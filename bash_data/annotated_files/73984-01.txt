29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=4 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is SpiderMonkey E4X code, released August, 2004.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
18863: #include "jsversion.h"
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: 
    1: #include <math.h>
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsbit.h"
    1: #include "jsprf.h"
    1: #include "jsutil.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
    1: #include "jscntxt.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
68933: #include "jsgcmark.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
    1: #include "jsparse.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
    1: #include "jsstr.h"
    1: #include "jsxml.h"
18989: #include "jsstaticcheck.h"
31884: #include "jsvector.h"
    1: 
48470: #include "jsatominlines.h"
40410: #include "jsobjinlines.h"
57817: #include "jsstrinlines.h"
40395: 
69223: #include "vm/Stack-inl.h"
69223: 
    1: #ifdef DEBUG
    1: #include <string.h>     /* for #ifdef DEBUG memset calls */
    1: #endif
    1: 
40221: using namespace js;
54707: using namespace js::gc;
40221: 
    1: /*
    1:  * NOTES
    1:  * - in the js shell, you must use the -x command line option, or call
    1:  *   options('xml') before compiling anything that uses XML literals
    1:  *
    1:  * TODO
    1:  * - XXXbe patrol
    1:  * - Fuse objects and their JSXML* private data into single GC-things
    1:  * - fix function::foo vs. x.(foo == 42) collision using proper namespacing
    1:  * - JSCLASS_DOCUMENT_OBSERVER support -- live two-way binding to Gecko's DOM!
    1:  */
    1: 
47494: static inline bool
47494: js_EnterLocalRootScope(JSContext *cx)
47494: {
47494:     return true;
47494: }
47494: 
47494: static inline void
47494: js_LeaveLocalRootScope(JSContext *cx)
47494: {
47494: }
47494: 
47494: static inline void
47494: js_LeaveLocalRootScopeWithResult(JSContext *cx, jsval rval)
47494: {
47494: }
47494: 
48470: static inline void
48470: js_LeaveLocalRootScopeWithResult(JSContext *cx, Value rval)
48470: {
48470: }
48470: 
48470: static inline void
48470: js_LeaveLocalRootScopeWithResult(JSContext *cx, void *rval)
48470: {
48470: }
48470: 
    1: /*
    1:  * Random utilities and global functions.
    1:  */
60566: const char js_AttributeName_str[] = "AttributeName";
    1: const char js_isXMLName_str[]     = "isXMLName";
    1: const char js_XMLList_str[]       = "XMLList";
    1: const char js_localName_str[]     = "localName";
    1: const char js_xml_parent_str[]    = "parent";
    1: const char js_prefix_str[]        = "prefix";
    1: const char js_toXMLString_str[]   = "toXMLString";
    1: const char js_uri_str[]           = "uri";
    1: 
    1: const char js_amp_entity_str[]    = "&amp;";
    1: const char js_gt_entity_str[]     = "&gt;";
    1: const char js_lt_entity_str[]     = "&lt;";
    1: const char js_quot_entity_str[]   = "&quot;";
41279: const char js_leftcurly_entity_str[]   = "&#123;";
    1: 
29366: #define IS_STAR(str)  ((str)->length() == 1 && *(str)->chars() == '*')
29366: 
18520: static JSBool
26187: GetXMLFunction(JSContext *cx, JSObject *obj, jsid id, jsval *vp);
26187: 
18520: static JSBool
18520: IsDeclared(const JSObject *obj)
18520: {
18520:     jsval v;
18520: 
48622:     JS_ASSERT(obj->getClass() == &js_NamespaceClass);
42693:     v = obj->getNamespaceDeclared();
18520:     JS_ASSERT(JSVAL_IS_VOID(v) || v == JSVAL_TRUE);
18520:     return v == JSVAL_TRUE;
18520: }
    1: 
    1: static JSBool
53557: xml_isXMLName(JSContext *cx, uintN argc, jsval *vp)
53557: {
53557:     *vp = BOOLEAN_TO_JSVAL(js_IsXMLName(cx, argc ? vp[2] : JSVAL_VOID));
    1:     return JS_TRUE;
    1: }
    1: 
56192: /*
56192:  * This wrapper is needed because NewBuiltinClassInstance doesn't
56192:  * call the constructor, and we need a place to set the
56192:  * HAS_EQUALITY bit.
56192:  */
56192: static inline JSObject *
56192: NewBuiltinClassInstanceXML(JSContext *cx, Class *clasp)
56192: {
56192:     JSObject *obj = NewBuiltinClassInstance(cx, clasp);
57806:     if (obj)
57806:         obj->syncSpecialEquality();
56192:     return obj;
56192: }
56192: 
43216: #define DEFINE_GETTER(name,code)                                               \
43216:     static JSBool                                                              \
48470:     name(JSContext *cx, JSObject *obj, jsid id, jsval *vp)                     \
43216:     {                                                                          \
43217:         code;                                                                  \
43216:         return true;                                                           \
43216:     }
43216: 
    1: /*
    1:  * Namespace class and library functions.
    1:  */
43216: DEFINE_GETTER(NamePrefix_getter,
59890:               if (obj->getClass() == &js_NamespaceClass) *vp = obj->getNamePrefixVal())
43216: DEFINE_GETTER(NameURI_getter,
59890:               if (obj->getClass() == &js_NamespaceClass) *vp = obj->getNameURIVal())
    1: 
    1: static JSBool
48470: namespace_equality(JSContext *cx, JSObject *obj, const Value *v, JSBool *bp)
    1: {
    1:     JSObject *obj2;
    1: 
48470:     JS_ASSERT(v->isObjectOrNull());
48470:     obj2 = v->toObjectOrNull();
48622:     *bp = (!obj2 || obj2->getClass() != &js_NamespaceClass)
18520:           ? JS_FALSE
59890:           : EqualStrings(obj->getNameURI(), obj2->getNameURI());
    1:     return JS_TRUE;
    1: }
    1: 
48622: JS_FRIEND_DATA(Class) js_NamespaceClass = {
48622:     "Namespace",
48622:     JSCLASS_CONSTRUCT_PROTOTYPE |
52503:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::NAMESPACE_CLASS_RESERVED_SLOTS) |
64218:     JSCLASS_HAS_CACHED_PROTO(JSProto_Namespace),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub,
61208:     FinalizeStub,
48622:     NULL,                 /* reserved0   */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
48622:     NULL,                 /* construct   */
48622:     NULL,                 /* xdrObject   */
48622:     NULL,                 /* hasInstance */
48622:     NULL,                 /* mark        */
48622:     {
48622:         namespace_equality,
48622:         NULL,             /* outerObject    */
48622:         NULL,             /* innerObject    */
48622:         NULL,             /* iteratorObject */
48622:         NULL,             /* wrappedObject  */
48622:     }
    1: };
    1: 
    1: #define NAMESPACE_ATTRS                                                       \
    1:     (JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT | JSPROP_SHARED)
    1: 
    1: static JSPropertySpec namespace_props[] = {
43216:     {js_prefix_str, 0, NAMESPACE_ATTRS, NamePrefix_getter, 0},
43216:     {js_uri_str,    0, NAMESPACE_ATTRS, NameURI_getter,    0},
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: static JSBool
53557: namespace_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return JS_FALSE;
67943:     if (!obj->isNamespace()) {
67943:         ReportIncompatibleMethod(cx, vp, &js_NamespaceClass);
67943:         return JS_FALSE;
67943:     }
59890:     *vp = Valueify(obj->getNameURIVal());
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSFunctionSpec namespace_methods[] = {
16519:     JS_FN(js_toString_str,  namespace_toString,        0,0),
 4127:     JS_FS_END
    1: };
    1: 
18520: static JSObject *
59890: NewXMLNamespace(JSContext *cx, JSLinearString *prefix, JSLinearString *uri, JSBool declared)
18520: {
14331:     JSObject *obj;
    1: 
56192:     obj = NewBuiltinClassInstanceXML(cx, &js_NamespaceClass);
18520:     if (!obj)
72069:         return NULL;
59890:     JS_ASSERT(JSVAL_IS_VOID(obj->getNamePrefixVal()));
59890:     JS_ASSERT(JSVAL_IS_VOID(obj->getNameURIVal()));
42693:     JS_ASSERT(JSVAL_IS_VOID(obj->getNamespaceDeclared()));
72069: 
72069:     /* Per ECMA-357, 13.2.5, these properties must be "own". */
72069:     if (!JS_DefineProperties(cx, obj, namespace_props))
72069:         return NULL;
72069: 
18520:     if (prefix)
59890:         obj->setNamePrefix(prefix);
18520:     if (uri)
59890:         obj->setNameURI(uri);
18520:     if (declared)
42693:         obj->setNamespaceDeclared(JSVAL_TRUE);
    1:     return obj;
    1: }
    1: 
    1: /*
    1:  * QName class and library functions.
    1:  */
43216: DEFINE_GETTER(QNameNameURI_getter,
48622:               if (obj->getClass() == &js_QNameClass)
59890:                   *vp = JSVAL_IS_VOID(obj->getNameURIVal()) ? JSVAL_NULL : obj->getNameURIVal())
43216: DEFINE_GETTER(QNameLocalName_getter,
48622:               if (obj->getClass() == &js_QNameClass)
59890:                   *vp = obj->getQNameLocalNameVal())
    1: 
18520: static JSBool
18520: qname_identity(JSObject *qna, JSObject *qnb)
18520: {
59890:     JSLinearString *uri1 = qna->getNameURI();
59890:     JSLinearString *uri2 = qnb->getNameURI();
18520: 
18520:     if (!uri1 ^ !uri2)
18520:         return JS_FALSE;
59890:     if (uri1 && !EqualStrings(uri1, uri2))
59890:         return JS_FALSE;
59890:     return EqualStrings(qna->getQNameLocalName(), qnb->getQNameLocalName());
18520: }
18520: 
18520: static JSBool
48470: qname_equality(JSContext *cx, JSObject *qn, const Value *v, JSBool *bp)
18520: {
    1:     JSObject *obj2;
    1: 
48470:     obj2 = v->toObjectOrNull();
48622:     *bp = (!obj2 || obj2->getClass() != &js_QNameClass)
18520:           ? JS_FALSE
18520:           : qname_identity(qn, obj2);
    1:     return JS_TRUE;
    1: }
    1: 
48622: JS_FRIEND_DATA(Class) js_QNameClass = {
48622:     "QName",
48622:     JSCLASS_CONSTRUCT_PROTOTYPE |
52503:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::QNAME_CLASS_RESERVED_SLOTS) |
64218:     JSCLASS_HAS_CACHED_PROTO(JSProto_QName),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub,
48622:     FinalizeStub,
48622:     NULL,                 /* reserved0   */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
48622:     NULL,                 /* construct   */
48622:     NULL,                 /* xdrObject   */
48622:     NULL,                 /* hasInstance */
48622:     NULL,                 /* mark        */
48622:     {
48622:         qname_equality,
48622:         NULL,             /* outerObject    */
48622:         NULL,             /* innerObject    */
48622:         NULL,             /* iteratorObject */
48622:         NULL,             /* wrappedObject  */
48622:     }
    1: };
    1: 
    1: /*
    1:  * Classes for the ECMA-357-internal types AttributeName and AnyName, which
    1:  * are like QName, except that they have no property getters.  They share the
    1:  * qname_toString method, and therefore are exposed as constructable objects
    1:  * in this implementation.
    1:  */
48470: JS_FRIEND_DATA(Class) js_AttributeNameClass = {
    1:     js_AttributeName_str,
18520:     JSCLASS_CONSTRUCT_PROTOTYPE |
52503:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::QNAME_CLASS_RESERVED_SLOTS) |
64218:     JSCLASS_IS_ANONYMOUS,
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
61208:     ConvertStub,
61208:     FinalizeStub
    1: };
    1: 
48470: JS_FRIEND_DATA(Class) js_AnyNameClass = {
    1:     js_AnyName_str,
18520:     JSCLASS_CONSTRUCT_PROTOTYPE |
52503:     JSCLASS_HAS_RESERVED_SLOTS(JSObject::QNAME_CLASS_RESERVED_SLOTS) |
64218:     JSCLASS_IS_ANONYMOUS,
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub,
61208:     FinalizeStub
    1: };
    1: 
48622: #define QNAME_ATTRS (JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT | JSPROP_SHARED)
    1: 
    1: static JSPropertySpec qname_props[] = {
43216:     {js_uri_str,       0, QNAME_ATTRS, QNameNameURI_getter,   0},
43216:     {js_localName_str, 0, QNAME_ATTRS, QNameLocalName_getter, 0},
    1:     {0,0,0,0,0}
    1: };
    1: 
60566: static JSString *
60566: ConvertQNameToString(JSContext *cx, JSObject *obj)
60566: {
60566:     JS_ASSERT(obj->isQName());
60566:     JSString *uri = obj->getNameURI();
60566:     JSString *str;
18520:     if (!uri) {
    1:         /* No uri means wildcard qualifier. */
64345:         str = cx->runtime->atomState.starQualifierAtom;
29366:     } else if (uri->empty()) {
    1:         /* Empty string for uri means localName is in no namespace. */
    1:         str = cx->runtime->emptyString;
    1:     } else {
64345:         JSString *qualstr = cx->runtime->atomState.qualifierAtom;
18520:         str = js_ConcatStrings(cx, uri, qualstr);
    1:         if (!str)
60566:             return NULL;
    1:     }
59890:     str = js_ConcatStrings(cx, str, obj->getQNameLocalName());
    1:     if (!str)
60566:         return NULL;
60566: 
60566:     if (obj->getClass() == &js_AttributeNameClass) {
63103:         JS::Anchor<JSString *> anchor(str);
60566:         size_t length = str->length();
64560:         jschar *chars = (jschar *) cx->malloc_((length + 2) * sizeof(jschar));
    1:         if (!chars)
    1:             return JS_FALSE;
    1:         *chars = '@';
59890:         const jschar *strChars = str->getChars(cx);
59890:         if (!strChars) {
64560:             cx->free_(chars);
60566:             return NULL;
59890:         }
59890:         js_strncpy(chars + 1, strChars, length);
    1:         chars[++length] = 0;
 4718:         str = js_NewString(cx, chars, length);
    1:         if (!str) {
64560:             cx->free_(chars);
60566:             return NULL;
60566:         }
60566:     }
60566:     return str;
60566: }
60566: 
60566: static JSBool
60566: qname_toString(JSContext *cx, uintN argc, Value *vp)
60566: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
67943:     if (!obj->isQName()) {
67943:         ReportIncompatibleMethod(cx, vp, &js_QNameClass);
60566:         return false;
67943:     }
60566: 
60566:     JSString *str = ConvertQNameToString(cx, obj);
60566:     if (!str)
60566:         return false;
    1: 
53557:     vp->setString(str);
60566:     return true;
    1: }
    1: 
    1: static JSFunctionSpec qname_methods[] = {
16519:     JS_FN(js_toString_str,  qname_toString,    0,0),
 4127:     JS_FS_END
    1: };
    1: 
18520: 
72069: static bool
72069: InitXMLQName(JSContext *cx, JSObject *obj, JSLinearString *uri, JSLinearString *prefix,
59890:              JSLinearString *localName)
59890: {
60566:     JS_ASSERT(obj->isQName());
59890:     JS_ASSERT(JSVAL_IS_VOID(obj->getNamePrefixVal()));
59890:     JS_ASSERT(JSVAL_IS_VOID(obj->getNameURIVal()));
59890:     JS_ASSERT(JSVAL_IS_VOID(obj->getQNameLocalNameVal()));
72069: 
72069:     /* Per ECMA-357, 13.3.5, these properties must be "own". */
72069:     if (!JS_DefineProperties(cx, obj, qname_props))
72069:         return false;
72069: 
18520:     if (uri)
59890:         obj->setNameURI(uri);
18520:     if (prefix)
59890:         obj->setNamePrefix(prefix);
18520:     if (localName)
59890:         obj->setQNameLocalName(localName);
72069:     return true;
18520: }
18520: 
18520: static JSObject *
59890: NewXMLQName(JSContext *cx, JSLinearString *uri, JSLinearString *prefix,
60566:             JSLinearString *localName)
60566: {
60566:     JSObject *obj = NewBuiltinClassInstanceXML(cx, &js_QNameClass);
60566:     if (!obj)
60566:         return NULL;
72069:     if (!InitXMLQName(cx, obj, uri, prefix, localName))
72069:         return NULL;
60566:     return obj;
60566: }
60566: 
60566: static JSObject *
60566: NewXMLAttributeName(JSContext *cx, JSLinearString *uri, JSLinearString *prefix,
60566:                     JSLinearString *localName)
60566: {
60566:     /*
60566:      * AttributeName is an internal anonymous class which instances are not
60566:      * exposed to scripts.
60566:      */
73984:     JSObject *parent = GetGlobalForScopeChain(cx);
73984:     JSObject *obj = NewNonFunction<WithProto::Given>(cx, &js_AttributeNameClass, NULL, parent);
18520:     if (!obj)
    1:         return NULL;
47429:     JS_ASSERT(obj->isQName());
72069:     if (!InitXMLQName(cx, obj, uri, prefix, localName))
72069:         return NULL;
    1:     return obj;
    1: }
    1: 
    1: JSObject *
48470: js_ConstructXMLQNameObject(JSContext *cx, const Value &nsval, const Value &lnval)
48470: {
48470:     Value argv[2];
    1: 
    1:     /*
    1:      * ECMA-357 11.1.2,
    1:      * The _QualifiedIdentifier : PropertySelector :: PropertySelector_
    1:      * production, step 2.
    1:      */
48470:     if (nsval.isObject() &&
48470:         nsval.toObject().getClass() == &js_AnyNameClass) {
48470:         argv[0].setNull();
48470:     } else {
    1:         argv[0] = nsval;
48470:     }
    1:     argv[1] = lnval;
48622:     return js_ConstructObject(cx, &js_QNameClass, NULL, NULL, 2, argv);
    1: }
    1: 
    1: static JSBool
    1: IsXMLName(const jschar *cp, size_t n)
    1: {
    1:     JSBool rv;
    1:     jschar c;
    1: 
    1:     rv = JS_FALSE;
    1:     if (n != 0 && JS_ISXMLNSSTART(*cp)) {
    1:         while (--n != 0) {
    1:             c = *++cp;
    1:             if (!JS_ISXMLNS(c))
    1:                 return rv;
    1:         }
    1:         rv = JS_TRUE;
    1:     }
    1:     return rv;
    1: }
    1: 
    1: JSBool
    1: js_IsXMLName(JSContext *cx, jsval v)
    1: {
59890:     JSLinearString *name = NULL;
    1:     JSErrorReporter older;
    1: 
    1:     /*
    1:      * Inline specialization of the QName constructor called with v passed as
    1:      * the only argument, to compute the localName for the constructed qname,
    1:      * without actually allocating the object or computing its uri and prefix.
    1:      * See ECMA-357 13.1.2.1 step 1 and 13.3.2.
    1:      */
    1:     if (!JSVAL_IS_PRIMITIVE(v) &&
42693:         JSVAL_TO_OBJECT(v)->isQName()) {
59890:         name = JSVAL_TO_OBJECT(v)->getQNameLocalName();
    1:     } else {
    1:         older = JS_SetErrorReporter(cx, NULL);
59890:         JSString *str = js_ValueToString(cx, Valueify(v));
59890:         if (str)
59890:             name = str->ensureLinear(cx);
    1:         JS_SetErrorReporter(cx, older);
    1:         if (!name) {
    1:             JS_ClearPendingException(cx);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
29366:     return IsXMLName(name->chars(), name->length());
    1: }
    1: 
16519: /*
16519:  * When argc is -1, it indicates argv is empty but the code should behave as
16519:  * if argc is 1 and argv[0] is JSVAL_VOID.
16519:  */
16519: static JSBool
16519: NamespaceHelper(JSContext *cx, JSObject *obj, intN argc, jsval *argv,
16012:                 jsval *rval)
    1: {
    1:     jsval urival, prefixval;
    1:     JSObject *uriobj;
    1:     JSBool isNamespace, isQName;
48470:     Class *clasp;
59890:     JSLinearString *empty, *prefix, *uri;
    1: 
16519:     isNamespace = isQName = JS_FALSE;
16519: #ifdef __GNUC__         /* suppress bogus gcc warnings */
16519:     uriobj = NULL;
16519: #endif
16519:     if (argc <= 0) {
16519:         urival = JSVAL_VOID;
16519:     } else {
    1:         urival = argv[argc > 1];
    1:         if (!JSVAL_IS_PRIMITIVE(urival)) {
    1:             uriobj = JSVAL_TO_OBJECT(urival);
40826:             clasp = uriobj->getClass();
48622:             isNamespace = (clasp == &js_NamespaceClass);
48622:             isQName = (clasp == &js_QNameClass);
    1:         }
16519:     }
    1: 
16012:     if (!obj) {
    1:         /* Namespace called as function. */
    1:         if (argc == 1 && isNamespace) {
    1:             /* Namespace called with one Namespace argument is identity. */
    1:             *rval = urival;
    1:             return JS_TRUE;
    1:         }
    1: 
56192:         obj = NewBuiltinClassInstanceXML(cx, &js_NamespaceClass);
    1:         if (!obj)
    1:             return JS_FALSE;
53557:     }
72069: 
72069:     /* Per ECMA-357, 13.2.5, these properties must be "own". */
72069:     if (!JS_DefineProperties(cx, obj, namespace_props))
72069:         return JS_FALSE;
72069: 
    1:     *rval = OBJECT_TO_JSVAL(obj);
18520: 
    1:     empty = cx->runtime->emptyString;
59890:     obj->setNamePrefix(empty);
59890:     obj->setNameURI(empty);
    1: 
16519:     if (argc == 1 || argc == -1) {
    1:         if (isNamespace) {
42693:             obj->setNameURI(uriobj->getNameURI());
42693:             obj->setNamePrefix(uriobj->getNamePrefix());
59890:         } else if (isQName && (uri = uriobj->getNameURI())) {
59890:             obj->setNameURI(uri);
42693:             obj->setNamePrefix(uriobj->getNamePrefix());
    1:         } else {
59890:             JSString *str = js_ValueToString(cx, Valueify(urival));
59890:             if (!str)
59890:                 return JS_FALSE;
59890:             uri = str->ensureLinear(cx);
18520:             if (!uri)
18520:                 return JS_FALSE;
59890:             obj->setNameURI(uri);
29366:             if (!uri->empty())
59890:                 obj->clearNamePrefix();
    1:         }
    1:     } else if (argc == 2) {
59890:         if (!isQName || !(uri = uriobj->getNameURI())) {
59890:             JSString *str = js_ValueToString(cx, Valueify(urival));
59890:             if (!str)
59890:                 return JS_FALSE;
59890:             uri = str->ensureLinear(cx);
18520:             if (!uri)
18520:                 return JS_FALSE;
18520:         }
59890:         obj->setNameURI(uri);
    1: 
    1:         prefixval = argv[0];
29366:         if (uri->empty()) {
    1:             if (!JSVAL_IS_VOID(prefixval)) {
59890:                 JSString *str = js_ValueToString(cx, Valueify(prefixval));
59890:                 if (!str)
59890:                     return JS_FALSE;
59890:                 if (!str->empty()) {
57812:                     JSAutoByteString bytes;
59890:                     if (js_ValueToPrintable(cx, StringValue(str), &bytes)) {
    1:                         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
57812:                                              JSMSG_BAD_XML_NAMESPACE, bytes.ptr());
57812:                     }
    1:                     return JS_FALSE;
    1:                 }
    1:             }
    1:         } else if (JSVAL_IS_VOID(prefixval) || !js_IsXMLName(cx, prefixval)) {
59890:             obj->clearNamePrefix();
    1:         } else {
59890:             JSString *str = js_ValueToString(cx, Valueify(prefixval));
59890:             if (!str)
59890:                 return JS_FALSE;
59890:             prefix = str->ensureLinear(cx);
    1:             if (!prefix)
    1:                 return JS_FALSE;
59890:             obj->setNamePrefix(prefix);
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
53557: Namespace(JSContext *cx, uintN argc, Value *vp)
53557: {
53557:     JSObject *thisobj = NULL;
53557:     (void)IsConstructing_PossiblyWithGivenThisObject(vp, &thisobj);
53557:     return NamespaceHelper(cx, thisobj, argc, Jsvalify(vp + 2), Jsvalify(vp));
16012: }
16012: 
16519: /*
16519:  * When argc is -1, it indicates argv is empty but the code should behave as
16519:  * if argc is 1 and argv[0] is JSVAL_VOID.
16519:  */
16519: static JSBool
60566: QNameHelper(JSContext *cx, JSObject *obj, intN argc, jsval *argv, jsval *rval)
    1: {
    1:     jsval nameval, nsval;
    1:     JSBool isQName, isNamespace;
18520:     JSObject *qn;
59890:     JSLinearString *uri, *prefix, *name;
18520:     JSObject *obj2;
    1: 
16519:     if (argc <= 0) {
16519:         nameval = JSVAL_VOID;
16519:         isQName = JS_FALSE;
16519:     } else {
    1:         nameval = argv[argc > 1];
    1:         isQName =
    1:             !JSVAL_IS_PRIMITIVE(nameval) &&
48622:             JSVAL_TO_OBJECT(nameval)->getClass() == &js_QNameClass;
16519:     }
    1: 
16012:     if (!obj) {
    1:         /* QName called as function. */
    1:         if (argc == 1 && isQName) {
    1:             /* QName called with one QName argument is identity. */
    1:             *rval = nameval;
    1:             return JS_TRUE;
    1:         }
    1: 
60566:         /* Create and return a new QName object exactly as if constructed. */
60566:         obj = NewBuiltinClassInstanceXML(cx, &js_QNameClass);
    1:         if (!obj)
    1:             return JS_FALSE;
53557:     }
    1:     *rval = OBJECT_TO_JSVAL(obj);
    1: 
    1:     if (isQName) {
    1:         /* If namespace is not specified and name is a QName, clone it. */
18520:         qn = JSVAL_TO_OBJECT(nameval);
    1:         if (argc == 1) {
59890:             uri = qn->getNameURI();
59890:             prefix = qn->getNamePrefix();
59890:             name = qn->getQNameLocalName();
    1:             goto out;
    1:         }
    1: 
    1:         /* Namespace and qname were passed -- use the qname's localName. */
59890:         nameval = qn->getQNameLocalNameVal();
    1:     }
    1: 
    1:     if (argc == 0) {
    1:         name = cx->runtime->emptyString;
16519:     } else if (argc < 0) {
64345:         name = cx->runtime->atomState.typeAtoms[JSTYPE_VOID];
    1:     } else {
59890:         JSString *str = js_ValueToString(cx, Valueify(nameval));
59890:         if (!str)
59890:             return JS_FALSE;
59890:         name = str->ensureLinear(cx);
    1:         if (!name)
    1:             return JS_FALSE;
16519:         argv[argc > 1] = STRING_TO_JSVAL(name);
16519:     }
16519: 
16519:     if (argc > 1 && !JSVAL_IS_VOID(argv[0])) {
    1:         nsval = argv[0];
16519:     } else if (IS_STAR(name)) {
    1:         nsval = JSVAL_NULL;
    1:     } else {
    1:         if (!js_GetDefaultXMLNamespace(cx, &nsval))
    1:             return JS_FALSE;
16519:         JS_ASSERT(!JSVAL_IS_PRIMITIVE(nsval));
40826:         JS_ASSERT(JSVAL_TO_OBJECT(nsval)->getClass() ==
48622:                   &js_NamespaceClass);
    1:     }
    1: 
    1:     if (JSVAL_IS_NULL(nsval)) {
    1:         /* NULL prefix represents *undefined* in ECMA-357 13.3.2 5(a). */
59890:         prefix = uri = NULL;
    1:     } else {
    1:         /*
    1:          * Inline specialization of the Namespace constructor called with
    1:          * nsval passed as the only argument, to compute the uri and prefix
    1:          * for the constructed namespace, without actually allocating the
    1:          * object or computing other members.  See ECMA-357 13.3.2 6(a) and
    1:          * 13.2.2.
    1:          */
    1:         isNamespace = isQName = JS_FALSE;
    1:         if (!JSVAL_IS_PRIMITIVE(nsval)) {
18520:             obj2 = JSVAL_TO_OBJECT(nsval);
60566:             isNamespace = (obj2->getClass() == &js_NamespaceClass);
60566:             isQName = (obj2->getClass() == &js_QNameClass);
    1:         }
    1: #ifdef __GNUC__         /* suppress bogus gcc warnings */
18520:         else obj2 = NULL;
    1: #endif
    1: 
    1:         if (isNamespace) {
59890:             uri = obj2->getNameURI();
59890:             prefix = obj2->getNamePrefix();
59890:         } else if (isQName && (uri = obj2->getNameURI())) {
16519:             JS_ASSERT(argc > 1);
59890:             prefix = obj2->getNamePrefix();
    1:         } else {
16519:             JS_ASSERT(argc > 1);
59890:             JSString *str = js_ValueToString(cx, Valueify(nsval));
59890:             if (!str)
59890:                 return JS_FALSE;
59890:             uri = str->ensureLinear(cx);
    1:             if (!uri)
    1:                 return JS_FALSE;
    1:             argv[0] = STRING_TO_JSVAL(uri);     /* local root */
    1: 
    1:             /* NULL here represents *undefined* in ECMA-357 13.2.2 3(c)iii. */
29366:             prefix = uri->empty() ? cx->runtime->emptyString : NULL;
    1:         }
    1:     }
    1: 
    1: out:
72069:     return InitXMLQName(cx, obj, uri, prefix, name);
    1: }
    1: 
    1: static JSBool
53557: QName(JSContext *cx, uintN argc, Value *vp)
53557: {
53557:     JSObject *thisobj = NULL;
53557:     (void)IsConstructing_PossiblyWithGivenThisObject(vp, &thisobj);
60566:     return QNameHelper(cx, thisobj, argc, Jsvalify(vp + 2), Jsvalify(vp));
    1: }
    1: 
    1: /*
    1:  * XMLArray library functions.
    1:  */
    1: static JSBool
    1: namespace_identity(const void *a, const void *b)
    1: {
18520:     const JSObject *nsa = (const JSObject *) a;
18520:     const JSObject *nsb = (const JSObject *) b;
59890:     JSLinearString *prefixa = nsa->getNamePrefix();
59890:     JSLinearString *prefixb = nsb->getNamePrefix();
18520: 
18520:     if (prefixa && prefixb) {
59890:         if (!EqualStrings(prefixa, prefixb))
    1:             return JS_FALSE;
    1:     } else {
18520:         if (prefixa || prefixb)
18520:             return JS_FALSE;
18520:     }
59890:     return EqualStrings(nsa->getNameURI(), nsb->getNameURI());
    1: }
    1: 
    1: static JSBool
    1: attr_identity(const void *a, const void *b)
    1: {
    1:     const JSXML *xmla = (const JSXML *) a;
    1:     const JSXML *xmlb = (const JSXML *) b;
    1: 
    1:     return qname_identity(xmla->name, xmlb->name);
    1: }
    1: 
54707: void
54707: JSXMLArrayCursor::trace(JSTracer *trc) {
54707: #ifdef DEBUG
54707:     size_t index = 0;
54707: #endif
54707:     for (JSXMLArrayCursor *cursor = this; cursor; cursor = cursor->next)
54707:         js::gc::MarkGCThing(trc, cursor->root, "cursor_root", index++);
54707: }
54707: 
    1: static void
  583: XMLArrayCursorTrace(JSTracer *trc, JSXMLArrayCursor *cursor)
  583: {
40383:     cursor->trace(trc);
    1: }
    1: 
47478: /* NB: called with null cx from the GC, via xml_trace => JSXMLArray::trim. */
47478: bool
47478: JSXMLArray::setCapacity(JSContext *cx, uint32 newCapacity)
47478: {
47478:     if (newCapacity == 0) {
    1:         /* We could let realloc(p, 0) free this, but purify gets confused. */
47478:         if (vector) {
30855:             if (cx)
64560:                 cx->free_(vector);
30855:             else
64560:                 Foreground::free_(vector);
30855:         }
    1:         vector = NULL;
    1:     } else {
47478:         void **tmp;
47478: 
 9975:         if (
 9975: #if JS_BITS_PER_WORD == 32
47478:             (size_t)newCapacity > ~(size_t)0 / sizeof(void *) ||
 9975: #endif
64560:             !(tmp = (void **) OffTheBooks::realloc_(vector, newCapacity * sizeof(void *)))) {
    1:             if (cx)
    1:                 JS_ReportOutOfMemory(cx);
47478:             return false;
47478:         }
47478:         vector = tmp;
47478:     }
47478:     capacity = JSXML_PRESET_CAPACITY | newCapacity;
47478:     return true;
47478: }
47478: 
47478: void
47478: JSXMLArray::trim()
47478: {
47478:     if (capacity & JSXML_PRESET_CAPACITY)
    1:         return;
47478:     if (length < capacity)
47478:         setCapacity(NULL, length);
47478: }
47478: 
47478: void
47478: JSXMLArray::finish(JSContext *cx)
47478: {
64560:     cx->free_(vector);
47478: 
47478:     while (JSXMLArrayCursor *cursor = cursors)
31884:         cursor->disconnect();
    1: 
    1: #ifdef DEBUG
47478:     memset(this, 0xd5, sizeof *this);
    1: #endif
    1: }
    1: 
    1: #define XML_NOT_FOUND   ((uint32) -1)
    1: 
    1: static uint32
    1: XMLArrayFindMember(const JSXMLArray *array, void *elt, JSIdentityOp identity)
    1: {
    1:     void **vector;
    1:     uint32 i, n;
    1: 
    1:     /* The identity op must not reallocate array->vector. */
    1:     vector = array->vector;
    1:     if (identity) {
    1:         for (i = 0, n = array->length; i < n; i++) {
    1:             if (identity(vector[i], elt))
    1:                 return i;
    1:         }
    1:     } else {
    1:         for (i = 0, n = array->length; i < n; i++) {
    1:             if (vector[i] == elt)
    1:                 return i;
    1:         }
    1:     }
    1:     return XML_NOT_FOUND;
    1: }
    1: 
    1: /*
    1:  * Grow array vector capacity by powers of two to LINEAR_THRESHOLD, and after
    1:  * that, grow by LINEAR_INCREMENT.  Both must be powers of two, and threshold
    1:  * should be greater than increment.
    1:  */
    1: #define LINEAR_THRESHOLD        256
    1: #define LINEAR_INCREMENT        32
    1: 
    1: static JSBool
    1: XMLArrayAddMember(JSContext *cx, JSXMLArray *array, uint32 index, void *elt)
    1: {
    1:     uint32 capacity, i;
    1:     int log2;
    1:     void **vector;
    1: 
    1:     if (index >= array->length) {
    1:         if (index >= JSXML_CAPACITY(array)) {
    1:             /* Arrange to clear JSXML_PRESET_CAPACITY from array->capacity. */
    1:             capacity = index + 1;
    1:             if (index >= LINEAR_THRESHOLD) {
    1:                 capacity = JS_ROUNDUP(capacity, LINEAR_INCREMENT);
    1:             } else {
    1:                 JS_CEILING_LOG2(log2, capacity);
    1:                 capacity = JS_BIT(log2);
    1:             }
 9975:             if (
 9975: #if JS_BITS_PER_WORD == 32
 9975:                 (size_t)capacity > ~(size_t)0 / sizeof(void *) ||
 9975: #endif
    1:                 !(vector = (void **)
64560:                            cx->realloc_(array->vector, capacity * sizeof(void *)))) {
    1:                 JS_ReportOutOfMemory(cx);
    1:                 return JS_FALSE;
    1:             }
    1:             array->capacity = capacity;
    1:             array->vector = vector;
    1:             for (i = array->length; i < index; i++)
    1:                 vector[i] = NULL;
    1:         }
    1:         array->length = index + 1;
    1:     }
    1: 
    1:     array->vector[index] = elt;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: XMLArrayInsert(JSContext *cx, JSXMLArray *array, uint32 i, uint32 n)
    1: {
    1:     uint32 j;
    1:     JSXMLArrayCursor *cursor;
    1: 
    1:     j = array->length;
    1:     JS_ASSERT(i <= j);
47478:     if (!array->setCapacity(cx, j + n))
    1:         return JS_FALSE;
    1: 
    1:     array->length = j + n;
    1:     JS_ASSERT(n != (uint32)-1);
    1:     while (j != i) {
    1:         --j;
    1:         array->vector[j + n] = array->vector[j];
    1:     }
    1: 
    1:     for (cursor = array->cursors; cursor; cursor = cursor->next) {
    1:         if (cursor->index > i)
    1:             cursor->index += n;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static void *
    1: XMLArrayDelete(JSContext *cx, JSXMLArray *array, uint32 index, JSBool compress)
    1: {
    1:     uint32 length;
    1:     void **vector, *elt;
    1:     JSXMLArrayCursor *cursor;
    1: 
    1:     length = array->length;
    1:     if (index >= length)
    1:         return NULL;
    1: 
    1:     vector = array->vector;
    1:     elt = vector[index];
    1:     if (compress) {
    1:         while (++index < length)
    1:             vector[index-1] = vector[index];
    1:         array->length = length - 1;
    1:         array->capacity = JSXML_CAPACITY(array);
    1:     } else {
    1:         vector[index] = NULL;
    1:     }
    1: 
    1:     for (cursor = array->cursors; cursor; cursor = cursor->next) {
    1:         if (cursor->index > index)
    1:             --cursor->index;
    1:     }
    1:     return elt;
    1: }
    1: 
    1: static void
    1: XMLArrayTruncate(JSContext *cx, JSXMLArray *array, uint32 length)
    1: {
    1:     void **vector;
    1: 
    1:     JS_ASSERT(!array->cursors);
    1:     if (length >= array->length)
    1:         return;
    1: 
    1:     if (length == 0) {
    1:         if (array->vector)
64560:             cx->free_(array->vector);
    1:         vector = NULL;
    1:     } else {
64560:         vector = (void **) cx->realloc_(array->vector, length * sizeof(void *));
    1:         if (!vector)
    1:             return;
    1:     }
    1: 
    1:     if (array->length > length)
    1:         array->length = length;
    1:     array->capacity = length;
    1:     array->vector = vector;
    1: }
    1: 
    1: #define XMLARRAY_FIND_MEMBER(a,e,f) XMLArrayFindMember(a, (void *)(e), f)
    1: #define XMLARRAY_HAS_MEMBER(a,e,f)  (XMLArrayFindMember(a, (void *)(e), f) != \
    1:                                      XML_NOT_FOUND)
    1: #define XMLARRAY_MEMBER(a,i,t)      (((i) < (a)->length)                      \
    1:                                      ? (t *) (a)->vector[i]                   \
    1:                                      : NULL)
    1: #define XMLARRAY_SET_MEMBER(a,i,e)  JS_BEGIN_MACRO                            \
    1:                                         if ((a)->length <= (i))               \
    1:                                             (a)->length = (i) + 1;            \
    1:                                         ((a)->vector[i] = (void *)(e));       \
    1:                                     JS_END_MACRO
    1: #define XMLARRAY_ADD_MEMBER(x,a,i,e)XMLArrayAddMember(x, a, i, (void *)(e))
    1: #define XMLARRAY_INSERT(x,a,i,n)    XMLArrayInsert(x, a, i, n)
    1: #define XMLARRAY_APPEND(x,a,e)      XMLARRAY_ADD_MEMBER(x, a, (a)->length, (e))
    1: #define XMLARRAY_DELETE(x,a,i,c,t)  ((t *) XMLArrayDelete(x, a, i, c))
    1: #define XMLARRAY_TRUNCATE(x,a,n)    XMLArrayTruncate(x, a, n)
    1: 
    1: /*
    1:  * Define XML setting property strings and constants early, so everyone can
43216:  * use the same names.
    1:  */
    1: static const char js_ignoreComments_str[]   = "ignoreComments";
    1: static const char js_ignoreProcessingInstructions_str[]
    1:                                             = "ignoreProcessingInstructions";
    1: static const char js_ignoreWhitespace_str[] = "ignoreWhitespace";
    1: static const char js_prettyPrinting_str[]   = "prettyPrinting";
    1: static const char js_prettyIndent_str[]     = "prettyIndent";
    1: 
43216: #define XSF_IGNORE_COMMENTS                JS_BIT(0)
43216: #define XSF_IGNORE_PROCESSING_INSTRUCTIONS JS_BIT(1)
43216: #define XSF_IGNORE_WHITESPACE              JS_BIT(2)
43216: #define XSF_PRETTY_PRINTING                JS_BIT(3)
    1: 
    1: static JSPropertySpec xml_static_props[] = {
43216:     {js_ignoreComments_str, 0, JSPROP_PERMANENT, NULL, NULL},
43216:     {js_ignoreProcessingInstructions_str, 0, JSPROP_PERMANENT, NULL, NULL},
43216:     {js_ignoreWhitespace_str, 0, JSPROP_PERMANENT, NULL, NULL},
43216:     {js_prettyPrinting_str, 0, JSPROP_PERMANENT, NULL, NULL},
43216:     {js_prettyIndent_str, 0, JSPROP_PERMANENT, NULL, NULL},
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: /* Macros for special-casing xml:, xmlns= and xmlns:foo= in ParseNodeToQName. */
    1: #define IS_XML(str)                                                           \
29366:     (str->length() == 3 && IS_XML_CHARS(str->chars()))
    1: 
    1: #define IS_XMLNS(str)                                                         \
29366:     (str->length() == 5 && IS_XMLNS_CHARS(str->chars()))
    1: 
    1: #define IS_XML_CHARS(chars)                                                   \
    1:     (JS_TOLOWER((chars)[0]) == 'x' &&                                         \
    1:      JS_TOLOWER((chars)[1]) == 'm' &&                                         \
    1:      JS_TOLOWER((chars)[2]) == 'l')
    1: 
    1: #define HAS_NS_AFTER_XML(chars)                                               \
    1:     (JS_TOLOWER((chars)[3]) == 'n' &&                                         \
    1:      JS_TOLOWER((chars)[4]) == 's')
    1: 
    1: #define IS_XMLNS_CHARS(chars)                                                 \
    1:     (IS_XML_CHARS(chars) && HAS_NS_AFTER_XML(chars))
    1: 
    1: #define STARTS_WITH_XML(chars,length)                                         \
    1:     (length >= 3 && IS_XML_CHARS(chars))
    1: 
    1: static const char xml_namespace_str[] = "http://www.w3.org/XML/1998/namespace";
    1: static const char xmlns_namespace_str[] = "http://www.w3.org/2000/xmlns/";
    1: 
18520: static JSObject *
40860: ParseNodeToQName(Parser *parser, JSParseNode *pn,
 7984:                  JSXMLArray *inScopeNSes, JSBool isAttributeName)
    1: {
40860:     JSContext *cx = parser->context;
59890:     JSLinearString *str, *uri, *prefix, *localName;
    1:     size_t length, offset;
    1:     const jschar *start, *limit, *colon;
    1:     uint32 n;
18520:     JSObject *ns;
59890:     JSLinearString *nsprefix;
    1: 
    1:     JS_ASSERT(pn->pn_arity == PN_NULLARY);
59890:     str = pn->pn_atom;
59890:     start = str->chars();
59890:     length = str->length();
    1:     JS_ASSERT(length != 0 && *start != '@');
    1:     JS_ASSERT(length != 1 || *start != '*');
    1: 
    1:     uri = cx->runtime->emptyString;
    1:     limit = start + length;
    1:     colon = js_strchr_limit(start, ':', limit);
    1:     if (colon) {
25144:         offset = colon - start;
 4076:         prefix = js_NewDependentString(cx, str, 0, offset);
    1:         if (!prefix)
    1:             return NULL;
    1: 
    1:         if (STARTS_WITH_XML(start, offset)) {
    1:             if (offset == 3) {
59890:                 uri = JS_ASSERT_STRING_IS_FLAT(JS_InternString(cx, xml_namespace_str));
    1:                 if (!uri)
    1:                     return NULL;
    1:             } else if (offset == 5 && HAS_NS_AFTER_XML(start)) {
59890:                 uri = JS_ASSERT_STRING_IS_FLAT(JS_InternString(cx, xmlns_namespace_str));
    1:                 if (!uri)
    1:                     return NULL;
    1:             } else {
    1:                 uri = NULL;
    1:             }
    1:         } else {
    1:             uri = NULL;
    1:             n = inScopeNSes->length;
    1:             while (n != 0) {
    1:                 --n;
18520:                 ns = XMLARRAY_MEMBER(inScopeNSes, n, JSObject);
59890:                 nsprefix = ns->getNamePrefix();
59890:                 if (nsprefix && EqualStrings(nsprefix, prefix)) {
59890:                     uri = ns->getNameURI();
    1:                     break;
    1:                 }
    1:             }
    1:         }
    1: 
    1:         if (!uri) {
48470:             Value v = StringValue(prefix);
57812:             JSAutoByteString bytes;
57812:             if (js_ValueToPrintable(parser->context, v, &bytes)) {
40860:                 ReportCompileErrorNumber(parser->context, &parser->tokenStream, pn,
57812:                                          JSREPORT_ERROR, JSMSG_BAD_XML_NAMESPACE, bytes.ptr());
57812:             }
    1:             return NULL;
    1:         }
    1: 
40860:         localName = js_NewStringCopyN(parser->context, colon + 1, length - (offset + 1));
    1:         if (!localName)
    1:             return NULL;
    1:     } else {
    1:         if (isAttributeName) {
    1:             /*
    1:              * An unprefixed attribute is not in any namespace, so set prefix
    1:              * as well as uri to the empty string.
    1:              */
    1:             prefix = uri;
    1:         } else {
    1:             /*
    1:              * Loop from back to front looking for the closest declared default
    1:              * namespace.
    1:              */
    1:             n = inScopeNSes->length;
    1:             while (n != 0) {
    1:                 --n;
18520:                 ns = XMLARRAY_MEMBER(inScopeNSes, n, JSObject);
59890:                 nsprefix = ns->getNamePrefix();
29366:                 if (!nsprefix || nsprefix->empty()) {
59890:                     uri = ns->getNameURI();
    1:                     break;
    1:                 }
    1:             }
40860:             prefix = uri->empty() ? parser->context->runtime->emptyString : NULL;
    1:         }
    1:         localName = str;
    1:     }
    1: 
40860:     return NewXMLQName(parser->context, uri, prefix, localName);
    1: }
    1: 
    1: static JSString *
    1: ChompXMLWhitespace(JSContext *cx, JSString *str)
    1: {
    1:     size_t length, newlength, offset;
    1:     const jschar *cp, *start, *end;
    1:     jschar c;
    1: 
59890:     length = str->length();
59890:     start = str->getChars(cx);
59890:     if (!start)
59890:         return NULL;
59890: 
 4718:     for (cp = start, end = cp + length; cp < end; cp++) {
    1:         c = *cp;
    1:         if (!JS_ISXMLSPACE(c))
    1:             break;
    1:     }
    1:     while (end > cp) {
    1:         c = end[-1];
    1:         if (!JS_ISXMLSPACE(c))
    1:             break;
    1:         --end;
    1:     }
25144:     newlength = end - cp;
    1:     if (newlength == length)
    1:         return str;
25144:     offset = cp - start;
 4076:     return js_NewDependentString(cx, str, offset, newlength);
    1: }
    1: 
    1: static JSXML *
40860: ParseNodeToXML(Parser *parser, JSParseNode *pn,
 7984:                JSXMLArray *inScopeNSes, uintN flags)
    1: {
40860:     JSContext *cx = parser->context;
    1:     JSXML *xml, *kid, *attr, *attrj;
59890:     JSLinearString *str;
    1:     uint32 length, n, i, j;
    1:     JSParseNode *pn2, *pn3, *head, **pnp;
18520:     JSObject *ns;
18520:     JSObject *qn, *attrjqn;
    1:     JSXMLClass xml_class;
    1:     int stackDummy;
    1: 
54707:     if (!JS_CHECK_STACK_SIZE(cx->stackLimit, &stackDummy)) {
40860:         ReportCompileErrorNumber(cx, &parser->tokenStream, pn, JSREPORT_ERROR,
    1:                                  JSMSG_OVER_RECURSED);
    1:         return NULL;
    1:     }
    1: 
    1: #define PN2X_SKIP_CHILD ((JSXML *) 1)
    1: 
    1:     /*
    1:      * Cases return early to avoid common code that gets an outermost xml's
    1:      * object, which protects GC-things owned by xml and its descendants from
    1:      * garbage collection.
    1:      */
    1:     xml = NULL;
    1:     if (!js_EnterLocalRootScope(cx))
    1:         return NULL;
    1:     switch (pn->pn_type) {
    1:       case TOK_XMLELEM:
    1:         length = inScopeNSes->length;
    1:         pn2 = pn->pn_head;
40860:         xml = ParseNodeToXML(parser, pn2, inScopeNSes, flags);
    1:         if (!xml)
    1:             goto fail;
    1: 
    1:         n = pn->pn_count;
    1:         JS_ASSERT(n >= 2);
    1:         n -= 2;
47478:         if (!xml->xml_kids.setCapacity(cx, n))
    1:             goto fail;
    1: 
    1:         i = 0;
    1:         while ((pn2 = pn2->pn_next) != NULL) {
    1:             if (!pn2->pn_next) {
    1:                 /* Don't append the end tag! */
    1:                 JS_ASSERT(pn2->pn_type == TOK_XMLETAGO);
    1:                 break;
    1:             }
    1: 
    1:             if ((flags & XSF_IGNORE_WHITESPACE) &&
    1:                 n > 1 && pn2->pn_type == TOK_XMLSPACE) {
    1:                 --n;
    1:                 continue;
    1:             }
    1: 
40860:             kid = ParseNodeToXML(parser, pn2, inScopeNSes, flags);
    1:             if (kid == PN2X_SKIP_CHILD) {
    1:                 --n;
    1:                 continue;
    1:             }
    1: 
    1:             if (!kid)
    1:                 goto fail;
    1: 
    1:             /* Store kid in xml right away, to protect it from GC. */
    1:             XMLARRAY_SET_MEMBER(&xml->xml_kids, i, kid);
    1:             kid->parent = xml;
    1:             ++i;
    1: 
    1:             /* XXX where is this documented in an XML spec, or in E4X? */
    1:             if ((flags & XSF_IGNORE_WHITESPACE) &&
    1:                 n > 1 && kid->xml_class == JSXML_CLASS_TEXT) {
59890:                 JSString *str = ChompXMLWhitespace(cx, kid->xml_value);
    1:                 if (!str)
    1:                     goto fail;
    1:                 kid->xml_value = str;
    1:             }
    1:         }
    1: 
    1:         JS_ASSERT(i == n);
    1:         if (n < pn->pn_count - 2)
47478:             xml->xml_kids.trim();
    1:         XMLARRAY_TRUNCATE(cx, inScopeNSes, length);
    1:         break;
    1: 
    1:       case TOK_XMLLIST:
    1:         xml = js_NewXML(cx, JSXML_CLASS_LIST);
    1:         if (!xml)
    1:             goto fail;
    1: 
    1:         n = pn->pn_count;
47478:         if (!xml->xml_kids.setCapacity(cx, n))
    1:             goto fail;
    1: 
    1:         i = 0;
    1:         for (pn2 = pn->pn_head; pn2; pn2 = pn2->pn_next) {
    1:             /*
    1:              * Always ignore insignificant whitespace in lists -- we shouldn't
    1:              * condition this on an XML.ignoreWhitespace setting when the list
    1:              * constructor is XMLList (note XML/XMLList unification hazard).
    1:              */
    1:             if (pn2->pn_type == TOK_XMLSPACE) {
    1:                 --n;
    1:                 continue;
    1:             }
    1: 
40860:             kid = ParseNodeToXML(parser, pn2, inScopeNSes, flags);
    1:             if (kid == PN2X_SKIP_CHILD) {
    1:                 --n;
    1:                 continue;
    1:             }
    1: 
    1:             if (!kid)
    1:                 goto fail;
    1: 
    1:             XMLARRAY_SET_MEMBER(&xml->xml_kids, i, kid);
    1:             ++i;
    1:         }
    1: 
    1:         if (n < pn->pn_count)
47478:             xml->xml_kids.trim();
    1:         break;
    1: 
    1:       case TOK_XMLSTAGO:
    1:       case TOK_XMLPTAGC:
    1:         length = inScopeNSes->length;
    1:         pn2 = pn->pn_head;
    1:         JS_ASSERT(pn2->pn_type == TOK_XMLNAME);
    1:         if (pn2->pn_arity == PN_LIST)
    1:             goto syntax;
    1: 
    1:         xml = js_NewXML(cx, JSXML_CLASS_ELEMENT);
    1:         if (!xml)
    1:             goto fail;
    1: 
    1:         /* First pass: check syntax and process namespace declarations. */
    1:         JS_ASSERT(pn->pn_count >= 1);
    1:         n = pn->pn_count - 1;
    1:         pnp = &pn2->pn_next;
    1:         head = *pnp;
    1:         while ((pn2 = *pnp) != NULL) {
    1:             size_t length;
    1:             const jschar *chars;
    1: 
    1:             if (pn2->pn_type != TOK_XMLNAME || pn2->pn_arity != PN_NULLARY)
    1:                 goto syntax;
    1: 
    1:             /* Enforce "Well-formedness constraint: Unique Att Spec". */
    1:             for (pn3 = head; pn3 != pn2; pn3 = pn3->pn_next->pn_next) {
    1:                 if (pn3->pn_atom == pn2->pn_atom) {
64345:                     Value v = StringValue(pn2->pn_atom);
57812:                     JSAutoByteString bytes;
57812:                     if (js_ValueToPrintable(cx, v, &bytes)) {
40860:                         ReportCompileErrorNumber(cx, &parser->tokenStream, pn2,
40320:                                                  JSREPORT_ERROR, JSMSG_DUPLICATE_XML_ATTR,
57812:                                                  bytes.ptr());
57812:                     }
    1:                     goto fail;
    1:                 }
    1:             }
    1: 
59890:             JSAtom *atom = pn2->pn_atom;
    1:             pn2 = pn2->pn_next;
    1:             JS_ASSERT(pn2);
    1:             if (pn2->pn_type != TOK_XMLATTR)
    1:                 goto syntax;
    1: 
59890:             chars = atom->chars();
59890:             length = atom->length();
    1:             if (length >= 5 &&
    1:                 IS_XMLNS_CHARS(chars) &&
    1:                 (length == 5 || chars[5] == ':')) {
59890:                 JSLinearString *uri, *prefix;
    1: 
64345:                 uri = pn2->pn_atom;
    1:                 if (length == 5) {
    1:                     /* 10.3.2.1. Step 6(h)(i)(1)(a). */
    1:                     prefix = cx->runtime->emptyString;
    1:                 } else {
 4076:                     prefix = js_NewStringCopyN(cx, chars + 6, length - 6);
    1:                     if (!prefix)
    1:                         goto fail;
    1:                 }
    1: 
    1:                 /*
    1:                  * Once the new ns is appended to xml->xml_namespaces, it is
    1:                  * protected from GC by the object that owns xml -- which is
    1:                  * either xml->object if outermost, or the object owning xml's
    1:                  * oldest ancestor if !outermost.
    1:                  */
18520:                 ns = NewXMLNamespace(cx, prefix, uri, JS_TRUE);
    1:                 if (!ns)
    1:                     goto fail;
    1: 
    1:                 /*
    1:                  * Don't add a namespace that's already in scope.  If someone
    1:                  * extracts a child property from its parent via [[Get]], then
    1:                  * we enforce the invariant, noted many times in ECMA-357, that
    1:                  * the child's namespaces form a possibly-improper superset of
    1:                  * its ancestors' namespaces.
    1:                  */
    1:                 if (!XMLARRAY_HAS_MEMBER(inScopeNSes, ns, namespace_identity)) {
    1:                     if (!XMLARRAY_APPEND(cx, inScopeNSes, ns) ||
    1:                         !XMLARRAY_APPEND(cx, &xml->xml_namespaces, ns)) {
    1:                         goto fail;
    1:                     }
    1:                 }
    1: 
    1:                 JS_ASSERT(n >= 2);
    1:                 n -= 2;
    1:                 *pnp = pn2->pn_next;
    1:                 /* XXXbe recycle pn2 */
    1:                 continue;
    1:             }
    1: 
    1:             pnp = &pn2->pn_next;
    1:         }
    1: 
47478:         xml->xml_namespaces.trim();
    1: 
    1:         /* Second pass: process tag name and attributes, using namespaces. */
    1:         pn2 = pn->pn_head;
40860:         qn = ParseNodeToQName(parser, pn2, inScopeNSes, JS_FALSE);
    1:         if (!qn)
    1:             goto fail;
    1:         xml->name = qn;
    1: 
    1:         JS_ASSERT((n & 1) == 0);
    1:         n >>= 1;
47478:         if (!xml->xml_attrs.setCapacity(cx, n))
    1:             goto fail;
    1: 
    1:         for (i = 0; (pn2 = pn2->pn_next) != NULL; i++) {
40860:             qn = ParseNodeToQName(parser, pn2, inScopeNSes, JS_TRUE);
    1:             if (!qn) {
    1:                 xml->xml_attrs.length = i;
    1:                 goto fail;
    1:             }
    1: 
    1:             /*
    1:              * Enforce "Well-formedness constraint: Unique Att Spec", part 2:
    1:              * this time checking local name and namespace URI.
    1:              */
    1:             for (j = 0; j < i; j++) {
    1:                 attrj = XMLARRAY_MEMBER(&xml->xml_attrs, j, JSXML);
    1:                 attrjqn = attrj->name;
59890:                 if (EqualStrings(attrjqn->getNameURI(), qn->getNameURI()) &&
59890:                     EqualStrings(attrjqn->getQNameLocalName(), qn->getQNameLocalName())) {
64345:                     Value v = StringValue(pn2->pn_atom);
57812:                     JSAutoByteString bytes;
57812:                     if (js_ValueToPrintable(cx, v, &bytes)) {
40860:                         ReportCompileErrorNumber(cx, &parser->tokenStream, pn2,
40320:                                                  JSREPORT_ERROR, JSMSG_DUPLICATE_XML_ATTR,
57812:                                                  bytes.ptr());
57812:                     }
    1:                     goto fail;
    1:                 }
    1:             }
    1: 
    1:             pn2 = pn2->pn_next;
    1:             JS_ASSERT(pn2);
    1:             JS_ASSERT(pn2->pn_type == TOK_XMLATTR);
    1: 
    1:             attr = js_NewXML(cx, JSXML_CLASS_ATTRIBUTE);
    1:             if (!attr)
    1:                 goto fail;
    1: 
    1:             XMLARRAY_SET_MEMBER(&xml->xml_attrs, i, attr);
    1:             attr->parent = xml;
    1:             attr->name = qn;
64345:             attr->xml_value = pn2->pn_atom;
    1:         }
    1: 
    1:         /* Point tag closes its own namespace scope. */
    1:         if (pn->pn_type == TOK_XMLPTAGC)
    1:             XMLARRAY_TRUNCATE(cx, inScopeNSes, length);
    1:         break;
    1: 
    1:       case TOK_XMLSPACE:
    1:       case TOK_XMLTEXT:
    1:       case TOK_XMLCDATA:
    1:       case TOK_XMLCOMMENT:
    1:       case TOK_XMLPI:
64345:         str = pn->pn_atom;
    1:         qn = NULL;
    1:         if (pn->pn_type == TOK_XMLCOMMENT) {
    1:             if (flags & XSF_IGNORE_COMMENTS)
    1:                 goto skip_child;
    1:             xml_class = JSXML_CLASS_COMMENT;
    1:         } else if (pn->pn_type == TOK_XMLPI) {
    1:             if (IS_XML(str)) {
48470:                 Value v = StringValue(str);
57812:                 JSAutoByteString bytes;
57812:                 if (js_ValueToPrintable(cx, v, &bytes)) {
40860:                     ReportCompileErrorNumber(cx, &parser->tokenStream, pn,
57812:                                              JSREPORT_ERROR, JSMSG_RESERVED_ID, bytes.ptr());
57812:                 }
    1:                 goto fail;
    1:             }
    1: 
    1:             if (flags & XSF_IGNORE_PROCESSING_INSTRUCTIONS)
    1:                 goto skip_child;
    1: 
40860:             qn = ParseNodeToQName(parser, pn, inScopeNSes, JS_FALSE);
    1:             if (!qn)
    1:                 goto fail;
    1: 
64345:             str = pn->pn_atom2 ? pn->pn_atom2 : cx->runtime->emptyString;
    1:             xml_class = JSXML_CLASS_PROCESSING_INSTRUCTION;
    1:         } else {
    1:             /* CDATA section content, or element text. */
    1:             xml_class = JSXML_CLASS_TEXT;
    1:         }
    1: 
    1:         xml = js_NewXML(cx, xml_class);
    1:         if (!xml)
    1:             goto fail;
    1:         xml->name = qn;
    1:         if (pn->pn_type == TOK_XMLSPACE)
    1:             xml->xml_flags |= XMLF_WHITESPACE_TEXT;
    1:         xml->xml_value = str;
    1:         break;
    1: 
    1:       default:
    1:         goto syntax;
    1:     }
    1: 
48470:     js_LeaveLocalRootScopeWithResult(cx, xml);
    1:     return xml;
    1: 
    1: skip_child:
    1:     js_LeaveLocalRootScope(cx);
    1:     return PN2X_SKIP_CHILD;
    1: 
    1: #undef PN2X_SKIP_CHILD
    1: 
    1: syntax:
40860:     ReportCompileErrorNumber(cx, &parser->tokenStream, pn, JSREPORT_ERROR, JSMSG_BAD_XML_MARKUP);
    1: fail:
    1:     js_LeaveLocalRootScope(cx);
    1:     return NULL;
    1: }
    1: 
    1: /*
    1:  * XML helper, object-ops, and library functions.  We start with the helpers,
    1:  * in ECMA-357 order, but merging XML (9.1) and XMLList (9.2) helpers.
    1:  */
    1: static JSBool
    1: GetXMLSetting(JSContext *cx, const char *name, jsval *vp)
    1: {
    1:     jsval v;
    1: 
48470:     if (!js_FindClassObject(cx, NULL, JSProto_XML, Valueify(&v)))
    1:         return JS_FALSE;
    1:     if (!VALUE_IS_FUNCTION(cx, v)) {
    1:         *vp = JSVAL_VOID;
    1:         return JS_TRUE;
    1:     }
    1:     return JS_GetProperty(cx, JSVAL_TO_OBJECT(v), name, vp);
    1: }
    1: 
    1: static JSBool
43216: GetBooleanXMLSetting(JSContext *cx, const char *name, JSBool *bp)
43216: {
    1:     jsval v;
    1: 
43216:     return GetXMLSetting(cx, name, &v) && JS_ValueToBoolean(cx, v, bp);
    1: }
    1: 
    1: static JSBool
    1: GetUint32XMLSetting(JSContext *cx, const char *name, uint32 *uip)
    1: {
    1:     jsval v;
    1: 
12681:     return GetXMLSetting(cx, name, &v) && JS_ValueToECMAUint32(cx, v, uip);
    1: }
    1: 
    1: static JSBool
    1: GetXMLSettingFlags(JSContext *cx, uintN *flagsp)
    1: {
43216:     JSBool flag[4];
43216: 
43216:     if (!GetBooleanXMLSetting(cx, js_ignoreComments_str, &flag[0]) ||
43216:         !GetBooleanXMLSetting(cx, js_ignoreProcessingInstructions_str, &flag[1]) ||
43216:         !GetBooleanXMLSetting(cx, js_ignoreWhitespace_str, &flag[2]) ||
43216:         !GetBooleanXMLSetting(cx, js_prettyPrinting_str, &flag[3])) {
43216:         return false;
43216:     }
43216: 
43216:     *flagsp = 0;
43216:     for (size_t n = 0; n < 4; ++n)
43216:         if (flag[n])
43216:             *flagsp |= JS_BIT(n);
43216:     return true;
    1: }
    1: 
    1: static JSXML *
    1: ParseXMLSource(JSContext *cx, JSString *src)
    1: {
    1:     jsval nsval;
59890:     JSLinearString *uri;
    1:     size_t urilen, srclen, length, offset, dstlen;
    1:     jschar *chars;
    1:     const jschar *srcp, *endp;
 2567:     JSXML *xml;
 6561:     const char *filename;
    1:     uintN lineno;
    1:     JSOp op;
    1: 
20487:     static const char prefix[] = "<parent xmlns=\"";
20487:     static const char middle[] = "\">";
    1:     static const char suffix[] = "</parent>";
    1: 
    1: #define constrlen(constr)   (sizeof(constr) - 1)
    1: 
    1:     if (!js_GetDefaultXMLNamespace(cx, &nsval))
    1:         return NULL;
59890:     uri = JSVAL_TO_OBJECT(nsval)->getNameURI();
20487:     uri = js_EscapeAttributeValue(cx, uri, JS_FALSE);
50461:     if (!uri)
50461:         return NULL;
18520: 
29366:     urilen = uri->length();
29366:     srclen = src->length();
    1:     length = constrlen(prefix) + urilen + constrlen(middle) + srclen +
    1:              constrlen(suffix);
    1: 
64560:     chars = (jschar *) cx->malloc_((length + 1) * sizeof(jschar));
    1:     if (!chars)
    1:         return NULL;
    1: 
    1:     dstlen = length;
71337:     InflateStringToBuffer(cx, prefix, constrlen(prefix), chars, &dstlen);
    1:     offset = dstlen;
29366:     js_strncpy(chars + offset, uri->chars(), urilen);
    1:     offset += urilen;
    1:     dstlen = length - offset + 1;
71337:     InflateStringToBuffer(cx, middle, constrlen(middle), chars + offset, &dstlen);
    1:     offset += dstlen;
59890:     srcp = src->getChars(cx);
59890:     if (!srcp) {
64560:         cx->free_(chars);
59890:         return NULL;
59890:     }
    1:     js_strncpy(chars + offset, srcp, srclen);
    1:     offset += srclen;
    1:     dstlen = length - offset + 1;
71337:     InflateStringToBuffer(cx, suffix, constrlen(suffix), chars + offset, &dstlen);
    1:     chars [offset + dstlen] = 0;
    1: 
42717:     LeaveTrace(cx);
 2567:     xml = NULL;
 6561:     filename = NULL;
 6561:     lineno = 1;
71697:     FrameRegsIter i(cx);
42717:     if (!i.done()) {
42717:         op = (JSOp) *i.pc();
    1:         if (op == JSOP_TOXML || op == JSOP_TOXMLLIST) {
71363:             filename = i.fp()->script()->filename;
71363:             lineno = js_FramePCToLineNumber(cx, i.fp(), i.pc());
 6561:             for (endp = srcp + srclen; srcp < endp; srcp++) {
    1:                 if (*srcp == '\n')
    1:                     --lineno;
 6561:             }
 6561:         }
 6561:     }
 6561: 
27012:     {
40860:         Parser parser(cx);
61450:         if (parser.init(chars, length, filename, lineno, cx->findVersion())) {
62953:             JSObject *scopeChain = GetScopeChain(cx);
59890:             if (!scopeChain) {
64560:                 cx->free_(chars);
56552:                 return NULL;
59890:             }
47478:             JSParseNode *pn = parser.parseXMLText(scopeChain, false);
47478:             uintN flags;
47478:             if (pn && GetXMLSettingFlags(cx, &flags)) {
47478:                 AutoNamespaceArray namespaces(cx);
47478:                 if (namespaces.array.setCapacity(cx, 1))
47478:                     xml = ParseNodeToXML(&parser, pn, &namespaces.array, flags);
    1:             }
27012:         }
27012:     }
27012: 
64560:     cx->free_(chars);
    1:     return xml;
    1: 
    1: #undef constrlen
    1: }
    1: 
    1: /*
    1:  * Errata in 10.3.1, 10.4.1, and 13.4.4.24 (at least).
    1:  *
    1:  * 10.3.1 Step 6(a) fails to NOTE that implementations that do not enforce
    1:  * the constraint:
    1:  *
    1:  *     for all x belonging to XML:
    1:  *         x.[[InScopeNamespaces]] >= x.[[Parent]].[[InScopeNamespaces]]
    1:  *
    1:  * must union x.[[InScopeNamespaces]] into x[0].[[InScopeNamespaces]] here
    1:  * (in new sub-step 6(a), renumbering the others to (b) and (c)).
    1:  *
    1:  * Same goes for 10.4.1 Step 7(a).
    1:  *
    1:  * In order for XML.prototype.namespaceDeclarations() to work correctly, the
    1:  * default namespace thereby unioned into x[0].[[InScopeNamespaces]] must be
    1:  * flagged as not declared, so that 13.4.4.24 Step 8(a) can exclude all such
    1:  * undeclared namespaces associated with x not belonging to ancestorNS.
    1:  */
    1: static JSXML *
    1: OrphanXMLChild(JSContext *cx, JSXML *xml, uint32 i)
    1: {
18520:     JSObject *ns;
18520: 
18520:     ns = XMLARRAY_MEMBER(&xml->xml_namespaces, 0, JSObject);
    1:     xml = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:     if (!ns || !xml)
    1:         return xml;
    1:     if (xml->xml_class == JSXML_CLASS_ELEMENT) {
    1:         if (!XMLARRAY_APPEND(cx, &xml->xml_namespaces, ns))
    1:             return NULL;
42693:         ns->setNamespaceDeclared(JSVAL_VOID);
    1:     }
    1:     xml->parent = NULL;
    1:     return xml;
    1: }
    1: 
    1: static JSObject *
    1: ToXML(JSContext *cx, jsval v)
    1: {
    1:     JSObject *obj;
    1:     JSXML *xml;
48470:     Class *clasp;
    1:     JSString *str;
    1:     uint32 length;
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(v)) {
    1:         if (JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v))
    1:             goto bad;
    1:     } else {
    1:         obj = JSVAL_TO_OBJECT(v);
42693:         if (obj->isXML()) {
32684:             xml = (JSXML *) obj->getPrivate();
    1:             if (xml->xml_class == JSXML_CLASS_LIST) {
    1:                 if (xml->xml_kids.length != 1)
    1:                     goto bad;
    1:                 xml = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);
    1:                 if (xml) {
    1:                     JS_ASSERT(xml->xml_class != JSXML_CLASS_LIST);
    1:                     return js_GetXMLObject(cx, xml);
    1:                 }
    1:             }
    1:             return obj;
    1:         }
    1: 
40826:         clasp = obj->getClass();
    1:         if (clasp->flags & JSCLASS_DOCUMENT_OBSERVER) {
    1:             JS_ASSERT(0);
    1:         }
    1: 
    1:         if (clasp != &js_StringClass &&
    1:             clasp != &js_NumberClass &&
    1:             clasp != &js_BooleanClass) {
    1:             goto bad;
    1:         }
    1:     }
    1: 
48470:     str = js_ValueToString(cx, Valueify(v));
    1:     if (!str)
    1:         return NULL;
29366:     if (str->empty()) {
    1:         length = 0;
    1: #ifdef __GNUC__         /* suppress bogus gcc warnings */
    1:         xml = NULL;
    1: #endif
    1:     } else {
    1:         xml = ParseXMLSource(cx, str);
    1:         if (!xml)
    1:             return NULL;
    1:         length = JSXML_LENGTH(xml);
    1:     }
    1: 
    1:     if (length == 0) {
    1:         obj = js_NewXMLObject(cx, JSXML_CLASS_TEXT);
    1:         if (!obj)
    1:             return NULL;
    1:     } else if (length == 1) {
    1:         xml = OrphanXMLChild(cx, xml, 0);
    1:         if (!xml)
    1:             return NULL;
    1:         obj = js_GetXMLObject(cx, xml);
    1:         if (!obj)
    1:             return NULL;
    1:     } else {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_SYNTAX_ERROR);
    1:         return NULL;
    1:     }
    1:     return obj;
    1: 
    1: bad:
    1:     js_ReportValueError(cx, JSMSG_BAD_XML_CONVERSION,
48470:                         JSDVG_IGNORE_STACK, Valueify(v), NULL);
    1:     return NULL;
    1: }
    1: 
    1: static JSBool
    1: Append(JSContext *cx, JSXML *list, JSXML *kid);
    1: 
    1: static JSObject *
    1: ToXMLList(JSContext *cx, jsval v)
    1: {
    1:     JSObject *obj, *listobj;
    1:     JSXML *xml, *list, *kid;
48470:     Class *clasp;
    1:     JSString *str;
    1:     uint32 i, length;
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(v)) {
    1:         if (JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v))
    1:             goto bad;
    1:     } else {
    1:         obj = JSVAL_TO_OBJECT(v);
42693:         if (obj->isXML()) {
32684:             xml = (JSXML *) obj->getPrivate();
    1:             if (xml->xml_class != JSXML_CLASS_LIST) {
    1:                 listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
    1:                 if (!listobj)
    1:                     return NULL;
32684:                 list = (JSXML *) listobj->getPrivate();
    1:                 if (!Append(cx, list, xml))
    1:                     return NULL;
    1:                 return listobj;
    1:             }
    1:             return obj;
    1:         }
    1: 
40826:         clasp = obj->getClass();
    1:         if (clasp->flags & JSCLASS_DOCUMENT_OBSERVER) {
    1:             JS_ASSERT(0);
    1:         }
    1: 
    1:         if (clasp != &js_StringClass &&
    1:             clasp != &js_NumberClass &&
    1:             clasp != &js_BooleanClass) {
    1:             goto bad;
    1:         }
    1:     }
    1: 
48470:     str = js_ValueToString(cx, Valueify(v));
    1:     if (!str)
    1:         return NULL;
29366:     if (str->empty()) {
    1:         xml = NULL;
    1:         length = 0;
    1:     } else {
    1:         if (!js_EnterLocalRootScope(cx))
    1:             return NULL;
    1:         xml = ParseXMLSource(cx, str);
    1:         if (!xml) {
    1:             js_LeaveLocalRootScope(cx);
    1:             return NULL;
    1:         }
    1:         length = JSXML_LENGTH(xml);
    1:     }
    1: 
    1:     listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
    1:     if (listobj) {
32684:         list = (JSXML *) listobj->getPrivate();
    1:         for (i = 0; i < length; i++) {
    1:             kid = OrphanXMLChild(cx, xml, i);
    1:             if (!kid || !Append(cx, list, kid)) {
    1:                 listobj = NULL;
    1:                 break;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (xml)
48470:         js_LeaveLocalRootScopeWithResult(cx, listobj);
    1:     return listobj;
    1: 
    1: bad:
    1:     js_ReportValueError(cx, JSMSG_BAD_XMLLIST_CONVERSION,
48470:                         JSDVG_IGNORE_STACK, Valueify(v), NULL);
    1:     return NULL;
    1: }
    1: 
    1: /*
    1:  * ECMA-357 10.2.1 Steps 5-7 pulled out as common subroutines of XMLToXMLString
    1:  * and their library-public js_* counterparts.  The guts of MakeXMLCDataString,
    1:  * MakeXMLCommentString, and MakeXMLPIString are further factored into a common
    1:  * MakeXMLSpecialString subroutine.
    1:  *
60571:  * These functions mutate sb, leaving it empty.
    1:  */
60571: static JSFlatString *
60571: MakeXMLSpecialString(JSContext *cx, StringBuffer &sb,
    1:                      JSString *str, JSString *str2,
    1:                      const jschar *prefix, size_t prefixlength,
    1:                      const jschar *suffix, size_t suffixlength)
    1: {
60571:     if (!sb.append(prefix, prefixlength) || !sb.append(str))
    1:         return NULL;
31884:     if (str2 && !str2->empty()) {
60571:         if (!sb.append(' ') || !sb.append(str2))
31884:             return NULL;
31884:     }
60571:     if (!sb.append(suffix, suffixlength))
31884:         return NULL;
31884: 
60571:     return sb.finishString();
60571: }
60571: 
60571: static JSFlatString *
60571: MakeXMLCDATAString(JSContext *cx, StringBuffer &sb, JSString *str)
    1: {
    1:     static const jschar cdata_prefix_ucNstr[] = {'<', '!', '[',
    1:                                                  'C', 'D', 'A', 'T', 'A',
    1:                                                  '['};
    1:     static const jschar cdata_suffix_ucNstr[] = {']', ']', '>'};
    1: 
60571:     return MakeXMLSpecialString(cx, sb, str, NULL,
    1:                                 cdata_prefix_ucNstr, 9,
    1:                                 cdata_suffix_ucNstr, 3);
    1: }
    1: 
60571: static JSFlatString *
60571: MakeXMLCommentString(JSContext *cx, StringBuffer &sb, JSString *str)
    1: {
    1:     static const jschar comment_prefix_ucNstr[] = {'<', '!', '-', '-'};
    1:     static const jschar comment_suffix_ucNstr[] = {'-', '-', '>'};
    1: 
60571:     return MakeXMLSpecialString(cx, sb, str, NULL,
    1:                                 comment_prefix_ucNstr, 4,
    1:                                 comment_suffix_ucNstr, 3);
    1: }
    1: 
60571: static JSFlatString *
60571: MakeXMLPIString(JSContext *cx, StringBuffer &sb, JSString *name,
    1:                 JSString *value)
    1: {
    1:     static const jschar pi_prefix_ucNstr[] = {'<', '?'};
    1:     static const jschar pi_suffix_ucNstr[] = {'?', '>'};
    1: 
60571:     return MakeXMLSpecialString(cx, sb, name, value,
    1:                                 pi_prefix_ucNstr, 2,
    1:                                 pi_suffix_ucNstr, 2);
    1: }
    1: 
    1: /*
    1:  * ECMA-357 10.2.1 17(d-g) pulled out into a common subroutine that appends
    1:  * equals, a double quote, an attribute value, and a closing double quote.
    1:  */
31884: static bool
60571: AppendAttributeValue(JSContext *cx, StringBuffer &sb, JSString *valstr)
60571: {
60571:     if (!sb.append('='))
31884:         return false;
 9762:     valstr = js_EscapeAttributeValue(cx, valstr, JS_TRUE);
60571:     return valstr && sb.append(valstr);
    1: }
    1: 
    1: /*
    1:  * ECMA-357 10.2.1.1 EscapeElementValue helper method.
31884: 
60571:  * These functions mutate sb, leaving it empty.
    1:  */
60571: static JSFlatString *
60571: EscapeElementValue(JSContext *cx, StringBuffer &sb, JSString *str, uint32 toSourceFlag)
31884: {
59890:     size_t length = str->length();
59890:     const jschar *start = str->getChars(cx);
59890:     if (!start)
59890:         return NULL;
31884: 
31884:     for (const jschar *cp = start, *end = start + length; cp != end; ++cp) {
31884:         jschar c = *cp;
31884:         switch (*cp) {
31884:           case '<':
60571:             if (!sb.append(js_lt_entity_str))
    1:                 return NULL;
31884:             break;
31884:           case '>':
60571:             if (!sb.append(js_gt_entity_str))
    1:                 return NULL;
31884:             break;
31884:           case '&':
60571:             if (!sb.append(js_amp_entity_str))
31884:                 return NULL;
31884:             break;
41279:           case '{':
41279:             /*
41279:              * If EscapeElementValue is called by toSource/uneval, we also need
41279:              * to escape '{'. See bug 463360.
41279:              */
41279:             if (toSourceFlag) {
60571:                 if (!sb.append(js_leftcurly_entity_str))
41279:                     return NULL;
41279:                 break;
41279:             }
41279:             /* FALL THROUGH */
31884:           default:
60571:             if (!sb.append(c))
31884:                 return NULL;
31884:         }
31884:     }
60571:     return sb.finishString();
    1: }
    1: 
    1: /*
    1:  * ECMA-357 10.2.1.2 EscapeAttributeValue helper method.
31884:  *
60571:  * These functions mutate sb, leaving it empty.
    1:  */
60571: static JSFlatString *
60571: EscapeAttributeValue(JSContext *cx, StringBuffer &sb, JSString *str, JSBool quote)
    1: {
59890:     size_t length = str->length();
59890:     const jschar *start = str->getChars(cx);
59890:     if (!start)
59890:         return NULL;
31884: 
60571:     if (quote && !sb.append('"'))
    1:         return NULL;
31884: 
31884:     for (const jschar *cp = start, *end = start + length; cp != end; ++cp) {
31884:         jschar c = *cp;
31884:         switch (c) {
31884:           case '"':
60571:             if (!sb.append(js_quot_entity_str))
    1:                 return NULL;
31884:             break;
31884:           case '<':
60571:             if (!sb.append(js_lt_entity_str))
31884:                 return NULL;
31884:             break;
31884:           case '&':
60571:             if (!sb.append(js_amp_entity_str))
31884:                 return NULL;
31884:             break;
31884:           case '\n':
60571:             if (!sb.append("&#xA;"))
31884:                 return NULL;
31884:             break;
31884:           case '\r':
60571:             if (!sb.append("&#xD;"))
31884:                 return NULL;
31884:             break;
31884:           case '\t':
60571:             if (!sb.append("&#x9;"))
31884:                 return NULL;
31884:             break;
31884:           default:
60571:             if (!sb.append(c))
31884:                 return NULL;
31884:         }
31884:     }
31884: 
60571:     if (quote && !sb.append('"'))
31884:         return NULL;
31884: 
60571:     return sb.finishString();
    1: }
    1: 
    1: /* 13.3.5.4 [[GetNamespace]]([InScopeNamespaces]) */
18520: static JSObject *
18520: GetNamespace(JSContext *cx, JSObject *qn, const JSXMLArray *inScopeNSes)
18520: {
59890:     JSLinearString *uri, *prefix, *nsprefix;
18520:     JSObject *match, *ns;
    1:     uint32 i, n;
    1:     jsval argv[2];
18520: 
59890:     uri = qn->getNameURI();
59890:     prefix = qn->getNamePrefix();
18520:     JS_ASSERT(uri);
18520:     if (!uri) {
57812:         JSAutoByteString bytes;
57812:         const char *s = !prefix ?
57812:                         js_undefined_str
57812:                         : js_ValueToPrintable(cx, StringValue(prefix), &bytes);
57812:         if (s)
57812:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_XML_NAMESPACE, s);
    1:         return NULL;
    1:     }
    1: 
    1:     /* Look for a matching namespace in inScopeNSes, if provided. */
    1:     match = NULL;
    1:     if (inScopeNSes) {
    1:         for (i = 0, n = inScopeNSes->length; i < n; i++) {
18520:             ns = XMLARRAY_MEMBER(inScopeNSes, i, JSObject);
    1:             if (!ns)
    1:                 continue;
    1: 
    1:             /*
    1:              * Erratum, very tricky, and not specified in ECMA-357 13.3.5.4:
18520:              * If we preserve prefixes, we must match null prefix against
18520:              * an empty prefix of ns, in order to avoid generating redundant
    1:              * prefixed and default namespaces for cases such as:
    1:              *
    1:              *   x = <t xmlns="http://foo.com"/>
    1:              *   print(x.toXMLString());
    1:              *
    1:              * Per 10.3.2.1, the namespace attribute in t has an empty string
    1:              * prefix (*not* a null prefix), per 10.3.2.1 Step 6(h)(i)(1):
    1:              *
    1:              *   1. If the [local name] property of a is "xmlns"
    1:              *      a. Map ns.prefix to the empty string
    1:              *
    1:              * But t's name has a null prefix in this implementation, meaning
    1:              * *undefined*, per 10.3.2.1 Step 6(c)'s NOTE (which refers to
    1:              * the http://www.w3.org/TR/xml-infoset/ spec, item 2.2.3, without
    1:              * saying how "no value" maps to an ECMA-357 value -- but it must
    1:              * map to the *undefined* prefix value).
    1:              *
    1:              * Since "" != undefined (or null, in the current implementation)
    1:              * the ECMA-357 spec will fail to match in [[GetNamespace]] called
    1:              * on t with argument {} U {(prefix="", uri="http://foo.com")}.
    1:              * This spec bug leads to ToXMLString results that duplicate the
    1:              * declared namespace.
    1:              */
59890:             if (EqualStrings(ns->getNameURI(), uri)) {
59890:                 nsprefix = ns->getNamePrefix();
18520:                 if (nsprefix == prefix ||
18520:                     ((nsprefix && prefix)
59890:                      ? EqualStrings(nsprefix, prefix)
29366:                      : (nsprefix ? nsprefix : prefix)->empty())) {
    1:                     match = ns;
    1:                     break;
    1:                 }
    1:             }
    1:         }
18520:     }
    1: 
    1:     /* If we didn't match, make a new namespace from qn. */
    1:     if (!match) {
18520:         argv[0] = prefix ? STRING_TO_JSVAL(prefix) : JSVAL_VOID;
18520:         argv[1] = STRING_TO_JSVAL(uri);
48622:         ns = js_ConstructObject(cx, &js_NamespaceClass, NULL, NULL,
48470:                                 2, Valueify(argv));
18520:         if (!ns)
    1:             return NULL;
18520:         match = ns;
    1:     }
    1:     return match;
    1: }
    1: 
59890: static JSLinearString *
59890: GeneratePrefix(JSContext *cx, JSLinearString *uri, JSXMLArray *decls)
    1: {
    1:     const jschar *cp, *start, *end;
    1:     size_t length, newlength, offset;
    1:     uint32 i, n, m, serial;
    1:     jschar *bp, *dp;
    1:     JSBool done;
18520:     JSObject *ns;
59890:     JSLinearString *nsprefix, *prefix;
    1: 
29366:     JS_ASSERT(!uri->empty());
    1: 
    1:     /*
    1:      * If there are no *declared* namespaces, skip all collision detection and
    1:      * return a short prefix quickly; an example of such a situation:
    1:      *
    1:      *   var x = <f/>;
    1:      *   var n = new Namespace("http://example.com/");
    1:      *   x.@n::att = "val";
    1:      *   x.toXMLString();
    1:      *
    1:      * This is necessary for various log10 uses below to be valid.
    1:      */
    1:     if (decls->length == 0)
59890:         return js_NewStringCopyZ(cx, "a");
    1: 
    1:     /*
    1:      * Try peeling off the last filename suffix or pathname component till
    1:      * we have a valid XML name.  This heuristic will prefer "xul" given
    1:      * ".../there.is.only.xul", "xbl" given ".../xbl", and "xbl2" given any
    1:      * likely URI of the form ".../xbl2/2005".
    1:      */
59890:     start = uri->chars();
59890:     end = start + uri->length();
 4718:     cp = end;
    1:     while (--cp > start) {
    1:         if (*cp == '.' || *cp == '/' || *cp == ':') {
    1:             ++cp;
25144:             length = end - cp;
    1:             if (IsXMLName(cp, length) && !STARTS_WITH_XML(cp, length))
    1:                 break;
    1:             end = --cp;
    1:         }
    1:     }
25144:     length = end - cp;
    1: 
    1:     /*
    1:      * If the namespace consisted only of non-XML names or names that begin
    1:      * case-insensitively with "xml", arbitrarily create a prefix consisting
    1:      * of 'a's of size length (allowing dp-calculating code to work with or
    1:      * without this branch executing) plus the space for storing a hyphen and
    1:      * the serial number (avoiding reallocation if a collision happens).
    1:      */
    1:     bp = (jschar *) cp;
    1:     newlength = length;
    1:     if (STARTS_WITH_XML(cp, length) || !IsXMLName(cp, length)) {
 3164:         newlength = length + 2 + (size_t) log10((double) decls->length);
    1:         bp = (jschar *)
64560:              cx->malloc_((newlength + 1) * sizeof(jschar));
    1:         if (!bp)
    1:             return NULL;
    1: 
    1:         bp[newlength] = 0;
    1:         for (i = 0; i < newlength; i++)
    1:              bp[i] = 'a';
    1:     }
    1: 
    1:     /*
    1:      * Now search through decls looking for a collision.  If we collide with
    1:      * an existing prefix, start tacking on a hyphen and a serial number.
    1:      */
    1:     serial = 0;
    1:     do {
    1:         done = JS_TRUE;
    1:         for (i = 0, n = decls->length; i < n; i++) {
18520:             ns = XMLARRAY_MEMBER(decls, i, JSObject);
59890:             if (ns && (nsprefix = ns->getNamePrefix()) &&
29366:                 nsprefix->length() == newlength &&
29366:                 !memcmp(nsprefix->chars(), bp,
    1:                         newlength * sizeof(jschar))) {
    1:                 if (bp == cp) {
 3164:                     newlength = length + 2 + (size_t) log10((double) n);
    1:                     bp = (jschar *)
64560:                          cx->malloc_((newlength + 1) * sizeof(jschar));
    1:                     if (!bp)
    1:                         return NULL;
    1:                     js_strncpy(bp, cp, length);
    1:                 }
    1: 
    1:                 ++serial;
    1:                 JS_ASSERT(serial <= n);
 3164:                 dp = bp + length + 2 + (size_t) log10((double) serial);
    1:                 *dp = 0;
    1:                 for (m = serial; m != 0; m /= 10)
    1:                     *--dp = (jschar)('0' + m % 10);
    1:                 *--dp = '-';
    1:                 JS_ASSERT(dp == bp + length);
    1: 
    1:                 done = JS_FALSE;
    1:                 break;
    1:             }
    1:         }
    1:     } while (!done);
    1: 
    1:     if (bp == cp) {
25144:         offset = cp - start;
 4076:         prefix = js_NewDependentString(cx, uri, offset, length);
    1:     } else {
 4718:         prefix = js_NewString(cx, bp, newlength);
    1:         if (!prefix)
64560:             cx->free_(bp);
    1:     }
    1:     return prefix;
    1: }
    1: 
    1: static JSBool
    1: namespace_match(const void *a, const void *b)
    1: {
18520:     const JSObject *nsa = (const JSObject *) a;
18520:     const JSObject *nsb = (const JSObject *) b;
59890:     JSLinearString *prefixa, *prefixb = nsb->getNamePrefix();
18520: 
18520:     if (prefixb) {
59890:         prefixa = nsa->getNamePrefix();
59890:         return prefixa && EqualStrings(prefixa, prefixb);
59890:     }
59890:     return EqualStrings(nsa->getNameURI(), nsb->getNameURI());
    1: }
    1: 
    1: /* ECMA-357 10.2.1 and 10.2.2 */
 9762: #define TO_SOURCE_FLAG 0x80000000
 9762: 
    1: static JSString *
    1: XMLToXMLString(JSContext *cx, JSXML *xml, const JSXMLArray *ancestorNSes,
 9762:                uint32 indentLevel)
    1: {
    1:     JSBool pretty, indentKids;
60571:     StringBuffer sb(cx);
59890:     JSString *str;
59890:     JSLinearString *prefix, *nsuri;
 9762:     uint32 i, n, nextIndentLevel;
18520:     JSObject *ns, *ns2;
47478:     AutoNamespaceArray empty(cx), decls(cx), ancdecls(cx);
    1: 
    1:     if (!GetBooleanXMLSetting(cx, js_prettyPrinting_str, &pretty))
    1:         return NULL;
    1: 
 2567:     if (pretty) {
60571:         if (!sb.appendN(' ', indentLevel & ~TO_SOURCE_FLAG))
 2567:             return NULL;
 2567:     }
31884: 
    1:     str = NULL;
    1: 
    1:     switch (xml->xml_class) {
    1:       case JSXML_CLASS_TEXT:
    1:         /* Step 4. */
    1:         if (pretty) {
    1:             str = ChompXMLWhitespace(cx, xml->xml_value);
    1:             if (!str)
    1:                 return NULL;
    1:         } else {
    1:             str = xml->xml_value;
    1:         }
60571:         return EscapeElementValue(cx, sb, str, indentLevel & TO_SOURCE_FLAG);
    1: 
    1:       case JSXML_CLASS_ATTRIBUTE:
    1:         /* Step 5. */
60571:         return EscapeAttributeValue(cx, sb, xml->xml_value,
 9762:                                     (indentLevel & TO_SOURCE_FLAG) != 0);
    1: 
    1:       case JSXML_CLASS_COMMENT:
    1:         /* Step 6. */
60571:         return MakeXMLCommentString(cx, sb, xml->xml_value);
    1: 
    1:       case JSXML_CLASS_PROCESSING_INSTRUCTION:
    1:         /* Step 7. */
60571:         return MakeXMLPIString(cx, sb, xml->name->getQNameLocalName(),
18520:                                xml->xml_value);
    1: 
    1:       case JSXML_CLASS_LIST:
    1:         /* ECMA-357 10.2.2. */
31884:         {
31884:             JSXMLArrayCursor cursor(&xml->xml_kids);
    1:             i = 0;
31884:             while (JSXML *kid = (JSXML *) cursor.getNext()) {
31884:                 if (pretty && i != 0) {
60571:                     if (!sb.append('\n'))
31884:                         return NULL;
31884:                 }
31884: 
31884:                 JSString *kidstr = XMLToXMLString(cx, kid, ancestorNSes, indentLevel);
60571:                 if (!kidstr || !sb.append(kidstr))
31884:                     return NULL;
    1:                 ++i;
    1:             }
31884:         }
31884: 
60571:         if (sb.empty())
 2567:             return cx->runtime->emptyString;
60571:         return sb.finishString();
    1: 
    1:       default:;
    1:     }
    1: 
    1:     /* After this point, control must flow through label out: to exit. */
    1:     if (!js_EnterLocalRootScope(cx))
    1:         return NULL;
    1: 
    1:     /* ECMA-357 10.2.1 step 8 onward: handle ToXMLString on an XML element. */
47478:     if (!ancestorNSes)
47478:         ancestorNSes = &empty.array;
    1: 
    1:     /* Clone in-scope namespaces not in ancestorNSes into decls. */
31884:     {
31884:         JSXMLArrayCursor cursor(&xml->xml_namespaces);
31884:         while ((ns = (JSObject *) cursor.getNext()) != NULL) {
18520:             if (!IsDeclared(ns))
    1:                 continue;
    1:             if (!XMLARRAY_HAS_MEMBER(ancestorNSes, ns, namespace_identity)) {
    1:                 /* NOTE: may want to exclude unused namespaces here. */
59890:                 ns2 = NewXMLNamespace(cx, ns->getNamePrefix(), ns->getNameURI(), JS_TRUE);
47478:                 if (!ns2 || !XMLARRAY_APPEND(cx, &decls.array, ns2))
    1:                     goto out;
31884:             }
31884:         }
31884:     }
    1: 
    1:     /*
    1:      * Union ancestorNSes and decls into ancdecls.  Note that ancdecls does
    1:      * not own its member references.  In the spec, ancdecls has no name, but
    1:      * is always written out as (AncestorNamespaces U namespaceDeclarations).
    1:      */
47478: 
47478:     if (!ancdecls.array.setCapacity(cx, ancestorNSes->length + decls.length()))
    1:         goto out;
    1:     for (i = 0, n = ancestorNSes->length; i < n; i++) {
18520:         ns2 = XMLARRAY_MEMBER(ancestorNSes, i, JSObject);
    1:         if (!ns2)
    1:             continue;
47478:         JS_ASSERT(!XMLARRAY_HAS_MEMBER(&decls.array, ns2, namespace_identity));
47478:         if (!XMLARRAY_APPEND(cx, &ancdecls.array, ns2))
    1:             goto out;
    1:     }
47478:     for (i = 0, n = decls.length(); i < n; i++) {
47478:         ns2 = XMLARRAY_MEMBER(&decls.array, i, JSObject);
    1:         if (!ns2)
    1:             continue;
47478:         JS_ASSERT(!XMLARRAY_HAS_MEMBER(&ancdecls.array, ns2, namespace_identity));
47478:         if (!XMLARRAY_APPEND(cx, &ancdecls.array, ns2))
    1:             goto out;
    1:     }
    1: 
    1:     /* Step 11, except we don't clone ns unless its prefix is undefined. */
47478:     ns = GetNamespace(cx, xml->name, &ancdecls.array);
    1:     if (!ns)
    1:         goto out;
    1: 
    1:     /* Step 12 (NULL means *undefined* here), plus the deferred ns cloning. */
59890:     prefix = ns->getNamePrefix();
18520:     if (!prefix) {
    1:         /*
    1:          * Create a namespace prefix that isn't used by any member of decls.
    1:          * Assign the new prefix to a copy of ns.  Flag this namespace as if
    1:          * it were declared, for assertion-testing's sake later below.
    1:          *
18520:          * Erratum: if prefix and xml->name are both null (*undefined* in
    1:          * ECMA-357), we know that xml was named using the default namespace
    1:          * (proof: see GetNamespace and the Namespace constructor called with
    1:          * two arguments).  So we ought not generate a new prefix here, when
    1:          * we can declare ns as the default namespace for xml.
    1:          *
    1:          * This helps descendants inherit the namespace instead of redundantly
    1:          * redeclaring it with generated prefixes in each descendant.
    1:          */
59890:         nsuri = ns->getNameURI();
59890:         if (!xml->name->getNamePrefix()) {
    1:             prefix = cx->runtime->emptyString;
    1:         } else {
47478:             prefix = GeneratePrefix(cx, nsuri, &ancdecls.array);
    1:             if (!prefix)
    1:                 goto out;
    1:         }
18520:         ns = NewXMLNamespace(cx, prefix, nsuri, JS_TRUE);
    1:         if (!ns)
    1:             goto out;
    1: 
    1:         /*
    1:          * If the xml->name was unprefixed, we must remove any declared default
    1:          * namespace from decls before appending ns.  How can you get a default
    1:          * namespace in decls that doesn't match the one from name?  Apparently
    1:          * by calling x.setNamespace(ns) where ns has no prefix.  The other way
    1:          * to fix this is to update x's in-scope namespaces when setNamespace
    1:          * is called, but that's not specified by ECMA-357.
    1:          *
    1:          * Likely Erratum here, depending on whether the lack of update to x's
    1:          * in-scope namespace in XML.prototype.setNamespace (13.4.4.36) is an
    1:          * erratum or not.  Note that changing setNamespace to update the list
    1:          * of in-scope namespaces will change x.namespaceDeclarations().
    1:          */
29366:         if (prefix->empty()) {
47478:             i = XMLArrayFindMember(&decls.array, ns, namespace_match);
    1:             if (i != XML_NOT_FOUND)
47478:                 XMLArrayDelete(cx, &decls.array, i, JS_TRUE);
    1:         }
    1: 
    1:         /*
    1:          * In the spec, ancdecls has no name, but is always written out as
    1:          * (AncestorNamespaces U namespaceDeclarations).  Since we compute
    1:          * that union in ancdecls, any time we append a namespace strong
    1:          * ref to decls, we must also append a weak ref to ancdecls.  Order
    1:          * matters here: code at label out: releases strong refs in decls.
    1:          */
47478:         if (!XMLARRAY_APPEND(cx, &ancdecls.array, ns) ||
47478:             !XMLARRAY_APPEND(cx, &decls.array, ns)) {
    1:             goto out;
    1:         }
    1:     }
    1: 
60571:     /* Format the element or point-tag into sb. */
60571:     if (!sb.append('<'))
31884:         goto out;
    1: 
59950:     if (!prefix->empty()) {
60571:         if (!sb.append(prefix) || !sb.append(':'))
31884:             goto out;
31884:     }
60571:     if (!sb.append(xml->name->getQNameLocalName()))
31884:         goto out;
    1: 
    1:     /*
    1:      * Step 16 makes a union to avoid writing two loops in step 17, to share
    1:      * common attribute value appending spec-code.  We prefer two loops for
    1:      * faster code and less data overhead.
    1:      */
    1: 
    1:     /* Step 17(b): append attributes. */
31884:     {
31884:         JSXMLArrayCursor cursor(&xml->xml_attrs);
31884:         while (JSXML *attr = (JSXML *) cursor.getNext()) {
60571:             if (!sb.append(' '))
31884:                 goto out;
47478:             ns2 = GetNamespace(cx, attr->name, &ancdecls.array);
    1:             if (!ns2)
31884:                 goto out;
    1: 
    1:             /* 17(b)(ii): NULL means *undefined* here. */
59890:             prefix = ns2->getNamePrefix();
18520:             if (!prefix) {
59890:                 prefix = GeneratePrefix(cx, ns2->getNameURI(), &ancdecls.array);
    1:                 if (!prefix)
31884:                     goto out;
    1: 
    1:                 /* Again, we avoid copying ns2 until we know it's prefix-less. */
59890:                 ns2 = NewXMLNamespace(cx, prefix, ns2->getNameURI(), JS_TRUE);
    1:                 if (!ns2)
31884:                     goto out;
    1: 
    1:                 /*
    1:                  * In the spec, ancdecls has no name, but is always written out as
    1:                  * (AncestorNamespaces U namespaceDeclarations).  Since we compute
    1:                  * that union in ancdecls, any time we append a namespace strong
    1:                  * ref to decls, we must also append a weak ref to ancdecls.  Order
    1:                  * matters here: code at label out: releases strong refs in decls.
    1:                  */
47478:                 if (!XMLARRAY_APPEND(cx, &ancdecls.array, ns2) ||
47478:                     !XMLARRAY_APPEND(cx, &decls.array, ns2)) {
31884:                     goto out;
    1:                 }
    1:             }
    1: 
    1:             /* 17(b)(iii). */
29366:             if (!prefix->empty()) {
60571:                 if (!sb.append(prefix) || !sb.append(':'))
31884:                     goto out;
    1:             }
    1: 
    1:             /* 17(b)(iv). */
60571:             if (!sb.append(attr->name->getQNameLocalName()))
31884:                 goto out;
    1: 
    1:             /* 17(d-g). */
60571:             if (!AppendAttributeValue(cx, sb, attr->xml_value))
    1:                 goto out;
31884:         }
31884:     }
    1: 
    1:     /* Step 17(c): append XML namespace declarations. */
31884:     {
47478:         JSXMLArrayCursor cursor(&decls.array);
31884:         while (JSObject *ns3 = (JSObject *) cursor.getNext()) {
31884:             JS_ASSERT(IsDeclared(ns3));
31884: 
60571:             if (!sb.append(" xmlns"))
31884:                 goto out;
    1: 
    1:             /* 17(c)(ii): NULL means *undefined* here. */
59890:             prefix = ns3->getNamePrefix();
18520:             if (!prefix) {
59890:                 prefix = GeneratePrefix(cx, ns3->getNameURI(), &ancdecls.array);
    1:                 if (!prefix)
31884:                     goto out;
59890:                 ns3->setNamePrefix(prefix);
    1:             }
    1: 
    1:             /* 17(c)(iii). */
29366:             if (!prefix->empty()) {
60571:                 if (!sb.append(':') || !sb.append(prefix))
31884:                     goto out;
    1:             }
    1: 
    1:             /* 17(d-g). */
60571:             if (!AppendAttributeValue(cx, sb, ns3->getNameURI()))
    1:                 goto out;
31884:         }
31884:     }
    1: 
    1:     /* Step 18: handle point tags. */
    1:     n = xml->xml_kids.length;
    1:     if (n == 0) {
60571:         if (!sb.append("/>"))
31884:             goto out;
    1:     } else {
    1:         /* Steps 19 through 25: handle element content, and open the end-tag. */
60571:         if (!sb.append('>'))
31884:             goto out;
31884:         {
31884:             JSXML *kid;
    1:             indentKids = n > 1 ||
    1:                          (n == 1 &&
    1:                           (kid = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML)) &&
    1:                           kid->xml_class != JSXML_CLASS_TEXT);
31884:         }
    1: 
    1:         if (pretty && indentKids) {
    1:             if (!GetUint32XMLSetting(cx, js_prettyIndent_str, &i))
    1:                 goto out;
    1:             nextIndentLevel = indentLevel + i;
    1:         } else {
 9762:             nextIndentLevel = indentLevel & TO_SOURCE_FLAG;
    1:         }
    1: 
31884:         {
31884:             JSXMLArrayCursor cursor(&xml->xml_kids);
31884:             while (JSXML *kid = (JSXML *) cursor.getNext()) {
31884:                 if (pretty && indentKids) {
60571:                     if (!sb.append('\n'))
31884:                         goto out;
31884:                 }
31884: 
47478:                 JSString *kidstr = XMLToXMLString(cx, kid, &ancdecls.array, nextIndentLevel);
    1:                 if (!kidstr)
    1:                     goto out;
    1: 
60571:                 if (!sb.append(kidstr))
31884:                     goto out;
31884:             }
31884:         }
31884: 
    1:         if (pretty && indentKids) {
60571:             if (!sb.append('\n') ||
60571:                 !sb.appendN(' ', indentLevel & ~TO_SOURCE_FLAG))
31884:                 goto out;
31884:         }
60571:         if (!sb.append("</"))
31884:             goto out;
    1: 
    1:         /* Step 26. */
59890:         prefix = ns->getNamePrefix();
29366:         if (prefix && !prefix->empty()) {
60571:             if (!sb.append(prefix) || !sb.append(':'))
31884:                 goto out;
    1:         }
    1: 
    1:         /* Step 27. */
60571:         if (!sb.append(xml->name->getQNameLocalName()) || !sb.append('>'))
    1:             goto out;
    1:     }
    1: 
60571:     str = sb.finishString();
    1: out:
48470:     js_LeaveLocalRootScopeWithResult(cx, str);
    1:     return str;
    1: }
    1: 
    1: /* ECMA-357 10.2 */
    1: static JSString *
 9762: ToXMLString(JSContext *cx, jsval v, uint32 toSourceFlag)
    1: {
    1:     if (JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v)) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_XML_CONVERSION,
 4342:                              JSVAL_IS_NULL(v) ? js_null_str : js_undefined_str);
    1:         return NULL;
    1:     }
    1: 
    1:     if (JSVAL_IS_BOOLEAN(v) || JSVAL_IS_NUMBER(v))
48470:         return js_ValueToString(cx, Valueify(v));
    1: 
31884:     if (JSVAL_IS_STRING(v)) {
60571:         StringBuffer sb(cx);
60571:         return EscapeElementValue(cx, sb, JSVAL_TO_STRING(v), toSourceFlag);
31884:     }
    1: 
72054:     JSObject *obj = JSVAL_TO_OBJECT(v);
42693:     if (!obj->isXML()) {
72054:         if (!ToPrimitive(cx, JSTYPE_STRING, Valueify(&v)))
    1:             return NULL;
72054:         JSString *str = js_ValueToString(cx, Valueify(v));
    1:         if (!str)
    1:             return NULL;
60571:         StringBuffer sb(cx);
60571:         return EscapeElementValue(cx, sb, str, toSourceFlag);
    1:     }
    1: 
    1:     /* Handle non-element cases in this switch, returning from each case. */
72054:     JS::Anchor<JSObject *> anch(obj);
72054:     JSXML *xml = reinterpret_cast<JSXML *>(obj->getPrivate());
 9762:     return XMLToXMLString(cx, xml, NULL, toSourceFlag | 0);
    1: }
    1: 
18520: static JSObject *
    1: ToAttributeName(JSContext *cx, jsval v)
    1: {
59890:     JSLinearString *name, *uri, *prefix;
    1:     JSObject *obj;
48470:     Class *clasp;
18520:     JSObject *qn;
    1: 
    1:     if (JSVAL_IS_STRING(v)) {
59890:         name = JSVAL_TO_STRING(v)->ensureLinear(cx);
59890:         if (!name)
59890:             return NULL;
    1:         uri = prefix = cx->runtime->emptyString;
    1:     } else {
    1:         if (JSVAL_IS_PRIMITIVE(v)) {
    1:             js_ReportValueError(cx, JSMSG_BAD_XML_ATTR_NAME,
48470:                                 JSDVG_IGNORE_STACK, Valueify(v), NULL);
    1:             return NULL;
    1:         }
    1: 
    1:         obj = JSVAL_TO_OBJECT(v);
40826:         clasp = obj->getClass();
    1:         if (clasp == &js_AttributeNameClass)
18520:             return obj;
    1: 
48622:         if (clasp == &js_QNameClass) {
18520:             qn = obj;
59890:             uri = qn->getNameURI();
59890:             prefix = qn->getNamePrefix();
59890:             name = qn->getQNameLocalName();
    1:         } else {
    1:             if (clasp == &js_AnyNameClass) {
64345:                 name = cx->runtime->atomState.starAtom;
    1:             } else {
59890:                 JSString *str = js_ValueToString(cx, Valueify(v));
59890:                 if (!str)
59890:                     return NULL;
59890:                 name = str->ensureLinear(cx);
    1:                 if (!name)
    1:                     return NULL;
    1:             }
    1:             uri = prefix = cx->runtime->emptyString;
    1:         }
    1:     }
    1: 
60566:     qn = NewXMLAttributeName(cx, uri, prefix, name);
    1:     if (!qn)
    1:         return NULL;
    1:     return qn;
    1: }
    1: 
    1: static void
48470: ReportBadXMLName(JSContext *cx, const Value &idval)
48470: {
48470:     js_ReportValueError(cx, JSMSG_BAD_XML_NAME, JSDVG_IGNORE_STACK, idval, NULL);
    1: }
    1: 
    1: static JSBool
18520: IsFunctionQName(JSContext *cx, JSObject *qn, jsid *funidp)
    1: {
    1:     JSAtom *atom;
59890:     JSLinearString *uri;
    1: 
54162:     atom = cx->runtime->atomState.functionNamespaceURIAtom;
59890:     uri = qn->getNameURI();
64345:     if (uri && (uri == atom || EqualStrings(uri, atom)))
59890:         return JS_ValueToId(cx, STRING_TO_JSVAL(qn->getQNameLocalName()), funidp);
48470:     *funidp = JSID_VOID;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: js_IsFunctionQName(JSContext *cx, JSObject *obj, jsid *funidp)
    1: {
48622:     if (obj->getClass() == &js_QNameClass)
18520:         return IsFunctionQName(cx, obj, funidp);
48470:     *funidp = JSID_VOID;
    1:     return JS_TRUE;
    1: }
    1: 
18520: static JSObject *
    1: ToXMLName(JSContext *cx, jsval v, jsid *funidp)
    1: {
48470:     JSAtom *atomizedName;
    1:     JSString *name;
    1:     JSObject *obj;
48470:     Class *clasp;
    1:     uint32 index;
    1: 
    1:     if (JSVAL_IS_STRING(v)) {
    1:         name = JSVAL_TO_STRING(v);
    1:     } else {
    1:         if (JSVAL_IS_PRIMITIVE(v)) {
48470:             ReportBadXMLName(cx, Valueify(v));
    1:             return NULL;
    1:         }
    1: 
    1:         obj = JSVAL_TO_OBJECT(v);
40826:         clasp = obj->getClass();
48622:         if (clasp == &js_AttributeNameClass || clasp == &js_QNameClass)
    1:             goto out;
    1:         if (clasp == &js_AnyNameClass) {
64345:             name = cx->runtime->atomState.starAtom;
    1:             goto construct;
    1:         }
48470:         name = js_ValueToString(cx, Valueify(v));
    1:         if (!name)
    1:             return NULL;
    1:     }
    1: 
70270:     atomizedName = js_AtomizeString(cx, name);
48470:     if (!atomizedName)
48470:         return NULL;
48470: 
    1:     /*
    1:      * ECMA-357 10.6.1 step 1 seems to be incorrect.  The spec says:
    1:      *
    1:      * 1. If ToString(ToNumber(P)) == ToString(P), throw a TypeError exception
    1:      *
    1:      * First, _P_ should be _s_, to refer to the given string.
    1:      *
    1:      * Second, why does ToXMLName applied to the string type throw TypeError
    1:      * only for numeric literals without any leading or trailing whitespace?
    1:      *
    1:      * If the idea is to reject uint32 property names, then the check needs to
    1:      * be stricter, to exclude hexadecimal and floating point literals.
    1:      */
48470:     if (js_IdIsIndex(ATOM_TO_JSID(atomizedName), &index))
    1:         goto bad;
    1: 
59890:     if (*atomizedName->chars() == '@') {
29366:         name = js_NewDependentString(cx, name, 1, name->length() - 1);
    1:         if (!name)
    1:             return NULL;
48470:         *funidp = JSID_VOID;
    1:         return ToAttributeName(cx, STRING_TO_JSVAL(name));
    1:     }
    1: 
    1: construct:
    1:     v = STRING_TO_JSVAL(name);
48622:     obj = js_ConstructObject(cx, &js_QNameClass, NULL, NULL, 1, Valueify(&v));
    1:     if (!obj)
    1:         return NULL;
    1: 
    1: out:
18520:     if (!IsFunctionQName(cx, obj, funidp))
    1:         return NULL;
18520:     return obj;
    1: 
    1: bad:
57812:     JSAutoByteString bytes;
57812:     if (js_ValueToPrintable(cx, StringValue(name), &bytes))
57812:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_XML_NAME, bytes.ptr());
    1:     return NULL;
    1: }
    1: 
    1: /* ECMA-357 9.1.1.13 XML [[AddInScopeNamespace]]. */
    1: static JSBool
18520: AddInScopeNamespace(JSContext *cx, JSXML *xml, JSObject *ns)
18520: {
59890:     JSLinearString *prefix, *prefix2;
18520:     JSObject *match, *ns2;
    1:     uint32 i, n, m;
    1: 
    1:     if (xml->xml_class != JSXML_CLASS_ELEMENT)
    1:         return JS_TRUE;
    1: 
    1:     /* NULL means *undefined* here -- see ECMA-357 9.1.1.13 step 2. */
59890:     prefix = ns->getNamePrefix();
18520:     if (!prefix) {
    1:         match = NULL;
    1:         for (i = 0, n = xml->xml_namespaces.length; i < n; i++) {
18520:             ns2 = XMLARRAY_MEMBER(&xml->xml_namespaces, i, JSObject);
59890:             if (ns2 && EqualStrings(ns2->getNameURI(), ns->getNameURI())) {
    1:                 match = ns2;
    1:                 break;
    1:             }
    1:         }
    1:         if (!match && !XMLARRAY_ADD_MEMBER(cx, &xml->xml_namespaces, n, ns))
    1:             return JS_FALSE;
    1:     } else {
59890:         if (prefix->empty() && xml->name->getNameURI()->empty())
    1:             return JS_TRUE;
    1:         match = NULL;
    1: #ifdef __GNUC__         /* suppress bogus gcc warnings */
    1:         m = XML_NOT_FOUND;
    1: #endif
    1:         for (i = 0, n = xml->xml_namespaces.length; i < n; i++) {
18520:             ns2 = XMLARRAY_MEMBER(&xml->xml_namespaces, i, JSObject);
59890:             if (ns2 && (prefix2 = ns2->getNamePrefix()) &&
59890:                 EqualStrings(prefix2, prefix)) {
    1:                 match = ns2;
    1:                 m = i;
    1:                 break;
    1:             }
    1:         }
59890:         if (match && !EqualStrings(match->getNameURI(), ns->getNameURI())) {
    1:             ns2 = XMLARRAY_DELETE(cx, &xml->xml_namespaces, m, JS_TRUE,
18520:                                   JSObject);
    1:             JS_ASSERT(ns2 == match);
59890:             match->clearNamePrefix();
    1:             if (!AddInScopeNamespace(cx, xml, match))
    1:                 return JS_FALSE;
    1:         }
    1:         if (!XMLARRAY_APPEND(cx, &xml->xml_namespaces, ns))
    1:             return JS_FALSE;
    1:     }
    1: 
    1:     /* OPTION: enforce that descendants have superset namespaces. */
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* ECMA-357 9.2.1.6 XMLList [[Append]]. */
    1: static JSBool
    1: Append(JSContext *cx, JSXML *list, JSXML *xml)
    1: {
    1:     uint32 i, j, k, n;
    1:     JSXML *kid;
    1: 
    1:     JS_ASSERT(list->xml_class == JSXML_CLASS_LIST);
    1:     i = list->xml_kids.length;
    1:     n = 1;
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         list->xml_target = xml->xml_target;
    1:         list->xml_targetprop = xml->xml_targetprop;
    1:         n = JSXML_LENGTH(xml);
    1:         k = i + n;
47478:         if (!list->xml_kids.setCapacity(cx, k))
    1:             return JS_FALSE;
    1:         for (j = 0; j < n; j++) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, j, JSXML);
    1:             if (kid)
    1:                 XMLARRAY_SET_MEMBER(&list->xml_kids, i + j, kid);
    1:         }
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     list->xml_target = xml->parent;
    1:     if (xml->xml_class == JSXML_CLASS_PROCESSING_INSTRUCTION)
    1:         list->xml_targetprop = NULL;
    1:     else
    1:         list->xml_targetprop = xml->name;
    1:     if (!XMLARRAY_ADD_MEMBER(cx, &list->xml_kids, i, xml))
    1:         return JS_FALSE;
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* ECMA-357 9.1.1.7 XML [[DeepCopy]] and 9.2.1.7 XMLList [[DeepCopy]]. */
    1: static JSXML *
    1: DeepCopyInLRS(JSContext *cx, JSXML *xml, uintN flags);
    1: 
    1: static JSXML *
    1: DeepCopy(JSContext *cx, JSXML *xml, JSObject *obj, uintN flags)
    1: {
    1:     JSXML *copy;
    1: 
    1:     /* Our caller may not be protecting newborns with a local root scope. */
    1:     if (!js_EnterLocalRootScope(cx))
    1:         return NULL;
    1:     copy = DeepCopyInLRS(cx, xml, flags);
    1:     if (copy) {
    1:         if (obj) {
    1:             /* Caller provided the object for this copy, hook 'em up. */
31452:             obj->setPrivate(copy);
    1:             copy->object = obj;
31452:         } else if (!js_GetXMLObject(cx, copy)) {
    1:             copy = NULL;
    1:         }
31452:     }
48470:     js_LeaveLocalRootScopeWithResult(cx, copy);
    1:     return copy;
    1: }
    1: 
    1: /*
    1:  * (i) We must be in a local root scope (InLRS).
    1:  * (ii) parent must have a rooted object.
    1:  * (iii) from's owning object must be locked if not thread-local.
    1:  */
    1: static JSBool
    1: DeepCopySetInLRS(JSContext *cx, JSXMLArray *from, JSXMLArray *to, JSXML *parent,
    1:                  uintN flags)
    1: {
    1:     uint32 j, n;
31884:     JSXML *kid2;
    1:     JSString *str;
    1: 
    1:     n = from->length;
47478:     if (!to->setCapacity(cx, n))
    1:         return JS_FALSE;
    1: 
31884:     JSXMLArrayCursor cursor(from);
    1:     j = 0;
31884:     while (JSXML *kid = (JSXML *) cursor.getNext()) {
    1:         if ((flags & XSF_IGNORE_COMMENTS) &&
    1:             kid->xml_class == JSXML_CLASS_COMMENT) {
    1:             continue;
    1:         }
    1:         if ((flags & XSF_IGNORE_PROCESSING_INSTRUCTIONS) &&
    1:             kid->xml_class == JSXML_CLASS_PROCESSING_INSTRUCTION) {
    1:             continue;
    1:         }
    1:         if ((flags & XSF_IGNORE_WHITESPACE) &&
    1:             (kid->xml_flags & XMLF_WHITESPACE_TEXT)) {
    1:             continue;
    1:         }
    1:         kid2 = DeepCopyInLRS(cx, kid, flags);
    1:         if (!kid2) {
    1:             to->length = j;
31884:             return JS_FALSE;
    1:         }
    1: 
    1:         if ((flags & XSF_IGNORE_WHITESPACE) &&
    1:             n > 1 && kid2->xml_class == JSXML_CLASS_TEXT) {
    1:             str = ChompXMLWhitespace(cx, kid2->xml_value);
    1:             if (!str) {
    1:                 to->length = j;
31884:                 return JS_FALSE;
    1:             }
    1:             kid2->xml_value = str;
    1:         }
    1: 
    1:         XMLARRAY_SET_MEMBER(to, j, kid2);
    1:         ++j;
    1:         if (parent->xml_class != JSXML_CLASS_LIST)
    1:             kid2->parent = parent;
    1:     }
    1: 
    1:     if (j < n)
47478:         to->trim();
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSXML *
    1: DeepCopyInLRS(JSContext *cx, JSXML *xml, uintN flags)
    1: {
    1:     JSXML *copy;
18520:     JSObject *qn;
    1:     JSBool ok;
    1:     uint32 i, n;
18520:     JSObject *ns, *ns2;
    1: 
12689:     JS_CHECK_RECURSION(cx, return NULL);
11139: 
26751:     copy = js_NewXML(cx, JSXMLClass(xml->xml_class));
    1:     if (!copy)
    1:         return NULL;
    1:     qn = xml->name;
    1:     if (qn) {
59890:         qn = NewXMLQName(cx, qn->getNameURI(), qn->getNamePrefix(), qn->getQNameLocalName());
    1:         if (!qn) {
    1:             ok = JS_FALSE;
    1:             goto out;
    1:         }
    1:     }
    1:     copy->name = qn;
    1:     copy->xml_flags = xml->xml_flags;
    1: 
    1:     if (JSXML_HAS_VALUE(xml)) {
    1:         copy->xml_value = xml->xml_value;
    1:         ok = JS_TRUE;
    1:     } else {
    1:         ok = DeepCopySetInLRS(cx, &xml->xml_kids, &copy->xml_kids, copy, flags);
    1:         if (!ok)
    1:             goto out;
    1: 
    1:         if (xml->xml_class == JSXML_CLASS_LIST) {
    1:             copy->xml_target = xml->xml_target;
    1:             copy->xml_targetprop = xml->xml_targetprop;
    1:         } else {
    1:             n = xml->xml_namespaces.length;
47478:             ok = copy->xml_namespaces.setCapacity(cx, n);
    1:             if (!ok)
    1:                 goto out;
    1:             for (i = 0; i < n; i++) {
18520:                 ns = XMLARRAY_MEMBER(&xml->xml_namespaces, i, JSObject);
    1:                 if (!ns)
    1:                     continue;
59890:                 ns2 = NewXMLNamespace(cx, ns->getNamePrefix(), ns->getNameURI(),
18520:                                       IsDeclared(ns));
    1:                 if (!ns2) {
    1:                     copy->xml_namespaces.length = i;
    1:                     ok = JS_FALSE;
    1:                     goto out;
    1:                 }
    1:                 XMLARRAY_SET_MEMBER(&copy->xml_namespaces, i, ns2);
    1:             }
    1: 
    1:             ok = DeepCopySetInLRS(cx, &xml->xml_attrs, &copy->xml_attrs, copy,
    1:                                   0);
    1:             if (!ok)
    1:                 goto out;
    1:         }
    1:     }
    1: 
    1: out:
    1:     if (!ok)
    1:         return NULL;
    1:     return copy;
    1: }
    1: 
    1: /* ECMA-357 9.1.1.4 XML [[DeleteByIndex]]. */
    1: static void
    1: DeleteByIndex(JSContext *cx, JSXML *xml, uint32 index)
    1: {
    1:     JSXML *kid;
    1: 
    1:     if (JSXML_HAS_KIDS(xml) && index < xml->xml_kids.length) {
    1:         kid = XMLARRAY_MEMBER(&xml->xml_kids, index, JSXML);
    1:         if (kid)
    1:             kid->parent = NULL;
    1:         XMLArrayDelete(cx, &xml->xml_kids, index, JS_TRUE);
    1:     }
    1: }
    1: 
18520: typedef JSBool (*JSXMLNameMatcher)(JSObject *nameqn, JSXML *xml);
18520: 
18520: static JSBool
18520: MatchAttrName(JSObject *nameqn, JSXML *attr)
18520: {
18520:     JSObject *attrqn = attr->name;
59890:     JSLinearString *localName = nameqn->getQNameLocalName();
59890:     JSLinearString *uri;
18520: 
18520:     return (IS_STAR(localName) ||
59890:             EqualStrings(attrqn->getQNameLocalName(), localName)) &&
59890:            (!(uri = nameqn->getNameURI()) ||
59890:             EqualStrings(attrqn->getNameURI(), uri));
18520: }
18520: 
18520: static JSBool
18520: MatchElemName(JSObject *nameqn, JSXML *elem)
18520: {
59890:     JSLinearString *localName = nameqn->getQNameLocalName();
59890:     JSLinearString *uri;
18520: 
18520:     return (IS_STAR(localName) ||
    1:             (elem->xml_class == JSXML_CLASS_ELEMENT &&
59890:              EqualStrings(elem->name->getQNameLocalName(), localName))) &&
59890:            (!(uri = nameqn->getNameURI()) ||
    1:             (elem->xml_class == JSXML_CLASS_ELEMENT &&
59890:              EqualStrings(elem->name->getNameURI(), uri)));
    1: }
    1: 
    1: /* ECMA-357 9.1.1.8 XML [[Descendants]] and 9.2.1.8 XMLList [[Descendants]]. */
    1: static JSBool
18520: DescendantsHelper(JSContext *cx, JSXML *xml, JSObject *nameqn, JSXML *list)
    1: {
    1:     uint32 i, n;
    1:     JSXML *attr, *kid;
    1: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
11139: 
    1:     if (xml->xml_class == JSXML_CLASS_ELEMENT &&
40826:         nameqn->getClass() == &js_AttributeNameClass) {
    1:         for (i = 0, n = xml->xml_attrs.length; i < n; i++) {
    1:             attr = XMLARRAY_MEMBER(&xml->xml_attrs, i, JSXML);
    1:             if (attr && MatchAttrName(nameqn, attr)) {
    1:                 if (!Append(cx, list, attr))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     for (i = 0, n = JSXML_LENGTH(xml); i < n; i++) {
    1:         kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:         if (!kid)
    1:             continue;
40826:         if (nameqn->getClass() != &js_AttributeNameClass &&
    1:             MatchElemName(nameqn, kid)) {
    1:             if (!Append(cx, list, kid))
    1:                 return JS_FALSE;
    1:         }
    1:         if (!DescendantsHelper(cx, kid, nameqn, list))
    1:             return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSXML *
    1: Descendants(JSContext *cx, JSXML *xml, jsval id)
    1: {
    1:     jsid funid;
18520:     JSObject *nameqn;
    1:     JSObject *listobj;
    1:     JSXML *list, *kid;
    1:     uint32 i, n;
    1:     JSBool ok;
    1: 
    1:     nameqn = ToXMLName(cx, id, &funid);
    1:     if (!nameqn)
    1:         return NULL;
    1: 
    1:     listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
    1:     if (!listobj)
    1:         return NULL;
32684:     list = (JSXML *) listobj->getPrivate();
48470:     if (!JSID_IS_VOID(funid))
    1:         return list;
    1: 
    1:     /*
    1:      * Protect nameqn's object and strings from GC by linking list to it
33581:      * temporarily.  The newborn GC root for the last allocated object
33581:      * protects listobj, which protects list. Any other object allocations
33581:      * occurring beneath DescendantsHelper use local roots.
    1:      */
    1:     list->name = nameqn;
    1:     if (!js_EnterLocalRootScope(cx))
    1:         return NULL;
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         ok = JS_TRUE;
    1:         for (i = 0, n = xml->xml_kids.length; i < n; i++) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid && kid->xml_class == JSXML_CLASS_ELEMENT) {
    1:                 ok = DescendantsHelper(cx, kid, nameqn, list);
    1:                 if (!ok)
    1:                     break;
    1:             }
    1:         }
    1:     } else {
    1:         ok = DescendantsHelper(cx, xml, nameqn, list);
    1:     }
48470:     js_LeaveLocalRootScopeWithResult(cx, list);
    1:     if (!ok)
    1:         return NULL;
    1:     list->name = NULL;
    1:     return list;
    1: }
    1: 
    1: /* Recursive (JSXML *) parameterized version of Equals. */
    1: static JSBool
    1: XMLEquals(JSContext *cx, JSXML *xml, JSXML *vxml, JSBool *bp)
    1: {
18520:     JSObject *qn, *vqn;
    1:     uint32 i, j, n;
    1:     JSXML *kid, *vkid, *attr, *vattr;
    1:     JSObject *xobj, *vobj;
    1: 
    1: retry:
    1:     if (xml->xml_class != vxml->xml_class) {
    1:         if (xml->xml_class == JSXML_CLASS_LIST && xml->xml_kids.length == 1) {
    1:             xml = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);
    1:             if (xml)
    1:                 goto retry;
    1:         }
    1:         if (vxml->xml_class == JSXML_CLASS_LIST && vxml->xml_kids.length == 1) {
    1:             vxml = XMLARRAY_MEMBER(&vxml->xml_kids, 0, JSXML);
    1:             if (vxml)
    1:                 goto retry;
    1:         }
    1:         *bp = JS_FALSE;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     qn = xml->name;
    1:     vqn = vxml->name;
    1:     if (qn) {
    1:         *bp = vqn &&
59890:               EqualStrings(qn->getQNameLocalName(), vqn->getQNameLocalName()) &&
59890:               EqualStrings(qn->getNameURI(), vqn->getNameURI());
    1:     } else {
    1:         *bp = vqn == NULL;
    1:     }
    1:     if (!*bp)
    1:         return JS_TRUE;
    1: 
    1:     if (JSXML_HAS_VALUE(xml)) {
59890:         if (!EqualStrings(cx, xml->xml_value, vxml->xml_value, bp))
59890:             return JS_FALSE;
    1:     } else if (xml->xml_kids.length != vxml->xml_kids.length) {
    1:         *bp = JS_FALSE;
    1:     } else {
31884:         {
31884:             JSXMLArrayCursor cursor(&xml->xml_kids);
31884:             JSXMLArrayCursor vcursor(&vxml->xml_kids);
    1:             for (;;) {
31884:                 kid = (JSXML *) cursor.getNext();
31884:                 vkid = (JSXML *) vcursor.getNext();
    1:                 if (!kid || !vkid) {
    1:                     *bp = !kid && !vkid;
    1:                     break;
    1:                 }
    1:                 xobj = js_GetXMLObject(cx, kid);
    1:                 vobj = js_GetXMLObject(cx, vkid);
31884:                 if (!xobj || !vobj ||
48470:                     !js_TestXMLEquality(cx, ObjectValue(*xobj), ObjectValue(*vobj), bp))
31884:                     return JS_FALSE;
31884:                 if (!*bp)
    1:                     break;
    1:             }
31884:         }
    1: 
    1:         if (*bp && xml->xml_class == JSXML_CLASS_ELEMENT) {
    1:             n = xml->xml_attrs.length;
    1:             if (n != vxml->xml_attrs.length)
    1:                 *bp = JS_FALSE;
    1:             for (i = 0; *bp && i < n; i++) {
    1:                 attr = XMLARRAY_MEMBER(&xml->xml_attrs, i, JSXML);
    1:                 if (!attr)
    1:                     continue;
    1:                 j = XMLARRAY_FIND_MEMBER(&vxml->xml_attrs, attr, attr_identity);
    1:                 if (j == XML_NOT_FOUND) {
    1:                     *bp = JS_FALSE;
    1:                     break;
    1:                 }
    1:                 vattr = XMLARRAY_MEMBER(&vxml->xml_attrs, j, JSXML);
    1:                 if (!vattr)
    1:                     continue;
59890:                 if (!EqualStrings(cx, attr->xml_value, vattr->xml_value, bp))
59890:                     return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* ECMA-357 9.1.1.9 XML [[Equals]] and 9.2.1.9 XMLList [[Equals]]. */
    1: static JSBool
    1: Equals(JSContext *cx, JSXML *xml, jsval v, JSBool *bp)
    1: {
    1:     JSObject *vobj;
    1:     JSXML *vxml;
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(v)) {
    1:         *bp = JS_FALSE;
    1:         if (xml->xml_class == JSXML_CLASS_LIST) {
    1:             if (xml->xml_kids.length == 1) {
    1:                 vxml = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);
    1:                 if (!vxml)
    1:                     return JS_TRUE;
    1:                 vobj = js_GetXMLObject(cx, vxml);
    1:                 if (!vobj)
    1:                     return JS_FALSE;
48470:                 return js_TestXMLEquality(cx, ObjectValue(*vobj), Valueify(v), bp);
    1:             }
    1:             if (JSVAL_IS_VOID(v) && xml->xml_kids.length == 0)
    1:                 *bp = JS_TRUE;
    1:         }
    1:     } else {
    1:         vobj = JSVAL_TO_OBJECT(v);
42693:         if (!vobj->isXML()) {
    1:             *bp = JS_FALSE;
    1:         } else {
32684:             vxml = (JSXML *) vobj->getPrivate();
    1:             if (!XMLEquals(cx, xml, vxml, bp))
    1:                 return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: CheckCycle(JSContext *cx, JSXML *xml, JSXML *kid)
    1: {
    1:     JS_ASSERT(kid->xml_class != JSXML_CLASS_LIST);
    1: 
    1:     do {
    1:         if (xml == kid) {
    1:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                  JSMSG_CYCLIC_VALUE, js_XML_str);
    1:             return JS_FALSE;
    1:         }
    1:     } while ((xml = xml->parent) != NULL);
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* ECMA-357 9.1.1.11 XML [[Insert]]. */
    1: static JSBool
    1: Insert(JSContext *cx, JSXML *xml, uint32 i, jsval v)
    1: {
    1:     uint32 j, n;
    1:     JSXML *vxml, *kid;
    1:     JSObject *vobj;
    1:     JSString *str;
    1: 
    1:     if (!JSXML_HAS_KIDS(xml))
    1:         return JS_TRUE;
    1: 
    1:     n = 1;
    1:     vxml = NULL;
    1:     if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         vobj = JSVAL_TO_OBJECT(v);
42693:         if (vobj->isXML()) {
32684:             vxml = (JSXML *) vobj->getPrivate();
    1:             if (vxml->xml_class == JSXML_CLASS_LIST) {
    1:                 n = vxml->xml_kids.length;
    1:                 if (n == 0)
    1:                     return JS_TRUE;
    1:                 for (j = 0; j < n; j++) {
    1:                     kid = XMLARRAY_MEMBER(&vxml->xml_kids, j, JSXML);
    1:                     if (!kid)
    1:                         continue;
    1:                     if (!CheckCycle(cx, xml, kid))
    1:                         return JS_FALSE;
    1:                 }
    1:             } else if (vxml->xml_class == JSXML_CLASS_ELEMENT) {
    1:                 /* OPTION: enforce that descendants have superset namespaces. */
    1:                 if (!CheckCycle(cx, xml, vxml))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1:     if (!vxml) {
48470:         str = js_ValueToString(cx, Valueify(v));
    1:         if (!str)
    1:             return JS_FALSE;
    1: 
    1:         vxml = js_NewXML(cx, JSXML_CLASS_TEXT);
    1:         if (!vxml)
    1:             return JS_FALSE;
    1:         vxml->xml_value = str;
    1:     }
    1: 
    1:     if (i > xml->xml_kids.length)
    1:         i = xml->xml_kids.length;
    1: 
    1:     if (!XMLArrayInsert(cx, &xml->xml_kids, i, n))
    1:         return JS_FALSE;
    1: 
    1:     if (vxml->xml_class == JSXML_CLASS_LIST) {
    1:         for (j = 0; j < n; j++) {
    1:             kid = XMLARRAY_MEMBER(&vxml->xml_kids, j, JSXML);
    1:             if (!kid)
    1:                 continue;
    1:             kid->parent = xml;
    1:             XMLARRAY_SET_MEMBER(&xml->xml_kids, i + j, kid);
    1: 
    1:             /* OPTION: enforce that descendants have superset namespaces. */
    1:         }
    1:     } else {
    1:         vxml->parent = xml;
    1:         XMLARRAY_SET_MEMBER(&xml->xml_kids, i, vxml);
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* ECMA-357 9.1.1.12 XML [[Replace]]. */
    1: static JSBool
    1: Replace(JSContext *cx, JSXML *xml, uint32 i, jsval v)
    1: {
    1:     uint32 n;
    1:     JSXML *vxml, *kid;
    1:     JSObject *vobj;
    1:     JSString *str;
    1: 
    1:     if (!JSXML_HAS_KIDS(xml))
    1:         return JS_TRUE;
    1: 
    1:     /*
    1:      * 9.1.1.12
    1:      * [[Replace]] handles _i >= x.[[Length]]_ by incrementing _x.[[Length]_.
    1:      * It should therefore constrain callers to pass in _i <= x.[[Length]]_.
    1:      */
    1:     n = xml->xml_kids.length;
    1:     if (i > n)
    1:         i = n;
    1: 
    1:     vxml = NULL;
    1:     if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         vobj = JSVAL_TO_OBJECT(v);
42693:         if (vobj->isXML())
32684:             vxml = (JSXML *) vobj->getPrivate();
    1:     }
    1: 
26751:     switch (vxml ? JSXMLClass(vxml->xml_class) : JSXML_CLASS_LIMIT) {
    1:       case JSXML_CLASS_ELEMENT:
    1:         /* OPTION: enforce that descendants have superset namespaces. */
    1:         if (!CheckCycle(cx, xml, vxml))
    1:             return JS_FALSE;
    1:       case JSXML_CLASS_COMMENT:
    1:       case JSXML_CLASS_PROCESSING_INSTRUCTION:
    1:       case JSXML_CLASS_TEXT:
    1:         goto do_replace;
    1: 
    1:       case JSXML_CLASS_LIST:
    1:         if (i < n)
    1:             DeleteByIndex(cx, xml, i);
    1:         if (!Insert(cx, xml, i, v))
    1:             return JS_FALSE;
    1:         break;
    1: 
    1:       default:
48470:         str = js_ValueToString(cx, Valueify(v));
    1:         if (!str)
    1:             return JS_FALSE;
    1: 
    1:         vxml = js_NewXML(cx, JSXML_CLASS_TEXT);
    1:         if (!vxml)
    1:             return JS_FALSE;
    1:         vxml->xml_value = str;
    1: 
    1:       do_replace:
    1:         vxml->parent = xml;
    1:         if (i < n) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid)
    1:                 kid->parent = NULL;
    1:         }
    1:         if (!XMLARRAY_ADD_MEMBER(cx, &xml->xml_kids, i, vxml))
    1:             return JS_FALSE;
    1:         break;
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* ECMA-357 9.1.1.3 XML [[Delete]], 9.2.1.3 XML [[Delete]] qname cases. */
    1: static void
18520: DeleteNamedProperty(JSContext *cx, JSXML *xml, JSObject *nameqn,
    1:                     JSBool attributes)
    1: {
    1:     JSXMLArray *array;
    1:     uint32 index, deleteCount;
    1:     JSXML *kid;
    1:     JSXMLNameMatcher matcher;
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         array = &xml->xml_kids;
    1:         for (index = 0; index < array->length; index++) {
    1:             kid = XMLARRAY_MEMBER(array, index, JSXML);
    1:             if (kid && kid->xml_class == JSXML_CLASS_ELEMENT)
    1:                 DeleteNamedProperty(cx, kid, nameqn, attributes);
    1:         }
    1:     } else if (xml->xml_class == JSXML_CLASS_ELEMENT) {
    1:         if (attributes) {
    1:             array = &xml->xml_attrs;
    1:             matcher = MatchAttrName;
    1:         } else {
    1:             array = &xml->xml_kids;
    1:             matcher = MatchElemName;
    1:         }
    1:         deleteCount = 0;
    1:         for (index = 0; index < array->length; index++) {
    1:             kid = XMLARRAY_MEMBER(array, index, JSXML);
    1:             if (kid && matcher(nameqn, kid)) {
    1:                 kid->parent = NULL;
    1:                 XMLArrayDelete(cx, array, index, JS_FALSE);
    1:                 ++deleteCount;
    1:             } else if (deleteCount != 0) {
    1:                 XMLARRAY_SET_MEMBER(array,
    1:                                     index - deleteCount,
    1:                                     array->vector[index]);
    1:             }
    1:         }
    1:         array->length -= deleteCount;
    1:     }
    1: }
    1: 
    1: /* ECMA-357 9.2.1.3 index case. */
    1: static void
    1: DeleteListElement(JSContext *cx, JSXML *xml, uint32 index)
    1: {
    1:     JSXML *kid, *parent;
    1:     uint32 kidIndex;
    1: 
    1:     JS_ASSERT(xml->xml_class == JSXML_CLASS_LIST);
    1: 
    1:     if (index < xml->xml_kids.length) {
    1:         kid = XMLARRAY_MEMBER(&xml->xml_kids, index, JSXML);
    1:         if (kid) {
    1:             parent = kid->parent;
    1:             if (parent) {
    1:                 JS_ASSERT(parent != xml);
    1:                 JS_ASSERT(JSXML_HAS_KIDS(parent));
    1: 
    1:                 if (kid->xml_class == JSXML_CLASS_ATTRIBUTE) {
    1:                     DeleteNamedProperty(cx, parent, kid->name, JS_TRUE);
    1:                 } else {
    1:                     kidIndex = XMLARRAY_FIND_MEMBER(&parent->xml_kids, kid,
    1:                                                     NULL);
    1:                     JS_ASSERT(kidIndex != XML_NOT_FOUND);
    1:                     DeleteByIndex(cx, parent, kidIndex);
    1:                 }
    1:             }
    1:             XMLArrayDelete(cx, &xml->xml_kids, index, JS_TRUE);
    1:         }
    1:     }
    1: }
    1: 
    1: static JSBool
    1: SyncInScopeNamespaces(JSContext *cx, JSXML *xml)
    1: {
    1:     JSXMLArray *nsarray;
    1:     uint32 i, n;
18520:     JSObject *ns;
    1: 
    1:     nsarray = &xml->xml_namespaces;
    1:     while ((xml = xml->parent) != NULL) {
    1:         for (i = 0, n = xml->xml_namespaces.length; i < n; i++) {
18520:             ns = XMLARRAY_MEMBER(&xml->xml_namespaces, i, JSObject);
    1:             if (ns && !XMLARRAY_HAS_MEMBER(nsarray, ns, namespace_identity)) {
    1:                 if (!XMLARRAY_APPEND(cx, nsarray, ns))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
18520: GetNamedProperty(JSContext *cx, JSXML *xml, JSObject* nameqn, JSXML *list)
    1: {
    1:     JSXMLArray *array;
    1:     JSXMLNameMatcher matcher;
    1:     JSBool attrs;
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
31884:         JSXMLArrayCursor cursor(&xml->xml_kids);
31884:         while (JSXML *kid = (JSXML *) cursor.getNext()) {
    1:             if (kid->xml_class == JSXML_CLASS_ELEMENT &&
    1:                 !GetNamedProperty(cx, kid, nameqn, list)) {
31884:                 return JS_FALSE;
31884:             }
31884:         }
    1:     } else if (xml->xml_class == JSXML_CLASS_ELEMENT) {
40826:         attrs = (nameqn->getClass() == &js_AttributeNameClass);
    1:         if (attrs) {
    1:             array = &xml->xml_attrs;
    1:             matcher = MatchAttrName;
    1:         } else {
    1:             array = &xml->xml_kids;
    1:             matcher = MatchElemName;
    1:         }
    1: 
31884:         JSXMLArrayCursor cursor(array);
31884:         while (JSXML *kid = (JSXML *) cursor.getNext()) {
    1:             if (matcher(nameqn, kid)) {
    1:                 if (!attrs &&
    1:                     kid->xml_class == JSXML_CLASS_ELEMENT &&
    1:                     !SyncInScopeNamespaces(cx, kid)) {
31884:                     return JS_FALSE;
    1:                 }
    1:                 if (!Append(cx, list, kid))
31884:                     return JS_FALSE;
31884:             }
31884:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* ECMA-357 9.1.1.1 XML [[Get]] and 9.2.1.1 XMLList [[Get]]. */
    1: static JSBool
48470: GetProperty(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
    1:     JSXML *xml, *list, *kid;
    1:     uint32 index;
    1:     JSObject *kidobj, *listobj;
18520:     JSObject *nameqn;
    1:     jsid funid;
    1: 
67943:     if (!obj->isXML())
67943:         return true;
67943:     xml = (JSXML *) obj->getPrivate();
    1:     if (!xml)
40395:         return true;
    1: 
    1:     if (js_IdIsIndex(id, &index)) {
42640:         if (!JSXML_HAS_KIDS(xml)) {
    1:             *vp = (index == 0) ? OBJECT_TO_JSVAL(obj) : JSVAL_VOID;
    1:         } else {
    1:             /*
    1:              * ECMA-357 9.2.1.1 starts here.
    1:              *
    1:              * Erratum: 9.2 is not completely clear that indexed properties
    1:              * correspond to kids, but that's what it seems to say, and it's
    1:              * what any sane user would want.
    1:              */
    1:             if (index < xml->xml_kids.length) {
    1:                 kid = XMLARRAY_MEMBER(&xml->xml_kids, index, JSXML);
    1:                 if (!kid) {
    1:                     *vp = JSVAL_VOID;
40395:                     return true;
    1:                 }
    1:                 kidobj = js_GetXMLObject(cx, kid);
    1:                 if (!kidobj)
40395:                     return false;
    1: 
    1:                 *vp = OBJECT_TO_JSVAL(kidobj);
    1:             } else {
    1:                 *vp = JSVAL_VOID;
    1:             }
    1:         }
40395:         return true;
    1:     }
    1: 
    1:     /*
    1:      * ECMA-357 9.2.1.1/9.1.1.1 qname case.
    1:      */
48470:     nameqn = ToXMLName(cx, IdToJsval(id), &funid);
    1:     if (!nameqn)
40395:         return false;
48470:     if (!JSID_IS_VOID(funid))
26187:         return GetXMLFunction(cx, obj, funid, vp);
    1: 
40395:     jsval roots[2] = { OBJECT_TO_JSVAL(nameqn), JSVAL_NULL };
48470:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(roots), Valueify(roots));
    1: 
    1:     listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
40395:     if (!listobj)
40395:         return false;
40395: 
    1:     roots[1] = OBJECT_TO_JSVAL(listobj);
    1: 
32684:     list = (JSXML *) listobj->getPrivate();
40395:     if (!GetNamedProperty(cx, xml, nameqn, list))
40395:         return false;
40395: 
    1:     /*
    1:      * Erratum: ECMA-357 9.1.1.1 misses that [[Append]] sets the
    1:      * given list's [[TargetProperty]] to the property that is being
    1:      * appended. This means that any use of the internal [[Get]]
    1:      * property returns a list which, when used by e.g. [[Insert]]
    1:      * duplicates the last element matched by id. See bug 336921.
    1:      */
    1:     list->xml_target = xml;
    1:     list->xml_targetprop = nameqn;
    1:     *vp = OBJECT_TO_JSVAL(listobj);
40395:     return true;
    1: }
    1: 
    1: static JSXML *
    1: CopyOnWrite(JSContext *cx, JSXML *xml, JSObject *obj)
    1: {
    1:     JS_ASSERT(xml->object != obj);
    1: 
    1:     xml = DeepCopy(cx, xml, obj, 0);
    1:     if (!xml)
    1:         return NULL;
    1: 
    1:     JS_ASSERT(xml->object == obj);
    1:     return xml;
    1: }
    1: 
    1: #define CHECK_COPY_ON_WRITE(cx,xml,obj)                                       \
    1:     (xml->object == obj ? xml : CopyOnWrite(cx, xml, obj))
    1: 
    1: static JSString *
    1: KidToString(JSContext *cx, JSXML *xml, uint32 index)
    1: {
    1:     JSXML *kid;
    1:     JSObject *kidobj;
    1: 
    1:     kid = XMLARRAY_MEMBER(&xml->xml_kids, index, JSXML);
    1:     if (!kid)
    1:         return cx->runtime->emptyString;
    1:     kidobj = js_GetXMLObject(cx, kid);
    1:     if (!kidobj)
    1:         return NULL;
48470:     return js_ValueToString(cx, ObjectValue(*kidobj));
    1: }
    1: 
    1: /* Forward declared -- its implementation uses other statics that call it. */
    1: static JSBool
    1: ResolveValue(JSContext *cx, JSXML *list, JSXML **result);
    1: 
    1: /* ECMA-357 9.1.1.2 XML [[Put]] and 9.2.1.2 XMLList [[Put]]. */
    1: static JSBool
62395: PutProperty(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
    1: {
    1:     JSBool ok, primitiveAssign;
    1:     enum { OBJ_ROOT, ID_ROOT, VAL_ROOT };
    1:     JSXML *xml, *vxml, *rxml, *kid, *attr, *parent, *copy, *kid2, *match;
    1:     JSObject *vobj, *nameobj, *attrobj, *parentobj, *kidobj, *copyobj;
18520:     JSObject *targetprop, *nameqn, *attrqn;
    1:     uint32 index, i, j, k, n, q, matchIndex;
    1:     jsval attrval, nsval;
    1:     jsid funid;
18520:     JSObject *ns;
    1: 
67943:     if (!obj->isXML())
67943:         return JS_TRUE;
67943:     xml = (JSXML *) obj->getPrivate();
    1:     if (!xml)
    1:         return JS_TRUE;
    1: 
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
    1: 
    1:     /* Precompute vxml for 9.2.1.2 2(c)(vii)(2-3) and 2(d) and 9.1.1.2 1. */
    1:     vxml = NULL;
    1:     if (!JSVAL_IS_PRIMITIVE(*vp)) {
    1:         vobj = JSVAL_TO_OBJECT(*vp);
42693:         if (vobj->isXML())
32684:             vxml = (JSXML *) vobj->getPrivate();
    1:     }
    1: 
    1:     ok = js_EnterLocalRootScope(cx);
    1:     if (!ok)
    1:         return JS_FALSE;
40395: 
18989:     MUST_FLOW_THROUGH("out");
40395:     jsval roots[3];
    1:     roots[OBJ_ROOT] = OBJECT_TO_JSVAL(obj);
48470:     roots[ID_ROOT] = IdToJsval(id);
    1:     roots[VAL_ROOT] = *vp;
48470:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(roots), Valueify(roots));
    1: 
    1:     if (js_IdIsIndex(id, &index)) {
    1:         if (xml->xml_class != JSXML_CLASS_LIST) {
    1:             /* See NOTE in spec: this variation is reserved for future use. */
48470:             ReportBadXMLName(cx, IdToValue(id));
    1:             goto bad;
    1:         }
    1: 
    1:         /*
    1:          * Step 1 of ECMA-357 9.2.1.2 index case sets i to the property index.
    1:          */
    1:         i = index;
    1: 
    1:         /* 2(a-b). */
    1:         if (xml->xml_target) {
    1:             ok = ResolveValue(cx, xml->xml_target, &rxml);
    1:             if (!ok)
    1:                 goto out;
    1:             if (!rxml)
    1:                 goto out;
    1:             JS_ASSERT(rxml->object);
    1:         } else {
    1:             rxml = NULL;
    1:         }
    1: 
    1:         /* 2(c). */
    1:         if (index >= xml->xml_kids.length) {
    1:             /* 2(c)(i). */
    1:             if (rxml) {
    1:                 if (rxml->xml_class == JSXML_CLASS_LIST) {
    1:                     if (rxml->xml_kids.length != 1)
    1:                         goto out;
    1:                     rxml = XMLARRAY_MEMBER(&rxml->xml_kids, 0, JSXML);
    1:                     if (!rxml)
    1:                         goto out;
    1:                     ok = js_GetXMLObject(cx, rxml) != NULL;
    1:                     if (!ok)
    1:                         goto out;
    1:                 }
    1: 
    1:                 /*
    1:                  * Erratum: ECMA-357 9.2.1.2 step 2(c)(ii) sets
    1:                  * _y.[[Parent]] = r_ where _r_ is the result of
    1:                  * [[ResolveValue]] called on _x.[[TargetObject]] in
    1:                  * 2(a)(i).  This can result in text parenting text:
    1:                  *
    1:                  *    var MYXML = new XML();
    1:                  *    MYXML.appendChild(new XML("<TEAM>Giants</TEAM>"));
    1:                  *
    1:                  * (testcase from Werner Sharp <wsharp@macromedia.com>).
    1:                  *
    1:                  * To match insertChildAfter, insertChildBefore,
    1:                  * prependChild, and setChildren, we should silently
    1:                  * do nothing in this case.
    1:                  */
    1:                 if (!JSXML_HAS_KIDS(rxml))
    1:                     goto out;
    1:             }
    1: 
    1:             /* 2(c)(ii) is distributed below as several js_NewXML calls. */
    1:             targetprop = xml->xml_targetprop;
59890:             if (!targetprop || IS_STAR(targetprop->getQNameLocalName())) {
    1:                 /* 2(c)(iv)(1-2), out of order w.r.t. 2(c)(iii). */
    1:                 kid = js_NewXML(cx, JSXML_CLASS_TEXT);
    1:                 if (!kid)
    1:                     goto bad;
    1:             } else {
18520:                 nameobj = targetprop;
40826:                 if (nameobj->getClass() == &js_AttributeNameClass) {
    1:                     /*
    1:                      * 2(c)(iii)(1-3).
    1:                      * Note that rxml can't be null here, because target
    1:                      * and targetprop are non-null.
    1:                      */
    1:                     ok = GetProperty(cx, rxml->object, id, &attrval);
    1:                     if (!ok)
    1:                         goto out;
    1:                     if (JSVAL_IS_PRIMITIVE(attrval))    /* no such attribute */
    1:                         goto out;
    1:                     attrobj = JSVAL_TO_OBJECT(attrval);
32684:                     attr = (JSXML *) attrobj->getPrivate();
    1:                     if (JSXML_LENGTH(attr) != 0)
    1:                         goto out;
    1: 
    1:                     kid = js_NewXML(cx, JSXML_CLASS_ATTRIBUTE);
    1:                 } else {
    1:                     /* 2(c)(v). */
    1:                     kid = js_NewXML(cx, JSXML_CLASS_ELEMENT);
    1:                 }
    1:                 if (!kid)
    1:                     goto bad;
    1: 
    1:                 /* An important bit of 2(c)(ii). */
    1:                 kid->name = targetprop;
    1:             }
    1: 
    1:             /* Final important bit of 2(c)(ii). */
    1:             kid->parent = rxml;
    1: 
    1:             /* 2(c)(vi-vii). */
    1:             i = xml->xml_kids.length;
    1:             if (kid->xml_class != JSXML_CLASS_ATTRIBUTE) {
    1:                 /*
    1:                  * 2(c)(vii)(1) tests whether _y.[[Parent]]_ is not null.
    1:                  * y.[[Parent]] is here called kid->parent, which we know
    1:                  * from 2(c)(ii) is _r_, here called rxml.  So let's just
    1:                  * test that!  Erratum, the spec should be simpler here.
    1:                  */
    1:                 if (rxml) {
    1:                     JS_ASSERT(JSXML_HAS_KIDS(rxml));
    1:                     n = rxml->xml_kids.length;
    1:                     j = n - 1;
    1:                     if (n != 0 && i != 0) {
    1:                         for (n = j, j = 0; j < n; j++) {
    1:                             if (rxml->xml_kids.vector[j] ==
    1:                                 xml->xml_kids.vector[i-1]) {
    1:                                 break;
    1:                             }
    1:                         }
    1:                     }
    1: 
    1:                     kidobj = js_GetXMLObject(cx, kid);
    1:                     if (!kidobj)
    1:                         goto bad;
    1:                     ok = Insert(cx, rxml, j + 1, OBJECT_TO_JSVAL(kidobj));
    1:                     if (!ok)
    1:                         goto out;
    1:                 }
    1: 
    1:                 /*
    1:                  * 2(c)(vii)(2-3).
    1:                  * Erratum: [[PropertyName]] in 2(c)(vii)(3) must be a
    1:                  * typo for [[TargetProperty]].
    1:                  */
    1:                 if (vxml) {
    1:                     kid->name = (vxml->xml_class == JSXML_CLASS_LIST)
    1:                         ? vxml->xml_targetprop
    1:                         : vxml->name;
    1:                 }
    1:             }
    1: 
    1:             /* 2(c)(viii). */
    1:             ok = Append(cx, xml, kid);
    1:             if (!ok)
    1:                 goto out;
    1:         }
    1: 
    1:         /* 2(d). */
    1:         if (!vxml ||
    1:             vxml->xml_class == JSXML_CLASS_TEXT ||
    1:             vxml->xml_class == JSXML_CLASS_ATTRIBUTE) {
    1:             ok = JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp);
    1:             if (!ok)
    1:                 goto out;
    1:             roots[VAL_ROOT] = *vp;
    1:         }
    1: 
    1:         /* 2(e). */
    1:         kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:         if (!kid)
    1:             goto out;
    1:         parent = kid->parent;
    1:         if (kid->xml_class == JSXML_CLASS_ATTRIBUTE) {
18520:             nameobj = kid->name;
40826:             if (nameobj->getClass() != &js_AttributeNameClass) {
60566:                 nameobj = NewXMLAttributeName(cx, nameobj->getNameURI(), nameobj->getNamePrefix(),
60566:                                               nameobj->getQNameLocalName());
    1:                 if (!nameobj)
    1:                     goto bad;
18520:             }
48470:             id = OBJECT_TO_JSID(nameobj);
    1: 
    1:             if (parent) {
    1:                 /* 2(e)(i). */
  217:                 parentobj = js_GetXMLObject(cx, parent);
  217:                 if (!parentobj)
  217:                     goto bad;
62395:                 ok = PutProperty(cx, parentobj, id, strict, vp);
    1:                 if (!ok)
    1:                     goto out;
    1: 
    1:                 /* 2(e)(ii). */
    1:                 ok = GetProperty(cx, parentobj, id, vp);
    1:                 if (!ok)
    1:                     goto out;
32684:                 attr = (JSXML *) JSVAL_TO_OBJECT(*vp)->getPrivate();
    1: 
26669:                 /* 2(e)(iii) - the length check comes from the bug 375406. */
26669:                 if (attr->xml_kids.length != 0)
    1:                     xml->xml_kids.vector[i] = attr->xml_kids.vector[0];
    1:             }
    1:         }
    1: 
    1:         /* 2(f). */
    1:         else if (vxml && vxml->xml_class == JSXML_CLASS_LIST) {
 2183:             /*
 2183:              * 2(f)(i)
 2183:              *
 2183:              * Erratum: the spec says to create a shallow copy _c_ of _V_, but
 2183:              * if we do that we never change the parent of each child in the
 2183:              * list.  Since [[Put]] when called on an XML object deeply copies
 2183:              * the provided list _V_, we also do so here.  Perhaps the shallow
 2183:              * copy was a misguided optimization?
 2183:              */
 2183:             copy = DeepCopyInLRS(cx, vxml, 0);
 2183:             if (!copy)
 2183:                 goto bad;
 2183:             copyobj = js_GetXMLObject(cx, copy);
    1:             if (!copyobj)
    1:                 goto bad;
    1: 
    1:             JS_ASSERT(parent != xml);
    1:             if (parent) {
    1:                 q = XMLARRAY_FIND_MEMBER(&parent->xml_kids, kid, NULL);
    1:                 JS_ASSERT(q != XML_NOT_FOUND);
    1:                 ok = Replace(cx, parent, q, OBJECT_TO_JSVAL(copyobj));
    1:                 if (!ok)
    1:                     goto out;
    1: 
    1: #ifdef DEBUG
    1:                 /* Erratum: this loop in the spec is useless. */
    1:                 for (j = 0, n = copy->xml_kids.length; j < n; j++) {
    1:                     kid2 = XMLARRAY_MEMBER(&parent->xml_kids, q + j, JSXML);
    1:                     JS_ASSERT(XMLARRAY_MEMBER(&copy->xml_kids, j, JSXML)
    1:                               == kid2);
    1:                 }
    1: #endif
    1:             }
    1: 
    1:             /*
    1:              * 2(f)(iv-vi).
    1:              * Erratum: notice the unhandled zero-length V basis case and
    1:              * the off-by-one errors for the n != 0 cases in the spec.
    1:              */
 2183:             n = copy->xml_kids.length;
    1:             if (n == 0) {
    1:                 XMLArrayDelete(cx, &xml->xml_kids, i, JS_TRUE);
    1:             } else {
    1:                 ok = XMLArrayInsert(cx, &xml->xml_kids, i + 1, n - 1);
    1:                 if (!ok)
    1:                     goto out;
    1: 
    1:                 for (j = 0; j < n; j++)
    1:                     xml->xml_kids.vector[i + j] = copy->xml_kids.vector[j];
    1:             }
    1:         }
    1: 
    1:         /* 2(g). */
    1:         else if (vxml || JSXML_HAS_VALUE(kid)) {
    1:             if (parent) {
    1:                 q = XMLARRAY_FIND_MEMBER(&parent->xml_kids, kid, NULL);
    1:                 JS_ASSERT(q != XML_NOT_FOUND);
    1:                 ok = Replace(cx, parent, q, *vp);
    1:                 if (!ok)
    1:                     goto out;
    1: 
    1:                 vxml = XMLARRAY_MEMBER(&parent->xml_kids, q, JSXML);
    1:                 if (!vxml)
    1:                     goto out;
    1:                 roots[VAL_ROOT] = *vp = OBJECT_TO_JSVAL(vxml->object);
    1:             }
    1: 
    1:             /*
    1:              * 2(g)(iii).
    1:              * Erratum: _V_ may not be of type XML, but all index-named
    1:              * properties _x[i]_ in an XMLList _x_ must be of type XML,
    1:              * according to 9.2.1.1 Overview and other places in the spec.
    1:              *
    1:              * Thanks to 2(d), we know _V_ (*vp here) is either a string
    1:              * or an XML/XMLList object.  If *vp is a string, call ToXML
    1:              * on it to satisfy the constraint.
    1:              */
    1:             if (!vxml) {
    1:                 JS_ASSERT(JSVAL_IS_STRING(*vp));
    1:                 vobj = ToXML(cx, *vp);
    1:                 if (!vobj)
    1:                     goto bad;
    1:                 roots[VAL_ROOT] = *vp = OBJECT_TO_JSVAL(vobj);
32684:                 vxml = (JSXML *) vobj->getPrivate();
    1:             }
    1:             XMLARRAY_SET_MEMBER(&xml->xml_kids, i, vxml);
    1:         }
    1: 
    1:         /* 2(h). */
    1:         else {
    1:             kidobj = js_GetXMLObject(cx, kid);
    1:             if (!kidobj)
    1:                 goto bad;
48470:             id = ATOM_TO_JSID(cx->runtime->atomState.starAtom);
62395:             ok = PutProperty(cx, kidobj, id, strict, vp);
    1:             if (!ok)
    1:                 goto out;
    1:         }
    1:     } else {
    1:         /*
    1:          * ECMA-357 9.2.1.2/9.1.1.2 qname case.
    1:          */
48470:         nameqn = ToXMLName(cx, IdToJsval(id), &funid);
    1:         if (!nameqn)
    1:             goto bad;
48470:         if (!JSID_IS_VOID(funid)) {
54169:             ok = js_SetProperty(cx, obj, funid, Valueify(vp), false);
    1:             goto out;
    1:         }
18520:         nameobj = nameqn;
  583:         roots[ID_ROOT] = OBJECT_TO_JSVAL(nameobj);
    1: 
    1:         if (xml->xml_class == JSXML_CLASS_LIST) {
    1:             /*
    1:              * Step 3 of 9.2.1.2.
    1:              * Erratum: if x.[[Length]] > 1 or [[ResolveValue]] returns null
    1:              * or an r with r.[[Length]] != 1, throw TypeError.
    1:              */
    1:             n = JSXML_LENGTH(xml);
    1:             if (n > 1)
    1:                 goto type_error;
    1:             if (n == 0) {
    1:                 ok = ResolveValue(cx, xml, &rxml);
    1:                 if (!ok)
    1:                     goto out;
    1:                 if (!rxml || JSXML_LENGTH(rxml) != 1)
    1:                     goto type_error;
    1:                 ok = Append(cx, xml, rxml);
    1:                 if (!ok)
    1:                     goto out;
    1:             }
    1:             JS_ASSERT(JSXML_LENGTH(xml) == 1);
    1:             xml = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);
    1:             if (!xml)
    1:                 goto out;
    1:             JS_ASSERT(xml->xml_class != JSXML_CLASS_LIST);
    1:             obj = js_GetXMLObject(cx, xml);
    1:             if (!obj)
    1:                 goto bad;
    1:             roots[OBJ_ROOT] = OBJECT_TO_JSVAL(obj);
    1: 
    1:             /* FALL THROUGH to non-list case */
    1:         }
    1: 
    1:         /*
    1:          * ECMA-357 9.1.1.2.
    1:          * Erratum: move steps 3 and 4 to before 1 and 2, to avoid wasted
    1:          * effort in ToString or [[DeepCopy]].
    1:          */
    1: 
    1:         if (JSXML_HAS_VALUE(xml))
    1:             goto out;
    1: 
    1:         if (!vxml ||
    1:             vxml->xml_class == JSXML_CLASS_TEXT ||
    1:             vxml->xml_class == JSXML_CLASS_ATTRIBUTE) {
    1:             ok = JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp);
    1:             if (!ok)
    1:                 goto out;
    1:         } else {
    1:             rxml = DeepCopyInLRS(cx, vxml, 0);
    1:             if (!rxml || !js_GetXMLObject(cx, rxml))
    1:                 goto bad;
    1:             vxml = rxml;
    1:             *vp = OBJECT_TO_JSVAL(vxml->object);
    1:         }
    1:         roots[VAL_ROOT] = *vp;
    1: 
    1:         /*
    1:          * 6.
    1:          * Erratum: why is this done here, so early? use is way later....
    1:          */
    1:         ok = js_GetDefaultXMLNamespace(cx, &nsval);
    1:         if (!ok)
    1:             goto out;
    1: 
40826:         if (nameobj->getClass() == &js_AttributeNameClass) {
    1:             /* 7(a). */
    1:             if (!js_IsXMLName(cx, OBJECT_TO_JSVAL(nameobj)))
    1:                 goto out;
    1: 
    1:             /* 7(b-c). */
    1:             if (vxml && vxml->xml_class == JSXML_CLASS_LIST) {
    1:                 n = vxml->xml_kids.length;
    1:                 if (n == 0) {
    1:                     *vp = STRING_TO_JSVAL(cx->runtime->emptyString);
    1:                 } else {
59890:                     JSString *left = KidToString(cx, vxml, 0);
    1:                     if (!left)
    1:                         goto bad;
    1: 
59890:                     JSString *space = cx->runtime->atomState.spaceAtom;
    1:                     for (i = 1; i < n; i++) {
    1:                         left = js_ConcatStrings(cx, left, space);
    1:                         if (!left)
    1:                             goto bad;
59890:                         JSString *right = KidToString(cx, vxml, i);
    1:                         if (!right)
    1:                             goto bad;
    1:                         left = js_ConcatStrings(cx, left, right);
    1:                         if (!left)
    1:                             goto bad;
    1:                     }
    1: 
    1:                     roots[VAL_ROOT] = *vp = STRING_TO_JSVAL(left);
    1:                 }
    1:             } else {
    1:                 ok = JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp);
    1:                 if (!ok)
    1:                     goto out;
    1:                 roots[VAL_ROOT] = *vp;
    1:             }
    1: 
    1:             /* 7(d-e). */
    1:             match = NULL;
    1:             for (i = 0, n = xml->xml_attrs.length; i < n; i++) {
    1:                 attr = XMLARRAY_MEMBER(&xml->xml_attrs, i, JSXML);
    1:                 if (!attr)
    1:                     continue;
    1:                 attrqn = attr->name;
59890:                 if (EqualStrings(attrqn->getQNameLocalName(), nameqn->getQNameLocalName())) {
59890:                     JSLinearString *uri = nameqn->getNameURI();
59890:                     if (!uri || EqualStrings(attrqn->getNameURI(), uri)) {
    1:                         if (!match) {
    1:                             match = attr;
    1:                         } else {
    1:                             DeleteNamedProperty(cx, xml, attrqn, JS_TRUE);
    1:                             --i;
    1:                         }
    1:                     }
    1:                 }
18520:             }
    1: 
    1:             /* 7(f). */
    1:             attr = match;
    1:             if (!attr) {
    1:                 /* 7(f)(i-ii). */
59890:                 JSLinearString *uri = nameqn->getNameURI();
59890:                 JSLinearString *left, *right;
18520:                 if (!uri) {
    1:                     left = right = cx->runtime->emptyString;
    1:                 } else {
18520:                     left = uri;
59890:                     right = nameqn->getNamePrefix();
59890:                 }
59890:                 nameqn = NewXMLQName(cx, left, right, nameqn->getQNameLocalName());
    1:                 if (!nameqn)
    1:                     goto bad;
    1: 
    1:                 /* 7(f)(iii). */
    1:                 attr = js_NewXML(cx, JSXML_CLASS_ATTRIBUTE);
    1:                 if (!attr)
    1:                     goto bad;
    1:                 attr->parent = xml;
    1:                 attr->name = nameqn;
    1: 
    1:                 /* 7(f)(iv). */
    1:                 ok = XMLARRAY_ADD_MEMBER(cx, &xml->xml_attrs, n, attr);
    1:                 if (!ok)
    1:                     goto out;
    1: 
    1:                 /* 7(f)(v-vi). */
    1:                 ns = GetNamespace(cx, nameqn, NULL);
    1:                 if (!ns)
    1:                     goto bad;
    1:                 ok = AddInScopeNamespace(cx, xml, ns);
    1:                 if (!ok)
    1:                     goto out;
    1:             }
    1: 
    1:             /* 7(g). */
    1:             attr->xml_value = JSVAL_TO_STRING(*vp);
    1:             goto out;
    1:         }
    1: 
    1:         /* 8-9. */
    1:         if (!js_IsXMLName(cx, OBJECT_TO_JSVAL(nameobj)) &&
59890:             !IS_STAR(nameqn->getQNameLocalName())) {
    1:             goto out;
    1:         }
    1: 
    1:         /* 10-11. */
48470:         id = JSID_VOID;
59890:         primitiveAssign = !vxml && !IS_STAR(nameqn->getQNameLocalName());
    1: 
    1:         /* 12. */
    1:         k = n = xml->xml_kids.length;
    1:         matchIndex = XML_NOT_FOUND;
    1:         kid2 = NULL;
    1:         while (k != 0) {
    1:             --k;
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, k, JSXML);
    1:             if (kid && MatchElemName(nameqn, kid)) {
    1:                 if (matchIndex != XML_NOT_FOUND)
    1:                     DeleteByIndex(cx, xml, matchIndex);
    1:                 matchIndex = k;
    1:                 kid2 = kid;
    1:             }
    1:         }
    1: 
    1:         /*
    1:          * Erratum: ECMA-357 specified child insertion inconsistently:
    1:          * insertChildBefore and insertChildAfter insert an arbitrary XML
    1:          * instance, and therefore can create cycles, but appendChild as
    1:          * specified by the "Overview" of 13.4.4.3 calls [[DeepCopy]] on
    1:          * its argument.  But the "Semantics" in 13.4.4.3 do not include
    1:          * any [[DeepCopy]] call.
    1:          *
    1:          * Fixing this (https://bugzilla.mozilla.org/show_bug.cgi?id=312692)
    1:          * required adding cycle detection, and allowing duplicate kids to
    1:          * be created (see comment 6 in the bug).  Allowing duplicate kid
    1:          * references means the loop above will delete all but the lowest
    1:          * indexed reference, and each [[DeleteByIndex]] nulls the kid's
    1:          * parent.  Thus the need to restore parent here.  This is covered
    1:          * by https://bugzilla.mozilla.org/show_bug.cgi?id=327564.
    1:          */
    1:         if (kid2) {
    1:             JS_ASSERT(kid2->parent == xml || !kid2->parent);
    1:             if (!kid2->parent)
    1:                 kid2->parent = xml;
    1:         }
    1: 
    1:         /* 13. */
    1:         if (matchIndex == XML_NOT_FOUND) {
    1:             /* 13(a). */
    1:             matchIndex = n;
    1: 
    1:             /* 13(b). */
    1:             if (primitiveAssign) {
59890:                 JSLinearString *uri = nameqn->getNameURI();
59890:                 JSLinearString *left, *right;
18520:                 if (!uri) {
18520:                     ns = JSVAL_TO_OBJECT(nsval);
59890:                     left = ns->getNameURI();
59890:                     right = ns->getNamePrefix();
    1:                 } else {
18520:                     left = uri;
59890:                     right = nameqn->getNamePrefix();
59890:                 }
59890:                 nameqn = NewXMLQName(cx, left, right, nameqn->getQNameLocalName());
    1:                 if (!nameqn)
    1:                     goto bad;
    1: 
    1:                 /* 13(b)(iii). */
    1:                 vobj = js_NewXMLObject(cx, JSXML_CLASS_ELEMENT);
    1:                 if (!vobj)
    1:                     goto bad;
32684:                 vxml = (JSXML *) vobj->getPrivate();
    1:                 vxml->parent = xml;
    1:                 vxml->name = nameqn;
    1: 
    1:                 /* 13(b)(iv-vi). */
    1:                 ns = GetNamespace(cx, nameqn, NULL);
    1:                 if (!ns)
    1:                     goto bad;
    1:                 ok = Replace(cx, xml, matchIndex, OBJECT_TO_JSVAL(vobj));
    1:                 if (!ok)
    1:                     goto out;
    1:                 ok = AddInScopeNamespace(cx, vxml, ns);
    1:                 if (!ok)
    1:                     goto out;
    1:             }
    1:         }
    1: 
    1:         /* 14. */
    1:         if (primitiveAssign) {
31884:             JSXMLArrayCursor cursor(&xml->xml_kids);
    1:             cursor.index = matchIndex;
31884:             kid = (JSXML *) cursor.getCurrent();
    1:             if (JSXML_HAS_KIDS(kid)) {
47478:                 kid->xml_kids.finish(cx);
47478:                 kid->xml_kids.init();
47478:                 ok = kid->xml_kids.setCapacity(cx, 1);
    1:             }
    1: 
    1:             /* 14(b-c). */
    1:             /* XXXbe Erratum? redundant w.r.t. 7(b-c) else clause above */
    1:             if (ok) {
    1:                 ok = JS_ConvertValue(cx, *vp, JSTYPE_STRING, vp);
29366:                 if (ok && !JSVAL_TO_STRING(*vp)->empty()) {
    1:                     roots[VAL_ROOT] = *vp;
31884:                     if ((JSXML *) cursor.getCurrent() == kid)
    1:                         ok = Replace(cx, kid, 0, *vp);
    1:                 }
    1:             }
    1:         } else {
    1:             /* 15(a). */
    1:             ok = Replace(cx, xml, matchIndex, *vp);
    1:         }
    1:     }
    1: 
    1: out:
    1:     js_LeaveLocalRootScope(cx);
    1:     return ok;
    1: 
    1: type_error:
57812:     {
57812:         JSAutoByteString bytes;
57812:         if (js_ValueToPrintable(cx, IdToValue(id), &bytes))
57812:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_XMLLIST_PUT, bytes.ptr());
57812:     }
    1: bad:
    1:     ok = JS_FALSE;
    1:     goto out;
    1: }
    1: 
    1: /* ECMA-357 9.1.1.10 XML [[ResolveValue]], 9.2.1.10 XMLList [[ResolveValue]]. */
    1: static JSBool
    1: ResolveValue(JSContext *cx, JSXML *list, JSXML **result)
    1: {
    1:     JSXML *target, *base;
18520:     JSObject *targetprop;
48470:     jsid id;
48470:     jsval tv;
    1: 
    1:     if (list->xml_class != JSXML_CLASS_LIST || list->xml_kids.length != 0) {
    1:         if (!js_GetXMLObject(cx, list))
    1:             return JS_FALSE;
    1:         *result = list;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     target = list->xml_target;
    1:     targetprop = list->xml_targetprop;
59890:     if (!target || !targetprop || IS_STAR(targetprop->getQNameLocalName())) {
    1:         *result = NULL;
    1:         return JS_TRUE;
    1:     }
    1: 
40826:     if (targetprop->getClass() == &js_AttributeNameClass) {
    1:         *result = NULL;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     if (!ResolveValue(cx, target, &base))
    1:         return JS_FALSE;
    1:     if (!base) {
    1:         *result = NULL;
    1:         return JS_TRUE;
    1:     }
    1:     if (!js_GetXMLObject(cx, base))
    1:         return JS_FALSE;
    1: 
48470:     id = OBJECT_TO_JSID(targetprop);
    1:     if (!GetProperty(cx, base->object, id, &tv))
    1:         return JS_FALSE;
32684:     target = (JSXML *) JSVAL_TO_OBJECT(tv)->getPrivate();
    1: 
    1:     if (JSXML_LENGTH(target) == 0) {
    1:         if (base->xml_class == JSXML_CLASS_LIST && JSXML_LENGTH(base) > 1) {
    1:             *result = NULL;
    1:             return JS_TRUE;
    1:         }
    1:         tv = STRING_TO_JSVAL(cx->runtime->emptyString);
62395:         if (!PutProperty(cx, base->object, id, false, &tv))
    1:             return JS_FALSE;
    1:         if (!GetProperty(cx, base->object, id, &tv))
    1:             return JS_FALSE;
32684:         target = (JSXML *) JSVAL_TO_OBJECT(tv)->getPrivate();
    1:     }
    1: 
    1:     *result = target;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
18520: HasNamedProperty(JSXML *xml, JSObject *nameqn)
    1: {
    1:     JSBool found;
    1:     JSXMLArray *array;
    1:     JSXMLNameMatcher matcher;
    1:     uint32 i, n;
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         found = JS_FALSE;
31884:         JSXMLArrayCursor cursor(&xml->xml_kids);
31884:         while (JSXML *kid = (JSXML *) cursor.getNext()) {
    1:             found = HasNamedProperty(kid, nameqn);
    1:             if (found)
    1:                 break;
    1:         }
    1:         return found;
    1:     }
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_ELEMENT) {
40826:         if (nameqn->getClass() == &js_AttributeNameClass) {
    1:             array = &xml->xml_attrs;
    1:             matcher = MatchAttrName;
    1:         } else {
    1:             array = &xml->xml_kids;
    1:             matcher = MatchElemName;
    1:         }
    1:         for (i = 0, n = array->length; i < n; i++) {
31884:             JSXML *kid = XMLARRAY_MEMBER(array, i, JSXML);
    1:             if (kid && matcher(nameqn, kid))
    1:                 return JS_TRUE;
    1:         }
    1:     }
    1: 
    1:     return JS_FALSE;
    1: }
    1: 
    1: static JSBool
    1: HasIndexedProperty(JSXML *xml, uint32 i)
    1: {
    1:     if (xml->xml_class == JSXML_CLASS_LIST)
    1:         return i < JSXML_LENGTH(xml);
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_ELEMENT)
    1:         return i == 0;
    1: 
    1:     return JS_FALSE;
    1: }
    1: 
    1: static JSBool
   99: HasSimpleContent(JSXML *xml);
   99: 
   99: static JSBool
    1: HasFunctionProperty(JSContext *cx, JSObject *obj, jsid funid, JSBool *found)
    1: {
    1:     JSObject *pobj;
    1:     JSProperty *prop;
   99:     JSXML *xml;
    1: 
40826:     JS_ASSERT(obj->getClass() == &js_XMLClass);
    1: 
   99:     if (!js_LookupProperty(cx, obj, funid, &pobj, &prop))
40395:         return false;
56567:     if (!prop) {
32684:         xml = (JSXML *) obj->getPrivate();
   99:         if (HasSimpleContent(xml)) {
40395:             AutoObjectRooter tvr(cx);
40395: 
    1:             /*
   99:              * Search in String.prototype to set found whenever
26187:              * GetXMLFunction returns existing function.
    1:              */
40395:             if (!js_GetClassPrototype(cx, NULL, JSProto_String, tvr.addr()))
40395:                 return false;
40395: 
40395:             JS_ASSERT(tvr.object());
40395:             if (!js_LookupProperty(cx, tvr.object(), funid, &pobj, &prop))
40395:                 return false;
   99:         }
   99:     }
    1:     *found = (prop != NULL);
40395:     return true;
    1: }
    1: 
64345: static bool
64345: IdValIsIndex(JSContext *cx, jsval id, jsuint *indexp, bool *isIndex)
64345: {
64345:     if (JSVAL_IS_INT(id)) {
64345:         jsint i;
64345:         i = JSVAL_TO_INT(id);
64345:         if (i < 0) {
64345:             *isIndex = false;
64345:             return true;
64345:         }
64345:         *indexp = (jsuint)i;
64345:         *isIndex = true;
64345:         return true;
64345:     }
64345: 
64345:     if (!JSVAL_IS_STRING(id)) {
64345:         *isIndex = false;
64345:         return true;
64345:     }
64345: 
64345:     JSLinearString *str = JSVAL_TO_STRING(id)->ensureLinear(cx);
64345:     if (!str)
64345:         return false;
64345: 
64345:     *isIndex = js_StringIsIndex(str, indexp);
64345:     return true;
64345: }
64345: 
    1: /* ECMA-357 9.1.1.6 XML [[HasProperty]] and 9.2.1.5 XMLList [[HasProperty]]. */
    1: static JSBool
    1: HasProperty(JSContext *cx, JSObject *obj, jsval id, JSBool *found)
    1: {
    1:     JSXML *xml;
59890:     bool isIndex;
    1:     uint32 i;
18520:     JSObject *qn;
    1:     jsid funid;
    1: 
32684:     xml = (JSXML *) obj->getPrivate();
64345:     if (!IdValIsIndex(cx, id, &i, &isIndex))
59890:         return JS_FALSE;
59890: 
59890:     if (isIndex) {
    1:         *found = HasIndexedProperty(xml, i);
    1:     } else {
    1:         qn = ToXMLName(cx, id, &funid);
    1:         if (!qn)
    1:             return JS_FALSE;
48470:         if (!JSID_IS_VOID(funid)) {
    1:             if (!HasFunctionProperty(cx, obj, funid, found))
    1:                 return JS_FALSE;
    1:         } else {
    1:             *found = HasNamedProperty(xml, qn);
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static void
    1: xml_finalize(JSContext *cx, JSObject *obj)
    1: {
31452:     JSXML *xml = (JSXML *) obj->getPrivate();
    1:     if (!xml)
    1:         return;
    1:     if (xml->object == obj)
    1:         xml->object = NULL;
    1: }
    1: 
    1: static void
  583: xml_trace_vector(JSTracer *trc, JSXML **vec, uint32 len)
    1: {
68933:     MarkXMLRange(trc, len, vec, "xml_vector");
    1: }
    1: 
    1: /*
48622:  * XML objects are native. Thus xml_lookupProperty must return a valid
52503:  * Shape pointer parameter via *propp to signify "property found". Since the
52503:  * only call to xml_lookupProperty is via JSObject::lookupProperty, and then
52503:  * only from js_FindProperty (in jsobj.c, called from jsinterp.c) or from
52503:  * JSOP_IN case in the interpreter, the only time we add a Shape here is when
52503:  * an unqualified name is being accessed or when "name in xml" is called.
    1:  *
   99:  * This scope property keeps the JSOP_NAME code in js_Interpret happy by
52503:  * giving it an shape with (getter, setter) == (GetProperty, PutProperty).
    1:  *
    1:  * NB: xml_deleteProperty must take care to remove any property added here.
   99:  *
   99:  * FIXME This clashes with the function namespace implementation which also
   99:  * uses native properties. Effectively after xml_lookupProperty any property
   99:  * stored previously using assignments to xml.function::name will be removed.
26187:  * We partially workaround the problem in GetXMLFunction. There we take
  402:  * advantage of the fact that typically function:: is used to access the
  402:  * functions from XML.prototype. So when js_GetProperty returns a non-function
  402:  * property, we assume that it represents the result of GetProperty setter
  402:  * hiding the function and use an extra prototype chain lookup to recover it.
  402:  * For a proper solution see bug 355257.
    1: */
    1: static JSBool
    1: xml_lookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                    JSProperty **propp)
    1: {
    1:     JSBool found;
    1:     JSXML *xml;
    1:     uint32 i;
18520:     JSObject *qn;
    1:     jsid funid;
    1: 
32684:     xml = (JSXML *) obj->getPrivate();
48470:     if (js_IdIsIndex(id, &i)) {
    1:         found = HasIndexedProperty(xml, i);
    1:     } else {
48470:         qn = ToXMLName(cx, IdToJsval(id), &funid);
    1:         if (!qn)
    1:             return JS_FALSE;
48470:         if (!JSID_IS_VOID(funid))
    1:             return js_LookupProperty(cx, obj, funid, objp, propp);
    1:         found = HasNamedProperty(xml, qn);
    1:     }
    1:     if (!found) {
    1:         *objp = NULL;
    1:         *propp = NULL;
    1:     } else {
52503:         const Shape *shape =
52503:             js_AddNativeProperty(cx, obj, id,
48470:                                  Valueify(GetProperty), Valueify(PutProperty),
52503:                                  SHAPE_INVALID_SLOT, JSPROP_ENUMERATE,
    1:                                  0, 0);
52503:         if (!shape)
    1:             return JS_FALSE;
    1: 
    1:         *objp = obj;
52503:         *propp = (JSProperty *) shape;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: xml_defineProperty(JSContext *cx, JSObject *obj, jsid id, const Value *v,
62395:                    PropertyOp getter, StrictPropertyOp setter, uintN attrs)
48470: {
48470:     if (IsFunctionObject(*v) || getter || setter ||
    1:         (attrs & JSPROP_ENUMERATE) == 0 ||
    1:         (attrs & (JSPROP_READONLY | JSPROP_PERMANENT | JSPROP_SHARED))) {
48470:         return js_DefineProperty(cx, obj, id, v, getter, setter, attrs);
48470:     }
48470: 
48470:     jsval tmp = Jsvalify(*v);
62395:     return PutProperty(cx, obj, id, false, &tmp);
    1: }
    1: 
    1: static JSBool
56817: xml_getProperty(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, Value *vp)
48470: {
48470:     if (JSID_IS_DEFAULT_XML_NAMESPACE(id)) {
48470:         vp->setUndefined();
    1:         return JS_TRUE;
    1:     }
    1: 
48470:     return GetProperty(cx, obj, id, Jsvalify(vp));
    1: }
    1: 
    1: static JSBool
56760: xml_setProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp, JSBool strict)
48470: {
62395:     return PutProperty(cx, obj, id, strict, Jsvalify(vp));
    1: }
    1: 
    1: static JSBool
43290: xml_getAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
    1: {
    1:     JSBool found;
48470:     if (!HasProperty(cx, obj, IdToJsval(id), &found))
43290:         return false;
43290: 
    1:     *attrsp = found ? JSPROP_ENUMERATE : 0;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
43290: xml_setAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
    1: {
    1:     JSBool found;
48470:     if (!HasProperty(cx, obj, IdToJsval(id), &found))
43290:         return false;
43290: 
    1:     if (found) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_SET_XML_ATTRS);
43290:         return false;
43290:     }
43290:     return true;
    1: }
    1: 
    1: static JSBool
54169: xml_deleteProperty(JSContext *cx, JSObject *obj, jsid id, Value *rval, JSBool strict)
    1: {
    1:     JSXML *xml;
    1:     jsval idval;
    1:     uint32 index;
18520:     JSObject *nameqn;
    1:     jsid funid;
    1: 
48470:     idval = IdToJsval(id);
32684:     xml = (JSXML *) obj->getPrivate();
48470:     if (js_IdIsIndex(id, &index)) {
    1:         if (xml->xml_class != JSXML_CLASS_LIST) {
    1:             /* See NOTE in spec: this variation is reserved for future use. */
48470:             ReportBadXMLName(cx, IdToValue(id));
54169:             return false;
    1:         }
    1: 
    1:         /* ECMA-357 9.2.1.3. */
    1:         DeleteListElement(cx, xml, index);
    1:     } else {
    1:         nameqn = ToXMLName(cx, idval, &funid);
    1:         if (!nameqn)
54169:             return false;
48470:         if (!JSID_IS_VOID(funid))
54169:             return js_DeleteProperty(cx, obj, funid, rval, false);
    1: 
    1:         DeleteNamedProperty(cx, xml, nameqn,
40826:                             nameqn->getClass() == &js_AttributeNameClass);
    1:     }
    1: 
   99:     /*
   99:      * If this object has its own (mutable) scope,  then we may have added a
   99:      * property to the scope in xml_lookupProperty for it to return to mean
   99:      * "found" and to provide a handle for access operations to call the
   99:      * property's getter or setter. But now it's time to remove any such
   99:      * property, to purge the property cache and remove the scope entry.
   99:      */
54169:     if (!obj->nativeEmpty() && !js_DeleteProperty(cx, obj, id, rval, false))
54169:         return false;
   99: 
48470:     rval->setBoolean(true);
54169:     return true;
    1: }
    1: 
72054: static JSString *
72054: xml_toString_helper(JSContext *cx, JSXML *xml);
72054: 
47607: JSBool
72054: xml_convert(JSContext *cx, JSObject *obj, JSType hint, Value *rval)
72054: {
72054:     JS_ASSERT(hint == JSTYPE_NUMBER || hint == JSTYPE_STRING || hint == JSTYPE_VOID);
72054:     JS_ASSERT(obj->isXML());
72054: 
72054:     JS::Anchor<JSObject *> anch(obj);
72054:     JSString *str = xml_toString_helper(cx, reinterpret_cast<JSXML *>(obj->getPrivate()));
67921:     if (!str)
67921:         return false;
67921:     *rval = StringValue(str);
67921:     return true;
    1: }
    1: 
    1: static JSBool
48470: xml_enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op, Value *statep, jsid *idp)
    1: {
    1:     JSXML *xml;
    1:     uint32 length, index;
    1:     JSXMLArrayCursor *cursor;
    1: 
32684:     xml = (JSXML *)obj->getPrivate();
    1:     length = JSXML_LENGTH(xml);
    1: 
    1:     switch (enum_op) {
    1:       case JSENUMERATE_INIT:
47569:       case JSENUMERATE_INIT_ALL:
    1:         if (length == 0) {
48470:             statep->setInt32(0);
    1:         } else {
64559:             cursor = cx->new_<JSXMLArrayCursor>(&xml->xml_kids);
    1:             if (!cursor)
    1:                 return JS_FALSE;
48470:             statep->setPrivate(cursor);
40395:         }
    1:         if (idp)
    1:             *idp = INT_TO_JSID(length);
    1:         break;
    1: 
    1:       case JSENUMERATE_NEXT:
48470:         if (statep->isInt32(0)) {
48470:             statep->setNull();
40395:             break;
40395:         }
48470:         cursor = (JSXMLArrayCursor *) statep->toPrivate();
    1:         if (cursor && cursor->array && (index = cursor->index) < length) {
    1:             *idp = INT_TO_JSID(index);
    1:             cursor->index = index + 1;
    1:             break;
    1:         }
    1:         /* FALL THROUGH */
    1: 
    1:       case JSENUMERATE_DESTROY:
48470:         if (!statep->isInt32(0)) {
48470:             cursor = (JSXMLArrayCursor *) statep->toPrivate();
31884:             if (cursor)
64559:                 cx->delete_(cursor);
40395:         }
48470:         statep->setNull();
    1:         break;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
38633: static JSType
38633: xml_typeOf(JSContext *cx, JSObject *obj)
38633: {
38633:     return JSTYPE_XML;
38633: }
38633: 
    1: static JSBool
48470: xml_hasInstance(JSContext *cx, JSObject *obj, const Value *, JSBool *bp)
    1: {
    1:     return JS_TRUE;
    1: }
    1: 
  583: static void
  583: xml_trace(JSTracer *trc, JSObject *obj)
    1: {
31452:     JSXML *xml = (JSXML *) obj->getPrivate();
  583:     if (xml)
  583:         JS_CALL_TRACER(trc, xml, JSTRACE_XML, "private");
    1: }
    1: 
54563: static JSBool
54563: xml_fix(JSContext *cx, JSObject *obj, bool *success, AutoIdVector *props)
54563: {
54563:     JS_ASSERT(obj->isExtensible());
54563:     *success = false;
54563:     return true;
54563: }
54563: 
    1: static void
    1: xml_clear(JSContext *cx, JSObject *obj)
    1: {
    1: }
    1: 
    1: static JSBool
    1: HasSimpleContent(JSXML *xml)
    1: {
    1:     JSXML *kid;
    1:     JSBool simple;
    1:     uint32 i, n;
    1: 
    1: again:
    1:     switch (xml->xml_class) {
    1:       case JSXML_CLASS_COMMENT:
    1:       case JSXML_CLASS_PROCESSING_INSTRUCTION:
    1:         return JS_FALSE;
    1:       case JSXML_CLASS_LIST:
    1:         if (xml->xml_kids.length == 0)
    1:             return JS_TRUE;
    1:         if (xml->xml_kids.length == 1) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);
    1:             if (kid) {
    1:                 xml = kid;
    1:                 goto again;
    1:             }
    1:         }
    1:         /* FALL THROUGH */
    1:       default:
    1:         simple = JS_TRUE;
    1:         for (i = 0, n = JSXML_LENGTH(xml); i < n; i++) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid && kid->xml_class == JSXML_CLASS_ELEMENT) {
    1:                 simple = JS_FALSE;
    1:                 break;
    1:             }
    1:         }
    1:         return simple;
    1:     }
    1: }
    1: 
    1: /*
    1:  * 11.2.2.1 Step 3(d) onward.
    1:  */
26187: JSBool
48470: js_GetXMLMethod(JSContext *cx, JSObject *obj, jsid id, Value *vp)
48470: {
67943:     JS_ASSERT(obj->isXML());
   99: 
26187:     if (JSID_IS_OBJECT(id)) {
26187:         jsid funid;
26187: 
26187:         if (!js_IsFunctionQName(cx, JSID_TO_OBJECT(id), &funid))
26187:             return JS_FALSE;
48470:         if (!JSID_IS_VOID(funid))
26187:             id = funid;
26187:     }
26187: 
    1:     /*
   99:      * As our callers have a bad habit of passing a pointer to an unrooted
   99:      * local value as vp, we use a proper root here.
    1:      */
40395:     AutoValueRooter tvr(cx);
48470:     JSBool ok = GetXMLFunction(cx, obj, id, Jsvalify(tvr.addr()));
26187:     *vp = tvr.value();
26187:     return ok;
26187: }
26187: 
26187: JSBool
48470: js_TestXMLEquality(JSContext *cx, const Value &v1, const Value &v2, JSBool *bp)
    1: {
    1:     JSXML *xml, *vxml;
    1:     JSObject *vobj;
    1:     JSBool ok;
    1:     JSString *str, *vstr;
    1:     jsdouble d, d2;
    1: 
48470:     JSObject *obj;
48470:     jsval v;
48470:     if (v1.isObject() && v1.toObject().isXML()) {
48470:         obj = &v1.toObject();
48470:         v = Jsvalify(v2);
48470:     } else {
48470:         v = Jsvalify(v1);
48470:         obj = &v2.toObject();
48470:     }
48470: 
67943:     JS_ASSERT(obj->isXML());
48470: 
32684:     xml = (JSXML *) obj->getPrivate();
    1:     vxml = NULL;
    1:     if (!JSVAL_IS_PRIMITIVE(v)) {
    1:         vobj = JSVAL_TO_OBJECT(v);
42693:         if (vobj->isXML())
32684:             vxml = (JSXML *) vobj->getPrivate();
    1:     }
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         ok = Equals(cx, xml, v, bp);
    1:     } else if (vxml) {
    1:         if (vxml->xml_class == JSXML_CLASS_LIST) {
    1:             ok = Equals(cx, vxml, OBJECT_TO_JSVAL(obj), bp);
    1:         } else {
    1:             if (((xml->xml_class == JSXML_CLASS_TEXT ||
    1:                   xml->xml_class == JSXML_CLASS_ATTRIBUTE) &&
    1:                  HasSimpleContent(vxml)) ||
    1:                 ((vxml->xml_class == JSXML_CLASS_TEXT ||
    1:                   vxml->xml_class == JSXML_CLASS_ATTRIBUTE) &&
    1:                  HasSimpleContent(xml))) {
    1:                 ok = js_EnterLocalRootScope(cx);
    1:                 if (ok) {
48470:                     ok = (str = js_ValueToString(cx, ObjectValue(*obj))) &&
48470:                          (vstr = js_ValueToString(cx, Valueify(v)));
    1:                     if (ok)
59890:                         ok = EqualStrings(cx, str, vstr, bp);
    1:                     js_LeaveLocalRootScope(cx);
    1:                 }
    1:             } else {
    1:                 ok = XMLEquals(cx, xml, vxml, bp);
    1:             }
    1:         }
    1:     } else {
    1:         ok = js_EnterLocalRootScope(cx);
    1:         if (ok) {
    1:             if (HasSimpleContent(xml)) {
48470:                 ok = (str = js_ValueToString(cx, ObjectValue(*obj))) &&
48470:                      (vstr = js_ValueToString(cx, Valueify(v)));
    1:                 if (ok)
59890:                     ok = EqualStrings(cx, str, vstr, bp);
    1:             } else if (JSVAL_IS_STRING(v) || JSVAL_IS_NUMBER(v)) {
48470:                 str = js_ValueToString(cx, ObjectValue(*obj));
    1:                 if (!str) {
    1:                     ok = JS_FALSE;
    1:                 } else if (JSVAL_IS_STRING(v)) {
59890:                     ok = EqualStrings(cx, str, JSVAL_TO_STRING(v), bp);
    1:                 } else {
12694:                     ok = JS_ValueToNumber(cx, STRING_TO_JSVAL(str), &d);
    1:                     if (ok) {
    1:                         d2 = JSVAL_IS_INT(v) ? JSVAL_TO_INT(v)
48470:                                              : JSVAL_TO_DOUBLE(v);
    1:                         *bp = JSDOUBLE_COMPARE(d, ==, d2, JS_FALSE);
    1:                     }
    1:                 }
    1:             } else {
    1:                 *bp = JS_FALSE;
    1:             }
    1:             js_LeaveLocalRootScope(cx);
    1:         }
    1:     }
    1:     return ok;
    1: }
    1: 
26187: JSBool
48470: js_ConcatenateXML(JSContext *cx, JSObject *obj, JSObject *robj, Value *vp)
    1: {
    1:     JSBool ok;
48470:     JSObject *listobj;
    1:     JSXML *list, *lxml, *rxml;
    1: 
67943:     JS_ASSERT(obj->isXML());
    1:     ok = js_EnterLocalRootScope(cx);
    1:     if (!ok)
    1:         return JS_FALSE;
    1: 
    1:     listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
    1:     if (!listobj) {
    1:         ok = JS_FALSE;
    1:         goto out;
    1:     }
    1: 
32684:     list = (JSXML *) listobj->getPrivate();
32684:     lxml = (JSXML *) obj->getPrivate();
    1:     ok = Append(cx, list, lxml);
    1:     if (!ok)
    1:         goto out;
    1: 
48470:     JS_ASSERT(robj->isXML());
32684:     rxml = (JSXML *) robj->getPrivate();
    1:     ok = Append(cx, list, rxml);
    1:     if (!ok)
    1:         goto out;
    1: 
48470:     vp->setObject(*listobj);
    1: out:
    1:     js_LeaveLocalRootScopeWithResult(cx, *vp);
    1:     return ok;
    1: }
    1: 
48622: JS_FRIEND_DATA(Class) js_XMLClass = {
48622:     js_XML_str,
64218:     JSCLASS_HAS_PRIVATE |
53557:     JSCLASS_HAS_CACHED_PROTO(JSProto_XML),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     xml_convert,
48622:     xml_finalize,
48622:     NULL,                 /* reserved0   */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
48622:     NULL,                 /* construct   */
48622:     NULL,                 /* xdrObject   */
48622:     xml_hasInstance,
64218:     xml_trace,
48622:     JS_NULL_CLASS_EXT,
48622:     {
43290:         xml_lookupProperty,
43290:         xml_defineProperty,
43290:         xml_getProperty,
43290:         xml_setProperty,
43290:         xml_getAttributes,
43290:         xml_setAttributes,
43290:         xml_deleteProperty,
43290:         xml_enumerate,
43290:         xml_typeOf,
54563:         xml_fix,
43290:         NULL,       /* thisObject     */
43290:         xml_clear
48622:     }
    1: };
    1: 
   99: static JSXML *
 4127: StartNonListXMLMethod(JSContext *cx, jsval *vp, JSObject **objp)
   99: {
   99:     JSXML *xml;
   99:     JSFunction *fun;
 8179:     char numBuf[12];
   99: 
 4127:     JS_ASSERT(VALUE_IS_FUNCTION(cx, *vp));
 4127: 
61734:     *objp = ToObject(cx, Valueify(&vp[1]));
61734:     if (!*objp)
61734:         return NULL;
67943:     if (!(*objp)->isXML()) {
67943:         ReportIncompatibleMethod(cx, Valueify(vp), &js_XMLClass);
67943:         return NULL;
67943:     }
67943:     xml = (JSXML *) (*objp)->getPrivate();
   99:     if (!xml || xml->xml_class != JSXML_CLASS_LIST)
   99:         return xml;
   99: 
   99:     if (xml->xml_kids.length == 1) {
   99:         xml = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);
   99:         if (xml) {
   99:             *objp = js_GetXMLObject(cx, xml);
   99:             if (!*objp)
   99:                 return NULL;
 4127:             vp[1] = OBJECT_TO_JSVAL(*objp);
   99:             return xml;
   99:         }
   99:     }
   99: 
13691:     fun = GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(*vp));
   99:     JS_snprintf(numBuf, sizeof numBuf, "%u", xml->xml_kids.length);
57812:     JSAutoByteString funNameBytes;
57812:     if (const char *funName = GetFunctionNameBytes(cx, fun, &funNameBytes)) {
57812:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NON_LIST_XML_METHOD,
57812:                              funName, numBuf);
57812:     }
  634:     return NULL;
   99: }
   99: 
 4127: /* Beware: these two are not bracketed by JS_BEGIN/END_MACRO. */
    1: #define XML_METHOD_PROLOG                                                     \
61734:     JSObject *obj = ToObject(cx, Valueify(&vp[1]));                           \
61734:     if (!obj)                                                                 \
61734:         return JS_FALSE;                                                      \
67943:     if (!obj->isXML()) {                                                      \
67943:         ReportIncompatibleMethod(cx, Valueify(vp), &js_XMLClass);             \
67943:         return JS_FALSE;                                                      \
67943:     }                                                                         \
67943:     JSXML *xml = (JSXML *)obj->getPrivate();                                  \
 4127:     if (!xml)                                                                 \
 4127:         return JS_FALSE
 4127: 
 4127: #define NON_LIST_XML_METHOD_PROLOG                                            \
 4127:     JSObject *obj;                                                            \
 4127:     JSXML *xml = StartNonListXMLMethod(cx, vp, &obj);                         \
    1:     if (!xml)                                                                 \
    1:         return JS_FALSE;                                                      \
 4127:     JS_ASSERT(xml->xml_class != JSXML_CLASS_LIST)
 4127: 
 4127: static JSBool
 4127: xml_addNamespace(JSContext *cx, uintN argc, jsval *vp)
 4127: {
18520:     JSObject *ns;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
    1:     if (xml->xml_class != JSXML_CLASS_ELEMENT)
16012:         goto done;
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
    1: 
16519:     if (!NamespaceHelper(cx, NULL, argc == 0 ? -1 : 1, vp + 2, vp))
16012:         return JS_FALSE;
16012:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(*vp));
16012: 
18520:     ns = JSVAL_TO_OBJECT(*vp);
    1:     if (!AddInScopeNamespace(cx, xml, ns))
    1:         return JS_FALSE;
42693:     ns->setNamespaceDeclared(JSVAL_TRUE);
16012: 
16012:   done:
 4127:     *vp = OBJECT_TO_JSVAL(obj);
 4127:     return JS_TRUE;
 4127: }
 4127: 
 4127: static JSBool
 4127: xml_appendChild(JSContext *cx, uintN argc, jsval *vp)
 4127: {
48470:     jsval v;
    1:     JSObject *vobj;
 4127:     JSXML *vxml;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
    1: 
48470:     jsid name;
    1:     if (!js_GetAnyName(cx, &name))
    1:         return JS_FALSE;
    1: 
    1:     if (!GetProperty(cx, obj, name, &v))
    1:         return JS_FALSE;
    1: 
    1:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));
    1:     vobj = JSVAL_TO_OBJECT(v);
42693:     JS_ASSERT(vobj->isXML());
32684:     vxml = (JSXML *) vobj->getPrivate();
    1:     JS_ASSERT(vxml->xml_class == JSXML_CLASS_LIST);
    1: 
48470:     if (!IndexToId(cx, vxml->xml_kids.length, &name))
    1:         return JS_FALSE;
16519:     *vp = (argc != 0) ? vp[2] : JSVAL_VOID;
48470: 
62395:     if (!PutProperty(cx, JSVAL_TO_OBJECT(v), name, false, vp))
 4127:         return JS_FALSE;
 4127: 
 4127:     *vp = OBJECT_TO_JSVAL(obj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_attribute(JSContext *cx, uintN argc, jsval *vp)
    1: {
18520:     JSObject *qn;
    1: 
16519:     if (argc == 0) {
48470:         js_ReportMissingArg(cx, Valueify(*vp), 0);
16519:         return JS_FALSE;
16519:     }
16519: 
 4127:     qn = ToAttributeName(cx, vp[2]);
    1:     if (!qn)
    1:         return JS_FALSE;
18520:     vp[2] = OBJECT_TO_JSVAL(qn);        /* local root */
 4127: 
48470:     jsid id = OBJECT_TO_JSID(qn);
61734:     JSObject *obj = ToObject(cx, Valueify(&vp[1]));
61734:     if (!obj)
61734:         return JS_FALSE;
61734:     return GetProperty(cx, obj, id, vp);
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_attributes(JSContext *cx, uintN argc, jsval *vp)
    1: {
64345:     jsval name = STRING_TO_JSVAL(cx->runtime->atomState.starAtom);
33178:     JSObject *qn = ToAttributeName(cx, name);
    1:     if (!qn)
    1:         return JS_FALSE;
48470: 
48470:     AutoObjectRooter tvr(cx, qn);
48470:     jsid id = OBJECT_TO_JSID(qn);
61734:     JSObject *obj = ToObject(cx, Valueify(&vp[1]));
61734:     if (!obj)
61734:         return JS_FALSE;
61734:     return GetProperty(cx, obj, id, vp);
    1: }
    1: 
    1: static JSXML *
    1: xml_list_helper(JSContext *cx, JSXML *xml, jsval *rval)
    1: {
    1:     JSObject *listobj;
    1:     JSXML *list;
    1: 
    1:     listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
    1:     if (!listobj)
    1:         return NULL;
    1: 
    1:     *rval = OBJECT_TO_JSVAL(listobj);
32684:     list = (JSXML *) listobj->getPrivate();
    1:     list->xml_target = xml;
    1:     return list;
    1: }
    1: 
    1: static JSBool
48470: ValueToId(JSContext *cx, jsval v, AutoIdRooter *idr)
48470: {
48470:     if (JSVAL_IS_INT(v)) {
48470:         jsint i = JSVAL_TO_INT(v);
48470:         if (INT_FITS_IN_JSID(i))
48470:             *idr->addr() = INT_TO_JSID(i);
48470:         else if (!js_ValueToStringId(cx, Valueify(v), idr->addr()))
48470:             return JS_FALSE;
48470:     } else if (JSVAL_IS_STRING(v)) {
70270:         JSAtom *atom = js_AtomizeString(cx, JSVAL_TO_STRING(v));
48470:         if (!atom)
48470:             return JS_FALSE;
48470:         *idr->addr() = ATOM_TO_JSID(atom);
48470:     } else if (!JSVAL_IS_PRIMITIVE(v)) {
48470:         *idr->addr() = OBJECT_TO_JSID(JSVAL_TO_OBJECT(v));
48470:     } else {
48470:         ReportBadXMLName(cx, Valueify(v));
48470:         return JS_FALSE;
48470:     }
48470:     return JS_TRUE;
48470: }
48470: 
48470: static JSBool
    1: xml_child_helper(JSContext *cx, JSObject *obj, JSXML *xml, jsval name,
    1:                  jsval *rval)
    1: {
59890:     bool isIndex;
    1:     uint32 index;
    1:     JSXML *kid;
    1:     JSObject *kidobj;
    1: 
    1:     /* ECMA-357 13.4.4.6 */
    1:     JS_ASSERT(xml->xml_class != JSXML_CLASS_LIST);
    1: 
64345:     if (!IdValIsIndex(cx, name, &index, &isIndex))
59890:         return JS_FALSE;
59890: 
59890:     if (isIndex) {
    1:         if (index >= JSXML_LENGTH(xml)) {
    1:             *rval = JSVAL_VOID;
    1:         } else {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, index, JSXML);
    1:             if (!kid) {
    1:                 *rval = JSVAL_VOID;
    1:             } else {
    1:                 kidobj = js_GetXMLObject(cx, kid);
    1:                 if (!kidobj)
    1:                     return JS_FALSE;
    1:                 *rval = OBJECT_TO_JSVAL(kidobj);
    1:             }
    1:         }
    1:         return JS_TRUE;
    1:     }
    1: 
48470:     AutoIdRooter idr(cx);
48470:     if (!ValueToId(cx, name, &idr))
48470:         return JS_FALSE;
48470: 
48470:     return GetProperty(cx, obj, idr.id(), rval);
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_child(JSContext *cx, uintN argc, jsval *vp)
 4127: {
48470:     jsval v;
31884:     JSXML *list, *vxml;
    1:     JSObject *kidobj;
    1: 
    1:     XML_METHOD_PROLOG;
48470:     jsval name = argc != 0 ? vp[2] : JSVAL_VOID;
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         /* ECMA-357 13.5.4.4 */
 4127:         list = xml_list_helper(cx, xml, vp);
    1:         if (!list)
    1:             return JS_FALSE;
    1: 
31884:         JSXMLArrayCursor cursor(&xml->xml_kids);
31884:         while (JSXML *kid = (JSXML *) cursor.getNext()) {
    1:             kidobj = js_GetXMLObject(cx, kid);
    1:             if (!kidobj)
31884:                 return JS_FALSE;
    1:             if (!xml_child_helper(cx, kidobj, kid, name, &v))
31884:                 return JS_FALSE;
    1:             if (JSVAL_IS_VOID(v)) {
    1:                 /* The property didn't exist in this kid. */
    1:                 continue;
    1:             }
    1: 
    1:             JS_ASSERT(!JSVAL_IS_PRIMITIVE(v));
32684:             vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
    1:             if ((!JSXML_HAS_KIDS(vxml) || vxml->xml_kids.length != 0) &&
    1:                 !Append(cx, list, vxml)) {
31884:                 return JS_FALSE;
31884:             }
31884:         }
31884:         return JS_TRUE;
    1:     }
    1: 
    1:     /* ECMA-357 Edition 2 13.3.4.6 (note 13.3, not 13.4 as in Edition 1). */
 4127:     if (!xml_child_helper(cx, obj, xml, name, vp))
 4127:         return JS_FALSE;
 4127:     if (JSVAL_IS_VOID(*vp) && !xml_list_helper(cx, xml, vp))
 4127:         return JS_FALSE;
 4127:     return JS_TRUE;
 4127: }
 4127: 
 4127: static JSBool
 4127: xml_childIndex(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     JSXML *parent;
    1:     uint32 i, n;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
    1:     parent = xml->parent;
    1:     if (!parent || xml->xml_class == JSXML_CLASS_ATTRIBUTE) {
48470:         *vp = DOUBLE_TO_JSVAL(js_NaN);
    1:         return JS_TRUE;
    1:     }
    1:     for (i = 0, n = JSXML_LENGTH(parent); i < n; i++) {
    1:         if (XMLARRAY_MEMBER(&parent->xml_kids, i, JSXML) == xml)
    1:             break;
    1:     }
    1:     JS_ASSERT(i < n);
48470:     if (i <= JSVAL_INT_MAX)
48470:         *vp = INT_TO_JSVAL(i);
48470:     else
48470:         *vp = DOUBLE_TO_JSVAL(i);
48470:     return JS_TRUE;
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_children(JSContext *cx, uintN argc, jsval *vp)
    1: {
61734:     JSObject *obj = ToObject(cx, Valueify(&vp[1]));
61734:     if (!obj)
61734:         return false;
48470:     jsid name = ATOM_TO_JSID(cx->runtime->atomState.starAtom);
61734:     return GetProperty(cx, obj, name, vp);
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_comments_helper(JSContext *cx, JSObject *obj, JSXML *xml, jsval *vp)
 4127: {
 4127:     JSXML *list, *kid, *vxml;
    1:     JSBool ok;
    1:     uint32 i, n;
    1:     JSObject *kidobj;
    1:     jsval v;
    1: 
 4127:     list = xml_list_helper(cx, xml, vp);
    1:     if (!list)
    1:         return JS_FALSE;
    1: 
    1:     ok = JS_TRUE;
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         /* 13.5.4.6 Step 2. */
    1:         for (i = 0, n = JSXML_LENGTH(xml); i < n; i++) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid && kid->xml_class == JSXML_CLASS_ELEMENT) {
    1:                 ok = js_EnterLocalRootScope(cx);
    1:                 if (!ok)
    1:                     break;
    1:                 kidobj = js_GetXMLObject(cx, kid);
    1:                 if (kidobj) {
 4127:                     ok = xml_comments_helper(cx, kidobj, kid, &v);
    1:                 } else {
    1:                     ok = JS_FALSE;
    1:                     v = JSVAL_NULL;
    1:                 }
48470:                 js_LeaveLocalRootScopeWithResult(cx, Valueify(v));
    1:                 if (!ok)
    1:                     break;
32684:                 vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
    1:                 if (JSXML_LENGTH(vxml) != 0) {
    1:                     ok = Append(cx, list, vxml);
    1:                     if (!ok)
    1:                         break;
    1:                 }
    1:             }
    1:         }
    1:     } else {
    1:         /* 13.4.4.9 Step 2. */
    1:         for (i = 0, n = JSXML_LENGTH(xml); i < n; i++) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid && kid->xml_class == JSXML_CLASS_COMMENT) {
    1:                 ok = Append(cx, list, kid);
    1:                 if (!ok)
    1:                     break;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return ok;
    1: }
    1: 
 4127: static JSBool
 4127: xml_comments(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     XML_METHOD_PROLOG;
 4127:     return xml_comments_helper(cx, obj, xml, vp);
 4127: }
 4127: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_contains(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     jsval value;
    1:     JSBool eq;
    1:     JSObject *kidobj;
    1: 
    1:     XML_METHOD_PROLOG;
16519:     value = argc != 0 ? vp[2] : JSVAL_VOID;
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         eq = JS_FALSE;
31884:         JSXMLArrayCursor cursor(&xml->xml_kids);
31884:         while (JSXML *kid = (JSXML *) cursor.getNext()) {
    1:             kidobj = js_GetXMLObject(cx, kid);
48470:             if (!kidobj || !js_TestXMLEquality(cx, ObjectValue(*kidobj), Valueify(value), &eq))
31884:                 return JS_FALSE;
    1:             if (eq)
    1:                 break;
    1:         }
    1:     } else {
48470:         if (!js_TestXMLEquality(cx, ObjectValue(*obj), Valueify(value), &eq))
    1:             return JS_FALSE;
    1:     }
 4127:     *vp = BOOLEAN_TO_JSVAL(eq);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_copy(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     JSXML *copy;
    1: 
    1:     XML_METHOD_PROLOG;
    1:     copy = DeepCopy(cx, xml, NULL, 0);
    1:     if (!copy)
    1:         return JS_FALSE;
 4127:     *vp = OBJECT_TO_JSVAL(copy->object);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_descendants(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     jsval name;
 4127:     JSXML *list;
    1: 
    1:     XML_METHOD_PROLOG;
64345:     name = argc == 0 ? STRING_TO_JSVAL(cx->runtime->atomState.starAtom) : vp[2];
    1:     list = Descendants(cx, xml, name);
    1:     if (!list)
    1:         return JS_FALSE;
 4127:     *vp = OBJECT_TO_JSVAL(list->object);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_elements_helper(JSContext *cx, JSObject *obj, JSXML *xml,
18520:                     JSObject *nameqn, jsval *vp)
 4127: {
31884:     JSXML *list, *vxml;
 4127:     jsval v;
    1:     JSBool ok;
    1:     JSObject *kidobj;
    1:     uint32 i, n;
    1: 
 4127:     list = xml_list_helper(cx, xml, vp);
    1:     if (!list)
    1:         return JS_FALSE;
    1: 
    1:     list->xml_targetprop = nameqn;
    1:     ok = JS_TRUE;
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         /* 13.5.4.6 */
31884:         JSXMLArrayCursor cursor(&xml->xml_kids);
31884:         while (JSXML *kid = (JSXML *) cursor.getNext()) {
    1:             if (kid->xml_class == JSXML_CLASS_ELEMENT) {
    1:                 ok = js_EnterLocalRootScope(cx);
    1:                 if (!ok)
    1:                     break;
    1:                 kidobj = js_GetXMLObject(cx, kid);
    1:                 if (kidobj) {
 4127:                     ok = xml_elements_helper(cx, kidobj, kid, nameqn, &v);
    1:                 } else {
    1:                     ok = JS_FALSE;
    1:                     v = JSVAL_NULL;
    1:                 }
48470:                 js_LeaveLocalRootScopeWithResult(cx, Valueify(v));
    1:                 if (!ok)
    1:                     break;
32684:                 vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
    1:                 if (JSXML_LENGTH(vxml) != 0) {
    1:                     ok = Append(cx, list, vxml);
    1:                     if (!ok)
    1:                         break;
    1:                 }
    1:             }
    1:         }
    1:     } else {
    1:         for (i = 0, n = JSXML_LENGTH(xml); i < n; i++) {
31884:             JSXML *kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid && kid->xml_class == JSXML_CLASS_ELEMENT &&
    1:                 MatchElemName(nameqn, kid)) {
    1:                 ok = Append(cx, list, kid);
    1:                 if (!ok)
    1:                     break;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return ok;
    1: }
    1: 
 4127: static JSBool
 4127: xml_elements(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     jsval name;
18520:     JSObject *nameqn;
 4127:     jsid funid;
 4127: 
 4127:     XML_METHOD_PROLOG;
 4127: 
64345:     name = (argc == 0) ? STRING_TO_JSVAL(cx->runtime->atomState.starAtom) : vp[2];
 4127:     nameqn = ToXMLName(cx, name, &funid);
 4127:     if (!nameqn)
 4127:         return JS_FALSE;
 4127: 
48470:     if (!JSID_IS_VOID(funid))
 4127:         return xml_list_helper(cx, xml, vp) != NULL;
 4127: 
 4127:     return xml_elements_helper(cx, obj, xml, nameqn, vp);
 4127: }
 4127: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_hasOwnProperty(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     jsval name;
    1:     JSBool found;
    1: 
61734:     JSObject *obj = ToObject(cx, Valueify(&vp[1]));
61734:     if (!obj)
61734:         return JS_FALSE;
67943:     if (!obj->isXML()) {
67943:         ReportIncompatibleMethod(cx, Valueify(vp), &js_XMLClass);
67943:         return JS_FALSE;
67943:     }
 4127: 
16519:     name = argc != 0 ? vp[2] : JSVAL_VOID;
    1:     if (!HasProperty(cx, obj, name, &found))
    1:         return JS_FALSE;
    1:     if (found) {
 4127:         *vp = JSVAL_TRUE;
 4127:         return JS_TRUE;
 4127:     }
48470:     return js_HasOwnPropertyHelper(cx, js_LookupProperty, argc, Valueify(vp));
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_hasComplexContent(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     JSXML *kid;
    1:     JSObject *kidobj;
    1:     uint32 i, n;
    1: 
    1:     XML_METHOD_PROLOG;
    1: again:
    1:     switch (xml->xml_class) {
    1:       case JSXML_CLASS_ATTRIBUTE:
    1:       case JSXML_CLASS_COMMENT:
    1:       case JSXML_CLASS_PROCESSING_INSTRUCTION:
    1:       case JSXML_CLASS_TEXT:
 4127:         *vp = JSVAL_FALSE;
    1:         break;
    1:       case JSXML_CLASS_LIST:
    1:         if (xml->xml_kids.length == 0) {
 4127:             *vp = JSVAL_TRUE;
    1:         } else if (xml->xml_kids.length == 1) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);
    1:             if (kid) {
    1:                 kidobj = js_GetXMLObject(cx, kid);
    1:                 if (!kidobj)
    1:                     return JS_FALSE;
    1:                 obj = kidobj;
32684:                 xml = (JSXML *) obj->getPrivate();
    1:                 goto again;
    1:             }
    1:         }
    1:         /* FALL THROUGH */
    1:       default:
 4127:         *vp = JSVAL_FALSE;
    1:         for (i = 0, n = xml->xml_kids.length; i < n; i++) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid && kid->xml_class == JSXML_CLASS_ELEMENT) {
 4127:                 *vp = JSVAL_TRUE;
    1:                 break;
    1:             }
    1:         }
    1:         break;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_hasSimpleContent(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     XML_METHOD_PROLOG;
 4127:     *vp = BOOLEAN_TO_JSVAL(HasSimpleContent(xml));
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: FindInScopeNamespaces(JSContext *cx, JSXML *xml, JSXMLArray *nsarray)
    1: {
    1:     uint32 length, i, j, n;
18520:     JSObject *ns, *ns2;
59890:     JSLinearString *prefix, *prefix2;
    1: 
    1:     length = nsarray->length;
    1:     do {
    1:         if (xml->xml_class != JSXML_CLASS_ELEMENT)
    1:             continue;
    1:         for (i = 0, n = xml->xml_namespaces.length; i < n; i++) {
18520:             ns = XMLARRAY_MEMBER(&xml->xml_namespaces, i, JSObject);
    1:             if (!ns)
    1:                 continue;
    1: 
59890:             prefix = ns->getNamePrefix();
    1:             for (j = 0; j < length; j++) {
18520:                 ns2 = XMLARRAY_MEMBER(nsarray, j, JSObject);
18520:                 if (ns2) {
59890:                     prefix2 = ns2->getNamePrefix();
18520:                     if ((prefix2 && prefix)
59890:                         ? EqualStrings(prefix2, prefix)
59890:                         : EqualStrings(ns2->getNameURI(), ns->getNameURI())) {
    1:                         break;
    1:                     }
    1:                 }
18520:             }
    1: 
    1:             if (j == length) {
    1:                 if (!XMLARRAY_APPEND(cx, nsarray, ns))
    1:                     return JS_FALSE;
    1:                 ++length;
    1:             }
    1:         }
    1:     } while ((xml = xml->parent) != NULL);
    1:     JS_ASSERT(length == nsarray->length);
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
40395: /*
40395:  * Populate a new JS array with elements of array and place the result into
40395:  * rval.  rval must point to a rooted location.
40395:  */
47478: static bool
47478: NamespacesToJSArray(JSContext *cx, JSXMLArray *array, jsval *rval)
47478: {
59234:     JSObject *arrayobj = NewDenseEmptyArray(cx);
40395:     if (!arrayobj)
40395:         return false;
40395:     *rval = OBJECT_TO_JSVAL(arrayobj);
40395: 
47478:     AutoValueRooter tvr(cx);
47478:     for (uint32 i = 0, n = array->length; i < n; i++) {
47478:         JSObject *ns = XMLARRAY_MEMBER(array, i, JSObject);
40395:         if (!ns)
40395:             continue;
48470:         tvr.set(ObjectValue(*ns));
54169:         if (!arrayobj->setProperty(cx, INT_TO_JSID(i), tvr.addr(), false))
40395:             return false;
40395:     }
40395:     return true;
40395: }
40395: 
    1: static JSBool
 4127: xml_inScopeNamespaces(JSContext *cx, uintN argc, jsval *vp)
 4127: {
   99:     NON_LIST_XML_METHOD_PROLOG;
    1: 
40395:     AutoNamespaceArray namespaces(cx);
47478:     return FindInScopeNamespaces(cx, xml, &namespaces.array) &&
47478:            NamespacesToJSArray(cx, &namespaces.array, vp);
    1: }
    1: 
    1: static JSBool
 4127: xml_insertChildAfter(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     jsval arg;
 4127:     JSXML *kid;
    1:     uint32 i;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
16519:     *vp = OBJECT_TO_JSVAL(obj);
16519:     if (!JSXML_HAS_KIDS(xml) || argc == 0)
    1:         return JS_TRUE;
    1: 
 4127:     arg = vp[2];
    1:     if (JSVAL_IS_NULL(arg)) {
    1:         kid = NULL;
    1:         i = 0;
    1:     } else {
42693:         if (!VALUE_IS_XML(arg))
    1:             return JS_TRUE;
32684:         kid = (JSXML *) JSVAL_TO_OBJECT(arg)->getPrivate();
    1:         i = XMLARRAY_FIND_MEMBER(&xml->xml_kids, kid, NULL);
    1:         if (i == XML_NOT_FOUND)
    1:             return JS_TRUE;
    1:         ++i;
    1:     }
    1: 
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
16519:     return Insert(cx, xml, i, argc >= 2 ? vp[3] : JSVAL_VOID);
 4127: }
 4127: 
 4127: static JSBool
 4127: xml_insertChildBefore(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     jsval arg;
 4127:     JSXML *kid;
    1:     uint32 i;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
16519:     *vp = OBJECT_TO_JSVAL(obj);
16519:     if (!JSXML_HAS_KIDS(xml) || argc == 0)
    1:         return JS_TRUE;
    1: 
 4127:     arg = vp[2];
    1:     if (JSVAL_IS_NULL(arg)) {
    1:         kid = NULL;
    1:         i = xml->xml_kids.length;
    1:     } else {
42693:         if (!VALUE_IS_XML(arg))
    1:             return JS_TRUE;
32684:         kid = (JSXML *) JSVAL_TO_OBJECT(arg)->getPrivate();
    1:         i = XMLARRAY_FIND_MEMBER(&xml->xml_kids, kid, NULL);
    1:         if (i == XML_NOT_FOUND)
    1:             return JS_TRUE;
    1:     }
    1: 
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
16519:     return Insert(cx, xml, i, argc >= 2 ? vp[3] : JSVAL_VOID);
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_length(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     XML_METHOD_PROLOG;
    1:     if (xml->xml_class != JSXML_CLASS_LIST) {
 4127:         *vp = JSVAL_ONE;
    1:     } else {
48470:         uint32 l = xml->xml_kids.length;
48470:         if (l <= JSVAL_INT_MAX)
48470:             *vp = INT_TO_JSVAL(l);
48470:         else
48470:             *vp = DOUBLE_TO_JSVAL(l);
 4127:     }
 4127:     return JS_TRUE;
 4127: }
 4127: 
 4127: static JSBool
 4127: xml_localName(JSContext *cx, uintN argc, jsval *vp)
 4127: {
   99:     NON_LIST_XML_METHOD_PROLOG;
59890:     *vp = xml->name ? xml->name->getQNameLocalNameVal() : JSVAL_NULL;
 4127:     return JS_TRUE;
 4127: }
 4127: 
 4127: static JSBool
 4127: xml_name(JSContext *cx, uintN argc, jsval *vp)
 4127: {
   99:     NON_LIST_XML_METHOD_PROLOG;
18520:     *vp = OBJECT_TO_JSVAL(xml->name);
 4127:     return JS_TRUE;
 4127: }
 4127: 
 4127: static JSBool
 4127: xml_namespace(JSContext *cx, uintN argc, jsval *vp)
 4127: {
59890:     JSLinearString *prefix, *nsprefix;
    1:     jsuint i, length;
18520:     JSObject *ns;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
    1:     if (argc == 0 && !JSXML_HAS_NAME(xml)) {
 4127:         *vp = JSVAL_NULL;
40395:         return true;
    1:     }
    1: 
    1:     if (argc == 0) {
    1:         prefix = NULL;
    1:     } else {
59890:         JSString *str = js_ValueToString(cx, Valueify(vp[2]));
59890:         if (!str)
59890:             return false;
59890:         prefix = str->ensureLinear(cx);
    1:         if (!prefix)
40395:             return false;
 4127:         vp[2] = STRING_TO_JSVAL(prefix);      /* local root */
    1:     }
    1: 
40395:     AutoNamespaceArray inScopeNSes(cx);
40395:     if (!FindInScopeNamespaces(cx, xml, &inScopeNSes.array))
40395:         return false;
    1: 
    1:     if (!prefix) {
    1:         ns = GetNamespace(cx, xml->name, &inScopeNSes.array);
40395:         if (!ns)
40395:             return false;
    1:     } else {
    1:         ns = NULL;
    1:         for (i = 0, length = inScopeNSes.array.length; i < length; i++) {
18520:             ns = XMLARRAY_MEMBER(&inScopeNSes.array, i, JSObject);
18520:             if (ns) {
59890:                 nsprefix = ns->getNamePrefix();
59890:                 if (nsprefix && EqualStrings(nsprefix, prefix))
    1:                     break;
    1:                 ns = NULL;
    1:             }
    1:         }
18520:     }
18520: 
18520:     *vp = (!ns) ? JSVAL_VOID : OBJECT_TO_JSVAL(ns);
40395:     return true;
    1: }
    1: 
    1: static JSBool
 4127: xml_namespaceDeclarations(JSContext *cx, uintN argc, jsval *vp)
 4127: {
   99:     NON_LIST_XML_METHOD_PROLOG;
   99:     if (JSXML_HAS_VALUE(xml))
40395:         return true;
40395: 
40395:     AutoNamespaceArray ancestors(cx);
40395:     AutoNamespaceArray declared(cx);
40395: 
40395:     JSXML *yml = xml;
    1:     while ((yml = yml->parent) != NULL) {
    1:         JS_ASSERT(yml->xml_class == JSXML_CLASS_ELEMENT);
40395:         for (uint32 i = 0, n = yml->xml_namespaces.length; i < n; i++) {
40395:             JSObject *ns = XMLARRAY_MEMBER(&yml->xml_namespaces, i, JSObject);
40395:             if (ns && !XMLARRAY_HAS_MEMBER(&ancestors.array, ns, namespace_match)) {
40395:                 if (!XMLARRAY_APPEND(cx, &ancestors.array, ns))
40395:                     return false;
40395:             }
40395:         }
40395:     }
40395: 
40395:     for (uint32 i = 0, n = xml->xml_namespaces.length; i < n; i++) {
40395:         JSObject *ns = XMLARRAY_MEMBER(&xml->xml_namespaces, i, JSObject);
    1:         if (!ns)
    1:             continue;
18520:         if (!IsDeclared(ns))
    1:             continue;
    1:         if (!XMLARRAY_HAS_MEMBER(&ancestors.array, ns, namespace_match)) {
40395:             if (!XMLARRAY_APPEND(cx, &declared.array, ns))
40395:                 return false;
40395:         }
40395:     }
40395: 
47478:     return NamespacesToJSArray(cx, &declared.array, vp);
    1: }
    1: 
    1: static const char js_attribute_str[] = "attribute";
    1: static const char js_text_str[]      = "text";
    1: 
  583: /* Exported to jsgc.c #ifdef DEBUG. */
    1: const char *js_xml_class_str[] = {
    1:     "list",
    1:     "element",
    1:     js_attribute_str,
    1:     "processing-instruction",
    1:     js_text_str,
    1:     "comment"
    1: };
    1: 
    1: static JSBool
 4127: xml_nodeKind(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     JSString *str;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
    1:     str = JS_InternString(cx, js_xml_class_str[xml->xml_class]);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static void
    1: NormalizingDelete(JSContext *cx, JSXML *xml, uint32 index)
    1: {
    1:     if (xml->xml_class == JSXML_CLASS_LIST)
    1:         DeleteListElement(cx, xml, index);
    1:     else
    1:         DeleteByIndex(cx, xml, index);
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_normalize_helper(JSContext *cx, JSObject *obj, JSXML *xml)
 4127: {
 4127:     JSXML *kid, *kid2;
    1:     uint32 i, n;
    1:     JSObject *kidobj;
    1:     JSString *str;
 4127: 
    1:     if (!JSXML_HAS_KIDS(xml))
    1:         return JS_TRUE;
    1: 
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
    1: 
    1:     for (i = 0, n = xml->xml_kids.length; i < n; i++) {
    1:         kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:         if (!kid)
    1:             continue;
    1:         if (kid->xml_class == JSXML_CLASS_ELEMENT) {
    1:             kidobj = js_GetXMLObject(cx, kid);
 4127:             if (!kidobj || !xml_normalize_helper(cx, kidobj, kid))
    1:                 return JS_FALSE;
    1:         } else if (kid->xml_class == JSXML_CLASS_TEXT) {
    1:             while (i + 1 < n &&
    1:                    (kid2 = XMLARRAY_MEMBER(&xml->xml_kids, i + 1, JSXML)) &&
    1:                    kid2->xml_class == JSXML_CLASS_TEXT) {
    1:                 str = js_ConcatStrings(cx, kid->xml_value, kid2->xml_value);
    1:                 if (!str)
    1:                     return JS_FALSE;
    1:                 NormalizingDelete(cx, xml, i + 1);
    1:                 n = xml->xml_kids.length;
    1:                 kid->xml_value = str;
    1:             }
29366:             if (kid->xml_value->empty()) {
    1:                 NormalizingDelete(cx, xml, i);
    1:                 n = xml->xml_kids.length;
    1:                 --i;
    1:             }
    1:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
 4127: static JSBool
 4127: xml_normalize(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     XML_METHOD_PROLOG;
 4127:     *vp = OBJECT_TO_JSVAL(obj);
 4127:     return xml_normalize_helper(cx, obj, xml);
 4127: }
 4127: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_parent(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     JSXML *parent, *kid;
    1:     uint32 i, n;
    1:     JSObject *parentobj;
    1: 
    1:     XML_METHOD_PROLOG;
    1:     parent = xml->parent;
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
 4127:         *vp = JSVAL_VOID;
    1:         n = xml->xml_kids.length;
    1:         if (n == 0)
    1:             return JS_TRUE;
    1: 
    1:         kid = XMLARRAY_MEMBER(&xml->xml_kids, 0, JSXML);
    1:         if (!kid)
    1:             return JS_TRUE;
    1:         parent = kid->parent;
    1:         for (i = 1; i < n; i++) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid && kid->parent != parent)
    1:                 return JS_TRUE;
    1:         }
    1:     }
    1: 
    1:     if (!parent) {
 4127:         *vp = JSVAL_NULL;
    1:         return JS_TRUE;
    1:     }
    1: 
    1:     parentobj = js_GetXMLObject(cx, parent);
    1:     if (!parentobj)
    1:         return JS_FALSE;
 4127:     *vp = OBJECT_TO_JSVAL(parentobj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_processingInstructions_helper(JSContext *cx, JSObject *obj, JSXML *xml,
18520:                                   JSObject *nameqn, jsval *vp)
 4127: {
31884:     JSXML *list, *vxml;
    1:     JSBool ok;
    1:     JSObject *kidobj;
 4127:     jsval v;
    1:     uint32 i, n;
    1: 
 4127:     list = xml_list_helper(cx, xml, vp);
    1:     if (!list)
    1:         return JS_FALSE;
    1: 
    1:     list->xml_targetprop = nameqn;
    1:     ok = JS_TRUE;
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         /* 13.5.4.17 Step 4 (misnumbered 9 -- Erratum?). */
31884:         JSXMLArrayCursor cursor(&xml->xml_kids);
31884:         while (JSXML *kid = (JSXML *) cursor.getNext()) {
    1:             if (kid->xml_class == JSXML_CLASS_ELEMENT) {
    1:                 ok = js_EnterLocalRootScope(cx);
    1:                 if (!ok)
    1:                     break;
    1:                 kidobj = js_GetXMLObject(cx, kid);
    1:                 if (kidobj) {
 4127:                     ok = xml_processingInstructions_helper(cx, kidobj, kid,
 4127:                                                            nameqn, &v);
    1:                 } else {
    1:                     ok = JS_FALSE;
    1:                     v = JSVAL_NULL;
    1:                 }
48470:                 js_LeaveLocalRootScopeWithResult(cx, Valueify(v));
    1:                 if (!ok)
    1:                     break;
32684:                 vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
    1:                 if (JSXML_LENGTH(vxml) != 0) {
    1:                     ok = Append(cx, list, vxml);
    1:                     if (!ok)
    1:                         break;
    1:                 }
    1:             }
    1:         }
    1:     } else {
    1:         /* 13.4.4.28 Step 4. */
    1:         for (i = 0, n = JSXML_LENGTH(xml); i < n; i++) {
31884:             JSXML *kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
18520:             if (kid && kid->xml_class == JSXML_CLASS_PROCESSING_INSTRUCTION) {
59890:                 JSLinearString *localName = nameqn->getQNameLocalName();
18520:                 if (IS_STAR(localName) ||
59890:                     EqualStrings(localName, kid->name->getQNameLocalName())) {
    1:                     ok = Append(cx, list, kid);
    1:                     if (!ok)
    1:                         break;
    1:                 }
    1:             }
    1:         }
18520:     }
    1: 
    1:     return ok;
    1: }
    1: 
    1: static JSBool
 4127: xml_processingInstructions(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     jsval name;
18520:     JSObject *nameqn;
 4127:     jsid funid;
 4127: 
 4127:     XML_METHOD_PROLOG;
 4127: 
64345:     name = (argc == 0) ? STRING_TO_JSVAL(cx->runtime->atomState.starAtom) : vp[2];
 4127:     nameqn = ToXMLName(cx, name, &funid);
 4127:     if (!nameqn)
 4127:         return JS_FALSE;
18520:     vp[2] = OBJECT_TO_JSVAL(nameqn);
 4127: 
48470:     if (!JSID_IS_VOID(funid))
 4127:         return xml_list_helper(cx, xml, vp) != NULL;
 4127: 
 4127:     return xml_processingInstructions_helper(cx, obj, xml, nameqn, vp);
 4127: }
 4127: 
 4127: static JSBool
 4127: xml_prependChild(JSContext *cx, uintN argc, jsval *vp)
 4127: {
   99:     NON_LIST_XML_METHOD_PROLOG;
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
 4127:     *vp = OBJECT_TO_JSVAL(obj);
16519:     return Insert(cx, xml, 0, argc != 0 ? vp[2] : JSVAL_VOID);
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_propertyIsEnumerable(JSContext *cx, uintN argc, jsval *vp)
 4127: {
59890:     bool isIndex;
    1:     uint32 index;
    1: 
    1:     XML_METHOD_PROLOG;
 4127:     *vp = JSVAL_FALSE;
59890:     if (argc != 0) {
64345:         if (!IdValIsIndex(cx, vp[2], &index, &isIndex))
59890:             return JS_FALSE;
59890: 
59890:         if (isIndex) {
    1:             if (xml->xml_class == JSXML_CLASS_LIST) {
    1:                 /* 13.5.4.18. */
 4127:                 *vp = BOOLEAN_TO_JSVAL(index < xml->xml_kids.length);
    1:             } else {
    1:                 /* 13.4.4.30. */
 4127:                 *vp = BOOLEAN_TO_JSVAL(index == 0);
    1:             }
    1:         }
59890:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: namespace_full_match(const void *a, const void *b)
    1: {
18520:     const JSObject *nsa = (const JSObject *) a;
18520:     const JSObject *nsb = (const JSObject *) b;
59890:     JSLinearString *prefixa = nsa->getNamePrefix();
59890:     JSLinearString *prefixb;
18520: 
18520:     if (prefixa) {
59890:         prefixb = nsb->getNamePrefix();
59890:         if (prefixb && !EqualStrings(prefixa, prefixb))
59890:             return JS_FALSE;
59890:     }
59890:     return EqualStrings(nsa->getNameURI(), nsb->getNameURI());
18520: }
18520: 
18520: static JSBool
18520: xml_removeNamespace_helper(JSContext *cx, JSXML *xml, JSObject *ns)
18520: {
18520:     JSObject *thisns, *attrns;
    1:     uint32 i, n;
    1:     JSXML *attr, *kid;
    1: 
    1:     thisns = GetNamespace(cx, xml->name, &xml->xml_namespaces);
    1:     JS_ASSERT(thisns);
    1:     if (thisns == ns)
    1:         return JS_TRUE;
    1: 
    1:     for (i = 0, n = xml->xml_attrs.length; i < n; i++) {
    1:         attr = XMLARRAY_MEMBER(&xml->xml_attrs, i, JSXML);
    1:         if (!attr)
    1:             continue;
    1:         attrns = GetNamespace(cx, attr->name, &xml->xml_namespaces);
    1:         JS_ASSERT(attrns);
    1:         if (attrns == ns)
    1:             return JS_TRUE;
    1:     }
    1: 
    1:     i = XMLARRAY_FIND_MEMBER(&xml->xml_namespaces, ns, namespace_full_match);
    1:     if (i != XML_NOT_FOUND)
    1:         XMLArrayDelete(cx, &xml->xml_namespaces, i, JS_TRUE);
    1: 
    1:     for (i = 0, n = xml->xml_kids.length; i < n; i++) {
    1:         kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:         if (kid && kid->xml_class == JSXML_CLASS_ELEMENT) {
    1:             if (!xml_removeNamespace_helper(cx, kid, ns))
    1:                 return JS_FALSE;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: xml_removeNamespace(JSContext *cx, uintN argc, jsval *vp)
 4127: {
18520:     JSObject *ns;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
    1:     if (xml->xml_class != JSXML_CLASS_ELEMENT)
16012:         goto done;
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
    1: 
16519:     if (!NamespaceHelper(cx, NULL, argc == 0 ? -1 : 1, vp + 2, vp))
16012:         return JS_FALSE;
16012:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(*vp));
18520:     ns = JSVAL_TO_OBJECT(*vp);
    1: 
    1:     /* NOTE: remove ns from each ancestor if not used by that ancestor. */
16012:     if (!xml_removeNamespace_helper(cx, xml, ns))
16012:         return JS_FALSE;
16012:   done:
16012:     *vp = OBJECT_TO_JSVAL(obj);
16012:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: xml_replace(JSContext *cx, uintN argc, jsval *vp)
 4127: {
16012:     jsval value;
 4127:     JSXML *vxml, *kid;
16012:     uint32 index, i;
18520:     JSObject *nameqn;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
    1:     if (xml->xml_class != JSXML_CLASS_ELEMENT)
16012:         goto done;
    1: 
16519:     if (argc <= 1) {
64345:         value = STRING_TO_JSVAL(cx->runtime->atomState.typeAtoms[JSTYPE_VOID]);
16519:     } else {
 4127:         value = vp[3];
42693:         vxml = VALUE_IS_XML(value)
32684:                ? (JSXML *) JSVAL_TO_OBJECT(value)->getPrivate()
    1:                : NULL;
    1:         if (!vxml) {
 4127:             if (!JS_ConvertValue(cx, value, JSTYPE_STRING, &vp[3]))
 4127:                 return JS_FALSE;
 4127:             value = vp[3];
    1:         } else {
    1:             vxml = DeepCopy(cx, vxml, NULL, 0);
    1:             if (!vxml)
    1:                 return JS_FALSE;
 4127:             value = vp[3] = OBJECT_TO_JSVAL(vxml->object);
    1:         }
16519:     }
    1: 
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
    1: 
59890:     bool haveIndex;
59890:     if (argc == 0) {
61207:         haveIndex = false;
59890:     } else {
64345:         if (!IdValIsIndex(cx, vp[2], &index, &haveIndex))
59890:             return JS_FALSE;
59890:     }
59890: 
59890:     if (!haveIndex) {
16012:         /*
16012:          * Call function QName per spec, not ToXMLName, to avoid attribute
16012:          * names.
16012:          */
60566:         if (!QNameHelper(cx, NULL, argc == 0 ? -1 : 1, vp + 2, vp))
60566:             return JS_FALSE;
16012:         JS_ASSERT(!JSVAL_IS_PRIMITIVE(*vp));
18520:         nameqn = JSVAL_TO_OBJECT(*vp);
16012: 
16012:         i = xml->xml_kids.length;
16012:         index = XML_NOT_FOUND;
16012:         while (i != 0) {
16012:             --i;
16012:             kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid && MatchElemName(nameqn, kid)) {
16012:                 if (i != XML_NOT_FOUND)
16012:                     DeleteByIndex(cx, xml, i);
16012:                 index = i;
16012:             }
16012:         }
16012: 
16012:         if (index == XML_NOT_FOUND)
16012:             goto done;
16012:     }
16012: 
16012:     if (!Replace(cx, xml, index, value))
16012:         return JS_FALSE;
16012: 
16012:   done:
16012:     *vp = OBJECT_TO_JSVAL(obj);
16012:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: xml_setChildren(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     JSObject *obj;
 4127: 
 4127:     if (!StartNonListXMLMethod(cx, vp, &obj))
   99:         return JS_FALSE;
   99: 
16519:     *vp = argc != 0 ? vp[2] : JSVAL_VOID;     /* local root */
62395:     if (!PutProperty(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.starAtom), false, vp))
16519:         return JS_FALSE;
 4127: 
 4127:     *vp = OBJECT_TO_JSVAL(obj);
 4127:     return JS_TRUE;
 4127: }
 4127: 
 4127: static JSBool
 4127: xml_setLocalName(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     jsval name;
18520:     JSObject *nameqn;
59890:     JSLinearString *namestr;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
    1:     if (!JSXML_HAS_NAME(xml))
    1:         return JS_TRUE;
    1: 
16519:     if (argc == 0) {
64345:         namestr = cx->runtime->atomState.typeAtoms[JSTYPE_VOID];
16519:     } else {
 4127:         name = vp[2];
    1:         if (!JSVAL_IS_PRIMITIVE(name) &&
48622:             JSVAL_TO_OBJECT(name)->getClass() == &js_QNameClass) {
18520:             nameqn = JSVAL_TO_OBJECT(name);
59890:             namestr = nameqn->getQNameLocalName();
    1:         } else {
 4127:             if (!JS_ConvertValue(cx, name, JSTYPE_STRING, &vp[2]))
 4127:                 return JS_FALSE;
 4127:             name = vp[2];
59890:             namestr = JSVAL_TO_STRING(name)->ensureLinear(cx);
59890:             if (!namestr)
59890:                 return JS_FALSE;
    1:         }
16519:     }
    1: 
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
59890:     if (namestr)
59890:         xml->name->setQNameLocalName(namestr);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: xml_setName(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     jsval name;
18520:     JSObject *nameqn;
 4127:     JSXML *nsowner;
    1:     JSXMLArray *nsarray;
    1:     uint32 i, n;
18520:     JSObject *ns;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
    1:     if (!JSXML_HAS_NAME(xml))
    1:         return JS_TRUE;
    1: 
16519:     if (argc == 0) {
64345:         name = STRING_TO_JSVAL(cx->runtime->atomState.typeAtoms[JSTYPE_VOID]);
16519:     } else {
 4127:         name = vp[2];
    1:         if (!JSVAL_IS_PRIMITIVE(name) &&
48622:             JSVAL_TO_OBJECT(name)->getClass() == &js_QNameClass &&
59890:             !(nameqn = JSVAL_TO_OBJECT(name))->getNameURI()) {
59890:             name = vp[2] = nameqn->getQNameLocalNameVal();
18520:         }
18520:     }
18520: 
48622:     nameqn = js_ConstructObject(cx, &js_QNameClass, NULL, NULL, 1, Valueify(&name));
18520:     if (!nameqn)
18520:         return JS_FALSE;
    1: 
    1:     /* ECMA-357 13.4.4.35 Step 4. */
    1:     if (xml->xml_class == JSXML_CLASS_PROCESSING_INSTRUCTION)
59890:         nameqn->setNameURI(cx->runtime->emptyString);
    1: 
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
    1:     if (!xml)
    1:         return JS_FALSE;
    1:     xml->name = nameqn;
    1: 
    1:     /*
    1:      * Erratum: nothing in 13.4.4.35 talks about making the name match the
    1:      * in-scope namespaces, either by finding an in-scope namespace with a
    1:      * matching uri and setting the new name's prefix to that namespace's
    1:      * prefix, or by extending the in-scope namespaces for xml (which are in
    1:      * xml->parent if xml is an attribute or a PI).
    1:      */
    1:     if (xml->xml_class == JSXML_CLASS_ELEMENT) {
    1:         nsowner = xml;
    1:     } else {
    1:         if (!xml->parent || xml->parent->xml_class != JSXML_CLASS_ELEMENT)
    1:             return JS_TRUE;
    1:         nsowner = xml->parent;
    1:     }
    1: 
59890:     if (nameqn->getNamePrefix()) {
    1:         /*
    1:          * The name being set has a prefix, which originally came from some
    1:          * namespace object (which may be the null namespace, where both the
    1:          * prefix and uri are the empty string).  We must go through a full
    1:          * GetNamespace in case that namespace is in-scope in nsowner.
    1:          *
    1:          * If we find such an in-scope namespace, we return true right away,
    1:          * in this block.  Otherwise, we fall through to the final return of
    1:          * AddInScopeNamespace(cx, nsowner, ns).
    1:          */
    1:         ns = GetNamespace(cx, nameqn, &nsowner->xml_namespaces);
    1:         if (!ns)
    1:             return JS_FALSE;
    1: 
    1:         /* XXXbe have to test membership to see whether GetNamespace added */
    1:         if (XMLARRAY_HAS_MEMBER(&nsowner->xml_namespaces, ns, NULL))
    1:             return JS_TRUE;
    1:     } else {
    1:         /*
18520:          * At this point, we know prefix of nameqn is null, so its uri can't
    1:          * be the empty string (the null namespace always uses the empty string
    1:          * for both prefix and uri).
    1:          *
    1:          * This means we must inline GetNamespace and specialize it to match
    1:          * uri only, never prefix.  If we find a namespace with nameqn's uri
    1:          * already in nsowner->xml_namespaces, then all that we need do is set
18520:          * prefix of nameqn to that namespace's prefix.
    1:          *
    1:          * If no such namespace exists, we can create one without going through
18520:          * the constructor, because we know uri of nameqn is non-empty (so
18520:          * prefix does not need to be converted from null to empty by QName).
    1:          */
59890:         JS_ASSERT(!nameqn->getNameURI()->empty());
    1: 
    1:         nsarray = &nsowner->xml_namespaces;
    1:         for (i = 0, n = nsarray->length; i < n; i++) {
18520:             ns = XMLARRAY_MEMBER(nsarray, i, JSObject);
59890:             if (ns && EqualStrings(ns->getNameURI(), nameqn->getNameURI())) {
42693:                 nameqn->setNamePrefix(ns->getNamePrefix());
18520:                 return JS_TRUE;
18520:             }
18520:         }
18520: 
59890:         ns = NewXMLNamespace(cx, NULL, nameqn->getNameURI(), JS_TRUE);
    1:         if (!ns)
    1:             return JS_FALSE;
    1:     }
    1: 
16519:     if (!AddInScopeNamespace(cx, nsowner, ns))
16519:         return JS_FALSE;
16519:     vp[0] = JSVAL_VOID;
16519:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
 4127: xml_setNamespace(JSContext *cx, uintN argc, jsval *vp)
 4127: {
18520:     JSObject *qn;
18520:     JSObject *ns;
    1:     jsval qnargv[2];
 4127:     JSXML *nsowner;
    1: 
   99:     NON_LIST_XML_METHOD_PROLOG;
   99:     if (!JSXML_HAS_NAME(xml))
   99:         return JS_TRUE;
    1: 
    1:     xml = CHECK_COPY_ON_WRITE(cx, xml, obj);
18520:     if (!xml)
18520:         return JS_FALSE;
18520: 
48622:     ns = js_ConstructObject(cx, &js_NamespaceClass, NULL, obj,
48470:                             argc == 0 ? 0 : 1, Valueify(vp + 2));
18520:     if (!ns)
18520:         return JS_FALSE;
18520:     vp[0] = OBJECT_TO_JSVAL(ns);
42693:     ns->setNamespaceDeclared(JSVAL_TRUE);
18520: 
54647:     qnargv[0] = OBJECT_TO_JSVAL(ns);
18520:     qnargv[1] = OBJECT_TO_JSVAL(xml->name);
48622:     qn = js_ConstructObject(cx, &js_QNameClass, NULL, NULL, 2, Valueify(qnargv));
18520:     if (!qn)
18520:         return JS_FALSE;
18520: 
18520:     xml->name = qn;
    1: 
    1:     /*
    1:      * Erratum: the spec fails to update the governing in-scope namespaces.
    1:      * See the erratum noted in xml_setName, above.
    1:      */
    1:     if (xml->xml_class == JSXML_CLASS_ELEMENT) {
    1:         nsowner = xml;
    1:     } else {
    1:         if (!xml->parent || xml->parent->xml_class != JSXML_CLASS_ELEMENT)
    1:             return JS_TRUE;
    1:         nsowner = xml->parent;
    1:     }
16519:     if (!AddInScopeNamespace(cx, nsowner, ns))
16519:         return JS_FALSE;
16519:     vp[0] = JSVAL_VOID;
16519:     return JS_TRUE;
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_text_helper(JSContext *cx, JSObject *obj, JSXML *xml, jsval *vp)
 4127: {
 4127:     JSXML *list, *kid, *vxml;
    1:     uint32 i, n;
    1:     JSBool ok;
    1:     JSObject *kidobj;
    1:     jsval v;
    1: 
 4127:     list = xml_list_helper(cx, xml, vp);
    1:     if (!list)
    1:         return JS_FALSE;
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         ok = JS_TRUE;
    1:         for (i = 0, n = xml->xml_kids.length; i < n; i++) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid && kid->xml_class == JSXML_CLASS_ELEMENT) {
    1:                 ok = js_EnterLocalRootScope(cx);
    1:                 if (!ok)
    1:                     break;
    1:                 kidobj = js_GetXMLObject(cx, kid);
    1:                 if (kidobj) {
 4127:                     ok = xml_text_helper(cx, kidobj, kid, &v);
    1:                 } else {
    1:                     ok = JS_FALSE;
    1:                     v = JSVAL_NULL;
    1:                 }
48470:                 js_LeaveLocalRootScopeWithResult(cx, Valueify(v));
    1:                 if (!ok)
    1:                     return JS_FALSE;
32684:                 vxml = (JSXML *) JSVAL_TO_OBJECT(v)->getPrivate();
    1:                 if (JSXML_LENGTH(vxml) != 0 && !Append(cx, list, vxml))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     } else {
    1:         for (i = 0, n = JSXML_LENGTH(xml); i < n; i++) {
    1:             kid = XMLARRAY_MEMBER(&xml->xml_kids, i, JSXML);
    1:             if (kid && kid->xml_class == JSXML_CLASS_TEXT) {
    1:                 if (!Append(cx, list, kid))
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
 4127: static JSBool
 4127: xml_text(JSContext *cx, uintN argc, jsval *vp)
 4127: {
 4127:     XML_METHOD_PROLOG;
 4127:     return xml_text_helper(cx, obj, xml, vp);
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSString *
    1: xml_toString_helper(JSContext *cx, JSXML *xml)
    1: {
    1:     JSString *str, *kidstr;
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_ATTRIBUTE ||
    1:         xml->xml_class == JSXML_CLASS_TEXT) {
    1:         return xml->xml_value;
    1:     }
    1: 
    1:     if (!HasSimpleContent(xml))
 9762:         return ToXMLString(cx, OBJECT_TO_JSVAL(xml->object), 0);
    1: 
    1:     str = cx->runtime->emptyString;
 2567:     if (!js_EnterLocalRootScope(cx))
 2567:         return NULL;
31884:     JSXMLArrayCursor cursor(&xml->xml_kids);
31884:     while (JSXML *kid = (JSXML *) cursor.getNext()) {
    1:         if (kid->xml_class != JSXML_CLASS_COMMENT &&
    1:             kid->xml_class != JSXML_CLASS_PROCESSING_INSTRUCTION) {
    1:             kidstr = xml_toString_helper(cx, kid);
    1:             if (!kidstr) {
    1:                 str = NULL;
    1:                 break;
    1:             }
    1:             str = js_ConcatStrings(cx, str, kidstr);
    1:             if (!str)
    1:                 break;
    1:         }
    1:     }
48470:     js_LeaveLocalRootScopeWithResult(cx, str);
    1:     return str;
    1: }
    1: 
    1: static JSBool
 9762: xml_toSource(JSContext *cx, uintN argc, jsval *vp)
 9762: {
61734:     JSObject *obj = ToObject(cx, Valueify(&vp[1]));
61734:     if (!obj)
61734:         return JS_FALSE;
61734:     JSString *str = ToXMLString(cx, OBJECT_TO_JSVAL(obj), TO_SOURCE_FLAG);
 9762:     if (!str)
 9762:         return JS_FALSE;
 9762:     *vp = STRING_TO_JSVAL(str);
 9762:     return JS_TRUE;
 9762: }
 9762: 
 9762: static JSBool
 4127: xml_toString(JSContext *cx, uintN argc, jsval *vp)
 4127: {
    1:     JSString *str;
    1: 
    1:     XML_METHOD_PROLOG;
    1:     str = xml_toString_helper(cx, xml);
    1:     if (!str)
    1:         return JS_FALSE;
 4127:     *vp = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: /* XML and XMLList */
    1: static JSBool
 4127: xml_toXMLString(JSContext *cx, uintN argc, jsval *vp)
 4127: {
61734:     JSObject *obj = ToObject(cx, Valueify(&vp[1]));
61734:     if (!obj)
61734:         return JS_FALSE;
61734:     JSString *str = ToXMLString(cx, OBJECT_TO_JSVAL(obj), 0);
 4127:     if (!str)
 4127:         return JS_FALSE;
 4127:     *vp = STRING_TO_JSVAL(str);
 4127:     return JS_TRUE;
 4127: }
 4127: 
 4127: /* XML and XMLList */
 4127: static JSBool
 4127: xml_valueOf(JSContext *cx, uintN argc, jsval *vp)
 4127: {
61734:     JSObject *obj = ToObject(cx, Valueify(&vp[1]));
61734:     if (!obj)
61734:         return false;
61734:     *vp = OBJECT_TO_JSVAL(obj);
61734:     return true;
    1: }
    1: 
    1: static JSFunctionSpec xml_methods[] = {
16519:     JS_FN("addNamespace",          xml_addNamespace,          1,0),
16519:     JS_FN("appendChild",           xml_appendChild,           1,0),
16519:     JS_FN(js_attribute_str,        xml_attribute,             1,0),
16519:     JS_FN("attributes",            xml_attributes,            0,0),
16519:     JS_FN("child",                 xml_child,                 1,0),
16519:     JS_FN("childIndex",            xml_childIndex,            0,0),
16519:     JS_FN("children",              xml_children,              0,0),
16519:     JS_FN("comments",              xml_comments,              0,0),
16519:     JS_FN("contains",              xml_contains,              1,0),
16519:     JS_FN("copy",                  xml_copy,                  0,0),
16519:     JS_FN("descendants",           xml_descendants,           1,0),
16519:     JS_FN("elements",              xml_elements,              1,0),
16519:     JS_FN("hasOwnProperty",        xml_hasOwnProperty,        1,0),
16519:     JS_FN("hasComplexContent",     xml_hasComplexContent,     1,0),
16519:     JS_FN("hasSimpleContent",      xml_hasSimpleContent,      1,0),
16519:     JS_FN("inScopeNamespaces",     xml_inScopeNamespaces,     0,0),
16519:     JS_FN("insertChildAfter",      xml_insertChildAfter,      2,0),
16519:     JS_FN("insertChildBefore",     xml_insertChildBefore,     2,0),
16519:     JS_FN(js_length_str,           xml_length,                0,0),
16519:     JS_FN(js_localName_str,        xml_localName,             0,0),
16519:     JS_FN(js_name_str,             xml_name,                  0,0),
16519:     JS_FN(js_namespace_str,        xml_namespace,             1,0),
16519:     JS_FN("namespaceDeclarations", xml_namespaceDeclarations, 0,0),
16519:     JS_FN("nodeKind",              xml_nodeKind,              0,0),
16519:     JS_FN("normalize",             xml_normalize,             0,0),
16519:     JS_FN(js_xml_parent_str,       xml_parent,                0,0),
16519:     JS_FN("processingInstructions",xml_processingInstructions,1,0),
16519:     JS_FN("prependChild",          xml_prependChild,          1,0),
16519:     JS_FN("propertyIsEnumerable",  xml_propertyIsEnumerable,  1,0),
16519:     JS_FN("removeNamespace",       xml_removeNamespace,       1,0),
16519:     JS_FN("replace",               xml_replace,               2,0),
16519:     JS_FN("setChildren",           xml_setChildren,           1,0),
16519:     JS_FN("setLocalName",          xml_setLocalName,          1,0),
16519:     JS_FN("setName",               xml_setName,               1,0),
16519:     JS_FN("setNamespace",          xml_setNamespace,          1,0),
16519:     JS_FN(js_text_str,             xml_text,                  0,0),
16519:     JS_FN(js_toSource_str,         xml_toSource,              0,0),
16519:     JS_FN(js_toString_str,         xml_toString,              0,0),
16519:     JS_FN(js_toXMLString_str,      xml_toXMLString,           0,0),
16519:     JS_FN(js_valueOf_str,          xml_valueOf,               0,0),
 4127:     JS_FS_END
    1: };
    1: 
    1: static JSBool
    1: CopyXMLSettings(JSContext *cx, JSObject *from, JSObject *to)
    1: {
    1:     int i;
    1:     const char *name;
    1:     jsval v;
    1: 
43216:     /* Note: PRETTY_INDENT is not a boolean setting. */
43216:     for (i = 0; xml_static_props[i].name; i++) {
    1:         name = xml_static_props[i].name;
    1:         if (!JS_GetProperty(cx, from, name, &v))
43216:             return false;
43216:         if (name == js_prettyIndent_str) {
43216:             if (!JSVAL_IS_NUMBER(v))
43216:                 continue;
43216:         } else {
43216:             if (!JSVAL_IS_BOOLEAN(v))
43216:                 continue;
43216:         }
43216:         if (!JS_SetProperty(cx, to, name, &v))
43216:             return false;
43216:     }
43216: 
43216:     return true;
    1: }
    1: 
    1: static JSBool
    1: SetDefaultXMLSettings(JSContext *cx, JSObject *obj)
    1: {
    1:     int i;
    1:     jsval v;
    1: 
43216:     /* Note: PRETTY_INDENT is not a boolean setting. */
43216:     for (i = 0; xml_static_props[i].name; i++) {
43216:         v = (xml_static_props[i].name != js_prettyIndent_str)
43216:             ? JSVAL_TRUE : INT_TO_JSVAL(2);
    1:         if (!JS_SetProperty(cx, obj, xml_static_props[i].name, &v))
    1:             return JS_FALSE;
    1:     }
43216:     return true;
    1: }
    1: 
    1: static JSBool
 4127: xml_settings(JSContext *cx, uintN argc, jsval *vp)
    1: {
61734:     JSObject *settings = JS_NewObject(cx, NULL, NULL, NULL);
    1:     if (!settings)
61734:         return false;
 4127:     *vp = OBJECT_TO_JSVAL(settings);
61734:     JSObject *obj = ToObject(cx, Valueify(&vp[1]));
61734:     if (!obj)
61734:         return false;
61734:     return CopyXMLSettings(cx, obj, settings);
 4127: }
 4127: 
 4127: static JSBool
 4127: xml_setSettings(JSContext *cx, uintN argc, jsval *vp)
 4127: {
61734:     JSObject *settings;
    1:     jsval v;
    1:     JSBool ok;
 4127: 
61734:     JSObject *obj = ToObject(cx, Valueify(&vp[1]));
11809:     if (!obj)
11809:         return JS_FALSE;
16519:     v = (argc == 0) ? JSVAL_VOID : vp[2];
    1:     if (JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v)) {
    1:         ok = SetDefaultXMLSettings(cx, obj);
    1:     } else {
    1:         if (JSVAL_IS_PRIMITIVE(v))
    1:             return JS_TRUE;
    1:         settings = JSVAL_TO_OBJECT(v);
    1:         ok = CopyXMLSettings(cx, settings, obj);
    1:     }
    1:     return ok;
    1: }
    1: 
    1: static JSBool
 4127: xml_defaultSettings(JSContext *cx, uintN argc, jsval *vp)
    1: {
    1:     JSObject *settings;
    1: 
    1:     settings = JS_NewObject(cx, NULL, NULL, NULL);
    1:     if (!settings)
    1:         return JS_FALSE;
 4127:     *vp = OBJECT_TO_JSVAL(settings);
    1:     return SetDefaultXMLSettings(cx, settings);
    1: }
    1: 
    1: static JSFunctionSpec xml_static_methods[] = {
16519:     JS_FN("settings",         xml_settings,          0,0),
16519:     JS_FN("setSettings",      xml_setSettings,       1,0),
16519:     JS_FN("defaultSettings",  xml_defaultSettings,   0,0),
 4127:     JS_FS_END
    1: };
    1: 
    1: static JSBool
53557: XML(JSContext *cx, uintN argc, Value *vp)
53557: {
    1:     JSXML *xml, *copy;
    1:     JSObject *xobj, *vobj;
48470:     Class *clasp;
    1: 
53557:     jsval v = argc ? Jsvalify(vp[2]) : JSVAL_VOID;
53557: 
    1:     if (JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v))
    1:         v = STRING_TO_JSVAL(cx->runtime->emptyString);
    1: 
    1:     xobj = ToXML(cx, v);
    1:     if (!xobj)
    1:         return JS_FALSE;
32684:     xml = (JSXML *) xobj->getPrivate();
    1: 
53557:     if (IsConstructing(vp) && !JSVAL_IS_PRIMITIVE(v)) {
    1:         vobj = JSVAL_TO_OBJECT(v);
40826:         clasp = vobj->getClass();
    1:         if (clasp == &js_XMLClass ||
    1:             (clasp->flags & JSCLASS_DOCUMENT_OBSERVER)) {
53557:             copy = DeepCopy(cx, xml, NULL, 0);
    1:             if (!copy)
    1:                 return JS_FALSE;
53557:             vp->setObject(*copy->object);
    1:             return JS_TRUE;
    1:         }
    1:     }
53557: 
53557:     vp->setObject(*xobj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
53557: XMLList(JSContext *cx, uintN argc, jsval *vp)
53557: {
    1:     JSObject *vobj, *listobj;
    1:     JSXML *xml, *list;
    1: 
53557:     jsval v = argc ? vp[2] : JSVAL_VOID;
53557: 
    1:     if (JSVAL_IS_NULL(v) || JSVAL_IS_VOID(v))
    1:         v = STRING_TO_JSVAL(cx->runtime->emptyString);
    1: 
53557:     if (IsConstructing(Valueify(vp)) && !JSVAL_IS_PRIMITIVE(v)) {
    1:         vobj = JSVAL_TO_OBJECT(v);
42693:         if (vobj->isXML()) {
32684:             xml = (JSXML *) vobj->getPrivate();
    1:             if (xml->xml_class == JSXML_CLASS_LIST) {
    1:                 listobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
    1:                 if (!listobj)
    1:                     return JS_FALSE;
53557:                 *vp = OBJECT_TO_JSVAL(listobj);
    1: 
32684:                 list = (JSXML *) listobj->getPrivate();
    1:                 if (!Append(cx, list, xml))
    1:                     return JS_FALSE;
    1:                 return JS_TRUE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     /* Toggle on XML support since the script has explicitly requested it. */
    1:     listobj = ToXMLList(cx, v);
    1:     if (!listobj)
    1:         return JS_FALSE;
    1: 
53557:     *vp = OBJECT_TO_JSVAL(listobj);
    1:     return JS_TRUE;
    1: }
    1: 
    1: #ifdef DEBUG_notme
    1: JSCList xml_leaks = JS_INIT_STATIC_CLIST(&xml_leaks);
    1: uint32  xml_serial;
    1: #endif
    1: 
    1: JSXML *
    1: js_NewXML(JSContext *cx, JSXMLClass xml_class)
    1: {
33581:     JSXML *xml = js_NewGCXML(cx);
    1:     if (!xml)
    1:         return NULL;
    1: 
    1:     xml->object = NULL;
    1:     xml->domnode = NULL;
    1:     xml->parent = NULL;
    1:     xml->name = NULL;
    1:     xml->xml_class = xml_class;
    1:     xml->xml_flags = 0;
    1:     if (JSXML_CLASS_HAS_VALUE(xml_class)) {
    1:         xml->xml_value = cx->runtime->emptyString;
    1:     } else {
47478:         xml->xml_kids.init();
    1:         if (xml_class == JSXML_CLASS_LIST) {
    1:             xml->xml_target = NULL;
    1:             xml->xml_targetprop = NULL;
    1:         } else {
47478:             xml->xml_namespaces.init();
47478:             xml->xml_attrs.init();
    1:         }
    1:     }
    1: 
    1: #ifdef DEBUG_notme
    1:     JS_APPEND_LINK(&xml->links, &xml_leaks);
    1:     xml->serial = xml_serial++;
    1: #endif
    1:     return xml;
    1: }
    1: 
    1: void
  583: js_TraceXML(JSTracer *trc, JSXML *xml)
  583: {
  583:     if (xml->object)
54707:         MarkObject(trc, *xml->object, "object");
  583:     if (xml->name)
54707:         MarkObject(trc, *xml->name, "name");
  583:     if (xml->parent)
  583:         JS_CALL_TRACER(trc, xml->parent, JSTRACE_XML, "xml_parent");
    1: 
    1:     if (JSXML_HAS_VALUE(xml)) {
  583:         if (xml->xml_value)
54707:             MarkString(trc, xml->xml_value, "value");
    1:         return;
    1:     }
    1: 
  583:     xml_trace_vector(trc,
    1:                      (JSXML **) xml->xml_kids.vector,
    1:                      xml->xml_kids.length);
  583:     XMLArrayCursorTrace(trc, xml->xml_kids.cursors);
    1: 
    1:     if (xml->xml_class == JSXML_CLASS_LIST) {
    1:         if (xml->xml_target)
  583:             JS_CALL_TRACER(trc, xml->xml_target, JSTRACE_XML, "target");
18520:         if (xml->xml_targetprop)
54707:             MarkObject(trc, *xml->xml_targetprop, "targetprop");
    1:     } else {
48470:         MarkObjectRange(trc, xml->xml_namespaces.length,
18520:                         (JSObject **) xml->xml_namespaces.vector,
48470:                         "xml_namespaces");
  583:         XMLArrayCursorTrace(trc, xml->xml_namespaces.cursors);
    1: 
  583:         xml_trace_vector(trc,
    1:                          (JSXML **) xml->xml_attrs.vector,
    1:                          xml->xml_attrs.length);
  583:         XMLArrayCursorTrace(trc, xml->xml_attrs.cursors);
    1:     }
    1: }
    1: 
    1: JSObject *
    1: js_NewXMLObject(JSContext *cx, JSXMLClass xml_class)
    1: {
40395:     JSXML *xml = js_NewXML(cx, xml_class);
    1:     if (!xml)
    1:         return NULL;
40395: 
40395:     AutoXMLRooter root(cx, xml);
40395:     return js_GetXMLObject(cx, xml);
    1: }
    1: 
    1: static JSObject *
    1: NewXMLObject(JSContext *cx, JSXML *xml)
    1: {
    1:     JSObject *obj;
    1: 
73984:     JSObject *parent = GetGlobalForScopeChain(cx);
73984:     obj = NewNonFunction<WithProto::Class>(cx, &js_XMLClass, NULL, parent);
31452:     if (!obj)
    1:         return NULL;
31452:     obj->setPrivate(xml);
    1:     return obj;
    1: }
    1: 
    1: JSObject *
    1: js_GetXMLObject(JSContext *cx, JSXML *xml)
    1: {
    1:     JSObject *obj;
    1: 
    1:     obj = xml->object;
    1:     if (obj) {
32684:         JS_ASSERT(obj->getPrivate() == xml);
    1:         return obj;
    1:     }
    1: 
    1:     obj = NewXMLObject(cx, xml);
    1:     if (!obj)
    1:         return NULL;
    1:     xml->object = obj;
    1:     return obj;
    1: }
    1: 
    1: JSObject *
    1: js_InitNamespaceClass(JSContext *cx, JSObject *obj)
    1: {
48622:     return js_InitClass(cx, obj, NULL, &js_NamespaceClass, Namespace, 2,
72069:                         NULL, namespace_methods, NULL, NULL);
    1: }
    1: 
    1: JSObject *
    1: js_InitQNameClass(JSContext *cx, JSObject *obj)
    1: {
48622:     return js_InitClass(cx, obj, NULL, &js_QNameClass, QName, 2,
72069:                         NULL, qname_methods, NULL, NULL);
    1: }
    1: 
    1: JSObject *
    1: js_InitXMLClass(JSContext *cx, JSObject *obj)
    1: {
    1:     /* Define the isXMLName function. */
    1:     if (!JS_DefineFunction(cx, obj, js_isXMLName_str, xml_isXMLName, 1, 0))
    1:         return NULL;
    1: 
    1:     /* Define the XML class constructor and prototype. */
72080:     JSObject *proto = js_InitClass(cx, obj, NULL, &js_XMLClass, XML, 1,
72080:                                    NULL, xml_methods, xml_static_props, xml_static_methods);
    1:     if (!proto)
    1:         return NULL;
    1: 
72080:     JSXML *xml = js_NewXML(cx, JSXML_CLASS_TEXT);
31452:     if (!xml)
    1:         return NULL;
31452:     proto->setPrivate(xml);
    1:     xml->object = proto;
    1: 
    1:     /*
    1:      * Prepare to set default settings on the XML constructor we just made.
31501:      * NB: We can't use JS_GetConstructor, because it calls
31501:      * JSObject::getProperty, which is xml_getProperty, which creates a new
31501:      * XMLList every time!  We must instead call js_LookupProperty directly.
    1:      */
72080:     JSObject *pobj;
72080:     JSProperty *prop;
    1:     if (!js_LookupProperty(cx, proto,
    1:                            ATOM_TO_JSID(cx->runtime->atomState.constructorAtom),
    1:                            &pobj, &prop)) {
    1:         return NULL;
    1:     }
    1:     JS_ASSERT(prop);
72080:     Shape *shape = (Shape *) prop;
72080:     jsval cval = Jsvalify(pobj->nativeGetSlot(shape->slot));
    1:     JS_ASSERT(VALUE_IS_FUNCTION(cx, cval));
    1: 
    1:     /* Set default settings. */
72080:     jsval vp[3];
 4127:     vp[0] = JSVAL_NULL;
 4127:     vp[1] = cval;
 4127:     vp[2] = JSVAL_VOID;
 4127:     if (!xml_setSettings(cx, 1, vp))
    1:         return NULL;
    1: 
    1:     /* Define the XMLList function and give it the same prototype as XML. */
72080:     JSFunction *fun = JS_DefineFunction(cx, obj, js_XMLList_str, XMLList, 1, JSFUN_CONSTRUCTOR);
    1:     if (!fun)
    1:         return NULL;
73788:     if (!LinkConstructorAndPrototype(cx, FUN_OBJECT(fun), proto))
    1:         return NULL;
73788: 
    1:     return proto;
    1: }
    1: 
    1: JSObject *
    1: js_InitXMLClasses(JSContext *cx, JSObject *obj)
    1: {
    1:     if (!js_InitNamespaceClass(cx, obj))
    1:         return NULL;
    1:     if (!js_InitQNameClass(cx, obj))
    1:         return NULL;
    1:     return js_InitXMLClass(cx, obj);
    1: }
    1: 
68955: namespace js {
68955: 
68955: bool
68955: GlobalObject::getFunctionNamespace(JSContext *cx, Value *vp)
68955: {
68955:     Value &v = getSlotRef(FUNCTION_NS);
68955:     if (v.isUndefined()) {
55674:         JSRuntime *rt = cx->runtime;
61208:         JSLinearString *prefix = rt->atomState.typeAtoms[JSTYPE_FUNCTION];
61208:         JSLinearString *uri = rt->atomState.functionNamespaceURIAtom;
61208:         JSObject *obj = NewXMLNamespace(cx, prefix, uri, JS_FALSE);
    1:         if (!obj)
55674:             return false;
    1: 
    1:         /*
    1:          * Avoid entraining any in-scope Object.prototype.  The loss of
    1:          * Namespace.prototype is not detectable, as there is no way to
    1:          * refer to this instance in scripts.  When used to qualify method
    1:          * names, its prefix and uri references are copied to the QName.
61208:          * The parent remains set and links back to global.
    1:          */
39928:         obj->clearProto();
61208: 
68955:         v.setObject(*obj);
68955:     }
68955: 
68955:     *vp = v;
55674:     return true;
    1: }
    1: 
68955: } // namespace js
68955: 
    1: /*
    1:  * Note the asymmetry between js_GetDefaultXMLNamespace and js_SetDefaultXML-
    1:  * Namespace.  Get searches fp->scopeChain for JS_DEFAULT_XML_NAMESPACE_ID,
32547:  * while Set sets JS_DEFAULT_XML_NAMESPACE_ID in fp->varobj. There's no
37777:  * requirement that fp->varobj lie directly on fp->scopeChain, although
37777:  * it should be reachable using the prototype chain from a scope object (cf.
32547:  * JSOPTION_VAROBJFIX in jsapi.h).
    1:  *
    1:  * If Get can't find JS_DEFAULT_XML_NAMESPACE_ID along the scope chain, it
    1:  * creates a default namespace via 'new Namespace()'.  In contrast, Set uses
    1:  * its v argument as the uri of a new Namespace, with "" as the prefix.  See
    1:  * ECMA-357 12.1 and 12.1.1.  Note that if Set is called with a Namespace n,
    1:  * the default XML namespace will be set to ("", n.uri).  So the uri string
    1:  * is really the only usefully stored value of the default namespace.
    1:  */
    1: JSBool
    1: js_GetDefaultXMLNamespace(JSContext *cx, jsval *vp)
    1: {
18520:     JSObject *ns, *obj, *tmp;
    1:     jsval v;
    1: 
62953:     JSObject *scopeChain = GetScopeChain(cx);
    1: 
    1:     obj = NULL;
53557:     for (tmp = scopeChain; tmp; tmp = tmp->getParent()) {
48470:         Class *clasp = tmp->getClass();
26727:         if (clasp == &js_BlockClass || clasp == &js_WithClass)
26727:             continue;
48470:         if (!tmp->getProperty(cx, JS_DEFAULT_XML_NAMESPACE_ID, Valueify(&v)))
    1:             return JS_FALSE;
    1:         if (!JSVAL_IS_PRIMITIVE(v)) {
    1:             *vp = v;
    1:             return JS_TRUE;
    1:         }
26727:         obj = tmp;
    1:     }
    1: 
48622:     ns = js_ConstructObject(cx, &js_NamespaceClass, NULL, obj, 0, NULL);
18520:     if (!ns)
18520:         return JS_FALSE;
18520:     v = OBJECT_TO_JSVAL(ns);
48470:     if (!obj->defineProperty(cx, JS_DEFAULT_XML_NAMESPACE_ID, Valueify(v),
62395:                              PropertyStub, StrictPropertyStub, JSPROP_PERMANENT)) {
    1:         return JS_FALSE;
    1:     }
    1:     *vp = v;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
48470: js_SetDefaultXMLNamespace(JSContext *cx, const Value &v)
48470: {
48470:     Value argv[2];
48470:     argv[0].setString(cx->runtime->emptyString);
    1:     argv[1] = v;
53840:     JSObject *ns = js_ConstructObject(cx, &js_NamespaceClass, NULL, NULL, 2, argv);
18520:     if (!ns)
18520:         return JS_FALSE;
    1: 
71694:     JSObject &varobj = cx->fp()->varObj();
53840:     if (!varobj.defineProperty(cx, JS_DEFAULT_XML_NAMESPACE_ID, ObjectValue(*ns),
62395:                                PropertyStub, StrictPropertyStub, JSPROP_PERMANENT)) {
    1:         return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
48470: js_ToAttributeName(JSContext *cx, Value *vp)
    1: {
18520:     JSObject *qn;
    1: 
48470:     qn = ToAttributeName(cx, Jsvalify(*vp));
    1:     if (!qn)
    1:         return JS_FALSE;
48470:     vp->setObject(*qn);
    1:     return JS_TRUE;
    1: }
    1: 
60571: JSFlatString *
 9762: js_EscapeAttributeValue(JSContext *cx, JSString *str, JSBool quote)
 9762: {
60571:     StringBuffer sb(cx);
60571:     return EscapeAttributeValue(cx, sb, str, quote);
    1: }
    1: 
    1: JSString *
    1: js_AddAttributePart(JSContext *cx, JSBool isName, JSString *str, JSString *str2)
    1: {
59890:     size_t len = str->length();
59890:     const jschar *chars = str->getChars(cx);
59890:     if (!chars)
59890:         return NULL;
59890: 
59890:     size_t len2 = str2->length();
59890:     const jschar *chars2 = str2->getChars(cx);
59890:     if (!chars2)
59890:         return NULL;
59890: 
59890:     size_t newlen = (isName) ? len + 1 + len2 : len + 2 + len2 + 1;
64560:     jschar *newchars = (jschar *) cx->malloc_((newlen+1) * sizeof(jschar));
48562:     if (!newchars)
    1:         return NULL;
    1: 
48562:     js_strncpy(newchars, chars, len);
48562:     newchars += len;
    1:     if (isName) {
48562:         *newchars++ = ' ';
48562:         js_strncpy(newchars, chars2, len2);
48562:         newchars += len2;
    1:     } else {
48562:         *newchars++ = '=';
48562:         *newchars++ = '"';
48562:         js_strncpy(newchars, chars2, len2);
48562:         newchars += len2;
48562:         *newchars++ = '"';
48562:     }
48562:     *newchars = 0;
48562:     return js_NewString(cx, newchars - newlen, newlen);
    1: }
    1: 
60571: JSFlatString *
    1: js_EscapeElementValue(JSContext *cx, JSString *str)
    1: {
60571:     StringBuffer sb(cx);
60571:     return EscapeElementValue(cx, sb, str, 0);
    1: }
    1: 
    1: JSString *
48470: js_ValueToXMLString(JSContext *cx, const Value &v)
48470: {
48470:     return ToXMLString(cx, Jsvalify(v), 0);
    1: }
    1: 
    1: JSBool
48470: js_GetAnyName(JSContext *cx, jsid *idp)
    1: {
71696:     JSObject *global = cx->hasfp() ? cx->fp()->scopeChain().getGlobal() : cx->globalObject;
69237:     Value v = global->getReservedSlot(JSProto_AnyName);
61208:     if (v.isUndefined()) {
61208:         JSObject *obj = NewNonFunction<WithProto::Given>(cx, &js_AnyNameClass, NULL, global);
55674:         if (!obj)
55674:             return false;
55674: 
61208:         JS_ASSERT(!obj->getProto());
61208: 
60566:         JSRuntime *rt = cx->runtime;
72069:         if (!InitXMLQName(cx, obj, rt->emptyString, rt->emptyString, rt->atomState.starAtom))
72069:             return false;
    1: 
61208:         v.setObject(*obj);
69237:         if (!js_SetReservedSlot(cx, global, JSProto_AnyName, v))
61208:             return false;
61208:     }
61208:     *idp = OBJECT_TO_JSID(&v.toObject());
55674:     return true;
    1: }
    1: 
    1: JSBool
48470: js_FindXMLProperty(JSContext *cx, const Value &nameval, JSObject **objp, jsid *idp)
    1: {
    1:     JSObject *nameobj;
    1:     jsval v;
18520:     JSObject *qn;
    1:     jsid funid;
    1:     JSObject *obj, *target, *proto, *pobj;
    1:     JSXML *xml;
    1:     JSBool found;
    1:     JSProperty *prop;
    1: 
48470:     JS_ASSERT(nameval.isObject());
48470:     nameobj = &nameval.toObject();
40826:     if (nameobj->getClass() == &js_AnyNameClass) {
64345:         v = STRING_TO_JSVAL(cx->runtime->atomState.starAtom);
48622:         nameobj = js_ConstructObject(cx, &js_QNameClass, NULL, NULL, 1,
48470:                                      Valueify(&v));
    1:         if (!nameobj)
    1:             return JS_FALSE;
    1:     } else {
40826:         JS_ASSERT(nameobj->getClass() == &js_AttributeNameClass ||
48622:                   nameobj->getClass() == &js_QNameClass);
    1:     }
    1: 
18520:     qn = nameobj;
    1:     if (!IsFunctionQName(cx, qn, &funid))
    1:         return JS_FALSE;
    1: 
53840:     obj = &js_GetTopStackFrame(cx)->scopeChain();
    1:     do {
    1:         /* Skip any With object that can wrap XML. */
    1:         target = obj;
40826:         while (target->getClass() == &js_WithClass) {
39928:              proto = target->getProto();
    1:              if (!proto)
    1:                  break;
    1:              target = proto;
    1:         }
    1: 
42693:         if (target->isXML()) {
48470:             if (JSID_IS_VOID(funid)) {
32684:                 xml = (JSXML *) target->getPrivate();
    1:                 found = HasNamedProperty(xml, qn);
    1:             } else {
    1:                 if (!HasFunctionProperty(cx, target, funid, &found))
    1:                     return JS_FALSE;
    1:             }
    1:             if (found) {
    1:                 *idp = OBJECT_TO_JSID(nameobj);
    1:                 *objp = target;
    1:                 return JS_TRUE;
    1:             }
48470:         } else if (!JSID_IS_VOID(funid)) {
31501:             if (!target->lookupProperty(cx, funid, &pobj, &prop))
    1:                 return JS_FALSE;
    1:             if (prop) {
    1:                 *idp = funid;
    1:                 *objp = target;
    1:                 return JS_TRUE;
    1:             }
    1:         }
39930:     } while ((obj = obj->getParent()) != NULL);
    1: 
57812:     JSAutoByteString printable;
60566:     JSString *str = ConvertQNameToString(cx, nameobj);
60566:     if (str && js_ValueToPrintable(cx, StringValue(str), &printable)) {
57812:         JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR, js_GetErrorMessage, NULL,
57812:                                      JSMSG_UNDEFINED_XML_NAME, printable.ptr());
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
26187: static JSBool
26187: GetXMLFunction(JSContext *cx, JSObject *obj, jsid id, jsval *vp)
    1: {
42693:     JS_ASSERT(obj->isXML());
   99: 
   99:     /*
   99:      * See comments before xml_lookupProperty about the need for the proto
   99:      * chain lookup.
   99:      */
40395:     JSObject *target = obj;
40395:     AutoObjectRooter tvr(cx);
   99:     for (;;) {
48470:         if (!js_GetProperty(cx, target, id, Valueify(vp)))
40395:             return false;
40395:         if (VALUE_IS_FUNCTION(cx, *vp))
40395:             return true;
39928:         target = target->getProto();
59241:         if (target == NULL || !target->isNative())
   99:             break;
40395:         tvr.setObject(target);
40395:     }
40395: 
40395:     JSXML *xml = (JSXML *) obj->getPrivate();
40395:     if (!HasSimpleContent(xml))
40395:         return true;
40395: 
   99:     /* Search in String.prototype to implement 11.2.2.1 Step 3(f). */
40395:     if (!js_GetClassPrototype(cx, NULL, JSProto_String, tvr.addr()))
40395:         return false;
40395: 
40395:     JS_ASSERT(tvr.object());
48470:     return tvr.object()->getProperty(cx, id, Valueify(vp));
    1: }
    1: 
    1: static JSXML *
    1: GetPrivate(JSContext *cx, JSObject *obj, const char *method)
    1: {
67943:     if (!obj->isXML()) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_INCOMPATIBLE_METHOD,
40826:                              js_XML_str, method, obj->getClass()->name);
67944:         return NULL;
    1:     }
67943:     return (JSXML *)obj->getPrivate();
    1: }
    1: 
    1: JSBool
    1: js_GetXMLDescendants(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:     JSXML *xml, *list;
    1: 
    1:     xml = GetPrivate(cx, obj, "descendants internal method");
    1:     if (!xml)
    1:         return JS_FALSE;
    1: 
    1:     list = Descendants(cx, xml, id);
    1:     if (!list)
    1:         return JS_FALSE;
    1:     *vp = OBJECT_TO_JSVAL(list->object);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: js_DeleteXMLListElements(JSContext *cx, JSObject *listobj)
    1: {
    1:     JSXML *list;
    1:     uint32 n;
    1: 
32684:     list = (JSXML *) listobj->getPrivate();
    1:     for (n = list->xml_kids.length; n != 0; --n)
    1:         DeleteListElement(cx, list, 0);
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
31884: struct JSXMLFilter
31884: {
11672:     JSXML               *list;
11672:     JSXML               *result;
11672:     JSXML               *kid;
11672:     JSXMLArrayCursor    cursor;
11672: 
31884:     JSXMLFilter(JSXML *list, JSXMLArray *array)
31884:       : list(list), result(NULL), kid(NULL), cursor(array) {}
31884: 
31884:     ~JSXMLFilter() {}
31884: };
11672: 
11672: static void
11672: xmlfilter_trace(JSTracer *trc, JSObject *obj)
11672: {
31452:     JSXMLFilter *filter = (JSXMLFilter *) obj->getPrivate();
11672:     if (!filter)
11672:         return;
11672: 
11672:     JS_ASSERT(filter->list);
11672:     JS_CALL_TRACER(trc, filter->list, JSTRACE_XML, "list");
11672:     if (filter->result)
11672:         JS_CALL_TRACER(trc, filter->result, JSTRACE_XML, "result");
11672:     if (filter->kid)
11672:         JS_CALL_TRACER(trc, filter->kid, JSTRACE_XML, "kid");
11672: 
11672:     /*
11672:      * We do not need to trace the cursor as that would be done when
11672:      * tracing the filter->list.
11672:      */
11672: }
11672: 
11672: static void
11672: xmlfilter_finalize(JSContext *cx, JSObject *obj)
11672: {
31452:     JSXMLFilter *filter = (JSXMLFilter *) obj->getPrivate();
11672:     if (!filter)
11672:         return;
11672: 
64559:     cx->delete_(filter);
11672: }
11672: 
48470: Class js_XMLFilterClass = {
11672:     "XMLFilter",
64218:     JSCLASS_HAS_PRIVATE | JSCLASS_IS_ANONYMOUS,
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub,
48622:     xmlfilter_finalize,
48622:     NULL,                 /* reserved0   */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
48622:     NULL,                 /* construct   */
48622:     NULL,                 /* xdrObject   */
48622:     NULL,                 /* hasInstance */
64218:     xmlfilter_trace
11672: };
11672: 
    1: JSBool
11672: js_StepXMLListFilter(JSContext *cx, JSBool initialized)
11672: {
11672:     jsval *sp;
11672:     JSObject *obj, *filterobj, *resobj, *kidobj;
11672:     JSXML *xml, *list;
11672:     JSXMLFilter *filter;
11672: 
42717:     LeaveTrace(cx);
69223:     sp = Jsvalify(cx->regs().sp);
11672:     if (!initialized) {
11672:         /*
11672:          * We haven't iterated yet, so initialize the filter based on the
11672:          * value stored in sp[-2].
11672:          */
42693:         if (!VALUE_IS_XML(sp[-2])) {
48470:             js_ReportValueError(cx, JSMSG_NON_XML_FILTER, -2, Valueify(sp[-2]), NULL);
11672:             return JS_FALSE;
11672:         }
11672:         obj = JSVAL_TO_OBJECT(sp[-2]);
32684:         xml = (JSXML *) obj->getPrivate();
    1: 
    1:         if (xml->xml_class == JSXML_CLASS_LIST) {
    1:             list = xml;
    1:         } else {
11672:             obj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
11672:             if (!obj)
11672:                 return JS_FALSE;
11672: 
11672:             /*
11672:              * Root just-created obj. sp[-2] cannot be used yet for rooting
11672:              * as it may be the only root holding xml.
11672:              */
11672:             sp[-1] = OBJECT_TO_JSVAL(obj);
32684:             list = (JSXML *) obj->getPrivate();
11672:             if (!Append(cx, list, xml))
11672:                 return JS_FALSE;
11672:         }
11672: 
73984:         JSObject *parent = GetGlobalForScopeChain(cx);
73984:         filterobj = NewNonFunction<WithProto::Given>(cx, &js_XMLFilterClass, NULL, parent);
11672:         if (!filterobj)
11672:             return JS_FALSE;
11672: 
11672:         /*
31452:          * Init all filter fields before setPrivate exposes it to
11672:          * xmlfilter_trace or xmlfilter_finalize.
11672:          */
64559:         filter = cx->new_<JSXMLFilter>(list, &list->xml_kids);
31884:         if (!filter)
31884:             return JS_FALSE;
31452:         filterobj->setPrivate(filter);
11672: 
11672:         /* Store filterobj to use in the later iterations. */
11672:         sp[-2] = OBJECT_TO_JSVAL(filterobj);
    1: 
    1:         resobj = js_NewXMLObject(cx, JSXML_CLASS_LIST);
    1:         if (!resobj)
11672:             return JS_FALSE;
11672: 
11672:         /* This also roots resobj. */
32684:         filter->result = (JSXML *) resobj->getPrivate();
11672:     } else {
11672:         /* We have iterated at least once. */
11672:         JS_ASSERT(!JSVAL_IS_PRIMITIVE(sp[-2]));
40826:         JS_ASSERT(JSVAL_TO_OBJECT(sp[-2])->getClass() == &js_XMLFilterClass);
32684:         filter = (JSXMLFilter *) JSVAL_TO_OBJECT(sp[-2])->getPrivate();
11672:         JS_ASSERT(filter->kid);
11672: 
11672:         /* Check if the filter expression wants to append the element. */
48470:         if (js_ValueToBoolean(Valueify(sp[-1])) &&
11672:             !Append(cx, filter->result, filter->kid)) {
11672:             return JS_FALSE;
11672:         }
11672:     }
11672: 
11672:     /* Do the iteration. */
31884:     filter->kid = (JSXML *) filter->cursor.getNext();
11672:     if (!filter->kid) {
11672:         /*
11672:          * Do not defer finishing the cursor until the next GC cycle to avoid
11672:          * accumulation of dead cursors associated with filter->list.
11672:          */
31884:         filter->cursor.disconnect();
11672:         JS_ASSERT(filter->result->object);
11672:         sp[-2] = OBJECT_TO_JSVAL(filter->result->object);
11672:         kidobj = NULL;
11672:     } else {
11672:         kidobj = js_GetXMLObject(cx, filter->kid);
    1:         if (!kidobj)
11672:             return JS_FALSE;
11672:     }
11672: 
11672:     /* Null as kidobj at sp[-1] signals filter termination. */
11672:     sp[-1] = OBJECT_TO_JSVAL(kidobj);
11672:     return JS_TRUE;
    1: }
    1: 
    1: JSObject *
48470: js_ValueToXMLObject(JSContext *cx, const Value &v)
48470: {
48470:     return ToXML(cx, Jsvalify(v));
    1: }
    1: 
    1: JSObject *
48470: js_ValueToXMLListObject(JSContext *cx, const Value &v)
48470: {
48470:     return ToXMLList(cx, Jsvalify(v));
    1: }
    1: 
    1: JSObject *
    1: js_NewXMLSpecialObject(JSContext *cx, JSXMLClass xml_class, JSString *name,
    1:                        JSString *value)
    1: {
    1:     uintN flags;
    1:     JSObject *obj;
    1:     JSXML *xml;
18520:     JSObject *qn;
    1: 
    1:     if (!GetXMLSettingFlags(cx, &flags))
    1:         return NULL;
    1: 
    1:     if ((xml_class == JSXML_CLASS_COMMENT &&
    1:          (flags & XSF_IGNORE_COMMENTS)) ||
    1:         (xml_class == JSXML_CLASS_PROCESSING_INSTRUCTION &&
    1:          (flags & XSF_IGNORE_PROCESSING_INSTRUCTIONS))) {
    1:         return js_NewXMLObject(cx, JSXML_CLASS_TEXT);
    1:     }
    1: 
    1:     obj = js_NewXMLObject(cx, xml_class);
    1:     if (!obj)
    1:         return NULL;
32684:     xml = (JSXML *) obj->getPrivate();
    1:     if (name) {
59890:         JSLinearString *linearName = name->ensureLinear(cx);
59890:         if (!linearName)
59890:             return NULL;
59890:         qn = NewXMLQName(cx, cx->runtime->emptyString, NULL, linearName);
    1:         if (!qn)
    1:             return NULL;
    1:         xml->name = qn;
    1:     }
    1:     xml->xml_value = value;
    1:     return obj;
    1: }
    1: 
    1: JSString *
    1: js_MakeXMLCDATAString(JSContext *cx, JSString *str)
    1: {
60571:     StringBuffer sb(cx);
60571:     return MakeXMLCDATAString(cx, sb, str);
    1: }
    1: 
    1: JSString *
    1: js_MakeXMLCommentString(JSContext *cx, JSString *str)
    1: {
60571:     StringBuffer sb(cx);
60571:     return MakeXMLCommentString(cx, sb, str);
    1: }
    1: 
    1: JSString *
    1: js_MakeXMLPIString(JSContext *cx, JSString *name, JSString *str)
    1: {
60571:     StringBuffer sb(cx);
60571:     return MakeXMLPIString(cx, sb, name, str);
    1: }
    1: 
    1: #endif /* JS_HAS_XML_SUPPORT */
