27440: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
27440:  * vim: sw=2 ts=2 et lcs=trail\:.,tab\:>~ :
 2327:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Oracle Corporation code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  *  Oracle Corporation
    1:  * Portions created by the Initial Developer are Copyright (C) 2004
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Vladimir Vukicevic <vladimir.vukicevic@oracle.com>
    1:  *   Brett Wilson <brettw@gmail.com>
 2327:  *   Shawn Wilsher <me@shawnwilsher.com>
 3228:  *   Lev Serebryakov <lev@serebryakov.spb.ru>
30359:  *   Drew Willcoxon <adw@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include <stdio.h>
    1: 
    1: #include "nsError.h"
    1: #include "nsIMutableArray.h"
 3228: #include "nsAutoPtr.h"
64470: #include "nsIMemoryReporter.h"
21035: #include "nsThreadUtils.h"
77864: #include "nsILocalFile.h"
84105: #include "mozilla/Telemetry.h"
84105: #include "mozilla/Mutex.h"
84105: #include "mozilla/CondVar.h"
    1: 
 3228: #include "mozIStorageAggregateFunction.h"
39287: #include "mozIStorageCompletionCallback.h"
    1: #include "mozIStorageFunction.h"
    1: 
27569: #include "mozStorageAsyncStatementExecution.h"
27529: #include "mozStorageSQLFunctions.h"
    1: #include "mozStorageConnection.h"
    1: #include "mozStorageService.h"
    1: #include "mozStorageStatement.h"
39769: #include "mozStorageAsyncStatement.h"
27530: #include "mozStorageArgValueArray.h"
21128: #include "mozStoragePrivateHelpers.h"
29548: #include "mozStorageStatementData.h"
39769: #include "StorageBaseStatementInternal.h"
30359: #include "SQLCollations.h"
84685: #include "FileSystemModule.h"
86727: #include "mozStorageHelper.h"
87692: #include "sampler.h"
    1: 
    1: #include "prlog.h"
    1: #include "prprf.h"
    1: 
77864: #define MIN_AVAILABLE_BYTES_PER_CHUNKED_GROWTH 524288000 // 500 MiB
77864: 
82059: // Maximum size of the pages cache per connection.  If the default cache_size
82059: // value evaluates to a larger size, it will be reduced to save memory.
82059: #define MAX_CACHE_SIZE_BYTES 4194304 // 4 MiB
82059: 
82059: // Default maximum number of pages to allow in the connection pages cache.
82059: #define DEFAULT_CACHE_SIZE_PAGES 2000
82059: 
    1: #ifdef PR_LOGGING
    1: PRLogModuleInfo* gStorageLog = nsnull;
    1: #endif
    1: 
27440: namespace mozilla {
27440: namespace storage {
27440: 
60703: namespace {
60703: 
27440: ////////////////////////////////////////////////////////////////////////////////
38397: //// Variant Specialization Functions (variantToSQLiteT)
28145: 
60703: int
28145: sqlite3_T_int(sqlite3_context *aCtx,
28145:               int aValue)
28145: {
28145:   ::sqlite3_result_int(aCtx, aValue);
28145:   return SQLITE_OK;
28145: }
28145: 
60703: int
28145: sqlite3_T_int64(sqlite3_context *aCtx,
28145:                 sqlite3_int64 aValue)
28145: {
28145:   ::sqlite3_result_int64(aCtx, aValue);
28145:   return SQLITE_OK;
28145: }
28145: 
60703: int
28145: sqlite3_T_double(sqlite3_context *aCtx,
28145:                  double aValue)
28145: {
28145:   ::sqlite3_result_double(aCtx, aValue);
28145:   return SQLITE_OK;
28145: }
28145: 
60703: int
38397: sqlite3_T_text(sqlite3_context *aCtx,
38397:                const nsCString &aValue)
38397: {
38397:   ::sqlite3_result_text(aCtx,
38397:                         aValue.get(),
38397:                         aValue.Length(),
38397:                         SQLITE_TRANSIENT);
38397:   return SQLITE_OK;
38397: }
38397: 
60703: int
28145: sqlite3_T_text16(sqlite3_context *aCtx,
38397:                  const nsString &aValue)
28145: {
28145:   ::sqlite3_result_text16(aCtx,
38397:                           aValue.get(),
28145:                           aValue.Length() * 2, // Number of bytes.
28145:                           SQLITE_TRANSIENT);
28145:   return SQLITE_OK;
28145: }
28145: 
60703: int
28145: sqlite3_T_null(sqlite3_context *aCtx)
28145: {
28145:   ::sqlite3_result_null(aCtx);
28145:   return SQLITE_OK;
28145: }
28145: 
60703: int
28146: sqlite3_T_blob(sqlite3_context *aCtx,
28146:                const void *aData,
28146:                int aSize)
28146: {
28146:   ::sqlite3_result_blob(aCtx, aData, aSize, NS_Free);
28146:   return SQLITE_OK;
28146: }
28146: 
38397: #include "variantToSQLiteT_impl.h"
38397: 
28145: ////////////////////////////////////////////////////////////////////////////////
84685: //// Modules
84685: 
84685: struct Module
84685: {
84685:   const char* name;
84685:   int (*registerFunc)(sqlite3*, const char*);
84685: };
84685: 
84685: Module gModules[] = {
84685:   { "filesystem", RegisterFileSystemModule }
84685: };
84685: 
84685: ////////////////////////////////////////////////////////////////////////////////
29812: //// Local Functions
29812: 
29812: #ifdef PR_LOGGING
29812: void tracefunc (void *aClosure, const char *aStmt)
29812: {
29812:   PR_LOG(gStorageLog, PR_LOG_DEBUG, ("sqlite3_trace on %p for '%s'", aClosure,
29812:                                      aStmt));
29812: }
29812: #endif
29812: 
29812: struct FFEArguments
29812: {
29812:     nsISupports *target;
29812:     bool found;
29812: };
29812: PLDHashOperator
29812: findFunctionEnumerator(const nsACString &aKey,
51598:                        Connection::FunctionInfo aData,
29812:                        void *aUserArg)
29812: {
29812:   FFEArguments *args = static_cast<FFEArguments *>(aUserArg);
51598:   if (aData.function == args->target) {
51598:     args->found = true;
29812:     return PL_DHASH_STOP;
29812:   }
29812:   return PL_DHASH_NEXT;
29812: }
29812: 
51598: PLDHashOperator
51598: copyFunctionEnumerator(const nsACString &aKey,
51598:                        Connection::FunctionInfo aData,
51598:                        void *aUserArg)
51598: {
51598:   NS_PRECONDITION(aData.type == Connection::FunctionInfo::SIMPLE ||
51598:                   aData.type == Connection::FunctionInfo::AGGREGATE,
51598:                   "Invalid function type!");
51598: 
51598:   Connection *connection = static_cast<Connection *>(aUserArg);
51598:   if (aData.type == Connection::FunctionInfo::SIMPLE) {
51598:     mozIStorageFunction *function =
51598:       static_cast<mozIStorageFunction *>(aData.function.get());
51598:     (void)connection->CreateFunction(aKey, aData.numArgs, function);
51598:   }
51598:   else {
51598:     mozIStorageAggregateFunction *function =
51598:       static_cast<mozIStorageAggregateFunction *>(aData.function.get());
51598:     (void)connection->CreateAggregateFunction(aKey, aData.numArgs, function);
51598:   }
51598: 
51598:   return PL_DHASH_NEXT;
51598: }
51598: 
29812: void
29812: basicFunctionHelper(sqlite3_context *aCtx,
29812:                     int aArgc,
29812:                     sqlite3_value **aArgv)
29812: {
29812:   void *userData = ::sqlite3_user_data(aCtx);
29812: 
29812:   mozIStorageFunction *func = static_cast<mozIStorageFunction *>(userData);
29812: 
29812:   nsRefPtr<ArgValueArray> arguments(new ArgValueArray(aArgc, aArgv));
29812:   if (!arguments)
29812:       return;
29812: 
29812:   nsCOMPtr<nsIVariant> result;
29812:   if (NS_FAILED(func->OnFunctionCall(arguments, getter_AddRefs(result)))) {
29812:     NS_WARNING("User function returned error code!");
29812:     ::sqlite3_result_error(aCtx,
29812:                            "User function returned error code",
29812:                            -1);
29812:     return;
29812:   }
29812:   if (variantToSQLiteT(aCtx, result) != SQLITE_OK) {
29812:     NS_WARNING("User function returned invalid data type!");
29812:     ::sqlite3_result_error(aCtx,
29812:                            "User function returned invalid data type",
29812:                            -1);
29812:   }
29812: }
29812: 
29812: void
29812: aggregateFunctionStepHelper(sqlite3_context *aCtx,
29812:                             int aArgc,
29812:                             sqlite3_value **aArgv)
29812: {
29812:   void *userData = ::sqlite3_user_data(aCtx);
29812:   mozIStorageAggregateFunction *func =
29812:     static_cast<mozIStorageAggregateFunction *>(userData);
29812: 
29812:   nsRefPtr<ArgValueArray> arguments(new ArgValueArray(aArgc, aArgv));
29812:   if (!arguments)
29812:     return;
29812: 
29812:   if (NS_FAILED(func->OnStep(arguments)))
29812:     NS_WARNING("User aggregate step function returned error code!");
29812: }
29812: 
29812: void
29812: aggregateFunctionFinalHelper(sqlite3_context *aCtx)
29812: {
29812:   void *userData = ::sqlite3_user_data(aCtx);
29812:   mozIStorageAggregateFunction *func =
29812:     static_cast<mozIStorageAggregateFunction *>(userData);
29812: 
29812:   nsRefPtr<nsIVariant> result;
29812:   if (NS_FAILED(func->OnFinal(getter_AddRefs(result)))) {
29812:     NS_WARNING("User aggregate final function returned error code!");
29812:     ::sqlite3_result_error(aCtx,
29812:                            "User aggregate final function returned error code",
29812:                            -1);
29812:     return;
29812:   }
29812: 
29812:   if (variantToSQLiteT(aCtx, result) != SQLITE_OK) {
29812:     NS_WARNING("User aggregate final function returned invalid data type!");
29812:     ::sqlite3_result_error(aCtx,
29812:                            "User aggregate final function returned invalid data type",
29812:                            -1);
29812:   }
29812: }
29812: 
84105: /**
84105:  * This code is heavily based on the sample at:
84105:  *   http://www.sqlite.org/unlock_notify.html
84105:  */
84105: class UnlockNotification
84105: {
84105: public:
84105:   UnlockNotification()
84105:   : mMutex("UnlockNotification mMutex")
84105:   , mCondVar(mMutex, "UnlockNotification condVar")
84105:   , mSignaled(false)
84105:   {
84105:   }
84105: 
84105:   void Wait()
84105:   {
84105:     MutexAutoLock lock(mMutex);
84105:     while (!mSignaled) {
84105:       (void)mCondVar.Wait();
84105:     }
84105:   }
84105: 
84105:   void Signal()
84105:   {
84105:     MutexAutoLock lock(mMutex);
84105:     mSignaled = true;
84105:     (void)mCondVar.Notify();
84105:   }
84105: 
84105: private:
84105:   Mutex mMutex;
84105:   CondVar mCondVar;
84105:   bool mSignaled;
84105: };
84105: 
84105: void
84105: UnlockNotifyCallback(void **aArgs,
84105:                      int aArgsSize)
84105: {
84105:   for (int i = 0; i < aArgsSize; i++) {
84105:     UnlockNotification *notification =
84105:       static_cast<UnlockNotification *>(aArgs[i]);
84105:     notification->Signal();
84105:   }
84105: }
84105: 
84105: int
84105: WaitForUnlockNotify(sqlite3* aDatabase)
84105: {
84105:   UnlockNotification notification;
84105:   int srv = ::sqlite3_unlock_notify(aDatabase, UnlockNotifyCallback,
84105:                                     &notification);
84105:   MOZ_ASSERT(srv == SQLITE_LOCKED || srv == SQLITE_OK);
84105:   if (srv == SQLITE_OK) {
84105:     notification.Wait();
84105:   }
84105: 
84105:   return srv;
84105: }
84105: 
39287: } // anonymous namespace
39287: 
39287: ////////////////////////////////////////////////////////////////////////////////
39287: //// Local Classes
39287: 
39287: namespace {
39287: 
39287: class AsyncCloseConnection : public nsRunnable
39287: {
39287: public:
39287:   AsyncCloseConnection(Connection *aConnection,
39287:                        nsIEventTarget *aCallingThread,
39287:                        nsIRunnable *aCallbackEvent)
39287:   : mConnection(aConnection)
39287:   , mCallingThread(aCallingThread)
39287:   , mCallbackEvent(aCallbackEvent)
39287:   {
39287:   }
39287: 
39287:   NS_METHOD Run()
39287:   {
39287:     // This event is first dispatched to the background thread to ensure that
39287:     // all pending asynchronous events are completed, and then back to the
39287:     // calling thread to actually close and notify.
79445:     bool onCallingThread = false;
39287:     (void)mCallingThread->IsOnCurrentThread(&onCallingThread);
39287:     if (!onCallingThread) {
39287:       (void)mCallingThread->Dispatch(this, NS_DISPATCH_NORMAL);
39287:       return NS_OK;
39287:     }
39287: 
39287:     (void)mConnection->internalClose();
39287:     if (mCallbackEvent)
39287:       (void)mCallingThread->Dispatch(mCallbackEvent, NS_DISPATCH_NORMAL);
39287: 
39986:     // Because we have no guarantee that the invocation of this method on the
39986:     // asynchronous thread has fully completed (including the Release of the
39986:     // reference to this object held by that event loop), we need to explicitly
39986:     // null out our pointers here.  It is possible this object will be destroyed
39986:     // on the asynchronous thread and if the references are still alive we will
39986:     // release them on that thread. We definitely do not want that for
39986:     // mConnection and it's nice to avoid for mCallbackEvent too.  We do not
39986:     // null out mCallingThread because it is conceivable the async thread might
39986:     // still be 'in' the object.
39986:     mConnection = nsnull;
39986:     mCallbackEvent = nsnull;
39986: 
39287:     return NS_OK;
39287:   }
39287: private:
59297:   nsRefPtr<Connection> mConnection;
39287:   nsCOMPtr<nsIEventTarget> mCallingThread;
39287:   nsCOMPtr<nsIRunnable> mCallbackEvent;
39287: };
29812: 
29812: } // anonymous namespace
29812: 
29812: ////////////////////////////////////////////////////////////////////////////////
64470: //// Memory Reporting
64470: 
64470: class StorageMemoryReporter : public nsIMemoryReporter
64470: {
64470: public:
64470:   NS_DECL_ISUPPORTS
64470: 
64470:   enum ReporterType {
64470:     Cache_Used,
64470:     Schema_Used,
64470:     Stmt_Used
64470:   };
64470: 
74897:   StorageMemoryReporter(sqlite3 *aDBConn,
74897:                         const nsCString &aFileName,
64470:                         ReporterType aType)
64470:   : mDBConn(aDBConn)
74897:   , mFileName(aFileName)
64470:   , mType(aType)
74897:   , mHasLeaked(false)
64470:   {
64470:   }
64470: 
73566:   NS_IMETHOD GetProcess(nsACString &process)
71287:   {
73566:     process.Truncate();
71287:     return NS_OK;
71287:   }
71287: 
73566:   NS_IMETHOD GetPath(nsACString &path)
64470:   {
73566:     path.AssignLiteral("explicit/storage/sqlite/");
74897:     path.Append(mFileName);
74897:     if (mHasLeaked) {
74897:       path.AppendLiteral("-LEAKED");
74897:     }
64470: 
70253:     if (mType == Cache_Used) {
69289:       path.AppendLiteral("/cache-used");
64470:     }
64470:     else if (mType == Schema_Used) {
69289:       path.AppendLiteral("/schema-used");
64470:     }
64470:     else if (mType == Stmt_Used) {
69289:       path.AppendLiteral("/stmt-used");
64470:     }
64470:     return NS_OK;
64470:   }
64470: 
70251:   NS_IMETHOD GetKind(PRInt32 *kind)
70251:   {
72640:     *kind = KIND_HEAP;
70251:     return NS_OK;
70251:   }
70251: 
72640:   NS_IMETHOD GetUnits(PRInt32 *units)
72640:   {
72640:     *units = UNITS_BYTES;
72640:     return NS_OK;
72640:   }
72640: 
72640:   NS_IMETHOD GetAmount(PRInt64 *amount)
72640:   {
72640:     int type = 0;
72640:     if (mType == Cache_Used) {
72640:       type = SQLITE_DBSTATUS_CACHE_USED;
72640:     }
72640:     else if (mType == Schema_Used) {
72640:       type = SQLITE_DBSTATUS_SCHEMA_USED;
72640:     }
72640:     else if (mType == Stmt_Used) {
72640:       type = SQLITE_DBSTATUS_STMT_USED;
72640:     }
72640: 
72640:     int cur=0, max=0;
72640:     int rc = ::sqlite3_db_status(mDBConn, type, &cur, &max, 0);
72640:     *amount = cur;
72640:     return convertResultCode(rc);
72640:   }
72640: 
73566:   NS_IMETHOD GetDescription(nsACString &desc)
64470:   {
70253:     if (mType == Cache_Used) {
74897:       desc.AssignLiteral("Memory (approximate) used by all pager caches used "
74897:                          "by connections to this database.");
64470:     }
64470:     else if (mType == Schema_Used) {
73566:       desc.AssignLiteral("Memory (approximate) used to store the schema "
74897:                          "for all databases associated with connections to "
74897:                          "this database.");
64470:     }
64470:     else if (mType == Stmt_Used) {
74897:       desc.AssignLiteral("Memory (approximate) used by all prepared statements "
74897:                          "used by connections to this database.");
64470:     }
64470:     return NS_OK;
64470:   }
64470: 
74897:   // We call this when we know we've leaked a connection.
74897:   void markAsLeaked()
74897:   {
74897:     mHasLeaked = true;
74897:   }
74897: 
74897: private:
74897:   sqlite3 *mDBConn;
64470:   nsCString mFileName;
64470:   ReporterType mType;
74897:   bool mHasLeaked;
64470: };
64470: NS_IMPL_THREADSAFE_ISUPPORTS1(
64470:   StorageMemoryReporter
64470: , nsIMemoryReporter
64470: )
64470: 
64470: ////////////////////////////////////////////////////////////////////////////////
27440: //// Connection
27440: 
51598: Connection::Connection(Service *aService,
51598:                        int aFlags)
32216: : sharedAsyncExecutionMutex("Connection::sharedAsyncExecutionMutex")
39769: , sharedDBMutex("Connection::sharedDBMutex")
35413: , threadOpenedOn(do_GetCurrentThread())
32216: , mDBConn(nsnull)
39287: , mAsyncExecutionThreadShuttingDown(false)
80486: , mTransactionInProgress(false)
16602: , mProgressHandler(nsnull)
51598: , mFlags(aFlags)
16602: , mStorageService(aService)
    1: {
 3228:   mFunctions.Init();
83472:   mStorageService->registerConnection(this);
    1: }
    1: 
27440: Connection::~Connection()
    1: {
 5459:   (void)Close();
    1: }
    1: 
83472: NS_IMPL_THREADSAFE_ADDREF(Connection)
83472: NS_IMPL_THREADSAFE_QUERY_INTERFACE2(
27440:   Connection,
59297:   mozIStorageConnection,
59297:   nsIInterfaceRequestor
27440: )
27440: 
83472: // This is identical to what NS_IMPL_THREADSAFE_RELEASE provides, but with the
83472: // extra |1 == count| case.
83472: NS_IMETHODIMP_(nsrefcnt) Connection::Release(void)
83472: {
83472:   NS_PRECONDITION(0 != mRefCnt, "dup release");
83472:   nsrefcnt count = NS_AtomicDecrementRefcnt(mRefCnt);
83472:   NS_LOG_RELEASE(this, count, "Connection");
83472:   if (1 == count) {
83472:     // If the refcount is 1, the single reference must be from
83472:     // gService->mConnections (in class |Service|).  Which means we can
83472:     // unregister it safely.
83472:     mStorageService->unregisterConnection(this);
83472:   } else if (0 == count) {
83472:     mRefCnt = 1; /* stabilize */
83472:     /* enable this to find non-threadsafe destructors: */
83472:     /* NS_ASSERT_OWNINGTHREAD(Connection); */
83472:     delete (this);
83472:     return 0;
83472:   }
83472:   return count;
83472: }
83472: 
39769: nsIEventTarget *
27440: Connection::getAsyncExecutionTarget()
    1: {
39287:   MutexAutoLock lockedScope(sharedAsyncExecutionMutex);
27440: 
27440:   // If we are shutting down the asynchronous thread, don't hand out any more
27440:   // references to the thread.
27440:   if (mAsyncExecutionThreadShuttingDown)
27440:     return nsnull;
27440: 
27440:   if (!mAsyncExecutionThread) {
27440:     nsresult rv = ::NS_NewThread(getter_AddRefs(mAsyncExecutionThread));
27440:     if (NS_FAILED(rv)) {
27440:       NS_WARNING("Failed to create async thread.");
27440:       return nsnull;
    1:     }
27440:   }
    1: 
39769:   return mAsyncExecutionThread;
27440: }
27440: 
27440: nsresult
51972: Connection::initialize(nsIFile *aDatabaseFile,
51972:                        const char* aVFSName)
    1: {
    1:   NS_ASSERTION (!mDBConn, "Initialize called on already opened database!");
87692:   SAMPLE_LABEL("storage", "Connection::initialize");
    1: 
    1:   int srv;
    1:   nsresult rv;
    1: 
    1:   mDatabaseFile = aDatabaseFile;
    1: 
    1:   if (aDatabaseFile) {
    1:     nsAutoString path;
    1:     rv = aDatabaseFile->GetPath(path);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
51598:     srv = ::sqlite3_open_v2(NS_ConvertUTF16toUTF8(path).get(), &mDBConn, mFlags,
51972:                             aVFSName);
27440:   }
27440:   else {
    1:     // in memory database requested, sqlite uses a magic file name
51972:     srv = ::sqlite3_open_v2(":memory:", &mDBConn, mFlags, aVFSName);
    1:   }
    1:   if (srv != SQLITE_OK) {
    1:     mDBConn = nsnull;
28140:     return convertResultCode(srv);
    1:   }
    1: 
36744:   // Properly wrap the database handle's mutex.
39769:   sharedDBMutex.initWithMutex(sqlite3_db_mutex(mDBConn));
36744: 
    1: #ifdef PR_LOGGING
    1:   if (!gStorageLog)
27440:     gStorageLog = ::PR_NewLogModule("mozStorage");
    1: 
27440:   ::sqlite3_trace(mDBConn, tracefunc, this);
15800: 
15800:   nsCAutoString leafName(":memory");
15800:   if (aDatabaseFile)
15800:     (void)aDatabaseFile->GetNativeLeafName(leafName);
15800:   PR_LOG(gStorageLog, PR_LOG_NOTICE, ("Opening connection to '%s' (%p)",
15800:                                       leafName.get(), this));
    1: #endif
82059: 
82059:   // Set page_size to the preferred default value.  This is effective only if
82059:   // the database has just been created, otherwise, if the database does not
82059:   // use WAL journal mode, a VACUUM operation will updated its page_size.
82059:   PRInt64 pageSize = DEFAULT_PAGE_SIZE;
86727:   nsCAutoString pageSizeQuery(MOZ_STORAGE_UNIQUIFY_QUERY_STR
86727:                               "PRAGMA page_size = ");
82059:   pageSizeQuery.AppendInt(pageSize);
82059:   rv = ExecuteSimpleSQL(pageSizeQuery);
82059:   NS_ENSURE_SUCCESS(rv, rv);
82059: 
82059:   // Get the current page_size, since it may differ from the specified value.
46994:   sqlite3_stmt *stmt;
86727:   NS_NAMED_LITERAL_CSTRING(pragma_page_size,
86727:                            MOZ_STORAGE_UNIQUIFY_QUERY_STR "PRAGMA page_size");
86727:   srv = prepareStatement(pragma_page_size, &stmt);
46994:   if (srv == SQLITE_OK) {
84105:     if (SQLITE_ROW == stepStatement(stmt)) {
82696:       pageSize = ::sqlite3_column_int64(stmt, 0);
82059:     }
46994:     (void)::sqlite3_finalize(stmt);
46994:   }
    1: 
82059:   // Setting the cache_size forces the database open, verifying if it is valid
82059:   // or corrupt.  So this is executed regardless it being actually needed.
82059:   // The cache_size is calculated from the actual page_size, to save memory.
86727:   nsCAutoString cacheSizeQuery(MOZ_STORAGE_UNIQUIFY_QUERY_STR
86727:                                "PRAGMA cache_size = ");
82059:   cacheSizeQuery.AppendInt(NS_MIN(DEFAULT_CACHE_SIZE_PAGES,
82059:                                   PRInt32(MAX_CACHE_SIZE_BYTES / pageSize)));
82059:   srv = ::sqlite3_exec(mDBConn, cacheSizeQuery.get(), NULL, NULL, NULL);
82059:   if (srv != SQLITE_OK) {
82059:     ::sqlite3_close(mDBConn);
82059:     mDBConn = nsnull;
82059:     return convertResultCode(srv);
82059:   }
82059: 
27529:   // Register our built-in SQL functions.
30359:   srv = registerFunctions(mDBConn);
30359:   if (srv != SQLITE_OK) {
30359:     ::sqlite3_close(mDBConn);
30359:     mDBConn = nsnull;
30359:     return convertResultCode(srv);
30359:   }
30359: 
30359:   // Register our built-in SQL collating sequences.
30359:   srv = registerCollations(mDBConn, mStorageService);
30359:   if (srv != SQLITE_OK) {
30359:     ::sqlite3_close(mDBConn);
 4458:     mDBConn = nsnull;
28140:     return convertResultCode(srv);
 4458:   }
 4458: 
61963:   // Set the synchronous PRAGMA, according to the preference.
61963:   switch (Service::getSynchronousPref()) {
15158:     case 2:
15158:       (void)ExecuteSimpleSQL(NS_LITERAL_CSTRING(
15158:           "PRAGMA synchronous = FULL;"));
15158:       break;
15158:     case 0:
15158:       (void)ExecuteSimpleSQL(NS_LITERAL_CSTRING(
15158:           "PRAGMA synchronous = OFF;"));
15158:       break;
15158:     case 1:
15158:     default:
15158:       (void)ExecuteSimpleSQL(NS_LITERAL_CSTRING(
15158:           "PRAGMA synchronous = NORMAL;"));
15158:       break;
15158:   }
15158: 
    1:   return NS_OK;
    1: }
    1: 
27440: nsresult
27440: Connection::databaseElementExists(enum DatabaseElementType aElementType,
27440:                                   const nsACString &aElementName,
79445:                                   bool *_exists)
27440: {
27440:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
    1: 
27440:   nsCAutoString query("SELECT name FROM sqlite_master WHERE type = '");
27440:   switch (aElementType) {
27440:     case INDEX:
27440:       query.Append("index");
27440:       break;
27440:     case TABLE:
27440:       query.Append("table");
27440:       break;
27440:   }
27440:   query.Append("' AND name ='");
27440:   query.Append(aElementName);
27440:   query.Append("'");
27440: 
27440:   sqlite3_stmt *stmt;
84105:   int srv = prepareStatement(query, &stmt);
27440:   if (srv != SQLITE_OK)
28140:     return convertResultCode(srv);
27440: 
84105:   srv = stepStatement(stmt);
27440:   // we just care about the return value from step
27440:   (void)::sqlite3_finalize(stmt);
27440: 
27440:   if (srv == SQLITE_ROW) {
80486:     *_exists = true;
27440:     return NS_OK;
27440:   }
27440:   if (srv == SQLITE_DONE) {
80486:     *_exists = false;
27440:     return NS_OK;
27440:   }
27440: 
28140:   return convertResultCode(srv);
27440: }
27440: 
27440: bool
27440: Connection::findFunctionByInstance(nsISupports *aInstance)
27440: {
39769:   sharedDBMutex.assertCurrentThreadOwns();
27440:   FFEArguments args = { aInstance, false };
51598:   (void)mFunctions.EnumerateRead(findFunctionEnumerator, &args);
27440:   return args.found;
27440: }
27440: 
27440: /* static */ int
27440: Connection::sProgressHelper(void *aArg)
27440: {
27440:   Connection *_this = static_cast<Connection *>(aArg);
27440:   return _this->progressHandler();
27440: }
27440: 
27440: int
27440: Connection::progressHandler()
27440: {
39769:   sharedDBMutex.assertCurrentThreadOwns();
27440:   if (mProgressHandler) {
79445:     bool result;
27440:     nsresult rv = mProgressHandler->OnProgress(this, &result);
27440:     if (NS_FAILED(rv)) return 0; // Don't break request
27440:     return result ? 1 : 0;
27440:   }
27440:   return 0;
27440: }
27440: 
39287: nsresult
39287: Connection::setClosedState()
39287: {
39287:   // Ensure that we are on the correct thread to close the database.
79445:   bool onOpenedThread;
39287:   nsresult rv = threadOpenedOn->IsOnCurrentThread(&onOpenedThread);
39287:   NS_ENSURE_SUCCESS(rv, rv);
39287:   if (!onOpenedThread) {
39287:     NS_ERROR("Must close the database on the thread that you opened it with!");
39287:     return NS_ERROR_UNEXPECTED;
39287:   }
35407: 
39287:   // Flag that we are shutting down the async thread, so that
39287:   // getAsyncExecutionTarget knows not to expose/create the async thread.
35397:   {
39287:     MutexAutoLock lockedScope(sharedAsyncExecutionMutex);
39287:     NS_ENSURE_FALSE(mAsyncExecutionThreadShuttingDown, NS_ERROR_UNEXPECTED);
39287:     mAsyncExecutionThreadShuttingDown = true;
39287:   }
39287: 
39287:   return NS_OK;
39287: }
39287: 
39287: nsresult
39287: Connection::internalClose()
39287: {
39287: #ifdef DEBUG
39287:   // Sanity checks to make sure we are in the proper state before calling this.
39287:   NS_ASSERTION(mDBConn, "Database connection is already null!");
39287: 
39287:   { // Make sure we have marked our async thread as shutting down.
39287:     MutexAutoLock lockedScope(sharedAsyncExecutionMutex);
39287:     NS_ASSERTION(mAsyncExecutionThreadShuttingDown,
39287:                  "Did not call setClosedState!");
39287:   }
39287: 
39287:   { // Ensure that we are being called on the thread we were opened with.
79445:     bool onOpenedThread = false;
39287:     (void)threadOpenedOn->IsOnCurrentThread(&onOpenedThread);
39287:     NS_ASSERTION(onOpenedThread,
39287:                  "Not called on the thread the database was opened on!");
39287:   }
39287: #endif
 5459: 
15800: #ifdef PR_LOGGING
15800:   nsCAutoString leafName(":memory");
15800:   if (mDatabaseFile)
15800:       (void)mDatabaseFile->GetNativeLeafName(leafName);
34594:   PR_LOG(gStorageLog, PR_LOG_NOTICE, ("Closing connection to '%s'",
15800:                                       leafName.get()));
15800: #endif
15800: 
22519: #ifdef DEBUG
22519:   // Notify about any non-finalized statements.
22519:   sqlite3_stmt *stmt = NULL;
27440:   while ((stmt = ::sqlite3_next_stmt(mDBConn, stmt))) {
27440:     char *msg = ::PR_smprintf("SQL statement '%s' was not finalized",
27440:                               ::sqlite3_sql(stmt));
25405:     NS_WARNING(msg);
27440:     ::PR_smprintf_free(msg);
22519:   }
22519: #endif
22519: 
27440:   int srv = ::sqlite3_close(mDBConn);
29611:   NS_ASSERTION(srv == SQLITE_OK,
29611:                "sqlite3_close failed. There are probably outstanding statements that are listed above!");
35407: 
35397:   mDBConn = NULL;
28140:   return convertResultCode(srv);
 5459: }
 5459: 
42480: nsCString
42480: Connection::getFilename()
42480: {
42898:   nsCString leafname(":memory:");
42898:   if (mDatabaseFile) {
42480:     (void)mDatabaseFile->GetNativeLeafName(leafname);
42898:   }
42480:   return leafname;
42480: }
42480: 
84105: int
84105: Connection::stepStatement(sqlite3_stmt *aStatement)
84105: {
84105:   bool checkedMainThread = false;
84105:   TimeStamp startTime = TimeStamp::Now();
84105: 
91355:   // mDBConn may be null if the executing statement has been created and cached
91355:   // after a call to asyncClose() but before the connection has been nullified
91355:   // by internalClose().  In such a case closing the connection fails due to
91355:   // the existence of prepared statements, but mDBConn is set to null
91355:   // regardless. This usually happens when other tasks using cached statements
91355:   // are asynchronously scheduled for execution and any of them ends up after
91355:   // asyncClose. See bug 728653 for details.
91355:   if (!mDBConn)
91355:     return SQLITE_MISUSE;
91355: 
84105:   (void)::sqlite3_extended_result_codes(mDBConn, 1);
84105: 
84105:   int srv;
84105:   while ((srv = ::sqlite3_step(aStatement)) == SQLITE_LOCKED_SHAREDCACHE) {
84105:     if (!checkedMainThread) {
84105:       checkedMainThread = true;
84105:       if (::NS_IsMainThread()) {
84105:         NS_WARNING("We won't allow blocking on the main thread!");
84105:         break;
84105:       }
84105:     }
84105: 
84105:     srv = WaitForUnlockNotify(mDBConn);
84105:     if (srv != SQLITE_OK) {
84105:       break;
84105:     }
84105: 
84105:     ::sqlite3_reset(aStatement);
84105:   }
84105: 
84105:   // Report very slow SQL statements to Telemetry
84105:   TimeDuration duration = TimeStamp::Now() - startTime;
84105:   if (duration.ToMilliseconds() >= Telemetry::kSlowStatementThreshold) {
84105:     nsDependentCString statementString(::sqlite3_sql(aStatement));
84105:     Telemetry::RecordSlowSQLStatement(statementString, getFilename(),
84105:                                       duration.ToMilliseconds());
84105:   }
84105: 
84105:   (void)::sqlite3_extended_result_codes(mDBConn, 0);
84105:   // Drop off the extended result bits of the result code.
84105:   return srv & 0xFF;
84105: }
84105: 
84105: int
84105: Connection::prepareStatement(const nsCString &aSQL,
84105:                              sqlite3_stmt **_stmt)
84105: {
84105:   bool checkedMainThread = false;
84105: 
84105:   (void)::sqlite3_extended_result_codes(mDBConn, 1);
84105: 
84105:   int srv;
84105:   while((srv = ::sqlite3_prepare_v2(mDBConn, aSQL.get(), -1, _stmt, NULL)) ==
84105:         SQLITE_LOCKED_SHAREDCACHE) {
84105:     if (!checkedMainThread) {
84105:       checkedMainThread = true;
84105:       if (::NS_IsMainThread()) {
84105:         NS_WARNING("We won't allow blocking on the main thread!");
84105:         break;
84105:       }
84105:     }
84105: 
84105:     srv = WaitForUnlockNotify(mDBConn);
84105:     if (srv != SQLITE_OK) {
84105:       break;
84105:     }
84105:   }
84105: 
84105:   if (srv != SQLITE_OK) {
84105:     nsCString warnMsg;
84105:     warnMsg.AppendLiteral("The SQL statement '");
84105:     warnMsg.Append(aSQL);
84105:     warnMsg.AppendLiteral("' could not be compiled due to an error: ");
84105:     warnMsg.Append(::sqlite3_errmsg(mDBConn));
84105: 
84105: #ifdef DEBUG
84105:     NS_WARNING(warnMsg.get());
84105: #endif
84105: #ifdef PR_LOGGING
84105:     PR_LOG(gStorageLog, PR_LOG_ERROR, ("%s", warnMsg.get()));
84105: #endif
84105:   }
84105: 
84105:   (void)::sqlite3_extended_result_codes(mDBConn, 0);
84105:   // Drop off the extended result bits of the result code.
84105:   return srv & 0xFF;
84105: }
84105: 
39287: ////////////////////////////////////////////////////////////////////////////////
59297: //// nsIInterfaceRequestor
59297: 
59297: NS_IMETHODIMP
59297: Connection::GetInterface(const nsIID &aIID,
59297:                          void **_result)
59297: {
59297:   if (aIID.Equals(NS_GET_IID(nsIEventTarget))) {
59297:     nsIEventTarget *background = getAsyncExecutionTarget();
59297:     NS_IF_ADDREF(background);
59297:     *_result = background;
59297:     return NS_OK;
59297:   }
59297:   return NS_ERROR_NO_INTERFACE;
59297: }
59297: 
59297: ////////////////////////////////////////////////////////////////////////////////
39287: //// mozIStorageConnection
39287: 
39287: NS_IMETHODIMP
39287: Connection::Close()
39287: {
39287:   if (!mDBConn)
39287:     return NS_ERROR_NOT_INITIALIZED;
39287: 
39287:   { // Make sure we have not executed any asynchronous statements.
86497:     // If this fails, the mDBConn will be left open, resulting in a leak.
86497:     // Ideally we'd schedule some code to destroy the mDBConn once all its
86497:     // async statements have finished executing;  see bug 704030.
39287:     MutexAutoLock lockedScope(sharedAsyncExecutionMutex);
74897:     bool asyncCloseWasCalled = !mAsyncExecutionThread;
74897:     NS_ENSURE_TRUE(asyncCloseWasCalled, NS_ERROR_UNEXPECTED);
39287:   }
39287: 
39287:   nsresult rv = setClosedState();
39287:   NS_ENSURE_SUCCESS(rv, rv);
39287: 
39287:   return internalClose();
39287: }
39287: 
39287: NS_IMETHODIMP
39287: Connection::AsyncClose(mozIStorageCompletionCallback *aCallback)
39287: {
39287:   if (!mDBConn)
39287:     return NS_ERROR_NOT_INITIALIZED;
39287: 
39769:   nsIEventTarget *asyncThread = getAsyncExecutionTarget();
39287:   NS_ENSURE_TRUE(asyncThread, NS_ERROR_UNEXPECTED);
39287: 
39287:   nsresult rv = setClosedState();
39287:   NS_ENSURE_SUCCESS(rv, rv);
39287: 
39287:   // Create our callback event if we were given a callback.
39287:   nsCOMPtr<nsIRunnable> completeEvent;
39287:   if (aCallback) {
39287:     completeEvent = newCompletionEvent(aCallback);
39287:     NS_ENSURE_TRUE(completeEvent, NS_ERROR_OUT_OF_MEMORY);
39287:   }
39287: 
39287:   // Create and dispatch our close event to the background thread.
39287:   nsCOMPtr<nsIRunnable> closeEvent =
39287:     new AsyncCloseConnection(this, NS_GetCurrentThread(), completeEvent);
39287:   NS_ENSURE_TRUE(closeEvent, NS_ERROR_OUT_OF_MEMORY);
39287: 
39287:   rv = asyncThread->Dispatch(closeEvent, NS_DISPATCH_NORMAL);
39287:   NS_ENSURE_SUCCESS(rv, rv);
39287: 
39287:   return NS_OK;
39287: }
39287: 
51598: NS_IMETHODIMP
79445: Connection::Clone(bool aReadOnly,
51598:                   mozIStorageConnection **_connection)
51598: {
87692:   SAMPLE_LABEL("storage", "Connection::Clone");
51598:   if (!mDBConn)
51598:     return NS_ERROR_NOT_INITIALIZED;
51598:   if (!mDatabaseFile)
51598:     return NS_ERROR_UNEXPECTED;
51598: 
51598:   int flags = mFlags;
51598:   if (aReadOnly) {
51598:     // Turn off SQLITE_OPEN_READWRITE, and set SQLITE_OPEN_READONLY.
51598:     flags = (~SQLITE_OPEN_READWRITE & flags) | SQLITE_OPEN_READONLY;
51598:     // Turn off SQLITE_OPEN_CREATE.
51598:     flags = (~SQLITE_OPEN_CREATE & flags);
51598:   }
51598:   nsRefPtr<Connection> clone = new Connection(mStorageService, flags);
51598:   NS_ENSURE_TRUE(clone, NS_ERROR_OUT_OF_MEMORY);
51598: 
51598:   nsresult rv = clone->initialize(mDatabaseFile);
51598:   NS_ENSURE_SUCCESS(rv, rv);
51598: 
81550:   // Copy over pragmas from the original connection.
81550:   static const char * pragmas[] = {
81550:     "cache_size",
81550:     "temp_store",
81550:     "foreign_keys",
81550:     "journal_size_limit",
81550:     "synchronous",
81550:     "wal_autocheckpoint",
81550:   };
81550:   for (PRUint32 i = 0; i < ArrayLength(pragmas); ++i) {
81550:     // Read-only connections just need cache_size and temp_store pragmas.
81550:     if (aReadOnly && ::strcmp(pragmas[i], "cache_size") != 0 &&
81550:                      ::strcmp(pragmas[i], "temp_store") != 0) {
81550:       continue;
81550:     }
81550: 
81550:     nsCAutoString pragmaQuery("PRAGMA ");
81550:     pragmaQuery.Append(pragmas[i]);
81550:     nsCOMPtr<mozIStorageStatement> stmt;
81550:     rv = CreateStatement(pragmaQuery, getter_AddRefs(stmt));
81550:     MOZ_ASSERT(NS_SUCCEEDED(rv));
81550:     bool hasResult = false;
81550:     if (stmt && NS_SUCCEEDED(stmt->ExecuteStep(&hasResult)) && hasResult) {
81550:       pragmaQuery.AppendLiteral(" = ");
81550:       pragmaQuery.AppendInt(stmt->AsInt32(0));
81550:       rv = clone->ExecuteSimpleSQL(pragmaQuery);
81550:       MOZ_ASSERT(NS_SUCCEEDED(rv));
81550:     }
81550:   }
81550: 
51598:   // Copy any functions that have been added to this connection.
51598:   (void)mFunctions.EnumerateRead(copyFunctionEnumerator, clone);
51598: 
51598:   NS_ADDREF(*_connection = clone);
51598:   return NS_OK;
51598: }
39287: 
 5459: NS_IMETHODIMP
79445: Connection::GetConnectionReady(bool *_ready)
    1: {
27440:   *_ready = (mDBConn != nsnull);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
27440: Connection::GetDatabaseFile(nsIFile **_dbFile)
    1: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
    1: 
27440:   NS_IF_ADDREF(*_dbFile = mDatabaseFile);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
27440: Connection::GetLastInsertRowID(PRInt64 *_id)
    1: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
    1: 
27440:   sqlite_int64 id = ::sqlite3_last_insert_rowid(mDBConn);
27440:   *_id = id;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
84685: Connection::GetAffectedRows(PRInt32 *_rows)
84685: {
84685:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
84685: 
84685:   *_rows = ::sqlite3_changes(mDBConn);
84685: 
84685:   return NS_OK;
84685: }
84685: 
84685: NS_IMETHODIMP
27440: Connection::GetLastError(PRInt32 *_error)
    1: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
    1: 
27440:   *_error = ::sqlite3_errcode(mDBConn);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
27440: Connection::GetLastErrorString(nsACString &_errorString)
    1: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
    1: 
27440:   const char *serr = ::sqlite3_errmsg(mDBConn);
27440:   _errorString.Assign(serr);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 2960: NS_IMETHODIMP
27440: Connection::GetSchemaVersion(PRInt32 *_version)
 2960: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
 2960: 
 2960:   nsCOMPtr<mozIStorageStatement> stmt;
27440:   (void)CreateStatement(NS_LITERAL_CSTRING("PRAGMA user_version"),
27440:                         getter_AddRefs(stmt));
27440:   NS_ENSURE_TRUE(stmt, NS_ERROR_OUT_OF_MEMORY);
 2960: 
27440:   *_version = 0;
79445:   bool hasResult;
 2960:   if (NS_SUCCEEDED(stmt->ExecuteStep(&hasResult)) && hasResult)
27440:     *_version = stmt->AsInt32(0);
 2960: 
 2960:   return NS_OK;
 2960: }
 2960: 
 2960: NS_IMETHODIMP
27440: Connection::SetSchemaVersion(PRInt32 aVersion)
 2960: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
 2960: 
 2960:   nsCAutoString stmt(NS_LITERAL_CSTRING("PRAGMA user_version = "));
 2960:   stmt.AppendInt(aVersion);
 2960: 
 2960:   return ExecuteSimpleSQL(stmt);
 2960: }
 2960: 
    1: NS_IMETHODIMP
27440: Connection::CreateStatement(const nsACString &aSQLStatement,
27440:                             mozIStorageStatement **_stmt)
    1: {
27440:   NS_ENSURE_ARG_POINTER(_stmt);
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
    1: 
28144:   nsRefPtr<Statement> statement(new Statement());
27440:   NS_ENSURE_TRUE(statement, NS_ERROR_OUT_OF_MEMORY);
    1: 
28144:   nsresult rv = statement->initialize(this, aSQLStatement);
27440:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
28144:   Statement *rawPtr;
27440:   statement.forget(&rawPtr);
27440:   *_stmt = rawPtr;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
39769: Connection::CreateAsyncStatement(const nsACString &aSQLStatement,
39769:                                  mozIStorageAsyncStatement **_stmt)
39769: {
39769:   NS_ENSURE_ARG_POINTER(_stmt);
39769:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
39769: 
39769:   nsRefPtr<AsyncStatement> statement(new AsyncStatement());
39769:   NS_ENSURE_TRUE(statement, NS_ERROR_OUT_OF_MEMORY);
39769: 
39769:   nsresult rv = statement->initialize(this, aSQLStatement);
39769:   NS_ENSURE_SUCCESS(rv, rv);
39769: 
39769:   AsyncStatement *rawPtr;
39769:   statement.forget(&rawPtr);
39769:   *_stmt = rawPtr;
39769:   return NS_OK;
39769: }
39769: 
39769: NS_IMETHODIMP
27440: Connection::ExecuteSimpleSQL(const nsACString &aSQLStatement)
    1: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
    1: 
27440:   int srv = ::sqlite3_exec(mDBConn, PromiseFlatCString(aSQLStatement).get(),
    1:                            NULL, NULL, NULL);
28140:   return convertResultCode(srv);
    1: }
    1: 
39769: NS_IMETHODIMP
39769: Connection::ExecuteAsync(mozIStorageBaseStatement **aStatements,
20442:                          PRUint32 aNumStatements,
20442:                          mozIStorageStatementCallback *aCallback,
27440:                          mozIStoragePendingStatement **_handle)
20442: {
29548:   nsTArray<StatementData> stmts(aNumStatements);
30834:   for (PRUint32 i = 0; i < aNumStatements; i++) {
39769:     nsCOMPtr<StorageBaseStatementInternal> stmt = 
39769:       do_QueryInterface(aStatements[i]);
30834: 
30834:     // Obtain our StatementData.
30834:     StatementData data;
30834:     nsresult rv = stmt->getAsynchronousStatementData(data);
30834:     NS_ENSURE_SUCCESS(rv, rv);
30834: 
39769:     NS_ASSERTION(stmt->getOwner() == this,
20442:                  "Statement must be from this database connection!");
20442: 
30834:     // Now append it to our array.
30834:     NS_ENSURE_TRUE(stmts.AppendElement(data), NS_ERROR_OUT_OF_MEMORY);
30615:   }
20442: 
20442:   // Dispatch to the background
30834:   return AsyncExecuteStatements::execute(stmts, this, aCallback, _handle);
20442: }
20442: 
27440: NS_IMETHODIMP
27440: Connection::TableExists(const nsACString &aTableName,
79445:                         bool *_exists)
    1: {
27440:     return databaseElementExists(TABLE, aTableName, _exists);
    1: }
    1: 
27440: NS_IMETHODIMP
27440: Connection::IndexExists(const nsACString &aIndexName,
79445:                         bool* _exists)
27440: {
27440:     return databaseElementExists(INDEX, aIndexName, _exists);
27440: }
    1: 
27440: NS_IMETHODIMP
79445: Connection::GetTransactionInProgress(bool *_inProgress)
27440: {
36744:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
36744: 
39769:   SQLiteMutexAutoLock lockedScope(sharedDBMutex);
27440:   *_inProgress = mTransactionInProgress;
25399:   return NS_OK;
25399: }
25399: 
25399: NS_IMETHODIMP
27440: Connection::BeginTransaction()
    1: {
16602:   return BeginTransactionAs(mozIStorageConnection::TRANSACTION_DEFERRED);
    1: }
    1: 
    1: NS_IMETHODIMP
27440: Connection::BeginTransactionAs(PRInt32 aTransactionType)
    1: {
36744:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
36744: 
39769:   SQLiteMutexAutoLock lockedScope(sharedDBMutex);
    1:   if (mTransactionInProgress)
 2327:     return NS_ERROR_FAILURE;
    1:   nsresult rv;
    1:   switch(aTransactionType) {
    1:     case TRANSACTION_DEFERRED:
    1:       rv = ExecuteSimpleSQL(NS_LITERAL_CSTRING("BEGIN DEFERRED"));
    1:       break;
    1:     case TRANSACTION_IMMEDIATE:
    1:       rv = ExecuteSimpleSQL(NS_LITERAL_CSTRING("BEGIN IMMEDIATE"));
    1:       break;
    1:     case TRANSACTION_EXCLUSIVE:
    1:       rv = ExecuteSimpleSQL(NS_LITERAL_CSTRING("BEGIN EXCLUSIVE"));
    1:       break;
    1:     default:
    1:       return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1:   if (NS_SUCCEEDED(rv))
80486:     mTransactionInProgress = true;
21127:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
27440: Connection::CommitTransaction()
    1: {
40922:   if (!mDBConn)
40922:     return NS_ERROR_NOT_INITIALIZED;
36744: 
39769:   SQLiteMutexAutoLock lockedScope(sharedDBMutex);
    1:   if (!mTransactionInProgress)
40922:     return NS_ERROR_UNEXPECTED;
40922: 
    1:   nsresult rv = ExecuteSimpleSQL(NS_LITERAL_CSTRING("COMMIT TRANSACTION"));
21127:   if (NS_SUCCEEDED(rv))
80486:     mTransactionInProgress = false;
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
27440: Connection::RollbackTransaction()
    1: {
40922:   if (!mDBConn)
40922:     return NS_ERROR_NOT_INITIALIZED;
36744: 
39769:   SQLiteMutexAutoLock lockedScope(sharedDBMutex);
    1:   if (!mTransactionInProgress)
40922:     return NS_ERROR_UNEXPECTED;
40922: 
    1:   nsresult rv = ExecuteSimpleSQL(NS_LITERAL_CSTRING("ROLLBACK TRANSACTION"));
21127:   if (NS_SUCCEEDED(rv))
80486:     mTransactionInProgress = false;
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
27440: Connection::CreateTable(const char *aTableName,
    1:                         const char *aTableSchema)
    1: {
13194:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
    1: 
27440:   char *buf = ::PR_smprintf("CREATE TABLE %s (%s)", aTableName, aTableSchema);
    1:   if (!buf)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
27440:   int srv = ::sqlite3_exec(mDBConn, buf, NULL, NULL, NULL);
27440:   ::PR_smprintf_free(buf);
    1: 
28140:   return convertResultCode(srv);
    1: }
    1: 
    1: NS_IMETHODIMP
27440: Connection::CreateFunction(const nsACString &aFunctionName,
    1:                            PRInt32 aNumArguments,
    1:                            mozIStorageFunction *aFunction)
    1: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
 3228: 
27440:   // Check to see if this function is already defined.  We only check the name
27440:   // because a function can be defined with the same body but different names.
39769:   SQLiteMutexAutoLock lockedScope(sharedDBMutex);
 3228:   NS_ENSURE_FALSE(mFunctions.Get(aFunctionName, NULL), NS_ERROR_FAILURE);
    1: 
27440:   int srv = ::sqlite3_create_function(mDBConn,
 3228:                                       nsPromiseFlatCString(aFunctionName).get(),
    1:                                       aNumArguments,
    1:                                       SQLITE_ANY,
    1:                                       aFunction,
27440:                                       basicFunctionHelper,
 3228:                                       NULL,
 3228:                                       NULL);
27440:   if (srv != SQLITE_OK)
28140:     return convertResultCode(srv);
    1: 
51598:   FunctionInfo info = { aFunction,
51598:                         Connection::FunctionInfo::SIMPLE,
51598:                         aNumArguments };
51598:   NS_ENSURE_TRUE(mFunctions.Put(aFunctionName, info),
27440:                  NS_ERROR_OUT_OF_MEMORY);
27440: 
 3228:   return NS_OK;
 3228: }
 3228: 
 3228: NS_IMETHODIMP
27440: Connection::CreateAggregateFunction(const nsACString &aFunctionName,
 3228:                                     PRInt32 aNumArguments,
 3228:                                     mozIStorageAggregateFunction *aFunction)
 3228: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
 3228: 
27440:   // Check to see if this function name is already defined.
39769:   SQLiteMutexAutoLock lockedScope(sharedDBMutex);
 3228:   NS_ENSURE_FALSE(mFunctions.Get(aFunctionName, NULL), NS_ERROR_FAILURE);
 3228: 
27440:   // Because aggregate functions depend on state across calls, you cannot have
27440:   // the same instance use the same name.  We want to enumerate all functions
27440:   // and make sure this instance is not already registered.
27440:   NS_ENSURE_FALSE(findFunctionByInstance(aFunction), NS_ERROR_FAILURE);
 3228: 
27440:   int srv = ::sqlite3_create_function(mDBConn,
 3228:                                       nsPromiseFlatCString(aFunctionName).get(),
 3228:                                       aNumArguments,
 3228:                                       SQLITE_ANY,
 3228:                                       aFunction,
 3228:                                       NULL,
27440:                                       aggregateFunctionStepHelper,
27440:                                       aggregateFunctionFinalHelper);
27440:   if (srv != SQLITE_OK)
28140:     return convertResultCode(srv);
 3228: 
51598:   FunctionInfo info = { aFunction,
51598:                         Connection::FunctionInfo::AGGREGATE,
51598:                         aNumArguments };
51598:   NS_ENSURE_TRUE(mFunctions.Put(aFunctionName, info),
27440:                  NS_ERROR_OUT_OF_MEMORY);
27440: 
 3228:   return NS_OK;
 3228: }
 3228: 
 3228: NS_IMETHODIMP
27440: Connection::RemoveFunction(const nsACString &aFunctionName)
 3228: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
 3228: 
39769:   SQLiteMutexAutoLock lockedScope(sharedDBMutex);
15747:   NS_ENSURE_TRUE(mFunctions.Get(aFunctionName, NULL), NS_ERROR_FAILURE);
 3228: 
27440:   int srv = ::sqlite3_create_function(mDBConn,
 3228:                                       nsPromiseFlatCString(aFunctionName).get(),
 3228:                                       0,
 3228:                                       SQLITE_ANY,
 3228:                                       NULL,
 3228:                                       NULL,
 3228:                                       NULL,
 3228:                                       NULL);
27440:   if (srv != SQLITE_OK)
28140:     return convertResultCode(srv);
 3228: 
 3228:   mFunctions.Remove(aFunctionName);
 3228: 
 3228:   return NS_OK;
 3228: }
 3228: 
 3228: NS_IMETHODIMP
27440: Connection::SetProgressHandler(PRInt32 aGranularity,
 3228:                                mozIStorageProgressHandler *aHandler,
27440:                                mozIStorageProgressHandler **_oldHandler)
 3228: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
 3228: 
 3228:   // Return previous one
39769:   SQLiteMutexAutoLock lockedScope(sharedDBMutex);
27440:   NS_IF_ADDREF(*_oldHandler = mProgressHandler);
 3228: 
 3228:   if (!aHandler || aGranularity <= 0) {
 3228:     aHandler = nsnull;
 3228:     aGranularity = 0;
 3228:   }
 3228:   mProgressHandler = aHandler;
27440:   ::sqlite3_progress_handler(mDBConn, aGranularity, sProgressHelper, this);
 3228: 
 3228:   return NS_OK;
 3228: }
 3228: 
 3228: NS_IMETHODIMP
27440: Connection::RemoveProgressHandler(mozIStorageProgressHandler **_oldHandler)
 3228: {
 3228:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
 3228: 
 3228:   // Return previous one
39769:   SQLiteMutexAutoLock lockedScope(sharedDBMutex);
27440:   NS_IF_ADDREF(*_oldHandler = mProgressHandler);
 3228: 
 3228:   mProgressHandler = nsnull;
27440:   ::sqlite3_progress_handler(mDBConn, 0, NULL, NULL);
 3228: 
 3228:   return NS_OK;
 3228: }
 3228: 
51868: NS_IMETHODIMP
51868: Connection::SetGrowthIncrement(PRInt32 aChunkSize, const nsACString &aDatabaseName)
51868: {
55393:   // Bug 597215: Disk space is extremely limited on Android
55393:   // so don't preallocate space. This is also not effective
55393:   // on log structured file systems used by Android devices
59017: #if !defined(ANDROID) && !defined(MOZ_PLATFORM_MAEMO)
77864:   // Don't preallocate if less than 500MiB is available.
77864:   nsCOMPtr<nsILocalFile> localFile = do_QueryInterface(mDatabaseFile);
77864:   NS_ENSURE_STATE(localFile);
77864:   PRInt64 bytesAvailable;
77864:   nsresult rv = localFile->GetDiskSpaceAvailable(&bytesAvailable);
77864:   NS_ENSURE_SUCCESS(rv, rv);
77864:   if (bytesAvailable < MIN_AVAILABLE_BYTES_PER_CHUNKED_GROWTH) {
77864:     return NS_ERROR_FILE_TOO_BIG;
77864:   }
77864: 
51868:   (void)::sqlite3_file_control(mDBConn,
51868:                                aDatabaseName.Length() ? nsPromiseFlatCString(aDatabaseName).get() : NULL,
51868:                                SQLITE_FCNTL_CHUNK_SIZE,
51868:                                &aChunkSize);
55393: #endif
51868:   return NS_OK;
51868: }
51868: 
84685: NS_IMETHODIMP
84685: Connection::EnableModule(const nsACString& aModuleName)
84685: {
84685:   if (!mDBConn) return NS_ERROR_NOT_INITIALIZED;
84685: 
84685:   for (size_t i = 0; i < ArrayLength(gModules); i++) {
84685:     struct Module* m = &gModules[i];
84685:     if (aModuleName.Equals(m->name)) {
84685:       int srv = m->registerFunc(mDBConn, m->name);
84685:       if (srv != SQLITE_OK)
84685:         return convertResultCode(srv);
84685: 
84685:       return NS_OK;
84685:     }
84685:   }
84685: 
84685:   return NS_ERROR_FAILURE;
84685: }
84685: 
27440: } // namespace storage
27440: } // namespace mozilla
