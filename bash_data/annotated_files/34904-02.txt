    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAccessibleTreeWalker.h"
27515: 
    1: #include "nsAccessibilityAtoms.h"
    1: #include "nsAccessNode.h"
27515: 
27515: #include "nsIAnonymousContentCreator.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIContent.h"
    1: #include "nsIDOMXULElement.h"
    1: #include "nsIPresShell.h"
    1: #include "nsWeakReference.h"
    1: 
    1: nsAccessibleTreeWalker::nsAccessibleTreeWalker(nsIWeakReference* aPresShell, nsIDOMNode* aNode, PRBool aWalkAnonContent): 
    1:   mWeakShell(aPresShell), 
    1:   mAccService(do_GetService("@mozilla.org/accessibilityService;1")),
    1:   mWalkAnonContent(aWalkAnonContent)
    1: {
    1:   mState.domNode = aNode;
    1:   mState.prevState = nsnull;
    1:   mState.siblingIndex = eSiblingsUninitialized;
    1:   mState.siblingList = nsnull;
    1:   mState.isHidden = false;
    1: 
    1:   MOZ_COUNT_CTOR(nsAccessibleTreeWalker);
    1: }
    1: 
    1: nsAccessibleTreeWalker::~nsAccessibleTreeWalker()
    1: {
    1:   // Clear state stack from memory
    1:   while (NS_SUCCEEDED(PopState()))
    1:     /* do nothing */ ;
    1:    MOZ_COUNT_DTOR(nsAccessibleTreeWalker);
    1: }
    1: 
    1: void nsAccessibleTreeWalker::GetKids(nsIDOMNode *aParentNode)
    1: {
    1:   nsCOMPtr<nsIContent> parentContent(do_QueryInterface(aParentNode));
33329:   if (!parentContent || !parentContent->IsHTML()) {
    1:     mState.frame = nsnull;  // Don't walk frames in non-HTML content, just walk the DOM.
    1:   }
    1: 
    1:   UpdateFrame(PR_TRUE);
    1: 
    1:   // Walk frames? UpdateFrame() sets this when it sees anonymous frames
    1:   if (mState.siblingIndex == eSiblingsWalkFrames) {
    1:     return;
    1:   }
    1: 
    1:   // Walk anonymous content? Not currently used for HTML -- anonymous content there uses frame walking
    1:   mState.siblingIndex = 0;   // Indicates our index into the sibling list
    1:   if (parentContent) {
    1:     if (mWalkAnonContent) {
    1:       // Walk anonymous content
    1:       nsIDocument* doc = parentContent->GetOwnerDoc();
    1:       if (doc) {
    1:         // returns null if no anon nodes
    1:         doc->GetXBLChildNodesFor(parentContent,
    1:                                  getter_AddRefs(mState.siblingList));
    1:       }
    1:     }
    1:     if (!mState.siblingList) {
    1:       // Walk normal DOM. Just use nsIContent -- it doesn't require 
    1:       // the mallocs that GetChildNodes() needs
    1:       //aParentNode->GetChildNodes(getter_AddRefs(mState.siblingList));
    1:       mState.parentContent = parentContent;
    1:       mState.domNode = do_QueryInterface(parentContent->GetChildAt(0 /* 0 == mState.siblingIndex */));
    1:       return;
    1:     }
    1:   }
    1:   else {
    1:     // We're on document node, that's why we could not QI to nsIContent.
    1:     // So, use nsIDOMNodeList method to walk content.
    1:     aParentNode->GetChildNodes(getter_AddRefs(mState.siblingList));
    1:     if (!mState.siblingList) {
    1:       return;
    1:     }
    1:   }
    1: 
    1:   mState.siblingList->Item(0 /* 0 == mState.siblingIndex */, getter_AddRefs(mState.domNode));
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessibleTreeWalker::PopState()
    1: {
34904:   nsIFrame *frameParent =
34904:     mState.frame.GetFrame() ? mState.frame.GetFrame()->GetParent() : nsnull;
    1:   if (mState.prevState) {
    1:     WalkState *toBeDeleted = mState.prevState;
    1:     mState = *mState.prevState; // deep copy
    1:     mState.isHidden = PR_FALSE; // If we were in a child, the parent wasn't hidden
34904:     if (!mState.frame.GetFrame()) {
    1:       mState.frame = frameParent;
    1:     }
    1:     delete toBeDeleted;
    1:     return NS_OK;
    1:   }
    1:   ClearState();
    1:   mState.frame = frameParent;
    1:   mState.isHidden = PR_FALSE;
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: void nsAccessibleTreeWalker::ClearState()
    1: {
    1:   mState.siblingList = nsnull;
    1:   mState.parentContent = nsnull;
    1:   mState.accessible = nsnull;
    1:   mState.domNode = nsnull;
    1:   mState.siblingIndex = eSiblingsUninitialized;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessibleTreeWalker::PushState()
    1: {
    1:   // Duplicate mState and put right before end; reset mState; make mState the new end of the stack
    1:   WalkState* nextToLastState= new WalkState();
    1:   if (!nextToLastState)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   *nextToLastState = mState;  // Deep copy - copy contents of struct to new state that will be added to end of our stack
    1:   ClearState();
    1:   mState.prevState = nextToLastState;   // Link to previous state
    1:   return NS_OK;
    1: }
    1: 
    1: void nsAccessibleTreeWalker::GetNextDOMNode()
    1: {
    1:   // Get next DOM node
    1:   if (mState.parentContent) {
    1:     mState.domNode = do_QueryInterface(mState.parentContent->GetChildAt(++mState.siblingIndex));
    1:   }
    1:   else if (mState.siblingIndex == eSiblingsWalkFrames) {
34904:     if (mState.frame.GetFrame()) {
34904:       mState.domNode = do_QueryInterface(mState.frame.GetFrame()->GetContent());
    1:     } else {
    1:       mState.domNode = nsnull;
    1:     }
    1:   }
    1:   else { 
    1:     mState.siblingList->Item(++mState.siblingIndex, getter_AddRefs(mState.domNode));
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessibleTreeWalker::GetNextSibling()
    1: {
    1:   // Make sure mState.prevState and mState.siblingIndex are initialized so we can walk forward
    1:   NS_ASSERTION(mState.prevState && mState.siblingIndex != eSiblingsUninitialized,
    1:                "Error - GetNextSibling() only works after a GetFirstChild(), so we must have a prevState.");
    1:   mState.accessible = nsnull;
    1: 
    1:   while (PR_TRUE) {
    1:     // Get next frame
    1:     UpdateFrame(PR_FALSE);
    1:     GetNextDOMNode();
    1: 
    1:     if (!mState.domNode) {  // Done with current siblings
    1:       PopState();   // Use parent - go up in stack. Can always pop state because we have to start with a GetFirstChild().
    1:       if (!mState.prevState) {
    1:         mState.accessible = nsnull;
    1:         break; // Back to original accessible that we did GetFirstChild() from
    1:       }
    1:     }
    1:     else if ((mState.domNode != mState.prevState->domNode && GetAccessible()) || 
    1:              NS_SUCCEEDED(GetFirstChild())) {
    1:       return NS_OK; // if next is accessible, use it 
    1:     }
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessibleTreeWalker::GetFirstChild()
    1: {
    1:   mState.accessible = nsnull;
    1:   if (mState.isHidden || !mState.domNode) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> parent(mState.domNode);
27607: 
27607:   PushState();
    1:   GetKids(parent); // Side effects change our state (mState)
    1: 
    1:   // Recursive loop: depth first search for first accessible child
    1:   while (mState.domNode) {
    1:     if ((mState.domNode != parent && GetAccessible()) || NS_SUCCEEDED(GetFirstChild()))
    1:       return NS_OK;
    1:     UpdateFrame(PR_FALSE);
    1:     GetNextDOMNode();
    1:   }
    1: 
    1:   PopState();  // Return to previous state
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: void nsAccessibleTreeWalker::UpdateFrame(PRBool aTryFirstChild)
    1: {
34904:   nsIFrame *curFrame = mState.frame.GetFrame();
34904:   if (!curFrame) {
    1:     return;
    1:   }
27515: 
    1:   if (aTryFirstChild) {
27515:     // If the frame implements nsIAnonymousContentCreator interface then go down
27515:     // through the frames and obtain anonymous nodes for them.
34904:     nsIAnonymousContentCreator* creator = do_QueryFrame(curFrame);
34904:     nsIFrame *child = curFrame->GetFirstChild(nsnull);
34904:     mState.frame = child;
27515: 
34904:     if (creator && child && mState.siblingIndex < 0) {
34904:       mState.domNode = do_QueryInterface(child->GetContent());
27515:       mState.siblingIndex = eSiblingsWalkFrames;
27515:     }
    1: // temporary workaround for Bug 359210. We never want to walk frames.
    1: // Aaron Leventhal will refix :before and :after content later without walking frames.
    1: #if 0
    1:     if (mState.frame && mState.siblingIndex < 0) {
    1:       // Container frames can contain generated content frames from
    1:       // :before and :after style rules, so we walk their frame trees
    1:       // instead of content trees
    1:       // XXX Walking the frame tree doesn't get us Aural CSS nodes, e.g. 
    1:       // @media screen { display: none; }
    1:       // Asking the style system might be better (with ProbePseudoStyleFor(),
    1:       // except that we need to ask only for those display types that support 
    1:       // :before and :after (which roughly means non-replaced elements)
    1:       // Here's some code to see if there is an :after rule for an element
    1:       // nsRefPtr<nsStyleContext> pseudoContext;
    1:       // nsStyleContext *styleContext = primaryFrame->GetStyleContext();
    1:       // if (aContent) {
    1:       //   pseudoContext = presContext->StyleSet()->
    1:       //     ProbePseudoStyleFor(content, nsAccessibilityAtoms::after, aStyleContext);
    1:       mState.domNode = do_QueryInterface(mState.frame->GetContent());
    1:       mState.siblingIndex = eSiblingsWalkFrames;
    1:     }
    1: #endif
    1:   }
    1:   else {
34904:     mState.frame = curFrame->GetNextSibling();
    1:   }
    1: }
    1: 
    1: /**
    1:  * If the DOM node's frame has an accessible or the DOMNode
    1:  * itself implements nsIAccessible return it.
    1:  */
    1: PRBool nsAccessibleTreeWalker::GetAccessible()
    1: {
    1:   if (!mAccService) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   mState.accessible = nsnull;
    1:   nsCOMPtr<nsIPresShell> presShell(do_QueryReferent(mWeakShell));
    1: 
34904:   nsIFrame *frame = mState.frame.GetFrame();
    1:   mAccService->GetAccessible(mState.domNode, presShell, mWeakShell,
34904:                              &frame, &mState.isHidden,
    1:                              getter_AddRefs(mState.accessible));
34904:   mState.frame = frame;
    1:   return mState.accessible ? PR_TRUE : PR_FALSE;
    1: }
    1: 
