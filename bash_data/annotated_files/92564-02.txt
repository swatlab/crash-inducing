    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla SVG project.
    1:  *
    1:  * The Initial Developer of the Original Code is IBM Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2004
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80467: #include "mozilla/Util.h"
80467: 
    1: #include "nsSVGAngle.h"
    1: #include "prdtoa.h"
    1: #include "nsTextFormatter.h"
    1: #include "nsSVGUtils.h"
38295: #include "nsSVGMarkerElement.h"
74645: #include "nsMathUtils.h"
75263: #include "nsContentUtils.h" // NS_ENSURE_FINITE
38295: #include "nsSMILValue.h"
38295: #include "SVGOrientSMILType.h"
    1: 
38295: using namespace mozilla;
38295: 
38295: /**
38295:  * Mutable SVGAngle class for SVGSVGElement.createSVGAngle().
38295:  *
38295:  * Note that this class holds its own nsSVGAngle, which therefore can't be
38295:  * animated. This means SVGMarkerElement::setOrientToAngle(angle) must copy
38295:  * any DOMSVGAngle passed in. Perhaps this is wrong and inconsistent with
38295:  * other parts of SVG, but it's how the code works for now.
38295:  */
 6788: class DOMSVGAngle : public nsIDOMSVGAngle
    1: {
    1: public:
    1:   NS_DECL_ISUPPORTS
    1: 
 6788:   DOMSVGAngle()
 6788:     { mVal.Init(); }
    1:     
 6788:   NS_IMETHOD GetUnitType(PRUint16* aResult)
38295:     { *aResult = mVal.mBaseValUnit; return NS_OK; }
    1: 
 6788:   NS_IMETHOD GetValue(float* aResult)
 6788:     { *aResult = mVal.GetBaseValue(); return NS_OK; }
 6788:   NS_IMETHOD SetValue(float aValue)
14038:     {
14038:       NS_ENSURE_FINITE(aValue, NS_ERROR_ILLEGAL_VALUE);
92564:       mVal.SetBaseValue(aValue, nsnull, false);
14038:       return NS_OK;
14038:     }
    1: 
 6788:   NS_IMETHOD GetValueInSpecifiedUnits(float* aResult)
 6788:     { *aResult = mVal.mBaseVal; return NS_OK; }
 6788:   NS_IMETHOD SetValueInSpecifiedUnits(float aValue)
14038:     {
14038:       NS_ENSURE_FINITE(aValue, NS_ERROR_ILLEGAL_VALUE);
14038:       mVal.mBaseVal = aValue;
14038:       return NS_OK;
14038:     }
    1: 
 6788:   NS_IMETHOD SetValueAsString(const nsAString& aValue)
80486:     { return mVal.SetBaseValueString(aValue, nsnull, false); }
 6788:   NS_IMETHOD GetValueAsString(nsAString& aValue)
 6788:     { mVal.GetBaseValueString(aValue); return NS_OK; }
    1: 
 6788:   NS_IMETHOD NewValueSpecifiedUnits(PRUint16 unitType,
 6788:                                     float valueInSpecifiedUnits)
14038:     {
37353:       return mVal.NewValueSpecifiedUnits(unitType, valueInSpecifiedUnits, nsnull);
14038:     }
 6788: 
 6788:   NS_IMETHOD ConvertToSpecifiedUnits(PRUint16 unitType)
37353:     { return mVal.ConvertToSpecifiedUnits(unitType, nsnull); }
 6788: 
 6788: private:
 6788:   nsSVGAngle mVal;
    1: };
    1: 
23193: NS_SVG_VAL_IMPL_CYCLE_COLLECTION(nsSVGAngle::DOMBaseVal, mSVGElement)
    1: 
23193: NS_SVG_VAL_IMPL_CYCLE_COLLECTION(nsSVGAngle::DOMAnimVal, mSVGElement)
    1: 
23193: NS_SVG_VAL_IMPL_CYCLE_COLLECTION(nsSVGAngle::DOMAnimatedAngle, mSVGElement)
23193: 
23193: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsSVGAngle::DOMBaseVal)
23193: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsSVGAngle::DOMBaseVal)
23193: 
23193: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsSVGAngle::DOMAnimVal)
23193: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsSVGAngle::DOMAnimVal)
23193: 
23193: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsSVGAngle::DOMAnimatedAngle)
23193: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsSVGAngle::DOMAnimatedAngle)
 6788: 
 6788: NS_IMPL_ADDREF(DOMSVGAngle)
 6788: NS_IMPL_RELEASE(DOMSVGAngle)
 6788: 
40490: DOMCI_DATA(SVGAngle, nsSVGAngle::DOMBaseVal)
40490: DOMCI_DATA(SVGAnimatedAngle, nsSVGAngle::DOMAnimatedAngle)
40490: 
23193: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsSVGAngle::DOMBaseVal)
 6788:   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAngle)
 6788:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(SVGAngle)
 6788: NS_INTERFACE_MAP_END
 6788: 
23193: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsSVGAngle::DOMAnimVal)
 6788:   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAngle)
 6788:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(SVGAngle)
 6788: NS_INTERFACE_MAP_END
 6788: 
23193: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsSVGAngle::DOMAnimatedAngle)
 6788:   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAnimatedAngle)
 6788:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(SVGAnimatedAngle)
 6788: NS_INTERFACE_MAP_END
 6788: 
 6788: NS_INTERFACE_MAP_BEGIN(DOMSVGAngle)
 6788:   NS_INTERFACE_MAP_ENTRY(nsIDOMSVGAngle)
 6788:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(SVGAngle)
 6788: NS_INTERFACE_MAP_END
 6788: 
 6788: static nsIAtom** const unitMap[] =
 6665: {
 6788:   nsnull, /* SVG_ANGLETYPE_UNKNOWN */
 6788:   nsnull, /* SVG_ANGLETYPE_UNSPECIFIED */
 6788:   &nsGkAtoms::deg,
 6788:   &nsGkAtoms::rad,
 6788:   &nsGkAtoms::grad
 6788: };
 6788: 
 6788: /* Helper functions */
 6788: 
79445: static bool
 6788: IsValidUnitType(PRUint16 unit)
 6788: {
 6788:   if (unit > nsIDOMSVGAngle::SVG_ANGLETYPE_UNKNOWN &&
 6788:       unit <= nsIDOMSVGAngle::SVG_ANGLETYPE_GRAD)
80486:     return true;
 6788: 
80486:   return false;
 6665: }
 6661: 
 6788: static void 
 6788: GetUnitString(nsAString& unit, PRUint16 unitType)
 6665: {
 6788:   if (IsValidUnitType(unitType)) {
 6788:     if (unitMap[unitType]) {
 6788:       (*unitMap[unitType])->ToString(unit);
 6665:     }
 6788:     return;
 6665:   }
 6661: 
 6788:   NS_NOTREACHED("Unknown unit type");
 6788:   return;
 6665: }
 6665: 
 6788: static PRUint16
 6788: GetUnitTypeForString(const char* unitStr)
 6665: {
 6788:   if (!unitStr || *unitStr == '\0') 
 6788:     return nsIDOMSVGAngle::SVG_ANGLETYPE_UNSPECIFIED;
 6788:                    
 6788:   nsCOMPtr<nsIAtom> unitAtom = do_GetAtom(unitStr);
 6788: 
80467:   for (PRUint32 i = 0 ; i < ArrayLength(unitMap) ; i++) {
 6788:     if (unitMap[i] && *unitMap[i] == unitAtom) {
 6788:       return i;
 6788:     }
 6665:   }
 6665: 
 6788:   return nsIDOMSVGAngle::SVG_ANGLETYPE_UNKNOWN;
    1: }
    1: 
 6788: static void
 6788: GetValueString(nsAString &aValueAsString, float aValue, PRUint16 aUnitType)
    1: {
    1:   PRUnichar buf[24];
    1:   nsTextFormatter::snprintf(buf, sizeof(buf)/sizeof(PRUnichar),
    1:                             NS_LITERAL_STRING("%g").get(),
 6788:                             (double)aValue);
    1:   aValueAsString.Assign(buf);
    1: 
    1:   nsAutoString unitString;
 6788:   GetUnitString(unitString, aUnitType);
    1:   aValueAsString.Append(unitString);
    1: }
    1: 
 6788: static nsresult
 6788: GetValueFromString(const nsAString &aValueAsString,
 6788:                    float *aValue,
 6788:                    PRUint16 *aUnitType)
    1: {
 7034:   NS_ConvertUTF16toUTF8 value(aValueAsString);
 7034:   const char *str = value.get();
 6665: 
 7034:   if (NS_IsAsciiWhitespace(*str))
37353:     return NS_ERROR_DOM_SYNTAX_ERR;
    1:   
    1:   char *rest;
 7034:   *aValue = float(PR_strtod(str, &rest));
74645:   if (rest != str && NS_finite(*aValue)) {
 7034:     *aUnitType = GetUnitTypeForString(rest);
 6788:     if (IsValidUnitType(*aUnitType)) {
 7034:       return NS_OK;
    1:     }
    1:   }
    1:   
37353:   return NS_ERROR_DOM_SYNTAX_ERR;
    1: }
    1: 
38295: /* static */ float
38295: nsSVGAngle::GetDegreesPerUnit(PRUint8 aUnit)
    1: {
38295:   switch (aUnit) {
 6788:   case nsIDOMSVGAngle::SVG_ANGLETYPE_UNSPECIFIED:
 6788:   case nsIDOMSVGAngle::SVG_ANGLETYPE_DEG:
37536:     return 1;
 6788:   case nsIDOMSVGAngle::SVG_ANGLETYPE_RAD:
38295:     return static_cast<float>(180.0 / M_PI);
 6788:   case nsIDOMSVGAngle::SVG_ANGLETYPE_GRAD:
64523:     return 90.0f / 100.0f;
 6788:   default:
 6788:     NS_NOTREACHED("Unknown unit type");
 6788:     return 0;
 6788:   }
 6788: }
    1: 
 6788: void
 6788: nsSVGAngle::SetBaseValueInSpecifiedUnits(float aValue,
 6788:                                          nsSVGElement *aSVGElement)
 6788: {
90217:   if (mBaseVal == aValue) {
90217:     return;
90217:   }
90217: 
90217:   nsAttrValue emptyOrOldValue = aSVGElement->WillChangeAngle(mAttrEnum);
 6788:   mBaseVal = aValue;
38295:   if (!mIsAnimated) {
38295:     mAnimVal = mBaseVal;
38295:   }
38295:   else {
38295:     aSVGElement->AnimationNeedsResample();
38295:   }
90217:   aSVGElement->DidChangeAngle(mAttrEnum, emptyOrOldValue);
 6788: }
 6788: 
37353: nsresult
 6788: nsSVGAngle::ConvertToSpecifiedUnits(PRUint16 unitType,
 6788:                                     nsSVGElement *aSVGElement)
 6788: {
 6788:   if (!IsValidUnitType(unitType))
37353:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 6788: 
90217:   if (mBaseValUnit == PRUint8(unitType))
90217:     return NS_OK;
90217: 
92564:   nsAttrValue emptyOrOldValue;
92564:   if (aSVGElement) {
92564:     emptyOrOldValue = aSVGElement->WillChangeAngle(mAttrEnum);
92564:   }
90217: 
38295:   float valueInUserUnits = mBaseVal * GetDegreesPerUnit(mBaseValUnit);
38295:   mBaseValUnit = PRUint8(unitType);
90217:   // Setting aDoSetAttr to false here will ensure we don't call
90217:   // Will/DidChangeAngle a second time (and dispatch duplicate notifications).
90217:   SetBaseValue(valueInUserUnits, aSVGElement, false);
90217: 
92564:   if (aSVGElement) {
90217:     aSVGElement->DidChangeAngle(mAttrEnum, emptyOrOldValue);
92564:   }
90217: 
37353:   return NS_OK;
 6788: }
 6788: 
37353: nsresult
 6788: nsSVGAngle::NewValueSpecifiedUnits(PRUint16 unitType,
 6788:                                    float valueInSpecifiedUnits,
 6788:                                    nsSVGElement *aSVGElement)
 6788: {
37353:   NS_ENSURE_FINITE(valueInSpecifiedUnits, NS_ERROR_ILLEGAL_VALUE);
37353: 
 6788:   if (!IsValidUnitType(unitType))
37353:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
 6788: 
90217:   if (mBaseVal == valueInSpecifiedUnits && mBaseValUnit == PRUint8(unitType))
90217:     return NS_OK;
90217: 
90217:   nsAttrValue emptyOrOldValue;
90217:   if (aSVGElement) {
90217:     emptyOrOldValue = aSVGElement->WillChangeAngle(mAttrEnum);
90217:   }
38295:   mBaseVal = valueInSpecifiedUnits;
38295:   mBaseValUnit = PRUint8(unitType);
38295:   if (!mIsAnimated) {
38295:     mAnimVal = mBaseVal;
38295:     mAnimValUnit = mBaseValUnit;
38295:   }
38295:   else {
38295:     aSVGElement->AnimationNeedsResample();
38295:   }
47880:   if (aSVGElement) {
90217:     aSVGElement->DidChangeAngle(mAttrEnum, emptyOrOldValue);
47880:   }
37353:   return NS_OK;
 6788: }
 6788: 
 6788: nsresult
 6788: nsSVGAngle::ToDOMBaseVal(nsIDOMSVGAngle **aResult, nsSVGElement *aSVGElement)
 6788: {
 6788:   *aResult = new DOMBaseVal(this, aSVGElement);
 6788:   if (!*aResult)
 6788:     return NS_ERROR_OUT_OF_MEMORY;
 6788: 
 6788:   NS_ADDREF(*aResult);
 6788:   return NS_OK;
 6788: }
 6788: 
 6788: nsresult
 6788: nsSVGAngle::ToDOMAnimVal(nsIDOMSVGAngle **aResult, nsSVGElement *aSVGElement)
 6788: {
 6788:   *aResult = new DOMAnimVal(this, aSVGElement);
 6788:   if (!*aResult)
 6788:     return NS_ERROR_OUT_OF_MEMORY;
 6788: 
 6788:   NS_ADDREF(*aResult);
 6788:   return NS_OK;
 6788: }
 6788: 
 6788: /* Implementation */
 6788: 
 6788: nsresult
 6788: nsSVGAngle::SetBaseValueString(const nsAString &aValueAsString,
 6788:                                nsSVGElement *aSVGElement,
79445:                                bool aDoSetAttr)
 6788: {
68468:   float value = 0;
68468:   PRUint16 unitType = 0;
 6788:   
 6788:   nsresult rv = GetValueFromString(aValueAsString, &value, &unitType);
 6945:   if (NS_FAILED(rv)) {
 6945:     return rv;
 6945:   }
90217:   if (mBaseVal == value && mBaseValUnit == PRUint8(unitType)) {
90217:     return NS_OK;
90217:   }
 6788: 
90217:   nsAttrValue emptyOrOldValue;
90217:   if (aDoSetAttr) {
90217:     emptyOrOldValue = aSVGElement->WillChangeAngle(mAttrEnum);
90217:   }
38295:   mBaseVal = value;
38295:   mBaseValUnit = PRUint8(unitType);
38295:   if (!mIsAnimated) {
38295:     mAnimVal = mBaseVal;
38295:     mAnimValUnit = mBaseValUnit;
38295:   }
38295:   else {
38295:     aSVGElement->AnimationNeedsResample();
38295:   }
    1: 
90217:   if (aDoSetAttr) {
90217:     aSVGElement->DidChangeAngle(mAttrEnum, emptyOrOldValue);
90217:   }
    1:   return NS_OK;
    1: }
    1: 
 6788: void
90217: nsSVGAngle::GetBaseValueString(nsAString & aValueAsString) const
    1: {
38295:   GetValueString(aValueAsString, mBaseVal, mBaseValUnit);
 6788: }
    1: 
 6788: void
90217: nsSVGAngle::GetAnimValueString(nsAString & aValueAsString) const
 6788: {
38295:   GetValueString(aValueAsString, mAnimVal, mAnimValUnit);
 6788: }
    1: 
 6788: void
90217: nsSVGAngle::SetBaseValue(float aValue, nsSVGElement *aSVGElement,
90217:                          bool aDoSetAttr)
 6788: {
90217:   if (mBaseVal == aValue * GetDegreesPerUnit(mBaseValUnit)) {
90217:     return;
90217:   }
90217:   nsAttrValue emptyOrOldValue;
90217:   if (aSVGElement && aDoSetAttr) {
90217:     emptyOrOldValue = aSVGElement->WillChangeAngle(mAttrEnum);
90217:   }
90217: 
38295:   mBaseVal = aValue / GetDegreesPerUnit(mBaseValUnit);
38295:   if (!mIsAnimated) {
38295:     mAnimVal = mBaseVal;
38295:   }
47880:   else {
38295:     aSVGElement->AnimationNeedsResample();
38295:   }
90217:   if (aSVGElement && aDoSetAttr) {
90217:     aSVGElement->DidChangeAngle(mAttrEnum, emptyOrOldValue);
 6788:   }
 6788: }
 6788: 
38295: void
38295: nsSVGAngle::SetAnimValue(float aValue, PRUint8 aUnit, nsSVGElement *aSVGElement)
38295: {
38295:   mAnimVal = aValue;
38295:   mAnimValUnit = aUnit;
80486:   mIsAnimated = true;
38295:   aSVGElement->DidAnimateAngle(mAttrEnum);
38295: }
38295: 
 6788: nsresult
 6788: nsSVGAngle::ToDOMAnimatedAngle(nsIDOMSVGAnimatedAngle **aResult,
 6788:                                nsSVGElement *aSVGElement)
 6788: {
 6788:   *aResult = new DOMAnimatedAngle(this, aSVGElement);
 6788:   if (!*aResult)
 6788:     return NS_ERROR_OUT_OF_MEMORY;
 6788: 
 6788:   NS_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
 6788: nsresult
 6788: NS_NewDOMSVGAngle(nsIDOMSVGAngle** aResult)
 6788: {
 6788:   *aResult = new DOMSVGAngle;
 6788:   if (!*aResult)
 6788:     return NS_ERROR_OUT_OF_MEMORY;
 6665: 
 6788:   NS_ADDREF(*aResult);
 6788:   return NS_OK;
    1: }
38295: 
38295: nsISMILAttr*
38295: nsSVGAngle::ToSMILAttr(nsSVGElement *aSVGElement)
38295: {
38295:   if (aSVGElement->NodeInfo()->Equals(nsGkAtoms::marker, kNameSpaceID_SVG)) {
38295:     nsSVGMarkerElement *marker = static_cast<nsSVGMarkerElement*>(aSVGElement);
38295:     return new SMILOrient(marker->GetOrientType(), this, aSVGElement);
38295:   }
38295:   // SMILOrient would not be useful for general angle attributes (also,
38295:   // "orient" is the only animatable <angle>-valued attribute in SVG 1.1).
38295:   NS_NOTREACHED("Trying to animate unknown angle attribute.");
38295:   return nsnull;
38295: }
38295: 
38295: nsresult
38295: nsSVGAngle::SMILOrient::ValueFromString(const nsAString& aStr,
38295:                                         const nsISMILAnimationElement* /*aSrcElement*/,
38352:                                         nsSMILValue& aValue,
79445:                                         bool& aPreventCachingOfSandwich) const
38295: {
38295:   nsSMILValue val(&SVGOrientSMILType::sSingleton);
38295:   if (aStr.EqualsLiteral("auto")) {
38295:     val.mU.mOrient.mOrientType = nsIDOMSVGMarkerElement::SVG_MARKER_ORIENT_AUTO;
38295:   } else {
38295:     float value;
38295:     PRUint16 unitType;
38295:     nsresult rv = GetValueFromString(aStr, &value, &unitType);
38295:     if (NS_FAILED(rv)) {
38295:       return rv;
38295:     }
38295:     val.mU.mOrient.mAngle = value;
38295:     val.mU.mOrient.mUnit = unitType;
38295:     val.mU.mOrient.mOrientType = nsIDOMSVGMarkerElement::SVG_MARKER_ORIENT_ANGLE;
38295:   }
39881:   aValue.Swap(val);
80486:   aPreventCachingOfSandwich = false;
38295: 
38295:   return NS_OK;
38295: }
38295: 
38295: nsSMILValue
38295: nsSVGAngle::SMILOrient::GetBaseValue() const
38295: {
38295:   nsSMILValue val(&SVGOrientSMILType::sSingleton);
38295:   val.mU.mOrient.mAngle = mAngle->GetBaseValInSpecifiedUnits();
38295:   val.mU.mOrient.mUnit = mAngle->GetBaseValueUnit();
38295:   val.mU.mOrient.mOrientType = mOrientType->GetBaseValue();
38295:   return val;
38295: }
38295: 
38295: void
38295: nsSVGAngle::SMILOrient::ClearAnimValue()
38295: {
38295:   if (mAngle->mIsAnimated) {
38295:     mOrientType->SetAnimValue(mOrientType->GetBaseValue());
80486:     mAngle->mIsAnimated = false;
91474:     mAngle->mAnimVal = mAngle->mBaseVal;
91474:     mAngle->mAnimValUnit = mAngle->mBaseValUnit;
91474:     mSVGElement->DidAnimateAngle(mAngle->mAttrEnum);
38295:   }
38295: }
38295: 
38295: nsresult
38295: nsSVGAngle::SMILOrient::SetAnimValue(const nsSMILValue& aValue)
38295: {
38295:   NS_ASSERTION(aValue.mType == &SVGOrientSMILType::sSingleton,
38295:                "Unexpected type to assign animated value");
38295: 
38295:   if (aValue.mType == &SVGOrientSMILType::sSingleton) {
38295:     mOrientType->SetAnimValue(aValue.mU.mOrient.mOrientType);
38295:     if (aValue.mU.mOrient.mOrientType == nsIDOMSVGMarkerElement::SVG_MARKER_ORIENT_AUTO) {
38295:       mAngle->SetAnimValue(0.0f, nsIDOMSVGAngle::SVG_ANGLETYPE_UNSPECIFIED, mSVGElement);
38295:     } else {
38295:       mAngle->SetAnimValue(aValue.mU.mOrient.mAngle, aValue.mU.mOrient.mUnit, mSVGElement);
38295:     }
38295:   }
38295:   return NS_OK;
38295: }
