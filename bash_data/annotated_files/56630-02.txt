38166: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
38166:  * vim: sw=2 ts=2 et lcs=trail\:.,tab\:>~ :
38166:  * ***** BEGIN LICENSE BLOCK *****
38166:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
38166:  *
38166:  * The contents of this file are subject to the Mozilla Public License Version
38166:  * 1.1 (the "License"); you may not use this file except in compliance with
38166:  * the License. You may obtain a copy of the License at
38166:  * http://www.mozilla.org/MPL/
38166:  *
38166:  * Software distributed under the License is distributed on an "AS IS" basis,
38166:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
38166:  * for the specific language governing rights and limitations under the
38166:  * License.
38166:  *
38166:  * The Original Code is places test code.
38166:  *
38166:  * The Initial Developer of the Original Code is
38166:  * Mozilla Foundation.
38166:  * Portions created by the Initial Developer are Copyright (C) 2009
38166:  * the Initial Developer. All Rights Reserved.
38166:  *
38166:  * Contributor(s):
38166:  *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
38166:  *
38166:  * Alternatively, the contents of this file may be used under the terms of
38166:  * either the GNU General Public License Version 2 or later (the "GPL"), or
38166:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
38166:  * in which case the provisions of the GPL or the LGPL are applicable instead
38166:  * of those above. If you wish to allow use of your version of this file only
38166:  * under the terms of either the GPL or the LGPL, and not to allow others to
38166:  * use your version of this file under the terms of the MPL, indicate your
38166:  * decision by deleting the provisions above and replace them with the notice
38166:  * and other provisions required by the GPL or the LGPL. If you do not delete
38166:  * the provisions above, a recipient may use your version of this file under
38166:  * the terms of any one of the MPL, the GPL or the LGPL.
38166:  *
38166:  * ***** END LICENSE BLOCK ***** */
38166: 
38166: #include "places_test_harness.h"
47715: #include "nsIBrowserHistory.h"
38166: 
38166: #include "mock_Link.h"
38166: using namespace mozilla::dom;
38166: 
38166: /**
38166:  * This file tests the IHistory interface.
38166:  */
38166: 
38166: ////////////////////////////////////////////////////////////////////////////////
38166: //// Helper Methods
38166: 
38166: void
38166: expect_visit(nsLinkState aState)
38166: {
38166:   do_check_true(aState == eLinkState_Visited);
38166: }
38166: 
38166: void
38166: expect_no_visit(nsLinkState aState)
38166: {
38166:   do_check_true(aState == eLinkState_Unvisited);
38166: }
38166: 
38166: already_AddRefed<nsIURI>
38166: new_test_uri()
38166: {
38166:   // Create a unique spec.
38166:   static PRInt32 specNumber = 0;
38166:   nsCAutoString spec = NS_LITERAL_CSTRING("http://mozilla.org/");
38166:   spec.AppendInt(specNumber++);
38166: 
38166:   // Create the URI for the spec.
38166:   nsCOMPtr<nsIURI> testURI;
38166:   nsresult rv = NS_NewURI(getter_AddRefs(testURI), spec);
38166:   do_check_success(rv);
38166:   return testURI.forget();
38166: }
38166: 
47715: class VisitURIObserver : public nsIObserver
47715: {
47715: public:
47715:   NS_DECL_ISUPPORTS
47715: 
47715:   VisitURIObserver(int aExpectedVisits = 1) :
47715:     mVisits(0),
47715:     mExpectedVisits(aExpectedVisits)
47715:   {
47715:     nsCOMPtr<nsIObserverService> observerService =
47715:       do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
47715:     do_check_true(observerService);
47715:     (void)observerService->AddObserver(this,
47715:                                        "uri-visit-saved",
47715:                                        PR_FALSE);
47715:   }
47715: 
47715:   void WaitForNotification()
47715:   {
47715:     while (mVisits < mExpectedVisits) {
47715:       (void)NS_ProcessNextEvent();
47715:     }
47715:   }
47715: 
47715:   NS_IMETHOD Observe(nsISupports* aSubject,
47715:                      const char* aTopic,
47715:                      const PRUnichar* aData)
47715:   {
47715:     mVisits++;
47715: 
47715:     if (mVisits == mExpectedVisits) {
47715:       nsCOMPtr<nsIObserverService> observerService =
47715:         do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
47715:       (void)observerService->RemoveObserver(this, "uri-visit-saved");
47715:     }
47715: 
47715:     return NS_OK;
47715:   }
47715: private:
47715:   int mVisits;
47715:   int mExpectedVisits;
47715: };
47715: NS_IMPL_ISUPPORTS1(
47715:   VisitURIObserver,
47715:   nsIObserver
47715: )
47715: 
38166: ////////////////////////////////////////////////////////////////////////////////
38166: //// Test Functions
38166: 
38166: // These variables are shared between part 1 and part 2 of the test.  Part 2
38166: // sets the nsCOMPtr's to nsnull, freeing the reference.
38166: namespace test_unvisited_does_not_notify {
38166:   nsCOMPtr<nsIURI> testURI;
38319:   nsCOMPtr<Link> testLink;
38166: }
38166: void
38166: test_unvisted_does_not_notify_part1()
38166: {
38166:   using namespace test_unvisited_does_not_notify;
38166: 
38166:   // This test is done in two parts.  The first part registers for a URI that
38166:   // should not be visited.  We then run another test that will also do a
38166:   // lookup and will be notified.  Since requests are answered in the order they
38166:   // are requested (at least as long as the same URI isn't asked for later), we
38166:   // will know that the Link was not notified.
38166: 
38166:   // First, we need a test URI.
38166:   testURI = new_test_uri();
38166: 
38166:   // Create our test Link.
38319:   testLink = new mock_Link(expect_no_visit);
38166: 
38166:   // Now, register our Link to be notified.
38166:   nsCOMPtr<IHistory> history(do_get_IHistory());
38319:   nsresult rv = history->RegisterVisitedCallback(testURI, testLink);
38166:   do_check_success(rv);
38166: 
38166:   // Run the next test.
38166:   run_next_test();
38166: }
38166: 
38166: void
38166: test_visited_notifies()
38166: {
38166:   // First, we add our test URI to history.
38166:   nsCOMPtr<nsIURI> testURI(new_test_uri());
38166:   addURI(testURI);
38166: 
38166:   // Create our test Link.  The callback function will release the reference we
38166:   // have on the Link.
38166:   Link* link = new mock_Link(expect_visit);
38166:   NS_ADDREF(link);
38166: 
38166:   // Now, register our Link to be notified.
38166:   nsCOMPtr<IHistory> history(do_get_IHistory());
38166:   nsresult rv = history->RegisterVisitedCallback(testURI, link);
38166:   do_check_success(rv);
38166:   // Note: test will continue upon notification.
38166: }
38166: 
38166: void
38166: test_unvisted_does_not_notify_part2()
38166: {
38166:   using namespace test_unvisited_does_not_notify;
38166: 
38166:   // We would have had a failure at this point had the content node been told it
38166:   // was visited.  Therefore, it is safe to unregister our content node.
38166:   nsCOMPtr<IHistory> history(do_get_IHistory());
38319:   nsresult rv = history->UnregisterVisitedCallback(testURI, testLink);
38166:   do_check_success(rv);
38166: 
38166:   // Clear the stored variables now.
38166:   testURI = nsnull;
38319:   testLink = nsnull;
38166: 
38166:   // Run the next test.
38166:   run_next_test();
38166: }
38166: 
38166: void
38166: test_same_uri_notifies_both()
38166: {
38166:   // First, we add our test URI to history.
38166:   nsCOMPtr<nsIURI> testURI(new_test_uri());
38166:   addURI(testURI);
38166: 
38166:   // Create our two test Links.  The callback function will release the
38166:   // reference we have on the Links.  Only the second Link should run the next
38166:   // test!
38166:   Link* link1 = new mock_Link(expect_visit, false);
38166:   NS_ADDREF(link1);
38166:   Link* link2 = new mock_Link(expect_visit);
38166:   NS_ADDREF(link2);
38166: 
38166:   // Now, register our Link to be notified.
38166:   nsCOMPtr<IHistory> history(do_get_IHistory());
38166:   nsresult rv = history->RegisterVisitedCallback(testURI, link1);
38166:   do_check_success(rv);
38166:   rv = history->RegisterVisitedCallback(testURI, link2);
38166:   do_check_success(rv);
38166: 
38166:   // Note: test will continue upon notification.
38166: }
38166: 
38166: void
38166: test_unregistered_visited_does_not_notify()
38166: {
38166:   // This test must have a test that has a successful notification after it.
38166:   // The Link would have been notified by now if we were buggy and notified
38166:   // unregistered Links (due to request serialization).
38166: 
38166:   nsCOMPtr<nsIURI> testURI(new_test_uri());
38166:   nsCOMPtr<Link> link(new mock_Link(expect_no_visit));
38166: 
38166:   // Now, register our Link to be notified.
38166:   nsCOMPtr<IHistory> history(do_get_IHistory());
38166:   nsresult rv = history->RegisterVisitedCallback(testURI, link);
38166:   do_check_success(rv);
38166: 
38166:   // Unregister the Link.
38166:   rv = history->UnregisterVisitedCallback(testURI, link);
38166:   do_check_success(rv);
38166: 
38166:   // And finally add a visit for the URI.
38166:   addURI(testURI);
38166: 
38166:   // If history tries to notify us, we'll either crash because the Link will
38166:   // have been deleted (we are the only thing holding a reference to it), or our
38166:   // expect_no_visit call back will produce a failure.  Either way, the test
38166:   // will be reported as a failure.
38166: 
38166:   // Run the next test.
38166:   run_next_test();
38166: }
38166: 
38166: void
38166: test_new_visit_notifies_waiting_Link()
38166: {
38166:   // Create our test Link.  The callback function will release the reference we
38166:   // have on the link.
38166:   Link* link = new mock_Link(expect_visit);
38166:   NS_ADDREF(link);
38166: 
38166:   // Now, register our content node to be notified.
38166:   nsCOMPtr<nsIURI> testURI(new_test_uri());
38166:   nsCOMPtr<IHistory> history(do_get_IHistory());
38166:   nsresult rv = history->RegisterVisitedCallback(testURI, link);
38166:   do_check_success(rv);
38166: 
38166:   // Add ourselves to history.
38166:   addURI(testURI);
38166: 
38166:   // Note: test will continue upon notification.
38166: }
38166: 
38166: void
38166: test_RegisterVisitedCallback_returns_before_notifying()
38166: {
38166:   // Add a URI so that it's already in history.
38166:   nsCOMPtr<nsIURI> testURI(new_test_uri());
38166:   addURI(testURI);
38166: 
38166:   // Create our test Link.
38166:   nsCOMPtr<Link> link(new mock_Link(expect_no_visit));
38166: 
38166:   // Now, register our content node to be notified.  It should not be notified.
38166:   nsCOMPtr<IHistory> history(do_get_IHistory());
38166:   nsresult rv = history->RegisterVisitedCallback(testURI, link);
38166:   do_check_success(rv);
38166: 
38166:   // Remove ourselves as an observer.  We would have failed if we had been
38166:   // notified.
38166:   rv = history->UnregisterVisitedCallback(testURI, link);
38166:   do_check_success(rv);
38166: 
38166:   run_next_test();
38166: }
38166: 
38477: namespace test_observer_topic_dispatched_helpers {
38477:   #define URI_VISITED "visited"
38477:   #define URI_NOT_VISITED "not visited"
38477:   #define URI_VISITED_RESOLUTION_TOPIC "visited-status-resolution"
38477:   class statusObserver : public nsIObserver
38477:   {
38477:   public:
38477:     NS_DECL_ISUPPORTS
38477: 
38477:     statusObserver(nsIURI* aURI,
38477:                    const bool aExpectVisit,
38477:                    bool& _notified)
38477:     : mURI(aURI)
38477:     , mExpectVisit(aExpectVisit)
38477:     , mNotified(_notified)
38477:     {
38477:       nsCOMPtr<nsIObserverService> observerService =
38477:         do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
38477:       do_check_true(observerService);
38477:       (void)observerService->AddObserver(this,
38477:                                          URI_VISITED_RESOLUTION_TOPIC,
38477:                                          PR_FALSE);
38477:     }
38477: 
38477:     NS_IMETHOD Observe(nsISupports* aSubject,
38477:                        const char* aTopic,
38477:                        const PRUnichar* aData)
38477:     {
38477:       // Make sure we got notified of the right topic.
38477:       do_check_false(strcmp(aTopic, URI_VISITED_RESOLUTION_TOPIC));
38477: 
38477:       // If this isn't for our URI, do not do anything.
38477:       nsCOMPtr<nsIURI> notifiedURI(do_QueryInterface(aSubject));
38477:       do_check_true(notifiedURI);
38477:       PRBool isOurURI;
38477:       nsresult rv = notifiedURI->Equals(mURI, &isOurURI);
38477:       do_check_success(rv);
38477:       if (!isOurURI) {
38477:         return NS_OK;
38477:       }
38477: 
38477:       // Check that we have either the visited or not visited string.
38477:       bool visited = !!NS_LITERAL_STRING(URI_VISITED).Equals(aData);
38477:       bool notVisited = !!NS_LITERAL_STRING(URI_NOT_VISITED).Equals(aData);
38477:       do_check_true(visited || notVisited);
38477: 
38477:       // Check to make sure we got the state we expected.
38477:       do_check_eq(mExpectVisit, visited);
38477: 
38477:       // Indicate that we've been notified.
38477:       mNotified = true;
38477: 
38477:       // Remove ourselves as an observer.
38477:       nsCOMPtr<nsIObserverService> observerService =
38477:         do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
38477:       (void)observerService->RemoveObserver(this,
38477:                                             URI_VISITED_RESOLUTION_TOPIC);
38477:       return NS_OK;
38477:     }
38477:   private:
38477:     nsCOMPtr<nsIURI> mURI;
38477:     const bool mExpectVisit;
38477:     bool& mNotified;
38477:   };
38477:   NS_IMPL_ISUPPORTS1(
38477:     statusObserver,
38477:     nsIObserver
38477:   )
38477: }
38477: void
38477: test_observer_topic_dispatched()
38477: {
38477:   using namespace test_observer_topic_dispatched_helpers;
38477: 
38477:   // Create two URIs, making sure only one is in history.
38477:   nsCOMPtr<nsIURI> visitedURI(new_test_uri());
38477:   nsCOMPtr<nsIURI> notVisitedURI(new_test_uri());
38477:   PRBool urisEqual;
38477:   nsresult rv = visitedURI->Equals(notVisitedURI, &urisEqual);
38477:   do_check_success(rv);
38477:   do_check_false(urisEqual);
38477:   addURI(visitedURI);
38477: 
38477:   // Need two Link objects as well - one for each URI.
38477:   nsCOMPtr<Link> visitedLink(new mock_Link(expect_visit, false));
38477:   NS_ADDREF(visitedLink); // It will release itself when notified.
38477:   nsCOMPtr<Link> notVisitedLink(new mock_Link(expect_no_visit));
38477: 
38477:   // Add the right observers for the URIs to check results.
38477:   bool visitedNotified = false;
38477:   nsCOMPtr<nsIObserver> vistedObs =
38477:     new statusObserver(visitedURI, true, visitedNotified);
38477:   bool notVisitedNotified = false;
38477:   nsCOMPtr<nsIObserver> unvistedObs =
38477:     new statusObserver(notVisitedURI, false, notVisitedNotified);
38477: 
38477:   // Register our Links to be notified.
38477:   nsCOMPtr<IHistory> history(do_get_IHistory());
38477:   rv = history->RegisterVisitedCallback(visitedURI, visitedLink);
38477:   do_check_success(rv);
38477:   rv = history->RegisterVisitedCallback(notVisitedURI, notVisitedLink);
38477:   do_check_success(rv);
38477: 
38477:   // Spin the event loop as long as we have not been properly notified.
38477:   while (!visitedNotified || !notVisitedNotified) {
38477:     (void)NS_ProcessNextEvent();
38477:   }
38477: 
38477:   // Unregister our observer that would not have been released.
38477:   rv = history->UnregisterVisitedCallback(notVisitedURI, notVisitedLink);
38477:   do_check_success(rv);
38477: 
38477:   run_next_test();
38477: }
38477: 
47715: void
47715: test_visituri_inserts()
47715: {
47715:   nsCOMPtr<IHistory> history(do_get_IHistory());
47715:   nsCOMPtr<nsIURI> lastURI(new_test_uri());
47715:   nsCOMPtr<nsIURI> visitedURI(new_test_uri());
47715: 
47715:   history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL);
47715: 
47715:   nsCOMPtr<VisitURIObserver> finisher = new VisitURIObserver();
47715:   finisher->WaitForNotification();
47715: 
47715:   PlaceRecord place;
47715:   do_get_place(visitedURI, place);
47715: 
47715:   do_check_true(place.id > 0);
47715:   do_check_false(place.hidden);
47715:   do_check_false(place.typed);
47715:   do_check_true(place.visitCount == 1);
47715: 
47715:   run_next_test();
47715: }
47715: 
47715: void
47715: test_visituri_updates()
47715: {
47715:   nsCOMPtr<IHistory> history(do_get_IHistory());
47715:   nsCOMPtr<nsIURI> lastURI(new_test_uri());
47715:   nsCOMPtr<nsIURI> visitedURI(new_test_uri());
47715:   nsCOMPtr<VisitURIObserver> finisher;
47715: 
47715:   history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL);
47715:   finisher = new VisitURIObserver();
47715:   finisher->WaitForNotification();
47715: 
47715:   history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL);
47715:   finisher = new VisitURIObserver();
47715:   finisher->WaitForNotification();
47715: 
47715:   PlaceRecord place;
47715:   do_get_place(visitedURI, place);
47715: 
47715:   do_check_true(place.visitCount == 2);
47715: 
47715:   run_next_test();
47715: }
47715: 
47715: void
47715: test_visituri_preserves_shown_and_typed()
47715: {
47715:   nsCOMPtr<IHistory> history(do_get_IHistory());
47715:   nsCOMPtr<nsIURI> lastURI(new_test_uri());
47715:   nsCOMPtr<nsIURI> visitedURI(new_test_uri());
47715: 
47715:   history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL);
47715:   // this simulates the uri visit happening in a frame.  Normally frame
47715:   // transitions would be hidden unless it was previously loaded top-level
47715:   history->VisitURI(visitedURI, lastURI, 0);
47715: 
47715:   nsCOMPtr<VisitURIObserver> finisher = new VisitURIObserver(2);
47715:   finisher->WaitForNotification();
47715: 
47715:   PlaceRecord place;
47715:   do_get_place(visitedURI, place);
47715:   do_check_false(place.hidden);
47715: 
47715:   run_next_test();
47715: }
47715: 
47715: void
47715: test_visituri_creates_visit()
47715: {
47715:   nsCOMPtr<IHistory> history(do_get_IHistory());
47715:   nsCOMPtr<nsIURI> lastURI(new_test_uri());
47715:   nsCOMPtr<nsIURI> visitedURI(new_test_uri());
47715: 
47715:   history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL);
47715:   nsCOMPtr<VisitURIObserver> finisher = new VisitURIObserver();
47715:   finisher->WaitForNotification();
47715: 
47715:   PlaceRecord place;
47715:   VisitRecord visit;
47715:   do_get_place(visitedURI, place);
47715:   do_get_lastVisit(place.id, visit);
47715: 
47715:   do_check_true(visit.id > 0);
47715:   do_check_true(visit.lastVisitId == 0);
47715:   do_check_true(visit.transitionType == nsINavHistoryService::TRANSITION_LINK);
47715: 
47715:   run_next_test();
47715: }
47715: 
47715: void
47715: test_visituri_transition_typed()
47715: {
47715:   nsCOMPtr<nsINavHistoryService> navHistory = do_get_NavHistory();
47715:   nsCOMPtr<nsIBrowserHistory> browserHistory = do_QueryInterface(navHistory);
47715:   nsCOMPtr<IHistory> history(do_get_IHistory());
47715:   nsCOMPtr<nsIURI> lastURI(new_test_uri());
47715:   nsCOMPtr<nsIURI> visitedURI(new_test_uri());
47715: 
47715:   browserHistory->MarkPageAsTyped(visitedURI);
47715:   history->VisitURI(visitedURI, lastURI, mozilla::IHistory::TOP_LEVEL);
47715:   nsCOMPtr<VisitURIObserver> finisher = new VisitURIObserver();
47715:   finisher->WaitForNotification();
47715: 
47715:   PlaceRecord place;
47715:   VisitRecord visit;
47715:   do_get_place(visitedURI, place);
47715:   do_get_lastVisit(place.id, visit);
47715: 
47715:   do_check_true(visit.transitionType == nsINavHistoryService::TRANSITION_TYPED);
47715: 
47715:   run_next_test();
47715: }
47715: 
47715: void
47715: test_visituri_transition_embed()
47715: {
47715:   nsCOMPtr<nsINavHistoryService> navHistory = do_get_NavHistory();
47715:   nsCOMPtr<nsIBrowserHistory> browserHistory = do_QueryInterface(navHistory);
47715:   nsCOMPtr<IHistory> history(do_get_IHistory());
47715:   nsCOMPtr<nsIURI> lastURI(new_test_uri());
47715:   nsCOMPtr<nsIURI> visitedURI(new_test_uri());
47715: 
47715:   history->VisitURI(visitedURI, lastURI, 0);
47715:   nsCOMPtr<VisitURIObserver> finisher = new VisitURIObserver();
47715:   finisher->WaitForNotification();
47715: 
47715:   PlaceRecord place;
47715:   VisitRecord visit;
47715:   do_get_place(visitedURI, place);
47715:   do_get_lastVisit(place.id, visit);
47715: 
47715:   do_check_true(visit.transitionType == nsINavHistoryService::TRANSITION_EMBED);
47715: 
47715:   run_next_test();
47715: }
47715: 
38166: ////////////////////////////////////////////////////////////////////////////////
56630: //// IPC-only Tests
56630: 
56630: #ifdef MOZ_IPC
56630: void
56630: test_two_null_links_same_uri()
56630: {
56630:   // Tests that we do not crash when we have had two NULL Links passed to
56630:   // RegisterVisitedCallback and then the visit occurs (bug 607469).  This only
56630:   // happens in IPC builds.
56630:   nsCOMPtr<nsIURI> testURI(new_test_uri());
56630: 
56630:   nsCOMPtr<IHistory> history(do_get_IHistory());
56630:   nsresult rv = history->RegisterVisitedCallback(testURI, NULL);
56630:   do_check_success(rv);
56630:   rv = history->RegisterVisitedCallback(testURI, NULL);
56630:   do_check_success(rv);
56630: 
56630:   rv = history->VisitURI(testURI, NULL, mozilla::IHistory::TOP_LEVEL);
56630:   do_check_success(rv);
56630: 
56630:   nsCOMPtr<VisitURIObserver> finisher = new VisitURIObserver();
56630:   finisher->WaitForNotification();
56630: 
56630:   run_next_test();
56630: }
56630: #endif // MOZ_IPC
56630: 
56630: ////////////////////////////////////////////////////////////////////////////////
38166: //// Test Harness
38166: 
38166: /**
38166:  * Note: for tests marked "Order Important!", please see the test for details.
38166:  */
38166: Test gTests[] = {
38166:   TEST(test_unvisted_does_not_notify_part1), // Order Important!
38166:   TEST(test_visited_notifies),
38166:   TEST(test_unvisted_does_not_notify_part2), // Order Important!
38166:   TEST(test_same_uri_notifies_both),
38166:   TEST(test_unregistered_visited_does_not_notify), // Order Important!
38166:   TEST(test_new_visit_notifies_waiting_Link),
38166:   TEST(test_RegisterVisitedCallback_returns_before_notifying),
38477:   TEST(test_observer_topic_dispatched),
47715:   TEST(test_visituri_inserts),
47715:   TEST(test_visituri_updates),
47715:   TEST(test_visituri_preserves_shown_and_typed),
47715:   TEST(test_visituri_creates_visit),
47715:   TEST(test_visituri_transition_typed),
47715:   TEST(test_visituri_transition_embed),
56630: 
56630:   // The rest of these tests are tests that are only run in IPC builds.
56630: #ifdef MOZ_IPC
56630:   TEST(test_two_null_links_same_uri),
56630: #endif // MOZ_IPC
38166: };
38166: 
38166: const char* file = __FILE__;
38166: #define TEST_NAME "IHistory"
38166: #define TEST_FILE file
38166: #include "places_test_harness_tail.h"
