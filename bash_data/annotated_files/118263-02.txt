     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: #ifndef nsBaseWidget_h__
     1: #define nsBaseWidget_h__
     1: 
106317: #include "mozilla/WidgetUtils.h"
     1: #include "nsRect.h"
     1: #include "nsIWidget.h"
 51049: #include "nsWidgetsCID.h"
101111: #include "nsIFile.h"
     1: #include "nsString.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsGUIEvent.h"
 30515: #include "nsAutoPtr.h"
102762: #include "nsIRollupListener.h"
  8591: class nsIContent;
  8591: class nsAutoRollup;
 38805: class gfxContext;
  8591: 
108454: #ifdef ACCESSIBILITY
108454: class Accessible;
108454: #endif
108454: 
 87729: namespace mozilla {
 87729: namespace layers {
106914: class BasicLayerManager;
 87729: class CompositorChild;
 87729: class CompositorParent;
 87729: }
 87729: }
 87729: 
 87729: namespace base {
 87729: class Thread;
 87729: }
 87729: 
     1: /**
     1:  * Common widget implementation used as base class for native
     1:  * or crossplatform implementations of Widgets. 
     1:  * All cross-platform behavior that all widgets need to implement 
     1:  * should be placed in this class. 
     1:  * (Note: widget implementations are not required to use this
     1:  * class, but it gives them a head start.)
     1:  */
     1: 
 63893: class nsBaseWidget : public nsIWidget
     1: {
  8591:   friend class nsAutoRollup;
     1: 
 47746: protected:
106317:   typedef base::Thread Thread;
 47746:   typedef mozilla::layers::BasicLayerManager BasicLayerManager;
106914:   typedef mozilla::layers::BufferMode BufferMode;
 87729:   typedef mozilla::layers::CompositorChild CompositorChild;
 87729:   typedef mozilla::layers::CompositorParent CompositorParent;
106317:   typedef mozilla::ScreenRotation ScreenRotation;
 47746: 
     1: public:
     1:   nsBaseWidget();
     1:   virtual ~nsBaseWidget();
     1: 
     1:   NS_DECL_ISUPPORTS
     1: 
     1:   // nsIWidget interface
 79445:   NS_IMETHOD              CaptureMouse(bool aCapture);
108457:   virtual nsIWidgetListener*  GetWidgetListener();
108457:   virtual void            SetWidgetListener(nsIWidgetListener* alistener);
     1:   NS_IMETHOD              Destroy();
     1:   NS_IMETHOD              SetParent(nsIWidget* aNewParent);
     1:   virtual nsIWidget*      GetParent(void);
 31093:   virtual nsIWidget*      GetTopLevelWidget();
 14886:   virtual nsIWidget*      GetSheetWindowParent(void);
 50782:   virtual float           GetDPI();
 50782:   virtual double          GetDefaultScale();
     1:   virtual void            AddChild(nsIWidget* aChild);
     1:   virtual void            RemoveChild(nsIWidget* aChild);
     1: 
108991:   NS_IMETHOD              SetZIndex(int32_t aZIndex);
108991:   NS_IMETHOD              GetZIndex(int32_t* aZIndex);
     1:   NS_IMETHOD              PlaceBehind(nsTopLevelWidgetZPlacement aPlacement,
 79445:                                       nsIWidget *aWidget, bool aActivate);
     1: 
108991:   NS_IMETHOD              SetSizeMode(int32_t aMode);
108991:   NS_IMETHOD              GetSizeMode(int32_t* aMode);
     1: 
     1:   virtual nscolor         GetForegroundColor(void);
     1:   NS_IMETHOD              SetForegroundColor(const nscolor &aColor);
     1:   virtual nscolor         GetBackgroundColor(void);
     1:   NS_IMETHOD              SetBackgroundColor(const nscolor &aColor);
     1:   virtual nsCursor        GetCursor();
     1:   NS_IMETHOD              SetCursor(nsCursor aCursor);
     1:   NS_IMETHOD              SetCursor(imgIContainer* aCursor,
108991:                                     uint32_t aHotspotX, uint32_t aHotspotY);
     1:   NS_IMETHOD              GetWindowType(nsWindowType& aWindowType);
 16601:   virtual void            SetTransparencyMode(nsTransparencyMode aMode);
 16601:   virtual nsTransparencyMode GetTransparencyMode();
 30515:   virtual void            GetWindowClipRegion(nsTArray<nsIntRect>* aRects);
108991:   NS_IMETHOD              SetWindowShadowStyle(int32_t aStyle);
 79445:   virtual void            SetShowsToolbarButton(bool aShow) {}
 93633:   virtual void            SetShowsFullScreenButton(bool aShow) {}
 90340:   virtual void            SetWindowAnimationType(WindowAnimationType aType) {}
 79445:   NS_IMETHOD              HideWindowChrome(bool aShouldHide);
 79445:   NS_IMETHOD              MakeFullScreen(bool aFullScreen);
 68668:   virtual nsDeviceContext* GetDeviceContext();
106838:   virtual LayerManager*   GetLayerManager(PLayersChild* aShadowManager = nullptr,
105710:                                           LayersBackend aBackendHint = mozilla::layers::LAYERS_NONE,
 75149:                                           LayerManagerPersistence aPersistence = LAYER_MANAGER_CURRENT,
106838:                                           bool* aAllowRetaining = nullptr);
 63893: 
 87729:   virtual void            CreateCompositor();
 92853:   virtual void            DrawWindowUnderlay(LayerManager* aManager, nsIntRect aRect) {}
 87886:   virtual void            DrawWindowOverlay(LayerManager* aManager, nsIntRect aRect) {}
 60289:   virtual void            UpdateThemeGeometries(const nsTArray<ThemeGeometry>& aThemeGeometries) {}
     1:   virtual gfxASurface*    GetThebesSurface();
 79445:   NS_IMETHOD              SetModal(bool aModal); 
     1:   NS_IMETHOD              SetWindowClass(const nsAString& xulWinType);
108991:   NS_IMETHOD              MoveClient(int32_t aX, int32_t aY);
108991:   NS_IMETHOD              ResizeClient(int32_t aWidth, int32_t aHeight, bool aRepaint);
108991:   NS_IMETHOD              ResizeClient(int32_t aX, int32_t aY, int32_t aWidth, int32_t aHeight, bool aRepaint);
 23738:   NS_IMETHOD              SetBounds(const nsIntRect &aRect);
 23738:   NS_IMETHOD              GetBounds(nsIntRect &aRect);
 23738:   NS_IMETHOD              GetClientBounds(nsIntRect &aRect);
 23738:   NS_IMETHOD              GetScreenBounds(nsIntRect &aRect);
 83107:   NS_IMETHOD              GetNonClientMargins(nsIntMargin &margins);
 83107:   NS_IMETHOD              SetNonClientMargins(nsIntMargin &margins);
 48256:   virtual nsIntPoint      GetClientOffset();
 79445:   NS_IMETHOD              EnableDragDrop(bool aEnable);
108991:   NS_IMETHOD              GetAttention(int32_t aCycleCount);
 79445:   virtual bool            HasPendingInputEvent();
     1:   NS_IMETHOD              SetIcon(const nsAString &anIconSpec);
  6348:   NS_IMETHOD              BeginSecureKeyboardInput();
  6348:   NS_IMETHOD              EndSecureKeyboardInput();
 79445:   NS_IMETHOD              SetWindowTitlebarColor(nscolor aColor, bool aActive);
 79445:   virtual void            SetDrawsInTitlebar(bool aState) {}
 79445:   virtual bool            ShowsResizeIndicator(nsIntRect* aResizerRect);
108991:   virtual void            FreeNativeData(void * data, uint32_t aDataType) {}
108991:   NS_IMETHOD              BeginResizeDrag(nsGUIEvent* aEvent, int32_t aHorizontal, int32_t aVertical);
 47857:   NS_IMETHOD              BeginMoveDrag(nsMouseEvent* aEvent);
 15578:   virtual nsresult        ActivateNativeMenuItemAt(const nsAString& indexString) { return NS_ERROR_NOT_IMPLEMENTED; }
 21081:   virtual nsresult        ForceUpdateNativeMenuAt(const nsAString& indexString) { return NS_ERROR_NOT_IMPLEMENTED; }
 24836:   NS_IMETHOD              ResetInputState() { return NS_OK; }
 24836:   NS_IMETHOD              CancelIMEComposition() { return NS_OK; }
 79445:   NS_IMETHOD              SetAcceleratedRendering(bool aEnabled);
 79445:   virtual bool            GetAcceleratedRendering();
 79445:   virtual bool            GetShouldAccelerate();
108991:   NS_IMETHOD              GetToggledKeyState(uint32_t aKeyCode, bool* aLEDState) { return NS_ERROR_NOT_IMPLEMENTED; }
 79445:   NS_IMETHOD              OnIMEFocusChange(bool aFocus) { return NS_ERROR_NOT_IMPLEMENTED; }
108991:   NS_IMETHOD              OnIMETextChange(uint32_t aStart, uint32_t aOldEnd, uint32_t aNewEnd) { return NS_ERROR_NOT_IMPLEMENTED; }
 24836:   NS_IMETHOD              OnIMESelectionChange(void) { return NS_ERROR_NOT_IMPLEMENTED; }
 80486:   virtual nsIMEUpdatePreference GetIMEUpdatePreference() { return nsIMEUpdatePreference(false, false); }
 30327:   NS_IMETHOD              OnDefaultButtonLoaded(const nsIntRect &aButtonRect) { return NS_ERROR_NOT_IMPLEMENTED; }
108991:   NS_IMETHOD              OverrideSystemMouseScrollSpeed(int32_t aOriginalDelta, bool aIsHorizontal, int32_t &aOverriddenDelta);
 51049:   virtual already_AddRefed<nsIWidget>
 51049:   CreateChild(const nsIntRect  &aRect,
 68668:               nsDeviceContext *aContext,
106838:               nsWidgetInitData *aInitData = nullptr,
 79445:               bool             aForceUseIWidgetParent = false);
108460:   NS_IMETHOD              AttachViewToTopLevel(bool aUseAttachedEvents, nsDeviceContext *aContext);
108461:   virtual nsIWidgetListener* GetAttachedWidgetListener();
108461:   virtual void               SetAttachedWidgetListener(nsIWidgetListener* aListener);
 48711:   NS_IMETHOD              RegisterTouchWindow();
 48711:   NS_IMETHOD              UnregisterTouchWindow();
     1: 
108456:   void NotifyWindowDestroyed();
108452:   void NotifySizeMoveDone();
108452: 
108452:   // Should be called by derived implementations to notify on system color and
108452:   // theme changes.
108452:   void NotifySysColorChanged();
108452:   void NotifyThemeChanged();
108455:   void NotifyUIStateChanged(UIStateChangeType aShowAccelerators,
108455:                             UIStateChangeType aShowFocusRings);
108452: 
108454: #ifdef ACCESSIBILITY
108454:   // Get the accessible for the window.
108454:   Accessible* GetAccessible();
108454: #endif
108454: 
 48254:   nsPopupLevel PopupLevel() { return mPopupLevel; }
 48254: 
 48256:   virtual nsIntSize       ClientToWindowSize(const nsIntSize& aClientSize)
 48256:   {
 48256:     return aClientSize;
 48256:   }
 48256: 
 48256:   // return true if this is a popup widget with a native titlebar
 79445:   bool IsPopupWithTitleBar() const
 48256:   {
 48256:     return (mWindowType == eWindowType_popup && 
 48256:             mBorderStyle != eBorderStyle_default &&
 48256:             mBorderStyle & eBorderStyle_title);
 48256:   }
 48256: 
 54312:   NS_IMETHOD              ReparentNativeWidget(nsIWidget* aNewParent) = 0;
 88239: 
108991:   virtual uint32_t GetGLFrameBufferFormat() MOZ_OVERRIDE;
 88239: 
106923:   virtual const SizeConstraints& GetSizeConstraints() const;
106923:   virtual void SetSizeConstraints(const SizeConstraints& aConstraints);
106923: 
 38805:   /**
 38805:    * Use this when GetLayerManager() returns a BasicLayerManager
 38805:    * (nsBaseWidget::GetLayerManager() does). This sets up the widget's
 38805:    * layer manager to temporarily render into aTarget.
106317:    *
106317:    * |aNaturalWidgetBounds| is the un-rotated bounds of |aWidget|.
106317:    * |aRotation| is the "virtual rotation" to apply when rendering to
106317:    * the target.  When |aRotation| is ROTATION_0,
106317:    * |aNaturalWidgetBounds| is not used.
 38805:    */
 38805:   class AutoLayerManagerSetup {
 38805:   public:
 47746:     AutoLayerManagerSetup(nsBaseWidget* aWidget, gfxContext* aTarget,
106914:                           BufferMode aDoubleBuffering,
106317:                           ScreenRotation aRotation = mozilla::ROTATION_0);
 38805:     ~AutoLayerManagerSetup();
 38805:   private:
 38805:     nsBaseWidget* mWidget;
 38805:   };
 38805:   friend class AutoLayerManagerSetup;
 38805: 
 55858:   class AutoUseBasicLayerManager {
 55858:   public:
 55858:     AutoUseBasicLayerManager(nsBaseWidget* aWidget);
 55858:     ~AutoUseBasicLayerManager();
 55858:   private:
 55858:     nsBaseWidget* mWidget;
118263:     bool mPreviousTemporarilyUseBasicLayerManager;
 55858:   };
 55858:   friend class AutoUseBasicLayerManager;
 55858: 
 79445:   bool HasDestroyStarted() const 
 79413:   {
 79413:     return mOnDestroyCalled;
 79413:   }
 79413: 
 79445:   bool                    Destroyed() { return mOnDestroyCalled; }
 78623: 
 91626:   nsWindowType            GetWindowType() { return mWindowType; }
 91626: 
101913:   virtual bool            UseOffMainThreadCompositing();
     1: protected:
     1: 
     1:   virtual void            ResolveIconName(const nsAString &aIconName,
     1:                                           const nsAString &aIconSuffix,
101111:                                           nsIFile **aResult);
     1:   virtual void            OnDestroy();
     1:   virtual void            BaseCreate(nsIWidget *aParent,
 23738:                                      const nsIntRect &aRect,
 68668:                                      nsDeviceContext *aContext,
     1:                                      nsWidgetInitData *aInitData);
     1: 
  8591:   virtual nsIContent* GetLastRollup()
  8591:   {
  8591:     return mLastRollup;
  8591:   }
  8591: 
108991:   virtual nsresult SynthesizeNativeKeyEvent(int32_t aNativeKeyboardLayout,
108991:                                             int32_t aNativeKeyCode,
108991:                                             uint32_t aModifierFlags,
 14962:                                             const nsAString& aCharacters,
 14998:                                             const nsAString& aUnmodifiedCharacters)
 14998:   { return NS_ERROR_UNEXPECTED; }
 14962: 
 32976:   virtual nsresult SynthesizeNativeMouseEvent(nsIntPoint aPoint,
108991:                                               uint32_t aNativeMessage,
108991:                                               uint32_t aModifierFlags)
 32976:   { return NS_ERROR_UNEXPECTED; }
 32976: 
 95203:   virtual nsresult SynthesizeNativeMouseMove(nsIntPoint aPoint)
 95203:   { return NS_ERROR_UNEXPECTED; }
 95203: 
 93734:   virtual nsresult SynthesizeNativeMouseScrollEvent(nsIntPoint aPoint,
108991:                                                     uint32_t aNativeMessage,
 93734:                                                     double aDeltaX,
 93734:                                                     double aDeltaY,
 93734:                                                     double aDeltaZ,
108991:                                                     uint32_t aModifierFlags,
108991:                                                     uint32_t aAdditionalFlags)
 93734:   { return NS_ERROR_UNEXPECTED; }
 93734: 
 30688:   // Stores the clip rectangles in aRects into mClipRects. Returns true
 30688:   // if the new rectangles are different from the old rectangles.
 79445:   bool StoreWindowClipRegion(const nsTArray<nsIntRect>& aRects);
 30515: 
 51049:   virtual already_AddRefed<nsIWidget>
 51049:   AllocateChildPopupWidget()
 51049:   {
 51049:     static NS_DEFINE_IID(kCPopUpCID, NS_CHILD_CID);
 51049:     nsCOMPtr<nsIWidget> widget = do_CreateInstance(kCPopUpCID);
 51049:     return widget.forget();
 51049:   }
 51049: 
 54111:   BasicLayerManager* CreateBasicLayerManager();
 54111: 
102628:   nsPopupType PopupType() const { return mPopupType; }
102628: 
102762:   void NotifyRollupGeometryChange(nsIRollupListener* aRollupListener)
102762:   {
102762:     if (aRollupListener) {
102762:       aRollupListener->NotifyGeometryChange();
102762:     }
102762:   }
102762: 
106923:   /**
106923:    * Apply the current size constraints to the given size.
106923:    *
106923:    * @param aWidth width to constrain
106923:    * @param aHeight height to constrain
106923:    */
108991:   void ConstrainSize(int32_t* aWidth, int32_t* aHeight) const
106923:   {
106923:     *aWidth = NS_MAX(mSizeConstraints.mMinSize.width,
106923:                      NS_MIN(mSizeConstraints.mMaxSize.width, *aWidth));
106923:     *aHeight = NS_MAX(mSizeConstraints.mMinSize.height,
106923:                       NS_MIN(mSizeConstraints.mMaxSize.height, *aHeight));
106923:   }
106923: 
     1: protected:
 99223:   /**
 99223:    * Starts the OMTC compositor destruction sequence.
 99223:    *
 99223:    * When this function returns, the compositor should not be 
 99223:    * able to access the opengl context anymore.
 99223:    * It is safe to call it several times if platform implementations
 99223:    * require the compositor to be destroyed before ~nsBaseWidget is
 99223:    * reached (This is the case with gtk2 for instance).
 99223:    */
 99223:   void DestroyCompositor();
 99223: 
108457:   nsIWidgetListener* mWidgetListener;
108461:   nsIWidgetListener* mAttachedWidgetListener;
 68668:   nsDeviceContext* mContext;
 38805:   nsRefPtr<LayerManager> mLayerManager;
 55858:   nsRefPtr<LayerManager> mBasicLayerManager;
 87729:   nsRefPtr<CompositorChild> mCompositorChild;
 87729:   nsRefPtr<CompositorParent> mCompositorParent;
     1:   nscolor           mBackground;
     1:   nscolor           mForeground;
     1:   nsCursor          mCursor;
     1:   nsWindowType      mWindowType;
     1:   nsBorderStyle     mBorderStyle;
 79445:   bool              mOnDestroyCalled;
 79445:   bool              mUseAcceleratedRendering;
 91135:   bool              mForceLayersAcceleration;
 79445:   bool              mTemporarilyUseBasicLayerManager;
108460:   bool              mUseAttachedEvents;
 23738:   nsIntRect         mBounds;
 23738:   nsIntRect*        mOriginalBounds;
 30515:   // When this pointer is null, the widget is not clipped
 30515:   nsAutoArrayPtr<nsIntRect> mClipRects;
108991:   uint32_t          mClipRectCount;
108991:   int32_t           mZIndex;
     1:   nsSizeMode        mSizeMode;
 48254:   nsPopupLevel      mPopupLevel;
102628:   nsPopupType       mPopupType;
106923:   SizeConstraints   mSizeConstraints;
     1: 
  8591:   // the last rolled up popup. Only set this when an nsAutoRollup is in scope,
  8591:   // so it can be cleared automatically.
  8591:   static nsIContent* mLastRollup;
  8591: 
     1: #ifdef DEBUG
     1: protected:
     1:   static nsAutoString debug_GuiEventToString(nsGUIEvent * aGuiEvent);
 79445:   static bool debug_WantPaintFlashing();
     1: 
     1:   static void debug_DumpInvalidate(FILE *                aFileOut,
     1:                                    nsIWidget *           aWidget,
 23738:                                    const nsIntRect *     aRect,
     1:                                    const nsCAutoString & aWidgetName,
108991:                                    int32_t               aWindowID);
     1: 
     1:   static void debug_DumpEvent(FILE *                aFileOut,
     1:                               nsIWidget *           aWidget,
     1:                               nsGUIEvent *          aGuiEvent,
     1:                               const nsCAutoString & aWidgetName,
108991:                               int32_t               aWindowID);
     1: 
     1:   static void debug_DumpPaintEvent(FILE *                aFileOut,
     1:                                    nsIWidget *           aWidget,
108457:                                    const nsIntRegion &   aPaintEvent,
     1:                                    const nsCAutoString & aWidgetName,
108991:                                    int32_t               aWindowID);
     1: 
 79445:   static bool debug_GetCachedBoolPref(const char* aPrefName);
     1: #endif
     1: };
     1: 
  8591: // A situation can occur when a mouse event occurs over a menu label while the
  8591: // menu popup is already open. The expected behaviour is to close the popup.
  8591: // This happens by calling nsIRollupListener::Rollup before the mouse event is
  8591: // processed. However, in cases where the mouse event is not consumed, this
  8591: // event will then get targeted at the menu label causing the menu to open
  8591: // again. To prevent this, we store in mLastRollup a reference to the popup
  8591: // that was closed during the Rollup call, and prevent this popup from
  8591: // reopening while processing the mouse event.
  8591: // mLastRollup should only be set while an nsAutoRollup is in scope;
  8591: // when it goes out of scope mLastRollup is cleared automatically.
  8591: // As mLastRollup is static, it can be retrieved by calling
  8591: // nsIWidget::GetLastRollup on any widget.
  8591: class nsAutoRollup
  8591: {
 79445:   bool wasClear;
  8591: 
  8591:   public:
  8591: 
  8591:   nsAutoRollup();
  8591:   ~nsAutoRollup();
  8591: };
  8591: 
     1: #endif // nsBaseWidget_h__
