70160: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
70160: /* ***** BEGIN LICENSE BLOCK *****
70160:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
70160:  *
70160:  * The contents of this file are subject to the Mozilla Public License Version
70160:  * 1.1 (the "License"); you may not use this file except in compliance with
70160:  * the License. You may obtain a copy of the License at
70160:  * http://www.mozilla.org/MPL/
70160:  *
70160:  * Software distributed under the License is distributed on an "AS IS" basis,
70160:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
70160:  * for the specific language governing rights and limitations under the
70160:  * License.
70160:  *
70160:  * The Original Code is Mozilla File API.
70160:  *
70160:  * The Initial Developer of the Original Code is
70160:  *   Kyle Huey <me@kylehuey.com>
70160:  * Portions created by the Initial Developer are Copyright (C) 2011
70160:  * the Initial Developer. All Rights Reserved.
70160:  *
70160:  * Contributor(s):
70160:  *
70160:  * Alternatively, the contents of this file may be used under the terms of
70160:  * either the GNU General Public License Version 2 or later (the "GPL"), or
70160:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
70160:  * in which case the provisions of the GPL or the LGPL are applicable instead
70160:  * of those above. If you wish to allow use of your version of this file only
70160:  * under the terms of either the GPL or the LGPL, and not to allow others to
70160:  * use your version of this file under the terms of the MPL, indicate your
70160:  * decision by deleting the provisions above and replace them with the notice
70160:  * and other provisions required by the GPL or the LGPL. If you do not delete
70160:  * the provisions above, a recipient may use your version of this file under
70160:  * the terms of any one of the MPL, the GPL or the LGPL.
70160:  *
70160:  * ***** END LICENSE BLOCK ***** */
70160: 
70160: #include "jstypedarray.h"
70160: #include "nsAutoPtr.h"
80058: #include "nsDOMClassInfoID.h"
70160: #include "nsDOMFile.h"
70160: #include "nsIMultiplexInputStream.h"
70160: #include "nsStringStream.h"
70160: #include "nsTArray.h"
70160: #include "nsJSUtils.h"
70160: #include "nsContentUtils.h"
70160: #include "CheckedInt.h"
70160: 
70160: // XXXkhuey shamelessly stolen from VideoUtils.h.  We should patch NSPR.
70160: #define PR_INT64_MAX (~((PRInt64)(1) << 63))
70160: #define PR_INT64_MIN (-PR_INT64_MAX - 1)
70160: 
70160: using namespace mozilla;
70160: 
73694: class nsDOMMultipartFile : public nsDOMFileBase
70160: {
70160: public:
73694:   // Create as a file
73694:   nsDOMMultipartFile(nsTArray<nsCOMPtr<nsIDOMBlob> > aBlobs,
73694:                      const nsAString& aName,
73694:                      const nsAString& aContentType)
73694:     : nsDOMFileBase(aName, aContentType, PR_UINT64_MAX),
73694:       mBlobs(aBlobs)
73694:   {
73694:   }
73694: 
73691:   // Create as a blob
73694:   nsDOMMultipartFile(nsTArray<nsCOMPtr<nsIDOMBlob> > aBlobs,
70160:                      const nsAString& aContentType)
73691:     : nsDOMFileBase(aContentType, PR_UINT64_MAX),
70160:       mBlobs(aBlobs)
70160:   {
70160:   }
70160: 
73691:   already_AddRefed<nsIDOMBlob>
73691:   CreateSlice(PRUint64 aStart, PRUint64 aLength, const nsAString& aContentType);
73691: 
70160:   NS_IMETHOD GetSize(PRUint64*);
70160:   NS_IMETHOD GetInternalStream(nsIInputStream**);
70160: 
70160: protected:
70160:   nsTArray<nsCOMPtr<nsIDOMBlob> > mBlobs;
70160: };
70160: 
70160: NS_IMETHODIMP
73694: nsDOMMultipartFile::GetSize(PRUint64* aLength)
70160: {
73691:   if (mLength == PR_UINT64_MAX) {
70160:     CheckedUint64 length = 0;
70160:   
70160:     PRUint32 i;
70160:     PRUint32 len = mBlobs.Length();
70160:     for (i = 0; i < len; i++) {
70160:       nsIDOMBlob* blob = mBlobs.ElementAt(i).get();
70160:       PRUint64 l = 0;
70160:   
73691:       nsresult rv = blob->GetSize(&l);
70160:       NS_ENSURE_SUCCESS(rv, rv);
70160:   
70160:       length += l;
70160:     }
70160:   
73691:     NS_ENSURE_TRUE(length.valid(), NS_ERROR_FAILURE);
70160: 
70160:     mLength = length.value();
73691:   }
73691: 
70160:   *aLength = mLength;
70160:   return NS_OK;
70160: }
70160: 
70160: NS_IMETHODIMP
73694: nsDOMMultipartFile::GetInternalStream(nsIInputStream** aStream)
70160: {
70160:   nsresult rv;
70160:   *aStream = nsnull;
70160: 
70160:   nsCOMPtr<nsIMultiplexInputStream> stream =
70160:     do_CreateInstance("@mozilla.org/io/multiplex-input-stream;1");
70160:   NS_ENSURE_TRUE(stream, NS_ERROR_FAILURE);
70160: 
70160:   PRUint32 i;
70160:   for (i = 0; i < mBlobs.Length(); i++) {
70160:     nsCOMPtr<nsIInputStream> scratchStream;
70160:     nsIDOMBlob* blob = mBlobs.ElementAt(i).get();
70160: 
70160:     rv = blob->GetInternalStream(getter_AddRefs(scratchStream));
70160:     NS_ENSURE_SUCCESS(rv, rv);
70160: 
70160:     rv = stream->AppendStream(scratchStream);
70160:     NS_ENSURE_SUCCESS(rv, rv);
70160:   }
70160: 
70160:   return CallQueryInterface(stream, aStream);
70160: }
70160: 
73691: already_AddRefed<nsIDOMBlob>
73694: nsDOMMultipartFile::CreateSlice(PRUint64 aStart, PRUint64 aLength,
73691:                                 const nsAString& aContentType)
70160: {
70160:   // If we clamped to nothing we create an empty blob
70160:   nsTArray<nsCOMPtr<nsIDOMBlob> > blobs;
70160: 
73691:   PRUint64 length = aLength;
70160:   PRUint64 skipStart = aStart;
70160: 
70160:   // Prune the list of blobs if we can
70160:   PRUint32 i;
70160:   for (i = 0; length && skipStart && i < mBlobs.Length(); i++) {
70160:     nsIDOMBlob* blob = mBlobs[i].get();
70160: 
70160:     PRUint64 l;
73691:     nsresult rv = blob->GetSize(&l);
73691:     NS_ENSURE_SUCCESS(rv, nsnull);
70160: 
70160:     if (skipStart < l) {
71170:       PRUint64 upperBound = NS_MIN<PRUint64>(l - skipStart, length);
70160: 
70160:       nsCOMPtr<nsIDOMBlob> firstBlob;
73691:       rv = blob->MozSlice(skipStart, skipStart + upperBound,
73693:                           aContentType, 3,
70160:                           getter_AddRefs(firstBlob));
73691:       NS_ENSURE_SUCCESS(rv, nsnull);
70160: 
73694:       // Avoid wrapping a single blob inside an nsDOMMultipartFile
70160:       if (length == upperBound) {
73691:         return firstBlob.forget();
70160:       }
70160: 
70160:       blobs.AppendElement(firstBlob);
70160:       length -= upperBound;
70160:       i++;
70160:       break;
70160:     }
70160:     skipStart -= l;
70160:   }
70160: 
70160:   // Now append enough blobs until we're done
70160:   for (; length && i < mBlobs.Length(); i++) {
70160:     nsIDOMBlob* blob = mBlobs[i].get();
70160: 
70160:     PRUint64 l;
73691:     nsresult rv = blob->GetSize(&l);
73691:     NS_ENSURE_SUCCESS(rv, nsnull);
70160: 
70160:     if (length < l) {
70160:       nsCOMPtr<nsIDOMBlob> lastBlob;
73693:       rv = blob->MozSlice(0, length, aContentType, 3,
70160:                           getter_AddRefs(lastBlob));
73691:       NS_ENSURE_SUCCESS(rv, nsnull);
70160: 
70160:       blobs.AppendElement(lastBlob);
70160:     } else {
70160:       blobs.AppendElement(blob);
70160:     }
71170:     length -= NS_MIN<PRUint64>(l, length);
70160:   }
70160: 
70160:   // we can create our blob now
73694:   nsCOMPtr<nsIDOMBlob> blob = new nsDOMMultipartFile(blobs, aContentType);
73691:   return blob.forget();
70160: }
70160: 
70822: class nsDOMBlobBuilder : public nsIDOMMozBlobBuilder
70160: {
70160: public:
70160:   nsDOMBlobBuilder()
70160:     : mData(nsnull), mDataLen(0), mDataBufferLen(0)
70160:   {}
70160: 
70160:   NS_DECL_ISUPPORTS
70822:   NS_DECL_NSIDOMMOZBLOBBUILDER
70160: protected:
70160:   nsresult AppendVoidPtr(void* aData, PRUint32 aLength);
70160:   nsresult AppendString(JSString* aString, JSContext* aCx);
70160:   nsresult AppendBlob(nsIDOMBlob* aBlob);
72062:   nsresult AppendArrayBuffer(JSObject* aBuffer);
70160: 
70160:   bool ExpandBufferSize(PRUint64 aSize)
70160:   {
70160:     if (mDataBufferLen >= mDataLen + aSize) {
70160:       mDataLen += aSize;
70160:       return true;
70160:     }
70160: 
70160:     // Start at 1 or we'll loop forever.
70160:     CheckedUint32 bufferLen = NS_MAX<PRUint32>(mDataBufferLen, 1);
70160:     while (bufferLen.valid() && bufferLen.value() < mDataLen + aSize)
70160:       bufferLen *= 2;
70160: 
70160:     if (!bufferLen.valid())
70160:       return false;
70160: 
70160:     // PR_ memory functions are still fallible
70160:     void* data = PR_Realloc(mData, bufferLen.value());
70160:     if (!data)
70160:       return false;
70160: 
70160:     mData = data;
70160:     mDataBufferLen = bufferLen.value();
70160:     mDataLen += aSize;
70160:     return true;
70160:   }
70160: 
70160:   void Flush() {
70160:     if (mData) {
70160:       // If we have some data, create a blob for it
70160:       // and put it on the stack
70160: 
70160:       nsCOMPtr<nsIDOMBlob> blob =
70160:         new nsDOMMemoryFile(mData, mDataLen, EmptyString(), EmptyString());
70160:       mBlobs.AppendElement(blob);
70160:       mData = nsnull; // The nsDOMMemoryFile takes ownership of the buffer
70160:       mDataLen = 0;
70160:       mDataBufferLen = 0;
70160:     }
70160:   }
70160: 
70160:   nsTArray<nsCOMPtr<nsIDOMBlob> > mBlobs;
70160:   void* mData;
70160:   PRUint64 mDataLen;
70160:   PRUint64 mDataBufferLen;
70160: };
70160: 
70160: DOMCI_DATA(MozBlobBuilder, nsDOMBlobBuilder)
70160: 
70160: NS_IMPL_ADDREF(nsDOMBlobBuilder)
70160: NS_IMPL_RELEASE(nsDOMBlobBuilder)
70160: NS_INTERFACE_MAP_BEGIN(nsDOMBlobBuilder)
70822:   NS_INTERFACE_MAP_ENTRY(nsIDOMMozBlobBuilder)
70160:   NS_INTERFACE_MAP_ENTRY(nsISupports)
70160:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MozBlobBuilder)
70160: NS_INTERFACE_MAP_END
70160: 
70160: nsresult
70160: nsDOMBlobBuilder::AppendVoidPtr(void* aData, PRUint32 aLength)
70160: {
70160:   NS_ENSURE_ARG_POINTER(aData);
70160: 
70160:   PRUint64 offset = mDataLen;
70160: 
70160:   if (!ExpandBufferSize(aLength))
70160:     return NS_ERROR_OUT_OF_MEMORY;
70160: 
70160:   memcpy((char*)mData + offset, aData, aLength);
70160:   return NS_OK;
70160: }
70160: 
70160: nsresult
70160: nsDOMBlobBuilder::AppendString(JSString* aString, JSContext* aCx)
70160: {
70160:   nsDependentJSString xpcomStr;
70160:   if (!xpcomStr.init(aCx, aString)) {
70160:     return NS_ERROR_XPC_BAD_CONVERT_JS;
70160:   }
70160: 
70160:   NS_ConvertUTF16toUTF8 utf8Str(xpcomStr);
70160: 
70160:   return AppendVoidPtr((void*)utf8Str.Data(),
70160:                        utf8Str.Length());
70160: }
70160: 
70160: nsresult
70160: nsDOMBlobBuilder::AppendBlob(nsIDOMBlob* aBlob)
70160: {
70160:   NS_ENSURE_ARG_POINTER(aBlob);
70160: 
70160:   Flush();
70160:   mBlobs.AppendElement(aBlob);
70160: 
70160:   return NS_OK;
70160: }
70160: 
70160: nsresult
72062: nsDOMBlobBuilder::AppendArrayBuffer(JSObject* aBuffer)
70160: {
72086:   return AppendVoidPtr(JS_GetArrayBufferData(aBuffer), JS_GetArrayBufferByteLength(aBuffer));
70160: }
70160: 
70160: /* nsIDOMBlob getBlob ([optional] in DOMString contentType); */
70160: NS_IMETHODIMP
70160: nsDOMBlobBuilder::GetBlob(const nsAString& aContentType,
70160:                           nsIDOMBlob** aBlob)
70160: {
70160:   NS_ENSURE_ARG(aBlob);
70160: 
70160:   Flush();
70160: 
73694:   nsCOMPtr<nsIDOMBlob> blob = new nsDOMMultipartFile(mBlobs,
70160:                                                      aContentType);
70160:   blob.forget(aBlob);
70160: 
70160:   // NB: This is a willful violation of the spec.  The spec says that
70160:   // the existing contents of the BlobBuilder should be included
70160:   // in the next blob produced.  This seems silly and has been raised
70160:   // on the WHATWG listserv.
70160:   mBlobs.Clear();
70160: 
70160:   return NS_OK;
70160: }
70160: 
73694: /* nsIDOMBlob getFile (in DOMString name, [optional] in DOMString contentType); */
73694: NS_IMETHODIMP
73694: nsDOMBlobBuilder::GetFile(const nsAString& aName,
73694:                           const nsAString& aContentType,
73694:                           nsIDOMFile** aFile)
73694: {
73694:   NS_ENSURE_ARG(aFile);
73694: 
73694:   Flush();
73694: 
73694:   nsCOMPtr<nsIDOMFile> file = new nsDOMMultipartFile(mBlobs,
73694:                                                      aName,
73694:                                                      aContentType);
73694:   file.forget(aFile);
73694: 
73694:   // NB: This is a willful violation of the spec.  The spec says that
73694:   // the existing contents of the BlobBuilder should be included
73694:   // in the next blob produced.  This seems silly and has been raised
73694:   // on the WHATWG listserv.
73694:   mBlobs.Clear();
73694: 
73694:   return NS_OK;
73694: }
73694: 
70160: /* [implicit_jscontext] void append (in jsval data); */
70160: NS_IMETHODIMP
70160: nsDOMBlobBuilder::Append(const jsval& aData, JSContext* aCx)
70160: {
70160:   // We need to figure out what our jsval is
70160: 
70160:   // Is it an object?
70160:   if (JSVAL_IS_OBJECT(aData)) {
70160:     JSObject* obj = JSVAL_TO_OBJECT(aData);
80782:     if (!obj) {
80782:       // We got passed null.  Just do nothing.
80782:       return NS_OK;
80782:     }
70160: 
70160:     // Is it a Blob?
70160:     nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(
70160:       nsContentUtils::XPConnect()->
70160:         GetNativeOfWrapper(aCx, obj));
70160:     if (blob)
70160:       return AppendBlob(blob);
70160: 
70160:     // Is it an array buffer?
70160:     if (js_IsArrayBuffer(obj)) {
72062:       JSObject* buffer = js::ArrayBuffer::getArrayBuffer(obj);
70160:       if (buffer)
70160:         return AppendArrayBuffer(buffer);
70160:     }
70160:   }
70160: 
70160:   // If it's not a Blob or an ArrayBuffer, coerce it to a string
70160:   JSString* str = JS_ValueToString(aCx, aData);
70160:   NS_ENSURE_TRUE(str, NS_ERROR_FAILURE);
70160: 
70160:   return AppendString(str, aCx);
70160: }
70160: 
70160: nsresult NS_NewBlobBuilder(nsISupports* *aSupports)
70160: {
70160:   nsDOMBlobBuilder* builder = new nsDOMBlobBuilder();
70160:   return CallQueryInterface(builder, aSupports);
70160: }
