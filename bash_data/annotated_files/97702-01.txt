    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation
72260:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
80467: #include "mozilla/Util.h"
80467: 
    1: #include "nsLayoutUtils.h"
    1: #include "nsIFormControlFrame.h"
    1: #include "nsPresContext.h"
    1: #include "nsIContent.h"
41068: #include "nsIDOMDocument.h"
41068: #include "nsIDOMHTMLDocument.h"
41320: #include "nsIDOMHTMLElement.h"
    1: #include "nsFrameList.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIAtom.h"
    1: #include "nsCSSPseudoElements.h"
12349: #include "nsCSSAnonBoxes.h"
72260: #include "nsCSSColorUtils.h"
    1: #include "nsIView.h"
    1: #include "nsPlaceholderFrame.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsDisplayList.h"
    1: #include "nsRegion.h"
    1: #include "nsFrameManager.h"
    1: #include "nsBlockFrame.h"
    1: #include "nsBidiPresUtils.h"
    1: #include "imgIContainer.h"
    1: #include "gfxRect.h"
 1442: #include "gfxContext.h"
 4032: #include "gfxFont.h"
93575: #include "nsRenderingContext.h"
    1: #include "nsIInterfaceRequestorUtils.h"
 1345: #include "nsCSSRendering.h"
 4032: #include "nsContentUtils.h"
16601: #include "nsThemeConstants.h"
16228: #include "nsPIDOMWindow.h"
16228: #include "nsIBaseWindow.h"
16228: #include "nsIDocShell.h"
16228: #include "nsIDocShellTreeItem.h"
16228: #include "nsIWidget.h"
19214: #include "gfxMatrix.h"
74753: #include "gfxPoint3D.h"
19214: #include "gfxTypes.h"
19962: #include "gfxUserFontSet.h"
24551: #include "nsTArray.h"
42402: #include "nsHTMLCanvasElement.h"
29572: #include "nsICanvasRenderingContextInternal.h"
29572: #include "gfxPlatform.h"
33027: #include "nsClientRect.h"
29959: #ifdef MOZ_MEDIA
29572: #include "nsHTMLVideoElement.h"
29959: #endif
29572: #include "imgIRequest.h"
29572: #include "nsIImageLoadingContent.h"
32132: #include "nsCOMPtr.h"
37081: #include "nsListControlFrame.h"
39499: #include "ImageLayers.h"
70831: #include "mozilla/arm.h"
41930: #include "mozilla/dom/Element.h"
47739: #include "nsCanvasFrame.h"
50420: #include "gfxDrawable.h"
50420: #include "gfxUtils.h"
60450: #include "nsDataHashtable.h"
71908: #include "nsTextFrame.h"
71908: #include "nsFontFaceList.h"
95535: #include "nsFontInflationData.h"
    1: 
12349: #include "nsSVGUtils.h"
19125: #include "nsSVGIntegrationUtils.h"
    1: #include "nsSVGForeignObjectFrame.h"
    1: #include "nsSVGOuterSVGFrame.h"
    1: 
74749: #include "mozilla/Preferences.h"
74749: 
39629: #ifdef MOZ_XUL
39629: #include "nsXULPopupManager.h"
39629: #endif
39629: 
87692: #include "sampler.h"
87692: 
80467: using namespace mozilla;
39499: using namespace mozilla::layers;
41634: using namespace mozilla::dom;
88122: using namespace mozilla::layout;
39499: 
55416: #ifdef DEBUG
55416: // TODO: remove, see bug 598468.
55416: bool nsLayoutUtils::gPreventAssertInCompareTreePosition = false;
55416: #endif // DEBUG
55416: 
55321: typedef gfxPattern::GraphicsFilter GraphicsFilter;
60444: typedef FrameMetrics::ViewID ViewID;
55321: 
82670: static PRUint32 sFontSizeInflationEmPerLine;
82670: static PRUint32 sFontSizeInflationMinTwips;
95532: /* static */ PRUint32 nsLayoutUtils::sFontSizeInflationLineThreshold;
82670: 
60450: static ViewID sScrollIdCounter = FrameMetrics::START_SCROLL_ID;
60450: 
60450: typedef nsDataHashtable<nsUint64HashKey, nsIContent*> ContentMap;
60450: static ContentMap* sContentMap = NULL;
60450: static ContentMap& GetContentMap() {
60450:   if (!sContentMap) {
60450:     sContentMap = new ContentMap();
63963: #ifdef DEBUG
63963:     nsresult rv =
63963: #endif
63963:     sContentMap->Init();
60450:     NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "Could not initialize map.");
60450:   }
60450:   return *sContentMap;
60450: }
60450: 
74749: 
79445: bool
74749: nsLayoutUtils::Are3DTransformsEnabled()
74749: {
79445:   static bool s3DTransformsEnabled;
79445:   static bool s3DTransformPrefCached = false;
74749: 
74749:   if (!s3DTransformPrefCached) {
80486:     s3DTransformPrefCached = true;
74749:     mozilla::Preferences::AddBoolVarCache(&s3DTransformsEnabled, 
74749:                                           "layout.3d-transforms.enabled");
74749:   }
74749: 
74749:   return s3DTransformsEnabled;
74749: }
74749: 
95942: bool
95942: nsLayoutUtils::UseBackgroundNearestFiltering()
95942: {
95942:   static bool sUseBackgroundNearestFilteringEnabled;
95942:   static bool sUseBackgroundNearestFilteringPrefInitialised = false;
95942: 
95942:   if (!sUseBackgroundNearestFilteringPrefInitialised) {
95942:     sUseBackgroundNearestFilteringPrefInitialised = true;
95942:     sUseBackgroundNearestFilteringEnabled = mozilla::Preferences::GetBool("gfx.filter.nearest.force-enabled", false);
95942:   }
95942: 
95942:   return sUseBackgroundNearestFilteringEnabled;
95942: }
95942: 
97534: bool
97534: nsLayoutUtils::GPUImageScalingEnabled()
97534: {
97534:   static bool sGPUImageScalingEnabled;
97534:   static bool sGPUImageScalingPrefInitialised = false;
97534: 
97534:   if (!sGPUImageScalingPrefInitialised) {
97534:     sGPUImageScalingPrefInitialised = true;
97534:     sGPUImageScalingEnabled = mozilla::Preferences::GetBool("layout.gpu-image-scaling.enabled", false);
97534:   }
97534: 
97534:   return sGPUImageScalingEnabled;
97534: }
97534: 
87626: void
87626: nsLayoutUtils::UnionChildOverflow(nsIFrame* aFrame,
87626:                                   nsOverflowAreas& aOverflowAreas)
87626: {
87630:   // Iterate over all children except pop-ups.
87630:   const nsIFrame::ChildListIDs skip(nsIFrame::kPopupList |
87630:                                     nsIFrame::kSelectPopupList);
87626:   for (nsIFrame::ChildListIterator childLists(aFrame);
87626:        !childLists.IsDone(); childLists.Next()) {
87630:     if (skip.Contains(childLists.CurrentID())) {
87626:       continue;
87630:     }
87626: 
87626:     nsFrameList children = childLists.CurrentList();
87626:     for (nsFrameList::Enumerator e(children); !e.AtEnd(); e.Next()) {
87626:       nsIFrame* child = e.get();
87626:       nsOverflowAreas childOverflow =
87626:         child->GetOverflowAreas() + child->GetPosition();
87626:       aOverflowAreas.UnionWith(childOverflow);
87626:     }
87626:   }
87626: }
87626: 
60450: static void DestroyViewID(void* aObject, nsIAtom* aPropertyName,
60450:                           void* aPropertyValue, void* aData)
60450: {
60450:   ViewID* id = static_cast<ViewID*>(aPropertyValue);
60450:   GetContentMap().Remove(*id);
60450:   delete id;
60450: }
60450: 
63413: /**
63413:  * A namespace class for static layout utilities.
63413:  */
63413: 
60450: ViewID
60450: nsLayoutUtils::FindIDFor(nsIContent* aContent)
60450: {
60450:   ViewID scrollId;
60450: 
60450:   void* scrollIdProperty = aContent->GetProperty(nsGkAtoms::RemoteId);
60450:   if (scrollIdProperty) {
60450:     scrollId = *static_cast<ViewID*>(scrollIdProperty);
60450:   } else {
60450:     scrollId = sScrollIdCounter++;
60450:     aContent->SetProperty(nsGkAtoms::RemoteId, new ViewID(scrollId),
60450:                           DestroyViewID);
60450:     GetContentMap().Put(scrollId, aContent);
60450:   }
60450: 
60450:   return scrollId;
60450: }
60450: 
60450: nsIContent*
60450: nsLayoutUtils::FindContentFor(ViewID aId)
60450: {
60450:   NS_ABORT_IF_FALSE(aId != FrameMetrics::NULL_SCROLL_ID &&
60450:                     aId != FrameMetrics::ROOT_SCROLL_ID,
60450:                     "Cannot find a content element in map for null or root IDs.");
60450:   nsIContent* content;
60450:   bool exists = GetContentMap().Get(aId, &content);
60450: 
60450:   if (exists) {
60450:     return content;
60450:   } else {
60450:     return nsnull;
60450:   }
60450: }
60450: 
63413: bool
63413: nsLayoutUtils::GetDisplayPort(nsIContent* aContent, nsRect *aResult)
63413: {
63413:   void* property = aContent->GetProperty(nsGkAtoms::DisplayPort);
63413:   if (!property) {
63413:     return false;
63413:   }
63413: 
63413:   if (aResult) {
63413:     *aResult = *static_cast<nsRect*>(property);
63413:   }
63413:   return true;
63413: }
    1: 
10780: nsIFrame*
10780: nsLayoutUtils::GetLastContinuationWithChild(nsIFrame* aFrame)
10780: {
10780:   NS_PRECONDITION(aFrame, "NULL frame pointer");
10780:   aFrame = aFrame->GetLastContinuation();
77154:   while (!aFrame->GetFirstPrincipalChild() &&
10780:          aFrame->GetPrevContinuation()) {
10780:     aFrame = aFrame->GetPrevContinuation();
10780:   }
10780:   return aFrame;
10780: }
10780: 
    1: /**
    1:  * GetFirstChildFrame returns the first "real" child frame of a
    1:  * given frame.  It will descend down into pseudo-frames (unless the
    1:  * pseudo-frame is the :before generated frame).
    1:  * @param aFrame the frame
    1:  * @param aFrame the frame's content node
    1:  */
    1: static nsIFrame*
    1: GetFirstChildFrame(nsIFrame*       aFrame,
    1:                    nsIContent*     aContent)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1: 
    1:   // Get the first child frame
77154:   nsIFrame* childFrame = aFrame->GetFirstPrincipalChild();
    1: 
    1:   // If the child frame is a pseudo-frame, then return its first child.
    1:   // Note that the frame we create for the generated content is also a
    1:   // pseudo-frame and so don't drill down in that case
    1:   if (childFrame &&
    1:       childFrame->IsPseudoFrame(aContent) &&
    1:       !childFrame->IsGeneratedContentFrame()) {
    1:     return GetFirstChildFrame(childFrame, aContent);
    1:   }
    1: 
    1:   return childFrame;
    1: }
    1: 
    1: /**
    1:  * GetLastChildFrame returns the last "real" child frame of a
    1:  * given frame.  It will descend down into pseudo-frames (unless the
    1:  * pseudo-frame is the :after generated frame).
    1:  * @param aFrame the frame
    1:  * @param aFrame the frame's content node
    1:  */
    1: static nsIFrame*
    1: GetLastChildFrame(nsIFrame*       aFrame,
    1:                   nsIContent*     aContent)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1: 
10780:   // Get the last continuation frame that's a parent
77154:   nsIFrame* lastParentContinuation =
77154:     nsLayoutUtils::GetLastContinuationWithChild(aFrame);
77154:   nsIFrame* lastChildFrame =
77154:     lastParentContinuation->GetLastChild(nsIFrame::kPrincipalList);
32843:   if (lastChildFrame) {
    1:     // Get the frame's first continuation. This matters in case the frame has
    1:     // been continued across multiple lines or split by BiDi resolution.
    1:     lastChildFrame = lastChildFrame->GetFirstContinuation();
    1: 
    1:     // If the last child frame is a pseudo-frame, then return its last child.
    1:     // Note that the frame we create for the generated content is also a
    1:     // pseudo-frame and so don't drill down in that case
    1:     if (lastChildFrame &&
    1:         lastChildFrame->IsPseudoFrame(aContent) &&
    1:         !lastChildFrame->IsGeneratedContentFrame()) {
    1:       return GetLastChildFrame(lastChildFrame, aContent);
    1:     }
    1: 
    1:     return lastChildFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: //static
77154: nsIFrame::ChildListID
36646: nsLayoutUtils::GetChildListNameFor(nsIFrame* aChildFrame)
36646: {
77154:   nsIFrame::ChildListID id = nsIFrame::kPrincipalList;
36646: 
36646:   if (aChildFrame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
36646:     nsIFrame* pif = aChildFrame->GetPrevInFlow();
36646:     if (pif->GetParent() == aChildFrame->GetParent()) {
77154:       id = nsIFrame::kExcessOverflowContainersList;
36646:     }
36646:     else {
77154:       id = nsIFrame::kOverflowContainersList;
36646:     }
36646:   }
36646:   // See if the frame is moved out of the flow
36646:   else if (aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
36646:     // Look at the style information to tell
36646:     const nsStyleDisplay* disp = aChildFrame->GetStyleDisplay();
36646: 
36646:     if (NS_STYLE_POSITION_ABSOLUTE == disp->mPosition) {
77154:       id = nsIFrame::kAbsoluteList;
36646:     } else if (NS_STYLE_POSITION_FIXED == disp->mPosition) {
36646:       if (nsLayoutUtils::IsReallyFixedPos(aChildFrame)) {
77154:         id = nsIFrame::kFixedList;
36646:       } else {
77154:         id = nsIFrame::kAbsoluteList;
36646:       }
36646: #ifdef MOZ_XUL
36646:     } else if (NS_STYLE_DISPLAY_POPUP == disp->mDisplay) {
36646:       // Out-of-flows that are DISPLAY_POPUP must be kids of the root popup set
36646: #ifdef DEBUG
36646:       nsIFrame* parent = aChildFrame->GetParent();
36646:       NS_ASSERTION(parent && parent->GetType() == nsGkAtoms::popupSetFrame,
36646:                    "Unexpected parent");
36646: #endif // DEBUG
36646: 
36646:       // XXX FIXME: Bug 350740
36646:       // Return here, because the postcondition for this function actually
36646:       // fails for this case, since the popups are not in a "real" frame list
36646:       // in the popup set.
77154:       return nsIFrame::kPopupList;
36646: #endif // MOZ_XUL
36646:     } else {
36646:       NS_ASSERTION(aChildFrame->GetStyleDisplay()->IsFloating(),
36646:                    "not a floated frame");
77154:       id = nsIFrame::kFloatList;
36646:     }
36646: 
36646:   } else {
36646:     nsIAtom* childType = aChildFrame->GetType();
36646:     if (nsGkAtoms::menuPopupFrame == childType) {
36646:       nsIFrame* parent = aChildFrame->GetParent();
36646:       nsIFrame* firstPopup = (parent)
77154:                              ? parent->GetFirstChild(nsIFrame::kPopupList)
36646:                              : nsnull;
36646:       NS_ASSERTION(!firstPopup || !firstPopup->GetNextSibling(),
36646:                    "We assume popupList only has one child, but it has more.");
77154:       id = firstPopup == aChildFrame
77154:              ? nsIFrame::kPopupList
77154:              : nsIFrame::kPrincipalList;
36646:     } else if (nsGkAtoms::tableColGroupFrame == childType) {
77154:       id = nsIFrame::kColGroupList;
36646:     } else if (nsGkAtoms::tableCaptionFrame == aChildFrame->GetType()) {
77154:       id = nsIFrame::kCaptionList;
36646:     } else {
77154:       id = nsIFrame::kPrincipalList;
36646:     }
36646:   }
36646: 
36646: #ifdef NS_DEBUG
36646:   // Verify that the frame is actually in that child list or in the
36646:   // corresponding overflow list.
36646:   nsIFrame* parent = aChildFrame->GetParent();
79445:   bool found = parent->GetChildList(id).ContainsFrame(aChildFrame);
36646:   if (!found) {
36646:     if (!(aChildFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
77154:       found = parent->GetChildList(nsIFrame::kOverflowList)
36646:                 .ContainsFrame(aChildFrame);
36646:     }
36646:     else if (aChildFrame->GetStyleDisplay()->IsFloating()) {
77154:       found = parent->GetChildList(nsIFrame::kOverflowOutOfFlowList)
36646:                 .ContainsFrame(aChildFrame);
36646:     }
77154:     // else it's positioned and should have been on the 'id' child list.
36646:     NS_POSTCONDITION(found, "not in child list");
36646:   }
36646: #endif
36646: 
77154:   return id;
36646: }
36646: 
36646: // static
    1: nsIFrame*
    1: nsLayoutUtils::GetBeforeFrame(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1:   NS_ASSERTION(!aFrame->GetPrevContinuation(),
    1:                "aFrame must be first continuation");
    1: 
    1:   nsIFrame* firstFrame = GetFirstChildFrame(aFrame, aFrame->GetContent());
    1: 
    1:   if (firstFrame && IsGeneratedContentFor(nsnull, firstFrame,
    1:                                           nsCSSPseudoElements::before)) {
    1:     return firstFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // static
    1: nsIFrame*
    1: nsLayoutUtils::GetAfterFrame(nsIFrame* aFrame)
    1: {
    1:   NS_PRECONDITION(aFrame, "NULL frame pointer");
    1: 
    1:   nsIFrame* lastFrame = GetLastChildFrame(aFrame, aFrame->GetContent());
    1: 
    1:   if (lastFrame && IsGeneratedContentFor(nsnull, lastFrame,
    1:                                          nsCSSPseudoElements::after)) {
    1:     return lastFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // static
    1: nsIFrame*
 3113: nsLayoutUtils::GetClosestFrameOfType(nsIFrame* aFrame, nsIAtom* aFrameType)
    1: {
    1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
 3113:     if (frame->GetType() == aFrameType) {
    1:       return frame;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
35300: // static
35300: nsIFrame*
35300: nsLayoutUtils::GetStyleFrame(nsIFrame* aFrame)
35300: {
35300:   if (aFrame->GetType() == nsGkAtoms::tableOuterFrame) {
77154:     nsIFrame* inner = aFrame->GetFirstPrincipalChild();
35300:     NS_ASSERTION(inner, "Outer table must have an inner");
35300:     return inner;
35300:   }
35300: 
35300:   return aFrame;
35300: }
35300: 
    1: nsIFrame*
    1: nsLayoutUtils::GetFloatFromPlaceholder(nsIFrame* aFrame) {
34911:   NS_ASSERTION(nsGkAtoms::placeholderFrame == aFrame->GetType(),
34911:                "Must have a placeholder here");
34912:   if (aFrame->GetStateBits() & PLACEHOLDER_FOR_FLOAT) {
    1:     nsIFrame *outOfFlowFrame =
    1:       nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
34912:     NS_ASSERTION(outOfFlowFrame->GetStyleDisplay()->IsFloating(),
34912:                  "How did that happen?");
    1:     return outOfFlowFrame;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // static
79445: bool
    1: nsLayoutUtils::IsGeneratedContentFor(nsIContent* aContent,
    1:                                      nsIFrame* aFrame,
    1:                                      nsIAtom* aPseudoElement)
    1: {
    1:   NS_PRECONDITION(aFrame, "Must have a frame");
    1:   NS_PRECONDITION(aPseudoElement, "Must have a pseudo name");
    1: 
    1:   if (!aFrame->IsGeneratedContentFrame()) {
80486:     return false;
    1:   }
16976:   nsIFrame* parent = aFrame->GetParent();
16976:   NS_ASSERTION(parent, "Generated content can't be root frame");
16976:   if (parent->IsGeneratedContentFrame()) {
16976:     // Not the root of the generated content
80486:     return false;
    1:   }
    1: 
16976:   if (aContent && parent->GetContent() != aContent) {
80486:     return false;
16976:   }
16976: 
16976:   return (aFrame->GetContent()->Tag() == nsGkAtoms::mozgeneratedcontentbefore) ==
16976:     (aPseudoElement == nsCSSPseudoElements::before);
    1: }
    1: 
    1: // static
    1: nsIFrame*
18884: nsLayoutUtils::GetCrossDocParentFrame(const nsIFrame* aFrame,
18884:                                       nsPoint* aExtraOffset)
    1: {
    1:   nsIFrame* p = aFrame->GetParent();
    1:   if (p)
    1:     return p;
    1: 
    1:   nsIView* v = aFrame->GetView();
    1:   if (!v)
    1:     return nsnull;
    1:   v = v->GetParent(); // anonymous inner view
    1:   if (!v)
    1:     return nsnull;
18884:   if (aExtraOffset) {
18884:     *aExtraOffset += v->GetPosition();
18884:   }
    1:   v = v->GetParent(); // subdocumentframe's view
82566:   return v ? v->GetFrame() : nsnull;
    1: }
    1: 
    1: // static
79445: bool
    1: nsLayoutUtils::IsProperAncestorFrameCrossDoc(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
    1:                                              nsIFrame* aCommonAncestor)
    1: {
    1:   if (aFrame == aCommonAncestor)
80486:     return false;
    1: 
    1:   nsIFrame* parentFrame = GetCrossDocParentFrame(aFrame);
    1: 
    1:   while (parentFrame != aCommonAncestor) {
    1:     if (parentFrame == aAncestorFrame)
80486:       return true;
    1: 
    1:     parentFrame = GetCrossDocParentFrame(parentFrame);
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
    1: // static
79445: bool
30518: nsLayoutUtils::IsAncestorFrameCrossDoc(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
30518:                                        nsIFrame* aCommonAncestor)
30518: {
30518:   if (aFrame == aAncestorFrame)
80486:     return true;
30518:   return IsProperAncestorFrameCrossDoc(aAncestorFrame, aFrame, aCommonAncestor);
30518: }
30518: 
30518: // static
79445: bool
    1: nsLayoutUtils::IsProperAncestorFrame(nsIFrame* aAncestorFrame, nsIFrame* aFrame,
    1:                                      nsIFrame* aCommonAncestor)
    1: {
    1:   if (aFrame == aCommonAncestor) {
80486:     return false;
    1:   }
    1: 
    1:   nsIFrame* parentFrame = aFrame->GetParent();
    1: 
    1:   while (parentFrame != aCommonAncestor) {
    1:     if (parentFrame == aAncestorFrame) {
80486:       return true;
    1:     }
    1: 
    1:     parentFrame = parentFrame->GetParent();
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
    1: // static
    1: PRInt32
    1: nsLayoutUtils::DoCompareTreePosition(nsIContent* aContent1,
    1:                                      nsIContent* aContent2,
    1:                                      PRInt32 aIf1Ancestor,
    1:                                      PRInt32 aIf2Ancestor,
32864:                                      const nsIContent* aCommonAncestor)
    1: {
    1:   NS_PRECONDITION(aContent1, "aContent1 must not be null");
    1:   NS_PRECONDITION(aContent2, "aContent2 must not be null");
    1: 
 7820:   nsAutoTArray<nsINode*, 32> content1Ancestors;
    1:   nsINode* c1;
    1:   for (c1 = aContent1; c1 && c1 != aCommonAncestor; c1 = c1->GetNodeParent()) {
    1:     content1Ancestors.AppendElement(c1);
    1:   }
    1:   if (!c1 && aCommonAncestor) {
    1:     // So, it turns out aCommonAncestor was not an ancestor of c1. Oops.
    1:     // Never mind. We can continue as if aCommonAncestor was null.
    1:     aCommonAncestor = nsnull;
    1:   }
    1: 
 7820:   nsAutoTArray<nsINode*, 32> content2Ancestors;
    1:   nsINode* c2;
    1:   for (c2 = aContent2; c2 && c2 != aCommonAncestor; c2 = c2->GetNodeParent()) {
    1:     content2Ancestors.AppendElement(c2);
    1:   }
    1:   if (!c2 && aCommonAncestor) {
    1:     // So, it turns out aCommonAncestor was not an ancestor of c2.
    1:     // We need to retry with no common ancestor hint.
    1:     return DoCompareTreePosition(aContent1, aContent2,
    1:                                  aIf1Ancestor, aIf2Ancestor, nsnull);
    1:   }
    1: 
 7820:   int last1 = content1Ancestors.Length() - 1;
 7820:   int last2 = content2Ancestors.Length() - 1;
    1:   nsINode* content1Ancestor = nsnull;
    1:   nsINode* content2Ancestor = nsnull;
    1:   while (last1 >= 0 && last2 >= 0
 7820:          && ((content1Ancestor = content1Ancestors.ElementAt(last1)) ==
 7820:              (content2Ancestor = content2Ancestors.ElementAt(last2)))) {
    1:     last1--;
    1:     last2--;
    1:   }
    1: 
    1:   if (last1 < 0) {
    1:     if (last2 < 0) {
    1:       NS_ASSERTION(aContent1 == aContent2, "internal error?");
    1:       return 0;
    1:     }
    1:     // aContent1 is an ancestor of aContent2
    1:     return aIf1Ancestor;
    1:   }
    1: 
    1:   if (last2 < 0) {
    1:     // aContent2 is an ancestor of aContent1
    1:     return aIf2Ancestor;
    1:   }
    1: 
    1:   // content1Ancestor != content2Ancestor, so they must be siblings with the same parent
    1:   nsINode* parent = content1Ancestor->GetNodeParent();
55416: #ifdef DEBUG
55416:   // TODO: remove the uglyness, see bug 598468.
55416:   NS_ASSERTION(gPreventAssertInCompareTreePosition || parent,
55416:                "no common ancestor at all???");
55416: #endif // DEBUG
    1:   if (!parent) { // different documents??
    1:     return 0;
    1:   }
    1: 
    1:   PRInt32 index1 = parent->IndexOf(content1Ancestor);
    1:   PRInt32 index2 = parent->IndexOf(content2Ancestor);
    1:   if (index1 < 0 || index2 < 0) {
    1:     // one of them must be anonymous; we can't determine the order
    1:     return 0;
    1:   }
    1: 
    1:   return index1 - index2;
    1: }
    1: 
    1: static nsIFrame* FillAncestors(nsIFrame* aFrame,
    1:                                nsIFrame* aStopAtAncestor, nsFrameManager* aFrameManager,
    1:                                nsTArray<nsIFrame*>* aAncestors)
    1: {
    1:   while (aFrame && aFrame != aStopAtAncestor) {
    1:     aAncestors->AppendElement(aFrame);
    1:     aFrame = nsLayoutUtils::GetParentOrPlaceholderFor(aFrameManager, aFrame);
    1:   }
    1:   return aFrame;
    1: }
    1: 
    1: // Return true if aFrame1 is after aFrame2
79445: static bool IsFrameAfter(nsIFrame* aFrame1, nsIFrame* aFrame2)
    1: {
    1:   nsIFrame* f = aFrame2;
    1:   do {
    1:     f = f->GetNextSibling();
    1:     if (f == aFrame1)
80486:       return true;
    1:   } while (f);
80486:   return false;
    1: }
    1: 
    1: // static
    1: PRInt32
    1: nsLayoutUtils::DoCompareTreePosition(nsIFrame* aFrame1,
    1:                                      nsIFrame* aFrame2,
    1:                                      PRInt32 aIf1Ancestor,
    1:                                      PRInt32 aIf2Ancestor,
    1:                                      nsIFrame* aCommonAncestor)
    1: {
    1:   NS_PRECONDITION(aFrame1, "aFrame1 must not be null");
    1:   NS_PRECONDITION(aFrame2, "aFrame2 must not be null");
    1: 
  238:   nsPresContext* presContext = aFrame1->PresContext();
  238:   if (presContext != aFrame2->PresContext()) {
    1:     NS_ERROR("no common ancestor at all, different documents");
    1:     return 0;
    1:   }
    1:   nsFrameManager* frameManager = presContext->PresShell()->FrameManager();
    1: 
    1:   nsAutoTArray<nsIFrame*,20> frame1Ancestors;
    1:   if (!FillAncestors(aFrame1, aCommonAncestor, frameManager, &frame1Ancestors)) {
    1:     // We reached the root of the frame tree ... if aCommonAncestor was set,
    1:     // it is wrong
    1:     aCommonAncestor = nsnull;
    1:   }
    1: 
    1:   nsAutoTArray<nsIFrame*,20> frame2Ancestors;
    1:   if (!FillAncestors(aFrame2, aCommonAncestor, frameManager, &frame2Ancestors) &&
    1:       aCommonAncestor) {
    1:     // We reached the root of the frame tree ... aCommonAncestor was wrong.
    1:     // Try again with no hint.
    1:     return DoCompareTreePosition(aFrame1, aFrame2,
    1:                                  aIf1Ancestor, aIf2Ancestor, nsnull);
    1:   }
    1: 
    1:   PRInt32 last1 = PRInt32(frame1Ancestors.Length()) - 1;
    1:   PRInt32 last2 = PRInt32(frame2Ancestors.Length()) - 1;
    1:   while (last1 >= 0 && last2 >= 0 &&
    1:          frame1Ancestors[last1] == frame2Ancestors[last2]) {
    1:     last1--;
    1:     last2--;
    1:   }
    1: 
    1:   if (last1 < 0) {
    1:     if (last2 < 0) {
    1:       NS_ASSERTION(aFrame1 == aFrame2, "internal error?");
    1:       return 0;
    1:     }
    1:     // aFrame1 is an ancestor of aFrame2
    1:     return aIf1Ancestor;
    1:   }
    1: 
    1:   if (last2 < 0) {
    1:     // aFrame2 is an ancestor of aFrame1
    1:     return aIf2Ancestor;
    1:   }
    1: 
    1:   nsIFrame* ancestor1 = frame1Ancestors[last1];
    1:   nsIFrame* ancestor2 = frame2Ancestors[last2];
    1:   // Now we should be able to walk sibling chains to find which one is first
    1:   if (IsFrameAfter(ancestor2, ancestor1))
    1:     return -1;
    1:   if (IsFrameAfter(ancestor1, ancestor2))
    1:     return 1;
    1:   NS_WARNING("Frames were in different child lists???");
    1:   return 0;
    1: }
    1: 
    1: // static
    1: nsIFrame* nsLayoutUtils::GetLastSibling(nsIFrame* aFrame) {
    1:   if (!aFrame) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsIFrame* next;
    1:   while ((next = aFrame->GetNextSibling()) != nsnull) {
    1:     aFrame = next;
    1:   }
    1:   return aFrame;
    1: }
    1: 
    1: // static
    1: nsIView*
    1: nsLayoutUtils::FindSiblingViewFor(nsIView* aParentView, nsIFrame* aFrame) {
82566:   nsIFrame* parentViewFrame = aParentView->GetFrame();
    1:   nsIContent* parentViewContent = parentViewFrame ? parentViewFrame->GetContent() : nsnull;
    1:   for (nsIView* insertBefore = aParentView->GetFirstChild(); insertBefore;
    1:        insertBefore = insertBefore->GetNextSibling()) {
82566:     nsIFrame* f = insertBefore->GetFrame();
    1:     if (!f) {
    1:       // this view could be some anonymous view attached to a meaningful parent
    1:       for (nsIView* searchView = insertBefore->GetParent(); searchView;
    1:            searchView = searchView->GetParent()) {
82566:         f = searchView->GetFrame();
    1:         if (f) {
    1:           break;
    1:         }
    1:       }
    1:       NS_ASSERTION(f, "Can't find a frame anywhere!");
    1:     }
    1:     if (!f || !aFrame->GetContent() || !f->GetContent() ||
    1:         CompareTreePosition(aFrame->GetContent(), f->GetContent(), parentViewContent) > 0) {
    1:       // aFrame's content is after f's content (or we just don't know),
    1:       // so put our view before f's view
    1:       return insertBefore;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: //static
    1: nsIScrollableFrame*
    1: nsLayoutUtils::GetScrollableFrameFor(nsIFrame *aScrolledFrame)
    1: {
    1:   nsIFrame *frame = aScrolledFrame->GetParent();
    1:   if (!frame) {
    1:     return nsnull;
    1:   }
23554:   nsIScrollableFrame *sf = do_QueryFrame(frame);
    1:   return sf;
    1: }
    1: 
47736: nsIFrame*
47736: nsLayoutUtils::GetActiveScrolledRootFor(nsIFrame* aFrame,
49156:                                         nsIFrame* aStopAtAncestor)
47736: {
47742:   nsIFrame* f = aFrame;
47742:   while (f != aStopAtAncestor) {
50412:     if (IsPopup(f))
50412:       break;
49156:     nsIFrame* parent = GetCrossDocParentFrame(f);
47742:     if (!parent)
47742:       break;
47742:     nsIScrollableFrame* sf = do_QueryFrame(parent);
47742:     if (sf && sf->IsScrollingActive() && sf->GetScrolledFrame() == f)
47742:       break;
47742:     f = parent;
47742:   }
47742:   return f;
47736: }
47736: 
67668: nsIFrame*
67668: nsLayoutUtils::GetActiveScrolledRootFor(nsDisplayItem* aItem,
69752:                                         nsDisplayListBuilder* aBuilder,
79445:                                         bool* aShouldFixToViewport)
67668: {
67668:   nsIFrame* f = aItem->GetUnderlyingFrame();
69752:   if (aShouldFixToViewport) {
80486:     *aShouldFixToViewport = false;
69752:   }
67668:   if (!f) {
67668:     return nsnull;
67668:   }
67668:   if (aItem->ShouldFixToViewport(aBuilder)) {
69752:     if (aShouldFixToViewport) {
80486:       *aShouldFixToViewport = true;
69752:     }
67668:     // Make its active scrolled root be the active scrolled root of
67668:     // the enclosing viewport, since it shouldn't be scrolled by scrolled
67668:     // frames in its document. InvalidateFixedBackgroundFramesFromList in
67668:     // nsGfxScrollFrame will not repaint this item when scrolling occurs.
67668:     nsIFrame* viewportFrame =
67668:       nsLayoutUtils::GetClosestFrameOfType(f, nsGkAtoms::viewportFrame);
67668:     NS_ASSERTION(viewportFrame, "no viewport???");
67668:     return nsLayoutUtils::GetActiveScrolledRootFor(viewportFrame, aBuilder->ReferenceFrame());
67668:   } else {
67668:     return nsLayoutUtils::GetActiveScrolledRootFor(f, aBuilder->ReferenceFrame());
67668:   }
67668: }
67668: 
79445: bool
97660: nsLayoutUtils::ScrolledByViewportScrolling(nsIFrame* aActiveScrolledRoot,
67668:                                            nsDisplayListBuilder* aBuilder)
67668: {
97660:   nsIFrame* rootScrollFrame =
97660:     aBuilder->ReferenceFrame()->PresContext()->GetPresShell()->GetRootScrollFrame();
67668:   return nsLayoutUtils::IsAncestorFrameCrossDoc(rootScrollFrame, aActiveScrolledRoot);
67668: }
67668: 
    1: // static
    1: nsIScrollableFrame*
37057: nsLayoutUtils::GetNearestScrollableFrameForDirection(nsIFrame* aFrame,
37057:                                                      Direction aDirection)
    1: {
37057:   NS_ASSERTION(aFrame, "GetNearestScrollableFrameForDirection expects a non-null frame");
37057:   for (nsIFrame* f = aFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
37057:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(f);
37057:     if (scrollableFrame) {
37057:       nsPresContext::ScrollbarStyles ss = scrollableFrame->GetScrollbarStyles();
37292:       PRUint32 scrollbarVisibility = scrollableFrame->GetScrollbarVisibility();
37057:       nsRect scrollRange = scrollableFrame->GetScrollRange();
37057:       // Require visible scrollbars or something to scroll to in
37057:       // the given direction.
37057:       if (aDirection == eVertical ?
37057:           (ss.mVertical != NS_STYLE_OVERFLOW_HIDDEN &&
37292:            ((scrollbarVisibility & nsIScrollableFrame::VERTICAL) ||
37292:             scrollRange.height > 0)) :
37057:           (ss.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN &&
37292:            ((scrollbarVisibility & nsIScrollableFrame::HORIZONTAL) ||
37292:             scrollRange.width > 0)))
37057:         return scrollableFrame;
37057:     }
37057:   }
37057:   return nsnull;
    1: }
    1: 
    1: // static
37057: nsIScrollableFrame*
37057: nsLayoutUtils::GetNearestScrollableFrame(nsIFrame* aFrame)
    1: {
37057:   NS_ASSERTION(aFrame, "GetNearestScrollableFrame expects a non-null frame");
37057:   for (nsIFrame* f = aFrame; f; f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
37057:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(f);
37057:     if (scrollableFrame) {
37057:       nsPresContext::ScrollbarStyles ss = scrollableFrame->GetScrollbarStyles();
37057:       if (ss.mVertical != NS_STYLE_OVERFLOW_HIDDEN ||
37057:           ss.mHorizontal != NS_STYLE_OVERFLOW_HIDDEN)
37057:         return scrollableFrame;
37057:     }
37057:   }
37057:   return nsnull;
    1: }
    1: 
48947: //static
79445: bool
48947: nsLayoutUtils::HasPseudoStyle(nsIContent* aContent,
48947:                               nsStyleContext* aStyleContext,
48947:                               nsCSSPseudoElements::Type aPseudoElement,
48947:                               nsPresContext* aPresContext)
48947: {
48947:   NS_PRECONDITION(aPresContext, "Must have a prescontext");
48947: 
48947:   nsRefPtr<nsStyleContext> pseudoContext;
48947:   if (aContent) {
48947:     pseudoContext = aPresContext->StyleSet()->
48947:       ProbePseudoElementStyle(aContent->AsElement(), aPseudoElement,
48947:                               aStyleContext);
48947:   }
48947:   return pseudoContext != nsnull;
48947: }
48947: 
    1: nsPoint
    1: nsLayoutUtils::GetDOMEventCoordinatesRelativeTo(nsIDOMEvent* aDOMEvent, nsIFrame* aFrame)
    1: {
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aDOMEvent));
    1:   NS_ASSERTION(privateEvent, "bad implementation");
    1:   if (!privateEvent)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
20234:   nsEvent *event = privateEvent->GetInternalNSEvent();
20234:   if (!event)
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1:   return GetEventCoordinatesRelativeTo(event, aFrame);
    1: }
    1: 
    1: nsPoint
 2817: nsLayoutUtils::GetEventCoordinatesRelativeTo(const nsEvent* aEvent, nsIFrame* aFrame)
    1: {
    1:   if (!aEvent || (aEvent->eventStructType != NS_MOUSE_EVENT &&
18445:                   aEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
23284:                   aEvent->eventStructType != NS_DRAG_EVENT &&
28352:                   aEvent->eventStructType != NS_SIMPLE_GESTURE_EVENT &&
31443:                   aEvent->eventStructType != NS_GESTURENOTIFY_EVENT &&
48711:                   aEvent->eventStructType != NS_MOZTOUCH_EVENT &&
87650:                   aEvent->eventStructType != NS_TOUCH_EVENT &&
28352:                   aEvent->eventStructType != NS_QUERY_CONTENT_EVENT))
    1:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
    1: 
 3233:   const nsGUIEvent* GUIEvent = static_cast<const nsGUIEvent*>(aEvent);
87650:   return GetEventCoordinatesRelativeTo(aEvent,
87650:                                        GUIEvent->refPoint,
87650:                                        aFrame);
87650: }
87650: 
87650: nsPoint
87650: nsLayoutUtils::GetEventCoordinatesRelativeTo(const nsEvent* aEvent,
87650:                                              const nsIntPoint aPoint,
87650:                                              nsIFrame* aFrame)
87650: {
87650:   if (!aFrame) {
87650:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
87650:   }
87650: 
87650:   const nsGUIEvent* GUIEvent = static_cast<const nsGUIEvent*>(aEvent);
87650:   nsIWidget* widget = GUIEvent->widget;
87650:   if (!widget) {
87650:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
87650:   }
87650: 
91486:   nsIView* view = aFrame->GetView();
91486:   if (view) {
91649:     nsIWidget* frameWidget = view->GetWidget();
91649:     if (frameWidget && frameWidget == GUIEvent->widget) {
91486:       // Special case this cause it happens a lot.
91486:       // This also fixes bug 664707, events in the extra-special case of select
91486:       // dropdown popups that are transformed.
91486:       nsPresContext* presContext = aFrame->PresContext();
91649:       nsPoint pt(presContext->DevPixelsToAppUnits(aPoint.x),
91649:                  presContext->DevPixelsToAppUnits(aPoint.y));
91486:       return pt - view->ViewToWidgetOffset();
91486:     }
91486:   }
91486: 
87650:   /* If we walk up the frame tree and discover that any of the frames are
87650:    * transformed, we need to do extra work to convert from the global
87650:    * space to the local space.
87650:    */
87650:   nsIFrame* rootFrame = aFrame;
87650:   bool transformFound = false;
87650:   for (nsIFrame* f = aFrame; f; f = GetCrossDocParentFrame(f)) {
87650:     if (f->IsTransformed()) {
87650:       transformFound = true;
87650:     }
87650: 
87650:     rootFrame = f;
87650:   }
87650: 
87650:   nsIView* rootView = rootFrame->GetView();
87650:   if (!rootView) {
87650:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
87650:   }
87650: 
87650:   nsPoint widgetToView = TranslateWidgetToView(rootFrame->PresContext(),
87650:                                widget, aPoint, rootView);
87650: 
87650:   if (widgetToView == nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE)) {
87650:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
87650:   }
87650: 
87650:   // Convert from root document app units to app units of the document aFrame
87650:   // is in.
87650:   PRInt32 rootAPD = rootFrame->PresContext()->AppUnitsPerDevPixel();
87650:   PRInt32 localAPD = aFrame->PresContext()->AppUnitsPerDevPixel();
87650:   widgetToView = widgetToView.ConvertAppUnits(rootAPD, localAPD);
87650: 
87650:   /* If we encountered a transform, we can't do simple arithmetic to figure
87650:    * out how to convert back to aFrame's coordinates and must use the CTM.
87650:    */
87650:   if (transformFound) {
87650:     return TransformRootPointToFrame(aFrame, widgetToView);
87650:   }
87650: 
87650:   /* Otherwise, all coordinate systems are translations of one another,
87650:    * so we can just subtract out the different.
87650:    */
87650:   nsPoint offset = aFrame->GetOffsetToCrossDoc(rootFrame);
87650:   return widgetToView - offset;
    1: }
    1: 
39629: nsIFrame*
48255: nsLayoutUtils::GetPopupFrameForEventCoordinates(nsPresContext* aPresContext,
48255:                                                 const nsEvent* aEvent)
39629: {
39629: #ifdef MOZ_XUL
39629:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
39629:   if (!pm) {
39629:     return nsnull;
39629:   }
39629:   nsTArray<nsIFrame*> popups = pm->GetVisiblePopups();
39629:   PRUint32 i;
39629:   // Search from top to bottom
39629:   for (i = 0; i < popups.Length(); i++) {
39629:     nsIFrame* popup = popups[i];
48255:     if (popup->PresContext()->GetRootPresContext() == aPresContext &&
55040:         popup->GetScrollableOverflowRect().Contains(
39629:           GetEventCoordinatesRelativeTo(aEvent, popup))) {
39629:       return popup;
39629:     }
39629:   }
39629: #endif
39629:   return nsnull;
39629: }
39629: 
74283: gfx3DMatrix
74757: nsLayoutUtils::ChangeMatrixBasis(const gfxPoint3D &aOrigin,
74283:                                  const gfx3DMatrix &aMatrix)
19214: {
77291:   gfx3DMatrix result = aMatrix;
77291: 
77291:   /* Translate to the origin before aMatrix */
77291:   result.Translate(-aOrigin);
77291: 
77291:   /* Translate back into position after aMatrix */
77291:   result.TranslatePost(aOrigin);
77291: 
77291:   return result; 
19214: }
19214: 
19214: /**
19214:  * Given a gfxFloat, constrains its value to be between nscoord_MIN and nscoord_MAX.
19214:  *
19214:  * @param aVal The value to constrain (in/out)
19214:  */
19214: static void ConstrainToCoordValues(gfxFloat &aVal)
19214: {
19214:   if (aVal <= nscoord_MIN)
19214:     aVal = nscoord_MIN;
19214:   else if (aVal >= nscoord_MAX)
19214:     aVal = nscoord_MAX;
19214: }
19214: 
19214: nsRect
19214: nsLayoutUtils::RoundGfxRectToAppRect(const gfxRect &aRect, float aFactor)
19214: {
19214:   /* Get a new gfxRect whose units are app units by scaling by the specified factor. */
68640:   gfxRect scaledRect = aRect;
68640:   scaledRect.ScaleRoundOut(aFactor);
19214: 
19214:   /* We now need to constrain our results to the max and min values for coords. */
68634:   ConstrainToCoordValues(scaledRect.x);
68634:   ConstrainToCoordValues(scaledRect.y);
68634:   ConstrainToCoordValues(scaledRect.width);
68634:   ConstrainToCoordValues(scaledRect.height);
19214: 
19214:   /* Now typecast everything back.  This is guaranteed to be safe. */
68632:   return nsRect(nscoord(scaledRect.X()), nscoord(scaledRect.Y()),
68632:                 nscoord(scaledRect.Width()), nscoord(scaledRect.Height()));
19214: }
19214: 
59779: 
59779: nsRegion
59779: nsLayoutUtils::RoundedRectIntersectRect(const nsRect& aRoundedRect,
59779:                                         const nscoord aRadii[8],
59779:                                         const nsRect& aContainedRect)
59779: {
59779:   // rectFullHeight and rectFullWidth together will approximately contain
59779:   // the total area of the frame minus the rounded corners.
59779:   nsRect rectFullHeight = aRoundedRect;
59779:   nscoord xDiff = NS_MAX(aRadii[NS_CORNER_TOP_LEFT_X], aRadii[NS_CORNER_BOTTOM_LEFT_X]);
59779:   rectFullHeight.x += xDiff;
59779:   rectFullHeight.width -= NS_MAX(aRadii[NS_CORNER_TOP_RIGHT_X],
59779:                                  aRadii[NS_CORNER_BOTTOM_RIGHT_X]) + xDiff;
59779:   nsRect r1;
59779:   r1.IntersectRect(rectFullHeight, aContainedRect);
59779: 
59779:   nsRect rectFullWidth = aRoundedRect;
59779:   nscoord yDiff = NS_MAX(aRadii[NS_CORNER_TOP_LEFT_Y], aRadii[NS_CORNER_TOP_RIGHT_Y]);
59779:   rectFullWidth.y += yDiff;
59779:   rectFullWidth.height -= NS_MAX(aRadii[NS_CORNER_BOTTOM_LEFT_Y],
59779:                                  aRadii[NS_CORNER_BOTTOM_RIGHT_Y]) + yDiff;
59779:   nsRect r2;
59779:   r2.IntersectRect(rectFullWidth, aContainedRect);
59779: 
59779:   nsRegion result;
59779:   result.Or(r1, r2);
59779:   return result;
59779: }
59779: 
19214: nsRect
63072: nsLayoutUtils::MatrixTransformRectOut(const nsRect &aBounds,
74283:                                       const gfx3DMatrix &aMatrix, float aFactor)
63072: {
63072:   nsRect outside = aBounds;
63072:   outside.ScaleRoundOut(1/aFactor);
63072:   gfxRect image = aMatrix.TransformBounds(gfxRect(outside.x,
63072:                                                   outside.y,
63072:                                                   outside.width,
63072:                                                   outside.height));
63072:   return RoundGfxRectToAppRect(image, aFactor);
63072: }
63072: 
63072: nsRect
19214: nsLayoutUtils::MatrixTransformRect(const nsRect &aBounds,
74283:                                    const gfx3DMatrix &aMatrix, float aFactor)
19214: {
63072:   gfxRect image = aMatrix.TransformBounds(gfxRect(NSAppUnitsToDoublePixels(aBounds.x, aFactor),
63072:                                                   NSAppUnitsToDoublePixels(aBounds.y, aFactor),
63072:                                                   NSAppUnitsToDoublePixels(aBounds.width, aFactor),
63072:                                                   NSAppUnitsToDoublePixels(aBounds.height, aFactor)));
19214: 
19214:   return RoundGfxRectToAppRect(image, aFactor);
19214: }
19214: 
19214: nsPoint
19214: nsLayoutUtils::MatrixTransformPoint(const nsPoint &aPoint,
74283:                                     const gfx3DMatrix &aMatrix, float aFactor)
19214: {
19214:   gfxPoint image = aMatrix.Transform(gfxPoint(NSAppUnitsToFloatPixels(aPoint.x, aFactor),
19214:                                               NSAppUnitsToFloatPixels(aPoint.y, aFactor)));
19214:   return nsPoint(NSFloatPixelsToAppUnits(float(image.x), aFactor),
19214:                  NSFloatPixelsToAppUnits(float(image.y), aFactor));
19214: }
19214: 
87659: gfx3DMatrix
87659: nsLayoutUtils::GetTransformToAncestor(nsIFrame *aFrame, nsIFrame *aAncestor)
86353: {
86353:   nsIFrame* parent;
86353:   gfx3DMatrix ctm = aFrame->GetTransformMatrix(aAncestor, &parent);
86353:   while (parent && parent != aAncestor) {
89891:     if (!parent->Preserves3DChildren()) {
89891:       ctm.ProjectTo2D();
89891:     }
86353:     ctm = ctm * parent->GetTransformMatrix(aAncestor, &parent);
86353:   }
86353:   return ctm;
86353: }
86353: 
86248: static gfxPoint
86353: TransformGfxPointFromAncestor(nsIFrame *aFrame,
86248:                               const gfxPoint &aPoint,
86353:                               nsIFrame *aAncestor)
86244: {
87659:   gfx3DMatrix ctm = nsLayoutUtils::GetTransformToAncestor(aFrame, aAncestor);
86353:   return ctm.Inverse().ProjectPoint(aPoint);
86248: }
86248: 
86248: static gfxRect
86353: TransformGfxRectFromAncestor(nsIFrame *aFrame,
86248:                              const gfxRect &aRect,
86353:                              nsIFrame *aAncestor)
19214: {
87659:   gfx3DMatrix ctm = nsLayoutUtils::GetTransformToAncestor(aFrame, aAncestor);
86353:   return ctm.Inverse().ProjectRectBounds(aRect);
86353: }
86353: 
86353: static gfxRect
86353: TransformGfxRectToAncestor(nsIFrame *aFrame,
86353:                            const gfxRect &aRect,
86353:                            nsIFrame *aAncestor)
86353: {
87659:   gfx3DMatrix ctm = nsLayoutUtils::GetTransformToAncestor(aFrame, aAncestor);
87914:   return ctm.TransformBounds(aRect);
19214: }
19214: 
19214: nsPoint
86353: nsLayoutUtils::TransformRootPointToFrame(nsIFrame *aFrame,
19214:                                          const nsPoint &aPoint)
19214: {
74753:     float factor = aFrame->PresContext()->AppUnitsPerDevPixel();
74753:     gfxPoint result(NSAppUnitsToFloatPixels(aPoint.x, factor),
74753:                     NSAppUnitsToFloatPixels(aPoint.y, factor));
74753:     
86353:     result = TransformGfxPointFromAncestor(aFrame, result, nsnull);
74753:    
74753:     return nsPoint(NSFloatPixelsToAppUnits(float(result.x), factor),
74753:                    NSFloatPixelsToAppUnits(float(result.y), factor));
74753: }
74753: 
74753: nsRect 
86353: nsLayoutUtils::TransformAncestorRectToFrame(nsIFrame* aFrame,
74753:                                             const nsRect &aRect,
86353:                                             nsIFrame* aAncestor)
74753: {
74753:     float factor = aFrame->PresContext()->AppUnitsPerDevPixel();
74753:     gfxRect result(NSAppUnitsToFloatPixels(aRect.x, factor),
74753:                    NSAppUnitsToFloatPixels(aRect.y, factor),
74753:                    NSAppUnitsToFloatPixels(aRect.width, factor),
74753:                    NSAppUnitsToFloatPixels(aRect.height, factor));
74753: 
86353:     result = TransformGfxRectFromAncestor(aFrame, result, aAncestor);
86353: 
86353:     return nsRect(NSFloatPixelsToAppUnits(float(result.x), factor),
86353:                   NSFloatPixelsToAppUnits(float(result.y), factor),
86353:                   NSFloatPixelsToAppUnits(float(result.width), factor),
86353:                   NSFloatPixelsToAppUnits(float(result.height), factor));
86353: }
86353: 
86353: nsRect
86353: nsLayoutUtils::TransformFrameRectToAncestor(nsIFrame* aFrame,
86353:                                             const nsRect& aRect,
86353:                                             nsIFrame* aAncestor)
86353: {
86353:   float factor = aFrame->PresContext()->AppUnitsPerDevPixel();
86353:   gfxRect result(NSAppUnitsToFloatPixels(aRect.x, factor),
86353:                  NSAppUnitsToFloatPixels(aRect.y, factor),
86353:                  NSAppUnitsToFloatPixels(aRect.width, factor),
86353:                  NSAppUnitsToFloatPixels(aRect.height, factor));
86353: 
86353:   result = TransformGfxRectToAncestor(aFrame, result, aAncestor);
74753: 
74753:   return nsRect(NSFloatPixelsToAppUnits(float(result.x), factor),
74753:                 NSFloatPixelsToAppUnits(float(result.y), factor),
74753:                 NSFloatPixelsToAppUnits(float(result.width), factor),
74753:                 NSFloatPixelsToAppUnits(float(result.height), factor));
19214: }
19214: 
23738: static nsIntPoint GetWidgetOffset(nsIWidget* aWidget, nsIWidget*& aRootWidget) {
23738:   nsIntPoint offset(0, 0);
 3778:   nsIWidget* parent = aWidget->GetParent();
 3778:   while (parent) {
23738:     nsIntRect bounds;
 3778:     aWidget->GetBounds(bounds);
 3778:     offset += bounds.TopLeft();
 3778:     aWidget = parent;
 3778:     parent = aWidget->GetParent();
 3778:   }
 3778:   aRootWidget = aWidget;
 3778:   return offset;
 3778: }
 3778: 
    1: nsPoint
    1: nsLayoutUtils::TranslateWidgetToView(nsPresContext* aPresContext,
    1:                                      nsIWidget* aWidget, nsIntPoint aPt,
    1:                                      nsIView* aView)
    1: {
 3778:   nsPoint viewOffset;
 3778:   nsIWidget* viewWidget = aView->GetNearestWidget(&viewOffset);
50858:   if (!viewWidget) {
50858:     return nsPoint(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
50858:   }
 3778: 
 3778:   nsIWidget* fromRoot;
23738:   nsIntPoint fromOffset = GetWidgetOffset(aWidget, fromRoot);
 3778:   nsIWidget* toRoot;
23738:   nsIntPoint toOffset = GetWidgetOffset(viewWidget, toRoot);
 3778: 
 3778:   nsIntPoint widgetPoint;
 3778:   if (fromRoot == toRoot) {
 3778:     widgetPoint = aPt + fromOffset - toOffset;
 3778:   } else {
25183:     nsIntPoint screenPoint = aWidget->WidgetToScreenOffset();
25183:     widgetPoint = aPt + screenPoint - viewWidget->WidgetToScreenOffset();
 3778:   }
 3778: 
 3778:   nsPoint widgetAppUnits(aPresContext->DevPixelsToAppUnits(widgetPoint.x),
 3778:                          aPresContext->DevPixelsToAppUnits(widgetPoint.y));
 3778:   return widgetAppUnits - viewOffset;
    1: }
    1: 
    1: // Combine aNewBreakType with aOrigBreakType, but limit the break types
    1: // to NS_STYLE_CLEAR_LEFT, RIGHT, LEFT_AND_RIGHT.
    1: PRUint8
    1: nsLayoutUtils::CombineBreakType(PRUint8 aOrigBreakType,
    1:                                 PRUint8 aNewBreakType)
    1: {
    1:   PRUint8 breakType = aOrigBreakType;
    1:   switch(breakType) {
    1:   case NS_STYLE_CLEAR_LEFT:
    1:     if ((NS_STYLE_CLEAR_RIGHT          == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
    1:       breakType = NS_STYLE_CLEAR_LEFT_AND_RIGHT;
    1:     }
    1:     break;
    1:   case NS_STYLE_CLEAR_RIGHT:
    1:     if ((NS_STYLE_CLEAR_LEFT           == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
    1:       breakType = NS_STYLE_CLEAR_LEFT_AND_RIGHT;
    1:     }
    1:     break;
    1:   case NS_STYLE_CLEAR_NONE:
    1:     if ((NS_STYLE_CLEAR_LEFT           == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_RIGHT          == aNewBreakType) ||
    1:         (NS_STYLE_CLEAR_LEFT_AND_RIGHT == aNewBreakType)) {
    1:       breakType = aNewBreakType;
    1:     }
    1:   }
    1:   return breakType;
    1: }
    1: 
82351: #ifdef MOZ_DUMP_PAINTING
    1: #include <stdio.h>
    1: 
94996: static bool gDumpEventList = false;
91338: int gPaintCount = 0;
    1: #endif
    1: 
60444: nsresult
60444: nsLayoutUtils::GetRemoteContentIds(nsIFrame* aFrame,
60444:                                    const nsRect& aTarget,
60444:                                    nsTArray<ViewID> &aOutIDs,
79445:                                    bool aIgnoreRootScrollFrame)
60444: {
60444:   nsDisplayListBuilder builder(aFrame, nsDisplayListBuilder::EVENT_DELIVERY,
80486:                                false);
60444:   nsDisplayList list;
60444: 
94996:   if (aIgnoreRootScrollFrame) {
60444:     nsIFrame* rootScrollFrame =
60444:       aFrame->PresContext()->PresShell()->GetRootScrollFrame();
60444:     if (rootScrollFrame) {
60444:       builder.SetIgnoreScrollFrame(rootScrollFrame);
60444:     }
60444:   }
60444: 
60444:   builder.EnterPresShell(aFrame, aTarget);
60444: 
60444:   nsresult rv =
60444:     aFrame->BuildDisplayListForStackingContext(&builder, aTarget, &list);
60444: 
60444:   builder.LeavePresShell(aFrame, aTarget);
60444:   NS_ENSURE_SUCCESS(rv, rv);
60444: 
78095:   nsAutoTArray<nsIFrame*,8> outFrames;
60444:   nsDisplayItem::HitTestState hitTestState(&aOutIDs);
60444:   list.HitTest(&builder, aTarget, &hitTestState, &outFrames);
60444:   list.DeleteAll();
60444: 
60444:   return NS_OK;
60444: }
60444: 
    1: nsIFrame*
 5440: nsLayoutUtils::GetFrameForPoint(nsIFrame* aFrame, nsPoint aPt,
79445:                                 bool aShouldIgnoreSuppression,
79445:                                 bool aIgnoreRootScrollFrame)
    1: {
96794:   SAMPLE_LABEL("nsLayoutUtils", "GetFrameForPoint");
40569:   nsresult rv;
78095:   nsAutoTArray<nsIFrame*,8> outFrames;
40569:   rv = GetFramesForArea(aFrame, nsRect(aPt, nsSize(1, 1)), outFrames,
40569:                         aShouldIgnoreSuppression, aIgnoreRootScrollFrame);
40569:   NS_ENSURE_SUCCESS(rv, nsnull);
40569:   return outFrames.Length() ? outFrames.ElementAt(0) : nsnull;
40569: }
40569: 
40569: nsresult
40569: nsLayoutUtils::GetFramesForArea(nsIFrame* aFrame, const nsRect& aRect,
40569:                                 nsTArray<nsIFrame*> &aOutFrames,
79445:                                 bool aShouldIgnoreSuppression,
79445:                                 bool aIgnoreRootScrollFrame)
40569: {
96794:   SAMPLE_LABEL("nsLayoutUtils","GetFramesForArea");
57094:   nsDisplayListBuilder builder(aFrame, nsDisplayListBuilder::EVENT_DELIVERY,
80486: 		                       false);
    1:   nsDisplayList list;
40569:   nsRect target(aRect);
40569: 
40569:   if (aShouldIgnoreSuppression) {
 5440:     builder.IgnorePaintSuppression();
40569:   }
20863: 
94996:   if (aIgnoreRootScrollFrame) {
20863:     nsIFrame* rootScrollFrame =
20863:       aFrame->PresContext()->PresShell()->GetRootScrollFrame();
20863:     if (rootScrollFrame) {
20863:       builder.SetIgnoreScrollFrame(rootScrollFrame);
20863:     }
20863:   }
20863: 
    1:   builder.EnterPresShell(aFrame, target);
    1: 
    1:   nsresult rv =
    1:     aFrame->BuildDisplayListForStackingContext(&builder, target, &list);
    1: 
    1:   builder.LeavePresShell(aFrame, target);
40569:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
82351: #ifdef MOZ_DUMP_PAINTING
    1:   if (gDumpEventList) {
94996:     fprintf(stdout, "Event handling --- (%d,%d):\n", aRect.x, aRect.y);
94996:     nsFrame::PrintDisplayList(&builder, list);
    1:   }
    1: #endif
    1: 
 9799:   nsDisplayItem::HitTestState hitTestState;
40569:   list.HitTest(&builder, target, &hitTestState, &aOutFrames);
    1:   list.DeleteAll();
40569:   return NS_OK;
    1: }
    1: 
    1: /**
14043:  * Remove all leaf display items that are not for descendants of
14043:  * aBuilder->GetReferenceFrame() from aList, and move all nsDisplayClip
14043:  * wrappers to their correct locations.
14043:  * @param aExtraPage the page we constructed aList for
14043:  * @param aY the Y-coordinate where aPage would be positioned relative
14043:  * to the main page (aBuilder->GetReferenceFrame()), considering only
14043:  * the content and ignoring page margins and dead space
14043:  * @param aList the list that is modified in-place
14043:  */
14043: static void
14043: PruneDisplayListForExtraPage(nsDisplayListBuilder* aBuilder,
14043:         nsIFrame* aExtraPage, nscoord aY, nsDisplayList* aList)
14043: {
14043:   nsDisplayList newList;
14043:   // The page which we're really constructing a display list for
14043:   nsIFrame* mainPage = aBuilder->ReferenceFrame();
14043: 
80486:   while (true) {
14043:     nsDisplayItem* i = aList->RemoveBottom();
14043:     if (!i)
14043:       break;
14043:     nsDisplayList* subList = i->GetList();
14043:     if (subList) {
14043:       PruneDisplayListForExtraPage(aBuilder, aExtraPage, aY, subList);
52292:       nsDisplayItem::Type type = i->GetType();
52292:       if (type == nsDisplayItem::TYPE_CLIP ||
52292:           type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT) {
14043:         // This might clip an element which should appear on the first
14043:         // page, and that element might be visible if this uses a 'clip'
14043:         // property with a negative top.
14043:         // The clip area needs to be moved because the frame geometry doesn't
14043:         // put page content frames for adjacent pages vertically adjacent,
14043:         // there are page margins and dead space between them in print
14043:         // preview, and in printing all pages are at (0,0)...
14043:         // XXX we have no way to test this right now that I know of;
14043:         // the 'clip' property requires an abs-pos element and we never
14043:         // paint abs-pos elements that start after the main page
14043:         // (bug 426909).
14043:         nsDisplayClip* clip = static_cast<nsDisplayClip*>(i);
14043:         clip->SetClipRect(clip->GetClipRect() + nsPoint(0, aY) -
14043:                 aExtraPage->GetOffsetTo(mainPage));
14043:       }
14043:       newList.AppendToTop(i);
14043:     } else {
14043:       nsIFrame* f = i->GetUnderlyingFrame();
14043:       if (f && nsLayoutUtils::IsProperAncestorFrameCrossDoc(mainPage, f)) {
14043:         // This one is in the page we care about, keep it
14043:         newList.AppendToTop(i);
14043:       } else {
14043:         // We're throwing this away so call its destructor now. The memory
14043:         // is owned by aBuilder which destroys all items at once.
23827:         i->~nsDisplayItem();
14043:       }
14043:     }
14043:   }
14043:   aList->AppendToTop(&newList);
14043: }
14043: 
14043: static nsresult
14043: BuildDisplayListForExtraPage(nsDisplayListBuilder* aBuilder,
14043:         nsIFrame* aPage, nscoord aY, nsDisplayList* aList)
14043: {
14043:   nsDisplayList list;
14043:   // Pass an empty dirty rect since we're only interested in finding
14043:   // placeholders whose out-of-flows are in the page
14043:   // aBuilder->GetReferenceFrame(), and the paths to those placeholders
14043:   // have already been marked as NS_FRAME_FORCE_DISPLAY_LIST_DESCEND_INTO.
14043:   // Note that we should still do a prune step since we don't want to
14043:   // rely on dirty-rect checking for correctness.
14043:   nsresult rv = aPage->BuildDisplayListForStackingContext(aBuilder, nsRect(), &list);
14043:   if (NS_FAILED(rv))
14043:     return rv;
14043:   PruneDisplayListForExtraPage(aBuilder, aPage, aY, &list);
14043:   aList->AppendToTop(&list);
14043:   return NS_OK;
14043: }
14043: 
14043: static nsIFrame*
14043: GetNextPage(nsIFrame* aPageContentFrame)
14043: {
14043:   // XXX ugh
14043:   nsIFrame* pageFrame = aPageContentFrame->GetParent();
14043:   NS_ASSERTION(pageFrame->GetType() == nsGkAtoms::pageFrame,
14043:                "pageContentFrame has unexpected parent");
14043:   nsIFrame* nextPageFrame = pageFrame->GetNextSibling();
14043:   if (!nextPageFrame)
14043:     return nsnull;
14043:   NS_ASSERTION(nextPageFrame->GetType() == nsGkAtoms::pageFrame,
14043:                "pageFrame's sibling is not a page frame...");
77154:   nsIFrame* f = nextPageFrame->GetFirstPrincipalChild();
14043:   NS_ASSERTION(f, "pageFrame has no page content frame!");
14043:   NS_ASSERTION(f->GetType() == nsGkAtoms::pageContentFrame,
14043:                "pageFrame's child is not page content!");
14043:   return f;
14043: }
14043: 
    1: nsresult
68481: nsLayoutUtils::PaintFrame(nsRenderingContext* aRenderingContext, nsIFrame* aFrame,
30541:                           const nsRegion& aDirtyRegion, nscolor aBackstop,
30541:                           PRUint32 aFlags)
    1: {
96794:   SAMPLE_LABEL("nsLayoutUtils","PaintFrame");
49168:   if (aFlags & PAINT_WIDGET_LAYERS) {
49168:     nsIView* view = aFrame->GetView();
51184:     if (!(view && view->GetWidget() && GetDisplayRootFrame(aFrame) == aFrame)) {
51184:       aFlags &= ~PAINT_WIDGET_LAYERS;
51184:       NS_ASSERTION(aRenderingContext, "need a rendering context");
51184:     }
51184:   }
49168: 
47738:   nsPresContext* presContext = aFrame->PresContext();
47739:   nsIPresShell* presShell = presContext->PresShell();
47738: 
63413:   nsIFrame* rootScrollFrame = presShell->GetRootScrollFrame();
63413:   bool usingDisplayPort = false;
63413:   nsRect displayport;
63413:   if (rootScrollFrame) {
63413:     nsIContent* content = rootScrollFrame->GetContent();
63413:     if (content) {
63413:       usingDisplayPort = nsLayoutUtils::GetDisplayPort(content, &displayport);
63413:     }
63413:   }
63413: 
79445:   bool ignoreViewportScrolling = presShell->IgnoringViewportScrolling();
47738:   nsRegion visibleRegion;
54080:   if (aFlags & PAINT_WIDGET_LAYERS) {
47738:     // This layer tree will be reused, so we'll need to calculate it
54080:     // for the whole "visible" area of the window
54080:     // 
54080:     // |ignoreViewportScrolling| and |usingDisplayPort| are persistent
54080:     // document-rendering state.  We rely on PresShell to flush
54080:     // retained layers as needed when that persistent state changes.
63413:     if (!usingDisplayPort) {
55040:       visibleRegion = aFrame->GetVisualOverflowRectRelativeToSelf();
47738:     } else {
63413:       visibleRegion = displayport;
54080:     }
54080:   } else {
47738:     visibleRegion = aDirtyRegion;
47738:   }
47738: 
51011:   // If we're going to display something different from what we'd normally
51011:   // paint in a window then we will flush out any retained layer trees before
51011:   // *and after* we draw.
79445:   bool willFlushRetainedLayers = (aFlags & PAINT_HIDE_CARET) != 0;
51011: 
57094:   nsDisplayListBuilder builder(aFrame, nsDisplayListBuilder::PAINTING,
57094: 		                       !(aFlags & PAINT_HIDE_CARET));
67670:   if (usingDisplayPort) {
69752:     builder.SetDisplayPort(displayport);
67670:   }
67670: 
    1:   nsDisplayList list;
30541:   if (aFlags & PAINT_IN_TRANSFORM) {
80486:     builder.SetInTransform(true);
30541:   }
32424:   if (aFlags & PAINT_SYNC_DECODE_IMAGES) {
80486:     builder.SetSyncDecodeImages(true);
32424:   }
61835:   if (aFlags & (PAINT_WIDGET_LAYERS | PAINT_TO_WINDOW)) {
80486:     builder.SetPaintingToWindow(true);
42240:   }
51851:   if (aFlags & PAINT_IGNORE_SUPPRESSION) {
51851:     builder.IgnorePaintSuppression();
47739:   }
47739:   nsRect canvasArea(nsPoint(0, 0), aFrame->GetSize());
62806: 
62806: #ifdef DEBUG
54080:   if (ignoreViewportScrolling) {
62806:     nsIDocument* doc = aFrame->GetContent() ?
62806:       aFrame->GetContent()->GetCurrentDoc() : nsnull;
62806:     NS_ASSERTION(!aFrame->GetParent() ||
62806:                  (doc && doc->IsBeingUsedAsImage()),
62806:                  "Only expecting ignoreViewportScrolling for root frames and "
62806:                  "for image documents.");
62806:   }
62806: #endif
62806: 
62806:   if (ignoreViewportScrolling && !aFrame->GetParent()) {
47739:     nsIFrame* rootScrollFrame = presShell->GetRootScrollFrame();
47739:     if (rootScrollFrame) {
47739:       nsIScrollableFrame* rootScrollableFrame =
47739:         presShell->GetRootScrollFrameAsScrollable();
54079:       if (aFlags & PAINT_DOCUMENT_RELATIVE) {
47739:         // Make visibleRegion and aRenderingContext relative to the
47739:         // scrolled frame instead of the root frame.
47739:         nsPoint pos = rootScrollableFrame->GetScrollPosition();
47739:         visibleRegion.MoveBy(-pos);
54080:         if (aRenderingContext) {
68479:           aRenderingContext->Translate(pos);
54079:         }
54080:       }
47739:       builder.SetIgnoreScrollFrame(rootScrollFrame);
47739: 
47739:       nsCanvasFrame* canvasFrame =
47739:         do_QueryFrame(rootScrollableFrame->GetScrolledFrame());
47739:       if (canvasFrame) {
47739:         // Use UnionRect here to ensure that areas where the scrollbars
47739:         // were are still filled with the background color.
47739:         canvasArea.UnionRect(canvasArea,
47739:           canvasFrame->CanvasArea() + builder.ToReferenceFrame(canvasFrame));
47739:       }
47739:     }
47739:   }
29987:   nsresult rv;
29987: 
47738:   nsRect dirtyRect = visibleRegion.GetBounds();
    1:   builder.EnterPresShell(aFrame, dirtyRect);
96794:   {
96794:   SAMPLE_LABEL("nsLayoutUtils","PaintFrame::BuildDisplayList");
29987:   rv = aFrame->BuildDisplayListForStackingContext(&builder, dirtyRect, &list);
96794:   }
79445:   const bool paintAllContinuations = aFlags & PAINT_ALL_CONTINUATIONS;
50424:   NS_ASSERTION(!paintAllContinuations || !aFrame->GetPrevContinuation(),
50424:                "If painting all continuations, the frame must be "
50424:                "first-continuation");
50424: 
49168:   nsIAtom* frameType = aFrame->GetType();
50424:   if (NS_SUCCEEDED(rv) && !paintAllContinuations &&
50424:       frameType == nsGkAtoms::pageContentFrame) {
49168:     NS_ASSERTION(!(aFlags & PAINT_WIDGET_LAYERS),
49168:       "shouldn't be painting with widget layers for page content frames");
14043:     // We may need to paint out-of-flow frames whose placeholders are
14043:     // on other pages. Add those pages to our display list. Note that
14043:     // out-of-flow frames can't be placed after their placeholders so
14043:     // we don't have to process earlier pages. The display lists for
14043:     // these extra pages are pruned so that only display items for the
14043:     // page we currently care about (which we would have reached by
14043:     // following placeholders to their out-of-flows) end up on the list.
14043:     nsIFrame* page = aFrame;
14043:     nscoord y = aFrame->GetSize().height;
14043:     while ((page = GetNextPage(page)) != nsnull) {
96794:       SAMPLE_LABEL("nsLayoutUtils","PaintFrame::BuildDisplayListForExtraPage");
14043:       rv = BuildDisplayListForExtraPage(&builder, page, y, &list);
14043:       if (NS_FAILED(rv))
14043:         break;
14043:       y += page->GetSize().height;
14043:     }
14043:   }
    1: 
50424:   if (paintAllContinuations) {
50424:     nsIFrame* currentFrame = aFrame;
50424:     while (NS_SUCCEEDED(rv) &&
50424:            (currentFrame = currentFrame->GetNextContinuation()) != nsnull) {
96794:       SAMPLE_LABEL("nsLayoutUtils","PaintFrame::ContinuationsBuildDisplayList");
50424:       nsRect frameDirty = dirtyRect - builder.ToReferenceFrame(currentFrame);
50424:       rv = currentFrame->BuildDisplayListForStackingContext(&builder,
50424:                                                             frameDirty, &list);
50424:     }
50424:   }
50424: 
30869:   // For the viewport frame in print preview/page layout we want to paint
30869:   // the grey background behind the page, not the canvas color.
30869:   if (frameType == nsGkAtoms::viewportFrame && 
49166:       nsLayoutUtils::NeedsPrintPreviewBackground(presContext)) {
30869:     nsRect bounds = nsRect(builder.ToReferenceFrame(aFrame),
30869:                            aFrame->GetSize());
49166:     rv = presShell->AddPrintPreviewBackgroundItem(builder, list, aFrame, bounds);
30869:   } else if (frameType != nsGkAtoms::pageFrame) {
29987:     // For printing, this function is first called on an nsPageFrame, which
29987:     // creates a display list with a PageContent item. The PageContent item's
29987:     // paint function calls this function on the nsPageFrame's child which is
29987:     // an nsPageContentFrame. We only want to add the canvas background color
29987:     // item once, for the nsPageContentFrame.
30869: 
47741:     // Add the canvas background color to the bottom of the list. This
47741:     // happens after we've built the list so that AddCanvasBackgroundColorItem
47741:     // can monkey with the contents if necessary.
80559:     canvasArea.IntersectRect(canvasArea, visibleRegion.GetBounds());
47739:     rv = presShell->AddCanvasBackgroundColorItem(
47739:            builder, list, aFrame, canvasArea, aBackstop);
49168: 
49168:     // If the passed in backstop color makes us draw something different from
49168:     // normal, we need to flush layers.
54080:     if ((aFlags & PAINT_WIDGET_LAYERS) && !willFlushRetainedLayers) {
49168:       nsIView* view = aFrame->GetView();
49168:       if (view) {
49168:         nscolor backstop = presShell->ComputeBackstopColor(view);
49168:         // The PresShell's canvas background color doesn't get updated until
49168:         // EnterPresShell, so this check has to be done after that.
49168:         nscolor canvasColor = presShell->GetCanvasBackground();
49168:         if (NS_ComposeColors(aBackstop, canvasColor) !=
49168:             NS_ComposeColors(backstop, canvasColor)) {
80486:           willFlushRetainedLayers = true;
49168:         }
49168:       }
49168:     }
29987:   }
29987: 
    1:   builder.LeavePresShell(aFrame, dirtyRect);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
51851:   if (builder.GetHadToIgnorePaintSuppression()) {
80486:     willFlushRetainedLayers = true;
51851:   }
51851: 
82351: #ifdef MOZ_DUMP_PAINTING
94286:   if (gfxUtils::sDumpPaintList || gfxUtils::sDumpPainting) {
91338:     if (gfxUtils::sDumpPaintingToFile) {
91338:       nsCString string("dump-");
91338:       string.AppendInt(gPaintCount);
91338:       string.Append(".html");
91338:       gfxUtils::sDumpPaintFile = fopen(string.BeginReading(), "w");
91338:     } else {
91338:       gfxUtils::sDumpPaintFile = stdout;
91338:     }
91338:     fprintf(gfxUtils::sDumpPaintFile, "<html><head><script>var array = {}; function ViewImage(index) { window.location = array[index]; }</script></head><body>");
91338:     fprintf(gfxUtils::sDumpPaintFile, "Painting --- before optimization (dirty %d,%d,%d,%d):\n",
    1:             dirtyRect.x, dirtyRect.y, dirtyRect.width, dirtyRect.height);
91338:     nsFrame::PrintDisplayList(&builder, list, gfxUtils::sDumpPaintFile);
91338:     if (gfxUtils::sDumpPaintingToFile) {
91338:       fprintf(gfxUtils::sDumpPaintFile, "<script>");
91338:     }
    1:   }
    1: #endif
    1: 
51633:   list.ComputeVisibilityForRoot(&builder, &visibleRegion);
    1: 
38805:   PRUint32 flags = nsDisplayList::PAINT_DEFAULT;
38805:   if (aFlags & PAINT_WIDGET_LAYERS) {
38805:     flags |= nsDisplayList::PAINT_USE_WIDGET_LAYERS;
54080:     if (willFlushRetainedLayers) {
54080:       // The caller wanted to paint from retained layers, but set up
54080:       // the paint in such a way that we can't use them.  We're going
54080:       // to display something different from what we'd normally paint
54080:       // in a window, so make sure we flush out any retained layer
54080:       // trees before *and after* we draw.  Callers should be fixed to
54080:       // not do this.
54080:       NS_WARNING("Flushing retained layers!");
47739:       flags |= nsDisplayList::PAINT_FLUSH_LAYERS;
62767:     } else if (!(aFlags & PAINT_DOCUMENT_RELATIVE)) {
63893:       nsIWidget *widget = aFrame->GetNearestWidget();
63893:       if (widget) {
59778:         builder.SetFinalTransparentRegion(visibleRegion);
60643:         // If we're finished building display list items for painting of the outermost
60643:         // pres shell, notify the widget about any toolbars we've encountered.
63893:         widget->UpdateThemeGeometries(builder.GetThemeGeometries());
38805:       }
47739:     }
62767:   }
60857:   if (aFlags & PAINT_EXISTING_TRANSACTION) {
60857:     flags |= nsDisplayList::PAINT_EXISTING_TRANSACTION;
60857:   }
47738: 
42246:   list.PaintRoot(&builder, aRenderingContext, flags);
47738: 
69805:   // Update the widget's opaque region information. This sets
62767:   // glass boundaries on Windows.
62767:   if ((aFlags & PAINT_WIDGET_LAYERS) &&
62767:       !willFlushRetainedLayers &&
62767:       !(aFlags & PAINT_DOCUMENT_RELATIVE)) {
63893:     nsIWidget *widget = aFrame->GetNearestWidget();
63893:     if (widget) {
69805:       nsRegion excludedRegion = builder.GetExcludedGlassRegion();
69805:       excludedRegion.Sub(excludedRegion, visibleRegion);
69805:       nsIntRegion windowRegion(excludedRegion.ToNearestPixels(presContext->AppUnitsPerDevPixel()));
69805:       widget->UpdateOpaqueRegion(windowRegion);
62767:     }
62767:   }
62767: 
82351: #ifdef MOZ_DUMP_PAINTING
94286:   if (gfxUtils::sDumpPaintList || gfxUtils::sDumpPainting) {
91338:     fprintf(gfxUtils::sDumpPaintFile, "</script>Painting --- after optimization:\n");
91338:     nsFrame::PrintDisplayList(&builder, list, gfxUtils::sDumpPaintFile);
91338: 
91338:     fprintf(gfxUtils::sDumpPaintFile, "Painting --- retained layer tree:\n");
91338:     builder.LayerBuilder()->DumpRetainedLayerTree(gfxUtils::sDumpPaintFile);
91338:     fprintf(gfxUtils::sDumpPaintFile, "</body></html>");
91338:     
91338:     if (gfxUtils::sDumpPaintingToFile) {
91338:       fclose(gfxUtils::sDumpPaintFile);
91338:     }
91338:     gfxUtils::sDumpPaintFile = NULL;
91338:     gPaintCount++;
47738:   }
47738: #endif
47738: 
    1:   // Flush the list so we don't trigger the IsEmpty-on-destruction assertion
    1:   list.DeleteAll();
    1:   return NS_OK;
    1: }
    1: 
    1: PRInt32
    1: nsLayoutUtils::GetZIndex(nsIFrame* aFrame) {
    1:   if (!aFrame->GetStyleDisplay()->IsPositioned())
    1:     return 0;
    1: 
    1:   const nsStylePosition* position =
    1:     aFrame->GetStylePosition();
    1:   if (position->mZIndex.GetUnit() == eStyleUnit_Integer)
    1:     return position->mZIndex.GetIntValue();
    1: 
    1:   // sort the auto and 0 elements together
    1:   return 0;
    1: }
    1: 
    1: /**
    1:  * Uses a binary search for find where the cursor falls in the line of text
    1:  * It also keeps track of the part of the string that has already been measured
    1:  * so it doesn't have to keep measuring the same text over and over
    1:  *
    1:  * @param "aBaseWidth" contains the width in twips of the portion
    1:  * of the text that has already been measured, and aBaseInx contains
    1:  * the index of the text that has already been measured.
    1:  *
    1:  * @param aTextWidth returns the (in twips) the length of the text that falls
    1:  * before the cursor aIndex contains the index of the text where the cursor falls
    1:  */
79445: bool
68481: nsLayoutUtils::BinarySearchForPosition(nsRenderingContext* aRendContext,
    1:                         const PRUnichar* aText,
    1:                         PRInt32    aBaseWidth,
    1:                         PRInt32    aBaseInx,
    1:                         PRInt32    aStartInx,
    1:                         PRInt32    aEndInx,
    1:                         PRInt32    aCursorPos,
    1:                         PRInt32&   aIndex,
    1:                         PRInt32&   aTextWidth)
    1: {
    1:   PRInt32 range = aEndInx - aStartInx;
    1:   if ((range == 1) || (range == 2 && NS_IS_HIGH_SURROGATE(aText[aStartInx]))) {
    1:     aIndex   = aStartInx + aBaseInx;
68484:     aTextWidth = aRendContext->GetWidth(aText, aIndex);
80486:     return true;
    1:   }
    1: 
    1:   PRInt32 inx = aStartInx + (range / 2);
    1: 
    1:   // Make sure we don't leave a dangling low surrogate
    1:   if (NS_IS_HIGH_SURROGATE(aText[inx-1]))
    1:     inx++;
    1: 
68484:   PRInt32 textWidth = aRendContext->GetWidth(aText, inx);
    1: 
    1:   PRInt32 fullWidth = aBaseWidth + textWidth;
    1:   if (fullWidth == aCursorPos) {
    1:     aTextWidth = textWidth;
    1:     aIndex = inx;
80486:     return true;
    1:   } else if (aCursorPos < fullWidth) {
    1:     aTextWidth = aBaseWidth;
    1:     if (BinarySearchForPosition(aRendContext, aText, aBaseWidth, aBaseInx, aStartInx, inx, aCursorPos, aIndex, aTextWidth)) {
80486:       return true;
    1:     }
    1:   } else {
    1:     aTextWidth = fullWidth;
    1:     if (BinarySearchForPosition(aRendContext, aText, aBaseWidth, aBaseInx, inx, aEndInx, aCursorPos, aIndex, aTextWidth)) {
80486:       return true;
80486:     }
80486:   }
80486:   return false;
    1: }
    1: 
12349: static void
19125: AddBoxesForFrame(nsIFrame* aFrame,
19125:                  nsLayoutUtils::BoxCallback* aCallback)
    1: {
34387:   nsIAtom* pseudoType = aFrame->GetStyleContext()->GetPseudo();
    1: 
12349:   if (pseudoType == nsCSSAnonBoxes::tableOuter) {
77154:     AddBoxesForFrame(aFrame->GetFirstPrincipalChild(), aCallback);
77154:     nsIFrame* kid = aFrame->GetFirstChild(nsIFrame::kCaptionList);
12349:     if (kid) {
19125:       AddBoxesForFrame(kid, aCallback);
12349:     }
12349:   } else if (pseudoType == nsCSSAnonBoxes::mozAnonymousBlock ||
12349:              pseudoType == nsCSSAnonBoxes::mozAnonymousPositionedBlock ||
12349:              pseudoType == nsCSSAnonBoxes::mozMathMLAnonymousBlock ||
12349:              pseudoType == nsCSSAnonBoxes::mozXULAnonymousBlock) {
77154:     for (nsIFrame* kid = aFrame->GetFirstPrincipalChild(); kid; kid = kid->GetNextSibling()) {
19125:       AddBoxesForFrame(kid, aCallback);
12349:     }
12349:   } else {
19125:     aCallback->AddBox(aFrame);
19125:   }
19125: }
19125: 
19125: void
19125: nsLayoutUtils::GetAllInFlowBoxes(nsIFrame* aFrame, BoxCallback* aCallback)
19125: {
19125:   while (aFrame) {
19125:     AddBoxesForFrame(aFrame, aCallback);
19125:     aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame);
19125:   }
19125: }
19125: 
19125: struct BoxToBorderRect : public nsLayoutUtils::BoxCallback {
19125:   nsIFrame* mRelativeTo;
19125:   nsLayoutUtils::RectCallback* mCallback;
86354:   PRUint32 mFlags;
86354: 
86354:   BoxToBorderRect(nsIFrame* aRelativeTo, nsLayoutUtils::RectCallback* aCallback,
86354:                   PRUint32 aFlags)
86354:     : mRelativeTo(aRelativeTo), mCallback(aCallback), mFlags(aFlags) {}
19125: 
19125:   virtual void AddBox(nsIFrame* aFrame) {
12349:     nsRect r;
12349:     nsIFrame* outer = nsSVGUtils::GetOuterSVGFrameAndCoveredRegion(aFrame, &r);
86354:     if (!outer) {
86354:       outer = aFrame;
86354:       r = nsRect(nsPoint(0, 0), aFrame->GetSize());
86354:     }
86354:     if (mFlags & nsLayoutUtils::RECTS_ACCOUNT_FOR_TRANSFORMS) {
86354:       r = nsLayoutUtils::TransformFrameRectToAncestor(outer, r, mRelativeTo);
86354:     } else {
86354:       r += outer->GetOffsetTo(mRelativeTo);
86354:     }
86354:     mCallback->AddRect(r);
12349:   }
19125: };
    1: 
12349: void
12349: nsLayoutUtils::GetAllInFlowRects(nsIFrame* aFrame, nsIFrame* aRelativeTo,
86354:                                  RectCallback* aCallback, PRUint32 aFlags)
12349: {
86354:   BoxToBorderRect converter(aRelativeTo, aCallback, aFlags);
19125:   GetAllInFlowBoxes(aFrame, &converter);
    1: }
    1: 
80486: nsLayoutUtils::RectAccumulator::RectAccumulator() : mSeenFirstRect(false) {}
33027: 
33027: void nsLayoutUtils::RectAccumulator::AddRect(const nsRect& aRect) {
12349:   mResultRect.UnionRect(mResultRect, aRect);
12349:   if (!mSeenFirstRect) {
80486:     mSeenFirstRect = true;
12349:     mFirstRect = aRect;
12349:   }
12349: }
33027: 
33027: nsLayoutUtils::RectListBuilder::RectListBuilder(nsClientRectList* aList)
33027:   : mRectList(aList), mRV(NS_OK) {}
33027: 
33027: void nsLayoutUtils::RectListBuilder::AddRect(const nsRect& aRect) {
33027:   nsRefPtr<nsClientRect> rect = new nsClientRect();
33027: 
33027:   rect->SetLayoutRect(aRect);
33027:   mRectList->Append(rect);
33027: }
33027: 
33027: nsIFrame* nsLayoutUtils::GetContainingBlockForClientRect(nsIFrame* aFrame)
33027: {
86354:   return aFrame->PresContext()->PresShell()->GetRootFrame();
33027: }
12349: 
12349: nsRect
86354: nsLayoutUtils::GetAllInFlowRectsUnion(nsIFrame* aFrame, nsIFrame* aRelativeTo,
86354:                                       PRUint32 aFlags) {
12349:   RectAccumulator accumulator;
86354:   GetAllInFlowRects(aFrame, aRelativeTo, &accumulator, aFlags);
12349:   return accumulator.mResultRect.IsEmpty() ? accumulator.mFirstRect
12349:           : accumulator.mResultRect;
    1: }
    1: 
15339: nsRect
15339: nsLayoutUtils::GetTextShadowRectsUnion(const nsRect& aTextAndDecorationsRect,
59781:                                        nsIFrame* aFrame,
59781:                                        PRUint32 aFlags)
15339: {
15339:   const nsStyleText* textStyle = aFrame->GetStyleText();
15699:   if (!textStyle->mTextShadow)
15339:     return aTextAndDecorationsRect;
15339: 
15339:   nsRect resultRect = aTextAndDecorationsRect;
52476:   PRInt32 A2D = aFrame->PresContext()->AppUnitsPerDevPixel();
15699:   for (PRUint32 i = 0; i < textStyle->mTextShadow->Length(); ++i) {
59781:     nsCSSShadowItem* shadow = textStyle->mTextShadow->ShadowAt(i);
59781:     nsMargin blur = nsContextBoxBlur::GetBlurRadiusMargin(shadow->mRadius, A2D);
59781:     if ((aFlags & EXCLUDE_BLUR_SHADOWS) && blur != nsMargin(0, 0, 0, 0))
59781:       continue;
59781: 
15339:     nsRect tmpRect(aTextAndDecorationsRect);
15339: 
19207:     tmpRect.MoveBy(nsPoint(shadow->mXOffset, shadow->mYOffset));
59781:     tmpRect.Inflate(blur);
15339: 
15339:     resultRect.UnionRect(resultRect, tmpRect);
15339:   }
15339:   return resultRect;
15339: }
15339: 
    1: nsresult
56866: nsLayoutUtils::GetFontMetricsForFrame(const nsIFrame* aFrame,
82672:                                       nsFontMetrics** aFontMetrics,
82672:                                       float aInflation)
    1: {
 4355:   return nsLayoutUtils::GetFontMetricsForStyleContext(aFrame->GetStyleContext(),
82672:                                                       aFontMetrics,
82672:                                                       aInflation);
 4355: }
 4355: 
 4355: nsresult
 4355: nsLayoutUtils::GetFontMetricsForStyleContext(nsStyleContext* aStyleContext,
82672:                                              nsFontMetrics** aFontMetrics,
82672:                                              float aInflation)
 4355: {
19962:   // pass the user font set object into the device context to pass along to CreateFontGroup
19962:   gfxUserFontSet* fs = aStyleContext->PresContext()->GetUserFontSet();
19962: 
82672:   nsFont font = aStyleContext->GetStyleFont()->mFont;
82672:   // We need to not run font.size through floats when it's large since
82672:   // doing so would be lossy.  Fortunately, in such cases, aInflation is
82672:   // guaranteed to be 1.0f.
82672:   if (aInflation != 1.0f) {
82672:     font.size = NSToCoordRound(font.size * aInflation);
82672:   }
19962:   return aStyleContext->PresContext()->DeviceContext()->GetMetricsFor(
88039:                   font, aStyleContext->GetStyleFont()->mLanguage,
22335:                   fs, *aFontMetrics);
    1: }
    1: 
    1: nsIFrame*
    1: nsLayoutUtils::FindChildContainingDescendant(nsIFrame* aParent, nsIFrame* aDescendantFrame)
    1: {
    1:   nsIFrame* result = aDescendantFrame;
    1: 
    1:   while (result) {
    1:     nsIFrame* parent = result->GetParent();
    1:     if (parent == aParent) {
    1:       break;
    1:     }
    1: 
    1:     // The frame is not an immediate child of aParent so walk up another level
    1:     result = parent;
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: nsBlockFrame*
 9572: nsLayoutUtils::GetAsBlock(nsIFrame* aFrame)
 9572: {
23554:   nsBlockFrame* block = do_QueryFrame(aFrame);
 9572:   return block;
 9572: }
 9572: 
 9572: nsBlockFrame*
    1: nsLayoutUtils::FindNearestBlockAncestor(nsIFrame* aFrame)
    1: {
    1:   nsIFrame* nextAncestor;
    1:   for (nextAncestor = aFrame->GetParent(); nextAncestor;
    1:        nextAncestor = nextAncestor->GetParent()) {
 9572:     nsBlockFrame* block = GetAsBlock(nextAncestor);
 9572:     if (block)
    1:       return block;
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: nsIFrame*
21943: nsLayoutUtils::GetNonGeneratedAncestor(nsIFrame* aFrame)
21943: {
21943:   if (!(aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT))
21943:     return aFrame;
21943: 
21943:   nsFrameManager* frameManager = aFrame->PresContext()->FrameManager();
21943:   nsIFrame* f = aFrame;
21943:   do {
21943:     f = GetParentOrPlaceholderFor(frameManager, f);
21943:   } while (f->GetStateBits() & NS_FRAME_GENERATED_CONTENT);
21943:   return f;
21943: }
21943: 
21943: nsIFrame*
    1: nsLayoutUtils::GetParentOrPlaceholderFor(nsFrameManager* aFrameManager,
    1:                                          nsIFrame* aFrame)
    1: {
 6521:   if ((aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
32108:       && !aFrame->GetPrevInFlow()) {
    1:     return aFrameManager->GetPlaceholderFrameFor(aFrame);
 6521:   }
    1:   return aFrame->GetParent();
    1: }
    1: 
    1: nsIFrame*
   94: nsLayoutUtils::GetNextContinuationOrSpecialSibling(nsIFrame *aFrame)
   94: {
   94:   nsIFrame *result = aFrame->GetNextContinuation();
   94:   if (result)
   94:     return result;
   94: 
   94:   if ((aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0) {
   94:     // We only store the "special sibling" annotation with the first
27338:     // frame in the continuation chain. Walk back to find that frame now.
27338:     aFrame = aFrame->GetFirstContinuation();
   94: 
39965:     void* value = aFrame->Properties().Get(nsIFrame::IBSplitSpecialSibling());
 3233:     return static_cast<nsIFrame*>(value);
   94:   }
   94: 
   94:   return nsnull;
   94: }
   94: 
19125: nsIFrame*
19125: nsLayoutUtils::GetFirstContinuationOrSpecialSibling(nsIFrame *aFrame)
19125: {
19125:   nsIFrame *result = aFrame->GetFirstContinuation();
19125:   if (result->GetStateBits() & NS_FRAME_IS_SPECIAL) {
80486:     while (true) {
19125:       nsIFrame *f = static_cast<nsIFrame*>
39965:         (result->Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
19125:       if (!f)
19125:         break;
19125:       result = f;
19125:     }
19125:   }
19125: 
19125:   return result;
19125: }
19125: 
79445: bool
    1: nsLayoutUtils::IsViewportScrollbarFrame(nsIFrame* aFrame)
    1: {
    1:   if (!aFrame)
80486:     return false;
    1: 
    1:   nsIFrame* rootScrollFrame =
  238:     aFrame->PresContext()->PresShell()->GetRootScrollFrame();
    1:   if (!rootScrollFrame)
80486:     return false;
    1: 
23554:   nsIScrollableFrame* rootScrollableFrame = do_QueryFrame(rootScrollFrame);
    1:   NS_ASSERTION(rootScrollableFrame, "The root scorollable frame is null");
    1: 
    1:   if (!IsProperAncestorFrame(rootScrollFrame, aFrame))
80486:     return false;
    1: 
    1:   nsIFrame* rootScrolledFrame = rootScrollableFrame->GetScrolledFrame();
    1:   return !(rootScrolledFrame == aFrame ||
    1:            IsProperAncestorFrame(rootScrolledFrame, aFrame));
    1: }
    1: 
    1: static nscoord AddPercents(nsLayoutUtils::IntrinsicWidthType aType,
    1:                            nscoord aCurrent, float aPercent)
    1: {
    1:   nscoord result = aCurrent;
    1:   if (aPercent > 0.0f && aType == nsLayoutUtils::PREF_WIDTH) {
    1:     // XXX Should we also consider percentages for min widths, up to a
    1:     // limit?
    1:     if (aPercent >= 1.0f)
    1:       result = nscoord_MAX;
    1:     else
    1:       result = NSToCoordRound(float(result) / (1.0f - aPercent));
    1:   }
    1:   return result;
    1: }
    1: 
51406: // Use only for widths/heights (or their min/max), since it clamps
51406: // negative calc() results to 0.
79445: static bool GetAbsoluteCoord(const nsStyleCoord& aStyle, nscoord& aResult)
16031: {
49566:   if (aStyle.IsCalcUnit()) {
49566:     if (aStyle.CalcHasPercent()) {
80486:       return false;
49566:     }
49566:     // If it has no percents, we can pass 0 for the percentage basis.
49566:     aResult = nsRuleNode::ComputeComputedCalc(aStyle, 0);
51406:     if (aResult < 0)
51406:       aResult = 0;
80486:     return true;
49566:   }
49566: 
16031:   if (eStyleUnit_Coord != aStyle.GetUnit())
80486:     return false;
16031: 
16031:   aResult = aStyle.GetCoordValue();
51406:   NS_ASSERTION(aResult >= 0, "negative widths not allowed");
80486:   return true;
16031: }
16031: 
79445: static bool
 2301: GetPercentHeight(const nsStyleCoord& aStyle,
 2301:                  nsIFrame* aFrame,
 2301:                  nscoord& aResult)
 2301: {
 2301:   if (eStyleUnit_Percent != aStyle.GetUnit())
80486:     return false;
 2301: 
79487:   nsIFrame *f = aFrame->GetContainingBlock();
 2301:   if (!f) {
 2301:     NS_NOTREACHED("top of frame tree not a containing block");
80486:     return false;
 2301:   }
 2301: 
 2301:   const nsStylePosition *pos = f->GetStylePosition();
 2301:   nscoord h;
16031:   if (!GetAbsoluteCoord(pos->mHeight, h) &&
16031:       !GetPercentHeight(pos->mHeight, f, h)) {
 2301:     NS_ASSERTION(pos->mHeight.GetUnit() == eStyleUnit_Auto ||
51406:                  pos->mHeight.HasPercent(),
 2301:                  "unknown height unit");
48945:     nsIAtom* fType = f->GetType();
48945:     if (fType != nsGkAtoms::viewportFrame && fType != nsGkAtoms::canvasFrame &&
48945:         fType != nsGkAtoms::pageContentFrame) {
 2301:       // There's no basis for the percentage height, so it acts like auto.
 2301:       // Should we consider a max-height < min-height pair a basis for
 2301:       // percentage heights?  The spec is somewhat unclear, and not doing
 2301:       // so is simpler and avoids troubling discontinuities in behavior,
 2301:       // so I'll choose not to. -LDB
80486:       return false;
 2301:     }
 2301: 
48945:     NS_ASSERTION(pos->mHeight.GetUnit() == eStyleUnit_Auto,
48945:                  "Unexpected height unit for viewport or canvas or page-content");
48945:     // For the viewport, canvas, and page-content kids, the percentage
48945:     // basis is just the parent height.
48945:     h = f->GetSize().height;
48945:     if (h == NS_UNCONSTRAINEDSIZE) {
48945:       // We don't have a percentage basis after all
80486:       return false;
48945:     }
48945:   }
48945: 
 2301:   nscoord maxh;
16031:   if (GetAbsoluteCoord(pos->mMaxHeight, maxh) ||
16031:       GetPercentHeight(pos->mMaxHeight, f, maxh)) {
 2301:     if (maxh < h)
 2301:       h = maxh;
 2301:   } else {
 2301:     NS_ASSERTION(pos->mMaxHeight.GetUnit() == eStyleUnit_None ||
51406:                  pos->mMaxHeight.HasPercent(),
 2301:                  "unknown max-height unit");
 2301:   }
 2301: 
 2301:   nscoord minh;
16031:   if (GetAbsoluteCoord(pos->mMinHeight, minh) ||
16031:       GetPercentHeight(pos->mMinHeight, f, minh)) {
 2301:     if (minh > h)
 2301:       h = minh;
 2301:   } else {
51406:     NS_ASSERTION(pos->mMinHeight.HasPercent(),
 2301:                  "unknown min-height unit");
 2301:   }
 2301: 
 2301:   aResult = NSToCoordRound(aStyle.GetPercentValue() * h);
80486:   return true;
 2301: }
 2301: 
 8046: // Handles only -moz-max-content and -moz-min-content, and
 8046: // -moz-fit-content for min-width and max-width, since the others
 8046: // (-moz-fit-content for width, and -moz-available) have no effect on
 1068: // intrinsic widths.
 1068: enum eWidthProperty { PROP_WIDTH, PROP_MAX_WIDTH, PROP_MIN_WIDTH };
79445: static bool
 1068: GetIntrinsicCoord(const nsStyleCoord& aStyle,
68481:                   nsRenderingContext* aRenderingContext,
 1068:                   nsIFrame* aFrame,
 1068:                   eWidthProperty aProperty,
 1068:                   nscoord& aResult)
 1068: {
 1068:   NS_PRECONDITION(aProperty == PROP_WIDTH || aProperty == PROP_MAX_WIDTH ||
 1068:                   aProperty == PROP_MIN_WIDTH, "unexpected property");
 1068:   if (aStyle.GetUnit() != eStyleUnit_Enumerated)
80486:     return false;
 1068:   PRInt32 val = aStyle.GetIntValue();
 8046:   NS_ASSERTION(val == NS_STYLE_WIDTH_MAX_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_MIN_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_FIT_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_AVAILABLE,
 1068:                "unexpected enumerated value for width property");
 8046:   if (val == NS_STYLE_WIDTH_AVAILABLE)
80486:     return false;
 8046:   if (val == NS_STYLE_WIDTH_FIT_CONTENT) {
 1068:     if (aProperty == PROP_WIDTH)
80486:       return false; // handle like 'width: auto'
 1068:     if (aProperty == PROP_MAX_WIDTH)
 8046:       // constrain large 'width' values down to -moz-max-content
 8046:       val = NS_STYLE_WIDTH_MAX_CONTENT;
 1068:     else
 8046:       // constrain small 'width' or 'max-width' values up to -moz-min-content
 8046:       val = NS_STYLE_WIDTH_MIN_CONTENT;
 1068:   }
 1068: 
 8046:   NS_ASSERTION(val == NS_STYLE_WIDTH_MAX_CONTENT ||
 8046:                val == NS_STYLE_WIDTH_MIN_CONTENT,
 1068:                "should have reduced everything remaining to one of these");
88122: 
88122:   // If aFrame is a container for font size inflation, then shrink
88122:   // wrapping inside of it should not apply font size inflation.
88122:   AutoMaybeNullInflationContainer an(aFrame);
88122: 
 8046:   if (val == NS_STYLE_WIDTH_MAX_CONTENT)
 1068:     aResult = aFrame->GetPrefWidth(aRenderingContext);
 1068:   else
 1068:     aResult = aFrame->GetMinWidth(aRenderingContext);
80486:   return true;
 1068: }
 1068: 
    1: #undef  DEBUG_INTRINSIC_WIDTH
    1: 
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1: static PRInt32 gNoiseIndent = 0;
    1: #endif
    1: 
    1: /* static */ nscoord
68481: nsLayoutUtils::IntrinsicForContainer(nsRenderingContext *aRenderingContext,
    1:                                      nsIFrame *aFrame,
    1:                                      IntrinsicWidthType aType)
    1: {
    1:   NS_PRECONDITION(aFrame, "null frame");
    1:   NS_PRECONDITION(aType == MIN_WIDTH || aType == PREF_WIDTH, "bad type");
    1: 
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:   nsFrame::IndentBy(stdout, gNoiseIndent);
 3233:   static_cast<nsFrame*>(aFrame)->ListTag(stdout);
    1:   printf(" %s intrinsic width for container:\n",
    1:          aType == MIN_WIDTH ? "min" : "pref");
    1: #endif
    1: 
88122:   // If aFrame is a container for font size inflation, then shrink
88122:   // wrapping inside of it should not apply font size inflation.
88122:   AutoMaybeNullInflationContainer an(aFrame);
88122: 
    1:   nsIFrame::IntrinsicWidthOffsetData offsets =
    1:     aFrame->IntrinsicWidthOffsets(aRenderingContext);
    1: 
    1:   const nsStylePosition *stylePos = aFrame->GetStylePosition();
 1068:   PRUint8 boxSizing = stylePos->mBoxSizing;
    1:   const nsStyleCoord &styleWidth = stylePos->mWidth;
    1:   const nsStyleCoord &styleMinWidth = stylePos->mMinWidth;
    1:   const nsStyleCoord &styleMaxWidth = stylePos->mMaxWidth;
    1: 
    1:   // We build up two values starting with the content box, and then
    1:   // adding padding, border and margin.  The result is normally
    1:   // |result|.  Then, when we handle 'width', 'min-width', and
    1:   // 'max-width', we use the results we've been building in |min| as a
    1:   // minimum, overriding 'min-width'.  This ensures two things:
    1:   //   * that we don't let a value of 'box-sizing' specifying a width
    1:   //     smaller than the padding/border inside the box-sizing box give
    1:   //     a content width less than zero
    1:   //   * that we prevent tables from becoming smaller than their
    1:   //     intrinsic minimum width
    1:   nscoord result = 0, min = 0;
    1: 
51407:   nscoord maxw;
79445:   bool haveFixedMaxWidth = GetAbsoluteCoord(styleMaxWidth, maxw);
51407:   nscoord minw;
79445:   bool haveFixedMinWidth = GetAbsoluteCoord(styleMinWidth, minw);
51407: 
    1:   // If we have a specified width (or a specified 'min-width' greater
    1:   // than the specified 'max-width', which works out to the same thing),
    1:   // don't even bother getting the frame's intrinsic width.
 1068:   if (styleWidth.GetUnit() == eStyleUnit_Enumerated &&
 8046:       (styleWidth.GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT ||
 8046:        styleWidth.GetIntValue() == NS_STYLE_WIDTH_MIN_CONTENT)) {
 8046:     // -moz-fit-content and -moz-available enumerated widths compute intrinsic
 1068:     // widths just like auto.
 8046:     // For -moz-max-content and -moz-min-content, we handle them like
 1068:     // specified widths, but ignore -moz-box-sizing.
 1068:     boxSizing = NS_STYLE_BOX_SIZING_CONTENT;
 1068:   } else if (styleWidth.GetUnit() != eStyleUnit_Coord &&
51407:              !(haveFixedMinWidth && haveFixedMaxWidth && maxw <= minw)) {
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:     ++gNoiseIndent;
    1: #endif
    1:     if (aType == MIN_WIDTH)
    1:       result = aFrame->GetMinWidth(aRenderingContext);
    1:     else
    1:       result = aFrame->GetPrefWidth(aRenderingContext);
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:     --gNoiseIndent;
    1:     nsFrame::IndentBy(stdout, gNoiseIndent);
 3233:     static_cast<nsFrame*>(aFrame)->ListTag(stdout);
    1:     printf(" %s intrinsic width from frame is %d.\n",
    1:            aType == MIN_WIDTH ? "min" : "pref", result);
    1: #endif
 2301: 
 2301:     // Handle elements with an intrinsic ratio (or size) and a specified
 2301:     // height, min-height, or max-height.
 2301:     const nsStyleCoord &styleHeight = stylePos->mHeight;
 2301:     const nsStyleCoord &styleMinHeight = stylePos->mMinHeight;
 2301:     const nsStyleCoord &styleMaxHeight = stylePos->mMaxHeight;
 2301:     if (styleHeight.GetUnit() != eStyleUnit_Auto ||
 2301:         !(styleMinHeight.GetUnit() == eStyleUnit_Coord &&
 2301:           styleMinHeight.GetCoordValue() == 0) ||
 2301:         styleMaxHeight.GetUnit() != eStyleUnit_None) {
 2301: 
 2301:       nsSize ratio = aFrame->GetIntrinsicRatio();
 2301: 
 2301:       if (ratio.height != 0) {
 2301: 
 2301:         nscoord h;
16031:         if (GetAbsoluteCoord(styleHeight, h) ||
16031:             GetPercentHeight(styleHeight, aFrame, h)) {
 2301:           result =
 2301:             NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
 2301:         }
 2301: 
16031:         if (GetAbsoluteCoord(styleMaxHeight, h) ||
16031:             GetPercentHeight(styleMaxHeight, aFrame, h)) {
 2301:           h = NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
 2301:           if (h < result)
 2301:             result = h;
 2301:         }
 2301: 
16031:         if (GetAbsoluteCoord(styleMinHeight, h) ||
16031:             GetPercentHeight(styleMinHeight, aFrame, h)) {
 2301:           h = NSToCoordRound(h * (float(ratio.width) / float(ratio.height)));
 2301:           if (h > result)
 2301:             result = h;
 2301:         }
 2301:       }
 2301:     }
    1:   }
    1: 
    1:   if (aFrame->GetType() == nsGkAtoms::tableFrame) {
    1:     // Tables can't shrink smaller than their intrinsic minimum width,
    1:     // no matter what.
    1:     min = aFrame->GetMinWidth(aRenderingContext);
    1:   }
    1: 
    1:   // We also need to track what has been added on outside of the box
    1:   // (controlled by 'box-sizing') where 'width', 'min-width' and
    1:   // 'max-width' are applied.  We have to account for these properties
    1:   // after getting all the offsets (margin, border, padding) because
    1:   // percentages do not operate linearly.
    1:   // Doing this is ok because although percentages aren't handled
    1:   // linearly, they are handled monotonically.
    1:   nscoord coordOutsideWidth = offsets.hPadding;
    1:   float pctOutsideWidth = offsets.hPctPadding;
    1: 
    1:   float pctTotal = 0.0f;
    1: 
    1:   if (boxSizing == NS_STYLE_BOX_SIZING_PADDING) {
    1:     min += coordOutsideWidth;
 6254:     result = NSCoordSaturatingAdd(result, coordOutsideWidth);
    1:     pctTotal += pctOutsideWidth;
    1: 
    1:     coordOutsideWidth = 0;
    1:     pctOutsideWidth = 0.0f;
    1:   }
    1: 
    1:   coordOutsideWidth += offsets.hBorder;
    1: 
    1:   if (boxSizing == NS_STYLE_BOX_SIZING_BORDER) {
    1:     min += coordOutsideWidth;
 6254:     result = NSCoordSaturatingAdd(result, coordOutsideWidth);
    1:     pctTotal += pctOutsideWidth;
    1: 
    1:     coordOutsideWidth = 0;
    1:     pctOutsideWidth = 0.0f;
    1:   }
    1: 
    1:   coordOutsideWidth += offsets.hMargin;
    1:   pctOutsideWidth += offsets.hPctMargin;
    1: 
    1:   min += coordOutsideWidth;
 6254:   result = NSCoordSaturatingAdd(result, coordOutsideWidth);
    1:   pctTotal += pctOutsideWidth;
    1: 
    1:   nscoord w;
16031:   if (GetAbsoluteCoord(styleWidth, w) ||
 1068:       GetIntrinsicCoord(styleWidth, aRenderingContext, aFrame,
 1068:                         PROP_WIDTH, w)) {
    1:     result = AddPercents(aType, w + coordOutsideWidth, pctOutsideWidth);
    1:   }
49566:   else if (aType == MIN_WIDTH &&
49566:            // The only cases of coord-percent-calc() units that
49566:            // GetAbsoluteCoord didn't handle are percent and calc()s
49566:            // containing percent.
49566:            styleWidth.IsCoordPercentCalcUnit() &&
    1:            aFrame->IsFrameOfType(nsIFrame::eReplaced)) {
    1:     // A percentage width on replaced elements means they can shrink to 0.
    1:     result = 0; // let |min| handle padding/border/margin
    1:   }
    1:   else {
49566:     // NOTE: We could really do a lot better for percents and for some
49566:     // cases of calc() containing percent (certainly including any where
49566:     // the coefficient on the percent is positive and there are no max()
49566:     // expressions).  However, doing better for percents wouldn't be
49566:     // backwards compatible.
    1:     result = AddPercents(aType, result, pctTotal);
    1:   }
    1: 
51407:   if (haveFixedMaxWidth ||
 1068:       GetIntrinsicCoord(styleMaxWidth, aRenderingContext, aFrame,
 1068:                         PROP_MAX_WIDTH, maxw)) {
    1:     maxw = AddPercents(aType, maxw + coordOutsideWidth, pctOutsideWidth);
    1:     if (result > maxw)
    1:       result = maxw;
    1:   }
    1: 
51407:   if (haveFixedMinWidth ||
 1068:       GetIntrinsicCoord(styleMinWidth, aRenderingContext, aFrame,
 1068:                         PROP_MIN_WIDTH, minw)) {
    1:     minw = AddPercents(aType, minw + coordOutsideWidth, pctOutsideWidth);
    1:     if (result < minw)
    1:       result = minw;
    1:   }
    1: 
    1:   min = AddPercents(aType, min, pctTotal);
    1:   if (result < min)
    1:     result = min;
    1: 
    1:   const nsStyleDisplay *disp = aFrame->GetStyleDisplay();
    1:   if (aFrame->IsThemed(disp)) {
23738:     nsIntSize size(0, 0);
79445:     bool canOverride = true;
  238:     nsPresContext *presContext = aFrame->PresContext();
    1:     presContext->GetTheme()->
    1:       GetMinimumWidgetSize(aRenderingContext, aFrame, disp->mAppearance,
    1:                            &size, &canOverride);
    1: 
    1:     nscoord themeWidth = presContext->DevPixelsToAppUnits(size.width);
    1: 
    1:     // GMWS() returns a border-box width
    1:     themeWidth += offsets.hMargin;
    1:     themeWidth = AddPercents(aType, themeWidth, offsets.hPctMargin);
    1: 
    1:     if (themeWidth > result || !canOverride)
    1:       result = themeWidth;
    1:   }
    1: 
    1: #ifdef DEBUG_INTRINSIC_WIDTH
    1:   nsFrame::IndentBy(stdout, gNoiseIndent);
 3233:   static_cast<nsFrame*>(aFrame)->ListTag(stdout);
    1:   printf(" %s intrinsic width for container is %d twips.\n",
    1:          aType == MIN_WIDTH ? "min" : "pref", result);
    1: #endif
    1: 
    1:   return result;
    1: }
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::ComputeWidthDependentValue(
    1:                  nscoord              aContainingBlockWidth,
    1:                  const nsStyleCoord&  aCoord)
    1: {
46369:   NS_WARN_IF_FALSE(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
46369:                    "have unconstrained width; this should only result from "
46369:                    "very large sizes, not attempts at intrinsic width "
46369:                    "calculation");
    1: 
51403:   if (aCoord.IsCoordPercentCalcUnit()) {
51403:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, aContainingBlockWidth);
    1:   }
 1363:   NS_ASSERTION(aCoord.GetUnit() == eStyleUnit_None ||
 1068:                aCoord.GetUnit() == eStyleUnit_Auto,
 1068:                "unexpected width value");
    1:   return 0;
    1: }
    1: 
    1: /* static */ nscoord
 1068: nsLayoutUtils::ComputeWidthValue(
68481:                  nsRenderingContext* aRenderingContext,
 1068:                  nsIFrame*            aFrame,
 1068:                  nscoord              aContainingBlockWidth,
 1068:                  nscoord              aContentEdgeToBoxSizing,
 1068:                  nscoord              aBoxSizingToMarginEdge,
 1068:                  const nsStyleCoord&  aCoord)
 1068: {
 1068:   NS_PRECONDITION(aFrame, "non-null frame expected");
 1068:   NS_PRECONDITION(aRenderingContext, "non-null rendering context expected");
34267:   NS_WARN_IF_FALSE(aContainingBlockWidth != NS_UNCONSTRAINEDSIZE,
34267:                    "have unconstrained width; this should only result from "
34267:                    "very large sizes, not attempts at intrinsic width "
34267:                    "calculation");
 1068:   NS_PRECONDITION(aContainingBlockWidth >= 0,
 1068:                   "width less than zero");
 1068: 
 1068:   nscoord result;
49566:   if (aCoord.IsCoordPercentCalcUnit()) {
49566:     result = nsRuleNode::ComputeCoordPercentCalc(aCoord, aContainingBlockWidth);
49566:     // The result of a calc() expression might be less than 0; we
49566:     // should clamp at runtime (below).  (Percentages and coords that
49566:     // are less than 0 have already been dropped by the parser.)
 1068:     result -= aContentEdgeToBoxSizing;
 1068:   } else if (eStyleUnit_Enumerated == aCoord.GetUnit()) {
88122:     // If aFrame is a container for font size inflation, then shrink
88122:     // wrapping inside of it should not apply font size inflation.
88122:     AutoMaybeNullInflationContainer an(aFrame);
88122: 
 1068:     PRInt32 val = aCoord.GetIntValue();
 1068:     switch (val) {
 8046:       case NS_STYLE_WIDTH_MAX_CONTENT:
 1068:         result = aFrame->GetPrefWidth(aRenderingContext);
 1068:         NS_ASSERTION(result >= 0, "width less than zero");
 1068:         break;
 8046:       case NS_STYLE_WIDTH_MIN_CONTENT:
 1068:         result = aFrame->GetMinWidth(aRenderingContext);
 1068:         NS_ASSERTION(result >= 0, "width less than zero");
 1068:         break;
 8046:       case NS_STYLE_WIDTH_FIT_CONTENT:
 1068:         {
 1068:           nscoord pref = aFrame->GetPrefWidth(aRenderingContext),
 1068:                    min = aFrame->GetMinWidth(aRenderingContext),
 1068:                   fill = aContainingBlockWidth -
 1068:                          (aBoxSizingToMarginEdge + aContentEdgeToBoxSizing);
32531:           result = NS_MAX(min, NS_MIN(pref, fill));
 1068:           NS_ASSERTION(result >= 0, "width less than zero");
 1068:         }
 1068:         break;
 8046:       case NS_STYLE_WIDTH_AVAILABLE:
 1068:         result = aContainingBlockWidth -
 1068:                  (aBoxSizingToMarginEdge + aContentEdgeToBoxSizing);
 1068:     }
 1068:   } else {
 1068:     NS_NOTREACHED("unexpected width value");
 1068:     result = 0;
 1068:   }
 1068:   if (result < 0)
 1068:     result = 0;
 1068:   return result;
 1068: }
 1068: 
 1068: 
 1068: /* static */ nscoord
    1: nsLayoutUtils::ComputeHeightDependentValue(
    1:                  nscoord              aContainingBlockHeight,
    1:                  const nsStyleCoord&  aCoord)
    1: {
    1:   // XXXldb Some callers explicitly check aContainingBlockHeight
51403:   // against NS_AUTOHEIGHT *and* unit against eStyleUnit_Percent or
51403:   // calc()s containing percents before calling this function.
51403:   // However, it would be much more likely to catch problems without
51403:   // the unit conditions.
    1:   // XXXldb Many callers pass a non-'auto' containing block height when
    1:   // according to CSS2.1 they should be passing 'auto'.
51403:   NS_PRECONDITION(NS_AUTOHEIGHT != aContainingBlockHeight ||
51404:                   !aCoord.HasPercent(),
51403:                   "unexpected containing block height");
51403: 
51403:   if (aCoord.IsCoordPercentCalcUnit()) {
51403:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, aContainingBlockHeight);
51403:   }
51403: 
 1363:   NS_ASSERTION(aCoord.GetUnit() == eStyleUnit_None ||
 1068:                aCoord.GetUnit() == eStyleUnit_Auto,
 1068:                "unexpected height value");
    1:   return 0;
    1: }
    1: 
    1: #define MULDIV(a,b,c) (nscoord(PRInt64(a) * PRInt64(b) / PRInt64(c)))
    1: 
    1: /* static */ nsSize
    1: nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(
68481:                    nsRenderingContext* aRenderingContext, nsIFrame* aFrame,
 8147:                    const nsIFrame::IntrinsicSize& aIntrinsicSize,
 8142:                    nsSize aIntrinsicRatio, nsSize aCBSize,
 1068:                    nsSize aMargin, nsSize aBorder, nsSize aPadding)
    1: {
    1:   const nsStylePosition *stylePos = aFrame->GetStylePosition();
    1:   // Handle intrinsic sizes and their interaction with
    1:   // {min-,max-,}{width,height} according to the rules in
    1:   // http://www.w3.org/TR/CSS21/visudet.html#min-max-widths
    1: 
    1:   // Note: throughout the following section of the function, I avoid
    1:   // a * (b / c) because of its reduced accuracy relative to a * b / c
    1:   // or (a * b) / c (which are equivalent).
    1: 
79445:   const bool isAutoWidth = stylePos->mWidth.GetUnit() == eStyleUnit_Auto;
79445:   const bool isAutoHeight = IsAutoHeight(stylePos->mHeight, aCBSize.height);
    1: 
    1:   nsSize boxSizingAdjust(0,0);
    1:   switch (stylePos->mBoxSizing) {
    1:     case NS_STYLE_BOX_SIZING_BORDER:
    1:       boxSizingAdjust += aBorder;
    1:       // fall through
    1:     case NS_STYLE_BOX_SIZING_PADDING:
    1:       boxSizingAdjust += aPadding;
    1:   }
 1068:   nscoord boxSizingToMarginEdgeWidth =
 1068:     aMargin.width + aBorder.width + aPadding.width - boxSizingAdjust.width;
    1: 
    1:   nscoord width, minWidth, maxWidth, height, minHeight, maxHeight;
    1: 
    1:   if (!isAutoWidth) {
 1068:     width = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 1068:               aFrame, aCBSize.width, boxSizingAdjust.width,
 1068:               boxSizingToMarginEdgeWidth, stylePos->mWidth);
 1068:     NS_ASSERTION(width >= 0, "negative result from ComputeWidthValue");
    1:   }
    1: 
 1363:   if (stylePos->mMaxWidth.GetUnit() != eStyleUnit_None) {
 1068:     maxWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 1068:                  aFrame, aCBSize.width, boxSizingAdjust.width,
 1068:                  boxSizingToMarginEdgeWidth, stylePos->mMaxWidth);
 1068:     NS_ASSERTION(maxWidth >= 0, "negative result from ComputeWidthValue");
    1:   } else {
    1:     maxWidth = nscoord_MAX;
    1:   }
    1: 
 1068:   minWidth = nsLayoutUtils::ComputeWidthValue(aRenderingContext,
 1068:                aFrame, aCBSize.width, boxSizingAdjust.width,
 1068:                boxSizingToMarginEdgeWidth, stylePos->mMinWidth);
 1068:   NS_ASSERTION(minWidth >= 0, "negative result from ComputeWidthValue");
    1: 
    1:   if (!isAutoHeight) {
16031:     height = nsLayoutUtils::
51406:       ComputeHeightValue(aCBSize.height, stylePos->mHeight) -
    1:       boxSizingAdjust.height;
    1:     if (height < 0)
    1:       height = 0;
    1:   }
    1: 
    1:   if (!IsAutoHeight(stylePos->mMaxHeight, aCBSize.height)) {
16031:     maxHeight = nsLayoutUtils::
51406:       ComputeHeightValue(aCBSize.height, stylePos->mMaxHeight) -
    1:       boxSizingAdjust.height;
    1:     if (maxHeight < 0)
    1:       maxHeight = 0;
    1:   } else {
    1:     maxHeight = nscoord_MAX;
    1:   }
    1: 
    1:   if (!IsAutoHeight(stylePos->mMinHeight, aCBSize.height)) {
16031:     minHeight = nsLayoutUtils::
51406:       ComputeHeightValue(aCBSize.height, stylePos->mMinHeight) -
    1:       boxSizingAdjust.height;
    1:     if (minHeight < 0)
    1:       minHeight = 0;
    1:   } else {
    1:     minHeight = 0;
    1:   }
    1: 
 8142:   // Resolve percentage intrinsic width/height as necessary:
 8142: 
 8142:   NS_ASSERTION(aCBSize.width != NS_UNCONSTRAINEDSIZE,
 8142:                "Our containing block must not have unconstrained width!");
 8142: 
79445:   bool hasIntrinsicWidth, hasIntrinsicHeight;
 8142:   nscoord intrinsicWidth, intrinsicHeight;
 8142: 
71655:   if (aIntrinsicSize.width.GetUnit() == eStyleUnit_Coord) {
80486:     hasIntrinsicWidth = true;
71655:     intrinsicWidth = aIntrinsicSize.width.GetCoordValue();
71655:     if (intrinsicWidth < 0)
71655:       intrinsicWidth = 0;
 8142:   } else {
71655:     NS_ASSERTION(aIntrinsicSize.width.GetUnit() == eStyleUnit_None,
71655:                  "unexpected unit");
80486:     hasIntrinsicWidth = false;
 8142:     intrinsicWidth = 0;
 8142:   }
 8142: 
71655:   if (aIntrinsicSize.height.GetUnit() == eStyleUnit_Coord) {
80486:     hasIntrinsicHeight = true;
71655:     intrinsicHeight = aIntrinsicSize.height.GetCoordValue();
 8142:     if (intrinsicHeight < 0)
 8142:       intrinsicHeight = 0;
 8142:   } else {
71655:     NS_ASSERTION(aIntrinsicSize.height.GetUnit() == eStyleUnit_None,
71655:                  "unexpected unit");
80486:     hasIntrinsicHeight = false;
 8142:     intrinsicHeight = 0;
 8142:   }
 8142: 
 8142:   NS_ASSERTION(aIntrinsicRatio.width >= 0 && aIntrinsicRatio.height >= 0,
 8142:                "Intrinsic ratio has a negative component!");
 8142: 
 8142:   // Now calculate the used values for width and height:
 8142: 
    1:   if (isAutoWidth) {
    1:     if (isAutoHeight) {
    1: 
    1:       // 'auto' width, 'auto' height
 8142: 
 8142:       // Get tentative values - CSS 2.1 sections 10.3.2 and 10.6.2:
 8142: 
 8142:       nscoord tentWidth, tentHeight;
 8142: 
 8142:       if (hasIntrinsicWidth) {
 8142:         tentWidth = intrinsicWidth;
 8142:       } else if (hasIntrinsicHeight && aIntrinsicRatio.height > 0) {
 8142:         tentWidth = MULDIV(intrinsicHeight, aIntrinsicRatio.width, aIntrinsicRatio.height);
 8142:       } else if (aIntrinsicRatio.width > 0) {
 8142:         tentWidth = aCBSize.width - boxSizingToMarginEdgeWidth; // XXX scrollbar?
 8142:         if (tentWidth < 0) tentWidth = 0;
 8142:       } else {
 8142:         tentWidth = nsPresContext::CSSPixelsToAppUnits(300);
 8142:       }
 8142: 
 8142:       if (hasIntrinsicHeight) {
 8142:         tentHeight = intrinsicHeight;
 8142:       } else if (aIntrinsicRatio.width > 0) {
 8142:         tentHeight = MULDIV(tentWidth, aIntrinsicRatio.height, aIntrinsicRatio.width);
 8142:       } else {
 8142:         tentHeight = nsPresContext::CSSPixelsToAppUnits(150);
 8142:       }
 8142: 
74937:       return ComputeAutoSizeWithIntrinsicDimensions(minWidth, minHeight,
74937:                                                     maxWidth, maxHeight,
74937:                                                     tentWidth, tentHeight);
74937:     } else {
74937: 
74937:       // 'auto' width, non-'auto' height
74937:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
74937:       if (aIntrinsicRatio.height > 0) {
74937:         width = MULDIV(height, aIntrinsicRatio.width, aIntrinsicRatio.height);
74937:       } else if (hasIntrinsicWidth) {
74937:         width = intrinsicWidth;
74937:       } else {
74937:         width = nsPresContext::CSSPixelsToAppUnits(300);
74937:       }
74937:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
74937: 
74937:     }
74937:   } else {
74937:     if (isAutoHeight) {
74937: 
74937:       // non-'auto' width, 'auto' height
74937:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
74937:       if (aIntrinsicRatio.width > 0) {
74937:         height = MULDIV(width, aIntrinsicRatio.height, aIntrinsicRatio.width);
74937:       } else if (hasIntrinsicHeight) {
74937:         height = intrinsicHeight;
74937:       } else {
74937:         height = nsPresContext::CSSPixelsToAppUnits(150);
74937:       }
74937:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
74937: 
74937:     } else {
74937: 
74937:       // non-'auto' width, non-'auto' height
74937:       width = NS_CSS_MINMAX(width, minWidth, maxWidth);
74937:       height = NS_CSS_MINMAX(height, minHeight, maxHeight);
74937: 
74937:     }
74937:   }
74937: 
74937:   return nsSize(width, height);
74937: }
74937: 
74937: nsSize
74937: nsLayoutUtils::ComputeAutoSizeWithIntrinsicDimensions(nscoord minWidth, nscoord minHeight,
74937:                                                       nscoord maxWidth, nscoord maxHeight,
74937:                                                       nscoord tentWidth, nscoord tentHeight)
74937: {
 8142:   // Now apply min/max-width/height - CSS 2.1 sections 10.4 and 10.7:
 8142: 
    1:   if (minWidth > maxWidth)
    1:     maxWidth = minWidth;
    1:   if (minHeight > maxHeight)
    1:     maxHeight = minHeight;
    1: 
    1:   nscoord heightAtMaxWidth, heightAtMinWidth,
    1:           widthAtMaxHeight, widthAtMinHeight;
 8142: 
 8142:   if (tentWidth > 0) {
 8142:     heightAtMaxWidth = MULDIV(maxWidth, tentHeight, tentWidth);
    1:     if (heightAtMaxWidth < minHeight)
    1:       heightAtMaxWidth = minHeight;
 8142:     heightAtMinWidth = MULDIV(minWidth, tentHeight, tentWidth);
    1:     if (heightAtMinWidth > maxHeight)
    1:       heightAtMinWidth = maxHeight;
    1:   } else {
76754:     heightAtMaxWidth = heightAtMinWidth = NS_CSS_MINMAX(tentHeight, minHeight, maxHeight);
    1:   }
    1: 
 8142:   if (tentHeight > 0) {
 8142:     widthAtMaxHeight = MULDIV(maxHeight, tentWidth, tentHeight);
    1:     if (widthAtMaxHeight < minWidth)
    1:       widthAtMaxHeight = minWidth;
 8142:     widthAtMinHeight = MULDIV(minHeight, tentWidth, tentHeight);
    1:     if (widthAtMinHeight > maxWidth)
    1:       widthAtMinHeight = maxWidth;
    1:   } else {
76754:     widthAtMaxHeight = widthAtMinHeight = NS_CSS_MINMAX(tentWidth, minWidth, maxWidth);
    1:   }
    1: 
 8142:   // The table at http://www.w3.org/TR/CSS21/visudet.html#min-max-widths :
 8142: 
74937:   nscoord width, height;
74937: 
 8142:   if (tentWidth > maxWidth) {
 8142:     if (tentHeight > maxHeight) {
 8142:       if (PRInt64(maxWidth) * PRInt64(tentHeight) <=
 8142:           PRInt64(maxHeight) * PRInt64(tentWidth)) {
    1:         width = maxWidth;
    1:         height = heightAtMaxWidth;
    1:       } else {
 8142:         width = widthAtMaxHeight;
    1:         height = maxHeight;
    1:       }
    1:     } else {
 8142:       // This also covers "(w > max-width) and (h < min-height)" since in
 8142:       // that case (max-width/w < 1), and with (h < min-height):
 8142:       //   max(max-width * h/w, min-height) == min-height
    1:       width = maxWidth;
    1:       height = heightAtMaxWidth;
    1:     }
 8142:   } else if (tentWidth < minWidth) {
 8142:     if (tentHeight < minHeight) {
 8142:       if (PRInt64(minWidth) * PRInt64(tentHeight) <=
 8142:           PRInt64(minHeight) * PRInt64(tentWidth)) {
 8142:         width = widthAtMinHeight;
    1:         height = minHeight;
    1:       } else {
    1:         width = minWidth;
    1:         height = heightAtMinWidth;
    1:       }
    1:     } else {
 8142:       // This also covers "(w < min-width) and (h > max-height)" since in
 8142:       // that case (min-width/w > 1), and with (h > max-height):
 8142:       //   min(min-width * h/w, max-height) == max-height
    1:       width = minWidth;
    1:       height = heightAtMinWidth;
    1:     }
    1:   } else {
 8142:     if (tentHeight > maxHeight) {
 8142:       width = widthAtMaxHeight;
    1:       height = maxHeight;
 8142:     } else if (tentHeight < minHeight) {
 8142:       width = widthAtMinHeight;
    1:       height = minHeight;
    1:     } else {
 8142:       width = tentWidth;
 8142:       height = tentHeight;
    1:     }
    1:   }
    1: 
    1:   return nsSize(width, height);
    1: }
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::MinWidthFromInline(nsIFrame* aFrame,
68481:                                   nsRenderingContext* aRenderingContext)
    1: {
88122:   NS_ASSERTION(!nsLayoutUtils::IsContainerForFontSizeInflation(aFrame),
88122:                "should not be container for font size inflation");
88122: 
    1:   nsIFrame::InlineMinWidthData data;
    1:   DISPLAY_MIN_WIDTH(aFrame, data.prevLines);
    1:   aFrame->AddInlineMinWidth(aRenderingContext, &data);
 2668:   data.ForceBreak(aRenderingContext);
    1:   return data.prevLines;
    1: }
    1: 
    1: /* static */ nscoord
    1: nsLayoutUtils::PrefWidthFromInline(nsIFrame* aFrame,
68481:                                    nsRenderingContext* aRenderingContext)
    1: {
88122:   NS_ASSERTION(!nsLayoutUtils::IsContainerForFontSizeInflation(aFrame),
88122:                "should not be container for font size inflation");
88122: 
    1:   nsIFrame::InlinePrefWidthData data;
    1:   DISPLAY_PREF_WIDTH(aFrame, data.prevLines);
    1:   aFrame->AddInlinePrefWidth(aRenderingContext, &data);
 2668:   data.ForceBreak(aRenderingContext);
    1:   return data.prevLines;
    1: }
    1: 
72260: static nscolor
72260: DarkenColor(nscolor aColor)
72260: {
72260:   PRUint16  hue, sat, value;
72260:   PRUint8 alpha;
72260: 
72260:   // convert the RBG to HSV so we can get the lightness (which is the v)
72260:   NS_RGB2HSV(aColor, hue, sat, value, alpha);
72260: 
72260:   // The goal here is to send white to black while letting colored
72260:   // stuff stay colored... So we adopt the following approach.
72260:   // Something with sat = 0 should end up with value = 0.  Something
72260:   // with a high sat can end up with a high value and it's ok.... At
72260:   // the same time, we don't want to make things lighter.  Do
72260:   // something simple, since it seems to work.
72260:   if (value > sat) {
72260:     value = sat;
72260:     // convert this color back into the RGB color space.
72260:     NS_HSV2RGB(aColor, hue, sat, value, alpha);
72260:   }
72260:   return aColor;
72260: }
72260: 
75138: // Check whether we should darken text/decoration colors. We need to do this if
72260: // background images and colors are being suppressed, because that means
72260: // light text will not be visible against the (presumed light-colored) background.
79445: static bool
72260: ShouldDarkenColors(nsPresContext* aPresContext)
72260: {
72260:   return !aPresContext->GetBackgroundColorDraw() &&
72260:          !aPresContext->GetBackgroundImageDraw();
72260: }
72260: 
72260: nscolor
75138: nsLayoutUtils::GetColor(nsIFrame* aFrame, nsCSSProperty aProperty)
72260: {
75138:   nscolor color = aFrame->GetVisitedDependentColor(aProperty);
72260:   if (ShouldDarkenColors(aFrame->PresContext())) {
72260:     color = DarkenColor(color);
72260:   }
72260:   return color;
72260: }
72260: 
72990: gfxFloat
72990: nsLayoutUtils::GetSnappedBaselineY(nsIFrame* aFrame, gfxContext* aContext,
72990:                                    nscoord aY, nscoord aAscent)
72990: {
72990:   gfxFloat appUnitsPerDevUnit = aFrame->PresContext()->AppUnitsPerDevPixel();
72990:   gfxFloat baseline = gfxFloat(aY) + aAscent;
72990:   gfxRect putativeRect(0, baseline/appUnitsPerDevUnit, 1, 1);
80486:   if (!aContext->UserToDevicePixelSnapped(putativeRect, true))
72990:     return baseline;
72990:   return aContext->DeviceToUser(putativeRect.TopLeft()).y * appUnitsPerDevUnit;
72990: }
72990: 
    1: void
    1: nsLayoutUtils::DrawString(const nsIFrame*      aFrame,
68481:                           nsRenderingContext* aContext,
    1:                           const PRUnichar*     aString,
    1:                           PRInt32              aLength,
24995:                           nsPoint              aPoint,
24995:                           PRUint8              aDirection)
    1: {
    1: #ifdef IBMBIDI
    1:   nsresult rv = NS_ERROR_FAILURE;
  238:   nsPresContext* presContext = aFrame->PresContext();
    1:   if (presContext->BidiEnabled()) {
24995:     if (aDirection == NS_STYLE_DIRECTION_INHERIT) {
24995:       aDirection = aFrame->GetStyleVisibility()->mDirection;
24995:     }
    1:     nsBidiDirection direction =
24995:       (NS_STYLE_DIRECTION_RTL == aDirection) ?
    1:       NSBIDI_RTL : NSBIDI_LTR;
73724:     rv = nsBidiPresUtils::RenderText(aString, aLength, direction,
60677:                                      presContext, *aContext, *aContext,
    1:                                      aPoint.x, aPoint.y);
    1:   }
    1:   if (NS_FAILED(rv))
    1: #endif // IBMBIDI
    1:   {
80486:     aContext->SetTextRunRTL(false);
    1:     aContext->DrawString(aString, aLength, aPoint.x, aPoint.y);
    1:   }
    1: }
    1: 
    1: nscoord
    1: nsLayoutUtils::GetStringWidth(const nsIFrame*      aFrame,
68481:                               nsRenderingContext* aContext,
    1:                               const PRUnichar*     aString,
    1:                               PRInt32              aLength)
    1: {
    1: #ifdef IBMBIDI
  238:   nsPresContext* presContext = aFrame->PresContext();
    1:   if (presContext->BidiEnabled()) {
    1:     const nsStyleVisibility* vis = aFrame->GetStyleVisibility();
    1:     nsBidiDirection direction =
    1:       (NS_STYLE_DIRECTION_RTL == vis->mDirection) ?
    1:       NSBIDI_RTL : NSBIDI_LTR;
73724:     return nsBidiPresUtils::MeasureTextWidth(aString, aLength,
    1:                                              direction, presContext, *aContext);
    1:   }
    1: #endif // IBMBIDI
80486:   aContext->SetTextRunRTL(false);
68484:   return aContext->GetWidth(aString, aLength);
    1: }
    1: 
72827: /* static */ void
72827: nsLayoutUtils::PaintTextShadow(const nsIFrame* aFrame,
72827:                                nsRenderingContext* aContext,
72827:                                const nsRect& aTextRect,
72827:                                const nsRect& aDirtyRect,
72827:                                const nscolor& aForegroundColor,
72827:                                TextShadowCallback aCallback,
72827:                                void* aCallbackData)
72827: {
72827:   const nsStyleText* textStyle = aFrame->GetStyleText();
72827:   if (!textStyle->mTextShadow)
72827:     return;
72827: 
72827:   // Text shadow happens with the last value being painted at the back,
72827:   // ie. it is painted first.
72827:   gfxContext* aDestCtx = aContext->ThebesContext();
72827:   for (PRUint32 i = textStyle->mTextShadow->Length(); i > 0; --i) {
72827:     nsCSSShadowItem* shadowDetails = textStyle->mTextShadow->ShadowAt(i - 1);
72827:     nsPoint shadowOffset(shadowDetails->mXOffset,
72827:                          shadowDetails->mYOffset);
72827:     nscoord blurRadius = NS_MAX(shadowDetails->mRadius, 0);
72827: 
72827:     nsRect shadowRect(aTextRect);
72827:     shadowRect.MoveBy(shadowOffset);
72827: 
72827:     nsPresContext* presCtx = aFrame->PresContext();
72827:     nsContextBoxBlur contextBoxBlur;
72827:     gfxContext* shadowContext = contextBoxBlur.Init(shadowRect, 0, blurRadius,
72827:                                                     presCtx->AppUnitsPerDevPixel(),
72827:                                                     aDestCtx, aDirtyRect, nsnull);
72827:     if (!shadowContext)
72827:       continue;
72827: 
72827:     nscolor shadowColor;
72827:     if (shadowDetails->mHasColor)
72827:       shadowColor = shadowDetails->mColor;
72827:     else
72827:       shadowColor = aForegroundColor;
72827: 
72827:     // Conjure an nsRenderingContext from a gfxContext for drawing the text
72828:     // to blur.
72827:     nsRefPtr<nsRenderingContext> renderingContext = new nsRenderingContext();
72827:     renderingContext->Init(presCtx->DeviceContext(), shadowContext);
72827: 
72827:     aDestCtx->Save();
72827:     aDestCtx->NewPath();
72827:     aDestCtx->SetColor(gfxRGBA(shadowColor));
72827: 
72827:     // The callback will draw whatever we want to blur as a shadow.
72827:     aCallback(renderingContext, shadowOffset, shadowColor, aCallbackData);
72827: 
72827:     contextBoxBlur.DoPaint();
72827:     aDestCtx->Restore();
72827:   }
72827: }
72827: 
28519: /* static */ nscoord
68493: nsLayoutUtils::GetCenteredFontBaseline(nsFontMetrics* aFontMetrics,
28519:                                        nscoord         aLineHeight)
28519: {
68495:   nscoord fontAscent = aFontMetrics->MaxAscent();
68495:   nscoord fontHeight = aFontMetrics->MaxHeight();
28519: 
28519:   nscoord leading = aLineHeight - fontHeight;
28519:   return fontAscent + leading/2;
28519: }
28519: 
28519: 
79445: /* static */ bool
    1: nsLayoutUtils::GetFirstLineBaseline(const nsIFrame* aFrame, nscoord* aResult)
    1: {
27100:   LinePosition position;
27100:   if (!GetFirstLinePosition(aFrame, &position))
80486:     return false;
27100:   *aResult = position.mBaseline;
80486:   return true;
27100: }
27100: 
79445: /* static */ bool
27100: nsLayoutUtils::GetFirstLinePosition(const nsIFrame* aFrame,
27100:                                     LinePosition* aResult)
27100: {
15909:   const nsBlockFrame* block = nsLayoutUtils::GetAsBlock(const_cast<nsIFrame*>(aFrame));
15909:   if (!block) {
    1:     // For the first-line baseline we also have to check for a table, and if
    1:     // so, use the baseline of its first row.
    1:     nsIAtom* fType = aFrame->GetType();
    1:     if (fType == nsGkAtoms::tableOuterFrame) {
27100:       aResult->mTop = 0;
27100:       aResult->mBaseline = aFrame->GetBaseline();
27100:       // This is what we want for the list bullet caller; not sure if
27100:       // other future callers will want the same.
27100:       aResult->mBottom = aFrame->GetSize().height;
80486:       return true;
    1:     }
    1: 
    1:     // For first-line baselines, we have to consider scroll frames.
    1:     if (fType == nsGkAtoms::scrollFrame) {
23554:       nsIScrollableFrame *sFrame = do_QueryFrame(const_cast<nsIFrame*>(aFrame));
23554:       if (!sFrame) {
    1:         NS_NOTREACHED("not scroll frame");
    1:       }
27100:       LinePosition kidPosition;
27100:       if (GetFirstLinePosition(sFrame->GetScrolledFrame(), &kidPosition)) {
    1:         // Consider only the border and padding that contributes to the
    1:         // kid's position, not the scrolling, so we get the initial
    1:         // position.
27100:         *aResult = kidPosition + aFrame->GetUsedBorderAndPadding().top;
80486:         return true;
80486:       }
80486:       return false;
    1:     }
    1: 
48894:     if (fType == nsGkAtoms::fieldSetFrame) {
48894:       LinePosition kidPosition;
77154:       nsIFrame* kid = aFrame->GetFirstPrincipalChild();
48894:       // kid might be a legend frame here, but that's ok.
48894:       if (GetFirstLinePosition(kid, &kidPosition)) {
48894:         *aResult = kidPosition + kid->GetPosition().y;
80486:         return true;
80486:       }
80486:       return false;
48894:     }
48894: 
    1:     // No baseline.
80486:     return false;
    1:   }
    1: 
    1:   for (nsBlockFrame::const_line_iterator line = block->begin_lines(),
    1:                                      line_end = block->end_lines();
    1:        line != line_end; ++line) {
    1:     if (line->IsBlock()) {
    1:       nsIFrame *kid = line->mFirstChild;
27100:       LinePosition kidPosition;
27100:       if (GetFirstLinePosition(kid, &kidPosition)) {
27100:         *aResult = kidPosition + kid->GetPosition().y;
80486:         return true;
    1:       }
    1:     } else {
    1:       // XXX Is this the right test?  We have some bogus empty lines
    1:       // floating around, but IsEmpty is perhaps too weak.
    1:       if (line->GetHeight() != 0 || !line->IsEmpty()) {
27100:         nscoord top = line->mBounds.y;
27100:         aResult->mTop = top;
27100:         aResult->mBaseline = top + line->GetAscent();
27100:         aResult->mBottom = top + line->GetHeight();
80486:         return true;
80486:       }
80486:     }
80486:   }
80486:   return false;
    1: }
    1: 
79445: /* static */ bool
    1: nsLayoutUtils::GetLastLineBaseline(const nsIFrame* aFrame, nscoord* aResult)
    1: {
15909:   const nsBlockFrame* block = nsLayoutUtils::GetAsBlock(const_cast<nsIFrame*>(aFrame));
15909:   if (!block)
    1:     // No baseline.  (We intentionally don't descend into scroll frames.)
80486:     return false;
    1: 
    1:   for (nsBlockFrame::const_reverse_line_iterator line = block->rbegin_lines(),
    1:                                              line_end = block->rend_lines();
    1:        line != line_end; ++line) {
    1:     if (line->IsBlock()) {
    1:       nsIFrame *kid = line->mFirstChild;
    1:       nscoord kidBaseline;
    1:       if (GetLastLineBaseline(kid, &kidBaseline)) {
    1:         *aResult = kidBaseline + kid->GetPosition().y;
80486:         return true;
    1:       } else if (kid->GetType() == nsGkAtoms::scrollFrame) {
    1:         // Use the bottom of the scroll frame.
    1:         // XXX CSS2.1 really doesn't say what to do here.
    1:         *aResult = kid->GetRect().YMost();
80486:         return true;
    1:       }
    1:     } else {
    1:       // XXX Is this the right test?  We have some bogus empty lines
    1:       // floating around, but IsEmpty is perhaps too weak.
    1:       if (line->GetHeight() != 0 || !line->IsEmpty()) {
    1:         *aResult = line->mBounds.y + line->GetAscent();
80486:         return true;
80486:       }
80486:     }
80486:   }
80486:   return false;
    1: }
    1: 
14460: static nscoord
14460: CalculateBlockContentBottom(nsBlockFrame* aFrame)
14460: {
14460:   NS_PRECONDITION(aFrame, "null ptr");
14460: 
14460:   nscoord contentBottom = 0;
14460: 
14460:   for (nsBlockFrame::line_iterator line = aFrame->begin_lines(),
14460:                                    line_end = aFrame->end_lines();
14460:        line != line_end; ++line) {
14460:     if (line->IsBlock()) {
14460:       nsIFrame* child = line->mFirstChild;
14460:       nscoord offset = child->GetRect().y - child->GetRelativeOffset().y;
31760:       contentBottom = NS_MAX(contentBottom,
14460:                         nsLayoutUtils::CalculateContentBottom(child) + offset);
14460:     }
14460:     else {
31760:       contentBottom = NS_MAX(contentBottom, line->mBounds.YMost());
14460:     }
14460:   }
14460:   return contentBottom;
14460: }
14460: 
14460: /* static */ nscoord
14460: nsLayoutUtils::CalculateContentBottom(nsIFrame* aFrame)
14460: {
14460:   NS_PRECONDITION(aFrame, "null ptr");
14460: 
14460:   nscoord contentBottom = aFrame->GetRect().height;
14460: 
55040:   // We want scrollable overflow rather than visual because this
55040:   // calculation is intended to affect layout.
55040:   if (aFrame->GetScrollableOverflowRect().height > contentBottom) {
77153:     nsIFrame::ChildListIDs skip(nsIFrame::kOverflowList |
77153:                                 nsIFrame::kExcessOverflowContainersList |
77153:                                 nsIFrame::kOverflowOutOfFlowList);
14460:     nsBlockFrame* blockFrame = GetAsBlock(aFrame);
77153:     if (blockFrame) {
77153:       contentBottom =
77153:         NS_MAX(contentBottom, CalculateBlockContentBottom(blockFrame));
77153:       skip |= nsIFrame::kPrincipalList;
77153:     }
77153:     nsIFrame::ChildListIterator lists(aFrame);
77153:     for (; !lists.IsDone(); lists.Next()) {
77153:       if (!skip.Contains(lists.CurrentID())) {
77153:         nsFrameList::Enumerator childFrames(lists.CurrentList()); 
77153:         for (; !childFrames.AtEnd(); childFrames.Next()) {
77153:           nsIFrame* child = childFrames.get();
14460:           nscoord offset = child->GetRect().y - child->GetRelativeOffset().y;
31760:           contentBottom = NS_MAX(contentBottom,
14460:                                  CalculateContentBottom(child) + offset);
14460:         }
14460:       }
77153:     }
77153:   }
14460:   return contentBottom;
14460: }
14460: 
    1: /* static */ nsIFrame*
    1: nsLayoutUtils::GetClosestLayer(nsIFrame* aFrame)
    1: {
    1:   nsIFrame* layer;
    1:   for (layer = aFrame; layer; layer = layer->GetParent()) {
    1:     if (layer->GetStyleDisplay()->IsPositioned() ||
    1:         (layer->GetParent() &&
    1:           layer->GetParent()->GetType() == nsGkAtoms::scrollFrame))
    1:       break;
    1:   }
    1:   if (layer)
    1:     return layer;
  238:   return aFrame->PresContext()->PresShell()->FrameManager()->GetRootFrame();
    1: }
    1: 
55321: GraphicsFilter
27185: nsLayoutUtils::GetGraphicsFilterForFrame(nsIFrame* aForFrame)
26926: {
70831:   GraphicsFilter defaultFilter = gfxPattern::FILTER_GOOD;
27185:   nsIFrame *frame = nsCSSRendering::IsCanvasFrame(aForFrame) ?
35300:     nsCSSRendering::FindBackgroundStyleFrame(aForFrame) : aForFrame;
27185: 
27185:   switch (frame->GetStyleSVG()->mImageRendering) {
26926:   case NS_STYLE_IMAGE_RENDERING_OPTIMIZESPEED:
26926:     return gfxPattern::FILTER_FAST;
26926:   case NS_STYLE_IMAGE_RENDERING_OPTIMIZEQUALITY:
26926:     return gfxPattern::FILTER_BEST;
26926:   case NS_STYLE_IMAGE_RENDERING_CRISPEDGES:
26926:     return gfxPattern::FILTER_NEAREST;
26926:   default:
43454:     return defaultFilter;
26926:   }
26926: }
26926: 
21752: /**
21752:  * Given an image being drawn into an appunit coordinate system, and
21752:  * a point in that coordinate system, map the point back into image
21752:  * pixel space.
21752:  * @param aSize the size of the image, in pixels
21752:  * @param aDest the rectangle that the image is being mapped into
21752:  * @param aPt a point in the same coordinate system as the rectangle
21752:  */
21323: static gfxPoint
22196: MapToFloatImagePixels(const gfxSize& aSize,
22196:                       const gfxRect& aDest, const gfxPoint& aPt)
21323: {
68632:   return gfxPoint(((aPt.x - aDest.X())*aSize.width)/aDest.Width(),
68632:                   ((aPt.y - aDest.Y())*aSize.height)/aDest.Height());
21323: }
21323: 
21752: /**
21752:  * Given an image being drawn into an pixel-based coordinate system, and
21752:  * a point in image space, map the point into the pixel-based coordinate
21752:  * system.
21752:  * @param aSize the size of the image, in pixels
21752:  * @param aDest the rectangle that the image is being mapped into
21752:  * @param aPt a point in image space
21752:  */
21752: static gfxPoint
22196: MapToFloatUserPixels(const gfxSize& aSize,
21752:                      const gfxRect& aDest, const gfxPoint& aPt)
21752: {
68632:   return gfxPoint(aPt.x*aDest.Width()/aSize.width + aDest.X(),
68632:                   aPt.y*aDest.Height()/aSize.height + aDest.Y());
21752: }
21752: 
52135: /* static */ gfxRect
52135: nsLayoutUtils::RectToGfxRect(const nsRect& aRect, PRInt32 aAppUnitsPerDevPixel)
46989: {
46989:   return gfxRect(gfxFloat(aRect.x) / aAppUnitsPerDevPixel,
46989:                  gfxFloat(aRect.y) / aAppUnitsPerDevPixel,
46989:                  gfxFloat(aRect.width) / aAppUnitsPerDevPixel,
46989:                  gfxFloat(aRect.height) / aAppUnitsPerDevPixel);
46989: }
46989: 
46989: struct SnappedImageDrawingParameters {
46989:   // A transform from either device space or user space (depending on mResetCTM)
46989:   // to image space
46989:   gfxMatrix mUserSpaceToImageSpace;
46989:   // A device-space, pixel-aligned rectangle to fill
46989:   gfxRect mFillRect;
46989:   // A pixel rectangle in tiled image space outside of which gfx should not
46989:   // sample (using EXTEND_PAD as necessary)
46989:   nsIntRect mSubimage;
46989:   // Whether there's anything to draw at all
79445:   bool mShouldDraw;
80486:   // true iff the CTM of the rendering context needs to be reset to the
46989:   // identity matrix before drawing
79445:   bool mResetCTM;
46989: 
46989:   SnappedImageDrawingParameters()
80486:    : mShouldDraw(false)
80486:    , mResetCTM(false)
46989:   {}
46989: 
46989:   SnappedImageDrawingParameters(const gfxMatrix& aUserSpaceToImageSpace,
46989:                                 const gfxRect&   aFillRect,
46989:                                 const nsIntRect& aSubimage,
79445:                                 bool             aResetCTM)
46989:    : mUserSpaceToImageSpace(aUserSpaceToImageSpace)
46989:    , mFillRect(aFillRect)
46989:    , mSubimage(aSubimage)
80486:    , mShouldDraw(true)
46989:    , mResetCTM(aResetCTM)
46989:   {}
46989: };
46989: 
46989: /**
46989:  * Given a set of input parameters, compute certain output parameters
46989:  * for drawing an image with the image snapping algorithm.
46989:  * See https://wiki.mozilla.org/Gecko:Image_Snapping_and_Rendering
46989:  *
46989:  *  @see nsLayoutUtils::DrawImage() for the descriptions of input parameters
46989:  */
46989: static SnappedImageDrawingParameters
46989: ComputeSnappedImageDrawingParameters(gfxContext*     aCtx,
46989:                                      PRInt32         aAppUnitsPerDevPixel,
46989:                                      const nsRect    aDest,
46989:                                      const nsRect    aFill,
46989:                                      const nsPoint   aAnchor,
46989:                                      const nsRect    aDirty,
46989:                                      const nsIntSize aImageSize)
46989: 
46989: {
46989:   if (aDest.IsEmpty() || aFill.IsEmpty())
46989:     return SnappedImageDrawingParameters();
46989: 
52135:   gfxRect devPixelDest =
52135:     nsLayoutUtils::RectToGfxRect(aDest, aAppUnitsPerDevPixel);
52135:   gfxRect devPixelFill =
52135:     nsLayoutUtils::RectToGfxRect(aFill, aAppUnitsPerDevPixel);
52135:   gfxRect devPixelDirty =
52135:     nsLayoutUtils::RectToGfxRect(aDirty, aAppUnitsPerDevPixel);
46989: 
79445:   bool ignoreScale = false;
46989: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
80486:   ignoreScale = true;
46989: #endif
46989:   gfxRect fill = devPixelFill;
79445:   bool didSnap = aCtx->UserToDevicePixelSnapped(fill, ignoreScale);
46989: 
46989:   gfxSize imageSize(aImageSize.width, aImageSize.height);
46989: 
46989:   // Compute the set of pixels that would be sampled by an ideal rendering
46989:   gfxPoint subimageTopLeft =
46989:     MapToFloatImagePixels(imageSize, devPixelDest, devPixelFill.TopLeft());
46989:   gfxPoint subimageBottomRight =
46989:     MapToFloatImagePixels(imageSize, devPixelDest, devPixelFill.BottomRight());
46989:   nsIntRect intSubimage;
46989:   intSubimage.MoveTo(NSToIntFloor(subimageTopLeft.x),
46989:                      NSToIntFloor(subimageTopLeft.y));
46989:   intSubimage.SizeTo(NSToIntCeil(subimageBottomRight.x) - intSubimage.x,
46989:                      NSToIntCeil(subimageBottomRight.y) - intSubimage.y);
46989: 
46989:   // Compute the anchor point and compute final fill rect.
46989:   // This code assumes that pixel-based devices have one pixel per
46989:   // device unit!
46989:   gfxPoint anchorPoint(gfxFloat(aAnchor.x)/aAppUnitsPerDevPixel,
46989:                        gfxFloat(aAnchor.y)/aAppUnitsPerDevPixel);
46989:   gfxPoint imageSpaceAnchorPoint =
46989:     MapToFloatImagePixels(imageSize, devPixelDest, anchorPoint);
46989:   gfxMatrix currentMatrix = aCtx->CurrentMatrix();
46989: 
46989:   if (didSnap) {
46989:     NS_ASSERTION(!currentMatrix.HasNonAxisAlignedTransform(),
46989:                  "How did we snap, then?");
46989:     imageSpaceAnchorPoint.Round();
46989:     anchorPoint = imageSpaceAnchorPoint;
46989:     anchorPoint = MapToFloatUserPixels(imageSize, devPixelDest, anchorPoint);
46989:     anchorPoint = currentMatrix.Transform(anchorPoint);
46989:     anchorPoint.Round();
46989: 
46989:     // This form of Transform is safe to call since non-axis-aligned
46989:     // transforms wouldn't be snapped.
46989:     devPixelDirty = currentMatrix.Transform(devPixelDirty);
46989:   }
46989: 
46989:   gfxFloat scaleX = imageSize.width*aAppUnitsPerDevPixel/aDest.width;
46989:   gfxFloat scaleY = imageSize.height*aAppUnitsPerDevPixel/aDest.height;
46989:   if (didSnap) {
46989:     // We'll reset aCTX to the identity matrix before drawing, so we need to
46989:     // adjust our scales to match.
46989:     scaleX /= currentMatrix.xx;
46989:     scaleY /= currentMatrix.yy;
46989:   }
46989:   gfxFloat translateX = imageSpaceAnchorPoint.x - anchorPoint.x*scaleX;
46989:   gfxFloat translateY = imageSpaceAnchorPoint.y - anchorPoint.y*scaleY;
46989:   gfxMatrix transform(scaleX, 0, 0, scaleY, translateX, translateY);
46989: 
46989:   gfxRect finalFillRect = fill;
46989:   // If the user-space-to-image-space transform is not a straight
46989:   // translation by integers, then filtering will occur, and
46989:   // restricting the fill rect to the dirty rect would change the values
46989:   // computed for edge pixels, which we can't allow.
46989:   // Also, if didSnap is false then rounding out 'devPixelDirty' might not
46989:   // produce pixel-aligned coordinates, which would also break the values
46989:   // computed for edge pixels.
46989:   if (didSnap && !transform.HasNonIntegerTranslation()) {
46989:     devPixelDirty.RoundOut();
46989:     finalFillRect = fill.Intersect(devPixelDirty);
46989:   }
46989:   if (finalFillRect.IsEmpty())
46989:     return SnappedImageDrawingParameters();
46989: 
46989:   return SnappedImageDrawingParameters(transform, finalFillRect, intSubimage,
46989:                                        didSnap);
46989: }
46989: 
46989: 
24452: static nsresult
68481: DrawImageInternal(nsRenderingContext* aRenderingContext,
30479:                   imgIContainer*       aImage,
55321:                   GraphicsFilter       aGraphicsFilter,
21323:                   const nsRect&        aDest,
21323:                   const nsRect&        aFill,
21323:                   const nsPoint&       aAnchor,
24452:                   const nsRect&        aDirty,
32424:                   const nsIntSize&     aImageSize,
32424:                   PRUint32             aImageFlags)
    1: {
95637:   if (aDest.Contains(aFill)) {
95637:     aImageFlags |= imgIContainer::FLAG_CLAMP;
95637:   }
68486:   PRInt32 appUnitsPerDevPixel = aRenderingContext->AppUnitsPerDevPixel();
21323:   gfxContext* ctx = aRenderingContext->ThebesContext();
21323: 
46989:   SnappedImageDrawingParameters drawingParams =
46989:     ComputeSnappedImageDrawingParameters(ctx, appUnitsPerDevPixel, aDest, aFill,
46989:                                          aAnchor, aDirty, aImageSize);
46989: 
46989:   if (!drawingParams.mShouldDraw)
46989:     return NS_OK;
46989: 
22177:   gfxContextMatrixAutoSaveRestore saveMatrix(ctx);
46989:   if (drawingParams.mResetCTM) {
21323:     ctx->IdentityMatrix();
    1:   }
21323: 
46989:   aImage->Draw(ctx, aGraphicsFilter, drawingParams.mUserSpaceToImageSpace,
52215:                drawingParams.mFillRect, drawingParams.mSubimage, aImageSize,
52215:                aImageFlags);
24452:   return NS_OK;
24452: }
24452: 
50420: /* static */ void
68481: nsLayoutUtils::DrawPixelSnapped(nsRenderingContext* aRenderingContext,
50420:                                 gfxDrawable*         aDrawable,
55321:                                 GraphicsFilter       aFilter,
50420:                                 const nsRect&        aDest,
50420:                                 const nsRect&        aFill,
50420:                                 const nsPoint&       aAnchor,
50420:                                 const nsRect&        aDirty)
50420: {
68486:   PRInt32 appUnitsPerDevPixel = aRenderingContext->AppUnitsPerDevPixel();
50420:   gfxContext* ctx = aRenderingContext->ThebesContext();
50420:   gfxIntSize drawableSize = aDrawable->Size();
50420:   nsIntSize imageSize(drawableSize.width, drawableSize.height);
50420: 
50420:   SnappedImageDrawingParameters drawingParams =
50420:     ComputeSnappedImageDrawingParameters(ctx, appUnitsPerDevPixel, aDest, aFill,
50420:                                          aAnchor, aDirty, imageSize);
50420: 
50420:   if (!drawingParams.mShouldDraw)
50420:     return;
50420: 
50420:   gfxContextMatrixAutoSaveRestore saveMatrix(ctx);
50420:   if (drawingParams.mResetCTM) {
50420:     ctx->IdentityMatrix();
50420:   }
50420: 
50420:   gfxRect sourceRect =
50420:     drawingParams.mUserSpaceToImageSpace.Transform(drawingParams.mFillRect);
50420:   gfxRect imageRect(0, 0, imageSize.width, imageSize.height);
50420:   gfxRect subimage(drawingParams.mSubimage.x, drawingParams.mSubimage.y,
50420:                    drawingParams.mSubimage.width, drawingParams.mSubimage.height);
50420: 
50420:   NS_ASSERTION(!sourceRect.Intersect(subimage).IsEmpty(),
50420:                "We must be allowed to sample *some* source pixels!");
50420: 
50420:   gfxUtils::DrawPixelSnapped(ctx, aDrawable,
50420:                              drawingParams.mUserSpaceToImageSpace, subimage,
50420:                              sourceRect, imageRect, drawingParams.mFillRect,
50420:                              gfxASurface::ImageFormatARGB32, aFilter);
50420: }
50420: 
30759: /* static */ nsresult
68481: nsLayoutUtils::DrawSingleUnscaledImage(nsRenderingContext* aRenderingContext,
30479:                                        imgIContainer*       aImage,
55322:                                        GraphicsFilter       aGraphicsFilter,
24452:                                        const nsPoint&       aDest,
55322:                                        const nsRect*        aDirty,
32424:                                        PRUint32             aImageFlags,
30759:                                        const nsRect*        aSourceArea)
24452: {
30759:   nsIntSize imageSize;
30759:   aImage->GetWidth(&imageSize.width);
30759:   aImage->GetHeight(&imageSize.height);
30759:   NS_ENSURE_TRUE(imageSize.width > 0 && imageSize.height > 0, NS_ERROR_FAILURE);
24452: 
68668:   nscoord appUnitsPerCSSPixel = nsDeviceContext::AppUnitsPerCSSPixel();
30759:   nsSize size(imageSize.width*appUnitsPerCSSPixel,
30759:               imageSize.height*appUnitsPerCSSPixel);
24452: 
24452:   nsRect source;
24452:   if (aSourceArea) {
24452:     source = *aSourceArea;
24452:   } else {
24452:     source.SizeTo(size);
24452:   }
24452: 
24452:   nsRect dest(aDest - source.TopLeft(), size);
24452:   nsRect fill(aDest, source.Size());
24452:   // Ensure that only a single image tile is drawn. If aSourceArea extends
24452:   // outside the image bounds, we want to honor the aSourceArea-to-aDest
24452:   // translation but we don't want to actually tile the image.
24452:   fill.IntersectRect(fill, dest);
55322:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
55322:                            dest, fill, aDest, aDirty ? *aDirty : dest,
55322:                            imageSize, aImageFlags);
30759: }
30759: 
30759: /* static */ nsresult
68481: nsLayoutUtils::DrawSingleImage(nsRenderingContext* aRenderingContext,
30479:                                imgIContainer*       aImage,
55321:                                GraphicsFilter       aGraphicsFilter,
24452:                                const nsRect&        aDest,
24452:                                const nsRect&        aDirty,
32424:                                PRUint32             aImageFlags,
30759:                                const nsRect*        aSourceArea)
24452: {
30759:   nsIntSize imageSize;
52215:   if (aImage->GetType() == imgIContainer::TYPE_VECTOR) {
52215:     imageSize.width  = nsPresContext::AppUnitsToIntCSSPixels(aDest.width);
52215:     imageSize.height = nsPresContext::AppUnitsToIntCSSPixels(aDest.height);
52215:   } else {
30759:     aImage->GetWidth(&imageSize.width);
30759:     aImage->GetHeight(&imageSize.height);
52215:   }
30759:   NS_ENSURE_TRUE(imageSize.width > 0 && imageSize.height > 0, NS_ERROR_FAILURE);
24452: 
24452:   nsRect source;
24452:   if (aSourceArea) {
24452:     source = *aSourceArea;
24452:   } else {
68668:     nscoord appUnitsPerCSSPixel = nsDeviceContext::AppUnitsPerCSSPixel();
30759:     source.SizeTo(imageSize.width*appUnitsPerCSSPixel,
30759:                   imageSize.height*appUnitsPerCSSPixel);
30759:   }
30759: 
30759:   nsRect dest = nsLayoutUtils::GetWholeImageDestination(imageSize, source,
24452:                                                         aDest);
24452:   // Ensure that only a single image tile is drawn. If aSourceArea extends
24452:   // outside the image bounds, we want to honor the aSourceArea-to-aDest
24452:   // transform but we don't want to actually tile the image.
24452:   nsRect fill;
24452:   fill.IntersectRect(aDest, dest);
26926:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter, dest, fill,
32424:                            fill.TopLeft(), aDirty, imageSize, aImageFlags);
30759: }
24452: 
52215: /* static */ void
52215: nsLayoutUtils::ComputeSizeForDrawing(imgIContainer *aImage,
52215:                                      nsIntSize&     aImageSize, /*outparam*/
75061:                                      nsSize&        aIntrinsicRatio, /*outparam*/
75061:                                      bool&          aGotWidth,  /*outparam*/
75061:                                      bool&          aGotHeight  /*outparam*/)
52215: {
52215:   aGotWidth  = NS_SUCCEEDED(aImage->GetWidth(&aImageSize.width));
52215:   aGotHeight = NS_SUCCEEDED(aImage->GetHeight(&aImageSize.height));
52215: 
75061:   if (aGotWidth && aGotHeight) {
75061:     aIntrinsicRatio = nsSize(aImageSize.width, aImageSize.height);
52215:     return;
52215:   }
52215: 
75061:   // If we failed to get width or height, we either have a vector image and
75061:   // should return its intrinsic ratio, or we hit an error (say, because the
75061:   // image failed to load or couldn't be decoded) and should return zero size.
75061:   if (nsIFrame* rootFrame = aImage->GetRootLayoutFrame()) {
75061:     aIntrinsicRatio = rootFrame->GetIntrinsicRatio();
75061:   } else {
75061:     aGotWidth = aGotHeight = true;
75061:     aImageSize = nsIntSize(0, 0);
75061:     aIntrinsicRatio = nsSize(0, 0);
75061:   }
75061: }
75061: 
75061: 
75061: /* static */ nsresult
75061: nsLayoutUtils::DrawBackgroundImage(nsRenderingContext* aRenderingContext,
75061:                                    imgIContainer*      aImage,
75061:                                    const nsIntSize&    aImageSize,
75061:                                    GraphicsFilter      aGraphicsFilter,
75061:                                    const nsRect&       aDest,
75061:                                    const nsRect&       aFill,
75061:                                    const nsPoint&      aAnchor,
75061:                                    const nsRect&       aDirty,
75061:                                    PRUint32            aImageFlags)
75061: {
87692:   SAMPLE_LABEL("layout", "nsLayoutUtils::DrawBackgroundImage");
95942: 
95942:   if (UseBackgroundNearestFiltering()) {
95942:     aGraphicsFilter = gfxPattern::FILTER_NEAREST;
95942:   }
95942: 
75061:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
75061:                            aDest, aFill, aAnchor, aDirty,
75061:                            aImageSize, aImageFlags);
75061: }
52215: 
24452: /* static */ nsresult
68481: nsLayoutUtils::DrawImage(nsRenderingContext* aRenderingContext,
24452:                          imgIContainer*       aImage,
55321:                          GraphicsFilter       aGraphicsFilter,
24452:                          const nsRect&        aDest,
24452:                          const nsRect&        aFill,
24452:                          const nsPoint&       aAnchor,
32424:                          const nsRect&        aDirty,
32424:                          PRUint32             aImageFlags)
24452: {
24452:   nsIntSize imageSize;
75061:   nsSize imageRatio;
75061:   bool gotHeight, gotWidth;
75061:   ComputeSizeForDrawing(aImage, imageSize, imageRatio, gotWidth, gotHeight);
75061: 
75061:   // XXX Dimensionless images shouldn't fall back to filled-area size -- the
75061:   //     caller should provide the image size, a la DrawBackgroundImage.
75061:   if (gotWidth != gotHeight) {
75061:     if (!gotWidth) {
75061:       if (imageRatio.height != 0) {
75061:         imageSize.width =
75061:           NSCoordSaturatingNonnegativeMultiply(imageSize.height,
75061:                                                float(imageRatio.width) /
75061:                                                float(imageRatio.height));
75061:         gotWidth = true;
75061:       }
75061:     } else {
75061:       if (imageRatio.width != 0) {
75061:         imageSize.height =
75061:           NSCoordSaturatingNonnegativeMultiply(imageSize.width,
75061:                                                float(imageRatio.height) /
75061:                                                float(imageRatio.width));
75061:         gotHeight = true;
75061:       }
75061:     }
75061:   }
75061: 
52215:   if (!gotWidth) {
52215:     imageSize.width = nsPresContext::AppUnitsToIntCSSPixels(aFill.width);
52215:   }
52215:   if (!gotHeight) {
52215:     imageSize.height = nsPresContext::AppUnitsToIntCSSPixels(aFill.height);
52215:   }
24452: 
26926:   return DrawImageInternal(aRenderingContext, aImage, aGraphicsFilter,
24452:                            aDest, aFill, aAnchor, aDirty,
32424:                            imageSize, aImageFlags);
    1: }
    1: 
21323: /* static */ nsRect
21323: nsLayoutUtils::GetWholeImageDestination(const nsIntSize& aWholeImageSize,
21323:                                         const nsRect& aImageSourceArea,
21323:                                         const nsRect& aDestArea)
21323: {
21323:   double scaleX = double(aDestArea.width)/aImageSourceArea.width;
21323:   double scaleY = double(aDestArea.height)/aImageSourceArea.height;
21323:   nscoord destOffsetX = NSToCoordRound(aImageSourceArea.x*scaleX);
21323:   nscoord destOffsetY = NSToCoordRound(aImageSourceArea.y*scaleY);
68668:   nscoord appUnitsPerCSSPixel = nsDeviceContext::AppUnitsPerCSSPixel();
21323:   nscoord wholeSizeX = NSToCoordRound(aWholeImageSize.width*appUnitsPerCSSPixel*scaleX);
21323:   nscoord wholeSizeY = NSToCoordRound(aWholeImageSize.height*appUnitsPerCSSPixel*scaleY);
21323:   return nsRect(aDestArea.TopLeft() - nsPoint(destOffsetX, destOffsetY),
21323:                 nsSize(wholeSizeX, wholeSizeY));
    1: }
 1105: 
79445: static bool NonZeroStyleCoord(const nsStyleCoord& aCoord)
 1345: {
52281:   if (aCoord.IsCoordPercentCalcUnit()) {
52281:     // Since negative results are clamped to 0, check > 0.
52281:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, nscoord_MAX) > 0 ||
52281:            nsRuleNode::ComputeCoordPercentCalc(aCoord, 0) > 0;
52281:   }
52281: 
80486:   return true;
 1345: }
 1345: 
79445: /* static */ bool
20039: nsLayoutUtils::HasNonZeroCorner(const nsStyleCorners& aCorners)
 1345: {
20039:   NS_FOR_CSS_HALF_CORNERS(corner) {
20039:     if (NonZeroStyleCoord(aCorners.Get(corner)))
80486:       return true;
80486:   }
80486:   return false;
 1345: }
 1345: 
28109: // aCorner is a "full corner" value, i.e. NS_CORNER_TOP_LEFT etc
79445: static bool IsCornerAdjacentToSide(PRUint8 aCorner, mozilla::css::Side aSide)
28109: {
41419:   PR_STATIC_ASSERT((int)NS_SIDE_TOP == NS_CORNER_TOP_LEFT);
41419:   PR_STATIC_ASSERT((int)NS_SIDE_RIGHT == NS_CORNER_TOP_RIGHT);
41419:   PR_STATIC_ASSERT((int)NS_SIDE_BOTTOM == NS_CORNER_BOTTOM_RIGHT);
41419:   PR_STATIC_ASSERT((int)NS_SIDE_LEFT == NS_CORNER_BOTTOM_LEFT);
41419:   PR_STATIC_ASSERT((int)NS_SIDE_TOP == ((NS_CORNER_TOP_RIGHT - 1)&3));
41419:   PR_STATIC_ASSERT((int)NS_SIDE_RIGHT == ((NS_CORNER_BOTTOM_RIGHT - 1)&3));
41419:   PR_STATIC_ASSERT((int)NS_SIDE_BOTTOM == ((NS_CORNER_BOTTOM_LEFT - 1)&3));
41419:   PR_STATIC_ASSERT((int)NS_SIDE_LEFT == ((NS_CORNER_TOP_LEFT - 1)&3));
28109: 
28109:   return aSide == aCorner || aSide == ((aCorner - 1)&3);
28109: }
28109: 
79445: /* static */ bool
28109: nsLayoutUtils::HasNonZeroCornerOnSide(const nsStyleCorners& aCorners,
41419:                                       mozilla::css::Side aSide)
28109: {
28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_LEFT_X/2 == NS_CORNER_TOP_LEFT);
28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_LEFT_Y/2 == NS_CORNER_TOP_LEFT);
28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_RIGHT_X/2 == NS_CORNER_TOP_RIGHT);
28109:   PR_STATIC_ASSERT(NS_CORNER_TOP_RIGHT_Y/2 == NS_CORNER_TOP_RIGHT);
28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_RIGHT_X/2 == NS_CORNER_BOTTOM_RIGHT);
28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_RIGHT_Y/2 == NS_CORNER_BOTTOM_RIGHT);
28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_LEFT_X/2 == NS_CORNER_BOTTOM_LEFT);
28109:   PR_STATIC_ASSERT(NS_CORNER_BOTTOM_LEFT_Y/2 == NS_CORNER_BOTTOM_LEFT);
28109: 
28109:   NS_FOR_CSS_HALF_CORNERS(corner) {
28109:     // corner is a "half corner" value, so dividing by two gives us a
28109:     // "full corner" value.
28109:     if (NonZeroStyleCoord(aCorners.Get(corner)) &&
28109:         IsCornerAdjacentToSide(corner/2, aSide))
80486:       return true;
80486:   }
80486:   return false;
28109: }
28109: 
16601: /* static */ nsTransparencyMode
31535: nsLayoutUtils::GetFrameTransparency(nsIFrame* aBackgroundFrame,
31535:                                     nsIFrame* aCSSRootFrame) {
31535:   if (aCSSRootFrame->GetStyleContext()->GetStyleDisplay()->mOpacity < 1.0f)
16601:     return eTransparencyTransparent;
 1345: 
31535:   if (HasNonZeroCorner(aCSSRootFrame->GetStyleContext()->GetStyleBorder()->mBorderRadius))
16601:     return eTransparencyTransparent;
 1345: 
56101:   if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_GLASS)
56101:     return eTransparencyGlass;
56101: 
56101:   if (aCSSRootFrame->GetStyleDisplay()->mAppearance == NS_THEME_WIN_BORDERLESS_GLASS)
56101:     return eTransparencyBorderlessGlass;
56101: 
43487:   nsITheme::Transparency transparency;
31535:   if (aCSSRootFrame->IsThemed(&transparency))
43487:     return transparency == nsITheme::eTransparent
43487:          ? eTransparencyTransparent
43487:          : eTransparencyOpaque;
 1345: 
24645:   // We need an uninitialized window to be treated as opaque because
24645:   // doing otherwise breaks window display effects on some platforms,
24645:   // specifically Vista. (bug 450322)
31535:   if (aBackgroundFrame->GetType() == nsGkAtoms::viewportFrame &&
77154:       !aBackgroundFrame->GetFirstPrincipalChild()) {
24645:     return eTransparencyOpaque;
24645:   }
24645: 
40177:   nsStyleContext* bgSC;
31535:   if (!nsCSSRendering::FindBackground(aBackgroundFrame->PresContext(),
40177:                                       aBackgroundFrame, &bgSC)) {
16601:     return eTransparencyTransparent;
31535:   }
40177:   const nsStyleBackground* bg = bgSC->GetStyleBackground();
25276:   if (NS_GET_A(bg->mBackgroundColor) < 255 ||
25276:       // bottom layer's clip is used for the color
25276:       bg->BottomLayer().mClip != NS_STYLE_BG_CLIP_BORDER)
16601:     return eTransparencyTransparent;
16601:   return eTransparencyOpaque;
 1345: }
 4032: 
87435: static bool IsPopupFrame(nsIFrame* aFrame)
87435: {
87435:   // aFrame is a popup it's the list control frame dropdown for a combobox.
87435:   nsIAtom* frameType = aFrame->GetType();
87435:   if (frameType == nsGkAtoms::listControlFrame) {
87435:     nsListControlFrame* lcf = static_cast<nsListControlFrame*>(aFrame);
87435:     return lcf->IsInDropDownMode();
87435:   }
87435: 
87435:   // ... or if it's a XUL menupopup frame.
87435:   return frameType == nsGkAtoms::menuPopupFrame;
87435: }
87435: 
79445: /* static */ bool
37081: nsLayoutUtils::IsPopup(nsIFrame* aFrame)
37081: {
87435:   // Optimization: the frame can't possibly be a popup if it has no view.
87435:   if (!aFrame->HasView()) {
87435:     NS_ASSERTION(!IsPopupFrame(aFrame), "popup frame must have a view");
87435:     return false;
87435:   }
87435:   return IsPopupFrame(aFrame);
37081: }
37081: 
37081: /* static */ nsIFrame*
37081: nsLayoutUtils::GetDisplayRootFrame(nsIFrame* aFrame)
37081: {
37081:   nsIFrame* f = aFrame;
37081:   for (;;) {
37081:     if (IsPopup(f))
37081:       return f;
37081:     nsIFrame* parent = GetCrossDocParentFrame(f);
37081:     if (!parent)
37081:       return f;
37081:     f = parent;
37081:   }
37081: }
37081: 
79445: static bool
 4032: IsNonzeroCoord(const nsStyleCoord& aCoord)
 4032: {
 4032:   if (eStyleUnit_Coord == aCoord.GetUnit())
 4032:     return aCoord.GetCoordValue() != 0;
80486:   return false;
 4032: }
 4032: 
 4032: /* static */ PRUint32
 4032: nsLayoutUtils::GetTextRunFlagsForStyle(nsStyleContext* aStyleContext,
 4032:                                        const nsStyleText* aStyleText,
 4032:                                        const nsStyleFont* aStyleFont)
 4032: {
 4032:   PRUint32 result = 0;
 4032:   if (IsNonzeroCoord(aStyleText->mLetterSpacing)) {
 4032:     result |= gfxTextRunFactory::TEXT_DISABLE_OPTIONAL_LIGATURES;
 4032:   }
 4032:   switch (aStyleContext->GetStyleSVG()->mTextRendering) {
 4032:   case NS_STYLE_TEXT_RENDERING_OPTIMIZESPEED:
 4032:     result |= gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
 4032:     break;
 4032:   case NS_STYLE_TEXT_RENDERING_AUTO:
 4032:     if (aStyleFont->mFont.size <
 4032:         aStyleContext->PresContext()->GetAutoQualityMinFontSize()) {
 4032:       result |= gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
 4032:     }
 4032:     break;
 4032:   default:
 4032:     break;
 4032:   }
 4032:   return result;
 4032: }
11384: 
11384: /* static */ void
11384: nsLayoutUtils::GetRectDifferenceStrips(const nsRect& aR1, const nsRect& aR2,
11384:                                        nsRect* aHStrip, nsRect* aVStrip) {
11384:   NS_ASSERTION(aR1.TopLeft() == aR2.TopLeft(),
11384:                "expected rects at the same position");
32531:   nsRect unionRect(aR1.x, aR1.y, NS_MAX(aR1.width, aR2.width),
32531:                    NS_MAX(aR1.height, aR2.height));
32531:   nscoord VStripStart = NS_MIN(aR1.width, aR2.width);
32531:   nscoord HStripStart = NS_MIN(aR1.height, aR2.height);
11384:   *aVStrip = unionRect;
11384:   aVStrip->x += VStripStart;
11384:   aVStrip->width -= VStripStart;
11384:   *aHStrip = unionRect;
11384:   aHStrip->y += HStripStart;
11384:   aHStrip->height -= HStripStart;
11384: }
11384: 
68668: nsDeviceContext*
93485: nsLayoutUtils::GetDeviceContextForScreenInfo(nsPIDOMWindow* aWindow)
16228: {
95491:   if (!aWindow) {
95491:     return nsnull;
95491:   }
95491: 
93485:   nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
16228:   while (docShell) {
16228:     // Now make sure our size is up to date.  That will mean that the device
16228:     // context does the right thing on multi-monitor systems when we return it to
16228:     // the caller.  It will also make sure that our prescontext has been created,
16228:     // if we're supposed to have one.
16228:     nsCOMPtr<nsPIDOMWindow> win = do_GetInterface(docShell);
16228:     if (!win) {
16228:       // No reason to go on
16228:       return nsnull;
16228:     }
16228: 
16228:     win->EnsureSizeUpToDate();
16228: 
32132:     nsRefPtr<nsPresContext> presContext;
32132:     docShell->GetPresContext(getter_AddRefs(presContext));
32132:     if (presContext) {
68668:       nsDeviceContext* context = presContext->DeviceContext();
32132:       if (context) {
32132:         return context;
32132:       }
16228:     }
16228: 
16228:     nsCOMPtr<nsIDocShellTreeItem> curItem = do_QueryInterface(docShell);
16228:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
16228:     curItem->GetParent(getter_AddRefs(parentItem));
16228:     docShell = do_QueryInterface(parentItem);
16228:   }
16228: 
16228:   return nsnull;
16228: }
16228: 
79445: /* static */ bool
21903: nsLayoutUtils::IsReallyFixedPos(nsIFrame* aFrame)
21903: {
21903:   NS_PRECONDITION(aFrame->GetParent(),
21903:                   "IsReallyFixedPos called on frame not in tree");
21903:   NS_PRECONDITION(aFrame->GetStyleDisplay()->mPosition ==
21903:                     NS_STYLE_POSITION_FIXED,
21903:                   "IsReallyFixedPos called on non-'position:fixed' frame");
21903: 
23170:   nsIAtom *parentType = aFrame->GetParent()->GetType();
23170:   return parentType == nsGkAtoms::viewportFrame ||
23170:          parentType == nsGkAtoms::pageContentFrame;
21903: }
21903: 
29572: nsLayoutUtils::SurfaceFromElementResult
83345: nsLayoutUtils::SurfaceFromElement(dom::Element* aElement,
29572:                                   PRUint32 aSurfaceFlags)
29572: {
29572:   SurfaceFromElementResult result;
29572:   nsresult rv;
29572: 
79445:   bool forceCopy = (aSurfaceFlags & SFE_WANT_NEW_SURFACE) != 0;
79445:   bool wantImageSurface = (aSurfaceFlags & SFE_WANT_IMAGE_SURFACE) != 0;
93959:   bool premultAlpha = (aSurfaceFlags & SFE_NO_PREMULTIPLY_ALPHA) == 0;
93959: 
93959:   if (!premultAlpha) {
80486:     forceCopy = true;
80486:     wantImageSurface = true;
60418:   }
60418: 
29572:   // If it's a <canvas>, we may be able to just grab its internal surface
83345:   if (nsHTMLCanvasElement* canvas = nsHTMLCanvasElement::FromContent(aElement)) {
83345:     gfxIntSize size = canvas->GetSize();
29572: 
29572:     nsRefPtr<gfxASurface> surf;
29572: 
29572:     if (!forceCopy && canvas->CountContexts() == 1) {
29572:       nsICanvasRenderingContextInternal *srcCanvas = canvas->GetContextAtIndex(0);
29572:       rv = srcCanvas->GetThebesSurface(getter_AddRefs(surf));
29572: 
29572:       if (NS_FAILED(rv))
29572:         surf = nsnull;
29572:     }
29572: 
29572:     if (surf && wantImageSurface && surf->GetType() != gfxASurface::SurfaceTypeImage)
29572:       surf = nsnull;
29572: 
29572:     if (!surf) {
29572:       if (wantImageSurface) {
42402:         surf = new gfxImageSurface(size, gfxASurface::ImageFormatARGB32);
29572:       } else {
54253:         surf = gfxPlatform::GetPlatform()->CreateOffscreenSurface(size, gfxASurface::CONTENT_COLOR_ALPHA);
29572:       }
29572: 
29572:       nsRefPtr<gfxContext> ctx = new gfxContext(surf);
42402:       // XXX shouldn't use the external interface, but maybe we can layerify this
93959:       PRUint32 flags = premultAlpha ? nsHTMLCanvasElement::RenderFlagPremultAlpha : 0;
93959:       rv = canvas->RenderContextsExternal(ctx, gfxPattern::FILTER_NEAREST, flags);
29572:       if (NS_FAILED(rv))
29572:         return result;
29572:     }
29572: 
63839:     // Ensure that any future changes to the canvas trigger proper invalidation,
63839:     // in case this is being used by -moz-element()
63839:     canvas->MarkContextClean();
63839: 
29572:     result.mSurface = surf;
42402:     result.mSize = size;
83345:     result.mPrincipal = aElement->NodePrincipal();
29572:     result.mIsWriteOnly = canvas->IsWriteOnly();
29572: 
29572:     return result;
29572:   }
29572: 
29572: #ifdef MOZ_MEDIA
29572:   // Maybe it's <video>?
83345:   if (nsHTMLVideoElement* video = nsHTMLVideoElement::FromContent(aElement)) {
83345:     PRUint16 readyState;
83345:     if (NS_SUCCEEDED(video->GetReadyState(&readyState)) &&
43798:         (readyState == nsIDOMHTMLMediaElement::HAVE_NOTHING ||
43798:          readyState == nsIDOMHTMLMediaElement::HAVE_METADATA)) {
80486:       result.mIsStillLoading = true;
43798:       return result;
43798:     }
43798: 
29572:     // If it doesn't have a principal, just bail
29572:     nsCOMPtr<nsIPrincipal> principal = video->GetCurrentPrincipal();
29572:     if (!principal)
29572:       return result;
29572: 
39499:     ImageContainer *container = video->GetImageContainer();
39499:     if (!container)
29572:       return result;
29572: 
39499:     gfxIntSize size;
39499:     nsRefPtr<gfxASurface> surf = container->GetCurrentAsSurface(&size);
39499:     if (!surf)
39499:       return result;
39499: 
39499:     if (wantImageSurface && surf->GetType() != gfxASurface::SurfaceTypeImage) {
39499:       nsRefPtr<gfxImageSurface> imgSurf =
39499:         new gfxImageSurface(size, gfxASurface::ImageFormatARGB32);
39499: 
39499:       nsRefPtr<gfxContext> ctx = new gfxContext(imgSurf);
29572:       ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
39499:       ctx->DrawSurface(surf, size);
39499:       surf = imgSurf;
39499:     }
29572: 
91989:     result.mCORSUsed = video->GetCORSMode() != CORS_NONE;
29572:     result.mSurface = surf;
39499:     result.mSize = size;
63836:     result.mPrincipal = principal.forget();
80486:     result.mIsWriteOnly = false;
29572: 
29572:     return result;
29572:   }
29572: #endif
29572: 
29572:   // Finally, check if it's a normal image
29572:   nsCOMPtr<nsIImageLoadingContent> imageLoader = do_QueryInterface(aElement);
29572: 
29572:   if (!imageLoader)
29572:     return result;
29572: 
61720:   // Push a null JSContext on the stack so that code that runs within
61720:   // the below code doesn't think it's being called by JS. See bug
61720:   // 604262.
61720:   nsCxPusher pusher;
61720:   pusher.PushNull();
61720: 
29572:   nsCOMPtr<imgIRequest> imgRequest;
29572:   rv = imageLoader->GetRequest(nsIImageLoadingContent::CURRENT_REQUEST,
29572:                                getter_AddRefs(imgRequest));
29572:   if (NS_FAILED(rv) || !imgRequest)
29572:     return result;
29572: 
29572:   PRUint32 status;
29572:   imgRequest->GetImageStatus(&status);
43798:   if ((status & imgIRequest::STATUS_LOAD_COMPLETE) == 0) {
43798:     // Spec says to use GetComplete, but that only works on
43798:     // nsIDOMHTMLImageElement, and we support all sorts of other stuff
43798:     // here.  Do this for now pending spec clarification.
43798:     result.mIsStillLoading = (status & imgIRequest::STATUS_ERROR) == 0;
29572:     return result;
43798:   }
29572: 
29572:   nsCOMPtr<nsIPrincipal> principal;
29572:   rv = imgRequest->GetImagePrincipal(getter_AddRefs(principal));
29572:   if (NS_FAILED(rv) || !principal)
29572:     return result;
29572: 
30479:   nsCOMPtr<imgIContainer> imgContainer;
29572:   rv = imgRequest->GetImage(getter_AddRefs(imgContainer));
29572:   if (NS_FAILED(rv) || !imgContainer)
29572:     return result;
29572: 
32424:   PRUint32 whichFrame = (aSurfaceFlags & SFE_WANT_FIRST_FRAME)
32424:                         ? (PRUint32) imgIContainer::FRAME_FIRST
32424:                         : (PRUint32) imgIContainer::FRAME_CURRENT;
60418:   PRUint32 frameFlags = imgIContainer::FLAG_SYNC_DECODE;
60418:   if (aSurfaceFlags & SFE_NO_COLORSPACE_CONVERSION)
60418:     frameFlags |= imgIContainer::FLAG_DECODE_NO_COLORSPACE_CONVERSION;
60418:   if (aSurfaceFlags & SFE_NO_PREMULTIPLY_ALPHA)
60418:     frameFlags |= imgIContainer::FLAG_DECODE_NO_PREMULTIPLY_ALPHA;
30479:   nsRefPtr<gfxASurface> framesurf;
32424:   rv = imgContainer->GetFrame(whichFrame,
60418:                               frameFlags,
32424:                               getter_AddRefs(framesurf));
29572:   if (NS_FAILED(rv))
29572:     return result;
29572: 
29572:   PRInt32 imgWidth, imgHeight;
30479:   rv = imgContainer->GetWidth(&imgWidth);
30479:   rv |= imgContainer->GetHeight(&imgHeight);
29572:   if (NS_FAILED(rv))
29572:     return result;
29572: 
30479:   if (wantImageSurface && framesurf->GetType() != gfxASurface::SurfaceTypeImage) {
80486:     forceCopy = true;
29572:   }
29572: 
30479:   nsRefPtr<gfxASurface> gfxsurf = framesurf;
30479:   if (forceCopy) {
29572:     if (wantImageSurface) {
29572:       gfxsurf = new gfxImageSurface (gfxIntSize(imgWidth, imgHeight), gfxASurface::ImageFormatARGB32);
29572:     } else {
29572:       gfxsurf = gfxPlatform::GetPlatform()->CreateOffscreenSurface(gfxIntSize(imgWidth, imgHeight),
54253:                                                                    gfxASurface::CONTENT_COLOR_ALPHA);
29572:     }
29572: 
29572:     nsRefPtr<gfxContext> ctx = new gfxContext(gfxsurf);
29572: 
29572:     ctx->SetOperator(gfxContext::OPERATOR_SOURCE);
30479:     ctx->SetSource(framesurf);
29572:     ctx->Paint();
29572:   }
29572: 
78159:   PRInt32 corsmode;
78159:   if (NS_SUCCEEDED(imgRequest->GetCORSMode(&corsmode))) {
78159:     result.mCORSUsed = (corsmode != imgIRequest::CORS_NONE);
78159:   }
78159: 
29572:   result.mSurface = gfxsurf;
29572:   result.mSize = gfxIntSize(imgWidth, imgHeight);
63836:   result.mPrincipal = principal.forget();
84921:   // no images, including SVG images, can load content from another domain.
84921:   result.mIsWriteOnly = false;
63836:   result.mImageRequest = imgRequest.forget();
29572: 
29572:   return result;
29572: }
29572: 
41068: /* static */
41068: nsIContent*
41068: nsLayoutUtils::GetEditableRootContentByContentEditable(nsIDocument* aDocument)
41068: {
41068:   // If the document is in designMode we should return NULL.
41068:   if (!aDocument || aDocument->HasFlag(NODE_IS_EDITABLE)) {
41068:     return nsnull;
41068:   }
41068: 
41068:   // contenteditable only works with HTML document.
41068:   // Note: Use nsIDOMHTMLDocument rather than nsIHTMLDocument for getting the
41068:   //       body node because nsIDOMHTMLDocument::GetBody() does something
41068:   //       additional work for some cases and nsEditor uses them.
41068:   nsCOMPtr<nsIDOMHTMLDocument> domHTMLDoc = do_QueryInterface(aDocument);
41068:   if (!domHTMLDoc) {
41068:     return nsnull;
41068:   }
41068: 
41634:   Element* rootElement = aDocument->GetRootElement();
41634:   if (rootElement && rootElement->IsEditable()) {
41634:     return rootElement;
41068:   }
41068: 
41068:   // If there are no editable root element, check its <body> element.
41068:   // Note that the body element could be <frameset> element.
41068:   nsCOMPtr<nsIDOMHTMLElement> body;
41068:   nsresult rv = domHTMLDoc->GetBody(getter_AddRefs(body));
41068:   nsCOMPtr<nsIContent> content = do_QueryInterface(body);
41068:   if (NS_SUCCEEDED(rv) && content && content->IsEditable()) {
41068:     return content;
41068:   }
41068:   return nsnull;
41068: }
41068: 
60338: #ifdef DEBUG
60338: /* static */ void
60338: nsLayoutUtils::AssertNoDuplicateContinuations(nsIFrame* aContainer,
60338:                                               const nsFrameList& aFrameList)
60338: {
60338:   for (nsIFrame* f = aFrameList.FirstChild(); f ; f = f->GetNextSibling()) {
60338:     // Check only later continuations of f; we deal with checking the
60338:     // earlier continuations when we hit those earlier continuations in
60338:     // the frame list.
60338:     for (nsIFrame *c = f; (c = c->GetNextInFlow());) {
60338:       NS_ASSERTION(c->GetParent() != aContainer ||
60338:                    !aFrameList.ContainsFrame(c),
60338:                    "Two continuations of the same frame in the same "
60338:                    "frame list");
60338:     }
60338:   }
60338: }
60341: 
60341: // Is one of aFrame's ancestors a letter frame?
60341: static bool
60341: IsInLetterFrame(nsIFrame *aFrame)
60341: {
60341:   for (nsIFrame *f = aFrame->GetParent(); f; f = f->GetParent()) {
60341:     if (f->GetType() == nsGkAtoms::letterFrame) {
60341:       return true;
60341:     }
60341:   }
60341:   return false;
60341: }
60341: 
60341: /* static */ void
60341: nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(nsIFrame *aSubtreeRoot)
60341: {
60341:   NS_ASSERTION(aSubtreeRoot->GetPrevInFlow(),
60341:                "frame tree not empty, but caller reported complete status");
60341: 
60341:   // Also assert that text frames map no text.
60341:   PRInt32 start, end;
60341:   nsresult rv = aSubtreeRoot->GetOffsets(start, end);
60341:   NS_ASSERTION(NS_SUCCEEDED(rv), "GetOffsets failed");
60341:   // In some cases involving :first-letter, we'll partially unlink a
60341:   // continuation in the middle of a continuation chain from its
60341:   // previous and next continuations before destroying it, presumably so
60341:   // that we don't also destroy the later continuations.  Once we've
60341:   // done this, GetOffsets returns incorrect values.
60341:   // For examples, see list of tests in
60341:   // https://bugzilla.mozilla.org/show_bug.cgi?id=619021#c29
60341:   NS_ASSERTION(start == end || IsInLetterFrame(aSubtreeRoot),
60341:                "frame tree not empty, but caller reported complete status");
60341: 
77153:   nsIFrame::ChildListIterator lists(aSubtreeRoot);
77153:   for (; !lists.IsDone(); lists.Next()) {
77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
77153:       nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(childFrames.get());
77153:     }
77153:   }
60341: }
60338: #endif
60338: 
60450: /* static */
71908: nsresult
71908: nsLayoutUtils::GetFontFacesForFrames(nsIFrame* aFrame,
71908:                                      nsFontFaceList* aFontFaceList)
71908: {
71908:   NS_PRECONDITION(aFrame, "NULL frame pointer");
71908: 
71908:   if (aFrame->GetType() == nsGkAtoms::textFrame) {
80486:     return GetFontFacesForText(aFrame, 0, PR_INT32_MAX, false,
71908:                                aFontFaceList);
71908:   }
71908: 
71908:   while (aFrame) {
77153:     nsIFrame::ChildListID childLists[] = { nsIFrame::kPrincipalList,
77153:                                            nsIFrame::kPopupList };
85981:     for (size_t i = 0; i < ArrayLength(childLists); ++i) {
71908:       nsFrameList children(aFrame->GetChildList(childLists[i]));
71908:       for (nsFrameList::Enumerator e(children); !e.AtEnd(); e.Next()) {
71908:         nsIFrame* child = e.get();
71908:         if (child->GetPrevContinuation()) {
71908:           continue;
71908:         }
71908:         child = nsPlaceholderFrame::GetRealFrameFor(child);
71908:         nsresult rv = GetFontFacesForFrames(child, aFontFaceList);
71908:         NS_ENSURE_SUCCESS(rv, rv);
71908:       }
71908:     }
71908:     aFrame = GetNextContinuationOrSpecialSibling(aFrame);
71908:   }
71908: 
71908:   return NS_OK;
71908: }
71908: 
71908: /* static */
71908: nsresult
71908: nsLayoutUtils::GetFontFacesForText(nsIFrame* aFrame,
71908:                                    PRInt32 aStartOffset, PRInt32 aEndOffset,
79445:                                    bool aFollowContinuations,
71908:                                    nsFontFaceList* aFontFaceList)
71908: {
71908:   NS_PRECONDITION(aFrame, "NULL frame pointer");
71908: 
71908:   if (aFrame->GetType() != nsGkAtoms::textFrame) {
71908:     return NS_OK;
71908:   }
71908: 
71908:   nsTextFrame* curr = static_cast<nsTextFrame*>(aFrame);
71908:   do {
80704:     PRInt32 fstart = NS_MAX(curr->GetContentOffset(), aStartOffset);
71908:     PRInt32 fend = NS_MIN(curr->GetContentEnd(), aEndOffset);
71908:     if (fstart >= fend) {
71908:       continue;
71908:     }
71908: 
71908:     // overlapping with the offset we want
82675:     gfxSkipCharsIterator iter = curr->EnsureTextRun(nsTextFrame::eInflated);
82675:     gfxTextRun* textRun = curr->GetTextRun(nsTextFrame::eInflated);
71908:     NS_ENSURE_TRUE(textRun, NS_ERROR_OUT_OF_MEMORY);
71908: 
80704:     PRUint32 skipStart = iter.ConvertOriginalToSkipped(fstart);
80704:     PRUint32 skipEnd = iter.ConvertOriginalToSkipped(fend);
71908:     aFontFaceList->AddFontsFromTextRun(textRun,
80704:                                        skipStart,
80704:                                        skipEnd - skipStart,
71909:                                        curr);
71908:   } while (aFollowContinuations &&
71908:            (curr = static_cast<nsTextFrame*>(curr->GetNextContinuation())));
71908: 
71908:   return NS_OK;
71908: }
71908: 
71908: /* static */
82849: size_t
82849: nsLayoutUtils::SizeOfTextRunsForFrames(nsIFrame* aFrame,
82849:                                        nsMallocSizeOfFun aMallocSizeOf,
82849:                                        bool clear)
80375: {
80375:   NS_PRECONDITION(aFrame, "NULL frame pointer");
80375: 
82849:   size_t total = 0;
82849: 
80375:   if (aFrame->GetType() == nsGkAtoms::textFrame) {
80375:     nsTextFrame* textFrame = static_cast<nsTextFrame*>(aFrame);
82675:     for (PRUint32 i = 0; i < 2; ++i) {
82675:       gfxTextRun *run = textFrame->GetTextRun(
82675:         (i != 0) ? nsTextFrame::eInflated : nsTextFrame::eNotInflated);
80375:       if (run) {
82849:         if (clear) {
82849:           run->ResetSizeOfAccountingFlags();
80375:         } else {
82849:           total += run->MaybeSizeOfIncludingThis(aMallocSizeOf);
82849:         }
82849:       }
82849:     }
82849:     return total;
80375:   }
80375: 
80375:   nsAutoTArray<nsIFrame::ChildList,4> childListArray;
80375:   aFrame->GetChildLists(&childListArray);
80375: 
80375:   for (nsIFrame::ChildListArrayIterator childLists(childListArray);
80375:        !childLists.IsDone(); childLists.Next()) {
80375:     for (nsFrameList::Enumerator e(childLists.CurrentList());
80375:          !e.AtEnd(); e.Next()) {
82849:       total += SizeOfTextRunsForFrames(e.get(), aMallocSizeOf, clear);
82849:     }
82849:   }
82849:   return total;
80375: }
80375: 
80375: /* static */
60450: void
82670: nsLayoutUtils::Initialize()
82670: {
82670:   mozilla::Preferences::AddUintVarCache(&sFontSizeInflationEmPerLine,
82670:                                         "font.size.inflation.emPerLine");
82670:   mozilla::Preferences::AddUintVarCache(&sFontSizeInflationMinTwips,
82670:                                         "font.size.inflation.minTwips");
95532:   mozilla::Preferences::AddUintVarCache(&sFontSizeInflationLineThreshold,
95532:                                         "font.size.inflation.lineThreshold");
82670: }
82670: 
82670: /* static */
82670: void
60450: nsLayoutUtils::Shutdown()
60450: {
60450:   if (sContentMap) {
60450:     delete sContentMap;
60450:     sContentMap = NULL;
60450:   }
60450: }
60450: 
82098: /* static */
82098: void
82098: nsLayoutUtils::RegisterImageRequest(nsPresContext* aPresContext,
82098:                                     imgIRequest* aRequest,
82098:                                     bool* aRequestRegistered)
82098: {
82098:   if (!aPresContext) {
82098:     return;
82098:   }
82098: 
82098:   if (aRequestRegistered && *aRequestRegistered) {
82098:     // Our request is already registered with the refresh driver, so
82098:     // no need to register it again.
82098:     return;
82098:   }
82098: 
82098:   if (aRequest) {
82098:     if (!aPresContext->RefreshDriver()->AddImageRequest(aRequest)) {
82098:       NS_WARNING("Unable to add image request");
82098:       return;
82098:     }
82098: 
82098:     if (aRequestRegistered) {
82098:       *aRequestRegistered = true;
82098:     }
82098:   }
82098: }
82098: 
82098: /* static */
82098: void
82098: nsLayoutUtils::RegisterImageRequestIfAnimated(nsPresContext* aPresContext,
82098:                                               imgIRequest* aRequest,
82098:                                               bool* aRequestRegistered)
82098: {
82098:   if (!aPresContext) {
82098:     return;
82098:   }
82098: 
82098:   if (aRequestRegistered && *aRequestRegistered) {
82098:     // Our request is already registered with the refresh driver, so
82098:     // no need to register it again.
82098:     return;
82098:   }
82098: 
82098:   if (aRequest) {
82098:     nsCOMPtr<imgIContainer> image;
82098:     aRequest->GetImage(getter_AddRefs(image));
82098:     if (image) {
82098: 
82098:       // Check to verify that the image is animated. If so, then add it to the
82098:       // list of images tracked by the refresh driver.
82098:       bool isAnimated = false;
82098:       nsresult rv = image->GetAnimated(&isAnimated);
82098:       if (NS_SUCCEEDED(rv) && isAnimated) {
82098:         if (!aPresContext->RefreshDriver()->AddImageRequest(aRequest)) {
82098:           NS_WARNING("Unable to add image request");
82098:           return;
82098:         }
82098: 
82098:         if (aRequestRegistered) {
82098:           *aRequestRegistered = true;
82098:         }
82098:       }
82098:     }
82098:   }
82098: }
82098: 
82098: /* static */
82098: void
82098: nsLayoutUtils::DeregisterImageRequest(nsPresContext* aPresContext,
82098:                                       imgIRequest* aRequest,
82098:                                       bool* aRequestRegistered)
82098: {
82098:   if (!aPresContext) {
82098:     return;
82098:   }
82098: 
82098:   // Deregister our imgIRequest with the refresh driver to
82098:   // complete tear-down, but only if it has been registered
82098:   if (aRequestRegistered && !*aRequestRegistered) {
82098:     return;
82098:   }
82098: 
82098:   if (aRequest) {
82098:     nsCOMPtr<imgIContainer> image;
82098:     aRequest->GetImage(getter_AddRefs(image));
82098:     if (image) {
82098:       aPresContext->RefreshDriver()->RemoveImageRequest(aRequest);
82098: 
82098:       if (aRequestRegistered) {
82098:         *aRequestRegistered = false;
82098:       }
82098:     }
82098:   }
82098: }
82098: 
14319: nsSetAttrRunnable::nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
14319:                                      const nsAString& aValue)
14319:   : mContent(aContent),
14319:     mAttrName(aAttrName),
14319:     mValue(aValue)
14319: {
14319:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
14319: }
14319: 
41743: nsSetAttrRunnable::nsSetAttrRunnable(nsIContent* aContent, nsIAtom* aAttrName,
41743:                                      PRInt32 aValue)
41743:   : mContent(aContent),
41743:     mAttrName(aAttrName)
41743: {
41743:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
41743:   mValue.AppendInt(aValue);
41743: }
41743: 
14319: NS_IMETHODIMP
14319: nsSetAttrRunnable::Run()
14319: {
80486:   return mContent->SetAttr(kNameSpaceID_None, mAttrName, mValue, true);
14319: }
14319: 
14319: nsUnsetAttrRunnable::nsUnsetAttrRunnable(nsIContent* aContent,
14319:                                          nsIAtom* aAttrName)
14319:   : mContent(aContent),
14319:     mAttrName(aAttrName)
14319: {
14319:   NS_ASSERTION(aContent && aAttrName, "Missing stuff, prepare to crash");
14319: }
14319: 
14319: NS_IMETHODIMP
14319: nsUnsetAttrRunnable::Run()
14319: {
80486:   return mContent->UnsetAttr(kNameSpaceID_None, mAttrName, true);
14319: }
23933: 
23933: nsReflowFrameRunnable::nsReflowFrameRunnable(nsIFrame* aFrame,
23933:                           nsIPresShell::IntrinsicDirty aIntrinsicDirty,
23933:                           nsFrameState aBitToAdd)
23933:   : mWeakFrame(aFrame),
23933:     mIntrinsicDirty(aIntrinsicDirty),
23933:     mBitToAdd(aBitToAdd)
23933: {
23933: }
23933: 
23933: NS_IMETHODIMP
23933: nsReflowFrameRunnable::Run()
23933: {
23933:   if (mWeakFrame.IsAlive()) {
23933:     mWeakFrame->PresContext()->PresShell()->
23933:       FrameNeedsReflow(mWeakFrame, mIntrinsicDirty, mBitToAdd);
23933:   }
23933:   return NS_OK;
23933: }
82670: 
82670: /**
82670:  * Compute the minimum font size inside of a container with the given
82670:  * width, such that **when the user zooms the container to fill the full
82670:  * width of the device**, the fonts satisfy our minima.
82670:  */
82670: static nscoord
82670: MinimumFontSizeFor(nsPresContext* aPresContext, nscoord aContainerWidth)
82670: {
82670:   if (sFontSizeInflationEmPerLine == 0 && sFontSizeInflationMinTwips == 0) {
82670:     return 0;
82670:   }
85975: 
85975:   // Clamp the container width to the device dimensions
85975:   nscoord iFrameWidth = aPresContext->GetVisibleArea().width;
85975:   nscoord effectiveContainerWidth = NS_MIN(iFrameWidth, aContainerWidth);
85975: 
82670:   nscoord byLine = 0, byInch = 0;
82670:   if (sFontSizeInflationEmPerLine != 0) {
85975:     byLine = effectiveContainerWidth / sFontSizeInflationEmPerLine;
82670:   }
82670:   if (sFontSizeInflationMinTwips != 0) {
82670:     // REVIEW: Is this giving us app units and sizes *not* counting
82670:     // viewport scaling?
82670:     nsDeviceContext *dx = aPresContext->DeviceContext();
82670:     nsRect clientRect;
82670:     dx->GetClientRect(clientRect); // FIXME: GetClientRect looks expensive
82670:     float deviceWidthInches =
82670:       float(clientRect.width) / float(dx->AppUnitsPerPhysicalInch());
85975:     byInch = NSToCoordRound(effectiveContainerWidth /
82670:                             (deviceWidthInches * 1440 /
82670:                              sFontSizeInflationMinTwips ));
82670:   }
82670:   return NS_MAX(byLine, byInch);
82670: }
82670: 
82670: /* static */ float
82670: nsLayoutUtils::FontSizeInflationInner(const nsIFrame *aFrame,
82670:                                       nscoord aMinFontSize)
82670: {
82670:   // Note that line heights should be inflated by the same ratio as the
82670:   // font size of the same text; thus we operate only on the font size
82670:   // even when we're scaling a line height.
82670:   nscoord styleFontSize = aFrame->GetStyleFont()->mFont.size;
82670:   if (styleFontSize <= 0) {
82670:     // Never scale zero font size.
82670:     return 1.0;
82670:   }
82670: 
82670:   if (aMinFontSize <= 0) {
82670:     // No need to scale.
82670:     return 1.0;
82670:   }
82670: 
95343:   // If between this current frame and its font inflation container there is a
95343:   // non-inline element with fixed width or height, then we should not inflate
95343:   // fonts for this frame.
95343:   for (const nsIFrame* f = aFrame;
95343:        f && !IsContainerForFontSizeInflation(f);
95343:        f = f->GetParent()) {
95343:     nsIContent* content = f->GetContent();
95343:     // Also, if there is more than one frame corresponding to a single
95343:     // content node, we want the outermost one.
97702:     if (!(f->GetParent() && f->GetParent()->GetContent() == content) &&
95343:         f->GetType() != nsGkAtoms::inlineFrame) {
95343:       nsStyleCoord stylePosWidth = f->GetStylePosition()->mWidth;
95343:       nsStyleCoord stylePosHeight = f->GetStylePosition()->mHeight;
95343:       if (stylePosWidth.GetUnit() != eStyleUnit_Auto ||
95343:           stylePosHeight.GetUnit() != eStyleUnit_Auto) {
95343: 
95343:         return 1.0;
95343:       }
95343:     }
95343:   }
95343: 
82670:   // Scale everything from 0-1.5 times min to instead fit in the range
82670:   // 1-1.5 times min, so that we still show some distinction rather than
82670:   // just enforcing a minimum.
82670:   // FIXME: Fiddle with this algorithm; maybe have prefs to control it?
82670:   float ratio = float(styleFontSize) / float(aMinFontSize);
82670:   if (ratio >= 1.5f) {
82670:     // If we're already at 1.5 or more times the minimum, don't scale.
82670:     return 1.0;
82670:   }
82670: 
82670:   // To scale 0-1.5 times min to instead be 1-1.5 times min, we want
82670:   // to the desired multiple of min to be 1 + (ratio/3) (where ratio
82670:   // is our input's multiple of min).  The scaling needed to produce
82670:   // that is that divided by |ratio|, or:
82670:   return (1.0f / ratio) + (1.0f / 3.0f);
82670: }
82670: 
95535: static inline bool
95535: InflationDataSaysEnabled(const nsIFrame *aFrame)
95535: {
95535:   nsFontInflationData *data =
95535:     nsFontInflationData::FindFontInflationDataFor(aFrame);
95535:   return data && data->InflationEnabled();
95535: }
95535: 
82670: static bool
82670: ShouldInflateFontsForContainer(const nsIFrame *aFrame)
82670: {
82670:   // We only want to inflate fonts for text that is in a place
82670:   // with room to expand.  The question is what the best heuristic for
82670:   // that is...
82670:   // For now, we're going to use NS_FRAME_IN_CONSTRAINED_HEIGHT, which
82670:   // indicates whether the frame is inside something with a constrained
82670:   // height (propagating down the tree), but the propagation stops when
82670:   // we hit overflow-y: scroll or auto.
91426:   const nsStyleText* styleText = aFrame->GetStyleText();
91426: 
91426:   return styleText->mTextSizeAdjust != NS_STYLE_TEXT_SIZE_ADJUST_NONE &&
91426:          !(aFrame->GetStateBits() & NS_FRAME_IN_CONSTRAINED_HEIGHT) &&
91426:          // We also want to disable font inflation for containers that have
91426:          // preformatted text.
95535:          styleText->WhiteSpaceCanWrap() &&
95535:          InflationDataSaysEnabled(aFrame);
82670: }
82670: 
82670: nscoord
88124: nsLayoutUtils::InflationMinFontSizeFor(const nsIFrame *aFrame,
88124:                                        WidthDetermination aWidthDetermination)
82670: {
82670: #ifdef DEBUG
88124:   if (aWidthDetermination == eNotInReflow) {
82670:     // Check that neither this frame nor any of its ancestors are
82670:     // currently being reflowed.
82670:     // It's ok for box frames (but not arbitrary ancestors of box frames)
82670:     // since they set their size before reflow.
82670:     if (!(aFrame->IsBoxFrame() && IsContainerForFontSizeInflation(aFrame))) {
82670:       for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
82670:         NS_ABORT_IF_FALSE(!(f->GetStateBits() & NS_FRAME_IN_REFLOW),
82670:                           "must call nsHTMLReflowState& version during reflow");
82670:       }
82670:     }
82670:     // It's ok if frames are dirty, or even if they've never been
82670:     // reflowed, since they will be eventually and then we'll get the
82670:     // right size.
88124:   }
82670: #endif
82670: 
82670:   if (!FontSizeInflationEnabled(aFrame->PresContext())) {
82670:     return 0;
82670:   }
82670: 
88124:   if (aWidthDetermination == eInReflow) {
88124:     nsPresContext *presContext = aFrame->PresContext();
88124:     nsIFrame *container = presContext->mCurrentInflationContainer;
88124:     if (!container || !ShouldInflateFontsForContainer(container)) {
88124:       return 0;
88124:     }
88124:     return MinimumFontSizeFor(presContext,
88124:                               presContext->mCurrentInflationContainerWidth);
88124:   }
88124: 
82670:   for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
82670:     if (IsContainerForFontSizeInflation(f)) {
82670:       if (!ShouldInflateFontsForContainer(f)) {
82670:         return 0;
82670:       }
82670: 
82670:       return MinimumFontSizeFor(aFrame->PresContext(),
82670:                                 f->GetContentRect().width);
82670:     }
82670:   }
82670: 
82670:   NS_ABORT_IF_FALSE(false, "root should always be container");
82670: 
82670:   return 0;
82670: }
82670: 
82670: float
88124: nsLayoutUtils::FontSizeInflationFor(const nsIFrame *aFrame,
88124:                                     WidthDetermination aWidthDetermination)
82670: {
82670: #ifdef DEBUG
88124:   if (aWidthDetermination == eNotInReflow) {
82670:     // Check that neither this frame nor any of its ancestors are
82670:     // currently being reflowed.
82670:     // It's ok for box frames (but not arbitrary ancestors of box frames)
82670:     // since they set their size before reflow.
82670:     if (!(aFrame->IsBoxFrame() && IsContainerForFontSizeInflation(aFrame))) {
82670:       for (const nsIFrame *f = aFrame; f; f = f->GetParent()) {
82670:         NS_ABORT_IF_FALSE(!(f->GetStateBits() & NS_FRAME_IN_REFLOW),
82670:                           "must call nsHTMLReflowState& version during reflow");
82670:       }
82670:     }
82670:     // It's ok if frames are dirty, or even if they've never been
82670:     // reflowed, since they will be eventually and then we'll get the
82670:     // right size.
88124:   }
82670: #endif
82670: 
82670:   if (!FontSizeInflationEnabled(aFrame->PresContext())) {
82670:     return 1.0;
82670:   }
82670: 
82670:   return FontSizeInflationInner(aFrame,
82670:                                 InflationMinFontSizeFor(aFrame,
88124:                                                         aWidthDetermination));
82670: }
82670: 
82670: /* static */ bool
82670: nsLayoutUtils::FontSizeInflationEnabled(nsPresContext *aPresContext)
82670: {
88583:   if ((sFontSizeInflationEmPerLine == 0 &&
88583:        sFontSizeInflationMinTwips == 0) ||
88583:        aPresContext->IsChrome()) {
88583:     return false;
88583:   }
88583: 
88583:   ViewportInfo vInf =
88583:     nsContentUtils::GetViewportInfo(aPresContext->PresShell()->GetDocument());
88583: 
88583:   if (vInf.defaultZoom >= 1.0 || vInf.autoSize) {
88583:     return false;
88583:   }
88583: 
88583:   return true;
88583: }
