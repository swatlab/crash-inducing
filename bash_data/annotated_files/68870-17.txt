    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Steve Clark (buster@netscape.com)
    1:  *   Ilya Konstantinov (mozilla-code@future.shiny.co.il)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
46517: #include "base/basictypes.h"
46517: #include "IPC/IPCMessageUtils.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsDOMUIEvent.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIContent.h"
    1: #include "nsContentUtils.h"
68780: #include "nsEventStateManager.h"
    1: #include "nsIFrame.h"
    1: #include "nsLayoutUtils.h"
    1: #include "nsIScrollableFrame.h"
    1: 
    1: nsDOMUIEvent::nsDOMUIEvent(nsPresContext* aPresContext, nsGUIEvent* aEvent)
    1:   : nsDOMEvent(aPresContext, aEvent ?
 3233:                static_cast<nsEvent *>(aEvent) :
 3233:                static_cast<nsEvent *>(new nsUIEvent(PR_FALSE, 0, 0)))
 7852:   , mClientPoint(0, 0), mLayerPoint(0, 0), mPagePoint(0, 0)
    1: {
    1:   if (aEvent) {
    1:     mEventIsInternal = PR_FALSE;
    1:   }
    1:   else {
    1:     mEventIsInternal = PR_TRUE;
    1:     mEvent->time = PR_Now();
    1:   }
    1:   
    1:   // Fill mDetail and mView according to the mEvent (widget-generated
    1:   // event) we've got
    1:   switch(mEvent->eventStructType)
    1:   {
    1:     case NS_UI_EVENT:
    1:     {
 3233:       nsUIEvent *event = static_cast<nsUIEvent*>(mEvent);
    1:       mDetail = event->detail;
    1:       break;
    1:     }
    1: 
    1:     case NS_SCROLLPORT_EVENT:
    1:     {
 3233:       nsScrollPortEvent* scrollEvent = static_cast<nsScrollPortEvent*>(mEvent);
    1:       mDetail = (PRInt32)scrollEvent->orient;
    1:       break;
    1:     }
    1: 
    1:     default:
    1:       mDetail = 0;
    1:       break;
    1:   }
    1: 
    1:   mView = nsnull;
    1:   if (mPresContext)
    1:   {
    1:     nsCOMPtr<nsISupports> container = mPresContext->GetContainer();
    1:     if (container)
    1:     {
    1:        nsCOMPtr<nsIDOMWindowInternal> window = do_GetInterface(container);
    1:        if (window)
    1:           mView = do_QueryInterface(window);
    1:     }
    1:   }
    1: }
    1: 
 2792: NS_IMPL_CYCLE_COLLECTION_CLASS(nsDOMUIEvent)
 2792: 
 2792: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsDOMUIEvent, nsDOMEvent)
 2792:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mView)
 2792: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 2792: 
 2792: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsDOMUIEvent, nsDOMEvent)
 2792:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mView)
 2792: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 2792: 
    1: NS_IMPL_ADDREF_INHERITED(nsDOMUIEvent, nsDOMEvent)
    1: NS_IMPL_RELEASE_INHERITED(nsDOMUIEvent, nsDOMEvent)
    1: 
40490: DOMCI_DATA(UIEvent, nsDOMUIEvent)
40490: 
 2792: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsDOMUIEvent)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMUIEvent)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSUIEvent)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(UIEvent)
    1: NS_INTERFACE_MAP_END_INHERITING(nsDOMEvent)
    1: 
23738: nsIntPoint
23738: nsDOMUIEvent::GetScreenPoint()
23738: {
    1:   if (!mEvent || 
    1:        (mEvent->eventStructType != NS_MOUSE_EVENT &&
    1:         mEvent->eventStructType != NS_POPUP_EVENT &&
    1:         mEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
48711:         mEvent->eventStructType != NS_MOZTOUCH_EVENT &&
25058:         mEvent->eventStructType != NS_DRAG_EVENT &&
25058:         mEvent->eventStructType != NS_SIMPLE_GESTURE_EVENT)) {
23738:     return nsIntPoint(0, 0);
    1:   }
    1: 
    1:   if (!((nsGUIEvent*)mEvent)->widget ) {
    1:     return mEvent->refPoint;
    1:   }
    1: 
25183:   nsIntPoint offset = mEvent->refPoint + 
25183:     ((nsGUIEvent*)mEvent)->widget->WidgetToScreenOffset();
23738:   nscoord factor = mPresContext->DeviceContext()->UnscaledAppUnitsPerDevPixel();
23738:   return nsIntPoint(nsPresContext::AppUnitsToIntCSSPixels(offset.x * factor),
 4003:                     nsPresContext::AppUnitsToIntCSSPixels(offset.y * factor));
    1: }
    1: 
23738: nsIntPoint
23738: nsDOMUIEvent::GetClientPoint()
23738: {
    1:   if (!mEvent ||
    1:       (mEvent->eventStructType != NS_MOUSE_EVENT &&
    1:        mEvent->eventStructType != NS_POPUP_EVENT &&
    1:        mEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
48711:        mEvent->eventStructType != NS_MOZTOUCH_EVENT &&
25058:        mEvent->eventStructType != NS_DRAG_EVENT &&
25058:        mEvent->eventStructType != NS_SIMPLE_GESTURE_EVENT) ||
 7852:       !mPresContext ||
 7852:       !((nsGUIEvent*)mEvent)->widget) {
 7852:     return mClientPoint;
    1:   }
    1: 
 4260:   nsPoint pt(0, 0);
12466:   nsIPresShell* shell = mPresContext->GetPresShell();
 7864:   if (!shell) {
23738:     return nsIntPoint(0, 0);
 7864:   }
 7864:   nsIFrame* rootFrame = shell->GetRootFrame();
 4260:   if (rootFrame)
 4260:     pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(mEvent, rootFrame);
    1: 
23738:   return nsIntPoint(nsPresContext::AppUnitsToIntCSSPixels(pt.x),
 4260:                     nsPresContext::AppUnitsToIntCSSPixels(pt.y));
    1: }
    1: 
    1: NS_IMETHODIMP
68870: nsDOMUIEvent::GetView(nsIDOMAbstractView** aView)
    1: {
    1:   *aView = mView;
    1:   NS_IF_ADDREF(*aView);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::GetDetail(PRInt32* aDetail)
    1: {
    1:   *aDetail = mDetail;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
68870: nsDOMUIEvent::InitUIEvent(const nsAString & typeArg, PRBool canBubbleArg, PRBool cancelableArg, nsIDOMAbstractView *viewArg, PRInt32 detailArg)
    1: {
    1:   nsresult rv = nsDOMEvent::InitEvent(typeArg, canBubbleArg, cancelableArg);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   mDetail = detailArg;
    1:   mView = viewArg;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // ---- nsDOMNSUIEvent implementation -------------------
23738: nsIntPoint
    1: nsDOMUIEvent::GetPagePoint()
    1: {
15901:   if (mPrivateDataDuplicated) {
15901:     return mPagePoint;
15901:   }
15901: 
23738:   nsIntPoint pagePoint = GetClientPoint();
15901: 
15901:   // If there is some scrolling, add scroll info to client point.
15901:   if (mPresContext && mPresContext->GetPresShell()) {
12466:     nsIPresShell* shell = mPresContext->GetPresShell();
 7864:     nsIScrollableFrame* scrollframe = shell->GetRootScrollFrameAsScrollable();
15901:     if (scrollframe) {
15901:       nsPoint pt = scrollframe->GetScrollPosition();
23738:       pagePoint += nsIntPoint(nsPresContext::AppUnitsToIntCSSPixels(pt.x),
    1:                               nsPresContext::AppUnitsToIntCSSPixels(pt.y));
    1:     }
    1:   }
    1: 
15901:   return pagePoint;
15901: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::GetPageX(PRInt32* aPageX)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPageX);
    1:   *aPageX = GetPagePoint().x;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::GetPageY(PRInt32* aPageY)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPageY);
    1:   *aPageY = GetPagePoint().y;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::GetWhich(PRUint32* aWhich)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aWhich);
    1:   // Usually we never reach here, as this is reimplemented for mouse and keyboard events.
    1:   *aWhich = 0;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::GetRangeParent(nsIDOMNode** aRangeParent)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aRangeParent);
    1:   nsIFrame* targetFrame = nsnull;
    1: 
    1:   if (mPresContext) {
68780:     targetFrame = mPresContext->EventStateManager()->GetEventTarget();
    1:   }
    1: 
    1:   *aRangeParent = nsnull;
    1: 
    1:   if (targetFrame) {
    1:     nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(mEvent,
    1:                                                               targetFrame);
    1:     nsCOMPtr<nsIContent> parent = targetFrame->GetContentOffsetsFromPoint(pt).content;
    1:     if (parent) {
61588:       if (parent->IsInNativeAnonymousSubtree() &&
61588:           !nsContentUtils::CanAccessNativeAnon()) {
61588:         return NS_OK;
61588:       }
    1:       return CallQueryInterface(parent, aRangeParent);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::GetRangeOffset(PRInt32* aRangeOffset)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aRangeOffset);
    1:   nsIFrame* targetFrame = nsnull;
    1: 
    1:   if (mPresContext) {
68780:     targetFrame = mPresContext->EventStateManager()->GetEventTarget();
    1:   }
    1: 
    1:   if (targetFrame) {
    1:     nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(mEvent,
    1:                                                               targetFrame);
    1:     *aRangeOffset = targetFrame->GetContentOffsetsFromPoint(pt).offset;
    1:     return NS_OK;
    1:   }
    1:   *aRangeOffset = 0;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::GetCancelBubble(PRBool* aCancelBubble)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aCancelBubble);
    1:   *aCancelBubble =
    1:     (mEvent->flags & NS_EVENT_FLAG_STOP_DISPATCH) ? PR_TRUE : PR_FALSE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::SetCancelBubble(PRBool aCancelBubble)
    1: {
    1:   if (aCancelBubble) {
    1:     mEvent->flags |= NS_EVENT_FLAG_STOP_DISPATCH;
    1:   } else {
    1:     mEvent->flags &= ~NS_EVENT_FLAG_STOP_DISPATCH;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
23738: nsIntPoint
23738: nsDOMUIEvent::GetLayerPoint()
23738: {
    1:   if (!mEvent ||
    1:       (mEvent->eventStructType != NS_MOUSE_EVENT &&
18737:        mEvent->eventStructType != NS_POPUP_EVENT &&
18737:        mEvent->eventStructType != NS_MOUSE_SCROLL_EVENT &&
48711:        mEvent->eventStructType != NS_MOZTOUCH_EVENT &&
25058:        mEvent->eventStructType != NS_DRAG_EVENT &&
25058:        mEvent->eventStructType != NS_SIMPLE_GESTURE_EVENT) ||
 7852:       !mPresContext ||
 7852:       mEventIsInternal) {
 7852:     return mLayerPoint;
    1:   }
    1:   // XXX I'm not really sure this is correct; it's my best shot, though
68780:   nsIFrame* targetFrame = mPresContext->EventStateManager()->GetEventTarget();
    1:   if (!targetFrame)
 7852:     return mLayerPoint;
    1:   nsIFrame* layer = nsLayoutUtils::GetClosestLayer(targetFrame);
    1:   nsPoint pt(nsLayoutUtils::GetEventCoordinatesRelativeTo(mEvent, layer));
23738:   return nsIntPoint(nsPresContext::AppUnitsToIntCSSPixels(pt.x),
23738:                     nsPresContext::AppUnitsToIntCSSPixels(pt.y));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::GetLayerX(PRInt32* aLayerX)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aLayerX);
    1:   *aLayerX = GetLayerPoint().x;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::GetLayerY(PRInt32* aLayerY)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aLayerY);
    1:   *aLayerY = GetLayerPoint().y;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsDOMUIEvent::GetIsChar(PRBool* aIsChar)
    1: {
    1:   switch(mEvent->eventStructType)
    1:   {
    1:     case NS_KEY_EVENT:
    1:       *aIsChar = ((nsKeyEvent*)mEvent)->isChar;
    1:       return NS_OK;
    1:     case NS_TEXT_EVENT:
    1:       *aIsChar = ((nsTextEvent*)mEvent)->isChar;
    1:       return NS_OK;
    1:     default:
    1:       *aIsChar = PR_FALSE;
    1:       return NS_OK;
    1:   }
    1: }
    1: 
    1: NS_METHOD
 7852: nsDOMUIEvent::DuplicatePrivateData()
 7852: {
 7852:   mClientPoint = GetClientPoint();
 7852:   mLayerPoint = GetLayerPoint();
 7852:   mPagePoint = GetPagePoint();
 7852:   // GetScreenPoint converts mEvent->refPoint to right coordinates.
23738:   nsIntPoint screenPoint = GetScreenPoint();
 7852:   nsresult rv = nsDOMEvent::DuplicatePrivateData();
 7852:   if (NS_SUCCEEDED(rv)) {
 7852:     mEvent->refPoint = screenPoint;
 7852:   }
 7852:   return rv;
 7852: }
 7852: 
46517: void
46517: nsDOMUIEvent::Serialize(IPC::Message* aMsg, PRBool aSerializeInterfaceType)
46517: {
46517:   if (aSerializeInterfaceType) {
46517:     IPC::WriteParam(aMsg, NS_LITERAL_STRING("uievent"));
46517:   }
46517: 
46517:   nsDOMEvent::Serialize(aMsg, PR_FALSE);
46517: 
46517:   PRInt32 detail = 0;
46517:   GetDetail(&detail);
46517:   IPC::WriteParam(aMsg, detail);
46517: }
46517: 
46517: PRBool
46517: nsDOMUIEvent::Deserialize(const IPC::Message* aMsg, void** aIter)
46517: {
46517:   NS_ENSURE_TRUE(nsDOMEvent::Deserialize(aMsg, aIter), PR_FALSE);
46517:   NS_ENSURE_TRUE(IPC::ReadParam(aMsg, aIter, &mDetail), PR_FALSE);
46517:   return PR_TRUE;
46517: }
46517: 
    1: nsresult NS_NewDOMUIEvent(nsIDOMEvent** aInstancePtrResult,
    1:                           nsPresContext* aPresContext,
    1:                           nsGUIEvent *aEvent) 
    1: {
    1:   nsDOMUIEvent* it = new nsDOMUIEvent(aPresContext, aEvent);
68870:   if (nsnull == it) {
68870:     return NS_ERROR_OUT_OF_MEMORY;
68870:   }
68870: 
    1:   return CallQueryInterface(it, aInstancePtrResult);
    1: }
