53962: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
53962: /* vim: set sw=4 ts=8 et tw=80 : */
95233: /* ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is nsCacheService.cpp, released
43113:  * February 10, 2001.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications Corporation.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Gordon Sheridan, 10-February-2001
43113:  *   Michael Ventnor <m.ventnor@gmail.com>
43113:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
80467: #include "mozilla/Util.h"
80467: 
43113: #include "necko-config.h"
43113: 
43113: #include "nsCache.h"
43113: #include "nsCacheService.h"
43113: #include "nsCacheRequest.h"
43113: #include "nsCacheEntry.h"
43113: #include "nsCacheEntryDescriptor.h"
43113: #include "nsCacheDevice.h"
43113: #include "nsMemoryCacheDevice.h"
43113: #include "nsICacheVisitor.h"
43113: #include "nsDiskCacheDevice.h"
43113: #include "nsDiskCacheDeviceSQL.h"
43113: 
74006: #include "nsIMemoryReporter.h"
43113: #include "nsIObserverService.h"
43113: #include "nsIPrefService.h"
43113: #include "nsIPrefBranch.h"
43113: #include "nsILocalFile.h"
43113: #include "nsIOService.h"
43113: #include "nsDirectoryServiceDefs.h"
43113: #include "nsAppDirectoryServiceDefs.h"
43113: #include "nsThreadUtils.h"
43113: #include "nsProxyRelease.h"
43113: #include "nsVoidArray.h"
43113: #include "nsDeleteDir.h"
43113: #include "nsIPrivateBrowsingService.h"
43113: #include "nsNetCID.h"
43113: #include <math.h>  // for log()
72127: #include "mozilla/Util.h" // for DebugOnly
43113: #include "mozilla/Services.h"
81095: #include "mozilla/Telemetry.h"
86759: #include "nsITimer.h"
43113: 
43113: #include "mozilla/FunctionTimer.h"
43113: 
56416: #include "mozilla/net/NeckoCommon.h"
56416: 
64576: using namespace mozilla;
64576: 
43113: /******************************************************************************
43113:  * nsCacheProfilePrefObserver
43113:  *****************************************************************************/
43113: #define DISK_CACHE_ENABLE_PREF      "browser.cache.disk.enable"
43113: #define DISK_CACHE_DIR_PREF         "browser.cache.disk.parent_directory"
53961: #define DISK_CACHE_SMART_SIZE_FIRST_RUN_PREF\
53961:     "browser.cache.disk.smart_size.first_run"
53961: #define DISK_CACHE_SMART_SIZE_ENABLED_PREF \
53961:     "browser.cache.disk.smart_size.enabled"
53961: #define DISK_CACHE_SMART_SIZE_PREF "browser.cache.disk.smart_size_cached_value"
43113: #define DISK_CACHE_CAPACITY_PREF    "browser.cache.disk.capacity"
43113: #define DISK_CACHE_MAX_ENTRY_SIZE_PREF "browser.cache.disk.max_entry_size"
50382: #define DISK_CACHE_CAPACITY         256000
43113: 
43113: #define OFFLINE_CACHE_ENABLE_PREF   "browser.cache.offline.enable"
43113: #define OFFLINE_CACHE_DIR_PREF      "browser.cache.offline.parent_directory"
43113: #define OFFLINE_CACHE_CAPACITY_PREF "browser.cache.offline.capacity"
43113: #define OFFLINE_CACHE_CAPACITY      512000
43113: 
43113: #define MEMORY_CACHE_ENABLE_PREF    "browser.cache.memory.enable"
43113: #define MEMORY_CACHE_CAPACITY_PREF  "browser.cache.memory.capacity"
43113: #define MEMORY_CACHE_MAX_ENTRY_SIZE_PREF "browser.cache.memory.max_entry_size"
43113: 
84841: #define CACHE_COMPRESSION_LEVEL_PREF "browser.cache.compression_level"
84841: #define CACHE_COMPRESSION_LEVEL     1
84841: 
85029: #define SANITIZE_ON_SHUTDOWN_PREF   "privacy.sanitize.sanitizeOnShutdown"
85029: #define CLEAR_ON_SHUTDOWN_PREF      "privacy.clearOnShutdown.cache"
85029: 
43113: static const char * observerList[] = { 
43113:     "profile-before-change",
54219:     "profile-do-change",
43113:     NS_XPCOM_SHUTDOWN_OBSERVER_ID,
43113:     NS_PRIVATE_BROWSING_SWITCH_TOPIC
43113: };
43113: static const char * prefList[] = { 
43113:     DISK_CACHE_ENABLE_PREF,
53961:     DISK_CACHE_SMART_SIZE_ENABLED_PREF,
43113:     DISK_CACHE_CAPACITY_PREF,
43113:     DISK_CACHE_DIR_PREF,
72584:     DISK_CACHE_MAX_ENTRY_SIZE_PREF,
43113:     OFFLINE_CACHE_ENABLE_PREF,
43113:     OFFLINE_CACHE_CAPACITY_PREF,
43113:     OFFLINE_CACHE_DIR_PREF,
43113:     MEMORY_CACHE_ENABLE_PREF,
72584:     MEMORY_CACHE_CAPACITY_PREF,
84841:     MEMORY_CACHE_MAX_ENTRY_SIZE_PREF,
85029:     CACHE_COMPRESSION_LEVEL_PREF,
85029:     SANITIZE_ON_SHUTDOWN_PREF,
85029:     CLEAR_ON_SHUTDOWN_PREF
43113: };
43113: 
54787: // Cache sizes, in KB
54787: const PRInt32 DEFAULT_CACHE_SIZE = 250 * 1024;  // 250 MB
54787: const PRInt32 MIN_CACHE_SIZE = 50 * 1024;       //  50 MB
54787: const PRInt32 MAX_CACHE_SIZE = 1024 * 1024;     //   1 GB
54786: // Default cache size was 50 MB for many years until FF 4:
54808: const PRInt32 PRE_GECKO_2_0_DEFAULT_CACHE_SIZE = 50 * 1024;
53961: 
43113: class nsCacheProfilePrefObserver : public nsIObserver
43113: {
43113: public:
43113:     NS_DECL_ISUPPORTS
43113:     NS_DECL_NSIOBSERVER
43113: 
43113:     nsCacheProfilePrefObserver()
80486:         : mHaveProfile(false)
80486:         , mDiskCacheEnabled(false)
43113:         , mDiskCacheCapacity(0)
72584:         , mDiskCacheMaxEntrySize(-1) // -1 means "no limit"
86759:         , mSmartSizeEnabled(false)
80486:         , mOfflineCacheEnabled(false)
43113:         , mOfflineCacheCapacity(0)
80486:         , mMemoryCacheEnabled(true)
43113:         , mMemoryCacheCapacity(-1)
72584:         , mMemoryCacheMaxEntrySize(-1) // -1 means "no limit"
80486:         , mInPrivateBrowsing(false)
84841:         , mCacheCompressionLevel(CACHE_COMPRESSION_LEVEL)
85029:         , mSanitizeOnShutdown(false)
85029:         , mClearCacheOnShutdown(false)
43113:     {
43113:     }
43113: 
43113:     virtual ~nsCacheProfilePrefObserver() {}
43113:     
43113:     nsresult        Install();
43113:     void            Remove();
43113:     nsresult        ReadPrefs(nsIPrefBranch* branch);
43113:     
79445:     bool            DiskCacheEnabled();
43113:     PRInt32         DiskCacheCapacity()         { return mDiskCacheCapacity; }
53961:     void            SetDiskCacheCapacity(PRInt32);
72584:     PRInt32         DiskCacheMaxEntrySize()     { return mDiskCacheMaxEntrySize; }
43113:     nsILocalFile *  DiskCacheParentDirectory()  { return mDiskCacheParentDirectory; }
86759:     bool            SmartSizeEnabled()          { return mSmartSizeEnabled; }
43113: 
79445:     bool            OfflineCacheEnabled();
43113:     PRInt32         OfflineCacheCapacity()         { return mOfflineCacheCapacity; }
43113:     nsILocalFile *  OfflineCacheParentDirectory()  { return mOfflineCacheParentDirectory; }
43113:     
79445:     bool            MemoryCacheEnabled();
43113:     PRInt32         MemoryCacheCapacity();
72584:     PRInt32         MemoryCacheMaxEntrySize()     { return mMemoryCacheMaxEntrySize; }
43113: 
84841:     PRInt32         CacheCompressionLevel();
84841: 
85029:     bool            SanitizeAtShutdown() { return mSanitizeOnShutdown && mClearCacheOnShutdown; }
85029: 
80586:     static PRUint32 GetSmartCacheSize(const nsAString& cachePath,
80586:                                       PRUint32 currentSize);
53961: 
43113: private:
79445:     bool                    PermittedToSmartSize(nsIPrefBranch*, bool firstRun);
79445:     bool                    mHaveProfile;
79445:     
79445:     bool                    mDiskCacheEnabled;
43113:     PRInt32                 mDiskCacheCapacity; // in kilobytes
72584:     PRInt32                 mDiskCacheMaxEntrySize; // in kilobytes
43113:     nsCOMPtr<nsILocalFile>  mDiskCacheParentDirectory;
86759:     bool                    mSmartSizeEnabled;
43113: 
79445:     bool                    mOfflineCacheEnabled;
43113:     PRInt32                 mOfflineCacheCapacity; // in kilobytes
43113:     nsCOMPtr<nsILocalFile>  mOfflineCacheParentDirectory;
43113:     
79445:     bool                    mMemoryCacheEnabled;
43113:     PRInt32                 mMemoryCacheCapacity; // in kilobytes
72584:     PRInt32                 mMemoryCacheMaxEntrySize; // in kilobytes
43113: 
79445:     bool                    mInPrivateBrowsing;
84841: 
84841:     PRInt32                 mCacheCompressionLevel;
85029: 
85029:     bool                    mSanitizeOnShutdown;
85029:     bool                    mClearCacheOnShutdown;
43113: };
43113: 
53961: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCacheProfilePrefObserver, nsIObserver)
53961: 
86759: class nsSetDiskSmartSizeCallback : public nsITimerCallback
86759: {
86759: public:
86759:     NS_DECL_ISUPPORTS
86759: 
86759:     NS_IMETHOD Notify(nsITimer* aTimer) {
86759:         if (nsCacheService::gService) {
86759:             nsCacheServiceAutoLock autoLock;
86759:             nsCacheService::gService->SetDiskSmartSize_Locked();
86759:             nsCacheService::gService->mSmartSizeTimer = nsnull;
86759:         }
86759:         return NS_OK;
86759:     }
86759: };
86759: 
86759: NS_IMPL_THREADSAFE_ISUPPORTS1(nsSetDiskSmartSizeCallback, nsITimerCallback)
86759: 
53961: // Runnable sent to main thread after the cache IO thread calculates available
53961: // disk space, so that there is no race in setting mDiskCacheCapacity.
53961: class nsSetSmartSizeEvent: public nsRunnable 
53961: {
53961: public:
80586:     nsSetSmartSizeEvent(PRInt32 smartSize)
80586:         : mSmartSize(smartSize) {}
53961: 
53961:     NS_IMETHOD Run() 
53961:     {
53961:         NS_ASSERTION(NS_IsMainThread(), 
53961:                      "Setting smart size data off the main thread");
53962: 
53962:         // Main thread may have already called nsCacheService::Shutdown
53962:         if (!nsCacheService::gService || !nsCacheService::gService->mObserver)
53962:             return NS_ERROR_NOT_AVAILABLE;
53962: 
86759:         // Ensure smart sizing wasn't switched off while event was pending.
86759:         // It is safe to access the observer without the lock since we are
86759:         // on the main thread and the value changes only on the main thread.
86759:         if (!nsCacheService::gService->mObserver->SmartSizeEnabled())
86759:             return NS_OK;
86759: 
53961:         nsCacheService::SetDiskCacheCapacity(mSmartSize);
86759: 
90037:         nsCOMPtr<nsIPrefBranch> ps = do_GetService(NS_PREFSERVICE_CONTRACTID);
86759:         if (!ps ||
86759:             NS_FAILED(ps->SetIntPref(DISK_CACHE_SMART_SIZE_PREF, mSmartSize)))
53962:             NS_WARNING("Failed to set smart size pref");
86759: 
86759:         return NS_OK;
53961:     }
53961: 
53961: private:
53961:     PRInt32 mSmartSize;
53961: };
53961: 
53961: 
53961: // Runnable sent from main thread to cacheIO thread
53961: class nsGetSmartSizeEvent: public nsRunnable
53961: {
53961: public:
80586:     nsGetSmartSizeEvent(const nsAString& cachePath, PRUint32 currentSize)
80586:       : mCachePath(cachePath)
80586:       , mCurrentSize(currentSize)
54789:     {}
53961:    
53961:     // Calculates user's disk space available on a background thread and
53961:     // dispatches this value back to the main thread.
53961:     NS_IMETHOD Run()
53961:     {
80586:         PRUint32 size;
80586:         size = nsCacheProfilePrefObserver::GetSmartCacheSize(mCachePath,
80586:                                                              mCurrentSize);
80586:         NS_DispatchToMainThread(new nsSetSmartSizeEvent(size));
53961:         return NS_OK;
53961:     }
53961: 
53961: private:
54789:     nsString mCachePath;
80586:     PRUint32 mCurrentSize;
53961: };
43113: 
61001: class nsBlockOnCacheThreadEvent : public nsRunnable {
61001: public:
61001:     nsBlockOnCacheThreadEvent()
61001:     {
61001:     }
61001:     NS_IMETHOD Run()
61001:     {
64576:         nsCacheServiceAutoLock autoLock;
61001: #ifdef PR_LOGGING
61001:         CACHE_LOG_DEBUG(("nsBlockOnCacheThreadEvent [%p]\n", this));
61001: #endif
64576:         nsCacheService::gService->mCondVar.Notify();
61001:         return NS_OK;
61001:     }
61001: };
61001: 
43113: 
43113: nsresult
43113: nsCacheProfilePrefObserver::Install()
43113: {
43113:     // install profile-change observer
43113:     nsCOMPtr<nsIObserverService> observerService =
43113:         mozilla::services::GetObserverService();
43113:     if (!observerService)
43113:         return NS_ERROR_FAILURE;
43113:     
43113:     nsresult rv, rv2 = NS_OK;
80467:     for (unsigned int i=0; i<ArrayLength(observerList); i++) {
80486:         rv = observerService->AddObserver(this, observerList[i], false);
43113:         if (NS_FAILED(rv)) 
43113:             rv2 = rv;
43113:     }
43113:     
43113:     // install preferences observer
90037:     nsCOMPtr<nsIPrefBranch> branch = do_GetService(NS_PREFSERVICE_CONTRACTID);
43113:     if (!branch) return NS_ERROR_FAILURE;
43113: 
80467:     for (unsigned int i=0; i<ArrayLength(prefList); i++) {
80486:         rv = branch->AddObserver(prefList[i], this, false);
43113:         if (NS_FAILED(rv))
43113:             rv2 = rv;
43113:     }
43113: 
43113:     // determine the initial status of the private browsing mode
43113:     nsCOMPtr<nsIPrivateBrowsingService> pbs =
43113:       do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
43113:     if (pbs)
43113:       pbs->GetPrivateBrowsingEnabled(&mInPrivateBrowsing);
43113: 
43113:     // Determine if we have a profile already
43113:     //     Install() is called *after* the profile-after-change notification
43113:     //     when there is only a single profile, or it is specified on the
43113:     //     commandline at startup.
43113:     //     In that case, we detect the presence of a profile by the existence
43113:     //     of the NS_APP_USER_PROFILE_50_DIR directory.
43113: 
43113:     nsCOMPtr<nsIFile> directory;
43113:     rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
43113:                                 getter_AddRefs(directory));
43113:     if (NS_SUCCEEDED(rv))
80486:         mHaveProfile = true;
43113: 
43113:     rv = ReadPrefs(branch);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     return rv2;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheProfilePrefObserver::Remove()
43113: {
43113:     // remove Observer Service observers
43113:     nsCOMPtr<nsIObserverService> obs =
43113:         mozilla::services::GetObserverService();
43113:     if (obs) {
80467:         for (unsigned int i=0; i<ArrayLength(observerList); i++) {
43113:             obs->RemoveObserver(this, observerList[i]);
43113:         }
43113:     }
43113: 
43113:     // remove Pref Service observers
90037:     nsCOMPtr<nsIPrefBranch> prefs =
43113:         do_GetService(NS_PREFSERVICE_CONTRACTID);
43113:     if (!prefs)
43113:         return;
80467:     for (unsigned int i=0; i<ArrayLength(prefList); i++)
43113:         prefs->RemoveObserver(prefList[i], this); // remove cache pref observers
43113: }
43113: 
53961: void
53961: nsCacheProfilePrefObserver::SetDiskCacheCapacity(PRInt32 capacity)
53961: {
71173:     mDiskCacheCapacity = NS_MAX(0, capacity);
53961: }
53961: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheProfilePrefObserver::Observe(nsISupports *     subject,
43113:                                     const char *      topic,
43113:                                     const PRUnichar * data_unicode)
43113: {
43113:     nsresult rv;
43113:     NS_ConvertUTF16toUTF8 data(data_unicode);
43113:     CACHE_LOG_ALWAYS(("Observe [topic=%s data=%s]\n", topic, data.get()));
43113: 
43113:     if (!strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, topic)) {
43113:         // xpcom going away, shutdown cache service
43113:         if (nsCacheService::GlobalInstance())
43113:             nsCacheService::GlobalInstance()->Shutdown();
43113:     
43113:     } else if (!strcmp("profile-before-change", topic)) {
43113:         // profile before change
80486:         mHaveProfile = false;
43113: 
43113:         // XXX shutdown devices
43113:         nsCacheService::OnProfileShutdown(!strcmp("shutdown-cleanse",
43113:                                                   data.get()));
43113:         
54219:     } else if (!strcmp("profile-do-change", topic)) {
43113:         // profile after change
80486:         mHaveProfile = true;
43113:         nsCOMPtr<nsIPrefBranch> branch = do_GetService(NS_PREFSERVICE_CONTRACTID);
43113:         ReadPrefs(branch);
43113:         nsCacheService::OnProfileChanged();
43113:     
43113:     } else if (!strcmp(NS_PREFBRANCH_PREFCHANGE_TOPIC_ID, topic)) {
43113: 
43113:         // ignore pref changes until we're done switch profiles
54787:         if (!mHaveProfile)  
54787:             return NS_OK;
43113: 
43113:         nsCOMPtr<nsIPrefBranch> branch = do_QueryInterface(subject, &rv);
54787:         if (NS_FAILED(rv))  
54787:             return rv;
43113: 
43113:         // which preference changed?
43113:         if (!strcmp(DISK_CACHE_ENABLE_PREF, data.get())) {
43113: 
43113:             if (!mInPrivateBrowsing) {
43113:                 rv = branch->GetBoolPref(DISK_CACHE_ENABLE_PREF,
43113:                                          &mDiskCacheEnabled);
54787:                 if (NS_FAILED(rv))  
54787:                     return rv;
43113:                 nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
43113:             }
43113: 
43113:         } else if (!strcmp(DISK_CACHE_CAPACITY_PREF, data.get())) {
43113: 
43113:             PRInt32 capacity = 0;
43113:             rv = branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &capacity);
54787:             if (NS_FAILED(rv))  
54787:                 return rv;
71173:             mDiskCacheCapacity = NS_MAX(0, capacity);
43113:             nsCacheService::SetDiskCacheCapacity(mDiskCacheCapacity);
53961:        
53961:         // Update the cache capacity when smart sizing is turned on/off 
53961:         } else if (!strcmp(DISK_CACHE_SMART_SIZE_ENABLED_PREF, data.get())) {
53961:             // Is the update because smartsizing was turned on, or off?
53961:             rv = branch->GetBoolPref(DISK_CACHE_SMART_SIZE_ENABLED_PREF,
86759:                                      &mSmartSizeEnabled);
54787:             if (NS_FAILED(rv)) 
54787:                 return rv;
53961:             PRInt32 newCapacity = 0;
86759:             if (mSmartSizeEnabled) {
86122:                 nsCacheService::SetDiskSmartSize();
53961:             } else {
53961:                 // Smart sizing switched off: use user specified size
53961:                 rv = branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &newCapacity);
54787:                 if (NS_FAILED(rv)) 
54787:                     return rv;
71173:                 mDiskCacheCapacity = NS_MAX(0, newCapacity);
53961:                 nsCacheService::SetDiskCacheCapacity(mDiskCacheCapacity);
53961:             }
72584:         } else if (!strcmp(DISK_CACHE_MAX_ENTRY_SIZE_PREF, data.get())) {
72584:             PRInt32 newMaxSize;
72584:             rv = branch->GetIntPref(DISK_CACHE_MAX_ENTRY_SIZE_PREF,
72584:                                     &newMaxSize);
72584:             if (NS_FAILED(rv)) 
72584:                 return rv;
72584: 
72584:             mDiskCacheMaxEntrySize = NS_MAX(-1, newMaxSize);
72584:             nsCacheService::SetDiskCacheMaxEntrySize(mDiskCacheMaxEntrySize);
72584:           
43113: #if 0            
43113:         } else if (!strcmp(DISK_CACHE_DIR_PREF, data.get())) {
43113:             // XXX We probaby don't want to respond to this pref except after
43113:             // XXX profile changes.  Ideally, there should be somekind of user
43113:             // XXX notification that the pref change won't take effect until
43113:             // XXX the next time the profile changes (browser launch)
43113: #endif            
43113:         } else
43113: 
43113:         // which preference changed?
43113:         if (!strcmp(OFFLINE_CACHE_ENABLE_PREF, data.get())) {
43113: 
43113:             if (!mInPrivateBrowsing) {
43113:                 rv = branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
43113:                                          &mOfflineCacheEnabled);
43113:                 if (NS_FAILED(rv))  return rv;
43113:                 nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
43113:             }
43113: 
43113:         } else if (!strcmp(OFFLINE_CACHE_CAPACITY_PREF, data.get())) {
43113: 
43113:             PRInt32 capacity = 0;
43113:             rv = branch->GetIntPref(OFFLINE_CACHE_CAPACITY_PREF, &capacity);
43113:             if (NS_FAILED(rv))  return rv;
71173:             mOfflineCacheCapacity = NS_MAX(0, capacity);
43113:             nsCacheService::SetOfflineCacheCapacity(mOfflineCacheCapacity);
43113: #if 0
43113:         } else if (!strcmp(OFFLINE_CACHE_DIR_PREF, data.get())) {
43113:             // XXX We probaby don't want to respond to this pref except after
43113:             // XXX profile changes.  Ideally, there should be some kind of user
43113:             // XXX notification that the pref change won't take effect until
43113:             // XXX the next time the profile changes (browser launch)
43113: #endif
43113:         } else
43113: 
43113:         if (!strcmp(MEMORY_CACHE_ENABLE_PREF, data.get())) {
43113: 
43113:             rv = branch->GetBoolPref(MEMORY_CACHE_ENABLE_PREF,
43113:                                      &mMemoryCacheEnabled);
54787:             if (NS_FAILED(rv))  
54787:                 return rv;
43113:             nsCacheService::SetMemoryCache();
43113:             
43113:         } else if (!strcmp(MEMORY_CACHE_CAPACITY_PREF, data.get())) {
43113: 
43113:             mMemoryCacheCapacity = -1;
43113:             (void) branch->GetIntPref(MEMORY_CACHE_CAPACITY_PREF,
43113:                                       &mMemoryCacheCapacity);
43113:             nsCacheService::SetMemoryCache();
72584:         } else if (!strcmp(MEMORY_CACHE_MAX_ENTRY_SIZE_PREF, data.get())) {
72584:             PRInt32 newMaxSize;
72584:             rv = branch->GetIntPref(MEMORY_CACHE_MAX_ENTRY_SIZE_PREF,
72584:                                      &newMaxSize);
72584:             if (NS_FAILED(rv)) 
72584:                 return rv;
72584:             
72584:             mMemoryCacheMaxEntrySize = NS_MAX(-1, newMaxSize);
72584:             nsCacheService::SetMemoryCacheMaxEntrySize(mMemoryCacheMaxEntrySize);
84841:         } else if (!strcmp(CACHE_COMPRESSION_LEVEL_PREF, data.get())) {
84841:             mCacheCompressionLevel = CACHE_COMPRESSION_LEVEL;
84841:             (void)branch->GetIntPref(CACHE_COMPRESSION_LEVEL_PREF,
84841:                                      &mCacheCompressionLevel);
84841:             mCacheCompressionLevel = NS_MAX(0, mCacheCompressionLevel);
84841:             mCacheCompressionLevel = NS_MIN(9, mCacheCompressionLevel);
85029:         } else if (!strcmp(SANITIZE_ON_SHUTDOWN_PREF, data.get())) {
85029:             rv = branch->GetBoolPref(SANITIZE_ON_SHUTDOWN_PREF,
85029:                                      &mSanitizeOnShutdown);
85029:             if (NS_FAILED(rv))
85029:                 return rv;
85029:             nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
85029:         } else if (!strcmp(CLEAR_ON_SHUTDOWN_PREF, data.get())) {
85029:             rv = branch->GetBoolPref(CLEAR_ON_SHUTDOWN_PREF,
85029:                                      &mClearCacheOnShutdown);
85029:             if (NS_FAILED(rv))
85029:                 return rv;
85029:             nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
43113:         }
43113:     } else if (!strcmp(NS_PRIVATE_BROWSING_SWITCH_TOPIC, topic)) {
43113:         if (!strcmp(NS_PRIVATE_BROWSING_ENTER, data.get())) {
80486:             mInPrivateBrowsing = true;
43113: 
43113:             nsCacheService::OnEnterExitPrivateBrowsing();
43113: 
80486:             mDiskCacheEnabled = false;
43113:             nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
43113: 
80486:             mOfflineCacheEnabled = false;
43113:             nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
43113:         } else if (!strcmp(NS_PRIVATE_BROWSING_LEAVE, data.get())) {
80486:             mInPrivateBrowsing = false;
43113: 
43113:             nsCacheService::OnEnterExitPrivateBrowsing();
43113: 
43113:             nsCOMPtr<nsIPrefBranch> branch = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
54787:             if (NS_FAILED(rv))  
54787:                 return rv;
76794: 
80486:             mDiskCacheEnabled = true; // by default enabled
43113:             (void) branch->GetBoolPref(DISK_CACHE_ENABLE_PREF,
43113:                                        &mDiskCacheEnabled);
43113:             nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
43113: 
80486:             mOfflineCacheEnabled = true; // by default enabled
43113:             (void) branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
43113:                                        &mOfflineCacheEnabled);
43113:             nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
43113:         }
43113:     }
43113:     
43113:     return NS_OK;
43113: }
43113: 
80586: // Returns default ("smart") size (in KB) of cache, given available disk space
80586: // (also in KB)
80586: static PRUint32
80586: SmartCacheSize(const PRUint32 availKB)
80586: {
80586:     if (availKB > 100 * 1024 * 1024)
80586:         return MAX_CACHE_SIZE;  // skip computing if we're over 100 GB
80586: 
80586:     // Grow/shrink in 10 MB units, deliberately, so that in the common case we
80586:     // don't shrink cache and evict items every time we startup (it's important
80586:     // that we don't slow down startup benchmarks).
80586:     PRUint32 sz10MBs = 0;
80586:     PRUint32 avail10MBs = availKB / (1024*10);
80586: 
80586:     // .5% of space above 25 GB
80586:     if (avail10MBs > 2500) {
80586:         sz10MBs += (avail10MBs - 2500)*.005;
80586:         avail10MBs = 2500;
80586:     }
80586:     // 1% of space between 7GB -> 25 GB
80586:     if (avail10MBs > 700) {
80586:         sz10MBs += (avail10MBs - 700)*.01;
80586:         avail10MBs = 700;
80586:     }
80586:     // 5% of space between 500 MB -> 7 GB
80586:     if (avail10MBs > 50) {
80586:         sz10MBs += (avail10MBs - 50)*.05;
80586:         avail10MBs = 50;
80586:     }
80586: 
80586:     // 40% of space up to 500 MB (50 MB min)
80586:     sz10MBs += NS_MAX<PRUint32>(5, avail10MBs * .4);
80586: 
80586:     return NS_MIN<PRUint32>(MAX_CACHE_SIZE, sz10MBs * 10 * 1024);
80586: }
80586: 
53961:  /* Computes our best guess for the default size of the user's disk cache, 
53961:   * based on the amount of space they have free on their hard drive. 
53961:   * We use a tiered scheme: the more space available, 
53961:   * the larger the disk cache will be. However, we do not want
53961:   * to enable the disk cache to grow to an unbounded size, so the larger the
53961:   * user's available space is, the smaller of a percentage we take. We set a
53961:   * lower bound of 50MB and an upper bound of 1GB.  
53961:   *
53961:   *@param:  None.
54787:   *@return: The size that the user's disk cache should default to, in kBytes.
53961:   */
53961: PRUint32
80586: nsCacheProfilePrefObserver::GetSmartCacheSize(const nsAString& cachePath,
80586:                                               PRUint32 currentSize)
54789: {
54789:     // Check for free space on device where cache directory lives
53961:     nsresult rv;
54789:     nsCOMPtr<nsILocalFile> 
54789:         cacheDirectory (do_CreateInstance(NS_LOCAL_FILE_CONTRACTID, &rv));
54789:     if (NS_FAILED(rv) || !cacheDirectory)
54787:         return DEFAULT_CACHE_SIZE;
54789:     rv = cacheDirectory->InitWithPath(cachePath);
54789:     if (NS_FAILED(rv))
54789:         return DEFAULT_CACHE_SIZE;
53961:     PRInt64 bytesAvailable;
54789:     rv = cacheDirectory->GetDiskSpaceAvailable(&bytesAvailable);
54787:     if (NS_FAILED(rv))
54787:         return DEFAULT_CACHE_SIZE;
80586: 
80586:     return SmartCacheSize((bytesAvailable / 1024) + currentSize);
53961: }
53961: 
53961: /* Determine if we are permitted to dynamically size the user's disk cache based
53961:  * on their disk space available. We may do this so long as the pref 
53961:  * smart_size.enabled is true.
53961:  */
53961: bool
79445: nsCacheProfilePrefObserver::PermittedToSmartSize(nsIPrefBranch* branch, bool
53961:                                                  firstRun)
53961: {
53961:     nsresult rv;
53961:     if (firstRun) {
53961:         // check if user has set cache size in the past
79445:         bool userSet;
53961:         rv = branch->PrefHasUserValue(DISK_CACHE_CAPACITY_PREF, &userSet);
80486:         if (NS_FAILED(rv)) userSet = true;
53961:         if (userSet) {
53961:             PRInt32 oldCapacity;
54787:             // If user explicitly set cache size to be smaller than old default
54787:             // of 50 MB, then keep user's value. Otherwise use smart sizing.
53961:             rv = branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &oldCapacity);
54808:             if (oldCapacity < PRE_GECKO_2_0_DEFAULT_CACHE_SIZE) {
86759:                 mSmartSizeEnabled = false;
53961:                 branch->SetBoolPref(DISK_CACHE_SMART_SIZE_ENABLED_PREF,
86759:                                     mSmartSizeEnabled);
86759:                 return mSmartSizeEnabled;
53961:             }
53961:         }
54788:         // Set manual setting to MAX cache size as starting val for any
54788:         // adjustment by user: (bug 559942 comment 65)
54788:         branch->SetIntPref(DISK_CACHE_CAPACITY_PREF, MAX_CACHE_SIZE);
53961:     }
86759: 
53961:     rv = branch->GetBoolPref(DISK_CACHE_SMART_SIZE_ENABLED_PREF,
86759:                              &mSmartSizeEnabled);
54787:     if (NS_FAILED(rv))
86759:         mSmartSizeEnabled = false;
86759:     return mSmartSizeEnabled;
53961: }
53961: 
53961: 
43113: nsresult
43113: nsCacheProfilePrefObserver::ReadPrefs(nsIPrefBranch* branch)
43113: {
43113:     nsresult rv = NS_OK;
43113: 
43113:     // read disk cache device prefs
43113:     if (!mInPrivateBrowsing) {
80486:         mDiskCacheEnabled = true;  // presume disk cache is enabled
43113:         (void) branch->GetBoolPref(DISK_CACHE_ENABLE_PREF, &mDiskCacheEnabled);
43113:     }
43113: 
43113:     mDiskCacheCapacity = DISK_CACHE_CAPACITY;
43113:     (void)branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &mDiskCacheCapacity);
71173:     mDiskCacheCapacity = NS_MAX(0, mDiskCacheCapacity);
43113: 
72584:     (void) branch->GetIntPref(DISK_CACHE_MAX_ENTRY_SIZE_PREF,
72584:                               &mDiskCacheMaxEntrySize);
72584:     mDiskCacheMaxEntrySize = NS_MAX(-1, mDiskCacheMaxEntrySize);
72584:     
43113:     (void) branch->GetComplexValue(DISK_CACHE_DIR_PREF,     // ignore error
43113:                                    NS_GET_IID(nsILocalFile),
43113:                                    getter_AddRefs(mDiskCacheParentDirectory));
43113:     
43113:     if (!mDiskCacheParentDirectory) {
43113:         nsCOMPtr<nsIFile>  directory;
43113: 
43113:         // try to get the disk cache parent directory
43113:         rv = NS_GetSpecialDirectory(NS_APP_CACHE_PARENT_DIR,
43113:                                     getter_AddRefs(directory));
43113:         if (NS_FAILED(rv)) {
43113:             // try to get the profile directory (there may not be a profile yet)
43113:             nsCOMPtr<nsIFile> profDir;
43113:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
43113:                                    getter_AddRefs(profDir));
43113:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_LOCAL_50_DIR,
43113:                                    getter_AddRefs(directory));
43113:             if (!directory)
43113:                 directory = profDir;
43113:             else if (profDir) {
79445:                 bool same;
43113:                 if (NS_SUCCEEDED(profDir->Equals(directory, &same)) && !same) {
43113:                     // We no longer store the cache directory in the main
43113:                     // profile directory, so we should cleanup the old one.
43113:                     rv = profDir->AppendNative(NS_LITERAL_CSTRING("Cache"));
43113:                     if (NS_SUCCEEDED(rv)) {
79445:                         bool exists;
43113:                         if (NS_SUCCEEDED(profDir->Exists(&exists)) && exists)
83182:                             nsDeleteDir::DeleteDir(profDir, false);
43113:                     }
43113:                 }
43113:             }
43113:         }
43113:         // use file cache in build tree only if asked, to avoid cache dir litter
43113:         if (!directory && PR_GetEnv("NECKO_DEV_ENABLE_DISK_CACHE")) {
43113:             rv = NS_GetSpecialDirectory(NS_XPCOM_CURRENT_PROCESS_DIR,
43113:                                         getter_AddRefs(directory));
43113:         }
43113:         if (directory)
43113:             mDiskCacheParentDirectory = do_QueryInterface(directory, &rv);
43113:     }
53961:     if (mDiskCacheParentDirectory) {
79445:         bool firstSmartSizeRun;
53961:         rv = branch->GetBoolPref(DISK_CACHE_SMART_SIZE_FIRST_RUN_PREF, 
53961:                                  &firstSmartSizeRun); 
54787:         if (NS_FAILED(rv)) 
80486:             firstSmartSizeRun = false;
53961:         if (PermittedToSmartSize(branch, firstSmartSizeRun)) {
54789:             // Avoid evictions: use previous cache size until smart size event
54789:             // updates mDiskCacheCapacity
86759:             rv = branch->GetIntPref(firstSmartSizeRun ?
86759:                                     DISK_CACHE_CAPACITY_PREF :
86759:                                     DISK_CACHE_SMART_SIZE_PREF,
86759:                                     &mDiskCacheCapacity);
86759:             if (NS_FAILED(rv))
54788:                 mDiskCacheCapacity = DEFAULT_CACHE_SIZE;
54788:         }
53961: 
53961:         if (firstSmartSizeRun) {
53961:             // It is no longer our first run
53961:             rv = branch->SetBoolPref(DISK_CACHE_SMART_SIZE_FIRST_RUN_PREF, 
80486:                                      false);
53961:             if (NS_FAILED(rv)) 
53961:                 NS_WARNING("Failed setting first_run pref in ReadPrefs.");
53961:         }
53961:     }
43113: 
43113:     // read offline cache device prefs
43113:     if (!mInPrivateBrowsing) {
80486:         mOfflineCacheEnabled = true;  // presume offline cache is enabled
43113:         (void) branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
43113:                                    &mOfflineCacheEnabled);
43113:     }
43113: 
43113:     mOfflineCacheCapacity = OFFLINE_CACHE_CAPACITY;
43113:     (void)branch->GetIntPref(OFFLINE_CACHE_CAPACITY_PREF,
43113:                              &mOfflineCacheCapacity);
71173:     mOfflineCacheCapacity = NS_MAX(0, mOfflineCacheCapacity);
43113: 
43113:     (void) branch->GetComplexValue(OFFLINE_CACHE_DIR_PREF,     // ignore error
43113:                                    NS_GET_IID(nsILocalFile),
43113:                                    getter_AddRefs(mOfflineCacheParentDirectory));
43113: 
43113:     if (!mOfflineCacheParentDirectory) {
43113:         nsCOMPtr<nsIFile>  directory;
43113: 
43113:         // try to get the offline cache parent directory
43113:         rv = NS_GetSpecialDirectory(NS_APP_CACHE_PARENT_DIR,
43113:                                     getter_AddRefs(directory));
43113:         if (NS_FAILED(rv)) {
43113:             // try to get the profile directory (there may not be a profile yet)
43113:             nsCOMPtr<nsIFile> profDir;
43113:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
43113:                                    getter_AddRefs(profDir));
43113:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_LOCAL_50_DIR,
43113:                                    getter_AddRefs(directory));
43113:             if (!directory)
43113:                 directory = profDir;
43113:         }
43113: #if DEBUG
43113:         if (!directory) {
43113:             // use current process directory during development
43113:             rv = NS_GetSpecialDirectory(NS_XPCOM_CURRENT_PROCESS_DIR,
43113:                                         getter_AddRefs(directory));
43113:         }
43113: #endif
43113:         if (directory)
43113:             mOfflineCacheParentDirectory = do_QueryInterface(directory, &rv);
43113:     }
43113: 
43113:     // read memory cache device prefs
43113:     (void) branch->GetBoolPref(MEMORY_CACHE_ENABLE_PREF, &mMemoryCacheEnabled);
43113: 
43113:     mMemoryCacheCapacity = -1;
43113:     (void) branch->GetIntPref(MEMORY_CACHE_CAPACITY_PREF,
43113:                               &mMemoryCacheCapacity);
43113: 
72584:     (void) branch->GetIntPref(MEMORY_CACHE_MAX_ENTRY_SIZE_PREF,
72584:                               &mMemoryCacheMaxEntrySize);
72584:     mMemoryCacheMaxEntrySize = NS_MAX(-1, mMemoryCacheMaxEntrySize);
84841: 
84841:     // read cache compression level pref
84841:     mCacheCompressionLevel = CACHE_COMPRESSION_LEVEL;
84841:     (void)branch->GetIntPref(CACHE_COMPRESSION_LEVEL_PREF,
84841:                              &mCacheCompressionLevel);
84841:     mCacheCompressionLevel = NS_MAX(0, mCacheCompressionLevel);
84841:     mCacheCompressionLevel = NS_MIN(9, mCacheCompressionLevel);
84841: 
85029:     // read cache shutdown sanitization prefs
85029:     (void) branch->GetBoolPref(SANITIZE_ON_SHUTDOWN_PREF,
85029:                                &mSanitizeOnShutdown);
85029:     (void) branch->GetBoolPref(CLEAR_ON_SHUTDOWN_PREF,
85029:                                &mClearCacheOnShutdown);
85029: 
43113:     return rv;
43113: }
43113: 
53961: nsresult
53961: nsCacheService::DispatchToCacheIOThread(nsIRunnable* event)
53961: {
53961:     if (!gService->mCacheIOThread) return NS_ERROR_NOT_AVAILABLE;
53961:     return gService->mCacheIOThread->Dispatch(event, NS_DISPATCH_NORMAL);
53961: }
53961: 
61001: nsresult
61001: nsCacheService::SyncWithCacheIOThread()
61001: {
64576:     gService->mLock.AssertCurrentThreadOwns();
61001:     if (!gService->mCacheIOThread) return NS_ERROR_NOT_AVAILABLE;
61001: 
61001:     nsCOMPtr<nsIRunnable> event = new nsBlockOnCacheThreadEvent();
61001: 
61001:     // dispatch event - it will notify the monitor when it's done
61001:     nsresult rv =
61001:         gService->mCacheIOThread->Dispatch(event, NS_DISPATCH_NORMAL);
61001:     if (NS_FAILED(rv)) {
61001:         NS_WARNING("Failed dispatching block-event");
61001:         return NS_ERROR_UNEXPECTED;
61001:     }
61001: 
61001:     // wait until notified, then return
64576:     rv = gService->mCondVar.Wait();
61001: 
61001:     return rv;
61001: }
61001: 
43113: 
79445: bool
43113: nsCacheProfilePrefObserver::DiskCacheEnabled()
43113: {
80486:     if ((mDiskCacheCapacity == 0) || (!mDiskCacheParentDirectory))  return false;
85029:     return mDiskCacheEnabled && (!mSanitizeOnShutdown || !mClearCacheOnShutdown);
43113: }
43113: 
43113: 
79445: bool
43113: nsCacheProfilePrefObserver::OfflineCacheEnabled()
43113: {
43113:     if ((mOfflineCacheCapacity == 0) || (!mOfflineCacheParentDirectory))
80486:         return false;
43113: 
43113:     return mOfflineCacheEnabled;
43113: }
43113: 
43113: 
79445: bool
43113: nsCacheProfilePrefObserver::MemoryCacheEnabled()
43113: {
80486:     if (mMemoryCacheCapacity == 0)  return false;
43113:     return mMemoryCacheEnabled;
43113: }
43113: 
43113: 
43113: /**
43113:  * MemoryCacheCapacity
43113:  *
43113:  * If the browser.cache.memory.capacity preference is positive, we use that
43113:  * value for the amount of memory available for the cache.
43113:  *
43113:  * If browser.cache.memory.capacity is zero, the memory cache is disabled.
43113:  * 
43113:  * If browser.cache.memory.capacity is negative or not present, we use a
43113:  * formula that grows less than linearly with the amount of system memory, 
43113:  * with an upper limit on the cache size. No matter how much physical RAM is
43113:  * present, the default cache size would not exceed 32 MB. This maximum would
43113:  * apply only to systems with more than 4 GB of RAM (e.g. terminal servers)
43113:  *
43113:  *   RAM   Cache
43113:  *   ---   -----
43113:  *   32 Mb   2 Mb
43113:  *   64 Mb   4 Mb
43113:  *  128 Mb   6 Mb
43113:  *  256 Mb  10 Mb
43113:  *  512 Mb  14 Mb
43113:  * 1024 Mb  18 Mb
43113:  * 2048 Mb  24 Mb
43113:  * 4096 Mb  30 Mb
43113:  *
43113:  * The equation for this is (for cache size C and memory size K (kbytes)):
43113:  *  x = log2(K) - 14
43113:  *  C = x^2/3 + x + 2/3 + 0.1 (0.1 for rounding)
43113:  *  if (C > 32) C = 32
43113:  */
43113: 
43113: PRInt32
43113: nsCacheProfilePrefObserver::MemoryCacheCapacity()
43113: {
43113:     PRInt32 capacity = mMemoryCacheCapacity;
43113:     if (capacity >= 0) {
43113:         CACHE_LOG_DEBUG(("Memory cache capacity forced to %d\n", capacity));
43113:         return capacity;
43113:     }
43113: 
43113:     static PRUint64 bytes = PR_GetPhysicalMemorySize();
43113:     CACHE_LOG_DEBUG(("Physical Memory size is %llu\n", bytes));
43113: 
43113:     // If getting the physical memory failed, arbitrarily assume
43113:     // 32 MB of RAM. We use a low default to have a reasonable
43113:     // size on all the devices we support.
43113:     if (bytes == 0)
43113:         bytes = 32 * 1024 * 1024;
43113: 
43113:     // Conversion from unsigned int64 to double doesn't work on all platforms.
43113:     // We need to truncate the value at LL_MAXINT to make sure we don't
43113:     // overflow.
43113:     if (LL_CMP(bytes, >, LL_MAXINT))
43113:         bytes = LL_MAXINT;
43113: 
43113:     PRUint64 kbytes;
43113:     LL_SHR(kbytes, bytes, 10);
43113: 
43113:     double kBytesD;
43113:     LL_L2D(kBytesD, (PRInt64) kbytes);
43113: 
43113:     double x = log(kBytesD)/log(2.0) - 14;
43113:     if (x > 0) {
43113:         capacity = (PRInt32)(x * x / 3.0 + x + 2.0 / 3 + 0.1); // 0.1 for rounding
43113:         if (capacity > 32)
43113:             capacity = 32;
43113:         capacity   *= 1024;
43113:     } else {
43113:         capacity    = 0;
43113:     }
43113: 
43113:     return capacity;
43113: }
43113: 
84841: PRInt32
84841: nsCacheProfilePrefObserver::CacheCompressionLevel()
84841: {
84841:     return mCacheCompressionLevel;
84841: }
51302: 
51302: /******************************************************************************
51302:  * nsProcessRequestEvent
51302:  *****************************************************************************/
51302: 
51302: class nsProcessRequestEvent : public nsRunnable {
51302: public:
51302:     nsProcessRequestEvent(nsCacheRequest *aRequest)
51302:     {
51302:         mRequest = aRequest;
51302:     }
51302: 
51302:     NS_IMETHOD Run()
51302:     {
51302:         nsresult rv;
51302: 
51302:         NS_ASSERTION(mRequest->mListener,
51302:                      "Sync OpenCacheEntry() posted to background thread!");
51302: 
51302:         nsCacheServiceAutoLock lock;
51302:         rv = nsCacheService::gService->ProcessRequest(mRequest,
80486:                                                       false,
51302:                                                       nsnull);
51302: 
51302:         // Don't delete the request if it was queued
93829:         if (!(mRequest->IsBlocking() &&
93829:             rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION))
51302:             delete mRequest;
51302: 
51302:         return NS_OK;
51302:     }
51302: 
51302: protected:
51302:     virtual ~nsProcessRequestEvent() {}
51302: 
51302: private:
51302:     nsCacheRequest *mRequest;
51302: };
51302: 
43113: /******************************************************************************
93831:  * nsNotifyDoomListener
93831:  *****************************************************************************/
93831: 
93831: class nsNotifyDoomListener : public nsRunnable {
93831: public:
93831:     nsNotifyDoomListener(nsICacheListener *listener,
93831:                          nsresult status)
93831:         : mListener(listener)      // transfers reference
93831:         , mStatus(status)
93831:     {}
93831: 
93831:     NS_IMETHOD Run()
93831:     {
93831:         mListener->OnCacheEntryDoomed(mStatus);
93831:         NS_RELEASE(mListener);
93831:         return NS_OK;
93831:     }
93831: 
93831: private:
93831:     nsICacheListener *mListener;
93831:     nsresult          mStatus;
93831: };
93831: 
93831: /******************************************************************************
93831:  * nsDoomEvent
93831:  *****************************************************************************/
93831: 
93831: class nsDoomEvent : public nsRunnable {
93831: public:
93831:     nsDoomEvent(nsCacheSession *session,
93831:                 const nsACString &key,
93831:                 nsICacheListener *listener)
93831:     {
93831:         mKey = *session->ClientID();
93831:         mKey.Append(':');
93831:         mKey.Append(key);
93831:         mStoragePolicy = session->StoragePolicy();
93831:         mListener = listener;
93831:         mThread = do_GetCurrentThread();
93831:         // We addref the listener here and release it in nsNotifyDoomListener
93831:         // on the callers thread. If posting of nsNotifyDoomListener event fails
93831:         // we leak the listener which is better than releasing it on a wrong
93831:         // thread.
93831:         NS_IF_ADDREF(mListener);
93831:     }
93831: 
93831:     NS_IMETHOD Run()
93831:     {
93831:         nsCacheServiceAutoLock lock;
93831: 
93831:         bool foundActive = true;
93831:         nsresult status = NS_ERROR_NOT_AVAILABLE;
93831:         nsCacheEntry *entry;
93831:         entry = nsCacheService::gService->mActiveEntries.GetEntry(&mKey);
93831:         if (!entry) {
93831:             bool collision = false;
93831:             foundActive = false;
93831:             entry = nsCacheService::gService->SearchCacheDevices(&mKey,
93831:                                                                  mStoragePolicy,
93831:                                                                  &collision);
93831:         }
93831: 
93831:         if (entry) {
93831:             status = NS_OK;
93831:             nsCacheService::gService->DoomEntry_Internal(entry, foundActive);
93831:         }
93831: 
93831:         if (mListener) {
93831:             mThread->Dispatch(new nsNotifyDoomListener(mListener, status),
93831:                               NS_DISPATCH_NORMAL);
93831:             // posted event will release the reference on the correct thread
93831:             mListener = nsnull;
93831:         }
93831: 
93831:         return NS_OK;
93831:     }
93831: 
93831: private:
93831:     nsCString             mKey;
93831:     nsCacheStoragePolicy  mStoragePolicy;
93831:     nsICacheListener     *mListener;
93831:     nsCOMPtr<nsIThread>   mThread;
93831: };
93831: 
93831: /******************************************************************************
43113:  * nsCacheService
43113:  *****************************************************************************/
43113: nsCacheService *   nsCacheService::gService = nsnull;
43113: 
74006: static nsCOMPtr<nsIMemoryReporter> MemoryCacheReporter = nsnull;
74006: 
74006: NS_THREADSAFE_MEMORY_REPORTER_IMPLEMENT(NetworkMemoryCache,
74006:     "explicit/network-memory-cache",
74006:     KIND_HEAP,
74006:     UNITS_BYTES,
74006:     nsCacheService::MemoryDeviceSize,
74006:     "Memory used by the network memory cache.")
74006: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCacheService, nsICacheService)
43113: 
43113: nsCacheService::nsCacheService()
64576:     : mLock("nsCacheService.mLock"),
64576:       mCondVar(mLock, "nsCacheService.mCondVar"),
80486:       mInitialized(false),
95284:       mClearingEntries(false),
80486:       mEnableMemoryDevice(true),
80486:       mEnableDiskDevice(true),
43113:       mMemoryDevice(nsnull),
43113:       mDiskDevice(nsnull),
43113:       mOfflineDevice(nsnull),
43113:       mTotalEntries(0),
43113:       mCacheHits(0),
43113:       mCacheMisses(0),
43113:       mMaxKeyLength(0),
43113:       mMaxDataSize(0),
43113:       mMaxMetaSize(0),
43113:       mDeactivateFailures(0),
43113:       mDeactivatedUnboundEntries(0)
43113: {
43113:     NS_ASSERTION(gService==nsnull, "multiple nsCacheService instances!");
43113:     gService = this;
43113: 
43113:     // create list of cache devices
43113:     PR_INIT_CLIST(&mDoomedEntries);
43113: }
43113: 
43113: nsCacheService::~nsCacheService()
43113: {
43113:     if (mInitialized) // Shutdown hasn't been called yet.
43113:         (void) Shutdown();
43113: 
43113:     gService = nsnull;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::Init()
43113: {
43113:     NS_TIME_FUNCTION;
43113: 
43113:     NS_ASSERTION(!mInitialized, "nsCacheService already initialized.");
43113:     if (mInitialized)
43113:         return NS_ERROR_ALREADY_INITIALIZED;
43113: 
56370:     if (mozilla::net::IsNeckoChild()) {
56370:         return NS_ERROR_UNEXPECTED;
56370:     }
56370: 
43113:     CACHE_LOG_INIT();
43113: 
51302:     nsresult rv = NS_NewThread(getter_AddRefs(mCacheIOThread));
51302:     if (NS_FAILED(rv)) {
94149:         NS_RUNTIMEABORT("Can't create cache IO thread");
51302:     }
51302: 
83182:     rv = nsDeleteDir::Init();
83182:     if (NS_FAILED(rv)) {
83182:         NS_WARNING("Can't initialize nsDeleteDir");
83182:     }
83182: 
43113:     // initialize hashtable for active cache entries
51302:     rv = mActiveEntries.Init();
43113:     if (NS_FAILED(rv)) return rv;
43113:     
43113:     // create profile/preference observer
43113:     mObserver = new nsCacheProfilePrefObserver();
43113:     if (!mObserver)  return NS_ERROR_OUT_OF_MEMORY;
43113:     NS_ADDREF(mObserver);
43113:     
43113:     mObserver->Install();
43113:     mEnableDiskDevice    = mObserver->DiskCacheEnabled();
43113:     mEnableOfflineDevice = mObserver->OfflineCacheEnabled();
43113:     mEnableMemoryDevice  = mObserver->MemoryCacheEnabled();
43113: 
80486:     mInitialized = true;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::Shutdown()
43113: {
51302:     nsCOMPtr<nsIThread> cacheIOThread;
83182:     Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_SHUTDOWN> totalTimer;
51302: 
85029:     bool shouldSanitize = false;
85029:     nsCOMPtr<nsILocalFile> parentDir;
85029: 
51302:     {
43113:     nsCacheServiceAutoLock lock;
43113:     NS_ASSERTION(mInitialized, 
43113:                  "can't shutdown nsCacheService unless it has been initialized.");
43113: 
43113:     if (mInitialized) {
43113: 
80486:         mInitialized = false;
43113: 
43113:         // Clear entries
43113:         ClearDoomList();
43113:         ClearActiveEntries();
43113: 
86759:         if (mSmartSizeTimer) {
86759:             mSmartSizeTimer->Cancel();
86759:             mSmartSizeTimer = nsnull;
86759:         }
86759: 
61001:         // Make sure to wait for any pending cache-operations before
61001:         // proceeding with destructive actions (bug #620660)
61001:         (void) SyncWithCacheIOThread();
61001: 
85029:         // obtain the disk cache directory in case we need to sanitize it
85029:         parentDir = mObserver->DiskCacheParentDirectory();
85029:         shouldSanitize = mObserver->SanitizeAtShutdown();
84843:         mObserver->Remove();
84843:         NS_RELEASE(mObserver);
84843:         
74006:         // unregister memory reporter, before deleting the memory device, just
74006:         // to be safe
74006:         NS_UnregisterMemoryReporter(MemoryCacheReporter);
74006:         MemoryCacheReporter = nsnull;
74006: 
43113:         // deallocate memory and disk caches
43113:         delete mMemoryDevice;
43113:         mMemoryDevice = nsnull;
43113: 
43113:         delete mDiskDevice;
43113:         mDiskDevice = nsnull;
43113: 
87133:         if (mOfflineDevice)
87133:             mOfflineDevice->Shutdown();
87133: 
43113:         NS_IF_RELEASE(mOfflineDevice);
43113: 
76794: #ifdef PR_LOGGING
43113:         LogCacheStatistics();
43113: #endif
51302: 
51302:         mCacheIOThread.swap(cacheIOThread);
43113:     }
51302:     } // lock
51302: 
51302:     if (cacheIOThread)
51302:         cacheIOThread->Shutdown();
83182: 
85029:     if (shouldSanitize) {
85029:         nsresult rv = parentDir->AppendNative(NS_LITERAL_CSTRING("Cache"));
85029:         if (NS_SUCCEEDED(rv)) {
85029:             bool exists;
85029:             if (NS_SUCCEEDED(parentDir->Exists(&exists)) && exists)
85029:                 nsDeleteDir::DeleteDir(parentDir, false);
83182:         }
83182:         Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_SHUTDOWN_CLEAR_PRIVATE> timer;
85029:         nsDeleteDir::Shutdown(shouldSanitize);
83182:     } else {
83182:         Telemetry::AutoTimer<Telemetry::NETWORK_DISK_CACHE_DELETEDIR_SHUTDOWN> timer;
85029:         nsDeleteDir::Shutdown(shouldSanitize);
83182:     }
43113: }
43113: 
43113: 
46998: nsresult
43113: nsCacheService::Create(nsISupports* aOuter, const nsIID& aIID, void* *aResult)
43113: {
43113:     nsresult  rv;
43113: 
43113:     if (aOuter != nsnull)
43113:         return NS_ERROR_NO_AGGREGATION;
43113: 
43113:     nsCacheService * cacheService = new nsCacheService();
43113:     if (cacheService == nsnull)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     NS_ADDREF(cacheService);
43113:     rv = cacheService->Init();
43113:     if (NS_SUCCEEDED(rv)) {
43113:         rv = cacheService->QueryInterface(aIID, aResult);
43113:     }
43113:     NS_RELEASE(cacheService);
43113:     return rv;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheService::CreateSession(const char *          clientID,
43113:                               nsCacheStoragePolicy  storagePolicy, 
79445:                               bool                  streamBased,
43113:                               nsICacheSession     **result)
43113: {
43113:     *result = nsnull;
43113: 
43113:     if (this == nsnull)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     nsCacheSession * session = new nsCacheSession(clientID, storagePolicy, streamBased);
43113:     if (!session)  return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     NS_ADDREF(*result = session);
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::EvictEntriesForSession(nsCacheSession * session)
43113: {
43113:     NS_ASSERTION(gService, "nsCacheService::gService is null.");
43113:     return gService->EvictEntriesForClient(session->ClientID()->get(),
43113:                                  session->StoragePolicy());
43113: }
43113: 
76881: namespace {
76881: 
76881: class EvictionNotifierRunnable : public nsRunnable
76881: {
76881: public:
76881:     EvictionNotifierRunnable(nsISupports* aSubject)
76881:         : mSubject(aSubject)
76881:     { }
76881: 
76881:     NS_DECL_NSIRUNNABLE
76881: 
76881: private:
76881:     nsCOMPtr<nsISupports> mSubject;
76881: };
76881: 
76881: NS_IMETHODIMP
76881: EvictionNotifierRunnable::Run()
76881: {
76881:     nsCOMPtr<nsIObserverService> obsSvc =
76881:         mozilla::services::GetObserverService();
76881:     if (obsSvc) {
76881:         obsSvc->NotifyObservers(mSubject,
76881:                                 NS_CACHESERVICE_EMPTYCACHE_TOPIC_ID,
76881:                                 nsnull);
76881:     }
76881:     return NS_OK;
76881: }
76881: 
76881: } // anonymous namespace
43113: 
43113: nsresult
43113: nsCacheService::EvictEntriesForClient(const char *          clientID,
43113:                                       nsCacheStoragePolicy  storagePolicy)
43113: {
76881:     nsRefPtr<EvictionNotifierRunnable> r = new EvictionNotifierRunnable(this);
76881:     NS_DispatchToMainThread(r);
43113: 
43113:     nsCacheServiceAutoLock lock;
43113:     nsresult res = NS_OK;
43113: 
43113:     if (storagePolicy == nsICache::STORE_ANYWHERE ||
43113:         storagePolicy == nsICache::STORE_ON_DISK) {
43113: 
43113:         if (mEnableDiskDevice) {
95233:             nsresult rv = NS_OK;
43113:             if (!mDiskDevice)
43113:                 rv = CreateDiskDevice();
43113:             if (mDiskDevice)
43113:                 rv = mDiskDevice->EvictEntries(clientID);
95233:             if (NS_FAILED(rv))
95233:                 res = rv;
43113:         }
43113:     }
43113: 
43113:     // Only clear the offline cache if it has been specifically asked for.
43113:     if (storagePolicy == nsICache::STORE_OFFLINE) {
43113:         if (mEnableOfflineDevice) {
95233:             nsresult rv = NS_OK;
43113:             if (!mOfflineDevice)
43113:                 rv = CreateOfflineDevice();
43113:             if (mOfflineDevice)
43113:                 rv = mOfflineDevice->EvictEntries(clientID);
95233:             if (NS_FAILED(rv))
95233:                 res = rv;
43113:         }
43113:     }
43113: 
43113:     if (storagePolicy == nsICache::STORE_ANYWHERE ||
43113:         storagePolicy == nsICache::STORE_IN_MEMORY) {
43113:         // If there is no memory device, there is no need to evict it...
43113:         if (mMemoryDevice) {
95233:             nsresult rv = mMemoryDevice->EvictEntries(clientID);
95233:             if (NS_FAILED(rv))
95233:                 res = rv;
43113:         }
43113:     }
43113: 
43113:     return res;
43113: }
43113: 
43113: 
43113: nsresult        
43113: nsCacheService::IsStorageEnabledForPolicy(nsCacheStoragePolicy  storagePolicy,
79445:                                           bool *              result)
43113: {
43113:     if (gService == nsnull) return NS_ERROR_NOT_AVAILABLE;
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     *result = gService->IsStorageEnabledForPolicy_Locked(storagePolicy);
43113:     return NS_OK;
43113: }
43113: 
43113: 
93831: nsresult
93831: nsCacheService::DoomEntry(nsCacheSession   *session,
93831:                           const nsACString &key,
93831:                           nsICacheListener *listener)
93831: {
93831:     CACHE_LOG_DEBUG(("Dooming entry for session %p, key %s\n",
93831:                      session, PromiseFlatCString(key).get()));
93831:     NS_ASSERTION(gService, "nsCacheService::gService is null.");
93831: 
93831:     if (!gService->mInitialized)
93831:         return NS_ERROR_NOT_INITIALIZED;
93831: 
93831:     return DispatchToCacheIOThread(new nsDoomEvent(session, key, listener));
93831: }
93831: 
93831: 
79445: bool          
43113: nsCacheService::IsStorageEnabledForPolicy_Locked(nsCacheStoragePolicy  storagePolicy)
43113: {
43113:     if (gService->mEnableMemoryDevice &&
43113:         (storagePolicy == nsICache::STORE_ANYWHERE ||
43113:          storagePolicy == nsICache::STORE_IN_MEMORY)) {
80486:         return true;
43113:     }
43113:     if (gService->mEnableDiskDevice &&
43113:         (storagePolicy == nsICache::STORE_ANYWHERE ||
43113:          storagePolicy == nsICache::STORE_ON_DISK  ||
43113:          storagePolicy == nsICache::STORE_ON_DISK_AS_FILE)) {
80486:         return true;
43113:     }
43113:     if (gService->mEnableOfflineDevice &&
43113:         storagePolicy == nsICache::STORE_OFFLINE) {
80486:         return true;
43113:     }
43113:     
80486:     return false;
43113: }
43113: 
43113: NS_IMETHODIMP nsCacheService::VisitEntries(nsICacheVisitor *visitor)
43113: {
43113:     NS_ENSURE_ARG_POINTER(visitor);
43113: 
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     if (!(mEnableDiskDevice || mEnableMemoryDevice))
43113:         return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     // XXX record the fact that a visitation is in progress, 
43113:     // XXX i.e. keep list of visitors in progress.
43113:     
43113:     nsresult rv = NS_OK;
43113:     // If there is no memory device, there are then also no entries to visit...
43113:     if (mMemoryDevice) {
43113:         rv = mMemoryDevice->Visit(visitor);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113:     if (mEnableDiskDevice) {
43113:         if (!mDiskDevice) {
43113:             rv = CreateDiskDevice();
43113:             if (NS_FAILED(rv)) return rv;
43113:         }
43113:         rv = mDiskDevice->Visit(visitor);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113:     if (mEnableOfflineDevice) {
43113:         if (!mOfflineDevice) {
43113:             rv = CreateOfflineDevice();
43113:             if (NS_FAILED(rv)) return rv;
43113:         }
43113:         rv = mOfflineDevice->Visit(visitor);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113:     // XXX notify any shutdown process that visitation is complete for THIS visitor.
43113:     // XXX keep queue of visitors
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP nsCacheService::EvictEntries(nsCacheStoragePolicy storagePolicy)
43113: {
43113:     return  EvictEntriesForClient(nsnull, storagePolicy);
43113: }
43113: 
51302: NS_IMETHODIMP nsCacheService::GetCacheIOTarget(nsIEventTarget * *aCacheIOTarget)
51302: {
51302:     nsCacheServiceAutoLock lock;
51302: 
51302:     if (!mCacheIOThread)
51302:         return NS_ERROR_NOT_AVAILABLE;
51302: 
51302:     NS_ADDREF(*aCacheIOTarget = mCacheIOThread);
51302:     return NS_OK;
51302: }
51302: 
43113: /**
43113:  * Internal Methods
43113:  */
43113: nsresult
43113: nsCacheService::CreateDiskDevice()
43113: {
43113:     if (!mInitialized)      return NS_ERROR_NOT_AVAILABLE;
43113:     if (!mEnableDiskDevice) return NS_ERROR_NOT_AVAILABLE;
43113:     if (mDiskDevice)        return NS_OK;
43113: 
43113:     mDiskDevice = new nsDiskCacheDevice;
43113:     if (!mDiskDevice)       return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     // set the preferences
43113:     mDiskDevice->SetCacheParentDirectory(mObserver->DiskCacheParentDirectory());
43113:     mDiskDevice->SetCapacity(mObserver->DiskCacheCapacity());
72584:     mDiskDevice->SetMaxEntrySize(mObserver->DiskCacheMaxEntrySize());
43113:     
43113:     nsresult rv = mDiskDevice->Init();
43113:     if (NS_FAILED(rv)) {
43113: #if DEBUG
43113:         printf("###\n");
43113:         printf("### mDiskDevice->Init() failed (0x%.8x)\n", rv);
43113:         printf("###    - disabling disk cache for this session.\n");
43113:         printf("###\n");
43113: #endif        
80486:         mEnableDiskDevice = false;
43113:         delete mDiskDevice;
43113:         mDiskDevice = nsnull;
87165:         return rv;
43113:     }
80586: 
87165:     NS_ASSERTION(!mSmartSizeTimer, "Smartsize timer was already fired!");
87165: 
86759:     // Disk device is usually created during the startup. Delay smart size
86759:     // calculation to avoid possible massive IO caused by eviction of entries
86759:     // in case the new smart size is smaller than current cache usage.
86759:     mSmartSizeTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
87165:     if (NS_SUCCEEDED(rv)) {
86759:         rv = mSmartSizeTimer->InitWithCallback(new nsSetDiskSmartSizeCallback(),
86759:                                                1000*60*3,
86759:                                                nsITimer::TYPE_ONE_SHOT);
86759:         if (NS_FAILED(rv)) {
86759:             NS_WARNING("Failed to post smart size timer");
86759:             mSmartSizeTimer = nsnull;
86759:         }
87165:     } else {
87165:         NS_WARNING("Can't create smart size timer");
86759:     }
87165:     // Ignore state of the timer and return success since the purpose of the
87165:     // method (create the disk-device) has been fulfilled
87165: 
87165:     return NS_OK;
43113: }
43113: 
43113: nsresult
96032: nsCacheService::GetOfflineDevice(nsOfflineCacheDevice **aDevice)
96032: {
96032:     if (!mOfflineDevice) {
96032:         nsresult rv = CreateOfflineDevice();
96032:         NS_ENSURE_SUCCESS(rv, rv);
96032:     }
96032: 
96032:     NS_ADDREF(*aDevice = mOfflineDevice);
96032:     return NS_OK;
96032: }
96032: 
96032: nsresult
43113: nsCacheService::CreateOfflineDevice()
43113: {
43113:     CACHE_LOG_ALWAYS(("Creating offline device"));
43113: 
43113:     if (!mInitialized)         return NS_ERROR_NOT_AVAILABLE;
43113:     if (!mEnableOfflineDevice) return NS_ERROR_NOT_AVAILABLE;
43113:     if (mOfflineDevice)        return NS_OK;
43113: 
43113:     mOfflineDevice = new nsOfflineCacheDevice;
43113:     if (!mOfflineDevice)       return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     NS_ADDREF(mOfflineDevice);
43113: 
43113:     // set the preferences
43113:     mOfflineDevice->SetCacheParentDirectory(
43113:         mObserver->OfflineCacheParentDirectory());
43113:     mOfflineDevice->SetCapacity(mObserver->OfflineCacheCapacity());
43113: 
43113:     nsresult rv = mOfflineDevice->Init();
43113:     if (NS_FAILED(rv)) {
43113:         CACHE_LOG_DEBUG(("mOfflineDevice->Init() failed (0x%.8x)\n", rv));
43113:         CACHE_LOG_DEBUG(("    - disabling offline cache for this session.\n"));
43113: 
80486:         mEnableOfflineDevice = false;
43113:         NS_RELEASE(mOfflineDevice);
43113:     }
43113:     return rv;
43113: }
43113: 
43113: nsresult
43113: nsCacheService::CreateMemoryDevice()
43113: {
43113:     if (!mInitialized)        return NS_ERROR_NOT_AVAILABLE;
43113:     if (!mEnableMemoryDevice) return NS_ERROR_NOT_AVAILABLE;
43113:     if (mMemoryDevice)        return NS_OK;
43113: 
43113:     mMemoryDevice = new nsMemoryCacheDevice;
43113:     if (!mMemoryDevice)       return NS_ERROR_OUT_OF_MEMORY;
43113:     
43113:     // set preference
43113:     PRInt32 capacity = mObserver->MemoryCacheCapacity();
43113:     CACHE_LOG_DEBUG(("Creating memory device with capacity %d\n", capacity));
43113:     mMemoryDevice->SetCapacity(capacity);
72584:     mMemoryDevice->SetMaxEntrySize(mObserver->MemoryCacheMaxEntrySize());
43113: 
43113:     nsresult rv = mMemoryDevice->Init();
43113:     if (NS_FAILED(rv)) {
43113:         NS_WARNING("Initialization of Memory Cache failed.");
43113:         delete mMemoryDevice;
43113:         mMemoryDevice = nsnull;
43113:     }
74006: 
74006:     MemoryCacheReporter =
74006:         new NS_MEMORY_REPORTER_NAME(NetworkMemoryCache);
74006:     NS_RegisterMemoryReporter(MemoryCacheReporter);
74006: 
43113:     return rv;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::CreateRequest(nsCacheSession *   session,
43113:                               const nsACString & clientKey,
43113:                               nsCacheAccessMode  accessRequested,
79445:                               bool               blockingMode,
43113:                               nsICacheListener * listener,
43113:                               nsCacheRequest **  request)
43113: {
43113:     NS_ASSERTION(request, "CreateRequest: request is null");
43113:      
43113:     nsCString * key = new nsCString(*session->ClientID());
43113:     if (!key)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     key->Append(':');
43113:     key->Append(clientKey);
43113: 
43113:     if (mMaxKeyLength < key->Length()) mMaxKeyLength = key->Length();
43113: 
43113:     // create request
43113:     *request = new  nsCacheRequest(key, listener, accessRequested, blockingMode, session);    
43113:     if (!*request) {
43113:         delete key;
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     }
43113: 
43113:     if (!listener)  return NS_OK;  // we're sync, we're done.
43113: 
43113:     // get the request's thread
43113:     (*request)->mThread = do_GetCurrentThread();
43113:     
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: class nsCacheListenerEvent : public nsRunnable
43113: {
43113: public:
43113:     nsCacheListenerEvent(nsICacheListener *listener,
43113:                          nsICacheEntryDescriptor *descriptor,
43113:                          nsCacheAccessMode accessGranted,
43113:                          nsresult status)
43113:         : mListener(listener)      // transfers reference
43113:         , mDescriptor(descriptor)  // transfers reference (may be null)
43113:         , mAccessGranted(accessGranted)
43113:         , mStatus(status)
43113:     {}
43113: 
43113:     NS_IMETHOD Run()
43113:     {
43113:         mListener->OnCacheEntryAvailable(mDescriptor, mAccessGranted, mStatus);
43113: 
43113:         NS_RELEASE(mListener);
43113:         NS_IF_RELEASE(mDescriptor);
43113:         return NS_OK;
43113:     }
43113: 
43113: private:
43113:     // We explicitly leak mListener or mDescriptor if Run is not called
43113:     // because otherwise we cannot guarantee that they are destroyed on
43113:     // the right thread.
43113: 
43113:     nsICacheListener        *mListener;
43113:     nsICacheEntryDescriptor *mDescriptor;
43113:     nsCacheAccessMode        mAccessGranted;
43113:     nsresult                 mStatus;
43113: };
43113: 
43113: 
43113: nsresult
43113: nsCacheService::NotifyListener(nsCacheRequest *          request,
43113:                                nsICacheEntryDescriptor * descriptor,
43113:                                nsCacheAccessMode         accessGranted,
43113:                                nsresult                  status)
43113: {
43113:     NS_ASSERTION(request->mThread, "no thread set in async request!");
43113: 
43113:     // Swap ownership, and release listener on target thread...
43113:     nsICacheListener *listener = request->mListener;
43113:     request->mListener = nsnull;
43113: 
43113:     nsCOMPtr<nsIRunnable> ev =
43113:             new nsCacheListenerEvent(listener, descriptor,
43113:                                      accessGranted, status);
43113:     if (!ev) {
43113:         // Better to leak listener and descriptor if we fail because we don't
43113:         // want to destroy them inside the cache service lock or on potentially
43113:         // the wrong thread.
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     }
43113: 
43113:     return request->mThread->Dispatch(ev, NS_DISPATCH_NORMAL);
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::ProcessRequest(nsCacheRequest *           request,
79445:                                bool                       calledFromOpenCacheEntry,
43113:                                nsICacheEntryDescriptor ** result)
43113: {
43113:     // !!! must be called with mLock held !!!
43113:     nsresult           rv;
43113:     nsCacheEntry *     entry = nsnull;
56468:     nsCacheEntry *     doomedEntry = nsnull;
43113:     nsCacheAccessMode  accessGranted = nsICache::ACCESS_NONE;
43113:     if (result) *result = nsnull;
43113: 
43113:     while(1) {  // Activate entry loop
56468:         rv = ActivateEntry(request, &entry, &doomedEntry);  // get the entry for this request
43113:         if (NS_FAILED(rv))  break;
43113: 
43113:         while(1) { // Request Access loop
43113:             NS_ASSERTION(entry, "no entry in Request Access loop!");
43113:             // entry->RequestAccess queues request on entry
43113:             rv = entry->RequestAccess(request, &accessGranted);
43113:             if (rv != NS_ERROR_CACHE_WAIT_FOR_VALIDATION) break;
43113: 
93829:             if (request->IsBlocking()) {
93829:                 if (request->mListener) {
93829:                     // async exits - validate, doom, or close will resume
43113:                     return rv;
93829:                 }
93829: 
43113:                 // XXX this is probably wrong...
43113:                 Unlock();
43113:                 rv = request->WaitForValidation();
43113:                 Lock();
43113:             }
43113: 
43113:             PR_REMOVE_AND_INIT_LINK(request);
43113:             if (NS_FAILED(rv)) break;   // non-blocking mode returns WAIT_FOR_VALIDATION error
43113:             // okay, we're ready to process this request, request access again
43113:         }
43113:         if (rv != NS_ERROR_CACHE_ENTRY_DOOMED)  break;
43113: 
43113:         if (entry->IsNotInUse()) {
43113:             // this request was the last one keeping it around, so get rid of it
43113:             DeactivateEntry(entry);
43113:         }
43113:         // loop back around to look for another entry
43113:     }
43113: 
43113:     nsICacheEntryDescriptor *descriptor = nsnull;
43113:     
43113:     if (NS_SUCCEEDED(rv))
43113:         rv = entry->CreateDescriptor(request, accessGranted, &descriptor);
43113: 
56468:     // If doomedEntry is set, ActivatEntry() doomed an existing entry and
56468:     // created a new one for that cache-key. However, any pending requests
56468:     // on the doomed entry were not processed and we need to do that here.
56468:     // This must be done after adding the created entry to list of active
56468:     // entries (which is done in ActivateEntry()) otherwise the hashkeys crash
56468:     // (see bug ##561313). It is also important to do this after creating a
56468:     // descriptor for this request, or some other request may end up being
56468:     // executed first for the newly created entry.
56468:     // Finally, it is worth to emphasize that if doomedEntry is set,
56468:     // ActivateEntry() created a new entry for the request, which will be
56468:     // initialized by RequestAccess() and they both should have returned NS_OK.
56468:     if (doomedEntry) {
56468:         (void) ProcessPendingRequests(doomedEntry);
56468:         if (doomedEntry->IsNotInUse())
56468:             DeactivateEntry(doomedEntry);
56468:         doomedEntry = nsnull;
56468:     }
56468: 
43113:     if (request->mListener) {  // Asynchronous
43113:     
43113:         if (NS_FAILED(rv) && calledFromOpenCacheEntry)
43113:             return rv;  // skip notifying listener, just return rv to caller
43113:             
43113:         // call listener to report error or descriptor
43113:         nsresult rv2 = NotifyListener(request, descriptor, accessGranted, rv);
43113:         if (NS_FAILED(rv2) && NS_SUCCEEDED(rv)) {
43113:             rv = rv2;  // trigger delete request
43113:         }
43113:     } else {        // Synchronous
43113:         *result = descriptor;
43113:     }
43113:     return rv;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::OpenCacheEntry(nsCacheSession *           session,
43113:                                const nsACString &         key,
43113:                                nsCacheAccessMode          accessRequested,
79445:                                bool                       blockingMode,
43113:                                nsICacheListener *         listener,
43113:                                nsICacheEntryDescriptor ** result)
43113: {
43113:     CACHE_LOG_DEBUG(("Opening entry for session %p, key %s, mode %d, blocking %d\n",
43113:                      session, PromiseFlatCString(key).get(), accessRequested,
43113:                      blockingMode));
43113:     NS_ASSERTION(gService, "nsCacheService::gService is null.");
43113:     if (result)
43113:         *result = nsnull;
43113: 
43113:     if (!gService->mInitialized)
43113:         return NS_ERROR_NOT_INITIALIZED;
43113: 
43113:     nsCacheRequest * request = nsnull;
43113: 
43113:     nsresult rv = gService->CreateRequest(session,
43113:                                           key,
43113:                                           accessRequested,
43113:                                           blockingMode,
43113:                                           listener,
43113:                                           &request);
43113:     if (NS_FAILED(rv))  return rv;
43113: 
43113:     CACHE_LOG_DEBUG(("Created request %p\n", request));
43113: 
51302:     // Process the request on the background thread if we are on the main thread
51302:     // and the the request is asynchronous
51302:     if (NS_IsMainThread() && listener && gService->mCacheIOThread) {
51302:         nsCOMPtr<nsIRunnable> ev =
51302:             new nsProcessRequestEvent(request);
63652:         rv = DispatchToCacheIOThread(ev);
51302: 
51302:         // delete request if we didn't post the event
51302:         if (NS_FAILED(rv))
51302:             delete request;
51302:     }
53987:     else {
63652: 
63652:         nsCacheServiceAutoLock lock;
80486:         rv = gService->ProcessRequest(request, true, result);
43113: 
43113:         // delete requests that have completed
93829:         if (!(listener && blockingMode &&
93829:             (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION)))
43113:             delete request;
51302:     }
43113: 
43113:     return rv;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::ActivateEntry(nsCacheRequest * request, 
56468:                               nsCacheEntry ** result,
56468:                               nsCacheEntry ** doomedEntry)
43113: {
43113:     CACHE_LOG_DEBUG(("Activate entry for request %p\n", request));
95284:     if (!mInitialized || mClearingEntries)
95284:         return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     nsresult        rv = NS_OK;
43113: 
43113:     NS_ASSERTION(request != nsnull, "ActivateEntry called with no request");
43113:     if (result) *result = nsnull;
56468:     if (doomedEntry) *doomedEntry = nsnull;
56468:     if ((!request) || (!result) || (!doomedEntry))
56468:         return NS_ERROR_NULL_POINTER;
43113: 
43113:     // check if the request can be satisfied
43113:     if (!mEnableMemoryDevice && !request->IsStreamBased())
43113:         return NS_ERROR_FAILURE;
43113:     if (!IsStorageEnabledForPolicy_Locked(request->StoragePolicy()))
43113:         return NS_ERROR_FAILURE;
43113: 
43113:     // search active entries (including those not bound to device)
43113:     nsCacheEntry *entry = mActiveEntries.GetEntry(request->mKey);
43113:     CACHE_LOG_DEBUG(("Active entry for request %p is %p\n", request, entry));
43113: 
43113:     if (!entry) {
43113:         // search cache devices for entry
79445:         bool collision = false;
43113:         entry = SearchCacheDevices(request->mKey, request->StoragePolicy(), &collision);
43113:         CACHE_LOG_DEBUG(("Device search for request %p returned %p\n",
43113:                          request, entry));
43113:         // When there is a hashkey collision just refuse to cache it...
43113:         if (collision) return NS_ERROR_CACHE_IN_USE;
43113: 
43113:         if (entry)  entry->MarkInitialized();
56468:     } else {
56468:         NS_ASSERTION(entry->IsActive(), "Inactive entry found in mActiveEntries!");
43113:     }
43113: 
43113:     if (entry) {
43113:         ++mCacheHits;
43113:         entry->Fetched();
43113:     } else {
43113:         ++mCacheMisses;
43113:     }
43113: 
43113:     if (entry &&
43113:         ((request->AccessRequested() == nsICache::ACCESS_WRITE) ||
43113:          ((request->StoragePolicy() != nsICache::STORE_OFFLINE) &&
43113:           (entry->mExpirationTime <= SecondsFromPRTime(PR_Now()) &&
43113:            request->WillDoomEntriesIfExpired()))))
43113: 
43113:     {
43113:         // this is FORCE-WRITE request or the entry has expired
56468:         // we doom entry without processing pending requests, but store it in
56468:         // doomedEntry which causes pending requests to be processed below
56468:         rv = DoomEntry_Internal(entry, false);
56468:         *doomedEntry = entry;
43113:         if (NS_FAILED(rv)) {
43113:             // XXX what to do?  Increment FailedDooms counter?
43113:         }
43113:         entry = nsnull;
43113:     }
43113: 
43113:     if (!entry) {
43113:         if (! (request->AccessRequested() & nsICache::ACCESS_WRITE)) {
43113:             // this is a READ-ONLY request
43113:             rv = NS_ERROR_CACHE_KEY_NOT_FOUND;
43113:             goto error;
43113:         }
43113: 
43113:         entry = new nsCacheEntry(request->mKey,
43113:                                  request->IsStreamBased(),
43113:                                  request->StoragePolicy());
43113:         if (!entry)
43113:             return NS_ERROR_OUT_OF_MEMORY;
43113:         
43113:         entry->Fetched();
43113:         ++mTotalEntries;
43113: 
43113:         // XXX  we could perform an early bind in some cases based on storage policy
43113:     }
43113: 
43113:     if (!entry->IsActive()) {
43113:         rv = mActiveEntries.AddEntry(entry);
43113:         if (NS_FAILED(rv)) goto error;
43113:         CACHE_LOG_DEBUG(("Added entry %p to mActiveEntries\n", entry));
43113:         entry->MarkActive();  // mark entry active, because it's now in mActiveEntries
43113:     }
43113:     *result = entry;
43113:     return NS_OK;
43113:     
43113:  error:
43113:     *result = nsnull;
43113:     delete entry;
43113:     return rv;
43113: }
43113: 
43113: 
43113: nsCacheEntry *
79445: nsCacheService::SearchCacheDevices(nsCString * key, nsCacheStoragePolicy policy, bool *collision)
43113: {
81095:     Telemetry::AutoTimer<Telemetry::CACHE_DEVICE_SEARCH> timer;
43113:     nsCacheEntry * entry = nsnull;
43113: 
43113:     CACHE_LOG_DEBUG(("mMemoryDevice: 0x%p\n", mMemoryDevice));
43113: 
80486:     *collision = false;
43113:     if ((policy == nsICache::STORE_ANYWHERE) || (policy == nsICache::STORE_IN_MEMORY)) {
43113:         // If there is no memory device, then there is nothing to search...
43113:         if (mMemoryDevice) {
43113:             entry = mMemoryDevice->FindEntry(key, collision);
43113:             CACHE_LOG_DEBUG(("Searching mMemoryDevice for key %s found: 0x%p, "
43113:                              "collision: %d\n", key->get(), entry, collision));
43113:         }
43113:     }
43113: 
43113:     if (!entry && 
43113:         ((policy == nsICache::STORE_ANYWHERE) || (policy == nsICache::STORE_ON_DISK))) {
43113: 
43113:         if (mEnableDiskDevice) {
43113:             if (!mDiskDevice) {
43113:                 nsresult rv = CreateDiskDevice();
43113:                 if (NS_FAILED(rv))
43113:                     return nsnull;
43113:             }
43113:             
43113:             entry = mDiskDevice->FindEntry(key, collision);
43113:         }
43113:     }
43113: 
43113:     if (!entry && (policy == nsICache::STORE_OFFLINE ||
43113:                    (policy == nsICache::STORE_ANYWHERE &&
43113:                     gIOService->IsOffline()))) {
43113: 
43113:         if (mEnableOfflineDevice) {
43113:             if (!mOfflineDevice) {
43113:                 nsresult rv = CreateOfflineDevice();
43113:                 if (NS_FAILED(rv))
43113:                     return nsnull;
43113:             }
43113: 
43113:             entry = mOfflineDevice->FindEntry(key, collision);
43113:         }
43113:     }
43113: 
43113:     return entry;
43113: }
43113: 
43113: 
43113: nsCacheDevice *
43113: nsCacheService::EnsureEntryHasDevice(nsCacheEntry * entry)
43113: {
43113:     nsCacheDevice * device = entry->CacheDevice();
56468:     // return device if found, possibly null if the entry is doomed i.e prevent
56468:     // doomed entries to bind to a device (see e.g. bugs #548406 and #596443)
56468:     if (device || entry->IsDoomed())  return device;
43113: 
52143:     PRInt64 predictedDataSize = entry->PredictedDataSize();
43113:     if (entry->IsStreamData() && entry->IsAllowedOnDisk() && mEnableDiskDevice) {
43113:         // this is the default
43113:         if (!mDiskDevice) {
43113:             (void)CreateDiskDevice();  // ignore the error (check for mDiskDevice instead)
43113:         }
43113: 
43113:         if (mDiskDevice) {
52143:             // Bypass the cache if Content-Length says the entry will be too big
52143:             if (predictedDataSize != -1 &&
67725:                 entry->StoragePolicy() != nsICache::STORE_ON_DISK_AS_FILE &&
52143:                 mDiskDevice->EntryIsTooBig(predictedDataSize)) {
72127:                 DebugOnly<nsresult> rv = nsCacheService::DoomEntry(entry);
52143:                 NS_ASSERTION(NS_SUCCEEDED(rv),"DoomEntry() failed.");
52143:                 return nsnull;
52143:             }
52143: 
43113:             entry->MarkBinding();  // enter state of binding
43113:             nsresult rv = mDiskDevice->BindEntry(entry);
43113:             entry->ClearBinding(); // exit state of binding
43113:             if (NS_SUCCEEDED(rv))
43113:                 device = mDiskDevice;
43113:         }
43113:     }
43113: 
43113:     // if we can't use mDiskDevice, try mMemoryDevice
43113:     if (!device && mEnableMemoryDevice && entry->IsAllowedInMemory()) {        
43113:         if (!mMemoryDevice) {
43113:             (void)CreateMemoryDevice();  // ignore the error (check for mMemoryDevice instead)
43113:         }
43113:         if (mMemoryDevice) {
52143:             // Bypass the cache if Content-Length says entry will be too big
52143:             if (predictedDataSize != -1 &&
52143:                 mMemoryDevice->EntryIsTooBig(predictedDataSize)) {
72127:                 DebugOnly<nsresult> rv = nsCacheService::DoomEntry(entry);
52143:                 NS_ASSERTION(NS_SUCCEEDED(rv),"DoomEntry() failed.");
52143:                 return nsnull;
52143:             }
52143: 
43113:             entry->MarkBinding();  // enter state of binding
43113:             nsresult rv = mMemoryDevice->BindEntry(entry);
43113:             entry->ClearBinding(); // exit state of binding
43113:             if (NS_SUCCEEDED(rv))
43113:                 device = mMemoryDevice;
43113:         }
43113:     }
43113: 
43113:     if (!device && entry->IsStreamData() &&
43113:         entry->IsAllowedOffline() && mEnableOfflineDevice) {
43113:         if (!mOfflineDevice) {
43113:             (void)CreateOfflineDevice(); // ignore the error (check for mOfflineDevice instead)
43113:         }
43113: 
43113:         if (mOfflineDevice) {
43113:             entry->MarkBinding();
43113:             nsresult rv = mOfflineDevice->BindEntry(entry);
43113:             entry->ClearBinding();
43113:             if (NS_SUCCEEDED(rv))
43113:                 device = mOfflineDevice;
43113:         }
43113:     }
43113: 
43113:     if (device) 
43113:         entry->SetCacheDevice(device);
43113:     return device;
43113: }
43113: 
74006: PRInt64
74006: nsCacheService::MemoryDeviceSize()
74006: {
74006:     nsMemoryCacheDevice *memoryDevice = GlobalInstance()->mMemoryDevice;
74006:     return memoryDevice ? memoryDevice->TotalSize() : 0;
74006: }
43113: 
43113: nsresult
43113: nsCacheService::DoomEntry(nsCacheEntry * entry)
43113: {
56468:     return gService->DoomEntry_Internal(entry, true);
43113: }
43113: 
43113: 
43113: nsresult
56468: nsCacheService::DoomEntry_Internal(nsCacheEntry * entry,
79445:                                    bool doProcessPendingRequests)
43113: {
43113:     if (entry->IsDoomed())  return NS_OK;
43113:     
43113:     CACHE_LOG_DEBUG(("Dooming entry %p\n", entry));
43113:     nsresult  rv = NS_OK;
43113:     entry->MarkDoomed();
43113:     
43113:     NS_ASSERTION(!entry->IsBinding(), "Dooming entry while binding device.");
43113:     nsCacheDevice * device = entry->CacheDevice();
43113:     if (device)  device->DoomEntry(entry);
43113: 
43113:     if (entry->IsActive()) {
43113:         // remove from active entries
43113:         mActiveEntries.RemoveEntry(entry);
43113:         CACHE_LOG_DEBUG(("Removed entry %p from mActiveEntries\n", entry));
43113:         entry->MarkInactive();
43113:      }
43113: 
43113:     // put on doom list to wait for descriptors to close
43113:     NS_ASSERTION(PR_CLIST_IS_EMPTY(entry), "doomed entry still on device list");
43113:     PR_APPEND_LINK(entry, &mDoomedEntries);
43113: 
56468:     // handle pending requests only if we're supposed to
56468:     if (doProcessPendingRequests) {
43113:         // tell pending requests to get on with their lives...
43113:         rv = ProcessPendingRequests(entry);
43113: 
43113:         // All requests have been removed, but there may still be open descriptors
43113:         if (entry->IsNotInUse()) {
43113:             DeactivateEntry(entry); // tell device to get rid of it
43113:         }
56468:     }
43113:     return rv;
43113: }
43113: 
43113: 
43113: void
79445: nsCacheService::OnProfileShutdown(bool cleanse)
43113: {
43113:     if (!gService)  return;
43113:     if (!gService->mInitialized) {
43113:         // The cache service has been shut down, but someone is still holding
43113:         // a reference to it. Ignore this call.
43113:         return;
43113:     }
43113:     nsCacheServiceAutoLock lock;
95284:     gService->mClearingEntries = true;
43113: 
43113:     gService->DoomActiveEntries();
43113:     gService->ClearDoomList();
43113: 
61001:     // Make sure to wait for any pending cache-operations before
61001:     // proceeding with destructive actions (bug #620660)
61001:     (void) SyncWithCacheIOThread();
61001: 
43113:     if (gService->mDiskDevice && gService->mEnableDiskDevice) {
43113:         if (cleanse)
43113:             gService->mDiskDevice->EvictEntries(nsnull);
43113: 
43113:         gService->mDiskDevice->Shutdown();
43113:     }
80486:     gService->mEnableDiskDevice = false;
43113: 
43113:     if (gService->mOfflineDevice && gService->mEnableOfflineDevice) {
43113:         if (cleanse)
43113:             gService->mOfflineDevice->EvictEntries(nsnull);
43113: 
43113:         gService->mOfflineDevice->Shutdown();
43113:     }
80486:     gService->mEnableOfflineDevice = false;
43113: 
43113:     if (gService->mMemoryDevice) {
43113:         // clear memory cache
43113:         gService->mMemoryDevice->EvictEntries(nsnull);
43113:     }
43113: 
95284:     gService->mClearingEntries = false;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::OnProfileChanged()
43113: {
43113:     if (!gService)  return;
43113: 
43113:     CACHE_LOG_DEBUG(("nsCacheService::OnProfileChanged"));
43113:  
43113:     nsCacheServiceAutoLock lock;
43113:     
43113:     gService->mEnableDiskDevice    = gService->mObserver->DiskCacheEnabled();
43113:     gService->mEnableOfflineDevice = gService->mObserver->OfflineCacheEnabled();
43113:     gService->mEnableMemoryDevice  = gService->mObserver->MemoryCacheEnabled();
43113: 
43113:     if (gService->mDiskDevice) {
43113:         gService->mDiskDevice->SetCacheParentDirectory(gService->mObserver->DiskCacheParentDirectory());
43113:         gService->mDiskDevice->SetCapacity(gService->mObserver->DiskCacheCapacity());
43113: 
43113:         // XXX initialization of mDiskDevice could be made lazily, if mEnableDiskDevice is false
43113:         nsresult rv = gService->mDiskDevice->Init();
43113:         if (NS_FAILED(rv)) {
43113:             NS_ERROR("nsCacheService::OnProfileChanged: Re-initializing disk device failed");
80486:             gService->mEnableDiskDevice = false;
43113:             // XXX delete mDiskDevice?
43113:         }
43113:     }
43113: 
43113:     if (gService->mOfflineDevice) {
43113:         gService->mOfflineDevice->SetCacheParentDirectory(gService->mObserver->OfflineCacheParentDirectory());
43113:         gService->mOfflineDevice->SetCapacity(gService->mObserver->OfflineCacheCapacity());
43113: 
43113:         // XXX initialization of mOfflineDevice could be made lazily, if mEnableOfflineDevice is false
43113:         nsresult rv = gService->mOfflineDevice->Init();
43113:         if (NS_FAILED(rv)) {
43113:             NS_ERROR("nsCacheService::OnProfileChanged: Re-initializing offline device failed");
80486:             gService->mEnableOfflineDevice = false;
43113:             // XXX delete mOfflineDevice?
43113:         }
43113:     }
43113: 
43113:     // If memoryDevice exists, reset its size to the new profile
43113:     if (gService->mMemoryDevice) {
43113:         if (gService->mEnableMemoryDevice) {
43113:             // make sure that capacity is reset to the right value
43113:             PRInt32 capacity = gService->mObserver->MemoryCacheCapacity();
43113:             CACHE_LOG_DEBUG(("Resetting memory device capacity to %d\n",
43113:                              capacity));
43113:             gService->mMemoryDevice->SetCapacity(capacity);
43113:         } else {
43113:             // tell memory device to evict everything
43113:             CACHE_LOG_DEBUG(("memory device disabled\n"));
43113:             gService->mMemoryDevice->SetCapacity(0);
43113:             // Don't delete memory device, because some entries may be active still...
43113:         }
43113:     }
43113: }
43113: 
43113: 
43113: void
79445: nsCacheService::SetDiskCacheEnabled(bool    enabled)
43113: {
43113:     if (!gService)  return;
43113:     nsCacheServiceAutoLock lock;
43113:     gService->mEnableDiskDevice = enabled;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::SetDiskCacheCapacity(PRInt32  capacity)
43113: {
43113:     if (!gService)  return;
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     if (gService->mDiskDevice) {
43113:         gService->mDiskDevice->SetCapacity(capacity);
43113:     }
43113: 
53962:     if (gService->mObserver)
43113:         gService->mEnableDiskDevice = gService->mObserver->DiskCacheEnabled();
43113: }
43113: 
43113: void
72584: nsCacheService::SetDiskCacheMaxEntrySize(PRInt32  maxSize)
72584: {
72584:     if (!gService)  return;
72584:     nsCacheServiceAutoLock lock;
72584: 
72584:     if (gService->mDiskDevice) {
72584:         gService->mDiskDevice->SetMaxEntrySize(maxSize);
72584:     }
72584: }
72584: 
72584: void
72584: nsCacheService::SetMemoryCacheMaxEntrySize(PRInt32  maxSize)
72584: {
72584:     if (!gService)  return;
72584:     nsCacheServiceAutoLock lock;
72584: 
72584:     if (gService->mMemoryDevice) {
72584:         gService->mMemoryDevice->SetMaxEntrySize(maxSize);
72584:     }
72584: }
72584: 
72584: void
79445: nsCacheService::SetOfflineCacheEnabled(bool    enabled)
43113: {
43113:     if (!gService)  return;
43113:     nsCacheServiceAutoLock lock;
43113:     gService->mEnableOfflineDevice = enabled;
43113: }
43113: 
43113: void
43113: nsCacheService::SetOfflineCacheCapacity(PRInt32  capacity)
43113: {
43113:     if (!gService)  return;
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     if (gService->mOfflineDevice) {
43113:         gService->mOfflineDevice->SetCapacity(capacity);
43113:     }
43113: 
43113:     gService->mEnableOfflineDevice = gService->mObserver->OfflineCacheEnabled();
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::SetMemoryCache()
43113: {
43113:     if (!gService)  return;
43113: 
43113:     CACHE_LOG_DEBUG(("nsCacheService::SetMemoryCache"));
43113: 
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     gService->mEnableMemoryDevice = gService->mObserver->MemoryCacheEnabled();
43113: 
43113:     if (gService->mEnableMemoryDevice) {
43113:         if (gService->mMemoryDevice) {
43113:             PRInt32 capacity = gService->mObserver->MemoryCacheCapacity();
43113:             // make sure that capacity is reset to the right value
43113:             CACHE_LOG_DEBUG(("Resetting memory device capacity to %d\n",
43113:                              capacity));
43113:             gService->mMemoryDevice->SetCapacity(capacity);
43113:         }
43113:     } else {
43113:         if (gService->mMemoryDevice) {
43113:             // tell memory device to evict everything
43113:             CACHE_LOG_DEBUG(("memory device disabled\n"));
43113:             gService->mMemoryDevice->SetCapacity(0);
43113:             // Don't delete memory device, because some entries may be active still...
43113:         }
43113:     }
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  * static methods for nsCacheEntryDescriptor
43113:  *****************************************************************************/
43113: void
43113: nsCacheService::CloseDescriptor(nsCacheEntryDescriptor * descriptor)
43113: {
43113:     // ask entry to remove descriptor
43113:     nsCacheEntry * entry       = descriptor->CacheEntry();
79445:     bool           stillActive = entry->RemoveDescriptor(descriptor);
43113:     nsresult       rv          = NS_OK;
43113: 
43113:     if (!entry->IsValid()) {
43113:         rv = gService->ProcessPendingRequests(entry);
43113:     }
43113: 
43113:     if (!stillActive) {
43113:         gService->DeactivateEntry(entry);
43113:     }
43113: }
43113: 
43113: 
43113: nsresult        
43113: nsCacheService::GetFileForEntry(nsCacheEntry *         entry,
43113:                                 nsIFile **             result)
43113: {
43113:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
43113:     if (!device)  return  NS_ERROR_UNEXPECTED;
43113:     
43113:     return device->GetFileForEntry(entry, result);
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::OpenInputStreamForEntry(nsCacheEntry *     entry,
43113:                                         nsCacheAccessMode  mode,
43113:                                         PRUint32           offset,
43113:                                         nsIInputStream  ** result)
43113: {
43113:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
43113:     if (!device)  return  NS_ERROR_UNEXPECTED;
43113: 
43113:     return device->OpenInputStreamForEntry(entry, mode, offset, result);
43113: }
43113: 
43113: nsresult
43113: nsCacheService::OpenOutputStreamForEntry(nsCacheEntry *     entry,
43113:                                          nsCacheAccessMode  mode,
43113:                                          PRUint32           offset,
43113:                                          nsIOutputStream ** result)
43113: {
43113:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
43113:     if (!device)  return  NS_ERROR_UNEXPECTED;
43113: 
43113:     return device->OpenOutputStreamForEntry(entry, mode, offset, result);
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::OnDataSizeChange(nsCacheEntry * entry, PRInt32 deltaSize)
43113: {
43113:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
43113:     if (!device)  return  NS_ERROR_UNEXPECTED;
43113: 
43113:     return device->OnDataSizeChange(entry, deltaSize);
43113: }
43113: 
43113: void
43113: nsCacheService::Lock()
43113: {
91229:     if (NS_IsMainThread()) {
91229:         Telemetry::AutoTimer<Telemetry::CACHE_SERVICE_LOCK_WAIT_MAINTHREAD> timer;
64576:         gService->mLock.Lock();
91229:     } else {
91229:         Telemetry::AutoTimer<Telemetry::CACHE_SERVICE_LOCK_WAIT> timer;
91229:         gService->mLock.Lock();
91229:     }
43113: }
43113: 
43113: void
43113: nsCacheService::Unlock()
43113: {
64576:     gService->mLock.AssertCurrentThreadOwns();
43113: 
43113:     nsTArray<nsISupports*> doomed;
43113:     doomed.SwapElements(gService->mDoomedObjects);
43113: 
64576:     gService->mLock.Unlock();
43113: 
43113:     for (PRUint32 i = 0; i < doomed.Length(); ++i)
43113:         doomed[i]->Release();
43113: }
43113: 
43113: void
43113: nsCacheService::ReleaseObject_Locked(nsISupports * obj,
43113:                                      nsIEventTarget * target)
43113: {
64576:     gService->mLock.AssertCurrentThreadOwns();
43113: 
79445:     bool isCur;
51302:     if (!target || (NS_SUCCEEDED(target->IsOnCurrentThread(&isCur)) && isCur)) {
43113:         gService->mDoomedObjects.AppendElement(obj);
43113:     } else {
43113:         NS_ProxyRelease(target, obj);
43113:     }
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::SetCacheElement(nsCacheEntry * entry, nsISupports * element)
43113: {
43113:     entry->SetData(element);
43113:     entry->TouchData();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::ValidateEntry(nsCacheEntry * entry)
43113: {
43113:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
43113:     if (!device)  return  NS_ERROR_UNEXPECTED;
43113: 
43113:     entry->MarkValid();
43113:     nsresult rv = gService->ProcessPendingRequests(entry);
43113:     NS_ASSERTION(rv == NS_OK, "ProcessPendingRequests failed.");
43113:     // XXX what else should be done?
43113: 
43113:     return rv;
43113: }
43113: 
43113: 
84841: PRInt32
84841: nsCacheService::CacheCompressionLevel()
84841: {
84841:     PRInt32 level = gService->mObserver->CacheCompressionLevel();
84841:     return level;
84841: }
84841: 
84841: 
43113: void
43113: nsCacheService::DeactivateEntry(nsCacheEntry * entry)
43113: {
43113:     CACHE_LOG_DEBUG(("Deactivating entry %p\n", entry));
43113:     nsresult  rv = NS_OK;
43113:     NS_ASSERTION(entry->IsNotInUse(), "### deactivating an entry while in use!");
43113:     nsCacheDevice * device = nsnull;
43113: 
43113:     if (mMaxDataSize < entry->DataSize() )     mMaxDataSize = entry->DataSize();
43113:     if (mMaxMetaSize < entry->MetaDataSize() ) mMaxMetaSize = entry->MetaDataSize();
43113: 
43113:     if (entry->IsDoomed()) {
43113:         // remove from Doomed list
43113:         PR_REMOVE_AND_INIT_LINK(entry);
43113:     } else if (entry->IsActive()) {
43113:         // remove from active entries
43113:         mActiveEntries.RemoveEntry(entry);
43113:         CACHE_LOG_DEBUG(("Removed deactivated entry %p from mActiveEntries\n",
43113:                          entry));
43113:         entry->MarkInactive();
43113: 
43113:         // bind entry if necessary to store meta-data
43113:         device = EnsureEntryHasDevice(entry); 
43113:         if (!device) {
43113:             CACHE_LOG_DEBUG(("DeactivateEntry: unable to bind active "
43113:                              "entry %p\n",
43113:                              entry));
43113:             NS_WARNING("DeactivateEntry: unable to bind active entry\n");
43113:             return;
43113:         }
43113:     } else {
80486:         // if mInitialized == false,
43113:         // then we're shutting down and this state is okay.
43113:         NS_ASSERTION(!mInitialized, "DeactivateEntry: bad cache entry state.");
43113:     }
43113: 
43113:     device = entry->CacheDevice();
43113:     if (device) {
43113:         rv = device->DeactivateEntry(entry);
43113:         if (NS_FAILED(rv)) {
43113:             // increment deactivate failure count
43113:             ++mDeactivateFailures;
43113:         }
43113:     } else {
43113:         // increment deactivating unbound entry statistic
43113:         ++mDeactivatedUnboundEntries;
43113:         delete entry; // because no one else will
43113:     }
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::ProcessPendingRequests(nsCacheEntry * entry)
43113: {
43113:     nsresult            rv = NS_OK;
43113:     nsCacheRequest *    request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);
43113:     nsCacheRequest *    nextRequest;
79445:     bool                newWriter = false;
43113:     
56468:     CACHE_LOG_DEBUG(("ProcessPendingRequests for %sinitialized %s %salid entry %p\n",
56468:                     (entry->IsInitialized()?"" : "Un"),
56468:                     (entry->IsDoomed()?"DOOMED" : ""),
56468:                     (entry->IsValid()? "V":"Inv"), entry));
56468: 
43113:     if (request == &entry->mRequestQ)  return NS_OK;    // no queued requests
43113: 
43113:     if (!entry->IsDoomed() && entry->IsInvalid()) {
43113:         // 1st descriptor closed w/o MarkValid()
43113:         NS_ASSERTION(PR_CLIST_IS_EMPTY(&entry->mDescriptorQ), "shouldn't be here with open descriptors");
43113: 
43113: #if DEBUG
43113:         // verify no ACCESS_WRITE requests(shouldn't have any of these)
43113:         while (request != &entry->mRequestQ) {
43113:             NS_ASSERTION(request->AccessRequested() != nsICache::ACCESS_WRITE,
43113:                          "ACCESS_WRITE request should have been given a new entry");
43113:             request = (nsCacheRequest *)PR_NEXT_LINK(request);
43113:         }
43113:         request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);        
43113: #endif
43113:         // find first request with ACCESS_READ_WRITE (if any) and promote it to 1st writer
43113:         while (request != &entry->mRequestQ) {
43113:             if (request->AccessRequested() == nsICache::ACCESS_READ_WRITE) {
80486:                 newWriter = true;
56468:                 CACHE_LOG_DEBUG(("  promoting request %p to 1st writer\n", request));
43113:                 break;
43113:             }
43113: 
43113:             request = (nsCacheRequest *)PR_NEXT_LINK(request);
43113:         }
43113:         
43113:         if (request == &entry->mRequestQ)   // no requests asked for ACCESS_READ_WRITE, back to top
43113:             request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);
43113:         
43113:         // XXX what should we do if there are only READ requests in queue?
43113:         // XXX serialize their accesses, give them only read access, but force them to check validate flag?
43113:         // XXX or do readers simply presume the entry is valid
61109:         // See fix for bug #467392 below
43113:     }
43113: 
43113:     nsCacheAccessMode  accessGranted = nsICache::ACCESS_NONE;
43113: 
43113:     while (request != &entry->mRequestQ) {
43113:         nextRequest = (nsCacheRequest *)PR_NEXT_LINK(request);
56468:         CACHE_LOG_DEBUG(("  %sync request %p for %p\n",
56468:                         (request->mListener?"As":"S"), request, entry));
43113: 
43113:         if (request->mListener) {
43113: 
43113:             // Async request
43113:             PR_REMOVE_AND_INIT_LINK(request);
43113: 
43113:             if (entry->IsDoomed()) {
80486:                 rv = ProcessRequest(request, false, nsnull);
43113:                 if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION)
43113:                     rv = NS_OK;
43113:                 else
43113:                     delete request;
43113: 
43113:                 if (NS_FAILED(rv)) {
43113:                     // XXX what to do?
43113:                 }
43113:             } else if (entry->IsValid() || newWriter) {
43113:                 rv = entry->RequestAccess(request, &accessGranted);
43113:                 NS_ASSERTION(NS_SUCCEEDED(rv),
43113:                              "if entry is valid, RequestAccess must succeed.");
43113:                 // XXX if (newWriter)  NS_ASSERTION( accessGranted == request->AccessRequested(), "why not?");
43113: 
43113:                 // entry->CreateDescriptor dequeues request, and queues descriptor
43113:                 nsICacheEntryDescriptor *descriptor = nsnull;
43113:                 rv = entry->CreateDescriptor(request,
43113:                                              accessGranted,
43113:                                              &descriptor);
43113: 
43113:                 // post call to listener to report error or descriptor
43113:                 rv = NotifyListener(request, descriptor, accessGranted, rv);
43113:                 delete request;
43113:                 if (NS_FAILED(rv)) {
43113:                     // XXX what to do?
43113:                 }
43113:                 
43113:             } else {
61109:                 // read-only request to an invalid entry - need to wait for
61109:                 // the entry to become valid so we post an event to process
61109:                 // the request again later (bug #467392)
61109:                 nsCOMPtr<nsIRunnable> ev =
61109:                     new nsProcessRequestEvent(request);
61109:                 rv = DispatchToCacheIOThread(ev);
61109:                 if (NS_FAILED(rv)) {
61109:                     delete request; // avoid leak
61109:                 }
43113:             }
43113:         } else {
43113: 
43113:             // Synchronous request
43113:             request->WakeUp();
43113:         }
43113:         if (newWriter)  break;  // process remaining requests after validation
43113:         request = nextRequest;
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::ClearPendingRequests(nsCacheEntry * entry)
43113: {
43113:     nsCacheRequest * request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);
43113:     
43113:     while (request != &entry->mRequestQ) {
43113:         nsCacheRequest * next = (nsCacheRequest *)PR_NEXT_LINK(request);
43113: 
43113:         // XXX we're just dropping these on the floor for now...definitely wrong.
43113:         PR_REMOVE_AND_INIT_LINK(request);
43113:         delete request;
43113:         request = next;
43113:     }
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::ClearDoomList()
43113: {
43113:     nsCacheEntry * entry = (nsCacheEntry *)PR_LIST_HEAD(&mDoomedEntries);
43113: 
43113:     while (entry != &mDoomedEntries) {
43113:         nsCacheEntry * next = (nsCacheEntry *)PR_NEXT_LINK(entry);
43113:         
43113:          entry->DetachDescriptors();
43113:          DeactivateEntry(entry);
43113:          entry = next;
43113:     }        
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::ClearActiveEntries()
43113: {
43113:     mActiveEntries.VisitEntries(DeactivateAndClearEntry, nsnull);
43113:     mActiveEntries.Shutdown();
43113: }
43113: 
43113: 
43113: PLDHashOperator
43113: nsCacheService::DeactivateAndClearEntry(PLDHashTable *    table,
43113:                                         PLDHashEntryHdr * hdr,
43113:                                         PRUint32          number,
43113:                                         void *            arg)
43113: {
43113:     nsCacheEntry * entry = ((nsCacheEntryHashTableEntry *)hdr)->cacheEntry;
43113:     NS_ASSERTION(entry, "### active entry = nsnull!");
56468:     // only called from Shutdown() so we don't worry about pending requests
43113:     gService->ClearPendingRequests(entry);
43113:     entry->DetachDescriptors();
43113:     
43113:     entry->MarkInactive();  // so we don't call Remove() while we're enumerating
43113:     gService->DeactivateEntry(entry);
43113:     
43113:     return PL_DHASH_REMOVE; // and continue enumerating
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::DoomActiveEntries()
43113: {
43113:     nsAutoTArray<nsCacheEntry*, 8> array;
43113: 
43113:     mActiveEntries.VisitEntries(RemoveActiveEntry, &array);
43113: 
43113:     PRUint32 count = array.Length();
43113:     for (PRUint32 i=0; i < count; ++i)
56468:         DoomEntry_Internal(array[i], true);
43113: }
43113: 
43113: 
43113: PLDHashOperator
43113: nsCacheService::RemoveActiveEntry(PLDHashTable *    table,
43113:                                   PLDHashEntryHdr * hdr,
43113:                                   PRUint32          number,
43113:                                   void *            arg)
43113: {
43113:     nsCacheEntry * entry = ((nsCacheEntryHashTableEntry *)hdr)->cacheEntry;
43113:     NS_ASSERTION(entry, "### active entry = nsnull!");
43113: 
43113:     nsTArray<nsCacheEntry*> * array = (nsTArray<nsCacheEntry*> *) arg;
43113:     NS_ASSERTION(array, "### array = nsnull!");
43113:     array->AppendElement(entry);
43113: 
43113:     // entry is being removed from the active entry list
43113:     entry->MarkInactive();
43113:     return PL_DHASH_REMOVE; // and continue enumerating
43113: }
43113: 
43113: 
43113: #if defined(PR_LOGGING)
43113: void
43113: nsCacheService::LogCacheStatistics()
43113: {
43113:     PRUint32 hitPercentage = (PRUint32)((((double)mCacheHits) /
43113:         ((double)(mCacheHits + mCacheMisses))) * 100);
43113:     CACHE_LOG_ALWAYS(("\nCache Service Statistics:\n\n"));
43113:     CACHE_LOG_ALWAYS(("    TotalEntries   = %d\n", mTotalEntries));
43113:     CACHE_LOG_ALWAYS(("    Cache Hits     = %d\n", mCacheHits));
43113:     CACHE_LOG_ALWAYS(("    Cache Misses   = %d\n", mCacheMisses));
43113:     CACHE_LOG_ALWAYS(("    Cache Hit %%    = %d%%\n", hitPercentage));
43113:     CACHE_LOG_ALWAYS(("    Max Key Length = %d\n", mMaxKeyLength));
43113:     CACHE_LOG_ALWAYS(("    Max Meta Size  = %d\n", mMaxMetaSize));
43113:     CACHE_LOG_ALWAYS(("    Max Data Size  = %d\n", mMaxDataSize));
43113:     CACHE_LOG_ALWAYS(("\n"));
43113:     CACHE_LOG_ALWAYS(("    Deactivate Failures         = %d\n",
43113:                       mDeactivateFailures));
43113:     CACHE_LOG_ALWAYS(("    Deactivated Unbound Entries = %d\n",
43113:                       mDeactivatedUnboundEntries));
43113: }
43113: #endif
43113: 
43113: 
43113: void
43113: nsCacheService::OnEnterExitPrivateBrowsing()
43113: {
43113:     if (!gService)  return;
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     gService->DoomActiveEntries();
43113: 
43113:     if (gService->mMemoryDevice) {
43113:         // clear memory cache
43113:         gService->mMemoryDevice->EvictEntries(nsnull);
43113:     }
43113: }
80586: 
80586: nsresult
86122: nsCacheService::SetDiskSmartSize()
80586: {
80586:     nsCacheServiceAutoLock lock;
80586: 
80586:     if (!gService) return NS_ERROR_NOT_AVAILABLE;
80586: 
86759:     return gService->SetDiskSmartSize_Locked();
80586: }
80586: 
80586: nsresult
86759: nsCacheService::SetDiskSmartSize_Locked()
80586: {
80586:     nsresult rv;
80586: 
80586:     if (!mObserver->DiskCacheParentDirectory())
80586:         return NS_ERROR_NOT_AVAILABLE;
80586: 
80586:     if (!mDiskDevice)
80586:         return NS_ERROR_NOT_AVAILABLE;
80586: 
86759:     if (!mObserver->SmartSizeEnabled())
80586:         return NS_ERROR_NOT_AVAILABLE;
80586: 
80586:     nsAutoString cachePath;
80586:     rv = mObserver->DiskCacheParentDirectory()->GetPath(cachePath);
80586:     if (NS_SUCCEEDED(rv)) {
80586:         nsCOMPtr<nsIRunnable> event =
80586:             new nsGetSmartSizeEvent(cachePath, mDiskDevice->getCacheSize());
80586:         DispatchToCacheIOThread(event);
80586:     } else {
80586:         return NS_ERROR_FAILURE;
80586:     }
80586: 
80586:     return NS_OK;
80586: }
