  7054: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
  7054:  *
 99778:  * This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
  7054: 
  7054: #include "nsRecentBadCerts.h"
  7054: #include "nsIX509Cert.h"
  7054: #include "nsSSLStatus.h"
  7054: #include "nsCOMPtr.h"
119832: #include "nsAutoPtr.h"
  7054: #include "nsNSSCertificate.h"
  7054: #include "nsCRT.h"
  7054: #include "nsPromiseFlatString.h"
  7054: #include "nsStringBuffer.h"
119832: #include "nsAutoPtr.h"
  7054: #include "nspr.h"
  7054: #include "pk11pub.h"
  7054: #include "certdb.h"
  7054: #include "sechash.h"
  7054: 
  7054: #include "nsNSSCleaner.h"
 64576: 
 64576: using namespace mozilla;
 64576: 
  7054: NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
  7054: 
  7054: NS_IMPL_THREADSAFE_ISUPPORTS1(nsRecentBadCertsService, 
  7054:                               nsIRecentBadCertsService)
  7054: 
  7054: nsRecentBadCertsService::nsRecentBadCertsService()
 64576: :monitor("nsRecentBadCertsService.monitor")
 64576: ,mNextStorePosition(0)
  7054: {
  7054: }
  7054: 
  7054: nsRecentBadCertsService::~nsRecentBadCertsService()
  7054: {
  7054: }
  7054: 
  7054: nsresult
  7054: nsRecentBadCertsService::Init()
  7054: {
  7054:   return NS_OK;
  7054: }
  7054: 
  7054: NS_IMETHODIMP
  7054: nsRecentBadCertsService::GetRecentBadCert(const nsAString & aHostNameWithPort, 
  7054:                                           nsISSLStatus **aStatus)
  7054: {
  7054:   NS_ENSURE_ARG_POINTER(aStatus);
  7054:   if (!aHostNameWithPort.Length())
  7054:     return NS_ERROR_INVALID_ARG;
  7054: 
106838:   *aStatus = nullptr;
119832:   nsRefPtr<nsSSLStatus> status = new nsSSLStatus();
119832:   if (!status)
119832:     return NS_ERROR_OUT_OF_MEMORY;
  7054: 
  7054:   SECItem foundDER;
  7054:   foundDER.len = 0;
106838:   foundDER.data = nullptr;
  7054: 
 79445:   bool isDomainMismatch = false;
 79445:   bool isNotValidAtThisTime = false;
 79445:   bool isUntrusted = false;
  7054: 
  7054:   {
 69142:     ReentrantMonitorAutoEnter lock(monitor);
  7054:     for (size_t i=0; i<const_recently_seen_list_size; ++i) {
  7054:       if (mCerts[i].mHostWithPort.Equals(aHostNameWithPort)) {
106838:         SECStatus srv = SECITEM_CopyItem(nullptr, &foundDER, &mCerts[i].mDERCert);
  7054:         if (srv != SECSuccess)
  7054:           return NS_ERROR_OUT_OF_MEMORY;
  7054: 
  7054:         isDomainMismatch = mCerts[i].isDomainMismatch;
  7054:         isNotValidAtThisTime = mCerts[i].isNotValidAtThisTime;
  7054:         isUntrusted = mCerts[i].isUntrusted;
  7054:       }
  7054:     }
  7054:   }
  7054: 
  7054:   if (foundDER.len) {
  7054:     CERTCertificate *nssCert;
  7054:     CERTCertDBHandle *certdb = CERT_GetDefaultCertDB();
  7054:     nssCert = CERT_FindCertByDERCert(certdb, &foundDER);
  7054:     if (!nssCert) 
  7054:       nssCert = CERT_NewTempCertificate(certdb, &foundDER,
106838:                                         nullptr, // no nickname
 80486:                                         false, // not perm
 80486:                                         true); // copy der
  7054: 
 80486:     SECITEM_FreeItem(&foundDER, false);
  7054: 
  7054:     if (!nssCert)
  7054:       return NS_ERROR_FAILURE;
  7054: 
 56495:     status->mServerCert = nsNSSCertificate::Create(nssCert);
  7054:     CERT_DestroyCertificate(nssCert);
  7054: 
 80486:     status->mHaveCertErrorBits = true;
  7054:     status->mIsDomainMismatch = isDomainMismatch;
  7054:     status->mIsNotValidAtThisTime = isNotValidAtThisTime;
  7054:     status->mIsUntrusted = isUntrusted;
  7054: 
  7054:     *aStatus = status;
  7054:     NS_IF_ADDREF(*aStatus);
  7054:   }
  7054: 
  7054:   return NS_OK;
  7054: }
  7054: 
  7054: NS_IMETHODIMP
  7054: nsRecentBadCertsService::AddBadCert(const nsAString &hostWithPort, 
  7054:                                     nsISSLStatus *aStatus)
  7054: {
  7054:   NS_ENSURE_ARG(aStatus);
  7054: 
  7054:   nsCOMPtr<nsIX509Cert> cert;
  7054:   nsresult rv;
  7054:   rv = aStatus->GetServerCert(getter_AddRefs(cert));
  7054:   NS_ENSURE_SUCCESS(rv, rv);
  7054: 
 79445:   bool isDomainMismatch;
 79445:   bool isNotValidAtThisTime;
 79445:   bool isUntrusted;
  7054: 
  7054:   rv = aStatus->GetIsDomainMismatch(&isDomainMismatch);
  7054:   NS_ENSURE_SUCCESS(rv, rv);
  7054: 
  7054:   rv = aStatus->GetIsNotValidAtThisTime(&isNotValidAtThisTime);
  7054:   NS_ENSURE_SUCCESS(rv, rv);
  7054: 
  7054:   rv = aStatus->GetIsUntrusted(&isUntrusted);
  7054:   NS_ENSURE_SUCCESS(rv, rv);
  7054: 
  7054:   SECItem tempItem;
108991:   rv = cert->GetRawDER(&tempItem.len, (uint8_t **)&tempItem.data);
  7054:   NS_ENSURE_SUCCESS(rv, rv);
  7054: 
  7054:   {
 69142:     ReentrantMonitorAutoEnter lock(monitor);
  7054:     RecentBadCert &updatedEntry = mCerts[mNextStorePosition];
  7054: 
  7054:     ++mNextStorePosition;
  7054:     if (mNextStorePosition == const_recently_seen_list_size)
  7054:       mNextStorePosition = 0;
  7054: 
  7054:     updatedEntry.Clear();
  7054:     updatedEntry.mHostWithPort = hostWithPort;
  7054:     updatedEntry.mDERCert = tempItem; // consume
  7054:     updatedEntry.isDomainMismatch = isDomainMismatch;
  7054:     updatedEntry.isNotValidAtThisTime = isNotValidAtThisTime;
  7054:     updatedEntry.isUntrusted = isUntrusted;
  7054:   }
  7054: 
  7054:   return NS_OK;
  7054: }
