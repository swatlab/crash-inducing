    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef __editor_h__
    1: #define __editor_h__
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsWeakReference.h"
    1: 
    1: #include "nsIEditor.h"
    1: #include "nsIEditorIMESupport.h"
    1: #include "nsIPhonetic.h"
    1: 
    1: #include "nsIAtom.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsISelection.h"
    1: #include "nsIDOMCharacterData.h"
    1: #include "nsIPrivateTextRange.h"
    1: #include "nsITransactionManager.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsCOMArray.h"
    1: #include "nsIEditActionListener.h"
    1: #include "nsIEditorObserver.h"
    1: #include "nsIDocumentStateListener.h"
    1: #include "nsICSSStyleSheet.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsSelectionState.h"
    1: #include "nsIEditorSpellCheck.h"
    1: #include "nsIInlineSpellChecker.h"
 1418: #include "nsPIDOMEventTarget.h"
 6601: #include "nsStubMutationObserver.h"
10730: #include "nsIViewManager.h"
28153: #include "nsCycleCollectionParticipant.h"
    1: 
    1: class nsIDOMCharacterData;
    1: class nsIDOMRange;
    1: class nsIPresShell;
    1: class ChangeAttributeTxn;
    1: class CreateElementTxn;
    1: class InsertElementTxn;
    1: class DeleteElementTxn;
    1: class InsertTextTxn;
    1: class DeleteTextTxn;
    1: class SplitElementTxn;
    1: class JoinElementTxn;
    1: class EditAggregateTxn;
    1: class IMETextTxn;
    1: class AddStyleSheetTxn;
    1: class RemoveStyleSheetTxn;
    1: class nsIFile;
    1: class nsISelectionController;
 1418: class nsIDOMEventTarget;
    1: 
    1: #define kMOZEditorBogusNodeAttr NS_LITERAL_STRING("_moz_editor_bogus_node")
    1: #define kMOZEditorBogusNodeValue NS_LITERAL_STRING("TRUE")
    1: 
    1: /** implementation of an editor object.  it will be the controller/focal point 
    1:  *  for the main editor services. i.e. the GUIManager, publishing, transaction 
    1:  *  manager, event interfaces. the idea for the event interfaces is to have them 
    1:  *  delegate the actual commands to the editor independent of the XPFE implementation.
    1:  */
    1: class nsEditor : public nsIEditor,
    1:                  public nsIEditorIMESupport,
    1:                  public nsSupportsWeakReference,
 6601:                  public nsIPhonetic,
 6601:                  public nsStubMutationObserver
    1: {
    1: public:
    1: 
    1:   enum IterDirection
    1:   {
    1:     kIterForward,
    1:     kIterBackward
    1:   };
    1: 
    1:   enum OperationID
    1:   {
    1:     kOpIgnore = -1,
    1:     kOpNone = 0,
    1:     kOpUndo,
    1:     kOpRedo,
    1:     kOpInsertNode,
    1:     kOpCreateNode,
    1:     kOpDeleteNode,
    1:     kOpSplitNode,
    1:     kOpJoinNode,
    1:     kOpDeleteSelection,
    1:     // text commands
    1:     kOpInsertBreak    = 1000,
    1:     kOpInsertText     = 1001,
    1:     kOpInsertIMEText  = 1002,
    1:     kOpDeleteText     = 1003
    1:   };
    1: 
    1:   /** The default constructor. This should suffice. the setting of the interfaces is done
    1:    *  after the construction of the editor class.
    1:    */
    1:   nsEditor();
    1:   /** The default destructor. This should suffice. Should this be pure virtual 
    1:    *  for someone to derive from the nsEditor later? I don't believe so.
    1:    */
    1:   virtual ~nsEditor();
    1: 
    1: //Interfaces for addref and release and queryinterface
    1: //NOTE: Use   NS_DECL_ISUPPORTS_INHERITED in any class inherited from nsEditor
28153:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
28153:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsEditor,
28153:                                            nsIEditor)
    1: 
    1:   /* ------------ utility methods   -------------- */
    1:   NS_IMETHOD GetPresShell(nsIPresShell **aPS);
    1:   void NotifyEditorObservers(void);
    1: 
    1:   /* ------------ nsIEditor methods -------------- */
    1:   NS_DECL_NSIEDITOR
    1:   /* ------------ nsIEditorIMESupport methods -------------- */
    1:   NS_DECL_NSIEDITORIMESUPPORT
    1:   
    1:   // nsIPhonetic
    1:   NS_DECL_NSIPHONETIC
    1: 
 6601:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
 6601:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
 6601:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
    1: 
    1: public:
    1: 
    1:   
    1:   NS_IMETHOD InsertTextImpl(const nsAString& aStringToInsert, 
    1:                                nsCOMPtr<nsIDOMNode> *aInOutNode, 
    1:                                PRInt32 *aInOutOffset,
    1:                                nsIDOMDocument *aDoc);
37130:   nsresult InsertTextIntoTextNodeImpl(const nsAString& aStringToInsert, 
    1:                                       nsIDOMCharacterData *aTextNode, 
37130:                                       PRInt32 aOffset,
37130:                                       PRBool aSuppressIME = PR_FALSE);
    1:   NS_IMETHOD DeleteSelectionImpl(EDirection aAction);
    1:   NS_IMETHOD DeleteSelectionAndCreateNode(const nsAString& aTag,
    1:                                            nsIDOMNode ** aNewNode);
    1: 
    1:   /* helper routines for node/parent manipulations */
    1:   nsresult ReplaceContainer(nsIDOMNode *inNode, 
    1:                             nsCOMPtr<nsIDOMNode> *outNode, 
    1:                             const nsAString &aNodeType,
    1:                             const nsAString *aAttribute = nsnull,
    1:                             const nsAString *aValue = nsnull,
    1:                             PRBool aCloneAttributes = PR_FALSE);
    1: 
    1:   nsresult RemoveContainer(nsIDOMNode *inNode);
    1:   nsresult InsertContainerAbove(nsIDOMNode *inNode, 
    1:                                 nsCOMPtr<nsIDOMNode> *outNode, 
    1:                                 const nsAString &aNodeType,
    1:                                 const nsAString *aAttribute = nsnull,
    1:                                 const nsAString *aValue = nsnull);
    1:   nsresult MoveNode(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aOffset);
    1: 
    1:   /* Method to replace certain CreateElementNS() calls. 
    1:      Arguments:
    1:       nsString& aTag          - tag you want
    1:       nsIContent** aContent   - returned Content that was created with above namespace.
    1:   */
    1:   nsresult CreateHTMLContent(const nsAString& aTag, nsIContent** aContent);
    1: 
    1: protected:
    1:   nsCString mContentMIMEType;       // MIME type of the doc we are editing.
    1: 
    1:   /** create a transaction for setting aAttribute to aValue on aElement
    1:     */
    1:   NS_IMETHOD CreateTxnForSetAttribute(nsIDOMElement *aElement, 
    1:                                       const nsAString &  aAttribute, 
    1:                                       const nsAString &  aValue,
    1:                                       ChangeAttributeTxn ** aTxn);
    1: 
    1:   /** create a transaction for removing aAttribute on aElement
    1:     */
    1:   NS_IMETHOD CreateTxnForRemoveAttribute(nsIDOMElement *aElement, 
    1:                                          const nsAString &  aAttribute,
    1:                                          ChangeAttributeTxn ** aTxn);
    1: 
    1:   /** create a transaction for creating a new child node of aParent of type aTag.
    1:     */
    1:   NS_IMETHOD CreateTxnForCreateElement(const nsAString & aTag,
    1:                                        nsIDOMNode     *aParent,
    1:                                        PRInt32         aPosition,
    1:                                        CreateElementTxn ** aTxn);
    1: 
    1:   /** create a transaction for inserting aNode as a child of aParent.
    1:     */
    1:   NS_IMETHOD CreateTxnForInsertElement(nsIDOMNode * aNode,
    1:                                        nsIDOMNode * aParent,
    1:                                        PRInt32      aOffset,
    1:                                        InsertElementTxn ** aTxn);
    1: 
    1:   /** create a transaction for removing aElement from its parent.
    1:     */
    1:   NS_IMETHOD CreateTxnForDeleteElement(nsIDOMNode * aElement,
    1:                                        DeleteElementTxn ** aTxn);
    1: 
    1: 
    1:   NS_IMETHOD CreateTxnForDeleteSelection(EDirection aAction,
    1:                                          EditAggregateTxn ** aTxn,
    1:                                          nsIDOMNode ** aNode,
    1:                                          PRInt32 *aOffset,
    1:                                          PRInt32 *aLength);
    1: 
    1:   NS_IMETHOD CreateTxnForDeleteInsertionPoint(nsIDOMRange         *aRange, 
    1:                                               EDirection aAction, 
    1:                                               EditAggregateTxn *aTxn,
    1:                                               nsIDOMNode ** aNode,
    1:                                               PRInt32 *aOffset,
    1:                                               PRInt32 *aLength);
    1: 
    1: 
    1:   /** create a transaction for inserting aStringToInsert into aTextNode
    1:     * if aTextNode is null, the string is inserted at the current selection.
    1:     */
    1:   NS_IMETHOD CreateTxnForInsertText(const nsAString & aStringToInsert,
    1:                                     nsIDOMCharacterData *aTextNode,
    1:                                     PRInt32 aOffset,
    1:                                     InsertTextTxn ** aTxn);
    1: 
    1:   NS_IMETHOD CreateTxnForIMEText(const nsAString & aStringToInsert,
    1:                                  IMETextTxn ** aTxn);
    1: 
    1:   /** create a transaction for adding a style sheet
    1:     */
    1:   NS_IMETHOD CreateTxnForAddStyleSheet(nsICSSStyleSheet* aSheet, AddStyleSheetTxn* *aTxn);
    1: 
    1:   /** create a transaction for removing a style sheet
    1:     */
    1:   NS_IMETHOD CreateTxnForRemoveStyleSheet(nsICSSStyleSheet* aSheet, RemoveStyleSheetTxn* *aTxn);
    1:   
    1:   NS_IMETHOD DeleteText(nsIDOMCharacterData *aElement,
    1:                         PRUint32             aOffset,
    1:                         PRUint32             aLength);
    1: 
    1: //  NS_IMETHOD DeleteRange(nsIDOMRange *aRange);
    1: 
    1:   NS_IMETHOD CreateTxnForDeleteText(nsIDOMCharacterData *aElement,
    1:                                     PRUint32             aOffset,
    1:                                     PRUint32             aLength,
    1:                                     DeleteTextTxn      **aTxn);
    1: 
    1:   nsresult CreateTxnForDeleteCharacter(nsIDOMCharacterData  *aData,
    1:                                        PRUint32              aOffset,
    1:                                        nsIEditor::EDirection aDirection,
    1:                                        DeleteTextTxn       **aTxn);
    1: 	
    1:   NS_IMETHOD CreateTxnForSplitNode(nsIDOMNode *aNode,
    1:                                    PRUint32    aOffset,
    1:                                    SplitElementTxn **aTxn);
    1: 
    1:   NS_IMETHOD CreateTxnForJoinNode(nsIDOMNode  *aLeftNode,
    1:                                   nsIDOMNode  *aRightNode,
    1:                                   JoinElementTxn **aTxn);
    1: 
    1:   NS_IMETHOD DeleteSelectionAndPrepareToCreateNode(nsCOMPtr<nsIDOMNode> &parentSelectedNode, 
    1:                                                    PRInt32& offsetOfNewNode);
    1: 
    1:   // called after a transaction is done successfully
    1:   NS_IMETHOD DoAfterDoTransaction(nsITransaction *aTxn);
    1:   // called after a transaction is undone successfully
    1:   NS_IMETHOD DoAfterUndoTransaction();
    1:   // called after a transaction is redone successfully
    1:   NS_IMETHOD DoAfterRedoTransaction();
    1: 
    1:   typedef enum {
    1:     eDocumentCreated,
    1:     eDocumentToBeDestroyed,
    1:     eDocumentStateChanged
    1:   } TDocumentListenerNotification;
    1:   
    1:   // tell the doc state listeners that the doc state has changed
    1:   NS_IMETHOD NotifyDocumentListeners(TDocumentListenerNotification aNotificationType);
    1:   
    1:   /** make the given selection span the entire document */
    1:   NS_IMETHOD SelectEntireDocument(nsISelection *aSelection);
    1: 
    1:   /* Helper for output routines -- we expect subclasses to override this */
    1:   NS_IMETHOD GetWrapWidth(PRInt32* aWrapCol);
    1: 
    1:   /** helper method for scrolling the selection into view after
    1:    *  an edit operation. aScrollToAnchor should be PR_TRUE if you
    1:    *  want to scroll to the point where the selection was started.
    1:    *  If PR_FALSE, it attempts to scroll the end of the selection into view.
    1:    *
    1:    *  Editor methods *should* call this method instead of the versions
    1:    *  in the various selection interfaces, since this version makes sure
    1:    *  that the editor's sync/async settings for reflowing, painting, and
    1:    *  scrolling match.
    1:    */
    1:   NS_IMETHOD ScrollSelectionIntoView(PRBool aScrollToAnchor);
    1: 
    1:   // stub.  see comment in source.                     
    1:   virtual PRBool IsBlockNode(nsIDOMNode *aNode);
    1:   
    1:   // helper for GetPriorNode
    1:   nsresult GetPriorNodeImpl(nsIDOMNode  *aCurrentNode, 
    1:                             PRBool       aEditableNode,
    1:                             nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                             PRBool       bNoBlockCrossing = PR_FALSE);
    1: 
    1:   // helper for GetNextNode
    1:   nsresult GetNextNodeImpl(nsIDOMNode  *aCurrentNode, 
    1:                            PRBool       aEditableNode,
    1:                            nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                            PRBool       bNoBlockCrossing = PR_FALSE);
    1: 
15919:   // Get nsIWidget interface
15919:   nsresult GetWidget(nsIWidget **aWidget);
    1: 
    1: 
    1:   // install the event listeners for the editor 
    1:   nsresult InstallEventListeners();
    1: 
    1:   virtual nsresult CreateEventListeners() = 0;
    1: 
    1:   // unregister and release our event listeners
    1:   virtual void RemoveEventListeners();
    1: 
    1:   /**
    1:    * Return true if spellchecking should be enabled for this editor.
    1:    */
    1:   PRBool GetDesiredSpellCheckState();
    1: 
34903:   nsresult QueryComposition(nsTextEventReply* aReply);
34903: 
    1: public:
    1: 
    1:   /** All editor operations which alter the doc should be prefaced
    1:    *  with a call to StartOperation, naming the action and direction */
    1:   NS_IMETHOD StartOperation(PRInt32 opID, nsIEditor::EDirection aDirection);
    1: 
    1:   /** All editor operations which alter the doc should be followed
    1:    *  with a call to EndOperation */
    1:   NS_IMETHOD EndOperation();
    1: 
    1:   /** routines for managing the preservation of selection across 
    1:    *  various editor actions */
    1:   PRBool   ArePreservingSelection();
    1:   nsresult PreserveSelectionAcrossActions(nsISelection *aSel);
    1:   nsresult RestorePreservedSelection(nsISelection *aSel);
    1:   void     StopPreservingSelection();
    1: 
    1:   /** 
    1:    * SplitNode() creates a new node identical to an existing node, and split the contents between the two nodes
    1:    * @param aExistingRightNode   the node to split.  It will become the new node's next sibling.
    1:    * @param aOffset              the offset of aExistingRightNode's content|children to do the split at
    1:    * @param aNewLeftNode         [OUT] the new node resulting from the split, becomes aExistingRightNode's previous sibling.
    1:    * @param aParent              the parent of aExistingRightNode
    1:    */
    1:   nsresult SplitNodeImpl(nsIDOMNode *aExistingRightNode,
    1:                          PRInt32     aOffset,
    1:                          nsIDOMNode *aNewLeftNode,
    1:                          nsIDOMNode *aParent);
    1: 
    1:   /** 
    1:    * JoinNodes() takes 2 nodes and merge their content|children.
    1:    * @param aNodeToKeep   The node that will remain after the join.
    1:    * @param aNodeToJoin   The node that will be joined with aNodeToKeep.
    1:    *                      There is no requirement that the two nodes be of the same type.
    1:    * @param aParent       The parent of aNodeToKeep
    1:    * @param aNodeToKeepIsFirst  if PR_TRUE, the contents|children of aNodeToKeep come before the
    1:    *                            contents|children of aNodeToJoin, otherwise their positions are switched.
    1:    */
    1:   nsresult JoinNodesImpl(nsIDOMNode *aNodeToKeep,
    1:                          nsIDOMNode *aNodeToJoin,
    1:                          nsIDOMNode *aParent,
    1:                          PRBool      aNodeToKeepIsFirst);
    1: 
    1:   /**
    1:    *  Set aOffset to the offset of aChild in aParent.  
    1:    *  Returns an error if aChild is not an immediate child of aParent.
    1:    */
    1:   static nsresult GetChildOffset(nsIDOMNode *aChild, 
    1:                                  nsIDOMNode *aParent, 
    1:                                  PRInt32    &aOffset);
    1: 
    1:   /**
    1:    *  Set aParent to the parent of aChild.
    1:    *  Set aOffset to the offset of aChild in aParent.  
    1:    */
    1:   static nsresult GetNodeLocation(nsIDOMNode *aChild, 
    1:                                  nsCOMPtr<nsIDOMNode> *aParent, 
    1:                                  PRInt32    *aOffset);
    1: 
    1:   /** returns the number of things inside aNode in the out-param aCount.  
    1:     * @param  aNode is the node to get the length of.  
    1:     *         If aNode is text, returns number of characters. 
    1:     *         If not, returns number of children nodes.
    1:     * @param  aCount [OUT] the result of the above calculation.
    1:     */
    1:   static nsresult GetLengthOfDOMNode(nsIDOMNode *aNode, PRUint32 &aCount);
    1: 
    1:   /** get the node immediately prior to aCurrentNode
    1:     * @param aCurrentNode   the node from which we start the search
    1:     * @param aEditableNode  if PR_TRUE, only return an editable node
    1:     * @param aResultNode    [OUT] the node that occurs before aCurrentNode in the tree,
    1:     *                       skipping non-editable nodes if aEditableNode is PR_TRUE.
    1:     *                       If there is no prior node, aResultNode will be nsnull.
    1:     */
    1:   nsresult GetPriorNode(nsIDOMNode  *aCurrentNode, 
    1:                         PRBool       aEditableNode,
    1:                         nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                         PRBool       bNoBlockCrossing = PR_FALSE);
    1: 
    1:   // and another version that takes a {parent,offset} pair rather than a node
    1:   nsresult GetPriorNode(nsIDOMNode  *aParentNode, 
    1:                         PRInt32      aOffset, 
    1:                         PRBool       aEditableNode, 
    1:                         nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                         PRBool       bNoBlockCrossing = PR_FALSE);
    1:                        
    1:   /** get the node immediately after to aCurrentNode
    1:     * @param aCurrentNode   the node from which we start the search
    1:     * @param aEditableNode  if PR_TRUE, only return an editable node
    1:     * @param aResultNode    [OUT] the node that occurs after aCurrentNode in the tree,
    1:     *                       skipping non-editable nodes if aEditableNode is PR_TRUE.
    1:     *                       If there is no prior node, aResultNode will be nsnull.
    1:     */
    1:   nsresult GetNextNode(nsIDOMNode  *aCurrentNode, 
    1:                        PRBool       aEditableNode,
    1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                        PRBool       bNoBlockCrossing = PR_FALSE);
    1: 
    1:   // and another version that takes a {parent,offset} pair rather than a node
    1:   nsresult GetNextNode(nsIDOMNode  *aParentNode, 
    1:                        PRInt32      aOffset, 
    1:                        PRBool       aEditableNode, 
    1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                        PRBool       bNoBlockCrossing = PR_FALSE);
    1: 
    1:   /** Get the rightmost child of aCurrentNode;
    1:     * return nsnull if aCurrentNode has no children.
    1:     */
    1:   nsCOMPtr<nsIDOMNode> GetRightmostChild(nsIDOMNode *aCurrentNode, 
    1:                                          PRBool      bNoBlockCrossing = PR_FALSE);
    1: 
    1:   /** Get the leftmost child of aCurrentNode;
    1:     * return nsnull if aCurrentNode has no children.
    1:     */
    1:   nsCOMPtr<nsIDOMNode> GetLeftmostChild(nsIDOMNode  *aCurrentNode, 
    1:                                          PRBool      bNoBlockCrossing = PR_FALSE);
    1: 
    1:   /** returns PR_TRUE if aNode is of the type implied by aTag */
    1:   static inline PRBool NodeIsType(nsIDOMNode *aNode, nsIAtom *aTag)
    1:   {
    1:     return GetTag(aNode) == aTag;
    1:   }
    1: 
    1:   // we should get rid of this method if we can
    1:   static inline PRBool NodeIsTypeString(nsIDOMNode *aNode, const nsAString &aTag)
    1:   {
    1:     nsIAtom *nodeAtom = GetTag(aNode);
    1:     return nodeAtom && nodeAtom->Equals(aTag);
    1:   }
    1: 
    1: 
    1:   /** returns PR_TRUE if aParent can contain a child of type aTag */
    1:   PRBool CanContainTag(nsIDOMNode* aParent, const nsAString &aTag);
    1:   PRBool TagCanContain(const nsAString &aParentTag, nsIDOMNode* aChild);
    1:   virtual PRBool TagCanContainTag(const nsAString &aParentTag, const nsAString &aChildTag);
    1: 
    1:   /** returns PR_TRUE if aNode is our root node */
    1:   PRBool IsRootNode(nsIDOMNode *inNode);
    1: 
    1:   /** returns PR_TRUE if aNode is a descendant of our root node */
    1:   PRBool IsDescendantOfBody(nsIDOMNode *inNode);
    1: 
    1:   /** returns PR_TRUE if aNode is a container */
    1:   virtual PRBool IsContainer(nsIDOMNode *aNode);
    1: 
    1:   /** returns PR_TRUE if aNode is an editable node */
    1:   PRBool IsEditable(nsIDOMNode *aNode);
    1: 
    1:   virtual PRBool IsTextInDirtyFrameVisible(nsIDOMNode *aNode);
    1: 
    1:   /** returns PR_TRUE if aNode is a MozEditorBogus node */
    1:   PRBool IsMozEditorBogusNode(nsIDOMNode *aNode);
    1: 
    1:   /** counts number of editable child nodes */
    1:   nsresult CountEditableChildren(nsIDOMNode *aNode, PRUint32 &outCount);
    1:   
    1:   /** Find the deep first and last children. Returned nodes are AddReffed */
    1:   nsresult GetFirstEditableNode(nsIDOMNode *aRoot, nsCOMPtr<nsIDOMNode> *outFirstNode);
    1: #ifdef XXX_DEAD_CODE
    1:   nsresult GetLastEditableNode(nsIDOMNode *aRoot, nsCOMPtr<nsIDOMNode> *outLastNode);
    1: #endif
    1: 
    1:   nsresult GetIMEBufferLength(PRInt32* length);
    1:   PRBool   IsIMEComposing();    /* test if IME is in composition state */
    1:   void     SetIsIMEComposing(); /* call this before |IsIMEComposing()| */
    1: 
    1:   /** from html rules code - migration in progress */
    1:   static nsresult GetTagString(nsIDOMNode *aNode, nsAString& outString);
    1:   static nsIAtom *GetTag(nsIDOMNode *aNode);
    1:   virtual PRBool NodesSameType(nsIDOMNode *aNode1, nsIDOMNode *aNode2);
    1:   static PRBool IsTextOrElementNode(nsIDOMNode *aNode);
    1:   static PRBool IsTextNode(nsIDOMNode *aNode);
    1:   
    1:   static PRInt32 GetIndexOf(nsIDOMNode *aParent, nsIDOMNode *aChild);
    1:   static nsCOMPtr<nsIDOMNode> GetChildAt(nsIDOMNode *aParent, PRInt32 aOffset);
    1:   
    1:   static nsresult GetStartNodeAndOffset(nsISelection *aSelection, nsCOMPtr<nsIDOMNode> *outStartNode, PRInt32 *outStartOffset);
    1:   static nsresult GetEndNodeAndOffset(nsISelection *aSelection, nsCOMPtr<nsIDOMNode> *outEndNode, PRInt32 *outEndOffset);
    1: #if DEBUG_JOE
    1:   static void DumpNode(nsIDOMNode *aNode, PRInt32 indent=0);
    1: #endif
    1: 
    1:   // Helpers to add a node to the selection. 
    1:   // Used by table cell selection methods
    1:   nsresult CreateRange(nsIDOMNode *aStartParent, PRInt32 aStartOffset,
    1:                        nsIDOMNode *aEndParent, PRInt32 aEndOffset,
    1:                        nsIDOMRange **aRange);
    1: 
    1:   // Creates a range with just the supplied node and appends that to the selection
    1:   nsresult AppendNodeToSelectionAsRange(nsIDOMNode *aNode);
    1:   // When you are using AppendNodeToSelectionAsRange, call this first to start a new selection
    1:   nsresult ClearSelection();
    1: 
    1:   nsresult IsPreformatted(nsIDOMNode *aNode, PRBool *aResult);
    1: 
    1:   nsresult SplitNodeDeep(nsIDOMNode *aNode, 
    1:                          nsIDOMNode *aSplitPointParent, 
    1:                          PRInt32 aSplitPointOffset,
    1:                          PRInt32 *outOffset,
    1:                          PRBool  aNoEmptyContainers = PR_FALSE,
    1:                          nsCOMPtr<nsIDOMNode> *outLeftNode = 0,
    1:                          nsCOMPtr<nsIDOMNode> *outRightNode = 0);
    1:   nsresult JoinNodeDeep(nsIDOMNode *aLeftNode, nsIDOMNode *aRightNode, nsCOMPtr<nsIDOMNode> *aOutJoinNode, PRInt32 *outOffset); 
    1: 
    1:   nsresult GetString(const nsAString& name, nsAString& value);
    1: 
    1:   nsresult BeginUpdateViewBatch(void);
    1:   virtual nsresult EndUpdateViewBatch(void);
    1: 
    1:   PRBool GetShouldTxnSetSelection();
    1: 
    1:   nsresult HandleInlineSpellCheck(PRInt32 action,
    1:                                     nsISelection *aSelection,
    1:                                     nsIDOMNode *previousSelectedNode,
    1:                                     PRInt32 previousSelectedOffset,
    1:                                     nsIDOMNode *aStartNode,
    1:                                     PRInt32 aStartOffset,
    1:                                     nsIDOMNode *aEndNode,
    1:                                     PRInt32 aEndOffset);
    1: 
 1418:   already_AddRefed<nsPIDOMEventTarget> GetPIDOMEventTarget();
    1: 
    1:   // Fast non-refcounting editor root element accessor
    1:   nsIDOMElement *GetRoot();
    1: 
    1: protected:
    1: 
    1:   PRUint32        mModCount;		// number of modifications (for undo/redo stack)
    1:   PRUint32        mFlags;		// behavior flags. See nsIPlaintextEditor.idl for the flags we use.
    1:   
    1:   nsWeakPtr       mPresShellWeak;   // weak reference to the nsIPresShell
    1:   nsWeakPtr       mSelConWeak;   // weak reference to the nsISelectionController
    1:   nsIViewManager *mViewManager;
    1:   PRInt32         mUpdateCount;
10730:   nsIViewManager::UpdateViewBatch mBatch;
    1: 
    1:   // Spellchecking
    1:   enum Tristate {
    1:     eTriUnset,
    1:     eTriFalse,
    1:     eTriTrue
    1:   }                 mSpellcheckCheckboxState;
    1:   nsCOMPtr<nsIInlineSpellChecker> mInlineSpellChecker;
    1: 
    1:   nsCOMPtr<nsITransactionManager> mTxnMgr;
    1:   nsWeakPtr         mPlaceHolderTxn;     // weak reference to placeholder for begin/end batch purposes
    1:   nsIAtom          *mPlaceHolderName;    // name of placeholder transaction
    1:   PRInt32           mPlaceHolderBatch;   // nesting count for batching
    1:   nsSelectionState *mSelState;           // saved selection state for placeholder txn batching
    1:   nsSelectionState  mSavedSel;           // cached selection for nsAutoSelectionReset
    1:   nsRangeUpdater    mRangeUpdater;       // utility class object for maintaining preserved ranges
    1:   nsCOMPtr<nsIDOMElement> mRootElement;    // cached root node
    1:   PRInt32           mAction;             // the current editor action
    1:   EDirection        mDirection;          // the current direction of editor action
    1:   
    1:   // data necessary to build IME transactions
    1:   nsCOMPtr<nsIPrivateTextRangeList> mIMETextRangeList; // IME special selection ranges
    1:   nsCOMPtr<nsIDOMCharacterData>     mIMETextNode;      // current IME text node
    1:   PRUint32                          mIMETextOffset;    // offset in text node where IME comp string begins
    1:   PRUint32                          mIMEBufferLength;  // current length of IME comp string
    1:   PRPackedBool                      mInIMEMode;        // are we inside an IME composition?
    1:   PRPackedBool                      mIsIMEComposing;   // is IME in composition state?
    1:                                                        // This is different from mInIMEMode. see Bug 98434.
    1: 
    1:   PRPackedBool                  mShouldTxnSetSelection;  // turn off for conservative selection adjustment by txns
    1:   PRPackedBool                  mDidPreDestroy;    // whether PreDestroy has been called
    1:    // various listeners
    1:   nsCOMArray<nsIEditActionListener> mActionListeners;  // listens to all low level actions on the doc
    1:   nsCOMArray<nsIEditorObserver> mEditorObservers;  // just notify once per high level change
    1:   nsCOMArray<nsIDocumentStateListener> mDocStateListeners;// listen to overall doc state (dirty or not, just created, etc)
    1: 
    1:   PRInt8                        mDocDirtyState;		// -1 = not initialized
    1:   nsWeakPtr        mDocWeak;  // weak reference to the nsIDOMDocument
    1:   // The form field as an event receiver
 1418:   nsCOMPtr<nsPIDOMEventTarget> mEventTarget;
    1: 
    1:   nsString* mPhonetic;
    1: 
    1:   nsCOMPtr<nsIDOMEventListener> mKeyListenerP;
    1:   nsCOMPtr<nsIDOMEventListener> mMouseListenerP;
    1:   nsCOMPtr<nsIDOMEventListener> mTextListenerP;
    1:   nsCOMPtr<nsIDOMEventListener> mCompositionListenerP;
    1:   nsCOMPtr<nsIDOMEventListener> mDragListenerP;
    1:   nsCOMPtr<nsIDOMEventListener> mFocusListenerP;
    1: 
    1:   friend PRBool NSCanUnload(nsISupports* serviceMgr);
    1:   friend class nsAutoTxnsConserveSelection;
    1:   friend class nsAutoSelectionReset;
    1:   friend class nsAutoRules;
    1:   friend class nsRangeUpdater;
    1: };
    1: 
    1: 
    1: #endif
