    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Bandhauer <jband@netscape.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* Per JSRuntime object */
    1: 
    1: #include "xpcprivate.h"
    1: 
    1: /***************************************************************************/
    1: 
    1: const char* XPCJSRuntime::mStrings[] = {
    1:     "constructor",          // IDX_CONSTRUCTOR
    1:     "toString",             // IDX_TO_STRING
    1:     "toSource",             // IDX_TO_SOURCE
    1:     "lastResult",           // IDX_LAST_RESULT
    1:     "returnCode",           // IDX_RETURN_CODE
    1:     "value",                // IDX_VALUE
    1:     "QueryInterface",       // IDX_QUERY_INTERFACE
    1:     "Components",           // IDX_COMPONENTS
    1:     "wrappedJSObject",      // IDX_WRAPPED_JSOBJECT
    1:     "Object",               // IDX_OBJECT
    1:     "Function",             // IDX_FUNCTION
    1:     "prototype",            // IDX_PROTOTYPE
    1:     "createInstance",       // IDX_CREATE_INSTANCE
 6464:     "item",                 // IDX_ITEM
 6464:     "__proto__",            // IDX_PROTO
 6464:     "__iterator__"          // IDX_ITERATOR
    1: #ifdef XPC_IDISPATCH_SUPPORT
    1:     , "GeckoActiveXObject"  // IDX_ACTIVEX_OBJECT
    1:     , "COMObject"           // IDX_COMOBJECT
    1:     , "supports"            // IDX_ACTIVEX_SUPPORTS
    1: #endif
    1: };
    1: 
    1: /***************************************************************************/
    1: 
    1: // data holder class for the enumerator callback below
    1: struct JSDyingJSObjectData
    1: {
    1:     JSContext* cx;
    1:     nsVoidArray* array;
    1: };
    1: 
18907: static JSDHashOperator
    1: WrappedJSDyingJSObjectFinder(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                 uint32 number, void *arg)
    1: {
    1:     JSDyingJSObjectData* data = (JSDyingJSObjectData*) arg;
    1:     nsXPCWrappedJS* wrapper = ((JSObject2WrappedJSMap::Entry*)hdr)->value;
    1:     NS_ASSERTION(wrapper, "found a null JS wrapper!");
    1: 
    1:     // walk the wrapper chain and find any whose JSObject is to be finalized
    1:     while(wrapper)
    1:     {
    1:         if(wrapper->IsSubjectToFinalization())
    1:         {
    1:             if(JS_IsAboutToBeFinalized(data->cx, wrapper->GetJSObject()))
    1:                 data->array->AppendElement(wrapper);
    1:         }
    1:         wrapper = wrapper->GetNextWrapper();
    1:     }
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: struct CX_AND_XPCRT_Data
    1: {
    1:     JSContext* cx;
    1:     XPCJSRuntime* rt;
    1: };
    1: 
18907: static JSDHashOperator
    1: NativeInterfaceGC(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                   uint32 number, void *arg)
    1: {
    1:     CX_AND_XPCRT_Data* data = (CX_AND_XPCRT_Data*) arg;
    1:     ((IID2NativeInterfaceMap::Entry*)hdr)->value->
    1:             DealWithDyingGCThings(data->cx, data->rt);
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
18907: static JSDHashOperator
    1: NativeInterfaceSweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                        uint32 number, void *arg)
    1: {
    1:     CX_AND_XPCRT_Data* data = (CX_AND_XPCRT_Data*) arg;
    1:     XPCNativeInterface* iface = ((IID2NativeInterfaceMap::Entry*)hdr)->value;
    1:     if(iface->IsMarked())
    1:     {
    1:         iface->Unmark();
    1:         return JS_DHASH_NEXT;
    1:     }
    1: 
    1: #ifdef XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING
    1:     printf("- Destroying XPCNativeInterface for %s\n",
    1:             JS_GetStringBytes(JSVAL_TO_STRING(iface->GetName())));
    1: #endif
    1: 
    1:     XPCNativeInterface::DestroyInstance(data->cx, data->rt, iface);
    1:     return JS_DHASH_REMOVE;
    1: }
    1: 
    1: // *Some* NativeSets are referenced from mClassInfo2NativeSetMap.
    1: // *All* NativeSets are referenced from mNativeSetMap.
    1: // So, in mClassInfo2NativeSetMap we just clear references to the unmarked.
    1: // In mNativeSetMap we clear the references to the unmarked *and* delete them.
    1: 
18907: static JSDHashOperator
    1: NativeUnMarkedSetRemover(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                          uint32 number, void *arg)
    1: {
    1:     XPCNativeSet* set = ((ClassInfo2NativeSetMap::Entry*)hdr)->value;
    1:     if(set->IsMarked())
    1:         return JS_DHASH_NEXT;
    1:     return JS_DHASH_REMOVE;
    1: }
    1: 
18907: static JSDHashOperator
    1: NativeSetSweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                  uint32 number, void *arg)
    1: {
    1:     XPCNativeSet* set = ((NativeSetMap::Entry*)hdr)->key_value;
    1:     if(set->IsMarked())
    1:     {
    1:         set->Unmark();
    1:         return JS_DHASH_NEXT;
    1:     }
    1: 
    1: #ifdef XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING
    1:     printf("- Destroying XPCNativeSet for:\n");
    1:     PRUint16 count = set->GetInterfaceCount();
    1:     for(PRUint16 k = 0; k < count; k++)
    1:     {
    1:         XPCNativeInterface* iface = set->GetInterfaceAt(k);
    1:         printf("    %s\n",JS_GetStringBytes(JSVAL_TO_STRING(iface->GetName())));
    1:     }
    1: #endif
    1: 
    1:     XPCNativeSet::DestroyInstance(set);
    1:     return JS_DHASH_REMOVE;
    1: }
    1: 
18907: static JSDHashOperator
    1: JSClassSweeper(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                uint32 number, void *arg)
    1: {
    1:     XPCNativeScriptableShared* shared =
    1:         ((XPCNativeScriptableSharedMap::Entry*) hdr)->key;
    1:     if(shared->IsMarked())
    1:     {
    1: #ifdef off_XPC_REPORT_JSCLASS_FLUSHING
    1:         printf("+ Marked XPCNativeScriptableShared for: %s @ %x\n",
    1:                shared->GetJSClass()->name,
    1:                shared->GetJSClass());
    1: #endif
    1:         shared->Unmark();
    1:         return JS_DHASH_NEXT;
    1:     }
    1: 
    1: #ifdef XPC_REPORT_JSCLASS_FLUSHING
    1:     printf("- Destroying XPCNativeScriptableShared for: %s @ %x\n",
    1:            shared->GetJSClass()->name,
    1:            shared->GetJSClass());
    1: #endif
    1: 
    1:     delete shared;
    1:     return JS_DHASH_REMOVE;
    1: }
    1: 
18907: static JSDHashOperator
    1: DyingProtoKiller(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                  uint32 number, void *arg)
    1: {
    1:     XPCWrappedNativeProto* proto =
    1:         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
    1:     delete proto;
    1:     return JS_DHASH_REMOVE;
    1: }
    1: 
18907: static JSDHashOperator
    1: DetachedWrappedNativeProtoMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                                  uint32 number, void *arg)
    1: {
    1:     XPCWrappedNativeProto* proto = 
    1:         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
    1: 
    1:     proto->Mark();
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: // GCCallback calls are chained
18907: static JSBool
    1: ContextCallback(JSContext *cx, uintN operation)
    1: {
20312:     XPCJSRuntime* self = nsXPConnect::GetRuntimeInstance();
    1:     if(self)
    1:     {
    1:         if(operation == JSCONTEXT_NEW)
    1:         {
20312:             if(!self->OnJSContextNew(cx))
20312:                 return JS_FALSE;
20312:         }
20312:         else if(operation == JSCONTEXT_DESTROY)
    1:         {
20312:             delete XPCContext::GetXPCContext(cx);
    1:         }
    1:     }
20312:     return JS_TRUE;
    1: }
    1: 
 7230: struct ObjectHolder : public JSDHashEntryHdr
 7230: {
 7230:     void *holder;
 7230:     nsScriptObjectTracer* tracer;
 7230: };
 7230: 
 7230: nsresult
 7230: XPCJSRuntime::AddJSHolder(void* aHolder, nsScriptObjectTracer* aTracer)
 7230: {
 7230:     if(!mJSHolders.ops)
 7230:         return NS_ERROR_OUT_OF_MEMORY;
 7230: 
 7230:     ObjectHolder *entry =
 7230:         reinterpret_cast<ObjectHolder*>(JS_DHashTableOperate(&mJSHolders,
 7230:                                                              aHolder,
 7230:                                                              JS_DHASH_ADD));
 7230:     if(!entry)
 7230:         return NS_ERROR_OUT_OF_MEMORY;
 7230: 
 7230:     entry->holder = aHolder;
 7230:     entry->tracer = aTracer;
 7230: 
 7230:     return NS_OK;
 7230: }
 7230: 
 7230: nsresult
 7230: XPCJSRuntime::RemoveJSHolder(void* aHolder)
 7230: {
 7230:     if(!mJSHolders.ops)
 7230:         return NS_ERROR_OUT_OF_MEMORY;
 7230: 
 7230:     JS_DHashTableOperate(&mJSHolders, aHolder, JS_DHASH_REMOVE);
 7230: 
 7230:     return NS_OK;
 7230: }
 7230: 
    1: // static
 1476: void XPCJSRuntime::TraceJS(JSTracer* trc, void* data)
 1025: {
 1476:     XPCJSRuntime* self = (XPCJSRuntime*)data;
 1476: 
 1025:     // Skip this part if XPConnect is shutting down. We get into
 1025:     // bad locking problems with the thread iteration otherwise.
 1025:     if(!self->GetXPConnect()->IsShuttingDown())
 1025:     {
 1025:         PRLock* threadLock = XPCPerThreadData::GetLock();
 1025:         if(threadLock)
 1025:         { // scoped lock
 1025:             nsAutoLock lock(threadLock);
 1025: 
 1025:             XPCPerThreadData* iterp = nsnull;
 1025:             XPCPerThreadData* thread;
 1025: 
 1025:             while(nsnull != (thread =
 1025:                              XPCPerThreadData::IterateThreads(&iterp)))
 1025:             {
 1025:                 // Trace those AutoMarkingPtr lists!
 1025:                 thread->TraceJS(trc);
 1025:             }
 1025:         }
 1025:     }
 1476: 
 7230:     // XPCJSObjectHolders don't participate in cycle collection, so always trace
 7230:     // them here.
 7230:     for(XPCRootSetElem *e = self->mObjectHolderRoots; e ; e = e->GetNextRoot())
 7230:         static_cast<XPCJSObjectHolder*>(e)->TraceJS(trc);
 7227:         
 7286:     if(self->GetXPConnect()->ShouldTraceRoots())
 7286:     {
 7286:         // Only trace these if we're not cycle-collecting, the cycle collector
 7286:         // will do that if we are.
 7230:         self->TraceXPConnectRoots(trc);
 7230:     }
 7286: }
 7230: 
20261: static void
 7230: TraceJSObject(PRUint32 aLangID, void *aScriptThing, void *aClosure)
 7230: {
 7230:     if(aLangID == nsIProgrammingLanguage::JAVASCRIPT)
 7230:     {
 7230:         JS_CALL_TRACER(static_cast<JSTracer*>(aClosure), aScriptThing,
 8005:                        js_GetGCThingTraceKind(aScriptThing),
 7230:                        "JSObjectHolder");
 7230:     }
 7230: }
 7230: 
18907: static JSDHashOperator
 7230: TraceJSHolder(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
 7230:               void *arg)
 7230: {
 7230:     ObjectHolder* entry = reinterpret_cast<ObjectHolder*>(hdr);
 7230: 
 7230:     entry->tracer->Trace(entry->holder, TraceJSObject, arg);
 7230: 
 7230:     return JS_DHASH_NEXT;
 7230: }
 7230: 
 7286: struct ClearedGlobalObject : public JSDHashEntryHdr
 7286: {
 7286:     JSContext* mContext;
 7286:     JSObject* mGlobalObject;
 7286: };
 7286: 
 7230: void XPCJSRuntime::TraceXPConnectRoots(JSTracer *trc)
 7230: {
 7286:     if(mClearedGlobalObjects.ops)
 7286:     {
 7286:         JSContext *iter = nsnull, *acx;
 7286:         while((acx = JS_ContextIterator(GetJSRuntime(), &iter)))
 7286:         {
 7286:             JSDHashEntryHdr* entry =
 7286:                 JS_DHashTableOperate(&mClearedGlobalObjects, acx,
 7286:                                      JS_DHASH_LOOKUP);
 7286:             if(JS_DHASH_ENTRY_IS_BUSY(entry))
 7286:             {
 7286:                 ClearedGlobalObject* clearedGlobal =
 7286:                     reinterpret_cast<ClearedGlobalObject*>(entry);
 7286:                 JS_CALL_OBJECT_TRACER(trc, clearedGlobal->mGlobalObject,
 7286:                                       "global object");
 7286:             }
 7286:         }
 7286:     }
 7286: 
 7230:     XPCWrappedNativeScope::TraceJS(trc, this);
 7230: 
 7230:     for(XPCRootSetElem *e = mVariantRoots; e ; e = e->GetNextRoot())
 7227:         static_cast<XPCTraceableVariant*>(e)->TraceJS(trc);
 7227: 
 7230:     for(XPCRootSetElem *e = mWrappedJSRoots; e ; e = e->GetNextRoot())
 7227:         static_cast<nsXPCWrappedJS*>(e)->TraceJS(trc);
 7227: 
 7230:     if(mJSHolders.ops)
 7230:         JS_DHashTableEnumerate(&mJSHolders, TraceJSHolder, trc);
 1025: }
 1025: 
18907: static JSDHashOperator
 7286: NoteJSHolder(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
 7286:              void *arg)
 7286: {
 7286:     ObjectHolder* entry = reinterpret_cast<ObjectHolder*>(hdr);
 7286: 
 7286:     nsCycleCollectionTraversalCallback* cb =
 7286:         static_cast<nsCycleCollectionTraversalCallback*>(arg);
 7286:     cb->NoteRoot(nsIProgrammingLanguage::CPLUSPLUS, entry->holder,
 7286:                  entry->tracer);
 7286: 
 7286:     return JS_DHASH_NEXT;
 7286: }
 7286: 
 7286: 
 7286: void XPCJSRuntime::AddXPConnectRoots(JSContext* cx,
 7286:                                      nsCycleCollectionTraversalCallback &cb)
 7286: {
 7286:     // For all JS objects that are held by native objects but aren't held
 7286:     // through rooting or locking, we need to add all the native objects that
 7286:     // hold them so that the JS objects are colored correctly in the cycle
 7286:     // collector. This includes JSContexts that don't have outstanding requests,
 7286:     // because their global object wasn't marked by the JS GC. All other JS
 7286:     // roots were marked by the JS GC and will be colored correctly in the cycle
 7286:     // collector.
 7286: 
 7286:     JSContext *iter = nsnull, *acx;
 7286:     while((acx = JS_ContextIterator(GetJSRuntime(), &iter)))
 7286:     {
 7286: #ifndef DEBUG_CC
 7286:         // Only skip JSContexts with outstanding requests if DEBUG_CC is not
 7286:         // defined, else we do want to know about all JSContexts to get better
 7286:         // graphs and explanations.
 7286:         if(nsXPConnect::GetXPConnect()->GetRequestDepth(acx) != 0)
 7286:             continue;
 7286: #endif
 7286:         cb.NoteRoot(nsIProgrammingLanguage::CPLUSPLUS, acx,
 7286:                     nsXPConnect::JSContextParticipant());
 7286:     }
 7286: 
 7286:     XPCWrappedNativeScope::SuspectAllWrappers(this, cx, cb);
 7286: 
 7286:     for(XPCRootSetElem *e = mVariantRoots; e ; e = e->GetNextRoot())
 7286:         cb.NoteXPCOMRoot(static_cast<XPCTraceableVariant*>(e));
 7286: 
 7286:     for(XPCRootSetElem *e = mWrappedJSRoots; e ; e = e->GetNextRoot())
 7286:     {
 7286:         nsIXPConnectWrappedJS *wrappedJS = static_cast<nsXPCWrappedJS*>(e);
 7286:         cb.NoteXPCOMRoot(wrappedJS);
 7286:     }
 7286: 
 7286:     if(mJSHolders.ops)
 7286:         JS_DHashTableEnumerate(&mJSHolders, NoteJSHolder, &cb);
 7286: }
 7286: 
 7286: void XPCJSRuntime::UnsetContextGlobals()
 7286: {
 7339:     if(!mClearedGlobalObjects.ops)
 7286:         return;
 7339: 
 7339:     RestoreContextGlobals();
 7286: 
 7286:     JSContext *iter = nsnull, *acx;
 7286:     while((acx = JS_ContextIterator(GetJSRuntime(), &iter)))
 7286:     {
 7286:         if(nsXPConnect::GetXPConnect()->GetRequestDepth(acx) == 0)
 7286:         {
 7286:             JS_ClearNewbornRoots(acx);
 7344:             if(acx->globalObject)
 7344:             {
 7286:                 JSDHashEntryHdr* entry =
 7344:                     JS_DHashTableOperate(&mClearedGlobalObjects, acx,
 7344:                                          JS_DHASH_ADD);
 7286:                 ClearedGlobalObject* clearedGlobal =
 7286:                     reinterpret_cast<ClearedGlobalObject*>(entry);
 7286:                 if(clearedGlobal)
 7286:                 {
 7286:                     clearedGlobal->mContext = acx;
 7286:                     clearedGlobal->mGlobalObject = acx->globalObject;
 7286:                     acx->globalObject = nsnull;
 7286:                 }
 7286:             }
 7286:         }
 7286:     }
 7344: }
 7286: 
 7339: JSDHashOperator
 7339: RemoveContextGlobal(JSDHashTable *table, JSDHashEntryHdr *hdr, uint32 number,
 7339:                     void *arg)
 7339: {
 7339:   return JS_DHASH_REMOVE;
 7339: }
 7339: 
 7286: void XPCJSRuntime::RestoreContextGlobals()
 7286: {
 7339:     if(!mClearedGlobalObjects.ops || mClearedGlobalObjects.entryCount == 0)
 7286:         return;
 7286: 
 7286:     JSContext *iter = nsnull, *acx;
 7286:     while((acx = JS_ContextIterator(GetJSRuntime(), &iter)))
 7286:     {
 7286:         JSDHashEntryHdr* entry =
 7286:             JS_DHashTableOperate(&mClearedGlobalObjects, acx, JS_DHASH_LOOKUP);
 7286:         if(JS_DHASH_ENTRY_IS_BUSY(entry))
 7286:         {
 7286:             ClearedGlobalObject* clearedGlobal =
 7286:                 reinterpret_cast<ClearedGlobalObject*>(entry);
 7286:             acx->globalObject = clearedGlobal->mGlobalObject;
 7286:         }
 7286:     }
 7339:     JS_DHashTableEnumerate(&mClearedGlobalObjects, RemoveContextGlobal, nsnull);
 7286: }
 7286: 
 7286: JSObject* XPCJSRuntime::GetUnsetContextGlobal(JSContext* cx)
 7286: {
 7286:     if(!mClearedGlobalObjects.ops)
 7286:         return nsnull;
 7286: 
 7286:     JSDHashEntryHdr* entry =
 7286:         JS_DHashTableOperate(&mClearedGlobalObjects, cx, JS_DHASH_LOOKUP);
 7286:     ClearedGlobalObject* clearedGlobal =
 7286:         reinterpret_cast<ClearedGlobalObject*>(entry);
 7286: 
 7286:     return JS_DHASH_ENTRY_IS_BUSY(entry) ?
 7286:            clearedGlobal->mGlobalObject :
 7286:            nsnull;
 7286: }
 7286: 
 1025: // static
    1: JSBool XPCJSRuntime::GCCallback(JSContext *cx, JSGCStatus status)
    1: {
    1:     nsVoidArray* dyingWrappedJSArray;
    1: 
20312:     XPCJSRuntime* self = nsXPConnect::GetRuntimeInstance();
    1:     if(self)
    1:     {
    1:         switch(status)
    1:         {
    1:             case JSGC_BEGIN:
    1:             {
 9740:                 if(!NS_IsMainThread())
    1:                 {
    1:                     return JS_FALSE;
    1:                 }
    1:                 break;
    1:             }
    1:             case JSGC_MARK_END:
    1:             {
    1:                 NS_ASSERTION(!self->mDoingFinalization, "bad state");
    1:     
    1:                 // mThreadRunningGC indicates that GC is running
    1:                 { // scoped lock
    1:                     XPCAutoLock lock(self->GetMapLock());
    1:                     NS_ASSERTION(!self->mThreadRunningGC, "bad state");
    1:                     self->mThreadRunningGC = PR_GetCurrentThread();
    1:                 }
    1: 
    1:                 dyingWrappedJSArray = &self->mWrappedJSToReleaseArray;
 9740: 
    1:                 {
    1:                     JSDyingJSObjectData data = {cx, dyingWrappedJSArray};
    1: 
    1:                     // Add any wrappers whose JSObjects are to be finalized to
    1:                     // this array. Note that this is a nsVoidArray because
    1:                     // we do not want to be changing the refcount of these wrappers.
    1:                     // We add them to the array now and Release the array members
    1:                     // later to avoid the posibility of doing any JS GCThing
    1:                     // allocations during the gc cycle.
    1:                     self->mWrappedJSMap->
    1:                         Enumerate(WrappedJSDyingJSObjectFinder, &data);
    1:                 }
    1: 
    1:                 // Do cleanup in NativeInterfaces. This part just finds 
    1:                 // member cloned function objects that are about to be 
    1:                 // collected. It does not deal with collection of interfaces or
    1:                 // sets at this point.
    1:                 CX_AND_XPCRT_Data data = {cx, self};
    1: 
    1:                 self->mIID2NativeInterfaceMap->
    1:                     Enumerate(NativeInterfaceGC, &data);
    1: 
    1:                 // Find dying scopes...
    1:                 XPCWrappedNativeScope::FinishedMarkPhaseOfGC(cx, self);
    1: 
    1:                 self->mDoingFinalization = JS_TRUE;
    1:                 break;
    1:             }
    1:             case JSGC_FINALIZE_END:
    1:             {
    1:                 NS_ASSERTION(self->mDoingFinalization, "bad state");
    1:                 self->mDoingFinalization = JS_FALSE;
    1: 
    1:                 // Release all the members whose JSObjects are now known
    1:                 // to be dead.
    1: 
    1:                 dyingWrappedJSArray = &self->mWrappedJSToReleaseArray;
    1:                 while(1)
    1:                 {
    1:                     nsXPCWrappedJS* wrapper;
    1:                     PRInt32 count = dyingWrappedJSArray->Count();
    1:                     if(!count)
    1:                     {
    1:                         dyingWrappedJSArray->Compact();
    1:                         break;
    1:                     }
 3233:                     wrapper = static_cast<nsXPCWrappedJS*>
 3233:                         (dyingWrappedJSArray->ElementAt(count-1));
    1:                     dyingWrappedJSArray->RemoveElementAt(count-1);
    1:                     NS_RELEASE(wrapper);
    1:                 }
    1: 
    1: 
    1: #ifdef XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING
    1:                 printf("--------------------------------------------------------------\n");
    1:                 int setsBefore = (int) self->mNativeSetMap->Count();
    1:                 int ifacesBefore = (int) self->mIID2NativeInterfaceMap->Count();
    1: #endif
    1: 
    1:                 // We use this occasion to mark and sweep NativeInterfaces,
    1:                 // NativeSets, and the WrappedNativeJSClasses...
    1: 
    1:                 // Do the marking...
    1:                 XPCWrappedNativeScope::MarkAllWrappedNativesAndProtos();
    1: 
    1:                 self->mDetachedWrappedNativeProtoMap->
    1:                     Enumerate(DetachedWrappedNativeProtoMarker, nsnull);
    1: 
    1:                 // Mark the sets used in the call contexts. There is a small
    1:                 // chance that a wrapper's set will change *while* a call is
    1:                 // happening which uses that wrapper's old interfface set. So,
    1:                 // we need to do this marking to avoid collecting those sets
    1:                 // that might no longer be otherwise reachable from the wrappers
    1:                 // or the wrapperprotos.
    1: 
    1:                 // Skip this part if XPConnect is shutting down. We get into
    1:                 // bad locking problems with the thread iteration otherwise.
    1:                 if(!self->GetXPConnect()->IsShuttingDown())
    1:                 {
    1:                     PRLock* threadLock = XPCPerThreadData::GetLock();
    1:                     if(threadLock)
    1:                     { // scoped lock
    1:                         nsAutoLock lock(threadLock);
    1: 
    1:                         XPCPerThreadData* iterp = nsnull;
    1:                         XPCPerThreadData* thread;
    1: 
    1:                         while(nsnull != (thread =
    1:                                      XPCPerThreadData::IterateThreads(&iterp)))
    1:                         {
    1:                             // Mark those AutoMarkingPtr lists!
    1:                             thread->MarkAutoRootsAfterJSFinalize();
    1: 
    1:                             XPCCallContext* ccxp = thread->GetCallContext();
    1:                             while(ccxp)
    1:                             {
    1:                                 // Deal with the strictness of callcontext that
    1:                                 // complains if you ask for a set when
    1:                                 // it is in a state where the set could not
    1:                                 // possibly be valid.
    1:                                 if(ccxp->CanGetSet())
    1:                                 {
    1:                                     XPCNativeSet* set = ccxp->GetSet();
    1:                                     if(set)
    1:                                         set->Mark();
    1:                                 }
    1:                                 if(ccxp->CanGetInterface())
    1:                                 {
    1:                                     XPCNativeInterface* iface = ccxp->GetInterface();
    1:                                     if(iface)
    1:                                         iface->Mark();
    1:                                 }
    1:                                 ccxp = ccxp->GetPrevCallContext();
    1:                             }
    1:                         }
    1:                     }
    1:                 }
    1: 
    1:                 // Do the sweeping...
    1: 
    1:                 // We don't want to sweep the JSClasses at shutdown time.
    1:                 // At this point there may be JSObjects using them that have
    1:                 // been removed from the other maps.
    1:                 if(!self->GetXPConnect()->IsShuttingDown())
    1:                 {
    1:                     self->mNativeScriptableSharedMap->
    1:                         Enumerate(JSClassSweeper, nsnull);
    1:                 }
    1: 
    1:                 self->mClassInfo2NativeSetMap->
    1:                     Enumerate(NativeUnMarkedSetRemover, nsnull);
    1: 
    1:                 self->mNativeSetMap->
    1:                     Enumerate(NativeSetSweeper, nsnull);
    1: 
    1:                 CX_AND_XPCRT_Data data = {cx, self};
    1: 
    1:                 self->mIID2NativeInterfaceMap->
    1:                     Enumerate(NativeInterfaceSweeper, &data);
    1: 
    1: #ifdef DEBUG
    1:                 XPCWrappedNativeScope::ASSERT_NoInterfaceSetsAreMarked();
    1: #endif
    1: 
    1: #ifdef XPC_REPORT_NATIVE_INTERFACE_AND_SET_FLUSHING
    1:                 int setsAfter = (int) self->mNativeSetMap->Count();
    1:                 int ifacesAfter = (int) self->mIID2NativeInterfaceMap->Count();
    1: 
    1:                 printf("\n");
    1:                 printf("XPCNativeSets:        before: %d  collected: %d  remaining: %d\n",
    1:                        setsBefore, setsBefore - setsAfter, setsAfter);
    1:                 printf("XPCNativeInterfaces:  before: %d  collected: %d  remaining: %d\n",
    1:                        ifacesBefore, ifacesBefore - ifacesAfter, ifacesAfter);
    1:                 printf("--------------------------------------------------------------\n");
    1: #endif
    1: 
    1:                 // Sweep scopes needing cleanup
    1:                 XPCWrappedNativeScope::FinishedFinalizationPhaseOfGC(cx);
    1: 
    1:                 // Now we are going to recycle any unused WrappedNativeTearoffs.
    1:                 // We do this by iterating all the live callcontexts (on all
    1:                 // threads!) and marking the tearoffs in use. And then we
    1:                 // iterate over all the WrappedNative wrappers and sweep their
    1:                 // tearoffs.
    1:                 //
    1:                 // This allows us to perhaps minimize the growth of the
    1:                 // tearoffs. And also makes us not hold references to interfaces
    1:                 // on our wrapped natives that we are not actually using.
    1:                 //
    1:                 // XXX We may decide to not do this on *every* gc cycle.
    1: 
    1:                 // Skip this part if XPConnect is shutting down. We get into
    1:                 // bad locking problems with the thread iteration otherwise.
    1:                 if(!self->GetXPConnect()->IsShuttingDown())
    1:                 {
    1:                     PRLock* threadLock = XPCPerThreadData::GetLock();
    1:                     if(threadLock)
    1:                     {
    1:                         // Do the marking...
    1:                         
    1:                         { // scoped lock
    1:                             nsAutoLock lock(threadLock);
    1: 
    1:                             XPCPerThreadData* iterp = nsnull;
    1:                             XPCPerThreadData* thread;
    1: 
    1:                             while(nsnull != (thread =
    1:                                      XPCPerThreadData::IterateThreads(&iterp)))
    1:                             {
    1:                                 XPCCallContext* ccxp = thread->GetCallContext();
    1:                                 while(ccxp)
    1:                                 {
    1:                                     // Deal with the strictness of callcontext that
    1:                                     // complains if you ask for a tearoff when
    1:                                     // it is in a state where the tearoff could not
    1:                                     // possibly be valid.
    1:                                     if(ccxp->CanGetTearOff())
    1:                                     {
    1:                                         XPCWrappedNativeTearOff* to = 
    1:                                             ccxp->GetTearOff();
    1:                                         if(to)
    1:                                             to->Mark();
    1:                                     }
    1:                                     ccxp = ccxp->GetPrevCallContext();
    1:                                 }
    1:                             }
    1:                         }
    1:     
    1:                         // Do the sweeping...
    1:                         XPCWrappedNativeScope::SweepAllWrappedNativeTearOffs();
    1:                     }
    1:                 }
    1: 
    1:                 // Now we need to kill the 'Dying' XPCWrappedNativeProtos.
    1:                 // We transfered these native objects to this table when their
    1:                 // JSObject's were finalized. We did not destroy them immediately
    1:                 // at that point because the ordering of JS finalization is not
    1:                 // deterministic and we did not yet know if any wrappers that
    1:                 // might still be referencing the protos where still yet to be
    1:                 // finalized and destroyed. We *do* know that the protos'
    1:                 // JSObjects would not have been finalized if there were any
    1:                 // wrappers that referenced the proto but where not themselves
    1:                 // slated for finalization in this gc cycle. So... at this point
    1:                 // we know that any and all wrappers that might have been
    1:                 // referencing the protos in the dying list are themselves dead.
    1:                 // So, we can safely delete all the protos in the list.
    1: 
    1:                 self->mDyingWrappedNativeProtoMap->
    1:                     Enumerate(DyingProtoKiller, nsnull);
    1: 
    1: 
    1:                 // mThreadRunningGC indicates that GC is running.
    1:                 // Clear it and notify waiters.
    1:                 { // scoped lock
    1:                     XPCAutoLock lock(self->GetMapLock());
    1:                     NS_ASSERTION(self->mThreadRunningGC == PR_GetCurrentThread(), "bad state");
    1:                     self->mThreadRunningGC = nsnull;
    1:                     xpc_NotifyAll(self->GetMapLock());
    1:                 }
    1: 
    1:                 break;
    1:             }
    1:             case JSGC_END:
    1:             {
    1:                 // NOTE that this event happens outside of the gc lock in
    1:                 // the js engine. So this could be simultaneous with the
    1:                 // events above.
    1: 
    1:                 // Do any deferred released of native objects.
    1:                 nsVoidArray* array = &self->mNativesToReleaseArray;
    1: #ifdef XPC_TRACK_DEFERRED_RELEASES
    1:                 printf("XPC - Begin deferred Release of %d nsISupports pointers\n",
    1:                        array->Count());
    1: #endif
    1:                 while(1)
    1:                 {
    1:                     nsISupports* obj;
    1:                     {
    1:                         PRInt32 count = array->Count();
    1:                         if(!count)
    1:                         {
    1:                             array->Compact();
    1:                             break;
    1:                         }
 3233:                         obj = reinterpret_cast<nsISupports*>
 3233:                             (array->ElementAt(count-1));
    1:                         array->RemoveElementAt(count-1);
    1:                     }
    1:                     NS_RELEASE(obj);
    1:                 }
    1: #ifdef XPC_TRACK_DEFERRED_RELEASES
    1:                 printf("XPC - End deferred Releases\n");
    1: #endif
    1:                 break;
    1:             }
    1:             default:
    1:                 break;
    1:         }
    1:     }
    1: 
20312:     return JS_TRUE;
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
18907: static JSDHashOperator
    1: DEBUG_WrapperChecker(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                      uint32 number, void *arg)
    1: {
    1:     XPCWrappedNative* wrapper = (XPCWrappedNative*)((JSDHashEntryStub*)hdr)->key;
    1:     NS_ASSERTION(!wrapper->IsValid(), "found a 'valid' wrapper!");
    1:     ++ *((int*)arg);
    1:     return JS_DHASH_NEXT;
    1: }
    1: #endif
    1: 
18907: static JSDHashOperator
    1: WrappedJSShutdownMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                         uint32 number, void *arg)
    1: {
    1:     JSRuntime* rt = (JSRuntime*) arg;
    1:     nsXPCWrappedJS* wrapper = ((JSObject2WrappedJSMap::Entry*)hdr)->value;
    1:     NS_ASSERTION(wrapper, "found a null JS wrapper!");
    1:     NS_ASSERTION(wrapper->IsValid(), "found an invalid JS wrapper!");
    1:     wrapper->SystemIsBeingShutDown(rt);
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
18907: static JSDHashOperator
    1: DetachedWrappedNativeProtoShutdownMarker(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                                          uint32 number, void *arg)
    1: {
    1:     XPCWrappedNativeProto* proto = 
    1:         (XPCWrappedNativeProto*)((JSDHashEntryStub*)hdr)->key;
    1: 
 2991:     proto->SystemIsBeingShutDown((JSContext*)arg);
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
 2991: void XPCJSRuntime::SystemIsBeingShutDown(JSContext* cx)
    1: {
    1:     if(mDetachedWrappedNativeProtoMap)
    1:         mDetachedWrappedNativeProtoMap->
 2991:             Enumerate(DetachedWrappedNativeProtoShutdownMarker, cx);
    1: }
    1: 
    1: XPCJSRuntime::~XPCJSRuntime()
    1: {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:     {
    1:     // count the total JSContexts in use
    1:     JSContext* iter = nsnull;
    1:     int count = 0;
    1:     while(JS_ContextIterator(mJSRuntime, &iter))
    1:         count ++;
    1:     if(count)
    1:         printf("deleting XPCJSRuntime with %d live JSContexts\n", count);
    1:     }
    1: #endif
    1: 
    1:     // clean up and destroy maps...
    1:     if(mWrappedJSMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mWrappedJSMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live wrapped JSObject\n", (int)count);
    1: #endif
    1:         mWrappedJSMap->Enumerate(WrappedJSShutdownMarker, mJSRuntime);
    1:         delete mWrappedJSMap;
    1:     }
    1: 
    1:     if(mWrappedJSClassMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mWrappedJSClassMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live nsXPCWrappedJSClass\n", (int)count);
    1: #endif
    1:         delete mWrappedJSClassMap;
    1:     }
    1: 
    1:     if(mIID2NativeInterfaceMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mIID2NativeInterfaceMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live XPCNativeInterfaces\n", (int)count);
    1: #endif
    1:         delete mIID2NativeInterfaceMap;
    1:     }
    1: 
    1:     if(mClassInfo2NativeSetMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mClassInfo2NativeSetMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live XPCNativeSets\n", (int)count);
    1: #endif
    1:         delete mClassInfo2NativeSetMap;
    1:     }
    1: 
    1:     if(mNativeSetMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mNativeSetMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live XPCNativeSets\n", (int)count);
    1: #endif
    1:         delete mNativeSetMap;
    1:     }
    1: 
    1:     if(mMapLock)
    1:         XPCAutoLock::DestroyLock(mMapLock);
    1: 
    1:     if(mThisTranslatorMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mThisTranslatorMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live ThisTranslator\n", (int)count);
    1: #endif
    1:         delete mThisTranslatorMap;
    1:     }
    1: 
    1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
    1:     if(DEBUG_WrappedNativeHashtable)
    1:     {
    1:         int LiveWrapperCount = 0;
    1:         JS_DHashTableEnumerate(DEBUG_WrappedNativeHashtable,
    1:                                DEBUG_WrapperChecker, &LiveWrapperCount);
    1:         if(LiveWrapperCount)
    1:             printf("deleting XPCJSRuntime with %d live XPCWrappedNative (found in wrapper check)\n", (int)LiveWrapperCount);
    1:         JS_DHashTableDestroy(DEBUG_WrappedNativeHashtable);
    1:     }
    1: #endif
    1: 
    1:     if(mNativeScriptableSharedMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mNativeScriptableSharedMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live XPCNativeScriptableShared\n", (int)count);
    1: #endif
    1:         delete mNativeScriptableSharedMap;
    1:     }
    1: 
    1:     if(mDyingWrappedNativeProtoMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mDyingWrappedNativeProtoMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live but dying XPCWrappedNativeProto\n", (int)count);
    1: #endif
    1:         delete mDyingWrappedNativeProtoMap;
    1:     }
    1: 
    1:     if(mDetachedWrappedNativeProtoMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mDetachedWrappedNativeProtoMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live detached XPCWrappedNativeProto\n", (int)count);
    1: #endif
    1:         delete mDetachedWrappedNativeProtoMap;
    1:     }
    1: 
    1:     if(mExplicitNativeWrapperMap)
    1:     {
    1: #ifdef XPC_DUMP_AT_SHUTDOWN
    1:         uint32 count = mExplicitNativeWrapperMap->Count();
    1:         if(count)
    1:             printf("deleting XPCJSRuntime with %d live explicit XPCNativeWrapper\n", (int)count);
    1: #endif
    1:         delete mExplicitNativeWrapperMap;
    1:     }
    1: 
    1:     // unwire the readable/JSString sharing magic
    1:     XPCStringConvert::ShutdownDOMStringFinalizer();
    1: 
    1:     XPCConvert::RemoveXPCOMUCStringFinalizer();
    1: 
 7230:     if(mJSHolders.ops)
 7230:     {
 7230:         JS_DHashTableFinish(&mJSHolders);
 7230:         mJSHolders.ops = nsnull;
 7230:     }
 7339:     if(mClearedGlobalObjects.ops)
 7339:     {
 7339:         JS_DHashTableFinish(&mClearedGlobalObjects);
 7339:         mClearedGlobalObjects.ops = nsnull;
 7339:     }
20312: 
20312:     if(mJSRuntime)
20312:     {
20312:         JS_DestroyRuntime(mJSRuntime);
20312:         JS_ShutDown();
20312: #ifdef DEBUG_shaver_off
20312:         fprintf(stderr, "nJRSI: destroyed runtime %p\n", (void *)mJSRuntime);
20312: #endif
    1:     }
    1: 
20312:     XPCPerThreadData::ShutDown();
20312: }
20312: 
20312: XPCJSRuntime::XPCJSRuntime(nsXPConnect* aXPConnect)
    1:  : mXPConnect(aXPConnect),
    1:    mJSRuntime(nsnull),
    1:    mWrappedJSMap(JSObject2WrappedJSMap::newMap(XPC_JS_MAP_SIZE)),
    1:    mWrappedJSClassMap(IID2WrappedJSClassMap::newMap(XPC_JS_CLASS_MAP_SIZE)),
    1:    mIID2NativeInterfaceMap(IID2NativeInterfaceMap::newMap(XPC_NATIVE_INTERFACE_MAP_SIZE)),
    1:    mClassInfo2NativeSetMap(ClassInfo2NativeSetMap::newMap(XPC_NATIVE_SET_MAP_SIZE)),
    1:    mNativeSetMap(NativeSetMap::newMap(XPC_NATIVE_SET_MAP_SIZE)),
    1:    mThisTranslatorMap(IID2ThisTranslatorMap::newMap(XPC_THIS_TRANSLATOR_MAP_SIZE)),
    1:    mNativeScriptableSharedMap(XPCNativeScriptableSharedMap::newMap(XPC_NATIVE_JSCLASS_MAP_SIZE)),
    1:    mDyingWrappedNativeProtoMap(XPCWrappedNativeProtoMap::newMap(XPC_DYING_NATIVE_PROTO_MAP_SIZE)),
    1:    mDetachedWrappedNativeProtoMap(XPCWrappedNativeProtoMap::newMap(XPC_DETACHED_NATIVE_PROTO_MAP_SIZE)),
    1:    mExplicitNativeWrapperMap(XPCNativeWrapperMap::newMap(XPC_NATIVE_WRAPPER_MAP_SIZE)),
    1:    mMapLock(XPCAutoLock::NewLock("XPCJSRuntime::mMapLock")),
    1:    mThreadRunningGC(nsnull),
    1:    mWrappedJSToReleaseArray(),
    1:    mNativesToReleaseArray(),
 2072:    mDoingFinalization(JS_FALSE),
 2072:    mVariantRoots(nsnull),
 2072:    mWrappedJSRoots(nsnull),
21873:    mObjectHolderRoots(nsnull)
    1: {
    1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
    1:     DEBUG_WrappedNativeHashtable =
    1:         JS_NewDHashTable(JS_DHashGetStubOps(), nsnull,
    1:                          sizeof(JSDHashEntryStub), 128);
    1: #endif
    1: 
    1:     // these jsids filled in later when we have a JSContext to work with.
    1:     mStrIDs[0] = 0;
    1: 
20312:     // Call XPCPerThreadData::GetData to initialize
20312:     // XPCPerThreadData::gTLSIndex before initializing
20312:     // JSRuntime::threadTPIndex in JS_NewRuntime.
20312:     //
20312:     // XPConnect uses a thread local storage (XPCPerThreadData) indexed by
20312:     // XPCPerThreadData::gTLSIndex, and SpiderMonkey GC uses a thread local
20312:     // storage indexed by JSRuntime::threadTPIndex.
20312:     //
20312:     // The destructor for XPCPerThreadData::gTLSIndex may access
20312:     // thread local storage indexed by JSRuntime::threadTPIndex.
20312:     // Thus, the destructor for JSRuntime::threadTPIndex must be called
20312:     // later than the one for XPCPerThreadData::gTLSIndex.
20312:     //
20312:     // We rely on the implementation of NSPR that calls destructors at
20312:     // the same order of calling PR_NewThreadPrivateIndex.
20312:     XPCPerThreadData::GetData(nsnull);
    1: 
20312:     mJSRuntime = JS_NewRuntime(32L * 1024L * 1024L); // pref ?
    1:     if(mJSRuntime)
    1:     {
20312:         // Unconstrain the runtime's threshold on nominal heap size, to avoid
20312:         // triggering GC too often if operating continuously near an arbitrary
20312:         // finite threshold (0xffffffff is infinity for uint32 parameters).
20312:         // This leaves the maximum-JS_malloc-bytes threshold still in effect
20312:         // to cause period, and we hope hygienic, last-ditch GCs from within
20312:         // the GC's allocator.
20312:         JS_SetGCParameter(mJSRuntime, JSGC_MAX_BYTES, 0xffffffff);
20312:         JS_SetContextCallback(mJSRuntime, ContextCallback);
20312:         JS_SetGCCallbackRT(mJSRuntime, GCCallback);
 1476:         JS_SetExtraGCRoots(mJSRuntime, TraceJS, this);
    1:     }
    1: 
 7230:     if(!JS_DHashTableInit(&mJSHolders, JS_DHashGetStubOps(), nsnull,
 7230:                           sizeof(ObjectHolder), 512))
 7230:         mJSHolders.ops = nsnull;
 7339:     if(!JS_DHashTableInit(&mClearedGlobalObjects, JS_DHashGetStubOps(), nsnull,
 7339:                           sizeof(ClearedGlobalObject), JS_DHASH_MIN_SIZE))
 7286:         mClearedGlobalObjects.ops = nsnull;
 7230: 
    1:     // Install a JavaScript 'debugger' keyword handler in debug builds only
    1: #ifdef DEBUG
 2433:     if(mJSRuntime && !JS_GetGlobalDebugHooks(mJSRuntime)->debuggerHandler)
    1:         xpc_InstallJSDebuggerKeywordHandler(mJSRuntime);
    1: #endif
    1: }
    1: 
    1: // static
    1: XPCJSRuntime*
20312: XPCJSRuntime::newXPCJSRuntime(nsXPConnect* aXPConnect)
    1: {
    1:     NS_PRECONDITION(aXPConnect,"bad param");
    1: 
20312:     XPCJSRuntime* self = new XPCJSRuntime(aXPConnect);
    1: 
    1:     if(self                                  &&
    1:        self->GetJSRuntime()                  &&
    1:        self->GetWrappedJSMap()               &&
    1:        self->GetWrappedJSClassMap()          &&
    1:        self->GetIID2NativeInterfaceMap()     &&
    1:        self->GetClassInfo2NativeSetMap()     &&
    1:        self->GetNativeSetMap()               &&
    1:        self->GetThisTranslatorMap()          &&
    1:        self->GetNativeScriptableSharedMap()  &&
    1:        self->GetDyingWrappedNativeProtoMap() &&
    1:        self->GetExplicitNativeWrapperMap()   &&
21873:        self->GetMapLock())
    1:     {
    1:         return self;
    1:     }
    1:     delete self;
    1:     return nsnull;
    1: }
    1: 
20312: JSBool
20312: XPCJSRuntime::OnJSContextNew(JSContext *cx)
    1: {
    1:     // if it is our first context then we need to generate our string ids
20312:     JSBool ok = JS_TRUE;
    1:     if(!mStrIDs[0])
    1:     {
20312:         JSAutoRequest ar(cx);
    1:         for(uintN i = 0; i < IDX_TOTAL_COUNT; i++)
    1:         {
    1:             JSString* str = JS_InternString(cx, mStrings[i]);
    1:             if(!str || !JS_ValueToId(cx, STRING_TO_JSVAL(str), &mStrIDs[i]))
    1:             {
    1:                 mStrIDs[0] = 0;
20312:                 ok = JS_FALSE;
20312:                 break;
    1:             }
    1:             mStrJSVals[i] = STRING_TO_JSVAL(str);
    1:         }
20312:     }
20312:     if (!ok)
20312:         return JS_FALSE;
20312: 
20312:     XPCPerThreadData* tls = XPCPerThreadData::GetData(cx);
20312:     if(!tls)
20312:         return JS_FALSE;
20312: 
20312:     XPCContext* xpc = new XPCContext(this, cx);
20312:     if (!xpc)
20312:         return JS_FALSE;
20312: 
20312:     JS_SetThreadStackLimit(cx, tls->GetStackLimit());
20312:     JS_SetScriptStackQuota(cx, 100*1024*1024);
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSBool
    1: XPCJSRuntime::DeferredRelease(nsISupports* obj)
    1: {
    1:     NS_ASSERTION(obj, "bad param");
    1: 
    1:     if(!mNativesToReleaseArray.Count())
    1:     {
    1:         // This array sometimes has 1000's
    1:         // of entries, and usually has 50-200 entries. Avoid lots
    1:         // of incremental grows.  We compact it down when we're done.
    1:         mNativesToReleaseArray.SizeTo(256);
    1:     }
    1:     return mNativesToReleaseArray.AppendElement(obj);
    1: }
    1: 
    1: /***************************************************************************/
    1: 
    1: #ifdef DEBUG
18907: static JSDHashOperator
    1: WrappedJSClassMapDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                                 uint32 number, void *arg)
    1: {
    1:     ((IID2WrappedJSClassMap::Entry*)hdr)->value->DebugDump(*(PRInt16*)arg);
    1:     return JS_DHASH_NEXT;
    1: }
18907: static JSDHashOperator
    1: WrappedJSMapDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                            uint32 number, void *arg)
    1: {
    1:     ((JSObject2WrappedJSMap::Entry*)hdr)->value->DebugDump(*(PRInt16*)arg);
    1:     return JS_DHASH_NEXT;
    1: }
18907: static JSDHashOperator
    1: NativeSetDumpEnumerator(JSDHashTable *table, JSDHashEntryHdr *hdr,
    1:                         uint32 number, void *arg)
    1: {
    1:     ((NativeSetMap::Entry*)hdr)->key_value->DebugDump(*(PRInt16*)arg);
    1:     return JS_DHASH_NEXT;
    1: }
    1: #endif
    1: 
    1: void
    1: XPCJSRuntime::DebugDump(PRInt16 depth)
    1: {
    1: #ifdef DEBUG
    1:     depth--;
    1:     XPC_LOG_ALWAYS(("XPCJSRuntime @ %x", this));
    1:         XPC_LOG_INDENT();
    1:         XPC_LOG_ALWAYS(("mXPConnect @ %x", mXPConnect));
    1:         XPC_LOG_ALWAYS(("mJSRuntime @ %x", mJSRuntime));
    1:         XPC_LOG_ALWAYS(("mMapLock @ %x", mMapLock));
    1: 
    1:         XPC_LOG_ALWAYS(("mWrappedJSToReleaseArray @ %x with %d wrappers(s)", \
    1:                          &mWrappedJSToReleaseArray,
    1:                          mWrappedJSToReleaseArray.Count()));
    1: 
20312:         int cxCount = 0;
20312:         JSContext* iter = nsnull;
20312:         while(JS_ContextIterator(mJSRuntime, &iter))
20312:             ++cxCount;
20312:         XPC_LOG_ALWAYS(("%d JS context(s)", cxCount));
20312: 
20312:         iter = nsnull;
20312:         while(JS_ContextIterator(mJSRuntime, &iter))
    1:         {
20312:             XPCContext *xpc = XPCContext::GetXPCContext(iter);
    1:             XPC_LOG_INDENT();
20312:             xpc->DebugDump(depth);
    1:             XPC_LOG_OUTDENT();
    1:         }
    1: 
    1:         XPC_LOG_ALWAYS(("mWrappedJSClassMap @ %x with %d wrapperclasses(s)", \
    1:                          mWrappedJSClassMap, mWrappedJSClassMap ? \
    1:                                             mWrappedJSClassMap->Count() : 0));
    1:         // iterate wrappersclasses...
    1:         if(depth && mWrappedJSClassMap && mWrappedJSClassMap->Count())
    1:         {
    1:             XPC_LOG_INDENT();
    1:             mWrappedJSClassMap->Enumerate(WrappedJSClassMapDumpEnumerator, &depth);
    1:             XPC_LOG_OUTDENT();
    1:         }
    1:         XPC_LOG_ALWAYS(("mWrappedJSMap @ %x with %d wrappers(s)", \
    1:                          mWrappedJSMap, mWrappedJSMap ? \
    1:                                             mWrappedJSMap->Count() : 0));
    1:         // iterate wrappers...
    1:         if(depth && mWrappedJSMap && mWrappedJSMap->Count())
    1:         {
    1:             XPC_LOG_INDENT();
    1:             mWrappedJSMap->Enumerate(WrappedJSMapDumpEnumerator, &depth);
    1:             XPC_LOG_OUTDENT();
    1:         }
    1: 
    1:         XPC_LOG_ALWAYS(("mIID2NativeInterfaceMap @ %x with %d interface(s)", \
    1:                          mIID2NativeInterfaceMap, mIID2NativeInterfaceMap ? \
    1:                                     mIID2NativeInterfaceMap->Count() : 0));
    1: 
    1:         XPC_LOG_ALWAYS(("mClassInfo2NativeSetMap @ %x with %d sets(s)", \
    1:                          mClassInfo2NativeSetMap, mClassInfo2NativeSetMap ? \
    1:                                     mClassInfo2NativeSetMap->Count() : 0));
    1: 
    1:         XPC_LOG_ALWAYS(("mThisTranslatorMap @ %x with %d translator(s)", \
    1:                          mThisTranslatorMap, mThisTranslatorMap ? \
    1:                                     mThisTranslatorMap->Count() : 0));
    1: 
    1:         XPC_LOG_ALWAYS(("mNativeSetMap @ %x with %d sets(s)", \
    1:                          mNativeSetMap, mNativeSetMap ? \
    1:                                     mNativeSetMap->Count() : 0));
    1: 
    1:         // iterate sets...
    1:         if(depth && mNativeSetMap && mNativeSetMap->Count())
    1:         {
    1:             XPC_LOG_INDENT();
    1:             mNativeSetMap->Enumerate(NativeSetDumpEnumerator, &depth);
    1:             XPC_LOG_OUTDENT();
    1:         }
    1: 
    1:         XPC_LOG_OUTDENT();
    1: #endif
    1: }
    1: 
 2072: /***************************************************************************/
 2072: 
 2072: void
 2072: XPCRootSetElem::AddToRootSet(JSRuntime* rt, XPCRootSetElem** listHead)
 2072: {
 2072:     NS_ASSERTION(!mSelfp, "Must be not linked");
 2072:     JS_LOCK_GC(rt);
 2072:     mSelfp = listHead;
 2072:     mNext = *listHead;
 2072:     if(mNext)
 2072:     {
 2072:         NS_ASSERTION(mNext->mSelfp == listHead, "Must be list start");
 2072:         mNext->mSelfp = &mNext;
 2072:     }
 2072:     *listHead = this;
 2072:     JS_UNLOCK_GC(rt);
 2072: }
 2072: 
 2072: void
 2072: XPCRootSetElem::RemoveFromRootSet(JSRuntime* rt)
 2072: {
 2072:     NS_ASSERTION(mSelfp, "Must be linked");
 2072:     JS_LOCK_GC(rt);
 2072:     NS_ASSERTION(*mSelfp == this, "Link invariant");
 2072:     *mSelfp = mNext;
 2072:     if(mNext)
 2072:         mNext->mSelfp = mSelfp;
 2072:     JS_UNLOCK_GC(rt);
 2072: #ifdef DEBUG
 2072:     mSelfp = nsnull;
 2072:     mNext = nsnull;
 2072: #endif
 2072: }
