190275: /* This Source Code Form is subject to the terms of the Mozilla Public
190275:  * License, v. 2.0. If a copy of the MPL was not distributed with this
190275:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
190275: 
190275: #ifndef CacheIndex__h__
190275: #define CacheIndex__h__
190275: 
190275: #include "CacheLog.h"
190275: #include "CacheFileIOManager.h"
190275: #include "nsIRunnable.h"
190275: #include "CacheHashUtils.h"
196909: #include "nsICacheStorageService.h"
190275: #include "nsICacheEntry.h"
190275: #include "nsILoadContextInfo.h"
190275: #include "nsTHashtable.h"
196909: #include "nsThreadUtils.h"
196909: #include "nsWeakReference.h"
190275: #include "mozilla/SHA1.h"
190275: #include "mozilla/Mutex.h"
190275: #include "mozilla/Endian.h"
190275: #include "mozilla/TimeStamp.h"
190275: 
190275: class nsIFile;
190275: class nsIDirectoryEnumerator;
190275: class nsITimer;
190275: 
190275: 
190275: #ifdef DEBUG
190275: #define DEBUG_STATS 1
190275: #endif
190275: 
190275: namespace mozilla {
190275: namespace net {
190275: 
190275: class CacheFileMetadata;
191186: class FileOpenHelper;
197520: class CacheIndexIterator;
190275: 
190275: typedef struct {
190275:   // Version of the index. The index must be ignored and deleted when the file
190275:   // on disk was written with a newer version.
190275:   uint32_t mVersion;
190275: 
190275:   // Timestamp of time when the last successful write of the index started.
190275:   // During update process we use this timestamp for a quick validation of entry
190275:   // files. If last modified time of the file is lower than this timestamp, we
190275:   // skip parsing of such file since the information in index should be up to
190275:   // date.
190275:   uint32_t mTimeStamp;
190275: 
190275:   // We set this flag as soon as possible after parsing index during startup
190275:   // and clean it after we write journal to disk during shutdown. We ignore the
190275:   // journal and start update process whenever this flag is set during index
190275:   // parsing.
190275:   uint32_t mIsDirty;
190275: } CacheIndexHeader;
190275: 
190275: struct CacheIndexRecord {
190275:   SHA1Sum::Hash mHash;
190275:   uint32_t      mFrecency;
190275:   uint32_t      mExpirationTime;
190275:   uint32_t      mAppId;
190275: 
190275:   /*
190275:    *    1000 0000 0000 0000 0000 0000 0000 0000 : initialized
190275:    *    0100 0000 0000 0000 0000 0000 0000 0000 : anonymous
190275:    *    0010 0000 0000 0000 0000 0000 0000 0000 : inBrowser
190275:    *    0001 0000 0000 0000 0000 0000 0000 0000 : removed
190275:    *    0000 1000 0000 0000 0000 0000 0000 0000 : dirty
190275:    *    0000 0100 0000 0000 0000 0000 0000 0000 : fresh
190275:    *    0000 0011 0000 0000 0000 0000 0000 0000 : reserved
190275:    *    0000 0000 1111 1111 1111 1111 1111 1111 : file size (in kB)
190275:    */
190275:   uint32_t      mFlags;
190275: 
190275:   CacheIndexRecord()
190275:     : mFrecency(0)
190275:     , mExpirationTime(nsICacheEntry::NO_EXPIRATION_TIME)
190275:     , mAppId(nsILoadContextInfo::NO_APP_ID)
190275:     , mFlags(0)
190275:   {}
190275: };
190275: 
190275: class CacheIndexEntry : public PLDHashEntryHdr
190275: {
190275: public:
190275:   typedef const SHA1Sum::Hash& KeyType;
190275:   typedef const SHA1Sum::Hash* KeyTypePointer;
190275: 
190275:   CacheIndexEntry(KeyTypePointer aKey)
190275:   {
190275:     MOZ_COUNT_CTOR(CacheIndexEntry);
190275:     mRec = new CacheIndexRecord();
190279:     LOG(("CacheIndexEntry::CacheIndexEntry() - Created record [rec=%p]", mRec.get()));
190275:     memcpy(&mRec->mHash, aKey, sizeof(SHA1Sum::Hash));
190275:   }
190275:   CacheIndexEntry(const CacheIndexEntry& aOther)
190275:   {
190275:     NS_NOTREACHED("CacheIndexEntry copy constructor is forbidden!");
190275:   }
190275:   ~CacheIndexEntry()
190275:   {
190275:     MOZ_COUNT_DTOR(CacheIndexEntry);
190275:     LOG(("CacheIndexEntry::~CacheIndexEntry() - Deleting record [rec=%p]",
190279:          mRec.get()));
190275:   }
190275: 
190275:   // KeyEquals(): does this entry match this key?
190275:   bool KeyEquals(KeyTypePointer aKey) const
190275:   {
190275:     return memcmp(&mRec->mHash, aKey, sizeof(SHA1Sum::Hash)) == 0;
190275:   }
190275: 
190275:   // KeyToPointer(): Convert KeyType to KeyTypePointer
190275:   static KeyTypePointer KeyToPointer(KeyType aKey) { return &aKey; }
190275: 
190275:   // HashKey(): calculate the hash number
190275:   static PLDHashNumber HashKey(KeyTypePointer aKey)
190275:   {
190275:     return (reinterpret_cast<const uint32_t *>(aKey))[0];
190275:   }
190275: 
190275:   // ALLOW_MEMMOVE can we move this class with memmove(), or do we have
190275:   // to use the copy constructor?
190275:   enum { ALLOW_MEMMOVE = true };
190275: 
190275:   bool operator==(const CacheIndexEntry& aOther) const
190275:   {
190275:     return KeyEquals(&aOther.mRec->mHash);
190275:   }
190275: 
190275:   CacheIndexEntry& operator=(const CacheIndexEntry& aOther)
190275:   {
190275:     MOZ_ASSERT(memcmp(&mRec->mHash, &aOther.mRec->mHash,
190275:                sizeof(SHA1Sum::Hash)) == 0);
190275:     mRec->mFrecency = aOther.mRec->mFrecency;
190275:     mRec->mExpirationTime = aOther.mRec->mExpirationTime;
190275:     mRec->mAppId = aOther.mRec->mAppId;
190275:     mRec->mFlags = aOther.mRec->mFlags;
190275:     return *this;
190275:   }
190275: 
190275:   void InitNew()
190275:   {
190275:     mRec->mFrecency = 0;
190275:     mRec->mExpirationTime = nsICacheEntry::NO_EXPIRATION_TIME;
190275:     mRec->mAppId = nsILoadContextInfo::NO_APP_ID;
190275:     mRec->mFlags = 0;
190275:   }
190275: 
190275:   void Init(uint32_t aAppId, bool aAnonymous, bool aInBrowser)
190275:   {
190275:     MOZ_ASSERT(mRec->mFrecency == 0);
190275:     MOZ_ASSERT(mRec->mExpirationTime == nsICacheEntry::NO_EXPIRATION_TIME);
190275:     MOZ_ASSERT(mRec->mAppId == nsILoadContextInfo::NO_APP_ID);
190275:     // When we init the entry it must be fresh and may be dirty
190275:     MOZ_ASSERT((mRec->mFlags & ~kDirtyMask) == kFreshMask);
190275: 
190275:     mRec->mAppId = aAppId;
190275:     mRec->mFlags |= kInitializedMask;
190275:     if (aAnonymous) {
190275:       mRec->mFlags |= kAnonymousMask;
190275:     }
190275:     if (aInBrowser) {
190275:       mRec->mFlags |= kInBrowserMask;
190275:     }
190275:   }
190275: 
190275:   const SHA1Sum::Hash * Hash() { return &mRec->mHash; }
190275: 
190275:   bool IsInitialized() { return !!(mRec->mFlags & kInitializedMask); }
190275: 
190275:   uint32_t AppId() { return mRec->mAppId; }
190275:   bool     Anonymous() { return !!(mRec->mFlags & kAnonymousMask); }
190275:   bool     InBrowser() { return !!(mRec->mFlags & kInBrowserMask); }
190275: 
190275:   bool IsRemoved() { return !!(mRec->mFlags & kRemovedMask); }
190275:   void MarkRemoved() { mRec->mFlags |= kRemovedMask; }
190275: 
190275:   bool IsDirty() { return !!(mRec->mFlags & kDirtyMask); }
190275:   void MarkDirty() { mRec->mFlags |= kDirtyMask; }
190275:   void ClearDirty() { mRec->mFlags &= ~kDirtyMask; }
190275: 
190275:   bool IsFresh() { return !!(mRec->mFlags & kFreshMask); }
190275:   void MarkFresh() { mRec->mFlags |= kFreshMask; }
190275: 
190275:   void     SetFrecency(uint32_t aFrecency) { mRec->mFrecency = aFrecency; }
190275:   uint32_t GetFrecency() { return mRec->mFrecency; }
190275: 
190275:   void     SetExpirationTime(uint32_t aExpirationTime)
190275:   {
190275:     mRec->mExpirationTime = aExpirationTime;
190275:   }
190275:   uint32_t GetExpirationTime() { return mRec->mExpirationTime; }
190275: 
190275:   // Sets filesize in kilobytes.
190275:   void     SetFileSize(uint32_t aFileSize)
190275:   {
190275:     if (aFileSize > kFileSizeMask) {
190275:       LOG(("CacheIndexEntry::SetFileSize() - FileSize is too large, "
190275:            "truncating to %u", kFileSizeMask));
190275:       aFileSize = kFileSizeMask;
190275:     }
190275:     mRec->mFlags &= ~kFileSizeMask;
190275:     mRec->mFlags |= aFileSize;
190275:   }
190275:   // Returns filesize in kilobytes.
201508:   uint32_t GetFileSize() { return GetFileSize(mRec); }
201508:   static uint32_t GetFileSize(CacheIndexRecord *aRec)
201508:   {
201508:     return aRec->mFlags & kFileSizeMask;
201508:   }
190275:   bool     IsFileEmpty() { return GetFileSize() == 0; }
190275: 
190275:   void WriteToBuf(void *aBuf)
190275:   {
190275:     CacheIndexRecord *dst = reinterpret_cast<CacheIndexRecord *>(aBuf);
190275: 
190275:     // Copy the whole record to the buffer.
190275:     memcpy(aBuf, mRec, sizeof(CacheIndexRecord));
190275: 
190275:     // Dirty and fresh flags should never go to disk, since they make sense only
190275:     // during current session.
190275:     dst->mFlags &= ~kDirtyMask;
190275:     dst->mFlags &= ~kFreshMask;
190275: 
190275: #if defined(IS_LITTLE_ENDIAN)
190275:     // Data in the buffer are in machine byte order and we want them in network
190275:     // byte order.
190275:     NetworkEndian::writeUint32(&dst->mFrecency, dst->mFrecency);
190275:     NetworkEndian::writeUint32(&dst->mExpirationTime, dst->mExpirationTime);
190275:     NetworkEndian::writeUint32(&dst->mAppId, dst->mAppId);
190275:     NetworkEndian::writeUint32(&dst->mFlags, dst->mFlags);
190275: #endif
190275:   }
190275: 
190275:   void ReadFromBuf(void *aBuf)
190275:   {
190275:     CacheIndexRecord *src= reinterpret_cast<CacheIndexRecord *>(aBuf);
190275:     MOZ_ASSERT(memcmp(&mRec->mHash, &src->mHash,
190275:                sizeof(SHA1Sum::Hash)) == 0);
190275: 
190275:     mRec->mFrecency = NetworkEndian::readUint32(&src->mFrecency);
190275:     mRec->mExpirationTime = NetworkEndian::readUint32(&src->mExpirationTime);
190275:     mRec->mAppId = NetworkEndian::readUint32(&src->mAppId);
190275:     mRec->mFlags = NetworkEndian::readUint32(&src->mFlags);
190275:   }
190275: 
190275:   void Log() {
190275:     LOG(("CacheIndexEntry::Log() [this=%p, hash=%08x%08x%08x%08x%08x, fresh=%u,"
190275:          " initialized=%u, removed=%u, dirty=%u, anonymous=%u, inBrowser=%u, "
190275:          "appId=%u, frecency=%u, expirationTime=%u, size=%u]",
190275:          this, LOGSHA1(mRec->mHash), IsFresh(), IsInitialized(), IsRemoved(),
190275:          IsDirty(), Anonymous(), InBrowser(), AppId(), GetFrecency(),
190275:          GetExpirationTime(), GetFileSize()));
190275:   }
190275: 
197520:   static bool RecordMatchesLoadContextInfo(CacheIndexRecord *aRec,
197520:                                            nsILoadContextInfo *aInfo)
197520:   {
197520:     if (!aInfo->IsPrivate() &&
197520:         aInfo->AppId() == aRec->mAppId &&
197520:         aInfo->IsAnonymous() == !!(aRec->mFlags & kAnonymousMask) &&
197520:         aInfo->IsInBrowserElement() == !!(aRec->mFlags & kInBrowserMask)) {
197520:       return true;
197520:     }
197520: 
197520:     return false;
197520:   }
197520: 
190279:   // Memory reporting
190279:   size_t SizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf) const
190279:   {
190279:     return mallocSizeOf(mRec.get());
190279:   }
190279: 
190279:   size_t SizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf) const
190279:   {
190279:     return mallocSizeOf(this) + SizeOfExcludingThis(mallocSizeOf);
190279:   }
190279: 
190275: private:
190275:   friend class CacheIndex;
190275:   friend class CacheIndexEntryAutoManage;
190275: 
190275:   static const uint32_t kInitializedMask = 0x80000000;
190275:   static const uint32_t kAnonymousMask   = 0x40000000;
190275:   static const uint32_t kInBrowserMask   = 0x20000000;
190275: 
190275:   // This flag is set when the entry was removed. We need to keep this
190275:   // information in memory until we write the index file.
190275:   static const uint32_t kRemovedMask     = 0x10000000;
190275: 
190275:   // This flag is set when the information in memory is not in sync with the
190275:   // information in index file on disk.
190275:   static const uint32_t kDirtyMask       = 0x08000000;
190275: 
190275:   // This flag is set when the information about the entry is fresh, i.e.
190275:   // we've created or opened this entry during this session, or we've seen
190275:   // this entry during update or build process.
190275:   static const uint32_t kFreshMask       = 0x04000000;
190275: 
190275:   static const uint32_t kReservedMask    = 0x03000000;
190275: 
190275:   // FileSize in kilobytes
190275:   static const uint32_t kFileSizeMask    = 0x00FFFFFF;
190275: 
190279:   nsAutoPtr<CacheIndexRecord> mRec;
190275: };
190275: 
190275: class CacheIndexStats
190275: {
190275: public:
190275:   CacheIndexStats()
190275:     : mCount(0)
190275:     , mNotInitialized(0)
190275:     , mRemoved(0)
190275:     , mDirty(0)
190275:     , mFresh(0)
190275:     , mEmpty(0)
190275:     , mSize(0)
190275: #ifdef DEBUG
190275:     , mStateLogged(false)
190275:     , mDisableLogging(false)
190275: #endif
190275:   {
190275:   }
190275: 
190275:   bool operator==(const CacheIndexStats& aOther) const
190275:   {
190275:     return
190275: #ifdef DEBUG
190275:            aOther.mStateLogged == mStateLogged &&
190275: #endif
190275:            aOther.mCount == mCount &&
190275:            aOther.mNotInitialized == mNotInitialized &&
190275:            aOther.mRemoved == mRemoved &&
190275:            aOther.mDirty == mDirty &&
190275:            aOther.mFresh == mFresh &&
190275:            aOther.mEmpty == mEmpty &&
190275:            aOther.mSize == mSize;
190275:   }
190275: 
190275: #ifdef DEBUG
190275:   void DisableLogging() {
190275:     mDisableLogging = true;
190275:   }
190275: #endif
190275: 
190275:   void Log() {
190275:     LOG(("CacheIndexStats::Log() [count=%u, notInitialized=%u, removed=%u, "
191186:          "dirty=%u, fresh=%u, empty=%u, size=%u]", mCount, mNotInitialized,
190275:          mRemoved, mDirty, mFresh, mEmpty, mSize));
190275:   }
190275: 
191186:   void Clear() {
191186:     MOZ_ASSERT(!mStateLogged, "CacheIndexStats::Clear() - state logged!");
191186: 
191186:     mCount = 0;
191186:     mNotInitialized = 0;
191186:     mRemoved = 0;
191186:     mDirty = 0;
191186:     mFresh = 0;
191186:     mEmpty = 0;
191186:     mSize = 0;
191186:   }
191186: 
190275: #ifdef DEBUG
190275:   bool StateLogged() {
190275:     return mStateLogged;
190275:   }
190275: #endif
190275: 
190275:   uint32_t Count() {
190275:     MOZ_ASSERT(!mStateLogged, "CacheIndexStats::Count() - state logged!");
190275:     return mCount;
190275:   }
190275: 
190275:   uint32_t Dirty() {
190275:     MOZ_ASSERT(!mStateLogged, "CacheIndexStats::Dirty() - state logged!");
190275:     return mDirty;
190275:   }
190275: 
190275:   uint32_t Fresh() {
190275:     MOZ_ASSERT(!mStateLogged, "CacheIndexStats::Fresh() - state logged!");
190275:     return mFresh;
190275:   }
190275: 
190275:   uint32_t ActiveEntriesCount() {
190275:     MOZ_ASSERT(!mStateLogged, "CacheIndexStats::ActiveEntriesCount() - state "
190275:                "logged!");
190275:     return mCount - mRemoved - mNotInitialized - mEmpty;
190275:   }
190275: 
190276:   uint32_t Size() {
190275:     MOZ_ASSERT(!mStateLogged, "CacheIndexStats::Size() - state logged!");
190275:     return mSize;
190275:   }
190275: 
190275:   void BeforeChange(CacheIndexEntry *aEntry) {
190275: #ifdef DEBUG_STATS
190275:     if (!mDisableLogging) {
190275:       LOG(("CacheIndexStats::BeforeChange()"));
190275:       Log();
190275:     }
190275: #endif
190275: 
190275:     MOZ_ASSERT(!mStateLogged, "CacheIndexStats::BeforeChange() - state "
190275:                "logged!");
190275: #ifdef DEBUG
190275:     mStateLogged = true;
190275: #endif
190275:     if (aEntry) {
190275:       MOZ_ASSERT(mCount);
190275:       mCount--;
190275:       if (aEntry->IsDirty()) {
190275:         MOZ_ASSERT(mDirty);
190275:         mDirty--;
190275:       }
190275:       if (aEntry->IsFresh()) {
190275:         MOZ_ASSERT(mFresh);
190275:         mFresh--;
190275:       }
190275:       if (aEntry->IsRemoved()) {
190275:         MOZ_ASSERT(mRemoved);
190275:         mRemoved--;
190275:       } else {
190275:         if (!aEntry->IsInitialized()) {
190275:           MOZ_ASSERT(mNotInitialized);
190275:           mNotInitialized--;
190275:         } else {
190275:           if (aEntry->IsFileEmpty()) {
190275:             MOZ_ASSERT(mEmpty);
190275:             mEmpty--;
190275:           } else {
190276:             MOZ_ASSERT(mSize >= aEntry->GetFileSize());
190275:             mSize -= aEntry->GetFileSize();
190275:           }
190275:         }
190275:       }
190275:     }
190275:   }
190275: 
190275:   void AfterChange(CacheIndexEntry *aEntry) {
190275:     MOZ_ASSERT(mStateLogged, "CacheIndexStats::AfterChange() - state not "
190275:                "logged!");
190275: #ifdef DEBUG
190275:     mStateLogged = false;
190275: #endif
190275:     if (aEntry) {
190275:       ++mCount;
190275:       if (aEntry->IsDirty()) {
190275:         mDirty++;
190275:       }
190275:       if (aEntry->IsFresh()) {
190275:         mFresh++;
190275:       }
190275:       if (aEntry->IsRemoved()) {
190275:         mRemoved++;
190275:       } else {
190275:         if (!aEntry->IsInitialized()) {
190275:           mNotInitialized++;
190275:         } else {
190275:           if (aEntry->IsFileEmpty()) {
190275:             mEmpty++;
190275:           } else {
190275:             mSize += aEntry->GetFileSize();
190275:           }
190275:         }
190275:       }
190275:     }
190275: 
190275: #ifdef DEBUG_STATS
190275:     if (!mDisableLogging) {
190275:       LOG(("CacheIndexStats::AfterChange()"));
190275:       Log();
190275:     }
190275: #endif
190275:   }
190275: 
190275: private:
190275:   uint32_t mCount;
190275:   uint32_t mNotInitialized;
190275:   uint32_t mRemoved;
190275:   uint32_t mDirty;
190275:   uint32_t mFresh;
190275:   uint32_t mEmpty;
190276:   uint32_t mSize;
190275: #ifdef DEBUG
190275:   // We completely remove the data about an entry from the stats in
190275:   // BeforeChange() and set this flag to true. The entry is then modified,
190275:   // deleted or created and the data is again put into the stats and this flag
190275:   // set to false. Statistics must not be read during this time since the
190275:   // information is not correct.
190275:   bool     mStateLogged;
190275: 
190275:   // Disables logging in this instance of CacheIndexStats
190275:   bool     mDisableLogging;
190275: #endif
190275: };
190275: 
190275: class CacheIndex : public CacheFileIOListener
190275:                  , public nsIRunnable
190275: {
190275: public:
190275:   NS_DECL_THREADSAFE_ISUPPORTS
190275:   NS_DECL_NSIRUNNABLE
190275: 
190275:   CacheIndex();
190275: 
190275:   static nsresult Init(nsIFile *aCacheDirectory);
190275:   static nsresult PreShutdown();
190275:   static nsresult Shutdown();
190275: 
190275:   // Following methods can be called only on IO thread.
190275: 
190275:   // Add entry to the index. The entry shouldn't be present in index. This
190275:   // method is called whenever a new handle for a new entry file is created. The
190275:   // newly created entry is not initialized and it must be either initialized
190275:   // with InitEntry() or removed with RemoveEntry().
190275:   static nsresult AddEntry(const SHA1Sum::Hash *aHash);
190275: 
190275:   // Inform index about an existing entry that should be present in index. This
190275:   // method is called whenever a new handle for an existing entry file is
190275:   // created. Like in case of AddEntry(), either InitEntry() or RemoveEntry()
190275:   // must be called on the entry, since the entry is not initizlized if the
190275:   // index is outdated.
190275:   static nsresult EnsureEntryExists(const SHA1Sum::Hash *aHash);
190275: 
190275:   // Initialize the entry. It MUST be present in index. Call to AddEntry() or
190275:   // EnsureEntryExists() must precede the call to this method.
190275:   static nsresult InitEntry(const SHA1Sum::Hash *aHash,
190275:                             uint32_t             aAppId,
190275:                             bool                 aAnonymous,
190275:                             bool                 aInBrowser);
190275: 
190275:   // Remove entry from index. The entry should be present in index.
190275:   static nsresult RemoveEntry(const SHA1Sum::Hash *aHash);
190275: 
190275:   // Update some information in entry. The entry MUST be present in index and
190275:   // MUST be initialized. Call to AddEntry() or EnsureEntryExists() and to
190275:   // InitEntry() must precede the call to this method.
190275:   // Pass nullptr if the value didn't change.
190275:   static nsresult UpdateEntry(const SHA1Sum::Hash *aHash,
190275:                               const uint32_t      *aFrecency,
190275:                               const uint32_t      *aExpirationTime,
190275:                               const uint32_t      *aSize);
190275: 
191186:   // Remove all entries from the index. Called when clearing the whole cache.
191186:   static nsresult RemoveAll();
191186: 
190275:   enum EntryStatus {
190275:     EXISTS         = 0,
190275:     DOES_NOT_EXIST = 1,
190275:     DO_NOT_KNOW    = 2
190275:   };
190275: 
190275:   // Returns status of the entry in index for the given key. It can be called
190275:   // on any thread.
190275:   static nsresult HasEntry(const nsACString &aKey, EntryStatus *_retval);
190275: 
190276:   // Returns a hash of the least important entry that should be evicted if the
190276:   // cache size is over limit and also returns a total number of all entries in
218369:   // the index.
190276:   static nsresult GetEntryForEviction(SHA1Sum::Hash *aHash, uint32_t *aCnt);
190276: 
190276:   // Returns cache size in kB.
190276:   static nsresult GetCacheSize(uint32_t *_retval);
190276: 
201508:   // Synchronously returns the disk occupation and number of entries per-context.
201508:   // Callable on any thread.
201508:   static nsresult GetCacheStats(nsILoadContextInfo *aInfo, uint32_t *aSize, uint32_t *aCount);
201508: 
196909:   // Asynchronously gets the disk cache size, used for display in the UI.
196909:   static nsresult AsyncGetDiskConsumption(nsICacheStorageConsumptionObserver* aObserver);
196909: 
197520:   // Returns an iterator that returns entries matching a given context that were
197520:   // present in the index at the time this method was called. If aAddNew is true
197520:   // then the iterator will also return entries created after this call.
197520:   // NOTE: When some entry is removed from index it is removed also from the
197520:   // iterator regardless what aAddNew was passed.
197520:   static nsresult GetIterator(nsILoadContextInfo *aInfo, bool aAddNew,
197520:                               CacheIndexIterator **_retval);
197520: 
197520:   // Returns true if we _think_ that the index is up to date. I.e. the state is
197520:   // READY or WRITING and mIndexNeedsUpdate as well as mShuttingDown is false.
197520:   static nsresult IsUpToDate(bool *_retval);
197520: 
190279:   // Memory reporting
190279:   static size_t SizeOfExcludingThis(mozilla::MallocSizeOf mallocSizeOf);
190279:   static size_t SizeOfIncludingThis(mozilla::MallocSizeOf mallocSizeOf);
190276: 
190275: private:
190275:   friend class CacheIndexEntryAutoManage;
190275:   friend class CacheIndexAutoLock;
190275:   friend class CacheIndexAutoUnlock;
191186:   friend class FileOpenHelper;
197520:   friend class CacheIndexIterator;
190275: 
190275:   virtual ~CacheIndex();
190275: 
190275:   NS_IMETHOD OnFileOpened(CacheFileHandle *aHandle, nsresult aResult);
191186:   nsresult   OnFileOpenedInternal(FileOpenHelper *aOpener,
191186:                                   CacheFileHandle *aHandle, nsresult aResult);
190275:   NS_IMETHOD OnDataWritten(CacheFileHandle *aHandle, const char *aBuf,
190275:                            nsresult aResult);
190275:   NS_IMETHOD OnDataRead(CacheFileHandle *aHandle, char *aBuf, nsresult aResult);
190275:   NS_IMETHOD OnFileDoomed(CacheFileHandle *aHandle, nsresult aResult);
190275:   NS_IMETHOD OnEOFSet(CacheFileHandle *aHandle, nsresult aResult);
190275:   NS_IMETHOD OnFileRenamed(CacheFileHandle *aHandle, nsresult aResult);
190275: 
190275:   void     Lock();
190275:   void     Unlock();
190275:   void     AssertOwnsLock();
190275: 
190275:   nsresult InitInternal(nsIFile *aCacheDirectory);
190275:   void     PreShutdownInternal();
190275: 
190275:   // This method returns false when index is not initialized or is shut down.
190275:   bool IsIndexUsable();
190275: 
190275:   // This method checks whether the entry has the same values of appId,
190275:   // isAnonymous and isInBrowser. We don't expect to find a collision since
190275:   // these values are part of the key that we hash and we use a strong hash
190275:   // function.
190275:   static bool IsCollision(CacheIndexEntry *aEntry,
190275:                           uint32_t         aAppId,
190275:                           bool             aAnonymous,
190275:                           bool             aInBrowser);
190275: 
190275:   // Checks whether any of the information about the entry has changed.
190275:   static bool HasEntryChanged(CacheIndexEntry *aEntry,
190275:                               const uint32_t  *aFrecency,
190275:                               const uint32_t  *aExpirationTime,
190275:                               const uint32_t  *aSize);
190275: 
190275:   // Merge all pending operations from mPendingUpdates into mIndex.
190275:   void ProcessPendingOperations();
190275:   static PLDHashOperator UpdateEntryInIndex(CacheIndexEntry *aEntry,
190275:                                             void* aClosure);
190275: 
190275:   // Following methods perform writing of the index file.
190275:   //
190275:   // The index is written periodically, but not earlier than once in
190275:   // kMinDumpInterval and there must be at least kMinUnwrittenChanges
190275:   // differences between index on disk and in memory. Index is always first
190275:   // written to a temporary file and the old index file is replaced when the
190275:   // writing process succeeds.
190275:   //
190275:   // Starts writing of index when both limits (minimal delay between writes and
190275:   // minimum number of changes in index) were exceeded.
190275:   bool WriteIndexToDiskIfNeeded();
190275:   // Starts writing of index file.
190275:   void WriteIndexToDisk();
190275:   // Serializes part of mIndex hashtable to the write buffer a writes the buffer
190275:   // to the file.
190275:   void WriteRecords();
190275:   // Finalizes writing process.
190275:   void FinishWrite(bool aSucceeded);
190275: 
190275:   static PLDHashOperator CopyRecordsToRWBuf(CacheIndexEntry *aEntry,
190275:                                             void* aClosure);
190275:   static PLDHashOperator ApplyIndexChanges(CacheIndexEntry *aEntry,
190275:                                            void* aClosure);
190275: 
190275:   // Following methods perform writing of the journal during shutdown. All these
190275:   // methods must be called only during shutdown since they write/delete files
190275:   // directly on the main thread instead of using CacheFileIOManager that does
190275:   // it asynchronously on IO thread. Journal contains only entries that are
190275:   // dirty, i.e. changes that are not present in the index file on the disk.
190275:   // When the log is written successfully, the dirty flag in index file is
190275:   // cleared.
190275:   nsresult GetFile(const nsACString &aName, nsIFile **_retval);
190275:   nsresult RemoveFile(const nsACString &aName);
190275:   void     RemoveIndexFromDisk();
190275:   // Writes journal to the disk and clears dirty flag in index header.
190275:   nsresult WriteLogToDisk();
190275: 
190275:   static PLDHashOperator WriteEntryToLog(CacheIndexEntry *aEntry,
190275:                                          void* aClosure);
190275: 
190275:   // Following methods perform reading of the index from the disk.
190275:   //
190275:   // Index is read at startup just after initializing the CacheIndex. There are
190275:   // 3 files used when manipulating with index: index file, journal file and
190275:   // a temporary file. All files contain the hash of the data, so we can check
190275:   // whether the content is valid and complete. Index file contains also a dirty
190275:   // flag in the index header which is unset on a clean shutdown. During opening
190275:   // and reading of the files we determine the status of the whole index from
190275:   // the states of the separate files. Following table shows all possible
190275:   // combinations:
190275:   //
190275:   // index, journal, tmpfile
190275:   // M      *        *       - index is missing    -> BUILD
190275:   // I      *        *       - index is invalid    -> BUILD
190275:   // D      *        *       - index is dirty      -> UPDATE
190275:   // C      M        *       - index is dirty      -> UPDATE
190275:   // C      I        *       - unexpected state    -> UPDATE
190275:   // C      V        E       - unexpected state    -> UPDATE
190275:   // C      V        M       - index is up to date -> READY
190275:   //
190275:   // where the letters mean:
190275:   //   * - any state
190275:   //   E - file exists
190275:   //   M - file is missing
190275:   //   I - data is invalid (parsing failed or hash didn't match)
190275:   //   D - dirty (data in index file is correct, but dirty flag is set)
190275:   //   C - clean (index file is clean)
190275:   //   V - valid (data in journal file is correct)
190275:   //
190275:   // Note: We accept the data from journal only when the index is up to date as
190275:   // a whole (i.e. C,V,M state).
190275:   //
190275:   // We rename the journal file to the temporary file as soon as possible after
190275:   // initial test to ensure that we start update process on the next startup if
190275:   // FF crashes during parsing of the index.
190275:   //
190275:   // Initiates reading index from disk.
190275:   void ReadIndexFromDisk();
190275:   // Starts reading data from index file.
190275:   void StartReadingIndex();
190275:   // Parses data read from index file.
190275:   void ParseRecords();
190275:   // Starts reading data from journal file.
190275:   void StartReadingJournal();
190275:   // Parses data read from journal file.
190275:   void ParseJournal();
190275:   // Merges entries from journal into mIndex.
190275:   void MergeJournal();
190275:   // In debug build this method checks that we have no fresh entry in mIndex
190275:   // after we finish reading index and before we process pending operations.
190275:   void EnsureNoFreshEntry();
190275:   // In debug build this method is called after processing pending operations
190275:   // to make sure mIndexStats contains correct information.
190275:   void EnsureCorrectStats();
190275:   static PLDHashOperator SumIndexStats(CacheIndexEntry *aEntry, void* aClosure);
190275:   // Finalizes reading process.
190275:   void FinishRead(bool aSucceeded);
190275: 
190275:   static PLDHashOperator ProcessJournalEntry(CacheIndexEntry *aEntry,
190275:                                              void* aClosure);
190275: 
190275:   // Following methods perform updating and building of the index.
190275:   // Timer callback that starts update or build process.
191186:   static void DelayedUpdate(nsITimer *aTimer, void *aClosure);
190275:   // Posts timer event that start update or build process.
191186:   nsresult ScheduleUpdateTimer(uint32_t aDelay);
190275:   nsresult SetupDirectoryEnumerator();
190275:   void InitEntryFromDiskData(CacheIndexEntry *aEntry,
190275:                              CacheFileMetadata *aMetaData,
190275:                              int64_t aFileSize);
191186:   // Returns true when either a timer is scheduled or event is posted.
191186:   bool IsUpdatePending();
190275:   // Iterates through all files in entries directory that we didn't create/open
190275:   // during this session, parses them and adds the entries to the index.
190275:   void BuildIndex();
190275: 
190275:   bool StartUpdatingIndexIfNeeded(bool aSwitchingToReadyState = false);
191186:   // Starts update or build process or fires a timer when it is too early after
191186:   // startup.
191186:   void StartUpdatingIndex(bool aRebuild);
190275:   // Iterates through all files in entries directory that we didn't create/open
190275:   // during this session and theirs last modified time is newer than timestamp
190275:   // in the index header. Parses the files and adds the entries to the index.
190275:   void UpdateIndex();
191186:   // Finalizes update or build process.
190275:   void FinishUpdate(bool aSucceeded);
190275: 
190275:   static PLDHashOperator RemoveNonFreshEntries(CacheIndexEntry *aEntry,
190275:                                                void* aClosure);
190275: 
190275:   enum EState {
190275:     // Initial state in which the index is not usable
190275:     // Possible transitions:
190275:     //  -> READING
190275:     INITIAL  = 0,
190275: 
190275:     // Index is being read from the disk.
190275:     // Possible transitions:
190275:     //  -> INITIAL  - We failed to dispatch a read event.
190275:     //  -> BUILDING - No or corrupted index file was found.
190275:     //  -> UPDATING - No or corrupted journal file was found.
190275:     //              - Dirty flag was set in index header.
190275:     //  -> READY    - Index was read successfully or was interrupted by
190275:     //                pre-shutdown.
190275:     //  -> SHUTDOWN - This could happen only in case of pre-shutdown failure.
190275:     READING  = 1,
190275: 
190275:     // Index is being written to the disk.
190275:     // Possible transitions:
190275:     //  -> READY    - Writing of index finished or was interrupted by
190275:     //                pre-shutdown..
190275:     //  -> UPDATING - Writing of index finished, but index was found outdated
190275:     //                during writing.
190275:     //  -> SHUTDOWN - This could happen only in case of pre-shutdown failure.
190275:     WRITING  = 2,
190275: 
190275:     // Index is being build.
190275:     // Possible transitions:
190275:     //  -> READY    - Building of index finished or was interrupted by
190275:     //                pre-shutdown.
190275:     //  -> SHUTDOWN - This could happen only in case of pre-shutdown failure.
190275:     BUILDING = 3,
190275: 
190275:     // Index is being updated.
190275:     // Possible transitions:
190275:     //  -> READY    - Updating of index finished or was interrupted by
190275:     //                pre-shutdown.
190275:     //  -> SHUTDOWN - This could happen only in case of pre-shutdown failure.
190275:     UPDATING = 4,
190275: 
190275:     // Index is ready.
190275:     // Possible transitions:
190275:     //  -> UPDATING - Index was found outdated.
190275:     //  -> SHUTDOWN - Index is shutting down.
190275:     READY    = 5,
190275: 
190275:     // Index is shutting down.
190275:     SHUTDOWN = 6
190275:   };
190275: 
190275: #ifdef PR_LOGGING
190275:   static char const * StateString(EState aState);
190275: #endif
190275:   void ChangeState(EState aNewState);
190275: 
190275:   // Allocates and releases buffer used for reading and writing index.
190275:   void AllocBuffer();
190275:   void ReleaseBuffer();
190275: 
190275:   // Methods used by CacheIndexEntryAutoManage to keep the arrays up to date.
190275:   void InsertRecordToFrecencyArray(CacheIndexRecord *aRecord);
190275:   void InsertRecordToExpirationArray(CacheIndexRecord *aRecord);
190275:   void RemoveRecordFromFrecencyArray(CacheIndexRecord *aRecord);
190275:   void RemoveRecordFromExpirationArray(CacheIndexRecord *aRecord);
190275: 
197520:   // Methods used by CacheIndexEntryAutoManage to keep the iterators up to date.
197520:   void AddRecordToIterators(CacheIndexRecord *aRecord);
197520:   void RemoveRecordFromIterators(CacheIndexRecord *aRecord);
197520:   void ReplaceRecordInIterators(CacheIndexRecord *aOldRecord,
197520:                                 CacheIndexRecord *aNewRecord);
197520: 
190279:   // Memory reporting (private part)
190279:   size_t SizeOfExcludingThisInternal(mozilla::MallocSizeOf mallocSizeOf) const;
190279: 
190275:   static CacheIndex *gInstance;
190275: 
190275:   nsCOMPtr<nsIFile> mCacheDirectory;
190275: 
190275:   mozilla::Mutex mLock;
190275:   EState         mState;
190275:   // Timestamp of time when the index was initialized. We use it to delay
190275:   // initial update or build of index.
190275:   TimeStamp      mStartTime;
190275:   // Set to true in PreShutdown(), it is checked on variaous places to prevent
190275:   // starting any process (write, update, etc.) during shutdown.
190275:   bool           mShuttingDown;
190275:   // When set to true, update process should start as soon as possible. This
190275:   // flag is set whenever we find some inconsistency which would be fixed by
190275:   // update process. The flag is checked always when switching to READY state.
190275:   // To make sure we start the update process as soon as possible, methods that
190275:   // set this flag should also call StartUpdatingIndexIfNeeded() to cover the
190275:   // case when we are currently in READY state.
190275:   bool           mIndexNeedsUpdate;
191186:   // Set at the beginning of RemoveAll() which clears the whole index. When
191186:   // removing all entries we must stop any pending reading, writing, updating or
191186:   // building operation. This flag is checked at various places and it prevents
191186:   // we won't start another operation (e.g. canceling reading of the index would
191186:   // normally start update or build process)
191186:   bool           mRemovingAll;
190275:   // Whether the index file on disk exists and is valid.
190275:   bool           mIndexOnDiskIsValid;
190275:   // When something goes wrong during updating or building process, we don't
190275:   // mark index clean (and also don't write journal) to ensure that update or
190275:   // build will be initiated on the next start.
190275:   bool           mDontMarkIndexClean;
190275:   // Timestamp value from index file. It is used during update process to skip
190275:   // entries that were last modified before this timestamp.
190275:   uint32_t       mIndexTimeStamp;
190275:   // Timestamp of last time the index was dumped to disk.
190275:   // NOTE: The index might not be necessarily dumped at this time. The value
190275:   // is used to schedule next dump of the index.
190275:   TimeStamp      mLastDumpTime;
190275: 
190275:   // Timer of delayed update/build.
191186:   nsCOMPtr<nsITimer> mUpdateTimer;
191186:   // True when build or update event is posted
191186:   bool               mUpdateEventPending;
190275: 
190275:   // Helper members used when reading/writing index from/to disk.
190275:   // Contains number of entries that should be skipped:
190275:   //  - in hashtable when writing index because they were already written
190275:   //  - in index file when reading index because they were already read
190275:   uint32_t                  mSkipEntries;
190275:   // Number of entries that should be written to disk. This is number of entries
190275:   // in hashtable that are initialized and are not marked as removed when writing
190275:   // begins.
190275:   uint32_t                  mProcessEntries;
190275:   char                     *mRWBuf;
190275:   uint32_t                  mRWBufSize;
190275:   uint32_t                  mRWBufPos;
190275:   nsRefPtr<CacheHash>       mRWHash;
190275: 
190275:   // Reading of journal succeeded if true.
190275:   bool                      mJournalReadSuccessfully;
190275: 
190275:   // Handle used for writing and reading index file.
190275:   nsRefPtr<CacheFileHandle> mIndexHandle;
190275:   // Handle used for reading journal file.
190275:   nsRefPtr<CacheFileHandle> mJournalHandle;
191186:   // Used to check the existence of the file during reading process.
191186:   nsRefPtr<CacheFileHandle> mTmpHandle;
191186: 
191186:   nsRefPtr<FileOpenHelper>  mIndexFileOpener;
191186:   nsRefPtr<FileOpenHelper>  mJournalFileOpener;
191186:   nsRefPtr<FileOpenHelper>  mTmpFileOpener;
190275: 
190275:   // Directory enumerator used when building and updating index.
190275:   nsCOMPtr<nsIDirectoryEnumerator> mDirEnumerator;
190275: 
190275:   // Main index hashtable.
190275:   nsTHashtable<CacheIndexEntry> mIndex;
190275: 
190275:   // We cannot add, remove or change any entry in mIndex in states READING and
190275:   // WRITING. We track all changes in mPendingUpdates during these states.
190275:   nsTHashtable<CacheIndexEntry> mPendingUpdates;
190275: 
190275:   // Contains information statistics for mIndex + mPendingUpdates.
190275:   CacheIndexStats               mIndexStats;
190275: 
190275:   // When reading journal, we must first parse the whole file and apply the
190275:   // changes iff the journal was read successfully. mTmpJournal is used to store
190275:   // entries from the journal file. We throw away all these entries if parsing
190275:   // of the journal fails or the hash does not match.
190275:   nsTHashtable<CacheIndexEntry> mTmpJournal;
190275: 
190275:   // Arrays that keep entry records ordered by eviction preference. When looking
190275:   // for an entry to evict, we first try to find an expired entry. If there is
190275:   // no expired entry, we take the entry with lowest valid frecency. Zero
190275:   // frecency is an initial value and such entries are stored at the end of the
190275:   // array. Uninitialized entries and entries marked as deleted are not present
190275:   // in these arrays.
190275:   nsTArray<CacheIndexRecord *>  mFrecencyArray;
190275:   nsTArray<CacheIndexRecord *>  mExpirationArray;
196909: 
197520:   nsTArray<CacheIndexIterator *> mIterators;
197520: 
196909:   class DiskConsumptionObserver : public nsRunnable
196909:   {
196909:   public:
196909:     static DiskConsumptionObserver* Init(nsICacheStorageConsumptionObserver* aObserver)
196909:     {
196909:       nsWeakPtr observer = do_GetWeakReference(aObserver);
196909:       if (!observer)
196909:         return nullptr;
196909: 
196909:       return new DiskConsumptionObserver(observer);
196909:     }
196909: 
196909:     void OnDiskConsumption(int64_t aSize)
196909:     {
196909:       mSize = aSize;
196909:       NS_DispatchToMainThread(this);
196909:     }
196909: 
196909:   private:
196909:     DiskConsumptionObserver(nsWeakPtr const &aWeakObserver)
196909:       : mObserver(aWeakObserver) { }
196909:     virtual ~DiskConsumptionObserver() { }
196909: 
196909:     NS_IMETHODIMP Run()
196909:     {
196909:       MOZ_ASSERT(NS_IsMainThread());
196909: 
196909:       nsCOMPtr<nsICacheStorageConsumptionObserver> observer =
196909:         do_QueryReferent(mObserver);
196909: 
196909:       if (observer) {
196909:         observer->OnNetworkCacheDiskConsumption(mSize);
196909:       }
196909: 
196909:       return NS_OK;
196909:     }
196909: 
196909:     nsWeakPtr mObserver;
196909:     int64_t mSize;
196909:   };
196909: 
196909:   // List of async observers that want to get disk consumption information
196909:   nsTArray<nsRefPtr<DiskConsumptionObserver> > mDiskConsumptionObservers;
190275: };
190275: 
197520: class CacheIndexAutoLock {
197520: public:
197520:   CacheIndexAutoLock(CacheIndex *aIndex)
197520:     : mIndex(aIndex)
197520:     , mLocked(true)
197520:   {
197520:     mIndex->Lock();
197520:   }
197520:   ~CacheIndexAutoLock()
197520:   {
197520:     if (mLocked) {
197520:       mIndex->Unlock();
197520:     }
197520:   }
197520:   void Lock()
197520:   {
197520:     MOZ_ASSERT(!mLocked);
197520:     mIndex->Lock();
197520:     mLocked = true;
197520:   }
197520:   void Unlock()
197520:   {
197520:     MOZ_ASSERT(mLocked);
197520:     mIndex->Unlock();
197520:     mLocked = false;
197520:   }
197520: 
197520: private:
197520:   nsRefPtr<CacheIndex> mIndex;
197520:   bool mLocked;
197520: };
197520: 
197520: class CacheIndexAutoUnlock {
197520: public:
197520:   CacheIndexAutoUnlock(CacheIndex *aIndex)
197520:     : mIndex(aIndex)
197520:     , mLocked(false)
197520:   {
197520:     mIndex->Unlock();
197520:   }
197520:   ~CacheIndexAutoUnlock()
197520:   {
197520:     if (!mLocked) {
197520:       mIndex->Lock();
197520:     }
197520:   }
197520:   void Lock()
197520:   {
197520:     MOZ_ASSERT(!mLocked);
197520:     mIndex->Lock();
197520:     mLocked = true;
197520:   }
197520:   void Unlock()
197520:   {
197520:     MOZ_ASSERT(mLocked);
197520:     mIndex->Unlock();
197520:     mLocked = false;
197520:   }
197520: 
197520: private:
197520:   nsRefPtr<CacheIndex> mIndex;
197520:   bool mLocked;
197520: };
190275: 
190275: } // net
190275: } // mozilla
190275: 
190275: #endif
