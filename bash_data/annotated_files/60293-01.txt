    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Daniel Glazman <glazman@netscape.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
39425:  *   Mats Palmgren <matspal@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "pratom.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMNSHTMLElement.h"
48083: #include "nsIDOMEventTarget.h"
48083: #include "nsIDOMNSEvent.h"
 1418: #include "nsPIDOMEventTarget.h"
41886: #include "nsIMEStateManager.h"
41886: #include "nsFocusManager.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsReadableUtils.h"
    1: 
    1: #include "nsIDOMText.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMDocumentFragment.h"
    1: #include "nsIDOMNamedNodeMap.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIDOMHTMLBRElement.h"
43715: #include "nsIDOMEventTarget.h"
    1: #include "nsIDocument.h"
    1: #include "nsITransactionManager.h"
    1: #include "nsIAbsorbingTransaction.h"
    1: #include "nsIPresShell.h"
    1: #include "nsISelection.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsISelectionController.h"
    1: #include "nsIEnumerator.h"
41743: #include "nsEditProperty.h"
    1: #include "nsIAtom.h"
15969: #include "nsCaret.h"
    1: #include "nsIWidget.h"
    1: #include "nsIPlaintextEditor.h"
43438: #include "nsIPrivateDOMEvent.h"
43438: #include "nsGUIEvent.h"
    1: 
    1: #include "nsIFrame.h"  // Needed by IME code
    1: 
42163: #include "nsCSSStyleSheet.h"
    1: 
    1: #include "nsIContent.h"
    1: #include "nsServiceManagerUtils.h"
    1: 
    1: // transactions the editor knows how to build
    1: #include "EditAggregateTxn.h"
    1: #include "PlaceholderTxn.h"
    1: #include "ChangeAttributeTxn.h"
    1: #include "CreateElementTxn.h"
    1: #include "InsertElementTxn.h"
    1: #include "DeleteElementTxn.h"
    1: #include "InsertTextTxn.h"
    1: #include "DeleteTextTxn.h"
    1: #include "DeleteRangeTxn.h"
    1: #include "SplitElementTxn.h"
    1: #include "JoinElementTxn.h"
    1: #include "nsStyleSheetTxns.h"
    1: #include "IMETextTxn.h"
20592: #include "nsString.h"
    1: 
    1: #include "nsEditor.h"
    1: #include "nsEditorUtils.h"
39014: #include "nsEditorEventListener.h"
    1: #include "nsISelectionDisplay.h"
    1: #include "nsIInlineSpellChecker.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIParserService.h"
    1: 
36983: #include "nsITransferable.h"
42574: #include "nsComputedDOMStyle.h"
53730: #include "nsTextEditUtils.h"
36983: 
42480: #include "mozilla/FunctionTimer.h"
42480: 
    1: #define NS_ERROR_EDITOR_NO_SELECTION NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_EDITOR,1)
    1: #define NS_ERROR_EDITOR_NO_TEXTNODE  NS_ERROR_GENERATE_FAILURE(NS_ERROR_MODULE_EDITOR,2)
    1: 
    1: #ifdef NS_DEBUG_EDITOR
    1: static PRBool gNoisy = PR_FALSE;
    1: #endif
    1: 
43713: #ifdef DEBUG
43713: #include "nsIDOMHTMLDocument.h"
43713: #endif
43713: 
    1: 
    1: // Defined in nsEditorRegistration.cpp
    1: extern nsIParserService *sParserService;
    1: 
    1: //---------------------------------------------------------------------------
    1: //
    1: // nsEditor: base editor class implementation
    1: //
    1: //---------------------------------------------------------------------------
    1: 
    1: nsEditor::nsEditor()
    1: :  mModCount(0)
51224: ,  mFlags(0)
    1: ,  mPresShellWeak(nsnull)
    1: ,  mUpdateCount(0)
    1: ,  mSpellcheckCheckboxState(eTriUnset)
    1: ,  mPlaceHolderTxn(nsnull)
    1: ,  mPlaceHolderName(nsnull)
    1: ,  mPlaceHolderBatch(0)
    1: ,  mSelState(nsnull)
    1: ,  mSavedSel()
    1: ,  mRangeUpdater()
    1: ,  mAction(nsnull)
    1: ,  mDirection(eNone)
    1: ,  mIMETextNode(nsnull)
    1: ,  mIMETextOffset(0)
    1: ,  mIMEBufferLength(0)
    1: ,  mInIMEMode(PR_FALSE)
    1: ,  mIsIMEComposing(PR_FALSE)
    1: ,  mShouldTxnSetSelection(PR_TRUE)
    1: ,  mDidPreDestroy(PR_FALSE)
    1: ,  mDocDirtyState(-1)
    1: ,  mDocWeak(nsnull)
    1: ,  mPhonetic(nsnull)
59460: ,  mLastKeypressEventWasTrusted(eTriUnset)
    1: {
    1:   //initialize member variables here
    1: }
    1: 
    1: nsEditor::~nsEditor()
    1: {
40720:   NS_ASSERTION(!mDocWeak || mDidPreDestroy, "Why PreDestroy hasn't been called?");
40720: 
13021:   mTxnMgr = nsnull;
    1: 
    1:   delete mPhonetic;
    1: }
    1: 
28153: NS_IMPL_CYCLE_COLLECTION_CLASS(nsEditor)
28153: 
28153: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsEditor)
28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mRootElement)
28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mInlineSpellChecker)
28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mTxnMgr)
28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mIMETextRangeList)
28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mIMETextNode)
28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mActionListeners)
28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mEditorObservers)
28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mDocStateListeners)
28153:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mEventTarget)
39014:  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mEventListener)
28153: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
28153: 
28153: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsEditor)
28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRootElement)
28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mInlineSpellChecker)
28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mTxnMgr)
28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mIMETextRangeList)
28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mIMETextNode)
28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mActionListeners)
28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mEditorObservers)
28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mDocStateListeners)
28153:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEventTarget)
39014:  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEventListener)
28153: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
28153: 
28153: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsEditor)
59460:  NS_INTERFACE_MAP_ENTRY(nsIEditor_MOZILLA_2_0_BRANCH)
28153:  NS_INTERFACE_MAP_ENTRY(nsIPhonetic)
28153:  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
28153:  NS_INTERFACE_MAP_ENTRY(nsIEditorIMESupport)
28153:  NS_INTERFACE_MAP_ENTRY(nsIEditor)
28153:  NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIEditor)
28153: NS_INTERFACE_MAP_END
28153: 
28153: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsEditor, nsIEditor)
28153: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsEditor, nsIEditor)
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsIEditorMethods 
    1: #pragma mark -
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::Init(nsIDOMDocument *aDoc, nsIPresShell* aPresShell, nsIContent *aRoot, nsISelectionController *aSelCon, PRUint32 aFlags)
    1: {
56879:   NS_PRECONDITION(aDoc && aPresShell, "bad arg");
56879:   if (!aDoc || !aPresShell)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
41886:   // First only set flags, but other stuff shouldn't be initialized now.
41886:   // Don't move this call after initializing mDocWeak and mPresShellWeak.
41886:   // SetFlags() can check whether it's called during initialization or not by
41886:   // them.  Note that SetFlags() will be called by PostCreate().
56879: #ifdef DEBUG
56879:   nsresult rv =
56879: #endif
56879:   SetFlags(aFlags);
41886:   NS_ASSERTION(NS_SUCCEEDED(rv), "SetFlags() failed");
41886: 
    1:   mDocWeak = do_GetWeakReference(aDoc);  // weak reference to doc
    1:   mPresShellWeak = do_GetWeakReference(aPresShell);   // weak reference to pres shell
    1:   mSelConWeak = do_GetWeakReference(aSelCon);   // weak reference to selectioncontroller
40703: 
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
43806:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
    1:   
    1:   //set up root element if we are passed one.  
    1:   if (aRoot)
    1:     mRootElement = do_QueryInterface(aRoot);
    1: 
    1:   mUpdateCount=0;
    1: 
    1:   /* initialize IME stuff */
    1:   mIMETextNode = nsnull;
    1:   mIMETextOffset = 0;
    1:   mIMEBufferLength = 0;
    1:   
    1:   /* Show the caret */
    1:   aSelCon->SetCaretReadOnly(PR_FALSE);
    1:   aSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
    1:   
    1:   aSelCon->SetSelectionFlags(nsISelectionDisplay::DISPLAY_ALL);//we want to see all the selection reflected to user
    1: 
    1:   NS_POSTCONDITION(mDocWeak && mPresShellWeak, "bad state");
    1: 
43129:   // Make sure that the editor will be destroyed properly
43129:   mDidPreDestroy = PR_FALSE;
43129: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::PostCreate()
    1: {
50883:   // Synchronize some stuff for the flags.  SetFlags() will initialize
50883:   // something by the flag difference.  This is first time of that, so, all
50883:   // initializations must be run.  For such reason, we need to invert mFlags
50883:   // value first.
50883:   mFlags = ~mFlags;
50883:   nsresult rv = SetFlags(~mFlags);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Set up listeners
    1:   rv = CreateEventListeners();
    1:   if (NS_FAILED(rv))
    1:   {
    1:     RemoveEventListeners();
    1: 
    1:     return rv;
    1:   }
    1: 
    1:   rv = InstallEventListeners();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // nuke the modification count, so the doc appears unmodified
    1:   // do this before we notify listeners
    1:   ResetModificationCount();
    1:   
    1:   // update the UI with our state
    1:   NotifyDocumentListeners(eDocumentCreated);
    1:   NotifyDocumentListeners(eDocumentStateChanged);
    1:   
55284:   // update nsTextStateManager and caret if we have focus
56870:   nsCOMPtr<nsIContent> focusedContent = GetFocusedContent();
54605:   if (focusedContent) {
54605:     nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
54605:     NS_ASSERTION(ps, "no pres shell even though we have focus");
54605:     nsPresContext* pc = ps->GetPresContext(); 
54605: 
54605:     nsIMEStateManager::OnTextStateBlur(pc, nsnull);
54605:     nsIMEStateManager::OnTextStateFocus(pc, focusedContent);
55284: 
55284:     nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(focusedContent);
55284:     if (target) {
55284:       InitializeSelection(target);
55284:     }
54605:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
39014: nsEditor::CreateEventListeners()
39014: {
43129:   // Don't create the handler twice
43129:   if (mEventListener)
43129:     return NS_OK;
39014:   mEventListener = do_QueryInterface(
40987:     static_cast<nsIDOMKeyListener*>(new nsEditorEventListener()));
39014:   NS_ENSURE_TRUE(mEventListener, NS_ERROR_OUT_OF_MEMORY);
39014:   return NS_OK;
39014: }
39014: 
39014: nsresult
    1: nsEditor::InstallEventListeners()
    1: {
39014:   NS_ENSURE_TRUE(mDocWeak && mPresShellWeak && mEventListener,
    1:                  NS_ERROR_NOT_INITIALIZED);
43714: 
43714:   // Initialize the event target.
43714:   nsCOMPtr<nsIContent> rootContent = do_QueryInterface(GetRoot());
43714:   NS_ENSURE_TRUE(rootContent, NS_ERROR_NOT_AVAILABLE);
43714:   mEventTarget = do_QueryInterface(rootContent->GetParent());
43714:   NS_ENSURE_TRUE(mEventTarget, NS_ERROR_NOT_AVAILABLE);
43714: 
40987:   nsEditorEventListener* listener =
40987:     reinterpret_cast<nsEditorEventListener*>(mEventListener.get());
40987:   return listener->Connect(this);
    1: }
    1: 
    1: void
    1: nsEditor::RemoveEventListeners()
    1: {
40987:   if (!mDocWeak || !mEventListener) {
    1:     return;
    1:   }
40987:   reinterpret_cast<nsEditorEventListener*>(mEventListener.get())->Disconnect();
43714:   mEventTarget = nsnull;
    1: }
    1: 
    1: PRBool
    1: nsEditor::GetDesiredSpellCheckState()
    1: {
    1:   // Check user override on this element
    1:   if (mSpellcheckCheckboxState != eTriUnset) {
    1:     return (mSpellcheckCheckboxState == eTriTrue);
    1:   }
    1: 
    1:   // Check user preferences
    1:   nsresult rv;
    1:   nsCOMPtr<nsIPrefBranch> prefBranch =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
    1:   PRInt32 spellcheckLevel = 1;
    1:   if (NS_SUCCEEDED(rv) && prefBranch) {
    1:     prefBranch->GetIntPref("layout.spellcheckDefault", &spellcheckLevel);
    1:   }
    1: 
    1:   if (spellcheckLevel == 0) {
    1:     return PR_FALSE;                    // Spellchecking forced off globally
    1:   }
    1: 
50883:   if (!CanEnableSpellCheck()) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   rv = GetPresShell(getter_AddRefs(presShell));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     nsPresContext* context = presShell->GetPresContext();
    1:     if (context && !context->IsDynamic()) {
    1:         return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   // Check DOM state
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(GetRoot());
    1:   if (!content) {
    1:     return PR_FALSE;
    1:   }
    1: 
16126:   if (content->IsRootOfNativeAnonymousSubtree()) {
    1:     content = content->GetParent();
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNSHTMLElement> element = do_QueryInterface(content);
    1:   if (!element) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   PRBool enable;
    1:   element->GetSpellcheck(&enable);
    1: 
    1:   return enable;
    1: }
    1: 
    1: NS_IMETHODIMP
22729: nsEditor::PreDestroy(PRBool aDestroyingFrames)
    1: {
    1:   if (mDidPreDestroy)
    1:     return NS_OK;
    1: 
    1:   // Let spellchecker clean up its observers etc. It is important not to
    1:   // actually free the spellchecker here, since the spellchecker could have
    1:   // caused flush notifications, which could have gotten here if a textbox
    1:   // is being removed. Setting the spellchecker to NULL could free the
    1:   // object that is still in use! It will be freed when the editor is
    1:   // destroyed.
    1:   if (mInlineSpellChecker)
22729:     mInlineSpellChecker->Cleanup(aDestroyingFrames);
    1: 
    1:   // tell our listeners that the doc is going away
    1:   NotifyDocumentListeners(eDocumentToBeDestroyed);
    1: 
    1:   // Unregister event listeners
    1:   RemoveEventListeners();
    1:   mActionListeners.Clear();
    1:   mEditorObservers.Clear();
    1:   mDocStateListeners.Clear();
    1:   mInlineSpellChecker = nsnull;
    1: 
    1:   mDidPreDestroy = PR_TRUE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetFlags(PRUint32 *aFlags)
    1: {
    1:   *aFlags = mFlags;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SetFlags(PRUint32 aFlags)
    1: {
50883:   if (mFlags == aFlags) {
50883:     return NS_OK;
50883:   }
50883: 
50883:   PRBool spellcheckerWasEnabled = CanEnableSpellCheck();
    1:   mFlags = aFlags;
    1: 
41886:   if (!mDocWeak || !mPresShellWeak) {
41886:     // If we're initializing, we shouldn't do anything now.
41886:     // SetFlags() will be called by PostCreate(),
41886:     // we should synchronize some stuff for the flags at that time.
41886:     return NS_OK;
41886:   }
41886: 
50883:   // The flag change may cause the spellchecker state change
50883:   if (CanEnableSpellCheck() != spellcheckerWasEnabled) {
41886:     nsresult rv = SyncRealTimeSpell();
41886:     NS_ENSURE_SUCCESS(rv, rv);
50883:   }
41886: 
41886:   // Might be changing editable state, so, we need to reset current IME state
42852:   // if we're focused and the flag change causes IME state change.
56870:   nsCOMPtr<nsIContent> focusedContent = GetFocusedContent();
56870:   if (focusedContent) {
41886:     // Use "enable" for the default value because if IME is disabled
41886:     // unexpectedly, it makes serious a11y problem.
41886:     PRUint32 newState = nsIContent::IME_STATUS_ENABLE;
50883:     nsresult rv = GetPreferredIMEState(&newState);
41886:     if (NS_SUCCEEDED(rv)) {
42852:       // NOTE: When the enabled state isn't going to be modified, this method
42852:       // is going to do nothing.
58017:       nsIMEStateManager::UpdateIMEState(newState, focusedContent);
41886:     }
41886:   }
41886: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetIsDocumentEditable(PRBool *aIsDocumentEditable)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aIsDocumentEditable);
    1:   nsCOMPtr<nsIDOMDocument> doc;
    1:   GetDocument(getter_AddRefs(doc));
    1:   *aIsDocumentEditable = doc ? PR_TRUE : PR_FALSE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::GetDocument(nsIDOMDocument **aDoc)
    1: {
43807:   NS_ENSURE_TRUE(aDoc, NS_ERROR_NULL_POINTER);
    1:   *aDoc = nsnull; // init out param
    1:   NS_PRECONDITION(mDocWeak, "bad state, mDocWeak weak pointer not initialized");
    1:   nsCOMPtr<nsIDOMDocument> doc = do_QueryReferent(mDocWeak);
43806:   NS_ENSURE_TRUE(doc, NS_ERROR_NOT_INITIALIZED);
    1:   NS_ADDREF(*aDoc = doc);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetPresShell(nsIPresShell **aPS)
    1: {
43807:   NS_ENSURE_TRUE(aPS, NS_ERROR_NULL_POINTER);
    1:   *aPS = nsnull; // init out param
    1:   NS_PRECONDITION(mPresShellWeak, "bad state, null mPresShellWeak");
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
43806:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
    1:   NS_ADDREF(*aPS = ps);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: /* attribute string contentsMIMEType; */
    1: NS_IMETHODIMP
    1: nsEditor::GetContentsMIMEType(char * *aContentsMIMEType)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aContentsMIMEType);
    1:   *aContentsMIMEType = ToNewCString(mContentMIMEType);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SetContentsMIMEType(const char * aContentsMIMEType)
    1: {
    1:   mContentMIMEType.Assign(aContentsMIMEType ? aContentsMIMEType : "");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetSelectionController(nsISelectionController **aSel)
    1: {
43807:   NS_ENSURE_TRUE(aSel, NS_ERROR_NULL_POINTER);
    1:   *aSel = nsnull; // init out param
    1:   NS_PRECONDITION(mSelConWeak, "bad state, null mSelConWeak");
    1:   nsCOMPtr<nsISelectionController> selCon = do_QueryReferent(mSelConWeak);
43806:   NS_ENSURE_TRUE(selCon, NS_ERROR_NOT_INITIALIZED);
    1:   NS_ADDREF(*aSel = selCon);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DeleteSelection(EDirection aAction)
    1: {
    1:   return DeleteSelectionImpl(aAction);
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetSelection(nsISelection **aSelection)
    1: {
43807:   NS_ENSURE_TRUE(aSelection, NS_ERROR_NULL_POINTER);
    1:   *aSelection = nsnull;
    1:   nsCOMPtr<nsISelectionController> selcon = do_QueryReferent(mSelConWeak);
43806:   NS_ENSURE_TRUE(selcon, NS_ERROR_NOT_INITIALIZED);
    1:   return selcon->GetSelection(nsISelectionController::SELECTION_NORMAL, aSelection);  // does an addref
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::DoTransaction(nsITransaction *aTxn)
    1: {
    1: #ifdef NS_DEBUG_EDITOR
    1:   if (gNoisy) { printf("Editor::DoTransaction ----------\n"); }
    1: #endif
    1: 
    1:   nsresult result = NS_OK;
    1:   
    1:   if (mPlaceHolderBatch && !mPlaceHolderTxn)
    1:   {
    1:     // it's pretty darn amazing how many different types of pointers
    1:     // this transaction goes through here.  I bet this is a record.
    1:     
    1:     // We start off with an EditTxn since that's what the factory returns.
27825:     nsRefPtr<EditTxn> editTxn = new PlaceholderTxn();
27825:     if (!editTxn) { return NS_ERROR_OUT_OF_MEMORY; }
    1: 
    1:     // Then we QI to an nsIAbsorbingTransaction to get at placeholder functionality
    1:     nsCOMPtr<nsIAbsorbingTransaction> plcTxn;
    1:     editTxn->QueryInterface(NS_GET_IID(nsIAbsorbingTransaction), getter_AddRefs(plcTxn));
    1:     // have to use line above instead of "plcTxn = do_QueryInterface(editTxn);"
    1:     // due to our broken interface model for transactions.
    1: 
    1:     // save off weak reference to placeholder txn
    1:     mPlaceHolderTxn = do_GetWeakReference(plcTxn);
    1:     plcTxn->Init(mPlaceHolderName, mSelState, this);
    1:     mSelState = nsnull;  // placeholder txn took ownership of this pointer
    1: 
    1:     // finally we QI to an nsITransaction since that's what DoTransaction() expects
    1:     nsCOMPtr<nsITransaction> theTxn = do_QueryInterface(plcTxn);
    1:     DoTransaction(theTxn);  // we will recurse, but will not hit this case in the nested call
    1: 
    1:     if (mTxnMgr)
    1:     {
    1:       nsCOMPtr<nsITransaction> topTxn;
    1:       result = mTxnMgr->PeekUndoStack(getter_AddRefs(topTxn));
43805:       NS_ENSURE_SUCCESS(result, result);
    1:       if (topTxn)
    1:       {
    1:         plcTxn = do_QueryInterface(topTxn);
    1:         if (plcTxn)
    1:         {
    1:           // there is a palceholder transaction on top of the undo stack.  It is 
    1:           // either the one we just created, or an earlier one that we are now merging
    1:           // into.  From here on out remember this placeholder instead of the one
    1:           // we just created.
    1:           mPlaceHolderTxn = do_GetWeakReference(plcTxn);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aTxn)
    1:   {  
    1:     // XXX: Why are we doing selection specific batching stuff here?
    1:     // XXX: Most entry points into the editor have auto variables that
    1:     // XXX: should trigger Begin/EndUpdateViewBatch() calls that will make
    1:     // XXX: these selection batch calls no-ops.
    1:     // XXX:
    1:     // XXX: I suspect that this was placed here to avoid multiple
    1:     // XXX: selection changed notifications from happening until after
    1:     // XXX: the transaction was done. I suppose that can still happen
    1:     // XXX: if an embedding application called DoTransaction() directly
    1:     // XXX: to pump its own transactions through the system, but in that
    1:     // XXX: case, wouldn't we want to use Begin/EndUpdateViewBatch() or
    1:     // XXX: its auto equivalent nsAutoUpdateViewBatch to ensure that
    1:     // XXX: selection listeners have access to accurate frame data?
    1:     // XXX:
    1:     // XXX: Note that if we did add Begin/EndUpdateViewBatch() calls
    1:     // XXX: we will need to make sure that they are disabled during
    1:     // XXX: the init of the editor for text widgets to avoid layout
    1:     // XXX: re-entry during initial reflow. - kin
    1: 
    1:     // get the selection and start a batch change
    1:     nsCOMPtr<nsISelection>selection;
    1:     result = GetSelection(getter_AddRefs(selection));
43895:     NS_ENSURE_SUCCESS(result, result);
43895:     NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1:     nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
    1: 
    1:     selPrivate->StartBatchChanges();
    1: 
    1:     if (mTxnMgr) {
    1:       result = mTxnMgr->DoTransaction(aTxn);
    1:     }
    1:     else {
    1:       result = aTxn->DoTransaction();
    1:     }
    1:     if (NS_SUCCEEDED(result)) {
    1:       result = DoAfterDoTransaction(aTxn);
    1:     }
    1: 
    1:     selPrivate->EndBatchChanges(); // no need to check result here, don't lose result of operation
    1:   }
    1:  
    1:   NS_POSTCONDITION((NS_SUCCEEDED(result)), "transaction did not execute properly");
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::EnableUndo(PRBool aEnable)
    1: {
    1:   nsresult result=NS_OK;
    1: 
    1:   if (PR_TRUE==aEnable)
    1:   {
    1:     if (!mTxnMgr)
    1:     {
    1:       mTxnMgr = do_CreateInstance(NS_TRANSACTIONMANAGER_CONTRACTID, &result);
    1:       if (NS_FAILED(result) || !mTxnMgr) {
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:       }
    1:     }
    1:     mTxnMgr->SetMaxTransactionCount(-1);
    1:   }
    1:   else
    1:   { // disable the transaction manager if it is enabled
    1:     if (mTxnMgr)
    1:     {
    1:       mTxnMgr->Clear();
    1:       mTxnMgr->SetMaxTransactionCount(0);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetTransactionManager(nsITransactionManager* *aTxnManager)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aTxnManager);
    1:   
    1:   *aTxnManager = NULL;
43807:   NS_ENSURE_TRUE(mTxnMgr, NS_ERROR_FAILURE);
    1: 
    1:   NS_ADDREF(*aTxnManager = mTxnMgr);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SetTransactionManager(nsITransactionManager *aTxnManager)
    1: {
    1:   NS_ENSURE_TRUE(aTxnManager, NS_ERROR_FAILURE);
    1: 
    1:   mTxnMgr = aTxnManager;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::Undo(PRUint32 aCount)
    1: {
    1: #ifdef NS_DEBUG_EDITOR
    1:   if (gNoisy) { printf("Editor::Undo ----------\n"); }
    1: #endif
    1: 
    1:   nsresult result = NS_OK;
    1:   ForceCompositionEnd();
    1: 
    1:   PRBool hasTxnMgr, hasTransaction = PR_FALSE;
    1:   CanUndo(&hasTxnMgr, &hasTransaction);
43807:   NS_ENSURE_TRUE(hasTransaction, result);
    1: 
    1:   nsAutoRules beginRulesSniffing(this, kOpUndo, nsIEditor::eNone);
    1: 
    1:   if ((nsITransactionManager *)nsnull!=mTxnMgr.get())
    1:   {
    1:     PRUint32 i=0;
    1:     for ( ; i<aCount; i++)
    1:     {
    1:       result = mTxnMgr->UndoTransaction();
    1: 
    1:       if (NS_SUCCEEDED(result))
    1:         result = DoAfterUndoTransaction();
    1:           
    1:       if (NS_FAILED(result))
    1:         break;
    1:     }
    1:   }
    1: 
    1:   NotifyEditorObservers();  
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CanUndo(PRBool *aIsEnabled, PRBool *aCanUndo)
    1: {
43807:   NS_ENSURE_TRUE(aIsEnabled && aCanUndo, NS_ERROR_NULL_POINTER);
    1:   *aIsEnabled = ((PRBool)((nsITransactionManager *)0!=mTxnMgr.get()));
    1:   if (*aIsEnabled)
    1:   {
    1:     PRInt32 numTxns=0;
    1:     mTxnMgr->GetNumberOfUndoItems(&numTxns);
    1:     *aCanUndo = ((PRBool)(0!=numTxns));
    1:   }
    1:   else {
    1:     *aCanUndo = PR_FALSE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::Redo(PRUint32 aCount)
    1: {
    1: #ifdef NS_DEBUG_EDITOR
    1:   if (gNoisy) { printf("Editor::Redo ----------\n"); }
    1: #endif
    1: 
    1:   nsresult result = NS_OK;
    1: 
    1:   PRBool hasTxnMgr, hasTransaction = PR_FALSE;
    1:   CanRedo(&hasTxnMgr, &hasTransaction);
43807:   NS_ENSURE_TRUE(hasTransaction, result);
    1: 
    1:   nsAutoRules beginRulesSniffing(this, kOpRedo, nsIEditor::eNone);
    1: 
    1:   if ((nsITransactionManager *)nsnull!=mTxnMgr.get())
    1:   {
    1:     PRUint32 i=0;
    1:     for ( ; i<aCount; i++)
    1:     {
    1:       result = mTxnMgr->RedoTransaction();
    1: 
    1:       if (NS_SUCCEEDED(result))
    1:         result = DoAfterRedoTransaction();
    1: 
    1:       if (NS_FAILED(result))
    1:         break;
    1:     }
    1:   }
    1: 
    1:   NotifyEditorObservers();  
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CanRedo(PRBool *aIsEnabled, PRBool *aCanRedo)
    1: {
43807:   NS_ENSURE_TRUE(aIsEnabled && aCanRedo, NS_ERROR_NULL_POINTER);
    1: 
    1:   *aIsEnabled = ((PRBool)((nsITransactionManager *)0!=mTxnMgr.get()));
    1:   if (*aIsEnabled)
    1:   {
    1:     PRInt32 numTxns=0;
    1:     mTxnMgr->GetNumberOfRedoItems(&numTxns);
    1:     *aCanRedo = ((PRBool)(0!=numTxns));
    1:   }
    1:   else {
    1:     *aCanRedo = PR_FALSE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::BeginTransaction()
    1: {
    1:   BeginUpdateViewBatch();
    1: 
    1:   if ((nsITransactionManager *)nsnull!=mTxnMgr.get())
    1:   {
    1:     mTxnMgr->BeginBatch();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::EndTransaction()
    1: {
    1:   if ((nsITransactionManager *)nsnull!=mTxnMgr.get())
    1:   {
    1:     mTxnMgr->EndBatch();
    1:   }
    1: 
    1:   EndUpdateViewBatch();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // These two routines are similar to the above, but do not use
    1: // the transaction managers batching feature.  Instead we use
    1: // a placeholder transaction to wrap up any further transaction
    1: // while the batch is open.  The advantage of this is that
    1: // placeholder transactions can later merge, if needed.  Merging
    1: // is unavailable between transaction manager batches.
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::BeginPlaceHolderTransaction(nsIAtom *aName)
    1: {
    1:   NS_PRECONDITION(mPlaceHolderBatch >= 0, "negative placeholder batch count!");
    1:   if (!mPlaceHolderBatch)
    1:   {
    1:     // time to turn on the batch
    1:     BeginUpdateViewBatch();
    1:     mPlaceHolderTxn = nsnull;
    1:     mPlaceHolderName = aName;
    1:     nsCOMPtr<nsISelection> selection;
    1:     nsresult res = GetSelection(getter_AddRefs(selection));
48845:     if (NS_SUCCEEDED(res)) {
    1:       mSelState = new nsSelectionState();
48845:       if (mSelState) {
    1:         mSelState->SaveSelection(selection);
    1:       }
48845:     }
48845:   }
    1:   mPlaceHolderBatch++;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::EndPlaceHolderTransaction()
    1: {
    1:   NS_PRECONDITION(mPlaceHolderBatch > 0, "zero or negative placeholder batch count when ending batch!");
    1:   if (mPlaceHolderBatch == 1)
    1:   {
    1:     nsCOMPtr<nsISelection>selection;
23383:     GetSelection(getter_AddRefs(selection));
    1: 
    1:     nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
    1: 
    1:    // By making the assumption that no reflow happens during the calls
    1:    // to EndUpdateViewBatch and ScrollSelectionIntoView, we are able to
    1:    // allow the selection to cache a frame offset which is used by the
    1:    // caret drawing code. We only enable this cache here; at other times,
    1:    // we have no way to know whether reflow invalidates it
    1:    // See bugs 35296 and 199412.
    1:     if (selPrivate) {
    1:       selPrivate->SetCanCacheFrameOffset(PR_TRUE);
    1:     }
    1: 
53732:     {
53732:       // Hide the caret here to avoid hiding it twice, once in EndUpdateViewBatch
53732:       // and once in ScrollSelectionIntoView.
53732:       nsRefPtr<nsCaret> caret;
53732:       nsCOMPtr<nsIPresShell> presShell;
53732:       GetPresShell(getter_AddRefs(presShell));
53732: 
53732:       if (presShell)
53732:         caret = presShell->GetCaret();
53732: 
53732:       StCaretHider caretHider(caret);
53732: 
    1:       // time to turn off the batch
    1:       EndUpdateViewBatch();
    1:       // make sure selection is in view
12392: 
12392:       // After ScrollSelectionIntoView(), the pending notifications might be
12392:       // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
    1:       ScrollSelectionIntoView(PR_FALSE);
53732:     }
    1: 
    1:     // cached for frame offset are Not available now
    1:     if (selPrivate) {
    1:       selPrivate->SetCanCacheFrameOffset(PR_FALSE);
    1:     }
    1: 
    1:     if (mSelState)
    1:     {
    1:       // we saved the selection state, but never got to hand it to placeholder 
    1:       // (else we ould have nulled out this pointer), so destroy it to prevent leaks.
    1:       delete mSelState;
    1:       mSelState = nsnull;
    1:     }
    1:     if (mPlaceHolderTxn)  // we might have never made a placeholder if no action took place
    1:     {
    1:       nsCOMPtr<nsIAbsorbingTransaction> plcTxn = do_QueryReferent(mPlaceHolderTxn);
    1:       if (plcTxn) 
    1:       {
    1:         plcTxn->EndPlaceHolderBatch();
    1:       }
    1:       else  
    1:       {
    1:         // in the future we will check to make sure undo is off here,
    1:         // since that is the only known case where the placeholdertxn would disappear on us.
    1:         // For now just removing the assert.
    1:       }
    1:       // notify editor observers of action unless it is uncommitted IME
    1:       if (!mInIMEMode) NotifyEditorObservers();
    1:     }
    1:   }
    1:   mPlaceHolderBatch--;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::ShouldTxnSetSelection(PRBool *aResult)
    1: {
43806:   NS_ENSURE_TRUE(aResult, NS_ERROR_NULL_POINTER);
    1:   *aResult = mShouldTxnSetSelection;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP  
    1: nsEditor::SetShouldTxnSetSelection(PRBool aShould)
    1: {
    1:   mShouldTxnSetSelection = aShould;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetDocumentIsEmpty(PRBool *aDocumentIsEmpty)
    1: {
    1:   *aDocumentIsEmpty = PR_TRUE;
    1: 
    1:   nsIDOMElement *rootElement = GetRoot(); 
43807:   NS_ENSURE_TRUE(rootElement, NS_ERROR_NULL_POINTER); 
    1: 
    1:   PRBool hasChildNodes;
    1:   nsresult res = rootElement->HasChildNodes(&hasChildNodes);
    1: 
    1:   *aDocumentIsEmpty = !hasChildNodes;
    1: 
    1:   return res;
    1: }
    1: 
    1: 
    1: // XXX: the rule system should tell us which node to select all on (ie, the root, or the body)
    1: NS_IMETHODIMP nsEditor::SelectAll()
    1: {
    1:   if (!mDocWeak || !mPresShellWeak) { return NS_ERROR_NOT_INITIALIZED; }
    1:   ForceCompositionEnd();
    1: 
    1:   nsCOMPtr<nsISelectionController> selCon = do_QueryReferent(mSelConWeak);
43806:   NS_ENSURE_TRUE(selCon, NS_ERROR_NOT_INITIALIZED);
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult result = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL, getter_AddRefs(selection));
    1:   if (NS_SUCCEEDED(result) && selection)
    1:   {
    1:     result = SelectEntireDocument(selection);
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::BeginningOfDocument()
    1: {
    1:   if (!mDocWeak || !mPresShellWeak) { return NS_ERROR_NOT_INITIALIZED; }
    1: 
    1:   // get the selection
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult result = GetSelection(getter_AddRefs(selection));
43808:   NS_ENSURE_SUCCESS(result, result);
43807:   NS_ENSURE_TRUE(selection, NS_ERROR_NOT_INITIALIZED);
    1:     
    1:   // get the root element 
    1:   nsIDOMElement *rootElement = GetRoot(); 
43807:   NS_ENSURE_TRUE(rootElement, NS_ERROR_NULL_POINTER); 
    1:   
    1:   // find first editable thingy
    1:   nsCOMPtr<nsIDOMNode> firstNode;
    1:   result = GetFirstEditableNode(rootElement, address_of(firstNode));
    1:   if (firstNode)
    1:   {
    1:     // if firstNode is text, set selection to beginning of the text node
    1:     if (IsTextNode(firstNode)) 
    1:     {
    1:       result = selection->Collapse(firstNode, 0);
    1:     }
    1:     else
    1:     { // otherwise, it's a leaf node and we set the selection just in front of it
    1:       nsCOMPtr<nsIDOMNode> parentNode;
    1:       result = firstNode->GetParentNode(getter_AddRefs(parentNode));
    1:       if (NS_FAILED(result)) { return result; }
    1:       if (!parentNode) { return NS_ERROR_NULL_POINTER; }
    1:       PRInt32 offsetInParent;
    1:       result = nsEditor::GetChildOffset(firstNode, parentNode, offsetInParent);
43805:       NS_ENSURE_SUCCESS(result, result);
    1:       result = selection->Collapse(parentNode, offsetInParent);
    1:     }
    1:   }
    1:   else
    1:   {
    1:     // just the root node, set selection to inside the root
    1:     result = selection->Collapse(rootElement, 0);
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::EndOfDocument() 
    1: { 
    1:   if (!mDocWeak || !mPresShellWeak) { return NS_ERROR_NOT_INITIALIZED; } 
    1:   nsresult res; 
    1: 
    1:   // get selection 
    1:   nsCOMPtr<nsISelection> selection; 
    1:   res = GetSelection(getter_AddRefs(selection)); 
43805:   NS_ENSURE_SUCCESS(res, res); 
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER); 
    1:   
    1:   // get the root element 
    1:   nsIDOMElement *rootElement = GetRoot(); 
43807:   NS_ENSURE_TRUE(rootElement, NS_ERROR_NULL_POINTER); 
    1: 
57480:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(rootElement);
57480:   nsCOMPtr<nsIDOMNode> child;
57480:   NS_ASSERTION(node, "Invalid root element");
57480: 
57480:   do {
57480:     node->GetLastChild(getter_AddRefs(child));
57480: 
57480:     if (child) {
57480:       if (IsContainer(child)) {
57480:         node = child;
57480:       } else {
57480:         break;
57480:       }
57480:     }
57480:   } while (child);
57480: 
57480:   PRUint32 length = 0;
57480:   res = GetLengthOfDOMNode(node, length);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
57480:   return selection->Collapse(node, (PRInt32)length);
    1: } 
    1:   
    1: NS_IMETHODIMP
    1: nsEditor::GetDocumentModified(PRBool *outDocModified)
    1: {
43807:   NS_ENSURE_TRUE(outDocModified, NS_ERROR_NULL_POINTER);
    1: 
    1:   PRInt32  modCount = 0;
    1:   GetModificationCount(&modCount);
    1: 
    1:   *outDocModified = (modCount != 0);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetDocumentCharacterSet(nsACString &characterSet)
    1: {
    1:   nsCOMPtr<nsIPresShell> presShell;
    1: 
    1:   nsresult rv = GetPresShell(getter_AddRefs(presShell));
    1:   if (NS_SUCCEEDED(rv))
    1:   {
    1:     nsIDocument *doc = presShell->GetDocument();
    1:     if (doc) {
    1:       characterSet = doc->GetDocumentCharacterSet();
    1:       return NS_OK;
    1:     }
    1:     rv = NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   return rv;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SetDocumentCharacterSet(const nsACString& characterSet)
    1: {
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   nsresult rv = GetPresShell(getter_AddRefs(presShell));
    1:   if (NS_SUCCEEDED(rv))
    1:   {
    1:     nsIDocument *doc = presShell->GetDocument();
    1:     if (doc) {
    1:       doc->SetDocumentCharacterSet(characterSet);
    1:       return NS_OK;
    1:     }
    1:     rv = NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::Cut()
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::CanCut(PRBool *aCanCut)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::Copy()
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::CanCopy(PRBool *aCanCut)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::Paste(PRInt32 aSelectionType)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
36983: nsEditor::PasteTransferable(nsITransferable *aTransferable)
36983: {
36983:   return NS_ERROR_NOT_IMPLEMENTED; 
36983: }
36983: 
36983: NS_IMETHODIMP
    1: nsEditor::CanPaste(PRInt32 aSelectionType, PRBool *aCanPaste)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
36983: nsEditor::CanPasteTransferable(nsITransferable *aTransferable, PRBool *aCanPaste)
36983: {
36983:   return NS_ERROR_NOT_IMPLEMENTED; 
36983: }
36983: 
36983: NS_IMETHODIMP
    1: nsEditor::CanDrag(nsIDOMEvent *aEvent, PRBool *aCanDrag)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DoDrag(nsIDOMEvent *aEvent)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::InsertFromDrop(nsIDOMEvent *aEvent)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED; 
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::SetAttribute(nsIDOMElement *aElement, const nsAString & aAttribute, const nsAString & aValue)
    1: {
 3030:   nsRefPtr<ChangeAttributeTxn> txn;
 3030:   nsresult result = CreateTxnForSetAttribute(aElement, aAttribute, aValue,
 3030:                                              getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = DoTransaction(txn);  
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::GetAttributeValue(nsIDOMElement *aElement, 
    1:                             const nsAString & aAttribute, 
    1:                             nsAString & aResultValue, 
    1:                             PRBool *aResultIsSet)
    1: {
43807:   NS_ENSURE_TRUE(aResultIsSet, NS_ERROR_NULL_POINTER);
    1:   *aResultIsSet=PR_FALSE;
    1:   nsresult result=NS_OK;
    1:   if (aElement)
    1:   {
    1:     nsCOMPtr<nsIDOMAttr> attNode;
    1:     result = aElement->GetAttributeNode(aAttribute, getter_AddRefs(attNode));
    1:     if ((NS_SUCCEEDED(result)) && attNode)
    1:     {
    1:       attNode->GetSpecified(aResultIsSet);
    1:       attNode->GetValue(aResultValue);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::RemoveAttribute(nsIDOMElement *aElement, const nsAString& aAttribute)
    1: {
 3030:   nsRefPtr<ChangeAttributeTxn> txn;
 3030:   nsresult result = CreateTxnForRemoveAttribute(aElement, aAttribute,
 3030:                                                 getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = DoTransaction(txn);  
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::MarkNodeDirty(nsIDOMNode* aNode)
    1: {  
    1:   //  mark the node dirty.
41743:   nsCOMPtr<nsIContent> element (do_QueryInterface(aNode));
    1:   if (element)
41743:     element->SetAttr(kNameSpaceID_None, nsEditProperty::mozdirty,
41743:                      EmptyString(), PR_FALSE);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::GetInlineSpellChecker(PRBool autoCreate,
    1:                                               nsIInlineSpellChecker ** aInlineSpellChecker)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aInlineSpellChecker);
    1: 
    1:   if (mDidPreDestroy) {
    1:     // Don't allow people to get or create the spell checker once the editor
    1:     // is going away.
    1:     *aInlineSpellChecker = nsnull;
    1:     return autoCreate ? NS_ERROR_NOT_AVAILABLE : NS_OK;
    1:   }
    1: 
15173:   nsresult rv;
    1:   if (!mInlineSpellChecker && autoCreate) {
    1:     mInlineSpellChecker = do_CreateInstance(MOZ_INLINESPELLCHECKER_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
15173:   }
15173: 
15173:   if (mInlineSpellChecker) {
    1:     rv = mInlineSpellChecker->Init(this);
    1:     if (NS_FAILED(rv))
    1:       mInlineSpellChecker = nsnull;
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aInlineSpellChecker = mInlineSpellChecker);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::SyncRealTimeSpell()
    1: {
42480:   NS_TIME_FUNCTION;
42480: 
    1:   PRBool enable = GetDesiredSpellCheckState();
    1: 
    1:   nsCOMPtr<nsIInlineSpellChecker> spellChecker;
    1:   GetInlineSpellChecker(enable, getter_AddRefs(spellChecker));
    1: 
    1:   if (spellChecker) {
    1:     spellChecker->SetEnableRealTimeSpell(enable);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::SetSpellcheckUserOverride(PRBool enable)
    1: {
    1:   mSpellcheckCheckboxState = enable ? eTriTrue : eTriFalse;
    1: 
    1:   return SyncRealTimeSpell();
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  main node manipulation routines 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP nsEditor::CreateNode(const nsAString& aTag,
    1:                                    nsIDOMNode *    aParent,
    1:                                    PRInt32         aPosition,
    1:                                    nsIDOMNode **   aNewNode)
    1: {
    1:   PRInt32 i;
    1: 
    1:   nsAutoRules beginRulesSniffing(this, kOpCreateNode, nsIEditor::eNext);
    1:   
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillCreateNode(aTag, aParent, aPosition);
    1: 
 3030:   nsRefPtr<CreateElementTxn> txn;
 3030:   nsresult result = CreateTxnForCreateElement(aTag, aParent, aPosition,
 3030:                                               getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result)) 
    1:   {
    1:     result = DoTransaction(txn);  
    1:     if (NS_SUCCEEDED(result)) 
    1:     {
    1:       result = txn->GetNewNode(aNewNode);
    1:       NS_ASSERTION((NS_SUCCEEDED(result)), "GetNewNode can't fail if txn::DoTransaction succeeded.");
    1:     }
    1:   }
    1:   
    1:   mRangeUpdater.SelAdjCreateNode(aParent, aPosition);
    1:   
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->DidCreateNode(aTag, *aNewNode, aParent, aPosition, result);
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::InsertNode(nsIDOMNode * aNode,
    1:                                    nsIDOMNode * aParent,
    1:                                    PRInt32      aPosition)
    1: {
    1:   PRInt32 i;
    1:   nsAutoRules beginRulesSniffing(this, kOpInsertNode, nsIEditor::eNext);
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillInsertNode(aNode, aParent, aPosition);
    1: 
 3030:   nsRefPtr<InsertElementTxn> txn;
 3030:   nsresult result = CreateTxnForInsertElement(aNode, aParent, aPosition,
 3030:                                               getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = DoTransaction(txn);  
    1:   }
    1: 
    1:   mRangeUpdater.SelAdjInsertNode(aParent, aPosition);
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->DidInsertNode(aNode, aParent, aPosition, result);
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::SplitNode(nsIDOMNode * aNode,
    1:                     PRInt32      aOffset,
    1:                     nsIDOMNode **aNewLeftNode)
    1: {
    1:   PRInt32 i;
    1:   nsAutoRules beginRulesSniffing(this, kOpSplitNode, nsIEditor::eNext);
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillSplitNode(aNode, aOffset);
    1: 
 3030:   nsRefPtr<SplitElementTxn> txn;
 3030:   nsresult result = CreateTxnForSplitNode(aNode, aOffset, getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  
    1:   {
    1:     result = DoTransaction(txn);
    1:     if (NS_SUCCEEDED(result))
    1:     {
    1:       result = txn->GetNewNode(aNewLeftNode);
    1:       NS_ASSERTION((NS_SUCCEEDED(result)), "result must succeeded for GetNewNode");
    1:     }
    1:   }
    1: 
    1:   mRangeUpdater.SelAdjSplitNode(aNode, aOffset, *aNewLeftNode);
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:   {
    1:     nsIDOMNode *ptr = *aNewLeftNode;
    1:     mActionListeners[i]->DidSplitNode(aNode, aOffset, ptr, result);
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::JoinNodes(nsIDOMNode * aLeftNode,
    1:                     nsIDOMNode * aRightNode,
    1:                     nsIDOMNode * aParent)
    1: {
    1:   PRInt32 i, offset;
    1:   nsAutoRules beginRulesSniffing(this, kOpJoinNode, nsIEditor::ePrevious);
    1: 
    1:   // remember some values; later used for saved selection updating.
    1:   // find the offset between the nodes to be joined.
    1:   nsresult result = GetChildOffset(aRightNode, aParent, offset);
43805:   NS_ENSURE_SUCCESS(result, result);
    1:   // find the number of children of the lefthand node
    1:   PRUint32 oldLeftNodeLen;
    1:   result = GetLengthOfDOMNode(aLeftNode, oldLeftNodeLen);
43805:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillJoinNodes(aLeftNode, aRightNode, aParent);
    1: 
 3030:   nsRefPtr<JoinElementTxn> txn;
 3030:   result = CreateTxnForJoinNode(aLeftNode, aRightNode, getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = DoTransaction(txn);  
    1:   }
    1: 
    1:   mRangeUpdater.SelAdjJoinNodes(aLeftNode, aRightNode, aParent, offset, (PRInt32)oldLeftNodeLen);
    1:   
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->DidJoinNodes(aLeftNode, aRightNode, aParent, result);
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::DeleteNode(nsIDOMNode * aElement)
    1: {
    1:   PRInt32 i, offset;
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   nsAutoRules beginRulesSniffing(this, kOpCreateNode, nsIEditor::ePrevious);
    1: 
    1:   // save node location for selection updating code.
    1:   nsresult result = GetNodeLocation(aElement, address_of(parent), &offset);
43805:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillDeleteNode(aElement);
    1: 
 3030:   nsRefPtr<DeleteElementTxn> txn;
 3030:   result = CreateTxnForDeleteElement(aElement, getter_AddRefs(txn));
    1:   if (NS_SUCCEEDED(result))  {
    1:     result = DoTransaction(txn);  
    1:   }
    1: 
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->DidDeleteNode(aElement, result);
    1: 
    1:   return result;
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // ReplaceContainer: replace inNode with a new node (outNode) which is contructed 
    1: //                   to be of type aNodeType.  Put inNodes children into outNode.
    1: //                   Callers responsibility to make sure inNode's children can 
    1: //                   go in outNode.
    1: nsresult
    1: nsEditor::ReplaceContainer(nsIDOMNode *inNode, 
    1:                            nsCOMPtr<nsIDOMNode> *outNode, 
    1:                            const nsAString &aNodeType,
    1:                            const nsAString *aAttribute,
    1:                            const nsAString *aValue,
    1:                            PRBool aCloneAttributes)
    1: {
43807:   NS_ENSURE_TRUE(inNode && outNode, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRInt32 offset;
    1:   nsresult res = GetNodeLocation(inNode, address_of(parent), &offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // create new container
    1:   nsCOMPtr<nsIContent> newContent;
    1: 
    1:   //new call to use instead to get proper HTML element, bug# 39919
    1:   res = CreateHTMLContent(aNodeType, getter_AddRefs(newContent));
    1:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(newContent);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:     *outNode = do_QueryInterface(elem);
    1:   
    1:   // set attribute if needed
    1:   if (aAttribute && aValue && !aAttribute->IsEmpty())
    1:   {
    1:     res = elem->SetAttribute(*aAttribute, *aValue);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   if (aCloneAttributes)
    1:   {
    1:     nsCOMPtr<nsIDOMNode>newNode = do_QueryInterface(elem);
    1:     res = CloneAttributes(newNode, inNode);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   // notify our internal selection state listener
    1:   // (Note: A nsAutoSelectionReset object must be created
    1:   //  before calling this to initialize mRangeUpdater)
    1:   nsAutoReplaceContainerSelNotify selStateNotify(mRangeUpdater, inNode, *outNode);
    1:   {
    1:     nsAutoTxnsConserveSelection conserveSelection(this);
    1:     nsCOMPtr<nsIDOMNode> child;
    1:     PRBool bHasMoreChildren;
    1:     inNode->HasChildNodes(&bHasMoreChildren);
    1:     while (bHasMoreChildren)
    1:     {
    1:       inNode->GetFirstChild(getter_AddRefs(child));
    1:       res = DeleteNode(child);
43805:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       res = InsertNode(child, *outNode, -1);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       inNode->HasChildNodes(&bHasMoreChildren);
    1:     }
    1:   }
    1:   // insert new container into tree
    1:   res = InsertNode( *outNode, parent, offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // delete old container
    1:   return DeleteNode(inNode);
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // RemoveContainer: remove inNode, reparenting its children into their
    1: //                  the parent of inNode
    1: //
    1: nsresult
    1: nsEditor::RemoveContainer(nsIDOMNode *inNode)
    1: {
43807:   NS_ENSURE_TRUE(inNode, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRInt32 offset;
    1:   
    1:   nsresult res = GetNodeLocation(inNode, address_of(parent), &offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   // loop through the child nodes of inNode and promote them
    1:   // into inNode's parent.
    1:   PRBool bHasMoreChildren;
    1:   inNode->HasChildNodes(&bHasMoreChildren);
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1:   res = inNode->GetChildNodes(getter_AddRefs(nodeList));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(nodeList, NS_ERROR_NULL_POINTER);
    1:   PRUint32 nodeOrigLen;
    1:   nodeList->GetLength(&nodeOrigLen);
    1: 
    1:   // notify our internal selection state listener
    1:   nsAutoRemoveContainerSelNotify selNotify(mRangeUpdater, inNode, parent, offset, nodeOrigLen);
    1:                                    
    1:   nsCOMPtr<nsIDOMNode> child;
    1:   while (bHasMoreChildren)
    1:   {
    1:     inNode->GetLastChild(getter_AddRefs(child));
    1:     res = DeleteNode(child);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     res = InsertNode(child, parent, offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     inNode->HasChildNodes(&bHasMoreChildren);
    1:   }
    1:   return DeleteNode(inNode);
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // InsertContainerAbove:  insert a new parent for inNode, returned in outNode,
    1: //                   which is contructed to be of type aNodeType.  outNode becomes
    1: //                   a child of inNode's earlier parent.
    1: //                   Callers responsibility to make sure inNode's can be child
    1: //                   of outNode, and outNode can be child of old parent.
    1: nsresult
    1: nsEditor::InsertContainerAbove( nsIDOMNode *inNode, 
    1:                                 nsCOMPtr<nsIDOMNode> *outNode, 
    1:                                 const nsAString &aNodeType,
    1:                                 const nsAString *aAttribute,
    1:                                 const nsAString *aValue)
    1: {
43807:   NS_ENSURE_TRUE(inNode && outNode, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> parent;
    1:   PRInt32 offset;
    1:   nsresult res = GetNodeLocation(inNode, address_of(parent), &offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // create new container
    1:   nsCOMPtr<nsIContent> newContent;
    1: 
    1:   //new call to use instead to get proper HTML element, bug# 39919
    1:   res = CreateHTMLContent(aNodeType, getter_AddRefs(newContent));
    1:   nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(newContent);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   *outNode = do_QueryInterface(elem);
    1:   
    1:   // set attribute if needed
    1:   if (aAttribute && aValue && !aAttribute->IsEmpty())
    1:   {
    1:     res = elem->SetAttribute(*aAttribute, *aValue);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   
    1:   // notify our internal selection state listener
    1:   nsAutoInsertContainerSelNotify selNotify(mRangeUpdater);
    1:   
    1:   // put inNode in new parent, outNode
    1:   res = DeleteNode(inNode);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   {
    1:     nsAutoTxnsConserveSelection conserveSelection(this);
    1:     res = InsertNode(inNode, *outNode, 0);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   // put new parent in doc
    1:   return InsertNode(*outNode, parent, offset);
    1: }
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // MoveNode:  move aNode to {aParent,aOffset}
    1: nsresult
    1: nsEditor::MoveNode(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aOffset)
    1: {
43807:   NS_ENSURE_TRUE(aNode && aParent, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMNode> oldParent;
    1:   PRInt32 oldOffset;
    1:   nsresult res = GetNodeLocation(aNode, address_of(oldParent), &oldOffset);
    1:   
    1:   if (aOffset == -1)
    1:   {
    1:     PRUint32 unsignedOffset;
    1:     // magic value meaning "move to end of aParent"
    1:     res = GetLengthOfDOMNode(aParent, unsignedOffset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     aOffset = (PRInt32)unsignedOffset;
    1:   }
    1:   
    1:   // don't do anything if it's already in right place
    1:   if ((aParent == oldParent.get()) && (oldOffset == aOffset)) return NS_OK;
    1:   
    1:   // notify our internal selection state listener
    1:   nsAutoMoveNodeSelNotify selNotify(mRangeUpdater, oldParent, oldOffset, aParent, aOffset);
    1:   
    1:   // need to adjust aOffset if we are moving aNode further along in its current parent
    1:   if ((aParent == oldParent.get()) && (oldOffset < aOffset)) 
    1:   {
    1:     aOffset--;  // this is because when we delete aNode, it will make the offsets after it off by one
    1:   }
    1: 
    1:   // put aNode in new parent
    1:   res = DeleteNode(aNode);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   return InsertNode(aNode, aParent, aOffset);
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  editor observer maintainance
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::AddEditorObserver(nsIEditorObserver *aObserver)
    1: {
    1:   // we don't keep ownership of the observers.  They must
    1:   // remove themselves as observers before they are destroyed.
    1:   
43807:   NS_ENSURE_TRUE(aObserver, NS_ERROR_NULL_POINTER);
    1: 
    1:   // Make sure the listener isn't already on the list
    1:   if (mEditorObservers.IndexOf(aObserver) == -1) 
    1:   {
    1:     if (!mEditorObservers.AppendObject(aObserver))
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::RemoveEditorObserver(nsIEditorObserver *aObserver)
    1: {
43807:   NS_ENSURE_TRUE(aObserver, NS_ERROR_FAILURE);
    1: 
    1:   if (!mEditorObservers.RemoveObject(aObserver))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void nsEditor::NotifyEditorObservers(void)
    1: {
    1:   for (PRInt32 i = 0; i < mEditorObservers.Count(); i++)
    1:     mEditorObservers[i]->EditAction();
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  action listener maintainance
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::AddEditActionListener(nsIEditActionListener *aListener)
    1: {
43807:   NS_ENSURE_TRUE(aListener, NS_ERROR_NULL_POINTER);
    1: 
    1:   // Make sure the listener isn't already on the list
    1:   if (mActionListeners.IndexOf(aListener) == -1) 
    1:   {
    1:     if (!mActionListeners.AppendObject(aListener))
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::RemoveEditActionListener(nsIEditActionListener *aListener)
    1: {
43807:   NS_ENSURE_TRUE(aListener, NS_ERROR_FAILURE);
    1: 
    1:   if (!mActionListeners.RemoveObject(aListener))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  docstate listener maintainance
    1: #pragma mark -
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::AddDocumentStateListener(nsIDocumentStateListener *aListener)
    1: {
43807:   NS_ENSURE_TRUE(aListener, NS_ERROR_NULL_POINTER);
    1: 
    1:   if (mDocStateListeners.IndexOf(aListener) == -1)
    1:   {
    1:     if (!mDocStateListeners.AppendObject(aListener))
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::RemoveDocumentStateListener(nsIDocumentStateListener *aListener)
    1: {
43807:   NS_ENSURE_TRUE(aListener, NS_ERROR_NULL_POINTER);
    1: 
    1:   if (!mDocStateListeners.RemoveObject(aListener))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  misc 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP nsEditor::OutputToString(const nsAString& aFormatType,
    1:                                        PRUint32 aFlags,
    1:                                        nsAString& aOutputString)
    1: {
    1:   // these should be implemented by derived classes.
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::OutputToStream(nsIOutputStream* aOutputStream,
    1:                          const nsAString& aFormatType,
    1:                          const nsACString& aCharsetOverride,
    1:                          PRUint32 aFlags)
    1: {
    1:   // these should be implemented by derived classes.
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DumpContentTree()
    1: {
    1: #ifdef DEBUG
    1:   nsCOMPtr<nsIContent> root = do_QueryInterface(mRootElement);
    1:   if (root)  root->List(stdout);
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DebugDumpContent()
    1: {
    1: #ifdef DEBUG
    1:   nsCOMPtr<nsIDOMHTMLDocument> doc = do_QueryReferent(mDocWeak);
43806:   NS_ENSURE_TRUE(doc, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIDOMHTMLElement>bodyElem;
    1:   doc->GetBody(getter_AddRefs(bodyElem));
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(bodyElem);
    1:   if (content)
    1:     content->List();
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DebugUnitTests(PRInt32 *outNumTests, PRInt32 *outNumTestsFailed)
    1: {
    1: #ifdef DEBUG
    1:   NS_NOTREACHED("This should never get called. Overridden by subclasses");
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  support for selection preservation
    1: #pragma mark -
    1: #endif
    1: 
    1: PRBool   
    1: nsEditor::ArePreservingSelection()
    1: {
    1:   return !(mSavedSel.IsEmpty());
    1: }
    1: 
    1: nsresult 
    1: nsEditor::PreserveSelectionAcrossActions(nsISelection *aSel)
    1: {
    1:   mSavedSel.SaveSelection(aSel);
    1:   mRangeUpdater.RegisterSelectionState(mSavedSel);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::RestorePreservedSelection(nsISelection *aSel)
    1: {
    1:   if (mSavedSel.IsEmpty()) return NS_ERROR_FAILURE;
    1:   mSavedSel.RestoreSelection(aSel);
    1:   StopPreservingSelection();
    1:   return NS_OK;
    1: }
    1: 
    1: void     
    1: nsEditor::StopPreservingSelection()
    1: {
    1:   mRangeUpdater.DropSelectionState(mSavedSel);
    1:   mSavedSel.MakeEmpty();
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
46425: #pragma mark  IME event handlers 
    1: #pragma mark -
    1: #endif
    1: 
46425: nsresult
46425: nsEditor::BeginIMEComposition()
46425: {
    1:   mInIMEMode = PR_TRUE;
46425:   if (mPhonetic) {
    1:     mPhonetic->Truncate(0);
46425:   }
40645:   return NS_OK;
    1: }
    1: 
46425: nsresult
46425: nsEditor::EndIMEComposition()
    1: {
43806:   NS_ENSURE_TRUE(mInIMEMode, NS_OK); // nothing to do
    1: 
46425:   nsresult rv = NS_OK;
    1: 
    1:   // commit the IME transaction..we can get at it via the transaction mgr.
    1:   // Note that this means IME won't work without an undo stack!
46425:   if (mTxnMgr) {
    1:     nsCOMPtr<nsITransaction> txn;
46425:     rv = mTxnMgr->PeekUndoStack(getter_AddRefs(txn));
46425:     NS_ASSERTION(NS_SUCCEEDED(rv), "PeekUndoStack() failed");
    1:     nsCOMPtr<nsIAbsorbingTransaction> plcTxn = do_QueryInterface(txn);
46425:     if (plcTxn) {
46425:       rv = plcTxn->Commit();
46425:       NS_ASSERTION(NS_SUCCEEDED(rv),
46425:                    "nsIAbsorbingTransaction::Commit() failed");
    1:     }
    1:   }
    1: 
    1:   /* reset the data we need to construct a transaction */
46425:   mIMETextNode = nsnull;
    1:   mIMETextOffset = 0;
    1:   mIMEBufferLength = 0;
    1:   mInIMEMode = PR_FALSE;
    1:   mIsIMEComposing = PR_FALSE;
    1: 
    1:   // notify editor observers of action
    1:   NotifyEditorObservers();
    1: 
46425:   return rv;
46425: }
46425: 
46425: 
46425: #ifdef XP_MAC
46425: #pragma mark -
46425: #pragma mark  nsIPhonetic
46425: #pragma mark -
46425: #endif
46425: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetPhonetic(nsAString& aPhonetic)
    1: {
    1:   if (mPhonetic)
    1:     aPhonetic = *mPhonetic;
    1:   else
    1:     aPhonetic.Truncate(0);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
46425: #ifdef XP_MAC
46425: #pragma mark -
46425: #pragma mark  nsIEditorIMESupport 
46425: #pragma mark -
46425: #endif
46425: 
46425: 
    1: static nsresult
36657: GetEditorContentWindow(nsIDOMElement *aRoot, nsIWidget **aResult)
36657: {
43807:   NS_ENSURE_TRUE(aRoot && aResult, NS_ERROR_NULL_POINTER);
    1: 
    1:   *aResult = 0;
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aRoot);
    1: 
43807:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
    1: 
    1:   // Not ref counted
36657:   nsIFrame *frame = content->GetPrimaryFrame();
    1: 
43807:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
    1: 
47148:   *aResult = frame->GetNearestWidget();
43807:   NS_ENSURE_TRUE(*aResult, NS_ERROR_FAILURE);
    1: 
    1:   NS_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
15919: nsEditor::GetWidget(nsIWidget **aWidget)
15919: {
43807:   NS_ENSURE_TRUE(aWidget, NS_ERROR_NULL_POINTER);
15919:   *aWidget = nsnull;
    1: 
    1:   nsCOMPtr<nsIWidget> widget;
36657:   nsresult res = GetEditorContentWindow(GetRoot(), getter_AddRefs(widget));
43808:   NS_ENSURE_SUCCESS(res, res);
43807:   NS_ENSURE_TRUE(widget, NS_ERROR_NOT_AVAILABLE);
15919: 
15919:   NS_ADDREF(*aWidget = widget);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::ForceCompositionEnd()
    1: {
    1: 
    1: // We can test mInIMEMode and do some optimization for Mac and Window
    1: // Howerver, since UNIX support over-the-spot, we cannot rely on that 
    1: // flag for Unix.
    1: // We should use nsILookAndFeel to resolve this
    1: 
    1: #if defined(XP_MAC) || defined(XP_MACOSX) || defined(XP_WIN) || defined(XP_OS2)
40986:   // XXXmnakano see bug 558976, ResetInputState() has two meaning which are
40986:   // "commit the composition" and "cursor is moved".  This method name is
40986:   // "ForceCompositionEnd", so, ResetInputState() should be used only for the
40986:   // former here.  However, ResetInputState() is also used for the latter here
40986:   // because even if we don't have composition, we call ResetInputState() on
40986:   // Linux.  Currently, nsGtkIMModule can know the timing of the cursor move,
40986:   // so, the latter meaning should be gone and we should remove this #if.
    1:   if(! mInIMEMode)
    1:     return NS_OK;
    1: #endif
    1: 
15919:   nsCOMPtr<nsIWidget> widget;
15919:   nsresult res = GetWidget(getter_AddRefs(widget));
43808:   NS_ENSURE_SUCCESS(res, res);
    1: 
15919:   if (widget) {
15919:     res = widget->ResetInputState();
43808:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetPreferredIMEState(PRUint32 *aState)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aState);
 1520:   *aState = nsIContent::IME_STATUS_ENABLE;
    1: 
40703:   if (IsReadonly() || IsDisabled()) {
    1:     *aState = nsIContent::IME_STATUS_DISABLE;
 1520:     return NS_OK;
 1520:   }
 1520: 
 1520:   nsCOMPtr<nsIContent> content = do_QueryInterface(GetRoot());
 1520:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
 1520: 
36657:   nsIFrame* frame = content->GetPrimaryFrame();
 1520:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
 1520: 
 1520:   switch (frame->GetStyleUIReset()->mIMEMode) {
 1520:     case NS_STYLE_IME_MODE_AUTO:
40703:       if (IsPasswordEditor())
  539:         *aState = nsIContent::IME_STATUS_PASSWORD;
 1520:       break;
 1520:     case NS_STYLE_IME_MODE_DISABLED:
 1520:       // we should use password state for |ime-mode: disabled;|.
 1520:       *aState = nsIContent::IME_STATUS_PASSWORD;
 1520:       break;
 1520:     case NS_STYLE_IME_MODE_ACTIVE:
 1520:       *aState |= nsIContent::IME_STATUS_OPEN;
 1520:       break;
 1520:     case NS_STYLE_IME_MODE_INACTIVE:
 1520:       *aState |= nsIContent::IME_STATUS_CLOSE;
 1520:       break;
 1520:   }
 1520: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
11912: nsEditor::GetComposing(PRBool* aResult)
11912: {
11912:   NS_ENSURE_ARG_POINTER(aResult);
11912:   *aResult = IsIMEComposing();
11912:   return NS_OK;
11912: }
11912: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  public nsEditor methods 
    1: #pragma mark -
    1: #endif
    1: /* Non-interface, public methods */
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::GetRootElement(nsIDOMElement **aRootElement)
    1: {
43713:   NS_ENSURE_ARG_POINTER(aRootElement);
43713:   NS_ENSURE_TRUE(mRootElement, NS_ERROR_NOT_AVAILABLE);
    1:   *aRootElement = mRootElement;
    1:   NS_ADDREF(*aRootElement);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: /** All editor operations which alter the doc should be prefaced
    1:  *  with a call to StartOperation, naming the action and direction */
    1: NS_IMETHODIMP
    1: nsEditor::StartOperation(PRInt32 opID, nsIEditor::EDirection aDirection)
    1: {
    1:   mAction = opID;
    1:   mDirection = aDirection;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: /** All editor operations which alter the doc should be followed
    1:  *  with a call to EndOperation */
    1: NS_IMETHODIMP
    1: nsEditor::EndOperation()
    1: {
    1:   mAction = nsnull;
    1:   mDirection = eNone;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::CloneAttribute(const nsAString & aAttribute,
    1:                          nsIDOMNode *aDestNode, nsIDOMNode *aSourceNode)
    1: {
43807:   NS_ENSURE_TRUE(aDestNode && aSourceNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMElement> destElement = do_QueryInterface(aDestNode);
    1:   nsCOMPtr<nsIDOMElement> sourceElement = do_QueryInterface(aSourceNode);
43807:   NS_ENSURE_TRUE(destElement && sourceElement, NS_ERROR_NO_INTERFACE);
    1: 
    1:   nsAutoString attrValue;
    1:   PRBool isAttrSet;
    1:   nsresult rv = GetAttributeValue(sourceElement,
    1:                                   aAttribute,
    1:                                   attrValue,
    1:                                   &isAttrSet);
43808:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (isAttrSet)
    1:     rv = SetAttribute(destElement, aAttribute, attrValue);
    1:   else
    1:     rv = RemoveAttribute(destElement, aAttribute);
    1: 
    1:   return rv;
    1: }
    1: 
    1: // Objects must be DOM elements
    1: NS_IMETHODIMP
    1: nsEditor::CloneAttributes(nsIDOMNode *aDestNode, nsIDOMNode *aSourceNode)
    1: {
43807:   NS_ENSURE_TRUE(aDestNode && aSourceNode, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsCOMPtr<nsIDOMElement> destElement = do_QueryInterface(aDestNode);
    1:   nsCOMPtr<nsIDOMElement> sourceElement = do_QueryInterface(aSourceNode);
43807:   NS_ENSURE_TRUE(destElement && sourceElement, NS_ERROR_NO_INTERFACE);
    1: 
    1:   nsCOMPtr<nsIDOMNamedNodeMap> sourceAttributes;
    1:   sourceElement->GetAttributes(getter_AddRefs(sourceAttributes));
    1:   nsCOMPtr<nsIDOMNamedNodeMap> destAttributes;
    1:   destElement->GetAttributes(getter_AddRefs(destAttributes));
43807:   NS_ENSURE_TRUE(sourceAttributes && destAttributes, NS_ERROR_FAILURE);
    1: 
    1:   nsAutoEditBatch beginBatching(this);
    1: 
    1:   // Use transaction system for undo only if destination
    1:   //   is already in the document
    1:   nsIDOMElement *rootElement = GetRoot();
43807:   NS_ENSURE_TRUE(rootElement, NS_ERROR_NULL_POINTER);
    1: 
    1:   PRBool destInBody = PR_TRUE;
    1:   nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(rootElement);
    1:   nsCOMPtr<nsIDOMNode> p = aDestNode;
    1:   while (p && p != rootNode)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> tmp;
    1:     if (NS_FAILED(p->GetParentNode(getter_AddRefs(tmp))) || !tmp)
    1:     {
    1:       destInBody = PR_FALSE;
    1:       break;
    1:     }
    1:     p = tmp;
    1:   }
    1: 
    1:   PRUint32 sourceCount;
    1:   sourceAttributes->GetLength(&sourceCount);
    1:   PRUint32 i, destCount;
    1:   destAttributes->GetLength(&destCount);
    1:   nsCOMPtr<nsIDOMNode> attrNode;
    1: 
    1:   // Clear existing attributes
    1:   for (i = 0; i < destCount; i++)
    1:   {
    1:     // always remove item number 0 (first item in list)
    1:     if( NS_SUCCEEDED(destAttributes->Item(0, getter_AddRefs(attrNode))) && attrNode)
    1:     {
    1:       nsCOMPtr<nsIDOMAttr> destAttribute = do_QueryInterface(attrNode);
    1:       if (destAttribute)
    1:       {
    1:         nsAutoString str;
    1:         if (NS_SUCCEEDED(destAttribute->GetName(str)))
    1:         {
    1:           if (destInBody)
    1:             RemoveAttribute(destElement, str);
    1:           else
    1:             destElement->RemoveAttribute(str);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsresult result = NS_OK;
    1: 
    1:   // Set just the attributes that the source element has
    1:   for (i = 0; i < sourceCount; i++)
    1:   {
    1:     if( NS_SUCCEEDED(sourceAttributes->Item(i, getter_AddRefs(attrNode))) && attrNode)
    1:     {
    1:       nsCOMPtr<nsIDOMAttr> sourceAttribute = do_QueryInterface(attrNode);
    1:       if (sourceAttribute)
    1:       {
    1:         nsAutoString sourceAttrName;
    1:         if (NS_SUCCEEDED(sourceAttribute->GetName(sourceAttrName)))
    1:         {
    1:           nsAutoString sourceAttrValue;
    1:           /*
    1:           Presence of an attribute in the named node map indicates that it was set on the 
    1:           element even if it has no value.
    1:           */
    1:           if (NS_SUCCEEDED(sourceAttribute->GetValue(sourceAttrValue)))
    1:           {
    1:             if (destInBody) {
    1:               result = SetAttributeOrEquivalent(destElement, sourceAttrName, sourceAttrValue, PR_FALSE);
    1:             }
    1:             else {
    1:               // the element is not inserted in the document yet, we don't want to put a
    1:               // transaction on the UndoStack
    1:               result = SetAttributeOrEquivalent(destElement, sourceAttrName, sourceAttrValue, PR_TRUE);
    1:             }
    1:           } else {
    1:             // Do we ever get here?
    1: #if DEBUG_cmanske
    1:             printf("Attribute in sourceAttribute has empty value in nsEditor::CloneAttributes()\n");
    1: #endif
    1:           }
    1:         }        
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  Protected and static methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: NS_IMETHODIMP nsEditor::ScrollSelectionIntoView(PRBool aScrollToAnchor)
    1: {
    1:   nsCOMPtr<nsISelectionController> selCon;
    1:   if (NS_SUCCEEDED(GetSelectionController(getter_AddRefs(selCon))) && selCon)
    1:   {
    1:     PRInt16 region = nsISelectionController::SELECTION_FOCUS_REGION;
    1: 
    1:     if (aScrollToAnchor)
    1:       region = nsISelectionController::SELECTION_ANCHOR_REGION;
    1: 
    1:     selCon->ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL,
56442:                                     region, 0);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::InsertTextImpl(const nsAString& aStringToInsert, 
    1:                                           nsCOMPtr<nsIDOMNode> *aInOutNode, 
    1:                                           PRInt32 *aInOutOffset,
    1:                                           nsIDOMDocument *aDoc)
    1: {
    1:   // NOTE: caller *must* have already used nsAutoTxnsConserveSelection stack-based
    1:   // class to turn off txn selection updating.  Caller also turned on rules sniffing
    1:   // if desired.
    1:   
53730:   nsresult res;
43806:   NS_ENSURE_TRUE(aInOutNode && *aInOutNode && aInOutOffset && aDoc, NS_ERROR_NULL_POINTER);
    1:   if (!mInIMEMode && aStringToInsert.IsEmpty()) return NS_OK;
    1:   nsCOMPtr<nsIDOMText> nodeAsText = do_QueryInterface(*aInOutNode);
53730:   if (!nodeAsText && IsPlaintextEditor()) {
53730:     // In some cases, aInOutNode is the anonymous DIV, and aInOutOffset is 0.
53730:     // To avoid injecting unneeded text nodes, we first look to see if we have
53730:     // one available.  In that case, we'll just adjust aInOutNode and aInOutOffset
53730:     // accordingly.
53730:     if (*aInOutNode == GetRoot() && *aInOutOffset == 0) {
53730:       nsCOMPtr<nsIDOMNode> possibleTextNode;
53730:       res = (*aInOutNode)->GetFirstChild(getter_AddRefs(possibleTextNode));
53730:       if (NS_SUCCEEDED(res)) {
53730:         nodeAsText = do_QueryInterface(possibleTextNode);
53730:         if (nodeAsText) {
53730:           *aInOutNode = possibleTextNode;
53730:         }
53730:       }
53730:     }
53730:     // In some other cases, aInOutNode is the anonymous DIV, and aInOutOffset points
53730:     // to the terminating mozBR.  In that case, we'll adjust aInOutNode and aInOutOffset
53730:     // to the preceding text node, if any.
53730:     if (!nodeAsText && *aInOutNode == GetRoot() && *aInOutOffset > 0) {
53730:       nsCOMPtr<nsIDOMNodeList> children;
53730:       res = (*aInOutNode)->GetChildNodes(getter_AddRefs(children));
53730:       if (NS_SUCCEEDED(res)) {
53730:         nsCOMPtr<nsIDOMNode> possibleMozBRNode;
55302:         children->Item(*aInOutOffset, getter_AddRefs(possibleMozBRNode));
55302:         if (possibleMozBRNode && nsTextEditUtils::IsMozBR(possibleMozBRNode)) {
53730:           nsCOMPtr<nsIDOMNode> possibleTextNode;
53730:           res = children->Item(*aInOutOffset - 1, getter_AddRefs(possibleTextNode));
53730:           if (NS_SUCCEEDED(res)) {
53730:             nodeAsText = do_QueryInterface(possibleTextNode);
53730:             if (nodeAsText) {
53730:               PRUint32 length;
53730:               res = nodeAsText->GetLength(&length);
53730:               if (NS_SUCCEEDED(res)) {
53730:                 *aInOutOffset = PRInt32(length);
53730:                 *aInOutNode = possibleTextNode;
53730:               }
53730:             }
53730:           }
56048:         } else {
56048:           // The selection might be at the end of the last textnode child,
56048:           // in which case we can just append to the textnode in question.
56048:           nsCOMPtr<nsIDOMNode> possibleTextNode;
56048:           res = children->Item(*aInOutOffset - 1, getter_AddRefs(possibleTextNode));
56048:           nodeAsText = do_QueryInterface(possibleTextNode);
56048:           if (nodeAsText) {
56048:             PRUint32 length;
56048:             res = nodeAsText->GetLength(&length);
56048:             if (NS_SUCCEEDED(res)) {
56048:               *aInOutOffset = PRInt32(length);
56048:               *aInOutNode = possibleTextNode;
56048:             }
56048:           }
53730:         }
53730:       }
53730:     }
53734:     // Sometimes, aInOutNode is the mozBR element itself.  In that case, we'll
53734:     // adjust the insertion point to the previous text node, if one exists, or
53734:     // to the parent anonymous DIV.
53734:     if (nsTextEditUtils::IsMozBR(*aInOutNode) && *aInOutOffset == 0) {
53734:       nsCOMPtr<nsIDOMNode> previous;
53734:       (*aInOutNode)->GetPreviousSibling(getter_AddRefs(previous));
53734:       nodeAsText = do_QueryInterface(previous);
53734:       if (nodeAsText) {
53734:         PRUint32 length;
53734:         res = nodeAsText->GetLength(&length);
53734:         if (NS_SUCCEEDED(res)) {
53734:           *aInOutOffset = PRInt32(length);
53734:           *aInOutNode = previous;
53734:         }
53734:       } else {
53734:         nsCOMPtr<nsIDOMNode> parent;
53734:         (*aInOutNode)->GetParentNode(getter_AddRefs(parent));
53734:         if (parent == GetRoot()) {
53734:           *aInOutNode = parent;
53734:         }
53734:       }
53734:     }
53730:   }
    1:   PRInt32 offset = *aInOutOffset;
    1:   if (mInIMEMode)
    1:   {
    1:     if (!nodeAsText)
    1:     {
    1:       // create a text node
    1:       res = aDoc->CreateTextNode(EmptyString(), getter_AddRefs(nodeAsText));
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(nodeAsText, NS_ERROR_NULL_POINTER);
    1:       nsCOMPtr<nsIDOMNode> newNode = do_QueryInterface(nodeAsText);
    1:       // then we insert it into the dom tree
    1:       res = InsertNode(newNode, *aInOutNode, offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       offset = 0;
    1:     }
    1:     res = InsertTextIntoTextNodeImpl(aStringToInsert, nodeAsText, offset);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:   }
    1:   else
    1:   {
    1:     if (nodeAsText)
    1:     {
    1:       // we are inserting text into an existing text node.
    1:       res = InsertTextIntoTextNodeImpl(aStringToInsert, nodeAsText, offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       *aInOutOffset += aStringToInsert.Length();
    1:     }
    1:     else
    1:     {
    1:       // we are inserting text into a non-text node
    1:       // first we have to create a textnode (this also populates it with the text)
    1:       res = aDoc->CreateTextNode(aStringToInsert, getter_AddRefs(nodeAsText));
43805:       NS_ENSURE_SUCCESS(res, res);
43806:       NS_ENSURE_TRUE(nodeAsText, NS_ERROR_NULL_POINTER);
    1:       nsCOMPtr<nsIDOMNode> newNode = do_QueryInterface(nodeAsText);
    1:       // then we insert it into the dom tree
    1:       res = InsertNode(newNode, *aInOutNode, offset);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       *aInOutNode = newNode;
    1:       *aInOutOffset = aStringToInsert.Length();
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: 
37130: nsresult nsEditor::InsertTextIntoTextNodeImpl(const nsAString& aStringToInsert, 
    1:                                               nsIDOMCharacterData *aTextNode, 
37130:                                               PRInt32 aOffset,
37130:                                               PRBool aSuppressIME)
    1: {
 3030:   nsRefPtr<EditTxn> txn;
20235:   nsresult result = NS_OK;
37130:   PRBool isIMETransaction = PR_FALSE;
37130:   // aSuppressIME is used when editor must insert text, yet this text is not
    1:   // part of current ime operation.  example: adjusting whitespace around an ime insertion.
37130:   if (mIMETextRangeList && mInIMEMode && !aSuppressIME)
    1:   {
    1:     if (!mIMETextNode)
    1:     {
    1:       mIMETextNode = aTextNode;
    1:       mIMETextOffset = aOffset;
    1:     }
    1:     PRUint16 len ;
20235:     len = mIMETextRangeList->GetLength();
20235:     if (len > 0)
    1:     {
    1:       nsCOMPtr<nsIPrivateTextRange> range;
    1:       for (PRUint16 i = 0; i < len; i++) 
    1:       {
20235:         range = mIMETextRangeList->Item(i);
20235:         if (range)
    1:         {
    1:           PRUint16 type;
    1:           result = range->GetRangeType(&type);
    1:           if (NS_SUCCEEDED(result)) 
    1:           {
    1:             if (type == nsIPrivateTextRange::TEXTRANGE_RAWINPUT) 
    1:             {
    1:               PRUint16 start, end;
    1:               result = range->GetRangeStart(&start);
    1:               if (NS_SUCCEEDED(result)) 
    1:               {
    1:                 result = range->GetRangeEnd(&end);
    1:                 if (NS_SUCCEEDED(result)) 
    1:                 {
    1:                   if (!mPhonetic)
    1:                     mPhonetic = new nsString();
    1:                   if (mPhonetic)
    1:                   {
    1:                     nsAutoString tmp(aStringToInsert);                  
    1:                     tmp.Mid(*mPhonetic, start, end-start);
    1:                   }
    1:                 }
    1:               }
    1:             } // if
    1:           }
    1:         } // if
    1:       } // for
    1:     } // if
    1: 
 3030:     nsRefPtr<IMETextTxn> imeTxn;
 3030:     result = CreateTxnForIMEText(aStringToInsert, getter_AddRefs(imeTxn));
 3030:     txn = imeTxn;
37130:     isIMETransaction = PR_TRUE;
    1:   }
    1:   else
    1:   {
 3030:     nsRefPtr<InsertTextTxn> insertTxn;
 3030:     result = CreateTxnForInsertText(aStringToInsert, aTextNode, aOffset,
 3030:                                     getter_AddRefs(insertTxn));
 3030:     txn = insertTxn;
 3030:   }
43805:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   // let listeners know what's up
    1:   PRInt32 i;
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->WillInsertText(aTextNode, aOffset, aStringToInsert);
    1:   
    1:   // XXX we may not need these view batches anymore.  This is handled at a higher level now I believe
    1:   BeginUpdateViewBatch();
    1:   result = DoTransaction(txn);
    1:   EndUpdateViewBatch();
    1: 
    1:   mRangeUpdater.SelAdjInsertText(aTextNode, aOffset, aStringToInsert);
    1:   
    1:   // let listeners know what happened
    1:   for (i = 0; i < mActionListeners.Count(); i++)
    1:     mActionListeners[i]->DidInsertText(aTextNode, aOffset, aStringToInsert, result);
    1: 
    1:   // Added some cruft here for bug 43366.  Layout was crashing because we left an 
    1:   // empty text node lying around in the document.  So I delete empty text nodes
    1:   // caused by IME.  I have to mark the IME transaction as "fixed", which means
    1:   // that furure ime txns won't merge with it.  This is because we don't want
    1:   // future ime txns trying to put their text into a node that is no longer in
    1:   // the document.  This does not break undo/redo, because all these txns are 
    1:   // wrapped in a parent PlaceHolder txn, and placeholder txns are already 
    1:   // savvy to having multiple ime txns inside them.
    1:   
    1:   // delete empty ime text node if there is one
60293:   if (isIMETransaction && mIMETextNode)
    1:   {
    1:     PRUint32 len;
    1:     mIMETextNode->GetLength(&len);
    1:     if (!len)
    1:     {
    1:       DeleteNode(mIMETextNode);
    1:       mIMETextNode = nsnull;
 3233:       static_cast<IMETextTxn*>(txn.get())->MarkFixed();  // mark the ime txn "fixed"
 3030:     }
 3030:   }
 3030:   
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::SelectEntireDocument(nsISelection *aSelection)
    1: {
    1:   if (!aSelection) { return NS_ERROR_NULL_POINTER; }
    1: 
    1:   nsIDOMElement *rootElement = GetRoot();
    1:   if (!rootElement) { return NS_ERROR_NOT_INITIALIZED; }
    1: 
    1:   return aSelection->SelectAllChildren(rootElement);
    1: }
    1: 
    1: 
    1: nsresult nsEditor::GetFirstEditableNode(nsIDOMNode *aRoot, nsCOMPtr<nsIDOMNode> *outFirstNode)
    1: {
43806:   NS_ENSURE_TRUE(aRoot && outFirstNode, NS_ERROR_NULL_POINTER);
    1:   nsresult rv = NS_OK;
    1:   *outFirstNode = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNode> node = GetLeftmostChild(aRoot);
    1:   if (node && !IsEditable(node))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> next;
    1:     rv = GetNextNode(node, PR_TRUE, address_of(next));
    1:     node = next;
    1:   }
    1:   
    1:   if (node != aRoot)
    1:     *outFirstNode = node;
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef XXX_DEAD_CODE
    1: // jfrancis wants to keep this method around for reference
    1: nsresult nsEditor::GetLastEditableNode(nsIDOMNode *aRoot, nsCOMPtr<nsIDOMNode> *outLastNode)
    1: {
43806:   NS_ENSURE_TRUE(aRoot && outLastNode, NS_ERROR_NULL_POINTER);
    1:   nsresult rv = NS_OK;
    1:   *outLastNode = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNode> node = GetRightmostChild(aRoot);
    1:   if (node && !IsEditable(node))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> next;
    1:     rv = GetPriorNode(node, PR_TRUE, address_of(next));
    1:     node = next;
    1:   }
    1: 
    1:   if (node != aRoot)
    1:     *outLastNode = node;
    1: 
    1:   return rv;
    1: }
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::NotifyDocumentListeners(TDocumentListenerNotification aNotificationType)
    1: {
    1:   PRInt32 numListeners = mDocStateListeners.Count();
43895:   if (!numListeners)    // maybe there just aren't any.
43895:     return NS_OK;
    1:  
30079:   nsCOMArray<nsIDocumentStateListener> listeners(mDocStateListeners);
    1:   nsresult rv = NS_OK;
    1:   PRInt32 i;
30079: 
    1:   switch (aNotificationType)
    1:   {
    1:     case eDocumentCreated:
    1:       for (i = 0; i < numListeners;i++)
    1:       {
30079:         rv = listeners[i]->NotifyDocumentCreated();
    1:         if (NS_FAILED(rv))
    1:           break;
    1:       }
    1:       break;
    1:       
    1:     case eDocumentToBeDestroyed:
    1:       for (i = 0; i < numListeners;i++)
    1:       {
30079:         rv = listeners[i]->NotifyDocumentWillBeDestroyed();
    1:         if (NS_FAILED(rv))
    1:           break;
    1:       }
    1:       break;
    1:   
    1:     case eDocumentStateChanged:
    1:       {
    1:         PRBool docIsDirty;
    1:         rv = GetDocumentModified(&docIsDirty);
43805:         NS_ENSURE_SUCCESS(rv, rv);
    1:         
    1:         if (docIsDirty == mDocDirtyState)
    1:           return NS_OK;
    1:         
    1:         mDocDirtyState = (PRInt8)docIsDirty;
    1:         
    1:         for (i = 0; i < numListeners;i++)
    1:         {
30079:           rv = listeners[i]->NotifyDocumentStateChanged(mDocDirtyState);
    1:           if (NS_FAILED(rv))
    1:             break;
    1:         }
    1:       }
    1:       break;
    1:     
    1:     default:
    1:       NS_NOTREACHED("Unknown notification");
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForInsertText(const nsAString & aStringToInsert,
    1:                                                nsIDOMCharacterData *aTextNode,
    1:                                                PRInt32 aOffset,
    1:                                                InsertTextTxn ** aTxn)
    1: {
43806:   NS_ENSURE_TRUE(aTextNode && aTxn, NS_ERROR_NULL_POINTER);
    1:   nsresult result;
    1: 
27825:   *aTxn = new InsertTextTxn();
43806:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
    1:   result = (*aTxn)->Init(aTextNode, aOffset, aStringToInsert, this);
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::DeleteText(nsIDOMCharacterData *aElement,
    1:                               PRUint32             aOffset,
    1:                               PRUint32             aLength)
    1: {
 3030:   nsRefPtr<DeleteTextTxn> txn;
 3030:   nsresult result = CreateTxnForDeleteText(aElement, aOffset, aLength,
 3030:                                            getter_AddRefs(txn));
    1:   nsAutoRules beginRulesSniffing(this, kOpDeleteText, nsIEditor::ePrevious);
    1:   if (NS_SUCCEEDED(result))  
    1:   {
    1:     // let listeners know what's up
    1:     PRInt32 i;
    1:     for (i = 0; i < mActionListeners.Count(); i++)
    1:       mActionListeners[i]->WillDeleteText(aElement, aOffset, aLength);
    1:     
    1:     result = DoTransaction(txn); 
    1:     
    1:     // let listeners know what happened
    1:     for (i = 0; i < mActionListeners.Count(); i++)
    1:       mActionListeners[i]->DidDeleteText(aElement, aOffset, aLength, result);
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForDeleteText(nsIDOMCharacterData *aElement,
    1:                                                PRUint32             aOffset,
    1:                                                PRUint32             aLength,
    1:                                                DeleteTextTxn      **aTxn)
    1: {
43807:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
    1: 
27825:   *aTxn = new DeleteTextTxn();
43807:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
27825:   return (*aTxn)->Init(this, aElement, aOffset, aLength, &mRangeUpdater);
    1: }
    1: 
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForSplitNode(nsIDOMNode *aNode,
    1:                                          PRUint32    aOffset,
    1:                                          SplitElementTxn **aTxn)
    1: {
43807:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1: 
27825:   *aTxn = new SplitElementTxn();
43807:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
    1: 
    1:   return (*aTxn)->Init(this, aNode, aOffset);
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForJoinNode(nsIDOMNode  *aLeftNode,
    1:                                              nsIDOMNode  *aRightNode,
    1:                                              JoinElementTxn **aTxn)
    1: {
43807:   NS_ENSURE_TRUE(aLeftNode && aRightNode, NS_ERROR_NULL_POINTER);
    1: 
27825:   *aTxn = new JoinElementTxn();
43807:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
27825: 
27825:   return (*aTxn)->Init(this, aLeftNode, aRightNode);
    1: }
    1: 
    1: 
    1: // END nsEditor core implementation
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  nsEditor public static helper methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: // BEGIN nsEditor public helper methods
    1: 
    1: nsresult
    1: nsEditor::SplitNodeImpl(nsIDOMNode * aExistingRightNode,
    1:                         PRInt32      aOffset,
    1:                         nsIDOMNode*  aNewLeftNode,
    1:                         nsIDOMNode*  aParent)
    1: {
    1: #ifdef NS_DEBUG_EDITOR
    1:   if (gNoisy) { printf("SplitNodeImpl: left=%p, right=%p, offset=%d\n", (void*)aNewLeftNode, (void*)aExistingRightNode, aOffset); }
    1: #endif
    1: 
    1:   NS_ASSERTION(((nsnull!=aExistingRightNode) &&
    1:                 (nsnull!=aNewLeftNode) &&
    1:                 (nsnull!=aParent)),
    1:                 "null arg");
    1:   nsresult result;
    1:   if ((nsnull!=aExistingRightNode) &&
    1:       (nsnull!=aNewLeftNode) &&
    1:       (nsnull!=aParent))
    1:   {
    1:     // get selection
    1:     nsCOMPtr<nsISelection> selection;
    1:     result = GetSelection(getter_AddRefs(selection));
43805:     NS_ENSURE_SUCCESS(result, result);
43806:     NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1: 
    1:     // remember some selection points
    1:     nsCOMPtr<nsIDOMNode> selStartNode, selEndNode;
    1:     PRInt32 selStartOffset, selEndOffset;
43518:     result = GetStartNodeAndOffset(selection, getter_AddRefs(selStartNode), &selStartOffset);
    1:     if (NS_FAILED(result)) selStartNode = nsnull;  // if selection is cleared, remember that
43518:     result = GetEndNodeAndOffset(selection, getter_AddRefs(selEndNode), &selEndOffset);
    1:     if (NS_FAILED(result)) selStartNode = nsnull;  // if selection is cleared, remember that
    1: 
    1:     nsCOMPtr<nsIDOMNode> resultNode;
    1:     result = aParent->InsertBefore(aNewLeftNode, aExistingRightNode, getter_AddRefs(resultNode));
    1:     //printf("  after insert\n"); content->List();  // DEBUG
    1:     if (NS_SUCCEEDED(result))
    1:     {
    1:       // split the children between the 2 nodes
    1:       // at this point, aExistingRightNode has all the children
    1:       // move all the children whose index is < aOffset to aNewLeftNode
    1:       if (0<=aOffset) // don't bother unless we're going to move at least one child
    1:       {
    1:         // if it's a text node, just shuffle around some text
    1:         nsCOMPtr<nsIDOMCharacterData> rightNodeAsText( do_QueryInterface(aExistingRightNode) );
    1:         nsCOMPtr<nsIDOMCharacterData> leftNodeAsText( do_QueryInterface(aNewLeftNode) );
    1:         if (leftNodeAsText && rightNodeAsText)
    1:         {
    1:           // fix right node
    1:           nsAutoString leftText;
    1:           rightNodeAsText->SubstringData(0, aOffset, leftText);
    1:           rightNodeAsText->DeleteData(0, aOffset);
    1:           // fix left node
    1:           leftNodeAsText->SetData(leftText);
    1:           // moose          
    1:         }
    1:         else
    1:         {  // otherwise it's an interior node, so shuffle around the children
    1:            // go through list backwards so deletes don't interfere with the iteration
    1:           nsCOMPtr<nsIDOMNodeList> childNodes;
    1:           result = aExistingRightNode->GetChildNodes(getter_AddRefs(childNodes));
    1:           if ((NS_SUCCEEDED(result)) && (childNodes))
    1:           {
    1:             PRInt32 i=aOffset-1;
    1:             for ( ; ((NS_SUCCEEDED(result)) && (0<=i)); i--)
    1:             {
    1:               nsCOMPtr<nsIDOMNode> childNode;
    1:               result = childNodes->Item(i, getter_AddRefs(childNode));
    1:               if ((NS_SUCCEEDED(result)) && (childNode))
    1:               {
    1:                 result = aExistingRightNode->RemoveChild(childNode, getter_AddRefs(resultNode));
    1:                 //printf("  after remove\n"); content->List();  // DEBUG
    1:                 if (NS_SUCCEEDED(result))
    1:                 {
    1:                   nsCOMPtr<nsIDOMNode> firstChild;
    1:                   aNewLeftNode->GetFirstChild(getter_AddRefs(firstChild));
    1:                   result = aNewLeftNode->InsertBefore(childNode, firstChild, getter_AddRefs(resultNode));
    1:                   //printf("  after append\n"); content->List();  // DEBUG
    1:                 }
    1:               }
    1:             }
    1:           }        
    1:         }
    1:         // handle selection
42409:         nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
42409:         if (ps)
42409:           ps->FlushPendingNotifications(Flush_Frames);
42409: 
    1:         if (GetShouldTxnSetSelection())
    1:         {
    1:           // editor wants us to set selection at split point
    1:           selection->Collapse(aNewLeftNode, aOffset);
    1:         }
    1:         else if (selStartNode)   
    1:         {
    1:           // else adjust the selection if needed.  if selStartNode is null, then there was no selection.
    1:           // HACK: this is overly simplified - multi-range selections need more work than this
    1:           if (selStartNode.get() == aExistingRightNode)
    1:           {
    1:             if (selStartOffset < aOffset)
    1:             {
    1:               selStartNode = aNewLeftNode;
    1:             }
    1:             else
    1:             {
    1:               selStartOffset -= aOffset;
    1:             }
    1:           }
    1:           if (selEndNode.get() == aExistingRightNode)
    1:           {
    1:             if (selEndOffset < aOffset)
    1:             {
    1:               selEndNode = aNewLeftNode;
    1:             }
    1:             else
    1:             {
    1:               selEndOffset -= aOffset;
    1:             }
    1:           }
    1:           selection->Collapse(selStartNode,selStartOffset);
    1:           selection->Extend(selEndNode,selEndOffset);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else
    1:     result = NS_ERROR_INVALID_ARG;
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsEditor::JoinNodesImpl(nsIDOMNode * aNodeToKeep,
    1:                         nsIDOMNode * aNodeToJoin,
    1:                         nsIDOMNode * aParent,
    1:                         PRBool       aNodeToKeepIsFirst)
    1: {
    1:   NS_ASSERTION(aNodeToKeep && aNodeToJoin && aParent, "null arg");
56879:   nsresult result = NS_OK;
    1:   if (aNodeToKeep && aNodeToJoin && aParent)
    1:   {
    1:     // get selection
    1:     nsCOMPtr<nsISelection> selection;
    1:     GetSelection(getter_AddRefs(selection));
43806:     NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1: 
    1:     // remember some selection points
    1:     nsCOMPtr<nsIDOMNode> selStartNode, selEndNode;
    1:     PRInt32 selStartOffset, selEndOffset, joinOffset, keepOffset;
43518:     result = GetStartNodeAndOffset(selection, getter_AddRefs(selStartNode), &selStartOffset);
    1:     if (NS_FAILED(result)) selStartNode = nsnull;
43518:     result = GetEndNodeAndOffset(selection, getter_AddRefs(selEndNode), &selEndOffset);
    1:     // Joe or Kin should comment here on why the following line is not a copy/paste error
    1:     if (NS_FAILED(result)) selStartNode = nsnull;
    1: 
    1:     nsCOMPtr<nsIDOMNode> leftNode;
    1:     if (aNodeToKeepIsFirst)
    1:       leftNode = aNodeToKeep;
    1:     else
    1:       leftNode = aNodeToJoin;
    1: 
    1:     PRUint32 firstNodeLength;
    1:     result = GetLengthOfDOMNode(leftNode, firstNodeLength);
43805:     NS_ENSURE_SUCCESS(result, result);
    1:     nsCOMPtr<nsIDOMNode> parent;
    1:     result = GetNodeLocation(aNodeToJoin, address_of(parent), &joinOffset);
43805:     NS_ENSURE_SUCCESS(result, result);
    1:     result = GetNodeLocation(aNodeToKeep, address_of(parent), &keepOffset);
43805:     NS_ENSURE_SUCCESS(result, result);
    1:     
    1:     // if selection endpoint is between the nodes, remember it as being
    1:     // in the one that is going away instead.  This simplifies later selection
    1:     // adjustment logic at end of this method.
    1:     if (selStartNode)
    1:     {
    1:       if (selStartNode == parent)
    1:       {
    1:         if (aNodeToKeepIsFirst)
    1:         {
    1:           if ((selStartOffset > keepOffset) && (selStartOffset <= joinOffset))
    1:           {
    1:             selStartNode = aNodeToJoin; 
    1:             selStartOffset = 0;
    1:           }
    1:         }
    1:         else
    1:         {
    1:           if ((selStartOffset > joinOffset) && (selStartOffset <= keepOffset))
    1:           {
    1:             selStartNode = aNodeToJoin; 
    1:             selStartOffset = firstNodeLength;
    1:           }
    1:         }
    1:       }
    1:       if (selEndNode == parent)
    1:       {
    1:         if (aNodeToKeepIsFirst)
    1:         {
    1:           if ((selEndOffset > keepOffset) && (selEndOffset <= joinOffset))
    1:           {
    1:             selEndNode = aNodeToJoin; 
    1:             selEndOffset = 0;
    1:           }
    1:         }
    1:         else
    1:         {
    1:           if ((selEndOffset > joinOffset) && (selEndOffset <= keepOffset))
    1:           {
    1:             selEndNode = aNodeToJoin; 
    1:             selEndOffset = firstNodeLength;
    1:           }
    1:         }
    1:       }
    1:     }
    1:     // ok, ready to do join now.
    1:     // if it's a text node, just shuffle around some text
    1:     nsCOMPtr<nsIDOMCharacterData> keepNodeAsText( do_QueryInterface(aNodeToKeep) );
    1:     nsCOMPtr<nsIDOMCharacterData> joinNodeAsText( do_QueryInterface(aNodeToJoin) );
    1:     if (keepNodeAsText && joinNodeAsText)
    1:     {
    1:       nsAutoString rightText;
    1:       nsAutoString leftText;
    1:       if (aNodeToKeepIsFirst)
    1:       {
    1:         keepNodeAsText->GetData(leftText);
    1:         joinNodeAsText->GetData(rightText);
    1:       }
    1:       else
    1:       {
    1:         keepNodeAsText->GetData(rightText);
    1:         joinNodeAsText->GetData(leftText);
    1:       }
    1:       leftText += rightText;
    1:       keepNodeAsText->SetData(leftText);          
    1:     }
    1:     else
    1:     {  // otherwise it's an interior node, so shuffle around the children
    1:       nsCOMPtr<nsIDOMNodeList> childNodes;
    1:       result = aNodeToJoin->GetChildNodes(getter_AddRefs(childNodes));
    1:       if ((NS_SUCCEEDED(result)) && (childNodes))
    1:       {
    1:         PRInt32 i;  // must be signed int!
    1:         PRUint32 childCount=0;
    1:         nsCOMPtr<nsIDOMNode> firstNode; //only used if aNodeToKeepIsFirst is false
    1:         childNodes->GetLength(&childCount);
    1:         if (!aNodeToKeepIsFirst)
    1:         { // remember the first child in aNodeToKeep, we'll insert all the children of aNodeToJoin in front of it
    1:           result = aNodeToKeep->GetFirstChild(getter_AddRefs(firstNode));  
    1:           // GetFirstChild returns nsnull firstNode if aNodeToKeep has no children, that's ok.
    1:         }
    1:         nsCOMPtr<nsIDOMNode> resultNode;
    1:         // have to go through the list backwards to keep deletes from interfering with iteration
    1:         nsCOMPtr<nsIDOMNode> previousChild;
    1:         for (i=childCount-1; ((NS_SUCCEEDED(result)) && (0<=i)); i--)
    1:         {
    1:           nsCOMPtr<nsIDOMNode> childNode;
    1:           result = childNodes->Item(i, getter_AddRefs(childNode));
    1:           if ((NS_SUCCEEDED(result)) && (childNode))
    1:           {
    1:             if (aNodeToKeepIsFirst)
    1:             { // append children of aNodeToJoin
    1:               //was result = aNodeToKeep->AppendChild(childNode, getter_AddRefs(resultNode));
    1:               result = aNodeToKeep->InsertBefore(childNode, previousChild, getter_AddRefs(resultNode));
    1:               previousChild = do_QueryInterface(childNode);
    1:             }
    1:             else
    1:             { // prepend children of aNodeToJoin
    1:               result = aNodeToKeep->InsertBefore(childNode, firstNode, getter_AddRefs(resultNode));
    1:               firstNode = do_QueryInterface(childNode);
    1:             }
    1:           }
    1:         }
    1:       }
    1:       else if (!childNodes) {
    1:         result = NS_ERROR_NULL_POINTER;
    1:       }
    1:     }
    1:     if (NS_SUCCEEDED(result))
    1:     { // delete the extra node
    1:       nsCOMPtr<nsIDOMNode> resultNode;
    1:       result = aParent->RemoveChild(aNodeToJoin, getter_AddRefs(resultNode));
    1:       
    1:       if (GetShouldTxnSetSelection())
    1:       {
    1:         // editor wants us to set selection at join point
    1:         selection->Collapse(aNodeToKeep, firstNodeLength);
    1:       }
    1:       else if (selStartNode)
    1:       {
    1:         // and adjust the selection if needed
    1:         // HACK: this is overly simplified - multi-range selections need more work than this
    1:         PRBool bNeedToAdjust = PR_FALSE;
    1:         
    1:         // check to see if we joined nodes where selection starts
    1:         if (selStartNode.get() == aNodeToJoin)
    1:         {
    1:           bNeedToAdjust = PR_TRUE;
    1:           selStartNode = aNodeToKeep;
    1:           if (aNodeToKeepIsFirst)
    1:           {
    1:             selStartOffset += firstNodeLength;
    1:           }
    1:         }
    1:         else if ((selStartNode.get() == aNodeToKeep) && !aNodeToKeepIsFirst)
    1:         {
    1:           bNeedToAdjust = PR_TRUE;
    1:           selStartOffset += firstNodeLength;
    1:         }
    1:                 
    1:         // check to see if we joined nodes where selection ends
    1:         if (selEndNode.get() == aNodeToJoin)
    1:         {
    1:           bNeedToAdjust = PR_TRUE;
    1:           selEndNode = aNodeToKeep;
    1:           if (aNodeToKeepIsFirst)
    1:           {
    1:             selEndOffset += firstNodeLength;
    1:           }
    1:         }
    1:         else if ((selEndNode.get() == aNodeToKeep) && !aNodeToKeepIsFirst)
    1:         {
    1:           bNeedToAdjust = PR_TRUE;
    1:           selEndOffset += firstNodeLength;
    1:         }
    1:         
    1:         // adjust selection if needed
    1:         if (bNeedToAdjust)
    1:         {
    1:           selection->Collapse(selStartNode,selStartOffset);
    1:           selection->Extend(selEndNode,selEndOffset);          
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else
    1:     result = NS_ERROR_INVALID_ARG;
    1: 
    1:   return result;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetChildOffset(nsIDOMNode *aChild, nsIDOMNode *aParent, PRInt32 &aOffset)
    1: {
    1:   NS_ASSERTION((aChild && aParent), "bad args");
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aParent);
    1:   nsCOMPtr<nsIContent> cChild = do_QueryInterface(aChild);
43807:   NS_ENSURE_TRUE(cChild && content, NS_ERROR_NULL_POINTER);
    1: 
    1:   aOffset = content->IndexOf(cChild);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::GetNodeLocation(nsIDOMNode *inChild, nsCOMPtr<nsIDOMNode> *outParent, PRInt32 *outOffset)
    1: {
    1:   NS_ASSERTION((inChild && outParent && outOffset), "bad args");
    1:   nsresult result = NS_ERROR_NULL_POINTER;
    1:   if (inChild && outParent && outOffset)
    1:   {
    1:     result = inChild->GetParentNode(getter_AddRefs(*outParent));
    1:     if ((NS_SUCCEEDED(result)) && (*outParent))
    1:     {
    1:       result = GetChildOffset(inChild, *outParent, *outOffset);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: // returns the number of things inside aNode.  
    1: // If aNode is text, returns number of characters. If not, returns number of children nodes.
    1: nsresult
    1: nsEditor::GetLengthOfDOMNode(nsIDOMNode *aNode, PRUint32 &aCount) 
    1: {
    1:   aCount = 0;
    1:   if (!aNode) { return NS_ERROR_NULL_POINTER; }
    1:   nsresult result=NS_OK;
    1:   nsCOMPtr<nsIDOMCharacterData>nodeAsChar = do_QueryInterface(aNode);
    1:   if (nodeAsChar) {
    1:     nodeAsChar->GetLength(&aCount);
    1:   }
    1:   else
    1:   {
    1:     PRBool hasChildNodes;
    1:     aNode->HasChildNodes(&hasChildNodes);
    1:     if (hasChildNodes)
    1:     {
    1:       nsCOMPtr<nsIDOMNodeList>nodeList;
    1:       result = aNode->GetChildNodes(getter_AddRefs(nodeList));
    1:       if (NS_SUCCEEDED(result) && nodeList) {
    1:         nodeList->GetLength(&aCount);
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetPriorNode(nsIDOMNode  *aParentNode, 
    1:                        PRInt32      aOffset, 
    1:                        PRBool       aEditableNode, 
    1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                        PRBool       bNoBlockCrossing)
    1: {
    1:   // just another version of GetPriorNode that takes a {parent, offset}
    1:   // instead of a node
    1:   if (!aParentNode || !aResultNode) { return NS_ERROR_NULL_POINTER; }
    1:   *aResultNode = nsnull;
    1:   
    1:   // if we are at beginning of node, or it is a textnode, then just look before it
    1:   if (!aOffset || IsTextNode(aParentNode))
    1:   {
    1:     if (bNoBlockCrossing && IsBlockNode(aParentNode))
    1:     {
    1:       // if we aren't allowed to cross blocks, don't look before this block
    1:       return NS_OK;
    1:     }
    1:     return GetPriorNode(aParentNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1:   }
    1: 
    1:   // else look before the child at 'aOffset'
    1:   nsCOMPtr<nsIDOMNode> child = GetChildAt(aParentNode, aOffset);
    1:   if (child)
    1:     return GetPriorNode(child, aEditableNode, aResultNode, bNoBlockCrossing);
    1: 
    1:   // unless there isn't one, in which case we are at the end of the node
    1:   // and want the deep-right child.
    1:   *aResultNode = GetRightmostChild(aParentNode, bNoBlockCrossing);
    1:   if (!*aResultNode || !aEditableNode || IsEditable(*aResultNode))
    1:     return NS_OK;
    1: 
    1:   // restart the search from the non-editable node we just found
    1:   nsCOMPtr<nsIDOMNode> notEditableNode = do_QueryInterface(*aResultNode);
    1:   return GetPriorNode(notEditableNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetNextNode(nsIDOMNode   *aParentNode, 
    1:                        PRInt32      aOffset, 
    1:                        PRBool       aEditableNode, 
    1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                        PRBool       bNoBlockCrossing)
    1: {
    1:   // just another version of GetNextNode that takes a {parent, offset}
    1:   // instead of a node
    1:   if (!aParentNode || !aResultNode) { return NS_ERROR_NULL_POINTER; }
    1:   
    1:   *aResultNode = nsnull;
    1: 
    1:   // if aParentNode is a text node, use it's location instead
    1:   if (IsTextNode(aParentNode))
    1:   {
    1:     nsCOMPtr<nsIDOMNode> parent;
    1:     nsEditor::GetNodeLocation(aParentNode, address_of(parent), &aOffset);
    1:     aParentNode = parent;
    1:     aOffset++;  // _after_ the text node
    1:   }
    1:   // look at the child at 'aOffset'
    1:   nsCOMPtr<nsIDOMNode> child = GetChildAt(aParentNode, aOffset);
    1:   if (child)
    1:   {
    1:     if (bNoBlockCrossing && IsBlockNode(child))
    1:     {
    1:       *aResultNode = child;  // return this block
    1:       return NS_OK;
    1:     }
    1:     *aResultNode = GetLeftmostChild(child, bNoBlockCrossing);
    1:     if (!*aResultNode) 
    1:     {
    1:       *aResultNode = child;
    1:       return NS_OK;
    1:     }
    1:     if (!IsDescendantOfBody(*aResultNode))
    1:     {
    1:       *aResultNode = nsnull;
    1:       return NS_OK;
    1:     }
    1: 
    1:     if (!aEditableNode || IsEditable(*aResultNode))
    1:       return NS_OK;
    1: 
    1:     // restart the search from the non-editable node we just found
    1:     nsCOMPtr<nsIDOMNode> notEditableNode = do_QueryInterface(*aResultNode);
    1:     return GetNextNode(notEditableNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1:   }
    1:     
    1:   // unless there isn't one, in which case we are at the end of the node
    1:   // and want the next one.
    1:   if (bNoBlockCrossing && IsBlockNode(aParentNode))
    1:   {
    1:     // don't cross out of parent block
    1:     return NS_OK;
    1:   }
    1:   return GetNextNode(aParentNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetPriorNode(nsIDOMNode  *aCurrentNode, 
    1:                        PRBool       aEditableNode, 
    1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                        PRBool       bNoBlockCrossing)
    1: {
    1:   nsresult result;
    1:   if (!aCurrentNode || !aResultNode) { return NS_ERROR_NULL_POINTER; }
    1:   
    1:   *aResultNode = nsnull;  // init out-param
    1: 
    1:   if (IsRootNode(aCurrentNode))
    1:   {
    1:     // Don't allow traversal above the root node! This helps
    1:     // prevent us from accidentally editing browser content
    1:     // when the editor is in a text widget.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> candidate;
    1:   result = GetPriorNodeImpl(aCurrentNode, aEditableNode, address_of(candidate), bNoBlockCrossing);
43805:   NS_ENSURE_SUCCESS(result, result);
    1:   
    1:   if (!candidate)
    1:   {
    1:     // we could not find a prior node.  return null.
    1:     return NS_OK;
    1:   }
    1:   else if (!aEditableNode) *aResultNode = candidate;
    1:   else if (IsEditable(candidate)) *aResultNode = candidate;
    1:   else 
    1:   { // restart the search from the non-editable node we just found
    1:     nsCOMPtr<nsIDOMNode> notEditableNode = do_QueryInterface(candidate);
    1:     return GetPriorNode(notEditableNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::GetPriorNodeImpl(nsIDOMNode  *aCurrentNode, 
    1:                            PRBool       aEditableNode, 
    1:                            nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                            PRBool       bNoBlockCrossing)
    1: {
    1:   // called only by GetPriorNode so we don't need to check params.
    1: 
    1:   // if aCurrentNode has a left sibling, return that sibling's rightmost child (or itself if it has no children)
    1:   nsCOMPtr<nsIDOMNode> prevSibling;
    1:   nsresult result = aCurrentNode->GetPreviousSibling(getter_AddRefs(prevSibling));
    1:   if ((NS_SUCCEEDED(result)) && prevSibling)
    1:   {
    1:     if (bNoBlockCrossing && IsBlockNode(prevSibling))
    1:     {
    1:       // don't look inside prevsib, since it is a block
    1:       *aResultNode = prevSibling;
    1:       return NS_OK;
    1:     }
    1:     *aResultNode = GetRightmostChild(prevSibling, bNoBlockCrossing);
    1:     if (!*aResultNode) 
    1:     { 
    1:       *aResultNode = prevSibling;
    1:       return NS_OK;
    1:     }
    1:     if (!IsDescendantOfBody(*aResultNode))
    1:     {
    1:       *aResultNode = nsnull;
    1:       return NS_OK;
    1:     }
    1:   }
    1:   else
    1:   {
    1:     // otherwise, walk up the parent tree until there is a child that comes before 
    1:     // the ancestor of aCurrentNode.  Then return that node's rightmost child
    1:     nsCOMPtr<nsIDOMNode> parent = do_QueryInterface(aCurrentNode);
    1:     nsCOMPtr<nsIDOMNode> node, notEditableNode;
    1:     do {
    1:       node = parent;
    1:       result = node->GetParentNode(getter_AddRefs(parent));
    1:       if ((NS_SUCCEEDED(result)) && parent)
    1:       {
    1:         if (!IsDescendantOfBody(parent))
    1:         {
    1:           *aResultNode = nsnull;
    1:           return NS_OK;
    1:         }
    1:         if ((bNoBlockCrossing && IsBlockNode(parent)) || IsRootNode(parent))
    1:         {
    1:           // we are at front of block or root, do not step out
    1:           *aResultNode = nsnull;
    1:           return NS_OK;
    1:         }
    1:         result = parent->GetPreviousSibling(getter_AddRefs(node));
    1:         if ((NS_SUCCEEDED(result)) && node)
    1:         {
    1:           if (bNoBlockCrossing && IsBlockNode(node))
    1:           {
    1:             // prev sibling is a block, do not step into it
    1:             *aResultNode = node;
    1:             return NS_OK;
    1:           }
    1:           *aResultNode = GetRightmostChild(node, bNoBlockCrossing);
    1:           if (!*aResultNode)  *aResultNode = node;
    1:           return NS_OK;
    1:         }
    1:       }
    1:     } while ((NS_SUCCEEDED(result)) && parent && !*aResultNode);
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::GetNextNode(nsIDOMNode  *aCurrentNode, 
    1:                       PRBool       aEditableNode, 
    1:                       nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                       PRBool       bNoBlockCrossing)
    1: {
    1:   if (!aCurrentNode || !aResultNode) { return NS_ERROR_NULL_POINTER; }
    1:   
    1:   *aResultNode = nsnull;  // init out-param
    1: 
    1:   if (IsRootNode(aCurrentNode))
    1:   {
    1:     // Don't allow traversal above the root node! This helps
    1:     // prevent us from accidentally editing browser content
    1:     // when the editor is in a text widget.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMNode> candidate;
    1:   nsresult result = GetNextNodeImpl(aCurrentNode, aEditableNode,
    1:                                     address_of(candidate), bNoBlockCrossing);
43805:   NS_ENSURE_SUCCESS(result, result);
    1:   
    1:   if (!candidate)
    1:   {
    1:     // we could not find a next node.  return null.
    1:     *aResultNode = nsnull;
    1:     return NS_OK;
    1:   }
    1:   else if (!aEditableNode) *aResultNode = candidate;
    1:   else if (IsEditable(candidate)) *aResultNode = candidate;
    1:   else 
    1:   { // restart the search from the non-editable node we just found
    1:     nsCOMPtr<nsIDOMNode> notEditableNode = do_QueryInterface(candidate);
    1:     return GetNextNode(notEditableNode, aEditableNode, aResultNode, bNoBlockCrossing);
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: nsresult 
    1: nsEditor::GetNextNodeImpl(nsIDOMNode  *aCurrentNode, 
    1:                           PRBool       aEditableNode, 
    1:                           nsCOMPtr<nsIDOMNode> *aResultNode,
    1:                           PRBool       bNoBlockCrossing)
    1: {
    1:   // called only by GetNextNode so we don't need to check params.
    1: 
    1:   // if aCurrentNode has a right sibling, return that sibling's leftmost child (or itself if it has no children)
    1:   nsCOMPtr<nsIDOMNode> nextSibling;
    1:   nsresult result = aCurrentNode->GetNextSibling(getter_AddRefs(nextSibling));
    1:   if ((NS_SUCCEEDED(result)) && nextSibling)
    1:   {
    1:     if (bNoBlockCrossing && IsBlockNode(nextSibling))
    1:     {
    1:       // next sibling is a block, do not step into it
    1:       *aResultNode = nextSibling;
    1:       return NS_OK;
    1:     }
    1:     *aResultNode = GetLeftmostChild(nextSibling, bNoBlockCrossing);
    1:     if (!*aResultNode)
    1:     { 
    1:       *aResultNode = nextSibling;
    1:       return NS_OK; 
    1:     }
    1:     if (!IsDescendantOfBody(*aResultNode))
    1:     {
    1:       *aResultNode = nsnull;
    1:       return NS_OK;
    1:     }
    1:   }
    1:   else
    1:   {
    1:     // otherwise, walk up the parent tree until there is a child that comes after 
    1:     // the ancestor of aCurrentNode.  Then return that node's leftmost child
    1:     nsCOMPtr<nsIDOMNode> parent(do_QueryInterface(aCurrentNode));
    1:     nsCOMPtr<nsIDOMNode> node, notEditableNode;
    1:     do {
    1:       node = parent;
    1:       result = node->GetParentNode(getter_AddRefs(parent));
    1:       if ((NS_SUCCEEDED(result)) && parent)
    1:       {
    1:         if (!IsDescendantOfBody(parent))
    1:         {
    1:           *aResultNode = nsnull;
    1:           return NS_OK;
    1:         }
    1:         if ((bNoBlockCrossing && IsBlockNode(parent)) || IsRootNode(parent))
    1:         {
    1:           // we are at end of block or root, do not step out
    1:           *aResultNode = nsnull;
    1:           return NS_OK;
    1:         }
    1:         result = parent->GetNextSibling(getter_AddRefs(node));
    1:         if ((NS_SUCCEEDED(result)) && node)
    1:         {
    1:           if (bNoBlockCrossing && IsBlockNode(node))
    1:           {
    1:             // next sibling is a block, do not step into it
    1:             *aResultNode = node;
    1:             return NS_OK;
    1:           }
    1:           *aResultNode = GetLeftmostChild(node, bNoBlockCrossing);
    1:           if (!*aResultNode) *aResultNode = node;
    1:           return NS_OK; 
    1:         }
    1:       }
    1:     } while ((NS_SUCCEEDED(result)) && parent);
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: nsCOMPtr<nsIDOMNode>
    1: nsEditor::GetRightmostChild(nsIDOMNode *aCurrentNode, 
    1:                             PRBool bNoBlockCrossing)
    1: {
43806:   NS_ENSURE_TRUE(aCurrentNode, nsnull);
    1:   nsCOMPtr<nsIDOMNode> resultNode, temp=aCurrentNode;
    1:   PRBool hasChildren;
    1:   aCurrentNode->HasChildNodes(&hasChildren);
    1:   while (hasChildren)
    1:   {
    1:     temp->GetLastChild(getter_AddRefs(resultNode));
    1:     if (resultNode)
    1:     {
    1:       if (bNoBlockCrossing && IsBlockNode(resultNode))
    1:          return resultNode;
    1:       resultNode->HasChildNodes(&hasChildren);
    1:       temp = resultNode;
    1:     }
    1:     else 
    1:       hasChildren = PR_FALSE;
    1:   }
    1: 
    1:   return resultNode;
    1: }
    1: 
    1: nsCOMPtr<nsIDOMNode>
    1: nsEditor::GetLeftmostChild(nsIDOMNode *aCurrentNode,
    1:                            PRBool bNoBlockCrossing)
    1: {
43806:   NS_ENSURE_TRUE(aCurrentNode, nsnull);
    1:   nsCOMPtr<nsIDOMNode> resultNode, temp=aCurrentNode;
    1:   PRBool hasChildren;
    1:   aCurrentNode->HasChildNodes(&hasChildren);
    1:   while (hasChildren)
    1:   {
    1:     temp->GetFirstChild(getter_AddRefs(resultNode));
    1:     if (resultNode)
    1:     {
    1:       if (bNoBlockCrossing && IsBlockNode(resultNode))
    1:          return resultNode;
    1:       resultNode->HasChildNodes(&hasChildren);
    1:       temp = resultNode;
    1:     }
    1:     else 
    1:       hasChildren = PR_FALSE;
    1:   }
    1: 
    1:   return resultNode;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::IsBlockNode(nsIDOMNode *aNode)
    1: {
    1:   // stub to be overridden in nsHTMLEditor.
41545:   // screwing around with the class hierarchy here in order
    1:   // to not duplicate the code in GetNextNode/GetPrevNode
    1:   // across both nsEditor/nsHTMLEditor.  
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::CanContainTag(nsIDOMNode* aParent, const nsAString &aChildTag)
    1: {
    1:   nsCOMPtr<nsIDOMElement> parentElement = do_QueryInterface(aParent);
43806:   NS_ENSURE_TRUE(parentElement, PR_FALSE);
    1:   
    1:   nsAutoString parentStringTag;
    1:   parentElement->GetTagName(parentStringTag);
    1:   return TagCanContainTag(parentStringTag, aChildTag);
    1: }
    1: 
    1: PRBool 
    1: nsEditor::TagCanContain(const nsAString &aParentTag, nsIDOMNode* aChild)
    1: {
    1:   nsAutoString childStringTag;
    1:   
    1:   if (IsTextNode(aChild)) 
    1:   {
    1:     childStringTag.AssignLiteral("#text");
    1:   }
    1:   else
    1:   {
    1:     nsCOMPtr<nsIDOMElement> childElement = do_QueryInterface(aChild);
43806:     NS_ENSURE_TRUE(childElement, PR_FALSE);
    1:     childElement->GetTagName(childStringTag);
    1:   }
    1:   return TagCanContainTag(aParentTag, childStringTag);
    1: }
    1: 
    1: PRBool 
    1: nsEditor::TagCanContainTag(const nsAString &aParentTag, const nsAString &aChildTag)
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::IsRootNode(nsIDOMNode *inNode) 
    1: {
43807:   NS_ENSURE_TRUE(inNode, PR_FALSE);
    1: 
    1:   nsIDOMElement *rootElement = GetRoot();
    1: 
    1:   nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(rootElement);
    1: 
    1:   return inNode == rootNode;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::IsDescendantOfBody(nsIDOMNode *inNode) 
    1: {
43806:   NS_ENSURE_TRUE(inNode, PR_FALSE);
    1:   nsIDOMElement *rootElement = GetRoot();
43806:   NS_ENSURE_TRUE(rootElement, PR_FALSE);
    1:   nsCOMPtr<nsIDOMNode> root = do_QueryInterface(rootElement);
    1: 
    1:   if (inNode == root.get()) return PR_TRUE;
    1:   
    1:   nsCOMPtr<nsIDOMNode> parent, node = do_QueryInterface(inNode);
    1:   
    1:   do
    1:   {
    1:     node->GetParentNode(getter_AddRefs(parent));
    1:     if (parent == root) return PR_TRUE;
    1:     node = parent;
    1:   } while (parent);
    1:   
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::IsContainer(nsIDOMNode *aNode)
    1: {
    1:   return aNode ? PR_TRUE : PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsEditor::IsTextInDirtyFrameVisible(nsIDOMNode *aNode)
    1: {
    1:   // virtual method
    1:   //
    1:   // If this is a simple non-html editor,
    1:   // the best we can do is to assume it's visible.
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::IsEditable(nsIDOMNode *aNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode, PR_FALSE);
    1: 
 2896:   if (IsMozEditorBogusNode(aNode) || !IsModifiableNode(aNode)) return PR_FALSE;
    1: 
    1:   // see if it has a frame.  If so, we'll edit it.
    1:   // special case for textnodes: frame must have width.
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1:   if (content)
    1:   {
36657:     nsIFrame *resultFrame = content->GetPrimaryFrame();
    1:     if (!resultFrame)   // if it has no frame, it is not editable
    1:       return PR_FALSE;
    1:     NS_ASSERTION(content->IsNodeOfType(nsINode::eTEXT) ||
41645:                  content->IsElement(),
    1:                  "frame for non element-or-text?");
    1:     if (!content->IsNodeOfType(nsINode::eTEXT))
    1:       return PR_TRUE;  // not a text node; has a frame
34011: 
34011:     // test the textframe and all its non-fluid continuations
34011:     while (resultFrame) {
    1:       if (resultFrame->GetStateBits() & NS_FRAME_IS_DIRTY) // we can only trust width data for undirty frames
    1:       {
    1:         // In the past a comment said:
    1:         //   "assume all text nodes with dirty frames are editable"
    1:         // Nowadays we use a virtual function, that assumes TRUE
    1:         // in the simple editor world,
    1:         // and uses enhanced logic to find out in the HTML world.
    1:         return IsTextInDirtyFrameVisible(aNode);
    1:       }
53735:       if (resultFrame->HasAnyNoncollapsedCharacters()) {
53735:         return PR_TRUE;
53735:       }
34011:       resultFrame = resultFrame->GetNextContinuation();
34011:     }
    1:   }
    1:   return PR_FALSE;  // didn't pass any editability test
    1: }
    1: 
    1: PRBool
    1: nsEditor::IsMozEditorBogusNode(nsIDOMNode *aNode)
    1: {
41743:   nsCOMPtr<nsIContent> element = do_QueryInterface(aNode);
41743:   return element &&
41743:          element->AttrValueIs(kNameSpaceID_None, kMOZEditorBogusNodeAttrAtom,
41743:                               kMOZEditorBogusNodeValue, eCaseMatters);
    1: }
    1: 
    1: nsresult
    1: nsEditor::CountEditableChildren(nsIDOMNode *aNode, PRUint32 &outCount) 
    1: {
    1:   outCount = 0;
    1:   if (!aNode) { return NS_ERROR_NULL_POINTER; }
    1:   nsresult res=NS_OK;
    1:   PRBool hasChildNodes;
    1:   aNode->HasChildNodes(&hasChildNodes);
    1:   if (hasChildNodes)
    1:   {
    1:     nsCOMPtr<nsIDOMNodeList>nodeList;
    1:     res = aNode->GetChildNodes(getter_AddRefs(nodeList));
    1:     if (NS_SUCCEEDED(res) && nodeList) 
    1:     {
    1:       PRUint32 i;
    1:       PRUint32 len;
    1:       nodeList->GetLength(&len);
    1:       for (i=0 ; i<len; i++)
    1:       {
    1:         nsCOMPtr<nsIDOMNode> child;
    1:         res = nodeList->Item((PRInt32)i, getter_AddRefs(child));
    1:         if ((NS_SUCCEEDED(res)) && (child))
    1:         {
    1:           if (IsEditable(child))
    1:           {
    1:             outCount++;
    1:           }
    1:         }
    1:       }
    1:     }
    1:     else if (!nodeList)
    1:       res = NS_ERROR_NULL_POINTER;
    1:   }
    1:   return res;
    1: }
    1: 
    1: //END nsEditor static utility methods
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::IncrementModificationCount(PRInt32 inNumMods)
    1: {
    1:   PRUint32 oldModCount = mModCount;
    1: 
    1:   mModCount += inNumMods;
    1: 
    1:   if ((oldModCount == 0 && mModCount != 0)
    1:    || (oldModCount != 0 && mModCount == 0))
    1:     NotifyDocumentListeners(eDocumentStateChanged);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::GetModificationCount(PRInt32 *outModCount)
    1: {
    1:   NS_ENSURE_ARG_POINTER(outModCount);
    1:   *outModCount = mModCount;
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::ResetModificationCount()
    1: {
    1:   PRBool doNotify = (mModCount != 0);
    1: 
    1:   mModCount = 0;
    1: 
    1:   if (doNotify)
    1:     NotifyDocumentListeners(eDocumentStateChanged);
    1:   return NS_OK;
    1: }
    1: 
    1: //END nsEditor Private methods
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetTag: digs out the atom for the tag of this node
    1: //                    
    1: nsIAtom *
    1: nsEditor::GetTag(nsIDOMNode *aNode)
    1: {
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1: 
    1:   if (!content) 
    1:   {
    1:     NS_ASSERTION(aNode, "null node passed to nsEditor::Tag()");
    1: 
    1:     return nsnull;
    1:   }
    1:   
    1:   return content->Tag();
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetTagString: digs out string for the tag of this node
    1: //                    
    1: nsresult 
    1: nsEditor::GetTagString(nsIDOMNode *aNode, nsAString& outString)
    1: {
    1:   if (!aNode) 
    1:   {
    1:     NS_NOTREACHED("null node passed to nsEditor::GetTag()");
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   
    1:   nsIAtom *atom = GetTag(aNode);
    1:   if (!atom)
    1:   {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   atom->ToString(outString);
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // NodesSameType: do these nodes have the same tag?
    1: //                    
    1: PRBool 
    1: nsEditor::NodesSameType(nsIDOMNode *aNode1, nsIDOMNode *aNode2)
    1: {
    1:   if (!aNode1 || !aNode2) 
    1:   {
    1:     NS_NOTREACHED("null node passed to nsEditor::NodesSameType()");
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   return GetTag(aNode1) == GetTag(aNode2);
    1: }
    1: 
    1: 
    1: // IsTextOrElementNode: true if node of dom type element or text
    1: //               
    1: PRBool
    1: nsEditor::IsTextOrElementNode(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode)
    1:   {
    1:     NS_NOTREACHED("null node passed to IsTextOrElementNode()");
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   PRUint16 nodeType;
    1:   aNode->GetNodeType(&nodeType);
    1:   return ((nodeType == nsIDOMNode::ELEMENT_NODE) || (nodeType == nsIDOMNode::TEXT_NODE));
    1: }
    1: 
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsTextNode: true if node of dom type text
    1: //               
    1: PRBool
    1: nsEditor::IsTextNode(nsIDOMNode *aNode)
    1: {
    1:   if (!aNode)
    1:   {
    1:     NS_NOTREACHED("null node passed to IsTextNode()");
    1:     return PR_FALSE;
    1:   }
    1:   
    1:   PRUint16 nodeType;
    1:   aNode->GetNodeType(&nodeType);
    1:   return (nodeType == nsIDOMNode::TEXT_NODE);
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetIndexOf: returns the position index of the node in the parent
    1: //
    1: PRInt32 
    1: nsEditor::GetIndexOf(nsIDOMNode *parent, nsIDOMNode *child)
    1: {
36743:   nsCOMPtr<nsINode> parentNode = do_QueryInterface(parent);
36743:   NS_PRECONDITION(parentNode, "null parentNode in nsEditor::GetIndexOf");
36743:   NS_PRECONDITION(parentNode->IsNodeOfType(nsINode::eCONTENT) ||
36743:                     parentNode->IsNodeOfType(nsINode::eDOCUMENT),
36743:                   "The parent node must be an element node or a document node");
36743: 
    1:   nsCOMPtr<nsIContent> cChild = do_QueryInterface(child);
    1:   NS_PRECONDITION(cChild, "null content in nsEditor::GetIndexOf");
    1: 
36743:   return parentNode->IndexOf(cChild);
    1: }
    1:   
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetChildAt: returns the node at this position index in the parent
    1: //
    1: nsCOMPtr<nsIDOMNode> 
    1: nsEditor::GetChildAt(nsIDOMNode *aParent, PRInt32 aOffset)
    1: {
    1:   nsCOMPtr<nsIDOMNode> resultNode;
    1:   
    1:   nsCOMPtr<nsIContent> parent = do_QueryInterface(aParent);
    1: 
43807:   NS_ENSURE_TRUE(parent, resultNode);
    1: 
    1:   resultNode = do_QueryInterface(parent->GetChildAt(aOffset));
    1: 
    1:   return resultNode;
    1: }
    1:   
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetStartNodeAndOffset: returns whatever the start parent & offset is of 
    1: //                        the first range in the selection.
    1: nsresult 
    1: nsEditor::GetStartNodeAndOffset(nsISelection *aSelection,
43518:                                        nsIDOMNode **outStartNode,
    1:                                        PRInt32 *outStartOffset)
    1: {
43807:   NS_ENSURE_TRUE(outStartNode && outStartOffset && aSelection, NS_ERROR_NULL_POINTER);
    1: 
43518:   *outStartNode = nsnull;
43518: 
    1:   // brade:  set outStartNode to null or ?
    1: 
    1:   nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(aSelection));
    1:   nsCOMPtr<nsIEnumerator> enumerator;
    1:   nsresult result = selPrivate->GetEnumerator(getter_AddRefs(enumerator));
43893:   NS_ENSURE_SUCCESS(result, result);
43893:   NS_ENSURE_TRUE(enumerator, NS_ERROR_FAILURE);
    1: 
    1:   enumerator->First(); 
    1:   nsCOMPtr<nsISupports> currentItem;
43893:   result = enumerator->CurrentItem(getter_AddRefs(currentItem));
43893:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
43807:   NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
    1: 
43893:   result = range->GetStartContainer(outStartNode);
43893:   NS_ENSURE_SUCCESS(result, result);
43893: 
43893:   result = range->GetStartOffset(outStartOffset);
43893:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // GetEndNodeAndOffset: returns whatever the end parent & offset is of 
    1: //                        the first range in the selection.
    1: nsresult 
    1: nsEditor::GetEndNodeAndOffset(nsISelection *aSelection,
43518:                                        nsIDOMNode **outEndNode,
    1:                                        PRInt32 *outEndOffset)
    1: {
43807:   NS_ENSURE_TRUE(outEndNode && outEndOffset, NS_ERROR_NULL_POINTER);
    1: 
43518:   *outEndNode = nsnull;
43518:     
    1:   nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(aSelection));
    1:   nsCOMPtr<nsIEnumerator> enumerator;
    1:   nsresult result = selPrivate->GetEnumerator(getter_AddRefs(enumerator));
    1:   if (NS_FAILED(result) || !enumerator)
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   enumerator->First(); 
    1:   nsCOMPtr<nsISupports> currentItem;
    1:   if (NS_FAILED(enumerator->CurrentItem(getter_AddRefs(currentItem))))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
43807:   NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
    1:     
43518:   if (NS_FAILED(range->GetEndContainer(outEndNode)))
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   if (NS_FAILED(range->GetEndOffset(outEndOffset)))
    1:     return NS_ERROR_FAILURE;
    1:     
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // IsPreformatted: checks the style info for the node for the preformatted
    1: //                 text style.
    1: nsresult 
    1: nsEditor::IsPreformatted(nsIDOMNode *aNode, PRBool *aResult)
    1: {
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
    1:   
43806:   NS_ENSURE_TRUE(aResult && content, NS_ERROR_NULL_POINTER);
    1:   
    1:   nsCOMPtr<nsIPresShell> ps = do_QueryReferent(mPresShellWeak);
43806:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
    1: 
52224:   // Look at the node (and its parent if it's not an element), and grab its style context
42574:   nsRefPtr<nsStyleContext> elementStyle;
52224:   if (!content->IsElement()) {
52224:     content = content->GetParent();
52224:   }
52224:   if (content && content->IsElement()) {
42574:     elementStyle = nsComputedDOMStyle::GetStyleContextForElement(content->AsElement(),
42574:                                                                  nsnull,
42574:                                                                  ps);
42574:   }
42574: 
42574:   if (!elementStyle)
    1:   {
    1:     // Consider nodes without a style context to be NOT preformatted:
    1:     // For instance, this is true of JS tags inside the body (which show
    1:     // up as #text nodes but have no style context).
    1:     *aResult = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
42574:   const nsStyleText* styleText = elementStyle->GetStyleText();
    1: 
11894:   *aResult = styleText->WhiteSpaceIsSignificant();
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // SplitNodeDeep: this splits a node "deeply", splitting children as 
    1: //                appropriate.  The place to split is represented by
    1: //                a dom point at {splitPointParent, splitPointOffset}.
    1: //                That dom point must be inside aNode, which is the node to 
    1: //                split.  outOffset is set to the offset in the parent of aNode where
    1: //                the split terminates - where you would want to insert 
    1: //                a new element, for instance, if that's why you were splitting 
    1: //                the node.
    1: //
    1: nsresult
    1: nsEditor::SplitNodeDeep(nsIDOMNode *aNode, 
    1:                         nsIDOMNode *aSplitPointParent, 
    1:                         PRInt32 aSplitPointOffset,
    1:                         PRInt32 *outOffset,
    1:                         PRBool  aNoEmptyContainers,
    1:                         nsCOMPtr<nsIDOMNode> *outLeftNode,
    1:                         nsCOMPtr<nsIDOMNode> *outRightNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode && aSplitPointParent && outOffset, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsIDOMNode> tempNode, parentNode;  
    1:   PRInt32 offset = aSplitPointOffset;
    1:   nsresult res;
    1:   
    1:   if (outLeftNode)  *outLeftNode  = nsnull;
    1:   if (outRightNode) *outRightNode = nsnull;
    1:   
    1:   nsCOMPtr<nsIDOMNode> nodeToSplit = do_QueryInterface(aSplitPointParent);
    1:   while (nodeToSplit)
    1:   {
    1:     // need to insert rules code call here to do things like
    1:     // not split a list if you are after the last <li> or before the first, etc.
    1:     // for now we just have some smarts about unneccessarily splitting
    1:     // textnodes, which should be universal enough to put straight in
    1:     // this nsEditor routine.
    1:     
    1:     nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(nodeToSplit);
    1:     PRUint32 len;
    1:     PRBool bDoSplit = PR_FALSE;
    1:     res = GetLengthOfDOMNode(nodeToSplit, len);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     if (!(aNoEmptyContainers || nodeAsText) || (offset && (offset != (PRInt32)len)))
    1:     {
    1:       bDoSplit = PR_TRUE;
    1:       res = SplitNode(nodeToSplit, offset, getter_AddRefs(tempNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (outRightNode) *outRightNode = nodeToSplit;
    1:       if (outLeftNode)  *outLeftNode  = tempNode;
    1:     }
    1: 
    1:     res = nodeToSplit->GetParentNode(getter_AddRefs(parentNode));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(parentNode, NS_ERROR_FAILURE);
    1: 
    1:     if (!bDoSplit && offset)  // must be "end of text node" case, we didn't split it, just move past it
    1:     {
    1:       offset = GetIndexOf(parentNode, nodeToSplit) +1;
    1:       if (outLeftNode)  *outLeftNode  = nodeToSplit;
    1:     }
    1:     else
    1:     {
    1:       offset = GetIndexOf(parentNode, nodeToSplit);
    1:       if (outRightNode) *outRightNode = nodeToSplit;
    1:     }
    1:     
    1:     if (nodeToSplit.get() == aNode)  // we split all the way up to (and including) aNode; we're done
    1:       break;
    1:       
    1:     nodeToSplit = parentNode;
    1:   }
    1:   
    1:   if (!nodeToSplit)
    1:   {
    1:     NS_NOTREACHED("null node obtained in nsEditor::SplitNodeDeep()");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   
    1:   *outOffset = offset;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: ///////////////////////////////////////////////////////////////////////////
    1: // JoinNodeDeep:  this joins two like nodes "deeply", joining children as 
    1: //                appropriate.  
    1: nsresult
    1: nsEditor::JoinNodeDeep(nsIDOMNode *aLeftNode, 
    1:                        nsIDOMNode *aRightNode,
    1:                        nsCOMPtr<nsIDOMNode> *aOutJoinNode, 
    1:                        PRInt32 *outOffset)
    1: {
43806:   NS_ENSURE_TRUE(aLeftNode && aRightNode && aOutJoinNode && outOffset, NS_ERROR_NULL_POINTER);
    1: 
    1:   // while the rightmost children and their descendants of the left node 
    1:   // match the leftmost children and their descendants of the right node
    1:   // join them up.  Can you say that three times fast?
    1:   
    1:   nsCOMPtr<nsIDOMNode> leftNodeToJoin = do_QueryInterface(aLeftNode);
    1:   nsCOMPtr<nsIDOMNode> rightNodeToJoin = do_QueryInterface(aRightNode);
    1:   nsCOMPtr<nsIDOMNode> parentNode,tmp;
    1:   nsresult res = NS_OK;
    1:   
    1:   rightNodeToJoin->GetParentNode(getter_AddRefs(parentNode));
    1:   
    1:   while (leftNodeToJoin && rightNodeToJoin && parentNode &&
    1:           NodesSameType(leftNodeToJoin, rightNodeToJoin))
    1:   {
    1:     // adjust out params
    1:     PRUint32 length;
    1:     if (IsTextNode(leftNodeToJoin))
    1:     {
    1:       nsCOMPtr<nsIDOMCharacterData>nodeAsText;
    1:       nodeAsText = do_QueryInterface(leftNodeToJoin);
    1:       nodeAsText->GetLength(&length);
    1:     }
    1:     else
    1:     {
    1:       res = GetLengthOfDOMNode(leftNodeToJoin, length);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:     }
    1:     
    1:     *aOutJoinNode = rightNodeToJoin;
    1:     *outOffset = length;
    1:     
    1:     // do the join
    1:     res = JoinNodes(leftNodeToJoin, rightNodeToJoin, parentNode);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     
    1:     if (IsTextNode(parentNode)) // we've joined all the way down to text nodes, we're done!
    1:       return NS_OK;
    1: 
    1:     else
    1:     {
    1:       // get new left and right nodes, and begin anew
    1:       parentNode = rightNodeToJoin;
    1:       leftNodeToJoin = GetChildAt(parentNode, length-1);
    1:       rightNodeToJoin = GetChildAt(parentNode, length);
    1: 
    1:       // skip over non-editable nodes
    1:       while (leftNodeToJoin && !IsEditable(leftNodeToJoin))
    1:       {
    1:         leftNodeToJoin->GetPreviousSibling(getter_AddRefs(tmp));
    1:         leftNodeToJoin = tmp;
    1:       }
    1:       if (!leftNodeToJoin) break;
    1:     
    1:       while (rightNodeToJoin && !IsEditable(rightNodeToJoin))
    1:       {
    1:         rightNodeToJoin->GetNextSibling(getter_AddRefs(tmp));
    1:         rightNodeToJoin = tmp;
    1:       }
    1:       if (!rightNodeToJoin) break;
    1:     }
    1:   }
    1:   
    1:   return res;
    1: }
    1: 
    1: nsresult nsEditor::BeginUpdateViewBatch()
    1: {
    1:   NS_PRECONDITION(mUpdateCount >= 0, "bad state");
    1: 
    1: 
    1:   if (0 == mUpdateCount)
    1:   {
    1:     // Turn off selection updates and notifications.
    1: 
    1:     nsCOMPtr<nsISelection> selection;
    1:     GetSelection(getter_AddRefs(selection));
    1: 
    1:     if (selection) 
    1:     {
    1:       nsCOMPtr<nsISelectionPrivate> selPrivate(do_QueryInterface(selection));
    1:       selPrivate->StartBatchChanges();
    1:     }
    1: 
    1:     // Turn off view updating.
43133:     nsCOMPtr<nsIPresShell> ps;
43133:     GetPresShell(getter_AddRefs(ps));
43133:     if (ps) {
43133:       nsCOMPtr<nsIViewManager> viewManager = ps->GetViewManager();
43133:       if (viewManager) {
43133:         mBatch.BeginUpdateViewBatch(viewManager);
43133:       }
43133:     }
    1:   }
    1: 
    1:   mUpdateCount++;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult nsEditor::EndUpdateViewBatch()
    1: {
    1:   NS_PRECONDITION(mUpdateCount > 0, "bad state");
    1:   
    1:   if (mUpdateCount <= 0)
    1:   {
    1:     mUpdateCount = 0;
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   mUpdateCount--;
    1: 
    1:   if (0 == mUpdateCount)
    1:   {
    1:     // Hide the caret with an StCaretHider. By the time it goes out
    1:     // of scope and tries to show the caret, reflow and selection changed
    1:     // notifications should've happened so the caret should have enough info
    1:     // to draw at the correct position.
    1: 
15969:     nsRefPtr<nsCaret> caret;
    1:     nsCOMPtr<nsIPresShell> presShell;
    1:     GetPresShell(getter_AddRefs(presShell));
    1: 
    1:     if (presShell)
40045:       caret = presShell->GetCaret();
    1: 
    1:     StCaretHider caretHider(caret);
    1: 
    1:     PRUint32 flags = 0;
    1: 
    1:     GetFlags(&flags);
    1: 
    1:     // Turn view updating back on.
    1:     PRUint32 updateFlag = NS_VMREFRESH_IMMEDIATE;
    1: 
    1:     // If we're doing async updates, use NS_VMREFRESH_DEFERRED here, so that
    1:     // the reflows we caused will get processed before the invalidates.
 5435:     if (flags & nsIPlaintextEditor::eEditorUseAsyncUpdatesMask) {
    1:       updateFlag = NS_VMREFRESH_DEFERRED;
 5435:     }
10730:     mBatch.EndUpdateViewBatch(updateFlag);
    1: 
    1:     // Turn selection updating and notifications back on.
    1: 
    1:     nsCOMPtr<nsISelection>selection;
    1:     GetSelection(getter_AddRefs(selection));
    1: 
    1:     if (selection) {
    1:       nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
    1:       selPrivate->EndBatchChanges();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool 
    1: nsEditor::GetShouldTxnSetSelection()
    1: {
    1:   return mShouldTxnSetSelection;
    1: }
    1: 
    1: 
    1: #ifdef XP_MAC
    1: #pragma mark -
    1: #pragma mark  protected nsEditor methods 
    1: #pragma mark -
    1: #endif
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::DeleteSelectionImpl(nsIEditor::EDirection aAction)
    1: {
    1:   nsCOMPtr<nsISelection>selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
 3030:   nsRefPtr<EditAggregateTxn> txn;
    1:   nsCOMPtr<nsIDOMNode> deleteNode;
    1:   PRInt32 deleteCharOffset = 0, deleteCharLength = 0;
 3030:   res = CreateTxnForDeleteSelection(aAction, getter_AddRefs(txn),
 3030:                                     getter_AddRefs(deleteNode),
 3030:                                     &deleteCharOffset, &deleteCharLength);
    1:   nsCOMPtr<nsIDOMCharacterData> deleteCharData(do_QueryInterface(deleteNode));
    1: 
    1:   if (NS_SUCCEEDED(res))  
    1:   {
    1:     nsAutoRules beginRulesSniffing(this, kOpDeleteSelection, aAction);
    1:     PRInt32 i;
    1:     // Notify nsIEditActionListener::WillDelete[Selection|Text|Node]
    1:     if (!deleteNode)
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->WillDeleteSelection(selection);
    1:     else if (deleteCharData)
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->WillDeleteText(deleteCharData, deleteCharOffset, 1);
    1:     else
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->WillDeleteNode(deleteNode);
    1: 
    1:     // Delete the specified amount
    1:     res = DoTransaction(txn);  
    1: 
    1:     // Notify nsIEditActionListener::DidDelete[Selection|Text|Node]
    1:     if (!deleteNode)
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->DidDeleteSelection(selection);
    1:     else if (deleteCharData)
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->DidDeleteText(deleteCharData, deleteCharOffset, 1, res);
    1:     else
    1:       for (i = 0; i < mActionListeners.Count(); i++)
    1:         mActionListeners[i]->DidDeleteNode(deleteNode, res);
    1:   }
    1: 
    1:   return res;
    1: }
    1: 
    1: // XXX: error handling in this routine needs to be cleaned up!
    1: NS_IMETHODIMP
    1: nsEditor::DeleteSelectionAndCreateNode(const nsAString& aTag,
    1:                                            nsIDOMNode ** aNewNode)
    1: {
    1:   nsCOMPtr<nsIDOMNode> parentSelectedNode;
    1:   PRInt32 offsetOfNewNode;
    1:   nsresult result = DeleteSelectionAndPrepareToCreateNode(parentSelectedNode,
    1:                                                           offsetOfNewNode);
43808:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   nsCOMPtr<nsIDOMNode> newNode;
    1:   result = CreateNode(aTag, parentSelectedNode, offsetOfNewNode,
    1:                       getter_AddRefs(newNode));
    1:   // XXX: ERROR_HANDLING  check result, and make sure aNewNode is set correctly in success/failure cases
    1:   *aNewNode = newNode;
    1:   NS_IF_ADDREF(*aNewNode);
    1: 
    1:   // we want the selection to be just after the new node
    1:   nsCOMPtr<nsISelection> selection;
    1:   result = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(result, result);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1:   return selection->Collapse(parentSelectedNode, offsetOfNewNode+1);
    1: }
    1: 
    1: 
    1: /* Non-interface, protected methods */
    1: 
    1: nsresult
    1: nsEditor::GetIMEBufferLength(PRInt32* length)
    1: {
    1:   *length = mIMEBufferLength;
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsEditor::SetIsIMEComposing(){  
    1:   // We set mIsIMEComposing according to mIMETextRangeList.
    1:   nsCOMPtr<nsIPrivateTextRange> rangePtr;
    1:   PRUint16 listlen, type;
    1: 
    1:   mIsIMEComposing = PR_FALSE;
20235:   listlen = mIMETextRangeList->GetLength();
    1: 
    1:   for (PRUint16 i = 0; i < listlen; i++)
    1:   {
20235:       rangePtr = mIMETextRangeList->Item(i);
20235:       if (!rangePtr) continue;
20235:       nsresult result = rangePtr->GetRangeType(&type);
    1:       if (NS_FAILED(result)) continue;
    1:       if ( type == nsIPrivateTextRange::TEXTRANGE_RAWINPUT ||
    1:            type == nsIPrivateTextRange::TEXTRANGE_CONVERTEDTEXT ||
    1:            type == nsIPrivateTextRange::TEXTRANGE_SELECTEDRAWTEXT ||
    1:            type == nsIPrivateTextRange::TEXTRANGE_SELECTEDCONVERTEDTEXT )
    1:       {
    1:         mIsIMEComposing = PR_TRUE;
    1: #ifdef DEBUG_IME
    1:         printf("nsEditor::mIsIMEComposing = PR_TRUE\n");
    1: #endif
    1:         break;
    1:       }
    1:   }
    1:   return;
    1: }
    1: 
    1: PRBool
    1: nsEditor::IsIMEComposing() {
    1:   return mIsIMEComposing;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::DeleteSelectionAndPrepareToCreateNode(nsCOMPtr<nsIDOMNode> &parentSelectedNode, PRInt32& offsetOfNewNode)
    1: {
    1:   nsresult result=NS_ERROR_NOT_INITIALIZED;
    1:   nsCOMPtr<nsISelection> selection;
    1:   result = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(result, result);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1: 
    1:   PRBool collapsed;
    1:   result = selection->GetIsCollapsed(&collapsed);
    1:   if (NS_SUCCEEDED(result) && !collapsed) 
    1:   {
    1:     result = DeleteSelection(nsIEditor::eNone);
    1:     if (NS_FAILED(result)) {
    1:       return result;
    1:     }
    1:     // get the new selection
    1:     result = GetSelection(getter_AddRefs(selection));
    1:     if (NS_FAILED(result)) {
    1:       return result;
    1:     }
47373: 
47373:     nsCOMPtr<nsIDOMNode> selectedNode;
47373:     selection->GetAnchorNode(getter_AddRefs(selectedNode));
    1:     // no selection is ok.
    1:     // if there is a selection, it must be collapsed
47373:     if (selectedNode)
47373:     {
47373:       PRBool testCollapsed = PR_FALSE;
47373:       selection->GetIsCollapsed(&testCollapsed);
47373:       if (!testCollapsed) {
47373:         result = selection->CollapseToEnd();
47373:         NS_ENSURE_SUCCESS(result, result);
47373:       }
47373:     }
    1:   }
    1:   // split the selected node
    1:   PRInt32 offsetOfSelectedNode;
    1:   result = selection->GetAnchorNode(getter_AddRefs(parentSelectedNode));
    1:   if (NS_SUCCEEDED(result) && NS_SUCCEEDED(selection->GetAnchorOffset(&offsetOfSelectedNode)) && parentSelectedNode)
    1:   {
    1:     nsCOMPtr<nsIDOMNode> selectedNode;
    1:     PRUint32 selectedNodeContentCount=0;
    1:     nsCOMPtr<nsIDOMCharacterData>selectedParentNodeAsText;
    1:     selectedParentNodeAsText = do_QueryInterface(parentSelectedNode);
    1: 
    1:     offsetOfNewNode = offsetOfSelectedNode;
    1:     
    1:     /* if the selection is a text node, split the text node if necessary
    1:        and compute where to put the new node
    1:     */
    1:     if (selectedParentNodeAsText) 
    1:     { 
    1:       PRInt32 indexOfTextNodeInParent;
    1:       selectedNode = do_QueryInterface(parentSelectedNode);
    1:       selectedNode->GetParentNode(getter_AddRefs(parentSelectedNode));
    1:       selectedParentNodeAsText->GetLength(&selectedNodeContentCount);
    1:       GetChildOffset(selectedNode, parentSelectedNode, indexOfTextNodeInParent);
    1: 
    1:       if ((offsetOfSelectedNode!=0) && (((PRUint32)offsetOfSelectedNode)!=selectedNodeContentCount))
    1:       {
    1:         nsCOMPtr<nsIDOMNode> newSiblingNode;
    1:         result = SplitNode(selectedNode, offsetOfSelectedNode, getter_AddRefs(newSiblingNode));
    1:         // now get the node's offset in it's parent, and insert the new tag there
    1:         if (NS_SUCCEEDED(result)) {
    1:           result = GetChildOffset(selectedNode, parentSelectedNode, offsetOfNewNode);
    1:         }
    1:       }
    1:       else 
    1:       { // determine where to insert the new node
    1:         if (0==offsetOfSelectedNode) {
    1:           offsetOfNewNode = indexOfTextNodeInParent; // insert new node as previous sibling to selection parent
    1:         }
    1:         else {                 // insert new node as last child
    1:           GetChildOffset(selectedNode, parentSelectedNode, offsetOfNewNode);
    1:           offsetOfNewNode++;    // offsets are 0-based, and we need the index of the new node
    1:         }
    1:       }
    1:     }
    1:     // Here's where the new node was inserted
    1:   }
    1: #ifdef DEBUG
    1:   else {
    1:     printf("InsertLineBreak into an empty document is not yet supported\n");
    1:   }
    1: #endif
    1:   return result;
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::DoAfterDoTransaction(nsITransaction *aTxn)
    1: {
    1:   nsresult rv = NS_OK;
    1:   
    1:   PRBool  isTransientTransaction;
    1:   rv = aTxn->GetIsTransient(&isTransientTransaction);
43808:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   if (!isTransientTransaction)
    1:   {
    1:     // we need to deal here with the case where the user saved after some
    1:     // edits, then undid one or more times. Then, the undo count is -ve,
    1:     // but we can't let a do take it back to zero. So we flip it up to
    1:     // a +ve number.
    1:     PRInt32 modCount;
    1:     GetModificationCount(&modCount);
    1:     if (modCount < 0)
    1:       modCount = -modCount;
    1:         
    1:     rv = IncrementModificationCount(1);    // don't count transient transactions
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::DoAfterUndoTransaction()
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   rv = IncrementModificationCount(-1);    // all undoable transactions are non-transient
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::DoAfterRedoTransaction()
    1: {
    1:   return IncrementModificationCount(1);    // all redoable transactions are non-transient
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::CreateTxnForSetAttribute(nsIDOMElement *aElement, 
    1:                                    const nsAString& aAttribute, 
    1:                                    const nsAString& aValue,
    1:                                    ChangeAttributeTxn ** aTxn)
    1: {
43807:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
27825: 
27825:   *aTxn = new ChangeAttributeTxn();
43807:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
27825:   return (*aTxn)->Init(this, aElement, aAttribute, aValue, PR_FALSE);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::CreateTxnForRemoveAttribute(nsIDOMElement *aElement, 
    1:                                       const nsAString& aAttribute,
    1:                                       ChangeAttributeTxn ** aTxn)
    1: {
43807:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
27825: 
27825:   *aTxn = new ChangeAttributeTxn();
43807:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
27825: 
27825:   return (*aTxn)->Init(this, aElement, aAttribute, EmptyString(), PR_TRUE);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForCreateElement(const nsAString& aTag,
    1:                                                   nsIDOMNode     *aParent,
    1:                                                   PRInt32         aPosition,
    1:                                                   CreateElementTxn ** aTxn)
    1: {
43807:   NS_ENSURE_TRUE(aParent, NS_ERROR_NULL_POINTER);
27825: 
27825:   *aTxn = new CreateElementTxn();
43807:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
27825: 
27825:   return (*aTxn)->Init(this, aTag, aParent, aPosition);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForInsertElement(nsIDOMNode * aNode,
    1:                                                   nsIDOMNode * aParent,
    1:                                                   PRInt32      aPosition,
    1:                                                   InsertElementTxn ** aTxn)
    1: {
43807:   NS_ENSURE_TRUE(aNode && aParent, NS_ERROR_NULL_POINTER);
27825: 
27825:   *aTxn = new InsertElementTxn();
43807:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
27825: 
27825:   return (*aTxn)->Init(aNode, aParent, aPosition, this);
    1: }
    1: 
    1: NS_IMETHODIMP nsEditor::CreateTxnForDeleteElement(nsIDOMNode * aElement,
    1:                                              DeleteElementTxn ** aTxn)
    1: {
43807:   NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
27825: 
27825:   *aTxn = new DeleteElementTxn();
43807:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
27825: 
27825:   return (*aTxn)->Init(this, aElement, &mRangeUpdater);
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsEditor::CreateTxnForIMEText(const nsAString& aStringToInsert,
    1:                               IMETextTxn ** aTxn)
    1: {
    1:   NS_ASSERTION(aTxn, "illegal value- null ptr- aTxn");
27825:      
27825:   *aTxn = new IMETextTxn();
43807:   NS_ENSURE_TRUE(*aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
27825: 
27825:   return (*aTxn)->Init(mIMETextNode, mIMETextOffset, mIMEBufferLength,
27825:                        mIMETextRangeList, aStringToInsert, mSelConWeak);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP 
42163: nsEditor::CreateTxnForAddStyleSheet(nsCSSStyleSheet* aSheet, AddStyleSheetTxn* *aTxn)
    1: {
27825:   *aTxn = new AddStyleSheetTxn();
43807:   NS_ENSURE_TRUE( *aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
    1: 
    1:   return (*aTxn)->Init(this, aSheet);
    1: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP 
42163: nsEditor::CreateTxnForRemoveStyleSheet(nsCSSStyleSheet* aSheet, RemoveStyleSheetTxn* *aTxn)
    1: {
27825:   *aTxn = new RemoveStyleSheetTxn();
43807:   NS_ENSURE_TRUE( *aTxn, NS_ERROR_OUT_OF_MEMORY);
27825:   NS_ADDREF(*aTxn);
    1: 
    1:   return (*aTxn)->Init(this, aSheet);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::CreateTxnForDeleteSelection(nsIEditor::EDirection aAction,
    1:                                       EditAggregateTxn ** aTxn,
    1:                                       nsIDOMNode ** aNode,
    1:                                       PRInt32 *aOffset,
    1:                                       PRInt32 *aLength)
    1: {
43807:   NS_ENSURE_TRUE(aTxn, NS_ERROR_NULL_POINTER);
    1:   *aTxn = nsnull;
    1: 
    1:   nsCOMPtr<nsISelectionController> selCon = do_QueryReferent(mSelConWeak);
43806:   NS_ENSURE_TRUE(selCon, NS_ERROR_NOT_INITIALIZED);
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult result = selCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
    1:                                          getter_AddRefs(selection));
    1:   if ((NS_SUCCEEDED(result)) && selection)
    1:   {
    1:     // Check whether the selection is collapsed and we should do nothing:
    1:     PRBool isCollapsed;
    1:     result = (selection->GetIsCollapsed(&isCollapsed));
    1:     if (NS_SUCCEEDED(result) && isCollapsed && aAction == eNone)
    1:       return NS_OK;
    1: 
    1:     // allocate the out-param transaction
27825:     *aTxn = new EditAggregateTxn();
27825:     if (!*aTxn) {
27825:       return NS_ERROR_OUT_OF_MEMORY;
27825:     }
27825:     NS_ADDREF(*aTxn);
    1: 
    1:     nsCOMPtr<nsISelectionPrivate>selPrivate(do_QueryInterface(selection));
    1:     nsCOMPtr<nsIEnumerator> enumerator;
    1:     result = selPrivate->GetEnumerator(getter_AddRefs(enumerator));
    1:     if (NS_SUCCEEDED(result) && enumerator)
    1:     {
    1:       for (enumerator->First(); NS_OK!=enumerator->IsDone(); enumerator->Next())
    1:       {
    1:         nsCOMPtr<nsISupports> currentItem;
    1:         result = enumerator->CurrentItem(getter_AddRefs(currentItem));
    1:         if ((NS_SUCCEEDED(result)) && (currentItem))
    1:         {
    1:           nsCOMPtr<nsIDOMRange> range( do_QueryInterface(currentItem) );
    1:           range->GetCollapsed(&isCollapsed);
    1:           if (!isCollapsed)
    1:           {
27825:             nsRefPtr<DeleteRangeTxn> txn = new DeleteRangeTxn();
27825:             if (txn)
    1:             {
    1:               txn->Init(this, range, &mRangeUpdater);
    1:               (*aTxn)->AppendChild(txn);
    1:             }
    1:             else
    1:               result = NS_ERROR_OUT_OF_MEMORY;
    1:           }
 5270:           // Same with range as with selection; if it is collapsed and action
 5270:           // is eNone, do nothing.
 5270:           else if (aAction != eNone)
    1:           { // we have an insertion point.  delete the thing in front of it or behind it, depending on aAction
    1:             result = CreateTxnForDeleteInsertionPoint(range, aAction, *aTxn, aNode, aOffset, aLength);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // if we didn't build the transaction correctly, destroy the out-param transaction so we don't leak it.
    1:   if (NS_FAILED(result))
    1:   {
    1:     NS_IF_RELEASE(*aTxn);
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsEditor::CreateTxnForDeleteCharacter(nsIDOMCharacterData  *aData,
    1:                                       PRUint32              aOffset,
    1:                                       nsIEditor::EDirection aDirection,
    1:                                       DeleteTextTxn       **aTxn)
    1: {
    1:   NS_ASSERTION(aDirection == eNext || aDirection == ePrevious,
    1:                "invalid direction");
    1:   nsAutoString data;
    1:   aData->GetData(data);
    1:   PRUint32 segOffset, segLength = 1;
    1:   if (aDirection == eNext) {
    1:     segOffset = aOffset;
43804:     if (segOffset + 1 < data.Length() &&
43804:         NS_IS_HIGH_SURROGATE(data[segOffset]) &&
    1:         NS_IS_LOW_SURROGATE(data[segOffset+1])) {
    1:       // delete both halves of the surrogate pair
    1:       ++segLength;
    1:     }
    1:   } else {
    1:     segOffset = aOffset - 1;
43804:     if (segOffset > 1 &&
43804:         NS_IS_LOW_SURROGATE(data[segOffset]) &&
    1:         NS_IS_HIGH_SURROGATE(data[segOffset-1])) {
    1:       ++segLength;
    1:       --segOffset;
    1:     }
    1:   }
    1:   return CreateTxnForDeleteText(aData, segOffset, segLength, aTxn);
    1: }
    1: 
    1: //XXX: currently, this doesn't handle edge conditions because GetNext/GetPrior are not implemented
    1: NS_IMETHODIMP
    1: nsEditor::CreateTxnForDeleteInsertionPoint(nsIDOMRange          *aRange, 
    1:                                            nsIEditor::EDirection aAction,
    1:                                            EditAggregateTxn     *aTxn,
    1:                                            nsIDOMNode          **aNode,
    1:                                            PRInt32              *aOffset,
    1:                                            PRInt32              *aLength)
    1: {
    1:   NS_ASSERTION(aAction == eNext || aAction == ePrevious, "invalid action");
    1: 
    1:   // get the node and offset of the insertion point
    1:   nsCOMPtr<nsIDOMNode> node;
    1:   nsresult result = aRange->GetStartContainer(getter_AddRefs(node));
43808:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   PRInt32 offset;
    1:   result = aRange->GetStartOffset(&offset);
43808:   NS_ENSURE_SUCCESS(result, result);
    1: 
    1:   // determine if the insertion point is at the beginning, middle, or end of the node
    1:   nsCOMPtr<nsIDOMCharacterData> nodeAsText = do_QueryInterface(node);
    1: 
    1:   PRUint32 count=0;
    1: 
    1:   if (nodeAsText)
    1:     nodeAsText->GetLength(&count);
    1:   else
    1:   { 
    1:     // get the child list and count
    1:     nsCOMPtr<nsIDOMNodeList>childList;
    1:     result = node->GetChildNodes(getter_AddRefs(childList));
    1:     if ((NS_SUCCEEDED(result)) && childList)
    1:       childList->GetLength(&count);
    1:   }
    1: 
    1:   PRBool isFirst = (0 == offset);
    1:   PRBool isLast  = (count == (PRUint32)offset);
    1: 
    1:   // XXX: if isFirst && isLast, then we'll need to delete the node 
    1:   //      as well as the 1 child
    1: 
    1:   // build a transaction for deleting the appropriate data
    1:   // XXX: this has to come from rule section
    1:   if ((ePrevious==aAction) && (PR_TRUE==isFirst))
    1:   { // we're backspacing from the beginning of the node.  Delete the first thing to our left
    1:     nsCOMPtr<nsIDOMNode> priorNode;
    1:     result = GetPriorNode(node, PR_TRUE, address_of(priorNode));
    1:     if ((NS_SUCCEEDED(result)) && priorNode)
    1:     { // there is a priorNode, so delete it's last child (if text content, delete the last char.)
    1:       // if it has no children, delete it
    1:       nsCOMPtr<nsIDOMCharacterData> priorNodeAsText = do_QueryInterface(priorNode);
    1:       if (priorNodeAsText)
    1:       {
    1:         PRUint32 length=0;
    1:         priorNodeAsText->GetLength(&length);
    1:         if (0<length)
    1:         {
    1:           DeleteTextTxn *txn;
    1:           result = CreateTxnForDeleteCharacter(priorNodeAsText, length,
    1:                                                ePrevious, &txn);
    1:           if (NS_SUCCEEDED(result)) {
    1:             aTxn->AppendChild(txn);
    1:             NS_ADDREF(*aNode = priorNode);
    1:             *aOffset = txn->GetOffset();
    1:             *aLength = txn->GetNumCharsToDelete();
    1:             NS_RELEASE(txn);
    1:           }
    1:         }
    1:         else
    1:         { // XXX: can you have an empty text node?  If so, what do you do?
    1:           printf("ERROR: found a text node with 0 characters\n");
    1:           result = NS_ERROR_UNEXPECTED;
    1:         }
    1:       }
    1:       else
    1:       { // priorNode is not text, so tell it's parent to delete it
    1:         DeleteElementTxn *txn;
    1:         result = CreateTxnForDeleteElement(priorNode, &txn);
    1:         if (NS_SUCCEEDED(result)) {
    1:           aTxn->AppendChild(txn);
    1:           NS_RELEASE(txn);
    1:           NS_ADDREF(*aNode = priorNode);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else if ((nsIEditor::eNext==aAction) && (PR_TRUE==isLast))
    1:   { // we're deleting from the end of the node.  Delete the first thing to our right
    1:     nsCOMPtr<nsIDOMNode> nextNode;
    1:     result = GetNextNode(node, PR_TRUE, address_of(nextNode));
    1:     if ((NS_SUCCEEDED(result)) && nextNode)
    1:     { // there is a nextNode, so delete it's first child (if text content, delete the first char.)
    1:       // if it has no children, delete it
    1:       nsCOMPtr<nsIDOMCharacterData> nextNodeAsText = do_QueryInterface(nextNode);
    1:       if (nextNodeAsText)
    1:       {
    1:         PRUint32 length=0;
    1:         nextNodeAsText->GetLength(&length);
    1:         if (0<length)
    1:         {
    1:           DeleteTextTxn *txn;
    1:           result = CreateTxnForDeleteCharacter(nextNodeAsText, 0, eNext, &txn);
    1:           if (NS_SUCCEEDED(result)) {
    1:             aTxn->AppendChild(txn);
    1:             NS_ADDREF(*aNode = nextNode);
    1:             *aOffset = txn->GetOffset();
    1:             *aLength = txn->GetNumCharsToDelete();
    1:             NS_RELEASE(txn);
    1:           }
    1:         }
    1:         else
    1:         { // XXX: can you have an empty text node?  If so, what do you do?
    1:           printf("ERROR: found a text node with 0 characters\n");
    1:           result = NS_ERROR_UNEXPECTED;
    1:         }
    1:       }
    1:       else
    1:       { // nextNode is not text, so tell it's parent to delete it
    1:         DeleteElementTxn *txn;
    1:         result = CreateTxnForDeleteElement(nextNode, &txn);
    1:         if (NS_SUCCEEDED(result)) {
    1:           aTxn->AppendChild(txn);
    1:           NS_RELEASE(txn);
    1:           NS_ADDREF(*aNode = nextNode);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   else
    1:   {
    1:     if (nodeAsText)
    1:     { // we have text, so delete a char at the proper offset
 5270:       nsRefPtr<DeleteTextTxn> txn;
 5270:       result = CreateTxnForDeleteCharacter(nodeAsText, offset, aAction,
 5270:                                            getter_AddRefs(txn));
    1:       if (NS_SUCCEEDED(result)) {
    1:         aTxn->AppendChild(txn);
    1:         NS_ADDREF(*aNode = node);
    1:         *aOffset = txn->GetOffset();
    1:         *aLength = txn->GetNumCharsToDelete();
    1:       }
    1:     }
    1:     else
    1:     { // we're either deleting a node or some text, need to dig into the next/prev node to find out
    1:       nsCOMPtr<nsIDOMNode> selectedNode;
    1:       if (ePrevious==aAction)
    1:       {
    1:         result = GetPriorNode(node, offset, PR_TRUE, address_of(selectedNode));
    1:       }
    1:       else if (eNext==aAction)
    1:       {
    1:         result = GetNextNode(node, offset, PR_TRUE, address_of(selectedNode));
    1:       }
    1:       if (NS_FAILED(result)) { return result; }
    1:       if (selectedNode) 
    1:       {
    1:         nsCOMPtr<nsIDOMCharacterData> selectedNodeAsText =
    1:                                              do_QueryInterface(selectedNode);
    1:         if (selectedNodeAsText)
    1:         { // we are deleting from a text node, so do a text deletion
    1:           PRUint32 position = 0;    // default for forward delete
    1:           if (ePrevious==aAction)
    1:           {
    1:             selectedNodeAsText->GetLength(&position);
    1:           }
 5270:           nsRefPtr<DeleteTextTxn> delTextTxn;
    1:           result = CreateTxnForDeleteCharacter(selectedNodeAsText, position,
 5270:                                                aAction,
 5270:                                                getter_AddRefs(delTextTxn));
    1:           if (NS_FAILED(result))  { return result; }
    1:           if (!delTextTxn) { return NS_ERROR_NULL_POINTER; }
    1:           aTxn->AppendChild(delTextTxn);
    1:           NS_ADDREF(*aNode = selectedNode);
    1:           *aOffset = delTextTxn->GetOffset();
    1:           *aLength = delTextTxn->GetNumCharsToDelete();
    1:         }
    1:         else
    1:         {
 5270:           nsRefPtr<DeleteElementTxn> delElementTxn;
 5270:           result = CreateTxnForDeleteElement(selectedNode,
 5270:                                              getter_AddRefs(delElementTxn));
    1:           if (NS_FAILED(result))  { return result; }
    1:           if (!delElementTxn) { return NS_ERROR_NULL_POINTER; }
    1:           aTxn->AppendChild(delElementTxn);
    1:           NS_ADDREF(*aNode = selectedNode);
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::CreateRange(nsIDOMNode *aStartParent, PRInt32 aStartOffset,
    1:                       nsIDOMNode *aEndParent, PRInt32 aEndOffset,
    1:                       nsIDOMRange **aRange)
    1: {
    1:   nsresult result;
    1:   result = CallCreateInstance("@mozilla.org/content/range;1", aRange);
43808:   NS_ENSURE_SUCCESS(result, result);
    1: 
43807:   NS_ENSURE_TRUE(*aRange, NS_ERROR_NULL_POINTER);
    1: 
    1:   result = (*aRange)->SetStart(aStartParent, aStartOffset);
    1: 
    1:   if (NS_SUCCEEDED(result))
    1:     result = (*aRange)->SetEnd(aEndParent, aEndOffset);
    1: 
    1:   if (NS_FAILED(result))
    1:   {
    1:     NS_RELEASE((*aRange));
    1:     *aRange = 0;
    1:   }
    1:   return result;
    1: }
    1: 
    1: nsresult 
    1: nsEditor::AppendNodeToSelectionAsRange(nsIDOMNode *aNode)
    1: {
43806:   NS_ENSURE_TRUE(aNode, NS_ERROR_NULL_POINTER);
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if(!selection) return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIDOMNode> parentNode;
    1:   res = aNode->GetParentNode(getter_AddRefs(parentNode));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(parentNode, NS_ERROR_NULL_POINTER);
    1:   
    1:   PRInt32 offset;
    1:   res = GetChildOffset(aNode, parentNode, offset);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   
    1:   nsCOMPtr<nsIDOMRange> range;
    1:   res = CreateRange(parentNode, offset, parentNode, offset+1, getter_AddRefs(range));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(range, NS_ERROR_NULL_POINTER);
    1: 
    1:   return selection->AddRange(range);
    1: }
    1: 
    1: nsresult nsEditor::ClearSelection()
    1: {
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult res = nsEditor::GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_FAILURE);
    1:   return selection->RemoveAllRanges();  
    1: }
    1: 
    1: nsresult
    1: nsEditor::CreateHTMLContent(const nsAString& aTag, nsIContent** aContent)
    1: {
    1:   nsCOMPtr<nsIDOMDocument> tempDoc;
    1:   GetDocument(getter_AddRefs(tempDoc));
    1: 
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(tempDoc);
43807:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
    1: 
    1:   // XXX Wallpaper over editor bug (editor tries to create elements with an
    1:   //     empty nodename).
    1:   if (aTag.IsEmpty()) {
    1:     NS_ERROR("Don't pass an empty tag to nsEditor::CreateHTMLContent, "
    1:              "check caller.");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
48124:   return doc->CreateElem(aTag, nsnull, kNameSpaceID_XHTML, PR_FALSE, aContent);
    1: }
    1: 
    1: nsresult
    1: nsEditor::SetAttributeOrEquivalent(nsIDOMElement * aElement,
    1:                                    const nsAString & aAttribute,
    1:                                    const nsAString & aValue,
    1:                                    PRBool aSuppressTransaction)
    1: {
    1:   return SetAttribute(aElement, aAttribute, aValue);
    1: }
    1: 
    1: nsresult
    1: nsEditor::RemoveAttributeOrEquivalent(nsIDOMElement * aElement,
    1:                                       const nsAString & aAttribute,
    1:                                       PRBool aSuppressTransaction)
    1: {
    1:   return RemoveAttribute(aElement, aAttribute);
    1: }
    1: 
    1: nsresult
43438: nsEditor::HandleKeyPressEvent(nsIDOMKeyEvent* aKeyEvent)
43438: {
43438:   // NOTE: When you change this method, you should also change:
43438:   //   * editor/libeditor/text/tests/test_texteditor_keyevent_handling.html
43438:   //   * editor/libeditor/html/tests/test_htmleditor_keyevent_handling.html
43438:   //
43438:   // And also when you add new key handling, you need to change the subclass's
43438:   // HandleKeyPressEvent()'s switch statement.
43438: 
43438:   nsKeyEvent* nativeKeyEvent = GetNativeKeyEvent(aKeyEvent);
43438:   NS_ENSURE_TRUE(nativeKeyEvent, NS_ERROR_UNEXPECTED);
43438:   NS_ASSERTION(nativeKeyEvent->message == NS_KEY_PRESS,
43438:                "HandleKeyPressEvent gets non-keypress event");
43438: 
43438:   // if we are readonly or disabled, then do nothing.
43438:   if (IsReadonly() || IsDisabled()) {
43438:     // consume backspace for disabled and readonly textfields, to prevent
43438:     // back in history, which could be confusing to users
43438:     if (nativeKeyEvent->keyCode == nsIDOMKeyEvent::DOM_VK_BACK_SPACE) {
43438:       aKeyEvent->PreventDefault();
43438:     }
43438:     return NS_OK;
43438:   }
43438: 
43438:   switch (nativeKeyEvent->keyCode) {
43438:     case nsIDOMKeyEvent::DOM_VK_META:
43438:     case nsIDOMKeyEvent::DOM_VK_SHIFT:
43438:     case nsIDOMKeyEvent::DOM_VK_CONTROL:
43438:     case nsIDOMKeyEvent::DOM_VK_ALT:
43438:       aKeyEvent->PreventDefault(); // consumed
43438:       return NS_OK;
43438:     case nsIDOMKeyEvent::DOM_VK_BACK_SPACE:
43438:       if (nativeKeyEvent->isControl || nativeKeyEvent->isAlt ||
43438:           nativeKeyEvent->isMeta) {
43438:         return NS_OK;
43438:       }
43438:       DeleteSelection(nsIEditor::ePrevious);
43438:       aKeyEvent->PreventDefault(); // consumed
43438:       return NS_OK;
43438:     case nsIDOMKeyEvent::DOM_VK_DELETE:
43438:       // on certain platforms (such as windows) the shift key
43438:       // modifies what delete does (cmd_cut in this case).
43438:       // bailing here to allow the keybindings to do the cut.
43438:       if (nativeKeyEvent->isShift || nativeKeyEvent->isControl ||
43438:           nativeKeyEvent->isAlt || nativeKeyEvent->isMeta) {
43438:         return NS_OK;
43438:       }
43438:       DeleteSelection(nsIEditor::eNext);
43438:       aKeyEvent->PreventDefault(); // consumed
43438:       return NS_OK; 
43438:   }
43438:   return NS_OK;
43438: }
43438: 
43438: nsresult
    1: nsEditor::HandleInlineSpellCheck(PRInt32 action,
    1:                                    nsISelection *aSelection,
    1:                                    nsIDOMNode *previousSelectedNode,
    1:                                    PRInt32 previousSelectedOffset,
    1:                                    nsIDOMNode *aStartNode,
    1:                                    PRInt32 aStartOffset,
    1:                                    nsIDOMNode *aEndNode,
    1:                                    PRInt32 aEndOffset)
    1: {
    1:   return mInlineSpellChecker ? mInlineSpellChecker->SpellCheckAfterEditorChange(action,
    1:                                                        aSelection,
    1:                                                        previousSelectedNode,
    1:                                                        previousSelectedOffset,
    1:                                                        aStartNode,
    1:                                                        aStartOffset,
    1:                                                        aEndNode,
    1:                                                        aEndOffset) : NS_OK;
    1: }
    1: 
43715: already_AddRefed<nsIContent>
43715: nsEditor::FindSelectionRoot(nsINode *aNode)
43715: {
43715:   nsCOMPtr<nsIContent> rootContent = do_QueryInterface(GetRoot());
43715:   return rootContent.forget();
43715: }
43715: 
43715: nsresult
43715: nsEditor::InitializeSelection(nsIDOMEventTarget* aFocusEventTarget)
43715: {
43715:   nsCOMPtr<nsINode> targetNode = do_QueryInterface(aFocusEventTarget);
43715:   NS_ENSURE_TRUE(targetNode, NS_ERROR_INVALID_ARG);
43715:   nsCOMPtr<nsIContent> selectionRootContent = FindSelectionRoot(targetNode);
43715:   if (!selectionRootContent) {
43715:     return NS_OK;
43715:   }
43715: 
43715:   nsCOMPtr<nsIDocument> targetDoc = do_QueryInterface(aFocusEventTarget);
43715:   PRBool isTargetDoc =
43715:     targetNode->IsNodeOfType(nsINode::eDOCUMENT) &&
43715:     targetNode->HasFlag(NODE_IS_EDITABLE);
43715: 
43715:   nsCOMPtr<nsISelection> selection;
43715:   nsresult rv = GetSelection(getter_AddRefs(selection));
43715:   NS_ENSURE_SUCCESS(rv, rv);
43715: 
43715:   nsCOMPtr<nsIPresShell> presShell;
43715:   rv = GetPresShell(getter_AddRefs(presShell));
43715:   NS_ENSURE_SUCCESS(rv, rv);
43715: 
43715:   nsCOMPtr<nsISelectionController> selCon;
43715:   rv = GetSelectionController(getter_AddRefs(selCon));
43715:   NS_ENSURE_SUCCESS(rv, rv);
43715: 
43715:   nsCOMPtr<nsISelectionPrivate> selectionPrivate =
43715:     do_QueryInterface(selection);
43715:   NS_ENSURE_TRUE(selectionPrivate, NS_ERROR_UNEXPECTED);
43715: 
43715:   // Init the caret
43715:   nsRefPtr<nsCaret> caret = presShell->GetCaret();
43715:   NS_ENSURE_TRUE(caret, NS_ERROR_UNEXPECTED);
43715:   caret->SetIgnoreUserModify(PR_FALSE);
43715:   caret->SetCaretDOMSelection(selection);
43715:   selCon->SetCaretReadOnly(IsReadonly());
43715:   selCon->SetCaretEnabled(PR_TRUE);
43715: 
43715:   // Init selection
43715:   selCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
43715:   selCon->RepaintSelection(nsISelectionController::SELECTION_NORMAL);
43715:   // If the computed selection root isn't root content, we should set it
43715:   // as selection ancestor limit.  However, if that is root element, it means
43715:   // there is not limitation of the selection, then, we must set NULL.
43715:   // NOTE: If we set a root element to the ancestor limit, some selection
43715:   // methods don't work fine.
43715:   if (selectionRootContent->GetParent()) {
43715:     selectionPrivate->SetAncestorLimiter(selectionRootContent);
43715:   } else {
43715:     selectionPrivate->SetAncestorLimiter(nsnull);
43715:   }
43715: 
43715:   // XXX What case needs this?
43715:   if (isTargetDoc) {
43715:     PRInt32 rangeCount;
43715:     selection->GetRangeCount(&rangeCount);
43715:     if (rangeCount == 0) {
43715:       BeginningOfDocument();
43715:     }
43715:   }
43715: 
43715:   return NS_OK;
43715: }
43715: 
    1: nsIDOMElement *
    1: nsEditor::GetRoot()
    1: {
    1:   if (!mRootElement)
    1:   {
    1:     nsCOMPtr<nsIDOMElement> root;
    1: 
    1:     // Let GetRootElement() do the work
    1:     GetRootElement(getter_AddRefs(root));
    1:   }
    1: 
    1:   return mRootElement;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsEditor::SwitchTextDirection()
    1: {
    1:   // Get the current root direction from its frame
    1:   nsIDOMElement *rootElement = GetRoot();
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(rootElement, &rv);
43808:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
36657:   nsIFrame *frame = content->GetPrimaryFrame();
43807:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE); 
    1: 
    1:   // Apply the opposite direction
    1:   if (frame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL)
    1:     rv = rootElement->SetAttribute(NS_LITERAL_STRING("dir"), NS_LITERAL_STRING("ltr"));
    1:   else
    1:     rv = rootElement->SetAttribute(NS_LITERAL_STRING("dir"), NS_LITERAL_STRING("rtl"));
    1: 
    1:   return rv;
    1: }
    1: 
    1: #if DEBUG_JOE
    1: void
    1: nsEditor::DumpNode(nsIDOMNode *aNode, PRInt32 indent)
    1: {
    1:   PRInt32 i;
    1:   for (i=0; i<indent; i++)
    1:     printf("  ");
    1:   
    1:   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aNode);
    1:   nsCOMPtr<nsIDOMDocumentFragment> docfrag = do_QueryInterface(aNode);
    1:   
    1:   if (element || docfrag)
    1:   { 
    1:     if (element)
    1:     {
    1:       nsAutoString tag;
    1:       element->GetTagName(tag);
    1:       printf("<%s>\n", NS_LossyConvertUTF16toASCII(tag).get());
    1:     }
    1:     else
    1:     {
    1:       printf("<document fragment>\n");
    1:     }
    1:     nsCOMPtr<nsIDOMNodeList> childList;
    1:     aNode->GetChildNodes(getter_AddRefs(childList));
43806:     NS_ENSURE_TRUE(childList, NS_ERROR_NULL_POINTER);
    1:     PRUint32 numChildren;
    1:     childList->GetLength(&numChildren);
    1:     nsCOMPtr<nsIDOMNode> child, tmp;
    1:     aNode->GetFirstChild(getter_AddRefs(child));
    1:     for (i=0; i<numChildren; i++)
    1:     {
    1:       DumpNode(child, indent+1);
    1:       child->GetNextSibling(getter_AddRefs(tmp));
    1:       child = tmp;
    1:     }
    1:   }
    1:   else if (IsTextNode(aNode))
    1:   {
    1:     nsCOMPtr<nsIDOMCharacterData> textNode = do_QueryInterface(aNode);
    1:     nsAutoString str;
    1:     textNode->GetData(str);
    1:     nsCAutoString cstr;
    1:     LossyCopyUTF16toASCII(str, cstr);
    1:     cstr.ReplaceChar('\n', ' ');
    1:     printf("<textnode> %s\n", cstr.get());
    1:   }
    1: }
    1: #endif
 2896: 
 2896: PRBool
 2896: nsEditor::IsModifiableNode(nsIDOMNode *aNode)
 2896: {
 2896:   return PR_TRUE;
 2896: }
41886: 
43438: nsKeyEvent*
43438: nsEditor::GetNativeKeyEvent(nsIDOMKeyEvent* aDOMKeyEvent)
43438: {
43438:   nsCOMPtr<nsIPrivateDOMEvent> privDOMEvent = do_QueryInterface(aDOMKeyEvent);
43438:   NS_ENSURE_TRUE(privDOMEvent, nsnull);
43438:   nsEvent* nativeEvent = privDOMEvent->GetInternalNSEvent();
43438:   NS_ENSURE_TRUE(nativeEvent, nsnull);
43438:   NS_ENSURE_TRUE(nativeEvent->eventStructType == NS_KEY_EVENT, nsnull);
43438:   return static_cast<nsKeyEvent*>(nativeEvent);
43438: }
43438: 
56870: already_AddRefed<nsIContent>
56870: nsEditor::GetFocusedContent()
41886: {
41886:   nsCOMPtr<nsPIDOMEventTarget> piTarget = GetPIDOMEventTarget();
41886:   if (!piTarget) {
56870:     return nsnull;
41886:   }
41886: 
41886:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
56870:   NS_ENSURE_TRUE(fm, nsnull);
41886: 
41886:   nsCOMPtr<nsIContent> content = fm->GetFocusedContent();
56870:   return SameCOMIdentity(content, piTarget) ? content.forget() : nsnull;
41886: }
48083: 
48083: PRBool
48083: nsEditor::IsActiveInDOMWindow()
48083: {
48083:   nsCOMPtr<nsPIDOMEventTarget> piTarget = GetPIDOMEventTarget();
48083:   if (!piTarget) {
48083:     return PR_FALSE;
48083:   }
48083: 
48083:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
48083:   NS_ENSURE_TRUE(fm, PR_FALSE);
48083: 
48083:   nsCOMPtr<nsIDocument> doc = do_QueryReferent(mDocWeak);
48083:   nsPIDOMWindow* ourWindow = doc->GetWindow();
48083:   nsCOMPtr<nsPIDOMWindow> win;
48083:   nsIContent* content =
48083:     nsFocusManager::GetFocusedDescendant(ourWindow, PR_FALSE,
48083:                                          getter_AddRefs(win));
48083:   return SameCOMIdentity(content, piTarget);
48083: }
48083: 
48083: PRBool
48083: nsEditor::IsAcceptableInputEvent(nsIDOMEvent* aEvent)
48083: {
48083:   // If the event is trusted, the event should always cause input.
48083:   nsCOMPtr<nsIDOMNSEvent> NSEvent = do_QueryInterface(aEvent);
48083:   NS_ENSURE_TRUE(NSEvent, PR_FALSE);
48083: 
48083:   PRBool isTrusted;
48083:   nsresult rv = NSEvent->GetIsTrusted(&isTrusted);
48083:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
48083:   if (isTrusted) {
48083:     return PR_TRUE;
48083:   }
48083:   // Otherwise, we shouldn't handle any input events when we're not an active
48083:   // element of the DOM window.
48083:   return IsActiveInDOMWindow();
48083: }
59460: 
59460: NS_IMETHODIMP
59460: nsEditor::GetLastKeypressEventTrusted(PRBool *aWasTrusted)
59460: {
59460:   NS_ENSURE_ARG_POINTER(aWasTrusted);
59460: 
59460:   if (mLastKeypressEventWasTrusted == eTriUnset) {
59460:     return NS_ERROR_UNEXPECTED;
59460:   }
59460: 
59460:   *aWasTrusted = (mLastKeypressEventWasTrusted == eTriTrue);
59460:   return NS_OK;
59460: }
59460: 
59460: void
59460: nsEditor::BeginKeypressHandling(nsIDOMNSEvent* aEvent)
59460: {
59460:   NS_ASSERTION(mLastKeypressEventWasTrusted == eTriUnset, "How come our status is not clear?");
59460: 
59460:   if (aEvent) {
59460:     PRBool isTrusted = PR_FALSE;
59460:     aEvent->GetIsTrusted(&isTrusted);
59460:     mLastKeypressEventWasTrusted = isTrusted ? eTriTrue : eTriFalse;
59460:   }
59460: }
