     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsISupports.h"
     1: #include "nsCMS.h"
     1: #include "nsNSSHelper.h"
     1: #include "nsNSSCertificate.h"
     1: #include "smime.h"
     1: #include "cms.h"
     1: #include "nsICMSMessageErrors.h"
     1: #include "nsIArray.h"
     1: #include "nsArrayUtils.h"
     1: #include "nsCertVerificationThread.h"
 69383: #include "nsCERTValInParamWrapper.h"
     1: 
     1: #include "prlog.h"
     1: #ifdef PR_LOGGING
     1: extern PRLogModuleInfo* gPIPNSSLog;
     1: #endif
     1: 
119832: #include "nsNSSCleaner.h"
119832: #include "nsNSSComponent.h"
 69383: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
     1: 
     1: NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
     1: 
     1: NS_IMPL_THREADSAFE_ISUPPORTS2(nsCMSMessage, nsICMSMessage, 
     1:                                             nsICMSMessage2)
     1: 
     1: nsCMSMessage::nsCMSMessage()
     1: {
106838:   m_cmsMsg = nullptr;
     1: }
     1: nsCMSMessage::nsCMSMessage(NSSCMSMessage *aCMSMsg)
     1: {
     1:   m_cmsMsg = aCMSMsg;
     1: }
     1: 
     1: nsCMSMessage::~nsCMSMessage()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   destructorSafeDestroyNSSReference();
     1:   shutdown(calledFromObject);
     1: }
     1: 
     1: void nsCMSMessage::virtualDestroyNSSReference()
     1: {
     1:   destructorSafeDestroyNSSReference();
     1: }
     1: 
     1: void nsCMSMessage::destructorSafeDestroyNSSReference()
     1: {
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   if (m_cmsMsg) {
     1:     NSS_CMSMessage_Destroy(m_cmsMsg);
     1:   }
     1: }
     1: 
     1: NS_IMETHODIMP nsCMSMessage::VerifySignature()
     1: {
106838:   return CommonVerifySignature(nullptr, 0);
     1: }
     1: 
     1: NSSCMSSignerInfo* nsCMSMessage::GetTopLevelSignerInfo()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
106838:     return nullptr;
     1: 
     1:   if (!m_cmsMsg)
106838:     return nullptr;
     1: 
     1:   if (!NSS_CMSMessage_IsSigned(m_cmsMsg))
106838:     return nullptr;
     1: 
     1:   NSSCMSContentInfo *cinfo = NSS_CMSMessage_ContentLevel(m_cmsMsg, 0);
     1:   if (!cinfo)
106838:     return nullptr;
     1: 
     1:   NSSCMSSignedData *sigd = (NSSCMSSignedData*)NSS_CMSContentInfo_GetContent(cinfo);
     1:   if (!sigd)
106838:     return nullptr;
     1: 
     1:   PR_ASSERT(NSS_CMSSignedData_SignerInfoCount(sigd) > 0);
     1:   return NSS_CMSSignedData_GetSignerInfo(sigd, 0);
     1: }
     1: 
     1: NS_IMETHODIMP nsCMSMessage::GetSignerEmailAddress(char * * aEmail)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::GetSignerEmailAddress\n"));
     1:   NS_ENSURE_ARG(aEmail);
     1: 
     1:   NSSCMSSignerInfo *si = GetTopLevelSignerInfo();
     1:   if (!si)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   *aEmail = NSS_CMSSignerInfo_GetSignerEmailAddress(si);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsCMSMessage::GetSignerCommonName(char ** aName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::GetSignerCommonName\n"));
     1:   NS_ENSURE_ARG(aName);
     1: 
     1:   NSSCMSSignerInfo *si = GetTopLevelSignerInfo();
     1:   if (!si)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   *aName = NSS_CMSSignerInfo_GetSignerCommonName(si);
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP nsCMSMessage::ContentIsEncrypted(bool *isEncrypted)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::ContentIsEncrypted\n"));
     1:   NS_ENSURE_ARG(isEncrypted);
     1: 
     1:   if (!m_cmsMsg)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   *isEncrypted = NSS_CMSMessage_IsEncrypted(m_cmsMsg);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP nsCMSMessage::ContentIsSigned(bool *isSigned)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::ContentIsSigned\n"));
     1:   NS_ENSURE_ARG(isSigned);
     1: 
     1:   if (!m_cmsMsg)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   *isSigned = NSS_CMSMessage_IsSigned(m_cmsMsg);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsCMSMessage::GetSignerCert(nsIX509Cert **scert)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   NSSCMSSignerInfo *si = GetTopLevelSignerInfo();
     1:   if (!si)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   if (si->cert) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::GetSignerCert got signer cert\n"));
     1: 
 56495:     *scert = nsNSSCertificate::Create(si->cert);
     1:     if (*scert) {
     1:       (*scert)->AddRef();
     1:     }
     1:   }
     1:   else {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::GetSignerCert no signer cert, do we have a cert list? %s\n",
119832:       (si->certList != nullptr ? "yes" : "no") ));
     1: 
106838:     *scert = nullptr;
     1:   }
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsCMSMessage::GetEncryptionCert(nsIX509Cert **ecert)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:     return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
108991: NS_IMETHODIMP nsCMSMessage::VerifyDetachedSignature(unsigned char* aDigestData, uint32_t aDigestDataLen)
     1: {
     1:   if (!aDigestData || !aDigestDataLen)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   return CommonVerifySignature(aDigestData, aDigestDataLen);
     1: }
     1: 
108991: nsresult nsCMSMessage::CommonVerifySignature(unsigned char* aDigestData, uint32_t aDigestDataLen)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature, content level count %d\n", NSS_CMSMessage_ContentLevelCount(m_cmsMsg)));
106838:   NSSCMSContentInfo *cinfo = nullptr;
106838:   NSSCMSSignedData *sigd = nullptr;
     1:   NSSCMSSignerInfo *si;
108991:   int32_t nsigners;
     1:   nsresult rv = NS_ERROR_FAILURE;
119832:   nsRefPtr<nsCERTValInParamWrapper> survivingParams;
 69383:   nsCOMPtr<nsINSSComponent> inss;
     1: 
 17116:   if (!NSS_CMSMessage_IsSigned(m_cmsMsg)) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - not signed\n"));
     1:     return NS_ERROR_CMS_VERIFY_NOT_SIGNED;
     1:   } 
     1: 
     1:   cinfo = NSS_CMSMessage_ContentLevel(m_cmsMsg, 0);
     1:   if (cinfo) {
     1:     // I don't like this hard cast. We should check in some way, that we really have this type.
     1:     sigd = (NSSCMSSignedData*)NSS_CMSContentInfo_GetContent(cinfo);
     1:   }
     1:   
     1:   if (!sigd) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - no content info\n"));
     1:     rv = NS_ERROR_CMS_VERIFY_NO_CONTENT_INFO;
     1:     goto loser;
     1:   }
     1: 
     1:   if (aDigestData && aDigestDataLen)
     1:   {
     1:     SECItem digest;
     1:     digest.data = aDigestData;
     1:     digest.len = aDigestDataLen;
     1: 
     1:     if (NSS_CMSSignedData_SetDigestValue(sigd, SEC_OID_SHA1, &digest)) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - bad digest\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_BAD_DIGEST;
     1:       goto loser;
     1:     }
     1:   }
     1: 
     1:   // Import certs. Note that import failure is not a signature verification failure. //
 80486:   if (NSS_CMSSignedData_ImportCerts(sigd, CERT_GetDefaultCertDB(), certUsageEmailRecipient, true) != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - can not import certs\n"));
     1:   }
     1: 
     1:   nsigners = NSS_CMSSignedData_SignerInfoCount(sigd);
     1:   PR_ASSERT(nsigners > 0);
     1:   si = NSS_CMSSignedData_GetSignerInfo(sigd, 0);
     1: 
     1:   // See bug 324474. We want to make sure the signing cert is 
     1:   // still valid at the current time.
 69383: 
 69383:   if (!nsNSSComponent::globalConstFlagUsePKIXVerification) {
 80486:     if (CERT_VerifyCertificateNow(CERT_GetDefaultCertDB(), si->cert, true, 
     1:                                   certificateUsageEmailSigner,
119832:                                   si->cmsg->pwfn_arg, NULL) != SECSuccess) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - signing cert not trusted now\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_UNTRUSTED;
     1:       goto loser;
     1:     }
 69383:   }
 69383:   else {
 69383:     CERTValOutParam cvout[1];
 69383:     cvout[0].type = cert_po_end;
 69383: 
 69383:     inss = do_GetService(kNSSComponentCID, &rv);
 69383:     if (!inss) {
 69383:       goto loser;
 69383:     }
 69383: 
 69383:     if (NS_FAILED(inss->GetDefaultCERTValInParam(survivingParams))) {
 69383:       goto loser;
 69383:     }
106860:     SECStatus stat = CERT_PKIXVerifyCert(si->cert, certificateUsageEmailSigner,
 69383: 			    survivingParams->GetRawPointerForNSS(),
 69383: 			    cvout, si->cmsg->pwfn_arg);
106860:     if (stat != SECSuccess) {
 69383:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - signing cert not trusted now\n"));
 69383:       rv = NS_ERROR_CMS_VERIFY_UNTRUSTED;
 69383:       goto loser;
 69383:     }
 69383:   }
     1: 
     1:   // We verify the first signer info,  only //
     1:   if (NSS_CMSSignedData_VerifySignerInfo(sigd, 0, CERT_GetDefaultCertDB(), certUsageEmailSigner) != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - unable to verify signature\n"));
     1: 
     1:     if (NSSCMSVS_SigningCertNotFound == si->verificationStatus) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - signing cert not found\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_NOCERT;
     1:     }
     1:     else if(NSSCMSVS_SigningCertNotTrusted == si->verificationStatus) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - signing cert not trusted at signing time\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_UNTRUSTED;
     1:     }
     1:     else if(NSSCMSVS_Unverified == si->verificationStatus) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - can not verify\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_ERROR_UNVERIFIED;
     1:     }
     1:     else if(NSSCMSVS_ProcessingError == si->verificationStatus) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - processing error\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_ERROR_PROCESSING;
     1:     }
     1:     else if(NSSCMSVS_BadSignature == si->verificationStatus) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - bad signature\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_BAD_SIGNATURE;
     1:     }
     1:     else if(NSSCMSVS_DigestMismatch == si->verificationStatus) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - digest mismatch\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_DIGEST_MISMATCH;
     1:     }
     1:     else if(NSSCMSVS_SignatureAlgorithmUnknown == si->verificationStatus) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - algo unknown\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_UNKNOWN_ALGO;
     1:     }
     1:     else if(NSSCMSVS_SignatureAlgorithmUnsupported == si->verificationStatus) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - algo not supported\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_UNSUPPORTED_ALGO;
     1:     }
     1:     else if(NSSCMSVS_MalformedSignature == si->verificationStatus) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - malformed signature\n"));
     1:       rv = NS_ERROR_CMS_VERIFY_MALFORMED_SIGNATURE;
     1:     }
     1: 
     1:     goto loser;
     1:   }
     1: 
     1:   // Save the profile. Note that save import failure is not a signature verification failure. //
     1:   if (NSS_SMIMESignerInfo_SaveSMIMEProfile(si) != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CommonVerifySignature - unable to save smime profile\n"));
     1:   }
     1: 
     1:   rv = NS_OK;
     1: loser:
     1:   return rv;
     1: }
     1: 
     1: NS_IMETHODIMP nsCMSMessage::AsyncVerifySignature(
     1:                               nsISMimeVerificationListener *aListener)
     1: {
106838:   return CommonAsyncVerifySignature(aListener, nullptr, 0);
     1: }
     1: 
     1: NS_IMETHODIMP nsCMSMessage::AsyncVerifyDetachedSignature(
     1:                               nsISMimeVerificationListener *aListener,
108991:                               unsigned char* aDigestData, uint32_t aDigestDataLen)
     1: {
     1:   if (!aDigestData || !aDigestDataLen)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   return CommonAsyncVerifySignature(aListener, aDigestData, aDigestDataLen);
     1: }
     1: 
     1: nsresult nsCMSMessage::CommonAsyncVerifySignature(nsISMimeVerificationListener *aListener,
108991:                                                   unsigned char* aDigestData, uint32_t aDigestDataLen)
     1: {
     1:   nsSMimeVerificationJob *job = new nsSMimeVerificationJob;
119832:   if (!job)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1:   
     1:   if (aDigestData)
     1:   {
     1:     job->digest_data = new unsigned char[aDigestDataLen];
119832:     if (!job->digest_data)
119832:     {
119832:       delete job;
119832:       return NS_ERROR_OUT_OF_MEMORY;
119832:     }
119832:     
     1:     memcpy(job->digest_data, aDigestData, aDigestDataLen);
     1:   }
     1:   else
     1:   {
106838:     job->digest_data = nullptr;
     1:   }
     1:   
     1:   job->digest_len = aDigestDataLen;
     1:   job->mMessage = this;
     1:   job->mListener = aListener;
     1: 
     1:   nsresult rv = nsCertVerificationThread::addJob(job);
     1:   if (NS_FAILED(rv))
     1:     delete job;
     1: 
     1:   return rv;
     1: }
     1: 
     1: class nsZeroTerminatedCertArray : public nsNSSShutDownObject
     1: {
     1: public:
     1:   nsZeroTerminatedCertArray()
106838:   :mCerts(nullptr), mPoolp(nullptr), mSize(0)
     1:   {
     1:   }
     1:   
     1:   ~nsZeroTerminatedCertArray()
     1:   {
     1:     nsNSSShutDownPreventionLock locker;
     1:     if (isAlreadyShutDown())
     1:       return;
     1: 
     1:     destructorSafeDestroyNSSReference();
     1:     shutdown(calledFromObject);
     1:   }
     1: 
     1:   void virtualDestroyNSSReference()
     1:   {
     1:     destructorSafeDestroyNSSReference();
     1:   }
     1: 
     1:   void destructorSafeDestroyNSSReference()
     1:   {
     1:     if (isAlreadyShutDown())
     1:       return;
     1: 
     1:     if (mCerts)
     1:     {
108991:       for (uint32_t i=0; i < mSize; i++) {
     1:         if (mCerts[i]) {
     1:           CERT_DestroyCertificate(mCerts[i]);
     1:         }
     1:       }
     1:     }
     1: 
     1:     if (mPoolp)
 80486:       PORT_FreeArena(mPoolp, false);
     1:   }
     1: 
108991:   bool allocate(uint32_t count)
     1:   {
     1:     // only allow allocation once
     1:     if (mPoolp)
 80486:       return false;
     1:   
     1:     mSize = count;
     1: 
     1:     if (!mSize)
 80486:       return false;
     1:   
     1:     mPoolp = PORT_NewArena(1024);
     1:     if (!mPoolp)
 80486:       return false;
     1: 
     1:     mCerts = (CERTCertificate**)PORT_ArenaZAlloc(
     1:       mPoolp, (count+1)*sizeof(CERTCertificate*));
     1: 
     1:     if (!mCerts)
 80486:       return false;
     1: 
     1:     // null array, including zero termination
108991:     for (uint32_t i = 0; i < count+1; i++) {
106838:       mCerts[i] = nullptr;
     1:     }
     1: 
 80486:     return true;
     1:   }
     1:   
108991:   void set(uint32_t i, CERTCertificate *c)
     1:   {
     1:     nsNSSShutDownPreventionLock locker;
     1:     if (isAlreadyShutDown())
     1:       return;
     1: 
     1:     if (i >= mSize)
     1:       return;
     1:     
     1:     if (mCerts[i]) {
     1:       CERT_DestroyCertificate(mCerts[i]);
     1:     }
     1:     
     1:     mCerts[i] = CERT_DupCertificate(c);
     1:   }
     1:   
108991:   CERTCertificate *get(uint32_t i)
     1:   {
     1:     nsNSSShutDownPreventionLock locker;
     1:     if (isAlreadyShutDown())
106838:       return nullptr;
     1: 
     1:     if (i >= mSize)
106838:       return nullptr;
     1:     
     1:     return CERT_DupCertificate(mCerts[i]);
     1:   }
     1: 
     1:   CERTCertificate **getRawArray()
     1:   {
     1:     nsNSSShutDownPreventionLock locker;
     1:     if (isAlreadyShutDown())
106838:       return nullptr;
     1: 
     1:     return mCerts;
     1:   }
     1: 
     1: private:
     1:   CERTCertificate **mCerts;
     1:   PLArenaPool *mPoolp;
108991:   uint32_t mSize;
     1: };
     1: 
     1: NS_IMETHODIMP nsCMSMessage::CreateEncrypted(nsIArray * aRecipientCerts)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateEncrypted\n"));
     1:   NSSCMSContentInfo *cinfo;
     1:   NSSCMSEnvelopedData *envd;
     1:   NSSCMSRecipientInfo *recipientInfo;
     1:   nsZeroTerminatedCertArray recipientCerts;
     1:   SECOidTag bulkAlgTag;
     1:   int keySize;
108991:   uint32_t i;
     1:   nsCOMPtr<nsIX509Cert2> nssRecipientCert;
     1:   nsresult rv = NS_ERROR_FAILURE;
     1: 
     1:   // Check the recipient certificates //
108991:   uint32_t recipientCertCount;
     1:   aRecipientCerts->GetLength(&recipientCertCount);
     1:   PR_ASSERT(recipientCertCount > 0);
     1: 
     1:   if (!recipientCerts.allocate(recipientCertCount)) {
     1:     goto loser;
     1:   }
     1: 
     1:   for (i=0; i<recipientCertCount; i++) {
     1:     nsCOMPtr<nsIX509Cert> x509cert = do_QueryElementAt(aRecipientCerts, i);
     1: 
     1:     nssRecipientCert = do_QueryInterface(x509cert);
     1: 
     1:     if (!nssRecipientCert)
     1:       return NS_ERROR_FAILURE;
     1: 
     1:     CERTCertificate *c = nssRecipientCert->GetCert();
     1:     CERTCertificateCleaner rcCleaner(c);
     1:     recipientCerts.set(i, c);
     1:   }
     1:   
     1:   // Find a bulk key algorithm //
     1:   if (NSS_SMIMEUtil_FindBulkAlgForRecipients(recipientCerts.getRawArray(), &bulkAlgTag,
     1:                                             &keySize) != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateEncrypted - can't find bulk alg for recipients\n"));
     1:     rv = NS_ERROR_CMS_ENCRYPT_NO_BULK_ALG;
     1:     goto loser;
     1:   }
     1: 
119832:   m_cmsMsg = NSS_CMSMessage_Create(NULL);
119832:   if (m_cmsMsg == nullptr) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateEncrypted - can't create new cms message\n"));
     1:     rv = NS_ERROR_OUT_OF_MEMORY;
     1:     goto loser;
     1:   }
     1: 
106838:   if ((envd = NSS_CMSEnvelopedData_Create(m_cmsMsg, bulkAlgTag, keySize)) == nullptr) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateEncrypted - can't create enveloped data\n"));
     1:     goto loser;
     1:   }
     1: 
     1:   cinfo = NSS_CMSMessage_GetContentInfo(m_cmsMsg);
     1:   if (NSS_CMSContentInfo_SetContent_EnvelopedData(m_cmsMsg, cinfo, envd) != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateEncrypted - can't create content enveloped data\n"));
     1:     goto loser;
     1:   }
     1: 
     1:   cinfo = NSS_CMSEnvelopedData_GetContentInfo(envd);
106838:   if (NSS_CMSContentInfo_SetContent_Data(m_cmsMsg, cinfo, nullptr, false) != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateEncrypted - can't set content data\n"));
     1:     goto loser;
     1:   }
     1: 
     1:   // Create and attach recipient information //
     1:   for (i=0; i < recipientCertCount; i++) {
     1:     CERTCertificate *rc = recipientCerts.get(i);
     1:     CERTCertificateCleaner rcCleaner(rc);
106838:     if ((recipientInfo = NSS_CMSRecipientInfo_Create(m_cmsMsg, rc)) == nullptr) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateEncrypted - can't create recipient info\n"));
     1:       goto loser;
     1:     }
     1:     if (NSS_CMSEnvelopedData_AddRecipient(envd, recipientInfo) != SECSuccess) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateEncrypted - can't add recipient info\n"));
     1:       goto loser;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: loser:
     1:   if (m_cmsMsg) {
     1:     NSS_CMSMessage_Destroy(m_cmsMsg);
106838:     m_cmsMsg = nullptr;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
108991: NS_IMETHODIMP nsCMSMessage::CreateSigned(nsIX509Cert* aSigningCert, nsIX509Cert* aEncryptCert, unsigned char* aDigestData, uint32_t aDigestDataLen)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned\n"));
     1:   NSSCMSContentInfo *cinfo;
     1:   NSSCMSSignedData *sigd;
     1:   NSSCMSSignerInfo *signerinfo;
106838:   CERTCertificate *scert = nullptr, *ecert = nullptr;
     1:   nsCOMPtr<nsIX509Cert2> aSigningCert2 = do_QueryInterface(aSigningCert);
     1:   nsresult rv = NS_ERROR_FAILURE;
     1: 
     1:   /* Get the certs */
     1:   if (aSigningCert2) {
     1:     scert = aSigningCert2->GetCert();
     1:   }
     1:   if (!scert) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   if (aEncryptCert) {
     1:     nsCOMPtr<nsIX509Cert2> aEncryptCert2 = do_QueryInterface(aEncryptCert);
     1:     if (aEncryptCert2) {
     1:       ecert = aEncryptCert2->GetCert();
     1:     }
     1:   }
     1: 
     1:   CERTCertificateCleaner ecertCleaner(ecert);
     1:   CERTCertificateCleaner scertCleaner(scert);
     1: 
     1:   /*
     1:    * create the message object
     1:    */
119832:   m_cmsMsg = NSS_CMSMessage_Create(NULL); /* create a message on its own pool */
119832:   if (m_cmsMsg == NULL) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't create new message\n"));
     1:     rv = NS_ERROR_OUT_OF_MEMORY;
     1:     goto loser;
     1:   }
     1: 
     1:   /*
     1:    * build chain of objects: message->signedData->data
     1:    */
119832:   if ((sigd = NSS_CMSSignedData_Create(m_cmsMsg)) == NULL) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't create signed data\n"));
     1:     goto loser;
     1:   }
     1:   cinfo = NSS_CMSMessage_GetContentInfo(m_cmsMsg);
     1:   if (NSS_CMSContentInfo_SetContent_SignedData(m_cmsMsg, cinfo, sigd) 
     1:           != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't set content signed data\n"));
     1:     goto loser;
     1:   }
     1: 
     1:   cinfo = NSS_CMSSignedData_GetContentInfo(sigd);
     1: 
     1:   /* we're always passing data in and detaching optionally */
106838:   if (NSS_CMSContentInfo_SetContent_Data(m_cmsMsg, cinfo, nullptr, true) 
     1:           != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't set content data\n"));
     1:     goto loser;
     1:   }
     1: 
     1:   /* 
     1:    * create & attach signer information
     1:    */
     1:   if ((signerinfo = NSS_CMSSignerInfo_Create(m_cmsMsg, scert, SEC_OID_SHA1)) 
119832:           == NULL) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't create signer info\n"));
     1:     goto loser;
     1:   }
     1: 
     1:   /* we want the cert chain included for this one */
     1:   if (NSS_CMSSignerInfo_IncludeCerts(signerinfo, NSSCMSCM_CertChain, 
     1:                                        certUsageEmailSigner) 
     1:           != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't include signer cert chain\n"));
     1:     goto loser;
     1:   }
     1: 
     1:   if (NSS_CMSSignerInfo_AddSigningTime(signerinfo, PR_Now()) 
     1: 	      != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't add signing time\n"));
     1:     goto loser;
     1:   }
     1: 
     1:   if (NSS_CMSSignerInfo_AddSMIMECaps(signerinfo) != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't add smime caps\n"));
     1:     goto loser;
     1:   }
     1: 
     1:   if (ecert) {
     1:     if (NSS_CMSSignerInfo_AddSMIMEEncKeyPrefs(signerinfo, ecert, 
     1: 	                                    CERT_GetDefaultCertDB())
     1: 	  != SECSuccess) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't add smime enc key prefs\n"));
     1:       goto loser;
     1:     }
     1: 
     1:     if (NSS_CMSSignerInfo_AddMSSMIMEEncKeyPrefs(signerinfo, ecert, 
     1: 	                                    CERT_GetDefaultCertDB())
     1: 	  != SECSuccess) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't add MS smime enc key prefs\n"));
     1:       goto loser;
     1:     }
     1: 
 43632:     // If signing and encryption cert are identical, don't add it twice.
 79445:     bool addEncryptionCert =
 43632:       (ecert && (!scert || !CERT_CompareCerts(ecert, scert)));
 43632: 
 43632:     if (addEncryptionCert &&
 43632:         NSS_CMSSignedData_AddCertificate(sigd, ecert) != SECSuccess) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't add own encryption certificate\n"));
     1:       goto loser;
     1:     }
     1:   }
     1: 
     1:   if (NSS_CMSSignedData_AddSignerInfo(sigd, signerinfo) != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't add signer info\n"));
     1:     goto loser;
     1:   }
     1: 
     1:   // Finally, add the pre-computed digest if passed in
     1:   if (aDigestData) {
     1:     SECItem digest;
     1: 
     1:     digest.data = aDigestData;
     1:     digest.len = aDigestDataLen;
     1: 
     1:     if (NSS_CMSSignedData_SetDigestValue(sigd, SEC_OID_SHA1, &digest)) {
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSMessage::CreateSigned - can't set digest value\n"));
     1:       goto loser;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: loser:
     1:   if (m_cmsMsg) {
     1:     NSS_CMSMessage_Destroy(m_cmsMsg);
106838:     m_cmsMsg = nullptr;
     1:   }
     1:   return rv;
     1: }
     1: 
     1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCMSDecoder, nsICMSDecoder)
     1: 
     1: nsCMSDecoder::nsCMSDecoder()
106838: : m_dcx(nullptr)
     1: {
     1: }
     1: 
     1: nsCMSDecoder::~nsCMSDecoder()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   destructorSafeDestroyNSSReference();
     1:   shutdown(calledFromObject);
     1: }
     1: 
     1: void nsCMSDecoder::virtualDestroyNSSReference()
     1: {
     1:   destructorSafeDestroyNSSReference();
     1: }
     1: 
     1: void nsCMSDecoder::destructorSafeDestroyNSSReference()
     1: {
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   if (m_dcx) {
     1:     NSS_CMSDecoder_Cancel(m_dcx);
106838:     m_dcx = nullptr;
     1:   }
     1: }
     1: 
     1: /* void start (in NSSCMSContentCallback cb, in voidPtr arg); */
     1: NS_IMETHODIMP nsCMSDecoder::Start(NSSCMSContentCallback cb, void * arg)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSDecoder::Start\n"));
     1:   m_ctx = new PipUIContext();
     1: 
     1:   m_dcx = NSS_CMSDecoder_Start(0, cb, arg, 0, m_ctx, 0, 0);
     1:   if (!m_dcx) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSDecoder::Start - can't start decoder\n"));
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* void update (in string bug, in long len); */
108991: NS_IMETHODIMP nsCMSDecoder::Update(const char *buf, int32_t len)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSDecoder::Update\n"));
     1:   NSS_CMSDecoder_Update(m_dcx, (char *)buf, len);
     1:   return NS_OK;
     1: }
     1: 
     1: /* void finish (); */
     1: NS_IMETHODIMP nsCMSDecoder::Finish(nsICMSMessage ** aCMSMsg)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSDecoder::Finish\n"));
     1:   NSSCMSMessage *cmsMsg;
     1:   cmsMsg = NSS_CMSDecoder_Finish(m_dcx);
106838:   m_dcx = nullptr;
     1:   if (cmsMsg) {
     1:     nsCMSMessage *obj = new nsCMSMessage(cmsMsg);
     1:     // The NSS object cmsMsg still carries a reference to the context
     1:     // we gave it on construction.
     1:     // Make sure the context will live long enough.
     1:     obj->referenceContext(m_ctx);
     1:     *aCMSMsg = obj;
     1:     NS_ADDREF(*aCMSMsg);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCMSEncoder, nsICMSEncoder)
     1: 
     1: nsCMSEncoder::nsCMSEncoder()
106838: : m_ecx(nullptr)
     1: {
     1: }
     1: 
     1: nsCMSEncoder::~nsCMSEncoder()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   destructorSafeDestroyNSSReference();
     1:   shutdown(calledFromObject);
     1: }
     1: 
     1: void nsCMSEncoder::virtualDestroyNSSReference()
     1: {
     1:   destructorSafeDestroyNSSReference();
     1: }
     1: 
     1: void nsCMSEncoder::destructorSafeDestroyNSSReference()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   if (m_ecx)
     1:     NSS_CMSEncoder_Cancel(m_ecx);
     1: }
     1: 
     1: /* void start (); */
     1: NS_IMETHODIMP nsCMSEncoder::Start(nsICMSMessage *aMsg, NSSCMSContentCallback cb, void * arg)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSEncoder::Start\n"));
  3233:   nsCMSMessage *cmsMsg = static_cast<nsCMSMessage*>(aMsg);
     1:   m_ctx = new PipUIContext();
     1: 
     1:   m_ecx = NSS_CMSEncoder_Start(cmsMsg->getCMS(), cb, arg, 0, 0, 0, m_ctx, 0, 0, 0, 0);
119832:   if (m_ecx == nullptr) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSEncoder::Start - can't start encoder\n"));
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* void update (in string aBuf, in long aLen); */
108991: NS_IMETHODIMP nsCMSEncoder::Update(const char *aBuf, int32_t aLen)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSEncoder::Update\n"));
     1:   if (!m_ecx || NSS_CMSEncoder_Update(m_ecx, aBuf, aLen) != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSEncoder::Update - can't update encoder\n"));
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* void finish (); */
     1: NS_IMETHODIMP nsCMSEncoder::Finish()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsresult rv = NS_OK;
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSEncoder::Finish\n"));
     1:   if (!m_ecx || NSS_CMSEncoder_Finish(m_ecx) != SECSuccess) {
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSEncoder::Finish - can't finish encoder\n"));
     1:     rv = NS_ERROR_FAILURE;
     1:   }
106838:   m_ecx = nullptr;
     1:   return rv;
     1: }
     1: 
     1: /* void encode (in nsICMSMessage aMsg); */
     1: NS_IMETHODIMP nsCMSEncoder::Encode(nsICMSMessage *aMsg)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("nsCMSEncoder::Encode\n"));
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
