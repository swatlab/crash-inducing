42611: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
42611:  * ***** BEGIN LICENSE BLOCK *****
42611:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42611:  *
42611:  * The contents of this file are subject to the Mozilla Public License Version
42611:  * 1.1 (the "License"); you may not use this file except in compliance with
42611:  * the License. You may obtain a copy of the License at
42611:  * http://www.mozilla.org/MPL/
42611:  *
42611:  * Software distributed under the License is distributed on an "AS IS" basis,
42611:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42611:  * for the specific language governing rights and limitations under the
42611:  * License.
42611:  *
42611:  * The Original Code is Mozilla Corporation code.
42611:  *
42611:  * The Initial Developer of the Original Code is Mozilla Foundation.
42611:  * Portions created by the Initial Developer are Copyright (C) 2009
42611:  * the Initial Developer. All Rights Reserved.
42611:  *
42611:  * Contributor(s):
42611:  *   Bas Schouten <bschouten@mozilla.com>
42611:  *
42611:  * Alternatively, the contents of this file may be used under the terms of
42611:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42611:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42611:  * in which case the provisions of the GPL or the LGPL are applicable instead
42611:  * of those above. If you wish to allow use of your version of this file only
42611:  * under the terms of either the GPL or the LGPL, and not to allow others to
42611:  * use your version of this file under the terms of the MPL, indicate your
42611:  * decision by deleting the provisions above and replace them with the notice
42611:  * and other provisions required by the GPL or the LGPL. If you do not delete
42611:  * the provisions above, a recipient may use your version of this file under
42611:  * the terms of any one of the MPL, the GPL or the LGPL.
42611:  *
42611:  * ***** END LICENSE BLOCK ***** */
42611: 
42611: #include "ThebesLayerD3D9.h"
42611: #include "gfxPlatform.h"
42611: 
47366: #include "gfxWindowsPlatform.h"
59775: #include "gfxTeeSurface.h"
59775: #include "gfxUtils.h"
47366: 
42611: namespace mozilla {
42611: namespace layers {
42611: 
42611: ThebesLayerD3D9::ThebesLayerD3D9(LayerManagerD3D9 *aManager)
42611:   : ThebesLayer(aManager, NULL)
42611:   , LayerD3D9(aManager)
42611: {
42611:   mImplData = static_cast<LayerD3D9*>(this);
53783:   aManager->deviceManager()->mLayersWithResources.AppendElement(this);
42611: }
42611: 
42611: ThebesLayerD3D9::~ThebesLayerD3D9()
42611: {
53980:   if (mD3DManager) {
53783:     mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
42611:   }
51977: }
42611: 
47109: /**
47109:  * Retention threshold - amount of pixels intersection required to enable
47109:  * layer content retention. This is a guesstimate. Profiling could be done to
47109:  * figure out the optimal threshold.
47109:  */
47109: #define RETENTION_THRESHOLD 16384
42611: 
42611: void
59775: ThebesLayerD3D9::InvalidateRegion(const nsIntRegion &aRegion)
42611: {
59775:   mValidRegion.Sub(mValidRegion, aRegion);
42611: }
47366: 
59775: void
59775: ThebesLayerD3D9::CopyRegion(IDirect3DTexture9* aSrc, const nsIntPoint &aSrcOffset,
59775:                             IDirect3DTexture9* aDest, const nsIntPoint &aDestOffset,
59775:                             const nsIntRegion &aCopyRegion, nsIntRegion* aValidRegion)
59775: {
47109:   nsRefPtr<IDirect3DSurface9> srcSurface, dstSurface;
59775:   aSrc->GetSurfaceLevel(0, getter_AddRefs(srcSurface));
59775:   aDest->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
47109: 
47109:   nsIntRegion retainedRegion;
59775:   nsIntRegionRectIterator iter(aCopyRegion);
47109:   const nsIntRect *r;
47109:   while ((r = iter.Next())) {
47109:     if (r->width * r->height > RETENTION_THRESHOLD) {
47109:       RECT oldRect, newRect;
47109: 
47109:       // Calculate the retained rectangle's position on the old and the new
47109:       // surface.
59775:       oldRect.left = r->x - aSrcOffset.x;
59775:       oldRect.top = r->y - aSrcOffset.y;
47109:       oldRect.right = oldRect.left + r->width;
47109:       oldRect.bottom = oldRect.top + r->height;
47109: 
59775:       newRect.left = r->x - aDestOffset.x;
59775:       newRect.top = r->y - aDestOffset.y;
47109:       newRect.right = newRect.left + r->width;
47109:       newRect.bottom = newRect.top + r->height;
47109: 
47109:       // Copy data from our old texture to the new one
47109:       HRESULT hr = device()->
47109:         StretchRect(srcSurface, &oldRect, dstSurface, &newRect, D3DTEXF_NONE);
47109: 
47109:       if (SUCCEEDED(hr)) {
47109:         retainedRegion.Or(retainedRegion, *r);
47109:       }
47109:     }
47109:   }
47109: 
47109:   // Areas which were valid and were retained are still valid
59775:   aValidRegion->And(*aValidRegion, retainedRegion);
42611: }
42611: 
59775: static PRUint64 RectArea(const nsIntRect& aRect)
42611: {
59775:   return aRect.width*PRUint64(aRect.height);
42611: }
42611: 
42611: void
59775: ThebesLayerD3D9::UpdateTextures(SurfaceMode aMode)
42611: {
59775:   nsIntRect visibleRect = mVisibleRegion.GetBounds();
59775: 
59775:   if (HaveTextures(aMode)) {
59775:     if (mTextureRect != visibleRect) {
59775:       nsRefPtr<IDirect3DTexture9> oldTexture = mTexture;
59775:       nsRefPtr<IDirect3DTexture9> oldTextureOnWhite = mTextureOnWhite;
59775: 
59775:       NS_ASSERTION(mTextureRect.Contains(mValidRegion.GetBounds()),
59775:                    "How can we have valid data outside the texture?");
59775:       nsIntRegion retainRegion;
59775:       // The region we want to retain is the valid data that is inside
59775:       // the new visible region
59775:       retainRegion.And(mValidRegion, mVisibleRegion);
59775: 
59775:       CreateNewTextures(gfxIntSize(visibleRect.width, visibleRect.height), aMode);
59775: 
59775:       // If our texture creation failed this can mean a device reset is pending and we
59775:       // should silently ignore the failure. In the future when device failures
59775:       // are properly handled we should test for the type of failure and gracefully
59775:       // handle different failures. See bug 569081.
59775:       if (!HaveTextures(aMode)) {
59775:         mValidRegion.SetEmpty();
59775:       } else {
59775:         CopyRegion(oldTexture, mTextureRect.TopLeft(), mTexture, visibleRect.TopLeft(),
59775:                    retainRegion, &mValidRegion);
59775:         if (aMode == SURFACE_COMPONENT_ALPHA) {
59775:           CopyRegion(oldTextureOnWhite, mTextureRect.TopLeft(), mTextureOnWhite, visibleRect.TopLeft(),
59775:                      retainRegion, &mValidRegion);
59775:         }
47109:       }
47366: 
59775:       mTextureRect = visibleRect;
59775:     }
59775:   } else {
59775:     CreateNewTextures(gfxIntSize(visibleRect.width, visibleRect.height), aMode);
59775:     mTextureRect = visibleRect;
42956:     
59775:     NS_ASSERTION(mValidRegion.IsEmpty(), "Someone forgot to empty the region");
47366:   }
47366: }
47366: 
59775: void
59775: ThebesLayerD3D9::RenderVisibleRegion()
59775: {
52176:   nsIntRegionRectIterator iter(mVisibleRegion);
52176: 
52176:   const nsIntRect *iterRect;
52176:   while ((iterRect = iter.Next())) {
54880:     device()->SetVertexShaderConstantF(CBvLayerQuad,
54880:                                        ShaderConstantRect(iterRect->x,
54880:                                                           iterRect->y,
54880:                                                           iterRect->width,
54880:                                                           iterRect->height),
54880:                                        1);
52176: 
54880:     device()->SetVertexShaderConstantF(CBvTextureCoords,
54880:       ShaderConstantRect(
59775:         (float)(iterRect->x - mTextureRect.x) / (float)mTextureRect.width,
59775:         (float)(iterRect->y - mTextureRect.y) / (float)mTextureRect.height,
59775:         (float)iterRect->width / (float)mTextureRect.width,
59775:         (float)iterRect->height / (float)mTextureRect.height), 1);
54880: 
42611:     device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
42611:   }
59775: }
59775: 
59775: void
59775: ThebesLayerD3D9::RenderLayer()
59775: {
59775:   if (mVisibleRegion.IsEmpty()) {
59775:     return;
59775:   }
59775: 
59775:   SurfaceMode mode = GetSurfaceMode();
59775:   if (mode == SURFACE_COMPONENT_ALPHA &&
59775:       (!mParent || !mParent->SupportsComponentAlphaChildren())) {
59775:     mode = SURFACE_SINGLE_CHANNEL_ALPHA;
59775:   }
59775:   VerifyContentType(mode);
59775:   UpdateTextures(mode);
59775:   if (!HaveTextures(mode)) {
59775:     NS_WARNING("Texture creation failed");
59775:     return;
59775:   }
59775: 
59775:   if (!mValidRegion.IsEqual(mVisibleRegion)) {
59775:     /* We use the bounds of the visible region because we draw the bounds of
59775:      * this region when we draw this entire texture. We have to make sure that
59775:      * the areas that aren't filled with content get their background drawn.
59775:      * This is an issue for opaque surfaces, which otherwise won't get their
59775:      * background painted.
59775:      */
59775:     nsIntRegion region;
59775:     region.Sub(mVisibleRegion, mValidRegion);
59775:     DrawRegion(region, mode);
59775: 
59775:     mValidRegion = mVisibleRegion;
59775:   }
59775: 
59775:   SetShaderTransformAndOpacity();
59775: 
59775:   if (mode == SURFACE_COMPONENT_ALPHA) {
59775:     mD3DManager->SetShaderMode(DeviceManagerD3D9::COMPONENTLAYERPASS1);
59775:     device()->SetTexture(0, mTexture);
59775:     device()->SetTexture(1, mTextureOnWhite);
59775:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);
59775:     device()->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCCOLOR);
59775:     RenderVisibleRegion();
59775: 
59775:     mD3DManager->SetShaderMode(DeviceManagerD3D9::COMPONENTLAYERPASS2);
59775:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
59775:     device()->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
59775:     RenderVisibleRegion();
59775: 
59775:     // Restore defaults
59775:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
59775:     device()->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
59775:     device()->SetTexture(1, NULL);
59775:   } else {
59775:     mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBALAYER);
59775:     device()->SetTexture(0, mTexture);
59775:     RenderVisibleRegion();
59775:   }
42611: 
52176:   // Set back to default.
54880:   device()->SetVertexShaderConstantF(CBvTextureCoords,
54880:                                      ShaderConstantRect(0, 0, 1.0f, 1.0f),
54880:                                      1);
52176: }
52176: 
42611: void
42611: ThebesLayerD3D9::CleanResources()
42611: {
42611:   mTexture = nsnull;
59775:   mTextureOnWhite = nsnull;
59813:   mValidRegion.SetEmpty();
42611: }
42611: 
53979: void
53979: ThebesLayerD3D9::LayerManagerDestroyed()
53979: {
53979:   mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
53979:   mD3DManager = nsnull;
53979: }
53979: 
42611: Layer*
42611: ThebesLayerD3D9::GetLayer()
42611: {
42611:   return this;
42611: }
42611: 
42611: PRBool
42611: ThebesLayerD3D9::IsEmpty()
42611: {
42611:   return !mTexture;
42611: }
42611: 
49323: void
59775: ThebesLayerD3D9::VerifyContentType(SurfaceMode aMode)
53680: {
59775:   if (!mTexture)
59775:     return;
59775: 
59775:   D3DSURFACE_DESC desc;
59775:   mTexture->GetLevelDesc(0, &desc);
59775: 
59775:   switch (aMode) {
59775:   case SURFACE_OPAQUE:
59775:     if (desc.Format == D3DFMT_X8R8G8B8 && !mTextureOnWhite)
59775:       return;
59775:     break;
59775: 
59775:   case SURFACE_SINGLE_CHANNEL_ALPHA:
59775:     if (desc.Format == D3DFMT_A8R8G8B8 && !mTextureOnWhite)
59775:       return;
59775:     break;
59775: 
59775:   case SURFACE_COMPONENT_ALPHA:
59775:     if (mTextureOnWhite) {
59775:       NS_ASSERTION(desc.Format == D3DFMT_X8R8G8B8, "Wrong format for component alpha texture");
59775:       return;
59775:     }
59775:     break;
59775:   }
59775: 
59775:   // The new format isn't compatible with the old texture(s), toss out the old
59775:   // texture(s).
59775:   mTexture = nsnull;
59775:   mTextureOnWhite = nsnull;
59775:   mValidRegion.SetEmpty();
59775: }
59775: 
59775: class OpaqueRenderer {
59775: public:
59775:   OpaqueRenderer(const nsIntRegion& aUpdateRegion) :
59775:     mUpdateRegion(aUpdateRegion), mDC(NULL) {}
59775:   already_AddRefed<gfxWindowsSurface> Begin(LayerD3D9* aLayer);
59775:   void End();
59775:   IDirect3DTexture9* GetTexture() { return mTmpTexture; }
59775: 
59775: private:
59775:   const nsIntRegion& mUpdateRegion;
59775:   nsRefPtr<IDirect3DTexture9> mTmpTexture;
59775:   nsRefPtr<IDirect3DSurface9> mSurface;
59775:   HDC mDC;
59775: };
59775: 
59775: already_AddRefed<gfxWindowsSurface>
59775: OpaqueRenderer::Begin(LayerD3D9* aLayer)
59775: {
59775:   nsIntRect bounds = mUpdateRegion.GetBounds();
59775: 
59775:   HRESULT hr = aLayer->device()->
59775:       CreateTexture(bounds.width, bounds.height, 1, 0, D3DFMT_X8R8G8B8,
59775:                     D3DPOOL_SYSTEMMEM, getter_AddRefs(mTmpTexture), NULL);
59775: 
59775:   if (FAILED(hr)) {
59775:     aLayer->ReportFailure(NS_LITERAL_CSTRING("Failed to create temporary texture in system memory."), hr);
59775:     return nsnull;
59775:   }
59775: 
59775:   hr = mTmpTexture->GetSurfaceLevel(0, getter_AddRefs(mSurface));
59775: 
59775:   if (FAILED(hr)) {
59775:     // Uh-oh, bail.
59775:     NS_WARNING("Failed to get texture surface level.");
59775:     return nsnull;
59775:   }
59775: 
59775:   hr = mSurface->GetDC(&mDC);
59775:   if (FAILED(hr)) {
59775:     NS_WARNING("Failed to get device context for texture surface.");
59775:     return nsnull;
59775:   }
59775: 
59775:   nsRefPtr<gfxWindowsSurface> result = new gfxWindowsSurface(mDC);
59775:   return result.forget();
53680: }
53680: 
53680: void
59775: OpaqueRenderer::End()
59775: {
59775:   mSurface->ReleaseDC(mDC);
59775: }
59775: 
59775: static void
59775: FillSurface(gfxASurface* aSurface, const nsIntRegion& aRegion,
59775:             const nsIntPoint& aOffset, const gfxRGBA& aColor)
59775: {
59775:   nsRefPtr<gfxContext> ctx = new gfxContext(aSurface);
59775:   ctx->Translate(-gfxPoint(aOffset.x, aOffset.y));
59775:   gfxUtils::ClipToRegion(ctx, aRegion);
59775:   ctx->SetColor(aColor);
59775:   ctx->Paint();
59775: }
59775: 
59775: void
59775: ThebesLayerD3D9::DrawRegion(const nsIntRegion &aRegion, SurfaceMode aMode)
49323: {
49323:   HRESULT hr;
49323:   nsIntRect visibleRect = mVisibleRegion.GetBounds();
49323: 
59775:   nsRefPtr<gfxASurface> destinationSurface;
49323:   nsIntRect bounds = aRegion.GetBounds();
59775:   nsRefPtr<IDirect3DTexture9> tmpTexture;
59775:   OpaqueRenderer opaqueRenderer(aRegion);
59775:   OpaqueRenderer opaqueRendererOnWhite(aRegion);
49323: 
59775:   switch (aMode)
59775:   {
59775:     case SURFACE_OPAQUE:
59775:       destinationSurface = opaqueRenderer.Begin(this);
59775:       break;
49323: 
59775:     case SURFACE_SINGLE_CHANNEL_ALPHA: {
55203:       hr = device()->CreateTexture(bounds.width, bounds.height, 1,
59775:                                    0, D3DFMT_A8R8G8B8,
49323:                                    D3DPOOL_SYSTEMMEM, getter_AddRefs(tmpTexture), NULL);
49323: 
55203:       if (FAILED(hr)) {
55203:         ReportFailure(NS_LITERAL_CSTRING("Failed to create temporary texture in system memory."), hr);
55203:         return;
55203:       }
55203: 
49323:       // XXX - We may consider retaining a SYSTEMMEM texture texture the size
49323:       // of our DEFAULT texture and then use UpdateTexture and add dirty rects
49323:       // to update in a single call.
59775:       nsRefPtr<gfxWindowsSurface> dest = new gfxWindowsSurface(
59775:           gfxIntSize(bounds.width, bounds.height), gfxASurface::ImageFormatARGB32);
59775:       // If the contents of this layer don't require component alpha in the
59775:       // end of rendering, it's safe to enable Cleartype since all the Cleartype
59775:       // glyphs must be over (or under) opaque pixels.
59775:       dest->SetSubpixelAntialiasingEnabled(!(mContentFlags & CONTENT_COMPONENT_ALPHA));
59775:       destinationSurface = dest.forget();
59775:       break;
59775:     }
59775: 
59775:     case SURFACE_COMPONENT_ALPHA: {
59775:       nsRefPtr<gfxWindowsSurface> onBlack = opaqueRenderer.Begin(this);
59775:       nsRefPtr<gfxWindowsSurface> onWhite = opaqueRendererOnWhite.Begin(this);
59775:       FillSurface(onBlack, aRegion, bounds.TopLeft(), gfxRGBA(0.0, 0.0, 0.0, 1.0));
59775:       FillSurface(onWhite, aRegion, bounds.TopLeft(), gfxRGBA(1.0, 1.0, 1.0, 1.0));
59775:       gfxASurface* surfaces[2] = { onBlack.get(), onWhite.get() };
59775:       destinationSurface = new gfxTeeSurface(surfaces, NS_ARRAY_LENGTH(surfaces));
59775:       // Using this surface as a source will likely go horribly wrong, since
59775:       // only the onBlack surface will really be used, so alpha information will
59775:       // be incorrect.
59775:       destinationSurface->SetAllowUseAsSource(PR_FALSE);
59775:       break;
59775:     }
49323:   }
49323: 
60231:   if (destinationSurface) {
60231:     nsRefPtr<gfxContext> context = new gfxContext(destinationSurface);
49323:     context->Translate(gfxPoint(-bounds.x, -bounds.y));
49323:     LayerManagerD3D9::CallbackInfo cbInfo = mD3DManager->GetCallbackInfo();
49323:     cbInfo.Callback(this, context, aRegion, nsIntRegion(), cbInfo.CallbackData);
60231:   }
49323: 
59775:   nsAutoTArray<IDirect3DTexture9*,2> srcTextures;
59775:   nsAutoTArray<IDirect3DTexture9*,2> destTextures;
59775:   switch (aMode)
59775:   {
59775:     case SURFACE_OPAQUE:
59775:       opaqueRenderer.End();
59775:       srcTextures.AppendElement(opaqueRenderer.GetTexture());
59775:       destTextures.AppendElement(mTexture);
59775:       break;
59775: 
59775:     case SURFACE_SINGLE_CHANNEL_ALPHA: {
49323:       D3DLOCKED_RECT r;
49323:       tmpTexture->LockRect(0, &r, NULL, 0);
49323: 
49323:       nsRefPtr<gfxImageSurface> imgSurface =
49323:         new gfxImageSurface((unsigned char *)r.pBits,
49323:                             gfxIntSize(bounds.width,
49323:                                        bounds.height),
49323:                             r.Pitch,
59775:                             gfxASurface::ImageFormatARGB32);
49323: 
60231:       if (destinationSurface) {
60231:         nsRefPtr<gfxContext> context = new gfxContext(imgSurface);
49323:         context->SetSource(destinationSurface);
49323:         context->SetOperator(gfxContext::OPERATOR_SOURCE);
49323:         context->Paint();
60231:       }
49323: 
49323:       imgSurface = NULL;
49323: 
49323:       tmpTexture->UnlockRect(0);
59775: 
59775:       srcTextures.AppendElement(tmpTexture);
59775:       destTextures.AppendElement(mTexture);
59775:       break;
49323:     }
49323: 
59775:     case SURFACE_COMPONENT_ALPHA: {
59775:       opaqueRenderer.End();
59775:       opaqueRendererOnWhite.End();
59775:       srcTextures.AppendElement(opaqueRenderer.GetTexture());
59775:       destTextures.AppendElement(mTexture);
59775:       srcTextures.AppendElement(opaqueRendererOnWhite.GetTexture());
59775:       destTextures.AppendElement(mTextureOnWhite);
59775:       break;
59775:     }
59775:   }
59775:   NS_ASSERTION(srcTextures.Length() == destTextures.Length(), "Mismatched lengths");
59775: 
59775:   for (PRUint32 i = 0; i < srcTextures.Length(); ++i) {
49323:     nsRefPtr<IDirect3DSurface9> srcSurface;
49323:     nsRefPtr<IDirect3DSurface9> dstSurface;
49323: 
59775:     destTextures[i]->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
59775:     srcTextures[i]->GetSurfaceLevel(0, getter_AddRefs(srcSurface));
49323: 
49323:     nsIntRegionRectIterator iter(aRegion);
49323:     const nsIntRect *iterRect;
49323:     while ((iterRect = iter.Next())) {
49323:       RECT rect;
49323:       rect.left = iterRect->x - bounds.x;
49323:       rect.top = iterRect->y - bounds.y;
49323:       rect.right = rect.left + iterRect->width;
49323:       rect.bottom = rect.top + iterRect->height;
49323:       POINT point;
49323:       point.x = iterRect->x - visibleRect.x;
49323:       point.y = iterRect->y - visibleRect.y;
49323:       device()->UpdateSurface(srcSurface, &rect, dstSurface, &point);
49323:     }
49323:   }
59775: }
49323: 
49323: void
59775: ThebesLayerD3D9::CreateNewTextures(const gfxIntSize &aSize,
59775:                                    SurfaceMode aMode)
49323: {
59775:   if (aSize.width == 0 || aSize.height == 0) {
49323:     // Nothing to do.
49323:     return;
49323:   }
49323: 
49323:   mTexture = nsnull;
59775:   mTextureOnWhite = nsnull;
49323:   device()->CreateTexture(aSize.width, aSize.height, 1,
59775:                           D3DUSAGE_RENDERTARGET,
59775:                           aMode != SURFACE_SINGLE_CHANNEL_ALPHA ? D3DFMT_X8R8G8B8 : D3DFMT_A8R8G8B8,
49323:                           D3DPOOL_DEFAULT, getter_AddRefs(mTexture), NULL);
59775:   if (aMode == SURFACE_COMPONENT_ALPHA) {
59775:     device()->CreateTexture(aSize.width, aSize.height, 1,
59775:                             D3DUSAGE_RENDERTARGET,
59775:                             D3DFMT_X8R8G8B8,
59775:                             D3DPOOL_DEFAULT, getter_AddRefs(mTextureOnWhite), NULL);
59775:   }
49323: }
49323: 
42611: } /* namespace layers */
42956: } /* namespace mozilla */
