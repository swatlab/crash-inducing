104324: /* This Source Code Form is subject to the terms of the Mozilla Public
104324:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
104324:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
104324: 
104324: #include "MediaEngineDefault.h"
104324: 
104324: #include "nsCOMPtr.h"
104324: #include "nsDOMFile.h"
104324: #include "nsILocalFile.h"
108747: #include "Layers.h"
108884: #include "ImageContainer.h"
108884: #include "ImageTypes.h"
104324: 
104324: #ifdef MOZ_WIDGET_ANDROID
104324: #include "AndroidBridge.h"
104324: #include "nsISupportsUtils.h"
104324: #endif
104324: 
104324: #define CHANNELS 1
104324: #define RATE USECS_PER_S
104324: 
104324: namespace mozilla {
104324: 
104324: NS_IMPL_THREADSAFE_ISUPPORTS1(MediaEngineDefaultVideoSource, nsITimerCallback)
104324: /**
104324:  * Default video source.
104324:  */
106914: 
116149: // Cannot be initialized in the class definition
116149: const MediaEngineVideoOptions MediaEngineDefaultVideoSource::mOpts = {
116149:   DEFAULT_WIDTH,
116149:   DEFAULT_HEIGHT,
116149:   DEFAULT_FPS,
116149:   kVideoCodecI420
116149: };
116149: 
106914: MediaEngineDefaultVideoSource::MediaEngineDefaultVideoSource()
119135:   : mTimer(nullptr)
119135: {
119135:   mState = kReleased;
119135: }
106914: 
106914: MediaEngineDefaultVideoSource::~MediaEngineDefaultVideoSource()
106914: {}
106914: 
104324: void
104324: MediaEngineDefaultVideoSource::GetName(nsAString& aName)
104324: {
104324:   aName.Assign(NS_LITERAL_STRING("Default Video Device"));
104324:   return;
104324: }
104324: 
104324: void
104324: MediaEngineDefaultVideoSource::GetUUID(nsAString& aUUID)
104324: {
104324:   aUUID.Assign(NS_LITERAL_STRING("1041FCBD-3F12-4F7B-9E9B-1EC556DD5676"));
104324:   return;
104324: }
104324: 
104348: nsresult
104324: MediaEngineDefaultVideoSource::Allocate()
104324: {
104324:   if (mState != kReleased) {
104348:     return NS_ERROR_FAILURE;
104324:   }
104324: 
104324:   mState = kAllocated;
104348:   return NS_OK;
104324: }
104324: 
104324: nsresult
104324: MediaEngineDefaultVideoSource::Deallocate()
104324: {
104324:   if (mState != kStopped && mState != kAllocated) {
104324:     return NS_ERROR_FAILURE;
104324:   }
104324:   mState = kReleased;
104324:   return NS_OK;
104324: }
104324: 
116149: const MediaEngineVideoOptions *
104324: MediaEngineDefaultVideoSource::GetOptions()
104324: {
116149:   return &mOpts;
104324: }
104324: 
104324: nsresult
104324: MediaEngineDefaultVideoSource::Start(SourceMediaStream* aStream, TrackID aID)
104324: {
104324:   if (mState != kAllocated) {
104324:     return NS_ERROR_FAILURE;
104324:   }
104324: 
104324:   mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
104324:   if (!mTimer) {
104324:     return NS_ERROR_FAILURE;
104324:   }
104324: 
104324:   mSource = aStream;
104324: 
104324:   // Allocate a single blank Image
108757:   ImageFormat format = PLANAR_YCBCR;
104324:   mImageContainer = layers::LayerManager::CreateImageContainer();
104324: 
104324:   nsRefPtr<layers::Image> image = mImageContainer->CreateImage(&format, 1);
104324: 
116149:   int len = ((DEFAULT_WIDTH * DEFAULT_HEIGHT) * 3 / 2);
104324:   mImage = static_cast<layers::PlanarYCbCrImage*>(image.get());
108991:   uint8_t* frame = (uint8_t*) PR_Malloc(len);
104324:   memset(frame, 0x80, len); // Gray
104324: 
108991:   const uint8_t lumaBpp = 8;
108991:   const uint8_t chromaBpp = 4;
104324: 
104324:   layers::PlanarYCbCrImage::Data data;
104324:   data.mYChannel = frame;
116149:   data.mYSize = gfxIntSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);
116149:   data.mYStride = DEFAULT_WIDTH * lumaBpp / 8.0;
116149:   data.mCbCrStride = DEFAULT_WIDTH * chromaBpp / 8.0;
116149:   data.mCbChannel = frame + DEFAULT_HEIGHT * data.mYStride;
116149:   data.mCrChannel = data.mCbChannel + DEFAULT_HEIGHT * data.mCbCrStride / 2;
116149:   data.mCbCrSize = gfxIntSize(DEFAULT_WIDTH / 2, DEFAULT_HEIGHT / 2);
104324:   data.mPicX = 0;
104324:   data.mPicY = 0;
116149:   data.mPicSize = gfxIntSize(DEFAULT_WIDTH, DEFAULT_HEIGHT);
108747:   data.mStereoMode = STEREO_MODE_MONO;
104324: 
104324:   // SetData copies data, so we can free the frame
104324:   mImage->SetData(data);
104324:   PR_Free(frame);
104324: 
104324:   // AddTrack takes ownership of segment
104324:   VideoSegment *segment = new VideoSegment();
116149:   segment->AppendFrame(image.forget(), USECS_PER_S / DEFAULT_FPS, gfxIntSize(DEFAULT_WIDTH, DEFAULT_HEIGHT));
104324:   mSource->AddTrack(aID, RATE, 0, segment);
104324: 
104324:   // We aren't going to add any more tracks
104324:   mSource->AdvanceKnownTracksTime(STREAM_TIME_MAX);
104324: 
104324:   // Remember TrackID so we can end it later
104324:   mTrackID = aID;
104324: 
104324:   // Start timer for subsequent frames
116149:   mTimer->InitWithCallback(this, 1000 / DEFAULT_FPS, nsITimer::TYPE_REPEATING_SLACK);
104324:   mState = kStarted;
104324: 
104324:   return NS_OK;
104324: }
104324: 
104324: nsresult
104324: MediaEngineDefaultVideoSource::Stop()
104324: {
104324:   if (mState != kStarted) {
104324:     return NS_ERROR_FAILURE;
104324:   }
104324:   if (!mTimer) {
104324:     return NS_ERROR_FAILURE;
104324:   }
104324: 
104324:   mTimer->Cancel();
104324:   mTimer = NULL;
104324: 
104324:   mSource->EndTrack(mTrackID);
104324:   mSource->Finish();
104324: 
104324:   mState = kStopped;
104324:   return NS_OK;
104324: }
104324: 
104324: nsresult
108991: MediaEngineDefaultVideoSource::Snapshot(uint32_t aDuration, nsIDOMFile** aFile)
104324: {
106838:   *aFile = nullptr;
104324: 
104324: #ifndef MOZ_WIDGET_ANDROID
104324:   return NS_ERROR_NOT_IMPLEMENTED;
104324: #else
104324:   if (!AndroidBridge::Bridge()) {
104324:     return NS_ERROR_UNEXPECTED;
104324:   }
104324: 
104324:   nsAutoString filePath;
104324:   AndroidBridge::Bridge()->ShowFilePickerForMimeType(filePath, NS_LITERAL_STRING("image/*"));
104324: 
104324:   nsCOMPtr<nsIFile> file;
104324:   nsresult rv = NS_NewLocalFile(filePath, false, getter_AddRefs(file));
104324:   NS_ENSURE_SUCCESS(rv, rv);
104324: 
104324:   NS_ADDREF(*aFile = new nsDOMFileFile(file));
104324:   return NS_OK;
104324: #endif
104324: }
104324: 
104324: NS_IMETHODIMP
104324: MediaEngineDefaultVideoSource::Notify(nsITimer* aTimer)
104324: {
104324:   VideoSegment segment;
104324: 
104324:   nsRefPtr<layers::PlanarYCbCrImage> image = mImage;
116149:   segment.AppendFrame(image.forget(), USECS_PER_S / DEFAULT_FPS, gfxIntSize(DEFAULT_WIDTH, DEFAULT_HEIGHT));
104324:   mSource->AppendToTrack(mTrackID, &segment);
104324: 
104324:   return NS_OK;
104324: }
104324: 
119168: void
119168: MediaEngineDefaultVideoSource::NotifyPull(MediaStreamGraph* aGraph,
119168:                                           StreamTime aDesiredTime)
119168: {
119168:   // Ignore - we push video data
119168: }
119168: 
119168: 
104324: /**
104324:  * Default audio source.
104324:  */
119168: NS_IMPL_THREADSAFE_ISUPPORTS1(MediaEngineDefaultAudioSource, nsITimerCallback)
119168: 
119135: MediaEngineDefaultAudioSource::MediaEngineDefaultAudioSource()
119135:   : mTimer(nullptr)
119135: {
119135:   mState = kReleased;
119135: }
119135: 
119135: MediaEngineDefaultAudioSource::~MediaEngineDefaultAudioSource()
119135: {}
119135: 
104324: void
119168: MediaEngineDefaultAudioSource::NotifyPull(MediaStreamGraph* aGraph,
119168:                                           StreamTime aDesiredTime)
119168: {
119168:   // Ignore - we push audio data
119168: }
119168: 
119168: void
104324: MediaEngineDefaultAudioSource::GetName(nsAString& aName)
104324: {
104324:   aName.Assign(NS_LITERAL_STRING("Default Audio Device"));
104324:   return;
104324: }
104324: 
104324: void
104324: MediaEngineDefaultAudioSource::GetUUID(nsAString& aUUID)
104324: {
104324:   aUUID.Assign(NS_LITERAL_STRING("B7CBD7C1-53EF-42F9-8353-73F61C70C092"));
104324:   return;
104324: }
104324: 
104348: nsresult
104324: MediaEngineDefaultAudioSource::Allocate()
104324: {
104324:   if (mState != kReleased) {
104348:     return NS_ERROR_FAILURE;
104324:   }
104348: 
104324:   mState = kAllocated;
104348:   return NS_OK;
104324: }
104324: 
104324: nsresult
104324: MediaEngineDefaultAudioSource::Deallocate()
104324: {
104324:   if (mState != kStopped && mState != kAllocated) {
104324:     return NS_ERROR_FAILURE;
104324:   }
104324:   mState = kReleased;
104324:   return NS_OK;
104324: }
104324: 
104324: nsresult
104324: MediaEngineDefaultAudioSource::Start(SourceMediaStream* aStream, TrackID aID)
104324: {
104324:   if (mState != kAllocated) {
104348:     return NS_ERROR_FAILURE;
104324:   }
104324: 
104324:   mTimer = do_CreateInstance(NS_TIMER_CONTRACTID);
104324:   if (!mTimer) {
104348:     return NS_ERROR_FAILURE;
104324:   }
104324: 
104324:   mSource = aStream;
104324: 
104324:   // AddTrack will take ownership of segment
104324:   AudioSegment* segment = new AudioSegment();
104324:   segment->Init(CHANNELS);
104324:   mSource->AddTrack(aID, RATE, 0, segment);
104324: 
104324:   // We aren't going to add any more tracks
104324:   mSource->AdvanceKnownTracksTime(STREAM_TIME_MAX);
104324: 
104324:   // Remember TrackID so we can finish later
104324:   mTrackID = aID;
104324: 
104324:   // 1 Audio frame per Video frame
116149:   mTimer->InitWithCallback(this, 1000 / MediaEngineDefaultVideoSource::DEFAULT_FPS, nsITimer::TYPE_REPEATING_SLACK);
104324:   mState = kStarted;
104324: 
104324:   return NS_OK;
104324: }
104324: 
104324: nsresult
104324: MediaEngineDefaultAudioSource::Stop()
104324: {
104324:   if (mState != kStarted) {
104324:     return NS_ERROR_FAILURE;
104324:   }
104324:   if (!mTimer) {
104324:     return NS_ERROR_FAILURE;
104324:   }
104324: 
104324:   mTimer->Cancel();
104324:   mTimer = NULL;
104324: 
104324:   mSource->EndTrack(mTrackID);
104324:   mSource->Finish();
104324: 
104324:   mState = kStopped;
104324:   return NS_OK;
104324: }
104324: 
104324: nsresult
108991: MediaEngineDefaultAudioSource::Snapshot(uint32_t aDuration, nsIDOMFile** aFile)
104324: {
104324:    return NS_ERROR_NOT_IMPLEMENTED;
104324: }
104324: 
104324: NS_IMETHODIMP
104324: MediaEngineDefaultAudioSource::Notify(nsITimer* aTimer)
104324: {
104324:   AudioSegment segment;
104324:   segment.Init(CHANNELS);
104324:   segment.InsertNullDataAtStart(1);
104324: 
104324:   mSource->AppendToTrack(mTrackID, &segment);
104324: 
104324:   return NS_OK;
104324: }
104324: 
104324: void
104324: MediaEngineDefault::EnumerateVideoDevices(nsTArray<nsRefPtr<MediaEngineVideoSource> >* aVSources) {
119499:   MutexAutoLock lock(mMutex);
119135:   int32_t found = false;
119135:   int32_t len = mVSources.Length();
119499: 
119135:   for (int32_t i = 0; i < len; i++) {
119135:     nsRefPtr<MediaEngineVideoSource> source = mVSources.ElementAt(i);
119135:     aVSources->AppendElement(source);
119135:     if (source->IsAvailable()) {
119135:       found = true;
119135:     }
119135:   }
119135: 
119135:   // All streams are currently busy, just make a new one.
119135:   if (!found) {
119135:     nsRefPtr<MediaEngineVideoSource> newSource =
119135:       new MediaEngineDefaultVideoSource();
119135:     mVSources.AppendElement(newSource);
119135:     aVSources->AppendElement(newSource);
119135:   }
104324:   return;
104324: }
104324: 
104324: void
104324: MediaEngineDefault::EnumerateAudioDevices(nsTArray<nsRefPtr<MediaEngineAudioSource> >* aASources) {
119499:   MutexAutoLock lock(mMutex);
119499:   int32_t len = mASources.Length();
119499: 
119135:   for (int32_t i = 0; i < len; i++) {
119135:     nsRefPtr<MediaEngineAudioSource> source = mASources.ElementAt(i);
119135:     if (source->IsAvailable()) {
119135:       aASources->AppendElement(source);
119135:     }
119135:   }
119135: 
119135:   // All streams are currently busy, just make a new one.
119135:   if (aASources->Length() == 0) {
119135:     nsRefPtr<MediaEngineAudioSource> newSource =
119135:       new MediaEngineDefaultAudioSource();
119135:     mASources.AppendElement(newSource);
119135:     aASources->AppendElement(newSource);
119135:   }
104324:   return;
104324: }
104324: 
104324: } // namespace mozilla
