    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.org.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corp.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Daniel Glazman (glazman@netscape.com) (Original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include <math.h>
    1: 
    1: #include "nsHTMLEditor.h"
    1: 
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsIEditor.h"
    1: #include "nsIPresShell.h"
    1: 
    1: #include "nsISelection.h"
    1: 
    1: #include "nsTextEditUtils.h"
    1: #include "nsEditorUtils.h"
    1: #include "nsHTMLEditUtils.h"
    1: #include "nsTextEditRules.h"
    1: #include "nsIHTMLEditRules.h"
    1: 
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMNSHTMLElement.h"
    1: #include "nsIDOMNodeList.h"
    1: 
    1: #include "nsIDOMEventTarget.h"
    1: 
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIServiceManager.h"
    1: 
    1: #include "nsIDOMCSSValue.h"
    1: #include "nsIDOMCSSPrimitiveValue.h"
    1: #include "nsIDOMRGBColor.h"
    1: 
    1: #define  BLACK_BG_RGB_TRIGGER 0xd0
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::AbsolutePositionSelection(PRBool aEnabled)
    1: {
    1:   nsAutoEditBatch beginBatching(this);
    1:   nsAutoRules beginRulesSniffing(this,
    1:                                  aEnabled ? kOpSetAbsolutePosition :
    1:                                             kOpRemoveAbsolutePosition,
    1:                                  nsIEditor::eNext);
    1:   
    1:   // the line below does not match the code; should it be removed?
    1:   // Find out if the selection is collapsed:
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsTextRulesInfo ruleInfo(aEnabled ?
    1:                            nsTextEditRules::kSetAbsolutePosition :
    1:                            nsTextEditRules::kRemoveAbsolutePosition);
    1:   PRBool cancel, handled;
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
    1:   if (NS_FAILED(res) || cancel)
    1:     return res;
    1:   
    1:   return mRules->DidDoAction(selection, &ruleInfo, res);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetAbsolutelyPositionedSelectionContainer(nsIDOMElement **_retval)
    1: {
    1:   nsCOMPtr<nsIDOMElement> element;
    1:   nsresult res = GetSelectionContainer(getter_AddRefs(element));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   nsAutoString positionStr;
    1:   nsCOMPtr<nsIDOMNode> node = do_QueryInterface(element);
    1:   nsCOMPtr<nsIDOMNode> resultNode;
    1: 
47371:   while (!resultNode && node && !nsEditor::NodeIsType(node, nsEditProperty::html)) {
    1:     res = mHTMLCSSUtils->GetComputedProperty(node, nsEditProperty::cssPosition,
    1:                                              positionStr);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (positionStr.EqualsLiteral("absolute"))
    1:       resultNode = node;
    1:     else {
    1:       nsCOMPtr<nsIDOMNode> parentNode;
    1:       res = node->GetParentNode(getter_AddRefs(parentNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       node.swap(parentNode);
    1:     }
10522:   }
    1: 
    1:   element = do_QueryInterface(resultNode ); 
    1:   *_retval = element;
    1:   NS_IF_ADDREF(*_retval);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetSelectionContainerAbsolutelyPositioned(PRBool *aIsSelectionContainerAbsolutelyPositioned)
    1: {
    1:   *aIsSelectionContainerAbsolutelyPositioned = (mAbsolutelyPositionedObject != nsnull);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetAbsolutePositioningEnabled(PRBool * aIsEnabled)
    1: {
    1:   *aIsEnabled = mIsAbsolutelyPositioningEnabled;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::SetAbsolutePositioningEnabled(PRBool aIsEnabled)
    1: {
    1:   mIsAbsolutelyPositioningEnabled = aIsEnabled;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::RelativeChangeElementZIndex(nsIDOMElement * aElement,
    1:                                           PRInt32 aChange,
    1:                                           PRInt32 * aReturn)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aElement);
    1:   NS_ENSURE_ARG_POINTER(aReturn);
    1:   if (!aChange) // early way out, no change
    1:     return NS_OK;
    1: 
    1:   PRInt32 zIndex;
    1:   nsresult res = GetElementZIndex(aElement, &zIndex);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
38053:   zIndex = NS_MAX(zIndex + aChange, 0);
    1:   SetElementZIndex(aElement, zIndex);
    1:   *aReturn = zIndex;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::SetElementZIndex(nsIDOMElement * aElement,
    1:                                PRInt32 aZindex)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aElement);
    1:   
    1:   nsAutoString zIndexStr;
    1:   zIndexStr.AppendInt(aZindex);
    1: 
    1:   mHTMLCSSUtils->SetCSSProperty(aElement,
    1:                                 nsEditProperty::cssZIndex,
    1:                                 zIndexStr,
    1:                                 PR_FALSE);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::RelativeChangeZIndex(PRInt32 aChange)
    1: {
    1:   nsAutoEditBatch beginBatching(this);
    1:   nsAutoRules beginRulesSniffing(this,
    1:                                  (aChange < 0) ? kOpDecreaseZIndex :
    1:                                                  kOpIncreaseZIndex,
    1:                                  nsIEditor::eNext);
    1:   
    1:   // brade: can we get rid of this comment?
    1:   // Find out if the selection is collapsed:
    1:   nsCOMPtr<nsISelection> selection;
    1:   nsresult res = GetSelection(getter_AddRefs(selection));
43805:   NS_ENSURE_SUCCESS(res, res);
43806:   NS_ENSURE_TRUE(selection, NS_ERROR_NULL_POINTER);
    1:   nsTextRulesInfo ruleInfo((aChange < 0) ? nsTextEditRules::kDecreaseZIndex:
    1:                                            nsTextEditRules::kIncreaseZIndex);
    1:   PRBool cancel, handled;
    1:   res = mRules->WillDoAction(selection, &ruleInfo, &cancel, &handled);
    1:   if (cancel || NS_FAILED(res))
    1:     return res;
    1:   
    1:   return mRules->DidDoAction(selection, &ruleInfo, res);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetElementZIndex(nsIDOMElement * aElement,
    1:                                PRInt32 * aZindex)
    1: {
    1:   nsAutoString zIndexStr;
    1:   *aZindex = 0;
    1: 
    1:   nsresult res = mHTMLCSSUtils->GetSpecifiedProperty(aElement,
    1:                                                      nsEditProperty::cssZIndex,
    1:                                                      zIndexStr);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (zIndexStr.EqualsLiteral("auto")) {
    1:     // we have to look at the positioned ancestors
    1:     // cf. CSS 2 spec section 9.9.1
    1:     nsCOMPtr<nsIDOMNode> parentNode;
    1:     res = aElement->GetParentNode(getter_AddRefs(parentNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     nsCOMPtr<nsIDOMNode> node = parentNode;
    1:     nsAutoString positionStr;
    1:     while (node && 
    1:            zIndexStr.EqualsLiteral("auto") &&
    1:            !nsTextEditUtils::IsBody(node)) {
    1:       res = mHTMLCSSUtils->GetComputedProperty(node,
    1:                                                nsEditProperty::cssPosition,
    1:                                                positionStr);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (positionStr.EqualsLiteral("absolute")) {
    1:         // ah, we found one, what's its z-index ? If its z-index is auto,
    1:         // we have to continue climbing the document's tree
    1:         res = mHTMLCSSUtils->GetComputedProperty(node,
    1:                                                  nsEditProperty::cssZIndex,
    1:                                                  zIndexStr);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:       }
    1:       res = node->GetParentNode(getter_AddRefs(parentNode));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       node = parentNode;
    1:     }
    1:   }
    1: 
    1:   if (!zIndexStr.EqualsLiteral("auto")) {
    1:     PRInt32 errorCode;
    1:     *aZindex = zIndexStr.ToInteger(&errorCode);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::CreateGrabber(nsIDOMNode * aParentNode, nsIDOMElement ** aReturn)
    1: {
    1:   // let's create a grabber through the element factory
    1:   nsresult res = CreateAnonymousElement(NS_LITERAL_STRING("span"),
    1:                                         aParentNode,
    1:                                         NS_LITERAL_STRING("mozGrabber"),
    1:                                         PR_FALSE,
    1:                                         aReturn);
    1: 
43807:   NS_ENSURE_TRUE(*aReturn, NS_ERROR_FAILURE);
    1: 
    1:   // add the mouse listener so we can detect a click on a resizer
    1:   nsCOMPtr<nsIDOMEventTarget> evtTarget(do_QueryInterface(*aReturn));
39014:   evtTarget->AddEventListener(NS_LITERAL_STRING("mousedown"),
39014:                               mEventListener, PR_FALSE);
    1: 
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::RefreshGrabber()
    1: {
    1:   NS_ENSURE_TRUE(mAbsolutelyPositionedObject, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsresult res = GetPositionAndDimensions(mAbsolutelyPositionedObject,
    1:                                          mPositionedObjectX,
    1:                                          mPositionedObjectY,
    1:                                          mPositionedObjectWidth,
    1:                                          mPositionedObjectHeight,
    1:                                          mPositionedObjectBorderLeft,
    1:                                          mPositionedObjectBorderTop,
    1:                                          mPositionedObjectMarginLeft,
    1:                                          mPositionedObjectMarginTop);
    1: 
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   SetAnonymousElementPosition(mPositionedObjectX+12,
    1:                               mPositionedObjectY-14,
    1:                               mGrabber);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::HideGrabber()
    1: {
    1:   nsresult res =
    1:     mAbsolutelyPositionedObject->RemoveAttribute(NS_LITERAL_STRING("_moz_abspos"));
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   mAbsolutelyPositionedObject = nsnull;
    1:   NS_ENSURE_TRUE(mGrabber, NS_ERROR_NULL_POINTER);
    1: 
    1:   // get the presshell's document observer interface.
63587:   nsCOMPtr<nsIPresShell> ps;
63587:   GetPresShell(getter_AddRefs(ps));
41949:   // We allow the pres shell to be null; when it is, we presume there
41949:   // are no document observers to notify, but we still want to
41949:   // UnbindFromTree.
    1: 
10522:   nsCOMPtr<nsIDOMNode> parentNode;
10522:   res = mGrabber->GetParentNode(getter_AddRefs(parentNode));
10522:   NS_ENSURE_SUCCESS(res, res);
    1: 
10522:   nsCOMPtr<nsIContent> parentContent = do_QueryInterface(parentNode);
43806:   NS_ENSURE_TRUE(parentContent, NS_ERROR_NULL_POINTER);
    1: 
10522:   DeleteRefToAnonymousNode(mGrabber, parentContent, ps);
    1:   mGrabber = nsnull;
10522:   DeleteRefToAnonymousNode(mPositioningShadow, parentContent, ps);
    1:   mPositioningShadow = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::ShowGrabberOnElement(nsIDOMElement * aElement)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aElement);
    1: 
14277:   if (mGrabber) {
14277:     NS_ERROR("call HideGrabber first");
14277:     return NS_ERROR_UNEXPECTED;
14277:   }
14277: 
    1:   nsAutoString classValue;
    1:   nsresult res = CheckPositionedElementBGandFG(aElement, classValue);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   res = aElement->SetAttribute(NS_LITERAL_STRING("_moz_abspos"),
    1:                                classValue);
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // first, let's keep track of that element...
    1:   mAbsolutelyPositionedObject = aElement;
    1: 
10522:   nsCOMPtr<nsIDOMNode> parentNode;
10522:   res = aElement->GetParentNode(getter_AddRefs(parentNode));
10522:   NS_ENSURE_SUCCESS(res, res);
    1: 
10522:   res = CreateGrabber(parentNode, getter_AddRefs(mGrabber));
10522:   NS_ENSURE_SUCCESS(res, res);
10522: 
    1:   // and set its position
    1:   return RefreshGrabber();
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::StartMoving(nsIDOMElement *aHandle)
    1: {
10522:   nsCOMPtr<nsIDOMNode> parentNode;
10522:   nsresult res = mGrabber->GetParentNode(getter_AddRefs(parentNode));
10522:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // now, let's create the resizing shadow
10522:   res = CreateShadow(getter_AddRefs(mPositioningShadow),
10522:                                  parentNode, mAbsolutelyPositionedObject);
10522:   NS_ENSURE_SUCCESS(res,res);
10522:   res = SetShadowPosition(mPositioningShadow, mAbsolutelyPositionedObject,
    1:                              mPositionedObjectX, mPositionedObjectY);
10522:   NS_ENSURE_SUCCESS(res,res);
    1: 
    1:   // make the shadow appear
    1:   mPositioningShadow->RemoveAttribute(NS_LITERAL_STRING("class"));
    1: 
    1:   // position it
    1:   mHTMLCSSUtils->SetCSSPropertyPixels(mPositioningShadow,
    1:                                       NS_LITERAL_STRING("width"),
    1:                                       mPositionedObjectWidth);
    1:   mHTMLCSSUtils->SetCSSPropertyPixels(mPositioningShadow,
    1:                                       NS_LITERAL_STRING("height"),
    1:                                       mPositionedObjectHeight);
    1: 
    1:   mIsMoving = PR_TRUE;
10522:   return res;
    1: }
    1: 
    1: void
    1: nsHTMLEditor::SnapToGrid(PRInt32 & newX, PRInt32 & newY)
    1: {
    1:   if (mSnapToGridEnabled && mGridSize) {
    1:     newX = (PRInt32) floor( ((float)newX / (float)mGridSize) + 0.5f ) * mGridSize;
    1:     newY = (PRInt32) floor( ((float)newY / (float)mGridSize) + 0.5f ) * mGridSize;
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::GrabberClicked()
    1: {
    1:   // add a mouse move listener to the editor
    1:   nsresult res = NS_OK;
    1:   if (!mMouseMotionListenerP) {
    1:     mMouseMotionListenerP = new ResizerMouseMotionListener(this);
    1:     if (!mMouseMotionListenerP) {return NS_ERROR_NULL_POINTER;}
    1: 
 1418:     nsCOMPtr<nsPIDOMEventTarget> piTarget = GetPIDOMEventTarget();
 1418:     NS_ENSURE_TRUE(piTarget, NS_ERROR_FAILURE);
    1: 
 1418:     res = piTarget->AddEventListenerByIID(mMouseMotionListenerP,
    1:                                           NS_GET_IID(nsIDOMMouseMotionListener));
    1:     NS_ASSERTION(NS_SUCCEEDED(res),
    1:                  "failed to register mouse motion listener");
    1:   }
    1:   mGrabberClicked = PR_TRUE;
    1:   return res;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::EndMoving()
    1: {
    1:   if (mPositioningShadow) {
63587:     nsCOMPtr<nsIPresShell> ps;
63587:     GetPresShell(getter_AddRefs(ps));
43806:     NS_ENSURE_TRUE(ps, NS_ERROR_NOT_INITIALIZED);
    1: 
10522:     nsCOMPtr<nsIDOMNode> parentNode;
10522:     nsresult res = mGrabber->GetParentNode(getter_AddRefs(parentNode));
10522:     NS_ENSURE_SUCCESS(res, res);
    1: 
10522:     nsCOMPtr<nsIContent> parentContent( do_QueryInterface(parentNode) );
43806:     NS_ENSURE_TRUE(parentContent, NS_ERROR_FAILURE);
    1: 
10522:     DeleteRefToAnonymousNode(mPositioningShadow, parentContent, ps);
    1: 
    1:     mPositioningShadow = nsnull;
    1:   }
 1418:   nsCOMPtr<nsPIDOMEventTarget> piTarget = GetPIDOMEventTarget();
    1: 
 1418:   if (piTarget && mMouseMotionListenerP) {
    1: #ifdef DEBUG
    1:     nsresult res =
    1: #endif
 1418:     piTarget->RemoveEventListenerByIID(mMouseMotionListenerP,
 1418:                                        NS_GET_IID(nsIDOMMouseMotionListener));
    1:     NS_ASSERTION(NS_SUCCEEDED(res), "failed to remove mouse motion listener");
    1:   }
    1:   mMouseMotionListenerP = nsnull;
    1: 
 2386:   mGrabberClicked = PR_FALSE;
 2386:   mIsMoving = PR_FALSE;
 2386:   nsCOMPtr<nsISelection> selection;
 2386:   GetSelection(getter_AddRefs(selection));
 2386:   if (!selection) {
 2386:     return NS_ERROR_NOT_INITIALIZED;
 2386:   }
 2386:   return CheckSelectionStateForAnonymousButtons(selection);
    1: }
    1: nsresult
    1: nsHTMLEditor::SetFinalPosition(PRInt32 aX, PRInt32 aY)
    1: {
    1:   nsresult res = EndMoving();
43805:   NS_ENSURE_SUCCESS(res, res);
    1: 
    1:   // we have now to set the new width and height of the resized object
    1:   // we don't set the x and y position because we don't control that in
    1:   // a normal HTML layout
    1:   PRInt32 newX = mPositionedObjectX + aX - mOriginalX - (mPositionedObjectBorderLeft+mPositionedObjectMarginLeft);
    1:   PRInt32 newY = mPositionedObjectY + aY - mOriginalY - (mPositionedObjectBorderTop+mPositionedObjectMarginTop);
    1: 
    1:   SnapToGrid(newX, newY);
    1: 
    1:   nsAutoString x, y;
    1:   x.AppendInt(newX);
    1:   y.AppendInt(newY);
    1: 
    1:   // we want one transaction only from a user's point of view
    1:   nsAutoEditBatch batchIt(this);
    1: 
    1:   mHTMLCSSUtils->SetCSSPropertyPixels(mAbsolutelyPositionedObject,
    1:                                       nsEditProperty::cssTop,
    1:                                       newY,
    1:                                       PR_FALSE);
    1:   mHTMLCSSUtils->SetCSSPropertyPixels(mAbsolutelyPositionedObject,
    1:                                       nsEditProperty::cssLeft,
    1:                                       newX,
    1:                                       PR_FALSE);
    1:   // keep track of that size
    1:   mPositionedObjectX  = newX;
    1:   mPositionedObjectY  = newY;
    1: 
    1:   return RefreshResizers();
    1: }
    1: 
    1: void
42606: nsHTMLEditor::AddPositioningOffset(PRInt32 & aX, PRInt32 & aY)
    1: {
    1:   // Get the positioning offset
    1:   nsresult res;
    1:   nsCOMPtr<nsIPrefBranch> prefBranch =
    1:     do_GetService(NS_PREFSERVICE_CONTRACTID, &res);
    1:   PRInt32 positioningOffset = 0;
    1:   if (NS_SUCCEEDED(res) && prefBranch) {
    1:     res = prefBranch->GetIntPref("editor.positioning.offset", &positioningOffset);
    1:     if (NS_FAILED(res)) // paranoia
    1:       positioningOffset = 0;
    1:   }
    1: 
    1:   aX += positioningOffset;
    1:   aY += positioningOffset;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::AbsolutelyPositionElement(nsIDOMElement * aElement,
    1:                                         PRBool aEnabled)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aElement);
    1: 
    1:   nsAutoString positionStr;
    1:   mHTMLCSSUtils->GetComputedProperty(aElement, nsEditProperty::cssPosition,
    1:                                      positionStr);
    1:   PRBool isPositioned = (positionStr.EqualsLiteral("absolute"));
    1: 
    1:   // nothing to do if the element is already in the state we want
    1:   if (isPositioned == aEnabled)
    1:     return NS_OK;
    1: 
    1:   nsAutoEditBatch batchIt(this);
    1:   nsresult res;
    1: 
    1:   if (aEnabled) {
    1:     PRInt32 x, y;
    1:     GetElementOrigin(aElement, x, y);
    1: 
    1:     mHTMLCSSUtils->SetCSSProperty(aElement,
    1:                                   nsEditProperty::cssPosition,
    1:                                   NS_LITERAL_STRING("absolute"),
    1:                                   PR_FALSE);
    1: 
42606:     AddPositioningOffset(x, y);
    1:     SnapToGrid(x, y);
    1:     SetElementPosition(aElement, x, y);
    1: 
    1:     // we may need to create a br if the positioned element is alone in its
    1:     // container
    1:     nsCOMPtr<nsIDOMNode> parentNode;
    1:     res = aElement->GetParentNode(getter_AddRefs(parentNode));
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     nsCOMPtr<nsIDOMNodeList> childNodes;
    1:     res = parentNode->GetChildNodes(getter_AddRefs(childNodes));
43805:     NS_ENSURE_SUCCESS(res, res);
43806:     NS_ENSURE_TRUE(childNodes, NS_ERROR_NULL_POINTER);
    1:     PRUint32 childCount;
    1:     res = childNodes->GetLength(&childCount);
43805:     NS_ENSURE_SUCCESS(res, res);
    1: 
    1:     if (childCount == 1) {
    1:       nsCOMPtr<nsIDOMNode> brNode;
    1:       res = CreateBR(parentNode, 0, address_of(brNode));
    1:     }
    1:   }
    1:   else {
    1:     mHTMLCSSUtils->RemoveCSSProperty(aElement,
    1:                                      nsEditProperty::cssPosition,
    1:                                      EmptyString(), PR_FALSE);
    1:     mHTMLCSSUtils->RemoveCSSProperty(aElement,
    1:                                      nsEditProperty::cssTop,
    1:                                      EmptyString(), PR_FALSE);
    1:     mHTMLCSSUtils->RemoveCSSProperty(aElement,
    1:                                      nsEditProperty::cssLeft,
    1:                                      EmptyString(), PR_FALSE);
    1:     mHTMLCSSUtils->RemoveCSSProperty(aElement,
    1:                                      nsEditProperty::cssZIndex,
    1:                                      EmptyString(), PR_FALSE);
    1: 
    1:     if (!nsHTMLEditUtils::IsImage(aElement)) {
    1:       mHTMLCSSUtils->RemoveCSSProperty(aElement,
    1:                                        nsEditProperty::cssWidth,
    1:                                        EmptyString(), PR_FALSE);
    1:       mHTMLCSSUtils->RemoveCSSProperty(aElement,
    1:                                        nsEditProperty::cssHeight,
    1:                                        EmptyString(), PR_FALSE);
    1:     }
    1: 
    1:     PRBool hasStyleOrIdOrClass;
    1:     res = HasStyleOrIdOrClass(aElement, &hasStyleOrIdOrClass);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (!hasStyleOrIdOrClass && nsHTMLEditUtils::IsDiv(aElement)) {
    1:       nsCOMPtr<nsIHTMLEditRules> htmlRules = do_QueryInterface(mRules);
43806:       NS_ENSURE_TRUE(htmlRules, NS_ERROR_FAILURE);
    1:       res = htmlRules->MakeSureElemStartsOrEndsOnCR(aElement);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       res = RemoveContainer(aElement);
    1:     }
    1:   }
    1:   return res;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::SetSnapToGridEnabled(PRBool aEnabled)
    1: {
    1:   mSnapToGridEnabled = aEnabled;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetSnapToGridEnabled(PRBool * aIsEnabled)
    1: {
    1:   *aIsEnabled = mSnapToGridEnabled;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::SetGridSize(PRUint32 aSize)
    1: {
    1:   mGridSize = aSize;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetGridSize(PRUint32 * aSize)
    1: {
    1:   *aSize = mGridSize;
    1:   return NS_OK;
    1: }
    1: 
    1: // self-explanatory
    1: NS_IMETHODIMP
    1: nsHTMLEditor::SetElementPosition(nsIDOMElement *aElement, PRInt32 aX, PRInt32 aY)
    1: {
    1:   nsAutoEditBatch batchIt(this);
    1: 
    1:   mHTMLCSSUtils->SetCSSPropertyPixels(aElement,
    1:                                       nsEditProperty::cssLeft,
    1:                                       aX,
    1:                                       PR_FALSE);
    1:   mHTMLCSSUtils->SetCSSPropertyPixels(aElement,
    1:                                       nsEditProperty::cssTop,
    1:                                       aY,
    1:                                       PR_FALSE);
    1:   return NS_OK;
    1: }
    1: 
    1: // self-explanatory
    1: NS_IMETHODIMP
    1: nsHTMLEditor::GetPositionedElement(nsIDOMElement ** aReturn)
    1: {
    1:   *aReturn = mAbsolutelyPositionedObject;
    1:   NS_IF_ADDREF(*aReturn);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsHTMLEditor::CheckPositionedElementBGandFG(nsIDOMElement * aElement,
    1:                                             nsAString & aReturn)
    1: {
    1:   // we are going to outline the positioned element and bring it to the
    1:   // front to overlap any other element intersecting with it. But
    1:   // first, let's see what's the background and foreground colors of the
    1:   // positioned element.
    1:   // if background-image computed value is 'none,
    1:   //   If the background color is 'auto' and R G B values of the foreground are
    1:   //       each above #d0, use a black background
    1:   //   If the background color is 'auto' and at least one of R G B values of
    1:   //       the foreground is below #d0, use a white background
    1:   // Otherwise don't change background/foreground
    1: 
    1:   aReturn.Truncate();
    1:   
    1:   nsAutoString bgImageStr;
    1:   nsresult res =
    1:     mHTMLCSSUtils->GetComputedProperty(aElement,
    1:                                        nsEditProperty::cssBackgroundImage,
    1:                                        bgImageStr);
43805:   NS_ENSURE_SUCCESS(res, res);
    1:   if (bgImageStr.EqualsLiteral("none")) {
    1:     nsAutoString bgColorStr;
    1:     res =
    1:       mHTMLCSSUtils->GetComputedProperty(aElement,
    1:                                          nsEditProperty::cssBackgroundColor,
    1:                                          bgColorStr);
43805:     NS_ENSURE_SUCCESS(res, res);
    1:     if (bgColorStr.EqualsLiteral("transparent")) {
68870: 
68870:       nsCOMPtr<nsIDOMViewCSS> viewCSS;
68870:       res = mHTMLCSSUtils->GetDefaultViewCSS(aElement, getter_AddRefs(viewCSS));
68835:       NS_ENSURE_SUCCESS(res, res);
68835:       nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl;
68870:       res = viewCSS->GetComputedStyle(aElement, EmptyString(), getter_AddRefs(cssDecl));
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       // from these declarations, get the one we want and that one only
    1:       nsCOMPtr<nsIDOMCSSValue> colorCssValue;
    1:       res = cssDecl->GetPropertyCSSValue(NS_LITERAL_STRING("color"), getter_AddRefs(colorCssValue));
43805:       NS_ENSURE_SUCCESS(res, res);
    1: 
    1:       PRUint16 type;
    1:       res = colorCssValue->GetCssValueType(&type);
43805:       NS_ENSURE_SUCCESS(res, res);
    1:       if (nsIDOMCSSValue::CSS_PRIMITIVE_VALUE == type) {
    1:         nsCOMPtr<nsIDOMCSSPrimitiveValue> val = do_QueryInterface(colorCssValue);
    1:         res = val->GetPrimitiveType(&type);
43805:         NS_ENSURE_SUCCESS(res, res);
    1:         if (nsIDOMCSSPrimitiveValue::CSS_RGBCOLOR == type) {
    1:           nsCOMPtr<nsIDOMRGBColor> rgbColor;
    1:           res = val->GetRGBColorValue(getter_AddRefs(rgbColor));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           nsCOMPtr<nsIDOMCSSPrimitiveValue> red, green, blue;
    1:           float r, g, b;
    1:           res = rgbColor->GetRed(getter_AddRefs(red));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = rgbColor->GetGreen(getter_AddRefs(green));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = rgbColor->GetBlue(getter_AddRefs(blue));
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = red->GetFloatValue(nsIDOMCSSPrimitiveValue::CSS_NUMBER, &r);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = green->GetFloatValue(nsIDOMCSSPrimitiveValue::CSS_NUMBER, &g);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           res = blue->GetFloatValue(nsIDOMCSSPrimitiveValue::CSS_NUMBER, &b);
43805:           NS_ENSURE_SUCCESS(res, res);
    1:           if (r >= BLACK_BG_RGB_TRIGGER &&
    1:               g >= BLACK_BG_RGB_TRIGGER &&
    1:               b >= BLACK_BG_RGB_TRIGGER)
    1:             aReturn.AssignLiteral("black");
    1:           else
    1:             aReturn.AssignLiteral("white");
    1:           return NS_OK;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
