    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Robert O'Callahan <roc@ocallahan.org>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object for css3 multi-column layout */
    1: 
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsIContent.h"
    1: #include "nsIFrame.h"
    1: #include "nsISupports.h"
    1: #include "nsIAtom.h"
    1: #include "nsPresContext.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsCOMPtr.h"
 9811: #include "nsLayoutUtils.h"
16055: #include "nsDisplayList.h"
16055: #include "nsCSSRendering.h"
    1: 
    1: class nsColumnSetFrame : public nsHTMLContainerFrame {
    1: public:
    1:   nsColumnSetFrame(nsStyleContext* aContext);
    1: 
    1:   NS_IMETHOD SetInitialChildList(nsIAtom*        aListName,
    1:                                  nsIFrame*       aChildList);
    1: 
    1:   NS_IMETHOD Reflow(nsPresContext* aPresContext,
    1:                     nsHTMLReflowMetrics& aDesiredSize,
    1:                     const nsHTMLReflowState& aReflowState,
    1:                     nsReflowStatus& aStatus);
    1:                                
    1:   NS_IMETHOD  AppendFrames(nsIAtom*        aListName,
    1:                            nsIFrame*       aFrameList);
    1:   NS_IMETHOD  InsertFrames(nsIAtom*        aListName,
    1:                            nsIFrame*       aPrevFrame,
    1:                            nsIFrame*       aFrameList);
    1:   NS_IMETHOD  RemoveFrame(nsIAtom*        aListName,
    1:                           nsIFrame*       aOldFrame);
    1: 
 3696:   virtual nscoord GetMinWidth(nsIRenderingContext *aRenderingContext);  
 3696:   virtual nscoord GetPrefWidth(nsIRenderingContext *aRenderingContext);
    1: 
    1:   virtual nsIFrame* GetContentInsertionFrame() {
12165:     nsIFrame* frame = GetFirstChild(nsnull);
12165: 
12165:     // if no children return nsnull
12165:     if (!frame)
12165:       return nsnull;
12165: 
12165:     return frame->GetContentInsertionFrame();
    1:   }
    1: 
 4006:   virtual nsresult StealFrame(nsPresContext* aPresContext,
 4006:                               nsIFrame*      aChild,
 4006:                               PRBool         aForceNormal)
 4006:   { // nsColumnSetFrame keeps overflow containers in main child list
 4006:     return nsContainerFrame::StealFrame(aPresContext, aChild, PR_TRUE);
 4006:   }
 4006: 
    1:   NS_IMETHOD BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                               const nsRect&           aDirtyRect,
    1:                               const nsDisplayListSet& aLists);
    1: 
    1:   virtual nsIAtom* GetType() const;
    1: 
16055:   virtual void PaintColumnRule(nsIRenderingContext* aCtx,
16055:                                const nsRect&        aDirtyRect,
16055:                                const nsPoint&       aPt);
16055: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const {
    1:     return MakeFrameName(NS_LITERAL_STRING("ColumnSet"), aResult);
    1:   }
    1: #endif
    1: 
    1: protected:
    1:   nscoord        mLastBalanceHeight;
    1:   nsReflowStatus mLastFrameStatus;
    1: 
    1:   virtual PRIntn GetSkipSides() const;
    1: 
    1:   /**
    1:    * These are the parameters that control the layout of columns.
    1:    */
    1:   struct ReflowConfig {
    1:     PRInt32 mBalanceColCount;
    1:     nscoord mColWidth;
    1:     nscoord mExpectedWidthLeftOver;
    1:     nscoord mColGap;
    1:     nscoord mColMaxHeight;
    1:   };
    1: 
    1:   /**
14460:    * Some data that is better calculated during reflow
14460:    */
14460:   struct ColumnBalanceData {
21324:     // The maximum "content height" of any column
14460:     nscoord mMaxHeight;
21324:     // The sum of the "content heights" for all columns
14460:     nscoord mSumHeight;
21324:     // The "content height" of the last column
14460:     nscoord mLastHeight;
21324:     // The maximum "content height" of all columns that overflowed
21324:     // their available height
21324:     nscoord mMaxOverflowingHeight;
14460:     void Reset() {
21324:       mMaxHeight = mSumHeight = mLastHeight = mMaxOverflowingHeight = 0;
14460:     }
14460:   };
14460:   
14460:   /**
    1:    * Similar to nsBlockFrame::DrainOverflowLines. Locate any columns not
    1:    * handled by our prev-in-flow, and any columns sitting on our own
    1:    * overflow list, and put them in our primary child list for reflowing.
    1:    */
    1:   void DrainOverflowColumns();
    1: 
    1:   /**
    1:    * The basic reflow strategy is to call this function repeatedly to
    1:    * obtain specific parameters that determine the layout of the
    1:    * columns. This function will compute those parameters from the CSS
    1:    * style. This function will also be responsible for implementing
    1:    * the state machine that controls column balancing.
    1:    */
    1:   ReflowConfig ChooseColumnStrategy(const nsHTMLReflowState& aReflowState);
    1: 
    1:   /**
    1:    * Reflow column children. Returns PR_TRUE iff the content that was reflowed 
    1:    * fit into the mColMaxHeight.
    1:    */
    1:   PRBool ReflowChildren(nsHTMLReflowMetrics& aDesiredSize,
    1:                         const nsHTMLReflowState& aReflowState,
    1:                         nsReflowStatus& aStatus,
    1:                         const ReflowConfig& aConfig,
    1:                         PRBool aLastColumnUnbounded,
14460:                         nsCollapsingMargin* aCarriedOutBottomMargin,
14460:                         ColumnBalanceData& aColData);
    1: };
    1: 
    1: /**
    1:  * Tracking issues:
    1:  *
    1:  * XXX cursor movement around the top and bottom of colums seems to make the editor
    1:  * lose the caret.
    1:  *
    1:  * XXX should we support CSS columns applied to table elements?
    1:  */
    1: nsIFrame*
    1: NS_NewColumnSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aStateFlags)
    1: {
    1:   nsColumnSetFrame* it = new (aPresShell) nsColumnSetFrame(aContext);
    1:   if (it) {
    1:     // set the state flags (if any are provided)
    1:     it->AddStateBits(aStateFlags);
    1:   }
    1: 
    1:   return it;
    1: }
    1: 
    1: nsColumnSetFrame::nsColumnSetFrame(nsStyleContext* aContext)
    1:   : nsHTMLContainerFrame(aContext), mLastBalanceHeight(NS_INTRINSICSIZE),
    1:     mLastFrameStatus(NS_FRAME_COMPLETE)
    1: {
    1: }
    1: 
    1: nsIAtom*
    1: nsColumnSetFrame::GetType() const
    1: {
    1:   return nsGkAtoms::columnSetFrame;
    1: }
    1: 
16055: static void
16055: PaintColumnRule(nsIFrame* aFrame, nsIRenderingContext* aCtx,
16055:                 const nsRect& aDirtyRect, nsPoint aPt)
16055: {
16055:   static_cast<nsColumnSetFrame*>(aFrame)->PaintColumnRule(aCtx, aDirtyRect, aPt);
16055: }
16055: 
16055: void
16055: nsColumnSetFrame::PaintColumnRule(nsIRenderingContext* aCtx,
16055:                                   const nsRect& aDirtyRect,
16055:                                   const nsPoint& aPt)
16055: {
16055:   nsIFrame* child = mFrames.FirstChild();
16055:   if (!child)
16055:     return;  // no columns
16055: 
16055:   nsIFrame* nextSibling = child->GetNextSibling();
16055:   if (!nextSibling)
16055:     return;  // 1 column only - this means no gap to draw on
16055: 
16055:   PRBool isRTL = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
16055:   const nsStyleColumn* colStyle = GetStyleColumn();
16055: 
16055:   PRUint8 ruleStyle;
16055:   // Per spec, inset => ridge and outset => groove
16055:   if (colStyle->mColumnRuleStyle == NS_STYLE_BORDER_STYLE_INSET)
16055:     ruleStyle = NS_STYLE_BORDER_STYLE_RIDGE;
16055:   else if (colStyle->mColumnRuleStyle == NS_STYLE_BORDER_STYLE_OUTSET)
16055:     ruleStyle = NS_STYLE_BORDER_STYLE_GROOVE;
16055:   else
16055:     ruleStyle = colStyle->mColumnRuleStyle;
16055: 
16055:   nsPresContext* presContext = PresContext();
16055:   nscoord ruleWidth = colStyle->GetComputedColumnRuleWidth();
16055:   if (!ruleWidth)
16055:     return;
16055: 
16055:   nscolor ruleColor;
16055:   if (colStyle->mColumnRuleColorIsForeground)
16055:     ruleColor = GetStyleColor()->mColor;
16055:   else
16055:     ruleColor = colStyle->mColumnRuleColor;
16055: 
16055:   // In order to re-use a large amount of code, we treat the column rule as a border.
16055:   // We create a new border style object and fill in all the details of the column rule as
16055:   // the left border. PaintBorder() does all the rendering for us, so we not
16055:   // only save an enormous amount of code but we'll support all the line styles that
16055:   // we support on borders!
16055:   nsStyleBorder border(presContext);
16055:   border.SetBorderWidth(NS_SIDE_LEFT, ruleWidth);
16055:   border.SetBorderStyle(NS_SIDE_LEFT, ruleStyle);
16055:   border.SetBorderColor(NS_SIDE_LEFT, ruleColor);
16055: 
16111:   // Get our content rect as an absolute coordinate, not relative to
16111:   // our parent (which is what the X and Y normally is)
16111:   nsRect contentRect = GetContentRect() - GetRect().TopLeft() + aPt;
16111:   nsSize ruleSize(ruleWidth, contentRect.height);
16111: 
16055:   while (nextSibling) {
16055:     // The frame tree goes RTL in RTL
16055:     nsIFrame* leftSibling = isRTL ? nextSibling : child;
16055:     nsIFrame* rightSibling = isRTL ? child : nextSibling;
16055: 
16055:     // Each child frame's position coordinates is actually relative to this nsColumnSetFrame.
16055:     // linePt will be at the top-left edge to paint the line.
16055:     nsPoint edgeOfLeftSibling = leftSibling->GetRect().TopRight() + aPt;
16055:     nsPoint edgeOfRightSibling = rightSibling->GetRect().TopLeft() + aPt;
16055:     nsPoint linePt((edgeOfLeftSibling.x + edgeOfRightSibling.x - ruleWidth) / 2,
16111:                    contentRect.y);
16055: 
16111:     nsRect lineRect(linePt, ruleSize);
16055:     nsCSSRendering::PaintBorder(presContext, *aCtx, this, aDirtyRect,
16055:                                 lineRect, border, GetStyleContext(),
16055:                                 // Remember, we only have the "left" "border". Skip everything else
16055:                                 (1 << NS_SIDE_TOP | 1 << NS_SIDE_RIGHT | 1 << NS_SIDE_BOTTOM));
16055: 
16055:     child = nextSibling;
16055:     nextSibling = nextSibling->GetNextSibling();
16055:   }
16055: }
16055: 
    1: NS_IMETHODIMP
    1: nsColumnSetFrame::SetInitialChildList(nsIAtom*        aListName,
    1:                                       nsIFrame*       aChildList)
    1: {
    1:   NS_ASSERTION(!aListName, "Only default child list supported");
    1:   NS_ASSERTION(aChildList && !aChildList->GetNextSibling(),
    1:                "initial child list must have exactly one child");
    1:   // Queue up the frames for the content frame
    1:   return nsHTMLContainerFrame::SetInitialChildList(nsnull, aChildList);
    1: }
    1: 
 9811: static nscoord
 9811: GetAvailableContentWidth(const nsHTMLReflowState& aReflowState)
 9811: {
    1:   if (aReflowState.availableWidth == NS_INTRINSICSIZE) {
    1:     return NS_INTRINSICSIZE;
    1:   }
    1:   nscoord borderPaddingWidth =
    1:     aReflowState.mComputedBorderPadding.left +
    1:     aReflowState.mComputedBorderPadding.right;
    1:   return PR_MAX(0, aReflowState.availableWidth - borderPaddingWidth);
    1: }
    1: 
 9811: static nscoord
 9811: GetAvailableContentHeight(const nsHTMLReflowState& aReflowState)
 9811: {
    1:   if (aReflowState.availableHeight == NS_INTRINSICSIZE) {
    1:     return NS_INTRINSICSIZE;
    1:   }
    1:   nscoord borderPaddingHeight =
    1:     aReflowState.mComputedBorderPadding.top +
    1:     aReflowState.mComputedBorderPadding.bottom;
    1:   return PR_MAX(0, aReflowState.availableHeight - borderPaddingHeight);
    1: }
    1: 
 3696: static nscoord
 9811: GetColumnGap(nsColumnSetFrame*    aFrame,
16031:              const nsStyleColumn* aColStyle)
 9811: {
 9811:   if (eStyleUnit_Normal == aColStyle->mColumnGap.GetUnit())
 3696:     return aFrame->GetStyleFont()->mFont.size;
16031:   if (eStyleUnit_Coord == aColStyle->mColumnGap.GetUnit()) {
16031:     nscoord colGap = aColStyle->mColumnGap.GetCoordValue();
11796:     NS_ASSERTION(colGap >= 0, "negative column gap");
 9811:     return colGap;
11796:   }
 9811: 
 3696:   NS_NOTREACHED("Unknown gap type");
 3696:   return 0;
 3696: }
 3696: 
    1: nsColumnSetFrame::ReflowConfig
    1: nsColumnSetFrame::ChooseColumnStrategy(const nsHTMLReflowState& aReflowState)
    1: {
    1:   const nsStyleColumn* colStyle = GetStyleColumn();
    1:   nscoord availContentWidth = GetAvailableContentWidth(aReflowState);
    1:   if (aReflowState.ComputedWidth() != NS_INTRINSICSIZE) {
    1:     availContentWidth = aReflowState.ComputedWidth();
    1:   }
    1:   nscoord colHeight = GetAvailableContentHeight(aReflowState);
 4166:   if (aReflowState.ComputedHeight() != NS_INTRINSICSIZE) {
 4166:     colHeight = aReflowState.ComputedHeight();
    1:   }
    1: 
16031:   nscoord colGap = GetColumnGap(this, colStyle);
    1:   PRInt32 numColumns = colStyle->mColumnCount;
    1: 
 9811:   nscoord colWidth;
16031:   if (colStyle->mColumnWidth.GetUnit() == eStyleUnit_Coord) {
16031:     colWidth = colStyle->mColumnWidth.GetCoordValue();
11796:     NS_ASSERTION(colWidth >= 0, "negative column width");
    1:     // Reduce column count if necessary to make columns fit in the
    1:     // available width. Compute max number of columns that fit in
    1:     // availContentWidth, satisfying colGap*(maxColumns - 1) +
    1:     // colWidth*maxColumns <= availContentWidth
11796:     if (availContentWidth != NS_INTRINSICSIZE && colGap + colWidth > 0
    1:         && numColumns > 0) {
    1:       // This expression uses truncated rounding, which is what we
    1:       // want
    1:       PRInt32 maxColumns = (availContentWidth + colGap)/(colGap + colWidth);
    1:       numColumns = PR_MAX(1, PR_MIN(numColumns, maxColumns));
    1:     }
    1:   } else if (numColumns > 0 && availContentWidth != NS_INTRINSICSIZE) {
    1:     nscoord widthMinusGaps = availContentWidth - colGap*(numColumns - 1);
    1:     colWidth = widthMinusGaps/numColumns;
 9811:   } else {
 9811:     colWidth = NS_INTRINSICSIZE;
    1:   }
    1:   // Take care of the situation where there's only one column but it's
    1:   // still too wide
    1:   colWidth = PR_MAX(1, PR_MIN(colWidth, availContentWidth));
    1: 
    1:   nscoord expectedWidthLeftOver = 0;
    1: 
    1:   if (colWidth != NS_INTRINSICSIZE && availContentWidth != NS_INTRINSICSIZE) {
    1:     // distribute leftover space
    1: 
    1:     // First, determine how many columns will be showing if the column
    1:     // count is auto
    1:     if (numColumns <= 0) {
    1:       // choose so that colGap*(nominalColumnCount - 1) +
    1:       // colWidth*nominalColumnCount is nearly availContentWidth
    1:       // make sure to round down
11796:       if (colGap + colWidth > 0) {
    1:         numColumns = (availContentWidth + colGap)/(colGap + colWidth);
11796:       }
    1:       if (numColumns <= 0) {
    1:         numColumns = 1;
    1:       }
    1:     }
    1: 
    1:     // Compute extra space and divide it among the columns
  686:     nscoord extraSpace =
  686:       PR_MAX(0, availContentWidth - (colWidth*numColumns + colGap*(numColumns - 1)));
    1:     nscoord extraToColumns = extraSpace/numColumns;
    1:     colWidth += extraToColumns;
    1:     expectedWidthLeftOver = extraSpace - (extraToColumns*numColumns);
    1:   }
    1: 
    1:   // NOTE that the non-balancing behavior for non-auto computed height
    1:   // is not in the CSS3 columns draft as of 18 January 2001
 4166:   if (aReflowState.ComputedHeight() == NS_INTRINSICSIZE) {
    1:     // Balancing!
    1:     if (numColumns <= 0) {
    1:       // Hmm, auto column count, column width or available width is unknown,
    1:       // and balancing is required. Let's just use one column then.
    1:       numColumns = 1;
    1:     }
    1:     colHeight = PR_MIN(mLastBalanceHeight, GetAvailableContentHeight(aReflowState));
    1:   } else {
    1:     // No balancing, so don't limit the column count
    1:     numColumns = PR_INT32_MAX;
    1:   }
    1: 
    1: #ifdef DEBUG_roc
    1:   printf("*** nsColumnSetFrame::ChooseColumnStrategy: numColumns=%d, colWidth=%d, expectedWidthLeftOver=%d, colHeight=%d, colGap=%d\n",
    1:          numColumns, colWidth, expectedWidthLeftOver, colHeight, colGap);
    1: #endif
    1:   ReflowConfig config = { numColumns, colWidth, expectedWidthLeftOver, colGap, colHeight };
    1:   return config;
    1: }
    1: 
    1: // XXX copied from nsBlockFrame, should this be moved to nsContainerFrame?
    1: static void
    1: PlaceFrameView(nsIFrame* aFrame)
    1: {
    1:   if (aFrame->HasView())
    1:     nsContainerFrame::PositionFrameView(aFrame);
    1:   else
    1:     nsContainerFrame::PositionChildViews(aFrame);
    1: }
    1: 
    1: static void MoveChildTo(nsIFrame* aParent, nsIFrame* aChild, nsPoint aOrigin) {
    1:   if (aChild->GetPosition() == aOrigin) {
    1:     return;
    1:   }
    1:   
11909:   nsRect r = aChild->GetOverflowRect();
    1:   r += aChild->GetPosition();
    1:   aParent->Invalidate(r);
    1:   r -= aChild->GetPosition();
    1:   aChild->SetPosition(aOrigin);
    1:   r += aOrigin;
    1:   aParent->Invalidate(r);
    1:   PlaceFrameView(aChild);
    1: }
    1: 
 3696: nscoord
 3696: nsColumnSetFrame::GetMinWidth(nsIRenderingContext *aRenderingContext) {
 3696:   nscoord width = 0;
27450:   DISPLAY_MIN_WIDTH(this, width);
 3696:   if (mFrames.FirstChild()) {
 3696:     width = mFrames.FirstChild()->GetMinWidth(aRenderingContext);
 3696:   }
 3696:   const nsStyleColumn* colStyle = GetStyleColumn();
 9811:   nscoord colWidth;
16031:   if (colStyle->mColumnWidth.GetUnit() == eStyleUnit_Coord) {
16031:     colWidth = colStyle->mColumnWidth.GetCoordValue();
16031:     // As available width reduces to zero, we reduce our number of columns
16031:     // to one, and don't enforce the column width, so just return the min
16031:     // of the child's min-width with any specified column width.
 9811:     width = PR_MIN(width, colWidth);
 3696:   } else {
16031:     NS_ASSERTION(colStyle->mColumnCount > 0,
16031:                  "column-count and column-width can't both be auto");
16031:     // As available width reduces to zero, we still have mColumnCount columns,
16031:     // so multiply the child's min-width by the number of columns.
13850:     colWidth = width;
 3696:     width *= colStyle->mColumnCount;
13850:     // The multiplication above can make 'width' negative (integer overflow),
13850:     // so use PR_MAX to protect against that.
13850:     width = PR_MAX(width, colWidth);
 3696:   }
 3696:   // XXX count forced column breaks here? Maybe we should return the child's
 3696:   // min-width times the minimum number of columns.
 3696:   return width;
 3696: }
 3696: 
 3696: nscoord
 3696: nsColumnSetFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext) {
16031:   // Our preferred width is our desired column width, if specified, otherwise
16031:   // the child's preferred width, times the number of columns, plus the width
16031:   // of any required column gaps
 3696:   // XXX what about forced column breaks here?
27450:   nscoord result = 0;
27450:   DISPLAY_PREF_WIDTH(this, result);
 3696:   const nsStyleColumn* colStyle = GetStyleColumn();
16031:   nscoord colGap = GetColumnGap(this, colStyle);
 3696: 
 3696:   nscoord colWidth;
16031:   if (colStyle->mColumnWidth.GetUnit() == eStyleUnit_Coord) {
16031:     colWidth = colStyle->mColumnWidth.GetCoordValue();
16031:   } else if (mFrames.FirstChild()) {
 3696:     colWidth = mFrames.FirstChild()->GetPrefWidth(aRenderingContext);
 3696:   } else {
 3696:     colWidth = 0;
 3696:   }
 3696: 
 3696:   PRInt32 numColumns = colStyle->mColumnCount;
 3696:   if (numColumns <= 0) {
 3696:     // if column-count is auto, assume one column
 3696:     numColumns = 1;
 3696:   }
 3696:   
13850:   nscoord width = colWidth*numColumns + colGap*(numColumns - 1);
13850:   // The multiplication above can make 'width' negative (integer overflow),
13850:   // so use PR_MAX to protect against that.
27450:   result = PR_MAX(width, colWidth);
27450:   return result;
 3696: }
 3696: 
    1: PRBool
    1: nsColumnSetFrame::ReflowChildren(nsHTMLReflowMetrics&     aDesiredSize,
    1:                                  const nsHTMLReflowState& aReflowState,
    1:                                  nsReflowStatus&          aStatus,
    1:                                  const ReflowConfig&      aConfig,
    1:                                  PRBool                   aUnboundedLastColumn,
14460:                                  nsCollapsingMargin*      aBottomMarginCarriedOut,
14460:                                  ColumnBalanceData&       aColData)
14460: {
14460:   aColData.Reset();
    1:   PRBool allFit = PR_TRUE;
    1:   PRBool RTL = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_RTL;
 1158:   PRBool shrinkingHeightOnly = !NS_SUBTREE_DIRTY(this) &&
    1:     mLastBalanceHeight > aConfig.mColMaxHeight;
    1:   
    1: #ifdef DEBUG_roc
    1:   printf("*** Doing column reflow pass: mLastBalanceHeight=%d, mColMaxHeight=%d, RTL=%d\n, mBalanceColCount=%d, mColWidth=%d, mColGap=%d\n",
    1:          mLastBalanceHeight, aConfig.mColMaxHeight, RTL, aConfig.mBalanceColCount,
    1:          aConfig.mColWidth, aConfig.mColGap);
    1: #endif
    1: 
    1:   DrainOverflowColumns();
    1:   
    1:   if (mLastBalanceHeight != aConfig.mColMaxHeight) {
    1:     mLastBalanceHeight = aConfig.mColMaxHeight;
    1:     // XXX Seems like this could fire if incremental reflow pushed the column set
    1:     // down so we reflow incrementally with a different available height.
    1:     // We need a way to do an incremental reflow and be sure availableHeight
    1:     // changes are taken account of! Right now I think block frames with absolute
    1:     // children might exit early.
    1:     //NS_ASSERTION(aKidReason != eReflowReason_Incremental,
    1:     //             "incremental reflow should not have changed the balance height");
    1:   }
    1: 
    1:   // get our border and padding
    1:   const nsMargin &borderPadding = aReflowState.mComputedBorderPadding;
    1:   
    1:   nsRect contentRect(0, 0, 0, 0);
    1:   nsRect overflowRect(0, 0, 0, 0);
    1:   
    1:   nsIFrame* child = mFrames.FirstChild();
    1:   nsPoint childOrigin = nsPoint(borderPadding.left, borderPadding.top);
    1:   // For RTL, figure out where the last column's left edge should be. Since the
    1:   // columns might not fill the frame exactly, we need to account for the
    1:   // slop. Otherwise we'll waste time moving the columns by some tiny
    1:   // amount unnecessarily.
    1:   nscoord targetX = borderPadding.left;
    1:   if (RTL) {
    1:     nscoord availWidth = aReflowState.availableWidth;
    1:     if (aReflowState.ComputedWidth() != NS_INTRINSICSIZE) {
    1:       availWidth = aReflowState.ComputedWidth();
    1:     }
    1:     if (availWidth != NS_INTRINSICSIZE) {
    1:       childOrigin.x += availWidth - aConfig.mColWidth;
    1:       targetX += aConfig.mExpectedWidthLeftOver;
    1: #ifdef DEBUG_roc
    1:       printf("*** childOrigin.x = %d\n", childOrigin.x);
    1: #endif
    1:     }
    1:   }
14460:   int columnCount = 0;
14460:   int contentBottom = 0;
    1:   PRBool reflowNext = PR_FALSE;
    1: 
    1:   while (child) {
    1:     // Try to skip reflowing the child. We can't skip if the child is dirty. We also can't
    1:     // skip if the next column is dirty, because the next column's first line(s)
    1:     // might be pullable back to this column. We can't skip if it's the last child
24917:     // because we need to obtain the bottom margin. We can't skip
24917:     // if this is the last column and we're supposed to assign unbounded
24917:     // height to it, because that could change the available height from
24917:     // the last time we reflowed it and we should try to pull all the
24917:     // content from its next sibling. (Note that it might be the last
24917:     // column, but not be the last child because the desired number of columns
24917:     // has changed.)
30044:     PRBool skipIncremental = !aReflowState.ShouldReflowAllKids()
 4006:       && !NS_SUBTREE_DIRTY(child)
    1:       && child->GetNextSibling()
24917:       && !(aUnboundedLastColumn && columnCount == aConfig.mBalanceColCount - 1)
 4006:       && !NS_SUBTREE_DIRTY(child->GetNextSibling());
    1:     // If we need to pull up content from the prev-in-flow then this is not just
    1:     // a height shrink. The prev in flow will have set the dirty bit.
    1:     // Check the overflow rect YMost instead of just the child's content height. The child
    1:     // may have overflowing content that cares about the available height boundary.
    1:     // (It may also have overflowing content that doesn't care about the available height
    1:     // boundary, but if so, too bad, this optimization is defeated.)
    1:     PRBool skipResizeHeightShrink = shrinkingHeightOnly
    1:       && child->GetOverflowRect().YMost() <= aConfig.mColMaxHeight;
14460: 
14460:     nscoord childContentBottom = 0;
    1:     if (!reflowNext && (skipIncremental || skipResizeHeightShrink)) {
    1:       // This child does not need to be reflowed, but we may need to move it
    1:       MoveChildTo(this, child, childOrigin);
    1:       
    1:       // If this is the last frame then make sure we get the right status
 4006:       nsIFrame* kidNext = child->GetNextSibling();
 4006:       if (kidNext) {
 4006:         aStatus = (kidNext->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)
 4006:                   ? NS_FRAME_OVERFLOW_INCOMPLETE
 4006:                   : NS_FRAME_NOT_COMPLETE;
    1:       } else {
    1:         aStatus = mLastFrameStatus;
    1:       }
14460:       childContentBottom = nsLayoutUtils::CalculateContentBottom(child);
    1: #ifdef DEBUG_roc
    1:       printf("*** Skipping child #%d %p (incremental %d, resize height shrink %d): status = %d\n",
    1:              columnCount, (void*)child, skipIncremental, skipResizeHeightShrink, aStatus);
    1: #endif
    1:     } else {
    1:       nsSize availSize(aConfig.mColWidth, aConfig.mColMaxHeight);
    1:       
    1:       if (aUnboundedLastColumn && columnCount == aConfig.mBalanceColCount - 1) {
    1:         availSize.height = GetAvailableContentHeight(aReflowState);
    1:       }
    1:   
    1:       if (reflowNext)
    1:         child->AddStateBits(NS_FRAME_IS_DIRTY);
    1: 
  238:       nsHTMLReflowState kidReflowState(PresContext(), aReflowState, child,
    1:                                        availSize, availSize.width,
 4166:                                        aReflowState.ComputedHeight());
    1:       kidReflowState.mFlags.mIsTopOfPage = PR_TRUE;
    1:       kidReflowState.mFlags.mTableIsSplittable = PR_FALSE;
    1:           
    1: #ifdef DEBUG_roc
    1:       printf("*** Reflowing child #%d %p: availHeight=%d\n",
    1:              columnCount, (void*)child,availSize.height);
    1: #endif
    1: 
    1:       // Note if the column's next in flow is not being changed by this incremental reflow.
    1:       // This may allow the current column to avoid trying to pull lines from the next column.
    1:       if (child->GetNextSibling() &&
    1:           !(GetStateBits() & NS_FRAME_IS_DIRTY) &&
    1:         !(child->GetNextSibling()->GetStateBits() & NS_FRAME_IS_DIRTY)) {
    1:         kidReflowState.mFlags.mNextInFlowUntouched = PR_TRUE;
    1:       }
    1:     
    1:       nsHTMLReflowMetrics kidDesiredSize(aDesiredSize.mFlags);
    1: 
23305:       // XXX it would be cool to consult the float manager for the
    1:       // previous block to figure out the region of floats from the
    1:       // previous column that extend into this column, and subtract
23305:       // that region from the new float manager.  So you could stick a
    1:       // really big float in the first column and text in following
    1:       // columns would flow around it.
    1: 
    1:       // Reflow the frame
  238:       ReflowChild(child, PresContext(), kidDesiredSize, kidReflowState,
    1:                   childOrigin.x + kidReflowState.mComputedMargin.left,
    1:                   childOrigin.y + kidReflowState.mComputedMargin.top,
    1:                   0, aStatus);
    1: 
    1:       reflowNext = (aStatus & NS_FRAME_REFLOW_NEXTINFLOW) != 0;
    1:     
    1: #ifdef DEBUG_roc
    1:       printf("*** Reflowed child #%d %p: status = %d, desiredSize=%d,%d\n",
    1:              columnCount, (void*)child, aStatus, kidDesiredSize.width, kidDesiredSize.height);
    1: #endif
    1: 
    1:       NS_FRAME_TRACE_REFLOW_OUT("Column::Reflow", aStatus);
    1: 
    1:       *aBottomMarginCarriedOut = kidDesiredSize.mCarriedOutBottomMargin;
    1:       
  238:       FinishReflowChild(child, PresContext(), &kidReflowState, 
    1:                         kidDesiredSize, childOrigin.x, childOrigin.y, 0);
14460: 
14460:       childContentBottom = nsLayoutUtils::CalculateContentBottom(child);
14460:       if (childContentBottom > aConfig.mColMaxHeight) {
14460:         allFit = PR_FALSE;
14460:       }
21324:       if (childContentBottom > availSize.height) {
21324:         aColData.mMaxOverflowingHeight = PR_MAX(childContentBottom,
21324:             aColData.mMaxOverflowingHeight);
21324:       }
    1:     }
    1: 
    1:     contentRect.UnionRect(contentRect, child->GetRect());
    1: 
    1:     ConsiderChildOverflow(overflowRect, child);
14460:     contentBottom = PR_MAX(contentBottom, childContentBottom);
14460:     aColData.mLastHeight = childContentBottom;
14460:     aColData.mSumHeight += childContentBottom;
    1: 
    1:     // Build a continuation column if necessary
    1:     nsIFrame* kidNextInFlow = child->GetNextInFlow();
    1: 
 4006:     if (NS_FRAME_IS_FULLY_COMPLETE(aStatus) && !NS_FRAME_IS_TRUNCATED(aStatus)) {
    1:       NS_ASSERTION(!kidNextInFlow, "next in flow should have been deleted");
29063:       child = nsnull;
    1:       break;
    1:     } else {
    1:       ++columnCount;
    1:       // Make sure that the column has a next-in-flow. If not, we must
    1:       // create one to hold the overflowing stuff, even if we're just
    1:       // going to put it on our overflow list and let *our*
    1:       // next in flow handle it.
    1:       if (!kidNextInFlow) {
    1:         NS_ASSERTION(aStatus & NS_FRAME_REFLOW_NEXTINFLOW,
    1:                      "We have to create a continuation, but the block doesn't want us to reflow it?");
    1: 
    1:         // We need to create a continuing column
  238:         nsresult rv = CreateNextInFlow(PresContext(), this, child, kidNextInFlow);
    1:         
    1:         if (NS_FAILED(rv)) {
    1:           NS_NOTREACHED("Couldn't create continuation");
29063:           child = nsnull;
    1:           break;
    1:         }
    1:       }
    1: 
 4006:       // Make sure we reflow a next-in-flow when it switches between being
 4006:       // normal or overflow container
 4006:       if (NS_FRAME_OVERFLOW_IS_INCOMPLETE(aStatus)) {
 4006:         if (!(kidNextInFlow->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
 4006:           aStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
 4006:           reflowNext = PR_TRUE;
 4006:           kidNextInFlow->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
 4006:         }
 4006:       }
 4006:       else if (kidNextInFlow->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
 4006:         aStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
 4006:         reflowNext = PR_TRUE;
 4006:         kidNextInFlow->RemoveStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
 4006:       }
 4006:         
    1:       if (columnCount >= aConfig.mBalanceColCount) {
    1:         // No more columns allowed here. Stop.
    1:         aStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
    1:         kidNextInFlow->AddStateBits(NS_FRAME_IS_DIRTY);
    1:         
    1:         // Move any of our leftover columns to our overflow list. Our
    1:         // next-in-flow will eventually pick them up.
    1:         nsIFrame* continuationColumns = child->GetNextSibling();
    1:         if (continuationColumns) {
  238:           SetOverflowFrames(PresContext(), continuationColumns);
    1:           child->SetNextSibling(nsnull);
    1:         }
29063:         child = nsnull;
    1:         break;
    1:       }
    1:     }
    1: 
29063:     if (PresContext()->HasPendingInterrupt()) {
27993:       // Stop the loop now while |child| still points to the frame that bailed
27993:       // out.  We could keep going here and condition a bunch of the code in
27993:       // this loop on whether there's an interrupt, or even just keep going and
27993:       // trying to reflow the blocks (even though we know they'll interrupt
27993:       // right after their first line), but stopping now is conceptually the
29063:       // simplest (and probably fastest) thing.
27993:       break;
27993:     }
27993: 
    1:     // Advance to the next column
    1:     child = child->GetNextSibling();
    1: 
    1:     if (child) {
    1:       if (!RTL) {
    1:         childOrigin.x += aConfig.mColWidth + aConfig.mColGap;
    1:       } else {
    1:         childOrigin.x -= aConfig.mColWidth + aConfig.mColGap;
    1:       }
    1:       
    1: #ifdef DEBUG_roc
    1:       printf("*** NEXT CHILD ORIGIN.x = %d\n", childOrigin.x);
    1: #endif
    1:     }
    1:   }
    1: 
29063:   if (PresContext()->CheckForInterrupt(this) &&
27993:       (GetStateBits() & NS_FRAME_IS_DIRTY)) {
27993:     // Mark all our kids starting with |child| dirty
29063: 
29063:     // Note that this is a CheckForInterrupt call, not a HasPendingInterrupt,
29063:     // because we might have interrupted while reflowing |child|, and since
29063:     // we're about to add a dirty bit to |child| we need to make sure that
29063:     // |this| is scheduled to have dirty bits marked on it and its ancestors.
29063:     // Otherwise, when we go to mark dirty bits on |child|'s ancestors we'll
29063:     // bail out immediately, since it'll already have a dirty bit.
27993:     for (; child; child = child->GetNextSibling()) {
27993:       child->AddStateBits(NS_FRAME_IS_DIRTY);
27993:     }
27993:   }
27993:   
    1:   // If we're doing RTL, we need to make sure our last column is at the left-hand side of the frame.
    1:   if (RTL && childOrigin.x != targetX) {
    1:     overflowRect = nsRect(0, 0, 0, 0);
    1:     contentRect = nsRect(0, 0, 0, 0);
    1:     PRInt32 deltaX = targetX - childOrigin.x;
    1: #ifdef DEBUG_roc
    1:     printf("*** CHILDORIGIN.x = %d, targetX = %d, DELTAX = %d\n", childOrigin.x, targetX, deltaX);
    1: #endif
    1:     for (child = mFrames.FirstChild(); child; child = child->GetNextSibling()) {
    1:       MoveChildTo(this, child, child->GetPosition() + nsPoint(deltaX, 0));
    1:       ConsiderChildOverflow(overflowRect, child);
    1:       contentRect.UnionRect(contentRect, child->GetRect());
    1:     }
    1:   }
14460:   aColData.mMaxHeight = contentBottom;
14460:   contentRect.height = PR_MAX(contentRect.height, contentBottom);
    1:   mLastFrameStatus = aStatus;
    1:   
    1:   // contentRect included the borderPadding.left,borderPadding.top of the child rects
    1:   contentRect -= nsPoint(borderPadding.left, borderPadding.top);
    1:   
    1:   nsSize contentSize = nsSize(contentRect.XMost(), contentRect.YMost());
    1: 
    1:   // Apply computed and min/max values
 4166:   if (aReflowState.ComputedHeight() != NS_INTRINSICSIZE) {
 4166:     contentSize.height = aReflowState.ComputedHeight();
    1:   } else {
    1:     if (NS_UNCONSTRAINEDSIZE != aReflowState.mComputedMaxHeight) {
    1:       contentSize.height = PR_MIN(aReflowState.mComputedMaxHeight, contentSize.height);
    1:     }
    1:     if (NS_UNCONSTRAINEDSIZE != aReflowState.mComputedMinHeight) {
    1:       contentSize.height = PR_MAX(aReflowState.mComputedMinHeight, contentSize.height);
    1:     }
    1:   }
    1:   if (aReflowState.ComputedWidth() != NS_INTRINSICSIZE) {
    1:     contentSize.width = aReflowState.ComputedWidth();
    1:   } else {
    1:     if (NS_UNCONSTRAINEDSIZE != aReflowState.mComputedMaxWidth) {
    1:       contentSize.width = PR_MIN(aReflowState.mComputedMaxWidth, contentSize.width);
    1:     }
    1:     if (NS_UNCONSTRAINEDSIZE != aReflowState.mComputedMinWidth) {
    1:       contentSize.width = PR_MAX(aReflowState.mComputedMinWidth, contentSize.width);
    1:     }
    1:   }
    1:     
    1:   aDesiredSize.height = borderPadding.top + contentSize.height +
    1:     borderPadding.bottom;
    1:   aDesiredSize.width = contentSize.width + borderPadding.left + borderPadding.right;
    1:   overflowRect.UnionRect(overflowRect, nsRect(0, 0, aDesiredSize.width, aDesiredSize.height));
    1:   aDesiredSize.mOverflowArea = overflowRect;
    1:   
    1: #ifdef DEBUG_roc
14460:   printf("*** DONE PASS feasible=%d\n", allFit && NS_FRAME_IS_FULLY_COMPLETE(aStatus)
    1:          && !NS_FRAME_IS_TRUNCATED(aStatus));
    1: #endif
14460:   return allFit && NS_FRAME_IS_FULLY_COMPLETE(aStatus)
    1:     && !NS_FRAME_IS_TRUNCATED(aStatus);
    1: }
    1: 
    1: void
    1: nsColumnSetFrame::DrainOverflowColumns()
    1: {
    1:   // First grab the prev-in-flows overflows and reparent them to this
    1:   // frame.
 3233:   nsColumnSetFrame* prev = static_cast<nsColumnSetFrame*>(GetPrevInFlow());
    1:   if (prev) {
  238:     nsIFrame* overflows = prev->GetOverflowFrames(PresContext(), PR_TRUE);
    1:     if (overflows) {
    1:       // Make all the frames on the overflow list mine
    1:       nsIFrame* lastFrame = nsnull;
    1:       for (nsIFrame* f = overflows; f; f = f->GetNextSibling()) {
    1:         f->SetParent(this);
    1: 
    1:         // When pushing and pulling frames we need to check for whether any
    1:         // views need to be reparented
  238:         nsHTMLContainerFrame::ReparentFrameView(PresContext(), f, prev, this);
    1: 
    1:         // Get the next frame
    1:         lastFrame = f;
    1:       }
    1: 
    1:       NS_ASSERTION(lastFrame, "overflow list was created with no frames");
    1:       lastFrame->SetNextSibling(mFrames.FirstChild());
    1:       
    1:       mFrames.SetFrames(overflows);
    1:     }
    1:   }
    1:   
    1:   // Now pull back our own overflows and append them to our children.
    1:   // We don't need to reparent them since we're already their parent.
  238:   nsIFrame* overflows = GetOverflowFrames(PresContext(), PR_TRUE);
    1:   if (overflows) {
    1:     mFrames.AppendFrames(this, overflows);
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsColumnSetFrame::Reflow(nsPresContext*           aPresContext,
    1:                          nsHTMLReflowMetrics&     aDesiredSize,
    1:                          const nsHTMLReflowState& aReflowState,
    1:                          nsReflowStatus&          aStatus)
    1: {
30638:   // Don't support interruption in columns
30638:   nsPresContext::InterruptPreventer noInterrupts(aPresContext);
30638: 
    1:   DO_GLOBAL_REFLOW_COUNT("nsColumnSetFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1: 
    1:   // Initialize OUT parameter
    1:   aStatus = NS_FRAME_COMPLETE;
    1: 
30044:   // Our children depend on our height if we have a fixed height.
30044:   if (aReflowState.ComputedHeight() != NS_AUTOHEIGHT) {
30044:     NS_ASSERTION(aReflowState.ComputedHeight() != NS_INTRINSICSIZE,
30044:                  "Unexpected mComputedHeight");
30044:     AddStateBits(NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
30044:   }
30044:   else {
30044:     RemoveStateBits(NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
30044:   }
30044: 
    1:   //------------ Handle Incremental Reflow -----------------
    1: 
    1:   ReflowConfig config = ChooseColumnStrategy(aReflowState);
    1:   PRBool isBalancing = config.mBalanceColCount < PR_INT32_MAX;
    1:   
    1:   // If balancing, then we allow the last column to grow to unbounded
    1:   // height during the first reflow. This gives us a way to estimate
    1:   // what the average column height should be, because we can measure
    1:   // the heights of all the columns and sum them up. But don't do this
    1:   // if we have a next in flow because we don't want to suck all its
    1:   // content back here and then have to push it out again!
    1:   nsIFrame* nextInFlow = GetNextInFlow();
11532:   PRBool unboundedLastColumn = isBalancing && !nextInFlow;
    1:   nsCollapsingMargin carriedOutBottomMargin;
14460:   ColumnBalanceData colData;
    1:   PRBool feasible = ReflowChildren(aDesiredSize, aReflowState,
14460:     aStatus, config, unboundedLastColumn, &carriedOutBottomMargin, colData);
    1: 
27993:   if (isBalancing && !aPresContext->HasPendingInterrupt()) {
    1:     nscoord availableContentHeight = GetAvailableContentHeight(aReflowState);
    1:   
    1:     // Termination of the algorithm below is guaranteed because
    1:     // knownFeasibleHeight - knownInfeasibleHeight decreases in every
    1:     // iteration.
    1:     nscoord knownFeasibleHeight = NS_INTRINSICSIZE;
    1:     nscoord knownInfeasibleHeight = 0;
    1:     // We set this flag when we detect that we may contain a frame
    1:     // that can break anywhere (thus foiling the linear decrease-by-one
    1:     // search)
    1:     PRBool maybeContinuousBreakingDetected = PR_FALSE;
    1: 
27993:     while (!aPresContext->HasPendingInterrupt()) {
    1:       nscoord lastKnownFeasibleHeight = knownFeasibleHeight;
    1: 
    1:       // Record what we learned from the last reflow
    1:       if (feasible) {
    1:         // maxHeight is feasible. Also, mLastBalanceHeight is feasible.
14460:         knownFeasibleHeight = PR_MIN(knownFeasibleHeight, colData.mMaxHeight);
    1:         knownFeasibleHeight = PR_MIN(knownFeasibleHeight, mLastBalanceHeight);
    1: 
    1:         // Furthermore, no height less than the height of the last
    1:         // column can ever be feasible. (We might be able to reduce the
    1:         // height of a non-last column by moving content to a later column,
    1:         // but we can't do that with the last column.)
    1:         if (mFrames.GetLength() == config.mBalanceColCount) {
    1:           knownInfeasibleHeight = PR_MAX(knownInfeasibleHeight,
14460:                                          colData.mLastHeight - 1);
    1:         }
    1:       } else {
    1:         knownInfeasibleHeight = PR_MAX(knownInfeasibleHeight, mLastBalanceHeight);
21324:         // If a column didn't fit in its available height, then its current
21324:         // height must be the minimum height for unbreakable content in
21324:         // the column, and therefore no smaller height can be feasible.
21324:         knownInfeasibleHeight = PR_MAX(knownInfeasibleHeight,
21324:                                        colData.mMaxOverflowingHeight - 1);
    1: 
    1:         if (unboundedLastColumn) {
    1:           // The last column is unbounded, so all content got reflowed, so the
14460:           // mColMaxHeight is feasible.
14460:           knownFeasibleHeight = PR_MIN(knownFeasibleHeight,
14460:                                        colData.mMaxHeight);
    1:         }
    1:       }
    1: 
    1: #ifdef DEBUG_roc
    1:       printf("*** nsColumnSetFrame::Reflow balancing knownInfeasible=%d knownFeasible=%d\n",
    1:              knownInfeasibleHeight, knownFeasibleHeight);
    1: #endif
    1: 
    1:       if (knownInfeasibleHeight >= knownFeasibleHeight - 1) {
    1:         // knownFeasibleHeight is where we want to be
    1:         break;
    1:       }
    1: 
    1:       if (knownInfeasibleHeight >= availableContentHeight) {
    1:         break;
    1:       }
    1: 
    1:       if (lastKnownFeasibleHeight - knownFeasibleHeight == 1) {
    1:         // We decreased the feasible height by one twip only. This could
    1:         // indicate that there is a continuously breakable child frame
    1:         // that we are crawling through.
    1:         maybeContinuousBreakingDetected = PR_TRUE;
    1:       }
    1: 
    1:       nscoord nextGuess = (knownFeasibleHeight + knownInfeasibleHeight)/2;
    1:       // The constant of 600 twips is arbitrary. It's about two line-heights.
    1:       if (knownFeasibleHeight - nextGuess < 600 &&
    1:           !maybeContinuousBreakingDetected) {
    1:         // We're close to our target, so just try shrinking just the
    1:         // minimum amount that will cause one of our columns to break
    1:         // differently.
    1:         nextGuess = knownFeasibleHeight - 1;
    1:       } else if (unboundedLastColumn) {
    1:         // Make a guess by dividing that into N columns. Add some slop
    1:         // to try to make it on the feasible side.  The constant of
    1:         // 600 twips is arbitrary. It's about two line-heights.
14460:         nextGuess = colData.mSumHeight/config.mBalanceColCount + 600;
    1:         // Sanitize it
    1:         nextGuess = PR_MIN(PR_MAX(nextGuess, knownInfeasibleHeight + 1),
    1:                            knownFeasibleHeight - 1);
    1:       } else if (knownFeasibleHeight == NS_INTRINSICSIZE) {
    1:         // This can happen when we had a next-in-flow so we didn't
    1:         // want to do an unbounded height measuring step. Let's just increase
    1:         // from the infeasible height by some reasonable amount.
    1:         nextGuess = knownInfeasibleHeight*2 + 600;
    1:       }
    1:       // Don't bother guessing more than our height constraint.
    1:       nextGuess = PR_MIN(availableContentHeight, nextGuess);
    1: 
    1: #ifdef DEBUG_roc
    1:       printf("*** nsColumnSetFrame::Reflow balancing choosing next guess=%d\n", nextGuess);
    1: #endif
    1: 
    1:       config.mColMaxHeight = nextGuess;
    1:       
    1:       unboundedLastColumn = PR_FALSE;
    1:       AddStateBits(NS_FRAME_IS_DIRTY);
    1:       feasible = ReflowChildren(aDesiredSize, aReflowState,
    1:                                 aStatus, config, PR_FALSE, 
14460:                                 &carriedOutBottomMargin, colData);
    1:     }
    1: 
27993:     if (!feasible && !aPresContext->HasPendingInterrupt()) {
    1:       // We may need to reflow one more time at the feasible height to
    1:       // get a valid layout.
    1:       PRBool skip = PR_FALSE;
    1:       if (knownInfeasibleHeight >= availableContentHeight) {
    1:         config.mColMaxHeight = availableContentHeight;
    1:         if (mLastBalanceHeight == availableContentHeight) {
    1:           skip = PR_TRUE;
    1:         }
    1:       } else {
    1:         config.mColMaxHeight = knownFeasibleHeight;
    1:       }
    1:       if (!skip) {
29076:         // If our height is unconstrained, make sure that the last column is
29076:         // allowed to have arbitrary height here, even though we were balancing.
29076:         // Otherwise we'd have to split, and it's not clear what we'd do with
29076:         // that.
    1:         AddStateBits(NS_FRAME_IS_DIRTY);
14460:         ReflowChildren(aDesiredSize, aReflowState, aStatus, config,
29076:                        availableContentHeight == NS_UNCONSTRAINEDSIZE,
29076:                        &carriedOutBottomMargin, colData);
    1:       }
    1:     }
    1:   }
    1: 
27993:   if (aPresContext->HasPendingInterrupt() &&
27993:       aReflowState.availableHeight == NS_UNCONSTRAINEDSIZE) {
27993:     // In this situation, we might be lying about our reflow status, because
27993:     // our last kid (the one that got interrupted) was incomplete.  Fix that.
27993:     aStatus = NS_FRAME_COMPLETE;
27993:   }
27993:   
17140:   CheckInvalidateSizeChange(aDesiredSize);
    1: 
    1:   FinishAndStoreOverflow(&aDesiredSize);
    1:   aDesiredSize.mCarriedOutBottomMargin = carriedOutBottomMargin;
    1: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
    1: 
24917:   NS_ASSERTION(NS_FRAME_IS_COMPLETE(aStatus) ||
24917:                aReflowState.availableHeight != NS_UNCONSTRAINEDSIZE,
24917:                "Column set should be complete if the available height is unconstrained");
24917: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsColumnSetFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                    const nsRect&           aDirtyRect,
    1:                                    const nsDisplayListSet& aLists) {
    1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
16055:   aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
16055:       nsDisplayGeneric(this, ::PaintColumnRule, "ColumnRule"));
16055:   
    1:   nsIFrame* kid = mFrames.FirstChild();
    1:   // Our children won't have backgrounds so it doesn't matter where we put them.
    1:   while (kid) {
    1:     nsresult rv = BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     kid = kid->GetNextSibling();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: PRIntn
    1: nsColumnSetFrame::GetSkipSides() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsColumnSetFrame::AppendFrames(nsIAtom*        aListName,
    1:                                nsIFrame*       aFrameList)
    1: {
    1:   NS_NOTREACHED("AppendFrames not supported");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsColumnSetFrame::InsertFrames(nsIAtom*        aListName,
    1:                                nsIFrame*       aPrevFrame,
    1:                                nsIFrame*       aFrameList)
    1: {
    1:   NS_NOTREACHED("InsertFrames not supported");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsColumnSetFrame::RemoveFrame(nsIAtom*        aListName,
    1:                               nsIFrame*       aOldFrame)
    1: {
    1:   NS_NOTREACHED("RemoveFrame not supported");
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
