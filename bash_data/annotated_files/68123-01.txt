51215: /* vim:set tw=80 expandtab softtabstop=4 ts=4 sw=4: */
51215: /* ***** BEGIN LICENSE BLOCK *****
51215:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
51215:  *
51215:  * The contents of this file are subject to the Mozilla Public License Version
51215:  * 1.1 (the "License"); you may not use this file except in compliance with
51215:  * the License. You may obtain a copy of the License at
51215:  * http://www.mozilla.org/MPL/
51215:  *
51215:  * Software distributed under the License is distributed on an "AS IS" basis,
51215:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
51215:  * for the specific language governing rights and limitations under the
51215:  * License.
51215:  *
51215:  * The Original Code is the Mozilla BMP Decoder.
51215:  *
51215:  * The Initial Developer of the Original Code is
51215:  * Christian Biesinger <cbiesinger@web.de>.
51215:  * Portions created by the Initial Developer are Copyright (C) 2001
51215:  * the Initial Developer. All Rights Reserved.
51215:  *
51215:  * Contributor(s):
51215:  *   Neil Rashbrook <neil@parkwaycc.co.uk>
51215:  *   Bobby Holley <bobbyholley@gmail.com>
51215:  *
51215:  * Alternatively, the contents of this file may be used under the terms of
51215:  * either the GNU General Public License Version 2 or later (the "GPL"), or
51215:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
51215:  * in which case the provisions of the GPL or the LGPL are applicable instead
51215:  * of those above. If you wish to allow use of your version of this file only
51215:  * under the terms of either the GPL or the LGPL, and not to allow others to
51215:  * use your version of this file under the terms of the MPL, indicate your
51215:  * decision by deleting the provisions above and replace them with the notice
51215:  * and other provisions required by the GPL or the LGPL. If you do not delete
51215:  * the provisions above, a recipient may use your version of this file under
51215:  * the terms of any one of the MPL, the GPL or the LGPL.
51215:  *
51215:  * ***** END LICENSE BLOCK ***** */
51215: /* I got the format description from http://www.daubnet.com/formats/BMP.html */
51215: 
51215: /* This is a Cross-Platform BMP Decoder, which should work everywhere, including
51215:  * Big-Endian machines like the PowerPC. */
51215: 
51215: #include <stdlib.h>
51215: 
51215: #include "nsBMPDecoder.h"
51215: 
51215: #include "nsIInputStream.h"
51215: #include "RasterImage.h"
51215: #include "imgIContainerObserver.h"
51215: 
51215: #include "prlog.h"
51215: 
51241: namespace mozilla {
51241: namespace imagelib {
51215: 
51215: #ifdef PR_LOGGING
51215: PRLogModuleInfo *gBMPLog = PR_NewLogModule("BMPDecoder");
51215: #endif
51215: 
51215: // Convert from row (1..height) to absolute line (0..height-1)
51215: #define LINE(row) ((mBIH.height < 0) ? (-mBIH.height - (row)) : ((row) - 1))
51215: #define PIXEL_OFFSET(row, col) (LINE(row) * mBIH.width + col)
51215: 
51215: nsBMPDecoder::nsBMPDecoder()
51215: {
51215:     mColors = nsnull;
51215:     mRow = nsnull;
51215:     mCurPos = mPos = mNumColors = mRowBytes = 0;
51215:     mOldLine = mCurLine = 1; // Otherwise decoder will never start
51215:     mState = eRLEStateInitial;
51215:     mStateData = 0;
51215:     mLOH = WIN_HEADER_LENGTH;
51215: }
51215: 
51215: nsBMPDecoder::~nsBMPDecoder()
51215: {
51215:   delete[] mColors;
51215:   if (mRow)
51215:       free(mRow);
51215: }
51215: 
53664: void
51247: nsBMPDecoder::FinishInternal()
51215: {
53673:     // We shouldn't be called in error cases
53675:     NS_ABORT_IF_FALSE(!HasError(), "Can't call FinishInternal on error!");
53673: 
51246:     // We should never make multiple frames
51246:     NS_ABORT_IF_FALSE(GetFrameCount() <= 1, "Multiple BMP frames?");
51246: 
51215:     // Send notifications if appropriate
53673:     if (!IsSizeDecode() && (GetFrameCount() == 1)) {
51246:         PostFrameStop();
53669:         PostDecodeDone();
51215:     }
51215: }
51215: 
51215: // ----------------------------------------
51215: // Actual Data Processing
51215: // ----------------------------------------
51215: 
51215: static void calcBitmask(PRUint32 aMask, PRUint8& aBegin, PRUint8& aLength)
51215: {
51215:     // find the rightmost 1
51215:     PRUint8 pos;
51215:     PRBool started = PR_FALSE;
51215:     aBegin = aLength = 0;
51215:     for (pos = 0; pos <= 31; pos++) {
51215:         if (!started && (aMask & (1 << pos))) {
51215:             aBegin = pos;
51215:             started = PR_TRUE;
51215:         }
51215:         else if (started && !(aMask & (1 << pos))) {
51215:             aLength = pos - aBegin;
51215:             break;
51215:         }
51215:     }
51215: }
51215: 
51215: NS_METHOD nsBMPDecoder::CalcBitShift()
51215: {
51215:     PRUint8 begin, length;
51215:     // red
51215:     calcBitmask(mBitFields.red, begin, length);
51215:     mBitFields.redRightShift = begin;
51215:     mBitFields.redLeftShift = 8 - length;
51215:     // green
51215:     calcBitmask(mBitFields.green, begin, length);
51215:     mBitFields.greenRightShift = begin;
51215:     mBitFields.greenLeftShift = 8 - length;
51215:     // blue
51215:     calcBitmask(mBitFields.blue, begin, length);
51215:     mBitFields.blueRightShift = begin;
51215:     mBitFields.blueLeftShift = 8 - length;
51215:     return NS_OK;
51215: }
51215: 
53664: void
51241: nsBMPDecoder::WriteInternal(const char* aBuffer, PRUint32 aCount)
51215: {
53675:     NS_ABORT_IF_FALSE(!HasError(), "Shouldn't call WriteInternal after error!");
51215: 
51215:     // aCount=0 means EOF, mCurLine=0 means we're past end of image
51215:     if (!aCount || !mCurLine)
53664:         return;
51215: 
51215:     nsresult rv;
51215:     if (mPos < BFH_LENGTH) { /* In BITMAPFILEHEADER */
51215:         PRUint32 toCopy = BFH_LENGTH - mPos;
51215:         if (toCopy > aCount)
51215:             toCopy = aCount;
51215:         memcpy(mRawBuf + mPos, aBuffer, toCopy);
51215:         mPos += toCopy;
51215:         aCount -= toCopy;
51215:         aBuffer += toCopy;
51215:     }
51215:     if (mPos == BFH_LENGTH) {
51215:         ProcessFileHeader();
51215:         if (mBFH.signature[0] != 'B' || mBFH.signature[1] != 'M') {
53662:             PostDataError();
53664:             return;
51215:         }
51215:         if (mBFH.bihsize == OS2_BIH_LENGTH)
51215:             mLOH = OS2_HEADER_LENGTH;
51215:     }
51215:     if (mPos >= BFH_LENGTH && mPos < mLOH) { /* In BITMAPINFOHEADER */
51215:         PRUint32 toCopy = mLOH - mPos;
51215:         if (toCopy > aCount)
51215:             toCopy = aCount;
51215:         memcpy(mRawBuf + (mPos - BFH_LENGTH), aBuffer, toCopy);
51215:         mPos += toCopy;
51215:         aCount -= toCopy;
51215:         aBuffer += toCopy;
51215:     }
51215:     if (mPos == mLOH) {
51215:         ProcessInfoHeader();
51215:         PR_LOG(gBMPLog, PR_LOG_DEBUG, ("BMP image is %lix%lix%lu. compression=%lu\n",
51215:             mBIH.width, mBIH.height, mBIH.bpp, mBIH.compression));
51215:         // Verify we support this bit depth
51215:         if (mBIH.bpp != 1 && mBIH.bpp != 4 && mBIH.bpp != 8 &&
51215:             mBIH.bpp != 16 && mBIH.bpp != 24 && mBIH.bpp != 32) {
53662:           PostDataError();
53664:           return;
51215:         }
51215: 
51215:         // BMPs with negative width are invalid
51215:         // Reject extremely wide images to keep the math sane
51215:         const PRInt32 k64KWidth = 0x0000FFFF;
51215:         if (mBIH.width < 0 || mBIH.width > k64KWidth) {
53662:             PostDataError();
53664:             return;
51215:         }
51215: 
51215:         PRUint32 real_height = (mBIH.height > 0) ? mBIH.height : -mBIH.height;
51215: 
51245:         // Post our size to the superclass
51245:         PostSize(mBIH.width, real_height);
68123:         if (HasError()) {
68123:           // Setting the size lead to an error; this can happen when for example
68123:           // a multipart channel sends an image of a different size.
68123:           return;
68123:         }
51215: 
51244:         // We have the size. If we're doing a size decode, we got what
51215:         // we came for.
51244:         if (IsSizeDecode())
53664:             return;
51215: 
51215:         // We're doing a real decode.
51215:         mOldLine = mCurLine = real_height;
51215: 
51215:         if (mBIH.bpp <= 8) {
51215:             mNumColors = 1 << mBIH.bpp;
51215:             if (mBIH.colors && mBIH.colors < mNumColors)
51215:                 mNumColors = mBIH.colors;
51215: 
51215:             // Always allocate 256 even though mNumColors might be smaller
51215:             mColors = new colorTable[256];
51215:             memset(mColors, 0, 256 * sizeof(colorTable));
51215:         }
51215:         else if (mBIH.compression != BI_BITFIELDS && mBIH.bpp == 16) {
51215:             // Use default 5-5-5 format
51215:             mBitFields.red   = 0x7C00;
51215:             mBitFields.green = 0x03E0;
51215:             mBitFields.blue  = 0x001F;
51215:             CalcBitShift();
51215:         }
51215: 
51215:         PRUint32 imageLength;
51215:         if ((mBIH.compression == BI_RLE8) || (mBIH.compression == BI_RLE4)) {
51215:             rv = mImage->AppendFrame(0, 0, mBIH.width, real_height, gfxASurface::ImageFormatARGB32,
51215:                                      (PRUint8**)&mImageData, &imageLength);
51215:         } else {
51215:             // mRow is not used for RLE encoded images
53676:             mRow = (PRUint8*)moz_malloc((mBIH.width * mBIH.bpp)/8 + 4);
51215:             // +4 because the line is padded to a 4 bit boundary, but I don't want
51215:             // to make exact calculations here, that's unnecessary.
51215:             // Also, it compensates rounding error.
51215:             if (!mRow) {
53662:                 PostDecoderError(NS_ERROR_OUT_OF_MEMORY);
53664:                 return;
51215:             }
51215:             rv = mImage->AppendFrame(0, 0, mBIH.width, real_height, gfxASurface::ImageFormatRGB24,
51215:                                      (PRUint8**)&mImageData, &imageLength);
51215:         }
53664:         if (NS_FAILED(rv) || !mImageData) {
53662:             PostDecoderError(NS_ERROR_FAILURE);
53664:             return;
51215:         }
51215: 
51215:         // Prepare for transparancy
51215:         if ((mBIH.compression == BI_RLE8) || (mBIH.compression == BI_RLE4)) {
51215:             if (((mBIH.compression == BI_RLE8) && (mBIH.bpp != 8)) 
51215:              || ((mBIH.compression == BI_RLE4) && (mBIH.bpp != 4) && (mBIH.bpp != 1))) {
51215:                 PR_LOG(gBMPLog, PR_LOG_DEBUG, ("BMP RLE8/RLE4 compression only supports 8/4 bits per pixel\n"));
53662:                 PostDataError();
53664:                 return;
51215:             }
51215:             // Clear the image, as the RLE may jump over areas
51215:             memset(mImageData, 0, imageLength);
51215:         }
51215: 
51246:         // Tell the superclass we're starting a frame
51246:         PostFrameStart();
51215:     }
51215:     PRUint8 bpc; // bytes per color
51215:     bpc = (mBFH.bihsize == OS2_BIH_LENGTH) ? 3 : 4; // OS/2 Bitmaps have no padding byte
51215:     if (mColors && (mPos >= mLOH && (mPos < (mLOH + mNumColors * bpc)))) {
51215:         // We will receive (mNumColors * bpc) bytes of color data
51215:         PRUint32 colorBytes = mPos - mLOH; // Number of bytes already received
51215:         PRUint8 colorNum = colorBytes / bpc; // Color which is currently received
51215:         PRUint8 at = colorBytes % bpc;
51215:         while (aCount && (mPos < (mLOH + mNumColors * bpc))) {
51215:             switch (at) {
51215:                 case 0:
51215:                     mColors[colorNum].blue = *aBuffer;
51215:                     break;
51215:                 case 1:
51215:                     mColors[colorNum].green = *aBuffer;
51215:                     break;
51215:                 case 2:
51215:                     mColors[colorNum].red = *aBuffer;
51215:                     colorNum++;
51215:                     break;
51215:                 case 3:
51215:                     // This is a padding byte
51215:                     break;
51215:             }
51215:             mPos++; aBuffer++; aCount--;
51215:             at = (at + 1) % bpc;
51215:         }
51215:     }
51215:     else if (aCount && mBIH.compression == BI_BITFIELDS && mPos < (WIN_HEADER_LENGTH + BITFIELD_LENGTH)) {
51215:         // If compression is used, this is a windows bitmap, hence we can
51215:         // use WIN_HEADER_LENGTH instead of mLOH
51215:         PRUint32 toCopy = (WIN_HEADER_LENGTH + BITFIELD_LENGTH) - mPos;
51215:         if (toCopy > aCount)
51215:             toCopy = aCount;
51215:         memcpy(mRawBuf + (mPos - WIN_HEADER_LENGTH), aBuffer, toCopy);
51215:         mPos += toCopy;
51215:         aBuffer += toCopy;
51215:         aCount -= toCopy;
51215:     }
51215:     if (mBIH.compression == BI_BITFIELDS && mPos == WIN_HEADER_LENGTH + BITFIELD_LENGTH) {
51215:         mBitFields.red = LITTLE_TO_NATIVE32(*(PRUint32*)mRawBuf);
51215:         mBitFields.green = LITTLE_TO_NATIVE32(*(PRUint32*)(mRawBuf + 4));
51215:         mBitFields.blue = LITTLE_TO_NATIVE32(*(PRUint32*)(mRawBuf + 8));
51215:         CalcBitShift();
51215:     }
51215:     while (aCount && (mPos < mBFH.dataoffset)) { // Skip whatever is between header and data
51215:         mPos++; aBuffer++; aCount--;
51215:     }
51215:     if (aCount && ++mPos >= mBFH.dataoffset) {
51215:         // Need to increment mPos, else we might get to mPos==mLOH again
51215:         // From now on, mPos is irrelevant
51215:         if (!mBIH.compression || mBIH.compression == BI_BITFIELDS) {
51215:             PRUint32 rowSize = (mBIH.bpp * mBIH.width + 7) / 8; // +7 to round up
51215:             if (rowSize % 4)
51215:                 rowSize += (4 - (rowSize % 4)); // Pad to DWORD Boundary
51215:             PRUint32 toCopy;
51215:             do {
51215:                 toCopy = rowSize - mRowBytes;
51215:                 if (toCopy) {
51215:                     if (toCopy > aCount)
51215:                         toCopy = aCount;
51215:                     memcpy(mRow + mRowBytes, aBuffer, toCopy);
51215:                     aCount -= toCopy;
51215:                     aBuffer += toCopy;
51215:                     mRowBytes += toCopy;
51215:                 }
51215:                 if (rowSize == mRowBytes) {
51215:                     // Collected a whole row into mRow, process it
51215:                     PRUint8* p = mRow;
51215:                     PRUint32* d = mImageData + PIXEL_OFFSET(mCurLine, 0);
51215:                     PRUint32 lpos = mBIH.width;
51215:                     switch (mBIH.bpp) {
51215:                       case 1:
51215:                         while (lpos > 0) {
51215:                           PRInt8 bit;
51215:                           PRUint8 idx;
51215:                           for (bit = 7; bit >= 0 && lpos > 0; bit--) {
51215:                               idx = (*p >> bit) & 1;
51215:                               SetPixel(d, idx, mColors);
51215:                               --lpos;
51215:                           }
51215:                           ++p;
51215:                         }
51215:                         break;
51215:                       case 4:
51215:                         while (lpos > 0) {
51215:                           Set4BitPixel(d, *p, lpos, mColors);
51215:                           ++p;
51215:                         }
51215:                         break;
51215:                       case 8:
51215:                         while (lpos > 0) {
51215:                           SetPixel(d, *p, mColors);
51215:                           --lpos;
51215:                           ++p;
51215:                         }
51215:                         break;
51215:                       case 16:
51215:                         while (lpos > 0) {
51215:                           PRUint16 val = LITTLE_TO_NATIVE16(*(PRUint16*)p);
51215:                           SetPixel(d,
51215:                                   (val & mBitFields.red) >> mBitFields.redRightShift << mBitFields.redLeftShift,
51215:                                   (val & mBitFields.green) >> mBitFields.greenRightShift << mBitFields.greenLeftShift,
51215:                                   (val & mBitFields.blue) >> mBitFields.blueRightShift << mBitFields.blueLeftShift);
51215:                           --lpos;
51215:                           p+=2;
51215:                         }
51215:                         break;
51215:                       case 32:
51215:                       case 24:
51215:                         while (lpos > 0) {
51215:                           SetPixel(d, p[2], p[1], p[0]);
51215:                           p += 2;
51215:                           --lpos;
51215:                           if (mBIH.bpp == 32)
51215:                             p++; // Padding byte
51215:                           ++p;
51215:                         }
51215:                         break;
51215:                       default:
51215:                         NS_NOTREACHED("Unsupported color depth, but earlier check didn't catch it");
51215:                     }
51215:                     mCurLine --;
51215:                     if (mCurLine == 0) { // Finished last line
51215:                         break;
51215:                     }
51215:                     mRowBytes = 0;
51215: 
51215:                 }
51215:             } while (aCount > 0);
51215:         } 
51215:         else if ((mBIH.compression == BI_RLE8) || (mBIH.compression == BI_RLE4)) {
51215:             if (((mBIH.compression == BI_RLE8) && (mBIH.bpp != 8)) 
51215:              || ((mBIH.compression == BI_RLE4) && (mBIH.bpp != 4) && (mBIH.bpp != 1))) {
51215:                 PR_LOG(gBMPLog, PR_LOG_DEBUG, ("BMP RLE8/RLE4 compression only supports 8/4 bits per pixel\n"));
53662:                 PostDataError();
53664:                 return;
51215:             }
51215: 
51215:             while (aCount > 0) {
51215:                 PRUint8 byte;
51215: 
51215:                 switch(mState) {
51215:                     case eRLEStateInitial:
51215:                         mStateData = (PRUint8)*aBuffer++;
51215:                         aCount--;
51215: 
51215:                         mState = eRLEStateNeedSecondEscapeByte;
51215:                         continue;
51215: 
51215:                     case eRLEStateNeedSecondEscapeByte:
51215:                         byte = *aBuffer++;
51215:                         aCount--;
51215:                         if (mStateData != RLE_ESCAPE) { // encoded mode
51215:                             // Encoded mode consists of two bytes: 
51215:                             // the first byte (mStateData) specifies the
51215:                             // number of consecutive pixels to be drawn 
51215:                             // using the color index contained in
51215:                             // the second byte
51215:                             // Work around bitmaps that specify too many pixels
51215:                             mState = eRLEStateInitial;
51215:                             PRUint32 pixelsNeeded = PR_MIN((PRUint32)(mBIH.width - mCurPos), mStateData);
51215:                             if (pixelsNeeded) {
51215:                                 PRUint32* d = mImageData + PIXEL_OFFSET(mCurLine, mCurPos);
51215:                                 mCurPos += pixelsNeeded;
51215:                                 if (mBIH.compression == BI_RLE8) {
51215:                                     do {
51215:                                         SetPixel(d, byte, mColors);
51215:                                         pixelsNeeded --;
51215:                                     } while (pixelsNeeded);
51215:                                 } else {
51215:                                     do {
51215:                                         Set4BitPixel(d, byte, pixelsNeeded, mColors);
51215:                                     } while (pixelsNeeded);
51215:                                 }
51215:                             }
51215:                             continue;
51215:                         }
51215: 
51215:                         switch(byte) {
51215:                             case RLE_ESCAPE_EOL:
51215:                                 // End of Line: Go to next row
51215:                                 mCurLine --;
51215:                                 mCurPos = 0;
51215:                                 mState = eRLEStateInitial;
51215:                                 break;
51215: 
51215:                             case RLE_ESCAPE_EOF: // EndOfFile
51215:                                 mCurPos = mCurLine = 0;
51215:                                 break;
51215: 
51215:                             case RLE_ESCAPE_DELTA:
51215:                                 mState = eRLEStateNeedXDelta;
51215:                                 continue;
51215: 
51215:                             default : // absolute mode
51215:                                 // Save the number of pixels to read
51215:                                 mStateData = byte;
51215:                                 if (mCurPos + mStateData > (PRUint32)mBIH.width) {
51215:                                     // We can work around bitmaps that specify one
51215:                                     // pixel too many, but only if their width is odd.
51215:                                     mStateData -= mBIH.width & 1;
51215:                                     if (mCurPos + mStateData > (PRUint32)mBIH.width) {
53662:                                         PostDataError();
53664:                                         return;
51215:                                     }
51215:                                 }
51215: 
51215:                                 // See if we will need to skip a byte
51215:                                 // to word align the pixel data
51215:                                 // mStateData is a number of pixels
51215:                                 // so allow for the RLE compression type
51215:                                 // Pixels RLE8=1 RLE4=2
51215:                                 //    1    Pad    Pad
51215:                                 //    2    No     Pad
51215:                                 //    3    Pad    No
51215:                                 //    4    No     No
51215:                                 if (((mStateData - 1) & mBIH.compression) != 0)
51215:                                     mState = eRLEStateAbsoluteMode;
51215:                                 else
51215:                                     mState = eRLEStateAbsoluteModePadded;
51215:                                 continue;
51215:                         }
51215:                         break;
51215: 
51215:                     case eRLEStateNeedXDelta:
51215:                         // Handle the XDelta and proceed to get Y Delta
51215:                         byte = *aBuffer++;
51215:                         aCount--;
51215:                         mCurPos += byte;
51215:                         if (mCurPos > mBIH.width)
51215:                             mCurPos = mBIH.width;
51215: 
51215:                         mState = eRLEStateNeedYDelta;
51215:                         continue;
51215: 
51215:                     case eRLEStateNeedYDelta:
51215:                         // Get the Y Delta and then "handle" the move
51215:                         byte = *aBuffer++;
51215:                         aCount--;
51215:                         mState = eRLEStateInitial;
51215:                         mCurLine -= PR_MIN(byte, mCurLine);
51215:                         break;
51215: 
51215:                     case eRLEStateAbsoluteMode: // Absolute Mode
51215:                     case eRLEStateAbsoluteModePadded:
51215:                         if (mStateData) {
51215:                             // In absolute mode, the second byte (mStateData)
51215:                             // represents the number of pixels 
51215:                             // that follow, each of which contains 
51215:                             // the color index of a single pixel.
51215:                             PRUint32* d = mImageData + PIXEL_OFFSET(mCurLine, mCurPos);
51215:                             PRUint32* oldPos = d;
51215:                             if (mBIH.compression == BI_RLE8) {
51215:                                 while (aCount > 0 && mStateData > 0) {
51215:                                     byte = *aBuffer++;
51215:                                     aCount--;
51215:                                     SetPixel(d, byte, mColors);
51215:                                     mStateData--;
51215:                                 }
51215:                             } else {
51215:                                 while (aCount > 0 && mStateData > 0) {
51215:                                     byte = *aBuffer++;
51215:                                     aCount--;
51215:                                     Set4BitPixel(d, byte, mStateData, mColors);
51215:                                 }
51215:                             }
51215:                             mCurPos += d - oldPos;
51215:                         }
51215: 
51215:                         if (mStateData == 0) {
51215:                             // In absolute mode, each run must 
51215:                             // be aligned on a word boundary
51215: 
51215:                             if (mState == eRLEStateAbsoluteMode) { // Word Aligned
51215:                                 mState = eRLEStateInitial;
51215:                             } else if (aCount > 0) {               // Not word Aligned
51215:                                 // "next" byte is just a padding byte
51215:                                 // so "move" past it and we can continue
51215:                                 aBuffer++;
51215:                                 aCount--;
51215:                                 mState = eRLEStateInitial;
51215:                             }
51215:                         }
51215:                         // else state is still eRLEStateAbsoluteMode
51215:                         continue;
51215: 
51215:                     default :
53662:                         NS_ABORT_IF_FALSE(0, "BMP RLE decompression: unknown state!");
53662:                         PostDecoderError(NS_ERROR_UNEXPECTED);
53664:                         return;
51215:                 }
51215:                 // Because of the use of the continue statement
51215:                 // we only get here for eol, eof or y delta
51215:                 if (mCurLine == 0) { // Finished last line
51215:                     break;
51215:                 }
51215:             }
51215:         }
51215:     }
51215:     
51215:     const PRUint32 rows = mOldLine - mCurLine;
51215:     if (rows) {
51592: 
51592:         // Invalidate
51215:         nsIntRect r(0, mBIH.height < 0 ? -mBIH.height - mOldLine : mCurLine,
51215:                     mBIH.width, rows);
51592:         PostInvalidation(r);
51215: 
51215:         mOldLine = mCurLine;
51215:     }
51215: 
53664:     return;
51215: }
51215: 
51215: void nsBMPDecoder::ProcessFileHeader()
51215: {
51215:     memset(&mBFH, 0, sizeof(mBFH));
51215:     memcpy(&mBFH.signature, mRawBuf, sizeof(mBFH.signature));
51215:     memcpy(&mBFH.filesize, mRawBuf + 2, sizeof(mBFH.filesize));
51215:     memcpy(&mBFH.reserved, mRawBuf + 6, sizeof(mBFH.reserved));
51215:     memcpy(&mBFH.dataoffset, mRawBuf + 10, sizeof(mBFH.dataoffset));
51215:     memcpy(&mBFH.bihsize, mRawBuf + 14, sizeof(mBFH.bihsize));
51215: 
51215:     // Now correct the endianness of the header
51215:     mBFH.filesize = LITTLE_TO_NATIVE32(mBFH.filesize);
51215:     mBFH.dataoffset = LITTLE_TO_NATIVE32(mBFH.dataoffset);
51215:     mBFH.bihsize = LITTLE_TO_NATIVE32(mBFH.bihsize);
51215: }
51215: 
51215: void nsBMPDecoder::ProcessInfoHeader()
51215: {
51215:     memset(&mBIH, 0, sizeof(mBIH));
51215:     if (mBFH.bihsize == 12) { // OS/2 Bitmap
51215:         memcpy(&mBIH.width, mRawBuf, 2);
51215:         memcpy(&mBIH.height, mRawBuf + 2, 2);
51215:         memcpy(&mBIH.planes, mRawBuf + 4, sizeof(mBIH.planes));
51215:         memcpy(&mBIH.bpp, mRawBuf + 6, sizeof(mBIH.bpp));
51215:     }
51215:     else {
51215:         memcpy(&mBIH.width, mRawBuf, sizeof(mBIH.width));
51215:         memcpy(&mBIH.height, mRawBuf + 4, sizeof(mBIH.height));
51215:         memcpy(&mBIH.planes, mRawBuf + 8, sizeof(mBIH.planes));
51215:         memcpy(&mBIH.bpp, mRawBuf + 10, sizeof(mBIH.bpp));
51215:         memcpy(&mBIH.compression, mRawBuf + 12, sizeof(mBIH.compression));
51215:         memcpy(&mBIH.image_size, mRawBuf + 16, sizeof(mBIH.image_size));
51215:         memcpy(&mBIH.xppm, mRawBuf + 20, sizeof(mBIH.xppm));
51215:         memcpy(&mBIH.yppm, mRawBuf + 24, sizeof(mBIH.yppm));
51215:         memcpy(&mBIH.colors, mRawBuf + 28, sizeof(mBIH.colors));
51215:         memcpy(&mBIH.important_colors, mRawBuf + 32, sizeof(mBIH.important_colors));
51215:     }
51215: 
51215:     // Convert endianness
51215:     mBIH.width = LITTLE_TO_NATIVE32(mBIH.width);
51215:     mBIH.height = LITTLE_TO_NATIVE32(mBIH.height);
51215:     mBIH.planes = LITTLE_TO_NATIVE16(mBIH.planes);
51215:     mBIH.bpp = LITTLE_TO_NATIVE16(mBIH.bpp);
51215: 
51215:     mBIH.compression = LITTLE_TO_NATIVE32(mBIH.compression);
51215:     mBIH.image_size = LITTLE_TO_NATIVE32(mBIH.image_size);
51215:     mBIH.xppm = LITTLE_TO_NATIVE32(mBIH.xppm);
51215:     mBIH.yppm = LITTLE_TO_NATIVE32(mBIH.yppm);
51215:     mBIH.colors = LITTLE_TO_NATIVE32(mBIH.colors);
51215:     mBIH.important_colors = LITTLE_TO_NATIVE32(mBIH.important_colors);
51215: }
51241: 
51241: } // namespace imagelib
51241: } // namespace mozilla
