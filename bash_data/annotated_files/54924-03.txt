    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
14437: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Henri Sivonen <hsivonen@iki.fi>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsCOMPtr.h"
    1: #include "nsXMLContentSink.h"
    1: #include "nsIParser.h"
    1: #include "nsIUnicharInputStream.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMDocumentType.h"
    1: #include "nsIDOMDOMImplementation.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIContent.h"
    1: #include "nsIURI.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIStyleSheetLinkingElement.h"
    1: #include "nsIDOMComment.h"
    1: #include "nsIDOMCDATASection.h"
    1: #include "nsDOMDocumentType.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsCRT.h"
42163: #include "nsCSSStyleSheet.h"
47937: #include "mozilla/css/Loader.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIContentViewer.h"
    1: #include "prtime.h"
    1: #include "prlog.h"
    1: #include "prmem.h"
    1: #include "nsParserUtils.h"
    1: #include "nsRect.h"
    1: #include "nsGenericElement.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIScriptElement.h"
    1: #include "nsScriptLoader.h"
    1: #include "nsStyleLinkElement.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsICookieService.h"
    1: #include "nsIPrompt.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIChannel.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsXMLPrettyPrinter.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsContentCreatorFunctions.h"
    1: #include "nsIContentPolicy.h"
53996: #include "nsIDocumentViewer.h"
    1: #include "nsContentPolicyUtils.h"
    1: #include "nsContentErrors.h"
    1: #include "nsIDOMProcessingInstruction.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsIScriptGlobalObject.h"
34616: #include "nsIHTMLDocument.h"
14228: #include "mozAutoDocUpdate.h"
38388: #include "nsMimeTypes.h"
    1: 
    1: #ifdef MOZ_SVG
47894: #include "nsHtml5SVGLoadDispatcher.h"
    1: #endif
    1: 
    1: // XXX Open Issues:
    1: // 1) what's not allowed - We need to figure out which HTML tags
    1: //    (prefixed with a HTML namespace qualifier) are explicitly not
    1: //    allowed (if any).
    1: // 2) factoring code with nsHTMLContentSink - There's some amount of
    1: //    common code between this and the HTML content sink. This will
    1: //    increase as we support more and more HTML elements. How can code
    1: //    from the code be factored?
    1: 
    1: nsresult
    1: NS_NewXMLContentSink(nsIXMLContentSink** aResult,
    1:                      nsIDocument* aDoc,
    1:                      nsIURI* aURI,
    1:                      nsISupports* aContainer,
    1:                      nsIChannel* aChannel)
    1: {
    1:   NS_PRECONDITION(nsnull != aResult, "null ptr");
    1:   if (nsnull == aResult) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
47223:   nsXMLContentSink* it = new nsXMLContentSink();
    1:   if (nsnull == it) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   
    1:   nsCOMPtr<nsIXMLContentSink> kungFuDeathGrip = it;
    1:   nsresult rv = it->Init(aDoc, aURI, aContainer, aChannel);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   return CallQueryInterface(it, aResult);
    1: }
    1: 
    1: nsXMLContentSink::nsXMLContentSink()
    1:   : mConstrainSize(PR_TRUE),
34165:     mPrettyPrintXML(PR_TRUE)
    1: {
    1: }
    1: 
    1: nsXMLContentSink::~nsXMLContentSink()
    1: {
    1:   NS_IF_RELEASE(mDocElement);
    1:   if (mText) {
    1:     PR_Free(mText);  //  Doesn't null out, unlike PR_FREEIF
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsXMLContentSink::Init(nsIDocument* aDoc,
    1:                        nsIURI* aURI,
    1:                        nsISupports* aContainer,
    1:                        nsIChannel* aChannel)
    1: {
    1:   nsresult rv = nsContentSink::Init(aDoc, aURI, aContainer, aChannel);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   aDoc->AddObserver(this);
28461:   mIsDocumentObserver = PR_TRUE;
    1: 
    1:   if (!mDocShell) {
    1:     mPrettyPrintXML = PR_FALSE;
    1:   }
    1:   
    1:   mState = eXMLContentSinkState_InProlog;
    1:   mDocElement = nsnull;
    1: 
    1:   return NS_OK;
    1: }
    1: 
11423: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsXMLContentSink)
11423:   NS_INTERFACE_MAP_ENTRY(nsIContentSink)
11423:   NS_INTERFACE_MAP_ENTRY(nsIXMLContentSink)
11423:   NS_INTERFACE_MAP_ENTRY(nsIExpatSink)
11423:   NS_INTERFACE_MAP_ENTRY(nsITransformObserver)
11423: NS_INTERFACE_MAP_END_INHERITING(nsContentSink)
11423: 
11423: NS_IMPL_ADDREF_INHERITED(nsXMLContentSink, nsContentSink)
11423: NS_IMPL_RELEASE_INHERITED(nsXMLContentSink, nsContentSink)
11423: 
11423: NS_IMPL_CYCLE_COLLECTION_CLASS(nsXMLContentSink)
11423: 
11423: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsXMLContentSink,
11423:                                                   nsContentSink)
11423:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCurrentHead)
11423:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_RAWPTR(mDocElement)
11423:   for (PRUint32 i = 0, count = tmp->mContentStack.Length(); i < count; i++) {
11423:     const StackNode& node = tmp->mContentStack.ElementAt(i);
11423:     cb.NoteXPCOMChild(node.mContent);
11423:   }
11423: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: // nsIContentSink
    1: NS_IMETHODIMP
21121: nsXMLContentSink::WillParse(void)
    1: {
21121:   return WillParseImpl();
    1: }
    1: 
    1: NS_IMETHODIMP
29496: nsXMLContentSink::WillBuildModel(nsDTDMode aDTDMode)
    1: {
    1:   WillBuildModelImpl();
    1: 
    1:   // Notify document that the load is beginning
    1:   mDocument->BeginLoad();
    1: 
    1:   // Check for correct load-command for maybe prettyprinting
    1:   if (mPrettyPrintXML) {
    1:     nsCAutoString command;
    1:     mParser->GetCommand(command);
    1:     if (!command.EqualsLiteral("view")) {
    1:       mPrettyPrintXML = PR_FALSE;
    1:     }
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsXMLContentSink::CanStillPrettyPrint()
    1: {
    1:   return mPrettyPrintXML &&
    1:          (!mPrettyPrintHasFactoredElements || mPrettyPrintHasSpecialRoot);
    1: }
    1: 
    1: nsresult
    1: nsXMLContentSink::MaybePrettyPrint()
    1: {
    1:   if (!CanStillPrettyPrint()) {
    1:     mPrettyPrintXML = PR_FALSE;
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // stop observing in order to avoid crashing when replacing content
    1:   mDocument->RemoveObserver(this);
28461:   mIsDocumentObserver = PR_FALSE;
    1: 
    1:   // Reenable the CSSLoader so that the prettyprinting stylesheets can load
    1:   if (mCSSLoader) {
    1:     mCSSLoader->SetEnabled(PR_TRUE);
    1:   }
    1:   
    1:   nsCOMPtr<nsXMLPrettyPrinter> printer;
    1:   nsresult rv = NS_NewXMLPrettyPrinter(getter_AddRefs(printer));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 2026:   PRBool isPrettyPrinting;
 2026:   rv = printer->PrettyPrint(mDocument, &isPrettyPrinting);
 2026:   NS_ENSURE_SUCCESS(rv, rv);
 2026: 
 2026:   mPrettyPrinting = isPrettyPrinting;
 2026:   return NS_OK;
    1: }
    1: 
    1: static void
    1: CheckXSLTParamPI(nsIDOMProcessingInstruction* aPi,
    1:                  nsIDocumentTransformer* aProcessor,
    1:                  nsIDocument* aDocument)
    1: {
    1:   nsAutoString target, data;
    1:   aPi->GetTarget(target);
    1: 
    1:   // Check for namespace declarations
    1:   if (target.EqualsLiteral("xslt-param-namespace")) {
    1:     aPi->GetData(data);
    1:     nsAutoString prefix, namespaceAttr;
    1:     nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::prefix,
    1:                                            prefix);
    1:     if (!prefix.IsEmpty() &&
    1:         nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::_namespace,
    1:                                                namespaceAttr)) {
    1:       aProcessor->AddXSLTParamNamespace(prefix, namespaceAttr);
    1:     }
    1:   }
    1: 
    1:   // Check for actual parameters
    1:   else if (target.EqualsLiteral("xslt-param")) {
    1:     aPi->GetData(data);
    1:     nsAutoString name, namespaceAttr, select, value;
    1:     nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::name,
    1:                                            name);
    1:     nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::_namespace,
    1:                                            namespaceAttr);
    1:     if (!nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::select, select)) {
    1:       select.SetIsVoid(PR_TRUE);
    1:     }
    1:     if (!nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::value, value)) {
    1:       value.SetIsVoid(PR_TRUE);
    1:     }
    1:     if (!name.IsEmpty()) {
    1:       nsCOMPtr<nsIDOMNode> doc = do_QueryInterface(aDocument);
    1:       aProcessor->AddXSLTParam(name, namespaceAttr, select, value, doc);
    1:     }
    1:   }
    1: }
    1: 
    1: NS_IMETHODIMP
33527: nsXMLContentSink::DidBuildModel(PRBool aTerminated)
    1: {
33527:   DidBuildModelImpl(aTerminated);
    1: 
    1:   if (mXSLTProcessor) {
    1:     // stop observing in order to avoid crashing when replacing content
    1:     mDocument->RemoveObserver(this);
28461:     mIsDocumentObserver = PR_FALSE;
    1: 
    1:     // Check for xslt-param and xslt-param-namespace PIs
    1:     PRUint32 i;
    1:     nsIContent* child;
    1:     for (i = 0; (child = mDocument->GetChildAt(i)); ++i) {
    1:       if (child->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION)) {
    1:         nsCOMPtr<nsIDOMProcessingInstruction> pi = do_QueryInterface(child);
    1:         CheckXSLTParamPI(pi, mXSLTProcessor, mDocument);
    1:       }
41637:       else if (child->IsElement()) {
    1:         // Only honor PIs in the prolog
    1:         break;
    1:       }
    1:     }
    1: 
    1:     nsCOMPtr<nsIDOMDocument> currentDOMDoc(do_QueryInterface(mDocument));
    1:     mXSLTProcessor->SetSourceContentModel(currentDOMDoc);
    1:     // Since the processor now holds a reference to us we drop our reference
    1:     // to it to avoid owning cycles
    1:     mXSLTProcessor = nsnull;
    1:   }
    1:   else {
    1:     // Kick off layout for non-XSLT transformed documents.
 2007:     mDocument->ScriptLoader()->RemoveObserver(this);
    1: 
    1:     if (mDocElement) {
    1:       // Notify document observers that all the content has been stuck
    1:       // into the document.
    1:       // XXX do we need to notify for things like PIs?  Or just the
    1:       // documentElement?
    1:       NS_ASSERTION(mDocument->IndexOf(mDocElement) != -1,
    1:                    "mDocElement not in doc?");
    1:     }
    1: 
    1:     // Check if we want to prettyprint
    1:     MaybePrettyPrint();
    1: 
 2026:     PRBool startLayout = PR_TRUE;
 2026:     
 2026:     if (mPrettyPrinting) {
 2026:       NS_ASSERTION(!mPendingSheetCount, "Shouldn't have pending sheets here!");
 2026:       
 2026:       // We're pretty-printing now.  See whether we should wait up on
 2026:       // stylesheet loads
 2026:       if (mDocument->CSSLoader()->HasPendingLoads() &&
 2026:           NS_SUCCEEDED(mDocument->CSSLoader()->AddObserver(this))) {
 2026:         // wait for those sheets to load
 2026:         startLayout = PR_FALSE;
 2026:       }
 2026:     }
 2026:     
 2026:     if (startLayout) {
  681:       StartLayout(PR_FALSE);
    1: 
    1:       ScrollToRef();
 2026:     }
    1: 
    1:     mDocument->RemoveObserver(this);
28461:     mIsDocumentObserver = PR_FALSE;
    1: 
    1:     mDocument->EndLoad();
    1:   }
    1: 
    1:   DropParserAndPerfHint();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::OnDocumentCreated(nsIDocument* aResultDocument)
    1: {
    1:   NS_ENSURE_ARG(aResultDocument);
    1: 
34616:   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(aResultDocument);
34616:   if (htmlDoc) {
34616:     htmlDoc->SetDocWriteDisabled(PR_TRUE);
34616:   }
34616: 
    1:   nsCOMPtr<nsIContentViewer> contentViewer;
    1:   mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
53996:   nsCOMPtr<nsIDocumentViewer> docViewer = do_QueryInterface(contentViewer);
53996:   if (docViewer) {
53996:     return docViewer->SetDocumentInternal(aResultDocument, PR_TRUE);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::OnTransformDone(nsresult aResult,
    1:                                   nsIDocument* aResultDocument)
    1: {
    1:   NS_ASSERTION(NS_FAILED(aResult) || aResultDocument,
    1:                "Don't notify about transform success without a document.");
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(aResultDocument);
    1: 
    1:   nsCOMPtr<nsIContentViewer> contentViewer;
    1:   mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
    1: 
    1:   if (NS_FAILED(aResult) && contentViewer) {
    1:     // Transform failed.
    1:     if (domDoc) {
20272:       aResultDocument->SetMayStartLayout(PR_FALSE);
    1:       // We have an error document.
    1:       contentViewer->SetDOMDocument(domDoc);
    1:     }
    1:     else {
    1:       // We don't have an error document, display the
    1:       // untransformed source document.
    1:       nsCOMPtr<nsIDOMDocument> document = do_QueryInterface(mDocument);
    1:       contentViewer->SetDOMDocument(document);
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocument> originalDocument = mDocument;
    1:   if (NS_SUCCEEDED(aResult) || aResultDocument) {
    1:     // Transform succeeded or it failed and we have an error
    1:     // document to display.
    1:     mDocument = aResultDocument;
34616:     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
34616:     if (htmlDoc) {
34616:       htmlDoc->SetDocWriteDisabled(PR_FALSE);
34616:     }
    1:   }
    1: 
 2007:   originalDocument->ScriptLoader()->RemoveObserver(this);
    1: 
    1:   // Notify document observers that all the content has been stuck
    1:   // into the document.  
    1:   // XXX do we need to notify for things like PIs?  Or just the
    1:   // documentElement?
41634:   nsIContent *rootElement = mDocument->GetRootElement();
41634:   if (rootElement) {
41634:     NS_ASSERTION(mDocument->IndexOf(rootElement) != -1,
41634:                  "rootElement not in doc?");
    1:     mDocument->BeginUpdate(UPDATE_CONTENT_MODEL);
41634:     nsNodeUtils::ContentInserted(mDocument, rootElement,
41634:                                  mDocument->IndexOf(rootElement));
    1:     mDocument->EndUpdate(UPDATE_CONTENT_MODEL);
    1:   }
    1: 
    1:   // Start the layout process
  681:   StartLayout(PR_FALSE);
    1: 
    1:   ScrollToRef();
    1: 
    1:   originalDocument->EndLoad();
    1: 
    1:   return NS_OK;
    1: }
    1: 
 2026: NS_IMETHODIMP
42163: nsXMLContentSink::StyleSheetLoaded(nsCSSStyleSheet* aSheet,
 2026:                                    PRBool aWasAlternate,
 2026:                                    nsresult aStatus)
 2026: {
 2026:   if (!mPrettyPrinting) {
 2026:     return nsContentSink::StyleSheetLoaded(aSheet, aWasAlternate, aStatus);
 2026:   }
 2026: 
 2026:   if (!mDocument->CSSLoader()->HasPendingLoads()) {
 2026:     mDocument->CSSLoader()->RemoveObserver(this);
 2026:     StartLayout(PR_FALSE);
 2026:     ScrollToRef();
 2026:   }
 2026: 
 2026:   return NS_OK;
 2026: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::WillInterrupt(void)
    1: {
    1:   return WillInterruptImpl();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::WillResume(void)
    1: {
    1:   return WillResumeImpl();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::SetParser(nsIParser* aParser)
    1: {
  854:   NS_PRECONDITION(aParser, "Should have a parser here!");
    1:   mParser = aParser;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXMLContentSink::CreateElement(const PRUnichar** aAtts, PRUint32 aAttsCount,
    1:                                 nsINodeInfo* aNodeInfo, PRUint32 aLineNumber,
19719:                                 nsIContent** aResult, PRBool* aAppendContent,
43386:                                 PRUint32 aFromParser)
    1: {
    1:   NS_ASSERTION(aNodeInfo, "can't create element without nodeinfo");
    1: 
    1:   *aResult = nsnull;
    1:   *aAppendContent = PR_TRUE;
    1:   nsresult rv = NS_OK;
    1: 
48124:   nsCOMPtr<nsINodeInfo> ni = aNodeInfo;
    1:   nsCOMPtr<nsIContent> content;
    1:   rv = NS_NewElement(getter_AddRefs(content), aNodeInfo->NamespaceID(),
48124:                      ni.forget(), aFromParser);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (aNodeInfo->Equals(nsGkAtoms::script, kNameSpaceID_XHTML)
    1: #ifdef MOZ_SVG
    1:       || aNodeInfo->Equals(nsGkAtoms::script, kNameSpaceID_SVG)
    1: #endif
    1:     ) {
    1:     nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(content);
    1:     sele->SetScriptLineNumber(aLineNumber);
    1:     mConstrainSize = PR_FALSE;
    1:   }
    1: 
    1:   // XHTML needs some special attention
    1:   if (aNodeInfo->NamespaceEquals(kNameSpaceID_XHTML)) {
    1:     mPrettyPrintHasFactoredElements = PR_TRUE;
    1:   }
    1:   else {
    1:     // If we care, find out if we just used a special factory.
    1:     if (!mPrettyPrintHasFactoredElements && !mPrettyPrintHasSpecialRoot &&
    1:         mPrettyPrintXML) {
    1:       mPrettyPrintHasFactoredElements =
    1:         nsContentUtils::NameSpaceManager()->
    1:           HasElementCreator(aNodeInfo->NamespaceID());
    1:     }
    1: 
    1:     if (!aNodeInfo->NamespaceEquals(kNameSpaceID_SVG)) {
    1:       content.swap(*aResult);
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
16977:   if (aNodeInfo->Equals(nsGkAtoms::link, kNameSpaceID_XHTML) ||
    1:       aNodeInfo->Equals(nsGkAtoms::style, kNameSpaceID_XHTML) ||
    1:       aNodeInfo->Equals(nsGkAtoms::style, kNameSpaceID_SVG)) {
    1:     nsCOMPtr<nsIStyleSheetLinkingElement> ssle(do_QueryInterface(content));
    1:     if (ssle) {
  681:       ssle->InitStyleLinkElement(PR_FALSE);
    1:       ssle->SetEnableUpdates(PR_FALSE);
    1:       if (!aNodeInfo->Equals(nsGkAtoms::link, kNameSpaceID_XHTML)) {
    1:         ssle->SetLineNumber(aLineNumber);
    1:       }
    1:     }
    1:   } 
    1: 
    1:   content.swap(*aResult);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXMLContentSink::CloseElement(nsIContent* aContent)
    1: {
    1:   NS_ASSERTION(aContent, "missing element to close");
    1: 
    1:   nsINodeInfo *nodeInfo = aContent->NodeInfo();
    1: 
    1:   // Some HTML nodes need DoneAddingChildren() called to initialize
    1:   // properly (eg form state restoration).
    1:   if ((nodeInfo->NamespaceID() == kNameSpaceID_XHTML &&
    1:        (nodeInfo->NameAtom() == nsGkAtoms::select ||
    1:         nodeInfo->NameAtom() == nsGkAtoms::textarea ||
15751: #ifdef MOZ_MEDIA
15751:         nodeInfo->NameAtom() == nsGkAtoms::video ||
15751:         nodeInfo->NameAtom() == nsGkAtoms::audio ||
15751: #endif
    1:         nodeInfo->NameAtom() == nsGkAtoms::object ||
    1:         nodeInfo->NameAtom() == nsGkAtoms::applet))
    1: #ifdef MOZ_XTF
    1:       || nodeInfo->NamespaceID() > kNameSpaceID_LastBuiltin
    1: #endif
16977:       || nodeInfo->NameAtom() == nsGkAtoms::title
    1:       ) {
14437:     aContent->DoneAddingChildren(HaveNotifiedForCurrentContent());
    1:   }
    1:   
    1:   if (IsMonolithicContainer(nodeInfo)) {
    1:     mInMonolithicContainer--;
    1:   }
    1: 
    1:   if (!nodeInfo->NamespaceEquals(kNameSpaceID_XHTML) &&
    1:       !nodeInfo->NamespaceEquals(kNameSpaceID_SVG)) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (nodeInfo->Equals(nsGkAtoms::script, kNameSpaceID_XHTML)
    1: #ifdef MOZ_SVG
    1:       || nodeInfo->Equals(nsGkAtoms::script, kNameSpaceID_SVG)
    1: #endif
    1:     ) {
    1:     mConstrainSize = PR_TRUE; 
    1: 
    1:     // Now tell the script that it's ready to go. This may execute the script
    1:     // or return NS_ERROR_HTMLPARSER_BLOCK. Or neither if the script doesn't
    1:     // need executing.
    1:     rv = aContent->DoneAddingChildren(PR_TRUE);
    1: 
    1:     // If the act of insertion evaluated the script, we're fine.
    1:     // Else, block the parser till the script has loaded.
    1:     if (rv == NS_ERROR_HTMLPARSER_BLOCK) {
    1:       nsCOMPtr<nsIScriptElement> sele = do_QueryInterface(aContent);
    1:       mScriptElements.AppendObject(sele);
    1:     }
    1: 
    1:     // If the parser got blocked, make sure to return the appropriate rv.
    1:     // I'm not sure if this is actually needed or not.
    1:     if (mParser && !mParser->IsParserEnabled()) {
    1:       // XXX The HTML sink doesn't call BlockParser here, why do we?
    1:       mParser->BlockParser();
    1:       rv = NS_ERROR_HTMLPARSER_BLOCK;
    1:     }
    1: 
    1:     return rv;
    1:   }
    1:   
41221:   if (nodeInfo->Equals(nsGkAtoms::meta, kNameSpaceID_XHTML) &&
    1:            // Need to check here to make sure this meta tag does not set
    1:            // mPrettyPrintXML to false when we have a special root!
    1:            (!mPrettyPrintXML || !mPrettyPrintHasSpecialRoot)) {
    1:     rv = ProcessMETATag(aContent);
    1:   }
    1:   else if (nodeInfo->Equals(nsGkAtoms::link, kNameSpaceID_XHTML) ||
    1:            nodeInfo->Equals(nsGkAtoms::style, kNameSpaceID_XHTML) ||
    1:            nodeInfo->Equals(nsGkAtoms::style, kNameSpaceID_SVG)) {
    1:     nsCOMPtr<nsIStyleSheetLinkingElement> ssle(do_QueryInterface(aContent));
    1:     if (ssle) {
    1:       ssle->SetEnableUpdates(PR_TRUE);
  681:       PRBool willNotify;
  681:       PRBool isAlternate;
  681:       rv = ssle->UpdateStyleSheet(this, &willNotify, &isAlternate);
  681:       if (NS_SUCCEEDED(rv) && willNotify && !isAlternate) {
  681:         ++mPendingSheetCount;
  681:         mScriptLoader->AddExecuteBlocker();
    1:       }
    1:     }
21577:     // Look for <link rel="dns-prefetch" href="hostname">
21577:     if (nodeInfo->Equals(nsGkAtoms::link, kNameSpaceID_XHTML)) {
21577:       nsAutoString relVal;
21577:       aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::rel, relVal);
21577:       if (relVal.EqualsLiteral("dns-prefetch")) {
21577:         nsAutoString hrefVal;
21577:         aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::href, hrefVal);
21577:         if (!hrefVal.IsEmpty()) {
21577:           PrefetchDNS(hrefVal);
21577:         }
21577:       }
21577:     }
    1:   }
    1: 
    1:   return rv;
    1: }  
    1: 
    1: nsresult
    1: nsXMLContentSink::AddContentAsLeaf(nsIContent *aContent)
    1: {
    1:   nsresult result = NS_OK;
    1: 
    1:   if ((eXMLContentSinkState_InProlog == mState) ||
    1:       (eXMLContentSinkState_InEpilog == mState)) {
    1:     NS_ASSERTION(mDocument, "Fragments have no prolog or epilog");
    1:     mDocument->AppendChildTo(aContent, PR_FALSE);
    1:   }
    1:   else {
    1:     nsCOMPtr<nsIContent> parent = GetCurrentContent();
    1: 
    1:     if (parent) {
    1:       result = parent->AppendChildTo(aContent, PR_FALSE);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: // Create an XML parser and an XSL content sink and start parsing
    1: // the XSL stylesheet located at the given URI.
    1: nsresult
    1: nsXMLContentSink::LoadXSLStyleSheet(nsIURI* aUrl)
    1: {
14436:   nsCOMPtr<nsIDocumentTransformer> processor =
    1:     do_CreateInstance("@mozilla.org/document-transformer;1?type=xslt");
14436:   if (!processor) {
    1:     // No XSLT processor available, continue normal document loading
    1:     return NS_OK;
    1:   }
    1: 
14436:   processor->Init(mDocument->NodePrincipal());
14436:   processor->SetTransformObserver(this);
    1: 
    1:   nsCOMPtr<nsILoadGroup> loadGroup = mDocument->GetDocumentLoadGroup();
    1:   if (!loadGroup) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
14436:   if (NS_SUCCEEDED(processor->LoadStyleSheet(aUrl, loadGroup))) {
14436:     mXSLTProcessor.swap(processor);
14436:   }
14436: 
14436:   // Intentionally ignore errors here, we should continue loading the
14436:   // XML document whether we're able to load the XSLT stylesheet or
14436:   // not.
14436: 
14436:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXMLContentSink::ProcessStyleLink(nsIContent* aElement,
    1:                                    const nsSubstring& aHref,
    1:                                    PRBool aAlternate,
    1:                                    const nsSubstring& aTitle,
    1:                                    const nsSubstring& aType,
    1:                                    const nsSubstring& aMedia)
    1: {
    1:   nsresult rv = NS_OK;
    1:   mPrettyPrintXML = PR_FALSE;
    1: 
    1:   nsCAutoString cmd;
    1:   if (mParser)
    1:     mParser->GetCommand(cmd);
    1:   if (cmd.EqualsASCII(kLoadAsData))
    1:     return NS_OK; // Do not load stylesheets when loading as data
    1: 
    1:   NS_ConvertUTF16toUTF8 type(aType);
38388:   if (type.EqualsIgnoreCase(TEXT_XSL) ||
38388:       type.EqualsIgnoreCase(TEXT_XML) ||
38388:       type.EqualsIgnoreCase(APPLICATION_XML)) {
    1:     if (aAlternate) {
    1:       // don't load alternate XSLT
    1:       return NS_OK;
    1:     }
    1:     // LoadXSLStyleSheet needs a mDocShell.
    1:     if (!mDocShell)
    1:       return NS_OK;
    1: 
    1:     nsCOMPtr<nsIURI> url;
41221:     rv = NS_NewURI(getter_AddRefs(url), aHref, nsnull,
41900:                    mDocument->GetDocBaseURI());
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Do security check
    1:     nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
    1:     rv = secMan->
12531:       CheckLoadURIWithPrincipal(mDocument->NodePrincipal(), url,
12531:                                 nsIScriptSecurityManager::ALLOW_CHROME);
    1:     NS_ENSURE_SUCCESS(rv, NS_OK);
    1: 
    1:     // Do content policy check
    1:     PRInt16 decision = nsIContentPolicy::ACCEPT;
    1:     rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_STYLESHEET,
    1:                                    url,
 4367:                                    mDocument->NodePrincipal(),
    1:                                    aElement,
    1:                                    type,
    1:                                    nsnull,
    1:                                    &decision,
 4367:                                    nsContentUtils::GetContentPolicy(),
 4367:                                    nsContentUtils::GetSecurityManager());
    1: 
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (NS_CP_REJECTED(decision)) {
    1:       return NS_OK;
    1:     }
    1: 
    1:     return LoadXSLStyleSheet(url);
    1:   }
    1: 
    1:   // Let nsContentSink deal with css.
    1:   rv = nsContentSink::ProcessStyleLink(aElement, aHref, aAlternate,
    1:                                        aTitle, aType, aMedia);
    1: 
  681:   // nsContentSink::ProcessStyleLink handles the bookkeeping here wrt
  681:   // pending sheets.
    1:   
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsXMLContentSink::SetDocumentCharset(nsACString& aCharset)
    1: {
    1:   if (mDocument) {
    1:     mDocument->SetDocumentCharacterSet(aCharset);
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsISupports *
    1: nsXMLContentSink::GetTarget()
    1: {
    1:   return mDocument;
    1: }
    1: 
27387: PRBool
27387: nsXMLContentSink::IsScriptExecuting()
27387: {
27387:   return IsScriptExecutingImpl();
27387: }
27387: 
    1: nsresult
20517: nsXMLContentSink::FlushText(PRBool aReleaseTextNode)
    1: {
20517:   nsresult rv = NS_OK;
20517: 
20517:   if (mTextLength != 0) {
20517:     if (mLastTextNode) {
20517:       if ((mLastTextNodeSize + mTextLength) > mTextSize && !mXSLTProcessor) {
20517:         mLastTextNodeSize = 0;
20517:         mLastTextNode = nsnull;
20517:         FlushText(aReleaseTextNode);
20517:       } else {
20517:         PRBool notify = HaveNotifiedForCurrentContent();
20517:         // We could probably always increase mInNotification here since
20517:         // if AppendText doesn't notify it shouldn't trigger evil code.
20517:         // But just in case it does, we don't want to mask any notifications.
20517:         if (notify) {
20517:           ++mInNotification;
20517:         }
20517:         rv = mLastTextNode->AppendText(mText, mTextLength, notify);
20517:         if (notify) {
20517:           --mInNotification;
 2835:         }
 2835: 
20517:         mLastTextNodeSize += mTextLength;
20517:         mTextLength = 0;
20517:       }
20517:     } else {
    1:       nsCOMPtr<nsIContent> textContent;
20517:       rv = NS_NewTextNode(getter_AddRefs(textContent),
20517:                           mNodeInfoManager);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
20517:       mLastTextNode = textContent;
20517:       
    1:       // Set the text in the text node
    1:       textContent->SetText(mText, mTextLength, PR_FALSE);
20517:       mLastTextNodeSize += mTextLength;
 2835:       mTextLength = 0;
    1: 
    1:       // Add text to its parent
20517:       rv = AddContentAsLeaf(textContent);
20517:     }
20517:   }
20517: 
20517:   if (aReleaseTextNode) {
20517:     mLastTextNodeSize = 0;
20517:     mLastTextNode = nsnull;
20517:   }
20517:   
20517:   return rv;
    1: }
    1: 
    1: nsIContent*
    1: nsXMLContentSink::GetCurrentContent()
    1: {
    1:   if (mContentStack.Length() == 0) {
    1:     return nsnull;
    1:   }
54924:   return GetCurrentStackNode()->mContent;
    1: }
    1: 
54924: StackNode*
    1: nsXMLContentSink::GetCurrentStackNode()
    1: {
    1:   PRInt32 count = mContentStack.Length();
54924:   return count != 0 ? &mContentStack[count-1] : nsnull;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXMLContentSink::PushContent(nsIContent *aContent)
    1: {
    1:   NS_PRECONDITION(aContent, "Null content being pushed!");
    1:   StackNode *sn = mContentStack.AppendElement();
    1:   NS_ENSURE_TRUE(sn, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   sn->mContent = aContent;
    1:   sn->mNumFlushed = 0;
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsXMLContentSink::PopContent()
    1: {
    1:   PRInt32 count = mContentStack.Length();
    1: 
    1:   if (count == 0) {
    1:     NS_WARNING("Popping empty stack");
    1:     return;
    1:   }
    1: 
    1:   mContentStack.RemoveElementAt(count - 1);
    1: }
    1: 
14437: PRBool
14437: nsXMLContentSink::HaveNotifiedForCurrentContent() const
14437: {
14437:   PRUint32 stackLength = mContentStack.Length();
14437:   if (stackLength) {
14437:     const StackNode& stackNode = mContentStack[stackLength - 1];
14437:     nsIContent* parent = stackNode.mContent;
14437:     return stackNode.mNumFlushed == parent->GetChildCount();
14437:   }
14437:   return PR_TRUE;
14437: }
14437: 
    1: void
  681: nsXMLContentSink::MaybeStartLayout(PRBool aIgnorePendingSheets)
    1: {
  681:   // XXXbz if aIgnorePendingSheets is true, what should we do when
  681:   // mXSLTProcessor or CanStillPrettyPrint()?
    1:   if (mLayoutStarted || mXSLTProcessor || CanStillPrettyPrint()) {
    1:     return;
    1:   }
  681:   StartLayout(aIgnorePendingSheets);
    1: }
    1: 
    1: ////////////////////////////////////////////////////////////////////////
    1: 
    1: PRBool
    1: nsXMLContentSink::SetDocElement(PRInt32 aNameSpaceID,
    1:                                 nsIAtom* aTagName,
    1:                                 nsIContent *aContent)
    1: {
    1:   if (mDocElement)
    1:     return PR_FALSE;
    1: 
    1:   // check for root elements that needs special handling for
    1:   // prettyprinting
    1:   if ((aNameSpaceID == kNameSpaceID_XBL &&
    1:        aTagName == nsGkAtoms::bindings) ||
    1:       (aNameSpaceID == kNameSpaceID_XSLT &&
    1:        (aTagName == nsGkAtoms::stylesheet ||
    1:         aTagName == nsGkAtoms::transform))) {
    1:     mPrettyPrintHasSpecialRoot = PR_TRUE;
    1:     if (mPrettyPrintXML) {
    1:       // In this case, disable script execution, stylesheet
    1:       // loading, and auto XLinks since we plan to prettyprint.
 2007:       mDocument->ScriptLoader()->SetEnabled(PR_FALSE);
    1:       if (mCSSLoader) {
    1:         mCSSLoader->SetEnabled(PR_FALSE);
    1:       }
    1:     }        
    1:   }
    1: 
    1:   mDocElement = aContent;
    1:   NS_ADDREF(mDocElement);
41743:   nsresult rv = mDocument->AppendChildTo(mDocElement, NotifyForDocElement());
    1:   if (NS_FAILED(rv)) {
    1:     // If we return PR_FALSE here, the caller will bail out because it won't
    1:     // find a parent content node to append to, which is fine.
    1:     return PR_FALSE;
    1:   }
24809: 
24809:   if (aTagName == nsGkAtoms::html &&
24809:       aNameSpaceID == kNameSpaceID_XHTML) {
24809:     ProcessOfflineManifest(aContent);
24809:   }
24809: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::HandleStartElement(const PRUnichar *aName,
    1:                                      const PRUnichar **aAtts,
    1:                                      PRUint32 aAttsCount,
    1:                                      PRInt32 aIndex,
    1:                                      PRUint32 aLineNumber)
    1: {
 2266:   return HandleStartElement(aName, aAtts, aAttsCount, aIndex, aLineNumber,
 2266:                             PR_TRUE);
 2266: }
 2266: 
 2266: nsresult
 2266: nsXMLContentSink::HandleStartElement(const PRUnichar *aName,
 2266:                                      const PRUnichar **aAtts,
 2266:                                      PRUint32 aAttsCount,
 2266:                                      PRInt32 aIndex,
 2266:                                      PRUint32 aLineNumber,
 2266:                                      PRBool aInterruptable)
 2266: {
    1:   NS_PRECONDITION(aIndex >= -1, "Bogus aIndex");
    1:   NS_PRECONDITION(aAttsCount % 2 == 0, "incorrect aAttsCount");
    1:   // Adjust aAttsCount so it's the actual number of attributes
    1:   aAttsCount /= 2;
    1: 
    1:   nsresult result = NS_OK;
    1:   PRBool appendContent = PR_TRUE;
    1:   nsCOMPtr<nsIContent> content;
    1: 
    1:   // XXX Hopefully the parser will flag this before we get
    1:   // here. If we're in the epilog, there should be no
    1:   // new elements
    1:   PR_ASSERT(eXMLContentSinkState_InEpilog != mState);
    1: 
    1:   FlushText();
    1:   DidAddContent();
    1: 
    1:   mState = eXMLContentSinkState_InDocumentElement;
    1: 
    1:   PRInt32 nameSpaceID;
    1:   nsCOMPtr<nsIAtom> prefix, localName;
    1:   nsContentUtils::SplitExpatName(aName, getter_AddRefs(prefix),
    1:                                  getter_AddRefs(localName), &nameSpaceID);
    1: 
    1:   if (!OnOpenContainer(aAtts, aAttsCount, nameSpaceID, localName, aLineNumber)) {
    1:     return NS_OK;
    1:   }
    1:   
    1:   nsCOMPtr<nsINodeInfo> nodeInfo;
19197:   nodeInfo = mNodeInfoManager->GetNodeInfo(localName, prefix, nameSpaceID);
19747:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   result = CreateElement(aAtts, aAttsCount, nodeInfo, aLineNumber,
19719:                          getter_AddRefs(content), &appendContent, PR_TRUE);
    1:   NS_ENSURE_SUCCESS(result, result);
    1: 
 1499:   // Have to do this before we push the new content on the stack... and have to
 1499:   // do that before we set attributes, call BindToTree, etc.  Ideally we'd push
 1499:   // on the stack inside CreateElement (which is effectively what the HTML sink
 1499:   // does), but that's hard with all the subclass overrides going on.
 1499:   nsCOMPtr<nsIContent> parent = GetCurrentContent();
 1499:   
 1499:   result = PushContent(content);
 1499:   NS_ENSURE_SUCCESS(result, result);
 1499: 
    1:   // Set the ID attribute atom on the node info object for this node
    1:   // This must occur before the attributes are added so the name
    1:   // of the id attribute is known.
    1:   if (aIndex != -1 && NS_SUCCEEDED(result)) {
    1:     nsCOMPtr<nsIAtom> IDAttr = do_GetAtom(aAtts[aIndex]);
    1: 
    1:     if (IDAttr) {
    1:       nodeInfo->SetIDAttributeAtom(IDAttr);
    1:     }
    1:   }
    1:   
    1: #ifdef MOZ_XTF
    1:   if (nameSpaceID > kNameSpaceID_LastBuiltin)
    1:     content->BeginAddingChildren();
    1: #endif
    1: 
    1:   // Set the attributes on the new content element
    1:   result = AddAttributes(aAtts, content);
    1: 
    1:   if (NS_OK == result) {
    1:     // Store the element 
    1:     if (!SetDocElement(nameSpaceID, localName, content) && appendContent) {
    1:       NS_ENSURE_TRUE(parent, NS_ERROR_UNEXPECTED);
    1: 
    1:       parent->AppendChildTo(content, PR_FALSE);
    1:     }
    1:   }
    1: 
    1:   // Some HTML nodes need DoneCreatingElement() called to initialize
    1:   // properly (eg form state restoration).
 3317:   if (nodeInfo->NamespaceID() == kNameSpaceID_XHTML) {
 3317:     if (nodeInfo->NameAtom() == nsGkAtoms::input ||
 3317:         nodeInfo->NameAtom() == nsGkAtoms::button) {
    1:       content->DoneCreatingElement();
 3317:     } else if (nodeInfo->NameAtom() == nsGkAtoms::head && !mCurrentHead) {
 3317:       mCurrentHead = content;
 3317:     }
    1:   }
    1: 
    1:   if (IsMonolithicContainer(nodeInfo)) {
    1:     mInMonolithicContainer++;
    1:   }
    1: 
 3317:   if (content != mDocElement && !mCurrentHead) {
 3317:     // This isn't the root and we're not inside an XHTML <head>.
 3317:     // Might need to start layout
  681:     MaybeStartLayout(PR_FALSE);
 3317:   }
    1: 
51669:   if (content == mDocElement) {
51669:     NotifyDocElementCreated(mDocument);
51669:   }
51669: 
 2266:   return aInterruptable && NS_SUCCEEDED(result) ? DidProcessATokenImpl() :
 2266:                                                   result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::HandleEndElement(const PRUnichar *aName)
    1: {
 2266:   return HandleEndElement(aName, PR_TRUE);
 2266: }
 2266: 
 2266: nsresult
 2266: nsXMLContentSink::HandleEndElement(const PRUnichar *aName,
 2266:                                    PRBool aInterruptable)
 2266: {
    1:   nsresult result = NS_OK;
    1: 
    1:   // XXX Hopefully the parser will flag this before we get
    1:   // here. If we're in the prolog or epilog, there should be
    1:   // no close tags for elements.
    1:   PR_ASSERT(eXMLContentSinkState_InDocumentElement == mState);
    1: 
    1:   FlushText();
    1: 
54924:   StackNode* sn = GetCurrentStackNode();
54924:   if (!sn) {
54924:     return NS_ERROR_UNEXPECTED;
54924:   }
    1: 
    1:   nsCOMPtr<nsIContent> content;
54924:   sn->mContent.swap(content);
54924:   PRUint32 numFlushed = sn->mNumFlushed;
    1: 
    1:   PopContent();
    1:   NS_ASSERTION(content, "failed to pop content");
    1: #ifdef DEBUG
    1:   // Check that we're closing the right thing
    1:   nsCOMPtr<nsIAtom> debugNameSpacePrefix, debugTagAtom;
    1:   PRInt32 debugNameSpaceID;
    1:   nsContentUtils::SplitExpatName(aName, getter_AddRefs(debugNameSpacePrefix),
    1:                                  getter_AddRefs(debugTagAtom),
    1:                                  &debugNameSpaceID);
    1:   NS_ASSERTION(content->NodeInfo()->Equals(debugTagAtom, debugNameSpaceID),
    1:                "Wrong element being closed");
    1: #endif  
    1: 
    1:   result = CloseElement(content);
    1: 
 3317:   if (mCurrentHead == content) {
 3317:     mCurrentHead = nsnull;
 3317:   }
 3317:   
    1:   if (mDocElement == content) {
    1:     // XXXbz for roots that don't want to be appended on open, we
    1:     // probably need to deal here.... (and stop appending them on open).
    1:     mState = eXMLContentSinkState_InEpilog;
 3317: 
 3317:     // We might have had no occasion to start layout yet.  Do so now.
 3317:     MaybeStartLayout(PR_FALSE);
    1:   }
    1: 
    1:   PRInt32 stackLen = mContentStack.Length();
    1:   if (mNotifyLevel >= stackLen) {
    1:     if (numFlushed < content->GetChildCount()) {
    1:     	  NotifyAppend(content, numFlushed);
    1:     }
    1:     mNotifyLevel = stackLen - 1;
    1:   }
    1:   DidAddContent();
    1: 
    1: #ifdef MOZ_SVG
47894:   if (content->GetNameSpaceID() == kNameSpaceID_SVG &&
47894:       content->Tag() == nsGkAtoms::svg) {
 1795:     FlushTags();
47894:     nsCOMPtr<nsIRunnable> event = new nsHtml5SVGLoadDispatcher(content);
47894:     if (NS_FAILED(NS_DispatchToMainThread(event))) {
47894:       NS_WARNING("failed to dispatch svg load dispatcher");
    1:     }
    1:   }
    1: #endif
    1: 
 2266:   return aInterruptable && NS_SUCCEEDED(result) ? DidProcessATokenImpl() :
 2266:                                                   result;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsXMLContentSink::HandleComment(const PRUnichar *aName)
    1: {
    1:   FlushText();
    1: 
    1:   nsCOMPtr<nsIContent> comment;
    1:   nsresult rv = NS_NewCommentNode(getter_AddRefs(comment), mNodeInfoManager);
    1:   if (comment) {
    1:     comment->SetText(nsDependentString(aName), PR_FALSE);
    1:     rv = AddContentAsLeaf(comment);
    1:     DidAddContent();
    1:   }
    1: 
    1:   return NS_SUCCEEDED(rv) ? DidProcessATokenImpl() : rv;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsXMLContentSink::HandleCDataSection(const PRUnichar *aData, 
    1:                                      PRUint32 aLength)
    1: {
    1:   // XSLT doesn't differentiate between text and cdata and wants adjacent
    1:   // textnodes merged, so add as text.
    1:   if (mXSLTProcessor) {
    1:     return AddText(aData, aLength);
    1:   }
    1: 
    1:   FlushText();
    1:   
    1:   nsCOMPtr<nsIContent> cdata;
    1:   nsresult rv = NS_NewXMLCDATASection(getter_AddRefs(cdata), mNodeInfoManager);
    1:   if (cdata) {
    1:     cdata->SetText(aData, aLength, PR_FALSE);
    1:     rv = AddContentAsLeaf(cdata);
    1:     DidAddContent();
    1:   }
    1: 
    1:   return NS_SUCCEEDED(rv) ? DidProcessATokenImpl() : rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::HandleDoctypeDecl(const nsAString & aSubset, 
    1:                                     const nsAString & aName, 
    1:                                     const nsAString & aSystemId, 
    1:                                     const nsAString & aPublicId,
    1:                                     nsISupports* aCatalogData)
    1: {
    1:   FlushText();
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   NS_ASSERTION(mDocument, "Shouldn't get here from a document fragment");
    1: 
    1:   nsCOMPtr<nsIAtom> name = do_GetAtom(aName);
    1:   NS_ENSURE_TRUE(name, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // Create a new doctype node
    1:   nsCOMPtr<nsIDOMDocumentType> docType;
    1:   rv = NS_NewDOMDocumentType(getter_AddRefs(docType), mNodeInfoManager, nsnull,
    1:                              name, nsnull, nsnull, aPublicId, aSystemId,
    1:                              aSubset);
    1:   if (NS_FAILED(rv) || !docType) {
    1:     return rv;
    1:   }
    1: 
    1:   if (aCatalogData && mCSSLoader && mDocument) {
    1:     // bug 124570 - we only expect additional agent sheets for now -- ignore
    1:     // exit codes, error are not fatal here, just that the stylesheet won't apply
    1:     nsCOMPtr<nsIURI> uri(do_QueryInterface(aCatalogData));
    1:     if (uri) {
42163:       nsRefPtr<nsCSSStyleSheet> sheet;
26242:       mCSSLoader->LoadSheetSync(uri, PR_TRUE, PR_TRUE, getter_AddRefs(sheet));
    1: 
    1: #ifdef NS_DEBUG
    1:       nsCAutoString uriStr;
    1:       uri->GetSpec(uriStr);
    1:       printf("Loading catalog stylesheet: %s ... %s\n", uriStr.get(), sheet.get() ? "Done" : "Failed");
    1: #endif
    1:       if (sheet) {
    1:         mDocument->BeginUpdate(UPDATE_STYLE);
    1:         mDocument->AddCatalogStyleSheet(sheet);
    1:         mDocument->EndUpdate(UPDATE_STYLE);
    1:       }
    1:     }
    1:   }
    1: 
    1:   nsCOMPtr<nsIContent> content = do_QueryInterface(docType);
    1:   NS_ASSERTION(content, "doctype isn't content?");
    1: 
    1:   rv = mDocument->AppendChildTo(content, PR_FALSE);
    1:   DidAddContent();
    1:   return NS_SUCCEEDED(rv) ? DidProcessATokenImpl() : rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::HandleCharacterData(const PRUnichar *aData, 
    1:                                       PRUint32 aLength)
    1: {
 2266:   return HandleCharacterData(aData, aLength, PR_TRUE);
 2266: }
 2266: 
 2266: nsresult
 2266: nsXMLContentSink::HandleCharacterData(const PRUnichar *aData, PRUint32 aLength,
 2266:                                       PRBool aInterruptable)
 2266: {
    1:   nsresult rv = NS_OK;
    1:   if (aData && mState != eXMLContentSinkState_InProlog &&
    1:       mState != eXMLContentSinkState_InEpilog) {
    1:     rv = AddText(aData, aLength);
    1:   }
 2266:   return aInterruptable && NS_SUCCEEDED(rv) ? DidProcessATokenImpl() : rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::HandleProcessingInstruction(const PRUnichar *aTarget, 
    1:                                               const PRUnichar *aData)
    1: {
    1:   FlushText();
    1: 
    1:   const nsDependentString target(aTarget);
    1:   const nsDependentString data(aData);
    1: 
    1:   nsCOMPtr<nsIContent> node;
    1: 
    1:   nsresult rv = NS_NewXMLProcessingInstruction(getter_AddRefs(node),
    1:                                                mNodeInfoManager, target, data);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIStyleSheetLinkingElement> ssle(do_QueryInterface(node));
    1:   if (ssle) {
  681:     ssle->InitStyleLinkElement(PR_FALSE);
    1:     ssle->SetEnableUpdates(PR_FALSE);
    1:     mPrettyPrintXML = PR_FALSE;
    1:   }
    1: 
    1:   rv = AddContentAsLeaf(node);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   DidAddContent();
    1: 
    1:   if (ssle) {
  681:     // This is an xml-stylesheet processing instruction... but it might not be
  681:     // a CSS one if the type is set to something else.
    1:     ssle->SetEnableUpdates(PR_TRUE);
  681:     PRBool willNotify;
  681:     PRBool isAlternate;
  681:     rv = ssle->UpdateStyleSheet(this, &willNotify, &isAlternate);
  681:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
  681:     if (willNotify) {
  681:       // Successfully started a stylesheet load
  681:       if (!isAlternate) {
  681:         ++mPendingSheetCount;
  681:         mScriptLoader->AddExecuteBlocker();
    1:       }
  681: 
  681:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   // If it's not a CSS stylesheet PI...
    1:   nsAutoString type;
    1:   nsParserUtils::GetQuotedAttributeValue(data, nsGkAtoms::type, type);
    1: 
    1:   if (mState != eXMLContentSinkState_InProlog ||
    1:       !target.EqualsLiteral("xml-stylesheet") ||
  681:       type.IsEmpty()                          ||
    1:       type.LowerCaseEqualsLiteral("text/css")) {
    1:     return DidProcessATokenImpl();
    1:   }
    1: 
    1:   nsAutoString href, title, media;
    1:   PRBool isAlternate = PR_FALSE;
    1: 
    1:   // If there was no href, we can't do anything with this PI
22106:   if (!ParsePIData(data, href, title, media, isAlternate)) {
    1:       return DidProcessATokenImpl();
    1:   }
    1: 
    1:   rv = ProcessStyleLink(node, href, isAlternate, title, type, media);
    1:   return NS_SUCCEEDED(rv) ? DidProcessATokenImpl() : rv;
    1: }
    1: 
    1: /* static */
22106: PRBool
    1: nsXMLContentSink::ParsePIData(const nsString &aData, nsString &aHref,
    1:                               nsString &aTitle, nsString &aMedia,
    1:                               PRBool &aIsAlternate)
    1: {
    1:   // If there was no href, we can't do anything with this PI
22106:   if (!nsParserUtils::GetQuotedAttributeValue(aData, nsGkAtoms::href, aHref)) {
22106:     return PR_FALSE;
    1:   }
    1: 
    1:   nsParserUtils::GetQuotedAttributeValue(aData, nsGkAtoms::title, aTitle);
    1: 
    1:   nsParserUtils::GetQuotedAttributeValue(aData, nsGkAtoms::media, aMedia);
    1: 
    1:   nsAutoString alternate;
    1:   nsParserUtils::GetQuotedAttributeValue(aData, nsGkAtoms::alternate, alternate);
    1: 
    1:   aIsAlternate = alternate.EqualsLiteral("yes");
22106: 
22106:   return PR_TRUE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::HandleXMLDeclaration(const PRUnichar *aVersion,
    1:                                        const PRUnichar *aEncoding,
    1:                                        PRInt32 aStandalone)
    1: {
    1:   mDocument->SetXMLDeclaration(aVersion, aEncoding, aStandalone);
    1: 
    1:   return DidProcessATokenImpl();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXMLContentSink::ReportError(const PRUnichar* aErrorText, 
    1:                               const PRUnichar* aSourceText,
    1:                               nsIScriptError *aError,
    1:                               PRBool *_retval)
    1: {
    1:   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
    1:   nsresult rv = NS_OK;
    1: 
    1:   // The expat driver should report the error.  We're just cleaning up the mess.
    1:   *_retval = PR_TRUE;
    1:   
    1:   mPrettyPrintXML = PR_FALSE;
    1: 
    1:   mState = eXMLContentSinkState_InProlog;
    1: 
    1:   // XXX need to stop scripts here -- hsivonen
    1: 
    1:   // stop observing in order to avoid crashing when removing content
    1:   mDocument->RemoveObserver(this);
28461:   mIsDocumentObserver = PR_FALSE;
    1: 
    1:   // Clear the current content and
    1:   // prepare to set <parsererror> as the document root
    1:   nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mDocument));
    1:   if (node) {
    1:     for (;;) {
    1:       nsCOMPtr<nsIDOMNode> child, dummy;
    1:       node->GetLastChild(getter_AddRefs(child));
    1:       if (!child)
    1:         break;
    1:       node->RemoveChild(child, getter_AddRefs(dummy));
    1:     }
    1:   }
    1:   NS_IF_RELEASE(mDocElement); 
    1: 
    1:   // Clear any buffered-up text we have.  It's enough to set the length to 0.
    1:   // The buffer itself is allocated when we're created and deleted in our
    1:   // destructor, so don't mess with it.
    1:   mTextLength = 0;
    1: 
    1:   if (mXSLTProcessor) {
    1:     // Get rid of the XSLT processor.
    1:     mXSLTProcessor->CancelLoads();
    1:     mXSLTProcessor = nsnull;
    1:   }
    1: 
    1:   // release the nodes on stack
    1:   mContentStack.Clear();
    1:   mNotifyLevel = 0;
    1: 
25603:   rv = HandleProcessingInstruction(NS_LITERAL_STRING("xml-stylesheet").get(),
25603:                                    NS_LITERAL_STRING("href=\"chrome://global/locale/intl.css\" type=\"text/css\"").get());
25603:   NS_ENSURE_SUCCESS(rv, rv);
25603: 
    1:   const PRUnichar* noAtts[] = { 0, 0 };
    1: 
    1:   NS_NAMED_LITERAL_STRING(errorNs,
    1:                           "http://www.mozilla.org/newlayout/xml/parsererror.xml");
    1: 
    1:   nsAutoString parsererror(errorNs);
    1:   parsererror.Append((PRUnichar)0xFFFF);
    1:   parsererror.AppendLiteral("parsererror");
    1:   
 2266:   rv = HandleStartElement(parsererror.get(), noAtts, 0, -1, (PRUint32)-1,
 2266:                           PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 2266:   rv = HandleCharacterData(aErrorText, nsCRT::strlen(aErrorText), PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);  
    1:   
    1:   nsAutoString sourcetext(errorNs);
    1:   sourcetext.Append((PRUnichar)0xFFFF);
    1:   sourcetext.AppendLiteral("sourcetext");
    1: 
 2266:   rv = HandleStartElement(sourcetext.get(), noAtts, 0, -1, (PRUint32)-1,
 2266:                           PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
 2266:   rv = HandleCharacterData(aSourceText, nsCRT::strlen(aSourceText), PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
 2266:   rv = HandleEndElement(sourcetext.get(), PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv); 
    1:   
 2266:   rv = HandleEndElement(parsererror.get(), PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   FlushTags();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXMLContentSink::AddAttributes(const PRUnichar** aAtts,
    1:                                 nsIContent* aContent)
    1: {
    1:   // Add tag attributes to the content attributes
    1:   nsCOMPtr<nsIAtom> prefix, localName;
    1:   while (*aAtts) {
    1:     PRInt32 nameSpaceID;
    1:     nsContentUtils::SplitExpatName(aAtts[0], getter_AddRefs(prefix),
    1:                                    getter_AddRefs(localName), &nameSpaceID);
    1: 
    1:     // Add attribute to content
    1:     aContent->SetAttr(nameSpaceID, localName, prefix,
    1:                       nsDependentString(aAtts[1]), PR_FALSE);
    1:     aAtts += 2;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #define NS_ACCUMULATION_BUFFER_SIZE 4096
    1: 
    1: nsresult
    1: nsXMLContentSink::AddText(const PRUnichar* aText, 
    1:                           PRInt32 aLength)
    1: {
    1:   // Create buffer when we first need it
    1:   if (0 == mTextSize) {
    1:     mText = (PRUnichar *) PR_MALLOC(sizeof(PRUnichar) * NS_ACCUMULATION_BUFFER_SIZE);
    1:     if (nsnull == mText) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     mTextSize = NS_ACCUMULATION_BUFFER_SIZE;
    1:   }
    1: 
    1:   // Copy data from string into our buffer; flush buffer when it fills up
    1:   PRInt32 offset = 0;
    1:   while (0 != aLength) {
    1:     PRInt32 amount = mTextSize - mTextLength;
    1:     if (0 == amount) {
    1:       // XSLT wants adjacent textnodes merged.
    1:       if (mConstrainSize && !mXSLTProcessor) {
    1:         nsresult rv = FlushText();
    1:         if (NS_OK != rv) {
    1:           return rv;
    1:         }
 2264: 
 2264:         amount = mTextSize - mTextLength;
    1:       }
    1:       else {
    1:         mTextSize += aLength;
    1:         mText = (PRUnichar *) PR_REALLOC(mText, sizeof(PRUnichar) * mTextSize);
    1:         if (nsnull == mText) {
 2264:           mTextSize = 0;
 2264: 
    1:           return NS_ERROR_OUT_OF_MEMORY;
    1:         }
 2264: 
 2264:         amount = aLength;
    1:       }
    1:     }
 2264:     if (amount > aLength) {
 2264:       amount = aLength;
 2264:     }
 2264:     memcpy(&mText[mTextLength], &aText[offset], sizeof(PRUnichar) * amount);
 2264:     mTextLength += amount;
    1:     offset += amount;
    1:     aLength -= amount;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsXMLContentSink::FlushPendingNotifications(mozFlushType aType)
    1: {
    1:   // Only flush tags if we're not doing the notification ourselves
    1:   // (since we aren't reentrant)
    1:   if (!mInNotification) {
28461:     if (mIsDocumentObserver) {
28461:       // Only flush if we're still a document observer (so that our child
28461:       // counts should be correct).
 4886:       if (aType >= Flush_ContentAndNotify) {
    1:         FlushTags();
    1:       }
    1:       else {
20517:         FlushText(PR_FALSE);
    1:       }
28461:     }
27993:     if (aType >= Flush_InterruptibleLayout) {
    1:       // Make sure that layout has started so that the reflow flush
    1:       // will actually happen.
  681:       MaybeStartLayout(PR_TRUE);
    1:     }
    1:   }
    1: }
    1: 
    1: /**
    1:  * NOTE!! Forked from SinkContext. Please keep in sync.
    1:  *
    1:  * Flush all elements that have been seen so far such that
    1:  * they are visible in the tree. Specifically, make sure
    1:  * that they are all added to their respective parents.
    1:  * Also, do notification at the top for all content that
    1:  * has been newly added so that the frame tree is complete.
    1:  */
    1: nsresult
    1: nsXMLContentSink::FlushTags()
    1: {
 3317:   mDeferredFlushTags = PR_FALSE;
    1:   PRBool oldBeganUpdate = mBeganUpdate;
 1574:   PRUint32 oldUpdates = mUpdatesInNotification;
    1: 
 1574:   mUpdatesInNotification = 0;
    1:   ++mInNotification;
  398:   {
  398:     // Scope so we call EndUpdate before we decrease mInNotification
    1:     mozAutoDocUpdate updateBatch(mDocument, UPDATE_CONTENT_MODEL, PR_TRUE);
    1:     mBeganUpdate = PR_TRUE;
    1: 
    1:     // Don't release last text node in case we need to add to it again
20517:     FlushText(PR_FALSE);
    1: 
    1:     // Start from the base of the stack (growing downward) and do
    1:     // a notification from the node that is closest to the root of
    1:     // tree for any content that has been added.
    1: 
    1:     PRInt32 stackPos;
    1:     PRInt32 stackLen = mContentStack.Length();
    1:     PRBool flushed = PR_FALSE;
    1:     PRUint32 childCount;
    1:     nsIContent* content;
    1: 
    1:     for (stackPos = 0; stackPos < stackLen; ++stackPos) {
    1:       content = mContentStack[stackPos].mContent;
    1:       childCount = content->GetChildCount();
    1: 
    1:       if (!flushed && (mContentStack[stackPos].mNumFlushed < childCount)) {
    1:         NotifyAppend(content, mContentStack[stackPos].mNumFlushed);
    1:         flushed = PR_TRUE;
    1:       }
    1: 
    1:       mContentStack[stackPos].mNumFlushed = childCount;
    1:     }
    1:     mNotifyLevel = stackLen - 1;
  398:   }
    1:   --mInNotification;
    1: 
 1574:   if (mUpdatesInNotification > 1) {
 1574:     UpdateChildCounts();
 1574:   }
 1574: 
 1574:   mUpdatesInNotification = oldUpdates;
    1:   mBeganUpdate = oldBeganUpdate;
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * NOTE!! Forked from SinkContext. Please keep in sync.
    1:  */
    1: void
    1: nsXMLContentSink::UpdateChildCounts()
    1: {
    1:   // Start from the top of the stack (growing upwards) and see if any
    1:   // new content has been appended. If so, we recognize that reflows
    1:   // have been generated for it and we should make sure that no
    1:   // further reflows occur.  Note that we have to include stackPos == 0
    1:   // to properly notify on kids of <html>.
    1:   PRInt32 stackLen = mContentStack.Length();
    1:   PRInt32 stackPos = stackLen - 1;
    1:   while (stackPos >= 0) {
    1:     StackNode & node = mContentStack[stackPos];
    1:     node.mNumFlushed = node.mContent->GetChildCount();
    1: 
    1:     stackPos--;
    1:   }
    1:   mNotifyLevel = stackLen - 1;
    1: }
    1: 
    1: PRBool
    1: nsXMLContentSink::IsMonolithicContainer(nsINodeInfo* aNodeInfo)
    1: {
    1:   return ((aNodeInfo->NamespaceID() == kNameSpaceID_XHTML &&
    1:           (aNodeInfo->NameAtom() == nsGkAtoms::tr ||
    1:            aNodeInfo->NameAtom() == nsGkAtoms::select ||
    1:            aNodeInfo->NameAtom() == nsGkAtoms::object ||
    1:            aNodeInfo->NameAtom() == nsGkAtoms::applet))
    1: #ifdef MOZ_MATHML
    1:        || (aNodeInfo->NamespaceID() == kNameSpaceID_MathML &&
    1:           (aNodeInfo->NameAtom() == nsGkAtoms::math))
    1: #endif
    1:           );
    1: }
