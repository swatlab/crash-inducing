     1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef jsiter_h___
     1: #define jsiter_h___
  3164: 
     1: /*
     1:  * JavaScript iterators.
     1:  */
 56750: #include "jscntxt.h"
     1: #include "jsprvtd.h"
     1: #include "jspubtd.h"
 40327: #include "jsversion.h"
     1: 
 82129: #include "gc/Barrier.h"
 79734: #include "vm/Stack.h"
 42641: 
 53519: /*
 53519:  * For cacheable native iterators, whether the iterator is currently active.
 53519:  * Not serialized by XDR.
 53519:  */
 53404: #define JSITER_ACTIVE       0x1000
 62573: #define JSITER_UNREUSABLE   0x2000
 53404: 
 55632: namespace js {
 55632: 
 42641: struct NativeIterator {
 82129:     HeapPtrObject obj;
 87655:     HeapPtr<JSFlatString> *props_array;
 87655:     HeapPtr<JSFlatString> *props_cursor;
 87655:     HeapPtr<JSFlatString> *props_end;
 83221:     const Shape **shapes_array;
 84755:     uint32_t  shapes_length;
 84755:     uint32_t  shapes_key;
 84755:     uint32_t  flags;
 53404:     JSObject  *next;  /* Forms cx->enumerators list, garbage otherwise. */
 42641: 
 48470:     bool isKeyIter() const { return (flags & JSITER_FOREACH) == 0; }
 43190: 
 87655:     inline HeapPtr<JSFlatString> *begin() const {
 61055:         return props_array;
 47516:     }
 47516: 
 87655:     inline HeapPtr<JSFlatString> *end() const {
 61055:         return props_end;
 47516:     }
 47516: 
 48470:     size_t numKeys() const {
 61055:         return end() - begin();
 48470:     }
 48470: 
 87655:     HeapPtr<JSFlatString> *current() const {
 61055:         JS_ASSERT(props_cursor < props_end);
 61055:         return props_cursor;
 48470:     }
 48470: 
 61055:     void incCursor() {
 61055:         props_cursor = props_cursor + 1;
 48470:     }
 48470: 
 84755:     static NativeIterator *allocateIterator(JSContext *cx, uint32_t slength,
 48470:                                             const js::AutoIdVector &props);
 91237:     void init(JSObject *obj, unsigned flags, uint32_t slength, uint32_t key);
 48470: 
 42641:     void mark(JSTracer *trc);
 42641: };
     1: 
 89622: class ElementIteratorObject : public JSObject {
 89622:   public:
 89622:     enum {
 89622:         TargetSlot,
 89622:         IndexSlot,
 89622:         NumSlots
 89622:     };
 89622: 
 97353:     static JSObject *create(JSContext *cx, HandleObject target);
 89622: 
 89622:     inline uint32_t getIndex() const;
 89622:     inline void setIndex(uint32_t index);
 89622:     inline JSObject *getTargetObject() const;
 89622: 
 89622:     /*
 89622:         Array iterators are like this:
 89622: 
 89622:         Array.prototype[iterate] = function () {
 89622:             for (var i = 0; i < (this.length >>> 0); i++) {
 89622:                 var desc = Object.getOwnPropertyDescriptor(this, i);
 89622:                 yield desc === undefined ? undefined : this[i];
 89622:             }
 89622:         }
 89622: 
 89622:         This has the following implications:
 89622: 
 89622:           - Array iterators are generic; Array.prototype[iterate] can be transferred to
 89622:             any other object to create iterators over it.
 89622: 
 89622:           - The next() method of an Array iterator is non-reentrant. Trying to reenter,
 89622:             e.g. by using it on an object with a length getter that calls it.next() on
 89622:             the same iterator, causes a TypeError.
 89622: 
 89622:           - The iterator fetches obj.length every time its next() method is called.
 89622: 
 89622:           - The iterator converts obj.length to a whole number using ToUint32. As a
 89622:             consequence the iterator can't go on forever; it can yield at most 2^32-1
 89622:             values. Then i will be 0xffffffff, and no possible length value will be
 89622:             greater than that.
 89622: 
 89622:           - The iterator does not skip "array holes". When it encounters a hole, it
 89622:             yields undefined.
 89622: 
 89622:           - The iterator never consults the prototype chain.
 89622: 
 89622:           - If an element has a getter which throws, the exception is propagated, and
 89622:             the iterator is closed (that is, all future calls to next() will simply
 89622:             throw StopIteration).
 89622: 
 89622:         Note that if next() were reentrant, even more details of its inner
 89622:         workings would be observable.
 89622:     */
 89622: 
 89622:     /*
 89622:      * If there are any more elements to visit, store the value of the next
 89622:      * element in *vp, increment the index, and return true. If not, call
 89622:      * vp->setMagic(JS_NO_ITER_VALUE) and return true. Return false on error.
 89622:      */
 89622:     bool iteratorNext(JSContext *cx, Value *vp);
 89622: };
 89622: 
 48470: bool
 95355: VectorToIdArray(JSContext *cx, AutoIdVector &props, JSIdArray **idap);
 42641: 
 47460: bool
 95355: GetIterator(JSContext *cx, HandleObject obj, unsigned flags, Value *vp);
 40829: 
 42733: bool
 95355: VectorToKeyIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &props, Value *vp);
 42733: 
 42733: bool
 95355: VectorToValueIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &props, Value *vp);
 48470: 
 48470: /*
 48470:  * Creates either a key or value iterator, depending on flags. For a value
 48470:  * iterator, performs value-lookup to convert the given list of jsids.
 48470:  */
 48470: bool
 95355: EnumeratedIdVectorToIterator(JSContext *cx, HandleObject obj, unsigned flags, AutoIdVector &props, Value *vp);
 42733: 
 40829: /*
     1:  * Convert the value stored in *vp to its iteration object. The flags should
 91364:  * contain JSITER_ENUMERATE if js::ValueToIterator is called when enumerating
     1:  * for-in semantics are required, and when the caller can guarantee that the
     1:  * iterator will never be exposed to scripts.
     1:  */
 91160: extern JSBool
 95355: ValueToIterator(JSContext *cx, unsigned flags, Value *vp);
     1: 
 91160: extern bool
 91160: CloseIterator(JSContext *cx, JSObject *iterObj);
 91160: 
 91160: extern bool
 91160: UnwindIteratorForException(JSContext *cx, JSObject *obj);
 91160: 
 91947: extern void
 91947: UnwindIteratorForUncatchableException(JSContext *cx, JSObject *obj);
 91947: 
 91160: }
  3025: 
 86790: extern bool
 97353: js_SuppressDeletedProperty(JSContext *cx, js::HandleObject obj, jsid id);
 43281: 
 86790: extern bool
 97353: js_SuppressDeletedElement(JSContext *cx, js::HandleObject obj, uint32_t index);
 78344: 
 86790: extern bool
 97353: js_SuppressDeletedElements(JSContext *cx, js::HandleObject obj, uint32_t begin, uint32_t end);
 55519: 
     1: /*
 42641:  * IteratorMore() indicates whether another value is available. It might
 42641:  * internally call iterobj.next() and then cache the value until its
 42641:  * picked up by IteratorNext(). The value is cached in the current context.
     1:  */
 42641: extern JSBool
 95355: js_IteratorMore(JSContext *cx, js::HandleObject iterobj, js::Value *rval);
 42641: 
 42641: extern JSBool
 48470: js_IteratorNext(JSContext *cx, JSObject *iterobj, js::Value *rval);
     1: 
  6464: extern JSBool
  6464: js_ThrowStopIteration(JSContext *cx);
  6464: 
 91364: namespace js {
 91364: 
 91364: /*
 91364:  * Get the next value from an iterator object.
 91364:  *
 91364:  * On success, store the next value in *vp and return true; if there are no
 91364:  * more values, store the magic value JS_NO_ITER_VALUE in *vp and return true.
 91364:  */
 91364: inline bool
 95355: Next(JSContext *cx, HandleObject iter, Value *vp)
 91364: {
 91364:     if (!js_IteratorMore(cx, iter, vp))
 91364:         return false;
 91364:     if (vp->toBoolean())
 91364:         return js_IteratorNext(cx, iter, vp);
 91364:     vp->setMagic(JS_NO_ITER_VALUE);
 91364:     return true;
 91364: }
 91364: 
 91364: /*
 91364:  * Imitate a for-of loop. This does the equivalent of the JS code:
 91364:  *
 91364:  *     for (let v of iterable)
 91364:  *         op(v);
 91364:  *
 91364:  * But the actual signature of op must be:
 91364:  *     bool op(JSContext *cx, const Value &v);
 91364:  *
 91364:  * There is no feature like JS 'break'. op must return false only
 91364:  * in case of exception or error.
 91364:  */
 91364: template <class Op>
 91364: bool
 91364: ForOf(JSContext *cx, const Value &iterable, Op op)
 91364: {
 91364:     Value iterv(iterable);
 91364:     if (!ValueToIterator(cx, JSITER_FOR_OF, &iterv))
 91364:         return false;
 99421:     RootedObject iter(cx, &iterv.toObject());
 91364: 
 91364:     bool ok = true;
 91364:     while (ok) {
 91364:         Value v;
 91364:         ok = Next(cx, iter, &v);
 91364:         if (ok) {
 91364:             if (v.isMagic(JS_NO_ITER_VALUE))
 91364:                 break;
 91364:             ok = op(cx, v);
 91364:         }
 91364:     }
 91364: 
 91364:     bool throwing = !ok && cx->isExceptionPending();
 91364:     Value exc;
 91364:     if (throwing) {
 91364:         exc = cx->getPendingException();
 91364:         cx->clearPendingException();
 91364:     }
 91364:     bool closedOK = CloseIterator(cx, iter);
 91364:     if (throwing && closedOK)
 91364:         cx->setPendingException(exc);
 91364:     return ok && closedOK;
 91364: }
 91364: 
 91364: } /* namespace js */
 91364: 
     1: #if JS_HAS_GENERATORS
     1: 
     1: /*
     1:  * Generator state codes.
     1:  */
100006: typedef enum JSGeneratorState {
     1:     JSGEN_NEWBORN,  /* not yet started */
     1:     JSGEN_OPEN,     /* started by a .next() or .send(undefined) call */
     1:     JSGEN_RUNNING,  /* currently executing via .next(), etc., call */
     1:     JSGEN_CLOSING,  /* close method is doing asynchronous return */
     1:     JSGEN_CLOSED    /* closed, cannot be started or closed again */
100006: } JSGeneratorState;
     1: 
100006: struct JSGenerator {
 82129:     js::HeapPtrObject   obj;
     1:     JSGeneratorState    state;
 69223:     js::FrameRegs       regs;
 43281:     JSObject            *enumerators;
100006:     js::StackFrame      *floating;
100006:     js::HeapValue       floatingStack[1];
100006: 
100006:     js::StackFrame *floatingFrame() {
100006:         return floating;
100006:     }
100006: 
100006:     js::StackFrame *liveFrame() {
100006:         JS_ASSERT((state == JSGEN_RUNNING || state == JSGEN_CLOSING) ==
100006:                   (regs.fp() != floatingFrame()));
100006:         return regs.fp();
100006:     }
 42709: };
 42708: 
     1: extern JSObject *
 37777: js_NewGenerator(JSContext *cx);
100006: 
100006: /*
100006:  * Generator stack frames do not have stable pointers since they get copied to
100006:  * and from the generator object and the stack (see SendToGenerator). This is a
100006:  * problem for Block and With objects, which need to store a pointer to the
100006:  * enclosing stack frame. The solution is for Block and With objects to store
100006:  * a pointer to the "floating" stack frame stored in the generator object,
100006:  * since it is stable, and maintain, in the generator object, a pointer to the
100006:  * "live" stack frame (either a copy on the stack or the floating frame). Thus,
100006:  * Block and With objects must "normalize" to and from the floating/live frames
100006:  * in the case of generators using the following functions.
100006:  */
100006: inline js::StackFrame *
100006: js_FloatingFrameIfGenerator(JSContext *cx, js::StackFrame *fp)
100006: {
100006:     if (JS_UNLIKELY(fp->isGeneratorFrame()))
100006:         return cx->generatorFor(fp)->floatingFrame();
100006:     return fp;
100006: }
100006: 
100006: /* Given a floating frame, given the JSGenerator containing it. */
100006: extern JSGenerator *
100006: js_FloatingFrameToGenerator(js::StackFrame *fp);
100006: 
100006: inline js::StackFrame *
100006: js_LiveFrameIfGenerator(js::StackFrame *fp)
100006: {
100006:     return fp->isGeneratorFrame() ? js_FloatingFrameToGenerator(fp)->liveFrame() : fp;
100006: }
100006: 
     1: #endif
     1: 
     1: extern JSObject *
     1: js_InitIteratorClasses(JSContext *cx, JSObject *obj);
     1: 
     1: #endif /* jsiter_h___ */
