35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
36124:  *   Jim Mathies <jmathies@mozilla.com>
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
35893: #include "PluginInstanceParent.h"
35945: 
35895: #include "BrowserStreamParent.h"
35945: #include "PluginModuleParent.h"
35938: #include "PluginStreamParent.h"
35904: #include "StreamNotifyParent.h"
35945: #include "npfunctions.h"
35945: #include "nsAutoPtr.h"
35945: 
36271: #if defined(OS_WIN)
36271: #include <windowsx.h>
37550: 
37550: // Plugin focus event for widget.
37550: extern const PRUnichar* kOOPPPluginFocusEventId;
37550: UINT gOOPPPluginFocusEvent =
37550:     RegisterWindowMessage(kOOPPPluginFocusEventId);
38103: UINT gOOPPSpinNativeLoopEvent =
38103:     RegisterWindowMessage(L"SyncChannel Spin Inner Loop Message");
38103: UINT gOOPPStopNativeLoopEvent =
38103:     RegisterWindowMessage(L"SyncChannel Stop Inner Loop Message");
36271: #endif
36271: 
35945: using namespace mozilla::plugins;
35945: 
35945: PluginInstanceParent::PluginInstanceParent(PluginModuleParent* parent,
35945:                                            NPP npp,
35945:                                            const NPNetscapeFuncs* npniface)
37550:   : mParent(parent)
37550:     , mNPP(npp)
37550:     , mNPNIface(npniface)
37550:     , mWindowType(NPWindowTypeWindow)
37550: #if defined(OS_WIN)
37550:     , mPluginHWND(NULL)
37550:     , mPluginWndProc(NULL)
37550: #endif // defined(XP_WIN)
35945: {
35945: }
35945: 
35945: PluginInstanceParent::~PluginInstanceParent()
35945: {
36144:     if (mNPP)
36144:         mNPP->pdata = NULL;
37594: 
37594: #if defined(OS_WIN)
37594:     NS_ASSERTION(!(mPluginHWND || mPluginWndProc),
37594:         "Subclass was not reset correctly before the dtor was reached!");
37594: #endif
35945: }
35890: 
37311: bool
37311: PluginInstanceParent::Init()
37311: {
37311:     return !!mScriptableObjects.Init();
37311: }
37311: 
37311: namespace {
37311: 
37311: PLDHashOperator
37311: ActorCollect(const void* aKey,
37311:              PluginScriptableObjectParent* aData,
37311:              void* aUserData)
37311: {
37311:     nsTArray<PluginScriptableObjectParent*>* objects =
37311:         reinterpret_cast<nsTArray<PluginScriptableObjectParent*>*>(aUserData);
37311:     return objects->AppendElement(aData) ? PL_DHASH_NEXT : PL_DHASH_STOP;
37311: }
37311: 
37311: } // anonymous namespace
37311: 
37594: void
37594: PluginInstanceParent::ActorDestroy(ActorDestroyReason why)
37594: {
37594: #if defined(OS_WIN)
37594:     if (why == AbnormalShutdown) {
37594:         // If the plugin process crashes, this is the only
37594:         // chance we get to destroy resources.
37594:         SharedSurfaceRelease();
37594:         UnsubclassPluginWindow();
38103:         // If we crashed in a modal loop in the child, reset
38103:         // the rpc event spin loop state.
38103:         if (mNestedEventState) {
38103:             mNestedEventState = false;
38103:             PostThreadMessage(GetCurrentThreadId(),
38103:                               gOOPPStopNativeLoopEvent,
38103:                               0, 0);
38103:         }
37594:     }
37594: #endif
37594: }
37594: 
37311: NPError
37307: PluginInstanceParent::Destroy()
37302: {
37311:     NPError retval;
38645:     if (!CallNPP_Destroy(&retval))
38645:         retval = NPERR_GENERIC_ERROR;
36124: 
36124: #if defined(OS_WIN)
36124:     SharedSurfaceRelease();
37550:     UnsubclassPluginWindow();
38103:     if (mNestedEventState) {
38103:         mNestedEventState = false;
38103:         PostThreadMessage(GetCurrentThreadId(),
38103:                           gOOPPStopNativeLoopEvent,
38103:                           0, 0);
38103:     }
36124: #endif
37311: 
37311:     return retval;
35965: }
35965: 
35898: PBrowserStreamParent*
35943: PluginInstanceParent::AllocPBrowserStream(const nsCString& url,
35893:                                           const uint32_t& length,
35890:                                           const uint32_t& lastmodified,
35990:                                           PStreamNotifyParent* notifyData,
35890:                                           const nsCString& headers,
35890:                                           const nsCString& mimeType,
35890:                                           const bool& seekable,
35893:                                           NPError* rv,
35893:                                           uint16_t *stype)
35890: {
35890:     NS_RUNTIMEABORT("Not reachable");
35890:     return NULL;
35890: }
35890: 
35926: bool
36138: PluginInstanceParent::DeallocPBrowserStream(PBrowserStreamParent* stream)
35890: {
35890:     delete stream;
35926:     return true;
35890: }
35740: 
35938: PPluginStreamParent*
35943: PluginInstanceParent::AllocPPluginStream(const nsCString& mimeType,
35938:                                          const nsCString& target,
35938:                                          NPError* result)
35938: {
35938:     return new PluginStreamParent(this, mimeType, target, result);
35938: }
35938: 
35938: bool
36138: PluginInstanceParent::DeallocPPluginStream(PPluginStreamParent* stream)
35938: {
35938:     delete stream;
35938:     return true;
35938: }
35938: 
35926: bool
35923: PluginInstanceParent::AnswerNPN_GetValue_NPNVjavascriptEnabledBool(
35923:                                                        bool* value,
35923:                                                        NPError* result)
35923: {
35923:     NPBool v;
35923:     *result = mNPNIface->getvalue(mNPP, NPNVjavascriptEnabledBool, &v);
35923:     *value = v;
35926:     return true;
35923: }
35923: 
35926: bool
35923: PluginInstanceParent::AnswerNPN_GetValue_NPNVisOfflineBool(bool* value,
35923:                                                            NPError* result)
35923: {
35923:     NPBool v;
35923:     *result = mNPNIface->getvalue(mNPP, NPNVisOfflineBool, &v);
35923:     *value = v;
35926:     return true;
35923: }
35923: 
35926: bool
37308: PluginInstanceParent::AnswerNPN_GetValue_NPNVnetscapeWindow(NativeWindowHandle* value,
37168:                                                             NPError* result)
37168: {
37168: #ifdef XP_WIN
37308:     HWND id;
37308: #elif defined(MOZ_X11)
37308:     XID id;
37308: #else
37308:     return false;
37308: #endif
37308: 
37308:     *result = mNPNIface->getvalue(mNPP, NPNVnetscapeWindow, &id);
37308:     *value = id;
37168:     return true;
37168: }
37168: 
37168: bool
35965: PluginInstanceParent::InternalGetValueForNPObject(
35965:                                          NPNVariable aVariable,
35965:                                          PPluginScriptableObjectParent** aValue,
35965:                                          NPError* aResult)
35923: {
35965:     NPObject* npobject;
35965:     NPError result = mNPNIface->getvalue(mNPP, aVariable, (void*)&npobject);
36078:     if (result == NPERR_NO_ERROR) {
36078:         NS_ASSERTION(npobject, "Shouldn't return null and NPERR_NO_ERROR!");
36078: 
36078:         PluginScriptableObjectParent* actor = GetActorForNPObject(npobject);
36078:         mNPNIface->releaseobject(npobject);
36078:         if (actor) {
36078:             *aValue = actor;
36078:             *aResult = NPERR_NO_ERROR;
35965:             return true;
35965:         }
35965: 
36078:         NS_ERROR("Failed to get actor!");
36078:         result = NPERR_GENERIC_ERROR;
35965:     }
35965: 
35965:     *aValue = nsnull;
36078:     *aResult = result;
35926:     return true;
35923: }
35923: 
35926: bool
35965: PluginInstanceParent::AnswerNPN_GetValue_NPNVWindowNPObject(
35965:                                          PPluginScriptableObjectParent** aValue,
35965:                                          NPError* aResult)
35965: {
35965:     return InternalGetValueForNPObject(NPNVWindowNPObject, aValue, aResult);
35965: }
35965: 
35965: bool
35923: PluginInstanceParent::AnswerNPN_GetValue_NPNVPluginElementNPObject(
35965:                                          PPluginScriptableObjectParent** aValue,
35965:                                          NPError* aResult)
35923: {
35965:     return InternalGetValueForNPObject(NPNVPluginElementNPObject, aValue,
35965:                                        aResult);
35923: }
35923: 
35926: bool
35923: PluginInstanceParent::AnswerNPN_GetValue_NPNVprivateModeBool(bool* value,
35923:                                                              NPError* result)
35923: {
35923:     NPBool v;
35923:     *result = mNPNIface->getvalue(mNPP, NPNVprivateModeBool, &v);
35923:     *value = v;
35926:     return true;
35923: }
35923: 
35951: 
35951: bool
35951: PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginWindow(
35951:     const bool& windowed, NPError* result)
35951: {
35951:     NPBool isWindowed = windowed;
35951:     *result = mNPNIface->setvalue(mNPP, NPPVpluginWindowBool,
35951:                                   (void*)isWindowed);
35951:     return true;
35951: }
35951: 
35951: bool
35951: PluginInstanceParent::AnswerNPN_SetValue_NPPVpluginTransparent(
35951:     const bool& transparent, NPError* result)
35951: {
35951:     NPBool isTransparent = transparent;
35951:     *result = mNPNIface->setvalue(mNPP, NPPVpluginTransparentBool,
35951:                                   (void*)isTransparent);
35951:     return true;
35951: }
35951: 
35951: 
35926: bool
35904: PluginInstanceParent::AnswerNPN_GetURL(const nsCString& url,
35904:                                        const nsCString& target,
35904:                                        NPError* result)
35904: {
35940:     *result = mNPNIface->geturl(mNPP,
35940:                                 NullableStringGet(url),
35940:                                 NullableStringGet(target));
35926:     return true;
35904: }
35904: 
35926: bool
35904: PluginInstanceParent::AnswerNPN_PostURL(const nsCString& url,
35904:                                         const nsCString& target,
35904:                                         const nsCString& buffer,
35904:                                         const bool& file,
35904:                                         NPError* result)
35904: {
35944:     *result = mNPNIface->posturl(mNPP, url.get(), NullableStringGet(target),
35904:                                  buffer.Length(), buffer.get(), file);
35926:     return true;
35904: }
35904: 
35904: PStreamNotifyParent*
35943: PluginInstanceParent::AllocPStreamNotify(const nsCString& url,
35904:                                          const nsCString& target,
35904:                                          const bool& post,
35904:                                          const nsCString& buffer,
35904:                                          const bool& file,
35904:                                          NPError* result)
35904: {
36110:     return new StreamNotifyParent();
36110: }
35904: 
36110: bool
36110: PluginInstanceParent::AnswerPStreamNotifyConstructor(PStreamNotifyParent* actor,
36110:                                                      const nsCString& url,
36110:                                                      const nsCString& target,
36110:                                                      const bool& post,
36110:                                                      const nsCString& buffer,
36110:                                                      const bool& file,
36110:                                                      NPError* result)
36110: {
37094:     bool streamDestroyed = false;
37094:     static_cast<StreamNotifyParent*>(actor)->
37094:         SetDestructionFlag(&streamDestroyed);
37094: 
35904:     if (!post) {
35940:         *result = mNPNIface->geturlnotify(mNPP,
35940:                                           NullableStringGet(url),
35940:                                           NullableStringGet(target),
36110:                                           actor);
35904:     }
35904:     else {
35940:         *result = mNPNIface->posturlnotify(mNPP,
35940:                                            NullableStringGet(url),
35940:                                            NullableStringGet(target),
36110:                                            buffer.Length(),
36110:                                            NullableStringGet(buffer),
36110:                                            file, actor);
35904:     }
36110: 
37094:     if (!streamDestroyed) {
37094:         static_cast<StreamNotifyParent*>(actor)->ClearDestructionFlag();
36110:         if (*result != NPERR_NO_ERROR)
36138:             PStreamNotifyParent::Call__delete__(actor, NPERR_GENERIC_ERROR);
37094:     }
36110: 
36110:     return true;
35904: }
35904: 
35926: bool
36138: PluginInstanceParent::DeallocPStreamNotify(PStreamNotifyParent* notifyData)
35904: {
35904:     delete notifyData;
35926:     return true;
35904: }
35904: 
35958: bool
35958: PluginInstanceParent::RecvNPN_InvalidateRect(const NPRect& rect)
35958: {
35958:     mNPNIface->invalidaterect(mNPP, const_cast<NPRect*>(&rect));
35958:     return true;
35958: }
35958: 
35740: NPError
35957: PluginInstanceParent::NPP_SetWindow(const NPWindow* aWindow)
35740: {
37099:     PLUGIN_LOG_DEBUG(("%s (aWindow=%p)", FULLFUNCTION, (void*) aWindow));
37099: 
35746:     NS_ENSURE_TRUE(aWindow, NPERR_GENERIC_ERROR);
35740: 
35957:     NPRemoteWindow window;
36124:     mWindowType = aWindow->type;
36124: 
36124: #if defined(OS_WIN)
36124:     // On windowless controls, reset the shared memory surface as needed.
36124:     if (mWindowType == NPWindowTypeDrawable) {
36124:         // SharedSurfaceSetWindow will take care of NPRemoteWindow.
36124:         if (!SharedSurfaceSetWindow(aWindow, window)) {
36124:           return NPERR_OUT_OF_MEMORY_ERROR;
36124:         }
36124:     }
36124:     else {
37550:         SubclassPluginWindow(reinterpret_cast<HWND>(aWindow->window));
37550: 
35957:         window.window = reinterpret_cast<unsigned long>(aWindow->window);
35957:         window.x = aWindow->x;
35957:         window.y = aWindow->y;
35957:         window.width = aWindow->width;
35957:         window.height = aWindow->height;
35957:         window.type = aWindow->type;
36124:     }
36124: #else
36124:     window.window = reinterpret_cast<unsigned long>(aWindow->window);
36124:     window.x = aWindow->x;
36124:     window.y = aWindow->y;
36124:     window.width = aWindow->width;
36124:     window.height = aWindow->height;
36124:     window.clipRect = aWindow->clipRect; // MacOS specific
36124:     window.type = aWindow->type;
36124: #endif
36124: 
35957: #if defined(MOZ_X11) && defined(XP_UNIX) && !defined(XP_MACOSX)
35957:     const NPSetWindowCallbackStruct* ws_info =
35957:       static_cast<NPSetWindowCallbackStruct*>(aWindow->ws_info);
35957:     window.visualID = ws_info->visual ? ws_info->visual->visualid : None;
35957:     window.colormap = ws_info->colormap;
35957: #endif
35957: 
35746:     NPError prv;
35957:     if (!CallNPP_SetWindow(window, &prv))
35746:         return NPERR_GENERIC_ERROR;
35746:     return prv;
35740: }
35740: 
35740: NPError
35945: PluginInstanceParent::NPP_GetValue(NPPVariable aVariable,
35945:                                    void* _retval)
35740: {
35945:     switch (aVariable) {
35945: 
38126: #ifdef MOZ_X11
35951:     case NPPVpluginNeedsXEmbed: {
35951:         bool needsXEmbed;
35951:         NPError rv;
35951: 
35951:         if (!CallNPP_GetValue_NPPVpluginNeedsXEmbed(&needsXEmbed, &rv)) {
35951:             return NPERR_GENERIC_ERROR;
35951:         }
35951: 
35951:         if (NPERR_NO_ERROR != rv) {
35951:             return rv;
35951:         }
35951: 
35951:         (*(NPBool*)_retval) = needsXEmbed;
35740:         return NPERR_NO_ERROR;
35951:     }
35746: #endif
35925: 
35934:     case NPPVpluginScriptableNPObject: {
35925:         PPluginScriptableObjectParent* actor;
35925:         NPError rv;
35934:         if (!CallNPP_GetValue_NPPVpluginScriptableNPObject(&actor, &rv)) {
35740:             return NPERR_GENERIC_ERROR;
35740:         }
35945: 
35945:         if (NPERR_NO_ERROR != rv) {
35934:             return rv;
35934:         }
35945: 
36075:         if (!actor) {
36075:             NS_ERROR("NPPVpluginScriptableNPObject succeeded but null.");
36075:             return NPERR_GENERIC_ERROR;
36075:         }
36073: 
35945:         const NPNetscapeFuncs* npn = mParent->GetNetscapeFuncs();
35945:         if (!npn) {
35945:             NS_WARNING("No netscape functions?!");
35945:             return NPERR_GENERIC_ERROR;
35945:         }
35945: 
35945:         NPObject* object =
37311:             static_cast<PluginScriptableObjectParent*>(actor)->GetObject(true);
35945:         NS_ASSERTION(object, "This shouldn't ever be null!");
35945: 
35945:         (*(NPObject**)_retval) = npn->retainobject(object);
35945:         return NPERR_NO_ERROR;
35945:     }
35945: 
35937:     default:
37099:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37099:                ("In PluginInstanceParent::NPP_GetValue: Unhandled NPPVariable %i (%s)",
37099:                 (int) aVariable, NPPVariableToString(aVariable)));
35937:         return NPERR_GENERIC_ERROR;
35934:     }
35740: }
35740: 
37350: NPError
37350: PluginInstanceParent::NPP_SetValue(NPNVariable variable, void* value)
37350: {
37350:     switch (variable) {
37350:     case NPNVprivateModeBool:
37350:         NPError result;
37350:         if (!CallNPP_SetValue_NPNVprivateModeBool(*static_cast<NPBool*>(value),
37350:                                                   &result))
37350:             return NPERR_GENERIC_ERROR;
37350: 
37350:         return result;
37350: 
37350:     default:
37350:         NS_ERROR("Unhandled NPNVariable in NPP_SetValue");
37350:         PR_LOG(gPluginLog, PR_LOG_WARNING,
37350:                ("In PluginInstanceParent::NPP_SetValue: Unhandled NPNVariable %i (%s)",
37350:                 (int) variable, NPNVariableToString(variable)));
37350:         return NPERR_GENERIC_ERROR;
37350:     }
37350: }
37350: 
35933: int16_t
35933: PluginInstanceParent::NPP_HandleEvent(void* event)
35933: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35933: 
35951:     NPEvent* npevent = reinterpret_cast<NPEvent*>(event);
36011:     NPRemoteEvent npremoteevent;
36011:     npremoteevent.event = *npevent;
38280:     int16_t handled = 0;
35951: 
36124: #if defined(OS_WIN)
36271:     if (mWindowType == NPWindowTypeDrawable) {
36271:         switch(npevent->event) {
36271:             case WM_PAINT:
36271:             {
36271:                 RECT rect;
36270:                 SharedSurfaceBeforePaint(rect, npremoteevent);
39265:                 CallPaint(npremoteevent, &handled);
36271:                 SharedSurfaceAfterPaint(npevent);
38401:                 return handled;
36271:             }
36271:             break;
38280: 
38280:             case WM_KILLFOCUS:
38280:             {
38280:               // When the user selects fullscreen mode in Flash video players,
38280:               // WM_KILLFOCUS will be delayed by deferred event processing:
38280:               // WM_LBUTTONUP results in a call to CreateWindow within Flash,
38280:               // which fires WM_KILLFOCUS. Delayed delivery causes Flash to
38280:               // misinterpret the event, dropping back out of fullscreen. Trap
38280:               // this event and drop it.
38280:               PRUnichar szClass[26];
38280:               HWND hwnd = GetForegroundWindow();
38280:               if (hwnd && hwnd != mPluginHWND &&
38280:                   GetClassNameW(hwnd, szClass,
38280:                                 sizeof(szClass)/sizeof(PRUnichar)) &&
38280:                   !wcscmp(szClass, L"ShockwaveFlashFullScreen")) {
38280:                   return 0;
38280:               }
38280:             }
38401:             break;
38401:         }
36124:     }
36124: #endif
36124: 
35980: #if defined(MOZ_X11)
35951:     if (GraphicsExpose == npevent->type) {
38112:         PLUGIN_LOG_DEBUG(("  schlepping drawable 0x%lx across the pipe\n",
38112:                           npevent->xgraphicsexpose.drawable));
35980:         // Make sure the X server has created the Drawable and completes any
35980:         // drawing before the plugin draws on top.
35980:         //
35980:         // XSync() waits for the X server to complete.  Really this parent
35980:         // process does not need to wait; the child is the process that needs
35980:         // to wait.  A possibly-slightly-better alternative would be to send
35980:         // an X event to the child that the child would wait for.
35980: #  ifdef MOZ_WIDGET_GTK2
35953:         XSync(GDK_DISPLAY(), False);
38045: #  elif defined(MOZ_WIDGET_QT)
38045:         XSync(QX11Info::display(), False);
35980: #  endif
39265: 
39270:         return CallPaint(npremoteevent, &handled) ? handled : 0;
35951:     }
39265: #endif
35951: 
36271:     if (!CallNPP_HandleEvent(npremoteevent, &handled))
35933:         return 0; // no good way to handle errors here...
36124: 
35933:     return handled;
35933: }
35933: 
35890: NPError
35893: PluginInstanceParent::NPP_NewStream(NPMIMEType type, NPStream* stream,
35890:                                     NPBool seekable, uint16_t* stype)
35890: {
37099:     PLUGIN_LOG_DEBUG(("%s (type=%s, stream=%p, seekable=%i)",
37099:                       FULLFUNCTION, (char*) type, (void*) stream, (int) seekable));
35890: 
35938:     BrowserStreamParent* bs = new BrowserStreamParent(this, stream);
35938: 
35890:     NPError err;
35938:     if (!CallPBrowserStreamConstructor(bs,
36111:                                        NullableString(stream->url),
35890:                                        stream->end,
35890:                                        stream->lastmodified,
35904:                                        static_cast<PStreamNotifyParent*>(stream->notifyData),
36111:                                        NullableString(stream->headers),
36111:                                        NullableString(type), seekable,
36111:                                        &err, stype))
35934:         return NPERR_GENERIC_ERROR;
35938: 
35938:     if (NPERR_NO_ERROR != err)
38759:         bs->NPP_DestroyStream(NPERR_GENERIC_ERROR);
35938: 
35890:     return err;
35890: }
35890: 
35890: NPError
35893: PluginInstanceParent::NPP_DestroyStream(NPStream* stream, NPReason reason)
35890: {
37099:     PLUGIN_LOG_DEBUG(("%s (stream=%p, reason=%i)",
37099:                       FULLFUNCTION, (void*) stream, (int) reason));
35944: 
35938:     AStream* s = static_cast<AStream*>(stream->pdata);
35938:     if (s->IsBrowserStream()) {
35895:         BrowserStreamParent* sp =
35938:             static_cast<BrowserStreamParent*>(s);
35938:         if (sp->mNPP != this)
35890:             NS_RUNTIMEABORT("Mismatched plugin data");
35938: 
38759:         return sp->NPP_DestroyStream(reason);
35934:     }
35938:     else {
35938:         PluginStreamParent* sp =
35938:             static_cast<PluginStreamParent*>(s);
35938:         if (sp->mInstance != this)
35938:             NS_RUNTIMEABORT("Mismatched plugin data");
35890: 
36138:         PPluginStreamParent::Call__delete__(sp, reason, false);
35938:         return NPERR_NO_ERROR;
35934:     }
35890: }
35890: 
37350: void
37350: PluginInstanceParent::NPP_Print(NPPrint* platformPrint)
37350: {
37350:     // TODO: implement me
37350:     NS_ERROR("Not implemented");
37350: }
37350: 
35898: PPluginScriptableObjectParent*
35943: PluginInstanceParent::AllocPPluginScriptableObject()
35835: {
37311:     return new PluginScriptableObjectParent(Proxy);
37311: }
37307: 
37311: #ifdef DEBUG
37311: namespace {
37307: 
37311: struct ActorSearchData
37311: {
37311:     PluginScriptableObjectParent* actor;
37311:     bool found;
37311: };
37311: 
37311: PLDHashOperator
37311: ActorSearch(const void* aKey,
37311:             PluginScriptableObjectParent* aData,
37311:             void* aUserData)
37311: {
37311:     ActorSearchData* asd = reinterpret_cast<ActorSearchData*>(aUserData);
37311:     if (asd->actor == aData) {
37311:         asd->found = true;
37311:         return PL_DHASH_STOP;
37302:     }
37311:     return PL_DHASH_NEXT;
37311: }
37311: 
37311: } // anonymous namespace
37311: #endif // DEBUG
35945: 
35926: bool
35945: PluginInstanceParent::DeallocPPluginScriptableObject(
35945:                                          PPluginScriptableObjectParent* aObject)
35835: {
37311:     PluginScriptableObjectParent* actor =
37311:         static_cast<PluginScriptableObjectParent*>(aObject);
35945: 
37311:     NPObject* object = actor->GetObject(false);
37311:     if (object) {
37311:         NS_ASSERTION(mScriptableObjects.Get(object, nsnull),
37311:                      "NPObject not in the hash!");
37311:         mScriptableObjects.Remove(object);
37311:     }
37311: #ifdef DEBUG
37311:     else {
37311:         ActorSearchData asd = { actor, false };
37311:         mScriptableObjects.EnumerateRead(ActorSearch, &asd);
37311:         NS_ASSERTION(!asd.found, "Actor in the hash with a null NPObject!");
37311:     }
37311: #endif
37311: 
37311:     delete actor;
37307:     return true;
37302: }
35945: 
35945: bool
38994: PluginInstanceParent::RecvPPluginScriptableObjectConstructor(
35945:                                           PPluginScriptableObjectParent* aActor)
35945: {
35965:     // This is only called in response to the child process requesting the
35965:     // creation of an actor. This actor will represent an NPObject that is
35965:     // created by the plugin and returned to the browser.
37311:     PluginScriptableObjectParent* actor =
37311:         static_cast<PluginScriptableObjectParent*>(aActor);
37311:     NS_ASSERTION(!actor->GetObject(false), "Actor already has an object?!");
35945: 
37311:     actor->InitializeProxy();
37311:     NS_ASSERTION(actor->GetObject(false), "Actor should have an object!");
35965: 
35926:     return true;
35835: }
35890: 
35944: void
35944: PluginInstanceParent::NPP_URLNotify(const char* url, NPReason reason,
35944:                                     void* notifyData)
35944: {
37099:     PLUGIN_LOG_DEBUG(("%s (%s, %i, %p)",
37099:                       FULLFUNCTION, url, (int) reason, notifyData));
35944: 
35944:     PStreamNotifyParent* streamNotify =
35944:         static_cast<PStreamNotifyParent*>(notifyData);
36138:     PStreamNotifyParent::Call__delete__(streamNotify, reason);
35944: }
35965: 
37311: bool
37311: PluginInstanceParent::RegisterNPObjectForActor(
37311:                                            NPObject* aObject,
37311:                                            PluginScriptableObjectParent* aActor)
37311: {
37311:     NS_ASSERTION(aObject && aActor, "Null pointers!");
37311:     NS_ASSERTION(mScriptableObjects.IsInitialized(), "Hash not initialized!");
37311:     NS_ASSERTION(!mScriptableObjects.Get(aObject, nsnull), "Duplicate entry!");
37311:     return !!mScriptableObjects.Put(aObject, aActor);
37311: }
37311: 
37311: void
37311: PluginInstanceParent::UnregisterNPObject(NPObject* aObject)
37311: {
37311:     NS_ASSERTION(aObject, "Null pointer!");
37311:     NS_ASSERTION(mScriptableObjects.IsInitialized(), "Hash not initialized!");
37311:     NS_ASSERTION(mScriptableObjects.Get(aObject, nsnull), "Unknown entry!");
37311:     mScriptableObjects.Remove(aObject);
37311: }
37311: 
35965: PluginScriptableObjectParent*
35965: PluginInstanceParent::GetActorForNPObject(NPObject* aObject)
35965: {
35965:     NS_ASSERTION(aObject, "Null pointer!");
35965: 
35965:     if (aObject->_class == PluginScriptableObjectParent::GetClass()) {
35965:         // One of ours!
35965:         ParentNPObject* object = static_cast<ParentNPObject*>(aObject);
35965:         NS_ASSERTION(object->parent, "Null actor!");
35965:         return object->parent;
35965:     }
35965: 
37311:     PluginScriptableObjectParent* actor;
37311:     if (mScriptableObjects.Get(aObject, &actor)) {
35965:         return actor;
35965:     }
37311: 
37311:     actor = new PluginScriptableObjectParent(LocalObject);
37311:     if (!actor) {
37311:         NS_ERROR("Out of memory!");
37311:         return nsnull;
35965:     }
35965: 
38994:     if (!SendPPluginScriptableObjectConstructor(actor)) {
37311:         NS_WARNING("Failed to send constructor message!");
37311:         return nsnull;
37311:     }
35965: 
37311:     actor->InitializeLocal(aObject);
35965:     return actor;
35965: }
35983: 
35983: bool
35983: PluginInstanceParent::AnswerNPN_PushPopupsEnabledState(const bool& aState,
35983:                                                        bool* aSuccess)
35983: {
35983:     *aSuccess = mNPNIface->pushpopupsenabledstate(mNPP, aState ? 1 : 0);
35983:     return true;
35983: }
35983: 
35983: bool
35983: PluginInstanceParent::AnswerNPN_PopPopupsEnabledState(bool* aSuccess)
35983: {
35983:     *aSuccess = mNPNIface->poppopupsenabledstate(mNPP);
35983:     return true;
35983: }
36124: 
37332: bool
37332: PluginInstanceParent::AnswerNPN_GetValueForURL(const NPNURLVariable& variable,
37332:                                                const nsCString& url,
37332:                                                nsCString* value,
37332:                                                NPError* result)
37332: {
37332:     char* v;
37332:     uint32_t len;
37332: 
37332:     *result = mNPNIface->getvalueforurl(mNPP, (NPNURLVariable) variable,
37332:                                         url.get(), &v, &len);
37332:     if (NPERR_NO_ERROR == *result)
37332:         value->Adopt(v, len);
37332: 
37332:     return true;
37332: }
37332: 
37332: bool
37332: PluginInstanceParent::AnswerNPN_SetValueForURL(const NPNURLVariable& variable,
37332:                                                const nsCString& url,
37332:                                                const nsCString& value,
37332:                                                NPError* result)
37332: {
37332:     *result = mNPNIface->setvalueforurl(mNPP, (NPNURLVariable) variable,
37332:                                         url.get(), value.get(),
37332:                                         value.Length());
37332:     return true;
37332: }
37332: 
37332: bool
37332: PluginInstanceParent::AnswerNPN_GetAuthenticationInfo(const nsCString& protocol,
37332:                                                       const nsCString& host,
37332:                                                       const int32_t& port,
37332:                                                       const nsCString& scheme,
37332:                                                       const nsCString& realm,
37332:                                                       nsCString* username,
37332:                                                       nsCString* password,
37332:                                                       NPError* result)
37332: {
37332:     char* u;
37332:     uint32_t ulen;
37332:     char* p;
37332:     uint32_t plen;
37332: 
37332:     *result = mNPNIface->getauthenticationinfo(mNPP, protocol.get(),
37332:                                                host.get(), port,
37332:                                                scheme.get(), realm.get(),
37332:                                                &u, &ulen, &p, &plen);
37390:     if (NPERR_NO_ERROR == *result) {
37332:         username->Adopt(u, ulen);
37332:         password->Adopt(p, plen);
37332:     }
37332:     return true;
37332: }
37332: 
36124: #if defined(OS_WIN)
36124: 
37550: /*
37550:   plugin focus changes between processes
37550: 
37550:   focus from dom -> child:
37550:     Focs manager calls on widget to set the focus on the window.
37550:     We pick up the resulting wm_setfocus event here, and forward
37550:     that over ipc to the child which calls set focus on itself. 
37550: 
37550:   focus from child -> focus manager:
37550:     Child picks up the local wm_setfocus and sends it via ipc over
37550:     here. We then post a custom event to widget/src/windows/nswindow
37550:     which fires off a gui event letting the browser know.
37550: */
37550: 
37550: static const PRUnichar kPluginInstanceParentProperty[] =
37550:                          L"PluginInstanceParentProperty";
37550: 
37550: // static
37550: LRESULT CALLBACK
37550: PluginInstanceParent::PluginWindowHookProc(HWND hWnd,
37550:                                            UINT message,
37550:                                            WPARAM wParam,
37550:                                            LPARAM lParam)
37550: {
37550:     PluginInstanceParent* self = reinterpret_cast<PluginInstanceParent*>(
37550:         ::GetPropW(hWnd, kPluginInstanceParentProperty));
37550:     if (!self) {
37550:         NS_NOTREACHED("PluginInstanceParent::PluginWindowHookProc null this ptr!");
37550:         return DefWindowProc(hWnd, message, wParam, lParam);
37550:     }
37550: 
37550:     NS_ASSERTION(self->mPluginHWND == hWnd, "Wrong window!");
37550: 
37550:     switch (message) {
37550:         case WM_SETFOCUS:
38400:         // Let the child plugin window know it should take focus.
37550:         self->CallSetPluginFocus();
37550:         break;
37550: 
37550:         case WM_CLOSE:
37550:         self->UnsubclassPluginWindow();
37550:         break;
37550:     }
37550: 
37550:     return ::CallWindowProc(self->mPluginWndProc, hWnd, message, wParam,
37550:                             lParam);
37550: }
37550: 
37550: void
37550: PluginInstanceParent::SubclassPluginWindow(HWND aWnd)
37550: {
37550:     NS_ASSERTION(!(mPluginHWND && aWnd != mPluginHWND),
37550:       "PluginInstanceParent::SubclassPluginWindow hwnd is not our window!");
37550: 
37550:     if (!mPluginHWND) {
37550:         mPluginHWND = aWnd;
37550:         mPluginWndProc = 
37550:             (WNDPROC)::SetWindowLongPtrA(mPluginHWND, GWLP_WNDPROC,
37550:                          reinterpret_cast<LONG>(PluginWindowHookProc));
37550:         bool bRes = ::SetPropW(mPluginHWND, kPluginInstanceParentProperty, this);
37550:         NS_ASSERTION(mPluginWndProc,
37550:           "PluginInstanceParent::SubclassPluginWindow failed to set subclass!");
37550:         NS_ASSERTION(bRes,
37550:           "PluginInstanceParent::SubclassPluginWindow failed to set prop!");
37550:    }
37550: }
37550: 
37550: void
37550: PluginInstanceParent::UnsubclassPluginWindow()
37550: {
37550:     if (mPluginHWND && mPluginWndProc) {
37550:         ::SetWindowLongPtrA(mPluginHWND, GWLP_WNDPROC,
37550:                             reinterpret_cast<LONG>(mPluginWndProc));
37550: 
37550:         ::RemovePropW(mPluginHWND, kPluginInstanceParentProperty);
37550: 
37550:         mPluginWndProc = NULL;
37550:         mPluginHWND = NULL;
37550:     }
37550: }
37550: 
36124: /* windowless drawing helpers */
36124: 
36271: /*
36271:  * Origin info:
36271:  *
36271:  * windowless, offscreen:
36271:  *
36271:  * WM_WINDOWPOSCHANGED: origin is relative to container 
36271:  * setwindow: origin is 0,0
36271:  * WM_PAINT: origin is 0,0
36271:  *
36271:  * windowless, native:
36271:  *
36271:  * WM_WINDOWPOSCHANGED: origin is relative to container 
36271:  * setwindow: origin is relative to container
36271:  * WM_PAINT: origin is relative to container
36271:  *
36271:  * PluginInstanceParent:
36271:  *
36271:  * painting: mPluginPort (nsIntRect, saved in SetWindow)
36271:  */
36271: 
36271: void
36124: PluginInstanceParent::SharedSurfaceRelease()
36124: {
36124:     mSharedSurfaceDib.Close();
36124: }
36124: 
36124: bool
36124: PluginInstanceParent::SharedSurfaceSetWindow(const NPWindow* aWindow,
36124:                                              NPRemoteWindow& aRemoteWindow)
36124: {
36124:     aRemoteWindow.window = nsnull;
36124:     aRemoteWindow.x      = 0;
36124:     aRemoteWindow.y      = 0;
36124:     aRemoteWindow.width  = aWindow->width;
36124:     aRemoteWindow.height = aWindow->height;
36124:     aRemoteWindow.type   = aWindow->type;
36124: 
36124:     nsIntRect newPort(aWindow->x, aWindow->y, aWindow->width, aWindow->height);
36124: 
36124:     // save the the rect location within the browser window.
36124:     mPluginPort = newPort;
36124: 
36124:     // move the port to our shared surface origin
36124:     newPort.MoveTo(0,0);
36124: 
36124:     // check to see if we have the room in shared surface
36124:     if (mSharedSurfaceDib.IsValid() && mSharedSize.Contains(newPort)) {
36124:       // ok to paint
36124:       aRemoteWindow.surfaceHandle = 0;
36124:       return true;
36124:     }
36124: 
36124:     // allocate a new shared surface
36124:     SharedSurfaceRelease();
36124:     if (NS_FAILED(mSharedSurfaceDib.Create(reinterpret_cast<HDC>(aWindow->window),
36124:                                            newPort.width, newPort.height, 32)))
36124:       return false;
36124: 
36124:     // save the new shared surface size we just allocated
36124:     mSharedSize = newPort;
36124: 
36124:     base::SharedMemoryHandle handle;
36124:     if (NS_FAILED(mSharedSurfaceDib.ShareToProcess(mParent->ChildProcessHandle(), &handle)))
36124:       return false;
36124: 
36124:     aRemoteWindow.surfaceHandle = handle;
36124: 
36124:     return true;
36124: }
36124: 
36270: void
36124: PluginInstanceParent::SharedSurfaceBeforePaint(RECT& rect,
36124:                                                NPRemoteEvent& npremoteevent)
36124: {
36124:     RECT* dr = (RECT*)npremoteevent.event.lParam;
36124:     HDC parentHdc = (HDC)npremoteevent.event.wParam;
36124: 
36124:     nsIntRect dirtyRect(dr->left, dr->top, dr->right-dr->left, dr->bottom-dr->top);
36124:     dirtyRect.MoveBy(-mPluginPort.x, -mPluginPort.y); // should always be smaller than dirtyRect
36124: 
36124:     ::BitBlt(mSharedSurfaceDib.GetHDC(),
36124:              dirtyRect.x,
36124:              dirtyRect.y,
36124:              dirtyRect.width,
36124:              dirtyRect.height,
36124:              parentHdc,
36124:              dr->left,
36124:              dr->top,
36124:              SRCCOPY);
36124: 
36124:     // setup the translated dirty rect we'll send to the child
36124:     rect.left   = dirtyRect.x;
36124:     rect.top    = dirtyRect.y;
36270:     rect.right  = dirtyRect.x + dirtyRect.width;
36270:     rect.bottom = dirtyRect.y + dirtyRect.height;
36124: 
36124:     npremoteevent.event.wParam = WPARAM(0);
36124:     npremoteevent.event.lParam = LPARAM(&rect);
36124: }
36124: 
36124: void
36124: PluginInstanceParent::SharedSurfaceAfterPaint(NPEvent* npevent)
36124: {
36124:     RECT* dr = (RECT*)npevent->lParam;
36124:     HDC parentHdc = (HDC)npevent->wParam;
36124: 
36124:     nsIntRect dirtyRect(dr->left, dr->top, dr->right-dr->left, dr->bottom-dr->top);
36124:     dirtyRect.MoveBy(-mPluginPort.x, -mPluginPort.y);
36124: 
36124:     // src copy the shared dib into the parent surface we are handed.
36124:     ::BitBlt(parentHdc,
36124:              dr->left,
36124:              dr->top,
36124:              dirtyRect.width,
36124:              dirtyRect.height,
36124:              mSharedSurfaceDib.GetHDC(),
36124:              dirtyRect.x,
36124:              dirtyRect.y,
36124:              SRCCOPY);
36124: }
36124: 
36124: #endif // defined(OS_WIN)
37550: 
37550: bool
37550: PluginInstanceParent::AnswerPluginGotFocus()
37550: {
37550:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
37550: 
37550:     // Currently only in use on windows - an rpc event we receive from the
37550:     // child when it's plugin window (or one of it's children) receives keyboard
37550:     // focus. We forward the event down to widget so the dom/focus manager can
37550:     // be updated.
37550: #if defined(OS_WIN)
37550:     ::SendMessage(mPluginHWND, gOOPPPluginFocusEvent, 0, 0);
37550:     return true;
37550: #else
37550:     NS_NOTREACHED("PluginInstanceParent::AnswerPluginGotFocus not implemented!");
37550:     return false;
37550: #endif
37550: }
38103: 
38103: bool
38103: PluginInstanceParent::RecvSetNestedEventState(const bool& aState)
38103: {
38103:     PLUGIN_LOG_DEBUG(("%s state=%i", FULLFUNCTION, (int)aState));
38103: #if defined(OS_WIN)
38103:     PostThreadMessage(GetCurrentThreadId(), aState ?
38103:         gOOPPSpinNativeLoopEvent : gOOPPStopNativeLoopEvent, 0, 0);
38103:     mNestedEventState = aState;
38103:     return true;
38103: #else
38103:     NS_NOTREACHED(
38103:         "PluginInstanceParent::AnswerSetNestedEventState not implemented!");
38103:     return false;
38103: #endif
38103: }
