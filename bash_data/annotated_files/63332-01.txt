29366: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=80:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS execution context.
    1:  */
32777: #include <new>
    1: #include <stdarg.h>
    1: #include <stdlib.h>
    1: #include <string.h>
54883: #ifdef ANDROID
57887: # include <android/log.h>
54883: # include <fstream>
54883: # include <string>
54883: #endif  // ANDROID
43244: 
43244: #include "jsstdint.h"
43244: 
    1: #include "jstypes.h"
55477: #include "jsarena.h"
55477: #include "jsutil.h"
    1: #include "jsclist.h"
    1: #include "jsprf.h"
    1: #include "jsatom.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
    1: #include "jsexn.h"
16519: #include "jsfun.h"
    1: #include "jsgc.h"
42714: #include "jsiter.h"
    1: #include "jslock.h"
31898: #include "jsmath.h"
47439: #include "jsnativestack.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
24874: #include "jspubtd.h"
    1: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
24499: #include "jsstaticcheck.h"
    1: #include "jsstr.h"
17583: #include "jstracer.h"
    1: 
54175: #ifdef JS_METHODJIT
54175: # include "assembler/assembler/MacroAssembler.h"
54175: #endif
54175: 
42714: #include "jscntxtinlines.h"
54707: #include "jscompartment.h"
53840: #include "jsinterpinlines.h"
53840: #include "jsobjinlines.h"
42714: 
42714: #ifdef XP_WIN
52897: # include "jswin.h"
43220: #elif defined(XP_OS2)
43220: # define INCL_DOSMEMMGR
43220: # include <os2.h>
42714: #else
42714: # include <unistd.h>
42714: # include <sys/mman.h>
42714: # if !defined(MAP_ANONYMOUS)
42714: #  if defined(MAP_ANON)
42714: #   define MAP_ANONYMOUS MAP_ANON
42714: #  else
42714: #   define MAP_ANONYMOUS 0
42714: #  endif
42714: # endif
42714: #endif
42714: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
41289: static const size_t ARENA_HEADER_SIZE_HACK = 40;
41289: static const size_t TEMP_POOL_CHUNK_SIZE = 4096 - ARENA_HEADER_SIZE_HACK;
41289: 
62797: static void
62797: FreeContext(JSContext *cx);
62797: 
37777: #ifdef DEBUG
42714: JS_REQUIRES_STACK bool
50466: StackSegment::contains(const JSStackFrame *fp) const
37777: {
42714:     JS_ASSERT(inContext());
37777:     JSStackFrame *start;
37777:     JSStackFrame *stop;
50467:     if (isActive()) {
51446:         JS_ASSERT(cx->hasfp());
51446:         start = cx->fp();
53840:         stop = cx->activeSegment()->initialFrame->prev();
50467:     } else {
51446:         JS_ASSERT(suspendedRegs && suspendedRegs->fp);
51446:         start = suspendedRegs->fp;
53840:         stop = initialFrame->prev();
37777:     }
53840:     for (JSStackFrame *f = start; f != stop; f = f->prev()) {
37777:         if (f == fp)
37777:             return true;
37777:     }
37777:     return false;
37777: }
37777: #endif
37777: 
40339: bool
42714: StackSpace::init()
42714: {
42714:     void *p;
42714: #ifdef XP_WIN
42714:     p = VirtualAlloc(NULL, CAPACITY_BYTES, MEM_RESERVE, PAGE_READWRITE);
42714:     if (!p)
42714:         return false;
42714:     void *check = VirtualAlloc(p, COMMIT_BYTES, MEM_COMMIT, PAGE_READWRITE);
42714:     if (p != check)
42714:         return false;
48470:     base = reinterpret_cast<Value *>(p);
42714:     commitEnd = base + COMMIT_VALS;
42714:     end = base + CAPACITY_VALS;
43220: #elif defined(XP_OS2)
43220:     if (DosAllocMem(&p, CAPACITY_BYTES, PAG_COMMIT | PAG_READ | PAG_WRITE | OBJ_ANY) &&
43220:         DosAllocMem(&p, CAPACITY_BYTES, PAG_COMMIT | PAG_READ | PAG_WRITE))
43220:         return false;
48470:     base = reinterpret_cast<Value *>(p);
43220:     end = base + CAPACITY_VALS;
42714: #else
42714:     JS_ASSERT(CAPACITY_BYTES % getpagesize() == 0);
42714:     p = mmap(NULL, CAPACITY_BYTES, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
42714:     if (p == MAP_FAILED)
42714:         return false;
48470:     base = reinterpret_cast<Value *>(p);
42714:     end = base + CAPACITY_VALS;
42714: #endif
42714:     return true;
42714: }
42714: 
62797: void
62797: StackSpace::finish()
42714: {
42714: #ifdef XP_WIN
48470:     VirtualFree(base, (commitEnd - base) * sizeof(Value), MEM_DECOMMIT);
42714:     VirtualFree(base, 0, MEM_RELEASE);
43220: #elif defined(XP_OS2)
43220:     DosFreeMem(base);
42714: #else
48634: #ifdef SOLARIS
48470:     munmap((caddr_t)base, CAPACITY_BYTES);
48634: #else
48634:     munmap(base, CAPACITY_BYTES);
48634: #endif
42714: #endif
42714: }
42714: 
42714: #ifdef XP_WIN
42714: JS_FRIEND_API(bool)
48470: StackSpace::bumpCommit(Value *from, ptrdiff_t nvals) const
42714: {
42714:     JS_ASSERT(end - from >= nvals);
48470:     Value *newCommit = commitEnd;
48470:     Value *request = from + nvals;
42714: 
42714:     /* Use a dumb loop; will probably execute once. */
42714:     JS_ASSERT((end - newCommit) % COMMIT_VALS == 0);
42714:     do {
42714:         newCommit += COMMIT_VALS;
42714:         JS_ASSERT((end - newCommit) >= 0);
42714:     } while (newCommit < request);
42714: 
42714:     /* The cast is safe because CAPACITY_BYTES is small. */
48470:     int32 size = static_cast<int32>(newCommit - commitEnd) * sizeof(Value);
42714: 
42714:     if (!VirtualAlloc(commitEnd, size, MEM_COMMIT, PAGE_READWRITE))
42714:         return false;
42714:     commitEnd = newCommit;
42714:     return true;
42714: }
42714: #endif
42714: 
53840: void
42714: StackSpace::mark(JSTracer *trc)
42714: {
42714:     /*
42714:      * The correctness/completeness of marking depends on the continuity
50466:      * invariants described by the StackSegment and StackSpace definitions.
53253:      *
53253:      * NB:
53253:      * Stack slots might be torn or uninitialized in the presence of method
53253:      * JIT'd code. Arguments are an exception and are always fully synced
53253:      * (so they can be read by functions).
42714:      */
48470:     Value *end = firstUnused();
50466:     for (StackSegment *seg = currentSegment; seg; seg = seg->getPreviousInMemory()) {
55479:         STATIC_ASSERT(ubound(end) >= 0);
50466:         if (seg->inContext()) {
42714:             /* This may be the only pointer to the initialVarObj. */
53840:             if (seg->hasInitialVarObj())
53840:                 MarkObject(trc, seg->getInitialVarObj(), "varobj");
42714: 
42714:             /* Mark slots/args trailing off of the last stack frame. */
50466:             JSStackFrame *fp = seg->getCurrentFrame();
53316:             MarkStackRangeConservatively(trc, fp->slots(), end);
42714: 
42714:             /* Mark stack frames and slots/args between stack frames. */
53840:             JSStackFrame *initial = seg->getInitialFrame();
53840:             for (JSStackFrame *f = fp; f != initial; f = f->prev()) {
42714:                 js_TraceStackFrame(trc, f);
53840:                 MarkStackRangeConservatively(trc, f->prev()->slots(), (Value *)f);
42714:             }
42714: 
53840:             /* Mark initial stack frame and leading args. */
53840:             js_TraceStackFrame(trc, initial);
53840:             MarkStackRangeConservatively(trc, seg->valueRangeBegin(), (Value *)initial);
42714:         } else {
48531:             /* Mark slots/args trailing off segment. */
53840:             MarkValueRange(trc, seg->valueRangeBegin(), end, "stack");
42714:         }
53840:         end = (Value *)seg;
42714:     }
42714: }
42714: 
53840: bool
53840: StackSpace::pushSegmentForInvoke(JSContext *cx, uintN argc, InvokeArgsGuard *ag)
42714: {
48470:     Value *start = firstUnused();
50468:     ptrdiff_t nvals = VALUES_PER_STACK_SEGMENT + 2 + argc;
42714:     if (!ensureSpace(cx, start, nvals))
42714:         return false;
42714: 
50466:     StackSegment *seg = new(start) StackSegment;
50466:     seg->setPreviousInMemory(currentSegment);
50466:     currentSegment = seg;
42714: 
53840:     ag->cx = cx;
53840:     ag->seg = seg;
53840:     ag->argv_ = seg->valueRangeBegin() + 2;
53840:     ag->argc_ = argc;
42714: 
50467:     /* Use invokeArgEnd to root [vp, vpend) until the frame is pushed. */
50467: #ifdef DEBUG
53840:     ag->prevInvokeSegment = invokeSegment;
50467:     invokeSegment = seg;
53840:     ag->prevInvokeFrame = invokeFrame;
50467:     invokeFrame = NULL;
50467: #endif
53840:     ag->prevInvokeArgEnd = invokeArgEnd;
53840:     invokeArgEnd = ag->argv() + ag->argc();
42714:     return true;
42714: }
42714: 
53840: void
50467: StackSpace::popSegmentForInvoke(const InvokeArgsGuard &ag)
42714: {
50467:     JS_ASSERT(!currentSegment->inContext());
50467:     JS_ASSERT(ag.seg == currentSegment);
50467:     JS_ASSERT(invokeSegment == currentSegment);
50468:     JS_ASSERT(invokeArgEnd == ag.argv() + ag.argc());
42714: 
50467:     currentSegment = currentSegment->getPreviousInMemory();
42714: 
50467: #ifdef DEBUG
50467:     invokeSegment = ag.prevInvokeSegment;
50467:     invokeFrame = ag.prevInvokeFrame;
50467: #endif
50467:     invokeArgEnd = ag.prevInvokeArgEnd;
42714: }
42714: 
53840: bool
62791: StackSpace::getSegmentAndFrame(JSContext *cx, uintN vplen, uintN nslots,
53840:                                FrameGuard *fg) const
42714: {
48470:     Value *start = firstUnused();
62791:     uintN nvals = VALUES_PER_STACK_SEGMENT + vplen + VALUES_PER_STACK_FRAME + nslots;
42714:     if (!ensureSpace(cx, start, nvals))
42714:         return false;
42714: 
53840:     fg->seg_ = new(start) StackSegment;
53840:     fg->vp_ = start + VALUES_PER_STACK_SEGMENT;
53840:     fg->fp_ = reinterpret_cast<JSStackFrame *>(fg->vp() + vplen);
42714:     return true;
42714: }
42714: 
53840: void
62520: StackSpace::pushSegmentAndFrame(JSContext *cx, JSFrameRegs *regs, FrameGuard *fg)
42714: {
53840:     /* Caller should have already initialized regs. */
53840:     JS_ASSERT(regs->fp == fg->fp());
62520:     StackSegment *seg = fg->segment();
53840: 
62520:     /* Register new segment/frame with the context. */
62520:     cx->pushSegmentAndFrame(seg, *regs);
62520: 
62520:     /* Officially push the segment/frame on the stack. */
50466:     seg->setPreviousInMemory(currentSegment);
50466:     currentSegment = seg;
51446: 
62520:     /* Mark as 'pushed' in the guard. */
53840:     fg->cx_ = cx;
42714: }
42714: 
53840: void
53840: StackSpace::popSegmentAndFrame(JSContext *cx)
42714: {
50467:     JS_ASSERT(isCurrentAndActive(cx));
48531:     JS_ASSERT(cx->hasActiveSegment());
62520: 
62520:     /* Officially pop the segment/frame from the stack. */
62520:     currentSegment = currentSegment->getPreviousInMemory();
62520: 
62520:     /* Unregister pushed segment/frame from the context. */
48531:     cx->popSegmentAndFrame();
62520: 
62520:     /*
62520:      * N.B. This StackSpace should be GC-able without any operations after
62520:      * cx->popSegmentAndFrame executes since it can trigger GC.
62520:      */
42714: }
42714: 
51471: FrameGuard::~FrameGuard()
50467: {
50467:     if (!pushed())
50467:         return;
53840:     JS_ASSERT(cx_->activeSegment() == segment());
53840:     JS_ASSERT(cx_->maybefp() == fp());
53840:     cx_->stack().popSegmentAndFrame(cx_);
50467: }
50467: 
53840: bool
53840: StackSpace::getExecuteFrame(JSContext *cx, JSScript *script, ExecuteFrameGuard *fg) const
51471: {
62791:     return getSegmentAndFrame(cx, 2, script->nslots, fg);
53840: }
53840: 
53840: void
53840: StackSpace::pushExecuteFrame(JSContext *cx, JSObject *initialVarObj, ExecuteFrameGuard *fg)
53840: {
53840:     JSStackFrame *fp = fg->fp();
53840:     JSScript *script = fp->script();
53840:     fg->regs_.pc = script->code;
53840:     fg->regs_.fp = fp;
53840:     fg->regs_.sp = fp->base();
62520:     pushSegmentAndFrame(cx, &fg->regs_, fg);
62520:     fg->seg_->setInitialVarObj(initialVarObj);
53840: }
53840: 
53840: bool
53840: StackSpace::pushDummyFrame(JSContext *cx, JSObject &scopeChain, DummyFrameGuard *fg)
53840: {
62791:     if (!getSegmentAndFrame(cx, 0 /*vplen*/, 0 /*nslots*/, fg))
51471:         return false;
53840:     fg->fp()->initDummyFrame(cx, scopeChain);
53840:     fg->regs_.fp = fg->fp();
53840:     fg->regs_.pc = NULL;
53840:     fg->regs_.sp = fg->fp()->slots();
62520:     pushSegmentAndFrame(cx, &fg->regs_, fg);
53840:     return true;
53840: }
51471: 
53840: bool
62791: StackSpace::getGeneratorFrame(JSContext *cx, uintN vplen, uintN nslots, GeneratorFrameGuard *fg)
53840: {
62791:     return getSegmentAndFrame(cx, vplen, nslots, fg);
53840: }
51471: 
53840: void
53840: StackSpace::pushGeneratorFrame(JSContext *cx, JSFrameRegs *regs, GeneratorFrameGuard *fg)
53840: {
53840:     JS_ASSERT(regs->fp == fg->fp());
53840:     JS_ASSERT(regs->fp->prev() == cx->maybefp());
62520:     pushSegmentAndFrame(cx, regs, fg);
53840: }
51471: 
53840: bool
53840: StackSpace::bumpCommitAndLimit(JSStackFrame *base, Value *sp, uintN nvals, Value **limit) const
53840: {
57717:     JS_ASSERT(sp >= firstUnused());
53840:     JS_ASSERT(sp + nvals >= *limit);
53840: #ifdef XP_WIN
53840:     if (commitEnd <= *limit) {
53840:         Value *quotaEnd = (Value *)base + STACK_QUOTA;
53840:         if (sp + nvals < quotaEnd) {
53840:             if (!ensureSpace(NULL, sp, nvals))
53840:                 return false;
53840:             *limit = Min(quotaEnd, commitEnd);
51471:             return true;
51471:         }
53840:     }
53840: #endif
53840:     return false;
53840: }
51471: 
50467: void
50467: FrameRegsIter::initSlow()
50467: {
50467:     if (!curseg) {
50467:         curfp = NULL;
50467:         cursp = NULL;
50467:         curpc = NULL;
50467:         return;
50467:     }
50467: 
50467:     JS_ASSERT(curseg->isSuspended());
50467:     curfp = curseg->getSuspendedFrame();
50467:     cursp = curseg->getSuspendedRegs()->sp;
50467:     curpc = curseg->getSuspendedRegs()->pc;
50467: }
50467: 
42717: /*
50467:  * Using the invariant described in the js::StackSegment comment, we know that,
53840:  * when a pair of prev-linked stack frames are in the same segment, the
53840:  * first frame's address is the top of the prev-frame's stack, modulo missing
42717:  * arguments.
42717:  */
50467: void
53840: FrameRegsIter::incSlow(JSStackFrame *fp, JSStackFrame *prev)
42717: {
53840:     JS_ASSERT(prev);
54832:     JS_ASSERT(curpc == curfp->pc(cx, fp));
53840:     JS_ASSERT(fp == curseg->getInitialFrame());
42717: 
42717:     /*
53840:      * If fp is in cs and the prev-frame is in csprev, it is not necessarily
53840:      * the case that |cs->getPreviousInContext == csprev| or that
53840:      * |csprev->getSuspendedFrame == prev| (because of indirect eval and
53840:      * JS_EvaluateInStackFrame). To compute prev's sp, we need to do a linear
53840:      * scan, keeping track of what is immediately after prev in memory.
42717:      */
50466:     curseg = curseg->getPreviousInContext();
50466:     cursp = curseg->getSuspendedRegs()->sp;
50466:     JSStackFrame *f = curseg->getSuspendedFrame();
53840:     while (f != prev) {
50466:         if (f == curseg->getInitialFrame()) {
50466:             curseg = curseg->getPreviousInContext();
50466:             cursp = curseg->getSuspendedRegs()->sp;
50466:             f = curseg->getSuspendedFrame();
42717:         } else {
53840:             cursp = f->formalArgsEnd();
53840:             f = f->prev();
42717:         }
42717:     }
42717: }
42717: 
53391: AllFramesIter::AllFramesIter(JSContext *cx)
53391:   : curcs(cx->stack().getCurrentSegment()),
53391:     curfp(curcs ? curcs->getCurrentFrame() : NULL)
53391: {
53391: }
53391: 
53391: AllFramesIter&
53391: AllFramesIter::operator++()
53391: {
53391:     JS_ASSERT(!done());
53391:     if (curfp == curcs->getInitialFrame()) {
53391:         curcs = curcs->getPreviousInMemory();
53391:         curfp = curcs ? curcs->getCurrentFrame() : NULL;
53391:     } else {
53840:         curfp = curfp->prev();
53391:     }
53391:     return *this;
53391: }
53391: 
42714: bool
35075: JSThreadData::init()
26569: {
62797: #ifdef DEBUG
62797:     /* The data must be already zeroed. */
62797:     for (size_t i = 0; i != sizeof(*this); ++i)
62797:         JS_ASSERT(reinterpret_cast<uint8*>(this)[i] == 0);
62797: #endif
62797:     if (!stackSpace.init())
62797:         return false;
62797:     dtoaState = js_NewDtoaState();
62797:     if (!dtoaState) {
62797:         finish();
62797:         return false;
62797:     }
42740:     nativeStackBase = GetNativeStackBase();
62797: 
60170: #ifdef JS_TRACER
59733:     /* Set the default size for the code cache to 16MB. */
59733:     maxCodeCacheBytes = 16 * 1024 * 1024;
60170: #endif
59733: 
62797:     return true;
62797: }
62797: 
62797: void
62797: JSThreadData::finish()
62797: {
62797:     if (dtoaState)
62797:         js_DestroyDtoaState(dtoaState);
62797: 
62797:     js_FinishGSNCache(&gsnCache);
62797:     propertyCache.~PropertyCache();
62797:     stackSpace.finish();
62797: }
62797: 
62797: void
62797: JSThreadData::mark(JSTracer *trc)
62797: {
62797:     stackSpace.mark(trc);
62797: }
62797: 
62797: void
62797: JSThreadData::purge(JSContext *cx)
62797: {
62797:     js_PurgeGSNCache(&gsnCache);
62797: 
62797:     /* FIXME: bug 506341. */
62797:     propertyCache.purge(cx);
35075: }
35075: 
26569: #ifdef JS_THREADSAFE
26569: 
62797: static JSThread *
62797: NewThread(void *id)
62797: {
62797:     JS_ASSERT(js_CurrentThreadId() == id);
62797:     JSThread *thread = (JSThread *) js_calloc(sizeof(JSThread));
62797:     if (!thread)
62797:         return NULL;
62797:     JS_INIT_CLIST(&thread->contextList);
62797:     thread->id = id;
62797:     if (!thread->data.init()) {
62797:         js_free(thread);
62797:         return NULL;
62797:     }
62797:     return thread;
62797: }
62797: 
62797: static void
62797: DestroyThread(JSThread *thread)
62797: {
62797:     /* The thread must have zero contexts. */
62797:     JS_ASSERT(JS_CLIST_IS_EMPTY(&thread->contextList));
62797: 
62797:     /*
62797:      * The conservative GC scanner should be disabled when the thread leaves
62797:      * the last request.
62797:      */
62797:     JS_ASSERT(!thread->data.conservativeGC.hasStackToScan());
62797: 
62797:     thread->data.finish();
62797:     js_free(thread);
62797: }
62797: 
34365: JSThread *
34365: js_CurrentThread(JSRuntime *rt)
26569: {
42712:     void *id = js_CurrentThreadId();
26569:     JS_LOCK_GC(rt);
26569: 
26561:     /*
26569:      * We must not race with a GC that accesses cx->thread for JSContext
26569:      * instances on all threads, see bug 476934.
26561:      */
26569:     js_WaitForGC(rt);
42712: 
26561:     JSThread *thread;
42712:     JSThread::Map::AddPtr p = rt->threads.lookupForAdd(id);
42712:     if (p) {
42712:         thread = p->value;
56535: 
56535:         /*
56535:          * If thread has no contexts, it might be left over from a previous
56535:          * thread with the same id but a different stack address.
56535:          */
56535:         if (JS_CLIST_IS_EMPTY(&thread->contextList))
56535:             thread->data.nativeStackBase = GetNativeStackBase();
26569:     } else {
26569:         JS_UNLOCK_GC(rt);
62797:         thread = NewThread(id);
62797:         if (!thread)
34365:             return NULL;
26569:         JS_LOCK_GC(rt);
26569:         js_WaitForGC(rt);
42712:         if (!rt->threads.relookupOrAdd(p, id, thread)) {
26569:             JS_UNLOCK_GC(rt);
62797:             DestroyThread(thread);
34365:             return NULL;
26560:         }
26560: 
42712:         /* Another thread cannot add an entry for the current thread id. */
42712:         JS_ASSERT(p->value == thread);
13825:     }
42712:     JS_ASSERT(thread->id == id);
58216: 
58216: #ifdef DEBUG
58216:     char* gnsb = (char*) GetNativeStackBase();
58216:     JS_ASSERT(gnsb + 0      == (char*) thread->data.nativeStackBase ||
58216:               /* Work around apparent glibc bug; see bug 608526. */
58216:               gnsb + 0x1000 == (char*) thread->data.nativeStackBase ||
58216:               gnsb + 0x2000 == (char*) thread->data.nativeStackBase ||
58216:               gnsb + 0x3000 == (char*) thread->data.nativeStackBase);
58216: #endif
    1: 
34365:     return thread;
34365: }
34365: 
34365: JSBool
34365: js_InitContextThread(JSContext *cx)
34365: {
34365:     JSThread *thread = js_CurrentThread(cx->runtime);
34365:     if (!thread)
34365:         return false;
34365: 
 9058:     JS_APPEND_LINK(&cx->threadLinks, &thread->contextList);
    1:     cx->thread = thread;
26569:     return true;
26569: }
26569: 
26569: void
26569: js_ClearContextThread(JSContext *cx)
26569: {
26569:     JS_ASSERT(CURRENT_THREAD_IS_ME(cx->thread));
26569:     JS_REMOVE_AND_INIT_LINK(&cx->threadLinks);
26569:     cx->thread = NULL;
26569: }
26569: 
    1: #endif /* JS_THREADSAFE */
    1: 
34365: JSThreadData *
34365: js_CurrentThreadData(JSRuntime *rt)
34365: {
34365: #ifdef JS_THREADSAFE
34366:     JSThread *thread = js_CurrentThread(rt);
34365:     if (!thread)
34365:         return NULL;
34365: 
34365:     return &thread->data;
34365: #else
34365:     return &rt->threadData;
34365: #endif
34365: }
34365: 
26569: JSBool
26569: js_InitThreads(JSRuntime *rt)
26569: {
26569: #ifdef JS_THREADSAFE
42712:     if (!rt->threads.init(4))
26569:         return false;
26569: #else
42714:     if (!rt->threadData.init())
42714:         return false;
26569: #endif
26569:     return true;
26569: }
26569: 
26569: void
26569: js_FinishThreads(JSRuntime *rt)
26569: {
26569: #ifdef JS_THREADSAFE
42712:     if (!rt->threads.initialized())
26569:         return;
42712:     for (JSThread::Map::Range r = rt->threads.all(); !r.empty(); r.popFront()) {
42712:         JSThread *thread = r.front().value;
62797:         JS_ASSERT(JS_CLIST_IS_EMPTY(&thread->contextList));
62797:         DestroyThread(thread);
42712:     }
42712:     rt->threads.clear();
26569: #else
35075:     rt->threadData.finish();
26569: #endif
26569: }
26569: 
26569: void
26569: js_PurgeThreads(JSContext *cx)
26569: {
26569: #ifdef JS_THREADSAFE
42712:     for (JSThread::Map::Enum e(cx->runtime->threads);
42712:          !e.empty();
42712:          e.popFront()) {
42712:         JSThread *thread = e.front().value;
42712: 
42712:         if (JS_CLIST_IS_EMPTY(&thread->contextList)) {
42712:             JS_ASSERT(cx->thread != thread);
62797: 
62797:             DestroyThread(thread);
42712:             e.removeFront();
42712:         } else {
42712:             thread->data.purge(cx);
42712:         }
42712:     }
26569: #else
35075:     cx->runtime->threadData.purge(cx);
26569: #endif
26569: }
26569: 
    1: JSContext *
    1: js_NewContext(JSRuntime *rt, size_t stackChunkSize)
    1: {
    1:     JSContext *cx;
    1:     JSBool ok, first;
    1:     JSContextCallback cxCallback;
    1: 
24872:     /*
24872:      * We need to initialize the new context fully before adding it to the
24872:      * runtime list. After that it can be accessed from another thread via
24872:      * js_ContextIterator.
24872:      */
32777:     void *mem = js_calloc(sizeof *cx);
32777:     if (!mem)
    1:         return NULL;
    1: 
32777:     cx = new (mem) JSContext(rt);
 2433:     cx->debugHooks = &rt->globalDebugHooks;
    1: #if JS_STACK_GROWTH_DIRECTION > 0
    1:     cx->stackLimit = (jsuword) -1;
    1: #endif
 5344:     cx->scriptStackQuota = JS_DEFAULT_SCRIPT_STACK_QUOTA;
24872:     JS_STATIC_ASSERT(JSVERSION_DEFAULT == 0);
53848:     JS_ASSERT(cx->findVersion() == JSVERSION_DEFAULT);
24872:     VOUCH_DOES_NOT_REQUIRE_STACK();
24872: 
47609:     JS_InitArenaPool(&cx->tempPool, "temp", TEMP_POOL_CHUNK_SIZE, sizeof(jsdouble),
47609:                      &cx->scriptStackQuota);
50491:     JS_InitArenaPool(&cx->regExpPool, "regExp", TEMP_POOL_CHUNK_SIZE, sizeof(int),
50491:                      &cx->scriptStackQuota);
24872: 
24872:     JS_ASSERT(cx->resolveFlags == 0);
    1: 
61229:     if (!cx->busyArrays.init()) {
62797:         FreeContext(cx);
61229:         return NULL;
61229:     }
61229: 
26569: #ifdef JS_THREADSAFE
26569:     if (!js_InitContextThread(cx)) {
62797:         FreeContext(cx);
26569:         return NULL;
26569:     }
26569: #endif
26569: 
26569:     /*
26569:      * Here the GC lock is still held after js_InitContextThread took it and
26569:      * the GC is not running on another thread.
26569:      */
26561:     for (;;) {
    1:         if (rt->state == JSRTS_UP) {
26058:             JS_ASSERT(!JS_CLIST_IS_EMPTY(&rt->contextList));
26058:             first = JS_FALSE;
    1:             break;
    1:         }
    1:         if (rt->state == JSRTS_DOWN) {
26058:             JS_ASSERT(JS_CLIST_IS_EMPTY(&rt->contextList));
26058:             first = JS_TRUE;
    1:             rt->state = JSRTS_LAUNCHING;
    1:             break;
    1:         }
    1:         JS_WAIT_CONDVAR(rt->stateChange, JS_NO_TIMEOUT);
26569: 
26569:         /*
26569:          * During the above wait after we are notified about the state change
26569:          * but before we wake up, another thread could enter the GC from
26569:          * js_DestroyContext, bug 478336. So we must wait here to ensure that
26569:          * when we exit the loop with the first flag set to true, that GC is
26569:          * finished.
26569:          */
26569:         js_WaitForGC(rt);
    1:     }
23092:     JS_APPEND_LINK(&cx->link, &rt->contextList);
    1:     JS_UNLOCK_GC(rt);
    1: 
40306:     js_InitRandom(cx);
40306: 
    1:     /*
    1:      * If cx is the first context on this runtime, initialize well-known atoms,
    1:      * keywords, numbers, and strings.  If one of these steps should fail, the
    1:      * runtime will be left in a partially initialized state, with zeroes and
    1:      * nulls stored in the default-initialized remainder of the struct.  We'll
    1:      * clean the runtime up under js_DestroyContext, because cx will be "last"
    1:      * as well as "first".
    1:      */
    1:     if (first) {
    1: #ifdef JS_THREADSAFE
    1:         JS_BeginRequest(cx);
    1: #endif
 4342:         ok = js_InitCommonAtoms(cx);
 4342: 
    1:         /*
 4342:          * scriptFilenameTable may be left over from a previous episode of
 4342:          * non-zero contexts alive in rt, so don't re-init the table if it's
 4342:          * not necessary.
    1:          */
    1:         if (ok && !rt->scriptFilenameTable)
    1:             ok = js_InitRuntimeScriptState(rt);
    1:         if (ok)
    1:             ok = js_InitRuntimeNumberState(cx);
37766: 
    1: #ifdef JS_THREADSAFE
    1:         JS_EndRequest(cx);
    1: #endif
    1:         if (!ok) {
    1:             js_DestroyContext(cx, JSDCM_NEW_FAILED);
    1:             return NULL;
    1:         }
    1: 
40840:         AutoLockGC lock(rt);
    1:         rt->state = JSRTS_UP;
    1:         JS_NOTIFY_ALL_CONDVAR(rt->stateChange);
    1:     }
    1: 
    1:     cxCallback = rt->cxCallback;
    1:     if (cxCallback && !cxCallback(cx, JSCONTEXT_NEW)) {
    1:         js_DestroyContext(cx, JSDCM_NEW_FAILED);
    1:         return NULL;
    1:     }
17442: 
    1:     return cx;
    1: }
    1: 
24375: #if defined DEBUG && defined XP_UNIX
24375: # include <stdio.h>
24375: 
27012: class JSAutoFile {
24869: public:
27012:     JSAutoFile() : mFile(NULL) {}
24869: 
27012:     ~JSAutoFile() {
27012:         if (mFile)
27012:             fclose(mFile);
24869:     }
24869: 
24869:     FILE *open(const char *fname, const char *mode) {
27012:         return mFile = fopen(fname, mode);
24869:     }
24869:     operator FILE *() {
27012:         return mFile;
24869:     }
24869: 
24869: private:
27012:     FILE *mFile;
24869: };
24869: 
24375: static void
24375: DumpEvalCacheMeter(JSContext *cx)
24375: {
48676:     if (const char *filename = getenv("JS_EVALCACHE_STATFILE")) {
24375:         struct {
24375:             const char *name;
24375:             ptrdiff_t  offset;
24375:         } table[] = {
24375: #define frob(x) { #x, offsetof(JSEvalCacheMeter, x) }
24375:             EVAL_CACHE_METER_LIST(frob)
24375: #undef frob
24375:         };
59733:         JSEvalCacheMeter *ecm = &cx->compartment->evalCacheMeter;
24375: 
27012:         static JSAutoFile fp;
48676:         if (!fp && !fp.open(filename, "w"))
24375:             return;
24375: 
24375:         fprintf(fp, "eval cache meter (%p):\n",
24375: #ifdef JS_THREADSAFE
24869:                 (void *) cx->thread
24375: #else
24869:                 (void *) cx->runtime
24375: #endif
24375:                 );
24375:         for (uintN i = 0; i < JS_ARRAY_LENGTH(table); ++i) {
24375:             fprintf(fp, "%-8.8s  %llu\n",
33132:                     table[i].name,
33132:                     (unsigned long long int) *(uint64 *)((uint8 *)ecm + table[i].offset));
24375:         }
24375:         fprintf(fp, "hit ratio %g%%\n", ecm->hit * 100. / ecm->probe);
24375:         fprintf(fp, "avg steps %g\n", double(ecm->step) / ecm->probe);
24375:         fflush(fp);
24375:     }
48676: }
24375: # define DUMP_EVAL_CACHE_METER(cx) DumpEvalCacheMeter(cx)
27012: 
48676: static void
48676: DumpFunctionCountMap(const char *title, JSRuntime::FunctionCountMap &map, FILE *fp)
48676: {
48676:     fprintf(fp, "\n%s count map:\n", title);
48676: 
48676:     for (JSRuntime::FunctionCountMap::Range r = map.all(); !r.empty(); r.popFront()) {
48676:         JSFunction *fun = r.front().key;
48676:         int32 count = r.front().value;
48676: 
48676:         fprintf(fp, "%10d %s:%u\n", count, fun->u.i.script->filename, fun->u.i.script->lineno);
48676:     }
48676: }
48676: 
27012: static void
27012: DumpFunctionMeter(JSContext *cx)
27012: {
48676:     if (const char *filename = cx->runtime->functionMeterFilename) {
27012:         struct {
27012:             const char *name;
27012:             ptrdiff_t  offset;
27012:         } table[] = {
27012: #define frob(x) { #x, offsetof(JSFunctionMeter, x) }
27012:             FUNCTION_KIND_METER_LIST(frob)
27012: #undef frob
27012:         };
27012:         JSFunctionMeter *fm = &cx->runtime->functionMeter;
27012: 
27012:         static JSAutoFile fp;
48676:         if (!fp && !fp.open(filename, "w"))
27012:             return;
48676: 
48676:         fprintf(fp, "function meter (%s):\n", cx->runtime->lastScriptFilename);
48676:         for (uintN i = 0; i < JS_ARRAY_LENGTH(table); ++i)
48676:             fprintf(fp, "%-19.19s %d\n", table[i].name, *(int32 *)((uint8 *)fm + table[i].offset));
48676: 
48676:         DumpFunctionCountMap("method read barrier", cx->runtime->methodReadBarrierCountMap, fp);
48676:         DumpFunctionCountMap("unjoined function", cx->runtime->unjoinedFunctionCountMap, fp);
48676: 
48676:         putc('\n', fp);
48676:         fflush(fp);
48676:     }
48656: }
48599: 
27012: # define DUMP_FUNCTION_METER(cx)   DumpFunctionMeter(cx)
27012: 
27012: #endif /* DEBUG && XP_UNIX */
27012: 
27012: #ifndef DUMP_EVAL_CACHE_METER
24375: # define DUMP_EVAL_CACHE_METER(cx) ((void) 0)
24375: #endif
24375: 
27012: #ifndef DUMP_FUNCTION_METER
27012: # define DUMP_FUNCTION_METER(cx)   ((void) 0)
27012: #endif
27012: 
    1: void
    1: js_DestroyContext(JSContext *cx, JSDestroyContextMode mode)
    1: {
    1:     JSRuntime *rt;
    1:     JSContextCallback cxCallback;
    1:     JSBool last;
    1: 
43281:     JS_ASSERT(!cx->enumerators);
43281: 
28456:     rt = cx->runtime;
24871: #ifdef JS_THREADSAFE
26670:     /*
26670:      * For API compatibility we allow to destroy contexts without a thread in
26670:      * optimized builds. We assume that the embedding knows that an OOM error
26670:      * cannot happen in JS_SetContextThread.
26670:      */
26670:     JS_ASSERT(cx->thread && CURRENT_THREAD_IS_ME(cx->thread));
26670:     if (!cx->thread)
26670:         JS_SetContextThread(cx);
    1: 
53548:     /*
53548:      * For API compatibility we support destroying contexts with non-zero
53548:      * cx->outstandingRequests but we assume that all JS_BeginRequest calls
56559:      * on this cx contributes to cx->thread->data.requestDepth and there is no
53548:      * JS_SuspendRequest calls that set aside the counter.
53548:      */
56559:     JS_ASSERT(cx->outstandingRequests <= cx->thread->data.requestDepth);
28456: #endif
28455: 
    1:     if (mode != JSDCM_NEW_FAILED) {
    1:         cxCallback = rt->cxCallback;
    1:         if (cxCallback) {
    1:             /*
    1:              * JSCONTEXT_DESTROY callback is not allowed to fail and must
    1:              * return true.
    1:              */
    1: #ifdef DEBUG
    1:             JSBool callbackStatus =
    1: #endif
    1:             cxCallback(cx, JSCONTEXT_DESTROY);
    1:             JS_ASSERT(callbackStatus);
    1:         }
    1:     }
    1: 
    1:     JS_LOCK_GC(rt);
    1:     JS_ASSERT(rt->state == JSRTS_UP || rt->state == JSRTS_LAUNCHING);
24872: #ifdef JS_THREADSAFE
24872:     /*
24872:      * Typically we are called outside a request, so ensure that the GC is not
24872:      * running before removing the context from rt->contextList, see bug 477021.
24872:      */
56559:     if (cx->thread->data.requestDepth == 0)
24872:         js_WaitForGC(rt);
24872: #endif
23092:     JS_REMOVE_LINK(&cx->link);
    1:     last = (rt->contextList.next == &rt->contextList);
    1:     if (last)
    1:         rt->state = JSRTS_LANDING;
26569:     if (last || mode == JSDCM_FORCE_GC || mode == JSDCM_MAYBE_GC
26569: #ifdef JS_THREADSAFE
53548:         || cx->outstandingRequests != 0
26569: #endif
26569:         ) {
28663:         JS_ASSERT(!rt->gcRunning);
28455: 
    1:         JS_UNLOCK_GC(rt);
    1: 
    1:         if (last) {
    1: #ifdef JS_THREADSAFE
    1:             /*
53548:              * If this thread is not in a request already, begin one now so
53548:              * that we wait for any racing GC started on a not-last context to
53548:              * finish, before we plow ahead and unpin atoms. Note that even
53548:              * though we begin a request here if necessary, we end all
53548:              * thread's requests before forcing a final GC. This lets any
53548:              * not-last context destruction racing in another thread try to
53548:              * force or maybe run the GC, but by that point, rt->state will
53548:              * not be JSRTS_UP, and that GC attempt will return early.
    1:              */
56559:             if (cx->thread->data.requestDepth == 0)
    1:                 JS_BeginRequest(cx);
    1: #endif
    1: 
    1:             js_FinishRuntimeNumberState(cx);
    1: 
 4342:             /* Unpin all common atoms before final GC. */
 4342:             js_FinishCommonAtoms(cx);
 4076: 
    1:             /* Clear debugging state to remove GC roots. */
    1:             JS_ClearAllTraps(cx);
    1:             JS_ClearAllWatchPoints(cx);
    1:         }
    1: 
    1: #ifdef JS_THREADSAFE
    1:         /*
    1:          * Destroying a context implicitly calls JS_EndRequest().  Also, we must
    1:          * end our request here in case we are "last" -- in that event, another
    1:          * js_DestroyContext that was not last might be waiting in the GC for our
    1:          * request to end.  We'll let it run below, just before we do the truly
    1:          * final GC and then free atom state.
    1:          */
53548:         while (cx->outstandingRequests != 0)
    1:             JS_EndRequest(cx);
    1: #endif
    1: 
    1:         if (last) {
60258:             js_GC(cx, NULL, GC_LAST_CONTEXT);
24375:             DUMP_EVAL_CACHE_METER(cx);
27012:             DUMP_FUNCTION_METER(cx);
    1: 
    1:             /* Take the runtime down, now that it has no contexts or atoms. */
    1:             JS_LOCK_GC(rt);
    1:             rt->state = JSRTS_DOWN;
    1:             JS_NOTIFY_ALL_CONDVAR(rt->stateChange);
    1:         } else {
    1:             if (mode == JSDCM_FORCE_GC)
60258:                 js_GC(cx, NULL, GC_NORMAL);
    1:             else if (mode == JSDCM_MAYBE_GC)
    1:                 JS_MaybeGC(cx);
26569:             JS_LOCK_GC(rt);
26569:             js_WaitForGC(rt);
    1:         }
26569:     }
26569: #ifdef JS_THREADSAFE
53548: #ifdef DEBUG
53548:     JSThread *t = cx->thread;
53548: #endif
26569:     js_ClearContextThread(cx);
56559:     JS_ASSERT_IF(JS_CLIST_IS_EMPTY(&t->contextList), !t->data.requestDepth);
26569: #endif
43244: #ifdef JS_METER_DST_OFFSET_CACHING
43244:     cx->dstOffsetCache.dumpStats();
43244: #endif
26569:     JS_UNLOCK_GC(rt);
62797:     FreeContext(cx);
62797: }
62797: 
62797: static void
62797: FreeContext(JSContext *cx)
62797: {
62797: #ifdef JS_THREADSAFE
62797:     JS_ASSERT(!cx->thread);
62797: #endif
62797: 
62797:     /* Free the stuff hanging off of cx. */
62797:     VOUCH_DOES_NOT_REQUIRE_STACK();
62797:     JS_FinishArenaPool(&cx->tempPool);
62797:     JS_FinishArenaPool(&cx->regExpPool);
62797: 
62797:     if (cx->lastMessage)
62797:         js_free(cx->lastMessage);
62797: 
62797:     /* Remove any argument formatters. */
62797:     JSArgumentFormatMap *map = cx->argumentFormatMap;
62797:     while (map) {
62797:         JSArgumentFormatMap *temp = map;
62797:         map = map->next;
62797:         cx->free(temp);
62797:     }
62797: 
62797:     /* Destroy the resolve recursion damper. */
62797:     if (cx->resolvingTable) {
62797:         JS_DHashTableDestroy(cx->resolvingTable);
62797:         cx->resolvingTable = NULL;
62797:     }
62797: 
62797:     /* Finally, free cx itself. */
62797:     cx->~JSContext();
62797:     js_free(cx);
    1: }
    1: 
23442: JSContext *
    1: js_ContextIterator(JSRuntime *rt, JSBool unlocked, JSContext **iterp)
    1: {
    1:     JSContext *cx = *iterp;
    1: 
41103:     Conditionally<AutoLockGC> lockIf(!!unlocked, rt);
23092:     cx = js_ContextFromLinkField(cx ? cx->link.next : rt->contextList.next);
23092:     if (&cx->link == &rt->contextList)
    1:         cx = NULL;
    1:     *iterp = cx;
    1:     return cx;
    1: }
    1: 
25087: JS_FRIEND_API(JSContext *)
25087: js_NextActiveContext(JSRuntime *rt, JSContext *cx)
25087: {
25087:     JSContext *iter = cx;
25087: #ifdef JS_THREADSAFE
25087:     while ((cx = js_ContextIterator(rt, JS_FALSE, &iter)) != NULL) {
56559:         if (cx->outstandingRequests && cx->thread->data.requestDepth)
25087:             break;
25087:     }
25087:     return cx;
25087: #else
25087:     return js_ContextIterator(rt, JS_FALSE, &iter);
25087: #endif
25087: }
25087: 
62797: static JSDHashNumber
62797: resolving_HashKey(JSDHashTable *table, const void *ptr)
62797: {
62797:     const JSResolvingKey *key = (const JSResolvingKey *)ptr;
62794: 
62797:     return (JSDHashNumber(uintptr_t(key->obj)) >> JS_GCTHING_ALIGN) ^ JSID_BITS(key->id);
    1: }
    1: 
62797: static JSBool
62797: resolving_MatchEntry(JSDHashTable *table,
62797:                      const JSDHashEntryHdr *hdr,
62797:                      const void *ptr)
62797: {
62797:     const JSResolvingEntry *entry = (const JSResolvingEntry *)hdr;
62797:     const JSResolvingKey *key = (const JSResolvingKey *)ptr;
62797: 
62797:     return entry->key.obj == key->obj && entry->key.id == key->id;
62797: }
62797: 
62797: static const JSDHashTableOps resolving_dhash_ops = {
62797:     JS_DHashAllocTable,
62797:     JS_DHashFreeTable,
62797:     resolving_HashKey,
62797:     resolving_MatchEntry,
62797:     JS_DHashMoveEntryStub,
62797:     JS_DHashClearEntryStub,
62797:     JS_DHashFinalizeStub,
62797:     NULL
62797: };
62797: 
62797: JSBool
62797: js_StartResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
62797:                   JSResolvingEntry **entryp)
62797: {
62797:     JSDHashTable *table;
62797:     JSResolvingEntry *entry;
62797: 
62797:     table = cx->resolvingTable;
62797:     if (!table) {
62797:         table = JS_NewDHashTable(&resolving_dhash_ops, NULL,
62797:                                  sizeof(JSResolvingEntry),
62797:                                  JS_DHASH_MIN_SIZE);
62797:         if (!table)
62797:             goto outofmem;
62797:         cx->resolvingTable = table;
62797:     }
62797: 
62797:     entry = (JSResolvingEntry *)
62797:             JS_DHashTableOperate(table, key, JS_DHASH_ADD);
62797:     if (!entry)
62797:         goto outofmem;
62797: 
62797:     if (entry->flags & flag) {
62797:         /* An entry for (key, flag) exists already -- dampen recursion. */
62797:         entry = NULL;
62797:     } else {
62797:         /* Fill in key if we were the first to add entry, then set flag. */
62797:         if (!entry->key.obj)
62797:             entry->key = *key;
62797:         entry->flags |= flag;
62797:     }
62797:     *entryp = entry;
62797:     return JS_TRUE;
62797: 
62797: outofmem:
62797:     JS_ReportOutOfMemory(cx);
62797:     return JS_FALSE;
62797: }
62797: 
62797: void
62797: js_StopResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
62797:                  JSResolvingEntry *entry, uint32 generation)
62797: {
62797:     JSDHashTable *table;
62797: 
62797:     /*
62797:      * Clear flag from entry->flags and return early if other flags remain.
62797:      * We must take care to re-lookup entry if the table has changed since
62797:      * it was found by js_StartResolving.
62797:      */
62797:     table = cx->resolvingTable;
62797:     if (!entry || table->generation != generation) {
62797:         entry = (JSResolvingEntry *)
62797:                 JS_DHashTableOperate(table, key, JS_DHASH_LOOKUP);
62797:     }
62797:     JS_ASSERT(JS_DHASH_ENTRY_IS_BUSY(&entry->hdr));
62797:     entry->flags &= ~flag;
62797:     if (entry->flags)
62797:         return;
62797: 
62797:     /*
62797:      * Do a raw remove only if fewer entries were removed than would cause
62797:      * alpha to be less than .5 (alpha is at most .75).  Otherwise, we just
62797:      * call JS_DHashTableOperate to re-lookup the key and remove its entry,
62797:      * compressing or shrinking the table as needed.
62797:      */
62797:     if (table->removedCount < JS_DHASH_TABLE_SIZE(table) >> 2)
62797:         JS_DHashTableRawRemove(table, &entry->hdr);
62797:     else
62797:         JS_DHashTableOperate(table, key, JS_DHASH_REMOVE);
62797: }
    1: 
    1: static void
36234: ReportError(JSContext *cx, const char *message, JSErrorReport *reportp,
36234:             JSErrorCallback callback, void *userRef)
    1: {
    1:     /*
    1:      * Check the error report, and set a JavaScript-catchable exception
    1:      * if the error is defined to have an associated exception.  If an
    1:      * exception is thrown, then the JSREPORT_EXCEPTION flag will be set
    1:      * on the error report, and exception-aware hosts should ignore it.
    1:      */
    1:     JS_ASSERT(reportp);
36234:     if ((!callback || callback == js_GetErrorMessage) &&
36234:         reportp->errorNumber == JSMSG_UNCAUGHT_EXCEPTION)
    1:         reportp->flags |= JSREPORT_EXCEPTION;
    1: 
    1:     /*
    1:      * Call the error reporter only if an exception wasn't raised.
    1:      *
    1:      * If an exception was raised, then we call the debugErrorHook
    1:      * (if present) to give it a chance to see the error before it
    1:      * propagates out of scope.  This is needed for compatability
    1:      * with the old scheme.
    1:      */
36234:     if (!JS_IsRunning(cx) ||
36234:         !js_ErrorToException(cx, message, reportp, callback, userRef)) {
    1:         js_ReportErrorAgain(cx, message, reportp);
 2433:     } else if (cx->debugHooks->debugErrorHook && cx->errorReporter) {
 2433:         JSDebugErrorHook hook = cx->debugHooks->debugErrorHook;
    1:         /* test local in case debugErrorHook changed on another thread */
    1:         if (hook)
 2433:             hook(cx, message, reportp, cx->debugHooks->debugErrorHookData);
    1:     }
    1: }
    1: 
22652: /* The report must be initially zeroed. */
22652: static void
22652: PopulateReportBlame(JSContext *cx, JSErrorReport *report)
22652: {
22652:     /*
22652:      * Walk stack until we find a frame that is associated with some script
22652:      * rather than a native frame.
22652:      */
53840:     for (JSStackFrame *fp = js_GetTopStackFrame(cx); fp; fp = fp->prev()) {
42717:         if (fp->pc(cx)) {
53840:             report->filename = fp->script()->filename;
22652:             report->lineno = js_FramePCToLineNumber(cx, fp);
22652:             break;
22652:         }
22652:     }
22652: }
22652: 
    1: /*
    1:  * We don't post an exception in this case, since doing so runs into
    1:  * complications of pre-allocating an exception object which required
    1:  * running the Exception class initializer early etc.
    1:  * Instead we just invoke the errorReporter with an "Out Of Memory"
    1:  * type message, and then hope the process ends swiftly.
    1:  */
    1: void
    1: js_ReportOutOfMemory(JSContext *cx)
    1: {
27060: #ifdef JS_TRACER
27060:     /*
27060:      * If we are in a builtin called directly from trace, don't report an
27060:      * error. We will retry in the interpreter instead.
27060:      */
62033:     if (JS_ON_TRACE(cx) && !JS_TRACE_MONITOR_ON_TRACE(cx)->bailExit)
27060:         return;
27060: #endif
27060: 
    1:     JSErrorReport report;
    1:     JSErrorReporter onError = cx->errorReporter;
    1: 
    1:     /* Get the message for this error, but we won't expand any arguments. */
    1:     const JSErrorFormatString *efs =
    1:         js_GetLocalizedErrorMessage(cx, NULL, NULL, JSMSG_OUT_OF_MEMORY);
    1:     const char *msg = efs ? efs->format : "Out of memory";
    1: 
    1:     /* Fill out the report, but don't do anything that requires allocation. */
40229:     PodZero(&report);
    1:     report.flags = JSREPORT_ERROR;
    1:     report.errorNumber = JSMSG_OUT_OF_MEMORY;
22652:     PopulateReportBlame(cx, &report);
    1: 
    1:     /*
11758:      * If debugErrorHook is present then we give it a chance to veto sending
11758:      * the error on to the regular ErrorReporter. We also clear a pending
11758:      * exception if any now so the hooks can replace the out-of-memory error
11758:      * by a script-catchable exception.
    1:      */
60211:     cx->clearPendingException();
    1:     if (onError) {
 2433:         JSDebugErrorHook hook = cx->debugHooks->debugErrorHook;
    1:         if (hook &&
 2433:             !hook(cx, msg, &report, cx->debugHooks->debugErrorHookData)) {
    1:             onError = NULL;
    1:         }
    1:     }
    1: 
    1:     if (onError)
    1:         onError(cx, msg, &report);
    1: }
    1: 
 8296: void
 8296: js_ReportOutOfScriptQuota(JSContext *cx)
 8296: {
 8296:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
 8296:                          JSMSG_SCRIPT_STACK_QUOTA);
 8296: }
 8296: 
51514: JS_FRIEND_API(void)
 8296: js_ReportOverRecursed(JSContext *cx)
 8296: {
 8296:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_OVER_RECURSED);
 8296: }
 8296: 
12983: void
12983: js_ReportAllocationOverflow(JSContext *cx)
12983: {
12983:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_ALLOC_OVERFLOW);
12983: }
12983: 
35302: /*
35302:  * Given flags and the state of cx, decide whether we should report an
35302:  * error, a warning, or just continue execution normally.  Return
35302:  * true if we should continue normally, without reporting anything;
35302:  * otherwise, adjust *flags as appropriate and return false.
35302:  */
35302: static bool
35302: checkReportFlags(JSContext *cx, uintN *flags)
35302: {
35302:     if (JSREPORT_IS_STRICT_MODE_ERROR(*flags)) {
39322:         /*
39322:          * Error in strict code; warning with strict option; okay otherwise.
39322:          * We assume that if the top frame is a native, then it is strict if
39322:          * the nearest scripted frame is strict, see bug 536306.
39322:          */
39322:         JSStackFrame *fp = js_GetScriptedCaller(cx, NULL);
53840:         if (fp && fp->script()->strictModeCode)
35302:             *flags &= ~JSREPORT_WARNING;
61450:         else if (cx->hasStrictOption())
35302:             *flags |= JSREPORT_WARNING;
35302:         else
35302:             return true;
35302:     } else if (JSREPORT_IS_STRICT(*flags)) {
35302:         /* Warning/error only when JSOPTION_STRICT is set. */
61450:         if (!cx->hasStrictOption())
35302:             return true;
35302:     }
35302: 
35302:     /* Warnings become errors when JSOPTION_WERROR is set. */
61450:     if (JSREPORT_IS_WARNING(*flags) && cx->hasWErrorOption())
35302:         *flags &= ~JSREPORT_WARNING;
35302: 
35302:     return false;
35302: }
35302: 
    1: JSBool
    1: js_ReportErrorVA(JSContext *cx, uintN flags, const char *format, va_list ap)
    1: {
    1:     char *message;
    1:     jschar *ucmessage;
    1:     size_t messagelen;
    1:     JSErrorReport report;
    1:     JSBool warning;
    1: 
35302:     if (checkReportFlags(cx, &flags))
    1:         return JS_TRUE;
    1: 
    1:     message = JS_vsmprintf(format, ap);
    1:     if (!message)
    1:         return JS_FALSE;
    1:     messagelen = strlen(message);
    1: 
40229:     PodZero(&report);
    1:     report.flags = flags;
    1:     report.errorNumber = JSMSG_USER_DEFINED_ERROR;
    1:     report.ucmessage = ucmessage = js_InflateString(cx, message, &messagelen);
22652:     PopulateReportBlame(cx, &report);
    1: 
    1:     warning = JSREPORT_IS_WARNING(report.flags);
    1: 
36234:     ReportError(cx, message, &report, NULL, NULL);
30851:     js_free(message);
30851:     cx->free(ucmessage);
    1:     return warning;
    1: }
    1: 
    1: /*
    1:  * The arguments from ap need to be packaged up into an array and stored
    1:  * into the report struct.
    1:  *
    1:  * The format string addressed by the error number may contain operands
    1:  * identified by the format {N}, where N is a decimal digit. Each of these
    1:  * is to be replaced by the Nth argument from the va_list. The complete
    1:  * message is placed into reportp->ucmessage converted to a JSString.
    1:  *
    1:  * Returns true if the expansion succeeds (can fail if out of memory).
    1:  */
    1: JSBool
    1: js_ExpandErrorArguments(JSContext *cx, JSErrorCallback callback,
    1:                         void *userRef, const uintN errorNumber,
    1:                         char **messagep, JSErrorReport *reportp,
35302:                         bool charArgs, va_list ap)
    1: {
    1:     const JSErrorFormatString *efs;
    1:     int i;
    1:     int argCount;
    1: 
    1:     *messagep = NULL;
    1: 
    1:     /* Most calls supply js_GetErrorMessage; if this is so, assume NULL. */
    1:     if (!callback || callback == js_GetErrorMessage)
    1:         efs = js_GetLocalizedErrorMessage(cx, userRef, NULL, errorNumber);
    1:     else
    1:         efs = callback(userRef, NULL, errorNumber);
    1:     if (efs) {
    1:         size_t totalArgsLength = 0;
    1:         size_t argLengths[10]; /* only {0} thru {9} supported */
    1:         argCount = efs->argCount;
    1:         JS_ASSERT(argCount <= 10);
    1:         if (argCount > 0) {
    1:             /*
    1:              * Gather the arguments into an array, and accumulate
    1:              * their sizes. We allocate 1 more than necessary and
    1:              * null it out to act as the caboose when we free the
    1:              * pointers later.
    1:              */
    1:             reportp->messageArgs = (const jschar **)
30851:                 cx->malloc(sizeof(jschar *) * (argCount + 1));
    1:             if (!reportp->messageArgs)
    1:                 return JS_FALSE;
    1:             reportp->messageArgs[argCount] = NULL;
    1:             for (i = 0; i < argCount; i++) {
    1:                 if (charArgs) {
    1:                     char *charArg = va_arg(ap, char *);
    1:                     size_t charArgLength = strlen(charArg);
    1:                     reportp->messageArgs[i]
    1:                         = js_InflateString(cx, charArg, &charArgLength);
    1:                     if (!reportp->messageArgs[i])
    1:                         goto error;
    1:                 } else {
    1:                     reportp->messageArgs[i] = va_arg(ap, jschar *);
    1:                 }
    1:                 argLengths[i] = js_strlen(reportp->messageArgs[i]);
    1:                 totalArgsLength += argLengths[i];
    1:             }
    1:             /* NULL-terminate for easy copying. */
    1:             reportp->messageArgs[i] = NULL;
    1:         }
    1:         /*
    1:          * Parse the error format, substituting the argument X
    1:          * for {X} in the format.
    1:          */
    1:         if (argCount > 0) {
    1:             if (efs->format) {
    1:                 jschar *buffer, *fmt, *out;
    1:                 int expandedArgs = 0;
    1:                 size_t expandedLength;
    1:                 size_t len = strlen(efs->format);
    1: 
    1:                 buffer = fmt = js_InflateString (cx, efs->format, &len);
    1:                 if (!buffer)
    1:                     goto error;
    1:                 expandedLength = len
    1:                                  - (3 * argCount)       /* exclude the {n} */
    1:                                  + totalArgsLength;
    1: 
    1:                 /*
    1:                 * Note - the above calculation assumes that each argument
    1:                 * is used once and only once in the expansion !!!
    1:                 */
    1:                 reportp->ucmessage = out = (jschar *)
30851:                     cx->malloc((expandedLength + 1) * sizeof(jschar));
    1:                 if (!out) {
30851:                     cx->free(buffer);
    1:                     goto error;
    1:                 }
    1:                 while (*fmt) {
    1:                     if (*fmt == '{') {
    1:                         if (isdigit(fmt[1])) {
    1:                             int d = JS7_UNDEC(fmt[1]);
    1:                             JS_ASSERT(d < argCount);
    1:                             js_strncpy(out, reportp->messageArgs[d],
    1:                                        argLengths[d]);
    1:                             out += argLengths[d];
    1:                             fmt += 3;
    1:                             expandedArgs++;
    1:                             continue;
    1:                         }
    1:                     }
    1:                     *out++ = *fmt++;
    1:                 }
    1:                 JS_ASSERT(expandedArgs == argCount);
    1:                 *out = 0;
30851:                 cx->free(buffer);
    1:                 *messagep =
    1:                     js_DeflateString(cx, reportp->ucmessage,
    1:                                      (size_t)(out - reportp->ucmessage));
    1:                 if (!*messagep)
    1:                     goto error;
    1:             }
    1:         } else {
    1:             /*
    1:              * Zero arguments: the format string (if it exists) is the
    1:              * entire message.
    1:              */
    1:             if (efs->format) {
    1:                 size_t len;
    1:                 *messagep = JS_strdup(cx, efs->format);
    1:                 if (!*messagep)
    1:                     goto error;
    1:                 len = strlen(*messagep);
    1:                 reportp->ucmessage = js_InflateString(cx, *messagep, &len);
    1:                 if (!reportp->ucmessage)
    1:                     goto error;
    1:             }
    1:         }
    1:     }
    1:     if (*messagep == NULL) {
    1:         /* where's the right place for this ??? */
    1:         const char *defaultErrorMessage
    1:             = "No error message available for error number %d";
    1:         size_t nbytes = strlen(defaultErrorMessage) + 16;
30851:         *messagep = (char *)cx->malloc(nbytes);
    1:         if (!*messagep)
    1:             goto error;
    1:         JS_snprintf(*messagep, nbytes, defaultErrorMessage, errorNumber);
    1:     }
    1:     return JS_TRUE;
    1: 
    1: error:
    1:     if (reportp->messageArgs) {
    1:         /* free the arguments only if we allocated them */
    1:         if (charArgs) {
    1:             i = 0;
    1:             while (reportp->messageArgs[i])
30851:                 cx->free((void *)reportp->messageArgs[i++]);
    1:         }
30851:         cx->free((void *)reportp->messageArgs);
    1:         reportp->messageArgs = NULL;
    1:     }
    1:     if (reportp->ucmessage) {
30851:         cx->free((void *)reportp->ucmessage);
    1:         reportp->ucmessage = NULL;
    1:     }
    1:     if (*messagep) {
30851:         cx->free((void *)*messagep);
    1:         *messagep = NULL;
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
    1: JSBool
    1: js_ReportErrorNumberVA(JSContext *cx, uintN flags, JSErrorCallback callback,
    1:                        void *userRef, const uintN errorNumber,
    1:                        JSBool charArgs, va_list ap)
    1: {
    1:     JSErrorReport report;
    1:     char *message;
    1:     JSBool warning;
    1: 
35302:     if (checkReportFlags(cx, &flags))
    1:         return JS_TRUE;
35302:     warning = JSREPORT_IS_WARNING(flags);
    1: 
40229:     PodZero(&report);
    1:     report.flags = flags;
    1:     report.errorNumber = errorNumber;
22652:     PopulateReportBlame(cx, &report);
    1: 
    1:     if (!js_ExpandErrorArguments(cx, callback, userRef, errorNumber,
39928:                                  &message, &report, !!charArgs, ap)) {
    1:         return JS_FALSE;
    1:     }
    1: 
36234:     ReportError(cx, message, &report, callback, userRef);
    1: 
    1:     if (message)
30851:         cx->free(message);
    1:     if (report.messageArgs) {
    1:         /*
    1:          * js_ExpandErrorArguments owns its messageArgs only if it had to
    1:          * inflate the arguments (from regular |char *|s).
    1:          */
    1:         if (charArgs) {
    1:             int i = 0;
    1:             while (report.messageArgs[i])
30851:                 cx->free((void *)report.messageArgs[i++]);
    1:         }
30851:         cx->free((void *)report.messageArgs);
    1:     }
    1:     if (report.ucmessage)
30851:         cx->free((void *)report.ucmessage);
    1: 
    1:     return warning;
    1: }
    1: 
    1: JS_FRIEND_API(void)
    1: js_ReportErrorAgain(JSContext *cx, const char *message, JSErrorReport *reportp)
    1: {
    1:     JSErrorReporter onError;
    1: 
    1:     if (!message)
    1:         return;
    1: 
    1:     if (cx->lastMessage)
30851:         js_free(cx->lastMessage);
    1:     cx->lastMessage = JS_strdup(cx, message);
    1:     if (!cx->lastMessage)
    1:         return;
    1:     onError = cx->errorReporter;
    1: 
    1:     /*
    1:      * If debugErrorHook is present then we give it a chance to veto
    1:      * sending the error on to the regular ErrorReporter.
    1:      */
    1:     if (onError) {
 2433:         JSDebugErrorHook hook = cx->debugHooks->debugErrorHook;
    1:         if (hook &&
    1:             !hook(cx, cx->lastMessage, reportp,
 2433:                   cx->debugHooks->debugErrorHookData)) {
    1:             onError = NULL;
    1:         }
    1:     }
    1:     if (onError)
    1:         onError(cx, cx->lastMessage, reportp);
    1: }
    1: 
    1: void
    1: js_ReportIsNotDefined(JSContext *cx, const char *name)
    1: {
    1:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_DEFINED, name);
    1: }
    1: 
    1: JSBool
48470: js_ReportIsNullOrUndefined(JSContext *cx, intN spindex, const Value &v,
 7897:                            JSString *fallback)
 7897: {
 7897:     char *bytes;
 7897:     JSBool ok;
 7897: 
48470:     bytes = DecompileValueGenerator(cx, spindex, v, fallback);
 7897:     if (!bytes)
 7897:         return JS_FALSE;
 7897: 
 7897:     if (strcmp(bytes, js_undefined_str) == 0 ||
 7897:         strcmp(bytes, js_null_str) == 0) {
 7897:         ok = JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
 7897:                                           js_GetErrorMessage, NULL,
 7897:                                           JSMSG_NO_PROPERTIES, bytes,
 7897:                                           NULL, NULL);
48470:     } else if (v.isUndefined()) {
 7897:         ok = JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
 7897:                                           js_GetErrorMessage, NULL,
31844:                                           JSMSG_UNEXPECTED_TYPE, bytes,
 7897:                                           js_undefined_str, NULL);
 7897:     } else {
48470:         JS_ASSERT(v.isNull());
 7897:         ok = JS_ReportErrorFlagsAndNumber(cx, JSREPORT_ERROR,
 7897:                                           js_GetErrorMessage, NULL,
31844:                                           JSMSG_UNEXPECTED_TYPE, bytes,
 7897:                                           js_null_str, NULL);
 7897:     }
 7897: 
30851:     cx->free(bytes);
 7897:     return ok;
 7897: }
 7897: 
16519: void
48470: js_ReportMissingArg(JSContext *cx, const Value &v, uintN arg)
16519: {
16519:     char argbuf[11];
16519:     char *bytes;
16519:     JSAtom *atom;
16519: 
16519:     JS_snprintf(argbuf, sizeof argbuf, "%u", arg);
16519:     bytes = NULL;
48470:     if (IsFunctionObject(v)) {
48470:         atom = GET_FUNCTION_PRIVATE(cx, &v.toObject())->atom;
48470:         bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK,
48470:                                         v, ATOM_TO_STRING(atom));
16519:         if (!bytes)
16519:             return;
16519:     }
16519:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
16519:                          JSMSG_MISSING_FUN_ARG, argbuf,
16519:                          bytes ? bytes : "");
30851:     cx->free(bytes);
16519: }
16519: 
 7897: JSBool
    1: js_ReportValueErrorFlags(JSContext *cx, uintN flags, const uintN errorNumber,
48470:                          intN spindex, const Value &v, JSString *fallback,
    1:                          const char *arg1, const char *arg2)
    1: {
    1:     char *bytes;
    1:     JSBool ok;
    1: 
    1:     JS_ASSERT(js_ErrorFormatString[errorNumber].argCount >= 1);
    1:     JS_ASSERT(js_ErrorFormatString[errorNumber].argCount <= 3);
48470:     bytes = DecompileValueGenerator(cx, spindex, v, fallback);
    1:     if (!bytes)
    1:         return JS_FALSE;
    1: 
    1:     ok = JS_ReportErrorFlagsAndNumber(cx, flags, js_GetErrorMessage,
    1:                                       NULL, errorNumber, bytes, arg1, arg2);
30851:     cx->free(bytes);
    1:     return ok;
    1: }
    1: 
    1: #if defined DEBUG && defined XP_UNIX
    1: /* For gdb usage. */
56604: void js_logon(JSContext *cx)  { cx->logfp = stderr; cx->logPrevPc = NULL; }
56604: void js_logoff(JSContext *cx) { cx->logfp = NULL; }
    1: #endif
    1: 
    1: JSErrorFormatString js_ErrorFormatString[JSErr_Limit] = {
    1: #define MSG_DEF(name, number, count, exception, format) \
    1:     { format, count, exception } ,
    1: #include "js.msg"
    1: #undef MSG_DEF
    1: };
    1: 
18727: JS_FRIEND_API(const JSErrorFormatString *)
    1: js_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber)
    1: {
    1:     if ((errorNumber > 0) && (errorNumber < JSErr_Limit))
    1:         return &js_ErrorFormatString[errorNumber];
    1:     return NULL;
    1: }
    1: 
    1: JSBool
25087: js_InvokeOperationCallback(JSContext *cx)
    1: {
56559:     JSRuntime *rt = cx->runtime;
56559:     JSThreadData *td = JS_THREAD_DATA(cx);
56559: 
48541:     JS_ASSERT_REQUEST_DEPTH(cx);
56559:     JS_ASSERT(td->interruptFlags != 0);
 9780: 
 9780:     /*
58723:      * Reset the callback counter first, then run GC and yield. If another
58723:      * thread is racing us here we will accumulate another callback request
58723:      * which will be serviced at the next opportunity.
 9780:      */
56559:     JS_LOCK_GC(rt);
56559:     td->interruptFlags = 0;
56559: #ifdef JS_THREADSAFE
56559:     JS_ATOMIC_DECREMENT(&rt->interruptCounter);
56559: #endif
56559:     JS_UNLOCK_GC(rt);
25087: 
48619:     if (rt->gcIsNeeded) {
60258:         js_GC(cx, rt->gcTriggerCompartment, GC_NORMAL);
48619: 
48619:         /*
48619:          * On trace we can exceed the GC quota, see comments in NewGCArena. So
48619:          * we check the quota and report OOM here when we are off trace.
48619:          */
48619:         bool delayedOutOfMemory;
48619:         JS_LOCK_GC(rt);
48619:         delayedOutOfMemory = (rt->gcBytes > rt->gcMaxBytes);
48619:         JS_UNLOCK_GC(rt);
48619:         if (delayedOutOfMemory) {
41098:             js_ReportOutOfMemory(cx);
41098:             return false;
41098:         }
41098:     }
58723:     
48619: #ifdef JS_THREADSAFE
58723:     /*
58723:      * We automatically yield the current context every time the operation
58723:      * callback is hit since we might be called as a result of an impending
58723:      * GC on another thread, which would deadlock if we do not yield.
58723:      * Operation callbacks are supposed to happen rarely (seconds, not
58723:      * milliseconds) so it is acceptable to yield at every callback.
58723:      *
58723:      * As the GC can be canceled before it does any request checks we yield
58723:      * even if rt->gcIsNeeded was true above. See bug 590533.
58723:      */
48619:     JS_YieldRequest(cx);
48619: #endif
48548: 
48619:     JSOperationCallback cb = cx->operationCallback;
25087: 
25087:     /*
25087:      * Important: Additional callbacks can occur inside the callback handler
25087:      * if it re-enters the JS engine. The embedding must ensure that the
25087:      * callback is disconnected before attempting such re-entry.
25087:      */
48619: 
25087:     return !cb || cb(cx);
 9780: }
22652: 
52753: JSBool
52753: js_HandleExecutionInterrupt(JSContext *cx)
52753: {
52753:     JSBool result = JS_TRUE;
56559:     if (JS_THREAD_DATA(cx)->interruptFlags)
52753:         result = js_InvokeOperationCallback(cx) && result;
52753:     return result;
52753: }
52753: 
53592: namespace js {
53592: 
27546: void
56559: TriggerOperationCallback(JSContext *cx)
56559: {
56559:     /*
56559:      * We allow for cx to come from another thread. Thus we must deal with
56559:      * possible JS_ClearContextThread calls when accessing cx->thread. But we
56559:      * assume that the calling thread is in a request so JSThread cannot be
56559:      * GC-ed.
56559:      */
56559:     JSThreadData *td;
56559: #ifdef JS_THREADSAFE
56559:     JSThread *thread = cx->thread;
56559:     if (!thread)
56559:         return;
56559:     td = &thread->data;
56559: #else
56559:     td = JS_THREAD_DATA(cx);
56559: #endif
56559:     td->triggerOperationCallback(cx->runtime);
56559: }
56559: 
56559: void
53592: TriggerAllOperationCallbacks(JSRuntime *rt)
27546: {
48538:     for (ThreadDataIter i(rt); !i.empty(); i.popFront())
56559:         i.threadData()->triggerOperationCallback(rt);
27546: }
27546: 
53592: } /* namespace js */
53592: 
22652: JSStackFrame *
22652: js_GetScriptedCaller(JSContext *cx, JSStackFrame *fp)
22652: {
22652:     if (!fp)
22652:         fp = js_GetTopStackFrame(cx);
53557:     while (fp && fp->isDummyFrame())
53840:         fp = fp->prev();
53840:     JS_ASSERT_IF(fp, fp->isScriptFrame());
22652:     return fp;
22652: }
26550: 
26550: jsbytecode*
26550: js_GetCurrentBytecodePC(JSContext* cx)
26550: {
26550:     jsbytecode *pc, *imacpc;
26550: 
26550: #ifdef JS_TRACER
26550:     if (JS_ON_TRACE(cx)) {
62033:         pc = JS_TRACE_MONITOR_ON_TRACE(cx)->bailExit->pc;
62033:         imacpc = JS_TRACE_MONITOR_ON_TRACE(cx)->bailExit->imacpc;
26550:     } else
26550: #endif
26550:     {
26550:         JS_ASSERT_NOT_ON_TRACE(cx);  /* for static analysis */
42717:         pc = cx->regs ? cx->regs->pc : NULL;
42717:         if (!pc)
26550:             return NULL;
53840:         imacpc = cx->fp()->maybeImacropc();
26550:     }
26550: 
26550:     /*
26550:      * If we are inside GetProperty_tn or similar, return a pointer to the
26550:      * current instruction in the script, not the CALL instruction in the
26550:      * imacro, for the benefit of callers doing bytecode inspection.
26550:      */
26550:     return (*pc == JSOP_CALL && imacpc) ? imacpc : pc;
26550: }
31911: 
31911: bool
31911: js_CurrentPCIsInImacro(JSContext *cx)
31911: {
31911: #ifdef JS_TRACER
31911:     VOUCH_DOES_NOT_REQUIRE_STACK();
51055:     if (JS_ON_TRACE(cx))
62033:         return JS_TRACE_MONITOR_ON_TRACE(cx)->bailExit->imacpc != NULL;
53840:     return cx->fp()->hasImacropc();
31911: #else
31911:     return false;
31911: #endif
31911: }
34288: 
43244: void
43244: DSTOffsetCache::purge()
43244: {
43244:     /*
43244:      * NB: The initial range values are carefully chosen to result in a cache
43244:      *     miss on first use given the range of possible values.  Be careful
43244:      *     to keep these values and the caching algorithm in sync!
43244:      */
43244:     offsetMilliseconds = 0;
43244:     rangeStartSeconds = rangeEndSeconds = INT64_MIN;
51077:     oldOffsetMilliseconds = 0;
51077:     oldRangeStartSeconds = oldRangeEndSeconds = INT64_MIN;
43244: 
43244: #ifdef JS_METER_DST_OFFSET_CACHING
43244:     totalCalculations = 0;
43244:     hit = 0;
43244:     missIncreasing = missDecreasing = 0;
43244:     missIncreasingOffsetChangeExpand = missIncreasingOffsetChangeUpper = 0;
43244:     missDecreasingOffsetChangeExpand = missDecreasingOffsetChangeLower = 0;
43244:     missLargeIncrease = missLargeDecrease = 0;
43244: #endif
43244: 
43244:     sanityCheck();
43244: }
43244: 
43244: /*
43244:  * Since getDSTOffsetMilliseconds guarantees that all times seen will be
43244:  * positive, we can initialize the range at construction time with large
43244:  * negative numbers to ensure the first computation is always a cache miss and
43244:  * doesn't return a bogus offset.
43244:  */
43244: DSTOffsetCache::DSTOffsetCache()
43244: {
43244:     purge();
43244: }
43244: 
42714: JSContext::JSContext(JSRuntime *rt)
61450:   : hasVersionOverride(false),
61450:     runtime(rt),
60583:     compartment(NULL),
42717:     regs(NULL),
61229:     busyArrays()
42714: {}
42714: 
42714: void
55607: JSContext::resetCompartment()
55607: {
55607:     JSObject *scopeobj;
55607:     if (hasfp()) {
55607:         scopeobj = &fp()->scopeChain();
55607:     } else {
55607:         scopeobj = globalObject;
60211:         if (!scopeobj)
60211:             goto error;
55607: 
55607:         /*
55607:          * Innerize. Assert, but check anyway, that this succeeds. (It
55607:          * can only fail due to bugs in the engine or embedding.)
55607:          */
55607:         OBJ_TO_INNER_OBJECT(this, scopeobj);
60211:         if (!scopeobj)
60211:             goto error;
60211:     }
60211: 
60211:     compartment = scopeobj->compartment();
60211: 
60211:     if (isExceptionPending())
60245:         wrapPendingException();
60211:     return;
60211: 
60211: error:
60211: 
60211:     /*
60211:      * If we try to use the context without a selected compartment,
60211:      * we will crash.
60211:      */
60194:     compartment = NULL;
55607: }
55607: 
60245: /*
60245:  * Since this function is only called in the context of a pending exception,
61428:  * the caller must subsequently take an error path. If wrapping fails, it will
61428:  * set a new (uncatchable) exception to be used in place of the original.
60245:  */
60245: void
60245: JSContext::wrapPendingException()
60245: {
60245:     Value v = getPendingException();
60245:     clearPendingException();
60245:     if (compartment->wrap(this, &v))
60245:         setPendingException(v);
60245: }
60245: 
55607: void
51446: JSContext::pushSegmentAndFrame(js::StackSegment *newseg, JSFrameRegs &newregs)
42714: {
53840:     JS_ASSERT(regs != &newregs);
54832:     if (hasActiveSegment())
51446:         currentSegment->suspend(regs);
50466:     newseg->setPreviousInContext(currentSegment);
50466:     currentSegment = newseg;
42717:     setCurrentRegs(&newregs);
51446:     newseg->joinContext(this, newregs.fp);
42714: }
42714: 
42714: void
48531: JSContext::popSegmentAndFrame()
42714: {
62520:     /*
62520:      * NB: This function calls resetCompartment, which may GC, so the stack needs
62520:      * to be in a GC-able state by that point.
62520:      */
62520: 
48531:     JS_ASSERT(currentSegment->maybeContext() == this);
51446:     JS_ASSERT(currentSegment->getInitialFrame() == regs->fp);
48531:     currentSegment->leaveContext();
48531:     currentSegment = currentSegment->getPreviousInContext();
48531:     if (currentSegment) {
48531:         if (currentSegment->isSaved()) {
42717:             setCurrentRegs(NULL);
62520:             resetCompartment();
42714:         } else {
48531:             setCurrentRegs(currentSegment->getSuspendedRegs());
48531:             currentSegment->resume();
42714:         }
42714:     } else {
53840:         JS_ASSERT(regs->fp->prev() == NULL);
42717:         setCurrentRegs(NULL);
62520:         resetCompartment();
42714:     }
61450:     maybeMigrateVersionOverride();
42714: }
42714: 
42714: void
48531: JSContext::saveActiveSegment()
42714: {
48531:     JS_ASSERT(hasActiveSegment());
62876:     currentSegment->save(regs);
42717:     setCurrentRegs(NULL);
62520:     resetCompartment();
42714: }
42714: 
42714: void
48531: JSContext::restoreSegment()
42714: {
62876:     js::StackSegment *ccs = currentSegment;
62876:     setCurrentRegs(ccs->getSuspendedRegs());
62876:     ccs->restore();
62520:     resetCompartment();
42714: }
42714: 
42714: JSGenerator *
42714: JSContext::generatorFor(JSStackFrame *fp) const
42714: {
53840:     JS_ASSERT(stack().contains(fp) && fp->isGeneratorFrame());
42714:     JS_ASSERT(!fp->isFloatingGenerator());
42714:     JS_ASSERT(!genStack.empty());
42714: 
53840:     if (JS_LIKELY(fp == genStack.back()->liveFrame()))
42714:         return genStack.back();
42714: 
42714:     /* General case; should only be needed for debug APIs. */
42714:     for (size_t i = 0; i < genStack.length(); ++i) {
53840:         if (genStack[i]->liveFrame() == fp)
42714:             return genStack[i];
42714:     }
42714:     JS_NOT_REACHED("no matching generator");
42714:     return NULL;
42714: }
42714: 
50466: StackSegment *
48531: JSContext::containingSegment(const JSStackFrame *target)
40276: {
40276:     /* The context may have nothing running. */
50466:     StackSegment *seg = currentSegment;
50466:     if (!seg)
40276:         return NULL;
40276: 
51446:     /* The active segments's top frame is cx->regs->fp. */
51446:     if (regs) {
51446:         JS_ASSERT(regs->fp);
50466:         JS_ASSERT(activeSegment() == seg);
51446:         JSStackFrame *f = regs->fp;
53840:         JSStackFrame *stop = seg->getInitialFrame()->prev();
53840:         for (; f != stop; f = f->prev()) {
40276:             if (f == target)
50466:                 return seg;
40276:         }
50466:         seg = seg->getPreviousInContext();
40276:     }
40276: 
48531:     /* A suspended segment's top frame is its suspended frame. */
50466:     for (; seg; seg = seg->getPreviousInContext()) {
50466:         JSStackFrame *f = seg->getSuspendedFrame();
53840:         JSStackFrame *stop = seg->getInitialFrame()->prev();
53840:         for (; f != stop; f = f->prev()) {
40276:             if (f == target)
50466:                 return seg;
40276:         }
40276:     }
40276: 
40276:     return NULL;
40276: }
40276: 
53592: JS_FRIEND_API(void)
53592: JSRuntime::onTooMuchMalloc()
48619: {
53592: #ifdef JS_THREADSAFE
53592:     AutoLockGC lock(this);
53592: 
53592:     /*
53592:      * We can be called outside a request and can race against a GC that
53592:      * mutates the JSThread set during the sweeping phase.
53592:      */
53592:     js_WaitForGC(this);
53592: #endif
53592:     TriggerGC(this);
53552: }
53552: 
53592: JS_FRIEND_API(void *)
53592: JSRuntime::onOutOfMemory(void *p, size_t nbytes, JSContext *cx)
53592: {
53549: #ifdef JS_THREADSAFE
53592:     gcHelperThread.waitBackgroundSweepEnd(this);
53592:     if (!p)
53592:         p = ::js_malloc(nbytes);
53592:     else if (p == reinterpret_cast<void *>(1))
53592:         p = ::js_calloc(nbytes);
53592:     else
53592:       p = ::js_realloc(p, nbytes);
53592:     if (p)
53592:         return p;
53549: #endif
53592:     if (cx)
53592:         js_ReportOutOfMemory(cx);
53592:     return NULL;
48619: }
48619: 
38604: /*
38604:  * Release pool's arenas if the stackPool has existed for longer than the
38604:  * limit specified by gcEmptyArenaPoolLifespan.
38604:  */
38604: inline void
38604: FreeOldArenas(JSRuntime *rt, JSArenaPool *pool)
38604: {
47609:     JSArena *a = pool->current;
47609:     if (a == pool->first.next && a->avail == a->base + sizeof(int64)) {
47609:         int64 age = JS_Now() - *(int64 *) a->base;
38604:         if (age > int64(rt->gcEmptyArenaPoolLifespan) * 1000)
47609:             JS_FreeArenaPool(pool);
38604:     }
38604: }
38604: 
38604: void
38604: JSContext::purge()
38604: {
50491:     FreeOldArenas(runtime, &regExpPool);
54427: }
54427: 
54883: static bool
54883: ComputeIsJITBroken()
54883: {
54883: #ifndef ANDROID
54883:     return false;
54883: #else  // ANDROID
54883:     if (getenv("JS_IGNORE_JIT_BROKENNESS")) {
54883:         return false;
54883:     }
54883: 
57624:     std::string line;
57624: 
57624:     // Check for the known-bad kernel version (2.6.29).
57624:     std::ifstream osrelease("/proc/sys/kernel/osrelease");
57624:     std::getline(osrelease, line);
57887:     __android_log_print(ANDROID_LOG_INFO, "Gecko", "Detected osrelease `%s'",
57887:                         line.c_str());
57887: 
57624:     if (line.npos == line.find("2.6.29")) {
57624:         // We're using something other than 2.6.29, so the JITs should work.
57887:         __android_log_print(ANDROID_LOG_INFO, "Gecko", "JITs are not broken");
57624:         return false;
57624:     }
57624: 
57624:     // We're using 2.6.29, and this causes trouble with the JITs on i9000.
57887:     line = "";
54883:     bool broken = false;
54883:     std::ifstream cpuinfo("/proc/cpuinfo");
54883:     do {
54883:         if (0 == line.find("Hardware")) {
54883:             const char* blacklist[] = {
63332:                 "SCH-I400",     // Samsung Continuum
54883:                 "SGH-T959",     // Samsung i9000, Vibrant device
54883:                 "SGH-I897",     // Samsung i9000, Captivate device
54883:                 "SCH-I500",     // Samsung i9000, Fascinate device
54883:                 "SPH-D700",     // Samsung i9000, Epic device
55237:                 "GT-I9000",     // Samsung i9000, UK/Europe device
54883:                 NULL
54883:             };
55003:             for (const char** hw = &blacklist[0]; *hw; ++hw) {
55003:                 if (line.npos != line.find(*hw)) {
57887:                     __android_log_print(ANDROID_LOG_INFO, "Gecko",
57887:                                         "Blacklisted device `%s'", *hw);
54883:                     broken = true;
54883:                     break;
54883:                 }
54883:             }
54883:             break;
54883:         }
54883:         std::getline(cpuinfo, line);
54883:     } while(!cpuinfo.fail() && !cpuinfo.eof());
57887: 
57887:     __android_log_print(ANDROID_LOG_INFO, "Gecko", "JITs are %sbroken",
57887:                         broken ? "" : "not ");
57887: 
54883:     return broken;
54883: #endif  // ifndef ANDROID
54883: }
54883: 
54883: static bool
54883: IsJITBrokenHere()
54883: {
54883:     static bool computedIsBroken = false;
54883:     static bool isBroken = false;
54883:     if (!computedIsBroken) {
54883:         isBroken = ComputeIsJITBroken();
54883:         computedIsBroken = true;
54883:     }
54883:     return isBroken;
38604: }
43286: 
54175: void
54175: JSContext::updateJITEnabled()
54175: {
54175: #ifdef JS_TRACER
61450:     traceJitEnabled = ((runOptions & JSOPTION_JIT) &&
54883:                        !IsJITBrokenHere() &&
54175:                        (debugHooks == &js_NullDebugHooks ||
54175:                         (debugHooks == &runtime->globalDebugHooks &&
54175:                          !runtime->debuggerInhibitsJIT())));
54175: #endif
54175: #ifdef JS_METHODJIT
61450:     methodJitEnabled = (runOptions & JSOPTION_METHODJIT) &&
54883:                        !IsJITBrokenHere()
54864: # if defined JS_CPU_X86 || defined JS_CPU_X64
54175:                        && JSC::MacroAssemblerX86Common::getSSEState() >=
54175:                           JSC::MacroAssemblerX86Common::HasSSE2
54175: # endif
54175:                         ;
56551: #ifdef JS_TRACER
61450:     profilingEnabled = (runOptions & JSOPTION_PROFILING) && traceJitEnabled && methodJitEnabled;
56551: #endif
54175: #endif
54175: }
54175: 
48470: namespace js {
48470: 
59733: JS_FORCES_STACK JS_FRIEND_API(void)
59733: LeaveTrace(JSContext *cx)
59733: {
59733: #ifdef JS_TRACER
59733:     if (JS_ON_TRACE(cx))
59733:         DeepBail(cx);
59733: #endif
59733: }
59733: 
48470: } /* namespace js */
