 1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 1: /* ***** BEGIN LICENSE BLOCK *****
 1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 1:  *
 1:  * The contents of this file are subject to the Mozilla Public License Version
 1:  * 1.1 (the "License"); you may not use this file except in compliance with
 1:  * the License. You may obtain a copy of the License at
 1:  * http://www.mozilla.org/MPL/
 1:  *
 1:  * Software distributed under the License is distributed on an "AS IS" basis,
 1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 1:  * for the specific language governing rights and limitations under the
 1:  * License.
 1:  *
 1:  * The Original Code is mozilla.org code.
 1:  *
 1:  * The Initial Developer of the Original Code is
 1:  * Netscape Communications Corporation.
 1:  * Portions created by the Initial Developer are Copyright (C) 1998
 1:  * the Initial Developer. All Rights Reserved.
 1:  *
 1:  * Contributor(s):
 1:  *   Original Author: David W. Hyatt (hyatt@netscape.com)
 1:  *   Michael Lowe <michael.lowe@bigfoot.com>
 1:  *   Pierre Phaneuf <pp@ludusdesign.com>
 1:  *   Dean Tessman <dean_tessman@hotmail.com>
 1:  *
 1:  * Alternatively, the contents of this file may be used under the terms of
 1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 1:  * in which case the provisions of the GPL or the LGPL are applicable instead
 1:  * of those above. If you wish to allow use of your version of this file only
 1:  * under the terms of either the GPL or the LGPL, and not to allow others to
 1:  * use your version of this file under the terms of the MPL, indicate your
 1:  * decision by deleting the provisions above and replace them with the notice
 1:  * and other provisions required by the GPL or the LGPL. If you do not delete
 1:  * the provisions above, a recipient may use your version of this file under
 1:  * the terms of any one of the MPL, the GPL or the LGPL.
 1:  *
 1:  * ***** END LICENSE BLOCK ***** */
 1: 
 1: #include "nsGkAtoms.h"
 1: #include "nsHTMLParts.h"
 1: #include "nsMenuFrame.h"
 1: #include "nsBoxFrame.h"
 1: #include "nsIContent.h"
 1: #include "prtypes.h"
 1: #include "nsIAtom.h"
 1: #include "nsPresContext.h"
 1: #include "nsIPresShell.h"
 1: #include "nsStyleContext.h"
 1: #include "nsCSSRendering.h"
 1: #include "nsINameSpaceManager.h"
 1: #include "nsMenuPopupFrame.h"
 1: #include "nsMenuBarFrame.h"
 1: #include "nsIView.h"
 1: #include "nsIWidget.h"
 1: #include "nsIDocument.h"
 1: #include "nsIDOMNSDocument.h"
 1: #include "nsIDOMDocument.h"
 1: #include "nsIDOMElement.h"
 1: #include "nsISupportsArray.h"
 1: #include "nsIDOMText.h"
 1: #include "nsILookAndFeel.h"
 1: #include "nsIComponentManager.h"
 1: #include "nsWidgetsCID.h"
 1: #include "nsBoxLayoutState.h"
 1: #include "nsIScrollableFrame.h"
 1: #include "nsIViewManager.h"
 1: #include "nsBindingManager.h"
 1: #include "nsIServiceManager.h"
 1: #include "nsCSSFrameConstructor.h"
 1: #include "nsIDOMKeyEvent.h"
 1: #include "nsIScrollableView.h"
 1: #include "nsXPIDLString.h"
 1: #include "nsReadableUtils.h"
 1: #include "nsUnicharUtils.h"
 1: #include "nsIStringBundle.h"
 1: #include "nsGUIEvent.h"
 1: #include "nsIEventStateManager.h"
 1: #include "nsContentUtils.h"
 1: #include "nsDisplayList.h"
 1: #include "nsIReflowCallback.h"
 1: 
 1: #define NS_MENU_POPUP_LIST_INDEX   0
 1: 
 1: #if defined(XP_WIN) || defined(XP_OS2)
 1: #define NSCONTEXTMENUISMOUSEUP 1
 1: #endif
 1: 
 1: static PRInt32 gEatMouseMove = PR_FALSE;
 1: 
 1: static NS_DEFINE_IID(kLookAndFeelCID, NS_LOOKANDFEEL_CID);
 1: 
 1: nsrefcnt nsMenuFrame::gRefCnt = 0;
 1: nsString *nsMenuFrame::gShiftText = nsnull;
 1: nsString *nsMenuFrame::gControlText = nsnull;
 1: nsString *nsMenuFrame::gMetaText = nsnull;
 1: nsString *nsMenuFrame::gAltText = nsnull;
 1: nsString *nsMenuFrame::gModifierSeparator = nsnull;
 1: 
 1: //
 1: // NS_NewMenuFrame
 1: //
 1: // Wrapper for creating a new menu popup container
 1: //
 1: nsIFrame*
 1: NS_NewMenuFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUint32 aFlags)
 1: {
 1:   nsMenuFrame* it = new (aPresShell) nsMenuFrame (aPresShell, aContext);
 1:   
 1:   if ((it != nsnull) && aFlags)
 1:     it->SetIsMenu(PR_TRUE);
 1: 
 1:   return it;
 1: }
 1: 
 1: NS_IMETHODIMP_(nsrefcnt) 
 1: nsMenuFrame::AddRef(void)
 1: {
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP_(nsrefcnt)
 1: nsMenuFrame::Release(void)
 1: {
 1:     return NS_OK;
 1: }
 1: 
 1: //
 1: // QueryInterface
 1: //
 1: NS_INTERFACE_MAP_BEGIN(nsMenuFrame)
 1:   NS_INTERFACE_MAP_ENTRY(nsIMenuFrame)
 1:   NS_INTERFACE_MAP_ENTRY(nsIScrollableViewProvider)
 1: NS_INTERFACE_MAP_END_INHERITING(nsBoxFrame)
 1: 
 1: //
 1: // nsMenuFrame cntr
 1: //
 1: nsMenuFrame::nsMenuFrame(nsIPresShell* aShell, nsStyleContext* aContext):
 1:   nsBoxFrame(aShell, aContext),
 1:     mIsMenu(PR_FALSE),
 1:     mMenuOpen(PR_FALSE),
 1:     mCreateHandlerSucceeded(PR_FALSE),
 1:     mChecked(PR_FALSE),
 1:     mType(eMenuType_Normal),
 1:     mMenuParent(nsnull),
 1:     mLastPref(-1,-1)
 1: {
 1: 
 1: } // cntr
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::SetParent(const nsIFrame* aParent)
 1: {
 1:   nsBoxFrame::SetParent(aParent);
 1:   const nsIFrame* currFrame = aParent;
 1:   while (!mMenuParent && currFrame) {
 1:     // Set our menu parent.
 1:     CallQueryInterface(NS_CONST_CAST(nsIFrame*, currFrame), &mMenuParent);
 1: 
 1:     currFrame = currFrame->GetParent();
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: class nsASyncMenuInitialization : public nsIReflowCallback
 1: {
 1: public:
 1:   nsASyncMenuInitialization(nsIFrame* aFrame)
 1:     : mWeakFrame(aFrame)
 1:   {
 1:   }
 1: 
 1:   virtual PRBool ReflowFinished() {
 1:     PRBool shouldFlush = PR_FALSE;
 1:     if (mWeakFrame.IsAlive()) {
 1:       nsIMenuFrame* imenu = nsnull;
 1:       CallQueryInterface(mWeakFrame.GetFrame(), &imenu);
 1:       if (imenu) {
 1:         nsMenuFrame* menu = NS_STATIC_CAST(nsMenuFrame*, imenu);
 1:         menu->UpdateMenuType(menu->GetPresContext());
 1:         shouldFlush = PR_TRUE;
 1:       }
 1:     }
 1:     delete this;
 1:     return shouldFlush;
 1:   }
 1: 
 1:   nsWeakFrame mWeakFrame;
 1: };
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::Init(nsIContent*      aContent,
 1:                   nsIFrame*        aParent,
 1:                   nsIFrame*        aPrevInFlow)
 1: {
 1:   nsresult  rv = nsBoxFrame::Init(aContent, aParent, aPrevInFlow);
 1: 
 1:   // Set up a mediator which can be used for callbacks on this frame.
 1:   mTimerMediator = new nsMenuTimerMediator(this);
 1:   if (NS_UNLIKELY(!mTimerMediator))
 1:     return NS_ERROR_OUT_OF_MEMORY;
 1: 
 1:   nsIFrame* currFrame = aParent;
 1:   while (!mMenuParent && currFrame) {
 1:     // Set our menu parent.
 1:     CallQueryInterface(currFrame, &mMenuParent);
 1: 
 1:     currFrame = currFrame->GetParent();
 1:   }
 1: 
 1:   //load the display strings for the keyboard accelerators, but only once
 1:   if (gRefCnt++ == 0) {
 1:     
 1:     nsCOMPtr<nsIStringBundleService> bundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
 1:     nsCOMPtr<nsIStringBundle> bundle;
 1:     if (NS_SUCCEEDED(rv) && bundleService) {
 1:       rv = bundleService->CreateBundle( "chrome://global-platform/locale/platformKeys.properties",
 1:                                         getter_AddRefs(bundle));
 1:     }    
 1:     
 1:     NS_ASSERTION(NS_SUCCEEDED(rv) && bundle, "chrome://global/locale/platformKeys.properties could not be loaded");
 1:     nsXPIDLString shiftModifier;
 1:     nsXPIDLString metaModifier;
 1:     nsXPIDLString altModifier;
 1:     nsXPIDLString controlModifier;
 1:     nsXPIDLString modifierSeparator;
 1:     if (NS_SUCCEEDED(rv) && bundle) {
 1:       //macs use symbols for each modifier key, so fetch each from the bundle, which also covers i18n
 1:       rv = bundle->GetStringFromName(NS_LITERAL_STRING("VK_SHIFT").get(), getter_Copies(shiftModifier));
 1:       rv = bundle->GetStringFromName(NS_LITERAL_STRING("VK_META").get(), getter_Copies(metaModifier));
 1:       rv = bundle->GetStringFromName(NS_LITERAL_STRING("VK_ALT").get(), getter_Copies(altModifier));
 1:       rv = bundle->GetStringFromName(NS_LITERAL_STRING("VK_CONTROL").get(), getter_Copies(controlModifier));
 1:       rv = bundle->GetStringFromName(NS_LITERAL_STRING("MODIFIER_SEPARATOR").get(), getter_Copies(modifierSeparator));
 1:     } else {
 1:       rv = NS_ERROR_NOT_AVAILABLE;
 1:     }
 1:     //if any of these don't exist, we get  an empty string
 1:     gShiftText = new nsString(shiftModifier);
 1:     gMetaText = new nsString(metaModifier);
 1:     gAltText = new nsString(altModifier);
 1:     gControlText = new nsString(controlModifier);
 1:     gModifierSeparator = new nsString(modifierSeparator);    
 1:   }
 1: 
 1:   BuildAcceleratorText();
 1:   nsIReflowCallback* cb = new nsASyncMenuInitialization(this);
 1:   NS_ENSURE_TRUE(cb, NS_ERROR_OUT_OF_MEMORY);
 1:   GetPresContext()->PresShell()->PostReflowCallback(cb);
 1:   return rv;
 1: }
 1: 
 1: nsMenuFrame::~nsMenuFrame()
 1: {
 1:   // Clean up shared statics
 1:   if (--gRefCnt == 0) {
 1:     delete gShiftText;
 1:     gShiftText = nsnull;
 1:     delete gControlText;  
 1:     gControlText = nsnull;
 1:     delete gMetaText;  
 1:     gMetaText = nsnull;
 1:     delete gAltText;  
 1:     gAltText = nsnull;
 1:     delete gModifierSeparator;
 1:     gModifierSeparator = nsnull;
 1:   }
 1: }
 1: 
 1: // The following methods are all overridden to ensure that the menupopup frame
 1: // is placed in the appropriate list.
 1: nsIFrame*
 1: nsMenuFrame::GetFirstChild(nsIAtom* aListName) const
 1: {
 1:   if (nsGkAtoms::popupList == aListName) {
 1:     return mPopupFrames.FirstChild();
 1:   }
 1:   return nsBoxFrame::GetFirstChild(aListName);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::SetInitialChildList(nsIAtom*        aListName,
 1:                                  nsIFrame*       aChildList)
 1: {
 1:   nsresult rv = NS_OK;
 1:   if (nsGkAtoms::popupList == aListName) {
 1:     mPopupFrames.SetFrames(aChildList);
 1:   } else {
 1: 
 1:     nsFrameList frames(aChildList);
 1: 
 1:     // We may have a menupopup in here. Get it out, and move it into
 1:     // the popup frame list.
 1:     nsIFrame* frame = frames.FirstChild();
 1:     while (frame) {
 1:       nsIMenuParent *menuPar;
 1:       CallQueryInterface(frame, &menuPar);
 1:       if (menuPar) {
 1:         PRBool isMenuBar;
 1:         menuPar->IsMenuBar(isMenuBar);
 1:         if (!isMenuBar) {
 1:           // Remove this frame from the list and place it in the other list.
 1:           frames.RemoveFrame(frame);
 1:           mPopupFrames.AppendFrame(this, frame);
 1:           nsIFrame* first = frames.FirstChild();
 1:           rv = nsBoxFrame::SetInitialChildList(aListName, first);
 1:           return rv;
 1:         }
 1:       }
 1:       frame = frame->GetNextSibling();
 1:     }
 1: 
 1:     // Didn't find it.
 1:     rv = nsBoxFrame::SetInitialChildList(aListName, aChildList);
 1:   }
 1:   return rv;
 1: }
 1: 
 1: nsIAtom*
 1: nsMenuFrame::GetAdditionalChildListName(PRInt32 aIndex) const
 1: {
 1:   if (NS_MENU_POPUP_LIST_INDEX == aIndex) {
 1:     return nsGkAtoms::popupList;
 1:   }
 1: 
 1:   return nsnull;
 1: }
 1: 
 1: nsresult
 1: nsMenuFrame::DestroyPopupFrames(nsPresContext* aPresContext)
 1: {
 1:   // Remove our frame mappings
 1:   nsCSSFrameConstructor* frameConstructor =
 1:     aPresContext->PresShell()->FrameConstructor();
 1:   nsIFrame* curFrame = mPopupFrames.FirstChild();
 1:   while (curFrame) {
 1:     frameConstructor->RemoveMappingsForFrameSubtree(curFrame);
 1:     curFrame = curFrame->GetNextSibling();
 1:   }
 1: 
 1:    // Cleanup frames in popup child list
 1:   mPopupFrames.DestroyFrames();
 1:   return NS_OK;
 1: }
 1: 
 1: void
 1: nsMenuFrame::Destroy()
 1: {
 1:   // Kill our timer if one is active. This is not strictly necessary as
 1:   // the pointer to this frame will be cleared from the mediator, but
 1:   // this is done for added safety.
 1:   if (mOpenTimer) {
 1:     mOpenTimer->Cancel();
 1:   }
 1: 
 1:   // Null out the pointer to this frame in the mediator wrapper so that it 
 1:   // doesn't try to interact with a deallocated frame.
 1:   mTimerMediator->ClearFrame();
 1: 
 1:   nsWeakFrame weakFrame(this);
 1:   // are we our menu parent's current menu item?
 1:   if (mMenuParent) {
 1:     nsIMenuFrame *curItem = mMenuParent->GetCurrentMenuItem();
 1:     if (curItem == this) {
 1:       // yes; tell it that we're going away
 1:       mMenuParent->SetCurrentMenuItem(nsnull);
 1:       ENSURE_TRUE(weakFrame.IsAlive());
 1:     }
 1:   }
 1: 
 1:   UngenerateMenu();
 1:   ENSURE_TRUE(weakFrame.IsAlive());
 1:   DestroyPopupFrames(GetPresContext());
 1:   nsBoxFrame::Destroy();
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,
 1:                                          const nsRect&           aDirtyRect,
 1:                                          const nsDisplayListSet& aLists)
 1: {
 1:   if (!aBuilder->IsForEventDelivery())
 1:     return nsBoxFrame::BuildDisplayListForChildren(aBuilder, aDirtyRect, aLists);
 1:     
 1:   nsDisplayListCollection set;
 1:   nsresult rv = nsBoxFrame::BuildDisplayListForChildren(aBuilder, aDirtyRect, set);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   
 1:   return WrapListsInRedirector(aBuilder, set, aLists);
 1: }
 1: 
 1: NS_IMETHODIMP 
 1: nsMenuFrame::HandleEvent(nsPresContext* aPresContext, 
 1:                              nsGUIEvent*     aEvent,
 1:                              nsEventStatus*  aEventStatus)
 1: {
 1:   NS_ENSURE_ARG_POINTER(aEventStatus);
 1:   nsWeakFrame weakFrame(this);
 1:   if (*aEventStatus == nsEventStatus_eIgnore)
 1:     *aEventStatus = nsEventStatus_eConsumeDoDefault;
 1:   
 1:   if (aEvent->message == NS_KEY_PRESS && !IsDisabled()) {
 1:     nsKeyEvent* keyEvent = (nsKeyEvent*)aEvent;
 1:     PRUint32 keyCode = keyEvent->keyCode;
 1: #ifdef XP_MACOSX
 1:     // On mac, open menulist on either up/down arrow or space (w/o Cmd pressed)
 1:     if (!IsOpen() && ((keyEvent->charCode == NS_VK_SPACE && !keyEvent->isMeta) ||
 1:         (keyCode == NS_VK_UP || keyCode == NS_VK_DOWN)))
 1:       OpenMenu(PR_TRUE);
 1: #else
 1:     // On other platforms, toggle menulist on unmodified F4 or Alt arrow
 1:     if ((keyCode == NS_VK_F4 && !keyEvent->isAlt) ||
 1:         ((keyCode == NS_VK_UP || keyCode == NS_VK_DOWN) && keyEvent->isAlt))
 1:       OpenMenu(!IsOpen());
 1: #endif
 1:   }
 1:   else if (aEvent->eventStructType == NS_MOUSE_EVENT &&
 1:            aEvent->message == NS_MOUSE_BUTTON_DOWN &&
 1:            NS_STATIC_CAST(nsMouseEvent*, aEvent)->button == nsMouseEvent::eLeftButton &&
 1:            !IsDisabled() && IsMenu()) {
 1:     PRBool isMenuBar = PR_FALSE;
 1:     if (mMenuParent)
 1:       mMenuParent->IsMenuBar(isMenuBar);
 1: 
 1:     // The menu item was selected. Bring up the menu.
 1:     // We have children.
 1:     if ( isMenuBar || !mMenuParent ) {
 1:       ToggleMenuState();
 1:       NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1: 
 1:       if (!IsOpen() && mMenuParent) {
 1:         // We closed up. The menu bar should always be
 1:         // deactivated when this happens.
 1:         mMenuParent->SetActive(PR_FALSE);
 1:       }
 1:     }
 1:     else
 1:       if ( !IsOpen() ) {
 1:         // one of our siblings is probably open and even possibly waiting
 1:         // for its close timer to fire. Tell our parent to close it down. Not
 1:         // doing this before its timer fires will cause the rollup state to
 1:         // get very confused.
 1:         if ( mMenuParent )
 1:           mMenuParent->KillPendingTimers();
 1: 
 1:         // safe to open up
 1:         OpenMenu(PR_TRUE);
 1:       }
 1:   }
 1:   else if (
 1: #ifndef NSCONTEXTMENUISMOUSEUP
 1:            (aEvent->eventStructType == NS_MOUSE_EVENT &&
 1:             aEvent->message == NS_MOUSE_BUTTON_UP &&
 1:             NS_STATIC_CAST(nsMouseEvent*, aEvent)->button ==
 1:               nsMouseEvent::eRightButton) &&
 1: #else
 1:             aEvent->message == NS_CONTEXTMENU &&
 1: #endif
 1:             mMenuParent && !IsMenu() && !IsDisabled()) {
 1:     // if this menu is a context menu it accepts right-clicks...fire away!
 1:     // Make sure we cancel default processing of the context menu event so
 1:     // that it doesn't bubble and get seen again by the popuplistener and show
 1:     // another context menu.
 1:     //
 1:     // Furthermore (there's always more, isn't there?), on some platforms (win32
 1:     // being one of them) we get the context menu event on a mouse up while
 1:     // on others we get it on a mouse down. For the ones where we get it on a
 1:     // mouse down, we must continue listening for the right button up event to
 1:     // dismiss the menu.
 1:     PRBool isContextMenu = PR_FALSE;
 1:     mMenuParent->GetIsContextMenu(isContextMenu);
 1:     if ( isContextMenu ) {
 1:       *aEventStatus = nsEventStatus_eConsumeNoDefault;
 1:       Execute(aEvent);
 1:     }
 1:   }
 1:   else if (aEvent->eventStructType == NS_MOUSE_EVENT &&
 1:            aEvent->message == NS_MOUSE_BUTTON_UP &&
 1:            NS_STATIC_CAST(nsMouseEvent*, aEvent)->button == nsMouseEvent::eLeftButton &&
 1:            !IsMenu() && mMenuParent && !IsDisabled()) {
 1:     // Execute the execute event handler.
 1:     Execute(aEvent);
 1:   }
 1:   else if (aEvent->message == NS_MOUSE_EXIT_SYNTH) {
 1:     // Kill our timer if one is active.
 1:     if (mOpenTimer) {
 1:       mOpenTimer->Cancel();
 1:       mOpenTimer = nsnull;
 1:     }
 1: 
 1:     // Deactivate the menu.
 1:     PRBool isActive = PR_FALSE;
 1:     PRBool isMenuBar = PR_FALSE;
 1:     if (mMenuParent) {
 1:       mMenuParent->IsMenuBar(isMenuBar);
 1:       PRBool cancel = PR_TRUE;
 1:       if (isMenuBar) {
 1:         mMenuParent->GetIsActive(isActive);
 1:         if (isActive) cancel = PR_FALSE;
 1:       }
 1:       
 1:       if (cancel) {
 1:         if (IsMenu() && !isMenuBar && mMenuOpen) {
 1:           // Submenus don't get closed up immediately.
 1:         }
 1:         else mMenuParent->SetCurrentMenuItem(nsnull);
 1:       }
 1:     }
 1:   }
 1:   else if (aEvent->message == NS_MOUSE_MOVE && mMenuParent) {
 1:     if (gEatMouseMove) {
 1:       gEatMouseMove = PR_FALSE;
 1:       return NS_OK;
 1:     }
 1: 
 1:     // we checked for mMenuParent right above
 1: 
 1:     PRBool isMenuBar = PR_FALSE;
 1:     mMenuParent->IsMenuBar(isMenuBar);
 1: 
 1:     // Let the menu parent know we're the new item.
 1:     mMenuParent->SetCurrentMenuItem(this);
 1:     NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1:     NS_ENSURE_TRUE(mMenuParent, NS_OK);
 1:     
 1:     // we need to check if we really became the current menu
 1:     // item or not
 1:     nsIMenuFrame *realCurrentItem = mMenuParent->GetCurrentMenuItem();
 1:     if (realCurrentItem != this) {
 1:       // we didn't (presumably because a context menu was active)
 1:       return NS_OK;
 1:     }
 1: 
 1:     // If we're a menu (and not a menu item),
 1:     // kick off the timer.
 1:     if (!IsDisabled() && !isMenuBar && IsMenu() && !mMenuOpen && !mOpenTimer) {
 1: 
 1:       PRInt32 menuDelay = 300;   // ms
 1: 
 1:       nsCOMPtr<nsILookAndFeel> lookAndFeel(do_GetService(kLookAndFeelCID));
 1:       if (lookAndFeel)
 1:         lookAndFeel->GetMetric(nsILookAndFeel::eMetric_SubmenuDelay, menuDelay);
 1: 
 1:       // We're a menu, we're built, we're closed, and no timer has been kicked off.
 1:       mOpenTimer = do_CreateInstance("@mozilla.org/timer;1");
 1:       mOpenTimer->InitWithCallback(mTimerMediator, menuDelay, nsITimer::TYPE_ONE_SHOT);
 1: 
 1:     }
 1:   }
 1:   
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::ToggleMenuState()
 1: {
 1:   nsWeakFrame weakFrame(this);
 1:   if (mMenuOpen) {
 1:     OpenMenu(PR_FALSE);
 1:     NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1:   }
 1:   else {
 1:     PRBool justRolledUp = PR_FALSE;
 1:     if (mMenuParent) {
 1:       mMenuParent->RecentlyRolledUp(this, &justRolledUp);
 1:     }
 1:     if (justRolledUp) {
 1:       // Don't let a click reopen a menu that was just rolled up
 1:       // from the same click. Otherwise, the user can't click on
 1:       // a menubar item to toggle its submenu closed.
 1:       OpenMenu(PR_FALSE);
 1:       NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1:       SelectMenu(PR_TRUE);
 1:       NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1:       NS_ENSURE_TRUE(mMenuParent, NS_OK);
 1:       mMenuParent->SetActive(PR_FALSE);
 1:     }
 1:     else {
 1:       if (mMenuParent) {
 1:         mMenuParent->SetActive(PR_TRUE);
 1:         NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1:       }
 1:       OpenMenu(PR_TRUE);
 1:     }
 1:   }
 1:   NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1: 
 1:   if (mMenuParent) {
 1:     // Make sure the current menu which is being toggled on
 1:     // the menubar is highlighted
 1:     mMenuParent->SetCurrentMenuItem(this);
 1:     NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1:     NS_ENSURE_TRUE(mMenuParent, NS_OK);
 1:     // We've successfully prevented the same click from both
 1:     // dismissing and reopening this menu. 
 1:     // Clear the recent rollup state so we don't prevent
 1:     // this menu from being opened by the next click.
 1:     mMenuParent->ClearRecentlyRolledUp();
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::SelectMenu(PRBool aActivateFlag)
 1: {
 1:   if (!mContent) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   nsAutoString domEventToFire;
 1: 
 1:   nsWeakFrame weakFrame(this);
 1:   if (aActivateFlag) {
 1:     if (mMenuParent) {
 1:       nsIMenuParent* ancestor = nsnull;
 1:       nsresult rv = mMenuParent->GetParentPopup(&ancestor);
 1:       while (NS_SUCCEEDED(rv) && ancestor) {
 1:         ancestor->CancelPendingTimers();
 1:         rv = ancestor->GetParentPopup(&ancestor);
 1:       }
 1:     }
 1:     // Highlight the menu.
 1:     mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::menuactive, NS_LITERAL_STRING("true"), PR_TRUE);
 1:     // The menuactivated event is used by accessibility to track the user's movements through menus
 1:     domEventToFire.AssignLiteral("DOMMenuItemActive");
 1:   }
 1:   else {
 1:     // Unhighlight the menu.
 1:     mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::menuactive, PR_TRUE);
 1:     domEventToFire.AssignLiteral("DOMMenuItemInactive");
 1:   }
 1: 
 1:   if (weakFrame.IsAlive()) {
 1:     FireDOMEventSynch(domEventToFire);
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: PRBool nsMenuFrame::IsGenerated()
 1: {
 1:   nsCOMPtr<nsIContent> child;
 1:   GetMenuChildrenElement(getter_AddRefs(child));
 1:   
 1:   // Generate the menu if it hasn't been generated already.  This
 1:   // takes it from display: none to display: block and gives us
 1:   // a menu forevermore.
 1:   if (child &&
 1:       !nsContentUtils::HasNonEmptyAttr(child, kNameSpaceID_None,
 1:                                        nsGkAtoms::menugenerated)) {
 1:     return PR_FALSE;
 1:   }
 1: 
 1:   return PR_TRUE;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::MarkAsGenerated()
 1: {
 1:   nsCOMPtr<nsIContent> child;
 1:   GetMenuChildrenElement(getter_AddRefs(child));
 1:   
 1:   // Generate the menu if it hasn't been generated already.  This
 1:   // takes it from display: none to display: block and gives us
 1:   // a menu forevermore.
 1:   if (child &&
 1:       !nsContentUtils::HasNonEmptyAttr(child, kNameSpaceID_None,
 1:                                        nsGkAtoms::menugenerated)) {
 1:     child->SetAttr(kNameSpaceID_None, nsGkAtoms::menugenerated,
 1:                    NS_LITERAL_STRING("true"), PR_TRUE);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::UngenerateMenu()
 1: {
 1:   nsCOMPtr<nsIContent> child;
 1:   GetMenuChildrenElement(getter_AddRefs(child));
 1:   
 1:   if (child &&
 1:       nsContentUtils::HasNonEmptyAttr(child, kNameSpaceID_None,
 1:                                       nsGkAtoms::menugenerated)) {
 1:     child->UnsetAttr(kNameSpaceID_None, nsGkAtoms::menugenerated, PR_TRUE);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::ActivateMenu(PRBool aActivateFlag)
 1: {
 1:   nsIFrame* frame = mPopupFrames.FirstChild();
 1:   nsMenuPopupFrame* menuPopup = (nsMenuPopupFrame*)frame;
 1:   
 1:   if (!menuPopup) 
 1:     return NS_OK;
 1: 
 1:   if (aActivateFlag) {
 1:       nsRect rect = menuPopup->GetRect();
 1:       nsIView* view = menuPopup->GetView();
 1:       nsIViewManager* viewManager = view->GetViewManager();
 1:       rect.x = rect.y = 0;
 1:       viewManager->ResizeView(view, rect);
 1: 
 1:       // make sure the scrolled window is at 0,0
 1:       if (mLastPref.height <= rect.height) {
 1:         nsIBox* child = menuPopup->GetChildBox();
 1: 
 1:         nsCOMPtr<nsIScrollableFrame> scrollframe(do_QueryInterface(child));
 1:         if (scrollframe) {
 1:           scrollframe->ScrollTo(nsPoint(0,0));
 1:         }
 1:       }
 1: 
 1:       viewManager->UpdateView(view, rect, NS_VMREFRESH_IMMEDIATE);
 1:       viewManager->SetViewVisibility(view, nsViewVisibility_kShow);
 1:       GetPresContext()->RootPresContext()->NotifyAddedActivePopupToTop(menuPopup);
 1:   } else {
 1:     if (mMenuOpen) {
 1:       nsWeakFrame weakFrame(this);
 1:       nsWeakFrame weakPopup(menuPopup);
 1:       FireDOMEventSynch(NS_LITERAL_STRING("DOMMenuInactive"), menuPopup->GetContent());
 1:       NS_ENSURE_TRUE(weakFrame.IsAlive() && weakPopup.IsAlive(), NS_OK);
 1:     }
 1:     nsIView* view = menuPopup->GetView();
 1:     NS_ASSERTION(view, "View is gone, looks like someone forgot to rollup the popup!");
 1:     if (view) {
 1:       nsIViewManager* viewManager = view->GetViewManager();
 1:       if (viewManager) { // the view manager can be null during widget teardown
 1:         viewManager->SetViewVisibility(view, nsViewVisibility_kHide);
 1:         viewManager->ResizeView(view, nsRect(0, 0, 0, 0));
 1:       }
 1:     }
 1:     // set here so hide chain can close the menu as well.
 1:     mMenuOpen = PR_FALSE;
 1:     GetPresContext()->RootPresContext()->NotifyRemovedActivePopup(menuPopup);
 1:   }
 1:   
 1:   return NS_OK;
 1: }  
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::AttributeChanged(PRInt32 aNameSpaceID,
 1:                               nsIAtom* aAttribute,
 1:                               PRInt32 aModType)
 1: {
 1:   nsAutoString value;
 1: 
 1:   if (aAttribute == nsGkAtoms::checked) {
 1:     if (mType != eMenuType_Normal)
 1:         UpdateMenuSpecialState(GetPresContext());
 1:   } else if (aAttribute == nsGkAtoms::acceltext) {
 1:     // someone reset the accelText attribute, so clear the bit that says *we* set it
 1:     AddStateBits(NS_STATE_ACCELTEXT_IS_DERIVED);
 1:     BuildAcceleratorText();
 1:   } else if (aAttribute == nsGkAtoms::key) {
 1:     BuildAcceleratorText();
 1:   } else if ( aAttribute == nsGkAtoms::type || aAttribute == nsGkAtoms::name )
 1:     UpdateMenuType(GetPresContext());
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::OpenMenu(PRBool aActivateFlag)
 1: {
 1:   if (!mContent)
 1:     return NS_OK;
 1: 
 1:   nsWeakFrame weakFrame(this);
 1:   if (aActivateFlag) {
 1:     // Now that the menu is opened, we should have a menupopup child built.
 1:     // Mark it as generated, which ensures a frame gets built.
 1:     MarkAsGenerated();
 1:     NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1: 
 1:     mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::open, NS_LITERAL_STRING("true"), PR_TRUE);
 1:     NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1:     FireDOMEventSynch(NS_LITERAL_STRING("DOMMenuItemActive"));
 1:   }
 1:   else {
 1:     mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::open, PR_TRUE);
 1:   }
 1: 
 1:   NS_ENSURE_TRUE(weakFrame.IsAlive(), NS_OK);
 1:   OpenMenuInternal(aActivateFlag);
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: void 
 1: nsMenuFrame::OpenMenuInternal(PRBool aActivateFlag) 
 1: {
 1:   gEatMouseMove = PR_TRUE;
 1: 
 1:   if (!mIsMenu)
 1:     return;
 1: 
 1:   nsPresContext* presContext = GetPresContext();
 1:   nsWeakFrame weakFrame(this);
 1: 
 1:   if (aActivateFlag) {
 1:     // Execute the oncreate handler
 1:     if (!OnCreate() || !weakFrame.IsAlive())
 1:       return;
 1: 
 1:     mCreateHandlerSucceeded = PR_TRUE;
 1:   
 1:     // Set the focus back to our view's widget.
 1:     if (nsMenuDismissalListener::sInstance)
 1:       nsMenuDismissalListener::sInstance->EnableListener(PR_FALSE);
 1:     
 1:     // XXX Only have this here because of RDF-generated content.
 1:     MarkAsGenerated();
 1:     ENSURE_TRUE(weakFrame.IsAlive());
 1: 
 1:     nsIFrame* frame = mPopupFrames.FirstChild();
 1:     nsMenuPopupFrame* menuPopup = (nsMenuPopupFrame*)frame;
 1:     
 1:     PRBool wasOpen = mMenuOpen;
 1:     mMenuOpen = PR_TRUE;
 1: 
 1:     if (menuPopup) {
 1:       nsWeakFrame weakMenuPopup(frame);
 1:       // inherit whether or not we're a context menu from the parent
 1:       if ( mMenuParent ) {
 1:         PRBool parentIsContextMenu = PR_FALSE;
 1:         mMenuParent->GetIsContextMenu(parentIsContextMenu);
 1:         menuPopup->SetIsContextMenu(parentIsContextMenu);
 1:         ENSURE_TRUE(weakFrame.IsAlive());
 1:       }
 1: 
 1:       // Install a keyboard navigation listener if we're the root of the menu chain.
 1:       PRBool onMenuBar = PR_TRUE;
 1:       if (mMenuParent)
 1:         mMenuParent->IsMenuBar(onMenuBar);
 1: 
 1:       if (mMenuParent && onMenuBar)
 1:         mMenuParent->InstallKeyboardNavigator();
 1:       else if (!mMenuParent) {
 1:         ENSURE_TRUE(weakMenuPopup.IsAlive());
 1:         menuPopup->InstallKeyboardNavigator();
 1:       }
 1:       
 1:       // Tell the menu bar we're active.
 1:       if (mMenuParent) {
 1:         mMenuParent->SetActive(PR_TRUE);
 1:         ENSURE_TRUE(weakFrame.IsAlive());
 1:       }
 1: 
 1:       nsIContent* menuPopupContent = menuPopup->GetContent();
 1: 
 1:       // Sync up the view.
 1:       nsAutoString popupAnchor, popupAlign;
 1:       
 1:       menuPopupContent->GetAttr(kNameSpaceID_None, nsGkAtoms::popupanchor, popupAnchor);
 1:       menuPopupContent->GetAttr(kNameSpaceID_None, nsGkAtoms::popupalign, popupAlign);
 1: 
 1:       ConvertPosition(menuPopupContent, popupAnchor, popupAlign);
 1: 
 1:       if (onMenuBar) {
 1:         if (popupAnchor.IsEmpty())
 1:           popupAnchor.AssignLiteral("bottomleft");
 1:         if (popupAlign.IsEmpty())
 1:           popupAlign.AssignLiteral("topleft");
 1:       }
 1:       else {
 1:         if (popupAnchor.IsEmpty())
 1:           popupAnchor.AssignLiteral("topright");
 1:         if (popupAlign.IsEmpty())
 1:           popupAlign.AssignLiteral("topleft");
 1:       }
 1: 
 1:       // If the menu popup was not open, do a reflow.  This is either the
 1:       // initial reflow for a brand-new popup, or a subsequent reflow for
 1:       // a menu that was deactivated and needs to be brought back to its
 1:       // active dimensions.
 1:       if (!wasOpen)
 1:       {
 1:          menuPopup->AddStateBits(NS_FRAME_IS_DIRTY);
 1:          presContext->PresShell()->
 1:            FrameNeedsReflow(menuPopup, nsIPresShell::eStyleChange);
 1:          presContext->PresShell()->FlushPendingNotifications(Flush_OnlyReflow);
 1:       }
 1: 
 1:       nsRect curRect(menuPopup->GetRect());
 1:       nsBoxLayoutState state(presContext);
 1:       menuPopup->SetBounds(state, nsRect(0,0,mLastPref.width, mLastPref.height));
 1: 
 1:       nsIView* view = menuPopup->GetView();
 1:       nsIViewManager* vm = view->GetViewManager();
 1:       if (vm) {
 1:         vm->SetViewVisibility(view, nsViewVisibility_kHide);
 1:       }
 1:       menuPopup->SyncViewWithFrame(presContext, popupAnchor, popupAlign, this, -1, -1);
 1:       nscoord newHeight = menuPopup->GetRect().height;
 1: 
 1:       // if the height is different then reflow. It might need scrollbars force a reflow
 1:       if (curRect.height != newHeight || mLastPref.height != newHeight)
 1:       {
 1:          menuPopup->AddStateBits(NS_FRAME_IS_DIRTY);
 1:          presContext->PresShell()->
 1:            FrameNeedsReflow(menuPopup, nsIPresShell::eStyleChange);
 1:          presContext->PresShell()->FlushPendingNotifications(Flush_OnlyReflow);
 1:       }
 1: 
 1:       ActivateMenu(PR_TRUE);
 1:       ENSURE_TRUE(weakFrame.IsAlive());
 1: 
 1:       nsIMenuParent *childPopup = nsnull;
 1:       CallQueryInterface(frame, &childPopup);
 1: 
 1:       nsMenuDismissalListener* listener = nsMenuDismissalListener::GetInstance();
 1:       if (listener)
 1:         listener->SetCurrentMenuParent(childPopup);
 1: 
 1:       OnCreated();
 1:       ENSURE_TRUE(weakFrame.IsAlive());
 1:     }
 1: 
 1:     // Set the focus back to our view's widget.
 1:     if (nsMenuDismissalListener::sInstance)
 1:       nsMenuDismissalListener::sInstance->EnableListener(PR_TRUE);
 1: 
 1:   }
 1:   else {
 1: 
 1:     // Close the menu. 
 1:     // Execute the ondestroy handler, but only if we're actually open
 1:     if ( !mCreateHandlerSucceeded || !OnDestroy() || !weakFrame.IsAlive())
 1:       return;
 1: 
 1:     // Set the focus back to our view's widget.
 1:     if (nsMenuDismissalListener::sInstance) {
 1:       nsMenuDismissalListener::sInstance->EnableListener(PR_FALSE);
 1:       nsMenuDismissalListener::sInstance->SetCurrentMenuParent(mMenuParent);
 1:     }
 1: 
 1:     nsIFrame* frame = mPopupFrames.FirstChild();
 1:     nsMenuPopupFrame* menuPopup = (nsMenuPopupFrame*)frame;
 1:   
 1:     // Make sure we clear out our own items.
 1:     if (menuPopup) {
 1:       menuPopup->SetCurrentMenuItem(nsnull);
 1:       ENSURE_TRUE(weakFrame.IsAlive());
 1:       menuPopup->KillCloseTimer();
 1: 
 1:       PRBool onMenuBar = PR_TRUE;
 1:       if (mMenuParent)
 1:         mMenuParent->IsMenuBar(onMenuBar);
 1: 
 1:       if (mMenuParent && onMenuBar)
 1:         mMenuParent->RemoveKeyboardNavigator();
 1:       else if (!mMenuParent)
 1:         menuPopup->RemoveKeyboardNavigator();
 1: 
 1:       // XXX, bug 137033, In Windows, if mouse is outside the window when the menupopup closes, no
 1:       // mouse_enter/mouse_exit event will be fired to clear current hover state, we should clear it manually.
 1:       // This code may not the best solution, but we can leave it here until we find the better approach.
 1: 
 1:       nsIEventStateManager *esm = presContext->EventStateManager();
 1: 
 1:       PRInt32 state;
 1:       esm->GetContentState(menuPopup->GetContent(), state);
 1: 
 1:       if (state & NS_EVENT_STATE_HOVER)
 1:         esm->SetContentState(nsnull, NS_EVENT_STATE_HOVER);
 1:     }
 1: 
 1:     ActivateMenu(PR_FALSE);
 1:     ENSURE_TRUE(weakFrame.IsAlive());
 1:     // XXX hack: ensure that mMenuOpen is set to false, in case where
 1:     // there is actually no popup. because ActivateMenu() will return 
 1:     // early without setting it. It could be that mMenuOpen is true
 1:     // in that case, because OpenMenuInternal(true) gets called if
 1:     // the attribute open="true", whether there is a popup or not.
 1:     // We should not allow mMenuOpen unless there is a popup in the first place,
 1:     // in which case this line would not be necessary.
 1:     mMenuOpen = PR_FALSE;
 1: 
 1:     OnDestroyed();
 1:     ENSURE_TRUE(weakFrame.IsAlive());
 1: 
 1:     if (nsMenuDismissalListener::sInstance)
 1:       nsMenuDismissalListener::sInstance->EnableListener(PR_TRUE);
 1: 
 1:     mCreateHandlerSucceeded = PR_FALSE;
 1:   }
 1: 
 1: }
 1: 
 1: void
 1: nsMenuFrame::GetMenuChildrenElement(nsIContent** aResult)
 1: {
 1:   *aResult = nsContentUtils::FindFirstChildWithResolvedTag(mContent,
 1:                                                            kNameSpaceID_XUL,
 1:                                                            nsGkAtoms::menupopup);
 1:   NS_IF_ADDREF(*aResult);
 1: }
 1: 
 1: PRBool
 1: nsMenuFrame::IsSizedToPopup(nsIContent* aContent, PRBool aRequireAlways)
 1: {
 1:   PRBool sizeToPopup;
 1:   if (aContent->Tag() == nsGkAtoms::select)
 1:     sizeToPopup = PR_TRUE;
 1:   else {
 1:     nsAutoString sizedToPopup;
 1:     aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::sizetopopup, sizedToPopup);
 1:     sizeToPopup = sizedToPopup.EqualsLiteral("always") ||
 1:                   !aRequireAlways && sizedToPopup.EqualsLiteral("pref");
 1:   }
 1:   
 1:   return sizeToPopup;
 1: }
 1: 
 1: nsSize
 1: nsMenuFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
 1: {
 1:   nsSize size = nsBoxFrame::GetMinSize(aBoxLayoutState);
 1:   DISPLAY_MIN_SIZE(this, size);
 1: 
 1:   if (IsSizedToPopup(mContent, PR_TRUE))
 1:     SizeToPopup(aBoxLayoutState, size);
 1: 
 1:   return size;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::DoLayout(nsBoxLayoutState& aState)
 1: {
 1:   // lay us out
 1:   nsresult rv = nsBoxFrame::DoLayout(aState);
 1: 
 1:   // layout the popup. First we need to get it.
 1:   nsIFrame* popupChild = mPopupFrames.FirstChild();
 1: 
 1:   if (popupChild) {
 1:     PRBool sizeToPopup = IsSizedToPopup(mContent, PR_FALSE);
 1:     
 1:     NS_ASSERTION(popupChild->IsBoxFrame(), "popupChild is not box!!");
 1: 
 1:     // then get its preferred size
 1:     nsSize prefSize = popupChild->GetPrefSize(aState);
 1:     nsSize minSize = popupChild->GetMinSize(aState); 
 1:     nsSize maxSize = popupChild->GetMaxSize(aState);
 1: 
 1:     BoundsCheck(minSize, prefSize, maxSize);
 1: 
 1:     if (sizeToPopup)
 1:         prefSize.width = mRect.width;
 1: 
 1:     // if the pref size changed then set bounds to be the pref size
 1:     // and sync the view. And set new pref size.
 1:     if (mLastPref != prefSize) {
 1:       popupChild->SetBounds(aState, nsRect(0,0,prefSize.width, prefSize.height));
 1:       RePositionPopup(aState);
 1:       mLastPref = prefSize;
 1:     }
 1: 
 1:     // is the new size too small? Make sure we handle scrollbars correctly
 1:     nsIBox* child = popupChild->GetChildBox();
 1: 
 1:     nsRect bounds(popupChild->GetRect());
 1: 
 1:     nsCOMPtr<nsIScrollableFrame> scrollframe(do_QueryInterface(child));
 1:     if (scrollframe &&
 1:         scrollframe->GetScrollbarStyles().mVertical == NS_STYLE_OVERFLOW_AUTO) {
 1:       if (bounds.height < prefSize.height) {
 1:         // layout the child
 1:         popupChild->Layout(aState);
 1: 
 1:         nsMargin scrollbars = scrollframe->GetActualScrollbarSizes();
 1:         if (bounds.width < prefSize.width + scrollbars.left + scrollbars.right)
 1:         {
 1:           bounds.width += scrollbars.left + scrollbars.right;
 1:           //printf("Width=%d\n",width);
 1:           popupChild->SetBounds(aState, bounds);
 1:         }
 1:       }
 1:     }
 1:     
 1:     // layout the child
 1:     popupChild->Layout(aState);
 1: 
 1:     // Only size the popups view if open.
 1:     if (mMenuOpen) {
 1:       nsIView* view = popupChild->GetView();
 1:       nsRect r(0, 0, bounds.width, bounds.height);
 1:       view->GetViewManager()->ResizeView(view, r);
 1:     }
 1: 
 1:   }
 1: 
 1:   SyncLayout(aState);
 1: 
 1:   return rv;
 1: }
 1: 
 1: #ifdef DEBUG_LAYOUT
 1: NS_IMETHODIMP
 1: nsMenuFrame::SetDebug(nsBoxLayoutState& aState, PRBool aDebug)
 1: {
 1:   // see if our state matches the given debug state
 1:   PRBool debugSet = mState & NS_STATE_CURRENTLY_IN_DEBUG;
 1:   PRBool debugChanged = (!aDebug && debugSet) || (aDebug && !debugSet);
 1: 
 1:   // if it doesn't then tell each child below us the new debug state
 1:   if (debugChanged)
 1:   {
 1:       nsBoxFrame::SetDebug(aState, aDebug);
 1:       SetDebug(aState, mPopupFrames.FirstChild(), aDebug);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsMenuFrame::SetDebug(nsBoxLayoutState& aState, nsIFrame* aList, PRBool aDebug)
 1: {
 1:       if (!aList)
 1:           return NS_OK;
 1: 
 1:       while (aList) {
 1:         if (aList->IsBoxFrame())
 1:           aList->SetDebug(aState, aDebug);
 1: 
 1:         aList = aList->GetNextSibling();
 1:       }
 1: 
 1:       return NS_OK;
 1: }
 1: #endif
 1: 
 1: void
 1: nsMenuFrame::ConvertPosition(nsIContent* aPopupElt, nsString& aAnchor, nsString& aAlign)
 1: {
 1:   static nsIContent::AttrValuesArray strings[] =
 1:     {&nsGkAtoms::_empty, &nsGkAtoms::before_start, &nsGkAtoms::before_end,
 1:      &nsGkAtoms::after_start, &nsGkAtoms::after_end, &nsGkAtoms::start_before,
 1:      &nsGkAtoms::start_after, &nsGkAtoms::end_before, &nsGkAtoms::end_after,
 1:      &nsGkAtoms::overlap, nsnull};
 1: 
 1:   switch (aPopupElt->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::position,
 1:                                      strings, eCaseMatters)) {
 1:     case nsIContent::ATTR_MISSING:
 1:     case 0:
 1:       return;
 1:     case 1:
 1:       aAnchor.AssignLiteral("topleft");
 1:       aAlign.AssignLiteral("bottomleft");
 1:       break;
 1:     case 2:
 1:       aAnchor.AssignLiteral("topright");
 1:       aAlign.AssignLiteral("bottomright");
 1:       break;
 1:     case 3:
 1:       aAnchor.AssignLiteral("bottomleft");
 1:       aAlign.AssignLiteral("topleft");
 1:       break;
 1:     case 4:
 1:       aAnchor.AssignLiteral("bottomright");
 1:       aAlign.AssignLiteral("topright");
 1:       break;
 1:     case 5:
 1:       aAnchor.AssignLiteral("topleft");
 1:       aAlign.AssignLiteral("topright");
 1:       break;
 1:     case 6:
 1:       aAnchor.AssignLiteral("bottomleft");
 1:       aAlign.AssignLiteral("bottomright");
 1:       break;
 1:     case 7:
 1:       aAnchor.AssignLiteral("topright");
 1:       aAlign.AssignLiteral("topleft");
 1:       break;
 1:     case 8:
 1:       aAnchor.AssignLiteral("bottomright");
 1:       aAlign.AssignLiteral("bottomleft");
 1:       break;
 1:     case 9:
 1:       aAnchor.AssignLiteral("topleft");
 1:       aAlign.AssignLiteral("topleft");
 1:       break;
 1:   }
 1: }
 1: 
 1: void
 1: nsMenuFrame::RePositionPopup(nsBoxLayoutState& aState)
 1: {  
 1:   nsPresContext* presContext = aState.PresContext();
 1: 
 1:   // Sync up the view.
 1:   nsIFrame* frame = mPopupFrames.FirstChild();
 1:   nsMenuPopupFrame* menuPopup = (nsMenuPopupFrame*)frame;
 1:   if (mMenuOpen && menuPopup) {
 1:     nsIContent* menuPopupContent = menuPopup->GetContent();
 1:     nsAutoString popupAnchor, popupAlign;
 1:       
 1:     menuPopupContent->GetAttr(kNameSpaceID_None, nsGkAtoms::popupanchor, popupAnchor);
 1:     menuPopupContent->GetAttr(kNameSpaceID_None, nsGkAtoms::popupalign, popupAlign);
 1: 
 1:     ConvertPosition(menuPopupContent, popupAnchor, popupAlign);
 1: 
 1:     PRBool onMenuBar = PR_TRUE;
 1:     if (mMenuParent)
 1:       mMenuParent->IsMenuBar(onMenuBar);
 1: 
 1:     if (onMenuBar) {
 1:       if (popupAnchor.IsEmpty())
 1:           popupAnchor.AssignLiteral("bottomleft");
 1:       if (popupAlign.IsEmpty())
 1:           popupAlign.AssignLiteral("topleft");
 1:     }
 1:     else {
 1:       if (popupAnchor.IsEmpty())
 1:         popupAnchor.AssignLiteral("topright");
 1:       if (popupAlign.IsEmpty())
 1:         popupAlign.AssignLiteral("topleft");
 1:     }
 1: 
 1:     menuPopup->SyncViewWithFrame(presContext, popupAnchor, popupAlign, this, -1, -1);
 1:   }
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::ShortcutNavigation(nsIDOMKeyEvent* aKeyEvent, PRBool& aHandledFlag)
 1: {
 1:   nsIFrame* frame = mPopupFrames.FirstChild();
 1:   if (frame) {
 1:     nsMenuPopupFrame* popup = (nsMenuPopupFrame*)frame;
 1:     popup->ShortcutNavigation(aKeyEvent, aHandledFlag);
 1:   } 
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::KeyboardNavigation(PRUint32 aKeyCode, PRBool& aHandledFlag)
 1: {
 1:   nsIFrame* frame = mPopupFrames.FirstChild();
 1:   if (frame) {
 1:     nsMenuPopupFrame* popup = (nsMenuPopupFrame*)frame;
 1:     popup->KeyboardNavigation(aKeyCode, aHandledFlag);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::Escape(PRBool& aHandledFlag)
 1: {
 1:   if (mMenuParent) {
 1:     mMenuParent->ClearRecentlyRolledUp();
 1:   }
 1:   nsIFrame* frame = mPopupFrames.FirstChild();
 1:   if (frame) {
 1:     nsMenuPopupFrame* popup = (nsMenuPopupFrame*)frame;
 1:     popup->Escape(aHandledFlag);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: 
 1: //
 1: // Enter
 1: //
 1: // Called when the user hits the <Enter>/<Return> keys or presses the
 1: // shortcut key. If this is a leaf item, the item's action will be executed.
 1: // If it is a submenu parent, open the submenu and select the first time.
 1: // In either case, do nothing if the item is disabled.
 1: //
 1: NS_IMETHODIMP
 1: nsMenuFrame::Enter()
 1: {
 1:   if (IsDisabled()) {
 1: #ifdef XP_WIN
 1:     // behavior on Windows - close the popup chain
 1:     if (mMenuParent)
 1:       mMenuParent->DismissChain();
 1: #endif   // #ifdef XP_WIN
 1:     // this menu item was disabled - exit
 1:     return NS_OK;
 1:   }
 1:     
 1:   if (!mMenuOpen) {
 1:     // The enter key press applies to us.
 1:     if (!IsMenu() && mMenuParent)
 1:       Execute(0);          // Execute our event handler
 1:     else {
 1:       OpenMenu(PR_TRUE);
 1:       SelectFirstItem();
 1:     }
 1: 
 1:     return NS_OK;
 1:   }
 1: 
 1:   nsIFrame* frame = mPopupFrames.FirstChild();
 1:   if (frame) {
 1:     nsMenuPopupFrame* popup = (nsMenuPopupFrame*)frame;
 1:     popup->Enter();
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::SelectFirstItem()
 1: {
 1:   nsIFrame* frame = mPopupFrames.FirstChild();
 1:   if (frame) {
 1:     nsMenuPopupFrame* popup = (nsMenuPopupFrame*)frame;
 1:     popup->SetCurrentMenuItem(popup->GetNextMenuItem(nsnull));
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: PRBool
 1: nsMenuFrame::IsMenu()
 1: {
 1:   return mIsMenu;
 1: }
 1: 
 1: nsresult
 1: nsMenuFrame::Notify(nsITimer* aTimer)
 1: {
 1:   // Our timer has fired.
 1:   if (aTimer == mOpenTimer.get()) {
 1:     if (!mMenuOpen && mMenuParent) {
 1:       // make sure we didn't open a context menu in the meantime
 1:       // (i.e. the user right-clicked while hovering over a submenu).
 1:       // However, also make sure that we're not the context menu itself,
 1:       // to allow context submenus to open.
 1:       nsIMenuParent *ctxMenu = nsMenuFrame::GetContextMenu();
 1:       PRBool parentIsContextMenu = PR_FALSE;
 1: 
 1:       if (ctxMenu)
 1:         mMenuParent->GetIsContextMenu(parentIsContextMenu);
 1: 
 1:       if (ctxMenu == nsnull || parentIsContextMenu) {
 1:         if (mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::menuactive,
 1:                                   nsGkAtoms::_true, eCaseMatters)) {
 1:           // We're still the active menu. Make sure all submenus/timers are closed
 1:           // before opening this one
 1:           mMenuParent->KillPendingTimers();
 1:           OpenMenu(PR_TRUE);
 1:         }
 1:       }
 1:     }
 1:     mOpenTimer->Cancel();
 1:     mOpenTimer = nsnull;
 1:   }
 1:   
 1:   mOpenTimer = nsnull;
 1:   return NS_OK;
 1: }
 1: 
 1: PRBool 
 1: nsMenuFrame::IsDisabled()
 1: {
 1:   return mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
 1:                                nsGkAtoms::_true, eCaseMatters);
 1: }
 1: 
 1: void
 1: nsMenuFrame::UpdateMenuType(nsPresContext* aPresContext)
 1: {
 1:   static nsIContent::AttrValuesArray strings[] =
 1:     {&nsGkAtoms::checkbox, &nsGkAtoms::radio, nsnull};
 1:   switch (mContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::type,
 1:                                     strings, eCaseMatters)) {
 1:     case 0: mType = eMenuType_Checkbox; break;
 1:     case 1:
 1:       mType = eMenuType_Radio;
 1:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::name, mGroupName);
 1:       break;
 1: 
 1:     default:
 1:       if (mType != eMenuType_Normal) {
 1:         nsWeakFrame weakFrame(this);
 1:         mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::checked,
 1:                             PR_TRUE);
 1:         ENSURE_TRUE(weakFrame.IsAlive());
 1:       }
 1:       mType = eMenuType_Normal;
 1:       break;
 1:   }
 1:   UpdateMenuSpecialState(aPresContext);
 1: }
 1: 
 1: /* update checked-ness for type="checkbox" and type="radio" */
 1: void
 1: nsMenuFrame::UpdateMenuSpecialState(nsPresContext* aPresContext) {
 1:   PRBool newChecked =
 1:     mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::checked,
 1:                           nsGkAtoms::_true, eCaseMatters); 
 1: 
 1:   if (newChecked == mChecked) {
 1:     /* checked state didn't change */
 1: 
 1:     if (mType != eMenuType_Radio)
 1:       return; // only Radio possibly cares about other kinds of change
 1: 
 1:     if (!mChecked || mGroupName.IsEmpty())
 1:       return;                   // no interesting change
 1:   } else { 
 1:     mChecked = newChecked;
 1:     if (mType != eMenuType_Radio || !mChecked)
 1:       /*
 1:        * Unchecking something requires no further changes, and only
 1:        * menuRadio has to do additional work when checked.
 1:        */
 1:       return;
 1:   }
 1: 
 1:   /*
 1:    * If we get this far, we're type=radio, and:
 1:    * - our name= changed, or
 1:    * - we went from checked="false" to checked="true"
 1:    */
 1: 
 1:   /*
 1:    * Behavioural note:
 1:    * If we're checked and renamed _into_ an existing radio group, we are
 1:    * made the new checked item, and we unselect the previous one.
 1:    *
 1:    * The only other reasonable behaviour would be to check for another selected
 1:    * item in that group.  If found, unselect ourselves, otherwise we're the
 1:    * selected item.  That, however, would be a lot more work, and I don't think
 1:    * it's better at all.
 1:    */
 1: 
 1:   /* walk siblings, looking for the other checked item with the same name */
 1:   nsIMenuFrame *sibMenu;
 1:   nsMenuType sibType;
 1:   nsAutoString sibGroup;
 1:   PRBool sibChecked;
 1:   
 1:   // get the first sibling in this menu popup. This frame may be it, and if we're
 1:   // being called at creation time, this frame isn't yet in the parent's child list.
 1:   // All I'm saying is that this may fail, but it's most likely alright.
 1:   nsIFrame* sib = GetParent()->GetFirstChild(nsnull);
 1:   if ( !sib )
 1:     return;
 1: 
 1:   // XXX - egcs 1.1.2 & gcc 2.95.x -Oy builds, where y > 1, 
 1:   // are known to break if we declare nsCOMPtrs inside this loop.  
 1:   // Moving the declaration out of the loop works around this problem.
 1:   // http://bugzilla.mozilla.org/show_bug.cgi?id=80988
 1: 
 1:   do {
 1:     if (NS_FAILED(sib->QueryInterface(NS_GET_IID(nsIMenuFrame),
 1:                                       (void **)&sibMenu)))
 1:         continue;
 1:         
 1:     if (sibMenu != (nsIMenuFrame *)this &&        // correct way to check?
 1:         (sibMenu->GetMenuType(sibType), sibType == eMenuType_Radio) &&
 1:         (sibMenu->MenuIsChecked(sibChecked), sibChecked) &&
 1:         (sibMenu->GetRadioGroupName(sibGroup), sibGroup == mGroupName)) {
 1:       
 1:       /* uncheck the old item */
 1:       sib->GetContent()->UnsetAttr(kNameSpaceID_None, nsGkAtoms::checked,
 1:                                    PR_TRUE);
 1: 
 1:       /* XXX in DEBUG, check to make sure that there aren't two checked items */
 1:       return;
 1:     }
 1: 
 1:   } while ((sib = sib->GetNextSibling()) != nsnull);
 1: 
 1: }
 1: 
 1: void 
 1: nsMenuFrame::BuildAcceleratorText()
 1: {
 1:   nsAutoString accelText;
 1: 
 1:   if ((GetStateBits() & NS_STATE_ACCELTEXT_IS_DERIVED) == 0) {
 1:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::acceltext, accelText);
 1:     if (!accelText.IsEmpty())
 1:       return;
 1:   }
 1:   // accelText is definitely empty here.
 1: 
 1:   // Now we're going to compute the accelerator text, so remember that we did.
 1:   AddStateBits(NS_STATE_ACCELTEXT_IS_DERIVED);
 1: 
 1:   // If anything below fails, just leave the accelerator text blank.
 1:   nsWeakFrame weakFrame(this);
 1:   mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::acceltext, PR_FALSE);
 1:   ENSURE_TRUE(weakFrame.IsAlive());
 1: 
 1:   // See if we have a key node and use that instead.
 1:   nsAutoString keyValue;
 1:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::key, keyValue);
 1:   if (keyValue.IsEmpty())
 1:     return;
 1: 
 1:   // Turn the document into a DOM document so we can use getElementById
 1:   nsCOMPtr<nsIDOMDocument> domDocument(do_QueryInterface(mContent->GetDocument()));
 1:   if (!domDocument)
 1:     return;
 1: 
 1:   nsCOMPtr<nsIDOMElement> keyDOMElement;
 1:   domDocument->GetElementById(keyValue, getter_AddRefs(keyDOMElement));
 1:   if (!keyDOMElement) {
 1: #ifdef DEBUG
 1:     nsAutoString label;
 1:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, label);
 1:     nsAutoString msg = NS_LITERAL_STRING("Key '") +
 1:                        keyValue +
 1:                        NS_LITERAL_STRING("' of menu item '") +
 1:                        label +
 1:                        NS_LITERAL_STRING("' could not be found");
 1:     NS_WARNING(NS_ConvertUTF16toUTF8(msg).get());
 1: #endif
 1:     return;
 1:   }
 1: 
 1:   nsCOMPtr<nsIContent> keyElement(do_QueryInterface(keyDOMElement));
 1:   if (!keyElement)
 1:     return;
 1: 
 1:   // get the string to display as accelerator text
 1:   // check the key element's attributes in this order:
 1:   // |keytext|, |key|, |keycode|
 1:   nsAutoString accelString;
 1:   keyElement->GetAttr(kNameSpaceID_None, nsGkAtoms::keytext, accelString);
 1: 
 1:   if (accelString.IsEmpty()) {
 1:     keyElement->GetAttr(kNameSpaceID_None, nsGkAtoms::key, accelString);
 1: 
 1:     if (!accelString.IsEmpty()) {
 1:       ToUpperCase(accelString);
 1:     } else {
 1:       nsAutoString keyCode;
 1:       keyElement->GetAttr(kNameSpaceID_None, nsGkAtoms::keycode, keyCode);
 1:       ToUpperCase(keyCode);
 1: 
 1:       nsresult rv;
 1:       nsCOMPtr<nsIStringBundleService> bundleService(do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv));
 1:       if (NS_SUCCEEDED(rv) && bundleService) {
 1:         nsCOMPtr<nsIStringBundle> bundle;
 1:         rv = bundleService->CreateBundle("chrome://global/locale/keys.properties",
 1:                                          getter_AddRefs(bundle));
 1: 
 1:         if (NS_SUCCEEDED(rv) && bundle) {
 1:           nsXPIDLString keyName;
 1:           rv = bundle->GetStringFromName(keyCode.get(), getter_Copies(keyName));
 1:           if (keyName)
 1:             accelString = keyName;
 1:         }
 1:       }
 1: 
 1:       // nothing usable found, bail
 1:       if (accelString.IsEmpty())
 1:         return;
 1:     }
 1:   }
 1: 
 1:   static PRInt32 accelKey = 0;
 1: 
 1:   if (!accelKey)
 1:   {
 1:     // Compiled-in defaults, in case we can't get LookAndFeel --
 1:     // command for mac, control for all other platforms.
 1: #if defined(XP_MAC) || defined(XP_MACOSX)
 1:     accelKey = nsIDOMKeyEvent::DOM_VK_META;
 1: #else
 1:     accelKey = nsIDOMKeyEvent::DOM_VK_CONTROL;
 1: #endif
 1: 
 1:     // Get the accelerator key value from prefs, overriding the default:
 1:     accelKey = nsContentUtils::GetIntPref("ui.key.accelKey", accelKey);
 1:   }
 1: 
 1:   nsAutoString modifiers;
 1:   keyElement->GetAttr(kNameSpaceID_None, nsGkAtoms::modifiers, modifiers);
 1:   
 1:   char* str = ToNewCString(modifiers);
 1:   char* newStr;
 1:   char* token = nsCRT::strtok(str, ", \t", &newStr);
 1:   while (token) {
 1:       
 1:     if (PL_strcmp(token, "shift") == 0)
 1:       accelText += *gShiftText;
 1:     else if (PL_strcmp(token, "alt") == 0) 
 1:       accelText += *gAltText; 
 1:     else if (PL_strcmp(token, "meta") == 0) 
 1:       accelText += *gMetaText; 
 1:     else if (PL_strcmp(token, "control") == 0) 
 1:       accelText += *gControlText; 
 1:     else if (PL_strcmp(token, "accel") == 0) {
 1:       switch (accelKey)
 1:       {
 1:         case nsIDOMKeyEvent::DOM_VK_META:
 1:           accelText += *gMetaText;
 1:           break;
 1: 
 1:         case nsIDOMKeyEvent::DOM_VK_ALT:
 1:           accelText += *gAltText;
 1:           break;
 1: 
 1:         case nsIDOMKeyEvent::DOM_VK_CONTROL:
 1:         default:
 1:           accelText += *gControlText;
 1:           break;
 1:       }
 1:     }
 1:     
 1:     accelText += *gModifierSeparator;
 1: 
 1:     token = nsCRT::strtok(newStr, ", \t", &newStr);
 1:   }
 1: 
 1:   nsMemory::Free(str);
 1: 
 1:   accelText += accelString;
 1:   
 1:   mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::acceltext, accelText, PR_FALSE);
 1: }
 1: 
 1: void
 1: nsMenuFrame::Execute(nsGUIEvent *aEvent)
 1: {
 1:   nsWeakFrame weakFrame(this);
 1:   // flip "checked" state if we're a checkbox menu, or an un-checked radio menu
 1:   if (mType == eMenuType_Checkbox || (mType == eMenuType_Radio && !mChecked)) {
 1:     if (!mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::autocheck,
 1:                                nsGkAtoms::_false, eCaseMatters)) {
 1:       if (mChecked) {
 1:         mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::checked,
 1:                             PR_TRUE);
 1:         ENSURE_TRUE(weakFrame.IsAlive());
 1:       }
 1:       else {
 1:         mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::checked, NS_LITERAL_STRING("true"),
 1:                           PR_TRUE);
 1:         ENSURE_TRUE(weakFrame.IsAlive());
 1:       }        
 1:       /* the AttributeChanged code will update all the internal state */
 1:     }
 1:   }
 1: 
 1:   // Temporarily disable rollup events on this menu.  This is
 1:   // to suppress this menu getting removed in the case where
 1:   // the oncommand handler opens a dialog, etc.
 1:   if ( nsMenuDismissalListener::sInstance ) {
 1:     nsMenuDismissalListener::sInstance->EnableListener(PR_FALSE);
 1:   }
 1: 
 1:   // Get our own content node and hold on to it to keep it from going away.
 1:   nsCOMPtr<nsIContent> content = mContent;
 1: 
 1:   // Deselect ourselves.
 1:   SelectMenu(PR_FALSE);
 1:   ENSURE_TRUE(weakFrame.IsAlive());
 1: 
 1:   // Now hide all of the open menus.
 1:   if (mMenuParent) {
 1:     mMenuParent->HideChain();
 1: 
 1:     // Since menu was not dismissed via click outside menu
 1:     // we don't want to keep track of this rollup.
 1:     // Otherwise, we keep track so that the same click 
 1:     // won't both dismiss and then reopen a menu.
 1:     mMenuParent->ClearRecentlyRolledUp();
 1:   }
 1: 
 1: 
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   // Create a trusted event if the triggering event was trusted, or if
 1:   // we're called from chrome code (since at least one of our caller
 1:   // passes in a null event).
 1:   nsXULCommandEvent event(aEvent ? NS_IS_TRUSTED_EVENT(aEvent) :
 1:                           nsContentUtils::IsCallerChrome(),
 1:                           NS_XUL_COMMAND, nsnull);
 1:   if (aEvent && (aEvent->eventStructType == NS_MOUSE_EVENT ||
 1:                  aEvent->eventStructType == NS_KEY_EVENT ||
 1:                  aEvent->eventStructType == NS_ACCESSIBLE_EVENT)) {
 1: 
 1:     event.isShift = NS_STATIC_CAST(nsInputEvent *, aEvent)->isShift;
 1:     event.isControl = NS_STATIC_CAST(nsInputEvent *, aEvent)->isControl;
 1:     event.isAlt = NS_STATIC_CAST(nsInputEvent *, aEvent)->isAlt;
 1:     event.isMeta = NS_STATIC_CAST(nsInputEvent *, aEvent)->isMeta;
 1:   }
 1: 
 1:   // The order of the nsIViewManager and nsIPresShell COM pointers is
 1:   // important below.  We want the pres shell to get released before the
 1:   // associated view manager on exit from this function.
 1:   // See bug 54233.
 1:   nsPresContext* presContext = GetPresContext();
 1:   nsCOMPtr<nsIViewManager> kungFuDeathGrip = presContext->GetViewManager();
 1:   nsCOMPtr<nsIPresShell> shell = presContext->GetPresShell();
 1:   if (shell) {
 1:     shell->HandleDOMEventWithTarget(mContent, &event, &status);
 1:     ENSURE_TRUE(weakFrame.IsAlive());
 1:   }
 1: 
 1:   if (mMenuParent) {
 1:     mMenuParent->DismissChain();
 1:   }
 1: 
 1:   // Re-enable rollup events on this menu.
 1:   if ( nsMenuDismissalListener::sInstance ) {
 1:     nsMenuDismissalListener::sInstance->EnableListener(PR_TRUE);
 1:   }
 1: }
 1: 
 1: PRBool
 1: nsMenuFrame::OnCreate()
 1: {
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_SHOWING, nsnull,
 1:                      nsMouseEvent::eReal);
 1: 
 1:   nsCOMPtr<nsIContent> child;
 1:   GetMenuChildrenElement(getter_AddRefs(child));
 1:   
 1:   nsresult rv = NS_OK;
 1: 
95:   nsCOMPtr<nsIPresShell> shell = GetPresContext()->GetPresShell();
 1:   if (shell) {
 1:     if (child) {
 1:       rv = shell->HandleDOMEventWithTarget(child, &event, &status);
 1:     }
 1:     else {
 1:       rv = shell->HandleDOMEventWithTarget(mContent, &event, &status);
 1:     }
 1:   }
 1: 
 1:   if ( NS_FAILED(rv) || status == nsEventStatus_eConsumeNoDefault )
 1:     return PR_FALSE;
 1: 
 1:   // The menu is going to show, and the create handler has executed.
 1:   // We should now walk all of our menu item children, checking to see if any
 1:   // of them has a command attribute.  If so, then several attributes must
 1:   // potentially be updated.
 1:   if (child) {
 1:     nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(child->GetDocument()));
 1: 
 1:     PRUint32 count = child->GetChildCount();
 1:     for (PRUint32 i = 0; i < count; i++) {
 1:       nsCOMPtr<nsIContent> grandChild = child->GetChildAt(i);
 1: 
 1:       if (grandChild->Tag() == nsGkAtoms::menuitem) {
 1:         // See if we have a command attribute.
 1:         nsAutoString command;
 1:         grandChild->GetAttr(kNameSpaceID_None, nsGkAtoms::command, command);
 1:         if (!command.IsEmpty()) {
 1:           // We do! Look it up in our document
 1:           nsCOMPtr<nsIDOMElement> commandElt;
 1:           domDoc->GetElementById(command, getter_AddRefs(commandElt));
 1:           nsCOMPtr<nsIContent> commandContent(do_QueryInterface(commandElt));
 1: 
 1:           if ( commandContent ) {
 1:             nsAutoString commandAttr;
 1:             // The menu's disabled state needs to be updated to match the command.
 1:             if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::disabled, commandAttr))
 1:               grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::disabled, commandAttr, PR_TRUE);
 1:             else
 1:               grandChild->UnsetAttr(kNameSpaceID_None, nsGkAtoms::disabled, PR_TRUE);
 1: 
 1:             // The menu's label, accesskey and checked states need to be updated
 1:             // to match the command. Note that unlike the disabled state if the
 1:             // command has *no* value, we assume the menu is supplying its own.
 1:             if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::checked, commandAttr))
 1:               grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::checked, commandAttr, PR_TRUE);
 1: 
 1:             if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, commandAttr))
 1:               grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, commandAttr, PR_TRUE);
 1: 
 1:             if (commandContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, commandAttr))
 1:               grandChild->SetAttr(kNameSpaceID_None, nsGkAtoms::label, commandAttr, PR_TRUE);
 1:           }
 1:         }
 1:       }
 1:     }
 1:   }
 1: 
 1:   return PR_TRUE;
 1: }
 1: 
 1: PRBool
 1: nsMenuFrame::OnCreated()
 1: {
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_SHOWN, nsnull,
 1:                      nsMouseEvent::eReal);
 1: 
 1:   nsCOMPtr<nsIContent> child;
 1:   GetMenuChildrenElement(getter_AddRefs(child));
 1:   
 1:   nsresult rv = NS_OK;
95:   nsCOMPtr<nsIPresShell> shell = GetPresContext()->GetPresShell();
 1:   if (shell) {
 1:     if (child) {
 1:       rv = shell->HandleDOMEventWithTarget(child, &event, &status);
 1:     }
 1:     else {
 1:       rv = shell->HandleDOMEventWithTarget(mContent, &event, &status);
 1:     }
 1:   }
 1: 
 1:   if ( NS_FAILED(rv) || status == nsEventStatus_eConsumeNoDefault )
 1:     return PR_FALSE;
 1:   return PR_TRUE;
 1: }
 1: 
 1: PRBool
 1: nsMenuFrame::OnDestroy()
 1: {
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_HIDING, nsnull,
 1:                      nsMouseEvent::eReal);
 1: 
 1:   nsCOMPtr<nsIContent> child;
 1:   GetMenuChildrenElement(getter_AddRefs(child));
 1:   
 1:   nsresult rv = NS_OK;
95:   nsCOMPtr<nsIPresShell> shell = GetPresContext()->GetPresShell();
 1:   if (shell) {
 1:     if (child) {
 1:       rv = shell->HandleDOMEventWithTarget(child, &event, &status);
 1:     }
 1:     else {
 1:       rv = shell->HandleDOMEventWithTarget(mContent, &event, &status);
 1:     }
 1:   }
 1: 
 1:   if ( NS_FAILED(rv) || status == nsEventStatus_eConsumeNoDefault )
 1:     return PR_FALSE;
 1:   return PR_TRUE;
 1: }
 1: 
 1: PRBool
 1: nsMenuFrame::OnDestroyed()
 1: {
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsMouseEvent event(PR_TRUE, NS_XUL_POPUP_HIDDEN, nsnull,
 1:                      nsMouseEvent::eReal);
 1: 
 1:   nsCOMPtr<nsIContent> child;
 1:   GetMenuChildrenElement(getter_AddRefs(child));
 1:   
 1:   nsresult rv = NS_OK;
95:   nsCOMPtr<nsIPresShell> shell = GetPresContext()->GetPresShell();
 1:   if (shell) {
 1:     if (child) {
 1:       rv = shell->HandleDOMEventWithTarget(child, &event, &status);
 1:     }
 1:     else {
 1:       rv = shell->HandleDOMEventWithTarget(mContent, &event, &status);
 1:     }
 1:   }
 1: 
 1:   if ( NS_FAILED(rv) || status == nsEventStatus_eConsumeNoDefault )
 1:     return PR_FALSE;
 1:   return PR_TRUE;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::RemoveFrame(nsIAtom*        aListName,
 1:                          nsIFrame*       aOldFrame)
 1: {
 1:   nsresult  rv;
 1: 
 1:   if (mPopupFrames.ContainsFrame(aOldFrame)) {
 1:     // Go ahead and remove this frame.
 1:     mPopupFrames.DestroyFrame(aOldFrame);
 1:     AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
 1:     GetPresContext()->PresShell()->
 1:       FrameNeedsReflow(this, nsIPresShell::eTreeChange);
 1:     rv = NS_OK;
 1:   } else {
 1:     rv = nsBoxFrame::RemoveFrame(aListName, aOldFrame);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::InsertFrames(nsIAtom*        aListName,
 1:                           nsIFrame*       aPrevFrame,
 1:                           nsIFrame*       aFrameList)
 1: {
 1:   nsresult          rv;
 1: 
 1:   nsIMenuParent *menuPar;
 1:   if (aFrameList && NS_SUCCEEDED(CallQueryInterface(aFrameList, &menuPar))) {
 1:     NS_ASSERTION(aFrameList->IsBoxFrame(),"Popup is not a box!!!");
 1:     mPopupFrames.InsertFrames(nsnull, nsnull, aFrameList);
 1: 
 1: #ifdef DEBUG_LAYOUT
 1:     nsBoxLayoutState state(GetPresContext());
 1:     SetDebug(state, aFrameList, mState & NS_STATE_CURRENTLY_IN_DEBUG);
 1: #endif
 1:     AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
 1:     GetPresContext()->PresShell()->
 1:       FrameNeedsReflow(this, nsIPresShell::eTreeChange);
 1:     rv = NS_OK;
 1:   } else {
 1:     rv = nsBoxFrame::InsertFrames(aListName, aPrevFrame, aFrameList);  
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::AppendFrames(nsIAtom*        aListName,
 1:                           nsIFrame*       aFrameList)
 1: {
 1:   if (!aFrameList)
 1:     return NS_OK;
 1: 
 1:   nsresult          rv;
 1: 
 1:   nsIMenuParent *menuPar;
 1:   if (aFrameList && NS_SUCCEEDED(CallQueryInterface(aFrameList, &menuPar))) {
 1:     NS_ASSERTION(aFrameList->IsBoxFrame(),"Popup is not a box!!!");
 1: 
 1:     mPopupFrames.AppendFrames(nsnull, aFrameList);
 1: #ifdef DEBUG_LAYOUT
 1:     nsBoxLayoutState state(GetPresContext());
 1:     SetDebug(state, aFrameList, mState & NS_STATE_CURRENTLY_IN_DEBUG);
 1: #endif
 1:     AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
 1:     GetPresContext()->PresShell()->
 1:       FrameNeedsReflow(this, nsIPresShell::eTreeChange);
 1:     rv = NS_OK;
 1:   } else {
 1:     rv = nsBoxFrame::AppendFrames(aListName, aFrameList); 
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: class nsASyncMenuGeneration : public nsIReflowCallback
 1: {
 1: public:
 1:   nsASyncMenuGeneration(nsIFrame* aFrame)
 1:     : mWeakFrame(aFrame)
 1:   {
 1:     nsIContent* content = aFrame ? aFrame->GetContent() : nsnull;
 1:     mDocument = content ? content->GetCurrentDoc() : nsnull;
 1:     if (mDocument) {
 1:       mDocument->BlockOnload();
 1:     }
 1:   }
 1: 
 1:   virtual PRBool ReflowFinished() {
 1:     PRBool shouldFlush = PR_FALSE;
 1:     nsIFrame* frame = mWeakFrame.GetFrame();
 1:     if (frame) {
 1:       nsBoxLayoutState state(frame->GetPresContext());
 1:       if (!frame->IsCollapsed(state)) {
 1:         nsIMenuFrame* imenu = nsnull;
 1:         CallQueryInterface(frame, &imenu);
 1:         if (imenu) {
 1:           imenu->MarkAsGenerated();
 1:           shouldFlush = PR_TRUE;
 1:         }
 1:       }
 1:     }
 1:     if (mDocument) {
 1:       mDocument->UnblockOnload(PR_FALSE);
 1:     }
 1:     delete this;
 1:     return shouldFlush;
 1:   }
 1: 
 1:   nsWeakFrame           mWeakFrame;
 1:   nsCOMPtr<nsIDocument> mDocument;
 1: };
 1: 
 1: PRBool
 1: nsMenuFrame::SizeToPopup(nsBoxLayoutState& aState, nsSize& aSize)
 1: {
 1:   if (!IsCollapsed(aState)) {
 1:     nsSize tmpSize(-1, 0);
 1:     nsIBox::AddCSSPrefSize(aState, this, tmpSize);
 1:     if (tmpSize.width == -1 && GetFlex(aState) == 0) {
 1:       nsIFrame* frame = mPopupFrames.FirstChild();
 1:       if (!frame) {
 1:         nsCOMPtr<nsIContent> child;
 1:         GetMenuChildrenElement(getter_AddRefs(child));
 1:         if (child &&
 1:             !nsContentUtils::HasNonEmptyAttr(child, kNameSpaceID_None,
 1:                                              nsGkAtoms::menugenerated)) {
 1:           nsIReflowCallback* cb = new nsASyncMenuGeneration(this);
 1:           if (cb) {
 1:             GetPresContext()->PresShell()->PostReflowCallback(cb);
 1:           }
 1:         }
 1:         return PR_FALSE;
 1:       }
 1: 
 1:       NS_ASSERTION(frame->IsBoxFrame(), "popupChild is not box!!");
 1: 
 1:       tmpSize = frame->GetPrefSize(aState);
 1:       aSize.width = tmpSize.width;
 1:       return PR_TRUE;
 1:     }
 1:   }
 1: 
 1:   return PR_FALSE;
 1: }
 1: 
 1: nsSize
 1: nsMenuFrame::GetPrefSize(nsBoxLayoutState& aState)
 1: {
 1:   nsSize size = nsBoxFrame::GetPrefSize(aState);
 1:   DISPLAY_PREF_SIZE(this, size);
 1: 
 1:   // If we are using sizetopopup="always" then
 1:   // nsBoxFrame will already have enforced the minimum size
 1:   if (!IsSizedToPopup(mContent, PR_TRUE) &&
 1:       IsSizedToPopup(mContent, PR_FALSE) &&
 1:       SizeToPopup(aState, size)) {
 1:     // We now need to ensure that size is within the min - max range.
 1:     nsSize minSize = nsBoxFrame::GetMinSize(aState);
 1:     nsSize maxSize = GetMaxSize(aState);
 1:     BoundsCheck(minSize, size, maxSize);
 1:   }
 1: 
 1:   return size;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::GetActiveChild(nsIDOMElement** aResult)
 1: {
 1:   nsIFrame* frame = mPopupFrames.FirstChild();
 1:   nsMenuPopupFrame* menuPopup = (nsMenuPopupFrame*)frame;
 1:   if (!frame)
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   nsIMenuFrame* menuFrame = menuPopup->GetCurrentMenuItem();
 1:   
 1:   if (!menuFrame) {
 1:     *aResult = nsnull;
 1:   }
 1:   else {
 1:     nsIFrame* f;
 1:     menuFrame->QueryInterface(NS_GET_IID(nsIFrame), (void**)&f);
 1:     nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(f->GetContent()));
 1:     *aResult = elt;
 1:     NS_IF_ADDREF(*aResult);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsMenuFrame::SetActiveChild(nsIDOMElement* aChild)
 1: {
 1:   nsIFrame* frame = mPopupFrames.FirstChild();
 1:   nsMenuPopupFrame* menuPopup = (nsMenuPopupFrame*)frame;
 1:   if (!frame)
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   if (!aChild) {
 1:     // Remove the current selection
 1:     menuPopup->SetCurrentMenuItem(nsnull);
 1:     return NS_OK;
 1:   }
 1: 
 1:   nsCOMPtr<nsIContent> child(do_QueryInterface(aChild));
 1:   
 1:   nsIFrame* kid = GetPresContext()->PresShell()->GetPrimaryFrameFor(child);
 1:   if (!kid)
 1:     return NS_ERROR_FAILURE;
 1:   nsIMenuFrame *menuFrame;
 1:   nsresult rv = CallQueryInterface(kid, &menuFrame);
 1:   if (NS_FAILED(rv))
 1:     return rv;
 1:   menuPopup->SetCurrentMenuItem(menuFrame);
 1:   return NS_OK;
 1: }
 1: 
 1: nsIScrollableView* nsMenuFrame::GetScrollableView()
 1: {
 1:   if (!mPopupFrames.FirstChild())
 1:     return nsnull;
 1: 
 1:   nsMenuPopupFrame* popup = (nsMenuPopupFrame*) mPopupFrames.FirstChild();
 1:   nsIFrame* childFrame = popup->GetFirstChild(nsnull);
 1:   if (childFrame) {
 1:     return popup->GetScrollableView(childFrame);
 1:   }
 1:   return nsnull;
 1: }
 1: 
 1: /* Need to figure out what this does.
 1: NS_IMETHODIMP
 1: nsMenuFrame::GetBoxInfo(nsPresContext* aPresContext, const nsHTMLReflowState& aReflowState, nsBoxInfo& aSize)
 1: {
 1:   nsresult rv = nsBoxFrame::GetBoxInfo(aPresContext, aReflowState, aSize);
 1:   nsCOMPtr<nsIDOMXULMenuListElement> menulist(do_QueryInterface(mContent));
 1:   if (menulist) {
 1:     nsCalculatedBoxInfo boxInfo(this);
 1:     boxInfo.prefSize.width = NS_UNCONSTRAINEDSIZE;
 1:     boxInfo.prefSize.height = NS_UNCONSTRAINEDSIZE;
 1:     boxInfo.flex = 0;
 1:     GetRedefinedMinPrefMax(aPresContext, this, boxInfo);
 1:     if (boxInfo.prefSize.width == NS_UNCONSTRAINEDSIZE &&
 1:         boxInfo.prefSize.height == NS_UNCONSTRAINEDSIZE &&
 1:         boxInfo.flex == 0) {
 1:       nsIFrame* frame = mPopupFrames.FirstChild();
 1:       if (!frame) {
 1:         MarkAsGenerated();
 1:         frame = mPopupFrames.FirstChild();
 1:       }
 1:       
 1:       nsCalculatedBoxInfo childInfo(frame);
 1:       frame->GetBoxInfo(aPresContext, aReflowState, childInfo);
 1:       GetRedefinedMinPrefMax(aPresContext, this, childInfo);
 1:       aSize.prefSize.width = childInfo.prefSize.width;
 1:     }
 1: 
 1:     // This retrieval guarantess that the selectedItem will
 1:     // be set before we lay out.
 1:     nsCOMPtr<nsIDOMElement> element;
 1:     menulist->GetSelectedItem(getter_AddRefs(element));
 1:   }
 1:   return rv;
 1: }
 1: */
 1: 
 1: nsIMenuParent*
 1: nsMenuFrame::GetContextMenu()
 1: {
 1:   if (!nsMenuDismissalListener::sInstance)
 1:     return nsnull;
 1: 
 1:   nsIMenuParent *menuParent =
 1:     nsMenuDismissalListener::sInstance->GetCurrentMenuParent();
 1:   if (!menuParent)
 1:     return nsnull;
 1: 
 1:   PRBool isContextMenu;
 1:   menuParent->GetIsContextMenu(isContextMenu);
 1:   if (isContextMenu)
 1:     return menuParent;
 1: 
 1:   return nsnull;
 1: }
 1: 
 1: // nsMenuTimerMediator implementation.
 1: NS_IMPL_ISUPPORTS1(nsMenuTimerMediator, nsITimerCallback)
 1: 
 1: /**
 1:  * Constructs a wrapper around an nsMenuFrame.
 1:  * @param aFrame nsMenuFrame to create a wrapper around.
 1:  */
 1: nsMenuTimerMediator::nsMenuTimerMediator(nsMenuFrame *aFrame) :
 1:   mFrame(aFrame)
 1: {
 1:   NS_ASSERTION(mFrame, "Must have frame");
 1: }
 1: 
 1: nsMenuTimerMediator::~nsMenuTimerMediator()
 1: {
 1: }
 1: 
 1: /**
 1:  * Delegates the notification to the contained frame if it has not been destroyed.
 1:  * @param aTimer Timer which initiated the callback.
 1:  * @return NS_ERROR_FAILURE if the frame has been destroyed.
 1:  */
 1: NS_IMETHODIMP nsMenuTimerMediator::Notify(nsITimer* aTimer)
 1: {
 1:   if (!mFrame)
 1:     return NS_ERROR_FAILURE;
 1: 
 1:   return mFrame->Notify(aTimer);
 1: }
 1: 
 1: /**
 1:  * Clear the pointer to the contained nsMenuFrame. This should be called
 1:  * when the contained nsMenuFrame is destroyed.
 1:  */
 1: void nsMenuTimerMediator::ClearFrame()
 1: {
 1:   mFrame = nsnull;
 1: }
