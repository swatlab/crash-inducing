     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 94037: // Main header first:
     1: #include "nsSVGOuterSVGFrame.h"
 93575: 
 94037: // Keep others in (case-insensitive) order:
 94037: #include "DOMSVGTests.h"
 94037: #include "gfxMatrix.h"
 94037: #include "nsDisplayList.h"
 94037: #include "nsIDocument.h"
     1: #include "nsIDOMSVGSVGElement.h"
 94037: #include "nsIDOMWindow.h"
 94037: #include "nsIInterfaceRequestorUtils.h"
 94037: #include "nsIObjectLoadingContent.h"
 93575: #include "nsRenderingContext.h"
 94037: #include "nsStubMutationObserver.h"
103332: #include "nsSVGIntegrationUtils.h"
105565: #include "nsSVGForeignObjectFrame.h"
     1: #include "nsSVGSVGElement.h"
     1: #include "nsSVGTextFrame.h"
     1: 
 51350: namespace dom = mozilla::dom;
 51350: 
     1: class nsSVGMutationObserver : public nsStubMutationObserver
     1: {
     1: public:
     1:   // nsIMutationObserver interface
   876:   NS_DECL_NSIMUTATIONOBSERVER_ATTRIBUTECHANGED
     1: 
     1:   // nsISupports interface:
     1:   NS_IMETHOD QueryInterface(const nsIID& aIID, void** aInstancePtr);
     1: private:
     1:   NS_IMETHOD_(nsrefcnt) AddRef() { return 1; }
     1:   NS_IMETHOD_(nsrefcnt) Release() { return 1; }
     1: 
     1:   static void UpdateTextFragmentTrees(nsIFrame *aFrame);
     1: };
     1: 
     1: //----------------------------------------------------------------------
     1: // nsISupports methods
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsSVGMutationObserver)
     1:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
     1: NS_INTERFACE_MAP_END
     1: 
     1: static nsSVGMutationObserver sSVGMutationObserver;
     1: 
     1: //----------------------------------------------------------------------
     1: // nsIMutationObserver methods
     1: 
     1: void
     1: nsSVGMutationObserver::AttributeChanged(nsIDocument* aDocument,
 51350:                                         dom::Element* aElement,
108991:                                         int32_t aNameSpaceID,
     1:                                         nsIAtom* aAttribute,
108991:                                         int32_t aModType)
     1: {
     1:   if (aNameSpaceID != kNameSpaceID_XML || aAttribute != nsGkAtoms::space) {
     1:     return;
     1:   }
     1: 
 51350:   nsIFrame* frame = aElement->GetPrimaryFrame();
     1:   if (!frame) {
 36917:     return;
     1:   }
     1: 
     1:   // is the content a child of a text element
 29052:   nsSVGTextContainerFrame* containerFrame = do_QueryFrame(frame);
 29052:   if (containerFrame) {
 14042:     containerFrame->NotifyGlyphMetricsChange();
 36917:     return;
     1:   }
     1:   // if not, are there text elements amongst its descendents
     1:   UpdateTextFragmentTrees(frame);
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // Implementation helpers
     1: 
     1: void
105565: nsSVGOuterSVGFrame::RegisterForeignObject(nsSVGForeignObjectFrame* aFrame)
105565: {
105565:   NS_ASSERTION(aFrame, "Who on earth is calling us?!");
105565: 
105565:   if (!mForeignObjectHash.IsInitialized()) {
105565:     mForeignObjectHash.Init();
105565:   }
105565: 
105565:   NS_ASSERTION(!mForeignObjectHash.GetEntry(aFrame),
105565:                "nsSVGForeignObjectFrame already registered!");
105565: 
105565:   mForeignObjectHash.PutEntry(aFrame);
105565: 
105565:   NS_ASSERTION(mForeignObjectHash.GetEntry(aFrame),
105565:                "Failed to register nsSVGForeignObjectFrame!");
105565: }
105565: 
105565: void
105565: nsSVGOuterSVGFrame::UnregisterForeignObject(nsSVGForeignObjectFrame* aFrame)
105565: {
105565:   NS_ASSERTION(aFrame, "Who on earth is calling us?!");
105565:   NS_ASSERTION(mForeignObjectHash.GetEntry(aFrame),
105565:                "nsSVGForeignObjectFrame not in registry!");
105565:   return mForeignObjectHash.RemoveEntry(aFrame);
105565: }
105565: 
105565: void
     1: nsSVGMutationObserver::UpdateTextFragmentTrees(nsIFrame *aFrame)
     1: {
 77154:   nsIFrame* kid = aFrame->GetFirstPrincipalChild();
     1:   while (kid) {
     1:     if (kid->GetType() == nsGkAtoms::svgTextFrame) {
  3233:       nsSVGTextFrame* textFrame = static_cast<nsSVGTextFrame*>(kid);
     1:       textFrame->NotifyGlyphMetricsChange();
     1:     } else {
     1:       UpdateTextFragmentTrees(kid);
     1:     }
     1:     kid = kid->GetNextSibling();
     1:   }
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // Implementation
     1: 
     1: nsIFrame*
 23953: NS_NewSVGOuterSVGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {  
     1:   return new (aPresShell) nsSVGOuterSVGFrame(aContext);
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsSVGOuterSVGFrame)
 32423: 
     1: nsSVGOuterSVGFrame::nsSVGOuterSVGFrame(nsStyleContext* aContext)
 10103:     : nsSVGOuterSVGFrameBase(aContext)
110767:     , mFullZoom(aContext->PresContext()->GetFullZoom())
 80486:     , mViewportInitialized(false)
 80486:     , mIsRootContent(false)
     1: {
 98711:   // Outer-<svg> has CSS layout, so remove this bit:
 98711:   RemoveStateBits(NS_FRAME_SVG_LAYOUT);
     1: }
     1: 
     1: NS_IMETHODIMP
  5468: nsSVGOuterSVGFrame::Init(nsIContent* aContent,
  5468:                          nsIFrame* aParent,
  5468:                          nsIFrame* aPrevInFlow)
     1: {
 23953: #ifdef DEBUG
 23953:   nsCOMPtr<nsIDOMSVGSVGElement> svgElement = do_QueryInterface(aContent);
 23953:   NS_ASSERTION(svgElement, "Content is not an SVG 'svg' element!");
 23953: #endif
 23953: 
 95533:   AddStateBits(NS_STATE_IS_OUTER_SVG |
 95533:                NS_FRAME_FONT_INFLATION_CONTAINER |
 95533:                NS_FRAME_FONT_INFLATION_FLOW_ROOT);
 15471: 
 58894:   // Check for conditional processing attributes here rather than in
 58894:   // nsCSSFrameConstructor::FindSVGData because we want to avoid
 58894:   // simply giving failing outer <svg> elements an nsSVGContainerFrame.
 93574:   // We don't create other SVG frames if PassesConditionalProcessingTests
 93574:   // returns false, but since we do create nsSVGOuterSVGFrame frames we
 93574:   // prevent them from painting by [ab]use NS_STATE_SVG_NONDISPLAY_CHILD. The
 93574:   // frame will be recreated via an nsChangeHint_ReconstructFrame restyle if
 93574:   // the value returned by PassesConditionalProcessingTests changes.
 86429:   nsSVGSVGElement *svg = static_cast<nsSVGSVGElement*>(aContent);
 86429:   if (!svg->PassesConditionalProcessingTests()) {
 58894:     AddStateBits(NS_STATE_SVG_NONDISPLAY_CHILD);
 58894:   }
 58894: 
  5468:   nsresult rv = nsSVGOuterSVGFrameBase::Init(aContent, aParent, aPrevInFlow);
  5468: 
     1:   nsIDocument* doc = mContent->GetCurrentDoc();
     1:   if (doc) {
     1:     // we only care about our content's zoom and pan values if it's the root element
 41634:     if (doc->GetRootElement() == mContent) {
 80486:       mIsRootContent = true;
     1:     }
     1:     // sSVGMutationObserver has the same lifetime as the document so does
     1:     // not need to be removed
 41925:     doc->AddMutationObserverUnlessExists(&sSVGMutationObserver);
     1:   }
     1: 
  5468:   return rv;
     1: }
     1: 
     1: //----------------------------------------------------------------------
 23554: // nsQueryFrame methods
     1: 
 23554: NS_QUERYFRAME_HEAD(nsSVGOuterSVGFrame)
 23554:   NS_QUERYFRAME_ENTRY(nsISVGSVGFrame)
 23554: NS_QUERYFRAME_TAIL_INHERITING(nsSVGOuterSVGFrameBase)
     1: 
     1: //----------------------------------------------------------------------
     1: // nsIFrame methods
     1:   
     1: //----------------------------------------------------------------------
     1: // reflowing
     1: 
  8142: /* virtual */ nscoord
 68481: nsSVGOuterSVGFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
  8142: {
  8142:   nscoord result;
  8142:   DISPLAY_MIN_WIDTH(this, result);
  8142: 
  8142:   result = nscoord(0);
  8142: 
  8142:   return result;
  8142: }
  8142: 
  8142: /* virtual */ nscoord
 68481: nsSVGOuterSVGFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
  8142: {
  8142:   nscoord result;
  8142:   DISPLAY_PREF_WIDTH(this, result);
  8142: 
  8142:   nsSVGSVGElement *svg = static_cast<nsSVGSVGElement*>(mContent);
  8142:   nsSVGLength2 &width = svg->mLengthAttributes[nsSVGSVGElement::WIDTH];
  8142: 
 10661:   if (width.IsPercentage()) {
 11418:     // It looks like our containing block's width may depend on our width. In
 11418:     // that case our behavior is undefined according to CSS 2.1 section 10.3.2,
 11418:     // so return zero.
 11418:     result = nscoord(0);
  8142:   } else {
  8142:     result = nsPresContext::CSSPixelsToAppUnits(width.GetAnimValue(svg));
 10660:     if (result < 0) {
 10660:       result = nscoord(0);
 10660:     }
  8142:   }
  8142: 
  8142:   return result;
  8142: }
  8142: 
  8142: /* virtual */ nsIFrame::IntrinsicSize
  8142: nsSVGOuterSVGFrame::GetIntrinsicSize()
  8142: {
  8142:   // XXXjwatt Note that here we want to return the CSS width/height if they're
  8142:   // specified and we're embedded inside an nsIObjectLoadingContent.
  8142: 
  8142:   IntrinsicSize intrinsicSize;
  8142: 
  8142:   nsSVGSVGElement *content = static_cast<nsSVGSVGElement*>(mContent);
  8142:   nsSVGLength2 &width  = content->mLengthAttributes[nsSVGSVGElement::WIDTH];
  8142:   nsSVGLength2 &height = content->mLengthAttributes[nsSVGSVGElement::HEIGHT];
  8142: 
 71654:   if (!width.IsPercentage()) {
  8142:     nscoord val = nsPresContext::CSSPixelsToAppUnits(width.GetAnimValue(content));
  8142:     if (val < 0) val = 0;
  8142:     intrinsicSize.width.SetCoordValue(val);
  8142:   }
  8142: 
 71654:   if (!height.IsPercentage()) {
  8142:     nscoord val = nsPresContext::CSSPixelsToAppUnits(height.GetAnimValue(content));
  8142:     if (val < 0) val = 0;
  8142:     intrinsicSize.height.SetCoordValue(val);
  8142:   }
  8142: 
  8142:   return intrinsicSize;
  8142: }
  8142: 
  8142: /* virtual */ nsSize
  8142: nsSVGOuterSVGFrame::GetIntrinsicRatio()
  8142: {
  8142:   // We only have an intrinsic size/ratio if our width and height attributes
  8142:   // are both specified and set to non-percentage values, or we have a viewBox
  8142:   // rect: http://www.w3.org/TR/SVGMobile12/coords.html#IntrinsicSizing
  8142: 
  8142:   nsSVGSVGElement *content = static_cast<nsSVGSVGElement*>(mContent);
  8142:   nsSVGLength2 &width  = content->mLengthAttributes[nsSVGSVGElement::WIDTH];
  8142:   nsSVGLength2 &height = content->mLengthAttributes[nsSVGSVGElement::HEIGHT];
  8142: 
 10661:   if (!width.IsPercentage() && !height.IsPercentage()) {
 71725:     nsSize ratio(NSToCoordRoundWithClamp(width.GetAnimValue(content)),
 71725:                  NSToCoordRoundWithClamp(height.GetAnimValue(content)));
 10660:     if (ratio.width < 0) {
 10660:       ratio.width = 0;
 10660:     }
 10660:     if (ratio.height < 0) {
 10660:       ratio.height = 0;
 10660:     }
 10660:     return ratio;
  8142:   }
  8142: 
 97650:   if (content->HasViewBox()) {
 38700:     const nsSVGViewBoxRect viewbox = content->mViewBox.GetAnimValue();
 24554:     float viewBoxWidth = viewbox.width;
 24554:     float viewBoxHeight = viewbox.height;
 24554: 
 12023:     if (viewBoxWidth < 0.0f) {
 12023:       viewBoxWidth = 0.0f;
 12023:     }
 12023:     if (viewBoxHeight < 0.0f) {
 12023:       viewBoxHeight = 0.0f;
 12023:     }
 71725:     return nsSize(NSToCoordRoundWithClamp(viewBoxWidth),
 71725:                   NSToCoordRoundWithClamp(viewBoxHeight));
  8142:   }
  8142: 
  8142:   return nsSVGOuterSVGFrameBase::GetIntrinsicRatio();
  8142: }
  8142: 
  8142: /* virtual */ nsSize
 68481: nsSVGOuterSVGFrame::ComputeSize(nsRenderingContext *aRenderingContext,
  8142:                                 nsSize aCBSize, nscoord aAvailableWidth,
  8142:                                 nsSize aMargin, nsSize aBorder, nsSize aPadding,
108991:                                 uint32_t aFlags)
  8142: {
 97649:   if (IsRootOfImage() || IsRootOfReplacedElementSubDoc()) {
 97649:     // The embedding element has sized itself using the CSS replaced element
 97649:     // sizing rules, using our intrinsic dimensions as necessary. The SVG spec
 97649:     // says that the width and height of embedded SVG is overridden by the
 97649:     // width and height of the embedding element, so we just need to size to
 97649:     // the viewport that the embedding element has established for us.
 97649:     return aCBSize;
 97649:   }
 62244: 
 97649:   nsSize cbSize = aCBSize;
 71654:   IntrinsicSize intrinsicSize = GetIntrinsicSize();
 71654: 
 71654:   if (!mContent->GetParent()) {
 97649:     // We're the root of the outermost browsing context, so we need to scale
 97649:     // cbSize by the full-zoom so that SVGs with percentage width/height zoom:
 97649: 
 97649:     NS_ASSERTION(aCBSize.width  != NS_AUTOHEIGHT &&
 97649:                  aCBSize.height != NS_AUTOHEIGHT,
 97649:                  "root should not have auto-width/height containing block");
 97649:     cbSize.width  *= PresContext()->GetFullZoom();
 97649:     cbSize.height *= PresContext()->GetFullZoom();
 97649: 
 97649:     // We also need to honour the width and height attributes' default values
 97649:     // of 100% when we're the root of a browsing context.  (GetIntrinsicSize()
 97649:     // doesn't report these since there's no such thing as a percentage
 97649:     // intrinsic size.  Also note that explicit percentage values are mapped
 97649:     // into style, so the following isn't for them.)
 97649: 
 97649:     nsSVGSVGElement* content = static_cast<nsSVGSVGElement*>(mContent);
 97649: 
 71654:     nsSVGLength2 &width =
 71654:       content->mLengthAttributes[nsSVGSVGElement::WIDTH];
 71654:     if (width.IsPercentage()) {
 71654:       NS_ABORT_IF_FALSE(intrinsicSize.width.GetUnit() == eStyleUnit_None,
 71654:                         "GetIntrinsicSize should have reported no "
 71654:                         "intrinsic width");
 71654:       float val = width.GetAnimValInSpecifiedUnits() / 100.0f;
 71654:       if (val < 0.0f) val = 0.0f;
 97649:       intrinsicSize.width.SetCoordValue(val * cbSize.width);
 71654:     }
 71654: 
 71654:     nsSVGLength2 &height =
 71654:       content->mLengthAttributes[nsSVGSVGElement::HEIGHT];
 81432:     NS_ASSERTION(aCBSize.height != NS_AUTOHEIGHT,
 71654:                  "root should not have auto-height containing block");
 71654:     if (height.IsPercentage()) {
 71654:       NS_ABORT_IF_FALSE(intrinsicSize.height.GetUnit() == eStyleUnit_None,
 71654:                         "GetIntrinsicSize should have reported no "
 71654:                         "intrinsic height");
 71654:       float val = height.GetAnimValInSpecifiedUnits() / 100.0f;
 71654:       if (val < 0.0f) val = 0.0f;
 97649:       intrinsicSize.height.SetCoordValue(val * cbSize.height);
 71654:     }
 71654:     NS_ABORT_IF_FALSE(intrinsicSize.height.GetUnit() == eStyleUnit_Coord &&
 71654:                       intrinsicSize.width.GetUnit() == eStyleUnit_Coord,
 71654:                       "We should have just handled the only situation where"
 71654:                       "we lack an intrinsic height or width.");
 71654:   }
  8142: 
  8142:   return nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(
  8142:                             aRenderingContext, this,
 97649:                             intrinsicSize, GetIntrinsicRatio(), cbSize,
  8142:                             aMargin, aBorder, aPadding);
  8142: }
  8142: 
     1: NS_IMETHODIMP
     1: nsSVGOuterSVGFrame::Reflow(nsPresContext*           aPresContext,
     1:                            nsHTMLReflowMetrics&     aDesiredSize,
     1:                            const nsHTMLReflowState& aReflowState,
     1:                            nsReflowStatus&          aStatus)
     1: {
  8142:   DO_GLOBAL_REFLOW_COUNT("nsSVGOuterSVGFrame");
  8142:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
  8142:   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
  8142:                   ("enter nsSVGOuterSVGFrame::Reflow: availSize=%d,%d",
  8142:                   aReflowState.availableWidth, aReflowState.availableHeight));
  8142: 
  8142:   NS_PRECONDITION(mState & NS_FRAME_IN_REFLOW, "frame is not in reflow");
  8142: 
     1:   aStatus = NS_FRAME_COMPLETE;
     1: 
  8142:   aDesiredSize.width  = aReflowState.ComputedWidth() +
  8142:                           aReflowState.mComputedBorderPadding.LeftRight();
  8142:   aDesiredSize.height = aReflowState.ComputedHeight() +
  8142:                           aReflowState.mComputedBorderPadding.TopBottom();
     1: 
  8142:   NS_ASSERTION(!GetPrevInFlow(), "SVG can't currently be broken across pages.");
     1: 
105956:   nsSVGSVGElement *svgElem = static_cast<nsSVGSVGElement*>(mContent);
105956: 
105956:   nsSVGOuterSVGAnonChildFrame *anonKid =
105956:     static_cast<nsSVGOuterSVGAnonChildFrame*>(GetFirstPrincipalChild());
105956: 
105956:   if (mState & NS_FRAME_FIRST_REFLOW) {
105956:     // Initialize
105956:     svgElem->mHasChildrenOnlyTransform =
106838:       anonKid->HasChildrenOnlyTransform(nullptr);
105956:   }
105956: 
  8142:   // If our SVG viewport has changed, update our content and notify.
  8142:   // http://www.w3.org/TR/SVG11/coords.html#ViewportSpace
     1: 
  8142:   svgFloatSize newViewportSize(
  8142:     nsPresContext::AppUnitsToFloatCSSPixels(aReflowState.ComputedWidth()),
  8142:     nsPresContext::AppUnitsToFloatCSSPixels(aReflowState.ComputedHeight()));
  8142: 
108991:   uint32_t changeBits = 0;
 97651:   if (newViewportSize != svgElem->GetViewportSize()) {
 97651:     changeBits |= COORD_CONTEXT_CHANGED;
  8142:     svgElem->SetViewportSize(newViewportSize);
 97651:   }
 97651:   if (mFullZoom != PresContext()->GetFullZoom()) {
 98711:     changeBits |= FULL_ZOOM_CHANGED;
 97651:     mFullZoom = PresContext()->GetFullZoom();
 97651:   }
 80486:   mViewportInitialized = true;
 97651:   if (changeBits) {
 97651:     NotifyViewportOrTransformChanged(changeBits);
  2407:   }
     1: 
103952:   if (!(GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
 98624:     // Now that we've marked the necessary children as dirty, call
106052:     // ReflowSVG() on them:
 93573: 
106052:     mCallingReflowSVG = true;
 93574: 
103952:     // Update the mRects and visual overflow rects of all our descendants,
103952:     // including our anonymous wrapper kid:
106052:     anonKid->ReflowSVG();
103952:     NS_ABORT_IF_FALSE(!anonKid->GetNextSibling(),
103952:       "We should have one anonymous child frame wrapping our real children");
     1: 
106052:     mCallingReflowSVG = false;
103952:   }
 93574: 
 98624:   // Make sure we scroll if we're too big:
 98624:   // XXX Use the bounding box of our descendants? (See bug 353460 comment 14.)
 98624:   aDesiredSize.SetOverflowAreasToDesiredBounds();
 98624:   FinishAndStoreOverflow(&aDesiredSize);
 98624: 
103952:   // Set our anonymous kid's offset from our border box:
103952:   anonKid->SetPosition(GetContentRectRelativeToSelf().TopLeft());
103952: 
 98624:   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
 98624:                   ("exit nsSVGOuterSVGFrame::Reflow: size=%d,%d",
 98624:                   aDesiredSize.width, aDesiredSize.height));
 98624:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
 98624:   return NS_OK;
  8210: }
 93574: 
 98624: NS_IMETHODIMP
 98624: nsSVGOuterSVGFrame::DidReflow(nsPresContext*   aPresContext,
 98624:                               const nsHTMLReflowState*  aReflowState,
 98624:                               nsDidReflowStatus aStatus)
 98624: {
 98624:   nsresult rv = nsSVGOuterSVGFrameBase::DidReflow(aPresContext,aReflowState,aStatus);
 98624: 
 93574:   // Make sure elements styled by :hover get updated if script/animation moves
 93574:   // them under or out from under the pointer:
 93574:   PresContext()->PresShell()->SynthesizeMouseMove(false);
     1: 
     1:   return rv;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // container methods
     1: 
105956: /**
105956:  * Used to paint/hit-test SVG when SVG display lists are disabled.
105956:  */
103175: class nsDisplayOuterSVG : public nsDisplayItem {
     1: public:
103175:   nsDisplayOuterSVG(nsDisplayListBuilder* aBuilder,
 51260:                     nsSVGOuterSVGFrame* aFrame) :
 51260:     nsDisplayItem(aBuilder, aFrame) {
103175:     MOZ_COUNT_CTOR(nsDisplayOuterSVG);
     1:   }
     1: #ifdef NS_BUILD_REFCNT_LOGGING
103175:   virtual ~nsDisplayOuterSVG() {
103175:     MOZ_COUNT_DTOR(nsDisplayOuterSVG);
     1:   }
     1: #endif
     1: 
 40570:   virtual void HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
 40570:                        HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames);
 33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
 68481:                      nsRenderingContext* aCtx);
103175:   NS_DISPLAY_DECL_NAME("SVGOuterSVG", TYPE_SVG_OUTER_SVG)
     1: };
     1: 
 40570: void
103175: nsDisplayOuterSVG::HitTest(nsDisplayListBuilder* aBuilder, const nsRect& aRect,
 40570:                            HitTestState* aState, nsTArray<nsIFrame*> *aOutFrames)
     1: {
 42235:   nsSVGOuterSVGFrame *outerSVGFrame = static_cast<nsSVGOuterSVGFrame*>(mFrame);
 51261:   nsRect rectAtOrigin = aRect - ToReferenceFrame();
 42235:   nsRect thisRect(nsPoint(0,0), outerSVGFrame->GetSize());
 40570:   if (!thisRect.Intersects(rectAtOrigin))
 40570:     return;
 40570: 
 40570:   nsPoint rectCenter(rectAtOrigin.x + rectAtOrigin.width / 2,
 40570:                      rectAtOrigin.y + rectAtOrigin.height / 2);
 40570: 
103952:   nsSVGOuterSVGAnonChildFrame *anonKid =
103952:     static_cast<nsSVGOuterSVGAnonChildFrame*>(
103952:       outerSVGFrame->GetFirstPrincipalChild());
 42235:   nsIFrame* frame = nsSVGUtils::HitTestChildren(
103952:     anonKid, rectCenter + outerSVGFrame->GetPosition() -
 42235:                outerSVGFrame->GetContentRect().TopLeft());
 40570:   if (frame) {
 40570:     aOutFrames->AppendElement(frame);
 40570:   }
     1: }
     1: 
     1: void
103175: nsDisplayOuterSVG::Paint(nsDisplayListBuilder* aBuilder,
 91453:                          nsRenderingContext* aContext)
     1: {
 91453: #if defined(DEBUG) && defined(SVG_DEBUG_PAINT_TIMING)
 91453:   PRTime start = PR_Now();
 91453: #endif
 91453: 
103708:   // Create an SVGAutoRenderState so we can call SetPaintingToWindow on
103708:   // it, but do so without changing the render mode:
103708:   SVGAutoRenderState state(aContext, SVGAutoRenderState::GetRenderMode(aContext));
103708: 
103708:   if (aBuilder->IsPaintingToWindow()) {
103708:     state.SetPaintingToWindow(true);
103708:   }
103708: 
103707:   nsRect viewportRect =
103707:     mFrame->GetContentRectRelativeToSelf() + ToReferenceFrame();
 91453: 
103176:   nsRect clipRect = mVisibleRect.Intersect(viewportRect);
103176: 
103708:   nsIntRect contentAreaDirtyRect =
103708:     (clipRect - viewportRect.TopLeft()).
103708:       ToOutsidePixels(mFrame->PresContext()->AppUnitsPerDevPixel());
103708: 
103707:   aContext->PushState();
103176:   aContext->Translate(viewportRect.TopLeft());
103708:   nsSVGUtils::PaintFrameWithEffects(aContext, &contentAreaDirtyRect, mFrame);
103707:   aContext->PopState();
103176: 
103707:   NS_ASSERTION(!aContext->ThebesContext()->HasError(), "Cairo in error state");
 91453: 
 91453: #if defined(DEBUG) && defined(SVG_DEBUG_PAINT_TIMING)
 91453:   PRTime end = PR_Now();
 91453:   printf("SVG Paint Timing: %f ms\n", (end-start)/1000.0);
 91453: #endif
     1: }
     1: 
  8142: // helper
 79445: static inline bool
  8142: DependsOnIntrinsicSize(const nsIFrame* aEmbeddingFrame)
  8142: {
  8142:   const nsStylePosition *pos = aEmbeddingFrame->GetStylePosition();
 49566:   const nsStyleCoord &width = pos->mWidth;
 49566:   const nsStyleCoord &height = pos->mHeight;
  8142: 
  8142:   // XXX it would be nice to know if the size of aEmbeddingFrame's containing
  8142:   // block depends on aEmbeddingFrame, then we'd know if we can return false
  8142:   // for eStyleUnit_Percent too.
 51405:   return !width.ConvertsToLength() ||
 51405:          !height.ConvertsToLength();
  8142: }
  8142: 
     1: NS_IMETHODIMP
108991: nsSVGOuterSVGFrame::AttributeChanged(int32_t  aNameSpaceID,
     1:                                      nsIAtom* aAttribute,
108991:                                      int32_t  aModType)
     1: {
     1:   if (aNameSpaceID == kNameSpaceID_None &&
108404:       !(GetStateBits() & (NS_FRAME_FIRST_REFLOW | NS_STATE_SVG_NONDISPLAY_CHILD))) {
 79554:     if (aAttribute == nsGkAtoms::viewBox ||
 79554:         aAttribute == nsGkAtoms::preserveAspectRatio ||
 79554:         aAttribute == nsGkAtoms::transform) {
 79554: 
 79554:       // make sure our cached transform matrix gets (lazily) updated
106838:       mCanvasTM = nullptr;
 79554: 
103952:       nsSVGUtils::NotifyChildrenOfSVGChange(GetFirstPrincipalChild(),
103952:                 aAttribute == nsGkAtoms::viewBox ?
 79554:                   TRANSFORM_CHANGED | COORD_CONTEXT_CHANGED : TRANSFORM_CHANGED);
 79554: 
 98711:       static_cast<nsSVGSVGElement*>(mContent)->ChildrenOnlyTransformChanged();
 98711: 
 79554:     } else if (aAttribute == nsGkAtoms::width ||
 79554:                aAttribute == nsGkAtoms::height) {
 79554: 
 98711:       // Don't call ChildrenOnlyTransformChanged() here, since we call it
 98711:       // under Reflow if the width/height actually changed.
 98711: 
  8142:       nsIFrame* embeddingFrame;
 62244:       if (IsRootOfReplacedElementSubDoc(&embeddingFrame) && embeddingFrame) {
  8142:         if (DependsOnIntrinsicSize(embeddingFrame)) {
  8142:           // Tell embeddingFrame's presShell it needs to be reflowed (which takes
  8142:           // care of reflowing us too).
  8142:           embeddingFrame->PresContext()->PresShell()->
  8142:             FrameNeedsReflow(embeddingFrame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
  8142:         }
  8142:         // else our width and height is overridden - don't reflow anything
  8142:       } else {
  8142:         // We are not embedded by reference, so our 'width' and 'height'
  8142:         // attributes are not overridden - we need to reflow.
   238:         PresContext()->PresShell()->
  1158:           FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
     1:       }
  8142:     }
 79554:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // painting
     1: 
     1: NS_IMETHODIMP
     1: nsSVGOuterSVGFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                                      const nsRect&           aDirtyRect,
     1:                                      const nsDisplayListSet& aLists)
     1: {
103176:   if (GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD) {
103176:     return NS_OK;
103176:   }
103176: 
  8142:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
  8142:   NS_ENSURE_SUCCESS(rv, rv);
  8142: 
103821:   nsDisplayList childItems;
101757: 
105956:   if ((aBuilder->IsForEventDelivery() &&
105956:        NS_SVGDisplayListHitTestingEnabled()) ||
105956:       NS_SVGDisplayListPaintingEnabled()) {
105956:     nsDisplayList *nonContentList = &childItems;
105956:     nsDisplayListSet set(nonContentList, nonContentList, nonContentList,
105956:                          &childItems, nonContentList, nonContentList);
105956:     nsresult rv =
105956:       BuildDisplayListForNonBlockChildren(aBuilder, aDirtyRect, set);
105956:     NS_ENSURE_SUCCESS(rv, rv);
105956:   } else {
103821:     rv = childItems.AppendNewToTop(
103175:            new (aBuilder) nsDisplayOuterSVG(aBuilder, this));
101757:     NS_ENSURE_SUCCESS(rv, rv);
105956:   }
101757: 
103821:   // Clip to our _content_ box:
103821:   nsRect clipRect =
103821:     GetContentRectRelativeToSelf() + aBuilder->ToReferenceFrame(this);
103821:   nsDisplayClip* item =
103821:     new (aBuilder) nsDisplayClip(aBuilder, this, &childItems, clipRect);
103821:   rv = childItems.AppendNewToTop(item);
103821:   NS_ENSURE_SUCCESS(rv, rv);
103821: 
103821:   WrapReplacedContentForBorderRadius(aBuilder, &childItems, aLists);
101757: 
101757:   return NS_OK;
     1: }
     1: 
 12087: nsSplittableType
 12087: nsSVGOuterSVGFrame::GetSplittableType() const
 12087: {
 12087:   return NS_FRAME_NOT_SPLITTABLE;
 12087: }
 12087: 
     1: nsIAtom *
     1: nsSVGOuterSVGFrame::GetType() const
     1: {
     1:   return nsGkAtoms::svgOuterSVGFrame;
     1: }
     1: 
     1: //----------------------------------------------------------------------
 89454: // nsISVGSVGFrame methods:
     1: 
 13316: void
108991: nsSVGOuterSVGFrame::NotifyViewportOrTransformChanged(uint32_t aFlags)
     1: {
 97651:   NS_ABORT_IF_FALSE(aFlags &&
 98711:                     !(aFlags & ~(COORD_CONTEXT_CHANGED | TRANSFORM_CHANGED |
 98711:                                  FULL_ZOOM_CHANGED)),
 97651:                     "Unexpected aFlags value");
 97651: 
 97651:   // No point in doing anything when were not init'ed yet:
 10661:   if (!mViewportInitialized) {
 89454:     return;
  2407:   }
  2407: 
 97651:   nsSVGSVGElement *content = static_cast<nsSVGSVGElement*>(mContent);
 10661: 
 97651:   if (aFlags & COORD_CONTEXT_CHANGED) {
 97651:     if (content->HasViewBox() || content->ShouldSynthesizeViewBox()) {
 97651:       // Percentage lengths on children resolve against the viewBox rect so we
 97651:       // don't need to notify them of the viewport change, but the viewBox
 97651:       // transform will have changed, so we need to notify them of that instead.
 97651:       aFlags = TRANSFORM_CHANGED;
 97651:     }
 97651:     else if (mCanvasTM && mCanvasTM->IsSingular()) {
 97651:       // A width/height of zero will result in us having a singular mCanvasTM
 97651:       // even when we don't have a viewBox. So we also want to recompute our
 97651:       // mCanvasTM for this width/height change even though we don't have a
 97651:       // viewBox.
 97651:       aFlags |= TRANSFORM_CHANGED;
 97651:     }
 10661:   }
 10661: 
 98711:   bool haveNonFulLZoomTransformChange = (aFlags & TRANSFORM_CHANGED);
 98711: 
 98711:   if (aFlags & FULL_ZOOM_CHANGED) {
 98711:     // Convert FULL_ZOOM_CHANGED to TRANSFORM_CHANGED:
 98711:     aFlags = (aFlags & ~FULL_ZOOM_CHANGED) | TRANSFORM_CHANGED;
 98711:   }
 98711: 
 97651:   if (aFlags & TRANSFORM_CHANGED) {
 97651:     // Make sure our canvas transform matrix gets (lazily) recalculated:
106838:     mCanvasTM = nullptr;
 98711: 
 98711:     if (haveNonFulLZoomTransformChange &&
 98711:         !(mState & NS_STATE_SVG_NONDISPLAY_CHILD)) {
110877:       PRUint32 flags = (mState & NS_FRAME_IN_REFLOW) ?
110877:                          nsSVGSVGElement::eDuringReflow : 0;
110877:       content->ChildrenOnlyTransformChanged(flags);
 98711:     }
 97651:   }
 97651: 
103952:   nsSVGUtils::NotifyChildrenOfSVGChange(GetFirstPrincipalChild(), aFlags);
103952: }
103952: 
103952: //----------------------------------------------------------------------
103952: // nsISVGChildFrame methods:
103952: 
103952: NS_IMETHODIMP
103952: nsSVGOuterSVGFrame::PaintSVG(nsRenderingContext* aContext,
103952:                              const nsIntRect *aDirtyRect)
103952: {
103952:   NS_ASSERTION(GetFirstPrincipalChild()->GetType() ==
103952:                  nsGkAtoms::svgOuterSVGAnonChildFrame &&
103952:                !GetFirstPrincipalChild()->GetNextSibling(),
103952:                "We should have a single, anonymous, child");
103952:   nsSVGOuterSVGAnonChildFrame *anonKid =
103952:     static_cast<nsSVGOuterSVGAnonChildFrame*>(GetFirstPrincipalChild());
103952:   return anonKid->PaintSVG(aContext, aDirtyRect);
103952: }
103952: 
103952: SVGBBox
103952: nsSVGOuterSVGFrame::GetBBoxContribution(const gfxMatrix &aToBBoxUserspace,
108991:                                         uint32_t aFlags)
103952: {
103952:   NS_ASSERTION(GetFirstPrincipalChild()->GetType() ==
103952:                  nsGkAtoms::svgOuterSVGAnonChildFrame &&
103952:                !GetFirstPrincipalChild()->GetNextSibling(),
103952:                "We should have a single, anonymous, child");
103952:   // We must defer to our child so that we don't include our
103952:   // content->PrependLocalTransformsTo() transforms.
103952:   nsSVGOuterSVGAnonChildFrame *anonKid =
103952:     static_cast<nsSVGOuterSVGAnonChildFrame*>(GetFirstPrincipalChild());
103952:   return anonKid->GetBBoxContribution(aToBBoxUserspace, aFlags);
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // nsSVGContainerFrame methods:
     1: 
 27899: gfxMatrix
108991: nsSVGOuterSVGFrame::GetCanvasTM(uint32_t aFor)
     1: {
103332:   if (!(GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
103332:     if ((aFor == FOR_PAINTING && NS_SVGDisplayListPaintingEnabled()) ||
103332:         (aFor == FOR_HIT_TESTING && NS_SVGDisplayListHitTestingEnabled())) {
103332:       return nsSVGIntegrationUtils::GetCSSPxToDevPxMatrix(this);
103332:     }
103332:   }
     1:   if (!mCanvasTM) {
 30596:     nsSVGSVGElement *content = static_cast<nsSVGSVGElement*>(mContent);
  8640: 
  8640:     float devPxPerCSSPx =
 30596:       1.0f / PresContext()->AppUnitsToFloatCSSPixels(
  8640:                                 PresContext()->AppUnitsPerDevPixel());
  9538: 
 98726:     gfxMatrix tm = content->PrependLocalTransformsTo(
 98726:                      gfxMatrix().Scale(devPxPerCSSPx, devPxPerCSSPx));
 98726:     mCanvasTM = new gfxMatrix(tm);
     1:   }
 78868:   return *mCanvasTM;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: // Implementation helpers
     1: 
 79445: bool
 62244: nsSVGOuterSVGFrame::IsRootOfReplacedElementSubDoc(nsIFrame **aEmbeddingFrame)
     1: {
 52220:   if (!mContent->GetParent()) {
  8142:     // Our content is the document element
  8142:     nsCOMPtr<nsISupports> container = PresContext()->GetContainer();
 73870:     nsCOMPtr<nsIDOMWindow> window = do_GetInterface(container);
  8142:     if (window) {
  8142:       nsCOMPtr<nsIDOMElement> frameElement;
  8142:       window->GetFrameElement(getter_AddRefs(frameElement));
  8142:       nsCOMPtr<nsIObjectLoadingContent> olc = do_QueryInterface(frameElement);
  8142:       if (olc) {
  8142:         // Our document is inside an HTML 'object', 'embed' or 'applet' element
  8142:         if (aEmbeddingFrame) {
  8142:           nsCOMPtr<nsIContent> element = do_QueryInterface(frameElement);
  8142:           *aEmbeddingFrame =
  8142:             static_cast<nsGenericElement*>(element.get())->GetPrimaryFrame();
  8142:           NS_ASSERTION(*aEmbeddingFrame, "Yikes, no embedding frame!");
     1:         }
 80486:         return true;
  8142:       }
  8142:     }
  8142:   }
  8142:   if (aEmbeddingFrame) {
106838:     *aEmbeddingFrame = nullptr;
  8142:   }
 80486:   return false;
  8142: }
 52220: 
 79445: bool
 52220: nsSVGOuterSVGFrame::IsRootOfImage()
 52220: {
 52220:   if (!mContent->GetParent()) {
 52220:     // Our content is the document element
 52220:     nsIDocument* doc = mContent->GetCurrentDoc();
 52220:     if (doc && doc->IsBeingUsedAsImage()) {
 52220:       // Our document is being used as an image
 80486:       return true;
 52220:     }
 52220:   }
 52220: 
 80486:   return false;
 52220: }
 93449: 
 93449: bool
 93449: nsSVGOuterSVGFrame::VerticalScrollbarNotNeeded() const
 93449: {
 93449:   nsSVGLength2 &height = static_cast<nsSVGSVGElement*>(mContent)->
 93449:                            mLengthAttributes[nsSVGSVGElement::HEIGHT];
 93449:   return height.IsPercentage() && height.GetBaseValInSpecifiedUnits() <= 100;
 93449: }
103952: 
103952: 
103952: //----------------------------------------------------------------------
103952: // Implementation of nsSVGOuterSVGAnonChildFrame
103952: 
103952: nsIFrame*
103952: NS_NewSVGOuterSVGAnonChildFrame(nsIPresShell* aPresShell,
103952:                                 nsStyleContext* aContext)
103952: {
103952:   return new (aPresShell) nsSVGOuterSVGAnonChildFrame(aContext);
103952: }
103952: 
103952: NS_IMPL_FRAMEARENA_HELPERS(nsSVGOuterSVGAnonChildFrame)
103952: 
103952: #ifdef DEBUG
103952: NS_IMETHODIMP
103952: nsSVGOuterSVGAnonChildFrame::Init(nsIContent* aContent,
103952:                                   nsIFrame* aParent,
103952:                                   nsIFrame* aPrevInFlow)
103952: {
103952:   NS_ABORT_IF_FALSE(aParent->GetType() == nsGkAtoms::svgOuterSVGFrame,
103952:                     "Unexpected parent");
103952:   return nsSVGOuterSVGAnonChildFrameBase::Init(aContent, aParent, aPrevInFlow);
103952: }
103952: #endif
103952: 
103952: nsIAtom *
103952: nsSVGOuterSVGAnonChildFrame::GetType() const
103952: {
103952:   return nsGkAtoms::svgOuterSVGAnonChildFrame;
103952: }
103952: 
103952: bool
103952: nsSVGOuterSVGAnonChildFrame::HasChildrenOnlyTransform(gfxMatrix *aTransform) const
103952: {
103952:   // We must claim our nsSVGOuterSVGFrame's children-only transforms as our own
103952:   // so that the children we are used to wrap are transformed properly.
103952: 
103952:   nsSVGSVGElement *content = static_cast<nsSVGSVGElement*>(mContent);
103952: 
103952:   bool hasTransform = content->HasChildrenOnlyTransform();
103952: 
103952:   if (hasTransform && aTransform) {
103952:     // Outer-<svg> doesn't use x/y, so we can pass eChildToUserSpace here.
103952:     gfxMatrix identity;
103952:     *aTransform =
103952:       content->PrependLocalTransformsTo(identity,
103952:                                         nsSVGElement::eChildToUserSpace);
103952:   }
103952: 
103952:   return hasTransform;
103952: }
