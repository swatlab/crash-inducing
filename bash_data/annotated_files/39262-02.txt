38120: #include "base/process_util.h"
38120: 
38120: #include "TestHangs.h"
38120: 
38120: #include "IPDLUnitTests.h"      // fail etc.
38120: 
38120: using base::KillProcess;
38120: 
39262: template<>
39262: struct RunnableMethodTraits<mozilla::_ipdltest::TestHangsParent>
39262: {
39262:     static void RetainCallee(mozilla::_ipdltest::TestHangsParent* obj) { }
39262:     static void ReleaseCallee(mozilla::_ipdltest::TestHangsParent* obj) { }
39262: };
38120: 
38120: namespace mozilla {
38120: namespace _ipdltest {
38120: 
38120: //-----------------------------------------------------------------------------
38120: // parent
38120: 
39262: TestHangsParent::TestHangsParent() : mFramesToGo(2), mDetectedHang(false)
38120: {
38120:     MOZ_COUNT_CTOR(TestHangsParent);
38120: }
38120: 
38120: TestHangsParent::~TestHangsParent()
38120: {
38120:     MOZ_COUNT_DTOR(TestHangsParent);
38120: }
38120: 
38120: void
38120: TestHangsParent::Main()
38120: {
39262:     // Here we try to set things up to test the following sequence of events:
39262:     //
39262:     // - subprocess causes an OnMaybeDequeueOne() task to be posted to
39262:     //   this thread
39262:     //
39262:     // - subprocess hangs just long enough for the hang timer to expire
39262:     //
39262:     // - hang-kill code in the parent starts running
39262:     //
39262:     // - subprocess replies to message while hang code runs
39262:     //
39262:     // - reply is processed in OnMaybeDequeueOne() before Close() has
39262:     //   been called or the channel error notification has been posted
38120: 
39262:     // this tells the subprocess to send us Nonce()
39262:     if (!SendStart())
39262:         fail("sending Start");
39262: 
39262:     // now we sleep here for a while awaiting the Nonce() message from
39262:     // the child.  since we're not blocked on anything, the IO thread
39262:     // will enqueue an OnMaybeDequeueOne() task to process that
39262:     // message
39262:     // 
39262:     // NB: PR_Sleep is exactly what we want, only the current thread
39262:     // sleeping
39262:     PR_Sleep(5000);
39262: 
39262:     // when we call into this, we'll pull the Nonce() message out of
39262:     // the mPending queue, but that doesn't matter ... the
39262:     // OnMaybeDequeueOne() event will remain
39262:     if (CallStackFrame() && mDetectedHang)
38120:         fail("should have timed out!");
38120: 
39262:     // the Close() task in the queue will shut us down
38120: }
38120: 
38120: bool
38120: TestHangsParent::ShouldContinueFromReplyTimeout()
38120: {
39262:     mDetectedHang = true;
38120: 
39262:     // so we've detected a timeout after 1 ms ... now we cheat and
39262:     // sleep for a long time, to allow the subprocess's reply to come
39262:     // in
39262: 
39262:     PR_Sleep(5000);
39262: 
39262:     // reply should be here; we'll post a task to shut things down.
39262:     // This must be after OnMaybeDequeueOne() in the event queue.
39262:     MessageLoop::current()->PostTask(
39262:         FROM_HERE, NewRunnableMethod(this, &TestHangsParent::CleanUp));
38120: 
38120:     return false;
38120: }
38120: 
38120: bool
38120: TestHangsParent::AnswerStackFrame()
38120: {
38120:     if (--mFramesToGo) {
38120:         if (CallStackFrame())
38120:             fail("should have timed out!");
38120:     }
38120:     else {
39262:         // minimum possible, 1 ms.  We want to detecting a hang to race
39262:         // with the reply coming in, as reliably as possible
39262:         SetReplyTimeoutMs(1);
39262: 
38120:         if (CallHang())
38120:             fail("should have timed out!");
38120:     }
38120: 
38120:     return true;
38120: }
38120: 
39262: void
39262: TestHangsParent::CleanUp()
39262: {
39262:     if (!KillProcess(OtherProcess(), 0, false))
39262:         fail("terminating child process");
39262:     Close();
39262: }
39262: 
38120: 
38120: //-----------------------------------------------------------------------------
38120: // child
38120: 
38120: TestHangsChild::TestHangsChild()
38120: {
38120:     MOZ_COUNT_CTOR(TestHangsChild);
38120: }
38120: 
38120: TestHangsChild::~TestHangsChild()
38120: {
38120:     MOZ_COUNT_DTOR(TestHangsChild);
38120: }
38120: 
38120: bool
38120: TestHangsChild::AnswerHang()
38120: {
39262:     puts(" (child process is 'hanging' now)");
38120: 
39262:     // just sleep until we're reasonably confident the 1ms hang
39262:     // detector fired in the parent process and it's sleeping in
39262:     // ShouldContinueFromReplyTimeout()
39262:     PR_Sleep(1000);
38120: 
39262:     return true;
38120: }
38120: 
38120: } // namespace _ipdltest
38120: } // namespace mozilla
