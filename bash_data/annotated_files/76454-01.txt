74337: /* -*- Mode: c++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 40 -*- */
76372: /* vim: set ts=2 et sw=2 tw=80: */
74337: /* ***** BEGIN LICENSE BLOCK *****
74337:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
74337:  *
74337:  * The contents of this file are subject to the Mozilla Public License Version
74337:  * 1.1 (the "License"); you may not use this file except in compliance with
74337:  * the License. You may obtain a copy of the License at
74337:  * http://www.mozilla.org/MPL/
74337:  *
74337:  * Software distributed under the License is distributed on an "AS IS" basis,
74337:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
74337:  * for the specific language governing rights and limitations under the
74337:  * License.
74337:  *
74337:  * The Original Code is Web Workers.
74337:  *
74337:  * The Initial Developer of the Original Code is
74337:  *   The Mozilla Foundation.
74337:  * Portions created by the Initial Developer are Copyright (C) 2011
74337:  * the Initial Developer. All Rights Reserved.
74337:  *
74337:  * Contributor(s):
74337:  *   Ben Turner <bent.mozilla@gmail.com> (Original Author)
74337:  *
74337:  * Alternatively, the contents of this file may be used under the terms of
74337:  * either the GNU General Public License Version 2 or later (the "GPL"), or
74337:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
74337:  * in which case the provisions of the GPL or the LGPL are applicable instead
74337:  * of those above. If you wish to allow use of your version of this file only
74337:  * under the terms of either the GPL or the LGPL, and not to allow others to
74337:  * use your version of this file under the terms of the MPL, indicate your
74337:  * decision by deleting the provisions above and replace them with the notice
74337:  * and other provisions required by the GPL or the LGPL. If you do not delete
74337:  * the provisions above, a recipient may use your version of this file under
74337:  * the terms of any one of the MPL, the GPL or the LGPL.
74337:  *
74337:  * ***** END LICENSE BLOCK ***** */
74337: 
74337: #include "WorkerPrivate.h"
74337: 
74337: #include "nsIClassInfo.h"
74337: #include "nsIConsoleService.h"
76372: #include "nsIDOMFile.h"
74337: #include "nsIDocument.h"
74337: #include "nsIEffectiveTLDService.h"
74337: #include "nsIJSContextStack.h"
74337: #include "nsIScriptError.h"
74337: #include "nsIScriptGlobalObject.h"
74337: #include "nsIScriptSecurityManager.h"
74337: #include "nsPIDOMWindow.h"
74337: #include "nsITextToSubURI.h"
74337: #include "nsITimer.h"
74337: #include "nsIURI.h"
74337: #include "nsIURL.h"
74337: #include "nsIXPConnect.h"
74337: 
74337: #include "jscntxt.h"
74337: #include "jsdbgapi.h"
74337: #include "nsAlgorithm.h"
74337: #include "nsContentUtils.h"
74337: #include "nsDOMClassInfo.h"
74337: #include "nsDOMJSUtils.h"
74337: #include "nsGUIEvent.h"
74337: #include "nsJSEnvironment.h"
74337: #include "nsJSUtils.h"
74337: #include "nsNetUtil.h"
74337: #include "nsThreadUtils.h"
75066: #include "xpcpublic.h"
74337: 
74337: #include "Events.h"
74337: #include "Exceptions.h"
76372: #include "File.h"
74337: #include "Principal.h"
74337: #include "RuntimeService.h"
74337: #include "ScriptLoader.h"
74337: #include "WorkerFeature.h"
74337: #include "WorkerScope.h"
74337: 
74337: #include "WorkerInlines.h"
74337: 
74337: #if 0 // Define to run GC more often.
74337: #define EXTRA_GC
74337: #endif
74337: 
74337: using mozilla::MutexAutoLock;
74337: using mozilla::TimeDuration;
74337: using mozilla::TimeStamp;
74337: using mozilla::dom::workers::exceptions::ThrowDOMExceptionForCode;
75066: using mozilla::xpconnect::memory::IterateData;
74337: 
74337: USING_WORKERS_NAMESPACE
74337: 
74337: namespace {
74337: 
74337: const char gErrorChars[] = "error";
74337: const char gMessageChars[] = "message";
74337: 
74337: template <class T>
74337: class AutoPtrComparator
74337: {
74337:   typedef nsAutoPtr<T> A;
74337:   typedef T* B;
74337: 
74337: public:
74337:   PRBool Equals(const A& a, const B& b) const {
74337:     return a && b ? *a == *b : !a && !b ? true : false;
74337:   }
74337:   PRBool LessThan(const A& a, const B& b) const {
74337:     return a && b ? *a < *b : b ? true : false;
74337:   }
74337: };
74337: 
74337: template <class T>
74337: inline AutoPtrComparator<T>
74337: GetAutoPtrComparator(const nsTArray<nsAutoPtr<T> >&)
74337: {
74337:   return AutoPtrComparator<T>();
74337: }
74337: 
74337: // Specialize this if there's some class that has multiple nsISupports bases.
74337: template <class T>
74337: struct ISupportsBaseInfo
74337: {
74337:   typedef T ISupportsBase;
74337: };
74337: 
74337: template <template <class> class SmartPtr, class T>
74337: inline void
74337: SwapToISupportsArray(SmartPtr<T>& aSrc,
74337:                      nsTArray<nsCOMPtr<nsISupports> >& aDest)
74337: {
74337:   nsCOMPtr<nsISupports>* dest = aDest.AppendElement();
74337: 
74337:   T* raw = nsnull;
74337:   aSrc.swap(raw);
74337: 
74337:   nsISupports* rawSupports =
74337:     static_cast<typename ISupportsBaseInfo<T>::ISupportsBase*>(raw);
74337:   dest->swap(rawSupports);
74337: }
74337: 
74337: struct WorkerStructuredCloneCallbacks
74337: {
74337:   static JSObject*
74337:   Read(JSContext* aCx, JSStructuredCloneReader* aReader, uint32 aTag,
74337:        uint32 aData, void* aClosure)
74337:   {
76372:     // See if object is a nsIDOMFile pointer.
76372:     if (aTag == DOMWORKER_SCTAG_FILE) {
76372:       JS_ASSERT(!aData);
76372: 
76372:       nsIDOMFile* file;
76372:       if (JS_ReadBytes(aReader, &file, sizeof(file))) {
76372:         JS_ASSERT(file);
76372: 
76372: #ifdef DEBUG
76372:         {
76372:           // File should not be mutable.
76372:           nsCOMPtr<nsIMutable> mutableFile = do_QueryInterface(file);
76372:           PRBool isMutable;
76372:           NS_ASSERTION(NS_SUCCEEDED(mutableFile->GetMutable(&isMutable)) &&
76372:                        !isMutable,
76372:                        "Only immutable file should be passed to worker");
76372:         }
76372: #endif
76372: 
76372:         // nsIDOMFiles should be threadsafe, thus we will use the same instance
76372:         // in the worker.
76372:         JSObject* jsFile = file::CreateFile(aCx, file);
76372:         return jsFile;
76372:       }
76372:     }
76372:     // See if object is a nsIDOMBlob pointer.
76372:     else if (aTag == DOMWORKER_SCTAG_BLOB) {
76372:       JS_ASSERT(!aData);
76372: 
76372:       nsIDOMBlob* blob;
76372:       if (JS_ReadBytes(aReader, &blob, sizeof(blob))) {
76372:         JS_ASSERT(blob);
76372: 
76372: #ifdef DEBUG
76372:         {
76372:           // Blob should not be mutable.
76372:           nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(blob);
76372:           PRBool isMutable;
76372:           NS_ASSERTION(NS_SUCCEEDED(mutableBlob->GetMutable(&isMutable)) &&
76372:                        !isMutable,
76372:                        "Only immutable blob should be passed to worker");
76372:         }
76372: #endif
76372: 
76372:         // nsIDOMBlob should be threadsafe, thus we will use the same instance
76372:         // in the worker.
76372:         JSObject* jsBlob = file::CreateBlob(aCx, blob);
76372:         return jsBlob;
76372:       }
76372:     }
76372: 
74337:     Error(aCx, 0);
74337:     return nsnull;
74337:   }
74337: 
74337:   static JSBool
74337:   Write(JSContext* aCx, JSStructuredCloneWriter* aWriter, JSObject* aObj,
74337:         void* aClosure)
74337:   {
76372:     NS_ASSERTION(aClosure, "Null pointer!");
76372: 
76372:     // We'll stash any nsISupports pointers that need to be AddRef'd here.
76372:     nsTArray<nsCOMPtr<nsISupports> >* clonedObjects =
76372:       static_cast<nsTArray<nsCOMPtr<nsISupports> >*>(aClosure);
76372: 
76372:     // See if this is a File object.
76372:     {
76372:       nsIDOMFile* file = file::GetDOMFileFromJSObject(aCx, aObj);
76372:       if (file) {
76372:         if (JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_FILE, 0) &&
76372:             JS_WriteBytes(aWriter, &file, sizeof(file))) {
76372:           clonedObjects->AppendElement(file);
76372:           return true;
76372:         }
76372:       }
76372:     }
76372: 
76372:     // See if this is a Blob object.
76372:     {
76372:       nsIDOMBlob* blob = file::GetDOMBlobFromJSObject(aCx, aObj);
76372:       if (blob) {
76372:         nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(blob);
76372:         if (mutableBlob && NS_SUCCEEDED(mutableBlob->SetMutable(PR_FALSE)) &&
76372:             JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_BLOB, 0) &&
76372:             JS_WriteBytes(aWriter, &blob, sizeof(blob))) {
76372:           clonedObjects->AppendElement(blob);
76372:           return true;
76372:         }
76372:       }
76372:     }
76372: 
74337:     Error(aCx, 0);
74337:     return false;
74337:   }
74337: 
74337:   static void
74337:   Error(JSContext* aCx, uint32 /* aErrorId */)
74337:   {
74337:     ThrowDOMExceptionForCode(aCx, DATA_CLONE_ERR);
74337:   }
74337: };
74337: 
74337: JSStructuredCloneCallbacks gWorkerStructuredCloneCallbacks = {
74337:   WorkerStructuredCloneCallbacks::Read,
74337:   WorkerStructuredCloneCallbacks::Write,
74337:   WorkerStructuredCloneCallbacks::Error
74337: };
74337: 
74337: struct MainThreadWorkerStructuredCloneCallbacks
74337: {
74337:   static JSObject*
74337:   Read(JSContext* aCx, JSStructuredCloneReader* aReader, uint32 aTag,
74337:        uint32 aData, void* aClosure)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
76372:     // See if object is a nsIDOMFile pointer.
76372:     if (aTag == DOMWORKER_SCTAG_FILE) {
76372:       JS_ASSERT(!aData);
76372: 
76372:       nsIDOMFile* file;
76372:       if (JS_ReadBytes(aReader, &file, sizeof(file))) {
76372:         JS_ASSERT(file);
76372: 
76372: #ifdef DEBUG
76372:         {
76372:           // File should not be mutable.
76372:           nsCOMPtr<nsIMutable> mutableFile = do_QueryInterface(file);
76372:           PRBool isMutable;
76372:           NS_ASSERTION(NS_SUCCEEDED(mutableFile->GetMutable(&isMutable)) &&
76372:                        !isMutable,
76372:                        "Only immutable file should be passed to worker");
76372:         }
76372: #endif
76372: 
76372:         // nsIDOMFiles should be threadsafe, thus we will use the same instance
76372:         // on the main thread.
76372:         jsval wrappedFile;
76372:         nsresult rv =
76372:           nsContentUtils::WrapNative(aCx, JS_GetGlobalForScopeChain(aCx), file,
76372:                                      &NS_GET_IID(nsIDOMFile), &wrappedFile);
76372:         if (NS_FAILED(rv)) {
76372:           Error(aCx, DATA_CLONE_ERR);
76372:           return nsnull;
76372:         }
76372: 
76372:         return JSVAL_TO_OBJECT(wrappedFile);
76372:       }
76372:     }
76372:     // See if object is a nsIDOMBlob pointer.
76372:     else if (aTag == DOMWORKER_SCTAG_BLOB) {
76372:       JS_ASSERT(!aData);
76372: 
76372:       nsIDOMBlob* blob;
76372:       if (JS_ReadBytes(aReader, &blob, sizeof(blob))) {
76372:         JS_ASSERT(blob);
76372: 
76372: #ifdef DEBUG
76372:         {
76372:           // Blob should not be mutable.
76372:           nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(blob);
76372:           PRBool isMutable;
76372:           NS_ASSERTION(NS_SUCCEEDED(mutableBlob->GetMutable(&isMutable)) &&
76372:                        !isMutable,
76372:                        "Only immutable blob should be passed to worker");
76372:         }
76372: #endif
76372: 
76372:         // nsIDOMBlobs should be threadsafe, thus we will use the same instance
76372:         // on the main thread.
76372:         jsval wrappedBlob;
76372:         nsresult rv =
76372:           nsContentUtils::WrapNative(aCx, JS_GetGlobalForScopeChain(aCx), blob,
76372:                                      &NS_GET_IID(nsIDOMBlob), &wrappedBlob);
76372:         if (NS_FAILED(rv)) {
76372:           Error(aCx, DATA_CLONE_ERR);
76372:           return nsnull;
76372:         }
76372: 
76372:         return JSVAL_TO_OBJECT(wrappedBlob);
76372:       }
76372:     }
76372: 
74337:     JSObject* clone =
74337:       WorkerStructuredCloneCallbacks::Read(aCx, aReader, aTag, aData, aClosure);
74337:     if (clone) {
74337:       return clone;
74337:     }
74337: 
74337:     JS_ClearPendingException(aCx);
74337:     return NS_DOMReadStructuredClone(aCx, aReader, aTag, aData, nsnull);
74337:   }
74337: 
74337:   static JSBool
74337:   Write(JSContext* aCx, JSStructuredCloneWriter* aWriter, JSObject* aObj,
74337:         void* aClosure)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
76372:     NS_ASSERTION(aClosure, "Null pointer!");
76372: 
76372:     // We'll stash any nsISupports pointers that need to be AddRef'd here.
76372:     nsTArray<nsCOMPtr<nsISupports> >* clonedObjects =
76372:       static_cast<nsTArray<nsCOMPtr<nsISupports> >*>(aClosure);
76372: 
76372:     // See if this is a wrapped native.
76372:     nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative;
76372:     nsContentUtils::XPConnect()->
76372:       GetWrappedNativeOfJSObject(aCx, aObj, getter_AddRefs(wrappedNative));
76372: 
76372:     if (wrappedNative) {
76372:       // Get the raw nsISupports out of it.
76372:       nsISupports* wrappedObject = wrappedNative->Native();
76372:       NS_ASSERTION(wrappedObject, "Null pointer?!");
76372: 
76372:       // See if the wrapped native is a nsIDOMFile.
76372:       nsCOMPtr<nsIDOMFile> file = do_QueryInterface(wrappedObject);
76372:       if (file) {
76372:         nsCOMPtr<nsIMutable> mutableFile = do_QueryInterface(file);
76372:         if (mutableFile && NS_SUCCEEDED(mutableFile->SetMutable(PR_FALSE))) {
76372:           nsIDOMFile* filePtr = file;
76372:           if (JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_FILE, 0) &&
76372:               JS_WriteBytes(aWriter, &filePtr, sizeof(filePtr))) {
76372:             clonedObjects->AppendElement(file);
76372:             return true;
76372:           }
76372:         }
76372:       }
76372: 
76372:       // See if the wrapped native is a nsIDOMBlob.
76372:       nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(wrappedObject);
76372:       if (blob) {
76372:         nsCOMPtr<nsIMutable> mutableBlob = do_QueryInterface(blob);
76372:         if (mutableBlob && NS_SUCCEEDED(mutableBlob->SetMutable(PR_FALSE))) {
76372:           nsIDOMBlob* blobPtr = blob;
76372:           if (JS_WriteUint32Pair(aWriter, DOMWORKER_SCTAG_BLOB, 0) &&
76372:               JS_WriteBytes(aWriter, &blobPtr, sizeof(blobPtr))) {
76372:             clonedObjects->AppendElement(blob);
76372:             return true;
76372:           }
76372:         }
76372:       }
76372:     }
76372: 
74337:     JSBool ok =
74337:       WorkerStructuredCloneCallbacks::Write(aCx, aWriter, aObj, aClosure);
74337:     if (ok) {
74337:       return ok;
74337:     }
74337: 
74337:     JS_ClearPendingException(aCx);
74337:     return NS_DOMWriteStructuredClone(aCx, aWriter, aObj, nsnull);
74337:   }
74337: 
74337:   static void
74337:   Error(JSContext* aCx, uint32 aErrorId)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
74337:     NS_DOMStructuredCloneError(aCx, aErrorId);
74337:   }
74337: };
74337: 
74337: JSStructuredCloneCallbacks gMainThreadWorkerStructuredCloneCallbacks = {
74337:   MainThreadWorkerStructuredCloneCallbacks::Read,
74337:   MainThreadWorkerStructuredCloneCallbacks::Write,
74337:   MainThreadWorkerStructuredCloneCallbacks::Error
74337: };
74337: 
74337: struct ChromeWorkerStructuredCloneCallbacks
74337: {
74337:   static JSObject*
74337:   Read(JSContext* aCx, JSStructuredCloneReader* aReader, uint32 aTag,
74337:        uint32 aData, void* aClosure)
74337:   {
74337:     return WorkerStructuredCloneCallbacks::Read(aCx, aReader, aTag, aData,
74337:                                                 aClosure);
74337:   }
74337: 
74337:   static JSBool
74337:   Write(JSContext* aCx, JSStructuredCloneWriter* aWriter, JSObject* aObj,
74337:         void* aClosure)
74337:   {
74337:     return WorkerStructuredCloneCallbacks::Write(aCx, aWriter, aObj, aClosure);
74337:   }
74337: 
74337:   static void
74337:   Error(JSContext* aCx, uint32 aErrorId)
74337:   {
74337:     return WorkerStructuredCloneCallbacks::Error(aCx, aErrorId);
74337:   }
74337: };
74337: 
74337: JSStructuredCloneCallbacks gChromeWorkerStructuredCloneCallbacks = {
74337:   ChromeWorkerStructuredCloneCallbacks::Read,
74337:   ChromeWorkerStructuredCloneCallbacks::Write,
74337:   ChromeWorkerStructuredCloneCallbacks::Error
74337: };
74337: 
74337: struct MainThreadChromeWorkerStructuredCloneCallbacks
74337: {
74337:   static JSObject*
74337:   Read(JSContext* aCx, JSStructuredCloneReader* aReader, uint32 aTag,
74337:        uint32 aData, void* aClosure)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
74337:     JSObject* clone =
74337:       ChromeWorkerStructuredCloneCallbacks::Read(aCx, aReader, aTag, aData,
74337:                                                  aClosure);
74337:     if (clone) {
74337:       return clone;
74337:     }
74337: 
74337:     JS_ClearPendingException(aCx);
74337:     return NS_DOMReadStructuredClone(aCx, aReader, aTag, aData, nsnull);
74337:   }
74337: 
74337:   static JSBool
74337:   Write(JSContext* aCx, JSStructuredCloneWriter* aWriter, JSObject* aObj,
74337:         void* aClosure)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
74337:     JSBool ok =
74337:       ChromeWorkerStructuredCloneCallbacks::Write(aCx, aWriter, aObj, aClosure);
74337:     if (ok) {
74337:       return ok;
74337:     }
74337: 
74337:     JS_ClearPendingException(aCx);
74337:     return NS_DOMWriteStructuredClone(aCx, aWriter, aObj, nsnull);
74337:   }
74337: 
74337:   static void
74337:   Error(JSContext* aCx, uint32 aErrorId)
74337:   {
74337:     AssertIsOnMainThread();
74337: 
74337:     NS_DOMStructuredCloneError(aCx, aErrorId);
74337:   }
74337: };
74337: 
74337: JSStructuredCloneCallbacks gMainThreadChromeWorkerStructuredCloneCallbacks = {
74337:   MainThreadChromeWorkerStructuredCloneCallbacks::Read,
74337:   MainThreadChromeWorkerStructuredCloneCallbacks::Write,
74337:   MainThreadChromeWorkerStructuredCloneCallbacks::Error
74337: };
74337: 
74337: class WorkerFinishedRunnable : public WorkerControlRunnable
74337: {
74337:   WorkerPrivate* mFinishedWorker;
74337:   nsCOMPtr<nsIThread> mThread;
74337: 
74337:   class MainThreadReleaseRunnable : public nsRunnable
74337:   {
74337:     nsCOMPtr<nsIThread> mThread;
74337:     nsTArray<nsCOMPtr<nsISupports> > mDoomed;
74337: 
74337:   public:
74337:     MainThreadReleaseRunnable(nsCOMPtr<nsIThread>& aThread,
74337:                               nsTArray<nsCOMPtr<nsISupports> >& aDoomed)
74337:     {
74337:       mThread.swap(aThread);
74337:       mDoomed.SwapElements(aDoomed);
74337:     }
74337: 
74337:     NS_IMETHOD
74337:     Run()
74337:     {
74337:       mDoomed.Clear();
74338: 
74338:       if (mThread) {
74338:         RuntimeService* runtime = RuntimeService::GetService();
74338:         NS_ASSERTION(runtime, "This should never be null!");
74338: 
74338:         runtime->NoteIdleThread(mThread);
74338:       }
74338: 
74338:       return NS_OK;
74337:     }
74337:   };
74337: 
74337: public:
74337:   WorkerFinishedRunnable(WorkerPrivate* aWorkerPrivate,
74337:                          WorkerPrivate* aFinishedWorker,
74337:                          nsIThread* aFinishedThread)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
74337:     mFinishedWorker(aFinishedWorker), mThread(aFinishedThread)
74337:   { }
74337: 
74337:   bool
74337:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     // Silence bad assertions.
74337:     return true;
74337:   }
74337: 
74337:   void
74337:   PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                bool aDispatchResult)
74337:   {
74337:     // Silence bad assertions.
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     nsTArray<nsCOMPtr<nsISupports> > doomed;
74337:     mFinishedWorker->ForgetMainThreadObjects(doomed);
74337: 
74337:     nsRefPtr<MainThreadReleaseRunnable> runnable =
74337:       new MainThreadReleaseRunnable(mThread, doomed);
74337:     if (NS_FAILED(NS_DispatchToMainThread(runnable, NS_DISPATCH_NORMAL))) {
74337:       NS_WARNING("Failed to dispatch, going to leak!");
74337:     }
74337: 
74337:     mFinishedWorker->FinalizeInstance(aCx);
74337: 
74337:     RuntimeService* runtime = RuntimeService::GetService();
74337:     NS_ASSERTION(runtime, "This should never be null!");
74337: 
74337:     runtime->UnregisterWorker(aCx, mFinishedWorker);
74337: 
74337:     delete mFinishedWorker;
74337:     return true;
74337:   }
74337: };
74337: 
74337: class TopLevelWorkerFinishedRunnable : public nsRunnable
74337: {
74337:   WorkerPrivate* mFinishedWorker;
74337:   nsCOMPtr<nsIThread> mThread;
74337: 
74337: public:
74337:   TopLevelWorkerFinishedRunnable(WorkerPrivate* aFinishedWorker,
74337:                                  nsIThread* aFinishedThread)
74337:   : mFinishedWorker(aFinishedWorker), mThread(aFinishedThread)
74337:   {
74337:     aFinishedWorker->AssertIsOnWorkerThread();
74337:   }
74337: 
74337:   NS_IMETHOD
74337:   Run()
74337:   {
74337:     AssertIsOnMainThread();
74337: 
74337:     RuntimeService::AutoSafeJSContext cx;
74337: 
74337:     mFinishedWorker->FinalizeInstance(cx);
74337: 
74337:     RuntimeService* runtime = RuntimeService::GetService();
74337:     NS_ASSERTION(runtime, "This should never be null!");
74337: 
74337:     runtime->UnregisterWorker(cx, mFinishedWorker);
74337: 
74338:     if (mThread) {
74338:       runtime->NoteIdleThread(mThread);
74338:     }
74337: 
74337:     delete mFinishedWorker;
74337: 
74338:     return NS_OK;
74337:   }
74337: };
74337: 
74337: class ModifyBusyCountRunnable : public WorkerControlRunnable
74337: {
74337:   bool mIncrease;
74337: 
74337: public:
74337:   ModifyBusyCountRunnable(WorkerPrivate* aWorkerPrivate, bool aIncrease)
74337:   : WorkerControlRunnable(aWorkerPrivate, ParentThread, UnchangedBusyCount),
74337:     mIncrease(aIncrease)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     return aWorkerPrivate->ModifyBusyCount(aCx, mIncrease);
74337:   }
74337: 
74337:   void
74337:   PostRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate, bool aRunResult)
74337:   {
74337:     if (mIncrease) {
74337:       WorkerControlRunnable::PostRun(aCx, aWorkerPrivate, aRunResult);
74337:       return;
74337:     }
74337:     // Don't do anything here as it's possible that aWorkerPrivate has been
74337:     // deleted.
74337:   }
74337: };
74337: 
74337: class CompileScriptRunnable : public WorkerRunnable
74337: {
74337: public:
74337:   CompileScriptRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : WorkerRunnable(aWorkerPrivate, WorkerThread, ModifyBusyCount)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     JSObject* global = CreateDedicatedWorkerGlobalScope(aCx);
74337:     if (!global) {
74337:       NS_WARNING("Failed to make global!");
74337:       return false;
74337:     }
74337: 
74337:     JSAutoEnterCompartment ac;
74337:     if (!ac.enter(aCx, global)) {
74337:       NS_WARNING("Failed to enter compartment!");
74337:       return false;
74337:     }
74337: 
74337:     JS_SetGlobalObject(aCx, global);
74337: 
74337:     return scriptloader::LoadWorkerScript(aCx);
74337:   }
74337: };
74337: 
74337: class CloseEventRunnable : public WorkerRunnable
74337: {
74337: public:
74337:   CloseEventRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : WorkerRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     JSObject* target = JS_GetGlobalObject(aCx);
74337:     NS_ASSERTION(target, "This must never be null!");
74337: 
74337:     aWorkerPrivate->CloseHandlerStarted();
74337: 
74337:     JSString* type = JS_InternString(aCx, "close");
74337:     if (!type) {
74337:       return false;
74337:     }
74337: 
74337:     JSObject* event = events::CreateGenericEvent(aCx, type, false, false,
74337:                                                  false);
74337:     if (!event) {
74337:       return false;
74337:     }
74337: 
74337:     bool ignored;
74337:     return events::DispatchEventToTarget(aCx, target, event, &ignored);
74337:   }
74337: 
74337:   void
74337:   PostRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate, bool aRunResult)
74337:   {
74337:     // Report errors.
74337:     WorkerRunnable::PostRun(aCx, aWorkerPrivate, aRunResult);
74337: 
74337:     // Match the busy count increase from NotifyRunnable.
74337:     if (!aWorkerPrivate->ModifyBusyCountFromWorker(aCx, false)) {
74337:       JS_ReportPendingException(aCx);
74337:     }
74337: 
74337:     aWorkerPrivate->CloseHandlerFinished();
74337:   }
74337: };
74337: 
74337: class MessageEventRunnable : public WorkerRunnable
74337: {
74337:   uint64* mData;
74337:   size_t mDataByteCount;
76372:   nsTArray<nsCOMPtr<nsISupports> > mClonedObjects;
74337: 
74337: public:
74337:   MessageEventRunnable(WorkerPrivate* aWorkerPrivate, Target aTarget,
76372:                        JSAutoStructuredCloneBuffer& aData,
76372:                        nsTArray<nsCOMPtr<nsISupports> >& aClonedObjects)
74337:   : WorkerRunnable(aWorkerPrivate, aTarget, aTarget == WorkerThread ?
74337:                                                        ModifyBusyCount :
74337:                                                        UnchangedBusyCount)
74337:   {
74337:     aData.steal(&mData, &mDataByteCount);
76372: 
76372:     if (!mClonedObjects.SwapElements(aClonedObjects)) {
76372:       NS_ERROR("This should never fail!");
76372:     }
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     JSAutoStructuredCloneBuffer buffer;
74542:     buffer.adopt(mData, mDataByteCount);
74337: 
74337:     mData = nsnull;
74337:     mDataByteCount = 0;
74337: 
74337:     bool mainRuntime;
74337:     JSObject* target;
74337:     if (mTarget == ParentThread) {
74337:       mainRuntime = !aWorkerPrivate->GetParent();
74337: 
74337:       target = aWorkerPrivate->GetJSObject();
74337: 
74337:       // Don't fire this event if the JS object has ben disconnected from the
74337:       // private object.
74337:       if (!target) {
74337:         return true;
74337:       }
74337: 
74337:       if (aWorkerPrivate->IsSuspended()) {
74337:         aWorkerPrivate->QueueRunnable(this);
74337:         buffer.steal(&mData, &mDataByteCount);
74337:         return true;
74337:       }
74337: 
74337:       aWorkerPrivate->AssertInnerWindowIsCorrect();
74337:     }
74337:     else {
74337:       NS_ASSERTION(aWorkerPrivate == GetWorkerPrivateFromContext(aCx),
74337:                    "Badness!");
74337:       mainRuntime = false;
74337:       target = JS_GetGlobalObject(aCx);
74337:     }
74337: 
74337:     NS_ASSERTION(target, "This should never be null!");
74337: 
76372:     JSObject* event = events::CreateMessageEvent(aCx, buffer, mClonedObjects,
76372:                                                  mainRuntime);
74337:     if (!event) {
74337:       return false;
74337:     }
74337: 
74337:     bool dummy;
74337:     return events::DispatchEventToTarget(aCx, target, event, &dummy);
74337:   }
74337: };
74337: 
74337: class NotifyRunnable : public WorkerControlRunnable
74337: {
74337:   Status mStatus;
74337: 
74337: public:
74337:   NotifyRunnable(WorkerPrivate* aWorkerPrivate, Status aStatus)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
74337:     mStatus(aStatus)
74337:   {
74337:     NS_ASSERTION(aStatus == Terminating || aStatus == Canceling ||
74337:                  aStatus == Killing, "Bad status!");
74337:   }
74337: 
74337:   bool
74337:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     // Modify here, but not in PostRun! This busy count addition will be matched
74337:     // by the CloseEventRunnable.
74337:     return aWorkerPrivate->ModifyBusyCount(aCx, true);
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     return aWorkerPrivate->NotifyInternal(aCx, mStatus);
74337:   }
74337: };
74337: 
74337: class CloseRunnable : public WorkerControlRunnable
74337: {
74337: public:
74337:   CloseRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : WorkerControlRunnable(aWorkerPrivate, ParentThread, UnchangedBusyCount)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     // This busy count will be matched by the CloseEventRunnable.
74337:     return aWorkerPrivate->ModifyBusyCount(aCx, true) &&
74337:            aWorkerPrivate->Close(aCx);
74337:   }
74337: };
74337: 
74337: class SuspendRunnable : public WorkerControlRunnable
74337: {
74337: public:
74337:   SuspendRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     return aWorkerPrivate->SuspendInternal(aCx);
74337:   }
74337: };
74337: 
74337: class ResumeRunnable : public WorkerControlRunnable
74337: {
74337: public:
74337:   ResumeRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     return aWorkerPrivate->ResumeInternal(aCx);
74337:   }
74337: };
74337: 
74337: class ReportErrorRunnable : public WorkerRunnable
74337: {
74337:   nsString mMessage;
74337:   nsString mFilename;
74337:   nsString mLine;
74337:   PRUint32 mLineNumber;
74337:   PRUint32 mColumnNumber;
74337:   PRUint32 mFlags;
74337:   PRUint32 mErrorNumber;
74337: 
74337: public:
74337:   ReportErrorRunnable(WorkerPrivate* aWorkerPrivate, const nsString& aMessage,
74337:                       const nsString& aFilename, const nsString& aLine,
74337:                       PRUint32 aLineNumber, PRUint32 aColumnNumber,
74337:                       PRUint32 aFlags, PRUint32 aErrorNumber)
74337:   : WorkerRunnable(aWorkerPrivate, ParentThread, UnchangedBusyCount),
74337:     mMessage(aMessage), mFilename(aFilename), mLine(aLine),
74337:     mLineNumber(aLineNumber), mColumnNumber(aColumnNumber), mFlags(aFlags),
74337:     mErrorNumber(aErrorNumber)
74337:   { }
74337: 
74337:   void
74337:   PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                bool aDispatchResult)
74337:   {
74337:     aWorkerPrivate->AssertIsOnWorkerThread();
74337: 
74337:     // Dispatch may fail if the worker was canceled, no need to report that as
74337:     // an error, so don't call base class PostDispatch.
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     JSObject* target = aWorkerPrivate->GetJSObject();
74337:     if (target) {
74337:       aWorkerPrivate->AssertInnerWindowIsCorrect();
74337:     }
74337: 
74337:     PRUint64 windowId;
74337: 
74337:     WorkerPrivate* parent = aWorkerPrivate->GetParent();
74337:     if (parent) {
74337:       windowId = 0;
74337:     }
74337:     else {
74337:       AssertIsOnMainThread();
74337: 
74337:       if (aWorkerPrivate->IsSuspended()) {
74337:         aWorkerPrivate->QueueRunnable(this);
74337:         return true;
74337:       }
74337: 
74337:       windowId = aWorkerPrivate->GetOuterWindowId();
74337:     }
74337: 
74337:     return ReportErrorRunnable::ReportError(aCx, parent, true, target, mMessage,
74337:                                             mFilename, mLine, mLineNumber,
74337:                                             mColumnNumber, mFlags,
74337:                                             mErrorNumber, windowId);
74337:   }
74337: 
74337:   static bool
74337:   ReportError(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:               bool aFireAtScope, JSObject* aTarget, const nsString& aMessage,
74337:               const nsString& aFilename, const nsString& aLine,
74337:               PRUint32 aLineNumber, PRUint32 aColumnNumber, PRUint32 aFlags,
74337:               PRUint32 aErrorNumber, PRUint64 aWindowId)
74337:   {
74337:     if (aWorkerPrivate) {
74337:       aWorkerPrivate->AssertIsOnWorkerThread();
74337:     }
74337:     else {
74337:       AssertIsOnMainThread();
74337:     }
74337: 
74337:     JSString* message = JS_NewUCStringCopyN(aCx, aMessage.get(),
74337:                                             aMessage.Length());
74337:     if (!message) {
74337:       return false;
74337:     }
74337: 
74337:     JSString* filename = JS_NewUCStringCopyN(aCx, aFilename.get(),
74337:                                              aFilename.Length());
74337:     if (!filename) {
74337:       return false;
74337:     }
74337: 
74337:     // First fire an ErrorEvent at the worker.
74337:     if (aTarget) {
74337:       JSObject* event = events::CreateErrorEvent(aCx, message, filename,
74337:                                                  aLineNumber, !aWorkerPrivate);
74337:       if (!event) {
74337:         return false;
74337:       }
74337: 
74337:       bool preventDefaultCalled;
74337:       if (!events::DispatchEventToTarget(aCx, aTarget, event,
74337:                                          &preventDefaultCalled)) {
74337:         return false;
74337:       }
74337: 
74337:       if (preventDefaultCalled) {
74337:         return true;
74337:       }
74337:     }
74337: 
74337:     // Now fire an event at the global object, but don't do that if the error
74337:     // code is too much recursion and this is the same script threw the error.
74337:     if (aFireAtScope && (aTarget || aErrorNumber != JSMSG_OVER_RECURSED)) {
74337:       aTarget = JS_GetGlobalForScopeChain(aCx);
74337:       NS_ASSERTION(aTarget, "This should never be null!");
74337: 
74337:       bool preventDefaultCalled;
74337:       if (aWorkerPrivate) {
74337:         // Fire a normal ErrorEvent if we're running on a worker thread.
74337:         JSObject* event = events::CreateErrorEvent(aCx, message, filename,
74337:                                                    aLineNumber, false);
74337:         if (!event) {
74337:           return false;
74337:         }
74337: 
74337:         if (!events::DispatchEventToTarget(aCx, aTarget, event,
74337:                                            &preventDefaultCalled)) {
74337:           return false;
74337:         }
74337:       }
74337:       else {
74337:         // Icky, we have to fire an nsScriptErrorEvent...
74337:         nsIScriptGlobalObject* sgo =
74337:           nsJSUtils::GetStaticScriptGlobal(aCx, aTarget);
74337:         NS_ASSERTION(sgo, "This should never be null!");
74337: 
74337:         nsScriptErrorEvent event(true, NS_LOAD_ERROR);
74337:         event.lineNr = aLineNumber;
74337:         event.errorMsg = aMessage.get();
74337:         event.fileName = aFilename.get();
74337: 
74337:         nsEventStatus status;
74337:         if (NS_FAILED(sgo->HandleScriptError(&event, &status))) {
74337:           NS_WARNING("Failed to dispatch main thread error event!");
74337:           status = nsEventStatus_eIgnore;
74337:         }
74337: 
74337:         preventDefaultCalled = status == nsEventStatus_eConsumeNoDefault;
74337:       }
74337: 
74337:       if (preventDefaultCalled) {
74337:         return true;
74337:       }
74337:     }
74337: 
74337:     // Now fire a runnable to do the same on the parent's thread if we can.
74337:     if (aWorkerPrivate) {
74337:       nsRefPtr<ReportErrorRunnable> runnable =
74337:         new ReportErrorRunnable(aWorkerPrivate, aMessage, aFilename, aLine,
74337:                                 aLineNumber, aColumnNumber, aFlags,
74337:                                 aErrorNumber);
74337:       return runnable->Dispatch(aCx);
74337:     }
74337: 
74337:     // Otherwise log an error to the error console.
74337:     nsCOMPtr<nsIScriptError2> scriptError =
74337:       do_CreateInstance(NS_SCRIPTERROR_CONTRACTID);
74337:     NS_WARN_IF_FALSE(scriptError, "Faild to create script error!");
74337: 
74337:     nsCOMPtr<nsIConsoleMessage> consoleMessage;
74337: 
74337:     if (scriptError) {
74337:       if (NS_SUCCEEDED(scriptError->InitWithWindowID(aMessage.get(),
74337:                                                      aFilename.get(),
74337:                                                      aLine.get(), aLineNumber,
74337:                                                      aColumnNumber, aFlags,
74337:                                                      "Web Worker",
74337:                                                      aWindowId))) {
74337:         consoleMessage = do_QueryInterface(scriptError);
74337:         NS_ASSERTION(consoleMessage, "This should never fail!");
74337:       }
74337:       else {
74337:         NS_WARNING("Failed to init script error!");
74337:       }
74337:     }
74337: 
74337:     nsCOMPtr<nsIConsoleService> consoleService =
74337:       do_GetService(NS_CONSOLESERVICE_CONTRACTID);
74337:     NS_WARN_IF_FALSE(consoleService, "Faild to get console service!");
74337: 
74337:     bool logged = false;
74337: 
74337:     if (consoleService) {
74337:       if (consoleMessage) {
74337:         if (NS_SUCCEEDED(consoleService->LogMessage(consoleMessage))) {
74337:           logged = true;
74337:         }
74337:         else {
74337:           NS_WARNING("Failed to log script error!");
74337:         }
74337:       }
74337:       else if (NS_SUCCEEDED(consoleService->LogStringMessage(aMessage.get()))) {
74337:         logged = true;
74337:       }
74337:       else {
74337:         NS_WARNING("Failed to log script error!");
74337:       }
74337:     }
74337: 
74337:     if (!logged) {
74337:       fputs(NS_ConvertUTF16toUTF8(aMessage).get(), stderr);
74337:       fflush(stderr);
74337:     }
74337: 
74337:     return true;
74337:   }
74337: };
74337: 
74337: class TimerRunnable : public WorkerRunnable
74337: {
74337: public:
74337:   TimerRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : WorkerRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount)
74337:   { }
74337: 
74337:   bool
74337:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     // Silence bad assertions.
74337:     return true;
74337:   }
74337: 
74337:   void
74337:   PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                bool aDispatchResult)
74337:   {
74337:     // Silence bad assertions.
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     return aWorkerPrivate->RunExpiredTimeouts(aCx);
74337:   }
74337: };
74337: 
74337: void
74337: DummyCallback(nsITimer* aTimer, void* aClosure)
74337: {
74337:   // Nothing!
74337: }
74337: 
74337: class WorkerRunnableEventTarget : public nsIEventTarget
74337: {
74337: protected:
74337:   nsRefPtr<WorkerRunnable> mWorkerRunnable;
74337: 
74337: public:
74337:   WorkerRunnableEventTarget(WorkerRunnable* aWorkerRunnable)
74337:   : mWorkerRunnable(aWorkerRunnable)
74337:   { }
74337: 
74337:   NS_DECL_ISUPPORTS
74337: 
74337:   NS_IMETHOD
74337:   Dispatch(nsIRunnable* aRunnable, PRUint32 aFlags)
74337:   {
74337:     NS_ASSERTION(aFlags == nsIEventTarget::DISPATCH_NORMAL, "Don't call me!");
74337: 
74337:     nsRefPtr<WorkerRunnableEventTarget> kungFuDeathGrip = this;
74337: 
74337:     // This can fail if we're racing to terminate or cancel, should be handled
74337:     // by the terminate or cancel code.
74337:     mWorkerRunnable->Dispatch(nsnull);
74337: 
74337:     // Run the runnable we're given now (should just call DummyCallback()),
74337:     // otherwise the timer thread will leak it...
74337:     return aRunnable->Run();
74337:   }
74337: 
74337:   NS_IMETHOD
74337:   IsOnCurrentThread(PRBool* aIsOnCurrentThread)
74337:   {
74337:     *aIsOnCurrentThread = false;
74337:     return NS_OK;
74337:   }
74337: };
74337: 
74337: NS_IMPL_THREADSAFE_ISUPPORTS1(WorkerRunnableEventTarget, nsIEventTarget)
74337: 
74337: class KillCloseEventRunnable : public WorkerRunnable
74337: {
74337:   nsCOMPtr<nsITimer> mTimer;
74337: 
74337:   class KillScriptRunnable : public WorkerControlRunnable
74337:   {
74337:   public:
74337:     KillScriptRunnable(WorkerPrivate* aWorkerPrivate)
74337:     : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount)
74337:     { }
74337: 
74337:     bool
74337:     PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:     {
74337:       // Silence bad assertions.
74337:       return true;
74337:     }
74337: 
74337:     void
74337:     PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                  bool aDispatchResult)
74337:     {
74337:       // Silence bad assertions.
74337:     }
74337: 
74337:     bool
74337:     WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:     {
74337:       // Kill running script.
74337:       return false;
74337:     }
74337:   };
74337: 
74337: public:
74337:   KillCloseEventRunnable(WorkerPrivate* aWorkerPrivate)
74337:   : WorkerRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount)
74337:   { }
74337: 
74337:   ~KillCloseEventRunnable()
74337:   {
74337:     if (mTimer) {
74337:       mTimer->Cancel();
74337:     }
74337:   }
74337: 
74337:   bool
74337:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     NS_NOTREACHED("Not meant to be dispatched!");
74337:     return false;
74337:   }
74337: 
74337:   bool
74337:   SetTimeout(JSContext* aCx, PRUint32 aDelayMS)
74337:   {
74337:     nsCOMPtr<nsITimer> timer = do_CreateInstance(NS_TIMER_CONTRACTID);
74337:     if (!timer) {
74337:       JS_ReportError(aCx, "Failed to create timer!");
74337:       return false;
74337:     }
74337: 
74337:     nsRefPtr<KillScriptRunnable> runnable =
74337:       new KillScriptRunnable(mWorkerPrivate);
74337: 
74337:     nsRefPtr<WorkerRunnableEventTarget> target =
74337:       new WorkerRunnableEventTarget(runnable);
74337: 
74337:     if (NS_FAILED(timer->SetTarget(target))) {
74337:       JS_ReportError(aCx, "Failed to set timer's target!");
74337:       return false;
74337:     }
74337: 
74337:     if (NS_FAILED(timer->InitWithFuncCallback(DummyCallback, nsnull, aDelayMS,
74337:                                               nsITimer::TYPE_ONE_SHOT))) {
74337:       JS_ReportError(aCx, "Failed to start timer!");
74337:       return false;
74337:     }
74337: 
74337:     mTimer.swap(timer);
74337:     return true;
74337:   }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     if (mTimer) {
74337:       mTimer->Cancel();
74337:       mTimer = nsnull;
74337:     }
74337: 
74337:     return true;
74337:   }
74337: };
74337: 
74337: class UpdateJSContextOptionsRunnable : public WorkerControlRunnable
74337: {
74337:   PRUint32 mOptions;
74337: 
74337: public:
74337:   UpdateJSContextOptionsRunnable(WorkerPrivate* aWorkerPrivate,
74337:                                  PRUint32 aOptions)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
74337:     mOptions(aOptions)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     aWorkerPrivate->UpdateJSContextOptionsInternal(aCx, mOptions);
74337:     return true;
74337:   }
74337: };
74337: 
74337: #ifdef JS_GC_ZEAL
74337: class UpdateGCZealRunnable : public WorkerControlRunnable
74337: {
74337:   PRUint8 mGCZeal;
74337: 
74337: public:
74337:   UpdateGCZealRunnable(WorkerPrivate* aWorkerPrivate,
74337:                        PRUint8 aGCZeal)
74337:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
74337:     mGCZeal(aGCZeal)
74337:   { }
74337: 
74337:   bool
74337:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337:   {
74337:     aWorkerPrivate->UpdateGCZealInternal(aCx, mGCZeal);
74337:     return true;
74337:   }
74337: };
74337: #endif
74337: 
75066: class CollectRuntimeStatsRunnable : public WorkerControlRunnable
75066: {
75066:   typedef mozilla::Mutex Mutex;
75066:   typedef mozilla::CondVar CondVar;
75066: 
75066:   Mutex* mMutex;
75066:   CondVar* mCondVar;
75066:   volatile bool* mDoneFlag;
75066:   IterateData* mData;
75066:   volatile bool* mSucceeded;
75066: 
75066: public:
75066:   CollectRuntimeStatsRunnable(WorkerPrivate* aWorkerPrivate, Mutex* aMutex,
75066:                               CondVar* aCondVar, volatile bool* aDoneFlag,
75066:                               IterateData* aData, volatile bool* aSucceeded)
75066:   : WorkerControlRunnable(aWorkerPrivate, WorkerThread, UnchangedBusyCount),
75066:     mMutex(aMutex), mCondVar(aCondVar), mDoneFlag(aDoneFlag), mData(aData),
75066:     mSucceeded(aSucceeded)
75066:   { }
75066: 
75066:   bool
75066:   PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
75066:   {
75066:     AssertIsOnMainThread();
75066:     return true;
75066:   }
75066: 
75066:   void
75066:   PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
75066:                bool aDispatchResult)
75066:   {
75066:     AssertIsOnMainThread();
75066:   }
75066: 
75066:   bool
75066:   WorkerRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
75066:   {
75066:     JSAutoSuspendRequest asr(aCx);
75066: 
75066:     *mSucceeded = CollectCompartmentStatsForRuntime(JS_GetRuntime(aCx), mData);
75066: 
75066:     {
75066:       MutexAutoLock lock(*mMutex);
75066: 
75066:       NS_ASSERTION(!*mDoneFlag, "Should be false!");
75066: 
75066:       *mDoneFlag = true;
75066:       mCondVar->Notify();
75066:     }
75066: 
75066:     return true;
75066:   }
75066: };
75066: 
74337: } /* anonymous namespace */
74337: 
74337: #ifdef DEBUG
74337: void
74337: mozilla::dom::workers::AssertIsOnMainThread()
74337: {
74337:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
74337: }
74337: 
74337: WorkerRunnable::WorkerRunnable(WorkerPrivate* aWorkerPrivate, Target aTarget,
74337:                                BusyBehavior aBusyBehavior)
74337: : mWorkerPrivate(aWorkerPrivate), mTarget(aTarget),
74337:   mBusyBehavior(aBusyBehavior)
74337: {
74337:   NS_ASSERTION(aWorkerPrivate, "Null worker private!");
74337: }
74337: #endif
74337: 
74337: NS_IMPL_THREADSAFE_ISUPPORTS1(WorkerRunnable, nsIRunnable)
74337: 
74337: bool
74337: WorkerRunnable::PreDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate)
74337: {
74337: #ifdef DEBUG
74337:   if (mBusyBehavior == ModifyBusyCount) {
74337:     NS_ASSERTION(mTarget == WorkerThread,
74337:                  "Don't set this option unless targeting the worker thread!");
74337:   }
74337:   if (mTarget == ParentThread) {
74337:     aWorkerPrivate->AssertIsOnWorkerThread();
74337:   }
74337:   else {
74337:     aWorkerPrivate->AssertIsOnParentThread();
74337:   }
74337: #endif
74337: 
74337:   if (mBusyBehavior == ModifyBusyCount) {
74337:     return aWorkerPrivate->ModifyBusyCount(aCx, true);
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: bool
74337: WorkerRunnable::Dispatch(JSContext* aCx)
74337: {
74337:   bool ok;
74337: 
74337:   if (!aCx) {
74337:     ok = PreDispatch(nsnull, mWorkerPrivate);
74337:     if (ok) {
74337:       ok = DispatchInternal();
74337:     }
74337:     PostDispatch(nsnull, mWorkerPrivate, ok);
74337:     return ok;
74337:   }
74337: 
74337:   JSAutoRequest ar(aCx);
74337: 
74337:   JSObject* global = JS_GetGlobalObject(aCx);
74337: 
74337:   JSAutoEnterCompartment ac;
74337:   if (global && !ac.enter(aCx, global)) {
74337:     return false;
74337:   }
74337: 
74337:   ok = PreDispatch(aCx, mWorkerPrivate);
74337: 
74337:   if (ok && !DispatchInternal()) {
74337:     ok = false;
74337:   }
74337: 
74337:   PostDispatch(aCx, mWorkerPrivate, ok);
74337: 
74337:   return ok;
74337: }
74337: 
74337: // static
74337: bool
74337: WorkerRunnable::DispatchToMainThread(nsIRunnable* aRunnable)
74337: {
74337:   nsCOMPtr<nsIThread> mainThread = do_GetMainThread();
74337:   NS_ASSERTION(mainThread, "This should never fail!");
74337: 
74337:   return NS_SUCCEEDED(mainThread->Dispatch(aRunnable, NS_DISPATCH_NORMAL));
74337: }
74337: 
74337: // These DispatchInternal functions look identical but carry important type
74337: // informaton so they can't be consolidated...
74337: 
74337: #define IMPL_DISPATCH_INTERNAL(_class)                                         \
74337:   bool                                                                         \
74337:   _class ::DispatchInternal()                                                  \
74337:   {                                                                            \
74337:     if (mTarget == WorkerThread) {                                             \
74337:       return mWorkerPrivate->Dispatch(this);                                   \
74337:     }                                                                          \
74337:                                                                                \
74337:     if (mWorkerPrivate->GetParent()) {                                         \
74337:       return mWorkerPrivate->GetParent()->Dispatch(this);                      \
74337:     }                                                                          \
74337:                                                                                \
74337:     return DispatchToMainThread(this);                                         \
74337:   }
74337: 
74337: IMPL_DISPATCH_INTERNAL(WorkerRunnable)
74337: IMPL_DISPATCH_INTERNAL(WorkerSyncRunnable)
74337: IMPL_DISPATCH_INTERNAL(WorkerControlRunnable)
74337: 
74337: #undef IMPL_DISPATCH_INTERNAL
74337: 
74337: void
74337: WorkerRunnable::PostDispatch(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                              bool aDispatchResult)
74337: {
74337: #ifdef DEBUG
74337:   if (mTarget == ParentThread) {
74337:     aWorkerPrivate->AssertIsOnWorkerThread();
74337:   }
74337:   else {
74337:     aWorkerPrivate->AssertIsOnParentThread();
74337:   }
74337: #endif
74337: 
74337:   if (!aDispatchResult) {
74337:     if (mBusyBehavior == ModifyBusyCount) {
74337:       aWorkerPrivate->ModifyBusyCount(aCx, false);
74337:     }
74337:     JS_ReportPendingException(aCx);
74337:   }
74337: }
74337: 
74337: NS_IMETHODIMP
74337: WorkerRunnable::Run()
74337: {
74337:   JSContext* cx;
74584:   JSObject* targetCompartmentObject;
74337:   nsIThreadJSContextStack* contextStack = nsnull;
74337: 
74337:   if (mTarget == WorkerThread) {
74337:     mWorkerPrivate->AssertIsOnWorkerThread();
74337:     cx = mWorkerPrivate->GetJSContext();
74584:     targetCompartmentObject = JS_GetGlobalObject(cx);
74337:   } else {
74337:     mWorkerPrivate->AssertIsOnParentThread();
74337:     cx = mWorkerPrivate->ParentJSContext();
74584:     targetCompartmentObject = mWorkerPrivate->GetJSObject();
74337: 
74337:     if (!mWorkerPrivate->GetParent()) {
74337:       AssertIsOnMainThread();
74337: 
74337:       contextStack = nsContentUtils::ThreadJSContextStack();
74337:       NS_ASSERTION(contextStack, "This should never be null!");
74337: 
74337:       if (NS_FAILED(contextStack->Push(cx))) {
74337:         NS_WARNING("Failed to push context!");
74337:         contextStack = nsnull;
74337:       }
74337:     }
74337:   }
74337: 
74337:   NS_ASSERTION(cx, "Must have a context!");
74337: 
74337:   JSAutoRequest ar(cx);
74337: 
74337:   JSAutoEnterCompartment ac;
74584:   if (targetCompartmentObject && !ac.enter(cx, targetCompartmentObject)) {
74337:     return false;
74337:   }
74337: 
74337:   bool result = WorkerRun(cx, mWorkerPrivate);
74337: 
74337:   PostRun(cx, mWorkerPrivate, result);
74337: 
74337:   if (contextStack) {
74337:     JSContext* otherCx;
74337:     if (NS_FAILED(contextStack->Pop(&otherCx))) {
74337:       NS_WARNING("Failed to pop context!");
74337:     }
74337:     else if (otherCx != cx) {
74337:       NS_WARNING("Popped a different context!");
74337:     }
74337:   }
74337: 
74337:   return result ? NS_OK : NS_ERROR_FAILURE;
74337: }
74337: 
74337: void
74337: WorkerRunnable::PostRun(JSContext* aCx, WorkerPrivate* aWorkerPrivate,
74337:                         bool aRunResult)
74337: {
74337: #ifdef DEBUG
74337:   if (mTarget == ParentThread) {
74337:     mWorkerPrivate->AssertIsOnParentThread();
74337:   }
74337:   else {
74337:     mWorkerPrivate->AssertIsOnWorkerThread();
74337:   }
74337: #endif
74337: 
74337:   if (mBusyBehavior == ModifyBusyCount) {
74337:     if (!aWorkerPrivate->ModifyBusyCountFromWorker(aCx, false)) {
74337:       aRunResult = false;
74337:     }
74337:   }
74337: 
74337:   if (!aRunResult) {
74337:     JS_ReportPendingException(aCx);
74337:   }
74337: }
74337: 
74337: struct WorkerPrivate::TimeoutInfo
74337: {
74337:   TimeoutInfo()
74337:   : mTimeoutVal(JSVAL_VOID), mLineNumber(0), mId(0), mIsInterval(false),
74337:     mCanceled(false)
74337:   {
74337:     MOZ_COUNT_CTOR(mozilla::dom::workers::WorkerPrivate::TimeoutInfo);
74337:   }
74337: 
74337:   ~TimeoutInfo()
74337:   {
74337:     MOZ_COUNT_DTOR(mozilla::dom::workers::WorkerPrivate::TimeoutInfo);
74337:   }
74337: 
74337:   bool operator==(const TimeoutInfo& aOther)
74337:   {
74337:     return mTargetTime == aOther.mTargetTime;
74337:   }
74337: 
74337:   bool operator<(const TimeoutInfo& aOther)
74337:   {
74337:     return mTargetTime < aOther.mTargetTime;
74337:   }
74337: 
74337:   jsval mTimeoutVal;
74337:   nsTArray<jsval> mExtraArgVals;
74337:   mozilla::TimeStamp mTargetTime;
74337:   mozilla::TimeDuration mInterval;
74337:   nsCString mFilename;
74337:   PRUint32 mLineNumber;
74337:   PRUint32 mId;
74337:   bool mIsInterval;
74337:   bool mCanceled;
74337: };
74337: 
74337: template <class Derived>
74337: WorkerPrivateParent<Derived>::WorkerPrivateParent(
74337:                                      JSContext* aCx, JSObject* aObject,
74337:                                      WorkerPrivate* aParent,
74337:                                      JSContext* aParentJSContext,
74337:                                      const nsAString& aScriptURL,
74337:                                      bool aIsChromeWorker,
74337:                                      const nsACString& aDomain,
74337:                                      nsCOMPtr<nsPIDOMWindow>& aWindow,
74337:                                      nsCOMPtr<nsIScriptContext>& aScriptContext,
74337:                                      nsCOMPtr<nsIURI>& aBaseURI,
74337:                                      nsCOMPtr<nsIPrincipal>& aPrincipal,
74337:                                      nsCOMPtr<nsIDocument>& aDocument)
74337: : mMutex("WorkerPrivateParent Mutex"),
74337:   mCondVar(mMutex, "WorkerPrivateParent CondVar"),
74337:   mJSObject(aObject), mParent(aParent), mParentJSContext(aParentJSContext),
74337:   mScriptURL(aScriptURL), mDomain(aDomain), mBusyCount(0),
74337:   mParentStatus(Pending), mJSObjectRooted(false), mParentSuspended(false),
76372:   mIsChromeWorker(aIsChromeWorker), mPrincipalIsSystem(false)
74337: {
74337:   MOZ_COUNT_CTOR(mozilla::dom::workers::WorkerPrivateParent);
74337: 
74337:   if (aWindow) {
74337:     NS_ASSERTION(aWindow->IsInnerWindow(), "Should have inner window here!");
74337:   }
74337: 
74337:   mWindow.swap(aWindow);
74337:   mScriptContext.swap(aScriptContext);
74337:   mBaseURI.swap(aBaseURI);
74337:   mPrincipal.swap(aPrincipal);
74337:   mDocument.swap(aDocument);
74337: 
74337:   if (aParent) {
74337:     aParent->AssertIsOnWorkerThread();
74337: 
74337:     NS_ASSERTION(JS_GetOptions(aCx) == aParent->GetJSContextOptions(),
74337:                  "Options mismatch!");
74337:     mJSContextOptions = aParent->GetJSContextOptions();
74337: #ifdef JS_GC_ZEAL
74337:     mGCZeal = aParent->GetGCZeal();
74337: #endif
74337:   }
74337:   else {
74337:     AssertIsOnMainThread();
74337: 
74337:     mJSContextOptions = RuntimeService::GetDefaultJSContextOptions();
74337: #ifdef JS_GC_ZEAL
74337:     mGCZeal = RuntimeService::GetDefaultGCZeal();
74337: #endif
74337:   }
74337: }
74337: 
74337: template <class Derived>
74337: WorkerPrivateParent<Derived>::~WorkerPrivateParent()
74337: {
74337:   MOZ_COUNT_DTOR(mozilla::dom::workers::WorkerPrivateParent);
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::Start()
74337: {
74337:   // May be called on any thread!
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     NS_ASSERTION(mParentStatus != Running, "How can this be?!");
74337: 
74337:     if (mParentStatus == Pending) {
74337:       mParentStatus = Running;
74337:       return true;
74337:     }
74337:   }
74337: 
74337:   return false;
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::Notify(JSContext* aCx, Status aStatus)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   bool pending;
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mParentStatus >= aStatus) {
74337:       return true;
74337:     }
74337: 
74337:     pending = mParentStatus == Pending;
74337:     mParentStatus = aStatus;
74337:   }
74337: 
74337:   FinalizeInstance(aCx);
74337: 
74337:   if (pending) {
74337:     WorkerPrivate* self = ParentAsWorkerPrivate();
74337: #ifdef DEBUG
74337:     {
74337:       // Silence useless assertions in debug builds.
74337:       nsIThread* currentThread = NS_GetCurrentThread();
74337:       NS_ASSERTION(currentThread, "This should never be null!");
74337: 
74337:       self->SetThread(currentThread);
74337:     }
74337: #endif
74337:     // Worker never got a chance to run, go ahead and delete it.
74337:     self->ScheduleDeletion(true);
74337:     return true;
74337:   }
74337: 
74337:   NS_ASSERTION(aStatus != Terminating || mQueuedRunnables.IsEmpty(),
74337:                "Shouldn't have anything queued!");
74337: 
74337:   // Anything queued will be discarded.
74337:   mQueuedRunnables.Clear();
74337: 
74337:   nsRefPtr<NotifyRunnable> runnable =
74337:     new NotifyRunnable(ParentAsWorkerPrivate(), aStatus);
74337:   return runnable->Dispatch(aCx);
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::Suspend(JSContext* aCx)
74337: {
74337:   AssertIsOnParentThread();
74337:   NS_ASSERTION(!mParentSuspended, "Suspended more than once!");
74337: 
74337:   mParentSuspended = true;
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mParentStatus >= Terminating) {
74337:       return true;
74337:     }
74337:   }
74337: 
74337:   nsRefPtr<SuspendRunnable> runnable =
74337:     new SuspendRunnable(ParentAsWorkerPrivate());
74337:   return runnable->Dispatch(aCx);
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::Resume(JSContext* aCx)
74337: {
74337:   AssertIsOnParentThread();
74337:   NS_ASSERTION(mParentSuspended, "Not yet suspended!");
74337: 
74337:   mParentSuspended = false;
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mParentStatus >= Terminating) {
74337:       return true;
74337:     }
74337:   }
74337: 
74337:   // Dispatch queued runnables before waking up the worker, otherwise the worker
74337:   // could post new messages before we run those that have been queued.
74337:   if (!mQueuedRunnables.IsEmpty()) {
74337:     AssertIsOnMainThread();
74337: 
74337:     nsTArray<nsRefPtr<WorkerRunnable> > runnables;
74337:     mQueuedRunnables.SwapElements(runnables);
74337: 
74337:     for (PRUint32 index = 0; index < runnables.Length(); index++) {
74337:       nsRefPtr<WorkerRunnable>& runnable = runnables[index];
74337:       if (NS_FAILED(NS_DispatchToCurrentThread(runnable))) {
74337:         NS_WARNING("Failed to dispatch queued runnable!");
74337:       }
74337:     }
74337:   }
74337: 
74337:   nsRefPtr<ResumeRunnable> runnable =
74337:     new ResumeRunnable(ParentAsWorkerPrivate());
74337:   if (!runnable->Dispatch(aCx)) {
74337:     return false;
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::FinalizeInstance(JSContext* aCx)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   if (mJSObject) {
74337:     // Decouple the object from the private now.
74337:     SetJSPrivateSafeish(aCx, mJSObject, nsnull);
74337: 
74337:     // Clear the JS object.
74337:     mJSObject = nsnull;
74337: 
74337:     // Unroot.
74337:     RootJSObject(aCx, false);
74337: 
74337:     if (!Terminate(aCx)) {
74337:       NS_WARNING("Failed to terminate!");
74337:     }
74337: 
74337:     events::EventTarget::FinalizeInstance(aCx);
74337:   }
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::Close(JSContext* aCx)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mParentStatus < Closing) {
74337:       mParentStatus = Closing;
74337:     }
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::ModifyBusyCount(JSContext* aCx, bool aIncrease)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   NS_ASSERTION(aIncrease || mBusyCount, "Mismatched busy count mods!");
74337: 
74337:   if (aIncrease) {
74337:     if (mBusyCount++ == 0) {
74337:       if (!RootJSObject(aCx, true)) {
74337:         return false;
74337:       }
74337:     }
74337:     return true;
74337:   }
74337: 
74337:   if (--mBusyCount == 0) {
74337:     if (!RootJSObject(aCx, false)) {
74337:       return false;
74337:     }
74337: 
74337:     bool shouldCancel;
74337:     {
74337:       MutexAutoLock lock(mMutex);
74337:       shouldCancel = mParentStatus == Terminating;
74337:     }
74337: 
74337:     if (shouldCancel && !Cancel(aCx)) {
74337:       return false;
74337:     }
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::RootJSObject(JSContext* aCx, bool aRoot)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   if (aRoot) {
74337:     if (mJSObjectRooted || !mJSObject) {
74337:       return true;
74337:     }
74337: 
74337:     if (!JS_AddNamedObjectRoot(aCx, &mJSObject, "Worker root")) {
74337:       NS_WARNING("JS_AddNamedObjectRoot failed!");
74337:       return false;
74337:     }
74337:   }
74337:   else {
74337:     if (!mJSObjectRooted) {
74337:       return true;
74337:     }
74337: 
74337:     if (!JS_RemoveObjectRoot(aCx, &mJSObject)) {
74337:       NS_WARNING("JS_RemoveObjectRoot failed!");
74337:       return false;
74337:     }
74337:   }
74337: 
74337:   mJSObjectRooted = aRoot;
74337:   return true;
74337: }
74337: 
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::ForgetMainThreadObjects(
74337:                                       nsTArray<nsCOMPtr<nsISupports> >& aDoomed)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   aDoomed.SetCapacity(6);
74337: 
74337:   SwapToISupportsArray(mWindow, aDoomed);
74337:   SwapToISupportsArray(mScriptContext, aDoomed);
74337:   SwapToISupportsArray(mBaseURI, aDoomed);
74337:   SwapToISupportsArray(mScriptURI, aDoomed);
74337:   SwapToISupportsArray(mPrincipal, aDoomed);
74337:   SwapToISupportsArray(mDocument, aDoomed);
74337: }
74337: 
74337: template <class Derived>
74337: bool
74337: WorkerPrivateParent<Derived>::PostMessage(JSContext* aCx, jsval aMessage)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   JSStructuredCloneCallbacks* callbacks;
74337:   if (GetParent()) {
76372:     if (IsChromeWorker()) {
76372:       callbacks = &gChromeWorkerStructuredCloneCallbacks;
76372:     }
76372:     else {
76372:       callbacks = &gWorkerStructuredCloneCallbacks;
76372:     }
74337:   }
74337:   else {
74337:     AssertIsOnMainThread();
74337: 
74337:     if (IsChromeWorker()) {
74337:       callbacks = &gMainThreadChromeWorkerStructuredCloneCallbacks;
74337:     }
74337:     else {
74337:       callbacks = &gMainThreadWorkerStructuredCloneCallbacks;
74337:     }
74337:   }
74337: 
76372:   nsTArray<nsCOMPtr<nsISupports> > clonedObjects;
76372: 
74337:   JSAutoStructuredCloneBuffer buffer;
76372:   if (!buffer.write(aCx, aMessage, callbacks, &clonedObjects)) {
74337:     return false;
74337:   }
74337: 
74337:   nsRefPtr<MessageEventRunnable> runnable =
74337:     new MessageEventRunnable(ParentAsWorkerPrivate(),
76372:                              WorkerRunnable::WorkerThread, buffer,
76372:                              clonedObjects);
74337:   return runnable->Dispatch(aCx);
74337: }
74337: 
74337: template <class Derived>
74337: PRUint64
74337: WorkerPrivateParent<Derived>::GetOuterWindowId()
74337: {
74337:   AssertIsOnMainThread();
74337:   return mDocument->OuterWindowID();
74337: }
74337: 
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::UpdateJSContextOptions(JSContext* aCx,
74337:                                                      PRUint32 aOptions)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   mJSContextOptions = aOptions;
74337: 
74337:   nsRefPtr<UpdateJSContextOptionsRunnable> runnable =
74337:     new UpdateJSContextOptionsRunnable(ParentAsWorkerPrivate(), aOptions);
74337:   if (!runnable->Dispatch(aCx)) {
74337:     NS_WARNING("Failed to update worker context options!");
74337:     JS_ClearPendingException(aCx);
74337:   }
74337: }
74337: 
74337: #ifdef JS_GC_ZEAL
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::UpdateGCZeal(JSContext* aCx, PRUint8 aGCZeal)
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   mGCZeal = aGCZeal;
74337: 
74337:   nsRefPtr<UpdateGCZealRunnable> runnable =
74337:     new UpdateGCZealRunnable(ParentAsWorkerPrivate(), aGCZeal);
74337:   if (!runnable->Dispatch(aCx)) {
74337:     NS_WARNING("Failed to update worker gczeal!");
74337:     JS_ClearPendingException(aCx);
74337:   }
74337: }
74337: #endif
74337: 
74337: template <class Derived>
74337: nsresult
74337: WorkerPrivateParent<Derived>::SetBaseURI(nsIURI* aBaseURI)
74337: {
74337:   AssertIsOnMainThread();
74337: 
74337:   mBaseURI = aBaseURI;
74337: 
74337:   nsCOMPtr<nsIURL> url(do_QueryInterface(aBaseURI));
74337:   NS_ENSURE_TRUE(url, NS_ERROR_NO_INTERFACE);
74337: 
74337:   nsresult rv = url->GetSpec(mLocationInfo.mHref);
74337:   NS_ENSURE_SUCCESS(rv, rv);
74337: 
74337:   rv = url->GetHost(mLocationInfo.mHostname);
74337:   NS_ENSURE_SUCCESS(rv, rv);
74337: 
74337:   rv = url->GetPath(mLocationInfo.mPathname);
74337:   NS_ENSURE_SUCCESS(rv, rv);
74337: 
74337:   nsCString temp;
74337: 
74337:   rv = url->GetQuery(temp);
74337:   NS_ENSURE_SUCCESS(rv, rv);
74337: 
74337:   if (!temp.IsEmpty()) {
74337:     mLocationInfo.mSearch.AssignLiteral("?");
74337:     mLocationInfo.mSearch.Append(temp);
74337:   }
74337: 
74337:   rv = url->GetRef(temp);
74337:   NS_ENSURE_SUCCESS(rv, rv);
74337: 
74337:   if (!temp.IsEmpty()) {
74337:     nsAutoString unicodeRef;
74337: 
74337:     nsCOMPtr<nsITextToSubURI> converter =
74337:       do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
74337:     if (NS_SUCCEEDED(rv)) {
74337:       nsCString charset;
74337:       rv = url->GetOriginCharset(charset);
74337:       if (NS_SUCCEEDED(rv)) {
74337:         rv = converter->UnEscapeURIForUI(charset, temp, unicodeRef);
74337:         if (NS_SUCCEEDED(rv)) {
74337:           mLocationInfo.mHash.AssignLiteral("#");
74337:           mLocationInfo.mHash.Append(NS_ConvertUTF16toUTF8(unicodeRef));
74337:         }
74337:       }
74337:     }
74337: 
74337:     if (NS_FAILED(rv)) {
74337:       mLocationInfo.mHash.AssignLiteral("#");
74337:       mLocationInfo.mHash.Append(temp);
74337:     }
74337:   }
74337: 
74337:   rv = url->GetScheme(mLocationInfo.mProtocol);
74337:   NS_ENSURE_SUCCESS(rv, rv);
74337: 
74337:   mLocationInfo.mProtocol.AppendLiteral(":");
74337: 
74337:   PRInt32 port;
74337:   rv = url->GetPort(&port);
74337:   if (NS_SUCCEEDED(rv) && port != -1) {
74337:     mLocationInfo.mPort.AppendInt(port);
74337: 
74337:     nsCAutoString host(mLocationInfo.mHostname);
74337:     host.AppendLiteral(":");
74337:     host.Append(mLocationInfo.mPort);
74337: 
74337:     mLocationInfo.mHost.Assign(host);
74337:   }
74337:   else {
74337:     mLocationInfo.mHost.Assign(mLocationInfo.mHostname);
74337:   }
74337: 
74337:   return NS_OK;
74337: }
74337: 
74337: template <class Derived>
76372: void
76372: WorkerPrivateParent<Derived>::SetPrincipal(nsIPrincipal* aPrincipal)
76372: {
76372:   AssertIsOnMainThread();
76372: 
76372:   mPrincipal = aPrincipal;
76372:   mPrincipalIsSystem = nsContentUtils::IsSystemPrincipal(aPrincipal);
76372: }
76372: 
76372: template <class Derived>
74337: JSContext*
74337: WorkerPrivateParent<Derived>::ParentJSContext() const
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   if (!mParent) {
74337:     AssertIsOnMainThread();
74337: 
74337:     if (!mScriptContext) {
74337:       NS_ASSERTION(!mParentJSContext, "Shouldn't have a parent context!");
74337:       return RuntimeService::AutoSafeJSContext::GetSafeContext();
74337:     }
74337: 
74337:     NS_ASSERTION(mParentJSContext ==
74337:                  static_cast<JSContext*>(mScriptContext->GetNativeContext()),
74337:                  "Native context has changed!");
74337:   }
74337: 
74337:   return mParentJSContext;
74337: }
74337: 
74337: WorkerPrivate::WorkerPrivate(JSContext* aCx, JSObject* aObject,
74337:                              WorkerPrivate* aParent,
74337:                              JSContext* aParentJSContext,
74337:                              const nsAString& aScriptURL, bool aIsChromeWorker,
74337:                              const nsACString& aDomain,
74337:                              nsCOMPtr<nsPIDOMWindow>& aWindow,
74337:                              nsCOMPtr<nsIScriptContext>& aParentScriptContext,
74337:                              nsCOMPtr<nsIURI>& aBaseURI,
74337:                              nsCOMPtr<nsIPrincipal>& aPrincipal,
74337:                              nsCOMPtr<nsIDocument>& aDocument)
74337: : WorkerPrivateParent<WorkerPrivate>(aCx, aObject, aParent, aParentJSContext,
74337:                                      aScriptURL, aIsChromeWorker, aDomain,
74337:                                      aWindow, aParentScriptContext, aBaseURI,
74337:                                      aPrincipal, aDocument),
74337:   mJSContext(nsnull), mErrorHandlerRecursionCount(0), mNextTimeoutId(1),
74337:   mStatus(Pending), mSuspended(false), mTimerRunning(false),
74337:   mRunningExpiredTimeouts(false), mCloseHandlerStarted(false),
74337:   mCloseHandlerFinished(false)
74337: {
74337:   MOZ_COUNT_CTOR(mozilla::dom::workers::WorkerPrivate);
74337: }
74337: 
74337: WorkerPrivate::~WorkerPrivate()
74337: {
74337:   MOZ_COUNT_DTOR(mozilla::dom::workers::WorkerPrivate);
74337: }
74337: 
74337: // static
74337: WorkerPrivate*
74337: WorkerPrivate::Create(JSContext* aCx, JSObject* aObj, WorkerPrivate* aParent,
74337:                       JSString* aScriptURL, bool aIsChromeWorker)
74337: {
74337:   nsCString domain;
74337:   nsCOMPtr<nsIURI> baseURI;
74337:   nsCOMPtr<nsIPrincipal> principal;
74337:   nsCOMPtr<nsIScriptContext> scriptContext;
74337:   nsCOMPtr<nsIDocument> document;
74337:   nsCOMPtr<nsPIDOMWindow> window;
74337: 
74337:   JSContext* parentContext;
74337: 
74337:   if (aParent) {
74337:     aParent->AssertIsOnWorkerThread();
74337: 
74337:     parentContext = aCx;
74337: 
74337:     // Domain is the only thing we can touch here. The rest will be handled by
74337:     // the ScriptLoader.
74337:     domain = aParent->Domain();
74337:   }
74337:   else {
74337:     AssertIsOnMainThread();
74337: 
74337:     nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
74337:     NS_ASSERTION(ssm, "This should never be null!");
74337: 
74337:     PRBool isChrome;
74337:     if (NS_FAILED(ssm->IsCapabilityEnabled("UniversalXPConnect", &isChrome))) {
74337:       NS_WARNING("IsCapabilityEnabled failed!");
74337:       isChrome = PR_FALSE;
74337:     }
74337: 
74337:     // First check to make sure the caller has permission to make a
74337:     // ChromeWorker if they called the ChromeWorker constructor.
74337:     if (aIsChromeWorker && !isChrome) {
74337:       nsDOMClassInfo::ThrowJSException(aCx, NS_ERROR_DOM_SECURITY_ERR);
74337:       return nsnull;
74337:     }
74337: 
74337:     // Chrome callers (whether ChromeWorker of Worker) always get the system
74337:     // principal here as they're allowed to load anything. The script loader may
74337:     // change the principal later depending on the script uri.
74337:     if (isChrome &&
74337:         NS_FAILED(ssm->GetSystemPrincipal(getter_AddRefs(principal)))) {
74337:       JS_ReportError(aCx, "Could not get system principal!");
74337:       return nsnull;
74337:     }
74337: 
74337:     // See if we're being called from a window or from somewhere else.
74337:     nsCOMPtr<nsIScriptGlobalObject> scriptGlobal =
74337:       nsJSUtils::GetStaticScriptGlobal(aCx, JS_GetGlobalForScopeChain(aCx));
74337:     if (scriptGlobal) {
74337:       // Window!
74337:       nsCOMPtr<nsPIDOMWindow> globalWindow = do_QueryInterface(scriptGlobal);
74337: 
74337:       // Only use the current inner window, and only use it if the caller can
74337:       // access it.
74337:       nsPIDOMWindow* outerWindow = globalWindow ?
74337:                                    globalWindow->GetOuterWindow() :
74337:                                    nsnull;
74337:       window = outerWindow ? outerWindow->GetCurrentInnerWindow() : nsnull;
74337:       if (!window ||
74337:           (globalWindow != window &&
74337:            !nsContentUtils::CanCallerAccess(window))) {
74337:         nsDOMClassInfo::ThrowJSException(aCx, NS_ERROR_DOM_SECURITY_ERR);
74337:         return nsnull;
74337:       }
74337: 
74337:       scriptContext = scriptGlobal->GetContext();
74337:       if (!scriptContext) {
74337:         JS_ReportError(aCx, "Couldn't get script context for this worker!");
74337:         return nsnull;
74337:       }
74337: 
74337:       parentContext =
74337:         static_cast<JSContext*>(scriptContext->GetNativeContext());
74337: 
74337:       // If we're called from a window then we can dig out the principal and URI
74337:       // from the document.
74337:       document = do_QueryInterface(window->GetExtantDocument());
74337:       if (!document) {
74337:         JS_ReportError(aCx, "No document in this window!");
74337:         return nsnull;
74337:       }
74337: 
74337:       baseURI = document->GetDocBaseURI();
74337: 
74337:       // Use the document's NodePrincipal as our principal if we're not being
74337:       // called from chrome.
74337:       if (!principal) {
74337:         if (!(principal = document->NodePrincipal())) {
74337:           JS_ReportError(aCx, "Could not get document principal!");
74337:           return nsnull;
74337:         }
74337: 
74337:         nsCOMPtr<nsIURI> codebase;
74337:         if (NS_FAILED(principal->GetURI(getter_AddRefs(codebase)))) {
74337:           JS_ReportError(aCx, "Could not determine codebase!");
74337:           return nsnull;
74337:         }
74337: 
74337:         NS_NAMED_LITERAL_CSTRING(file, "file");
74337: 
74337:         PRBool isFile;
74337:         if (NS_FAILED(codebase->SchemeIs(file.get(), &isFile))) {
74337:           JS_ReportError(aCx, "Could not determine if codebase is file!");
74337:           return nsnull;
74337:         }
74337: 
74337:         if (isFile) {
74337:           // XXX Fix this, need a real domain here.
74337:           domain = file;
74337:         }
74337:         else {
74337:           nsCOMPtr<nsIEffectiveTLDService> tldService =
74337:             do_GetService(NS_EFFECTIVETLDSERVICE_CONTRACTID);
74337:           if (!tldService) {
74337:             JS_ReportError(aCx, "Could not get TLD service!");
74337:             return nsnull;
74337:           }
74337: 
74337:           if (NS_FAILED(tldService->GetBaseDomain(codebase, 0, domain))) {
74337:             JS_ReportError(aCx, "Could not get domain!");
74337:             return nsnull;
74337:           }
74337:         }
74337:       }
74337:     }
74337:     else {
74337:       // Not a window
74337:       NS_ASSERTION(isChrome, "Should be chrome only!");
74337: 
74337:       parentContext = nsnull;
74337: 
74337:       // We're being created outside of a window. Need to figure out the script
74337:       // that is creating us in order for us to use relative URIs later on.
74337:       JSStackFrame* frame = JS_GetScriptedCaller(aCx, nsnull);
74337:       if (frame) {
74337:         JSScript* script = JS_GetFrameScript(aCx, frame);
74337:         if (!script) {
74337:           JS_ReportError(aCx, "Could not get frame script!");
74337:           return nsnull;
74337:         }
74337:         if (NS_FAILED(NS_NewURI(getter_AddRefs(baseURI),
74337:                                 JS_GetScriptFilename(aCx, script)))) {
74337:           JS_ReportError(aCx, "Failed to construct base URI!");
74337:           return nsnull;
74337:         }
74337:       }
74337:     }
74337: 
74337:     NS_ASSERTION(principal, "Must have a principal now!");
74337: 
74337:     if (!isChrome && domain.IsEmpty()) {
74337:       NS_ERROR("Must be chrome or have an domain!");
74337:       return nsnull;
74337:     }
74337:   }
74337: 
74337:   size_t urlLength;
74337:   const jschar* urlChars = JS_GetStringCharsZAndLength(aCx, aScriptURL,
74337:                                                        &urlLength);
74337:   if (!urlChars) {
74337:     return nsnull;
74337:   }
74337: 
74337:   nsDependentString scriptURL(urlChars, urlLength);
74337: 
74337:   nsAutoPtr<WorkerPrivate> worker(
74337:     new WorkerPrivate(aCx, aObj, aParent, parentContext, scriptURL,
74337:                       aIsChromeWorker, domain, window, scriptContext, baseURI,
74337:                       principal, document));
74337: 
74337:   nsRefPtr<CompileScriptRunnable> compiler = new CompileScriptRunnable(worker);
74337:   if (!compiler->Dispatch(aCx)) {
74337:     return nsnull;
74337:   }
74337: 
74337:   return worker.forget();
74337: }
74337: 
74337: void
74337: WorkerPrivate::DoRunLoop(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337:     mJSContext = aCx;
74337: 
74337:     NS_ASSERTION(mStatus == Pending, "Huh?!");
74337:     mStatus = Running;
74337:   }
74337: 
74337:   for (;;) {
74337:     Status currentStatus;
74337:     nsIRunnable* event;
74337:     {
74337:       MutexAutoLock lock(mMutex);
74337: 
74337:       while (!mControlQueue.Pop(event) && !mQueue.Pop(event)) {
74337:         mCondVar.Wait();
74337:       }
74337: 
74337:       {
74337:         MutexAutoUnlock unlock(mMutex);
74337: 
74337: #ifdef EXTRA_GC
74337:         // Find GC bugs...
74337:         JS_GC(aCx);
74337: #endif
74337: 
74337:         event->Run();
74337:         NS_RELEASE(event);
74337:       }
74337: 
74337:       currentStatus = mStatus;
74337:     }
74337: 
74337: #ifdef EXTRA_GC
74337:     // Find GC bugs...
74337:     JS_GC(aCx);
74337: #endif
74337: 
74337:     if (currentStatus != Running && !HasActiveFeatures()) {
74337:       // If the close handler has finished and all features are done then we can
74337:       // kill this thread.
74337:       if (mCloseHandlerFinished && currentStatus != Killing) {
74337:         if (!NotifyInternal(aCx, Killing)) {
74337:           JS_ReportPendingException(aCx);
74337:         }
74337: #ifdef DEBUG
74337:         {
74337:           MutexAutoLock lock(mMutex);
74337:           currentStatus = mStatus;
74337:         }
74337:         NS_ASSERTION(currentStatus == Killing, "Should have changed status!");
74337: #else
74337:         currentStatus = Killing;
74337: #endif
74337:       }
74337: 
74337:       // If we're supposed to die then we should exit the loop.
74337:       if (currentStatus == Killing) {
74337:         StopAcceptingEvents();
74337:         return;
74337:       }
74337:     }
74337:   }
74337: 
74337:   NS_NOTREACHED("Shouldn't get here!");
74337: }
74337: 
74337: bool
74337: WorkerPrivate::OperationCallback(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   bool mayContinue = true;
74337: 
74337:   for (;;) {
74337:     // Run all control events now.
74337:     for (;;) {
74337:       nsIRunnable* event;
74337:       {
74337:         MutexAutoLock lock(mMutex);
74337:         if (!mControlQueue.Pop(event)) {
74337:           break;
74337:         }
74337:       }
74337: 
74337:       if (NS_FAILED(event->Run())) {
74337:         mayContinue = false;
74337:       }
74337: 
74337:       NS_RELEASE(event);
74337:     }
74337: 
74337:     if (!mayContinue || !mSuspended) {
74337:       break;
74337:     }
74337: 
74337:     // Clean up before suspending.
74337:     JS_FlushCaches(aCx);
74337:     JS_GC(aCx);
74337: 
74337:     while ((mayContinue = MayContinueRunning())) {
74337:       MutexAutoLock lock(mMutex);
74337:       if (!mControlQueue.IsEmpty()) {
74337:         break;
74337:       }
74674: 
74337:       mCondVar.Wait(PR_MillisecondsToInterval(RemainingRunTimeMS()));
74337:     }
74337:   }
74337: 
74337:   if (!mayContinue) {
74337:     // We want only uncatchable exceptions here.
74337:     NS_ASSERTION(!JS_IsExceptionPending(aCx),
74337:                  "Should not have an exception set here!");
74337:     return false;
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::ScheduleDeletion(bool aWasPending)
74337: {
74337:   AssertIsOnWorkerThread();
74337:   NS_ASSERTION(mChildWorkers.IsEmpty(), "Live child workers!");
74337:   NS_ASSERTION(mSyncQueues.IsEmpty(), "Should have no sync queues here!");
74337: 
74337:   StopAcceptingEvents();
74337: 
74337:   nsIThread* currentThread;
74337:   if (aWasPending) {
74337:     // Don't want to close down this thread since we never got to run!
74337:     currentThread = nsnull;
74337:   }
74337:   else {
74337:     currentThread = NS_GetCurrentThread();
74337:     NS_ASSERTION(currentThread, "This should never be null!");
74337:   }
74337: 
74337:   WorkerPrivate* parent = GetParent();
74337:   if (parent) {
74337:     nsRefPtr<WorkerFinishedRunnable> runnable =
74337:       new WorkerFinishedRunnable(parent, this, currentThread);
74337:     if (!runnable->Dispatch(nsnull)) {
74337:       NS_WARNING("Failed to dispatch runnable!");
74337:     }
74337:   }
74337:   else {
74337:     nsRefPtr<TopLevelWorkerFinishedRunnable> runnable =
74337:       new TopLevelWorkerFinishedRunnable(this, currentThread);
74337:     if (NS_FAILED(NS_DispatchToMainThread(runnable, NS_DISPATCH_NORMAL))) {
74337:       NS_WARNING("Failed to dispatch runnable!");
74337:     }
74337:   }
74337: }
74337: 
74337: bool
75066: WorkerPrivate::BlockAndCollectRuntimeStats(IterateData* aData)
75066: {
75066:   AssertIsOnMainThread();
75066:   mMutex.AssertNotCurrentThreadOwns();
75066:   NS_ASSERTION(aData, "Null data!");
75066: 
75066:   mozilla::Mutex mutex("BlockAndCollectRuntimeStats mutex");
75066:   mozilla::CondVar condvar(mutex, "BlockAndCollectRuntimeStats condvar");
75066:   volatile bool doneFlag = false;
75066:   volatile bool succeeded = false;
75066: 
75066:   nsRefPtr<CollectRuntimeStatsRunnable> runnable =
75066:     new CollectRuntimeStatsRunnable(this, &mutex, &condvar, &doneFlag, aData,
75066:                                     &succeeded);
75066:   if (!runnable->Dispatch(nsnull)) {
75066:     NS_WARNING("Failed to dispatch runnable!");
75066:     return false;
75066:   }
75066: 
75066:   {
75066:     MutexAutoLock lock(mutex);
75066:     while (!doneFlag) {
75066:       condvar.Wait();
75066:     }
75066:   }
75066: 
75066:   return succeeded;
75066: }
75066: 
75066: bool
74337: WorkerPrivate::Dispatch(WorkerRunnable* aEvent, EventQueue* aQueue)
74337: {
74337:   nsRefPtr<WorkerRunnable> event(aEvent);
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mStatus == Dead) {
74337:       // Nothing may be added after we've set Dead.
74337:       return false;
74337:     }
74337: 
74337:     if (aQueue == &mQueue) {
74337:       // Check parent status.
74337:       Status parentStatus = ParentStatus();
74337:       if (parentStatus >= Terminating) {
74337:         // Throw.
74337:         return false;
74337:       }
74337: 
74337:       // Check inner status too.
74337:       if (parentStatus >= Closing || mStatus >= Closing) {
74337:         // Silently eat this one.
74337:         return true;
74337:       }
74337:     }
74337: 
74337:     if (!aQueue->Push(event)) {
74337:       return false;
74337:     }
74337: 
74337:     if (aQueue == &mControlQueue && mJSContext) {
74337:       JS_TriggerOperationCallback(mJSContext);
74337:     }
74337: 
74337:     mCondVar.Notify();
74337:   }
74337: 
74337:   event.forget();
74337:   return true;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::DispatchToSyncQueue(WorkerSyncRunnable* aEvent)
74337: {
74337:   nsRefPtr<WorkerRunnable> event(aEvent);
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     NS_ASSERTION(mSyncQueues.Length() > aEvent->mSyncQueueKey, "Bad event!");
74337: 
74337:     if (!mSyncQueues[aEvent->mSyncQueueKey]->mQueue.Push(event)) {
74337:       return false;
74337:     }
74337: 
74337:     mCondVar.Notify();
74337:   }
74337: 
74337:   event.forget();
74337:   return true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::ClearQueue(EventQueue* aQueue)
74337: {
74337:   AssertIsOnWorkerThread();
74337:   mMutex.AssertCurrentThreadOwns();
74337: 
74337:   nsIRunnable* event;
74337:   while (aQueue->Pop(event)) {
74337:     event->Release();
74337:   }
74337: }
74337: 
74337: PRUint32
74337: WorkerPrivate::RemainingRunTimeMS() const
74337: {
74337:   if (mKillTime.IsNull()) {
74337:     return PR_UINT32_MAX;
74337:   }
74337:   TimeDuration runtime = mKillTime - TimeStamp::Now();
74337:   double ms = runtime > TimeDuration(0) ? runtime.ToMilliseconds() : 0;
74337:   return ms > double(PR_UINT32_MAX) ? PR_UINT32_MAX : PRUint32(ms);
74337: }
74337: 
74337: bool
74337: WorkerPrivate::SuspendInternal(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(!mSuspended, "Already suspended!");
74337: 
74337:   mSuspended = true;
74337:   return true;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::ResumeInternal(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(mSuspended, "Not yet suspended!");
74337: 
74337:   mSuspended = false;
74337:   return true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::TraceInternal(JSTracer* aTrc)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   for (PRUint32 index = 0; index < mTimeouts.Length(); index++) {
74337:     TimeoutInfo* info = mTimeouts[index];
74337:     JS_CALL_VALUE_TRACER(aTrc, info->mTimeoutVal,
74337:                          "WorkerPrivate timeout value");
74337:     for (PRUint32 index2 = 0; index2 < info->mExtraArgVals.Length(); index2++) {
74337:       JS_CALL_VALUE_TRACER(aTrc, info->mExtraArgVals[index2],
74337:                            "WorkerPrivate timeout extra argument value");
74337:     }
74337:   }
74337: }
74337: 
74337: bool
74337: WorkerPrivate::ModifyBusyCountFromWorker(JSContext* aCx, bool aIncrease)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     // If we're in shutdown then the busy count is no longer being considered so
74337:     // just return now.
74337:     if (mStatus >= Killing) {
74337:       return true;
74337:     }
74337:   }
74337: 
74337:   nsRefPtr<ModifyBusyCountRunnable> runnable =
74337:     new ModifyBusyCountRunnable(this, aIncrease);
74337:   return runnable->Dispatch(aCx);
74337: }
74337: 
74337: bool
74337: WorkerPrivate::AddChildWorker(JSContext* aCx, ParentType* aChildWorker)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   Status currentStatus;
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337:     currentStatus = mStatus;
74337:   }
74337: 
74337:   if (currentStatus > Running) {
74337:     JS_ReportError(aCx, "Cannot create child workers from the close handler!");
74337:     return false;
74337:   }
74337: 
74337:   NS_ASSERTION(!mChildWorkers.Contains(aChildWorker),
74337:                "Already know about this one!");
74337:   mChildWorkers.AppendElement(aChildWorker);
74337: 
74337:   return mChildWorkers.Length() == 1 ?
74337:          ModifyBusyCountFromWorker(aCx, true) :
74337:          true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::RemoveChildWorker(JSContext* aCx, ParentType* aChildWorker)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(mChildWorkers.Contains(aChildWorker),
74337:                "Didn't know about this one!");
74337:   mChildWorkers.RemoveElement(aChildWorker);
74337: 
74337:   if (mChildWorkers.IsEmpty() && !ModifyBusyCountFromWorker(aCx, false)) {
74337:     NS_WARNING("Failed to modify busy count!");
74337:   }
74337: }
74337: 
74337: bool
74337: WorkerPrivate::AddFeature(JSContext* aCx, WorkerFeature* aFeature)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mStatus >= Canceling) {
74337:       return false;
74337:     }
74337:   }
74337: 
74337:   NS_ASSERTION(!mFeatures.Contains(aFeature), "Already know about this one!");
74337:   mFeatures.AppendElement(aFeature);
74337: 
74337:   return mFeatures.Length() == 1 ?
74337:          ModifyBusyCountFromWorker(aCx, true) :
74337:          true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::RemoveFeature(JSContext* aCx, WorkerFeature* aFeature)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(mFeatures.Contains(aFeature), "Didn't know about this one!");
74337:   mFeatures.RemoveElement(aFeature);
74337: 
74337:   if (mFeatures.IsEmpty() && !ModifyBusyCountFromWorker(aCx, false)) {
74337:     NS_WARNING("Failed to modify busy count!");
74337:   }
74337: }
74337: 
74337: void
74337: WorkerPrivate::NotifyFeatures(JSContext* aCx, Status aStatus)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(aStatus > Running, "Bad status!");
74337: 
74337:   if (aStatus >= Closing) {
74337:     CancelAllTimeouts(aCx);
74337:   }
74337: 
74337:   nsAutoTArray<WorkerFeature*, 30> features;
74337:   features.AppendElements(mFeatures);
74337: 
74337:   for (PRUint32 index = 0; index < features.Length(); index++) {
74337:     if (!features[index]->Notify(aCx, aStatus)) {
74337:       NS_WARNING("Failed to notify feature!");
74337:     }
74337:   }
74337: 
74337:   nsAutoTArray<ParentType*, 10> children;
74337:   children.AppendElements(mChildWorkers);
74337: 
74337:   for (PRUint32 index = 0; index < children.Length(); index++) {
74337:     if (!children[index]->Notify(aCx, aStatus)) {
74337:       NS_WARNING("Failed to notify child worker!");
74337:     }
74337:   }
74337: }
74337: 
74337: void
74337: WorkerPrivate::CancelAllTimeouts(JSContext* aCx)
74337: {
74337:   if (mTimerRunning) {
74337:     NS_ASSERTION(mTimer, "Huh?!");
74337:     NS_ASSERTION(!mTimeouts.IsEmpty(), "Huh?!");
74337: 
74337:     if (NS_FAILED(mTimer->Cancel())) {
74337:       NS_WARNING("Failed to cancel timer!");
74337:     }
74337: 
74337:     for (PRUint32 index = 0; index < mTimeouts.Length(); index++) {
74337:       mTimeouts[index]->mCanceled = true;
74337:     }
74337: 
74337:     RunExpiredTimeouts(aCx);
74337: 
74337:     mTimer = nsnull;
74337:   }
74337:   else {
74337:     NS_ASSERTION(mTimeouts.IsEmpty(), "Huh?!");
74337:   }
74337: }
74337: 
74337: PRUint32
74337: WorkerPrivate::CreateNewSyncLoop()
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(mSyncQueues.Length() < PR_UINT32_MAX,
74337:                "Should have bailed by now!");
74337: 
74337:   mSyncQueues.AppendElement(new SyncQueue());
74337:   return mSyncQueues.Length() - 1;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::RunSyncLoop(JSContext* aCx, PRUint32 aSyncLoopKey)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(!mSyncQueues.IsEmpty() ||
74337:                (aSyncLoopKey != mSyncQueues.Length() - 1),
74337:                "Forgot to call CreateNewSyncLoop!");
74337:   if (aSyncLoopKey != mSyncQueues.Length() - 1) {
74337:     return false;
74337:   }
74337: 
74337:   SyncQueue* syncQueue = mSyncQueues[aSyncLoopKey].get();
74337: 
74337:   for (;;) {
74337:     nsIRunnable* event;
74337:     {
74337:       MutexAutoLock lock(mMutex);
74337: 
74337:       while (!mControlQueue.Pop(event) && !syncQueue->mQueue.Pop(event)) {
74337:         mCondVar.Wait();
74337:       }
74337:     }
74337: 
74337: #ifdef EXTRA_GC
74337:     // Find GC bugs...
74337:     JS_GC(mJSContext);
74337: #endif
74337: 
74337:     event->Run();
74337:     NS_RELEASE(event);
74337: 
74337: #ifdef EXTRA_GC
74337:     // Find GC bugs...
74337:     JS_GC(mJSContext);
74337: #endif
74337: 
74337:     if (syncQueue->mComplete) {
74337:       NS_ASSERTION(mSyncQueues.Length() - 1 == aSyncLoopKey,
74337:                    "Mismatched calls!");
74337:       NS_ASSERTION(syncQueue->mQueue.IsEmpty(), "Unprocessed sync events!");
74337: 
74337:       bool result = syncQueue->mResult;
74337:       mSyncQueues.RemoveElementAt(aSyncLoopKey);
74337: 
74337: #ifdef DEBUG
74337:       syncQueue = nsnull;
74337: #endif
74337: 
74337:       return result;
74337:     }
74337:   }
74337: 
74337:   NS_NOTREACHED("Shouldn't get here!");
74337:   return false;
74337: }
74337: 
74337: void
74337: WorkerPrivate::StopSyncLoop(PRUint32 aSyncLoopKey, bool aSyncResult)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(mSyncQueues.IsEmpty() ||
74337:                (aSyncLoopKey == mSyncQueues.Length() - 1),
74337:                "Forgot to call CreateNewSyncLoop!");
74337:   if (aSyncLoopKey != mSyncQueues.Length() - 1) {
74337:     return;
74337:   }
74337: 
74337:   SyncQueue* syncQueue = mSyncQueues[aSyncLoopKey].get();
74337: 
74337:   NS_ASSERTION(!syncQueue->mComplete, "Already called StopSyncLoop?!");
74337: 
74337:   syncQueue->mResult = aSyncResult;
74337:   syncQueue->mComplete = true;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::PostMessageToParent(JSContext* aCx, jsval aMessage)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
76372:   JSStructuredCloneCallbacks* callbacks =
76372:     IsChromeWorker() ?
76372:     &gChromeWorkerStructuredCloneCallbacks :
76372:     &gWorkerStructuredCloneCallbacks;
76372: 
76372:   nsTArray<nsCOMPtr<nsISupports> > clonedObjects;
76372: 
74337:   JSAutoStructuredCloneBuffer buffer;
76372:   if (!buffer.write(aCx, aMessage, callbacks, &clonedObjects)) {
74337:     return false;
74337:   }
74337: 
74337:   nsRefPtr<MessageEventRunnable> runnable =
76372:     new MessageEventRunnable(this, WorkerRunnable::ParentThread, buffer,
76372:                              clonedObjects);
74337:   return runnable->Dispatch(aCx);
74337: }
74337: 
74337: bool
74337: WorkerPrivate::NotifyInternal(JSContext* aCx, Status aStatus)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   NS_ASSERTION(aStatus > Running && aStatus < Dead, "Bad status!");
74337: 
74337:   // Save the old status and set the new status.
74337:   Status previousStatus;
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337: 
74337:     if (mStatus >= aStatus) {
74337:       return true;
74337:     }
74337: 
74337:     previousStatus = mStatus;
74337:     mStatus = aStatus;
74337:   }
74337: 
74337:   NS_ASSERTION(previousStatus != Pending, "How is this possible?!");
74337: 
74337:   NS_ASSERTION(previousStatus >= Canceling || mKillTime.IsNull(),
74337:                "Bad kill time set!");
74337: 
74337:   // Let all our features know the new status.
74337:   NotifyFeatures(aCx, aStatus);
74337: 
74337:   // There's nothing to do here if we never succeeded in running the worker
74337:   // script or if the close handler has already run.
74337:   if (!JS_GetGlobalObject(aCx) || mCloseHandlerFinished) {
74337:     return true;
74337:   }
74337: 
74337:   // If this is the first time our status has changed then we need to clear the
74337:   // main event queue. We also need to schedule the close handler unless we're
74337:   // being shut down.
74337:   if (previousStatus == Running) {
74337:     NS_ASSERTION(!mCloseHandlerStarted && !mCloseHandlerFinished,
74337:                  "This is impossible!");
74337: 
74337:     {
74337:       MutexAutoLock lock(mMutex);
74337:       ClearQueue(&mQueue);
74337:     }
74337: 
74337:     if (aStatus != Killing) {
74337:       nsRefPtr<CloseEventRunnable> closeRunnable = new CloseEventRunnable(this);
74337: 
74337:       MutexAutoLock lock(mMutex);
74337: 
74337:       if (!mQueue.Push(closeRunnable)) {
74337:         NS_WARNING("Failed to push closeRunnable!");
74337:         return false;
74337:       }
74337: 
74337:       closeRunnable.forget();
74337:     }
74337:   }
74337: 
74337:   if (aStatus == Closing) {
74337:     // Notify parent to stop sending us messages and balance our busy count.
74337:     nsRefPtr<CloseRunnable> runnable = new CloseRunnable(this);
74337:     if (!runnable->Dispatch(aCx)) {
74337:       return false;
74337:     }
74337: 
74337:     // Don't abort the script.
74337:     return true;
74337:   }
74337: 
74337:   if (aStatus == Terminating) {
74337:     // Only abort the script if we're not yet running the close handler.
74337:     return mCloseHandlerStarted;
74337:   }
74337: 
74337:   if (aStatus == Canceling) {
74337:     // We need to enforce a timeout on the close handler.
74337:     NS_ASSERTION(previousStatus == Running || previousStatus == Closing ||
74337:                  previousStatus == Terminating,
74337:                  "Bad previous status!");
74337: 
74337:     PRUint32 killSeconds = RuntimeService::GetCloseHandlerTimeoutSeconds();
74337:     if (killSeconds) {
74337:       mKillTime = TimeStamp::Now() + TimeDuration::FromSeconds(killSeconds);
74337: 
74337:       if (!mCloseHandlerFinished && !ScheduleKillCloseEventRunnable(aCx)) {
74337:         return false;
74337:       }
74337:     }
74337: 
74337:     // Only abort the script if we're not yet running the close handler.
74337:     return mCloseHandlerStarted;
74337:   }
74337: 
74337:   if (aStatus == Killing) {
74337:     mKillTime = TimeStamp::Now();
74337: 
74337:     if (!mCloseHandlerFinished && !ScheduleKillCloseEventRunnable(aCx)) {
74337:       return false;
74337:     }
74337: 
74337:     // Always abort the script.
74337:     return false;
74337:   }
74337: 
74337:   NS_NOTREACHED("Should never get here!");
74337:   return false;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::ScheduleKillCloseEventRunnable(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337:   NS_ASSERTION(!mKillTime.IsNull(), "Must have a kill time!");
74337: 
74337:   nsRefPtr<KillCloseEventRunnable> killCloseEventRunnable =
74337:     new KillCloseEventRunnable(this);
74337:   if (!killCloseEventRunnable->SetTimeout(aCx, RemainingRunTimeMS())) {
74337:     return false;
74337:   }
74337: 
74337:   MutexAutoLock lock(mMutex);
74337: 
74337:   if (!mQueue.Push(killCloseEventRunnable)) {
74337:     NS_WARNING("Failed to push killCloseEventRunnable!");
74337:     return false;
74337:   }
74337: 
74337:   killCloseEventRunnable.forget();
74337:   return true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::ReportError(JSContext* aCx, const char* aMessage,
74337:                            JSErrorReport* aReport)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   if (!MayContinueRunning() || mErrorHandlerRecursionCount == 2) {
74337:     return;
74337:   }
74337: 
74337:   NS_ASSERTION(mErrorHandlerRecursionCount == 0 ||
74337:                mErrorHandlerRecursionCount == 1,
74337:                "Bad recursion logic!");
74337: 
74337:   JS_ClearPendingException(aCx);
74337: 
74337:   nsString message, filename, line;
74337:   PRUint32 lineNumber, columnNumber, flags, errorNumber;
74337: 
74337:   if (aReport) {
74337:     // Can't do anything here if we're out of memory.
74337:     if (aReport->errorNumber == JSMSG_OUT_OF_MEMORY) {
74337:       NS_WARNING("Out of memory!");
74337:       return;
74337:     }
74337: 
74337:     if (aReport->ucmessage) {
74337:       message = aReport->ucmessage;
74337:     }
74337:     filename = NS_ConvertUTF8toUTF16(aReport->filename);
74337:     line = aReport->uclinebuf;
74337:     lineNumber = aReport->lineno;
74337:     columnNumber = aReport->uctokenptr - aReport->uclinebuf;
74337:     flags = aReport->flags;
74337:     errorNumber = aReport->errorNumber;
74337:   }
74337:   else {
74337:     lineNumber = columnNumber = errorNumber = 0;
74337:     flags = nsIScriptError::errorFlag | nsIScriptError::exceptionFlag;
74337:   }
74337: 
74337:   if (message.IsEmpty()) {
74337:     message = NS_ConvertUTF8toUTF16(aMessage);
74337:   }
74337: 
74337:   mErrorHandlerRecursionCount++;
74337: 
74337:   // Don't want to run the scope's error handler if this is a recursive error or
74337:   // if there was an error in the close handler.
74337:   bool fireAtScope = mErrorHandlerRecursionCount == 1 &&
74337:                      !mCloseHandlerStarted;
74337: 
74337:   if (!ReportErrorRunnable::ReportError(aCx, this, fireAtScope, nsnull, message,
74337:                                         filename, line, lineNumber,
74337:                                         columnNumber, flags, errorNumber, 0)) {
74337:     JS_ReportPendingException(aCx);
74337:   }
74337: 
74337:   mErrorHandlerRecursionCount--;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::SetTimeout(JSContext* aCx, uintN aArgc, jsval* aVp,
74337:                           bool aIsInterval)
74337: {
74337:   AssertIsOnWorkerThread();
74337:   NS_ASSERTION(aArgc, "Huh?!");
74337: 
74337:   const PRUint32 timerId = mNextTimeoutId++;
74337: 
74337:   Status currentStatus;
74337:   {
74337:     MutexAutoLock lock(mMutex);
74337:     currentStatus = mStatus;
74337:   }
74337: 
74337:   if (currentStatus > Running) {
74337:     JS_ReportError(aCx, "Cannot schedule timeouts from the close handler!");
74337:     return false;
74337:   }
74337: 
74337:   nsAutoPtr<TimeoutInfo> newInfo(new TimeoutInfo());
74337:   newInfo->mIsInterval = aIsInterval;
74337:   newInfo->mId = timerId;
74337: 
74337:   if (NS_UNLIKELY(timerId == PR_UINT32_MAX)) {
74337:     NS_WARNING("Timeout ids overflowed!");
74337:     mNextTimeoutId = 1;
74337:   }
74337: 
74337:   jsval* argv = JS_ARGV(aCx, aVp);
74337: 
74337:   // Take care of the main argument.
74337:   if (JSVAL_IS_OBJECT(argv[0])) {
74337:     if (JS_ObjectIsCallable(aCx, JSVAL_TO_OBJECT(argv[0]))) {
74337:       newInfo->mTimeoutVal = argv[0];
74337:     }
74337:     else {
74337:       JSString* timeoutStr = JS_ValueToString(aCx, argv[0]);
74337:       if (!timeoutStr) {
74337:         return false;
74337:       }
74337:       newInfo->mTimeoutVal = STRING_TO_JSVAL(timeoutStr);
74337:     }
74337:   }
74337:   else if (JSVAL_IS_STRING(argv[0])) {
74337:     newInfo->mTimeoutVal = argv[0];
74337:   }
74337:   else {
74337:     JS_ReportError(aCx, "Useless %s call (missing quotes around argument?)",
74337:                    aIsInterval ? "setInterval" : "setTimeout");
74337:     return false;
74337:   }
74337: 
74337:   // See if any of the optional arguments were passed.
74337:   if (aArgc > 1) {
74337:     jsdouble intervalMS = 0;
74337:     if (!JS_ValueToNumber(aCx, argv[1], &intervalMS)) {
74337:       return false;
74337:     }
74337:     newInfo->mInterval = TimeDuration::FromMilliseconds(intervalMS);
74337: 
74337:     if (aArgc > 2 && JSVAL_IS_OBJECT(newInfo->mTimeoutVal)) {
74337:       nsTArray<jsval> extraArgVals(aArgc - 2);
74337:       for (uintN index = 2; index < aArgc; index++) {
74337:         extraArgVals.AppendElement(argv[index]);
74337:       }
74337:       newInfo->mExtraArgVals.SwapElements(extraArgVals);
74337:     }
74337:   }
74337: 
74337:   newInfo->mTargetTime = TimeStamp::Now() + newInfo->mInterval;
74337: 
74337:   if (JSVAL_IS_STRING(newInfo->mTimeoutVal)) {
74337:     const char* filenameChars;
74337:     PRUint32 lineNumber;
74337:     if (nsJSUtils::GetCallingLocation(aCx, &filenameChars, &lineNumber)) {
74337:       newInfo->mFilename = filenameChars;
74337:       newInfo->mLineNumber = lineNumber;
74337:     }
74337:     else {
74337:       NS_WARNING("Failed to get calling location!");
74337:     }
74337:   }
74337: 
74337:   mTimeouts.InsertElementSorted(newInfo.get(), GetAutoPtrComparator(mTimeouts));
74337: 
74337:   // If the timeout we just made is set to fire next then we need to update the
74337:   // timer.
74337:   if (mTimeouts[0] == newInfo) {
74337:     nsresult rv;
74337: 
74337:     if (!mTimer) {
74337:       mTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
74337:       if (NS_FAILED(rv)) {
74337:         JS_ReportError(aCx, "Failed to create timer!");
74337:         return false;
74337:       }
74337: 
74337:       nsRefPtr<TimerRunnable> timerRunnable = new TimerRunnable(this);
74337: 
74337:       nsCOMPtr<nsIEventTarget> target =
74337:         new WorkerRunnableEventTarget(timerRunnable);
74337:       rv = mTimer->SetTarget(target);
74337:       if (NS_FAILED(rv)) {
74337:         JS_ReportError(aCx, "Failed to set timer's target!");
74337:         return false;
74337:       }
74337:     }
74337: 
74337:     if (!mTimerRunning) {
74337:       if (!ModifyBusyCountFromWorker(aCx, true)) {
74337:         return false;
74337:       }
74337:       mTimerRunning = true;
74337:     }
74337: 
74337:     if (!RescheduleTimeoutTimer(aCx)) {
74337:       return false;
74337:     }
74337:   }
74337: 
74337:   JS_SET_RVAL(aCx, aVp, INT_TO_JSVAL(timerId));
74337: 
74337:   newInfo.forget();
74337:   return true;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::ClearTimeout(JSContext* aCx, uint32 aId)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   if (!mTimeouts.IsEmpty()) {
74337:     NS_ASSERTION(mTimerRunning, "Huh?!");
74337: 
74337:     for (PRUint32 index = 0; index < mTimeouts.Length(); index++) {
74337:       nsAutoPtr<TimeoutInfo>& info = mTimeouts[index];
74337:       if (info->mId == aId) {
74337:         info->mCanceled = true;
74337:         break;
74337:       }
74337:     }
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::RunExpiredTimeouts(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   // We may be called recursively (e.g. close() inside a timeout) or we could
74337:   // have been canceled while this event was pending, bail out if there is
74337:   // nothing to do.
74337:   if (mRunningExpiredTimeouts || !mTimerRunning) {
74337:     return true;
74337:   }
74337: 
74337:   NS_ASSERTION(!mTimeouts.IsEmpty(), "Should have some work to do!");
74337: 
74337:   bool retval = true;
74337: 
76454:   AutoPtrComparator<TimeoutInfo> comparator = GetAutoPtrComparator(mTimeouts);
76454:   JSObject* global = JS_GetGlobalObject(aCx);
76454:   JSPrincipals* principal = GetWorkerPrincipal();
74337: 
74337:   // We want to make sure to run *something*, even if the timer fired a little
74337:   // early. Fudge the value of now to at least include the first timeout.
76454:   const TimeStamp now = NS_MAX(TimeStamp::Now(), mTimeouts[0]->mTargetTime);
74337: 
74337:   nsAutoTArray<TimeoutInfo*, 10> expiredTimeouts;
74337:   for (PRUint32 index = 0; index < mTimeouts.Length(); index++) {
74337:     nsAutoPtr<TimeoutInfo>& info = mTimeouts[index];
76454:     if (info->mTargetTime > now) {
76454:       break;
76454:     }
74337:     expiredTimeouts.AppendElement(info);
74337:   }
74337: 
74337:   // Guard against recursion.
74337:   mRunningExpiredTimeouts = true;
74337: 
74337:   // Run expired timeouts.
74337:   for (PRUint32 index = 0; index < expiredTimeouts.Length(); index++) {
74337:     TimeoutInfo*& info = expiredTimeouts[index];
74337: 
74337:     if (info->mCanceled) {
74337:       continue;
74337:     }
74337: 
76454:     // Always call JS_ReportPendingException if something fails, and if
76454:     // JS_ReportPendingException returns false (i.e. uncatchable exception) then
76454:     // break out of the loop.
74337: 
74337:     if (JSVAL_IS_STRING(info->mTimeoutVal)) {
74337:       JSString* expression = JSVAL_TO_STRING(info->mTimeoutVal);
74337: 
74337:       size_t stringLength;
74337:       const jschar* string = JS_GetStringCharsAndLength(aCx, expression,
74337:                                                         &stringLength);
76454: 
76454:       if ((!string ||
76454:            !JS_EvaluateUCScriptForPrincipals(aCx, global, principal, string,
76454:                                              stringLength,
76454:                                              info->mFilename.get(),
76454:                                              info->mLineNumber, nsnull)) &&
76454:           !JS_ReportPendingException(aCx)) {
74337:         retval = false;
74337:         break;
74337:       }
74337:     }
74337:     else {
74337:       jsval rval;
74337:       if (!JS_CallFunctionValue(aCx, global, info->mTimeoutVal,
74337:                                 info->mExtraArgVals.Length(),
76454:                                 info->mExtraArgVals.Elements(), &rval) &&
76454:           !JS_ReportPendingException(aCx)) {
74337:         retval = false;
74337:         break;
74337:       }
74337:     }
76454: 
76454:     // Reschedule intervals.
76454:     if (info->mIsInterval) {
76454:       PRUint32 timeoutIndex = mTimeouts.IndexOf(info);
76454:       NS_ASSERTION(timeoutIndex != PRUint32(-1),
76454:                    "Should still be in the main list!");
76454: 
76454:       mTimeouts[timeoutIndex].forget();
76454:       mTimeouts.RemoveElementAt(timeoutIndex);
76454: 
76454:       NS_ASSERTION(!mTimeouts.Contains(info), "Shouldn't have duplicates!");
76454: 
76454:       info->mTargetTime += info->mInterval;
76454:       mTimeouts.InsertElementSorted(info, comparator);
74337:     }
74337:   }
74337: 
74337:   // No longer possible to be called recursively.
74337:   mRunningExpiredTimeouts = false;
74337: 
76454:   // Now remove canceled and expired timeouts from the main list.
76454:   for (PRUint32 index = 0; index < mTimeouts.Length(); ) {
76454:     nsAutoPtr<TimeoutInfo>& info = mTimeouts[index];
76454:     if (info->mTargetTime <= now || info->mCanceled) {
74337:       mTimeouts.RemoveElement(info);
76454:     }
76454:     else {
76454:       index++;
76454:     }
74337:   }
74337: 
74337:   // Signal the parent that we're no longer using timeouts or reschedule the
74337:   // timer.
74337:   if (mTimeouts.IsEmpty()) {
74337:     if (!ModifyBusyCountFromWorker(aCx, false)) {
74337:       retval = false;
74337:     }
74337:     mTimerRunning = false;
74337:   }
74337:   else if (retval && !RescheduleTimeoutTimer(aCx)) {
74337:     retval = false;
74337:   }
74337: 
74337:   return retval;
74337: }
74337: 
74337: bool
74337: WorkerPrivate::RescheduleTimeoutTimer(JSContext* aCx)
74337: {
74337:   AssertIsOnWorkerThread();
74337:   NS_ASSERTION(!mTimeouts.IsEmpty(), "Should have some timeouts!");
74337:   NS_ASSERTION(mTimer, "Should have a timer!");
74337: 
74337:   double delta =
74337:     (mTimeouts[0]->mTargetTime - TimeStamp::Now()).ToMilliseconds();
74337:   PRUint32 delay = delta > 0 ? NS_MIN(delta, double(PR_UINT32_MAX)) : 0;
74337: 
74337:   nsresult rv = mTimer->InitWithFuncCallback(DummyCallback, nsnull, delay,
74337:                                              nsITimer::TYPE_ONE_SHOT);
74337:   if (NS_FAILED(rv)) {
74337:     JS_ReportError(aCx, "Failed to start timer!");
74337:     return false;
74337:   }
74337: 
74337:   return true;
74337: }
74337: 
74337: void
74337: WorkerPrivate::UpdateJSContextOptionsInternal(JSContext* aCx, PRUint32 aOptions)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   JS_SetOptions(aCx, aOptions);
74337: 
74337:   for (PRUint32 index = 0; index < mChildWorkers.Length(); index++) {
74337:     mChildWorkers[index]->UpdateJSContextOptions(aCx, aOptions);
74337:   }
74337: }
74337: 
74337: #ifdef JS_GC_ZEAL
74337: void
74337: WorkerPrivate::UpdateGCZealInternal(JSContext* aCx, PRUint8 aGCZeal)
74337: {
74337:   AssertIsOnWorkerThread();
74337: 
74337:   PRUint32 frequency = aGCZeal <= 2 ? JS_DEFAULT_ZEAL_FREQ : 1;
74337:   JS_SetGCZeal(aCx, aGCZeal, frequency, false);
74337: 
74337:   for (PRUint32 index = 0; index < mChildWorkers.Length(); index++) {
74337:     mChildWorkers[index]->UpdateGCZeal(aCx, aGCZeal);
74337:   }
74337: }
74337: #endif
74337: 
74337: #ifdef DEBUG
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::AssertIsOnParentThread() const
74337: {
74337:   if (GetParent()) {
74337:     GetParent()->AssertIsOnWorkerThread();
74337:   }
74337:   else {
74337:     AssertIsOnMainThread();
74337:   }
74337: }
74337: 
74337: template <class Derived>
74337: void
74337: WorkerPrivateParent<Derived>::AssertInnerWindowIsCorrect() const
74337: {
74337:   AssertIsOnParentThread();
74337: 
74337:   // Only care about top level workers from windows.
74337:   if (mParent || !mWindow) {
74337:     return;
74337:   }
74337: 
74337:   AssertIsOnMainThread();
74337: 
74337:   nsPIDOMWindow* outer = mWindow->GetOuterWindow();
74337:   NS_ASSERTION(outer && outer->GetCurrentInnerWindow() == mWindow,
74337:                "Inner window no longer correct!");
74337: }
74337: 
74337: void
74337: WorkerPrivate::AssertIsOnWorkerThread() const
74337: {
74337:   if (mThread) {
74337:     PRBool current;
74337:     if (NS_FAILED(mThread->IsOnCurrentThread(&current)) || !current) {
74337:       NS_ERROR("Wrong thread!");
74337:     }
74337:   }
74337:   else {
74337:     NS_ERROR("Trying to assert thread identity after thread has been "
74337:              "shutdown!");
74337:   }
74337: }
74337: #endif
74337: 
74890: BEGIN_WORKERS_NAMESPACE
74890: 
74337: // Force instantiation.
74337: template class WorkerPrivateParent<WorkerPrivate>;
74337: 
74337: WorkerPrivate*
74337: GetWorkerPrivateFromContext(JSContext* aCx)
74337: {
74337:   NS_ASSERTION(!NS_IsMainThread(), "Wrong thread!");
74337:   return static_cast<WorkerPrivate*>(JS_GetContextPrivate(aCx));
74337: }
74337: 
74337: JSStructuredCloneCallbacks*
76372: WorkerStructuredCloneCallbacks(bool aMainRuntime)
74337: {
76372:   return aMainRuntime ?
76372:          &gMainThreadWorkerStructuredCloneCallbacks :
76372:          &gWorkerStructuredCloneCallbacks;
74337: }
74337: 
74337: JSStructuredCloneCallbacks*
76372: ChromeWorkerStructuredCloneCallbacks(bool aMainRuntime)
74337: {
76372:   return aMainRuntime ?
76372:          &gMainThreadChromeWorkerStructuredCloneCallbacks :
76372:          &gChromeWorkerStructuredCloneCallbacks;
74337: }
74337: 
74337: END_WORKERS_NAMESPACE
