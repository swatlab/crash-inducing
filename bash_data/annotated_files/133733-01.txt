     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1:  
     1: /* the interface (to internal code) for retrieving computed style data */
     1: 
126025: #include "mozilla/DebugOnly.h"
126025: 
     1: #include "nsStyleConsts.h"
     1: #include "nsString.h"
     1: #include "nsPresContext.h"
     1: #include "nsIStyleRule.h"
     1: 
     1: #include "nsCOMPtr.h"
     1: #include "nsStyleSet.h"
     1: #include "nsIPresShell.h"
     1: 
     1: #include "nsRuleNode.h"
     1: #include "nsStyleContext.h"
 35554: #include "prlog.h"
 40173: #include "nsStyleAnimation.h"
114005: #include "sampler.h"
     1: 
     1: #ifdef DEBUG
     1: // #define NOISY_DEBUG
     1: #endif
     1: 
107482: using namespace mozilla;
107482: 
     1: //----------------------------------------------------------------------
     1: 
     1: 
     1: nsStyleContext::nsStyleContext(nsStyleContext* aParent,
     1:                                nsIAtom* aPseudoTag,
 35554:                                nsCSSPseudoElements::Type aPseudoType,
133733:                                nsRuleNode* aRuleNode,
133733:                                bool aSkipFlexItemStyleFixup)
     1:   : mParent(aParent),
106838:     mChild(nullptr),
106838:     mEmptyChild(nullptr),
     1:     mPseudoTag(aPseudoTag),
     1:     mRuleNode(aRuleNode),
106838:     mAllocations(nullptr),
106838:     mCachedResetData(nullptr),
108991:     mBits(((uint32_t)aPseudoType) << NS_STYLE_CONTEXT_TYPE_SHIFT),
     1:     mRefCnt(0)
     1: {
 90821:   // This check has to be done "backward", because if it were written the
 90821:   // more natural way it wouldn't fail even when it needed to.
115367:   MOZ_STATIC_ASSERT((UINT32_MAX >> NS_STYLE_CONTEXT_TYPE_SHIFT) >=
 90821:                     nsCSSPseudoElements::ePseudo_MAX,
108991:                     "pseudo element bits no longer fit in a uint32_t");
132810:   MOZ_ASSERT(aRuleNode);
 35554: 
     1:   mNextSibling = this;
     1:   mPrevSibling = this;
     1:   if (mParent) {
     1:     mParent->AddRef();
     1:     mParent->AddChild(this);
 23831: #ifdef DEBUG
132810:     nsRuleNode *r1 = mParent->RuleNode(), *r2 = aRuleNode;
 23831:     while (r1->GetParent())
 23831:       r1 = r1->GetParent();
 23831:     while (r2->GetParent())
 23831:       r2 = r2->GetParent();
 24429:     NS_ASSERTION(r1 == r2, "must be in the same rule tree as parent");
 23831: #endif
     1:   }
     1: 
121240:   mRuleNode->AddRef();
121240:   mRuleNode->SetUsedDirectly(); // before ApplyStyleFixups()!
121240: 
133733:   ApplyStyleFixups(aSkipFlexItemStyleFixup);
     1: 
     1:   #define eStyleStruct_LastItem (nsStyleStructID_Length - 1)
     1:   NS_ASSERTION(NS_STYLE_INHERIT_MASK & NS_STYLE_INHERIT_BIT(LastItem),
     1:                "NS_STYLE_INHERIT_MASK must be bigger, and other bits shifted");
     1:   #undef eStyleStruct_LastItem
     1: }
     1: 
     1: nsStyleContext::~nsStyleContext()
     1: {
106838:   NS_ASSERTION((nullptr == mChild) && (nullptr == mEmptyChild), "destructing context with children");
     1: 
132811:   nsPresContext *presContext = mRuleNode->PresContext();
     1: 
 33020:   mRuleNode->Release();
 33020: 
     1:   presContext->PresShell()->StyleSet()->
     1:     NotifyStyleContextDestroyed(presContext, this);
     1: 
     1:   if (mParent) {
     1:     mParent->RemoveChild(this);
     1:     mParent->Release();
     1:   }
     1: 
     1:   // Free up our data structs.
 38860:   mCachedInheritedData.DestroyStructs(mBits, presContext);
 38860:   if (mCachedResetData) {
 38860:     mCachedResetData->Destroy(mBits, presContext);
     1:   }
 47177: 
 47177:   FreeAllocations(presContext);
     1: }
     1: 
     1: void nsStyleContext::AddChild(nsStyleContext* aChild)
     1: {
     1:   NS_ASSERTION(aChild->mPrevSibling == aChild &&
     1:                aChild->mNextSibling == aChild,
     1:                "child already in a child list");
     1: 
     1:   nsStyleContext **list = aChild->mRuleNode->IsRoot() ? &mEmptyChild : &mChild;
     1: 
     1:   // Insert at the beginning of the list.  See also FindChildWithRules.
     1:   if (*list) {
     1:     // Link into existing elements, if there are any.
     1:     aChild->mNextSibling = (*list);
     1:     aChild->mPrevSibling = (*list)->mPrevSibling;
     1:     (*list)->mPrevSibling->mNextSibling = aChild;
     1:     (*list)->mPrevSibling = aChild;
     1:   }
     1:   (*list) = aChild;
     1: }
     1: 
     1: void nsStyleContext::RemoveChild(nsStyleContext* aChild)
     1: {
106838:   NS_PRECONDITION(nullptr != aChild && this == aChild->mParent, "bad argument");
     1: 
     1:   nsStyleContext **list = aChild->mRuleNode->IsRoot() ? &mEmptyChild : &mChild;
     1: 
     1:   if (aChild->mPrevSibling != aChild) { // has siblings
     1:     if ((*list) == aChild) {
     1:       (*list) = (*list)->mNextSibling;
     1:     }
     1:   } 
     1:   else {
     1:     NS_ASSERTION((*list) == aChild, "bad sibling pointers");
106838:     (*list) = nullptr;
     1:   }
     1: 
     1:   aChild->mPrevSibling->mNextSibling = aChild->mNextSibling;
     1:   aChild->mNextSibling->mPrevSibling = aChild->mPrevSibling;
     1:   aChild->mNextSibling = aChild;
     1:   aChild->mPrevSibling = aChild;
     1: }
     1: 
     1: already_AddRefed<nsStyleContext>
     1: nsStyleContext::FindChildWithRules(const nsIAtom* aPseudoTag, 
 40187:                                    nsRuleNode* aRuleNode,
 40187:                                    nsRuleNode* aRulesIfVisited,
 79445:                                    bool aRelevantLinkVisited)
     1: {
 40187:   NS_ABORT_IF_FALSE(aRulesIfVisited || !aRelevantLinkVisited,
 40187:     "aRelevantLinkVisited should only be set when we have a separate style");
108991:   uint32_t threshold = 10; // The # of siblings we're willing to examine
     1:                            // before just giving this whole thing up.
     1: 
106838:   nsStyleContext* result = nullptr;
     1:   nsStyleContext *list = aRuleNode->IsRoot() ? mEmptyChild : mChild;
     1: 
     1:   if (list) {
     1:     nsStyleContext *child = list;
     1:     do {
 40187:       if (child->mRuleNode == aRuleNode &&
 40187:           child->mPseudoTag == aPseudoTag &&
 40497:           !child->IsStyleIfVisited() &&
 40187:           child->RelevantLinkVisited() == aRelevantLinkVisited) {
 79445:         bool match = false;
 40187:         if (aRulesIfVisited) {
 40187:           match = child->GetStyleIfVisited() &&
 40187:                   child->GetStyleIfVisited()->mRuleNode == aRulesIfVisited;
 40187:         } else {
 40187:           match = !child->GetStyleIfVisited();
 40187:         }
 40187:         if (match) {
     1:           result = child;
     1:           break;
     1:         }
 40187:       }
     1:       child = child->mNextSibling;
     1:       threshold--;
     1:       if (threshold == 0)
     1:         break;
     1:     } while (child != list);
     1:   }
     1: 
     1:   if (result) {
     1:     if (result != list) {
     1:       // Move result to the front of the list.
     1:       RemoveChild(result);
     1:       AddChild(result);
     1:     }
     1: 
     1:     // Add reference for the caller.
     1:     result->AddRef();
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
 38860: const void* nsStyleContext::GetCachedStyleData(nsStyleStructID aSID)
 38860: {
 38860:   const void* cachedData;
 63757:   if (nsCachedStyleData::IsReset(aSID)) {
 38860:     if (mCachedResetData) {
 63757:       cachedData = mCachedResetData->mStyleStructs[aSID];
 38860:     } else {
106838:       cachedData = nullptr;
 38860:     }
 38860:   } else {
 63757:     cachedData = mCachedInheritedData.mStyleStructs[aSID];
 38860:   }
 38860:   return cachedData;
 38860: }
 38860: 
132813: const void* nsStyleContext::StyleData(nsStyleStructID aSID)
     1: {
 38860:   const void* cachedData = GetCachedStyleData(aSID);
     1:   if (cachedData)
     1:     return cachedData; // We have computed data stored on this node in the context tree.
 80486:   return mRuleNode->GetStyleData(aSID, this, true); // Our rule node will take care of it for us.
     1: }
     1: 
     1: // This is an evil evil function, since it forces you to alloc your own separate copy of
     1: // style data!  Do not use this function unless you absolutely have to!  You should avoid
     1: // this at all costs! -dwh
 10152: void* 
     1: nsStyleContext::GetUniqueStyleData(const nsStyleStructID& aSID)
     1: {
     1:   // If we already own the struct and no kids could depend on it, then
     1:   // just return it.  (We leak in this case if there are kids -- and this
     1:   // function really shouldn't be called for style contexts that could
     1:   // have kids depending on the data.  ClearStyleData would be OK, but
     1:   // this test for no mChild or mEmptyChild doesn't catch that case.)
132813:   const void *current = StyleData(aSID);
     1:   if (!mChild && !mEmptyChild &&
     1:       !(mBits & nsCachedStyleData::GetBitForSID(aSID)) &&
 38860:       GetCachedStyleData(aSID))
 10152:     return const_cast<void*>(current);
     1: 
 10152:   void* result;
     1:   nsPresContext *presContext = PresContext();
     1:   switch (aSID) {
     1: 
     1: #define UNIQUE_CASE(c_)                                                       \
     1:   case eStyleStruct_##c_:                                                     \
     1:     result = new (presContext) nsStyle##c_(                                   \
  3233:       * static_cast<const nsStyle##c_ *>(current));                           \
     1:     break;
     1: 
     1:   UNIQUE_CASE(Display)
     1:   UNIQUE_CASE(Background)
     1:   UNIQUE_CASE(Text)
     1:   UNIQUE_CASE(TextReset)
     1: 
     1: #undef UNIQUE_CASE
     1: 
     1:   default:
 43756:     NS_ERROR("Struct type not supported.  Please find another way to do this if you can!");
106838:     return nullptr;
     1:   }
     1: 
     1:   SetStyle(aSID, result);
     1:   mBits &= ~nsCachedStyleData::GetBitForSID(aSID);
     1: 
     1:   return result;
     1: }
     1: 
     1: void
 10152: nsStyleContext::SetStyle(nsStyleStructID aSID, void* aStruct)
     1: {
     1:   // This method should only be called from nsRuleNode!  It is not a public
     1:   // method!
     1:   
     1:   NS_ASSERTION(aSID >= 0 && aSID < nsStyleStructID_Length, "out of bounds");
     1: 
     1:   // NOTE:  nsCachedStyleData::GetStyleData works roughly the same way.
     1:   // See the comments there (in nsRuleNode.h) for more details about
     1:   // what this is doing and why.
     1: 
 63757:   void** dataSlot;
 38860:   if (nsCachedStyleData::IsReset(aSID)) {
 38860:     if (!mCachedResetData) {
132811:       mCachedResetData = new (mRuleNode->PresContext()) nsResetStyleData;
 38860:     }
 63757:     dataSlot = &mCachedResetData->mStyleStructs[aSID];
     1:   } else {
 63757:     dataSlot = &mCachedInheritedData.mStyleStructs[aSID];
     1:   }
 63757:   NS_ASSERTION(!*dataSlot || (mBits & nsCachedStyleData::GetBitForSID(aSID)),
 31217:                "Going to leak style data");
 63757:   *dataSlot = aStruct;
     1: }
     1: 
     1: void
133733: nsStyleContext::ApplyStyleFixups(bool aSkipFlexItemStyleFixup)
     1: {
     1:   // See if we have any text decorations.
     1:   // First see if our parent has text decorations.  If our parent does, then we inherit the bit.
 68819:   if (mParent && mParent->HasTextDecorationLines()) {
 68819:     mBits |= NS_STYLE_HAS_TEXT_DECORATION_LINES;
 68819:   } else {
     1:     // We might have defined a decoration.
132812:     const nsStyleTextReset* text = StyleTextReset();
108991:     uint8_t decorationLine = text->mTextDecorationLine;
 68819:     if (decorationLine != NS_STYLE_TEXT_DECORATION_LINE_NONE &&
 68819:         decorationLine != NS_STYLE_TEXT_DECORATION_LINE_OVERRIDE_ALL) {
 68819:       mBits |= NS_STYLE_HAS_TEXT_DECORATION_LINES;
 68819:     }
     1:   }
     1: 
 31306:   if ((mParent && mParent->HasPseudoElementData()) || mPseudoTag) {
 31306:     mBits |= NS_STYLE_HAS_PSEUDO_ELEMENT_DATA;
 31306:   }
 31306: 
     1:   // Correct tables.
132812:   const nsStyleDisplay* disp = StyleDisplay();
     1:   if (disp->mDisplay == NS_STYLE_DISPLAY_TABLE) {
     1:     // -moz-center and -moz-right are used for HTML's alignment
     1:     // This is covering the <div align="right"><table>...</table></div> case.
     1:     // In this case, we don't want to inherit the text alignment into the table.
132812:     const nsStyleText* text = StyleText();
     1:     
     1:     if (text->mTextAlign == NS_STYLE_TEXT_ALIGN_MOZ_CENTER ||
     1:         text->mTextAlign == NS_STYLE_TEXT_ALIGN_MOZ_RIGHT)
     1:     {
     1:       nsStyleText* uniqueText = (nsStyleText*)GetUniqueStyleData(eStyleStruct_Text);
     1:       uniqueText->mTextAlign = NS_STYLE_TEXT_ALIGN_DEFAULT;
     1:     }
     1:   }
     1: 
     1:   // CSS2.1 section 9.2.4 specifies fixups for the 'display' property of
     1:   // the root element.  We can't implement them in nsRuleNode because we
     1:   // don't want to store all display structs that aren't 'block',
     1:   // 'inline', or 'table' in the style context tree on the off chance
     1:   // that the root element has its style reresolved later.  So do them
     1:   // here if needed, by changing the style data, so that other code
     1:   // doesn't get confused by looking at the style data.
     1:   if (!mParent) {
     1:     if (disp->mDisplay != NS_STYLE_DISPLAY_NONE &&
     1:         disp->mDisplay != NS_STYLE_DISPLAY_BLOCK &&
     1:         disp->mDisplay != NS_STYLE_DISPLAY_TABLE) {
  3233:       nsStyleDisplay *mutable_display = static_cast<nsStyleDisplay*>
  3233:                                                    (GetUniqueStyleData(eStyleStruct_Display));
 81063:       // If we're in this code, then mOriginalDisplay doesn't matter
 81063:       // for purposes of the cascade (because this nsStyleDisplay
 81063:       // isn't living in the ruletree anyway), and for determining
 81063:       // hypothetical boxes it's better to have mOriginalDisplay
 81063:       // matching mDisplay here.
     1:       if (mutable_display->mDisplay == NS_STYLE_DISPLAY_INLINE_TABLE)
 81063:         mutable_display->mOriginalDisplay = mutable_display->mDisplay =
 81063:           NS_STYLE_DISPLAY_TABLE;
     1:       else
 81063:         mutable_display->mOriginalDisplay = mutable_display->mDisplay =
 81063:           NS_STYLE_DISPLAY_BLOCK;
     1:     }
     1:   }
     1: 
121232:   // Adjust the "display" values of flex items (but not for raw text,
121232:   // placeholders, or table-parts). CSS3 Flexbox section 4 says:
121232:   //   # The computed 'display' of a flex item is determined
121232:   //   # by applying the table in CSS 2.1 Chapter 9.7.
121232:   // ...which converts inline-level elements to their block-level equivalents.
121232: #ifdef MOZ_FLEXBOX
133733:   if (!aSkipFlexItemStyleFixup && mParent) {
132812:     const nsStyleDisplay* parentDisp = mParent->StyleDisplay();
121232:     if ((parentDisp->mDisplay == NS_STYLE_DISPLAY_FLEX ||
121232:          parentDisp->mDisplay == NS_STYLE_DISPLAY_INLINE_FLEX) &&
121232:         GetPseudo() != nsCSSAnonBoxes::mozNonElement) {
121232:       uint8_t displayVal = disp->mDisplay;
121232:       // Skip table parts.
121232:       // NOTE: This list needs to be kept in sync with
121232:       // nsCSSFrameConstructor.cpp's "sDisplayData" array -- specifically,
121232:       // this should be the list of display-values that have
121232:       // FCDATA_DESIRED_PARENT_TYPE_TO_BITS specified in that array.
121232:       if (NS_STYLE_DISPLAY_TABLE_CAPTION      != displayVal &&
121232:           NS_STYLE_DISPLAY_TABLE_ROW_GROUP    != displayVal &&
121232:           NS_STYLE_DISPLAY_TABLE_HEADER_GROUP != displayVal &&
121232:           NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP != displayVal &&
121232:           NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP != displayVal &&
121232:           NS_STYLE_DISPLAY_TABLE_COLUMN       != displayVal &&
121232:           NS_STYLE_DISPLAY_TABLE_ROW          != displayVal &&
121232:           NS_STYLE_DISPLAY_TABLE_CELL         != displayVal) {
121232: 
121232:         // NOTE: Technically, we shouldn't modify the 'display' value of
121232:         // positioned elements, since they aren't flex items. However, we don't
121232:         // need to worry about checking for that, because if we're positioned,
121232:         // we'll have already been through a call to EnsureBlockDisplay() in
121232:         // nsRuleNode, so this call here won't change anything. So we're OK.
121232:         nsRuleNode::EnsureBlockDisplay(displayVal);
121232:         if (displayVal != disp->mDisplay) {
121232:           NS_ASSERTION(!disp->IsAbsolutelyPositionedStyle(),
121232:                        "We shouldn't be changing the display value of "
121232:                        "positioned content (and we should have already "
121232:                        "converted its display value to be block-level...)");
121232:           nsStyleDisplay *mutable_display =
121232:             static_cast<nsStyleDisplay*>(GetUniqueStyleData(eStyleStruct_Display));
121232:           mutable_display->mDisplay = displayVal;
121232:         }
121232:       }
121232:     }
121232:   }
121232: #endif // MOZ_FLEXBOX
121232: 
     1:   // Computer User Interface style, to trigger loads of cursors
132812:   StyleUserInterface();
     1: }
     1: 
     1: nsChangeHint
111449: nsStyleContext::CalcStyleDifference(nsStyleContext* aOther,
111449:                                     nsChangeHint aParentHintsNotHandledForDescendants)
     1: {
114005:   SAMPLE_LABEL("nsStyleContext", "CalcStyleDifference");
114005: 
111449:   NS_ABORT_IF_FALSE(NS_IsHintSubset(aParentHintsNotHandledForDescendants,
111449:                                     nsChangeHint_Hints_NotHandledForDescendants),
111449:                     "caller is passing inherited hints, but shouldn't be");
111449: 
     1:   nsChangeHint hint = NS_STYLE_HINT_NONE;
     1:   NS_ENSURE_TRUE(aOther, hint);
     1:   // We must always ensure that we populate the structs on the new style
     1:   // context that are filled in on the old context, so that if we get
     1:   // two style changes in succession, the second of which causes a real
 11409:   // style change, the PeekStyleData doesn't return null (implying that
 11409:   // nobody ever looked at that struct's data).  In other words, we
 11409:   // can't skip later structs if we get a big change up front, because
 11409:   // we could later get a small change in one of those structs that we
 11409:   // don't want to miss.
     1: 
111445:   // If our rule nodes are the same, then any differences in style data
111445:   // are already accounted for by differences on ancestors.  We know
111445:   // this because CalcStyleDifference is always called on two style
111445:   // contexts that point to the same element, so we know that our
111445:   // position in the style context tree is the same and our position in
111445:   // the rule node tree is also the same.
111449:   // However, if there were noninherited style change hints on the
111449:   // parent, we might produce these same noninherited hints on this
111449:   // style context's frame due to 'inherit' values, so we do need to
111449:   // compare.
111449:   // (Things like 'em' units are handled by the change hint produced
111449:   // by font-size changing, so we don't need to worry about them like
111449:   // we worry about 'inherit' values.)
 79445:   bool compare = mRuleNode != aOther->mRuleNode;
     1: 
     1: #define DO_STRUCT_DIFFERENCE(struct_)                                         \
     1:   PR_BEGIN_MACRO                                                              \
 38860:     const nsStyle##struct_* this##struct_ = PeekStyle##struct_();             \
     1:     if (this##struct_) {                                                      \
132812:       const nsStyle##struct_* other##struct_ = aOther->Style##struct_();      \
111449:       nsChangeHint maxDifference = nsStyle##struct_::MaxDifference();         \
111449:       if ((compare ||                                                         \
111449:            (maxDifference & aParentHintsNotHandledForDescendants)) &&         \
111449:           !NS_IsHintSubset(maxDifference, hint) &&                            \
     1:           this##struct_ != other##struct_) {                                  \
     1:         NS_ASSERTION(NS_IsHintSubset(                                         \
     1:              this##struct_->CalcDifference(*other##struct_),                  \
     1:              nsStyle##struct_::MaxDifference()),                              \
     1:              "CalcDifference() returned bigger hint than MaxDifference()");   \
     1:         NS_UpdateHint(hint, this##struct_->CalcDifference(*other##struct_));  \
     1:       }                                                                       \
     1:     }                                                                         \
     1:   PR_END_MACRO
     1: 
111446:   // In general, we want to examine structs starting with those that can
111446:   // cause the largest style change, down to those that can cause the
111446:   // smallest.  This lets us skip later ones if we already have a hint
111446:   // that subsumes their MaxDifference.  (As the hints get
111446:   // finer-grained, this optimization is becoming less useful, though.)
     1:   DO_STRUCT_DIFFERENCE(Display);
     1:   DO_STRUCT_DIFFERENCE(XUL);
     1:   DO_STRUCT_DIFFERENCE(Column);
     1:   DO_STRUCT_DIFFERENCE(Content);
     1:   DO_STRUCT_DIFFERENCE(UserInterface);
 89564:   DO_STRUCT_DIFFERENCE(Visibility);
 89566:   DO_STRUCT_DIFFERENCE(Outline);
     1:   DO_STRUCT_DIFFERENCE(TableBorder);
     1:   DO_STRUCT_DIFFERENCE(Table);
     1:   DO_STRUCT_DIFFERENCE(UIReset);
 29501:   DO_STRUCT_DIFFERENCE(Text);
     1:   DO_STRUCT_DIFFERENCE(List);
     1:   DO_STRUCT_DIFFERENCE(Quotes);
 16411:   DO_STRUCT_DIFFERENCE(SVGReset);
 19948:   DO_STRUCT_DIFFERENCE(SVG);
101252:   DO_STRUCT_DIFFERENCE(Position);
     1:   DO_STRUCT_DIFFERENCE(Font);
     1:   DO_STRUCT_DIFFERENCE(Margin);
     1:   DO_STRUCT_DIFFERENCE(Padding);
 89564:   DO_STRUCT_DIFFERENCE(Border);
 89562:   DO_STRUCT_DIFFERENCE(TextReset);
 50422:   DO_STRUCT_DIFFERENCE(Background);
     1:   DO_STRUCT_DIFFERENCE(Color);
     1: 
     1: #undef DO_STRUCT_DIFFERENCE
     1: 
 40172:   // Note that we do not check whether this->RelevantLinkVisited() !=
 40172:   // aOther->RelevantLinkVisited(); we don't need to since
 40172:   // nsCSSFrameConstructor::DoContentStateChanged always adds
 40172:   // nsChangeHint_RepaintFrame for NS_EVENT_STATE_VISITED changes (and
 40172:   // needs to, since HasStateDependentStyle probably doesn't work right
 40172:   // for NS_EVENT_STATE_VISITED).  Hopefully this doesn't actually
 40172:   // expose whether links are visited to performance tests since all
 40172:   // link coloring happens asynchronously at a time when it's hard for
 40172:   // the page to measure.
 40172:   // However, we do need to compute the larger of the changes that can
 40172:   // happen depending on whether the link is visited or unvisited, since
 40172:   // doing only the one that's currently appropriate would expose which
 40172:   // links are in history to easy performance measurement.  Therefore,
 40172:   // here, we add nsChangeHint_RepaintFrame hints (the maximum for
 40172:   // things that can depend on :visited) for the properties on which we
 40172:   // call GetVisitedDependentColor.
 40172:   nsStyleContext *thisVis = GetStyleIfVisited(),
 40172:                 *otherVis = aOther->GetStyleIfVisited();
 40172:   if (!thisVis != !otherVis) {
 40172:     // One style context has a style-if-visited and the other doesn't.
 40172:     // Presume a difference.
 40172:     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
 40172:   } else if (thisVis && !NS_IsHintSubset(nsChangeHint_RepaintFrame, hint)) {
 40172:     // Both style contexts have a style-if-visited.
 79445:     bool change = false;
 40172: 
 40172:     // NB: Calling Peek on |this|, not |thisVis|, since callers may look
 40172:     // at a struct on |this| without looking at the same struct on
 40172:     // |thisVis| (including this function if we skip one of these checks
 40172:     // due to change being true already or due to the old style context
 40172:     // not having a style-if-visited), but not the other way around.
 40172:     if (PeekStyleColor()) {
132812:       if (thisVis->StyleColor()->mColor !=
132812:           otherVis->StyleColor()->mColor) {
 80486:         change = true;
 40172:       }
 40172:     }
 40172: 
 40172:     // NB: Calling Peek on |this|, not |thisVis| (see above).
 40172:     if (!change && PeekStyleBackground()) {
132812:       if (thisVis->StyleBackground()->mBackgroundColor !=
132812:           otherVis->StyleBackground()->mBackgroundColor) {
 80486:         change = true;
 40172:       }
 40172:     }
 40172: 
 40172:     // NB: Calling Peek on |this|, not |thisVis| (see above).
 40172:     if (!change && PeekStyleBorder()) {
132812:       const nsStyleBorder *thisVisBorder = thisVis->StyleBorder();
132812:       const nsStyleBorder *otherVisBorder = otherVis->StyleBorder();
 40172:       NS_FOR_CSS_SIDES(side) {
 79445:         bool thisFG, otherFG;
 40172:         nscolor thisColor, otherColor;
 40172:         thisVisBorder->GetBorderColor(side, thisColor, thisFG);
 40172:         otherVisBorder->GetBorderColor(side, otherColor, otherFG);
 40172:         if (thisFG != otherFG || (!thisFG && thisColor != otherColor)) {
 80486:           change = true;
 40172:           break;
 40172:         }
 40172:       }
 40172:     }
 40172: 
 40172:     // NB: Calling Peek on |this|, not |thisVis| (see above).
 40172:     if (!change && PeekStyleOutline()) {
132812:       const nsStyleOutline *thisVisOutline = thisVis->StyleOutline();
132812:       const nsStyleOutline *otherVisOutline = otherVis->StyleOutline();
 79445:       bool haveColor;
 40172:       nscolor thisColor, otherColor;
 40172:       if (thisVisOutline->GetOutlineInitialColor() != 
 40172:             otherVisOutline->GetOutlineInitialColor() ||
 40172:           (haveColor = thisVisOutline->GetOutlineColor(thisColor)) != 
 40172:             otherVisOutline->GetOutlineColor(otherColor) ||
 40172:           (haveColor && thisColor != otherColor)) {
 80486:         change = true;
 40172:       }
 40172:     }
 40172: 
 40172:     // NB: Calling Peek on |this|, not |thisVis| (see above).
 40172:     if (!change && PeekStyleColumn()) {
132812:       const nsStyleColumn *thisVisColumn = thisVis->StyleColumn();
132812:       const nsStyleColumn *otherVisColumn = otherVis->StyleColumn();
 40172:       if (thisVisColumn->mColumnRuleColor != otherVisColumn->mColumnRuleColor ||
 40172:           thisVisColumn->mColumnRuleColorIsForeground !=
 40172:             otherVisColumn->mColumnRuleColorIsForeground) {
 80486:         change = true;
 40172:       }
 40172:     }
 40172: 
 40172:     // NB: Calling Peek on |this|, not |thisVis| (see above).
 64456:     if (!change && PeekStyleTextReset()) {
132812:       const nsStyleTextReset *thisVisTextReset = thisVis->StyleTextReset();
132812:       const nsStyleTextReset *otherVisTextReset = otherVis->StyleTextReset();
 64456:       nscolor thisVisDecColor, otherVisDecColor;
 79445:       bool thisVisDecColorIsFG, otherVisDecColorIsFG;
 64456:       thisVisTextReset->GetDecorationColor(thisVisDecColor,
 64456:                                            thisVisDecColorIsFG);
 64456:       otherVisTextReset->GetDecorationColor(otherVisDecColor,
 64456:                                             otherVisDecColorIsFG);
 64456:       if (thisVisDecColorIsFG != otherVisDecColorIsFG ||
 64456:           (!thisVisDecColorIsFG && thisVisDecColor != otherVisDecColor)) {
 80486:         change = true;
 64456:       }
 64456:     }
 64456: 
 64456:     // NB: Calling Peek on |this|, not |thisVis| (see above).
 40172:     if (!change && PeekStyleSVG()) {
132812:       const nsStyleSVG *thisVisSVG = thisVis->StyleSVG();
132812:       const nsStyleSVG *otherVisSVG = otherVis->StyleSVG();
 40172:       if (thisVisSVG->mFill != otherVisSVG->mFill ||
 40172:           thisVisSVG->mStroke != otherVisSVG->mStroke) {
 80486:         change = true;
 40172:       }
 40172:     }
 40172: 
 40172:     if (change) {
 40172:       NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
 40172:     }
 40172:   }
 40172: 
     1:   return hint;
     1: }
     1: 
     1: void
     1: nsStyleContext::Mark()
     1: {
     1:   // Mark our rule node.
     1:   mRuleNode->Mark();
     1: 
     1:   // Mark our children (i.e., tell them to mark their rule nodes, etc.).
     1:   if (mChild) {
     1:     nsStyleContext* child = mChild;
     1:     do {
     1:       child->Mark();
     1:       child = child->mNextSibling;
     1:     } while (mChild != child);
     1:   }
     1:   
     1:   if (mEmptyChild) {
     1:     nsStyleContext* child = mEmptyChild;
     1:     do {
     1:       child->Mark();
     1:       child = child->mNextSibling;
     1:     } while (mEmptyChild != child);
     1:   }
     1: }
     1: 
     1: #ifdef DEBUG
108991: void nsStyleContext::List(FILE* out, int32_t aIndent)
     1: {
     1:   // Indent
108991:   int32_t ix;
     1:   for (ix = aIndent; --ix >= 0; ) fputs("  ", out);
     1:   fprintf(out, "%p(%d) parent=%p ",
     1:           (void*)this, mRefCnt, (void *)mParent);
     1:   if (mPseudoTag) {
     1:     nsAutoString  buffer;
     1:     mPseudoTag->ToString(buffer);
     1:     fputs(NS_LossyConvertUTF16toASCII(buffer).get(), out);
     1:     fputs(" ", out);
     1:   }
     1: 
     1:   if (mRuleNode) {
     1:     fputs("{\n", out);
     1:     nsRuleNode* ruleNode = mRuleNode;
     1:     while (ruleNode) {
     1:       nsIStyleRule *styleRule = ruleNode->GetRule();
     1:       if (styleRule) {
     1:         styleRule->List(out, aIndent + 1);
     1:       }
     1:       ruleNode = ruleNode->GetParent();
     1:     }
     1:     for (ix = aIndent; --ix >= 0; ) fputs("  ", out);
     1:     fputs("}\n", out);
     1:   }
     1:   else {
     1:     fputs("{}\n", out);
     1:   }
     1: 
106838:   if (nullptr != mChild) {
     1:     nsStyleContext* child = mChild;
     1:     do {
     1:       child->List(out, aIndent + 1);
     1:       child = child->mNextSibling;
     1:     } while (mChild != child);
     1:   }
106838:   if (nullptr != mEmptyChild) {
     1:     nsStyleContext* child = mEmptyChild;
     1:     do {
     1:       child->List(out, aIndent + 1);
     1:       child = child->mNextSibling;
     1:     } while (mEmptyChild != child);
     1:   }
     1: }
     1: #endif
     1: 
     1: // Overloaded new operator. Initializes the memory to 0 and relies on an arena
     1: // (which comes from the presShell) to perform the allocation.
     1: void* 
     1: nsStyleContext::operator new(size_t sz, nsPresContext* aPresContext) CPP_THROW_NEW
     1: {
     1:   // Check the recycle list first.
101694:   return aPresContext->PresShell()->AllocateByObjectID(nsPresArena::nsStyleContext_id, sz);
     1: }
     1: 
     1: // Overridden to prevent the global delete from being called, since the memory
     1: // came out of an nsIArena instead of the global delete operator's heap.
     1: void 
     1: nsStyleContext::Destroy()
     1: {
     1:   // Get the pres context from our rule node.
132811:   nsRefPtr<nsPresContext> presContext = mRuleNode->PresContext();
     1: 
     1:   // Call our destructor.
     1:   this->~nsStyleContext();
     1: 
     1:   // Don't let the memory be freed, since it will be recycled
     1:   // instead. Don't call the global operator delete.
101694:   presContext->PresShell()->FreeByObjectID(nsPresArena::nsStyleContext_id, this);
     1: }
     1: 
     1: already_AddRefed<nsStyleContext>
     1: NS_NewStyleContext(nsStyleContext* aParentContext,
     1:                    nsIAtom* aPseudoTag,
 35554:                    nsCSSPseudoElements::Type aPseudoType,
133733:                    nsRuleNode* aRuleNode,
133733:                    bool aSkipFlexItemStyleFixup)
     1: {
 35554:   nsStyleContext* context =
132811:     new (aRuleNode->PresContext())
133733:     nsStyleContext(aParentContext, aPseudoTag, aPseudoType, aRuleNode,
133733:                    aSkipFlexItemStyleFixup);
     1:   context->AddRef();
     1:   return context;
     1: }
     1: 
107482: static inline void
107482: ExtractAnimationValue(nsCSSProperty aProperty,
107482:                       nsStyleContext* aStyleContext,
107482:                       nsStyleAnimation::Value& aResult)
107482: {
107482:   DebugOnly<bool> success =
107482:     nsStyleAnimation::ExtractComputedValue(aProperty, aStyleContext, aResult);
107482:   NS_ABORT_IF_FALSE(success,
107482:                     "aProperty must be extractable by nsStyleAnimation");
107482: }
107482: 
107482: static nscolor
107482: ExtractColor(nsCSSProperty aProperty,
 40173:              nsStyleContext *aStyleContext)
 40173: {
 40173:   nsStyleAnimation::Value val;
107482:   ExtractAnimationValue(aProperty, aStyleContext, val);
 40173:   return val.GetColorValue();
 40173: }
 40173: 
107482: static nscolor
107482: ExtractColorLenient(nsCSSProperty aProperty,
107482:                     nsStyleContext *aStyleContext)
107482: {
107482:   nsStyleAnimation::Value val;
107482:   ExtractAnimationValue(aProperty, aStyleContext, val);
107482:   if (val.GetUnit() == nsStyleAnimation::eUnit_Color) {
107482:     return val.GetColorValue();
107482:   }
107482:   return NS_RGBA(0, 0, 0, 0);
107482: }
107482: 
 40173: struct ColorIndexSet {
108991:   uint8_t colorIndex, alphaIndex;
 40173: };
 40173: 
 40173: static const ColorIndexSet gVisitedIndices[2] = { { 0, 0 }, { 1, 0 } };
 40173: 
 40173: nscolor
 40173: nsStyleContext::GetVisitedDependentColor(nsCSSProperty aProperty)
 40173: {
 40173:   NS_ASSERTION(aProperty == eCSSProperty_color ||
 40173:                aProperty == eCSSProperty_background_color ||
 40173:                aProperty == eCSSProperty_border_top_color ||
 40173:                aProperty == eCSSProperty_border_right_color_value ||
 40173:                aProperty == eCSSProperty_border_bottom_color ||
 40173:                aProperty == eCSSProperty_border_left_color_value ||
 40173:                aProperty == eCSSProperty_outline_color ||
 40173:                aProperty == eCSSProperty__moz_column_rule_color ||
 64456:                aProperty == eCSSProperty_text_decoration_color ||
 40173:                aProperty == eCSSProperty_fill ||
 40173:                aProperty == eCSSProperty_stroke,
 40173:                "we need to add to nsStyleContext::CalcStyleDifference");
 40173: 
107482:   bool isPaintProperty = aProperty == eCSSProperty_fill ||
107482:                          aProperty == eCSSProperty_stroke;
107482: 
 40173:   nscolor colors[2];
107482:   colors[0] = isPaintProperty ? ExtractColorLenient(aProperty, this)
107482:                               : ExtractColor(aProperty, this);
 40173: 
 40173:   nsStyleContext *visitedStyle = this->GetStyleIfVisited();
 40173:   if (!visitedStyle) {
 40173:     return colors[0];
 40173:   }
 40173: 
107482:   colors[1] = isPaintProperty ? ExtractColorLenient(aProperty, visitedStyle)
107482:                               : ExtractColor(aProperty, visitedStyle);
 40173: 
 40183:   return nsStyleContext::CombineVisitedColors(colors,
 40183:                                               this->RelevantLinkVisited());
 40183: }
 40183: 
 40183: /* static */ nscolor
 79445: nsStyleContext::CombineVisitedColors(nscolor *aColors, bool aLinkIsVisited)
 40183: {
 40519:   if (NS_GET_A(aColors[1]) == 0) {
 40519:     // If the style-if-visited is transparent, then just use the
 40519:     // unvisited style rather than using the (meaningless) color
 40519:     // components of the visited style along with a potentially
 40519:     // non-transparent alpha value.
 80486:     aLinkIsVisited = false;
 40519:   }
 40519: 
 40173:   // NOTE: We want this code to have as little timing dependence as
 40173:   // possible on whether this->RelevantLinkVisited() is true.
 40173:   const ColorIndexSet &set =
 40183:     gVisitedIndices[aLinkIsVisited ? 1 : 0];
 40173: 
 40183:   nscolor colorColor = aColors[set.colorIndex];
 40183:   nscolor alphaColor = aColors[set.alphaIndex];
 40173:   return NS_RGBA(NS_GET_R(colorColor), NS_GET_G(colorColor),
 40173:                  NS_GET_B(colorColor), NS_GET_A(alphaColor));
 40173: }
 47177: 
 47177: void*
 47177: nsStyleContext::Alloc(size_t aSize)
 47177: {
 47177:   nsIPresShell *shell = PresContext()->PresShell();
 47177: 
 47177:   aSize += offsetof(AllocationHeader, mStorageStart);
 47177:   AllocationHeader *alloc =
 47177:     static_cast<AllocationHeader*>(shell->AllocateMisc(aSize));
 47177: 
 47177:   alloc->mSize = aSize; // NOTE: inflated by header
 47177: 
 47177:   alloc->mNext = mAllocations;
 47177:   mAllocations = alloc;
 47177: 
 47177:   return static_cast<void*>(&alloc->mStorageStart);
 47177: }
 47177: 
 47177: void
 47177: nsStyleContext::FreeAllocations(nsPresContext *aPresContext)
 47177: {
 47177:   nsIPresShell *shell = aPresContext->PresShell();
 47177: 
 47177:   for (AllocationHeader *alloc = mAllocations, *next; alloc; alloc = next) {
 47177:     next = alloc->mNext;
 47177:     shell->FreeMisc(alloc->mSize, alloc);
 47177:   }
 47177: }
