180994: /* This Source Code Form is subject to the terms of the Mozilla Public
180994:  * License, v. 2.0. If a copy of the MPL was not distributed with this
180994:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
180994: 
180994: /**
180994:  *
180994:  * `deprecated/traits-worker` was previously `content/worker` and kept
180994:  * only due to `deprecated/symbiont` using it, which is necessary for
180994:  * `widget`, until that reaches deprecation EOL.
180994:  *
180994:  */
180994: 
180994: "use strict";
180994: 
180994: module.metadata = {
180994:   "stability": "deprecated"
180994: };
180994: 
180994: const { Trait } = require('./traits');
180994: const { EventEmitter, EventEmitterTrait } = require('./events');
180994: const { Ci, Cu, Cc } = require('chrome');
180994: const timer = require('../timers');
180994: const { URL } = require('../url');
180994: const unload = require('../system/unload');
180994: const observers = require('../system/events');
180994: const { Cortex } = require('./cortex');
180994: const { sandbox, evaluate, load } = require("../loader/sandbox");
180994: const { merge } = require('../util/object');
180994: const xulApp = require("../system/xul-app");
180994: const { getInnerId } = require("../window/utils")
180994: const USE_JS_PROXIES = !xulApp.versionInRange(xulApp.platformVersion,
180994:                                               "17.0a2", "*");
180994: const { getTabForWindow } = require('../tabs/helpers');
180994: const { getTabForContentWindow } = require('../tabs/utils');
180994: 
180994: /* Trick the linker in order to ensure shipping these files in the XPI.
180994:   require('../content/content-worker.js');
180994:   Then, retrieve URL of these files in the XPI:
180994: */
180994: let prefix = module.uri.split('deprecated/traits-worker.js')[0];
180994: const CONTENT_WORKER_URL = prefix + 'content/content-worker.js';
180994: 
180994: // Fetch additional list of domains to authorize access to for each content
180994: // script. It is stored in manifest `metadata` field which contains
180994: // package.json data. This list is originaly defined by authors in
180994: // `permissions` attribute of their package.json addon file.
180994: const permissions = require('@loader/options').metadata['permissions'] || {};
180994: const EXPANDED_PRINCIPALS = permissions['cross-domain-content'] || [];
180994: 
180994: const JS_VERSION = '1.8';
180994: 
180994: const ERR_DESTROYED =
180994:   "Couldn't find the worker to receive this message. " +
180994:   "The script may not be initialized yet, or may already have been unloaded.";
180994: 
180994: const ERR_FROZEN = "The page is currently hidden and can no longer be used " +
180994:                    "until it is visible again.";
180994: 
180994: 
180994: const WorkerSandbox = EventEmitter.compose({
180994: 
180994:   /**
180994:    * Emit a message to the worker content sandbox
180994:    */
180994:   emit: function emit() {
180994:     // First ensure having a regular array
180994:     // (otherwise, `arguments` would be mapped to an object by `stringify`)
180994:     let array = Array.slice(arguments);
180994:     // JSON.stringify is buggy with cross-sandbox values,
180994:     // it may return "{}" on functions. Use a replacer to match them correctly.
180994:     function replacer(k, v) {
180994:       return typeof v === "function" ? undefined : v;
180994:     }
180994:     // Ensure having an asynchronous behavior
180994:     let self = this;
180994:     timer.setTimeout(function () {
180994:       self._emitToContent(JSON.stringify(array, replacer));
180994:     }, 0);
180994:   },
180994: 
180994:   /**
180994:    * Synchronous version of `emit`.
180994:    * /!\ Should only be used when it is strictly mandatory /!\
180994:    *     Doesn't ensure passing only JSON values.
180994:    *     Mainly used by context-menu in order to avoid breaking it.
180994:    */
180994:   emitSync: function emitSync() {
180994:     let args = Array.slice(arguments);
180994:     return this._emitToContent(args);
180994:   },
180994: 
180994:   /**
180994:    * Tells if content script has at least one listener registered for one event,
180994:    * through `self.on('xxx', ...)`.
180994:    * /!\ Shouldn't be used. Implemented to avoid breaking context-menu API.
180994:    */
180994:   hasListenerFor: function hasListenerFor(name) {
180994:     return this._hasListenerFor(name);
180994:   },
180994: 
180994:   /**
180994:    * Method called by the worker sandbox when it needs to send a message
180994:    */
180994:   _onContentEvent: function onContentEvent(args) {
180994:     // As `emit`, we ensure having an asynchronous behavior
180994:     let self = this;
180994:     timer.setTimeout(function () {
180994:       // We emit event to chrome/addon listeners
180994:       self._emit.apply(self, JSON.parse(args));
180994:     }, 0);
180994:   },
180994: 
180994:   /**
180994:    * Configures sandbox and loads content scripts into it.
180994:    * @param {Worker} worker
180994:    *    content worker
180994:    */
180994:   constructor: function WorkerSandbox(worker) {
180994:     this._addonWorker = worker;
180994: 
180994:     // Ensure that `emit` has always the right `this`
180994:     this.emit = this.emit.bind(this);
180994:     this.emitSync = this.emitSync.bind(this);
180994: 
180994:     // We receive a wrapped window, that may be an xraywrapper if it's content
180994:     let window = worker._window;
180994:     let proto = window;
180994: 
180994:     // Eventually use expanded principal sandbox feature, if some are given.
180994:     //
180994:     // But prevent it when the Worker isn't used for a content script but for
180994:     // injecting `addon` object into a Panel, Widget, ... scope.
180994:     // That's because:
180994:     // 1/ It is useless to use multiple domains as the worker is only used
180994:     // to communicate with the addon,
180994:     // 2/ By using it it would prevent the document to have access to any JS
180994:     // value of the worker. As JS values coming from multiple domain principals
180994:     // can't be accessed by "mono-principals" (principal with only one domain).
180994:     // Even if this principal is for a domain that is specified in the multiple
180994:     // domain principal.
180994:     let principals  = window;
180994:     let wantGlobalProperties = []
180994:     if (EXPANDED_PRINCIPALS.length > 0 && !worker._injectInDocument) {
180994:       principals = EXPANDED_PRINCIPALS.concat(window);
180994:       // We have to replace XHR constructor of the content document
180994:       // with a custom cross origin one, automagically added by platform code:
180994:       delete proto.XMLHttpRequest;
180994:       wantGlobalProperties.push("XMLHttpRequest");
180994:     }
180994: 
180994:     // Instantiate trusted code in another Sandbox in order to prevent content
180994:     // script from messing with standard classes used by proxy and API code.
180994:     let apiSandbox = sandbox(principals, { wantXrays: true, sameZoneAs: window });
180994:     apiSandbox.console = console;
180994: 
180994:     // Create the sandbox and bind it to window in order for content scripts to
180994:     // have access to all standard globals (window, document, ...)
180994:     let content = this._sandbox = sandbox(principals, {
180994:       sandboxPrototype: proto,
180994:       wantXrays: true,
180994:       wantGlobalProperties: wantGlobalProperties,
180994:       sameZoneAs: window,
182866:       metadata: { SDKContentScript: true }
180994:     });
180994:     // We have to ensure that window.top and window.parent are the exact same
180994:     // object than window object, i.e. the sandbox global object. But not
180994:     // always, in case of iframes, top and parent are another window object.
180994:     let top = window.top === window ? content : content.top;
180994:     let parent = window.parent === window ? content : content.parent;
180994:     merge(content, {
180994:       // We need "this === window === top" to be true in toplevel scope:
180994:       get window() content,
180994:       get top() top,
180994:       get parent() parent,
180994:       // Use the Greasemonkey naming convention to provide access to the
180994:       // unwrapped window object so the content script can access document
180994:       // JavaScript values.
180994:       // NOTE: this functionality is experimental and may change or go away
180994:       // at any time!
180994:       get unsafeWindow() window.wrappedJSObject
180994:     });
180994: 
180994:     // Load trusted code that will inject content script API.
180994:     // We need to expose JS objects defined in same principal in order to
180994:     // avoid having any kind of wrapper.
180994:     load(apiSandbox, CONTENT_WORKER_URL);
180994: 
180994:     // prepare a clean `self.options`
180994:     let options = 'contentScriptOptions' in worker ?
180994:       JSON.stringify( worker.contentScriptOptions ) :
180994:       undefined;
180994: 
180994:     // Then call `inject` method and communicate with this script
180994:     // by trading two methods that allow to send events to the other side:
180994:     //   - `onEvent` called by content script
180994:     //   - `result.emitToContent` called by addon script
180994:     // Bug 758203: We have to explicitely define `__exposedProps__` in order
180994:     // to allow access to these chrome object attributes from this sandbox with
180994:     // content priviledges
180994:     // https://developer.mozilla.org/en/XPConnect_wrappers#Other_security_wrappers
180994:     let chromeAPI = {
180994:       timers: {
180994:         setTimeout: timer.setTimeout,
180994:         setInterval: timer.setInterval,
180994:         clearTimeout: timer.clearTimeout,
180994:         clearInterval: timer.clearInterval,
180994:         __exposedProps__: {
180994:           setTimeout: 'r',
180994:           setInterval: 'r',
180994:           clearTimeout: 'r',
180994:           clearInterval: 'r'
180994:         }
180994:       },
180994:       sandbox: {
180994:         evaluate: evaluate,
180994:         __exposedProps__: {
180994:           evaluate: 'r',
180994:         }
180994:       },
180994:       __exposedProps__: {
180994:         timers: 'r',
180994:         sandbox: 'r',
180994:       }
180994:     };
180994:     let onEvent = this._onContentEvent.bind(this);
180994:     // `ContentWorker` is defined in CONTENT_WORKER_URL file
180994:     let result = apiSandbox.ContentWorker.inject(content, chromeAPI, onEvent, options);
180994:     this._emitToContent = result.emitToContent;
180994:     this._hasListenerFor = result.hasListenerFor;
180994: 
180994:     // Handle messages send by this script:
180994:     let self = this;
180994:     // console.xxx calls
180994:     this.on("console", function consoleListener(kind) {
180994:       console[kind].apply(console, Array.slice(arguments, 1));
180994:     });
180994: 
180994:     // self.postMessage calls
180994:     this.on("message", function postMessage(data) {
180994:       // destroyed?
180994:       if (self._addonWorker)
180994:         self._addonWorker._emit('message', data);
180994:     });
180994: 
180994:     // self.port.emit calls
180994:     this.on("event", function portEmit(name, args) {
180994:       // destroyed?
180994:       if (self._addonWorker)
180994:         self._addonWorker._onContentScriptEvent.apply(self._addonWorker, arguments);
180994:     });
180994: 
180994:     // unwrap, recreate and propagate async Errors thrown from content-script
180994:     this.on("error", function onError({instanceOfError, value}) {
180994:       if (self._addonWorker) {
180994:         let error = value;
180994:         if (instanceOfError) {
180994:           error = new Error(value.message, value.fileName, value.lineNumber);
180994:           error.stack = value.stack;
180994:           error.name = value.name;
180994:         }
180994:         self._addonWorker._emit('error', error);
180994:       }
180994:     });
180994: 
180994:     // Inject `addon` global into target document if document is trusted,
180994:     // `addon` in document is equivalent to `self` in content script.
180994:     if (worker._injectInDocument) {
180994:       let win = window.wrappedJSObject ? window.wrappedJSObject : window;
180994:       Object.defineProperty(win, "addon", {
180994:           value: content.self
180994:         }
180994:       );
180994:     }
180994: 
180994:     // Inject our `console` into target document if worker doesn't have a tab
180994:     // (e.g Panel, PageWorker, Widget).
180994:     // `worker.tab` can't be used because bug 804935.
180994:     if (!getTabForContentWindow(window)) {
180994:       let win = window.wrappedJSObject ? window.wrappedJSObject : window;
180994: 
180994:       // export our chrome console to content window, using the same approach
180994:       // of `ConsoleAPI`:
180994:       // http://mxr.mozilla.org/mozilla-central/source/dom/base/ConsoleAPI.js#150
180994:       //
180994:       // and described here:
180994:       // https://developer.mozilla.org/en-US/docs/Components.utils.createObjectIn
180994:       let con = Cu.createObjectIn(win);
180994: 
180994:       let genPropDesc = function genPropDesc(fun) {
180994:         return { enumerable: true, configurable: true, writable: true,
180994:           value: console[fun] };
180994:       }
180994: 
180994:       const properties = {
180994:         log: genPropDesc('log'),
180994:         info: genPropDesc('info'),
180994:         warn: genPropDesc('warn'),
180994:         error: genPropDesc('error'),
180994:         debug: genPropDesc('debug'),
180994:         trace: genPropDesc('trace'),
180994:         dir: genPropDesc('dir'),
180994:         group: genPropDesc('group'),
180994:         groupCollapsed: genPropDesc('groupCollapsed'),
180994:         groupEnd: genPropDesc('groupEnd'),
180994:         time: genPropDesc('time'),
180994:         timeEnd: genPropDesc('timeEnd'),
180994:         profile: genPropDesc('profile'),
180994:         profileEnd: genPropDesc('profileEnd'),
180994:        __noSuchMethod__: { enumerable: true, configurable: true, writable: true,
180994:                             value: function() {} }
180994:       };
180994: 
180994:       Object.defineProperties(con, properties);
180994:       Cu.makeObjectPropsNormal(con);
180994: 
180994:       win.console = con;
180994:     };
180994: 
180994:     // The order of `contentScriptFile` and `contentScript` evaluation is
180994:     // intentional, so programs can load libraries like jQuery from script URLs
180994:     // and use them in scripts.
180994:     let contentScriptFile = ('contentScriptFile' in worker) ? worker.contentScriptFile
180994:           : null,
180994:         contentScript = ('contentScript' in worker) ? worker.contentScript : null;
180994: 
180994:     if (contentScriptFile) {
180994:       if (Array.isArray(contentScriptFile))
180994:         this._importScripts.apply(this, contentScriptFile);
180994:       else
180994:         this._importScripts(contentScriptFile);
180994:     }
180994:     if (contentScript) {
180994:       this._evaluate(
180994:         Array.isArray(contentScript) ? contentScript.join(';\n') : contentScript
180994:       );
180994:     }
180994:   },
180994:   destroy: function destroy() {
180994:     this.emitSync("detach");
180994:     this._sandbox = null;
180994:     this._addonWorker = null;
180994:   },
180994: 
180994:   /**
180994:    * JavaScript sandbox where all the content scripts are evaluated.
180994:    * {Sandbox}
180994:    */
180994:   _sandbox: null,
180994: 
180994:   /**
180994:    * Reference to the addon side of the worker.
180994:    * @type {Worker}
180994:    */
180994:   _addonWorker: null,
180994: 
180994:   /**
180994:    * Evaluates code in the sandbox.
180994:    * @param {String} code
180994:    *    JavaScript source to evaluate.
180994:    * @param {String} [filename='javascript:' + code]
180994:    *    Name of the file
180994:    */
180994:   _evaluate: function(code, filename) {
180994:     try {
180994:       evaluate(this._sandbox, code, filename || 'javascript:' + code);
180994:     }
180994:     catch(e) {
180994:       this._addonWorker._emit('error', e);
180994:     }
180994:   },
180994:   /**
180994:    * Imports scripts to the sandbox by reading files under urls and
180994:    * evaluating its source. If exception occurs during evaluation
180994:    * `"error"` event is emitted on the worker.
180994:    * This is actually an analog to the `importScript` method in web
180994:    * workers but in our case it's not exposed even though content
180994:    * scripts may be able to do it synchronously since IO operation
180994:    * takes place in the UI process.
180994:    */
180994:   _importScripts: function _importScripts(url) {
180994:     let urls = Array.slice(arguments, 0);
180994:     for each (let contentScriptFile in urls) {
180994:       try {
180994:         let uri = URL(contentScriptFile);
180994:         if (uri.scheme === 'resource')
180994:           load(this._sandbox, String(uri));
180994:         else
180994:           throw Error("Unsupported `contentScriptFile` url: " + String(uri));
180994:       }
180994:       catch(e) {
180994:         this._addonWorker._emit('error', e);
180994:       }
180994:     }
180994:   }
180994: });
180994: 
180994: /**
180994:  * Message-passing facility for communication between code running
180994:  * in the content and add-on process.
180994:  * @see https://addons.mozilla.org/en-US/developers/docs/sdk/latest/modules/sdk/content/worker.html
180994:  */
180994: const Worker = EventEmitter.compose({
180994:   on: Trait.required,
180994:   _removeAllListeners: Trait.required,
180994: 
180994:   // List of messages fired before worker is initialized
180994:   get _earlyEvents() {
180994:     delete this._earlyEvents;
180994:     this._earlyEvents = [];
180994:     return this._earlyEvents;
180994:   },
180994: 
180994:   /**
180994:    * Sends a message to the worker's global scope. Method takes single
180994:    * argument, which represents data to be sent to the worker. The data may
180994:    * be any primitive type value or `JSON`. Call of this method asynchronously
180994:    * emits `message` event with data value in the global scope of this
180994:    * symbiont.
180994:    *
180994:    * `message` event listeners can be set either by calling
180994:    * `self.on` with a first argument string `"message"` or by
180994:    * implementing `onMessage` function in the global scope of this worker.
180994:    * @param {Number|String|JSON} data
180994:    */
180994:   postMessage: function (data) {
180994:     let args = ['message'].concat(Array.slice(arguments));
180994:     if (!this._inited) {
180994:       this._earlyEvents.push(args);
180994:       return;
180994:     }
180994:     processMessage.apply(this, args);
180994:   },
180994: 
180994:   /**
180994:    * EventEmitter, that behaves (calls listeners) asynchronously.
180994:    * A way to send customized messages to / from the worker.
180994:    * Events from in the worker can be observed / emitted via
180994:    * worker.on / worker.emit.
180994:    */
180994:   get port() {
180994:     // We generate dynamically this attribute as it needs to be accessible
180994:     // before Worker.constructor gets called. (For ex: Panel)
180994: 
180994:     // create an event emitter that receive and send events from/to the worker
180994:     this._port = EventEmitterTrait.create({
180994:       emit: this._emitEventToContent.bind(this)
180994:     });
180994: 
180994:     // expose wrapped port, that exposes only public properties:
180994:     // We need to destroy this getter in order to be able to set the
180994:     // final value. We need to update only public port attribute as we never
180994:     // try to access port attribute from private API.
180994:     delete this._public.port;
180994:     this._public.port = Cortex(this._port);
180994:     // Replicate public port to the private object
180994:     delete this.port;
180994:     this.port = this._public.port;
180994: 
180994:     return this._port;
180994:   },
180994: 
180994:   /**
180994:    * Same object than this.port but private API.
180994:    * Allow access to _emit, in order to send event to port.
180994:    */
180994:   _port: null,
180994: 
180994:   /**
180994:    * Emit a custom event to the content script,
180994:    * i.e. emit this event on `self.port`
180994:    */
180994:   _emitEventToContent: function () {
180994:     let args = ['event'].concat(Array.slice(arguments));
180994:     if (!this._inited) {
180994:       this._earlyEvents.push(args);
180994:       return;
180994:     }
180994:     processMessage.apply(this, args);
180994:   },
180994: 
180994:   // Is worker connected to the content worker sandbox ?
180994:   _inited: false,
180994: 
180994:   // Is worker being frozen? i.e related document is frozen in bfcache.
180994:   // Content script should not be reachable if frozen.
180994:   _frozen: true,
180994: 
180994:   constructor: function Worker(options) {
180994:     options = options || {};
180994: 
180994:     if ('contentScriptFile' in options)
180994:       this.contentScriptFile = options.contentScriptFile;
180994:     if ('contentScriptOptions' in options)
180994:       this.contentScriptOptions = options.contentScriptOptions;
180994:     if ('contentScript' in options)
180994:       this.contentScript = options.contentScript;
180994: 
180994:     this._setListeners(options);
180994: 
180994:     unload.ensure(this._public, "destroy");
180994: 
180994:     // Ensure that worker._port is initialized for contentWorker to be able
180994:     // to send events during worker initialization.
180994:     this.port;
180994: 
180994:     this._documentUnload = this._documentUnload.bind(this);
180994:     this._pageShow = this._pageShow.bind(this);
180994:     this._pageHide = this._pageHide.bind(this);
180994: 
180994:     if ("window" in options) this._attach(options.window);
180994:   },
180994: 
180994:   _setListeners: function(options) {
180994:     if ('onError' in options)
180994:       this.on('error', options.onError);
180994:     if ('onMessage' in options)
180994:       this.on('message', options.onMessage);
180994:     if ('onDetach' in options)
180994:       this.on('detach', options.onDetach);
180994:   },
180994: 
180994:   _attach: function(window) {
180994:     this._window = window;
180994:     // Track document unload to destroy this worker.
180994:     // We can't watch for unload event on page's window object as it
180994:     // prevents bfcache from working:
180994:     // https://developer.mozilla.org/En/Working_with_BFCache
180994:     this._windowID = getInnerId(this._window);
180994:     observers.on("inner-window-destroyed", this._documentUnload);
180994: 
180994:     // Listen to pagehide event in order to freeze the content script
180994:     // while the document is frozen in bfcache:
180994:     this._window.addEventListener("pageshow", this._pageShow, true);
180994:     this._window.addEventListener("pagehide", this._pageHide, true);
180994: 
180994:     // will set this._contentWorker pointing to the private API:
180994:     this._contentWorker = WorkerSandbox(this);
180994: 
180994:     // Mainly enable worker.port.emit to send event to the content worker
180994:     this._inited = true;
180994:     this._frozen = false;
180994: 
180994:     // Process all events and messages that were fired before the
180994:     // worker was initialized.
180994:     this._earlyEvents.forEach((function (args) {
180994:       processMessage.apply(this, args);
180994:     }).bind(this));
180994:   },
180994: 
180994:   _documentUnload: function _documentUnload({ subject, data }) {
180994:     let innerWinID = subject.QueryInterface(Ci.nsISupportsPRUint64).data;
180994:     if (innerWinID != this._windowID) return false;
180994:     this._workerCleanup();
180994:     return true;
180994:   },
180994: 
180994:   _pageShow: function _pageShow() {
180994:     this._contentWorker.emitSync("pageshow");
180994:     this._emit("pageshow");
180994:     this._frozen = false;
180994:   },
180994: 
180994:   _pageHide: function _pageHide() {
180994:     this._contentWorker.emitSync("pagehide");
180994:     this._emit("pagehide");
180994:     this._frozen = true;
180994:   },
180994: 
180994:   get url() {
180994:     // this._window will be null after detach
180994:     return this._window ? this._window.document.location.href : null;
180994:   },
180994: 
180994:   get tab() {
180994:     // this._window will be null after detach
180994:     if (this._window)
180994:       return getTabForWindow(this._window);
180994:     return null;
180994:   },
180994: 
180994:   /**
180994:    * Tells content worker to unload itself and
180994:    * removes all the references from itself.
180994:    */
180994:   destroy: function destroy() {
180994:     this._workerCleanup();
180994:     this._inited = true;
180994:     this._removeAllListeners();
180994:   },
180994: 
180994:   /**
180994:    * Remove all internal references to the attached document
180994:    * Tells _port to unload itself and removes all the references from itself.
180994:    */
180994:   _workerCleanup: function _workerCleanup() {
180994:     // maybe unloaded before content side is created
180994:     // As Symbiont call worker.constructor on document load
180994:     if (this._contentWorker)
180994:       this._contentWorker.destroy();
180994:     this._contentWorker = null;
180994:     if (this._window) {
180994:       this._window.removeEventListener("pageshow", this._pageShow, true);
180994:       this._window.removeEventListener("pagehide", this._pageHide, true);
180994:     }
180994:     this._window = null;
180994:     // This method may be called multiple times,
180994:     // avoid dispatching `detach` event more than once
180994:     if (this._windowID) {
180994:       this._windowID = null;
180994:       observers.off("inner-window-destroyed", this._documentUnload);
180994:       this._earlyEvents.length = 0;
180994:       this._emit("detach");
180994:     }
180994:     this._inited = false;
180994:   },
180994: 
180994:   /**
180994:    * Receive an event from the content script that need to be sent to
180994:    * worker.port. Provide a way for composed object to catch all events.
180994:    */
180994:   _onContentScriptEvent: function _onContentScriptEvent() {
180994:     this._port._emit.apply(this._port, arguments);
180994:   },
180994: 
180994:   /**
180994:    * Reference to the content side of the worker.
180994:    * @type {WorkerGlobalScope}
180994:    */
180994:   _contentWorker: null,
180994: 
180994:   /**
180994:    * Reference to the window that is accessible from
180994:    * the content scripts.
180994:    * @type {Object}
180994:    */
180994:   _window: null,
180994: 
180994:   /**
180994:    * Flag to enable `addon` object injection in document. (bug 612726)
180994:    * @type {Boolean}
180994:    */
180994:   _injectInDocument: false
180994: });
180994: 
180994: /**
180994:  * Fired from postMessage and _emitEventToContent, or from the _earlyMessage
180994:  * queue when fired before the content is loaded. Sends arguments to
180994:  * contentWorker if able
180994:  */
180994: 
180994: function processMessage () {
180994:   if (!this._contentWorker)
180994:     throw new Error(ERR_DESTROYED);
180994:   if (this._frozen)
180994:     throw new Error(ERR_FROZEN);
180994: 
180994:   this._contentWorker.emit.apply(null, Array.slice(arguments));
180994: }
180994: 
180994: exports.Worker = Worker;
