15558: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
15558: /* ***** BEGIN LICENSE BLOCK *****
15558:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
15558:  *
15558:  * The contents of this file are subject to the Mozilla Public License Version
15558:  * 1.1 (the "License"); you may not use this file except in compliance with
15558:  * the License. You may obtain a copy of the License at
15558:  * http://www.mozilla.org/MPL/
15558:  *
15558:  * Software distributed under the License is distributed on an "AS IS" basis,
15558:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
15558:  * for the specific language governing rights and limitations under the
15558:  * License.
15558:  *
15558:  * The Original Code is mozilla.org code.
15558:  *
15558:  * The Initial Developer of the Original Code is
15558:  * Mozilla Corporation.
15558:  * Portions created by the Initial Developer are Copyright (C) 2008
15558:  * the Initial Developer. All Rights Reserved.
15558:  *
15558:  * Contributor(s):
15558:  *   Josh Aas <josh@mozilla.com>
15558:  *
15558:  * Alternatively, the contents of this file may be used under the terms of
15558:  * either the GNU General Public License Version 2 or later (the "GPL"), or
15558:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
15558:  * in which case the provisions of the GPL or the LGPL are applicable instead
15558:  * of those above. If you wish to allow use of your version of this file only
15558:  * under the terms of either the GPL or the LGPL, and not to allow others to
15558:  * use your version of this file under the terms of the MPL, indicate your
15558:  * decision by deleting the provisions above and replace them with the notice
15558:  * and other provisions required by the GPL or the LGPL. If you do not delete
15558:  * the provisions above, a recipient may use your version of this file under
15558:  * the terms of any one of the MPL, the GPL or the LGPL.
15558:  *
15558:  * ***** END LICENSE BLOCK ***** */
15558: 
15558: #include "nsMenuUtilsX.h"
15558: #include "nsMenuBarX.h"
16264: #include "nsMenuX.h"
15558: #include "nsMenuItemX.h"
37976: #include "nsStandaloneNativeMenu.h"
15558: #include "nsObjCExceptions.h"
15558: #include "nsCocoaUtils.h"
15558: #include "nsCocoaWindow.h"
15558: #include "nsWidgetAtoms.h"
29844: #include "nsIDocument.h"
29844: #include "nsIDOMDocumentEvent.h"
29844: #include "nsIDOMEventTarget.h"
29844: #include "nsIDOMXULCommandEvent.h"
29844: #include "nsIPrivateDOMEvent.h"
29844: #include "nsPIDOMWindow.h"
68870: #include "nsIDOMAbstractView.h"
15558: 
29844: void nsMenuUtilsX::DispatchCommandTo(nsIContent* aTargetContent)
15558: {
15558:   NS_PRECONDITION(aTargetContent, "null ptr");
15558: 
29844:   nsIDocument* doc = aTargetContent->GetOwnerDoc();
29844:   nsCOMPtr<nsIDOMDocumentEvent> docEvent = do_QueryInterface(doc);
29844:   nsCOMPtr<nsIDOMEventTarget> target = do_QueryInterface(aTargetContent);
29844:   if (docEvent && target) {
29844:     nsCOMPtr<nsIDOMEvent> event;
29844:     docEvent->CreateEvent(NS_LITERAL_STRING("xulcommandevent"),
29844:                           getter_AddRefs(event));
29844:     nsCOMPtr<nsIDOMXULCommandEvent> command = do_QueryInterface(event);
29844:     nsCOMPtr<nsIPrivateDOMEvent> pEvent = do_QueryInterface(command);
68870:     nsCOMPtr<nsIDOMAbstractView> view = do_QueryInterface(doc->GetWindow());
15558: 
15558:     // FIXME: Should probably figure out how to init this with the actual
15558:     // pressed keys, but this is a big old edge case anyway. -dwh
29844:     if (pEvent &&
29844:         NS_SUCCEEDED(command->InitCommandEvent(NS_LITERAL_STRING("command"),
68870:                                                PR_TRUE, PR_TRUE, view, 0,
29844:                                                PR_FALSE, PR_FALSE, PR_FALSE,
29844:                                                PR_FALSE, nsnull))) {
29844:       pEvent->SetTrusted(PR_TRUE);
29844:       PRBool dummy;
29844:       target->DispatchEvent(event, &dummy);
29844:     }
29844:   }
15558: }
15558: 
27906: NSString* nsMenuUtilsX::GetTruncatedCocoaLabel(const nsString& itemLabel)
15558: {
15558:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
15558: 
63556:   // We want to truncate long strings to some reasonable pixel length but there is no
63556:   // good API for doing that which works for all OS versions and architectures. For now
63556:   // we'll do nothing for consistency and depend on good user interface design to limit
63556:   // string lengths.
27906:   return [NSString stringWithCharacters:itemLabel.get() length:itemLabel.Length()];
15558: 
15558:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
15558: }
15558: 
15558: PRUint8 nsMenuUtilsX::GeckoModifiersForNodeAttribute(const nsString& modifiersAttribute)
15558: {
15558:   PRUint8 modifiers = knsMenuItemNoModifier;
15558:   char* str = ToNewCString(modifiersAttribute);
15558:   char* newStr;
15558:   char* token = strtok_r(str, ", \t", &newStr);
15558:   while (token != NULL) {
15558:     if (strcmp(token, "shift") == 0)
15558:       modifiers |= knsMenuItemShiftModifier;
15558:     else if (strcmp(token, "alt") == 0) 
15558:       modifiers |= knsMenuItemAltModifier;
15558:     else if (strcmp(token, "control") == 0) 
15558:       modifiers |= knsMenuItemControlModifier;
15558:     else if ((strcmp(token, "accel") == 0) ||
15558:              (strcmp(token, "meta") == 0)) {
15558:       modifiers |= knsMenuItemCommandModifier;
15558:     }
15558:     token = strtok_r(newStr, ", \t", &newStr);
15558:   }
15558:   free(str);
15558: 
15558:   return modifiers;
15558: }
15558: 
15558: unsigned int nsMenuUtilsX::MacModifiersForGeckoModifiers(PRUint8 geckoModifiers)
15558: {
15558:   unsigned int macModifiers = 0;
15558:   
15558:   if (geckoModifiers & knsMenuItemShiftModifier)
15558:     macModifiers |= NSShiftKeyMask;
15558:   if (geckoModifiers & knsMenuItemAltModifier)
15558:     macModifiers |= NSAlternateKeyMask;
15558:   if (geckoModifiers & knsMenuItemControlModifier)
15558:     macModifiers |= NSControlKeyMask;
15558:   if (geckoModifiers & knsMenuItemCommandModifier)
15558:     macModifiers |= NSCommandKeyMask;
15558: 
15558:   return macModifiers;
15558: }
15558: 
15558: nsMenuBarX* nsMenuUtilsX::GetHiddenWindowMenuBar()
15558: {
15558:   nsIWidget* hiddenWindowWidgetNoCOMPtr = nsCocoaUtils::GetHiddenWindowWidget();
15558:   if (hiddenWindowWidgetNoCOMPtr)
15558:     return static_cast<nsCocoaWindow*>(hiddenWindowWidgetNoCOMPtr)->GetMenuBar();
15558:   else
15558:     return nsnull;
15558: }
15558: 
15558: // It would be nice if we could localize these edit menu names.
15558: NSMenuItem* nsMenuUtilsX::GetStandardEditMenuItem()
15558: {
15558:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
15558: 
24141:   // In principle we should be able to allocate this once and then always
24141:   // return the same object.  But wierd interactions happen between native
24141:   // app-modal dialogs and Gecko-modal dialogs that open above them.  So what
24141:   // we return here isn't always released before it needs to be added to
24141:   // another menu.  See bmo bug 468393.
24141:   NSMenuItem* standardEditMenuItem =
24141:     [[[NSMenuItem alloc] initWithTitle:@"Edit" action:nil keyEquivalent:@""] autorelease];
15558:   NSMenu* standardEditMenu = [[NSMenu alloc] initWithTitle:@"Edit"];
15558:   [standardEditMenuItem setSubmenu:standardEditMenu];
15558:   [standardEditMenu release];
15558: 
15558:   // Add Undo
15558:   NSMenuItem* undoItem = [[NSMenuItem alloc] initWithTitle:@"Undo" action:@selector(undo:) keyEquivalent:@"z"];
15558:   [standardEditMenu addItem:undoItem];
15558:   [undoItem release];
15558: 
15558:   // Add Redo
15558:   NSMenuItem* redoItem = [[NSMenuItem alloc] initWithTitle:@"Redo" action:@selector(redo:) keyEquivalent:@"Z"];
15558:   [standardEditMenu addItem:redoItem];
15558:   [redoItem release];
15558: 
15558:   // Add separator
15558:   [standardEditMenu addItem:[NSMenuItem separatorItem]];
15558: 
15558:   // Add Cut
15558:   NSMenuItem* cutItem = [[NSMenuItem alloc] initWithTitle:@"Cut" action:@selector(cut:) keyEquivalent:@"x"];
15558:   [standardEditMenu addItem:cutItem];
15558:   [cutItem release];
15558: 
15558:   // Add Copy
15558:   NSMenuItem* copyItem = [[NSMenuItem alloc] initWithTitle:@"Copy" action:@selector(copy:) keyEquivalent:@"c"];
15558:   [standardEditMenu addItem:copyItem];
15558:   [copyItem release];
15558: 
15558:   // Add Paste
15558:   NSMenuItem* pasteItem = [[NSMenuItem alloc] initWithTitle:@"Paste" action:@selector(paste:) keyEquivalent:@"v"];
15558:   [standardEditMenu addItem:pasteItem];
15558:   [pasteItem release];
15558: 
15558:   // Add Delete
15558:   NSMenuItem* deleteItem = [[NSMenuItem alloc] initWithTitle:@"Delete" action:@selector(delete:) keyEquivalent:@""];
15558:   [standardEditMenu addItem:deleteItem];
15558:   [deleteItem release];
15558: 
15558:   // Add Select All
15558:   NSMenuItem* selectAllItem = [[NSMenuItem alloc] initWithTitle:@"Select All" action:@selector(selectAll:) keyEquivalent:@"a"];
15558:   [standardEditMenu addItem:selectAllItem];
15558:   [selectAllItem release];
15558: 
15558:   return standardEditMenuItem;
15558: 
15558:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
15558: }
15558: 
15558: PRBool nsMenuUtilsX::NodeIsHiddenOrCollapsed(nsIContent* inContent)
15558: {
15558:   return (inContent->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::hidden,
15558:                                  nsWidgetAtoms::_true, eCaseMatters) ||
15558:           inContent->AttrValueIs(kNameSpaceID_None, nsWidgetAtoms::collapsed,
15558:                                  nsWidgetAtoms::_true, eCaseMatters));
15558: }
16264: 
16264: // Determines how many items are visible among the siblings in a menu that are
24131: // before the given child. This will not count the application menu.
24131: int nsMenuUtilsX::CalculateNativeInsertionPoint(nsMenuObjectX* aParent,
24131:                                                 nsMenuObjectX* aChild)
16264: {
24131:   int insertionPoint = 0;
24131:   nsMenuObjectTypeX parentType = aParent->MenuObjectType();
16264:   if (parentType == eMenuBarObjectType) {
24131:     nsMenuBarX* menubarParent = static_cast<nsMenuBarX*>(aParent);
16264:     PRUint32 numMenus = menubarParent->GetMenuCount();
16264:     for (PRUint32 i = 0; i < numMenus; i++) {
16264:       nsMenuX* currMenu = menubarParent->GetMenuAt(i);
16264:       if (currMenu == aChild)
24131:         return insertionPoint; // we found ourselves, break out
24131:       if (currMenu && [currMenu->NativeMenuItem() menu])
24131:         insertionPoint++;
16264:     }
16264:   }
37976:   else if (parentType == eSubmenuObjectType ||
37976:            parentType == eStandaloneNativeMenuObjectType) {
37976:     nsMenuX* menuParent;
37976:     if (parentType == eSubmenuObjectType)
37976:       menuParent = static_cast<nsMenuX*>(aParent);
37976:     else
37976:       menuParent = static_cast<nsStandaloneNativeMenu*>(aParent)->GetMenuXObject();
37976: 
16264:     PRUint32 numItems = menuParent->GetItemCount();
16264:     for (PRUint32 i = 0; i < numItems; i++) {
16264:       // Using GetItemAt instead of GetVisibleItemAt to avoid O(N^2)
16264:       nsMenuObjectX* currItem = menuParent->GetItemAt(i);
16264:       if (currItem == aChild)
24131:         return insertionPoint; // we found ourselves, break out
24131:       NSMenuItem* nativeItem = nil;
24131:       nsMenuObjectTypeX currItemType = currItem->MenuObjectType();
24131:       if (currItemType == eSubmenuObjectType)
24131:         nativeItem = static_cast<nsMenuX*>(currItem)->NativeMenuItem();
24131:       else
24131:         nativeItem = (NSMenuItem*)(currItem->NativeData());
24131:       if ([nativeItem menu])
24131:         insertionPoint++;
16264:     }
16264:   }
24131:   return insertionPoint;
16264: }
