35734: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35734:  * vim: sw=4 ts=4 et :
35778:  */
35778: /* ***** BEGIN LICENSE BLOCK *****
35734:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35734:  *
35734:  * The contents of this file are subject to the Mozilla Public License Version
35734:  * 1.1 (the "License"); you may not use this file except in compliance with
35734:  * the License. You may obtain a copy of the License at
35734:  * http://www.mozilla.org/MPL/
35734:  *
35734:  * Software distributed under the License is distributed on an "AS IS" basis,
35734:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35734:  * for the specific language governing rights and limitations under the
35734:  * License.
35734:  *
35734:  * The Original Code is Mozilla Plugin App.
35734:  *
35734:  * The Initial Developer of the Original Code is
35734:  *   Chris Jones <jones.chris.g@gmail.com>
35734:  * Portions created by the Initial Developer are Copyright (C) 2009
35734:  * the Initial Developer. All Rights Reserved.
35734:  *
35734:  * Contributor(s):
35734:  *
35734:  * Alternatively, the contents of this file may be used under the terms of
35734:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35734:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35734:  * in which case the provisions of the GPL or the LGPL are applicable instead
35734:  * of those above. If you wish to allow use of your version of this file only
35734:  * under the terms of either the GPL or the LGPL, and not to allow others to
35734:  * use your version of this file under the terms of the MPL, indicate your
35734:  * decision by deleting the provisions above and replace them with the notice
35734:  * and other provisions required by the GPL or the LGPL. If you do not delete
35734:  * the provisions above, a recipient may use your version of this file under
35734:  * the terms of any one of the MPL, the GPL or the LGPL.
35734:  *
35734:  * ***** END LICENSE BLOCK ***** */
35734: 
35744: #include "mozilla/ipc/RPCChannel.h"
38100: #include "mozilla/ipc/ProtocolUtils.h"
35734: 
35734: #include "nsDebug.h"
36081: #include "nsTraceRefcnt.h"
35734: 
35977: #define RPC_ASSERT(_cond, ...)                                      \
35977:     do {                                                            \
35977:         if (!(_cond))                                               \
35977:             DebugAbort(__FILE__, __LINE__, #_cond,## __VA_ARGS__);  \
35977:     } while (0)
35977: 
35734: using mozilla::MutexAutoLock;
35899: using mozilla::MutexAutoUnlock;
35734: 
35734: template<>
35734: struct RunnableMethodTraits<mozilla::ipc::RPCChannel>
35734: {
35734:     static void RetainCallee(mozilla::ipc::RPCChannel* obj) { }
35734:     static void ReleaseCallee(mozilla::ipc::RPCChannel* obj) { }
35734: };
35734: 
38100: 
38100: namespace
38100: {
38100: 
38100: // Async (from the sending side's perspective)
38100: class BlockChildMessage : public IPC::Message
38100: {
38100: public:
38100:     enum { ID = BLOCK_CHILD_MESSAGE_TYPE };
38100:     BlockChildMessage() :
38100:         Message(MSG_ROUTING_NONE, ID, IPC::Message::PRIORITY_NORMAL)
38100:     { }
38100: };
38100: 
38100: // Async
38100: class UnblockChildMessage : public IPC::Message
38100: {
38100: public:
38100:     enum { ID = UNBLOCK_CHILD_MESSAGE_TYPE };
38100:     UnblockChildMessage() :
38100:         Message(MSG_ROUTING_NONE, ID, IPC::Message::PRIORITY_NORMAL)
38100:     { }
38100: };
38100: 
38100: } // namespace <anon>
38100: 
38100: 
35734: namespace mozilla {
35734: namespace ipc {
35734: 
39264: RPCChannel::RPCChannel(RPCListener* aListener)
36078:   : SyncChannel(aListener),
36078:     mPending(),
36078:     mStack(),
37474:     mOutOfTurnReplies(),
36078:     mDeferred(),
36078:     mRemoteStackDepthGuess(0),
39768:     mBlockedOnParent(false),
39768:     mSawRPCOutMsg(false)
36078: {
36078:     MOZ_COUNT_CTOR(RPCChannel);
39255: 
39255:     mDequeueOneTask = new RefCountedTask(NewRunnableMethod(
39255:                                                  this,
39255:                                                  &RPCChannel::OnMaybeDequeueOne));
36078: }
36078: 
36078: RPCChannel::~RPCChannel()
36078: {
36078:     MOZ_COUNT_DTOR(RPCChannel);
39614:     RPC_ASSERT(mCxxStackFrames.empty(), "mismatched CxxStackFrame ctor/dtors");
36078: }
36078: 
39255: void
39255: RPCChannel::Clear()
39255: {
39255:     mDequeueOneTask->Cancel();
39255: 
39255:     AsyncChannel::Clear();
39255: }
39255: 
35734: bool
41379: RPCChannel::EventOccurred() const
38106: {
38106:     AssertWorkerThread();
38106:     mMutex.AssertCurrentThreadOwns();
38106:     RPC_ASSERT(StackDepth() > 0, "not in wait loop");
38106: 
38106:     return (!Connected() ||
38106:             !mPending.empty() ||
38106:             (!mOutOfTurnReplies.empty() &&
38106:              mOutOfTurnReplies.find(mStack.top().seqno())
38106:              != mOutOfTurnReplies.end()));
38106: }
38106: 
38106: bool
38681: RPCChannel::Send(Message* msg)
38681: {
39614:     Message copy = *msg;
39614:     CxxStackFrame f(*this, OUT_MESSAGE, &copy);
38681:     return AsyncChannel::Send(msg);
38681: }
38681: 
38681: bool
38681: RPCChannel::Send(Message* msg, Message* reply)
38681: {
39614:     Message copy = *msg;
39614:     CxxStackFrame f(*this, OUT_MESSAGE, &copy);
38681:     return SyncChannel::Send(msg, reply);
38681: }
38681: 
38681: bool
35734: RPCChannel::Call(Message* msg, Message* reply)
35734: {
35971:     AssertWorkerThread();
36140:     mMutex.AssertNotCurrentThreadOwns();
35977:     RPC_ASSERT(!ProcessingSyncMessage(),
35859:                "violation of sync handler invariant");
35977:     RPC_ASSERT(msg->is_rpc(), "can only Call() RPC messages here");
35744: 
41474: #ifdef OS_WIN
41474:     SyncStackFrame frame(this, true);
41474: #endif
41474: 
39614:     Message copy = *msg;
39614:     CxxStackFrame f(*this, OUT_MESSAGE, &copy);
38681: 
35974:     MutexAutoLock lock(mMutex);
35974: 
36015:     if (!Connected()) {
36015:         ReportConnectionError("RPCChannel");
35940:         return false;
36015:     }
35940: 
37473:     msg->set_seqno(NextSeqno());
37473:     msg->set_rpc_remote_stack_depth_guess(mRemoteStackDepthGuess);
37473:     msg->set_rpc_local_stack_depth(1 + StackDepth());
35902:     mStack.push(*msg);
35858: 
41175:     SendThroughTransport(msg);
35778: 
35734:     while (1) {
39312:         // if a handler invoked by *Dispatch*() spun a nested event
39312:         // loop, and the connection was broken during that loop, we
39312:         // might have already processed the OnError event. if so,
39312:         // trying another loop iteration will be futile because
39312:         // channel state will have been cleared
39312:         if (!Connected()) {
39312:             ReportConnectionError("RPCChannel");
39312:             return false;
39312:         }
39312: 
36171:         // now might be the time to process a message deferred because
36171:         // of race resolution
60363:         MaybeUndeferIncall();
36171: 
35902:         // here we're waiting for something to happen. see long
35902:         // comment about the queue in RPCChannel.h
38106:         while (!EventOccurred()) {
38106:             bool maybeTimedOut = !RPCChannel::WaitForNotify();
38106: 
39796:             if (EventOccurred() ||
39796:                 // we might have received a "subtly deferred" message
39796:                 // in a nested loop that it's now time to process
39796:                 (!maybeTimedOut &&
39796:                  (!mDeferred.empty() || !mOutOfTurnReplies.empty())))
38106:                 break;
38106: 
38110:             if (maybeTimedOut && !ShouldContinueFromTimeout())
38106:                 return false;
35902:         }
35734: 
36015:         if (!Connected()) {
36015:             ReportConnectionError("RPCChannel");
35940:             return false;
36015:         }
35940: 
37474:         Message recvd;
38103:         MessageMap::iterator it;
37474:         if (!mOutOfTurnReplies.empty() &&
38103:             ((it = mOutOfTurnReplies.find(mStack.top().seqno())) !=
38103:             mOutOfTurnReplies.end())) {
38103:             recvd = it->second;
38103:             mOutOfTurnReplies.erase(it);
37474:         }
39796:         else if (!mPending.empty()) {
37474:             recvd = mPending.front();
35734:             mPending.pop();
37474:         }
39796:         else {
39796:             // because of subtleties with nested event loops, it's
39796:             // possible that we got here and nothing happened.  or, we
39796:             // might have a deferred in-call that needs to be
39796:             // processed.  either way, we won't break the inner while
39796:             // loop again until something new happens.
39796:             continue;
39796:         }
35734: 
35902:         if (!recvd.is_sync() && !recvd.is_rpc()) {
35902:             MutexAutoUnlock unlock(mMutex);
39614: 
39614:             CxxStackFrame f(*this, IN_MESSAGE, &recvd);
35902:             AsyncChannel::OnDispatchMessage(recvd);
39614: 
35902:             continue;
35902:         }
35902: 
35899:         if (recvd.is_sync()) {
35977:             RPC_ASSERT(mPending.empty(),
35977:                        "other side should have been blocked");
35899:             MutexAutoUnlock unlock(mMutex);
39614: 
39614:             CxxStackFrame f(*this, IN_MESSAGE, &recvd);
35899:             SyncChannel::OnDispatchMessage(recvd);
39614: 
35899:             continue;
35899:         }
35899: 
37473:         RPC_ASSERT(recvd.is_rpc(), "wtf???");
35899: 
35858:         if (recvd.is_reply()) {
35975:             RPC_ASSERT(0 < mStack.size(), "invalid RPC stack");
35778: 
35902:             const Message& outcall = mStack.top();
35834: 
38647:             // in the parent, seqno's increase from 0, and in the
38647:             // child, they decrease from 0
38647:             if ((!mChild && recvd.seqno() < outcall.seqno()) ||
38647:                 (mChild && recvd.seqno() > outcall.seqno())) {
38103:                 mOutOfTurnReplies[recvd.seqno()] = recvd;
37474:                 continue;
37474:             }
37474: 
35778:             // FIXME/cjones: handle error
35977:             RPC_ASSERT(
37473:                 recvd.is_reply_error() ||
37473:                 (recvd.type() == (outcall.type()+1) &&
37473:                  recvd.seqno() == outcall.seqno()),
35975:                 "somebody's misbehavin'", "rpc", true);
35778: 
35858:             // we received a reply to our most recent outstanding
35858:             // call.  pop this frame and return the reply
35902:             mStack.pop();
35834: 
35834:             bool isError = recvd.is_reply_error();
35834:             if (!isError) {
35734:                 *reply = recvd;
35834:             }
35734: 
37474:             if (0 == StackDepth()) {
37474:                 RPC_ASSERT(
37474:                     mOutOfTurnReplies.empty(),
37474:                     "still have pending replies with no pending out-calls",
37474:                     "rpc", true);
37474:             }
37474: 
35977:             // finished with this RPC stack frame
35834:             return !isError;
35734:         }
35902: 
35977:         // in-call.  process in a new stack frame.
35902: 
35858:         // "snapshot" the current stack depth while we own the Mutex
35858:         size_t stackDepth = StackDepth();
35902:         {
35899:             MutexAutoUnlock unlock(mMutex);
35734:             // someone called in to us from the other side.  handle the call
39614:             CxxStackFrame f(*this, IN_MESSAGE, &recvd);
35977:             Incall(recvd, stackDepth);
35778:             // FIXME/cjones: error handling
35734:         }
35734:     }
35734: 
35734:     return true;
35734: }
35734: 
60363: void
60363: RPCChannel::MaybeUndeferIncall()
35902: {
35971:     AssertWorkerThread();
35977:     mMutex.AssertCurrentThreadOwns();
35977: 
35977:     if (mDeferred.empty())
60363:         return;
35977: 
35977:     size_t stackDepth = StackDepth();
35977: 
35977:     // the other side can only *under*-estimate our actual stack depth
35977:     RPC_ASSERT(mDeferred.top().rpc_remote_stack_depth_guess() <= stackDepth,
35977:                "fatal logic error");
35977: 
35977:     if (mDeferred.top().rpc_remote_stack_depth_guess() < stackDepth)
60363:         return;
35977: 
60363:     // maybe time to process this message
35977:     Message call = mDeferred.top();
35977:     mDeferred.pop();
35977: 
35977:     // fix up fudge factor we added to account for race
35977:     RPC_ASSERT(0 < mRemoteStackDepthGuess, "fatal logic error");
35977:     --mRemoteStackDepthGuess;
35977: 
60363:     mPending.push(call);
35977: }
35977: 
35977: void
35977: RPCChannel::EnqueuePendingMessages()
35977: {
36171:     AssertWorkerThread();
36171:     mMutex.AssertCurrentThreadOwns();
36171: 
60363:     MaybeUndeferIncall();
60363: 
38277:     for (size_t i = 0; i < mDeferred.size(); ++i)
36171:         mWorkerLoop->PostTask(
36171:             FROM_HERE,
39255:             new DequeueTask(mDequeueOneTask));
36171: 
35977:     // XXX performance tuning knob: could process all or k pending
35977:     // messages here, rather than enqueuing for later processing
35977: 
35977:     for (size_t i = 0; i < mPending.size(); ++i)
35977:         mWorkerLoop->PostTask(
35977:             FROM_HERE,
39255:             new DequeueTask(mDequeueOneTask));
35902: }
35902: 
35902: void
42538: RPCChannel::FlushPendingRPCQueue()
42538: {
42538:     AssertWorkerThread();
42538:     mMutex.AssertNotCurrentThreadOwns();
42538: 
42538:     {
42538:         MutexAutoLock lock(mMutex);
42538: 
42538:         if (mDeferred.empty()) {
42538:             if (mPending.empty())
42538:                 return;
42538: 
42538:             const Message& last = mPending.back();
42538:             if (!last.is_rpc() || last.is_reply())
42538:                 return;
42538:         }
42538:     }
42538: 
42538:     while (OnMaybeDequeueOne());
42538: }
42538: 
42538: bool
35941: RPCChannel::OnMaybeDequeueOne()
35941: {
35977:     // XXX performance tuning knob: could process all or k pending
35977:     // messages here
35977: 
35971:     AssertWorkerThread();
35977:     mMutex.AssertNotCurrentThreadOwns();
35977: 
35941:     Message recvd;
35941:     {
35941:         MutexAutoLock lock(mMutex);
35941: 
39261:         if (!Connected()) {
39261:             ReportConnectionError("RPCChannel");
42538:             return false;
39261:         }
39261: 
36171:         if (!mDeferred.empty())
60363:             MaybeUndeferIncall();
36171: 
35941:         if (mPending.empty())
42538:             return false;
35941: 
35941:         recvd = mPending.front();
35941:         mPending.pop();
35941:     }
35977: 
39632:     if (IsOnCxxStack() && recvd.is_rpc() && recvd.is_reply()) {
39632:         // We probably just received a reply in a nested loop for an
39632:         // RPC call sent before entering that loop.
39632:         mOutOfTurnReplies[recvd.seqno()] = recvd;
42538:         return false;
39632:     }
39632: 
39614:     CxxStackFrame f(*this, IN_MESSAGE, &recvd);
38681: 
35977:     if (recvd.is_rpc())
42538:         Incall(recvd, 0);
35977:     else if (recvd.is_sync())
42538:         SyncChannel::OnDispatchMessage(recvd);
35977:     else
42538:         AsyncChannel::OnDispatchMessage(recvd);
42538: 
42538:     return true;
35941: }
35941: 
35941: void
35977: RPCChannel::Incall(const Message& call, size_t stackDepth)
35858: {
35971:     AssertWorkerThread();
35858:     mMutex.AssertNotCurrentThreadOwns();
35977:     RPC_ASSERT(call.is_rpc() && !call.is_reply(), "wrong message type");
35858: 
35974:     // Race detection: see the long comment near
35974:     // mRemoteStackDepthGuess in RPCChannel.h.  "Remote" stack depth
35974:     // means our side, and "local" means other side.
51832:     //
51832:     // We compare the remote stack depth guess against the "remote
51832:     // view of stack depth" because of out-of-turn replies.  When we
51832:     // receive one, our actual RPC stack depth doesn't decrease, but
51832:     // the other side (that sent the reply) thinks it has.  So, just
51832:     // adjust down by the number of out-of-turn replies.
51832:     size_t remoteViewOfStackDepth = (stackDepth - mOutOfTurnReplies.size());
51832:     if (call.rpc_remote_stack_depth_guess() != remoteViewOfStackDepth) {
39299:         // RPC in-calls have raced.
35974:         // the "winner", if there is one, gets to defer processing of
35974:         // the other side's in-call
35974:         bool defer;
35974:         const char* winner;
39264:         switch (Listener()->MediateRPCRace(mChild ? call : mStack.top(),
39264:                                            mChild ? mStack.top() : call)) {
35974:         case RRPChildWins:
35974:             winner = "child";
35974:             defer = mChild;
35974:             break;
35974:         case RRPParentWins:
35974:             winner = "parent";
35974:             defer = !mChild;
35974:             break;
35974:         case RRPError:
35974:             NS_RUNTIMEABORT("NYI: 'Error' RPC race policy");
35974:             return;
35974:         default:
35974:             NS_RUNTIMEABORT("not reached");
35974:             return;
35974:         }
35974: 
42293:         if (LoggingEnabled()) {
60363:             fprintf(stderr, "  (%s: %s won, so we're%sdeferring)\n",
60363:                     mChild ? "child" : "parent", winner, defer ? " " : " not ");
42293:         }
35974: 
35974:         if (defer) {
35977:             // we now know the other side's stack has one more frame
35977:             // than we thought
35977:             ++mRemoteStackDepthGuess; // decremented in MaybeProcessDeferred()
35977:             mDeferred.push(call);
35974:             return;
35974:         }
35974: 
35977:         // we "lost" and need to process the other side's in-call.
35977:         // don't need to fix up the mRemoteStackDepthGuess here,
35977:         // because we're just about to increment it in DispatchCall(),
35977:         // which will make it correct again
35974:     }
35858: 
35977:     DispatchIncall(call);
35977: }
35977: 
35977: void
35977: RPCChannel::DispatchIncall(const Message& call)
35977: {
35977:     AssertWorkerThread();
35977:     mMutex.AssertNotCurrentThreadOwns();
35977:     RPC_ASSERT(call.is_rpc() && !call.is_reply(),
35977:                "wrong message type");
35977: 
35834:     Message* reply = nsnull;
35858: 
35974:     ++mRemoteStackDepthGuess;
39264:     Result rv = Listener()->OnCallReceived(call, reply);
35974:     --mRemoteStackDepthGuess;
35858: 
36015:     if (!MaybeHandleError(rv, "RPCChannel")) {
35834:         delete reply;
35834:         reply = new Message();
35834:         reply->set_rpc();
35834:         reply->set_reply();
35834:         reply->set_reply_error();
35734:     }
35912: 
37473:     reply->set_seqno(call.seqno());
37473: 
38124:     {
38124:         MutexAutoLock lock(mMutex);
38124:         if (ChannelConnected == mChannelState)
41175:             SendThroughTransport(reply);
35977:     }
38124: }
35912: 
38100: bool
38100: RPCChannel::BlockChild()
38100: {
38100:     AssertWorkerThread();
38100: 
38100:     if (mChild)
38100:         NS_RUNTIMEABORT("child tried to block parent");
38100:     SendSpecialMessage(new BlockChildMessage());
38100:     return true;
38100: }
38100: 
38100: bool
38100: RPCChannel::UnblockChild()
38100: {
38100:     AssertWorkerThread();
38100: 
38100:     if (mChild)
38100:         NS_RUNTIMEABORT("child tried to unblock parent");
38100:     SendSpecialMessage(new UnblockChildMessage());
38100:     return true;
38100: }
38100: 
38100: bool
38100: RPCChannel::OnSpecialMessage(uint16 id, const Message& msg)
38100: {
38100:     AssertWorkerThread();
38100: 
38100:     switch (id) {
38100:     case BLOCK_CHILD_MESSAGE_TYPE:
38100:         BlockOnParent();
38100:         return true;
38100: 
38100:     case UNBLOCK_CHILD_MESSAGE_TYPE:
38100:         UnblockFromParent();
38100:         return true;
38100: 
38100:     default:
38100:         return SyncChannel::OnSpecialMessage(id, msg);
38100:     }
38100: }
38100: 
38100: void
38100: RPCChannel::BlockOnParent()
38100: {
38100:     AssertWorkerThread();
38100: 
38100:     if (!mChild)
38100:         NS_RUNTIMEABORT("child tried to block parent");
38100: 
38100:     MutexAutoLock lock(mMutex);
38100: 
38100:     if (mBlockedOnParent || AwaitingSyncReply() || 0 < StackDepth())
38100:         NS_RUNTIMEABORT("attempt to block child when it's already blocked");
38100: 
38100:     mBlockedOnParent = true;
38102:     do {
38100:         // XXX this dispatch loop shares some similarities with the
38100:         // one in Call(), but the logic is simpler and different
38100:         // enough IMHO to warrant its own dispatch loop
38100:         while (Connected() && mPending.empty() && mBlockedOnParent) {
38100:             WaitForNotify();
38100:         }
38100: 
38100:         if (!Connected()) {
38100:             mBlockedOnParent = false;
38100:             ReportConnectionError("RPCChannel");
38100:             break;
38100:         }
38100: 
38100:         if (!mPending.empty()) {
38100:             Message recvd = mPending.front();
38100:             mPending.pop();
38100: 
38100:             MutexAutoUnlock unlock(mMutex);
39614: 
39614:             CxxStackFrame f(*this, IN_MESSAGE, &recvd);
38100:             if (recvd.is_rpc()) {
38100:                 // stack depth must be 0 here
38100:                 Incall(recvd, 0);
38100:             }
38100:             else if (recvd.is_sync()) {
38100:                 SyncChannel::OnDispatchMessage(recvd);
38100:             }
38100:             else {
38100:                 AsyncChannel::OnDispatchMessage(recvd);
38100:             }
38100:         }
38102:     } while (mBlockedOnParent);
38100: 
38100:     EnqueuePendingMessages();
38100: }
38100: 
38100: void
38100: RPCChannel::UnblockFromParent()
38100: {
38100:     AssertWorkerThread();
38100: 
38100:     if (!mChild)
38100:         NS_RUNTIMEABORT("child tried to block parent");
38100:     MutexAutoLock lock(mMutex);
38100:     mBlockedOnParent = false;
38100: }
35977: 
35977: void
39615: RPCChannel::ExitedCxxStack()
39615: {
39615:     Listener()->OnExitedCxxStack();
39768:     if (mSawRPCOutMsg) {
39615:         MutexAutoLock lock(mMutex);
39615:         // see long comment in OnMaybeDequeueOne()
39615:         EnqueuePendingMessages();
39768:         mSawRPCOutMsg = false;
39615:     }
39615: }
39615: 
39615: void
35977: RPCChannel::DebugAbort(const char* file, int line, const char* cond,
35977:                        const char* why,
41379:                        const char* type, bool reply) const
35977: {
35977:     fprintf(stderr,
35992:             "###!!! [RPCChannel][%s][%s:%d] "
35977:             "Assertion (%s) failed.  %s (triggered by %s%s)\n",
35977:             mChild ? "Child" : "Parent",
35977:             file, line, cond,
35977:             why,
35977:             type, reply ? "reply" : "");
35977:     // technically we need the mutex for this, but we're dying anyway
39614:     DumpRPCStack(stderr, "  ");
35977:     fprintf(stderr, "  remote RPC stack guess: %lu\n",
35977:             mRemoteStackDepthGuess);
35977:     fprintf(stderr, "  deferred stack size: %lu\n",
35977:             mDeferred.size());
37474:     fprintf(stderr, "  out-of-turn RPC replies stack size: %lu\n",
37474:             mOutOfTurnReplies.size());
35977:     fprintf(stderr, "  Pending queue size: %lu, front to back:\n",
35977:             mPending.size());
41379: 
41379:     MessageQueue pending = mPending;
41379:     while (!pending.empty()) {
35977:         fprintf(stderr, "    [ %s%s ]\n",
41379:                 pending.front().is_rpc() ? "rpc" :
41379:                 (pending.front().is_sync() ? "sync" : "async"),
41379:                 pending.front().is_reply() ? "reply" : "");
41379:         pending.pop();
35977:     }
35977: 
35977:     NS_RUNTIMEABORT(why);
35734: }
35734: 
39614: void
41379: RPCChannel::DumpRPCStack(FILE* outfile, const char* const pfx) const
39614: {
39614:     NS_WARN_IF_FALSE(MessageLoop::current() != mWorkerLoop,
39614:                      "The worker thread had better be paused in a debugger!");
39614: 
39614:     if (!outfile)
39614:         outfile = stdout;
39614: 
39614:     fprintf(outfile, "%sRPCChannel 'backtrace':\n", pfx);
39614: 
39614:     // print a python-style backtrace, first frame to last
39614:     for (PRUint32 i = 0; i < mCxxStackFrames.size(); ++i) {
39614:         int32 id;
39614:         const char* dir, *sems, *name;
39614:         mCxxStackFrames[i].Describe(&id, &dir, &sems, &name);
39614: 
39614:         fprintf(outfile, "%s[(%u) %s %s %s(actor=%d) ]\n", pfx,
39614:                 i, dir, sems, name, id);
39614:     }
39614: }
39614: 
35734: //
35734: // The methods below run in the context of the IO thread, and can proxy
35734: // back to the methods above
35734: //
35734: 
35734: void
35734: RPCChannel::OnMessageReceived(const Message& msg)
35778: {
35971:     AssertIOThread();
35899:     MutexAutoLock lock(mMutex);
35899: 
39261:     if (MaybeInterceptSpecialIOMessage(msg))
39261:         return;
39261: 
35941:     // regardless of the RPC stack, if we're awaiting a sync reply, we
35941:     // know that it needs to be immediately handled to unblock us.
35977:     if (AwaitingSyncReply() && msg.is_sync()) {
35977:         // wake up worker thread waiting at SyncChannel::Send
35941:         mRecvd = msg;
35977:         NotifyWorkerThread();
35941:         return;
35941:     }
35941: 
35941:     mPending.push(msg);
35941: 
39255:     if (0 == StackDepth() && !mBlockedOnParent) {
35977:         // the worker thread might be idle, make sure it wakes up
39255:         mWorkerLoop->PostTask(FROM_HERE, new DequeueTask(mDequeueOneTask));
39255:     }
38106:     else if (!AwaitingSyncReply())
35977:         NotifyWorkerThread();
35734: }
35734: 
35734: 
35940: void
35940: RPCChannel::OnChannelError()
35940: {
35971:     AssertIOThread();
36140: 
38316:     MutexAutoLock lock(mMutex);
38316: 
38316:     if (ChannelClosing != mChannelState)
38316:         mChannelState = ChannelError;
36140: 
36140:     // skip SyncChannel::OnError(); we subsume its duties
38316:     if (AwaitingSyncReply() || 0 < StackDepth())
35977:         NotifyWorkerThread();
38316: 
39611:     PostErrorNotifyTask();
35940: }
35940: 
35734: } // namespace ipc
35734: } // namespace mozilla
35977: 
