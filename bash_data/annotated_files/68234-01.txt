29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS standard exception implementation.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsbit.h"
55477: #include "jsutil.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsdbgapi.h"
    1: #include "jsexn.h"
    1: #include "jsfun.h"
    1: #include "jsinterp.h"
    1: #include "jsnum.h"
12581: #include "jsobj.h"
    1: #include "jsopcode.h"
12581: #include "jsscope.h"
    1: #include "jsscript.h"
18989: #include "jsstaticcheck.h"
57674: #include "jswrapper.h"
    1: 
48470: #include "jscntxtinlines.h"
53840: #include "jsinterpinlines.h"
40858: #include "jsobjinlines.h"
40858: 
40221: using namespace js;
54707: using namespace js::gc;
40221: 
    1: /* Forward declarations for js_ErrorClass's initializer. */
    1: static JSBool
53557: Exception(JSContext *cx, uintN argc, Value *vp);
    1: 
    1: static void
  583: exn_trace(JSTracer *trc, JSObject *obj);
    1: 
    1: static void
    1: exn_finalize(JSContext *cx, JSObject *obj);
    1: 
    1: static JSBool
    1: exn_enumerate(JSContext *cx, JSObject *obj);
    1: 
    1: static JSBool
48470: exn_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:             JSObject **objp);
    1: 
48470: Class js_ErrorClass = {
    1:     js_Error_str,
  583:     JSCLASS_HAS_PRIVATE | JSCLASS_NEW_RESOLVE | JSCLASS_MARK_IS_TRACE |
    1:     JSCLASS_HAS_CACHED_PROTO(JSProto_Error),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     exn_enumerate,
48622:     (JSResolveOp)exn_resolve,
48622:     ConvertStub,
48622:     exn_finalize,
48622:     NULL,                 /* reserved0   */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
55515:     NULL,                 /* construct   */
48622:     NULL,                 /* xdrObject   */
48622:     NULL,                 /* hasInstance */
48622:     JS_CLASS_TRACE(exn_trace)
    1: };
    1: 
    1: typedef struct JSStackTraceElem {
    1:     JSString            *funName;
    1:     size_t              argc;
    1:     const char          *filename;
    1:     uintN               ulineno;
    1: } JSStackTraceElem;
    1: 
    1: typedef struct JSExnPrivate {
    1:     /* A copy of the JSErrorReport originally generated. */
    1:     JSErrorReport       *errorReport;
    1:     JSString            *message;
    1:     JSString            *filename;
    1:     uintN               lineno;
    1:     size_t              stackDepth;
    1:     JSStackTraceElem    stackElems[1];
    1: } JSExnPrivate;
    1: 
    1: static JSString *
    1: StackTraceToString(JSContext *cx, JSExnPrivate *priv);
    1: 
    1: static JSErrorReport *
    1: CopyErrorReport(JSContext *cx, JSErrorReport *report)
    1: {
    1:     /*
    1:      * We use a single malloc block to make a deep copy of JSErrorReport with
    1:      * the following layout:
    1:      *   JSErrorReport
    1:      *   array of copies of report->messageArgs
    1:      *   jschar array with characters for all messageArgs
    1:      *   jschar array with characters for ucmessage
    1:      *   jschar array with characters for uclinebuf and uctokenptr
    1:      *   char array with characters for linebuf and tokenptr
    1:      *   char array with characters for filename
    1:      * Such layout together with the properties enforced by the following
    1:      * asserts does not need any extra alignment padding.
    1:      */
    1:     JS_STATIC_ASSERT(sizeof(JSErrorReport) % sizeof(const char *) == 0);
    1:     JS_STATIC_ASSERT(sizeof(const char *) % sizeof(jschar) == 0);
    1: 
    1:     size_t filenameSize;
    1:     size_t linebufSize;
    1:     size_t uclinebufSize;
    1:     size_t ucmessageSize;
    1:     size_t i, argsArraySize, argsCopySize, argSize;
    1:     size_t mallocSize;
    1:     JSErrorReport *copy;
    1:     uint8 *cursor;
    1: 
    1: #define JS_CHARS_SIZE(jschars) ((js_strlen(jschars) + 1) * sizeof(jschar))
    1: 
    1:     filenameSize = report->filename ? strlen(report->filename) + 1 : 0;
    1:     linebufSize = report->linebuf ? strlen(report->linebuf) + 1 : 0;
    1:     uclinebufSize = report->uclinebuf ? JS_CHARS_SIZE(report->uclinebuf) : 0;
    1:     ucmessageSize = 0;
    1:     argsArraySize = 0;
    1:     argsCopySize = 0;
    1:     if (report->ucmessage) {
    1:         ucmessageSize = JS_CHARS_SIZE(report->ucmessage);
    1:         if (report->messageArgs) {
    1:             for (i = 0; report->messageArgs[i]; ++i)
    1:                 argsCopySize += JS_CHARS_SIZE(report->messageArgs[i]);
    1: 
    1:             /* Non-null messageArgs should have at least one non-null arg. */
    1:             JS_ASSERT(i != 0);
    1:             argsArraySize = (i + 1) * sizeof(const jschar *);
    1:         }
    1:     }
    1: 
    1:     /*
    1:      * The mallocSize can not overflow since it represents the sum of the
    1:      * sizes of already allocated objects.
    1:      */
    1:     mallocSize = sizeof(JSErrorReport) + argsArraySize + argsCopySize +
    1:                  ucmessageSize + uclinebufSize + linebufSize + filenameSize;
30851:     cursor = (uint8 *)cx->malloc(mallocSize);
    1:     if (!cursor)
    1:         return NULL;
    1: 
    1:     copy = (JSErrorReport *)cursor;
    1:     memset(cursor, 0, sizeof(JSErrorReport));
    1:     cursor += sizeof(JSErrorReport);
    1: 
    1:     if (argsArraySize != 0) {
    1:         copy->messageArgs = (const jschar **)cursor;
    1:         cursor += argsArraySize;
    1:         for (i = 0; report->messageArgs[i]; ++i) {
    1:             copy->messageArgs[i] = (const jschar *)cursor;
    1:             argSize = JS_CHARS_SIZE(report->messageArgs[i]);
    1:             memcpy(cursor, report->messageArgs[i], argSize);
    1:             cursor += argSize;
    1:         }
    1:         copy->messageArgs[i] = NULL;
    1:         JS_ASSERT(cursor == (uint8 *)copy->messageArgs[0] + argsCopySize);
    1:     }
    1: 
    1:     if (report->ucmessage) {
    1:         copy->ucmessage = (const jschar *)cursor;
    1:         memcpy(cursor, report->ucmessage, ucmessageSize);
    1:         cursor += ucmessageSize;
    1:     }
    1: 
    1:     if (report->uclinebuf) {
    1:         copy->uclinebuf = (const jschar *)cursor;
    1:         memcpy(cursor, report->uclinebuf, uclinebufSize);
    1:         cursor += uclinebufSize;
    1:         if (report->uctokenptr) {
    1:             copy->uctokenptr = copy->uclinebuf + (report->uctokenptr -
    1:                                                   report->uclinebuf);
    1:         }
    1:     }
    1: 
    1:     if (report->linebuf) {
    1:         copy->linebuf = (const char *)cursor;
    1:         memcpy(cursor, report->linebuf, linebufSize);
    1:         cursor += linebufSize;
    1:         if (report->tokenptr) {
    1:             copy->tokenptr = copy->linebuf + (report->tokenptr -
    1:                                               report->linebuf);
    1:         }
    1:     }
    1: 
    1:     if (report->filename) {
    1:         copy->filename = (const char *)cursor;
    1:         memcpy(cursor, report->filename, filenameSize);
    1:     }
    1:     JS_ASSERT(cursor + filenameSize == (uint8 *)copy + mallocSize);
    1: 
    1:     /* Copy non-pointer members. */
    1:     copy->lineno = report->lineno;
    1:     copy->errorNumber = report->errorNumber;
    1: 
    1:     /* Note that this is before it gets flagged with JSREPORT_EXCEPTION */
    1:     copy->flags = report->flags;
    1: 
    1: #undef JS_CHARS_SIZE
    1:     return copy;
    1: }
    1: 
    1: static jsval *
    1: GetStackTraceValueBuffer(JSExnPrivate *priv)
    1: {
    1:     /*
    1:      * We use extra memory after JSExnPrivateInfo.stackElems to store jsvals
    1:      * that helps to produce more informative stack traces. The following
    1:      * assert allows us to assume that no gap after stackElems is necessary to
    1:      * align the buffer properly.
    1:      */
    1:     JS_STATIC_ASSERT(sizeof(JSStackTraceElem) % sizeof(jsval) == 0);
    1: 
    1:     return (jsval *)(priv->stackElems + priv->stackDepth);
    1: }
    1: 
    1: static JSBool
    1: InitExnPrivate(JSContext *cx, JSObject *exnObject, JSString *message,
    1:                JSString *filename, uintN lineno, JSErrorReport *report)
    1: {
18870:     JSSecurityCallbacks *callbacks;
48470:     CheckAccessOp checkAccess;
    1:     JSErrorReporter older;
    1:     JSExceptionState *state;
48470:     jsid callerid;
    1:     JSStackFrame *fp, *fpstop;
    1:     size_t stackDepth, valueCount, size;
    1:     JSBool overflow;
    1:     JSExnPrivate *priv;
    1:     JSStackTraceElem *elem;
    1:     jsval *values;
    1: 
40826:     JS_ASSERT(exnObject->getClass() == &js_ErrorClass);
    1: 
    1:     /*
    1:      * Prepare stack trace data.
    1:      *
    1:      * Set aside any error reporter for cx and save its exception state
    1:      * so we can suppress any checkAccess failures.  Such failures should stop
    1:      * the backtrace procedure, not result in a failure of this constructor.
    1:      */
18870:     callbacks = JS_GetSecurityCallbacks(cx);
18870:     checkAccess = callbacks
48470:                   ? Valueify(callbacks->checkObjectAccess)
18870:                   : NULL;
    1:     older = JS_SetErrorReporter(cx, NULL);
    1:     state = JS_SaveExceptionState(cx);
    1: 
48470:     callerid = ATOM_TO_JSID(cx->runtime->atomState.callerAtom);
    1:     stackDepth = 0;
    1:     valueCount = 0;
53840:     for (fp = js_GetTopStackFrame(cx); fp; fp = fp->prev()) {
68234:         if (fp->scopeChain().compartment() != cx->compartment)
68234:             break;
53840:         if (fp->isFunctionFrame() && !fp->isEvalFrame()) {
48470:             Value v = NullValue();
 4130:             if (checkAccess &&
53840:                 !checkAccess(cx, &fp->callee(), callerid, JSACC_READ, &v)) {
    1:                 break;
    1:             }
51120:             valueCount += fp->numActualArgs();
    1:         }
    1:         ++stackDepth;
    1:     }
    1:     JS_RestoreExceptionState(cx, state);
    1:     JS_SetErrorReporter(cx, older);
    1:     fpstop = fp;
    1: 
    1:     size = offsetof(JSExnPrivate, stackElems);
    1:     overflow = (stackDepth > ((size_t)-1 - size) / sizeof(JSStackTraceElem));
    1:     size += stackDepth * sizeof(JSStackTraceElem);
    1:     overflow |= (valueCount > ((size_t)-1 - size) / sizeof(jsval));
    1:     size += valueCount * sizeof(jsval);
    1:     if (overflow) {
12983:         js_ReportAllocationOverflow(cx);
    1:         return JS_FALSE;
    1:     }
30851:     priv = (JSExnPrivate *)cx->malloc(size);
    1:     if (!priv)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * We initialize errorReport with a copy of report after setting the
    1:      * private slot, to prevent GC accessing a junk value we clear the field
    1:      * here.
    1:      */
    1:     priv->errorReport = NULL;
    1:     priv->message = message;
    1:     priv->filename = filename;
    1:     priv->lineno = lineno;
    1:     priv->stackDepth = stackDepth;
    1: 
    1:     values = GetStackTraceValueBuffer(priv);
    1:     elem = priv->stackElems;
53840:     for (fp = js_GetTopStackFrame(cx); fp != fpstop; fp = fp->prev()) {
68234:         if (fp->scopeChain().compartment() != cx->compartment)
68234:             break;
53840:         if (!fp->isFunctionFrame() || fp->isEvalFrame()) {
    1:             elem->funName = NULL;
    1:             elem->argc = 0;
    1:         } else {
53840:             elem->funName = fp->fun()->atom
53840:                             ? ATOM_TO_STRING(fp->fun()->atom)
    1:                             : cx->runtime->emptyString;
51120:             elem->argc = fp->numActualArgs();
57718:             fp->forEachCanonicalActualArg(CopyTo(Valueify(values)));
51120:             values += elem->argc;
    1:         }
    1:         elem->ulineno = 0;
    1:         elem->filename = NULL;
53840:         if (fp->isScriptFrame()) {
53840:             elem->filename = fp->script()->filename;
42717:             if (fp->pc(cx))
21685:                 elem->ulineno = js_FramePCToLineNumber(cx, fp);
    1:         }
    1:         ++elem;
    1:     }
    1:     JS_ASSERT(priv->stackElems + stackDepth == elem);
    1:     JS_ASSERT(GetStackTraceValueBuffer(priv) + valueCount == values);
    1: 
31452:     exnObject->setPrivate(priv);
    1: 
    1:     if (report) {
    1:         /*
    1:          * Construct a new copy of the error report struct. We can't use the
    1:          * error report struct that was passed in, because it's allocated on
    1:          * the stack, and also because it may point to transient data in the
40320:          * TokenStream.
    1:          */
    1:         priv->errorReport = CopyErrorReport(cx, report);
    1:         if (!priv->errorReport) {
    1:             /* The finalizer realeases priv since it is in the private slot. */
    1:             return JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
31452: static inline JSExnPrivate *
    1: GetExnPrivate(JSContext *cx, JSObject *obj)
    1: {
31452:     return (JSExnPrivate *) obj->getPrivate();
    1: }
    1: 
  583: static void
  583: exn_trace(JSTracer *trc, JSObject *obj)
    1: {
    1:     JSExnPrivate *priv;
    1:     JSStackTraceElem *elem;
    1:     size_t vcount, i;
    1:     jsval *vp, v;
    1: 
  583:     priv = GetExnPrivate(trc->context, obj);
    1:     if (priv) {
  583:         if (priv->message)
54707:             MarkString(trc, priv->message, "exception message");
  583:         if (priv->filename)
54707:             MarkString(trc, priv->filename, "exception filename");
  583: 
    1:         elem = priv->stackElems;
    1:         for (vcount = i = 0; i != priv->stackDepth; ++i, ++elem) {
54707:             if (elem->funName)
54707:                 MarkString(trc, elem->funName, "stack trace function name");
  583:             if (IS_GC_MARKING_TRACER(trc) && elem->filename)
    1:                 js_MarkScriptFilename(elem->filename);
    1:             vcount += elem->argc;
    1:         }
    1:         vp = GetStackTraceValueBuffer(priv);
    1:         for (i = 0; i != vcount; ++i, ++vp) {
    1:             v = *vp;
  583:             JS_CALL_VALUE_TRACER(trc, v, "stack trace argument");
    1:         }
    1:     }
    1: }
    1: 
    1: static void
    1: exn_finalize(JSContext *cx, JSObject *obj)
    1: {
    1:     JSExnPrivate *priv;
    1: 
    1:     priv = GetExnPrivate(cx, obj);
    1:     if (priv) {
    1:         if (priv->errorReport)
30851:             cx->free(priv->errorReport);
30851:         cx->free(priv);
    1:     }
    1: }
    1: 
    1: static JSBool
    1: exn_enumerate(JSContext *cx, JSObject *obj)
    1: {
    1:     JSAtomState *atomState;
    1:     uintN i;
    1:     JSAtom *atom;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
    1: 
    1:     JS_STATIC_ASSERT(sizeof(JSAtomState) <= (size_t)(uint16)-1);
    1:     static const uint16 offsets[] = {
    1:         (uint16)offsetof(JSAtomState, messageAtom),
    1:         (uint16)offsetof(JSAtomState, fileNameAtom),
    1:         (uint16)offsetof(JSAtomState, lineNumberAtom),
    1:         (uint16)offsetof(JSAtomState, stackAtom),
    1:     };
    1: 
    1:     atomState = &cx->runtime->atomState;
    1:     for (i = 0; i != JS_ARRAY_LENGTH(offsets); ++i) {
    1:         atom = *(JSAtom **)((uint8 *)atomState + offsets[i]);
    1:         if (!js_LookupProperty(cx, obj, ATOM_TO_JSID(atom), &pobj, &prop))
    1:             return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: exn_resolve(JSContext *cx, JSObject *obj, jsid id, uintN flags,
    1:             JSObject **objp)
    1: {
    1:     JSExnPrivate *priv;
    1:     JSString *str;
    1:     JSAtom *atom;
    1:     JSString *stack;
    1:     const char *prop;
    1:     jsval v;
    1: 
    1:     *objp = NULL;
    1:     priv = GetExnPrivate(cx, obj);
48470:     if (priv && JSID_IS_ATOM(id)) {
48470:         str = JSID_TO_STRING(id);
    1: 
    1:         atom = cx->runtime->atomState.messageAtom;
    1:         if (str == ATOM_TO_STRING(atom)) {
    1:             prop = js_message_str;
    1:             v = STRING_TO_JSVAL(priv->message);
    1:             goto define;
    1:         }
    1: 
    1:         atom = cx->runtime->atomState.fileNameAtom;
    1:         if (str == ATOM_TO_STRING(atom)) {
    1:             prop = js_fileName_str;
    1:             v = STRING_TO_JSVAL(priv->filename);
    1:             goto define;
    1:         }
    1: 
    1:         atom = cx->runtime->atomState.lineNumberAtom;
    1:         if (str == ATOM_TO_STRING(atom)) {
    1:             prop = js_lineNumber_str;
    1:             v = INT_TO_JSVAL(priv->lineno);
    1:             goto define;
    1:         }
    1: 
    1:         atom = cx->runtime->atomState.stackAtom;
    1:         if (str == ATOM_TO_STRING(atom)) {
    1:             stack = StackTraceToString(cx, priv);
    1:             if (!stack)
    1:                 return JS_FALSE;
    1: 
    1:             /* Allow to GC all things that were used to build stack trace. */
    1:             priv->stackDepth = 0;
    1:             prop = js_stack_str;
    1:             v = STRING_TO_JSVAL(stack);
    1:             goto define;
    1:         }
    1:     }
    1:     return JS_TRUE;
    1: 
    1:   define:
    1:     if (!JS_DefineProperty(cx, obj, prop, v, NULL, NULL, JSPROP_ENUMERATE))
    1:         return JS_FALSE;
    1:     *objp = obj;
    1:     return JS_TRUE;
    1: }
    1: 
    1: JSErrorReport *
    1: js_ErrorFromException(JSContext *cx, jsval exn)
    1: {
    1:     JSObject *obj;
    1:     JSExnPrivate *priv;
    1: 
    1:     if (JSVAL_IS_PRIMITIVE(exn))
    1:         return NULL;
    1:     obj = JSVAL_TO_OBJECT(exn);
40826:     if (obj->getClass() != &js_ErrorClass)
    1:         return NULL;
    1:     priv = GetExnPrivate(cx, obj);
    1:     if (!priv)
    1:         return NULL;
    1:     return priv->errorReport;
    1: }
    1: 
    1: static JSString *
    1: ValueToShortSource(JSContext *cx, jsval v)
    1: {
    1:     JSString *str;
    1: 
    1:     /* Avoid toSource bloat and fallibility for object types. */
57674:     if (JSVAL_IS_PRIMITIVE(v))
57674:         return js_ValueToSource(cx, Valueify(v));
57674: 
57674:     AutoCompartment ac(cx, JSVAL_TO_OBJECT(v));
57674:     if (!ac.enter())
57674:         return NULL;
57674: 
57674:     if (VALUE_IS_FUNCTION(cx, v)) {
    1:         /*
    1:          * XXX Avoid function decompilation bloat for now.
    1:          */
    1:         str = JS_GetFunctionId(JS_ValueToFunction(cx, v));
48470:         if (!str && !(str = js_ValueToSource(cx, Valueify(v)))) {
    1:             /*
    1:              * Continue to soldier on if the function couldn't be
    1:              * converted into a string.
    1:              */
    1:             JS_ClearPendingException(cx);
    1:             str = JS_NewStringCopyZ(cx, "[unknown function]");
    1:         }
    1:     } else {
    1:         /*
    1:          * XXX Avoid toString on objects, it takes too long and uses too much
    1:          * memory, for too many classes (see Mozilla bug 166743).
    1:          */
    1:         char buf[100];
    1:         JS_snprintf(buf, sizeof buf, "[object %s]",
40826:                     JSVAL_TO_OBJECT(v)->getClass()->name);
    1:         str = JS_NewStringCopyZ(cx, buf);
    1:     }
57674: 
57674:     ac.leave();
57674: 
57674:     if (!str || !cx->compartment->wrap(cx, &str))
57674:         return NULL;
    1:     return str;
    1: }
    1: 
    1: static JSString *
    1: StackTraceToString(JSContext *cx, JSExnPrivate *priv)
    1: {
    1:     jschar *stackbuf;
    1:     size_t stacklen, stackmax;
    1:     JSStackTraceElem *elem, *endElem;
    1:     jsval *values;
    1:     size_t i;
    1:     JSString *str;
    1:     const char *cp;
    1:     char ulnbuf[11];
    1: 
    1:     /* After this point, failing control flow must goto bad. */
    1:     stackbuf = NULL;
    1:     stacklen = stackmax = 0;
    1: 
    1: /* Limit the stackbuf length to a reasonable value to avoid overflow checks. */
    1: #define STACK_LENGTH_LIMIT JS_BIT(20)
    1: 
    1: #define APPEND_CHAR_TO_STACK(c)                                               \
    1:     JS_BEGIN_MACRO                                                            \
    1:         if (stacklen == stackmax) {                                           \
    1:             void *ptr_;                                                       \
    1:             if (stackmax >= STACK_LENGTH_LIMIT)                               \
    1:                 goto done;                                                    \
    1:             stackmax = stackmax ? 2 * stackmax : 64;                          \
30851:             ptr_ = cx->realloc(stackbuf, (stackmax+1) * sizeof(jschar));      \
    1:             if (!ptr_)                                                        \
    1:                 goto bad;                                                     \
 3164:             stackbuf = (jschar *) ptr_;                                       \
    1:         }                                                                     \
    1:         stackbuf[stacklen++] = (c);                                           \
    1:     JS_END_MACRO
    1: 
    1: #define APPEND_STRING_TO_STACK(str)                                           \
    1:     JS_BEGIN_MACRO                                                            \
    1:         JSString *str_ = str;                                                 \
59890:         size_t length_ = str_->length();                                      \
59890:         const jschar *chars_ = str_->getChars(cx);                            \
59890:         if (!chars_)                                                          \
59890:             goto bad;                                                         \
 4718:                                                                               \
    1:         if (length_ > stackmax - stacklen) {                                  \
    1:             void *ptr_;                                                       \
    1:             if (stackmax >= STACK_LENGTH_LIMIT ||                             \
    1:                 length_ >= STACK_LENGTH_LIMIT - stacklen) {                   \
    1:                 goto done;                                                    \
    1:             }                                                                 \
    1:             stackmax = JS_BIT(JS_CeilingLog2(stacklen + length_));            \
30851:             ptr_ = cx->realloc(stackbuf, (stackmax+1) * sizeof(jschar));      \
    1:             if (!ptr_)                                                        \
    1:                 goto bad;                                                     \
 3164:             stackbuf = (jschar *) ptr_;                                       \
    1:         }                                                                     \
 4718:         js_strncpy(stackbuf + stacklen, chars_, length_);                     \
    1:         stacklen += length_;                                                  \
    1:     JS_END_MACRO
    1: 
    1:     values = GetStackTraceValueBuffer(priv);
    1:     elem = priv->stackElems;
    1:     for (endElem = elem + priv->stackDepth; elem != endElem; elem++) {
    1:         if (elem->funName) {
    1:             APPEND_STRING_TO_STACK(elem->funName);
    1:             APPEND_CHAR_TO_STACK('(');
    1:             for (i = 0; i != elem->argc; i++, values++) {
    1:                 if (i > 0)
    1:                     APPEND_CHAR_TO_STACK(',');
    1:                 str = ValueToShortSource(cx, *values);
    1:                 if (!str)
    1:                     goto bad;
    1:                 APPEND_STRING_TO_STACK(str);
    1:             }
    1:             APPEND_CHAR_TO_STACK(')');
    1:         }
    1:         APPEND_CHAR_TO_STACK('@');
    1:         if (elem->filename) {
    1:             for (cp = elem->filename; *cp; cp++)
    1:                 APPEND_CHAR_TO_STACK(*cp);
    1:         }
    1:         APPEND_CHAR_TO_STACK(':');
    1:         JS_snprintf(ulnbuf, sizeof ulnbuf, "%u", elem->ulineno);
    1:         for (cp = ulnbuf; *cp; cp++)
    1:             APPEND_CHAR_TO_STACK(*cp);
    1:         APPEND_CHAR_TO_STACK('\n');
    1:     }
    1: #undef APPEND_CHAR_TO_STACK
    1: #undef APPEND_STRING_TO_STACK
    1: #undef STACK_LENGTH_LIMIT
    1: 
    1:   done:
    1:     if (stacklen == 0) {
    1:         JS_ASSERT(!stackbuf);
    1:         return cx->runtime->emptyString;
    1:     }
    1:     if (stacklen < stackmax) {
    1:         /*
    1:          * Realloc can fail when shrinking on some FreeBSD versions, so
    1:          * don't use JS_realloc here; simply let the oversized allocation
    1:          * be owned by the string in that rare case.
    1:          */
30851:         void *shrunk = cx->realloc(stackbuf, (stacklen+1) * sizeof(jschar));
    1:         if (shrunk)
 3164:             stackbuf = (jschar *) shrunk;
    1:     }
    1: 
    1:     stackbuf[stacklen] = 0;
 4718:     str = js_NewString(cx, stackbuf, stacklen);
    1:     if (str)
    1:         return str;
    1: 
    1:   bad:
    1:     if (stackbuf)
30851:         cx->free(stackbuf);
    1:     return NULL;
    1: }
    1: 
    1: /* XXXbe Consolidate the ugly truth that we don't treat filename as UTF-8
    1:          with these two functions. */
    1: static JSString *
    1: FilenameToString(JSContext *cx, const char *filename)
    1: {
    1:     return JS_NewStringCopyZ(cx, filename);
    1: }
    1: 
    1: static JSBool
53557: Exception(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *message, *filename;
    1:     JSStackFrame *fp;
    1: 
    1:     /*
    1:      * ECMA ed. 3, 15.11.1 requires Error, etc., to construct even when
    1:      * called as functions, without operator new.  But as we do not give
    1:      * each constructor a distinct JSClass, whose .name member is used by
47497:      * NewNativeClassInstance to find the class prototype, we must get the
47497:      * class prototype ourselves.
    1:      */
53557:     JSObject &callee = vp[0].toObject();
53557:     Value protov;
53557:     if (!callee.getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom), &protov))
    1:         return JS_FALSE;
53557: 
63146:     if (!protov.isObject()) {
63146:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_PROTOTYPE, "Error");
63146:         return JS_FALSE;
63146:     }
63146: 
53557:     JSObject *errProto = &protov.toObject();
53557:     JSObject *obj = NewNativeClassInstance(cx, &js_ErrorClass, errProto, errProto->getParent());
    1:     if (!obj)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * If it's a new object of class Exception, then null out the private
    1:      * data so that the finalizer doesn't attempt to free it.
    1:      */
40826:     if (obj->getClass() == &js_ErrorClass)
31452:         obj->setPrivate(NULL);
    1: 
    1:     /* Set the 'message' property. */
53557:     Value *argv = vp + 2;
    1:     if (argc != 0) {
    1:         message = js_ValueToString(cx, argv[0]);
    1:         if (!message)
    1:             return JS_FALSE;
48470:         argv[0].setString(message);
    1:     } else {
    1:         message = cx->runtime->emptyString;
    1:     }
    1: 
    1:     /* Set the 'fileName' property. */
    1:     if (argc > 1) {
    1:         filename = js_ValueToString(cx, argv[1]);
    1:         if (!filename)
    1:             return JS_FALSE;
48470:         argv[1].setString(filename);
    1:         fp = NULL;
    1:     } else {
22652:         fp = js_GetScriptedCaller(cx, NULL);
    1:         if (fp) {
53840:             filename = FilenameToString(cx, fp->script()->filename);
    1:             if (!filename)
    1:                 return JS_FALSE;
    1:         } else {
    1:             filename = cx->runtime->emptyString;
    1:         }
    1:     }
    1: 
    1:     /* Set the 'lineNumber' property. */
40828:     uint32_t lineno;
    1:     if (argc > 2) {
40828:         if (!ValueToECMAUint32(cx, argv[2], &lineno))
    1:             return JS_FALSE;
    1:     } else {
    1:         if (!fp)
22652:             fp = js_GetScriptedCaller(cx, NULL);
42717:         lineno = (fp && fp->pc(cx)) ? js_FramePCToLineNumber(cx, fp) : 0;
    1:     }
    1: 
53557:     if (obj->getClass() == &js_ErrorClass &&
53557:         !InitExnPrivate(cx, obj, message, filename, lineno, NULL)) {
53557:         return JS_FALSE;
53557:     }
53557: 
53557:     vp->setObject(*obj);
53557:     return JS_TRUE;
    1: }
    1: 
    1: /*
    1:  * Convert to string.
    1:  *
    1:  * This method only uses JavaScript-modifiable properties name, message.  It
    1:  * is left to the host to check for private data and report filename and line
    1:  * number information along with this message.
    1:  */
    1: static JSBool
53557: exn_toString(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsval v;
    1:     JSString *name, *message, *result;
    1:     jschar *chars, *cp;
    1:     size_t name_length, message_length, length;
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return JS_FALSE;
61734:     if (!obj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.nameAtom), Valueify(&v)))
    1:         return JS_FALSE;
    1:     name = JSVAL_IS_STRING(v) ? JSVAL_TO_STRING(v) : cx->runtime->emptyString;
53557:     vp->setString(name);
    1: 
    1:     if (!JS_GetProperty(cx, obj, js_message_str, &v))
    1:         return JS_FALSE;
    1:     message = JSVAL_IS_STRING(v) ? JSVAL_TO_STRING(v)
    1:                                  : cx->runtime->emptyString;
    1: 
29366:     if (message->length() != 0) {
29366:         name_length = name->length();
29366:         message_length = message->length();
    1:         length = (name_length ? name_length + 2 : 0) + message_length;
30851:         cp = chars = (jschar *) cx->malloc((length + 1) * sizeof(jschar));
    1:         if (!chars)
    1:             return JS_FALSE;
    1: 
    1:         if (name_length) {
59890:             const jschar *name_chars = name->getChars(cx);
59890:             if (!name_chars)
59890:                 return JS_FALSE;
59890:             js_strncpy(cp, name_chars, name_length);
    1:             cp += name_length;
    1:             *cp++ = ':'; *cp++ = ' ';
    1:         }
59890:         const jschar *message_chars = message->getChars(cx);
59890:         if (!message_chars)
59890:             return JS_FALSE;
59890:         js_strncpy(cp, message_chars, message_length);
    1:         cp += message_length;
    1:         *cp = 0;
    1: 
 4718:         result = js_NewString(cx, chars, length);
    1:         if (!result) {
30851:             cx->free(chars);
    1:             return JS_FALSE;
    1:         }
    1:     } else {
    1:         result = name;
    1:     }
    1: 
53557:     vp->setString(result);
    1:     return JS_TRUE;
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
    1: /*
    1:  * Return a string that may eval to something similar to the original object.
    1:  */
    1: static JSBool
53557: exn_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     JSString *name, *message, *filename, *lineno_as_str, *result;
 6917:     jsval localroots[3] = {JSVAL_NULL, JSVAL_NULL, JSVAL_NULL};
    1:     size_t lineno_length, name_length, message_length, filename_length, length;
    1:     jschar *chars, *cp;
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734:     if (!obj->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.nameAtom), vp))
40221:         return false;
53557:     name = js_ValueToString(cx, *vp);
    1:     if (!name)
40221:         return false;
53557:     vp->setString(name);
    1: 
40221:     {
48470:         AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(localroots), Valueify(localroots));
    1: 
18107: #ifdef __GNUC__
18107:         message = filename = NULL;
18107: #endif
40389:         if (!JS_GetProperty(cx, obj, js_message_str, &localroots[0]) ||
48470:             !(message = js_ValueToSource(cx, Valueify(localroots[0])))) {
40389:             return false;
40389:         }
 4127:         localroots[0] = STRING_TO_JSVAL(message);
    1: 
40389:         if (!JS_GetProperty(cx, obj, js_fileName_str, &localroots[1]) ||
48470:             !(filename = js_ValueToSource(cx, Valueify(localroots[1])))) {
40389:             return false;
40389:         }
 4127:         localroots[1] = STRING_TO_JSVAL(filename);
    1: 
40389:         if (!JS_GetProperty(cx, obj, js_lineNumber_str, &localroots[2]))
40389:             return false;
40828:         uint32_t lineno;
48470:         if (!ValueToECMAUint32(cx, Valueify(localroots[2]), &lineno))
40389:             return false;
    1: 
    1:         if (lineno != 0) {
48470:             lineno_as_str = js_ValueToString(cx, Valueify(localroots[2]));
40389:             if (!lineno_as_str)
40389:                 return false;
29366:             lineno_length = lineno_as_str->length();
    1:         } else {
    1:             lineno_as_str = NULL;
    1:             lineno_length = 0;
    1:         }
    1: 
    1:         /* Magic 8, for the characters in ``(new ())''. */
29366:         name_length = name->length();
29366:         message_length = message->length();
    1:         length = 8 + name_length + message_length;
    1: 
29366:         filename_length = filename->length();
    1:         if (filename_length != 0) {
    1:             /* append filename as ``, {filename}'' */
    1:             length += 2 + filename_length;
    1:             if (lineno_as_str) {
    1:                 /* append lineno as ``, {lineno_as_str}'' */
    1:                 length += 2 + lineno_length;
    1:             }
    1:         } else {
    1:             if (lineno_as_str) {
    1:                 /*
    1:                  * no filename, but have line number,
    1:                  * need to append ``, "", {lineno_as_str}''
    1:                  */
    1:                 length += 6 + lineno_length;
    1:             }
    1:         }
    1: 
30851:         cp = chars = (jschar *) cx->malloc((length + 1) * sizeof(jschar));
40389:         if (!chars)
40389:             return false;
    1: 
    1:         *cp++ = '('; *cp++ = 'n'; *cp++ = 'e'; *cp++ = 'w'; *cp++ = ' ';
59890:         const jschar *name_chars = name->getChars(cx);
59890:         if (!name_chars)
59890:             return false;
59890:         js_strncpy(cp, name_chars, name_length);
    1:         cp += name_length;
    1:         *cp++ = '(';
59890:         const jschar *message_chars = message->getChars(cx);
59890:         if (!message_chars)
59890:             return false;
    1:         if (message_length != 0) {
59890:             js_strncpy(cp, message_chars, message_length);
    1:             cp += message_length;
    1:         }
    1: 
    1:         if (filename_length != 0) {
    1:             /* append filename as ``, {filename}'' */
    1:             *cp++ = ','; *cp++ = ' ';
59890:             const jschar *filename_chars = filename->getChars(cx);
59890:             if (!filename_chars)
59890:                 return false;
59890:             js_strncpy(cp, filename_chars, filename_length);
    1:             cp += filename_length;
    1:         } else {
    1:             if (lineno_as_str) {
    1:                 /*
    1:                  * no filename, but have line number,
    1:                  * need to append ``, "", {lineno_as_str}''
    1:                  */
    1:                 *cp++ = ','; *cp++ = ' '; *cp++ = '"'; *cp++ = '"';
    1:             }
    1:         }
    1:         if (lineno_as_str) {
    1:             /* append lineno as ``, {lineno_as_str}'' */
    1:             *cp++ = ','; *cp++ = ' ';
59890:             const jschar *lineno_chars = lineno_as_str->getChars(cx);
59890:             if (!lineno_chars)
59890:                 return false;
59890:             js_strncpy(cp, lineno_chars, lineno_length);
    1:             cp += lineno_length;
    1:         }
    1: 
    1:         *cp++ = ')'; *cp++ = ')'; *cp = 0;
    1: 
 4718:         result = js_NewString(cx, chars, length);
    1:         if (!result) {
30851:             cx->free(chars);
40389:             return false;
    1:         }
53557:         vp->setString(result);
40389:         return true;
40221:     }
    1: }
    1: #endif
    1: 
    1: static JSFunctionSpec exception_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,   exn_toSource,           0,0),
    1: #endif
16519:     JS_FN(js_toString_str,   exn_toString,           0,0),
 4127:     JS_FS_END
    1: };
    1: 
23081: /* JSProto_ ordering for exceptions shall match JSEXN_ constants. */
23081: JS_STATIC_ASSERT(JSEXN_ERR == 0);
23081: JS_STATIC_ASSERT(JSProto_Error + JSEXN_INTERNALERR  == JSProto_InternalError);
23081: JS_STATIC_ASSERT(JSProto_Error + JSEXN_EVALERR      == JSProto_EvalError);
23081: JS_STATIC_ASSERT(JSProto_Error + JSEXN_RANGEERR     == JSProto_RangeError);
23081: JS_STATIC_ASSERT(JSProto_Error + JSEXN_REFERENCEERR == JSProto_ReferenceError);
23081: JS_STATIC_ASSERT(JSProto_Error + JSEXN_SYNTAXERR    == JSProto_SyntaxError);
23081: JS_STATIC_ASSERT(JSProto_Error + JSEXN_TYPEERR      == JSProto_TypeError);
23081: JS_STATIC_ASSERT(JSProto_Error + JSEXN_URIERR       == JSProto_URIError);
23081: 
23081: static JS_INLINE JSProtoKey
23081: GetExceptionProtoKey(intN exn)
23081: {
23081:     JS_ASSERT(JSEXN_ERR <= exn);
23081:     JS_ASSERT(exn < JSEXN_LIMIT);
23081:     return (JSProtoKey) (JSProto_Error + exn);
23081: }
23081: 
    1: JSObject *
    1: js_InitExceptionClasses(JSContext *cx, JSObject *obj)
    1: {
    1:     /*
    1:      * If lazy class initialization occurs for any Error subclass, then all
    1:      * classes are initialized, starting with Error.  To avoid reentry and
    1:      * redundant initialization, we must not pass a null proto parameter to
50450:      * NewNonFunction below, when called for the Error superclass.  We need to
    1:      * ensure that Object.prototype is the proto of Error.prototype.
    1:      *
    1:      * See the equivalent code to ensure that parent_proto is non-null when
50450:      * js_InitClass calls NewObject, in jsobj.cpp.
    1:      */
61705:     JSObject *obj_proto;
38604:     if (!js_GetClassPrototype(cx, obj, JSProto_Object, &obj_proto))
    1:         return NULL;
    1: 
61705:     /* Define all error constructors. */
61705:     Value empty = StringValue(cx->runtime->emptyString);
61705:     jsid nameId = ATOM_TO_JSID(cx->runtime->atomState.nameAtom);
61705:     jsid messageId = ATOM_TO_JSID(cx->runtime->atomState.messageAtom);
61705:     jsid fileNameId = ATOM_TO_JSID(cx->runtime->atomState.fileNameAtom);
61705:     jsid lineNumberId = ATOM_TO_JSID(cx->runtime->atomState.lineNumberAtom);
61705:     JSObject *error_proto = NULL;
23081:     for (intN i = JSEXN_ERR; i != JSEXN_LIMIT; i++) {
61705:         JSProtoKey protoKey = GetExceptionProtoKey(i);
61705:         JSAtom *atom = cx->runtime->atomState.classAtoms[protoKey];
47530:         JSObject *proto =
61705:             DefineConstructorAndPrototype(cx, obj, protoKey, atom,
61705:                                           (i == JSEXN_ERR) ? obj_proto : error_proto,
61705:                                           &js_ErrorClass, Exception, 1,
61705:                                           NULL, (i == JSEXN_ERR) ? exception_methods : NULL,
61705:                                           NULL, NULL);
23081:         if (!proto)
23081:             return NULL;
61705:         JS_ASSERT(proto->privateData == NULL);
61705: 
61705:         if (i == JSEXN_ERR)
23081:             error_proto = proto;
    1: 
61705:         /* Add properties to the prototype. */
61705:         JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DECLARING);
61705:         if (!js_DefineNativeProperty(cx, proto, nameId, StringValue(atom),
62395:                                      PropertyStub, StrictPropertyStub, 
62395:                                      JSPROP_ENUMERATE, 0, 0, NULL) ||
61705:             !js_DefineNativeProperty(cx, proto, messageId, empty,
62395:                                      PropertyStub, StrictPropertyStub,
62395:                                      JSPROP_ENUMERATE, 0, 0, NULL) ||
61705:             !js_DefineNativeProperty(cx, proto, fileNameId, empty,
62395:                                      PropertyStub, StrictPropertyStub,
62395:                                      JSPROP_ENUMERATE, 0, 0, NULL) ||
61705:             !js_DefineNativeProperty(cx, proto, lineNumberId, Valueify(JSVAL_ZERO),
62395:                                      PropertyStub, StrictPropertyStub,
62395:                                      JSPROP_ENUMERATE, 0, 0, NULL)) {
23081:             return NULL;
    1:         }
    1:     }
    1: 
23081:     return error_proto;
    1: }
    1: 
    1: const JSErrorFormatString*
 1324: js_GetLocalizedErrorMessage(JSContext* cx, void *userRef, const char *locale,
 1324:                             const uintN errorNumber)
    1: {
    1:     const JSErrorFormatString *errorString = NULL;
    1: 
    1:     if (cx->localeCallbacks && cx->localeCallbacks->localeGetErrorMessage) {
    1:         errorString = cx->localeCallbacks
    1:                         ->localeGetErrorMessage(userRef, locale, errorNumber);
    1:     }
    1:     if (!errorString)
    1:         errorString = js_GetErrorMessage(userRef, locale, errorNumber);
    1:     return errorString;
    1: }
    1: 
    1: #if defined ( DEBUG_mccabe ) && defined ( PRINTNAMES )
    1: /* For use below... get character strings for error name and exception name */
    1: static struct exnname { char *name; char *exception; } errortoexnname[] = {
    1: #define MSG_DEF(name, number, count, exception, format) \
    1:     {#name, #exception},
    1: #include "js.msg"
    1: #undef MSG_DEF
    1: };
    1: #endif /* DEBUG */
    1: 
    1: JSBool
36234: js_ErrorToException(JSContext *cx, const char *message, JSErrorReport *reportp,
36234:                     JSErrorCallback callback, void *userRef)
    1: {
    1:     JSErrNum errorNumber;
    1:     const JSErrorFormatString *errorString;
    1:     JSExnType exn;
    1:     jsval tv[4];
    1:     JSBool ok;
    1:     JSObject *errProto, *errObject;
    1:     JSString *messageStr, *filenameStr;
    1: 
    1:     /*
18955:      * Tell our caller to report immediately if this report is just a warning.
    1:      */
    1:     JS_ASSERT(reportp);
18955:     if (JSREPORT_IS_WARNING(reportp->flags))
    1:         return JS_FALSE;
    1: 
    1:     /* Find the exception index associated with this error. */
    1:     errorNumber = (JSErrNum) reportp->errorNumber;
36234:     if (!callback || callback == js_GetErrorMessage)
    1:         errorString = js_GetLocalizedErrorMessage(cx, NULL, NULL, errorNumber);
36234:     else
36234:         errorString = callback(userRef, NULL, errorNumber);
 3164:     exn = errorString ? (JSExnType) errorString->exnType : JSEXN_NONE;
    1:     JS_ASSERT(exn < JSEXN_LIMIT);
    1: 
    1: #if defined( DEBUG_mccabe ) && defined ( PRINTNAMES )
    1:     /* Print the error name and the associated exception name to stderr */
    1:     fprintf(stderr, "%s\t%s\n",
    1:             errortoexnname[errorNumber].name,
    1:             errortoexnname[errorNumber].exception);
    1: #endif
    1: 
    1:     /*
    1:      * Return false (no exception raised) if no exception is associated
    1:      * with the given error number.
    1:      */
    1:     if (exn == JSEXN_NONE)
    1:         return JS_FALSE;
    1: 
    1:     /*
    1:      * Prevent runaway recursion, via cx->generatingError.  If an out-of-memory
    1:      * error occurs, no exception object will be created, but we don't assume
    1:      * that OOM is the only kind of error that subroutines of this function
    1:      * called below might raise.
    1:      */
    1:     if (cx->generatingError)
    1:         return JS_FALSE;
    1: 
18989:     MUST_FLOW_THROUGH("out");
    1:     cx->generatingError = JS_TRUE;
    1: 
    1:     /* Protect the newly-created strings below from nesting GCs. */
40229:     PodArrayZero(tv);
48470:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(tv), Valueify(tv));
    1: 
    1:     /*
    1:      * Try to get an appropriate prototype by looking up the corresponding
    1:      * exception constructor name in the scope chain of the current context's
    1:      * top stack frame, or in the global object if no frame is active.
    1:      */
38604:     ok = js_GetClassPrototype(cx, NULL, GetExceptionProtoKey(exn), &errProto);
    1:     if (!ok)
    1:         goto out;
    1:     tv[0] = OBJECT_TO_JSVAL(errProto);
    1: 
47497:     errObject = NewNativeClassInstance(cx, &js_ErrorClass, errProto, errProto->getParent());
    1:     if (!errObject) {
    1:         ok = JS_FALSE;
    1:         goto out;
    1:     }
    1:     tv[1] = OBJECT_TO_JSVAL(errObject);
    1: 
    1:     messageStr = JS_NewStringCopyZ(cx, message);
    1:     if (!messageStr) {
    1:         ok = JS_FALSE;
    1:         goto out;
    1:     }
    1:     tv[2] = STRING_TO_JSVAL(messageStr);
    1: 
    1:     filenameStr = JS_NewStringCopyZ(cx, reportp->filename);
    1:     if (!filenameStr) {
    1:         ok = JS_FALSE;
    1:         goto out;
    1:     }
    1:     tv[3] = STRING_TO_JSVAL(filenameStr);
    1: 
    1:     ok = InitExnPrivate(cx, errObject, messageStr, filenameStr,
    1:                         reportp->lineno, reportp);
    1:     if (!ok)
    1:         goto out;
    1: 
    1:     JS_SetPendingException(cx, OBJECT_TO_JSVAL(errObject));
    1: 
    1:     /* Flag the error report passed in to indicate an exception was raised. */
    1:     reportp->flags |= JSREPORT_EXCEPTION;
    1: 
    1: out:
    1:     cx->generatingError = JS_FALSE;
    1:     return ok;
    1: }
    1: 
    1: JSBool
    1: js_ReportUncaughtException(JSContext *cx)
    1: {
    1:     jsval exn;
    1:     JSObject *exnObject;
 4127:     jsval roots[5];
    1:     JSErrorReport *reportp, report;
    1:     JSString *str;
    1:     const char *bytes;
    1: 
    1:     if (!JS_IsExceptionPending(cx))
40221:         return true;
    1: 
    1:     if (!JS_GetPendingException(cx, &exn))
40221:         return false;
    1: 
40229:     PodArrayZero(roots);
48470:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(roots), Valueify(roots));
    1: 
    1:     /*
    1:      * Because js_ValueToString below could error and an exception object
    1:      * could become unrooted, we must root exnObject.  Later, if exnObject is
    1:      * non-null, we need to root other intermediates, so allocate an operand
    1:      * stack segment to protect all of these values.
    1:      */
    1:     if (JSVAL_IS_PRIMITIVE(exn)) {
    1:         exnObject = NULL;
    1:     } else {
    1:         exnObject = JSVAL_TO_OBJECT(exn);
 4127:         roots[0] = exn;
    1:     }
    1: 
    1:     JS_ClearPendingException(cx);
    1:     reportp = js_ErrorFromException(cx, exn);
    1: 
    1:     /* XXX L10N angels cry once again (see also jsemit.c, /L10N gaffes/) */
48470:     str = js_ValueToString(cx, Valueify(exn));
57812:     JSAutoByteString bytesStorage;
    1:     if (!str) {
    1:         bytes = "unknown (can't convert to string)";
    1:     } else {
 4127:         roots[1] = STRING_TO_JSVAL(str);
57812:         if (!bytesStorage.encode(cx, str))
40389:             return false;
57812:         bytes = bytesStorage.ptr();
40378:     }
    1: 
57812:     JSAutoByteString filename;
40379:     if (!reportp && exnObject && exnObject->getClass() == &js_ErrorClass) {
40389:         if (!JS_GetProperty(cx, exnObject, js_message_str, &roots[2]))
40389:             return false;
 4127:         if (JSVAL_IS_STRING(roots[2])) {
57812:             bytesStorage.clear();
57812:             if (!bytesStorage.encode(cx, str))
40389:                 return false;
57812:             bytes = bytesStorage.ptr();
    1:         }
    1: 
40389:         if (!JS_GetProperty(cx, exnObject, js_fileName_str, &roots[3]))
40389:             return false;
48470:         str = js_ValueToString(cx, Valueify(roots[3]));
57812:         if (!str || !filename.encode(cx, str))
40389:             return false;
    1: 
40389:         if (!JS_GetProperty(cx, exnObject, js_lineNumber_str, &roots[4]))
40389:             return false;
40828:         uint32_t lineno;
48470:         if (!ValueToECMAUint32(cx, Valueify(roots[4]), &lineno))
40389:             return false;
    1: 
    1:         reportp = &report;
40229:         PodZero(&report);
57812:         report.filename = filename.ptr();
    1:         report.lineno = (uintN) lineno;
40611:         if (JSVAL_IS_STRING(roots[2])) {
40611:             report.ucmessage = js_GetStringChars(cx, JSVAL_TO_STRING(roots[2]));
40611:             if (!report.ucmessage)
40611:                 return false;
40611:         }
    1:     }
    1: 
    1:     if (!reportp) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_UNCAUGHT_EXCEPTION, bytes);
    1:     } else {
    1:         /* Flag the error as an exception. */
    1:         reportp->flags |= JSREPORT_EXCEPTION;
12469: 
12469:         /* Pass the exception object. */
12469:         JS_SetPendingException(cx, exn);
    1:         js_ReportErrorAgain(cx, bytes, reportp);
12469:         JS_ClearPendingException(cx);
    1:     }
    1: 
40389:     return true;
    1: }
