    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org Code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK *****
    1:  * This Original Code has been modified by IBM Corporation.
    1:  * Modifications made by IBM described herein are
    1:  * Copyright (c) International Business Machines
    1:  * Corporation, 2000
    1:  *
    1:  * Modifications to Mozilla code or documentation
    1:  * identified per MPL Section 3.3
    1:  *
    1:  * Date             Modified by     Description of modification
    1:  * 04/20/2000       IBM Corp.      Added PR_CALLBACK for Optlink use in OS2
    1:  */
    1: 
    1: /* Allow logging in the release build */
    1: #ifdef MOZ_LOGGING
    1: #define FORCE_PR_LOG
    1: #endif
    1: 
    1: #include "nsNativeComponentLoader.h"
    1: 
    1: #include "prlog.h"
    1: #include "prinit.h"
    1: #include "prerror.h"
    1: 
    1: #include "nsComponentManager.h"
    1: #include "nsCRTGlue.h"
23472: #include "nsThreadUtils.h"
    1: #include "nsTraceRefcntImpl.h"
    1: 
    1: #include "nsILocalFile.h"
23472: #include "nsIProxyObjectManager.h"
    1: 
    1: #ifdef XP_WIN
    1: #include <windows.h>
    1: #endif
    1: 
    1: #ifdef XP_MACOSX
    1: #include <signal.h>
    1: #endif
    1: 
    1: #ifdef VMS
    1: #include <lib$routines.h>
    1: #include <ssdef.h>
    1: #endif
    1: 
    1: #if defined(DEBUG) && !defined(XP_BEOS)
    1: #define IMPLEMENT_BREAK_AFTER_LOAD
    1: #endif
    1: 
    1: static PRLogModuleInfo *nsNativeModuleLoaderLog =
    1:     PR_NewLogModule("nsNativeModuleLoader");
    1: 
    1: #define LOG(level, args) PR_LOG(nsNativeModuleLoaderLog, level, args)
    1: 
12033: NS_IMPL_QUERY_INTERFACE1(nsNativeModuleLoader, 
46997:                          mozilla::ModuleLoader)
12033: 
    1: NS_IMPL_ADDREF_USING_AGGREGATOR(nsNativeModuleLoader,
    1:                                 nsComponentManagerImpl::gComponentManager)
    1: NS_IMPL_RELEASE_USING_AGGREGATOR(nsNativeModuleLoader,
    1:                                  nsComponentManagerImpl::gComponentManager)
    1: 
    1: nsresult
    1: nsNativeModuleLoader::Init()
    1: {
23472:     NS_ASSERTION(NS_IsMainThread(), "Startup not on main thread?");
23472: 
    1:     LOG(PR_LOG_DEBUG, ("nsNativeModuleLoader::Init()"));
    1: 
    1:     return mLibraries.Init() ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
46997: class LoadModuleMainThreadRunnable : public nsRunnable
46997: {
46997: public:
46997:     LoadModuleMainThreadRunnable(nsNativeModuleLoader* loader,
46997:                                  nsILocalFile* file)
46997:         : mLoader(loader)
46997:         , mFile(file)
46997:         , mResult(NULL)
46997:     { }
46997: 
46997:     NS_IMETHOD Run()
46997:     {
46997:         mResult = mLoader->LoadModule(mFile);
46997:         return NS_OK;
46997:     }
46997: 
46997:     nsRefPtr<nsNativeModuleLoader> mLoader;
46997:     nsCOMPtr<nsILocalFile> mFile;
46997:     const mozilla::Module* mResult;
46997: };
46997: 
46997: const mozilla::Module*
46997: nsNativeModuleLoader::LoadModule(nsILocalFile* aFile)
    1: {
    1:     nsresult rv;
    1: 
23472:     if (!NS_IsMainThread()) {
23472:         // If this call is off the main thread, synchronously proxy it
23472:         // to the main thread.
46997:         nsRefPtr<LoadModuleMainThreadRunnable> r = new LoadModuleMainThreadRunnable(this, aFile);
46997:         NS_DispatchToMainThread(r, NS_DISPATCH_SYNC);
46997:         return r->mResult;
23472:     }
23472: 
    1:     nsCOMPtr<nsIHashable> hashedFile(do_QueryInterface(aFile));
    1:     if (!hashedFile) {
    1:         NS_ERROR("nsIFile is not nsIHashable");
46997:         return NULL;
    1:     }
    1: 
47023:     nsCAutoString filePath;
47023:     aFile->GetNativePath(filePath);
47023: 
    1:     NativeLoadData data;
    1: 
    1:     if (mLibraries.Get(hashedFile, &data)) {
    1:         NS_ASSERTION(data.module, "Corrupt mLibraries hash");
    1:         LOG(PR_LOG_DEBUG,
    1:             ("nsNativeModuleLoader::LoadModule(\"%s\") - found in cache",
    1:              filePath.get()));
46997:         return data.module;
    1:     }
    1: 
    1:     // We haven't loaded this module before
    1: 
    1:     rv = aFile->Load(&data.library);
    1: 
    1:     if (NS_FAILED(rv)) {
    1:         char errorMsg[1024] = "<unknown; can't get error from NSPR>";
    1: 
    1:         if (PR_GetErrorTextLength() < (int) sizeof(errorMsg))
    1:             PR_GetErrorText(errorMsg);
    1: 
    1:         LOG(PR_LOG_ERROR,
    1:             ("nsNativeModuleLoader::LoadModule(\"%s\") - load FAILED, "
    1:              "rv: %lx, error:\n\t%s\n",
    1:              filePath.get(), rv, errorMsg));
    1: 
    1: #ifdef DEBUG
    1:         fprintf(stderr,
    1:                 "nsNativeModuleLoader::LoadModule(\"%s\") - load FAILED, "
    1:                 "rv: %lx, error:\n\t%s\n",
42397:                 filePath.get(), (unsigned long)rv, errorMsg);
    1: #endif
    1: 
46997:         return NULL;
    1:     }
    1: 
    1: #ifdef IMPLEMENT_BREAK_AFTER_LOAD
    1:     nsCAutoString leafName;
    1:     aFile->GetNativeLeafName(leafName);
    1: 
    1:     char *env = getenv("XPCOM_BREAK_ON_LOAD");
    1:     char *blist;
    1:     if (env && *env && (blist = strdup(env))) {
    1:         char *nextTok = blist;
    1:         while (char *token = NS_strtok(":", &nextTok)) {
    1:             if (leafName.Find(token, PR_TRUE) != kNotFound) {
    1:                 NS_BREAK();
    1:             }
    1:         }
    1: 
    1:         free(blist);
    1:     }
    1: #endif
    1: 
47695:     void *module = PR_FindSymbol(data.library, "NSModule");
47695:     if (module) {
47695:         data.module = *(mozilla::Module const *const *) module;
46997:         if (mLibraries.Put(hashedFile, data))
46997:             return data.module;
    1:     }
    1:     else {
    1:         LOG(PR_LOG_ERROR,
    1:             ("nsNativeModuleLoader::LoadModule(\"%s\") - "
46997:              "Symbol NSModule not found", filePath.get()));
    1:     }
    1: 
    1:     // at some point we failed, clean up
    1:     data.module = nsnull;
    1:     PR_UnloadLibrary(data.library);
    1: 
46997:     return NULL;
42397: }
42397: 
47008: const mozilla::Module*
47008: nsNativeModuleLoader::LoadModuleFromJAR(nsILocalFile* aJARFile, const nsACString &aPath)
47008: {
47008:     NS_ERROR("Binary components cannot be loaded from JARs");
47008:     return NULL;
    1: }
    1: 
    1: PLDHashOperator
    1: nsNativeModuleLoader::ReleaserFunc(nsIHashable* aHashedFile,
    1:                                    NativeLoadData& aLoadData, void*)
    1: {
    1:     aLoadData.module = nsnull;
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
    1: PLDHashOperator
    1: nsNativeModuleLoader::UnloaderFunc(nsIHashable* aHashedFile,
    1:                                    NativeLoadData& aLoadData, void*)
    1: {
    1:     if (PR_LOG_TEST(nsNativeModuleLoaderLog, PR_LOG_DEBUG)) {
    1:         nsCOMPtr<nsIFile> file(do_QueryInterface(aHashedFile));
    1: 
    1:         nsCAutoString filePath;
    1:         file->GetNativePath(filePath);
    1: 
    1:         LOG(PR_LOG_DEBUG,
    1:             ("nsNativeModuleLoader::UnloaderFunc(\"%s\")", filePath.get()));
    1:     }
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:     nsTraceRefcntImpl::SetActivityIsLegal(PR_FALSE);
    1: #endif
    1: 
    1: #if 0
    1:     // XXXbsmedberg: do this as soon as the static-destructor crash(es)
    1:     // are fixed
    1:     PRStatus ret = PR_UnloadLibrary(aLoadData.library);
    1:     NS_ASSERTION(ret == PR_SUCCESS, "Failed to unload library");
    1: #endif
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:     nsTraceRefcntImpl::SetActivityIsLegal(PR_TRUE);
    1: #endif
    1: 
    1:     return PL_DHASH_REMOVE;
    1: }
    1: 
    1: void
    1: nsNativeModuleLoader::UnloadLibraries()
    1: {
23472:     NS_ASSERTION(NS_IsMainThread(), "Shutdown not on main thread?");
23472: 
    1:     mLibraries.Enumerate(ReleaserFunc, nsnull);
    1:     mLibraries.Enumerate(UnloaderFunc, nsnull);
    1: }
