    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Oracle Corporation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Oracle Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@pavlov.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
 1349: #include "prmem.h"
 1349: 
62693: #include "gfxAlphaRecovery.h"
    1: #include "gfxImageSurface.h"
    1: 
    1: #include "cairo.h"
96638: #include "mozilla/gfx/2D.h"
96638: #include "gfx2DGlue.h"
96638: 
96638: using namespace mozilla::gfx;
    1: 
42262: gfxImageSurface::gfxImageSurface()
42262:   : mSize(0, 0),
80486:     mOwnsData(false),
42262:     mFormat(ImageFormatUnknown),
42262:     mStride(0)
42262: {
42262: }
42262: 
42262: void
42262: gfxImageSurface::InitFromSurface(cairo_surface_t *csurf)
42262: {
42262:     mSize.width = cairo_image_surface_get_width(csurf);
42262:     mSize.height = cairo_image_surface_get_height(csurf);
42262:     mData = cairo_image_surface_get_data(csurf);
42262:     mFormat = (gfxImageFormat) cairo_image_surface_get_format(csurf);
80486:     mOwnsData = false;
42262:     mStride = cairo_image_surface_get_stride(csurf);
42262: 
80486:     Init(csurf, true);
42262: }
42262: 
15751: gfxImageSurface::gfxImageSurface(unsigned char *aData, const gfxIntSize& aSize,
15751:                                  long aStride, gfxImageFormat aFormat)
15751: {
57209:     InitWithData(aData, aSize, aStride, aFormat);
57209: }
57209: 
57209: void
79633: gfxImageSurface::MakeInvalid()
79633: {
79633:     mSize = gfxIntSize(-1, -1);
79633:     mData = NULL;
79633:     mStride = 0;
79633: }
79633: 
79633: void
57209: gfxImageSurface::InitWithData(unsigned char *aData, const gfxIntSize& aSize,
57209:                               long aStride, gfxImageFormat aFormat)
57209: {
57209:     mSize = aSize;
80486:     mOwnsData = false;
57209:     mData = aData;
57209:     mFormat = aFormat;
57209:     mStride = aStride;
57209: 
15751:     if (!CheckSurfaceSize(aSize))
79633:         MakeInvalid();
15751: 
15751:     cairo_surface_t *surface =
15751:         cairo_image_surface_create_for_data((unsigned char*)mData,
15751:                                             (cairo_format_t)mFormat,
15751:                                             mSize.width,
15751:                                             mSize.height,
15751:                                             mStride);
15751: 
15751:     // cairo_image_surface_create_for_data can return a 'null' surface
15751:     // in out of memory conditions. The gfxASurface::Init call checks
15751:     // the surface it receives to see if there is an error with the
15751:     // surface and handles it appropriately. That is why there is
15751:     // no check here.
15751:     Init(surface);
15751: }
15751: 
62693: static void*
62693: TryAllocAlignedBytes(size_t aSize)
62693: {
62693:     // Use fallible allocators here
94810: #if defined(HAVE_POSIX_MEMALIGN)
62693:     void* ptr;
62693:     // Try to align for fast alpha recovery.  This should only help
62693:     // cairo too, can't hurt.
62693:     return moz_posix_memalign(&ptr,
62693:                               1 << gfxAlphaRecovery::GoodAlignmentLog2(),
62693:                               aSize) ?
62693:              nsnull : ptr;
62693: #else
62693:     // Oh well, hope that luck is with us in the allocator
62693:     return moz_malloc(aSize);
62693: #endif
62693: }
62693: 
95670: gfxImageSurface::gfxImageSurface(const gfxIntSize& size, gfxImageFormat format, bool aClear) :
80486:     mSize(size), mOwnsData(false), mData(nsnull), mFormat(format)
    1: {
 1349:     mStride = ComputeStride();
 1349: 
 1349:     if (!CheckSurfaceSize(size))
79633:         MakeInvalid();
 1349: 
49179:     // if we have a zero-sized surface, just leave mData nsnull
 1651:     if (mSize.height * mStride > 0) {
51291: 
62693:         // This can fail to allocate memory aligned as we requested,
62693:         // or it can fail to allocate any memory at all.
62693:         mData = (unsigned char *) TryAllocAlignedBytes(mSize.height * mStride);
 1349:         if (!mData)
 1349:             return;
95670:         if (aClear)
51291:             memset(mData, 0, mSize.height * mStride);
 1651:     }
 1349: 
80486:     mOwnsData = true;
    1: 
    1:     cairo_surface_t *surface =
    1:         cairo_image_surface_create_for_data((unsigned char*)mData,
    1:                                             (cairo_format_t)format,
    1:                                             mSize.width,
    1:                                             mSize.height,
 1349:                                             mStride);
42553: 
    1:     Init(surface);
42553: 
57899:     if (mSurfaceValid) {
57899:         RecordMemoryUsed(mSize.height * ComputeStride() +
57899:                          sizeof(gfxImageSurface));
57899:     }
    1: }
    1: 
    1: gfxImageSurface::gfxImageSurface(cairo_surface_t *csurf)
    1: {
    1:     mSize.width = cairo_image_surface_get_width(csurf);
    1:     mSize.height = cairo_image_surface_get_height(csurf);
    1:     mData = cairo_image_surface_get_data(csurf);
    1:     mFormat = (gfxImageFormat) cairo_image_surface_get_format(csurf);
80486:     mOwnsData = false;
    1:     mStride = cairo_image_surface_get_stride(csurf);
    1: 
80486:     Init(csurf, true);
    1: }
    1: 
    1: gfxImageSurface::~gfxImageSurface()
    1: {
15696:     if (mOwnsData)
 1349:         free(mData);
    1: }
    1: 
59847: /*static*/ long
59847: gfxImageSurface::ComputeStride(const gfxIntSize& aSize, gfxImageFormat aFormat)
    1: {
    1:     long stride;
    1: 
59847:     if (aFormat == ImageFormatARGB32)
59847:         stride = aSize.width * 4;
59847:     else if (aFormat == ImageFormatRGB24)
59847:         stride = aSize.width * 4;
59847:     else if (aFormat == ImageFormatRGB16_565)
59847:         stride = aSize.width * 2;
59847:     else if (aFormat == ImageFormatA8)
59847:         stride = aSize.width;
59847:     else if (aFormat == ImageFormatA1) {
59847:         stride = (aSize.width + 7) / 8;
    1:     } else {
    1:         NS_WARNING("Unknown format specified to gfxImageSurface!");
59847:         stride = aSize.width * 4;
    1:     }
    1: 
    1:     stride = ((stride + 3) / 4) * 4;
    1: 
    1:     return stride;
    1: }
11244: 
96638: // helper function for the CopyFrom methods
96638: static void
96638: CopyForStride(unsigned char* aDest, unsigned char* aSrc, const gfxIntSize& aSize, long aDestStride, long aSrcStride)
96638: {
96638:     if (aDestStride == aSrcStride) {
96638:         memcpy (aDest, aSrc, aSrcStride * aSize.height);
96638:     } else {
96638:         int lineSize = NS_MIN(aDestStride, aSrcStride);
96638:         for (int i = 0; i < aSize.height; i++) {
96638:             unsigned char* src = aSrc + aSrcStride * i;
96638:             unsigned char* dst = aDest + aDestStride * i;
96638: 
96638:             memcpy (dst, src, lineSize);
96638:         }
96638:     }
96638: }
96638: 
96638: // helper function for the CopyFrom methods
96638: static bool
96638: FormatsAreCompatible(gfxASurface::gfxImageFormat a1, gfxASurface::gfxImageFormat a2)
96638: {
96638:     if (a1 != a2 &&
96638:         !(a1 == gfxASurface::ImageFormatARGB32 &&
96638:           a2 == gfxASurface::ImageFormatRGB24) &&
96638:         !(a1 == gfxASurface::ImageFormatRGB24 &&
96638:           a2 == gfxASurface::ImageFormatARGB32)) {
96638:         return false;
96638:     }
96638: 
96638:     return true;
96638: }
96638: 
96638: bool
96638: gfxImageSurface::CopyFrom (SourceSurface *aSurface)
96638: {
96638:     mozilla::RefPtr<DataSourceSurface> data = aSurface->GetDataSurface();
96638: 
96638:     if (!data) {
96638:         return false;
96638:     }
96638: 
96638:     gfxIntSize size(data->GetSize().width, data->GetSize().height);
96638:     if (size != mSize) {
96638:         return false;
96638:     }
96638: 
96638:     if (!FormatsAreCompatible(SurfaceFormatToImageFormat(aSurface->GetFormat()),
96638:                               mFormat)) {
96638:         return false;
96638:     }
96638: 
96638:     CopyForStride(mData, data->GetData(), size, mStride, data->Stride());
96638: 
96638:     return true;
96638: }
96638: 
96638: 
79445: bool
11244: gfxImageSurface::CopyFrom(gfxImageSurface *other)
11244: {
96638:     if (other->mSize != mSize) {
80486:         return false;
11244:     }
11244: 
96638:     if (!FormatsAreCompatible(other->mFormat, mFormat)) {
80486:         return false;
11244:     }
11244: 
96638:     CopyForStride(mData, other->mData, mSize, mStride, other->mStride);
11244: 
80486:     return true;
11244: }
53939: 
53939: already_AddRefed<gfxSubimageSurface>
53939: gfxImageSurface::GetSubimage(const gfxRect& aRect)
53939: {
53939:     gfxRect r(aRect);
53939:     r.Round();
53939:     unsigned char* subData = Data() +
53939:         (Stride() * (int)r.Y()) +
53939:         (int)r.X() * gfxASurface::BytePerPixelFromFormat(Format());
53939: 
53939:     nsRefPtr<gfxSubimageSurface> image =
53939:         new gfxSubimageSurface(this, subData,
53939:                                gfxIntSize((int)r.Width(), (int)r.Height()));
53939: 
53939:     return image.forget().get();
53939: }
53939: 
53939: gfxSubimageSurface::gfxSubimageSurface(gfxImageSurface* aParent,
53939:                                        unsigned char* aData,
53939:                                        const gfxIntSize& aSize)
53939:   : gfxImageSurface(aData, aSize, aParent->Stride(), aParent->Format())
53939:   , mParent(aParent)
53939: {
53939: }
57344: 
57344: already_AddRefed<gfxImageSurface>
57344: gfxImageSurface::GetAsImageSurface()
57344: {
57344:   nsRefPtr<gfxImageSurface> surface = this;
57344:   return surface.forget();
57344: }
63369: 
63369: void
63369: gfxImageSurface::MovePixels(const nsIntRect& aSourceRect,
63369:                             const nsIntPoint& aDestTopLeft)
63369: {
63369:     const nsIntRect bounds(0, 0, mSize.width, mSize.height);
63369:     nsIntPoint offset = aDestTopLeft - aSourceRect.TopLeft(); 
63369:     nsIntRect clippedSource = aSourceRect;
63369:     clippedSource.IntersectRect(clippedSource, bounds);
63369:     nsIntRect clippedDest = clippedSource + offset;
63369:     clippedDest.IntersectRect(clippedDest, bounds);
63369:     const nsIntRect dest = clippedDest;
63369:     const nsIntRect source = dest - offset;
63369:     // NB: this relies on IntersectRect() and operator+/- preserving
63369:     // x/y for empty rectangles
63369:     NS_ABORT_IF_FALSE(bounds.Contains(dest) && bounds.Contains(source) &&
63369:                       aSourceRect.Contains(source) &&
63369:                       nsIntRect(aDestTopLeft, aSourceRect.Size()).Contains(dest) &&
63369:                       source.Size() == dest.Size() &&
63369:                       offset == (dest.TopLeft() - source.TopLeft()),
63369:                       "Messed up clipping, crash or corruption will follow");
68638:     if (source.IsEmpty() || source.IsEqualInterior(dest)) {
63369:         return;
63369:     }
63369: 
63369:     long naturalStride = ComputeStride(mSize, mFormat);
63369:     if (mStride == naturalStride && dest.width == bounds.width) {
63369:         // Fast path: this is a vertical shift of some rows in a
63369:         // "normal" image surface.  We can directly memmove and
63369:         // hopefully stay in SIMD land.
63369:         unsigned char* dst = mData + dest.y * mStride;
63369:         const unsigned char* src = mData + source.y * mStride;
63369:         size_t nBytes = dest.height * mStride;
63369:         memmove(dst, src, nBytes);
63369:         return;
63369:     }
63369: 
63369:     // Slow(er) path: have to move row-by-row.
63369:     const PRInt32 bpp = BytePerPixelFromFormat(mFormat);
63369:     const size_t nRowBytes = dest.width * bpp;
63369:     // dstRow points at the first pixel within the current destination
63369:     // row, and similarly for srcRow.  endSrcRow is one row beyond the
63369:     // last row we need to copy.  stride is either +mStride or
63369:     // -mStride, depending on which direction we're copying.
63369:     unsigned char* dstRow;
63369:     unsigned char* srcRow;
63369:     unsigned char* endSrcRow;   // NB: this may point outside the image
63369:     long stride;
63369:     if (dest.y > source.y) {
63369:         // We're copying down from source to dest, so walk backwards
63369:         // starting from the last rows to avoid stomping pixels we
63369:         // need.
63369:         stride = -mStride;
63369:         dstRow = mData + dest.x * bpp + (dest.YMost() - 1) * mStride;
63369:         srcRow = mData + source.x * bpp + (source.YMost() - 1) * mStride;
63369:         endSrcRow = mData + source.x * bpp + (source.y - 1) * mStride;
63369:     } else {
63369:         stride = mStride;
63369:         dstRow = mData + dest.x * bpp + dest.y * mStride;
63369:         srcRow = mData + source.x * bpp + source.y * mStride;
63369:         endSrcRow = mData + source.x * bpp + source.YMost() * mStride;
63369:     }
63369: 
63369:     for (; srcRow != endSrcRow; dstRow += stride, srcRow += stride) {
63369:         memmove(dstRow, srcRow, nRowBytes);
63369:     }
63369: }
