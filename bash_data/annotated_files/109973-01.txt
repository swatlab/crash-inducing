     1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 80467: #include "mozilla/Util.h"
 80467: 
     1: #include "nspr.h"
     1: 
     1: #include "nsIFileStreams.h"       // New Necko file streams
     1: 
     1: #ifdef XP_OS2
     1: #include "nsILocalFileOS2.h"
     1: #endif
     1: 
     1: #include "nsNetUtil.h"
     1: #include "nsComponentManagerUtils.h"
     1: #include "nsIComponentRegistrar.h"
     1: #include "nsIStorageStream.h"
     1: #include "nsISeekableStream.h"
     1: #include "nsIHttpChannel.h"
 29288: #include "nsIHttpChannelInternal.h"
     1: #include "nsIEncodedChannel.h"
     1: #include "nsIUploadChannel.h"
     1: #include "nsICachingChannel.h"
 39409: #include "nsIFileChannel.h"
     1: #include "nsEscape.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsIStringEnumerator.h"
     1: #include "nsCRT.h"
     1: #include "nsSupportsArray.h"
     1: #include "nsContentCID.h"
     1: #include "nsStreamUtils.h"
     1: 
     1: #include "nsCExternalHandlerService.h"
     1: 
     1: #include "nsIURL.h"
     1: #include "nsIFileURL.h"
     1: #include "nsIDocument.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDOMXMLDocument.h"
     1: #include "nsIDOMTreeWalker.h"
     1: #include "nsIDOMNode.h"
     1: #include "nsIDOMComment.h"
     1: #include "nsIDOMNamedNodeMap.h"
     1: #include "nsIDOMNodeList.h"
     1: #include "nsIWebProgressListener.h"
     1: #include "nsIAuthPrompt.h"
     1: #include "nsIPrompt.h"
     1: #include "nsISHEntry.h"
     1: #include "nsIWebPageDescriptor.h"
 16267: #include "nsIFormControl.h"
 91106: #include "nsContentUtils.h"
     1: 
     1: #include "nsIDOMNodeFilter.h"
     1: #include "nsIDOMProcessingInstruction.h"
     1: #include "nsIDOMHTMLBodyElement.h"
     1: #include "nsIDOMHTMLTableElement.h"
     1: #include "nsIDOMHTMLTableRowElement.h"
     1: #include "nsIDOMHTMLTableCellElement.h"
     1: #include "nsIDOMHTMLAnchorElement.h"
     1: #include "nsIDOMHTMLAreaElement.h"
     1: #include "nsIDOMHTMLImageElement.h"
     1: #include "nsIDOMHTMLScriptElement.h"
     1: #include "nsIDOMHTMLLinkElement.h"
     1: #include "nsIDOMHTMLBaseElement.h"
     1: #include "nsIDOMHTMLFrameElement.h"
     1: #include "nsIDOMHTMLIFrameElement.h"
     1: #include "nsIDOMHTMLInputElement.h"
     1: #include "nsIDOMHTMLEmbedElement.h"
     1: #include "nsIDOMHTMLObjectElement.h"
     1: #include "nsIDOMHTMLAppletElement.h"
 16267: #include "nsIDOMHTMLOptionElement.h"
 16267: #include "nsIDOMHTMLTextAreaElement.h"
     1: #include "nsIDOMHTMLDocument.h"
     1: #include "nsIDOMSVGImageElement.h"
     1: #include "nsIDOMSVGScriptElement.h"
 50877: #ifdef MOZ_MEDIA
 50877: #include "nsIDOMHTMLSourceElement.h"
 50877: #include "nsIDOMHTMLMediaElement.h"
 50877: #endif // MOZ_MEDIA
     1:  
     1: #include "nsIImageLoadingContent.h"
     1: 
     1: #include "ftpCore.h"
     1: #include "nsITransport.h"
     1: #include "nsISocketTransport.h"
     1: #include "nsIStringBundle.h"
   538: #include "nsIProtocolHandler.h"
     1: 
     1: #include "nsWebBrowserPersist.h"
     1: 
 80467: using namespace mozilla;
 80467: 
  9812: // Buffer file writes in 32kb chunks
  9812: #define BUFFERED_OUTPUT_SIZE (1024 * 32)
     1: 
     1: // Information about a DOM document
     1: struct DocData
     1: {
     1:     nsCOMPtr<nsIURI> mBaseURI;
     1:     nsCOMPtr<nsIDOMDocument> mDocument;
     1:     nsCOMPtr<nsIURI> mFile;
     1:     nsCOMPtr<nsIURI> mDataPath;
 79445:     bool mDataPathIsRelative;
     1:     nsCString mRelativePathToData;
     1:     nsCString mCharset;
     1: };
     1: 
     1: // Information about a URI
     1: struct URIData
     1: {
 79445:     bool mNeedsPersisting;
 79445:     bool mSaved;
 79445:     bool mIsSubFrame;
 79445:     bool mDataPathIsRelative;
 79445:     bool mNeedsFixup;
     1:     nsString mFilename;
     1:     nsString mSubFrameExt;
     1:     nsCOMPtr<nsIURI> mFile;
     1:     nsCOMPtr<nsIURI> mDataPath;
     1:     nsCString mRelativePathToData;
     1:     nsCString mCharset;
     1: };
     1: 
     1: // Information about the output stream
     1: struct OutputData
     1: {
     1:     nsCOMPtr<nsIURI> mFile;
     1:     nsCOMPtr<nsIURI> mOriginalLocation;
     1:     nsCOMPtr<nsIOutputStream> mStream;
108991:     int64_t mSelfProgress;
108991:     int64_t mSelfProgressMax;
 79445:     bool mCalcFileExt;
 79445: 
 79445:     OutputData(nsIURI *aFile, nsIURI *aOriginalLocation, bool aCalcFileExt) :
     1:         mFile(aFile),
     1:         mOriginalLocation(aOriginalLocation),
     1:         mSelfProgress(0),
     1:         mSelfProgressMax(10000),
     1:         mCalcFileExt(aCalcFileExt)
     1:     {
     1:     }
     1:     ~OutputData()
     1:     {
     1:         if (mStream)
     1:         {
     1:             mStream->Close();
     1:         }
     1:     }
     1: };
     1: 
     1: struct UploadData
     1: {
     1:     nsCOMPtr<nsIURI> mFile;
108991:     int64_t mSelfProgress;
108991:     int64_t mSelfProgressMax;
     1: 
     1:     UploadData(nsIURI *aFile) :
     1:         mFile(aFile),
     1:         mSelfProgress(0),
     1:         mSelfProgressMax(10000)
     1:     {
     1:     }
     1: };
     1: 
     1: struct CleanupData
     1: {
101111:     nsCOMPtr<nsIFile> mFile;
     1:     // Snapshot of what the file actually is at the time of creation so that if
     1:     // it transmutes into something else later on it can be ignored. For example,
     1:     // catch files that turn into dirs or vice versa.
 79445:     bool mIsDirectory;
     1: };
     1: 
     1: // Maximum file length constant. The max file name length is
     1: // volume / server dependent but it is difficult to obtain
     1: // that information. Instead this constant is a reasonable value that
     1: // modern systems should able to cope with.
108991: const uint32_t kDefaultMaxFilenameLength = 64;
     1: 
     1: // Default flags for persistence
108991: const uint32_t kDefaultPersistFlags = 
     1:     nsIWebBrowserPersist::PERSIST_FLAGS_NO_CONVERSION |
     1:     nsIWebBrowserPersist::PERSIST_FLAGS_REPLACE_EXISTING_FILES;
     1: 
     1: // String bundle where error messages come from
     1: const char *kWebBrowserPersistStringBundle =
     1:     "chrome://global/locale/nsWebBrowserPersist.properties";
     1: 
     1: nsWebBrowserPersist::nsWebBrowserPersist() :
     1:     mCurrentThingsToPersist(0),
 80486:     mFirstAndOnlyUse(true),
 80486:     mCancel(false),
 80486:     mJustStartedLoading(true),
 80486:     mCompleted(false),
 80486:     mStartSaving(false),
 80486:     mReplaceExisting(true),
 80486:     mSerializingOutput(false),
     1:     mPersistFlags(kDefaultPersistFlags),
     1:     mPersistResult(NS_OK),
 64617:     mTotalCurrentProgress(0),
 64617:     mTotalMaxProgress(0),
 69294:     mWrapColumn(72),
     1:     mEncodingFlags(0)
     1: {
     1: }
     1: 
     1: nsWebBrowserPersist::~nsWebBrowserPersist()
     1: {
     1:     Cleanup();
     1: }
     1: 
     1: //*****************************************************************************
     1: // nsWebBrowserPersist::nsISupports
     1: //*****************************************************************************
     1: 
     1: NS_IMPL_ADDREF(nsWebBrowserPersist)
     1: NS_IMPL_RELEASE(nsWebBrowserPersist)
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsWebBrowserPersist)
     1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIWebBrowserPersist)
     1:     NS_INTERFACE_MAP_ENTRY(nsIWebBrowserPersist)
     1:     NS_INTERFACE_MAP_ENTRY(nsICancelable)
     1:     NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
     1:     NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
     1:     NS_INTERFACE_MAP_ENTRY(nsIStreamListener)
     1:     NS_INTERFACE_MAP_ENTRY(nsIRequestObserver)
     1:     NS_INTERFACE_MAP_ENTRY(nsIProgressEventSink)
     1: NS_INTERFACE_MAP_END
     1: 
     1: 
     1: //*****************************************************************************
     1: // nsWebBrowserPersist::nsIInterfaceRequestor
     1: //*****************************************************************************
     1: 
     1: NS_IMETHODIMP nsWebBrowserPersist::GetInterface(const nsIID & aIID, void **aIFace)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aIFace);
     1: 
106838:     *aIFace = nullptr;
     1: 
     1:     nsresult rv = QueryInterface(aIID, aIFace);
     1:     if (NS_SUCCEEDED(rv))
     1:     {
     1:         return rv;
     1:     }
     1:     
     1:     if (mProgressListener && (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) 
     1:                              || aIID.Equals(NS_GET_IID(nsIPrompt))))
     1:     {
     1:         mProgressListener->QueryInterface(aIID, aIFace);
     1:         if (*aIFace)
     1:             return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIInterfaceRequestor> req = do_QueryInterface(mProgressListener);
     1:     if (req)
     1:     {
     1:         return req->GetInterface(aIID, aIFace);
     1:     }
     1: 
     1:     return NS_ERROR_NO_INTERFACE;
     1: }
     1: 
     1: 
     1: //*****************************************************************************
     1: // nsWebBrowserPersist::nsIWebBrowserPersist
     1: //*****************************************************************************
     1: 
     1: /* attribute unsigned long persistFlags; */
108991: NS_IMETHODIMP nsWebBrowserPersist::GetPersistFlags(uint32_t *aPersistFlags)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aPersistFlags);
     1:     *aPersistFlags = mPersistFlags;
     1:     return NS_OK;
     1: }
108991: NS_IMETHODIMP nsWebBrowserPersist::SetPersistFlags(uint32_t aPersistFlags)
     1: {
     1:     mPersistFlags = aPersistFlags;
 80486:     mReplaceExisting = (mPersistFlags & PERSIST_FLAGS_REPLACE_EXISTING_FILES) ? true : false;
 80486:     mSerializingOutput = (mPersistFlags & PERSIST_FLAGS_SERIALIZE_OUTPUT) ? true : false;
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute unsigned long currentState; */
108991: NS_IMETHODIMP nsWebBrowserPersist::GetCurrentState(uint32_t *aCurrentState)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aCurrentState);
     1:     if (mCompleted)
     1:     {
     1:         *aCurrentState = PERSIST_STATE_FINISHED;
     1:     }
     1:     else if (mFirstAndOnlyUse)
     1:     {
     1:         *aCurrentState = PERSIST_STATE_SAVING;
     1:     }
     1:     else
     1:     {
     1:         *aCurrentState = PERSIST_STATE_READY;
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute unsigned long result; */
108412: NS_IMETHODIMP nsWebBrowserPersist::GetResult(nsresult *aResult)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aResult);
     1:     *aResult = mPersistResult;
     1:     return NS_OK;
     1: }
     1: 
     1: /* attribute nsIWebBrowserPersistProgress progressListener; */
     1: NS_IMETHODIMP nsWebBrowserPersist::GetProgressListener(
     1:     nsIWebProgressListener * *aProgressListener)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aProgressListener);
     1:     *aProgressListener = mProgressListener;
     1:     NS_IF_ADDREF(*aProgressListener);
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP nsWebBrowserPersist::SetProgressListener(
     1:     nsIWebProgressListener * aProgressListener)
     1: {
     1:     mProgressListener = aProgressListener;
     1:     mProgressListener2 = do_QueryInterface(aProgressListener);
     1:     mEventSink = do_GetInterface(aProgressListener);
     1:     return NS_OK;
     1: }
     1: 
     1: /* void saveURI (in nsIURI aURI, in nsISupports aCacheKey, in nsIURI aReferrer,
     1:    in nsIInputStream aPostData, in wstring aExtraHeaders,
     1:    in nsISupports aFile); */
     1: NS_IMETHODIMP nsWebBrowserPersist::SaveURI(
     1:     nsIURI *aURI, nsISupports *aCacheKey, nsIURI *aReferrer, nsIInputStream *aPostData, const char *aExtraHeaders, nsISupports *aFile)
     1: {
     1:     NS_ENSURE_TRUE(mFirstAndOnlyUse, NS_ERROR_FAILURE);
 80486:     mFirstAndOnlyUse = false; // Stop people from reusing this object!
     1: 
     1:     nsCOMPtr<nsIURI> fileAsURI;
     1:     nsresult rv;
     1:     rv = GetValidURIFromObject(aFile, getter_AddRefs(fileAsURI));
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_INVALID_ARG);
     1: 
     1:     // SaveURI doesn't like broken uris.
     1:     mPersistFlags |= PERSIST_FLAGS_FAIL_ON_BROKEN_LINKS;
 80486:     rv = SaveURIInternal(aURI, aCacheKey, aReferrer, aPostData, aExtraHeaders, fileAsURI, false);
     1:     return NS_FAILED(rv) ? rv : NS_OK;
     1: }
     1: 
     1: /* void saveChannel (in nsIChannel aChannel, in nsISupports aFile); */
     1: NS_IMETHODIMP nsWebBrowserPersist::SaveChannel(
     1:     nsIChannel *aChannel, nsISupports *aFile)
     1: {
     1:     NS_ENSURE_TRUE(mFirstAndOnlyUse, NS_ERROR_FAILURE);
 80486:     mFirstAndOnlyUse = false; // Stop people from reusing this object!
     1: 
     1:     nsCOMPtr<nsIURI> fileAsURI;
     1:     nsresult rv;
     1:     rv = GetValidURIFromObject(aFile, getter_AddRefs(fileAsURI));
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_INVALID_ARG);
     1: 
     1:     rv = aChannel->GetURI(getter_AddRefs(mURI));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // SaveURI doesn't like broken uris.
     1:     mPersistFlags |= PERSIST_FLAGS_FAIL_ON_BROKEN_LINKS;
 80486:     rv = SaveChannelInternal(aChannel, fileAsURI, false);
     1:     return NS_FAILED(rv) ? rv : NS_OK;
     1: }
     1: 
     1: 
     1: /* void saveDocument (in nsIDOMDocument aDocument, in nsIURI aFileURI,
     1:    in nsIURI aDataPathURI, in string aOutputContentType,
     1:    in unsigned long aEncodingFlags, in unsigned long aWrapColumn); */
     1: NS_IMETHODIMP nsWebBrowserPersist::SaveDocument(
     1:     nsIDOMDocument *aDocument, nsISupports *aFile, nsISupports *aDataPath,
108991:     const char *aOutputContentType, uint32_t aEncodingFlags, uint32_t aWrapColumn)
     1: {
     1:     NS_ENSURE_TRUE(mFirstAndOnlyUse, NS_ERROR_FAILURE);
 80486:     mFirstAndOnlyUse = false; // Stop people from reusing this object!
     1: 
     1:     nsCOMPtr<nsIURI> fileAsURI;
     1:     nsCOMPtr<nsIURI> datapathAsURI;
     1:     nsresult rv;
     1: 
     1:     rv = GetValidURIFromObject(aFile, getter_AddRefs(fileAsURI));
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_INVALID_ARG);
     1:     if (aDataPath)
     1:     {
     1:         rv = GetValidURIFromObject(aDataPath, getter_AddRefs(datapathAsURI));
     1:         NS_ENSURE_SUCCESS(rv, NS_ERROR_INVALID_ARG);
     1:     }
     1: 
     1:     mWrapColumn = aWrapColumn;
     1: 
     1:     // Produce nsIDocumentEncoder encoding flags
     1:     mEncodingFlags = 0;
     1:     if (aEncodingFlags & ENCODE_FLAGS_SELECTION_ONLY)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputSelectionOnly;
     1:     if (aEncodingFlags & ENCODE_FLAGS_FORMATTED)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputFormatted;
     1:     if (aEncodingFlags & ENCODE_FLAGS_RAW)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputRaw;
     1:     if (aEncodingFlags & ENCODE_FLAGS_BODY_ONLY)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputBodyOnly;
     1:     if (aEncodingFlags & ENCODE_FLAGS_PREFORMATTED)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputPreformatted;
     1:     if (aEncodingFlags & ENCODE_FLAGS_WRAP)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputWrap;
     1:     if (aEncodingFlags & ENCODE_FLAGS_FORMAT_FLOWED)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputFormatFlowed;
     1:     if (aEncodingFlags & ENCODE_FLAGS_ABSOLUTE_LINKS)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputAbsoluteLinks;
     1:     if (aEncodingFlags & ENCODE_FLAGS_ENCODE_BASIC_ENTITIES)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputEncodeBasicEntities;
     1:     if (aEncodingFlags & ENCODE_FLAGS_ENCODE_LATIN1_ENTITIES)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputEncodeLatin1Entities;
     1:     if (aEncodingFlags & ENCODE_FLAGS_ENCODE_HTML_ENTITIES)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputEncodeHTMLEntities;
     1:     if (aEncodingFlags & ENCODE_FLAGS_ENCODE_W3C_ENTITIES)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputEncodeW3CEntities;
     1:     if (aEncodingFlags & ENCODE_FLAGS_CR_LINEBREAKS)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputCRLineBreak;
     1:     if (aEncodingFlags & ENCODE_FLAGS_LF_LINEBREAKS)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputLFLineBreak;
     1:     if (aEncodingFlags & ENCODE_FLAGS_NOSCRIPT_CONTENT)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputNoScriptContent;
     1:     if (aEncodingFlags & ENCODE_FLAGS_NOFRAMES_CONTENT)
     1:         mEncodingFlags |= nsIDocumentEncoder::OutputNoFramesContent;
     1:     
     1:     if (aOutputContentType)
     1:     {
     1:         mContentType.AssignASCII(aOutputContentType);
     1:     }
     1: 
     1:     rv = SaveDocumentInternal(aDocument, fileAsURI, datapathAsURI);
     1: 
     1:     // Now save the URIs that have been gathered
     1: 
     1:     if (NS_SUCCEEDED(rv) && datapathAsURI)
     1:     {
     1:         rv = SaveGatheredURIs(fileAsURI);
     1:     }
     1:     else if (mProgressListener)
     1:     {
     1:         // tell the listener we're done
106838:         mProgressListener->OnStateChange(nullptr, nullptr,
 12812:                                          nsIWebProgressListener::STATE_START |
 12812:                                          nsIWebProgressListener::STATE_IS_NETWORK,
     1:                                          NS_OK);
106838:         mProgressListener->OnStateChange(nullptr, nullptr,
 12812:                                          nsIWebProgressListener::STATE_STOP |
 12812:                                          nsIWebProgressListener::STATE_IS_NETWORK,
     1:                                          rv);
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: /* void cancel(nsresult aReason); */
     1: NS_IMETHODIMP nsWebBrowserPersist::Cancel(nsresult aReason)
     1: {
 80486:     mCancel = true;
     1:     EndDownload(aReason);
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: /* void cancelSave(); */
     1: NS_IMETHODIMP nsWebBrowserPersist::CancelSave()
     1: {
     1:     return Cancel(NS_BINDING_ABORTED);
     1: }
     1: 
     1: 
     1: nsresult
     1: nsWebBrowserPersist::StartUpload(nsIStorageStream *storStream, 
     1:     nsIURI *aDestinationURI, const nsACString &aContentType)
     1: {
     1:      // setup the upload channel if the destination is not local
     1:     nsCOMPtr<nsIInputStream> inputstream;
     1:     nsresult rv = storStream->NewInputStream(0, getter_AddRefs(inputstream));
     1:     NS_ENSURE_TRUE(inputstream, NS_ERROR_FAILURE);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
 39409:     return StartUpload(inputstream, aDestinationURI, aContentType);
 39409: }
 39409: 
 39409: nsresult
 39409: nsWebBrowserPersist::StartUpload(nsIInputStream *aInputStream,
 39409:     nsIURI *aDestinationURI, const nsACString &aContentType)
 39409: {
     1:     nsCOMPtr<nsIChannel> destChannel;
 39409:     CreateChannelFromURI(aDestinationURI, getter_AddRefs(destChannel));
     1:     nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(destChannel));
     1:     NS_ENSURE_TRUE(uploadChannel, NS_ERROR_FAILURE);
     1: 
     1:     // Set the upload stream
     1:     // NOTE: ALL data must be available in "inputstream"
 39409:     nsresult rv = uploadChannel->SetUploadStream(aInputStream, aContentType, -1);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
106838:     rv = destChannel->AsyncOpen(this, nullptr);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     // add this to the upload list
     1:     nsCOMPtr<nsISupports> keyPtr = do_QueryInterface(destChannel);
     1:     nsISupportsKey key(keyPtr);
     1:     mUploadList.Put(&key, new UploadData(aDestinationURI));
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::SaveGatheredURIs(nsIURI *aFileAsURI)
     1: {
     1:     nsresult rv = NS_OK;
     1: 
     1:     // Count how many URIs in the URI map require persisting
108991:     uint32_t urisToPersist = 0;
     1:     if (mURIMap.Count() > 0)
     1:     {
     1:         mURIMap.Enumerate(EnumCountURIsToPersist, &urisToPersist);
     1:     }
     1: 
     1:     if (urisToPersist > 0)
     1:     {
     1:         // Persist each file in the uri map. The document(s)
     1:         // will be saved after the last one of these is saved.
     1:         mURIMap.Enumerate(EnumPersistURIs, this);
     1:     }
     1: 
     1:     // if we don't have anything in mOutputMap (added from above enumeration)
     1:     // then we build the doc list (SaveDocuments)
     1:     if (mOutputMap.Count() == 0)
     1:     {
     1:         // There are no URIs to save, so just save the document(s)
     1: 
     1:         // State start notification
108991:         uint32_t addToStateFlags = 0;
     1:         if (mProgressListener)
     1:         {
     1:             if (mJustStartedLoading)
     1:             {
     1:                 addToStateFlags |= nsIWebProgressListener::STATE_IS_NETWORK;
     1:             }
106838:             mProgressListener->OnStateChange(nullptr, nullptr,
     1:                 nsIWebProgressListener::STATE_START | addToStateFlags, NS_OK);
     1:         }
     1: 
     1:         rv = SaveDocuments();
     1:         if (NS_FAILED(rv))
     1:             EndDownload(rv);
     1:         else if (aFileAsURI)
     1:         {
     1:             // local files won't trigger OnStopRequest so we call EndDownload here
 79445:             bool isFile = false;
     1:             aFileAsURI->SchemeIs("file", &isFile);
     1:             if (isFile)
     1:                 EndDownload(NS_OK);
     1:         }
     1: 
     1:         // State stop notification
     1:         if (mProgressListener)
     1:         {
106838:             mProgressListener->OnStateChange(nullptr, nullptr,
     1:                 nsIWebProgressListener::STATE_STOP | addToStateFlags, rv);
     1:         }
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: // this method returns true if there is another file to persist and false if not
 79445: bool
     1: nsWebBrowserPersist::SerializeNextFile()
     1: {
     1:     if (!mSerializingOutput)
     1:     {
 80486:         return false;
     1:     }
     1: 
106838:     nsresult rv = SaveGatheredURIs(nullptr);
     1:     if (NS_FAILED(rv))
     1:     {
 80486:         return false;
     1:     }
     1: 
     1:     return (mURIMap.Count() 
     1:         || mUploadList.Count()
 25498:         || mDocList.Length()
     1:         || mOutputMap.Count());
     1: }
     1: 
     1: 
     1: //*****************************************************************************
     1: // nsWebBrowserPersist::nsIRequestObserver
     1: //*****************************************************************************
     1: 
     1: NS_IMETHODIMP nsWebBrowserPersist::OnStartRequest(
     1:     nsIRequest* request, nsISupports *ctxt)
     1: {
     1:     if (mProgressListener)
     1:     {
108991:         uint32_t stateFlags = nsIWebProgressListener::STATE_START |
     1:                               nsIWebProgressListener::STATE_IS_REQUEST;
     1:         if (mJustStartedLoading)
     1:         {
     1:             stateFlags |= nsIWebProgressListener::STATE_IS_NETWORK;
     1:         }
106838:         mProgressListener->OnStateChange(nullptr, request, stateFlags, NS_OK);
     1:     }
     1: 
 80486:     mJustStartedLoading = false;
     1: 
     1:     nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
     1:     NS_ENSURE_TRUE(channel, NS_ERROR_FAILURE);
     1: 
     1:     nsCOMPtr<nsISupports> keyPtr = do_QueryInterface(request);
     1:     nsISupportsKey key(keyPtr);
     1:     OutputData *data = (OutputData *) mOutputMap.Get(&key);
     1: 
     1:     // NOTE: This code uses the channel as a hash key so it will not
     1:     //       recognize redirected channels because the key is not the same.
     1:     //       When that happens we remove and add the data entry to use the
     1:     //       new channel as the hash key.
     1:     if (!data)
     1:     {
     1:         UploadData *upData = (UploadData *) mUploadList.Get(&key);
     1:         if (!upData)
     1:         {
     1:             // Redirect? Try and fixup the output table
     1:             nsresult rv = FixRedirectedChannelEntry(channel);
     1:             NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:             // Should be able to find the data after fixup unless redirects
     1:             // are disabled.
     1:             data = (OutputData *) mOutputMap.Get(&key);
     1:             if (!data)
     1:             {
     1:                 return NS_ERROR_FAILURE;
     1:             }
     1:         }
     1:     }
     1: 
     1:     if (data && data->mFile)
     1:     {
     1:         // If PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION is set in mPersistFlags,
     1:         // try to determine whether this channel needs to apply Content-Encoding
     1:         // conversions.
     1:         NS_ASSERTION(!((mPersistFlags & PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION) &&
     1:                       (mPersistFlags & PERSIST_FLAGS_NO_CONVERSION)),
     1:                      "Conflict in persist flags: both AUTODETECT and NO_CONVERSION set");
     1:         if (mPersistFlags & PERSIST_FLAGS_AUTODETECT_APPLY_CONVERSION)
     1:             SetApplyConversionIfNeeded(channel);
     1: 
     1:         if (data->mCalcFileExt && !(mPersistFlags & PERSIST_FLAGS_DONT_CHANGE_FILENAMES))
     1:         {
     1:             // this is the first point at which the server can tell us the mimetype
     1:             CalculateAndAppendFileExt(data->mFile, channel, data->mOriginalLocation);
     1: 
     1:             // now make filename conformant and unique
     1:             CalculateUniqueFilename(data->mFile);
     1:         }
     1: 
     1:         // compare uris and bail before we add to output map if they are equal
 79445:         bool isEqual = false;
     1:         if (NS_SUCCEEDED(data->mFile->Equals(data->mOriginalLocation, &isEqual))
     1:             && isEqual)
     1:         {
     1:             // remove from output map
     1:             delete data;
     1:             mOutputMap.Remove(&key);
     1: 
     1:             // cancel; we don't need to know any more
     1:             // stop request will get called
     1:             request->Cancel(NS_BINDING_ABORTED);
     1:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1:  
     1: NS_IMETHODIMP nsWebBrowserPersist::OnStopRequest(
     1:     nsIRequest* request, nsISupports *ctxt, nsresult status)
     1: {
     1:     nsCOMPtr<nsISupports> keyPtr = do_QueryInterface(request);
     1:     nsISupportsKey key(keyPtr);
     1:     OutputData *data = (OutputData *) mOutputMap.Get(&key);
     1:     if (data)
     1:     {
  3794:         if (NS_SUCCEEDED(mPersistResult) && NS_FAILED(status))
 80486:             SendErrorStatusChange(true, status, request, data->mFile);
  3794: 
     1: #if defined(XP_OS2)
     1:         // delete 'data';  this will close the stream and let
     1:         // us tag the file it created with its source URI
     1:         nsCOMPtr<nsIURI> uriSource = data->mOriginalLocation;
101111:         nsCOMPtr<nsIFile> localFile;
     1:         GetLocalFileFromURI(data->mFile, getter_AddRefs(localFile));
     1:         delete data;
     1:         mOutputMap.Remove(&key);
     1:         if (localFile)
     1:         {
     1:             nsCOMPtr<nsILocalFileOS2> localFileOS2 = do_QueryInterface(localFile);
     1:             if (localFileOS2)
     1:             {
     1:                 nsCAutoString url;
     1:                 uriSource->GetSpec(url);
     1:                 localFileOS2->SetFileSource(url);
     1:             }
     1:         }
     1: #else
     1:         // This will close automatically close the output stream
     1:         delete data;
     1:         mOutputMap.Remove(&key);
     1: #endif
     1:     }
     1:     else
     1:     {
     1:         // if we didn't find the data in mOutputMap, try mUploadList
     1:         UploadData *upData = (UploadData *) mUploadList.Get(&key);
     1:         if (upData)
     1:         {
     1:             delete upData;
     1:             mUploadList.Remove(&key);
     1:         }
     1:     }
     1: 
     1:     // ensure we call SaveDocuments if we:
     1:     // 1) aren't canceling
     1:     // 2) we haven't triggered the save (which we only want to trigger once)
     1:     // 3) we aren't serializing (which will call it inside SerializeNextFile)
     1:     if (mOutputMap.Count() == 0 && !mCancel && !mStartSaving && !mSerializingOutput)
     1:     {
     1:         nsresult rv = SaveDocuments();
     1:         NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1:     }
     1: 
 79445:     bool completed = false;
     1:     if (mOutputMap.Count() == 0 && mUploadList.Count() == 0 && !mCancel)
     1:     {
     1:         // if no documents left in mDocList, --> done
     1:         // if we have no files left to serialize and no error result, --> done
 25498:         if (mDocList.Length() == 0
     1:             || (!SerializeNextFile() && NS_SUCCEEDED(mPersistResult)))
     1:         {
 80486:             completed = true;
     1:         }
     1:     }
     1: 
     1:     if (completed)
     1:     {
     1:         // we're all done, do our cleanup
  3794:         EndDownload(status);
     1:     }
     1: 
     1:     if (mProgressListener)
     1:     {
108991:         uint32_t stateFlags = nsIWebProgressListener::STATE_STOP |
     1:                               nsIWebProgressListener::STATE_IS_REQUEST;
     1:         if (completed)
     1:         {
     1:             stateFlags |= nsIWebProgressListener::STATE_IS_NETWORK;
     1:         }
106838:         mProgressListener->OnStateChange(nullptr, request, stateFlags, status);
     1:     }
     1:     if (completed)
     1:     {
106838:         mProgressListener = nullptr;
106838:         mProgressListener2 = nullptr;
106838:         mEventSink = nullptr;
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: //*****************************************************************************
     1: // nsWebBrowserPersist::nsIStreamListener
     1: //*****************************************************************************
     1: 
     1: NS_IMETHODIMP nsWebBrowserPersist::OnDataAvailable(
     1:     nsIRequest* request, nsISupports *aContext, nsIInputStream *aIStream,
108991:     uint32_t aOffset, uint32_t aLength)
     1: {
 79445:     bool cancel = mCancel;
     1:     if (!cancel)
     1:     {
     1:         nsresult rv = NS_OK;
108991:         uint32_t bytesRemaining = aLength;
     1: 
     1:         nsCOMPtr<nsIChannel> channel = do_QueryInterface(request);
     1:         NS_ENSURE_TRUE(channel, NS_ERROR_FAILURE);
     1: 
     1:         nsCOMPtr<nsISupports> keyPtr = do_QueryInterface(request);
     1:         nsISupportsKey key(keyPtr);
     1:         OutputData *data = (OutputData *) mOutputMap.Get(&key);
     1:         if (!data) {
     1:             // might be uploadData; consume necko's buffer and bail...
108991:             uint32_t n;
106838:             return aIStream->ReadSegments(NS_DiscardSegment, nullptr, aLength, &n);
     1:         }
     1: 
 79445:         bool readError = true;
     1: 
     1:         // Make the output stream
     1:         if (!data->mStream)
     1:         {
     1:             rv = MakeOutputStream(data->mFile, getter_AddRefs(data->mStream));
     1:             if (NS_FAILED(rv))
     1:             {
 80486:                 readError = false;
 80486:                 cancel = true;
     1:             }
     1:         }
     1: 
     1:         // Read data from the input and write to the output
     1:         char buffer[8192];
108991:         uint32_t bytesRead;
     1:         while (!cancel && bytesRemaining)
     1:         {
 80486:             readError = true;
 38394:             rv = aIStream->Read(buffer,
108991:                                 NS_MIN(uint32_t(sizeof(buffer)), bytesRemaining),
 38394:                                 &bytesRead);
     1:             if (NS_SUCCEEDED(rv))
     1:             {
 80486:                 readError = false;
     1:                 // Write out the data until something goes wrong, or, it is
     1:                 // all written.  We loop because for some errors (e.g., disk
     1:                 // full), we get NS_OK with some bytes written, then an error.
     1:                 // So, we want to write again in that case to get the actual
     1:                 // error code.
     1:                 const char *bufPtr = buffer; // Where to write from.
     1:                 while (NS_SUCCEEDED(rv) && bytesRead)
     1:                 {
108991:                     uint32_t bytesWritten = 0;
     1:                     rv = data->mStream->Write(bufPtr, bytesRead, &bytesWritten);
     1:                     if (NS_SUCCEEDED(rv))
     1:                     {
     1:                         bytesRead -= bytesWritten;
     1:                         bufPtr += bytesWritten;
     1:                         bytesRemaining -= bytesWritten;
     1:                         // Force an error if (for some reason) we get NS_OK but
     1:                         // no bytes written.
     1:                         if (!bytesWritten)
     1:                         {
     1:                             rv = NS_ERROR_FAILURE;
 80486:                             cancel = true;
     1:                         }
     1:                     }
     1:                     else
     1:                     {
     1:                         // Disaster - can't write out the bytes - disk full / permission?
 80486:                         cancel = true;
     1:                     }
     1:                 }
     1:             }
     1:             else
     1:             {
     1:                 // Disaster - can't read the bytes - broken link / file error?
 80486:                 cancel = true;
     1:             }
     1:         }
     1: 
108991:         int32_t channelContentLength = -1;
     1:         if (!cancel &&
     1:             NS_SUCCEEDED(channel->GetContentLength(&channelContentLength)))
     1:         {
     1:             // if we get -1 at this point, we didn't get content-length header
     1:             // assume that we got all of the data and push what we have; 
     1:             // that's the best we can do now
     1:             if ((-1 == channelContentLength) ||
     1:                 ((channelContentLength - (aOffset + aLength)) == 0))
     1:             {
     1:                 NS_WARN_IF_FALSE(channelContentLength != -1,
     1:                     "nsWebBrowserPersist::OnDataAvailable() no content length "
     1:                     "header, pushing what we have");
     1:                 // we're done with this pass; see if we need to do upload
     1:                 nsCAutoString contentType;
     1:                 channel->GetContentType(contentType);
     1:                 // if we don't have the right type of output stream then it's a local file
     1:                 nsCOMPtr<nsIStorageStream> storStream(do_QueryInterface(data->mStream));
     1:                 if (storStream)
     1:                 {
     1:                     data->mStream->Close();
106838:                     data->mStream = nullptr; // null out stream so we don't close it later
     1:                     rv = StartUpload(storStream, data->mFile, contentType);
     1:                     if (NS_FAILED(rv))
     1:                     {
 80486:                         readError = false;
 80486:                         cancel = true;
     1:                     }
     1:                 }
     1:             }
     1:         }
     1: 
     1:         // Notify listener if an error occurred.
     1:         if (cancel)
     1:         {
     1:             SendErrorStatusChange(readError, rv,
106838:                 readError ? request : nullptr, data->mFile);
     1:         }
     1:     }
     1: 
     1:     // Cancel reading?
     1:     if (cancel)
     1:     {
     1:         EndDownload(NS_BINDING_ABORTED);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: //*****************************************************************************
     1: // nsWebBrowserPersist::nsIProgressEventSink
     1: //*****************************************************************************
     1: 
     1: /* void onProgress (in nsIRequest request, in nsISupports ctxt,
     1:     in unsigned long long aProgress, in unsigned long long aProgressMax); */
     1: NS_IMETHODIMP nsWebBrowserPersist::OnProgress(
108991:     nsIRequest *request, nsISupports *ctxt, uint64_t aProgress,
108991:     uint64_t aProgressMax)
     1: {
     1:     if (!mProgressListener)
     1:     {
     1:         return NS_OK;
     1:     }
     1: 
     1:     // Store the progress of this request
     1:     nsCOMPtr<nsISupports> keyPtr = do_QueryInterface(request);
     1:     nsISupportsKey key(keyPtr);
     1:     OutputData *data = (OutputData *) mOutputMap.Get(&key);
     1:     if (data)
     1:     {
108991:         data->mSelfProgress = int64_t(aProgress);
108991:         data->mSelfProgressMax = int64_t(aProgressMax);
     1:     }
     1:     else
     1:     {
     1:         UploadData *upData = (UploadData *) mUploadList.Get(&key);
     1:         if (upData)
     1:         {
108991:             upData->mSelfProgress = int64_t(aProgress);
108991:             upData->mSelfProgressMax = int64_t(aProgressMax);
     1:         }
     1:     }
     1: 
     1:     // Notify listener of total progress
     1:     CalcTotalProgress();
     1:     if (mProgressListener2)
     1:     {
106838:       mProgressListener2->OnProgressChange64(nullptr, request, aProgress,
     1:             aProgressMax, mTotalCurrentProgress, mTotalMaxProgress);
     1:     }
     1:     else
     1:     {
     1:       // have to truncate 64-bit to 32bit
108991:       mProgressListener->OnProgressChange(nullptr, request, uint64_t(aProgress),
108991:               uint64_t(aProgressMax), mTotalCurrentProgress, mTotalMaxProgress);
     1:     }
     1: 
     1:     // If our progress listener implements nsIProgressEventSink,
     1:     // forward the notification
     1:     if (mEventSink)
     1:     {
     1:         mEventSink->OnProgress(request, ctxt, aProgress, aProgressMax);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: /* void onStatus (in nsIRequest request, in nsISupports ctxt,
     1:     in nsresult status, in wstring statusArg); */
     1: NS_IMETHODIMP nsWebBrowserPersist::OnStatus(
     1:     nsIRequest *request, nsISupports *ctxt, nsresult status,
     1:     const PRUnichar *statusArg)
     1: {
     1:     if (mProgressListener)
     1:     {
     1:         // We need to filter out non-error error codes.
     1:         // Is the only NS_SUCCEEDED value NS_OK?
     1:         switch ( status )
     1:         {
     1:         case NS_NET_STATUS_RESOLVING_HOST:
 70188:         case NS_NET_STATUS_RESOLVED_HOST:
     1:         case NS_NET_STATUS_BEGIN_FTP_TRANSACTION:
     1:         case NS_NET_STATUS_END_FTP_TRANSACTION:
     1:         case NS_NET_STATUS_CONNECTING_TO:
     1:         case NS_NET_STATUS_CONNECTED_TO:
     1:         case NS_NET_STATUS_SENDING_TO:
     1:         case NS_NET_STATUS_RECEIVING_FROM:
     1:         case NS_NET_STATUS_WAITING_FOR:
108414:         case NS_NET_STATUS_READING:
108414:         case NS_NET_STATUS_WRITING:
     1:             break;
     1: 
     1:         default:
     1:             // Pass other notifications (for legitimate errors) along.
106838:             mProgressListener->OnStatusChange(nullptr, request, status, statusArg);
     1:             break;
     1:         }
     1: 
     1:     }
     1: 
     1:     // If our progress listener implements nsIProgressEventSink,
     1:     // forward the notification
     1:     if (mEventSink)
     1:     {
     1:         mEventSink->OnStatus(request, ctxt, status, statusArg);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: //*****************************************************************************
     1: // nsWebBrowserPersist private methods
     1: //*****************************************************************************
     1: 
     1: // Convert error info into proper message text and send OnStatusChange notification
     1: // to the web progress listener.
     1: nsresult nsWebBrowserPersist::SendErrorStatusChange( 
 79445:     bool aIsReadError, nsresult aResult, nsIRequest *aRequest, nsIURI *aURI)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aURI);
     1: 
     1:     if (!mProgressListener)
     1:     {
     1:         // Do nothing
     1:         return NS_OK;
     1:     }
     1: 
     1:     // Get the file path or spec from the supplied URI
101111:     nsCOMPtr<nsIFile> file;
     1:     GetLocalFileFromURI(aURI, getter_AddRefs(file));
     1:     nsAutoString path;
     1:     if (file)
     1:     {
     1:         file->GetPath(path);
     1:     }
     1:     else
     1:     {
     1:         nsCAutoString fileurl;
     1:         aURI->GetSpec(fileurl);
     1:         AppendUTF8toUTF16(fileurl, path);
     1:     }
     1:     
     1:     nsAutoString msgId;
     1:     switch(aResult)
     1:     {
     1:     case NS_ERROR_FILE_NAME_TOO_LONG:
     1:         // File name too long.
     1:         msgId.AssignLiteral("fileNameTooLongError");
     1:         break;
     1:     case NS_ERROR_FILE_ALREADY_EXISTS:
     1:         // File exists with same name as directory.
     1:         msgId.AssignLiteral("fileAlreadyExistsError");
     1:         break;
     1:     case NS_ERROR_FILE_DISK_FULL:
     1:     case NS_ERROR_FILE_NO_DEVICE_SPACE:
     1:         // Out of space on target volume.
     1:         msgId.AssignLiteral("diskFull");
     1:         break;
     1: 
     1:     case NS_ERROR_FILE_READ_ONLY:
     1:         // Attempt to write to read/only file.
     1:         msgId.AssignLiteral("readOnly");
     1:         break;
     1: 
     1:     case NS_ERROR_FILE_ACCESS_DENIED:
     1:         // Attempt to write without sufficient permissions.
     1:         msgId.AssignLiteral("accessError");
     1:         break;
     1: 
     1:     default:
     1:         // Generic read/write error message.
     1:         if (aIsReadError)
     1:             msgId.AssignLiteral("readError");
     1:         else
     1:             msgId.AssignLiteral("writeError");
     1:         break;
     1:     }
     1:     // Get properties file bundle and extract status string.
     1:     nsresult rv;
     1:     nsCOMPtr<nsIStringBundleService> s = do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
     1:     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && s, NS_ERROR_FAILURE);
     1: 
     1:     nsCOMPtr<nsIStringBundle> bundle;
     1:     rv = s->CreateBundle(kWebBrowserPersistStringBundle, getter_AddRefs(bundle));
     1:     NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && bundle, NS_ERROR_FAILURE);
     1:     
     1:     nsXPIDLString msgText;
     1:     const PRUnichar *strings[1];
     1:     strings[0] = path.get();
     1:     rv = bundle->FormatStringFromName(msgId.get(), strings, 1, getter_Copies(msgText));
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
106838:     mProgressListener->OnStatusChange(nullptr, aRequest, aResult, msgText);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult nsWebBrowserPersist::GetValidURIFromObject(nsISupports *aObject, nsIURI **aURI) const
     1: {
     1:     NS_ENSURE_ARG_POINTER(aObject);
     1:     NS_ENSURE_ARG_POINTER(aURI);
     1:     
     1:     nsCOMPtr<nsIFile> objAsFile = do_QueryInterface(aObject);
     1:     if (objAsFile)
     1:     {
     1:         return NS_NewFileURI(aURI, objAsFile);
     1:     }
     1:     nsCOMPtr<nsIURI> objAsURI = do_QueryInterface(aObject);
     1:     if (objAsURI)
     1:     {
     1:         *aURI = objAsURI;
     1:         NS_ADDREF(*aURI);
     1:         return NS_OK;
     1:     }
     1: 
     1:     return NS_ERROR_FAILURE;
     1: }
     1: 
101111: nsresult nsWebBrowserPersist::GetLocalFileFromURI(nsIURI *aURI, nsIFile **aLocalFile) const
     1: {
     1:     nsresult rv;
     1: 
     1:     nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(aURI, &rv);
     1:     if (NS_FAILED(rv))
     1:         return rv;
     1: 
     1:     nsCOMPtr<nsIFile> file;
     1:     rv = fileURL->GetFile(getter_AddRefs(file));
     1:     if (NS_SUCCEEDED(rv))
     1:         rv = CallQueryInterface(file, aLocalFile);
     1: 
     1:     return rv;
     1: }
     1: 
     1: nsresult nsWebBrowserPersist::AppendPathToURI(nsIURI *aURI, const nsAString & aPath) const
     1: {
     1:     NS_ENSURE_ARG_POINTER(aURI);
     1: 
     1:     nsCAutoString newPath;
     1:     nsresult rv = aURI->GetPath(newPath);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     // Append a forward slash if necessary
108991:     int32_t len = newPath.Length();
     1:     if (len > 0 && newPath.CharAt(len - 1) != '/')
     1:     {
     1:         newPath.Append('/');
     1:     }
     1: 
     1:     // Store the path back on the URI
     1:     AppendUTF16toUTF8(aPath, newPath);
     1:     aURI->SetPath(newPath);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult nsWebBrowserPersist::SaveURIInternal(
     1:     nsIURI *aURI, nsISupports *aCacheKey, nsIURI *aReferrer,
     1:     nsIInputStream *aPostData, const char *aExtraHeaders,
 79445:     nsIURI *aFile, bool aCalcFileExt)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aURI);
     1:     NS_ENSURE_ARG_POINTER(aFile);
     1: 
     1:     nsresult rv = NS_OK;
     1:     
     1:     mURI = aURI;
     1: 
     1:     nsLoadFlags loadFlags = nsIRequest::LOAD_NORMAL;
     1:     if (mPersistFlags & PERSIST_FLAGS_BYPASS_CACHE)
     1:     {
     1:         loadFlags |= nsIRequest::LOAD_BYPASS_CACHE;
     1:     }
     1:     else if (mPersistFlags & PERSIST_FLAGS_FROM_CACHE)
     1:     {
     1:         loadFlags |= nsIRequest::LOAD_FROM_CACHE;
     1:     }
     1: 
     1:     // Extract the cache key
     1:     nsCOMPtr<nsISupports> cacheKey;
     1:     if (aCacheKey)
     1:     {
     1:         // Test if the cache key is actually a web page descriptor (docshell)
 25235:         // or session history entry.
 25235:         nsCOMPtr<nsISHEntry> shEntry = do_QueryInterface(aCacheKey);
 25235:         if (!shEntry)
 25235:         {
 25235:             nsCOMPtr<nsIWebPageDescriptor> webPageDescriptor =
 25235:                 do_QueryInterface(aCacheKey);
     1:             if (webPageDescriptor)
     1:             {
     1:                 nsCOMPtr<nsISupports> currentDescriptor;
     1:                 webPageDescriptor->GetCurrentDescriptor(getter_AddRefs(currentDescriptor));
 25235:                 shEntry = do_QueryInterface(currentDescriptor);
 25235:             }
 25235:         }
 25235: 
     1:         if (shEntry)
     1:         {
     1:             shEntry->GetCacheKey(getter_AddRefs(cacheKey));
     1:         }
     1:         else
     1:         {
     1:             // Assume a plain cache key
     1:             cacheKey = aCacheKey;
     1:         }
     1:     }
     1: 
     1:     // Open a channel to the URI
     1:     nsCOMPtr<nsIChannel> inputChannel;
     1:     rv = NS_NewChannel(getter_AddRefs(inputChannel), aURI,
106838:             nullptr, nullptr, static_cast<nsIInterfaceRequestor *>(this),
     1:             loadFlags);
     1:     
106838:     if (NS_FAILED(rv) || inputChannel == nullptr)
     1:     {
     1:         EndDownload(NS_ERROR_FAILURE);
     1:         return NS_ERROR_FAILURE;
     1:     }
     1:     
     1:     // Disable content conversion
     1:     if (mPersistFlags & PERSIST_FLAGS_NO_CONVERSION)
     1:     {
     1:         nsCOMPtr<nsIEncodedChannel> encodedChannel(do_QueryInterface(inputChannel));
     1:         if (encodedChannel)
     1:         {
 80486:             encodedChannel->SetApplyConversion(false);
     1:         }
     1:     }
     1: 
 29288:     if (mPersistFlags & PERSIST_FLAGS_FORCE_ALLOW_COOKIES) 
 29288:     {
 29288:         nsCOMPtr<nsIHttpChannelInternal> httpChannelInternal =
 29288:                 do_QueryInterface(inputChannel);
 29288:         if (httpChannelInternal)
 80486:             httpChannelInternal->SetForceAllowThirdPartyCookie(true);
 29288:     }
 29288: 
     1:     // Set the referrer, post data and headers if any
     1:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(inputChannel));
     1:     if (httpChannel)
     1:     {
     1:         // Referrer
     1:         if (aReferrer)
     1:         {
     1:             httpChannel->SetReferrer(aReferrer);
     1:         }
     1: 
     1:         // Post data
     1:         if (aPostData)
     1:         {
     1:             nsCOMPtr<nsISeekableStream> stream(do_QueryInterface(aPostData));
     1:             if (stream)
     1:             {
     1:                 // Rewind the postdata stream
     1:                 stream->Seek(nsISeekableStream::NS_SEEK_SET, 0);
     1:                 nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(httpChannel));
     1:                 NS_ASSERTION(uploadChannel, "http must support nsIUploadChannel");
     1:                 // Attach the postdata to the http channel
     1:                 uploadChannel->SetUploadStream(aPostData, EmptyCString(), -1);
     1:             }
     1:         }
     1: 
     1:         // Cache key
     1:         nsCOMPtr<nsICachingChannel> cacheChannel(do_QueryInterface(httpChannel));
     1:         if (cacheChannel && cacheKey)
     1:         {
     1:             cacheChannel->SetCacheKey(cacheKey);
     1:         }
     1: 
     1:         // Headers
     1:         if (aExtraHeaders)
     1:         {
     1:             nsCAutoString oneHeader;
     1:             nsCAutoString headerName;
     1:             nsCAutoString headerValue;
108991:             int32_t crlf = 0;
108991:             int32_t colon = 0;
     1:             const char *kWhitespace = "\b\t\r\n ";
     1:             nsCAutoString extraHeaders(aExtraHeaders);
 80486:             while (true)
 80486:             {
 80486:                 crlf = extraHeaders.Find("\r\n", true);
     1:                 if (crlf == -1)
     1:                     break;
     1:                 extraHeaders.Mid(oneHeader, 0, crlf);
     1:                 extraHeaders.Cut(0, crlf + 2);
     1:                 colon = oneHeader.Find(":");
     1:                 if (colon == -1)
     1:                     break; // Should have a colon
     1:                 oneHeader.Left(headerName, colon);
     1:                 colon++;
     1:                 oneHeader.Mid(headerValue, colon, oneHeader.Length() - colon);
     1:                 headerName.Trim(kWhitespace);
     1:                 headerValue.Trim(kWhitespace);
     1:                 // Add the header (merging if required)
 80486:                 rv = httpChannel->SetRequestHeader(headerName, headerValue, true);
     1:                 if (NS_FAILED(rv))
     1:                 {
     1:                     EndDownload(NS_ERROR_FAILURE);
     1:                     return NS_ERROR_FAILURE;
     1:                 }
     1:             }
     1:         }
     1:     }
     1:     return SaveChannelInternal(inputChannel, aFile, aCalcFileExt);
     1: }
     1: 
     1: nsresult nsWebBrowserPersist::SaveChannelInternal(
 79445:     nsIChannel *aChannel, nsIURI *aFile, bool aCalcFileExt)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aChannel);
     1:     NS_ENSURE_ARG_POINTER(aFile);
     1: 
 39409:     // The default behaviour of SaveChannelInternal is to download the source
 39409:     // into a storage stream and upload that to the target. MakeOutputStream
 39409:     // special-cases a file target and creates a file output stream directly.
 39409:     // We want to special-case a file source and create a file input stream,
 39409:     // but we don't need to do this in the case of a file target.
 39409:     nsCOMPtr<nsIFileChannel> fc(do_QueryInterface(aChannel));
 39409:     nsCOMPtr<nsIFileURL> fu(do_QueryInterface(aFile));
 39409:     if (fc && !fu) {
 39409:         nsCOMPtr<nsIInputStream> fileInputStream, bufferedInputStream;
 39409:         nsresult rv = aChannel->Open(getter_AddRefs(fileInputStream));
 39409:         NS_ENSURE_SUCCESS(rv, rv);
 39409:         rv = NS_NewBufferedInputStream(getter_AddRefs(bufferedInputStream),
 39409:                                        fileInputStream, BUFFERED_OUTPUT_SIZE);
 39409:         NS_ENSURE_SUCCESS(rv, rv);
 39409:         nsCAutoString contentType;
 39409:         aChannel->GetContentType(contentType);
 39409:         return StartUpload(bufferedInputStream, aFile, contentType);
 39409:     }
 39409: 
     1:     // Read from the input channel
106838:     nsresult rv = aChannel->AsyncOpen(this, nullptr);
     1:     if (rv == NS_ERROR_NO_CONTENT)
     1:     {
     1:         // Assume this is a protocol such as mailto: which does not feed out
     1:         // data and just ignore it.
     1:         return NS_SUCCESS_DONT_FIXUP;
     1:     }
 39409: 
 39409:     if (NS_FAILED(rv))
     1:     {
     1:         // Opening failed, but do we care?
     1:         if (mPersistFlags & PERSIST_FLAGS_FAIL_ON_BROKEN_LINKS)
     1:         {
 80486:             SendErrorStatusChange(true, rv, aChannel, aFile);
     1:             EndDownload(NS_ERROR_FAILURE);
     1:             return NS_ERROR_FAILURE;
     1:         }
     1:         return NS_SUCCESS_DONT_FIXUP;
     1:     }
 39409: 
     1:     // Add the output transport to the output map with the channel as the key
     1:     nsCOMPtr<nsISupports> keyPtr = do_QueryInterface(aChannel);
     1:     nsISupportsKey key(keyPtr);
     1:     mOutputMap.Put(&key, new OutputData(aFile, mURI, aCalcFileExt));
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::GetExtensionForContentType(const PRUnichar *aContentType, PRUnichar **aExt)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aContentType);
     1:     NS_ENSURE_ARG_POINTER(aExt);
     1: 
106838:     *aExt = nullptr;
     1: 
     1:     nsresult rv;
     1:     if (!mMIMEService)
     1:     {
     1:         mMIMEService = do_GetService(NS_MIMESERVICE_CONTRACTID, &rv);
     1:         NS_ENSURE_TRUE(mMIMEService, NS_ERROR_FAILURE);
     1:     }
     1: 
     1:     nsCOMPtr<nsIMIMEInfo> mimeInfo;
     1:     nsCAutoString contentType;
     1:     contentType.AssignWithConversion(aContentType);
     1:     nsCAutoString ext;
     1:     rv = mMIMEService->GetPrimaryExtension(contentType, EmptyCString(), ext);
     1:     if (NS_SUCCEEDED(rv))
     1:     {
     1:         *aExt = UTF8ToNewUnicode(ext);
     1:         NS_ENSURE_TRUE(*aExt, NS_ERROR_OUT_OF_MEMORY);
     1:         return NS_OK;
     1:     }
     1: 
     1:     return NS_ERROR_FAILURE;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::GetDocumentExtension(nsIDOMDocument *aDocument, PRUnichar **aExt)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aDocument);
     1:     NS_ENSURE_ARG_POINTER(aExt);
     1: 
     1:     nsXPIDLString contentType;
106838:     nsresult rv = GetDocEncoderContentType(aDocument, nullptr, getter_Copies(contentType));
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1:     return GetExtensionForContentType(contentType.get(), aExt);
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::GetDocEncoderContentType(nsIDOMDocument *aDocument, const PRUnichar *aContentType, PRUnichar **aRealContentType)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aDocument);
     1:     NS_ENSURE_ARG_POINTER(aRealContentType);
     1: 
106838:     *aRealContentType = nullptr;
     1: 
     1:     nsAutoString defaultContentType(NS_LITERAL_STRING("text/html"));
     1: 
     1:     // Get the desired content type for the document, either by using the one
     1:     // supplied or from the document itself.
     1: 
     1:     nsAutoString contentType;
     1:     if (aContentType)
     1:     {
     1:         contentType.Assign(aContentType);
     1:     }
     1:     else
     1:     {
     1:         // Get the content type from the document
     1:         nsAutoString type;
 70983:         if (NS_SUCCEEDED(aDocument->GetContentType(type)) && !type.IsEmpty())
     1:             contentType.Assign(type);
     1:     }
     1: 
     1:     // Check that an encoder actually exists for the desired output type. The
     1:     // following content types will usually yield an encoder.
     1:     //
     1:     //   text/xml
     1:     //   application/xml
     1:     //   application/xhtml+xml
     1:     //   image/svg+xml
     1:     //   text/html
     1:     //   text/plain
     1: 
     1:     if (!contentType.IsEmpty() &&
     1:         !contentType.Equals(defaultContentType, nsCaseInsensitiveStringComparator()))
     1:     {
     1:         // Check if there is an encoder for the desired content type
     1:         nsCAutoString contractID(NS_DOC_ENCODER_CONTRACTID_BASE);
  5237:         AppendUTF16toUTF8(contentType, contractID);
     1: 
     1:         nsCOMPtr<nsIComponentRegistrar> registrar;
     1:         NS_GetComponentRegistrar(getter_AddRefs(registrar));
     1:         if (registrar)
     1:         {
 79445:             bool result;
     1:             nsresult rv = registrar->IsContractIDRegistered(contractID.get(), &result);
     1:             if (NS_SUCCEEDED(rv) && result)
     1:             {
     1:                 *aRealContentType = ToNewUnicode(contentType);
     1:             }
     1:         }
     1:     }
     1: 
     1:     // Use the default if no encoder exists for the desired one
     1:     if (!*aRealContentType)
     1:     {
     1:         *aRealContentType = ToNewUnicode(defaultContentType);
     1:     }
     1:     
     1:     NS_ENSURE_TRUE(*aRealContentType, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult nsWebBrowserPersist::SaveDocumentInternal(
     1:     nsIDOMDocument *aDocument, nsIURI *aFile, nsIURI *aDataPath)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aDocument);
     1:     NS_ENSURE_ARG_POINTER(aFile);
     1: 
     1:     // See if we can get the local file representation of this URI
101111:     nsCOMPtr<nsIFile> localFile;
     1:     nsresult rv = GetLocalFileFromURI(aFile, getter_AddRefs(localFile));
     1: 
101111:     nsCOMPtr<nsIFile> localDataPath;
     1:     if (NS_SUCCEEDED(rv) && aDataPath)
     1:     {
     1:         // See if we can get the local file representation of this URI
     1:         rv = GetLocalFileFromURI(aDataPath, getter_AddRefs(localDataPath));
     1:         NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMNode> docAsNode = do_QueryInterface(aDocument);
     1: 
     1:     // Persist the main document
     1:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(aDocument));
109973:     if (!doc) {
109973:         return NS_ERROR_UNEXPECTED;
109973:     }
     1:     mURI = doc->GetDocumentURI();
     1: 
     1:     nsCOMPtr<nsIURI> oldBaseURI = mCurrentBaseURI;
     1:     nsCAutoString oldCharset(mCurrentCharset);
     1: 
     1:     // Store the base URI and the charset
     1:     mCurrentBaseURI = doc->GetBaseURI();
     1:     mCurrentCharset = doc->GetDocumentCharacterSet();
     1: 
     1:     // Does the caller want to fixup the referenced URIs and save those too?
     1:     if (aDataPath)
     1:     {
     1:         // Basic steps are these.
     1:         //
     1:         // 1. Iterate through the document (and subdocuments) building a list
     1:         //    of unique URIs.
     1:         // 2. For each URI create an OutputData entry and open a channel to save
     1:         //    it. As each URI is saved, discover the mime type and fix up the
     1:         //    local filename with the correct extension.
     1:         // 3. Store the document in a list and wait for URI persistence to finish
     1:         // 4. After URI persistence completes save the list of documents,
     1:         //    fixing it up as it goes out to file.
     1: 
     1:         nsCOMPtr<nsIURI> oldDataPath = mCurrentDataPath;
 79445:         bool oldDataPathIsRelative = mCurrentDataPathIsRelative;
     1:         nsCString oldCurrentRelativePathToData = mCurrentRelativePathToData;
108991:         uint32_t oldThingsToPersist = mCurrentThingsToPersist;
     1: 
 80486:         mCurrentDataPathIsRelative = false;
     1:         mCurrentDataPath = aDataPath;
     1:         mCurrentRelativePathToData = "";
     1:         mCurrentThingsToPersist = 0;
     1: 
     1:         // Determine if the specified data path is relative to the
     1:         // specified file, (e.g. c:\docs\htmldata is relative to
     1:         // c:\docs\myfile.htm, but not to d:\foo\data.
     1: 
     1:         // Starting with the data dir work back through its parents
     1:         // checking if one of them matches the base directory.
     1: 
     1:         if (localDataPath && localFile)
     1:         {
     1:             nsCOMPtr<nsIFile> baseDir;
     1:             localFile->GetParent(getter_AddRefs(baseDir));
     1: 
     1:             nsCAutoString relativePathToData;
     1:             nsCOMPtr<nsIFile> dataDirParent;
     1:             dataDirParent = localDataPath;
     1:             while (dataDirParent)
     1:             {
 79445:                 bool sameDir = false;
     1:                 dataDirParent->Equals(baseDir, &sameDir);
     1:                 if (sameDir)
     1:                 {
     1:                     mCurrentRelativePathToData = relativePathToData;
 80486:                     mCurrentDataPathIsRelative = true;
     1:                     break;
     1:                 }
     1: 
 12174:                 nsAutoString dirName;
 12174:                 dataDirParent->GetLeafName(dirName);
     1: 
     1:                 nsCAutoString newRelativePathToData;
 12174:                 newRelativePathToData = NS_ConvertUTF16toUTF8(dirName)
     1:                                       + NS_LITERAL_CSTRING("/")
     1:                                       + relativePathToData;
     1:                 relativePathToData = newRelativePathToData;
     1: 
     1:                 nsCOMPtr<nsIFile> newDataDirParent;
     1:                 rv = dataDirParent->GetParent(getter_AddRefs(newDataDirParent));
     1:                 dataDirParent = newDataDirParent;
     1:             }
     1:         }
     1:         else
     1:         {
     1:             // generate a relative path if possible
     1:             nsCOMPtr<nsIURL> pathToBaseURL(do_QueryInterface(aFile));
     1:             if (pathToBaseURL)
     1:             {
     1:                 nsCAutoString relativePath;  // nsACString
     1:                 if (NS_SUCCEEDED(pathToBaseURL->GetRelativeSpec(aDataPath, relativePath)))
     1:                 {
 80486:                     mCurrentDataPathIsRelative = true;
     1:                     mCurrentRelativePathToData = relativePath;
     1:                 }
     1:             }
     1:         }
     1: 
     1:         // Store the document in a list so when URI persistence is done and the
     1:         // filenames of saved URIs are known, the documents can be fixed up and
     1:         // saved
     1: 
     1:         DocData *docData = new DocData;
     1:         docData->mBaseURI = mCurrentBaseURI;
     1:         docData->mCharset = mCurrentCharset;
     1:         docData->mDocument = aDocument;
     1:         docData->mFile = aFile;
     1:         docData->mRelativePathToData = mCurrentRelativePathToData;
     1:         docData->mDataPath = mCurrentDataPath;
     1:         docData->mDataPathIsRelative = mCurrentDataPathIsRelative;
     1:         mDocList.AppendElement(docData);
     1: 
     1:         // Walk the DOM gathering a list of externally referenced URIs in the uri map
     1:         nsCOMPtr<nsIDOMTreeWalker> walker;
 69899:         rv = aDocument->CreateTreeWalker(docAsNode, 
     1:             nsIDOMNodeFilter::SHOW_ELEMENT |
     1:                 nsIDOMNodeFilter::SHOW_DOCUMENT |
     1:                 nsIDOMNodeFilter::SHOW_PROCESSING_INSTRUCTION,
106838:             nullptr, true, getter_AddRefs(walker));
     1:         NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:         nsCOMPtr<nsIDOMNode> currentNode;
     1:         walker->GetCurrentNode(getter_AddRefs(currentNode));
     1:         while (currentNode)
     1:         {
     1:             OnWalkDOMNode(currentNode);
     1:             walker->NextNode(getter_AddRefs(currentNode));
     1:         }
     1: 
     1:         // If there are things to persist, create a directory to hold them
     1:         if (mCurrentThingsToPersist > 0)
     1:         {
     1:             if (localDataPath)
     1:             {
 79445:                 bool exists = false;
 79445:                 bool haveDir = false;
     1: 
     1:                 localDataPath->Exists(&exists);
     1:                 if (exists)
     1:                 {
     1:                     localDataPath->IsDirectory(&haveDir);
     1:                 }
     1:                 if (!haveDir)
     1:                 {
101111:                     rv = localDataPath->Create(nsIFile::DIRECTORY_TYPE, 0755);
     1:                     if (NS_SUCCEEDED(rv))
 80486:                         haveDir = true;
     1:                     else
106838:                         SendErrorStatusChange(false, rv, nullptr, aFile);
     1:                 }
     1:                 if (!haveDir)
     1:                 {
     1:                     EndDownload(NS_ERROR_FAILURE);
     1:                     mCurrentBaseURI = oldBaseURI;
     1:                     mCurrentCharset = oldCharset;
     1:                     return NS_ERROR_FAILURE;
     1:                 }
     1:                 if (mPersistFlags & PERSIST_FLAGS_CLEANUP_ON_FAILURE)
     1:                 {
     1:                     // Add to list of things to delete later if all goes wrong
     1:                     CleanupData *cleanupData = new CleanupData;
     1:                     NS_ENSURE_TRUE(cleanupData, NS_ERROR_OUT_OF_MEMORY);
     1:                     cleanupData->mFile = localDataPath;
 80486:                     cleanupData->mIsDirectory = true;
     1:                     mCleanupList.AppendElement(cleanupData);
     1:                 }
     1: #if defined(XP_OS2)
     1:                 // tag the directory with the URI that originated its contents
     1:                 nsCOMPtr<nsILocalFileOS2> localFileOS2 = do_QueryInterface(localDataPath);
     1:                 if (localFileOS2)
     1:                 {
     1:                     nsCAutoString url;
     1:                     mCurrentBaseURI->GetSpec(url);
     1:                     localFileOS2->SetFileSource(url);
     1:                 }
     1: #endif
     1:             }
     1:         }
     1: 
     1:         mCurrentThingsToPersist = oldThingsToPersist;
     1:         mCurrentDataPath = oldDataPath;
     1:         mCurrentDataPathIsRelative = oldDataPathIsRelative;
     1:         mCurrentRelativePathToData = oldCurrentRelativePathToData;
     1:     }
     1:     else
     1:     {
     1:         // Set the document base to ensure relative links still work
     1:         SetDocumentBase(aDocument, mCurrentBaseURI);
     1: 
     1:         // Get the content type to save with
     1:         nsXPIDLString realContentType;
     1:         GetDocEncoderContentType(aDocument,
106838:             !mContentType.IsEmpty() ? mContentType.get() : nullptr,
     1:             getter_Copies(realContentType));
     1: 
     1:         nsCAutoString contentType; contentType.AssignWithConversion(realContentType);
     1:         nsCAutoString charType; // Empty
     1: 
     1:         // Save the document
     1:         rv = SaveDocumentWithFixup(
     1:             aDocument,
106838:             nullptr,  // no dom fixup
     1:             aFile,
     1:             mReplaceExisting,
     1:             contentType,
     1:             charType,
     1:             mEncodingFlags);
     1:         NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1:     }
     1: 
     1:     mCurrentBaseURI = oldBaseURI;
     1:     mCurrentCharset = oldCharset;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult nsWebBrowserPersist::SaveDocuments()
     1: {
     1:     nsresult rv = NS_OK;
     1: 
 80486:     mStartSaving = true;
     1: 
     1:     // Iterate through all queued documents, saving them to file and fixing
     1:     // them up on the way.
     1: 
108991:     uint32_t i;
 25498:     for (i = 0; i < mDocList.Length(); i++)
 25498:     {
 25498:         DocData *docData = mDocList.ElementAt(i);
     1:         if (!docData)
     1:         {
     1:             rv = NS_ERROR_FAILURE;
     1:             break;
     1:         }
     1: 
     1:         mCurrentBaseURI = docData->mBaseURI;
     1:         mCurrentCharset = docData->mCharset;
     1: 
     1:         // Save the document, fixing it up with the new URIs as we do
     1:         
     1:         nsEncoderNodeFixup *nodeFixup;
     1:         nodeFixup = new nsEncoderNodeFixup;
     1:         if (nodeFixup)
     1:             nodeFixup->mWebBrowserPersist = this;
     1: 
     1:         // Get the content type
     1:         nsXPIDLString realContentType;
     1:         GetDocEncoderContentType(docData->mDocument,
106838:             !mContentType.IsEmpty() ? mContentType.get() : nullptr,
     1:             getter_Copies(realContentType));
     1: 
     1:         nsCAutoString contentType; contentType.AssignWithConversion(realContentType.get());
     1:         nsCAutoString charType; // Empty
     1: 
     1:         // Save the document, fixing up the links as it goes out
     1:         rv = SaveDocumentWithFixup(
     1:             docData->mDocument,
     1:             nodeFixup,
     1:             docData->mFile,
     1:             mReplaceExisting,
     1:             contentType,
     1:             charType,
     1:             mEncodingFlags);
     1: 
     1:         if (NS_FAILED(rv))
     1:             break;
     1: 
     1:         // if we're serializing, bail after first iteration of loop
     1:         if (mSerializingOutput)
     1:             break;
     1:     }
     1: 
     1:     // delete, cleanup regardless of errors (bug 132417)
 25498:     for (i = 0; i < mDocList.Length(); i++)
 25498:     {
 25498:         DocData *docData = mDocList.ElementAt(i);
     1:         delete docData;
     1:         if (mSerializingOutput)
     1:         {
     1:             mDocList.RemoveElementAt(i);
     1:             break;
     1:         }
     1:     }
     1: 
     1:     if (!mSerializingOutput)
     1:     {
     1:         mDocList.Clear();
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: void nsWebBrowserPersist::Cleanup()
     1: {
     1:     mURIMap.Enumerate(EnumCleanupURIMap, this);
     1:     mURIMap.Reset();
     1:     mOutputMap.Enumerate(EnumCleanupOutputMap, this);
     1:     mOutputMap.Reset();
     1:     mUploadList.Enumerate(EnumCleanupUploadList, this);
     1:     mUploadList.Reset();
108991:     uint32_t i;
 25498:     for (i = 0; i < mDocList.Length(); i++)
 25498:     {
 25498:         DocData *docData = mDocList.ElementAt(i);
     1:         delete docData;
     1:     }
     1:     mDocList.Clear();
 25498:     for (i = 0; i < mCleanupList.Length(); i++)
 25498:     {
 25498:         CleanupData *cleanupData = mCleanupList.ElementAt(i);
     1:         delete cleanupData;
     1:     }
     1:     mCleanupList.Clear();
     1:     mFilenameList.Clear();
     1: }
     1: 
     1: void nsWebBrowserPersist::CleanupLocalFiles()
     1: {
     1:     // Two passes, the first pass cleans up files, the second pass tests
     1:     // for and then deletes empty directories. Directories that are not
     1:     // empty after the first pass must contain files from something else
     1:     // and are not deleted.
     1:     int pass;
     1:     for (pass = 0; pass < 2; pass++)
     1:     {
108991:         uint32_t i;
 25498:         for (i = 0; i < mCleanupList.Length(); i++)
 25498:         {
 25498:             CleanupData *cleanupData = mCleanupList.ElementAt(i);
101111:             nsCOMPtr<nsIFile> file = cleanupData->mFile;
     1: 
     1:             // Test if the dir / file exists (something in an earlier loop
     1:             // may have already removed it)
 79445:             bool exists = false;
     1:             file->Exists(&exists);
     1:             if (!exists)
     1:                 continue;
     1: 
     1:             // Test if the file has changed in between creation and deletion
     1:             // in some way that means it should be ignored
 79445:             bool isDirectory = false;
     1:             file->IsDirectory(&isDirectory);
     1:             if (isDirectory != cleanupData->mIsDirectory)
     1:                 continue; // A file has become a dir or vice versa !
     1: 
     1:             if (pass == 0 && !isDirectory)
     1:             {
 80486:                 file->Remove(false);
     1:             }
     1:             else if (pass == 1 && isDirectory) // Directory
     1:             {
     1:                 // Directories are more complicated. Enumerate through
     1:                 // children looking for files. Any files created by the
     1:                 // persist object would have been deleted by the first
     1:                 // pass so if there are any there at this stage, the dir
     1:                 // cannot be deleted because it has someone else's files
     1:                 // in it. Empty child dirs are deleted but they must be
     1:                 // recursed through to ensure they are actually empty.
     1: 
 79445:                 bool isEmptyDirectory = true;
 27300:                 nsCOMArray<nsISimpleEnumerator> dirStack;
108991:                 int32_t stackSize = 0;
     1: 
     1:                 // Push the top level enum onto the stack
     1:                 nsCOMPtr<nsISimpleEnumerator> pos;
     1:                 if (NS_SUCCEEDED(file->GetDirectoryEntries(getter_AddRefs(pos))))
 27300:                     dirStack.AppendObject(pos);
 27300: 
 27300:                 while (isEmptyDirectory && (stackSize = dirStack.Count()))
     1:                 {
     1:                     // Pop the last element
     1:                     nsCOMPtr<nsISimpleEnumerator> curPos;
 27300:                     curPos = dirStack[stackSize-1];
 27300:                     dirStack.RemoveObjectAt(stackSize - 1);
     1:                     
     1:                     // Test if the enumerator has any more files in it
 79445:                     bool hasMoreElements = false;
     1:                     curPos->HasMoreElements(&hasMoreElements);
     1:                     if (!hasMoreElements)
     1:                     {
     1:                         continue;
     1:                     }
     1: 
     1:                     // Child files automatically make this code drop out,
     1:                     // while child dirs keep the loop going.
     1:                     nsCOMPtr<nsISupports> child;
     1:                     curPos->GetNext(getter_AddRefs(child));
     1:                     NS_ASSERTION(child, "No child element, but hasMoreElements says otherwise");
     1:                     if (!child)
     1:                         continue;
101111:                     nsCOMPtr<nsIFile> childAsFile = do_QueryInterface(child);
     1:                     NS_ASSERTION(childAsFile, "This should be a file but isn't");
     1: 
 79445:                     bool childIsSymlink = false;
     1:                     childAsFile->IsSymlink(&childIsSymlink);
 79445:                     bool childIsDir = false;
     1:                     childAsFile->IsDirectory(&childIsDir);                           
     1:                     if (!childIsDir || childIsSymlink)
     1:                     {
     1:                         // Some kind of file or symlink which means dir
     1:                         // is not empty so just drop out.
 80486:                         isEmptyDirectory = false;
     1:                         break;
     1:                     }
     1:                     // Push parent enumerator followed by child enumerator
     1:                     nsCOMPtr<nsISimpleEnumerator> childPos;
     1:                     childAsFile->GetDirectoryEntries(getter_AddRefs(childPos));
 27300:                     dirStack.AppendObject(curPos);
     1:                     if (childPos)
 27300:                         dirStack.AppendObject(childPos);
     1: 
     1:                 }
     1:                 dirStack.Clear();
     1: 
     1:                 // If after all that walking the dir is deemed empty, delete it
     1:                 if (isEmptyDirectory)
     1:                 {
 80486:                     file->Remove(true);
     1:                 }
     1:             }
     1:         }
     1:     }
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::CalculateUniqueFilename(nsIURI *aURI)
     1: {
     1:     nsCOMPtr<nsIURL> url(do_QueryInterface(aURI));
     1:     NS_ENSURE_TRUE(url, NS_ERROR_FAILURE);
     1: 
 79445:     bool nameHasChanged = false;
     1:     nsresult rv;
     1: 
     1:     // Get the old filename
     1:     nsCAutoString filename;
     1:     rv = url->GetFileName(filename);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1:     nsCAutoString directory;
     1:     rv = url->GetDirectory(directory);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     // Split the filename into a base and an extension.
     1:     // e.g. "foo.html" becomes "foo" & ".html"
     1:     //
     1:     // The nsIURL methods GetFileBaseName & GetFileExtension don't
     1:     // preserve the dot whereas this code does to save some effort
     1:     // later when everything is put back together.
108991:     int32_t lastDot = filename.RFind(".");
     1:     nsCAutoString base;
     1:     nsCAutoString ext;
     1:     if (lastDot >= 0)
     1:     {
     1:         filename.Mid(base, 0, lastDot);
     1:         filename.Mid(ext, lastDot, filename.Length() - lastDot); // includes dot
     1:     }
     1:     else
     1:     {
     1:         // filename contains no dot
     1:         base = filename;
     1:     }
     1: 
     1:     // Test if the filename is longer than allowed by the OS
108991:     int32_t needToChop = filename.Length() - kDefaultMaxFilenameLength;
     1:     if (needToChop > 0)
     1:     {
     1:         // Truncate the base first and then the ext if necessary
108991:         if (base.Length() > (uint32_t) needToChop)
     1:         {
     1:             base.Truncate(base.Length() - needToChop);
     1:         }
     1:         else
     1:         {
     1:             needToChop -= base.Length() - 1;
     1:             base.Truncate(1);
108991:             if (ext.Length() > (uint32_t) needToChop)
     1:             {
     1:                 ext.Truncate(ext.Length() - needToChop);
     1:             }
     1:             else
     1:             {
     1:                 ext.Truncate(0);
     1:             }
     1:             // If kDefaultMaxFilenameLength were 1 we'd be in trouble here,
     1:             // but that won't happen because it will be set to a sensible
     1:             // value.
     1:         }
     1: 
     1:         filename.Assign(base);
     1:         filename.Append(ext);
 80486:         nameHasChanged = true;
     1:     }
     1: 
     1:     // Ensure the filename is unique
     1:     // Create a filename if it's empty, or if the filename / datapath is
     1:     // already taken by another URI and create an alternate name.
     1: 
 24317:     if (base.IsEmpty() || !mFilenameList.IsEmpty())
     1:     {
     1:         nsCAutoString tmpPath;
     1:         nsCAutoString tmpBase;
108991:         uint32_t duplicateCounter = 1;
     1:         while (1)
     1:         {
     1:             // Make a file name,
     1:             // Foo become foo_001, foo_002, etc.
     1:             // Empty files become _001, _002 etc.
     1: 
     1:             if (base.IsEmpty() || duplicateCounter > 1)
     1:             {
     1:                 char * tmp = PR_smprintf("_%03d", duplicateCounter);
     1:                 NS_ENSURE_TRUE(tmp, NS_ERROR_OUT_OF_MEMORY);
     1:                 if (filename.Length() < kDefaultMaxFilenameLength - 4)
     1:                 {
     1:                     tmpBase = base;
     1:                 }
     1:                 else
     1:                 {
     1:                     base.Mid(tmpBase, 0, base.Length() - 4);
     1:                 }
     1:                 tmpBase.Append(tmp);
     1:                 PR_smprintf_free(tmp);
     1:             }
     1:             else
     1:             {
     1:                 tmpBase = base;
     1:             }
     1:         
     1:             tmpPath.Assign(directory);
     1:             tmpPath.Append(tmpBase);
     1:             tmpPath.Append(ext);
     1: 
     1:             // Test if the name is a duplicate
 24317:             if (!mFilenameList.Contains(tmpPath))
     1:             {
     1:                 if (!base.Equals(tmpBase))
     1:                 {
     1:                     filename.Assign(tmpBase);
     1:                     filename.Append(ext);
 80486:                     nameHasChanged = true;
     1:                 }
     1:                 break;
     1:             }
     1:             duplicateCounter++;
     1:         }
     1:     }
     1: 
     1:     // Add name to list of those already used
     1:     nsCAutoString newFilepath(directory);
     1:     newFilepath.Append(filename);
 24031:     mFilenameList.AppendElement(newFilepath);
     1: 
     1:     // Update the uri accordingly if the filename actually changed
     1:     if (nameHasChanged)
     1:     {
     1:         // Final sanity test
     1:         if (filename.Length() > kDefaultMaxFilenameLength)
     1:         {
     1:             NS_WARNING("Filename wasn't truncated less than the max file length - how can that be?");
     1:             return NS_ERROR_FAILURE;
     1:         }
     1: 
101111:         nsCOMPtr<nsIFile> localFile;
     1:         GetLocalFileFromURI(aURI, getter_AddRefs(localFile));
     1: 
     1:         if (localFile)
     1:         {
     1:             nsAutoString filenameAsUnichar;
     1:             filenameAsUnichar.AssignWithConversion(filename.get());
     1:             localFile->SetLeafName(filenameAsUnichar);
     1: 
     1:             // Resync the URI with the file after the extension has been appended
     1:             nsresult rv;
     1:             nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(aURI, &rv);
     1:             NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1:             fileURL->SetFile(localFile);  // this should recalculate uri
     1:         }
     1:         else
     1:         {
     1:             url->SetFileName(filename);
     1:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsWebBrowserPersist::MakeFilenameFromURI(nsIURI *aURI, nsString &aFilename)
     1: {
     1:     // Try to get filename from the URI.
     1:     nsAutoString fileName;
     1: 
     1:     // Get a suggested file name from the URL but strip it of characters
     1:     // likely to cause the name to be illegal.
     1: 
     1:     nsCOMPtr<nsIURL> url(do_QueryInterface(aURI));
     1:     if (url)
     1:     {
     1:         nsCAutoString nameFromURL;
     1:         url->GetFileName(nameFromURL);
     1:         if (mPersistFlags & PERSIST_FLAGS_DONT_CHANGE_FILENAMES)
     1:         {
     1:             fileName.AssignWithConversion(NS_UnescapeURL(nameFromURL).get());
     1:             goto end;
     1:         }
     1:         if (!nameFromURL.IsEmpty())
     1:         {
     1:             // Unescape the file name (GetFileName escapes it)
     1:             NS_UnescapeURL(nameFromURL);
108991:             uint32_t nameLength = 0;
     1:             const char *p = nameFromURL.get();
     1:             for (;*p && *p != ';' && *p != '?' && *p != '#' && *p != '.'
     1:                  ;p++)
     1:             {
     1:                 if (nsCRT::IsAsciiAlpha(*p) || nsCRT::IsAsciiDigit(*p)
     1:                     || *p == '.' || *p == '-' ||  *p == '_' || (*p == ' '))
     1:                 {
     1:                     fileName.Append(PRUnichar(*p));
     1:                     if (++nameLength == kDefaultMaxFilenameLength)
     1:                     {
     1:                         // Note:
     1:                         // There is no point going any further since it will be
     1:                         // truncated in CalculateUniqueFilename anyway.
     1:                         // More importantly, certain implementations of
101111:                         // nsIFile (e.g. the Mac impl) might truncate
     1:                         // names in undesirable ways, such as truncating from
     1:                         // the middle, inserting ellipsis and so on.
     1:                         break;
     1:                     }
     1:                 }
     1:             }
     1:         }
     1:     }
     1: 
     1:     // Empty filenames can confuse the local file object later 
     1:     // when it attempts to set the leaf name in CalculateUniqueFilename
     1:     // for duplicates and ends up replacing the parent dir. To avoid
     1:     // the problem, all filenames are made at least one character long.
     1:     if (fileName.IsEmpty())
     1:     {
     1:         fileName.Append(PRUnichar('a')); // 'a' is for arbitrary
     1:     }
     1:  
     1: end:
     1:     aFilename = fileName;
     1:     return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
     1: nsWebBrowserPersist::CalculateAndAppendFileExt(nsIURI *aURI, nsIChannel *aChannel, nsIURI *aOriginalURIWithExtension)
     1: {
     1:     nsresult rv;
     1: 
     1:     if (!mMIMEService)
     1:     {
     1:         mMIMEService = do_GetService(NS_MIMESERVICE_CONTRACTID, &rv);
     1:         NS_ENSURE_TRUE(mMIMEService, NS_ERROR_FAILURE);
     1:     }
     1: 
     1:     nsCAutoString contentType;
     1: 
     1:     // Get the content type from the channel
     1:     aChannel->GetContentType(contentType);
     1: 
     1:     // Get the content type from the MIME service
     1:     if (contentType.IsEmpty())
     1:     {
     1:         nsCOMPtr<nsIURI> uri;
     1:         aChannel->GetOriginalURI(getter_AddRefs(uri));
     1:         mMIMEService->GetTypeFromURI(uri, contentType);
     1:     }
     1: 
     1:     // Append the extension onto the file
     1:     if (!contentType.IsEmpty())
     1:     {
     1:         nsCOMPtr<nsIMIMEInfo> mimeInfo;
     1:         mMIMEService->GetFromTypeAndExtension(
     1:             contentType, EmptyCString(), getter_AddRefs(mimeInfo));
     1: 
101111:         nsCOMPtr<nsIFile> localFile;
     1:         GetLocalFileFromURI(aURI, getter_AddRefs(localFile));
     1: 
     1:         if (mimeInfo)
     1:         {
     1:             nsCOMPtr<nsIURL> url(do_QueryInterface(aURI));
     1:             NS_ENSURE_TRUE(url, NS_ERROR_FAILURE);
     1: 
     1:             nsCAutoString newFileName;
     1:             url->GetFileName(newFileName);
     1: 
     1:             // Test if the current extension is current for the mime type
 79445:             bool hasExtension = false;
108991:             int32_t ext = newFileName.RFind(".");
     1:             if (ext != -1)
     1:             {
     1:                 mimeInfo->ExtensionExists(Substring(newFileName, ext + 1), &hasExtension);
     1:             }
     1: 
     1:             // Append the mime file extension
     1:             nsCAutoString fileExt;
     1:             if (!hasExtension)
     1:             {
     1:                 // Test if previous extension is acceptable
     1:                 nsCOMPtr<nsIURL> oldurl(do_QueryInterface(aOriginalURIWithExtension));
     1:                 NS_ENSURE_TRUE(oldurl, NS_ERROR_FAILURE);
     1:                 oldurl->GetFileExtension(fileExt);
 79445:                 bool useOldExt = false;
     1:                 if (!fileExt.IsEmpty())
     1:                 {
     1:                     mimeInfo->ExtensionExists(fileExt, &useOldExt);
     1:                 }
     1: 
     1:                 // can't use old extension so use primary extension
     1:                 if (!useOldExt)
     1:                 {
     1:                     mimeInfo->GetPrimaryExtension(fileExt);
     1:                 } 
     1: 
     1:                 if (!fileExt.IsEmpty())
     1:                 {
108991:                     uint32_t newLength = newFileName.Length() + fileExt.Length() + 1;
     1:                     if (newLength > kDefaultMaxFilenameLength)
     1:                     {
     1:                         newFileName.Truncate(newFileName.Length() - (newLength - kDefaultMaxFilenameLength));
     1:                     }
     1:                     newFileName.Append(".");
     1:                     newFileName.Append(fileExt);
     1:                 }
     1: 
     1:                 if (localFile)
     1:                 {
 12174:                     localFile->SetLeafName(NS_ConvertUTF8toUTF16(newFileName));
     1: 
     1:                     // Resync the URI with the file after the extension has been appended
     1:                     nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(aURI, &rv);
     1:                     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1:                     fileURL->SetFile(localFile);  // this should recalculate uri
     1:                 }
     1:                 else
     1:                 {
     1:                     url->SetFileName(newFileName);
     1:                 }
     1:             }
     1: 
     1:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::MakeOutputStream(
     1:     nsIURI *aURI, nsIOutputStream **aOutputStream)
     1: {
     1:     nsresult rv;
     1: 
101111:     nsCOMPtr<nsIFile> localFile;
     1:     GetLocalFileFromURI(aURI, getter_AddRefs(localFile));
     1:     if (localFile)
     1:         rv = MakeOutputStreamFromFile(localFile, aOutputStream);
     1:     else
     1:         rv = MakeOutputStreamFromURI(aURI, aOutputStream);
     1: 
     1:     return rv;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::MakeOutputStreamFromFile(
101111:     nsIFile *aFile, nsIOutputStream **aOutputStream)
     1: {
     1:     nsresult rv = NS_OK;
     1: 
     1:     nsCOMPtr<nsIFileOutputStream> fileOutputStream =
     1:         do_CreateInstance(NS_LOCALFILEOUTPUTSTREAM_CONTRACTID, &rv);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     // XXX brade:  get the right flags here!
108991:     int32_t ioFlags = -1;
  3453:     if (mPersistFlags & nsIWebBrowserPersist::PERSIST_FLAGS_APPEND_TO_FILE)
  3453:       ioFlags = PR_APPEND | PR_CREATE_FILE | PR_WRONLY; 
  3453:     rv = fileOutputStream->Init(aFile, ioFlags, -1, 0);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
  9812:     *aOutputStream = NS_BufferOutputStream(fileOutputStream,
  9812:                                            BUFFERED_OUTPUT_SIZE).get();
     1: 
     1:     if (mPersistFlags & PERSIST_FLAGS_CLEANUP_ON_FAILURE)
     1:     {
     1:         // Add to cleanup list in event of failure
     1:         CleanupData *cleanupData = new CleanupData;
  9960:         if (!cleanupData) {
  9960:           NS_RELEASE(*aOutputStream);
  9960:           return NS_ERROR_OUT_OF_MEMORY;
  9960:         }
     1:         cleanupData->mFile = aFile;
 80486:         cleanupData->mIsDirectory = false;
     1:         mCleanupList.AppendElement(cleanupData);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::MakeOutputStreamFromURI(
     1:     nsIURI *aURI, nsIOutputStream  **aOutputStream)
     1: {
108991:     uint32_t segsize = 8192;
108991:     uint32_t maxsize = uint32_t(-1);
     1:     nsCOMPtr<nsIStorageStream> storStream;
     1:     nsresult rv = NS_NewStorageStream(segsize, maxsize, getter_AddRefs(storStream));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     
     1:     NS_ENSURE_SUCCESS(CallQueryInterface(storStream, aOutputStream), NS_ERROR_FAILURE);
     1:     return NS_OK;
     1: }
     1: 
     1: void
     1: nsWebBrowserPersist::EndDownload(nsresult aResult)
     1: {
     1:     // Store the error code in the result if it is an error
     1:     if (NS_SUCCEEDED(mPersistResult) && NS_FAILED(aResult))
     1:     {
     1:         mPersistResult = aResult;
     1:     }
     1: 
     1:     // Do file cleanup if required
     1:     if (NS_FAILED(aResult) && (mPersistFlags & PERSIST_FLAGS_CLEANUP_ON_FAILURE))
     1:     {
     1:         CleanupLocalFiles();
     1:     }
     1: 
     1:     // Cleanup the channels
 80486:     mCompleted = true;
     1:     Cleanup();
     1: }
     1: 
     1: /* Hack class to get access to nsISupportsKey's protected mKey member */
     1: class nsMyISupportsKey : public nsISupportsKey
     1: {
     1: public:
     1:     nsMyISupportsKey(nsISupports *key) : nsISupportsKey(key)
     1:     {
     1:     }
     1: 
     1:     nsresult GetISupports(nsISupports **ret)
     1:     {
     1:         *ret = mKey;
     1:         NS_IF_ADDREF(mKey);
     1:         return NS_OK;
     1:     }
     1: };
     1: 
 15594: struct NS_STACK_CLASS FixRedirectData
     1: {
     1:     nsCOMPtr<nsIChannel> mNewChannel;
     1:     nsCOMPtr<nsIURI> mOriginalURI;
     1:     nsISupportsKey *mMatchingKey;
     1: };
     1: 
     1: nsresult
     1: nsWebBrowserPersist::FixRedirectedChannelEntry(nsIChannel *aNewChannel)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aNewChannel);
     1:     nsCOMPtr<nsIURI> originalURI;
     1: 
     1:     // Enumerate through existing open channels looking for one with
     1:     // a URI matching the one specified.
     1: 
     1:     FixRedirectData data;
106838:     data.mMatchingKey = nullptr;
     1:     data.mNewChannel = aNewChannel;
     1:     data.mNewChannel->GetOriginalURI(getter_AddRefs(data.mOriginalURI));
     1:     mOutputMap.Enumerate(EnumFixRedirect, (void *) &data);
     1: 
     1:     // If a match is found, remove the data entry with the old channel key
     1:     // and re-add it with the new channel key.
     1: 
     1:     if (data.mMatchingKey)
     1:     {
     1:         OutputData *outputData = (OutputData *) mOutputMap.Get(data.mMatchingKey);
     1:         NS_ENSURE_TRUE(outputData, NS_ERROR_FAILURE);
     1:         mOutputMap.Remove(data.mMatchingKey);
     1: 
     1:         // Store data again with new channel unless told to ignore redirects
     1:         if (!(mPersistFlags & PERSIST_FLAGS_IGNORE_REDIRECTED_DATA))
     1:         {
     1:             nsCOMPtr<nsISupports> keyPtr = do_QueryInterface(aNewChannel);
     1:             nsISupportsKey key(keyPtr);
     1:             mOutputMap.Put(&key, outputData);
     1:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
 79445: bool
     1: nsWebBrowserPersist::EnumFixRedirect(nsHashKey *aKey, void *aData, void* closure)
     1: {
     1:     FixRedirectData *data = (FixRedirectData *) closure;
     1: 
     1:     nsCOMPtr<nsISupports> keyPtr;
     1:     ((nsMyISupportsKey *) aKey)->GetISupports(getter_AddRefs(keyPtr));
     1: 
     1:     nsCOMPtr<nsIChannel> thisChannel = do_QueryInterface(keyPtr);
     1:     nsCOMPtr<nsIURI> thisURI;
     1: 
     1:     thisChannel->GetOriginalURI(getter_AddRefs(thisURI));
     1: 
     1:     // Compare this channel's URI to the one passed in.
 79445:     bool matchingURI = false;
     1:     thisURI->Equals(data->mOriginalURI, &matchingURI);
     1:     if (matchingURI)
     1:     {
     1:         data->mMatchingKey = (nsISupportsKey *) aKey;
 80486:         return false; // Stop enumerating
 80486:     }
 80486: 
 80486:     return true;
     1: }
     1: 
     1: void
     1: nsWebBrowserPersist::CalcTotalProgress()
     1: {
     1:     mTotalCurrentProgress = 0;
     1:     mTotalMaxProgress = 0;
     1: 
     1:     if (mOutputMap.Count() > 0)
     1:     {
     1:         // Total up the progress of each output stream
     1:         mOutputMap.Enumerate(EnumCalcProgress, this);
     1:     }
     1: 
     1:     if (mUploadList.Count() > 0)
     1:     {
     1:         // Total up the progress of each upload
     1:         mUploadList.Enumerate(EnumCalcUploadProgress, this);
     1:     }
     1: 
     1:     // XXX this code seems pretty bogus and pointless
     1:     if (mTotalCurrentProgress == LL_ZERO && mTotalMaxProgress == LL_ZERO)
     1:     {
     1:         // No output streams so we must be complete
     1:         mTotalCurrentProgress = 10000;
     1:         mTotalMaxProgress = 10000;
     1:     }
     1: }
     1: 
 79445: bool
     1: nsWebBrowserPersist::EnumCalcProgress(nsHashKey *aKey, void *aData, void* closure)
     1: {
     1:     nsWebBrowserPersist *pthis = (nsWebBrowserPersist *) closure;
     1:     OutputData *data = (OutputData *) aData;
     1: 
     1:     // only count toward total progress if destination file is local
     1:     nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(data->mFile);
     1:     if (fileURL)
     1:     {
     1:         pthis->mTotalCurrentProgress += data->mSelfProgress;
     1:         pthis->mTotalMaxProgress += data->mSelfProgressMax;
     1:     }
 80486:     return true;
     1: }
     1: 
 79445: bool
     1: nsWebBrowserPersist::EnumCalcUploadProgress(nsHashKey *aKey, void *aData, void* closure)
     1: {
     1:     if (aData && closure)
     1:     {
     1:         nsWebBrowserPersist *pthis = (nsWebBrowserPersist *) closure;
     1:         UploadData *data = (UploadData *) aData;
     1:         pthis->mTotalCurrentProgress += data->mSelfProgress;
     1:         pthis->mTotalMaxProgress += data->mSelfProgressMax;
     1:     }
 80486:     return true;
     1: }
     1: 
 79445: bool
     1: nsWebBrowserPersist::EnumCountURIsToPersist(nsHashKey *aKey, void *aData, void* closure)
     1: {
     1:     URIData *data = (URIData *) aData;
108991:     uint32_t *count = (uint32_t *) closure;
     1:     if (data->mNeedsPersisting && !data->mSaved)
     1:     {
     1:         (*count)++;
     1:     }
 80486:     return true;
     1: }
     1: 
 79445: bool
     1: nsWebBrowserPersist::EnumPersistURIs(nsHashKey *aKey, void *aData, void* closure)
     1: {
     1:     URIData *data = (URIData *) aData;
     1:     if (!data->mNeedsPersisting || data->mSaved)
     1:     {
 80486:         return true;
     1:     }
     1: 
     1:     nsWebBrowserPersist *pthis = (nsWebBrowserPersist *) closure;
     1:     nsresult rv;
     1: 
     1:     // Create a URI from the key
     1:     nsCOMPtr<nsIURI> uri;
     1:     rv = NS_NewURI(getter_AddRefs(uri), 
     1:                    nsDependentCString(((nsCStringKey *) aKey)->GetString(),
     1:                                       ((nsCStringKey *) aKey)->GetStringLength()),
     1:                    data->mCharset.get());
 80486:     NS_ENSURE_SUCCESS(rv, false);
     1: 
     1:     // Make a URI to save the data to
     1:     nsCOMPtr<nsIURI> fileAsURI;
     1:     rv = data->mDataPath->Clone(getter_AddRefs(fileAsURI));
 80486:     NS_ENSURE_SUCCESS(rv, false);
     1:     rv = pthis->AppendPathToURI(fileAsURI, data->mFilename);
 80486:     NS_ENSURE_SUCCESS(rv, false);
 80486: 
106838:     rv = pthis->SaveURIInternal(uri, nullptr, nullptr, nullptr, nullptr, fileAsURI, true);
     1:     // if SaveURIInternal fails, then it will have called EndDownload,
     1:     // which means that |aData| is no longer valid memory.  we MUST bail.
 80486:     NS_ENSURE_SUCCESS(rv, false);
     1: 
     1:     if (rv == NS_OK)
     1:     {
     1:         // Store the actual object because once it's persisted this
     1:         // will be fixed up with the right file extension.
     1: 
     1:         data->mFile = fileAsURI;
 80486:         data->mSaved = true;
     1:     }
     1:     else
     1:     {
 80486:         data->mNeedsFixup = false;
     1:     }
     1: 
     1:     if (pthis->mSerializingOutput)
 80486:         return false;
 80486: 
 80486:     return true;
     1: }
     1: 
 79445: bool
     1: nsWebBrowserPersist::EnumCleanupOutputMap(nsHashKey *aKey, void *aData, void* closure)
     1: {
     1:     nsCOMPtr<nsISupports> keyPtr;
     1:     ((nsMyISupportsKey *) aKey)->GetISupports(getter_AddRefs(keyPtr));
     1:     nsCOMPtr<nsIChannel> channel = do_QueryInterface(keyPtr);
     1:     if (channel)
     1:     {
     1:         channel->Cancel(NS_BINDING_ABORTED);
     1:     }
     1:     OutputData *data = (OutputData *) aData;
     1:     delete data;
 80486:     return true;
     1: }
     1: 
     1: 
 79445: bool
     1: nsWebBrowserPersist::EnumCleanupURIMap(nsHashKey *aKey, void *aData, void* closure)
     1: {
     1:     URIData *data = (URIData *) aData;
     1:     delete data; // Delete data associated with key
 80486:     return true;
     1: }
     1: 
     1: 
 79445: bool
     1: nsWebBrowserPersist::EnumCleanupUploadList(nsHashKey *aKey, void *aData, void* closure)
     1: {
     1:     nsCOMPtr<nsISupports> keyPtr;
     1:     ((nsMyISupportsKey *) aKey)->GetISupports(getter_AddRefs(keyPtr));
     1:     nsCOMPtr<nsIChannel> channel = do_QueryInterface(keyPtr);
     1:     if (channel)
     1:     {
     1:         channel->Cancel(NS_BINDING_ABORTED);
     1:     }
     1:     UploadData *data = (UploadData *) aData;
     1:     delete data; // Delete data associated with key
 80486:     return true;
     1: }
     1: 
     1: nsresult nsWebBrowserPersist::FixupXMLStyleSheetLink(nsIDOMProcessingInstruction *aPI, const nsAString &aHref)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aPI);
     1:     nsresult rv = NS_OK;
     1: 
     1:     nsAutoString data;
     1:     rv = aPI->GetData(data);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     nsAutoString href;
 91106:     nsContentUtils::GetPseudoAttributeValue(data,
 91106:                                             nsGkAtoms::href,
 91106:                                             href);
     1: 
     1:     // Construct and set a new data value for the xml-stylesheet
     1:     if (!aHref.IsEmpty() && !href.IsEmpty())
     1:     {
     1:         nsAutoString alternate;
     1:         nsAutoString charset;
     1:         nsAutoString title;
     1:         nsAutoString type;
     1:         nsAutoString media;
     1: 
 91106:         nsContentUtils::GetPseudoAttributeValue(data,
 91106:                                                 nsGkAtoms::alternate,
 91106:                                                 alternate);
 91106:         nsContentUtils::GetPseudoAttributeValue(data,
 91106:                                                 nsGkAtoms::charset,
 91106:                                                 charset);
 91106:         nsContentUtils::GetPseudoAttributeValue(data,
 91106:                                                 nsGkAtoms::title,
 91106:                                                 title);
 91106:         nsContentUtils::GetPseudoAttributeValue(data,
 91106:                                                 nsGkAtoms::type,
 91106:                                                 type);
 91106:         nsContentUtils::GetPseudoAttributeValue(data,
 91106:                                                 nsGkAtoms::media,
 91106:                                                 media);
     1: 
     1:         NS_NAMED_LITERAL_STRING(kCloseAttr, "\" ");
     1:         nsAutoString newData;
     1:         newData += NS_LITERAL_STRING("href=\"") + aHref + kCloseAttr;
     1:         if (!title.IsEmpty())
     1:         {
     1:             newData += NS_LITERAL_STRING("title=\"") + title + kCloseAttr;
     1:         }
     1:         if (!media.IsEmpty())
     1:         {
     1:             newData += NS_LITERAL_STRING("media=\"") + media + kCloseAttr;
     1:         }
     1:         if (!type.IsEmpty())
     1:         {
     1:             newData += NS_LITERAL_STRING("type=\"") + type + kCloseAttr;
     1:         }
     1:         if (!charset.IsEmpty())
     1:         {
     1:             newData += NS_LITERAL_STRING("charset=\"") + charset + kCloseAttr;
     1:         }
     1:         if (!alternate.IsEmpty())
     1:         {
     1:             newData += NS_LITERAL_STRING("alternate=\"") + alternate + kCloseAttr;
     1:         }
     1:         newData.Truncate(newData.Length() - 1);  // Remove the extra space on the end.
     1:         aPI->SetData(newData);
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: nsresult nsWebBrowserPersist::GetXMLStyleSheetLink(nsIDOMProcessingInstruction *aPI, nsAString &aHref)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aPI);
     1: 
     1:     nsresult rv = NS_OK;
     1:     nsAutoString data;
     1:     rv = aPI->GetData(data);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
 91106:     nsContentUtils::GetPseudoAttributeValue(data, nsGkAtoms::href, aHref);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult nsWebBrowserPersist::OnWalkDOMNode(nsIDOMNode *aNode)
     1: {
     1:     // Fixup xml-stylesheet processing instructions
     1:     nsCOMPtr<nsIDOMProcessingInstruction> nodeAsPI = do_QueryInterface(aNode);
     1:     if (nodeAsPI)
     1:     {
     1:         nsAutoString target;
     1:         nodeAsPI->GetTarget(target);
     1:         if (target.EqualsLiteral("xml-stylesheet"))
     1:         {
     1:             nsAutoString href;
     1:             GetXMLStyleSheetLink(nodeAsPI, href);
     1:             if (!href.IsEmpty())
     1:             {
     1:                 StoreURI(NS_ConvertUTF16toUTF8(href).get());
     1:             }
     1:         }
  2481:         return NS_OK;
     1:     }
     1: 
     1:     // Test the node to see if it's an image, frame, iframe, css, js
     1:     nsCOMPtr<nsIDOMHTMLImageElement> nodeAsImage = do_QueryInterface(aNode);
     1:     if (nodeAsImage)
     1:     {
     1:         StoreURIAttribute(aNode, "src");
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMSVGImageElement> nodeAsSVGImage = do_QueryInterface(aNode);
     1:     if (nodeAsSVGImage)
     1:     {
     1:         StoreURIAttributeNS(aNode, "http://www.w3.org/1999/xlink", "href");
     1:         return NS_OK;
     1:     }
     1: 
 50877: #ifdef MOZ_MEDIA
 50877:     nsCOMPtr<nsIDOMHTMLMediaElement> nodeAsMedia = do_QueryInterface(aNode);
 50877:     if (nodeAsMedia)
 50877:     {
 50877:         StoreURIAttribute(aNode, "src");
 50877:         return NS_OK;
 50877:     }
 50877:     nsCOMPtr<nsIDOMHTMLSourceElement> nodeAsSource = do_QueryInterface(aNode);
 50877:     if (nodeAsSource)
 50877:     {
 50877:         StoreURIAttribute(aNode, "src");
 50877:         return NS_OK;
 50877:     }
 50877: #endif // MOZ_MEDIA
 50877: 
     1:     nsCOMPtr<nsIDOMHTMLBodyElement> nodeAsBody = do_QueryInterface(aNode);
     1:     if (nodeAsBody)
     1:     {
     1:         StoreURIAttribute(aNode, "background");
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLTableElement> nodeAsTable = do_QueryInterface(aNode);
     1:     if (nodeAsTable)
     1:     {
     1:         StoreURIAttribute(aNode, "background");
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLTableRowElement> nodeAsTableRow = do_QueryInterface(aNode);
     1:     if (nodeAsTableRow)
     1:     {
     1:         StoreURIAttribute(aNode, "background");
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLTableCellElement> nodeAsTableCell = do_QueryInterface(aNode);
     1:     if (nodeAsTableCell)
     1:     {
     1:         StoreURIAttribute(aNode, "background");
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLScriptElement> nodeAsScript = do_QueryInterface(aNode);
     1:     if (nodeAsScript)
     1:     {
     1:         StoreURIAttribute(aNode, "src");
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMSVGScriptElement> nodeAsSVGScript = do_QueryInterface(aNode);
     1:     if (nodeAsSVGScript)
     1:     {
     1:         StoreURIAttributeNS(aNode, "http://www.w3.org/1999/xlink", "href");
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLEmbedElement> nodeAsEmbed = do_QueryInterface(aNode);
     1:     if (nodeAsEmbed)
     1:     {
     1:         StoreURIAttribute(aNode, "src");
     1:         return NS_OK;
     1:     }
     1:     
     1:     nsCOMPtr<nsIDOMHTMLObjectElement> nodeAsObject = do_QueryInterface(aNode);
     1:     if (nodeAsObject)
     1:     {
     1:         StoreURIAttribute(aNode, "data");
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLAppletElement> nodeAsApplet = do_QueryInterface(aNode);
     1:     if (nodeAsApplet)
     1:     {
     1:         // For an applet, relative URIs are resolved relative to the
     1:         // codebase (which is resolved relative to the base URI).
     1:         nsCOMPtr<nsIURI> oldBase = mCurrentBaseURI;
     1:         nsAutoString codebase;
     1:         nodeAsApplet->GetCodeBase(codebase);
     1:         if (!codebase.IsEmpty()) {
     1:             nsCOMPtr<nsIURI> baseURI;
     1:             NS_NewURI(getter_AddRefs(baseURI), codebase,
     1:                       mCurrentCharset.get(), mCurrentBaseURI);
     1:             if (baseURI) {
     1:                 mCurrentBaseURI = baseURI;
     1:             }
     1:         }
 15760: 
106838:         URIData *archiveURIData = nullptr;
 80486:         StoreURIAttribute(aNode, "archive", true, &archiveURIData);
 15760:         // We only store 'code' locally if there is no 'archive',
 15760:         // otherwise we assume the archive file(s) contains it (bug 430283).
 15760:         if (!archiveURIData)
     1:             StoreURIAttribute(aNode, "code");
 15760: 
     1:         // restore the base URI we really want to have
     1:         mCurrentBaseURI = oldBase;
     1:         return NS_OK;
     1:     }
     1:     
     1:     nsCOMPtr<nsIDOMHTMLLinkElement> nodeAsLink = do_QueryInterface(aNode);
     1:     if (nodeAsLink)
     1:     {
     1:         // Test if the link has a rel value indicating it to be a stylesheet
     1:         nsAutoString linkRel;
     1:         if (NS_SUCCEEDED(nodeAsLink->GetRel(linkRel)) && !linkRel.IsEmpty())
     1:         {
     1:             nsReadingIterator<PRUnichar> start;
     1:             nsReadingIterator<PRUnichar> end;
     1:             nsReadingIterator<PRUnichar> current;
     1: 
     1:             linkRel.BeginReading(start);
     1:             linkRel.EndReading(end);
     1: 
     1:             // Walk through space delimited string looking for "stylesheet"
     1:             for (current = start; current != end; ++current)
     1:             {
     1:                 // Ignore whitespace
     1:                 if (nsCRT::IsAsciiSpace(*current))
     1:                     continue;
     1: 
     1:                 // Grab the next space delimited word
     1:                 nsReadingIterator<PRUnichar> startWord = current;
     1:                 do {
     1:                     ++current;
     1:                 } while (current != end && !nsCRT::IsAsciiSpace(*current));
     1: 
     1:                 // Store the link for fix up if it says "stylesheet"
     1:                 if (Substring(startWord, current)
     1:                         .LowerCaseEqualsLiteral("stylesheet"))
     1:                 {
     1:                     StoreURIAttribute(aNode, "href");
     1:                     return NS_OK;
     1:                 }
     1:                 if (current == end)
     1:                     break;
     1:             }
     1:         }
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLFrameElement> nodeAsFrame = do_QueryInterface(aNode);
     1:     if (nodeAsFrame)
     1:     {
106838:         URIData *data = nullptr;
 80486:         StoreURIAttribute(aNode, "src", false, &data);
     1:         if (data)
     1:         {
 80486:             data->mIsSubFrame = true;
     1:             // Save the frame content
     1:             nsCOMPtr<nsIDOMDocument> content;
     1:             nodeAsFrame->GetContentDocument(getter_AddRefs(content));
     1:             if (content)
     1:             {
     1:                 SaveSubframeContent(content, data);
     1:             }
     1:         }
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLIFrameElement> nodeAsIFrame = do_QueryInterface(aNode);
     1:     if (nodeAsIFrame && !(mPersistFlags & PERSIST_FLAGS_IGNORE_IFRAMES))
     1:     {
106838:         URIData *data = nullptr;
 80486:         StoreURIAttribute(aNode, "src", false, &data);
     1:         if (data)
     1:         {
 80486:             data->mIsSubFrame = true;
     1:             // Save the frame content
     1:             nsCOMPtr<nsIDOMDocument> content;
     1:             nodeAsIFrame->GetContentDocument(getter_AddRefs(content));
     1:             if (content)
     1:             {
     1:                 SaveSubframeContent(content, data);
     1:             }
     1:         }
     1:         return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLInputElement> nodeAsInput = do_QueryInterface(aNode);
     1:     if (nodeAsInput)
     1:     {
     1:         StoreURIAttribute(aNode, "src");
     1:         return NS_OK;
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::GetNodeToFixup(nsIDOMNode *aNodeIn, nsIDOMNode **aNodeOut)
     1: {
     1:     if (!(mPersistFlags & PERSIST_FLAGS_FIXUP_ORIGINAL_DOM))
     1:     {
 90796:         nsresult rv = aNodeIn->CloneNode(false, 1, aNodeOut);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1:     else
     1:     {
     1:         NS_ADDREF(*aNodeOut = aNodeIn);
     1:     }
     1:     nsCOMPtr<nsIDOMHTMLElement> element(do_QueryInterface(*aNodeOut));
     1:     if (element) {
     1:         // Make sure this is not XHTML
     1:         nsAutoString namespaceURI;
     1:         element->GetNamespaceURI(namespaceURI);
     1:         if (namespaceURI.IsEmpty()) {
     1:             // This is a tag-soup node.  It may have a _base_href attribute
     1:             // stuck on it by the parser, but since we're fixing up all URIs
     1:             // relative to the overall document base that will screw us up.
     1:             // Just remove the _base_href.
     1:             element->RemoveAttribute(NS_LITERAL_STRING("_base_href"));
     1:         }
     1:     }
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
 16267: nsWebBrowserPersist::CloneNodeWithFixedUpAttributes(
 79445:     nsIDOMNode *aNodeIn, bool *aSerializeCloneKids, nsIDOMNode **aNodeOut)
     1: {
     1:     nsresult rv;
106838:     *aNodeOut = nullptr;
 80486:     *aSerializeCloneKids = false;
     1: 
     1:     // Fixup xml-stylesheet processing instructions
     1:     nsCOMPtr<nsIDOMProcessingInstruction> nodeAsPI = do_QueryInterface(aNodeIn);
     1:     if (nodeAsPI)
     1:     {
     1:         nsAutoString target;
     1:         nodeAsPI->GetTarget(target);
     1:         if (target.EqualsLiteral("xml-stylesheet"))
     1:         {
     1:             rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:             if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:             {
     1:                 nsCOMPtr<nsIDOMProcessingInstruction> outNode = do_QueryInterface(*aNodeOut);
     1:                 nsAutoString href;
     1:                 GetXMLStyleSheetLink(nodeAsPI, href);
     1:                 if (!href.IsEmpty())
     1:                 {
     1:                     FixupURI(href);
     1:                     FixupXMLStyleSheetLink(outNode, href);
     1:                 }
     1:             }
     1:         }
     1:     }
     1: 
     1:     // BASE elements are replaced by a comment so relative links are not hosed.
     1: 
     1:     if (!(mPersistFlags & PERSIST_FLAGS_NO_BASE_TAG_MODIFICATIONS))
     1:     {
     1:         nsCOMPtr<nsIDOMHTMLBaseElement> nodeAsBase = do_QueryInterface(aNodeIn);
     1:         if (nodeAsBase)
     1:         {
     1:             nsCOMPtr<nsIDOMDocument> ownerDocument;
     1:             nodeAsBase->GetOwnerDocument(getter_AddRefs(ownerDocument));
     1:             if (ownerDocument)
     1:             {
     1:                 nsAutoString href;
     1:                 nodeAsBase->GetHref(href); // Doesn't matter if this fails
     1:                 nsCOMPtr<nsIDOMComment> comment;
     1:                 nsAutoString commentText; commentText.AssignLiteral(" base ");
     1:                 if (!href.IsEmpty())
     1:                 {
     1:                     commentText += NS_LITERAL_STRING("href=\"") + href + NS_LITERAL_STRING("\" ");
     1:                 }
     1:                 rv = ownerDocument->CreateComment(commentText, getter_AddRefs(comment));
     1:                 if (comment)
     1:                 {
     1:                     return CallQueryInterface(comment, aNodeOut);
     1:                 }
     1:             }
     1:         }
     1:     }
     1: 
     1:     // Fix up href and file links in the elements
     1: 
     1:     nsCOMPtr<nsIDOMHTMLAnchorElement> nodeAsAnchor = do_QueryInterface(aNodeIn);
     1:     if (nodeAsAnchor)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupAnchor(*aNodeOut);
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLAreaElement> nodeAsArea = do_QueryInterface(aNodeIn);
     1:     if (nodeAsArea)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupAnchor(*aNodeOut);
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLBodyElement> nodeAsBody = do_QueryInterface(aNodeIn);
     1:     if (nodeAsBody)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupNodeAttribute(*aNodeOut, "background");
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLTableElement> nodeAsTable = do_QueryInterface(aNodeIn);
     1:     if (nodeAsTable)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupNodeAttribute(*aNodeOut, "background");
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLTableRowElement> nodeAsTableRow = do_QueryInterface(aNodeIn);
     1:     if (nodeAsTableRow)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupNodeAttribute(*aNodeOut, "background");
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLTableCellElement> nodeAsTableCell = do_QueryInterface(aNodeIn);
     1:     if (nodeAsTableCell)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupNodeAttribute(*aNodeOut, "background");
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLImageElement> nodeAsImage = do_QueryInterface(aNodeIn);
     1:     if (nodeAsImage)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             // Disable image loads
     1:             nsCOMPtr<nsIImageLoadingContent> imgCon =
     1:                 do_QueryInterface(*aNodeOut);
     1:             if (imgCon)
 80486:                 imgCon->SetLoadingEnabled(false);
     1: 
     1:             FixupAnchor(*aNodeOut);
     1:             FixupNodeAttribute(*aNodeOut, "src");
     1:         }
     1:         return rv;
     1:     }
     1: 
 50877: #ifdef MOZ_MEDIA
 50877:     nsCOMPtr<nsIDOMHTMLMediaElement> nodeAsMedia = do_QueryInterface(aNodeIn);
 50877:     if (nodeAsMedia)
 50877:     {
 50877:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
 50877:         if (NS_SUCCEEDED(rv) && *aNodeOut)
 50877:         {
 50877:             FixupNodeAttribute(*aNodeOut, "src");
 50877:         }
 50877: 
 50877:         return rv;
 50877:     }
 50877: 
 50877:     nsCOMPtr<nsIDOMHTMLSourceElement> nodeAsSource = do_QueryInterface(aNodeIn);
 50877:     if (nodeAsSource)
 50877:     {
 50877:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
 50877:         if (NS_SUCCEEDED(rv) && *aNodeOut)
 50877:         {
 50877:             FixupNodeAttribute(*aNodeOut, "src");
 50877:         }
 50877: 
 50877:         return rv;
 50877:     }
 50877: #endif // MOZ_MEDIA
 50877: 
     1:     nsCOMPtr<nsIDOMSVGImageElement> nodeAsSVGImage = do_QueryInterface(aNodeIn);
     1:     if (nodeAsSVGImage)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             // Disable image loads
     1:             nsCOMPtr<nsIImageLoadingContent> imgCon =
     1:                 do_QueryInterface(*aNodeOut);
     1:             if (imgCon)
 80486:                 imgCon->SetLoadingEnabled(false);
     1: 
     1:             // FixupAnchor(*aNodeOut);  // XXXjwatt: is this line needed?
     1:             FixupNodeAttributeNS(*aNodeOut, "http://www.w3.org/1999/xlink", "href");
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLScriptElement> nodeAsScript = do_QueryInterface(aNodeIn);
     1:     if (nodeAsScript)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupNodeAttribute(*aNodeOut, "src");
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMSVGScriptElement> nodeAsSVGScript = do_QueryInterface(aNodeIn);
     1:     if (nodeAsSVGScript)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupNodeAttributeNS(*aNodeOut, "http://www.w3.org/1999/xlink", "href");
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLEmbedElement> nodeAsEmbed = do_QueryInterface(aNodeIn);
     1:     if (nodeAsEmbed)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupNodeAttribute(*aNodeOut, "src");
     1:         }
     1:         return rv;
     1:     }
     1:     
     1:     nsCOMPtr<nsIDOMHTMLObjectElement> nodeAsObject = do_QueryInterface(aNodeIn);
     1:     if (nodeAsObject)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupNodeAttribute(*aNodeOut, "data");
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLAppletElement> nodeAsApplet = do_QueryInterface(aNodeIn);
     1:     if (nodeAsApplet)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             nsCOMPtr<nsIDOMHTMLAppletElement> newApplet =
     1:                 do_QueryInterface(*aNodeOut);
     1:             // For an applet, relative URIs are resolved relative to the
     1:             // codebase (which is resolved relative to the base URI).
     1:             nsCOMPtr<nsIURI> oldBase = mCurrentBaseURI;
     1:             nsAutoString codebase;
     1:             nodeAsApplet->GetCodeBase(codebase);
     1:             if (!codebase.IsEmpty()) {
     1:                 nsCOMPtr<nsIURI> baseURI;
     1:                 NS_NewURI(getter_AddRefs(baseURI), codebase,
     1:                           mCurrentCharset.get(), mCurrentBaseURI);
     1:                 if (baseURI) {
     1:                     mCurrentBaseURI = baseURI;
     1:                 }
     1:             }
     1:             // Unset the codebase too, since we'll correctly relativize the
     1:             // code and archive paths.
     1:             newApplet->RemoveAttribute(NS_LITERAL_STRING("codebase"));
     1:             FixupNodeAttribute(*aNodeOut, "code");
     1:             FixupNodeAttribute(*aNodeOut, "archive");
     1:             // restore the base URI we really want to have
     1:             mCurrentBaseURI = oldBase;
     1:         }
     1:         return rv;
     1:     }
     1:     
     1:     nsCOMPtr<nsIDOMHTMLLinkElement> nodeAsLink = do_QueryInterface(aNodeIn);
     1:     if (nodeAsLink)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             // First see if the link represents linked content
     1:             rv = FixupNodeAttribute(*aNodeOut, "href");
     1:             if (NS_FAILED(rv))
     1:             {
     1:                 // Perhaps this link is actually an anchor to related content
     1:                 FixupAnchor(*aNodeOut);
     1:             }
     1:             // TODO if "type" attribute == "text/css"
     1:             //        fixup stylesheet
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLFrameElement> nodeAsFrame = do_QueryInterface(aNodeIn);
     1:     if (nodeAsFrame)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupNodeAttribute(*aNodeOut, "src");
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLIFrameElement> nodeAsIFrame = do_QueryInterface(aNodeIn);
     1:     if (nodeAsIFrame)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             FixupNodeAttribute(*aNodeOut, "src");
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDOMHTMLInputElement> nodeAsInput = do_QueryInterface(aNodeIn);
     1:     if (nodeAsInput)
     1:     {
     1:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
     1:         if (NS_SUCCEEDED(rv) && *aNodeOut)
     1:         {
     1:             // Disable image loads
     1:             nsCOMPtr<nsIImageLoadingContent> imgCon =
     1:                 do_QueryInterface(*aNodeOut);
     1:             if (imgCon)
 80486:                 imgCon->SetLoadingEnabled(false);
     1: 
     1:             FixupNodeAttribute(*aNodeOut, "src");
 16267: 
 16267:             nsAutoString valueStr;
 16267:             NS_NAMED_LITERAL_STRING(valueAttr, "value");
 16267:             // Update element node attributes with user-entered form state
 16267:             nsCOMPtr<nsIDOMHTMLInputElement> outElt = do_QueryInterface(*aNodeOut);
 16267:             nsCOMPtr<nsIFormControl> formControl = do_QueryInterface(*aNodeOut);
 16267:             switch (formControl->GetType()) {
 50907:                 case NS_FORM_INPUT_EMAIL:
 42372:                 case NS_FORM_INPUT_SEARCH:
 16267:                 case NS_FORM_INPUT_TEXT:
 42192:                 case NS_FORM_INPUT_TEL:
 50909:                 case NS_FORM_INPUT_URL:
103657:                 case NS_FORM_INPUT_NUMBER:
 16267:                     nodeAsInput->GetValue(valueStr);
 16267:                     // Avoid superfluous value="" serialization
 16267:                     if (valueStr.IsEmpty())
 16267:                       outElt->RemoveAttribute(valueAttr);
 16267:                     else
 16267:                       outElt->SetAttribute(valueAttr, valueStr);
 16267:                     break;
 16267:                 case NS_FORM_INPUT_CHECKBOX:
 16267:                 case NS_FORM_INPUT_RADIO:
 79445:                     bool checked;
 16267:                     nodeAsInput->GetChecked(&checked);
 16267:                     outElt->SetDefaultChecked(checked);
 16267:                     break;
 16267:                 default:
 16267:                     break;
 16267:             }
 16267:         }
 16267:         return rv;
 16267:     }
 16267: 
 16267:     nsCOMPtr<nsIDOMHTMLTextAreaElement> nodeAsTextArea = do_QueryInterface(aNodeIn);
 16267:     if (nodeAsTextArea)
 16267:     {
 16267:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
 16267:         if (NS_SUCCEEDED(rv) && *aNodeOut)
 16267:         {
 16267:             // Tell the document encoder to serialize the text child we create below
 80486:             *aSerializeCloneKids = true;
 16267: 
 16267:             nsAutoString valueStr;
 16267:             nodeAsTextArea->GetValue(valueStr);
 16267:             
 71768:             (*aNodeOut)->SetTextContent(valueStr);
 16267:         }
 16267:         return rv;
 16267:     }
 16267: 
 16267:     nsCOMPtr<nsIDOMHTMLOptionElement> nodeAsOption = do_QueryInterface(aNodeIn);
 16267:     if (nodeAsOption)
 16267:     {
 16267:         rv = GetNodeToFixup(aNodeIn, aNodeOut);
 16267:         if (NS_SUCCEEDED(rv) && *aNodeOut)
 16267:         {          
 16267:             nsCOMPtr<nsIDOMHTMLOptionElement> outElt = do_QueryInterface(*aNodeOut);
 79445:             bool selected;
 16267:             nodeAsOption->GetSelected(&selected);
 16267:             outElt->SetDefaultSelected(selected);
     1:         }
     1:         return rv;
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::StoreURI(
 79445:     const char *aURI, bool aNeedsPersisting, URIData **aData)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aURI);
  5237: 
   538:     nsCOMPtr<nsIURI> uri;
   538:     nsresult rv = NS_NewURI(getter_AddRefs(uri),
   538:                             nsDependentCString(aURI),
   538:                             mCurrentCharset.get(),
   538:                             mCurrentBaseURI);
   538:     NS_ENSURE_SUCCESS(rv, rv);
   538: 
  5237:     return StoreURI(uri, aNeedsPersisting, aData);
  5237: }
  5237: 
  5237: nsresult
  5237: nsWebBrowserPersist::StoreURI(
 79445:     nsIURI *aURI, bool aNeedsPersisting, URIData **aData)
  5237: {
  5237:     NS_ENSURE_ARG_POINTER(aURI);
  5237:     if (aData)
  5237:     {
106838:         *aData = nullptr;
  5237:     }
  5237: 
  5237:     // Test if this URI should be persisted. By default
  5237:     // we should assume the URI  is persistable.
 79445:     bool doNotPersistURI;
  5237:     nsresult rv = NS_URIChainHasFlags(aURI,
   538:                                       nsIProtocolHandler::URI_NON_PERSISTABLE,
   538:                                       &doNotPersistURI);
   538:     if (NS_FAILED(rv))
   538:     {
 80486:         doNotPersistURI = false;
   538:     }
   538: 
   538:     if (doNotPersistURI)
   538:     {
   538:         return NS_OK;
   538:     }
   538: 
106838:     URIData *data = nullptr;
  5237:     MakeAndStoreLocalFilenameInURIMap(aURI, aNeedsPersisting, &data);
     1:     if (aData)
     1:     {
     1:         *aData = data;
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::StoreURIAttributeNS(
     1:     nsIDOMNode *aNode, const char *aNamespaceURI, const char *aAttribute,
 79445:     bool aNeedsPersisting, URIData **aData)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aNode);
     1:     NS_ENSURE_ARG_POINTER(aNamespaceURI);
     1:     NS_ENSURE_ARG_POINTER(aAttribute);
     1: 
     1:     nsresult rv = NS_OK;
     1: 
     1:     // Find the named URI attribute on the (element) node and store
     1:     // a reference to the URI that maps onto a local file name
     1: 
     1:     nsCOMPtr<nsIDOMNamedNodeMap> attrMap;
     1:     nsCOMPtr<nsIDOMNode> attrNode;
     1:     rv = aNode->GetAttributes(getter_AddRefs(attrMap));
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     NS_ConvertASCIItoUTF16 namespaceURI(aNamespaceURI);
     1:     NS_ConvertASCIItoUTF16 attribute(aAttribute);
     1:     rv = attrMap->GetNamedItemNS(namespaceURI, attribute, getter_AddRefs(attrNode));
     1:     if (attrNode)
     1:     {
     1:         nsAutoString oldValue;
     1:         attrNode->GetNodeValue(oldValue);
     1:         if (!oldValue.IsEmpty())
     1:         {
     1:             NS_ConvertUTF16toUTF8 oldCValue(oldValue);
     1:             return StoreURI(oldCValue.get(), aNeedsPersisting, aData);
     1:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::FixupURI(nsAString &aURI)
     1: {
     1:     // get the current location of the file (absolutized)
     1:     nsCOMPtr<nsIURI> uri;
     1:     nsresult rv = NS_NewURI(getter_AddRefs(uri), aURI, 
     1:                             mCurrentCharset.get(), mCurrentBaseURI);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     nsCAutoString spec;
     1:     rv = uri->GetSpec(spec);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Search for the URI in the map and replace it with the local file
     1:     nsCStringKey key(spec.get());
     1:     if (!mURIMap.Exists(&key))
     1:     {
     1:         return NS_ERROR_FAILURE;
     1:     }
     1:     URIData *data = (URIData *) mURIMap.Get(&key);
     1:     if (!data->mNeedsFixup)
     1:     {
     1:         return NS_OK;
     1:     }
     1:     nsCOMPtr<nsIURI> fileAsURI;
     1:     if (data->mFile)
     1:     {
     1:         rv = data->mFile->Clone(getter_AddRefs(fileAsURI)); 
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1:     else
     1:     {
     1:         rv = data->mDataPath->Clone(getter_AddRefs(fileAsURI));
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:         rv = AppendPathToURI(fileAsURI, data->mFilename);
     1:         NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1:     nsAutoString newValue;
     1: 
     1:     // remove username/password if present
     1:     fileAsURI->SetUserPass(EmptyCString());
     1: 
     1:     // reset node attribute 
     1:     // Use relative or absolute links
     1:     if (data->mDataPathIsRelative)
     1:     {
     1:         nsCOMPtr<nsIURL> url(do_QueryInterface(fileAsURI));
     1:         if (!url)
     1:           return NS_ERROR_FAILURE;
     1:           
     1:         nsCAutoString filename;
     1:         url->GetFileName(filename);
     1: 
     1:         nsCAutoString rawPathURL(data->mRelativePathToData);
     1:         rawPathURL.Append(filename);
     1: 
     1:         nsCAutoString buf;
     1:         AppendUTF8toUTF16(NS_EscapeURL(rawPathURL, esc_FilePath, buf),
     1:                           newValue);
     1:     }
     1:     else
     1:     {
     1:         nsCAutoString fileurl;
     1:         fileAsURI->GetSpec(fileurl);
     1:         AppendUTF8toUTF16(fileurl, newValue);
     1:     }
     1:     if (data->mIsSubFrame)
     1:     {
     1:         newValue.Append(data->mSubFrameExt);
     1:     }
     1: 
     1:     aURI = newValue;
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::FixupNodeAttributeNS(nsIDOMNode *aNode,
     1:                                         const char *aNamespaceURI,
     1:                                         const char *aAttribute)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aNode);
     1:     NS_ENSURE_ARG_POINTER(aNamespaceURI);
     1:     NS_ENSURE_ARG_POINTER(aAttribute);
     1: 
     1:     nsresult rv = NS_OK;
     1: 
     1:     // Find the named URI attribute on the (element) node and change it to reference
     1:     // a local file.
     1: 
     1:     nsCOMPtr<nsIDOMNamedNodeMap> attrMap;
     1:     nsCOMPtr<nsIDOMNode> attrNode;
     1:     rv = aNode->GetAttributes(getter_AddRefs(attrMap));
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     NS_ConvertASCIItoUTF16 attribute(aAttribute);
     1:     NS_ConvertASCIItoUTF16 namespaceURI(aNamespaceURI);
     1:     rv = attrMap->GetNamedItemNS(namespaceURI, attribute, getter_AddRefs(attrNode));
     1:     if (attrNode)
     1:     {
     1:         nsString uri;
     1:         attrNode->GetNodeValue(uri);
     1:         rv = FixupURI(uri);
     1:         if (NS_SUCCEEDED(rv))
     1:         {
     1:             attrNode->SetNodeValue(uri);
     1:         }
     1:     }
     1: 
     1:     return rv;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::FixupAnchor(nsIDOMNode *aNode)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aNode);
     1: 
     1:     nsCOMPtr<nsIDOMNamedNodeMap> attrMap;
     1:     nsCOMPtr<nsIDOMNode> attrNode;
     1:     nsresult rv = aNode->GetAttributes(getter_AddRefs(attrMap));
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     if (mPersistFlags & PERSIST_FLAGS_DONT_FIXUP_LINKS)
     1:     {
     1:         return NS_OK;
     1:     }
     1: 
     1:     // Make all anchor links absolute so they point off onto the Internet
     1:     nsString attribute(NS_LITERAL_STRING("href"));
     1:     rv = attrMap->GetNamedItem(attribute, getter_AddRefs(attrNode));
     1:     if (attrNode)
     1:     {
     1:         nsString oldValue;
     1:         attrNode->GetNodeValue(oldValue);
     1:         NS_ConvertUTF16toUTF8 oldCValue(oldValue);
     1: 
     1:         // Skip empty values and self-referencing bookmarks
     1:         if (oldCValue.IsEmpty() || oldCValue.CharAt(0) == '#')
     1:         {
     1:             return NS_OK;
     1:         }
     1: 
     1:         // if saving file to same location, we don't need to do any fixup
 79445:         bool isEqual = false;
     1:         if (NS_SUCCEEDED(mCurrentBaseURI->Equals(mTargetBaseURI, &isEqual))
     1:             && isEqual)
     1:         {
     1:             return NS_OK;
     1:         }
     1: 
     1:         nsCOMPtr<nsIURI> relativeURI;
     1:         relativeURI = (mPersistFlags & PERSIST_FLAGS_FIXUP_LINKS_TO_DESTINATION)
     1:                       ? mTargetBaseURI : mCurrentBaseURI;
     1:         // Make a new URI to replace the current one
     1:         nsCOMPtr<nsIURI> newURI;
     1:         rv = NS_NewURI(getter_AddRefs(newURI), oldCValue, 
     1:                        mCurrentCharset.get(), relativeURI);
     1:         if (NS_SUCCEEDED(rv) && newURI)
     1:         {
     1:             newURI->SetUserPass(EmptyCString());
     1:             nsCAutoString uriSpec;
     1:             newURI->GetSpec(uriSpec);
     1:             attrNode->SetNodeValue(NS_ConvertUTF8toUTF16(uriSpec));
     1:         }
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::StoreAndFixupStyleSheet(nsIStyleSheet *aStyleSheet)
     1: {
     1:     // TODO go through the style sheet fixing up all links
     1:     return NS_OK;
     1: }
     1: 
 79445: bool
  5237: nsWebBrowserPersist::DocumentEncoderExists(const PRUnichar *aContentType)
  5237: {
  5237:     // Check if there is an encoder for the desired content type.
  5237:     nsCAutoString contractID(NS_DOC_ENCODER_CONTRACTID_BASE);
  5237:     AppendUTF16toUTF8(aContentType, contractID);
  5237: 
  5237:     nsCOMPtr<nsIComponentRegistrar> registrar;
  5237:     NS_GetComponentRegistrar(getter_AddRefs(registrar));
  5237:     if (registrar)
  5237:     {
 79445:         bool result;
  5237:         nsresult rv = registrar->IsContractIDRegistered(contractID.get(),
  5237:                                                         &result);
  5237:         if (NS_SUCCEEDED(rv) && result)
  5237:         {
 80486:             return true;
 80486:         }
 80486:     }
 80486:     return false;
  5237: }
  5237: 
     1: nsresult
     1: nsWebBrowserPersist::SaveSubframeContent(
     1:     nsIDOMDocument *aFrameContent, URIData *aData)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aData);
  5237: 
  5237:     // Extract the content type for the frame's contents.
  5237:     nsCOMPtr<nsIDocument> frameDoc(do_QueryInterface(aFrameContent));
  5237:     NS_ENSURE_STATE(frameDoc);
  5237: 
  5237:     nsAutoString contentType;
  5237:     nsresult rv = frameDoc->GetContentType(contentType);
  5237:     NS_ENSURE_SUCCESS(rv, rv);
  5237: 
  5237:     nsXPIDLString ext;
  5237:     GetExtensionForContentType(contentType.get(), getter_Copies(ext));
  5237: 
  5237:     // We must always have an extension so we will try to re-assign
  5237:     // the original extension if GetExtensionForContentType fails.
  5237:     if (ext.IsEmpty())
  5237:     {
  5237:         nsCOMPtr<nsIURL> url(do_QueryInterface(frameDoc->GetDocumentURI(),
  5237:                                                &rv));
  5237:         nsCAutoString extension;
  5237:         if (NS_SUCCEEDED(rv))
  5237:         {
  5237:             url->GetFileExtension(extension);
  5237:         }
  5237:         else
  5237:         {
  5237:             extension.AssignLiteral("htm");
  5237:         }
  5237:         aData->mSubFrameExt.Assign(PRUnichar('.'));
  5237:         AppendUTF8toUTF16(extension, aData->mSubFrameExt);
  5237:     }
  5237:     else
  5237:     {
  5237:         aData->mSubFrameExt.Assign(PRUnichar('.'));
  5237:         aData->mSubFrameExt.Append(ext);
  5237:     }
     1: 
     1:     nsString filenameWithExt = aData->mFilename;
     1:     filenameWithExt.Append(aData->mSubFrameExt);
     1: 
     1:     // Work out the path for the subframe
     1:     nsCOMPtr<nsIURI> frameURI;
     1:     rv = mCurrentDataPath->Clone(getter_AddRefs(frameURI));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     rv = AppendPathToURI(frameURI, filenameWithExt);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Work out the path for the subframe data
     1:     nsCOMPtr<nsIURI> frameDataURI;
     1:     rv = mCurrentDataPath->Clone(getter_AddRefs(frameDataURI));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     nsAutoString newFrameDataPath(aData->mFilename);
     1: 
     1:     // Append _data
     1:     newFrameDataPath.AppendLiteral("_data");
     1:     rv = AppendPathToURI(frameDataURI, newFrameDataPath);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Make frame document & data path conformant and unique
     1:     rv = CalculateUniqueFilename(frameURI);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     rv = CalculateUniqueFilename(frameDataURI);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     mCurrentThingsToPersist++;
  5237: 
  5237:     // We shouldn't use SaveDocumentInternal for the contents
  5237:     // of frames that are not documents, e.g. images.
  5237:     if (DocumentEncoderExists(contentType.get()))
  5237:     {
     1:         rv = SaveDocumentInternal(aFrameContent, frameURI, frameDataURI);
  5237:     }
  5237:     else
  5237:     {
  5237:         rv = StoreURI(frameDoc->GetDocumentURI());
  5237:     }
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // Store the updated uri to the frame
     1:     aData->mFile = frameURI;
     1:     aData->mSubFrameExt.Truncate(); // we already put this in frameURI
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsWebBrowserPersist::CreateChannelFromURI(nsIURI *aURI, nsIChannel **aChannel)
     1: {
     1:     nsresult rv = NS_OK;
106838:     *aChannel = nullptr;
     1: 
     1:     nsCOMPtr<nsIIOService> ioserv;
     1:     ioserv = do_GetIOService(&rv);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     rv = ioserv->NewChannelFromURI(aURI, aChannel);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     NS_ENSURE_ARG_POINTER(*aChannel);
     1: 
  3233:     rv = (*aChannel)->SetNotificationCallbacks(static_cast<nsIInterfaceRequestor *>(this));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     return NS_OK;
     1: } 
     1: 
     1: nsresult
     1: nsWebBrowserPersist::SaveDocumentWithFixup(
     1:     nsIDOMDocument *aDocument, nsIDocumentEncoderNodeFixup *aNodeFixup,
 79445:     nsIURI *aFile, bool aReplaceExisting, const nsACString &aFormatType,
108991:     const nsCString &aSaveCharset, uint32_t aFlags)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aFile);
     1:     
     1:     nsresult  rv = NS_OK;
101111:     nsCOMPtr<nsIFile> localFile;
     1:     GetLocalFileFromURI(aFile, getter_AddRefs(localFile));
     1:     if (localFile)
     1:     {
     1:         // if we're not replacing an existing file but the file
     1:         // exists, something is wrong
 79445:         bool fileExists = false;
     1:         rv = localFile->Exists(&fileExists);
     1:         NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:         if (!aReplaceExisting && fileExists)
     1:             return NS_ERROR_FAILURE;                // where are the file I/O errors?
     1:     }
     1:     
     1:     nsCOMPtr<nsIOutputStream> outputStream;
     1:     rv = MakeOutputStream(aFile, getter_AddRefs(outputStream));
     1:     if (NS_FAILED(rv))
     1:     {
106838:         SendErrorStatusChange(false, rv, nullptr, aFile);
     1:         return NS_ERROR_FAILURE;
     1:     }
     1:     NS_ENSURE_TRUE(outputStream, NS_ERROR_FAILURE);
     1: 
     1:     // Get a document encoder instance
     1:     nsCAutoString contractID(NS_DOC_ENCODER_CONTRACTID_BASE);
     1:     contractID.Append(aFormatType);
     1:     
     1:     nsCOMPtr<nsIDocumentEncoder> encoder = do_CreateInstance(contractID.get(), &rv);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     NS_ConvertASCIItoUTF16 newContentType(aFormatType);
     1:     rv = encoder->Init(aDocument, newContentType, aFlags);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     mTargetBaseURI = aFile;
     1: 
     1:     // Set the node fixup callback
     1:     encoder->SetNodeFixup(aNodeFixup);
     1: 
     1:     if (mWrapColumn && (aFlags & ENCODE_FLAGS_WRAP))
     1:         encoder->SetWrapColumn(mWrapColumn);
     1: 
     1:     nsCAutoString charsetStr(aSaveCharset);
     1:     if (charsetStr.IsEmpty())
     1:     {
     1:         nsCOMPtr<nsIDocument> doc = do_QueryInterface(aDocument);
     1:         NS_ASSERTION(doc, "Need a document");
     1:         charsetStr = doc->GetDocumentCharacterSet();
     1:     }
     1: 
     1:     rv = encoder->SetCharset(charsetStr);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     rv = encoder->EncodeToStream(outputStream);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1:     
     1:     if (!localFile)
     1:     {
     1:         nsCOMPtr<nsIStorageStream> storStream(do_QueryInterface(outputStream));
     1:         if (storStream)
     1:         {
     1:             outputStream->Close();
     1:             rv = StartUpload(storStream, aFile, aFormatType);
     1:             NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1:         }
     1:     }
     1: #if defined(XP_OS2)
     1:     else
     1:     {
     1:         // close the stream, then tag the file it created with its source URI
     1:         outputStream->Close();
     1:         nsCOMPtr<nsILocalFileOS2> localFileOS2 = do_QueryInterface(localFile);
     1:         if (localFileOS2)
     1:         {
     1:             nsCAutoString url;
     1:             mCurrentBaseURI->GetSpec(url);
     1:             localFileOS2->SetFileSource(url);
     1:         }
     1:     }
     1: #endif
     1: 
     1:     return rv;
     1: }
     1: 
     1: 
     1: // we store the current location as the key (absolutized version of domnode's attribute's value)
     1: nsresult
     1: nsWebBrowserPersist::MakeAndStoreLocalFilenameInURIMap(
 79445:     nsIURI *aURI, bool aNeedsPersisting, URIData **aData)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aURI);
     1: 
     1:     nsCAutoString spec;
   538:     nsresult rv = aURI->GetSpec(spec);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     // Create a sensibly named filename for the URI and store in the URI map
     1:     nsCStringKey key(spec.get());
 24827:     URIData *data;
     1:     if (mURIMap.Exists(&key))
     1:     {
 24827:         data = (URIData *) mURIMap.Get(&key);
 24827:         if (aNeedsPersisting)
 24827:         {
 80486:           data->mNeedsPersisting = true;
 24827:         }
     1:         if (aData)
     1:         {
 24827:             *aData = data;
     1:         }
     1:         return NS_OK;
     1:     }
     1: 
     1:     // Create a unique file name for the uri
     1:     nsString filename;
   538:     rv = MakeFilenameFromURI(aURI, filename);
     1:     NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
     1: 
     1:     // Store the file name
 24827:     data = new URIData;
     1:     NS_ENSURE_TRUE(data, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:     data->mNeedsPersisting = aNeedsPersisting;
 80486:     data->mNeedsFixup = true;
     1:     data->mFilename = filename;
 80486:     data->mSaved = false;
 80486:     data->mIsSubFrame = false;
     1:     data->mDataPath = mCurrentDataPath;
     1:     data->mDataPathIsRelative = mCurrentDataPathIsRelative;
     1:     data->mRelativePathToData = mCurrentRelativePathToData;
     1:     data->mCharset = mCurrentCharset;
     1: 
     1:     if (aNeedsPersisting)
     1:         mCurrentThingsToPersist++;
     1: 
     1:     mURIMap.Put(&key, data);
     1:     if (aData)
     1:     {
     1:         *aData = data;
     1:     }
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: // Ordered so that typical documents work fastest.
     1: //                                    strlen("blockquote")==10
     1: static const char kSpecialXHTMLTags[][11] = {
     1:     "body",
     1:     "head",
     1:     "img",
     1:     "script",
     1:     "a",
     1:     "area",
     1:     "link",
     1:     "input",
     1:     "frame",
     1:     "iframe",
     1:     "object",
     1:     "applet",
     1:     "form",
     1:     "blockquote",
     1:     "q",
     1:     "del",
     1:     "ins"
     1: };
     1: 
 79445: static bool IsSpecialXHTMLTag(nsIDOMNode *aNode)
     1: {
     1:     nsAutoString tmp;
     1:     aNode->GetNamespaceURI(tmp);
     1:     if (!tmp.EqualsLiteral("http://www.w3.org/1999/xhtml"))
 80486:         return false;
     1: 
     1:     aNode->GetLocalName(tmp);
108991:     for (uint32_t i = 0; i < ArrayLength(kSpecialXHTMLTags); i++) {
     1:         if (tmp.EqualsASCII(kSpecialXHTMLTags[i]))
     1:         {
     1:             // XXX This element MAY have URI attributes, but
     1:             //     we are not actually checking if they are present.
     1:             //     That would slow us down further, and I am not so sure
     1:             //     how important that would be.
 80486:             return true;
 80486:         }
 80486:     }
 80486: 
 80486:     return false;
     1: }
     1: 
 79445: static bool HasSpecialXHTMLTags(nsIDOMNode *aParent)
     1: {
     1:     if (IsSpecialXHTMLTag(aParent))
 80486:         return true;
     1: 
     1:     nsCOMPtr<nsIDOMNodeList> list;
     1:     aParent->GetChildNodes(getter_AddRefs(list));
     1:     if (list)
     1:     {
108991:         uint32_t count;
     1:         list->GetLength(&count);
108991:         uint32_t i;
     1:         for (i = 0; i < count; i++) {
     1:             nsCOMPtr<nsIDOMNode> node;
     1:             list->Item(i, getter_AddRefs(node));
     1:             if (!node)
     1:                 break;
108991:             uint16_t nodeType;
     1:             node->GetNodeType(&nodeType);
     1:             if (nodeType == nsIDOMNode::ELEMENT_NODE) {
     1:                 return HasSpecialXHTMLTags(node);
     1:             }
     1:         }
     1:     }
     1: 
 80486:     return false;
     1: }
     1: 
 79445: static bool NeedXHTMLBaseTag(nsIDOMDocument *aDocument)
     1: {
     1:     nsCOMPtr<nsIDOMElement> docElement;
     1:     aDocument->GetDocumentElement(getter_AddRefs(docElement));
     1: 
     1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(docElement));
     1:     if (node)
     1:     {
     1:         return HasSpecialXHTMLTags(node);
     1:     }
     1: 
 80486:     return false;
     1: }
     1: 
     1: // Set document base. This could create an invalid XML document (still well-formed).
     1: nsresult
     1: nsWebBrowserPersist::SetDocumentBase(
     1:     nsIDOMDocument *aDocument, nsIURI *aBaseURI)
     1: {
     1:     if (mPersistFlags & PERSIST_FLAGS_NO_BASE_TAG_MODIFICATIONS)
     1:     {
     1:         return NS_OK;
     1:     }
     1: 
     1:     NS_ENSURE_ARG_POINTER(aBaseURI);
     1: 
     1:     nsCOMPtr<nsIDOMXMLDocument> xmlDoc;
     1:     nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(aDocument);
     1:     if (!htmlDoc)
     1:     {
     1:         xmlDoc = do_QueryInterface(aDocument);
     1:         if (!xmlDoc)
     1:         {
     1:             return NS_ERROR_FAILURE;
     1:         }
     1:     }
     1: 
     1:     NS_NAMED_LITERAL_STRING(kXHTMLNS, "http://www.w3.org/1999/xhtml");
     1:     NS_NAMED_LITERAL_STRING(kHead, "head");
     1: 
     1:     // Find the head element
     1:     nsCOMPtr<nsIDOMElement> headElement;
     1:     nsCOMPtr<nsIDOMNodeList> headList;
     1:     if (xmlDoc)
     1:     {
     1:         // First see if there is XHTML content that needs base 
     1:         // tags.
     1:         if (!NeedXHTMLBaseTag(aDocument))
     1:             return NS_OK;
     1: 
     1:         aDocument->GetElementsByTagNameNS(
     1:             kXHTMLNS,
     1:             kHead, getter_AddRefs(headList));
     1:     }
     1:     else
     1:     {
     1:         aDocument->GetElementsByTagName(
     1:             kHead, getter_AddRefs(headList));
     1:     }
     1:     if (headList)
     1:     {
     1:         nsCOMPtr<nsIDOMNode> headNode;
     1:         headList->Item(0, getter_AddRefs(headNode));
     1:         headElement = do_QueryInterface(headNode);
     1:     }
     1:     if (!headElement)
     1:     {
     1:         // Create head and insert as first element
     1:         nsCOMPtr<nsIDOMNode> firstChildNode;
     1:         nsCOMPtr<nsIDOMNode> newNode;
     1:         if (xmlDoc)
     1:         {
     1:             aDocument->CreateElementNS(
     1:                 kXHTMLNS,
     1:                 kHead, getter_AddRefs(headElement));
     1:         }
     1:         else
     1:         {
     1:             aDocument->CreateElement(
     1:                 kHead, getter_AddRefs(headElement));
     1:         }
     1:         nsCOMPtr<nsIDOMElement> documentElement;
     1:         aDocument->GetDocumentElement(getter_AddRefs(documentElement));
     1:         if (documentElement)
     1:         {
     1:             documentElement->GetFirstChild(getter_AddRefs(firstChildNode));
     1:             documentElement->InsertBefore(headElement, firstChildNode, getter_AddRefs(newNode));
     1:         }
     1:     }
     1:     if (!headElement)
     1:     {
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     // Find or create the BASE element
     1:     NS_NAMED_LITERAL_STRING(kBase, "base");
     1:     nsCOMPtr<nsIDOMElement> baseElement;
     1:     nsCOMPtr<nsIDOMNodeList> baseList;
     1:     if (xmlDoc)
     1:     {
     1:         headElement->GetElementsByTagNameNS(
     1:             kXHTMLNS,
     1:             kBase, getter_AddRefs(baseList));
     1:     }
     1:     else
     1:     {
     1:         headElement->GetElementsByTagName(
     1:             kBase, getter_AddRefs(baseList));
     1:     }
     1:     if (baseList)
     1:     {
     1:         nsCOMPtr<nsIDOMNode> baseNode;
     1:         baseList->Item(0, getter_AddRefs(baseNode));
     1:         baseElement = do_QueryInterface(baseNode);
     1:     }
     1: 
     1:     // Add the BASE element
     1:     if (!baseElement)
     1:     {
     1:       nsCOMPtr<nsIDOMNode> newNode;
     1:       if (xmlDoc)
     1:       {
     1:           aDocument->CreateElementNS(
     1:               kXHTMLNS,
     1:               kBase, getter_AddRefs(baseElement));
     1:       }
     1:       else
     1:       {
     1:           aDocument->CreateElement(
     1:               kBase, getter_AddRefs(baseElement));
     1:       }
     1:       headElement->AppendChild(baseElement, getter_AddRefs(newNode));
     1:     }
     1:     if (!baseElement)
     1:     {
     1:         return NS_ERROR_FAILURE;
     1:     }
     1:     nsCAutoString uriSpec;
     1:     aBaseURI->GetSpec(uriSpec);
     1:     NS_ConvertUTF8toUTF16 href(uriSpec);
     1:     baseElement->SetAttribute(NS_LITERAL_STRING("href"), href);
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: // Decide if we need to apply conversion to the passed channel.
     1: void nsWebBrowserPersist::SetApplyConversionIfNeeded(nsIChannel *aChannel)
     1: {
     1:     nsresult rv = NS_OK;
     1:     nsCOMPtr<nsIEncodedChannel> encChannel = do_QueryInterface(aChannel, &rv);
     1:     if (NS_FAILED(rv))
     1:         return;
     1: 
     1:     // Set the default conversion preference:
 80486:     encChannel->SetApplyConversion(false);
     1: 
     1:     nsCOMPtr<nsIURI> thisURI;
     1:     aChannel->GetURI(getter_AddRefs(thisURI));
     1:     nsCOMPtr<nsIURL> sourceURL(do_QueryInterface(thisURI));
     1:     if (!sourceURL)
     1:         return;
     1:     nsCAutoString extension;
     1:     sourceURL->GetFileExtension(extension);
     1: 
     1:     nsCOMPtr<nsIUTF8StringEnumerator> encEnum;
     1:     encChannel->GetContentEncodings(getter_AddRefs(encEnum));
     1:     if (!encEnum)
     1:         return;
     1:     nsCOMPtr<nsIExternalHelperAppService> helperAppService =
     1:         do_GetService(NS_EXTERNALHELPERAPPSERVICE_CONTRACTID, &rv);
     1:     if (NS_FAILED(rv))
     1:         return;
 79445:     bool hasMore;
     1:     rv = encEnum->HasMore(&hasMore);
     1:     if (NS_SUCCEEDED(rv) && hasMore)
     1:     {
     1:         nsCAutoString encType;
     1:         rv = encEnum->GetNext(encType);
     1:         if (NS_SUCCEEDED(rv))
     1:         {
 79445:             bool applyConversion = false;
     1:             rv = helperAppService->ApplyDecodingForExtension(extension, encType,
     1:                                                              &applyConversion);
     1:             if (NS_SUCCEEDED(rv))
     1:                 encChannel->SetApplyConversion(applyConversion);
     1:         }
     1:     }
     1: }
     1: 
     1: ///////////////////////////////////////////////////////////////////////////////
     1: 
     1: 
106838: nsEncoderNodeFixup::nsEncoderNodeFixup() : mWebBrowserPersist(nullptr)
     1: {
     1: }
     1: 
     1: 
     1: nsEncoderNodeFixup::~nsEncoderNodeFixup()
     1: {
     1: }
     1: 
     1: 
     1: NS_IMPL_ADDREF(nsEncoderNodeFixup)
     1: NS_IMPL_RELEASE(nsEncoderNodeFixup)
     1: 
     1: 
     1: NS_INTERFACE_MAP_BEGIN(nsEncoderNodeFixup)
     1:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDocumentEncoderNodeFixup)
     1:     NS_INTERFACE_MAP_ENTRY(nsIDocumentEncoderNodeFixup)
     1: NS_INTERFACE_MAP_END
     1: 
     1: 
     1: NS_IMETHODIMP nsEncoderNodeFixup::FixupNode(
 79445:     nsIDOMNode *aNode, bool *aSerializeCloneKids, nsIDOMNode **aOutNode)
     1: {
     1:     NS_ENSURE_ARG_POINTER(aNode);
     1:     NS_ENSURE_ARG_POINTER(aOutNode);
     1:     NS_ENSURE_TRUE(mWebBrowserPersist, NS_ERROR_FAILURE);
     1: 
106838:     *aOutNode = nullptr;
     1:     
     1:     // Test whether we need to fixup the node
108991:     uint16_t type = 0;
     1:     aNode->GetNodeType(&type);
     1:     if (type == nsIDOMNode::ELEMENT_NODE ||
     1:         type == nsIDOMNode::PROCESSING_INSTRUCTION_NODE)
     1:     {
 16267:         return mWebBrowserPersist->CloneNodeWithFixedUpAttributes(aNode, aSerializeCloneKids, aOutNode);
     1:     }
     1: 
     1:     return NS_OK;
     1: }
