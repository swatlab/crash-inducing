    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Netscape security libraries.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2000
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsCRLManager.h"
    1: #include "nsCRLInfo.h"
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIDateTimeFormat.h"
    1: #include "nsDateTimeFormatCID.h"
    1: #include "nsComponentManagerUtils.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsNSSComponent.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsIPrompt.h"
    1: #include "nsICertificateDialogs.h"
    1: #include "nsIMutableArray.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsNSSShutDown.h"
    1: 
    1: #include "nsNSSCertHeader.h"
    1: 
    1: #include "nspr.h"
    1: extern "C" {
    1: #include "pk11func.h"
    1: #include "certdb.h"
    1: #include "cert.h"
    1: #include "secerr.h"
    1: #include "nssb64.h"
    1: #include "secasn1.h"
    1: #include "secder.h"
    1: }
    1: #include "ssl.h"
    1: #include "ocsp.h"
    1: #include "plbase64.h"
    1: 
    1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
    1: 
    1: NS_IMPL_ISUPPORTS1(nsCRLManager, nsICRLManager)
    1: 
    1: nsCRLManager::nsCRLManager()
    1: {
    1: }
    1: 
    1: nsCRLManager::~nsCRLManager()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP 
67654: nsCRLManager::ImportCrl (PRUint8 *aData, PRUint32 aLength, nsIURI * aURI, PRUint32 aType, PRBool doSilentDownload, const PRUnichar* crlKey)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   nsresult rv;
    1:   PRArenaPool *arena = NULL;
    1:   CERTCertificate *caCert;
    1:   SECItem derName = { siBuffer, NULL, 0 };
    1:   SECItem derCrl;
    1:   CERTSignedData sd;
    1:   SECStatus sec_rv;
    1:   CERTSignedCrl *crl;
    1:   nsCAutoString url;
    1:   nsCOMPtr<nsICRLInfo> crlData;
    1:   PRBool importSuccessful;
    1:   PRInt32 errorCode;
    1:   nsString errorMessage;
    1:   
    1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
    1:   if (NS_FAILED(rv)) return rv;
    1: 	         
    1:   aURI->GetSpec(url);
    1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
    1:   if (!arena) {
    1:     goto loser;
    1:   }
    1:   memset(&sd, 0, sizeof(sd));
    1: 
    1:   derCrl.data = (unsigned char*)aData;
    1:   derCrl.len = aLength;
    1:   sec_rv = CERT_KeyFromDERCrl(arena, &derCrl, &derName);
    1:   if (sec_rv != SECSuccess) {
    1:     goto loser;
    1:   }
    1: 
    1:   caCert = CERT_FindCertByName(CERT_GetDefaultCertDB(), &derName);
    1:   if (!caCert) {
    1:     if (aType == SEC_KRL_TYPE){
    1:       goto loser;
    1:     }
    1:   } else {
    1:     sec_rv = SEC_ASN1DecodeItem(arena,
    1:                             &sd, SEC_ASN1_GET(CERT_SignedDataTemplate), 
    1:                             &derCrl);
    1:     if (sec_rv != SECSuccess) {
    1:       goto loser;
    1:     }
    1:     sec_rv = CERT_VerifySignedData(&sd, caCert, PR_Now(),
    1:                                nsnull);
    1:     if (sec_rv != SECSuccess) {
    1:       goto loser;
    1:     }
    1:   }
    1:   
 3233:   crl = SEC_NewCrl(CERT_GetDefaultCertDB(), const_cast<char*>(url.get()), &derCrl,
    1:                    aType);
    1:   
    1:   if (!crl) {
    1:     goto loser;
    1:   }
    1: 
    1:   crlData = new nsCRLInfo(crl);
    1:   SSL_ClearSessionCache();
    1:   SEC_DestroyCrl(crl);
    1:   
    1:   importSuccessful = PR_TRUE;
    1:   goto done;
    1: 
    1: loser:
    1:   importSuccessful = PR_FALSE;
    1:   errorCode = PR_GetError();
    1:   switch (errorCode) {
    1:     case SEC_ERROR_CRL_EXPIRED:
    1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureExpired", errorMessage);
    1:       break;
    1: 
    1: 	case SEC_ERROR_CRL_BAD_SIGNATURE:
    1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureBadSignature", errorMessage);
    1:       break;
    1: 
    1: 	case SEC_ERROR_CRL_INVALID:
    1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureInvalid", errorMessage);
    1:       break;
    1: 
    1: 	case SEC_ERROR_OLD_CRL:
    1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureOld", errorMessage);
    1:       break;
    1: 
    1: 	case SEC_ERROR_CRL_NOT_YET_VALID:
    1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureNotYetValid", errorMessage);
    1:       break;
    1: 
    1:     default:
    1:       nssComponent->GetPIPNSSBundleString("CrlImportFailureReasonUnknown", errorMessage);
    1:       errorMessage.AppendInt(errorCode,16);
    1:       break;
    1:   }
    1: 
    1: done:
    1:           
67654:   if(!doSilentDownload){
    1:     if (!importSuccessful){
    1:       nsString message;
    1:       nsString temp;
    1:       nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
    1:       nsCOMPtr<nsIPrompt> prompter;
    1:       if (wwatch){
    1:         wwatch->GetNewPrompter(0, getter_AddRefs(prompter));
 4289:         nssComponent->GetPIPNSSBundleString("CrlImportFailure1x", message);
    1:         message.Append(NS_LITERAL_STRING("\n").get());
    1:         message.Append(errorMessage);
    1:         nssComponent->GetPIPNSSBundleString("CrlImportFailure2", temp);
    1:         message.Append(NS_LITERAL_STRING("\n").get());
    1:         message.Append(temp);
    1:      
    1:         if(prompter) {
    1:           nsPSMUITracker tracker;
    1:           if (!tracker.isUIForbidden()) {
    1:             prompter->Alert(0, message.get());
    1:           }
    1:         }
    1:       }
    1:     } else {
    1:       nsCOMPtr<nsICertificateDialogs> certDialogs;
    1:       // Not being able to display the success dialog should not
    1:       // be a fatal error, so don't return a failure code.
    1:       {
    1:         nsPSMUITracker tracker;
    1:         if (tracker.isUIForbidden()) {
    1:           rv = NS_ERROR_NOT_AVAILABLE;
    1:         }
    1:         else {
    1:           rv = ::getNSSDialogs(getter_AddRefs(certDialogs),
    1:             NS_GET_IID(nsICertificateDialogs), NS_CERTIFICATEDIALOGS_CONTRACTID);
    1:         }
    1:       }
    1:       if (NS_SUCCEEDED(rv)) {
    1:         nsCOMPtr<nsIInterfaceRequestor> cxt = new PipUIContext();
    1:         certDialogs->CrlImportStatusDialog(cxt, crlData);
    1:       }
    1:     }
    1:   } else {
    1:     if(crlKey == nsnull){
    1:       return NS_ERROR_FAILURE;
    1:     }
    1:     nsCOMPtr<nsIPrefService> prefSvc = do_GetService(NS_PREFSERVICE_CONTRACTID,&rv);
    1:     nsCOMPtr<nsIPrefBranch> pref = do_GetService(NS_PREFSERVICE_CONTRACTID,&rv);
    1:     if (NS_FAILED(rv)){
    1:       return rv;
    1:     }
    1:     
    1:     nsCAutoString updateErrCntPrefStr(CRL_AUTOUPDATE_ERRCNT_PREF);
    1:     updateErrCntPrefStr.AppendWithConversion(crlKey);
    1:     if(importSuccessful){
    1:       PRUnichar *updateTime;
    1:       nsCAutoString updateTimeStr;
    1:       nsCString updateURL;
    1:       PRInt32 timingTypePref;
    1:       double dayCnt;
    1:       char *dayCntStr;
    1:       nsCAutoString updateTypePrefStr(CRL_AUTOUPDATE_TIMIINGTYPE_PREF);
    1:       nsCAutoString updateTimePrefStr(CRL_AUTOUPDATE_TIME_PREF);
    1:       nsCAutoString updateUrlPrefStr(CRL_AUTOUPDATE_URL_PREF);
    1:       nsCAutoString updateDayCntPrefStr(CRL_AUTOUPDATE_DAYCNT_PREF);
    1:       nsCAutoString updateFreqCntPrefStr(CRL_AUTOUPDATE_FREQCNT_PREF);
    1:       updateTypePrefStr.AppendWithConversion(crlKey);
    1:       updateTimePrefStr.AppendWithConversion(crlKey);
    1:       updateUrlPrefStr.AppendWithConversion(crlKey);
    1:       updateDayCntPrefStr.AppendWithConversion(crlKey);
    1:       updateFreqCntPrefStr.AppendWithConversion(crlKey);
    1: 
    1:       pref->GetIntPref(updateTypePrefStr.get(),&timingTypePref);
    1:       
    1:       //Compute and update the next download instant
    1:       if(timingTypePref == TYPE_AUTOUPDATE_TIME_BASED){
    1:         pref->GetCharPref(updateDayCntPrefStr.get(),&dayCntStr);
    1:       }else{
    1:         pref->GetCharPref(updateFreqCntPrefStr.get(),&dayCntStr);
    1:       }
    1:       dayCnt = atof(dayCntStr);
    1:       nsMemory::Free(dayCntStr);
    1: 
    1:       PRBool toBeRescheduled = PR_FALSE;
    1:       if(NS_SUCCEEDED(ComputeNextAutoUpdateTime(crlData, timingTypePref, dayCnt, &updateTime))){
    1:         updateTimeStr.AssignWithConversion(updateTime);
    1:         nsMemory::Free(updateTime);
    1:         pref->SetCharPref(updateTimePrefStr.get(),updateTimeStr.get());
    1:         //Now, check if this update time is already in the past. This would
    1:         //imply we have downloaded the same crl, or there is something wrong
    1:         //with the next update date. We will not reschedule this crl in this
    1:         //session anymore - or else, we land into a loop. It would anyway be
    1:         //imported once the browser is restarted.
    1:         PRTime nextTime;
    1:         PR_ParseTimeString(updateTimeStr.get(),PR_TRUE, &nextTime);
    1:         if(LL_CMP(nextTime, > , PR_Now())){
    1:           toBeRescheduled = PR_TRUE;
    1:         }
    1:       }
    1:       
    1:       //Update the url to download from, next time
    1:       crlData->GetLastFetchURL(updateURL);
    1:       pref->SetCharPref(updateUrlPrefStr.get(),updateURL.get());
    1:       
    1:       pref->SetIntPref(updateErrCntPrefStr.get(),0);
    1:       
17116:       if (toBeRescheduled) {
    1:         nsAutoString hashKey(crlKey);
    1:         nssComponent->RemoveCrlFromList(hashKey);
    1:         nssComponent->DefineNextTimer();
    1:       }
    1: 
    1:     } else{
    1:       PRInt32 errCnt;
    1:       nsCAutoString errMsg;
    1:       nsCAutoString updateErrDetailPrefStr(CRL_AUTOUPDATE_ERRDETAIL_PREF);
    1:       updateErrDetailPrefStr.AppendWithConversion(crlKey);
    1:       errMsg.AssignWithConversion(errorMessage.get());
    1:       rv = pref->GetIntPref(updateErrCntPrefStr.get(),&errCnt);
    1:       if(NS_FAILED(rv))
    1:         errCnt = 0;
    1: 
    1:       pref->SetIntPref(updateErrCntPrefStr.get(),errCnt+1);
    1:       pref->SetCharPref(updateErrDetailPrefStr.get(),errMsg.get());
    1:     }
    1:     prefSvc->SavePrefFile(nsnull);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsCRLManager::UpdateCRLFromURL( const PRUnichar *url, const PRUnichar* key, PRBool *res)
    1: {
    1:   nsresult rv;
    1:   nsAutoString downloadUrl(url);
    1:   nsAutoString dbKey(key);
    1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
    1:   if(NS_FAILED(rv)){
    1:     *res = PR_FALSE;
    1:     return rv;
    1:   }
    1: 
    1:   rv = nssComponent->DownloadCRLDirectly(downloadUrl, dbKey);
    1:   if(NS_FAILED(rv)){
    1:     *res = PR_FALSE;
    1:   } else {
    1:     *res = PR_TRUE;
    1:   }
    1:   return NS_OK;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP 
    1: nsCRLManager::RescheduleCRLAutoUpdate(void)
    1: {
    1:   nsresult rv;
    1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
    1:   if(NS_FAILED(rv)){
    1:     return rv;
    1:   }
    1:   rv = nssComponent->DefineNextTimer();
    1:   return rv;
    1: }
    1: 
67655: /**
    1:  * getCRLs
    1:  *
    1:  * Export a set of certs and keys from the database to a PKCS#12 file.
    1:  */
    1: NS_IMETHODIMP 
    1: nsCRLManager::GetCrls(nsIArray ** aCrls)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   SECStatus sec_rv;
    1:   CERTCrlHeadNode *head = nsnull;
    1:   CERTCrlNode *node = nsnull;
    1:   nsresult rv;
    1:   nsCOMPtr<nsIMutableArray> crlsArray =
    1:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
    1:   if (NS_FAILED(rv)) {
    1:     return rv;
    1:   }
    1: 
    1:   // Get the list of certs //
    1:   sec_rv = SEC_LookupCrls(CERT_GetDefaultCertDB(), &head, -1);
    1:   if (sec_rv != SECSuccess) {
67656:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (head) {
    1:     for (node=head->first; node != nsnull; node = node->next) {
    1: 
    1:       nsCOMPtr<nsICRLInfo> entry = new nsCRLInfo((node->crl));
    1:       crlsArray->AppendElement(entry, PR_FALSE);
    1:     }
    1:     PORT_FreeArena(head->arena, PR_FALSE);
    1:   }
    1: 
    1:   *aCrls = crlsArray;
    1:   NS_IF_ADDREF(*aCrls);
    1:   return NS_OK;
    1: }
    1: 
67655: /**
67655:  * deleteCrl
    1:  *
    1:  * Delete a Crl entry from the cert db.
    1:  */
    1: NS_IMETHODIMP 
    1: nsCRLManager::DeleteCrl(PRUint32 aCrlIndex)
    1: {
    1:   nsNSSShutDownPreventionLock locker;
    1:   CERTSignedCrl *realCrl = nsnull;
    1:   CERTCrlHeadNode *head = nsnull;
    1:   CERTCrlNode *node = nsnull;
    1:   SECStatus sec_rv;
    1:   PRUint32 i;
    1: 
    1:   // Get the list of certs //
    1:   sec_rv = SEC_LookupCrls(CERT_GetDefaultCertDB(), &head, -1);
    1:   if (sec_rv != SECSuccess) {
67656:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (head) {
    1:     for (i = 0, node=head->first; node != nsnull; i++, node = node->next) {
    1:       if (i != aCrlIndex) {
    1:         continue;
    1:       }
    1:       realCrl = SEC_FindCrlByName(CERT_GetDefaultCertDB(), &(node->crl->crl.derName), node->type);
    1:       SEC_DeletePermCRL(realCrl);
    1:       SEC_DestroyCrl(realCrl);
    1:       SSL_ClearSessionCache();
    1:     }
    1:     PORT_FreeArena(head->arena, PR_FALSE);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsCRLManager::ComputeNextAutoUpdateTime(nsICRLInfo *info, 
    1:   PRUint32 autoUpdateType, double dayCnt, PRUnichar **nextAutoUpdate)
    1: {
    1:   if (!info)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   PRTime microsecInDayCnt;
    1:   PRTime now = PR_Now();
    1:   PRTime tempTime;
    1:   PRInt64 diff = 0;
    1:   PRInt64 secsInDay = 86400UL;
    1:   PRInt64 temp;
    1:   PRInt64 cycleCnt = 0;
    1:   PRInt64 secsInDayCnt;
    1:   PRFloat64 tmpData;
    1:   
    1:   LL_L2F(tmpData,secsInDay);
    1:   LL_MUL(tmpData,dayCnt,tmpData);
    1:   LL_F2L(secsInDayCnt,tmpData);
    1:   LL_MUL(microsecInDayCnt, secsInDayCnt, PR_USEC_PER_SEC);
    1:     
    1:   PRTime lastUpdate;
    1:   PRTime nextUpdate;
    1:   
    1:   nsresult rv;
    1: 
    1:   rv = info->GetLastUpdate(&lastUpdate);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   rv = info->GetNextUpdate(&nextUpdate);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   switch (autoUpdateType) {
    1:   case TYPE_AUTOUPDATE_FREQ_BASED:
    1:     LL_SUB(diff, now, lastUpdate);             //diff is the no of micro sec between now and last update
    1:     LL_DIV(cycleCnt, diff, microsecInDayCnt);   //temp is the number of full cycles from lst update
    1:     LL_MOD(temp, diff, microsecInDayCnt);
    1:     if(!(LL_IS_ZERO(temp))) {
    1:       LL_ADD(cycleCnt,cycleCnt,1);            //no of complete cycles till next autoupdate instant
    1:     }
    1:     LL_MUL(temp,cycleCnt,microsecInDayCnt);    //micro secs from last update
    1:     LL_ADD(tempTime, lastUpdate, temp);
    1:     break;  
    1:   case TYPE_AUTOUPDATE_TIME_BASED:
    1:     LL_SUB(tempTime, nextUpdate, microsecInDayCnt);
    1:     break;
    1:   default:
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1:   }
    1: 
    1:   //Now, a basic constraing is that the next auto update date can never be after
    1:   //next update, if one is defined
    1:   if(LL_CMP(nextUpdate , > , 0 )) {
    1:     if(LL_CMP(tempTime , > , nextUpdate)) {
    1:       tempTime = nextUpdate;
    1:     }
    1:   }
    1: 
    1:   nsAutoString nextAutoUpdateDate;
    1:   PRExplodedTime explodedTime;
    1:   nsCOMPtr<nsIDateTimeFormat> dateFormatter = do_CreateInstance(NS_DATETIMEFORMAT_CONTRACTID, &rv);
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   PR_ExplodeTime(tempTime, PR_GMTParameters, &explodedTime);
    1:   dateFormatter->FormatPRExplodedTime(nsnull, kDateFormatShort, kTimeFormatSeconds,
    1:                                       &explodedTime, nextAutoUpdateDate);
    1:   *nextAutoUpdate = ToNewUnicode(nextAutoUpdateDate);
    1: 
    1:   return NS_OK;
    1: }
    1: 
