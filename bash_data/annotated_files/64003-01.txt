62125: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
62125: /* ***** BEGIN LICENSE BLOCK *****
62125:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
62125:  *
62125:  * The contents of this file are subject to the Mozilla Public License Version
62125:  * 1.1 (the "License"); you may not use this file except in compliance with
62125:  * the License. You may obtain a copy of the License at
62125:  * http://www.mozilla.org/MPL/
62125:  *
62125:  * Software distributed under the License is distributed on an "AS IS" basis,
62125:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
62125:  * for the specific language governing rights and limitations under the
62125:  * License.
62125:  *
62125:  * The Original Code is mozilla.org code.
62125:  *
62125:  * The Initial Developer of the Original Code is
62125:  * Mozilla Foundation.
62125:  * Portions created by the Initial Developer are Copyright (C) 2011
62125:  * the Initial Developer. All Rights Reserved.
62125:  *
62125:  * Contributor(s):
62125:  *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
62125:  *
62125:  * Alternatively, the contents of this file may be used under the terms of
62125:  * either of the GNU General Public License Version 2 or later (the "GPL"),
62125:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
62125:  * in which case the provisions of the GPL or the LGPL are applicable instead
62125:  * of those above. If you wish to allow use of your version of this file only
62125:  * under the terms of either the GPL or the LGPL, and not to allow others to
62125:  * use your version of this file under the terms of the MPL, indicate your
62125:  * decision by deleting the provisions above and replace them with the notice
62125:  * and other provisions required by the GPL or the LGPL. If you do not delete
62125:  * the provisions above, a recipient may use your version of this file under
62125:  * the terms of any one of the MPL, the GPL or the LGPL.
62125:  *
62125:  * ***** END LICENSE BLOCK ***** */
62125: 
62125: #include "TextUpdater.h"
62125: 
62125: #include "nsDocAccessible.h"
62125: #include "nsTextAccessible.h"
62125: 
62125: void
62125: TextUpdater::Run(nsDocAccessible* aDocument, nsTextAccessible* aTextLeaf,
62125:                  const nsAString& aNewText)
62125: {
62125:   NS_ASSERTION(aTextLeaf, "No text leaf accessible?");
62125: 
62125:   const nsString& oldText = aTextLeaf->Text();
62125:   PRUint32 oldLen = oldText.Length(), newLen = aNewText.Length();
62125:   PRUint32 minLen = NS_MIN(oldLen, newLen);
62125: 
62125:   // Skip coinciding begin substrings.
62125:   PRUint32 skipStart = 0;
62125:   for (; skipStart < minLen; skipStart++) {
62125:     if (aNewText[skipStart] != oldText[skipStart])
62125:       break;
62125:   }
62125: 
62125:   // The text was changed. Do update.
62125:   if (skipStart != minLen || oldLen != newLen) {
62125:     TextUpdater updater(aDocument, aTextLeaf);
62125:     updater.DoUpdate(aNewText, oldText, skipStart);
62125:   }
62125: }
62125: 
62125: void
62125: TextUpdater::DoUpdate(const nsAString& aNewText, const nsAString& aOldText,
62125:                       PRUint32 aSkipStart)
62125: {
62125:   nsAccessible* parent = mTextLeaf->GetParent();
64003:   if (!parent) {
64003:     NS_ERROR("No parent for text leaf!");
64003:     return;
64003:   }
62125: 
62125:   mHyperText = parent->AsHyperText();
62125:   if (!mHyperText) {
62125:     NS_ERROR("Text leaf parent is not hypertext!");
62125:     return;
62125:   }
62125: 
62125:   // Get the text leaf accessible offset and invalidate cached offsets after it.
62125:   mTextOffset = mHyperText->GetChildOffset(mTextLeaf, PR_TRUE);
62125:   NS_ASSERTION(mTextOffset != -1,
62125:                "Text leaf hasn't offset within hyper text!");
62125: 
62125:   PRUint32 oldLen = aOldText.Length(), newLen = aNewText.Length();
62125:   PRUint32 minLen = NS_MIN(oldLen, newLen);
62125: 
62125:   // Text was appended or removed to/from the end.
62125:   if (aSkipStart == minLen) {
62125:     // If text has been appended to the end, fire text inserted event.
62125:     if (oldLen < newLen) {
62125:       UpdateTextNFireEvent(aNewText, Substring(aNewText, oldLen),
62125:                            oldLen, PR_TRUE);
62125:       return;
62125:     }
62125: 
62125:     // Text has been removed from the end, fire text removed event.
62125:     UpdateTextNFireEvent(aNewText, Substring(aOldText, newLen),
62125:                          newLen, PR_FALSE);
62125:     return;
62125:   }
62125: 
62125:   // Trim coinciding substrings from the end.
62125:   PRUint32 skipEnd = 0;
62125:   while (minLen - skipEnd > aSkipStart &&
62125:          aNewText[newLen - skipEnd - 1] == aOldText[oldLen - skipEnd - 1]) {
62125:     skipEnd++;
62125:   }
62125: 
62125:   // Text was appended or removed to/from the start.
62125:   if (skipEnd == minLen) {
62125:     // If text has been appended to the start, fire text inserted event.
62125:     if (oldLen < newLen) {
62125:       UpdateTextNFireEvent(aNewText, Substring(aNewText, 0, newLen - skipEnd),
62125:                            0, PR_TRUE);
62125:       return;
62125:     }
62125: 
62125:     // Text has been removed from the start, fire text removed event.
62125:     UpdateTextNFireEvent(aNewText, Substring(aOldText, 0, oldLen - skipEnd),
62125:                          0, PR_FALSE);
62125:     return;
62125:   }
62125: 
62125:   // Find the difference between strings and fire events.
62125:   // Note: we can skip initial and final coinciding characters since they don't
62125:   // affect the Levenshtein distance.
62125: 
62125:   PRInt32 strLen1 = oldLen - aSkipStart - skipEnd;
62125:   PRInt32 strLen2 = newLen - aSkipStart - skipEnd;
62125: 
62125:   const nsAString& str1 = Substring(aOldText, aSkipStart, strLen1);
62125:   const nsAString& str2 = Substring(aNewText, aSkipStart, strLen2);
62125: 
62125:   // Increase offset of the text leaf on skipped characters amount.
62125:   mTextOffset += aSkipStart;
62125: 
62125:   // Compute the flat structured matrix need to compute the difference.
62125:   PRUint32 len1 = strLen1 + 1, len2 = strLen2 + 1;
62125:   PRUint32* entries = new PRUint32[len1 * len2];
62125: 
62125:   for (PRUint32 colIdx = 0; colIdx < len1; colIdx++)
62125:     entries[colIdx] = colIdx;
62125: 
62125:   PRUint32* row = entries;
62125:   for (PRUint32 rowIdx = 1; rowIdx < len2; rowIdx++) {
62125:     PRUint32* prevRow = row;
62125:     row += len1;
62125:     row[0] = rowIdx;
62125:     for (PRUint32 colIdx = 1; colIdx < len1; colIdx++) {
62125:       if (str1[colIdx - 1] != str2[rowIdx - 1]) {
62125:         PRUint32 left = row[colIdx - 1];
62125:         PRUint32 up = prevRow[colIdx];
62125:         PRUint32 upleft = prevRow[colIdx - 1];
62125:         row[colIdx] = NS_MIN(upleft, NS_MIN(left, up)) + 1;
62125:       } else {
62125:         row[colIdx] = prevRow[colIdx - 1];
62125:       }
62125:     }
62125:   }
62125: 
62125:   // Compute events based on the difference.
62125:   nsTArray<nsRefPtr<AccEvent> > events;
62125:   ComputeTextChangeEvents(str1, str2, entries, events);
62125: 
62125:   delete [] entries;
62125: 
62125:   // Fire events.
62125:   for (PRInt32 idx = events.Length() - 1; idx >= 0; idx--)
62125:     mDocument->FireDelayedAccessibleEvent(events[idx]);
62125: 
62125:   if (mHyperText->Role() == nsIAccessibleRole::ROLE_ENTRY) {
62125:     nsRefPtr<AccEvent> valueChangeEvent =
62125:       new AccEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE, mHyperText,
62125:                    eAutoDetect, AccEvent::eRemoveDupes);
62125:     mDocument->FireDelayedAccessibleEvent(valueChangeEvent);
62125:   }
62125: 
62125:   // Update the text.
62125:   mTextLeaf->SetText(aNewText);
62125: }
62125: 
62125: void
62125: TextUpdater::ComputeTextChangeEvents(const nsAString& aStr1,
62125:                                      const nsAString& aStr2,
62125:                                      PRUint32* aEntries,
62125:                                      nsTArray<nsRefPtr<AccEvent> >& aEvents)
62125: {
62125:   PRInt32 colIdx = aStr1.Length(), rowIdx = aStr2.Length();
62125: 
62125:   // Point at which strings last matched.
62125:   PRInt32 colEnd = colIdx;
62125:   PRInt32 rowEnd = rowIdx;
62125: 
62125:   PRInt32 colLen = colEnd + 1;
62125:   PRUint32* row = aEntries + rowIdx * colLen;
62125:   PRInt32 dist = row[colIdx]; // current Levenshtein distance
62125:   while (rowIdx && colIdx) { // stop when we can't move diagonally
62125:     if (aStr1[colIdx - 1] == aStr2[rowIdx - 1]) { // match
62125:       if (rowIdx < rowEnd) { // deal with any pending insertion
62125:         FireInsertEvent(Substring(aStr2, rowIdx, rowEnd - rowIdx),
62125:                         rowIdx, aEvents);
62125:       }
62125:       if (colIdx < colEnd) { // deal with any pending deletion
62125:         FireDeleteEvent(Substring(aStr1, colIdx, colEnd - colIdx),
62125:                         rowIdx, aEvents);
62125:       }
62125: 
62125:       colEnd = --colIdx; // reset the match point
62125:       rowEnd = --rowIdx;
62125:       row -= colLen;
62125:       continue;
62125:     }
62125:     --dist;
62125:     if (dist == row[colIdx - 1 - colLen]) { // substitution
62125:       --colIdx;
62125:       --rowIdx;
62125:       row -= colLen;
62125:       continue;
62125:     }
62125:     if (dist == row[colIdx - colLen]) { // insertion
62125:       --rowIdx;
62125:       row -= colLen;
62125:       continue;
62125:     }
62125:     if (dist == row[colIdx - 1]) { // deletion
62125:       --colIdx;
62125:       continue;
62125:     }
62125:     NS_NOTREACHED("huh?");
62125:     return;
62125:   }
62125: 
62125:   if (rowEnd)
62125:     FireInsertEvent(Substring(aStr2, 0, rowEnd), 0, aEvents);
62125:   if (colEnd)
62125:     FireDeleteEvent(Substring(aStr1, 0, colEnd), 0, aEvents);
62125: }
62125: 
62125: void
62125: TextUpdater::UpdateTextNFireEvent(const nsAString& aNewText,
62125:                                   const nsAString& aChangeText,
62125:                                   PRUint32 aAddlOffset,
62125:                                   PRBool aIsInserted)
62125: {
62125:   // Fire text change event.
62125:   nsRefPtr<AccEvent> textChangeEvent =
62125:     new AccTextChangeEvent(mHyperText, mTextOffset + aAddlOffset, aChangeText,
62125:                            aIsInserted);
62125:   mDocument->FireDelayedAccessibleEvent(textChangeEvent);
62125: 
62125:   // Fire value change event.
62125:   if (mHyperText->Role() == nsIAccessibleRole::ROLE_ENTRY) {
62125:     nsRefPtr<AccEvent> valueChangeEvent =
62125:       new AccEvent(nsIAccessibleEvent::EVENT_VALUE_CHANGE, mHyperText,
62125:                    eAutoDetect, AccEvent::eRemoveDupes);
62125:     mDocument->FireDelayedAccessibleEvent(valueChangeEvent);
62125:   }
62125: 
62125:   // Update the text.
62125:   mTextLeaf->SetText(aNewText);
62125: }
