    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
42402: #include "nsHTMLCanvasElement.h"
42402: 
71465: #include "mozilla/Base64.h"
    1: #include "nsNetUtil.h"
    1: #include "prmem.h"
54294: #include "nsDOMFile.h"
54974: #include "CheckedInt.h"
    1: 
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIXPConnect.h"
    1: #include "jsapi.h"
75263: #include "nsContentUtils.h"
59889: #include "nsJSUtils.h"
70899: #include "nsMathUtils.h"
72429: #include "mozilla/Preferences.h"
    1: 
42402: #include "nsFrameManager.h"
47740: #include "nsDisplayList.h"
42402: #include "ImageLayers.h"
42402: #include "BasicLayers.h"
57631: #include "imgIEncoder.h"
57631: 
57631: #include "nsIWritablePropertyBag2.h"
30125: 
    1: #define DEFAULT_CANVAS_WIDTH 300
    1: #define DEFAULT_CANVAS_HEIGHT 150
    1: 
42402: using namespace mozilla;
56805: using namespace mozilla::dom;
42402: using namespace mozilla::layers;
    1: 
    1: nsGenericHTMLElement*
48124: NS_NewHTMLCanvasElement(already_AddRefed<nsINodeInfo> aNodeInfo,
56805:                         FromParser aFromParser)
    1: {
11169:   return new nsHTMLCanvasElement(aNodeInfo);
    1: }
    1: 
48124: nsHTMLCanvasElement::nsHTMLCanvasElement(already_AddRefed<nsINodeInfo> aNodeInfo)
    1:   : nsGenericHTMLElement(aNodeInfo), mWriteOnly(PR_FALSE)
    1: {
    1: }
    1: 
    1: nsHTMLCanvasElement::~nsHTMLCanvasElement()
    1: {
    1: }
43655: 
43655: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLCanvasElement)
43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLCanvasElement,
43655:                                                   nsGenericHTMLElement)
43655:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCurrentContext)
43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
72165: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsHTMLCanvasElement,
72165:                                                 nsGenericHTMLElement)
72165:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCurrentContext)
72165: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
72165: 
    1: NS_IMPL_ADDREF_INHERITED(nsHTMLCanvasElement, nsGenericElement)
    1: NS_IMPL_RELEASE_INHERITED(nsHTMLCanvasElement, nsGenericElement)
    1: 
48124: DOMCI_NODE_DATA(HTMLCanvasElement, nsHTMLCanvasElement)
40490: 
43655: NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLCanvasElement)
21218:   NS_HTML_CONTENT_INTERFACE_TABLE2(nsHTMLCanvasElement,
 4838:                                    nsIDOMHTMLCanvasElement,
42402:                                    nsICanvasElementExternal)
21218:   NS_HTML_CONTENT_INTERFACE_TABLE_TO_MAP_SEGUE(nsHTMLCanvasElement,
21218:                                                nsGenericHTMLElement)
 4838: NS_HTML_CONTENT_INTERFACE_TABLE_TAIL_CLASSINFO(HTMLCanvasElement)
    1: 
    1: NS_IMPL_ELEMENT_CLONE(nsHTMLCanvasElement)
    1: 
    1: nsIntSize
    1: nsHTMLCanvasElement::GetWidthHeight()
    1: {
70071:   nsIntSize size(DEFAULT_CANVAS_WIDTH, DEFAULT_CANVAS_HEIGHT);
    1:   const nsAttrValue* value;
    1: 
    1:   if ((value = GetParsedAttr(nsGkAtoms::width)) &&
    1:       value->Type() == nsAttrValue::eInteger)
    1:   {
    1:       size.width = value->GetIntegerValue();
    1:   }
    1: 
    1:   if ((value = GetParsedAttr(nsGkAtoms::height)) &&
    1:       value->Type() == nsAttrValue::eInteger)
    1:   {
    1:       size.height = value->GetIntegerValue();
    1:   }
    1: 
    1:   return size;
    1: }
    1: 
63873: NS_IMPL_UINT_ATTR_DEFAULT_VALUE(nsHTMLCanvasElement, Width, width, DEFAULT_CANVAS_WIDTH)
63873: NS_IMPL_UINT_ATTR_DEFAULT_VALUE(nsHTMLCanvasElement, Height, height, DEFAULT_CANVAS_HEIGHT)
15234: NS_IMPL_BOOL_ATTR(nsHTMLCanvasElement, MozOpaque, moz_opaque)
    1: 
    1: nsresult
    1: nsHTMLCanvasElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                              nsIAtom* aPrefix, const nsAString& aValue,
    1:                              PRBool aNotify)
    1: {
    1:   nsresult rv = nsGenericHTMLElement::SetAttr(aNameSpaceID, aName, aPrefix, aValue,
    1:                                               aNotify);
    1:   if (NS_SUCCEEDED(rv) && mCurrentContext &&
15234:       (aName == nsGkAtoms::width || aName == nsGkAtoms::height || aName == nsGkAtoms::moz_opaque))
    1:   {
    1:     rv = UpdateContext();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
35581: nsresult
35581: nsHTMLCanvasElement::CopyInnerTo(nsGenericElement* aDest) const
35581: {
35581:   nsresult rv = nsGenericHTMLElement::CopyInnerTo(aDest);
35581:   NS_ENSURE_SUCCESS(rv, rv);
35581:   if (aDest->GetOwnerDoc()->IsStaticDocument()) {
35581:     nsHTMLCanvasElement* dest = static_cast<nsHTMLCanvasElement*>(aDest);
35581:     nsCOMPtr<nsISupports> cxt;
57631:     dest->GetContext(NS_LITERAL_STRING("2d"), JSVAL_VOID, getter_AddRefs(cxt));
35581:     nsCOMPtr<nsIDOMCanvasRenderingContext2D> context2d = do_QueryInterface(cxt);
35581:     if (context2d) {
35581:       context2d->DrawImage(const_cast<nsHTMLCanvasElement*>(this),
35581:                            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0);
35581:     }
35581:   }
35581:   return rv;
35581: }
35581: 
    1: nsChangeHint
    1: nsHTMLCanvasElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                             PRInt32 aModType) const
    1: {
    1:   nsChangeHint retval =
    1:     nsGenericHTMLElement::GetAttributeChangeHint(aAttribute, aModType);
    1:   if (aAttribute == nsGkAtoms::width ||
    1:       aAttribute == nsGkAtoms::height)
    1:   {
    1:     NS_UpdateHint(retval, NS_STYLE_HINT_REFLOW);
15234:   } else if (aAttribute == nsGkAtoms::moz_opaque)
15234:   {
15234:     NS_UpdateHint(retval, NS_STYLE_HINT_VISUAL);
    1:   }
    1:   return retval;
    1: }
    1: 
    1: PRBool
    1: nsHTMLCanvasElement::ParseAttribute(PRInt32 aNamespaceID,
    1:                                     nsIAtom* aAttribute,
    1:                                     const nsAString& aValue,
    1:                                     nsAttrValue& aResult)
    1: {
41186:   if (aNamespaceID == kNameSpaceID_None &&
41186:       (aAttribute == nsGkAtoms::width || aAttribute == nsGkAtoms::height)) {
63873:     return aResult.ParseNonNegativeIntValue(aValue);
    1:   }
    1: 
    1:   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
    1:                                               aResult);
    1: }
    1: 
    1: 
    1: // nsHTMLCanvasElement::toDataURL
    1: 
    1: NS_IMETHODIMP
70899: nsHTMLCanvasElement::ToDataURL(const nsAString& aType, nsIVariant* aParams,
34226:                                PRUint8 optional_argc, nsAString& aDataURL)
    1: {
    1:   // do a trust check if this is a write-only canvas
70899:   if (mWriteOnly && !nsContentUtils::IsCallerTrustedForRead()) {
    1:     return NS_ERROR_DOM_SECURITY_ERR;
    1:   }
    1: 
47330:   return ToDataURLImpl(aType, aParams, aDataURL);
    1: }
    1: 
    1: nsresult
54294: nsHTMLCanvasElement::ExtractData(const nsAString& aType,
54294:                                  const nsAString& aOptions,
71465:                                  nsIInputStream** aStream,
54294:                                  bool& aFellBackToPNG)
    1: {
57631:   // note that if we don't have a current context, the spec says we're
57631:   // supposed to just return transparent black pixels of the canvas
57631:   // dimensions.
57631:   nsRefPtr<gfxImageSurface> emptyCanvas;
57631:   nsIntSize size = GetWidthHeight();
57631:   if (!mCurrentContext) {
57631:     emptyCanvas = new gfxImageSurface(gfxIntSize(size.width, size.height), gfxASurface::ImageFormatARGB32);
77274:     if (emptyCanvas->CairoStatus()) {
77274:       return NS_ERROR_INVALID_ARG;
77274:     }
51845:   }
    1: 
57631:   nsresult rv;
57631: 
    1:   // get image bytes
    1:   nsCOMPtr<nsIInputStream> imgStream;
64432:   NS_ConvertUTF16toUTF8 encoderType(aType);
57631: 
57631:  try_again:
57631:   if (mCurrentContext) {
71728:     rv = mCurrentContext->GetInputStream(encoderType.get(),
54294:                                          nsPromiseFlatString(aOptions).get(),
    1:                                          getter_AddRefs(imgStream));
57631:   } else {
57631:     // no context, so we have to encode the empty image we created above
57631:     nsCString enccid("@mozilla.org/image/encoder;2?type=");
57631:     enccid += encoderType;
57631: 
71728:     nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(enccid.get(), &rv);
57631:     if (NS_SUCCEEDED(rv) && encoder) {
57631:       rv = encoder->InitFromData(emptyCanvas->Data(),
57631:                                  size.width * size.height * 4,
57631:                                  size.width,
57631:                                  size.height,
57631:                                  size.width * 4,
57631:                                  imgIEncoder::INPUT_FORMAT_HOSTARGB,
57631:                                  aOptions);
57631:       if (NS_SUCCEEDED(rv)) {
57631:         imgStream = do_QueryInterface(encoder);
57631:       }
57631:     } else {
57631:       rv = NS_ERROR_FAILURE;
57631:     }
57631:   }
57631: 
57631:   if (NS_FAILED(rv) && !aFellBackToPNG) {
57631:     // Try image/png instead.
    1:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
54294:     aFellBackToPNG = true;
57631:     encoderType.AssignLiteral("image/png");
57631:     goto try_again;
57631:   }
57631: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
71465:   return CallQueryInterface(imgStream, aStream);
54294:   return NS_OK;
54294: }
54294: 
54294: nsresult
54294: nsHTMLCanvasElement::ToDataURLImpl(const nsAString& aMimeType,
70899:                                    nsIVariant* aEncoderOptions,
54294:                                    nsAString& aDataURL)
54294: {
54294:   bool fallbackToPNG = false;
57631: 
70118:   nsIntSize size = GetWidthHeight();
70118:   if (size.height == 0 || size.width == 0) {
70118:     aDataURL = NS_LITERAL_STRING("data:,");
70118:     return NS_OK;
70118:   }
70118: 
64432:   nsAutoString type;
64432:   nsContentUtils::ASCIIToLower(aMimeType, type);
64432: 
70899:   nsAutoString params;
70899: 
70899:   // Quality parameter is only valid for the image/jpeg MIME type
70899:   if (type.EqualsLiteral("image/jpeg")) {
70899:     PRUint16 vartype;
70899: 
70899:     if (aEncoderOptions &&
70899:         NS_SUCCEEDED(aEncoderOptions->GetDataType(&vartype)) &&
70899:         vartype <= nsIDataType::VTYPE_DOUBLE) {
70899: 
70899:       double quality;
70899:       // Quality must be between 0.0 and 1.0, inclusive
70899:       if (NS_SUCCEEDED(aEncoderOptions->GetAsDouble(&quality)) &&
70899:           quality >= 0.0 && quality <= 1.0) {
70899:         params.AppendLiteral("quality=");
70899:         params.AppendInt(NS_lround(quality * 100.0));
70899:       }
70899:     }
70899:   }
70899: 
77231:   // If we haven't parsed the params check for proprietary options.
77231:   // The proprietary option -moz-parse-options will take a image lib encoder
77231:   // parse options string as is and pass it to the encoder.
77231:   PRBool usingCustomParseOptions = PR_FALSE;
77231:   if (params.Length() == 0) {
77231:     NS_NAMED_LITERAL_STRING(mozParseOptions, "-moz-parse-options:");
77231:     nsAutoString paramString;
77231:     if (NS_SUCCEEDED(aEncoderOptions->GetAsAString(paramString)) && 
77231:         StringBeginsWith(paramString, mozParseOptions)) {
77231:       nsDependentSubstring parseOptions = Substring(paramString, 
77231:                                                     mozParseOptions.Length(), 
77231:                                                     paramString.Length() - 
77231:                                                     mozParseOptions.Length());
77231:       params.Append(parseOptions);
77231:       usingCustomParseOptions = PR_TRUE;
77231:     }
77231:   }
77231: 
71465:   nsCOMPtr<nsIInputStream> stream;
71465:   nsresult rv = ExtractData(type, params, getter_AddRefs(stream),
71465:                             fallbackToPNG);
77231: 
77231:   // If there are unrecognized custom parse options, we should fall back to 
77231:   // the default values for the encoder without any options at all.
77231:   if (rv == NS_ERROR_INVALID_ARG && usingCustomParseOptions) {
77231:     fallbackToPNG = false;
77231:     rv = ExtractData(type, EmptyString(), getter_AddRefs(stream), fallbackToPNG);
77231:   }
77231: 
54294:   NS_ENSURE_SUCCESS(rv, rv);
54294: 
    1:   // build data URL string
47330:   if (fallbackToPNG)
71465:     aDataURL = NS_LITERAL_STRING("data:image/png;base64,");
47330:   else
64432:     aDataURL = NS_LITERAL_STRING("data:") + type +
71465:       NS_LITERAL_STRING(";base64,");
    1: 
71465:   PRUint32 count;
71465:   rv = stream->Available(&count);
71465:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
71465:   return Base64EncodeInputStream(stream, aDataURL, count, aDataURL.Length());
    1: }
    1: 
54294: NS_IMETHODIMP
54294: nsHTMLCanvasElement::MozGetAsFile(const nsAString& aName,
54294:                                   const nsAString& aType,
54294:                                   PRUint8 optional_argc,
54294:                                   nsIDOMFile** aResult)
54294: {
54294:   // do a trust check if this is a write-only canvas
54294:   if ((mWriteOnly) &&
54294:       !nsContentUtils::IsCallerTrustedForRead()) {
54294:     return NS_ERROR_DOM_SECURITY_ERR;
54294:   }
54294: 
54294:   return MozGetAsFileImpl(aName, aType, aResult);
54294: }
54294: 
54294: nsresult
54294: nsHTMLCanvasElement::MozGetAsFileImpl(const nsAString& aName,
54294:                                       const nsAString& aType,
54294:                                       nsIDOMFile** aResult)
54294: {
54294:   bool fallbackToPNG = false;
54294: 
71465:   nsCOMPtr<nsIInputStream> stream;
71465:   nsresult rv = ExtractData(aType, EmptyString(), getter_AddRefs(stream),
71465:                             fallbackToPNG);
54294:   NS_ENSURE_SUCCESS(rv, rv);
54294: 
54294:   nsAutoString type(aType);
54294:   if (fallbackToPNG) {
54294:     type.AssignLiteral("image/png");
54294:   }
54294: 
71465:   PRUint32 imgSize;
71465:   rv = stream->Available(&imgSize);
71465:   NS_ENSURE_SUCCESS(rv, rv);
71465: 
71465:   void* imgData = nsnull;
71465:   rv = NS_ReadInputStreamToBuffer(stream, &imgData, imgSize);
71465:   NS_ENSURE_SUCCESS(rv, rv);
71465: 
54294:   // The DOMFile takes ownership of the buffer
54294:   nsRefPtr<nsDOMMemoryFile> file =
71465:     new nsDOMMemoryFile(imgData, imgSize, aName, type);
54294: 
54294:   return CallQueryInterface(file, aResult);
54294: }
54294: 
46756: nsresult
46756: nsHTMLCanvasElement::GetContextHelper(const nsAString& aContextId,
73612:                                       PRBool aForceThebes,
46756:                                       nsICanvasRenderingContextInternal **aContext)
    1: {
46756:   NS_ENSURE_ARG(aContext);
    1: 
73612:   NS_ConvertUTF16toUTF8 ctxId(aContextId);
    1: 
    1:   // check that ctxId is clamped to A-Za-z0-9_-
    1:   for (PRUint32 i = 0; i < ctxId.Length(); i++) {
    1:     if ((ctxId[i] < 'A' || ctxId[i] > 'Z') &&
    1:         (ctxId[i] < 'a' || ctxId[i] > 'z') &&
    1:         (ctxId[i] < '0' || ctxId[i] > '9') &&
    1:         (ctxId[i] != '-') &&
    1:         (ctxId[i] != '_'))
    1:     {
    1:       // XXX ERRMSG we need to report an error to developers here! (bug 329026)
47330:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   nsCString ctxString("@mozilla.org/content/canvas-rendering-context;1?id=");
    1:   ctxString.Append(ctxId);
    1: 
73612:   if (aForceThebes && ctxId.EqualsASCII("2d")) {
73612:     ctxString.AssignASCII("@mozilla.org/content/2dthebes-canvas-rendering-context;1");
73612:   }
73612: 
46756:   nsresult rv;
46756:   nsCOMPtr<nsICanvasRenderingContextInternal> ctx =
71728:     do_CreateInstance(ctxString.get(), &rv);
46756:   if (rv == NS_ERROR_OUT_OF_MEMORY) {
46756:     *aContext = nsnull;
    1:     return NS_ERROR_OUT_OF_MEMORY;
46756:   }
46756:   if (NS_FAILED(rv)) {
46756:     *aContext = nsnull;
42402:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
47330:     return NS_OK;
46756:   }
42402: 
46756:   rv = ctx->SetCanvasElement(this);
42402:   if (NS_FAILED(rv)) {
46756:     *aContext = nsnull;
42402:     return rv;
42402:   }
42402: 
46756:   *aContext = ctx.forget().get();
46756: 
46756:   return rv;
46756: }
46756: 
46756: NS_IMETHODIMP
46756: nsHTMLCanvasElement::GetContext(const nsAString& aContextId,
57631:                                 const jsval& aContextOptions,
46756:                                 nsISupports **aContext)
46756: {
46756:   nsresult rv;
46756: 
73612:   PRBool forceThebes = PR_FALSE;
73612: 
73612:   while (mCurrentContextId.IsEmpty()) {
73612:     rv = GetContextHelper(aContextId, forceThebes, getter_AddRefs(mCurrentContext));
47720:     NS_ENSURE_SUCCESS(rv, rv);
47720:     if (!mCurrentContext) {
47720:       return NS_OK;
47720:     }
    1: 
43655:     // Ensure that the context participates in CC.  Note that returning a
43655:     // CC participant from QI doesn't addref.
43655:     nsXPCOMCycleCollectionParticipant *cp = nsnull;
43655:     CallQueryInterface(mCurrentContext, &cp);
43655:     if (!cp) {
43655:       mCurrentContext = nsnull;
43655:       return NS_ERROR_FAILURE;
43655:     }
43655: 
57631:     nsCOMPtr<nsIPropertyBag> contextProps;
57631:     if (!JSVAL_IS_NULL(aContextOptions) &&
57631:         !JSVAL_IS_VOID(aContextOptions))
57631:     {
57631:       JSContext *cx = nsContentUtils::GetCurrentJSContext();
57631: 
57631:       nsCOMPtr<nsIWritablePropertyBag2> newProps;
57631: 
57631:       // note: if any contexts end up supporting something other
57631:       // than objects, e.g. plain strings, then we'll need to expand
57631:       // this to know how to create nsISupportsStrings etc.
57631:       if (JSVAL_IS_OBJECT(aContextOptions)) {
57631:         newProps = do_CreateInstance("@mozilla.org/hash-property-bag;1");
57631: 
57631:         JSObject *opts = JSVAL_TO_OBJECT(aContextOptions);
57631:         JSIdArray *props = JS_Enumerate(cx, opts);
57631:         for (int i = 0; props && i < props->length; ++i) {
57631:           jsid propid = props->vector[i];
57631:           jsval propname, propval;
57631:           if (!JS_IdToValue(cx, propid, &propname) ||
57631:               !JS_GetPropertyById(cx, opts, propid, &propval))
57631:           {
57631:             continue;
57631:           }
57631: 
57631:           JSString *propnameString = JS_ValueToString(cx, propname);
59889:           nsDependentJSString pstr;
59889:           if (!propnameString || !pstr.init(cx, propnameString)) {
59889:             mCurrentContext = nsnull;
59889:             return NS_ERROR_FAILURE;
59889:           }
57631: 
57631:           if (JSVAL_IS_BOOLEAN(propval)) {
57631:             newProps->SetPropertyAsBool(pstr, propval == JSVAL_TRUE ? PR_TRUE : PR_FALSE);
57631:           } else if (JSVAL_IS_INT(propval)) {
57631:             newProps->SetPropertyAsInt32(pstr, JSVAL_TO_INT(propval));
57631:           } else if (JSVAL_IS_DOUBLE(propval)) {
57631:             newProps->SetPropertyAsDouble(pstr, JSVAL_TO_DOUBLE(propval));
57631:           } else if (JSVAL_IS_STRING(propval)) {
59889:             JSString *propvalString = JS_ValueToString(cx, propval);
59889:             nsDependentJSString vstr;
59889:             if (!propvalString || !vstr.init(cx, propvalString)) {
59889:               mCurrentContext = nsnull;
59889:               return NS_ERROR_FAILURE;
59889:             }
59889: 
59889:             newProps->SetPropertyAsAString(pstr, vstr);
57631:           }
57631:         }
57631:       }
57631: 
57631:       contextProps = newProps;
57631:     }
57631: 
57631:     rv = UpdateContext(contextProps);
 2756:     if (NS_FAILED(rv)) {
73612:       if (!forceThebes) {
73612:         // Try again with a Thebes context
73612:         forceThebes = PR_TRUE;
73612:         continue;
73612:       }
 2756:       return rv;
 2756:     }
    1: 
    1:     mCurrentContextId.Assign(aContextId);
73612:     break;
73612:   }
73612:   if (!mCurrentContextId.Equals(aContextId)) {
    1:     //XXX eventually allow for more than one active context on a given canvas
47330:     return NS_OK;
    1:   }
    1: 
    1:   NS_ADDREF (*aContext = mCurrentContext);
    1:   return NS_OK;
    1: }
    1: 
46756: NS_IMETHODIMP
46902: nsHTMLCanvasElement::MozGetIPCContext(const nsAString& aContextId,
46756:                                       nsISupports **aContext)
46756: {
46756:   if(!nsContentUtils::IsCallerTrustedForRead()) {
46756:     // XXX ERRMSG we need to report an error to developers here! (bug 329026)
46756:     return NS_ERROR_DOM_SECURITY_ERR;
46756:   }
46756: 
46756:   // We only support 2d shmem contexts for now.
46756:   if (!aContextId.Equals(NS_LITERAL_STRING("2d")))
46756:     return NS_ERROR_INVALID_ARG;
46756: 
46756:   nsresult rv;
46756: 
46756:   if (mCurrentContextId.IsEmpty()) {
73612:     rv = GetContextHelper(aContextId, PR_FALSE, getter_AddRefs(mCurrentContext));
47720:     NS_ENSURE_SUCCESS(rv, rv);
47720:     if (!mCurrentContext) {
47720:       return NS_OK;
47720:     }
46756: 
46902:     mCurrentContext->SetIsIPC(PR_TRUE);
46756: 
46756:     rv = UpdateContext();
74620:     NS_ENSURE_SUCCESS(rv, rv);
46756: 
46756:     mCurrentContextId.Assign(aContextId);
46756:   } else if (!mCurrentContextId.Equals(aContextId)) {
46756:     //XXX eventually allow for more than one active context on a given canvas
46756:     return NS_ERROR_INVALID_ARG;
46756:   }
46756: 
46756:   NS_ADDREF (*aContext = mCurrentContext);
46756:   return NS_OK;
46756: }
46756: 
    1: nsresult
57631: nsHTMLCanvasElement::UpdateContext(nsIPropertyBag *aNewContextOptions)
    1: {
57631:   if (!mCurrentContext)
57631:     return NS_OK;
57631: 
    1:   nsresult rv = NS_OK;
70173:   nsIntSize sz = GetWidthHeight();
57631: 
57631:   rv = mCurrentContext->SetIsOpaque(GetIsOpaque());
70173:   if (NS_FAILED(rv)) {
70173:     mCurrentContext = nsnull;
74779:     mCurrentContextId.AssignLiteral("");
57631:     return rv;
70173:   }
57631: 
57631:   rv = mCurrentContext->SetContextOptions(aNewContextOptions);
70173:   if (NS_FAILED(rv)) {
70173:     mCurrentContext = nsnull;
74779:     mCurrentContextId.AssignLiteral("");
57631:     return rv;
70173:   }
57631: 
    1:   rv = mCurrentContext->SetDimensions(sz.width, sz.height);
70173:   if (NS_FAILED(rv)) {
70173:     mCurrentContext = nsnull;
74779:     mCurrentContextId.AssignLiteral("");
57631:     return rv;
70173:   }
    1: 
    1:   return rv;
    1: }
    1: 
42402: nsIFrame *
42402: nsHTMLCanvasElement::GetPrimaryCanvasFrame()
    1: {
42402:   return GetPrimaryFrame(Flush_Frames);
    1: }
    1: 
42402: nsIntSize
42402: nsHTMLCanvasElement::GetSize()
    1: {
42402:   return GetWidthHeight();
    1: }
    1: 
    1: PRBool
    1: nsHTMLCanvasElement::IsWriteOnly()
    1: {
    1:   return mWriteOnly;
    1: }
    1: 
    1: void
    1: nsHTMLCanvasElement::SetWriteOnly()
    1: {
    1:   mWriteOnly = PR_TRUE;
    1: }
 6313: 
42402: void
64542: nsHTMLCanvasElement::InvalidateCanvasContent(const gfxRect* damageRect)
 6313: {
30125:   // We don't need to flush anything here; if there's no frame or if
30125:   // we plan to reframe we don't need to invalidate it anyway.
36655:   nsIFrame *frame = GetPrimaryFrame();
42402:   if (!frame)
42402:     return;
 6313: 
72242:   frame->MarkLayersActive(nsChangeHint(0));
64542: 
64542:   nsRect invalRect;
64542:   nsRect contentArea = frame->GetContentRect();
42402:   if (damageRect) {
27097:     nsIntSize size = GetWidthHeight();
70071:     if (size.width != 0 && size.height != 0) {
27097: 
27097:       // damageRect and size are in CSS pixels; contentArea is in appunits
27097:       // We want a rect in appunits; so avoid doing pixels-to-appunits and
27097:       // vice versa conversion here.
42402:       gfxRect realRect(*damageRect);
27097:       realRect.Scale(contentArea.width / gfxFloat(size.width),
27097:                      contentArea.height / gfxFloat(size.height));
27097:       realRect.RoundOut();
27097: 
27097:       // then make it a nsRect
64542:       invalRect = nsRect(realRect.X(), realRect.Y(),
27097:                          realRect.Width(), realRect.Height());
70071:     }
64542:   } else {
64542:     invalRect = nsRect(nsPoint(0, 0), contentArea.Size());
64542:   }
27097:   invalRect.MoveBy(contentArea.TopLeft() - frame->GetPosition());
27097: 
64542:   Layer* layer = frame->InvalidateLayer(invalRect, nsDisplayItem::TYPE_CANVAS);
64542:   if (layer) {
64542:     static_cast<CanvasLayer*>(layer)->Updated();
 6313:   }
 6313: }
14812: 
64542: void
64542: nsHTMLCanvasElement::InvalidateCanvas()
64542: {
64542:   // We don't need to flush anything here; if there's no frame or if
64542:   // we plan to reframe we don't need to invalidate it anyway.
64542:   nsIFrame *frame = GetPrimaryFrame();
64542:   if (!frame)
64542:     return;
64542: 
64542:   frame->Invalidate(frame->GetContentRect() - frame->GetPosition());
64542: }
64542: 
14812: PRInt32
14812: nsHTMLCanvasElement::CountContexts()
14812: {
14812:   if (mCurrentContext)
14812:     return 1;
14812: 
14812:   return 0;
14812: }
14812: 
14812: nsICanvasRenderingContextInternal *
14812: nsHTMLCanvasElement::GetContextAtIndex (PRInt32 index)
14812: {
14812:   if (mCurrentContext && index == 0)
14812:     return mCurrentContext.get();
14812: 
14812:   return NULL;
14812: }
25788: 
25788: PRBool
25788: nsHTMLCanvasElement::GetIsOpaque()
25788: {
25788:   return HasAttr(kNameSpaceID_None, nsGkAtoms::moz_opaque);
25788: }
42402: 
42402: already_AddRefed<CanvasLayer>
64542: nsHTMLCanvasElement::GetCanvasLayer(nsDisplayListBuilder* aBuilder,
64542:                                     CanvasLayer *aOldLayer,
47731:                                     LayerManager *aManager)
42402: {
42402:   if (!mCurrentContext)
42402:     return nsnull;
42402: 
64542:   return mCurrentContext->GetCanvasLayer(aBuilder, aOldLayer, aManager);
42402: }
42402: 
73612: PRBool
73612: nsHTMLCanvasElement::ShouldForceInactiveLayer(LayerManager *aManager)
73612: {
73612:   return !mCurrentContext || mCurrentContext->ShouldForceInactiveLayer(aManager);
73612: }
73612: 
42402: void
42402: nsHTMLCanvasElement::MarkContextClean()
42402: {
42402:   if (!mCurrentContext)
42402:     return;
42402: 
42402:   mCurrentContext->MarkContextClean();
42402: }
42402: 
42402: NS_IMETHODIMP_(nsIntSize)
42402: nsHTMLCanvasElement::GetSizeExternal()
42402: {
42402:   return GetWidthHeight();
42402: }
42402: 
42402: NS_IMETHODIMP
42402: nsHTMLCanvasElement::RenderContextsExternal(gfxContext *aContext, gfxPattern::GraphicsFilter aFilter)
42402: {
42402:   if (!mCurrentContext)
42402:     return NS_OK;
42402: 
42402:   return mCurrentContext->Render(aContext, aFilter);
42402: }
72429: 
72429: nsresult NS_NewCanvasRenderingContext2DThebes(nsIDOMCanvasRenderingContext2D** aResult);
72429: nsresult NS_NewCanvasRenderingContext2DAzure(nsIDOMCanvasRenderingContext2D** aResult);
72429: 
72429: nsresult
72429: NS_NewCanvasRenderingContext2D(nsIDOMCanvasRenderingContext2D** aResult)
72429: {
73023:   if (Preferences::GetBool("gfx.canvas.azure.enabled", PR_FALSE)) {
72429:     nsresult rv = NS_NewCanvasRenderingContext2DAzure(aResult);
72429:     // If Azure fails, fall back to a classic canvas.
72429:     if (NS_SUCCEEDED(rv)) {
72429:       return rv;
72429:     }
72429:   }
72429: 
72429:   return NS_NewCanvasRenderingContext2DThebes(aResult);
72429: }
