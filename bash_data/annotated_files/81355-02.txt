75157: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
54814:  * ***** BEGIN LICENSE BLOCK *****
54814:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
54814:  *
54814:  * The contents of this file are subject to the Mozilla Public License Version
54814:  * 1.1 (the "License"); you may not use this file except in compliance with
54814:  * the License. You may obtain a copy of the License at
54814:  * http://www.mozilla.org/MPL/
54814:  *
54814:  * Software distributed under the License is distributed on an "AS IS" basis,
54814:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
54814:  * for the specific language governing rights and limitations under the
54814:  * License.
54814:  *
54814:  * The Original Code is Mozilla Corporation code.
54814:  *
54814:  * The Initial Developer of the Original Code is Mozilla Foundation.
54814:  * Portions created by the Initial Developer are Copyright (C) 2009
54814:  * the Initial Developer. All Rights Reserved.
54814:  *
54814:  * Contributor(s):
54814:  *   Bas Schouten <bschouten@mozilla.com>
54814:  *
54814:  * Alternatively, the contents of this file may be used under the terms of
54814:  * either the GNU General Public License Version 2 or later (the "GPL"), or
54814:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
54814:  * in which case the provisions of the GPL or the LGPL are applicable instead
54814:  * of those above. If you wish to allow use of your version of this file only
54814:  * under the terms of either the GPL or the LGPL, and not to allow others to
54814:  * use your version of this file under the terms of the MPL, indicate your
54814:  * decision by deleting the provisions above and replace them with the notice
54814:  * and other provisions required by the GPL or the LGPL. If you do not delete
54814:  * the provisions above, a recipient may use your version of this file under
54814:  * the terms of any one of the MPL, the GPL or the LGPL.
54814:  *
54814:  * ***** END LICENSE BLOCK ***** */
54814: 
75156: #include <algorithm>
75156: 
54814: #include "LayerManagerD3D10.h"
54814: #include "LayerManagerD3D10Effect.h"
54814: #include "gfxWindowsPlatform.h"
54814: #include "gfxD2DSurface.h"
62254: #include "gfxFailure.h"
54814: #include "cairo-win32.h"
54814: #include "dxgi.h"
54814: 
54814: #include "ContainerLayerD3D10.h"
54814: #include "ThebesLayerD3D10.h"
54814: #include "ColorLayerD3D10.h"
54814: #include "CanvasLayerD3D10.h"
62702: #include "ReadbackLayerD3D10.h"
54814: #include "ImageLayerD3D10.h"
75157: #include "mozilla/layers/PLayerChild.h"
54814: 
60419: #include "../d3d9/Nv3DVUtils.h"
60419: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
75156: using namespace std;
72426: using namespace mozilla::gfx;
72426: 
54814: namespace mozilla {
54814: namespace layers {
54814: 
54814: typedef HRESULT (WINAPI*D3D10CreateEffectFromMemoryFunc)(
54814:     void *pData,
54814:     SIZE_T DataLength,
54814:     UINT FXFlags,
54814:     ID3D10Device *pDevice, 
54814:     ID3D10EffectPool *pEffectPool,
54814:     ID3D10Effect **ppEffect
54814: );
54814: 
54814: struct Vertex
54814: {
54814:     float position[2];
54814: };
54814: 
62702: // {592BF306-0EED-4F76-9D03-A0846450F472}
62702: static const GUID sDeviceAttachments = 
62702: { 0x592bf306, 0xeed, 0x4f76, { 0x9d, 0x3, 0xa0, 0x84, 0x64, 0x50, 0xf4, 0x72 } };
62702: // {716AEDB1-C9C3-4B4D-8332-6F65D44AF6A8}
62702: static const GUID sLayerManagerCount = 
62702: { 0x716aedb1, 0xc9c3, 0x4b4d, { 0x83, 0x32, 0x6f, 0x65, 0xd4, 0x4a, 0xf6, 0xa8 } };
54814: 
54814: cairo_user_data_key_t gKeyD3D10Texture;
54814: 
54814: LayerManagerD3D10::LayerManagerD3D10(nsIWidget *aWidget)
54814:   : mWidget(aWidget)
54814: {
54814: }
54814: 
62702: struct DeviceAttachments
62702: {
62702:   nsRefPtr<ID3D10Effect> mEffect;
62702:   nsRefPtr<ID3D10InputLayout> mInputLayout;
62702:   nsRefPtr<ID3D10Buffer> mVertexBuffer;
62702:   nsRefPtr<ReadbackManagerD3D10> mReadbackManager;
62702: };
62702: 
54814: LayerManagerD3D10::~LayerManagerD3D10()
54814: {
62702:   if (mDevice) {
62702:     int referenceCount = 0;
62702:     UINT size = sizeof(referenceCount);
62702:     HRESULT hr = mDevice->GetPrivateData(sLayerManagerCount, &size, &referenceCount);
62702:     NS_ASSERTION(SUCCEEDED(hr), "Reference count not found on device.");
62702:     referenceCount--;
62702:     mDevice->SetPrivateData(sLayerManagerCount, sizeof(referenceCount), &referenceCount);
62702: 
62702:     if (!referenceCount) {
62702:       DeviceAttachments *attachments;
62702:       size = sizeof(attachments);
62702:       mDevice->GetPrivateData(sDeviceAttachments, &size, &attachments);
62702:       // No LayerManagers left for this device. Clear out interfaces stored which
62702:       // hold a reference to the device.
62702:       mDevice->SetPrivateData(sDeviceAttachments, 0, NULL);
62702: 
62702:       delete attachments;
62702:     }
62702:   }
62702: 
56116:   Destroy();
54814: }
54814: 
54814: bool
54814: LayerManagerD3D10::Initialize()
54814: {
63285:   ScopedGfxFeatureReporter reporter("D3D10 Layers");
63285: 
54814:   HRESULT hr;
54814: 
60419:   /* Create an Nv3DVUtils instance */
60419:   if (!mNv3DVUtils) {
60419:     mNv3DVUtils = new Nv3DVUtils();
60419:     if (!mNv3DVUtils) {
60419:       NS_WARNING("Could not create a new instance of Nv3DVUtils.\n");
60419:     }
60419:   }
60419: 
60419:   /* Initialize the Nv3DVUtils object */
60419:   if (mNv3DVUtils) {
60419:     mNv3DVUtils->Initialize();
60419:   }
60419: 
60089:   mDevice = gfxWindowsPlatform::GetPlatform()->GetD3D10Device();
60089:   if (!mDevice) {
54814:       return false;
54814:   }
54814: 
60419:   /*
60419:    * Do some post device creation setup
60419:    */
60419:   if (mNv3DVUtils) {
60419:     IUnknown* devUnknown = NULL;
60419:     if (mDevice) {
60419:       mDevice->QueryInterface(IID_IUnknown, (void **)&devUnknown);
60419:     }
60419:     mNv3DVUtils->SetDeviceInfo(devUnknown);
60419:   }
60419: 
62702:   int referenceCount = 0;
62702:   UINT size = sizeof(referenceCount);
62702:   // If this isn't there yet it'll fail, count will remain 0, which is correct.
62702:   mDevice->GetPrivateData(sLayerManagerCount, &size, &referenceCount);
62702:   referenceCount++;
62702:   mDevice->SetPrivateData(sLayerManagerCount, sizeof(referenceCount), &referenceCount);
62702: 
62702:   DeviceAttachments *attachments;
62702:   size = sizeof(DeviceAttachments*);
62702:   if (FAILED(mDevice->GetPrivateData(sDeviceAttachments, &size, &attachments))) {
62702:     attachments = new DeviceAttachments;
62702:     mDevice->SetPrivateData(sDeviceAttachments, sizeof(attachments), &attachments);
62702: 
54814:     D3D10CreateEffectFromMemoryFunc createEffect = (D3D10CreateEffectFromMemoryFunc)
54814: 	GetProcAddress(LoadLibraryA("d3d10_1.dll"), "D3D10CreateEffectFromMemory");
54814: 
54814:     if (!createEffect) {
54814:       return false;
54814:     }
54814: 
54814:     hr = createEffect((void*)g_main,
54814:                       sizeof(g_main),
54814:                       D3D10_EFFECT_SINGLE_THREADED,
54814:                       mDevice,
54814:                       NULL,
54814:                       getter_AddRefs(mEffect));
54814:     
54814:     if (FAILED(hr)) {
54814:       return false;
54814:     }
54814: 
62702:     attachments->mEffect = mEffect;
54814:   
54814:     D3D10_INPUT_ELEMENT_DESC layout[] =
54814:     {
54814:       { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0 },
54814:     };
54814:     D3D10_PASS_DESC passDesc;
54814:     mEffect->GetTechniqueByName("RenderRGBLayerPremul")->GetPassByIndex(0)->
54814:       GetDesc(&passDesc);
54814: 
54814:     hr = mDevice->CreateInputLayout(layout,
54814:                                     sizeof(layout) / sizeof(D3D10_INPUT_ELEMENT_DESC),
54814:                                     passDesc.pIAInputSignature,
54814:                                     passDesc.IAInputSignatureSize,
54814:                                     getter_AddRefs(mInputLayout));
54814:     
54814:     if (FAILED(hr)) {
54814:       return false;
54814:     }
54814: 
62702:     attachments->mInputLayout = mInputLayout;
54814:   
54814:     Vertex vertices[] = { {0.0, 0.0}, {1.0, 0.0}, {0.0, 1.0}, {1.0, 1.0} };
54814:     CD3D10_BUFFER_DESC bufferDesc(sizeof(vertices), D3D10_BIND_VERTEX_BUFFER);
54814:     D3D10_SUBRESOURCE_DATA data;
54814:     data.pSysMem = (void*)vertices;
54814: 
54814:     hr = mDevice->CreateBuffer(&bufferDesc, &data, getter_AddRefs(mVertexBuffer));
54814: 
54814:     if (FAILED(hr)) {
54814:       return false;
54814:     }
54814: 
62702:     attachments->mVertexBuffer = mVertexBuffer;
62702:   } else {
62702:     mEffect = attachments->mEffect;
62702:     mVertexBuffer = attachments->mVertexBuffer;
62702:     mInputLayout = attachments->mInputLayout;
54814:   }
54814: 
75156:   if (HasShadowManager()) {
75156:     reporter.SetSuccessful();
75156:     return true;
75156:   }
75156: 
54814:   nsRefPtr<IDXGIDevice> dxgiDevice;
54814:   nsRefPtr<IDXGIAdapter> dxgiAdapter;
54814:   nsRefPtr<IDXGIFactory> dxgiFactory;
54814: 
54814:   mDevice->QueryInterface(dxgiDevice.StartAssignment());
54814:   dxgiDevice->GetAdapter(getter_AddRefs(dxgiAdapter));
54814: 
54814:   dxgiAdapter->GetParent(IID_PPV_ARGS(dxgiFactory.StartAssignment()));
54814: 
54814:   DXGI_SWAP_CHAIN_DESC swapDesc;
54814:   ::ZeroMemory(&swapDesc, sizeof(swapDesc));
54814: 
54814:   swapDesc.BufferDesc.Width = 0;
54814:   swapDesc.BufferDesc.Height = 0;
54814:   swapDesc.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
54814:   swapDesc.BufferDesc.RefreshRate.Numerator = 60;
54814:   swapDesc.BufferDesc.RefreshRate.Denominator = 1;
54814:   swapDesc.SampleDesc.Count = 1;
54814:   swapDesc.SampleDesc.Quality = 0;
54814:   swapDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
54814:   swapDesc.BufferCount = 1;
59294:   // We don't really need this flag, however it seems on some NVidia hardware
59396:   // smaller area windows do not present properly without this flag. This flag
60236:   // should have no negative consequences by itself. See bug 613790. This flag
60236:   // is broken on optimus devices. As a temporary solution we don't set it
60236:   // there, the only way of reliably detecting we're on optimus is looking for
60236:   // the DLL. See Bug 623807.
63228:   if (gfxWindowsPlatform::IsOptimus()) {
60236:     swapDesc.Flags = 0;
60236:   } else {
59294:     swapDesc.Flags = DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE;
60236:   }
54814:   swapDesc.OutputWindow = (HWND)mWidget->GetNativeData(NS_NATIVE_WINDOW);
54814:   swapDesc.Windowed = TRUE;
54814: 
54814:   /**
54814:    * Create a swap chain, this swap chain will contain the backbuffer for
54814:    * the window we draw to. The front buffer is the full screen front
54814:    * buffer.
54814:    */
54814:   hr = dxgiFactory->CreateSwapChain(dxgiDevice, &swapDesc, getter_AddRefs(mSwapChain));
54814: 
54814:   if (FAILED(hr)) {
54814:     return false;
54814:   }
54814: 
55201:   // We need this because we don't want DXGI to respond to Alt+Enter.
55201:   dxgiFactory->MakeWindowAssociation(swapDesc.OutputWindow, DXGI_MWA_NO_WINDOW_CHANGES);
55201: 
63285:   reporter.SetSuccessful();
54814:   return true;
54814: }
54814: 
54814: void
56116: LayerManagerD3D10::Destroy()
56116: {
56116:   if (!IsDestroyed()) {
56116:     if (mRoot) {
56116:       static_cast<LayerD3D10*>(mRoot->ImplData())->LayerManagerDestroyed();
56116:     }
75158:     mRootForShadowTree = nsnull;
75158:     // XXX need to be careful here about surface destruction
75158:     // racing with share-to-chrome message
56116:   }
56116:   LayerManager::Destroy();
56116: }
56116: 
56116: void
54814: LayerManagerD3D10::SetRoot(Layer *aRoot)
54814: {
54814:   mRoot = aRoot;
54814: }
54814: 
54814: void
54814: LayerManagerD3D10::BeginTransaction()
54814: {
75150: #ifdef MOZ_LAYERS_HAVE_LOG
75150:   MOZ_LAYERS_LOG(("[----- BeginTransaction"));
75150:   Log();
75150: #endif
54814: }
54814: 
54814: void
54814: LayerManagerD3D10::BeginTransactionWithTarget(gfxContext* aTarget)
54814: {
54814:   mTarget = aTarget;
54814: }
54814: 
60859: bool
60859: LayerManagerD3D10::EndEmptyTransaction()
60859: {
60859:   if (!mRoot)
60859:     return false;
60859: 
60859:   EndTransaction(nsnull, nsnull);
60859:   return true;
60859: }
60859: 
59171: void
54814: LayerManagerD3D10::EndTransaction(DrawThebesLayerCallback aCallback,
78887:                                   void* aCallbackData,
78887:                                   EndTransactionFlags aFlags)
54814: {
78887:   if (mRoot && !(aFlags & END_NO_IMMEDIATE_REDRAW)) {
54814:     mCurrentCallbackInfo.Callback = aCallback;
54814:     mCurrentCallbackInfo.CallbackData = aCallbackData;
57097: 
57097:     // The results of our drawing always go directly into a pixel buffer,
57097:     // so we don't need to pass any global transform here.
57097:     mRoot->ComputeEffectiveTransforms(gfx3DMatrix());
57097: 
75150: #ifdef MOZ_LAYERS_HAVE_LOG
75150:     MOZ_LAYERS_LOG(("  ----- (beginning paint)"));
75150:     Log();
75150: #endif
75150: 
54814:     Render();
54814:     mCurrentCallbackInfo.Callback = nsnull;
54814:     mCurrentCallbackInfo.CallbackData = nsnull;
62292:   }
62292: 
75150: #ifdef MOZ_LAYERS_HAVE_LOG
75150:   Log();
75150:   MOZ_LAYERS_LOG(("]----- EndTransaction"));
75150: #endif
75150: 
54814:   mTarget = nsnull;
54814: }
54814: 
54814: already_AddRefed<ThebesLayer>
54814: LayerManagerD3D10::CreateThebesLayer()
54814: {
54814:   nsRefPtr<ThebesLayer> layer = new ThebesLayerD3D10(this);
54814:   return layer.forget();
54814: }
54814:  
75155: already_AddRefed<ShadowThebesLayer>
75155: LayerManagerD3D10::CreateShadowThebesLayer()
75155: {
75155:   nsRefPtr<ShadowThebesLayerD3D10> layer = new ShadowThebesLayerD3D10(this);
75155:   return layer.forget();
75155: }
75155: 
54814: already_AddRefed<ContainerLayer>
54814: LayerManagerD3D10::CreateContainerLayer()
54814: {
54814:   nsRefPtr<ContainerLayer> layer = new ContainerLayerD3D10(this);
54814:   return layer.forget();
54814: }
54814: 
75155: already_AddRefed<ShadowContainerLayer>
75155: LayerManagerD3D10::CreateShadowContainerLayer()
75155: {
75155:   nsRefPtr<ShadowContainerLayer> layer = new ShadowContainerLayerD3D10(this);
75155:   return layer.forget();
75155: }
75155: 
54814: already_AddRefed<ImageLayer>
54814: LayerManagerD3D10::CreateImageLayer()
54814: {
54814:   nsRefPtr<ImageLayer> layer = new ImageLayerD3D10(this);
54814:   return layer.forget();
54814: }
54814: 
54814: already_AddRefed<ColorLayer>
54814: LayerManagerD3D10::CreateColorLayer()
54814: {
54814:   nsRefPtr<ColorLayer> layer = new ColorLayerD3D10(this);
54814:   return layer.forget();
54814: }
54814: 
54814: already_AddRefed<CanvasLayer>
54814: LayerManagerD3D10::CreateCanvasLayer()
54814: {
54814:   nsRefPtr<CanvasLayer> layer = new CanvasLayerD3D10(this);
54814:   return layer.forget();
54814: }
54814: 
62702: already_AddRefed<ReadbackLayer>
62702: LayerManagerD3D10::CreateReadbackLayer()
62702: {
62702:   nsRefPtr<ReadbackLayer> layer = new ReadbackLayerD3D10(this);
62702:   return layer.forget();
62702: }
62702: 
54814: already_AddRefed<ImageContainer>
54814: LayerManagerD3D10::CreateImageContainer()
54814: {
59719:   nsRefPtr<ImageContainer> layer = new ImageContainerD3D10(mDevice);
54814:   return layer.forget();
54814: }
54814: 
54814: static void ReleaseTexture(void *texture)
54814: {
54814:   static_cast<ID3D10Texture2D*>(texture)->Release();
54814: }
54814: 
54814: already_AddRefed<gfxASurface>
54814: LayerManagerD3D10::CreateOptimalSurface(const gfxIntSize &aSize,
54814:                                    gfxASurface::gfxImageFormat aFormat)
54814: {
54814:   if ((aFormat != gfxASurface::ImageFormatRGB24 &&
54814:        aFormat != gfxASurface::ImageFormatARGB32)) {
54814:     return LayerManager::CreateOptimalSurface(aSize, aFormat);
54814:   }
54814: 
54814:   nsRefPtr<ID3D10Texture2D> texture;
54814:   
54814:   CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM, aSize.width, aSize.height, 1, 1);
54814:   desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
54814:   desc.MiscFlags = D3D10_RESOURCE_MISC_GDI_COMPATIBLE;
54814:   
54814:   HRESULT hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(texture));
54814: 
54814:   if (FAILED(hr)) {
54814:     NS_WARNING("Failed to create new texture for CreateOptimalSurface!");
54814:     return LayerManager::CreateOptimalSurface(aSize, aFormat);
54814:   }
54814: 
54814:   nsRefPtr<gfxD2DSurface> surface =
54814:     new gfxD2DSurface(texture, aFormat == gfxASurface::ImageFormatRGB24 ?
54814:       gfxASurface::CONTENT_COLOR : gfxASurface::CONTENT_COLOR_ALPHA);
54814: 
54814:   if (!surface || surface->CairoStatus()) {
54814:     return LayerManager::CreateOptimalSurface(aSize, aFormat);
54814:   }
54814: 
54814:   surface->SetData(&gKeyD3D10Texture,
54814:                    texture.forget().get(),
54814:                    ReleaseTexture);
54814: 
54814:   return surface.forget();
54814: }
54814: 
72426: TemporaryRef<DrawTarget>
72426: LayerManagerD3D10::CreateDrawTarget(const IntSize &aSize,
72426:                                     SurfaceFormat aFormat)
72426: {
72426:   if ((aFormat != FORMAT_B8G8R8A8 &&
72426:        aFormat != FORMAT_B8G8R8X8)) {
72426:     return LayerManager::CreateDrawTarget(aSize, aFormat);
72426:   }
72426: 
72426:   nsRefPtr<ID3D10Texture2D> texture;
72426:   
72426:   CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM, aSize.width, aSize.height, 1, 1);
72426:   desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
72426:   desc.MiscFlags = D3D10_RESOURCE_MISC_GDI_COMPATIBLE;
72426:   
72426:   HRESULT hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(texture));
72426: 
72426:   if (FAILED(hr)) {
72426:     NS_WARNING("Failed to create new texture for CreateOptimalSurface!");
72426:     return LayerManager::CreateDrawTarget(aSize, aFormat);
72426:   }
72426: 
72426:   RefPtr<DrawTarget> surface =
72426:     Factory::CreateDrawTargetForD3D10Texture(texture, aFormat);
72426: 
72426:   if (!surface) {
72426:     return LayerManager::CreateDrawTarget(aSize, aFormat);
72426:   }
72426:   
72426:   return surface;
72426: }
72426: 
62702: ReadbackManagerD3D10*
62702: LayerManagerD3D10::readbackManager()
62702: {
62702:   EnsureReadbackManager();
62702:   return mReadbackManager;
62702: }
62702: 
54814: void
54814: LayerManagerD3D10::SetViewport(const nsIntSize &aViewport)
54814: {
54814:   mViewport = aViewport;
54814: 
54814:   D3D10_VIEWPORT viewport;
54814:   viewport.MaxDepth = 1.0f;
54814:   viewport.MinDepth = 0;
54814:   viewport.Width = aViewport.width;
54814:   viewport.Height = aViewport.height;
54814:   viewport.TopLeftX = 0;
54814:   viewport.TopLeftY = 0;
54814: 
54814:   mDevice->RSSetViewports(1, &viewport);
54814: 
54814:   gfx3DMatrix projection;
54814:   /*
54814:    * Matrix to transform to viewport space ( <-1.0, 1.0> topleft,
54814:    * <1.0, -1.0> bottomright)
54814:    */
54814:   projection._11 = 2.0f / aViewport.width;
54814:   projection._22 = -2.0f / aViewport.height;
74750:   projection._33 = 0.0f;
54814:   projection._41 = -1.0f;
54814:   projection._42 = 1.0f;
54814:   projection._44 = 1.0f;
54814: 
54814:   HRESULT hr = mEffect->GetVariableByName("mProjection")->
54814:     SetRawValue(&projection._11, 0, 64);
54814: 
54814:   if (FAILED(hr)) {
54814:     NS_WARNING("Failed to set projection matrix.");
54814:   }
54814: }
54814: 
54814: void
54814: LayerManagerD3D10::SetupPipeline()
54814: {
54814:   VerifyBufferSize();
54814:   UpdateRenderTarget();
54814: 
54814:   nsIntRect rect;
54814:   mWidget->GetClientBounds(rect);
54814: 
54814:   HRESULT hr;
54814: 
54814:   hr = mEffect->GetVariableByName("vTextureCoords")->AsVector()->
54814:     SetFloatVector(ShaderConstantRectD3D10(0, 0, 1.0f, 1.0f));
54814: 
54814:   if (FAILED(hr)) {
54814:     NS_WARNING("Failed to set Texture Coordinates.");
54814:     return;
54814:   }
54814: 
54814:   ID3D10RenderTargetView *view = mRTView;
54814:   mDevice->OMSetRenderTargets(1, &view, NULL);
54814:   mDevice->IASetInputLayout(mInputLayout);
54814: 
54814:   UINT stride = sizeof(Vertex);
54814:   UINT offset = 0;
54814:   ID3D10Buffer *buffer = mVertexBuffer;
54814:   mDevice->IASetVertexBuffers(0, 1, &buffer, &stride, &offset);
54814:   mDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
54814: 
54814:   SetViewport(nsIntSize(rect.width, rect.height));
54814: }
54814: 
54814: void
54814: LayerManagerD3D10::UpdateRenderTarget()
54814: {
54814:   if (mRTView) {
54814:     return;
54814:   }
54814: 
54814:   HRESULT hr;
54814: 
54814:   nsRefPtr<ID3D10Texture2D> backBuf;
54814:   
75156:   if (mSwapChain) {
54814:     hr = mSwapChain->GetBuffer(0, __uuidof(ID3D10Texture2D), (void**)backBuf.StartAssignment());
54814:     if (FAILED(hr)) {
54814:       return;
54814:     }
75156:   } else {
75156:     backBuf = mBackBuffer;
75156:   }
54814:   
54814:   mDevice->CreateRenderTargetView(backBuf, NULL, getter_AddRefs(mRTView));
54814: }
54814: 
54814: void
54814: LayerManagerD3D10::VerifyBufferSize()
54814: {
75156:   nsIntRect rect;
75156:   mWidget->GetClientBounds(rect);
75156: 
75156:   if (mSwapChain) {
73920:     DXGI_SWAP_CHAIN_DESC swapDesc;
73920:     mSwapChain->GetDesc(&swapDesc);
73920: 
54814:     if (swapDesc.BufferDesc.Width == rect.width &&
54814:         swapDesc.BufferDesc.Height == rect.height) {
54814:       return;
54814:     }
54814: 
54814:     mRTView = nsnull;
63228:     if (gfxWindowsPlatform::IsOptimus()) {
60236:       mSwapChain->ResizeBuffers(1, rect.width, rect.height,
60236:                                 DXGI_FORMAT_B8G8R8A8_UNORM,
60236:                                 0);
60236:     } else {
54814:       mSwapChain->ResizeBuffers(1, rect.width, rect.height,
59294:                                 DXGI_FORMAT_B8G8R8A8_UNORM,
59294:                                 DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE);
60236:     }
75156:   } else {
75156:     D3D10_TEXTURE2D_DESC oldDesc;    
75156:     if (mBackBuffer) {
75156:         mBackBuffer->GetDesc(&oldDesc);
75156:     } else {
75156:         oldDesc.Width = oldDesc.Height = 0;
75156:     }
75156:     if (oldDesc.Width == rect.width &&
75156:         oldDesc.Height == rect.height) {
75156:       return;
75156:     }
54814: 
75156:     CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM,
75156:                                rect.width, rect.height, 1, 1);
75156:     desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
75156:     desc.MiscFlags = D3D10_RESOURCE_MISC_SHARED
75156:                      // FIXME/bug 662109: synchronize using KeyedMutex
75156:                      /*D3D10_RESOURCE_MISC_SHARED_KEYEDMUTEX*/;
81355:     HRESULT hr = device()->CreateTexture2D(&desc, nsnull, getter_AddRefs(mBackBuffer));
75156:     if (FAILED(hr)) {
81355:       ReportFailure(NS_LITERAL_CSTRING("LayerManagerD3D10::VerifyBufferSize(): Failed to create shared texture"),
75156:                     hr);
75156:       NS_RUNTIMEABORT("Failed to create back buffer");
75156:     }
75156: 
75156:     // XXX resize texture?
75156:     mRTView = nsnull;
75156:   }
54814: }
54814: 
54814: void
62702: LayerManagerD3D10::EnsureReadbackManager()
62702: {
62702:   if (mReadbackManager) {
62702:     return;
62702:   }
62702: 
62702:   DeviceAttachments *attachments;
62702:   UINT size = sizeof(DeviceAttachments*);
62702:   if (FAILED(mDevice->GetPrivateData(sDeviceAttachments, &size, &attachments))) {
62702:     // Strange! This shouldn't happen ... return a readback manager for this
62702:     // layer manager only.
62702:     mReadbackManager = new ReadbackManagerD3D10();
62702:     gfx::LogFailure(NS_LITERAL_CSTRING("Couldn't get device attachments for device."));
62702:     return;
62702:   }
62702: 
62702:   if (attachments->mReadbackManager) {
62702:     mReadbackManager = attachments->mReadbackManager;
62702:     return;
62702:   }
62702: 
62702:   mReadbackManager = new ReadbackManagerD3D10();
62702:   attachments->mReadbackManager = mReadbackManager;
62702: }
62702: 
62702: void
54814: LayerManagerD3D10::Render()
54814: {
54814:   static_cast<LayerD3D10*>(mRoot->ImplData())->Validate();
54814: 
54814:   SetupPipeline();
54814: 
54814:   float black[] = { 0, 0, 0, 0 };
54814:   device()->ClearRenderTargetView(mRTView, black);
54814: 
54814:   nsIntRect rect;
54814:   mWidget->GetClientBounds(rect);
54814: 
54814:   const nsIntRect *clipRect = mRoot->GetClipRect();
54814:   D3D10_RECT r;
54814:   if (clipRect) {
54814:     r.left = (LONG)clipRect->x;
54814:     r.top = (LONG)clipRect->y;
54814:     r.right = (LONG)(clipRect->x + clipRect->width);
54814:     r.bottom = (LONG)(clipRect->y + clipRect->height);
54814:   } else {
54814:     r.left = r.top = 0;
54814:     r.right = rect.width;
54814:     r.bottom = rect.height;
54814:   }
54814:   device()->RSSetScissorRects(1, &r);
54814: 
57097:   static_cast<LayerD3D10*>(mRoot->ImplData())->RenderLayer();
54814: 
54814:   if (mTarget) {
54814:     PaintToTarget();
75156:   } else if (mBackBuffer) {
75158:     ShadowLayerForwarder::BeginTransaction();
75158:     
75158:     nsIntRect contentRect = nsIntRect(0, 0, rect.width, rect.height);
75158:     if (!mRootForShadowTree) {
75158:         mRootForShadowTree = new DummyRoot(this);
75158:         mRootForShadowTree->SetShadow(ConstructShadowFor(mRootForShadowTree));
75158:         CreatedContainerLayer(mRootForShadowTree);
75158:         ShadowLayerForwarder::SetRoot(mRootForShadowTree);
75158:     }
75158: 
75158:     nsRefPtr<WindowLayer> windowLayer =
75158:         static_cast<WindowLayer*>(mRootForShadowTree->GetFirstChild());
75158:     if (!windowLayer) {
75158:         windowLayer = new WindowLayer(this);
75158:         windowLayer->SetShadow(ConstructShadowFor(windowLayer));
75158:         CreatedThebesLayer(windowLayer);
75158:         mRootForShadowTree->InsertAfter(windowLayer, nsnull);
75158:         ShadowLayerForwarder::InsertAfter(mRootForShadowTree, windowLayer);
75158:     }
75158: 
75158:     if (!mRootForShadowTree->GetVisibleRegion().IsEqual(contentRect)) {
75158:         mRootForShadowTree->SetVisibleRegion(contentRect);
75158:         windowLayer->SetVisibleRegion(contentRect);
75158: 
75158:         ShadowLayerForwarder::Mutated(mRootForShadowTree);
75158:         ShadowLayerForwarder::Mutated(windowLayer);
75158:     }
75158: 
75158:     FrameMetrics m;
75158:     if (ContainerLayer* cl = mRoot->AsContainerLayer()) {
75158:         m = cl->GetFrameMetrics();
75158:     } else {
75158:         m.mScrollId = FrameMetrics::ROOT_SCROLL_ID;
75158:     }
75158:     if (m != mRootForShadowTree->GetFrameMetrics()) {
75158:         mRootForShadowTree->SetFrameMetrics(m);
75158:         ShadowLayerForwarder::Mutated(mRootForShadowTree);
75158:     }
75158: 
75158:     SurfaceDescriptorD3D10 sd;
75158:     GetDescriptor(mBackBuffer, &sd);
75158:     ShadowLayerForwarder::PaintedThebesBuffer(windowLayer,
75158:                                               contentRect,
75158:                                               contentRect, nsIntPoint(),
75158:                                               sd);
75158: 
75158:     // A source in the graphics pipeline can't also be a target.  So
75158:     // unbind here to avoid racing with the chrome process sourcing
75158:     // the back texture.
75158:     mDevice->OMSetRenderTargets(0, NULL, NULL);
75158: 
75158:     // XXX revisit this Flush() in bug 662109.  It's not clear it's
75158:     // needed.
75158:     mDevice->Flush();
75158: 
75158:     mRTView = NULL;
75158: 
75158:     AutoInfallibleTArray<EditReply, 10> replies;
75158:     ShadowLayerForwarder::EndTransaction(&replies);
75158:     // We expect only 1 reply, but might get none if the parent
75158:     // process crashed
75158: 
75156:     swap(mBackBuffer, mRemoteFrontBuffer);
54814:   } else {
54814:     mSwapChain->Present(0, 0);
54814:   }
54814: }
54814: 
54814: void
54814: LayerManagerD3D10::PaintToTarget()
54814: {
54814:   nsRefPtr<ID3D10Texture2D> backBuf;
54814:   
54814:   mSwapChain->GetBuffer(0, __uuidof(ID3D10Texture2D), (void**)backBuf.StartAssignment());
54814: 
54814:   D3D10_TEXTURE2D_DESC bbDesc;
54814:   backBuf->GetDesc(&bbDesc);
54814: 
54814:   CD3D10_TEXTURE2D_DESC softDesc(bbDesc.Format, bbDesc.Width, bbDesc.Height);
54814:   softDesc.MipLevels = 1;
54814:   softDesc.CPUAccessFlags = D3D10_CPU_ACCESS_READ;
54814:   softDesc.Usage = D3D10_USAGE_STAGING;
54814:   softDesc.BindFlags = 0;
54814: 
54814:   nsRefPtr<ID3D10Texture2D> readTexture;
54814: 
81355:   HRESULT hr = device()->CreateTexture2D(&softDesc, NULL, getter_AddRefs(readTexture));
81355:   if (FAILED(hr)) {
81355:     ReportFailure(NS_LITERAL_CSTRING("LayerManagerD3D10::PaintToTarget(): Failed to create texture"),
81355:                   hr);
81355:     return;
81355:   }
54814: 
54814:   device()->CopyResource(readTexture, backBuf);
54814: 
54814:   D3D10_MAPPED_TEXTURE2D map;
54814:   readTexture->Map(0, D3D10_MAP_READ, 0, &map);
54814: 
54814:   nsRefPtr<gfxImageSurface> tmpSurface =
54814:     new gfxImageSurface((unsigned char*)map.pData,
54814:                         gfxIntSize(bbDesc.Width, bbDesc.Height),
54814:                         map.RowPitch,
54814:                         gfxASurface::ImageFormatARGB32);
54814: 
54814:   mTarget->SetSource(tmpSurface);
56115:   mTarget->SetOperator(gfxContext::OPERATOR_OVER);
54814:   mTarget->Paint();
56115: 
56115:   readTexture->Unmap(0);
54814: }
54814: 
60333: void
60333: LayerManagerD3D10::ReportFailure(const nsACString &aMsg, HRESULT aCode)
60333: {
60333:   // We could choose to abort here when hr == E_OUTOFMEMORY.
60333:   nsCString msg;
60333:   msg.Append(aMsg);
60333:   msg.AppendLiteral(" Error code: ");
60333:   msg.AppendInt(PRUint32(aCode));
60333:   NS_WARNING(msg.BeginReading());
62254: 
62254:   gfx::LogFailure(msg);
60333: }
60333: 
54814: LayerD3D10::LayerD3D10(LayerManagerD3D10 *aManager)
54814:   : mD3DManager(aManager)
54814: {
54814: }
54814: 
75157: WindowLayer::WindowLayer(LayerManagerD3D10* aManager)
75157:   : ThebesLayer(aManager, nsnull)
75157: {
54814:  }
75157: 
75157: WindowLayer::~WindowLayer()
75157: {
75157:   PLayerChild::Send__delete__(GetShadow());
54814: }
75157: 
75157: DummyRoot::DummyRoot(LayerManagerD3D10* aManager)
75157:   : ContainerLayer(aManager, nsnull)
75157: {
75157: }
75157: 
75157: DummyRoot::~DummyRoot()
75157: {
75157:   RemoveChild(nsnull);
75157:   PLayerChild::Send__delete__(GetShadow());
75157: }
75157: 
75157: void
75157: DummyRoot::InsertAfter(Layer* aLayer, Layer* aNull)
75157: {
75157:   NS_ABORT_IF_FALSE(!mFirstChild && !aNull,
75157:                     "Expect to append one child, once");
75157:   mFirstChild = nsRefPtr<Layer>(aLayer).forget().get();
75157: }
75157: 
75157: void
75157: DummyRoot::RemoveChild(Layer* aNull)
75157: {
75157:   NS_ABORT_IF_FALSE(!aNull, "Unused argument should be null");
75157:   NS_IF_RELEASE(mFirstChild);
75157: }
75157: 
75157: 
75157: }
75157: }
