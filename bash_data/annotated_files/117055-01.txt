 38727: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 38727: 
 38727: #include "gfxDWriteFonts.h"
 40504: #include "gfxDWriteShaper.h"
 43527: #include "gfxHarfBuzzShaper.h"
 84392: #ifdef MOZ_GRAPHITE
 84392: #include "gfxGraphiteShaper.h"
 84392: #endif
 38727: #include "gfxDWriteFontList.h"
 38727: #include "gfxContext.h"
 38727: #include <dwrite.h>
 38727: 
 38727: #include "gfxDWriteTextAnalysis.h"
 38727: 
 95828: #include "harfbuzz/hb.h"
 43526: 
 38727: // Chosen this as to resemble DWrite's own oblique face style.
 38727: #define OBLIQUE_SKEW_FACTOR 0.3
 38727: 
 93509: using namespace mozilla::gfx;
 93509: 
 43475: // This is also in gfxGDIFont.cpp. Would be nice to put it somewhere common,
 43475: // but we can't declare it in the gfxFont.h or gfxFontUtils.h headers
 43475: // because those are exported, and the cairo headers aren't.
 43475: static inline cairo_antialias_t
 43475: GetCairoAntialiasOption(gfxFont::AntialiasOption anAntialiasOption)
 43475: {
 43475:     switch (anAntialiasOption) {
 43475:     default:
 43475:     case gfxFont::kAntialiasDefault:
 43475:         return CAIRO_ANTIALIAS_DEFAULT;
 43475:     case gfxFont::kAntialiasNone:
 43475:         return CAIRO_ANTIALIAS_NONE;
 43475:     case gfxFont::kAntialiasGrayscale:
 43475:         return CAIRO_ANTIALIAS_GRAY;
 43475:     case gfxFont::kAntialiasSubpixel:
 43475:         return CAIRO_ANTIALIAS_SUBPIXEL;
 43475:     }
 43475: }
 43475: 
 59850: // Code to determine whether Windows is set to use ClearType font smoothing;
 59850: // based on private functions in cairo-win32-font.c
 59850: 
 59850: #ifndef SPI_GETFONTSMOOTHINGTYPE
 59850: #define SPI_GETFONTSMOOTHINGTYPE 0x200a
 59850: #endif
 59850: #ifndef FE_FONTSMOOTHINGCLEARTYPE
 59850: #define FE_FONTSMOOTHINGCLEARTYPE 2
 59850: #endif
 59850: 
 59850: static bool
 59850: UsingClearType()
 59850: {
 59850:     BOOL fontSmoothing;
 59850:     if (!SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &fontSmoothing, 0) ||
 59850:         !fontSmoothing)
 59850:     {
 59850:         return false;
 59850:     }
 59850: 
 59850:     UINT type;
 59850:     if (SystemParametersInfo(SPI_GETFONTSMOOTHINGTYPE, 0, &type, 0) &&
 59850:         type == FE_FONTSMOOTHINGCLEARTYPE)
 59850:     {
 59850:         return true;
 59850:     }
 59850:     return false;
 59850: }
 59850: 
 38727: ////////////////////////////////////////////////////////////////////////////////
 38727: // gfxDWriteFont
 38727: gfxDWriteFont::gfxDWriteFont(gfxFontEntry *aFontEntry,
 39306:                              const gfxFontStyle *aFontStyle,
 79445:                              bool aNeedsBold,
 43475:                              AntialiasOption anAAOption)
 43475:     : gfxFont(aFontEntry, aFontStyle, anAAOption)
106838:     , mCairoFontFace(nullptr)
106838:     , mMetrics(nullptr)
 80486:     , mNeedsOblique(false)
 43475:     , mNeedsBold(aNeedsBold)
 80486:     , mUseSubpixelPositions(false)
 80486:     , mAllowManualShowGlyphs(true)
 38727: {
 61422:     gfxDWriteFontEntry *fe =
 61422:         static_cast<gfxDWriteFontEntry*>(aFontEntry);
 61422:     nsresult rv;
 61422:     DWRITE_FONT_SIMULATIONS sims = DWRITE_FONT_SIMULATIONS_NONE;
 93220:     if ((GetStyle()->style & (NS_FONT_STYLE_ITALIC | NS_FONT_STYLE_OBLIQUE)) &&
 61422:         !fe->IsItalic()) {
 61422:             // For this we always use the font_matrix for uniformity. Not the
 61422:             // DWrite simulation.
 80486:             mNeedsOblique = true;
 61422:     }
 61422:     if (aNeedsBold) {
 61422:         sims |= DWRITE_FONT_SIMULATIONS_BOLD;
 61422:     }
 61422: 
 61422:     rv = fe->CreateFontFace(getter_AddRefs(mFontFace), sims);
 61422: 
 61422:     if (NS_FAILED(rv)) {
 80486:         mIsValid = false;
 61422:         return;
 61422:     }
 61422: 
 71190:     ComputeMetrics(anAAOption);
 61422: 
 84392: #ifdef MOZ_GRAPHITE
 84392:     if (FontCanSupportGraphite()) {
 84392:         mGraphiteShaper = new gfxGraphiteShaper(this);
 84392:     }
 84392: #endif
 84392: 
 61083:     if (FontCanSupportHarfBuzz()) {
 61083:         mHarfBuzzShaper = new gfxHarfBuzzShaper(this);
 61083:     }
 61083: }
 61083: 
 61083: gfxDWriteFont::~gfxDWriteFont()
 61083: {
 61083:     if (mCairoFontFace) {
 61083:         cairo_font_face_destroy(mCairoFontFace);
 61083:     }
 84651:     if (mScaledFont) {
 84651:         cairo_scaled_font_destroy(mScaledFont);
 61083:     }
 61083:     delete mMetrics;
 61083: }
 61083: 
 61083: gfxFont*
 61083: gfxDWriteFont::CopyWithAntialiasOption(AntialiasOption anAAOption)
 61083: {
 61083:     return new gfxDWriteFont(static_cast<gfxDWriteFontEntry*>(mFontEntry.get()),
 61083:                              &mStyle, mNeedsBold, anAAOption);
 61083: }
 61083: 
 61083: void
 43527: gfxDWriteFont::CreatePlatformShaper()
 43527: {
 43527:     mPlatformShaper = new gfxDWriteShaper(this);
 43527: }
 43527: 
 38727: const gfxFont::Metrics&
 38727: gfxDWriteFont::GetMetrics()
 38727: {
 61083:     return *mMetrics;
 38727: }
 38727: 
 79445: bool
 63782: gfxDWriteFont::GetFakeMetricsForArialBlack(DWRITE_FONT_METRICS *aFontMetrics)
 63782: {
 63782:     gfxFontStyle style(mStyle);
 63782:     style.weight = 700;
 79445:     bool needsBold;
 63782:     gfxFontEntry *fe = mFontEntry->Family()->FindFontForStyle(style, needsBold);
 63782:     if (!fe || fe == mFontEntry) {
 80486:         return false;
 63782:     }
 63782: 
 63782:     nsRefPtr<gfxFont> font = fe->FindOrMakeFont(&style, needsBold);
 63782:     gfxDWriteFont *dwFont = static_cast<gfxDWriteFont*>(font.get());
 63782:     dwFont->mFontFace->GetMetrics(aFontMetrics);
 63782: 
 80486:     return true;
 63782: }
 63782: 
 38727: void
 71190: gfxDWriteFont::ComputeMetrics(AntialiasOption anAAOption)
 38727: {
 38727:     DWRITE_FONT_METRICS fontMetrics;
 63782:     if (!(mFontEntry->Weight() == 900 &&
 63782:           !mFontEntry->IsUserFont() &&
 63782:           mFontEntry->FamilyName().EqualsLiteral("Arial") &&
 63782:           GetFakeMetricsForArialBlack(&fontMetrics)))
 63782:     {
 38727:         mFontFace->GetMetrics(&fontMetrics);
 63782:     }
 38727: 
 39352:     if (mStyle.sizeAdjust != 0.0) {
 39352:         gfxFloat aspect = (gfxFloat)fontMetrics.xHeight /
 39352:                    fontMetrics.designUnitsPerEm;
 39352:         mAdjustedSize = mStyle.GetAdjustedSize(aspect);
 39352:     } else {
 39352:         mAdjustedSize = mStyle.size;
 39352:     }
 39352: 
 71190:     // Note that GetMeasuringMode depends on mAdjustedSize
 71190:     if ((anAAOption == gfxFont::kAntialiasDefault &&
 71190:          UsingClearType() &&
 71190:          GetMeasuringMode() == DWRITE_MEASURING_MODE_NATURAL) ||
 71190:         anAAOption == gfxFont::kAntialiasSubpixel)
 71190:     {
 80486:         mUseSubpixelPositions = true;
 71190:         // note that this may be reset to FALSE if we determine that a bitmap
 71190:         // strike is going to be used
 71190:     }
 71190: 
 61260:     gfxDWriteFontEntry *fe =
 61260:         static_cast<gfxDWriteFontEntry*>(mFontEntry.get());
 61260:     if (fe->IsCJKFont() && HasBitmapStrikeForSize(NS_lround(mAdjustedSize))) {
 61074:         mAdjustedSize = NS_lround(mAdjustedSize);
 80486:         mUseSubpixelPositions = false;
 61104:         // if we have bitmaps, we need to tell Cairo NOT to use subpixel AA,
 61104:         // to avoid the manual-subpixel codepath in cairo-d2d-surface.cpp
 62611:         // which fails to render bitmap glyphs (see bug 626299).
 62611:         // This option will be passed to the cairo_dwrite_scaled_font_t
 62611:         // after creation.
 80486:         mAllowManualShowGlyphs = false;
 61074:     }
 61074: 
 61083:     mMetrics = new gfxFont::Metrics;
 61083:     ::memset(mMetrics, 0, sizeof(*mMetrics));
 61083: 
 68738:     mFUnitsConvFactor = float(mAdjustedSize / fontMetrics.designUnitsPerEm);
 40505: 
 68738:     mMetrics->xHeight = fontMetrics.xHeight * mFUnitsConvFactor;
 68738: 
 68738:     mMetrics->maxAscent = ceil(fontMetrics.ascent * mFUnitsConvFactor);
 68738:     mMetrics->maxDescent = ceil(fontMetrics.descent * mFUnitsConvFactor);
 61083:     mMetrics->maxHeight = mMetrics->maxAscent + mMetrics->maxDescent;
 40505: 
 61083:     mMetrics->emHeight = mAdjustedSize;
 61083:     mMetrics->emAscent = mMetrics->emHeight *
 61083:         mMetrics->maxAscent / mMetrics->maxHeight;
 61083:     mMetrics->emDescent = mMetrics->emHeight - mMetrics->emAscent;
 40505: 
 61083:     mMetrics->maxAdvance = mAdjustedSize;
 40505: 
 48914:     // try to get the true maxAdvance value from 'hhea'
108991:     uint8_t *tableData;
108991:     uint32_t len;
 48914:     void *tableContext = NULL;
 48914:     BOOL exists;
 48914:     HRESULT hr =
 48914:         mFontFace->TryGetFontTable(DWRITE_MAKE_OPENTYPE_TAG('h', 'h', 'e', 'a'),
 48914:                                    (const void**)&tableData,
 48914:                                    &len,
 48914:                                    &tableContext,
 48914:                                    &exists);
 48914:     if (SUCCEEDED(hr)) {
 48914:         if (exists && len >= sizeof(mozilla::HheaTable)) {
 48914:             const mozilla::HheaTable* hhea =
 48914:                 reinterpret_cast<const mozilla::HheaTable*>(tableData);
 68738:             mMetrics->maxAdvance =
108991:                 uint16_t(hhea->advanceWidthMax) * mFUnitsConvFactor;
 48914:         }
 48914:         mFontFace->ReleaseFontTable(tableContext);
 48914:     }
 48914: 
 61083:     mMetrics->internalLeading = NS_MAX(mMetrics->maxHeight - mMetrics->emHeight, 0.0);
 68738:     mMetrics->externalLeading = ceil(fontMetrics.lineGap * mFUnitsConvFactor);
 38727: 
108991:     UINT16 glyph = (uint16_t)GetSpaceGlyph();
 68738:     mMetrics->spaceWidth = MeasureGlyphWidth(glyph);
 48914: 
 48914:     // try to get aveCharWidth from the OS/2 table, fall back to measuring 'x'
 68738:     // if the table is not available or if using hinted/pixel-snapped widths
 68738:     if (mUseSubpixelPositions) {
 61083:         mMetrics->aveCharWidth = 0;
 48914:         hr = mFontFace->TryGetFontTable(DWRITE_MAKE_OPENTYPE_TAG('O', 'S', '/', '2'),
 48914:                                         (const void**)&tableData,
 48914:                                         &len,
 48914:                                         &tableContext,
 48914:                                         &exists);
 48914:         if (SUCCEEDED(hr)) {
 48914:             if (exists && len >= 4) {
 48914:                 // Not checking against sizeof(mozilla::OS2Table) here because older
 48914:                 // versions of the table have different sizes; we only need the first
 48914:                 // two 16-bit fields here.
 48914:                 const mozilla::OS2Table* os2 =
 48914:                     reinterpret_cast<const mozilla::OS2Table*>(tableData);
 68738:                 mMetrics->aveCharWidth =
108991:                     int16_t(os2->xAvgCharWidth) * mFUnitsConvFactor;
 48914:             }
 48914:             mFontFace->ReleaseFontTable(tableContext);
 48914:         }
 68738:     }
 48914: 
 48914:     UINT32 ucs;
 61083:     if (mMetrics->aveCharWidth < 1) {
 48914:         ucs = L'x';
 68738:         if (SUCCEEDED(mFontFace->GetGlyphIndicesA(&ucs, 1, &glyph))) {
 68738:             mMetrics->aveCharWidth = MeasureGlyphWidth(glyph);
 68738:         }
 68738:         if (mMetrics->aveCharWidth < 1) {
 38727:             // Let's just assume the X is square.
 68738:             mMetrics->aveCharWidth = fontMetrics.xHeight * mFUnitsConvFactor;
 38727:         }
 48914:     }
 48914: 
 38727:     ucs = L'0';
 68738:     if (SUCCEEDED(mFontFace->GetGlyphIndicesA(&ucs, 1, &glyph))) {
 68738:         mMetrics->zeroOrAveCharWidth = MeasureGlyphWidth(glyph);
 68738:     }
 68738:     if (mMetrics->zeroOrAveCharWidth < 1) {
 61083:         mMetrics->zeroOrAveCharWidth = mMetrics->aveCharWidth;
 38727:     }
 48914: 
 61083:     mMetrics->underlineOffset =
 68738:         fontMetrics.underlinePosition * mFUnitsConvFactor;
 61083:     mMetrics->underlineSize = 
 68738:         fontMetrics.underlineThickness * mFUnitsConvFactor;
 61083:     mMetrics->strikeoutOffset =
 68738:         fontMetrics.strikethroughPosition * mFUnitsConvFactor;
 61083:     mMetrics->strikeoutSize =
 68738:         fontMetrics.strikethroughThickness * mFUnitsConvFactor;
 61083:     mMetrics->superscriptOffset = 0;
 61083:     mMetrics->subscriptOffset = 0;
 38727: 
 61083:     SanitizeMetrics(mMetrics, GetFontEntry()->mIsBadUnderlineFont);
 40042: 
 40042: #if 0
 40042:     printf("Font: %p (%s) size: %f\n", this,
 40042:            NS_ConvertUTF16toUTF8(GetName()).get(), mStyle.size);
 61083:     printf("    emHeight: %f emAscent: %f emDescent: %f\n", mMetrics->emHeight, mMetrics->emAscent, mMetrics->emDescent);
 61083:     printf("    maxAscent: %f maxDescent: %f maxAdvance: %f\n", mMetrics->maxAscent, mMetrics->maxDescent, mMetrics->maxAdvance);
 61083:     printf("    internalLeading: %f externalLeading: %f\n", mMetrics->internalLeading, mMetrics->externalLeading);
 48914:     printf("    spaceWidth: %f aveCharWidth: %f zeroOrAve: %f xHeight: %f\n",
 61083:            mMetrics->spaceWidth, mMetrics->aveCharWidth, mMetrics->zeroOrAveCharWidth, mMetrics->xHeight);
 40042:     printf("    uOff: %f uSize: %f stOff: %f stSize: %f supOff: %f subOff: %f\n",
 61083:            mMetrics->underlineOffset, mMetrics->underlineSize, mMetrics->strikeoutOffset, mMetrics->strikeoutSize,
 61083:            mMetrics->superscriptOffset, mMetrics->subscriptOffset);
 40042: #endif
 38727: }
 38727: 
 61074: using namespace mozilla; // for AutoSwap_* types
 61074: 
 61074: struct EBLCHeader {
 61074:     AutoSwap_PRUint32 version;
 61074:     AutoSwap_PRUint32 numSizes;
 61074: };
 61074: 
 61074: struct SbitLineMetrics {
108991:     int8_t  ascender;
108991:     int8_t  descender;
108991:     uint8_t widthMax;
108991:     int8_t  caretSlopeNumerator;
108991:     int8_t  caretSlopeDenominator;
108991:     int8_t  caretOffset;
108991:     int8_t  minOriginSB;
108991:     int8_t  minAdvanceSB;
108991:     int8_t  maxBeforeBL;
108991:     int8_t  minAfterBL;
108991:     int8_t  pad1;
108991:     int8_t  pad2;
 61074: };
 61074: 
 61074: struct BitmapSizeTable {
 61074:     AutoSwap_PRUint32 indexSubTableArrayOffset;
 61074:     AutoSwap_PRUint32 indexTablesSize;
 61074:     AutoSwap_PRUint32 numberOfIndexSubTables;
 61074:     AutoSwap_PRUint32 colorRef;
 61074:     SbitLineMetrics   hori;
 61074:     SbitLineMetrics   vert;
 61074:     AutoSwap_PRUint16 startGlyphIndex;
 61074:     AutoSwap_PRUint16 endGlyphIndex;
108991:     uint8_t           ppemX;
108991:     uint8_t           ppemY;
108991:     uint8_t           bitDepth;
108991:     uint8_t           flags;
 61074: };
 61074: 
 61074: typedef EBLCHeader EBSCHeader;
 61074: 
 61074: struct BitmapScaleTable {
 61074:     SbitLineMetrics   hori;
 61074:     SbitLineMetrics   vert;
108991:     uint8_t           ppemX;
108991:     uint8_t           ppemY;
108991:     uint8_t           substitutePpemX;
108991:     uint8_t           substitutePpemY;
 61074: };
 61074: 
 79445: bool
108991: gfxDWriteFont::HasBitmapStrikeForSize(uint32_t aSize)
 61074: {
108991:     uint8_t *tableData;
108991:     uint32_t len;
 61074:     void *tableContext;
 61074:     BOOL exists;
 61074:     HRESULT hr =
 61074:         mFontFace->TryGetFontTable(DWRITE_MAKE_OPENTYPE_TAG('E', 'B', 'L', 'C'),
 61074:                                    (const void**)&tableData, &len,
 61074:                                    &tableContext, &exists);
 61074:     if (FAILED(hr)) {
 80486:         return false;
 61074:     }
 61074: 
 79445:     bool hasStrike = false;
 61074:     // not really a loop, but this lets us use 'break' to skip out of the block
 61074:     // as soon as we know the answer, and skips it altogether if the table is
 61074:     // not present
 61074:     while (exists) {
 61074:         if (len < sizeof(EBLCHeader)) {
 61074:             break;
 61074:         }
 61074:         const EBLCHeader *hdr = reinterpret_cast<const EBLCHeader*>(tableData);
 61074:         if (hdr->version != 0x00020000) {
 61074:             break;
 61074:         }
108991:         uint32_t numSizes = hdr->numSizes;
 61074:         if (numSizes > 0xffff) { // sanity-check, prevent overflow below
 61074:             break;
 61074:         }
 61074:         if (len < sizeof(EBLCHeader) + numSizes * sizeof(BitmapSizeTable)) {
 61074:             break;
 61074:         }
 61074:         const BitmapSizeTable *sizeTable =
 61074:             reinterpret_cast<const BitmapSizeTable*>(hdr + 1);
108991:         for (uint32_t i = 0; i < numSizes; ++i, ++sizeTable) {
 61074:             if (sizeTable->ppemX == aSize && sizeTable->ppemY == aSize) {
 61074:                 // we ignore a strike that contains fewer than 4 glyphs,
 61074:                 // as that probably indicates a font such as Courier New
 61074:                 // that provides bitmaps ONLY for the "shading" characters
 61074:                 // U+2591..2593
108991:                 hasStrike = (uint16_t(sizeTable->endGlyphIndex) >=
108991:                              uint16_t(sizeTable->startGlyphIndex) + 3);
 61074:                 break;
 61074:             }
 61074:         }
 61074:         // if we reach here, we didn't find a strike; unconditionally break
 61074:         // out of the while-loop block
 61074:         break;
 61074:     }
 61074:     mFontFace->ReleaseFontTable(tableContext);
 61074: 
 61074:     if (hasStrike) {
 80486:         return true;
 61074:     }
 61074: 
 61074:     // if we didn't find a real strike, check if the font calls for scaling
 61074:     // another bitmap to this size
 61074:     hr = mFontFace->TryGetFontTable(DWRITE_MAKE_OPENTYPE_TAG('E', 'B', 'S', 'C'),
 61074:                                     (const void**)&tableData, &len,
 61074:                                     &tableContext, &exists);
 61074:     if (FAILED(hr)) {
 80486:         return false;
 61074:     }
 61074: 
 61074:     while (exists) {
 61074:         if (len < sizeof(EBSCHeader)) {
 61074:             break;
 61074:         }
 61074:         const EBSCHeader *hdr = reinterpret_cast<const EBSCHeader*>(tableData);
 61074:         if (hdr->version != 0x00020000) {
 61074:             break;
 61074:         }
108991:         uint32_t numSizes = hdr->numSizes;
 61074:         if (numSizes > 0xffff) {
 61074:             break;
 61074:         }
 61074:         if (len < sizeof(EBSCHeader) + numSizes * sizeof(BitmapScaleTable)) {
 61074:             break;
 61074:         }
 61074:         const BitmapScaleTable *scaleTable =
 61074:             reinterpret_cast<const BitmapScaleTable*>(hdr + 1);
108991:         for (uint32_t i = 0; i < numSizes; ++i, ++scaleTable) {
 61074:             if (scaleTable->ppemX == aSize && scaleTable->ppemY == aSize) {
 80486:                 hasStrike = true;
 61074:                 break;
 61074:             }
 61074:         }
 61074:         break;
 61074:     }
 61074:     mFontFace->ReleaseFontTable(tableContext);
 61074: 
 61074:     return hasStrike;
 61074: }
 61074: 
108991: uint32_t
 38727: gfxDWriteFont::GetSpaceGlyph()
 38727: {
 38727:     UINT32 ucs = L' ';
 38727:     UINT16 glyph;
 38727:     HRESULT hr;
 38727:     hr = mFontFace->GetGlyphIndicesA(&ucs, 1, &glyph);
 38727:     if (FAILED(hr)) {
 38727:         return 0;
 38727:     }
 38727:     return glyph;
 38727: }
 38727: 
 79445: bool
 38727: gfxDWriteFont::SetupCairoFont(gfxContext *aContext)
 38727: {
 38727:     cairo_scaled_font_t *scaledFont = CairoScaledFont();
 38727:     if (cairo_scaled_font_status(scaledFont) != CAIRO_STATUS_SUCCESS) {
 38727:         // Don't cairo_set_scaled_font as that would propagate the error to
 38727:         // the cairo_t, precluding any further drawing.
 80486:         return false;
 38727:     }
 38727:     cairo_set_scaled_font(aContext->GetCairo(), scaledFont);
 80486:     return true;
 38727: }
 38727: 
 79445: bool
 61083: gfxDWriteFont::IsValid()
 61083: {
 61083:     return mFontFace != NULL;
 61083: }
 61083: 
 61083: IDWriteFontFace*
 61083: gfxDWriteFont::GetFontFace()
 61083: {
 61083:     return  mFontFace.get();
 61083: }
 61083: 
 38727: cairo_font_face_t *
 38727: gfxDWriteFont::CairoFontFace()
 38727: {
 38727:     if (!mCairoFontFace) {
 38727: #ifdef CAIRO_HAS_DWRITE_FONT
 38727:         mCairoFontFace = 
 38727:             cairo_dwrite_font_face_create_for_dwrite_fontface(
 38727:             ((gfxDWriteFontEntry*)mFontEntry.get())->mFont, mFontFace);
 38727: #endif
 38727:     }
 38727:     return mCairoFontFace;
 38727: }
 38727: 
 38727: 
 38727: cairo_scaled_font_t *
 38727: gfxDWriteFont::CairoScaledFont()
 38727: {
 84651:     if (!mScaledFont) {
 38727:         cairo_matrix_t sizeMatrix;
 38727:         cairo_matrix_t identityMatrix;
 38727: 
 39352:         cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
 38727:         cairo_matrix_init_identity(&identityMatrix);
 38727: 
 38727:         cairo_font_options_t *fontOptions = cairo_font_options_create();
 38727:         if (mNeedsOblique) {
 38727:             double skewfactor = OBLIQUE_SKEW_FACTOR;
 38727: 
 38727:             cairo_matrix_t style;
 38727:             cairo_matrix_init(&style,
 38727:                               1,                //xx
 38727:                               0,                //yx
 38727:                               -1 * skewfactor,  //xy
 38727:                               1,                //yy
 38727:                               0,                //x0
 38727:                               0);               //y0
 38727:             cairo_matrix_multiply(&sizeMatrix, &sizeMatrix, &style);
 38727:         }
 38727: 
 43475:         if (mAntialiasOption != kAntialiasDefault) {
 43475:             cairo_font_options_set_antialias(fontOptions,
 43475:                 GetCairoAntialiasOption(mAntialiasOption));
 43475:         }
 43475: 
 84651:         mScaledFont = cairo_scaled_font_create(CairoFontFace(),
 38727:                                                     &sizeMatrix,
 38727:                                                     &identityMatrix,
 38727:                                                     fontOptions);
 38727:         cairo_font_options_destroy(fontOptions);
 62611: 
 84651:         cairo_dwrite_scaled_font_allow_manual_show_glyphs(mScaledFont,
 62611:                                                           mAllowManualShowGlyphs);
 71189: 
 71189:         gfxDWriteFontEntry *fe =
 71189:             static_cast<gfxDWriteFontEntry*>(mFontEntry.get());
 84651:         cairo_dwrite_scaled_font_set_force_GDI_classic(mScaledFont,
 71190:                                                        GetForceGDIClassic());
 38727:     }
 38727: 
 39352:     NS_ASSERTION(mAdjustedSize == 0.0 ||
 84651:                  cairo_scaled_font_status(mScaledFont) 
 38727:                    == CAIRO_STATUS_SUCCESS,
 38727:                  "Failed to make scaled font");
 38727: 
 84651:     return mScaledFont;
 38727: }
 43526: 
 72826: gfxFont::RunMetrics
 72826: gfxDWriteFont::Measure(gfxTextRun *aTextRun,
108991:                     uint32_t aStart, uint32_t aEnd,
 72826:                     BoundingBoxType aBoundingBoxType,
 72826:                     gfxContext *aRefContext,
 72826:                     Spacing *aSpacing)
 72826: {
 72826:     gfxFont::RunMetrics metrics =
 72826:         gfxFont::Measure(aTextRun, aStart, aEnd,
 72826:                          aBoundingBoxType, aRefContext, aSpacing);
 72826: 
 72826:     // if aBoundingBoxType is LOOSE_INK_EXTENTS
 72826:     // and the underlying cairo font may be antialiased,
 72826:     // we can't trust Windows to have considered all the pixels
 72826:     // so we need to add "padding" to the bounds.
 72826:     // (see bugs 475968, 439831, compare also bug 445087)
 72826:     if (aBoundingBoxType == LOOSE_INK_EXTENTS &&
 72826:         mAntialiasOption != kAntialiasNone &&
 72826:         GetMeasuringMode() == DWRITE_MEASURING_MODE_GDI_CLASSIC &&
 72826:         metrics.mBoundingBox.width > 0) {
 72826:         metrics.mBoundingBox.x -= aTextRun->GetAppUnitsPerDevUnit();
 72826:         metrics.mBoundingBox.width += aTextRun->GetAppUnitsPerDevUnit() * 3;
 72826:     }
 72826: 
 72826:     return metrics;
 72826: }
 72826: 
 43526: // Access to font tables packaged in hb_blob_t form
 43526: 
 43526: // object attached to the Harfbuzz blob, used to release
 43526: // the table when the blob is destroyed
 43526: class FontTableRec {
 43526: public:
 43526:     FontTableRec(IDWriteFontFace *aFontFace, void *aContext)
 43526:         : mFontFace(aFontFace), mContext(aContext)
 43526:     { }
 43526: 
 43526:     ~FontTableRec() {
 43526:         mFontFace->ReleaseFontTable(mContext);
 43526:     }
 43526: 
 43526: private:
 43526:     IDWriteFontFace *mFontFace;
 43526:     void            *mContext;
 43526: };
 43526: 
 43526: /*static*/ void
 43526: gfxDWriteFont::DestroyBlobFunc(void* aUserData)
 43526: {
 43526:     FontTableRec *ftr = static_cast<FontTableRec*>(aUserData);
 43526:     delete ftr;
 43526: }
 43526: 
 43526: hb_blob_t *
108991: gfxDWriteFont::GetFontTable(uint32_t aTag)
 43526: {
 43526:     const void *data;
 43526:     UINT32      size;
 43526:     void       *context;
 43526:     BOOL        exists;
 43526:     HRESULT hr = mFontFace->TryGetFontTable(NS_SWAP32(aTag),
 43526:                                             &data, &size, &context, &exists);
 43526:     if (SUCCEEDED(hr) && exists) {
 43526:         FontTableRec *ftr = new FontTableRec(mFontFace, context);
 43526:         return hb_blob_create(static_cast<const char*>(data), size,
 43526:                               HB_MEMORY_MODE_READONLY,
 90072:                               ftr, DestroyBlobFunc);
 43526:     }
 43526: 
 55084:     if (mFontEntry->IsUserFont() && !mFontEntry->IsLocalUserFont()) {
 55084:         // for downloaded fonts, there may be layout tables cached in the entry
 55084:         // even though they're absent from the sanitized platform font
 58944:         hb_blob_t *blob;
 58944:         if (mFontEntry->GetExistingFontTable(aTag, &blob)) {
 58944:             return blob;
 58944:         }
 55084:     }
 55084: 
106838:     return nullptr;
 43526: }
 59850: 
 79445: bool
 61086: gfxDWriteFont::ProvidesGlyphWidths()
 61086: {
 61086:     return !mUseSubpixelPositions ||
 61086:            (mFontFace->GetSimulations() & DWRITE_FONT_SIMULATIONS_BOLD);
 61086: }
 61086: 
108991: int32_t
108991: gfxDWriteFont::GetGlyphWidth(gfxContext *aCtx, uint16_t aGID)
 59850: {
 59850:     if (!mGlyphWidths.IsInitialized()) {
 59850:         mGlyphWidths.Init(200);
 59850:     }
 59850: 
108991:     int32_t width = -1;
 59850:     if (mGlyphWidths.Get(aGID, &width)) {
 59850:         return width;
 59850:     }
 59850: 
 68738:     width = NS_lround(MeasureGlyphWidth(aGID) * 65536.0);
 68738:     mGlyphWidths.Put(aGID, width);
 68738:     return width;
 68738: }
 68738: 
 93509: TemporaryRef<GlyphRenderingOptions>
 93509: gfxDWriteFont::GetGlyphRenderingOptions()
 93509: {
 93509:   if (UsingClearType()) {
 93509:     return Factory::CreateDWriteGlyphRenderingOptions(
 93509:       gfxWindowsPlatform::GetPlatform()->GetRenderingParams(GetForceGDIClassic() ?
 93509:         gfxWindowsPlatform::TEXT_RENDERING_GDI_CLASSIC : gfxWindowsPlatform::TEXT_RENDERING_NORMAL));
 93509:   } else {
 93509:     return Factory::CreateDWriteGlyphRenderingOptions(gfxWindowsPlatform::GetPlatform()->
 93509:       GetRenderingParams(gfxWindowsPlatform::TEXT_RENDERING_NO_CLEARTYPE));
 93509:   }
 93509: }
 93509: 
 71190: bool
 71190: gfxDWriteFont::GetForceGDIClassic()
 71190: {
 71190:     return static_cast<gfxDWriteFontEntry*>(mFontEntry.get())->GetForceGDIClassic() &&
 71544:          cairo_dwrite_get_cleartype_rendering_mode() < 0 &&
 71190:          GetAdjustedSize() <=
 71190:             gfxDWriteFontList::PlatformFontList()->GetForceGDIClassicMaxFontSize();
 71190: }
 71190: 
 71189: DWRITE_MEASURING_MODE
 71189: gfxDWriteFont::GetMeasuringMode()
 71189: {
 71190:     return GetForceGDIClassic()
 71189:         ? DWRITE_MEASURING_MODE_GDI_CLASSIC
 71189:         : gfxWindowsPlatform::GetPlatform()->DWriteMeasuringMode();
 71189: }
 71189: 
 68738: gfxFloat
108991: gfxDWriteFont::MeasureGlyphWidth(uint16_t aGlyph)
 68738: {
 68738:     DWRITE_GLYPH_METRICS metrics;
 61073:     HRESULT hr;
 61074:     if (mUseSubpixelPositions) {
 68738:         hr = mFontFace->GetDesignGlyphMetrics(&aGlyph, 1, &metrics, FALSE);
 61073:         if (SUCCEEDED(hr)) {
 68738:             return metrics.advanceWidth * mFUnitsConvFactor;
 61073:         }
 61073:     } else {
 61073:         hr = mFontFace->GetGdiCompatibleGlyphMetrics(
106838:                   FLOAT(mAdjustedSize), 1.0f, nullptr,
 71189:                   GetMeasuringMode() == DWRITE_MEASURING_MODE_GDI_NATURAL,
 68738:                   &aGlyph, 1, &metrics, FALSE);
 61073:         if (SUCCEEDED(hr)) {
 68738:             return NS_lround(metrics.advanceWidth * mFUnitsConvFactor);
 61073:         }
 61073:     }
 68738:     return 0;
 59850: }
 93997: 
 93997: void
 93997: gfxDWriteFont::SizeOfExcludingThis(nsMallocSizeOfFun aMallocSizeOf,
 93997:                                    FontCacheSizes*   aSizes) const
 93997: {
 93997:     gfxFont::SizeOfExcludingThis(aMallocSizeOf, aSizes);
 93997:     aSizes->mFontInstances += aMallocSizeOf(mMetrics) +
106838:         mGlyphWidths.SizeOfExcludingThis(nullptr, aMallocSizeOf);
 93997: }
 93997: 
 93997: void
 93997: gfxDWriteFont::SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf,
 93997:                                    FontCacheSizes*   aSizes) const
 93997: {
 93997:     aSizes->mFontInstances += aMallocSizeOf(this);
 93997:     SizeOfExcludingThis(aMallocSizeOf, aSizes);
 93997: }
114778: 
114778: TemporaryRef<ScaledFont>
114778: gfxDWriteFont::GetScaledFont(mozilla::gfx::DrawTarget *aTarget)
114778: {
114778:   bool wantCairo = aTarget->GetType() == BACKEND_CAIRO;
114778:   if (mAzureScaledFont && mAzureScaledFontIsCairo == wantCairo) {
114778:     return mAzureScaledFont;
114778:   }
114778: 
114778:   NativeFont nativeFont;
114778:   nativeFont.mType = NATIVE_FONT_DWRITE_FONT_FACE;
114778:   nativeFont.mFont = GetFontFace();
114778: 
114778:   if (wantCairo) {
114778:     mAzureScaledFont = Factory::CreateScaledFontWithCairo(nativeFont,
114778:                                                         GetAdjustedSize(),
117055:                                                         CairoScaledFont());
114778:   } else {
114778:     mAzureScaledFont = Factory::CreateScaledFontForNativeFont(nativeFont,
114778:                                                             GetAdjustedSize());
114778:   }
114778: 
114778:   mAzureScaledFontIsCairo = wantCairo;
114778: 
114778:   return mAzureScaledFont;
114778: }
