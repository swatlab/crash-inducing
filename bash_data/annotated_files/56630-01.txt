38166: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
38166:  * vim: sw=2 ts=2 et lcs=trail\:.,tab\:>~ :
38166:  * ***** BEGIN LICENSE BLOCK *****
38166:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
38166:  *
38166:  * The contents of this file are subject to the Mozilla Public License Version
38166:  * 1.1 (the "License"); you may not use this file except in compliance with
38166:  * the License. You may obtain a copy of the License at
38166:  * http://www.mozilla.org/MPL/
38166:  *
38166:  * Software distributed under the License is distributed on an "AS IS" basis,
38166:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
38166:  * for the specific language governing rights and limitations under the
38166:  * License.
38166:  *
38166:  * The Original Code is Places code.
38166:  *
38166:  * The Initial Developer of the Original Code is
38166:  * Mozilla Foundation.
38166:  * Portions created by the Initial Developer are Copyright (C) 2009
38166:  * the Initial Developer. All Rights Reserved.
38166:  *
38166:  * Contributor(s):
38166:  *   Shawn Wilsher <me@shawnwilsher.com> (Original Author)
38166:  *
38166:  * Alternatively, the contents of this file may be used under the terms of
38166:  * either the GNU General Public License Version 2 or later (the "GPL"), or
38166:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
38166:  * in which case the provisions of the GPL or the LGPL are applicable instead
38166:  * of those above. If you wish to allow use of your version of this file only
38166:  * under the terms of either the GPL or the LGPL, and not to allow others to
38166:  * use your version of this file under the terms of the MPL, indicate your
38166:  * decision by deleting the provisions above and replace them with the notice
38166:  * and other provisions required by the GPL or the LGPL. If you do not delete
38166:  * the provisions above, a recipient may use your version of this file under
38166:  * the terms of any one of the MPL, the GPL or the LGPL.
38166:  *
38166:  * ***** END LICENSE BLOCK ***** */
38166: 
48297: #ifdef MOZ_IPC
48297: #include "mozilla/dom/ContentChild.h"
48297: #include "mozilla/dom/ContentParent.h"
48297: #include "nsXULAppAPI.h"
48297: #endif
48297: 
48298: #ifdef MOZ_IPC
48298: #include "mozilla/dom/ContentChild.h"
48298: #include "nsXULAppAPI.h"
48298: #endif
48298: 
38166: #include "History.h"
38166: #include "nsNavHistory.h"
47715: #include "nsNavBookmarks.h"
41398: #include "Helpers.h"
38166: 
38166: #include "mozilla/storage.h"
38166: #include "mozilla/dom/Link.h"
38166: #include "nsDocShellCID.h"
38166: #include "nsIEventStateManager.h"
41398: #include "mozilla/Services.h"
38166: 
38166: using namespace mozilla::dom;
38166: 
38166: namespace mozilla {
38166: namespace places {
38166: 
38166: ////////////////////////////////////////////////////////////////////////////////
38477: //// Global Defines
38477: 
38477: #define URI_VISITED "visited"
38477: #define URI_NOT_VISITED "not visited"
38477: #define URI_VISITED_RESOLUTION_TOPIC "visited-status-resolution"
47715: // Observer event fired after a visit has been registered in the DB.
47715: #define URI_VISIT_SAVED "uri-visit-saved"
47715: 
47715: ////////////////////////////////////////////////////////////////////////////////
47715: //// Step
47715: 
47715: class Step : public AsyncStatementCallback
47715: {
47715: public:
47715:   /**
47715:    * Executes statement asynchronously using this as a callback.
47715:    * 
47715:    * @param aStmt
47715:    *        Statement to execute asynchronously
47715:    */
47715:   NS_IMETHOD ExecuteAsync(mozIStorageStatement* aStmt);
47715: 
47715:   /**
47715:    * Called once after query is completed.  If your query has more than one
47715:    * result set to process, you will want to override HandleResult to process
47715:    * each one.
47715:    *
47715:    * @param aResultSet
47715:    *        Results from ExecuteAsync
47715:    *        Unlike HandleResult, this *can be NULL* if there were no results.
47715:    */
47715:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet);
47715: 
47715:   /**
47715:    * By default, stores the last result set received in mResultSet.
47715:    * For queries with only one result set, you don't need to override.
47715:    *
47715:    * @param aResultSet
47715:    *        Results from ExecuteAsync
47715:    */
47715:   NS_IMETHOD HandleResult(mozIStorageResultSet* aResultSet);
47715: 
47715:   /**
47715:    * By default, this calls Callback with any saved results from HandleResult.
47715:    * For queries with only one result set, you don't need to override.
47715:    *
47715:    * @param aReason
47715:    *        SQL status code
47715:    */
47715:   NS_IMETHOD HandleCompletion(PRUint16 aReason);
47715: 
47715: private:
47715:   // Used by HandleResult to cache results until HandleCompletion is called.
47715:   nsCOMPtr<mozIStorageResultSet> mResultSet;
47715: };
47715: 
47715: NS_IMETHODIMP
47715: Step::ExecuteAsync(mozIStorageStatement* aStmt)
47715: {
47715:   nsCOMPtr<mozIStoragePendingStatement> handle;
47715:   nsresult rv = aStmt->ExecuteAsync(this, getter_AddRefs(handle));
47715:   NS_ENSURE_SUCCESS(rv, rv);
47715:   return NS_OK;
47715: }
47715: 
47715: NS_IMETHODIMP
47715: Step::Callback(mozIStorageResultSet* aResultSet)
47715: {
47715:   return NS_OK;
47715: }
47715: 
47715: NS_IMETHODIMP
47715: Step::HandleResult(mozIStorageResultSet* aResultSet)
47715: {
47715:   mResultSet = aResultSet;
47715:   return NS_OK;
47715: }
47715: 
47715: NS_IMETHODIMP
47715: Step::HandleCompletion(PRUint16 aReason)
47715: {
49687:   if (aReason == mozIStorageStatementCallback::REASON_FINISHED) {
47715:     nsCOMPtr<mozIStorageResultSet> resultSet = mResultSet;
47715:     mResultSet = NULL;
47715:     Callback(resultSet);
49687:   }
47715:   return NS_OK;
47715: }
38477: 
38477: ////////////////////////////////////////////////////////////////////////////////
38166: //// Anonymous Helpers
38166: 
38166: namespace {
38166: 
38166: class VisitedQuery : public mozIStorageStatementCallback
38166: {
38166: public:
38166:   NS_DECL_ISUPPORTS
38166: 
38166:   static nsresult Start(nsIURI* aURI)
38166:   {
47715:     NS_PRECONDITION(aURI, "Null URI");
38166: 
48297: #ifdef MOZ_IPC
48297:   // If we are a content process, always remote the request to the
48297:   // parent process.
48297:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
48297:     mozilla::dom::ContentChild * cpc = 
48297:       mozilla::dom::ContentChild::GetSingleton();
48297:     NS_ASSERTION(cpc, "Content Protocol is NULL!");
48842:     (void)cpc->SendStartVisitedQuery(aURI);
48297:     return NS_OK;
48297:   }
48297: #endif
48297: 
38166:     nsNavHistory* navHist = nsNavHistory::GetHistoryService();
38166:     NS_ENSURE_TRUE(navHist, NS_ERROR_FAILURE);
41398:     mozIStorageStatement* stmt = navHist->GetStatementById(DB_IS_PAGE_VISITED);
38166:     NS_ENSURE_STATE(stmt);
38166: 
41398:     // Bind by index for performance.
41398:     nsresult rv = URIBinder::Bind(stmt, 0, aURI);
38166:     NS_ENSURE_SUCCESS(rv, rv);
38166: 
38166:     nsRefPtr<VisitedQuery> callback = new VisitedQuery(aURI);
38166:     NS_ENSURE_TRUE(callback, NS_ERROR_OUT_OF_MEMORY);
38166: 
38166:     nsCOMPtr<mozIStoragePendingStatement> handle;
38166:     return stmt->ExecuteAsync(callback, getter_AddRefs(handle));
38166:   }
38166: 
38166:   NS_IMETHOD HandleResult(mozIStorageResultSet* aResults)
38166:   {
38166:     // If this method is called, we've gotten results, which means we have a
38166:     // visit.
38166:     mIsVisited = true;
38166:     return NS_OK;
38166:   }
38166: 
38166:   NS_IMETHOD HandleError(mozIStorageError* aError)
38166:   {
38166:     // mIsVisited is already set to false, and that's the assumption we will
38166:     // make if an error occurred.
38166:     return NS_OK;
38166:   }
38166: 
38166:   NS_IMETHOD HandleCompletion(PRUint16 aReason)
38166:   {
49687:     if (aReason != mozIStorageStatementCallback::REASON_FINISHED) {
49687:       return NS_OK;
49687:     }
49687: 
46955:     if (mIsVisited) {
46955:       History::GetService()->NotifyVisited(mURI);
46955:     }
46955: 
46955:     // Notify any observers about that we have resolved the visited state of
46955:     // this URI.
46955:     nsCOMPtr<nsIObserverService> observerService =
41398:       mozilla::services::GetObserverService();
46955:     if (observerService) {
46955:       nsAutoString status;
46955:       if (mIsVisited) {
46955:         status.AssignLiteral(URI_VISITED);
46955:       }
46955:       else {
46955:         status.AssignLiteral(URI_NOT_VISITED);
46955:       }
46955:       (void)observerService->NotifyObservers(mURI,
46955:                                              URI_VISITED_RESOLUTION_TOPIC,
46955:                                              status.get());
46955:     }
46955: 
38166:     return NS_OK;
38166:   }
38166: private:
38166:   VisitedQuery(nsIURI* aURI)
38166:   : mURI(aURI)
38166:   , mIsVisited(false)
38166:   {
38166:   }
38166: 
38166:   nsCOMPtr<nsIURI> mURI;
38166:   bool mIsVisited;
38166: };
38166: NS_IMPL_ISUPPORTS1(
38166:   VisitedQuery,
38166:   mozIStorageStatementCallback
38166: )
38166: 
47715: /**
47715:  * Fail-safe mechanism for ensuring that your task completes, no matter what.
47715:  * Pass this around as an nsAutoPtr in your steps to guarantee that when all
47715:  * your steps are finished, your task is finished.
47715:  *
47715:  * Be sure to use AppendTask to add your first step to the queue.
47715:  */
47715: class FailSafeFinishTask
47715: {
47715: public:
47715:   FailSafeFinishTask()
47715:   : mAppended(false) 
47715:   {
47715:   }
47715: 
47715:   ~FailSafeFinishTask()
47715:   {
47715:     if (mAppended) {
47715:       History::GetService()->CurrentTaskFinished();
47715:     }
47715:   }
47715: 
47715:   /**
47715:    * Appends task to History's queue.  When this object is destroyed, it will
47715:    * consider the task finished.
47715:    */
47715:   void AppendTask(Step* step)
47715:   {
47715:     History::GetService()->AppendTask(step);
47715:     mAppended = true;
47715:   }
47715: 
47715: private:
47715:   bool mAppended;
47715: };
47715: 
47715: ////////////////////////////////////////////////////////////////////////////////
47715: //// Steps for VisitURI
47715: 
47715: struct VisitURIData : public FailSafeFinishTask
47715: {
47715:   PRInt64 placeId;
47715:   PRInt32 hidden;
47715:   PRInt32 typed;
47715:   nsCOMPtr<nsIURI> uri;
47715: 
47715:   // Url of last added visit in chain.
47715:   nsCString lastSpec;
47715:   PRInt64 lastVisitId;
47715:   PRInt32 transitionType;
47715:   PRInt64 sessionId;
47715:   PRTime dateTime;
47715: };
47715: 
47715: /**
47715:  * Step 6: Update frecency of URI and notify observers.
47715:  */
47715: class UpdateFrecencyAndNotifyStep : public Step
47715: {
47715: public:
47715:   NS_DECL_ISUPPORTS
47715: 
47715:   UpdateFrecencyAndNotifyStep(nsAutoPtr<VisitURIData> aData)
47715:   : mData(aData)
47715:   {
47715:   }
47715: 
47715:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
47715:   {
47715:     // Result set contains new visit created in earlier step
47715:     NS_ENSURE_STATE(aResultSet);
47715: 
47715:     nsCOMPtr<mozIStorageRow> row;
47715:     nsresult rv = aResultSet->GetNextRow(getter_AddRefs(row));
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:     PRInt64 visitId;
47715:     rv = row->GetInt64(0, &visitId);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:     // TODO need to figure out story for not synchronous frecency updating
47715:     // (bug 556631)
47715: 
47715:     // Swallow errors here, since if we've gotten this far, it's more
47715:     // important to notify the observers below.
47715:     nsNavHistory* history = nsNavHistory::GetHistoryService();
47715:     NS_WARN_IF_FALSE(history, "Could not get history service");
47715:     nsNavBookmarks* bookmarks = nsNavBookmarks::GetBookmarksService();
47715:     NS_WARN_IF_FALSE(bookmarks, "Could not get bookmarks service");
47715:     if (history && bookmarks) {
47715:       // Update frecency *after* the visit info is in the db
47715:       nsresult rv = history->UpdateFrecency(
47715:         mData->placeId,
47715:         bookmarks->IsRealBookmark(mData->placeId)
47715:       );
47715:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not update frecency");
47715: 
47715:       // Notify nsNavHistory observers of visit, but only for certain types of
47715:       // visits to maintain consistency with nsNavHistory::GetQueryResults.
47715:       if (!mData->hidden &&
47715:           mData->transitionType != nsINavHistoryService::TRANSITION_EMBED &&
47715:           mData->transitionType != nsINavHistoryService::TRANSITION_FRAMED_LINK) {
47715:         history->NotifyOnVisit(mData->uri, visitId, mData->dateTime,
47715:                                mData->sessionId, mData->lastVisitId,
47715:                                mData->transitionType);
47715:       }
47715:     }
47715: 
47715:     nsCOMPtr<nsIObserverService> obsService =
47715:       mozilla::services::GetObserverService();
47715:     if (obsService) {
47715:       nsresult rv = obsService->NotifyObservers(mData->uri, URI_VISIT_SAVED, nsnull);
47715:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Could not notify observers");
47715:     }
47715: 
47715:     History::GetService()->NotifyVisited(mData->uri);
47715: 
47715:     return NS_OK;
47715:   }
47715: 
47715: protected:
47715:   nsAutoPtr<VisitURIData> mData;
47715: };
47715: NS_IMPL_ISUPPORTS1(
47715:   UpdateFrecencyAndNotifyStep
47715: , mozIStorageStatementCallback
47715: )
47715: 
47715: /**
47715:  * Step 5: Get newly created visit ID from moz_history_visits table.
47715:  */
47715: class GetVisitIDStep : public Step
47715: {
47715: public:
47715:   NS_DECL_ISUPPORTS
47715: 
47715:   GetVisitIDStep(nsAutoPtr<VisitURIData> aData)
47715:   : mData(aData)
47715:   {
47715:   }
47715: 
47715:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
47715:   {
47715:     // Find visit ID, needed for notifying observers in next step.
47715:     nsNavHistory* history = nsNavHistory::GetHistoryService();
47715:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
47715:     nsCOMPtr<mozIStorageStatement> stmt =
47715:       history->GetStatementById(DB_RECENT_VISIT_OF_URL);
47715:     NS_ENSURE_STATE(stmt);
47715: 
47715:     nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->uri);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:     nsCOMPtr<Step> step = new UpdateFrecencyAndNotifyStep(mData);
47715:     NS_ENSURE_STATE(step);
47715:     rv = step->ExecuteAsync(stmt);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:     return NS_OK;
47715:   }
47715: 
47715: protected:
47715:   nsAutoPtr<VisitURIData> mData;
47715: };
47715: NS_IMPL_ISUPPORTS1(
47715:   GetVisitIDStep
47715: , mozIStorageStatementCallback
47715: )
47715: 
47715: /**
47715:  * Step 4: Add visit to moz_history_visits table.
47715:  */
47715: class AddVisitStep : public Step
47715: {
47715: public:
47715:   NS_DECL_ISUPPORTS
47715: 
47715:   AddVisitStep(nsAutoPtr<VisitURIData> aData)
47715:   : mData(aData)
47715:   {
47715:   }
47715: 
47715:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
47715:   {
47715:     nsresult rv;
47715: 
47715:     nsNavHistory* history = nsNavHistory::GetHistoryService();
47715:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
47715: 
47715:     // TODO need to figure out story for new session IDs that isn't synchronous
47715:     // (bug 561450)
47715: 
47715:     if (aResultSet) {
47715:       // Result set contains last visit information for this session
47715:       nsCOMPtr<mozIStorageRow> row;
47715:       rv = aResultSet->GetNextRow(getter_AddRefs(row));
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:       PRInt64 possibleSessionId;
47715:       PRTime lastVisitOfSession;
47715: 
47715:       rv = row->GetInt64(0, &mData->lastVisitId);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:       rv = row->GetInt64(1, &possibleSessionId);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:       rv = row->GetInt64(2, &lastVisitOfSession);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:       if (mData->dateTime - lastVisitOfSession <= RECENT_EVENT_THRESHOLD) {
47715:         mData->sessionId = possibleSessionId;
47715:       }
47715:       else {
47715:         // Session is too old. Start a new one.
47715:         mData->sessionId = history->GetNewSessionID();
47715:         mData->lastVisitId = 0;
47715:       }
47715:     }
47715:     else {
47715:       // No previous saved visit entry could be found, so start a new session.
47715:       mData->sessionId = history->GetNewSessionID();
47715:       mData->lastVisitId = 0;
47715:     }
47715: 
47715:     nsCOMPtr<mozIStorageStatement> stmt =
47715:       history->GetStatementById(DB_INSERT_VISIT);
47715:     NS_ENSURE_STATE(stmt);
47715: 
47715:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("from_visit"),
47715:                                mData->lastVisitId);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"),
47715:                                mData->placeId);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("visit_date"),
47715:                                mData->dateTime);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715:     rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("visit_type"),
47715:                                mData->transitionType);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("session"),
47715:                                mData->sessionId);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:     nsCOMPtr<Step> step = new GetVisitIDStep(mData);
47715:     NS_ENSURE_STATE(step);
47715:     rv = step->ExecuteAsync(stmt);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:     return NS_OK;
47715:   }
47715: 
47715: protected:
47715:   nsAutoPtr<VisitURIData> mData;
47715: };
47715: NS_IMPL_ISUPPORTS1(
47715:   AddVisitStep
47715: , mozIStorageStatementCallback
47715: )
47715: 
47715: /**
47715:  * Step 3: Callback for inserting or updating a moz_places entry.
47715:  *         This step checks database for the last visit in session.
47715:  */
47715: class CheckLastVisitStep : public Step
47715: {
47715: public:
47715:   NS_DECL_ISUPPORTS
47715: 
47715:   CheckLastVisitStep(nsAutoPtr<VisitURIData> aData)
47715:   : mData(aData)
47715:   {
47715:   }
47715: 
47715:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
47715:   {
47715:     nsresult rv;
47715: 
47715:     if (aResultSet) {
47715:       // Last step inserted a new URL. This query contains the id.
47715:       nsCOMPtr<mozIStorageRow> row;
47715:       rv = aResultSet->GetNextRow(getter_AddRefs(row));
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:       rv = row->GetInt64(0, &mData->placeId);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:     }
47715: 
47715:     if (!mData->lastSpec.IsEmpty()) {
47715:       // Find last visit ID and session ID using lastSpec so we can add them
47715:       // to a browsing session if the visit was recent.
47715:       nsNavHistory* history = nsNavHistory::GetHistoryService();
47715:       NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
47715:       nsCOMPtr<mozIStorageStatement> stmt =
47715:         history->GetStatementById(DB_RECENT_VISIT_OF_URL);
47715:       NS_ENSURE_STATE(stmt);
47715: 
47715:       rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->lastSpec);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:       nsCOMPtr<Step> step = new AddVisitStep(mData);
47715:       NS_ENSURE_STATE(step);
47715:       rv = step->ExecuteAsync(stmt);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:     }
47715:     else {
47715:       // Empty lastSpec.
47715:       // Not part of a session.  Just run next step's callback with no results.
47715:       nsCOMPtr<Step> step = new AddVisitStep(mData);
47715:       NS_ENSURE_STATE(step);
47715:       rv = step->Callback(NULL);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:     }
47715: 
47715:     return NS_OK;
47715:   }
47715: 
47715: protected:
47715:   nsAutoPtr<VisitURIData> mData;
47715: };
47715: NS_IMPL_ISUPPORTS1(
47715:   CheckLastVisitStep
47715: , mozIStorageStatementCallback
47715: )
47715: 
47715: /**
47715:  * Step 2a: Called only when a new entry is put into moz_places.
47715:  *          Finds the ID of a recently inserted place.
47715:  */
47715: class FindNewIdStep : public Step
47715: {
47715: public:
47715:   NS_DECL_ISUPPORTS
47715: 
47715:   FindNewIdStep(nsAutoPtr<VisitURIData> aData)
47715:   : mData(aData)
47715:   {
47715:   }
47715: 
47715:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
47715:   {
47715:     nsNavHistory* history = nsNavHistory::GetHistoryService();
47715:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
47715:     nsCOMPtr<mozIStorageStatement> stmt =
47715:       history->GetStatementById(DB_GET_PAGE_VISIT_STATS);
47715:     NS_ENSURE_STATE(stmt);
47715: 
47715:     nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->uri);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:     nsCOMPtr<Step> step = new CheckLastVisitStep(mData);
47715:     NS_ENSURE_STATE(step);
47715:     rv = step->ExecuteAsync(stmt);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:     return NS_OK;
47715:   }
47715: 
47715: protected:
47715:   nsAutoPtr<VisitURIData> mData;
47715: };
47715: NS_IMPL_ISUPPORTS1(
47715:   FindNewIdStep
47715: , mozIStorageStatementCallback
47715: )
47715: 
47715: /**
47715:  * Step 2: Callback for checking for an existing URI in moz_places.
47715:  *         This step inserts or updates the URI accordingly.
47715:  */
47715: class CheckExistingStep : public Step
47715: {
47715: public:
47715:   NS_DECL_ISUPPORTS
47715: 
47715:   CheckExistingStep(nsAutoPtr<VisitURIData> aData)
47715:   : mData(aData)
47715:   {
47715:   }
47715: 
47715:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
47715:   {
47715:     nsresult rv;
47715:     nsCOMPtr<mozIStorageStatement> stmt;
47715: 
47715:     nsNavHistory* history = nsNavHistory::GetHistoryService();
47715:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
47715: 
47715:     if (aResultSet) {
47715:       nsCOMPtr<mozIStorageRow> row;
47715:       rv = aResultSet->GetNextRow(getter_AddRefs(row));
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:       rv = row->GetInt64(0, &mData->placeId);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:       if (!mData->typed) {
47715:         // If this transition wasn't typed, others might have been. If database
47715:         // has location as typed, reflect that in our data structure.
47715:         rv = row->GetInt32(2, &mData->typed);
47715:         NS_ENSURE_SUCCESS(rv, rv);
47715:       }
47715:       if (mData->hidden) {
47715:         // If this transition was hidden, it is possible that others were not.
47715:         // Any one visible transition makes this location visible. If database
47715:         // has location as visible, reflect that in our data structure.
47715:         rv = row->GetInt32(3, &mData->hidden);
47715:         NS_ENSURE_SUCCESS(rv, rv);
47715:       }
47715: 
47715:       // Note: trigger will update visit_count.
47715:       stmt = history->GetStatementById(DB_UPDATE_PAGE_VISIT_STATS);
47715:       NS_ENSURE_STATE(stmt);
47715: 
47715:       rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("typed"), mData->typed);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:       rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("hidden"), mData->hidden);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:       rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), mData->placeId);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:       nsCOMPtr<Step> step = new CheckLastVisitStep(mData);
47715:       NS_ENSURE_STATE(step);
47715:       rv = step->ExecuteAsync(stmt);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:     }
47715:     else {
47715:       // No entry exists, so create one.
47715:       stmt = history->GetStatementById(DB_ADD_NEW_PAGE);
47715:       NS_ENSURE_STATE(stmt);
47715: 
47715:       nsAutoString revHost;
47715:       rv = GetReversedHostname(mData->uri, revHost);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:       rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->uri);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:       rv = stmt->BindStringByName(NS_LITERAL_CSTRING("rev_host"), revHost);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:       rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("typed"), mData->typed);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:       rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("hidden"), mData->hidden);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:       rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("frecency"), -1);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:       nsCOMPtr<Step> step = new FindNewIdStep(mData);
47715:       NS_ENSURE_STATE(step);
47715:       rv = step->ExecuteAsync(stmt);
47715:       NS_ENSURE_SUCCESS(rv, rv);
47715:     }
47715: 
47715:     return NS_OK;
47715:   }
47715: 
47715: protected:
47715:   nsAutoPtr<VisitURIData> mData;
47715: };
47715: NS_IMPL_ISUPPORTS1(
47715:   CheckExistingStep
47715: , mozIStorageStatementCallback
47715: )
47715: 
47715: /**
47715:  * Step 1: See if there is an existing URI.
47715:  */
47715: class StartVisitURIStep : public Step
47715: {
47715: public:
47715:   NS_DECL_ISUPPORTS
47715: 
47715:   StartVisitURIStep(nsAutoPtr<VisitURIData> aData)
47715:   : mData(aData)
47715:   {
47715:     mData->AppendTask(this);
47715:   }
47715: 
47715:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
47715:   {
47715:     nsNavHistory* history = nsNavHistory::GetHistoryService();
47715:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
47715: 
47715:     // Find existing entry in moz_places table, if any.
47715:     nsCOMPtr<mozIStorageStatement> stmt =
47715:       history->GetStatementById(DB_GET_PAGE_VISIT_STATS);
47715:     NS_ENSURE_STATE(stmt);
47715: 
47715:     nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->uri);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:     nsCOMPtr<Step> step = new CheckExistingStep(mData);
47715:     NS_ENSURE_STATE(step);
47715:     rv = step->ExecuteAsync(stmt);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715: 
47715:     return NS_OK;
47715:   }
47715: 
47715: protected:
47715:   nsAutoPtr<VisitURIData> mData;
47715: };
47715: NS_IMPL_ISUPPORTS1(
47715:   StartVisitURIStep
47715: , Step
47715: )
47715: 
47716: ////////////////////////////////////////////////////////////////////////////////
47716: //// Steps for SetURITitle
47716: 
47716: struct SetTitleData : public FailSafeFinishTask
47716: {
47716:   nsCOMPtr<nsIURI> uri;
47716:   nsString title;
47716: };
47716: 
47716: /**
47716:  * Step 3: Notify that title has been updated.
47716:  */
47716: class TitleNotifyStep: public Step
47716: {
47716: public:
47716:   NS_DECL_ISUPPORTS
47716: 
47716:   TitleNotifyStep(nsAutoPtr<SetTitleData> aData)
47716:   : mData(aData)
47716:   {
47716:   }
47716: 
47716:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
47716:   {
47716:     nsNavHistory* history = nsNavHistory::GetHistoryService();
47716:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
47716:     history->NotifyTitleChange(mData->uri, mData->title);
47716: 
47716:     return NS_OK;
47716:   }
47716: 
47716: protected:
47716:   nsAutoPtr<SetTitleData> mData;
47716: };
47716: NS_IMPL_ISUPPORTS1(
47716:   TitleNotifyStep
47716: , mozIStorageStatementCallback
47716: )
47716: 
47716: /**
47716:  * Step 2: Set title.
47716:  */
47716: class SetTitleStep : public Step
47716: {
47716: public:
47716:   NS_DECL_ISUPPORTS
47716: 
47716:   SetTitleStep(nsAutoPtr<SetTitleData> aData)
47716:   : mData(aData)
47716:   {
47716:   }
47716: 
47716:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
47716:   {
47716:     if (!aResultSet) {
47716:       // URI record was not found.
47716:       return NS_OK;
47716:     }
47716: 
47716:     nsCOMPtr<mozIStorageRow> row;
47716:     nsresult rv = aResultSet->GetNextRow(getter_AddRefs(row));
47716:     NS_ENSURE_SUCCESS(rv, rv);
47716: 
47716:     nsAutoString title;
47716:     rv = row->GetString(2, title);
47716:     NS_ENSURE_SUCCESS(rv, rv);
47716: 
47716:     // It is actually common to set the title to be the same thing it used to
47716:     // be. For example, going to any web page will always cause a title to be set,
47716:     // even though it will often be unchanged since the last visit. In these
47716:     // cases, we can avoid DB writing and observer overhead.
47716:     if (mData->title.Equals(title) || (mData->title.IsVoid() && title.IsVoid()))
47716:       return NS_OK;
47716: 
47716:     nsNavHistory* history = nsNavHistory::GetHistoryService();
47716:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
47716: 
47716:     nsCOMPtr<mozIStorageStatement> stmt =
47716:       history->GetStatementById(DB_SET_PLACE_TITLE);
47716:     NS_ENSURE_STATE(stmt);
47716: 
47716:     if (mData->title.IsVoid()) {
47716:       rv = stmt->BindNullByName(NS_LITERAL_CSTRING("page_title"));
47716:     }
47716:     else {
47716:       rv = stmt->BindStringByName(
47716:         NS_LITERAL_CSTRING("page_title"),
47716:         StringHead(mData->title, TITLE_LENGTH_MAX)
47716:       );
47716:     }
47716:     NS_ENSURE_SUCCESS(rv, rv);
47716: 
47716:     rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->uri);
47716:     NS_ENSURE_SUCCESS(rv, rv);
47716: 
47716:     nsCOMPtr<Step> step = new TitleNotifyStep(mData);
47716:     rv = step->ExecuteAsync(stmt);
47716:     NS_ENSURE_SUCCESS(rv, rv);
47716: 
47716:     return NS_OK;
47716:   }
47716: 
47716: protected:
47716:   nsAutoPtr<SetTitleData> mData;
47716: };
47716: NS_IMPL_ISUPPORTS1(
47716:   SetTitleStep
47716: , mozIStorageStatementCallback
47716: )
47716: 
47716: /**
47716:  * Step 1: See if there is an existing URI.
47716:  */
47716: class StartSetURITitleStep : public Step
47716: {
47716: public:
47716:   NS_DECL_ISUPPORTS
47716: 
47716:   StartSetURITitleStep(nsAutoPtr<SetTitleData> aData)
47716:   : mData(aData)
47716:   {
47716:     mData->AppendTask(this);
47716:   }
47716: 
47716:   NS_IMETHOD Callback(mozIStorageResultSet* aResultSet)
47716:   {
47716:     nsNavHistory* history = nsNavHistory::GetHistoryService();
47716:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
47716: 
47716:     // Find existing entry in moz_places table, if any.
47716:     nsCOMPtr<mozIStorageStatement> stmt =
47716:       history->GetStatementById(DB_GET_URL_PAGE_INFO);
47716:     NS_ENSURE_STATE(stmt);
47716: 
47716:     nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData->uri);
47716:     NS_ENSURE_SUCCESS(rv, rv);
47716: 
47716:     nsCOMPtr<Step> step = new SetTitleStep(mData);
47716:     rv = step->ExecuteAsync(stmt);
47716:     NS_ENSURE_SUCCESS(rv, rv);
47716: 
47716:     return NS_OK;
47716:   }
47716: 
47716: protected:
47716:   nsAutoPtr<SetTitleData> mData;
47716: };
47716: NS_IMPL_ISUPPORTS1(
47716:   StartSetURITitleStep
47716: , Step
47716: )
47716: 
38166: } // anonymous namespace
38166: 
38166: ////////////////////////////////////////////////////////////////////////////////
38166: //// History
38166: 
47167: History* History::gService = NULL;
38166: 
38166: History::History()
47715: : mShuttingDown(false)
38166: {
38166:   NS_ASSERTION(!gService, "Ruh-roh!  This service has already been created!");
38166:   gService = this;
47715: 
47715:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
47715:   NS_WARN_IF_FALSE(os, "Observer service was not found!");
47715:   if (os) {
47715:     (void)os->AddObserver(this, TOPIC_PLACES_SHUTDOWN, PR_FALSE);
47715:   }
38166: }
38166: 
38166: History::~History()
38166: {
47167:   gService = NULL;
47715: 
38900: #ifdef DEBUG
38900:   if (mObservers.IsInitialized()) {
38900:     NS_ASSERTION(mObservers.Count() == 0,
38900:                  "Not all Links were removed before we disappear!");
38900:   }
38900: #endif
47715: 
47715:   // Places shutdown event may not occur, but we *must* clean up before History
47715:   // goes away.
47715:   Shutdown();
47715: }
47715: 
47715: void
47715: History::AppendTask(Step* aTask)
47715: {
47715:   NS_PRECONDITION(aTask, "Got NULL task.");
47715: 
47715:   if (mShuttingDown) {
47715:     return;
47715:   }
47715: 
47715:   NS_ADDREF(aTask);
47715:   mPendingVisits.Push(aTask);
47715: 
47715:   if (mPendingVisits.GetSize() == 1) {
47715:     // There are no other pending tasks.
47715:     StartNextTask();
47715:   }
47715: }
47715: 
47715: void
47715: History::CurrentTaskFinished()
47715: {
47715:   if (mShuttingDown) {
47715:     return;
47715:   }
47715: 
47715:   NS_ASSERTION(mPendingVisits.PeekFront(), "Tried to finish task not on the queue");
47715: 
47715:   nsCOMPtr<Step> deadTaskWalking =
47715:     dont_AddRef(static_cast<Step*>(mPendingVisits.PopFront()));
47715:   StartNextTask();
38166: }
38166: 
38166: void
46955: History::NotifyVisited(nsIURI* aURI)
38166: {
38166:   NS_ASSERTION(aURI, "Ruh-roh!  A NULL URI was passed to us!");
38166: 
48297: #ifdef MOZ_IPC
48297:   if (XRE_GetProcessType() == GeckoProcessType_Default) {
48297:     mozilla::dom::ContentParent* cpp = 
48297:       mozilla::dom::ContentParent::GetSingleton(PR_FALSE);
48297:     if (cpp)
48842:       (void)cpp->SendNotifyVisited(aURI);
48297:   }
48297: #endif
48297: 
38166:   // If the hash table has not been initialized, then we have nothing to notify
38166:   // about.
38166:   if (!mObservers.IsInitialized()) {
38166:     return;
38166:   }
38166: 
38166:   // Additionally, if we have no observers for this URI, we have nothing to
38166:   // notify about.
38166:   KeyClass* key = mObservers.GetEntry(aURI);
38166:   if (!key) {
38166:     return;
38166:   }
38166: 
38166:   // Walk through the array, and update each Link node.
38166:   const ObserverArray& observers = key->array;
38166:   ObserverArray::index_type len = observers.Length();
38166:   for (ObserverArray::index_type i = 0; i < len; i++) {
38166:     Link* link = observers[i];
38166:     link->SetLinkState(eLinkState_Visited);
38166:     NS_ASSERTION(len == observers.Length(),
38166:                  "Calling SetLinkState added or removed an observer!");
38166:   }
38166: 
38166:   // All the registered nodes can now be removed for this URI.
38166:   mObservers.RemoveEntry(aURI);
38166: }
38166: 
38166: /* static */
38166: History*
38166: History::GetService()
38166: {
38166:   if (gService) {
38166:     return gService;
38166:   }
38166: 
38166:   nsCOMPtr<IHistory> service(do_GetService(NS_IHISTORY_CONTRACTID));
38166:   NS_ABORT_IF_FALSE(service, "Cannot obtain IHistory service!");
38166:   NS_ASSERTION(gService, "Our constructor was not run?!");
38166: 
38166:   return gService;
38166: }
38166: 
38166: /* static */
38166: History*
38166: History::GetSingleton()
38166: {
38166:   if (!gService) {
38166:     gService = new History();
38166:     NS_ENSURE_TRUE(gService, nsnull);
38166:   }
38166: 
38166:   NS_ADDREF(gService);
38166:   return gService;
38166: }
38166: 
47715: void
47715: History::StartNextTask()
47715: {
47715:   if (mShuttingDown) {
47715:     return;
47715:   }
47715: 
47715:   nsCOMPtr<Step> nextTask =
47715:     static_cast<Step*>(mPendingVisits.PeekFront());
47715:   if (!nextTask) {
47715:     // No more pending visits left to process.
47715:     return;
47715:   }
47715:   nsresult rv = nextTask->Callback(NULL);
47715:   NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Beginning a task failed.");
47715: }
47715: 
47715: void
47715: History::Shutdown()
47715: {
47715:   mShuttingDown = true;
47715: 
47715:   while (mPendingVisits.PeekFront()) {
47715:     nsCOMPtr<Step> deadTaskWalking =
47715:       dont_AddRef(static_cast<Step*>(mPendingVisits.PopFront()));
47715:   }
47715: }
47715: 
38166: ////////////////////////////////////////////////////////////////////////////////
38166: //// IHistory
38166: 
38166: NS_IMETHODIMP
47715: History::VisitURI(nsIURI* aURI,
47715:                   nsIURI* aLastVisitedURI,
47715:                   PRUint32 aFlags)
47715: {
47715:   NS_PRECONDITION(aURI, "URI should not be NULL.");
47715:   if (mShuttingDown) {
47715:     return NS_OK;
47715:   }
47715: 
48298: #ifdef MOZ_IPC
48298:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
48298:     mozilla::dom::ContentChild * cpc = 
48298:       mozilla::dom::ContentChild::GetSingleton();
48298:     NS_ASSERTION(cpc, "Content Protocol is NULL!");
48842:     (void)cpc->SendVisitURI(aURI, aLastVisitedURI, aFlags);
48298:     return NS_OK;
48298:   } 
48298: #endif /* MOZ_IPC */
48298: 
47715:   nsNavHistory* history = nsNavHistory::GetHistoryService();
47715:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
47715: 
47715:   // Silently return if URI is something we shouldn't add to DB.
47715:   PRBool canAdd;
47715:   nsresult rv = history->CanAddURI(aURI, &canAdd);
47715:   NS_ENSURE_SUCCESS(rv, rv);
47715:   if (!canAdd) {
47715:     return NS_OK;
47715:   }
47715: 
47715:   // Populate data structure that will be used in our async SQL steps.
47715:   nsAutoPtr<VisitURIData> data(new VisitURIData());
47715:   NS_ENSURE_STATE(data);
47715: 
47715:   nsCAutoString spec;
47715:   rv = aURI->GetSpec(spec);
47715:   NS_ENSURE_SUCCESS(rv, rv);
47715:   if (aLastVisitedURI) {
47715:     rv = aLastVisitedURI->GetSpec(data->lastSpec);
47715:     NS_ENSURE_SUCCESS(rv, rv);
47715:   }
47715: 
47715:   if (spec.Equals(data->lastSpec)) {
47715:     // Do not save refresh-page visits.
47715:     return NS_OK;
47715:   }
47715: 
47715:   // Assigns a type to the edge in the visit linked list. Each type will be
47715:   // considered differently when weighting the frecency of a location.
47715:   PRUint32 recentFlags = history->GetRecentFlags(aURI);
47715:   bool redirected = false;
47715:   if (aFlags & IHistory::REDIRECT_TEMPORARY) {
47715:     data->transitionType = nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY;
47715:     redirected = true;
47715:   }
47715:   else if (aFlags & IHistory::REDIRECT_PERMANENT) {
47715:     data->transitionType = nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT;
47715:     redirected = true;
47715:   }
47715:   else if (recentFlags & nsNavHistory::RECENT_TYPED) {
47715:     data->transitionType = nsINavHistoryService::TRANSITION_TYPED;
47715:   }
47715:   else if (recentFlags & nsNavHistory::RECENT_BOOKMARKED) {
47715:     data->transitionType = nsINavHistoryService::TRANSITION_BOOKMARK;
47715:   }
47715:   else if (aFlags & IHistory::TOP_LEVEL) {
47715:     // User was redirected or link was clicked in the main window.
47715:     data->transitionType = nsINavHistoryService::TRANSITION_LINK;
47715:   }
47715:   else if (recentFlags & nsNavHistory::RECENT_ACTIVATED) {
47715:     // User activated a link in a frame.
47715:     data->transitionType = nsINavHistoryService::TRANSITION_FRAMED_LINK;
47715:   }
47715:   else {
47715:     // A frame redirected to a new site without user interaction.
47715:     data->transitionType = nsINavHistoryService::TRANSITION_EMBED;
47715:   }
47715: 
47715:   data->typed = (data->transitionType == nsINavHistoryService::TRANSITION_TYPED) ? 1 : 0;
47715:   data->hidden = 
47715:     (data->transitionType == nsINavHistoryService::TRANSITION_FRAMED_LINK ||
47715:      data->transitionType == nsINavHistoryService::TRANSITION_EMBED ||
47715:      redirected) ? 1 : 0;
47715:   data->dateTime = PR_Now();
47715:   data->uri = aURI;
47715: 
47715:   nsCOMPtr<Step> task(new StartVisitURIStep(data));
47715: 
47715:   nsCOMPtr<nsIObserverService> obsService =
47715:     mozilla::services::GetObserverService();
47715:   if (obsService) {
47715:     obsService->NotifyObservers(aURI, NS_LINK_VISITED_EVENT_TOPIC, nsnull);
47715:   }
47715: 
47715:   return NS_OK;
47715: }
47715: 
47715: NS_IMETHODIMP
38166: History::RegisterVisitedCallback(nsIURI* aURI,
38166:                                  Link* aLink)
38166: {
38166:   NS_ASSERTION(aURI, "Must pass a non-null URI!");
48297: #ifdef MOZ_IPC
48297:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
48703:     NS_PRECONDITION(aLink, "Must pass a non-null Link!");
48297:   }
48297: #else
48703:   NS_PRECONDITION(aLink, "Must pass a non-null Link!");
48297: #endif
48297: 
38166:   // First, ensure that our hash table is setup.
38166:   if (!mObservers.IsInitialized()) {
38166:     NS_ENSURE_TRUE(mObservers.Init(), NS_ERROR_OUT_OF_MEMORY);
38166:   }
38166: 
38166:   // Obtain our array of observers for this URI.
38900: #ifdef DEBUG
38900:   bool keyAlreadyExists = !!mObservers.GetEntry(aURI);
38900: #endif
38166:   KeyClass* key = mObservers.PutEntry(aURI);
38166:   NS_ENSURE_TRUE(key, NS_ERROR_OUT_OF_MEMORY);
38166:   ObserverArray& observers = key->array;
38166: 
38166:   if (observers.IsEmpty()) {
38900:     NS_ASSERTION(!keyAlreadyExists,
38900:                  "An empty key was kept around in our hashtable!");
38900: 
38166:     // We are the first Link node to ask about this URI, or there are no pending
38166:     // Links wanting to know about this URI.  Therefore, we should query the
38166:     // database now.
46955:     nsresult rv = VisitedQuery::Start(aURI);
56630: 
56630:     // In IPC builds, we are passed a NULL Link from
56630:     // ContentParent::RecvStartVisitedQuery.  Since we won't be adding a NULL
56630:     // entry to our list of observers, and the code after this point assumes
56630:     // that aLink is non-NULL, we will need to return now.
48297:     if (NS_FAILED(rv) || !aLink) {
38900:       // Remove our array from the hashtable so we don't keep it around.
38900:       mObservers.RemoveEntry(aURI);
38166:       return rv;
38166:     }
38166:   }
56630: #ifdef MOZ_IPC
56630:   // In IPC builds, we are passed a NULL Link from
56630:   // ContentParent::RecvStartVisitedQuery.  All of our code after this point
56630:   // assumes aLink is non-NULL, so we have to return now.
56630:   else if (!aLink) {
56630:     NS_ASSERTION(XRE_GetProcessType() == GeckoProcessType_Default,
56630:                  "We should only ever get a null Link in the default process!");
56630:     return NS_OK;
56630:   }
56630: #endif
38166: 
38166:   // Sanity check that Links are not registered more than once for a given URI.
38166:   // This will not catch a case where it is registered for two different URIs.
38166:   NS_ASSERTION(!observers.Contains(aLink),
38166:                "Already tracking this Link object!");
38166: 
38166:   // Start tracking our Link.
38166:   if (!observers.AppendElement(aLink)) {
38166:     // Curses - unregister and return failure.
38166:     (void)UnregisterVisitedCallback(aURI, aLink);
38166:     return NS_ERROR_OUT_OF_MEMORY;
38166:   }
38166: 
38166:   return NS_OK;
38166: }
38166: 
38166: NS_IMETHODIMP
38166: History::UnregisterVisitedCallback(nsIURI* aURI,
38166:                                    Link* aLink)
38166: {
38166:   NS_ASSERTION(aURI, "Must pass a non-null URI!");
38166:   NS_ASSERTION(aLink, "Must pass a non-null Link object!");
38166: 
38166:   // Get the array, and remove the item from it.
38166:   KeyClass* key = mObservers.GetEntry(aURI);
38166:   if (!key) {
38166:     NS_ERROR("Trying to unregister for a URI that wasn't registered!");
38166:     return NS_ERROR_UNEXPECTED;
38166:   }
38166:   ObserverArray& observers = key->array;
38166:   if (!observers.RemoveElement(aLink)) {
38166:     NS_ERROR("Trying to unregister a node that wasn't registered!");
38166:     return NS_ERROR_UNEXPECTED;
38166:   }
38166: 
38166:   // If the array is now empty, we should remove it from the hashtable.
38166:   if (observers.IsEmpty()) {
38166:     mObservers.RemoveEntry(aURI);
38166:   }
38166: 
38166:   return NS_OK;
38166: }
38166: 
47716: NS_IMETHODIMP
47716: History::SetURITitle(nsIURI* aURI, const nsAString& aTitle)
47716: {
47716:   NS_PRECONDITION(aURI, "Must pass a non-null URI!");
47716:   if (mShuttingDown) {
47716:     return NS_OK;
47716:   }
47716: 
48342: #ifdef MOZ_IPC
48342:   if (XRE_GetProcessType() == GeckoProcessType_Content) {
48342:     mozilla::dom::ContentChild * cpc = 
48342:       mozilla::dom::ContentChild::GetSingleton();
48342:     NS_ASSERTION(cpc, "Content Protocol is NULL!");
48842:     (void)cpc->SendSetURITitle(aURI, nsDependentString(aTitle));
48342:     return NS_OK;
48342:   } 
48342: #endif /* MOZ_IPC */
48342: 
47716:   nsNavHistory* history = nsNavHistory::GetHistoryService();
47716: 
47716:   // At first, it seems like nav history should always be available here, no
47716:   // matter what.
47716:   //
47716:   // nsNavHistory fails to register as a service if there is no profile in
47716:   // place (for instance, if user is choosing a profile).
47716:   //
47716:   // Maybe the correct thing to do is to not register this service if no
47716:   // profile has been selected?
47716:   //
47716:   NS_ENSURE_TRUE(history, NS_ERROR_FAILURE);
47716: 
47716:   PRBool canAdd;
47716:   nsresult rv = history->CanAddURI(aURI, &canAdd);
47716:   NS_ENSURE_SUCCESS(rv, rv);
47716:   if (!canAdd) {
47716:     return NS_OK;
47716:   }
47716: 
47716:   nsAutoPtr<SetTitleData> data(new SetTitleData());
47716:   NS_ENSURE_STATE(data);
47716: 
47716:   data->uri = aURI;
47716: 
47716:   if (aTitle.IsEmpty()) {
47716:     data->title.SetIsVoid(PR_TRUE);
47716:   }
47716:   else {
47716:     data->title.Assign(aTitle);
47716:   }
47716: 
47716:   nsCOMPtr<Step> task(new StartSetURITitleStep(data));
47716: 
47716:   return NS_OK;
47716: }
47716: 
38166: ////////////////////////////////////////////////////////////////////////////////
47715: //// nsIObserver
47715: 
47715: NS_IMETHODIMP
47715: History::Observe(nsISupports* aSubject, const char* aTopic,
47715:                  const PRUnichar* aData)
47715: {
47715:   if (strcmp(aTopic, TOPIC_PLACES_SHUTDOWN) == 0) {
47715:     Shutdown();
47715: 
47715:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
47715:     if (os) {
47715:       (void)os->RemoveObserver(this, TOPIC_PLACES_SHUTDOWN);
47715:     }
47715:   }
47715: 
47715:   return NS_OK;
47715: }
47715: 
47715: ////////////////////////////////////////////////////////////////////////////////
38166: //// nsISupports
38166: 
47715: NS_IMPL_ISUPPORTS2(
47715:   History
47715: , IHistory
47715: , nsIObserver
38166: )
38166: 
38166: } // namespace places
38166: } // namespace mozilla
