     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * rendering object for replaced elements that contain a document, such
     1:  * as <frame>, <iframe>, and some <object>s
     1:  */
     1: 
 54019: #include "mozilla/layout/RenderFrameParent.h"
 54019: 
 51753: #include "nsSubDocumentFrame.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsGenericHTMLElement.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDocShellLoadInfo.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsIDocShellTreeNode.h"
     1: #include "nsIDocShellTreeOwner.h"
     1: #include "nsIBaseWindow.h"
     1: #include "nsIContentViewer.h"
     1: #include "nsPresContext.h"
     1: #include "nsIPresShell.h"
     1: #include "nsIComponentManager.h"
     1: #include "nsFrameManager.h"
     1: #include "nsIStreamListener.h"
     1: #include "nsIURL.h"
     1: #include "nsNetUtil.h"
     1: #include "nsIDocument.h"
     1: #include "nsIView.h"
     1: #include "nsIViewManager.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsStyleCoord.h"
     1: #include "nsStyleContext.h"
     1: #include "nsStyleConsts.h"
     1: #include "nsFrameSetFrame.h"
     1: #include "nsIDOMHTMLFrameElement.h"
     1: #include "nsIDOMHTMLIFrameElement.h"
     1: #include "nsIDOMXULElement.h"
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsIScrollable.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsWeakReference.h"
     1: #include "nsIDOMWindow.h"
     1: #include "nsDisplayList.h"
     1: #include "nsUnicharUtils.h"
  8142: #include "nsIScrollableFrame.h"
  8142: #include "nsIObjectLoadingContent.h"
  8142: #include "nsLayoutUtils.h"
 54309: #include "FrameLayerBuilder.h"
 54309: #include "nsObjectFrame.h"
 75263: #include "nsIServiceManager.h"
 75263: #include "nsContentUtils.h"
     1: 
 11414: #ifdef MOZ_XUL
 11414: #include "nsXULPopupManager.h"
 11414: #endif
 11414: 
     1: // For Accessibility
     1: #ifdef ACCESSIBILITY
 61464: #include "nsAccessibilityService.h"
     1: #endif
     1: 
 54309: using namespace mozilla;
 75263: using mozilla::layout::RenderFrameParent;
 54309: 
 54309: static nsIDocument*
 54309: GetDocumentFromView(nsIView* aView)
 54309: {
 54309:   NS_PRECONDITION(aView, "");
 54309: 
 82566:   nsIFrame* f = aView->GetFrame();
106838:   nsIPresShell* ps =  f ? f->PresContext()->PresShell() : nullptr;
106838:   return ps ? ps->GetDocument() : nullptr;
 54309: }
 54309: 
 40755: class AsyncFrameInit;
 40755: 
     1: nsSubDocumentFrame::nsSubDocumentFrame(nsStyleContext* aContext)
 34245:   : nsLeafFrame(aContext)
 80486:   , mIsInline(false)
 80486:   , mPostedReflowCallback(false)
 80486:   , mDidCreateDoc(false)
 80486:   , mCallingShow(false)
     1: {
     1: }
     1: 
     1: #ifdef ACCESSIBILITY
 99648: already_AddRefed<Accessible>
 46338: nsSubDocumentFrame::CreateAccessible()
     1: {
 61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
 46338:   return accService ?
 46338:     accService->CreateOuterDocAccessible(mContent, PresContext()->PresShell()) :
106838:     nullptr;
     1: }
     1: #endif
     1: 
 23554: NS_QUERYFRAME_HEAD(nsSubDocumentFrame)
 51754:   NS_QUERYFRAME_ENTRY(nsSubDocumentFrame)
 23554: NS_QUERYFRAME_TAIL_INHERITING(nsLeafFrame)
     1: 
 40755: class AsyncFrameInit : public nsRunnable
 40755: {
 40755: public:
 40755:   AsyncFrameInit(nsIFrame* aFrame) : mFrame(aFrame) {}
 40755:   NS_IMETHOD Run()
 40755:   {
 40755:     if (mFrame.IsAlive()) {
 40755:       static_cast<nsSubDocumentFrame*>(mFrame.GetFrame())->ShowViewer();
 40755:     }
 40755:     return NS_OK;
 40755:   }
 40755: private:
 40755:   nsWeakFrame mFrame;
 40755: };
 40755: 
108608: static void
108608: InsertViewsInReverseOrder(nsIView* aSibling, nsIView* aParent);
108608: 
108608: static void
108608: EndSwapDocShellsForViews(nsIView* aView);
108608: 
     1: NS_IMETHODIMP
     1: nsSubDocumentFrame::Init(nsIContent*     aContent,
     1:                          nsIFrame*       aParent,
     1:                          nsIFrame*       aPrevInFlow)
     1: {
     1:   // determine if we are a <frame> or <iframe>
     1:   if (aContent) {
     1:     nsCOMPtr<nsIDOMHTMLFrameElement> frameElem = do_QueryInterface(aContent);
 80486:     mIsInline = frameElem ? false : true;
     1:   }
     1: 
     1:   nsresult rv =  nsLeafFrame::Init(aContent, aParent, aPrevInFlow);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   // We are going to create an inner view.  If we need a view for the
     1:   // OuterFrame but we wait for the normal view creation path in
     1:   // nsCSSFrameConstructor, then we will lose because the inner view's
     1:   // parent will already have been set to some outer view (e.g., the
     1:   // canvas) when it really needs to have this frame's view as its
     1:   // parent. So, create this frame's view right away, whether we
     1:   // really need it or not, and the inner view will get it as the
     1:   // parent.
     1:   if (!HasView()) {
 80486:     rv = nsContainerFrame::CreateViewForFrame(this, true);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
 93744:   EnsureInnerView();
     1: 
109280:   // Set the primary frame now so that DocumentViewerImpl::FindContainerView
109280:   // called from within EndSwapDocShellsForViews below can find it if needed.
109280:   aContent->SetPrimaryFrame(this);
109280: 
108608:   // If we have a detached subdoc's root view on our frame loader, re-insert
108608:   // it into the view tree. This happens when we've been reframed, and
108608:   // ensures the presentation persists across reframes. If the frame element
108608:   // has changed documents however, we blow away the presentation.
108608:   nsRefPtr<nsFrameLoader> frameloader = FrameLoader();
108608:   if (frameloader) {
108608:     nsCOMPtr<nsIDocument> oldContainerDoc;
108608:     nsIView* detachedViews =
108608:       frameloader->GetDetachedSubdocView(getter_AddRefs(oldContainerDoc));
108608:     if (detachedViews) {
108608:       if (oldContainerDoc == aContent->OwnerDoc()) {
108608:         // Restore stashed presentation.
108608:         ::InsertViewsInReverseOrder(detachedViews, mInnerView);
108608:         ::EndSwapDocShellsForViews(mInnerView->GetFirstChild());
108608:       } else {
108608:         // Presentation is for a different document, don't restore it.
108608:         frameloader->Hide();
108608:       }
108608:     }
108608:     frameloader->SetDetachedSubdocView(nullptr, nullptr);
108608:   }
108608: 
 40755:   nsContentUtils::AddScriptRunner(new AsyncFrameInit(this));
 16549:   return NS_OK;
 16549: }
 16549: 
108991: inline int32_t ConvertOverflow(uint8_t aOverflow)
 34245: {
 34245:   switch (aOverflow) {
 34245:     case NS_STYLE_OVERFLOW_VISIBLE:
 34245:     case NS_STYLE_OVERFLOW_AUTO:
 34245:       return nsIScrollable::Scrollbar_Auto;
 34245:     case NS_STYLE_OVERFLOW_HIDDEN:
 34245:     case NS_STYLE_OVERFLOW_CLIP:
 34245:       return nsIScrollable::Scrollbar_Never;
 34245:     case NS_STYLE_OVERFLOW_SCROLL:
 34245:       return nsIScrollable::Scrollbar_Always;
 34245:   }
 34245:   NS_NOTREACHED("invalid overflow value passed to ConvertOverflow");
 34245:   return nsIScrollable::Scrollbar_Auto;
 34245: }
 34245: 
 16549: void
 16549: nsSubDocumentFrame::ShowViewer()
 16549: {
 42907:   if (mCallingShow) {
 42907:     return;
 42907:   }
 42907: 
 16549:   if (!PresContext()->IsDynamic()) {
 16543:     // We let the printing code take care of loading the document; just
 54315:     // create the inner view for it to use.
 54315:     (void) EnsureInnerView();
 34245:   } else {
 42907:     nsRefPtr<nsFrameLoader> frameloader = FrameLoader();
 34245:     if (frameloader) {
 34245:       nsIntSize margin = GetMarginAttributes();
 34245:       const nsStyleDisplay* disp = GetStyleDisplay();
 42907:       nsWeakFrame weakThis(this);
 80486:       mCallingShow = true;
 79445:       bool didCreateDoc =
 42907:         frameloader->Show(margin.width, margin.height,
 34245:                           ConvertOverflow(disp->mOverflowX),
 34245:                           ConvertOverflow(disp->mOverflowY),
 34245:                           this);
 42907:       if (!weakThis.IsAlive()) {
 42907:         return;
 42907:       }
 80486:       mCallingShow = false;
 42907:       mDidCreateDoc = didCreateDoc;
 16549:     }
 16497:   }
     1: }
     1: 
107846: int
     1: nsSubDocumentFrame::GetSkipSides() const
     1: {
     1:   return 0;
     1: }
     1: 
 51752: nsIFrame*
 51752: nsSubDocumentFrame::GetSubdocumentRootFrame()
 51752: {
 51752:   if (!mInnerView)
106838:     return nullptr;
 51752:   nsIView* subdocView = mInnerView->GetFirstChild();
106838:   return subdocView ? subdocView->GetFrame() : nullptr;
 51752: }
 51752: 
     1: NS_IMETHODIMP
     1: nsSubDocumentFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
     1:                                      const nsRect&           aDirtyRect,
     1:                                      const nsDisplayListSet& aLists)
     1: {
     1:   if (!IsVisibleForPainting(aBuilder))
     1:     return NS_OK;
     1: 
 32021:   if (aBuilder->IsForEventDelivery() &&
 32021:       GetStyleVisibility()->mPointerEvents == NS_STYLE_POINTER_EVENTS_NONE)
 32021:     return NS_OK;
 32021: 
     1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   if (!mInnerView)
     1:     return NS_OK;
 54074: 
 54019:   nsFrameLoader* frameLoader = FrameLoader();
 54019:   if (frameLoader) {
 54019:     RenderFrameParent* rfp = frameLoader->GetCurrentRemoteFrame();
 54019:     if (rfp) {
 60444:       return rfp->BuildDisplayList(aBuilder, this, aDirtyRect, aLists);
 54019:     }
 54019:   }
 54019: 
     1:   nsIView* subdocView = mInnerView->GetFirstChild();
     1:   if (!subdocView)
     1:     return NS_OK;
 27834: 
106838:   nsCOMPtr<nsIPresShell> presShell = nullptr;
 28575: 
 82566:   nsIFrame* subdocRootFrame = subdocView->GetFrame();
 47900:   if (subdocRootFrame) {
 47900:     presShell = subdocRootFrame->PresContext()->PresShell();
 52485:   }
 52485:   // If painting is suppressed in the presshell, we try to look for a better
 52485:   // presshell to use.
 52485:   if (!presShell || (presShell->IsPaintingSuppressed() &&
 52485:                      !aBuilder->IsIgnoringPaintSuppression())) {
 37864:     // During page transition mInnerView will sometimes have two children, the
 37864:     // first being the new page that may not have any frame, and the second
 37864:     // being the old page that will probably have a frame.
 37864:     nsIView* nextView = subdocView->GetNextSibling();
106838:     nsIFrame* frame = nullptr;
 37864:     if (nextView) {
 82566:       frame = nextView->GetFrame();
 37864:     }
 52485:     if (frame) {
 52485:       nsIPresShell* ps = frame->PresContext()->PresShell();
 52485:       if (!presShell || (ps && !ps->IsPaintingSuppressed())) {
 37864:         subdocView = nextView;
 52485:         subdocRootFrame = frame;
 52485:         presShell = ps;
 52485:       }
 52485:     }
 52485:     if (!presShell) {
 28575:       // If we don't have a frame we use this roundabout way to get the pres shell.
 27834:       if (!mFrameLoader)
 27834:         return NS_OK;
 27834:       nsCOMPtr<nsIDocShell> docShell;
 27834:       mFrameLoader->GetDocShell(getter_AddRefs(docShell));
 27834:       if (!docShell)
 27834:         return NS_OK;
 27834:       docShell->GetPresShell(getter_AddRefs(presShell));
 27834:       if (!presShell)
 27834:         return NS_OK;
 28575:     }
 37864:   }
 27834: 
 49166:   nsPresContext* presContext = presShell->GetPresContext();
 49166: 
 28373:   nsDisplayList childItems;
 28373: 
108991:   int32_t parentAPD = PresContext()->AppUnitsPerDevPixel();
108991:   int32_t subdocAPD = presContext->AppUnitsPerDevPixel();
 47900: 
 28373:   nsRect dirty;
 47900:   if (subdocRootFrame) {
102512:     nsIDocument* doc = subdocRootFrame->PresContext()->Document();
106838:     nsIContent* root = doc ? doc->GetRootElement() : nullptr;
102512:     nsRect displayPort;
102512:     if (root && nsLayoutUtils::GetDisplayPort(root, &displayPort)) {
102512:       dirty = displayPort;
102512:     } else {
 47900:       // get the dirty rect relative to the root frame of the subdoc
 47900:       dirty = aDirtyRect + GetOffsetToCrossDoc(subdocRootFrame);
 47900:       // and convert into the appunits of the subdoc
 47900:       dirty = dirty.ConvertAppUnitsRoundOut(parentAPD, subdocAPD);
102512:     }
 47900: 
 47900:     aBuilder->EnterPresShell(subdocRootFrame, dirty);
 28373:   }
 27834: 
 47900:   nsRect subdocBoundsInParentUnits =
 83441:     mInnerView->GetBounds() + GetOffsetToCrossDoc(aBuilder->ReferenceFrame());
 28373: 
 91245:   if (subdocRootFrame) {
 47900:     rv = subdocRootFrame->
 47900:            BuildDisplayListForStackingContext(aBuilder, dirty, &childItems);
 47741:   }
 47741: 
 29987:   if (!aBuilder->IsForEventDelivery()) {
 47900:     // If we are going to use a displayzoom below then any items we put under
 47900:     // it need to have underlying frames from the subdocument. So we need to
 47900:     // calculate the bounds based on which frame will be the underlying frame
 47900:     // for the canvas background color item.
 47900:     nsRect bounds;
 47900:     if (subdocRootFrame) {
 83441:       bounds = subdocBoundsInParentUnits.ConvertAppUnitsRoundOut(parentAPD, subdocAPD);
 47900:     } else {
 47900:       bounds = subdocBoundsInParentUnits;
 47900:     }
 49166: 
 49166:     // If we are in print preview/page layout we want to paint the grey
 49166:     // background behind the page, not the canvas color. The canvas color gets
 49166:     // painted on the page itself.
 49166:     if (nsLayoutUtils::NeedsPrintPreviewBackground(presContext)) {
 49166:       rv = presShell->AddPrintPreviewBackgroundItem(
 49166:              *aBuilder, childItems, subdocRootFrame ? subdocRootFrame : this,
 49166:              bounds);
 49166:     } else {
 47741:       // Add the canvas background color to the bottom of the list. This
 47741:       // happens after we've built the list so that AddCanvasBackgroundColorItem
 47741:       // can monkey with the contents if necessary.
108991:       uint32_t flags = nsIPresShell::FORCE_DRAW;
 29987:       rv = presShell->AddCanvasBackgroundColorItem(
 47900:              *aBuilder, childItems, subdocRootFrame ? subdocRootFrame : this,
 61411:              bounds, NS_RGBA(0,0,0,0), flags);
 29987:     }
 49166:   }
 29987: 
 60447:   bool addedLayer = false;
 60447: 
 47900:   if (subdocRootFrame && parentAPD != subdocAPD) {
 60447:     NS_WARN_IF_FALSE(!addedLayer,
 60447:                      "Two container layers have been added. "
 60447:                       "Performance may suffer.");
 60447:     addedLayer = true;
 60447: 
 47900:     nsDisplayZoom* zoomItem =
 51260:       new (aBuilder) nsDisplayZoom(aBuilder, subdocRootFrame, &childItems,
103530:                                    subdocAPD, parentAPD);
 47900:     childItems.AppendToTop(zoomItem);
 60447:   }
 60447: 
 60447:   if (!addedLayer && presContext->IsRootContentDocument()) {
 51186:     // We always want top level content documents to be in their own layer.
 51186:     nsDisplayOwnLayer* layerItem = new (aBuilder) nsDisplayOwnLayer(
103530:       aBuilder, subdocRootFrame ? subdocRootFrame : this, &childItems);
 51186:     childItems.AppendToTop(layerItem);
 47900:   }
 51186: 
 91246:   if (subdocRootFrame) {
 91246:     aBuilder->LeavePresShell(subdocRootFrame, dirty);
 91246:   }
 91246: 
 83439:   if (ShouldClipSubdocument()) {
 83439:     nsDisplayClip* item =
 83439:       new (aBuilder) nsDisplayClip(aBuilder, this, &childItems,
 83439:                                    subdocBoundsInParentUnits);
 84014:     // Clip children to the child root frame's rectangle
 83439:     childItems.AppendToTop(item);
 83439:   }
 68777: 
 68777:   if (mIsInline) {
 83439:     WrapReplacedContentForBorderRadius(aBuilder, &childItems, aLists);
 68777:   } else {
 83439:     aLists.Content()->AppendToTop(&childItems);
 68777:   }
 83439: 
  8155:   // delete childItems in case of OOM
  8155:   childItems.DeleteAll();
 28373: 
     1:   return rv;
     1: }
     1: 
     1: nscoord
     1: nsSubDocumentFrame::GetIntrinsicWidth()
     1: {
     1:   if (!IsInline()) {
  8142:     return 0;  // HTML <frame> has no useful intrinsic width
     1:   }
     1: 
 33329:   if (mContent->IsXUL()) {
  8142:     return 0;  // XUL <iframe> and <browser> have no useful intrinsic width
     1:   }
     1: 
106838:   NS_ASSERTION(ObtainIntrinsicSizeFrame() == nullptr,
  8142:                "Intrinsic width should come from the embedded document.");
  8142: 
     1:   // We must be an HTML <iframe>.  Default to a width of 300, for IE
     1:   // compat (and per CSS2.1 draft).
     1:   return nsPresContext::CSSPixelsToAppUnits(300);
     1: }
     1: 
     1: nscoord
     1: nsSubDocumentFrame::GetIntrinsicHeight()
     1: {
     1:   // <frame> processing does not use this routine, only <iframe>
     1:   NS_ASSERTION(IsInline(), "Shouldn't have been called");
     1: 
 33329:   if (mContent->IsXUL()) {
     1:     return 0;
     1:   }
     1: 
106838:   NS_ASSERTION(ObtainIntrinsicSizeFrame() == nullptr,
  8142:                "Intrinsic height should come from the embedded document.");
  8142: 
     1:   // Use 150px, for compatibility with IE, and per CSS2.1 draft.
     1:   return nsPresContext::CSSPixelsToAppUnits(150);
     1: }
     1: 
     1: #ifdef DEBUG
     1: NS_IMETHODIMP nsSubDocumentFrame::GetFrameName(nsAString& aResult) const
     1: {
     1:   return MakeFrameName(NS_LITERAL_STRING("FrameOuter"), aResult);
     1: }
     1: #endif
     1: 
     1: nsIAtom*
     1: nsSubDocumentFrame::GetType() const
     1: {
     1:   return nsGkAtoms::subDocumentFrame;
     1: }
     1: 
  8142: /* virtual */ nscoord
 68481: nsSubDocumentFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
  8142: {
  8142:   nscoord result;
  8142:   DISPLAY_MIN_WIDTH(this, result);
  8142: 
  8142:   nsIFrame* subDocRoot = ObtainIntrinsicSizeFrame();
  8142:   if (subDocRoot) {
  8142:     result = subDocRoot->GetMinWidth(aRenderingContext);
  8142:   } else {
  8142:     result = GetIntrinsicWidth();
  8142:   }
  8142: 
  8142:   return result;
  8142: }
  8142: 
  8142: /* virtual */ nscoord
 68481: nsSubDocumentFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
  8142: {
  8142:   nscoord result;
  8142:   DISPLAY_PREF_WIDTH(this, result);
  8142: 
  8142:   nsIFrame* subDocRoot = ObtainIntrinsicSizeFrame();
  8142:   if (subDocRoot) {
  8142:     result = subDocRoot->GetPrefWidth(aRenderingContext);
  8142:   } else {
  8142:     result = GetIntrinsicWidth();
  8142:   }
  8142: 
  8142:   return result;
  8142: }
  8142: 
 13281: /* virtual */ nsIFrame::IntrinsicSize
 13281: nsSubDocumentFrame::GetIntrinsicSize()
 13281: {
 13281:   nsIFrame* subDocRoot = ObtainIntrinsicSizeFrame();
 13281:   if (subDocRoot) {
 13281:     return subDocRoot->GetIntrinsicSize();
 13281:   }
 13281:   return nsLeafFrame::GetIntrinsicSize();
 13281: }
 13281: 
  8142: /* virtual */ nsSize
  8142: nsSubDocumentFrame::GetIntrinsicRatio()
  8142: {
  8142:   nsIFrame* subDocRoot = ObtainIntrinsicSizeFrame();
  8142:   if (subDocRoot) {
  8142:     return subDocRoot->GetIntrinsicRatio();
  8142:   }
  8142:   return nsLeafFrame::GetIntrinsicRatio();
  8142: }
  8142: 
  8142: /* virtual */ nsSize
 68481: nsSubDocumentFrame::ComputeAutoSize(nsRenderingContext *aRenderingContext,
 11872:                                     nsSize aCBSize, nscoord aAvailableWidth,
 11872:                                     nsSize aMargin, nsSize aBorder,
 79445:                                     nsSize aPadding, bool aShrinkWrap)
 11872: {
 11872:   if (!IsInline()) {
 11872:     return nsFrame::ComputeAutoSize(aRenderingContext, aCBSize,
 11872:                                     aAvailableWidth, aMargin, aBorder,
 11872:                                     aPadding, aShrinkWrap);
 11872:   }
 11872: 
 11872:   return nsLeafFrame::ComputeAutoSize(aRenderingContext, aCBSize,
 11872:                                       aAvailableWidth, aMargin, aBorder,
 11872:                                       aPadding, aShrinkWrap);  
 11872: }
 11872: 
 11872: 
 11872: /* virtual */ nsSize
 68481: nsSubDocumentFrame::ComputeSize(nsRenderingContext *aRenderingContext,
  8142:                                 nsSize aCBSize, nscoord aAvailableWidth,
  8142:                                 nsSize aMargin, nsSize aBorder, nsSize aPadding,
108991:                                 uint32_t aFlags)
  8142: {
  8142:   nsIFrame* subDocRoot = ObtainIntrinsicSizeFrame();
  8142:   if (subDocRoot) {
  8142:     return nsLayoutUtils::ComputeSizeWithIntrinsicDimensions(
  8145:                             aRenderingContext, this,
  8142:                             subDocRoot->GetIntrinsicSize(),
  8142:                             subDocRoot->GetIntrinsicRatio(),
  8142:                             aCBSize, aMargin, aBorder, aPadding);
  8142:   }
  8142:   return nsLeafFrame::ComputeSize(aRenderingContext, aCBSize, aAvailableWidth,
 93353:                                   aMargin, aBorder, aPadding, aFlags);
  8142: }
  8142: 
     1: NS_IMETHODIMP
     1: nsSubDocumentFrame::Reflow(nsPresContext*           aPresContext,
     1:                            nsHTMLReflowMetrics&     aDesiredSize,
     1:                            const nsHTMLReflowState& aReflowState,
     1:                            nsReflowStatus&          aStatus)
     1: {
     1:   DO_GLOBAL_REFLOW_COUNT("nsSubDocumentFrame");
     1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
     1:   // printf("OuterFrame::Reflow %X (%d,%d) \n", this, aReflowState.availableWidth, aReflowState.availableHeight);
     1:   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
     1:      ("enter nsSubDocumentFrame::Reflow: maxSize=%d,%d",
     1:       aReflowState.availableWidth, aReflowState.availableHeight));
     1: 
     1:   aStatus = NS_FRAME_COMPLETE;
     1: 
 36656:   NS_ASSERTION(mContent->GetPrimaryFrame() == this,
  6162:                "Shouldn't happen");
  6162: 
     1:   // "offset" is the offset of our content area from our frame's
     1:   // top-left corner.
     1:   nsPoint offset(0, 0);
     1:   
     1:   if (IsInline()) {
  8142:     // XUL <iframe> or <browser>, or HTML <iframe>, <object> or <embed>
 10487:     nsresult rv = nsLeafFrame::DoReflow(aPresContext, aDesiredSize, aReflowState,
     1:                                         aStatus);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     offset = nsPoint(aReflowState.mComputedBorderPadding.left,
     1:                      aReflowState.mComputedBorderPadding.top);
     1:   } else {
  8142:     // HTML <frame>
     1:     SizeToAvailSize(aReflowState, aDesiredSize);
     1:   }
     1: 
     1:   nsSize innerSize(aDesiredSize.width, aDesiredSize.height);
     1:   if (IsInline()) {
     1:     innerSize.width  -= aReflowState.mComputedBorderPadding.LeftRight();
     1:     innerSize.height -= aReflowState.mComputedBorderPadding.TopBottom();
     1:   }
     1: 
 20078:   if (mInnerView) {
     1:     nsIViewManager* vm = mInnerView->GetViewManager();
     1:     vm->MoveViewTo(mInnerView, offset.x, offset.y);
 80486:     vm->ResizeView(mInnerView, nsRect(nsPoint(0, 0), innerSize), true);
 20078:   }
     1: 
 83439:   aDesiredSize.SetOverflowAreasToDesiredBounds();
 83439:   if (!ShouldClipSubdocument()) {
 83439:     nsIFrame* subdocRootFrame = GetSubdocumentRootFrame();
 83439:     if (subdocRootFrame) {
 83439:       aDesiredSize.mOverflowAreas.UnionWith(subdocRootFrame->GetOverflowAreas() + offset);
 83439:     }
 83439:   }
 83439: 
103530:   // Determine if we need to repaint our border, background or outline
103530:   CheckInvalidateSizeChange(aDesiredSize);
103530: 
  1669:   FinishAndStoreOverflow(&aDesiredSize);
  1669: 
  6162:   if (!aPresContext->IsPaginated() && !mPostedReflowCallback) {
  6162:     PresContext()->PresShell()->PostReflowCallback(this);
 80486:     mPostedReflowCallback = true;
     1:   }
     1: 
     1:   // printf("OuterFrame::Reflow DONE %X (%d,%d)\n", this,
     1:   //        aDesiredSize.width, aDesiredSize.height);
     1: 
     1:   NS_FRAME_TRACE(NS_FRAME_TRACE_CALLS,
     1:      ("exit nsSubDocumentFrame::Reflow: size=%d,%d status=%x",
     1:       aDesiredSize.width, aDesiredSize.height, aStatus));
     1: 
     1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
  6162: nsSubDocumentFrame::ReflowFinished()
  6162: {
 46492:   if (mFrameLoader) {
  7709:     nsWeakFrame weakFrame(this);
  7709: 
 46492:     mFrameLoader->UpdatePositionAndSize(this);
  7709: 
 46492:     if (weakFrame.IsAlive()) {
  7709:       // Make sure that we can post a reflow callback in the future.
 80486:       mPostedReflowCallback = false;
  6162:     }
 58593:   } else {
 80486:     mPostedReflowCallback = false;
 46492:   }
 80486:   return false;
  6162: }
  6162: 
  8509: void
  8509: nsSubDocumentFrame::ReflowCallbackCanceled()
  8509: {
 80486:   mPostedReflowCallback = false;
  8509: }
  6162: 
     1: NS_IMETHODIMP
108991: nsSubDocumentFrame::AttributeChanged(int32_t aNameSpaceID,
     1:                                      nsIAtom* aAttribute,
108991:                                      int32_t aModType)
     1: {
     1:   if (aNameSpaceID != kNameSpaceID_None) {
     1:     return NS_OK;
     1:   }
     1:   
     1:   // If the noResize attribute changes, dis/allow frame to be resized
 13432:   if (aAttribute == nsGkAtoms::noresize) {
     1:     // Note that we're not doing content type checks, but that's ok -- if
     1:     // they'd fail we will just end up with a null framesetFrame.
     1:     if (mContent->GetParent()->Tag() == nsGkAtoms::frameset) {
     1:       nsIFrame* parentFrame = GetParent();
     1: 
     1:       if (parentFrame) {
     1:         // There is no interface for nsHTMLFramesetFrame so QI'ing to
     1:         // concrete class, yay!
 23554:         nsHTMLFramesetFrame* framesetFrame = do_QueryFrame(parentFrame);
     1:         if (framesetFrame) {
     1:           framesetFrame->RecalculateBorderResize();
     1:         }
     1:       }
     1:     }
     1:   }
 60693:   else if (aAttribute == nsGkAtoms::showresizer) {
 60693:     nsIFrame* rootFrame = GetSubdocumentRootFrame();
 60693:     if (rootFrame) {
 60693:       rootFrame->PresContext()->PresShell()->
 60693:         FrameNeedsReflow(rootFrame, nsIPresShell::eResize, NS_FRAME_IS_DIRTY);
 60693:     }
 60693:   }
 69814:   else if (aAttribute == nsGkAtoms::marginwidth ||
 69814:            aAttribute == nsGkAtoms::marginheight) {
 69814: 
 69814:     // Retrieve the attributes
 69814:     nsIntSize margins = GetMarginAttributes();
 69814: 
 69814:     // Notify the frameloader
 69814:     nsRefPtr<nsFrameLoader> frameloader = FrameLoader();
 69814:     if (frameloader)
 69814:       frameloader->MarginsChanged(margins.width, margins.height);
 69814:   }
     1:   else if (aAttribute == nsGkAtoms::type) {
     1:     if (!mFrameLoader) 
     1:       return NS_OK;
     1: 
 33329:     if (!mContent->IsXUL()) {
     1:       return NS_OK;
     1:     }
     1: 
 71439:     if (mFrameLoader->GetRemoteBrowser()) {
 71439:       // TODO: Implement ContentShellAdded for remote browsers (bug 658304)
 71439:       return NS_OK;
 71439:     }
 71439: 
     1:     // Note: This logic duplicates a lot of logic in
     1:     // nsFrameLoader::EnsureDocShell.  We should fix that.
     1: 
     1:     // Notify our enclosing chrome that our type has changed.  We only do this
     1:     // if our parent is chrome, since in all other cases we're random content
     1:     // subframes and the treeowner shouldn't worry about us.
     1: 
     1:     nsCOMPtr<nsIDocShell> docShell;
     1:     mFrameLoader->GetDocShell(getter_AddRefs(docShell));
     1:     nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(docShell));
     1:     if (!docShellAsItem) {
     1:       return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDocShellTreeItem> parentItem;
     1:     docShellAsItem->GetParent(getter_AddRefs(parentItem));
 58808:     if (!parentItem) {
 58808:       return NS_OK;
 58808:     }
     1: 
108991:     int32_t parentType;
     1:     parentItem->GetItemType(&parentType);
     1: 
     1:     if (parentType != nsIDocShellTreeItem::typeChrome) {
     1:       return NS_OK;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDocShellTreeOwner> parentTreeOwner;
     1:     parentItem->GetTreeOwner(getter_AddRefs(parentTreeOwner));
     1:     if (parentTreeOwner) {
     1:       nsAutoString value;
     1:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::type, value);
     1: 
 79445:       bool is_primary = value.LowerCaseEqualsLiteral("content-primary");
     1: 
 11414: #ifdef MOZ_XUL
 11414:       // when a content panel is no longer primary, hide any open popups it may have
 11414:       if (!is_primary) {
 11414:         nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
 11414:         if (pm)
 11414:           pm->HidePopupsInDocShell(docShellAsItem);
 11414:       }
 11414: #endif
 11414: 
  6683:       parentTreeOwner->ContentShellRemoved(docShellAsItem);
     1: 
     1:       if (value.LowerCaseEqualsLiteral("content") ||
     1:           StringBeginsWith(value, NS_LITERAL_STRING("content-"),
     1:                            nsCaseInsensitiveStringComparator())) {
 79445:         bool is_targetable = is_primary ||
     1:           value.LowerCaseEqualsLiteral("content-targetable");
     1: 
  6683:         parentTreeOwner->ContentShellAdded(docShellAsItem, is_primary,
  6683:                                            is_targetable, value);
     1:       }
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsIFrame*
     1: NS_NewSubDocumentFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
     1: {
     1:   return new (aPresShell) nsSubDocumentFrame(aContext);
     1: }
     1: 
 32423: NS_IMPL_FRAMEARENA_HELPERS(nsSubDocumentFrame)
 32423: 
108608: class nsHideViewer : public nsRunnable {
108608: public:
108608:   nsHideViewer(nsIContent* aFrameElement,
108608:                nsFrameLoader* aFrameLoader,
108608:                nsIPresShell* aPresShell,
108608:                bool aHideViewerIfFrameless)
108608:     : mFrameElement(aFrameElement),
108608:       mFrameLoader(aFrameLoader),
108608:       mPresShell(aPresShell),
108608:       mHideViewerIfFrameless(aHideViewerIfFrameless)
108608:   {
108608:     NS_ASSERTION(mFrameElement, "Must have a frame element");
108608:     NS_ASSERTION(mFrameLoader, "Must have a frame loader");
108608:     NS_ASSERTION(mPresShell, "Must have a presshell");
108608:   }
108608: 
108608:   NS_IMETHOD Run()
108608:   {
108608:     // Flush frames, to ensure any pending display:none changes are made.
108608:     // Note it can be unsafe to flush if we've destroyed the presentation
108608:     // for some other reason, like if we're shutting down.
108608:     if (!mPresShell->IsDestroying()) {
108608:       mPresShell->FlushPendingNotifications(Flush_Frames);
108608:     }
108608:     nsIFrame* frame = mFrameElement->GetPrimaryFrame();
108891:     if ((!frame && mHideViewerIfFrameless) ||
108891:         mPresShell->IsDestroying()) {
108891:       // Either the frame element has no nsIFrame or the presshell is being
108891:       // destroyed. Hide the nsFrameLoader, which destroys the presentation,
108891:       // and clear our references to the stashed presentation.
108608:       mFrameLoader->SetDetachedSubdocView(nullptr, nullptr);
108608:       mFrameLoader->Hide();
108608:     }
108608:     return NS_OK;
108608:   }
108608: private:
108608:   nsCOMPtr<nsIContent> mFrameElement;
108608:   nsRefPtr<nsFrameLoader> mFrameLoader;
108608:   nsCOMPtr<nsIPresShell> mPresShell;
108608:   bool mHideViewerIfFrameless;
108608: };
108608: 
108608: static nsIView*
108608: BeginSwapDocShellsForViews(nsIView* aSibling);
108608: 
     1: void
 36647: nsSubDocumentFrame::DestroyFrom(nsIFrame* aDestructRoot)
     1: {
  6162:   if (mPostedReflowCallback) {
  6162:     PresContext()->PresShell()->CancelReflowCallback(this);
 80486:     mPostedReflowCallback = false;
  6162:   }
  6162: 
109282:   // Forget about plugin geometry updates in the subdoc's PresContext,
109282:   // otherwise we can be left with dangling pointers to the "plugin for
109282:   // geometry update frame" in the root PresContext.
109282:   nsIFrame* subdocRootFrame = GetSubdocumentRootFrame();
109282:   if (subdocRootFrame) {
109282:     nsPresContext* pc = subdocRootFrame->PresContext();
109282:     nsRootPresContext* rpc = pc ? pc->GetRootPresContext() : nullptr;
109282:     if (rpc) {
109282:       rpc->RootForgetUpdatePluginGeometryFrameForPresContext(pc);
109282:     }
109282:   }
109282: 
108608:   // Detach the subdocument's views and stash them in the frame loader.
108608:   // We can then reattach them if we're being reframed (for example if
108608:   // the frame has been made position:fixed).
108608:   nsFrameLoader* frameloader = FrameLoader();
108608:   if (frameloader) {
108608:     nsIView* detachedViews = ::BeginSwapDocShellsForViews(mInnerView->GetFirstChild());
108608:     frameloader->SetDetachedSubdocView(detachedViews, mContent->OwnerDoc());
108608: 
108608:     // We call nsFrameLoader::HideViewer() in a script runner so that we can
108608:     // safely determine whether the frame is being reframed or destroyed.
108608:     nsContentUtils::AddScriptRunner(
108608:       new nsHideViewer(mContent,
108608:                        mFrameLoader,
108608:                        PresContext()->PresShell(),
108608:                        (mDidCreateDoc || mCallingShow)));
108608:   }
108273: 
108398:   nsLeafFrame::DestroyFrom(aDestructRoot);
108273: }
 16549: 
 31295: nsIntSize
 31295: nsSubDocumentFrame::GetMarginAttributes()
     1: {
 23738:   nsIntSize result(-1, -1);
     1:   nsGenericHTMLElement *content = nsGenericHTMLElement::FromContent(mContent);
     1:   if (content) {
     1:     const nsAttrValue* attr = content->GetParsedAttr(nsGkAtoms::marginwidth);
     1:     if (attr && attr->Type() == nsAttrValue::eInteger)
     1:       result.width = attr->GetIntegerValue();
     1:     attr = content->GetParsedAttr(nsGkAtoms::marginheight);
     1:     if (attr && attr->Type() == nsAttrValue::eInteger)
     1:       result.height = attr->GetIntegerValue();
     1:   }
     1:   return result;
     1: }
     1: 
 34245: nsFrameLoader*
 34245: nsSubDocumentFrame::FrameLoader()
 34245: {
 34245:   nsIContent* content = GetContent();
 34245:   if (!content)
106838:     return nullptr;
 34245: 
 34245:   if (!mFrameLoader) {
 34245:     nsCOMPtr<nsIFrameLoaderOwner> loaderOwner = do_QueryInterface(content);
 34245:     if (loaderOwner) {
 34245:       nsCOMPtr<nsIFrameLoader> loader;
 34245:       loaderOwner->GetFrameLoader(getter_AddRefs(loader));
 34245:       mFrameLoader = static_cast<nsFrameLoader*>(loader.get());
 34245:     }
 34245:   }
 34245:   return mFrameLoader;
 34245: }
 34245: 
     1: // XXX this should be called ObtainDocShell or something like that,
     1: // to indicate that it could have side effects
 51756: nsresult
     1: nsSubDocumentFrame::GetDocShell(nsIDocShell **aDocShell)
     1: {
106838:   *aDocShell = nullptr;
     1: 
 34245:   NS_ENSURE_STATE(FrameLoader());
     1:   return mFrameLoader->GetDocShell(aDocShell);
     1: }
     1: 
 54309: static void
 54309: DestroyDisplayItemDataForFrames(nsIFrame* aFrame)
 54309: {
 54309:   FrameLayerBuilder::DestroyDisplayItemDataFor(aFrame);
 54309: 
 77153:   nsIFrame::ChildListIterator lists(aFrame);
 77153:   for (; !lists.IsDone(); lists.Next()) {
 77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 77153:       DestroyDisplayItemDataForFrames(childFrames.get());
 54309:     }
 77153:   }
 54309: }
 54309: 
 79445: static bool
 54309: BeginSwapDocShellsForDocument(nsIDocument* aDocument, void*)
 54309: {
 54309:   NS_PRECONDITION(aDocument, "");
 54309: 
 54309:   nsIPresShell* shell = aDocument->GetShell();
106838:   nsIFrame* rootFrame = shell ? shell->GetRootFrame() : nullptr;
 54309:   if (rootFrame) {
 54309:     ::DestroyDisplayItemDataForFrames(rootFrame);
 54309:   }
 54309:   aDocument->EnumerateFreezableElements(
106838:     nsObjectFrame::BeginSwapDocShells, nullptr);
106838:   aDocument->EnumerateSubDocuments(BeginSwapDocShellsForDocument, nullptr);
 80486:   return true;
 54309: }
 54309: 
 54309: static nsIView*
 54309: BeginSwapDocShellsForViews(nsIView* aSibling)
 54309: {
 54309:   // Collect the removed sibling views in reverse order in 'removedViews'.
106838:   nsIView* removedViews = nullptr;
 54309:   while (aSibling) {
 54309:     nsIDocument* doc = ::GetDocumentFromView(aSibling);
 54309:     if (doc) {
106838:       ::BeginSwapDocShellsForDocument(doc, nullptr);
 54309:     }
 54309:     nsIView* next = aSibling->GetNextSibling();
 54309:     aSibling->GetViewManager()->RemoveChild(aSibling);
 54309:     aSibling->SetNextSibling(removedViews);
 54309:     removedViews = aSibling;
 54309:     aSibling = next;
 54309:   }
 54309:   return removedViews;
 54309: }
 54309: 
 54309: static void
 54309: InsertViewsInReverseOrder(nsIView* aSibling, nsIView* aParent)
 54309: {
 54309:   NS_PRECONDITION(aParent, "");
 54309:   NS_PRECONDITION(!aParent->GetFirstChild(), "inserting into non-empty list");
 54309: 
 54309:   nsIViewManager* vm = aParent->GetViewManager();
 54309:   while (aSibling) {
 54309:     nsIView* next = aSibling->GetNextSibling();
106838:     aSibling->SetNextSibling(nullptr);
 80486:     // true means 'after' in document order which is 'before' in view order,
 54309:     // so this call prepends the child, thus reversing the siblings as we go.
106838:     vm->InsertChild(aParent, aSibling, nullptr, true);
 54309:     aSibling = next;
 54309:   }
 54309: }
 54309: 
 51756: nsresult
 16549: nsSubDocumentFrame::BeginSwapDocShells(nsIFrame* aOther)
 16549: {
 16549:   if (!aOther || aOther->GetType() != nsGkAtoms::subDocumentFrame) {
 16549:     return NS_ERROR_NOT_IMPLEMENTED;
 16549:   }
 16549: 
 16549:   nsSubDocumentFrame* other = static_cast<nsSubDocumentFrame*>(aOther);
 42907:   if (!mFrameLoader || !mDidCreateDoc || mCallingShow ||
 42907:       !other->mFrameLoader || !other->mDidCreateDoc) {
 16549:     return NS_ERROR_NOT_IMPLEMENTED;
 16549:   }
 16549: 
 54309:   if (mInnerView && other->mInnerView) {
 54309:     nsIView* ourSubdocViews = mInnerView->GetFirstChild();
 54309:     nsIView* ourRemovedViews = ::BeginSwapDocShellsForViews(ourSubdocViews);
 54309:     nsIView* otherSubdocViews = other->mInnerView->GetFirstChild();
 54309:     nsIView* otherRemovedViews = ::BeginSwapDocShellsForViews(otherSubdocViews);
 16549: 
 54309:     ::InsertViewsInReverseOrder(ourRemovedViews, other->mInnerView);
 54309:     ::InsertViewsInReverseOrder(otherRemovedViews, mInnerView);
 54309:   }
 16549:   mFrameLoader.swap(other->mFrameLoader);
 16549:   return NS_OK;
 16549: }
 16549: 
 79445: static bool
 54309: EndSwapDocShellsForDocument(nsIDocument* aDocument, void*)
 54309: {
 54309:   NS_PRECONDITION(aDocument, "");
 54309: 
 54311:   // Our docshell and view trees have been updated for the new hierarchy.
 68668:   // Now also update all nsDeviceContext::mWidget to that of the
 54311:   // container view in the new hierarchy.
 54311:   nsCOMPtr<nsISupports> container = aDocument->GetContainer();
 54311:   nsCOMPtr<nsIDocShell> ds = do_QueryInterface(container);
 54311:   if (ds) {
 54311:     nsCOMPtr<nsIContentViewer> cv;
 54311:     ds->GetContentViewer(getter_AddRefs(cv));
 54311:     while (cv) {
 54311:       nsCOMPtr<nsPresContext> pc;
 80401:       cv->GetPresContext(getter_AddRefs(pc));
106838:       nsDeviceContext* dc = pc ? pc->DeviceContext() : nullptr;
 54311:       if (dc) {
 80401:         nsIView* v = cv->FindContainerView();
106838:         dc->Init(v ? v->GetNearestWidget(nullptr) : nullptr);
 54311:       }
 54311:       nsCOMPtr<nsIContentViewer> prev;
 54311:       cv->GetPreviousViewer(getter_AddRefs(prev));
 54311:       cv = prev;
 54311:     }
 54311:   }
 54311: 
 54309:   aDocument->EnumerateFreezableElements(
106838:     nsObjectFrame::EndSwapDocShells, nullptr);
106838:   aDocument->EnumerateSubDocuments(EndSwapDocShellsForDocument, nullptr);
 80486:   return true;
 54309: }
 54309: 
 54309: static void
 54309: EndSwapDocShellsForViews(nsIView* aSibling)
 54309: {
 54309:   for ( ; aSibling; aSibling = aSibling->GetNextSibling()) {
 54309:     nsIDocument* doc = ::GetDocumentFromView(aSibling);
 54309:     if (doc) {
106838:       ::EndSwapDocShellsForDocument(doc, nullptr);
 54309:     }
 54309:   }
 54309: }
 54309: 
 16549: void
 16549: nsSubDocumentFrame::EndSwapDocShells(nsIFrame* aOther)
 16549: {
 16549:   nsSubDocumentFrame* other = static_cast<nsSubDocumentFrame*>(aOther);
 42907:   nsWeakFrame weakThis(this);
 42907:   nsWeakFrame weakOther(aOther);
 54309: 
 54309:   if (mInnerView) {
 54309:     ::EndSwapDocShellsForViews(mInnerView->GetFirstChild());
 54309:   }
 54309:   if (other->mInnerView) {
 54309:     ::EndSwapDocShellsForViews(other->mInnerView->GetFirstChild());
 54309:   }
 16549: 
 16549:   // Now make sure we reflow both frames, in case their contents
 16549:   // determine their size.
 42907:   // And repaint them, for good measure, in case there's nothing
 42907:   // interesting that happens during reflow.
 42907:   if (weakThis.IsAlive()) {
 16549:     PresContext()->PresShell()->
 16549:       FrameNeedsReflow(this, nsIPresShell::eTreeChange, NS_FRAME_IS_DIRTY);
 51756:     InvalidateFrameSubtree();
 42907:   }
 42907:   if (weakOther.IsAlive()) {
 16549:     other->PresContext()->PresShell()->
 16549:       FrameNeedsReflow(other, nsIPresShell::eTreeChange, NS_FRAME_IS_DIRTY);
 51756:     other->InvalidateFrameSubtree();
 16549:   }
 42907: }
 16549: 
 34245: nsIView*
 54315: nsSubDocumentFrame::EnsureInnerView()
     1: {
 16549:   if (mInnerView) {
 34245:     return mInnerView;
 16549:   }
 16549: 
     1:   // create, init, set the parent of the view
     1:   nsIView* outerView = GetView();
     1:   NS_ASSERTION(outerView, "Must have an outer view already");
     1:   nsRect viewBounds(0, 0, 0, 0); // size will be fixed during reflow
     1: 
     1:   nsIViewManager* viewMan = outerView->GetViewManager();
 32182:   nsIView* innerView = viewMan->CreateView(viewBounds, outerView);
     1:   if (!innerView) {
     1:     NS_ERROR("Could not create inner view");
106838:     return nullptr;
     1:   }
     1:   mInnerView = innerView;
106838:   viewMan->InsertChild(outerView, innerView, nullptr, true);
     1: 
 34245:   return mInnerView;
     1: }
  8142: 
  8142: nsIFrame*
  8142: nsSubDocumentFrame::ObtainIntrinsicSizeFrame()
  8142: {
  8142:   nsCOMPtr<nsIObjectLoadingContent> olc = do_QueryInterface(GetContent());
  8142:   if (olc) {
  8142:     // We are an HTML <object>, <embed> or <applet> (a replaced element).
  8142: 
  8142:     // Try to get an nsIFrame for our sub-document's document element
106838:     nsIFrame* subDocRoot = nullptr;
  8142: 
  8142:     nsCOMPtr<nsIDocShell> docShell;
  8142:     GetDocShell(getter_AddRefs(docShell));
  8142:     if (docShell) {
  8142:       nsCOMPtr<nsIPresShell> presShell;
  8142:       docShell->GetPresShell(getter_AddRefs(presShell));
  8142:       if (presShell) {
  8142:         nsIScrollableFrame* scrollable = presShell->GetRootScrollFrameAsScrollable();
  8142:         if (scrollable) {
  8142:           nsIFrame* scrolled = scrollable->GetScrolledFrame();
  8142:           if (scrolled) {
 77154:             subDocRoot = scrolled->GetFirstPrincipalChild();
  8142:           }
  8142:         }
  8142:       }
  8142:     }
  8142: 
  8142:     if (subDocRoot && subDocRoot->GetContent() &&
  8142:         subDocRoot->GetContent()->NodeInfo()->Equals(nsGkAtoms::svg, kNameSpaceID_SVG)) {
  8142:       return subDocRoot; // SVG documents have an intrinsic size
  8142:     }
  8142:   }
106838:   return nullptr;
  8142: }
