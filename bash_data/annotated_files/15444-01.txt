    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: // vim:set ts=2 sts=2 sw=2 et cin:
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Jacek Piskozub <piskozub@iopan.gda.pl>
    1:  *   Leon Sha <leon.sha@sun.com>
    1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
    1:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
    1:  *   Christian Biesinger <cbiesinger@web.de>
  130:  *   Josh Aas <josh@mozilla.com>
13537:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering objects for replaced elements implemented by a plugin */
    1: 
    1: #include "nscore.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIDOMKeyListener.h"
    1: #include "nsIPluginHost.h"
    1: #include "nsplugin.h"
    1: #include "nsString.h"
    1: #include "nsReadableUtils.h"
    1: #include "prmem.h"
    1: #include "nsGkAtoms.h"
    4: #include "nsIAppShell.h"
    1: #include "nsIDocument.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIURL.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIPluginInstanceOwner.h"
    1: #include "plstr.h"
    1: #include "nsILinkHandler.h"
    1: #ifdef OJI
    1: #include "nsIJVMPluginTagInfo.h"
    1: #endif
    1: #include "nsIEventListener.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsIScrollPositionListener.h"
    1: #include "nsITimer.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeOwner.h"
    1: #include "nsDocShellCID.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMHTMLObjectElement.h"
    1: #include "nsIDOMHTMLEmbedElement.h"
    1: #include "nsIDOMHTMLAppletElement.h"
    1: #include "nsIDOMWindow.h"
    1: #include "nsIDOMDocumentEvent.h"
    1: #include "nsIDOMMouseListener.h"
    1: #include "nsIDOMMouseMotionListener.h"
    1: #include "nsIDOMFocusListener.h"
    1: #include "nsIDOMContextMenuListener.h"
    1: #include "nsIDOMDragListener.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMNSEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIDocumentEncoder.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIPluginWidget.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIRenderingContext.h"
    1: #include "npapi.h"
    1: #include "nsTransform2D.h"
    1: #include "nsIImageLoadingContent.h"
    1: #include "nsIObjectLoadingContent.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsContentUtils.h"
    1: #include "nsDisplayList.h"
    1: #include "nsAttrName.h"
    1: #include "nsDataHashtable.h"
13098: #include "nsDOMClassInfo.h"
    1: 
    1: // headers for plugin scriptability
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIXPCScriptable.h"
    1: #include "nsIClassInfo.h"
    1: 
    1: #include "nsObjectFrame.h"
    1: #include "nsIObjectFrame.h"
    1: #include "nsPluginNativeWindow.h"
    1: #include "nsPIPluginHost.h"
    1: #include "nsIPluginDocument.h"
    1: 
 4577: #include "nsThreadUtils.h"
 4577: 
    1: #include "gfxContext.h"
    1: 
11703: #ifdef XP_WIN
11703: #include "gfxWindowsNativeDrawing.h"
11703: #endif
11703: 
    1: // accessibility support
    1: #ifdef ACCESSIBILITY
    1: #include "nsIAccessibilityService.h"
    1: #endif
    1: 
    1: #ifdef MOZ_LOGGING
    1: #define FORCE_PR_LOG 1 /* Allow logging in the release build */
    1: #endif /* MOZ_LOGGING */
    1: #include "prlog.h"
    1: 
    1: #include <errno.h>
    1: 
    1: #include "nsContentCID.h"
    1: static NS_DEFINE_CID(kRangeCID, NS_RANGE_CID);
13537: static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
    1: 
11944: #ifdef XP_MACOSX
11944: #include "gfxQuartzNativeDrawing.h"
11944: #endif
11944: 
 3059: #ifdef MOZ_X11
 3059: #include <X11/Xlib.h>
    1: /* X headers suck */
 3059: enum { XKeyPress = KeyPress };
    1: #ifdef KeyPress
    1: #undef KeyPress
    1: #endif
 3059: #include "gfxXlibNativeRenderer.h"
 3059: #ifdef MOZ_WIDGET_GTK2
 3059: #include <gdk/gdkwindow.h>
 3059: #include <gdk/gdkx.h>
 3059: #endif
 3059: #endif
    1: 
    1: #ifdef XP_WIN
    1: #include <wtypes.h>
    1: #include <winuser.h>
    1: #endif
    1: 
    1: #ifdef CreateEvent // Thank you MS.
    1: #undef CreateEvent
    1: #endif
    1: 
    1: #ifdef PR_LOGGING 
    1: static PRLogModuleInfo *nsObjectFrameLM = PR_NewLogModule("nsObjectFrame");
    1: #endif /* PR_LOGGING */
    1: 
    1: // 1020 / 60
    1: #define NORMAL_PLUGIN_DELAY 17
    1: 
    1: // low enough to avoid audio skipping/delays
    1: #define HIDDEN_PLUGIN_DELAY 100
    1: 
    1: // special class for handeling DOM context menu events because for
    1: // some reason it starves other mouse events if implemented on the
    1: // same class
    1: class nsPluginDOMContextMenuListener : public nsIDOMContextMenuListener,
    1:                                        public nsIEventListener
    1: {
    1: public:
    1:   nsPluginDOMContextMenuListener();
    1:   virtual ~nsPluginDOMContextMenuListener();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_IMETHOD ContextMenu(nsIDOMEvent* aContextMenuEvent);
    1:   
    1:   nsresult Init(nsIContent* aContent);
    1:   nsresult Destroy(nsIContent* aContent);
    1:   
    1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent)
    1:   {
    1:     return NS_OK;
    1:   }
    1:   nsEventStatus ProcessEvent(const nsGUIEvent& anEvent)
    1:   {
    1:     return nsEventStatus_eConsumeNoDefault;
    1:   }
    1: };
    1: 
    1: 
    1: class nsPluginInstanceOwner : public nsIPluginInstanceOwner,
    1:                               public nsIPluginTagInfo2,
    1: #ifdef OJI
    1:                               public nsIJVMPluginTagInfo,
    1: #endif
    1:                               public nsIEventListener,
    1:                               public nsITimerCallback,
    1:                               public nsIDOMMouseListener,
    1:                               public nsIDOMMouseMotionListener,
    1:                               public nsIDOMKeyListener,
    1:                               public nsIDOMFocusListener,
    1:                               public nsIScrollPositionListener,
    1:                               public nsIDOMDragListener
    1: 
    1: {
    1: public:
    1:   nsPluginInstanceOwner();
    1:   virtual ~nsPluginInstanceOwner();
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   //nsIPluginInstanceOwner interface
    1: 
    1:   NS_IMETHOD SetInstance(nsIPluginInstance *aInstance);
    1: 
    1:   NS_IMETHOD GetInstance(nsIPluginInstance *&aInstance);
    1: 
    1:   NS_IMETHOD GetWindow(nsPluginWindow *&aWindow);
    1: 
    1:   NS_IMETHOD GetMode(nsPluginMode *aMode);
    1: 
    1:   NS_IMETHOD CreateWidget(void);
    1: 
    1:   NS_IMETHOD GetURL(const char *aURL, const char *aTarget, void *aPostData, 
    1:                     PRUint32 aPostDataLen, void *aHeadersData, 
    1:                     PRUint32 aHeadersDataLen, PRBool isFile = PR_FALSE);
    1: 
    1:   NS_IMETHOD ShowStatus(const char *aStatusMsg);
    1: 
    1:   NS_IMETHOD ShowStatus(const PRUnichar *aStatusMsg);
    1:   
    1:   NS_IMETHOD GetDocument(nsIDocument* *aDocument);
    1: 
    1:   NS_IMETHOD InvalidateRect(nsPluginRect *invalidRect);
    1: 
    1:   NS_IMETHOD InvalidateRegion(nsPluginRegion invalidRegion);
    1: 
    1:   NS_IMETHOD ForceRedraw();
    1: 
    1:   NS_IMETHOD GetValue(nsPluginInstancePeerVariable variable, void *value);
    1: 
    1:   //nsIPluginTagInfo interface
    1: 
    1:   NS_IMETHOD GetAttributes(PRUint16& n, const char*const*& names,
    1:                            const char*const*& values);
    1: 
    1:   NS_IMETHOD GetAttribute(const char* name, const char* *result);
    1: 
    1:   //nsIPluginTagInfo2 interface
    1: 
    1:   NS_IMETHOD GetTagType(nsPluginTagType *result);
    1: 
    1:   NS_IMETHOD GetTagText(const char* *result);
    1: 
    1:   NS_IMETHOD GetParameters(PRUint16& n, const char*const*& names, const char*const*& values);
    1: 
    1:   NS_IMETHOD GetParameter(const char* name, const char* *result);
    1:   
    1:   NS_IMETHOD GetDocumentBase(const char* *result);
    1:   
    1:   NS_IMETHOD GetDocumentEncoding(const char* *result);
    1:   
    1:   NS_IMETHOD GetAlignment(const char* *result);
    1:   
    1:   NS_IMETHOD GetWidth(PRUint32 *result);
    1:   
    1:   NS_IMETHOD GetHeight(PRUint32 *result);
    1: 
    1:   NS_IMETHOD GetBorderVertSpace(PRUint32 *result);
    1:   
    1:   NS_IMETHOD GetBorderHorizSpace(PRUint32 *result);
    1: 
    1:   NS_IMETHOD GetUniqueID(PRUint32 *result);
    1: 
    1:   NS_IMETHOD GetDOMElement(nsIDOMElement* *result);
    1: 
    1: #ifdef OJI
    1:   //nsIJVMPluginTagInfo interface
    1: 
    1:   NS_IMETHOD GetCode(const char* *result);
    1: 
    1:   NS_IMETHOD GetCodeBase(const char* *result);
    1: 
    1:   NS_IMETHOD GetArchive(const char* *result);
    1: 
    1:   NS_IMETHOD GetName(const char* *result);
    1: 
    1:   NS_IMETHOD GetMayScript(PRBool *result);
    1: 
    1: #endif /* OJI */
    1: 
    1:  /** nsIDOMMouseListener interfaces 
    1:   * @see nsIDOMMouseListener
    1:   */
    1:   NS_IMETHOD MouseDown(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseUp(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseClick(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseDblClick(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseOver(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD MouseOut(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);     
    1:   /* END interfaces from nsIDOMMouseListener*/
    1: 
    1:   // nsIDOMMouseListener intefaces
    1:   NS_IMETHOD MouseMove(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD DragMove(nsIDOMEvent* aMouseEvent) { return NS_OK; }
    1: 
    1:   // nsIDOMKeyListener interfaces
    1:   NS_IMETHOD KeyDown(nsIDOMEvent* aKeyEvent);
    1:   NS_IMETHOD KeyUp(nsIDOMEvent* aKeyEvent);
    1:   NS_IMETHOD KeyPress(nsIDOMEvent* aKeyEvent);
    1:   // end nsIDOMKeyListener interfaces
    1: 
    1:   // nsIDOMFocuListener interfaces
    1:   NS_IMETHOD Focus(nsIDOMEvent * aFocusEvent);
    1:   NS_IMETHOD Blur(nsIDOMEvent * aFocusEvent);
    1:   
    1:   // nsIDOMDragListener interfaces
    1:   NS_IMETHOD DragEnter(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD DragOver(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD DragExit(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD DragDrop(nsIDOMEvent* aMouseEvent);
    1:   NS_IMETHOD DragGesture(nsIDOMEvent* aMouseEvent);
  482:   NS_IMETHOD Drag(nsIDOMEvent* aMouseEvent);
  482:   NS_IMETHOD DragEnd(nsIDOMEvent* aMouseEvent);
    1:   
    1: 
    1:   nsresult Destroy();  
    1: 
 4577:   void PrepareToStop(PRBool aDelayedStop);
 4577: 
    1:   //nsIEventListener interface
    1:   nsEventStatus ProcessEvent(const nsGUIEvent & anEvent);
    1:   
 3059: #ifdef XP_WIN
 3059:   void Paint(const nsRect& aDirtyRect, HDC ndc);
 3059: #elif defined(XP_MACOSX)
 3059:   void Paint(const nsRect& aDirtyRect);  
 3059: #elif defined(MOZ_X11)
 3059:   void Paint(nsIRenderingContext& aRenderingContext,
 3059:              const nsRect& aDirtyRect);
12859: #elif defined(XP_OS2)
12859:   void Paint(const nsRect& aDirtyRect, HPS aHPS);
 3059: #endif
    1: 
    1:   // nsITimerCallback interface
    1:   NS_DECL_NSITIMERCALLBACK
    1:   
    1:   void CancelTimer();
    1:   void StartTimer(unsigned int aDelay);
    1: 
    1:   // nsIScrollPositionListener interface
    1:   NS_IMETHOD ScrollPositionWillChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY);
    1:   NS_IMETHOD ScrollPositionDidChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY);
    1: 
    1:   //locals
    1: 
    1:   nsresult Init(nsPresContext* aPresContext, nsObjectFrame* aFrame,
    1:                 nsIContent* aContent);
    1: 
    1:   nsPluginPort* GetPluginPort();
    1:   void ReleasePluginPort(nsPluginPort * pluginPort);
    1: 
    1:   void SetPluginHost(nsIPluginHost* aHost);
    1: 
    1: #ifdef XP_MACOSX
  130:   NPDrawingModel GetDrawingModel();
  130:   WindowRef FixUpPluginWindow(PRInt32 inPaintState);
    1:   void GUItoMacEvent(const nsGUIEvent& anEvent, EventRecord* origEvent, EventRecord& aMacEvent);
    1: #endif
    1: 
 4577:   void SetOwner(nsObjectFrame *aOwner)
 4577:   {
 4577:     mOwner = aOwner;
 4577:   }
 4577: 
13537:   PRUint32 GetLastEventloopNestingLevel() const {
13537:     return mLastEventloopNestingLevel; 
13537:   }
13537: 
13537:   void ConsiderNewEventloopNestingLevel() {
13537:     nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
13537:     if (appShell) {
13537:       PRUint32 currentLevel = 0;
13537:       appShell->GetEventloopNestingLevel(&currentLevel);
13589: #ifdef XP_MACOSX
13589:       // Cocoa widget code doesn't process UI events through the normal appshell
13589:       // event loop, so it needs an additional count here.
13589:       currentLevel++;
13589: #else
13589:       // No idea how this happens... but Linux doesn't consistently process UI
13589:       // events through the appshell event loop. If we get a 0 here on any
13589:       // platform we increment the level just in case so that we make sure we
13589:       // always tear the plugin down eventually.
13589:       if (!currentLevel) {
13589:         currentLevel++;
13589:       }
13589: #endif
13537:       if (currentLevel < mLastEventloopNestingLevel) {
13537:         mLastEventloopNestingLevel = currentLevel;
13537:       }
13537:     }
13537:   }
13537: 
14390:   const char* GetPluginName()
14390:   {
14390:     if (mInstance && mPluginHost) {
14390:       nsCOMPtr<nsPIPluginHost> piPluginHost = do_QueryInterface(mPluginHost);
14390:       char* name = NULL;
14390:       if (NS_SUCCEEDED(piPluginHost->GetPluginName(mInstance, &name)) &&
14390:           name)
14390:         return name;
14390:     }
14390:     return "";
14390:   }
14390: 
    1: private:
    1:   void FixUpURLS(const nsString &name, nsAString &value);
    1: 
    1:   nsPluginNativeWindow       *mPluginWindow;
    1:   nsCOMPtr<nsIPluginInstance> mInstance;
    1:   nsObjectFrame              *mOwner;
    1:   nsCOMPtr<nsIContent>        mContent;
    1:   nsCString                   mDocumentBase;
    1:   char                       *mTagText;
    1:   nsCOMPtr<nsIWidget>         mWidget;
    1:   nsCOMPtr<nsITimer>          mPluginTimer;
    1:   nsCOMPtr<nsIPluginHost>     mPluginHost;
13537: 
13537:   // Initially, the event loop nesting level we were created on, it's updated
13537:   // if we detect the appshell is on a lower level as long as we're not stopped.
13537:   // We delay DoStopPlugin() until the appshell reaches this level or lower.
13537:   PRUint32                    mLastEventloopNestingLevel;
    1:   PRPackedBool                mContentFocused;
    1:   PRPackedBool                mWidgetVisible;    // used on Mac to store our widget's visible state
 4577: 
 4577:   // If true, destroy the widget on destruction. Used when plugin stop
 4577:   // is being delayed to a safer point in time.
 4577:   PRPackedBool                mDestroyWidget;
    1:   PRUint16          mNumCachedAttrs;
    1:   PRUint16          mNumCachedParams;
    1:   char              **mCachedAttrParamNames;
    1:   char              **mCachedAttrParamValues;
    1: 
12417:   // pointer to wrapper for nsIDOMContextMenuListener
12417:   nsRefPtr<nsPluginDOMContextMenuListener> mCXMenuListener;
    1: 
    1:   nsresult DispatchKeyToPlugin(nsIDOMEvent* aKeyEvent);
    1:   nsresult DispatchMouseToPlugin(nsIDOMEvent* aMouseEvent);
    1:   nsresult DispatchFocusToPlugin(nsIDOMEvent* aFocusEvent);
    1: 
    1:   nsresult EnsureCachedAttrParamArrays();
 3059: 
 3059: #ifdef MOZ_X11
 3059:   class Renderer : public gfxXlibNativeRenderer {
 3059:   public:
 3059:     Renderer(nsPluginWindow* aWindow, nsIPluginInstance* aInstance,
 3059:              const nsIntRect& aDirtyRect)
 3059:       : mWindow(aWindow), mInstance(aInstance), mDirtyRect(aDirtyRect)
 3059:     {}
 3059:     virtual nsresult NativeDraw(Display* dpy, Drawable drawable, Visual* visual,
 3059:                                 short offsetX, short offsetY,
 3059:                                 XRectangle* clipRects, PRUint32 numClipRects);
 3059:   private:
 3059:     nsPluginWindow* mWindow;
 3059:     nsIPluginInstance* mInstance;
 3059:     const nsIntRect& mDirtyRect;
    1:   };
 3059: #endif
 3059: 
 3059: };
 3059: 
12859: #if defined(XP_WIN) || (defined(DO_DIRTY_INTERSECT) && defined(XP_MACOSX)) || defined(MOZ_X11) || defined(XP_OS2)
 3059: static void ConvertAppUnitsToPixels(const nsPresContext& aPresContext, const nsRect& aTwipsRect, nsIntRect& aPixelRect);
    1: #endif
    1: 
    1:   // Mac specific code to fix up port position and clip during paint
    1: #ifdef XP_MACOSX
    1: 
    1: #ifdef DO_DIRTY_INTERSECT
    1:   // convert relative coordinates to absolute
    1:   static void ConvertRelativeToWindowAbsolute(nsIFrame* aFrame, nsPoint& aRel, nsPoint& aAbs, nsIWidget *&aContainerWidget);
    1: #endif
    1: 
    1:   enum { ePluginPaintIgnore, ePluginPaintEnable, ePluginPaintDisable };
    1: 
    1: #endif // XP_MACOSX
    1: 
12417: nsObjectFrame::nsObjectFrame(nsStyleContext* aContext)
12417:   : nsObjectFrameSuper(aContext)
12417: {
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("Created new nsObjectFrame %p\n", this));
12417: }
12417: 
    1: nsObjectFrame::~nsObjectFrame()
    1: {
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsObjectFrame %p deleted\n", this));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectFrame::QueryInterface(const nsIID& aIID, void** aInstancePtr)
    1: {
 3114:   NS_PRECONDITION(aInstancePtr, "null out param");
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIObjectFrame))) {
 3233:     *aInstancePtr = static_cast<nsIObjectFrame*>(this);
    1:     return NS_OK;
 3114:   }
 3114: 
 3114:   return nsObjectFrameSuper::QueryInterface(aIID, aInstancePtr);
    1: }
    1: 
    1: NS_IMETHODIMP_(nsrefcnt) nsObjectFrame::AddRef(void)
    1: {
    1:   NS_WARNING("not supported for frames");
    1:   return 1;
    1: }
    1: 
    1: NS_IMETHODIMP_(nsrefcnt) nsObjectFrame::Release(void)
    1: {
    1:   NS_WARNING("not supported for frames");
    1:   return 1;
    1: }
    1: 
    1: #ifdef ACCESSIBILITY
    1: NS_IMETHODIMP nsObjectFrame::GetAccessible(nsIAccessible** aAccessible)
    1: {
    1:   nsCOMPtr<nsIAccessibilityService> accService = do_GetService("@mozilla.org/accessibilityService;1");
    1: 
    1:   if (accService) {
    1:     return accService->CreateHTMLObjectFrameAccessible(this, aAccessible);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: #ifdef XP_WIN
    1: NS_IMETHODIMP nsObjectFrame::GetPluginPort(HWND *aPort)
    1: {
    1:   *aPort = (HWND) mInstanceOwner->GetPluginPort();
    1:   return NS_OK;
    1: }
    1: #endif
    1: #endif
    1: 
    1: 
    1: static NS_DEFINE_CID(kWidgetCID, NS_CHILD_CID);
    1: static NS_DEFINE_CID(kCPluginManagerCID, NS_PLUGINMANAGER_CID);
    1: 
    1: // #define DO_DIRTY_INTERSECT 1   // enable dirty rect intersection during paint
    1: 
    1: NS_IMETHODIMP 
    1: nsObjectFrame::Init(nsIContent*      aContent,
    1:                     nsIFrame*        aParent,
    1:                     nsIFrame*        aPrevInFlow)
    1: {
14982:   mPreventInstantiation = PR_FALSE;
    1: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("Initializing nsObjectFrame %p for content %p\n", this, aContent));
12417: 
 4329:   return nsObjectFrameSuper::Init(aContent, aParent, aPrevInFlow);
    1: }
    1: 
    1: void
    1: nsObjectFrame::Destroy()
    1: {
14982:   NS_ASSERTION(!mPreventInstantiation, "about to crash due to bug 136927");
    1: 
    1:   // we need to finish with the plugin before native window is destroyed
    1:   // doing this in the destructor is too late.
 4577:   StopPluginInternal(PR_TRUE);
    1:   
    1:   nsObjectFrameSuper::Destroy();
    1: }
    1: 
 7015: NS_IMETHODIMP
 7015: nsObjectFrame::DidSetStyleContext()
 7015: {
 7015:   if (HasView()) {
 7015:     nsIView* view = GetView();
 7015:     nsIViewManager* vm = view->GetViewManager();
 7015:     if (vm) {
 7015:       nsViewVisibility visibility = 
 7015:         IsHidden() ? nsViewVisibility_kHide : nsViewVisibility_kShow;
 7015:       vm->SetViewVisibility(view, visibility);
 7015:     }
 7015:   }
 7015: 
 7015:   return nsObjectFrameSuper::DidSetStyleContext();
 7015: }
 7015: 
    1: nsIAtom*
    1: nsObjectFrame::GetType() const
    1: {
    1:   return nsGkAtoms::objectFrame; 
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsObjectFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("ObjectFrame"), aResult);
    1: }
    1: #endif
    1: 
    1: nsresult
    1: nsObjectFrame::CreateWidgetForView(nsIView* aView)
    1: {
    1:   // Bug 179822: Create widget and allow non-unicode SubClass
    1:   nsWidgetInitData initData;
    1:   initData.mUnicode = PR_FALSE;
    1:   return aView->CreateWidget(kWidgetCID, &initData);
    1: }
    1: 
    1: nsresult
    1: nsObjectFrame::CreateWidget(nscoord aWidth,
    1:                             nscoord aHeight,
    1:                             PRBool  aViewOnly)
    1: {
    1:   nsIView* view = GetView();
    1:   NS_ASSERTION(view, "Object frames must have views");  
    1:   if (!view) {
    1:     return NS_OK;       //XXX why OK? MMP
    1:   }
    1: 
    1:   nsIViewManager* viewMan = view->GetViewManager();
    1:   // mark the view as hidden since we don't know the (x,y) until Paint
    1:   // XXX is the above comment correct?
    1:   viewMan->SetViewVisibility(view, nsViewVisibility_kHide);
    1: 
    1:   //this is ugly. it was ripped off from didreflow(). MMP
    1:   // Position and size view relative to its parent, not relative to our
    1:   // parent frame (our parent frame may not have a view).
    1:   
    1:   nsIView* parentWithView;
    1:   nsPoint origin;
    1:   nsRect r(0, 0, mRect.width, mRect.height);
    1: 
    1:   GetOffsetFromView(origin, &parentWithView);
    1:   viewMan->ResizeView(view, r);
    1:   viewMan->MoveViewTo(view, origin.x, origin.y);
    1: 
    1:   if (!aViewOnly && !view->HasWidget()) {
    1:     nsresult rv = CreateWidgetForView(view);
    1:     if (NS_FAILED(rv)) {
    1:       return NS_OK;       //XXX why OK? MMP
    1:     }
    1:   }
    1: 
    1:   {
    1:     // Here we set the background color for this widget because some plugins will use 
    1:     // the child window background color when painting. If it's not set, it may default to gray
    1:     // Sometimes, a frame doesn't have a background color or is transparent. In this
    1:     // case, walk up the frame tree until we do find a frame with a background color
    1:     for (nsIFrame* frame = this; frame; frame = frame->GetParent()) {
    1:       const nsStyleBackground* background = frame->GetStyleBackground();
    1:       if (!background->IsTransparent()) {  // make sure we got an actual color
    1:         nsIWidget* win = view->GetWidget();
    1:         if (win)
    1:           win->SetBackgroundColor(background->mBackgroundColor);
    1:         break;
    1:       }
    1:     }
    1: 
    1:   }
    1: 
 7015:   if (!IsHidden()) {
    1:     viewMan->SetViewVisibility(view, nsViewVisibility_kShow);
 7015:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: #define EMBED_DEF_WIDTH 240
    1: #define EMBED_DEF_HEIGHT 200
    1: 
    1: /* virtual */ nscoord
    1: nsObjectFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result = 0;
    1: 
    1:   if (!IsHidden(PR_FALSE)) {
    1:     nsIAtom *atom = mContent->Tag();
    1:     if (atom == nsGkAtoms::applet || atom == nsGkAtoms::embed) {
    1:       result = nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_WIDTH);
    1:     }
    1:   }
    1: 
    1:   DISPLAY_MIN_WIDTH(this, result);
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsObjectFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   return nsObjectFrame::GetMinWidth(aRenderingContext);
    1: }
    1: 
    1: void
    1: nsObjectFrame::GetDesiredSize(nsPresContext* aPresContext,
    1:                               const nsHTMLReflowState& aReflowState,
    1:                               nsHTMLReflowMetrics& aMetrics)
    1: {
    1:   // By default, we have no area
    1:   aMetrics.width = 0;
    1:   aMetrics.height = 0;
    1: 
    1:   if (IsHidden(PR_FALSE)) {
    1:     return;
    1:   }
    1:   
    1:   aMetrics.width = aReflowState.ComputedWidth();
 4166:   aMetrics.height = aReflowState.ComputedHeight();
    1: 
    1:   // for EMBED and APPLET, default to 240x200 for compatibility
    1:   nsIAtom *atom = mContent->Tag();
    1:   if (atom == nsGkAtoms::applet || atom == nsGkAtoms::embed) {
    1:     if (aMetrics.width == NS_UNCONSTRAINEDSIZE) {
    1:       aMetrics.width = PR_MIN(PR_MAX(nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_WIDTH),
    1:                                      aReflowState.mComputedMinWidth),
    1:                               aReflowState.mComputedMaxWidth);
    1:     }
    1:     if (aMetrics.height == NS_UNCONSTRAINEDSIZE) {
    1:       aMetrics.height = PR_MIN(PR_MAX(nsPresContext::CSSPixelsToAppUnits(EMBED_DEF_HEIGHT),
    1:                                       aReflowState.mComputedMinHeight),
    1:                                aReflowState.mComputedMaxHeight);
    1:     }
    1: 
  944: #if defined (MOZ_WIDGET_GTK2)
    1:     // We need to make sure that the size of the object frame does not
    1:     // exceed the maximum size of X coordinates.  See bug #225357 for
    1:     // more information.  In theory Gtk2 can handle large coordinates,
    1:     // but underlying plugins can't.
    1:     aMetrics.height = PR_MIN(aPresContext->DevPixelsToAppUnits(PR_INT16_MAX), aMetrics.height);
    1:     aMetrics.width = PR_MIN(aPresContext->DevPixelsToAppUnits(PR_INT16_MAX), aMetrics.width);
    1: #endif
    1:   }
    1: 
    1:   // At this point, the width has an unconstrained value only if we have
    1:   // nothing to go on (no width set, no information from the plugin, nothing).
    1:   // Make up a number.
    1:   if (aMetrics.width == NS_UNCONSTRAINEDSIZE) {
    1:     aMetrics.width =
    1:       (aReflowState.mComputedMinWidth != NS_UNCONSTRAINEDSIZE) ?
    1:         aReflowState.mComputedMinWidth : 0;
    1:   }
    1: 
    1:   // At this point, the height has an unconstrained value only in two cases:
    1:   // a) We are in standards mode with percent heights and parent is auto-height
    1:   // b) We have no height information at all.
    1:   // In either case, we have to make up a number.
    1:   if (aMetrics.height == NS_UNCONSTRAINEDSIZE) {
    1:     aMetrics.height =
    1:       (aReflowState.mComputedMinHeight != NS_UNCONSTRAINEDSIZE) ?
    1:         aReflowState.mComputedMinHeight : 0;
    1:   }
    1: 
    1:   // XXXbz don't add in the border and padding, because we screw up our
    1:   // plugin's size and positioning if we do...  Eventually we _do_ want to
    1:   // paint borders, though!  At that point, we will need to adjust the desired
    1:   // size either here or in Reflow....  Further, we will need to fix Paint() to
    1:   // call the superclass in all cases.
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectFrame::Reflow(nsPresContext*           aPresContext,
    1:                       nsHTMLReflowMetrics&     aMetrics,
    1:                       const nsHTMLReflowState& aReflowState,
    1:                       nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsObjectFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aStatus);
    1: 
    1:   // Get our desired size
    1:   GetDesiredSize(aPresContext, aReflowState, aMetrics);
 3017:   aMetrics.mOverflowArea = nsRect(0, 0,
 3017:                                   aMetrics.width, aMetrics.height);
    1: 
    1:   // delay plugin instantiation until all children have
    1:   // arrived. Otherwise there may be PARAMs or other stuff that the
    1:   // plugin needs to see that haven't arrived yet.
    1:   if (!GetContent()->IsDoneAddingChildren()) {
    1:     aStatus = NS_FRAME_COMPLETE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // if we are printing or print previewing, bail for now
    1:   if (aPresContext->Medium() == nsGkAtoms::print) {
    1:     aStatus = NS_FRAME_COMPLETE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   FixupWindow(nsSize(aMetrics.width, aMetrics.height));
    1: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aMetrics);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsObjectFrame::InstantiatePlugin(nsIPluginHost* aPluginHost, 
    1:                                  const char* aMimeType,
    1:                                  nsIURI* aURI)
    1: {
14982:   NS_ASSERTION(mPreventInstantiation,
14982:                "Instantiation should be prevented here!");
14982: 
    4:   // If you add early return(s), be sure to balance this call to
    4:   // appShell->SuspendNative() with additional call(s) to
    4:   // appShell->ReturnNative().
    4:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
    4:   if (appShell) {
    4:     appShell->SuspendNative();
    4:   }
    1: 
    1:   NS_ASSERTION(mContent, "We should have a content node.");
    1: 
    1:   nsIDocument* doc = mContent->GetOwnerDoc();
    1:   nsCOMPtr<nsIPluginDocument> pDoc (do_QueryInterface(doc));
    1: 
    1:   nsresult rv;
    1:   if (pDoc) {  /* full-page mode */
    1:     nsCOMPtr<nsIStreamListener> stream;
    1:     rv = aPluginHost->InstantiateFullPagePlugin(aMimeType, aURI,
    1:           /* resulting stream listener */       *getter_AddRefs(stream),
    1:                                                 mInstanceOwner);
    1:     if (NS_SUCCEEDED(rv))
    1:       pDoc->SetStreamListener(stream);
    1:   } else {   /* embedded mode */
    1:     rv = aPluginHost->InstantiateEmbeddedPlugin(aMimeType, aURI,
    1:                                                 mInstanceOwner);
    1:   }
    1: 
    4:   if (appShell) {
    4:     appShell->ResumeNative();
    4:   }
    4: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsObjectFrame::FixupWindow(const nsSize& aSize)
    1: {
  238:   nsPresContext* presContext = PresContext();
    1: 
    1:   if (!mInstanceOwner)
    1:     return;
    1: 
    1:   nsPluginWindow  *window;
    1:   mInstanceOwner->GetWindow(window);
    1: 
    1:   NS_ENSURE_TRUE(window, /**/);
    1: 
 4329: #ifdef XP_MACOSX
 4329:   mInstanceOwner->FixUpPluginWindow(ePluginPaintDisable);
 4329: #endif
 4329: 
 4329:   PRBool windowless = (window->type == nsPluginWindowType_Drawable);
 4329: 
 4329:   nsPoint origin = GetWindowOriginInPixels(windowless);
 4329: 
 4329:   window->x = origin.x;
 4329:   window->y = origin.y;
 4329: 
    1:   window->width = presContext->AppUnitsToDevPixels(aSize.width);
    1:   window->height = presContext->AppUnitsToDevPixels(aSize.height);
    1: 
    1:   // on the Mac we need to set the clipRect to { 0, 0, 0, 0 } for now. This will keep
    1:   // us from drawing on screen until the widget is properly positioned, which will not
    1:   // happen until we have finished the reflow process.
    1:   window->clipRect.top = 0;
    1:   window->clipRect.left = 0;
    1: #ifdef XP_MACOSX
    1:   window->clipRect.bottom = 0;
    1:   window->clipRect.right = 0;
    1: #else
    1:   window->clipRect.bottom = presContext->AppUnitsToDevPixels(aSize.height);
    1:   window->clipRect.right = presContext->AppUnitsToDevPixels(aSize.width);
    1: #endif
    1: }
    1: 
 4825: void
 4825: nsObjectFrame::CallSetWindow()
    1: {
    1:   nsPluginWindow *win = nsnull;
    1:  
 4825:   nsresult rv;
    1:   nsCOMPtr<nsIPluginInstance> pi; 
    1:   if (!mInstanceOwner ||
    1:       NS_FAILED(rv = mInstanceOwner->GetInstance(*getter_AddRefs(pi))) ||
    1:       !pi ||
    1:       NS_FAILED(rv = mInstanceOwner->GetWindow(win)) || 
    1:       !win)
 4825:     return;
    1: 
    1:   nsPluginNativeWindow *window = (nsPluginNativeWindow *)win;
    1: 
    1: #ifdef XP_MACOSX
    1:   mInstanceOwner->FixUpPluginWindow(ePluginPaintDisable);
    1: #endif
    1: 
 4825:   if (IsHidden())
 4825:     return;
    1: 
    1:   PRBool windowless = (window->type == nsPluginWindowType_Drawable);
    1: 
    1:   nsPoint origin = GetWindowOriginInPixels(windowless);
    1: 
    1:   window->x = origin.x;
    1:   window->y = origin.y;
    1: 
    1:   // refresh the plugin port as well
 3059: #ifdef MOZ_X11
 3059:   if(windowless) {
 3059:     // There is no plugin port window but there are some extra fields to
 3059:     // fill in.
 3059:     nsIWidget* widget = GetWindow();
 3059:     if (widget) {
 3059:       NPSetWindowCallbackStruct* ws_info = 
 3233:         static_cast<NPSetWindowCallbackStruct*>(window->ws_info);
 3059:       ws_info->display =
 3233:         static_cast<Display*>(widget->GetNativeData(NS_NATIVE_DISPLAY));
 3059: #ifdef MOZ_WIDGET_GTK2
 3059:       GdkWindow* gdkWindow =
 3233:         static_cast<GdkWindow*>(widget->GetNativeData(NS_NATIVE_WINDOW));
 3059:       GdkColormap* gdkColormap = gdk_drawable_get_colormap(gdkWindow);
 3059:       ws_info->colormap = gdk_x11_colormap_get_xcolormap(gdkColormap);
 3059:       GdkVisual* gdkVisual = gdk_colormap_get_visual(gdkColormap);
 3059:       ws_info->visual = gdk_x11_visual_get_xvisual(gdkVisual);
 3059:       ws_info->depth = gdkVisual->depth;
 3059: #endif
 3059:     }
 3059:   }
 3059:   else
 3059: #endif
 3059:   {
    1:     window->window = mInstanceOwner->GetPluginPort();
 3059:   }
    1: 
    1:   // this will call pi->SetWindow and take care of window subclassing
 4164:   // if needed, see bug 132759.
    1:   window->CallSetWindow(pi);
    1: 
    1:   mInstanceOwner->ReleasePluginPort((nsPluginPort *)window->window);
 4825: }
 4825: 
 4825: PRBool
 4825: nsObjectFrame::IsFocusable(PRInt32 *aTabIndex, PRBool aWithMouse)
 4825: {
 4825:   if (aTabIndex)
 4825:     *aTabIndex = -1;
 4825:   return nsObjectFrameSuper::IsFocusable(aTabIndex, aWithMouse);
 4825: }
 4825: 
 4825: PRBool
 4825: nsObjectFrame::IsHidden(PRBool aCheckVisibilityStyle) const
 4825: {
 4825:   if (aCheckVisibilityStyle) {
 4825:     if (!GetStyleVisibility()->IsVisibleOrCollapsed())
 4825:       return PR_TRUE;    
 4825:   }
 4825: 
 4825:   // only <embed> tags support the HIDDEN attribute
 4825:   if (mContent->Tag() == nsGkAtoms::embed) {
 4825:     // Yes, these are really the kooky ways that you could tell 4.x
 4825:     // not to hide the <embed> once you'd put the 'hidden' attribute
 4825:     // on the tag...
 4825: 
 4825:     // HIDDEN w/ no attributes gets translated as we are hidden for
 4825:     // compatibility w/ 4.x and IE so we don't create a non-painting
 4825:     // widget in layout. See bug 188959.
 4825:     nsAutoString hidden;
 4825:     if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::hidden, hidden) &&
 4825:        (hidden.IsEmpty() ||
 4825:         !hidden.LowerCaseEqualsLiteral("false") &&
 4825:         !hidden.LowerCaseEqualsLiteral("no") &&
 4825:         !hidden.LowerCaseEqualsLiteral("off"))) {
 4825:       return PR_TRUE;
 4825:     }
 4825:   }
 4825: 
 4825:   return PR_FALSE;
 4825: }
 4825: 
 4825: nsPoint nsObjectFrame::GetWindowOriginInPixels(PRBool aWindowless)
 4825: {
 4825:   nsIView * parentWithView;
 4825:   nsPoint origin(0,0);
 4825: 
 4825:   GetOffsetFromView(origin, &parentWithView);
 4825: 
 4825:   // if it's windowless, let's make sure we have our origin set right
 4825:   // it may need to be corrected, like after scrolling
 4825:   if (aWindowless && parentWithView) {
 4825:     // XXX Should this be replaced by nsIView::GetNearestWidget?
 4825:     // The implementation below doesn't handle cases where the widget's origin
 4825:     // doesn't coincide with its view's origin.
 4825: 
 4825:     nsIViewManager* parentVM = parentWithView->GetViewManager();
 4825: 
 4825:     // Walk up all the views and add up their positions until we
 4825:     // reach the first view with a window (non-null widget). This will give us our
 4825:     // position relative to the containing window which is what we want to give the plugin
 4825:     nsIView* theView = parentWithView;
 4825:     while (theView && !theView->GetWidget()) {
 4825:       if (theView->GetViewManager() != parentVM)
 4825:         break;
 4825: 
 4825:       origin += theView->GetPosition();
 4825:       theView = theView->GetParent();
 4825:     }  
 4825:   }
 4825: 
 4825:   origin.x = PresContext()->AppUnitsToDevPixels(origin.x);
 4825:   origin.y = PresContext()->AppUnitsToDevPixels(origin.y);
 4825: 
 4825:   return origin;
 4825: }
 4825: 
 4825: NS_IMETHODIMP
 4825: nsObjectFrame::DidReflow(nsPresContext*            aPresContext,
 4825:                          const nsHTMLReflowState*  aReflowState,
 4825:                          nsDidReflowStatus         aStatus)
 4825: {
 4825:   // Do this check before calling the superclass, as that clears
 4825:   // NS_FRAME_FIRST_REFLOW
 4825:   if (aStatus == NS_FRAME_REFLOW_FINISHED &&
 4825:       (GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
 4825:     nsCOMPtr<nsIObjectLoadingContent> objContent(do_QueryInterface(mContent));
 4825:     NS_ASSERTION(objContent, "Why not an object loading content?");
 4825:     objContent->HasNewFrame(this);
 4825:   }
 4825: 
 4825:   nsresult rv = nsObjectFrameSuper::DidReflow(aPresContext, aReflowState, aStatus);
 4825: 
 4825:   // The view is created hidden; once we have reflowed it and it has been
 4825:   // positioned then we show it.
 4825:   if (aStatus != NS_FRAME_REFLOW_FINISHED) 
 4825:     return rv;
 4825: 
 4825:   if (HasView()) {
 4825:     nsIView* view = GetView();
 4825:     nsIViewManager* vm = view->GetViewManager();
 4825:     if (vm)
 4825:       vm->SetViewVisibility(view, IsHidden() ? nsViewVisibility_kHide : nsViewVisibility_kShow);
 4825:   }
 4825: 
 4825:   // WMP10 needs an additional SetWindow call here (bug 391261)
 4825:   CallSetWindow();
    1: 
    1:   return rv;
    1: }
    1: 
    1: static void PaintPrintPlugin(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:                              const nsRect& aDirtyRect, nsPoint aPt)
    1: {
    1:   nsIRenderingContext::AutoPushTranslation translate(aCtx, aPt.x, aPt.y);
 3233:   static_cast<nsObjectFrame*>(aFrame)->PrintPlugin(*aCtx, aDirtyRect);
    1: }
    1: 
    1: static void PaintPlugin(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:                         const nsRect& aDirtyRect, nsPoint aPt)
    1: {
    1:   nsIRenderingContext::AutoPushTranslation translate(aCtx, aPt.x, aPt.y);
 3059: #ifdef MOZ_X11 // FIXME - Bug 385435: Don't others want this too!
 3059:   nsRect relativeDirtyRect = aDirtyRect - aPt;
 3233:   static_cast<nsObjectFrame*>(aFrame)->PaintPlugin(*aCtx, relativeDirtyRect);
 3059: #else
 3233:   static_cast<nsObjectFrame*>(aFrame)->PaintPlugin(*aCtx, aDirtyRect);
 3059: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                 const nsRect&           aDirtyRect,
    1:                                 const nsDisplayListSet& aLists)
    1: {
    1:   // XXX why are we painting collapsed object frames?
    1:   if (!IsVisibleOrCollapsedForPainting(aBuilder))
    1:     return NS_OK;
    1:     
    1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
  238:   nsPresContext::nsPresContextType type = PresContext()->Type();
    1: 
    1:   // If we are painting in Print Preview do nothing....
    1:   if (type == nsPresContext::eContext_PrintPreview)
    1:     return NS_OK;
    1: 
    1:   DO_GLOBAL_REFLOW_COUNT_DSP("nsObjectFrame");
    1:   
    1:   // determine if we are printing
    1:   if (type == nsPresContext::eContext_Print)
    1:     return aLists.Content()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayGeneric(this, PaintPrintPlugin, "PrintPlugin"));
    1:   
    1:   return aLists.Content()->AppendNewToTop(new (aBuilder)
    1:       nsDisplayGeneric(this, ::PaintPlugin, "Plugin"));
    1: }
    1: 
    1: void
    1: nsObjectFrame::PrintPlugin(nsIRenderingContext& aRenderingContext,
    1:                            const nsRect& aDirtyRect)
    1: {
    1:   // if we are printing, we need to get the correct nsIPluginInstance
    1:   // for THIS content node in order to call ->Print() on the right plugin
    1: 
    1:   // first, we need to get the document
    1:   nsIDocument* doc = mContent->GetCurrentDoc();
    1:   if (!doc)
    1:     return;
    1: 
    1:   // now we need to get the shell for the screen
    1:   // XXX assuming that the shell at zero will always be the screen one
  981:   nsIPresShell *shell = doc->GetPrimaryShell();
    1:   if (!shell)
    1:     return;
    1: 
    1:   // then the shell can give us the screen frame for this content node
    1:   nsIFrame* frame = shell->GetPrimaryFrameFor(mContent);
    1:   if (!frame)
    1:     return;
    1: 
  238:   nsPresContext* presContext = PresContext();
    1:   // make sure this is REALLY an nsIObjectFrame
    1:   // we may need to go through the children to get it
    1:   nsIObjectFrame* objectFrame = nsnull;
    1:   CallQueryInterface(frame,&objectFrame);
    1:   if (!objectFrame)
    1:     objectFrame = GetNextObjectFrame(presContext,frame);
    1:   if (!objectFrame)
    1:     return;
    1: 
    1:   // finally we can get our plugin instance
    1:   nsCOMPtr<nsIPluginInstance> pi;
    1:   if (NS_FAILED(objectFrame->GetPluginInstance(*getter_AddRefs(pi))) || !pi)
    1:     return;
    1: 
    1:   // now we need to setup the correct location for printing
    1:   nsresult rv;
    1:   nsPluginWindow    window;
    1:   window.window =   nsnull;
    1: 
    1:   // prepare embedded mode printing struct
    1:   nsPluginPrint npprint;
    1:   npprint.mode = nsPluginMode_Embedded;
    1: 
    1:   // we need to find out if we are windowless or not
    1:   PRBool windowless = PR_FALSE;
    1:   pi->GetValue(nsPluginInstanceVariable_WindowlessBool, (void *)&windowless);
    1:   window.type  =  windowless ? nsPluginWindowType_Drawable : nsPluginWindowType_Window;
    1: 
    1:   window.clipRect.bottom = 0; window.clipRect.top = 0;
    1:   window.clipRect.left = 0; window.clipRect.right = 0;
    1:   
    1: // XXX platform specific printing code
    1: #if defined(XP_UNIX) && !defined(XP_MACOSX)
12653: 
12653:   /* XXX this just flat-out doesn't work in a thebes world --
12653:    * RenderEPS is a no-op.  So don't bother to do any work here.
12653:    */
12653: #if 0
    1:     /* UNIX does things completely differently:
    1:    * We call the plugin and it sends generated PostScript data into a
    1:    * file handle we provide. If the plugin returns with success we embed
    1:    * this PostScript code fragment into the PostScript job we send to the
    1:    * printer.
    1:    */
    1: 
    1:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG, ("nsObjectFrame::Paint() start for X11 platforms\n"));
    1:          
    1:   FILE *plugintmpfile = tmpfile();
    1:   if (!plugintmpfile) {
    1:     PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG, ("error: could not open tmp. file, errno=%d\n", errno));
    1:     return;
    1:   }
    1:  
    1:     /* Send off print info to plugin */
    1:   NPPrintCallbackStruct npPrintInfo;
    1:   npPrintInfo.type = NP_PRINT;
    1:   npPrintInfo.fp   = plugintmpfile;
    1:   npprint.print.embedPrint.platformPrint = (void *)&npPrintInfo;
    1:   /* aDirtyRect contains the right information for ps print */
    1:   window.x =   aDirtyRect.x;
    1:   window.y =   aDirtyRect.y;
    1:   window.width =   aDirtyRect.width;
    1:   window.height =   aDirtyRect.height;
    1:   npprint.print.embedPrint.window        = window;
    1:   rv = pi->Print(&npprint);
    1:   if (NS_FAILED(rv)) {
    1:     PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG, ("error: plugin returned failure %lx\n", (long)rv));
    1:     fclose(plugintmpfile);
    1:     return;
    1:   }
    1: 
    1:   /* Send data to printer */
    1:   rv = aRenderingContext.RenderEPS(aDirtyRect, plugintmpfile);
    1: 
    1:   fclose(plugintmpfile);
    1: 
    1:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG, ("plugin printing done, return code is %lx\n", (long)rv));
12653: #endif
    1: 
12859: #elif defined(XP_OS2)
12859:   void *hps = aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_OS2_PS);
12859:   if (!hps)
12859:     return;
12859: 
12859:   npprint.print.embedPrint.platformPrint = hps;
12859:   npprint.print.embedPrint.window = window;
12859:   // send off print info to plugin
12859:   rv = pi->Print(&npprint);
11703: #elif defined(XP_WIN)
11703: 
11703:   /* On Windows, we use the win32 printing surface to print.  This, in
11703:    * turn, uses the Cairo paginated surface, which in turn uses the
11703:    * meta surface to record all operations and then play them back.
11703:    * This doesn't work too well for plugins, because if plugins render
11703:    * directly into the DC, the meta surface won't have any knowledge
11703:    * of them, and so at the end when it actually does the replay step,
11703:    * it'll fill the background with white and draw over whatever was
11703:    * rendered before.
11703:    *
11703:    * So, to avoid this, we use PushGroup, which creates a new windows
11703:    * surface, the plugin renders to that, and then we use normal
11703:    * cairo methods to composite that in such that it's recorded using the
11703:    * meta surface.
11703:    */
11703: 
12653:   /* we'll already be translated into the right spot by gfxWindowsNativeDrawing */
12653:   window.x = 0;
12653:   window.y = 0;
12653:   window.width = presContext->AppUnitsToDevPixels(mRect.width);
12653:   window.height = presContext->AppUnitsToDevPixels(mRect.height);
12653: 
11703:   gfxContext *ctx = aRenderingContext.ThebesContext();
11703: 
11703:   ctx->Save();
11703: 
12653:   /* Make sure plugins don't do any damage outside of where they're supposed to */
11703:   ctx->NewPath();
11703:   ctx->Rectangle(gfxRect(window.x, window.y,
11703:                          window.width, window.height));
11703:   ctx->Clip();
12653: 
12653:   /* If we're windowless, we need to do COLOR_ALPHA, and do alpha recovery.
12653:    * XXX - we could have some sort of flag here that would indicate whether
12653:    * the plugin knows how to render to an ARGB DIB
12653:    */
12653:   if (windowless)
11703:     ctx->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
12653:   else
12653:     ctx->PushGroup(gfxASurface::CONTENT_COLOR);
11703: 
11703:   gfxWindowsNativeDrawing nativeDraw(ctx,
11703:                                      gfxRect(window.x, window.y,
11703:                                              window.width, window.height));
11703:   do {
11703:     HDC dc = nativeDraw.BeginNativeDrawing();
11703:     if (!dc)
11703:       return;
11703: 
11703:     npprint.print.embedPrint.platformPrint = dc;
11703:     npprint.print.embedPrint.window = window;
11703:     // send off print info to plugin
11703:     rv = pi->Print(&npprint);
11703: 
11703:     nativeDraw.EndNativeDrawing();
11703:   } while (nativeDraw.ShouldRenderAgain());
11703:   nativeDraw.PaintToContext();
11703: 
11703:   ctx->PopGroupToSource();
11703:   ctx->Paint();
11703: 
11703:   ctx->Restore();
11703: 
    1: #else
    1: 
12653:   // Get the offset of the DC
12653:   nsTransform2D* rcTransform;
12653:   aRenderingContext.GetCurrentTransform(rcTransform);
12653:   nsPoint origin;
12653:   rcTransform->GetTranslationCoord(&origin.x, &origin.y);
12653: 
12653:   // set it all up
12653:   // XXX is windowless different?
12653:   window.x = presContext->AppUnitsToDevPixels(origin.x);
12653:   window.y = presContext->AppUnitsToDevPixels(origin.y);
12653:   window.width = presContext->AppUnitsToDevPixels(mRect.width);
12653:   window.height= presContext->AppUnitsToDevPixels(mRect.height);
12653: 
    1:   // we need the native printer device context to pass to plugin
11703:   // NATIVE_WINDOWS_DC is a misnomer, it's whatever the native platform
11703:   // thing is.
    1:   void* dc;
    1:   dc = aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_WINDOWS_DC);
 4185:   if (!dc)
 4185:     return; // no dc implemented so quit
    1: 
    1:   npprint.print.embedPrint.platformPrint = dc;
    1:   npprint.print.embedPrint.window = window;
    1:   // send off print info to plugin
    1:     rv = pi->Print(&npprint);
    1: #endif
    1: 
    1:   // XXX Nav 4.x always sent a SetWindow call after print. Should we do the same?
    1:   nsDidReflowStatus status = NS_FRAME_REFLOW_FINISHED; // should we use a special status?
    1:   frame->DidReflow(presContext,
    1:                    nsnull, status);  // DidReflow will take care of it
    1: }
    1: 
    1: void
    1: nsObjectFrame::PaintPlugin(nsIRenderingContext& aRenderingContext,
    1:                            const nsRect& aDirtyRect)
    1: {
    1:   // Screen painting code
    1: #if defined(XP_MACOSX)
    1:   // delegate all painting to the plugin instance.
11944:   if (mInstanceOwner) {
11944:     if (mInstanceOwner->GetDrawingModel() == NPDrawingModelCoreGraphics) {
11944:       PRInt32 p2a = PresContext()->AppUnitsPerDevPixel();
11944:       gfxRect nativeClipRect(aDirtyRect.x, aDirtyRect.y,
11944:                              aDirtyRect.width, aDirtyRect.height);
11944:       nativeClipRect.ScaleInverse(gfxFloat(p2a));
11944:       gfxContext* ctx = aRenderingContext.ThebesContext();
11944:       gfxQuartzNativeDrawing nativeDrawing(ctx, nativeClipRect);
11944: 
11944:       CGContextRef cgContext = nativeDrawing.BeginNativeDrawing();
11944:       if (!cgContext) {
11944:         NS_WARNING("null CGContextRef during PaintPlugin");
11944:         return;
11944:       }
11944: 
12241:       // If gfxQuartzNativeDrawing hands out a CGContext other than the last
12241:       // one we passed to the plugin, we need to pass the new one to the
12241:       // plugin via SetWindow.
12241:       // XXXkinetik it's not necessary to call SetWindow for every paint so
12241:       // this should eventually be optimized to only do so when necessary
11944:       nsPluginPort* pluginPort = mInstanceOwner->GetPluginPort();
12241:       nsCOMPtr<nsIPluginInstance> inst;
12241:       GetPluginInstance(*getter_AddRefs(inst));
12241:       if (!inst) {
12241:         NS_WARNING("null plugin instance during PaintPlugin");
12241:         return;
12241:       }
12241:       nsPluginWindow* window;
12241:       mInstanceOwner->GetWindow(window);
12241:       if (!window) {
12241:         NS_WARNING("null plugin window during PaintPlugin");
12241:         return;
12241:       }
12241:       pluginPort->cgPort.context = cgContext;
12241:       window->window = pluginPort;
12241:       inst->SetWindow(window);
11944: 
    1:       mInstanceOwner->Paint(aDirtyRect);
11944: 
11944:       nativeDrawing.EndNativeDrawing();
11944:     } else {
11944:       mInstanceOwner->Paint(aDirtyRect);
11944:     }
11944:   }
 3059: #elif defined(MOZ_X11)
 3059:   if (mInstanceOwner)
 3059:     {
 3059:       nsPluginWindow * window;
 3059:       mInstanceOwner->GetWindow(window);
 3059: 
 3059:       if (window->type == nsPluginWindowType_Drawable)
 3059:         mInstanceOwner->Paint(aRenderingContext, aDirtyRect);
 3059:     }
12859: #elif defined (XP_WIN) || defined(XP_OS2)
    1:   nsCOMPtr<nsIPluginInstance> inst;
    1:   GetPluginInstance(*getter_AddRefs(inst));
    1:   if (inst) {
    1:     // Look if it's windowless
    1:     nsPluginWindow * window;
    1:     mInstanceOwner->GetWindow(window);
    1: 
    1:     if (window->type == nsPluginWindowType_Drawable) {
    1:       // check if we need to call SetWindow with updated parameters
    1:       PRBool doupdatewindow = PR_FALSE;
    1:       // the offset of the DC
    1:       nsPoint origin;
    1: 
    1:       /*
    1:        * Layout now has an optimized way of painting. Now we always get
    1:        * a new drawing surface, sized to be just what's needed. Windowless
    1:        * plugins need a transform applied to their origin so they paint
    1:        * in the right place. Since |SetWindow| is no longer being used
    1:        * to tell the plugin where it is, we dispatch a NPWindow through
    1:        * |HandleEvent| to tell the plugin when its window moved
    1:        */
15229:       gfxContext *ctx = aRenderingContext.ThebesContext();
    1:       gfxMatrix ctxMatrix = ctx->CurrentMatrix();
    1:       if (ctxMatrix.HasNonTranslation()) {
    1:         // soo; in the future, we should be able to render
    1:         // the object content to an offscreen DC, and then
    1:         // composite it in with the right transforms.
    1: 
    1:         // But, we don't bother doing that, because we don't
    1:         // have the event handling story figured out yet.
    1:         // Instead, let's just bail.
    1: 
    1:         return;
    1:       }
    1: 
    1:       origin.x = NSToIntRound(float(ctxMatrix.GetTranslation().x));
    1:       origin.y = NSToIntRound(float(ctxMatrix.GetTranslation().y));
    1: 
    1:       /* Need to force the clip to be set */
    1:       ctx->UpdateSurfaceClip();
    1: 
    1:       /* Set the device offsets as appropriate, for whatever our current group offsets might be */
    1:       gfxFloat xoff, yoff;
    1:       nsRefPtr<gfxASurface> surf = ctx->CurrentSurface(&xoff, &yoff);
    1: 
12761:       if (surf->CairoStatus() != 0) {
12761:         NS_WARNING("Plugin is being asked to render to a surface that's in error!");
12761:         return;
12761:       }
12761: 
12859: #ifdef XP_WIN
12761:       // check if we need to update hdc
12761:       HDC hdc = (HDC)aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_WINDOWS_DC);
12761: 
12761:       if (reinterpret_cast<HDC>(window->window) != hdc) {
12761:         window->window = reinterpret_cast<nsPluginPort*>(hdc);
12761:         doupdatewindow = PR_TRUE;
12761:       }
12761: 
12761:       SaveDC(hdc);
12761: 
    1:       POINT origViewportOrigin;
    1:       GetViewportOrgEx(hdc, &origViewportOrigin);
    1:       SetViewportOrgEx(hdc, origViewportOrigin.x + (int) xoff, origViewportOrigin.y + (int) yoff, NULL);
12859: #else // do something similar on OS/2
12859:       // check if we need to update the PS
12859:       HPS hps = (HPS)aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_OS2_PS);
12859:       if (reinterpret_cast<HPS>(window->window) != hps) {
12859:         window->window = reinterpret_cast<nsPluginPort*>(hps);
12859:         doupdatewindow = PR_TRUE;
12859:       }
12859:       LONG lPSid = GpiSavePS(hps);
12859:       RECTL rclViewport;
12859:       if (GpiQueryDevice(hps) != NULLHANDLE) { // ensure that we have an associated HDC
12859:         if (GpiQueryPageViewport(hps, &rclViewport)) {
12859:           rclViewport.xLeft += (LONG)xoff;
12859:           rclViewport.xRight += (LONG)xoff;
12859:           rclViewport.yBottom += (LONG)yoff;
12859:           rclViewport.yTop += (LONG)yoff;
12859:           GpiSetPageViewport(hps, &rclViewport);
12859:         }
12859:       }
12859: #endif
    1: 
    1:       if ((window->x != origin.x) || (window->y != origin.y)) {
    1:         window->x = origin.x;
    1:         window->y = origin.y;
    1:         doupdatewindow = PR_TRUE;
    1:       }
    1: 
    1:       // if our location or visible area has changed, we need to tell the plugin
    1:       if (doupdatewindow) {
    1: #ifdef XP_WIN    // Windowless plugins on windows need a special event to update their location, see bug 135737
    1:            // bug 271442: note, the rectangle we send is now purely the bounds of the plugin
    1:            // relative to the window it is contained in, which is useful for the plugin to correctly translate mouse coordinates
    1:            //
    1:            // this does not mesh with the comments for bug 135737 which imply that the rectangle
    1:            // must be clipped in some way to prevent the plugin attempting to paint over areas it shouldn't;
    1:            //
    1:            // since the two uses of the rectangle are mutually exclusive in some cases,
    1:            // and since I don't see any incorrect painting (at least with Flash and ViewPoint - the originator of 135737),
    1:            // it seems that windowless plugins are not relying on information here for clipping their drawing,
    1:            // and we can safely use this message to tell the plugin exactly where it is in all cases.
    1: 
    1:               origin = GetWindowOriginInPixels(PR_TRUE);
    1:               nsRect winlessRect = nsRect(origin, nsSize(window->width, window->height));
 3059:               // XXX I don't think we can be certain that the location wrt to
 3059:               // the window only changes when the location wrt to the drawable
 3059:               // changes, but the hdc probably changes on every paint so
 3059:               // doupdatewindow is rarely false, and there is not likely to be
 3059:               // a problem.
    1:               if (mWindowlessRect != winlessRect) {
    1:                 mWindowlessRect = winlessRect;
    1: 
    1:                 WINDOWPOS winpos;
    1:                 memset(&winpos, 0, sizeof(winpos));
    1:                 winpos.x = mWindowlessRect.x;
    1:                 winpos.y = mWindowlessRect.y;
    1:                 winpos.cx = mWindowlessRect.width;
    1:                 winpos.cy = mWindowlessRect.height;
    1: 
    1:                 // finally, update the plugin by sending it a WM_WINDOWPOSCHANGED event
    1:                 nsPluginEvent pluginEvent;
    1:                 pluginEvent.event = WM_WINDOWPOSCHANGED;
    1:                 pluginEvent.wParam = 0;
    1:                 pluginEvent.lParam = (uint32)&winpos;
    1:                 PRBool eventHandled = PR_FALSE;
    1: 
    1:                 inst->HandleEvent(&pluginEvent, &eventHandled);
    1:               }
    1: #endif
    1: 
    1:         inst->SetWindow(window);        
    1:       }
    1: 
12859: #ifdef XP_WIN
 3059:       // FIXME - Bug 385435:
    1:       // This expects a dirty rect relative to the plugin's rect
    1:       // XXX I wonder if this breaks if we give the frame a border so the
    1:       // frame origin and plugin origin are not the same
 3059:       mInstanceOwner->Paint(aDirtyRect, hdc);
    1: 
    1:       RestoreDC(hdc, -1);
12859: #else // do something similar on OS/2
12859:       mInstanceOwner->Paint(aDirtyRect, hps);
12859:       if (lPSid >= 1) {
12859:         GpiRestorePS(hps, lPSid);
12859:       }
12859: #endif
    1:       surf->MarkDirty();
    1:     }
    1:   }
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsObjectFrame::HandleEvent(nsPresContext* aPresContext,
    1:                            nsGUIEvent*     anEvent,
    1:                            nsEventStatus*  anEventStatus)
    1: {
    1:   NS_ENSURE_ARG_POINTER(anEventStatus);
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (!mInstanceOwner)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
13537:   mInstanceOwner->ConsiderNewEventloopNestingLevel();
13537: 
    1:   if (anEvent->message == NS_PLUGIN_ACTIVATE) {
    1:     nsIContent* content = GetContent();
    1:     if (content) {
    1:       content->SetFocus(aPresContext);
    1:       return rv;
    1:     }
    1:   }
    1: 
    1: #ifdef XP_WIN
    1:   rv = nsObjectFrameSuper::HandleEvent(aPresContext, anEvent, anEventStatus);
    1:   return rv;
    1: #endif
    1: 
    1:   switch (anEvent->message) {
    1:   case NS_DESTROY:
    1:     mInstanceOwner->CancelTimer();
    1:     break;
    1:   case NS_GOTFOCUS:
    1:   case NS_LOSTFOCUS:
    1:     *anEventStatus = mInstanceOwner->ProcessEvent(*anEvent);
    1:     break;
    1:     
    1:   default:
    1:     // instead of using an event listener, we can dispatch events to plugins directly.
    1:     rv = nsObjectFrameSuper::HandleEvent(aPresContext, anEvent, anEventStatus);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult nsObjectFrame::GetPluginInstance(nsIPluginInstance*& aPluginInstance)
    1: {
    1:   aPluginInstance = nsnull;
    1: 
    1:   if (!mInstanceOwner)
    1:     return NS_OK;
    1:   
    1:   return mInstanceOwner->GetInstance(aPluginInstance);
    1: }
    1: 
    1: nsresult
    1: nsObjectFrame::PrepareInstanceOwner()
    1: {
12744:   nsWeakFrame weakFrame(this);
12744: 
 6312:   // First, have to stop any possibly running plugins.
 6312:   StopPluginInternal(PR_FALSE);
 6312: 
12744:   if (!weakFrame.IsAlive()) {
12744:     return NS_ERROR_NOT_AVAILABLE;
12744:   }
12744: 
    1:   NS_ASSERTION(!mInstanceOwner, "Must not have an instance owner here");
    1: 
    1:   mInstanceOwner = new nsPluginInstanceOwner();
12417: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("Created new instance owner %p for frame %p\n", mInstanceOwner.get(),
12417:           this));
12417: 
    1:   if (!mInstanceOwner)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
12417:   // Note, |this| may very well be gone after this call.
12417:   return mInstanceOwner->Init(PresContext(), this, GetContent());
    1: }
    1: 
    1: nsresult
    1: nsObjectFrame::Instantiate(nsIChannel* aChannel, nsIStreamListener** aStreamListener)
    1: {
14982:   if (mPreventInstantiation) {
 8609:     return NS_OK;
 8609:   }
 8609:   
12417:   // Note: If PrepareInstanceOwner() returns an error, |this| may very
12417:   // well be deleted already.
    1:   nsresult rv = PrepareInstanceOwner();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(kCPluginManagerCID, &rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   mInstanceOwner->SetPluginHost(pluginHost);
    1: 
    1:   // This must be done before instantiating the plugin
    1:   FixupWindow(mRect.Size());
    1: 
14982:   NS_ASSERTION(!mPreventInstantiation, "Say what?");
14982:   mPreventInstantiation = PR_TRUE;
    1:   rv = pluginHost->InstantiatePluginForChannel(aChannel, mInstanceOwner, aStreamListener);
14982:   NS_ASSERTION(mPreventInstantiation,
14982:                "Instantiation should still be prevented!");
14982:   mPreventInstantiation = PR_FALSE;
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsObjectFrame::Instantiate(const char* aMimeType, nsIURI* aURI)
    1: {
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsObjectFrame::Instantiate(%s) called on frame %p\n", aMimeType,
12417:           this));
12417: 
14982:   if (mPreventInstantiation) {
 8609:     return NS_OK;
 8609:   }
 8609: 
    1:   NS_ASSERTION(aMimeType || aURI, "Need a type or a URI!");
12417: 
12417:   // Note: If PrepareInstanceOwner() returns an error, |this| may very
12417:   // well be deleted already.
    1:   nsresult rv = PrepareInstanceOwner();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // This must be done before instantiating the plugin
    1:   FixupWindow(mRect.Size());
    1: 
    1:   // get the nsIPluginHost service
    1:   nsCOMPtr<nsIPluginHost> pluginHost(do_GetService(kCPluginManagerCID, &rv));
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1:   mInstanceOwner->SetPluginHost(pluginHost);
    1: 
14982:   mPreventInstantiation = PR_TRUE;
14982: 
    1:   rv = InstantiatePlugin(pluginHost, aMimeType, aURI);
    1: 
    1:   // finish up
    1:   if (NS_SUCCEEDED(rv)) {
 4189:     TryNotifyContentObjectWrapper();
 4825:     CallSetWindow();
 4189:   }
 4189: 
14982:   NS_ASSERTION(mPreventInstantiation,
14982:                "Instantiation should still be prevented!");
14982: 
14982:   mPreventInstantiation = PR_FALSE;
14982: 
 4189:   return rv;
 4189: }
 4189: 
 4189: void
 4189: nsObjectFrame::TryNotifyContentObjectWrapper()
 4189: {
    1:   nsCOMPtr<nsIPluginInstance> inst;
    1:   mInstanceOwner->GetInstance(*getter_AddRefs(inst));
    1:   if (inst) {
    1:     // The plugin may have set up new interfaces; we need to mess with our JS
    1:     // wrapper.  Note that we DO NOT want to call this if there is no plugin
    1:     // instance!  That would just reenter Instantiate(), trying to create
    1:     // said plugin instance.
    1:     NotifyContentObjectWrapper();
    1:   }
    1: }
    1: 
13537: class nsStopPluginRunnable : public nsRunnable, public nsITimerCallback
    1: {
 4577: public:
13537:   NS_DECL_ISUPPORTS_INHERITED
13537: 
 4577:   nsStopPluginRunnable(nsPluginInstanceOwner *aInstanceOwner)
 4577:     : mInstanceOwner(aInstanceOwner)
 4577:   {
13537:     NS_ASSERTION(aInstanceOwner, "need an owner");
13537:   }
13537: 
13537:   // nsRunnable
 4577:   NS_IMETHOD Run();
 4577: 
13537:   // nsITimerCallback
13537:   NS_IMETHOD Notify(nsITimer *timer);
13537: 
 4577: private:  
13537:   nsCOMPtr<nsITimer> mTimer;
 4577:   nsRefPtr<nsPluginInstanceOwner> mInstanceOwner;
 4577: };
 4577: 
13537: NS_IMPL_ISUPPORTS_INHERITED1(nsStopPluginRunnable, nsRunnable, nsITimerCallback)
13537: 
14123: static const char*
14123: GetMIMEType(nsIPluginInstance *aPluginInstance)
14123: {
14123:   nsCOMPtr<nsIPluginInstancePeer> peer;
14123:   aPluginInstance->GetPeer(getter_AddRefs(peer));
14123:   if (peer) {
14123:     nsMIMEType mime = NULL;
14123:     if (NS_SUCCEEDED(peer->GetMIMEType(&mime)) && mime)
14123:       return mime;
14123:   }
14123:   return "";
14123: }
14123: 
14390: static PRBool
14390: MatchPluginName(nsPluginInstanceOwner *aInstanceOwner, const char *aPluginName)
14390: {
14390:   return strncmp(aInstanceOwner->GetPluginName(),
14390:                  aPluginName,
14390:                  strlen(aPluginName)) == 0;
14390: }
14390: 
14390: static PRBool
14390: DoDelayedStop(nsPluginInstanceOwner *aInstanceOwner, PRBool aDelayedStop)
14390: {
14390:   // Don't delay stopping QuickTime (bug 425157), Flip4Mac (bug 426524).
14390:   if (aDelayedStop &&
14390:       !::MatchPluginName(aInstanceOwner, "QuickTime") &&
14390:       !::MatchPluginName(aInstanceOwner, "Flip4Mac")) {
14390:     nsCOMPtr<nsIRunnable> evt = new nsStopPluginRunnable(aInstanceOwner);
14390:     NS_DispatchToCurrentThread(evt);
14390:     return PR_TRUE;
14390:   }
14390:   return PR_FALSE;
14390: }
14390: 
 4577: static void
13300: DoStopPlugin(nsPluginInstanceOwner *aInstanceOwner, PRBool aDelayedStop)
 4577: {
    1:   nsCOMPtr<nsIPluginInstance> inst;
 4577:   aInstanceOwner->GetInstance(*getter_AddRefs(inst));
    1:   if (inst) {
    1:     nsPluginWindow *win;
 4577:     aInstanceOwner->GetWindow(win);
    1:     nsPluginNativeWindow *window = (nsPluginNativeWindow *)win;
    1:     nsCOMPtr<nsIPluginInstance> nullinst;
    1: 
    1:     PRBool doCache = PR_TRUE;
    1:     PRBool doCallSetWindowAfterDestroy = PR_FALSE;
    1: 
    1:     // first, determine if the plugin wants to be cached
 4577:     inst->GetValue(nsPluginInstanceVariable_DoCacheBool, (void *)&doCache);
    1:     if (!doCache) {
    1:       // then determine if the plugin wants Destroy to be called after
    1:       // Set Window.  This is for bug 50547.
    1:       inst->GetValue(nsPluginInstanceVariable_CallSetWindowAfterDestroyBool, 
    1:                      (void *)&doCallSetWindowAfterDestroy);
    1:       if (doCallSetWindowAfterDestroy) {
12417:         // XXXjst: ns4xPluginInstance::Destroy() is a no-op, clean
12417:         // this mess up when there are no other instance types.
    1:         inst->Stop();
    1:         inst->Destroy();
    1: 
    1:         if (window) 
    1:           window->CallSetWindow(nullinst);
    1:         else 
    1:           inst->SetWindow(nsnull);
    1:       }
    1:       else {
    1:         if (window) 
    1:           window->CallSetWindow(nullinst);
    1:         else 
    1:           inst->SetWindow(nsnull);
    1: 
14390:         if (DoDelayedStop(aInstanceOwner, aDelayedStop))
13044:           return;
13044: 
    1:         inst->Stop();
    1:         inst->Destroy();
    1:       }
    1:     }
    1:     else {
    1:       if (window) 
    1:         window->CallSetWindow(nullinst);
    1:       else 
    1:         inst->SetWindow(nsnull);
    1: 
14390:       if (DoDelayedStop(aInstanceOwner, aDelayedStop))
13044:         return;
13044: 
    1:       inst->Stop();
    1:     }
    1: 
    1:     nsCOMPtr<nsIPluginHost> pluginHost = do_GetService(kCPluginManagerCID);
    1:     if (pluginHost)
    1:       pluginHost->StopPluginInstance(inst);
    1: 
 4577:     // the frame is going away along with its widget so tell the
 4577:     // window to forget its widget too
    1:     if (window)
    1:       window->SetPluginWidget(nsnull);
    1:   }
    1: 
 4577:   aInstanceOwner->Destroy();
 4577: }
 4577: 
 4577: NS_IMETHODIMP
13537: nsStopPluginRunnable::Notify(nsITimer *aTimer)
13537: {
13537:   return Run();
13537: }
13537: 
13537: NS_IMETHODIMP
 4577: nsStopPluginRunnable::Run()
 4577: {
13537:   // InitWithCallback calls Release before AddRef so we need to hold a
13537:   // strong ref on 'this' since we fall through to this scope if it fails.
13537:   nsCOMPtr<nsITimerCallback> kungFuDeathGrip = this;
13537:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
13537:   if (appShell) {
13537:     PRUint32 currentLevel = 0;
13537:     appShell->GetEventloopNestingLevel(&currentLevel);
13537:     if (currentLevel > mInstanceOwner->GetLastEventloopNestingLevel()) {
13537:       if (!mTimer)
13537:         mTimer = do_CreateInstance("@mozilla.org/timer;1");
13537:       if (mTimer) {
13589:         // Fire 100ms timer to try to tear down this plugin as quickly as
13589:         // possible once the nesting level comes back down.
13589:         nsresult rv = mTimer->InitWithCallback(this, 100, nsITimer::TYPE_ONE_SHOT);
13537:         if (NS_SUCCEEDED(rv)) {
13537:           return rv;
13537:         }
13537:       }
13537:       NS_ERROR("Failed to setup a timer to stop the plugin later (at a safe "
13537:                "time). Stopping the plugin now, this might crash.");
13537:     }
13537:   }
13537: 
13537:   mTimer = nsnull;
13537: 
13300:   DoStopPlugin(mInstanceOwner, PR_FALSE);
 4577: 
 4577:   return NS_OK;
 4577: }
 4577: 
 4577: void
 4577: nsObjectFrame::StopPlugin()
 4577: {
14123:   PRBool delayedStop = PR_FALSE;
13537: #ifdef XP_WIN
13537:   nsCOMPtr<nsIPluginInstance> inst;
13537:   if (mInstanceOwner)
13537:     mInstanceOwner->GetInstance(*getter_AddRefs(inst));
13537:   if (inst) {
14123:     // Delayed stop for Real plugin only; see bug 420886, 426852.
14123:     const char* pluginType = ::GetMIMEType(inst);
14123:     delayedStop = strcmp(pluginType, "audio/x-pn-realaudio-plugin") == 0;
14123:   }
14123: #endif
13537:   StopPluginInternal(delayedStop);
 4577: }
 4577: 
 4577: void
 4577: nsObjectFrame::StopPluginInternal(PRBool aDelayedStop)
 4577: {
12744:   if (!mInstanceOwner) {
 4577:     return;
 4577:   }
 4577: 
12744:   // Transfer the reference to the instance owner onto the stack so
12744:   // that if we do end up re-entering this code, or if we unwind back
12744:   // here witha deleted frame (this), we can still continue to stop
12744:   // the plugin. Note that due to that, the ordering of the code in
12744:   // this function is extremely important.
12744: 
12744:   nsRefPtr<nsPluginInstanceOwner> owner;
12744:   owner.swap(mInstanceOwner);
12744: 
12744:   // Make sure that our windowless rect has been zeroed out, so if we
12744:   // get reinstantiated we'll send the right messages to the plug-in.
12744:   mWindowlessRect.Empty();
12744: 
14982:   PRBool oldVal = mPreventInstantiation;
14982:   mPreventInstantiation = PR_TRUE;
14982: 
14982:   nsWeakFrame weakFrame(this);
14982: 
12744: #ifdef XP_WIN
12744:   if (aDelayedStop) {
12744:     // If we're asked to do a delayed stop it means we're stopping the
12744:     // plugin because we're destroying the frame. In that case, tell
12744:     // the view to disown the widget (i.e. leave it up to us to
12744:     // destroy it).
12744: 
12805:     // Disown the view while we still know it's safe to do so.
12744:     nsIView *view = GetView();
12744:     if (view) {
12744:       view->DisownWidget();
12744:     }
12744:   }
12744: #endif
12744: 
12744:   // From this point on, |this| could have been deleted, so don't
12744:   // touch it!
12744:   owner->PrepareToStop(aDelayedStop);
 4577: 
13300:   DoStopPlugin(owner, aDelayedStop);
 4577: 
14982:   // If |this| is still alive, reset mPreventInstantiation.
14982:   if (weakFrame.IsAlive()) {
14982:     NS_ASSERTION(mPreventInstantiation,
14982:                  "Instantiation should still be prevented!");
14982: 
14982:     mPreventInstantiation = oldVal;
14982:   }
14982: 
 4577:   // Break relationship between frame and plugin instance owner
12744:   owner->SetOwner(nsnull);
    1: }
    1: 
    1: void
    1: nsObjectFrame::NotifyContentObjectWrapper()
    1: {
    1:   nsCOMPtr<nsIDocument> doc = mContent->GetDocument();
    1:   if (!doc)
    1:     return;
    1: 
    1:   nsIScriptGlobalObject *sgo = doc->GetScriptGlobalObject();
    1:   if (!sgo)
    1:     return;
    1: 
    1:   nsIScriptContext *scx = sgo->GetContext();
    1:   if (!scx)
    1:     return;
    1: 
    1:   JSContext *cx = (JSContext *)scx->GetNativeContext();
    1: 
    1:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
    1:   nsContentUtils::XPConnect()->
    1:     GetWrappedNativeOfNativeObject(cx, sgo->GetGlobalJSObject(), mContent,
    1:                                    NS_GET_IID(nsISupports),
    1:                                    getter_AddRefs(wrapper));
    1: 
    1:   if (!wrapper) {
13098:     // Nothing to do here if there's no wrapper for mContent. The proto
13098:     // chain will be fixed appropriately when the wrapper is created.
    1:     return;
    1:   }
    1: 
    1:   JSObject *obj = nsnull;
    1:   nsresult rv = wrapper->GetJSObject(&obj);
    1:   if (NS_FAILED(rv))
    1:     return;
    1: 
13098:   nsHTMLPluginObjElementSH::SetupProtoChain(wrapper, cx, obj);
10158: }
    1: 
    1: // static
    1: nsIObjectFrame *
    1: nsObjectFrame::GetNextObjectFrame(nsPresContext* aPresContext, nsIFrame* aRoot)
    1: {
    1:   nsIFrame* child = aRoot->GetFirstChild(nsnull);
    1: 
    1:   while (child) {
    1:     nsIObjectFrame* outFrame = nsnull;
    1:     CallQueryInterface(child, &outFrame);
    1:     if (outFrame) {
    1:       nsCOMPtr<nsIPluginInstance> pi;
    1:       outFrame->GetPluginInstance(*getter_AddRefs(pi));  // make sure we have a REAL plugin
    1:       if (pi)
    1:         return outFrame;
    1:     }
    1: 
    1:     outFrame = GetNextObjectFrame(aPresContext, child);
    1:     if (outFrame)
    1:       return outFrame;
    1:     child = child->GetNextSibling();
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsIFrame*
    1: NS_NewObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsObjectFrame(aContext);
    1: }
    1: 
    1: 
    1: // nsPluginDOMContextMenuListener class implementation
    1: 
    1: nsPluginDOMContextMenuListener::nsPluginDOMContextMenuListener()
    1: {
    1: }
    1: 
    1: nsPluginDOMContextMenuListener::~nsPluginDOMContextMenuListener()
    1: {
    1: }
    1: 
14031: NS_IMPL_ISUPPORTS3(nsPluginDOMContextMenuListener,
14031:                    nsIDOMContextMenuListener,
14031:                    nsIDOMEventListener,
14031:                    nsIEventListener)
    1: 
    1: NS_IMETHODIMP
    1: nsPluginDOMContextMenuListener::ContextMenu(nsIDOMEvent* aContextMenuEvent)
    1: {
    1:   aContextMenuEvent->PreventDefault(); // consume event
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginDOMContextMenuListener::Init(nsIContent* aContent)
    1: {
    1:   nsCOMPtr<nsIDOMEventTarget> receiver(do_QueryInterface(aContent));
    1:   if (receiver) {
    1:     receiver->AddEventListener(NS_LITERAL_STRING("contextmenu"), this, PR_TRUE);
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_ERROR_NO_INTERFACE;
    1: }
    1: 
    1: nsresult nsPluginDOMContextMenuListener::Destroy(nsIContent* aContent)
    1: {
    1:   // Unregister context menu listener
    1:   nsCOMPtr<nsIDOMEventTarget> receiver(do_QueryInterface(aContent));
    1:   if (receiver) {
    1:     receiver->RemoveEventListener(NS_LITERAL_STRING("contextmenu"), this, PR_TRUE);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //plugin instance owner
    1: 
    1: nsPluginInstanceOwner::nsPluginInstanceOwner()
    1: {
    1:   // create nsPluginNativeWindow object, it is derived from nsPluginWindow
    1:   // struct and allows to manipulate native window procedure
    1:   nsCOMPtr<nsIPluginHost> ph = do_GetService(kCPluginManagerCID);
    1:   nsCOMPtr<nsPIPluginHost> pph(do_QueryInterface(ph));
    1:   if (pph)
    1:     pph->NewPluginNativeWindow(&mPluginWindow);
    1:   else
    1:     mPluginWindow = nsnull;
    1: 
    1:   mOwner = nsnull;
    1:   mTagText = nsnull;
    1:   mContentFocused = PR_FALSE;
    1:   mWidgetVisible = PR_TRUE;
    1:   mNumCachedAttrs = 0;
    1:   mNumCachedParams = 0;
    1:   mCachedAttrParamNames = nsnull;
    1:   mCachedAttrParamValues = nsnull;
 4577:   mDestroyWidget = PR_FALSE;
12417: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsPluginInstanceOwner %p created\n", this));
    1: }
    1: 
    1: nsPluginInstanceOwner::~nsPluginInstanceOwner()
    1: {
    1:   PRInt32 cnt;
    1: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsPluginInstanceOwner %p deleted\n", this));
12417: 
    1:   // shut off the timer.
    1:   if (mPluginTimer != nsnull) {
    1:     CancelTimer();
    1:   }
    1: 
    1:   mOwner = nsnull;
    1: 
    1:   for (cnt = 0; cnt < (mNumCachedAttrs + 1 + mNumCachedParams); cnt++) {
    1:     if (mCachedAttrParamNames && mCachedAttrParamNames[cnt]) {
    1:       PR_Free(mCachedAttrParamNames[cnt]);
    1:       mCachedAttrParamNames[cnt] = nsnull;
    1:     }
    1: 
    1:     if (mCachedAttrParamValues && mCachedAttrParamValues[cnt]) {
    1:       PR_Free(mCachedAttrParamValues[cnt]);
    1:       mCachedAttrParamValues[cnt] = nsnull;
    1:     }
    1:   }
    1: 
    1:   if (mCachedAttrParamNames) {
    1:     PR_Free(mCachedAttrParamNames);
    1:     mCachedAttrParamNames = nsnull;
    1:   }
    1: 
    1:   if (mCachedAttrParamValues) {
    1:     PR_Free(mCachedAttrParamValues);
    1:     mCachedAttrParamValues = nsnull;
    1:   }
    1: 
    1:   if (mTagText) {
    1:     NS_Free(mTagText);
    1:     mTagText = nsnull;
    1:   }
    1: 
    1:   // clean up plugin native window object
    1:   nsCOMPtr<nsIPluginHost> ph = do_GetService(kCPluginManagerCID);
    1:   nsCOMPtr<nsPIPluginHost> pph(do_QueryInterface(ph));
    1:   if (pph) {
    1:     pph->DeletePluginNativeWindow(mPluginWindow);
    1:     mPluginWindow = nsnull;
    1:   }
    1: }
    1: 
    1: /*
    1:  * nsISupports Implementation
    1:  */
    1: 
    1: NS_IMPL_ADDREF(nsPluginInstanceOwner)
    1: NS_IMPL_RELEASE(nsPluginInstanceOwner)
    1: 
    1: NS_INTERFACE_MAP_BEGIN(nsPluginInstanceOwner)
    1:   NS_INTERFACE_MAP_ENTRY(nsIPluginInstanceOwner)
    1:   NS_INTERFACE_MAP_ENTRY(nsIPluginTagInfo)
    1:   NS_INTERFACE_MAP_ENTRY(nsIPluginTagInfo2)
    1: #ifdef OJI
    1:   NS_INTERFACE_MAP_ENTRY(nsIJVMPluginTagInfo)
    1: #endif
    1:   NS_INTERFACE_MAP_ENTRY(nsIEventListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMMouseMotionListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMKeyListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMFocusListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsIScrollPositionListener)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMDragListener)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMMouseListener)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIPluginInstanceOwner)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::SetInstance(nsIPluginInstance *aInstance)
    1: {
    1:   mInstance = aInstance;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetWindow(nsPluginWindow *&aWindow)
    1: {
    1:   NS_ASSERTION(mPluginWindow, "the plugin window object being returned is null");
    1:   aWindow = mPluginWindow;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetMode(nsPluginMode *aMode)
    1: {
    1:   nsCOMPtr<nsIDocument> doc;
    1:   nsresult rv = GetDocument(getter_AddRefs(doc));
    1:   nsCOMPtr<nsIPluginDocument> pDoc (do_QueryInterface(doc));
    1: 
    1:   if (pDoc) {
    1:     *aMode = nsPluginMode_Full;
    1:   } else {
    1:     *aMode = nsPluginMode_Embedded;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetAttributes(PRUint16& n,
    1:                                                      const char*const*& names,
    1:                                                      const char*const*& values)
    1: {
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   n = mNumCachedAttrs;
    1:   names  = (const char **)mCachedAttrParamNames;
    1:   values = (const char **)mCachedAttrParamValues;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetAttribute(const char* name, const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(name);
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *result = nsnull;
    1: 
    1:   for (int i = 0; i < mNumCachedAttrs; i++) {
    1:     if (0 == PL_strcasecmp(mCachedAttrParamNames[i], name)) {
    1:       *result = mCachedAttrParamValues[i];
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDOMElement(nsIDOMElement* *result)
    1: {
    1:   return CallQueryInterface(mContent, result);
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetInstance(nsIPluginInstance *&aInstance)
    1: {
    1:   NS_IF_ADDREF(aInstance = mInstance);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetURL(const char *aURL, const char *aTarget, void *aPostData, PRUint32 aPostDataLen, void *aHeadersData, 
    1:                                             PRUint32 aHeadersDataLen, PRBool isFile)
    1: {
    1:   NS_ENSURE_TRUE(mOwner,NS_ERROR_NULL_POINTER);
    1: 
 3333:   if (mContent->IsEditable()) {
 3333:     return NS_OK;
 3333:   }
 3333: 
    1:   // the container of the pres context will give us the link handler
  238:   nsCOMPtr<nsISupports> container = mOwner->PresContext()->GetContainer();
    1:   NS_ENSURE_TRUE(container,NS_ERROR_FAILURE);
    1:   nsCOMPtr<nsILinkHandler> lh = do_QueryInterface(container);
    1:   NS_ENSURE_TRUE(lh, NS_ERROR_FAILURE);
    1: 
    1:   nsAutoString  unitarget;
    1:   unitarget.AssignASCII(aTarget); // XXX could this be nonascii?
    1: 
    1:   nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
    1: 
    1:   // Create an absolute URL
    1:   nsCOMPtr<nsIURI> uri;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(uri), aURL, baseURI);
    1: 
    1:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIInputStream> postDataStream;
    1:   nsCOMPtr<nsIInputStream> headersDataStream;
    1: 
    1:   // deal with post data, either in a file or raw data, and any headers
    1:   if (aPostData) {
    1: 
    1:     rv = NS_NewPluginPostDataStream(getter_AddRefs(postDataStream), (const char *)aPostData, aPostDataLen, isFile);
    1: 
    1:     NS_ASSERTION(NS_SUCCEEDED(rv),"failed in creating plugin post data stream");
    1:     if (NS_FAILED(rv))
    1:       return rv;
    1: 
    1:     if (aHeadersData) {
    1:       rv = NS_NewPluginPostDataStream(getter_AddRefs(headersDataStream), 
    1:                                       (const char *) aHeadersData, 
    1:                                       aHeadersDataLen,
    1:                                       PR_FALSE,
    1:                                       PR_TRUE);  // last arg says we are headers, no /r/n/r/n fixup!
    1: 
    1:       NS_ASSERTION(NS_SUCCEEDED(rv),"failed in creating plugin header data stream");
    1:       if (NS_FAILED(rv))
    1:         return rv;
    1:     }
    1:   }
    1: 
    1:   PRInt32 blockPopups =
    1:     nsContentUtils::GetIntPref("privacy.popups.disable_from_plugins");
    1:   nsAutoPopupStatePusher popupStatePusher((PopupControlState)blockPopups);
    1: 
    1:   rv = lh->OnLinkClick(mContent, uri, unitarget.get(), 
    1:                        postDataStream, headersDataStream);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::ShowStatus(const char *aStatusMsg)
    1: {
    1:   nsresult  rv = NS_ERROR_FAILURE;
    1:   
    1:   rv = this->ShowStatus(NS_ConvertUTF8toUTF16(aStatusMsg).get());
    1:   
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::ShowStatus(const PRUnichar *aStatusMsg)
    1: {
    1:   nsresult  rv = NS_ERROR_FAILURE;
    1: 
    1:   if (!mOwner) {
    1:     return rv;
    1:   }
  238:   nsCOMPtr<nsISupports> cont = mOwner->PresContext()->GetContainer();
    1:   if (!cont) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellItem(do_QueryInterface(cont, &rv));
    1:   if (NS_FAILED(rv) || !docShellItem) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   rv = docShellItem->GetTreeOwner(getter_AddRefs(treeOwner));
    1:   if (NS_FAILED(rv) || !treeOwner) {
    1:     return rv;
    1:   }
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(treeOwner, &rv));
    1:   if (NS_FAILED(rv) || !browserChrome) {
    1:     return rv;
    1:   }
    1:   rv = browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_SCRIPT, 
    1:                                 aStatusMsg);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDocument(nsIDocument* *aDocument)
    1: {
    1:   if (!aDocument)
    1:     return NS_ERROR_NULL_POINTER;
    1: 
    1:   // XXX sXBL/XBL2 issue: current doc or owner doc?
    1:   // But keep in mind bug 322414 comment 33
    1:   NS_IF_ADDREF(*aDocument = mContent->GetOwnerDoc());
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::InvalidateRect(nsPluginRect *invalidRect)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
 9627:   if (mOwner && invalidRect && mWidgetVisible) {
    1:     //no reference count on view
    1:     nsIView* view = mOwner->GetView();
    1: 
    1:     if (view) {
  238:       nsPresContext* presContext = mOwner->PresContext();
    1: 
    1:       nsRect rect(presContext->DevPixelsToAppUnits(invalidRect->left),
    1:             presContext->DevPixelsToAppUnits(invalidRect->top),
    1:             presContext->DevPixelsToAppUnits(invalidRect->right - invalidRect->left),
    1:             presContext->DevPixelsToAppUnits(invalidRect->bottom - invalidRect->top));
    1: 
    1:       //set flags to not do a synchronous update, force update does the redraw
    1:       view->GetViewManager()->UpdateView(view, rect, NS_VMREFRESH_NO_SYNC);
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::InvalidateRegion(nsPluginRegion invalidRegion)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::ForceRedraw()
    1: {
13969:   NS_ENSURE_TRUE(mOwner,NS_ERROR_NULL_POINTER);
    1:   nsIView* view = mOwner->GetView();
    1:   if (view) {
    1:     return view->GetViewManager()->Composite();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetValue(nsPluginInstancePeerVariable variable, void *value)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   switch(variable) {
    1:     case nsPluginInstancePeerVariable_NetscapeWindow:
    1:     {      
    1:       if (mOwner) {
 3061: #if defined(XP_WIN) || defined(XP_OS2)
    1:         void** pvalue = (void**)value;
  238:         nsIViewManager* vm = mOwner->PresContext()->GetViewManager();
    1:         if (vm) {
    1: #if defined(XP_WIN)
    1:           // This property is provided to allow a "windowless" plugin to determine the window it is drawing
    1:           // in, so it can translate mouse coordinates it receives directly from the operating system
    1:           // to coordinates relative to itself.
    1:         
    1:           // The original code (outside this #if) returns the document's window, which is OK if the window the "windowless" plugin
    1:           // is drawing into has the same origin as the document's window, but this is not the case for "windowless" plugins inside of scrolling DIVs etc
    1: 
    1:           // To make sure "windowless" plugins always get the right origin for translating mouse coordinates, this code
    1:           // determines the window handle of the mozilla window containing the "windowless" plugin.
    1: 
    1:           // Given that this HWND may not be that of the document's window, there is a slight risk
    1:           // of confusing a plugin that is using this HWND for illicit purposes, but since the documentation
    1:           // does not suggest this HWND IS that of the document window, rather that of the window
    1:           // the plugin is drawn in, this seems like a safe fix.
    1:          
    1:           // we only attempt to get the nearest window if this really is a "windowless" plugin so as not
    1:           // to change any behaviour for the much more common windowed plugins,
    1:           // though why this method would even be being called for a windowed plugin escapes me.
    1:           if (mPluginWindow && mPluginWindow->type == nsPluginWindowType_Drawable) {
    1:               // it turns out that flash also uses this window for determining focus, and is currently
    1:               // unable to show a caret correctly if we return the enclosing window. Therefore for
    1:               // now we only return the enclosing window when there is an actual offset which
    1:               // would otherwise cause coordinates to be offset incorrectly. (i.e.
    1:               // if the enclosing window if offset from the document window)
    1:               //
    1:               // fixing both the caret and ability to interact issues for a windowless control in a non document aligned windw
    1:               // does not seem to be possible without a change to the flash plugin
    1:     
    1:               nsIWidget* win = mOwner->GetWindow();
    1:               if (win) {
    1:                 nsIView *view = nsIView::GetViewFor(win);
    1:                 NS_ASSERTION(view, "No view for widget");
    1:                 nsIView *rootView = nsnull;
    1:                 vm->GetRootView(rootView);
    1:                 NS_ASSERTION(rootView, "No root view");
    1:                 nsPoint offset = view->GetOffsetTo(rootView);
    1:       
    1:                 if (offset.x || offset.y) {
    1:                   // in the case the two windows are offset from eachother, we do go ahead and return the correct enclosing window
    1:                   // so that mouse co-ordinates are not messed up.
    1:                   *pvalue = (void*)win->GetNativeData(NS_NATIVE_WINDOW);
    1:                   if (*pvalue)
    1:                     return NS_OK;
    1:                 }
    1:               }
    1:           }
    1: #endif
    1:           // simply return the document window
    1:           nsCOMPtr<nsIWidget> widget;
    1:           rv = vm->GetWidget(getter_AddRefs(widget));            
    1:           if (widget) {
    1:             *pvalue = (void*)widget->GetNativeData(NS_NATIVE_WINDOW);
    1:           } else NS_ASSERTION(widget, "couldn't get doc's widget in getting doc's window handle");
    1:         } else NS_ASSERTION(vm, "couldn't get view manager in getting doc's window handle");
 3061: #elif defined(MOZ_WIDGET_GTK2)
 3061:         // X11 window managers want the toplevel window for WM_TRANSIENT_FOR.
 3061:         nsIWidget* win = mOwner->GetWindow();
 3061:         if (!win)
 3061:           return rv;
 3061:         GdkWindow* gdkWindow =
 3233:           static_cast<GdkWindow*>(win->GetNativeData(NS_NATIVE_WINDOW));
 3061:         if (!gdkWindow)
 3061:           return rv;
 3061:         gdkWindow = gdk_window_get_toplevel(gdkWindow);
 3233:         *static_cast<Window*>(value) = GDK_WINDOW_XID(gdkWindow);
 3061:         return NS_OK;
 3061: #endif
    1:       } else NS_ASSERTION(mOwner, "plugin owner has no owner in getting doc's window handle");
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetTagType(nsPluginTagType *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   *result = nsPluginTagType_Unknown;
    1: 
    1:   nsIAtom *atom = mContent->Tag();
    1: 
    1:   if (atom == nsGkAtoms::applet)
    1:     *result = nsPluginTagType_Applet;
    1:   else if (atom == nsGkAtoms::embed)
    1:     *result = nsPluginTagType_Embed;
    1:   else if (atom == nsGkAtoms::object)
    1:     *result = nsPluginTagType_Object;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetTagText(const char* *result)
    1: {
    1:     NS_ENSURE_ARG_POINTER(result);
    1:     if (nsnull == mTagText) {
    1:         nsresult rv;
    1:         nsCOMPtr<nsIDOMNode> node(do_QueryInterface(mContent, &rv));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsCOMPtr<nsIDocument> document;
    1:         rv = GetDocument(getter_AddRefs(document));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(document);
    1:         NS_ASSERTION(domDoc, "Need a document");
    1: 
    1:         nsCOMPtr<nsIDocumentEncoder> docEncoder(do_CreateInstance(NS_DOC_ENCODER_CONTRACTID_BASE "text/html", &rv));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:         rv = docEncoder->Init(domDoc, NS_LITERAL_STRING("text/html"), nsIDocumentEncoder::OutputEncodeBasicEntities);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsCOMPtr<nsIDOMRange> range(do_CreateInstance(kRangeCID,&rv));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         rv = range->SelectNode(node);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         docEncoder->SetRange(range);
    1:         nsString elementHTML;
    1:         rv = docEncoder->EncodeToString(elementHTML);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         mTagText = ToNewUTF8String(elementHTML);
    1:         if (!mTagText)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:     *result = mTagText;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetParameters(PRUint16& n, const char*const*& names, const char*const*& values)
    1: {
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   n = mNumCachedParams;
    1:   if (n) {
    1:     names  = (const char **)(mCachedAttrParamNames + mNumCachedAttrs + 1);
    1:     values = (const char **)(mCachedAttrParamValues + mNumCachedAttrs + 1);
    1:   } else
    1:     names = values = nsnull;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetParameter(const char* name, const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(name);
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   
    1:   nsresult rv = EnsureCachedAttrParamArrays();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *result = nsnull;
    1: 
    1:   for (int i = mNumCachedAttrs + 1; i < (mNumCachedParams + 1 + mNumCachedAttrs); i++) {
    1:     if (0 == PL_strcasecmp(mCachedAttrParamNames[i], name)) {
    1:       *result = mCachedAttrParamValues[i];
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDocumentBase(const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   nsresult rv = NS_OK;
    1:   if (mDocumentBase.IsEmpty()) {
    1:     if (!mOwner) {
    1:       *result = nsnull;
    1:       return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     nsIDocument* doc = mContent->GetOwnerDoc();
    1:     NS_ASSERTION(doc, "Must have an owner doc");
    1:     rv = doc->GetBaseURI()->GetSpec(mDocumentBase);
    1:   }
    1:   if (NS_SUCCEEDED(rv))
    1:     *result = ToNewCString(mDocumentBase);
    1:   return rv;
    1: }
    1: 
    1: static nsDataHashtable<nsDepCharHashKey, const char *> * gCharsetMap;
    1: typedef struct {
    1:     char mozName[16];
    1:     char javaName[12];
    1: } moz2javaCharset;
    1: 
    1: /* XXX If you add any strings longer than
    1:  *  {"x-mac-cyrillic",  "MacCyrillic"},
    1:  *  {"x-mac-ukrainian", "MacUkraine"},
    1:  * to the following array then you MUST update the
    1:  * sizes of the arrays in the moz2javaCharset struct
    1:  */
    1: 
    1: static const moz2javaCharset charsets[] = 
    1: {
    1:     {"windows-1252",    "Cp1252"},
    1:     {"IBM850",          "Cp850"},
    1:     {"IBM852",          "Cp852"},
    1:     {"IBM855",          "Cp855"},
    1:     {"IBM857",          "Cp857"},
    1:     {"IBM828",          "Cp862"},
    1:     {"IBM864",          "Cp864"},
    1:     {"IBM866",          "Cp866"},
    1:     {"windows-1250",    "Cp1250"},
    1:     {"windows-1251",    "Cp1251"},
    1:     {"windows-1253",    "Cp1253"},
    1:     {"windows-1254",    "Cp1254"},
    1:     {"windows-1255",    "Cp1255"},
    1:     {"windows-1256",    "Cp1256"},
    1:     {"windows-1257",    "Cp1257"},
    1:     {"windows-1258",    "Cp1258"},
    1:     {"EUC-JP",          "EUC_JP"},
    1:     {"EUC-KR",          "EUC_KR"},
    1:     {"x-euc-tw",        "EUC_TW"},
    1:     {"gb18030",         "GB18030"},
    1:     {"x-gbk",           "GBK"},
    1:     {"ISO-2022-JP",     "ISO2022JP"},
    1:     {"ISO-2022-KR",     "ISO2022KR"},
    1:     {"ISO-8859-2",      "ISO8859_2"},
    1:     {"ISO-8859-3",      "ISO8859_3"},
    1:     {"ISO-8859-4",      "ISO8859_4"},
    1:     {"ISO-8859-5",      "ISO8859_5"},
    1:     {"ISO-8859-6",      "ISO8859_6"},
    1:     {"ISO-8859-7",      "ISO8859_7"},
    1:     {"ISO-8859-8",      "ISO8859_8"},
    1:     {"ISO-8859-9",      "ISO8859_9"},
    1:     {"ISO-8859-13",     "ISO8859_13"},
    1:     {"x-johab",         "Johab"},
    1:     {"KOI8-R",          "KOI8_R"},
    1:     {"TIS-620",         "MS874"},
    1:     {"windows-936",     "MS936"},
    1:     {"x-windows-949",   "MS949"},
    1:     {"x-mac-arabic",    "MacArabic"},
    1:     {"x-mac-croatian",  "MacCroatia"},
    1:     {"x-mac-cyrillic",  "MacCyrillic"},
    1:     {"x-mac-greek",     "MacGreek"},
    1:     {"x-mac-hebrew",    "MacHebrew"},
    1:     {"x-mac-icelandic", "MacIceland"},
    1:     {"x-mac-roman",     "MacRoman"},
    1:     {"x-mac-romanian",  "MacRomania"},
    1:     {"x-mac-ukrainian", "MacUkraine"},
    1:     {"Shift_JIS",       "SJIS"},
    1:     {"TIS-620",         "TIS620"}
    1: };
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetDocumentEncoding(const char* *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   *result = nsnull;
    1: 
    1:   nsresult rv;
    1:   // XXX sXBL/XBL2 issue: current doc or owner doc?
    1:   nsCOMPtr<nsIDocument> doc;
    1:   rv = GetDocument(getter_AddRefs(doc));
    1:   NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get document");
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
    1:   const nsCString &charset = doc->GetDocumentCharacterSet();
    1: 
    1:   if (charset.IsEmpty())
    1:     return NS_OK;
    1: 
    1:   // common charsets and those not requiring conversion first
    1:   if (charset.EqualsLiteral("us-ascii")) {
    1:     *result = PL_strdup("US_ASCII");
    1:   } else if (charset.EqualsLiteral("ISO-8859-1") ||
    1:       !nsCRT::strncmp(PromiseFlatCString(charset).get(), "UTF", 3)) {
    1:     *result = ToNewCString(charset);
    1:   } else {
    1:     if (!gCharsetMap) {
    1:       const int NUM_CHARSETS = sizeof(charsets) / sizeof(moz2javaCharset);
    1:       gCharsetMap = new nsDataHashtable<nsDepCharHashKey, const char*>();
    1:       if (!gCharsetMap || !gCharsetMap->Init(NUM_CHARSETS))
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       for (PRUint16 i = 0; i < NUM_CHARSETS; i++) {
    1:         gCharsetMap->Put(charsets[i].mozName, charsets[i].javaName);
    1:       }
    1:     }
    1:     // if found mapping, return it; otherwise return original charset
    1:     const char *mapping;
    1:     *result = gCharsetMap->Get(charset.get(), &mapping) ? PL_strdup(mapping) :
    1:                                                           ToNewCString(charset);
    1:   }
    1: 
    1:   return (*result) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetAlignment(const char* *result)
    1: {
    1:   return GetAttribute("ALIGN", result);
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetWidth(PRUint32 *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   NS_ENSURE_TRUE(mPluginWindow, NS_ERROR_NULL_POINTER);
    1: 
    1:   *result = mPluginWindow->width;
    1: 
    1:   return NS_OK;
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetHeight(PRUint32 *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1: 
    1:   NS_ENSURE_TRUE(mPluginWindow, NS_ERROR_NULL_POINTER);
    1: 
    1:   *result = mPluginWindow->height;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetBorderVertSpace(PRUint32 *result)
    1: {
    1:   nsresult    rv;
    1:   const char  *vspace;
    1: 
    1:   rv = GetAttribute("VSPACE", &vspace);
    1: 
    1:   if (NS_OK == rv) {
    1:     if (*result != 0)
    1:       *result = (PRUint32)atol(vspace);
    1:     else
    1:       *result = 0;
    1:   }
    1:   else
    1:     *result = 0;
    1: 
    1:   return rv;
    1: }
    1:   
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetBorderHorizSpace(PRUint32 *result)
    1: {
    1:   nsresult    rv;
    1:   const char  *hspace;
    1: 
    1:   rv = GetAttribute("HSPACE", &hspace);
    1: 
    1:   if (NS_OK == rv) {
    1:     if (*result != 0)
    1:       *result = (PRUint32)atol(hspace);
    1:     else
    1:       *result = 0;
    1:   }
    1:   else
    1:     *result = 0;
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetUniqueID(PRUint32 *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   *result = NS_PTR_TO_INT32(mOwner);
    1:   return NS_OK;
    1: }
    1: 
    1: #ifdef OJI
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetCode(const char* *result)
    1: {
    1:   nsresult rv;
    1:   nsPluginTagType tagType;  
    1:   NS_ENSURE_SUCCESS(rv = GetTagType(&tagType), rv);
    1: 
    1:   rv = NS_ERROR_FAILURE;
    1:   if (nsPluginTagType_Object != tagType)
    1:     rv = GetAttribute("CODE", result);
    1:   if (NS_FAILED(rv))
    1:     rv = GetParameter("CODE", result);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetCodeBase(const char* *result)
    1: {
    1:   nsresult rv;
    1:   if (NS_FAILED(rv = GetAttribute("CODEBASE", result)))
    1:     rv = GetParameter("CODEBASE", result);
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetArchive(const char* *result)
    1: {
    1:   nsresult rv;
    1:   if (NS_FAILED(rv = GetAttribute("ARCHIVE", result)))
    1:     rv = GetParameter("ARCHIVE", result);
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetName(const char* *result)
    1: {
    1:   nsresult rv;
    1:   nsPluginTagType tagType;  
    1:   NS_ENSURE_SUCCESS(rv = GetTagType(&tagType), rv);
    1: 
    1:   rv = NS_ERROR_FAILURE;
    1:   if (nsPluginTagType_Object != tagType)
    1:     rv = GetAttribute("NAME", result);
    1:   if (NS_FAILED(rv))
    1:     rv = GetParameter("NAME", result);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::GetMayScript(PRBool *result)
    1: {
    1:   NS_ENSURE_ARG_POINTER(result);
    1:   nsPluginTagType tagType;  
    1:   NS_ENSURE_SUCCESS(GetTagType(&tagType), NS_ERROR_FAILURE);
    1: 
    1:   const char* unused;
    1:   if (nsPluginTagType_Object == tagType)
    1:     *result = NS_SUCCEEDED(GetParameter("MAYSCRIPT", &unused)); 
    1:   else
    1:     *result = NS_SUCCEEDED(GetAttribute("MAYSCRIPT", &unused));
    1: 
    1:   return NS_OK;
    1: }
    1: #endif /* OJI */
    1: 
    1: // Cache the attributes and/or parameters of our tag into a single set
    1: // of arrays to be compatible with 4.x. The attributes go first,
    1: // followed by a PARAM/null and then any PARAM tags. Also, hold the
    1: // cached array around for the duration of the life of the instance
    1: // because 4.x did. See bug 111008.
    1: 
    1: nsresult nsPluginInstanceOwner::EnsureCachedAttrParamArrays()
    1: {
    1:   if (mCachedAttrParamValues)
    1:     return NS_OK;
    1: 
    1:   NS_PRECONDITION(((mNumCachedAttrs + mNumCachedParams) == 0) &&
    1:                   !mCachedAttrParamNames,
    1:                   "re-cache of attrs/params not implemented! use the DOM "
    1:                   "node directy instead");
    1:   NS_ENSURE_TRUE(mOwner, NS_ERROR_NULL_POINTER);
    1: 
    1:   // first, we need to find out how much we need to allocate for our
    1:   // arrays count up attributes
    1:   mNumCachedAttrs = 0;
    1: 
    1:   PRUint32 cattrs = mContent->GetAttrCount();
    1: 
    1:   if (cattrs < 0x0000FFFF) {
    1:     // unsigned 32 bits to unsigned 16 bits conversion
 3233:     mNumCachedAttrs = static_cast<PRUint16>(cattrs);
    1:   } else {
    1:     mNumCachedAttrs = 0xFFFE;  // minus one in case we add an extra "src" entry below
    1:   }
    1: 
    1:   // now, we need to find all the PARAM tags that are children of us
    1:   // however, be carefull NOT to include any PARAMs that don't have us
    1:   // as a direct parent. For nested object (or applet) tags, be sure
    1:   // to only round up the param tags that coorespond with THIS
    1:   // instance. And also, weed out any bogus tags that may get in the
    1:   // way, see bug 39609. Then, with any param tag that meet our
    1:   // qualification, temporarly cache them in an nsCOMArray until
    1:   // we can figure out what size to make our fixed char* array.
    1: 
    1:   mNumCachedParams = 0;
    1:   nsCOMArray<nsIDOMElement> ourParams;
    1:  
    1:   // use the DOM to get us ALL our dependent PARAM tags, even if not
    1:   // ours
    1:   nsCOMPtr<nsIDOMElement> mydomElement = do_QueryInterface(mContent);
    1:   NS_ENSURE_TRUE(mydomElement, NS_ERROR_NO_INTERFACE);
    1: 
    1:   nsCOMPtr<nsIDOMNodeList> allParams; 
    1: 
    1:   nsINodeInfo *ni = mContent->NodeInfo();
    1: 
    1:   // Making DOM method calls can cause our frame to go away, which
    1:   // might kill us...
    1:   nsCOMPtr<nsIPluginInstanceOwner> kungFuDeathGrip(this);
    1:   
    1:   if (ni->NamespaceEquals(kNameSpaceID_XHTML)) {
    1:     // For XHTML elements we need to take the namespace URI into
    1:     // account when looking for param elements.
    1: 
    1:     NS_NAMED_LITERAL_STRING(xhtml_ns, "http://www.w3.org/1999/xhtml");
    1: 
    1:     mydomElement->GetElementsByTagNameNS(xhtml_ns, NS_LITERAL_STRING("param"),
    1:                                          getter_AddRefs(allParams));
    1:   } else {
    1:     // If content is not XHTML, it must be HTML, no need to worry
    1:     // about namespaces then...
    1: 
    1:     mydomElement->GetElementsByTagName(NS_LITERAL_STRING("param"),
    1:                                        getter_AddRefs(allParams));
    1:   }    
    1: 
    1:   if (allParams) {
    1:     PRUint32 numAllParams; 
    1:     allParams->GetLength(&numAllParams);
    1:     // loop through every so called dependent PARAM tag to check if it
    1:     // "belongs" to us
    1: 
    1:     for (PRUint32 i = 0; i < numAllParams; i++) {
    1:       nsCOMPtr<nsIDOMNode> pnode;
    1:       allParams->Item(i, getter_AddRefs(pnode));
    1: 
    1:       nsCOMPtr<nsIDOMElement> domelement = do_QueryInterface(pnode);
    1:       if (domelement) {
    1:         // let's NOT count up param tags that don't have a name attribute
    1:         nsAutoString name;
    1:         domelement->GetAttribute(NS_LITERAL_STRING("name"), name);
    1:         if (!name.IsEmpty()) {
    1:           nsCOMPtr<nsIDOMNode> parent;
    1:           nsCOMPtr<nsIDOMHTMLObjectElement> domobject;
    1:           nsCOMPtr<nsIDOMHTMLAppletElement> domapplet;
    1:           pnode->GetParentNode(getter_AddRefs(parent));
    1:           // walk up the parents of this PARAM until we find an object
    1:           // (or applet) tag
    1: 
    1:           while (!(domobject || domapplet) && parent) {
    1:             domobject = do_QueryInterface(parent);
    1:             domapplet = do_QueryInterface(parent);
    1:             nsCOMPtr<nsIDOMNode> temp;
    1:             parent->GetParentNode(getter_AddRefs(temp));
    1:             parent = temp;
    1:           }
    1: 
    1:           if (domapplet || domobject) {
    1:             if (domapplet)
    1:               parent = domapplet;
    1:             else
    1:               parent = domobject;
    1: 
    1:             // now check to see if this PARAM's parent is us. if so,
    1:             // cache it for later
    1: 
    1:             nsCOMPtr<nsIDOMNode> mydomNode = do_QueryInterface(mydomElement);
    1:             if (parent == mydomNode) {
    1:               ourParams.AppendObject(domelement);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // We're done with DOM method calls now; make sure we still have a frame.
    1:   NS_ENSURE_TRUE(mOwner, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   PRUint32 cparams = ourParams.Count(); // unsigned 32 bits to unsigned 16 bits conversion
    1:   if (cparams < 0x0000FFFF)
 3233:     mNumCachedParams = static_cast<PRUint16>(cparams);
    1:   else 
    1:     mNumCachedParams = 0xFFFF;
    1: 
    1:   // Some plugins were never written to understand the "data" attribute of the OBJECT tag.
    1:   // Real and WMP will not play unless they find a "src" attribute, see bug 152334.
    1:   // Nav 4.x would simply replace the "data" with "src". Because some plugins correctly
    1:   // look for "data", lets instead copy the "data" attribute and add another entry
    1:   // to the bottom of the array if there isn't already a "src" specified.
    1:   PRInt16 numRealAttrs = mNumCachedAttrs;
    1:   nsAutoString data;
    1:   if (mContent->Tag() == nsGkAtoms::object
    1:     && !mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::src)
    1:     && mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::data, data)) {
    1:       mNumCachedAttrs++;
    1:   }
    1: 
    1:   // now lets make the arrays
    1:   mCachedAttrParamNames  = (char **)PR_Calloc(sizeof(char *) * (mNumCachedAttrs + 1 + mNumCachedParams), 1);
    1:   NS_ENSURE_TRUE(mCachedAttrParamNames,  NS_ERROR_OUT_OF_MEMORY);
    1:   mCachedAttrParamValues = (char **)PR_Calloc(sizeof(char *) * (mNumCachedAttrs + 1 + mNumCachedParams), 1);
    1:   NS_ENSURE_TRUE(mCachedAttrParamValues, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // let's fill in our attributes
    1:   PRInt16 c = 0;
    1: 
    1:   // Some plugins (eg Flash, see bug 234675.) are actually sensitive to the
    1:   // attribute order.  So we want to make sure we give the plugin the
    1:   // attributes in the order they came in in the source, to be compatible with
    1:   // other browsers.  Now in HTML, the storage order is the reverse of the
    1:   // source order, while in XML and XHTML it's the same as the source order
    1:   // (see the AddAttributes functions in the HTML and XML content sinks).
    1:   PRInt16 start, end, increment;
    1:   if (mContent->IsNodeOfType(nsINode::eHTML) &&
    1:       mContent->NodeInfo()->NamespaceEquals(kNameSpaceID_None)) {
    1:     // HTML.  Walk attributes in reverse order.
    1:     start = numRealAttrs - 1;
    1:     end = -1;
    1:     increment = -1;
    1:   } else {
    1:     // XHTML or XML.  Walk attributes in forward order.
    1:     start = 0;
    1:     end = numRealAttrs;
    1:     increment = 1;
    1:   }
    1:   for (PRInt16 index = start; index != end; index += increment) {
    1:     const nsAttrName* attrName = mContent->GetAttrNameAt(index);
    1:     nsIAtom* atom = attrName->LocalName();
    1:     nsAutoString value;
    1:     mContent->GetAttr(attrName->NamespaceID(), atom, value);
    1:     nsAutoString name;
    1:     atom->ToString(name);
    1: 
    1:     FixUpURLS(name, value);
    1: 
    1:     mCachedAttrParamNames [c] = ToNewUTF8String(name);
    1:     mCachedAttrParamValues[c] = ToNewUTF8String(value);
    1:     c++;
    1:   }
    1: 
    1:   // if the conditions above were met, copy the "data" attribute to a "src" array entry
    1:   if (data.Length()) {
    1:     mCachedAttrParamNames [mNumCachedAttrs-1] = ToNewUTF8String(NS_LITERAL_STRING("SRC"));
    1:     mCachedAttrParamValues[mNumCachedAttrs-1] = ToNewUTF8String(data);
    1:   }
    1: 
    1:   // add our PARAM and null separator
    1:   mCachedAttrParamNames [mNumCachedAttrs] = ToNewUTF8String(NS_LITERAL_STRING("PARAM"));
    1:   mCachedAttrParamValues[mNumCachedAttrs] = nsnull;
    1: 
    1:   // now fill in the PARAM name/value pairs from the cached DOM nodes
    1:   c = 0;
    1:   for (PRInt16 idx = 0; idx < mNumCachedParams; idx++) {
    1:     nsIDOMElement* param = ourParams.ObjectAt(idx);
    1:     if (param) {
    1:      nsAutoString name;
    1:      nsAutoString value;
    1:      param->GetAttribute(NS_LITERAL_STRING("name"), name); // check for empty done above
    1:      param->GetAttribute(NS_LITERAL_STRING("value"), value);
    1: 
    1:      FixUpURLS(name, value);
    1: 
    1:      /*
    1:       * According to the HTML 4.01 spec, at
    1:       * http://www.w3.org/TR/html4/types.html#type-cdata
    1:       * ''User agents may ignore leading and trailing
    1:       * white space in CDATA attribute values (e.g., "
    1:       * myval " may be interpreted as "myval"). Authors
    1:       * should not declare attribute values with
    1:       * leading or trailing white space.''
    1:       * However, do not trim consecutive spaces as in bug 122119
    1:       */            
    1:      name.Trim(" \n\r\t\b", PR_TRUE, PR_TRUE, PR_FALSE);
    1:      value.Trim(" \n\r\t\b", PR_TRUE, PR_TRUE, PR_FALSE);
    1:      mCachedAttrParamNames [mNumCachedAttrs + 1 + c] = ToNewUTF8String(name);
    1:      mCachedAttrParamValues[mNumCachedAttrs + 1 + c] = ToNewUTF8String(value);
    1:      c++;                                                      // rules!
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // Here's where we forward events to plugins.
    1: 
    1: #ifdef XP_MACOSX
    1: 
    1: static void InitializeEventRecord(EventRecord* event)
    1: {
    1:     memset(event, 0, sizeof(EventRecord));
    1:     ::GetGlobalMouse(&event->where);
    1:     event->when = ::TickCount();
12558:     event->modifiers = ::GetCurrentEventKeyModifiers();
    1: }
    1: 
  130: NPDrawingModel nsPluginInstanceOwner::GetDrawingModel()
  130: {
  130: #ifndef NP_NO_QUICKDRAW
  130:   NPDrawingModel drawingModel = NPDrawingModelQuickDraw;
  130: #else
  130:   NPDrawingModel drawingModel = NPDrawingModelCoreGraphics;
  130: #endif
  130: 
  130:   if (!mInstance)
  130:     return drawingModel;
  130: 
  130:   mInstance->GetValue(nsPluginInstanceVariable_DrawingModel,
  130:                       (void *)&drawingModel);
  130: 
  130:   return drawingModel;
  130: }
  130: 
    1: void nsPluginInstanceOwner::GUItoMacEvent(const nsGUIEvent& anEvent, EventRecord* origEvent, EventRecord& aMacEvent)
    1: {
  238:   nsPresContext* presContext = mOwner ? mOwner->PresContext() : nsnull;
    1:   InitializeEventRecord(&aMacEvent);
    1:   switch (anEvent.message) {
    1:     case NS_FOCUS_EVENT_START:   // this is the same as NS_FOCUS_CONTENT
    1:         aMacEvent.what = nsPluginEventType_GetFocusEvent;
    1:         if (presContext) {
    1:             nsIContent* content = mContent;
    1:             if (content)
    1:                 content->SetFocus(presContext);
    1:         }
    1:         break;
    1: 
    1:     case NS_BLUR_CONTENT:
    1:         aMacEvent.what = nsPluginEventType_LoseFocusEvent;
    1:         if (presContext) {
    1:             nsIContent* content = mContent;
    1:             if (content)
    1:                 content->RemoveFocus(presContext);
    1:         }
    1:         break;
    1: 
    1:     case NS_MOUSE_MOVE:
    1:     case NS_MOUSE_ENTER:
    1:         if (origEvent)
    1:           aMacEvent = *origEvent;
    1:         aMacEvent.what = nsPluginEventType_AdjustCursorEvent;
    1:         break;
    1:   }
    1: }
    1: 
    1: #endif
    1: 
    1: nsresult nsPluginInstanceOwner::ScrollPositionWillChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY)
    1: {
    1: #ifdef XP_MACOSX
    1:     CancelTimer();
    1: 
    1:     if (mInstance) {
    1:         nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:         if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
    1:             EventRecord scrollEvent;
    1:             InitializeEventRecord(&scrollEvent);
    1:             scrollEvent.what = nsPluginEventType_ScrollingBeginsEvent;
    1:     
  130:             WindowRef window = FixUpPluginWindow(ePluginPaintDisable);
  130:             if (window) {
  130:               nsPluginEvent pluginEvent = { &scrollEvent, nsPluginPlatformWindowRef(window) };
    1:               PRBool eventHandled = PR_FALSE;
    1:               mInstance->HandleEvent(&pluginEvent, &eventHandled);
    1:             }
    1:             pluginWidget->EndDrawPlugin();
    1:         }
    1:     }
    1: #endif
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::ScrollPositionDidChange(nsIScrollableView* aScrollable, nscoord aX, nscoord aY)
    1: {
    1: #ifdef XP_MACOSX
    1:     if (mInstance) {
    1:       nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:       if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
    1:         EventRecord scrollEvent;
    1:         InitializeEventRecord(&scrollEvent);
    1:         scrollEvent.what = nsPluginEventType_ScrollingEndsEvent;
    1:   
  130:         WindowRef window = FixUpPluginWindow(ePluginPaintEnable);
  130:         if (window) {
  130:           nsPluginEvent pluginEvent = { &scrollEvent, nsPluginPlatformWindowRef(window) };
    1:           PRBool eventHandled = PR_FALSE;
    1:           mInstance->HandleEvent(&pluginEvent, &eventHandled);
    1:         }
    1:         pluginWidget->EndDrawPlugin();
    1:       }
    1: 
    1:       // FIXME - Only invalidate the newly revealed amount.
    1:       // XXX necessary?
    1:       if (mWidget)
15444:         mWidget->Invalidate(PR_FALSE);
    1:     }
    1: #endif
    1: 
    1:     StartTimer(NORMAL_PLUGIN_DELAY);
    1:     return NS_OK;
    1: }
    1: 
    1: /*=============== nsIFocusListener ======================*/
    1: nsresult nsPluginInstanceOwner::Focus(nsIDOMEvent * aFocusEvent)
    1: {
    1:   mContentFocused = PR_TRUE;
    1:   return DispatchFocusToPlugin(aFocusEvent);
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::Blur(nsIDOMEvent * aFocusEvent)
    1: {
    1:   mContentFocused = PR_FALSE;
    1:   return DispatchFocusToPlugin(aFocusEvent);
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DispatchFocusToPlugin(nsIDOMEvent* aFocusEvent)
    1: {
    1: #ifndef XP_MACOSX
    1:   if (!mPluginWindow || nsPluginWindowType_Window == mPluginWindow->type) {
    1:     // continue only for cases without child window
    1:     return aFocusEvent->PreventDefault(); // consume event
    1:   }
    1: #endif
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aFocusEvent));
    1:   if (privateEvent) {
    1:     nsEvent * theEvent;
    1:     privateEvent->GetInternalNSEvent(&theEvent);
    1:     if (theEvent) {
    1:       // we only care about the message in ProcessEvent
    1:       nsGUIEvent focusEvent(NS_IS_TRUSTED_EVENT(theEvent), theEvent->message,
    1:                             nsnull);
    1:       nsEventStatus rv = ProcessEvent(focusEvent);
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         aFocusEvent->PreventDefault();
    1:         aFocusEvent->StopPropagation();
    1:       }
    1:     }
    1:     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchFocusToPlugin failed, focusEvent null");   
    1:   }
    1:   else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchFocusToPlugin failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }    
    1: 
    1: /*=============== nsIDOMDragListener ======================*/
    1: nsresult nsPluginInstanceOwner::DragEnter(nsIDOMEvent* aMouseEvent)
    1: {
    1:   if (mInstance) {
    1:     // Let the plugin handle drag events.
    1:     aMouseEvent->PreventDefault();
    1:     aMouseEvent->StopPropagation();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DragOver(nsIDOMEvent* aMouseEvent)
    1: {
    1:   if (mInstance) {
    1:     // Let the plugin handle drag events.
    1:     aMouseEvent->PreventDefault();
    1:     aMouseEvent->StopPropagation();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DragExit(nsIDOMEvent* aMouseEvent)
    1: {
    1:   if (mInstance) {
    1:     // Let the plugin handle drag events.
    1:     aMouseEvent->PreventDefault();
    1:     aMouseEvent->StopPropagation();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DragDrop(nsIDOMEvent* aMouseEvent)
    1: {
    1:   if (mInstance) {
    1:     // Let the plugin handle drag events.
    1:     aMouseEvent->PreventDefault();
    1:     aMouseEvent->StopPropagation();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DragGesture(nsIDOMEvent* aMouseEvent)
    1: {
    1:   if (mInstance) {
    1:     // Let the plugin handle drag events.
    1:     aMouseEvent->PreventDefault();
    1:     aMouseEvent->StopPropagation();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
  482: nsresult nsPluginInstanceOwner::Drag(nsIDOMEvent* aMouseEvent)
  482: {
  482:   if (mInstance) {
  482:     // Let the plugin handle drag events.
  482:     aMouseEvent->PreventDefault();
  482:     aMouseEvent->StopPropagation();
  482:   }
  482: 
  482:   return NS_OK;
  482: }
  482: 
  482: nsresult nsPluginInstanceOwner::DragEnd(nsIDOMEvent* aMouseEvent)
  482: {
  482:   if (mInstance) {
  482:     // Let the plugin handle drag events.
  482:     aMouseEvent->PreventDefault();
  482:     aMouseEvent->StopPropagation();
  482:   }
  482: 
  482:   return NS_OK;
  482: }
  482: 
    1: 
    1: 
    1: /*=============== nsIKeyListener ======================*/
    1: nsresult nsPluginInstanceOwner::KeyDown(nsIDOMEvent* aKeyEvent)
    1: {
    1:   return DispatchKeyToPlugin(aKeyEvent);
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::KeyUp(nsIDOMEvent* aKeyEvent)
    1: {
    1:   return DispatchKeyToPlugin(aKeyEvent);
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::KeyPress(nsIDOMEvent* aKeyEvent)
    1: {
    1: #ifdef XP_MACOSX // send KeyPress events only on Mac
    1: 
    1:   // KeyPress events are really synthesized keyDown events.
    1:   // Here we check the native message of the event so that
    1:   // we won't send the plugin two keyDown events.
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aKeyEvent));
    1:   if (privateEvent) {
    1:     nsEvent *theEvent;
    1:     privateEvent->GetInternalNSEvent(&theEvent);
    1:     const nsGUIEvent *guiEvent = (nsGUIEvent*)theEvent;
    1:     const EventRecord *ev = (EventRecord*)(guiEvent->nativeMsg); 
    1:     if (guiEvent &&
    1:         guiEvent->message == NS_KEY_PRESS &&
    1:         ev &&
    1:         ev->what == keyDown)
    1:       return aKeyEvent->PreventDefault(); // consume event
    1:   }
    1: 
    1:   // Nasty hack to avoid recursive event dispatching with Java. Java can
    1:   // dispatch key events to a TSM handler, which comes back and calls 
    1:   // [ChildView insertText:] on the cocoa widget, which sends a key
    1:   // event back down.
    1:   static PRBool sInKeyDispatch = PR_FALSE;
    1:   
    1:   if (sInKeyDispatch)
    1:     return aKeyEvent->PreventDefault(); // consume event
    1: 
    1:   sInKeyDispatch = PR_TRUE;
    1:   nsresult rv =  DispatchKeyToPlugin(aKeyEvent);
    1:   sInKeyDispatch = PR_FALSE;
    1:   return rv;
    1: #else
    1:   if (mInstance) {
    1:     // If this event is going to the plugin, we want to kill it.
    1:     // Not actually sending keypress to the plugin, since we didn't before.
    1:     aKeyEvent->PreventDefault();
    1:     aKeyEvent->StopPropagation();
    1:   }
    1:   return NS_OK;
    1: #endif
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DispatchKeyToPlugin(nsIDOMEvent* aKeyEvent)
    1: {
    1: #ifndef XP_MACOSX
    1:   if (!mPluginWindow || nsPluginWindowType_Window == mPluginWindow->type)
    1:     return aKeyEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
    1: 
    1:   if (mInstance) {
    1:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aKeyEvent));
    1:     if (privateEvent) {
    1:       nsKeyEvent* keyEvent = nsnull;
    1:       privateEvent->GetInternalNSEvent((nsEvent**)&keyEvent);
    1:       if (keyEvent) {
    1:         nsEventStatus rv = ProcessEvent(*keyEvent);
    1:         if (nsEventStatus_eConsumeNoDefault == rv) {
    1:           aKeyEvent->PreventDefault();
    1:           aKeyEvent->StopPropagation();
    1:         }
    1:       }
    1:       else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchKeyToPlugin failed, keyEvent null");   
    1:     }
    1:     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchKeyToPlugin failed, privateEvent null");   
    1:   }
    1: 
    1:   return NS_OK;
    1: }    
    1: 
    1: /*=============== nsIMouseMotionListener ======================*/
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseMove(nsIDOMEvent* aMouseEvent)
    1: {
    1: #if !defined(XP_MACOSX)
    1:   if (!mPluginWindow || nsPluginWindowType_Window == mPluginWindow->type)
    1:     return aMouseEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
    1: 
    1:   // don't send mouse events if we are hiddden
    1:   if (!mWidgetVisible)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aMouseEvent));
    1:   if (privateEvent) {
    1:     nsMouseEvent* mouseEvent = nsnull;
    1:     privateEvent->GetInternalNSEvent((nsEvent**)&mouseEvent);
    1:     if (mouseEvent) {
    1:       nsEventStatus rv = ProcessEvent(*mouseEvent);
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         return aMouseEvent->PreventDefault(); // consume event
    1:       }
    1:     }
    1:     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::MouseMove failed, mouseEvent null");   
    1:   }
    1:   else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::MouseMove failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: /*=============== nsIMouseListener ======================*/
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseDown(nsIDOMEvent* aMouseEvent)
    1: {
    1: #if !defined(XP_MACOSX)
    1:   if (!mPluginWindow || nsPluginWindowType_Window == mPluginWindow->type)
    1:     return aMouseEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
    1: 
    1:   // if the plugin is windowless, we need to set focus ourselves
    1:   // otherwise, we might not get key events
    1:   if (mOwner && mPluginWindow &&
    1:       mPluginWindow->type == nsPluginWindowType_Drawable) {
  238:     mContent->SetFocus(mOwner->PresContext());
    1:   }
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aMouseEvent));
    1:   if (privateEvent) {
    1:     nsMouseEvent* mouseEvent = nsnull;
    1:     privateEvent->GetInternalNSEvent((nsEvent**)&mouseEvent);
    1:     if (mouseEvent) {
    1:       nsEventStatus rv = ProcessEvent(*mouseEvent);
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         return aMouseEvent->PreventDefault(); // consume event
    1:       }
    1:     }
    1:     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::MouseDown failed, mouseEvent null");   
    1:   }
    1:   else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::MouseDown failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseUp(nsIDOMEvent* aMouseEvent)
    1: {
    1:   return DispatchMouseToPlugin(aMouseEvent);
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseClick(nsIDOMEvent* aMouseEvent)
    1: {
    1:   return DispatchMouseToPlugin(aMouseEvent);
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseDblClick(nsIDOMEvent* aMouseEvent)
    1: {
    1:   return DispatchMouseToPlugin(aMouseEvent);
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseOver(nsIDOMEvent* aMouseEvent)
    1: {
    1:   return DispatchMouseToPlugin(aMouseEvent);
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::MouseOut(nsIDOMEvent* aMouseEvent)
    1: {
    1:   return DispatchMouseToPlugin(aMouseEvent);
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::DispatchMouseToPlugin(nsIDOMEvent* aMouseEvent)
    1: {
    1: #if !defined(XP_MACOSX)
    1:   if (!mPluginWindow || nsPluginWindowType_Window == mPluginWindow->type)
    1:     return aMouseEvent->PreventDefault(); // consume event
    1:   // continue only for cases without child window
    1: #endif
    1: 
    1:   // don't send mouse events if we are hiddden
    1:   if (!mWidgetVisible)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(aMouseEvent));
    1:   if (privateEvent) {
    1:     nsMouseEvent* mouseEvent = nsnull;
    1:     privateEvent->GetInternalNSEvent((nsEvent**)&mouseEvent);
    1:     if (mouseEvent) {
    1:       nsEventStatus rv = ProcessEvent(*mouseEvent);
    1:       if (nsEventStatus_eConsumeNoDefault == rv) {
    1:         aMouseEvent->PreventDefault();
    1:         aMouseEvent->StopPropagation();
    1:       }
    1:     }
    1:     else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchMouseToPlugin failed, mouseEvent null");   
    1:   }
    1:   else NS_ASSERTION(PR_FALSE, "nsPluginInstanceOwner::DispatchMouseToPlugin failed, privateEvent null");   
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::HandleEvent(nsIDOMEvent* aEvent)
    1: {
    1:   return NS_OK;
    1: }
    1: 
 3060: #ifdef MOZ_X11
 3060: static unsigned int XInputEventState(const nsInputEvent& anEvent)
 3060: {
 3060:   unsigned int state = 0;
 3060:   if(anEvent.isShift) state |= ShiftMask;
 3060:   if(anEvent.isControl) state |= ControlMask;
 3060:   if(anEvent.isAlt) state |= Mod1Mask;
 3060:   if(anEvent.isMeta) state |= Mod4Mask;
 3060:   return state;
 3060: }
 3060: #endif
    1: 
    1: nsEventStatus nsPluginInstanceOwner::ProcessEvent(const nsGUIEvent& anEvent)
    1: {
    1:   // printf("nsGUIEvent.message: %d\n", anEvent.message);
    1:   nsEventStatus rv = nsEventStatus_eIgnore;
 3060:   if (!mInstance || !mOwner)   // if mInstance is null, we shouldn't be here
    1:     return rv;
    1: 
    1: #ifdef XP_MACOSX
    1:   // check for null mWidget
    1:   if (mWidget) {
    1:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:     if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
    1:       EventRecord macEvent;
    1:       EventRecord* event = (EventRecord*)anEvent.nativeMsg;
    1:       if ((event == NULL) || (event->what == nullEvent)  || 
    1:           (anEvent.message == NS_FOCUS_CONTENT)          || 
    1:           (anEvent.message == NS_BLUR_CONTENT)           || 
    1:           (anEvent.message == NS_MOUSE_MOVE)             ||
    1:           (anEvent.message == NS_MOUSE_ENTER)) {
    1:         GUItoMacEvent(anEvent, event, macEvent);
    1:         event = &macEvent;
    1:       }
    1: 
  130:       if (anEvent.message == NS_FOCUS_CONTENT) {
    1:         // Work around an issue in the Flash plugin, which can cache a pointer
    1:         // to a doomed TSM document (one that belongs to a NSTSMInputContext)
    1:         // and try to activate it after it has been deleted. See bug 183313.
    1:         ::DeactivateTSMDocument(::TSMGetActiveDocument());
    1:       }
  130: 
    1:       PRBool eventHandled = PR_FALSE;
  130:       WindowRef window = FixUpPluginWindow(ePluginPaintIgnore);
  130:       if (window) {
  130:         nsPluginEvent pluginEvent = { event, nsPluginPlatformWindowRef(window) };
    1:         mInstance->HandleEvent(&pluginEvent, &eventHandled);
    1:       }
    1: 
    1:       if (eventHandled && !(anEvent.eventStructType == NS_MOUSE_EVENT &&
    1:                             anEvent.message == NS_MOUSE_BUTTON_DOWN &&
 3233:                             static_cast<const nsMouseEvent&>(anEvent).button ==
    1:                               nsMouseEvent::eLeftButton &&
    1:                             !mContentFocused))
    1:         rv = nsEventStatus_eConsumeNoDefault;
    1: 
    1:       pluginWidget->EndDrawPlugin();
    1:     }
    1:   }
    1: #endif
    1: 
    1: #ifdef XP_WIN
    1:   // this code supports windowless plugins
    1:   nsPluginEvent * pPluginEvent = (nsPluginEvent *)anEvent.nativeMsg;
    1:   // we can get synthetic events from the nsEventStateManager... these
    1:   // have no nativeMsg
    1:   nsPluginEvent pluginEvent;
    1:   if (!pPluginEvent) {
    1:     switch (anEvent.message) {
    1:       case NS_FOCUS_CONTENT:
    1:         pluginEvent.event = WM_SETFOCUS;
    1:         pluginEvent.wParam = 0;
    1:         pluginEvent.lParam = 0;
    1:         pPluginEvent = &pluginEvent;
    1:         break;
    1:       case NS_BLUR_CONTENT:
    1:         pluginEvent.event = WM_KILLFOCUS;
    1:         pluginEvent.wParam = 0;
    1:         pluginEvent.lParam = 0;
    1:         pPluginEvent = &pluginEvent;
    1:         break;
    1:     }
    1:   }
    1: 
    1:   if (pPluginEvent) {
    1:     PRBool eventHandled = PR_FALSE;
    1:     mInstance->HandleEvent(pPluginEvent, &eventHandled);
    1:     if (eventHandled)
    1:       rv = nsEventStatus_eConsumeNoDefault;
    1:   }
    1: #endif
    1: 
 3060: #ifdef MOZ_X11
 3060:   // this code supports windowless plugins
 3060:   nsIWidget* widget = anEvent.widget;
 3060:   nsPluginEvent pluginEvent;
 3060:   pluginEvent.event.type = 0;
 3060: 
 3060:   switch(anEvent.eventStructType)
 3060:     {
 3060:     case NS_MOUSE_EVENT:
 3060:       {
 3060:         switch (anEvent.message)
 3060:           {
 3060:           case NS_MOUSE_CLICK:
 3060:           case NS_MOUSE_DOUBLECLICK:
 3060:             // Button up/down events sent instead.
 3060:             return rv;
 3060:           }
 3060: 
 3060:         // Get reference point relative to plugin origin.
 3060:         const nsPresContext* presContext = mOwner->PresContext();
 3060:         nsPoint appPoint =
 3060:           nsLayoutUtils::GetEventCoordinatesRelativeTo(&anEvent, mOwner); 
 3060:         nsIntPoint pluginPoint(presContext->AppUnitsToDevPixels(appPoint.x),
 3060:                                presContext->AppUnitsToDevPixels(appPoint.y));
 3060:         const nsMouseEvent& mouseEvent =
 3233:           static_cast<const nsMouseEvent&>(anEvent);
 3060:         // Get reference point relative to screen:
 3060:         nsRect windowRect(anEvent.refPoint, nsSize(1, 1));
 3060:         nsRect rootPoint(-1,-1,1,1);
 3060:         if (widget)
 3060:           widget->WidgetToScreen(windowRect, rootPoint);
 3060: #ifdef MOZ_WIDGET_GTK2
 3060:         Window root = GDK_ROOT_WINDOW();
 3060: #else
 3060:         Window root = None; // Could XQueryTree, but this is not important.
 3060: #endif
 3060: 
 3060:         switch (anEvent.message)
 3060:           {
 3060:           case NS_MOUSE_ENTER_SYNTH:
 3060:           case NS_MOUSE_EXIT_SYNTH:
 3060:             {
 3060:               XCrossingEvent& event = pluginEvent.event.xcrossing;
 3060:               event.type = anEvent.message == NS_MOUSE_ENTER_SYNTH ?
 3060:                 EnterNotify : LeaveNotify;
 3060:               event.root = root;
 3060:               event.time = anEvent.time;
 3060:               event.x = pluginPoint.x;
 3060:               event.y = pluginPoint.y;
 3060:               event.x_root = rootPoint.x;
 3060:               event.y_root = rootPoint.y;
 3060:               event.state = XInputEventState(mouseEvent);
 3060:               // information lost
 3060:               event.subwindow = None;
 3060:               event.mode = -1;
 3060:               event.detail = NotifyDetailNone;
 3060:               event.same_screen = True;
 3060:               event.focus = mContentFocused;
 3060:             }
 3060:             break;
 3060:           case NS_MOUSE_MOVE:
 3060:             {
 3060:               XMotionEvent& event = pluginEvent.event.xmotion;
 3060:               event.type = MotionNotify;
 3060:               event.root = root;
 3060:               event.time = anEvent.time;
 3060:               event.x = pluginPoint.x;
 3060:               event.y = pluginPoint.y;
 3060:               event.x_root = rootPoint.x;
 3060:               event.y_root = rootPoint.y;
 3060:               event.state = XInputEventState(mouseEvent);
 3060:               // information lost
 3060:               event.subwindow = None;
 3060:               event.is_hint = NotifyNormal;
 3060:               event.same_screen = True;
 3060:             }
 3060:             break;
 3060:           case NS_MOUSE_BUTTON_DOWN:
 3060:           case NS_MOUSE_BUTTON_UP:
 3060:             {
 3060:               XButtonEvent& event = pluginEvent.event.xbutton;
 3060:               event.type = anEvent.message == NS_MOUSE_BUTTON_DOWN ?
 3060:                 ButtonPress : ButtonRelease;
 3060:               event.root = root;
 3060:               event.time = anEvent.time;
 3060:               event.x = pluginPoint.x;
 3060:               event.y = pluginPoint.y;
 3060:               event.x_root = rootPoint.x;
 3060:               event.y_root = rootPoint.y;
 3060:               event.state = XInputEventState(mouseEvent);
 3060:               switch (mouseEvent.button)
 3060:                 {
 3060:                 case nsMouseEvent::eMiddleButton:
 3060:                   event.button = 2;
 3060:                   break;
 3060:                 case nsMouseEvent::eRightButton:
 3060:                   event.button = 3;
 3060:                   break;
 3060:                 default: // nsMouseEvent::eLeftButton;
 3060:                   event.button = 1;
 3060:                   break;
 3060:                 }
 3060:               // information lost:
 3060:               event.subwindow = None;
 3060:               event.same_screen = True;
 3060:             }
 3060:             break;
 3060:           }
 3060:       }
 3060:       break;
 3060: 
 3060:    //XXX case NS_MOUSE_SCROLL_EVENT: not received.
 3060:  
 3060:    case NS_KEY_EVENT:
 3060:       if (anEvent.nativeMsg)
 3060:         {
 3060:           XKeyEvent &event = pluginEvent.event.xkey;
 3060: #ifdef MOZ_WIDGET_GTK2
 3060:           event.root = GDK_ROOT_WINDOW();
 3060:           event.time = anEvent.time;
 3060:           const GdkEventKey* gdkEvent =
 3233:             static_cast<const GdkEventKey*>(anEvent.nativeMsg);
 3060:           event.keycode = gdkEvent->hardware_keycode;
 3060:           event.state = gdkEvent->state;
 3060:           switch (anEvent.message)
 3060:             {
 3060:             case NS_KEY_DOWN:
 3060:               event.type = XKeyPress;
 3060:               break;
 3060:             case NS_KEY_UP:
 3060:               event.type = KeyRelease;
 3060:               break;
 3060:             }
 3060: #endif
 3060:           // Information that could be obtained from nativeMsg but we may not
 3060:           // want to promise to provide:
 3060:           event.subwindow = None;
 3060:           event.x = 0;
 3060:           event.y = 0;
 3060:           event.x_root = -1;
 3060:           event.y_root = -1;
 3060:           event.same_screen = False;
 3060:         }
 3060:       else
 3060:         {
 3060:           // If we need to send synthesized key events, then
 3060:           // DOMKeyCodeToGdkKeyCode(keyEvent.keyCode) and
 3060:           // gdk_keymap_get_entries_for_keyval will be useful, but the
 3060:           // mappings will not be unique.
 3060:           NS_WARNING("Synthesized key event not sent to plugin");
 3060:         }
 3060:       break;
 3060: 
 3060:     default: 
 3060:       switch (anEvent.message)
 3060:         {
 3060:         case NS_FOCUS_CONTENT:
 3060:         case NS_BLUR_CONTENT:
 3060:           {
 3060:             XFocusChangeEvent &event = pluginEvent.event.xfocus;
 3060:             event.type =
 3060:               anEvent.message == NS_FOCUS_CONTENT ? FocusIn : FocusOut;
 3060:             // information lost:
 3060:             event.mode = -1;
 3060:             event.detail = NotifyDetailNone;
 3060:           }
 3060:           break;
 3060:         }
 3060:     }
 3060: 
 3060:   if (!pluginEvent.event.type) {
 3060:     PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
 3060:            ("Unhandled event message %d with struct type %d\n",
 3060:             anEvent.message, anEvent.eventStructType));
 3060:     return rv;
 3060:   }
 3060: 
 3060:   // Fill in (useless) generic event information.
 3060:   XAnyEvent& event = pluginEvent.event.xany;
 3060:   event.display = widget ?
 3233:     static_cast<Display*>(widget->GetNativeData(NS_NATIVE_DISPLAY)) : nsnull;
 3060:   event.window = None; // not a real window
 3060:   // information lost:
 3060:   event.serial = 0;
 3060:   event.send_event = False;
 3060: 
 3060:   PRBool eventHandled = PR_FALSE;
 3060:   mInstance->HandleEvent(&pluginEvent, &eventHandled);
 3060:   if (eventHandled)
 3060:       rv = nsEventStatus_eConsumeNoDefault;
 3060: #endif
 3060: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsPluginInstanceOwner::Destroy()
    1: {
    1:   // stop the timer explicitly to reduce reference count.
    1:   CancelTimer();
    1: 
    1:   // unregister context menu listener
    1:   if (mCXMenuListener) {
    1:     mCXMenuListener->Destroy(mContent);
12417:     mCXMenuListener = nsnull;
    1:   }
    1: 
 1418:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mContent));
 1418:   if (target) {
    1: 
    1:     nsCOMPtr<nsIDOMEventListener> listener;
    1:     QueryInterface(NS_GET_IID(nsIDOMEventListener), getter_AddRefs(listener));
    1: 
    1:     // Unregister focus event listener
 1418:     mContent->RemoveEventListenerByIID(listener, NS_GET_IID(nsIDOMFocusListener));
    1: 
    1:     // Unregister mouse event listener
 1418:     mContent->RemoveEventListenerByIID(listener, NS_GET_IID(nsIDOMMouseListener));
    1: 
    1:     // now for the mouse motion listener
 1418:     mContent->RemoveEventListenerByIID(listener, NS_GET_IID(nsIDOMMouseMotionListener));
    1: 
    1:     // Unregister key event listener;
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("keypress"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("keydown"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("keyup"), listener, PR_TRUE);
    1: 
    1:     // Unregister drag event listener;
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
 1418:     target->RemoveEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
    1:   }
    1: 
14641:   if (mWidget) {
14641:     nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
14641:     if (pluginWidget)
14641:       pluginWidget->SetPluginInstanceOwner(nsnull);
14641: 
14641:     if (mDestroyWidget)
 4577:       mWidget->Destroy();
 4577:   }
 4577: 
 4577:   return NS_OK;
 4577: }
 4577: 
 4577: /*
 4577:  * Prepare to stop 
 4577:  */
 4577: void
 4577: nsPluginInstanceOwner::PrepareToStop(PRBool aDelayedStop)
 4577: {
 4577: #ifdef XP_WIN
 7779:   if (aDelayedStop && mWidget) {
 4577:     // To delay stopping a plugin we need to reparent the plugin
 4577:     // so that we can safely tear down the
 4577:     // plugin after its frame (and view) is gone.
 4577: 
 4577:     // Also hide and disable the widget to avoid it from appearing in
 4577:     // odd places after reparenting it, but before it gets destroyed.
 4577:     mWidget->Show(PR_FALSE);
 4577:     mWidget->Enable(PR_FALSE);
 4577: 
 4577:     // Reparent the plugins native window. This relies on the widget
 4577:     // and plugin et al not holding any other references to its
 4577:     // parent.
 4577:     mWidget->SetParent(nsnull);
 4577: 
 4577:     mDestroyWidget = PR_TRUE;
 4577:   }
 4577: #endif
 4577: 
    1:   // Unregister scroll position listener
    1:   nsIFrame* parentWithView = mOwner->GetAncestorWithView();
    1:   nsIView* curView = parentWithView ? parentWithView->GetView() : nsnull;
    1:   while (curView) {
    1:     nsIScrollableView* scrollingView = curView->ToScrollableView();
    1:     if (scrollingView)
    1:       scrollingView->RemoveScrollPositionListener((nsIScrollPositionListener *)this);
    1:     
    1:     curView = curView->GetParent();
    1:   }
    1: }
    1: 
    1: // Paints are handled differently, so we just simulate an update event.
    1: 
 3059: #ifdef XP_MACOSX
 3059: void nsPluginInstanceOwner::Paint(const nsRect& aDirtyRect)
    1: {
    1:   if (!mInstance || !mOwner)
    1:     return;
    1:  
    1: #ifdef DO_DIRTY_INTERSECT   // aDirtyRect isn't always correct, see bug 56128
    1:   nsPoint rel(aDirtyRect.x, aDirtyRect.y);
    1:   nsPoint abs(0,0);
    1:   nsCOMPtr<nsIWidget> containerWidget;
    1: 
    1:   // Convert dirty rect relative coordinates to absolute and also get the containerWidget
    1:   ConvertRelativeToWindowAbsolute(mOwner, rel, abs, *getter_AddRefs(containerWidget));
    1: 
    1:   nsRect absDirtyRect = nsRect(abs.x, abs.y, aDirtyRect.width, aDirtyRect.height);
    1: 
    1:   // Convert to absolute pixel values for the dirty rect
 3059:   nsIntRect absDirtyRectInPixels;
    1:   ConvertAppUnitsToPixels(*mOwner->GetPresContext(), absDirtyRect,
    1:                           absDirtyRectInPixels);
    1: #endif
    1: 
    1:   nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:   if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
  130:     WindowRef window = FixUpPluginWindow(ePluginPaintEnable);
  130:     if (window) {
    1:       EventRecord updateEvent;
    1:       InitializeEventRecord(&updateEvent);
    1:       updateEvent.what = updateEvt;
  130:       updateEvent.message = UInt32(window);
  130:     
  130:       nsPluginEvent pluginEvent = { &updateEvent, nsPluginPlatformWindowRef(window) };
    1:       PRBool eventHandled = PR_FALSE;
    1:       mInstance->HandleEvent(&pluginEvent, &eventHandled);
    1:     }
    1:     pluginWidget->EndDrawPlugin();
    1:   }
 3059: }
    1: #endif
    1: 
    1: #ifdef XP_WIN
 3059: void nsPluginInstanceOwner::Paint(const nsRect& aDirtyRect, HDC ndc)
 3059: {
 3059:   if (!mInstance || !mOwner)
 3059:     return;
 3059: 
    1:   nsPluginWindow * window;
    1:   GetWindow(window);
    1:   nsRect relDirtyRect = nsRect(aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height);
 3059:   nsIntRect relDirtyRectInPixels;
  238:   ConvertAppUnitsToPixels(*mOwner->PresContext(), relDirtyRect,
    1:                           relDirtyRectInPixels);
    1: 
    1:   // we got dirty rectangle in relative window coordinates, but we
    1:   // need it in absolute units and in the (left, top, right, bottom) form
    1:   RECT drc;
    1:   drc.left   = relDirtyRectInPixels.x + window->x;
    1:   drc.top    = relDirtyRectInPixels.y + window->y;
    1:   drc.right  = drc.left + relDirtyRectInPixels.width;
    1:   drc.bottom = drc.top + relDirtyRectInPixels.height;
    1: 
    1:   nsPluginEvent pluginEvent;
    1:   pluginEvent.event = WM_PAINT;
    1:   pluginEvent.wParam = (uint32)ndc;
    1:   pluginEvent.lParam = (uint32)&drc;
    1:   PRBool eventHandled = PR_FALSE;
    1:   mInstance->HandleEvent(&pluginEvent, &eventHandled);
 3059: }
    1: #endif
 3059: 
12859: #ifdef XP_OS2
12859: void nsPluginInstanceOwner::Paint(const nsRect& aDirtyRect, HPS aHPS)
12859: {
12859:   if (!mInstance || !mOwner)
12859:     return;
12859: 
12859:   nsPluginWindow * window;
12859:   GetWindow(window);
12859:   nsRect relDirtyRect = nsRect(aDirtyRect.x, aDirtyRect.y, aDirtyRect.width, aDirtyRect.height);
12859:   nsIntRect relDirtyRectInPixels;
12859:   ConvertAppUnitsToPixels(*mOwner->PresContext(), relDirtyRect,
12859:                           relDirtyRectInPixels);
12859: 
12859:   // we got dirty rectangle in relative window coordinates, but we
12859:   // need it in absolute units and in the (left, top, right, bottom) form
12859:   RECTL rectl;
12859:   rectl.xLeft   = relDirtyRectInPixels.x + window->x;
12859:   rectl.yBottom = relDirtyRectInPixels.y + window->y;
12859:   rectl.xRight  = rectl.xLeft + relDirtyRectInPixels.width;
12859:   rectl.yTop    = rectl.yBottom + relDirtyRectInPixels.height;
12859: 
12859:   nsPluginEvent pluginEvent;
12859:   pluginEvent.event = WM_PAINT;
12859:   pluginEvent.wParam = (uint32)aHPS;
12859:   pluginEvent.lParam = (uint32)&rectl;
12859:   PRBool eventHandled = PR_FALSE;
12859:   mInstance->HandleEvent(&pluginEvent, &eventHandled);
12859: }
12859: #endif
12859: 
 3059: #ifdef MOZ_X11
 3059: void nsPluginInstanceOwner::Paint(nsIRenderingContext& aRenderingContext,
 3059:                                   const nsRect& aDirtyRect)
 3059: {
 3059:   if (!mInstance || !mOwner)
 3059:     return;
 3059:  
 3059:   nsPluginWindow* window;
 3059:   GetWindow(window);
 3059: 
 3059:   nsIntRect dirtyRectInPixels;
 3059:   ConvertAppUnitsToPixels(*mOwner->PresContext(), aDirtyRect,
 3059:                           dirtyRectInPixels);
 3059:   // Sanitize the dirty rect so we don't tell plugins that the area outside
 3059:   // the plugin rectangle needs updating.
 3059:   nsIntRect pluginDirtyRect;
 3059:   if (!pluginDirtyRect.IntersectRect(nsIntRect(0, 0, window->width, window->height), dirtyRectInPixels))
 3059:     return;
 3059: 
 3059:   Renderer renderer(window, mInstance, pluginDirtyRect);
 3059:   PRUint32 rendererFlags =
 3059:     Renderer::DRAW_SUPPORTS_OFFSET |
 3059:     Renderer::DRAW_SUPPORTS_CLIP_RECT |
 3059:     Renderer::DRAW_SUPPORTS_NONDEFAULT_VISUAL |
 3059:     Renderer::DRAW_SUPPORTS_ALTERNATE_DISPLAY;
 3059: 
 3059:   PRBool transparent = PR_TRUE;
 3059:   mInstance->GetValue(nsPluginInstanceVariable_TransparentBool,
 3059:                       (void *)&transparent);
 3059:   if (!transparent)
 3059:     rendererFlags |= Renderer::DRAW_IS_OPAQUE;
 3059: 
 3059:   gfxContext* ctx =
 3233:     static_cast<gfxContext*>
 3233:                (aRenderingContext.GetNativeGraphicData(nsIRenderingContext::NATIVE_THEBES_CONTEXT));
 3059: 
 3059:   // The display used by gfxXlibNativeRenderer will be the one for the cairo
 3059:   // surface (provided that it is an Xlib surface) but the display argument
 3059:   // here needs to be non-NULL for cairo_draw_with_xlib ->
 3059:   // _create_temp_xlib_surface -> DefaultScreen(dpy).
 3059:   NPSetWindowCallbackStruct* ws_info = 
 3233:     static_cast<NPSetWindowCallbackStruct*>(window->ws_info);
 3059:   renderer.Draw(ws_info->display, ctx, window->width, window->height,
 3059:                 rendererFlags, nsnull);
 3059: }
 3059: 
 3059: nsresult
 3059: nsPluginInstanceOwner::Renderer::NativeDraw(Display* dpy, Drawable drawable,
 3059:                                             Visual* visual,
 3059:                                             short offsetX, short offsetY,
 3059:                                             XRectangle* clipRects,
 3059:                                             PRUint32 numClipRects)
 3059: {
 3059:   // See if the plugin must be notified of new window parameters.
 3059:   PRBool doupdatewindow = PR_FALSE;
 3059: 
 3059:   if (mWindow->x != offsetX || mWindow->y != offsetY) {
 3059:     mWindow->x = offsetX;
 3059:     mWindow->y = offsetY;
 3059:     doupdatewindow = PR_TRUE;
 3059:   }
 3059: 
 3059:   NS_ASSERTION(numClipRects <= 1, "We don't support multiple clip rectangles!");
 3059:   nsPluginRect newClipRect;
 3059:   if (numClipRects) {
 3059:     newClipRect.left = clipRects[0].x;
 3059:     newClipRect.top = clipRects[0].y;
 3059:     newClipRect.right  = clipRects[0].x + clipRects[0].width;
 3059:     newClipRect.bottom = clipRects[0].y + clipRects[0].height;
 3059:   }
 3059:   else {
 3059:     // We should have been given a clip if an offset is -ve.
 3059:     NS_ASSERTION(offsetX >= 0 && offsetY >= 0,
 3059:                  "Clip rectangle offsets are negative!");
 3059:     newClipRect.left = offsetX;
 3059:     newClipRect.top  = offsetY;
 3059:     newClipRect.right  = offsetX + mWindow->width;
 3059:     newClipRect.bottom = offsetY + mWindow->height;
 3059:   }
 3059: 
 3059:   if (mWindow->clipRect.left    != newClipRect.left   ||
 3059:       mWindow->clipRect.top     != newClipRect.top    ||
 3059:       mWindow->clipRect.right   != newClipRect.right  ||
 3059:       mWindow->clipRect.bottom  != newClipRect.bottom) {
 3059:     mWindow->clipRect = newClipRect;
 3059:     doupdatewindow = PR_TRUE;
 3059:   }
 3059: 
 3059:   NPSetWindowCallbackStruct* ws_info = 
 3233:     static_cast<NPSetWindowCallbackStruct*>(mWindow->ws_info);
 3059:   if ( ws_info->visual != visual) {
 3059:     // NPAPI needs a colormap but the surface doesn't provide a colormap.  If
 3059:     // gfxContent::CurrentSurface is a gfxXlibSurface then the visual here
 3059:     // should be derived from that of the window and so the colormap of the
 3059:     // window should be fine.  For other surfaces I don't know what to use.
 3059:     NS_ASSERTION(ws_info->visual == visual,
 3059:                  "Visual changed: colormap may not match");
 3059:     ws_info->visual = visual;
 3059:     doupdatewindow = PR_TRUE;
 3059:   }
 3059: 
 3059:   if (doupdatewindow)
 3059:       mInstance->SetWindow(mWindow);
 3059: 
 3059:   nsPluginEvent pluginEvent;
 3059:   XGraphicsExposeEvent& exposeEvent = pluginEvent.event.xgraphicsexpose;
 3059:   // set the drawing info
 3059:   exposeEvent.type = GraphicsExpose;
 3059:   exposeEvent.display = dpy;
 3059:   exposeEvent.drawable = drawable;
 3059:   exposeEvent.x = mDirtyRect.x + offsetX;
 3059:   exposeEvent.y = mDirtyRect.y + offsetY;
 3059:   exposeEvent.width  = mDirtyRect.width;
 3059:   exposeEvent.height = mDirtyRect.height;
 3059:   exposeEvent.count = 0;
 3059:   // information not set:
 3059:   exposeEvent.serial = 0;
 3059:   exposeEvent.send_event = False;
 3059:   exposeEvent.major_code = 0;
 3059:   exposeEvent.minor_code = 0;
 3059: 
 3059:   PRBool eventHandled = PR_FALSE;
 3059:   mInstance->HandleEvent(&pluginEvent, &eventHandled);
 3059: 
 3059:   return NS_OK;
 3059: }
 3059: #endif
    1: 
    1: // Here's how we give idle time to plugins.
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::Notify(nsITimer* /* timer */)
    1: {
    1: #ifdef XP_MACOSX
    1:     // validate the plugin clipping information by syncing the plugin window info to
    1:     // reflect the current widget location. This makes sure that everything is updated
    1:     // correctly in the event of scrolling in the window.
    1:     if (mInstance) {
    1:         nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:         if (pluginWidget && NS_SUCCEEDED(pluginWidget->StartDrawPlugin())) {
  130:             WindowRef window = FixUpPluginWindow(ePluginPaintIgnore);
  130:             if (window) {
    1:                 EventRecord idleEvent;
    1:                 InitializeEventRecord(&idleEvent);
    1:                 idleEvent.what = nullEvent;
    1:                     
    1:                 // give a bogus 'where' field of our null event when hidden, so Flash
    1:                 // won't respond to mouse moves in other tabs, see bug 120875
    1:                 if (!mWidgetVisible)
    1:                     idleEvent.where.h = idleEvent.where.v = 20000;
    1:     
  130:                 nsPluginEvent pluginEvent = { &idleEvent, nsPluginPlatformWindowRef(window) };
    1:     
    1:                 PRBool eventHandled = PR_FALSE;
    1:                 mInstance->HandleEvent(&pluginEvent, &eventHandled);
    1:             }
    1:             
    1:             pluginWidget->EndDrawPlugin();
    1:        }
    1:     }
    1: #endif
    1:     return NS_OK;
    1: }
    1: 
    1: void nsPluginInstanceOwner::StartTimer(unsigned int aDelay)
    1: {
    1: #ifdef XP_MACOSX
    1:     nsresult rv;
    1: 
    1:     // start a periodic timer to provide null events to the plugin instance.
    1:     if (!mPluginTimer) {
    1:       mPluginTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
    1:       if (NS_SUCCEEDED(rv))
    1:         mPluginTimer->InitWithCallback(this, aDelay, nsITimer::TYPE_REPEATING_SLACK);
    1:     }
    1: #endif
    1: }
    1: 
    1: void nsPluginInstanceOwner::CancelTimer()
    1: {
    1:     if (mPluginTimer) {
    1:         mPluginTimer->Cancel();
    1:         mPluginTimer = nsnull;
    1:     }
    1: }
    1: 
    1: nsresult nsPluginInstanceOwner::Init(nsPresContext* aPresContext,
    1:                                      nsObjectFrame* aFrame,
    1:                                      nsIContent*    aContent)
    1: {
13537:   mLastEventloopNestingLevel = 0;
13537:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
13537:   if (appShell) {
13537:     appShell->GetEventloopNestingLevel(&mLastEventloopNestingLevel);
13537:   }
13537: 
12417:   PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:          ("nsPluginInstanceOwner::Init() called on %p for frame %p\n", this,
12417:           aFrame));
12417: 
    1:   mOwner = aFrame;
    1:   mContent = aContent;
    1: 
12417:   nsWeakFrame weakFrame(aFrame);
12417: 
    1:   // Some plugins require a specific sequence of shutdown and startup when
    1:   // a page is reloaded. Shutdown happens usually when the last instance
    1:   // is destroyed. Here we make sure the plugin instance in the old
    1:   // document is destroyed before we try to create the new one.
    1:   aPresContext->EnsureVisible(PR_TRUE);
    1: 
12417:   if (!weakFrame.IsAlive()) {
12417:     PR_LOG(nsObjectFrameLM, PR_LOG_DEBUG,
12417:            ("nsPluginInstanceOwner::Init's EnsureVisible() call destroyed "
12417:             "instance owner %p\n", this));
12417: 
12417:     return NS_ERROR_NOT_AVAILABLE;
12417:   }
12417: 
    1:   // register context menu listener
    1:   mCXMenuListener = new nsPluginDOMContextMenuListener();
    1:   if (mCXMenuListener) {    
    1:     mCXMenuListener->Init(aContent);
    1:   }
    1: 
 1418:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(mContent));
 1418:   if (target) {
    1: 
    1:     nsCOMPtr<nsIDOMEventListener> listener;
    1:     QueryInterface(NS_GET_IID(nsIDOMEventListener), getter_AddRefs(listener));
    1: 
    1:     // Register focus listener
 1418:     mContent->AddEventListenerByIID(listener, NS_GET_IID(nsIDOMFocusListener));
    1: 
    1:     // Register mouse listener
 1418:     mContent->AddEventListenerByIID(listener, NS_GET_IID(nsIDOMMouseListener));
    1: 
    1:     // now do the mouse motion listener
 1418:     mContent->AddEventListenerByIID(listener, NS_GET_IID(nsIDOMMouseMotionListener));
    1: 
    1:     // Register key listener
 1418:     target->AddEventListener(NS_LITERAL_STRING("keypress"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("keydown"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("keyup"), listener, PR_TRUE);
    1: 
    1:     // Register drag listener
 1418:     target->AddEventListener(NS_LITERAL_STRING("dragdrop"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("dragover"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("dragexit"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("dragenter"), listener, PR_TRUE);
 1418:     target->AddEventListener(NS_LITERAL_STRING("draggesture"), listener, PR_TRUE);
    1:   }
    1:   
    1:   // Register scroll position listener
    1:   // We need to register a scroll pos listener on every scrollable
    1:   // view up to the top
    1:   nsIFrame* parentWithView = mOwner->GetAncestorWithView();
    1:   nsIView* curView = parentWithView ? parentWithView->GetView() : nsnull;
    1:   while (curView) {
    1:     nsIScrollableView* scrollingView = curView->ToScrollableView();
    1:     if (scrollingView)
    1:       scrollingView->AddScrollPositionListener((nsIScrollPositionListener *)this);
    1:     
    1:     curView = curView->GetParent();
    1:   }
    1: 
    1:   return NS_OK; 
    1: }
    1: 
    1: nsPluginPort* nsPluginInstanceOwner::GetPluginPort()
    1: {
    1: //!!! Port must be released for windowless plugins on Windows, because it is HDC !!!
    1: 
    1:   nsPluginPort* result = NULL;
    1:   if (mWidget) {
    1: #ifdef XP_WIN
    1:     if (mPluginWindow && mPluginWindow->type == nsPluginWindowType_Drawable)
    1:       result = (nsPluginPort*) mWidget->GetNativeData(NS_NATIVE_GRAPHIC);
    1:     else
    1: #endif
  130: #ifdef XP_MACOSX
  130:     if (GetDrawingModel() == NPDrawingModelCoreGraphics)
  130:       result = (nsPluginPort*) mWidget->GetNativeData(NS_NATIVE_PLUGIN_PORT_CG);
  130:     else
  130: #endif
    1:       result = (nsPluginPort*) mWidget->GetNativeData(NS_NATIVE_PLUGIN_PORT);
    1:   }
    1:   return result;
    1: }
    1: 
    1: void nsPluginInstanceOwner::ReleasePluginPort(nsPluginPort * pluginPort)
    1: {
    1: #ifdef XP_WIN
    1:   if (mWidget && mPluginWindow &&
    1:       mPluginWindow->type == nsPluginWindowType_Drawable) {
    1:     mWidget->FreeNativeData((HDC)pluginPort, NS_NATIVE_GRAPHIC);
    1:   }
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP nsPluginInstanceOwner::CreateWidget(void)
    1: {
    1:   NS_ENSURE_TRUE(mPluginWindow, NS_ERROR_NULL_POINTER);
    1: 
    1:   nsIView   *view;
    1:   nsresult  rv = NS_ERROR_FAILURE;
    1: 
    1:   if (mOwner) {
    1:     // Create view if necessary
    1: 
    1:     view = mOwner->GetView();
    1: 
    1:     if (!view || !mWidget) {
    1:       PRBool windowless = PR_FALSE;
    1: 
    1:       mInstance->GetValue(nsPluginInstanceVariable_WindowlessBool,
    1:                           (void *)&windowless);
    1: 
    1:       // always create widgets in Twips, not pixels
  238:       nsPresContext* context = mOwner->PresContext();
    1:       rv = mOwner->CreateWidget(context->DevPixelsToAppUnits(mPluginWindow->width),
    1:                                 context->DevPixelsToAppUnits(mPluginWindow->height),
    1:                                 windowless);
    1:       if (NS_OK == rv) {
    1:         view = mOwner->GetView();
    1: 
    1:         if (view) {
    1:           mWidget = view->GetWidget();
    1:         }
    1: 
    1:         if (PR_TRUE == windowless) {
    1:           mPluginWindow->type = nsPluginWindowType_Drawable;
    1: 
    1:           // this needs to be a HDC according to the spec, but I do
    1:           // not see the right way to release it so let's postpone
    1:           // passing HDC till paint event when it is really
    1:           // needed. Change spec?
    1:           mPluginWindow->window = nsnull;
    1:         } else if (mWidget) {
    1:           mWidget->Resize(mPluginWindow->width, mPluginWindow->height,
    1:                           PR_FALSE);
    1: 
    1:           // mPluginWindow->type is used in |GetPluginPort| so it must
14641:           // be initialized first
    1:           mPluginWindow->type = nsPluginWindowType_Window;
    1:           mPluginWindow->window = GetPluginPort();
    1: 
    1:           // start the idle timer.
    1:           StartTimer(NORMAL_PLUGIN_DELAY);
    1: 
    1:           // tell the plugin window about the widget
    1:           mPluginWindow->SetPluginWidget(mWidget);
14641: 
14641:           // tell the widget about the current plugin instance owner.
14641:           nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
14641:           if (pluginWidget)
14641:             pluginWidget->SetPluginInstanceOwner(this);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: void nsPluginInstanceOwner::SetPluginHost(nsIPluginHost* aHost)
    1: {
    1:   mPluginHost = aHost;
    1: }
    1: 
12859: #if defined(XP_WIN) || (defined(DO_DIRTY_INTERSECT) && defined(XP_MACOSX)) || defined(MOZ_X11) || defined(XP_OS2)
    1: // convert frame coordinates from twips to pixels
 3059: static void ConvertAppUnitsToPixels(const nsPresContext& aPresContext, const nsRect& aTwipsRect, nsIntRect& aPixelRect)
    1: {
    1:   aPixelRect.x = aPresContext.AppUnitsToDevPixels(aTwipsRect.x);
    1:   aPixelRect.y = aPresContext.AppUnitsToDevPixels(aTwipsRect.y);
    1:   aPixelRect.width = aPresContext.AppUnitsToDevPixels(aTwipsRect.width);
    1:   aPixelRect.height = aPresContext.AppUnitsToDevPixels(aTwipsRect.height);
    1: }
    1: #endif
    1: 
    1:   // Mac specific code to fix up the port location and clipping region
    1: #ifdef XP_MACOSX
    1: 
    1: #ifdef DO_DIRTY_INTERSECT
    1: // Convert from a frame relative coordinate to a coordinate relative to its
    1: // containing window
    1: static void ConvertRelativeToWindowAbsolute(nsIFrame*   aFrame,
    1:                                             nsPoint&    aRel, 
    1:                                             nsPoint&    aAbs,
    1:                                             nsIWidget*& aContainerWidget)
    1: {
    1:   // See if this frame has a view
    1:   nsIView *view = aFrame->GetView();
    1:   if (!view) {
    1:     aAbs.x = 0;
    1:     aAbs.y = 0;
    1:     // Calculate frames offset from its nearest view
    1:     aFrame->GetOffsetFromView(aAbs, &view);
    1:   } else {
    1:     // Store frames offset from its view.
    1:     aAbs = aFrame->GetPosition();
    1:   }
    1: 
    1:   NS_ASSERTION(view, "the object frame does not have a view");
    1:   if (view) {
    1:     // Calculate the view's offset from its nearest widget
    1:     nsPoint viewOffset;
    1:     aContainerWidget = view->GetNearestWidget(&viewOffset);
    1:     NS_IF_ADDREF(aContainerWidget);
    1:     aAbs += viewOffset;
    1:   }
    1: 
    1:   // Add relative coordinate to the absolute coordinate that has been calculated
    1:   aAbs += aRel;
    1: }
    1: #endif // DO_DIRTY_INTERSECT
    1: 
  130: WindowRef nsPluginInstanceOwner::FixUpPluginWindow(PRInt32 inPaintState)
    1: {
13044:   if (!mWidget || !mPluginWindow || !mInstance || !mOwner)
    1:     return nsnull;
    1: 
    1:   nsPluginPort* pluginPort = GetPluginPort(); 
    1: 
    1:   if (!pluginPort)
    1:     return nsnull;
    1: 
  130:   NPDrawingModel drawingModel = GetDrawingModel();
  130: 
    1:   // first, check our view for CSS visibility style
    1:   PRBool isVisible =
    1:     mOwner->GetView()->GetVisibility() == nsViewVisibility_kShow;
    1: 
    1:   nsCOMPtr<nsIPluginWidget> pluginWidget = do_QueryInterface(mWidget);
    1:   
    1:   nsPoint pluginOrigin;
    1:   nsRect widgetClip;
    1:   PRBool widgetVisible;
    1:   pluginWidget->GetPluginClipRect(widgetClip, pluginOrigin, /* out */ widgetVisible);
    1:   
    1:   // printf("GetPluginClipRect returning visible %d\n", widgetVisible);
    1: 
    1:   isVisible &= widgetVisible;
    1:   if (!isVisible)
    1:     widgetClip.Empty();
    1: 
  130: #ifndef NP_NO_QUICKDRAW
    1:   // set the port coordinates
  130:   if (drawingModel == NPDrawingModelQuickDraw) {
  130:     mPluginWindow->x = -pluginPort->qdPort.portx;
  130:     mPluginWindow->y = -pluginPort->qdPort.porty;
  130:   }
 2078:   else if (drawingModel == NPDrawingModelCoreGraphics)
  130: #endif
 2078:   {
 2078:     // This would be a lot easier if we could use obj-c here,
 2078:     // but we can't. Since we have only nsIWidget and we can't
 2078:     // use its native widget (an obj-c object) we have to go
 2078:     // from the widget's screen coordinates to its window coords
 2078:     // instead of straight to window coords.
 2078:     nsRect geckoBounds;
 2078:     mWidget->GetBounds(geckoBounds);
 2078:     // we need a rect that is the entire *internal* rect, so the
 2078:     // x and y coords are 0, width is the same.
 2078:     geckoBounds.x = 0;
 2078:     geckoBounds.y = 0;
 2078:     nsRect geckoScreenCoords;
 2078:     mWidget->WidgetToScreen(geckoBounds, geckoScreenCoords);
 2078: 
 2078:     Rect windowRect;
 2078:     WindowRef window = (WindowRef)pluginPort->cgPort.window;
 2078:     ::GetWindowBounds(window, kWindowStructureRgn, &windowRect);
 2078: 
 2078:     mPluginWindow->x = geckoScreenCoords.x - windowRect.left;
 2078:     mPluginWindow->y = geckoScreenCoords.y - windowRect.top;
 2078:   }
    1: 
    1:   nsPluginRect oldClipRect = mPluginWindow->clipRect;
    1:   
    1:   // fix up the clipping region
    1:   mPluginWindow->clipRect.top    = widgetClip.y;
    1:   mPluginWindow->clipRect.left   = widgetClip.x;
    1: 
    1:   mWidgetVisible = isVisible;
    1: 
    1:   if (!mWidgetVisible || inPaintState == ePluginPaintDisable) {
    1:     mPluginWindow->clipRect.bottom = mPluginWindow->clipRect.top;
    1:     mPluginWindow->clipRect.right  = mPluginWindow->clipRect.left;
    1:     // pluginPort = nsnull; // don't uncomment this
    1:   }
    1:   else if (inPaintState == ePluginPaintEnable)
    1:   {
    1:     mPluginWindow->clipRect.bottom = mPluginWindow->clipRect.top + widgetClip.height;
    1:     mPluginWindow->clipRect.right  = mPluginWindow->clipRect.left + widgetClip.width; 
    1:   }
    1: 
    1:   // if the clip rect changed, call SetWindow()
    1:   // (RealPlayer needs this to draw correctly)
    1:   if (mPluginWindow->clipRect.left    != oldClipRect.left   ||
    1:       mPluginWindow->clipRect.top     != oldClipRect.top    ||
    1:       mPluginWindow->clipRect.right   != oldClipRect.right  ||
    1:       mPluginWindow->clipRect.bottom  != oldClipRect.bottom)
    1:   {
    1:     mInstance->SetWindow(mPluginWindow);
    1:     // if the clipRect is of size 0, make the null timer fire less often
    1:     CancelTimer();
    1:     if (mPluginWindow->clipRect.left == mPluginWindow->clipRect.right ||
    1:         mPluginWindow->clipRect.top == mPluginWindow->clipRect.bottom) {
    1:       StartTimer(HIDDEN_PLUGIN_DELAY);
    1:     }
    1:     else {
    1:       StartTimer(NORMAL_PLUGIN_DELAY);
    1:     }
    1:   }
    1: 
  130: #ifndef NP_NO_QUICKDRAW
  130:   if (drawingModel == NPDrawingModelQuickDraw)
  130:     return ::GetWindowFromPort(pluginPort->qdPort.port);
  130: #endif
  130: 
  130:   if (drawingModel == NPDrawingModelCoreGraphics)
  130:     return pluginPort->cgPort.window;
  130: 
  130:   return nsnull;
    1: }
    1: 
    1: #endif // XP_MACOSX
    1: 
    1: // Little helper function to resolve relative URL in
    1: // |value| for certain inputs of |name|
    1: void nsPluginInstanceOwner::FixUpURLS(const nsString &name, nsAString &value)
    1: {
    1:   if (name.LowerCaseEqualsLiteral("pluginurl") ||
    1:       name.LowerCaseEqualsLiteral("pluginspage")) {        
    1:     
    1:     nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
    1:     nsAutoString newURL;
    1:     NS_MakeAbsoluteURI(newURL, value, baseURI);
    1:     if (!newURL.IsEmpty())
    1:       value = newURL;
    1:   }
    1: }
    1: 
    1: 
