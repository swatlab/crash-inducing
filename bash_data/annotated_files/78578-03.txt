41920: /*
41920:  * Copyright © 2008 Mozilla Corporation
64161:  * Copyright © 2010 Nokia Corporation
41920:  *
41920:  * Permission to use, copy, modify, distribute, and sell this software and its
41920:  * documentation for any purpose is hereby granted without fee, provided that
41920:  * the above copyright notice appear in all copies and that both that
41920:  * copyright notice and this permission notice appear in supporting
41920:  * documentation, and that the name of Mozilla Corporation not be used in
41920:  * advertising or publicity pertaining to distribution of the software without
41920:  * specific, written prior permission.  Mozilla Corporation makes no
41920:  * representations about the suitability of this software for any purpose.  It
41920:  * is provided "as is" without express or implied warranty.
41920:  *
41920:  * THE COPYRIGHT HOLDERS DISCLAIM ALL WARRANTIES WITH REGARD TO THIS
41920:  * SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
41920:  * FITNESS, IN NO EVENT SHALL THE COPYRIGHT HOLDERS BE LIABLE FOR ANY
41920:  * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
41920:  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
41920:  * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
41920:  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
41920:  * SOFTWARE.
41920:  *
41920:  * Author:  Jeff Muizelaar (jeff@infidigm.net)
41920:  *
41920:  */
41920: 
41920: /* Prevent the stack from becoming executable */
41920: #if defined(__linux__) && defined(__ELF__)
41920: .section .note.GNU-stack,"",%progbits
41920: #endif
41920: 
41920: 	.text
41920: 	.arch armv6
41920: 	.object_arch armv4
41920: 	.arm
41920: 	.altmacro
78578: 	.p2align 2
41920: 
41920: /* Supplementary macro for setting function attributes */
41920: .macro pixman_asm_function fname
41920: 	.func fname
41920: 	.global fname
41920: #ifdef __ELF__
41920: 	.hidden fname
41920: 	.type fname, %function
41920: #endif
41920: fname:
41920: .endm
41920: 
41920: /*
41920:  * The code below was generated by gcc 4.3.4 from the commented out
41920:  * functions in 'pixman-arm-simd.c' file with the following optimization
41920:  * options: "-O3 -mcpu=arm1136jf-s -fomit-frame-pointer"
41920:  *
41920:  * TODO: replace gcc generated code with hand tuned versions because
41920:  * the code quality is not very good, introduce symbolic register
41920:  * aliases for better readability and maintainability.
41920:  */
41920: 
56260: pixman_asm_function pixman_composite_add_8_8_asm_armv6
41920: 	push	{r4, r5, r6, r7, r8, r9, r10, r11}
41920: 	mov	r10, r1
41920: 	sub	sp, sp, #4
41920: 	subs	r10, r10, #1
41920: 	mov	r11, r0
41920: 	mov	r8, r2
41920: 	str	r3, [sp]
41920: 	ldr	r7, [sp, #36]
41920: 	bcc	0f
41920: 6:	cmp	r11, #0
41920: 	beq	1f
41920: 	orr	r3, r8, r7
41920: 	tst	r3, #3
41920: 	beq	2f
41920: 	mov	r1, r8
41920: 	mov	r0, r7
41920: 	mov	r12, r11
41920: 	b	3f
41920: 5:	tst	r3, #3
41920: 	beq	4f
41920: 3:	ldrb	r2, [r0], #1
41920: 	subs	r12, r12, #1
41920: 	ldrb	r3, [r1]
41920: 	uqadd8	r3, r2, r3
41920: 	strb	r3, [r1], #1
41920: 	orr	r3, r1, r0
41920: 	bne	5b
41920: 1:	ldr	r3, [sp]
41920: 	add	r8, r8, r3
41920: 	ldr	r3, [sp, #40]
41920: 	add	r7, r7, r3
41920: 10:	subs	r10, r10, #1
41920: 	bcs	6b
41920: 0:	add	sp, sp, #4
41920: 	pop	{r4, r5, r6, r7, r8, r9, r10, r11}
41920: 	bx	lr
41920: 2:	mov	r12, r11
41920: 	mov	r1, r8
41920: 	mov	r0, r7
41920: 4:	cmp	r12, #3
41920: 	subgt	r6, r12, #4
41920: 	movgt	r9, r12
41920: 	lsrgt	r5, r6, #2
41920: 	addgt	r3, r5, #1
41920: 	movgt	r12, #0
41920: 	lslgt	r4, r3, #2
41920: 	ble	7f
41920: 8:	ldr	r3, [r0, r12]
41920: 	ldr	r2, [r1, r12]
41920: 	uqadd8	r3, r3, r2
41920: 	str	r3, [r1, r12]
41920: 	add	r12, r12, #4
41920: 	cmp	r12, r4
41920: 	bne	8b
41920: 	sub	r3, r9, #4
41920: 	bic	r3, r3, #3
41920: 	add	r3, r3, #4
41920: 	subs	r12, r6, r5, lsl #2
41920: 	add	r1, r1, r3
41920: 	add	r0, r0, r3
41920: 	beq	1b
41920: 7:	mov	r4, #0
41920: 9:	ldrb	r3, [r1, r4]
41920: 	ldrb	r2, [r0, r4]
41920: 	uqadd8	r3, r2, r3
41920: 	strb	r3, [r1, r4]
41920: 	add	r4, r4, #1
41920: 	cmp	r4, r12
41920: 	bne	9b
41920: 	ldr	r3, [sp]
41920: 	add	r8, r8, r3
41920: 	ldr	r3, [sp, #40]
41920: 	add	r7, r7, r3
41920: 	b	10b
41920: .endfunc
41920: 
41920: pixman_asm_function pixman_composite_over_8888_8888_asm_armv6
41920: 	push	{r4, r5, r6, r7, r8, r9, r10, r11}
41920: 	sub	sp, sp, #20
41920: 	cmp	r1, #0
41920: 	mov	r12, r2
41920: 	str	r1, [sp, #12]
41920: 	str	r0, [sp, #16]
41920: 	ldr	r2, [sp, #52]
41920: 	beq	0f
41920: 	lsl	r3, r3, #2
41920: 	str	r3, [sp]
41920: 	ldr	r3, [sp, #56]
41920: 	mov	r10, #0
41920: 	lsl	r3, r3, #2
41920: 	str	r3, [sp, #8]
41920: 	mov	r11, r3
41920: 	b	1f
41920: 6:	ldr	r11, [sp, #8]
41920: 1:	ldr	r9, [sp]
41920: 	mov	r0, r12
41920: 	add	r12, r12, r9
41920: 	mov	r1, r2
41920: 	str	r12, [sp, #4]
41920: 	add	r2, r2, r11
41920: 	ldr	r12, [sp, #16]
41920: 	ldr	r3, =0x00800080
41920: 	ldr	r9, =0xff00ff00
41920: 	mov	r11, #255
41920: 	cmp	r12, #0
41920: 	beq	4f
41920: 5:	ldr	r5, [r1], #4
41920: 	ldr	r4, [r0]
41920: 	sub	r8, r11, r5, lsr #24
41920: 	uxtb16	r6, r4
41920: 	uxtb16	r7, r4, ror #8
41920: 	mla	r6, r6, r8, r3
41920: 	mla	r7, r7, r8, r3
41920: 	uxtab16	r6, r6, r6, ror #8
41920: 	uxtab16	r7, r7, r7, ror #8
41920: 	and	r7, r7, r9
41920: 	uxtab16	r6, r7, r6, ror #8
41920: 	uqadd8	r5, r6, r5
41920: 	str	r5, [r0], #4
41920: 	subs	r12, r12, #1
41920: 	bne	5b
41920: 4:	ldr	r3, [sp, #12]
41920: 	add	r10, r10, #1
41920: 	cmp	r10, r3
41920: 	ldr	r12, [sp, #4]
41920: 	bne	6b
41920: 0:	add	sp, sp, #20
41920: 	pop	{r4, r5, r6, r7, r8, r9, r10, r11}
41920: 	bx	lr
41920: .endfunc
41920: 
41920: pixman_asm_function pixman_composite_over_8888_n_8888_asm_armv6
41920: 	push	{r4, r5, r6, r7, r8, r9, r10, r11}
41920: 	sub	sp, sp, #28
41920: 	cmp	r1, #0
41920: 	str	r1, [sp, #12]
41920: 	ldrb	r1, [sp, #71]
41920: 	mov	r12, r2
41920: 	str	r0, [sp, #16]
41920: 	ldr	r2, [sp, #60]
41920: 	str	r1, [sp, #24]
41920: 	beq	0f
41920: 	lsl	r3, r3, #2
41920: 	str	r3, [sp, #20]
41920: 	ldr	r3, [sp, #64]
41920: 	mov	r10, #0
41920: 	lsl	r3, r3, #2
41920: 	str	r3, [sp, #8]
41920: 	mov	r11, r3
41920: 	b	1f
41920: 5:	ldr	r11, [sp, #8]
41920: 1:	ldr	r4, [sp, #20]
41920: 	mov	r0, r12
41920: 	mov	r1, r2
41920: 	add	r12, r12, r4
41920: 	add	r2, r2, r11
41920: 	str	r12, [sp]
41920: 	str	r2, [sp, #4]
41920: 	ldr	r12, [sp, #16]
41920: 	ldr	r2, =0x00800080
41920: 	ldr	r3, [sp, #24]
41920: 	mov	r11, #255
41920: 	cmp	r12, #0
41920: 	beq	3f
41920: 4:	ldr	r5, [r1], #4
41920: 	ldr	r4, [r0]
41920: 	uxtb16	r6, r5
41920: 	uxtb16	r7, r5, ror #8
41920: 	mla	r6, r6, r3, r2
41920: 	mla	r7, r7, r3, r2
41920: 	uxtab16	r6, r6, r6, ror #8
41920: 	uxtab16	r7, r7, r7, ror #8
41920: 	uxtb16	r6, r6, ror #8
41920: 	uxtb16	r7, r7, ror #8
41920: 	orr	r5, r6, r7, lsl #8
41920: 	uxtb16	r6, r4
41920: 	uxtb16	r7, r4, ror #8
41920: 	sub	r8, r11, r5, lsr #24
41920: 	mla	r6, r6, r8, r2
41920: 	mla	r7, r7, r8, r2
41920: 	uxtab16	r6, r6, r6, ror #8
41920: 	uxtab16	r7, r7, r7, ror #8
41920: 	uxtb16	r6, r6, ror #8
41920: 	uxtb16	r7, r7, ror #8
41920: 	orr	r6, r6, r7, lsl #8
41920: 	uqadd8	r5, r6, r5
41920: 	str	r5, [r0], #4
41920: 	subs	r12, r12, #1
41920: 	bne	4b
41920: 3:	ldr	r1, [sp, #12]
41920: 	add	r10, r10, #1
41920: 	cmp	r10, r1
41920: 	ldr	r12, [sp]
41920: 	ldr	r2, [sp, #4]
41920: 	bne	5b
41920: 0:	add	sp, sp, #28
41920: 	pop	{r4, r5, r6, r7, r8, r9, r10, r11}
41920: 	bx	lr
41920: .endfunc
41920: 
41920: pixman_asm_function pixman_composite_over_n_8_8888_asm_armv6
41920: 	push	{r4, r5, r6, r7, r8, r9, r10, r11}
41920: 	sub	sp, sp, #28
41920: 	cmp	r1, #0
41920: 	ldr	r9, [sp, #60]
41920: 	str	r1, [sp, #12]
41920: 	bic	r1, r9, #-16777216
41920: 	str	r1, [sp, #20]
41920: 	mov	r12, r2
41920: 	lsr	r1, r9, #8
41920: 	ldr	r2, [sp, #20]
41920: 	bic	r1, r1, #-16777216
41920: 	bic	r2, r2, #65280
41920: 	bic	r1, r1, #65280
41920: 	str	r2, [sp, #20]
41920: 	str	r0, [sp, #16]
41920: 	str	r1, [sp, #4]
41920: 	ldr	r2, [sp, #68]
41920: 	beq	0f
41920: 	lsl	r3, r3, #2
41920: 	str	r3, [sp, #24]
41920: 	mov	r0, #0
41920: 	b	1f
41920: 5:	ldr	r3, [sp, #24]
41920: 1:	ldr	r4, [sp, #72]
41920: 	mov	r10, r12
41920: 	mov	r1, r2
41920: 	add	r12, r12, r3
41920: 	add	r2, r2, r4
41920: 	str	r12, [sp, #8]
41920: 	str	r2, [sp]
41920: 	ldr	r12, [sp, #16]
41920: 	ldr	r11, =0x00800080
41920: 	ldr	r2, [sp, #4]
41920: 	ldr	r3, [sp, #20]
41920: 	cmp	r12, #0
41920: 	beq	3f
41920: 4:	ldrb	r5, [r1], #1
41920: 	ldr	r4, [r10]
41920: 	mla	r6, r3, r5, r11
41920: 	mla	r7, r2, r5, r11
41920: 	uxtab16	r6, r6, r6, ror #8
41920: 	uxtab16	r7, r7, r7, ror #8
41920: 	uxtb16	r6, r6, ror #8
41920: 	uxtb16	r7, r7, ror #8
41920: 	orr	r5, r6, r7, lsl #8
41920: 	uxtb16	r6, r4
41920: 	uxtb16	r7, r4, ror #8
41920: 	mvn	r8, r5
41920: 	lsr	r8, r8, #24
41920: 	mla	r6, r6, r8, r11
41920: 	mla	r7, r7, r8, r11
41920: 	uxtab16	r6, r6, r6, ror #8
41920: 	uxtab16	r7, r7, r7, ror #8
41920: 	uxtb16	r6, r6, ror #8
41920: 	uxtb16	r7, r7, ror #8
41920: 	orr	r6, r6, r7, lsl #8
41920: 	uqadd8	r5, r6, r5
41920: 	str	r5, [r10], #4
41920: 	subs	r12, r12, #1
41920: 	bne	4b
41920: 3:	ldr	r4, [sp, #12]
41920: 	add	r0, r0, #1
41920: 	cmp	r0, r4
41920: 	ldr	r12, [sp, #8]
41920: 	ldr	r2, [sp]
41920: 	bne	5b
41920: 0:	add	sp, sp, #28
41920: 	pop	{r4, r5, r6, r7, r8, r9, r10, r11}
41920: 	bx	lr
41920: .endfunc
64161: 
64161: /*
64161:  * Note: This code is only using armv5te instructions (not even armv6),
64161:  *       but is scheduled for ARM Cortex-A8 pipeline. So it might need to
64161:  *       be split into a few variants, tuned for each microarchitecture.
64161:  *
64161:  * TODO: In order to get good performance on ARM9/ARM11 cores (which don't
64161:  * have efficient write combining), it needs to be changed to use 16-byte
64161:  * aligned writes using STM instruction.
64161:  *
64161:  * Nearest scanline scaler macro template uses the following arguments:
64161:  *  fname                     - name of the function to generate
64161:  *  bpp_shift                 - (1 << bpp_shift) is the size of pixel in bytes
64161:  *  t                         - type suffix for LDR/STR instructions
64161:  *  prefetch_distance         - prefetch in the source image by that many
64161:  *                              pixels ahead
64161:  *  prefetch_braking_distance - stop prefetching when that many pixels are
64161:  *                              remaining before the end of scanline
64161:  */
64161: 
64161: .macro generate_nearest_scanline_func fname, bpp_shift, t,      \
64161:                                       prefetch_distance,        \
64161:                                       prefetch_braking_distance
64161: 
64161: pixman_asm_function fname
64161: 	W	.req	r0
64161: 	DST	.req	r1
64161: 	SRC	.req	r2
64161: 	VX	.req	r3
64161: 	UNIT_X	.req	ip
64161: 	TMP1	.req	r4
64161: 	TMP2	.req	r5
64161: 	VXMASK	.req	r6
64161: 	PF_OFFS	.req	r7
64161: 
64161: 	ldr	UNIT_X, [sp]
64161: 	push	{r4, r5, r6, r7}
64161: 	mvn	VXMASK, #((1 << bpp_shift) - 1)
64161: 
64161: 	/* define helper macro */
64161: 	.macro	scale_2_pixels
64161: 		ldr&t	TMP1, [SRC, TMP1]
64161: 		and	TMP2, VXMASK, VX, lsr #(16 - bpp_shift)
64161: 		add	VX, VX, UNIT_X
64161: 		str&t	TMP1, [DST], #(1 << bpp_shift)
64161: 
64161: 		ldr&t	TMP2, [SRC, TMP2]
64161: 		and	TMP1, VXMASK, VX, lsr #(16 - bpp_shift)
64161: 		add	VX, VX, UNIT_X
64161: 		str&t	TMP2, [DST], #(1 << bpp_shift)
64161: 	.endm
64161: 
64161: 	/* now do the scaling */
64161: 	and	TMP1, VXMASK, VX, lsr #(16 - bpp_shift)
64161: 	add	VX, VX, UNIT_X
64161: 	subs	W, W, #(8 + prefetch_braking_distance)
64161: 	blt	2f
64161: 	/* calculate prefetch offset */
64161: 	mov	PF_OFFS, #prefetch_distance
64161: 	mla	PF_OFFS, UNIT_X, PF_OFFS, VX
64161: 1:	/* main loop, process 8 pixels per iteration with prefetch */
64161: 	subs	W, W, #8
64161: 	add	PF_OFFS, UNIT_X, lsl #3
64161: 	scale_2_pixels
64161: 	scale_2_pixels
64161: 	scale_2_pixels
64161: 	scale_2_pixels
64161: 	pld	[SRC, PF_OFFS, lsr #(16 - bpp_shift)]
64161: 	bge	1b
64161: 2:
64161: 	subs	W, W, #(4 - 8 - prefetch_braking_distance)
64161: 	blt	2f
64161: 1:	/* process the remaining pixels */
64161: 	scale_2_pixels
64161: 	scale_2_pixels
64161: 	subs	W, W, #4
64161: 	bge	1b
64161: 2:
64161: 	tst	W, #2
64161: 	beq	2f
64161: 	scale_2_pixels
64161: 2:
64161: 	tst	W, #1
64161: 	ldrne&t	TMP1, [SRC, TMP1]
64161: 	strne&t	TMP1, [DST]
64161: 	/* cleanup helper macro */
64161: 	.purgem	scale_2_pixels
64161: 	.unreq	DST
64161: 	.unreq	SRC
64161: 	.unreq	W
64161: 	.unreq	VX
64161: 	.unreq	UNIT_X
64161: 	.unreq	TMP1
64161: 	.unreq	TMP2
64161: 	.unreq	VXMASK
64161: 	.unreq	PF_OFFS
64161: 	/* return */
64161: 	pop	{r4, r5, r6, r7}
64161: 	bx	lr
64161: .endfunc
64161: .endm
64161: 
64161: generate_nearest_scanline_func \
64161:     pixman_scaled_nearest_scanline_0565_0565_SRC_asm_armv6, 1, h, 80, 32
64161: 
64161: generate_nearest_scanline_func \
64161:     pixman_scaled_nearest_scanline_8888_8888_SRC_asm_armv6, 2,  , 48, 32
