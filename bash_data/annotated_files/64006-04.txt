    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Gaunt (jgaunt@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef _nsAccessible_H_
    1: #define _nsAccessible_H_
    1: 
    1: #include "nsAccessNodeWrap.h"
 1628: 
    1: #include "nsIAccessible.h"
    1: #include "nsIAccessibleHyperLink.h"
    1: #include "nsIAccessibleSelectable.h"
    1: #include "nsIAccessibleValue.h"
 1628: #include "nsIAccessibleRole.h"
 1628: #include "nsIAccessibleStates.h"
 1628: 
58433: #include "nsARIAMap.h"
41384: #include "nsStringGlue.h"
23904: #include "nsTArray.h"
43888: #include "nsRefPtrHashtable.h"
41384: 
61638: class AccEvent;
47172: class AccGroupInfo;
50622: class EmbeddedObjCollector;
61638: class nsAccessible;
61467: class nsHyperTextAccessible;
64006: class nsHTMLLIAccessible;
41384: struct nsRoleMapEntry;
61638: class nsTextAccessible;
    1: 
    1: struct nsRect;
    1: class nsIContent;
    1: class nsIFrame;
    1: class nsIAtom;
    1: class nsIView;
    1: 
41384: typedef nsRefPtrHashtable<nsVoidPtrHashKey, nsAccessible>
41384:   nsAccessibleHashtable;
41384: 
22844: // see nsAccessible::GetAttrValue
 4274: #define NS_OK_NO_ARIA_VALUE \
 4274: NS_ERROR_GENERATE_SUCCESS(NS_ERROR_MODULE_GENERAL, 0x21)
 4274: 
22844: // see nsAccessible::GetNameInternal
22844: #define NS_OK_EMPTY_NAME \
22844: NS_ERROR_GENERATE_SUCCESS(NS_ERROR_MODULE_GENERAL, 0x23)
22844: 
25591: // see nsAccessible::GetNameInternal
25591: #define NS_OK_NAME_FROM_TOOLTIP \
25591: NS_ERROR_GENERATE_SUCCESS(NS_ERROR_MODULE_GENERAL, 0x25)
25591: 
    1: 
41384: #define NS_ACCESSIBLE_IMPL_IID                          \
37299: {  /* 133c8bf4-4913-4355-bd50-426bd1d6e1ad */           \
37299:   0x133c8bf4,                                           \
37299:   0x4913,                                               \
37299:   0x4355,                                               \
37299:   { 0xbd, 0x50, 0x42, 0x6b, 0xd1, 0xd6, 0xe1, 0xad }    \
20246: }
20246: 
    1: class nsAccessible : public nsAccessNodeWrap, 
    1:                      public nsIAccessible, 
    1:                      public nsIAccessibleHyperLink,
    1:                      public nsIAccessibleSelectable,
    1:                      public nsIAccessibleValue
    1: {
    1: public:
43504:   nsAccessible(nsIContent *aContent, nsIWeakReference *aShell);
    1:   virtual ~nsAccessible();
    1: 
    1:   NS_DECL_ISUPPORTS_INHERITED
16428:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED(nsAccessible, nsAccessNode)
16428: 
    1:   NS_DECL_NSIACCESSIBLE
    1:   NS_DECL_NSIACCESSIBLEHYPERLINK
    1:   NS_DECL_NSIACCESSIBLESELECTABLE
    1:   NS_DECL_NSIACCESSIBLEVALUE
41384:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_ACCESSIBLE_IMPL_IID)
    1: 
21169:   //////////////////////////////////////////////////////////////////////////////
21169:   // nsAccessNode
21169: 
43538:   virtual void Shutdown();
    1: 
20246:   //////////////////////////////////////////////////////////////////////////////
20246:   // Public methods
20246: 
20246:   /**
20246:    * Returns the accessible name specified by ARIA.
20246:    */
20246:   nsresult GetARIAName(nsAString& aName);
20246: 
20246:   /**
29320:    * Maps ARIA state attributes to state of accessible. Note the given state
29320:    * argument should hold states for accessible before you pass it into this
29320:    * method.
29320:    *
29320:    * @param  [in/out] where to fill the states into.
29565:    * @param  [in/out] where to fill the extra states into
29320:    */
29565:   virtual nsresult GetARIAState(PRUint32 *aState, PRUint32 *aExtraState);
29320: 
29320:   /**
20246:    * Returns the accessible name provided by native markup. It doesn't take
22844:    * into account ARIA markup used to specify the name.
22844:    *
22844:    * @param  aName             [out] the accessible name
22844:    *
22844:    * @return NS_OK_EMPTY_NAME  points empty name was specified by native markup
22844:    *                           explicitly (see nsIAccessible::name attribute for
22844:    *                           details)
20246:    */
20246:   virtual nsresult GetNameInternal(nsAString& aName);
20246: 
  262:   /**
52053:    * Return enumerated accessible role (see constants in nsIAccessibleRole).
52053:    */
58433:   inline PRUint32 Role()
58433:   {
58433:     if (!mRoleMapEntry || mRoleMapEntry->roleRule != kUseMapRole)
58433:       return NativeRole();
58433: 
58433:     return ARIARoleInternal();
58433:   }
58433: 
58433:   /**
58433:    * Return accessible role specified by ARIA (see constants in
58433:    * nsIAccessibleRole).
58433:    */
58433:   inline PRUint32 ARIARole()
58433:   {
58433:     if (!mRoleMapEntry || mRoleMapEntry->roleRule != kUseMapRole)
58433:       return nsIAccessibleRole::ROLE_NOTHING;
58433: 
58433:     return ARIARoleInternal();
58433:   }
52053: 
52053:   /**
25822:    * Returns enumerated accessible role from native markup (see constants in
25822:    * nsIAccessibleRole). Doesn't take into account ARIA roles.
25822:    */
52027:   virtual PRUint32 NativeRole();
25822: 
25822:   /**
  262:    * Return the state of accessible that doesn't take into account ARIA states.
21256:    * Use nsIAccessible::state to get all states for accessible. If
  262:    * second argument is omitted then second bit field of accessible state won't
  262:    * be calculated.
  262:    */
21256:   virtual nsresult GetStateInternal(PRUint32 *aState, PRUint32 *aExtraState);
  262: 
  262:   /**
  401:    * Returns attributes for accessible without explicitly setted ARIA
  401:    * attributes.
  401:    */
  401:   virtual nsresult GetAttributesInternal(nsIPersistentProperties *aAttributes);
  401: 
28197:   /**
28197:    * Return direct or deepest child at the given point.
28197:    *
28197:    * @param  aX             [in] x coordinate relative screen
28197:    * @param  aY             [in] y coordinate relative screen
28197:    * @param  aDeepestChild  [in] flag points if deep child should be returned
28197:    * @param  aChild         [out] found child
28197:    */
28197:   virtual nsresult GetChildAtPoint(PRInt32 aX, PRInt32 aY,
28197:                                    PRBool aDeepestChild,
28197:                                    nsIAccessible **aChild);
28197: 
36879:   /**
36879:    * Return calculated group level based on accessible hierarchy.
36879:    */
36879:   virtual PRInt32 GetLevelInternal();
36879: 
36879:   /**
36879:    * Calculate position in group and group size ('posinset' and 'setsize') based
36879:    * on accessible hierarchy.
36879:    *
36879:    * @param  aPosInSet  [out] accessible position in the group
36879:    * @param  aSetSize   [out] the group size
36879:    */
36879:   virtual void GetPositionAndSizeInternal(PRInt32 *aPosInSet,
36879:                                           PRInt32 *aSetSize);
36879: 
20246:   //////////////////////////////////////////////////////////////////////////////
35523:   // Initializing methods
29320: 
29320:   /**
29320:    * Set the ARIA role map entry for a new accessible.
29320:    * For a newly created accessible, specify which role map entry should be used.
29320:    *
29320:    * @param aRoleMapEntry The ARIA nsRoleMapEntry* for the accessible, or 
29320:    *                      nsnull if none.
29320:    */
29320:   virtual void SetRoleMapEntry(nsRoleMapEntry *aRoleMapEntry);
29320: 
29320:   /**
61359:    * Update the children cache.
61359:    */
61359:   inline bool UpdateChildren()
61359:   {
61359:     InvalidateChildren();
61359:     return EnsureChildren();
61359:   }
61359: 
61359:   /**
40575:    * Cache children if necessary. Return true if the accessible is defunct.
40575:    */
61463:   bool EnsureChildren();
40575: 
40575:   /**
35523:    * Set the child count to -1 (unknown) and null out cached child pointers.
35523:    * Should be called when accessible tree is changed because document has
47105:    * transformed. Note, if accessible cares about its parent relation chain
47105:    * itself should override this method to do nothing.
29320:    */
29320:   virtual void InvalidateChildren();
29320: 
43310:   /**
47105:    * Append/insert/remove a child. Return true if operation was successful.
43310:    */
47105:   virtual PRBool AppendChild(nsAccessible* aChild);
47105:   virtual PRBool InsertChildAt(PRUint32 aIndex, nsAccessible* aChild);
47105:   virtual PRBool RemoveChild(nsAccessible* aChild);
43310: 
35523:   //////////////////////////////////////////////////////////////////////////////
35523:   // Accessible tree traverse methods
35523: 
35523:   /**
35523:    * Return parent accessible.
35523:    */
61582:   nsAccessible* GetParent() const { return mParent; }
35523: 
35523:   /**
35523:    * Return child accessible at the given index.
35523:    */
36989:   virtual nsAccessible* GetChildAt(PRUint32 aIndex);
35523: 
35523:   /**
35523:    * Return child accessible count.
35523:    */
35523:   virtual PRInt32 GetChildCount();
35523: 
35523:   /**
35523:    * Return index of the given child accessible.
35523:    */
47105:   virtual PRInt32 GetIndexOf(nsAccessible* aChild);
35523: 
35523:   /**
35523:    * Return index in parent accessible.
35523:    */
61639:   virtual PRInt32 GetIndexInParent() const;
35523: 
29320:   /**
42530:    * Return true if accessible has children;
42530:    */
42530:   PRBool HasChildren() { return !!GetChildAt(0); }
42530: 
42530:   /**
50622:    * Return embedded accessible children count.
50622:    */
50622:   PRInt32 GetEmbeddedChildCount();
50622: 
50622:   /**
50622:    * Return embedded accessible child at the given index.
50622:    */
50622:   nsAccessible* GetEmbeddedChildAt(PRUint32 aIndex);
50622: 
50622:   /**
50622:    * Return index of the given embedded accessible child.
50622:    */
50622:   PRInt32 GetIndexOfEmbeddedChild(nsAccessible* aChild);
50622: 
50622:   /**
46469:    * Return cached accessible of parent-child relatives.
29320:    */
47106:   nsAccessible* GetCachedNextSibling() const
47106:   {
47106:     return mParent ?
47124:       mParent->mChildren.SafeElementAt(mIndexInParent + 1, nsnull).get() : nsnull;
47106:   }
47106:   nsAccessible* GetCachedPrevSibling() const
47106:   {
47106:     return mParent ?
47124:       mParent->mChildren.SafeElementAt(mIndexInParent - 1, nsnull).get() : nsnull;
47106:   }
47105:   PRUint32 GetCachedChildCount() const { return mChildren.Length(); }
56292:   nsAccessible* GetCachedChildAt(PRUint32 aIndex) const { return mChildren.ElementAt(aIndex); }
61466:   inline bool AreChildrenCached() const
61466:     { return !IsChildrenFlag(eChildrenUninitialized); }
61463:   bool IsBoundToParent() const { return !!mParent; }
29320: 
29320:   //////////////////////////////////////////////////////////////////////////////
35523:   // Miscellaneous methods
29320: 
29320:   /**
37299:    * Handle accessible event, i.e. process it, notifies observers and fires
37299:    * platform specific event.
29320:    */
51377:   virtual nsresult HandleAccEvent(AccEvent* aAccEvent);
29320: 
29320:   /**
29320:    * Return true if there are accessible children in anonymous content
29320:    */
29320:   virtual PRBool GetAllowsAnonChildAccessibles();
29320: 
29320:   /**
29320:    * Returns text of accessible if accessible has text role otherwise empty
29320:    * string.
29320:    *
61682:    * @param aText         [in] returned text of the accessible
61682:    * @param aStartOffset  [in, optional] start offset inside of the accessible,
61682:    *                        if missed entire text is appended
61682:    * @param aLength       [in, optional] required length of text, if missed
61682:    *                        then text form start offset till the end is appended
29320:    */
61682:   virtual void AppendTextTo(nsAString& aText, PRUint32 aStartOffset = 0,
61682:                             PRUint32 aLength = PR_UINT32_MAX);
29320: 
38000:   /**
39144:    * Assert if child not in parent's cache if the cache was initialized at this
39144:    * point.
38000:    */
61461:   void TestChildCache(nsAccessible* aCachedChild) const;
38000: 
51810:   //////////////////////////////////////////////////////////////////////////////
61467:   // Downcasting
61467: 
62919:   inline bool IsApplication() const { return mFlags & eApplicationAccessible; }
62919: 
61467:   inline bool IsHyperText() const { return mFlags & eHyperTextAccessible; }
61467:   nsHyperTextAccessible* AsHyperText();
61467: 
64006:   inline bool IsHTMLListItem() const { return mFlags & eHTMLListItemAccessible; }
64006:   nsHTMLLIAccessible* AsHTMLListItem();
64006: 
63248:   inline bool IsRoot() const { return mFlags & eRootAccessible; }
63248:   nsRootAccessible* AsRoot();
63248: 
61638:   inline bool IsTextLeaf() const { return mFlags & eTextLeafAccessible; }
61638:   nsTextAccessible* AsTextLeaf();
61638: 
61467:   //////////////////////////////////////////////////////////////////////////////
51810:   // HyperLinkAccessible
51810: 
51810:   /**
51810:    * Return true if the accessible is hyper link accessible.
51810:    */
51810:   virtual bool IsHyperLink();
51810: 
51810:   /**
51810:    * Return the start offset of the link within the parent accessible.
51810:    */
51810:   virtual PRUint32 StartOffset();
51810: 
51810:   /**
51810:    * Return the end offset of the link within the parent accessible.
51810:    */
51810:   virtual PRUint32 EndOffset();
51810: 
51810:   /**
51810:    * Return true if the link is valid (e. g. points to a valid URL).
51810:    */
51810:   virtual bool IsValid();
51810: 
51810:   /**
51810:    * Return true if the link currently has the focus.
51810:    */
51810:   virtual bool IsSelected();
51810: 
51810:   /**
51810:    * Return the number of anchors within the link.
51810:    */
51810:   virtual PRUint32 AnchorCount();
51810: 
51810:   /**
51810:    * Returns an anchor accessible at the given index.
51810:    */
51810:   virtual nsAccessible* GetAnchor(PRUint32 aAnchorIndex);
51810: 
51810:   /**
51810:    * Returns an anchor URI at the given index.
51810:    */
51810:   virtual already_AddRefed<nsIURI> GetAnchorURI(PRUint32 aAnchorIndex);
51810: 
51865:   //////////////////////////////////////////////////////////////////////////////
51865:   // SelectAccessible
51865: 
51865:   /**
51865:    * Return true if the accessible is a select control containing selectable
51865:    * items.
51865:    */
51865:   virtual bool IsSelect();
51865: 
51865:   /**
51865:    * Return an array of selected items.
51865:    */
51865:   virtual already_AddRefed<nsIArray> SelectedItems();
51865: 
51865:   /**
51865:    * Return the number of selected items.
51865:    */
51865:   virtual PRUint32 SelectedItemCount();
51865: 
51865:   /**
51865:    * Return selected item at the given index.
51865:    */
51865:   virtual nsAccessible* GetSelectedItem(PRUint32 aIndex);
51865: 
51865:   /**
51865:    * Determine if item at the given index is selected.
51865:    */
51865:   virtual bool IsItemSelected(PRUint32 aIndex);
51865: 
51865:   /**
51865:    * Add item at the given index the selection. Return true if success.
51865:    */
51865:   virtual bool AddItemToSelection(PRUint32 aIndex);
51865: 
51865:   /**
51865:    * Remove item at the given index from the selection. Return if success.
51865:    */
51865:   virtual bool RemoveItemFromSelection(PRUint32 aIndex);
51865: 
51865:   /**
51865:    * Select all items. Return true if success.
51865:    */
51865:   virtual bool SelectAll();
51865: 
51865:   /**
51865:    * Unselect all items. Return true if success.
51865:    */
51865:   virtual bool UnselectAll();
51865: 
35523: protected:
35523: 
35136:   //////////////////////////////////////////////////////////////////////////////
35523:   // Initializing, cache and tree traverse methods
35136: 
35523:   /**
35523:    * Cache accessible children.
35523:    */
35523:   virtual void CacheChildren();
35136: 
35523:   /**
47105:    * Set accessible parent and index in parent.
47105:    */
57414:   virtual void BindToParent(nsAccessible* aParent, PRUint32 aIndexInParent);
47803:   void UnbindFromParent();
47105: 
47105:   /**
35523:    * Return sibling accessible at the given offset.
35523:    */
39191:   virtual nsAccessible* GetSiblingAtOffset(PRInt32 aOffset,
35523:                                            nsresult *aError = nsnull);
35523: 
61466:   /**
61466:    * Flags used to describe the state and type of children.
61466:    */
61466:   enum ChildrenFlags {
61466:     eChildrenUninitialized = 0, // children aren't initialized
61466:     eMixedChildren = 1 << 0, // text leaf children are presented
61466:     eEmbeddedChildren = 1 << 1 // all children are embedded objects
61466:   };
61466: 
61466:   /**
61466:    * Return true if the children flag is set.
61466:    */
61466:   inline bool IsChildrenFlag(ChildrenFlags aFlag) const
61466:     { return (mFlags & kChildrenFlagsMask) == aFlag; }
61466: 
61466:   /**
61466:    * Set children flag.
61466:    */
61466:   inline void SetChildrenFlag(ChildrenFlags aFlag)
61466:     { mFlags = (mFlags & ~kChildrenFlagsMask) | aFlag; }
61466: 
61467:   /**
61467:    * Flags describing the accessible itself.
61467:    * @note keep these flags in sync with ChildrenFlags
61467:    */
61467:   enum AccessibleTypes {
62919:     eApplicationAccessible = 1 << 2,
62919:     eHyperTextAccessible = 1 << 3,
64006:     eHTMLListItemAccessible = 1 << 4,
64006:     eRootAccessible = 1 << 5,
64006:     eTextLeafAccessible = 1 << 6
61467:   };
61467: 
35523:   //////////////////////////////////////////////////////////////////////////////
35523:   // Miscellaneous helpers
35523: 
58433:   /**
58433:    * Return ARIA role (helper method).
58433:    */
58433:   PRUint32 ARIARoleInternal();
58433: 
    1:   virtual nsIFrame* GetBoundsFrame();
    1:   virtual void GetBoundsRect(nsRect& aRect, nsIFrame** aRelativeFrame);
    1:   PRBool IsVisible(PRBool *aIsOffscreen); 
    1: 
22204:   //////////////////////////////////////////////////////////////////////////////
35523:   // Name helpers
22204: 
22204:   /**
22204:    * Compute the name of HTML node.
22204:    */
22204:   nsresult GetHTMLName(nsAString& aName);
22204: 
22204:   /**
22204:    * Compute the name for XUL node.
22204:    */
22204:   nsresult GetXULName(nsAString& aName);
22204: 
    1:   // helper method to verify frames
    1:   static nsresult GetFullKeyName(const nsAString& aModifierName, const nsAString& aKeyName, nsAString& aStringOut);
    1:   static nsresult GetTranslatedString(const nsAString& aKey, nsAString& aStringOut);
15971: 
    1:   /**
34455:    * Return an accessible for the given DOM node, or if that node isn't
34455:    * accessible, return the accessible for the next DOM node which has one
34455:    * (based on forward depth first search).
34455:    *
34455:    * @param  aStartNode  [in] the DOM node to start from
    1:    * @return              the resulting accessible
    1:    */
43504:   nsAccessible *GetFirstAvailableAccessible(nsINode *aStartNode) const;
    1: 
31673:   //////////////////////////////////////////////////////////////////////////////
31673:   // Action helpers
31673: 
31673:   /**
31673:    * Prepares click action that will be invoked in timeout.
31673:    *
31673:    * @note  DoCommand() prepares an action in timeout because when action
31673:    *  command opens a modal dialog/window, it won't return until the
31673:    *  dialog/window is closed. If executing action command directly in
31673:    *  nsIAccessible::DoAction() method, it will block AT tools (e.g. GOK) that
31673:    *  invoke action of mozilla accessibles direclty (see bug 277888 for details).
31673:    *
31673:    * @param  aContent      [in, optional] element to click
31673:    * @param  aActionIndex  [in, optional] index of accessible action
31673:    */
37481:   void DoCommand(nsIContent *aContent = nsnull, PRUint32 aActionIndex = 0);
31673: 
31673:   /**
31673:    * Dispatch click event.
31673:    */
31673:   virtual void DispatchClickEvent(nsIContent *aContent, PRUint32 aActionIndex);
31673: 
37480:   NS_DECL_RUNNABLEMETHOD_ARG2(nsAccessible, DispatchClickEvent,
37480:                               nsCOMPtr<nsIContent>, PRUint32)
37480: 
31673:   //////////////////////////////////////////////////////////////////////////////
31673:   // Helpers
    1: 
    1:   // Check the visibility across both parent content and chrome
    1:   PRBool CheckVisibilityInParentChain(nsIDocument* aDocument, nsIView* aView);
    1: 
 4274:   /**
 8937:    *  Get the container node for an atomic region, defined by aria-atomic="true"
 6066:    *  @return the container node
 6066:    */
 6066:   nsIDOMNode* GetAtomicRegion();
 6066: 
 6066:   /**
 6279:    * Get numeric value of the given ARIA attribute.
 4274:    *
 6279:    * @param aAriaProperty - the ARIA property we're using
 4274:    * @param aValue - value of the attribute
 4274:    *
 4274:    * @return - NS_OK_NO_ARIA_VALUE if there is no setted ARIA attribute
 4274:    */
 8937:   nsresult GetAttrValue(nsIAtom *aAriaProperty, double *aValue);
 4274: 
15375:   /**
20140:    * Return the action rule based on ARIA enum constants EActionRule
20140:    * (see nsARIAMap.h). Used by GetNumActions() and GetActionName().
20140:    *
20140:    * @param aStates  [in] states of the accessible
20140:    */
20140:   PRUint32 GetActionRule(PRUint32 aStates);
20140: 
20140:   /**
47172:    * Return group info.
47172:    */
47172:   AccGroupInfo* GetGroupInfo();
47172: 
47172:   /**
15375:    * Fires platform accessible event. It's notification method only. It does
37299:    * change nothing on Gecko side. Don't use it until you're sure what you do
37299:    * (see example in XUL tree accessible), use nsEventShell::FireEvent()
37299:    * instead. MUST be overridden in wrap classes.
15375:    *
15375:    * @param aEvent  the accessible event to fire.
15375:    */
51377:   virtual nsresult FirePlatformEvent(AccEvent* aEvent) = 0;
15375: 
    1:   // Data Members
36989:   nsRefPtr<nsAccessible> mParent;
36989:   nsTArray<nsRefPtr<nsAccessible> > mChildren;
47105:   PRInt32 mIndexInParent;
16428: 
61466:   static const PRUint32 kChildrenFlagsMask =
61466:     eChildrenUninitialized | eMixedChildren | eEmbeddedChildren;
61466: 
61466:   PRUint32 mFlags;
50622: 
50622:   nsAutoPtr<EmbeddedObjCollector> mEmbeddedObjCollector;
50622:   PRInt32 mIndexOfEmbeddedChild;
50622:   friend class EmbeddedObjCollector;
50622: 
47172:   nsAutoPtr<AccGroupInfo> mGroupInfo;
47172:   friend class AccGroupInfo;
47172: 
    1:   nsRoleMapEntry *mRoleMapEntry; // Non-null indicates author-supplied role; possibly state & value as well
    1: };
    1: 
20246: NS_DEFINE_STATIC_IID_ACCESSOR(nsAccessible,
41384:                               NS_ACCESSIBLE_IMPL_IID)
    1: 
    1: #endif
