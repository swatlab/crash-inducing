     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim: set ts=2 sw=2 et tw=80: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
134925: #include "mozilla/Attributes.h"
193672: #include "mozilla/EventDispatcher.h"
196025: #include "mozilla/EventStateManager.h"
196390: #include "mozilla/EventStates.h"
190851: #include "mozilla/IMEStateManager.h"
163419: #include "mozilla/MiscEvents.h"
134925: #include "mozilla/MathAlgorithms.h"
163417: #include "mozilla/MouseEvents.h"
197484: #include "mozilla/TextComposition.h"
163418: #include "mozilla/TextEvents.h"
163416: #include "mozilla/TouchEvents.h"
190116: #include "mozilla/dom/Event.h"
 54603: #include "mozilla/dom/TabParent.h"
189485: #include "mozilla/dom/UIEvent.h"
 50731: 
191142: #include "ContentEventHandler.h"
199390: #include "IMEContentObserver.h"
196021: #include "WheelHandlingHelper.h"
191142: 
     1: #include "nsCOMPtr.h"
166503: #include "nsFocusManager.h"
     1: #include "nsIContent.h"
     1: #include "nsIDocument.h"
     1: #include "nsIFrame.h"
     1: #include "nsIWidget.h"
     1: #include "nsPresContext.h"
     1: #include "nsIPresShell.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsIFormControl.h"
     1: #include "nsIComboboxControlFrame.h"
 31443: #include "nsIScrollableFrame.h"
 81041: #include "nsIDOMHTMLElement.h"
     1: #include "nsIDOMXULControlElement.h"
189329: #include "nsNameSpaceManager.h"
     1: #include "nsIBaseWindow.h"
     1: #include "nsISelection.h"
179647: #include "nsITextControlElement.h"
     1: #include "nsFrameSelection.h"
     1: #include "nsPIDOMWindow.h"
 38336: #include "nsPIWindowRoot.h"
     1: #include "nsIWebNavigation.h"
     1: #include "nsIContentViewer.h"
 37058: #include "nsFrameManager.h"
     1: 
     1: #include "nsIDOMXULElement.h"
     1: #include "nsIDOMKeyEvent.h"
     1: #include "nsIObserverService.h"
     1: #include "nsIDocShell.h"
108059: #include "nsIDOMWheelEvent.h"
 18445: #include "nsIDOMDragEvent.h"
 77226: #include "nsIDOMUIEvent.h"
 96948: #include "nsIMozBrowserFrame.h"
     1: 
 51754: #include "nsSubDocumentFrame.h"
     1: #include "nsLayoutUtils.h"
     1: #include "nsIInterfaceRequestorUtils.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsContentUtils.h"
     1: 
     1: #include "imgIContainer.h"
     1: #include "nsIProperties.h"
     1: #include "nsISupportsPrimitives.h"
     1: 
  7093: #include "nsServiceManagerUtils.h"
  7093: #include "nsITimer.h"
 68493: #include "nsFontMetrics.h"
 23192: #include "nsIDOMXULDocument.h"
 18445: #include "nsIDragService.h"
 18445: #include "nsIDragSession.h"
189110: #include "mozilla/dom/DataTransfer.h"
 18445: #include "nsContentAreaDragDrop.h"
 18445: #ifdef MOZ_XUL
 20988: #include "nsTreeBodyFrame.h"
 18445: #endif
 31218: #include "nsIController.h"
 36983: #include "nsICommandParams.h"
 41540: #include "mozilla/Services.h"
126764: #include "mozilla/dom/HTMLLabelElement.h"
 18445: 
 70840: #include "mozilla/Preferences.h"
 78124: #include "mozilla/LookAndFeel.h"
137339: #include "GeckoProfiler.h"
151336: #include "Units.h"
 95203: 
     1: #ifdef XP_MACOSX
 32855: #import <ApplicationServices/ApplicationServices.h>
     1: #endif
     1: 
196027: namespace mozilla {
196027: 
196027: using namespace dom;
 54603: 
     1: //#define DEBUG_DOCSHELL_FOCUS
     1: 
  7093: #define NS_USER_INTERACTION_INTERVAL 5000 // ms
  7093: 
154119: static const LayoutDeviceIntPoint kInvalidRefPoint = LayoutDeviceIntPoint(-1,-1);
115570: 
108991: static uint32_t gMouseOrKeyboardEventCounter = 0;
106838: static nsITimer* gUserInteractionTimer = nullptr;
106838: static nsITimerCallback* gUserInteractionTimerCallback = nullptr;
  7093: 
108991: static inline int32_t
108059: RoundDown(double aDouble)
108059: {
108991:   return (aDouble > 0) ? static_cast<int32_t>(floor(aDouble)) :
108991:                          static_cast<int32_t>(ceil(aDouble));
108059: }
108059: 
 21191: #ifdef DEBUG_DOCSHELL_FOCUS
 21191: static void
 21191: PrintDocTree(nsIDocShellTreeItem* aParentItem, int aLevel)
 21191: {
108991:   for (int32_t i=0;i<aLevel;i++) printf("  ");
108991: 
108991:   int32_t childWebshellCount;
 21191:   aParentItem->GetChildCount(&childWebshellCount);
 21191:   nsCOMPtr<nsIDocShell> parentAsDocShell(do_QueryInterface(aParentItem));
181250:   int32_t type = aParentItem->ItemType();
127381:   nsCOMPtr<nsIPresShell> presShell = parentAsDocShell->GetPresShell();
 39823:   nsRefPtr<nsPresContext> presContext;
 21191:   parentAsDocShell->GetPresContext(getter_AddRefs(presContext));
 21191:   nsCOMPtr<nsIContentViewer> cv;
 21191:   parentAsDocShell->GetContentViewer(getter_AddRefs(cv));
 21191:   nsCOMPtr<nsIDOMDocument> domDoc;
 21191:   if (cv)
 21191:     cv->GetDOMDocument(getter_AddRefs(domDoc));
 21191:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
106838:   nsCOMPtr<nsIDOMWindow> domwin = doc ? doc->GetWindow() : nullptr;
106838:   nsIURI* uri = doc ? doc->GetDocumentURI() : nullptr;
 21191: 
 21191:   printf("DS %p  Type %s  Cnt %d  Doc %p  DW %p  EM %p%c",
 21191:     static_cast<void*>(parentAsDocShell.get()),
 21191:     type==nsIDocShellTreeItem::typeChrome?"Chrome":"Content",
 21191:     childWebshellCount, static_cast<void*>(doc.get()),
 21191:     static_cast<void*>(domwin.get()),
106838:     static_cast<void*>(presContext ? presContext->EventStateManager() : nullptr),
 21191:     uri ? ' ' : '\n');
 21191:   if (uri) {
110974:     nsAutoCString spec;
 21191:     uri->GetSpec(spec);
 21191:     printf("\"%s\"\n", spec.get());
 21191:   }
 21191: 
 21191:   if (childWebshellCount > 0) {
108991:     for (int32_t i = 0; i < childWebshellCount; i++) {
 21191:       nsCOMPtr<nsIDocShellTreeItem> child;
 21191:       aParentItem->GetChildAt(i, getter_AddRefs(child));
 21191:       PrintDocTree(child, aLevel + 1);
 21191:     }
 21191:   }
 21191: }
 21191: 
 21191: static void
 21191: PrintDocTreeAll(nsIDocShellTreeItem* aItem)
 21191: {
 21191:   nsCOMPtr<nsIDocShellTreeItem> item = aItem;
 21191:   for(;;) {
 21191:     nsCOMPtr<nsIDocShellTreeItem> parent;
 21191:     item->GetParent(getter_AddRefs(parent));
 21191:     if (!parent)
 21191:       break;
 21191:     item = parent;
 21191:   }
 21191: 
 21191:   PrintDocTree(item, 0);
 21191: }
 21191: #endif
 21191: 
196027: // mask values for ui.key.chromeAccess and ui.key.contentAccess
196027: #define NS_MODIFIER_SHIFT    1
196027: #define NS_MODIFIER_CONTROL  2
196027: #define NS_MODIFIER_ALT      4
196027: #define NS_MODIFIER_META     8
196027: #define NS_MODIFIER_OS       16
196027: 
196027: static nsIDocument *
196027: GetDocumentFromWindow(nsIDOMWindow *aWindow)
196027: {
196027:   nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(aWindow);
196027:   return win ? win->GetExtantDoc() : nullptr;
196027: }
196027: 
196027: /******************************************************************/
196027: /* mozilla::UITimerCallback                                       */
196027: /******************************************************************/
196027: 
196027: class UITimerCallback MOZ_FINAL : public nsITimerCallback
  7093: {
  7093: public:
196027:   UITimerCallback() : mPreviousCount(0) {}
  7093:   NS_DECL_ISUPPORTS
  7093:   NS_DECL_NSITIMERCALLBACK
  7093: private:
212223:   ~UITimerCallback() {}
108991:   uint32_t mPreviousCount;
  7093: };
  7093: 
200047: NS_IMPL_ISUPPORTS(UITimerCallback, nsITimerCallback)
  7093: 
106838: // If aTimer is nullptr, this method always sends "user-interaction-inactive"
  7093: // notification.
  7093: NS_IMETHODIMP
196027: UITimerCallback::Notify(nsITimer* aTimer)
  7093: {
  7093:   nsCOMPtr<nsIObserverService> obs =
 41540:     mozilla::services::GetObserverService();
 41540:   if (!obs)
 41540:     return NS_ERROR_FAILURE;
  7093:   if ((gMouseOrKeyboardEventCounter == mPreviousCount) || !aTimer) {
  7093:     gMouseOrKeyboardEventCounter = 0;
106838:     obs->NotifyObservers(nullptr, "user-interaction-inactive", nullptr);
 57074:     if (gUserInteractionTimer) {
 57074:       gUserInteractionTimer->Cancel();
 57074:       NS_RELEASE(gUserInteractionTimer);
 57074:     }
  7093:   } else {
106838:     obs->NotifyObservers(nullptr, "user-interaction-active", nullptr);
196025:     EventStateManager::UpdateUserActivityTimer();
  7093:   }
  7093:   mPreviousCount = gMouseOrKeyboardEventCounter;
  7093:   return NS_OK;
  7093: }
  7093: 
165307: /******************************************************************/
196026: /* mozilla::OverOutElementsWrapper                                */
186255: /******************************************************************/
186255: 
196025: OverOutElementsWrapper::OverOutElementsWrapper()
196025:   : mLastOverFrame(nullptr)
196025: {
196025: }
196025: 
196025: OverOutElementsWrapper::~OverOutElementsWrapper()
196025: {
196025: }
196025: 
199997: NS_IMPL_CYCLE_COLLECTION(OverOutElementsWrapper,
186255:                          mLastOverElement,
186255:                          mFirstOverEventElement,
186255:                          mFirstOutEventElement)
186255: NS_IMPL_CYCLE_COLLECTING_ADDREF(OverOutElementsWrapper)
186255: NS_IMPL_CYCLE_COLLECTING_RELEASE(OverOutElementsWrapper)
186255: 
186255: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(OverOutElementsWrapper)
186255:   NS_INTERFACE_MAP_ENTRY(nsISupports)
186255: NS_INTERFACE_MAP_END
186255: 
186255: /******************************************************************/
196025: /* mozilla::EventStateManager                                     */
186255: /******************************************************************/
196025: 
196025: static uint32_t sESMInstanceCount = 0;
211244: static bool sPointerEventEnabled = false;
196025: 
196025: int32_t EventStateManager::sUserInputEventDepth = 0;
196025: bool EventStateManager::sNormalLMouseEventInProcess = false;
196025: EventStateManager* EventStateManager::sActiveESM = nullptr;
196025: nsIDocument* EventStateManager::sMouseOverDocument = nullptr;
196025: nsWeakFrame EventStateManager::sLastDragOverFrame = nullptr;
196025: LayoutDeviceIntPoint EventStateManager::sLastRefPoint = kInvalidRefPoint;
196025: nsIntPoint EventStateManager::sLastScreenPoint = nsIntPoint(0, 0);
196025: LayoutDeviceIntPoint EventStateManager::sSynthCenteringPoint = kInvalidRefPoint;
196025: CSSIntPoint EventStateManager::sLastClientPoint = CSSIntPoint(0, 0);
196025: bool EventStateManager::sIsPointerLocked = false;
196025: // Reference to the pointer locked element.
196025: nsWeakPtr EventStateManager::sPointerLockedElement;
196025: // Reference to the document which requested pointer lock.
196025: nsWeakPtr EventStateManager::sPointerLockedDoc;
196025: nsCOMPtr<nsIContent> EventStateManager::sDragOverContent = nullptr;
196025: TimeStamp EventStateManager::sHandlingInputStart;
196025: 
196025: EventStateManager::WheelPrefs*
196025:   EventStateManager::WheelPrefs::sInstance = nullptr;
196025: EventStateManager::DeltaAccumulator*
196025:   EventStateManager::DeltaAccumulator::sInstance = nullptr;
196025: 
196025: EventStateManager::EventStateManager()
196025:   : mLockCursor(0)
196025:   , mPreLockPoint(0,0)
196025:   , mCurrentTarget(nullptr)
     1:     // init d&d gesture state machine variables
196025:   , mGestureDownPoint(0,0)
196025:   , mPresContext(nullptr)
196025:   , mLClickCount(0)
196025:   , mMClickCount(0)
196025:   , mRClickCount(0)
196025:   , m_haveShutdown(false)
     1: {
  7093:   if (sESMInstanceCount == 0) {
196027:     gUserInteractionTimerCallback = new UITimerCallback();
 57074:     if (gUserInteractionTimerCallback)
  7093:       NS_ADDREF(gUserInteractionTimerCallback);
 57074:     UpdateUserActivityTimer();
 57074:   }
 57074:   ++sESMInstanceCount;
211244: 
211244:   static bool sAddedPointerEventEnabled = false;
211244:   if (!sAddedPointerEventEnabled) {
211244:     Preferences::AddBoolVarCache(&sPointerEventEnabled,
211244:                                  "dom.w3c_pointer_events.enabled", false);
211244:     sAddedPointerEventEnabled = true;
211244:   }
 57074: }
 57074: 
 57074: nsresult
196025: EventStateManager::UpdateUserActivityTimer()
 57074: {
 57074:   if (!gUserInteractionTimerCallback)
 57074:     return NS_OK;
 57074: 
 57074:   if (!gUserInteractionTimer)
  7093:     CallCreateInstance("@mozilla.org/timer;1", &gUserInteractionTimer);
 57074: 
  7093:   if (gUserInteractionTimer) {
  7093:     gUserInteractionTimer->InitWithCallback(gUserInteractionTimerCallback,
  7093:                                             NS_USER_INTERACTION_INTERVAL,
 57074:                                             nsITimer::TYPE_ONE_SHOT);
 57074:   }
 57074:   return NS_OK;
     1: }
     1: 
 68780: nsresult
196025: EventStateManager::Init()
     1: {
     1:   nsCOMPtr<nsIObserverService> observerService =
 41540:     mozilla::services::GetObserverService();
 41540:   if (!observerService)
 41540:     return NS_ERROR_FAILURE;
     1: 
 80486:   observerService->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, true);
     1: 
     1:   if (sESMInstanceCount == 1) {
157647:     Prefs::Init();
157647:   }
     1: 
 41540:   return NS_OK;
     1: }
     1: 
196025: EventStateManager::~EventStateManager()
     1: {
199390:   ReleaseCurrentIMEContentObserver();
199390: 
 54151:   if (sActiveESM == this) {
106838:     sActiveESM = nullptr;
 54151:   }
157647:   if (Prefs::ClickHoldContextMenu())
     1:     KillClickHoldTimer();
     1: 
 54257:   if (mDocument == sMouseOverDocument)
106838:     sMouseOverDocument = nullptr;
 54257: 
     1:   --sESMInstanceCount;
     1:   if(sESMInstanceCount == 0) {
196023:     WheelTransaction::Shutdown();
  7093:     if (gUserInteractionTimerCallback) {
106838:       gUserInteractionTimerCallback->Notify(nullptr);
  7093:       NS_RELEASE(gUserInteractionTimerCallback);
  7093:     }
  7093:     if (gUserInteractionTimer) {
  7093:       gUserInteractionTimer->Cancel();
  7093:       NS_RELEASE(gUserInteractionTimer);
  7093:     }
157647:     Prefs::Shutdown();
108052:     WheelPrefs::Shutdown();
108061:     DeltaAccumulator::Shutdown();
     1:   }
     1: 
 80526:   if (sDragOverContent && sDragOverContent->OwnerDoc() == mDocument) {
106838:     sDragOverContent = nullptr;
 79435:   }
 79435: 
     1:   if (!m_haveShutdown) {
     1:     Shutdown();
     1: 
     1:     // Don't remove from Observer service in Shutdown because Shutdown also
     1:     // gets called from xpcom shutdown observer.  And we don't want to remove
     1:     // from the service in that case.
     1: 
     1:     nsCOMPtr<nsIObserverService> observerService =
 41540:       mozilla::services::GetObserverService();
 41540:     if (observerService) {
     1:       observerService->RemoveObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID);
     1:     }
     1:   }
     1: 
     1: }
     1: 
     1: nsresult
196025: EventStateManager::Shutdown()
     1: {
 80486:   m_haveShutdown = true;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
196025: EventStateManager::Observe(nsISupports* aSubject,
     1:                            const char* aTopic,
179103:                            const char16_t *someData)
     1: {
157647:   if (!nsCRT::strcmp(aTopic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)) {
     1:     Shutdown();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
196025: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(EventStateManager)
 68780:    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIObserver)
  4484:    NS_INTERFACE_MAP_ENTRY(nsIObserver)
  4484:    NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
  4484: NS_INTERFACE_MAP_END
  4484: 
196025: NS_IMPL_CYCLE_COLLECTING_ADDREF(EventStateManager)
196025: NS_IMPL_CYCLE_COLLECTING_RELEASE(EventStateManager)
196025: 
199997: NS_IMPL_CYCLE_COLLECTION(EventStateManager,
139718:                          mCurrentTargetContent,
139718:                          mGestureDownContent,
139718:                          mGestureDownFrameOwner,
139718:                          mLastLeftMouseDownContent,
139718:                          mLastLeftMouseDownContentParent,
139718:                          mLastMiddleMouseDownContent,
139718:                          mLastMiddleMouseDownContentParent,
139718:                          mLastRightMouseDownContent,
139718:                          mLastRightMouseDownContentParent,
139718:                          mActiveContent,
139718:                          mHoverContent,
139718:                          mURLTargetContent,
186255:                          mMouseEnterLeaveHelper,
186255:                          mPointersEnterLeaveHelper,
139718:                          mDocument,
199390:                          mIMEContentObserver,
139718:                          mAccessKeys)
  4484: 
199390: void
199390: EventStateManager::ReleaseCurrentIMEContentObserver()
199390: {
199390:   if (mIMEContentObserver) {
199390:     mIMEContentObserver->DisconnectFromEventStateManager();
199390:   }
199390:   mIMEContentObserver = nullptr;
199390: }
199390: 
199390: void
199390: EventStateManager::OnStartToObserveContent(
199390:                      IMEContentObserver* aIMEContentObserver)
199390: {
199390:   ReleaseCurrentIMEContentObserver();
199390:   mIMEContentObserver = aIMEContentObserver;
199390: }
199390: 
199390: void
199390: EventStateManager::OnStopObservingContent(
199390:                      IMEContentObserver* aIMEContentObserver)
199390: {
199390:   aIMEContentObserver->DisconnectFromEventStateManager();
199390:   NS_ENSURE_TRUE_VOID(mIMEContentObserver == aIMEContentObserver);
199390:   mIMEContentObserver = nullptr;
199390: }
199390: 
 68780: nsresult
196025: EventStateManager::PreHandleEvent(nsPresContext* aPresContext,
164382:                                   WidgetEvent* aEvent,
     1:                                   nsIFrame* aTargetFrame,
 82566:                                   nsEventStatus* aStatus)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aStatus);
     1:   NS_ENSURE_ARG(aPresContext);
     1:   if (!aEvent) {
     1:     NS_ERROR("aEvent is null.  This should never happen.");
     1:     return NS_ERROR_NULL_POINTER;
     1:   }
     1: 
     1:   mCurrentTarget = aTargetFrame;
106838:   mCurrentTargetContent = nullptr;
     1: 
  7093:   // Do not take account NS_MOUSE_ENTER/EXIT so that loading a page
  7093:   // when user is not active doesn't change the state to active.
251343:   WidgetMouseEvent* mouseEvent = aEvent->AsMouseEvent();
126028:   if (aEvent->mFlags.mIsTrusted &&
196021:       ((mouseEvent && mouseEvent->IsReal() &&
167231:         mouseEvent->message != NS_MOUSE_ENTER &&
167231:         mouseEvent->message != NS_MOUSE_EXIT) ||
220552:        aEvent->mClass == eWheelEventClass ||
220543:        aEvent->mClass == eKeyboardEventClass)) {
  7093:     if (gMouseOrKeyboardEventCounter == 0) {
  7093:       nsCOMPtr<nsIObserverService> obs =
 41540:         mozilla::services::GetObserverService();
  7093:       if (obs) {
106838:         obs->NotifyObservers(nullptr, "user-interaction-active", nullptr);
 57074:         UpdateUserActivityTimer();
  7093:       }
  7093:     }
  7093:     ++gMouseOrKeyboardEventCounter;
  7093:   }
  7093: 
251343:   WheelTransaction::OnEvent(aEvent);
251343: 
251343:   // Focus events don't necessarily need a frame.
251343:   if (NS_EVENT_NEEDS_FRAME(aEvent)) {
251343:     if (!mCurrentTarget) {
251343:       return NS_ERROR_NULL_POINTER;
251343:     }
251343:   }
251343: #ifdef DEBUG
251343:   if (aEvent->HasDragEventMessage() && sIsPointerLocked) {
251343:     NS_ASSERTION(sIsPointerLocked,
251343:       "sIsPointerLocked is true. Drag events should be suppressed when "
251343:       "the pointer is locked.");
251343:   }
251343: #endif
251343:   // Store last known screenPoint and clientPoint so pointer lock
251343:   // can use these values as constants.
251343:   if (aEvent->mFlags.mIsTrusted &&
251343:       ((mouseEvent && mouseEvent->IsReal()) ||
251343:        aEvent->mClass == eWheelEventClass) &&
251343:       !sIsPointerLocked) {
251343:     sLastScreenPoint =
251343:       UIEvent::CalculateScreenPoint(aPresContext, aEvent);
251343:     sLastClientPoint =
251343:       UIEvent::CalculateClientPoint(aPresContext, aEvent, nullptr);
251343:   }
251343: 
     1:   *aStatus = nsEventStatus_eIgnore;
     1: 
     1:   switch (aEvent->message) {
239597:   case NS_CONTEXTMENU:
239597:     if (sIsPointerLocked) {
239597:       return NS_ERROR_DOM_INVALID_STATE_ERR;
239597:     }
239597:     break;
166409:   case NS_MOUSE_BUTTON_DOWN: {
166409:     switch (mouseEvent->button) {
164386:     case WidgetMouseEvent::eLeftButton:
166409:       BeginTrackingDragGesture(aPresContext, mouseEvent, aTargetFrame);
166409:       mLClickCount = mouseEvent->clickCount;
166409:       SetClickCount(aPresContext, mouseEvent, aStatus);
 80486:       sNormalLMouseEventInProcess = true;
     1:       break;
164386:     case WidgetMouseEvent::eMiddleButton:
166409:       mMClickCount = mouseEvent->clickCount;
166409:       SetClickCount(aPresContext, mouseEvent, aStatus);
     1:       break;
164386:     case WidgetMouseEvent::eRightButton:
166409:       mRClickCount = mouseEvent->clickCount;
166409:       SetClickCount(aPresContext, mouseEvent, aStatus);
     1:       break;
     1:     }
     1:     break;
166409:   }
166409:   case NS_MOUSE_BUTTON_UP: {
166409:     switch (mouseEvent->button) {
164386:       case WidgetMouseEvent::eLeftButton:
157647:         if (Prefs::ClickHoldContextMenu()) {
     1:           KillClickHoldTimer();
 43674:         }
     1:         StopTrackingDragGesture();
 80486:         sNormalLMouseEventInProcess = false;
 63945:         // then fall through...
164386:       case WidgetMouseEvent::eRightButton:
164386:       case WidgetMouseEvent::eMiddleButton:
166409:         SetClickCount(aPresContext, mouseEvent, aStatus);
     1:         break;
     1:     }
     1:     break;
166409:   }
     1:   case NS_MOUSE_EXIT:
205509:     // If this is a remote frame, we receive NS_MOUSE_EXIT from the parent
205509:     // the mouse exits our content. Since the parent may update the cursor
205509:     // while the mouse is outside our frame, and since PuppetWidget caches the
205509:     // current cursor internally, re-entering our content (say from over a
205509:     // window edge) wont update the cursor if the cached value and the current
205509:     // cursor match. So when the mouse exits a remote frame, clear the cached
205509:     // widget cursor so a proper update will occur when the mouse re-enters.
205509:     if (XRE_GetProcessType() == GeckoProcessType_Content) {
205509:       ClearCachedWidgetCursor(mCurrentTarget);
205509:     }
205509: 
 12976:     // If the event is not a top-level window exit, then it's not
 12976:     // really an exit --- we may have traversed widget boundaries but
     1:     // we're still in our toplevel window.
164386:     if (mouseEvent->exit != WidgetMouseEvent::eTopLevel) {
 14640:       // Treat it as a synthetic move so we don't generate spurious
 14640:       // "exit" or "move" events.  Any necessary "out" or "over" events
 14640:       // will be generated by GenerateMouseEnterExit
 14640:       mouseEvent->message = NS_MOUSE_MOVE;
164386:       mouseEvent->reason = WidgetMouseEvent::eSynthesized;
     1:       // then fall through...
     1:     } else {
211244:       if (sPointerEventEnabled) {
211244:         // We should synthetize corresponding pointer events
211244:         GeneratePointerEnterExit(NS_POINTER_LEAVE, mouseEvent);
211244:       }
166409:       GenerateMouseEnterExit(mouseEvent);
     1:       //This is a window level mouse exit event and should stop here
     1:       aEvent->message = 0;
     1:       break;
     1:     }
186256:   case NS_MOUSE_MOVE:
188078:   case NS_POINTER_DOWN:
186256:   case NS_POINTER_MOVE: {
     1:     // on the Mac, GenerateDragGesture() may not return until the drag
     1:     // has completed and so |aTargetFrame| may have been deleted (moving
     1:     // a bookmark, for example).  If this is the case, however, we know
     1:     // that ClearFrameRefs() has been called and it cleared out
     1:     // |mCurrentTarget|. As a result, we should pass |mCurrentTarget|
     1:     // into UpdateCursor().
166409:     GenerateDragGesture(aPresContext, mouseEvent);
     1:     UpdateCursor(aPresContext, aEvent, mCurrentTarget, aStatus);
166409:     GenerateMouseEnterExit(mouseEvent);
 86861:     // Flush pending layout changes, so that later mouse move events
 86861:     // will go to the right nodes.
 86861:     FlushPendingEvents(aPresContext);
     1:     break;
166409:   }
     1:   case NS_DRAGDROP_GESTURE:
157647:     if (Prefs::ClickHoldContextMenu()) {
     1:       // an external drag gesture event came in, not generated internally
     1:       // by Gecko. Make sure we get rid of the click-hold timer.
     1:       KillClickHoldTimer();
 43674:     }
     1:     break;
     1:   case NS_DRAGDROP_OVER:
 18445:     // NS_DRAGDROP_DROP is fired before NS_DRAGDROP_DRAGDROP so send
 18445:     // the enter/exit events before NS_DRAGDROP_DROP.
166409:     GenerateDragDropEnterExit(aPresContext, aEvent->AsDragEvent());
     1:     break;
     1: 
     1:   case NS_KEY_PRESS:
     1:     {
166081:       WidgetKeyboardEvent* keyEvent = aEvent->AsKeyboardEvent();
     1: 
108991:       int32_t modifierMask = 0;
 96893:       if (keyEvent->IsShift())
     1:         modifierMask |= NS_MODIFIER_SHIFT;
 96893:       if (keyEvent->IsControl())
     1:         modifierMask |= NS_MODIFIER_CONTROL;
 96893:       if (keyEvent->IsAlt())
     1:         modifierMask |= NS_MODIFIER_ALT;
 96893:       if (keyEvent->IsMeta())
     1:         modifierMask |= NS_MODIFIER_META;
105732:       if (keyEvent->IsOS())
105732:         modifierMask |= NS_MODIFIER_OS;
     1: 
     1:       // Prevent keyboard scrolling while an accesskey modifier is in use.
157648:       if (modifierMask &&
157648:           (modifierMask == Prefs::ChromeAccessModifierMask() ||
157648:            modifierMask == Prefs::ContentAccessModifierMask())) {
106838:         HandleAccessKey(aPresContext, keyEvent, aStatus, nullptr,
     1:                         eAccessKeyProcessingNormal, modifierMask);
     1:       }
157648:     }
 63945:     // then fall through...
240019:   case NS_KEY_BEFORE_DOWN:
     1:   case NS_KEY_DOWN:
240019:   case NS_KEY_AFTER_DOWN:
240019:   case NS_KEY_BEFORE_UP:
     1:   case NS_KEY_UP:
240019:   case NS_KEY_AFTER_UP:
     1:     {
 29018:       nsIContent* content = GetFocusedContent();
 29018:       if (content)
 29018:         mCurrentTargetContent = content;
197484: 
197484:       // NOTE: Don't refer TextComposition::IsComposing() since DOM Level 3
197484:       //       Events defines that KeyboardEvent.isComposing is true when it's
197484:       //       dispatched after compositionstart and compositionend.
197484:       //       TextComposition::IsComposing() is false even before
197484:       //       compositionend if there is no composing string.
197484:       WidgetKeyboardEvent* keyEvent = aEvent->AsKeyboardEvent();
197484:       nsRefPtr<TextComposition> composition =
197484:         IMEStateManager::GetTextCompositionFor(keyEvent);
197484:       keyEvent->mIsComposing = !!composition;
     1:     }
     1:     break;
108059:   case NS_WHEEL_WHEEL:
165307:   case NS_WHEEL_START:
165307:   case NS_WHEEL_STOP:
     1:     {
126028:       NS_ASSERTION(aEvent->mFlags.mIsTrusted,
108059:                    "Untrusted wheel event shouldn't be here");
108059: 
 29018:       nsIContent* content = GetFocusedContent();
165307:       if (content) {
 29018:         mCurrentTargetContent = content;
165307:       }
165307: 
165307:       if (aEvent->message != NS_WHEEL_WHEEL) {
165307:         break;
165307:       }
     1: 
166411:       WidgetWheelEvent* wheelEvent = aEvent->AsWheelEvent();
108059:       WheelPrefs::GetInstance()->ApplyUserPrefsToDelta(wheelEvent);
108061: 
108588:       // If we won't dispatch a DOM event for this event, nothing to do anymore.
163205:       if (!wheelEvent->IsAllowedToDispatchDOMEvent()) {
108588:         break;
108588:       }
108588: 
108061:       // Init lineOrPageDelta values for line scroll events for some devices
108061:       // on some platforms which might dispatch wheel events which don't have
108061:       // lineOrPageDelta values.  And also, if delta values are customized by
108061:       // prefs, this recomputes them.
108061:       DeltaAccumulator::GetInstance()->
108061:         InitLineOrPageDelta(aTargetFrame, this, wheelEvent);
 19319:     }
 19319:     break;
 11914:   case NS_QUERY_SELECTED_TEXT:
166084:     DoQuerySelectedText(aEvent->AsQueryContentEvent());
 11914:     break;
 11914:   case NS_QUERY_TEXT_CONTENT:
 11914:     {
191142:       if (RemoteQueryContentEvent(aEvent)) {
 54603:         break;
191142:       }
191142:       ContentEventHandler handler(mPresContext);
166084:       handler.OnQueryTextContent(aEvent->AsQueryContentEvent());
 11914:     }
 11914:     break;
 11914:   case NS_QUERY_CARET_RECT:
 11914:     {
180770:       if (RemoteQueryContentEvent(aEvent)) {
180770:         break;
180770:       }
191142:       ContentEventHandler handler(mPresContext);
166084:       handler.OnQueryCaretRect(aEvent->AsQueryContentEvent());
 11914:     }
 11914:     break;
 24836:   case NS_QUERY_TEXT_RECT:
 24836:     {
180769:       if (RemoteQueryContentEvent(aEvent)) {
180769:         break;
180769:       }
191142:       ContentEventHandler handler(mPresContext);
166084:       handler.OnQueryTextRect(aEvent->AsQueryContentEvent());
 24836:     }
 24836:     break;
 24836:   case NS_QUERY_EDITOR_RECT:
 24836:     {
250388:       if (RemoteQueryContentEvent(aEvent)) {
250388:         break;
250388:       }
191142:       ContentEventHandler handler(mPresContext);
166084:       handler.OnQueryEditorRect(aEvent->AsQueryContentEvent());
 24836:     }
 24836:     break;
 26757:   case NS_QUERY_CONTENT_STATE:
 26757:     {
 54603:       // XXX remote event
191142:       ContentEventHandler handler(mPresContext);
166084:       handler.OnQueryContentState(aEvent->AsQueryContentEvent());
 26757:     }
 26757:     break;
 26757:   case NS_QUERY_SELECTION_AS_TRANSFERABLE:
 26757:     {
 54603:       // XXX remote event
191142:       ContentEventHandler handler(mPresContext);
166084:       handler.OnQuerySelectionAsTransferable(aEvent->AsQueryContentEvent());
 26757:     }
 26757:     break;
 28352:   case NS_QUERY_CHARACTER_AT_POINT:
 28352:     {
 54603:       // XXX remote event
191142:       ContentEventHandler handler(mPresContext);
166084:       handler.OnQueryCharacterAtPoint(aEvent->AsQueryContentEvent());
 28352:     }
 28352:     break;
 63215:   case NS_QUERY_DOM_WIDGET_HITTEST:
 63215:     {
 63215:       // XXX remote event
191142:       ContentEventHandler handler(mPresContext);
166084:       handler.OnQueryDOMWidgetHittest(aEvent->AsQueryContentEvent());
 63215:     }
 63215:     break;
 24836:   case NS_SELECTION_SET:
 24836:     {
166085:       WidgetSelectionEvent* selectionEvent = aEvent->AsSelectionEvent();
 54603:       if (IsTargetCrossProcess(selectionEvent)) {
 54603:         // Will not be handled locally, remote the event
191142:         if (GetCrossProcessTarget()->SendSelectionEvent(*selectionEvent)) {
 80486:           selectionEvent->mSucceeded = true;
191142:         }
 54603:         break;
 54603:       }
191142:       ContentEventHandler handler(mPresContext);
166085:       handler.OnSelectionEvent(selectionEvent);
 24836:     }
 24836:     break;
 31218:   case NS_CONTENT_COMMAND_CUT:
 31218:   case NS_CONTENT_COMMAND_COPY:
 31218:   case NS_CONTENT_COMMAND_PASTE:
 31218:   case NS_CONTENT_COMMAND_DELETE:
 31218:   case NS_CONTENT_COMMAND_UNDO:
 31218:   case NS_CONTENT_COMMAND_REDO:
 36983:   case NS_CONTENT_COMMAND_PASTE_TRANSFERABLE:
 31218:     {
166076:       DoContentCommandEvent(aEvent->AsContentCommandEvent());
 31218:     }
 31218:     break;
 39248:   case NS_CONTENT_COMMAND_SCROLL:
 39248:     {
166076:       DoContentCommandScrollEvent(aEvent->AsContentCommandEvent());
 39248:     }
 39248:     break;
 50731:   case NS_COMPOSITION_START:
126028:     if (aEvent->mFlags.mIsTrusted) {
 78622:       // If the event is trusted event, set the selected text to data of
 78622:       // composition event.
166083:       WidgetCompositionEvent* compositionEvent = aEvent->AsCompositionEvent();
164199:       WidgetQueryContentEvent selectedText(true, NS_QUERY_SELECTED_TEXT,
 78622:                                            compositionEvent->widget);
 78622:       DoQuerySelectedText(&selectedText);
 78622:       NS_ASSERTION(selectedText.mSucceeded, "Failed to get selected text");
233672:       compositionEvent->mData = selectedText.mReply.mString;
 78622:     }
 78622:     // through to compositionend handling
 50731:   case NS_COMPOSITION_END:
233682:   case NS_COMPOSITION_CHANGE:
243738:   case NS_COMPOSITION_COMMIT_AS_IS:
243740:   case NS_COMPOSITION_COMMIT:
 50731:     {
166083:       WidgetCompositionEvent* compositionEvent = aEvent->AsCompositionEvent();
 50731:       if (IsTargetCrossProcess(compositionEvent)) {
 50731:         // Will not be handled locally, remote the event
 54603:         if (GetCrossProcessTarget()->SendCompositionEvent(*compositionEvent)) {
 50731:           // Cancel local dispatching
126031:           aEvent->mFlags.mPropagationStopped = true;
 50731:         }
 50731:       }
 50731:     }
 50731:     break;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
157647: // static
157647: int32_t
196025: EventStateManager::GetAccessModifierMaskFor(nsISupports* aDocShell)
     1: {
     1:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(aDocShell));
     1:   if (!treeItem)
     1:     return -1; // invalid modifier
     1: 
181250:   switch (treeItem->ItemType()) {
     1:   case nsIDocShellTreeItem::typeChrome:
157648:     return Prefs::ChromeAccessModifierMask();
     1: 
     1:   case nsIDocShellTreeItem::typeContent:
157648:     return Prefs::ContentAccessModifierMask();
     1: 
     1:   default:
     1:     return -1; // invalid modifier
     1:   }
     1: }
     1: 
 79445: static bool
 14328: IsAccessKeyTarget(nsIContent* aContent, nsIFrame* aFrame, nsAString& aKey)
  8407: {
125959:   // Use GetAttr because we want Unicode case=insensitive matching
125959:   // XXXbz shouldn't this be case-sensitive, per spec?
125959:   nsString contentKey;
125959:   if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, contentKey) ||
125959:       !contentKey.Equals(aKey, nsCaseInsensitiveStringComparator()))
 80486:     return false;
 23192: 
 23192:   nsCOMPtr<nsIDOMXULDocument> xulDoc =
 80526:     do_QueryInterface(aContent->OwnerDoc());
 33329:   if (!xulDoc && !aContent->IsXUL())
 80486:     return true;
 23192: 
 23192:     // For XUL we do visibility checks.
  8407:   if (!aFrame)
 80486:     return false;
  8407: 
  8407:   if (aFrame->IsFocusable())
 80486:     return true;
  8407: 
 80910:   if (!aFrame->IsVisibleConsideringAncestors())
 80486:     return false;
  8407: 
 23192:   // XUL controls can be activated.
  8407:   nsCOMPtr<nsIDOMXULControlElement> control(do_QueryInterface(aContent));
  8407:   if (control)
 80486:     return true;
  8407: 
 33329:   if (aContent->IsHTML()) {
 15065:     nsIAtom* tag = aContent->Tag();
 15065: 
 15065:     // HTML area, label and legend elements are never focusable, so
 15065:     // we need to check for them explicitly before giving up.
 15065:     if (tag == nsGkAtoms::area ||
 15065:         tag == nsGkAtoms::label ||
 15065:         tag == nsGkAtoms::legend)
 80486:       return true;
 30176: 
 33329:   } else if (aContent->IsXUL()) {
 30176:     // XUL label elements are never focusable, so we need to check for them
 30176:     // explicitly before giving up.
 30176:     if (aContent->Tag() == nsGkAtoms::label)
 80486:       return true;
 80486:   }
 80486: 
 80486:   return false;
  8407: }
  8407: 
 79445: bool
196025: EventStateManager::ExecuteAccessKey(nsTArray<uint32_t>& aAccessCharCodes,
 79445:                                     bool aIsTrustedEvent)
 14328: {
108991:   int32_t count, start = -1;
 29018:   nsIContent* focusedContent = GetFocusedContent();
 29018:   if (focusedContent) {
 29018:     start = mAccessKeys.IndexOf(focusedContent);
 29018:     if (start == -1 && focusedContent->GetBindingParent())
 29018:       start = mAccessKeys.IndexOf(focusedContent->GetBindingParent());
 14328:   }
 14328:   nsIContent *content;
 14328:   nsIFrame *frame;
108991:   int32_t length = mAccessKeys.Count();
108991:   for (uint32_t i = 0; i < aAccessCharCodes.Length(); ++i) {
108991:     uint32_t ch = aAccessCharCodes[i];
 14328:     nsAutoString accessKey;
 14328:     AppendUCS4ToUTF16(ch, accessKey);
 14328:     for (count = 1; count <= length; ++count) {
 14328:       content = mAccessKeys[(start + count) % length];
 36655:       frame = content->GetPrimaryFrame();
 14328:       if (IsAccessKeyTarget(content, frame, accessKey)) {
157647:         bool shouldActivate = Prefs::KeyCausesActivation();
 14328:         while (shouldActivate && ++count <= length) {
 14328:           nsIContent *oc = mAccessKeys[(start + count) % length];
 36655:           nsIFrame *of = oc->GetPrimaryFrame();
 14328:           if (IsAccessKeyTarget(oc, of, accessKey))
 80486:             shouldActivate = false;
 14328:         }
 14328:         if (shouldActivate)
 14328:           content->PerformAccesskey(shouldActivate, aIsTrustedEvent);
 29018:         else {
 29018:           nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:           if (fm) {
 29018:             nsCOMPtr<nsIDOMElement> element = do_QueryInterface(content);
 29018:             fm->SetFocus(element, nsIFocusManager::FLAG_BYKEY);
 29018:           }
 29018:         }
 80486:         return true;
 80486:       }
 80486:     }
 80486:   }
 80486:   return false;
 14328: }
 14328: 
237105: // static
237105: void
237105: EventStateManager::GetAccessKeyLabelPrefix(Element* aElement, nsAString& aPrefix)
 74612: {
 74612:   aPrefix.Truncate();
 74612:   nsAutoString separator, modifierText;
 74612:   nsContentUtils::GetModifierSeparatorText(separator);
 74612: 
237105:   nsCOMPtr<nsISupports> container = aElement->OwnerDoc()->GetDocShell();
157648:   int32_t modifierMask = GetAccessModifierMaskFor(container);
157648: 
237105:   if (modifierMask == -1) {
237105:     return;
237105:   }
237105: 
157648:   if (modifierMask & NS_MODIFIER_CONTROL) {
 74612:     nsContentUtils::GetControlText(modifierText);
 74612:     aPrefix.Append(modifierText + separator);
 74612:   }
157648:   if (modifierMask & NS_MODIFIER_META) {
 74612:     nsContentUtils::GetMetaText(modifierText);
 74612:     aPrefix.Append(modifierText + separator);
 74612:   }
157648:   if (modifierMask & NS_MODIFIER_OS) {
105732:     nsContentUtils::GetOSText(modifierText);
105732:     aPrefix.Append(modifierText + separator);
105732:   }
157648:   if (modifierMask & NS_MODIFIER_ALT) {
 74612:     nsContentUtils::GetAltText(modifierText);
 74612:     aPrefix.Append(modifierText + separator);
 74612:   }
157648:   if (modifierMask & NS_MODIFIER_SHIFT) {
 74612:     nsContentUtils::GetShiftText(modifierText);
 74612:     aPrefix.Append(modifierText + separator);
 74612:   }
 74612: }
 74612: 
     1: void
196025: EventStateManager::HandleAccessKey(nsPresContext* aPresContext,
164193:                                    WidgetKeyboardEvent* aEvent,
     1:                                    nsEventStatus* aStatus,
  1585:                                    nsIDocShellTreeItem* aBubbledFrom,
     1:                                    ProcessingAccessKeyState aAccessKeyState,
108991:                                    int32_t aModifierMask)
     1: {
180033:   nsCOMPtr<nsIDocShell> docShell = aPresContext->GetDocShell();
     1: 
     1:   // Alt or other accesskey modifier is down, we may need to do an accesskey
 14328:   if (mAccessKeys.Count() > 0 &&
180033:       aModifierMask == GetAccessModifierMaskFor(docShell)) {
     1:     // Someone registered an accesskey.  Find and activate it.
108991:     nsAutoTArray<uint32_t, 10> accessCharCodes;
 14328:     nsContentUtils::GetAccessKeyCandidates(aEvent, accessCharCodes);
126028:     if (ExecuteAccessKey(accessCharCodes, aEvent->mFlags.mIsTrusted)) {
     1:       *aStatus = nsEventStatus_eConsumeNoDefault;
 14328:       return;
     1:     }
     1:   }
     1: 
     1:   // after the local accesskey handling
     1:   if (nsEventStatus_eConsumeNoDefault != *aStatus) {
     1:     // checking all sub docshells
     1: 
     1:     if (!docShell) {
     1:       NS_WARNING("no docShellTreeNode for presContext");
     1:       return;
     1:     }
     1: 
108991:     int32_t childCount;
     1:     docShell->GetChildCount(&childCount);
108991:     for (int32_t counter = 0; counter < childCount; counter++) {
     1:       // Not processing the child which bubbles up the handling
  1585:       nsCOMPtr<nsIDocShellTreeItem> subShellItem;
  1585:       docShell->GetChildAt(counter, getter_AddRefs(subShellItem));
  1585:       if (aAccessKeyState == eAccessKeyProcessingUp &&
  1585:           subShellItem == aBubbledFrom)
     1:         continue;
     1: 
     1:       nsCOMPtr<nsIDocShell> subDS = do_QueryInterface(subShellItem);
     1:       if (subDS && IsShellVisible(subDS)) {
127381:         nsCOMPtr<nsIPresShell> subPS = subDS->GetPresShell();
     1: 
     1:         // Docshells need not have a presshell (eg. display:none
     1:         // iframes, docshells in transition between documents, etc).
     1:         if (!subPS) {
     1:           // Oh, well.  Just move on to the next child
     1:           continue;
     1:         }
     1: 
     1:         nsPresContext *subPC = subPS->GetPresContext();
     1: 
196025:         EventStateManager* esm =
196025:           static_cast<EventStateManager*>(subPC->EventStateManager());
     1: 
     1:         if (esm)
106838:           esm->HandleAccessKey(subPC, aEvent, aStatus, nullptr,
     1:                                eAccessKeyProcessingDown, aModifierMask);
     1: 
     1:         if (nsEventStatus_eConsumeNoDefault == *aStatus)
     1:           break;
     1:       }
     1:     }
     1:   }// if end . checking all sub docshell ends here.
     1: 
  1585:   // bubble up the process to the parent docshell if necessary
     1:   if (eAccessKeyProcessingDown != aAccessKeyState && nsEventStatus_eConsumeNoDefault != *aStatus) {
     1:     if (!docShell) {
  1585:       NS_WARNING("no docShellTreeItem for presContext");
     1:       return;
     1:     }
     1: 
     1:     nsCOMPtr<nsIDocShellTreeItem> parentShellItem;
     1:     docShell->GetParent(getter_AddRefs(parentShellItem));
     1:     nsCOMPtr<nsIDocShell> parentDS = do_QueryInterface(parentShellItem);
     1:     if (parentDS) {
127381:       nsCOMPtr<nsIPresShell> parentPS = parentDS->GetPresShell();
     1:       NS_ASSERTION(parentPS, "Our PresShell exists but the parent's does not?");
     1: 
     1:       nsPresContext *parentPC = parentPS->GetPresContext();
     1:       NS_ASSERTION(parentPC, "PresShell without PresContext");
     1: 
196025:       EventStateManager* esm =
196025:         static_cast<EventStateManager*>(parentPC->EventStateManager());
     1: 
     1:       if (esm)
  1585:         esm->HandleAccessKey(parentPC, aEvent, aStatus, docShell,
     1:                              eAccessKeyProcessingUp, aModifierMask);
     1:     }
     1:   }// if end. bubble up process
     1: }// end of HandleAccessKey
     1: 
105595: bool
196025: EventStateManager::DispatchCrossProcessEvent(WidgetEvent* aEvent,
105700:                                              nsFrameLoader* aFrameLoader,
105595:                                              nsEventStatus *aStatus) {
105700:   PBrowserParent* remoteBrowser = aFrameLoader->GetRemoteBrowser();
 73592:   TabParent* remote = static_cast<TabParent*>(remoteBrowser);
 73592:   if (!remote) {
105595:     return false;
105595:   }
105595: 
220539:   switch (aEvent->mClass) {
220549:   case eMouseEventClass: {
166409:     return remote->SendRealMouseEvent(*aEvent->AsMouseEvent());
105595:   }
220543:   case eKeyboardEventClass: {
166081:     return remote->SendRealKeyEvent(*aEvent->AsKeyboardEvent());
105595:   }
220552:   case eWheelEventClass: {
166411:     return remote->SendMouseWheelEvent(*aEvent->AsWheelEvent());
108049:   }
220556:   case eTouchEventClass: {
105595:     // Let the child process synthesize a mouse event if needed, and
105595:     // ensure we don't synthesize one in this process.
105595:     *aStatus = nsEventStatus_eConsumeNoDefault;
166078:     return remote->SendRealTouchEvent(*aEvent->AsTouchEvent());
105595:   }
105595:   default: {
150033:     MOZ_CRASH("Attempt to send non-whitelisted event?");
105595:   }
 73592:   }
 73592: }
 73592: 
 79445: bool
196025: EventStateManager::IsRemoteTarget(nsIContent* target) {
 96948:   if (!target) {
 96948:     return false;
 96948:   }
 96948: 
 96948:   // <browser/iframe remote=true> from XUL
 96948:   if ((target->Tag() == nsGkAtoms::browser ||
 80649:        target->Tag() == nsGkAtoms::iframe) &&
 73592:       target->IsXUL() &&
 73592:       target->AttrValueIs(kNameSpaceID_None, nsGkAtoms::Remote,
 96948:                           nsGkAtoms::_true, eIgnoreCase)) {
 96948:     return true;
 96948:   }
 96948: 
121589:   // <frame/iframe mozbrowser/mozapp>
 96948:   nsCOMPtr<nsIMozBrowserFrame> browserFrame = do_QueryInterface(target);
121589:   if (browserFrame && browserFrame->GetReallyIsBrowserOrApp()) {
102765:     return !!TabParent::GetFrom(target);
 96948:   }
 96948: 
 96948:   return false;
 73592: }
 73592: 
151336: /*static*/ LayoutDeviceIntPoint
196025: EventStateManager::GetChildProcessOffset(nsFrameLoader* aFrameLoader,
164382:                                          const WidgetEvent& aEvent)
113703: {
113703:   // The "toplevel widget" in child processes is always at position
113703:   // 0,0.  Map the event coordinates to match that.
113703:   nsIFrame* targetFrame = aFrameLoader->GetPrimaryFrameOfOwningContent();
113703:   if (!targetFrame) {
151336:     return LayoutDeviceIntPoint();
113703:   }
113703:   nsPresContext* presContext = targetFrame->PresContext();
113703: 
144594:   // Find out how far we're offset from the nearest widget.
144594:   nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(&aEvent,
144594:                                                             targetFrame);
151336:   return LayoutDeviceIntPoint::FromAppUnitsToNearest(pt, presContext->AppUnitsPerDevPixel());
144594: }
144594: 
105595: bool
164382: CrossProcessSafeEvent(const WidgetEvent& aEvent)
105595: {
220539:   switch (aEvent.mClass) {
220543:   case eKeyboardEventClass:
220552:   case eWheelEventClass:
105595:     return true;
220549:   case eMouseEventClass:
105595:     switch (aEvent.message) {
105595:     case NS_MOUSE_BUTTON_DOWN:
105595:     case NS_MOUSE_BUTTON_UP:
105595:     case NS_MOUSE_MOVE:
155510:     case NS_CONTEXTMENU:
205508:     case NS_MOUSE_EXIT:
105595:       return true;
105595:     default:
105595:       return false;
105595:     }
220556:   case eTouchEventClass:
105595:     switch (aEvent.message) {
105595:     case NS_TOUCH_START:
105595:     case NS_TOUCH_MOVE:
105595:     case NS_TOUCH_END:
105595:     case NS_TOUCH_CANCEL:
105595:       return true;
105595:     default:
105595:       return false;
105595:     }
105595:   default:
105595:     return false;
105595:   }
105595: }
 73592: 
 79445: bool
196025: EventStateManager::HandleCrossProcessEvent(WidgetEvent* aEvent,
 73592:                                            nsEventStatus *aStatus) {
105595:   if (*aStatus == nsEventStatus_eConsumeNoDefault ||
126037:       aEvent->mFlags.mNoCrossProcessBoundaryForwarding ||
105595:       !CrossProcessSafeEvent(*aEvent)) {
 80486:     return false;
 73592:   }
105475: 
105595:   // Collect the remote event targets we're going to forward this
105595:   // event to.
105595:   //
105595:   // NB: the elements of |targets| must be unique, for correctness.
105595:   nsAutoTArray<nsCOMPtr<nsIContent>, 1> targets;
220556:   if (aEvent->mClass != eTouchEventClass ||
105595:       aEvent->message == NS_TOUCH_START) {
105595:     // If this event only has one target, and it's remote, add it to
105595:     // the array.
181952:     nsIFrame* frame = GetEventTarget();
181952:     nsIContent* target = frame ? frame->GetContent() : nullptr;
105595:     if (IsRemoteTarget(target)) {
105595:       targets.AppendElement(target);
105595:     }
105595:   } else {
105595:     // This is a touch event with possibly multiple touch points.
105595:     // Each touch point may have its own target.  So iterate through
105595:     // all of them and collect the unique set of targets for event
105595:     // forwarding.
105595:     //
105595:     // This loop is similar to the one used in
105595:     // PresShell::DispatchTouchEvent().
214899:     const WidgetTouchEvent::TouchArray& touches =
166078:       aEvent->AsTouchEvent()->touches;
108991:     for (uint32_t i = 0; i < touches.Length(); ++i) {
154120:       Touch* touch = touches[i];
105595:       // NB: the |mChanged| check is an optimization, subprocesses can
105595:       // compute this for themselves.  If the touch hasn't changed, we
105595:       // may be able to avoid forwarding the event entirely (which is
105595:       // not free).
105595:       if (!touch || !touch->mChanged) {
105595:         continue;
105595:       }
154120:       nsCOMPtr<EventTarget> targetPtr = touch->mTarget;
105595:       if (!targetPtr) {
105595:         continue;
105595:       }
105595:       nsCOMPtr<nsIContent> target = do_QueryInterface(targetPtr);
105595:       if (IsRemoteTarget(target) && !targets.Contains(target)) {
105595:         targets.AppendElement(target);
105595:       }
105595:     }
105595:   }
105595: 
105700:   if (targets.Length() == 0) {
105700:     return false;
105700:   }
105700: 
105595:   // Look up the frame loader for all the remote targets we found, and
105595:   // then dispatch the event to the remote content they represent.
105595:   bool dispatched = false;
108991:   for (uint32_t i = 0; i < targets.Length(); ++i) {
105595:     nsIContent* target = targets[i];
 73592:     nsCOMPtr<nsIFrameLoaderOwner> loaderOwner = do_QueryInterface(target);
 73592:     if (!loaderOwner) {
105700:       continue;
 73592:     }
 73592: 
 73592:     nsRefPtr<nsFrameLoader> frameLoader = loaderOwner->GetFrameLoader();
 73592:     if (!frameLoader) {
105700:       continue;
 73592:     }
 73592: 
108991:     uint32_t eventMode;
 73592:     frameLoader->GetEventMode(&eventMode);
 73592:     if (eventMode == nsIFrameLoader::EVENT_MODE_DONT_FORWARD_TO_CHILD) {
105700:       continue;
105700:     }
105700: 
105595:     dispatched |= DispatchCrossProcessEvent(aEvent, frameLoader, aStatus);
105595:   }
105595:   return dispatched;
 73592: }
     1: 
     1: //
     1: // CreateClickHoldTimer
     1: //
     1: // Fire off a timer for determining if the user wants click-hold. This timer
     1: // is a one-shot that will be cancelled when the user moves enough to fire
     1: // a drag.
     1: //
     1: void
196025: EventStateManager::CreateClickHoldTimer(nsPresContext* inPresContext,
     1:                                         nsIFrame* inDownFrame,
164381:                                         WidgetGUIEvent* inMouseDownEvent)
     1: {
239597:   if (!inMouseDownEvent->mFlags.mIsTrusted ||
239597:       IsRemoteTarget(mGestureDownContent) ||
239597:       sIsPointerLocked) {
     1:     return;
239597:   }
     1: 
     1:   // just to be anal (er, safe)
     1:   if (mClickHoldTimer) {
     1:     mClickHoldTimer->Cancel();
106838:     mClickHoldTimer = nullptr;
     1:   }
     1: 
     1:   // if content clicked on has a popup, don't even start the timer
     1:   // since we'll end up conflicting and both will show.
     1:   if (mGestureDownContent) {
     1:     // check for the |popup| attribute
     1:     if (nsContentUtils::HasNonEmptyAttr(mGestureDownContent, kNameSpaceID_None,
     1:                                         nsGkAtoms::popup))
     1:       return;
     1:     
     1:     // check for a <menubutton> like bookmarks
     1:     if (mGestureDownContent->Tag() == nsGkAtoms::menubutton)
     1:       return;
     1:   }
     1: 
     1:   mClickHoldTimer = do_CreateInstance("@mozilla.org/timer;1");
 43674:   if (mClickHoldTimer) {
108991:     int32_t clickHoldDelay =
 70842:       Preferences::GetInt("ui.click_hold_context_menus.delay", 500);
     1:     mClickHoldTimer->InitWithFuncCallback(sClickHoldCallback, this,
 43674:                                           clickHoldDelay,
     1:                                           nsITimer::TYPE_ONE_SHOT);
 43674:   }
     1: } // CreateClickHoldTimer
     1: 
     1: 
     1: //
     1: // KillClickHoldTimer
     1: //
     1: // Stop the timer that would show the context menu dead in its tracks
     1: //
     1: void
196025: EventStateManager::KillClickHoldTimer()
     1: {
     1:   if (mClickHoldTimer) {
     1:     mClickHoldTimer->Cancel();
106838:     mClickHoldTimer = nullptr;
     1:   }
     1: }
     1: 
     1: 
     1: //
     1: // sClickHoldCallback
     1: //
     1: // This fires after the mouse has been down for a certain length of time.
     1: //
     1: void
196025: EventStateManager::sClickHoldCallback(nsITimer* aTimer, void* aESM)
     1: {
196025:   nsRefPtr<EventStateManager> self = static_cast<EventStateManager*>(aESM);
130400:   if (self) {
     1:     self->FireContextClick();
130400:   }
     1: 
     1:   // NOTE: |aTimer| and |self->mAutoHideTimer| are invalid after calling ClosePopup();
     1: 
     1: } // sAutoHideCallback
     1: 
     1: 
     1: //
     1: // FireContextClick
     1: //
     1: // If we're this far, our timer has fired, which means the mouse has been down
     1: // for a certain period of time and has not moved enough to generate a dragGesture.
     1: // We can be certain the user wants a context-click at this stage, so generate
     1: // a dom event and fire it in.
     1: //
     1: // After the event fires, check if PreventDefault() has been set on the event which
     1: // means that someone either ate the event or put up a context menu. This is our cue
     1: // to stop tracking the drag gesture. If we always did this, draggable items w/out
     1: // a context menu wouldn't be draggable after a certain length of time, which is
     1: // _not_ what we want.
     1: //
     1: void
196025: EventStateManager::FireContextClick()
     1: {
239597:   if (!mGestureDownContent || !mPresContext || sIsPointerLocked) {
     1:     return;
168579:   }
     1: 
     1: #ifdef XP_MACOSX
 32855:   // Hack to ensure that we don't show a context menu when the user
 32855:   // let go of the mouse after a long cpu-hogging operation prevented
     1:   // us from handling any OS events. See bug 117589.
 32855:   if (!CGEventSourceButtonState(kCGEventSourceStateCombinedSessionState, kCGMouseButtonLeft))
     1:     return;
     1: #endif
     1: 
     1:   nsEventStatus status = nsEventStatus_eIgnore;
     1: 
     1:   // Dispatch to the DOM. We have to fake out the ESM and tell it that the
     1:   // current target frame is actually where the mouseDown occurred, otherwise it
     1:   // will use the frame the mouse is currently over which may or may not be
     1:   // the same. (Note: saari and I have decided that we don't have to reset |mCurrentTarget|
     1:   // when we're through because no one else is doing anything more with this
     1:   // event and it will get reset on the very next event to the correct frame).
 36655:   mCurrentTarget = mPresContext->GetPrimaryFrameFor(mGestureDownContent);
130400:   // make sure the widget sticks around
130400:   nsCOMPtr<nsIWidget> targetWidget;
130400:   if (mCurrentTarget && (targetWidget = mCurrentTarget->GetNearestWidget())) {
   238:     NS_ASSERTION(mPresContext == mCurrentTarget->PresContext(),
     1:                  "a prescontext returned a primary frame that didn't belong to it?");
     1: 
     1:     // before dispatching, check that we're not on something that
     1:     // doesn't get a context menu
     1:     nsIAtom *tag = mGestureDownContent->Tag();
 79445:     bool allowedToDispatch = true;
     1: 
 33329:     if (mGestureDownContent->IsXUL()) {
     1:       if (tag == nsGkAtoms::scrollbar ||
     1:           tag == nsGkAtoms::scrollbarbutton ||
     1:           tag == nsGkAtoms::button)
 80486:         allowedToDispatch = false;
     1:       else if (tag == nsGkAtoms::toolbarbutton) {
     1:         // a <toolbarbutton> that has the container attribute set
     1:         // will already have its own dropdown.
     1:         if (nsContentUtils::HasNonEmptyAttr(mGestureDownContent,
     1:                 kNameSpaceID_None, nsGkAtoms::container)) {
 80486:           allowedToDispatch = false;
     1:         } else {
     1:           // If the toolbar button has an open menu, don't attempt to open
     1:             // a second menu
     1:           if (mGestureDownContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::open,
     1:                                                nsGkAtoms::_true, eCaseMatters)) {
 80486:             allowedToDispatch = false;
     1:           }
     1:         }
     1:       }
     1:     }
 33329:     else if (mGestureDownContent->IsHTML()) {
     1:       nsCOMPtr<nsIFormControl> formCtrl(do_QueryInterface(mGestureDownContent));
     1: 
     1:       if (formCtrl) {
132300:         allowedToDispatch = formCtrl->IsTextControl(false) ||
132300:                             formCtrl->GetType() == NS_FORM_INPUT_FILE;
     1:       }
     1:       else if (tag == nsGkAtoms::applet ||
     1:                tag == nsGkAtoms::embed  ||
     1:                tag == nsGkAtoms::object) {
 80486:         allowedToDispatch = false;
     1:       }
     1:     }
     1: 
     1:     if (allowedToDispatch) {
     1:       // init the event while mCurrentTarget is still good
164386:       WidgetMouseEvent event(true, NS_CONTEXTMENU, targetWidget,
164386:                              WidgetMouseEvent::eReal);
     1:       event.clickCount = 1;
     1:       FillInEventFromGestureDown(&event);
     1:         
     1:       // stop selection tracking, we're in control now
     1:       if (mCurrentTarget)
     1:       {
 70097:         nsRefPtr<nsFrameSelection> frameSel =
  8295:           mCurrentTarget->GetFrameSelection();
     1:         
220863:         if (frameSel && frameSel->GetDragState()) {
     1:           // note that this can cause selection changed events to fire if we're in
     1:           // a text field, which will null out mCurrentTarget
220863:           frameSel->SetDragState(false);
     1:         }
     1:       }
     1: 
207686:       nsIDocument* doc = mGestureDownContent->GetCrossShadowCurrentDoc();
166503:       AutoHandlingUserInputStatePusher userInpStatePusher(true, &event, doc);
123981: 
     1:       // dispatch to DOM
193672:       EventDispatcher::Dispatch(mGestureDownContent, mPresContext, &event,
106838:                                 nullptr, &status);
     1: 
     1:       // We don't need to dispatch to frame handling because no frames
     1:       // watch NS_CONTEXTMENU except for nsMenuFrame and that's only for
     1:       // dismissal. That's just as well since we don't really know
     1:       // which frame to send it to.
     1:     }
     1:   }
     1: 
     1:   // now check if the event has been handled. If so, stop tracking a drag
     1:   if (status == nsEventStatus_eConsumeNoDefault) {
     1:     StopTrackingDragGesture();
     1:   }
     1: 
     1:   KillClickHoldTimer();
     1: 
     1: } // FireContextClick
     1: 
     1: 
     1: //
     1: // BeginTrackingDragGesture
     1: //
     1: // Record that the mouse has gone down and that we should move to TRACKING state
     1: // of d&d gesture tracker.
     1: //
 43674: // We also use this to track click-hold context menus. When the mouse goes down,
     1: // fire off a short timer. If the timer goes off and we have yet to fire the
     1: // drag gesture (ie, the mouse hasn't moved a certain distance), then we can
     1: // assume the user wants a click-hold, so fire a context-click event. We only
     1: // want to cancel the drag gesture if the context-click event is handled.
     1: //
     1: void
196025: EventStateManager::BeginTrackingDragGesture(nsPresContext* aPresContext,
164386:                                             WidgetMouseEvent* inDownEvent,
     1:                                             nsIFrame* inDownFrame)
     1: {
 43674:   if (!inDownEvent->widget)
 43674:     return;
 43674: 
     1:   // Note that |inDownEvent| could be either a mouse down event or a
     1:   // synthesized mouse move event.
 25183:   mGestureDownPoint = inDownEvent->refPoint +
154119:     LayoutDeviceIntPoint::FromUntyped(inDownEvent->widget->WidgetToScreenOffset());
     1: 
 79435:   inDownFrame->GetContentForEvent(inDownEvent,
     1:                                   getter_AddRefs(mGestureDownContent));
     1: 
     1:   mGestureDownFrameOwner = inDownFrame->GetContent();
 96887:   mGestureModifiers = inDownEvent->modifiers;
 96888:   mGestureDownButtons = inDownEvent->buttons;
     1: 
157647:   if (Prefs::ClickHoldContextMenu()) {
     1:     // fire off a timer to track click-hold
     1:     CreateClickHoldTimer(aPresContext, inDownFrame, inDownEvent);
 43674:   }
     1: }
     1: 
     1: 
     1: //
     1: // StopTrackingDragGesture
     1: //
     1: // Record that the mouse has gone back up so that we should leave the TRACKING
     1: // state of d&d gesture tracker and return to the START state.
     1: //
     1: void
196025: EventStateManager::StopTrackingDragGesture()
     1: {
106838:   mGestureDownContent = nullptr;
106838:   mGestureDownFrameOwner = nullptr;
     1: }
     1: 
     1: void
196025: EventStateManager::FillInEventFromGestureDown(WidgetMouseEvent* aEvent)
     1: {
 47148:   NS_ASSERTION(aEvent->widget == mCurrentTarget->GetNearestWidget(),
     1:                "Incorrect widget in event");
     1: 
     1:   // Set the coordinates in the new event to the coordinates of
     1:   // the old event, adjusted for the fact that the widget might be
     1:   // different
154119:   aEvent->refPoint = mGestureDownPoint -
154119:     LayoutDeviceIntPoint::FromUntyped(aEvent->widget->WidgetToScreenOffset());
 96887:   aEvent->modifiers = mGestureModifiers;
 96888:   aEvent->buttons = mGestureDownButtons;
     1: }
     1: 
     1: //
     1: // GenerateDragGesture
     1: //
     1: // If we're in the TRACKING state of the d&d gesture tracker, check the current position
     1: // of the mouse in relation to the old one. If we've moved a sufficient amount from
     1: // the mouse down, then fire off a drag gesture event.
     1: void
196025: EventStateManager::GenerateDragGesture(nsPresContext* aPresContext,
164386:                                        WidgetMouseEvent* aEvent)
     1: {
     1:   NS_ASSERTION(aPresContext, "This shouldn't happen.");
     1:   if (IsTrackingDragGesture()) {
 36655:     mCurrentTarget = mGestureDownFrameOwner->GetPrimaryFrame();
     1: 
     1:     if (!mCurrentTarget) {
     1:       StopTrackingDragGesture();
     1:       return;
     1:     }
     1: 
216591:     // Check if selection is tracking drag gestures, if so
216591:     // don't interfere!
216591:     if (mCurrentTarget)
216591:     {
216591:       nsRefPtr<nsFrameSelection> frameSel = mCurrentTarget->GetFrameSelection();
220863:       if (frameSel && frameSel->GetDragState()) {
216591:         StopTrackingDragGesture();
216591:         return;
216591:       }
216591:     }
216591: 
 37876:     // If non-native code is capturing the mouse don't start a drag.
 37876:     if (nsIPresShell::IsMouseCapturePreventingDrag()) {
 37876:       StopTrackingDragGesture();
 37876:       return;
 37876:     }
 37876: 
108991:     static int32_t pixelThresholdX = 0;
108991:     static int32_t pixelThresholdY = 0;
     1: 
     1:     if (!pixelThresholdX) {
 78124:       pixelThresholdX =
 78124:         LookAndFeel::GetInt(LookAndFeel::eIntID_DragThresholdX, 0);
 78124:       pixelThresholdY =
 78124:         LookAndFeel::GetInt(LookAndFeel::eIntID_DragThresholdY, 0);
     1:       if (!pixelThresholdX)
     1:         pixelThresholdX = 5;
     1:       if (!pixelThresholdY)
     1:         pixelThresholdY = 5;
     1:     }
     1: 
     1:     // fire drag gesture if mouse has moved enough
154119:     LayoutDeviceIntPoint pt = aEvent->refPoint +
154119:       LayoutDeviceIntPoint::FromUntyped(aEvent->widget->WidgetToScreenOffset());
223358:     LayoutDeviceIntPoint distance = pt - mGestureDownPoint;
225186:     if (Abs(distance.x) > AssertedCast<uint32_t>(pixelThresholdX) ||
225186:         Abs(distance.y) > AssertedCast<uint32_t>(pixelThresholdY)) {
157647:       if (Prefs::ClickHoldContextMenu()) {
     1:         // stop the click-hold before we fire off the drag gesture, in case
     1:         // it takes a long time
     1:         KillClickHoldTimer();
 43674:       }
     1: 
189111:       nsCOMPtr<nsISupports> container = aPresContext->GetContainerWeak();
189111:       nsCOMPtr<nsPIDOMWindow> window = do_GetInterface(container);
189111:       if (!window)
189111:         return;
189111: 
189110:       nsRefPtr<DataTransfer> dataTransfer =
189111:         new DataTransfer(window, NS_DRAGDROP_START, false, -1);
 18445: 
 90375:       nsCOMPtr<nsISelection> selection;
216591:       nsCOMPtr<nsIContent> eventContent, targetContent;
216591:       mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(eventContent));
 18445:       if (eventContent)
189111:         DetermineDragTarget(window, eventContent, dataTransfer,
 90375:                             getter_AddRefs(selection), getter_AddRefs(targetContent));
 18445: 
     1:       // Stop tracking the drag gesture now. This should stop us from
     1:       // reentering GenerateDragGesture inside DOM event processing.
     1:       StopTrackingDragGesture();
     1: 
 18445:       if (!targetContent)
 18445:         return;
 18445: 
189111:       // Use our targetContent, now that we've determined it, as the
189111:       // parent object of the DataTransfer.
189111:       dataTransfer->SetParentObject(targetContent);
189111: 
106838:       sLastDragOverFrame = nullptr;
 47148:       nsCOMPtr<nsIWidget> widget = mCurrentTarget->GetNearestWidget();
   482: 
     1:       // get the widget from the target frame
164204:       WidgetDragEvent startEvent(aEvent->mFlags.mIsTrusted,
126028:                                  NS_DRAGDROP_START, widget);
 18445:       FillInEventFromGestureDown(&startEvent);
 18445: 
164204:       WidgetDragEvent gestureEvent(aEvent->mFlags.mIsTrusted,
126028:                                    NS_DRAGDROP_GESTURE, widget);
   482:       FillInEventFromGestureDown(&gestureEvent);
     1: 
 18445:       startEvent.dataTransfer = gestureEvent.dataTransfer = dataTransfer;
 40485:       startEvent.inputSource = gestureEvent.inputSource = aEvent->inputSource;
 18445: 
     1:       // Dispatch to the DOM. By setting mCurrentTarget we are faking
     1:       // out the ESM and telling it that the current target frame is
     1:       // actually where the mouseDown occurred, otherwise it will use
     1:       // the frame the mouse is currently over which may or may not be
     1:       // the same. (Note: saari and I have decided that we don't have
     1:       // to reset |mCurrentTarget| when we're through because no one
     1:       // else is doing anything more with this event and it will get
     1:       // reset on the very next event to the correct frame).
     1: 
     1:       // Hold onto old target content through the event and reset after.
     1:       nsCOMPtr<nsIContent> targetBeforeEvent = mCurrentTargetContent;
     1: 
     1:       // Set the current target to the content for the mouse down
     1:       mCurrentTargetContent = targetContent;
     1: 
 19703:       // Dispatch both the dragstart and draggesture events to the DOM. For
 19703:       // elements in an editor, only fire the draggesture event so that the
 19703:       // editor code can handle it but content doesn't see a dragstart.
   482:       nsEventStatus status = nsEventStatus_eIgnore;
193672:       EventDispatcher::Dispatch(targetContent, aPresContext, &startEvent,
193672:                                 nullptr, &status);
 18445: 
164204:       WidgetDragEvent* event = &startEvent;
 18445:       if (status != nsEventStatus_eConsumeNoDefault) {
 18445:         status = nsEventStatus_eIgnore;
193672:         EventDispatcher::Dispatch(targetContent, aPresContext, &gestureEvent,
193672:                                   nullptr, &status);
 18445:         event = &gestureEvent;
 18445:       }
 18445: 
182067:       nsCOMPtr<nsIObserverService> observerService =
182067:         mozilla::services::GetObserverService();
182067:       // Emit observer event to allow addons to modify the DataTransfer object.
182067:       if (observerService) {
182067:         observerService->NotifyObservers(dataTransfer,
182067:                                          "on-datatransfer-available",
182067:                                          nullptr);
182067:       }
182067: 
 18445:       // now that the dataTransfer has been updated in the dragstart and
 18445:       // draggesture events, make it read only so that the data doesn't
 18445:       // change during the drag.
 18445:       dataTransfer->SetReadOnly();
 18445: 
 34683:       if (status != nsEventStatus_eConsumeNoDefault) {
 79445:         bool dragStarted = DoDefaultDragStart(aPresContext, event, dataTransfer,
 90375:                                               targetContent, selection);
 34683:         if (dragStarted) {
106838:           sActiveESM = nullptr;
126031:           aEvent->mFlags.mPropagationStopped = true;
 34683:         }
 34683:       }
   482: 
     1:       // Note that frame event handling doesn't care about NS_DRAGDROP_GESTURE,
     1:       // which is just as well since we don't really know which frame to
     1:       // send it to
     1: 
     1:       // Reset mCurretTargetContent to what it was
     1:       mCurrentTargetContent = targetBeforeEvent;
     1:     }
     1: 
     1:     // Now flush all pending notifications, for better responsiveness
     1:     // while dragging.
     1:     FlushPendingEvents(aPresContext);
     1:   }
     1: } // GenerateDragGesture
     1: 
 18445: void
196025: EventStateManager::DetermineDragTarget(nsPIDOMWindow* aWindow,
 18445:                                        nsIContent* aSelectionTarget,
189110:                                        DataTransfer* aDataTransfer,
 90375:                                        nsISelection** aSelection,
 18445:                                        nsIContent** aTargetNode)
 18445: {
106838:   *aTargetNode = nullptr;
 18445: 
 18445:   // GetDragData determines if a selection, link or image in the content
 18445:   // should be dragged, and places the data associated with the drag in the
 90375:   // data transfer.
 90375:   // mGestureDownContent is the node where the mousedown event for the drag
 90375:   // occurred, and aSelectionTarget is the node to use when a selection is used
 79445:   bool canDrag;
 18445:   nsCOMPtr<nsIContent> dragDataNode;
161040:   bool wasAlt = (mGestureModifiers & MODIFIER_ALT) != 0;
189111:   nsresult rv = nsContentAreaDragDrop::GetDragData(aWindow, mGestureDownContent,
 96893:                                                    aSelectionTarget, wasAlt,
 90375:                                                    aDataTransfer, &canDrag, aSelection,
 18445:                                                    getter_AddRefs(dragDataNode));
 18445:   if (NS_FAILED(rv) || !canDrag)
 18445:     return;
 18445: 
 18445:   // if GetDragData returned a node, use that as the node being dragged.
 18445:   // Otherwise, if a selection is being dragged, use the node within the
 18445:   // selection that was dragged. Otherwise, just use the mousedown target.
 18445:   nsIContent* dragContent = mGestureDownContent;
 18445:   if (dragDataNode)
 18445:     dragContent = dragDataNode;
 90375:   else if (*aSelection)
 18445:     dragContent = aSelectionTarget;
 18445: 
 18445:   nsIContent* originalDragContent = dragContent;
 18445: 
 18445:   // If a selection isn't being dragged, look for an ancestor with the
 18445:   // draggable property set. If one is found, use that as the target of the
 18445:   // drag instead of the node that was clicked on. If a draggable node wasn't
 18445:   // found, just use the clicked node.
 90375:   if (!*aSelection) {
 18445:     while (dragContent) {
 81041:       nsCOMPtr<nsIDOMHTMLElement> htmlElement = do_QueryInterface(dragContent);
 18445:       if (htmlElement) {
 79445:         bool draggable = false;
 18445:         htmlElement->GetDraggable(&draggable);
 18445:         if (draggable)
 18445:           break;
 18445:       }
 18445:       else {
 18445:         nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(dragContent);
 18445:         if (xulElement) {
 18445:           // All XUL elements are draggable, so if a XUL element is
 18445:           // encountered, stop looking for draggable nodes and just use the
 18445:           // original clicked node instead.
 18445:           // XXXndeakin
 18445:           // In the future, we will want to improve this so that XUL has a
 18445:           // better way to specify whether something is draggable than just
 18445:           // on/off.
 18445:           dragContent = mGestureDownContent;
 18445:           break;
 18445:         }
 18445:         // otherwise, it's not an HTML or XUL element, so just keep looking
 18445:       }
 18445:       dragContent = dragContent->GetParent();
 18445:     }
 18445:   }
 18445: 
 18445:   // if no node in the hierarchy was found to drag, but the GetDragData method
 18985:   // returned a node, use that returned node. Otherwise, nothing is draggable.
 18985:   if (!dragContent && dragDataNode)
 18985:     dragContent = dragDataNode;
 18445: 
 18445:   if (dragContent) {
 18445:     // if an ancestor node was used instead, clear the drag data
 18445:     // XXXndeakin rework this a bit. Find a way to just not call GetDragData if we don't need to.
 18445:     if (dragContent != originalDragContent)
 18445:       aDataTransfer->ClearAll();
 18445:     *aTargetNode = dragContent;
 18445:     NS_ADDREF(*aTargetNode);
 18445:   }
 18445: }
 18445: 
 79445: bool
196025: EventStateManager::DoDefaultDragStart(nsPresContext* aPresContext,
164204:                                       WidgetDragEvent* aDragEvent,
189110:                                       DataTransfer* aDataTransfer,
 18445:                                       nsIContent* aDragTarget,
 90375:                                       nsISelection* aSelection)
 18445: {
 18445:   nsCOMPtr<nsIDragService> dragService =
 18445:     do_GetService("@mozilla.org/widget/dragservice;1");
 18445:   if (!dragService)
 80486:     return false;
 18445: 
 18445:   // Default handling for the draggesture/dragstart event.
 18445:   //
 18445:   // First, check if a drag session already exists. This means that the drag
 18445:   // service was called directly within a draggesture handler. In this case,
 18445:   // don't do anything more, as it is assumed that the handler is managing
 34683:   // drag and drop manually. Make sure to return true to indicate that a drag
 34683:   // began.
 18445:   nsCOMPtr<nsIDragSession> dragSession;
 18445:   dragService->GetCurrentSession(getter_AddRefs(dragSession));
 18445:   if (dragSession)
 80486:     return true;
 18445: 
 18445:   // No drag session is currently active, so check if a handler added
 18445:   // any items to be dragged. If not, there isn't anything to drag.
108991:   uint32_t count = 0;
 18445:   if (aDataTransfer)
 18445:     aDataTransfer->GetMozItemCount(&count);
 18445:   if (!count)
 80486:     return false;
 18445: 
 18445:   // Get the target being dragged, which may not be the same as the
 18445:   // target of the mouse event. If one wasn't set in the
 18445:   // aDataTransfer during the event handler, just use the original
 18445:   // target instead.
189460:   nsCOMPtr<nsIContent> dragTarget = aDataTransfer->GetDragTarget();
 18445:   if (!dragTarget) {
189460:     dragTarget = aDragTarget;
 18445:     if (!dragTarget)
 80486:       return false;
 18445:   }
 18445: 
 18552:   // check which drag effect should initially be used. If the effect was not
 18552:   // set, just use all actions, otherwise Windows won't allow a drop.
108991:   uint32_t action;
 18552:   aDataTransfer->GetEffectAllowedInt(&action);
 18552:   if (action == nsIDragService::DRAGDROP_ACTION_UNINITIALIZED)
 18552:     action = nsIDragService::DRAGDROP_ACTION_COPY |
 18552:              nsIDragService::DRAGDROP_ACTION_MOVE |
 18552:              nsIDragService::DRAGDROP_ACTION_LINK;
 18445: 
 18445:   // get any custom drag image that was set
108991:   int32_t imageX, imageY;
189111:   Element* dragImage = aDataTransfer->GetDragImage(&imageX, &imageY);
189111: 
189111:   nsCOMPtr<nsISupportsArray> transArray =
189111:     aDataTransfer->GetTransferables(dragTarget->AsDOMNode());
 18445:   if (!transArray)
 80486:     return false;
 18445: 
 18445:   // XXXndeakin don't really want to create a new drag DOM event
 18445:   // here, but we need something to pass to the InvokeDragSession
 18445:   // methods.
 18445:   nsCOMPtr<nsIDOMEvent> domEvent;
189111:   NS_NewDOMDragEvent(getter_AddRefs(domEvent), dragTarget,
135508:                      aPresContext, aDragEvent);
 18445: 
 18445:   nsCOMPtr<nsIDOMDragEvent> domDragEvent = do_QueryInterface(domEvent);
 18445:   // if creating a drag event failed, starting a drag session will
 18445:   // just fail.
 90375: 
 90375:   // Use InvokeDragSessionWithSelection if a selection is being dragged,
 90375:   // such that the image can be generated from the selected text. However,
 90375:   // use InvokeDragSessionWithImage if a custom image was set or something
 90375:   // other than a selection is being dragged.
 90375:   if (!dragImage && aSelection) {
 90375:     dragService->InvokeDragSessionWithSelection(aSelection, transArray,
 18445:                                                 action, domDragEvent,
 18445:                                                 aDataTransfer);
 18445:   }
 18445:   else {
 18445:     // if dragging within a XUL tree and no custom drag image was
 18445:     // set, the region argument to InvokeDragSessionWithImage needs
 18445:     // to be set to the area encompassing the selected rows of the
 18445:     // tree to ensure that the drag feedback gets clipped to those
 18445:     // rows. For other content, region should be null.
 18445:     nsCOMPtr<nsIScriptableRegion> region;
 18445: #ifdef MOZ_XUL
 18445:     if (dragTarget && !dragImage) {
189111:       if (dragTarget->NodeInfo()->Equals(nsGkAtoms::treechildren,
 18445:                                          kNameSpaceID_XUL)) {
189111:         nsTreeBodyFrame* treeBody =
189111:           do_QueryFrame(dragTarget->GetPrimaryFrame());
 36655:         if (treeBody) {
 20988:           treeBody->GetSelectionRegion(getter_AddRefs(region));
 18445:         }
 18445:       }
 18445:     }
 18445: #endif
 18445: 
189111:     dragService->InvokeDragSessionWithImage(dragTarget->AsDOMNode(), transArray,
189111:                                             region, action,
189111:                                             dragImage ? dragImage->AsDOMNode() :
189111:                                                         nullptr,
189111:                                             imageX,
189111:                                             imageY, domDragEvent,
 18445:                                             aDataTransfer);
 18445:   }
 34683: 
 80486:   return true;
 18445: }
 18445: 
     1: nsresult
218485: EventStateManager::GetContentViewer(nsIContentViewer** aCv)
     1: {
218485:   *aCv = nullptr;
  7251: 
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if(!fm) return NS_ERROR_FAILURE;
 29018: 
 29018:   nsCOMPtr<nsIDOMWindow> focusedWindow;
 29018:   fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> ourWindow = do_QueryInterface(focusedWindow);
     1:   if(!ourWindow) return NS_ERROR_FAILURE;
     1: 
 73870:   nsIDOMWindow *rootWindow = ourWindow->GetPrivateRoot();
     1:   if(!rootWindow) return NS_ERROR_FAILURE;
     1: 
     1:   nsCOMPtr<nsIDOMWindow> contentWindow;
     1:   rootWindow->GetContent(getter_AddRefs(contentWindow));
     1:   if(!contentWindow) return NS_ERROR_FAILURE;
     1: 
     1:   nsIDocument *doc = GetDocumentFromWindow(contentWindow);
     1:   if(!doc) return NS_ERROR_FAILURE;
     1: 
 46225:   nsIPresShell *presShell = doc->GetShell();
     1:   if(!presShell) return NS_ERROR_FAILURE;
     1:   nsPresContext *presContext = presShell->GetPresContext();
     1:   if(!presContext) return NS_ERROR_FAILURE;
     1: 
177265:   nsCOMPtr<nsIDocShell> docshell(presContext->GetDocShell());
     1:   if(!docshell) return NS_ERROR_FAILURE;
     1: 
218485:   docshell->GetContentViewer(aCv);
218485:   if(!*aCv) return NS_ERROR_FAILURE;
  7251: 
  7251:   return NS_OK;
  7251: }
  7251: 
  7251: nsresult
196025: EventStateManager::ChangeTextSize(int32_t change)
  7251: {
218485:   nsCOMPtr<nsIContentViewer> cv;
218485:   nsresult rv = GetContentViewer(getter_AddRefs(cv));
  7251:   NS_ENSURE_SUCCESS(rv, rv);
  7251: 
  7251:   float textzoom;
 70842:   float zoomMin = ((float)Preferences::GetInt("zoom.minPercent", 50)) / 100;
 70842:   float zoomMax = ((float)Preferences::GetInt("zoom.maxPercent", 300)) / 100;
218485:   cv->GetTextZoom(&textzoom);
  7251:   textzoom += ((float)change) / 10;
 20751:   if (textzoom < zoomMin)
 20751:     textzoom = zoomMin;
 20751:   else if (textzoom > zoomMax)
 20751:     textzoom = zoomMax;
218485:   cv->SetTextZoom(textzoom);
  7251: 
  7251:   return NS_OK;
  7251: }
  7251: 
  7251: nsresult
196025: EventStateManager::ChangeFullZoom(int32_t change)
  7251: {
218485:   nsCOMPtr<nsIContentViewer> cv;
218485:   nsresult rv = GetContentViewer(getter_AddRefs(cv));
  7251:   NS_ENSURE_SUCCESS(rv, rv);
  7251: 
  7187:   float fullzoom;
 70842:   float zoomMin = ((float)Preferences::GetInt("zoom.minPercent", 50)) / 100;
 70842:   float zoomMax = ((float)Preferences::GetInt("zoom.maxPercent", 300)) / 100;
218485:   cv->GetFullZoom(&fullzoom);
  7187:   fullzoom += ((float)change) / 10;
  7187:   if (fullzoom < zoomMin)
  7187:     fullzoom = zoomMin;
  7187:   else if (fullzoom > zoomMax)
  7187:     fullzoom = zoomMax;
218485:   cv->SetFullZoom(fullzoom);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: void
196025: EventStateManager::DoScrollHistory(int32_t direction)
     1: {
177265:   nsCOMPtr<nsISupports> pcContainer(mPresContext->GetContainerWeak());
     1:   if (pcContainer) {
     1:     nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(pcContainer));
     1:     if (webNav) {
     1:       // positive direction to go back one step, nonpositive to go forward
     1:       if (direction > 0)
     1:         webNav->GoBack();
     1:       else
     1:         webNav->GoForward();
     1:     }
     1:   }
     1: }
     1: 
     1: void
196025: EventStateManager::DoScrollZoom(nsIFrame* aTargetFrame,
108991:                                 int32_t adjustment)
  7251: {
177087:   // Exclude form controls and content in chrome docshells.
  7251:   nsIContent *content = aTargetFrame->GetContent();
  7251:   if (content &&
  7251:       !content->IsNodeOfType(nsINode::eHTML_FORM_CONTROL) &&
177087:       !nsContentUtils::IsInChromeDocshell(content->OwnerDoc()))
  7251:     {
 11660:       // positive adjustment to decrease zoom, negative to increase
108991:       int32_t change = (adjustment > 0) ? -1 : 1;
 11660: 
207684:       if (Preferences::GetBool("browser.zoom.full") || content->OwnerDoc()->IsSyntheticDocument()) {
 11660:         ChangeFullZoom(change);
 70840:       } else {
 11660:         ChangeTextSize(change);
     1:       }
223532:       nsContentUtils::DispatchChromeEvent(mDocument, static_cast<nsIDocument*>(mDocument),
223532:                                           NS_LITERAL_STRING("ZoomChangeUsingMouseWheel"),
223532:                                           true, true);
     1:     }
 70840: }
     1: 
     1: static nsIFrame*
 37058: GetParentFrameToScroll(nsIFrame* aFrame)
     1: {
 37058:   if (!aFrame)
106838:     return nullptr;
     1: 
132812:   if (aFrame->StyleDisplay()->mPosition == NS_STYLE_POSITION_FIXED &&
 21930:       nsLayoutUtils::IsReallyFixedPos(aFrame))
 37058:     return aFrame->PresContext()->GetPresShell()->GetRootScrollFrame();
     1: 
     1:   return aFrame->GetParent();
     1: }
     1: 
 26874: void
196025: EventStateManager::DispatchLegacyMouseScrollEvents(nsIFrame* aTargetFrame,
165701:                                                    WidgetWheelEvent* aEvent,
108060:                                                    nsEventStatus* aStatus)
108060: {
108060:   MOZ_ASSERT(aEvent);
108060:   MOZ_ASSERT(aStatus);
108060: 
108060:   if (!aTargetFrame || *aStatus == nsEventStatus_eConsumeNoDefault) {
108060:     return;
108060:   }
108060: 
108060:   // Ignore mouse wheel transaction for computing legacy mouse wheel
108060:   // events' delta value.
108060:   nsIScrollableFrame* scrollTarget =
111054:     ComputeScrollTarget(aTargetFrame, aEvent,
111054:                         COMPUTE_LEGACY_MOUSE_SCROLL_EVENT_TARGET);
108060: 
108060:   nsIFrame* scrollFrame = do_QueryFrame(scrollTarget);
108060:   nsPresContext* pc =
108060:     scrollFrame ? scrollFrame->PresContext() : aTargetFrame->PresContext();
108060: 
108060:   // DOM event's delta vales are computed from CSS pixels.
108060:   nsSize scrollAmount = GetScrollAmount(pc, aEvent, scrollTarget);
108060:   nsIntSize scrollAmountInCSSPixels(
108060:     nsPresContext::AppUnitsToIntCSSPixels(scrollAmount.width),
108060:     nsPresContext::AppUnitsToIntCSSPixels(scrollAmount.height));
108060: 
108743:   // XXX We don't deal with fractional amount in legacy event, though the
108743:   //     default action handler (DoScrollText()) deals with it.
108743:   //     If we implemented such strict computation, we would need additional
108743:   //     accumulated delta values. It would made the code more complicated.
108743:   //     And also it would computes different delta values from older version.
108743:   //     It doesn't make sense to implement such code for legacy events and
108743:   //     rare cases.
108991:   int32_t scrollDeltaX, scrollDeltaY, pixelDeltaX, pixelDeltaY;
108060:   switch (aEvent->deltaMode) {
108060:     case nsIDOMWheelEvent::DOM_DELTA_PAGE:
108060:       scrollDeltaX =
108060:         !aEvent->lineOrPageDeltaX ? 0 :
108060:           (aEvent->lineOrPageDeltaX > 0  ? nsIDOMUIEvent::SCROLL_PAGE_DOWN :
108060:                                            nsIDOMUIEvent::SCROLL_PAGE_UP);
108060:       scrollDeltaY =
108060:         !aEvent->lineOrPageDeltaY ? 0 :
108060:           (aEvent->lineOrPageDeltaY > 0  ? nsIDOMUIEvent::SCROLL_PAGE_DOWN :
108060:                                            nsIDOMUIEvent::SCROLL_PAGE_UP);
108060:       pixelDeltaX = RoundDown(aEvent->deltaX * scrollAmountInCSSPixels.width);
108060:       pixelDeltaY = RoundDown(aEvent->deltaY * scrollAmountInCSSPixels.height);
108060:       break;
108060: 
108060:     case nsIDOMWheelEvent::DOM_DELTA_LINE:
108060:       scrollDeltaX = aEvent->lineOrPageDeltaX;
108060:       scrollDeltaY = aEvent->lineOrPageDeltaY;
108060:       pixelDeltaX = RoundDown(aEvent->deltaX * scrollAmountInCSSPixels.width);
108060:       pixelDeltaY = RoundDown(aEvent->deltaY * scrollAmountInCSSPixels.height);
108060:       break;
108060: 
108060:     case nsIDOMWheelEvent::DOM_DELTA_PIXEL:
108060:       scrollDeltaX = aEvent->lineOrPageDeltaX;
108060:       scrollDeltaY = aEvent->lineOrPageDeltaY;
108060:       pixelDeltaX = RoundDown(aEvent->deltaX);
108060:       pixelDeltaY = RoundDown(aEvent->deltaY);
108060:       break;
108060: 
108060:     default:
150033:       MOZ_CRASH("Invalid deltaMode value comes");
108060:   }
108060: 
108060:   // Send the legacy events in following order:
108060:   // 1. Vertical scroll
108060:   // 2. Vertical pixel scroll (even if #1 isn't consumed)
108060:   // 3. Horizontal scroll (even if #1 and/or #2 are consumed)
108060:   // 4. Horizontal pixel scroll (even if #3 isn't consumed)
108060: 
108060:   nsWeakFrame targetFrame(aTargetFrame);
108060: 
175113:   MOZ_ASSERT(*aStatus != nsEventStatus_eConsumeNoDefault &&
175113:              !aEvent->mFlags.mDefaultPrevented,
175113:              "If you make legacy events dispatched for default prevented wheel "
175113:              "event, you need to initialize stateX and stateY");
175113:   EventState stateX, stateY;
108060:   if (scrollDeltaY) {
175113:     SendLineScrollEvent(aTargetFrame, aEvent, stateY,
108060:                         scrollDeltaY, DELTA_DIRECTION_Y);
108060:     if (!targetFrame.IsAlive()) {
108060:       *aStatus = nsEventStatus_eConsumeNoDefault;
108060:       return;
108060:     }
108060:   }
108060: 
108060:   if (pixelDeltaY) {
175113:     SendPixelScrollEvent(aTargetFrame, aEvent, stateY,
108060:                          pixelDeltaY, DELTA_DIRECTION_Y);
108060:     if (!targetFrame.IsAlive()) {
108060:       *aStatus = nsEventStatus_eConsumeNoDefault;
108060:       return;
108060:     }
108060:   }
108060: 
108060:   if (scrollDeltaX) {
175113:     SendLineScrollEvent(aTargetFrame, aEvent, stateX,
108060:                         scrollDeltaX, DELTA_DIRECTION_X);
108060:     if (!targetFrame.IsAlive()) {
108060:       *aStatus = nsEventStatus_eConsumeNoDefault;
108060:       return;
108060:     }
108060:   }
108060: 
108060:   if (pixelDeltaX) {
175113:     SendPixelScrollEvent(aTargetFrame, aEvent, stateX,
108060:                          pixelDeltaX, DELTA_DIRECTION_X);
108060:     if (!targetFrame.IsAlive()) {
108060:       *aStatus = nsEventStatus_eConsumeNoDefault;
108060:       return;
108060:     }
108060:   }
108060: 
175113:   if (stateY.mDefaultPrevented || stateX.mDefaultPrevented) {
108060:     *aStatus = nsEventStatus_eConsumeNoDefault;
175113:     aEvent->mFlags.mDefaultPrevented = true;
175113:     aEvent->mFlags.mDefaultPreventedByContent |=
175113:       stateY.mDefaultPreventedByContent || stateX.mDefaultPreventedByContent;
108060:   }
108060: }
108060: 
108060: void
196025: EventStateManager::SendLineScrollEvent(nsIFrame* aTargetFrame,
165701:                                        WidgetWheelEvent* aEvent,
175113:                                        EventState& aState,
108991:                                        int32_t aDelta,
108060:                                        DeltaDirection aDeltaDirection)
 26874: {
 26874:   nsCOMPtr<nsIContent> targetContent = aTargetFrame->GetContent();
 26874:   if (!targetContent)
 29018:     targetContent = GetFocusedContent();
 26874:   if (!targetContent)
 26874:     return;
 26874: 
 26874:   while (targetContent->IsNodeOfType(nsINode::eTEXT)) {
 26874:     targetContent = targetContent->GetParent();
 26874:   }
 26874: 
164205:   WidgetMouseScrollEvent event(aEvent->mFlags.mIsTrusted, NS_MOUSE_SCROLL,
108060:                                aEvent->widget);
175113:   event.mFlags.mDefaultPrevented = aState.mDefaultPrevented;
175113:   event.mFlags.mDefaultPreventedByContent = aState.mDefaultPreventedByContent;
 26874:   event.refPoint = aEvent->refPoint;
 26874:   event.widget = aEvent->widget;
 26874:   event.time = aEvent->time;
207315:   event.timeStamp = aEvent->timeStamp;
 96887:   event.modifiers = aEvent->modifiers;
 96888:   event.buttons = aEvent->buttons;
108076:   event.isHorizontal = (aDeltaDirection == DELTA_DIRECTION_X);
108060:   event.delta = aDelta;
108060:   event.inputSource = aEvent->inputSource;
108060: 
175113:   nsEventStatus status = nsEventStatus_eIgnore;
193672:   EventDispatcher::Dispatch(targetContent, aTargetFrame->PresContext(),
175113:                             &event, nullptr, &status);
175113:   aState.mDefaultPrevented =
175113:     event.mFlags.mDefaultPrevented || status == nsEventStatus_eConsumeNoDefault;
175113:   aState.mDefaultPreventedByContent = event.mFlags.mDefaultPreventedByContent;
 26874: }
 26874: 
 26874: void
196025: EventStateManager::SendPixelScrollEvent(nsIFrame* aTargetFrame,
165701:                                         WidgetWheelEvent* aEvent,
175113:                                         EventState& aState,
108991:                                         int32_t aPixelDelta,
108060:                                         DeltaDirection aDeltaDirection)
 26874: {
 26874:   nsCOMPtr<nsIContent> targetContent = aTargetFrame->GetContent();
 29018:   if (!targetContent) {
 29018:     targetContent = GetFocusedContent();
 26874:     if (!targetContent)
 26874:       return;
 29018:   }
 26874: 
 26874:   while (targetContent->IsNodeOfType(nsINode::eTEXT)) {
 26874:     targetContent = targetContent->GetParent();
 26874:   }
 26874: 
164205:   WidgetMouseScrollEvent event(aEvent->mFlags.mIsTrusted, NS_MOUSE_PIXEL_SCROLL,
108060:                                aEvent->widget);
175113:   event.mFlags.mDefaultPrevented = aState.mDefaultPrevented;
175113:   event.mFlags.mDefaultPreventedByContent = aState.mDefaultPreventedByContent;
 19319:   event.refPoint = aEvent->refPoint;
 19319:   event.widget = aEvent->widget;
 19319:   event.time = aEvent->time;
207315:   event.timeStamp = aEvent->timeStamp;
 96887:   event.modifiers = aEvent->modifiers;
 96888:   event.buttons = aEvent->buttons;
108076:   event.isHorizontal = (aDeltaDirection == DELTA_DIRECTION_X);
108060:   event.delta = aPixelDelta;
108060:   event.inputSource = aEvent->inputSource;
108060: 
175113:   nsEventStatus status = nsEventStatus_eIgnore;
193672:   EventDispatcher::Dispatch(targetContent, aTargetFrame->PresContext(),
175113:                             &event, nullptr, &status);
175113:   aState.mDefaultPrevented =
175113:     event.mFlags.mDefaultPrevented || status == nsEventStatus_eConsumeNoDefault;
175113:   aState.mDefaultPreventedByContent = event.mFlags.mDefaultPreventedByContent;
 19319: }
 19319: 
108050: nsIScrollableFrame*
196025: EventStateManager::ComputeScrollTarget(nsIFrame* aTargetFrame,
165701:                                        WidgetWheelEvent* aEvent,
111054:                                        ComputeScrollTargetOptions aOptions)
     1: {
165307:   return ComputeScrollTarget(aTargetFrame, aEvent->deltaX, aEvent->deltaY,
165307:                              aEvent, aOptions);
165307: }
165307: 
165307: // Overload ComputeScrollTarget method to allow passing "test" dx and dy when looking
224155: // for which scrollbarmediators to activate when two finger down on trackpad
165307: // and before any actual motion
165307: nsIScrollableFrame*
196025: EventStateManager::ComputeScrollTarget(nsIFrame* aTargetFrame,
165307:                                        double aDirectionX,
165307:                                        double aDirectionY,
165701:                                        WidgetWheelEvent* aEvent,
165307:                                        ComputeScrollTargetOptions aOptions)
165307: {
111054:   if (aOptions & PREFER_MOUSE_WHEEL_TRANSACTION) {
108051:     // If the user recently scrolled with the mousewheel, then they probably
108051:     // want to scroll the same view as before instead of the view under the
196023:     // cursor.  WheelTransaction tracks the frame currently being
108051:     // scrolled with the mousewheel. We consider the transaction ended when the
108051:     // mouse moves more than "mousewheel.transaction.ignoremovedelay"
108051:     // milliseconds after the last scroll operation, or any time the mouse moves
108051:     // out of the frame, or when more than "mousewheel.transaction.timeout"
108051:     // milliseconds have passed after the last operation, even if the mouse
108051:     // hasn't moved.
196023:     nsIFrame* lastScrollFrame = WheelTransaction::GetTargetFrame();
     1:     if (lastScrollFrame) {
108051:       nsIScrollableFrame* frameToScroll =
108051:         lastScrollFrame->GetScrollTargetFrame();
 37058:       if (frameToScroll) {
108050:         return frameToScroll;
108050:       }
108050:     }
108051:   }
108050: 
108059:   // If the event doesn't cause scroll actually, we cannot find scroll target
108059:   // because we check if the event can cause scroll actually on each found
108059:   // scrollable frame.
165307:   if (!aDirectionX && !aDirectionY) {
108059:     return nullptr;
108059:   }
108059: 
111054:   bool checkIfScrollableX =
165307:     aDirectionX && (aOptions & PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_X_AXIS);
111054:   bool checkIfScrollableY =
165307:     aDirectionY && (aOptions & PREFER_ACTUAL_SCROLLABLE_TARGET_ALONG_Y_AXIS);
111054: 
108050:   nsIScrollableFrame* frameToScroll = nullptr;
111054:   nsIFrame* scrollFrame =
111054:     !(aOptions & START_FROM_PARENT) ? aTargetFrame :
111054:                                       GetParentFrameToScroll(aTargetFrame);
111054:   for (; scrollFrame; scrollFrame = GetParentFrameToScroll(scrollFrame)) {
     1:     // Check whether the frame wants to provide us with a scrollable view.
 37058:     frameToScroll = scrollFrame->GetScrollTargetFrame();
 37058:     if (!frameToScroll) {
     1:       continue;
     1:     }
     1: 
179647:     // Don't scroll vertically by mouse-wheel on a single-line text control.
179647:     if (checkIfScrollableY) {
179647:       nsIContent* c = scrollFrame->GetContent();
179647:       nsCOMPtr<nsITextControlElement> ctrl =
179647:         do_QueryInterface(c->IsInAnonymousSubtree() ? c->GetBindingParent() : c);
179647:       if (ctrl && ctrl->IsSingleLineTextControl()) {
179647:         continue;
179647:       }
179647:     }
179647: 
111054:     if (!checkIfScrollableX && !checkIfScrollableY) {
108051:       return frameToScroll;
108051:     }
108051: 
157995:     ScrollbarStyles ss = frameToScroll->GetScrollbarStyles();
108059:     bool hiddenForV = (NS_STYLE_OVERFLOW_HIDDEN == ss.mVertical);
108059:     bool hiddenForH = (NS_STYLE_OVERFLOW_HIDDEN == ss.mHorizontal);
108059:     if ((hiddenForV && hiddenForH) ||
111054:         (checkIfScrollableY && !checkIfScrollableX && hiddenForV) ||
111054:         (checkIfScrollableX && !checkIfScrollableY && hiddenForH)) {
     1:       continue;
     1:     }
     1: 
108051:     // For default action, we should climb up the tree if cannot scroll it
108051:     // by the event actually.
196021:     bool canScroll =
196021:       WheelHandlingUtils::CanScrollOn(frameToScroll, aDirectionX, aDirectionY);
     1:     // Comboboxes need special care.
 23554:     nsIComboboxControlFrame* comboBox = do_QueryFrame(scrollFrame);
     1:     if (comboBox) {
     1:       if (comboBox->IsDroppedDown()) {
     1:         // Don't propagate to parent when drop down menu is active.
108051:         return canScroll ? frameToScroll : nullptr;
108051:       }
     1:       // Always propagate when not dropped down (even if focused).
108051:       continue;
108051:     }
108051: 
108051:     if (canScroll) {
108050:       return frameToScroll;
108050:     }
108051:   }
108050: 
108050:   nsIFrame* newFrame = nsLayoutUtils::GetCrossDocParentFrame(
108050:       aTargetFrame->PresContext()->FrameManager()->GetRootFrame());
111054:   aOptions =
111054:     static_cast<ComputeScrollTargetOptions>(aOptions & ~START_FROM_PARENT);
157561:   return newFrame ? ComputeScrollTarget(newFrame, aEvent, aOptions) : nullptr;
108051: }
108051: 
108057: nsSize
196025: EventStateManager::GetScrollAmount(nsPresContext* aPresContext,
165701:                                    WidgetWheelEvent* aEvent,
108051:                                    nsIScrollableFrame* aScrollableFrame)
108051: {
108051:   MOZ_ASSERT(aPresContext);
108051:   MOZ_ASSERT(aEvent);
108059: 
108059:   bool isPage = (aEvent->deltaMode == nsIDOMWheelEvent::DOM_DELTA_PAGE);
108051:   if (aScrollableFrame) {
108057:     return isPage ? aScrollableFrame->GetPageScrollAmount() :
108051:                     aScrollableFrame->GetLineScrollAmount();
108051:   }
108051: 
108051:   // If there is no scrollable frame and page scrolling, use view port size.
108051:   if (isPage) {
108057:     return aPresContext->GetVisibleArea().Size();
108051:   }
108051: 
108051:   // If there is no scrollable frame, we should use root frame's information.
108051:   nsIFrame* rootFrame = aPresContext->PresShell()->GetRootFrame();
108051:   if (!rootFrame) {
108057:     return nsSize(0, 0);
108051:   }
108051:   nsRefPtr<nsFontMetrics> fm;
108051:   nsLayoutUtils::GetFontMetricsForFrame(rootFrame, getter_AddRefs(fm),
108051:     nsLayoutUtils::FontSizeInflationFor(rootFrame));
108057:   NS_ENSURE_TRUE(fm, nsSize(0, 0));
120305:   return nsSize(fm->AveCharWidth(), fm->MaxHeight());
108050: }
108050: 
108059: void
196025: EventStateManager::DoScrollText(nsIScrollableFrame* aScrollableFrame,
165701:                                 WidgetWheelEvent* aEvent)
108050: {
108059:   MOZ_ASSERT(aScrollableFrame);
108059:   MOZ_ASSERT(aEvent);
108059: 
108059:   nsIFrame* scrollFrame = do_QueryFrame(aScrollableFrame);
108050:   MOZ_ASSERT(scrollFrame);
108050:   nsWeakFrame scrollFrameWeak(scrollFrame);
108050: 
196023:   nsIFrame* lastScrollFrame = WheelTransaction::GetTargetFrame();
108050:   if (!lastScrollFrame) {
196023:     WheelTransaction::BeginTransaction(scrollFrame, aEvent);
108050:   } else if (lastScrollFrame != scrollFrame) {
196023:     WheelTransaction::EndTransaction();
196023:     WheelTransaction::BeginTransaction(scrollFrame, aEvent);
108050:   } else {
196023:     WheelTransaction::UpdateTransaction(aEvent);
108059:   }
108050: 
108050:   // When the scroll event will not scroll any views, UpdateTransaction
108050:   // fired MozMouseScrollFailed event which is for automated testing.
108050:   // In the event handler, the target frame might be destroyed.  Then,
108050:   // we should not try scrolling anything.
108050:   if (!scrollFrameWeak.IsAlive()) {
196023:     WheelTransaction::EndTransaction();
108059:     return;
108059:   }
108059: 
108059:   // Default action's actual scroll amount should be computed from device
108059:   // pixels.
108059:   nsPresContext* pc = scrollFrame->PresContext();
108059:   nsSize scrollAmount = GetScrollAmount(pc, aEvent, aScrollableFrame);
108059:   nsIntSize scrollAmountInDevPixels(
108059:     pc->AppUnitsToDevPixels(scrollAmount.width),
108059:     pc->AppUnitsToDevPixels(scrollAmount.height));
108743:   nsIntPoint actualDevPixelScrollAmount =
108743:     DeltaAccumulator::GetInstance()->
108743:       ComputeScrollAmountForDefaultAction(aEvent, scrollAmountInDevPixels);
108059: 
110714:   // Don't scroll around the axis whose overflow style is hidden.
157995:   ScrollbarStyles overflowStyle = aScrollableFrame->GetScrollbarStyles();
110714:   if (overflowStyle.mHorizontal == NS_STYLE_OVERFLOW_HIDDEN) {
110714:     actualDevPixelScrollAmount.x = 0;
110714:   }
110714:   if (overflowStyle.mVertical == NS_STYLE_OVERFLOW_HIDDEN) {
110714:     actualDevPixelScrollAmount.y = 0;
110714:   }
110714: 
108059:   nsIAtom* origin = nullptr;
108059:   switch (aEvent->deltaMode) {
108059:     case nsIDOMWheelEvent::DOM_DELTA_LINE:
108059:       origin = nsGkAtoms::mouseWheel;
108059:       break;
108059:     case nsIDOMWheelEvent::DOM_DELTA_PAGE:
108059:       origin = nsGkAtoms::pages;
108059:       break;
108059:     case nsIDOMWheelEvent::DOM_DELTA_PIXEL:
108059:       origin = nsGkAtoms::pixels;
108059:       break;
108059:     default:
150033:       MOZ_CRASH("Invalid deltaMode value comes");
108059:   }
108059: 
120483:   // We shouldn't scroll more one page at once except when over one page scroll
120483:   // is allowed for the event.
108059:   nsSize pageSize = aScrollableFrame->GetPageScrollAmount();
108059:   nsIntSize devPixelPageSize(pc->AppUnitsToDevPixels(pageSize.width),
108059:                              pc->AppUnitsToDevPixels(pageSize.height));
120483:   if (!WheelPrefs::GetInstance()->IsOverOnePageScrollAllowedX(aEvent) &&
135921:       DeprecatedAbs(actualDevPixelScrollAmount.x) > devPixelPageSize.width) {
108059:     actualDevPixelScrollAmount.x =
108059:       (actualDevPixelScrollAmount.x >= 0) ? devPixelPageSize.width :
108059:                                             -devPixelPageSize.width;
108059:   }
108059: 
120483:   if (!WheelPrefs::GetInstance()->IsOverOnePageScrollAllowedY(aEvent) &&
135921:       DeprecatedAbs(actualDevPixelScrollAmount.y) > devPixelPageSize.height) {
108059:     actualDevPixelScrollAmount.y =
108059:       (actualDevPixelScrollAmount.y >= 0) ? devPixelPageSize.height :
108059:                                             -devPixelPageSize.height;
108059:   }
108059: 
108743:   bool isDeltaModePixel =
108743:     (aEvent->deltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL);
108743: 
108063:   nsIScrollableFrame::ScrollMode mode;
108063:   switch (aEvent->scrollType) {
165701:     case WidgetWheelEvent::SCROLL_DEFAULT:
108063:       if (isDeltaModePixel) {
108063:         mode = nsIScrollableFrame::NORMAL;
108063:       } else {
108063:         mode = nsIScrollableFrame::SMOOTH;
108063:       }
108063:       break;
165701:     case WidgetWheelEvent::SCROLL_SYNCHRONOUSLY:
108063:       mode = nsIScrollableFrame::INSTANT;
108063:       break;
165701:     case WidgetWheelEvent::SCROLL_ASYNCHRONOUSELY:
108063:       mode = nsIScrollableFrame::NORMAL;
108063:       break;
165701:     case WidgetWheelEvent::SCROLL_SMOOTHLY:
108063:       mode = nsIScrollableFrame::SMOOTH;
108063:       break;
108063:     default:
150033:       MOZ_CRASH("Invalid scrollType value comes");
108063:   }
 70338: 
 37058:   nsIntPoint overflow;
108059:   aScrollableFrame->ScrollBy(actualDevPixelScrollAmount,
108059:                              nsIScrollableFrame::DEVICE_PIXELS,
219668:                              mode, &overflow, origin, aEvent->isMomentum);
108059: 
111054:   if (!scrollFrameWeak.IsAlive()) {
111054:     // If the scroll causes changing the layout, we can think that the event
111054:     // has been completely consumed by the content.  Then, users probably don't
111054:     // want additional action.
111054:     aEvent->overflowDeltaX = aEvent->overflowDeltaY = 0;
111054:   } else if (isDeltaModePixel) {
108059:     aEvent->overflowDeltaX = overflow.x;
108059:     aEvent->overflowDeltaY = overflow.y;
108059:   } else {
108059:     aEvent->overflowDeltaX =
108059:       static_cast<double>(overflow.x) / scrollAmountInDevPixels.width;
108059:     aEvent->overflowDeltaY =
108059:       static_cast<double>(overflow.y) / scrollAmountInDevPixels.height;
108059:   }
110714: 
110714:   // If CSS overflow properties caused not to scroll, the overflowDelta* values
110714:   // should be same as delta* values since they may be used as gesture event by
111054:   // widget.  However, if there is another scrollable element in the ancestor
111054:   // along the axis, probably users don't want the operation to cause
111054:   // additional action such as moving history.  In such case, overflowDelta
111054:   // values should stay zero.
111054:   if (scrollFrameWeak.IsAlive()) {
111054:     if (aEvent->deltaX &&
111054:         overflowStyle.mHorizontal == NS_STYLE_OVERFLOW_HIDDEN &&
111054:         !ComputeScrollTarget(scrollFrame, aEvent,
111054:                              COMPUTE_SCROLLABLE_ANCESTOR_ALONG_X_AXIS)) {
110714:       aEvent->overflowDeltaX = aEvent->deltaX;
110714:     }
111054:     if (aEvent->deltaY &&
111054:         overflowStyle.mVertical == NS_STYLE_OVERFLOW_HIDDEN &&
111054:         !ComputeScrollTarget(scrollFrame, aEvent,
111054:                              COMPUTE_SCROLLABLE_ANCESTOR_ALONG_Y_AXIS)) {
110714:       aEvent->overflowDeltaY = aEvent->deltaY;
110714:     }
111054:   }
110714: 
110714:   NS_ASSERTION(aEvent->overflowDeltaX == 0 ||
111054:     (aEvent->overflowDeltaX > 0) == (aEvent->deltaX > 0),
110714:     "The sign of overflowDeltaX is different from the scroll direction");
110714:   NS_ASSERTION(aEvent->overflowDeltaY == 0 ||
111054:     (aEvent->overflowDeltaY > 0) == (aEvent->deltaY > 0),
110714:     "The sign of overflowDeltaY is different from the scroll direction");
110714: 
108066:   WheelPrefs::GetInstance()->CancelApplyingUserPrefsFromOverflowDelta(aEvent);
 28609: }
 28609: 
 31443: void
196025: EventStateManager::DecideGestureEvent(WidgetGestureNotifyEvent* aEvent,
 31443:                                       nsIFrame* targetFrame)
 31443: {
 31443: 
 31443:   NS_ASSERTION(aEvent->message == NS_GESTURENOTIFY_EVENT_START,
 31443:                "DecideGestureEvent called with a non-gesture event");
 31443: 
 31443:   /* Check the ancestor tree to decide if any frame is willing* to receive
 31443:    * a MozPixelScroll event. If that's the case, the current touch gesture
 31443:    * will be used as a pan gesture; otherwise it will be a regular
 31443:    * mousedown/mousemove/click event.
 31443:    *
 31443:    * *willing: determine if it makes sense to pan the element using scroll events:
 31443:    *  - For web content: if there are any visible scrollbars on the touch point
 31443:    *  - For XUL: if it's an scrollable element that can currently scroll in some
 31443:     *    direction.
 31443:    *
 31443:    * Note: we'll have to one-off various cases to ensure a good usable behavior
 31443:    */
163726:   WidgetGestureNotifyEvent::ePanDirection panDirection =
163726:     WidgetGestureNotifyEvent::ePanNone;
 79445:   bool displayPanFeedback = false;
 31443:   for (nsIFrame* current = targetFrame; current;
 31443:        current = nsLayoutUtils::GetCrossDocParentFrame(current)) {
 31443: 
 31443:     nsIAtom* currentFrameType = current->GetType();
 31443: 
 31443:     // Scrollbars should always be draggable
 31443:     if (currentFrameType == nsGkAtoms::scrollbarFrame) {
163726:       panDirection = WidgetGestureNotifyEvent::ePanNone;
 31443:       break;
 31443:     }
 31443: 
 31443: #ifdef MOZ_XUL
 31443:     // Special check for trees
 31443:     nsTreeBodyFrame* treeFrame = do_QueryFrame(current);
 31443:     if (treeFrame) {
 31443:       if (treeFrame->GetHorizontalOverflow()) {
163726:         panDirection = WidgetGestureNotifyEvent::ePanHorizontal;
 31443:       }
 31443:       if (treeFrame->GetVerticalOverflow()) {
163726:         panDirection = WidgetGestureNotifyEvent::ePanVertical;
 31443:       }
 31443:       break;
 31443:     }
 31443: #endif
 31443: 
 31443:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(current);
 31443:     if (scrollableFrame) {
 31443:       if (current->IsFrameOfType(nsIFrame::eXULBox)) {
 80486:         displayPanFeedback = true;
 31443: 
 37061:         nsRect scrollRange = scrollableFrame->GetScrollRange();
 79445:         bool canScrollHorizontally = scrollRange.width > 0;
 31443: 
 31443:         if (targetFrame->GetType() == nsGkAtoms::menuFrame) {
 31443:           // menu frames report horizontal scroll when they have submenus
 31443:           // and we don't want that
 80486:           canScrollHorizontally = false;
 80486:           displayPanFeedback = false;
 31443:         }
 31443: 
 31443:         // Vertical panning has priority over horizontal panning, so
 37061:         // when vertical movement is possible we can just finish the loop.
 37061:         if (scrollRange.height > 0) {
163726:           panDirection = WidgetGestureNotifyEvent::ePanVertical;
 31443:           break;
 31443:         }
 31443: 
 37061:         if (canScrollHorizontally) {
163726:           panDirection = WidgetGestureNotifyEvent::ePanHorizontal;
 80486:           displayPanFeedback = false;
 31443:         }
 31443:       } else { //Not a XUL box
108991:         uint32_t scrollbarVisibility = scrollableFrame->GetScrollbarVisibility();
 31443: 
 31443:         //Check if we have visible scrollbars
 37292:         if (scrollbarVisibility & nsIScrollableFrame::VERTICAL) {
163726:           panDirection = WidgetGestureNotifyEvent::ePanVertical;
 80486:           displayPanFeedback = true;
 31443:           break;
 31443:         }
 31443: 
 37292:         if (scrollbarVisibility & nsIScrollableFrame::HORIZONTAL) {
163726:           panDirection = WidgetGestureNotifyEvent::ePanHorizontal;
 80486:           displayPanFeedback = true;
 31443:         }
 37061:       }
 31443:     } //scrollableFrame
 31443:   } //ancestor chain
 31443: 
 31443:   aEvent->displayPanFeedback = displayPanFeedback;
 31443:   aEvent->panDirection = panDirection;
 31443: }
 31443: 
 58135: #ifdef XP_MACOSX
 47793: static bool
 47793: NodeAllowsClickThrough(nsINode* aNode)
 47793: {
 47793:   while (aNode) {
 47793:     if (aNode->IsElement() && aNode->AsElement()->IsXUL()) {
 47793:       mozilla::dom::Element* element = aNode->AsElement();
 47793:       static nsIContent::AttrValuesArray strings[] =
106838:         {&nsGkAtoms::always, &nsGkAtoms::never, nullptr};
 47793:       switch (element->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::clickthrough,
 47793:                                        strings, eCaseMatters)) {
 47793:         case 0:
 47793:           return true;
 47793:         case 1:
 47793:           return false;
 47793:       }
 47793:     }
 47793:     aNode = nsContentUtils::GetCrossDocParentNode(aNode);
 47793:   }
 47793:   return true;
 47793: }
 58135: #endif
 47793: 
 68780: nsresult
196025: EventStateManager::PostHandleEvent(nsPresContext* aPresContext,
164382:                                    WidgetEvent* aEvent,
     1:                                    nsIFrame* aTargetFrame,
 82566:                                    nsEventStatus* aStatus)
     1: {
     1:   NS_ENSURE_ARG(aPresContext);
     1:   NS_ENSURE_ARG_POINTER(aStatus);
    55: 
153610:   bool dispatchedToContentProcess = HandleCrossProcessEvent(aEvent,
153610:                                                             aStatus);
 73592: 
     1:   mCurrentTarget = aTargetFrame;
106838:   mCurrentTargetContent = nullptr;
    55: 
  8236:   // Most of the events we handle below require a frame.
  8236:   // Add special cases here.
 55257:   if (!mCurrentTarget && aEvent->message != NS_MOUSE_BUTTON_UP &&
 55257:       aEvent->message != NS_MOUSE_BUTTON_DOWN) {
    55:     return NS_OK;
    55:   }
    55: 
     1:   //Keep the prescontext alive, we might need it after event dispatch
     1:   nsRefPtr<nsPresContext> presContext = aPresContext;
    55:   nsresult ret = NS_OK;
     1: 
     1:   switch (aEvent->message) {
     1:   case NS_MOUSE_BUTTON_DOWN:
     1:     {
166409:       WidgetMouseEvent* mouseEvent = aEvent->AsMouseEvent();
166409:       if (mouseEvent->button == WidgetMouseEvent::eLeftButton &&
 52199:           !sNormalLMouseEventInProcess) {
 32435:         // We got a mouseup event while a mousedown event was being processed.
 32435:         // Make sure that the capturing content is cleared.
106838:         nsIPresShell::SetCapturingContent(nullptr, 0);
     1:         break;
     1:       }
     1: 
227658:       // For remote content, capture the event in the parent process at the
227658:       // <xul:browser remote> element. This will ensure that subsequent mousemove/mouseup
227658:       // events will continue to be dispatched to this element and therefore forwarded
227658:       // to the child.
227658:       if (dispatchedToContentProcess && !nsIPresShell::GetCapturingContent()) {
227658:         nsIContent* content = mCurrentTarget ? mCurrentTarget->GetContent() : nullptr;
227658:         nsIPresShell::SetCapturingContent(content, 0);
227658:       }
227658: 
 55892:       nsCOMPtr<nsIContent> activeContent;
     1:       if (nsEventStatus_eConsumeNoDefault != *aStatus) {
     1:         nsCOMPtr<nsIContent> newFocus;      
 79445:         bool suppressBlur = false;
     1:         if (mCurrentTarget) {
 79435:           mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(newFocus));
132812:           const nsStyleUserInterface* ui = mCurrentTarget->StyleUserInterface();
134640:           activeContent = mCurrentTarget->GetContent();
134640: 
134640:           // In some cases, we do not want to even blur the current focused
134640:           // element. Those cases are:
134640:           // 1. -moz-user-focus CSS property is set to 'ignore';
134640:           // 2. Element with NS_EVENT_STATE_DISABLED
134640:           //    (aka :disabled pseudo-class for HTML element);
134640:           // 3. XUL control element has the disabled property set to 'true'.
134640:           //
134640:           // We can't use nsIFrame::IsFocusable() because we want to blur when
134640:           // we click on a visibility: none element.
134640:           // We can't use nsIContent::IsFocusable() because we want to blur when
134640:           // we click on a non-focusable element like a <div>.
134640:           // We have to use |aEvent->target| to not make sure we do not check an
134640:           // anonymous node of the targeted element.
134381:           suppressBlur = (ui->mUserFocus == NS_STYLE_USER_FOCUS_IGNORE);
134640: 
134640:           if (!suppressBlur) {
134640:             nsCOMPtr<Element> element = do_QueryInterface(aEvent->target);
134640:             suppressBlur = element &&
134640:                            element->State().HasState(NS_EVENT_STATE_DISABLED);
134640:           }
134640: 
134640:           if (!suppressBlur) {
134640:             nsCOMPtr<nsIDOMXULControlElement> xulControl =
134640:               do_QueryInterface(aEvent->target);
134640:             if (xulControl) {
134640:               bool disabled;
134640:               xulControl->GetDisabled(&disabled);
134640:               suppressBlur = disabled;
134640:             }
134640:           }
 29018:         }
 29018: 
172117:         if (!suppressBlur) {
172117:           suppressBlur = nsContentUtils::IsUserFocusIgnored(activeContent);
172117:         }
172117: 
 41068:         nsIFrame* currFrame = mCurrentTarget;
 41068: 
 41068:         // When a root content which isn't editable but has an editable HTML
 41068:         // <body> element is clicked, we should redirect the focus to the
 41068:         // the <body> element.  E.g., when an user click bottom of the editor
 41068:         // where is outside of the <body> element, the <body> should be focused
 41068:         // and the user can edit immediately after that.
 41068:         //
 41068:         // NOTE: The newFocus isn't editable that also means it's not in
 41068:         // designMode.  In designMode, all contents are not focusable.
 41068:         if (newFocus && !newFocus->IsEditable()) {
207686:           nsIDocument *doc = newFocus->GetCrossShadowCurrentDoc();
 41634:           if (doc && newFocus == doc->GetRootElement()) {
 41068:             nsIContent *bodyContent =
 41068:               nsLayoutUtils::GetEditableRootContentByContentEditable(doc);
 41068:             if (bodyContent) {
 41068:               nsIFrame* bodyFrame = bodyContent->GetPrimaryFrame();
 41068:               if (bodyFrame) {
 41068:                 currFrame = bodyFrame;
 41068:                 newFocus = bodyContent;
 41068:               }
 41068:             }
 41068:           }
 41068:         }
 41068: 
 29018:         // When the mouse is pressed, the default action is to focus the
 29018:         // target. Look for the nearest enclosing focusable frame.
     1:         while (currFrame) {
     1:           // If the mousedown happened inside a popup, don't
     1:           // try to set focus on one of its containing elements
132812:           const nsStyleDisplay* display = currFrame->StyleDisplay();
     1:           if (display->mDisplay == NS_STYLE_DISPLAY_POPUP) {
106838:             newFocus = nullptr;
     1:             break;
     1:           }
     1: 
108991:           int32_t tabIndexUnused;
 80486:           if (currFrame->IsFocusable(&tabIndexUnused, true)) {
     1:             newFocus = currFrame->GetContent();
     1:             nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(newFocus));
     1:             if (domElement)
     1:               break;
     1:           }
     1:           currFrame = currFrame->GetParent();
     1:         }
     1: 
 29018:         nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:         if (fm) {
 29018:           // if something was found to focus, focus it. Otherwise, if the
 29018:           // element that was clicked doesn't have -moz-user-focus: ignore,
 29018:           // clear the existing focus. For -moz-user-focus: ignore, the focus
 29018:           // is just left as is.
 29018:           // Another effect of mouse clicking, handled in nsSelection, is that
 29018:           // it should update the caret position to where the mouse was
 29018:           // clicked. Because the focus is cleared when clicking on a
 29018:           // non-focusable node, the next press of the tab key will cause
 29018:           // focus to be shifted from the caret position instead of the root.
 29018:           if (newFocus && currFrame) {
 29018:             // use the mouse flag and the noscroll flag so that the content
 29018:             // doesn't unexpectedly scroll when clicking an element that is
 29018:             // only hald visible
 29018:             nsCOMPtr<nsIDOMElement> newFocusElement = do_QueryInterface(newFocus);
 29018:             fm->SetFocus(newFocusElement, nsIFocusManager::FLAG_BYMOUSE |
 29018:                                           nsIFocusManager::FLAG_NOSCROLL);
 29018:           }
     1:           else if (!suppressBlur) {
 29018:             // clear the focus within the frame and then set it as the
 29018:             // focused frame
 29018:             EnsureDocument(mPresContext);
 29018:             if (mDocument) {
 41071: #ifdef XP_MACOSX
 41071:               if (!activeContent || !activeContent->IsXUL())
 41071: #endif
 29018:                 fm->ClearFocus(mDocument->GetWindow());
 29018:               fm->SetFocusedWindow(mDocument->GetWindow());
 29018:             }
 29018:           }
     1:         }
     1: 
     1:         // The rest is left button-specific.
166409:         if (mouseEvent->button != WidgetMouseEvent::eLeftButton) {
     1:           break;
166409:         }
     1: 
     1:         if (activeContent) {
     1:           // The nearest enclosing element goes into the
     1:           // :active state.  If we fail the QI to DOMElement,
     1:           // then we know we're only a node, and that we need
     1:           // to obtain our parent element and put it into :active
     1:           // instead.
     1:           nsCOMPtr<nsIDOMElement> elt(do_QueryInterface(activeContent));
     1:           if (!elt) {
     1:             nsIContent* par = activeContent->GetParent();
     1:             if (par)
     1:               activeContent = par;
     1:           }
     1:         }
     1:       }
     1:       else {
     1:         // if we're here, the event handler returned false, so stop
     1:         // any of our own processing of a drag. Workaround for bug 43258.
     1:         StopTrackingDragGesture();
 61173: 
 61173:         // When the event was cancelled, there is currently a chrome document
 61173:         // focused and a mousedown just occurred on a content document, ensure
 61173:         // that the window that was clicked is focused.
 61173:         EnsureDocument(mPresContext);
 61173:         nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 61173:         if (mDocument && fm) {
 61173:           nsCOMPtr<nsIDOMWindow> currentWindow;
 61173:           fm->GetFocusedWindow(getter_AddRefs(currentWindow));
118594:           if (currentWindow && mDocument->GetWindow() &&
118594:               currentWindow != mDocument->GetWindow() &&
 61173:               !nsContentUtils::IsChromeDoc(mDocument)) {
118594:             nsCOMPtr<nsIDOMWindow> currentTop;
118594:             nsCOMPtr<nsIDOMWindow> newTop;
118860:             currentWindow->GetTop(getter_AddRefs(currentTop));
118860:             mDocument->GetWindow()->GetTop(getter_AddRefs(newTop));
 61173:             nsCOMPtr<nsPIDOMWindow> win = do_QueryInterface(currentWindow);
141493:             nsCOMPtr<nsIDocument> currentDoc = win->GetExtantDoc();
118594:             if (nsContentUtils::IsChromeDoc(currentDoc) ||
118594:                 (currentTop && newTop && currentTop != newTop)) {
 61173:               fm->SetFocusedWindow(mDocument->GetWindow());
 61173:             }
 61173:           }
 61173:         }
     1:       }
 56644:       SetActiveManager(this, activeContent);
     1:     }
     1:     break;
202239:   case NS_POINTER_CANCEL: {
202239:     if(WidgetMouseEvent* mouseEvent = aEvent->AsMouseEvent()) {
202239:       GenerateMouseEnterExit(mouseEvent);
202239:     }
202239:     // This break was commented specially
202239:     // break;
202239:   }
186256:   case NS_POINTER_UP: {
186256:     WidgetPointerEvent* pointerEvent = aEvent->AsPointerEvent();
186256:     // After UP/Cancel Touch pointers become invalid so we can remove relevant helper from Table
186256:     // Mouse/Pen pointers are valid all the time (not only between down/up)
186256:     if (pointerEvent->inputSource == nsIDOMMouseEvent::MOZ_SOURCE_TOUCH) {
186256:       mPointersEnterLeaveHelper.Remove(pointerEvent->pointerId);
200078:       GenerateMouseEnterExit(pointerEvent);
200078:     }
186256:     break;
186256:   }
     1:   case NS_MOUSE_BUTTON_UP:
     1:     {
 56644:       ClearGlobalActiveContent(this);
196021:       WidgetMouseEvent* mouseEvent = aEvent->AsMouseEvent();
196021:       if (mouseEvent && mouseEvent->IsReal()) {
     1:         if (!mCurrentTarget) {
 68780:           GetEventTarget();
  8236:         }
101341:         // Make sure to dispatch the click even if there is no frame for
101341:         // the current target element. This is required for Web compatibility.
196021:         ret = CheckForAndDispatchClick(presContext, mouseEvent, aStatus);
 39761:       }
 32435: 
     1:       nsIPresShell *shell = presContext->GetPresShell();
     1:       if (shell) {
 70097:         nsRefPtr<nsFrameSelection> frameSelection = shell->FrameSelection();
220863:         frameSelection->SetDragState(false);
     1:       }
     1:     }
     1:     break;
165307:   case NS_WHEEL_STOP:
165307:     {
165307:       MOZ_ASSERT(aEvent->mFlags.mIsTrusted);
196022:       ScrollbarsForWheel::MayInactivate();
165307:     }
165307:     break;
165169:   case NS_WHEEL_WHEEL:
165307:   case NS_WHEEL_START:
165030:     {
165030:       MOZ_ASSERT(aEvent->mFlags.mIsTrusted);
108059: 
108059:       if (*aStatus == nsEventStatus_eConsumeNoDefault) {
196022:         ScrollbarsForWheel::Inactivate();
108059:         break;
108059:       }
108059: 
166411:       WidgetWheelEvent* wheelEvent = aEvent->AsWheelEvent();
108062:       switch (WheelPrefs::GetInstance()->ComputeActionFor(wheelEvent)) {
108062:         case WheelPrefs::ACTION_SCROLL: {
108059:           // For scrolling of default action, we should honor the mouse wheel
108059:           // transaction.
165307: 
196022:           ScrollbarsForWheel::PrepareToScrollText(this, aTargetFrame, wheelEvent);
165307: 
165307:           if (aEvent->message != NS_WHEEL_WHEEL ||
165307:               (!wheelEvent->deltaX && !wheelEvent->deltaY)) {
165307:             break;
165307:           }
165307: 
108059:           nsIScrollableFrame* scrollTarget =
111054:             ComputeScrollTarget(aTargetFrame, wheelEvent,
111054:                                 COMPUTE_DEFAULT_ACTION_TARGET);
165307: 
196022:           ScrollbarsForWheel::SetActiveScrollTarget(scrollTarget);
165307: 
165707:           nsIFrame* rootScrollFrame = !aTargetFrame ? nullptr :
165707:             aTargetFrame->PresContext()->PresShell()->GetRootScrollFrame();
165707:           nsIScrollableFrame* rootScrollableFrame = nullptr;
165707:           if (rootScrollFrame) {
165707:             rootScrollableFrame = do_QueryFrame(rootScrollFrame);
165707:           }
165707:           if (!scrollTarget || scrollTarget == rootScrollableFrame) {
165306:             wheelEvent->mViewPortIsOverscrolled = true;
165306:           }
108346:           wheelEvent->overflowDeltaX = wheelEvent->deltaX;
108346:           wheelEvent->overflowDeltaY = wheelEvent->deltaY;
108346:           WheelPrefs::GetInstance()->
108346:             CancelApplyingUserPrefsFromOverflowDelta(wheelEvent);
108059:           if (scrollTarget) {
108059:             DoScrollText(scrollTarget, wheelEvent);
108059:           } else {
196023:             WheelTransaction::EndTransaction();
196022:             ScrollbarsForWheel::Inactivate();
108059:           }
108062:           break;
108062:         }
127591:         case WheelPrefs::ACTION_HISTORY: {
127591:           // If this event doesn't cause NS_MOUSE_SCROLL event or the direction
127591:           // is oblique, don't perform history back/forward.
127591:           int32_t intDelta = wheelEvent->GetPreferredIntDelta();
127591:           if (!intDelta) {
108062:             break;
127591:           }
127591:           DoScrollHistory(intDelta);
108062:           break;
127591:         }
127591:         case WheelPrefs::ACTION_ZOOM: {
127591:           // If this event doesn't cause NS_MOUSE_SCROLL event or the direction
127591:           // is oblique, don't perform zoom in/out.
127591:           int32_t intDelta = wheelEvent->GetPreferredIntDelta();
127591:           if (!intDelta) {
127591:             break;
127591:           }
127591:           DoScrollZoom(aTargetFrame, intDelta);
127591:           break;
127591:         }
127591:         case WheelPrefs::ACTION_NONE:
108160:         default:
127591:           // If we don't handle the wheel event, all of the delta values must
127591:           // be overflown delta values.
127591:           wheelEvent->overflowDeltaX = wheelEvent->deltaX;
127591:           wheelEvent->overflowDeltaY = wheelEvent->deltaY;
127591:           WheelPrefs::GetInstance()->
127591:             CancelApplyingUserPrefsFromOverflowDelta(wheelEvent);
108160:           break;
108062:       }
108059:       *aStatus = nsEventStatus_eConsumeNoDefault;
 19319:     }
     1:     break;
     1: 
 31443:   case NS_GESTURENOTIFY_EVENT_START:
 31443:     {
166080:       if (nsEventStatus_eConsumeNoDefault != *aStatus) {
166080:         DecideGestureEvent(aEvent->AsGestureNotifyEvent(), mCurrentTarget);
166080:       }
 31443:     }
 31443:     break;
 31443: 
 18445:   case NS_DRAGDROP_ENTER:
 18445:   case NS_DRAGDROP_OVER:
 18445:     {
220550:       NS_ASSERTION(aEvent->mClass == eDragEventClass, "Expected a drag event");
 18445: 
 18445:       nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
 18445:       if (!dragSession)
 18445:         break;
 18445: 
 34272:       // Reset the flag.
 80486:       dragSession->SetOnlyChromeDrop(false);
 34272:       if (mPresContext) {
 34272:         EnsureDocument(mPresContext);
 34272:       }
 79445:       bool isChromeDoc = nsContentUtils::IsChromeDoc(mDocument);
 34272: 
 18445:       // the initial dataTransfer is the one from the dragstart event that
 18445:       // was set on the dragSession when the drag began.
 89615:       nsCOMPtr<nsIDOMDataTransfer> dataTransfer;
 18445:       nsCOMPtr<nsIDOMDataTransfer> initialDataTransfer;
 18445:       dragSession->GetDataTransfer(getter_AddRefs(initialDataTransfer));
 18445: 
166088:       WidgetDragEvent *dragEvent = aEvent->AsDragEvent();
 33528: 
 33528:       // collect any changes to moz cursor settings stored in the event's
 33528:       // data transfer.
 33528:       UpdateDragDataTransfer(dragEvent);
 33528: 
 18445:       // cancelling a dragenter or dragover event means that a drop should be
 18445:       // allowed, so update the dropEffect and the canDrop state to indicate
 18445:       // that a drag is allowed. If the event isn't cancelled, a drop won't be
 18445:       // allowed. Essentially, to allow a drop somewhere, specify the effects
 18445:       // using the effectAllowed and dropEffect properties in a dragenter or
 18445:       // dragover event and cancel the event. To not allow a drop somewhere,
 18445:       // don't cancel the event or set the effectAllowed or dropEffect to
 18445:       // "none". This way, if the event is just ignored, no drop will be
 18445:       // allowed.
108991:       uint32_t dropEffect = nsIDragService::DRAGDROP_ACTION_NONE;
 18445:       if (nsEventStatus_eConsumeNoDefault == *aStatus) {
 18445:         // if the event has a dataTransfer set, use it.
 18445:         if (dragEvent->dataTransfer) {
 18445:           // get the dataTransfer and the dropEffect that was set on it
 18445:           dataTransfer = do_QueryInterface(dragEvent->dataTransfer);
 18445:           dataTransfer->GetDropEffectInt(&dropEffect);
 18445:         }
 18445:         else {
 18445:           // if dragEvent->dataTransfer is null, it means that no attempt was
 18445:           // made to access the dataTransfer during the event, yet the event
 18445:           // was cancelled. Instead, use the initial data transfer available
 18445:           // from the drag session. The drop effect would not have been
189225:           // initialized (which is done in DragEvent::GetDataTransfer),
 18445:           // so set it from the drag action. We'll still want to filter it
 18445:           // based on the effectAllowed below.
 89615:           dataTransfer = initialDataTransfer;
 18445: 
108991:           uint32_t action;
 18445:           dragSession->GetDragAction(&action);
 18445: 
 18445:           // filter the drop effect based on the action. Use UNINITIALIZED as
 18445:           // any effect is allowed.
 29545:           dropEffect = nsContentUtils::FilterDropEffect(action,
 18445:                          nsIDragService::DRAGDROP_ACTION_UNINITIALIZED);
 18445:         }
 18445: 
 18445:         // At this point, if the dataTransfer is null, it means that the
 18445:         // drag was originally started by directly calling the drag service.
 18445:         // Just assume that all effects are allowed.
108991:         uint32_t effectAllowed = nsIDragService::DRAGDROP_ACTION_UNINITIALIZED;
 18445:         if (dataTransfer)
 18445:           dataTransfer->GetEffectAllowedInt(&effectAllowed);
 18445: 
 18445:         // set the drag action based on the drop effect and effect allowed.
 18445:         // The drop effect field on the drag transfer object specifies the
 18445:         // desired current drop effect. However, it cannot be used if the
 18445:         // effectAllowed state doesn't include that type of action. If the
 18445:         // dropEffect is "none", then the action will be 'none' so a drop will
 18445:         // not be allowed.
108991:         uint32_t action = nsIDragService::DRAGDROP_ACTION_NONE;
 18445:         if (effectAllowed == nsIDragService::DRAGDROP_ACTION_UNINITIALIZED ||
 18445:             dropEffect & effectAllowed)
 18445:           action = dropEffect;
 18445: 
 18445:         if (action == nsIDragService::DRAGDROP_ACTION_NONE)
 18445:           dropEffect = nsIDragService::DRAGDROP_ACTION_NONE;
 18445: 
 18445:         // inform the drag session that a drop is allowed on this node.
 18445:         dragSession->SetDragAction(action);
 18445:         dragSession->SetCanDrop(action != nsIDragService::DRAGDROP_ACTION_NONE);
 34272: 
 34272:         // For now, do this only for dragover.
 34272:         //XXXsmaug dragenter needs some more work.
 34272:         if (aEvent->message == NS_DRAGDROP_OVER && !isChromeDoc) {
177224:           // Someone has called preventDefault(), check whether is was on
177224:           // content or chrome.
 34272:           dragSession->SetOnlyChromeDrop(
177224:             !dragEvent->mDefaultPreventedOnContent);
 34272:         }
 34272:       } else if (aEvent->message == NS_DRAGDROP_OVER && !isChromeDoc) {
 34605:         // No one called preventDefault(), so handle drop only in chrome.
 80486:         dragSession->SetOnlyChromeDrop(true);
 18445:       }
 18445: 
 18445:       // now set the drop effect in the initial dataTransfer. This ensures
 18445:       // that we can get the desired drop effect in the drop event.
 89615:       if (initialDataTransfer)
 89615:         initialDataTransfer->SetDropEffectInt(dropEffect);
 18445:     }
 18445:     break;
 18445: 
     1:   case NS_DRAGDROP_DROP:
 18445:     {
 18445:       // now fire the dragdrop event, for compatibility with XUL
 18445:       if (mCurrentTarget && nsEventStatus_eConsumeNoDefault != *aStatus) {
 18445:         nsCOMPtr<nsIContent> targetContent;
 79435:         mCurrentTarget->GetContentForEvent(aEvent,
 18445:                                            getter_AddRefs(targetContent));
 18445: 
 47148:         nsCOMPtr<nsIWidget> widget = mCurrentTarget->GetNearestWidget();
164204:         WidgetDragEvent event(aEvent->mFlags.mIsTrusted,
126028:                               NS_DRAGDROP_DRAGDROP, widget);
 18445: 
166409:         WidgetMouseEvent* mouseEvent = aEvent->AsMouseEvent();
 18445:         event.refPoint = mouseEvent->refPoint;
 46252:         if (mouseEvent->widget) {
154119:           event.refPoint += LayoutDeviceIntPoint::FromUntyped(mouseEvent->widget->WidgetToScreenOffset());
154119:         }
154119:         event.refPoint -= LayoutDeviceIntPoint::FromUntyped(widget->WidgetToScreenOffset());
 96887:         event.modifiers = mouseEvent->modifiers;
 96888:         event.buttons = mouseEvent->buttons;
 40485:         event.inputSource = mouseEvent->inputSource;
 18445: 
 18445:         nsEventStatus status = nsEventStatus_eIgnore;
 18445:         nsCOMPtr<nsIPresShell> presShell = mPresContext->GetPresShell();
 18445:         if (presShell) {
 18445:           presShell->HandleEventWithTarget(&event, mCurrentTarget,
 18445:                                            targetContent, &status);
 18445:         }
 18445:       }
106838:       sLastDragOverFrame = nullptr;
 56644:       ClearGlobalActiveContent(this);
 18445:       break;
 18445:     }
     1:   case NS_DRAGDROP_EXIT:
 18445:      // make sure to fire the enter and exit_synth events after the
 18445:      // NS_DRAGDROP_EXIT event, otherwise we'll clean up too early
166409:     GenerateDragDropEnterExit(presContext, aEvent->AsDragEvent());
     1:     break;
     1: 
240019:   case NS_KEY_BEFORE_UP:
     1:   case NS_KEY_UP:
240019:   case NS_KEY_AFTER_UP:
     1:     break;
     1: 
     1:   case NS_KEY_PRESS:
     1:     if (nsEventStatus_eConsumeNoDefault != *aStatus) {
166081:       WidgetKeyboardEvent* keyEvent = aEvent->AsKeyboardEvent();
     1:       //This is to prevent keyboard scrolling while alt modifier in use.
 96893:       if (!keyEvent->IsAlt()) {
     1:         switch(keyEvent->keyCode) {
     1:           case NS_VK_TAB:
 29018:           case NS_VK_F6:
153610:             // Handling the tab event after it was sent to content is bad,
153610:             // because to the FocusManager the remote-browser looks like one
153610:             // element, so we would just move the focus to the next element
153610:             // in chrome, instead of handling it in content.
153610:             if (dispatchedToContentProcess)
153610:               break;
153610: 
 29018:             EnsureDocument(mPresContext);
 29018:             nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:             if (fm && mDocument) {
     1:               // Shift focus forward or back depending on shift key
164202:               bool isDocMove =
164202:                 keyEvent->IsControl() || keyEvent->keyCode == NS_VK_F6;
164202:               uint32_t dir = keyEvent->IsShift() ?
108991:                   (isDocMove ? static_cast<uint32_t>(nsIFocusManager::MOVEFOCUS_BACKWARDDOC) :
108991:                                static_cast<uint32_t>(nsIFocusManager::MOVEFOCUS_BACKWARD)) :
108991:                   (isDocMove ? static_cast<uint32_t>(nsIFocusManager::MOVEFOCUS_FORWARDDOC) :
108991:                                static_cast<uint32_t>(nsIFocusManager::MOVEFOCUS_FORWARD));
 29018:               nsCOMPtr<nsIDOMElement> result;
106838:               fm->MoveFocus(mDocument->GetWindow(), nullptr, dir,
 29018:                             nsIFocusManager::FLAG_BYKEY,
 29018:                             getter_AddRefs(result));
 29018:             }
     1:             *aStatus = nsEventStatus_eConsumeNoDefault;
     1:             break;
     1:         }
     1:       }
     1:     }
     1:     break;
     1: 
     1:   case NS_MOUSE_ENTER:
     1:     if (mCurrentTarget) {
     1:       nsCOMPtr<nsIContent> targetContent;
 79435:       mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(targetContent));
     1:       SetContentState(targetContent, NS_EVENT_STATE_HOVER);
     1:     }
     1:     break;
 47793: 
 47793: #ifdef XP_MACOSX
 47793:   case NS_MOUSE_ACTIVATE:
 47793:     if (mCurrentTarget) {
 47793:       nsCOMPtr<nsIContent> targetContent;
 79435:       mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(targetContent));
 47793:       if (!NodeAllowsClickThrough(targetContent)) {
 47793:         *aStatus = nsEventStatus_eConsumeNoDefault;
 47793:       }
 47793:     }
 47793:     break;
 47793: #endif
     1:   }
     1: 
     1:   //Reset target frame to null to avoid mistargeting after reentrant event
106838:   mCurrentTarget = nullptr;
106838:   mCurrentTargetContent = nullptr;
     1: 
     1:   return ret;
     1: }
     1: 
 79445: bool
196025: EventStateManager::RemoteQueryContentEvent(WidgetEvent* aEvent)
 54603: {
166084:   WidgetQueryContentEvent* queryEvent = aEvent->AsQueryContentEvent();
 54603:   if (!IsTargetCrossProcess(queryEvent)) {
 80486:     return false;
 54603:   }
 54603:   // Will not be handled locally, remote the event
 54603:   GetCrossProcessTarget()->HandleQueryContentEvent(*queryEvent);
 80486:   return true;
 54603: }
 54603: 
 54603: TabParent*
196025: EventStateManager::GetCrossProcessTarget()
 50731: {
 54603:   return TabParent::GetIMETabParent();
 50731: }
 50731: 
 79445: bool
196025: EventStateManager::IsTargetCrossProcess(WidgetGUIEvent* aEvent)
 50731: {
 54776:   // Check to see if there is a focused, editable content in chrome,
 54776:   // in that case, do not forward IME events to content
 54776:   nsIContent *focusedContent = GetFocusedContent();
 54776:   if (focusedContent && focusedContent->IsEditable())
 80486:     return false;
106838:   return TabParent::GetIMETabParent() != nullptr;
 54603: }
 50731: 
 68780: void
196025: EventStateManager::NotifyDestroyPresContext(nsPresContext* aPresContext)
     1: {
190851:   IMEStateManager::OnDestroyPresContext(aPresContext);
 98800:   if (mHoverContent) {
 98800:     // Bug 70855: Presentation is going away, possibly for a reframe.
 98800:     // Reset the hover state so that if we're recreating the presentation,
 98800:     // we won't have the old hover state still set in the new presentation,
 98800:     // as if the new presentation is resized, a new element may be hovered. 
106838:     SetContentState(nullptr, NS_EVENT_STATE_HOVER);
 98800:   }
186256:   mPointersEnterLeaveHelper.Clear();
 68780: }
 68780: 
 68780: void
196025: EventStateManager::SetPresContext(nsPresContext* aPresContext)
     1: {
     1:   mPresContext = aPresContext;
 68780: }
 68780: 
 68780: void
196025: EventStateManager::ClearFrameRefs(nsIFrame* aFrame)
     1: {
     1:   if (aFrame && aFrame == mCurrentTarget) {
     1:     mCurrentTargetContent = aFrame->GetContent();
     1:   }
     1: }
     1: 
     1: void
196025: EventStateManager::UpdateCursor(nsPresContext* aPresContext,
164382:                                 WidgetEvent* aEvent,
164382:                                 nsIFrame* aTargetFrame,
     1:                                 nsEventStatus* aStatus)
     1: {
 73592:   if (aTargetFrame && IsRemoteTarget(aTargetFrame->GetContent())) {
 73592:     return;
 73592:   }
 73592: 
108991:   int32_t cursor = NS_STYLE_CURSOR_DEFAULT;
106838:   imgIContainer* container = nullptr;
 79445:   bool haveHotspot = false;
     1:   float hotspotX = 0.0f, hotspotY = 0.0f;
     1: 
     1:   //If cursor is locked just use the locked one
     1:   if (mLockCursor) {
     1:     cursor = mLockCursor;
     1:   }
     1:   //If not locked, look for correct cursor
     1:   else if (aTargetFrame) {
     1:       nsIFrame::Cursor framecursor;
     1:       nsPoint pt = nsLayoutUtils::GetEventCoordinatesRelativeTo(aEvent,
     1:                                                                 aTargetFrame);
     1:       if (NS_FAILED(aTargetFrame->GetCursor(pt, framecursor)))
     1:         return;  // don't update the cursor if we failed to get it from the frame see bug 118877
     1:       cursor = framecursor.mCursor;
     1:       container = framecursor.mContainer;
     1:       haveHotspot = framecursor.mHaveHotspot;
     1:       hotspotX = framecursor.mHotspotX;
     1:       hotspotY = framecursor.mHotspotY;
     1:   }
     1: 
 79445:   if (Preferences::GetBool("ui.use_activity_cursor", false)) {
 32813:     // Check whether or not to show the busy cursor
177265:     nsCOMPtr<nsIDocShell> docShell(aPresContext->GetDocShell());
 32813:     if (!docShell) return;
108991:     uint32_t busyFlags = nsIDocShell::BUSY_FLAGS_NONE;
 32813:     docShell->GetBusyFlags(&busyFlags);
 32813: 
 32813:     // Show busy cursor everywhere before page loads
 32813:     // and just replace the arrow cursor after page starts loading
 32813:     if (busyFlags & nsIDocShell::BUSY_FLAGS_BUSY &&
 32813:           (cursor == NS_STYLE_CURSOR_AUTO || cursor == NS_STYLE_CURSOR_DEFAULT))
 32813:     {
 32813:       cursor = NS_STYLE_CURSOR_SPINNING;
106838:       container = nullptr;
 32813:     }
 32813:   }
 32813: 
     1:   if (aTargetFrame) {
     1:     SetCursor(cursor, container, haveHotspot, hotspotX, hotspotY,
 80486:               aTargetFrame->GetNearestWidget(), false);
     1:   }
     1: 
     1:   if (mLockCursor || NS_STYLE_CURSOR_AUTO != cursor) {
     1:     *aStatus = nsEventStatus_eConsumeDoDefault;
     1:   }
     1: }
     1: 
205509: void
205509: EventStateManager::ClearCachedWidgetCursor(nsIFrame* aTargetFrame)
205509: {
205509:   if (!aTargetFrame) {
205509:     return;
205509:   }
205509:   nsIWidget* aWidget = aTargetFrame->GetNearestWidget();
205509:   if (!aWidget) {
205509:     return;
205509:   }
205509:   aWidget->ClearCachedCursor();
205509: }
205509: 
 68780: nsresult
196025: EventStateManager::SetCursor(int32_t aCursor, imgIContainer* aContainer,
 79445:                              bool aHaveHotspot,
     1:                              float aHotspotX, float aHotspotY,
 79445:                              nsIWidget* aWidget, bool aLockCursor)
     1: {
 54257:   EnsureDocument(mPresContext);
 54257:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
 54257:   sMouseOverDocument = mDocument.get();
 54257: 
     1:   nsCursor c;
     1: 
     1:   NS_ENSURE_TRUE(aWidget, NS_ERROR_FAILURE);
     1:   if (aLockCursor) {
     1:     if (NS_STYLE_CURSOR_AUTO != aCursor) {
     1:       mLockCursor = aCursor;
     1:     }
     1:     else {
     1:       //If cursor style is set to auto we unlock the cursor again.
     1:       mLockCursor = 0;
     1:     }
     1:   }
     1:   switch (aCursor) {
     1:   default:
     1:   case NS_STYLE_CURSOR_AUTO:
     1:   case NS_STYLE_CURSOR_DEFAULT:
     1:     c = eCursor_standard;
     1:     break;
     1:   case NS_STYLE_CURSOR_POINTER:
     1:     c = eCursor_hyperlink;
     1:     break;
     1:   case NS_STYLE_CURSOR_CROSSHAIR:
     1:     c = eCursor_crosshair;
     1:     break;
     1:   case NS_STYLE_CURSOR_MOVE:
     1:     c = eCursor_move;
     1:     break;
     1:   case NS_STYLE_CURSOR_TEXT:
     1:     c = eCursor_select;
     1:     break;
     1:   case NS_STYLE_CURSOR_WAIT:
     1:     c = eCursor_wait;
     1:     break;
     1:   case NS_STYLE_CURSOR_HELP:
     1:     c = eCursor_help;
     1:     break;
     1:   case NS_STYLE_CURSOR_N_RESIZE:
     1:     c = eCursor_n_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_S_RESIZE:
     1:     c = eCursor_s_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_W_RESIZE:
     1:     c = eCursor_w_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_E_RESIZE:
     1:     c = eCursor_e_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_NW_RESIZE:
     1:     c = eCursor_nw_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_SE_RESIZE:
     1:     c = eCursor_se_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_NE_RESIZE:
     1:     c = eCursor_ne_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_SW_RESIZE:
     1:     c = eCursor_sw_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_COPY: // CSS3
     1:     c = eCursor_copy;
     1:     break;
     1:   case NS_STYLE_CURSOR_ALIAS:
     1:     c = eCursor_alias;
     1:     break;
     1:   case NS_STYLE_CURSOR_CONTEXT_MENU:
     1:     c = eCursor_context_menu;
     1:     break;
     1:   case NS_STYLE_CURSOR_CELL:
     1:     c = eCursor_cell;
     1:     break;
     1:   case NS_STYLE_CURSOR_GRAB:
     1:     c = eCursor_grab;
     1:     break;
     1:   case NS_STYLE_CURSOR_GRABBING:
     1:     c = eCursor_grabbing;
     1:     break;
     1:   case NS_STYLE_CURSOR_SPINNING:
     1:     c = eCursor_spinning;
     1:     break;
146139:   case NS_STYLE_CURSOR_ZOOM_IN:
     1:     c = eCursor_zoom_in;
     1:     break;
146139:   case NS_STYLE_CURSOR_ZOOM_OUT:
     1:     c = eCursor_zoom_out;
     1:     break;
     1:   case NS_STYLE_CURSOR_NOT_ALLOWED:
     1:     c = eCursor_not_allowed;
     1:     break;
     1:   case NS_STYLE_CURSOR_COL_RESIZE:
     1:     c = eCursor_col_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_ROW_RESIZE:
     1:     c = eCursor_row_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_NO_DROP:
     1:     c = eCursor_no_drop;
     1:     break;
     1:   case NS_STYLE_CURSOR_VERTICAL_TEXT:
     1:     c = eCursor_vertical_text;
     1:     break;
     1:   case NS_STYLE_CURSOR_ALL_SCROLL:
     1:     c = eCursor_all_scroll;
     1:     break;
     1:   case NS_STYLE_CURSOR_NESW_RESIZE:
     1:     c = eCursor_nesw_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_NWSE_RESIZE:
     1:     c = eCursor_nwse_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_NS_RESIZE:
     1:     c = eCursor_ns_resize;
     1:     break;
     1:   case NS_STYLE_CURSOR_EW_RESIZE:
     1:     c = eCursor_ew_resize;
     1:     break;
 10405:   case NS_STYLE_CURSOR_NONE:
 10405:     c = eCursor_none;
 10405:     break;
     1:   }
     1: 
     1:   // First, try the imgIContainer, if non-null
     1:   nsresult rv = NS_ERROR_FAILURE;
     1:   if (aContainer) {
108991:     uint32_t hotspotX, hotspotY;
     1: 
     1:     // css3-ui says to use the CSS-specified hotspot if present,
     1:     // otherwise use the intrinsic hotspot, otherwise use the top left
     1:     // corner.
     1:     if (aHaveHotspot) {
108991:       int32_t imgWidth, imgHeight;
     1:       aContainer->GetWidth(&imgWidth);
     1:       aContainer->GetHeight(&imgHeight);
     1: 
129543:       // XXX std::max(NS_lround(x), 0)?
     1:       hotspotX = aHotspotX > 0.0f
108991:                    ? uint32_t(aHotspotX + 0.5f) : uint32_t(0);
108991:       if (hotspotX >= uint32_t(imgWidth))
     1:         hotspotX = imgWidth - 1;
     1:       hotspotY = aHotspotY > 0.0f
108991:                    ? uint32_t(aHotspotY + 0.5f) : uint32_t(0);
108991:       if (hotspotY >= uint32_t(imgHeight))
     1:         hotspotY = imgHeight - 1;
     1:     } else {
     1:       hotspotX = 0;
     1:       hotspotY = 0;
     1:       nsCOMPtr<nsIProperties> props(do_QueryInterface(aContainer));
     1:       if (props) {
     1:         nsCOMPtr<nsISupportsPRUint32> hotspotXWrap, hotspotYWrap;
     1: 
     1:         props->Get("hotspotX", NS_GET_IID(nsISupportsPRUint32), getter_AddRefs(hotspotXWrap));
     1:         props->Get("hotspotY", NS_GET_IID(nsISupportsPRUint32), getter_AddRefs(hotspotYWrap));
     1: 
     1:         if (hotspotXWrap)
     1:           hotspotXWrap->GetData(&hotspotX);
     1:         if (hotspotYWrap)
     1:           hotspotYWrap->GetData(&hotspotY);
     1:       }
     1:     }
     1: 
     1:     rv = aWidget->SetCursor(aContainer, hotspotX, hotspotY);
     1:   }
     1: 
     1:   if (NS_FAILED(rv))
     1:     aWidget->SetCursor(c);
     1: 
     1:   return NS_OK;
     1: }
     1: 
196025: class MOZ_STACK_CLASS ESMEventCB : public EventDispatchingCallback
     1: {
     1: public:
227620:   explicit ESMEventCB(nsIContent* aTarget) : mTarget(aTarget) {}
     1: 
193670:   virtual void HandleEvent(EventChainPostVisitor& aVisitor)
     1:   {
     1:     if (aVisitor.mPresContext) {
 36655:       nsIFrame* frame = aVisitor.mPresContext->GetPrimaryFrameFor(mTarget);
     1:       if (frame) {
     1:         frame->HandleEvent(aVisitor.mPresContext,
166410:                            aVisitor.mEvent->AsGUIEvent(),
     1:                            &aVisitor.mEventStatus);
     1:       }
     1:     }
     1:   }
     1: 
     1:   nsCOMPtr<nsIContent> mTarget;
     1: };
     1: 
131234: /*static*/ bool
196025: EventStateManager::IsHandlingUserInput()
131234: {
131234:   if (sUserInputEventDepth <= 0) {
131234:     return false;
131234:   }
131234: 
131234:   TimeDuration timeout = nsContentUtils::HandlingUserInputTimeout();
131234:   return timeout <= TimeDuration(0) ||
131234:          (TimeStamp::Now() - sHandlingInputStart) <= timeout;
131234: }
131234: 
205508: static void
205508: CreateMouseOrPointerWidgetEvent(WidgetMouseEvent* aMouseEvent,
205508:                                 uint32_t aMessage,
205508:                                 nsIContent* aRelatedContent,
205508:                                 nsAutoPtr<WidgetMouseEvent>& aNewEvent)
205508: {
205508:   WidgetPointerEvent* sourcePointer = aMouseEvent->AsPointerEvent();
205508:   if (sourcePointer) {
206323:     PROFILER_LABEL("Input", "DispatchPointerEvent",
206323:       js::ProfileEntry::Category::EVENTS);
206323: 
205508:     nsAutoPtr<WidgetPointerEvent> newPointerEvent;
205508:     newPointerEvent =
205508:       new WidgetPointerEvent(aMouseEvent->mFlags.mIsTrusted, aMessage,
205508:                              aMouseEvent->widget);
205508:     newPointerEvent->isPrimary = sourcePointer->isPrimary;
205508:     newPointerEvent->pointerId = sourcePointer->pointerId;
205508:     newPointerEvent->width = sourcePointer->width;
205508:     newPointerEvent->height = sourcePointer->height;
205508:     newPointerEvent->inputSource = sourcePointer->inputSource;
205508:     newPointerEvent->relatedTarget =
205508:       nsIPresShell::GetPointerCapturingContent(sourcePointer->pointerId)
205508:         ? nullptr
205508:         : aRelatedContent;
205508:     aNewEvent = newPointerEvent.forget();
205508:   } else {
205508:     aNewEvent =
205508:       new WidgetMouseEvent(aMouseEvent->mFlags.mIsTrusted, aMessage,
205508:                            aMouseEvent->widget, WidgetMouseEvent::eReal);
205508:     aNewEvent->relatedTarget = aRelatedContent;
205508:   }
205508:   aNewEvent->refPoint = aMouseEvent->refPoint;
205508:   aNewEvent->modifiers = aMouseEvent->modifiers;
205508:   aNewEvent->button = aMouseEvent->button;
205508:   aNewEvent->buttons = aMouseEvent->buttons;
205508:   aNewEvent->pressure = aMouseEvent->pressure;
218931:   aNewEvent->mPluginEvent = aMouseEvent->mPluginEvent;
205508:   aNewEvent->inputSource = aMouseEvent->inputSource;
205508: }
205508: 
     1: nsIFrame*
196025: EventStateManager::DispatchMouseOrPointerEvent(WidgetMouseEvent* aMouseEvent,
164381:                                                uint32_t aMessage,
     1:                                                nsIContent* aTargetContent,
     1:                                                nsIContent* aRelatedContent)
     1: {
 95203:   // http://dvcs.w3.org/hg/webevents/raw-file/default/mouse-lock.html#methods
 95203:   // "[When the mouse is locked on an element...e]vents that require the concept
 95203:   // of a mouse cursor must not be dispatched (for example: mouseover, mouseout).
 95203:   if (sIsPointerLocked &&
 95203:       (aMessage == NS_MOUSELEAVE ||
 95203:        aMessage == NS_MOUSEENTER ||
 95203:        aMessage == NS_MOUSE_ENTER_SYNTH ||
 95203:        aMessage == NS_MOUSE_EXIT_SYNTH)) {
106838:     mCurrentTargetContent = nullptr;
 95203:     nsCOMPtr<Element> pointerLockedElement =
196025:       do_QueryReferent(EventStateManager::sPointerLockedElement);
 95203:     if (!pointerLockedElement) {
 95203:       NS_WARNING("Should have pointer locked element, but didn't.");
106838:       return nullptr;
 95203:     }
 95203:     nsCOMPtr<nsIContent> content = do_QueryInterface(pointerLockedElement);
 95203:     return mPresContext->GetPrimaryFrameFor(content);
 95203:   }
 95203: 
205508:   mCurrentTargetContent = nullptr;
205508: 
205508:   if (!aTargetContent) {
205508:     return nullptr;
205508:   }
205508: 
205508:   nsAutoPtr<WidgetMouseEvent> dispatchEvent;
205508:   CreateMouseOrPointerWidgetEvent(aMouseEvent, aMessage,
205508:                                   aRelatedContent, dispatchEvent);
205508: 
205508:   nsWeakFrame previousTarget = mCurrentTarget;
205508:   mCurrentTargetContent = aTargetContent;
205508: 
205508:   nsIFrame* targetFrame = nullptr;
205508: 
205508:   if (aMouseEvent->AsMouseEvent()) {
206323:     PROFILER_LABEL("Input", "DispatchMouseEvent",
206323:       js::ProfileEntry::Category::EVENTS);
205508:   }
205508: 
186256:   nsEventStatus status = nsEventStatus_eIgnore;
196025:   ESMEventCB callback(aTargetContent);
205508:   EventDispatcher::Dispatch(aTargetContent, mPresContext, dispatchEvent, nullptr,
     1:                             &status, &callback);
     1: 
 36655:   if (mPresContext) {
205508:     // Although the primary frame was checked in event callback, it may not be
205508:     // the same object after event dispatch and handling, so refetch it.
 36655:     targetFrame = mPresContext->GetPrimaryFrameFor(aTargetContent);
205508: 
205508:     // If we are leaving remote content, dispatch a mouse exit event to the
205508:     // remote frame.
205508:     if (aMessage == NS_MOUSE_EXIT_SYNTH && IsRemoteTarget(aTargetContent)) {
205508:       // For remote content, send a normal widget mouse exit event.
205508:       nsAutoPtr<WidgetMouseEvent> remoteEvent;
205508:       CreateMouseOrPointerWidgetEvent(aMouseEvent, NS_MOUSE_EXIT,
205508:                                       aRelatedContent, remoteEvent);
205508: 
205508:       // mCurrentTarget is set to the new target, so we must reset it to the
205508:       // old target and then dispatch a cross-process event. (mCurrentTarget
205508:       // will be set back below.) HandleCrossProcessEvent will query for the
205508:       // proper target via GetEventTarget which will return mCurrentTarget.
205508:       mCurrentTarget = targetFrame;
205508:       HandleCrossProcessEvent(remoteEvent, &status);
     1:     }
     1:   }
     1: 
106838:   mCurrentTargetContent = nullptr;
 51626:   mCurrentTarget = previousTarget;
     1: 
     1:   return targetFrame;
     1: }
     1: 
186256: class EnterLeaveDispatcher
 78422: {
 78422: public:
196025:   EnterLeaveDispatcher(EventStateManager* aESM,
 78422:                        nsIContent* aTarget, nsIContent* aRelatedTarget,
166409:                        WidgetMouseEvent* aMouseEvent, uint32_t aType)
196025:     : mESM(aESM)
196025:     , mMouseEvent(aMouseEvent)
196025:     , mType(aType)
 78422:   {
 78422:     nsPIDOMWindow* win =
106838:       aTarget ? aTarget->OwnerDoc()->GetInnerWindow() : nullptr;
186256:     if (aMouseEvent->AsPointerEvent() ? win && win->HasPointerEnterLeaveEventListeners() :
186256:                                         win && win->HasMouseEnterLeaveEventListeners()) {
 78422:       mRelatedTarget = aRelatedTarget ?
118445:         aRelatedTarget->FindFirstNonChromeOnlyAccessContent() : nullptr;
106838:       nsINode* commonParent = nullptr;
 78422:       if (aTarget && aRelatedTarget) {
 78422:         commonParent =
 78422:           nsContentUtils::GetCommonAncestor(aTarget, aRelatedTarget);
 78422:       }
 78422:       nsIContent* current = aTarget;
 78422:       // Note, it is ok if commonParent is null!
 78422:       while (current && current != commonParent) {
118445:         if (!current->ChromeOnlyAccess()) {
 78422:           mTargets.AppendObject(current);
 78422:         }
 78422:         // mouseenter/leave is fired only on elements.
 78422:         current = current->GetParent();
 78422:       }
 78422:     }
 78422:   }
 78422: 
186256:   ~EnterLeaveDispatcher()
186256:   {
186256:     if (mType == NS_MOUSEENTER ||
186256:         mType == NS_POINTER_ENTER) {
108991:       for (int32_t i = mTargets.Count() - 1; i >= 0; --i) {
186256:         mESM->DispatchMouseOrPointerEvent(mMouseEvent, mType, mTargets[i],
166409:                                           mRelatedTarget);
102778:       }
102778:     } else {
108991:       for (int32_t i = 0; i < mTargets.Count(); ++i) {
186256:         mESM->DispatchMouseOrPointerEvent(mMouseEvent, mType, mTargets[i],
166409:                                           mRelatedTarget);
 78422:       }
 78422:     }
102778:   }
 78422: 
196025:   EventStateManager* mESM;
 78422:   nsCOMArray<nsIContent> mTargets;
 78422:   nsCOMPtr<nsIContent> mRelatedTarget;
166409:   WidgetMouseEvent* mMouseEvent;
108991:   uint32_t mType;
 78422: };
 78422: 
     1: void
196025: EventStateManager::NotifyMouseOut(WidgetMouseEvent* aMouseEvent,
164381:                                   nsIContent* aMovingInto)
     1: {
186255:   OverOutElementsWrapper* wrapper = GetWrapperByEventID(aMouseEvent);
186255: 
186255:   if (!wrapper->mLastOverElement)
     1:     return;
     1:   // Before firing mouseout, check for recursion
186255:   if (wrapper->mLastOverElement == wrapper->mFirstOutEventElement)
     1:     return;
     1: 
186255:   if (wrapper->mLastOverFrame) {
     1:     // if the frame is associated with a subdocument,
     1:     // tell the subdocument that we're moving out of it
186255:     nsSubDocumentFrame* subdocFrame = do_QueryFrame(wrapper->mLastOverFrame.GetFrame());
     1:     if (subdocFrame) {
     1:       nsCOMPtr<nsIDocShell> docshell;
     1:       subdocFrame->GetDocShell(getter_AddRefs(docshell));
     1:       if (docshell) {
 39823:         nsRefPtr<nsPresContext> presContext;
     1:         docshell->GetPresContext(getter_AddRefs(presContext));
     1: 
     1:         if (presContext) {
196025:           EventStateManager* kidESM = presContext->EventStateManager();
     1:           // Not moving into any element in this subdocument
166409:           kidESM->NotifyMouseOut(aMouseEvent, nullptr);
     1:         }
     1:       }
     1:     }
     1:   }
     1:   // That could have caused DOM events which could wreak havoc. Reverify
     1:   // things and be careful.
186255:   if (!wrapper->mLastOverElement)
     1:     return;
     1: 
     1:   // Store the first mouseOut event we fire and don't refire mouseOut
     1:   // to that element while the first mouseOut is still ongoing.
186255:   wrapper->mFirstOutEventElement = wrapper->mLastOverElement;
     1: 
     1:   // Don't touch hover state if aMovingInto is non-null.  Caller will update
     1:   // hover state itself, and we have optimizations for hover switching between
     1:   // two nearby elements both deep in the DOM tree that would be defeated by
     1:   // switching the hover state to null here.
220553:   bool isPointer = aMouseEvent->mClass == ePointerEventClass;
186256:   if (!aMovingInto && !isPointer) {
     1:     // Unset :hover
106838:     SetContentState(nullptr, NS_EVENT_STATE_HOVER);
     1:   }
     1: 
186256:   EnterLeaveDispatcher leaveDispatcher(this, wrapper->mLastOverElement,
186256:                                        aMovingInto, aMouseEvent,
186256:                                        isPointer ? NS_POINTER_LEAVE :
186256:                                                    NS_MOUSELEAVE);
 78422: 
     1:   // Fire mouseout
186256:   DispatchMouseOrPointerEvent(aMouseEvent, isPointer ? NS_POINTER_OUT : NS_MOUSE_EXIT_SYNTH,
186255:                               wrapper->mLastOverElement, aMovingInto);
186255: 
186255:   wrapper->mLastOverFrame = nullptr;
186255:   wrapper->mLastOverElement = nullptr;
     1: 
     1:   // Turn recursion protection back off
186255:   wrapper->mFirstOutEventElement = nullptr;
     1: }
     1: 
     1: void
196025: EventStateManager::NotifyMouseOver(WidgetMouseEvent* aMouseEvent,
164381:                                    nsIContent* aContent)
     1: {
     1:   NS_ASSERTION(aContent, "Mouse must be over something");
     1: 
215306:   // If pointer capture is set, we should suppress pointerover/pointerenter events
215306:   // for all elements except element which have pointer capture.
215306:   bool dispatch = !aMouseEvent->retargetedByPointerCapture;
215306: 
186255:   OverOutElementsWrapper* wrapper = GetWrapperByEventID(aMouseEvent);
186255: 
215306:   if (wrapper->mLastOverElement == aContent && dispatch)
     1:     return;
     1: 
     1:   // Before firing mouseover, check for recursion
186255:   if (aContent == wrapper->mFirstOverEventElement)
     1:     return;
     1: 
     1:   // Check to see if we're a subdocument and if so update the parent
     1:   // document's ESM state to indicate that the mouse is over the
     1:   // content associated with our subdocument.
     1:   EnsureDocument(mPresContext);
215306:   if (nsIDocument *parentDoc = mDocument->GetParentDocument()) {
215306:     if (nsIContent *docContent = parentDoc->FindContentForSubDocument(mDocument)) {
215306:       if (nsIPresShell *parentShell = parentDoc->GetShell()) {
196025:         EventStateManager* parentESM =
196025:           parentShell->GetPresContext()->EventStateManager();
166409:         parentESM->NotifyMouseOver(aMouseEvent, docContent);
     1:       }
     1:     }
     1:   }
     1:   // Firing the DOM event in the parent document could cause all kinds
     1:   // of havoc.  Reverify and take care.
215306:   if (wrapper->mLastOverElement == aContent && dispatch)
     1:     return;
     1: 
186255:   // Remember mLastOverElement as the related content for the
186256:   // DispatchMouseOrPointerEvent() call below, since NotifyMouseOut() resets it, bug 298477.
186255:   nsCOMPtr<nsIContent> lastOverElement = wrapper->mLastOverElement;
186255: 
220553:   bool isPointer = aMouseEvent->mClass == ePointerEventClass;
215306:   
215306:   Maybe<EnterLeaveDispatcher> enterDispatcher;
215306:   if (dispatch) {
222291:     enterDispatcher.emplace(this, aContent, lastOverElement, aMouseEvent,
215306:                             isPointer ? NS_POINTER_ENTER : NS_MOUSEENTER);
215306:   }
166409: 
166409:   NotifyMouseOut(aMouseEvent, aContent);
     1: 
     1:   // Store the first mouseOver event we fire and don't refire mouseOver
     1:   // to that element while the first mouseOver is still ongoing.
186255:   wrapper->mFirstOverEventElement = aContent;
     1: 
186256:   if (!isPointer) {
     1:     SetContentState(aContent, NS_EVENT_STATE_HOVER);
186256:   }
     1: 
215306:   if (dispatch) {
     1:     // Fire mouseover
186256:     wrapper->mLastOverFrame = 
186256:       DispatchMouseOrPointerEvent(aMouseEvent,
215306:                                   isPointer ? NS_POINTER_OVER : NS_MOUSE_ENTER_SYNTH,
186255:                                   aContent, lastOverElement);
186255:     wrapper->mLastOverElement = aContent;
215306:   } else {
215306:     wrapper->mLastOverFrame = nullptr;
215306:     wrapper->mLastOverElement = nullptr;
215306:   }
     1: 
     1:   // Turn recursion protection back off
186255:   wrapper->mFirstOverEventElement = nullptr;
     1: }
     1: 
102504: // Returns the center point of the window's inner content area.
102504: // This is in widget coordinates, i.e. relative to the widget's top
114823: // left corner, not in screen coordinates, the same units that
189485: // UIEvent::refPoint is in.
135203: //
135203: // XXX Hack alert: XXX
135203: // However, we do the computation in integer CSS pixels, NOT device pix,
135203: // in order to fudge around the one-pixel error in innerHeight in fullscreen
135203: // mode (see bug 799523 comment 35, and bug 729011). Using integer CSS pix
135203: // makes us throw away the fractional error that results, rather than having
135203: // it manifest as a potential one-device-pix discrepancy.
154119: static LayoutDeviceIntPoint
102504: GetWindowInnerRectCenter(nsPIDOMWindow* aWindow,
102504:                          nsIWidget* aWidget,
102504:                          nsPresContext* aContext)
102504: {
154119:   NS_ENSURE_TRUE(aWindow && aWidget && aContext, LayoutDeviceIntPoint(0, 0));
102504: 
102504:   float cssInnerX = 0.0;
102504:   aWindow->GetMozInnerScreenX(&cssInnerX);
135203:   int32_t innerX = int32_t(NS_round(cssInnerX));
102504: 
102504:   float cssInnerY = 0.0;
102504:   aWindow->GetMozInnerScreenY(&cssInnerY);
135203:   int32_t innerY = int32_t(NS_round(cssInnerY));
108991:  
108991:   int32_t innerWidth = 0;
102504:   aWindow->GetInnerWidth(&innerWidth);
102504: 
108991:   int32_t innerHeight = 0;
102504:   aWindow->GetInnerHeight(&innerHeight);
102504: 
102504:   nsIntRect screen;
102504:   aWidget->GetScreenBounds(screen);
102504: 
135203:   int32_t cssScreenX = aContext->DevPixelsToIntCSSPixels(screen.x);
135203:   int32_t cssScreenY = aContext->DevPixelsToIntCSSPixels(screen.y);
135203: 
154119:   return LayoutDeviceIntPoint(
135203:     aContext->CSSPixelsToDevPixels(innerX - cssScreenX + innerWidth / 2),
135203:     aContext->CSSPixelsToDevPixels(innerY - cssScreenY + innerHeight / 2));
102504: }
102504: 
     1: void
211244: EventStateManager::GeneratePointerEnterExit(uint32_t aMessage, WidgetMouseEvent* aEvent)
211244: {
211244:   WidgetPointerEvent pointerEvent(*aEvent);
211244:   pointerEvent.message = aMessage;
211244:   GenerateMouseEnterExit(&pointerEvent);
211244: }
211244: 
211244: void
196025: EventStateManager::GenerateMouseEnterExit(WidgetMouseEvent* aMouseEvent)
     1: {
     1:   EnsureDocument(mPresContext);
     1:   if (!mDocument)
     1:     return;
     1: 
     1:   // Hold onto old target content through the event and reset after.
     1:   nsCOMPtr<nsIContent> targetBeforeEvent = mCurrentTargetContent;
     1: 
166409:   switch(aMouseEvent->message) {
     1:   case NS_MOUSE_MOVE:
     1:     {
114825:       // Mouse movement is reported on the MouseEvent.movement{X,Y} fields.
189485:       // Movement is calculated in UIEvent::GetMovementPoint() as:
114825:       //   previous_mousemove_refPoint - current_mousemove_refPoint.
166409:       if (sIsPointerLocked && aMouseEvent->widget) {
114825:         // The pointer is locked. If the pointer is not located at the center of
114825:         // the window, dispatch a synthetic mousemove to return the pointer there.
114825:         // Doing this between "real" pointer moves gives the impression that the
114825:         // (locked) pointer can continue moving and won't stop at the screen
114825:         // boundary. We cancel the synthetic event so that we don't end up
114825:         // dispatching the centering move event to content.
154119:         LayoutDeviceIntPoint center =
166409:           GetWindowInnerRectCenter(mDocument->GetWindow(), aMouseEvent->widget,
102504:                                    mPresContext);
166409:         aMouseEvent->lastRefPoint = center;
166409:         if (aMouseEvent->refPoint != center) {
114825:           // Mouse move doesn't finish at the center of the window. Dispatch a
114825:           // synthetic native mouse event to move the pointer back to the center
114825:           // of the window, to faciliate more movement. But first, record that
114825:           // we've dispatched a synthetic mouse movement, so we can cancel it
114825:           // in the other branch here.
114825:           sSynthCenteringPoint = center;
166409:           aMouseEvent->widget->SynthesizeNativeMouseMove(
166409:             LayoutDeviceIntPoint::ToUntyped(center) +
166409:               aMouseEvent->widget->WidgetToScreenOffset());
166409:         } else if (aMouseEvent->refPoint == sSynthCenteringPoint) {
114825:           // This is the "synthetic native" event we dispatched to re-center the
114825:           // pointer. Cancel it so we don't expose the centering move to content.
166409:           aMouseEvent->mFlags.mPropagationStopped = true;
114825:           // Clear sSynthCenteringPoint so we don't cancel other events
114825:           // targeted at the center.
115570:           sSynthCenteringPoint = kInvalidRefPoint;
115570:         }
115570:       } else if (sLastRefPoint == kInvalidRefPoint) {
115570:         // We don't have a valid previous mousemove refPoint. This is either
115570:         // the first move we've encountered, or the mouse has just re-entered
115570:         // the application window. We should report (0,0) movement for this
115570:         // case, so make the current and previous refPoints the same.
166409:         aMouseEvent->lastRefPoint = aMouseEvent->refPoint;
 95203:       } else {
166409:         aMouseEvent->lastRefPoint = sLastRefPoint;
 95203:       }
 95203: 
 95203:       // Update the last known refPoint with the current refPoint.
166409:       sLastRefPoint = aMouseEvent->refPoint;
 95203: 
186256:     }
186256:   case NS_POINTER_MOVE:
188078:   case NS_POINTER_DOWN:
186256:     {
     1:       // Get the target content target (mousemove target == mouseover target)
166409:       nsCOMPtr<nsIContent> targetElement = GetEventTargetContent(aMouseEvent);
     1:       if (!targetElement) {
     1:         // We're always over the document root, even if we're only
     1:         // over dead space in a page (whose frame is not associated with
     1:         // any content) or in print preview dead space
 41634:         targetElement = mDocument->GetRootElement();
     1:       }
     1:       if (targetElement) {
166409:         NotifyMouseOver(aMouseEvent, targetElement);
     1:       }
     1:     }
     1:     break;
200078:   case NS_POINTER_UP:
200078:     {
200078:       // Get the target content target (mousemove target == mouseover target)
200078:       nsCOMPtr<nsIContent> targetElement = GetEventTargetContent(aMouseEvent);
200078:       if (!targetElement) {
200078:         // We're always over the document root, even if we're only
200078:         // over dead space in a page (whose frame is not associated with
200078:         // any content) or in print preview dead space
200078:         targetElement = mDocument->GetRootElement();
200078:       }
200078:       if (targetElement) {
200078:         OverOutElementsWrapper* helper = GetWrapperByEventID(aMouseEvent);
200078:         if (helper) {
200078:           helper->mLastOverElement = targetElement;
200078:         }
200078:         NotifyMouseOut(aMouseEvent, nullptr);
200078:       }
200078:     }
200078:     break;
186256:   case NS_POINTER_LEAVE:
189059:   case NS_POINTER_CANCEL:
     1:   case NS_MOUSE_EXIT:
     1:     {
186256:       // This is actually the window mouse exit or pointer leave event. We're not moving
     1:       // into any new element.
  8562: 
186255:       OverOutElementsWrapper* helper = GetWrapperByEventID(aMouseEvent);
186255:       if (helper->mLastOverFrame &&
166409:           nsContentUtils::GetTopLevelWidget(aMouseEvent->widget) !=
186255:           nsContentUtils::GetTopLevelWidget(helper->mLastOverFrame->GetNearestWidget())) {
186256:         // the Mouse/PointerOut event widget doesn't have same top widget with
186256:         // mLastOverFrame, it's a spurious event for mLastOverFrame
  8562:         break;
  8562:       }
  8562: 
115570:       // Reset sLastRefPoint, so that we'll know not to report any
115570:       // movement the next time we re-enter the window.
115570:       sLastRefPoint = kInvalidRefPoint;
115570: 
166409:       NotifyMouseOut(aMouseEvent, nullptr);
     1:     }
     1:     break;
     1:   }
     1: 
     1:   // reset mCurretTargetContent to what it was
     1:   mCurrentTargetContent = targetBeforeEvent;
     1: }
     1: 
186255: OverOutElementsWrapper*
196025: EventStateManager::GetWrapperByEventID(WidgetMouseEvent* aEvent)
186255: {
186256:   WidgetPointerEvent* pointer = aEvent->AsPointerEvent();
186256:   if (!pointer) {
186256:     MOZ_ASSERT(aEvent->AsMouseEvent() != nullptr);
186255:     if (!mMouseEnterLeaveHelper) {
186255:       mMouseEnterLeaveHelper = new OverOutElementsWrapper();
186255:     }
186256:     return mMouseEnterLeaveHelper;
186256:   }
186256:   nsRefPtr<OverOutElementsWrapper> helper;
186256:   if (!mPointersEnterLeaveHelper.Get(pointer->pointerId, getter_AddRefs(helper))) {
186256:     helper = new OverOutElementsWrapper();
186256:     mPointersEnterLeaveHelper.Put(pointer->pointerId, helper);
186256:   }
186256: 
186256:   return helper;
186255: }
186255: 
     1: void
196025: EventStateManager::SetPointerLock(nsIWidget* aWidget,
 95203:                                   nsIContent* aElement)
 95203: {
106838:   // NOTE: aElement will be nullptr when unlocking.
 95203:   sIsPointerLocked = !!aElement;
 95203: 
 95203:   if (!aWidget) {
 95203:     return;
 95203:   }
 95203: 
 95203:   // Reset mouse wheel transaction
196023:   WheelTransaction::EndTransaction();
 95203: 
 95203:   // Deal with DnD events
 95203:   nsCOMPtr<nsIDragService> dragService =
 95203:     do_GetService("@mozilla.org/widget/dragservice;1");
 95203: 
 95203:   if (sIsPointerLocked) {
 95203:     // Store the last known ref point so we can reposition the pointer after unlock.
102504:     mPreLockPoint = sLastRefPoint;
102504: 
102504:     // Fire a synthetic mouse move to ensure event state is updated. We first
102504:     // set the mouse to the center of the window, so that the mouse event
102504:     // doesn't report any movement.
102504:     sLastRefPoint = GetWindowInnerRectCenter(aElement->OwnerDoc()->GetWindow(),
102504:                                              aWidget,
102504:                                              mPresContext);
114823:     aWidget->SynthesizeNativeMouseMove(
154119:       LayoutDeviceIntPoint::ToUntyped(sLastRefPoint) + aWidget->WidgetToScreenOffset());
 95203: 
 95203:     // Retarget all events to this element via capture.
 95203:     nsIPresShell::SetCapturingContent(aElement, CAPTURE_POINTERLOCK);
 95203: 
 95203:     // Suppress DnD
 95203:     if (dragService) {
 95203:       dragService->Suppress();
 95203:     }
 95203:   } else {
102504:     // Unlocking, so return pointer to the original position by firing a
102504:     // synthetic mouse event. We first reset sLastRefPoint to its
102504:     // pre-pointerlock position, so that the synthetic mouse event reports
102504:     // no movement.
102504:     sLastRefPoint = mPreLockPoint;
114823:     aWidget->SynthesizeNativeMouseMove(
154119:       LayoutDeviceIntPoint::ToUntyped(mPreLockPoint) + aWidget->WidgetToScreenOffset());
 95203: 
 95203:     // Don't retarget events to this element any more.
106838:     nsIPresShell::SetCapturingContent(nullptr, CAPTURE_POINTERLOCK);
 95203: 
 95203:     // Unsuppress DnD
 95203:     if (dragService) {
 95203:       dragService->Unsuppress();
 95203:     }
 95203:   }
 95203: }
 95203: 
 95203: void
196025: EventStateManager::GenerateDragDropEnterExit(nsPresContext* aPresContext,
166409:                                              WidgetDragEvent* aDragEvent)
     1: {
     1:   //Hold onto old target content through the event and reset after.
     1:   nsCOMPtr<nsIContent> targetBeforeEvent = mCurrentTargetContent;
     1: 
166409:   switch(aDragEvent->message) {
     1:   case NS_DRAGDROP_OVER:
     1:     {
 58550:       // when dragging from one frame to another, events are fired in the
 58550:       // order: dragexit, dragenter, dragleave
 79435:       if (sLastDragOverFrame != mCurrentTarget) {
     1:         //We'll need the content, too, to check if it changed separately from the frames.
     1:         nsCOMPtr<nsIContent> lastContent;
     1:         nsCOMPtr<nsIContent> targetContent;
166409:         mCurrentTarget->GetContentForEvent(aDragEvent,
166409:                                            getter_AddRefs(targetContent));
 79435: 
 79435:         if (sLastDragOverFrame) {
   482:           //The frame has changed but the content may not have. Check before dispatching to content
166409:           sLastDragOverFrame->GetContentForEvent(aDragEvent,
166409:                                                  getter_AddRefs(lastContent));
 79435: 
 79435:           FireDragEnterOrExit(sLastDragOverFrame->PresContext(),
166409:                               aDragEvent, NS_DRAGDROP_EXIT_SYNTH,
 79435:                               targetContent, lastContent, sLastDragOverFrame);
 58550:         }
 58550: 
166409:         FireDragEnterOrExit(aPresContext, aDragEvent, NS_DRAGDROP_ENTER,
 58550:                             lastContent, targetContent, mCurrentTarget);
 58550: 
 79435:         if (sLastDragOverFrame) {
 79435:           FireDragEnterOrExit(sLastDragOverFrame->PresContext(),
166409:                               aDragEvent, NS_DRAGDROP_LEAVE_SYNTH,
 79435:                               targetContent, lastContent, sLastDragOverFrame);
 79435:         }
 79435: 
 79435:         sLastDragOverFrame = mCurrentTarget;
   482:       }
   482:     }
   482:     break;
   482: 
   482:   case NS_DRAGDROP_EXIT:
   482:     {
   482:       //This is actually the window mouse exit event.
 79435:       if (sLastDragOverFrame) {
   482:         nsCOMPtr<nsIContent> lastContent;
166409:         sLastDragOverFrame->GetContentForEvent(aDragEvent,
166409:                                                getter_AddRefs(lastContent));
 79435: 
 79435:         nsRefPtr<nsPresContext> lastDragOverFramePresContext = sLastDragOverFrame->PresContext();
 79435:         FireDragEnterOrExit(lastDragOverFramePresContext,
166409:                             aDragEvent, NS_DRAGDROP_EXIT_SYNTH,
106838:                             nullptr, lastContent, sLastDragOverFrame);
 79435:         FireDragEnterOrExit(lastDragOverFramePresContext,
166409:                             aDragEvent, NS_DRAGDROP_LEAVE_SYNTH,
106838:                             nullptr, lastContent, sLastDragOverFrame);
106838: 
106838:         sLastDragOverFrame = nullptr;
   482:       }
   482:     }
   482:     break;
   482:   }
   482: 
   482:   //reset mCurretTargetContent to what it was
   482:   mCurrentTargetContent = targetBeforeEvent;
   482: 
   482:   // Now flush all pending notifications, for better responsiveness.
   482:   FlushPendingEvents(aPresContext);
   482: }
   482: 
   482: void
196025: EventStateManager::FireDragEnterOrExit(nsPresContext* aPresContext,
166409:                                        WidgetDragEvent* aDragEvent,
108991:                                        uint32_t aMsg,
   482:                                        nsIContent* aRelatedTarget,
   482:                                        nsIContent* aTargetContent,
   482:                                        nsWeakFrame& aTargetFrame)
   482: {
     1:   nsEventStatus status = nsEventStatus_eIgnore;
166409:   WidgetDragEvent event(aDragEvent->mFlags.mIsTrusted, aMsg,
166409:                         aDragEvent->widget);
166409:   event.refPoint = aDragEvent->refPoint;
166409:   event.modifiers = aDragEvent->modifiers;
166409:   event.buttons = aDragEvent->buttons;
   482:   event.relatedTarget = aRelatedTarget;
166409:   event.inputSource = aDragEvent->inputSource;
   482: 
   482:   mCurrentTargetContent = aTargetContent;
   482: 
   482:   if (aTargetContent != aRelatedTarget) {
     1:     //XXX This event should still go somewhere!!
193672:     if (aTargetContent) {
193672:       EventDispatcher::Dispatch(aTargetContent, aPresContext, &event,
106838:                                 nullptr, &status);
193672:     }
     1: 
 19702:     // adjust the drag hover if the dragenter event was cancelled or this is a drag exit
 19702:     if (status == nsEventStatus_eConsumeNoDefault || aMsg == NS_DRAGDROP_EXIT)
106838:       SetContentState((aMsg == NS_DRAGDROP_ENTER) ? aTargetContent : nullptr,
   482:                       NS_EVENT_STATE_DRAGOVER);
 33528: 
 33528:     // collect any changes to moz cursor settings stored in the event's
 33528:     // data transfer.
 33528:     if (aMsg == NS_DRAGDROP_LEAVE_SYNTH || aMsg == NS_DRAGDROP_EXIT_SYNTH ||
 33528:         aMsg == NS_DRAGDROP_ENTER)
 33528:       UpdateDragDataTransfer(&event);
   482:   }
   482: 
   482:   // Finally dispatch the event to the frame
   482:   if (aTargetFrame)
   482:     aTargetFrame->HandleEvent(aPresContext, &event, &status);
     1: }
     1: 
 33528: void
196025: EventStateManager::UpdateDragDataTransfer(WidgetDragEvent* dragEvent)
 33528: {
 33528:   NS_ASSERTION(dragEvent, "drag event is null in UpdateDragDataTransfer!");
 33528:   if (!dragEvent->dataTransfer)
 33528:     return;
 33528: 
 33528:   nsCOMPtr<nsIDragSession> dragSession = nsContentUtils::GetDragSession();
 33528: 
 33528:   if (dragSession) {
 33528:     // the initial dataTransfer is the one from the dragstart event that
 33528:     // was set on the dragSession when the drag began.
 33528:     nsCOMPtr<nsIDOMDataTransfer> initialDataTransfer;
 33528:     dragSession->GetDataTransfer(getter_AddRefs(initialDataTransfer));
 89615:     if (initialDataTransfer) {
 33528:       // retrieve the current moz cursor setting and save it.
 33528:       nsAutoString mozCursor;
 89615:       dragEvent->dataTransfer->GetMozCursor(mozCursor);
 89615:       initialDataTransfer->SetMozCursor(mozCursor);
 33528:     }
 33528:   }
 33528: }
 33528: 
     1: nsresult
196025: EventStateManager::SetClickCount(nsPresContext* aPresContext,
164386:                                  WidgetMouseEvent* aEvent,
     1:                                  nsEventStatus* aStatus)
     1: {
     1:   nsCOMPtr<nsIContent> mouseContent;
106838:   nsIContent* mouseContentParent = nullptr;
 79435:   mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(mouseContent));
 69450:   if (mouseContent) {
 69450:     if (mouseContent->IsNodeOfType(nsINode::eTEXT)) {
 69450:       mouseContent = mouseContent->GetParent();
 69450:     }
 69450:     if (mouseContent && mouseContent->IsRootOfNativeAnonymousSubtree()) {
 69450:       mouseContentParent = mouseContent->GetParent();
 69450:     }
 69450:   }
     1: 
     1:   switch (aEvent->button) {
164386:   case WidgetMouseEvent::eLeftButton:
     1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
     1:       mLastLeftMouseDownContent = mouseContent;
 51869:       mLastLeftMouseDownContentParent = mouseContentParent;
     1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
 37465:       if (mLastLeftMouseDownContent == mouseContent ||
 51869:           mLastLeftMouseDownContentParent == mouseContent ||
 51869:           mLastLeftMouseDownContent == mouseContentParent) {
     1:         aEvent->clickCount = mLClickCount;
     1:         mLClickCount = 0;
     1:       } else {
     1:         aEvent->clickCount = 0;
     1:       }
106838:       mLastLeftMouseDownContent = nullptr;
106838:       mLastLeftMouseDownContentParent = nullptr;
     1:     }
     1:     break;
     1: 
164386:   case WidgetMouseEvent::eMiddleButton:
     1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
     1:       mLastMiddleMouseDownContent = mouseContent;
 51869:       mLastMiddleMouseDownContentParent = mouseContentParent;
     1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
 37465:       if (mLastMiddleMouseDownContent == mouseContent ||
 51869:           mLastMiddleMouseDownContentParent == mouseContent ||
 52181:           mLastMiddleMouseDownContent == mouseContentParent) {
     1:         aEvent->clickCount = mMClickCount;
     1:         mMClickCount = 0;
     1:       } else {
     1:         aEvent->clickCount = 0;
     1:       }
106838:       mLastMiddleMouseDownContent = nullptr;
106838:       mLastMiddleMouseDownContentParent = nullptr;
     1:     }
     1:     break;
     1: 
164386:   case WidgetMouseEvent::eRightButton:
     1:     if (aEvent->message == NS_MOUSE_BUTTON_DOWN) {
     1:       mLastRightMouseDownContent = mouseContent;
 51869:       mLastRightMouseDownContentParent = mouseContentParent;
     1:     } else if (aEvent->message == NS_MOUSE_BUTTON_UP) {
 37465:       if (mLastRightMouseDownContent == mouseContent ||
 51869:           mLastRightMouseDownContentParent == mouseContent ||
 52181:           mLastRightMouseDownContent == mouseContentParent) {
     1:         aEvent->clickCount = mRClickCount;
     1:         mRClickCount = 0;
     1:       } else {
     1:         aEvent->clickCount = 0;
     1:       }
106838:       mLastRightMouseDownContent = nullptr;
106838:       mLastRightMouseDownContentParent = nullptr;
     1:     }
     1:     break;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
196025: EventStateManager::CheckForAndDispatchClick(nsPresContext* aPresContext,
164386:                                             WidgetMouseEvent* aEvent,
     1:                                             nsEventStatus* aStatus)
     1: {
     1:   nsresult ret = NS_OK;
     1: 
     1:   //If mouse is still over same element, clickcount will be > 1.
     1:   //If it has moved it will be zero, so no click.
     1:   if (0 != aEvent->clickCount) {
     1:     //Check that the window isn't disabled before firing a click
     1:     //(see bug 366544).
106103:     if (aEvent->widget && !aEvent->widget->IsEnabled()) {
     1:       return ret;
     1:     }
     1:     //fire click
126038:     bool notDispatchToContents =
164386:      (aEvent->button == WidgetMouseEvent::eMiddleButton ||
164386:       aEvent->button == WidgetMouseEvent::eRightButton);
164386: 
164386:     WidgetMouseEvent event(aEvent->mFlags.mIsTrusted, NS_MOUSE_CLICK,
164386:                            aEvent->widget, WidgetMouseEvent::eReal);
     1:     event.refPoint = aEvent->refPoint;
     1:     event.clickCount = aEvent->clickCount;
 96887:     event.modifiers = aEvent->modifiers;
 96888:     event.buttons = aEvent->buttons;
     1:     event.time = aEvent->time;
207315:     event.timeStamp = aEvent->timeStamp;
126038:     event.mFlags.mNoContentDispatch = notDispatchToContents;
     1:     event.button = aEvent->button;
 40485:     event.inputSource = aEvent->inputSource;
     1: 
     1:     nsCOMPtr<nsIPresShell> presShell = mPresContext->GetPresShell();
     1:     if (presShell) {
 68780:       nsCOMPtr<nsIContent> mouseContent = GetEventTargetContent(aEvent);
141371:       if (!mouseContent && !mCurrentTarget) {
141371:         return NS_OK;
141371:       }
151907: 
151907:       // HandleEvent clears out mCurrentTarget which we might need again
151907:       nsWeakFrame currentTarget = mCurrentTarget;
151907:       ret = presShell->HandleEventWithTarget(&event, currentTarget,
     1:                                              mouseContent, aStatus);
     1:       if (NS_SUCCEEDED(ret) && aEvent->clickCount == 2) {
     1:         //fire double click
164386:         WidgetMouseEvent event2(aEvent->mFlags.mIsTrusted, NS_MOUSE_DOUBLECLICK,
164386:                                 aEvent->widget, WidgetMouseEvent::eReal);
     1:         event2.refPoint = aEvent->refPoint;
     1:         event2.clickCount = aEvent->clickCount;
 96887:         event2.modifiers = aEvent->modifiers;
 96888:         event2.buttons = aEvent->buttons;
126038:         event2.mFlags.mNoContentDispatch = notDispatchToContents;
     1:         event2.button = aEvent->button;
 40485:         event2.inputSource = aEvent->inputSource;
     1: 
151907:         ret = presShell->HandleEventWithTarget(&event2, currentTarget,
     1:                                                mouseContent, aStatus);
     1:       }
     1:     }
     1:   }
     1:   return ret;
     1: }
     1: 
 68780: nsIFrame*
196025: EventStateManager::GetEventTarget()
     1: {
 30569:   nsIPresShell *shell;
 30569:   if (mCurrentTarget ||
 30569:       !mPresContext ||
 30569:       !(shell = mPresContext->GetPresShell())) {
 68780:     return mCurrentTarget;
 30569:   }
 30569: 
 30569:   if (mCurrentTargetContent) {
 36655:     mCurrentTarget = mPresContext->GetPrimaryFrameFor(mCurrentTargetContent);
 30569:     if (mCurrentTarget) {
 68780:       return mCurrentTarget;
 30569:     }
 30569:   }
 30569: 
 40047:   nsIFrame* frame = shell->GetEventTargetFrame();
 68780:   return (mCurrentTarget = frame);
 68780: }
 68780: 
 68780: already_AddRefed<nsIContent>
196025: EventStateManager::GetEventTargetContent(WidgetEvent* aEvent)
     1: {
     1:   if (aEvent &&
     1:       (aEvent->message == NS_FOCUS_CONTENT ||
     1:        aEvent->message == NS_BLUR_CONTENT)) {
 68780:     nsCOMPtr<nsIContent> content = GetFocusedContent();
 68780:     return content.forget();
     1:   }
     1: 
     1:   if (mCurrentTargetContent) {
 68780:     nsCOMPtr<nsIContent> content = mCurrentTargetContent;
 68780:     return content.forget();
 68780:   }
 68780: 
141832:   nsCOMPtr<nsIContent> content;
     1: 
     1:   nsIPresShell *presShell = mPresContext->GetPresShell();
     1:   if (presShell) {
141832:     content = presShell->GetEventTargetContent(aEvent);
     1:   }
     1: 
     1:   // Some events here may set mCurrentTarget but not set the corresponding
     1:   // event target in the PresShell.
 68780:   if (!content && mCurrentTarget) {
141832:     mCurrentTarget->GetContentForEvent(aEvent, getter_AddRefs(content));
141832:   }
141832: 
141832:   return content.forget();
     1: }
     1: 
 70852: static Element*
 70852: GetLabelTarget(nsIContent* aPossibleLabel)
 42951: {
126764:   mozilla::dom::HTMLLabelElement* label =
126764:     mozilla::dom::HTMLLabelElement::FromContent(aPossibleLabel);
 42951:   if (!label)
106838:     return nullptr;
 42951: 
 70852:   return label->GetLabeledElement();
 42951: }
 42951: 
     1: static nsIContent* FindCommonAncestor(nsIContent *aNode1, nsIContent *aNode2)
     1: {
     1:   // Find closest common ancestor
     1:   if (aNode1 && aNode2) {
     1:     // Find the nearest common ancestor by counting the distance to the
     1:     // root and then walking up again, in pairs.
108991:     int32_t offset = 0;
     1:     nsIContent *anc1 = aNode1;
     1:     for (;;) {
     1:       ++offset;
     1:       nsIContent* parent = anc1->GetParent();
     1:       if (!parent)
     1:         break;
     1:       anc1 = parent;
     1:     }
     1:     nsIContent *anc2 = aNode2;
     1:     for (;;) {
     1:       --offset;
     1:       nsIContent* parent = anc2->GetParent();
     1:       if (!parent)
     1:         break;
     1:       anc2 = parent;
     1:     }
     1:     if (anc1 == anc2) {
     1:       anc1 = aNode1;
     1:       anc2 = aNode2;
     1:       while (offset > 0) {
     1:         anc1 = anc1->GetParent();
     1:         --offset;
     1:       }
     1:       while (offset < 0) {
     1:         anc2 = anc2->GetParent();
     1:         ++offset;
     1:       }
     1:       while (anc1 != anc2) {
     1:         anc1 = anc1->GetParent();
     1:         anc2 = anc2->GetParent();
     1:       }
     1:       return anc1;
     1:     }
     1:   }
106838:   return nullptr;
     1: }
     1: 
 81144: static Element*
 81144: GetParentElement(Element* aElement)
 81144: {
 81144:   nsIContent* p = aElement->GetParent();
106838:   return (p && p->IsElement()) ? p->AsElement() : nullptr;
 81144: }
 81144: 
 71112: /* static */
 77844: void
196025: EventStateManager::SetFullScreenState(Element* aElement, bool aIsFullScreen)
 77844: {
 77844:   DoStateChange(aElement, NS_EVENT_STATE_FULL_SCREEN, aIsFullScreen);
 81144:   Element* ancestor = aElement;
 81144:   while ((ancestor = GetParentElement(ancestor))) {
 81144:     DoStateChange(ancestor, NS_EVENT_STATE_FULL_SCREEN_ANCESTOR, aIsFullScreen);
 81144:   }
 77844: }
 77844: 
 77844: /* static */
 71112: inline void
196390: EventStateManager::DoStateChange(Element* aElement, EventStates aState,
 79445:                                  bool aAddState)
 42949: {
 71112:   if (aAddState) {
 71112:     aElement->AddStates(aState);
 71112:   } else {
 71112:     aElement->RemoveStates(aState);
 71112:   }
 71112: }
 71112: 
 71112: /* static */
 71113: inline void
196390: EventStateManager::DoStateChange(nsIContent* aContent, EventStates aState,
 79445:                                  bool aStateAdded)
 71113: {
 71113:   if (aContent->IsElement()) {
 71113:     DoStateChange(aContent->AsElement(), aState, aStateAdded);
 71113:   }
 71113: }
 71113: 
 71113: /* static */
 71112: void
196025: EventStateManager::UpdateAncestorState(nsIContent* aStartNode,
 71112:                                        nsIContent* aStopBefore,
196390:                                        EventStates aState,
 79445:                                        bool aAddState)
 71112: {
 71112:   for (; aStartNode && aStartNode != aStopBefore;
 71112:        aStartNode = aStartNode->GetParent()) {
 71112:     // We might be starting with a non-element (e.g. a text node) and
 71112:     // if someone is doing something weird might be ending with a
 71112:     // non-element too (e.g. a document fragment)
 71112:     if (!aStartNode->IsElement()) {
 71112:       continue;
 71112:     }
 71112:     Element* element = aStartNode->AsElement();
 71112:     DoStateChange(element, aState, aAddState);
 71112:     Element* labelTarget = GetLabelTarget(element);
 42951:     if (labelTarget) {
 71112:       DoStateChange(labelTarget, aState, aAddState);
 71112:     }
 42949:   }
 86028: 
 86028:   if (aAddState) {
 86028:     // We might be in a situation where a node was in hover both
 86028:     // because it was hovered and because the label for it was
 86028:     // hovered, and while we stopped hovering the node the label is
 86028:     // still hovered.  Or we might have had two nested labels for the
 86028:     // same node, and while one is no longer hovered the other still
 86028:     // is.  In that situation, the label that's still hovered will be
 86028:     // aStopBefore or some ancestor of it, and the call we just made
 86028:     // to UpdateAncestorState with aAddState = false would have
 86028:     // removed the hover state from the node.  But the node should
 86028:     // still be in hover state.  To handle this situation we need to
 86028:     // keep walking up the tree and any time we find a label mark its
 86028:     // corresponding node as still in our state.
 86028:     for ( ; aStartNode; aStartNode = aStartNode->GetParent()) {
 86028:       if (!aStartNode->IsElement()) {
 86028:         continue;
 86028:       }
 86028: 
 86028:       Element* labelTarget = GetLabelTarget(aStartNode->AsElement());
 86028:       if (labelTarget && !labelTarget->State().HasState(aState)) {
 86028:         DoStateChange(labelTarget, aState, true);
 86028:       }
 86028:     }
 86028:   }
 42949: }
 42949: 
 79445: bool
196390: EventStateManager::SetContentState(nsIContent* aContent, EventStates aState)
     1: {
 64122:   // We manage 4 states here: ACTIVE, HOVER, DRAGOVER, URLTARGET
 64122:   // The input must be exactly one of them.
 64122:   NS_PRECONDITION(aState == NS_EVENT_STATE_ACTIVE ||
 64122:                   aState == NS_EVENT_STATE_HOVER ||
 64122:                   aState == NS_EVENT_STATE_DRAGOVER ||
 64122:                   aState == NS_EVENT_STATE_URLTARGET,
 64122:                   "Unexpected state");
 64122: 
 64122:   nsCOMPtr<nsIContent> notifyContent1;
 64122:   nsCOMPtr<nsIContent> notifyContent2;
 79445:   bool updateAncestors;
 64122: 
 64122:   if (aState == NS_EVENT_STATE_HOVER || aState == NS_EVENT_STATE_ACTIVE) {
 64122:     // Hover and active are hierarchical
 80486:     updateAncestors = true;
     1: 
     1:     // check to see that this state is allowed by style. Check dragover too?
     1:     // XXX Is this even what we want?
 64122:     if (mCurrentTarget)
     1:     {
132812:       const nsStyleUserInterface* ui = mCurrentTarget->StyleUserInterface();
     1:       if (ui->mUserInput == NS_STYLE_USER_INPUT_NONE)
 80486:         return false;
     1:     }
     1: 
 64122:     if (aState == NS_EVENT_STATE_ACTIVE) {
 64122:       if (aContent != mActiveContent) {
 64122:         notifyContent1 = aContent;
 64122:         notifyContent2 = mActiveContent;
     1:         mActiveContent = aContent;
     1:       }
 64122:     } else {
 64122:       NS_ASSERTION(aState == NS_EVENT_STATE_HOVER, "How did that happen?");
 64122:       nsIContent* newHover;
     1:       
 63649:       if (mPresContext->IsDynamic()) {
     1:         newHover = aContent;
     1:       } else {
 36655:         NS_ASSERTION(!aContent ||
207686:                      aContent->GetCrossShadowCurrentDoc() ==
207686:                        mPresContext->PresShell()->GetDocument(),
 36655:                      "Unexpected document");
106838:         nsIFrame *frame = aContent ? aContent->GetPrimaryFrame() : nullptr;
     1:         if (frame && nsLayoutUtils::IsViewportScrollbarFrame(frame)) {
     1:           // The scrollbars of viewport should not ignore the hover state.
     1:           // Because they are *not* the content of the web page.
     1:           newHover = aContent;
     1:         } else {
     1:           // All contents of the web page should ignore the hover state.
106838:           newHover = nullptr;
     1:         }
     1:       }
     1: 
 64122:       if (newHover != mHoverContent) {
 64122:         notifyContent1 = newHover;
 64122:         notifyContent2 = mHoverContent;
 64122:         mHoverContent = newHover;
 64122:       }
 64122:     }
 64122:   } else {
 80486:     updateAncestors = false;
 64122:     if (aState == NS_EVENT_STATE_DRAGOVER) {
 79435:       if (aContent != sDragOverContent) {
 64122:         notifyContent1 = aContent;
 79435:         notifyContent2 = sDragOverContent;
 79435:         sDragOverContent = aContent;
 64122:       }
 64122:     } else if (aState == NS_EVENT_STATE_URLTARGET) {
 64122:       if (aContent != mURLTargetContent) {
 64122:         notifyContent1 = aContent;
 64122:         notifyContent2 = mURLTargetContent;
 64122:         mURLTargetContent = aContent;
 64122:       }
 64122:     }
 64122:   }
 64122: 
 71112:   // We need to keep track of which of notifyContent1 and notifyContent2 is
 71112:   // getting the state set and which is getting it unset.  If both are
 71112:   // non-null, then notifyContent1 is having the state set and notifyContent2
 71112:   // is having it unset.  But if one of them is null, we need to keep track of
 71112:   // the right thing for notifyContent1 explicitly.
 79445:   bool content1StateSet = true;
 64122:   if (!notifyContent1) {
 64122:     // This is ok because FindCommonAncestor wouldn't find anything
 64122:     // anyway if notifyContent1 is null.
 64122:     notifyContent1 = notifyContent2;
106838:     notifyContent2 = nullptr;
 80486:     content1StateSet = false;
 64122:   }
 64122: 
 64122:   if (notifyContent1 && mPresContext) {
     1:     EnsureDocument(mPresContext);
 64122:     if (mDocument) {
 71103:       nsAutoScriptBlocker scriptBlocker;
 64122: 
 71112:       if (updateAncestors) {
 64122:         nsCOMPtr<nsIContent> commonAncestor =
 64122:           FindCommonAncestor(notifyContent1, notifyContent2);
 64122:         if (notifyContent2) {
 71112:           // It's very important to first notify the state removal and
 71112:           // then the state addition, because due to labels it's
 71112:           // possible that we're removing state from some element but
 71112:           // then adding it again (say because mHoverContent changed
 71112:           // from a control to its label).
 80486:           UpdateAncestorState(notifyContent2, commonAncestor, aState, false);
 71112:         }
 71112:         UpdateAncestorState(notifyContent1, commonAncestor, aState,
 71112:                             content1StateSet);
 64122:       } else {
 64122:         if (notifyContent2) {
 80486:           DoStateChange(notifyContent2, aState, false);
 71113:         }
 71113:         DoStateChange(notifyContent1, aState, content1StateSet);
 64122:       }
     1:     }
     1:   }
     1: 
 80486:   return true;
 29018: }
 29018: 
186255: PLDHashOperator
196025: EventStateManager::ResetLastOverForContent(
196025:                      const uint32_t& aIdx,
186255:                      nsRefPtr<OverOutElementsWrapper>& aElemWrapper,
186255:                      void* aClosure)
186255: {
186255:   nsIContent* content = static_cast<nsIContent*>(aClosure);
186255:   if (aElemWrapper && aElemWrapper->mLastOverElement &&
186255:       nsContentUtils::ContentIsDescendantOf(aElemWrapper->mLastOverElement, content)) {
186255:     aElemWrapper->mLastOverElement = nullptr;
186255:   }
186255: 
186255:   return PL_DHASH_NEXT;
186255: }
186255: 
 68780: void
196025: EventStateManager::ContentRemoved(nsIDocument* aDocument, nsIContent* aContent)
     1: {
 95699:   /*
 95699:    * Anchor and area elements when focused or hovered might make the UI to show
 95699:    * the current link. We want to make sure that the UI gets informed when they
 95699:    * are actually removed from the DOM.
 95699:    */
 95699:   if (aContent->IsHTML() &&
 95699:       (aContent->Tag() == nsGkAtoms::a || aContent->Tag() == nsGkAtoms::area) &&
 95699:       (aContent->AsElement()->State().HasAtLeastOneOfStates(NS_EVENT_STATE_FOCUS |
 95699:                                                             NS_EVENT_STATE_HOVER))) {
 95699:     nsGenericHTMLElement* element = static_cast<nsGenericHTMLElement*>(aContent);
224164:     element->LeaveLink(
224164:       element->GetPresContext(nsGenericHTMLElement::eForComposedDoc));
 95699:   }
 95699: 
190851:   IMEStateManager::OnRemoveContent(mPresContext, aContent);
119248: 
 29018:   // inform the focus manager that the content is being removed. If this
 29018:   // content is focused, the focus will be removed without firing events.
 41409:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (fm)
 29018:     fm->ContentRemoved(aDocument, aContent);
     1: 
     1:   if (mHoverContent &&
     1:       nsContentUtils::ContentIsDescendantOf(mHoverContent, aContent)) {
     1:     // Since hover is hierarchical, set the current hover to the
     1:     // content's parent node.
 42951:     SetContentState(aContent->GetParent(), NS_EVENT_STATE_HOVER);
     1:   }
     1: 
     1:   if (mActiveContent &&
     1:       nsContentUtils::ContentIsDescendantOf(mActiveContent, aContent)) {
     1:     // Active is hierarchical, so set the current active to the
     1:     // content's parent node.
 42951:     SetContentState(aContent->GetParent(), NS_EVENT_STATE_ACTIVE);
     1:   }
     1: 
 79435:   if (sDragOverContent &&
 80526:       sDragOverContent->OwnerDoc() == aContent->OwnerDoc() &&
 79435:       nsContentUtils::ContentIsDescendantOf(sDragOverContent, aContent)) {
106838:     sDragOverContent = nullptr;
     1:   }
     1: 
     1:   // See bug 292146 for why we want to null this out
186255:   ResetLastOverForContent(0, mMouseEnterLeaveHelper, aContent);
196025:   mPointersEnterLeaveHelper.Enumerate(
196025:     &EventStateManager::ResetLastOverForContent, aContent);
 68780: }
 68780: 
 79445: bool
196025: EventStateManager::EventStatusOK(WidgetGUIEvent* aEvent)
     1: {
 68780:   return !(aEvent->message == NS_MOUSE_BUTTON_DOWN &&
166409:            aEvent->AsMouseEvent()->button == WidgetMouseEvent::eLeftButton &&
 68780:            !sNormalLMouseEventInProcess);
     1: }
     1: 
     1: //-------------------------------------------
     1: // Access Key Registration
     1: //-------------------------------------------
 68780: void
196025: EventStateManager::RegisterAccessKey(nsIContent* aContent, uint32_t aKey)
     1: {
  8407:   if (aContent && mAccessKeys.IndexOf(aContent) == -1)
  8407:     mAccessKeys.AppendObject(aContent);
 68780: }
 68780: 
 68780: void
196025: EventStateManager::UnregisterAccessKey(nsIContent* aContent, uint32_t aKey)
     1: {
  8407:   if (aContent)
  8407:     mAccessKeys.RemoveObject(aContent);
 68780: }
 68780: 
108991: uint32_t
196025: EventStateManager::GetRegisteredAccessKey(nsIContent* aContent)
  5414: {
111239:   MOZ_ASSERT(aContent);
  5414: 
  8407:   if (mAccessKeys.IndexOf(aContent) == -1)
 68780:     return 0;
  5414: 
  8407:   nsAutoString accessKey;
  8407:   aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accessKey);
 68780:   return accessKey.First();
  5414: }
  5414: 
     1: void
196025: EventStateManager::EnsureDocument(nsPresContext* aPresContext)
     1: {
     1:   if (!mDocument)
     1:     mDocument = aPresContext->Document();
     1: }
     1: 
     1: void
196025: EventStateManager::FlushPendingEvents(nsPresContext* aPresContext)
     1: {
106838:   NS_PRECONDITION(nullptr != aPresContext, "nullptr ptr");
     1:   nsIPresShell *shell = aPresContext->GetPresShell();
     1:   if (shell) {
 27993:     shell->FlushPendingNotifications(Flush_InterruptibleLayout);
     1:   }
     1: }
     1: 
 29018: nsIContent*
196025: EventStateManager::GetFocusedContent()
     1: {
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (!fm || !mDocument)
106838:     return nullptr;
 29018: 
 29018:   nsCOMPtr<nsPIDOMWindow> focusedWindow;
 80486:   return nsFocusManager::GetFocusedDescendant(mDocument->GetWindow(), false,
 29018:                                               getter_AddRefs(focusedWindow));
     1: }
     1: 
     1: //-------------------------------------------------------
 80486: // Return true if the docshell is visible
     1: 
 79445: bool
196025: EventStateManager::IsShellVisible(nsIDocShell* aShell)
     1: {
     1:   NS_ASSERTION(aShell, "docshell is null");
     1: 
     1:   nsCOMPtr<nsIBaseWindow> basewin = do_QueryInterface(aShell);
     1:   if (!basewin)
 80486:     return true;
     1: 
 79445:   bool isVisible = true;
     1:   basewin->GetVisibility(&isVisible);
     1: 
     1:   // We should be doing some additional checks here so that
     1:   // we don't tab into hidden tabs of tabbrowser.  -bryner
     1: 
     1:   return isVisible;
     1: }
 31218: 
 31218: nsresult
196025: EventStateManager::DoContentCommandEvent(WidgetContentCommandEvent* aEvent)
 31218: {
 31218:   EnsureDocument(mPresContext);
 31218:   NS_ENSURE_TRUE(mDocument, NS_ERROR_FAILURE);
 38336:   nsCOMPtr<nsPIDOMWindow> window(mDocument->GetWindow());
 31218:   NS_ENSURE_TRUE(window, NS_ERROR_FAILURE);
 38336: 
 38336:   nsCOMPtr<nsPIWindowRoot> root = window->GetTopWindowRoot();
 38336:   NS_ENSURE_TRUE(root, NS_ERROR_FAILURE);
 31218:   const char* cmd;
 31218:   switch (aEvent->message) {
 31218:     case NS_CONTENT_COMMAND_CUT:
 31218:       cmd = "cmd_cut";
 31218:       break;
 31218:     case NS_CONTENT_COMMAND_COPY:
 31218:       cmd = "cmd_copy";
 31218:       break;
 31218:     case NS_CONTENT_COMMAND_PASTE:
 31218:       cmd = "cmd_paste";
 31218:       break;
 31218:     case NS_CONTENT_COMMAND_DELETE:
 31218:       cmd = "cmd_delete";
 31218:       break;
 31218:     case NS_CONTENT_COMMAND_UNDO:
 31218:       cmd = "cmd_undo";
 31218:       break;
 31218:     case NS_CONTENT_COMMAND_REDO:
 31218:       cmd = "cmd_redo";
 31218:       break;
 36983:     case NS_CONTENT_COMMAND_PASTE_TRANSFERABLE:
 36983:       cmd = "cmd_pasteTransferable";
 36983:       break;
 31218:     default:
 31218:       return NS_ERROR_NOT_IMPLEMENTED;
 31218:   }
 31218:   nsCOMPtr<nsIController> controller;
 38336:   nsresult rv = root->GetControllerForCommand(cmd, getter_AddRefs(controller));
 31218:   NS_ENSURE_SUCCESS(rv, rv);
 31218:   if (!controller) {
 31218:     // When GetControllerForCommand succeeded but there is no controller, the
 31218:     // command isn't supported.
 80486:     aEvent->mIsEnabled = false;
 31218:   } else {
 79445:     bool canDoIt;
 31218:     rv = controller->IsCommandEnabled(cmd, &canDoIt);
 31218:     NS_ENSURE_SUCCESS(rv, rv);
 31218:     aEvent->mIsEnabled = canDoIt;
 31218:     if (canDoIt && !aEvent->mOnlyEnabledCheck) {
 36983:       switch (aEvent->message) {
 36983:         case NS_CONTENT_COMMAND_PASTE_TRANSFERABLE: {
 36983:           nsCOMPtr<nsICommandController> commandController = do_QueryInterface(controller);
 36983:           NS_ENSURE_STATE(commandController);
 36983: 
 36983:           nsCOMPtr<nsICommandParams> params = do_CreateInstance("@mozilla.org/embedcomp/command-params;1", &rv);
 36983:           NS_ENSURE_SUCCESS(rv, rv);
 36983: 
 36983:           rv = params->SetISupportsValue("transferable", aEvent->mTransferable);
 36983:           NS_ENSURE_SUCCESS(rv, rv);
 36983: 
 36983:           rv = commandController->DoCommandWithParams(cmd, params);
 36983:           break;
 36983:         }
 36983:         
 36983:         default:
 31218:           rv = controller->DoCommand(cmd);
 36983:           break;
 36983:       }
 31218:       NS_ENSURE_SUCCESS(rv, rv);
 31218:     }
 31218:   }
 80486:   aEvent->mSucceeded = true;
 31218:   return NS_OK;
 31218: }
 39248: 
 39248: nsresult
196025: EventStateManager::DoContentCommandScrollEvent(
163715:                      WidgetContentCommandEvent* aEvent)
 39248: {
 39248:   NS_ENSURE_TRUE(mPresContext, NS_ERROR_NOT_AVAILABLE);
 39248:   nsIPresShell* ps = mPresContext->GetPresShell();
 39248:   NS_ENSURE_TRUE(ps, NS_ERROR_NOT_AVAILABLE);
 39248:   NS_ENSURE_TRUE(aEvent->mScroll.mAmount != 0, NS_ERROR_INVALID_ARG);
 39248: 
 39248:   nsIScrollableFrame::ScrollUnit scrollUnit;
 39248:   switch (aEvent->mScroll.mUnit) {
163715:     case WidgetContentCommandEvent::eCmdScrollUnit_Line:
 39248:       scrollUnit = nsIScrollableFrame::LINES;
 39248:       break;
163715:     case WidgetContentCommandEvent::eCmdScrollUnit_Page:
 39248:       scrollUnit = nsIScrollableFrame::PAGES;
 39248:       break;
163715:     case WidgetContentCommandEvent::eCmdScrollUnit_Whole:
 39248:       scrollUnit = nsIScrollableFrame::WHOLE;
 39248:       break;
 39248:     default:
 39248:       return NS_ERROR_INVALID_ARG;
 39248:   }
 39248: 
 80486:   aEvent->mSucceeded = true;
 39248: 
 39248:   nsIScrollableFrame* sf =
 39248:     ps->GetFrameToScrollAsScrollable(nsIPresShell::eEither);
108058:   aEvent->mIsEnabled = sf ?
108058:     (aEvent->mScroll.mIsHorizontal ?
196021:       WheelHandlingUtils::CanScrollOn(sf, aEvent->mScroll.mAmount, 0) :
196021:       WheelHandlingUtils::CanScrollOn(sf, 0, aEvent->mScroll.mAmount)) : false;
 39248: 
 39248:   if (!aEvent->mIsEnabled || aEvent->mOnlyEnabledCheck) {
 39248:     return NS_OK;
 39248:   }
 39248: 
 39248:   nsIntPoint pt(0, 0);
 39248:   if (aEvent->mScroll.mIsHorizontal) {
 39248:     pt.x = aEvent->mScroll.mAmount;
 39248:   } else {
 39248:     pt.y = aEvent->mScroll.mAmount;
 39248:   }
 39248: 
 39248:   // The caller may want synchronous scrolling.
 39248:   sf->ScrollBy(pt, scrollUnit, nsIScrollableFrame::INSTANT);
 39248:   return NS_OK;
 39248: }
 54151: 
 54151: void
196025: EventStateManager::DoQuerySelectedText(WidgetQueryContentEvent* aEvent)
 78622: {
 78622:   if (RemoteQueryContentEvent(aEvent)) {
 78622:     return;
 78622:   }
191142:   ContentEventHandler handler(mPresContext);
 78622:   handler.OnQuerySelectedText(aEvent);
 78622: }
 78622: 
 78622: void
196025: EventStateManager::SetActiveManager(EventStateManager* aNewESM,
 54151:                                     nsIContent* aContent)
 54151: {
 54151:   if (sActiveESM && aNewESM != sActiveESM) {
106838:     sActiveESM->SetContentState(nullptr, NS_EVENT_STATE_ACTIVE);
 54151:   }
 54151:   sActiveESM = aNewESM;
 56644:   if (sActiveESM && aContent) {
 54151:     sActiveESM->SetContentState(aContent, NS_EVENT_STATE_ACTIVE);
 54151:   }
 54151: }
 55892: 
 55892: void
196025: EventStateManager::ClearGlobalActiveContent(EventStateManager* aClearer)
 55892: {
 56644:   if (aClearer) {
106838:     aClearer->SetContentState(nullptr, NS_EVENT_STATE_ACTIVE);
 79435:     if (sDragOverContent) {
106838:       aClearer->SetContentState(nullptr, NS_EVENT_STATE_DRAGOVER);
 79435:     }
 56644:   }
 56644:   if (sActiveESM && aClearer != sActiveESM) {
106838:     sActiveESM->SetContentState(nullptr, NS_EVENT_STATE_ACTIVE);
106838:   }
106838:   sActiveESM = nullptr;
106838: }
108052: 
108054: /******************************************************************/
196025: /* mozilla::EventStateManager::DeltaAccumulator                   */
108054: /******************************************************************/
108054: 
108054: void
196025: EventStateManager::DeltaAccumulator::InitLineOrPageDelta(
108054:                                        nsIFrame* aTargetFrame,
196025:                                        EventStateManager* aESM,
165701:                                        WidgetWheelEvent* aEvent)
108054: {
108054:   MOZ_ASSERT(aESM);
108054:   MOZ_ASSERT(aEvent);
108061: 
108061:   // Reset if the previous wheel event is too old.
108054:   if (!mLastTime.IsNull()) {
108054:     TimeDuration duration = TimeStamp::Now() - mLastTime;
196023:     if (duration.ToMilliseconds() > WheelTransaction::GetTimeoutTime()) {
108054:       Reset();
108054:     }
108054:   }
108061:   // If we have accumulated delta,  we may need to reset it.
108743:   if (IsInTransaction()) {
108061:     // If wheel event type is changed, reset the values.
108061:     if (mHandlingDeltaMode != aEvent->deltaMode ||
214586:         mIsNoLineOrPageDeltaDevice != aEvent->mIsNoLineOrPageDelta) {
108061:       Reset();
108061:     } else {
108061:       // If the delta direction is changed, we should reset only the
108061:       // accumulated values.
108061:       if (mX && aEvent->deltaX && ((aEvent->deltaX > 0.0) != (mX > 0.0))) {
108743:         mX = mPendingScrollAmountX = 0.0;
108061:       }
108061:       if (mY && aEvent->deltaY && ((aEvent->deltaY > 0.0) != (mY > 0.0))) {
108743:         mY = mPendingScrollAmountY = 0.0;
108061:       }
108061:     }
108061:   }
108061: 
108061:   mHandlingDeltaMode = aEvent->deltaMode;
214586:   mIsNoLineOrPageDeltaDevice = aEvent->mIsNoLineOrPageDelta;
214586: 
214586:   // If it's handling neither a device that does not provide line or page deltas
214586:   // nor delta values multiplied by prefs, we must not modify lineOrPageDelta
108743:   // values.
214586:   if (!mIsNoLineOrPageDeltaDevice &&
196025:       !EventStateManager::WheelPrefs::GetInstance()->
108743:         NeedToComputeLineOrPageDelta(aEvent)) {
108743:     // Set the delta values to mX and mY.  They would be used when above block
108743:     // resets mX/mY/mPendingScrollAmountX/mPendingScrollAmountY if the direction
108743:     // is changed.
108743:     // NOTE: We shouldn't accumulate the delta values, it might could cause
108743:     //       overflow even though it's not a realistic situation.
108743:     if (aEvent->deltaX) {
108743:       mX = aEvent->deltaX;
108743:     }
108743:     if (aEvent->deltaY) {
108743:       mY = aEvent->deltaY;
108743:     }
108743:     mLastTime = TimeStamp::Now();
108743:     return;
108743:   }
108743: 
108061:   mX += aEvent->deltaX;
108061:   mY += aEvent->deltaY;
108061: 
108061:   if (mHandlingDeltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL) {
108061:     // Records pixel delta values and init lineOrPageDeltaX and
108061:     // lineOrPageDeltaY for wheel events which are caused by pixel only
108061:     // devices.  Ignore mouse wheel transaction for computing this.  The
108061:     // lineOrPageDelta values will be used by dispatching legacy
220551:     // eMouseScrollEventClass (DOMMouseScroll) but not be used for scrolling
108061:     // of default action.  The transaction should be used only for the default
108061:     // action.
108061:     nsIScrollableFrame* scrollTarget =
111054:       aESM->ComputeScrollTarget(aTargetFrame, aEvent,
111054:                                 COMPUTE_LEGACY_MOUSE_SCROLL_EVENT_TARGET);
108061:     nsIFrame* frame = do_QueryFrame(scrollTarget);
108061:     nsPresContext* pc =
108061:       frame ? frame->PresContext() : aTargetFrame->PresContext();
108061:     nsSize scrollAmount = aESM->GetScrollAmount(pc, aEvent, scrollTarget);
108061:     nsIntSize scrollAmountInCSSPixels(
108061:       nsPresContext::AppUnitsToIntCSSPixels(scrollAmount.width),
108061:       nsPresContext::AppUnitsToIntCSSPixels(scrollAmount.height));
108061: 
108061:     aEvent->lineOrPageDeltaX = RoundDown(mX) / scrollAmountInCSSPixels.width;
108061:     aEvent->lineOrPageDeltaY = RoundDown(mY) / scrollAmountInCSSPixels.height;
108061: 
108061:     mX -= aEvent->lineOrPageDeltaX * scrollAmountInCSSPixels.width;
108061:     mY -= aEvent->lineOrPageDeltaY * scrollAmountInCSSPixels.height;
108061:   } else {
108061:     aEvent->lineOrPageDeltaX = RoundDown(mX);
108061:     aEvent->lineOrPageDeltaY = RoundDown(mY);
108061:     mX -= aEvent->lineOrPageDeltaX;
108061:     mY -= aEvent->lineOrPageDeltaY;
108061:   }
108054: 
108054:   mLastTime = TimeStamp::Now();
108054: }
108054: 
108054: void
196025: EventStateManager::DeltaAccumulator::Reset()
108054: {
108061:   mX = mY = 0.0;
108743:   mPendingScrollAmountX = mPendingScrollAmountY = 0.0;
115367:   mHandlingDeltaMode = UINT32_MAX;
214586:   mIsNoLineOrPageDeltaDevice = false;
108054: }
108054: 
108743: nsIntPoint
196025: EventStateManager::DeltaAccumulator::ComputeScrollAmountForDefaultAction(
165701:                      WidgetWheelEvent* aEvent,
108743:                      const nsIntSize& aScrollAmountInDevPixels)
108743: {
108743:   MOZ_ASSERT(aEvent);
108743: 
108743:   // If the wheel event is line scroll and the delta value is computed from
108743:   // system settings, allow to override the system speed.
108743:   bool allowScrollSpeedOverride =
108743:     (!aEvent->customizedByUserPrefs &&
108743:      aEvent->deltaMode == nsIDOMWheelEvent::DOM_DELTA_LINE);
108743:   DeltaValues acceleratedDelta =
196023:     WheelTransaction::AccelerateWheelDelta(aEvent, allowScrollSpeedOverride);
108743: 
108743:   nsIntPoint result(0, 0);
108743:   if (aEvent->deltaMode == nsIDOMWheelEvent::DOM_DELTA_PIXEL) {
108743:     mPendingScrollAmountX += acceleratedDelta.deltaX;
108743:     mPendingScrollAmountY += acceleratedDelta.deltaY;
108743:   } else {
108743:     mPendingScrollAmountX +=
108743:       aScrollAmountInDevPixels.width * acceleratedDelta.deltaX;
108743:     mPendingScrollAmountY +=
108743:       aScrollAmountInDevPixels.height * acceleratedDelta.deltaY;
108743:   }
108743:   result.x = RoundDown(mPendingScrollAmountX);
108743:   result.y = RoundDown(mPendingScrollAmountY);
108743:   mPendingScrollAmountX -= result.x;
108743:   mPendingScrollAmountY -= result.y;
108743: 
108743:   return result;
108743: }
108743: 
108052: /******************************************************************/
196025: /* mozilla::EventStateManager::WheelPrefs                         */
108052: /******************************************************************/
108052: 
108052: // static
196025: EventStateManager::WheelPrefs*
196025: EventStateManager::WheelPrefs::GetInstance()
108052: {
108052:   if (!sInstance) {
108052:     sInstance = new WheelPrefs();
108052:   }
108052:   return sInstance;
108052: }
108052: 
108052: // static
108052: void
196025: EventStateManager::WheelPrefs::Shutdown()
108052: {
108052:   delete sInstance;
108052:   sInstance = nullptr;
108052: }
108052: 
108052: // static
176808: void
196025: EventStateManager::WheelPrefs::OnPrefChanged(const char* aPrefName,
108052:                                              void* aClosure)
108052: {
108052:   // forget all prefs, it's not problem for performance.
108052:   sInstance->Reset();
108061:   DeltaAccumulator::GetInstance()->Reset();
108052: }
108052: 
196025: EventStateManager::WheelPrefs::WheelPrefs()
108052: {
108052:   Reset();
108052:   Preferences::RegisterCallback(OnPrefChanged, "mousewheel.", nullptr);
108052: }
108052: 
196025: EventStateManager::WheelPrefs::~WheelPrefs()
108052: {
108052:   Preferences::UnregisterCallback(OnPrefChanged, "mousewheel.", nullptr);
108052: }
108052: 
108052: void
196025: EventStateManager::WheelPrefs::Reset()
108052: {
108052:   memset(mInit, 0, sizeof(mInit));
108052: 
108052: }
108052: 
196025: EventStateManager::WheelPrefs::Index
196025: EventStateManager::WheelPrefs::GetIndexFor(WidgetWheelEvent* aEvent)
108052: {
108053:   if (!aEvent) {
108053:     return INDEX_DEFAULT;
108053:   }
108053: 
161040:   Modifiers modifiers =
161040:     (aEvent->modifiers & (MODIFIER_ALT |
161040:                           MODIFIER_CONTROL |
161040:                           MODIFIER_META |
161040:                           MODIFIER_SHIFT |
161040:                           MODIFIER_OS));
108052: 
108052:   switch (modifiers) {
161040:     case MODIFIER_ALT:
108052:       return INDEX_ALT;
161040:     case MODIFIER_CONTROL:
108052:       return INDEX_CONTROL;
161040:     case MODIFIER_META:
108052:       return INDEX_META;
161040:     case MODIFIER_SHIFT:
108052:       return INDEX_SHIFT;
161040:     case MODIFIER_OS:
108052:       return INDEX_OS;
108052:     default:
108052:       // If two or more modifier keys are pressed, we should use default
108052:       // settings.
108052:       return INDEX_DEFAULT;
108052:   }
108052: }
108052: 
108052: void
196025: EventStateManager::WheelPrefs::GetBasePrefName(
196025:                      EventStateManager::WheelPrefs::Index aIndex,
108052:                      nsACString& aBasePrefName)
108052: {
108052:   aBasePrefName.AssignLiteral("mousewheel.");
108052:   switch (aIndex) {
108052:     case INDEX_ALT:
108053:       aBasePrefName.AppendLiteral("with_alt.");
108052:       break;
108052:     case INDEX_CONTROL:
108053:       aBasePrefName.AppendLiteral("with_control.");
108052:       break;
108052:     case INDEX_META:
108053:       aBasePrefName.AppendLiteral("with_meta.");
108052:       break;
108052:     case INDEX_SHIFT:
108053:       aBasePrefName.AppendLiteral("with_shift.");
108052:       break;
108052:     case INDEX_OS:
108053:       aBasePrefName.AppendLiteral("with_win.");
108052:       break;
108052:     case INDEX_DEFAULT:
108052:     default:
108053:       aBasePrefName.AppendLiteral("default.");
108052:       break;
108052:   }
108052: }
108052: 
108052: void
196025: EventStateManager::WheelPrefs::Init(EventStateManager::WheelPrefs::Index aIndex)
108052: {
108052:   if (mInit[aIndex]) {
108052:     return;
108052:   }
108052:   mInit[aIndex] = true;
108052: 
110974:   nsAutoCString basePrefName;
108052:   GetBasePrefName(aIndex, basePrefName);
108052: 
110974:   nsAutoCString prefNameX(basePrefName);
108052:   prefNameX.AppendLiteral("delta_multiplier_x");
108052:   mMultiplierX[aIndex] =
108052:     static_cast<double>(Preferences::GetInt(prefNameX.get(), 100)) / 100;
108052: 
110974:   nsAutoCString prefNameY(basePrefName);
108052:   prefNameY.AppendLiteral("delta_multiplier_y");
108052:   mMultiplierY[aIndex] =
108052:     static_cast<double>(Preferences::GetInt(prefNameY.get(), 100)) / 100;
108053: 
110974:   nsAutoCString prefNameZ(basePrefName);
108064:   prefNameZ.AppendLiteral("delta_multiplier_z");
108064:   mMultiplierZ[aIndex] =
108064:     static_cast<double>(Preferences::GetInt(prefNameZ.get(), 100)) / 100;
108064: 
110974:   nsAutoCString prefNameAction(basePrefName);
108053:   prefNameAction.AppendLiteral("action");
125268:   int32_t action = Preferences::GetInt(prefNameAction.get(), ACTION_SCROLL);
125304:   if (action < int32_t(ACTION_NONE) || action > int32_t(ACTION_LAST)) {
108053:     NS_WARNING("Unsupported action pref value, replaced with 'Scroll'.");
125268:     action = ACTION_SCROLL;
125268:   }
125268:   mActions[aIndex] = static_cast<Action>(action);
125268: 
125268:   // Compute action values overridden by .override_x pref.
125268:   // At present, override is possible only for the x-direction
125268:   // because this pref is introduced mainly for tilt wheels.
125268:   prefNameAction.AppendLiteral(".override_x");
125268:   int32_t actionOverrideX = Preferences::GetInt(prefNameAction.get(), -1);
125304:   if (actionOverrideX < -1 || actionOverrideX > int32_t(ACTION_LAST)) {
125268:     NS_WARNING("Unsupported action override pref value, didn't override.");
125268:     actionOverrideX = -1;
125268:   }
125268:   mOverriddenActionsX[aIndex] = (actionOverrideX == -1)
125268:                               ? static_cast<Action>(action)
125268:                               : static_cast<Action>(actionOverrideX);
108052: }
108052: 
108052: void
196025: EventStateManager::WheelPrefs::ApplyUserPrefsToDelta(WidgetWheelEvent* aEvent)
108052: {
108052:   Index index = GetIndexFor(aEvent);
108052:   Init(index);
108052: 
108059:   aEvent->deltaX *= mMultiplierX[index];
108059:   aEvent->deltaY *= mMultiplierY[index];
108064:   aEvent->deltaZ *= mMultiplierZ[index];
108059: 
108060:   // If the multiplier is 1.0 or -1.0, i.e., it doesn't change the absolute
108060:   // value, we should use lineOrPageDelta values which were set by widget.
108060:   // Otherwise, we need to compute them from accumulated delta values.
108064:   if (!NeedToComputeLineOrPageDelta(aEvent)) {
108991:     aEvent->lineOrPageDeltaX *= static_cast<int32_t>(mMultiplierX[index]);
108991:     aEvent->lineOrPageDeltaY *= static_cast<int32_t>(mMultiplierY[index]);
108060:   } else {
108060:     aEvent->lineOrPageDeltaX = 0;
108060:     aEvent->lineOrPageDeltaY = 0;
108060:   }
108060: 
108059:   aEvent->customizedByUserPrefs =
108064:     ((mMultiplierX[index] != 1.0) || (mMultiplierY[index] != 1.0) ||
108064:      (mMultiplierZ[index] != 1.0));
108052: }
108053: 
108066: void
196025: EventStateManager::WheelPrefs::CancelApplyingUserPrefsFromOverflowDelta(
165701:                                  WidgetWheelEvent* aEvent)
108066: {
108066:   Index index = GetIndexFor(aEvent);
108066:   Init(index);
108066: 
110714:   // XXX If the multiplier pref value is negative, the scroll direction was
110714:   //     changed and caused to scroll different direction.  In such case,
110714:   //     this method reverts the sign of overflowDelta.  Does it make widget
110714:   //     happy?  Although, widget can know the pref applied delta values by
110714:   //     referrencing the deltaX and deltaY of the event.
110714: 
108588:   if (mMultiplierX[index]) {
108066:     aEvent->overflowDeltaX /= mMultiplierX[index];
108588:   }
108588:   if (mMultiplierY[index]) {
108066:     aEvent->overflowDeltaY /= mMultiplierY[index];
108066:   }
108588: }
108066: 
196025: EventStateManager::WheelPrefs::Action
196025: EventStateManager::WheelPrefs::ComputeActionFor(WidgetWheelEvent* aEvent)
108053: {
108053:   Index index = GetIndexFor(aEvent);
108053:   Init(index);
108062: 
125268:   bool deltaXPreferred =
135923:     (Abs(aEvent->deltaX) > Abs(aEvent->deltaY) &&
135923:      Abs(aEvent->deltaX) > Abs(aEvent->deltaZ));
125268:   Action* actions = deltaXPreferred ? mOverriddenActionsX : mActions;
125268:   if (actions[index] == ACTION_NONE || actions[index] == ACTION_SCROLL) {
125268:     return actions[index];
108053:   }
108061: 
108062:   // Momentum events shouldn't run special actions.
108062:   if (aEvent->isMomentum) {
108062:     // Use the default action.  Note that user might kill the wheel scrolling.
108062:     Init(INDEX_DEFAULT);
125268:     return (actions[INDEX_DEFAULT] == ACTION_SCROLL) ? ACTION_SCROLL :
108062:                                                        ACTION_NONE;
108062:   }
108062: 
127591:   return actions[index];
108062: }
108062: 
108061: bool
196025: EventStateManager::WheelPrefs::NeedToComputeLineOrPageDelta(
165701:                                  WidgetWheelEvent* aEvent)
108061: {
108061:   Index index = GetIndexFor(aEvent);
108061:   Init(index);
108061: 
108061:   return (mMultiplierX[index] != 1.0 && mMultiplierX[index] != -1.0) ||
108061:          (mMultiplierY[index] != 1.0 && mMultiplierY[index] != -1.0);
108061: }
120483: 
120483: bool
196025: EventStateManager::WheelPrefs::IsOverOnePageScrollAllowedX(
165701:                                  WidgetWheelEvent* aEvent)
120483: {
120483:   Index index = GetIndexFor(aEvent);
120483:   Init(index);
135923:   return Abs(mMultiplierX[index]) >=
120483:            MIN_MULTIPLIER_VALUE_ALLOWING_OVER_ONE_PAGE_SCROLL;
120483: }
120483: 
120483: bool
196025: EventStateManager::WheelPrefs::IsOverOnePageScrollAllowedY(
165701:                                  WidgetWheelEvent* aEvent)
120483: {
120483:   Index index = GetIndexFor(aEvent);
120483:   Init(index);
135923:   return Abs(mMultiplierY[index]) >=
120483:            MIN_MULTIPLIER_VALUE_ALLOWING_OVER_ONE_PAGE_SCROLL;
120483: }
157647: 
157647: /******************************************************************/
196025: /* mozilla::EventStateManager::Prefs                              */
157647: /******************************************************************/
157647: 
196025: bool EventStateManager::Prefs::sKeyCausesActivation = true;
196025: bool EventStateManager::Prefs::sClickHoldContextMenu = false;
196025: int32_t EventStateManager::Prefs::sGenericAccessModifierKey = -1;
196025: int32_t EventStateManager::Prefs::sChromeAccessModifierMask = 0;
196025: int32_t EventStateManager::Prefs::sContentAccessModifierMask = 0;
157647: 
157647: // static
157647: void
196025: EventStateManager::Prefs::Init()
157647: {
248969:   DebugOnly<nsresult> rv = Preferences::RegisterCallback(OnChange, "dom.popup_allowed_events");
248969:   MOZ_ASSERT(NS_SUCCEEDED(rv),
248969:              "Failed to observe \"dom.popup_allowed_events\"");
248969: 
248969:   static bool sPrefsAlreadyCached = false;
248969:   if (sPrefsAlreadyCached) {
248969:     return;
248969:   }
248969: 
248969:   rv = Preferences::AddBoolVarCache(&sKeyCausesActivation,
157647:                                     "accessibility.accesskeycausesactivation",
157647:                                     sKeyCausesActivation);
157647:   MOZ_ASSERT(NS_SUCCEEDED(rv),
157647:              "Failed to observe \"accessibility.accesskeycausesactivation\"");
157647:   rv = Preferences::AddBoolVarCache(&sClickHoldContextMenu,
157647:                                     "ui.click_hold_context_menus",
157647:                                     sClickHoldContextMenu);
157647:   MOZ_ASSERT(NS_SUCCEEDED(rv),
157647:              "Failed to observe \"ui.click_hold_context_menus\"");
157648:   rv = Preferences::AddIntVarCache(&sGenericAccessModifierKey,
157648:                                    "ui.key.generalAccessKey",
157648:                                    sGenericAccessModifierKey);
157647:   MOZ_ASSERT(NS_SUCCEEDED(rv),
157647:              "Failed to observe \"ui.key.generalAccessKey\"");
157648:   rv = Preferences::AddIntVarCache(&sChromeAccessModifierMask,
157648:                                    "ui.key.chromeAccess",
157648:                                    sChromeAccessModifierMask);
157647:   MOZ_ASSERT(NS_SUCCEEDED(rv),
157647:              "Failed to observe \"ui.key.chromeAccess\"");
157648:   rv = Preferences::AddIntVarCache(&sContentAccessModifierMask,
157648:                                    "ui.key.contentAccess",
157648:                                    sContentAccessModifierMask);
157647:   MOZ_ASSERT(NS_SUCCEEDED(rv),
157647:              "Failed to observe \"ui.key.contentAccess\"");
248969:   sPrefsAlreadyCached = true;
157647: }
157647: 
157647: // static
176808: void
196025: EventStateManager::Prefs::OnChange(const char* aPrefName, void*)
157647: {
157647:   nsDependentCString prefName(aPrefName);
157648:   if (prefName.EqualsLiteral("dom.popup_allowed_events")) {
190116:     Event::PopupAllowedEventsChanged();
157647:   }
157647: }
157647: 
157647: // static
157647: void
196025: EventStateManager::Prefs::Shutdown()
157647: {
157647:   Preferences::UnregisterCallback(OnChange, "dom.popup_allowed_events");
157647: }
157648: 
157648: // static
157648: int32_t
196025: EventStateManager::Prefs::ChromeAccessModifierMask()
157648: {
157648:   return GetAccessModifierMask(nsIDocShellTreeItem::typeChrome);
157648: }
157648: 
157648: // static
157648: int32_t
196025: EventStateManager::Prefs::ContentAccessModifierMask()
157648: {
157648:   return GetAccessModifierMask(nsIDocShellTreeItem::typeContent);
157648: }
157648: 
157648: // static
157648: int32_t
196025: EventStateManager::Prefs::GetAccessModifierMask(int32_t aItemType)
157648: {
157648:   switch (sGenericAccessModifierKey) {
157648:     case -1:                             break; // use the individual prefs
157648:     case nsIDOMKeyEvent::DOM_VK_SHIFT:   return NS_MODIFIER_SHIFT;
157648:     case nsIDOMKeyEvent::DOM_VK_CONTROL: return NS_MODIFIER_CONTROL;
157648:     case nsIDOMKeyEvent::DOM_VK_ALT:     return NS_MODIFIER_ALT;
157648:     case nsIDOMKeyEvent::DOM_VK_META:    return NS_MODIFIER_META;
157648:     case nsIDOMKeyEvent::DOM_VK_WIN:     return NS_MODIFIER_OS;
157648:     default:                             return 0;
157648:   }
157648: 
157648:   switch (aItemType) {
157648:     case nsIDocShellTreeItem::typeChrome:
157648:       return sChromeAccessModifierMask;
157648:     case nsIDocShellTreeItem::typeContent:
157648:       return sContentAccessModifierMask;
157648:     default:
157648:       return 0;
157648:   }
157648: }
157648: 
166503: /******************************************************************/
166503: /* mozilla::AutoHandlingUserInputStatePusher                      */
166503: /******************************************************************/
166503: 
166503: AutoHandlingUserInputStatePusher::AutoHandlingUserInputStatePusher(
166503:                                     bool aIsHandlingUserInput,
166503:                                     WidgetEvent* aEvent,
166503:                                     nsIDocument* aDocument) :
166503:   mIsHandlingUserInput(aIsHandlingUserInput),
166503:   mIsMouseDown(aEvent && aEvent->message == NS_MOUSE_BUTTON_DOWN),
211177:   mResetFMMouseButtonHandlingState(false)
166503: {
166503:   if (!aIsHandlingUserInput) {
166503:     return;
166503:   }
196025:   EventStateManager::StartHandlingUserInput();
211177:   if (mIsMouseDown) {
166503:     nsIPresShell::SetCapturingContent(nullptr, 0);
166503:     nsIPresShell::AllowMouseCapture(true);
211177:   }
211177:   if (!aDocument || !aEvent || !aEvent->mFlags.mIsTrusted) {
166503:     return;
166503:   }
211177:   mResetFMMouseButtonHandlingState = (aEvent->message == NS_MOUSE_BUTTON_DOWN ||
211177:                                       aEvent->message == NS_MOUSE_BUTTON_UP);
211177:   if (mResetFMMouseButtonHandlingState) {
166503:     nsFocusManager* fm = nsFocusManager::GetFocusManager();
166503:     NS_ENSURE_TRUE_VOID(fm);
211179:     // If it's in modal state, mouse button event handling may be nested.
211179:     // E.g., a modal dialog is opened at mousedown or mouseup event handler
211179:     // and the dialog is clicked.  Therefore, we should store current
211179:     // mouse button event handling document if nsFocusManager already has it.
211179:     mMouseButtonEventHandlingDocument =
211177:       fm->SetMouseButtonHandlingDocument(aDocument);
211177:   }
166503: }
166503: 
166503: AutoHandlingUserInputStatePusher::~AutoHandlingUserInputStatePusher()
166503: {
166503:   if (!mIsHandlingUserInput) {
166503:     return;
166503:   }
196025:   EventStateManager::StopHandlingUserInput();
211177:   if (mIsMouseDown) {
166503:     nsIPresShell::AllowMouseCapture(false);
211177:   }
211177:   if (mResetFMMouseButtonHandlingState) {
166503:     nsFocusManager* fm = nsFocusManager::GetFocusManager();
166503:     NS_ENSURE_TRUE_VOID(fm);
211179:     nsCOMPtr<nsIDocument> handlingDocument =
211179:       fm->SetMouseButtonHandlingDocument(mMouseButtonEventHandlingDocument);
211177:   }
166503: }
166503: 
196025: } // namespace mozilla
196025: 
