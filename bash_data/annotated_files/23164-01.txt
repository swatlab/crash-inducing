    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 1574: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is 
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Henri Sivonen <hsivonen@iki.fi>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for the XML and HTML content sinks, which construct a
    1:  * DOM based on information from the parser.
    1:  */
    1: 
    1: #include "nsContentSink.h"
    1: #include "nsScriptLoader.h"
    1: #include "nsIDocument.h"
 3942: #include "nsIDOMDocument.h"
    1: #include "nsICSSLoader.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsStyleLinkElement.h"
    1: #include "nsINodeInfo.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsCPrefetchService.h"
    1: #include "nsIURI.h"
    1: #include "nsNetUtil.h"
    1: #include "nsIHttpChannel.h"
    1: #include "nsIContent.h"
    1: #include "nsIScriptElement.h"
    1: #include "nsIParser.h"
    1: #include "nsContentErrors.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsIAtom.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIDOMWindowInternal.h"
    1: #include "nsIPrincipal.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsNetCID.h"
 3942: #include "nsIOfflineCacheUpdate.h"
18430: #include "nsIApplicationCache.h"
18430: #include "nsIApplicationCacheContainer.h"
21311: #include "nsIApplicationCacheChannel.h"
18488: #include "nsIApplicationCacheService.h"
10340: #include "nsIScriptSecurityManager.h"
 3942: #include "nsIDOMLoadStatus.h"
    1: #include "nsICookieService.h"
    1: #include "nsIPrompt.h"
    1: #include "nsServiceManagerUtils.h"
    1: #include "nsContentUtils.h"
    1: #include "nsParserUtils.h"
    1: #include "nsCRT.h"
    1: #include "nsEscape.h"
    1: #include "nsWeakReference.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsNodeInfoManager.h"
    1: #include "nsTimer.h"
    1: #include "nsIAppShell.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIDOMNSDocument.h"
    1: #include "nsIRequest.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsThreadUtils.h"
 1722: #include "nsPresShellIterator.h"
10340: #include "nsPIDOMWindow.h"
14228: #include "mozAutoDocUpdate.h"
18488: #include "nsIWebNavigation.h"
18488: #include "nsIDocumentLoader.h"
18488: #include "nsICachingChannel.h"
18488: #include "nsICacheEntryDescriptor.h"
21577: #include "nsGenericHTMLElement.h"
21577: #include "nsHTMLDNSPrefetch.h"
    1: 
    1: PRLogModuleInfo* gContentSinkLogModuleInfo;
    1: 
    1: class nsScriptLoaderObserverProxy : public nsIScriptLoaderObserver
    1: {
    1: public:
    1:   nsScriptLoaderObserverProxy(nsIScriptLoaderObserver* aInner)
    1:     : mInner(do_GetWeakReference(aInner))
    1:   {
    1:   }
    1:   virtual ~nsScriptLoaderObserverProxy()
    1:   {
    1:   }
    1:   
    1:   NS_DECL_ISUPPORTS
    1:   NS_DECL_NSISCRIPTLOADEROBSERVER
    1: 
    1:   nsWeakPtr mInner;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(nsScriptLoaderObserverProxy, nsIScriptLoaderObserver)
    1: 
    1: NS_IMETHODIMP
    1: nsScriptLoaderObserverProxy::ScriptAvailable(nsresult aResult,
    1:                                              nsIScriptElement *aElement,
    1:                                              PRBool aIsInline,
    1:                                              nsIURI *aURI,
    1:                                              PRInt32 aLineNo)
    1: {
    1:   nsCOMPtr<nsIScriptLoaderObserver> inner = do_QueryReferent(mInner);
    1: 
    1:   if (inner) {
    1:     return inner->ScriptAvailable(aResult, aElement, aIsInline, aURI,
    1:                                   aLineNo);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsScriptLoaderObserverProxy::ScriptEvaluated(nsresult aResult,
    1:                                              nsIScriptElement *aElement,
    1:                                              PRBool aIsInline)
    1: {
    1:   nsCOMPtr<nsIScriptLoaderObserver> inner = do_QueryReferent(mInner);
    1: 
    1:   if (inner) {
    1:     return inner->ScriptEvaluated(aResult, aElement, aIsInline);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
11423: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsContentSink)
11423: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsContentSink)
11423: 
11423: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsContentSink)
11423:   NS_INTERFACE_MAP_ENTRY(nsICSSLoaderObserver)
11423:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
11423:   NS_INTERFACE_MAP_ENTRY(nsIScriptLoaderObserver)
12587:   NS_INTERFACE_MAP_ENTRY(nsIDocumentObserver)
12587:   NS_INTERFACE_MAP_ENTRY(nsIMutationObserver)
12587:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
11423:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIScriptLoaderObserver)
11423: NS_INTERFACE_MAP_END
11423: 
12587: NS_IMPL_CYCLE_COLLECTION_CLASS(nsContentSink)
12587: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsContentSink)
12587:   if (tmp->mDocument) {
12587:     tmp->mDocument->RemoveObserver(tmp);
12587:   }
12587:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument)
12587:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mParser)
13669:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mNodeInfoManager)
12587: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
12587: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsContentSink)
12587:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument)
12587:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mParser)
13669:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mNodeInfoManager,
13669:                                                   nsNodeInfoManager)
12587: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
12587: 
    1: 
    1: nsContentSink::nsContentSink()
    1: {
    1:   // We have a zeroing operator new
    1:   NS_ASSERTION(mLayoutStarted == PR_FALSE, "What?");
    1:   NS_ASSERTION(mDynamicLowerValue == PR_FALSE, "What?");
    1:   NS_ASSERTION(mParsing == PR_FALSE, "What?");
    1:   NS_ASSERTION(mLastSampledUserEventTime == 0, "What?");
    1:   NS_ASSERTION(mDeflectedCount == 0, "What?");
    1:   NS_ASSERTION(mDroppedTimer == PR_FALSE, "What?");
    1:   NS_ASSERTION(mInMonolithicContainer == 0, "What?");
    1:   NS_ASSERTION(mInNotification == 0, "What?");
  681:   NS_ASSERTION(mDeferredLayoutStart == PR_FALSE, "What?");
    1: 
    1: #ifdef NS_DEBUG
    1:   if (!gContentSinkLogModuleInfo) {
    1:     gContentSinkLogModuleInfo = PR_NewLogModule("nscontentsink");
    1:   }
    1: #endif
    1: }
    1: 
    1: nsContentSink::~nsContentSink()
    1: {
12587:   if (mDocument) {
12587:     // Remove ourselves just to be safe, though we really should have
12587:     // been removed in DidBuildModel if everything worked right.
12587:     mDocument->RemoveObserver(this);
12587:   }
    1: }
    1: 
    1: nsresult
    1: nsContentSink::Init(nsIDocument* aDoc,
    1:                     nsIURI* aURI,
    1:                     nsISupports* aContainer,
    1:                     nsIChannel* aChannel)
    1: {
    1:   NS_PRECONDITION(aDoc, "null ptr");
    1:   NS_PRECONDITION(aURI, "null ptr");
    1: 
    1:   if (!aDoc || !aURI) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   mDocument = aDoc;
    1: 
    1:   mDocumentURI = aURI;
    1:   mDocumentBaseURI = aURI;
    1:   mDocShell = do_QueryInterface(aContainer);
    1:   if (mDocShell) {
    1:     PRUint32 loadType = 0;
    1:     mDocShell->GetLoadType(&loadType);
    1:     mChangeScrollPosWhenScrollingToRef =
    1:       ((loadType & nsIDocShell::LOAD_CMD_HISTORY) == 0);
    1:   }
    1: 
    1:   // use this to avoid a circular reference sink->document->scriptloader->sink
    1:   nsCOMPtr<nsIScriptLoaderObserver> proxy =
    1:       new nsScriptLoaderObserverProxy(this);
    1:   NS_ENSURE_TRUE(proxy, NS_ERROR_OUT_OF_MEMORY);
    1: 
 2007:   mScriptLoader = mDocument->ScriptLoader();
  681:   mScriptLoader->AddObserver(proxy);
    1: 
    1:   mCSSLoader = aDoc->CSSLoader();
    1: 
    1:   ProcessHTTPHeaders(aChannel);
    1: 
    1:   mNodeInfoManager = aDoc->NodeInfoManager();
    1: 
    1:   mNotifyOnTimer =
    1:     nsContentUtils::GetBoolPref("content.notify.ontimer", PR_TRUE);
    1: 
    1:   // -1 means never
    1:   mBackoffCount =
    1:     nsContentUtils::GetIntPref("content.notify.backoffcount", -1);
    1: 
    1:   // The mNotificationInterval has a dramatic effect on how long it
    1:   // takes to initially display content for slow connections.
    1:   // The current value provides good
    1:   // incremental display of content without causing an increase
    1:   // in page load time. If this value is set below 1/10 of second
    1:   // it starts to impact page load performance.
    1:   // see bugzilla bug 72138 for more info.
    1:   mNotificationInterval =
    1:     nsContentUtils::GetIntPref("content.notify.interval", 120000);
    1: 
    1:   // The mMaxTokenProcessingTime controls how long we stay away from
    1:   // the event loop when processing token. A lower value makes the app
    1:   // more responsive, but may increase page load time.  The content
    1:   // sink mNotificationInterval gates how frequently the content is
    1:   // processed so it will also affect how interactive the app is
    1:   // during page load also. The mNotification prevents contents
    1:   // flushes from happening too frequently. while
    1:   // mMaxTokenProcessingTime prevents flushes from happening too
    1:   // infrequently.
    1: 
    1:   // The current ratio of 3 to 1 was determined to be the lowest
    1:   // mMaxTokenProcessingTime which does not impact page load
    1:   // performance.  See bugzilla bug 76722 for details.
    1: 
    1:   mMaxTokenProcessingTime =
    1:     nsContentUtils::GetIntPref("content.max.tokenizing.time",
    1:                                mNotificationInterval * 3);
    1: 
    1:   // 3/4 second (750000us) default for switching
    1:   mDynamicIntervalSwitchThreshold =
    1:     nsContentUtils::GetIntPref("content.switch.threshold", 750000);
    1: 
    1:   mCanInterruptParser =
    1:     nsContentUtils::GetBoolPref("content.interrupt.parsing", PR_TRUE);
    1: 
    1:   return NS_OK;
    1: 
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsContentSink::StyleSheetLoaded(nsICSSStyleSheet* aSheet,
    1:                                 PRBool aWasAlternate,
    1:                                 nsresult aStatus)
    1: {
  681:   if (!aWasAlternate) {
  681:     NS_ASSERTION(mPendingSheetCount > 0, "How'd that happen?");
  681:     --mPendingSheetCount;
  681: 
 3317:     if (mPendingSheetCount == 0 &&
 3317:         (mDeferredLayoutStart || mDeferredFlushTags)) {
 3317:       if (mDeferredFlushTags) {
 3317:         FlushTags();
 3317:       }
 3317:       if (mDeferredLayoutStart) {
  681:         // We might not have really started layout, since this sheet was still
  681:         // loading.  Do it now.  Probably doesn't matter whether we do this
 3317:         // before or after we unblock scripts, but before feels saner.  Note
 3317:         // that if mDeferredLayoutStart is true, that means any subclass
 3317:         // StartLayout() stuff that needs to happen has already happened, so we
 3317:         // don't need to worry about it.
  681:         StartLayout(PR_FALSE);
 3317:       }
  681: 
  681:       // Go ahead and try to scroll to our ref if we have one
12356:       ScrollToRef();
  681:     }
  681:     
  681:     mScriptLoader->RemoveExecuteBlocker();
  681:   }
  681: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsContentSink::ScriptAvailable(nsresult aResult,
    1:                                nsIScriptElement *aElement,
    1:                                PRBool aIsInline,
    1:                                nsIURI *aURI,
    1:                                PRInt32 aLineNo)
    1: {
    1:   PRUint32 count = mScriptElements.Count();
22702:   if (mParser && NS_SUCCEEDED(aResult)) {
22702:     // Only notify the parser about scripts that are actually going to run.
22702:     mParser->ScriptExecuting();
22702:   }
    1: 
    1:   if (count == 0) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // aElement will not be in mScriptElements if a <script> was added
    1:   // using the DOM during loading, or if the script was inline and thus
    1:   // never blocked.
    1:   NS_ASSERTION(mScriptElements.IndexOf(aElement) == count - 1 ||
    1:                mScriptElements.IndexOf(aElement) == PRUint32(-1),
    1:                "script found at unexpected position");
    1: 
    1:   // Check if this is the element we were waiting for
    1:   if (aElement != mScriptElements[count - 1]) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (mParser && !mParser->IsParserEnabled()) {
    1:     // make sure to unblock the parser before evaluating the script,
    1:     // we must unblock the parser even if loading the script failed or
    1:     // if the script was empty, if we don't, the parser will never be
    1:     // unblocked.
    1:     mParser->UnblockParser();
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(aResult)) {
    1:     PreEvaluateScript();
    1:   } else {
    1:     mScriptElements.RemoveObjectAt(count - 1);
    1: 
    1:     if (mParser && aResult != NS_BINDING_ABORTED) {
    1:       // Loading external script failed!. So, resume parsing since the parser
    1:       // got blocked when loading external script. See
    1:       // http://bugzilla.mozilla.org/show_bug.cgi?id=94903.
    1:       //
    1:       // XXX We don't resume parsing if we get NS_BINDING_ABORTED from the
    1:       //     script load, assuming that that error code means that the user
    1:       //     stopped the load through some action (like clicking a link). See
    1:       //     http://bugzilla.mozilla.org/show_bug.cgi?id=243392.
    1:       ContinueInterruptedParsingAsync();
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsContentSink::ScriptEvaluated(nsresult aResult,
    1:                                nsIScriptElement *aElement,
    1:                                PRBool aIsInline)
    1: {
22702:   if (mParser) {
22702:     mParser->ScriptDidExecute();
22702:   }
22702: 
    1:   // Check if this is the element we were waiting for
    1:   PRInt32 count = mScriptElements.Count();
22702:   if (count == 0 || aElement != mScriptElements[count - 1]) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Pop the script element stack
    1:   mScriptElements.RemoveObjectAt(count - 1); 
    1: 
    1:   if (NS_SUCCEEDED(aResult)) {
    1:     PostEvaluateScript(aElement);
    1:   }
    1: 
    1:   if (mParser && mParser->IsParserEnabled()) {
    1:     ContinueInterruptedParsingAsync();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsContentSink::ProcessHTTPHeaders(nsIChannel* aChannel)
    1: {
    1:   nsCOMPtr<nsIHttpChannel> httpchannel(do_QueryInterface(aChannel));
    1:   
    1:   if (!httpchannel) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Note that the only header we care about is the "link" header, since we
    1:   // have all the infrastructure for kicking off stylesheet loads.
    1:   
    1:   nsCAutoString linkHeader;
    1:   
    1:   nsresult rv = httpchannel->GetResponseHeader(NS_LITERAL_CSTRING("link"),
    1:                                                linkHeader);
    1:   if (NS_SUCCEEDED(rv) && !linkHeader.IsEmpty()) {
    1:     ProcessHeaderData(nsGkAtoms::link,
    1:                       NS_ConvertASCIItoUTF16(linkHeader));
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsContentSink::ProcessHeaderData(nsIAtom* aHeader, const nsAString& aValue,
    1:                                  nsIContent* aContent)
    1: {
    1:   nsresult rv = NS_OK;
    1:   // necko doesn't process headers coming in from the parser
    1: 
    1:   mDocument->SetHeaderData(aHeader, aValue);
    1: 
    1:   if (aHeader == nsGkAtoms::setcookie) {
    1:     // Note: Necko already handles cookies set via the channel.  We can't just
    1:     // call SetCookie on the channel because we want to do some security checks
    1:     // here and want to use the prompt associated to our current window, not
    1:     // the window where the channel was dispatched.
    1:     nsCOMPtr<nsICookieService> cookieServ =
    1:       do_GetService(NS_COOKIESERVICE_CONTRACTID, &rv);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
    1:     // Get a URI from the document principal
    1: 
    1:     // We use the original codebase in case the codebase was changed
    1:     // by SetDomain
    1: 
    1:     // Note that a non-codebase principal (eg the system principal) will return
    1:     // a null URI.
    1:     nsCOMPtr<nsIURI> codebaseURI;
    1:     rv = mDocument->NodePrincipal()->GetURI(getter_AddRefs(codebaseURI));
    1:     NS_ENSURE_TRUE(codebaseURI, rv);
    1: 
    1:     nsCOMPtr<nsIPrompt> prompt;
    1:     nsCOMPtr<nsIDOMWindowInternal> window (do_QueryInterface(mDocument->GetScriptGlobalObject()));
    1:     if (window) {
    1:       window->GetPrompter(getter_AddRefs(prompt));
    1:     }
    1: 
    1:     nsCOMPtr<nsIChannel> channel;
    1:     if (mParser) {
    1:       mParser->GetChannel(getter_AddRefs(channel));
    1:     }
    1: 
    1:     rv = cookieServ->SetCookieString(codebaseURI,
    1:                                      prompt,
    1:                                      NS_ConvertUTF16toUTF8(aValue).get(),
    1:                                      channel);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1:   }
    1:   else if (aHeader == nsGkAtoms::link) {
    1:     rv = ProcessLinkHeader(aContent, aValue);
    1:   }
    1:   else if (aHeader == nsGkAtoms::msthemecompatible) {
    1:     // Disable theming for the presshell if the value is no.
    1:     // XXXbz don't we want to support this as an HTTP header too?
    1:     nsAutoString value(aValue);
    1:     if (value.LowerCaseEqualsLiteral("no")) {
  981:       nsIPresShell* shell = mDocument->GetPrimaryShell();
    1:       if (shell) {
    1:         shell->DisableThemeSupport();
    1:       }
    1:     }
    1:   }
    1:   // Don't report "refresh" headers back to necko, since our document handles
    1:   // them
    1:   else if (aHeader != nsGkAtoms::refresh && mParser) {
    1:     // we also need to report back HTTP-EQUIV headers to the channel
    1:     // so that it can process things like pragma: no-cache or other
    1:     // cache-control headers. Ideally this should also be the way for
    1:     // cookies to be set! But we'll worry about that in the next
    1:     // iteration
    1:     nsCOMPtr<nsIChannel> channel;
    1:     if (NS_SUCCEEDED(mParser->GetChannel(getter_AddRefs(channel)))) {
    1:       nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(channel));
    1:       if (httpChannel) {
    1:         const char* header;
    1:         (void)aHeader->GetUTF8String(&header);
    1:         (void)httpChannel->SetResponseHeader(nsDependentCString(header),
    1:                                              NS_ConvertUTF16toUTF8(aValue),
    1:                                              PR_TRUE);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: static const PRUnichar kSemiCh = PRUnichar(';');
    1: static const PRUnichar kCommaCh = PRUnichar(',');
    1: static const PRUnichar kEqualsCh = PRUnichar('=');
    1: static const PRUnichar kLessThanCh = PRUnichar('<');
    1: static const PRUnichar kGreaterThanCh = PRUnichar('>');
    1: 
    1: nsresult
    1: nsContentSink::ProcessLinkHeader(nsIContent* aElement,
    1:                                  const nsAString& aLinkData)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1:   // parse link content and call process style link
    1:   nsAutoString href;
    1:   nsAutoString rel;
    1:   nsAutoString title;
    1:   nsAutoString type;
    1:   nsAutoString media;
    1: 
    1:   // copy to work buffer
    1:   nsAutoString stringList(aLinkData);
    1: 
    1:   // put an extra null at the end
    1:   stringList.Append(kNullCh);
    1: 
    1:   PRUnichar* start = stringList.BeginWriting();
    1:   PRUnichar* end   = start;
    1:   PRUnichar* last  = start;
    1:   PRUnichar  endCh;
    1: 
    1:   while (*start != kNullCh) {
    1:     // skip leading space
    1:     while ((*start != kNullCh) && nsCRT::IsAsciiSpace(*start)) {
    1:       ++start;
    1:     }
    1: 
    1:     end = start;
    1:     last = end - 1;
    1: 
    1:     // look for semicolon or comma
    1:     while (*end != kNullCh && *end != kSemiCh && *end != kCommaCh) {
    1:       PRUnichar ch = *end;
    1: 
    1:       if (ch == kApostrophe || ch == kQuote || ch == kLessThanCh) {
    1:         // quoted string
    1: 
    1:         PRUnichar quote = *end;
    1:         if (quote == kLessThanCh) {
    1:           quote = kGreaterThanCh;
    1:         }
    1: 
    1:         PRUnichar* closeQuote = (end + 1);
    1: 
    1:         // seek closing quote
    1:         while (*closeQuote != kNullCh && quote != *closeQuote) {
    1:           ++closeQuote;
    1:         }
    1: 
    1:         if (quote == *closeQuote) {
    1:           // found closer
    1: 
    1:           // skip to close quote
    1:           end = closeQuote;
    1: 
    1:           last = end - 1;
    1: 
    1:           ch = *(end + 1);
    1: 
    1:           if (ch != kNullCh && ch != kSemiCh && ch != kCommaCh) {
    1:             // end string here
    1:             *(++end) = kNullCh;
    1: 
    1:             ch = *(end + 1);
    1: 
    1:             // keep going until semi or comma
    1:             while (ch != kNullCh && ch != kSemiCh && ch != kCommaCh) {
    1:               ++end;
    1: 
    1:               ch = *end;
    1:             }
    1:           }
    1:         }
    1:       }
    1: 
    1:       ++end;
    1:       ++last;
    1:     }
    1: 
    1:     endCh = *end;
    1: 
    1:     // end string here
    1:     *end = kNullCh;
    1: 
    1:     if (start < end) {
    1:       if ((*start == kLessThanCh) && (*last == kGreaterThanCh)) {
    1:         *last = kNullCh;
    1: 
    1:         if (href.IsEmpty()) { // first one wins
    1:           href = (start + 1);
    1:           href.StripWhitespace();
    1:         }
    1:       } else {
    1:         PRUnichar* equals = start;
    1: 
    1:         while ((*equals != kNullCh) && (*equals != kEqualsCh)) {
    1:           equals++;
    1:         }
    1: 
    1:         if (*equals != kNullCh) {
    1:           *equals = kNullCh;
    1:           nsAutoString  attr(start);
    1:           attr.StripWhitespace();
    1: 
    1:           PRUnichar* value = ++equals;
    1:           while (nsCRT::IsAsciiSpace(*value)) {
    1:             value++;
    1:           }
    1: 
    1:           if (((*value == kApostrophe) || (*value == kQuote)) &&
    1:               (*value == *last)) {
    1:             *last = kNullCh;
    1:             value++;
    1:           }
    1: 
    1:           if (attr.LowerCaseEqualsLiteral("rel")) {
    1:             if (rel.IsEmpty()) {
    1:               rel = value;
    1:               rel.CompressWhitespace();
    1:             }
    1:           } else if (attr.LowerCaseEqualsLiteral("title")) {
    1:             if (title.IsEmpty()) {
    1:               title = value;
    1:               title.CompressWhitespace();
    1:             }
    1:           } else if (attr.LowerCaseEqualsLiteral("type")) {
    1:             if (type.IsEmpty()) {
    1:               type = value;
    1:               type.StripWhitespace();
    1:             }
    1:           } else if (attr.LowerCaseEqualsLiteral("media")) {
    1:             if (media.IsEmpty()) {
    1:               media = value;
    1: 
    1:               // HTML4.0 spec is inconsistent, make it case INSENSITIVE
    1:               ToLowerCase(media);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (endCh == kCommaCh) {
    1:       // hit a comma, process what we've got so far
    1: 
    1:       if (!href.IsEmpty() && !rel.IsEmpty()) {
    1:         rv = ProcessLink(aElement, href, rel, title, type, media);
    1:       }
    1: 
    1:       href.Truncate();
    1:       rel.Truncate();
    1:       title.Truncate();
    1:       type.Truncate();
    1:       media.Truncate();
    1:     }
    1: 
    1:     start = ++end;
    1:   }
    1: 
    1:   if (!href.IsEmpty() && !rel.IsEmpty()) {
    1:     rv = ProcessLink(aElement, href, rel, title, type, media);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsContentSink::ProcessLink(nsIContent* aElement,
    1:                            const nsSubstring& aHref, const nsSubstring& aRel,
    1:                            const nsSubstring& aTitle, const nsSubstring& aType,
    1:                            const nsSubstring& aMedia)
    1: {
    1:   // XXX seems overkill to generate this string array
    1:   nsStringArray linkTypes;
    1:   nsStyleLinkElement::ParseLinkTypes(aRel, linkTypes);
    1: 
    1:   PRBool hasPrefetch = (linkTypes.IndexOf(NS_LITERAL_STRING("prefetch")) != -1);
    1:   // prefetch href if relation is "next" or "prefetch"
    1:   if (hasPrefetch || linkTypes.IndexOf(NS_LITERAL_STRING("next")) != -1) {
 3942:     PrefetchHref(aHref, aElement, hasPrefetch);
    1:   }
    1: 
21577:   if ((!aHref.IsEmpty()) && linkTypes.IndexOf(NS_LITERAL_STRING("dns-prefetch")) != -1) {
21577:     PrefetchDNS(aHref);
21577:   }
21577: 
    1:   // is it a stylesheet link?
    1:   if (linkTypes.IndexOf(NS_LITERAL_STRING("stylesheet")) == -1) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRBool isAlternate = linkTypes.IndexOf(NS_LITERAL_STRING("alternate")) != -1;
    1:   return ProcessStyleLink(aElement, aHref, isAlternate, aTitle, aType,
    1:                           aMedia);
    1: }
    1: 
    1: nsresult
    1: nsContentSink::ProcessStyleLink(nsIContent* aElement,
    1:                                 const nsSubstring& aHref,
    1:                                 PRBool aAlternate,
    1:                                 const nsSubstring& aTitle,
    1:                                 const nsSubstring& aType,
    1:                                 const nsSubstring& aMedia)
    1: {
    1:   if (aAlternate && aTitle.IsEmpty()) {
    1:     // alternates must have title return without error, for now
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsAutoString  mimeType;
    1:   nsAutoString  params;
    1:   nsParserUtils::SplitMimeType(aType, mimeType, params);
    1: 
    1:   // see bug 18817
    1:   if (!mimeType.IsEmpty() && !mimeType.LowerCaseEqualsLiteral("text/css")) {
    1:     // Unknown stylesheet language
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> url;
    1:   nsresult rv = NS_NewURI(getter_AddRefs(url), aHref, nsnull, mDocumentBaseURI);
    1:   
    1:   if (NS_FAILED(rv)) {
    1:     // The URI is bad, move along, don't propagate the error (for now)
    1:     return NS_OK;
    1:   }
    1: 
  681:   PRBool isAlternate;
  681:   rv = mCSSLoader->LoadStyleLink(aElement, url, aTitle, aMedia, aAlternate,
  681:                                  this, &isAlternate);
  681:   NS_ENSURE_SUCCESS(rv, rv);
  681:   
  681:   if (!isAlternate) {
  681:     ++mPendingSheetCount;
  681:     mScriptLoader->AddExecuteBlocker();
    1:   }
    1: 
  681:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsContentSink::ProcessMETATag(nsIContent* aContent)
    1: {
    1:   NS_ASSERTION(aContent, "missing base-element");
    1: 
    1:   nsresult rv = NS_OK;
    1: 
    1:   // set any HTTP-EQUIV data into document's header data as well as url
    1:   nsAutoString header;
    1:   aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::httpEquiv, header);
    1:   if (!header.IsEmpty()) {
    1:     nsAutoString result;
    1:     aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::content, result);
    1:     if (!result.IsEmpty()) {
    1:       ToLowerCase(header);
    1:       nsCOMPtr<nsIAtom> fieldAtom(do_GetAtom(header));
    1:       rv = ProcessHeaderData(fieldAtom, result, aContent); 
    1:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: void
    1: nsContentSink::PrefetchHref(const nsAString &aHref,
 3254:                             nsIContent *aSource,
 3942:                             PRBool aExplicit)
    1: {
    1:   //
    1:   // SECURITY CHECK: disable prefetching from mailnews!
    1:   //
    1:   // walk up the docshell tree to see if any containing
    1:   // docshell are of type MAIL.
    1:   //
    1:   if (!mDocShell)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIDocShell> docshell = mDocShell;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem, parentItem;
    1:   do {
    1:     PRUint32 appType = 0;
    1:     nsresult rv = docshell->GetAppType(&appType);
    1:     if (NS_FAILED(rv) || appType == nsIDocShell::APP_TYPE_MAIL)
    1:       return; // do not prefetch from mailnews
    1:     if (treeItem = do_QueryInterface(docshell)) {
    1:       treeItem->GetParent(getter_AddRefs(parentItem));
    1:       if (parentItem) {
    1:         treeItem = parentItem;
    1:         docshell = do_QueryInterface(treeItem);
    1:         if (!docshell) {
    1:           NS_ERROR("cannot get a docshell from a treeItem!");
    1:           return;
    1:         }
    1:       }
    1:     }
    1:   } while (parentItem);
    1:   
    1:   // OK, we passed the security check...
    1:   
    1:   nsCOMPtr<nsIPrefetchService> prefetchService(do_GetService(NS_PREFETCHSERVICE_CONTRACTID));
    1:   if (prefetchService) {
    1:     // construct URI using document charset
    1:     const nsACString &charset = mDocument->GetDocumentCharacterSet();
    1:     nsCOMPtr<nsIURI> uri;
    1:     NS_NewURI(getter_AddRefs(uri), aHref,
    1:               charset.IsEmpty() ? nsnull : PromiseFlatCString(charset).get(),
    1:               mDocumentBaseURI);
    1:     if (uri) {
 3254:       nsCOMPtr<nsIDOMNode> domNode = do_QueryInterface(aSource);
 3254:       prefetchService->PrefetchURI(uri, mDocumentURI, domNode, aExplicit);
    1:     }
    1:   }
    1: }
    1: 
21577: void
21577: nsContentSink::PrefetchDNS(const nsAString &aHref)
21577: {
21577:   nsAutoString hostname;
21577: 
21577:   if (StringBeginsWith(aHref, NS_LITERAL_STRING("//")))  {
21577:     hostname = Substring(aHref, 2);
21577:   }
21577:   else
21577:     nsGenericHTMLElement::GetHostnameFromHrefString(aHref, hostname);
21577: 
22391:   if (nsHTMLDNSPrefetch::IsAllowed(mDocument)) {
22391:     nsHTMLDNSPrefetch::PrefetchLow(hostname);
21577:   }
21577: }
21577: 
18488: nsresult
18488: nsContentSink::GetChannelCacheKey(nsIChannel* aChannel, nsACString& aCacheKey)
18488: {
18488:   aCacheKey.Truncate();
18488: 
18488:   nsresult rv;
18488:   nsCOMPtr<nsICachingChannel> cachingChannel = do_QueryInterface(aChannel, &rv);
18488:   NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:   nsCOMPtr<nsISupports> token;
18488:   rv = cachingChannel->GetCacheToken(getter_AddRefs(token));
18488:   NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:   nsCOMPtr<nsICacheEntryDescriptor> descriptor = do_QueryInterface(token, &rv);
18488:   NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:   rv = descriptor->GetKey(aCacheKey);
18488:   NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:   return NS_OK;
18488: }
18488: 
18488: nsresult
18488: nsContentSink::SelectDocAppCache(nsIApplicationCache *aLoadApplicationCache,
18488:                                  nsIURI *aManifestURI,
18488:                                  PRBool aFetchedWithHTTPGetOrEquiv,
18488:                                  CacheSelectionAction *aAction)
18488: {
21366:   nsresult rv;
21366: 
18488:   *aAction = CACHE_SELECTION_NONE;
18488: 
18488:   nsCOMPtr<nsIApplicationCacheContainer> applicationCacheDocument =
18488:     do_QueryInterface(mDocument);
18488:   NS_ASSERTION(applicationCacheDocument,
18488:                "mDocument must implement nsIApplicationCacheContainer.");
18488: 
21366:   if (aLoadApplicationCache) {
18488:     nsCAutoString groupID;
21366:     rv = aLoadApplicationCache->GetGroupID(groupID);
18488:     NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:     nsCOMPtr<nsIURI> groupURI;
18488:     rv = NS_NewURI(getter_AddRefs(groupURI), groupID);
18488:     NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:     PRBool equal = PR_FALSE;
18488:     rv = groupURI->Equals(aManifestURI, &equal);
18488:     NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:     if (!equal) {
21366:       // This is a foreign entry, mark it as such and force a reload to avoid
21366:       // loading the foreign entry.  The next attempt will not choose this
21366:       // cache entry (because it has been marked foreign).
18488: 
18488:       nsCAutoString cachekey;
18488:       rv = GetChannelCacheKey(mDocument->GetChannel(), cachekey);
18488:       NS_ENSURE_SUCCESS(rv, rv);
18488: 
21366:       rv = aLoadApplicationCache->MarkEntry(cachekey,
18488:                                             nsIApplicationCache::ITEM_FOREIGN);
18488:       NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:       *aAction = CACHE_SELECTION_RELOAD;
18488:     }
21366:     else {
21366:       // The http manifest attribute URI is equal to the manifest URI of
21366:       // the cache the document was loaded from - associate the document with
21366:       // that cache and invoke the cache update process.
21366: #ifdef NS_DEBUG
21366:       nsCAutoString docURISpec, clientID;
21366:       mDocumentURI->GetAsciiSpec(docURISpec);
21366:       aLoadApplicationCache->GetClientID(clientID);
21366:       SINK_TRACE(gContentSinkLogModuleInfo, SINK_TRACE_CALLS,
21366:           ("Selection: assigning app cache %s to document %s", clientID.get(), docURISpec.get()));
21366: #endif
18488: 
21366:       rv = applicationCacheDocument->SetApplicationCache(aLoadApplicationCache);
18488:       NS_ENSURE_SUCCESS(rv, rv);
18488: 
21366:       // Document will be added as implicit entry to the cache as part of
21366:       // the update process.
18488:       *aAction = CACHE_SELECTION_UPDATE;
18488:     }
18488:   }
18488:   else {
18488:     // The document was not loaded from an application cache
18488:     // Here we know the manifest has the same origin as the
18488:     // document. There is call to CheckMayLoad() on it above.
18488: 
18488:     if (!aFetchedWithHTTPGetOrEquiv) {
18488:       // The document was not loaded using HTTP GET or equivalent
18488:       // method. The spec says to run the cache selection algorithm w/o
21366:       // the manifest specified.
21366:       *aAction = CACHE_SELECTION_RESELECT_WITHOUT_MANIFEST;
18488:     }
18488:     else {
18488:       // Always do an update in this case
18488:       *aAction = CACHE_SELECTION_UPDATE;
18488:     }
18488:   }
18488: 
18488:   return NS_OK;
18488: }
18488: 
18488: nsresult
18488: nsContentSink::SelectDocAppCacheNoManifest(nsIApplicationCache *aLoadApplicationCache,
18488:                                            nsIURI **aManifestURI,
18488:                                            CacheSelectionAction *aAction)
18488: {
18488:   *aManifestURI = nsnull;
18488:   *aAction = CACHE_SELECTION_NONE;
18488: 
18488:   nsresult rv;
18488: 
21366:   if (aLoadApplicationCache) {
18488:     // The document was loaded from an application cache, use that
18488:     // application cache as the document's application cache.
18488:     nsCOMPtr<nsIApplicationCacheContainer> applicationCacheDocument =
18488:       do_QueryInterface(mDocument);
18488:     NS_ASSERTION(applicationCacheDocument,
18488:                  "mDocument must implement nsIApplicationCacheContainer.");
18488: 
21366: #ifdef NS_DEBUG
21366:     nsCAutoString docURISpec, clientID;
21366:     mDocumentURI->GetAsciiSpec(docURISpec);
21366:     aLoadApplicationCache->GetClientID(clientID);
21366:     SINK_TRACE(gContentSinkLogModuleInfo, SINK_TRACE_CALLS,
21366:         ("Selection, no manifest: assigning app cache %s to document %s", clientID.get(), docURISpec.get()));
21366: #endif
21366: 
18488:     rv = applicationCacheDocument->SetApplicationCache(aLoadApplicationCache);
18488:     NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:     // Return the uri and invoke the update process for the selected
18488:     // application cache.
18488:     nsCAutoString groupID;
18488:     rv = aLoadApplicationCache->GetGroupID(groupID);
18488:     NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:     rv = NS_NewURI(aManifestURI, groupID);
18488:     NS_ENSURE_SUCCESS(rv, rv);
18488: 
18488:     *aAction = CACHE_SELECTION_UPDATE;
21366:   }
18488: 
18488:   return NS_OK;
18488: }
18488: 
10340: void
10340: nsContentSink::ProcessOfflineManifest(nsIContent *aElement)
 1426: {
18488:   // Only check the manifest for root document nodes.
18488:   if (aElement != mDocument->GetRootContent()) {
18488:     return;
18488:   }
18488: 
18488:   nsresult rv;
18488: 
10340:   // Check for a manifest= attribute.
10340:   nsAutoString manifestSpec;
10340:   aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::manifest, manifestSpec);
 1426: 
18488:   // Grab the application cache the document was loaded from, if any.
18488:   nsCOMPtr<nsIApplicationCache> applicationCache;
18488: 
21311:   nsCOMPtr<nsIApplicationCacheChannel> applicationCacheChannel =
18488:     do_QueryInterface(mDocument->GetChannel());
18488:   if (applicationCacheChannel) {
21367:     PRBool loadedFromApplicationCache;
21367:     rv = applicationCacheChannel->GetLoadedFromApplicationCache(
21367:       &loadedFromApplicationCache);
21367:     if (NS_FAILED(rv)) {
21367:       return;
21367:     }
21367: 
21367:     if (loadedFromApplicationCache) {
18488:       rv = applicationCacheChannel->GetApplicationCache(
18488:         getter_AddRefs(applicationCache));
18488:       if (NS_FAILED(rv)) {
18488:         return;
18488:       }
18488:     }
21367:   }
18488: 
18488:   if (manifestSpec.IsEmpty() && !applicationCache) {
18488:     // Not loaded from an application cache, and no manifest
18488:     // attribute.  Nothing to do here.
10340:     return;
 1426:   }
 1426: 
18488:   CacheSelectionAction action = CACHE_SELECTION_NONE;
18488:   nsCOMPtr<nsIURI> manifestURI;
18488: 
18488:   if (manifestSpec.IsEmpty()) {
21366:     action = CACHE_SELECTION_RESELECT_WITHOUT_MANIFEST;
10340:   }
18488:   else {
10340:     nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(manifestURI),
10340:                                               manifestSpec, mDocument,
10340:                                               mDocumentURI);
10340:     if (!manifestURI) {
10340:       return;
10340:     }
10340: 
10340:     // Documents must list a manifest from the same origin
18488:     rv = mDocument->NodePrincipal()->CheckMayLoad(manifestURI, PR_TRUE);
10340:     if (NS_FAILED(rv)) {
21366:       action = CACHE_SELECTION_RESELECT_WITHOUT_MANIFEST;
10340:     }
21366:     else {
18488:       // Only continue if the document has permission to use offline APIs.
18488:       if (!nsContentUtils::OfflineAppAllowed(mDocument->NodePrincipal())) {
18488:         return;
18488:       }
18488: 
18488:       PRBool fetchedWithHTTPGetOrEquiv = PR_FALSE;
18488:       nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mDocument->GetChannel()));
18488:       if (httpChannel) {
18488:         nsCAutoString method;
18488:         rv = httpChannel->GetRequestMethod(method);
18488:         if (NS_SUCCEEDED(rv))
18488:           fetchedWithHTTPGetOrEquiv = method.Equals("GET");
18488:       }
18488: 
21366:       rv = SelectDocAppCache(applicationCache, manifestURI,
18488:                              fetchedWithHTTPGetOrEquiv, &action);
18488:       if (NS_FAILED(rv)) {
18488:         return;
18488:       }
18488:     }
21366:   }
21366: 
21366:   if (action == CACHE_SELECTION_RESELECT_WITHOUT_MANIFEST) {
21366:     rv = SelectDocAppCacheNoManifest(applicationCache,
21366:                                      getter_AddRefs(manifestURI),
21366:                                      &action);
21366:     if (NS_FAILED(rv)) {
21366:       return;
21366:     }
21366:   }
18488: 
18488:   switch (action)
18488:   {
18488:   case CACHE_SELECTION_NONE:
21366:     break;
18488:   case CACHE_SELECTION_UPDATE: {
10340:     nsCOMPtr<nsIOfflineCacheUpdateService> updateService =
10340:       do_GetService(NS_OFFLINECACHEUPDATESERVICE_CONTRACTID);
18488: 
18488:     if (updateService) {
18488:       nsCOMPtr<nsIDOMDocument> domdoc = do_QueryInterface(mDocument);
10340:       updateService->ScheduleOnDocumentStop(manifestURI, mDocumentURI, domdoc);
 1426:     }
18488:     break;
18488:   }
18488:   case CACHE_SELECTION_RELOAD: {
18488:     // This situation occurs only for toplevel documents, see bottom
18488:     // of SelectDocAppCache method.
18488:     nsCOMPtr<nsIWebNavigation> webNav = do_QueryInterface(mDocShell);
18488: 
18488:     webNav->Stop(nsIWebNavigation::STOP_ALL);
18488:     webNav->Reload(nsIWebNavigation::LOAD_FLAGS_NONE);
18488:     break;
18488:   }
21366:   default:
21366:     NS_ASSERTION(PR_FALSE,
21366:           "Cache selection algorithm didn't decide on proper action");
21366:     break;
18488:   }
18488: }
 1426: 
    1: void
    1: nsContentSink::ScrollToRef()
    1: {
    1:   if (mRef.IsEmpty()) {
    1:     return;
    1:   }
    1: 
12356:   if (mScrolledToRefAlready) {
12356:     return;
12356:   }
    1: 
    1:   char* tmpstr = ToNewCString(mRef);
    1:   if (!tmpstr) {
    1:     return;
    1:   }
    1: 
    1:   nsUnescape(tmpstr);
    1:   nsCAutoString unescapedRef;
    1:   unescapedRef.Assign(tmpstr);
    1:   nsMemory::Free(tmpstr);
    1: 
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   // We assume that the bytes are in UTF-8, as it says in the spec:
    1:   // http://www.w3.org/TR/html4/appendix/notes.html#h-B.2.1
    1:   NS_ConvertUTF8toUTF16 ref(unescapedRef);
    1: 
 1722:   nsPresShellIterator iter(mDocument);
 1722:   nsCOMPtr<nsIPresShell> shell;
 1722:   while ((shell = iter.GetNextShell())) {
    1:     // Check an empty string which might be caused by the UTF-8 conversion
    1:     if (!ref.IsEmpty()) {
    1:       // Note that GoToAnchor will handle flushing layout as needed.
    1:       rv = shell->GoToAnchor(ref, mChangeScrollPosWhenScrollingToRef);
    1:     } else {
    1:       rv = NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // If UTF-8 URI failed then try to assume the string as a
    1:     // document's charset.
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       const nsACString &docCharset = mDocument->GetDocumentCharacterSet();
    1: 
    1:       rv = nsContentUtils::ConvertStringFromCharset(docCharset, unescapedRef, ref);
    1: 
    1:       if (NS_SUCCEEDED(rv) && !ref.IsEmpty())
    1:         rv = shell->GoToAnchor(ref, mChangeScrollPosWhenScrollingToRef);
    1:     }
    1:     if (NS_SUCCEEDED(rv)) {
    1:       mScrolledToRefAlready = PR_TRUE;
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsContentSink::RefreshIfEnabled(nsIViewManager* vm)
    1: {
    1:   if (!vm) {
 1416:     // vm might be null if the shell got Destroy() called already
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIContentViewer> contentViewer;
    1:   mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
    1:   if (contentViewer) {
    1:     PRBool enabled;
    1:     contentViewer->GetEnableRendering(&enabled);
    1:     if (enabled) {
  752:       vm->EnableRefresh(NS_VMREFRESH_IMMEDIATE);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
  681: nsContentSink::StartLayout(PRBool aIgnorePendingSheets)
    1: {
  681:   if (mLayoutStarted) {
  681:     // Nothing to do here
  681:     return;
  681:   }
  681:   
  681:   mDeferredLayoutStart = PR_TRUE;
  681: 
 3317:   if (!aIgnorePendingSheets && WaitForPendingSheets()) {
  681:     // Bail out; we'll start layout when the sheets load
  681:     return;
  681:   }
  681: 
  681:   mDeferredLayoutStart = PR_FALSE;
  681: 
  845:   // Notify on all our content.  If none of our presshells have started layout
  845:   // yet it'll be a no-op except for updating our data structures, a la
  845:   // UpdateChildCounts() (because we don't want to double-notify on whatever we
  845:   // have right now).  If some of them _have_ started layout, we want to make
  845:   // sure to flush tags instead of just calling UpdateChildCounts() after we
  845:   // loop over the shells.
  845:   FlushTags();
  845: 
    1:   mLayoutStarted = PR_TRUE;
    1:   mLastNotificationTime = PR_Now();
  681: 
10474:   mDocument->SetMayStartLayout(PR_TRUE);
 1722:   nsPresShellIterator iter(mDocument);
 1722:   nsCOMPtr<nsIPresShell> shell;
 1722:   while ((shell = iter.GetNextShell())) {
    1:     // Make sure we don't call InitialReflow() for a shell that has
    1:     // already called it. This can happen when the layout frame for
    1:     // an iframe is constructed *between* the Embed() call for the
    1:     // docshell in the iframe, and the content sink's call to OpenBody().
    1:     // (Bug 153815)
    1: 
23164:     if (shell->DidInitialReflow()) {
    1:       // XXX: The assumption here is that if something already
    1:       // called InitialReflow() on this shell, it also did some of
    1:       // the setup below, so we do nothing and just move on to the
    1:       // next shell in the list.
    1: 
    1:       continue;
    1:     }
    1: 
    1:     nsRect r = shell->GetPresContext()->GetVisibleArea();
 1416:     nsCOMPtr<nsIPresShell> shellGrip = shell;
    1:     nsresult rv = shell->InitialReflow(r.width, r.height);
    1:     if (NS_FAILED(rv)) {
    1:       return;
    1:     }
    1: 
    1:     // Now trigger a refresh
    1:     RefreshIfEnabled(shell->GetViewManager());
    1:   }
    1: 
    1:   // If the document we are loading has a reference or it is a
    1:   // frameset document, disable the scroll bars on the views.
    1: 
    1:   if (mDocumentURI) {
    1:     nsCAutoString ref;
    1: 
    1:     // Since all URI's that pass through here aren't URL's we can't
    1:     // rely on the nsIURI implementation for providing a way for
    1:     // finding the 'ref' part of the URI, we'll haveto revert to
    1:     // string routines for finding the data past '#'
    1: 
    1:     mDocumentURI->GetSpec(ref);
    1: 
    1:     nsReadingIterator<char> start, end;
    1: 
    1:     ref.BeginReading(start);
    1:     ref.EndReading(end);
    1: 
    1:     if (FindCharInReadable('#', start, end)) {
    1:       ++start; // Skip over the '#'
    1: 
    1:       mRef = Substring(start, end);
    1:     }
    1:   }
    1: }
    1: 
    1: void
    1: nsContentSink::NotifyAppend(nsIContent* aContainer, PRUint32 aStartIndex)
    1: {
    1:   if (aContainer->GetCurrentDoc() != mDocument) {
    1:     // aContainer is not actually in our document anymore.... Just bail out of
    1:     // here; notifying on our document for this append would be wrong.
    1:     return;
    1:   }
    1: 
    1:   mInNotification++;
    1: 
    1:   MOZ_TIMER_DEBUGLOG(("Save and stop: nsHTMLContentSink::NotifyAppend()\n"));
    1:   MOZ_TIMER_SAVE(mWatch)
    1:   MOZ_TIMER_STOP(mWatch);
    1: 
    1:   {
    1:     // Scope so we call EndUpdate before we decrease mInNotification
    1:     MOZ_AUTO_DOC_UPDATE(mDocument, UPDATE_CONTENT_MODEL, !mBeganUpdate);
    1:     nsNodeUtils::ContentAppended(aContainer, aStartIndex);
    1:     mLastNotificationTime = PR_Now();
    1:   }
    1: 
    1:   MOZ_TIMER_DEBUGLOG(("Restore: nsHTMLContentSink::NotifyAppend()\n"));
    1:   MOZ_TIMER_RESTORE(mWatch);
    1: 
    1:   mInNotification--;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsContentSink::Notify(nsITimer *timer)
    1: {
    1:   MOZ_TIMER_DEBUGLOG(("Start: nsHTMLContentSink::Notify()\n"));
    1:   MOZ_TIMER_START(mWatch);
    1: 
    1:   if (mParsing) {
    1:     // We shouldn't interfere with our normal DidProcessAToken logic
    1:     mDroppedTimer = PR_TRUE;
    1:     return NS_OK;
    1:   }
    1:   
    1: #ifdef MOZ_DEBUG
    1:   {
    1:     PRTime now = PR_Now();
    1:     PRInt64 diff, interval;
    1:     PRInt32 delay;
    1: 
    1:     LL_I2L(interval, GetNotificationInterval());
    1:     LL_SUB(diff, now, mLastNotificationTime);
    1: 
    1:     LL_SUB(diff, diff, interval);
    1:     LL_L2I(delay, diff);
    1:     delay /= PR_USEC_PER_MSEC;
    1: 
    1:     mBackoffCount--;
    1:     SINK_TRACE(gContentSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                ("nsContentSink::Notify: reflow on a timer: %d milliseconds "
    1:                 "late, backoff count: %d", delay, mBackoffCount));
    1:   }
    1: #endif
    1: 
 3317:   if (WaitForPendingSheets()) {
 3317:     mDeferredFlushTags = PR_TRUE;
 3317:   } else {
    1:     FlushTags();
    1: 
    1:     // Now try and scroll to the reference
    1:     // XXX Should we scroll unconditionally for history loads??
12356:     ScrollToRef();
 3317:   }
 3317: 
    1:   mNotificationTimer = nsnull;
    1:   MOZ_TIMER_DEBUGLOG(("Stop: nsHTMLContentSink::Notify()\n"));
    1:   MOZ_TIMER_STOP(mWatch);
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsContentSink::IsTimeToNotify()
    1: {
    1:   if (!mNotifyOnTimer || !mLayoutStarted || !mBackoffCount ||
    1:       mInMonolithicContainer) {
    1:     return PR_FALSE;
    1:   }
    1: 
 3317:   if (WaitForPendingSheets()) {
 3317:     mDeferredFlushTags = PR_TRUE;
 3317:     return PR_FALSE;
 3317:   }
 3317: 
    1:   PRTime now = PR_Now();
    1:   PRInt64 interval, diff;
    1: 
    1:   LL_I2L(interval, GetNotificationInterval());
    1:   LL_SUB(diff, now, mLastNotificationTime);
    1: 
    1:   if (LL_CMP(diff, >, interval)) {
    1:     mBackoffCount--;
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: nsresult
    1: nsContentSink::WillInterruptImpl()
    1: {
    1:   nsresult result = NS_OK;
    1: 
    1:   SINK_TRACE(gContentSinkLogModuleInfo, SINK_TRACE_CALLS,
    1:              ("nsContentSink::WillInterrupt: this=%p", this));
    1: #ifndef SINK_NO_INCREMENTAL
 3317:   if (WaitForPendingSheets()) {
 3317:     mDeferredFlushTags = PR_TRUE;
 3317:   } else if (mNotifyOnTimer && mLayoutStarted) {
    1:     if (mBackoffCount && !mInMonolithicContainer) {
    1:       PRInt64 now = PR_Now();
    1:       PRInt64 interval = GetNotificationInterval();
    1:       PRInt64 diff = now - mLastNotificationTime;
    1: 
    1:       // If it's already time for us to have a notification
    1:       if (diff > interval || mDroppedTimer) {
    1:         mBackoffCount--;
    1:         SINK_TRACE(gContentSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                    ("nsContentSink::WillInterrupt: flushing tags since we've "
    1:                     "run out time; backoff count: %d", mBackoffCount));
    1:         result = FlushTags();
    1:         if (mDroppedTimer) {
12356:           ScrollToRef();
    1:           mDroppedTimer = PR_FALSE;
    1:         }
    1:       } else if (!mNotificationTimer) {
    1:         interval -= diff;
    1:         PRInt32 delay = interval;
    1: 
    1:         // Convert to milliseconds
    1:         delay /= PR_USEC_PER_MSEC;
    1: 
    1:         mNotificationTimer = do_CreateInstance("@mozilla.org/timer;1",
    1:                                                &result);
    1:         if (NS_SUCCEEDED(result)) {
    1:           SINK_TRACE(gContentSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                      ("nsContentSink::WillInterrupt: setting up timer with "
    1:                       "delay %d", delay));
    1: 
    1:           result =
    1:             mNotificationTimer->InitWithCallback(this, delay,
    1:                                                  nsITimer::TYPE_ONE_SHOT);
    1:           if (NS_FAILED(result)) {
    1:             mNotificationTimer = nsnull;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   } else {
    1:     SINK_TRACE(gContentSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                ("nsContentSink::WillInterrupt: flushing tags "
    1:                 "unconditionally"));
    1:     result = FlushTags();
    1:   }
    1: #endif
    1: 
    1:   mParsing = PR_FALSE;
    1: 
    1:   return result;
    1: }
    1: 
    1: nsresult
    1: nsContentSink::WillResumeImpl()
    1: {
    1:   SINK_TRACE(gContentSinkLogModuleInfo, SINK_TRACE_CALLS,
    1:              ("nsContentSink::WillResume: this=%p", this));
    1: 
    1:   mParsing = PR_TRUE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsContentSink::DidProcessATokenImpl()
    1: {
    1:   if (!mCanInterruptParser) {
    1:     return NS_OK;
    1:   }
    1:   // There is both a high frequency interrupt mode and a low
    1:   // frequency interupt mode controlled by the flag
    1:   // mDynamicLowerValue The high frequency mode
    1:   // interupts the parser frequently to provide UI responsiveness at
    1:   // the expense of page load time. The low frequency mode
    1:   // interrupts the parser and samples the system clock infrequently
    1:   // to provide fast page load time. When the user moves the mouse,
    1:   // clicks or types the mode switches to the high frequency
    1:   // interrupt mode. If the user stops moving the mouse or typing
    1:   // for a duration of time (mDynamicIntervalSwitchThreshold) it
    1:   // switches to low frequency interrupt mode.
    1: 
    1:   // Get the current user event time
  981:   nsIPresShell *shell = mDocument->GetPrimaryShell();
    1: 
    1:   if (!shell) {
    1:     // If there's no pres shell in the document, return early since
    1:     // we're not laying anything out here.
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsIViewManager* vm = shell->GetViewManager();
    1:   NS_ENSURE_TRUE(vm, NS_ERROR_FAILURE);
    1:   PRUint32 eventTime;
    1:   nsCOMPtr<nsIWidget> widget;
    1:   nsresult rv = vm->GetWidget(getter_AddRefs(widget));
    1:   if (!widget || NS_FAILED(widget->GetLastInputEventTime(eventTime))) {
    1:       // If we can't get the last input time from the widget
    1:       // then we will get it from the viewmanager.
    1:       rv = vm->GetLastUserEventTime(eventTime);
    1:       NS_ENSURE_SUCCESS(rv , NS_ERROR_FAILURE);
    1:   }
    1: 
    1: 
    1:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
    1: 
    1:   if (!mDynamicLowerValue && mLastSampledUserEventTime == eventTime) {
    1:     // The magic value of NS_MAX_TOKENS_DEFLECTED_IN_LOW_FREQ_MODE
    1:     // was selected by empirical testing. It provides reasonable
    1:     // user response and prevents us from sampling the clock too
    1:     // frequently.
    1:     if (mDeflectedCount < NS_MAX_TOKENS_DEFLECTED_IN_LOW_FREQ_MODE) {
    1:       mDeflectedCount++;
    1:       // return early to prevent sampling the clock. Note: This
    1:       // prevents us from switching to higher frequency (better UI
    1:       // responsive) mode, so limit ourselves to doing for no more
    1:       // than NS_MAX_TOKENS_DEFLECTED_IN_LOW_FREQ_MODE tokens.
    1: 
    1:       return NS_OK;
    1:     }
    1: 
    1:     // reset count and drop through to the code which samples the
    1:     // clock and does the dynamic switch between the high
    1:     // frequency and low frequency interruption of the parser.
    1:     mDeflectedCount = 0;
    1:   }
    1:   mLastSampledUserEventTime = eventTime;
    1: 
    1:   PRUint32 currentTime = PR_IntervalToMicroseconds(PR_IntervalNow());
    1: 
    1:   // Get the last user event time and compare it with the current
    1:   // time to determine if the lower value for content notification
    1:   // and max token processing should be used. But only consider
    1:   // using the lower value if the document has already been loading
    1:   // for 2 seconds. 2 seconds was chosen because it is greater than
    1:   // the default 3/4 of second that is used to determine when to
    1:   // switch between the modes and it gives the document a little
    1:   // time to create windows.  This is important because on some
    1:   // systems (Windows, for example) when a window is created and the
    1:   // mouse is over it, a mouse move event is sent, which will kick
    1:   // us into interactive mode otherwise. It also suppresses reaction
    1:   // to pressing the ENTER key in the URL bar...
    1: 
    1:   PRUint32 delayBeforeLoweringThreshold =
 3233:     static_cast<PRUint32>(((2 * mDynamicIntervalSwitchThreshold) +
    1:                               NS_DELAY_FOR_WINDOW_CREATION));
    1: 
    1:   if ((currentTime - mBeginLoadTime) > delayBeforeLoweringThreshold) {
    1:     if ((currentTime - eventTime) <
 3233:         static_cast<PRUint32>(mDynamicIntervalSwitchThreshold)) {
    1: 
    1:       if (!mDynamicLowerValue) {
    1:         // lower the dynamic values to favor application
    1:         // responsiveness over page load time.
    1:         mDynamicLowerValue = PR_TRUE;
    1:         // Set the performance hint to prevent event starvation when
    1:         // dispatching PLEvents. This improves application responsiveness
    1:         // during page loads.
    1:         FavorPerformanceHint(PR_FALSE, 0);
    1:       }
    1: 
    1:     }
    1:     else if (mDynamicLowerValue) {
    1:       // raise the content notification and MaxTokenProcessing time
    1:       // to favor overall page load speed over responsiveness.
    1:       mDynamicLowerValue = PR_FALSE;
    1:       // Reset the hint that to favoring performance for PLEvent dispatch.
    1:       FavorPerformanceHint(PR_TRUE, 0);
    1:     }
    1:   }
    1: 
    1:   if ((currentTime - mDelayTimerStart) >
 3233:       static_cast<PRUint32>(GetMaxTokenProcessingTime())) {
    1:     return NS_ERROR_HTMLPARSER_INTERRUPTED;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: void
    1: nsContentSink::FavorPerformanceHint(PRBool perfOverStarvation, PRUint32 starvationDelay)
    1: {
    1:   static NS_DEFINE_CID(kAppShellCID, NS_APPSHELL_CID);
    1:   nsCOMPtr<nsIAppShell> appShell = do_GetService(kAppShellCID);
    1:   if (appShell)
    1:     appShell->FavorPerformanceHint(perfOverStarvation, starvationDelay);
    1: }
    1: 
    1: void
    1: nsContentSink::BeginUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType)
    1: {
 1574:   // Remember nested updates from updates that we started.
 1574:   if (mInNotification && mUpdatesInNotification < 2) {
 1574:     ++mUpdatesInNotification;
 1574:   }
 1574: 
    1:   // If we're in a script and we didn't do the notification,
    1:   // something else in the script processing caused the
    1:   // notification to occur. Since this could result in frame
    1:   // creation, make sure we've flushed everything before we
    1:   // continue.
    1: 
    1:   // Note that UPDATE_CONTENT_STATE notifications never cause
    1:   // synchronous frame construction, so we never have to worry about
    1:   // them here.  The code that handles the async event these
    1:   // notifications post will flush us out if it needs to.
    1: 
    1:   // Also, if this is not an UPDATE_CONTENT_STATE notification,
    1:   // increment mInNotification to make sure we don't flush again until
    1:   // the end of this update, even if nested updates or
    1:   // FlushPendingNotifications calls happen during it.
    1:   NS_ASSERTION(aUpdateType && (aUpdateType & UPDATE_ALL) == aUpdateType,
    1:                "Weird update type bitmask");
    1:   if (aUpdateType != UPDATE_CONTENT_STATE && !mInNotification++) {
    1:     FlushTags();
    1:   }
    1: }
    1: 
    1: void
    1: nsContentSink::EndUpdate(nsIDocument *aDocument, nsUpdateType aUpdateType)
    1: {
    1:   // If we're in a script and we didn't do the notification,
    1:   // something else in the script processing caused the
    1:   // notification to occur. Update our notion of how much
    1:   // has been flushed to include any new content if ending
    1:   // this update leaves us not inside a notification.  Note that we
    1:   // exclude UPDATE_CONTENT_STATE notifications here, since those
    1:   // never affect the frame model directly while inside the
    1:   // notification.
    1:   NS_ASSERTION(aUpdateType && (aUpdateType & UPDATE_ALL) == aUpdateType,
    1:                "Weird update type bitmask");
    1:   if (aUpdateType != UPDATE_CONTENT_STATE && !--mInNotification) {
    1:     UpdateChildCounts();
    1:   }
    1: }
    1: 
    1: void
    1: nsContentSink::DidBuildModelImpl(void)
    1: {
18363:   if (!mDocument->HaveFiredDOMTitleChange()) {
18363:     mDocument->NotifyPossibleTitleChange(PR_FALSE);
18363:   }
18363: 
    1:   // Cancel a timer if we had one out there
    1:   if (mNotificationTimer) {
    1:     SINK_TRACE(gContentSinkLogModuleInfo, SINK_TRACE_REFLOW,
    1:                ("nsContentSink::DidBuildModel: canceling notification "
    1:                 "timeout"));
    1:     mNotificationTimer->Cancel();
    1:     mNotificationTimer = 0;
    1:   }	
    1: }
    1: 
    1: void
    1: nsContentSink::DropParserAndPerfHint(void)
    1: {
  854:   if (!mParser) {
  854:     // Make sure we don't unblock unload too many times
  854:     return;
  854:   }
  854:   
    1:   // Ref. Bug 49115
    1:   // Do this hack to make sure that the parser
    1:   // doesn't get destroyed, accidently, before
    1:   // the circularity, between sink & parser, is
    1:   // actually borken.
    1:   nsCOMPtr<nsIParser> kungFuDeathGrip(mParser);
    1: 
    1:   // Drop our reference to the parser to get rid of a circular
    1:   // reference.
    1:   mParser = nsnull;
    1: 
    1:   if (mDynamicLowerValue) {
    1:     // Reset the performance hint which was set to FALSE
    1:     // when mDynamicLowerValue was set.
    1:     FavorPerformanceHint(PR_TRUE, 0);
    1:   }
    1: 
    1:   if (mCanInterruptParser) {
    1:     mDocument->UnblockOnload(PR_TRUE);
    1:   }
    1: }
    1: 
    1: nsresult
21121: nsContentSink::WillParseImpl(void)
    1: {
    1:   if (mCanInterruptParser) {
    1:     mDelayTimerStart = PR_IntervalToMicroseconds(PR_IntervalNow());
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsContentSink::WillBuildModelImpl()
    1: {
    1:   if (mCanInterruptParser) {
    1:     mDocument->BlockOnload();
    1: 
    1:     mBeginLoadTime = PR_IntervalToMicroseconds(PR_IntervalNow());
    1:   }
    1: 
    1:   mScrolledToRefAlready = PR_FALSE;
    1: }
    1: 
    1: void
 1686: nsContentSink::ContinueInterruptedParsingIfEnabled()
 1686: {
 1686:   if (mParser && mParser->IsParserEnabled()) {
 1686:     mParser->ContinueInterruptedParsing();
 1686:   }
 1686: }
 1686: 
 1686: void
    1: nsContentSink::ContinueInterruptedParsingAsync()
    1: {
    1:   nsCOMPtr<nsIRunnable> ev = new nsRunnableMethod<nsContentSink>(this,
 1686:     &nsContentSink::ContinueInterruptedParsingIfEnabled);
    1: 
    1:   NS_DispatchToCurrentThread(ev);
    1: }
 2542: 
 2542: // URIs: action, href, src, longdesc, usemap, cite
 2542: PRBool 
 2542: IsAttrURI(nsIAtom *aName)
 2542: {
 2542:   return (aName == nsGkAtoms::action ||
 2542:           aName == nsGkAtoms::href ||
 2542:           aName == nsGkAtoms::src ||
 2542:           aName == nsGkAtoms::longdesc ||
 2542:           aName == nsGkAtoms::usemap ||
 2542:           aName == nsGkAtoms::cite ||
 2542:           aName == nsGkAtoms::background);
 2542: }
 2542: 
 2542: //
 2542: // these two lists are used by the sanitizing fragment serializers
 2542: // Thanks to Mark Pilgrim and Sam Ruby for the initial whitelist
 2542: //
 2542: nsIAtom** const kDefaultAllowedTags [] = {
 2542:   &nsGkAtoms::a,
 2542:   &nsGkAtoms::abbr,
 2542:   &nsGkAtoms::acronym,
 2542:   &nsGkAtoms::address,
 2542:   &nsGkAtoms::area,
 2542:   &nsGkAtoms::b,
 2542:   &nsGkAtoms::bdo,
 2542:   &nsGkAtoms::big,
 2542:   &nsGkAtoms::blockquote,
 2542:   &nsGkAtoms::br,
 2542:   &nsGkAtoms::button,
 2542:   &nsGkAtoms::caption,
 2542:   &nsGkAtoms::center,
 2542:   &nsGkAtoms::cite,
 2542:   &nsGkAtoms::code,
 2542:   &nsGkAtoms::col,
 2542:   &nsGkAtoms::colgroup,
 2542:   &nsGkAtoms::dd,
 2542:   &nsGkAtoms::del,
 2542:   &nsGkAtoms::dfn,
 2542:   &nsGkAtoms::dir,
 2542:   &nsGkAtoms::div,
 2542:   &nsGkAtoms::dl,
 2542:   &nsGkAtoms::dt,
 2542:   &nsGkAtoms::em,
 2542:   &nsGkAtoms::fieldset,
 2542:   &nsGkAtoms::font,
 2542:   &nsGkAtoms::form,
 2542:   &nsGkAtoms::h1,
 2542:   &nsGkAtoms::h2,
 2542:   &nsGkAtoms::h3,
 2542:   &nsGkAtoms::h4,
 2542:   &nsGkAtoms::h5,
 2542:   &nsGkAtoms::h6,
 2542:   &nsGkAtoms::hr,
 2542:   &nsGkAtoms::i,
 2542:   &nsGkAtoms::img,
 2542:   &nsGkAtoms::input,
 2542:   &nsGkAtoms::ins,
 2542:   &nsGkAtoms::kbd,
 2542:   &nsGkAtoms::label,
 2542:   &nsGkAtoms::legend,
 2542:   &nsGkAtoms::li,
 2542:   &nsGkAtoms::listing,
 2542:   &nsGkAtoms::map,
 2542:   &nsGkAtoms::menu,
 2542:   &nsGkAtoms::nobr,
 2542:   &nsGkAtoms::ol,
 2542:   &nsGkAtoms::optgroup,
 2542:   &nsGkAtoms::option,
 2542:   &nsGkAtoms::p,
 2542:   &nsGkAtoms::pre,
 2542:   &nsGkAtoms::q,
 2542:   &nsGkAtoms::s,
 2542:   &nsGkAtoms::samp,
 2542:   &nsGkAtoms::select,
 2542:   &nsGkAtoms::small,
 2542:   &nsGkAtoms::span,
 2542:   &nsGkAtoms::strike,
 2542:   &nsGkAtoms::strong,
 2542:   &nsGkAtoms::sub,
 2542:   &nsGkAtoms::sup,
 2542:   &nsGkAtoms::table,
 2542:   &nsGkAtoms::tbody,
 2542:   &nsGkAtoms::td,
 2542:   &nsGkAtoms::textarea,
 2542:   &nsGkAtoms::tfoot,
 2542:   &nsGkAtoms::th,
 2542:   &nsGkAtoms::thead,
 2542:   &nsGkAtoms::tr,
 2542:   &nsGkAtoms::tt,
 2542:   &nsGkAtoms::u,
 2542:   &nsGkAtoms::ul,
 2542:   &nsGkAtoms::var,
 2542:   nsnull
 2542: };
 2542: 
 2542: nsIAtom** const kDefaultAllowedAttributes [] = {
 2542:   &nsGkAtoms::abbr,
 2542:   &nsGkAtoms::accept,
 2542:   &nsGkAtoms::acceptcharset,
 2542:   &nsGkAtoms::accesskey,
 2542:   &nsGkAtoms::action,
 2542:   &nsGkAtoms::align,
 2542:   &nsGkAtoms::alt,
 2542:   &nsGkAtoms::autocomplete,
 2542:   &nsGkAtoms::axis,
 2542:   &nsGkAtoms::background,
 2542:   &nsGkAtoms::bgcolor,
 2542:   &nsGkAtoms::border,
 2542:   &nsGkAtoms::cellpadding,
 2542:   &nsGkAtoms::cellspacing,
 2542:   &nsGkAtoms::_char,
 2542:   &nsGkAtoms::charoff,
 2542:   &nsGkAtoms::charset,
 2542:   &nsGkAtoms::checked,
 2542:   &nsGkAtoms::cite,
 2542:   &nsGkAtoms::_class,
 2542:   &nsGkAtoms::clear,
 2542:   &nsGkAtoms::cols,
 2542:   &nsGkAtoms::colspan,
 2542:   &nsGkAtoms::color,
 2542:   &nsGkAtoms::compact,
 2542:   &nsGkAtoms::coords,
 2542:   &nsGkAtoms::datetime,
 2542:   &nsGkAtoms::dir,
 2542:   &nsGkAtoms::disabled,
 2542:   &nsGkAtoms::enctype,
 2542:   &nsGkAtoms::_for,
 2542:   &nsGkAtoms::frame,
 2542:   &nsGkAtoms::headers,
 2542:   &nsGkAtoms::height,
 2542:   &nsGkAtoms::href,
 2542:   &nsGkAtoms::hreflang,
 2542:   &nsGkAtoms::hspace,
 2542:   &nsGkAtoms::id,
 2542:   &nsGkAtoms::ismap,
 2542:   &nsGkAtoms::label,
 2542:   &nsGkAtoms::lang,
 2542:   &nsGkAtoms::longdesc,
 2542:   &nsGkAtoms::maxlength,
 2542:   &nsGkAtoms::media,
 2542:   &nsGkAtoms::method,
 2542:   &nsGkAtoms::multiple,
 2542:   &nsGkAtoms::name,
 2542:   &nsGkAtoms::nohref,
 2542:   &nsGkAtoms::noshade,
 2542:   &nsGkAtoms::nowrap,
 2542:   &nsGkAtoms::pointSize,
 2542:   &nsGkAtoms::prompt,
 2542:   &nsGkAtoms::readonly,
 2542:   &nsGkAtoms::rel,
 2542:   &nsGkAtoms::rev,
 2542:   &nsGkAtoms::role,
 2542:   &nsGkAtoms::rows,
 2542:   &nsGkAtoms::rowspan,
 2542:   &nsGkAtoms::rules,
 2542:   &nsGkAtoms::scope,
 2542:   &nsGkAtoms::selected,
 2542:   &nsGkAtoms::shape,
 2542:   &nsGkAtoms::size,
 2542:   &nsGkAtoms::span,
 2542:   &nsGkAtoms::src,
 2542:   &nsGkAtoms::start,
 2542:   &nsGkAtoms::summary,
 2542:   &nsGkAtoms::tabindex,
 2542:   &nsGkAtoms::target,
 2542:   &nsGkAtoms::title,
 2542:   &nsGkAtoms::type,
 2542:   &nsGkAtoms::usemap,
 2542:   &nsGkAtoms::valign,
 2542:   &nsGkAtoms::value,
 2542:   &nsGkAtoms::vspace,
 2542:   &nsGkAtoms::width,
 2542:   nsnull
 2542: };
