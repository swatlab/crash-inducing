  3869: // Copyright (c) 2006, Google Inc.
  3869: // All rights reserved.
  3869: //
  3869: // Redistribution and use in source and binary forms, with or without
  3869: // modification, are permitted provided that the following conditions are
  3869: // met:
  3869: //
  3869: //     * Redistributions of source code must retain the above copyright
  3869: // notice, this list of conditions and the following disclaimer.
  3869: //     * Redistributions in binary form must reproduce the above
  3869: // copyright notice, this list of conditions and the following disclaimer
  3869: // in the documentation and/or other materials provided with the
  3869: // distribution.
  3869: //     * Neither the name of Google Inc. nor the names of its
  3869: // contributors may be used to endorse or promote products derived from
  3869: // this software without specific prior written permission.
  3869: //
  3869: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  3869: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  3869: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  3869: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  3869: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  3869: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  3869: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  3869: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  3869: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  3869: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  3869: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  3869: 
 54618: #include <algorithm>
  3869: #include <cstdio>
  3869: 
  3869: #include <mach/host_info.h>
118328: #include <mach/machine.h>
  3869: #include <mach/vm_statistics.h>
  3869: #include <mach-o/dyld.h>
  3869: #include <mach-o/loader.h>
  3869: #include <sys/sysctl.h>
  3889: #include <sys/resource.h>
  3869: 
  3869: #include <CoreFoundation/CoreFoundation.h>
  3869: 
  3869: #include "client/mac/handler/minidump_generator.h"
 74574: 
114869: #ifdef HAS_ARM_SUPPORT
114869: #include <mach/arm/thread_status.h>
114869: #endif
 74574: #ifdef HAS_PPC_SUPPORT
 74574: #include <mach/ppc/thread_status.h>
 74574: #endif
114869: #ifdef HAS_X86_SUPPORT
114869: #include <mach/i386/thread_status.h>
114869: #endif
 74574: 
  3869: #include "client/minidump_file_writer-inl.h"
  3869: #include "common/mac/file_id.h"
114869: #include "common/mac/macho_id.h"
  3869: #include "common/mac/string_utilities.h"
  3869: 
  3869: using MacStringUtils::ConvertToString;
  3869: using MacStringUtils::IntegerValueAtIndex;
  3869: 
  3869: namespace google_breakpad {
  3869: 
 47243: #if __LP64__
 47243: #define LC_SEGMENT_ARCH LC_SEGMENT_64
 47243: #else
 47243: #define LC_SEGMENT_ARCH LC_SEGMENT
 47243: #endif
 47243: 
  3897: // constructor when generating from within the crashed process
  3869: MinidumpGenerator::MinidumpGenerator()
 50677:     : writer_(),
 50677:       exception_type_(0),
  3869:       exception_code_(0),
 32241:       exception_subcode_(0),
  3889:       exception_thread_(0),
  3889:       crashing_task_(mach_task_self()),
  3897:       handler_thread_(mach_thread_self()),
 59426:       cpu_type_(DynamicImages::GetNativeCPUType()),
114869:       task_context_(NULL),
 54618:       dynamic_images_(NULL),
 54618:       memory_blocks_(&allocator_) {
  3889:   GatherSystemInformation();
  3889: }
  3889: 
 22509: // constructor when generating from a different process than the
 22509: // crashed process
 22509: MinidumpGenerator::MinidumpGenerator(mach_port_t crashing_task,
 22509:                                      mach_port_t handler_thread)
 50677:     : writer_(),
 50677:       exception_type_(0),
  3889:       exception_code_(0),
 32241:       exception_subcode_(0),
  3889:       exception_thread_(0),
  3889:       crashing_task_(crashing_task),
 50677:       handler_thread_(handler_thread),
 59426:       cpu_type_(DynamicImages::GetNativeCPUType()),
114869:       task_context_(NULL),
 54618:       dynamic_images_(NULL),
 54618:       memory_blocks_(&allocator_) {
  3897:   if (crashing_task != mach_task_self()) {
  3889:     dynamic_images_ = new DynamicImages(crashing_task_);
 59426:     cpu_type_ = dynamic_images_->GetCPUType();
  3897:   } else {
  3897:     dynamic_images_ = NULL;
 59426:     cpu_type_ = DynamicImages::GetNativeCPUType();
  3897:   }
  3897: 
  3889:   GatherSystemInformation();
  3869: }
  3869: 
  3869: MinidumpGenerator::~MinidumpGenerator() {
  3897:   delete dynamic_images_;
  3869: }
  3869: 
  3869: char MinidumpGenerator::build_string_[16];
  3869: int MinidumpGenerator::os_major_version_ = 0;
  3869: int MinidumpGenerator::os_minor_version_ = 0;
  3869: int MinidumpGenerator::os_build_number_ = 0;
  3869: 
  3869: // static
  3869: void MinidumpGenerator::GatherSystemInformation() {
  3869:   // If this is non-zero, then we've already gathered the information
  3869:   if (os_major_version_)
  3869:     return;
  3869: 
  3869:   // This code extracts the version and build information from the OS
  3869:   CFStringRef vers_path =
  3869:     CFSTR("/System/Library/CoreServices/SystemVersion.plist");
  3869:   CFURLRef sys_vers =
 22509:     CFURLCreateWithFileSystemPath(NULL,
 22509:                                   vers_path,
 22509:                                   kCFURLPOSIXPathStyle,
 22509:                                   false);
  3869:   CFDataRef data;
  3869:   SInt32 error;
  3869:   CFURLCreateDataAndPropertiesFromResource(NULL, sys_vers, &data, NULL, NULL,
  3869:                                            &error);
  3869: 
114869:   if (!data) {
114869:     CFRelease(sys_vers);
  3869:     return;
114869:   }
  3869: 
  3869:   CFDictionaryRef list = static_cast<CFDictionaryRef>
  3869:     (CFPropertyListCreateFromXMLData(NULL, data, kCFPropertyListImmutable,
  3869:                                      NULL));
114869:   if (!list) {
114869:     CFRelease(sys_vers);
114869:     CFRelease(data);
  3869:     return;
114869:   }
  3869: 
  3869:   CFStringRef build_version = static_cast<CFStringRef>
  3869:     (CFDictionaryGetValue(list, CFSTR("ProductBuildVersion")));
  3869:   CFStringRef product_version = static_cast<CFStringRef>
  3869:     (CFDictionaryGetValue(list, CFSTR("ProductVersion")));
  3869:   string build_str = ConvertToString(build_version);
  3869:   string product_str = ConvertToString(product_version);
  3869: 
  3869:   CFRelease(list);
  3869:   CFRelease(sys_vers);
  3869:   CFRelease(data);
  3869: 
  3869:   strlcpy(build_string_, build_str.c_str(), sizeof(build_string_));
  3869: 
  3869:   // Parse the string that looks like "10.4.8"
  3869:   os_major_version_ = IntegerValueAtIndex(product_str, 0);
  3869:   os_minor_version_ = IntegerValueAtIndex(product_str, 1);
  3869:   os_build_number_ = IntegerValueAtIndex(product_str, 2);
  3869: }
  3869: 
114869: void MinidumpGenerator::SetTaskContext(ucontext_t *task_context) {
114869:   task_context_ = task_context;
114869: }
114869: 
  3869: string MinidumpGenerator::UniqueNameInDirectory(const string &dir,
  3869:                                                 string *unique_name) {
  3869:   CFUUIDRef uuid = CFUUIDCreate(NULL);
  3869:   CFStringRef uuid_cfstr = CFUUIDCreateString(NULL, uuid);
  3869:   CFRelease(uuid);
  3869:   string file_name(ConvertToString(uuid_cfstr));
  3869:   CFRelease(uuid_cfstr);
  3869:   string path(dir);
  3869: 
  3869:   // Ensure that the directory (if non-empty) has a trailing slash so that
  3869:   // we can append the file name and have a valid pathname.
  3869:   if (!dir.empty()) {
  3869:     if (dir.at(dir.size() - 1) != '/')
  3869:       path.append(1, '/');
  3869:   }
  3869: 
  3869:   path.append(file_name);
  3869:   path.append(".dmp");
  3869: 
  3869:   if (unique_name)
  3869:     *unique_name = file_name;
  3869: 
  3869:   return path;
  3869: }
  3869: 
  3869: bool MinidumpGenerator::Write(const char *path) {
  3869:   WriteStreamFN writers[] = {
  3869:     &MinidumpGenerator::WriteThreadListStream,
 54618:     &MinidumpGenerator::WriteMemoryListStream,
  3869:     &MinidumpGenerator::WriteSystemInfoStream,
  3869:     &MinidumpGenerator::WriteModuleListStream,
  3869:     &MinidumpGenerator::WriteMiscInfoStream,
  3869:     &MinidumpGenerator::WriteBreakpadInfoStream,
  3869:     // Exception stream needs to be the last entry in this array as it may
  3869:     // be omitted in the case where the minidump is written without an
  3869:     // exception.
  3869:     &MinidumpGenerator::WriteExceptionStream,
  3869:   };
 32241:   bool result = false;
  3869: 
  3869:   // If opening was successful, create the header, directory, and call each
  3869:   // writer.  The destructor for the TypedMDRVAs will cause the data to be
  3869:   // flushed.  The destructor for the MinidumpFileWriter will close the file.
  3869:   if (writer_.Open(path)) {
  3869:     TypedMDRVA<MDRawHeader> header(&writer_);
  3869:     TypedMDRVA<MDRawDirectory> dir(&writer_);
  3869: 
  3869:     if (!header.Allocate())
  3869:       return false;
  3869: 
 50677:     int writer_count = static_cast<int>(sizeof(writers) / sizeof(writers[0]));
  3869: 
  3869:     // If we don't have exception information, don't write out the
  3869:     // exception stream
  3869:     if (!exception_thread_ && !exception_type_)
  3869:       --writer_count;
  3869: 
  3869:     // Add space for all writers
  3869:     if (!dir.AllocateArray(writer_count))
  3869:       return false;
  3869: 
  3869:     MDRawHeader *header_ptr = header.get();
  3869:     header_ptr->signature = MD_HEADER_SIGNATURE;
  3869:     header_ptr->version = MD_HEADER_VERSION;
  3869:     time(reinterpret_cast<time_t *>(&(header_ptr->time_date_stamp)));
  3869:     header_ptr->stream_count = writer_count;
  3869:     header_ptr->stream_directory_rva = dir.position();
  3869: 
  3869:     MDRawDirectory local_dir;
 32241:     result = true;
  3869:     for (int i = 0; (result) && (i < writer_count); ++i) {
  3869:       result = (this->*writers[i])(&local_dir);
  3869: 
  3869:       if (result)
  3869:         dir.CopyIndex(i, &local_dir);
  3869:     }
  3869:   }
  3869:   return result;
  3869: }
  3869: 
 22509: size_t MinidumpGenerator::CalculateStackSize(mach_vm_address_t start_addr) {
 22509:   mach_vm_address_t stack_region_base = start_addr;
 22509:   mach_vm_size_t stack_region_size;
  3869:   natural_t nesting_level = 0;
 22509:   vm_region_submap_info_64 submap_info;
 22509:   mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;
 22509: 
 22509:   vm_region_recurse_info_t region_info;
 22509:   region_info = reinterpret_cast<vm_region_recurse_info_t>(&submap_info);
 22509: 
 22509:   if (start_addr == 0) {
 22509:     return 0;
 22509:   }
 22509: 
  3869:   kern_return_t result =
 22509:     mach_vm_region_recurse(crashing_task_, &stack_region_base,
 22509:                            &stack_region_size, &nesting_level,
114869:                            region_info, &info_count);
  3869: 
114869:   if (result != KERN_SUCCESS || start_addr < stack_region_base) {
114869:     // Failure or stack corruption, since mach_vm_region had to go
 22509:     // higher in the process address space to find a valid region.
 22509:     return 0;
 22509:   }
  3869: 
114869:   unsigned int tag = submap_info.user_tag;
 22509: 
114869:   // If the user tag is VM_MEMORY_STACK, look for more readable regions with
114869:   // the same tag placed immediately above the computed stack region. Under
114869:   // some circumstances, the stack for thread 0 winds up broken up into
114869:   // multiple distinct abutting regions. This can happen for several reasons,
114869:   // including user code that calls setrlimit(RLIMIT_STACK, ...) or changes
114869:   // the access on stack pages by calling mprotect.
114869:   if (tag == VM_MEMORY_STACK) {
114869:     while (true) {
114869:       mach_vm_address_t next_region_base = stack_region_base +
114869:                                            stack_region_size;
114869:       mach_vm_address_t proposed_next_region_base = next_region_base;
114869:       mach_vm_size_t next_region_size;
114869:       nesting_level = 0;
114869:       info_count = VM_REGION_SUBMAP_INFO_COUNT_64;
114869:       result = mach_vm_region_recurse(crashing_task_, &next_region_base,
114869:                                       &next_region_size, &nesting_level,
114869:                                       region_info, &info_count);
114869:       if (result != KERN_SUCCESS ||
114869:           next_region_base != proposed_next_region_base ||
114869:           submap_info.user_tag != tag ||
114869:           (submap_info.protection & VM_PROT_READ) == 0) {
114869:         break;
  3869:       }
  3869: 
114869:       stack_region_size += next_region_size;
114869:     }
114869:   }
114869: 
114869:   return stack_region_base + stack_region_size - start_addr;
  3869: }
  3869: 
  3869: bool MinidumpGenerator::WriteStackFromStartAddress(
 22509:     mach_vm_address_t start_addr,
  3869:     MDMemoryDescriptor *stack_location) {
  3869:   UntypedMDRVA memory(&writer_);
 22509: 
 22509:   bool result = false;
  3869:   size_t size = CalculateStackSize(start_addr);
  3869: 
 22509:   if (size == 0) {
 22509:       // In some situations the stack address for the thread can come back 0.
 22509:       // In these cases we skip over the threads in question and stuff the
 22509:       // stack with a clearly borked value.
 22509:       start_addr = 0xDEADBEEF;
  3869:       size = 16;
 22509:       if (!memory.Allocate(size))
 22509:         return false;
 22509: 
 22509:       unsigned long long dummy_stack[2];  // Fill dummy stack with 16 bytes of
 22509:                                           // junk.
 22509:       dummy_stack[0] = 0xDEADBEEF;
 22509:       dummy_stack[1] = 0xDEADBEEF;
 22509: 
 22509:       result = memory.Copy(dummy_stack, size);
 22509:   } else {
  3869: 
  3869:     if (!memory.Allocate(size))
  3869:       return false;
  3869: 
  3897:     if (dynamic_images_) {
 59426:       vector<uint8_t> stack_memory;
 59426:       if (ReadTaskMemory(crashing_task_,
 59426:                          start_addr,
 22509:                          size,
 59426:                          stack_memory) != KERN_SUCCESS) {
 22509:         return false;
 22509:       }
 22509: 
 59426:       result = memory.Copy(&stack_memory[0], size);
  3897:     } else {
  3897:       result = memory.Copy(reinterpret_cast<const void *>(start_addr), size);
  3897:     }
 22509:   }
  3889: 
  3869:   stack_location->start_of_memory_range = start_addr;
  3869:   stack_location->memory = memory.location();
  3869: 
  3869:   return result;
  3869: }
  3869: 
  3889: bool MinidumpGenerator::WriteStack(breakpad_thread_state_data_t state,
  3869:                                    MDMemoryDescriptor *stack_location) {
 59426:   switch (cpu_type_) {
114869: #ifdef HAS_ARM_SUPPORT
114869:     case CPU_TYPE_ARM:
114869:       return WriteStackARM(state, stack_location);
114869: #endif
114869: #ifdef HAS_PPC_SUPPORT
 59426:     case CPU_TYPE_POWERPC:
 59426:       return WriteStackPPC(state, stack_location);
 59426:     case CPU_TYPE_POWERPC64:
 59426:       return WriteStackPPC64(state, stack_location);
 74574: #endif
114869: #ifdef HAS_X86_SUPPORT
 59426:     case CPU_TYPE_I386:
 59426:       return WriteStackX86(state, stack_location);
 59426:     case CPU_TYPE_X86_64:
 59426:       return WriteStackX86_64(state, stack_location);
114869: #endif
 59426:     default:
 59426:       return false;
 59426:   }
 59426: }
 59426: 
 59426: bool MinidumpGenerator::WriteContext(breakpad_thread_state_data_t state,
 59426:                                      MDLocationDescriptor *register_location) {
 59426:   switch (cpu_type_) {
114869: #ifdef HAS_ARM_SUPPORT
114869:     case CPU_TYPE_ARM:
114869:       return WriteContextARM(state, register_location);
114869: #endif
 74574: #ifdef HAS_PPC_SUPPORT
 59426:     case CPU_TYPE_POWERPC:
 59426:       return WriteContextPPC(state, register_location);
 59426:     case CPU_TYPE_POWERPC64:
 59426:       return WriteContextPPC64(state, register_location);
 74574: #endif
114869: #ifdef HAS_X86_SUPPORT
 59426:     case CPU_TYPE_I386:
 59426:       return WriteContextX86(state, register_location);
 59426:     case CPU_TYPE_X86_64:
 59426:       return WriteContextX86_64(state, register_location);
114869: #endif
 59426:     default:
 59426:       return false;
 59426:   }
 59426: }
 59426: 
 59426: u_int64_t MinidumpGenerator::CurrentPCForStack(
 59426:     breakpad_thread_state_data_t state) {
 59426:   switch (cpu_type_) {
114869: #ifdef HAS_ARM_SUPPORT
114869:     case CPU_TYPE_ARM:
114869:       return CurrentPCForStackARM(state);
114869: #endif
 74574: #ifdef HAS_PPC_SUPPORT
 59426:     case CPU_TYPE_POWERPC:
 59426:       return CurrentPCForStackPPC(state);
 59426:     case CPU_TYPE_POWERPC64:
 59426:       return CurrentPCForStackPPC64(state);
 74574: #endif
114869: #ifdef HAS_X86_SUPPORT
 59426:     case CPU_TYPE_I386:
 59426:       return CurrentPCForStackX86(state);
 59426:     case CPU_TYPE_X86_64:
 59426:       return CurrentPCForStackX86_64(state);
114869: #endif
 59426:     default:
114869:       assert(0 && "Unknown CPU type!");
 59426:       return 0;
 59426:   }
 59426: }
 59426: 
114869: #ifdef HAS_ARM_SUPPORT
114869: bool MinidumpGenerator::WriteStackARM(breakpad_thread_state_data_t state,
114869:                                       MDMemoryDescriptor *stack_location) {
114869:   arm_thread_state_t *machine_state =
114869:       reinterpret_cast<arm_thread_state_t *>(state);
114869:   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, sp);
114869:   return WriteStackFromStartAddress(start_addr, stack_location);
114869: }
114869: 
114869: u_int64_t
114869: MinidumpGenerator::CurrentPCForStackARM(breakpad_thread_state_data_t state) {
114869:   arm_thread_state_t *machine_state =
114869:       reinterpret_cast<arm_thread_state_t *>(state);
114869: 
114869:   return REGISTER_FROM_THREADSTATE(machine_state, pc);
114869: }
114869: 
114869: bool MinidumpGenerator::WriteContextARM(breakpad_thread_state_data_t state,
114869:                                         MDLocationDescriptor *register_location)
114869: {
114869:   TypedMDRVA<MDRawContextARM> context(&writer_);
114869:   arm_thread_state_t *machine_state =
114869:       reinterpret_cast<arm_thread_state_t *>(state);
114869: 
114869:   if (!context.Allocate())
114869:     return false;
114869: 
114869:   *register_location = context.location();
114869:   MDRawContextARM *context_ptr = context.get();
114869:   context_ptr->context_flags = MD_CONTEXT_ARM_FULL;
114869: 
114869: #define AddGPR(a) context_ptr->iregs[a] = REGISTER_FROM_THREADSTATE(machine_state, r[a])
114869: 
114869:   context_ptr->iregs[13] = REGISTER_FROM_THREADSTATE(machine_state, sp);
114869:   context_ptr->iregs[14] = REGISTER_FROM_THREADSTATE(machine_state, lr);
114869:   context_ptr->iregs[15] = REGISTER_FROM_THREADSTATE(machine_state, pc);
114869:   context_ptr->cpsr = REGISTER_FROM_THREADSTATE(machine_state, cpsr);
114869: 
114869:   AddGPR(0);
114869:   AddGPR(1);
114869:   AddGPR(2);
114869:   AddGPR(3);
114869:   AddGPR(4);
114869:   AddGPR(5);
114869:   AddGPR(6);
114869:   AddGPR(7);
114869:   AddGPR(8);
114869:   AddGPR(9);
114869:   AddGPR(10);
114869:   AddGPR(11);
114869:   AddGPR(12);
114869: #undef AddReg
114869: #undef AddGPR
114869: 
114869:   return true;
114869: }
114869: #endif
114869: 
 74574: #ifdef HAS_PCC_SUPPORT
 59426: bool MinidumpGenerator::WriteStackPPC(breakpad_thread_state_data_t state,
 59426:                                       MDMemoryDescriptor *stack_location) {
 59426:   ppc_thread_state_t *machine_state =
 59426:       reinterpret_cast<ppc_thread_state_t *>(state);
 59426:   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, r1);
 59426:   return WriteStackFromStartAddress(start_addr, stack_location);
 59426: }
 59426: 
 59426: bool MinidumpGenerator::WriteStackPPC64(breakpad_thread_state_data_t state,
 59426:                                         MDMemoryDescriptor *stack_location) {
 59426:   ppc_thread_state64_t *machine_state =
 59426:       reinterpret_cast<ppc_thread_state64_t *>(state);
 32506:   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, r1);
  3869:   return WriteStackFromStartAddress(start_addr, stack_location);
  3869: }
  3869: 
 22509: u_int64_t
 59426: MinidumpGenerator::CurrentPCForStackPPC(breakpad_thread_state_data_t state) {
 59426:   ppc_thread_state_t *machine_state =
 59426:       reinterpret_cast<ppc_thread_state_t *>(state);
  3869: 
 32506:   return REGISTER_FROM_THREADSTATE(machine_state, srr0);
  3869: }
  3869: 
 59426: u_int64_t
 59426: MinidumpGenerator::CurrentPCForStackPPC64(breakpad_thread_state_data_t state) {
 59426:   ppc_thread_state64_t *machine_state =
 59426:       reinterpret_cast<ppc_thread_state64_t *>(state);
 59426: 
 59426:   return REGISTER_FROM_THREADSTATE(machine_state, srr0);
 59426: }
 59426: 
 59426: bool MinidumpGenerator::WriteContextPPC(breakpad_thread_state_data_t state,
 59426:                                         MDLocationDescriptor *register_location)
 59426: {
 59426:   TypedMDRVA<MDRawContextPPC> context(&writer_);
 59426:   ppc_thread_state_t *machine_state =
 59426:       reinterpret_cast<ppc_thread_state_t *>(state);
  3869: 
  3869:   if (!context.Allocate())
  3869:     return false;
  3869: 
  3869:   *register_location = context.location();
 59426:   MDRawContextPPC *context_ptr = context.get();
  3869:   context_ptr->context_flags = MD_CONTEXT_PPC_BASE;
  3869: 
 32506: #define AddReg(a) context_ptr->a = REGISTER_FROM_THREADSTATE(machine_state, a)
 32506: #define AddGPR(a) context_ptr->gpr[a] = REGISTER_FROM_THREADSTATE(machine_state, r ## a)
 22509: 
  3869:   AddReg(srr0);
  3869:   AddReg(cr);
  3869:   AddReg(xer);
  3869:   AddReg(ctr);
  3869:   AddReg(lr);
  3869:   AddReg(vrsave);
  3869: 
  3869:   AddGPR(0);
  3869:   AddGPR(1);
  3869:   AddGPR(2);
  3869:   AddGPR(3);
  3869:   AddGPR(4);
  3869:   AddGPR(5);
  3869:   AddGPR(6);
  3869:   AddGPR(7);
  3869:   AddGPR(8);
  3869:   AddGPR(9);
  3869:   AddGPR(10);
  3869:   AddGPR(11);
  3869:   AddGPR(12);
  3869:   AddGPR(13);
  3869:   AddGPR(14);
  3869:   AddGPR(15);
  3869:   AddGPR(16);
  3869:   AddGPR(17);
  3869:   AddGPR(18);
  3869:   AddGPR(19);
  3869:   AddGPR(20);
  3869:   AddGPR(21);
  3869:   AddGPR(22);
  3869:   AddGPR(23);
  3869:   AddGPR(24);
  3869:   AddGPR(25);
  3869:   AddGPR(26);
  3869:   AddGPR(27);
  3869:   AddGPR(28);
  3869:   AddGPR(29);
  3869:   AddGPR(30);
  3869:   AddGPR(31);
 22509:   AddReg(mq);
 59426: #undef AddReg
 59426: #undef AddGPR
 22509: 
  3869:   return true;
  3869: }
  3869: 
 59426: bool MinidumpGenerator::WriteContextPPC64(
 59426:     breakpad_thread_state_data_t state,
  3869:     MDLocationDescriptor *register_location) {
 59426:   TypedMDRVA<MDRawContextPPC64> context(&writer_);
 59426:   ppc_thread_state64_t *machine_state =
 59426:       reinterpret_cast<ppc_thread_state64_t *>(state);
  3869: 
  3869:   if (!context.Allocate())
  3869:     return false;
  3869: 
  3869:   *register_location = context.location();
 59426:   MDRawContextPPC64 *context_ptr = context.get();
 59426:   context_ptr->context_flags = MD_CONTEXT_PPC_BASE;
 22509: 
 32241: #define AddReg(a) context_ptr->a = REGISTER_FROM_THREADSTATE(machine_state, a)
 59426: #define AddGPR(a) context_ptr->gpr[a] = REGISTER_FROM_THREADSTATE(machine_state, r ## a)
 59426: 
 59426:   AddReg(srr0);
 59426:   AddReg(cr);
 59426:   AddReg(xer);
 59426:   AddReg(ctr);
 59426:   AddReg(lr);
 59426:   AddReg(vrsave);
 59426: 
 59426:   AddGPR(0);
 59426:   AddGPR(1);
 59426:   AddGPR(2);
 59426:   AddGPR(3);
 59426:   AddGPR(4);
 59426:   AddGPR(5);
 59426:   AddGPR(6);
 59426:   AddGPR(7);
 59426:   AddGPR(8);
 59426:   AddGPR(9);
 59426:   AddGPR(10);
 59426:   AddGPR(11);
 59426:   AddGPR(12);
 59426:   AddGPR(13);
 59426:   AddGPR(14);
 59426:   AddGPR(15);
 59426:   AddGPR(16);
 59426:   AddGPR(17);
 59426:   AddGPR(18);
 59426:   AddGPR(19);
 59426:   AddGPR(20);
 59426:   AddGPR(21);
 59426:   AddGPR(22);
 59426:   AddGPR(23);
 59426:   AddGPR(24);
 59426:   AddGPR(25);
 59426:   AddGPR(26);
 59426:   AddGPR(27);
 59426:   AddGPR(28);
 59426:   AddGPR(29);
 59426:   AddGPR(30);
 59426:   AddGPR(31);
 59426: #undef AddReg
 59426: #undef AddGPR
 59426: 
 59426:   return true;
 59426: }
 59426: 
 74574: #endif
 74574: 
114869: #ifdef HAS_X86_SUPPORT
 59426: bool MinidumpGenerator::WriteStackX86(breakpad_thread_state_data_t state,
 59426:                                    MDMemoryDescriptor *stack_location) {
 59426:   i386_thread_state_t *machine_state =
 59426:       reinterpret_cast<i386_thread_state_t *>(state);
 59426: 
 59426:   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, esp);
 59426:   return WriteStackFromStartAddress(start_addr, stack_location);
 59426: }
 59426: 
 59426: bool MinidumpGenerator::WriteStackX86_64(breakpad_thread_state_data_t state,
 59426:                                          MDMemoryDescriptor *stack_location) {
 59426:   x86_thread_state64_t *machine_state =
 59426:       reinterpret_cast<x86_thread_state64_t *>(state);
 59426: 
 59426:   mach_vm_address_t start_addr = REGISTER_FROM_THREADSTATE(machine_state, rsp);
 59426:   return WriteStackFromStartAddress(start_addr, stack_location);
 59426: }
 59426: 
 59426: u_int64_t
 59426: MinidumpGenerator::CurrentPCForStackX86(breakpad_thread_state_data_t state) {
 59426:   i386_thread_state_t *machine_state =
 59426:       reinterpret_cast<i386_thread_state_t *>(state);
 59426: 
 59426:   return REGISTER_FROM_THREADSTATE(machine_state, eip);
 59426: }
 59426: 
 59426: u_int64_t
 59426: MinidumpGenerator::CurrentPCForStackX86_64(breakpad_thread_state_data_t state) {
 59426:   x86_thread_state64_t *machine_state =
 59426:       reinterpret_cast<x86_thread_state64_t *>(state);
 59426: 
 59426:   return REGISTER_FROM_THREADSTATE(machine_state, rip);
 59426: }
 59426: 
 59426: bool MinidumpGenerator::WriteContextX86(breakpad_thread_state_data_t state,
 59426:                                         MDLocationDescriptor *register_location)
 59426: {
 59426:   TypedMDRVA<MDRawContextX86> context(&writer_);
 59426:   i386_thread_state_t *machine_state =
 59426:       reinterpret_cast<i386_thread_state_t *>(state);
 59426: 
 59426:   if (!context.Allocate())
 59426:     return false;
 59426: 
 59426:   *register_location = context.location();
 59426:   MDRawContextX86 *context_ptr = context.get();
 59426: 
 59426: #define AddReg(a) context_ptr->a = REGISTER_FROM_THREADSTATE(machine_state, a)
 59426: 
  3869:   context_ptr->context_flags = MD_CONTEXT_X86;
 22509:   AddReg(eax);
 22509:   AddReg(ebx);
 22509:   AddReg(ecx);
 22509:   AddReg(edx);
 22509:   AddReg(esi);
 22509:   AddReg(edi);
 22509:   AddReg(ebp);
 22509:   AddReg(esp);
 22509: 
  3869:   AddReg(cs);
  3869:   AddReg(ds);
  3869:   AddReg(ss);
  3869:   AddReg(es);
  3869:   AddReg(fs);
  3869:   AddReg(gs);
  3869:   AddReg(eflags);
  3869: 
  3869:   AddReg(eip);
114869: #undef AddReg
 59426: 
 59426:   return true;
 59426: }
 59426: 
 59426: bool MinidumpGenerator::WriteContextX86_64(
 59426:     breakpad_thread_state_data_t state,
 59426:     MDLocationDescriptor *register_location) {
 59426:   TypedMDRVA<MDRawContextAMD64> context(&writer_);
 59426:   x86_thread_state64_t *machine_state =
 59426:       reinterpret_cast<x86_thread_state64_t *>(state);
 59426: 
 59426:   if (!context.Allocate())
 59426:     return false;
 59426: 
 59426:   *register_location = context.location();
 59426:   MDRawContextAMD64 *context_ptr = context.get();
 59426: 
 59426: #define AddReg(a) context_ptr->a = REGISTER_FROM_THREADSTATE(machine_state, a)
 59426: 
 22509:   context_ptr->context_flags = MD_CONTEXT_AMD64;
 22509:   AddReg(rax);
 22509:   AddReg(rbx);
 22509:   AddReg(rcx);
 22509:   AddReg(rdx);
 22509:   AddReg(rdi);
 22509:   AddReg(rsi);
 22509:   AddReg(rbp);
 22509:   AddReg(rsp);
 22509:   AddReg(r8);
 22509:   AddReg(r9);
 22509:   AddReg(r10);
 22509:   AddReg(r11);
 22509:   AddReg(r12);
 22509:   AddReg(r13);
 22509:   AddReg(r14);
 22509:   AddReg(r15);
 22509:   AddReg(rip);
 22509:   // according to AMD's software developer guide, bits above 18 are
 22509:   // not used in the flags register.  Since the minidump format
 22509:   // specifies 32 bits for the flags register, we can truncate safely
 22509:   // with no loss.
 59426:   context_ptr->eflags = static_cast<u_int32_t>(REGISTER_FROM_THREADSTATE(machine_state, rflags));
 22509:   AddReg(cs);
 22509:   AddReg(fs);
 22509:   AddReg(gs);
114869: #undef AddReg
 22509: 
  3869:   return true;
  3869: }
114869: #endif
 59426: 
 59426: bool MinidumpGenerator::GetThreadState(thread_act_t target_thread,
 59426:                                        thread_state_t state,
 59426:                                        mach_msg_type_number_t *count) {
114869:   if (task_context_ && target_thread == mach_thread_self()) {
114869:     switch (cpu_type_) {
114869: #ifdef HAS_ARM_SUPPORT
114869:       case CPU_TYPE_ARM: {
114869:         size_t final_size =
114869:             std::min(static_cast<size_t>(*count), sizeof(arm_thread_state_t));
114869:         memcpy(state, &task_context_->uc_mcontext->__ss, final_size);
114869:         *count = final_size;
114869:         return true;
114869:       }
114869: #endif
114869:     }
114869:   }
 59426:   thread_state_flavor_t flavor;
 59426:   switch (cpu_type_) {
114869: #ifdef HAS_ARM_SUPPORT
114869:     case CPU_TYPE_ARM:
114869:       flavor = ARM_THREAD_STATE;
114869:       break;
114869: #endif
 74574: #ifdef HAS_PPC_SUPPORT
 59426:     case CPU_TYPE_POWERPC:
 59426:       flavor = PPC_THREAD_STATE;
 59426:       break;
 59426:     case CPU_TYPE_POWERPC64:
 59426:       flavor = PPC_THREAD_STATE64;
 59426:       break;
 74574: #endif
114869: #ifdef HAS_X86_SUPPORT
 59426:     case CPU_TYPE_I386:
 59426:       flavor = i386_THREAD_STATE;
 59426:       break;
 59426:     case CPU_TYPE_X86_64:
 59426:       flavor = x86_THREAD_STATE64;
 59426:       break;
114869: #endif
 59426:     default:
 59426:       return false;
 59426:   }
 59426:   return thread_get_state(target_thread, flavor,
 59426:                           state, count) == KERN_SUCCESS;
 59426: }
  3869: 
  3869: bool MinidumpGenerator::WriteThreadStream(mach_port_t thread_id,
  3869:                                           MDRawThread *thread) {
  3889:   breakpad_thread_state_data_t state;
 50677:   mach_msg_type_number_t state_count
 50677:       = static_cast<mach_msg_type_number_t>(sizeof(state));
  3869: 
 59426:   if (GetThreadState(thread_id, state, &state_count)) {
  3869:     if (!WriteStack(state, &thread->stack))
  3869:       return false;
  3869: 
 54618:     memory_blocks_.push_back(thread->stack);
 54618: 
  3869:     if (!WriteContext(state, &thread->thread_context))
  3869:       return false;
  3869: 
  3869:     thread->thread_id = thread_id;
  3869:   } else {
  3869:     return false;
  3869:   }
  3869: 
  3869:   return true;
  3869: }
  3869: 
  3869: bool MinidumpGenerator::WriteThreadListStream(
  3869:     MDRawDirectory *thread_list_stream) {
  3869:   TypedMDRVA<MDRawThreadList> list(&writer_);
  3869:   thread_act_port_array_t threads_for_task;
  3869:   mach_msg_type_number_t thread_count;
  3869:   int non_generator_thread_count;
  3869: 
  3889:   if (task_threads(crashing_task_, &threads_for_task, &thread_count))
  3869:     return false;
  3869: 
  3869:   // Don't include the generator thread
 50677:   if (handler_thread_ != MACH_PORT_NULL)
  3869:     non_generator_thread_count = thread_count - 1;
 50677:   else
 50677:     non_generator_thread_count = thread_count;
  3869:   if (!list.AllocateObjectAndArray(non_generator_thread_count,
  3869:                                    sizeof(MDRawThread)))
  3869:     return false;
  3869: 
  3869:   thread_list_stream->stream_type = MD_THREAD_LIST_STREAM;
  3869:   thread_list_stream->location = list.location();
  3869: 
  3869:   list.get()->number_of_threads = non_generator_thread_count;
  3869: 
  3869:   MDRawThread thread;
  3869:   int thread_idx = 0;
  3869: 
  3869:   for (unsigned int i = 0; i < thread_count; ++i) {
  3869:     memset(&thread, 0, sizeof(MDRawThread));
  3869: 
  3889:     if (threads_for_task[i] != handler_thread_) {
  3869:       if (!WriteThreadStream(threads_for_task[i], &thread))
  3869:         return false;
  3869: 
  3869:       list.CopyIndexAfterObject(thread_idx++, &thread, sizeof(MDRawThread));
  3869:     }
  3869:   }
  3869: 
  3869:   return true;
  3869: }
  3869: 
 54618: bool MinidumpGenerator::WriteMemoryListStream(
 54618:     MDRawDirectory *memory_list_stream) {
 54618:   TypedMDRVA<MDRawMemoryList> list(&writer_);
 54618: 
 54618:   // If the dump has an exception, include some memory around the
 54618:   // instruction pointer.
 54618:   const size_t kIPMemorySize = 256;  // bytes
 54618:   bool have_ip_memory = false;
 54618:   MDMemoryDescriptor ip_memory_d;
 54618:   if (exception_thread_ && exception_type_) {
 54618:     breakpad_thread_state_data_t state;
 54618:     mach_msg_type_number_t stateCount
 54618:       = static_cast<mach_msg_type_number_t>(sizeof(state));
 54618: 
114869:     if (GetThreadState(exception_thread_, state, &stateCount)) {
 54618:       u_int64_t ip = CurrentPCForStack(state);
 54618:       // Bound it to the upper and lower bounds of the region
 54618:       // it's contained within. If it's not in a known memory region,
 54618:       // don't bother trying to write it.
114869:       mach_vm_address_t addr = static_cast<vm_address_t>(ip);
 54618:       mach_vm_size_t size;
 54618:       natural_t nesting_level = 0;
 54618:       vm_region_submap_info_64 info;
 54618:       mach_msg_type_number_t info_count = VM_REGION_SUBMAP_INFO_COUNT_64;
114869:       vm_region_recurse_info_t recurse_info;
114869:       recurse_info = reinterpret_cast<vm_region_recurse_info_t>(&info);
 54618: 
 54618:       kern_return_t ret =
 54618:         mach_vm_region_recurse(crashing_task_,
 54618:                                &addr,
 54618:                                &size,
 54618:                                &nesting_level,
114869:                                recurse_info,
 54618:                                &info_count);
 54618:       if (ret == KERN_SUCCESS && ip >= addr && ip < (addr + size)) {
 54618:         // Try to get 128 bytes before and after the IP, but
 54618:         // settle for whatever's available.
 54618:         ip_memory_d.start_of_memory_range =
 54618:           std::max(uintptr_t(addr),
 54618:                    uintptr_t(ip - (kIPMemorySize / 2)));
 54618:         uintptr_t end_of_range = 
 54618:           std::min(uintptr_t(ip + (kIPMemorySize / 2)),
 54618:                    uintptr_t(addr + size));
 54618:         ip_memory_d.memory.data_size =
114869:             end_of_range -
114869:             static_cast<uintptr_t>(ip_memory_d.start_of_memory_range);
 54618:         have_ip_memory = true;
 54618:         // This needs to get appended to the list even though
 54618:         // the memory bytes aren't filled in yet so the entire
 54618:         // list can be written first. The memory bytes will get filled
 54618:         // in after the memory list is written.
 54618:         memory_blocks_.push_back(ip_memory_d);
 54618:       }
 54618:     }
 54618:   }
 54618: 
 54618:   // Now fill in the memory list and write it.
 54618:   unsigned memory_count = memory_blocks_.size();
 54618:   if (!list.AllocateObjectAndArray(memory_count,
 54618:                                    sizeof(MDMemoryDescriptor)))
 54618:     return false;
 54618: 
 54618:   memory_list_stream->stream_type = MD_MEMORY_LIST_STREAM;
 54618:   memory_list_stream->location = list.location();
 54618: 
 54618:   list.get()->number_of_memory_ranges = memory_count;
 54618: 
 54618:   unsigned int i;
 54618:   for (i = 0; i < memory_count; ++i) {
 58373:     list.CopyIndexAfterObject(i, &memory_blocks_[i],
 54618:                               sizeof(MDMemoryDescriptor));
 54618:   }
 54618: 
 54618:   if (have_ip_memory) {
 54618:     // Now read the memory around the instruction pointer.
 54618:     UntypedMDRVA ip_memory(&writer_);
 54618:     if (!ip_memory.Allocate(ip_memory_d.memory.data_size))
 54618:       return false;
 54618: 
 54618:     if (dynamic_images_) {
 54618:       // Out-of-process.
 59426:       vector<uint8_t> memory;
 59426:       if (ReadTaskMemory(crashing_task_,
 59426:                          ip_memory_d.start_of_memory_range,
 54618:                          ip_memory_d.memory.data_size,
 59426:                          memory) != KERN_SUCCESS) {
 54618:         return false;
 54618:       }
 54618: 
 59426:       ip_memory.Copy(&memory[0], ip_memory_d.memory.data_size);
 54618:     } else {
 54618:       // In-process, just copy from local memory.
 54618:       ip_memory.Copy(
 54618:         reinterpret_cast<const void *>(ip_memory_d.start_of_memory_range),
 54618:         ip_memory_d.memory.data_size);
 54618:     }
 54618: 
 54618:     ip_memory_d.memory = ip_memory.location();
 54618:     // Write this again now that the data location is filled in.
 54618:     list.CopyIndexAfterObject(i - 1, &ip_memory_d,
 54618:                               sizeof(MDMemoryDescriptor));
 54618:   }
 54618: 
 54618:   return true;
 54618: }
 54618: 
 22509: bool
 22509: MinidumpGenerator::WriteExceptionStream(MDRawDirectory *exception_stream) {
  3869:   TypedMDRVA<MDRawExceptionStream> exception(&writer_);
  3869: 
  3869:   if (!exception.Allocate())
  3869:     return false;
  3869: 
  3869:   exception_stream->stream_type = MD_EXCEPTION_STREAM;
  3869:   exception_stream->location = exception.location();
  3869:   MDRawExceptionStream *exception_ptr = exception.get();
  3869:   exception_ptr->thread_id = exception_thread_;
  3869: 
  3869:   // This naming is confusing, but it is the proper translation from
  3869:   // mach naming to minidump naming.
  3869:   exception_ptr->exception_record.exception_code = exception_type_;
  3869:   exception_ptr->exception_record.exception_flags = exception_code_;
  3869: 
  3889:   breakpad_thread_state_data_t state;
 59426:   mach_msg_type_number_t state_count
 50677:       = static_cast<mach_msg_type_number_t>(sizeof(state));
  3869: 
 59426:   if (!GetThreadState(exception_thread_, state, &state_count))
  3869:     return false;
  3869: 
  3869:   if (!WriteContext(state, &exception_ptr->thread_context))
  3869:     return false;
  3869: 
 32241:   if (exception_type_ == EXC_BAD_ACCESS)
 32241:     exception_ptr->exception_record.exception_address = exception_subcode_;
 32241:   else
  3869:     exception_ptr->exception_record.exception_address = CurrentPCForStack(state);
  3869: 
  3869:   return true;
  3869: }
  3869: 
  3869: bool MinidumpGenerator::WriteSystemInfoStream(
  3869:     MDRawDirectory *system_info_stream) {
  3869:   TypedMDRVA<MDRawSystemInfo> info(&writer_);
  3869: 
  3869:   if (!info.Allocate())
  3869:     return false;
  3869: 
  3869:   system_info_stream->stream_type = MD_SYSTEM_INFO_STREAM;
  3869:   system_info_stream->location = info.location();
  3869: 
  3869:   // CPU Information
  3869:   uint32_t number_of_processors;
 59426:   size_t len = sizeof(number_of_processors);
  3869:   sysctlbyname("hw.ncpu", &number_of_processors, &len, NULL, 0);
  3869:   MDRawSystemInfo *info_ptr = info.get();
  3869: 
 59426:   switch (cpu_type_) {
114869: #ifdef HAS_ARM_SUPPORT
114869:     case CPU_TYPE_ARM:
114869:       info_ptr->processor_architecture = MD_CPU_ARCHITECTURE_ARM;
114869:       break;
114869: #endif
114869: #ifdef HAS_PPC_SUPPORT
  3869:     case CPU_TYPE_POWERPC:
 59426:     case CPU_TYPE_POWERPC64:
  3869:       info_ptr->processor_architecture = MD_CPU_ARCHITECTURE_PPC;
  3869:       break;
114869: #endif
114869: #ifdef HAS_X86_SUPPORT
  3869:     case CPU_TYPE_I386:
 47243:     case CPU_TYPE_X86_64:
 59426:       if (cpu_type_ == CPU_TYPE_I386)
 59426:         info_ptr->processor_architecture = MD_CPU_ARCHITECTURE_X86;
 59426:       else
 59426:         info_ptr->processor_architecture = MD_CPU_ARCHITECTURE_AMD64;
 47243: #ifdef __i386__
  3897:       // ebx is used for PIC code, so we need
  3897:       // to preserve it.
  3897: #define cpuid(op,eax,ebx,ecx,edx)      \
  3897:   asm ("pushl %%ebx   \n\t"            \
  3897:        "cpuid         \n\t"            \
  3897:        "movl %%ebx,%1 \n\t"            \
  3897:        "popl %%ebx"                    \
  3897:        : "=a" (eax),                   \
  3897:          "=g" (ebx),                   \
  3897:          "=c" (ecx),                   \
  3897:          "=d" (edx)                    \
  3897:        : "0" (op))
 47243: #elif defined(__x86_64__)
 59426: 
 47243: #define cpuid(op,eax,ebx,ecx,edx)      \
 47243:   asm ("cpuid         \n\t"            \
 47243:        : "=a" (eax),                   \
 47243:          "=b" (ebx),                   \
 47243:          "=c" (ecx),                   \
 47243:          "=d" (edx)                    \
 47243:        : "0" (op))
 47243: #endif
 47243: 
 47243: #if defined(__i386__) || defined(__x86_64__)
  3897:       int unused, unused2;
  3897:       // get vendor id
  3897:       cpuid(0, unused, info_ptr->cpu.x86_cpu_info.vendor_id[0],
  3897:             info_ptr->cpu.x86_cpu_info.vendor_id[2],
  3897:             info_ptr->cpu.x86_cpu_info.vendor_id[1]);
  3897:       // get version and feature info
  3897:       cpuid(1, info_ptr->cpu.x86_cpu_info.version_information, unused, unused2,
  3897:             info_ptr->cpu.x86_cpu_info.feature_information);
 36832: 
  3897:       // family
  3897:       info_ptr->processor_level =
  3897:         (info_ptr->cpu.x86_cpu_info.version_information & 0xF00) >> 8;
  3897:       // 0xMMSS (Model, Stepping)
  3897:       info_ptr->processor_revision =
  3897:         (info_ptr->cpu.x86_cpu_info.version_information & 0xF) |
  3897:         ((info_ptr->cpu.x86_cpu_info.version_information & 0xF0) << 4);
 36832: 
 36832:       // decode extended model info
 36832:       if (info_ptr->processor_level == 0xF ||
 36832:           info_ptr->processor_level == 0x6) {
 36832:         info_ptr->processor_revision |=
 36832:           ((info_ptr->cpu.x86_cpu_info.version_information & 0xF0000) >> 4);
 36832:       }
 36832: 
 36832:       // decode extended family info
 36832:       if (info_ptr->processor_level == 0xF) {
 36832:         info_ptr->processor_level +=
 36832:           ((info_ptr->cpu.x86_cpu_info.version_information & 0xFF00000) >> 20);
 36832:       }
 36832: 
 47243: #endif  // __i386__ || __x86_64_
  3869:       break;
114869: #endif  // HAS_X86_SUPPORT
  3869:     default:
  3869:       info_ptr->processor_architecture = MD_CPU_ARCHITECTURE_UNKNOWN;
  3869:       break;
  3869:   }
  3869: 
114869:   info_ptr->number_of_processors = static_cast<uint8_t>(number_of_processors);
114869: #if TARGET_OS_IPHONE
114869:   info_ptr->platform_id = MD_OS_IOS;
114869: #else
  3869:   info_ptr->platform_id = MD_OS_MAC_OS_X;
114869: #endif  // TARGET_OS_IPHONE
  3869: 
  3869:   MDLocationDescriptor build_string_loc;
  3869: 
  3869:   if (!writer_.WriteString(build_string_, 0,
  3869:                            &build_string_loc))
  3869:     return false;
  3869: 
  3869:   info_ptr->csd_version_rva = build_string_loc.rva;
  3869:   info_ptr->major_version = os_major_version_;
  3869:   info_ptr->minor_version = os_minor_version_;
  3869:   info_ptr->build_number = os_build_number_;
  3869: 
  3869:   return true;
  3869: }
  3869: 
  3869: bool MinidumpGenerator::WriteModuleStream(unsigned int index,
  3869:                                           MDRawModule *module) {
  3897:   if (dynamic_images_) {
  3897:     // we're in a different process than the crashed process
  3889:     DynamicImage *image = dynamic_images_->GetImage(index);
  3889: 
  3889:     if (!image)
  3889:       return false;
  3889: 
  3869:     memset(module, 0, sizeof(MDRawModule));
  3869: 
  3869:     MDLocationDescriptor string_location;
  3869: 
 59426:     string name = image->GetFilePath();
 59426:     if (!writer_.WriteString(name.c_str(), 0, &string_location))
  3869:       return false;
  3869: 
  3889:     module->base_of_image = image->GetVMAddr() + image->GetVMAddrSlide();
 50677:     module->size_of_image = static_cast<u_int32_t>(image->GetVMSize());
  3869:     module->module_name_rva = string_location.rva;
  3869: 
 22509:     // We'll skip the executable module, because they don't have
 22509:     // LC_ID_DYLIB load commands, and the crash processing server gets
 22509:     // version information from the Plist file, anyway.
114869:     if (index != static_cast<uint32_t>(FindExecutableModule())) {
 22509:       module->version_info.signature = MD_VSFIXEDFILEINFO_SIGNATURE;
 22509:       module->version_info.struct_version |= MD_VSFIXEDFILEINFO_VERSION;
 22509:       // Convert MAC dylib version format, which is a 32 bit number, to the
 22509:       // format used by minidump.  The mac format is <16 bits>.<8 bits>.<8 bits>
 22509:       // so it fits nicely into the windows version with some massaging
 22509:       // The mapping is:
 22509:       //    1) upper 16 bits of MAC version go to lower 16 bits of product HI
 22509:       //    2) Next most significant 8 bits go to upper 16 bits of product LO
 22509:       //    3) Least significant 8 bits go to lower 16 bits of product LO
 22509:       uint32_t modVersion = image->GetVersion();
 22509:       module->version_info.file_version_hi = 0;
 22509:       module->version_info.file_version_hi = modVersion >> 16;
 22509:       module->version_info.file_version_lo |= (modVersion & 0xff00)  << 8;
 22509:       module->version_info.file_version_lo |= (modVersion & 0xff);
 22509:     }
 22509: 
114869:     if (!WriteCVRecord(module, image->GetCPUType(), name.c_str(), false)) {
  3869:       return false;
  3869:     }
  3897:   } else {
 59426:     // Getting module info in the crashed process
 22509:     const breakpad_mach_header *header;
 22509:     header = (breakpad_mach_header*)_dyld_get_image_header(index);
  3897:     if (!header)
  3897:       return false;
  3897: 
 22509: #ifdef __LP64__
 22509:     assert(header->magic == MH_MAGIC_64);
 22509: 
 22509:     if(header->magic != MH_MAGIC_64)
 22509:       return false;
 22509: #else
 22509:     assert(header->magic == MH_MAGIC);
 22509: 
 22509:     if(header->magic != MH_MAGIC)
 22509:       return false;
 22509: #endif
 22509: 
  3897:     int cpu_type = header->cputype;
  3897:     unsigned long slide = _dyld_get_image_vmaddr_slide(index);
  3897:     const char* name = _dyld_get_image_name(index);
  3897:     const struct load_command *cmd =
  3897:         reinterpret_cast<const struct load_command *>(header + 1);
  3897: 
  3897:     memset(module, 0, sizeof(MDRawModule));
  3897: 
  3897:     for (unsigned int i = 0; cmd && (i < header->ncmds); i++) {
 47243:       if (cmd->cmd == LC_SEGMENT_ARCH) {
 22509: 
 22509:         const breakpad_mach_segment_command *seg =
 22509:             reinterpret_cast<const breakpad_mach_segment_command *>(cmd);
 22509: 
  3897:         if (!strcmp(seg->segname, "__TEXT")) {
  3897:           MDLocationDescriptor string_location;
  3897: 
  3897:           if (!writer_.WriteString(name, 0, &string_location))
  3897:             return false;
  3897: 
  3897:           module->base_of_image = seg->vmaddr + slide;
 50677:           module->size_of_image = static_cast<u_int32_t>(seg->vmsize);
  3897:           module->module_name_rva = string_location.rva;
  3897: 
114869:           bool in_memory = false;
114869: #if TARGET_OS_IPHONE
114869:           in_memory = true;
114869: #endif
114869:           if (!WriteCVRecord(module, cpu_type, name, in_memory))
  3897:             return false;
  3897: 
  3897:           return true;
  3897:         }
  3897:       }
  3897: 
  3897:       cmd = reinterpret_cast<struct load_command*>((char *)cmd + cmd->cmdsize);
  3897:     }
  3897:   }
  3869: 
  3869:   return true;
  3869: }
  3869: 
  3889: int MinidumpGenerator::FindExecutableModule() {
  3897:   if (dynamic_images_) {
  3889:     int index = dynamic_images_->GetExecutableImageIndex();
  3869: 
  3889:     if (index >= 0) {
  3889:       return index;
  3869:     }
  3897:   } else {
  3897:     int image_count = _dyld_image_count();
  3897:     const struct mach_header *header;
  3897: 
  3897:     for (int index = 0; index < image_count; ++index) {
  3897:       header = _dyld_get_image_header(index);
  3897: 
  3897:       if (header->filetype == MH_EXECUTE)
  3897:         return index;
  3897:     }
  3897:   }
  3869: 
  3889:   // failed - just use the first image
  3869:   return 0;
  3869: }
  3869: 
  3869: bool MinidumpGenerator::WriteCVRecord(MDRawModule *module, int cpu_type,
114869:                                       const char *module_path, bool in_memory) {
  3869:   TypedMDRVA<MDCVInfoPDB70> cv(&writer_);
  3869: 
  3869:   // Only return the last path component of the full module path
  3897:   const char *module_name = strrchr(module_path, '/');
  3869: 
  3869:   // Increment past the slash
  3869:   if (module_name)
  3869:     ++module_name;
  3869:   else
  3869:     module_name = "<Unknown>";
  3869: 
  3869:   size_t module_name_length = strlen(module_name);
  3869: 
  3869:   if (!cv.AllocateObjectAndArray(module_name_length + 1, sizeof(u_int8_t)))
  3869:     return false;
  3869: 
  3869:   if (!cv.CopyIndexAfterObject(0, module_name, module_name_length))
  3869:     return false;
  3869: 
  3869:   module->cv_record = cv.location();
  3869:   MDCVInfoPDB70 *cv_ptr = cv.get();
  3869:   cv_ptr->cv_signature = MD_CVINFOPDB70_SIGNATURE;
  3869:   cv_ptr->age = 0;
  3869: 
  3869:   // Get the module identifier
114869:   unsigned char identifier[16];
114869:   bool result = false;
114869:   if (in_memory) {
114869:     MacFileUtilities::MachoID macho(module_path,
114869:         reinterpret_cast<void *>(module->base_of_image),
114869:         static_cast<size_t>(module->size_of_image));
118328:     result = macho.UUIDCommand(cpu_type, CPU_SUBTYPE_MULTIPLE, identifier);
114869:     if (!result)
118328:       result = macho.MD5(cpu_type, CPU_SUBTYPE_MULTIPLE, identifier);
114869:   }
114869: 
114869:   if (!result) {
114534:      FileID file_id(module_path);
118328:      result = file_id.MachoIdentifier(cpu_type, CPU_SUBTYPE_MULTIPLE,
118328:                                       identifier);
114869:   }
114508: 
114869:   if (result) {
114869:     cv_ptr->signature.data1 =
114869:         static_cast<uint32_t>(identifier[0]) << 24 |
114869:         static_cast<uint32_t>(identifier[1]) << 16 |
114869:         static_cast<uint32_t>(identifier[2]) << 8 |
114869:         static_cast<uint32_t>(identifier[3]);
114869:     cv_ptr->signature.data2 =
114869:         static_cast<uint16_t>(identifier[4] << 8) | identifier[5];
114869:     cv_ptr->signature.data3 =
114869:         static_cast<uint16_t>(identifier[6] << 8) | identifier[7];
  3869:     cv_ptr->signature.data4[0] = identifier[8];
  3869:     cv_ptr->signature.data4[1] = identifier[9];
  3869:     cv_ptr->signature.data4[2] = identifier[10];
  3869:     cv_ptr->signature.data4[3] = identifier[11];
  3869:     cv_ptr->signature.data4[4] = identifier[12];
  3869:     cv_ptr->signature.data4[5] = identifier[13];
  3869:     cv_ptr->signature.data4[6] = identifier[14];
  3869:     cv_ptr->signature.data4[7] = identifier[15];
  3869:   }
  3869: 
  3869:   return true;
  3869: }
  3869: 
  3869: bool MinidumpGenerator::WriteModuleListStream(
  3869:     MDRawDirectory *module_list_stream) {
  3869:   TypedMDRVA<MDRawModuleList> list(&writer_);
  3869: 
114869:   size_t image_count = dynamic_images_ ?
114869:       static_cast<size_t>(dynamic_images_->GetImageCount()) :
114869:       _dyld_image_count();
  3869: 
  3869:   if (!list.AllocateObjectAndArray(image_count, MD_MODULE_SIZE))
  3869:     return false;
  3869: 
  3869:   module_list_stream->stream_type = MD_MODULE_LIST_STREAM;
  3869:   module_list_stream->location = list.location();
  3869:   list.get()->number_of_modules = image_count;
  3869: 
  3869:   // Write out the executable module as the first one
  3869:   MDRawModule module;
114869:   size_t executableIndex = FindExecutableModule();
  3869: 
  3889:   if (!WriteModuleStream(executableIndex, &module)) {
  3869:     return false;
  3889:   }
  3869: 
  3869:   list.CopyIndexAfterObject(0, &module, MD_MODULE_SIZE);
  3869:   int destinationIndex = 1;  // Write all other modules after this one
  3869: 
114869:   for (size_t i = 0; i < image_count; ++i) {
  3869:     if (i != executableIndex) {
  3889:       if (!WriteModuleStream(i, &module)) {
  3869:         return false;
  3889:       }
  3869: 
  3869:       list.CopyIndexAfterObject(destinationIndex++, &module, MD_MODULE_SIZE);
  3869:     }
  3869:   }
  3869: 
  3869:   return true;
  3869: }
  3869: 
  3869: bool MinidumpGenerator::WriteMiscInfoStream(MDRawDirectory *misc_info_stream) {
  3869:   TypedMDRVA<MDRawMiscInfo> info(&writer_);
  3869: 
  3869:   if (!info.Allocate())
  3869:     return false;
  3869: 
  3869:   misc_info_stream->stream_type = MD_MISC_INFO_STREAM;
  3869:   misc_info_stream->location = info.location();
  3869: 
  3869:   MDRawMiscInfo *info_ptr = info.get();
 50677:   info_ptr->size_of_info = static_cast<u_int32_t>(sizeof(MDRawMiscInfo));
  3869:   info_ptr->flags1 = MD_MISCINFO_FLAGS1_PROCESS_ID |
  3869:     MD_MISCINFO_FLAGS1_PROCESS_TIMES |
  3869:     MD_MISCINFO_FLAGS1_PROCESSOR_POWER_INFO;
  3869: 
  3869:   // Process ID
  3869:   info_ptr->process_id = getpid();
  3869: 
  3869:   // Times
  3869:   struct rusage usage;
  3869:   if (getrusage(RUSAGE_SELF, &usage) != -1) {
  3869:     // Omit the fractional time since the MDRawMiscInfo only wants seconds
 50677:     info_ptr->process_user_time =
 50677:         static_cast<u_int32_t>(usage.ru_utime.tv_sec);
 50677:     info_ptr->process_kernel_time =
 50677:         static_cast<u_int32_t>(usage.ru_stime.tv_sec);
  3869:   }
114869:   int mib[4] = { CTL_KERN, KERN_PROC, KERN_PROC_PID,
114869:                  static_cast<int>(info_ptr->process_id) };
 50677:   u_int mibsize = static_cast<u_int>(sizeof(mib) / sizeof(mib[0]));
114869:   struct kinfo_proc proc;
114869:   size_t size = sizeof(proc);
114869:   if (sysctl(mib, mibsize, &proc, &size, NULL, 0) == 0) {
 50677:     info_ptr->process_create_time =
114869:         static_cast<u_int32_t>(proc.kp_proc.p_starttime.tv_sec);
  3869:   }
  3869: 
  3869:   // Speed
  3869:   uint64_t speed;
 50677:   const uint64_t kOneMillion = 1000 * 1000;
  3869:   size = sizeof(speed);
  3869:   sysctlbyname("hw.cpufrequency_max", &speed, &size, NULL, 0);
 50677:   info_ptr->processor_max_mhz = static_cast<u_int32_t>(speed / kOneMillion);
 50677:   info_ptr->processor_mhz_limit = static_cast<u_int32_t>(speed / kOneMillion);
  3869:   size = sizeof(speed);
  3869:   sysctlbyname("hw.cpufrequency", &speed, &size, NULL, 0);
 50677:   info_ptr->processor_current_mhz = static_cast<u_int32_t>(speed / kOneMillion);
  3869: 
  3869:   return true;
  3869: }
  3869: 
  3869: bool MinidumpGenerator::WriteBreakpadInfoStream(
  3869:     MDRawDirectory *breakpad_info_stream) {
  3869:   TypedMDRVA<MDRawBreakpadInfo> info(&writer_);
  3869: 
  3869:   if (!info.Allocate())
  3869:     return false;
  3869: 
  3869:   breakpad_info_stream->stream_type = MD_BREAKPAD_INFO_STREAM;
  3869:   breakpad_info_stream->location = info.location();
  3869:   MDRawBreakpadInfo *info_ptr = info.get();
  3869: 
  3869:   if (exception_thread_ && exception_type_) {
  3869:     info_ptr->validity = MD_BREAKPAD_INFO_VALID_DUMP_THREAD_ID |
  3869:                          MD_BREAKPAD_INFO_VALID_REQUESTING_THREAD_ID;
  3889:     info_ptr->dump_thread_id = handler_thread_;
  3869:     info_ptr->requesting_thread_id = exception_thread_;
  3869:   } else {
  3869:     info_ptr->validity = MD_BREAKPAD_INFO_VALID_DUMP_THREAD_ID;
  3889:     info_ptr->dump_thread_id = handler_thread_;
  3869:     info_ptr->requesting_thread_id = 0;
  3869:   }
  3869: 
  3869:   return true;
  3869: }
  3869: 
  3869: }  // namespace google_breakpad
