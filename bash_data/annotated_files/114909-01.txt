114055: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
114055: /* This Source Code Form is subject to the terms of the Mozilla Public
114055:  * License, v. 2.0. If a copy of the MPL was not distributed with this
114055:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
114055: 
114055: #include "nsMixedContentBlocker.h"
114055: #include "nsContentPolicyUtils.h"
114055: 
114055: #include "nsINode.h"
114055: #include "nsCOMPtr.h"
114055: #include "nsIDocShell.h"
114055: #include "nsISecurityEventSink.h"
114055: #include "nsIWebProgressListener.h"
114055: #include "nsContentUtils.h"
114055: #include "mozilla/Preferences.h"
114055: 
114055: using namespace mozilla;
114055: 
114055: // Is mixed script blocking (fonts, plugin content, scripts, stylesheets,
114055: // iframes, websockets, XHR) enabled?
114055: bool nsMixedContentBlocker::sBlockMixedScript = false;
114055: 
114055: // Is mixed display content blocking (images, audio, video, <a ping>) enabled?
114055: bool nsMixedContentBlocker::sBlockMixedDisplay = false;
114055: 
114055: // Fired at the document that attempted to load mixed content.  The UI could
114055: // handle this event, for example, by displaying an info bar that offers the
114055: // choice to reload the page with mixed content permitted.
114055: //
114055: // Disabled for now until bug 782654 is fixed
114055: /*
114055: class nsMixedContentBlockedEvent : public nsRunnable
114055: {
114055: public:
114055:   nsMixedContentBlockedEvent(nsISupports *aContext, unsigned short aType)
114055:     : mContext(aContext), mType(aType)
114055:   {}
114055: 
114055:   NS_IMETHOD Run()
114055:   {
114055:     NS_ASSERTION(mContext,
114055:                  "You can't call this runnable without a requesting context");
114055: 
114055:     // To update the security UI in the tab with the blocked mixed content, call
114055:     // nsISecurityEventSink::OnSecurityChange.  You can get to the event sink by
114055:     // calling NS_CP_GetDocShellFromContext on the context, and QI'ing to
114055:     // nsISecurityEventSink.
114055: 
114055:     return NS_OK;
114055:   }
114055: private:
114055:   // The requesting context for the content load. Generally, a DOM node from
114055:   // the document that caused the load.
114055:   nsCOMPtr<nsISupports> mContext;
114055: 
114055:   // The type of mixed content that was blocked, i.e. active or display
114055:   unsigned short mType;
114055: };
114055: */
114055: 
114055: nsMixedContentBlocker::nsMixedContentBlocker()
114055: {
114055:   // Cache the pref for mixed script blocking
114055:   Preferences::AddBoolVarCache(&sBlockMixedScript,
114055:                                "security.mixed_content.block_active_content");
114055: 
114055:   // Cache the pref for mixed display blocking
114055:   Preferences::AddBoolVarCache(&sBlockMixedDisplay,
114055:                                "security.mixed_content.block_display_content");
114055: }
114055: 
114055: nsMixedContentBlocker::~nsMixedContentBlocker()
114055: {
114055: }
114055: 
114055: NS_IMPL_ISUPPORTS1(nsMixedContentBlocker, nsIContentPolicy)
114055: 
114055: NS_IMETHODIMP
114849: nsMixedContentBlocker::ShouldLoad(PRUint32 aContentType,
114055:                                   nsIURI* aContentLocation,
114055:                                   nsIURI* aRequestingLocation,
114055:                                   nsISupports* aRequestingContext,
114055:                                   const nsACString& aMimeGuess,
114055:                                   nsISupports* aExtra,
114055:                                   nsIPrincipal* aRequestPrincipal,
114849:                                   PRInt16* aDecision)
114055: {
114055:   // Default policy: allow the load if we find no reason to block it.
114055:   *aDecision = nsIContentPolicy::ACCEPT;
114055: 
114055:   // If mixed script blocking and mixed display blocking are turned off
114055:   // we can return early
114055:   if (!sBlockMixedScript && !sBlockMixedDisplay) {
114055:     return NS_OK;
114055:   }
114055: 
114055:   // Top-level load cannot be mixed content so allow it
114055:   if (aContentType == nsIContentPolicy::TYPE_DOCUMENT) {
114055:     return NS_OK;
114055:   }
114055: 
114055:   // We need aRequestingLocation to pull out the scheme. If it isn't passed
114055:   // in, get it from the DOM node.
114055:   if (!aRequestingLocation) {
114055:     nsCOMPtr<nsINode> node = do_QueryInterface(aRequestingContext);
114055:     if (node) {
114055:       nsCOMPtr<nsIURI> principalUri;
114055:       node->NodePrincipal()->GetURI(getter_AddRefs(principalUri));
114055:       aRequestingLocation = principalUri;
114055:     }
114055:     // If we still don't have a requesting location then we can't tell if
114055:     // this is a mixed content load.  Deny to be safe.
114055:     if (!aRequestingLocation) {
114055:       *aDecision = nsIContentPolicy::REJECT_REQUEST;
114055:       return NS_OK;
114055:     }
114055:   }
114055: 
114055:   // Check the parent scheme. If it is not an HTTPS page then mixed content
114055:   // restrictions do not apply.
114055:   bool parentIsHttps;
114055:   if (NS_FAILED(aRequestingLocation->SchemeIs("https", &parentIsHttps)) ||
114055:       !parentIsHttps) {
114055:     return NS_OK;
114055:   }
114055: 
114055:   // Get the scheme of the sub-document resource to be requested. If it is
114055:   // an HTTPS load then mixed content doesn't apply.
114055:   bool isHttps;
114055:   if (NS_FAILED(aContentLocation->SchemeIs("https", &isHttps)) || isHttps) {
114055:     return NS_OK;
114055:   }
114055: 
114055:   // If we are here we have mixed content.
114055: 
114055:   // Decide whether or not to allow the mixed content based on what type of
114055:   // content it is and if the user permitted it.
114055:   switch (aContentType) {
114055:     case nsIContentPolicy::TYPE_FONT:
114055:     case nsIContentPolicy::TYPE_OBJECT:
114055:     case nsIContentPolicy::TYPE_SCRIPT:
114055:     case nsIContentPolicy::TYPE_STYLESHEET:
114055:     case nsIContentPolicy::TYPE_SUBDOCUMENT:
114055:     case nsIContentPolicy::TYPE_WEBSOCKET:
114055:     case nsIContentPolicy::TYPE_XMLHTTPREQUEST:
114055:       // fonts, plugin content, scripts, stylesheets, iframes, websockets and
114055:       // XHRs are considered high risk for mixed content so these are blocked
114055:       // per the mixed script preference
114055:       if (sBlockMixedScript) {
114055:         *aDecision = nsIContentPolicy::REJECT_REQUEST;
114055: 
114055:         // Fire the event from a script runner as it is unsafe to run script
114055:         // from within ShouldLoad
114055:         // Disabled until bug 782654 is fixed.
114055:         /*
114055:         nsContentUtils::AddScriptRunner(
114055:           new nsMixedContentBlockedEvent(aRequestingContext, eBlockedMixedScript));
114055:         */
114055:       }
114055:       break;
114055: 
114055:     case nsIContentPolicy::TYPE_IMAGE:
114055:     case nsIContentPolicy::TYPE_MEDIA:
114055:     case nsIContentPolicy::TYPE_PING:
114055:       // display (static) content are considered moderate risk for mixed content
114055:       // so these will be blocked according to the mixed display preference
114055:       if (sBlockMixedDisplay) {
114055:         *aDecision = nsIContentPolicy::REJECT_REQUEST;
114055: 
114055:         // Fire the event from a script runner as it is unsafe to run script
114055:         // from within ShouldLoad
114055:         // Disabled until bug 782654 is fixed.
114055:         /*
114055:         nsContentUtils::AddScriptRunner(
114055:           new nsMixedContentBlockedEvent(aRequestingContext, eBlockedMixedDisplay));
114055:         */
114055:       }
114055:       break;
114055: 
114055:     default:
114055:       // other types of mixed content are allowed
114055:       break;
114055:   }
114055: 
114055:   return NS_OK;
114055: }
114055: 
114055: NS_IMETHODIMP
114849: nsMixedContentBlocker::ShouldProcess(PRUint32 aContentType,
114055:                                      nsIURI* aContentLocation,
114055:                                      nsIURI* aRequestingLocation,
114055:                                      nsISupports* aRequestingContext,
114055:                                      const nsACString& aMimeGuess,
114055:                                      nsISupports* aExtra,
114055:                                      nsIPrincipal* aRequestPrincipal,
114849:                                      PRInt16* aDecision)
114055: {
114909:   if(!aContentLocation) {
114909:     // aContentLocation may be null when a plugin is loading without an associated URI resource
114909:     if(aContentType == TYPE_OBJECT) {
114909:        return NS_OK;
114909:     } else {
114909:        return NS_ERROR_FAILURE;
114909:     }
114909:   }
114909: 
114055:   return ShouldLoad(aContentType, aContentLocation, aRequestingLocation,
114055:                     aRequestingContext, aMimeGuess, aExtra, aRequestPrincipal,
114055:                     aDecision);
114055: }
