    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brian Ryner <bryner@brianryner.com>
    1:  *   Terry Hayes <thayes@netscape.com>
    1:  *   Kai Engert <kengert@redhat.com>
 8756:  *   Petr Kostka <petr.kostka@st.com>
28629:  *   Honza Bambas <honzab@firemni.cz>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsNSSComponent.h" // for PIPNSS string bundle calls.
    1: #include "nsNSSCallbacks.h"
    1: #include "nsNSSCertificate.h"
 6598: #include "nsNSSCleaner.h"
 6598: #include "nsSSLStatus.h"
    1: #include "nsNSSIOLayer.h" // for nsNSSSocketInfo
    1: #include "nsIWebProgressListener.h"
    1: #include "nsIStringBundle.h"
    1: #include "nsXPIDLString.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsIPrompt.h"
    1: #include "nsProxiedService.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
 8756: #include "nsProtectedAuthThread.h"
 8756: #include "nsITokenDialogs.h"
    1: #include "nsCRT.h"
    1: #include "nsNSSShutDown.h"
    1: #include "nsIUploadChannel.h"
    1: #include "nsSSLThread.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsAutoLock.h"
    1: #include "nsIThread.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsIPrompt.h"
12058: #include "nsProxyRelease.h"
37963: #include "nsIConsoleService.h"
    1: 
    1: #include "ssl.h"
    1: #include "cert.h"
    1: #include "ocsp.h"
27009: #include "nssb64.h"
68227: #include "secerr.h"
    1: 
    1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
 6598: NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
    1: 
    1: #ifdef PR_LOGGING
    1: extern PRLogModuleInfo* gPIPNSSLog;
    1: #endif
    1: 
14244: class nsHTTPDownloadEvent : public nsRunnable {
14244: public:
    1:   nsHTTPDownloadEvent();
    1:   ~nsHTTPDownloadEvent();
    1: 
    1:   NS_IMETHOD Run();
    1: 
14563:   nsNSSHttpRequestSession *mRequestSession;
    1:   
    1:   nsCOMPtr<nsHTTPListener> mListener;
    1:   PRBool mResponsibleForDoneSignal;
    1: };
    1: 
    1: nsHTTPDownloadEvent::nsHTTPDownloadEvent()
    1: :mResponsibleForDoneSignal(PR_TRUE)
    1: {
    1: }
    1: 
    1: nsHTTPDownloadEvent::~nsHTTPDownloadEvent()
    1: {
    1:   if (mResponsibleForDoneSignal && mListener)
    1:     mListener->send_done_signal();
14563: 
14563:   mRequestSession->Release();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsHTTPDownloadEvent::Run()
    1: {
    1:   if (!mListener)
    1:     return NS_OK;
    1: 
    1:   nsresult rv;
    1: 
    1:   nsCOMPtr<nsIIOService> ios = do_GetIOService();
    1:   NS_ENSURE_STATE(ios);
    1: 
    1:   nsCOMPtr<nsIChannel> chan;
    1:   ios->NewChannel(mRequestSession->mURL, nsnull, nsnull, getter_AddRefs(chan));
    1:   NS_ENSURE_STATE(chan);
    1: 
    1:   // Create a loadgroup for this new channel.  This way if the channel
    1:   // is redirected, we'll have a way to cancel the resulting channel.
14244:   nsCOMPtr<nsILoadGroup> lg = do_CreateInstance(NS_LOADGROUP_CONTRACTID);
14244:   chan->SetLoadGroup(lg);
    1: 
    1:   if (mRequestSession->mHasPostData)
    1:   {
    1:     nsCOMPtr<nsIInputStream> uploadStream;
    1:     rv = NS_NewPostDataStream(getter_AddRefs(uploadStream),
    1:                               PR_FALSE,
    1:                               mRequestSession->mPostData,
    1:                               0, ios);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIUploadChannel> uploadChannel(do_QueryInterface(chan));
    1:     NS_ENSURE_STATE(uploadChannel);
    1: 
    1:     rv = uploadChannel->SetUploadStream(uploadStream, 
    1:                                         mRequestSession->mPostContentType,
    1:                                         -1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   nsCOMPtr<nsIHttpChannel> hchan = do_QueryInterface(chan);
    1:   NS_ENSURE_STATE(hchan);
    1: 
    1:   rv = hchan->SetRequestMethod(mRequestSession->mRequestMethod);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mResponsibleForDoneSignal = PR_FALSE;
    1:   mListener->mResponsibleForDoneSignal = PR_TRUE;
    1: 
14244:   mListener->mLoadGroup = lg.get();
14244:   NS_ADDREF(mListener->mLoadGroup);
14244:   mListener->mLoadGroupOwnerThread = PR_GetCurrentThread();
14244: 
    1:   rv = NS_NewStreamLoader(getter_AddRefs(mListener->mLoader), 
    1:                           mListener);
    1: 
    1:   if (NS_SUCCEEDED(rv))
    1:     rv = hchan->AsyncOpen(mListener->mLoader, nsnull);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     mListener->mResponsibleForDoneSignal = PR_FALSE;
    1:     mResponsibleForDoneSignal = PR_TRUE;
13550: 
14244:     NS_RELEASE(mListener->mLoadGroup);
14244:     mListener->mLoadGroup = nsnull;
14244:     mListener->mLoadGroupOwnerThread = nsnull;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: struct nsCancelHTTPDownloadEvent : nsRunnable {
14244:   nsCOMPtr<nsHTTPListener> mListener;
14244: 
    1:   NS_IMETHOD Run() {
14244:     mListener->FreeLoadGroup(PR_TRUE);
14244:     mListener = nsnull;
    1:     return NS_OK;
    1:   }
    1: };
    1: 
    1: SECStatus nsNSSHttpServerSession::createSessionFcn(const char *host,
    1:                                                    PRUint16 portnum,
    1:                                                    SEC_HTTP_SERVER_SESSION *pSession)
    1: {
    1:   if (!host || !pSession)
    1:     return SECFailure;
    1: 
    1:   nsNSSHttpServerSession *hss = new nsNSSHttpServerSession;
    1:   if (!hss)
    1:     return SECFailure;
    1: 
    1:   hss->mHost = host;
    1:   hss->mPort = portnum;
    1: 
    1:   *pSession = hss;
    1:   return SECSuccess;
    1: }
    1: 
    1: SECStatus nsNSSHttpRequestSession::createFcn(SEC_HTTP_SERVER_SESSION session,
    1:                                              const char *http_protocol_variant,
    1:                                              const char *path_and_query_string,
    1:                                              const char *http_request_method, 
    1:                                              const PRIntervalTime timeout, 
    1:                                              SEC_HTTP_REQUEST_SESSION *pRequest)
    1: {
    1:   if (!session || !http_protocol_variant || !path_and_query_string || 
    1:       !http_request_method || !pRequest)
    1:     return SECFailure;
    1: 
 3233:   nsNSSHttpServerSession* hss = static_cast<nsNSSHttpServerSession*>(session);
    1:   if (!hss)
    1:     return SECFailure;
    1: 
    1:   nsNSSHttpRequestSession *rs = new nsNSSHttpRequestSession;
    1:   if (!rs)
    1:     return SECFailure;
    1: 
    1:   rs->mTimeoutInterval = timeout;
    1: 
 8618:   // Use a maximum timeout value of 10 seconds because of bug 404059.
 8618:   // FIXME: Use a better approach once 406120 is ready.
 8618:   PRUint32 maxBug404059Timeout = PR_TicksPerSecond() * 10;
 8618:   if (timeout > maxBug404059Timeout) {
 8618:     rs->mTimeoutInterval = maxBug404059Timeout;
 8618:   }
 8618: 
58262:   rs->mURL.Assign(http_protocol_variant);
    1:   rs->mURL.AppendLiteral("://");
    1:   rs->mURL.Append(hss->mHost);
    1:   rs->mURL.AppendLiteral(":");
    1:   rs->mURL.AppendInt(hss->mPort);
    1:   rs->mURL.Append(path_and_query_string);
    1: 
58262:   rs->mRequestMethod = http_request_method;
    1: 
    1:   *pRequest = (void*)rs;
    1:   return SECSuccess;
    1: }
    1: 
    1: SECStatus nsNSSHttpRequestSession::setPostDataFcn(const char *http_data, 
    1:                                                   const PRUint32 http_data_len,
    1:                                                   const char *http_content_type)
    1: {
    1:   mHasPostData = PR_TRUE;
    1:   mPostData.Assign(http_data, http_data_len);
    1:   mPostContentType.Assign(http_content_type);
    1: 
    1:   return SECSuccess;
    1: }
    1: 
    1: SECStatus nsNSSHttpRequestSession::addHeaderFcn(const char *http_header_name, 
    1:                                                 const char *http_header_value)
    1: {
    1:   return SECFailure; // not yet implemented
    1: 
    1:   // All http code needs to be postponed to the UI thread.
    1:   // Once this gets implemented, we need to add a string list member to
    1:   // nsNSSHttpRequestSession and queue up the headers,
    1:   // so they can be added in HandleHTTPDownloadPLEvent.
    1:   //
    1:   // The header will need to be set using 
    1:   //   mHttpChannel->SetRequestHeader(nsDependentCString(http_header_name), 
    1:   //                                  nsDependentCString(http_header_value), 
    1:   //                                  PR_FALSE)));
    1: }
    1: 
    1: SECStatus nsNSSHttpRequestSession::trySendAndReceiveFcn(PRPollDesc **pPollDesc,
    1:                                                         PRUint16 *http_response_code, 
    1:                                                         const char **http_response_content_type, 
    1:                                                         const char **http_response_headers, 
    1:                                                         const char **http_response_data, 
    1:                                                         PRUint32 *http_response_data_len)
    1: {
    1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
    1:          ("nsNSSHttpRequestSession::trySendAndReceiveFcn to %s\n", mURL.get()));
    1: 
 2018:   const int max_retries = 2;
    1:   int retry_count = 0;
    1:   PRBool retryable_error = PR_FALSE;
    1:   SECStatus result_sec_status = SECFailure;
    1: 
    1:   do
    1:   {
    1:     if (retry_count > 0)
    1:     {
    1:       if (retryable_error)
    1:       {
    1:         PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
    1:                ("nsNSSHttpRequestSession::trySendAndReceiveFcn - sleeping and retrying: %d of %d\n",
    1:                 retry_count, max_retries));
    1:       }
    1: 
    1:       PR_Sleep( PR_MillisecondsToInterval(300) * retry_count );
    1:     }
    1: 
    1:     ++retry_count;
    1:     retryable_error = PR_FALSE;
    1: 
    1:     result_sec_status =
    1:       internal_send_receive_attempt(retryable_error, pPollDesc, http_response_code,
    1:                                     http_response_content_type, http_response_headers,
    1:                                     http_response_data, http_response_data_len);
    1:   }
    1:   while (retryable_error &&
    1:          retry_count < max_retries);
    1: 
    1: #ifdef PR_LOGGING
    1:   if (retry_count > 1)
    1:   {
    1:     if (retryable_error)
    1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
    1:              ("nsNSSHttpRequestSession::trySendAndReceiveFcn - still failing, giving up...\n"));
    1:     else
    1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
    1:              ("nsNSSHttpRequestSession::trySendAndReceiveFcn - success at attempt %d\n",
    1:               retry_count));
    1:   }
    1: #endif
    1: 
    1:   return result_sec_status;
    1: }
    1: 
14563: void
14563: nsNSSHttpRequestSession::AddRef()
14563: {
14563:   PR_AtomicIncrement(&mRefCount);
14563: }
14563: 
14563: void
14563: nsNSSHttpRequestSession::Release()
14563: {
14563:   PRInt32 newRefCount = PR_AtomicDecrement(&mRefCount);
14563:   if (!newRefCount) {
14563:     delete this;
14563:   }
14563: }
14563: 
    1: SECStatus
    1: nsNSSHttpRequestSession::internal_send_receive_attempt(PRBool &retryable_error,
    1:                                                        PRPollDesc **pPollDesc,
    1:                                                        PRUint16 *http_response_code,
    1:                                                        const char **http_response_content_type,
    1:                                                        const char **http_response_headers,
    1:                                                        const char **http_response_data,
    1:                                                        PRUint32 *http_response_data_len)
    1: {
    1:   if (pPollDesc) *pPollDesc = nsnull;
    1:   if (http_response_code) *http_response_code = 0;
    1:   if (http_response_content_type) *http_response_content_type = 0;
    1:   if (http_response_headers) *http_response_headers = 0;
    1:   if (http_response_data) *http_response_data = 0;
    1: 
    1:   PRUint32 acceptableResultSize = 0;
    1: 
    1:   if (http_response_data_len)
    1:   {
    1:     acceptableResultSize = *http_response_data_len;
    1:     *http_response_data_len = 0;
    1:   }
    1:   
    1:   if (!mListener)
    1:     return SECFailure;
    1: 
    1:   if (NS_FAILED(mListener->InitLocks()))
    1:     return SECFailure;
    1: 
    1:   PRLock *waitLock = mListener->mLock;
    1:   PRCondVar *waitCondition = mListener->mCondition;
    1:   volatile PRBool &waitFlag = mListener->mWaitFlag;
    1:   waitFlag = PR_TRUE;
    1: 
    1:   nsRefPtr<nsHTTPDownloadEvent> event = new nsHTTPDownloadEvent;
    1:   if (!event)
    1:     return SECFailure;
    1: 
    1:   event->mListener = mListener;
14563:   this->AddRef();
    1:   event->mRequestSession = this;
    1: 
    1:   nsresult rv = NS_DispatchToMainThread(event);
    1:   if (NS_FAILED(rv))
    1:   {
    1:     event->mResponsibleForDoneSignal = PR_FALSE;
    1:     return SECFailure;
    1:   }
    1: 
    1:   PRBool request_canceled = PR_FALSE;
    1: 
    1:   {
    1:     nsAutoLock locker(waitLock);
    1: 
    1:     const PRIntervalTime start_time = PR_IntervalNow();
    1:     PRIntervalTime wait_interval;
    1: 
    1:     PRBool running_on_main_thread = NS_IsMainThread();
    1:     if (running_on_main_thread)
    1:     {
    1:       // let's process events quickly
    1:       wait_interval = PR_MicrosecondsToInterval(50);
    1:     }
    1:     else
    1:     { 
    1:       // On a secondary thread, it's fine to wait some more for
    1:       // for the condition variable.
    1:       wait_interval = PR_MillisecondsToInterval(250);
    1:     }
    1: 
    1:     while (waitFlag)
    1:     {
    1:       if (running_on_main_thread)
    1:       {
    1:         // Networking runs on the main thread, which we happen to block here.
    1:         // Processing events will allow the OCSP networking to run while we 
    1:         // are waiting. Thanks a lot to Darin Fisher for rewriting the 
    1:         // thread manager. Thanks a lot to Christian Biesinger who
    1:         // made me aware of this possibility. (kaie)
    1: 
    1:         locker.unlock();
    1:         NS_ProcessNextEvent(nsnull);
    1:         locker.lock();
    1:       }
    1: 
    1:       PR_WaitCondVar(waitCondition, wait_interval);
    1:       
    1:       if (!waitFlag)
    1:         break;
    1: 
    1:       if (!request_canceled)
    1:       {
14244:         PRBool wantExit = nsSSLThread::exitRequested();
14244:         PRBool timeout = 
14244:           (PRIntervalTime)(PR_IntervalNow() - start_time) > mTimeoutInterval;
14244: 
14244:         if (wantExit || timeout)
    1:         {
    1:           request_canceled = PR_TRUE;
    1: 
14244:           nsRefPtr<nsCancelHTTPDownloadEvent> cancelevent = new nsCancelHTTPDownloadEvent;
14244:           cancelevent->mListener = mListener;
    1:           rv = NS_DispatchToMainThread(cancelevent);
14244:           if (NS_FAILED(rv)) {
    1:             NS_WARNING("cannot post cancel event");
14244:           }
    1:           break;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (request_canceled)
    1:     return SECFailure;
    1: 
    1:   if (NS_FAILED(mListener->mResultCode))
    1:   {
    1:     if (mListener->mResultCode == NS_ERROR_CONNECTION_REFUSED
    1:         ||
    1:         mListener->mResultCode == NS_ERROR_NET_RESET)
    1:     {
    1:       retryable_error = PR_TRUE;
    1:     }
    1:     return SECFailure;
    1:   }
    1: 
    1:   if (http_response_code)
    1:     *http_response_code = mListener->mHttpResponseCode;
    1: 
    1:   if (mListener->mHttpRequestSucceeded && http_response_data && http_response_data_len) {
    1: 
    1:     *http_response_data_len = mListener->mResultLen;
    1:   
    1:     // acceptableResultSize == 0 means: any size is acceptable
    1:     if (acceptableResultSize != 0
    1:         &&
    1:         acceptableResultSize < mListener->mResultLen)
    1:     {
    1:       return SECFailure;
    1:     }
    1: 
    1:     // return data by reference, result data will be valid 
    1:     // until "this" gets destroyed by NSS
    1:     *http_response_data = (const char*)mListener->mResultData;
    1:   }
    1: 
    1:   if (mListener->mHttpRequestSucceeded && http_response_content_type) {
    1:     if (mListener->mHttpResponseContentType.Length()) {
    1:       *http_response_content_type = mListener->mHttpResponseContentType.get();
    1:     }
    1:   }
    1: 
    1:   return SECSuccess;
    1: }
    1: 
    1: SECStatus nsNSSHttpRequestSession::cancelFcn()
    1: {
    1:   // As of today, only the blocking variant of the http interface
    1:   // has been implemented. Implementing cancelFcn will be necessary
    1:   // as soon as we implement the nonblocking variant.
    1:   return SECSuccess;
    1: }
    1: 
    1: SECStatus nsNSSHttpRequestSession::freeFcn()
    1: {
14563:   Release();
    1:   return SECSuccess;
    1: }
    1: 
    1: nsNSSHttpRequestSession::nsNSSHttpRequestSession()
14563: : mRefCount(1),
14563:   mHasPostData(PR_FALSE),
    1:   mTimeoutInterval(0),
    1:   mListener(new nsHTTPListener)
    1: {
    1: }
    1: 
    1: nsNSSHttpRequestSession::~nsNSSHttpRequestSession()
    1: {
    1: }
    1: 
    1: SEC_HttpClientFcn nsNSSHttpInterface::sNSSInterfaceTable;
    1: 
    1: void nsNSSHttpInterface::initTable()
    1: {
    1:   sNSSInterfaceTable.version = 1;
    1:   SEC_HttpClientFcnV1 &v1 = sNSSInterfaceTable.fcnTable.ftable1;
    1:   v1.createSessionFcn = createSessionFcn;
    1:   v1.keepAliveSessionFcn = keepAliveFcn;
    1:   v1.freeSessionFcn = freeSessionFcn;
    1:   v1.createFcn = createFcn;
    1:   v1.setPostDataFcn = setPostDataFcn;
    1:   v1.addHeaderFcn = addHeaderFcn;
    1:   v1.trySendAndReceiveFcn = trySendAndReceiveFcn;
    1:   v1.cancelFcn = cancelFcn;
    1:   v1.freeFcn = freeFcn;
    1: }
    1: 
    1: void nsNSSHttpInterface::registerHttpClient()
    1: {
    1:   SEC_RegisterDefaultHttpClient(&sNSSInterfaceTable);
    1: }
    1: 
    1: void nsNSSHttpInterface::unregisterHttpClient()
    1: {
    1:   SEC_RegisterDefaultHttpClient(nsnull);
    1: }
    1: 
    1: nsHTTPListener::nsHTTPListener()
    1: : mResultData(nsnull),
    1:   mResultLen(0),
    1:   mLock(nsnull),
    1:   mCondition(nsnull),
    1:   mWaitFlag(PR_TRUE),
14244:   mResponsibleForDoneSignal(PR_FALSE),
14244:   mLoadGroup(nsnull),
14244:   mLoadGroupOwnerThread(nsnull)
    1: {
    1: }
    1: 
    1: nsresult nsHTTPListener::InitLocks()
    1: {
    1:   mLock = PR_NewLock();
    1:   if (!mLock)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   
    1:   mCondition = PR_NewCondVar(mLock);
    1:   if (!mCondition)
    1:   {
    1:     PR_DestroyLock(mLock);
    1:     mLock = nsnull;
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: nsHTTPListener::~nsHTTPListener()
    1: {
    1:   if (mResponsibleForDoneSignal)
    1:     send_done_signal();
    1: 
    1:   if (mCondition)
    1:     PR_DestroyCondVar(mCondition);
    1:   
    1:   if (mLock)
    1:     PR_DestroyLock(mLock);
12058: 
12058:   if (mLoader) {
12058:     nsCOMPtr<nsIThread> mainThread(do_GetMainThread());
12058:     NS_ProxyRelease(mainThread, mLoader);
12058:   }
    1: }
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsHTTPListener, nsIStreamLoaderObserver)
    1: 
14244: void
14244: nsHTTPListener::FreeLoadGroup(PRBool aCancelLoad)
14244: {
14244:   nsILoadGroup *lg = nsnull;
14244: 
14244:   if (mLock) {
14244:     nsAutoLock locker(mLock);
14244: 
14244:     if (mLoadGroup) {
14244:       if (mLoadGroupOwnerThread != PR_GetCurrentThread()) {
14244:         NS_ASSERTION(PR_FALSE,
14244:           "attempt to access nsHTTPDownloadEvent::mLoadGroup on multiple threads, leaking it!");
14244:       }
14244:       else {
14244:         lg = mLoadGroup;
14244:         mLoadGroup = nsnull;
14244:       }
14244:     }
14244:   }
14244: 
14244:   if (lg) {
14244:     if (aCancelLoad) {
14244:       lg->Cancel(NS_ERROR_ABORT);
14244:     }
14244:     NS_RELEASE(lg);
14244:   }
14244: }
14244: 
    1: NS_IMETHODIMP
    1: nsHTTPListener::OnStreamComplete(nsIStreamLoader* aLoader,
    1:                                  nsISupports* aContext,
    1:                                  nsresult aStatus,
    1:                                  PRUint32 stringLen,
    1:                                  const PRUint8* string)
    1: {
    1:   mResultCode = aStatus;
    1: 
14244:   FreeLoadGroup(PR_FALSE);
14244: 
    1:   nsCOMPtr<nsIRequest> req;
    1:   nsCOMPtr<nsIHttpChannel> hchan;
    1: 
    1:   nsresult rv = aLoader->GetRequest(getter_AddRefs(req));
    1:   
    1: #ifdef PR_LOGGING
    1:   if (NS_FAILED(aStatus))
    1:   {
    1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
    1:            ("nsHTTPListener::OnStreamComplete status failed %d", aStatus));
    1:   }
    1: #endif
    1: 
    1:   if (NS_SUCCEEDED(rv))
    1:     hchan = do_QueryInterface(req, &rv);
    1: 
    1:   if (NS_SUCCEEDED(rv))
    1:   {
    1:     rv = hchan->GetRequestSucceeded(&mHttpRequestSucceeded);
    1:     if (NS_FAILED(rv))
    1:       mHttpRequestSucceeded = PR_FALSE;
    1: 
    1:     mResultLen = stringLen;
    1:     mResultData = string; // reference. Make sure loader lives as long as this
    1: 
    1:     unsigned int rcode;
    1:     rv = hchan->GetResponseStatus(&rcode);
    1:     if (NS_FAILED(rv))
    1:       mHttpResponseCode = 500;
    1:     else
    1:       mHttpResponseCode = rcode;
    1: 
    1:     hchan->GetResponseHeader(NS_LITERAL_CSTRING("Content-Type"), 
    1:                                     mHttpResponseContentType);
    1:   }
    1: 
    1:   if (mResponsibleForDoneSignal)
    1:     send_done_signal();
    1:   
    1:   return aStatus;
    1: }
    1: 
    1: void nsHTTPListener::send_done_signal()
    1: {
    1:   mResponsibleForDoneSignal = PR_FALSE;
    1: 
    1:   {
    1:     nsAutoLock locker(mLock);
    1:     mWaitFlag = PR_FALSE;
    1:     PR_NotifyAllCondVar(mCondition);
    1:   }
    1: }
    1: 
 8756: static char*
 8756: ShowProtectedAuthPrompt(PK11SlotInfo* slot, nsIInterfaceRequestor *ir)
 8756: {
 8756:   char* protAuthRetVal = nsnull;
 8756: 
 8756:   // Get protected auth dialogs
 8756:   nsITokenDialogs* dialogs = 0;
 8756:   nsresult nsrv = getNSSDialogs((void**)&dialogs, 
 8756:                                 NS_GET_IID(nsITokenDialogs), 
 8756:                                 NS_TOKENDIALOGS_CONTRACTID);
 8756:   if (NS_SUCCEEDED(nsrv))
 8756:   {
 8756:     nsProtectedAuthThread* protectedAuthRunnable = new nsProtectedAuthThread();
 8756:     if (protectedAuthRunnable)
 8756:     {
 8756:       NS_ADDREF(protectedAuthRunnable);
 8756: 
 8756:       protectedAuthRunnable->SetParams(slot);
 8756:       
 8756:       nsCOMPtr<nsIProtectedAuthThread> runnable = do_QueryInterface(protectedAuthRunnable);
 8756:       if (runnable)
 8756:       {
 8756:         nsrv = dialogs->DisplayProtectedAuth(ir, runnable);
 8756:               
 8756:         // We call join on the thread,
 8756:         // so we can be sure that no simultaneous access will happen.
 8756:         protectedAuthRunnable->Join();
 8756:               
 8756:         if (NS_SUCCEEDED(nsrv))
 8756:         {
 8756:           SECStatus rv = protectedAuthRunnable->GetResult();
 8756:           switch (rv)
 8756:           {
 8756:               case SECSuccess:
16678:                   protAuthRetVal = ToNewCString(nsDependentCString(PK11_PW_AUTHENTICATED));
 8756:                   break;
 8756:               case SECWouldBlock:
16678:                   protAuthRetVal = ToNewCString(nsDependentCString(PK11_PW_RETRY));
 8756:                   break;
 8756:               default:
 8756:                   protAuthRetVal = nsnull;
 8756:                   break;
 8756:               
 8756:           }
 8756:         }
 8756:       }
 8756: 
 8756:       NS_RELEASE(protectedAuthRunnable);
 8756:     }
 8756: 
 8756:     NS_RELEASE(dialogs);
 8756:   }
 8756: 
 8756:   return protAuthRetVal;
 8756: }
 8756:   
    1: char* PR_CALLBACK
    1: PK11PasswordPrompt(PK11SlotInfo* slot, PRBool retry, void* arg) {
    1:   nsNSSShutDownPreventionLock locker;
    1:   nsresult rv = NS_OK;
    1:   PRUnichar *password = nsnull;
    1:   PRBool value = PR_FALSE;
 3233:   nsIInterfaceRequestor *ir = static_cast<nsIInterfaceRequestor*>(arg);
    1:   nsCOMPtr<nsIPrompt> proxyPrompt;
    1: 
    1:   /* TODO: Retry should generate a different dialog message */
    1: /*
    1:   if (retry)
    1:     return nsnull;
    1: */
    1: 
    1:   if (!ir)
    1:   {
    1:     nsCOMPtr<nsIWindowWatcher> wwatch(do_GetService(NS_WINDOWWATCHER_CONTRACTID));
    1:     if (!wwatch)
    1:       return nsnull;
    1: 
    1:     nsCOMPtr<nsIPrompt> prompter;
    1:     wwatch->GetNewPrompter(0, getter_AddRefs(prompter));
    1:     if (!prompter)
    1:       return nsnull;
    1: 
    1:     NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1:                          NS_GET_IID(nsIPrompt),
    1:                          prompter, NS_PROXY_SYNC,
    1:                          getter_AddRefs(proxyPrompt));
    1:     if (!proxyPrompt)
    1:       return nsnull;
    1:   }
    1:   else
    1:   {
    1:     // The interface requestor object may not be safe, so
    1:     // proxy the call to get the nsIPrompt.
    1:   
    1:     nsCOMPtr<nsIInterfaceRequestor> proxiedCallbacks;
    1:     NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1:                          NS_GET_IID(nsIInterfaceRequestor),
    1:                          ir,
    1:                          NS_PROXY_SYNC,
    1:                          getter_AddRefs(proxiedCallbacks));
    1:   
    1:     // Get the desired interface
    1:     nsCOMPtr<nsIPrompt> prompt(do_GetInterface(proxiedCallbacks));
    1:     if (!prompt) {
    1:       NS_ASSERTION(PR_FALSE, "callbacks does not implement nsIPrompt");
    1:       return nsnull;
    1:     }
    1:   
    1:     // Finally, get a proxy for the nsIPrompt
    1:     NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
    1:                          NS_GET_IID(nsIPrompt),
    1:                          prompt,
    1:                          NS_PROXY_SYNC,
    1:                          getter_AddRefs(proxyPrompt));
    1:   }
    1: 
 8756:   if (PK11_ProtectedAuthenticationPath(slot))
 8756:     return ShowProtectedAuthPrompt(slot, ir);
 8756: 
    1:   nsAutoString promptString;
    1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
    1: 
    1:   if (NS_FAILED(rv))
    1:     return nsnull; 
    1: 
    1:   const PRUnichar* formatStrings[1] = { ToNewUnicode(NS_ConvertUTF8toUTF16(PK11_GetTokenName(slot))) };
    1:   rv = nssComponent->PIPBundleFormatStringFromName("CertPassPrompt",
    1:                                       formatStrings, 1,
    1:                                       promptString);
 3233:   nsMemory::Free(const_cast<PRUnichar*>(formatStrings[0]));
    1: 
    1:   if (NS_FAILED(rv))
    1:     return nsnull;
    1: 
    1:   {
    1:     nsPSMUITracker tracker;
    1:     if (tracker.isUIForbidden()) {
    1:       rv = NS_ERROR_NOT_AVAILABLE;
    1:     }
    1:     else {
29073:       PRBool checkState;
    1:       rv = proxyPrompt->PromptPassword(nsnull, promptString.get(),
29073:                                        &password, nsnull, &checkState, &value);
    1:     }
    1:   }
    1:   
    1:   if (NS_SUCCEEDED(rv) && value) {
    1:     char* str = ToNewUTF8String(nsDependentString(password));
  241:     NS_Free(password);
    1:     return str;
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: void PR_CALLBACK HandshakeCallback(PRFileDesc* fd, void* client_data) {
    1:   nsNSSShutDownPreventionLock locker;
    1:   PRInt32 sslStatus;
    1:   char* signer = nsnull;
    1:   char* cipherName = nsnull;
    1:   PRInt32 keyLength;
    1:   nsresult rv;
    1:   PRInt32 encryptBits;
    1: 
    1:   if (SECSuccess != SSL_SecurityStatus(fd, &sslStatus, &cipherName, &keyLength,
    1:                                        &encryptBits, &signer, nsnull)) {
    1:     return;
    1:   }
    1: 
    1:   PRInt32 secStatus;
    1:   if (sslStatus == SSL_SECURITY_STATUS_OFF)
    1:     secStatus = nsIWebProgressListener::STATE_IS_BROKEN;
    1:   else if (encryptBits >= 90)
    1:     secStatus = (nsIWebProgressListener::STATE_IS_SECURE |
    1:                  nsIWebProgressListener::STATE_SECURE_HIGH);
    1:   else
    1:     secStatus = (nsIWebProgressListener::STATE_IS_SECURE |
    1:                  nsIWebProgressListener::STATE_SECURE_LOW);
    1: 
37963:   PRBool siteSupportsSafeRenego;
37963:   if (SSL_HandshakeNegotiatedExtension(fd, ssl_renegotiation_info_xtn, &siteSupportsSafeRenego) != SECSuccess
37963:       || !siteSupportsSafeRenego) {
37963: 
41739:     PRBool wantWarning = (nsSSLIOLayerHelpers::getWarnLevelMissingRFC5746() > 0);
41739: 
37963:     nsNSSSocketInfo* infoObject = (nsNSSSocketInfo*) fd->higher->secret;
41739:     nsCOMPtr<nsIConsoleService> console;
41739:     if (infoObject && wantWarning) {
41739:       console = do_GetService(NS_CONSOLESERVICE_CONTRACTID);
41739:       if (console) {
37963:         nsXPIDLCString hostName;
37963:         infoObject->GetHostName(getter_Copies(hostName));
37963: 
37963:         nsAutoString msg;
37963:         msg.Append(NS_ConvertASCIItoUTF16(hostName));
41739:         msg.Append(NS_LITERAL_STRING(" : server does not support RFC 5746, see CVE-2009-3555"));
37963: 
37963:         console->LogStringMessage(msg.get());
37963:       }
41739:     }
37963:     if (nsSSLIOLayerHelpers::treatUnsafeNegotiationAsBroken()) {
37963:       secStatus = nsIWebProgressListener::STATE_IS_BROKEN;
37963:     }
37963:   }
37963: 
37963: 
    1:   CERTCertificate *peerCert = SSL_PeerCertificate(fd);
 1965:   const char* caName = nsnull; // caName is a pointer only, no ownership
 1965:   char* certOrgName = CERT_GetOrgName(&peerCert->issuer);
    1:   CERT_DestroyCertificate(peerCert);
 1965:   caName = certOrgName ? certOrgName : signer;
    1: 
 1965:   const char* verisignName = "Verisign, Inc.";
    1:   // If the CA name is RSA Data Security, then change the name to the real
    1:   // name of the company i.e. VeriSign, Inc.
    1:   if (nsCRT::strcmp((const char*)caName, "RSA Data Security, Inc.") == 0) {
 1965:     caName = verisignName;
    1:   }
    1: 
    1:   nsAutoString shortDesc;
    1:   const PRUnichar* formatStrings[1] = { ToNewUnicode(NS_ConvertUTF8toUTF16(caName)) };
    1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
    1:   if (NS_SUCCEEDED(rv)) {
    1:     rv = nssComponent->PIPBundleFormatStringFromName("SignedBy",
    1:                                                    formatStrings, 1,
    1:                                                    shortDesc);
    1: 
 3233:     nsMemory::Free(const_cast<PRUnichar*>(formatStrings[0]));
    1: 
    1:     nsNSSSocketInfo* infoObject = (nsNSSSocketInfo*) fd->higher->secret;
    1:     infoObject->SetSecurityState(secStatus);
    1:     infoObject->SetShortSecurityDescription(shortDesc.get());
    1: 
    1:     /* Set the SSL Status information */
 8463:     nsRefPtr<nsSSLStatus> status = infoObject->SSLStatus();
 6598:     if (!status) {
 6598:       status = new nsSSLStatus();
 6598:       infoObject->SetSSLStatus(status);
 6598:     }
    1: 
28629:     nsSSLIOLayerHelpers::mHostsWithCertErrors->LookupCertErrorBits(
28629:       infoObject, status);
28629: 
    1:     CERTCertificate *serverCert = SSL_PeerCertificate(fd);
    1:     if (serverCert) {
56495:       nsRefPtr<nsNSSCertificate> nssc = nsNSSCertificate::Create(serverCert);
    1:       CERT_DestroyCertificate(serverCert);
 5220:       serverCert = nsnull;
10258: 
10258:       nsCOMPtr<nsIX509Cert> prevcert;
10258:       infoObject->GetPreviousCert(getter_AddRefs(prevcert));
10258: 
10258:       PRBool equals_previous = PR_FALSE;
56495:       if (prevcert && nssc) {
10258:         nsresult rv = nssc->Equals(prevcert, &equals_previous);
10258:         if (NS_FAILED(rv)) {
10258:           equals_previous = PR_FALSE;
10258:         }
10258:       }
10258: 
10258:       if (equals_previous) {
10258:         PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
10258:                ("HandshakeCallback using PREV cert %p\n", prevcert.get()));
10258:         infoObject->SetCert(prevcert);
10258:         status->mServerCert = prevcert;
10258:       }
10258:       else {
10258:         if (status->mServerCert) {
10258:           PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
10258:                  ("HandshakeCallback KEEPING cert %p\n", status->mServerCert.get()));
10258:           infoObject->SetCert(status->mServerCert);
10258:         }
10258:         else {
10258:           PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
10258:                  ("HandshakeCallback using NEW cert %p\n", nssc.get()));
 5220:           infoObject->SetCert(nssc);
 5220:           status->mServerCert = nssc;
 5220:         }
    1:       }
10258:     }
    1: 
 6598:     status->mHaveKeyLengthAndCipher = PR_TRUE;
    1:     status->mKeyLength = keyLength;
    1:     status->mSecretKeyLength = encryptBits;
27356:     status->mCipherName.Assign(cipherName);
    1:   }
    1: 
27356:   PORT_Free(cipherName);
 1965:   PR_FREEIF(certOrgName);
    1:   PR_Free(signer);
    1: }
    1: 
68227: struct nsSerialBinaryBlacklistEntry
68227: {
68227:   unsigned int len;
68227:   const char *binary_serial;
68227: };
68227: 
68227: // bug 642395
68227: static struct nsSerialBinaryBlacklistEntry myUTNBlacklistEntries[] = {
68227:   { 17, "\x00\x92\x39\xd5\x34\x8f\x40\xd1\x69\x5a\x74\x54\x70\xe1\xf2\x3f\x43" },
68227:   { 17, "\x00\xd8\xf3\x5f\x4e\xb7\x87\x2b\x2d\xab\x06\x92\xe3\x15\x38\x2f\xb0" },
68227:   { 16, "\x72\x03\x21\x05\xc5\x0c\x08\x57\x3d\x8e\xa5\x30\x4e\xfe\xe8\xb0" },
68227:   { 17, "\x00\xb0\xb7\x13\x3e\xd0\x96\xf9\xb5\x6f\xae\x91\xc8\x74\xbd\x3a\xc0" },
68228:   { 16, "\x39\x2a\x43\x4f\x0e\x07\xdf\x1f\x8a\xa3\x05\xde\x34\xe0\xc2\x29" },
68228:   { 16, "\x3e\x75\xce\xd4\x6b\x69\x30\x21\x21\x88\x30\xae\x86\xa8\x2a\x71" },
68227:   { 17, "\x00\xe9\x02\x8b\x95\x78\xe4\x15\xdc\x1a\x71\x0a\x2b\x88\x15\x44\x47" },
68227:   { 17, "\x00\xd7\x55\x8f\xda\xf5\xf1\x10\x5b\xb2\x13\x28\x2b\x70\x77\x29\xa3" },
68227:   { 16, "\x04\x7e\xcb\xe9\xfc\xa5\x5f\x7b\xd0\x9e\xae\x36\xe1\x0c\xae\x1e" },
68227:   { 17, "\x00\xf5\xc8\x6a\xf3\x61\x62\xf1\x3a\x64\xf5\x4f\x6d\xc9\x58\x7c\x06" },
68227:   { 0, 0 } // end marker
68227: };
68227: 
    1: SECStatus PR_CALLBACK AuthCertificateCallback(void* client_data, PRFileDesc* fd,
    1:                                               PRBool checksig, PRBool isServer) {
    1:   nsNSSShutDownPreventionLock locker;
    1: 
68227:   CERTCertificate *serverCert = SSL_PeerCertificate(fd);
68258:   CERTCertificateCleaner serverCertCleaner(serverCert);
68258: 
68227:   if (serverCert && 
68227:       serverCert->serialNumber.data &&
68258:       serverCert->issuerName &&
68227:       !strcmp(serverCert->issuerName, 
68227:         "CN=UTN-USERFirst-Hardware,OU=http://www.usertrust.com,O=The USERTRUST Network,L=Salt Lake City,ST=UT,C=US")) {
68227: 
68227:     unsigned char *server_cert_comparison_start = (unsigned char*)serverCert->serialNumber.data;
68227:     unsigned int server_cert_comparison_len = serverCert->serialNumber.len;
68227: 
68227:     while (server_cert_comparison_len) {
68227:       if (*server_cert_comparison_start != 0)
68227:         break;
68227: 
68227:       ++server_cert_comparison_start;
68227:       --server_cert_comparison_len;
68227:     }
68227: 
68227:     nsSerialBinaryBlacklistEntry *walk = myUTNBlacklistEntries;
68227:     for ( ; walk && walk->len; ++walk) {
68227: 
68227:       unsigned char *locked_cert_comparison_start = (unsigned char*)walk->binary_serial;
68227:       unsigned int locked_cert_comparison_len = walk->len;
68227:       
68227:       while (locked_cert_comparison_len) {
68227:         if (*locked_cert_comparison_start != 0)
68227:           break;
68227:         
68227:         ++locked_cert_comparison_start;
68227:         --locked_cert_comparison_len;
68227:       }
68227: 
68227:       if (server_cert_comparison_len == locked_cert_comparison_len &&
68227:           !memcmp(server_cert_comparison_start, locked_cert_comparison_start, locked_cert_comparison_len)) {
68227:         PR_SetError(SEC_ERROR_REVOKED_CERTIFICATE, 0);
68227:         return SECFailure;
68227:       }
68227:     }
68227:   }
68227:   
    1:   // first the default action
    1:   SECStatus rv = SSL_AuthCertificate(CERT_GetDefaultCertDB(), fd, checksig, isServer);
    1: 
    1:   // We want to remember the CA certs in the temp db, so that the application can find the
    1:   // complete chain at any time it might need it.
    1:   // But we keep only those CA certs in the temp db, that we didn't already know.
    1: 
 6598:   if (serverCert) {
14100:     nsNSSSocketInfo* infoObject = (nsNSSSocketInfo*) fd->higher->secret;
14100:     nsRefPtr<nsSSLStatus> status = infoObject->SSLStatus();
14100:     nsRefPtr<nsNSSCertificate> nsc;
14100: 
14100:     if (!status || !status->mServerCert) {
56495:       nsc = nsNSSCertificate::Create(serverCert);
14100:     }
14100: 
    1:     if (SECSuccess == rv) {
14100:       if (nsc) {
14100:         PRBool dummyIsEV;
14100:         nsc->GetIsExtendedValidation(&dummyIsEV); // the nsc object will cache the status
14100:       }
14100:     
    1:       CERTCertList *certList = CERT_GetCertChainFromCert(serverCert, PR_Now(), certUsageSSLCA);
    1: 
    1:       nsCOMPtr<nsINSSComponent> nssComponent;
    1:       
    1:       for (CERTCertListNode *node = CERT_LIST_HEAD(certList);
    1:            !CERT_LIST_END(node, certList);
    1:            node = CERT_LIST_NEXT(node)) {
    1: 
    1:         if (node->cert->slot) {
    1:           // This cert was found on a token, no need to remember it in the temp db.
    1:           continue;
    1:         }
    1: 
    1:         if (node->cert->isperm) {
    1:           // We don't need to remember certs already stored in perm db.
    1:           continue;
    1:         }
    1:         
    1:         if (node->cert == serverCert) {
    1:           // We don't want to remember the server cert, 
    1:           // the code that cares for displaying page info does this already.
    1:           continue;
    1:         }
    1: 
    1:         // We have found a signer cert that we want to remember.
 7051:         nsCAutoString nickname;
 7051:         nickname = nsNSSCertificate::defaultServerNickname(node->cert);
 7051:         if (!nickname.IsEmpty()) {
 7051:           PK11SlotInfo *slot = PK11_GetInternalKeySlot();
 7051:           if (slot) {
 7051:             PK11_ImportCert(slot, node->cert, CK_INVALID_HANDLE, 
 7051:                             const_cast<char*>(nickname.get()), PR_FALSE);
 7051:             PK11_FreeSlot(slot);
    1:           }
    1:         }
    1:       }
    1: 
    1:       CERT_DestroyCertList(certList);
 6598:     }
 8223: 
 8223:     // The connection may get terminated, for example, if the server requires
 8223:     // a client cert. Let's provide a minimal SSLStatus
 6598:     // to the caller that contains at least the cert and its status.
 6598:     if (!status) {
 6598:       status = new nsSSLStatus();
 6598:       infoObject->SetSSLStatus(status);
 6598:     }
28629: 
28629:     if (rv == SECSuccess) {
28629:       // Certificate verification succeeded delete any potential record
28629:       // of certificate error bits.
28629:       nsSSLIOLayerHelpers::mHostsWithCertErrors->RememberCertHasError(
28629:         infoObject, nsnull, rv);
28629:     }
28629:     else {
28629:       // Certificate verification failed, update the status' bits.
28629:       nsSSLIOLayerHelpers::mHostsWithCertErrors->LookupCertErrorBits(
28629:         infoObject, status);
28629:     }
28629: 
10258:     if (status && !status->mServerCert) {
14100:       status->mServerCert = nsc;
10258:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG,
10258:              ("AuthCertificateCallback setting NEW cert %p\n", status->mServerCert.get()));
 6598:     }
    1:   }
    1: 
    1:   return rv;
    1: }
27009: 
27009: struct OCSPDefaultResponders {
27009:     const char *issuerName_string;
27009:     CERTName *issuerName;
27009:     const char *issuerKeyID_base64;
27009:     SECItem *issuerKeyID;
27009:     const char *ocspUrl;
27009: };
27009: 
27009: static struct OCSPDefaultResponders myDefaultOCSPResponders[] = {
27009:   /* COMODO */
27009:   {
27009:     "CN=AddTrust External CA Root,OU=AddTrust External TTP Network,O=AddTrust AB,C=SE",
27009:     nsnull, "rb2YejS0Jvf6xCZU7wO94CTLVBo=", nsnull,
27009:     "http://ocsp.comodoca.com"
27009:   },
27009:   {
27009:     "CN=COMODO Certification Authority,O=COMODO CA Limited,L=Salford,ST=Greater Manchester,C=GB",
27009:     nsnull, "C1jli8ZMFTekQKkwqSG+RzZaVv8=", nsnull,
27009:     "http://ocsp.comodoca.com"
27009:   },
27009:   {
27009:     "CN=COMODO EV SGC CA,O=COMODO CA Limited,L=Salford,ST=Greater Manchester,C=GB",
27009:     nsnull, "f/ZMNigUrs0eN6/eWvJbw6CsK/4=", nsnull,
27009:     "http://ocsp.comodoca.com"
27009:   },
27009:   {
27009:     "CN=COMODO EV SSL CA,O=COMODO CA Limited,L=Salford,ST=Greater Manchester,C=GB",
27009:     nsnull, "aRZJ7LZ1ZFrpAyNgL1RipTRcPuI=", nsnull,
27009:     "http://ocsp.comodoca.com"
27009:   },
27009:   {
27009:     "CN=UTN - DATACorp SGC,OU=http://www.usertrust.com,O=The USERTRUST Network,L=Salt Lake City,ST=UT,C=US",
27009:     nsnull, "UzLRs89/+uDxoF2FTpLSnkUdtE8=", nsnull,
27009:     "http://ocsp.usertrust.com"
27009:   },
27009:   {
27009:     "CN=UTN-USERFirst-Hardware,OU=http://www.usertrust.com,O=The USERTRUST Network,L=Salt Lake City,ST=UT,C=US",
27009:     nsnull, "oXJfJhsomEOVXQc31YWWnUvSw0U=", nsnull,
27009:     "http://ocsp.usertrust.com"
27009:   },
27009:   /* Network Solutions */
27009:   {
27009:     "CN=Network Solutions Certificate Authority,O=Network Solutions L.L.C.,C=US",
27009:     nsnull, "ITDJ+wDXTpjah6oq0KcusUAxp0w=", nsnull,
27009:     "http://ocsp.netsolssl.com"
27009:   },
27009:   {
27009:     "CN=Network Solutions EV SSL CA,O=Network Solutions L.L.C.,C=US",
27009:     nsnull, "tk6FnYQfGx3UUolOB5Yt+d7xj8w=", nsnull,
27009:     "http://ocsp.netsolssl.com"
30365:   },
30365:   /* GlobalSign */
30365:   {
30365:     "CN=GlobalSign Root CA,OU=Root CA,O=GlobalSign nv-sa,C=BE",
30365:     nsnull, "YHtmGkUNl8qJUC99BM00qP/8/Us=", nsnull,
30365:     "http://ocsp.globalsign.com/ExtendedSSLCACross"
30365:   },
30365:   {
30365:     "CN=GlobalSign,O=GlobalSign,OU=GlobalSign Root CA - R2",
30365:     nsnull, "m+IHV2ccHsBqBt5ZtJot39wZhi4=", nsnull,
30365:     "http://ocsp.globalsign.com/ExtendedSSLCA"
30365:   },
30365:   {
30365:     "CN=GlobalSign Extended Validation CA,O=GlobalSign,OU=Extended Validation CA",
30365:     nsnull, "NLH5yYxrNUTMCGkK7uOjuVy/FuA=", nsnull,
30365:     "http://ocsp.globalsign.com/ExtendedSSL"
30366:   },
30366:   /* Trustwave */
30366:   {
30366:     "CN=SecureTrust CA,O=SecureTrust Corporation,C=US",
30366:     nsnull, "QjK2FvoE/f5dS3rD/fdMQB1aQ68=", nsnull,
30366:     "http://ocsp.trustwave.com"
27009:   }
27009: };
27009: 
27009: static const unsigned int numResponders =
27009:     (sizeof myDefaultOCSPResponders) / (sizeof myDefaultOCSPResponders[0]);
27009: 
27009: static CERT_StringFromCertFcn oldOCSPAIAInfoCallback = nsnull;
27009: 
27009: /*
27009:  * See if we have a hard-coded default responder for this certificate's
27009:  * issuer (unless this certificate is a root certificate).
27009:  *
27009:  * The result needs to be freed (PORT_Free) when no longer in use.
27009:  */
27009: char* PR_CALLBACK MyAlternateOCSPAIAInfoCallback(CERTCertificate *cert) {
27009:   if (cert && !cert->isRoot) {
27009:     unsigned int i;
27009:     for (i=0; i < numResponders; i++) {
27009:       if (!(myDefaultOCSPResponders[i].issuerName));
27009:       else if (!(myDefaultOCSPResponders[i].issuerKeyID));
27009:       else if (!(cert->authKeyID));
27009:       else if (CERT_CompareName(myDefaultOCSPResponders[i].issuerName,
27009:                                 &(cert->issuer)) != SECEqual);
27009:       else if (SECITEM_CompareItem(myDefaultOCSPResponders[i].issuerKeyID,
27009:                                    &(cert->authKeyID->keyID)) != SECEqual);
27009:       else        // Issuer Name and Key Identifier match, so use this OCSP URL.
27009:         return PORT_Strdup(myDefaultOCSPResponders[i].ocspUrl);
27009:     }
27009:   }
27009: 
27009:   // If we've not found a hard-coded default responder, chain to the old
27009:   // callback function (if there is one).
27009:   if (oldOCSPAIAInfoCallback)
27009:     return (*oldOCSPAIAInfoCallback)(cert);
27009: 
27009:   return nsnull;
27009: }
27009: 
27009: void cleanUpMyDefaultOCSPResponders() {
27009:   unsigned int i;
27009: 
27009:   for (i=0; i < numResponders; i++) {
27009:     if (myDefaultOCSPResponders[i].issuerName) {
27009:       CERT_DestroyName(myDefaultOCSPResponders[i].issuerName);
27009:       myDefaultOCSPResponders[i].issuerName = nsnull;
27009:     }
27009:     if (myDefaultOCSPResponders[i].issuerKeyID) {
27009:       SECITEM_FreeItem(myDefaultOCSPResponders[i].issuerKeyID, PR_TRUE);
27009:       myDefaultOCSPResponders[i].issuerKeyID = nsnull;
27009:     }
27009:   }
27009: }
27009: 
27009: SECStatus RegisterMyOCSPAIAInfoCallback() {
27009:   // Prevent multiple registrations.
27009:   if (myDefaultOCSPResponders[0].issuerName)
27009:     return SECSuccess;                 // Already registered ok.
27009: 
27009:   // Populate various fields in the myDefaultOCSPResponders[] array.
27009:   SECStatus rv = SECFailure;
27009:   unsigned int i;
27009:   for (i=0; i < numResponders; i++) {
27009:     // Create a CERTName structure from the issuer name string.
27009:     myDefaultOCSPResponders[i].issuerName = CERT_AsciiToName(
27009:       const_cast<char*>(myDefaultOCSPResponders[i].issuerName_string));
27009:     if (!(myDefaultOCSPResponders[i].issuerName))
27009:       goto loser;
27009:     // Create a SECItem from the Base64 authority key identifier keyID.
27009:     myDefaultOCSPResponders[i].issuerKeyID = NSSBase64_DecodeBuffer(nsnull,
27009:           nsnull, myDefaultOCSPResponders[i].issuerKeyID_base64,
27009:           (PRUint32)PORT_Strlen(myDefaultOCSPResponders[i].issuerKeyID_base64));
27009:     if (!(myDefaultOCSPResponders[i].issuerKeyID))
27009:       goto loser;
27009:   }
27009: 
27009:   // Register our alternate OCSP Responder URL lookup function.
27009:   rv = CERT_RegisterAlternateOCSPAIAInfoCallBack(MyAlternateOCSPAIAInfoCallback,
27009:                                                  &oldOCSPAIAInfoCallback);
27009:   if (rv != SECSuccess)
27009:     goto loser;
27009: 
27009:   return SECSuccess;
27009: 
27009: loser:
27009:   cleanUpMyDefaultOCSPResponders();
27009:   return rv;
27009: }
27009: 
27009: SECStatus UnregisterMyOCSPAIAInfoCallback() {
27009:   SECStatus rv;
27009: 
27009:   // Only allow unregistration if we're already registered.
27009:   if (!(myDefaultOCSPResponders[0].issuerName))
27009:     return SECFailure;
27009: 
27009:   // Unregister our alternate OCSP Responder URL lookup function.
27009:   rv = CERT_RegisterAlternateOCSPAIAInfoCallBack(oldOCSPAIAInfoCallback,
27009:                                                  nsnull);
27009:   if (rv != SECSuccess)
27009:     return rv;
27009: 
27009:   // Tidy up.
27009:   oldOCSPAIAInfoCallback = nsnull;
27009:   cleanUpMyDefaultOCSPResponders();
27009:   return SECSuccess;
27009: }
