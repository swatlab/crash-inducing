42611: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
42611:  * ***** BEGIN LICENSE BLOCK *****
42611:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42611:  *
42611:  * The contents of this file are subject to the Mozilla Public License Version
42611:  * 1.1 (the "License"); you may not use this file except in compliance with
42611:  * the License. You may obtain a copy of the License at
42611:  * http://www.mozilla.org/MPL/
42611:  *
42611:  * Software distributed under the License is distributed on an "AS IS" basis,
42611:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42611:  * for the specific language governing rights and limitations under the
42611:  * License.
42611:  *
42611:  * The Original Code is Mozilla Corporation code.
42611:  *
42611:  * The Initial Developer of the Original Code is Mozilla Foundation.
42611:  * Portions created by the Initial Developer are Copyright (C) 2009
42611:  * the Initial Developer. All Rights Reserved.
42611:  *
42611:  * Contributor(s):
42611:  *   Bas Schouten <bschouten@mozilla.com>
42611:  *
42611:  * Alternatively, the contents of this file may be used under the terms of
42611:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42611:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42611:  * in which case the provisions of the GPL or the LGPL are applicable instead
42611:  * of those above. If you wish to allow use of your version of this file only
42611:  * under the terms of either the GPL or the LGPL, and not to allow others to
42611:  * use your version of this file under the terms of the MPL, indicate your
42611:  * decision by deleting the provisions above and replace them with the notice
42611:  * and other provisions required by the GPL or the LGPL. If you do not delete
42611:  * the provisions above, a recipient may use your version of this file under
42611:  * the terms of any one of the MPL, the GPL or the LGPL.
42611:  *
42611:  * ***** END LICENSE BLOCK ***** */
42611: 
72995: #include "mozilla/layers/PLayers.h"
80467: 
80467: /* This must occur *after* layers/PLayers.h to avoid typedefs conflicts. */
80467: #include "mozilla/Util.h"
80467: 
72995: #include "mozilla/layers/ShadowLayers.h"
72995: #include "ShadowBufferD3D9.h"
72995: 
42611: #include "ThebesLayerD3D9.h"
42611: #include "gfxPlatform.h"
42611: 
47366: #include "gfxWindowsPlatform.h"
59775: #include "gfxTeeSurface.h"
59775: #include "gfxUtils.h"
62701: #include "ReadbackProcessor.h"
47366: 
42611: namespace mozilla {
42611: namespace layers {
42611: 
42611: ThebesLayerD3D9::ThebesLayerD3D9(LayerManagerD3D9 *aManager)
42611:   : ThebesLayer(aManager, NULL)
42611:   , LayerD3D9(aManager)
42611: {
42611:   mImplData = static_cast<LayerD3D9*>(this);
53783:   aManager->deviceManager()->mLayersWithResources.AppendElement(this);
42611: }
42611: 
42611: ThebesLayerD3D9::~ThebesLayerD3D9()
42611: {
53980:   if (mD3DManager) {
53783:     mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
42611:   }
51977: }
42611: 
47109: /**
47109:  * Retention threshold - amount of pixels intersection required to enable
47109:  * layer content retention. This is a guesstimate. Profiling could be done to
47109:  * figure out the optimal threshold.
47109:  */
47109: #define RETENTION_THRESHOLD 16384
42611: 
42611: void
59775: ThebesLayerD3D9::InvalidateRegion(const nsIntRegion &aRegion)
42611: {
59775:   mValidRegion.Sub(mValidRegion, aRegion);
42611: }
47366: 
59775: void
59775: ThebesLayerD3D9::CopyRegion(IDirect3DTexture9* aSrc, const nsIntPoint &aSrcOffset,
59775:                             IDirect3DTexture9* aDest, const nsIntPoint &aDestOffset,
72233:                             const nsIntRegion &aCopyRegion, nsIntRegion* aValidRegion)
59775: {
47109:   nsRefPtr<IDirect3DSurface9> srcSurface, dstSurface;
59775:   aSrc->GetSurfaceLevel(0, getter_AddRefs(srcSurface));
59775:   aDest->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
47109: 
47109:   nsIntRegion retainedRegion;
59775:   nsIntRegionRectIterator iter(aCopyRegion);
47109:   const nsIntRect *r;
47109:   while ((r = iter.Next())) {
47109:     if (r->width * r->height > RETENTION_THRESHOLD) {
47109:       RECT oldRect, newRect;
47109: 
47109:       // Calculate the retained rectangle's position on the old and the new
72233:       // surface.
72233:       oldRect.left = r->x - aSrcOffset.x;
72233:       oldRect.top = r->y - aSrcOffset.y;
72233:       oldRect.right = oldRect.left + r->width;
72233:       oldRect.bottom = oldRect.top + r->height;
47109: 
72233:       newRect.left = r->x - aDestOffset.x;
72233:       newRect.top = r->y - aDestOffset.y;
72233:       newRect.right = newRect.left + r->width;
72233:       newRect.bottom = newRect.top + r->height;
47109: 
47109:       // Copy data from our old texture to the new one
47109:       HRESULT hr = device()->
47109:         StretchRect(srcSurface, &oldRect, dstSurface, &newRect, D3DTEXF_NONE);
47109: 
47109:       if (SUCCEEDED(hr)) {
47109:         retainedRegion.Or(retainedRegion, *r);
47109:       }
47109:     }
47109:   }
47109: 
47109:   // Areas which were valid and were retained are still valid
59775:   aValidRegion->And(*aValidRegion, retainedRegion);
42611: }
42611: 
59775: static PRUint64 RectArea(const nsIntRect& aRect)
42611: {
59775:   return aRect.width*PRUint64(aRect.height);
42611: }
42611: 
42611: void
59775: ThebesLayerD3D9::UpdateTextures(SurfaceMode aMode)
42611: {
59775:   nsIntRect visibleRect = mVisibleRegion.GetBounds();
59775: 
59775:   if (HaveTextures(aMode)) {
68638:     if (!mTextureRect.IsEqualInterior(visibleRect)) {
59775:       nsRefPtr<IDirect3DTexture9> oldTexture = mTexture;
59775:       nsRefPtr<IDirect3DTexture9> oldTextureOnWhite = mTextureOnWhite;
59775: 
59775:       NS_ASSERTION(mTextureRect.Contains(mValidRegion.GetBounds()),
59775:                    "How can we have valid data outside the texture?");
59775:       nsIntRegion retainRegion;
59775:       // The region we want to retain is the valid data that is inside
59775:       // the new visible region
59775:       retainRegion.And(mValidRegion, mVisibleRegion);
59775: 
59775:       CreateNewTextures(gfxIntSize(visibleRect.width, visibleRect.height), aMode);
59775: 
59775:       // If our texture creation failed this can mean a device reset is pending and we
59775:       // should silently ignore the failure. In the future when device failures
59775:       // are properly handled we should test for the type of failure and gracefully
59775:       // handle different failures. See bug 569081.
59775:       if (!HaveTextures(aMode)) {
59775:         mValidRegion.SetEmpty();
59775:       } else {
59775:         CopyRegion(oldTexture, mTextureRect.TopLeft(), mTexture, visibleRect.TopLeft(),
72233:                    retainRegion, &mValidRegion);
59775:         if (aMode == SURFACE_COMPONENT_ALPHA) {
59775:           CopyRegion(oldTextureOnWhite, mTextureRect.TopLeft(), mTextureOnWhite, visibleRect.TopLeft(),
72233:                      retainRegion, &mValidRegion);
59775:         }
47109:       }
47366: 
59775:       mTextureRect = visibleRect;
59775:     }
59775:   } else {
59775:     CreateNewTextures(gfxIntSize(visibleRect.width, visibleRect.height), aMode);
59775:     mTextureRect = visibleRect;
42956:     
59775:     NS_ASSERTION(mValidRegion.IsEmpty(), "Someone forgot to empty the region");
47366:   }
47366: }
47366: 
59775: void
64539: ThebesLayerD3D9::RenderRegion(const nsIntRegion& aRegion)
59775: {
64539:   nsIntRegionRectIterator iter(aRegion);
52176: 
52176:   const nsIntRect *iterRect;
52176:   while ((iterRect = iter.Next())) {
54880:     device()->SetVertexShaderConstantF(CBvLayerQuad,
54880:                                        ShaderConstantRect(iterRect->x,
54880:                                                           iterRect->y,
54880:                                                           iterRect->width,
54880:                                                           iterRect->height),
54880:                                        1);
52176: 
54880:     device()->SetVertexShaderConstantF(CBvTextureCoords,
54880:       ShaderConstantRect(
59775:         (float)(iterRect->x - mTextureRect.x) / (float)mTextureRect.width,
59775:         (float)(iterRect->y - mTextureRect.y) / (float)mTextureRect.height,
59775:         (float)iterRect->width / (float)mTextureRect.width,
59775:         (float)iterRect->height / (float)mTextureRect.height), 1);
54880: 
42611:     device()->DrawPrimitive(D3DPT_TRIANGLESTRIP, 0, 2);
42611:   }
59775: }
59775: 
59775: void
62701: ThebesLayerD3D9::RenderThebesLayer(ReadbackProcessor* aReadback)
59775: {
59775:   if (mVisibleRegion.IsEmpty()) {
59775:     return;
59775:   }
59775: 
64536:   nsIntRect newTextureRect = mVisibleRegion.GetBounds();
64536: 
59775:   SurfaceMode mode = GetSurfaceMode();
59775:   if (mode == SURFACE_COMPONENT_ALPHA &&
59775:       (!mParent || !mParent->SupportsComponentAlphaChildren())) {
59775:     mode = SURFACE_SINGLE_CHANNEL_ALPHA;
59775:   }
64536:   // If we have a transform that requires resampling of our texture, then
64536:   // we need to make sure we don't sample pixels that haven't been drawn.
64536:   // We clamp sample coordinates to the texture rect, but when the visible region
64536:   // doesn't fill the entire texture rect we need to make sure we draw all the
64536:   // pixels in the texture rect anyway in case they get sampled.
64536:   nsIntRegion neededRegion = mVisibleRegion;
68638:   if (!neededRegion.GetBounds().IsEqualInterior(newTextureRect) ||
64536:       neededRegion.GetNumRects() > 1) {
64536:     gfxMatrix transform2d;
64536:     if (!GetEffectiveTransform().Is2D(&transform2d) ||
64536:         transform2d.HasNonIntegerTranslation()) {
64536:       neededRegion = newTextureRect;
64536:       if (mode == SURFACE_OPAQUE) {
64536:         // We're going to paint outside the visible region, but layout hasn't
64536:         // promised that it will paint opaquely there, so we'll have to
64536:         // treat this layer as transparent.
64536:         mode = SURFACE_SINGLE_CHANNEL_ALPHA;
64536:       }
64536:     }
64536:   }
64536: 
59775:   VerifyContentType(mode);
59775:   UpdateTextures(mode);
59775:   if (!HaveTextures(mode)) {
59775:     NS_WARNING("Texture creation failed");
59775:     return;
59775:   }
59775: 
62701:   nsTArray<ReadbackProcessor::Update> readbackUpdates;
62701:   nsIntRegion readbackRegion;
62701:   if (aReadback && UsedForReadback()) {
62701:     aReadback->GetThebesLayerUpdates(this, &readbackUpdates, &readbackRegion);
62701:   }
62701: 
62701:   // Because updates to D3D9 ThebesLayers are rendered with the CPU, we don't
62701:   // have to do readback from D3D9 surfaces. Instead we make sure that any area
62701:   // needed for readback is included in the drawRegion we ask layout to render.
62701:   // Then the readback areas we need can be copied out of the temporary
62701:   // destinationSurface in DrawRegion.
62701:   nsIntRegion drawRegion;
64536:   drawRegion.Sub(neededRegion, mValidRegion);
62701:   drawRegion.Or(drawRegion, readbackRegion);
62701:   // NS_ASSERTION(mVisibleRegion.Contains(region), "Bad readback region!");
62701: 
62701:   if (!drawRegion.IsEmpty()) {
60858:     LayerManagerD3D9::CallbackInfo cbInfo = mD3DManager->GetCallbackInfo();
60858:     if (!cbInfo.Callback) {
60858:       NS_ERROR("D3D9 should never need to update ThebesLayers in an empty transaction");
60858:       return;
60858:     }
60858: 
62701:     DrawRegion(drawRegion, mode, readbackUpdates);
59775: 
64536:     mValidRegion = neededRegion;
59775:   }
59775: 
59775:   SetShaderTransformAndOpacity();
59775: 
59775:   if (mode == SURFACE_COMPONENT_ALPHA) {
59775:     mD3DManager->SetShaderMode(DeviceManagerD3D9::COMPONENTLAYERPASS1);
59775:     device()->SetTexture(0, mTexture);
59775:     device()->SetTexture(1, mTextureOnWhite);
59775:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ZERO);
59775:     device()->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCCOLOR);
64539:     RenderRegion(neededRegion);
59775: 
59775:     mD3DManager->SetShaderMode(DeviceManagerD3D9::COMPONENTLAYERPASS2);
59775:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
59775:     device()->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_ONE);
64539:     RenderRegion(neededRegion);
59775: 
59775:     // Restore defaults
59775:     device()->SetRenderState(D3DRS_SRCBLEND, D3DBLEND_ONE);
59775:     device()->SetRenderState(D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
59775:     device()->SetTexture(1, NULL);
59775:   } else {
59775:     mD3DManager->SetShaderMode(DeviceManagerD3D9::RGBALAYER);
59775:     device()->SetTexture(0, mTexture);
64539:     RenderRegion(neededRegion);
59775:   }
42611: 
52176:   // Set back to default.
54880:   device()->SetVertexShaderConstantF(CBvTextureCoords,
54880:                                      ShaderConstantRect(0, 0, 1.0f, 1.0f),
54880:                                      1);
52176: }
52176: 
42611: void
42611: ThebesLayerD3D9::CleanResources()
42611: {
42611:   mTexture = nsnull;
59775:   mTextureOnWhite = nsnull;
59813:   mValidRegion.SetEmpty();
42611: }
42611: 
53979: void
53979: ThebesLayerD3D9::LayerManagerDestroyed()
53979: {
53979:   mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
53979:   mD3DManager = nsnull;
53979: }
53979: 
42611: Layer*
42611: ThebesLayerD3D9::GetLayer()
42611: {
42611:   return this;
42611: }
42611: 
79445: bool
42611: ThebesLayerD3D9::IsEmpty()
42611: {
42611:   return !mTexture;
42611: }
42611: 
49323: void
59775: ThebesLayerD3D9::VerifyContentType(SurfaceMode aMode)
53680: {
59775:   if (!mTexture)
59775:     return;
59775: 
59775:   D3DSURFACE_DESC desc;
59775:   mTexture->GetLevelDesc(0, &desc);
59775: 
59775:   switch (aMode) {
59775:   case SURFACE_OPAQUE:
59775:     if (desc.Format == D3DFMT_X8R8G8B8 && !mTextureOnWhite)
59775:       return;
59775:     break;
59775: 
59775:   case SURFACE_SINGLE_CHANNEL_ALPHA:
59775:     if (desc.Format == D3DFMT_A8R8G8B8 && !mTextureOnWhite)
59775:       return;
59775:     break;
59775: 
59775:   case SURFACE_COMPONENT_ALPHA:
59775:     if (mTextureOnWhite) {
59775:       NS_ASSERTION(desc.Format == D3DFMT_X8R8G8B8, "Wrong format for component alpha texture");
59775:       return;
59775:     }
59775:     break;
59775:   }
59775: 
59775:   // The new format isn't compatible with the old texture(s), toss out the old
59775:   // texture(s).
59775:   mTexture = nsnull;
59775:   mTextureOnWhite = nsnull;
59775:   mValidRegion.SetEmpty();
59775: }
59775: 
59775: class OpaqueRenderer {
59775: public:
59775:   OpaqueRenderer(const nsIntRegion& aUpdateRegion) :
59775:     mUpdateRegion(aUpdateRegion), mDC(NULL) {}
60263:   ~OpaqueRenderer() { End(); }
72233:   already_AddRefed<gfxWindowsSurface> Begin(LayerD3D9* aLayer);
59775:   void End();
59775:   IDirect3DTexture9* GetTexture() { return mTmpTexture; }
59775: 
59775: private:
59775:   const nsIntRegion& mUpdateRegion;
59775:   nsRefPtr<IDirect3DTexture9> mTmpTexture;
59775:   nsRefPtr<IDirect3DSurface9> mSurface;
59775:   HDC mDC;
59775: };
59775: 
59775: already_AddRefed<gfxWindowsSurface>
72233: OpaqueRenderer::Begin(LayerD3D9* aLayer)
59775: {
59775:   nsIntRect bounds = mUpdateRegion.GetBounds();
59775: 
59775:   HRESULT hr = aLayer->device()->
72233:       CreateTexture(bounds.width, bounds.height, 1, 0, D3DFMT_X8R8G8B8,
59775:                     D3DPOOL_SYSTEMMEM, getter_AddRefs(mTmpTexture), NULL);
59775: 
59775:   if (FAILED(hr)) {
59775:     aLayer->ReportFailure(NS_LITERAL_CSTRING("Failed to create temporary texture in system memory."), hr);
59775:     return nsnull;
59775:   }
59775: 
59775:   hr = mTmpTexture->GetSurfaceLevel(0, getter_AddRefs(mSurface));
59775: 
59775:   if (FAILED(hr)) {
59775:     // Uh-oh, bail.
59775:     NS_WARNING("Failed to get texture surface level.");
59775:     return nsnull;
59775:   }
59775: 
59775:   hr = mSurface->GetDC(&mDC);
59775:   if (FAILED(hr)) {
59775:     NS_WARNING("Failed to get device context for texture surface.");
59775:     return nsnull;
59775:   }
59775: 
59775:   nsRefPtr<gfxWindowsSurface> result = new gfxWindowsSurface(mDC);
59775:   return result.forget();
53680: }
53680: 
53680: void
59775: OpaqueRenderer::End()
59775: {
60263:   if (mSurface && mDC) {
59775:     mSurface->ReleaseDC(mDC);
60263:     mSurface = NULL;
60263:     mDC = NULL;
60263:   }
59775: }
59775: 
59775: static void
59775: FillSurface(gfxASurface* aSurface, const nsIntRegion& aRegion,
72233:             const nsIntPoint& aOffset, const gfxRGBA& aColor)
59775: {
59775:   nsRefPtr<gfxContext> ctx = new gfxContext(aSurface);
59775:   ctx->Translate(-gfxPoint(aOffset.x, aOffset.y));
59775:   gfxUtils::ClipToRegion(ctx, aRegion);
59775:   ctx->SetColor(aColor);
59775:   ctx->Paint();
59775: }
59775: 
59775: void
62701: ThebesLayerD3D9::DrawRegion(nsIntRegion &aRegion, SurfaceMode aMode,
62701:                             const nsTArray<ReadbackProcessor::Update>& aReadbackUpdates)
49323: {
49323:   HRESULT hr;
49323:   nsIntRect visibleRect = mVisibleRegion.GetBounds();
49323: 
59775:   nsRefPtr<gfxASurface> destinationSurface;
49323:   nsIntRect bounds = aRegion.GetBounds();
59775:   nsRefPtr<IDirect3DTexture9> tmpTexture;
59775:   OpaqueRenderer opaqueRenderer(aRegion);
59775:   OpaqueRenderer opaqueRendererOnWhite(aRegion);
49323: 
59775:   switch (aMode)
59775:   {
59775:     case SURFACE_OPAQUE:
72233:       destinationSurface = opaqueRenderer.Begin(this);
59775:       break;
49323: 
59775:     case SURFACE_SINGLE_CHANNEL_ALPHA: {
72233:       hr = device()->CreateTexture(bounds.width, bounds.height, 1,
59775:                                    0, D3DFMT_A8R8G8B8,
49323:                                    D3DPOOL_SYSTEMMEM, getter_AddRefs(tmpTexture), NULL);
49323: 
55203:       if (FAILED(hr)) {
55203:         ReportFailure(NS_LITERAL_CSTRING("Failed to create temporary texture in system memory."), hr);
55203:         return;
55203:       }
55203: 
49323:       // XXX - We may consider retaining a SYSTEMMEM texture texture the size
49323:       // of our DEFAULT texture and then use UpdateTexture and add dirty rects
49323:       // to update in a single call.
59775:       nsRefPtr<gfxWindowsSurface> dest = new gfxWindowsSurface(
72233:           gfxIntSize(bounds.width, bounds.height), gfxASurface::ImageFormatARGB32);
59775:       // If the contents of this layer don't require component alpha in the
59775:       // end of rendering, it's safe to enable Cleartype since all the Cleartype
59775:       // glyphs must be over (or under) opaque pixels.
59775:       dest->SetSubpixelAntialiasingEnabled(!(mContentFlags & CONTENT_COMPONENT_ALPHA));
59775:       destinationSurface = dest.forget();
59775:       break;
59775:     }
59775: 
59775:     case SURFACE_COMPONENT_ALPHA: {
72233:       nsRefPtr<gfxWindowsSurface> onBlack = opaqueRenderer.Begin(this);
72233:       nsRefPtr<gfxWindowsSurface> onWhite = opaqueRendererOnWhite.Begin(this);
60262:       if (onBlack && onWhite) {
72233:         FillSurface(onBlack, aRegion, bounds.TopLeft(), gfxRGBA(0.0, 0.0, 0.0, 1.0));
72233:         FillSurface(onWhite, aRegion, bounds.TopLeft(), gfxRGBA(1.0, 1.0, 1.0, 1.0));
59775:         gfxASurface* surfaces[2] = { onBlack.get(), onWhite.get() };
80467:         destinationSurface = new gfxTeeSurface(surfaces, ArrayLength(surfaces));
59775:         // Using this surface as a source will likely go horribly wrong, since
59775:         // only the onBlack surface will really be used, so alpha information will
59775:         // be incorrect.
80486:         destinationSurface->SetAllowUseAsSource(false);
60262:       }
59775:       break;
59775:     }
49323:   }
49323: 
60263:   if (!destinationSurface)
60263:     return;
60263: 
60231:   nsRefPtr<gfxContext> context = new gfxContext(destinationSurface);
49323:   context->Translate(gfxPoint(-bounds.x, -bounds.y));
49323:   LayerManagerD3D9::CallbackInfo cbInfo = mD3DManager->GetCallbackInfo();
49323:   cbInfo.Callback(this, context, aRegion, nsIntRegion(), cbInfo.CallbackData);
49323: 
62701:   for (PRUint32 i = 0; i < aReadbackUpdates.Length(); ++i) {
62701:     NS_ASSERTION(aMode == SURFACE_OPAQUE,
62701:                  "Transparent surfaces should not be used for readback");
62701:     const ReadbackProcessor::Update& update = aReadbackUpdates[i];
62701:     nsIntPoint offset = update.mLayer->GetBackgroundLayerOffset();
62701:     nsRefPtr<gfxContext> ctx =
62701:         update.mLayer->GetSink()->BeginUpdate(update.mUpdateRect + offset,
62701:                                               update.mSequenceCounter);
62701:     if (ctx) {
62701:       ctx->Translate(gfxPoint(offset.x, offset.y));
62701:       ctx->SetSource(destinationSurface, gfxPoint(bounds.x, bounds.y));
62701:       ctx->Paint();
62701:       update.mLayer->GetSink()->EndUpdate(ctx, update.mUpdateRect + offset);
62701:     }
62701:   }
62701: 
59775:   nsAutoTArray<IDirect3DTexture9*,2> srcTextures;
59775:   nsAutoTArray<IDirect3DTexture9*,2> destTextures;
59775:   switch (aMode)
59775:   {
59775:     case SURFACE_OPAQUE:
59775:       opaqueRenderer.End();
59775:       srcTextures.AppendElement(opaqueRenderer.GetTexture());
59775:       destTextures.AppendElement(mTexture);
59775:       break;
59775: 
59775:     case SURFACE_SINGLE_CHANNEL_ALPHA: {
72995:       LockTextureRectD3D9 textureLock(tmpTexture);
72995:       if (!textureLock.HasLock()) {
72995:         NS_WARNING("Failed to lock ThebesLayer tmpTexture texture.");
72995:         return;
72995:       }
72995: 
72995:       D3DLOCKED_RECT r = textureLock.GetLockRect();
49323: 
49323:       nsRefPtr<gfxImageSurface> imgSurface =
49323:         new gfxImageSurface((unsigned char *)r.pBits,
72233:                             bounds.Size(),
49323:                             r.Pitch,
59775:                             gfxASurface::ImageFormatARGB32);
49323: 
60231:       if (destinationSurface) {
60231:         nsRefPtr<gfxContext> context = new gfxContext(imgSurface);
49323:         context->SetSource(destinationSurface);
49323:         context->SetOperator(gfxContext::OPERATOR_SOURCE);
49323:         context->Paint();
60231:       }
49323: 
49323:       imgSurface = NULL;
49323: 
59775:       srcTextures.AppendElement(tmpTexture);
59775:       destTextures.AppendElement(mTexture);
59775:       break;
49323:     }
49323: 
59775:     case SURFACE_COMPONENT_ALPHA: {
59775:       opaqueRenderer.End();
59775:       opaqueRendererOnWhite.End();
59775:       srcTextures.AppendElement(opaqueRenderer.GetTexture());
59775:       destTextures.AppendElement(mTexture);
59775:       srcTextures.AppendElement(opaqueRendererOnWhite.GetTexture());
59775:       destTextures.AppendElement(mTextureOnWhite);
59775:       break;
59775:     }
59775:   }
59775:   NS_ASSERTION(srcTextures.Length() == destTextures.Length(), "Mismatched lengths");
59775: 
72233:   // Copy to the texture.
59775:   for (PRUint32 i = 0; i < srcTextures.Length(); ++i) {
49323:     nsRefPtr<IDirect3DSurface9> srcSurface;
49323:     nsRefPtr<IDirect3DSurface9> dstSurface;
49323: 
59775:     destTextures[i]->GetSurfaceLevel(0, getter_AddRefs(dstSurface));
59775:     srcTextures[i]->GetSurfaceLevel(0, getter_AddRefs(srcSurface));
49323: 
49323:     nsIntRegionRectIterator iter(aRegion);
49323:     const nsIntRect *iterRect;
49323:     while ((iterRect = iter.Next())) {
49323:       RECT rect;
72233:       rect.left = iterRect->x - bounds.x;
72233:       rect.top = iterRect->y - bounds.y;
72233:       rect.right = iterRect->XMost() - bounds.x;
72233:       rect.bottom = iterRect->YMost() - bounds.y;
62853: 
49323:       POINT point;
72233:       point.x = iterRect->x - visibleRect.x;
72233:       point.y = iterRect->y - visibleRect.y;
49323:       device()->UpdateSurface(srcSurface, &rect, dstSurface, &point);
49323:     }
49323:   }
59775: }
49323: 
49323: void
59775: ThebesLayerD3D9::CreateNewTextures(const gfxIntSize &aSize,
59775:                                    SurfaceMode aMode)
49323: {
59775:   if (aSize.width == 0 || aSize.height == 0) {
49323:     // Nothing to do.
49323:     return;
49323:   }
49323: 
49323:   mTexture = nsnull;
59775:   mTextureOnWhite = nsnull;
81355:   HRESULT hr = device()->CreateTexture(aSize.width, aSize.height, 1,
59775:                                        D3DUSAGE_RENDERTARGET,
59775:                                        aMode != SURFACE_SINGLE_CHANNEL_ALPHA ? D3DFMT_X8R8G8B8 : D3DFMT_A8R8G8B8,
49323:                                        D3DPOOL_DEFAULT, getter_AddRefs(mTexture), NULL);
81355:   if (FAILED(hr)) {
81355:     ReportFailure(NS_LITERAL_CSTRING("ThebesLayerD3D9::CreateNewTextures(): Failed to create texture"),
81355:                   hr);
81355:     return;
81355:   }
81355: 
59775:   if (aMode == SURFACE_COMPONENT_ALPHA) {
81355:     hr = device()->CreateTexture(aSize.width, aSize.height, 1,
59775:                                  D3DUSAGE_RENDERTARGET,
59775:                                  D3DFMT_X8R8G8B8,
59775:                                  D3DPOOL_DEFAULT, getter_AddRefs(mTextureOnWhite), NULL);
81355:     if (FAILED(hr)) {
81355:       ReportFailure(NS_LITERAL_CSTRING("ThebesLayerD3D9::CreateNewTextures(): Failed to create texture (2)"),
81355:                     hr);
81355:       return;
81355:     }
59775:   }
49323: }
49323: 
72995: ShadowThebesLayerD3D9::ShadowThebesLayerD3D9(LayerManagerD3D9 *aManager)
72995:   : ShadowThebesLayer(aManager, nsnull)
72995:   , LayerD3D9(aManager)
72995: {
72995:   mImplData = static_cast<LayerD3D9*>(this);
72995: }
72995: 
72995: ShadowThebesLayerD3D9::~ShadowThebesLayerD3D9()
72995: {}
72995: 
72995: void
80169: ShadowThebesLayerD3D9::Swap(const ThebesBuffer& aNewFront,
80169:                            const nsIntRegion& aUpdatedRegion,
80169:                            OptionalThebesBuffer* aNewBack,
80169:                            nsIntRegion* aNewBackValidRegion,
80169:                            OptionalThebesBuffer* aReadOnlyFront,
80169:                            nsIntRegion* aFrontUpdatedRegion)
72995: {
72995:   if (!mBuffer) {
72995:     mBuffer = new ShadowBufferD3D9(this);
72995:   }
72995: 
72995:   if (mBuffer) {
72995:     nsRefPtr<gfxASurface> surf = ShadowLayerForwarder::OpenDescriptor(aNewFront.buffer());
72995:     mBuffer->Upload(surf, GetVisibleRegion().GetBounds());
72995:   }
72995: 
72995:   *aNewBack = aNewFront;
72995:   *aNewBackValidRegion = mValidRegion;
72995:   *aReadOnlyFront = null_t();
72995:   aFrontUpdatedRegion->SetEmpty();
72995: }
72995: 
72995: void
72995: ShadowThebesLayerD3D9::DestroyFrontBuffer()
72995: {
72995:   mBuffer = nsnull;
72995: }
72995: 
72995: void
72995: ShadowThebesLayerD3D9::Disconnect()
72995: {
72995:   mBuffer = nsnull;
72995: }
72995: 
72995: Layer*
72995: ShadowThebesLayerD3D9::GetLayer()
72995: {
72995:   return this;
72995: }
72995: 
79445: bool
72995: ShadowThebesLayerD3D9::IsEmpty()
72995: {
72995:   return !mBuffer;
72995: }
72995: 
72995: void
72995: ShadowThebesLayerD3D9::RenderThebesLayer()
72995: {
72995:   if (!mBuffer) {
72995:     return;
72995:   }
72995:   NS_ABORT_IF_FALSE(mBuffer, "should have a buffer here");
72995: 
72995:   mBuffer->RenderTo(mD3DManager, GetEffectiveVisibleRegion());
72995: }
72995: 
72995: void
72995: ShadowThebesLayerD3D9::CleanResources()
72995: {
72995:   mBuffer = nsnull;
72995:   mValidRegion.SetEmpty();
72995: }
72995: 
72995: void
72995: ShadowThebesLayerD3D9::LayerManagerDestroyed()
72995: {
72995:   mD3DManager->deviceManager()->mLayersWithResources.RemoveElement(this);
72995:   mD3DManager = nsnull;
72995: }
72995: 
42611: } /* namespace layers */
42956: } /* namespace mozilla */
