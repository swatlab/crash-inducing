     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef __editor_h__
     1: #define __editor_h__
     1: 
104487: #include "mozilla/Assertions.h"         // for MOZ_ASSERT, etc
104487: #include "nsAutoPtr.h"                  // for nsRefPtr
104487: #include "nsCOMArray.h"                 // for nsCOMArray
104487: #include "nsCOMPtr.h"                   // for already_AddRefed, nsCOMPtr
104487: #include "nsCycleCollectionParticipant.h"
104487: #include "nsEditProperty.h"             // for nsEditProperty, etc
104487: #include "nsIEditor.h"                  // for nsIEditor::EDirection, etc
104487: #include "nsIEditorIMESupport.h"        // for NS_DECL_NSIEDITORIMESUPPORT, etc
104487: #include "nsIObserver.h"                // for NS_DECL_NSIOBSERVER, etc
104487: #include "nsIPhonetic.h"                // for NS_DECL_NSIPHONETIC, etc
104487: #include "nsIPlaintextEditor.h"         // for nsIPlaintextEditor, etc
104487: #include "nsISupportsImpl.h"            // for nsEditor::Release, etc
104487: #include "nsIWeakReferenceUtils.h"      // for nsWeakPtr
104487: #include "nsLiteralString.h"            // for NS_LITERAL_STRING
104487: #include "nsSelectionState.h"           // for nsRangeUpdater, etc
104487: #include "nsString.h"                   // for nsCString
104487: #include "nsWeakReference.h"            // for nsSupportsWeakReference
104487: #include "nscore.h"                     // for nsresult, nsAString, etc
104487: #include "prtypes.h"                    // for PRInt32, PRUint32, PRInt8, etc
     1: 
104487: class AddStyleSheetTxn;
     1: class ChangeAttributeTxn;
     1: class CreateElementTxn;
103680: class DeleteNodeTxn;
     1: class DeleteTextTxn;
     1: class EditAggregateTxn;
     1: class IMETextTxn;
104487: class InsertElementTxn;
104487: class InsertTextTxn;
104487: class JoinElementTxn;
     1: class RemoveStyleSheetTxn;
104487: class SplitElementTxn;
104487: class nsCSSStyleSheet;
104487: class nsIAtom;
104487: class nsIContent;
104487: class nsIDOMCharacterData;
104487: class nsIDOMDataTransfer;
104487: class nsIDOMDocument;
104487: class nsIDOMElement;
104487: class nsIDOMEvent;
104487: class nsIDOMEventListener;
  1418: class nsIDOMEventTarget;
104487: class nsIDOMKeyEvent;
104487: class nsIDOMNSEvent;
104487: class nsIDOMNode;
104487: class nsIDOMRange;
104487: class nsIDocument;
104487: class nsIDocumentStateListener;
104487: class nsIEditActionListener;
104487: class nsIEditorObserver;
104487: class nsIInlineSpellChecker;
104487: class nsINode;
104487: class nsIPresShell;
104487: class nsIPrivateTextRangeList;
104487: class nsISelection;
104487: class nsISupports;
104487: class nsITransaction;
104487: class nsIWidget;
 43438: class nsKeyEvent;
104487: class nsRange;
104487: class nsString;
104487: class nsTransactionManager;
104487: 
104487: namespace mozilla {
104487: class Selection;
104487: 
104487: namespace dom {
104487: class Element;
104487: }  // namespace dom
104487: }  // namespace mozilla
     1: 
 82843: namespace mozilla {
 82843: namespace widget {
 82843: struct IMEState;
 82843: } // namespace widget
 82843: } // namespace mozilla
 82843: 
 41743: #define kMOZEditorBogusNodeAttrAtom nsEditProperty::mozEditorBogusNode
     1: #define kMOZEditorBogusNodeValue NS_LITERAL_STRING("TRUE")
     1: 
     1: /** implementation of an editor object.  it will be the controller/focal point 
     1:  *  for the main editor services. i.e. the GUIManager, publishing, transaction 
     1:  *  manager, event interfaces. the idea for the event interfaces is to have them 
     1:  *  delegate the actual commands to the editor independent of the XPFE implementation.
     1:  */
     1: class nsEditor : public nsIEditor,
     1:                  public nsIEditorIMESupport,
     1:                  public nsSupportsWeakReference,
 78229:                  public nsIObserver,
 67852:                  public nsIPhonetic
     1: {
     1: public:
     1: 
     1:   enum IterDirection
     1:   {
     1:     kIterForward,
     1:     kIterBackward
     1:   };
     1: 
     1:   enum OperationID
     1:   {
     1:     kOpIgnore = -1,
     1:     kOpNone = 0,
     1:     kOpUndo,
     1:     kOpRedo,
     1:     kOpInsertNode,
     1:     kOpCreateNode,
     1:     kOpDeleteNode,
     1:     kOpSplitNode,
     1:     kOpJoinNode,
 97808:     kOpDeleteText = 1003,
 97808: 
     1:     // text commands
 97808:     kOpInsertText         = 2000,
 97808:     kOpInsertIMEText      = 2001,
 97808:     kOpDeleteSelection    = 2002,
 97808:     kOpSetTextProperty    = 2003,
 97808:     kOpRemoveTextProperty = 2004,
 97808:     kOpOutputText         = 2005,
 97808: 
 97808:     // html only action
 97808:     kOpInsertBreak         = 3000,
 97808:     kOpMakeList            = 3001,
 97808:     kOpIndent              = 3002,
 97808:     kOpOutdent             = 3003,
 97808:     kOpAlign               = 3004,
 97808:     kOpMakeBasicBlock      = 3005,
 97808:     kOpRemoveList          = 3006,
 97808:     kOpMakeDefListItem     = 3007,
 97808:     kOpInsertElement       = 3008,
 97808:     kOpInsertQuotation     = 3009,
 97808:     kOpHTMLPaste           = 3012,
 97808:     kOpLoadHTML            = 3013,
 97808:     kOpResetTextProperties = 3014,
 97808:     kOpSetAbsolutePosition = 3015,
 97808:     kOpRemoveAbsolutePosition = 3016,
 97808:     kOpDecreaseZIndex      = 3017,
 97808:     kOpIncreaseZIndex      = 3018
     1:   };
     1: 
     1:   /** The default constructor. This should suffice. the setting of the interfaces is done
     1:    *  after the construction of the editor class.
     1:    */
     1:   nsEditor();
     1:   /** The default destructor. This should suffice. Should this be pure virtual 
     1:    *  for someone to derive from the nsEditor later? I don't believe so.
     1:    */
     1:   virtual ~nsEditor();
     1: 
     1: //Interfaces for addref and release and queryinterface
     1: //NOTE: Use   NS_DECL_ISUPPORTS_INHERITED in any class inherited from nsEditor
 28153:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 28153:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsEditor,
 28153:                                            nsIEditor)
     1: 
     1:   /* ------------ utility methods   -------------- */
 93880:   already_AddRefed<nsIDOMDocument> GetDOMDocument();
 93880:   already_AddRefed<nsIDocument> GetDocument();
 70236:   already_AddRefed<nsIPresShell> GetPresShell();
 70236:   void NotifyEditorObservers();
     1: 
     1:   /* ------------ nsIEditor methods -------------- */
     1:   NS_DECL_NSIEDITOR
     1:   /* ------------ nsIEditorIMESupport methods -------------- */
     1:   NS_DECL_NSIEDITORIMESUPPORT
     1:   
 78229:   /* ------------ nsIObserver methods -------------- */
 78229:   NS_DECL_NSIOBSERVER
 78229: 
     1:   // nsIPhonetic
     1:   NS_DECL_NSIPHONETIC
     1: 
     1: public:
     1: 
 82861:   virtual bool IsModifiableNode(nsINode *aNode);
     1:   
     1:   NS_IMETHOD InsertTextImpl(const nsAString& aStringToInsert, 
     1:                                nsCOMPtr<nsIDOMNode> *aInOutNode, 
     1:                                PRInt32 *aInOutOffset,
     1:                                nsIDOMDocument *aDoc);
 37130:   nsresult InsertTextIntoTextNodeImpl(const nsAString& aStringToInsert, 
     1:                                       nsIDOMCharacterData *aTextNode, 
 37130:                                       PRInt32 aOffset,
 79445:                                       bool aSuppressIME = false);
 98852:   NS_IMETHOD DeleteSelectionImpl(EDirection aAction,
 98852:                                  EStripWrappers aStripWrappers);
     1:   NS_IMETHOD DeleteSelectionAndCreateNode(const nsAString& aTag,
     1:                                            nsIDOMNode ** aNewNode);
     1: 
     1:   /* helper routines for node/parent manipulations */
103679:   nsresult DeleteNode(nsINode* aNode);
101128:   nsresult ReplaceContainer(nsINode* inNode,
101128:                             mozilla::dom::Element** outNode,
101128:                             const nsAString& aNodeType,
101128:                             const nsAString* aAttribute = nsnull,
101128:                             const nsAString* aValue = nsnull,
101128:                             bool aCloneAttributes = false);
     1:   nsresult ReplaceContainer(nsIDOMNode *inNode, 
     1:                             nsCOMPtr<nsIDOMNode> *outNode, 
     1:                             const nsAString &aNodeType,
     1:                             const nsAString *aAttribute = nsnull,
     1:                             const nsAString *aValue = nsnull,
 79445:                             bool aCloneAttributes = false);
     1: 
 89176:   nsresult RemoveContainer(nsINode* aNode);
     1:   nsresult RemoveContainer(nsIDOMNode *inNode);
101124:   nsresult InsertContainerAbove(nsIContent* aNode,
101124:                                 mozilla::dom::Element** aOutNode,
101124:                                 const nsAString& aNodeType,
101124:                                 const nsAString* aAttribute = nsnull,
101124:                                 const nsAString* aValue = nsnull);
     1:   nsresult InsertContainerAbove(nsIDOMNode *inNode, 
     1:                                 nsCOMPtr<nsIDOMNode> *outNode, 
     1:                                 const nsAString &aNodeType,
     1:                                 const nsAString *aAttribute = nsnull,
     1:                                 const nsAString *aValue = nsnull);
100182:   nsresult JoinNodes(nsINode* aNodeToKeep, nsIContent* aNodeToMove);
100182:   nsresult MoveNode(nsIContent* aNode, nsINode* aParent, PRInt32 aOffset);
     1:   nsresult MoveNode(nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aOffset);
     1: 
     1:   /* Method to replace certain CreateElementNS() calls. 
     1:      Arguments:
     1:       nsString& aTag          - tag you want
     1:       nsIContent** aContent   - returned Content that was created with above namespace.
     1:   */
101120:   nsresult CreateHTMLContent(const nsAString& aTag,
101120:                              mozilla::dom::Element** aContent);
     1: 
 46425:   // IME event handlers
 46425:   virtual nsresult BeginIMEComposition();
 46425:   virtual nsresult UpdateIMEComposition(const nsAString &aCompositionString,
 46425:                                         nsIPrivateTextRangeList *aTextRange)=0;
103791:   void EndIMEComposition();
 46425: 
 78325:   void SwitchTextDirectionTo(PRUint32 aDirection);
 78325: 
     1: protected:
 78325:   nsresult DetermineCurrentDirection();
 78325: 
     1:   /** create a transaction for setting aAttribute to aValue on aElement
     1:     */
     1:   NS_IMETHOD CreateTxnForSetAttribute(nsIDOMElement *aElement, 
     1:                                       const nsAString &  aAttribute, 
     1:                                       const nsAString &  aValue,
     1:                                       ChangeAttributeTxn ** aTxn);
     1: 
     1:   /** create a transaction for removing aAttribute on aElement
     1:     */
     1:   NS_IMETHOD CreateTxnForRemoveAttribute(nsIDOMElement *aElement, 
     1:                                          const nsAString &  aAttribute,
     1:                                          ChangeAttributeTxn ** aTxn);
     1: 
     1:   /** create a transaction for creating a new child node of aParent of type aTag.
     1:     */
     1:   NS_IMETHOD CreateTxnForCreateElement(const nsAString & aTag,
     1:                                        nsIDOMNode     *aParent,
     1:                                        PRInt32         aPosition,
     1:                                        CreateElementTxn ** aTxn);
     1: 
     1:   /** create a transaction for inserting aNode as a child of aParent.
     1:     */
     1:   NS_IMETHOD CreateTxnForInsertElement(nsIDOMNode * aNode,
     1:                                        nsIDOMNode * aParent,
     1:                                        PRInt32      aOffset,
     1:                                        InsertElementTxn ** aTxn);
     1: 
103679:   /** create a transaction for removing aNode from its parent.
     1:     */
103680:   nsresult CreateTxnForDeleteNode(nsINode* aNode, DeleteNodeTxn** aTxn);
     1: 
     1: 
101981:   nsresult CreateTxnForDeleteSelection(EDirection aAction,
     1:                                        EditAggregateTxn** aTxn,
101981:                                        nsINode** aNode,
     1:                                        PRInt32* aOffset,
     1:                                        PRInt32* aLength);
     1: 
101981:   nsresult CreateTxnForDeleteInsertionPoint(nsRange* aRange, 
     1:                                             EDirection aAction, 
     1:                                             EditAggregateTxn* aTxn,
101981:                                             nsINode** aNode,
     1:                                             PRInt32* aOffset,
     1:                                             PRInt32* aLength);
     1: 
     1: 
     1:   /** create a transaction for inserting aStringToInsert into aTextNode
     1:     * if aTextNode is null, the string is inserted at the current selection.
     1:     */
     1:   NS_IMETHOD CreateTxnForInsertText(const nsAString & aStringToInsert,
     1:                                     nsIDOMCharacterData *aTextNode,
     1:                                     PRInt32 aOffset,
     1:                                     InsertTextTxn ** aTxn);
     1: 
     1:   NS_IMETHOD CreateTxnForIMEText(const nsAString & aStringToInsert,
     1:                                  IMETextTxn ** aTxn);
     1: 
     1:   /** create a transaction for adding a style sheet
     1:     */
 42163:   NS_IMETHOD CreateTxnForAddStyleSheet(nsCSSStyleSheet* aSheet, AddStyleSheetTxn* *aTxn);
     1: 
     1:   /** create a transaction for removing a style sheet
     1:     */
 42163:   NS_IMETHOD CreateTxnForRemoveStyleSheet(nsCSSStyleSheet* aSheet, RemoveStyleSheetTxn* *aTxn);
     1:   
     1:   NS_IMETHOD DeleteText(nsIDOMCharacterData *aElement,
     1:                         PRUint32             aOffset,
     1:                         PRUint32             aLength);
     1: 
     1: //  NS_IMETHOD DeleteRange(nsIDOMRange *aRange);
     1: 
101981:   nsresult CreateTxnForDeleteText(nsIDOMCharacterData* aElement,
     1:                                   PRUint32             aOffset,
     1:                                   PRUint32             aLength,
     1:                                   DeleteTextTxn**      aTxn);
     1: 
     1:   nsresult CreateTxnForDeleteCharacter(nsIDOMCharacterData* aData,
     1:                                        PRUint32             aOffset,
101981:                                        EDirection           aDirection,
     1:                                        DeleteTextTxn**      aTxn);
     1: 	
     1:   NS_IMETHOD CreateTxnForSplitNode(nsIDOMNode *aNode,
     1:                                    PRUint32    aOffset,
     1:                                    SplitElementTxn **aTxn);
     1: 
     1:   NS_IMETHOD CreateTxnForJoinNode(nsIDOMNode  *aLeftNode,
     1:                                   nsIDOMNode  *aRightNode,
     1:                                   JoinElementTxn **aTxn);
     1: 
102862:   /**
102862:    * This method first deletes the selection, if it's not collapsed.  Then if
102862:    * the selection lies in a CharacterData node, it splits it.  If the
102862:    * selection is at this point collapsed in a CharacterData node, it's
102862:    * adjusted to be collapsed right before or after the node instead (which is
102862:    * always possible, since the node was split).
102862:    */
102862:   nsresult DeleteSelectionAndPrepareToCreateNode();
102862: 
     1: 
     1:   // called after a transaction is done successfully
103792:   void DoAfterDoTransaction(nsITransaction *aTxn);
     1:   // called after a transaction is undone successfully
103792:   void DoAfterUndoTransaction();
     1:   // called after a transaction is redone successfully
103792:   void DoAfterRedoTransaction();
     1: 
     1:   typedef enum {
     1:     eDocumentCreated,
     1:     eDocumentToBeDestroyed,
     1:     eDocumentStateChanged
     1:   } TDocumentListenerNotification;
     1:   
     1:   // tell the doc state listeners that the doc state has changed
     1:   NS_IMETHOD NotifyDocumentListeners(TDocumentListenerNotification aNotificationType);
     1:   
     1:   /** make the given selection span the entire document */
     1:   NS_IMETHOD SelectEntireDocument(nsISelection *aSelection);
     1: 
     1:   /** helper method for scrolling the selection into view after
 80486:    *  an edit operation. aScrollToAnchor should be true if you
     1:    *  want to scroll to the point where the selection was started.
 80486:    *  If false, it attempts to scroll the end of the selection into view.
     1:    *
     1:    *  Editor methods *should* call this method instead of the versions
     1:    *  in the various selection interfaces, since this version makes sure
     1:    *  that the editor's sync/async settings for reflowing, painting, and
     1:    *  scrolling match.
     1:    */
 79445:   NS_IMETHOD ScrollSelectionIntoView(bool aScrollToAnchor);
     1: 
103377:   // Convenience method; forwards to IsBlockNode(nsINode*).
103377:   bool IsBlockNode(nsIDOMNode* aNode);
     1:   // stub.  see comment in source.                     
 82861:   virtual bool IsBlockNode(nsINode* aNode);
     1:   
 82862:   // helper for GetPriorNode and GetNextNode
 82862:   nsIContent* FindNextLeafNode(nsINode  *aCurrentNode,
 82862:                                bool      aGoForward,
 97988:                                bool      bNoBlockCrossing);
     1: 
 15919:   // Get nsIWidget interface
 15919:   nsresult GetWidget(nsIWidget **aWidget);
     1: 
     1: 
     1:   // install the event listeners for the editor 
 40987:   virtual nsresult InstallEventListeners();
     1: 
 73869:   virtual void CreateEventListeners();
     1: 
     1:   // unregister and release our event listeners
     1:   virtual void RemoveEventListeners();
     1: 
     1:   /**
     1:    * Return true if spellchecking should be enabled for this editor.
     1:    */
 79445:   bool GetDesiredSpellCheckState();
     1: 
 43438:   nsKeyEvent* GetNativeKeyEvent(nsIDOMKeyEvent* aDOMKeyEvent);
 43438: 
 79445:   bool CanEnableSpellCheck()
 50883:   {
 50883:     // Check for password/readonly/disabled, which are not spellchecked
 80481:     // regardless of DOM. Also, check to see if spell check should be skipped or not.
 80481:     return !IsPasswordEditor() && !IsReadonly() && !IsDisabled() && !ShouldSkipSpellCheck();
 50883:   }
 50883: 
     1: public:
     1: 
     1:   /** All editor operations which alter the doc should be prefaced
     1:    *  with a call to StartOperation, naming the action and direction */
 97808:   NS_IMETHOD StartOperation(OperationID opID,
 97808:                             nsIEditor::EDirection aDirection);
     1: 
     1:   /** All editor operations which alter the doc should be followed
     1:    *  with a call to EndOperation */
     1:   NS_IMETHOD EndOperation();
     1: 
     1:   /** routines for managing the preservation of selection across 
     1:    *  various editor actions */
 79445:   bool     ArePreservingSelection();
106286:   void     PreserveSelectionAcrossActions(mozilla::Selection* aSel);
     1:   nsresult RestorePreservedSelection(nsISelection *aSel);
     1:   void     StopPreservingSelection();
     1: 
     1:   /** 
     1:    * SplitNode() creates a new node identical to an existing node, and split the contents between the two nodes
     1:    * @param aExistingRightNode   the node to split.  It will become the new node's next sibling.
     1:    * @param aOffset              the offset of aExistingRightNode's content|children to do the split at
     1:    * @param aNewLeftNode         [OUT] the new node resulting from the split, becomes aExistingRightNode's previous sibling.
     1:    * @param aParent              the parent of aExistingRightNode
     1:    */
     1:   nsresult SplitNodeImpl(nsIDOMNode *aExistingRightNode,
     1:                          PRInt32     aOffset,
     1:                          nsIDOMNode *aNewLeftNode,
     1:                          nsIDOMNode *aParent);
     1: 
     1:   /** 
     1:    * JoinNodes() takes 2 nodes and merge their content|children.
     1:    * @param aNodeToKeep   The node that will remain after the join.
     1:    * @param aNodeToJoin   The node that will be joined with aNodeToKeep.
     1:    *                      There is no requirement that the two nodes be of the same type.
     1:    * @param aParent       The parent of aNodeToKeep
 80486:    * @param aNodeToKeepIsFirst  if true, the contents|children of aNodeToKeep come before the
     1:    *                            contents|children of aNodeToJoin, otherwise their positions are switched.
     1:    */
     1:   nsresult JoinNodesImpl(nsIDOMNode *aNodeToKeep,
     1:                          nsIDOMNode *aNodeToJoin,
     1:                          nsIDOMNode *aParent,
 79445:                          bool        aNodeToKeepIsFirst);
     1: 
     1:   /**
103677:    * Return the offset of aChild in aParent.  Asserts fatally if parent or
103677:    * child is null, or parent is not child's parent.
     1:    */
103677:   static PRInt32 GetChildOffset(nsIDOMNode *aChild,
103677:                                 nsIDOMNode *aParent);
     1: 
     1:   /**
103950:    *  Set outOffset to the offset of aChild in the parent.
103950:    *  Returns the parent of aChild.
     1:    */
103950:   static already_AddRefed<nsIDOMNode> GetNodeLocation(nsIDOMNode* aChild,
103678:                                                       PRInt32* outOffset);
     1: 
     1:   /** returns the number of things inside aNode in the out-param aCount.  
     1:     * @param  aNode is the node to get the length of.  
     1:     *         If aNode is text, returns number of characters. 
     1:     *         If not, returns number of children nodes.
     1:     * @param  aCount [OUT] the result of the above calculation.
     1:     */
     1:   static nsresult GetLengthOfDOMNode(nsIDOMNode *aNode, PRUint32 &aCount);
     1: 
     1:   /** get the node immediately prior to aCurrentNode
     1:     * @param aCurrentNode   the node from which we start the search
 80486:     * @param aEditableNode  if true, only return an editable node
     1:     * @param aResultNode    [OUT] the node that occurs before aCurrentNode in the tree,
 80486:     *                       skipping non-editable nodes if aEditableNode is true.
     1:     *                       If there is no prior node, aResultNode will be nsnull.
 82864:     * @param bNoBlockCrossing If true, don't move across "block" nodes, whatever that means.
     1:     */
     1:   nsresult GetPriorNode(nsIDOMNode  *aCurrentNode, 
 79445:                         bool         aEditableNode,
     1:                         nsCOMPtr<nsIDOMNode> *aResultNode,
 97988:                         bool         bNoBlockCrossing = false);
 97755:   nsIContent* GetPriorNode(nsINode* aCurrentNode, bool aEditableNode,
 97988:                            bool aNoBlockCrossing = false);
     1: 
     1:   // and another version that takes a {parent,offset} pair rather than a node
     1:   nsresult GetPriorNode(nsIDOMNode  *aParentNode, 
     1:                         PRInt32      aOffset, 
 79445:                         bool         aEditableNode, 
     1:                         nsCOMPtr<nsIDOMNode> *aResultNode,
 97988:                         bool         bNoBlockCrossing = false);
 97755:   nsIContent* GetPriorNode(nsINode* aParentNode,
 97755:                            PRInt32 aOffset,
 97755:                            bool aEditableNode,
 97988:                            bool aNoBlockCrossing = false);
 97755: 
     1: 
     1:   /** get the node immediately after to aCurrentNode
     1:     * @param aCurrentNode   the node from which we start the search
 80486:     * @param aEditableNode  if true, only return an editable node
     1:     * @param aResultNode    [OUT] the node that occurs after aCurrentNode in the tree,
 80486:     *                       skipping non-editable nodes if aEditableNode is true.
     1:     *                       If there is no prior node, aResultNode will be nsnull.
     1:     */
     1:   nsresult GetNextNode(nsIDOMNode  *aCurrentNode, 
 79445:                        bool         aEditableNode,
     1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
 97988:                        bool         bNoBlockCrossing = false);
 89183:   nsIContent* GetNextNode(nsINode* aCurrentNode,
 89183:                           bool aEditableNode,
 97988:                           bool bNoBlockCrossing = false);
     1: 
     1:   // and another version that takes a {parent,offset} pair rather than a node
     1:   nsresult GetNextNode(nsIDOMNode  *aParentNode, 
     1:                        PRInt32      aOffset, 
 79445:                        bool         aEditableNode, 
     1:                        nsCOMPtr<nsIDOMNode> *aResultNode,
 97988:                        bool         bNoBlockCrossing = false);
 97755:   nsIContent* GetNextNode(nsINode* aParentNode,
 97755:                           PRInt32 aOffset,
 97755:                           bool aEditableNode,
 97988:                           bool aNoBlockCrossing = false);
     1: 
 82863:   // Helper for GetNextNode and GetPriorNode
 82863:   nsIContent* FindNode(nsINode *aCurrentNode,
 82863:                        bool     aGoForward,
 82863:                        bool     aEditableNode,
 97988:                        bool     bNoBlockCrossing);
 75266:   /**
 75266:    * Get the rightmost child of aCurrentNode;
     1:    * return nsnull if aCurrentNode has no children.
     1:    */
 75266:   already_AddRefed<nsIDOMNode> GetRightmostChild(nsIDOMNode *aCurrentNode, 
 79445:                                                  bool        bNoBlockCrossing = false);
 82861:   nsIContent* GetRightmostChild(nsINode *aCurrentNode,
 82861:                                 bool     bNoBlockCrossing = false);
     1: 
 75266:   /**
 75266:    * Get the leftmost child of aCurrentNode;
     1:    * return nsnull if aCurrentNode has no children.
     1:    */
 75266:   already_AddRefed<nsIDOMNode> GetLeftmostChild(nsIDOMNode  *aCurrentNode, 
 79445:                                                 bool        bNoBlockCrossing = false);
 82861:   nsIContent* GetLeftmostChild(nsINode *aCurrentNode,
 82861:                                bool     bNoBlockCrossing = false);
     1: 
 80486:   /** returns true if aNode is of the type implied by aTag */
 79445:   static inline bool NodeIsType(nsIDOMNode *aNode, nsIAtom *aTag)
     1:   {
     1:     return GetTag(aNode) == aTag;
     1:   }
     1: 
 80486:   /** returns true if aParent can contain a child of type aTag */
 97375:   bool CanContain(nsIDOMNode* aParent, nsIDOMNode* aChild);
 97376:   bool CanContainTag(nsIDOMNode* aParent, nsIAtom* aTag);
 97376:   bool TagCanContain(nsIAtom* aParentTag, nsIDOMNode* aChild);
 97376:   virtual bool TagCanContainTag(nsIAtom* aParentTag, nsIAtom* aChildTag);
     1: 
 80486:   /** returns true if aNode is our root node */
 97986:   bool IsRoot(nsIDOMNode* inNode);
 97986:   bool IsRoot(nsINode* inNode);
 97988:   bool IsEditorRoot(nsINode* aNode);
     1: 
 80486:   /** returns true if aNode is a descendant of our root node */
 97986:   bool IsDescendantOfRoot(nsIDOMNode* inNode);
 97986:   bool IsDescendantOfRoot(nsINode* inNode);
 97989:   bool IsDescendantOfEditorRoot(nsIDOMNode* aNode);
 97988:   bool IsDescendantOfEditorRoot(nsINode* aNode);
     1: 
 80486:   /** returns true if aNode is a container */
 79445:   virtual bool IsContainer(nsIDOMNode *aNode);
     1: 
 80486:   /** returns true if aNode is an editable node */
 80866:   bool IsEditable(nsIDOMNode *aNode);
 98127:   virtual bool IsEditable(nsIContent *aNode);
     1: 
 97761:   /**
 97761:    * aNode must be a non-null text node.
 97761:    */
 82861:   virtual bool IsTextInDirtyFrameVisible(nsIContent *aNode);
     1: 
 80486:   /** returns true if aNode is a MozEditorBogus node */
 82861:   bool IsMozEditorBogusNode(nsIContent *aNode);
     1: 
     1:   /** counts number of editable child nodes */
101123:   PRUint32 CountEditableChildren(nsINode* aNode);
     1:   
 89184:   /** Find the deep first and last children. */
 89184:   nsINode* GetFirstEditableNode(nsINode* aRoot);
     1: 
101070:   PRInt32 GetIMEBufferLength();
 79445:   bool IsIMEComposing();    /* test if IME is in composition state */
     1:   void SetIsIMEComposing(); /* call this before |IsIMEComposing()| */
     1: 
     1:   /** from html rules code - migration in progress */
     1:   static nsresult GetTagString(nsIDOMNode *aNode, nsAString& outString);
     1:   static nsIAtom *GetTag(nsIDOMNode *aNode);
 98809: 
 98809:   bool NodesSameType(nsIDOMNode *aNode1, nsIDOMNode *aNode2);
 98809:   virtual bool AreNodesSameType(nsIContent* aNode1, nsIContent* aNode2);
 98809: 
 79445:   static bool IsTextNode(nsIDOMNode *aNode);
 82861:   static bool IsTextNode(nsINode *aNode);
     1:   
     1:   static nsCOMPtr<nsIDOMNode> GetChildAt(nsIDOMNode *aParent, PRInt32 aOffset);
 73913:   static nsCOMPtr<nsIDOMNode> GetNodeAtRangeOffsetPoint(nsIDOMNode* aParentOrNode, PRInt32 aOffset);
     1: 
 43518:   static nsresult GetStartNodeAndOffset(nsISelection *aSelection, nsIDOMNode **outStartNode, PRInt32 *outStartOffset);
 43518:   static nsresult GetEndNodeAndOffset(nsISelection *aSelection, nsIDOMNode **outEndNode, PRInt32 *outEndOffset);
     1: #if DEBUG_JOE
     1:   static void DumpNode(nsIDOMNode *aNode, PRInt32 indent=0);
     1: #endif
101616:   mozilla::Selection* GetSelection();
     1: 
     1:   // Helpers to add a node to the selection. 
     1:   // Used by table cell selection methods
     1:   nsresult CreateRange(nsIDOMNode *aStartParent, PRInt32 aStartOffset,
     1:                        nsIDOMNode *aEndParent, PRInt32 aEndOffset,
     1:                        nsIDOMRange **aRange);
     1: 
     1:   // Creates a range with just the supplied node and appends that to the selection
     1:   nsresult AppendNodeToSelectionAsRange(nsIDOMNode *aNode);
     1:   // When you are using AppendNodeToSelectionAsRange, call this first to start a new selection
     1:   nsresult ClearSelection();
     1: 
 79445:   nsresult IsPreformatted(nsIDOMNode *aNode, bool *aResult);
     1: 
     1:   nsresult SplitNodeDeep(nsIDOMNode *aNode, 
     1:                          nsIDOMNode *aSplitPointParent, 
     1:                          PRInt32 aSplitPointOffset,
     1:                          PRInt32 *outOffset,
 79445:                          bool    aNoEmptyContainers = false,
     1:                          nsCOMPtr<nsIDOMNode> *outLeftNode = 0,
     1:                          nsCOMPtr<nsIDOMNode> *outRightNode = 0);
     1:   nsresult JoinNodeDeep(nsIDOMNode *aLeftNode, nsIDOMNode *aRightNode, nsCOMPtr<nsIDOMNode> *aOutJoinNode, PRInt32 *outOffset); 
     1: 
     1:   nsresult GetString(const nsAString& name, nsAString& value);
     1: 
101070:   void BeginUpdateViewBatch(void);
     1:   virtual nsresult EndUpdateViewBatch(void);
     1: 
 79445:   bool GetShouldTxnSetSelection();
     1: 
 43438:   virtual nsresult HandleKeyPressEvent(nsIDOMKeyEvent* aKeyEvent);
 43438: 
 97808:   nsresult HandleInlineSpellCheck(OperationID action,
     1:                                     nsISelection *aSelection,
     1:                                     nsIDOMNode *previousSelectedNode,
     1:                                     PRInt32 previousSelectedOffset,
     1:                                     nsIDOMNode *aStartNode,
     1:                                     PRInt32 aStartOffset,
     1:                                     nsIDOMNode *aEndNode,
     1:                                     PRInt32 aEndOffset);
     1: 
 72327:   virtual already_AddRefed<nsIDOMEventTarget> GetDOMEventTarget() = 0;
     1: 
     1:   // Fast non-refcounting editor root element accessor
 83343:   mozilla::dom::Element *GetRoot();
     1: 
 97988:   // Likewise, but gets the editor's root instead, which is different for HTML
 97988:   // editors
 97988:   virtual mozilla::dom::Element* GetEditorRoot();
 97988: 
 40703:   // Accessor methods to flags
 79445:   bool IsPlaintextEditor() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorPlaintextMask) != 0;
 40703:   }
 40703: 
 79445:   bool IsSingleLineEditor() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorSingleLineMask) != 0;
 40703:   }
 40703: 
 79445:   bool IsPasswordEditor() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorPasswordMask) != 0;
 40703:   }
 40703: 
 79445:   bool IsReadonly() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorReadonlyMask) != 0;
 40703:   }
 40703: 
 79445:   bool IsDisabled() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorDisabledMask) != 0;
 40703:   }
 40703: 
 79445:   bool IsInputFiltered() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorFilterInputMask) != 0;
 40703:   }
 40703: 
 79445:   bool IsMailEditor() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorMailMask) != 0;
 40703:   }
 40703: 
 79445:   bool IsWrapHackEnabled() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorEnableWrapHackMask) != 0;
 40703:   }
 40703: 
 79445:   bool IsFormWidget() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorWidgetMask) != 0;
 40703:   }
 40703: 
 79445:   bool NoCSS() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorNoCSSMask) != 0;
 40703:   }
 40703: 
 79445:   bool IsInteractionAllowed() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorAllowInteraction) != 0;
 40703:   }
 40703: 
 79445:   bool DontEchoPassword() const
 40703:   {
 40703:     return (mFlags & nsIPlaintextEditor::eEditorDontEchoPassword) != 0;
 40703:   }
 40703:   
 94737:   bool ShouldSkipSpellCheck() const
 80481:   {
 80481:     return (mFlags & nsIPlaintextEditor::eEditorSkipSpellCheck) != 0;
 80481:   }
 80481: 
 79445:   bool IsTabbable() const
 43438:   {
 43438:     return IsSingleLineEditor() || IsPasswordEditor() || IsFormWidget() ||
 43438:            IsInteractionAllowed();
 43438:   }
 43438: 
 94119:   // Get the input event target. This might return null.
 94119:   virtual already_AddRefed<nsIContent> GetInputEventTargetContent() = 0;
 94119: 
 56870:   // Get the focused content, if we're focused.  Returns null otherwise.
 56870:   virtual already_AddRefed<nsIContent> GetFocusedContent();
 41886: 
 48083:   // Whether the editor is active on the DOM window.  Note that when this
 56870:   // returns true but GetFocusedContent() returns null, it means that this editor was
 48083:   // focused when the DOM window was active.
 79445:   virtual bool IsActiveInDOMWindow();
 48083: 
 48083:   // Whether the aEvent should be handled by this editor or not.  When this
 48083:   // returns FALSE, The aEvent shouldn't be handled on this editor,
 48083:   // i.e., The aEvent should be handled by another inner editor or ancestor
 48083:   // elements.
 79445:   virtual bool IsAcceptableInputEvent(nsIDOMEvent* aEvent);
 48083: 
 43715:   // FindSelectionRoot() returns a selection root of this editor when aNode
 43715:   // gets focus.  aNode must be a content node or a document node.  When the
 43715:   // target isn't a part of this editor, returns NULL.  If this is for
 43715:   // designMode, you should set the document node to aNode except that an
 43715:   // element in the document has focus.
 43715:   virtual already_AddRefed<nsIContent> FindSelectionRoot(nsINode* aNode);
 43715: 
 43715:   // Initializes selection and caret for the editor.  If aEventTarget isn't
 43715:   // a host of the editor, i.e., the editor doesn't get focus, this does
 43715:   // nothing.
 43715:   nsresult InitializeSelection(nsIDOMEventTarget* aFocusEventTarget);
 43715: 
 75374:   // This method has to be called by nsEditorEventListener::Focus.
 75374:   // All actions that have to be done when the editor is focused needs to be
 75374:   // added here.
 75374:   void OnFocus(nsIDOMEventTarget* aFocusEventTarget);
 75374: 
 90377:   // Used to insert content from a data transfer into the editable area.
 90377:   // This is called for each item in the data transfer, with the index of
 90377:   // each item passed as aIndex.
 90377:   virtual nsresult InsertFromDataTransfer(nsIDOMDataTransfer *aDataTransfer,
 90377:                                           PRInt32 aIndex,
 90377:                                           nsIDOMDocument *aSourceDoc,
 90377:                                           nsIDOMNode *aDestinationNode,
 90377:                                           PRInt32 aDestOffset,
 90377:                                           bool aDoDeleteSelection) = 0;
 90377: 
 90377:   virtual nsresult InsertFromDrop(nsIDOMEvent* aDropEvent) = 0;
 90377: 
 90377:   virtual already_AddRefed<nsIDOMNode> FindUserSelectAllNode(nsIDOMNode* aNode) { return nsnull; }
 90377: 
 94119:   NS_STACK_CLASS class HandlingTrustedAction
 94119:   {
 94119:   public:
 94119:     explicit HandlingTrustedAction(nsEditor* aSelf, bool aIsTrusted = true)
 94119:     {
 94119:       Init(aSelf, aIsTrusted);
 94119:     }
 94119: 
 94119:     HandlingTrustedAction(nsEditor* aSelf, nsIDOMNSEvent* aEvent);
 94119: 
 94119:     ~HandlingTrustedAction()
 94119:     {
 94119:       mEditor->mHandlingTrustedAction = mWasHandlingTrustedAction;
 94119:       mEditor->mHandlingActionCount--;
 94119:     }
 94119: 
 94119:   private:
 94119:     nsRefPtr<nsEditor> mEditor;
 94119:     bool mWasHandlingTrustedAction;
 94119: 
 94119:     void Init(nsEditor* aSelf, bool aIsTrusted)
 94119:     {
 94119:       MOZ_ASSERT(aSelf);
 94119: 
 94119:       mEditor = aSelf;
 94119:       mWasHandlingTrustedAction = aSelf->mHandlingTrustedAction;
 94119:       if (aIsTrusted) {
 94119:         // If action is nested and the outer event is not trusted,
 94119:         // we shouldn't override it.
 94119:         if (aSelf->mHandlingActionCount == 0) {
 94119:           aSelf->mHandlingTrustedAction = true;
 94119:         }
 94119:       } else {
 94119:         aSelf->mHandlingTrustedAction = false;
 94119:       }
 94119:       aSelf->mHandlingActionCount++;
 94119:     }
 94119:   };
 94119: 
     1: protected:
 96784:   enum Tristate {
 96784:     eTriUnset,
 96784:     eTriFalse,
 96784:     eTriTrue
 96784:   };
 96784:   // Spellchecking
 96784:   nsCString mContentMIMEType;       // MIME type of the doc we are editing.
 96784: 
 96784:   nsCOMPtr<nsIInlineSpellChecker> mInlineSpellChecker;
 96784: 
103790:   nsRefPtr<nsTransactionManager> mTxnMgr;
 96784:   nsCOMPtr<mozilla::dom::Element> mRootElement; // cached root node
 96784:   nsCOMPtr<nsIPrivateTextRangeList> mIMETextRangeList; // IME special selection ranges
 96784:   nsCOMPtr<nsIDOMCharacterData>     mIMETextNode;      // current IME text node
 96784:   nsCOMPtr<nsIDOMEventTarget> mEventTarget; // The form field as an event receiver
 96784:   nsCOMPtr<nsIDOMEventListener> mEventListener;
 96784:   nsWeakPtr        mSelConWeak;          // weak reference to the nsISelectionController
 96784:   nsWeakPtr        mPlaceHolderTxn;      // weak reference to placeholder for begin/end batch purposes
 96784:   nsWeakPtr        mDocWeak;             // weak reference to the nsIDOMDocument
 96784:   nsIAtom          *mPlaceHolderName;    // name of placeholder transaction
 96784:   nsSelectionState *mSelState;           // saved selection state for placeholder txn batching
 96784:   nsString         *mPhonetic;
 96784: 
 96784:   // various listeners
 96784:   nsCOMArray<nsIEditActionListener> mActionListeners;  // listens to all low level actions on the doc
 96784:   nsCOMArray<nsIEditorObserver> mEditorObservers;  // just notify once per high level change
 96784:   nsCOMArray<nsIDocumentStateListener> mDocStateListeners;// listen to overall doc state (dirty or not, just created, etc)
 96784: 
 96784:   nsSelectionState  mSavedSel;           // cached selection for nsAutoSelectionReset
 96784:   nsRangeUpdater    mRangeUpdater;       // utility class object for maintaining preserved ranges
 96783: 
 96783:   PRUint32          mModCount;     // number of modifications (for undo/redo stack)
 96783:   PRUint32          mFlags;        // behavior flags. See nsIPlaintextEditor.idl for the flags we use.
 96783: 
 96783:   PRInt32           mUpdateCount;
 96783: 
 96784:   PRInt32           mPlaceHolderBatch;   // nesting count for batching
 97808:   OperationID       mAction;             // the current editor action
 96784:   PRUint32          mHandlingActionCount;
 96782: 
     1:   PRUint32          mIMETextOffset;    // offset in text node where IME comp string begins
     1:   PRUint32          mIMEBufferLength;  // current length of IME comp string
 96784: 
 96784:   EDirection        mDirection;          // the current direction of editor action
 96784:   PRInt8            mDocDirtyState;      // -1 = not initialized
 96784:   PRUint8           mSpellcheckCheckboxState; // a Tristate value
 96784: 
 79445:   bool mInIMEMode;        // are we inside an IME composition?
 79445:   bool mIsIMEComposing;   // is IME in composition state?
     1:                                                        // This is different from mInIMEMode. see Bug 98434.
     1: 
 79445:   bool mShouldTxnSetSelection;  // turn off for conservative selection adjustment by txns
 79445:   bool mDidPreDestroy;    // whether PreDestroy has been called
 79445:   bool mDidPostCreate;    // whether PostCreate has been called
 94119:   bool mHandlingTrustedAction;
 94119:   bool mDispatchInputEvent;
 59460: 
 79445:   friend bool NSCanUnload(nsISupports* serviceMgr);
     1:   friend class nsAutoTxnsConserveSelection;
     1:   friend class nsAutoSelectionReset;
     1:   friend class nsAutoRules;
     1:   friend class nsRangeUpdater;
     1: };
     1: 
     1: 
     1: #endif
