    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
32424:  *   Bobby Holley <bobbyholley@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "imgRequest.h"
    1: 
48312: /* We end up pulling in windows.h because we eventually hit gfxWindowsSurface;
48312:  * windows.h defines LoadImage, so we have to #undef it or imgLoader::LoadImage
48312:  * gets changed.
48312:  * This #undef needs to be in multiple places because we don't always pull
48312:  * headers in in the same order.
48312:  */
48312: #undef LoadImage
48312: 
    1: #include "imgLoader.h"
    1: #include "imgRequestProxy.h"
50551: #include "RasterImage.h"
52216: #include "VectorImage.h"
    1: 
    1: #include "imgILoader.h"
    1: #include "ImageLogging.h"
    1: 
    1: #include "netCore.h"
    1: 
    1: #include "nsIChannel.h"
    1: #include "nsICachingChannel.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsIInputStream.h"
    1: #include "nsIMultiPartChannel.h"
    1: #include "nsIHttpChannel.h"
    1: 
    1: #include "nsIComponentManager.h"
23007: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIProxyObjectManager.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsISupportsPrimitives.h"
 7703: #include "nsIScriptSecurityManager.h"
    1: 
18827: #include "nsICacheVisitor.h"
18827: 
    1: #include "nsString.h"
    1: #include "nsXPIDLString.h"
    1: #include "plstr.h" // PL_strcasestr(...)
38082: #include "nsNetUtil.h"
38082: #include "nsIProtocolHandler.h"
    1: 
71637: #include "mozilla/Preferences.h"
46172: 
50548: #include "DiscardTracker.h"
48889: #include "nsAsyncRedirectVerifyHelper.h"
47317: 
46172: #define DISCARD_PREF "image.mem.discardable"
46172: #define DECODEONDRAW_PREF "image.mem.decodeondraw"
51590: #define BYTESATATIME_PREF "image.mem.decode_bytes_at_a_time"
51590: #define MAXMS_PREF "image.mem.max_ms_before_yield"
51595: #define MAXBYTESFORSYNC_PREF "image.mem.max_bytes_for_sync_decode"
50553: #define SVG_MIMETYPE "image/svg+xml"
46172: 
71637: using namespace mozilla;
50546: using namespace mozilla::imagelib;
50546: 
46172: /* Kept up to date by a pref observer. */
32449: static PRBool gDecodeOnDraw = PR_FALSE;
32449: static PRBool gDiscardable = PR_FALSE;
32424: 
71637: static const char* kObservedPrefs[] = {
71637:   DISCARD_PREF,
71637:   DECODEONDRAW_PREF,
71637:   DISCARD_TIMEOUT_PREF,
71637:   nsnull
71637: };
71637: 
46172: /*
46172:  * Pref observer goop. Yuck.
46172:  */
46172: 
46172: // Flag
46172: static PRBool gRegisteredPrefObserver = PR_FALSE;
46172: 
46172: // Reloader
46172: static void
71637: ReloadPrefs()
46172: {
46172:   // Discardable
71637:   gDiscardable = Preferences::GetBool(DISCARD_PREF, gDiscardable);
46172: 
46172:   // Decode-on-draw
71637:   gDecodeOnDraw = Preferences::GetBool(DECODEONDRAW_PREF, gDecodeOnDraw);
47317: 
51590:   // Progressive decoding knobs
51595:   PRInt32 bytesAtATime, maxMS, maxBytesForSync;
71637:   if (NS_SUCCEEDED(Preferences::GetInt(BYTESATATIME_PREF, &bytesAtATime))) {
51590:     RasterImage::SetDecodeBytesAtATime(bytesAtATime);
71637:   }
71637: 
71637:   if (NS_SUCCEEDED(Preferences::GetInt(MAXMS_PREF, &maxMS))) {
51590:     RasterImage::SetMaxMSBeforeYield(maxMS);
71637:   }
71637: 
71637:   if (NS_SUCCEEDED(Preferences::GetInt(MAXBYTESFORSYNC_PREF,
71637:                                        &maxBytesForSync))) {
51595:     RasterImage::SetMaxBytesForSyncDecode(maxBytesForSync);
71637:   }
51590: 
47317:   // Discard timeout
50547:   mozilla::imagelib::DiscardTracker::ReloadTimeout();
46172: }
46172: 
46172: // Observer
46172: class imgRequestPrefObserver : public nsIObserver {
46172: public:
46172:     NS_DECL_ISUPPORTS
46172:     NS_DECL_NSIOBSERVER
46172: };
46172: NS_IMPL_ISUPPORTS1(imgRequestPrefObserver, nsIObserver)
46172: 
46172: // Callback
46172: NS_IMETHODIMP
46172: imgRequestPrefObserver::Observe(nsISupports     *aSubject,
46172:                                 const char      *aTopic,
46172:                                 const PRUnichar *aData)
46172: {
46172:   // Right topic
46172:   NS_ABORT_IF_FALSE(!strcmp(aTopic, NS_PREFBRANCH_PREFCHANGE_TOPIC_ID), "invalid topic");
46172: 
46172:   // Right pref
46172:   if (strcmp(NS_LossyConvertUTF16toASCII(aData).get(), DISCARD_PREF) &&
47317:       strcmp(NS_LossyConvertUTF16toASCII(aData).get(), DECODEONDRAW_PREF) &&
47317:       strcmp(NS_LossyConvertUTF16toASCII(aData).get(), DISCARD_TIMEOUT_PREF))
46172:     return NS_OK;
46172: 
46172:   // Process the change
71637:   ReloadPrefs();
46172: 
46172:   return NS_OK;
46172: }
46172: 
    1: #if defined(PR_LOGGING)
    1: PRLogModuleInfo *gImgLog = PR_NewLogModule("imgRequest");
    1: #endif
    1: 
48889: NS_IMPL_ISUPPORTS8(imgRequest,
    1:                    imgIDecoderObserver, imgIContainerObserver,
    1:                    nsIStreamListener, nsIRequestObserver,
23007:                    nsISupportsWeakReference,
23007:                    nsIChannelEventSink,
48889:                    nsIInterfaceRequestor,
48889:                    nsIAsyncVerifyRedirectCallback)
    1: 
    1: imgRequest::imgRequest() : 
48320:   mCacheId(0), mValidator(nsnull), mImageSniffers("image-sniffing-services"),
60276:   mWindowId(0), mDecodeRequested(PR_FALSE), mIsMultiPartChannel(PR_FALSE),
60276:   mGotData(PR_FALSE), mIsInCache(PR_FALSE)
48320: {}
    1: 
    1: imgRequest::~imgRequest()
    1: {
72903:   if (mKeyURI) {
25078:     nsCAutoString spec;
72903:     mKeyURI->GetSpec(spec);
25078:     LOG_FUNC_WITH_PARAM(gImgLog, "imgRequest::~imgRequest()", "keyuri", spec.get());
25078:   } else
25078:     LOG_FUNC(gImgLog, "imgRequest::~imgRequest()");
    1: }
    1: 
    1: nsresult imgRequest::Init(nsIURI *aURI,
72903:                           nsIURI *aKeyURI,
    1:                           nsIRequest *aRequest,
23007:                           nsIChannel *aChannel,
18827:                           imgCacheEntry *aCacheEntry,
    1:                           void *aCacheId,
    1:                           void *aLoadId)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequest::Init");
    1: 
25078:   NS_ABORT_IF_FALSE(!mImage, "Multiple calls to init");
25078:   NS_ABORT_IF_FALSE(aURI, "No uri");
72903:   NS_ABORT_IF_FALSE(aKeyURI, "No key uri");
25078:   NS_ABORT_IF_FALSE(aRequest, "No request");
25078:   NS_ABORT_IF_FALSE(aChannel, "No channel");
    1: 
    1:   mProperties = do_CreateInstance("@mozilla.org/properties;1");
50553: 
51296:   mStatusTracker = new imgStatusTracker(nsnull);
51296: 
    1:   mURI = aURI;
72903:   mKeyURI = aKeyURI;
    1:   mRequest = aRequest;
23007:   mChannel = aChannel;
71556:   mTimedChannel = do_QueryInterface(mChannel);
71556: 
23007:   mChannel->GetNotificationCallbacks(getter_AddRefs(mPrevChannelSink));
23007: 
23007:   NS_ASSERTION(mPrevChannelSink != this,
23007:                "Initializing with a channel that already calls back to us!");
23007: 
23007:   mChannel->SetNotificationCallbacks(this);
    1: 
    1:   mCacheEntry = aCacheEntry;
    1: 
    1:   mCacheId = aCacheId;
    1: 
    1:   SetLoadId(aLoadId);
    1: 
46172:   // Register our pref observer if it hasn't been done yet.
46172:   if (NS_UNLIKELY(!gRegisteredPrefObserver)) {
60670:     nsCOMPtr<nsIObserver> observer(new imgRequestPrefObserver());
71637:     Preferences::AddStrongObservers(observer, kObservedPrefs);
71637:     ReloadPrefs();
46172:     gRegisteredPrefObserver = PR_TRUE;
46172:   }
46172: 
    1:   return NS_OK;
    1: }
    1: 
51297: imgStatusTracker&
51297: imgRequest::GetStatusTracker()
51297: {
51297:   if (mImage) {
51297:     NS_ABORT_IF_FALSE(!mStatusTracker,
51297:                       "Should have given mStatusTracker to mImage");
51297:     return mImage->GetStatusTracker();
51297:   } else {
51297:     NS_ABORT_IF_FALSE(mStatusTracker,
51297:                       "Should have mStatusTracker until we create mImage");
51297:     return *mStatusTracker;
51297:   }
51297: }
51297: 
25078: void imgRequest::SetCacheEntry(imgCacheEntry *entry)
25078: {
25078:   mCacheEntry = entry;
25078: }
25078: 
25078: PRBool imgRequest::HasCacheEntry() const
25078: {
25078:   return mCacheEntry != nsnull;
25078: }
25078: 
 6229: nsresult imgRequest::AddProxy(imgRequestProxy *proxy)
    1: {
 6229:   NS_PRECONDITION(proxy, "null imgRequestProxy passed in");
    1:   LOG_SCOPE_WITH_PARAM(gImgLog, "imgRequest::AddProxy", "proxy", proxy);
    1: 
25078:   // If we're empty before adding, we have to tell the loader we now have
25078:   // proxies.
25078:   if (mObservers.IsEmpty()) {
72903:     NS_ABORT_IF_FALSE(mKeyURI, "Trying to SetHasProxies without key uri.");
72903:     imgLoader::SetHasProxies(mKeyURI);
25078:   }
25078: 
48318:   // If we don't have any current observers, we should restart any animation.
51297:   if (mImage && !HaveProxyWithObserver(proxy) && proxy->HasObserver()) {
48318:     LOG_MSG(gImgLog, "imgRequest::AddProxy", "resetting animation");
48318: 
48318:     mImage->ResetAnimation();
48318:   }
48318: 
48319:   proxy->SetPrincipal(mPrincipal);
48319: 
 9536:   return mObservers.AppendElementUnlessExists(proxy) ?
 9031:     NS_OK : NS_ERROR_OUT_OF_MEMORY;
    1: }
    1: 
    1: nsresult imgRequest::RemoveProxy(imgRequestProxy *proxy, nsresult aStatus, PRBool aNotify)
    1: {
    1:   LOG_SCOPE_WITH_PARAM(gImgLog, "imgRequest::RemoveProxy", "proxy", proxy);
    1: 
52149:   // This will remove our animation consumers, so after removing
52149:   // this proxy, we don't end up without proxies with observers, but still
52149:   // have animation consumers.
52149:   proxy->ClearAnimationConsumers();
52149: 
 9536:   mObservers.RemoveElement(proxy);
    1: 
48320:   // Let the status tracker do its thing before we potentially call Cancel()
48320:   // below, because Cancel() may result in OnStopRequest being called back
48320:   // before Cancel() returns, leaving the image in a different state then the
48320:   // one it was in at this point.
    1: 
51297:   imgStatusTracker& statusTracker = GetStatusTracker();
51297:   statusTracker.EmulateRequestFinished(proxy, aStatus, !aNotify);
35718: 
 6229:   if (mObservers.IsEmpty()) {
25078:     // If we have no observers, there's nothing holding us alive. If we haven't
25078:     // been cancelled and thus removed from the cache, tell the image loader so
25078:     // we can be evicted from the cache.
25078:     if (mCacheEntry) {
72903:       NS_ABORT_IF_FALSE(mKeyURI, "Removing last observer without key uri.");
25078: 
72903:       imgLoader::SetHasNoProxies(mKeyURI, mCacheEntry);
25078:     } 
25078: #if defined(PR_LOGGING)
25078:     else {
25078:       nsCAutoString spec;
72903:       mKeyURI->GetSpec(spec);
25078:       LOG_MSG_WITH_PARAM(gImgLog, "imgRequest::RemoveProxy no cache entry", "uri", spec.get());
25078:     }
25078: #endif
25078: 
    1:     /* If |aStatus| is a failure code, then cancel the load if it is still in progress.
    1:        Otherwise, let the load continue, keeping 'this' in the cache with no observers.
    1:        This way, if a proxy is destroyed without calling cancel on it, it won't leak
    1:        and won't leave a bad pointer in mObservers.
    1:      */
51297:     if (statusTracker.IsLoading() && NS_FAILED(aStatus)) {
    1:       LOG_MSG(gImgLog, "imgRequest::RemoveProxy", "load in progress.  canceling");
    1: 
    1:       this->Cancel(NS_BINDING_ABORTED);
    1:     }
    1: 
    1:     /* break the cycle from the cache entry. */
    1:     mCacheEntry = nsnull;
    1:   }
    1: 
    1:   // If a proxy is removed for a reason other than its owner being
    1:   // changed, remove the proxy from the loadgroup.
    1:   if (aStatus != NS_IMAGELIB_CHANGING_OWNER)
    1:     proxy->RemoveFromLoadGroup(PR_TRUE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
50546: PRBool imgRequest::IsReusable(void *aCacheId)
50546: {
50546:   return (mImage && mImage->GetStatusTracker().IsLoading()) ||
50546:     (aCacheId == mCacheId);
50546: }
50546: 
23007: void imgRequest::CancelAndAbort(nsresult aStatus)
23007: {
25078:   LOG_SCOPE(gImgLog, "imgRequest::CancelAndAbort");
25078: 
23007:   Cancel(aStatus);
23007: 
23007:   // It's possible for the channel to fail to open after we've set our
23007:   // notification callbacks. In that case, make sure to break the cycle between
23007:   // the channel and us, because it won't.
23007:   if (mChannel) {
23007:     mChannel->SetNotificationCallbacks(mPrevChannelSink);
23007:     mPrevChannelSink = nsnull;
23007:   }
    1: }
    1: 
48320: void imgRequest::Cancel(nsresult aStatus)
48320: {
48320:   /* The Cancel() method here should only be called by this class. */
48320: 
48320:   LOG_SCOPE(gImgLog, "imgRequest::Cancel");
48320: 
51297:   imgStatusTracker& statusTracker = GetStatusTracker();
51297:   statusTracker.RecordCancel();
48320: 
48320:   RemoveFromCache();
48320: 
51297:   if (mRequest && statusTracker.IsLoading())
48320:     mRequest->Cancel(aStatus);
48320: }
48320: 
    1: nsresult imgRequest::GetURI(nsIURI **aURI)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequest::GetURI");
    1: 
    1:   if (mURI) {
    1:     *aURI = mURI;
    1:     NS_ADDREF(*aURI);
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
23036: nsresult imgRequest::GetKeyURI(nsIURI **aKeyURI)
23036: {
23036:   LOG_FUNC(gImgLog, "imgRequest::GetKeyURI");
23036: 
72903:   if (mKeyURI) {
72903:     *aKeyURI = mKeyURI;
23036:     NS_ADDREF(*aKeyURI);
23036:     return NS_OK;
23036:   }
23036: 
23036:   return NS_ERROR_FAILURE;
23036: }
23036: 
18557: nsresult imgRequest::GetSecurityInfo(nsISupports **aSecurityInfo)
18557: {
18557:   LOG_FUNC(gImgLog, "imgRequest::GetSecurityInfo");
18557: 
18557:   // Missing security info means this is not a security load
18557:   // i.e. it is not an error when security info is missing
18557:   NS_IF_ADDREF(*aSecurityInfo = mSecurityInfo);
18557:   return NS_OK;
18557: }
18557: 
    1: void imgRequest::RemoveFromCache()
    1: {
    1:   LOG_SCOPE(gImgLog, "imgRequest::RemoveFromCache");
    1: 
26259:   if (mIsInCache) {
26259:     // mCacheEntry is nulled out when we have no more observers.
25078:     if (mCacheEntry)
25078:       imgLoader::RemoveFromCache(mCacheEntry);
25078:     else
72903:       imgLoader::RemoveFromCache(mKeyURI);
26259:   }
25078: 
26075:   mCacheEntry = nsnull;
26069: }
    1: 
    1: PRBool imgRequest::HaveProxyWithObserver(imgRequestProxy* aProxyToIgnore) const
    1: {
 9536:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
 6229:   imgRequestProxy* proxy;
 9536:   while (iter.HasMore()) {
 9536:     proxy = iter.GetNext();
    1:     if (proxy == aProxyToIgnore) {
    1:       continue;
    1:     }
    1:     
    1:     if (proxy->HasObserver()) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1:   
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRInt32 imgRequest::Priority() const
    1: {
    1:   PRInt32 priority = nsISupportsPriority::PRIORITY_NORMAL;
    1:   nsCOMPtr<nsISupportsPriority> p = do_QueryInterface(mRequest);
    1:   if (p)
    1:     p->GetPriority(&priority);
    1:   return priority;
    1: }
    1: 
    1: void imgRequest::AdjustPriority(imgRequestProxy *proxy, PRInt32 delta)
    1: {
    1:   // only the first proxy is allowed to modify the priority of this image load.
    1:   //
    1:   // XXX(darin): this is probably not the most optimal algorithm as we may want
    1:   // to increase the priority of requests that have a lot of proxies.  the key
    1:   // concern though is that image loads remain lower priority than other pieces
    1:   // of content such as link clicks, CSS, and JS.
    1:   //
 9536:   if (mObservers.SafeElementAt(0, nsnull) != proxy)
    1:     return;
    1: 
    1:   nsCOMPtr<nsISupportsPriority> p = do_QueryInterface(mRequest);
    1:   if (p)
    1:     p->AdjustPriority(delta);
    1: }
    1: 
26259: void imgRequest::SetIsInCache(PRBool incache)
25748: {
26259:   LOG_FUNC_WITH_PARAM(gImgLog, "imgRequest::SetIsCacheable", "incache", incache);
26259:   mIsInCache = incache;
25748: }
25748: 
32424: void imgRequest::UpdateCacheEntrySize()
32424: {
32424:   if (mCacheEntry) {
51231:     mCacheEntry->SetDataSize(mImage->GetDataSize());
    1: 
32424: #ifdef DEBUG_joe
32424:     nsCAutoString url;
32424:     mURI->GetSpec(url);
32424:     printf("CACHEPUT: %d %s %d\n", time(NULL), url.get(), imageSize);
32424: #endif
    1:   }
32424: }
32424: 
32424: nsresult
32516: imgRequest::LockImage()
32516: {
32516:   return mImage->LockImage();
32516: }
32516: 
32516: nsresult
32516: imgRequest::UnlockImage()
32516: {
32516:   return mImage->UnlockImage();
32516: }
32516: 
32516: nsresult
32516: imgRequest::RequestDecode()
32516: {
48320:   // If we've initialized our image, we can request a decode.
51297:   if (mImage) {
32516:     return mImage->RequestDecode();
32516:   }
32516: 
32516:   // Otherwise, flag to do it when we get the image
32516:   mDecodeRequested = PR_TRUE;
32516: 
32516:   return NS_OK;
32516: }
32516: 
    1: /** imgIContainerObserver methods **/
    1: 
30479: /* [noscript] void frameChanged (in imgIContainer container, in nsIntRect dirtyRect); */
    1: NS_IMETHODIMP imgRequest::FrameChanged(imgIContainer *container,
50544:                                        const nsIntRect *dirtyRect)
    1: {
    1:   LOG_SCOPE(gImgLog, "imgRequest::FrameChanged");
51297:   NS_ABORT_IF_FALSE(mImage,
51297:                     "FrameChanged callback before we've created our image");
    1: 
48320:   mImage->GetStatusTracker().RecordFrameChanged(container, dirtyRect);
48320: 
 9536:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
 9536:   while (iter.HasMore()) {
48320:     mImage->GetStatusTracker().SendFrameChanged(iter.GetNext(), container, dirtyRect);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /** imgIDecoderObserver methods **/
    1: 
    1: /* void onStartDecode (in imgIRequest request); */
    1: NS_IMETHODIMP imgRequest::OnStartDecode(imgIRequest *request)
    1: {
    1:   LOG_SCOPE(gImgLog, "imgRequest::OnStartDecode");
51297:   NS_ABORT_IF_FALSE(mImage,
51297:                     "OnStartDecode callback before we've created our image");
51297: 
    1: 
48320:   mImage->GetStatusTracker().RecordStartDecode();
    1: 
 9536:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
 9536:   while (iter.HasMore()) {
48320:     mImage->GetStatusTracker().SendStartDecode(iter.GetNext());
    1:   }
    1: 
    1:   /* In the case of streaming jpegs, it is possible to get multiple OnStartDecodes which
    1:      indicates the beginning of a new decode.
    1:      The cache entry's size therefore needs to be reset to 0 here.  If we do not do this,
    1:      the code in imgRequest::OnStopFrame will continue to increase the data size cumulatively.
    1:    */
    1:   if (mCacheEntry)
    1:     mCacheEntry->SetDataSize(0);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP imgRequest::OnStartRequest(imgIRequest *aRequest)
    1: {
    1:   NS_NOTREACHED("imgRequest(imgIDecoderObserver)::OnStartRequest");
    1:   return NS_OK;
    1: }
    1: 
    1: /* void onStartContainer (in imgIRequest request, in imgIContainer image); */
    1: NS_IMETHODIMP imgRequest::OnStartContainer(imgIRequest *request, imgIContainer *image)
    1: {
    1:   LOG_SCOPE(gImgLog, "imgRequest::OnStartContainer");
    1: 
    1:   NS_ASSERTION(image, "imgRequest::OnStartContainer called with a null image!");
    1:   if (!image) return NS_ERROR_UNEXPECTED;
    1: 
51297:   NS_ABORT_IF_FALSE(mImage,
51297:                     "OnStartContainer callback before we've created our image");
51297:   NS_ABORT_IF_FALSE(image == mImage,
51297:                     "OnStartContainer callback from an image we don't own");
49700:   mImage->GetStatusTracker().RecordStartContainer(image);
49700: 
 9536:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
 9536:   while (iter.HasMore()) {
48320:     mImage->GetStatusTracker().SendStartContainer(iter.GetNext(), image);
    1:   }
48320: 
    1:   return NS_OK;
    1: }
    1: 
30479: /* void onStartFrame (in imgIRequest request, in unsigned long frame); */
    1: NS_IMETHODIMP imgRequest::OnStartFrame(imgIRequest *request,
30479:                                        PRUint32 frame)
    1: {
    1:   LOG_SCOPE(gImgLog, "imgRequest::OnStartFrame");
51297:   NS_ABORT_IF_FALSE(mImage,
51297:                     "OnStartFrame callback before we've created our image");
    1: 
48320:   mImage->GetStatusTracker().RecordStartFrame(frame);
48320: 
 9536:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
 9536:   while (iter.HasMore()) {
48320:     mImage->GetStatusTracker().SendStartFrame(iter.GetNext(), frame);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
30479: /* [noscript] void onDataAvailable (in imgIRequest request, in boolean aCurrentFrame, [const] in nsIntRect rect); */
    1: NS_IMETHODIMP imgRequest::OnDataAvailable(imgIRequest *request,
30479:                                           PRBool aCurrentFrame,
    1:                                           const nsIntRect * rect)
    1: {
    1:   LOG_SCOPE(gImgLog, "imgRequest::OnDataAvailable");
51297:   NS_ABORT_IF_FALSE(mImage,
51297:                     "OnDataAvailable callback before we've created our image");
    1: 
48320:   mImage->GetStatusTracker().RecordDataAvailable(aCurrentFrame, rect);
48320: 
 9536:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
 9536:   while (iter.HasMore()) {
48320:     mImage->GetStatusTracker().SendDataAvailable(iter.GetNext(), aCurrentFrame, rect);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
30479: /* void onStopFrame (in imgIRequest request, in unsigned long frame); */
    1: NS_IMETHODIMP imgRequest::OnStopFrame(imgIRequest *request,
30479:                                       PRUint32 frame)
    1: {
    1:   LOG_SCOPE(gImgLog, "imgRequest::OnStopFrame");
51297:   NS_ABORT_IF_FALSE(mImage,
51297:                     "OnStopFrame callback before we've created our image");
    1: 
48320:   mImage->GetStatusTracker().RecordStopFrame(frame);
    1: 
 9536:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
 9536:   while (iter.HasMore()) {
48320:     mImage->GetStatusTracker().SendStopFrame(iter.GetNext(), frame);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* void onStopContainer (in imgIRequest request, in imgIContainer image); */
    1: NS_IMETHODIMP imgRequest::OnStopContainer(imgIRequest *request,
    1:                                           imgIContainer *image)
    1: {
    1:   LOG_SCOPE(gImgLog, "imgRequest::OnStopContainer");
51297:   NS_ABORT_IF_FALSE(mImage,
51297:                     "OnDataContainer callback before we've created our image");
    1: 
48320:   mImage->GetStatusTracker().RecordStopContainer(image);
35718: 
 9536:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
 9536:   while (iter.HasMore()) {
48320:     mImage->GetStatusTracker().SendStopContainer(iter.GetNext(), image);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* void onStopDecode (in imgIRequest request, in nsresult status, in wstring statusArg); */
    1: NS_IMETHODIMP imgRequest::OnStopDecode(imgIRequest *aRequest,
    1:                                        nsresult aStatus,
    1:                                        const PRUnichar *aStatusArg)
    1: {
    1:   LOG_SCOPE(gImgLog, "imgRequest::OnStopDecode");
51297:   NS_ABORT_IF_FALSE(mImage,
51297:                     "OnDataDecode callback before we've created our image");
    1: 
32424:   // We finished the decode, and thus have the decoded frames. Update the cache
32424:   // entry size to take this into account.
32424:   UpdateCacheEntrySize();
    1: 
48320:   mImage->GetStatusTracker().RecordStopDecode(aStatus, aStatusArg);
48320: 
48320:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
48320:   while (iter.HasMore()) {
48320:     mImage->GetStatusTracker().SendStopDecode(iter.GetNext(), aStatus,
48320:                                               aStatusArg);
48320:   }
33531: 
50556:   // RasterImage and everything below it is completely correct and
32424:   // bulletproof about its handling of decoder notifications.
32424:   // Unfortunately, here and above we have to make some gross and
32424:   // inappropriate use of things to get things to work without
32424:   // completely overhauling the decoder observer interface (this will,
32424:   // thankfully, happen in bug 505385). From imgRequest and above (for
32424:   // the time being), OnStopDecode is just a companion to OnStopRequest
32424:   // that signals success or failure of the _load_ (not the _decode_).
48320:   // Within imgStatusTracker, we ignore OnStopDecode notifications from the
50556:   // decoder and RasterImage and generate our own every time we send
48320:   // OnStopRequest. From within SendStopDecode, we actually send
48320:   // OnStopContainer.  For more information, see bug 435296.
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP imgRequest::OnStopRequest(imgIRequest *aRequest,
    1:                                         PRBool aLastPart)
    1: {
    1:   NS_NOTREACHED("imgRequest(imgIDecoderObserver)::OnStopRequest");
    1:   return NS_OK;
    1: }
    1: 
32424: /* void onDiscard (in imgIRequest request); */
32424: NS_IMETHODIMP imgRequest::OnDiscard(imgIRequest *aRequest)
32424: {
51297:   NS_ABORT_IF_FALSE(mImage,
51297:                     "OnDiscard callback before we've created our image");
51297: 
48320:   mImage->GetStatusTracker().RecordDiscard();
32424: 
32424:   // Update the cache entry size, since we just got rid of frame data
32424:   UpdateCacheEntrySize();
32424: 
32424:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
32424:   while (iter.HasMore()) {
48320:     mImage->GetStatusTracker().SendDiscard(iter.GetNext());
32424:   }
32424: 
32424:   return NS_OK;
32424: }
32424: 
    1: /** nsIRequestObserver methods **/
    1: 
    1: /* void onStartRequest (in nsIRequest request, in nsISupports ctxt); */
    1: NS_IMETHODIMP imgRequest::OnStartRequest(nsIRequest *aRequest, nsISupports *ctxt)
    1: {
72903:   nsresult rv;
72903: 
    1:   LOG_SCOPE(gImgLog, "imgRequest::OnStartRequest");
    1: 
32424:   // Figure out if we're multipart
    1:   nsCOMPtr<nsIMultiPartChannel> mpchan(do_QueryInterface(aRequest));
    1:   if (mpchan)
    1:       mIsMultiPartChannel = PR_TRUE;
    1: 
32424:   // If we're not multipart, we shouldn't have an image yet
51297:   NS_ABORT_IF_FALSE(mIsMultiPartChannel || !mImage,
32424:                     "Already have an image for non-multipart request");
32424: 
48320:   // If we're multipart, and our image is initialized, fix things up for another round
52203:   if (mIsMultiPartChannel && mImage) {
52203:     if (mImage->GetType() == imgIContainer::TYPE_RASTER) {
50556:       // Inform the RasterImage that we have new source data
50553:       static_cast<RasterImage*>(mImage.get())->NewSourceData();
52203:     } else {  // imageType == imgIContainer::TYPE_VECTOR
52203:       nsCOMPtr<nsIStreamListener> imageAsStream = do_QueryInterface(mImage);
52203:       NS_ABORT_IF_FALSE(imageAsStream,
52203:                         "SVG-typed Image failed QI to nsIStreamListener");
52203:       imageAsStream->OnStartRequest(aRequest, ctxt);
52203:     }
32424:   }
32424: 
20073:   /*
20073:    * If mRequest is null here, then we need to set it so that we'll be able to
20073:    * cancel it if our Cancel() method is called.  Note that this can only
20073:    * happen for multipart channels.  We could simply not null out mRequest for
20073:    * non-last parts, if GetIsLastPart() were reliable, but it's not.  See
20073:    * https://bugzilla.mozilla.org/show_bug.cgi?id=339610
20073:    */
20073:   if (!mRequest) {
20073:     NS_ASSERTION(mpchan,
20073:                  "We should have an mRequest here unless we're multipart");
20073:     nsCOMPtr<nsIChannel> chan;
20073:     mpchan->GetBaseChannel(getter_AddRefs(chan));
20073:     mRequest = chan;
20073:   }
20073: 
51297:   imgStatusTracker& statusTracker = GetStatusTracker();
51297:   statusTracker.RecordStartRequest();
    1: 
18557:   nsCOMPtr<nsIChannel> channel(do_QueryInterface(aRequest));
18557:   if (channel)
18557:     channel->GetSecurityInfo(getter_AddRefs(mSecurityInfo));
18557: 
 9536:   nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
 9536:   while (iter.HasMore()) {
51297:     statusTracker.SendStartRequest(iter.GetNext());
    1:   }
    1: 
 7703:   /* Get our principal */
    1:   nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
 7703:   if (chan) {
 7703:     nsCOMPtr<nsIScriptSecurityManager> secMan =
 7703:       do_GetService("@mozilla.org/scriptsecuritymanager;1");
 7703:     if (secMan) {
 7703:       nsresult rv = secMan->GetChannelPrincipal(chan,
 7703:                                                 getter_AddRefs(mPrincipal));
 7703:       if (NS_FAILED(rv)) {
 7703:         return rv;
 7703:       }
48319: 
48319:       // Tell all of our proxies that we have a principal.
48319:       nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
48319:       while (iter.HasMore()) {
48319:         iter.GetNext()->SetPrincipal(mPrincipal);
48319:       }
 7703:     }
 7703:   }
    1: 
72903:   /* get the expires info */
72903:   if (mCacheEntry) {
72903:     nsCOMPtr<nsICachingChannel> cacheChannel(do_QueryInterface(aRequest));
72903:     if (cacheChannel) {
72903:       nsCOMPtr<nsISupports> cacheToken;
72903:       cacheChannel->GetCacheToken(getter_AddRefs(cacheToken));
72903:       if (cacheToken) {
72903:         nsCOMPtr<nsICacheEntryInfo> entryDesc(do_QueryInterface(cacheToken));
72903:         if (entryDesc) {
72903:           PRUint32 expiration;
72903:           /* get the expiration time from the caching channel's token */
72903:           entryDesc->GetExpirationTime(&expiration);
72903: 
72903:           /* set the expiration time on our entry */
72903:           mCacheEntry->SetExpiryTime(expiration);
72903:         }
72903:       }
72903:     }
72903:     //
72903:     // Determine whether the cache entry must be revalidated when it expires.
72903:     // If so, then the cache entry must *not* be used during HISTORY loads if
72903:     // it has expired.
72903:     //
72903:     // Currently, only HTTP specifies this information...
72903:     //
72903:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aRequest));
72903:     if (httpChannel) {
72903:       PRBool bMustRevalidate = PR_FALSE;
72903: 
72903:       rv = httpChannel->IsNoStoreResponse(&bMustRevalidate);
72903: 
72903:       if (!bMustRevalidate) {
72903:         rv = httpChannel->IsNoCacheResponse(&bMustRevalidate);
72903:       }
72903: 
72903:       if (!bMustRevalidate) {
72903:         nsCAutoString cacheHeader;
72903: 
72903:         rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("Cache-Control"),
72903:                                             cacheHeader);
72903:         if (PL_strcasestr(cacheHeader.get(), "must-revalidate")) {
72903:           bMustRevalidate = PR_TRUE;
72903:         }
72903:       }
72903: 
72903:       mCacheEntry->SetMustValidateIfExpired(bMustRevalidate);
72903:     }
72903:   }
72903: 
    1: 
    1:   // Shouldn't we be dead already if this gets hit?  Probably multipart/x-mixed-replace...
 6229:   if (mObservers.IsEmpty()) {
    1:     this->Cancel(NS_IMAGELIB_ERROR_FAILURE);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* void onStopRequest (in nsIRequest request, in nsISupports ctxt, in nsresult status); */
    1: NS_IMETHODIMP imgRequest::OnStopRequest(nsIRequest *aRequest, nsISupports *ctxt, nsresult status)
    1: {
    1:   LOG_FUNC(gImgLog, "imgRequest::OnStopRequest");
    1: 
48319:   PRBool lastPart = PR_TRUE;
    1:   nsCOMPtr<nsIMultiPartChannel> mpchan(do_QueryInterface(aRequest));
48319:   if (mpchan)
48319:     mpchan->GetIsLastPart(&lastPart);
    1: 
    1:   // XXXldb What if this is a non-last part of a multipart request?
23007:   // xxx before we release our reference to mRequest, lets
    1:   // save the last status that we saw so that the
    1:   // imgRequestProxy will have access to it.
23007:   if (mRequest) {
    1:     mRequest = nsnull;  // we no longer need the request
    1:   }
    1: 
23007:   // stop holding a ref to the channel, since we don't need it anymore
23007:   if (mChannel) {
23007:     mChannel->SetNotificationCallbacks(mPrevChannelSink);
23007:     mPrevChannelSink = nsnull;
23007:     mChannel = nsnull;
23007:   }
23007: 
32424:   // Tell the image that it has all of the source data. Note that this can
32424:   // trigger a failure, since the image might be waiting for more non-optional
32424:   // data and this is the point where we break the news that it's not coming.
52203:   if (mImage) {
52203:     nsresult rv;
52203:     if (mImage->GetType() == imgIContainer::TYPE_RASTER) {
52203:       // Notify the image
52203:       rv = static_cast<RasterImage*>(mImage.get())->SourceDataComplete();
52203:     } else { // imageType == imgIContainer::TYPE_VECTOR
52203:       nsCOMPtr<nsIStreamListener> imageAsStream = do_QueryInterface(mImage);
52203:       NS_ABORT_IF_FALSE(imageAsStream,
52203:                         "SVG-typed Image failed QI to nsIStreamListener");
52203:       rv = imageAsStream->OnStopRequest(aRequest, ctxt, status);
52203:     }
32424: 
52203:     // If we got an error in the SourceDataComplete() / OnStopRequest() call,
52203:     // we don't want to proceed as if nothing bad happened. However, we also
52203:     // want to give precedence to failure status codes from necko, since
52203:     // presumably they're more meaningful.
32424:     if (NS_FAILED(rv) && NS_SUCCEEDED(status))
32424:       status = rv;
    1:   }
    1: 
51297:   imgStatusTracker& statusTracker = GetStatusTracker();
51297:   statusTracker.RecordStopRequest(lastPart, status);
32424: 
48320:   // If the request went through, update the cache entry size. Otherwise,
48320:   // cancel the request, which removes us from the cache.
51297:   if (mImage && NS_SUCCEEDED(status)) {
32424:     // We update the cache entry size here because this is where we finish
32424:     // loading compressed source data, which is part of our size calculus.
32424:     UpdateCacheEntrySize();
32424:   }
48320:   else {
48320:     // stops animations, removes from cache
48320:     this->Cancel(status);
48320:   }
32424: 
32424:   /* notify the kids */
32424:   nsTObserverArray<imgRequestProxy*>::ForwardIterator srIter(mObservers);
32424:   while (srIter.HasMore()) {
51297:     statusTracker.SendStopRequest(srIter.GetNext(), lastPart, status);
    1:   }
    1: 
71556:   mTimedChannel = nsnull;
    1:   return NS_OK;
    1: }
    1: 
32424: /* prototype for these defined below */
    1: static NS_METHOD sniff_mimetype_callback(nsIInputStream* in, void* closure, const char* fromRawSegment,
    1:                                          PRUint32 toOffset, PRUint32 count, PRUint32 *writeCount);
    1: 
    1: /** nsIStreamListener methods **/
    1: 
    1: /* void onDataAvailable (in nsIRequest request, in nsISupports ctxt, in nsIInputStream inStr, in unsigned long sourceOffset, in unsigned long count); */
    1: NS_IMETHODIMP imgRequest::OnDataAvailable(nsIRequest *aRequest, nsISupports *ctxt, nsIInputStream *inStr, PRUint32 sourceOffset, PRUint32 count)
    1: {
    1:   LOG_SCOPE_WITH_PARAM(gImgLog, "imgRequest::OnDataAvailable", "count", count);
    1: 
    1:   NS_ASSERTION(aRequest, "imgRequest::OnDataAvailable -- no request!");
    1: 
32424:   nsresult rv;
25037: 
50553:   PRUint16 imageType;
50553:   if (mGotData) {
50553:     imageType = mImage->GetType();
50553:   } else {
    1:     LOG_SCOPE(gImgLog, "imgRequest::OnDataAvailable |First time through... finding mimetype|");
    1: 
48320:     mGotData = PR_TRUE;
48320: 
    1:     /* look at the first few bytes and see if we can tell what the data is from that
    1:      * since servers tend to lie. :(
    1:      */
    1:     PRUint32 out;
    1:     inStr->ReadSegments(sniff_mimetype_callback, this, count, &out);
    1: 
    1: #ifdef NS_DEBUG
    1:     /* NS_WARNING if the content type from the channel isn't the same if the sniffing */
    1: #endif
    1: 
    1:     if (mContentType.IsEmpty()) {
    1:       LOG_SCOPE(gImgLog, "imgRequest::OnDataAvailable |sniffing of mimetype failed|");
    1: 
51738:       nsCOMPtr<nsIChannel> chan(do_QueryInterface(aRequest));
51738: 
32424:       rv = NS_ERROR_FAILURE;
    1:       if (chan) {
    1:         rv = chan->GetContentType(mContentType);
    1:       }
    1: 
    1:       if (NS_FAILED(rv)) {
    1:         PR_LOG(gImgLog, PR_LOG_ERROR,
    1:                ("[this=%p] imgRequest::OnDataAvailable -- Content type unavailable from the channel\n",
    1:                 this));
    1: 
    1:         this->Cancel(NS_IMAGELIB_ERROR_FAILURE);
    1: 
    1:         return NS_BINDING_ABORTED;
    1:       }
    1: 
    1:       LOG_MSG(gImgLog, "imgRequest::OnDataAvailable", "Got content type from the channel");
    1:     }
    1: 
50553:     /* now we have mimetype, so we can infer the image type that we want */
52216:     if (mContentType.EqualsLiteral(SVG_MIMETYPE)) {
52216:       mImage = new VectorImage(mStatusTracker.forget());
52216:     } else {
51297:       mImage = new RasterImage(mStatusTracker.forget());
52216:     }
59516:     mImage->SetWindowID(mWindowId);
51297:     imageType = mImage->GetType();
51297: 
51297:     // Notify any imgRequestProxys that are observing us that we have an Image.
51297:     nsTObserverArray<imgRequestProxy*>::ForwardIterator iter(mObservers);
51297:     while (iter.HasMore()) {
51297:       iter.GetNext()->SetImage(mImage);
51297:     }
50553: 
    1:     /* set our mimetype as a property */
    1:     nsCOMPtr<nsISupportsCString> contentType(do_CreateInstance("@mozilla.org/supports-cstring;1"));
    1:     if (contentType) {
    1:       contentType->SetData(mContentType);
    1:       mProperties->Set("type", contentType);
    1:     }
    1: 
    1:     /* set our content disposition as a property */
    1:     nsCAutoString disposition;
51738:     nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(aRequest));
51738:     if (httpChannel) {
51738:       httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("content-disposition"), disposition);
51738:     } else {
51738:       nsCOMPtr<nsIMultiPartChannel> multiPartChannel(do_QueryInterface(aRequest));
51738:       if (multiPartChannel) {
51738:         multiPartChannel->GetContentDisposition(disposition);
51738:       }
    1:     }
    1:     if (!disposition.IsEmpty()) {
    1:       nsCOMPtr<nsISupportsCString> contentDisposition(do_CreateInstance("@mozilla.org/supports-cstring;1"));
    1:       if (contentDisposition) {
    1:         contentDisposition->SetData(disposition);
    1:         mProperties->Set("content-disposition", contentDisposition);
    1:       }
    1:     }
    1: 
    1:     LOG_MSG_WITH_PARAM(gImgLog, "imgRequest::OnDataAvailable", "content type", mContentType.get());
    1: 
32424:     //
50556:     // Figure out our Image initialization flags
32424:     //
    1: 
32424:     // We default to the static globals
32424:     PRBool isDiscardable = gDiscardable;
32424:     PRBool doDecodeOnDraw = gDecodeOnDraw;
    1: 
32424:     // We want UI to be as snappy as possible and not to flicker. Disable discarding
32424:     // and decode-on-draw for chrome URLS
32424:     PRBool isChrome = PR_FALSE;
32424:     rv = mURI->SchemeIs("chrome", &isChrome);
32424:     if (NS_SUCCEEDED(rv) && isChrome)
32424:       isDiscardable = doDecodeOnDraw = PR_FALSE;
    1: 
32424:     // We don't want resources like the "loading" icon to be discardable or
32424:     // decode-on-draw either.
32424:     PRBool isResource = PR_FALSE;
32424:     rv = mURI->SchemeIs("resource", &isResource);
32424:     if (NS_SUCCEEDED(rv) && isResource)
32424:       isDiscardable = doDecodeOnDraw = PR_FALSE;
    1: 
32424:     // For multipart/x-mixed-replace, we basically want a direct channel to the
32424:     // decoder. Disable both for this case as well.
32424:     if (mIsMultiPartChannel)
32424:       isDiscardable = doDecodeOnDraw = PR_FALSE;
32424: 
32424:     // We have all the information we need
50556:     PRUint32 imageFlags = Image::INIT_FLAG_NONE;
32424:     if (isDiscardable)
50556:       imageFlags |= Image::INIT_FLAG_DISCARDABLE;
32424:     if (doDecodeOnDraw)
50556:       imageFlags |= Image::INIT_FLAG_DECODE_ON_DRAW;
32424:     if (mIsMultiPartChannel)
50556:       imageFlags |= Image::INIT_FLAG_MULTIPART;
32424: 
53660:     // Get our URI string
53660:     nsCAutoString uriString;
53660:     rv = mURI->GetSpec(uriString);
53660:     if (NS_FAILED(rv))
53660:       uriString.Assign("<unknown image URI>");
53660: 
51297:     // Initialize the image that we created above. For RasterImages, this
48320:     // instantiates a decoder behind the scenes, so if we don't have a decoder
48320:     // for this mimetype we'll find out about it here.
53660:     rv = mImage->Init(this, mContentType.get(), uriString.get(), imageFlags);
32424:     if (NS_FAILED(rv)) { // Probably bad mimetype
32424: 
32424:       this->Cancel(rv);
32424:       return NS_BINDING_ABORTED;
32424:     }
32516: 
50553:     if (imageType == imgIContainer::TYPE_RASTER) {
46235:       /* Use content-length as a size hint for http channels. */
46235:       if (httpChannel) {
51739:         nsCAutoString contentLength;
51739:         rv = httpChannel->GetResponseHeader(NS_LITERAL_CSTRING("content-length"),
51739:                                             contentLength);
46235:         if (NS_SUCCEEDED(rv)) {
51739:           PRInt32 len = contentLength.ToInteger(&rv);
51739: 
50553:           // Pass anything usable on so that the RasterImage can preallocate
50553:           // its source buffer
51739:           if (len > 0) {
51739:             PRUint32 sizeHint = (PRUint32) len;
71173:             sizeHint = NS_MIN<PRUint32>(sizeHint, 20000000); /* Bound by something reasonable */
50553:             RasterImage* rasterImage = static_cast<RasterImage*>(mImage.get());
71472:             rv = rasterImage->SetSourceSizeHint(sizeHint);
71472:             if (NS_FAILED(rv)) {
71472:               // Flush memory, try to get some back, and try again
71472:               rv = nsMemory::HeapMinimize(PR_TRUE);
71472:               rv |= rasterImage->SetSourceSizeHint(sizeHint);
71472:               // If we've still failed at this point, things are going downhill
71472:               if (NS_FAILED(rv)) {
71472:                 NS_WARNING("About to hit OOM in imagelib!");
71472:               }
71472:             }
50553:           }
46235:         }
46235:       }
46235:     }
46235: 
52203:     if (imageType == imgIContainer::TYPE_RASTER) {
32516:       // If we were waiting on the image to do something, now's our chance.
32516:       if (mDecodeRequested) {
32516:         mImage->RequestDecode();
32516:       }
52203:     } else { // imageType == imgIContainer::TYPE_VECTOR
52203:       nsCOMPtr<nsIStreamListener> imageAsStream = do_QueryInterface(mImage);
52203:       NS_ABORT_IF_FALSE(imageAsStream,
52203:                         "SVG-typed Image failed QI to nsIStreamListener");
52203:       imageAsStream->OnStartRequest(aRequest, nsnull);
52203:     }
    1:   }
    1: 
52203:   if (imageType == imgIContainer::TYPE_RASTER) {
50556:     // WriteToRasterImage always consumes everything it gets
71472:     // if it doesn't run out of memory
32424:     PRUint32 bytesRead;
50556:     rv = inStr->ReadSegments(RasterImage::WriteToRasterImage,
32424:                              static_cast<void*>(mImage),
32424:                              count, &bytesRead);
71472:     NS_ABORT_IF_FALSE(bytesRead == count || mImage->HasError(),
71472:   "WriteToRasterImage should consume everything or the image must be in error!");
52203:   } else { // imageType == imgIContainer::TYPE_VECTOR
52203:     nsCOMPtr<nsIStreamListener> imageAsStream = do_QueryInterface(mImage);
52203:     rv = imageAsStream->OnDataAvailable(aRequest, ctxt, inStr,
52203:                                         sourceOffset, count);
52203:   }
    1:   if (NS_FAILED(rv)) {
    1:     PR_LOG(gImgLog, PR_LOG_WARNING,
32424:            ("[this=%p] imgRequest::OnDataAvailable -- "
50556:             "copy to RasterImage failed\n", this));
    1:     this->Cancel(NS_IMAGELIB_ERROR_FAILURE);
    1:     return NS_BINDING_ABORTED;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static NS_METHOD sniff_mimetype_callback(nsIInputStream* in,
    1:                                          void* closure,
    1:                                          const char* fromRawSegment,
    1:                                          PRUint32 toOffset,
    1:                                          PRUint32 count,
    1:                                          PRUint32 *writeCount)
    1: {
 3233:   imgRequest *request = static_cast<imgRequest*>(closure);
    1: 
    1:   NS_ASSERTION(request, "request is null!");
    1: 
    1:   if (count > 0)
    1:     request->SniffMimeType(fromRawSegment, count);
    1: 
    1:   *writeCount = 0;
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: void
    1: imgRequest::SniffMimeType(const char *buf, PRUint32 len)
    1: {
    1:   imgLoader::GetMimeTypeFromContent(buf, len, mContentType);
 5554: 
 5554:   // The vast majority of the time, imgLoader will find a gif/jpeg/png image
 5554:   // and fill mContentType with the sniffed MIME type.
 5554:   if (!mContentType.IsEmpty())
 5554:     return;
 5554: 
 5554:   // When our sniffing fails, we want to query registered image decoders
 5554:   // to see if they can identify the image. If we always trusted the server
 5554:   // to send the right MIME, images sent as text/plain would not be rendered.
 5554:   const nsCOMArray<nsIContentSniffer>& sniffers = mImageSniffers.GetEntries();
 5554:   PRUint32 length = sniffers.Count();
 5554:   for (PRUint32 i = 0; i < length; ++i) {
 5554:     nsresult rv =
 5554:       sniffers[i]->GetMIMETypeFromContent(nsnull, (const PRUint8 *) buf, len, mContentType);
 5554:     if (NS_SUCCEEDED(rv) && !mContentType.IsEmpty()) {
 5554:       return;
 5554:     }
 5554:   }
    1: }
    1: 
32424: 
23007: /** nsIInterfaceRequestor methods **/
23007: 
23007: NS_IMETHODIMP
23007: imgRequest::GetInterface(const nsIID & aIID, void **aResult)
23007: {
23007:   if (!mPrevChannelSink || aIID.Equals(NS_GET_IID(nsIChannelEventSink)))
23007:     return QueryInterface(aIID, aResult);
23007: 
23007:   NS_ASSERTION(mPrevChannelSink != this, 
23007:                "Infinite recursion - don't keep track of channel sinks that are us!");
23007:   return mPrevChannelSink->GetInterface(aIID, aResult);
23007: }
23007: 
23007: /** nsIChannelEventSink methods **/
23007: NS_IMETHODIMP
48889: imgRequest::AsyncOnChannelRedirect(nsIChannel *oldChannel,
48889:                                    nsIChannel *newChannel, PRUint32 flags,
48889:                                    nsIAsyncVerifyRedirectCallback *callback)
23007: {
48889:   NS_ASSERTION(mRequest && mChannel, "Got a channel redirect after we nulled out mRequest!");
23007:   NS_ASSERTION(mChannel == oldChannel, "Got a channel redirect for an unknown channel!");
23007:   NS_ASSERTION(newChannel, "Got a redirect to a NULL channel!");
23007: 
48889:   // Prepare for callback
48889:   mRedirectCallback = callback;
48889:   mNewRedirectChannel = newChannel;
48889: 
23007:   nsCOMPtr<nsIChannelEventSink> sink(do_GetInterface(mPrevChannelSink));
23007:   if (sink) {
48889:     nsresult rv = sink->AsyncOnChannelRedirect(oldChannel, newChannel, flags,
48889:                                                this);
48889:     if (NS_FAILED(rv)) {
48889:         mRedirectCallback = nsnull;
48889:         mNewRedirectChannel = nsnull;
48889:     }
23007:     return rv;
23007:   }
23007:   
48889:   (void) OnRedirectVerifyCallback(NS_OK);
48889:   return NS_OK;
48889: }
48889: 
48889: NS_IMETHODIMP
48889: imgRequest::OnRedirectVerifyCallback(nsresult result)
48889: {
48889:   NS_ASSERTION(mRedirectCallback, "mRedirectCallback not set in callback");
48889:   NS_ASSERTION(mNewRedirectChannel, "mNewRedirectChannel not set in callback");
48889:     
48889:   if (NS_FAILED(result)) {
48889:       mRedirectCallback->OnRedirectVerifyCallback(result);
48889:       mRedirectCallback = nsnull;
48889:       mNewRedirectChannel = nsnull;
48889:       return NS_OK;
48889:   }
48889: 
48889:   mChannel = mNewRedirectChannel;
71556:   mTimedChannel = do_QueryInterface(mChannel);
48889:   mNewRedirectChannel = nsnull;
23007: 
72903:   // Don't make any cache changes if we're going to point to the same thing. We
72903:   // compare specs and not just URIs here because URIs that compare as
72903:   // .Equals() might have different hashes.
26259:   nsCAutoString oldspec;
72903:   if (mKeyURI)
72903:     mKeyURI->GetSpec(oldspec);
26259:   LOG_MSG_WITH_PARAM(gImgLog, "imgRequest::OnChannelRedirect", "old", oldspec.get());
23007: 
38082:   // make sure we have a protocol that returns data rather than opens
38082:   // an external application, e.g. mailto:
72903:   nsCOMPtr<nsIURI> uri;
72903:   mChannel->GetURI(getter_AddRefs(uri));
38082:   PRBool doesNotReturnData = PR_FALSE;
48889:   nsresult rv =
72903:     NS_URIChainHasFlags(uri, nsIProtocolHandler::URI_DOES_NOT_RETURN_DATA,
38082:                         &doesNotReturnData);
48889: 
48889:   if (NS_SUCCEEDED(rv) && doesNotReturnData)
48889:     rv = NS_ERROR_ABORT;
48889: 
48889:   if (NS_FAILED(rv)) {
48889:     mRedirectCallback->OnRedirectVerifyCallback(rv);
48889:     mRedirectCallback = nsnull;
48889:     return NS_OK;
48889:   }
38082: 
72903:   nsCOMPtr<nsIURI> newURI;
72903:   mChannel->GetOriginalURI(getter_AddRefs(newURI));
72903:   nsCAutoString newspec;
72903:   if (newURI)
72903:     newURI->GetSpec(newspec);
72903:   LOG_MSG_WITH_PARAM(gImgLog, "imgRequest::OnChannelRedirect", "new", newspec.get());
72903: 
72903:   if (oldspec != newspec) {
72903:     if (mIsInCache) {
72903:       // Remove the cache entry from the cache, but don't null out mCacheEntry
72903:       // (as imgRequest::RemoveFromCache() does), because we need it to put
72903:       // ourselves back in the cache.
72903:       if (mCacheEntry)
72903:         imgLoader::RemoveFromCache(mCacheEntry);
72903:       else
72903:         imgLoader::RemoveFromCache(mKeyURI);
72903:     }
72903: 
72903:     mKeyURI = newURI;
72903:  
72903:     if (mIsInCache) {
72903:       // If we don't still have a URI or cache entry, we don't want to put
72903:       // ourselves back into the cache.
72903:       if (mKeyURI && mCacheEntry)
72903:         imgLoader::PutIntoCache(mKeyURI, mCacheEntry);
72903:     }
72903:   }
72903: 
48889:   mRedirectCallback->OnRedirectVerifyCallback(NS_OK);
48889:   mRedirectCallback = nsnull;
48889:   return NS_OK;
23007: }
