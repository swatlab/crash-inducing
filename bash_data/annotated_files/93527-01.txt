36949: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
36949:  * ***** BEGIN LICENSE BLOCK *****
36949:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
36949:  *
36949:  * The contents of this file are subject to the Mozilla Public License Version
36949:  * 1.1 (the "License"); you may not use this file except in compliance with
36949:  * the License. You may obtain a copy of the License at
36949:  * http://www.mozilla.org/MPL/
36949:  *
36949:  * Software distributed under the License is distributed on an "AS IS" basis,
36949:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
36949:  * for the specific language governing rights and limitations under the
36949:  * License.
36949:  *
36949:  * The Original Code is Mozilla Corporation code.
36949:  *
36949:  * The Initial Developer of the Original Code is Mozilla Corporation.
36949:  * Portions created by the Initial Developer are Copyright (C) 2009
36949:  * the Initial Developer. All Rights Reserved.
36949:  *
36949:  * Contributor(s):
36949:  *   Stuart Parmenter <stuart@mozilla.com>
36949:  *   Masayuki Nakano <masayuki@d-toybox.com>
36949:  *   Mats Palmgren <mats.palmgren@bredband.net>
36949:  *   John Daggett <jdaggett@mozilla.com>
36949:  *   Jonathan Kew <jfkthame@gmail.com>
36949:  *
36949:  * Alternatively, the contents of this file may be used under the terms of
36949:  * either the GNU General Public License Version 2 or later (the "GPL"), or
36949:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
36949:  * in which case the provisions of the GPL or the LGPL are applicable instead
36949:  * of those above. If you wish to allow use of your version of this file only
36949:  * under the terms of either the GPL or the LGPL, and not to allow others to
36949:  * use your version of this file under the terms of the MPL, indicate your
36949:  * decision by deleting the provisions above and replace them with the notice
36949:  * and other provisions required by the GPL or the LGPL. If you do not delete
36949:  * the provisions above, a recipient may use your version of this file under
36949:  * the terms of any one of the MPL, the GPL or the LGPL.
36949:  *
36949:  * ***** END LICENSE BLOCK ***** */
36949: 
80467: #include "mozilla/Util.h"
80467: 
61084: #ifdef MOZ_LOGGING
61084: #define FORCE_PR_LOG /* Allow logging in the release build */
61084: #endif
61084: #include "prlog.h"
61084: 
36949: #include "gfxGDIFontList.h"
36949: #include "gfxWindowsPlatform.h"
36949: #include "gfxUserFontSet.h"
36949: #include "gfxFontUtils.h"
39447: #include "gfxGDIFont.h"
36949: 
36949: #include "nsServiceManagerUtils.h"
36949: #include "nsTArray.h"
36949: #include "nsUnicharUtils.h"
36949: 
36949: #include "nsDirectoryServiceUtils.h"
36949: #include "nsDirectoryServiceDefs.h"
36949: #include "nsAppDirectoryServiceDefs.h"
36949: #include "nsISimpleEnumerator.h"
36949: #include "nsIWindowsRegKey.h"
36949: 
74430: #include "mozilla/Telemetry.h"
74430: 
39447: #include <usp10.h>
90802: #include <t2embapi.h>
39447: 
74430: using namespace mozilla;
74430: 
36949: #define ROUND(x) floor((x) + 0.5)
36949: 
42854: 
42854: #ifndef CLEARTYPE_QUALITY
42854: #define CLEARTYPE_QUALITY 5
42854: #endif
42854: 
36949: #ifdef PR_LOGGING
61084: #define LOG_FONTLIST(args) PR_LOG(gfxPlatform::GetLog(eGfxLog_fontlist), \
61084:                                PR_LOG_DEBUG, args)
61084: #define LOG_FONTLIST_ENABLED() PR_LOG_TEST( \
61084:                                    gfxPlatform::GetLog(eGfxLog_fontlist), \
61084:                                    PR_LOG_DEBUG)
36949: 
91869: #define LOG_CMAPDATA_ENABLED() PR_LOG_TEST( \
91869:                                    gfxPlatform::GetLog(eGfxLog_cmapdata), \
91869:                                    PR_LOG_DEBUG)
91869: 
61084: #endif // PR_LOGGING
36949: 
36949: // font info loader constants
61083: 
61083: // avoid doing this during startup even on slow machines but try to start
61083: // it soon enough so that system fallback doesn't happen first
61083: static const PRUint32 kDelayBeforeLoadingFonts = 120 * 1000; // 2 minutes after init
61083: static const PRUint32 kIntervalBetweenLoadingFonts = 2000;   // every 2 seconds until complete
36949: 
36949: static __inline void
36949: BuildKeyNameFromFontName(nsAString &aName)
36949: {
36949:     if (aName.Length() >= LF_FACESIZE)
36949:         aName.Truncate(LF_FACESIZE - 1);
36949:     ToLowerCase(aName);
36949: }
36949: 
36949: // Implementation of gfxPlatformFontList for Win32 GDI,
36949: // using GDI font enumeration APIs to get the list of fonts
36949: 
93527: typedef LONG
93527: (WINAPI *TTLoadEmbeddedFontProc)(HANDLE* phFontReference, ULONG ulFlags,
93527:                                  ULONG* pulPrivStatus, ULONG ulPrivs,
93527:                                  ULONG* pulStatus,
93527:                                  READEMBEDPROC lpfnReadFromStream,
93527:                                  LPVOID lpvReadStream,
93527:                                  LPWSTR szWinFamilyName, 
93527:                                  LPSTR szMacFamilyName,
93527:                                  TTLOADINFO* pTTLoadInfo);
93527: 
93527: typedef LONG
93527: (WINAPI *TTDeleteEmbeddedFontProc)(HANDLE hFontReference, ULONG ulFlags,
93527:                                    ULONG* pulStatus);
93527: 
93527: 
93527: static TTLoadEmbeddedFontProc TTLoadEmbeddedFontPtr = nsnull;
93527: static TTDeleteEmbeddedFontProc TTDeleteEmbeddedFontPtr = nsnull;
91197: 
36949: class WinUserFontData : public gfxUserFontData {
36949: public:
79445:     WinUserFontData(HANDLE aFontRef, bool aIsEmbedded)
47845:         : mFontRef(aFontRef), mIsEmbedded(aIsEmbedded)
36949:     { }
36949: 
36949:     virtual ~WinUserFontData()
36949:     {
47845:         if (mIsEmbedded) {
47845:             ULONG pulStatus;
47845:             LONG err;
93527:             err = TTDeleteEmbeddedFontPtr(mFontRef, 0, &pulStatus);
47845: #if DEBUG
47845:             if (err != E_NONE) {
47845:                 char buf[256];
47845:                 sprintf(buf, "error deleting embedded font handle (%p) - TTDeleteEmbeddedFont returned %8.8x", mFontRef, err);
47845:                 NS_ASSERTION(err == E_NONE, buf);
47845:             }
47845: #endif
36949:         } else {
47845:             BOOL success;
47845:             success = RemoveFontMemResourceEx(mFontRef);
47845: #if DEBUG
47845:             if (!success) {
47845:                 char buf[256];
47845:                 sprintf(buf, "error deleting font handle (%p) - RemoveFontMemResourceEx failed", mFontRef);
47845:                 NS_ASSERTION(success, buf);
47845:             }
47845: #endif
36949:         }
36949:     }
36949:     
36949:     HANDLE mFontRef;
79445:     bool mIsEmbedded;
36949: };
36949: 
36949: BYTE 
36949: FontTypeToOutPrecision(PRUint8 fontType)
36949: {
36949:     BYTE ret;
36949:     switch (fontType) {
36949:     case GFX_FONT_TYPE_TT_OPENTYPE:
36949:     case GFX_FONT_TYPE_TRUETYPE:
36949:         ret = OUT_TT_ONLY_PRECIS;
36949:         break;
36949:     case GFX_FONT_TYPE_PS_OPENTYPE:
36949:         ret = OUT_PS_ONLY_PRECIS;
36949:         break;
36949:     case GFX_FONT_TYPE_TYPE1:
36949:         ret = OUT_OUTLINE_PRECIS;
36949:         break;
36949:     case GFX_FONT_TYPE_RASTER:
36949:         ret = OUT_RASTER_PRECIS;
36949:         break;
36949:     case GFX_FONT_TYPE_DEVICE:
36949:         ret = OUT_DEVICE_PRECIS;
36949:         break;
36949:     default:
36949:         ret = OUT_DEFAULT_PRECIS;
36949:     }
36949:     return ret;
36949: }
36949: 
36949: /***************************************************************
36949:  *
36949:  * GDIFontEntry
36949:  *
36949:  */
36949: 
77858: GDIFontEntry::GDIFontEntry(const nsAString& aFaceName,
77858:                            gfxWindowsFontType aFontType,
79445:                            bool aItalic, PRUint16 aWeight, PRInt16 aStretch,
77858:                            gfxUserFontData *aUserFontData)
77858:     : gfxFontEntry(aFaceName),
40483:       mWindowsFamily(0), mWindowsPitch(0),
40483:       mFontType(aFontType),
80486:       mForceGDI(false), mUnknownCMAP(false),
36949:       mCharset(), mUnicodeRanges()
36949: {
36949:     mUserFontData = aUserFontData;
36949:     mItalic = aItalic;
36949:     mWeight = aWeight;
77858:     mStretch = aStretch;
36949:     if (IsType1())
80486:         mForceGDI = true;
36949:     mIsUserFont = aUserFontData != nsnull;
42854: 
43347:     InitLogFont(aFaceName, aFontType);
36949: }
36949: 
36949: nsresult
36949: GDIFontEntry::ReadCMAP()
36949: {
46221:     // skip non-SFNT fonts completely
46221:     if (mFontType != GFX_FONT_TYPE_PS_OPENTYPE && 
46221:         mFontType != GFX_FONT_TYPE_TT_OPENTYPE &&
46221:         mFontType != GFX_FONT_TYPE_TRUETYPE) 
46221:     {
46221:         return NS_ERROR_FAILURE;
46221:     }
46221: 
36949:     // attempt this once, if errors occur leave a blank cmap
36949:     if (mCmapInitialized)
36949:         return NS_OK;
80486:     mCmapInitialized = true;
36949: 
36949:     const PRUint32 kCmapTag = TRUETYPE_TAG('c','m','a','p');
60098:     AutoFallibleTArray<PRUint8,16384> buffer;
36949:     if (GetFontTable(kCmapTag, buffer) != NS_OK)
36949:         return NS_ERROR_FAILURE;
36949:     PRUint8 *cmap = buffer.Elements();
36949: 
79445:     bool          unicodeFont = false, symbolFont = false;
36949:     nsresult rv = gfxFontUtils::ReadCMAP(cmap, buffer.Length(),
43527:                                          mCharacterMap, mUVSOffset,
43527:                                          unicodeFont, symbolFont);
36949:     mSymbolFont = symbolFont;
43527:     mHasCmapTable = NS_SUCCEEDED(rv);
36949: 
61084: #ifdef PR_LOGGING
61084:     LOG_FONTLIST(("(fontlist-cmap) name: %s, size: %d\n",
36949:                   NS_ConvertUTF16toUTF8(mName).get(), mCharacterMap.GetSize()));
91869:     if (LOG_CMAPDATA_ENABLED()) {
91869:         char prefix[256];
91869:         sprintf(prefix, "(cmapdata) name: %.220s",
91869:                 NS_ConvertUTF16toUTF8(mName).get());
91869:         mCharacterMap.Dump(prefix, eGfxLog_cmapdata);
91869:     }
61084: #endif
36949:     return rv;
36949: }
36949: 
79445: bool
70100: GDIFontEntry::IsSymbolFont()
70100: {
70100:     // initialize cmap first
70100:     HasCmapTable();
70100:     return mSymbolFont;  
70100: }
70100: 
37211: gfxFont *
79445: GDIFontEntry::CreateFontInstance(const gfxFontStyle* aFontStyle, bool aNeedsBold)
37211: {
79445:     bool isXP = (gfxWindowsPlatform::WindowsOSVersion() 
42854:                        < gfxWindowsPlatform::kWindowsVista);
42854: 
79445:     bool useClearType = isXP && !aFontStyle->systemFont &&
42854:         (gfxWindowsPlatform::GetPlatform()->UseClearTypeAlways() ||
43347:          (mIsUserFont && !mIsLocalUserFont &&
42854:           gfxWindowsPlatform::GetPlatform()->UseClearTypeForDownloadableFonts()));
42854: 
42854:     return new gfxGDIFont(this, aFontStyle, aNeedsBold, 
42854:                           (useClearType ? gfxFont::kAntialiasSubpixel
42854:                                         : gfxFont::kAntialiasDefault));
37211: }
37211: 
36949: nsresult
60098: GDIFontEntry::GetFontTable(PRUint32 aTableTag,
60098:                            FallibleTArray<PRUint8>& aBuffer)
36949: {
43526:     if (!IsTrueType()) {
43526:         return NS_ERROR_FAILURE;
43526:     }
43526: 
36949:     AutoDC dc;
36949:     AutoSelectFont font(dc.GetDC(), &mLogFont);
36949:     if (font.IsValid()) {
43526:         PRInt32 tableSize =
43526:             ::GetFontData(dc.GetDC(), NS_SWAP32(aTableTag), 0, NULL, NULL);
36949:         if (tableSize != GDI_ERROR) {
36949:             if (aBuffer.SetLength(tableSize)) {
43526:                 ::GetFontData(dc.GetDC(), NS_SWAP32(aTableTag), 0,
43526:                               aBuffer.Elements(), tableSize);
36949:                 return NS_OK;
36949:             }
36949:             return NS_ERROR_OUT_OF_MEMORY;
36949:         }
36949:     }
36949:     return NS_ERROR_FAILURE;
36949: }
36949: 
36949: void
90073: GDIFontEntry::FillLogFont(LOGFONTW *aLogFont,
42854:                           PRUint16 aWeight, gfxFloat aSize,
79445:                           bool aUseCleartype)
36949: {
36949:     memcpy(aLogFont, &mLogFont, sizeof(LOGFONTW));
36949: 
36949:     aLogFont->lfHeight = (LONG)-ROUND(aSize);
36949: 
90073:     if (aLogFont->lfHeight == 0) {
36949:         aLogFont->lfHeight = -1;
90073:     }
36949: 
90073:     // If a non-zero weight is passed in, use this to override the original
90073:     // weight in the entry's logfont. This is used to control synthetic bolding
90073:     // for installed families with no bold face, and for downloaded fonts
90073:     // (but NOT for local user fonts, because it could cause a different,
90073:     // glyph-incompatible face to be used)
90073:     if (aWeight) {
36949:         aLogFont->lfWeight = aWeight;
90073:     }
90073: 
90073:     // for non-local() user fonts, we never want to apply italics here;
90073:     // if the face is described as italic, we should use it as-is,
90073:     // and if it's not, but then the element is styled italic, we'll use
90073:     // a cairo transform to create fake italic (oblique)
90073:     if (IsUserFont() && !IsLocalUserFont()) {
90073:         aLogFont->lfItalic = 0;
90073:     }
90073: 
43347:     aLogFont->lfQuality = (aUseCleartype ? CLEARTYPE_QUALITY : DEFAULT_QUALITY);
36949: }
36949: 
62924: #define MISSING_GLYPH 0x1F // glyph index returned for missing characters
62924:                            // on WinXP with .fon fonts, but not Type1 (.pfb)
46221: 
79445: bool 
36949: GDIFontEntry::TestCharacterMap(PRUint32 aCh)
36949: {
36949:     if (ReadCMAP() != NS_OK) {
36949:         // For fonts where we failed to read the character map,
36949:         // we can take a slow path to look up glyphs character by character
80486:         mUnknownCMAP = true;
36949:     }
36949: 
36949:     if (mUnknownCMAP) {
36949:         if (aCh > 0xFFFF)
80486:             return false;
36949: 
36949:         // previous code was using the group style
36949:         gfxFontStyle fakeStyle;  
36949:         if (mItalic)
93220:             fakeStyle.style = NS_FONT_STYLE_ITALIC;
36949:         fakeStyle.weight = mWeight * 100;
36949: 
80486:         nsRefPtr<gfxFont> tempFont = FindOrMakeFont(&fakeStyle, false);
39447:         if (!tempFont || !tempFont->Valid())
80486:             return false;
39447:         gfxGDIFont *font = static_cast<gfxGDIFont*>(tempFont.get());
36949: 
36949:         HDC dc = GetDC((HWND)nsnull);
36949:         SetGraphicsMode(dc, GM_ADVANCED);
36949:         HFONT hfont = font->GetHFONT();
36949:         HFONT oldFont = (HFONT)SelectObject(dc, hfont);
36949: 
36949:         PRUnichar str[1] = { (PRUnichar)aCh };
36949:         WORD glyph[1];
36949: 
79445:         bool hasGlyph = false;
46221: 
46221:         // Bug 573038 - in some cases GetGlyphIndicesW returns 0xFFFF for a 
46221:         // missing glyph or 0x1F in other cases to indicate the "invalid" 
46221:         // glyph.  Map both cases to "not found"
39447:         if (IsType1() || mForceGDI) {
46221:             // Type1 fonts and uniscribe APIs don't get along.  
46221:             // ScriptGetCMap will return E_HANDLE
46221:             DWORD ret = GetGlyphIndicesW(dc, str, 1, 
46221:                                          glyph, GGI_MARK_NONEXISTING_GLYPHS);
46221:             if (ret != GDI_ERROR
46221:                 && glyph[0] != 0xFFFF
62924:                 && (IsType1() || glyph[0] != MISSING_GLYPH))
46221:             {
80486:                 hasGlyph = true;
46221:             }
36949:         } else {
46221:             // ScriptGetCMap works better than GetGlyphIndicesW 
46221:             // for things like bitmap/vector fonts
39447:             SCRIPT_CACHE sc = NULL;
39447:             HRESULT rv = ScriptGetCMap(dc, &sc, str, 1, 0, glyph);
36949:             if (rv == S_OK)
80486:                 hasGlyph = true;
36949:         }
36949: 
36949:         SelectObject(dc, oldFont);
36949:         ReleaseDC(NULL, dc);
36949: 
36949:         if (hasGlyph) {
36949:             mCharacterMap.set(aCh);
80486:             return true;
36949:         }
36949:     } else {
36949:         // font had a cmap so simply check that
36949:         return mCharacterMap.test(aCh);
36949:     }
36949: 
80486:     return false;
36949: }
36949: 
36949: void
36949: GDIFontEntry::InitLogFont(const nsAString& aName,
43347:                           gfxWindowsFontType aFontType)
36949: {
36949: #define CLIP_TURNOFF_FONTASSOCIATION 0x40
36949:     
36949:     mLogFont.lfHeight = -1;
36949: 
36949:     // Fill in logFont structure
36949:     mLogFont.lfWidth          = 0;
36949:     mLogFont.lfEscapement     = 0;
36949:     mLogFont.lfOrientation    = 0;
36949:     mLogFont.lfUnderline      = FALSE;
36949:     mLogFont.lfStrikeOut      = FALSE;
36949:     mLogFont.lfCharSet        = DEFAULT_CHARSET;
36949:     mLogFont.lfOutPrecision   = FontTypeToOutPrecision(aFontType);
36949:     mLogFont.lfClipPrecision  = CLIP_TURNOFF_FONTASSOCIATION;
43347:     mLogFont.lfQuality        = DEFAULT_QUALITY;
36949:     mLogFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
36949:     // always force lfItalic if we want it.  Font selection code will
36949:     // do its best to give us an italic font entry, but if no face exists
36949:     // it may give us a regular one based on weight.  Windows should
36949:     // do fake italic for us in that case.
36949:     mLogFont.lfItalic         = mItalic;
36949:     mLogFont.lfWeight         = mWeight;
36949: 
71173:     int len = NS_MIN<int>(aName.Length(), LF_FACESIZE - 1);
71519:     memcpy(&mLogFont.lfFaceName, nsPromiseFlatString(aName).get(), len * 2);
36949:     mLogFont.lfFaceName[len] = '\0';
36949: }
36949: 
36949: GDIFontEntry* 
77858: GDIFontEntry::CreateFontEntry(const nsAString& aName,
79445:                               gfxWindowsFontType aFontType, bool aItalic,
77858:                               PRUint16 aWeight, PRInt16 aStretch,
36949:                               gfxUserFontData* aUserFontData)
36949: {
36949:     // jtdfix - need to set charset, unicode ranges, pitch/family
36949: 
77858:     GDIFontEntry *fe = new GDIFontEntry(aName, aFontType, aItalic,
77858:                                         aWeight, aStretch, aUserFontData);
36949: 
36949:     return fe;
36949: }
36949: 
36949: /***************************************************************
36949:  *
36949:  * GDIFontFamily
36949:  *
36949:  */
36949: 
36949: int CALLBACK
36949: GDIFontFamily::FamilyAddStylesProc(const ENUMLOGFONTEXW *lpelfe,
36949:                                         const NEWTEXTMETRICEXW *nmetrics,
36949:                                         DWORD fontType, LPARAM data)
36949: {
36949:     const NEWTEXTMETRICW& metrics = nmetrics->ntmTm;
36949:     LOGFONTW logFont = lpelfe->elfLogFont;
36949:     GDIFontFamily *ff = reinterpret_cast<GDIFontFamily*>(data);
36949: 
36949:     // Some fonts claim to support things > 900, but we don't so clamp the sizes
81029:     logFont.lfWeight = clamped(logFont.lfWeight, LONG(100), LONG(900));
36949: 
36949:     gfxWindowsFontType feType = GDIFontEntry::DetermineFontType(metrics, fontType);
36949: 
36949:     GDIFontEntry *fe = nsnull;
36949:     for (PRUint32 i = 0; i < ff->mAvailableFonts.Length(); ++i) {
36949:         fe = static_cast<GDIFontEntry*>(ff->mAvailableFonts[i].get());
36949:         if (feType > fe->mFontType) {
36949:             // if the new type is better than the old one, remove the old entries
36949:             ff->mAvailableFonts.RemoveElementAt(i);
36949:             --i;
36949:         } else if (feType < fe->mFontType) {
36949:             // otherwise if the new type is worse, skip it
36949:             return 1;
36949:         }
36949:     }
36949: 
36949:     for (PRUint32 i = 0; i < ff->mAvailableFonts.Length(); ++i) {
36949:         fe = static_cast<GDIFontEntry*>(ff->mAvailableFonts[i].get());
36949:         // check if we already know about this face
36949:         if (fe->mWeight == logFont.lfWeight &&
36949:             fe->mItalic == (logFont.lfItalic == 0xFF)) {
36949:             // update the charset bit here since this could be different
37209:             fe->mCharset.set(metrics.tmCharSet);
36949:             return 1; 
36949:         }
36949:     }
36949: 
77858:     fe = GDIFontEntry::CreateFontEntry(nsDependentString(lpelfe->elfFullName),
77858:                                        feType, (logFont.lfItalic == 0xFF),
77858:                                        (PRUint16) (logFont.lfWeight), 0,
77858:                                        nsnull);
36949:     if (!fe)
36949:         return 1;
36949: 
61357:     ff->AddFontEntry(fe);
36949: 
36949:     // mark the charset bit
37209:     fe->mCharset.set(metrics.tmCharSet);
36949: 
36949:     fe->mWindowsFamily = logFont.lfPitchAndFamily & 0xF0;
36949:     fe->mWindowsPitch = logFont.lfPitchAndFamily & 0x0F;
36949: 
36949:     if (nmetrics->ntmFontSig.fsUsb[0] != 0x00000000 &&
36949:         nmetrics->ntmFontSig.fsUsb[1] != 0x00000000 &&
36949:         nmetrics->ntmFontSig.fsUsb[2] != 0x00000000 &&
36949:         nmetrics->ntmFontSig.fsUsb[3] != 0x00000000) {
36949: 
36949:         // set the unicode ranges
36949:         PRUint32 x = 0;
36949:         for (PRUint32 i = 0; i < 4; ++i) {
36949:             DWORD range = nmetrics->ntmFontSig.fsUsb[i];
36949:             for (PRUint32 k = 0; k < 32; ++k) {
37209:                 fe->mUnicodeRanges.set(x++, (range & (1 << k)) != 0);
36949:             }
36949:         }
36949:     }
36949: 
36949: #ifdef PR_LOGGING
61084:     if (LOG_FONTLIST_ENABLED()) {
61084:         LOG_FONTLIST(("(fontlist) added (%s) to family (%s)"
36949:              " with style: %s weight: %d stretch: %d",
36949:              NS_ConvertUTF16toUTF8(fe->Name()).get(), 
36949:              NS_ConvertUTF16toUTF8(ff->Name()).get(), 
36949:              (logFont.lfItalic == 0xff) ? "italic" : "normal",
36949:              logFont.lfWeight, fe->Stretch()));
36949:     }
36949: #endif
36949:     return 1;
36949: }
36949: 
36949: void
36949: GDIFontFamily::FindStyleVariations()
36949: {
36949:     if (mHasStyles)
36949:         return;
80486:     mHasStyles = true;
36949: 
36949:     HDC hdc = GetDC(nsnull);
36949:     SetGraphicsMode(hdc, GM_ADVANCED);
36949: 
36949:     LOGFONTW logFont;
36949:     memset(&logFont, 0, sizeof(LOGFONTW));
36949:     logFont.lfCharSet = DEFAULT_CHARSET;
36949:     logFont.lfPitchAndFamily = 0;
71173:     PRUint32 l = NS_MIN<PRUint32>(mName.Length(), LF_FACESIZE - 1);
36949:     memcpy(logFont.lfFaceName,
36949:            nsPromiseFlatString(mName).get(),
36949:            l * sizeof(PRUnichar));
36949:     logFont.lfFaceName[l] = 0;
36949: 
36949:     EnumFontFamiliesExW(hdc, &logFont,
36949:                         (FONTENUMPROCW)GDIFontFamily::FamilyAddStylesProc,
36949:                         (LPARAM)this, 0);
38205: #ifdef PR_LOGGING
61084:     if (LOG_FONTLIST_ENABLED() && mAvailableFonts.Length() == 0) {
61084:         LOG_FONTLIST(("(fontlist) no styles available in family \"%s\"",
61084:                       NS_ConvertUTF16toUTF8(mName).get()));
36949:     }
36949: #endif
36949: 
36949:     ReleaseDC(nsnull, hdc);
36949: 
36949:     if (mIsBadUnderlineFamily)
36949:         SetBadUnderlineFonts();
36949: }
36949: 
36949: /***************************************************************
36949:  *
36949:  * gfxGDIFontList
36949:  *
36949:  */
36949: 
36949: gfxGDIFontList::gfxGDIFontList()
36949: {
36949:     mFontSubstitutes.Init(50);
91197: 
93527:     InitializeFontEmbeddingProcs();
36949: }
36949: 
36949: static void
36949: RemoveCharsetFromFontSubstitute(nsAString &aName)
36949: {
36949:     PRInt32 comma = aName.FindChar(PRUnichar(','));
36949:     if (comma >= 0)
36949:         aName.Truncate(comma);
36949: }
36949: 
61083: #define MAX_VALUE_NAME 512
61083: #define MAX_VALUE_DATA 512
61083: 
36949: nsresult
36949: gfxGDIFontList::GetFontSubstitutes()
36949: {
61083:     HKEY hKey;
61083:     DWORD i, rv, lenAlias, lenActual, valueType;
61083:     WCHAR aliasName[MAX_VALUE_NAME];
61083:     WCHAR actualName[MAX_VALUE_DATA];
61083: 
61083:     if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
61083:           L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes",
61083:           0, KEY_READ, &hKey) != ERROR_SUCCESS)
61083:     {
36949:         return NS_ERROR_FAILURE;
61083:     }
36949: 
61083:     for (i = 0, rv = ERROR_SUCCESS; rv != ERROR_NO_MORE_ITEMS; i++) {
61083:         aliasName[0] = 0;
80467:         lenAlias = ArrayLength(aliasName);
61083:         actualName[0] = 0;
61083:         lenActual = sizeof(actualName);
61083:         rv = RegEnumValueW(hKey, i, aliasName, &lenAlias, NULL, &valueType, 
61083:                 (LPBYTE)actualName, &lenActual);
36949: 
61083:         if (rv != ERROR_SUCCESS || valueType != REG_SZ || lenAlias == 0) {
36949:             continue;
61083:         }
61083: 
61083:         if (aliasName[0] == WCHAR('@')) {
36949:             continue;
61083:         }
36949: 
61083:         nsAutoString substituteName((PRUnichar*) aliasName);
61083:         nsAutoString actualFontName((PRUnichar*) actualName);
36949:         RemoveCharsetFromFontSubstitute(substituteName);
36949:         BuildKeyNameFromFontName(substituteName);
36949:         RemoveCharsetFromFontSubstitute(actualFontName);
36949:         BuildKeyNameFromFontName(actualFontName);
36949:         gfxFontFamily *ff;
61083:         if (!actualFontName.IsEmpty() && 
61083:             (ff = mFontFamilies.GetWeak(actualFontName))) {
36949:             mFontSubstitutes.Put(substituteName, ff);
36949:         } else {
36949:             mNonExistingFonts.AppendElement(substituteName);
36949:         }
36949:     }
81013: 
81013:     // "Courier" on a default Windows install is an ugly bitmap font.
81013:     // If there is no substitution for Courier in the registry
81013:     // substitute "Courier" with "Courier New".
81013:     nsAutoString substituteName;
81013:     substituteName.AssignLiteral("Courier");
81013:     BuildKeyNameFromFontName(substituteName);
81013:     if (!mFontSubstitutes.Get(substituteName)) {
81013:         gfxFontFamily *ff;
81013:         nsAutoString actualFontName;
81013:         actualFontName.AssignLiteral("Courier New");
81013:         BuildKeyNameFromFontName(actualFontName);
81013:         ff = mFontFamilies.GetWeak(actualFontName);
81013:         if (ff) {
81013:             mFontSubstitutes.Put(substituteName, ff);
81013:         }
81013:     }
36949:     return NS_OK;
36949: }
36949: 
57104: nsresult
36949: gfxGDIFontList::InitFontList()
36949: {
74430:     Telemetry::AutoTimer<Telemetry::GDI_INITFONTLIST_TOTAL> timer;
36949:     gfxFontCache *fc = gfxFontCache::GetCache();
36949:     if (fc)
36949:         fc->AgeAllGenerations();
36949: 
37618:     // reset font lists
37618:     gfxPlatformFontList::InitFontList();
37618:     
36949:     mFontSubstitutes.Clear();
36949:     mNonExistingFonts.Clear();
36949: 
36949:     // iterate over available families
36949:     LOGFONTW logfont;
36949:     memset(&logfont, 0, sizeof(logfont));
36949:     logfont.lfCharSet = DEFAULT_CHARSET;
36949: 
36949:     AutoDC hdc;
36949:     int result = EnumFontFamiliesExW(hdc.GetDC(), &logfont,
36949:                                      (FONTENUMPROCW)&EnumFontFamExProc,
36949:                                      0, 0);
36949: 
36949:     GetFontSubstitutes();
36949: 
36949:     StartLoader(kDelayBeforeLoadingFonts, kIntervalBetweenLoadingFonts);
57104: 
57104:     return NS_OK;
36949: }
36949: 
36949: int CALLBACK
36949: gfxGDIFontList::EnumFontFamExProc(ENUMLOGFONTEXW *lpelfe,
36949:                                       NEWTEXTMETRICEXW *lpntme,
36949:                                       DWORD fontType,
36949:                                       LPARAM lParam)
36949: {
36949:     const LOGFONTW& lf = lpelfe->elfLogFont;
36949: 
36949:     if (lf.lfFaceName[0] == '@') {
36949:         return 1;
36949:     }
36949: 
36949:     nsAutoString name(lf.lfFaceName);
36949:     BuildKeyNameFromFontName(name);
36949: 
36949:     gfxGDIFontList *fontList = PlatformFontList();
36949: 
36949:     if (!fontList->mFontFamilies.GetWeak(name)) {
37209:         nsDependentString faceName(lf.lfFaceName);
37209:         nsRefPtr<gfxFontFamily> family = new GDIFontFamily(faceName);
36949:         fontList->mFontFamilies.Put(name, family);
60116: 
60116:         // if locale is such that CJK font names are the default coming from
60116:         // GDI, then if a family name is non-ASCII immediately read in other
60116:         // family names.  This assures that MS Gothic, MS Mincho are all found
60116:         // before lookups begin.
60116:         if (!IsASCII(faceName)) {
60116:             family->ReadOtherFamilyNames(gfxPlatformFontList::PlatformFontList());
60116:         }
60116: 
38060:         if (fontList->mBadUnderlineFamilyNames.Contains(name))
37599:             family->SetBadUnderlineFamily();
36949:     }
36949: 
36949:     return 1;
36949: }
36949: 
36949: gfxFontEntry* 
36949: gfxGDIFontList::LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
36949:                                 const nsAString& aFullname)
36949: {
79445:     bool found;
37618:     gfxFontEntry *lookup;
36949: 
37618:     // initialize name lookup tables if needed
37618:     if (!mFaceNamesInitialized) {
37618:         InitFaceNameLists();
37618:     }
36949: 
37618:     // lookup in name lookup tables, return null if not found
37618:     if (!(lookup = mPostscriptNames.GetWeak(aFullname, &found)) &&
37618:         !(lookup = mFullnames.GetWeak(aFullname, &found))) 
36949:     {
36949:         return nsnull;
36949:     }
36949: 
37618:     // create a new font entry with the proxy entry style characteristics
36949:     PRUint16 w = (aProxyEntry->mWeight == 0 ? 400 : aProxyEntry->mWeight);
79445:     bool isCFF = false; // jtdfix -- need to determine this
36949:     
37618:     // use the face name from the lookup font entry, which will be the localized
37618:     // face name which GDI mapping tables use (e.g. with the system locale set to
37618:     // Dutch, a fullname of 'Arial Bold' will find a font entry with the face name
37618:     // 'Arial Vet' which can be used as a key in GDI font lookups).
37618:     gfxFontEntry *fe = GDIFontEntry::CreateFontEntry(lookup->Name(), 
36949:         gfxWindowsFontType(isCFF ? GFX_FONT_TYPE_PS_OPENTYPE : GFX_FONT_TYPE_TRUETYPE) /*type*/, 
93220:         PRUint32(aProxyEntry->mItalic ? NS_FONT_STYLE_ITALIC : NS_FONT_STYLE_NORMAL), 
77858:         w, aProxyEntry->mStretch, nsnull);
36949:         
36949:     if (!fe)
37618:         return nsnull;
36949: 
80486:     fe->mIsUserFont = true;
80486:     fe->mIsLocalUserFont = true;
36949:     return fe;
36949: }
36949: 
93527: void gfxGDIFontList::InitializeFontEmbeddingProcs()
93527: {
93527:     static HMODULE fontlib = LoadLibraryW(L"t2embed.dll");
93527:     if (!fontlib)
93527:         return;
93527:     TTLoadEmbeddedFontPtr = (TTLoadEmbeddedFontProc)
93527:         GetProcAddress(fontlib, "TTLoadEmbeddedFont");
93527:     TTDeleteEmbeddedFontPtr = (TTDeleteEmbeddedFontProc)
93527:         GetProcAddress(fontlib, "TTDeleteEmbeddedFont");
93527: }
93527: 
36949: // used to control stream read by Windows TTLoadEmbeddedFont API
36949: 
36949: class EOTFontStreamReader {
36949: public:
36949:     EOTFontStreamReader(const PRUint8 *aFontData, PRUint32 aLength, PRUint8 *aEOTHeader, 
36949:                            PRUint32 aEOTHeaderLen, FontDataOverlay *aNameOverlay)
36949:         : mCurrentChunk(0), mChunkOffset(0)
36949:     {
36949:         NS_ASSERTION(aFontData, "null font data ptr passed in");
36949:         NS_ASSERTION(aEOTHeader, "null EOT header ptr passed in");
36949:         NS_ASSERTION(aNameOverlay, "null name overlay struct passed in");
36949: 
36949:         if (aNameOverlay->overlaySrc) {
36949:             mNumChunks = 4;
36949:             // 0 : EOT header
36949:             mDataChunks[0].mData = aEOTHeader;
36949:             mDataChunks[0].mLength = aEOTHeaderLen;
36949:             // 1 : start of font data to overlayDest
36949:             mDataChunks[1].mData = aFontData;
36949:             mDataChunks[1].mLength = aNameOverlay->overlayDest;
36949:             // 2 : overlay data
36949:             mDataChunks[2].mData = aFontData + aNameOverlay->overlaySrc;
36949:             mDataChunks[2].mLength = aNameOverlay->overlaySrcLen;
36949:             // 3 : rest of font data
36949:             mDataChunks[3].mData = aFontData + aNameOverlay->overlayDest + aNameOverlay->overlaySrcLen;
36949:             mDataChunks[3].mLength = aLength - aNameOverlay->overlayDest - aNameOverlay->overlaySrcLen;
36949:         } else {
36949:             mNumChunks = 2;
36949:             // 0 : EOT header
36949:             mDataChunks[0].mData = aEOTHeader;
36949:             mDataChunks[0].mLength = aEOTHeaderLen;
36949:             // 1 : font data
36949:             mDataChunks[1].mData = aFontData;
36949:             mDataChunks[1].mLength = aLength;
36949:         }
36949:     }
36949: 
36949:     ~EOTFontStreamReader() 
36949:     { 
36949: 
36949:     }
36949: 
36949:     struct FontDataChunk {
36949:         const PRUint8 *mData;
36949:         PRUint32       mLength;
36949:     };
36949: 
36949:     PRUint32                mNumChunks;
36949:     FontDataChunk           mDataChunks[4];
36949:     PRUint32                mCurrentChunk;
36949:     PRUint32                mChunkOffset;
36949: 
36949:     unsigned long Read(void *outBuffer, const unsigned long aBytesToRead)
36949:     {
36949:         PRUint32 bytesLeft = aBytesToRead;  // bytes left in the out buffer
36949:         PRUint8 *out = static_cast<PRUint8*> (outBuffer);
36949: 
36949:         while (mCurrentChunk < mNumChunks && bytesLeft) {
36949:             FontDataChunk& currentChunk = mDataChunks[mCurrentChunk];
71173:             PRUint32 bytesToCopy = NS_MIN(bytesLeft, 
36949:                                           currentChunk.mLength - mChunkOffset);
36949:             memcpy(out, currentChunk.mData + mChunkOffset, bytesToCopy);
36949:             bytesLeft -= bytesToCopy;
36949:             mChunkOffset += bytesToCopy;
36949:             out += bytesToCopy;
36949: 
36949:             NS_ASSERTION(mChunkOffset <= currentChunk.mLength, "oops, buffer overrun");
36949: 
36949:             if (mChunkOffset == currentChunk.mLength) {
36949:                 mCurrentChunk++;
36949:                 mChunkOffset = 0;
36949:             }
36949:         }
36949: 
36949:         return aBytesToRead - bytesLeft;
36949:     }
36949: 
36949:     static unsigned long ReadEOTStream(void *aReadStream, void *outBuffer, 
36949:                                        const unsigned long aBytesToRead) 
36949:     {
36949:         EOTFontStreamReader *eotReader = 
36949:                                static_cast<EOTFontStreamReader*> (aReadStream);
36949:         return eotReader->Read(outBuffer, aBytesToRead);
36949:     }        
36949:         
36949: };
36949: 
36949: gfxFontEntry* 
36949: gfxGDIFontList::MakePlatformFont(const gfxProxyFontEntry *aProxyEntry, 
36949:                                  const PRUint8 *aFontData,
36949:                                  PRUint32 aLength)
36949: {
36949:     // MakePlatformFont is responsible for deleting the font data with NS_Free
36949:     // so we set up a stack object to ensure it is freed even if we take an
36949:     // early exit
36949:     struct FontDataDeleter {
36949:         FontDataDeleter(const PRUint8 *aFontData)
36949:             : mFontData(aFontData) { }
36949:         ~FontDataDeleter() { NS_Free((void*)mFontData); }
36949:         const PRUint8 *mFontData;
36949:     };
36949:     FontDataDeleter autoDelete(aFontData);
36949: 
79445:     bool hasVertical;
79445:     bool isCFF = gfxFontUtils::IsCffFont(aFontData, hasVertical);
36949: 
36949:     nsresult rv;
36949:     HANDLE fontRef = nsnull;
79445:     bool isEmbedded = false;
36949: 
36949:     nsAutoString uniqueName;
36949:     rv = gfxFontUtils::MakeUniqueUserFontName(uniqueName);
36949:     if (NS_FAILED(rv))
36949:         return nsnull;
36949: 
93527:     // for TTF fonts, first try using the t2embed library if available
93527:     if (!isCFF && TTLoadEmbeddedFontPtr && TTDeleteEmbeddedFontPtr) {
36949:         // TrueType-style glyphs, use EOT library
60098:         AutoFallibleTArray<PRUint8,2048> eotHeader;
36949:         PRUint8 *buffer;
36949:         PRUint32 eotlen;
36949: 
80486:         isEmbedded = true;
71173:         PRUint32 nameLen = NS_MIN<PRUint32>(uniqueName.Length(), LF_FACESIZE - 1);
71730:         nsAutoString fontName(Substring(uniqueName, 0, nameLen));
36949:         
36949:         FontDataOverlay overlayNameData = {0, 0, 0};
36949: 
36949:         rv = gfxFontUtils::MakeEOTHeader(aFontData, aLength, &eotHeader, 
36949:                                          &overlayNameData);
47845:         if (NS_SUCCEEDED(rv)) {
36949: 
36949:             // load in embedded font data
36949:             eotlen = eotHeader.Length();
36949:             buffer = reinterpret_cast<PRUint8*> (eotHeader.Elements());
36949:             
36949:             PRInt32 ret;
36949:             ULONG privStatus, pulStatus;
36949:             EOTFontStreamReader eotReader(aFontData, aLength, buffer, eotlen,
36949:                                           &overlayNameData);
36949: 
93527:             ret = TTLoadEmbeddedFontPtr(&fontRef, TTLOAD_PRIVATE, &privStatus,
36949:                                         LICENSE_PREVIEWPRINT, &pulStatus,
36949:                                         EOTFontStreamReader::ReadEOTStream,
47845:                                         &eotReader,
47845:                                         (PRUnichar*)(fontName.get()), 0, 0);
47845:             if (ret != E_NONE) {
36949:                 fontRef = nsnull;
47845:                 char buf[256];
47845:                 sprintf(buf, "font (%s) not loaded using TTLoadEmbeddedFont - error %8.8x", NS_ConvertUTF16toUTF8(aProxyEntry->FamilyName()).get(), ret);
47845:                 NS_WARNING(buf);
47845:             }
47845:         }
36949:     }
36949: 
36949:     // load CFF fonts or fonts that failed with t2embed loader
36949:     if (fontRef == nsnull) {
36949:         // Postscript-style glyphs, swizzle name table, load directly
60098:         FallibleTArray<PRUint8> newFontData;
36949: 
80486:         isEmbedded = false;
36949:         rv = gfxFontUtils::RenameFont(uniqueName, aFontData, aLength, &newFontData);
36949: 
36949:         if (NS_FAILED(rv))
36949:             return nsnull;
36949:         
36949:         DWORD numFonts = 0;
36949: 
36949:         PRUint8 *fontData = reinterpret_cast<PRUint8*> (newFontData.Elements());
36949:         PRUint32 fontLength = newFontData.Length();
36949:         NS_ASSERTION(fontData, "null font data after renaming");
36949: 
36949:         // http://msdn.microsoft.com/en-us/library/ms533942(VS.85).aspx
36949:         // "A font that is added by AddFontMemResourceEx is always private 
36949:         //  to the process that made the call and is not enumerable."
36949:         fontRef = AddFontMemResourceEx(fontData, fontLength, 
36949:                                        0 /* reserved */, &numFonts);
36949:         if (!fontRef)
36949:             return nsnull;
36949: 
36949:         // only load fonts with a single face contained in the data
63900:         // AddFontMemResourceEx generates an additional face name for
63900:         // vertical text if the font supports vertical writing
63900:         if (fontRef && numFonts != 1 + !!hasVertical) {
36949:             RemoveFontMemResourceEx(fontRef);
36949:             return nsnull;
36949:         }
36949:     }
36949: 
36949:     // make a new font entry using the unique name
47845:     WinUserFontData *winUserFontData = new WinUserFontData(fontRef, isEmbedded);
36949:     PRUint16 w = (aProxyEntry->mWeight == 0 ? 400 : aProxyEntry->mWeight);
36949: 
36949:     GDIFontEntry *fe = GDIFontEntry::CreateFontEntry(uniqueName, 
36949:         gfxWindowsFontType(isCFF ? GFX_FONT_TYPE_PS_OPENTYPE : GFX_FONT_TYPE_TRUETYPE) /*type*/, 
93220:         PRUint32(aProxyEntry->mItalic ? NS_FONT_STYLE_ITALIC : NS_FONT_STYLE_NORMAL), 
77858:         w, aProxyEntry->mStretch, winUserFontData);
36949: 
36949:     if (!fe)
36949:         return fe;
36949: 
80486:     fe->mIsUserFont = true;
36949: 
47845:     // Uniscribe doesn't place CFF fonts loaded privately 
47845:     // via AddFontMemResourceEx on XP/Vista
47845:     if (isCFF && gfxWindowsPlatform::WindowsOSVersion() 
47845:                  < gfxWindowsPlatform::kWindows7) {
80486:         fe->mForceGDI = true;
47845:     }
36949:  
36949:     return fe;
36949: }
36949: 
36949: gfxFontEntry*
79445: gfxGDIFontList::GetDefaultFont(const gfxFontStyle* aStyle, bool& aNeedsBold)
36949: {
36949:     // this really shouldn't fail to find a font....
36949:     HGDIOBJ hGDI = ::GetStockObject(DEFAULT_GUI_FONT);
36949:     LOGFONTW logFont;
36949:     if (hGDI && ::GetObjectW(hGDI, sizeof(logFont), &logFont)) {
36949:         nsAutoString resolvedName;
36949:         if (ResolveFontName(nsDependentString(logFont.lfFaceName), resolvedName)) {
36949:             return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
36949:         }
36949:     }
36949: 
36949:     // ...but just in case, try another approach as well
36949:     NONCLIENTMETRICSW ncm;
36949:     ncm.cbSize = sizeof(ncm);
36949:     BOOL status = ::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, 
36949:                                           sizeof(ncm), &ncm, 0);
36949:     if (status) {
36949:         nsAutoString resolvedName;
36949:         if (ResolveFontName(nsDependentString(ncm.lfMessageFont.lfFaceName), resolvedName)) {
36949:             return FindFontForFamily(resolvedName, aStyle, aNeedsBold);
36949:         }
36949:     }
36949: 
36949:     return nsnull;
36949: }
36949: 
36949: 
79445: bool 
36949: gfxGDIFontList::ResolveFontName(const nsAString& aFontName, nsAString& aResolvedFontName)
36949: {
36949:     nsAutoString keyName(aFontName);
36949:     BuildKeyNameFromFontName(keyName);
36949: 
36949:     nsRefPtr<gfxFontFamily> ff;
36949:     if (mFontSubstitutes.Get(keyName, &ff)) {
36949:         aResolvedFontName = ff->Name();
80486:         return true;
36949:     }
36949: 
36949:     if (mNonExistingFonts.Contains(keyName))
80486:         return false;
36949: 
36949:     if (gfxPlatformFontList::ResolveFontName(aFontName, aResolvedFontName))
80486:         return true;
36949: 
80486:     return false;
36949: }
