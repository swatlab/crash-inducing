    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998-2000
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Henry Sobotka <sobotka@axess.com>
    1:  *   IBM Corp.
    1:  *   Rich Walsh <dragtext@e-vertise.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: // N.B. the ns* & pr* headers below will #include all
    1: // of the standard library headers this file requires
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsMemory.h"
    1: 
    1: #include "nsLocalFile.h"
    1: #include "nsNativeCharsetUtils.h"
    1: 
    1: #include "nsISimpleEnumerator.h"
    1: #include "nsIDirectoryEnumerator.h"
    1: #include "nsIComponentManager.h"
    1: #include "prtypes.h"
    1: #include "prio.h"
    1: 
    1: #include "nsReadableUtils.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsIMutableArray.h"
    1: #include "nsTraceRefcntImpl.h"
    1: 
    1: #define CHECK_mWorkingPath()                    \
    1:     PR_BEGIN_MACRO                              \
    1:         if (mWorkingPath.IsEmpty())             \
    1:             return NS_ERROR_NOT_INITIALIZED;    \
    1:     PR_END_MACRO
    1: 
    1: //-----------------------------------------------------------------------------
    1: // static helper functions
    1: //-----------------------------------------------------------------------------
    1: 
    1: static nsresult ConvertOS2Error(int err)
    1: {
    1:     nsresult rv;
    1: 
    1:     switch (err)
    1:     {
    1:         case ERROR_FILE_NOT_FOUND:
    1:         case ERROR_PATH_NOT_FOUND:
    1:         case ERROR_INVALID_DRIVE:
    1:             rv = NS_ERROR_FILE_NOT_FOUND;
    1:             break;
    1:         case ERROR_ACCESS_DENIED:
    1:         case ERROR_NOT_SAME_DEVICE:
    1:             rv = NS_ERROR_FILE_ACCESS_DENIED;
    1:             break;
    1:         case ERROR_NOT_ENOUGH_MEMORY:
    1:         case ERROR_INVALID_BLOCK:
    1:         case ERROR_INVALID_HANDLE:
    1:         case ERROR_ARENA_TRASHED:
    1:             rv = NS_ERROR_OUT_OF_MEMORY;
    1:             break;
    1:         case ERROR_CURRENT_DIRECTORY:
    1:             rv = NS_ERROR_FILE_DIR_NOT_EMPTY;
    1:             break;
    1:         case ERROR_WRITE_PROTECT:
    1:             rv = NS_ERROR_FILE_READ_ONLY;
    1:             break;
    1:         case ERROR_HANDLE_DISK_FULL:
    1:             rv = NS_ERROR_FILE_TOO_BIG;
    1:             break;
    1:         case ERROR_FILE_EXISTS:
    1:         case ERROR_ALREADY_EXISTS:
    1:         case ERROR_CANNOT_MAKE:
    1:             rv = NS_ERROR_FILE_ALREADY_EXISTS;
    1:             break;
    1:         case ERROR_FILENAME_EXCED_RANGE:
    1:             rv = NS_ERROR_FILE_NAME_TOO_LONG;
    1:             break;
    1:         case 0:
    1:             rv = NS_OK;
    1:         default:
    1:             rv = NS_ERROR_FAILURE;
    1:     }
    1:     return rv;
    1: }
    1: 
    1: static void
    1: myLL_L2II(PRInt64 result, PRInt32 *hi, PRInt32 *lo )
    1: {
    1:     PRInt64 a64, b64;  // probably could have been done with
    1:                        // only one PRInt64, but these are macros,
    1:                        // and I am a wimp.
    1: 
    1:     // shift the hi word to the low word, then push it into a long.
    1:     LL_SHR(a64, result, 32);
    1:     LL_L2I(*hi, a64);
    1: 
    1:     // shift the low word to the hi word first, then shift it back.
    1:     LL_SHL(b64, result, 32);
    1:     LL_SHR(a64, b64, 32);
    1:     LL_L2I(*lo, a64);
    1: }
    1: 
    1: // Locates the first occurrence of charToSearchFor in the stringToSearch
20261: static unsigned char*
    1: _mbschr(const unsigned char* stringToSearch, int charToSearchFor)
    1: {
    1:     const unsigned char* p = stringToSearch;
    1: 
    1:     do {
    1:         if (*p == charToSearchFor)
    1:             break;
    1:         p  = (const unsigned char*)WinNextChar(0,0,0,(char*)p);
    1:     } while (*p);
    1: 
    1:     // Result is p or NULL
    1:     return *p ? (unsigned char*)p : NULL;
    1: }
    1: 
    1: // Locates the first occurrence of subString in the stringToSearch
20261: static unsigned char*
    1: _mbsstr(const unsigned char* stringToSearch, const unsigned char* subString)
    1: {
    1:     const unsigned char* pStr = stringToSearch;
    1:     const unsigned char* pSub = subString;
    1: 
    1:     do {
    1:         while (*pStr && *pStr != *pSub)
    1:             pStr = (const unsigned char*)WinNextChar(0,0,0,(char*)pStr);
    1: 
    1:         if (!*pStr)
    1:             break;
    1: 
    1:         const unsigned char* pNxt = pStr;
    1:         do {
    1:             pSub = (const unsigned char*)WinNextChar(0,0,0,(char*)pSub);
    1:             pNxt = (const unsigned char*)WinNextChar(0,0,0,(char*)pNxt);
    1:         } while (*pSub && *pSub == *pNxt);
    1: 
    1:         if (!*pSub)
    1:             break;
    1: 
    1:         pSub = subString;
    1:         pStr = (const unsigned char*)WinNextChar(0,0,0,(char*)pStr);
    1: 
    1:     } while (*pStr);
    1: 
    1:     // if we got to the end of pSub, we've found it
    1:     return *pSub ? NULL : (unsigned char*)pStr;
    1: }
    1: 
    1: // Locates last occurence of charToSearchFor in the stringToSearch
    1: NS_EXPORT unsigned char*
    1: _mbsrchr(const unsigned char* stringToSearch, int charToSearchFor)
    1: {
    1:     int length = strlen((const char*)stringToSearch);
    1:     const unsigned char* p = stringToSearch+length;
    1: 
    1:     do {
    1:         if (*p == charToSearchFor)
    1:             break;
    1:         p  = (const unsigned char*)WinPrevChar(0,0,0,(char*)stringToSearch,(char*)p);
    1:     } while (p > stringToSearch);
    1: 
    1:     // Result is p or NULL
    1:     return (*p == charToSearchFor) ? (unsigned char*)p : NULL;
    1: }
    1: 
    1: // Implement equivalent of Win32 CreateDirectoryA
20261: static nsresult
    1: CreateDirectoryA(PSZ path, PEAOP2 ppEABuf)
    1: {
    1:     APIRET rc;
    1:     nsresult rv;
    1:     FILESTATUS3 pathInfo;
    1: 
    1:     rc = DosCreateDir(path, ppEABuf);
    1:     if (rc != NO_ERROR)
    1:     {
    1:         rv = ConvertOS2Error(rc);
    1: 
    1:         // Check if directory already exists and if so,
    1:         // reflect that in the return value
    1:         rc = DosQueryPathInfo(path, FIL_STANDARD,
    1:                               &pathInfo, sizeof(pathInfo));
    1:         if (rc == NO_ERROR)
    1:             rv = ERROR_FILE_EXISTS;
    1:     }
    1:     else
    1:         rv = rc;
    1: 
    1:     return rv;
    1: }
    1: 
    1: static int isleadbyte(int c)
    1: {
    1:     static BOOL bDBCSFilled = FALSE;
    1:     // According to the Control Program Guide&Ref, 12 bytes is sufficient
    1:     static BYTE DBCSInfo[12] = { 0 };
    1:     BYTE *curr;
    1:     BOOL retval = FALSE;
    1: 
    1:     if(!bDBCSFilled)
    1:     {
    1:         COUNTRYCODE ctrycodeInfo = { 0 };
    1:         APIRET rc = NO_ERROR;
    1:         ctrycodeInfo.country = 0;     // Current Country
    1:         ctrycodeInfo.codepage = 0;    // Current Codepage
    1: 
    1:         rc = DosQueryDBCSEnv(sizeof(DBCSInfo), &ctrycodeInfo, DBCSInfo);
    1:         // we had an error, do something?
    1:         if (rc != NO_ERROR)
    1:             return FALSE;
    1: 
    1:         bDBCSFilled=TRUE;
    1:     }
    1: 
    1:     // DBCSInfo returned by DosQueryDBCSEnv is terminated
    1:     // with two '0' bytes in a row
    1:     curr = DBCSInfo;
    1:     while(*curr != 0 && *(curr+1) != 0)
    1:     {
    1:         if(c >= *curr && c <= *(curr+1))
    1:         {
    1:             retval=TRUE;
    1:             break;
    1:         }
    1:         curr+=2;
    1:     }
    1: 
    1:     return retval;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsDirEnumerator
    1: //-----------------------------------------------------------------------------
    1: 
    1: class nsDirEnumerator : public nsISimpleEnumerator,
    1:                         public nsIDirectoryEnumerator
    1: {
    1:     public:
    1: 
    1:         NS_DECL_ISUPPORTS
    1: 
    1:         nsDirEnumerator() : mDir(nsnull)
    1:         {
    1:         }
    1: 
    1:         nsresult Init(nsILocalFile* parent)
    1:         {
    1:             nsCAutoString filepath;
    1:             parent->GetNativeTarget(filepath);
    1: 
    1:             if (filepath.IsEmpty())
    1:             {
    1:                 parent->GetNativePath(filepath);
    1:             }
    1: 
    1:             if (filepath.IsEmpty())
    1:             {
    1:                 return NS_ERROR_UNEXPECTED;
    1:             }
    1: 
    1:             mDir = PR_OpenDir(filepath.get());
    1:             if (mDir == nsnull)    // not a directory?
    1:                 return NS_ERROR_FAILURE;
    1: 
    1:             mParent = parent;
    1:             return NS_OK;
    1:         }
    1: 
79445:         NS_IMETHOD HasMoreElements(bool *result)
    1:         {
    1:             nsresult rv;
    1:             if (mNext == nsnull && mDir)
    1:             {
    1:                 PRDirEntry* entry = PR_ReadDir(mDir, PR_SKIP_BOTH);
    1:                 if (entry == nsnull)
    1:                 {
    1:                     // end of dir entries
    1: 
    1:                     PRStatus status = PR_CloseDir(mDir);
    1:                     if (status != PR_SUCCESS)
    1:                         return NS_ERROR_FAILURE;
    1:                     mDir = nsnull;
    1: 
80486:                     *result = false;
    1:                     return NS_OK;
    1:                 }
    1: 
    1:                 nsCOMPtr<nsIFile> file;
    1:                 rv = mParent->Clone(getter_AddRefs(file));
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1: 
    1:                 rv = file->AppendNative(nsDependentCString(entry->name));
    1:                 if (NS_FAILED(rv))
    1:                     return rv;
    1: 
    1:                 // make sure the thing exists.  If it does, try the next one.
79445:                 bool exists;
    1:                 rv = file->Exists(&exists);
    1:                 if (NS_FAILED(rv) || !exists)
    1:                 {
    1:                     return HasMoreElements(result);
    1:                 }
    1: 
    1:                 mNext = do_QueryInterface(file);
    1:             }
    1:             *result = mNext != nsnull;
    1:             if (!*result)
    1:                 Close();
    1:             return NS_OK;
    1:         }
    1: 
    1:         NS_IMETHOD GetNext(nsISupports **result)
    1:         {
    1:             nsresult rv;
79445:             bool hasMore;
    1:             rv = HasMoreElements(&hasMore);
    1:             if (NS_FAILED(rv)) return rv;
    1: 
    1:             *result = mNext;        // might return nsnull
    1:             NS_IF_ADDREF(*result);
    1: 
    1:             mNext = nsnull;
    1:             return NS_OK;
    1:         }
    1: 
    1:         NS_IMETHOD GetNextFile(nsIFile **result)
    1:         {
    1:             *result = nsnull;
79445:             bool hasMore = false;
    1:             nsresult rv = HasMoreElements(&hasMore);
    1:             if (NS_FAILED(rv) || !hasMore)
    1:                 return rv;
    1:             *result = mNext;
    1:             NS_IF_ADDREF(*result);
    1:             mNext = nsnull;
    1:             return NS_OK;
    1:         }
    1: 
    1:         NS_IMETHOD Close()
    1:         {
    1:             if (mDir)
    1:             {
    1:                 PRStatus status = PR_CloseDir(mDir);
    1:                 NS_ASSERTION(status == PR_SUCCESS, "close failed");
    1:                 if (status != PR_SUCCESS)
    1:                     return NS_ERROR_FAILURE;
    1:                 mDir = nsnull;
    1:             }
    1:             return NS_OK;
    1:         }
    1: 
    1:         // dtor can be non-virtual since there are no subclasses, but must be
    1:         // public to use the class on the stack.
    1:         ~nsDirEnumerator()
    1:         {
    1:             Close();
    1:         }
    1: 
    1:     protected:
    1:         PRDir*                  mDir;
    1:         nsCOMPtr<nsILocalFile>  mParent;
    1:         nsCOMPtr<nsILocalFile>  mNext;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS2(nsDirEnumerator, nsISimpleEnumerator, nsIDirectoryEnumerator)
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsDriveEnumerator
    1: //-----------------------------------------------------------------------------
    1: 
    1: class nsDriveEnumerator : public nsISimpleEnumerator
    1: {
    1: public:
    1:     nsDriveEnumerator();
    1:     virtual ~nsDriveEnumerator();
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSISIMPLEENUMERATOR
    1:     nsresult Init();
    1: 
    1: private:
    1:     // mDrives is a bitmap representing the available drives
    1:     // mLetter is incremented each time mDrives is shifted rightward
    1:     PRUint32    mDrives;
    1:     PRUint8     mLetter;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(nsDriveEnumerator, nsISimpleEnumerator)
    1: 
    1: nsDriveEnumerator::nsDriveEnumerator()
    1:  : mDrives(0), mLetter(0)
    1: {
    1: }
    1: 
    1: nsDriveEnumerator::~nsDriveEnumerator()
    1: {
    1: }
    1: 
    1: nsresult nsDriveEnumerator::Init()
    1: {
    1:     ULONG   ulCurrent;
    1: 
    1:     // bits 0-25 in mDrives represent each possible drive, A-Z
    1:     DosError(FERR_DISABLEHARDERR);
    1:     APIRET rc = DosQueryCurrentDisk(&ulCurrent, (PULONG)&mDrives);
    1:     DosError(FERR_ENABLEHARDERR);
    1:     if (rc)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     mLetter = 'A';
    1:     return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsDriveEnumerator::HasMoreElements(bool *aHasMore)
    1: {
    1:     // no more bits means no more drives
    1:     *aHasMore = (mDrives != 0);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsDriveEnumerator::GetNext(nsISupports **aNext)
    1: {
    1:     if (!mDrives)
    1:     {
    1:         *aNext = nsnull;
    1:         return NS_OK;
    1:     }
    1: 
    1:     // if bit 0 is off, advance to the next bit that's on
    1:     while ((mDrives & 1) == 0)
    1:     {
    1:         mDrives >>= 1;
    1:         mLetter++;
    1:     }
    1: 
    1:     // format a drive string, then advance to the next possible drive
    1:     char drive[4] = "x:\\";
    1:     drive[0] = mLetter;
    1:     mDrives >>= 1;
    1:     mLetter++;
    1: 
    1:     nsILocalFile *file;
    1:     nsresult rv = NS_NewNativeLocalFile(nsDependentCString(drive),
80486:                                         false, &file);
    1:     *aNext = file;
    1: 
    1:     return rv;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // class TypeEaEnumerator - a convenience for accessing
    1: // a file's .TYPE extended attribute
    1: //-----------------------------------------------------------------------------
    1: 
    1: // this struct describes the first entry for an MVMT or MVST EA;
    1: // .TYPE is supposed to be MVMT but is sometimes malformed as MVST
    1: 
    1: typedef struct _MVHDR {
    1:     USHORT  usEAType;
    1:     USHORT  usCodePage;
    1:     USHORT  usNumEntries;
    1:     USHORT  usDataType;
    1:     USHORT  usDataLth;
    1:     char    data[1];
    1: } MVHDR;
    1: 
    1: typedef MVHDR *PMVHDR;
    1: 
    1: 
    1: class TypeEaEnumerator
    1: {
    1: public:
    1:     TypeEaEnumerator() : mEaBuf(nsnull) { }
    1:     ~TypeEaEnumerator() { if (mEaBuf) NS_Free(mEaBuf); }
    1: 
    1:     nsresult Init(nsLocalFile * aFile);
    1:     char *   GetNext(PRUint32 *lth);
    1: 
    1: private:
    1:     char *  mEaBuf;
    1:     char *  mpCur;
    1:     PMVHDR  mpMvh;
    1:     USHORT  mLth;
    1:     USHORT  mCtr;
    1: };
    1: 
    1: 
    1: nsresult TypeEaEnumerator::Init(nsLocalFile * aFile)
    1: {
    1: #define EABUFSIZE 512
    1: 
    1:     // provide a buffer for the results
    1:     mEaBuf = (char*)NS_Alloc(EABUFSIZE);
    1:     if (!mEaBuf)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     PFEA2LIST   pfea2list = (PFEA2LIST)mEaBuf;
    1:     pfea2list->cbList = EABUFSIZE;
    1: 
    1:     // ask for the .TYPE extended attribute
    1:     nsresult rv = aFile->GetEA(".TYPE", pfea2list);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // point at the data - it starts immediately after the EA's name;
    1:     // then confirm the EA is MVMT (correct) or MVST (acceptable)
    1:     mpMvh = (PMVHDR)&(pfea2list->list[0].szName[pfea2list->list[0].cbName+1]);
    1:     if (mpMvh->usEAType != EAT_MVMT)
    1:         if (mpMvh->usEAType != EAT_MVST || mpMvh->usDataType != EAT_ASCII)
    1:             return NS_ERROR_FAILURE;
    1: 
    1:     // init the variables that tell us where we are in the lsit
    1:     mLth = 0;
    1:     mCtr = 0;
    1:     mpCur = (char*)(mpMvh->usEAType == EAT_MVMT ?
    1:                     &mpMvh->usDataType : &mpMvh->usDataLth);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: char *   TypeEaEnumerator::GetNext(PRUint32 *lth)
    1: {
    1:     char *  result = nsnull;
    1: 
    1:     // this is a loop so we can skip invalid entries if needed;
    1:     // normally, it will break out on the first iteration
    1:     while (mCtr++ < mpMvh->usNumEntries) {
    1: 
    1:         // advance to the next entry
    1:         mpCur += mLth;
    1: 
    1:         // if MVMT, ensure the datatype is OK, then advance
    1:         // to the length field present in both formats
    1:         if (mpMvh->usEAType == EAT_MVMT) {
    1:             if (*((PUSHORT)mpCur) != EAT_ASCII)
    1:                 continue;
    1:             mpCur += sizeof(USHORT);
    1:         }
    1: 
    1:         // get the data's length, point at the data itself, then exit
    1:         mLth = *lth = *((PUSHORT)mpCur);
    1:         mpCur += sizeof(USHORT);
    1:         result = mpCur;
    1:         break;
    1:     }
    1: 
    1:     return result;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsLocalFile <public>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsLocalFile::nsLocalFile()
80486:   : mDirty(true)
    1: {
    1: }
    1: 
47878: nsresult
    1: nsLocalFile::nsLocalFileConstructor(nsISupports* outer, const nsIID& aIID, void* *aInstancePtr)
    1: {
    1:     NS_ENSURE_ARG_POINTER(aInstancePtr);
    1:     NS_ENSURE_NO_AGGREGATION(outer);
    1: 
    1:     nsLocalFile* inst = new nsLocalFile();
    1:     if (inst == NULL)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     nsresult rv = inst->QueryInterface(aIID, aInstancePtr);
    1:     if (NS_FAILED(rv))
    1:     {
    1:         delete inst;
    1:         return rv;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsLocalFile::nsISupports
    1: //-----------------------------------------------------------------------------
    1: 
11159: NS_IMPL_THREADSAFE_ISUPPORTS4(nsLocalFile,
    1:                               nsILocalFile,
    1:                               nsIFile,
    1:                               nsILocalFileOS2,
    1:                               nsIHashable)
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsLocalFile <private>
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsLocalFile::nsLocalFile(const nsLocalFile& other)
80486:   : mDirty(true)
    1:   , mWorkingPath(other.mWorkingPath)
    1: {
    1: }
    1: 
    1: 
    1: // Stat the path. After a successful return the path is
    1: // guaranteed valid and the members of mFileInfo64 can be used.
    1: nsresult
    1: nsLocalFile::Stat()
    1: {
    1:     // if we aren't dirty then we are already done
    1:     if (!mDirty)
    1:         return NS_OK;
    1: 
    1:     // we can't stat anything that isn't a valid NSPR addressable path
    1:     if (mWorkingPath.IsEmpty())
    1:         return NS_ERROR_FILE_INVALID_PATH;
    1: 
    1:     // hack designed to work around bug 134796 until it is fixed
    1:     char temp[4];
    1:     const char *nsprPath = mWorkingPath.get();
    1:     if (mWorkingPath.Length() == 2 && mWorkingPath.CharAt(1) == ':')
    1:     {
    1:         temp[0] = mWorkingPath[0];
    1:         temp[1] = mWorkingPath[1];
    1:         temp[2] = '\\';
    1:         temp[3] = '\0';
    1:         nsprPath = temp;
    1:     }
    1: 
    1:     // see if the working path exists
    1:     DosError(FERR_DISABLEHARDERR);
    1:     PRStatus status = PR_GetFileInfo64(nsprPath, &mFileInfo64);
    1:     DosError(FERR_ENABLEHARDERR);
    1:     if (status != PR_SUCCESS)
    1:         return NS_ERROR_FILE_NOT_FOUND;
    1: 
80486:     mDirty = false;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsLocalFile::nsIFile,nsILocalFile
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Clone(nsIFile **file)
    1: {
    1:     // Just copy-construct ourselves
    1:     *file = new nsLocalFile(*this);
    1:     if (!*file)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ADDREF(*file);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::InitWithNativePath(const nsACString &filePath)
    1: {
    1:     MakeDirty();
    1: 
    1:     nsACString::const_iterator begin, end;
    1:     filePath.BeginReading(begin);
    1:     filePath.EndReading(end);
    1: 
    1:     // input string must not be empty
    1:     if (begin == end)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     char firstChar = *begin;
    1:     char secondChar = *(++begin);
    1: 
    1:     // just do a sanity check.  if it has any forward slashes, it is not
    1:     // a Native path.  Also, it must have a colon at after the first char.
25735:     if (FindCharInReadable('/', begin, end))
    1:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
25735:     if (secondChar != ':' && (secondChar != '\\' || firstChar != '\\'))
25735:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
25735: 
25735:     mWorkingPath = filePath;
    1:     // kill any trailing '\' provided it isn't the second char of DBCS
25735:     PRInt32 len = mWorkingPath.Length() - 1;
25735:     if (mWorkingPath[len] == '\\' && !::isleadbyte(mWorkingPath[len - 1]))
25735:         mWorkingPath.Truncate(len);
25735: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::OpenNSPRFileDesc(PRInt32 flags, PRInt32 mode, PRFileDesc **_retval)
    1: {
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv) && rv != NS_ERROR_FILE_NOT_FOUND)
    1:         return rv;
    1: 
    1:     *_retval = PR_Open(mWorkingPath.get(), flags, mode);
    1:     if (*_retval)
    1:         return NS_OK;
    1: 
26480:     if (flags & DELETE_ON_CLOSE) {
26480:         PR_Delete(mWorkingPath.get());
26480:     }
26480: 
    1:     return NS_ErrorAccordingToNSPR();
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::OpenANSIFileDesc(const char *mode, FILE * *_retval)
    1: {
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv) && rv != NS_ERROR_FILE_NOT_FOUND)
    1:         return rv;
    1: 
    1:     *_retval = fopen(mWorkingPath.get(), mode);
    1:     if (*_retval)
    1:         return NS_OK;
    1: 
    1:     return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Create(PRUint32 type, PRUint32 attributes)
    1: {
    1:     if (type != NORMAL_FILE_TYPE && type != DIRECTORY_TYPE)
    1:         return NS_ERROR_FILE_UNKNOWN_TYPE;
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv) && rv != NS_ERROR_FILE_NOT_FOUND)
    1:         return rv;
    1: 
    1:     // create directories to target
    1:     //
    1:     // A given local file can be either one of these forms:
    1:     //
    1:     //   - normal:    X:\some\path\on\this\drive
    1:     //                       ^--- start here
    1:     //
    1:     //   - UNC path:  \\machine\volume\some\path\on\this\drive
    1:     //                                     ^--- start here
    1:     //
    1:     // Skip the first 'X:\' for the first form, and skip the first full
    1:     // '\\machine\volume\' segment for the second form.
    1: 
    1:     unsigned char* path = (unsigned char*) mWorkingPath.BeginWriting();
    1: 
    1:     if (path[0] == '\\' && path[1] == '\\')
    1:     {
    1:         // dealing with a UNC path here; skip past '\\machine\'
    1:         path = _mbschr(path + 2, '\\');
    1:         if (!path)
    1:             return NS_ERROR_FILE_INVALID_PATH;
    1:         ++path;
    1:     }
    1: 
    1:     // search for first slash after the drive (or volume) name
    1:     unsigned char* slash = _mbschr(path, '\\');
    1: 
    1:     if (slash)
    1:     {
    1:         // skip the first '\\'
    1:         ++slash;
    1:         slash = _mbschr(slash, '\\');
    1: 
    1:         while (slash)
    1:         {
    1:             *slash = '\0';
    1: 
 3233:             rv = CreateDirectoryA(const_cast<char*>(mWorkingPath.get()), NULL);
    1:             if (rv) {
    1:                 rv = ConvertOS2Error(rv);
    1:                 if (rv != NS_ERROR_FILE_ALREADY_EXISTS)
    1:                     return rv;
    1:             }
    1:             *slash = '\\';
    1:             ++slash;
    1:             slash = _mbschr(slash, '\\');
    1:         }
    1:     }
    1: 
    1:     if (type == NORMAL_FILE_TYPE)
    1:     {
    1:         PRFileDesc* file = PR_Open(mWorkingPath.get(), PR_RDONLY | PR_CREATE_FILE | PR_APPEND | PR_EXCL, attributes);
 7847:         if (!file)
 8101:             return NS_ERROR_FILE_ALREADY_EXISTS;
    1: 
    1:         PR_Close(file);
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (type == DIRECTORY_TYPE)
    1:     {
 3233:         rv = CreateDirectoryA(const_cast<char*>(mWorkingPath.get()), NULL);
    1:         if (rv)
    1:             return ConvertOS2Error(rv);
    1:         else
    1:             return NS_OK;
    1:     }
    1: 
    1:     return NS_ERROR_FILE_UNKNOWN_TYPE;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::AppendNative(const nsACString &node)
    1: {
    1:     // append this path, multiple components are not permitted
80486:     return AppendNativeInternal(PromiseFlatCString(node), false);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::AppendRelativeNativePath(const nsACString &node)
    1: {
    1:     // append this path, multiple components are permitted
80486:     return AppendNativeInternal(PromiseFlatCString(node), true);
    1: }
    1: 
    1: nsresult
79445: nsLocalFile::AppendNativeInternal(const nsAFlatCString &node, bool multipleComponents)
    1: {
    1:     if (node.IsEmpty())
    1:         return NS_OK;
    1: 
    1:     // check the relative path for validity
    1:     const unsigned char * nodePath = (const unsigned char *) node.get();
    1:     if (*nodePath == '\\'                           // can't start with an '\'
    1:         || _mbschr(nodePath, '/')                   // can't contain /
    1:         || node.Equals(".."))                       // can't be ..
    1:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
    1:     if (multipleComponents)
    1:     {
    1:         // can't contain .. as a path component. Ensure that the valid components
    1:         // "foo..foo", "..foo", and "foo.." are not falsely detected, but the invalid
    1:         // paths "..\", "foo\..", "foo\..\foo", "..\foo", etc are.
    1:         const unsigned char * doubleDot = _mbsstr(nodePath, (const unsigned char *)"\\..");
    1:         while (doubleDot)
    1:         {
    1:             doubleDot += 3;
    1:             if (*doubleDot == '\0' || *doubleDot == '\\')
    1:                 return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1:             doubleDot = _mbsstr(doubleDot, (unsigned char *)"\\..");
    1:         }
    1:         // catches the remaining cases of prefixes (i.e. '..\')
    1:         // note: this is a substitute for Win32's _mbsncmp(nodePath, "..\\", 3)
    1:         if (*nodePath == '.') {
    1:             nodePath = (const unsigned char*)WinNextChar(0,0,0,(char*)nodePath);
    1:             if (*nodePath == '.' &&
    1:                 *WinNextChar(0,0,0,(char*)nodePath) == '\\')
    1:                 return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1:         }
    1:     }
    1:     else if (_mbschr(nodePath, '\\'))   // single components can't contain '\'
    1:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
    1:     MakeDirty();
    1: 
    1:     mWorkingPath.Append(NS_LITERAL_CSTRING("\\") + node);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Normalize()
    1: {
    1:     // XXX See bug 187957 comment 18 for possible problems with this implementation.
    1: 
    1:     if (mWorkingPath.IsEmpty())
    1:         return NS_OK;
    1: 
    1:     // work in unicode for ease
    1:     nsAutoString path;
    1:     NS_CopyNativeToUnicode(mWorkingPath, path);
    1: 
    1:     // find the index of the root backslash for the path. Everything before
    1:     // this is considered fully normalized and cannot be ascended beyond
    1:     // using ".."  For a local drive this is the first slash (e.g. "c:\").
    1:     // For a UNC path it is the slash following the share name
    1:     // (e.g. "\\server\share\").
    1:     PRInt32 rootIdx = 2;        // default to local drive
    1:     if (path.First() == '\\')   // if a share then calculate the rootIdx
    1:     {
    1:         rootIdx = path.FindChar('\\', 2);   // skip \\ in front of the server
    1:         if (rootIdx == kNotFound)
    1:             return NS_OK;                   // already normalized
    1:         rootIdx = path.FindChar('\\', rootIdx+1);
    1:         if (rootIdx == kNotFound)
    1:             return NS_OK;                   // already normalized
    1:     }
    1:     else if (path.CharAt(rootIdx) != '\\')
    1:     {
    1:         // The path has been specified relative to the current working directory
    1:         // for that drive. To normalize it, the current working directory for
    1:         // that drive needs to be inserted before the supplied relative path
    1:         // which will provide an absolute path (and the rootIdx will still be 2).
    1:         char drv[4] = "A:.";
    1:         char cwd[CCHMAXPATH];
    1: 
    1:         drv[0] = mWorkingPath.First();
    1:         if (DosQueryPathInfo(drv, FIL_QUERYFULLNAME, cwd, sizeof(cwd)))
    1:             return NS_ERROR_FILE_NOT_FOUND;
    1: 
    1:         nsAutoString currentDir;
    1:         NS_CopyNativeToUnicode(nsDependentCString(cwd), currentDir);
    1: 
    1:         if (currentDir.Last() == '\\')
    1:             path.Replace(0, 2, currentDir);
    1:         else
    1:             path.Replace(0, 2, currentDir + NS_LITERAL_STRING("\\"));
    1:     }
    1:     NS_POSTCONDITION(0 < rootIdx && rootIdx < (PRInt32)path.Length(), "rootIdx is invalid");
    1:     NS_POSTCONDITION(path.CharAt(rootIdx) == '\\', "rootIdx is invalid");
    1: 
    1:     // if there is nothing following the root path then it is already normalized
    1:     if (rootIdx + 1 == (PRInt32)path.Length())
    1:         return NS_OK;
    1: 
    1:     // assign the root
    1:     nsAutoString normal;
    1:     const PRUnichar * pathBuffer = path.get();  // simplify access to the buffer
    1:     normal.SetCapacity(path.Length()); // it won't ever grow longer
    1:     normal.Assign(pathBuffer, rootIdx);
    1: 
    1:     // Normalize the path components. The actions taken are:
    1:     //
    1:     //  "\\"    condense to single backslash
    1:     //  "."     remove from path
    1:     //  ".."    up a directory
    1:     //  "..."   remove from path (any number of dots > 2)
    1:     //
    1:     // The last form is something that Windows 95 and 98 supported and
    1:     // is a shortcut for changing up multiple directories. Windows XP
    1:     // and ilk ignore it in a path, as is done here.
    1:     PRInt32 len, begin, end = rootIdx;
    1:     while (end < (PRInt32)path.Length())
    1:     {
    1:         // find the current segment (text between the backslashes) to
    1:         // be examined, this will set the following variables:
    1:         //  begin == index of first char in segment
    1:         //  end   == index 1 char after last char in segment
    1:         //  len   == length of segment
    1:         begin = end + 1;
    1:         end = path.FindChar('\\', begin);
    1:         if (end == kNotFound)
    1:             end = path.Length();
    1:         len = end - begin;
    1: 
    1:         // ignore double backslashes
    1:         if (len == 0)
    1:             continue;
    1: 
    1:         // len != 0, and interesting paths always begin with a dot
    1:         if (pathBuffer[begin] == '.')
    1:         {
    1:             // ignore single dots
    1:             if (len == 1)
    1:                 continue;
    1: 
    1:             // handle multiple dots
    1:             if (len >= 2 && pathBuffer[begin+1] == '.')
    1:             {
    1:                 // back up a path component on double dot
    1:                 if (len == 2)
    1:                 {
    1:                     PRInt32 prev = normal.RFindChar('\\');
    1:                     if (prev >= rootIdx)
    1:                         normal.Truncate(prev);
    1:                     continue;
    1:                 }
    1: 
    1:                 // length is > 2 and the first two characters are dots.
    1:                 // if the rest of the string is dots, then ignore it.
    1:                 int idx = len - 1;
    1:                 for (; idx >= 2; --idx)
    1:                 {
    1:                     if (pathBuffer[begin+idx] != '.')
    1:                         break;
    1:                 }
    1: 
    1:                 // this is true if the loop above didn't break
    1:                 // and all characters in this segment are dots.
    1:                 if (idx < 2)
    1:                     continue;
    1:             }
    1:         }
    1: 
    1:         // add the current component to the path, including the preceding backslash
    1:         normal.Append(pathBuffer + begin - 1, len + 1);
    1:     }
    1: 
    1:     // kill trailing dots and spaces.
    1:     PRInt32 filePathLen = normal.Length() - 1;
    1:     while(filePathLen > 0 && (normal[filePathLen] == ' ' || normal[filePathLen] == '.'))
    1:     {
    1:         normal.Truncate(filePathLen--);
    1:     }
    1: 
    1:     NS_CopyUnicodeToNative(normal, mWorkingPath);
    1:     MakeDirty();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetNativeLeafName(nsACString &aLeafName)
    1: {
    1:     aLeafName.Truncate();
    1: 
    1:     const char* temp = mWorkingPath.get();
    1:     if(temp == nsnull)
    1:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
    1:     const char* leaf = (const char*) _mbsrchr((const unsigned char*) temp, '\\');
    1: 
    1:     // if the working path is just a node without any lashes.
    1:     if (leaf == nsnull)
    1:         leaf = temp;
    1:     else
    1:         leaf++;
    1: 
    1:     aLeafName.Assign(leaf);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetNativeLeafName(const nsACString &aLeafName)
    1: {
    1:     MakeDirty();
    1: 
    1:     const unsigned char* temp = (const unsigned char*) mWorkingPath.get();
    1:     if(temp == nsnull)
    1:         return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
    1:     // cannot use nsCString::RFindChar() due to 0x5c problem
    1:     PRInt32 offset = (PRInt32) (_mbsrchr(temp, '\\') - temp);
    1:     if (offset)
    1:     {
    1:         mWorkingPath.Truncate(offset+1);
    1:     }
    1:     mWorkingPath.Append(aLeafName);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetNativePath(nsACString &_retval)
    1: {
    1:     _retval = mWorkingPath;
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: // get any single extended attribute for the current file or directory
    1: 
    1: nsresult
    1: nsLocalFile::GetEA(const char *eaName, PFEA2LIST pfea2list)
    1: {
    1:     // ensure we have an out-buffer whose length is specified
    1:     if (!pfea2list || !pfea2list->cbList)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // the gea2list's name field is only 1 byte long;
    1:     // this expands its allocation to hold a 33 byte name
    1:     union {
    1:         GEA2LIST    gea2list;
    1:         char        dummy[sizeof(GEA2LIST)+32];
    1:     };
    1:     EAOP2       eaop2;
    1: 
    1:     eaop2.fpFEA2List = pfea2list;
    1:     eaop2.fpGEA2List = &gea2list;
    1: 
    1:     // fill in the request structure
    1:     dummy[sizeof(GEA2LIST)+31] = 0;
    1:     gea2list.list[0].oNextEntryOffset = 0;
    1:     strcpy(gea2list.list[0].szName, eaName);
    1:     gea2list.list[0].cbName = strlen(gea2list.list[0].szName);
    1:     gea2list.cbList = sizeof(GEA2LIST) + gea2list.list[0].cbName;
    1: 
    1:     // see what we get - this will succeed even if the EA doesn't exist
    1:     APIRET rc = DosQueryPathInfo(mWorkingPath.get(), FIL_QUERYEASFROMLIST,
    1:                                  &eaop2, sizeof(eaop2));
    1:     if (rc)
    1:         return ConvertOS2Error(rc);
    1: 
    1:     // if the data length is zero, requested EA doesn't exist
    1:     if (!pfea2list->list[0].cbValue)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: // return an array of file types or null if there are none
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetFileTypes(nsIArray **_retval)
    1: {
    1:     NS_ENSURE_ARG(_retval);
    1:     *_retval = 0;
    1: 
    1:     // fetch the .TYPE ea & prepare for enumeration
    1:     TypeEaEnumerator typeEnum;
    1:     nsresult rv = typeEnum.Init(this);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // create an array that's scriptable
    1:     nsCOMPtr<nsIMutableArray> mutArray =
    1:         do_CreateInstance(NS_ARRAY_CONTRACTID);
    1:     NS_ENSURE_STATE(mutArray);
    1: 
    1:     PRInt32  cnt;
    1:     PRUint32 lth;
    1:     char *   ptr;
    1: 
    1:     // get each file type, convert to a CString, then add to the array
    1:     for (cnt=0, ptr=typeEnum.GetNext(&lth); ptr; ptr=typeEnum.GetNext(&lth)) {
    1:         nsCOMPtr<nsISupportsCString> typeString(
    1:                     do_CreateInstance(NS_SUPPORTS_CSTRING_CONTRACTID, &rv));
    1:         if (NS_SUCCEEDED(rv)) {
    1:             nsCAutoString temp;
    1:             temp.Assign(ptr, lth);
    1:             typeString->SetData(temp);
80486:             mutArray->AppendElement(typeString, false);
    1:             cnt++;
    1:         }
    1:     }
    1: 
    1:     // if the array has any contents, addref & return it
    1:     if (cnt) {
    1:         *_retval = mutArray;
    1:         NS_ADDREF(*_retval);
    1:         rv = NS_OK;
    1:     }
    1:     else
    1:         rv = NS_ERROR_FAILURE;
    1: 
    1:     return rv;
    1: }
    1: 
    1: 
    1: // see if the file is of the requested type
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsFileType(const nsACString& fileType, bool *_retval)
    1: {
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1: 
    1:     // fetch the .TYPE ea & prepare for enumeration
    1:     TypeEaEnumerator typeEnum;
    1:     nsresult rv = typeEnum.Init(this);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRUint32 lth;
    1:     char *   ptr;
    1: 
    1:     // compare each type to the request;  if there's a match, exit
    1:     for (ptr = typeEnum.GetNext(&lth); ptr; ptr = typeEnum.GetNext(&lth))
    1:         if (fileType.EqualsASCII(ptr, lth)) {
80486:             *_retval = true;
    1:             break;
    1:         }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: // this struct combines an FEA2LIST, an FEA2, plus additional fields
    1: // needed to write a .TYPE EA in the correct EAT_MVMT format
    1: #pragma pack(1)
    1:     typedef struct _TYPEEA {
    1:         struct {
    1:             ULONG   ulcbList;
    1:             ULONG   uloNextEntryOffset;
    1:             BYTE    bfEA;
    1:             BYTE    bcbName;
    1:             USHORT  uscbValue;
    1:             char    chszName[sizeof(".TYPE")];
    1:         } hdr;
    1:         struct {
    1:             USHORT  usEAType;
    1:             USHORT  usCodePage;
    1:             USHORT  usNumEntries;
    1:             USHORT  usDataType;
    1:             USHORT  usDataLth;
    1:         } info;
    1:         char    data[1];
    1:     } TYPEEA;
    1: 
    1:     typedef struct _TYPEEA2 {
    1:         USHORT  usDataType;
    1:         USHORT  usDataLth;
    1:     } TYPEEA2;
    1: #pragma pack()
    1: 
    1: // writes one or more .TYPE extended attributes taken
    1: // from a comma-delimited string
    1: NS_IMETHODIMP
    1: nsLocalFile::SetFileTypes(const nsACString& fileTypes)
    1: {
    1:     if (fileTypes.IsEmpty())
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     PRUint32 cnt = CountCharInReadable(fileTypes, ',');
    1:     PRUint32 lth = fileTypes.Length() - cnt + (cnt * sizeof(TYPEEA2));
    1:     PRUint32 size = sizeof(TYPEEA) + lth;
    1: 
    1:     char *pBuf = (char*)NS_Alloc(size);
    1:     if (!pBuf)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     TYPEEA *pEA = (TYPEEA *)pBuf;
    1: 
    1:     // the buffer has an extra byte due to TYPEEA.data[1]
    1:     pEA->hdr.ulcbList = size - 1;
    1:     pEA->hdr.uloNextEntryOffset = 0;
    1:     pEA->hdr.bfEA = 0;
    1:     pEA->hdr.bcbName = sizeof(".TYPE") - 1;
    1:     pEA->hdr.uscbValue = sizeof(pEA->info) + lth;
    1:     strcpy(pEA->hdr.chszName, ".TYPE");
    1: 
    1:     pEA->info.usEAType = EAT_MVMT;
    1:     pEA->info.usCodePage = 0;
    1:     pEA->info.usNumEntries = ++cnt;
    1: 
    1:     nsACString::const_iterator begin, end, delim;
    1:     fileTypes.BeginReading(begin);
    1:     fileTypes.EndReading(end);
    1:     delim = begin;
    1: 
    1:     // fill in type & length, copy the current type name (which
    1:     // is not zero-terminated), then advance the ptr so the next
    1:     // iteration can reuse the trailing members of the structure
    1:     do {
    1:         FindCharInReadable( ',', delim, end);
    1:         lth = delim.get() - begin.get();
    1:         pEA->info.usDataType = EAT_ASCII;
    1:         pEA->info.usDataLth = lth;
    1:         memcpy(pEA->data, begin.get(), lth);
    1:         pEA = (TYPEEA *)((char*)pEA + lth + sizeof(TYPEEA2));
    1:         begin = ++delim;
    1:     } while (--cnt);
    1: 
    1:     // write the EA, then free the buffer
    1:     EAOP2 eaop2;
    1:     eaop2.fpGEA2List = 0;
    1:     eaop2.fpFEA2List = (PFEA2LIST)pBuf;
    1: 
    1:     int rc = DosSetPathInfo(mWorkingPath.get(), FIL_QUERYEASIZE,
    1:                             &eaop2, sizeof(eaop2), 0);
    1:     NS_Free(pBuf);
    1: 
    1:     if (rc)
    1:         return ConvertOS2Error(rc);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: // this struct combines an FEA2LIST, an FEA2, plus additional fields
    1: // needed to write a .SUBJECT EA in the correct EAT_ASCII format;
    1: #pragma pack(1)
    1:     typedef struct _SUBJEA {
    1:         struct {
    1:             ULONG   ulcbList;
    1:             ULONG   uloNextEntryOffset;
    1:             BYTE    bfEA;
    1:             BYTE    bcbName;
    1:             USHORT  uscbValue;
    1:             char    chszName[sizeof(".SUBJECT")];
    1:         } hdr;
    1:         struct {
    1:             USHORT  usEAType;
    1:             USHORT  usDataLth;
    1:         } info;
    1:         char    data[1];
    1:     } SUBJEA;
    1: #pragma pack()
    1: 
    1: // saves the file's source URI in its .SUBJECT extended attribute
    1: NS_IMETHODIMP
    1: nsLocalFile::SetFileSource(const nsACString& aURI)
    1: {
    1:     if (aURI.IsEmpty())
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     // this includes an extra character for the spec's trailing null
    1:     PRUint32 lth = sizeof(SUBJEA) + aURI.Length();
    1:     char *   pBuf = (char*)NS_Alloc(lth);
    1:     if (!pBuf)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     SUBJEA *pEA = (SUBJEA *)pBuf;
    1: 
    1:     // the trailing null doesn't get saved, so don't include it in the size
    1:     pEA->hdr.ulcbList = lth - 1;
    1:     pEA->hdr.uloNextEntryOffset = 0;
    1:     pEA->hdr.bfEA = 0;
    1:     pEA->hdr.bcbName = sizeof(".SUBJECT") - 1;
    1:     pEA->hdr.uscbValue = sizeof(pEA->info) + aURI.Length();
    1:     strcpy(pEA->hdr.chszName, ".SUBJECT");
    1:     pEA->info.usEAType = EAT_ASCII;
    1:     pEA->info.usDataLth = aURI.Length();
    1:     strcpy(pEA->data, PromiseFlatCString(aURI).get());
    1: 
    1:     // write the EA, then free the buffer
    1:     EAOP2 eaop2;
    1:     eaop2.fpGEA2List = 0;
    1:     eaop2.fpFEA2List = (PFEA2LIST)pEA;
    1: 
    1:     int rc = DosSetPathInfo(mWorkingPath.get(), FIL_QUERYEASIZE,
    1:                             &eaop2, sizeof(eaop2), 0);
    1:     NS_Free(pBuf);
    1: 
    1:     if (rc)
    1:         return ConvertOS2Error(rc);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsLocalFile::CopySingleFile(nsIFile *sourceFile, nsIFile *destParent,
79445:                             const nsACString &newName, bool move)
    1: {
    1:     nsresult rv;
    1:     nsCAutoString filePath;
    1: 
    1:     nsCAutoString destPath;
    1:     destParent->GetNativeTarget(destPath);
    1: 
    1:     destPath.Append("\\");
    1: 
    1:     if (newName.IsEmpty())
    1:     {
    1:         nsCAutoString aFileName;
    1:         sourceFile->GetNativeLeafName(aFileName);
    1:         destPath.Append(aFileName);
    1:     }
    1:     else
    1:     {
    1:         destPath.Append(newName);
    1:     }
    1: 
    1:     rv = sourceFile->GetNativePath(filePath);
    1: 
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     APIRET rc = NO_ERROR;
    1: 
    1:     if (move)
 3233:         rc = DosMove(filePath.get(), (PSZ)const_cast<char*>(destPath.get()));
    1: 
    1:     if (!move || rc == ERROR_NOT_SAME_DEVICE || rc == ERROR_ACCESS_DENIED)
    1:     {
    1:         // will get an error if the destination and source files aren't on
    1:         // the same drive.  "MoveFile()" on Windows will go ahead and move
    1:         // the file without error, so we need to do the same   IBM-AKR
    1: 
    1:         do {
 3233:             rc = DosCopy(filePath.get(), (PSZ)const_cast<char*>(destPath.get()), DCPY_EXISTING);
    1:             if (rc == ERROR_TOO_MANY_OPEN_FILES) {
    1:                 ULONG CurMaxFH = 0;
    1:                 LONG ReqCount = 20;
    1:                 APIRET rc2;
    1:                 rc2 = DosSetRelMaxFH(&ReqCount, &CurMaxFH);
    1:                 if (rc2 != NO_ERROR)
    1:                     break;
    1:             }
    1:         } while (rc == ERROR_TOO_MANY_OPEN_FILES);
    1: 
    1:         // WSOD2 HACK - NETWORK_ACCESS_DENIED
    1:         if (rc == 65)
    1:         {
    1:             CHAR         achProgram[CCHMAXPATH];  // buffer for program name, parameters
    1:             RESULTCODES  rescResults;             // buffer for results of dosexecpgm
    1: 
    1:             strcpy(achProgram, "CMD.EXE  /C ");
    1:             strcat(achProgram, """COPY ");
    1:             strcat(achProgram, filePath.get());
    1:             strcat(achProgram, " ");
 3233:             strcat(achProgram, (PSZ)const_cast<char*>(destPath.get()));
    1:             strcat(achProgram, """");
    1:             achProgram[strlen(achProgram) + 1] = '\0';
    1:             achProgram[7] = '\0';
    1:             DosExecPgm(NULL, 0,
    1:                        EXEC_SYNC, achProgram, (PSZ)NULL,
    1:                        &rescResults, achProgram);
    1:             rc = 0; // Assume it worked
    1: 
    1:         } // rc == 65
    1: 
    1:         // moving the file is supposed to act like a rename, so delete the
    1:         // original file if we got this far without error
    1:         if(move && (rc == NO_ERROR))
    1:             DosDelete( filePath.get());
    1: 
    1:     } // !move or ERROR
    1: 
    1:     if (rc)
    1:         rv = ConvertOS2Error(rc);
    1: 
    1:     return rv;
    1: }
    1: 
    1: 
    1: nsresult
79445: nsLocalFile::CopyMove(nsIFile *aParentDir, const nsACString &newName, bool move)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     nsCOMPtr<nsIFile> newParentDir = aParentDir;
    1: 
    1:     nsresult rv  = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (!newParentDir)
    1:     {
    1:         // no parent was specified.  We must rename.
    1: 
    1:         if (newName.IsEmpty())
    1:             return NS_ERROR_INVALID_ARG;
    1: 
    1:         rv = GetParent(getter_AddRefs(newParentDir));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     if (!newParentDir)
    1:         return NS_ERROR_FILE_DESTINATION_NOT_DIR;
    1: 
    1:     // make sure it exists and is a directory.  Create it if not there.
79445:     bool exists;
    1:     newParentDir->Exists(&exists);
    1:     if (!exists)
    1:     {
    1:         rv = newParentDir->Create(DIRECTORY_TYPE, 0644);  // TODO, what permissions should we use
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1:     else
    1:     {
79445:         bool isDir;
    1:         newParentDir->IsDirectory(&isDir);
37970:         if (!isDir)
    1:         {
    1:             return NS_ERROR_FILE_DESTINATION_NOT_DIR;
    1:         }
    1:     }
    1: 
    1:     // Try different ways to move/copy files/directories
79445:     bool done = false;
79445:     bool isDir;
    1:     IsDirectory(&isDir);
    1: 
    1:     // Try to move the file or directory, or try to copy a single file
    1:     if (move || !isDir)
    1:     {
    1:         // when moving things, first try to just MoveFile it,
    1:         // even if it is a directory
    1:         rv = CopySingleFile(this, newParentDir, newName, move);
    1:         done = NS_SUCCEEDED(rv);
    1:         // If we are moving a directory and that fails, fallback on directory
    1:         // enumeration.  See bug 231300 for details.
    1:         if (!done && !(move && isDir))
    1:             return rv;
    1:     }
    1: 
    1:     // Not able to copy or move directly, so enumerate it
    1:     if (!done)
    1:     {
    1:         // create a new target destination in the new parentDir;
    1:         nsCOMPtr<nsIFile> target;
    1:         rv = newParentDir->Clone(getter_AddRefs(target));
    1: 
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsCAutoString allocatedNewName;
    1:         if (newName.IsEmpty())
    1:         {
    1:             GetNativeLeafName(allocatedNewName);
    1:         }
    1:         else
    1:         {
    1:             allocatedNewName = newName;
    1:         }
    1: 
    1:         rv = target->AppendNative(allocatedNewName);
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         allocatedNewName.Truncate();
    1: 
    1:         // check if the destination directory already exists
    1:         target->Exists(&exists);
    1:         if (!exists)
    1:         {
    1:             // if the destination directory cannot be created, return an error
    1:             rv = target->Create(DIRECTORY_TYPE, 0644);  // TODO, what permissions should we use
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
    1:         else
    1:         {
    1:             // check if the destination directory is writable and empty
79445:             bool isWritable;
    1: 
    1:             target->IsWritable(&isWritable);
    1:             if (!isWritable)
    1:                 return NS_ERROR_FILE_ACCESS_DENIED;
    1: 
    1:             nsCOMPtr<nsISimpleEnumerator> targetIterator;
    1:             rv = target->GetDirectoryEntries(getter_AddRefs(targetIterator));
80584:             if (NS_FAILED(rv))
80584:                 return rv;
    1: 
79445:             bool more;
    1:             targetIterator->HasMoreElements(&more);
    1:             // return error if target directory is not empty
    1:             if (more)
    1:                 return NS_ERROR_FILE_DIR_NOT_EMPTY;
    1:         }
    1: 
    1:         nsDirEnumerator dirEnum;
    1: 
    1:         rv = dirEnum.Init(this);
    1:         if (NS_FAILED(rv)) {
    1:             NS_WARNING("dirEnum initialization failed");
    1:             return rv;
    1:         }
    1: 
79445:         bool more;
    1:         while (NS_SUCCEEDED(dirEnum.HasMoreElements(&more)) && more)
    1:         {
    1:             nsCOMPtr<nsISupports> item;
    1:             nsCOMPtr<nsIFile> file;
    1:             dirEnum.GetNext(getter_AddRefs(item));
    1:             file = do_QueryInterface(item);
    1:             if (file)
    1:             {
    1:                 if (move)
    1:                 {
    1:                     rv = file->MoveToNative(target, EmptyCString());
    1:                     NS_ENSURE_SUCCESS(rv,rv);
    1:                 }
    1:                 else
    1:                 {
    1:                     rv = file->CopyToNative(target, EmptyCString());
    1:                     NS_ENSURE_SUCCESS(rv,rv);
    1:                 }
    1:             }
    1:         }
    1:         // we've finished moving all the children of this directory
    1:         // in the new directory.  so now delete the directory
    1:         // note, we don't need to do a recursive delete.
    1:         // MoveTo() is recursive.  At this point,
    1:         // we've already moved the children of the current folder
    1:         // to the new location.  nothing should be left in the folder.
    1:         if (move)
    1:         {
80486:           rv = Remove(false); // recursive
    1:           NS_ENSURE_SUCCESS(rv,rv);
    1:         }
    1:     }
    1: 
    1: 
    1:     // If we moved, we want to adjust this.
    1:     if (move)
    1:     {
    1:         MakeDirty();
    1: 
    1:         nsCAutoString newParentPath;
    1:         newParentDir->GetNativePath(newParentPath);
    1: 
    1:         if (newParentPath.IsEmpty())
    1:             return NS_ERROR_FAILURE;
    1: 
    1:         if (newName.IsEmpty())
    1:         {
    1:             nsCAutoString aFileName;
    1:             GetNativeLeafName(aFileName);
    1: 
    1:             InitWithNativePath(newParentPath);
    1:             AppendNative(aFileName);
    1:         }
    1:         else
    1:         {
    1:             InitWithNativePath(newParentPath);
    1:             AppendNative(newName);
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::CopyToNative(nsIFile *newParentDir, const nsACString &newName)
    1: {
80486:     return CopyMove(newParentDir, newName, false);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::CopyToFollowingLinksNative(nsIFile *newParentDir, const nsACString &newName)
    1: {
80486:     return CopyMove(newParentDir, newName, false);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::MoveToNative(nsIFile *newParentDir, const nsACString &newName)
    1: {
80486:     return CopyMove(newParentDir, newName, true);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Load(PRLibrary * *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
79445:     bool isFile;
    1:     nsresult rv = IsFile(&isFile);
    1: 
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (!isFile)
    1:         return NS_ERROR_FILE_IS_DIRECTORY;
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
80486:     nsTraceRefcntImpl::SetActivityIsLegal(false);
    1: #endif
    1: 
    1:     *_retval =  PR_LoadLibrary(mWorkingPath.get());
    1: 
    1: #ifdef NS_BUILD_REFCNT_LOGGING
80486:     nsTraceRefcntImpl::SetActivityIsLegal(true);
    1: #endif
    1: 
    1:     if (*_retval)
    1:         return NS_OK;
    1: 
    1:     return NS_ERROR_NULL_POINTER;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::Remove(bool recursive)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
79445:     bool isDir = false;
    1: 
    1:     nsresult rv = IsDirectory(&isDir);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (isDir)
    1:     {
    1:         if (recursive)
    1:         {
    1:             nsDirEnumerator dirEnum;
    1: 
    1:             rv = dirEnum.Init(this);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1: 
79445:             bool more;
    1:             while (NS_SUCCEEDED(dirEnum.HasMoreElements(&more)) && more)
    1:             {
    1:                 nsCOMPtr<nsISupports> item;
    1:                 dirEnum.GetNext(getter_AddRefs(item));
    1:                 nsCOMPtr<nsIFile> file = do_QueryInterface(item);
    1:                 if (file)
    1:                     file->Remove(recursive);
    1:             }
    1:         }
    1:         rv = rmdir(mWorkingPath.get());
    1:     }
    1:     else
    1:     {
    1:         rv = remove(mWorkingPath.get());
    1:     }
    1: 
    1:     // fixup error code if necessary...
    1:     if (rv == (nsresult)-1)
    1:         rv = NSRESULT_FOR_ERRNO();
    1: 
    1:     MakeDirty();
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetLastModifiedTime(PRInt64 *aLastModifiedTime)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(aLastModifiedTime);
    1: 
    1:     *aLastModifiedTime = 0;
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // microseconds -> milliseconds
    1:     PRInt64 usecPerMsec;
    1:     LL_I2L(usecPerMsec, PR_USEC_PER_MSEC);
    1:     LL_DIV(*aLastModifiedTime, mFileInfo64.modifyTime, usecPerMsec);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetLastModifiedTimeOfLink(PRInt64 *aLastModifiedTime)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetLastModifiedTime(PRInt64 aLastModifiedTime)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     return nsLocalFile::SetModDate(aLastModifiedTime);
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetLastModifiedTimeOfLink(PRInt64 aLastModifiedTime)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: nsresult
    1: nsLocalFile::SetModDate(PRInt64 aLastModifiedTime)
    1: {
    1:     nsresult rv = Stat();
    1: 
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRExplodedTime pret;
    1:     FILESTATUS3 pathInfo;
    1: 
    1:     // Level 1 info
    1:     rv = DosQueryPathInfo(mWorkingPath.get(), FIL_STANDARD,
    1:                           &pathInfo, sizeof(pathInfo));
    1: 
    1:     if (NS_FAILED(rv))
    1:     {
    1:        rv = ConvertOS2Error(rv);
    1:        return rv;
    1:     }
    1: 
    1:     // PR_ExplodeTime expects usecs...
    1:     PR_ExplodeTime(aLastModifiedTime * PR_USEC_PER_MSEC, PR_LocalTimeParameters, &pret);
    1: 
    1:     // fdateLastWrite.year is based off of 1980
    1:     if (pret.tm_year >= 1980)
    1:         pathInfo.fdateLastWrite.year    = pret.tm_year-1980;
    1:     else
    1:         pathInfo.fdateLastWrite.year    = pret.tm_year;
    1: 
    1:     // Convert start offset -- OS/2: Jan=1; NSPR: Jan=0
    1:     pathInfo.fdateLastWrite.month       = pret.tm_month + 1;
    1:     pathInfo.fdateLastWrite.day         = pret.tm_mday;
    1:     pathInfo.ftimeLastWrite.hours       = pret.tm_hour;
    1:     pathInfo.ftimeLastWrite.minutes     = pret.tm_min;
    1:     pathInfo.ftimeLastWrite.twosecs     = pret.tm_sec / 2;
    1: 
    1:     rv = DosSetPathInfo(mWorkingPath.get(), FIL_STANDARD,
    1:                         &pathInfo, sizeof(pathInfo), 0UL);
    1: 
    1:     if (NS_FAILED(rv))
    1:        return rv;
    1: 
    1:     MakeDirty();
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetPermissions(PRUint32 *aPermissions)
    1: {
    1:     NS_ENSURE_ARG(aPermissions);
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
79445:     bool isWritable, isExecutable;
    1:     IsWritable(&isWritable);
    1:     IsExecutable(&isExecutable);
    1: 
    1:     *aPermissions = PR_IRUSR|PR_IRGRP|PR_IROTH;         // all read
    1:     if (isWritable)
    1:         *aPermissions |= PR_IWUSR|PR_IWGRP|PR_IWOTH;    // all write
    1:     if (isExecutable)
    1:         *aPermissions |= PR_IXUSR|PR_IXGRP|PR_IXOTH;    // all execute
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetPermissionsOfLink(PRUint32 *aPermissionsOfLink)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: // the only Unix-style permission OS/2 knows is whether a file is
    1: // writable;  as a matter of policy, a browser shouldn't be able
    1: // to change any of the other DOS-style attributes;  to enforce
    1: // this, we use DosSetPathInfo() rather than chmod()
    1: NS_IMETHODIMP
    1: nsLocalFile::SetPermissions(PRUint32 aPermissions)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     APIRET rc;
    1:     FILESTATUS3 pathInfo;
    1: 
    1:     // Level 1 info
    1:     rc = DosQueryPathInfo(mWorkingPath.get(), FIL_STANDARD,
    1:                           &pathInfo, sizeof(pathInfo));
    1: 
    1:     if (rc != NO_ERROR)
    1:        return ConvertOS2Error(rc);
    1: 
    1:     ULONG attr = 0;
    1:     if (!(aPermissions & (PR_IWUSR|PR_IWGRP|PR_IWOTH)))
    1:         attr = FILE_READONLY;
    1: 
    1:     if (attr == (pathInfo.attrFile & FILE_READONLY))
    1:         return NS_OK;
    1: 
    1:     pathInfo.attrFile ^= FILE_READONLY;
    1: 
    1:     rc = DosSetPathInfo(mWorkingPath.get(), FIL_STANDARD,
    1:                         &pathInfo, sizeof(pathInfo), 0UL);
    1: 
    1:     if (rc != NO_ERROR)
    1:        return ConvertOS2Error(rc);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetPermissionsOfLink(PRUint32 aPermissions)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetFileSize(PRInt64 *aFileSize)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(aFileSize);
    1:     *aFileSize = 0;
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *aFileSize = mFileInfo64.size;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetFileSizeOfLink(PRInt64 *aFileSize)
    1: {
    1:     return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetFileSize(PRInt64 aFileSize)
    1: {
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     APIRET rc;
    1:     HFILE hFile;
    1:     ULONG actionTaken;
    1: 
    1:     rc = DosOpen(mWorkingPath.get(),
    1:                  &hFile,
    1:                  &actionTaken,
    1:                  0,
    1:                  FILE_NORMAL,
    1:                  OPEN_ACTION_FAIL_IF_NEW | OPEN_ACTION_OPEN_IF_EXISTS,
    1:                  OPEN_SHARE_DENYREADWRITE | OPEN_ACCESS_READWRITE,
    1:                  NULL);
    1: 
    1:     if (rc != NO_ERROR)
    1:     {
    1:         MakeDirty();
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // Seek to new, desired end of file
    1:     PRInt32 hi, lo;
    1:     myLL_L2II(aFileSize, &hi, &lo );
    1: 
    1:     rc = DosSetFileSize(hFile, lo);
    1:     DosClose(hFile);
    1:     MakeDirty();
    1: 
    1:     if (rc != NO_ERROR)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetDiskSpaceAvailable(PRInt64 *aDiskSpaceAvailable)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(aDiskSpaceAvailable);
    1:     *aDiskSpaceAvailable = 0;
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     ULONG ulDriveNo = toupper(mWorkingPath.CharAt(0)) + 1 - 'A';
    1:     FSALLOCATE fsAllocate;
    1:     APIRET rc = DosQueryFSInfo(ulDriveNo,
    1:                                FSIL_ALLOC,
    1:                                &fsAllocate,
    1:                                sizeof(fsAllocate));
    1: 
    1:     if (rc != NO_ERROR)
    1:        return NS_ERROR_FAILURE;
    1: 
    1:     *aDiskSpaceAvailable = fsAllocate.cUnitAvail;
    1:     *aDiskSpaceAvailable *= fsAllocate.cSectorUnit;
    1:     *aDiskSpaceAvailable *= fsAllocate.cbSector;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetParent(nsIFile * *aParent)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG_POINTER(aParent);
    1: 
    1:     nsCAutoString parentPath(mWorkingPath);
    1: 
    1:     // cannot use nsCString::RFindChar() due to 0x5c problem
    1:     PRInt32 offset = (PRInt32) (_mbsrchr((const unsigned char *) parentPath.get(), '\\')
    1:                      - (const unsigned char *) parentPath.get());
    1:     // adding this offset check that was removed in bug 241708 fixes mail
    1:     // directories that aren't relative to/underneath the profile dir.
    1:     // e.g., on a different drive. Before you remove them, please make
    1:     // sure local mail directories that aren't underneath the profile dir work.
    1:     if (offset < 0)
    1:       return NS_ERROR_FILE_UNRECOGNIZED_PATH;
    1: 
    1:     if (offset == 1 && parentPath[0] == '\\') {
    1:         aParent = nsnull;
    1:         return NS_OK;
    1:     }
    1:     if (offset > 0)
    1:         parentPath.Truncate(offset);
    1:     else
    1:         parentPath.AssignLiteral("\\\\.");
    1: 
    1:     nsCOMPtr<nsILocalFile> localFile;
80486:     nsresult rv = NS_NewNativeLocalFile(parentPath, false, getter_AddRefs(localFile));
    1: 
    1:     if(NS_SUCCEEDED(rv) && localFile)
    1:     {
    1:         return CallQueryInterface(localFile, aParent);
    1:     }
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::Exists(bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1: 
    1:     MakeDirty();
    1:     nsresult rv = Stat();
    1: 
    1:     *_retval = NS_SUCCEEDED(rv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsWritable(bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     APIRET rc;
    1:     FILESTATUS3 pathInfo;
    1: 
    1:     // Level 1 info
    1:     rc = DosQueryPathInfo(mWorkingPath.get(), FIL_STANDARD,
    1:                           &pathInfo, sizeof(pathInfo));
    1: 
    1:     if (rc != NO_ERROR)
    1:     {
    1:        rc = ConvertOS2Error(rc);
    1:        return rc;
    1:     }
    1: 
    1:     // on OS/2, unlike Windows, directories on writable media
    1:     // can not be assigned a readonly attribute
    1:     *_retval = !((pathInfo.attrFile & FILE_READONLY) != 0);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsReadable(bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
80486:     *_retval = true;
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsExecutable(bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // no need to bother if this isn't a file
79445:     bool isFile;
    1:     rv = IsFile(&isFile);
    1:     if (NS_FAILED(rv) || !isFile)
    1:         return rv;
    1: 
    1:     nsCAutoString path;
    1:     GetNativeTarget(path);
    1: 
    1:     // get the filename, including the leading backslash
    1:     const char* leaf = (const char*) _mbsrchr((const unsigned char*)path.get(), '\\');
    1:     if (!leaf)
    1:         return NS_OK;
    1: 
    1:     // eliminate trailing dots & spaces in a DBCS-aware manner
    1:     // XXX shouldn't this have been done when the path was set?
    1: 
    1:     char*   pathEnd = WinPrevChar(0, 0, 0, leaf, strchr(leaf, 0));
    1:     while (pathEnd > leaf)
    1:     {
    1:         if (*pathEnd != ' ' && *pathEnd != '.')
    1:             break;
    1:         *pathEnd = 0;
    1:         pathEnd = WinPrevChar(0, 0, 0, leaf, pathEnd);
    1:     }
    1: 
    1:     if (pathEnd == leaf)
    1:         return NS_OK;
    1: 
 7182:     // get the extension, including the dot
 7182:     char* ext = (char*) _mbsrchr((const unsigned char*)leaf, '.');
 7182:     if (!ext)
 7182:         return NS_OK;
 7182: 
 7182:     if (stricmp(ext, ".exe") == 0 ||
 7182:         stricmp(ext, ".cmd") == 0 ||
 7182:         stricmp(ext, ".com") == 0 ||
 7182:         stricmp(ext, ".bat") == 0)
80486:         *_retval = true;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsDirectory(bool *_retval)
    1: {
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *_retval = (mFileInfo64.type == PR_FILE_DIRECTORY);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsFile(bool *_retval)
    1: {
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     *_retval = (mFileInfo64.type == PR_FILE_FILE);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsHidden(bool *_retval)
    1: {
    1:     NS_ENSURE_ARG(_retval);
80486:     *_retval = false;
    1: 
    1:     nsresult rv = Stat();
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     APIRET rc;
    1:     FILESTATUS3 pathInfo;
    1: 
    1:     // Level 1 info
    1:     rc = DosQueryPathInfo(mWorkingPath.get(), FIL_STANDARD,
    1:                           &pathInfo, sizeof(pathInfo));
    1: 
    1:     if (rc != NO_ERROR)
    1:     {
    1:        rc = ConvertOS2Error(rc);
    1:        return rc;
    1:     }
    1: 
    1:     *_retval = ((pathInfo.attrFile & FILE_HIDDEN) != 0);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsSymlink(bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     NS_ENSURE_ARG_POINTER(_retval);
    1: 
    1:     // No Symlinks on OS/2
80486:     *_retval = false;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::IsSpecial(bool *_retval)
    1: {
    1:     NS_ENSURE_ARG(_retval);
    1: 
    1:     // when implemented, IsSpecial will be used for WPS objects
80486:     *_retval = false;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::Equals(nsIFile *inFile, bool *_retval)
    1: {
    1:     NS_ENSURE_ARG(inFile);
    1:     NS_ENSURE_ARG(_retval);
    1: 
    1:     nsCAutoString inFilePath;
    1:     inFile->GetNativePath(inFilePath);
    1: 
    1:     *_retval = inFilePath.Equals(mWorkingPath);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::Contains(nsIFile *inFile, bool recur, bool *_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
80486:     *_retval = false;
    1: 
    1:     nsCAutoString myFilePath;
    1:     if ( NS_FAILED(GetNativeTarget(myFilePath)))
    1:         GetNativePath(myFilePath);
    1: 
    1:     PRInt32 myFilePathLen = myFilePath.Length();
    1: 
    1:     nsCAutoString inFilePath;
    1:     if ( NS_FAILED(inFile->GetNativeTarget(inFilePath)))
    1:         inFile->GetNativePath(inFilePath);
    1: 
    1:     if ( strnicmp( myFilePath.get(), inFilePath.get(), myFilePathLen) == 0)
    1:     {
    1:         // now make sure that the |inFile|'s path has a trailing
    1:         // separator.
    1: 
    1:         if (inFilePath[myFilePathLen] == '\\')
    1:         {
80486:             *_retval = true;
    1:         }
    1: 
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetNativeTarget(nsACString &_retval)
    1: {
    1:     // Check we are correctly initialized.
    1:     CHECK_mWorkingPath();
    1: 
    1:     _retval = mWorkingPath;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::GetFollowLinks(bool *aFollowLinks)
    1: {
    1:     NS_ENSURE_ARG(aFollowLinks);
80486:     *aFollowLinks = false;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::SetFollowLinks(bool aFollowLinks)
    1: {
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetDirectoryEntries(nsISimpleEnumerator * *entries)
    1: {
    1:     NS_ENSURE_ARG(entries);
    1:     nsresult rv;
    1:     *entries = nsnull;
    1: 
    1:     if (mWorkingPath.EqualsLiteral("\\\\.")) {
    1:         nsDriveEnumerator *drives = new nsDriveEnumerator;
    1:         if (!drives)
    1:             return NS_ERROR_OUT_OF_MEMORY;
    1:         NS_ADDREF(drives);
    1:         rv = drives->Init();
    1:         if (NS_FAILED(rv)) {
    1:             NS_RELEASE(drives);
    1:             return rv;
    1:         }
    1:         *entries = drives;
    1:         return NS_OK;
    1:     }
    1: 
79445:     bool isDir;
    1:     rv = IsDirectory(&isDir);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     if (!isDir)
    1:         return NS_ERROR_FILE_NOT_DIRECTORY;
    1: 
    1:     nsDirEnumerator* dirEnum = new nsDirEnumerator();
    1:     if (dirEnum == nsnull)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(dirEnum);
    1:     rv = dirEnum->Init(this);
    1:     if (NS_FAILED(rv))
    1:     {
    1:         NS_RELEASE(dirEnum);
    1:         return rv;
    1:     }
    1: 
    1:     *entries = dirEnum;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetPersistentDescriptor(nsACString &aPersistentDescriptor)
    1: {
    1:     return GetNativePath(aPersistentDescriptor);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetPersistentDescriptor(const nsACString &aPersistentDescriptor)
    1: {
    1:     return InitWithNativePath(aPersistentDescriptor);
    1: }
    1: 
    1: #ifndef OPEN_DEFAULT
    1: #define OPEN_DEFAULT       0
    1: #define OPEN_CONTENTS      1
    1: #endif
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Reveal()
    1: {
79445:     bool isDirectory = false;
    1:     nsCAutoString path;
    1: 
    1:     IsDirectory(&isDirectory);
    1:     if (isDirectory)
    1:     {
    1:         GetNativePath(path);
    1:     }
    1:     else
    1:     {
    1:         nsCOMPtr<nsIFile> parent;
    1:         GetParent(getter_AddRefs(parent));
    1:         if (parent)
    1:             parent->GetNativePath(path);
    1:     }
    1: 
    1:     HOBJECT hobject = WinQueryObject(path.get());
    1:     WinSetFocus(HWND_DESKTOP, HWND_DESKTOP);
    1:     WinOpenObject(hobject, OPEN_DEFAULT, TRUE);
    1: 
    1:     // we don't care if it succeeded or failed.
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Launch()
    1: {
    1:   HOBJECT hobject = WinQueryObject(mWorkingPath.get());
    1:   WinSetFocus(HWND_DESKTOP, HWND_DESKTOP);
    1:   WinOpenObject(hobject, OPEN_DEFAULT, TRUE);
    1: 
    1:   // we don't care if it succeeded or failed.
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
79445: NS_NewNativeLocalFile(const nsACString &path, bool followLinks, nsILocalFile* *result)
    1: {
    1:     nsLocalFile* file = new nsLocalFile();
    1:     if (file == nsnull)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     NS_ADDREF(file);
    1: 
    1:     if (!path.IsEmpty()) {
    1:         nsresult rv = file->InitWithNativePath(path);
    1:         if (NS_FAILED(rv)) {
    1:             NS_RELEASE(file);
    1:             return rv;
    1:         }
    1:     }
    1: 
    1:     *result = file;
    1:     return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // UCS2 interface
    1: //-----------------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::InitWithPath(const nsAString &filePath)
    1: {
    1:     if (filePath.IsEmpty())
    1:         return InitWithNativePath(EmptyCString());
    1: 
    1:     nsCAutoString tmp;
    1:     nsresult rv = NS_CopyUnicodeToNative(filePath, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return InitWithNativePath(tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::Append(const nsAString &node)
    1: {
    1:     if (node.IsEmpty())
    1:         return NS_OK;
    1: 
    1:     nsCAutoString tmp;
    1:     nsresult rv = NS_CopyUnicodeToNative(node, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return AppendNative(tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::AppendRelativePath(const nsAString &node)
    1: {
    1:     if (node.IsEmpty())
    1:         return NS_OK;
    1: 
    1:     nsCAutoString tmp;
    1:     nsresult rv = NS_CopyUnicodeToNative(node, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return AppendRelativeNativePath(tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetLeafName(nsAString &aLeafName)
    1: {
    1:     nsCAutoString tmp;
    1:     nsresult rv = GetNativeLeafName(tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         rv = NS_CopyNativeToUnicode(tmp, aLeafName);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::SetLeafName(const nsAString &aLeafName)
    1: {
    1:     if (aLeafName.IsEmpty())
    1:         return SetNativeLeafName(EmptyCString());
    1: 
    1:     nsCAutoString tmp;
    1:     nsresult rv = NS_CopyUnicodeToNative(aLeafName, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return SetNativeLeafName(tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetPath(nsAString &_retval)
    1: {
    1:     return NS_CopyNativeToUnicode(mWorkingPath, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::CopyTo(nsIFile *newParentDir, const nsAString &newName)
    1: {
    1:     if (newName.IsEmpty())
    1:         return CopyToNative(newParentDir, EmptyCString());
    1: 
    1:     nsCAutoString tmp;
    1:     nsresult rv = NS_CopyUnicodeToNative(newName, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return CopyToNative(newParentDir, tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::CopyToFollowingLinks(nsIFile *newParentDir, const nsAString &newName)
    1: {
    1:     if (newName.IsEmpty())
    1:         return CopyToFollowingLinksNative(newParentDir, EmptyCString());
    1: 
    1:     nsCAutoString tmp;
    1:     nsresult rv = NS_CopyUnicodeToNative(newName, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return CopyToFollowingLinksNative(newParentDir, tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::MoveTo(nsIFile *newParentDir, const nsAString &newName)
    1: {
    1:     if (newName.IsEmpty())
    1:         return MoveToNative(newParentDir, EmptyCString());
    1: 
    1:     nsCAutoString tmp;
    1:     nsresult rv = NS_CopyUnicodeToNative(newName, tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         return MoveToNative(newParentDir, tmp);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetTarget(nsAString &_retval)
    1: {
    1:     nsCAutoString tmp;
    1:     nsresult rv = GetNativeTarget(tmp);
    1:     if (NS_SUCCEEDED(rv))
    1:         rv = NS_CopyNativeToUnicode(tmp, _retval);
    1: 
    1:     return rv;
    1: }
    1: 
    1: // nsIHashable
    1: 
    1: NS_IMETHODIMP
79445: nsLocalFile::Equals(nsIHashable* aOther, bool *aResult)
    1: {
    1:     nsCOMPtr<nsIFile> otherfile(do_QueryInterface(aOther));
    1:     if (!otherfile) {
80486:         *aResult = false;
    1:         return NS_OK;
    1:     }
    1: 
    1:     return Equals(otherfile, aResult);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsLocalFile::GetHashCode(PRUint32 *aResult)
    1: {
    1:     *aResult = nsCRT::HashCode(mWorkingPath.get());
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
79445: NS_NewLocalFile(const nsAString &path, bool followLinks, nsILocalFile* *result)
    1: {
    1:     nsCAutoString buf;
    1:     nsresult rv = NS_CopyUnicodeToNative(path, buf);
    1:     if (NS_FAILED(rv)) {
    1:         *result = nsnull;
    1:         return rv;
    1:     }
    1:     return NS_NewNativeLocalFile(buf, followLinks, result);
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: // nsLocalFile <static members>
    1: //-----------------------------------------------------------------------------
    1: 
    1: void
    1: nsLocalFile::GlobalInit()
    1: {
    1: }
    1: 
    1: void
    1: nsLocalFile::GlobalShutdown()
    1: {
    1: }
    1: 
    1: //-----------------------------------------------------------------------------
    1: 
