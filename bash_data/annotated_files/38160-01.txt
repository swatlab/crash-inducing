37311: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*-
37311:  * vim: sw=2 ts=2 et :
35835:  * ***** BEGIN LICENSE BLOCK *****
35835:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35835:  *
35835:  * The contents of this file are subject to the Mozilla Public License Version
35835:  * 1.1 (the "License"); you may not use this file except in compliance with
35835:  * the License. You may obtain a copy of the License at
35835:  * http://www.mozilla.org/MPL/
35835:  *
35835:  * Software distributed under the License is distributed on an "AS IS" basis,
35835:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35835:  * for the specific language governing rights and limitations under the
35835:  * License.
35835:  *
35835:  * The Original Code is Mozilla Plugin App.
35835:  *
35835:  * The Initial Developer of the Original Code is
35835:  *   Ben Turner <bent.mozilla@gmail.com>
35835:  * Portions created by the Initial Developer are Copyright (C) 2009
35835:  * the Initial Developer. All Rights Reserved.
35835:  *
35835:  * Contributor(s):
35835:  *
35835:  * Alternatively, the contents of this file may be used under the terms of
35835:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35835:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35835:  * in which case the provisions of the GPL or the LGPL are applicable instead
35835:  * of those above. If you wish to allow use of your version of this file only
35835:  * under the terms of either the GPL or the LGPL, and not to allow others to
35835:  * use your version of this file under the terms of the MPL, indicate your
35835:  * decision by deleting the provisions above and replace them with the notice
35835:  * and other provisions required by the GPL or the LGPL. If you do not delete
35835:  * the provisions above, a recipient may use your version of this file under
35835:  * the terms of any one of the MPL, the GPL or the LGPL.
35835:  *
35835:  * ***** END LICENSE BLOCK ***** */
35835: 
35925: #include "PluginScriptableObjectChild.h"
37311: #include "PluginScriptableObjectUtils.h"
35925: 
35925: using namespace mozilla::plugins;
35965: using mozilla::ipc::NPRemoteIdentifier;
35925: 
35965: // static
35965: NPObject*
35965: PluginScriptableObjectChild::ScriptableAllocate(NPP aInstance,
35965:                                                 NPClass* aClass)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aClass != GetClass()) {
37311:     NS_RUNTIMEABORT("Huh?! Wrong class!");
37311:   }
37307: 
37311:   return new ChildNPObject();
35965: }
35965: 
35965: // static
35965: void
35965: PluginScriptableObjectChild::ScriptableInvalidate(NPObject* aObject)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
35965:   if (object->invalidated) {
35965:     // This can happen more than once, and is just fine.
35965:     return;
35965:   }
35965: 
35965:   object->invalidated = true;
35965: }
35965: 
35965: // static
35965: void
35965: PluginScriptableObjectChild::ScriptableDeallocate(NPObject* aObject)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
37311:   PluginScriptableObjectChild* actor = object->parent;
37311:   if (actor) {
37311:     NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
37311:     actor->DropNPObject();
37311:   }
35965: 
37311:   delete object;
35965: }
35965: 
35965: // static
35965: bool
35965: PluginScriptableObjectChild::ScriptableHasMethod(NPObject* aObject,
35965:                                                  NPIdentifier aName)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
35965:   if (object->invalidated) {
35965:     NS_WARNING("Calling method on an invalidated object!");
35965:     return false;
35965:   }
35965: 
37311:   ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
35965:   NS_ASSERTION(actor, "This shouldn't ever be null!");
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35965: 
35965:   bool result;
37311:   actor->CallHasMethod((NPRemoteIdentifier)aName, &result);
35965: 
35965:   return result;
35965: }
35965: 
35965: // static
35965: bool
35965: PluginScriptableObjectChild::ScriptableInvoke(NPObject* aObject,
35965:                                               NPIdentifier aName,
35965:                                               const NPVariant* aArgs,
35965:                                               uint32_t aArgCount,
35965:                                               NPVariant* aResult)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
35965:   if (object->invalidated) {
35965:     NS_WARNING("Calling method on an invalidated object!");
35965:     return false;
35965:   }
35965: 
37311:   ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
35965:   NS_ASSERTION(actor, "This shouldn't ever be null!");
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35965: 
37311:   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
37311:   if (!args.IsOk()) {
37311:     NS_ERROR("Failed to convert arguments!");
35965:     return false;
35965:   }
35965: 
35965:   Variant remoteResult;
35965:   bool success;
37311:   actor->CallInvoke((NPRemoteIdentifier)aName, args, &remoteResult, &success);
35965: 
35965:   if (!success) {
35965:     return false;
35965:   }
35965: 
35965:   ConvertToVariant(remoteResult, *aResult);
35965:   return true;
35965: }
35965: 
35965: // static
35965: bool
35965: PluginScriptableObjectChild::ScriptableInvokeDefault(NPObject* aObject,
35965:                                                      const NPVariant* aArgs,
35965:                                                      uint32_t aArgCount,
35965:                                                      NPVariant* aResult)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
35965:   if (object->invalidated) {
35965:     NS_WARNING("Calling method on an invalidated object!");
35965:     return false;
35965:   }
35965: 
37311:   ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
35965:   NS_ASSERTION(actor, "This shouldn't ever be null!");
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35965: 
37311:   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
37311:   if (!args.IsOk()) {
37311:     NS_ERROR("Failed to convert arguments!");
35965:     return false;
35965:   }
35965: 
35965:   Variant remoteResult;
35965:   bool success;
37311:   actor->CallInvokeDefault(args, &remoteResult, &success);
35965: 
35965:   if (!success) {
35965:     return false;
35965:   }
35965: 
35965:   ConvertToVariant(remoteResult, *aResult);
35965:   return true;
35965: }
35965: 
35965: // static
35965: bool
35965: PluginScriptableObjectChild::ScriptableHasProperty(NPObject* aObject,
35965:                                                    NPIdentifier aName)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
35965:   if (object->invalidated) {
35965:     NS_WARNING("Calling method on an invalidated object!");
35965:     return false;
35965:   }
35965: 
37311:   ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
35965:   NS_ASSERTION(actor, "This shouldn't ever be null!");
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35965: 
35965:   bool result;
37311:   actor->CallHasProperty((NPRemoteIdentifier)aName, &result);
35965: 
35965:   return result;
35965: }
35965: 
35965: // static
35965: bool
35965: PluginScriptableObjectChild::ScriptableGetProperty(NPObject* aObject,
35965:                                                    NPIdentifier aName,
35965:                                                    NPVariant* aResult)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
35965:   if (object->invalidated) {
35965:     NS_WARNING("Calling method on an invalidated object!");
35965:     return false;
35965:   }
35965: 
37311:   ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
35965:   NS_ASSERTION(actor, "This shouldn't ever be null!");
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35965: 
35965:   Variant result;
35965:   bool success;
37311:   actor->CallGetProperty((NPRemoteIdentifier)aName, &result, &success);
35965: 
35965:   if (!success) {
35965:     return false;
35965:   }
35965: 
35965:   ConvertToVariant(result, *aResult);
35965:   return true;
35965: }
35965: 
35965: // static
35965: bool
35965: PluginScriptableObjectChild::ScriptableSetProperty(NPObject* aObject,
35965:                                                    NPIdentifier aName,
35965:                                                    const NPVariant* aValue)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
35965:   if (object->invalidated) {
35965:     NS_WARNING("Calling method on an invalidated object!");
35965:     return false;
35965:   }
35965: 
37311:   ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
35965:   NS_ASSERTION(actor, "This shouldn't ever be null!");
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35965: 
37311:   ProtectedVariant value(*aValue, actor->GetInstance());
37311:   if (!value.IsOk()) {
35965:     NS_WARNING("Failed to convert variant!");
35965:     return false;
35965:   }
35965: 
35965:   bool success;
37311:   actor->CallSetProperty((NPRemoteIdentifier)aName, value, &success);
35965: 
35965:   return success;
35965: }
35965: 
35965: // static
35965: bool
35965: PluginScriptableObjectChild::ScriptableRemoveProperty(NPObject* aObject,
35965:                                                       NPIdentifier aName)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
35965:   if (object->invalidated) {
35965:     NS_WARNING("Calling method on an invalidated object!");
35965:     return false;
35965:   }
35965: 
37311:   ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
35965:   NS_ASSERTION(actor, "This shouldn't ever be null!");
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35965: 
35965:   bool success;
37311:   actor->CallRemoveProperty((NPRemoteIdentifier)aName, &success);
35965: 
35965:   return success;
35965: }
35965: 
35965: // static
35965: bool
35965: PluginScriptableObjectChild::ScriptableEnumerate(NPObject* aObject,
35965:                                                  NPIdentifier** aIdentifiers,
35965:                                                  uint32_t* aCount)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
35965:   if (object->invalidated) {
35965:     NS_WARNING("Calling method on an invalidated object!");
35965:     return false;
35965:   }
35965: 
37311:   ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
35965:   NS_ASSERTION(actor, "This shouldn't ever be null!");
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35965: 
35965:   nsAutoTArray<NPRemoteIdentifier, 10> identifiers;
35965:   bool success;
37311:   actor->CallEnumerate(&identifiers, &success);
35965: 
35965:   if (!success) {
35965:     return false;
35965:   }
35965: 
35965:   *aCount = identifiers.Length();
35965:   if (!*aCount) {
35965:     *aIdentifiers = nsnull;
35965:     return true;
35965:   }
35965: 
35965:   *aIdentifiers = reinterpret_cast<NPIdentifier*>(
35965:       PluginModuleChild::sBrowserFuncs.memalloc(*aCount * sizeof(NPIdentifier)));
35965:   if (!*aIdentifiers) {
35965:     NS_ERROR("Out of memory!");
35965:     return false;
35965:   }
35965: 
35965:   for (PRUint32 index = 0; index < *aCount; index++) {
36033:     (*aIdentifiers)[index] = (NPIdentifier)identifiers[index];
35965:   }
35965:   return true;
35965: }
35965: 
35965: // static
35965: bool
35965: PluginScriptableObjectChild::ScriptableConstruct(NPObject* aObject,
35965:                                                  const NPVariant* aArgs,
35965:                                                  uint32_t aArgCount,
35965:                                                  NPVariant* aResult)
35965: {
35971:   AssertPluginThread();
35971: 
37311:   if (aObject->_class != GetClass()) {
37311:     NS_RUNTIMEABORT("Don't know what kind of object this is!");
35965:   }
35965: 
35965:   ChildNPObject* object = reinterpret_cast<ChildNPObject*>(aObject);
35965:   if (object->invalidated) {
35965:     NS_WARNING("Calling method on an invalidated object!");
35965:     return false;
35965:   }
35965: 
37311:   ProtectedActor<PluginScriptableObjectChild> actor(object->parent);
35965:   NS_ASSERTION(actor, "This shouldn't ever be null!");
37311:   NS_ASSERTION(actor->Type() == Proxy, "Bad type!");
35965: 
37311:   ProtectedVariantArray args(aArgs, aArgCount, actor->GetInstance());
37311:   if (!args.IsOk()) {
37311:     NS_ERROR("Failed to convert arguments!");
35965:     return false;
35965:   }
35965: 
35965:   Variant remoteResult;
35965:   bool success;
37311:   actor->CallConstruct(args, &remoteResult, &success);
35965: 
35965:   if (!success) {
35965:     return false;
35965:   }
35965: 
35965:   ConvertToVariant(remoteResult, *aResult);
35965:   return true;
35965: }
35965: 
35965: const NPClass PluginScriptableObjectChild::sNPClass = {
35965:   NP_CLASS_STRUCT_VERSION,
35965:   PluginScriptableObjectChild::ScriptableAllocate,
35965:   PluginScriptableObjectChild::ScriptableDeallocate,
35965:   PluginScriptableObjectChild::ScriptableInvalidate,
35965:   PluginScriptableObjectChild::ScriptableHasMethod,
35965:   PluginScriptableObjectChild::ScriptableInvoke,
35965:   PluginScriptableObjectChild::ScriptableInvokeDefault,
35965:   PluginScriptableObjectChild::ScriptableHasProperty,
35965:   PluginScriptableObjectChild::ScriptableGetProperty,
35965:   PluginScriptableObjectChild::ScriptableSetProperty,
35965:   PluginScriptableObjectChild::ScriptableRemoveProperty,
35965:   PluginScriptableObjectChild::ScriptableEnumerate,
35965:   PluginScriptableObjectChild::ScriptableConstruct
35965: };
35965: 
37311: PluginScriptableObjectChild::PluginScriptableObjectChild(
37311:                                                      ScriptableObjectType aType)
35925: : mInstance(nsnull),
37311:   mObject(nsnull),
37311:   mInvalidated(false),
37311:   mProtectCount(0),
37311:   mType(aType)
35835: {
35971:   AssertPluginThread();
35835: }
35835: 
35893: PluginScriptableObjectChild::~PluginScriptableObjectChild()
35835: {
35971:   AssertPluginThread();
35971: 
35925:   if (mObject) {
37477:     PluginModuleChild::current()->UnregisterActorForNPObject(mObject);
37477: 
35965:     if (mObject->_class == GetClass()) {
37311:       NS_ASSERTION(mType == Proxy, "Wrong type!");
37311:       static_cast<ChildNPObject*>(mObject)->parent = nsnull;
35965:     }
35965:     else {
37311:       NS_ASSERTION(mType == LocalObject, "Wrong type!");
37311:       PluginModuleChild::sBrowserFuncs.releaseobject(mObject);
37311:     }
37311:   }
35965: }
35925: 
35925: void
37311: PluginScriptableObjectChild::InitializeProxy()
35925: {
35971:   AssertPluginThread();
37311:   NS_ASSERTION(mType == Proxy, "Bad type!");
37311:   NS_ASSERTION(!mObject, "Calling Initialize more than once!");
37311:   NS_ASSERTION(!mInvalidated, "Already invalidated?!");
35971: 
37311:   mInstance = static_cast<PluginInstanceChild*>(Manager());
37311:   NS_ASSERTION(mInstance, "Null manager?!");
35965: 
37311:   NPObject* object = CreateProxyObject();
37311:   NS_ASSERTION(object, "Failed to create object!");
35965: 
37477:   if (!PluginModuleChild::current()->RegisterActorForNPObject(object, this)) {
37311:     NS_ERROR("Out of memory?");
37311:   }
37311: 
37311:   mObject = object;
37311: }
37311: 
37311: void
37311: PluginScriptableObjectChild::InitializeLocal(NPObject* aObject)
37311: {
37311:   AssertPluginThread();
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
37311:   NS_ASSERTION(!mObject, "Calling Initialize more than once!");
37311:   NS_ASSERTION(!mInvalidated, "Already invalidated?!");
37311: 
37311:   mInstance = static_cast<PluginInstanceChild*>(Manager());
37311:   NS_ASSERTION(mInstance, "Null manager?!");
37311: 
37311:   PluginModuleChild::sBrowserFuncs.retainobject(aObject);
37311: 
37311:   NS_ASSERTION(!mProtectCount, "Should be zero!");
37311:   mProtectCount++;
37311: 
37477:   if (!PluginModuleChild::current()->RegisterActorForNPObject(aObject, this)) {
37311:       NS_ERROR("Out of memory?");
37311:   }
37311: 
37311:   mObject = aObject;
37311: }
37311: 
37311: NPObject*
37311: PluginScriptableObjectChild::CreateProxyObject()
37311: {
37311:   NS_ASSERTION(mInstance, "Must have an instance!");
37311:   NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
37311: 
37311:   NPClass* proxyClass = const_cast<NPClass*>(GetClass());
37311:   NPObject* npobject =
37311:     PluginModuleChild::sBrowserFuncs.createobject(mInstance->GetNPP(),
37311:                                                   proxyClass);
37311:   NS_ASSERTION(npobject, "Failed to create object?!");
37311:   NS_ASSERTION(npobject->_class == GetClass(), "Wrong kind of object!");
37311:   NS_ASSERTION(npobject->referenceCount == 1, "Some kind of live object!");
37311: 
37311:   ChildNPObject* object = static_cast<ChildNPObject*>(npobject);
37311:   NS_ASSERTION(!object->invalidated, "Bad object!");
35965:   NS_ASSERTION(!object->parent, "Bad object!");
35965: 
35965:   // We don't want to have the actor own this object but rather let the object
35965:   // own this actor. Set the reference count to 0 here so that when the object
37311:   // dies we will send the destructor message to the child.
37311:   object->referenceCount = 0;
37476:   NS_LOG_RELEASE(object, 0, "NPObject");
37311: 
37311:   object->parent = const_cast<PluginScriptableObjectChild*>(this);
37311:   return object;
35965: }
35965: 
37311: bool
37311: PluginScriptableObjectChild::ResurrectProxyObject()
37311: {
37311:   NS_ASSERTION(mInstance, "Must have an instance already!");
37311:   NS_ASSERTION(!mObject, "Should not have an object already!");
37311:   NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
37311: 
37311:   NPObject* object = CreateProxyObject();
37311:   if (!object) {
37311:     NS_WARNING("Failed to create object!");
37311:     return false;
37311:   }
37311: 
37311:   InitializeProxy();
37311:   NS_ASSERTION(mObject, "Initialize failed!");
37311: 
37311:   CallProtect();
37311:   return true;
37311: }
37311: 
37311: NPObject*
37311: PluginScriptableObjectChild::GetObject(bool aCanResurrect)
37311: {
37311:   if (!mObject && aCanResurrect && !ResurrectProxyObject()) {
37311:     NS_ERROR("Null object!");
37311:     return nsnull;
37311:   }
37311:   return mObject;
37311: }
37311: 
37311: void
37311: PluginScriptableObjectChild::Protect()
37311: {
37311:   NS_ASSERTION(mObject, "No object!");
37311:   NS_ASSERTION(mProtectCount >= 0, "Negative retain count?!");
37311: 
37311:   if (mType == LocalObject) {
37311:     ++mProtectCount;
37311:   }
37311: }
37311: 
37311: void
37311: PluginScriptableObjectChild::Unprotect()
37311: {
37311:   NS_ASSERTION(mObject, "Bad state!");
37311:   NS_ASSERTION(mProtectCount >= 0, "Negative retain count?!");
37311: 
37311:   if (mType == LocalObject) {
37311:     if (--mProtectCount == 0) {
37311:       PluginScriptableObjectChild::Call__delete__(this);
37311:     }
37311:   }
37311: }
37311: 
37311: void
37311: PluginScriptableObjectChild::DropNPObject()
37311: {
37311:   NS_ASSERTION(mObject, "Invalidated object!");
37311:   NS_ASSERTION(mObject->_class == GetClass(), "Wrong type of object!");
37311:   NS_ASSERTION(mType == Proxy, "Shouldn't call this for non-proxy object!");
37311: 
37311:   // We think we're about to be deleted, but we could be racing with the other
37311:   // process.
37477:   PluginModuleChild::current()->UnregisterActorForNPObject(mObject);
37311:   mObject = nsnull;
37311: 
37311:   CallUnprotect();
35835: }
35835: 
37477: void
37477: PluginScriptableObjectChild::NPObjectDestroyed()
37477: {
37477:   NS_ASSERTION(LocalObject == mType,
37477:                "ScriptableDeallocate should have handled this for proxies");
37477:   mInvalidated = true;
37477:   mObject = NULL;
37477: }
37477: 
35926: bool
35893: PluginScriptableObjectChild::AnswerInvalidate()
35835: {
35971:   AssertPluginThread();
35971: 
37311:   if (mInvalidated) {
37311:     return true;
37311:   }
37311: 
37311:   mInvalidated = true;
37311: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
37311: 
35965:   if (mObject->_class && mObject->_class->invalidate) {
35965:     mObject->_class->invalidate(mObject);
35965:   }
37311: 
37311:   Unprotect();
37311: 
35926:   return true;
35925: }
35835: 
35926: bool
35893: PluginScriptableObjectChild::AnswerHasMethod(const NPRemoteIdentifier& aId,
35835:                                              bool* aHasMethod)
35835: {
35971:   AssertPluginThread();
35971: 
37311:   if (mInvalidated) {
35965:     NS_WARNING("Calling AnswerHasMethod with an invalidated object!");
35934:     *aHasMethod = false;
35934:     return true;
35934:   }
35925: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35925:   if (!(mObject->_class && mObject->_class->hasMethod)) {
35925:     *aHasMethod = false;
35926:     return true;
35925:   }
35925: 
35925:   *aHasMethod = mObject->_class->hasMethod(mObject, (NPIdentifier)aId);
35926:   return true;
35835: }
35835: 
35926: bool
35893: PluginScriptableObjectChild::AnswerInvoke(const NPRemoteIdentifier& aId,
35965:                                           const nsTArray<Variant>& aArgs,
35965:                                           Variant* aResult,
35835:                                           bool* aSuccess)
35835: {
35971:   AssertPluginThread();
35971: 
37311:   if (mInvalidated) {
35965:     NS_WARNING("Calling AnswerInvoke with an invalidated object!");
35969:     *aResult = void_t();
35934:     *aSuccess = false;
35934:     return true;
35934:   }
35925: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35925:   if (!(mObject->_class && mObject->_class->invoke)) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   nsAutoTArray<NPVariant, 10> convertedArgs;
35925:   PRUint32 argCount = aArgs.Length();
35925: 
35925:   if (!convertedArgs.SetLength(argCount)) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     ConvertToVariant(aArgs[index], convertedArgs[index]);
35925:   }
35925: 
35925:   NPVariant result;
37349:   VOID_TO_NPVARIANT(result);
35925:   bool success = mObject->_class->invoke(mObject, (NPIdentifier)aId,
35925:                                          convertedArgs.Elements(), argCount,
35925:                                          &result);
35965: 
35965:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     PluginModuleChild::sBrowserFuncs.releasevariantvalue(&convertedArgs[index]);
35965:   }
35965: 
35925:   if (!success) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35965:   Variant convertedResult;
37311:   success = ConvertToRemoteVariant(result, convertedResult, GetInstance(),
37311:                                    false);
35965: 
36033:   DeferNPVariantLastRelease(&PluginModuleChild::sBrowserFuncs, &result);
35965: 
35965:   if (!success) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   *aSuccess = true;
35925:   *aResult = convertedResult;
35926:   return true;
35835: }
35835: 
35926: bool
35965: PluginScriptableObjectChild::AnswerInvokeDefault(const nsTArray<Variant>& aArgs,
35965:                                                  Variant* aResult,
35835:                                                  bool* aSuccess)
35835: {
35971:   AssertPluginThread();
35971: 
37311:   if (mInvalidated) {
35965:     NS_WARNING("Calling AnswerInvokeDefault with an invalidated object!");
35969:     *aResult = void_t();
35934:     *aSuccess = false;
35934:     return true;
35934:   }
35925: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35925:   if (!(mObject->_class && mObject->_class->invokeDefault)) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   nsAutoTArray<NPVariant, 10> convertedArgs;
35925:   PRUint32 argCount = aArgs.Length();
35925: 
35925:   if (!convertedArgs.SetLength(argCount)) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     ConvertToVariant(aArgs[index], convertedArgs[index]);
35925:   }
35925: 
35925:   NPVariant result;
37349:   VOID_TO_NPVARIANT(result);
35925:   bool success = mObject->_class->invokeDefault(mObject,
35925:                                                 convertedArgs.Elements(),
35925:                                                 argCount, &result);
35965: 
35965:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     PluginModuleChild::sBrowserFuncs.releasevariantvalue(&convertedArgs[index]);
35965:   }
35965: 
35925:   if (!success) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35965:   Variant convertedResult;
37311:   success = ConvertToRemoteVariant(result, convertedResult, GetInstance(),
37311:                                    false);
35965: 
36033:   DeferNPVariantLastRelease(&PluginModuleChild::sBrowserFuncs, &result);
35965: 
35965:   if (!success) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35969:   *aResult = convertedResult;
35925:   *aSuccess = true;
35926:   return true;
35835: }
35835: 
35926: bool
35893: PluginScriptableObjectChild::AnswerHasProperty(const NPRemoteIdentifier& aId,
35835:                                                bool* aHasProperty)
35835: {
35971:   AssertPluginThread();
35971: 
37311:   if (mInvalidated) {
35965:     NS_WARNING("Calling AnswerHasProperty with an invalidated object!");
35934:     *aHasProperty = false;
35934:     return true;
35934:   }
35925: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35925:   if (!(mObject->_class && mObject->_class->hasProperty)) {
35925:     *aHasProperty = false;
35926:     return true;
35925:   }
35925: 
35925:   *aHasProperty = mObject->_class->hasProperty(mObject, (NPIdentifier)aId);
35926:   return true;
35835: }
35835: 
35926: bool
35893: PluginScriptableObjectChild::AnswerGetProperty(const NPRemoteIdentifier& aId,
35965:                                                Variant* aResult,
35835:                                                bool* aSuccess)
35835: {
35971:   AssertPluginThread();
35971: 
37311:   if (mInvalidated) {
35965:     NS_WARNING("Calling AnswerGetProperty with an invalidated object!");
35970:     *aResult = void_t();
35934:     *aSuccess = false;
35934:     return true;
35934:   }
35925: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35925:   if (!(mObject->_class && mObject->_class->getProperty)) {
35970:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   NPVariant result;
37349:   VOID_TO_NPVARIANT(result);
35925:   if (!mObject->_class->getProperty(mObject, (NPIdentifier)aId, &result)) {
35970:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35965:   Variant converted;
37311:   if ((*aSuccess = ConvertToRemoteVariant(result, converted, GetInstance(),
37311:                                           false))) {
36033:     DeferNPVariantLastRelease(&PluginModuleChild::sBrowserFuncs, &result);
35925:     *aResult = converted;
35925:   }
35970:   else {
35970:     *aResult = void_t();
35970:   }
35970: 
35926:   return true;
35835: }
35835: 
35926: bool
35893: PluginScriptableObjectChild::AnswerSetProperty(const NPRemoteIdentifier& aId,
35965:                                                const Variant& aValue,
35835:                                                bool* aSuccess)
35835: {
35971:   AssertPluginThread();
35971: 
37311:   if (mInvalidated) {
35965:     NS_WARNING("Calling AnswerSetProperty with an invalidated object!");
35934:     *aSuccess = false;
35934:     return true;
35934:   }
35925: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35925:   if (!(mObject->_class && mObject->_class->setProperty)) {
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   NPVariant converted;
35965:   ConvertToVariant(aValue, converted);
35965: 
35965:   if ((*aSuccess = mObject->_class->setProperty(mObject, (NPIdentifier)aId,
35965:                                                 &converted))) {
35965:     PluginModuleChild::sBrowserFuncs.releasevariantvalue(&converted);
35925:   }
35926:   return true;
35835: }
35835: 
35926: bool
35893: PluginScriptableObjectChild::AnswerRemoveProperty(const NPRemoteIdentifier& aId,
35835:                                                   bool* aSuccess)
35835: {
35971:   AssertPluginThread();
35971: 
37311:   if (mInvalidated) {
35965:     NS_WARNING("Calling AnswerRemoveProperty with an invalidated object!");
35934:     *aSuccess = false;
35934:     return true;
35934:   }
35925: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35925:   if (!(mObject->_class && mObject->_class->removeProperty)) {
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   *aSuccess = mObject->_class->removeProperty(mObject, (NPIdentifier)aId);
35926:   return true;
35835: }
35835: 
35926: bool
35893: PluginScriptableObjectChild::AnswerEnumerate(nsTArray<NPRemoteIdentifier>* aProperties,
35835:                                              bool* aSuccess)
35835: {
35971:   AssertPluginThread();
35971: 
37311:   if (mInvalidated) {
35965:     NS_WARNING("Calling AnswerEnumerate with an invalidated object!");
35934:     *aSuccess = false;
35934:     return true;
35934:   }
35925: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35925:   if (!(mObject->_class && mObject->_class->enumerate)) {
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   NPIdentifier* ids;
35925:   uint32_t idCount;
35925:   if (!mObject->_class->enumerate(mObject, &ids, &idCount)) {
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   if (!aProperties->SetCapacity(idCount)) {
35925:     PluginModuleChild::sBrowserFuncs.memfree(ids);
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   for (uint32_t index = 0; index < idCount; index++) {
35925: #ifdef DEBUG
35925:     NPRemoteIdentifier* remoteId =
35925: #endif
35925:     aProperties->AppendElement((NPRemoteIdentifier)ids[index]);
35925:     NS_ASSERTION(remoteId, "Shouldn't fail if SetCapacity above succeeded!");
35925:   }
35925: 
35925:   PluginModuleChild::sBrowserFuncs.memfree(ids);
35925:   *aSuccess = true;
35926:   return true;
35835: }
35835: 
35926: bool
35965: PluginScriptableObjectChild::AnswerConstruct(const nsTArray<Variant>& aArgs,
35965:                                              Variant* aResult,
35835:                                              bool* aSuccess)
35835: {
35971:   AssertPluginThread();
35971: 
37311:   if (mInvalidated) {
35965:     NS_WARNING("Calling AnswerConstruct with an invalidated object!");
35969:     *aResult = void_t();
35934:     *aSuccess = false;
35934:     return true;
35934:   }
35925: 
35965:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
35965: 
35925:   if (!(mObject->_class && mObject->_class->construct)) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35835:   }
35925: 
35925:   nsAutoTArray<NPVariant, 10> convertedArgs;
35925:   PRUint32 argCount = aArgs.Length();
35925: 
35925:   if (!convertedArgs.SetLength(argCount)) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35925:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     ConvertToVariant(aArgs[index], convertedArgs[index]);
35925:   }
35925: 
35925:   NPVariant result;
37349:   VOID_TO_NPVARIANT(result);
35925:   bool success = mObject->_class->construct(mObject, convertedArgs.Elements(),
35925:                                             argCount, &result);
35965: 
35965:   for (PRUint32 index = 0; index < argCount; index++) {
35965:     PluginModuleChild::sBrowserFuncs.releasevariantvalue(&convertedArgs[index]);
35965:   }
35965: 
35925:   if (!success) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35965:   Variant convertedResult;
37311:   success = ConvertToRemoteVariant(result, convertedResult, GetInstance(),
37311:                                    false);
35965: 
36033:   DeferNPVariantLastRelease(&PluginModuleChild::sBrowserFuncs, &result);
35965: 
35965:   if (!success) {
35969:     *aResult = void_t();
35925:     *aSuccess = false;
35926:     return true;
35925:   }
35925: 
35969:   *aResult = convertedResult;
35925:   *aSuccess = true;
35926:   return true;
35925: }
35983: 
35983: bool
37311: PluginScriptableObjectChild::AnswerProtect()
37311: {
37311:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
37311: 
37311:   Protect();
37311:   return true;
37311: }
37311: 
37311: bool
37311: PluginScriptableObjectChild::AnswerUnprotect()
37311: {
37311:   NS_ASSERTION(mObject->_class != GetClass(), "Bad object type!");
37311:   NS_ASSERTION(mType == LocalObject, "Bad type!");
37311: 
37311:   Unprotect();
37311:   return true;
37311: }
37311: 
37311: bool
35983: PluginScriptableObjectChild::Evaluate(NPString* aScript,
35983:                                       NPVariant* aResult)
35983: {
35983:   nsDependentCString script("");
35983:   if (aScript->UTF8Characters && aScript->UTF8Length) {
35983:     script.Rebind(aScript->UTF8Characters, aScript->UTF8Length);
35983:   }
35983: 
35983:   bool success;
35983:   Variant result;
37311:   CallNPN_Evaluate(script, &result, &success);
37311: 
37311:   if (!success) {
35983:     return false;
35983:   }
35983: 
35983:   ConvertToVariant(result, *aResult);
35983:   return true;
35983: }
