16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:   function: LSP (also called LSF) conversion routines
31034:   last mod: $Id: lsp.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:   The LSP generation code is taken (with minimal modification and a
16295:   few bugfixes) from "On the Computation of the LSP Frequencies" by
16295:   Joseph Rothweiler (see http://www.rothweiler.us for contact info).
16295:   The paper is available at:
16295: 
16295:   http://www.myown1.com/joe/lsf
16295: 
16295:  ********************************************************************/
16295: 
16295: /* Note that the lpc-lsp conversion finds the roots of polynomial with
16295:    an iterative root polisher (CACM algorithm 283).  It *is* possible
16295:    to confuse this algorithm into not converging; that should only
16295:    happen with absurdly closely spaced roots (very sharp peaks in the
16295:    LPC f response) which in turn should be impossible in our use of
16295:    the code.  If this *does* happen anyway, it's a bug in the floor
16295:    finder; find the cause of the confusion (probably a single bin
16295:    spike or accidental near-float-limit resolution problems) and
16295:    correct it. */
16295: 
16295: #include <math.h>
16295: #include <string.h>
16295: #include <stdlib.h>
16295: #include "lsp.h"
16295: #include "os.h"
16295: #include "misc.h"
16295: #include "lookup.h"
16295: #include "scales.h"
16295: 
16295: /* three possible LSP to f curve functions; the exact computation
16295:    (float), a lookup based float implementation, and an integer
16295:    implementation.  The float lookup is likely the optimal choice on
16295:    any machine with an FPU.  The integer implementation is *not* fixed
16295:    point (due to the need for a large dynamic range and thus a
16295:    seperately tracked exponent) and thus much more complex than the
16295:    relatively simple float implementations. It's mostly for future
16295:    work on a fully fixed point implementation for processors like the
16295:    ARM family. */
16295: 
31034: /* define either of these (preferably FLOAT_LOOKUP) to have faster
31034:    but less precise implementation. */
31034: #undef FLOAT_LOOKUP
16295: #undef INT_LOOKUP
16295: 
16295: #ifdef FLOAT_LOOKUP
16295: #include "vorbis_lookup.c" /* catch this in the build system; we #include for
16295:                        compilers (like gcc) that can't inline across
16295:                        modules */
16295: 
16295: /* side effect: changes *lsp to cosines of lsp */
16295: void vorbis_lsp_to_curve(float *curve,int *map,int n,int ln,float *lsp,int m,
16295:                             float amp,float ampoffset){
16295:   int i;
16295:   float wdel=M_PI/ln;
16295:   vorbis_fpu_control fpu;
16295: 
16295:   vorbis_fpu_setround(&fpu);
16295:   for(i=0;i<m;i++)lsp[i]=vorbis_coslook(lsp[i]);
16295: 
16295:   i=0;
16295:   while(i<n){
16295:     int k=map[i];
16295:     int qexp;
16295:     float p=.7071067812f;
16295:     float q=.7071067812f;
16295:     float w=vorbis_coslook(wdel*k);
16295:     float *ftmp=lsp;
16295:     int c=m>>1;
16295: 
16295:     do{
16295:       q*=ftmp[0]-w;
16295:       p*=ftmp[1]-w;
16295:       ftmp+=2;
16295:     }while(--c);
16295: 
16295:     if(m&1){
16295:       /* odd order filter; slightly assymetric */
16295:       /* the last coefficient */
16295:       q*=ftmp[0]-w;
16295:       q*=q;
16295:       p*=p*(1.f-w*w);
16295:     }else{
16295:       /* even order filter; still symmetric */
16295:       q*=q*(1.f+w);
16295:       p*=p*(1.f-w);
16295:     }
16295: 
16295:     q=frexp(p+q,&qexp);
16295:     q=vorbis_fromdBlook(amp*
16295:                         vorbis_invsqlook(q)*
16295:                         vorbis_invsq2explook(qexp+m)-
16295:                         ampoffset);
16295: 
16295:     do{
16295:       curve[i++]*=q;
16295:     }while(map[i]==k);
16295:   }
16295:   vorbis_fpu_restore(fpu);
16295: }
16295: 
16295: #else
16295: 
16295: #ifdef INT_LOOKUP
16295: #include "vorbis_lookup.c" /* catch this in the build system; we #include for
16295:                        compilers (like gcc) that can't inline across
16295:                        modules */
16295: 
30043: static const int MLOOP_1[64]={
16295:    0,10,11,11, 12,12,12,12, 13,13,13,13, 13,13,13,13,
16295:   14,14,14,14, 14,14,14,14, 14,14,14,14, 14,14,14,14,
16295:   15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
16295:   15,15,15,15, 15,15,15,15, 15,15,15,15, 15,15,15,15,
16295: };
16295: 
30043: static const int MLOOP_2[64]={
16295:   0,4,5,5, 6,6,6,6, 7,7,7,7, 7,7,7,7,
16295:   8,8,8,8, 8,8,8,8, 8,8,8,8, 8,8,8,8,
16295:   9,9,9,9, 9,9,9,9, 9,9,9,9, 9,9,9,9,
16295:   9,9,9,9, 9,9,9,9, 9,9,9,9, 9,9,9,9,
16295: };
16295: 
30043: static const int MLOOP_3[8]={0,1,2,2,3,3,3,3};
16295: 
16295: 
16295: /* side effect: changes *lsp to cosines of lsp */
16295: void vorbis_lsp_to_curve(float *curve,int *map,int n,int ln,float *lsp,int m,
16295:                             float amp,float ampoffset){
16295: 
16295:   /* 0 <= m < 256 */
16295: 
16295:   /* set up for using all int later */
16295:   int i;
16295:   int ampoffseti=rint(ampoffset*4096.f);
16295:   int ampi=rint(amp*16.f);
16295:   long *ilsp=alloca(m*sizeof(*ilsp));
16295:   for(i=0;i<m;i++)ilsp[i]=vorbis_coslook_i(lsp[i]/M_PI*65536.f+.5f);
16295: 
16295:   i=0;
16295:   while(i<n){
16295:     int j,k=map[i];
16295:     unsigned long pi=46341; /* 2**-.5 in 0.16 */
16295:     unsigned long qi=46341;
16295:     int qexp=0,shift;
16295:     long wi=vorbis_coslook_i(k*65536/ln);
16295: 
16295:     qi*=labs(ilsp[0]-wi);
16295:     pi*=labs(ilsp[1]-wi);
16295: 
16295:     for(j=3;j<m;j+=2){
16295:       if(!(shift=MLOOP_1[(pi|qi)>>25]))
16295:         if(!(shift=MLOOP_2[(pi|qi)>>19]))
16295:           shift=MLOOP_3[(pi|qi)>>16];
16295:       qi=(qi>>shift)*labs(ilsp[j-1]-wi);
16295:       pi=(pi>>shift)*labs(ilsp[j]-wi);
16295:       qexp+=shift;
16295:     }
16295:     if(!(shift=MLOOP_1[(pi|qi)>>25]))
16295:       if(!(shift=MLOOP_2[(pi|qi)>>19]))
16295:         shift=MLOOP_3[(pi|qi)>>16];
16295: 
16295:     /* pi,qi normalized collectively, both tracked using qexp */
16295: 
16295:     if(m&1){
16295:       /* odd order filter; slightly assymetric */
16295:       /* the last coefficient */
16295:       qi=(qi>>shift)*labs(ilsp[j-1]-wi);
16295:       pi=(pi>>shift)<<14;
16295:       qexp+=shift;
16295: 
16295:       if(!(shift=MLOOP_1[(pi|qi)>>25]))
16295:         if(!(shift=MLOOP_2[(pi|qi)>>19]))
16295:           shift=MLOOP_3[(pi|qi)>>16];
16295: 
16295:       pi>>=shift;
16295:       qi>>=shift;
16295:       qexp+=shift-14*((m+1)>>1);
16295: 
16295:       pi=((pi*pi)>>16);
16295:       qi=((qi*qi)>>16);
16295:       qexp=qexp*2+m;
16295: 
16295:       pi*=(1<<14)-((wi*wi)>>14);
16295:       qi+=pi>>14;
16295: 
16295:     }else{
16295:       /* even order filter; still symmetric */
16295: 
16295:       /* p*=p(1-w), q*=q(1+w), let normalization drift because it isn't
16295:          worth tracking step by step */
16295: 
16295:       pi>>=shift;
16295:       qi>>=shift;
16295:       qexp+=shift-7*m;
16295: 
16295:       pi=((pi*pi)>>16);
16295:       qi=((qi*qi)>>16);
16295:       qexp=qexp*2+m;
16295: 
16295:       pi*=(1<<14)-wi;
16295:       qi*=(1<<14)+wi;
16295:       qi=(qi+pi)>>14;
16295: 
16295:     }
16295: 
16295: 
16295:     /* we've let the normalization drift because it wasn't important;
16295:        however, for the lookup, things must be normalized again.  We
16295:        need at most one right shift or a number of left shifts */
16295: 
16295:     if(qi&0xffff0000){ /* checks for 1.xxxxxxxxxxxxxxxx */
16295:       qi>>=1; qexp++;
16295:     }else
16295:       while(qi && !(qi&0x8000)){ /* checks for 0.0xxxxxxxxxxxxxxx or less*/
16295:         qi<<=1; qexp--;
16295:       }
16295: 
16295:     amp=vorbis_fromdBlook_i(ampi*                     /*  n.4         */
16295:                             vorbis_invsqlook_i(qi,qexp)-
16295:                                                       /*  m.8, m+n<=8 */
16295:                             ampoffseti);              /*  8.12[0]     */
16295: 
16295:     curve[i]*=amp;
16295:     while(map[++i]==k)curve[i]*=amp;
16295:   }
16295: }
16295: 
16295: #else
16295: 
16295: /* old, nonoptimized but simple version for any poor sap who needs to
16295:    figure out what the hell this code does, or wants the other
16295:    fraction of a dB precision */
16295: 
16295: /* side effect: changes *lsp to cosines of lsp */
16295: void vorbis_lsp_to_curve(float *curve,int *map,int n,int ln,float *lsp,int m,
16295:                             float amp,float ampoffset){
16295:   int i;
16295:   float wdel=M_PI/ln;
16295:   for(i=0;i<m;i++)lsp[i]=2.f*cos(lsp[i]);
16295: 
16295:   i=0;
16295:   while(i<n){
16295:     int j,k=map[i];
16295:     float p=.5f;
16295:     float q=.5f;
16295:     float w=2.f*cos(wdel*k);
16295:     for(j=1;j<m;j+=2){
16295:       q *= w-lsp[j-1];
16295:       p *= w-lsp[j];
16295:     }
16295:     if(j==m){
16295:       /* odd order filter; slightly assymetric */
16295:       /* the last coefficient */
16295:       q*=w-lsp[j-1];
16295:       p*=p*(4.f-w*w);
16295:       q*=q;
16295:     }else{
16295:       /* even order filter; still symmetric */
16295:       p*=p*(2.f-w);
16295:       q*=q*(2.f+w);
16295:     }
16295: 
16295:     q=fromdB(amp/sqrt(p+q)-ampoffset);
16295: 
16295:     curve[i]*=q;
16295:     while(map[++i]==k)curve[i]*=q;
16295:   }
16295: }
16295: 
16295: #endif
16295: #endif
16295: 
16295: static void cheby(float *g, int ord) {
16295:   int i, j;
16295: 
16295:   g[0] *= .5f;
16295:   for(i=2; i<= ord; i++) {
16295:     for(j=ord; j >= i; j--) {
16295:       g[j-2] -= g[j];
16295:       g[j] += g[j];
16295:     }
16295:   }
16295: }
16295: 
16295: static int comp(const void *a,const void *b){
16295:   return (*(float *)a<*(float *)b)-(*(float *)a>*(float *)b);
16295: }
16295: 
16295: /* Newton-Raphson-Maehly actually functioned as a decent root finder,
16295:    but there are root sets for which it gets into limit cycles
16295:    (exacerbated by zero suppression) and fails.  We can't afford to
16295:    fail, even if the failure is 1 in 100,000,000, so we now use
16295:    Laguerre and later polish with Newton-Raphson (which can then
16295:    afford to fail) */
16295: 
16295: #define EPSILON 10e-7
16295: static int Laguerre_With_Deflation(float *a,int ord,float *r){
16295:   int i,m;
16295:   double lastdelta=0.f;
16295:   double *defl=alloca(sizeof(*defl)*(ord+1));
16295:   for(i=0;i<=ord;i++)defl[i]=a[i];
16295: 
16295:   for(m=ord;m>0;m--){
16295:     double new=0.f,delta;
16295: 
16295:     /* iterate a root */
16295:     while(1){
16295:       double p=defl[m],pp=0.f,ppp=0.f,denom;
16295: 
16295:       /* eval the polynomial and its first two derivatives */
16295:       for(i=m;i>0;i--){
16295:         ppp = new*ppp + pp;
16295:         pp  = new*pp  + p;
16295:         p   = new*p   + defl[i-1];
16295:       }
16295: 
16295:       /* Laguerre's method */
16295:       denom=(m-1) * ((m-1)*pp*pp - m*p*ppp);
16295:       if(denom<0)
16295:         return(-1);  /* complex root!  The LPC generator handed us a bad filter */
16295: 
16295:       if(pp>0){
16295:         denom = pp + sqrt(denom);
16295:         if(denom<EPSILON)denom=EPSILON;
16295:       }else{
16295:         denom = pp - sqrt(denom);
16295:         if(denom>-(EPSILON))denom=-(EPSILON);
16295:       }
16295: 
16295:       delta  = m*p/denom;
16295:       new   -= delta;
16295: 
16295:       if(delta<0.f)delta*=-1;
16295: 
16295:       if(fabs(delta/new)<10e-12)break;
16295:       lastdelta=delta;
16295:     }
16295: 
16295:     r[m-1]=new;
16295: 
16295:     /* forward deflation */
16295: 
16295:     for(i=m;i>0;i--)
16295:       defl[i-1]+=new*defl[i];
16295:     defl++;
16295: 
16295:   }
16295:   return(0);
16295: }
16295: 
16295: 
16295: /* for spit-and-polish only */
16295: static int Newton_Raphson(float *a,int ord,float *r){
16295:   int i, k, count=0;
16295:   double error=1.f;
16295:   double *root=alloca(ord*sizeof(*root));
16295: 
16295:   for(i=0; i<ord;i++) root[i] = r[i];
16295: 
16295:   while(error>1e-20){
16295:     error=0;
16295: 
16295:     for(i=0; i<ord; i++) { /* Update each point. */
16295:       double pp=0.,delta;
16295:       double rooti=root[i];
16295:       double p=a[ord];
16295:       for(k=ord-1; k>= 0; k--) {
16295: 
16295:         pp= pp* rooti + p;
16295:         p = p * rooti + a[k];
16295:       }
16295: 
16295:       delta = p/pp;
16295:       root[i] -= delta;
16295:       error+= delta*delta;
16295:     }
16295: 
16295:     if(count>40)return(-1);
16295: 
16295:     count++;
16295:   }
16295: 
16295:   /* Replaced the original bubble sort with a real sort.  With your
16295:      help, we can eliminate the bubble sort in our lifetime. --Monty */
16295: 
16295:   for(i=0; i<ord;i++) r[i] = root[i];
16295:   return(0);
16295: }
16295: 
16295: 
16295: /* Convert lpc coefficients to lsp coefficients */
16295: int vorbis_lpc_to_lsp(float *lpc,float *lsp,int m){
16295:   int order2=(m+1)>>1;
16295:   int g1_order,g2_order;
16295:   float *g1=alloca(sizeof(*g1)*(order2+1));
16295:   float *g2=alloca(sizeof(*g2)*(order2+1));
16295:   float *g1r=alloca(sizeof(*g1r)*(order2+1));
16295:   float *g2r=alloca(sizeof(*g2r)*(order2+1));
16295:   int i;
16295: 
16295:   /* even and odd are slightly different base cases */
16295:   g1_order=(m+1)>>1;
16295:   g2_order=(m)  >>1;
16295: 
16295:   /* Compute the lengths of the x polynomials. */
16295:   /* Compute the first half of K & R F1 & F2 polynomials. */
16295:   /* Compute half of the symmetric and antisymmetric polynomials. */
16295:   /* Remove the roots at +1 and -1. */
16295: 
16295:   g1[g1_order] = 1.f;
16295:   for(i=1;i<=g1_order;i++) g1[g1_order-i] = lpc[i-1]+lpc[m-i];
16295:   g2[g2_order] = 1.f;
16295:   for(i=1;i<=g2_order;i++) g2[g2_order-i] = lpc[i-1]-lpc[m-i];
16295: 
16295:   if(g1_order>g2_order){
16295:     for(i=2; i<=g2_order;i++) g2[g2_order-i] += g2[g2_order-i+2];
16295:   }else{
16295:     for(i=1; i<=g1_order;i++) g1[g1_order-i] -= g1[g1_order-i+1];
16295:     for(i=1; i<=g2_order;i++) g2[g2_order-i] += g2[g2_order-i+1];
16295:   }
16295: 
16295:   /* Convert into polynomials in cos(alpha) */
16295:   cheby(g1,g1_order);
16295:   cheby(g2,g2_order);
16295: 
16295:   /* Find the roots of the 2 even polynomials.*/
16295:   if(Laguerre_With_Deflation(g1,g1_order,g1r) ||
16295:      Laguerre_With_Deflation(g2,g2_order,g2r))
16295:     return(-1);
16295: 
16295:   Newton_Raphson(g1,g1_order,g1r); /* if it fails, it leaves g1r alone */
16295:   Newton_Raphson(g2,g2_order,g2r); /* if it fails, it leaves g2r alone */
16295: 
16295:   qsort(g1r,g1_order,sizeof(*g1r),comp);
16295:   qsort(g2r,g2_order,sizeof(*g2r),comp);
16295: 
16295:   for(i=0;i<g1_order;i++)
16295:     lsp[i*2] = acos(g1r[i]);
16295: 
16295:   for(i=0;i<g2_order;i++)
16295:     lsp[i*2+1] = acos(g2r[i]);
16295:   return(0);
16295: }
