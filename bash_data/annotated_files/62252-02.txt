60891: /* vim: se cin sw=2 ts=2 et : */
60891: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
60891:  *
60891:  * ***** BEGIN LICENSE BLOCK *****
60891:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
60891:  *
60891:  * The contents of this file are subject to the Mozilla Public License Version
60891:  * 1.1 (the "License"); you may not use this file except in compliance with
60891:  * the License. You may obtain a copy of the License at
60891:  * http://www.mozilla.org/MPL/
60891:  *
60891:  * Software distributed under the License is distributed on an "AS IS" basis,
60891:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
60891:  * for the specific language governing rights and limitations under the
60891:  * License.
60891:  *
60891:  * The Original Code is mozilla.org code.
60891:  *
60891:  * The Initial Developer of the Original Code is
60891:  * Mozilla Foundation.
60891:  * Portions created by the Initial Developer are Copyright (C) 2011
60891:  * the Initial Developer. All Rights Reserved.
60891:  *
60891:  * Contributor(s):
60891:  *
60891:  * Alternatively, the contents of this file may be used under the terms of
60891:  * either the GNU General Public License Version 2 or later (the "GPL"), or
60891:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
60891:  * in which case the provisions of the GPL or the LGPL are applicable instead
60891:  * of those above. If you wish to allow use of your version of this file only
60891:  * under the terms of either the GPL or the LGPL, and not to allow others to
60891:  * use your version of this file under the terms of the MPL, indicate your
60891:  * decision by deleting the provisions above and replace them with the notice
60891:  * and other provisions required by the GPL or the LGPL. If you do not delete
60891:  * the provisions above, a recipient may use your version of this file under
60891:  * the terms of any one of the MPL, the GPL or the LGPL.
60891:  *
60891:  * ***** END LICENSE BLOCK ***** */
60891: 
60891: #include "GfxInfoBase.h"
60893: 
60891: #include "GfxInfoWebGL.h"
60893: #include "GfxDriverInfo.h"
60892: #include "nsIPrefBranch2.h"
60892: #include "nsIPrefService.h"
60892: #include "nsCOMPtr.h"
60893: #include "nsCOMArray.h"
60893: #include "nsAutoPtr.h"
60892: #include "nsString.h"
60892: #include "nsServiceManagerUtils.h"
60893: #include "mozilla/Services.h"
60893: #include "nsIObserver.h"
60893: #include "nsIObserverService.h"
60893: #include "nsIDOMElement.h"
60893: #include "nsIDOMNode.h"
60893: #include "nsIDOM3Node.h"
60893: #include "nsIDOMNodeList.h"
60893: #include "nsTArray.h"
60891: 
61767: #if defined(MOZ_CRASHREPORTER) && defined(MOZ_ENABLE_LIBXUL)
61767: #include "nsExceptionHandler.h"
61767: #endif
61767: 
61767: extern "C" {
62252:   void StoreSpline(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy);
62252:   void CrashSpline(double tolerance, int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy);
61767: }
61767: 
62252: static int crash_ax;
62252: static int crash_ay;
62252: static int crash_bx;
62252: static int crash_by;
62252: static int crash_cx;
62252: static int crash_cy;
62252: static int crash_dx;
62252: static int crash_dy;
61767: 
61767: void
62252: StoreSpline(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy) {
61767:     crash_ax = ax;
61767:     crash_ay = ay;
61767:     crash_bx = bx;
61767:     crash_by = by;
61767:     crash_cx = cx;
61767:     crash_cy = cy;
61767:     crash_dx = dx;
61767:     crash_dy = dy;
61767: }
61767: 
61767: void
62252: CrashSpline(double tolerance, int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy) {
61767: #if defined(MOZ_CRASHREPORTER) && defined(MOZ_ENABLE_LIBXUL)
61767:   static bool annotated;
61767: 
61767:   if (!annotated) {
61767:     nsCAutoString note;
61767: 
61767:     note.AppendPrintf("curve ");
62252:     note.AppendPrintf("%x ", crash_ax);
62252:     note.AppendPrintf("%x, ", crash_ay);
62252:     note.AppendPrintf("%x ", crash_bx);
62252:     note.AppendPrintf("%x, ", crash_by);
62252:     note.AppendPrintf("%x ", crash_cx);
62252:     note.AppendPrintf("%x, ", crash_cy);
62252:     note.AppendPrintf("%x ", crash_dx);
62252:     note.AppendPrintf("%x\n", crash_dy);
62252:     note.AppendPrintf("crv-crash(%f): ", tolerance);
62252:     note.AppendPrintf("%x ", ax);
62252:     note.AppendPrintf("%x, ", ay);
62252:     note.AppendPrintf("%x ", bx);
62252:     note.AppendPrintf("%x, ", by);
62252:     note.AppendPrintf("%x ", cx);
62252:     note.AppendPrintf("%x, ", cy);
62252:     note.AppendPrintf("%x ", dx);
62252:     note.AppendPrintf("%x\n", dy);
61767: 
61767:     CrashReporter::AppendAppNotesToCrashReport(note);
61767:     annotated = true;
61767:   }
61767: #endif
61767: }
61767: 
61767: 
60891: using namespace mozilla::widget;
60891: 
60893: NS_IMPL_ISUPPORTS3(GfxInfoBase, nsIGfxInfo, nsIObserver, nsISupportsWeakReference)
60891: 
60892: #define BLACKLIST_PREF_BRANCH "gfx.blacklist."
60892: #define SUGGESTED_VERSION_PREF BLACKLIST_PREF_BRANCH "suggested-driver-version"
60893: #define BLACKLIST_ENTRY_TAG_NAME "gfxBlacklistEntry"
60892: 
60892: static const char*
60892: GetPrefNameForFeature(PRInt32 aFeature)
60892: {
60892:   const char* name = nsnull;
60892:   switch(aFeature) {
60892:     case nsIGfxInfo::FEATURE_DIRECT2D:
60892:       name = BLACKLIST_PREF_BRANCH "direct2d";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS:
60892:       name = BLACKLIST_PREF_BRANCH "layers.direct3d9";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_DIRECT3D_10_LAYERS:
60892:       name = BLACKLIST_PREF_BRANCH "layers.direct3d10";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_DIRECT3D_10_1_LAYERS:
60892:       name = BLACKLIST_PREF_BRANCH "layers.direct3d10-1";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_OPENGL_LAYERS:
60892:       name = BLACKLIST_PREF_BRANCH "layers.opengl";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_WEBGL_OPENGL:
60892:       name = BLACKLIST_PREF_BRANCH "webgl.opengl";
60892:       break;
60892:     case nsIGfxInfo::FEATURE_WEBGL_ANGLE:
60892:       name = BLACKLIST_PREF_BRANCH "webgl.angle";
60892:       break;
60892:     default:
60892:       break;
60892:   };
60892: 
60892:   return name;
60892: }
60892: 
60892: // Returns the value of the pref for the relevant feature in aValue.
60892: // If the pref doesn't exist, aValue is not touched, and returns false.
60892: static bool
60892: GetPrefValueForFeature(PRInt32 aFeature, PRInt32& aValue)
60892: {
60892:   const char *prefname = GetPrefNameForFeature(aFeature);
60892:   if (!prefname)
60892:     return false;
60892: 
60892:   nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
60892:   if (prefs) {
60892:     PRInt32 val;
60892:     if (NS_SUCCEEDED(prefs->GetIntPref(prefname, &val))) {
60892:       aValue = val;
60892:       return true;
60892:     }
60892:   }
60892: 
60892:   return false;
60892: }
60892: 
60892: static void
60892: SetPrefValueForFeature(PRInt32 aFeature, PRInt32 aValue)
60892: {
60892:   const char *prefname = GetPrefNameForFeature(aFeature);
60892:   if (!prefname)
60892:     return;
60892: 
60892:   nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
60892:   if (prefs) {
60892:     prefs->SetIntPref(prefname, aValue);
60892:   }
60892: }
60892: 
60892: static void
60892: RemovePrefForFeature(PRInt32 aFeature)
60892: {
60892:   const char *prefname = GetPrefNameForFeature(aFeature);
60892:   if (!prefname)
60892:     return;
60892: 
60892:   nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
60892:   if (prefs) {
60892:     prefs->ClearUserPref(prefname);
60892:   }
60892: }
60892: 
60892: static bool
60892: GetPrefValueForDriverVersion(nsACString& aVersion)
60892: {
60892:   nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
60892:   if (prefs) {
60892:     nsXPIDLCString version;
60892:     if (NS_SUCCEEDED(prefs->GetCharPref(SUGGESTED_VERSION_PREF,
60892:                                         getter_Copies(version)))) {
60892:       aVersion = version;
60892:       return true;
60892:     }
60892:   }
60892: 
60892:   return false;
60892: }
60892: 
60892: static void
60892: SetPrefValueForDriverVersion(const nsAString& aVersion)
60892: {
60892:   nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
60892:   if (prefs) {
60892:     nsCAutoString ver = NS_LossyConvertUTF16toASCII(aVersion);
60892:     prefs->SetCharPref(SUGGESTED_VERSION_PREF,
60892:                        PromiseFlatCString(ver).get());
60892:   }
60892: }
60892: 
60892: static void
60892: RemovePrefForDriverVersion()
60892: {
60892:   nsCOMPtr<nsIPrefBranch2> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
60892:   if (prefs) {
60892:     prefs->ClearUserPref(SUGGESTED_VERSION_PREF);
60892:   }
60892: }
60892: 
60893: // <foo>Hello</foo> - "Hello" is stored as a child text node of the foo node.
60893: static bool
60893: BlacklistNodeToTextValue(nsIDOMNode *aBlacklistNode, nsAString& aValue)
60893: {
60893:   nsCOMPtr<nsIDOM3Node> dom3 = do_QueryInterface(aBlacklistNode);
60893:   if (!dom3)
60893:     return false;
60893: 
60893:   nsAutoString value;
60893:   if (NS_FAILED(dom3->GetTextContent(value)))
60893:     return false;
60893: 
60893:   value.Trim(" \t\r\n");
60893:   aValue = value;
60893: 
60893:   return true;
60893: }
60893: 
60893: static OperatingSystem
60893: BlacklistOSToOperatingSystem(const nsAString& os)
60893: {
60893:   if (os == NS_LITERAL_STRING("WINNT 5.0"))
60893:     return DRIVER_OS_WINDOWS_2000;
60893:   else if (os == NS_LITERAL_STRING("WINNT 5.1"))
60893:     return DRIVER_OS_WINDOWS_XP;
60893:   else if (os == NS_LITERAL_STRING("WINNT 5.2"))
60893:     return DRIVER_OS_WINDOWS_SERVER_2003;
60893:   else if (os == NS_LITERAL_STRING("WINNT 6.0"))
60893:     return DRIVER_OS_WINDOWS_VISTA;
60893:   else if (os == NS_LITERAL_STRING("WINNT 6.1"))
60893:     return DRIVER_OS_WINDOWS_7;
60893:   else if (os == NS_LITERAL_STRING("Linux"))
60893:     return DRIVER_OS_LINUX;
60893:   else if (os == NS_LITERAL_STRING("Darwin 9"))
60893:     return DRIVER_OS_OS_X_10_5;
60893:   else if (os == NS_LITERAL_STRING("Darwin 10"))
60893:     return DRIVER_OS_OS_X_10_6;
60893:   else if (os == NS_LITERAL_STRING("All"))
60893:     return DRIVER_OS_ALL;
60893: 
60893:   return DRIVER_OS_UNKNOWN;
60893: }
60893: 
60893: static PRUint32
60893: BlacklistHexToInt(const nsAString& aHex)
60893: {
60893:   PRInt32 err;
60893:   // nsAString doesn't have .ToInteger() :(
60893:   nsAutoString hex(aHex);
60893:   PRInt32 value = hex.ToInteger(&err, 16);
60893:   if (NS_FAILED(err))
60893:     return 0;
60893:   return (PRUint32) value;
60893: }
60893: 
60893: static PRUint32*
60893: BlacklistDevicesToDeviceFamily(nsIDOMNodeList* aDevices)
60893: {
60893:   PRUint32 length;
60893:   if (NS_FAILED(aDevices->GetLength(&length)))
60893:     return nsnull;
60893: 
60893:   // For each <device>, get its device ID, and return a freshly-allocated array
60893:   // with the contents of that array.
60893:   nsAutoArrayPtr<PRUint32> deviceIds(new PRUint32[length + 1]);
60893:   memset(deviceIds, 0, sizeof(PRUint32) * (length + 1));
60893: 
60893:   for (PRUint32 i = 0; i < length; ++i) {
60893:     nsCOMPtr<nsIDOMNode> node;
60893:     if (NS_FAILED(aDevices->Item(i, getter_AddRefs(node))) || !node)
60893:       continue;
60893: 
60893:     nsAutoString deviceValue;
60893:     if (!BlacklistNodeToTextValue(node, deviceValue))
60893:       continue;
60893: 
60893:     deviceIds[i] = BlacklistHexToInt(deviceValue);
60893:   }
60893: 
60893:   return deviceIds.forget();
60893: }
60893: 
60893: static PRInt32
60893: BlacklistFeatureToGfxFeature(const nsAString& aFeature)
60893: {
60893:   if (aFeature == NS_LITERAL_STRING("DIRECT2D"))
60893:     return nsIGfxInfo::FEATURE_DIRECT2D;
60893:   else if (aFeature == NS_LITERAL_STRING("DIRECT3D_9_LAYERS"))
60893:     return nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS;
60893:   else if (aFeature == NS_LITERAL_STRING("DIRECT3D_10_LAYERS"))
60893:     return nsIGfxInfo::FEATURE_DIRECT3D_10_LAYERS;
60893:   else if (aFeature == NS_LITERAL_STRING("DIRECT3D_10_1_LAYERS"))
60893:     return nsIGfxInfo::FEATURE_DIRECT3D_10_1_LAYERS;
60893:   else if (aFeature == NS_LITERAL_STRING("OPENGL_LAYERS"))
60893:     return nsIGfxInfo::FEATURE_OPENGL_LAYERS;
60893:   else if (aFeature == NS_LITERAL_STRING("WEBGL_OPENGL"))
60893:     return nsIGfxInfo::FEATURE_WEBGL_OPENGL;
60893:   else if (aFeature == NS_LITERAL_STRING("WEBGL_ANGLE"))
60893:     return nsIGfxInfo::FEATURE_WEBGL_ANGLE;
60893: 
60893:   return 0;
60893: }
60893: 
60893: static PRInt32
60893: BlacklistFeatureStatusToGfxFeatureStatus(const nsAString& aStatus)
60893: {
60893:   if (aStatus == NS_LITERAL_STRING("NO_INFO"))
60893:     return nsIGfxInfo::FEATURE_NO_INFO;
60893:   else if (aStatus == NS_LITERAL_STRING("BLOCKED_DRIVER_VERSION"))
60893:     return nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
60893:   else if (aStatus == NS_LITERAL_STRING("BLOCKED_DEVICE"))
60893:     return nsIGfxInfo::FEATURE_BLOCKED_DEVICE;
60893:   else if (aStatus == NS_LITERAL_STRING("DISCOURAGED"))
60893:     return nsIGfxInfo::FEATURE_DISCOURAGED;
60893:   else if (aStatus == NS_LITERAL_STRING("BLOCKED_OS_VERSION"))
60893:     return nsIGfxInfo::FEATURE_BLOCKED_OS_VERSION;
60893: 
60893:   return nsIGfxInfo::FEATURE_NO_INFO;
60893: }
60893: 
60893: static VersionComparisonOp
60893: BlacklistComparatorToComparisonOp(const nsAString& op)
60893: {
60893:   if (op == NS_LITERAL_STRING("LESS_THAN"))
60893:     return DRIVER_LESS_THAN;
60893:   else if (op == NS_LITERAL_STRING("LESS_THAN_OR_EQUAL"))
60893:     return DRIVER_LESS_THAN_OR_EQUAL;
60893:   else if (op == NS_LITERAL_STRING("GREATER_THAN"))
60893:     return DRIVER_GREATER_THAN;
60893:   else if (op == NS_LITERAL_STRING("GREATER_THAN_OR_EQUAL"))
60893:     return DRIVER_GREATER_THAN_OR_EQUAL;
60893:   else if (op == NS_LITERAL_STRING("EQUAL"))
60893:     return DRIVER_EQUAL;
60893:   else if (op == NS_LITERAL_STRING("NOT_EQUAL"))
60893:     return DRIVER_NOT_EQUAL;
60893:   else if (op == NS_LITERAL_STRING("BETWEEN_EXCLUSIVE"))
60893:     return DRIVER_BETWEEN_EXCLUSIVE;
60893:   else if (op == NS_LITERAL_STRING("BETWEEN_INCLUSIVE"))
60893:     return DRIVER_BETWEEN_INCLUSIVE;
60893:   else if (op == NS_LITERAL_STRING("BETWEEN_INCLUSIVE_START"))
60893:     return DRIVER_BETWEEN_INCLUSIVE_START;
60893: 
60893:   return DRIVER_UNKNOWN_COMPARISON;
60893: }
60893: 
60893: // Arbitrarily returns the first |tagname| child of |element|.
60893: static bool
60893: BlacklistNodeGetChildByName(nsIDOMElement *element,
60893:                             const nsAString& tagname,
60893:                             nsIDOMNode** firstchild)
60893: {
60893:   nsCOMPtr<nsIDOMNodeList> nodelist;
60893:   if (NS_FAILED(element->GetElementsByTagName(tagname,
60893:                                               getter_AddRefs(nodelist))) ||
60893:       !nodelist) {
60893:     return false;
60893:   }
60893: 
60893:   nsCOMPtr<nsIDOMNode> node;
60893:   if (NS_FAILED(nodelist->Item(0, getter_AddRefs(node))) || !node)
60893:     return false;
60893: 
60893:   *firstchild = node.forget().get();
60893:   return true;
60893: }
60893: 
60893: /*
60893: 
60893: <gfxBlacklistEntry>
60893:   <os>WINNT 6.0</os>
60893:   <vendor>0x8086</vendor>
60893:   <devices>
60893:     <device>0x2582</device>
60893:     <device>0x2782</device>
60893:   </devices>
60893:   <feature> DIRECT3D_10_LAYERS </feature>
60893:   <featureStatus> BLOCKED_DRIVER_VERSION </featureStatus>
60893:   <driverVersion> 8.52.322.2202 </driverVersion>
60893:   <driverVersionComparator> LESS_THAN_OR_EQUAL </driverVersionComparator>
60893: </gfxBlacklistEntry>
60893: 
60893: */
60893: static bool
60893: BlacklistEntryToDriverInfo(nsIDOMNode* aBlacklistEntry,
60893:                            GfxDriverInfo& aDriverInfo)
60893: {
60893:   nsAutoString nodename;
60893:   if (NS_FAILED(aBlacklistEntry->GetNodeName(nodename)) ||
60893:       nodename != NS_LITERAL_STRING(BLACKLIST_ENTRY_TAG_NAME)) {
60893:     return false;
60893:   }
60893: 
60893:   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(aBlacklistEntry);
60893:   if (!element)
60893:     return false;
60893: 
60893:   nsCOMPtr<nsIDOMNode> dataNode;
60893:   nsAutoString dataValue;
60893: 
60893:   // <os>WINNT 6.0</os>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("os"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     aDriverInfo.mOperatingSystem = BlacklistOSToOperatingSystem(dataValue);
60893:   }
60893: 
60893:   // <vendor>0x8086</vendor>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("vendor"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     aDriverInfo.mAdapterVendor = BlacklistHexToInt(dataValue);
60893:   }
60893: 
60893:   // <devices>
60893:   //   <device>0x2582</device>
60893:   //   <device>0x2782</device>
60893:   // </devices>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("devices"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     nsCOMPtr<nsIDOMElement> devicesElement = do_QueryInterface(dataNode);
60893:     if (devicesElement) {
60893: 
60893:       // Get only the <device> nodes, because BlacklistDevicesToDeviceFamily
60893:       // assumes it is passed no other nodes.
60893:       nsCOMPtr<nsIDOMNodeList> devices;
60893:       if (NS_SUCCEEDED(devicesElement->GetElementsByTagName(NS_LITERAL_STRING("device"),
60893:                                                             getter_AddRefs(devices)))) {
60893:         PRUint32* deviceIds = BlacklistDevicesToDeviceFamily(devices);
60893:         if (deviceIds) {
60893:           // Get GfxDriverInfo to adopt the devices array we created.
60893:           aDriverInfo.mDeleteDevices = true;
60893:           aDriverInfo.mDevices = deviceIds;
60893:         }
60893:       }
60893:     }
60893:   }
60893: 
60893:   // <feature> DIRECT3D_10_LAYERS </feature>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("feature"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     aDriverInfo.mFeature = BlacklistFeatureToGfxFeature(dataValue);
60893:   }
60893: 
60893:   // <featureStatus> BLOCKED_DRIVER_VERSION </featureStatus>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("featureStatus"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     aDriverInfo.mFeatureStatus = BlacklistFeatureStatusToGfxFeatureStatus(dataValue);
60893:   }
60893: 
60893:   // <driverVersion> 8.52.322.2202 </driverVersion>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("driverVersion"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     PRUint64 version;
60893:     if (ParseDriverVersion(dataValue, &version))
60893:       aDriverInfo.mDriverVersion = version;
60893:   }
60893: 
60893:   // <driverVersionComparator> LESS_THAN_OR_EQUAL </driverVersionComparator>
60893:   if (BlacklistNodeGetChildByName(element, NS_LITERAL_STRING("driverVersionComparator"),
60893:                                   getter_AddRefs(dataNode))) {
60893:     BlacklistNodeToTextValue(dataNode, dataValue);
60893:     aDriverInfo.mComparisonOp = BlacklistComparatorToComparisonOp(dataValue);
60893:   }
60893: 
60893:   // We explicitly ignore unknown elements.
60893: 
60893:   return true;
60893: }
60893: 
60893: static void
60893: BlacklistEntriesToDriverInfo(nsIDOMNodeList* aBlacklistEntries,
60893:                              nsTArray<GfxDriverInfo>& aDriverInfo)
60893: {
60893:   PRUint32 length;
60893:   if (NS_FAILED(aBlacklistEntries->GetLength(&length)))
60893:     return;
60893: 
60893:   for (PRUint32 i = 0; i < length; ++i) {
60893:     nsCOMPtr<nsIDOMNode> blacklistEntry;
60893:     if (NS_SUCCEEDED(aBlacklistEntries->Item(i,
60893:                                              getter_AddRefs(blacklistEntry))) &&
60893:         blacklistEntry) {
60893:       GfxDriverInfo di;
60893:       if (BlacklistEntryToDriverInfo(blacklistEntry, di)) {
60893:         aDriverInfo.AppendElement(di);
60893:       }
60893:     }
60893:   }
60893: }
60893: 
60893: NS_IMETHODIMP
60893: GfxInfoBase::Observe(nsISupports* aSubject, const char* aTopic,
60893:                      const PRUnichar* aData)
60893: {
60893:   if (strcmp(aTopic, "blocklist-data-gfxItems") == 0) {
60893:     nsCOMPtr<nsIDOMElement> gfxItems = do_QueryInterface(aSubject);
60893:     if (gfxItems) {
60893:       nsCOMPtr<nsIDOMNodeList> blacklistEntries;
60893:       if (NS_SUCCEEDED(gfxItems->
60893:             GetElementsByTagName(NS_LITERAL_STRING(BLACKLIST_ENTRY_TAG_NAME),
60893:                                  getter_AddRefs(blacklistEntries))) &&
60893:           blacklistEntries)
60893:       {
60893:         nsTArray<GfxDriverInfo> driverInfo;
60893:         BlacklistEntriesToDriverInfo(blacklistEntries, driverInfo);
60894: 
60894:         EvaluateDownloadedBlacklist(driverInfo);
60893:       }
60893:     }
60893:   }
60893: 
60893:   return NS_OK;
60893: }
60893: 
60893: GfxInfoBase::GfxInfoBase()
62106:     : mFailureCount(0)
60893: {
60893: }
60893: 
60893: GfxInfoBase::~GfxInfoBase()
60893: {
60893: }
60893: 
60893: nsresult
60893: GfxInfoBase::Init()
60893: {
60893:   nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
60893:   if (os) {
60893:     os->AddObserver(this, "blocklist-data-gfxItems", PR_TRUE);
60893:   }
60893: 
60893:   return NS_OK;
60893: }
60893: 
60891: NS_IMETHODIMP
60891: GfxInfoBase::GetFeatureStatus(PRInt32 aFeature, PRInt32* aStatus NS_OUTPARAM)
60891: {
60892:   if (GetPrefValueForFeature(aFeature, *aStatus))
60892:     return NS_OK;
60892: 
60891:   nsString version;
60891:   return GetFeatureStatusImpl(aFeature, aStatus, version);
60891: }
60891: 
60891: NS_IMETHODIMP
60891: GfxInfoBase::GetFeatureSuggestedDriverVersion(PRInt32 aFeature,
60891:                                               nsAString& aVersion NS_OUTPARAM)
60891: {
60892:   nsCString version;
60892:   if (GetPrefValueForDriverVersion(version)) {
60892:     aVersion = NS_ConvertASCIItoUTF16(version);
60892:     return NS_OK;
60892:   }
60892: 
60891:   PRInt32 status;
60891:   return GetFeatureStatusImpl(aFeature, &status, aVersion);
60891: }
60891: 
60892: 
60891: NS_IMETHODIMP
60891: GfxInfoBase::GetWebGLParameter(const nsAString& aParam,
60891:                                nsAString& aResult NS_OUTPARAM)
60891: {
60891:   return GfxInfoWebGL::GetWebGLParameter(aParam, aResult);
60891: }
60894: 
60894: void
60894: GfxInfoBase::EvaluateDownloadedBlacklist(nsTArray<GfxDriverInfo>& aDriverInfo)
60894: {
60894:   PRInt32 features[] = {
60894:     nsIGfxInfo::FEATURE_DIRECT2D,
60894:     nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS,
60894:     nsIGfxInfo::FEATURE_DIRECT3D_10_LAYERS,
60894:     nsIGfxInfo::FEATURE_DIRECT3D_10_1_LAYERS,
60894:     nsIGfxInfo::FEATURE_OPENGL_LAYERS,
60894:     nsIGfxInfo::FEATURE_WEBGL_OPENGL,
60894:     nsIGfxInfo::FEATURE_WEBGL_ANGLE,
60894:     0
60894:   };
60894: 
60894:   // GetFeatureStatusImpl wants a zero-GfxDriverInfo terminated array. So, we
60894:   // append that to our list.
60894:   aDriverInfo.AppendElement(GfxDriverInfo());
60894: 
60894:   // For every feature we know about, we evaluate whether this blacklist has a
60894:   // non-NO_INFO status. If it does, we set the pref we evaluate in
60894:   // GetFeatureStatus above, so we don't need to hold on to this blacklist
60894:   // anywhere permanent.
60894:   int i = 0;
60894:   while (features[i]) {
60894:     PRInt32 status;
60894:     nsAutoString suggestedVersion;
60894:     if (NS_SUCCEEDED(GetFeatureStatusImpl(features[i], &status,
60894:                                           suggestedVersion,
60894:                                           aDriverInfo.Elements()))) {
60894:       switch (status) {
60894:         default:
60894:         case nsIGfxInfo::FEATURE_NO_INFO:
60894:           RemovePrefForFeature(features[i]);
60894:           break;
60894: 
60894:         case nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION:
60894:           if (!suggestedVersion.IsEmpty()) {
60894:             SetPrefValueForDriverVersion(suggestedVersion);
60894:           } else {
60894:             RemovePrefForDriverVersion();
60894:           }
60894:           // FALLTHROUGH
60894: 
60894:         case nsIGfxInfo::FEATURE_BLOCKED_DEVICE:
60894:         case nsIGfxInfo::FEATURE_DISCOURAGED:
60894:         case nsIGfxInfo::FEATURE_BLOCKED_OS_VERSION:
60894:           SetPrefValueForFeature(features[i], status);
60894:           break;
60894:       }
60894:     }
60894: 
60894:     ++i;
60894:   }
60894: }
62106: 
62106: NS_IMETHODIMP_(void)
62106: GfxInfoBase::LogFailure(const nsACString &failure)
62106: {
62106:   /* We only keep the first 9 failures */
62106:   if (mFailureCount < NS_ARRAY_LENGTH(mFailures)) {
62106:     mFailures[mFailureCount++] = failure;
62106:   }
62106: }
62106: 
62106: /* void getFailures ([optional] out unsigned long failureCount, [array, size_is (failureCount), retval] out string failures); */
62106: /* XPConnect method of returning arrays is very ugly. Would not recommend. Fallable nsMemory::Alloc makes things worse */
62106: NS_IMETHODIMP GfxInfoBase::GetFailures(PRUint32 *failureCount NS_OUTPARAM, char ***failures NS_OUTPARAM)
62106: {
62106: 
62106:   NS_ENSURE_ARG_POINTER(failureCount);
62106:   NS_ENSURE_ARG_POINTER(failures);
62106: 
62106:   *failures = nsnull;
62106:   *failureCount = mFailureCount;
62106: 
62106:   if (*failureCount != 0) {
62106:     *failures = (char**)nsMemory::Alloc(*failureCount * sizeof(char*));
62106:     if (!failures)
62106:       return NS_ERROR_OUT_OF_MEMORY;
62106: 
62106:     /* copy over the failure messages into the array we just allocated */
62106:     for (PRUint32 i = 0; i < *failureCount; i++) {
62106:       nsPromiseFlatCString flattenedFailureMessage(mFailures[i]);
62106:       (*failures)[i] = (char*)nsMemory::Clone(flattenedFailureMessage.get(), flattenedFailureMessage.Length() + 1);
62106: 
62106:       if (!(*failures)[i]) {
62106:         /* <sarcasm> I'm too afraid to use an inline function... </sarcasm> */
62106:         NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(i, (*failures));
62106:         return NS_ERROR_OUT_OF_MEMORY;
62106:       }
62106:     }
62106:   }
62106: 
62106:   return NS_OK;
62106: }
