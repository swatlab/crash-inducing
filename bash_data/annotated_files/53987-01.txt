53962: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
53962: /* vim: set sw=4 ts=8 et tw=80 : */
53962: /*
43113:  * ***** BEGIN LICENSE BLOCK *****
43113:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43113:  *
43113:  * The contents of this file are subject to the Mozilla Public License Version
43113:  * 1.1 (the "License"); you may not use this file except in compliance with
43113:  * the License. You may obtain a copy of the License at
43113:  * http://www.mozilla.org/MPL/
43113:  *
43113:  * Software distributed under the License is distributed on an "AS IS" basis,
43113:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43113:  * for the specific language governing rights and limitations under the
43113:  * License.
43113:  *
43113:  * The Original Code is nsCacheService.cpp, released
43113:  * February 10, 2001.
43113:  *
43113:  * The Initial Developer of the Original Code is
43113:  * Netscape Communications Corporation.
43113:  * Portions created by the Initial Developer are Copyright (C) 2001
43113:  * the Initial Developer. All Rights Reserved.
43113:  *
43113:  * Contributor(s):
43113:  *   Gordon Sheridan, 10-February-2001
43113:  *   Michael Ventnor <m.ventnor@gmail.com>
43113:  *   Ehsan Akhgari <ehsan.akhgari@gmail.com>
43113:  *
43113:  * Alternatively, the contents of this file may be used under the terms of
43113:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43113:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43113:  * in which case the provisions of the GPL or the LGPL are applicable instead
43113:  * of those above. If you wish to allow use of your version of this file only
43113:  * under the terms of either the GPL or the LGPL, and not to allow others to
43113:  * use your version of this file under the terms of the MPL, indicate your
43113:  * decision by deleting the provisions above and replace them with the notice
43113:  * and other provisions required by the GPL or the LGPL. If you do not delete
43113:  * the provisions above, a recipient may use your version of this file under
43113:  * the terms of any one of the MPL, the GPL or the LGPL.
43113:  *
43113:  * ***** END LICENSE BLOCK ***** */
43113: 
43113: #include "necko-config.h"
43113: 
43113: #include "nsCache.h"
43113: #include "nsCacheService.h"
43113: #include "nsCacheRequest.h"
43113: #include "nsCacheEntry.h"
43113: #include "nsCacheEntryDescriptor.h"
43113: #include "nsCacheDevice.h"
43113: #include "nsMemoryCacheDevice.h"
43113: #include "nsICacheVisitor.h"
43113: #include "nsDiskCacheDevice.h"
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113: #include "nsDiskCacheDeviceSQL.h"
43113: #endif
43113: 
43113: #include "nsIObserverService.h"
43113: #include "nsIPrefService.h"
43113: #include "nsIPrefBranch.h"
43113: #include "nsIPrefBranch2.h"
43113: #include "nsILocalFile.h"
43113: #include "nsIOService.h"
43113: #include "nsDirectoryServiceDefs.h"
43113: #include "nsAppDirectoryServiceDefs.h"
43113: #include "nsThreadUtils.h"
43113: #include "nsProxyRelease.h"
43113: #include "nsVoidArray.h"
43113: #include "nsDeleteDir.h"
43113: #include "nsIPrivateBrowsingService.h"
43113: #include "nsNetCID.h"
43113: #include <math.h>  // for log()
43113: #include "mozilla/Services.h"
43113: 
43113: #include "mozilla/FunctionTimer.h"
43113: 
43113: /******************************************************************************
43113:  * nsCacheProfilePrefObserver
43113:  *****************************************************************************/
43113: #ifdef XP_MAC
43113: #pragma mark nsCacheProfilePrefObserver
43113: #endif
43113: 
43113: #define DISK_CACHE_ENABLE_PREF      "browser.cache.disk.enable"
43113: #define DISK_CACHE_DIR_PREF         "browser.cache.disk.parent_directory"
53961: #define DISK_CACHE_SMART_SIZE_FIRST_RUN_PREF\
53961:     "browser.cache.disk.smart_size.first_run"
53961: #define DISK_CACHE_SMART_SIZE_ENABLED_PREF \
53961:     "browser.cache.disk.smart_size.enabled"
53961: #define DISK_CACHE_SMART_SIZE_PREF "browser.cache.disk.smart_size_cached_value"
43113: #define DISK_CACHE_CAPACITY_PREF    "browser.cache.disk.capacity"
43113: #define DISK_CACHE_MAX_ENTRY_SIZE_PREF "browser.cache.disk.max_entry_size"
50382: #define DISK_CACHE_CAPACITY         256000
43113: 
43113: #define OFFLINE_CACHE_ENABLE_PREF   "browser.cache.offline.enable"
43113: #define OFFLINE_CACHE_DIR_PREF      "browser.cache.offline.parent_directory"
43113: #define OFFLINE_CACHE_CAPACITY_PREF "browser.cache.offline.capacity"
43113: #define OFFLINE_CACHE_CAPACITY      512000
43113: 
43113: #define MEMORY_CACHE_ENABLE_PREF    "browser.cache.memory.enable"
43113: #define MEMORY_CACHE_CAPACITY_PREF  "browser.cache.memory.capacity"
43113: #define MEMORY_CACHE_MAX_ENTRY_SIZE_PREF "browser.cache.memory.max_entry_size"
43113: 
43113: static const char * observerList[] = { 
43113:     "profile-before-change",
43113:     "profile-after-change",
43113:     NS_XPCOM_SHUTDOWN_OBSERVER_ID,
43113:     NS_PRIVATE_BROWSING_SWITCH_TOPIC
43113: };
43113: static const char * prefList[] = { 
43113: #ifdef NECKO_DISK_CACHE
43113:     DISK_CACHE_ENABLE_PREF,
53961:     DISK_CACHE_SMART_SIZE_ENABLED_PREF,
43113:     DISK_CACHE_CAPACITY_PREF,
43113:     DISK_CACHE_DIR_PREF,
43113: #endif
43113: #ifdef NECKO_OFFLINE_CACHE
43113:     OFFLINE_CACHE_ENABLE_PREF,
43113:     OFFLINE_CACHE_CAPACITY_PREF,
43113:     OFFLINE_CACHE_DIR_PREF,
43113: #endif
43113:     MEMORY_CACHE_ENABLE_PREF,
43113:     MEMORY_CACHE_CAPACITY_PREF
43113: };
43113: 
53961: // Let our base line be 250MB. 
53961: const PRInt32 BASE_LINE = 250 * 1024 * 1024;
53961: const PRInt32 MIN_SIZE = 50 * 1024 * 1024;
53961: const PRInt32 MAX_SIZE = 1024 * 1024 * 1024;
53961: 
53961: 
43113: class nsCacheProfilePrefObserver : public nsIObserver
43113: {
43113: public:
43113:     NS_DECL_ISUPPORTS
43113:     NS_DECL_NSIOBSERVER
43113: 
43113:     nsCacheProfilePrefObserver()
43113:         : mHaveProfile(PR_FALSE)
43113:         , mDiskCacheEnabled(PR_FALSE)
43113:         , mDiskCacheCapacity(0)
43113:         , mOfflineCacheEnabled(PR_FALSE)
43113:         , mOfflineCacheCapacity(0)
43113:         , mMemoryCacheEnabled(PR_TRUE)
43113:         , mMemoryCacheCapacity(-1)
43113:         , mInPrivateBrowsing(PR_FALSE)
43113:     {
43113:     }
43113: 
43113:     virtual ~nsCacheProfilePrefObserver() {}
43113:     
43113:     nsresult        Install();
43113:     void            Remove();
43113:     nsresult        ReadPrefs(nsIPrefBranch* branch);
43113:     
43113:     PRBool          DiskCacheEnabled();
43113:     PRInt32         DiskCacheCapacity()         { return mDiskCacheCapacity; }
53961:     void            SetDiskCacheCapacity(PRInt32);
43113:     nsILocalFile *  DiskCacheParentDirectory()  { return mDiskCacheParentDirectory; }
43113: 
43113:     PRBool          OfflineCacheEnabled();
43113:     PRInt32         OfflineCacheCapacity()         { return mOfflineCacheCapacity; }
43113:     nsILocalFile *  OfflineCacheParentDirectory()  { return mOfflineCacheParentDirectory; }
43113:     
43113:     PRBool          MemoryCacheEnabled();
43113:     PRInt32         MemoryCacheCapacity();
43113: 
53961:     static PRUint32 GetSmartCacheSize(void);
53961: 
43113: private:
53961:     bool                    PermittedToSmartSize(nsIPrefBranch*, PRBool firstRun);
43113:     PRBool                  mHaveProfile;
43113:     
43113:     PRBool                  mDiskCacheEnabled;
43113:     PRInt32                 mDiskCacheCapacity; // in kilobytes
43113:     nsCOMPtr<nsILocalFile>  mDiskCacheParentDirectory;
43113: 
43113:     PRBool                  mOfflineCacheEnabled;
43113:     PRInt32                 mOfflineCacheCapacity; // in kilobytes
43113:     nsCOMPtr<nsILocalFile>  mOfflineCacheParentDirectory;
43113:     
43113:     PRBool                  mMemoryCacheEnabled;
43113:     PRInt32                 mMemoryCacheCapacity; // in kilobytes
43113: 
43113:     PRBool                  mInPrivateBrowsing;
43113: };
43113: 
53961: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCacheProfilePrefObserver, nsIObserver)
53961: 
53961: // Runnable sent to main thread after the cache IO thread calculates available
53961: // disk space, so that there is no race in setting mDiskCacheCapacity.
53961: class nsSetSmartSizeEvent: public nsRunnable 
53961: {
53961: public:
53962:     nsSetSmartSizeEvent(bool firstRun, PRInt32 smartSize) 
53962:         : mFirstRun(firstRun) , mSmartSize(smartSize) {}
53961: 
53961:     NS_IMETHOD Run() 
53961:     {
53961:         nsresult rv;
53961:         NS_ASSERTION(NS_IsMainThread(), 
53961:                      "Setting smart size data off the main thread");
53962: 
53962:         // Main thread may have already called nsCacheService::Shutdown
53962:         if (!nsCacheService::gService || !nsCacheService::gService->mObserver)
53962:             return NS_ERROR_NOT_AVAILABLE;
53962:     
53961:         PRBool smartSizeEnabled;
53962:         nsCOMPtr<nsIPrefBranch2> branch = do_GetService(NS_PREFSERVICE_CONTRACTID);
53962:         if (!branch) {
53962:             NS_WARNING("Failed to get pref service!");
53962:             return NS_ERROR_NOT_AVAILABLE;
53962:         }
53962:         // ensure smart sizing wasn't switched off while event was pending
53962:         rv = branch->GetBoolPref(DISK_CACHE_SMART_SIZE_ENABLED_PREF,
53961:                                  &smartSizeEnabled);
53962:         if (NS_FAILED(rv)) 
53962:             smartSizeEnabled = PR_FALSE;
53961:         if (smartSizeEnabled) {
53961:             nsCacheService::SetDiskCacheCapacity(mSmartSize);
53962:             // also set on observer, in case mDiskDevice not init'd yet.
53962:             nsCacheService::gService->mObserver->SetDiskCacheCapacity(mSmartSize);
53962:             rv = branch->SetIntPref(DISK_CACHE_SMART_SIZE_PREF, mSmartSize);
53962:             if (NS_FAILED(rv)) 
53962:                 NS_WARNING("Failed to set smart size pref");
53961:         }
53961:         return rv;
53961:     }
53961: 
53961: private: 
53961:     bool mFirstRun;
53961:     PRInt32 mSmartSize;
53961: };
53961: 
53961: 
53961: // Runnable sent from main thread to cacheIO thread
53961: class nsGetSmartSizeEvent: public nsRunnable
53961: {
53961: public:
53962:     nsGetSmartSizeEvent(bool firstRun) : mFirstRun(firstRun) , mSmartSize(0) {}
53961:    
53961:     // Calculates user's disk space available on a background thread and
53961:     // dispatches this value back to the main thread.
53961:     NS_IMETHOD Run()
53961:     {
53961:         mSmartSize = nsCacheProfilePrefObserver::GetSmartCacheSize() / 1024;
53961:         nsCOMPtr<nsIRunnable> event = new nsSetSmartSizeEvent(mFirstRun,
53962:                                                               mSmartSize);
53961:         NS_DispatchToMainThread(event);
53961:         return NS_OK;
53961:     }
53961: 
53961: private: 
53961:     bool mFirstRun;
53961:     PRInt32 mSmartSize;
53961: };
43113: 
43113: 
43113: nsresult
43113: nsCacheProfilePrefObserver::Install()
43113: {
43113:     // install profile-change observer
43113:     nsCOMPtr<nsIObserverService> observerService =
43113:         mozilla::services::GetObserverService();
43113:     if (!observerService)
43113:         return NS_ERROR_FAILURE;
43113:     
43113:     nsresult rv, rv2 = NS_OK;
43113:     for (unsigned int i=0; i<NS_ARRAY_LENGTH(observerList); i++) {
43113:         rv = observerService->AddObserver(this, observerList[i], PR_FALSE);
43113:         if (NS_FAILED(rv)) 
43113:             rv2 = rv;
43113:     }
43113:     
43113:     // install preferences observer
43113:     nsCOMPtr<nsIPrefBranch2> branch = do_GetService(NS_PREFSERVICE_CONTRACTID);
43113:     if (!branch) return NS_ERROR_FAILURE;
43113: 
43113:     for (unsigned int i=0; i<NS_ARRAY_LENGTH(prefList); i++) {
43113:         rv = branch->AddObserver(prefList[i], this, PR_FALSE);
43113:         if (NS_FAILED(rv))
43113:             rv2 = rv;
43113:     }
43113: 
43113:     // determine the initial status of the private browsing mode
43113:     nsCOMPtr<nsIPrivateBrowsingService> pbs =
43113:       do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
43113:     if (pbs)
43113:       pbs->GetPrivateBrowsingEnabled(&mInPrivateBrowsing);
43113: 
43113:     // Determine if we have a profile already
43113:     //     Install() is called *after* the profile-after-change notification
43113:     //     when there is only a single profile, or it is specified on the
43113:     //     commandline at startup.
43113:     //     In that case, we detect the presence of a profile by the existence
43113:     //     of the NS_APP_USER_PROFILE_50_DIR directory.
43113: 
43113:     nsCOMPtr<nsIFile> directory;
43113:     rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
43113:                                 getter_AddRefs(directory));
43113:     if (NS_SUCCEEDED(rv))
43113:         mHaveProfile = PR_TRUE;
43113: 
43113:     rv = ReadPrefs(branch);
43113:     NS_ENSURE_SUCCESS(rv, rv);
43113: 
43113:     return rv2;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheProfilePrefObserver::Remove()
43113: {
43113:     // remove Observer Service observers
43113:     nsCOMPtr<nsIObserverService> obs =
43113:         mozilla::services::GetObserverService();
43113:     if (obs) {
43113:         for (unsigned int i=0; i<NS_ARRAY_LENGTH(observerList); i++) {
43113:             obs->RemoveObserver(this, observerList[i]);
43113:         }
43113:     }
43113: 
43113:     // remove Pref Service observers
43113:     nsCOMPtr<nsIPrefBranch2> prefs =
43113:         do_GetService(NS_PREFSERVICE_CONTRACTID);
43113:     if (!prefs)
43113:         return;
43113:     for (unsigned int i=0; i<NS_ARRAY_LENGTH(prefList); i++)
43113:         prefs->RemoveObserver(prefList[i], this); // remove cache pref observers
43113: }
43113: 
53961: void
53961: nsCacheProfilePrefObserver::SetDiskCacheCapacity(PRInt32 capacity)
53961: {
53961:     mDiskCacheCapacity = PR_MAX(0, capacity);
53961: }
53961: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheProfilePrefObserver::Observe(nsISupports *     subject,
43113:                                     const char *      topic,
43113:                                     const PRUnichar * data_unicode)
43113: {
43113:     nsresult rv;
43113:     NS_ConvertUTF16toUTF8 data(data_unicode);
43113:     CACHE_LOG_ALWAYS(("Observe [topic=%s data=%s]\n", topic, data.get()));
43113: 
43113:     if (!strcmp(NS_XPCOM_SHUTDOWN_OBSERVER_ID, topic)) {
43113:         // xpcom going away, shutdown cache service
43113:         if (nsCacheService::GlobalInstance())
43113:             nsCacheService::GlobalInstance()->Shutdown();
43113:     
43113:     } else if (!strcmp("profile-before-change", topic)) {
43113:         // profile before change
43113:         mHaveProfile = PR_FALSE;
43113: 
43113:         // XXX shutdown devices
43113:         nsCacheService::OnProfileShutdown(!strcmp("shutdown-cleanse",
43113:                                                   data.get()));
43113:         
43113:     } else if (!strcmp("profile-after-change", topic)) {
43113:         // profile after change
43113:         mHaveProfile = PR_TRUE;
43113:         nsCOMPtr<nsIPrefBranch> branch = do_GetService(NS_PREFSERVICE_CONTRACTID);
43113:         ReadPrefs(branch);
43113:         nsCacheService::OnProfileChanged();
43113:     
43113:     } else if (!strcmp(NS_PREFBRANCH_PREFCHANGE_TOPIC_ID, topic)) {
43113: 
43113:         // ignore pref changes until we're done switch profiles
43113:         if (!mHaveProfile)  return NS_OK;
43113: 
43113:         nsCOMPtr<nsIPrefBranch> branch = do_QueryInterface(subject, &rv);
43113:         if (NS_FAILED(rv))  return rv;
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:         // which preference changed?
43113:         if (!strcmp(DISK_CACHE_ENABLE_PREF, data.get())) {
43113: 
43113:             if (!mInPrivateBrowsing) {
43113:                 rv = branch->GetBoolPref(DISK_CACHE_ENABLE_PREF,
43113:                                          &mDiskCacheEnabled);
43113:                 if (NS_FAILED(rv))  return rv;
43113:                 nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
43113:             }
43113: 
43113:         } else if (!strcmp(DISK_CACHE_CAPACITY_PREF, data.get())) {
43113: 
43113:             PRInt32 capacity = 0;
43113:             rv = branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &capacity);
43113:             if (NS_FAILED(rv))  return rv;
43113:             mDiskCacheCapacity = PR_MAX(0, capacity);
43113:             nsCacheService::SetDiskCacheCapacity(mDiskCacheCapacity);
53961:        
53961:         // Update the cache capacity when smart sizing is turned on/off 
53961:         } else if (!strcmp(DISK_CACHE_SMART_SIZE_ENABLED_PREF, data.get())) {
53961:             // Is the update because smartsizing was turned on, or off?
53961:             PRBool smartSizeEnabled;
53961:             rv = branch->GetBoolPref(DISK_CACHE_SMART_SIZE_ENABLED_PREF,
53961:                                      &smartSizeEnabled);
53961:             if (NS_FAILED(rv)) return rv;
53961:             PRInt32 newCapacity = 0;
53961:             if (smartSizeEnabled) {
53961:                 // Smart sizing switched on: recalculate the capacity.
53962:                 nsCOMPtr<nsIRunnable> event = new nsGetSmartSizeEvent(false);
53961:                 rv = nsCacheService::DispatchToCacheIOThread(event);
53961:                 // If the dispatch failed, just use our base line for the size
53961:                 if (NS_FAILED(rv)) mDiskCacheCapacity = BASE_LINE;
53961:             } else {
53961:                 // Smart sizing switched off: use user specified size
53961:                 rv = branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &newCapacity);
53961:                 if (NS_FAILED(rv)) return rv;
53961:                 mDiskCacheCapacity = PR_MAX(0, newCapacity);
53961:                 nsCacheService::SetDiskCacheCapacity(mDiskCacheCapacity);
53961:             } 
53961:             
53961:                
43113: #if 0            
43113:         } else if (!strcmp(DISK_CACHE_DIR_PREF, data.get())) {
43113:             // XXX We probaby don't want to respond to this pref except after
43113:             // XXX profile changes.  Ideally, there should be somekind of user
43113:             // XXX notification that the pref change won't take effect until
43113:             // XXX the next time the profile changes (browser launch)
43113: #endif            
43113:         } else 
43113: #endif // !NECKO_DISK_CACHE
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:         // which preference changed?
43113:         if (!strcmp(OFFLINE_CACHE_ENABLE_PREF, data.get())) {
43113: 
43113:             if (!mInPrivateBrowsing) {
43113:                 rv = branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
43113:                                          &mOfflineCacheEnabled);
43113:                 if (NS_FAILED(rv))  return rv;
43113:                 nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
43113:             }
43113: 
43113:         } else if (!strcmp(OFFLINE_CACHE_CAPACITY_PREF, data.get())) {
43113: 
43113:             PRInt32 capacity = 0;
43113:             rv = branch->GetIntPref(OFFLINE_CACHE_CAPACITY_PREF, &capacity);
43113:             if (NS_FAILED(rv))  return rv;
43113:             mOfflineCacheCapacity = PR_MAX(0, capacity);
43113:             nsCacheService::SetOfflineCacheCapacity(mOfflineCacheCapacity);
43113: #if 0
43113:         } else if (!strcmp(OFFLINE_CACHE_DIR_PREF, data.get())) {
43113:             // XXX We probaby don't want to respond to this pref except after
43113:             // XXX profile changes.  Ideally, there should be some kind of user
43113:             // XXX notification that the pref change won't take effect until
43113:             // XXX the next time the profile changes (browser launch)
43113: #endif
43113:         } else
43113: #endif // !NECKO_OFFLINE_CACHE
43113: 
43113:         if (!strcmp(MEMORY_CACHE_ENABLE_PREF, data.get())) {
43113: 
43113:             rv = branch->GetBoolPref(MEMORY_CACHE_ENABLE_PREF,
43113:                                      &mMemoryCacheEnabled);
43113:             if (NS_FAILED(rv))  return rv;
43113:             nsCacheService::SetMemoryCache();
43113:             
43113:         } else if (!strcmp(MEMORY_CACHE_CAPACITY_PREF, data.get())) {
43113: 
43113:             mMemoryCacheCapacity = -1;
43113:             (void) branch->GetIntPref(MEMORY_CACHE_CAPACITY_PREF,
43113:                                       &mMemoryCacheCapacity);
43113:             nsCacheService::SetMemoryCache();
43113:         }
43113:     } else if (!strcmp(NS_PRIVATE_BROWSING_SWITCH_TOPIC, topic)) {
43113:         if (!strcmp(NS_PRIVATE_BROWSING_ENTER, data.get())) {
43113:             mInPrivateBrowsing = PR_TRUE;
43113: 
43113:             nsCacheService::OnEnterExitPrivateBrowsing();
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:             mDiskCacheEnabled = PR_FALSE;
43113:             nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
43113: #endif // !NECKO_DISK_CACHE
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:             mOfflineCacheEnabled = PR_FALSE;
43113:             nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
43113: #endif // !NECKO_OFFLINE_CACHE
43113:         } else if (!strcmp(NS_PRIVATE_BROWSING_LEAVE, data.get())) {
43113:             mInPrivateBrowsing = PR_FALSE;
43113: 
43113:             nsCacheService::OnEnterExitPrivateBrowsing();
43113: 
43113: #if defined(NECKO_DISK_CACHE) || defined(NECKO_OFFLINE_CACHE)
43113:             nsCOMPtr<nsIPrefBranch> branch = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
43113:             if (NS_FAILED(rv))  return rv;
43113: #endif // !NECKO_DISK_CACHE && !NECKO_OFFLINE_CACHE
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:             mDiskCacheEnabled = PR_TRUE; // by default enabled
43113:             (void) branch->GetBoolPref(DISK_CACHE_ENABLE_PREF,
43113:                                        &mDiskCacheEnabled);
43113:             nsCacheService::SetDiskCacheEnabled(DiskCacheEnabled());
43113: #endif // !NECKO_DISK_CACHE
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:             mOfflineCacheEnabled = PR_TRUE; // by default enabled
43113:             (void) branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
43113:                                        &mOfflineCacheEnabled);
43113:             nsCacheService::SetOfflineCacheEnabled(OfflineCacheEnabled());
43113: #endif // !NECKO_OFFLINE_CACHE
43113:         }
43113:     }
43113:     
43113:     return NS_OK;
43113: }
43113:  
43113:  
53961: 
53961:  /* Computes our best guess for the default size of the user's disk cache, 
53961:   * based on the amount of space they have free on their hard drive. 
53961:   * We use a tiered scheme: the more space available, 
53961:   * the larger the disk cache will be. However, we do not want
53961:   * to enable the disk cache to grow to an unbounded size, so the larger the
53961:   * user's available space is, the smaller of a percentage we take. We set a
53961:   * lower bound of 50MB and an upper bound of 1GB.  
53961:   *
53961:   *@param:  None.
53961:   *@return: The size that the user's disk cache should default to, in bytes.
53961:   */
53961: PRUint32
53961: nsCacheProfilePrefObserver::GetSmartCacheSize(void) {
53961:   // Get a handle to disk where cache lives, so we can check for free space
53961:   nsresult rv;
53961:   nsCOMPtr<nsIFile> profileDirectory;
53961:   rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
53961:                               getter_AddRefs(profileDirectory));
53961:   if (NS_FAILED(rv)) { 
53961:     return BASE_LINE;
53961:   }
53961:   nsCOMPtr<nsILocalFile> diskHandle = do_QueryInterface(profileDirectory);
53961:   PRInt64 bytesAvailable;
53961:   diskHandle->GetDiskSpaceAvailable(&bytesAvailable);
53961:   
53961:   /* 0MB <= Available < 500MB
53961:    * Use between 50MB  and 200MB
53961:    */ 
53961:   if (bytesAvailable < BASE_LINE * 2) {
53961:     return PR_MAX(MIN_SIZE, bytesAvailable * 4 / 10);
53961:   }
53961:   
53961:   /* 500MB <= Available < 2500MB
53961:    * Use 250MB 
53961:    */
53961:   if (bytesAvailable < static_cast<PRInt64>(BASE_LINE) * 10) {
53961:     return BASE_LINE;
53961:   }
53961: 
53961:   /* 2500MB <= Available < 5000MB 
53961:    * Use between 250MB and 500MB
53961:    */
53961:   if (bytesAvailable < static_cast<PRInt64>(BASE_LINE) * 20) {
53961:     return bytesAvailable / 10;
53961:   }
53961: 
53961:   /* 5000MB <= Available < 50000MB 
53961:    * Use 625MB
53961:    */
53961:   if (bytesAvailable < static_cast<PRInt64>(BASE_LINE) * 200 ) {
53961:     return BASE_LINE * 5 / 2;
53961:   }
53961: 
53961:   /* 50000MB <= Available < 75000MB
53961:    * Use 800MB
53961:    */
53961:   if (bytesAvailable < static_cast<PRInt64>(BASE_LINE) * 300) {
53961:     return BASE_LINE / 5 * 16;  
53961:   }
53961:   
53961:   /* We have come within range of the ceiling
53961:    * Use 1GB
53961:    */
53961:   return MAX_SIZE;
53961: }
53961: 
53961: /* Determine if we are permitted to dynamically size the user's disk cache based
53961:  * on their disk space available. We may do this so long as the pref 
53961:  * smart_size.enabled is true.
53961:  */
53961: bool
53961: nsCacheProfilePrefObserver::PermittedToSmartSize(nsIPrefBranch* branch, PRBool
53961:                                                  firstRun)
53961: {
53961:     nsresult rv;
53961:     // If user has explicitly set cache size to be smaller than previous default
53961:     // of 250MB, then smart sizing is off by default. Otherwise, smart sizing is
53961:     // on by default.
53961:     if (firstRun) {
53961:         // check if user has set cache size in the past
53961:         PRBool userSet;
53961:         rv = branch->PrefHasUserValue(DISK_CACHE_CAPACITY_PREF, &userSet);
53961:         if (NS_FAILED(rv)) userSet = PR_TRUE;
53961:         if (userSet) {
53961:             PRInt32 oldCapacity;
53961:             rv = branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &oldCapacity);
53961:             if (oldCapacity < BASE_LINE / 1024) {
53961:                 branch->SetBoolPref(DISK_CACHE_SMART_SIZE_ENABLED_PREF, 
53961:                                     PR_FALSE);
53961:                 return false;
53961:             }
53961:         }
53961:     }
53961:     PRBool smartSizeEnabled; 
53961:     rv = branch->GetBoolPref(DISK_CACHE_SMART_SIZE_ENABLED_PREF,
53961:                              &smartSizeEnabled);
53961:     if (NS_FAILED(rv)) return false;
53961:     return !!smartSizeEnabled;
53961: }
53961: 
53961: 
43113: nsresult
43113: nsCacheProfilePrefObserver::ReadPrefs(nsIPrefBranch* branch)
43113: {
43113:     nsresult rv = NS_OK;
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:     // read disk cache device prefs
43113:     if (!mInPrivateBrowsing) {
43113:         mDiskCacheEnabled = PR_TRUE;  // presume disk cache is enabled
43113:         (void) branch->GetBoolPref(DISK_CACHE_ENABLE_PREF, &mDiskCacheEnabled);
43113:     }
43113: 
43113:     mDiskCacheCapacity = DISK_CACHE_CAPACITY;
43113:     (void)branch->GetIntPref(DISK_CACHE_CAPACITY_PREF, &mDiskCacheCapacity);
43113:     mDiskCacheCapacity = PR_MAX(0, mDiskCacheCapacity);
43113: 
43113:     (void) branch->GetComplexValue(DISK_CACHE_DIR_PREF,     // ignore error
43113:                                    NS_GET_IID(nsILocalFile),
43113:                                    getter_AddRefs(mDiskCacheParentDirectory));
43113:     
43113:     if (!mDiskCacheParentDirectory) {
43113:         nsCOMPtr<nsIFile>  directory;
43113: 
43113:         // try to get the disk cache parent directory
43113:         rv = NS_GetSpecialDirectory(NS_APP_CACHE_PARENT_DIR,
43113:                                     getter_AddRefs(directory));
43113:         if (NS_FAILED(rv)) {
43113:             // try to get the profile directory (there may not be a profile yet)
43113:             nsCOMPtr<nsIFile> profDir;
43113:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
43113:                                    getter_AddRefs(profDir));
43113:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_LOCAL_50_DIR,
43113:                                    getter_AddRefs(directory));
43113:             if (!directory)
43113:                 directory = profDir;
43113:             else if (profDir) {
43113:                 PRBool same;
43113:                 if (NS_SUCCEEDED(profDir->Equals(directory, &same)) && !same) {
43113:                     // We no longer store the cache directory in the main
43113:                     // profile directory, so we should cleanup the old one.
43113:                     rv = profDir->AppendNative(NS_LITERAL_CSTRING("Cache"));
43113:                     if (NS_SUCCEEDED(rv)) {
43113:                         PRBool exists;
43113:                         if (NS_SUCCEEDED(profDir->Exists(&exists)) && exists)
43113:                             DeleteDir(profDir, PR_FALSE, PR_FALSE);
43113:                     }
43113:                 }
43113:             }
43113:         }
43113:         // use file cache in build tree only if asked, to avoid cache dir litter
43113:         if (!directory && PR_GetEnv("NECKO_DEV_ENABLE_DISK_CACHE")) {
43113:             rv = NS_GetSpecialDirectory(NS_XPCOM_CURRENT_PROCESS_DIR,
43113:                                         getter_AddRefs(directory));
43113:         }
43113:         if (directory)
43113:             mDiskCacheParentDirectory = do_QueryInterface(directory, &rv);
43113:     }
53961:     if (mDiskCacheParentDirectory) {
53961:         PRBool firstSmartSizeRun;
53961:         rv = branch->GetBoolPref(DISK_CACHE_SMART_SIZE_FIRST_RUN_PREF, 
53961:                                  &firstSmartSizeRun); 
53961:         if (NS_FAILED(rv)) firstSmartSizeRun = PR_FALSE;
53961:         if (PermittedToSmartSize(branch, firstSmartSizeRun)) {
53961:             // Prevent unnecessary eviction before smart size event returns 
53961:             if (!firstSmartSizeRun) {
53961:                 PRInt32 oldSmartSize;
53961:                 rv = branch->GetIntPref(DISK_CACHE_SMART_SIZE_PREF,
53961:                                         &oldSmartSize);
53961:                 mDiskCacheCapacity = oldSmartSize;
53961:             } else {
53961:                 rv = branch->SetIntPref(DISK_CACHE_CAPACITY_PREF, 
53961:                                         MAX_SIZE / 1024);
53961:                 if (NS_FAILED(rv)) NS_WARNING("Failed setting capacity pref");
53961:             }
53961:             nsCOMPtr<nsIRunnable> event = 
53962:                 new nsGetSmartSizeEvent(!!firstSmartSizeRun);
53961:             rv = nsCacheService::DispatchToCacheIOThread(event);
53961:             if (NS_FAILED(rv)) mDiskCacheCapacity = BASE_LINE;
53961:         }
53961: 
53961:         if (firstSmartSizeRun) {
53961:             // It is no longer our first run
53961:             rv = branch->SetBoolPref(DISK_CACHE_SMART_SIZE_FIRST_RUN_PREF, 
53961:                                      PR_FALSE);
53961:             if (NS_FAILED(rv)) 
53961:                 NS_WARNING("Failed setting first_run pref in ReadPrefs.");
53961:         }
53961:     }
43113: #endif // !NECKO_DISK_CACHE
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:     // read offline cache device prefs
43113:     if (!mInPrivateBrowsing) {
43113:         mOfflineCacheEnabled = PR_TRUE;  // presume offline cache is enabled
43113:         (void) branch->GetBoolPref(OFFLINE_CACHE_ENABLE_PREF,
43113:                                    &mOfflineCacheEnabled);
43113:     }
43113: 
43113:     mOfflineCacheCapacity = OFFLINE_CACHE_CAPACITY;
43113:     (void)branch->GetIntPref(OFFLINE_CACHE_CAPACITY_PREF,
43113:                              &mOfflineCacheCapacity);
43113:     mOfflineCacheCapacity = PR_MAX(0, mOfflineCacheCapacity);
43113: 
43113:     (void) branch->GetComplexValue(OFFLINE_CACHE_DIR_PREF,     // ignore error
43113:                                    NS_GET_IID(nsILocalFile),
43113:                                    getter_AddRefs(mOfflineCacheParentDirectory));
43113: 
43113:     if (!mOfflineCacheParentDirectory) {
43113:         nsCOMPtr<nsIFile>  directory;
43113: 
43113:         // try to get the offline cache parent directory
43113:         rv = NS_GetSpecialDirectory(NS_APP_CACHE_PARENT_DIR,
43113:                                     getter_AddRefs(directory));
43113:         if (NS_FAILED(rv)) {
43113:             // try to get the profile directory (there may not be a profile yet)
43113:             nsCOMPtr<nsIFile> profDir;
43113:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
43113:                                    getter_AddRefs(profDir));
43113:             NS_GetSpecialDirectory(NS_APP_USER_PROFILE_LOCAL_50_DIR,
43113:                                    getter_AddRefs(directory));
43113:             if (!directory)
43113:                 directory = profDir;
43113:         }
43113: #if DEBUG
43113:         if (!directory) {
43113:             // use current process directory during development
43113:             rv = NS_GetSpecialDirectory(NS_XPCOM_CURRENT_PROCESS_DIR,
43113:                                         getter_AddRefs(directory));
43113:         }
43113: #endif
43113:         if (directory)
43113:             mOfflineCacheParentDirectory = do_QueryInterface(directory, &rv);
43113:     }
43113: #endif // !NECKO_OFFLINE_CACHE
43113:     
43113:     // read memory cache device prefs
43113:     (void) branch->GetBoolPref(MEMORY_CACHE_ENABLE_PREF, &mMemoryCacheEnabled);
43113: 
43113:     mMemoryCacheCapacity = -1;
43113:     (void) branch->GetIntPref(MEMORY_CACHE_CAPACITY_PREF,
43113:                               &mMemoryCacheCapacity);
43113:         
43113:     return rv;
43113: }
43113: 
53961: nsresult
53961: nsCacheService::DispatchToCacheIOThread(nsIRunnable* event)
53961: {
53961:     if (!gService->mCacheIOThread) return NS_ERROR_NOT_AVAILABLE;
53961:     return gService->mCacheIOThread->Dispatch(event, NS_DISPATCH_NORMAL);
53961: }
53961: 
43113: 
43113: PRBool
43113: nsCacheProfilePrefObserver::DiskCacheEnabled()
43113: {
43113:     if ((mDiskCacheCapacity == 0) || (!mDiskCacheParentDirectory))  return PR_FALSE;
43113:     return mDiskCacheEnabled;
43113: }
43113: 
43113: 
43113: PRBool
43113: nsCacheProfilePrefObserver::OfflineCacheEnabled()
43113: {
43113:     if ((mOfflineCacheCapacity == 0) || (!mOfflineCacheParentDirectory))
43113:         return PR_FALSE;
43113: 
43113:     return mOfflineCacheEnabled;
43113: }
43113: 
43113: 
43113: PRBool
43113: nsCacheProfilePrefObserver::MemoryCacheEnabled()
43113: {
43113:     if (mMemoryCacheCapacity == 0)  return PR_FALSE;
43113:     return mMemoryCacheEnabled;
43113: }
43113: 
43113: 
43113: /**
43113:  * MemoryCacheCapacity
43113:  *
43113:  * If the browser.cache.memory.capacity preference is positive, we use that
43113:  * value for the amount of memory available for the cache.
43113:  *
43113:  * If browser.cache.memory.capacity is zero, the memory cache is disabled.
43113:  * 
43113:  * If browser.cache.memory.capacity is negative or not present, we use a
43113:  * formula that grows less than linearly with the amount of system memory, 
43113:  * with an upper limit on the cache size. No matter how much physical RAM is
43113:  * present, the default cache size would not exceed 32 MB. This maximum would
43113:  * apply only to systems with more than 4 GB of RAM (e.g. terminal servers)
43113:  *
43113:  *   RAM   Cache
43113:  *   ---   -----
43113:  *   32 Mb   2 Mb
43113:  *   64 Mb   4 Mb
43113:  *  128 Mb   6 Mb
43113:  *  256 Mb  10 Mb
43113:  *  512 Mb  14 Mb
43113:  * 1024 Mb  18 Mb
43113:  * 2048 Mb  24 Mb
43113:  * 4096 Mb  30 Mb
43113:  *
43113:  * The equation for this is (for cache size C and memory size K (kbytes)):
43113:  *  x = log2(K) - 14
43113:  *  C = x^2/3 + x + 2/3 + 0.1 (0.1 for rounding)
43113:  *  if (C > 32) C = 32
43113:  */
43113: 
43113: PRInt32
43113: nsCacheProfilePrefObserver::MemoryCacheCapacity()
43113: {
43113:     PRInt32 capacity = mMemoryCacheCapacity;
43113:     if (capacity >= 0) {
43113:         CACHE_LOG_DEBUG(("Memory cache capacity forced to %d\n", capacity));
43113:         return capacity;
43113:     }
43113: 
43113:     static PRUint64 bytes = PR_GetPhysicalMemorySize();
43113:     CACHE_LOG_DEBUG(("Physical Memory size is %llu\n", bytes));
43113: 
43113:     // If getting the physical memory failed, arbitrarily assume
43113:     // 32 MB of RAM. We use a low default to have a reasonable
43113:     // size on all the devices we support.
43113:     if (bytes == 0)
43113:         bytes = 32 * 1024 * 1024;
43113: 
43113:     // Conversion from unsigned int64 to double doesn't work on all platforms.
43113:     // We need to truncate the value at LL_MAXINT to make sure we don't
43113:     // overflow.
43113:     if (LL_CMP(bytes, >, LL_MAXINT))
43113:         bytes = LL_MAXINT;
43113: 
43113:     PRUint64 kbytes;
43113:     LL_SHR(kbytes, bytes, 10);
43113: 
43113:     double kBytesD;
43113:     LL_L2D(kBytesD, (PRInt64) kbytes);
43113: 
43113:     double x = log(kBytesD)/log(2.0) - 14;
43113:     if (x > 0) {
43113:         capacity = (PRInt32)(x * x / 3.0 + x + 2.0 / 3 + 0.1); // 0.1 for rounding
43113:         if (capacity > 32)
43113:             capacity = 32;
43113:         capacity   *= 1024;
43113:     } else {
43113:         capacity    = 0;
43113:     }
43113: 
43113:     return capacity;
43113: }
43113: 
51302: 
51302: /******************************************************************************
51302:  * nsProcessRequestEvent
51302:  *****************************************************************************/
51302: 
51302: class nsProcessRequestEvent : public nsRunnable {
51302: public:
51302:     nsProcessRequestEvent(nsCacheRequest *aRequest)
51302:     {
51302:         mRequest = aRequest;
51302:     }
51302: 
51302:     NS_IMETHOD Run()
51302:     {
51302:         nsresult rv;
51302: 
51302:         NS_ASSERTION(mRequest->mListener,
51302:                      "Sync OpenCacheEntry() posted to background thread!");
51302: 
51302:         nsCacheServiceAutoLock lock;
51302:         rv = nsCacheService::gService->ProcessRequest(mRequest,
51302:                                                       PR_FALSE,
51302:                                                       nsnull);
51302: 
51302:         // Don't delete the request if it was queued
51302:         if (rv != NS_ERROR_CACHE_WAIT_FOR_VALIDATION)
51302:             delete mRequest;
51302: 
51302:         return NS_OK;
51302:     }
51302: 
51302: protected:
51302:     virtual ~nsProcessRequestEvent() {}
51302: 
51302: private:
51302:     nsCacheRequest *mRequest;
51302: };
51302: 
43113: /******************************************************************************
43113:  * nsCacheService
43113:  *****************************************************************************/
43113: #ifdef XP_MAC
43113: #pragma mark -
43113: #pragma mark nsCacheService
43113: #endif
43113: 
43113: nsCacheService *   nsCacheService::gService = nsnull;
43113: 
43113: NS_IMPL_THREADSAFE_ISUPPORTS1(nsCacheService, nsICacheService)
43113: 
43113: nsCacheService::nsCacheService()
43113:     : mLock(nsnull),
43113:       mInitialized(PR_FALSE),
43113:       mEnableMemoryDevice(PR_TRUE),
43113:       mEnableDiskDevice(PR_TRUE),
43113:       mMemoryDevice(nsnull),
43113:       mDiskDevice(nsnull),
43113:       mOfflineDevice(nsnull),
43113:       mTotalEntries(0),
43113:       mCacheHits(0),
43113:       mCacheMisses(0),
43113:       mMaxKeyLength(0),
43113:       mMaxDataSize(0),
43113:       mMaxMetaSize(0),
43113:       mDeactivateFailures(0),
43113:       mDeactivatedUnboundEntries(0)
43113: {
43113:     NS_ASSERTION(gService==nsnull, "multiple nsCacheService instances!");
43113:     gService = this;
43113: 
43113:     // create list of cache devices
43113:     PR_INIT_CLIST(&mDoomedEntries);
43113:   
43113:     // allocate service lock
43113:     mLock = PR_NewLock();
43113: 
43113: #if defined(DEBUG)
43113:     mLockedThread = nsnull;
43113: #endif
43113: }
43113: 
43113: nsCacheService::~nsCacheService()
43113: {
43113:     if (mInitialized) // Shutdown hasn't been called yet.
43113:         (void) Shutdown();
43113: 
43113:     PR_DestroyLock(mLock);
43113:     gService = nsnull;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::Init()
43113: {
43113:     NS_TIME_FUNCTION;
43113: 
43113:     NS_ASSERTION(!mInitialized, "nsCacheService already initialized.");
43113:     if (mInitialized)
43113:         return NS_ERROR_ALREADY_INITIALIZED;
43113: 
43113:     if (mLock == nsnull)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     CACHE_LOG_INIT();
43113: 
51302:     nsresult rv = NS_NewThread(getter_AddRefs(mCacheIOThread));
51302:     if (NS_FAILED(rv)) {
51302:         NS_WARNING("Can't create cache IO thread");
51302:     }
51302: 
43113:     // initialize hashtable for active cache entries
51302:     rv = mActiveEntries.Init();
43113:     if (NS_FAILED(rv)) return rv;
43113:     
43113:     // create profile/preference observer
43113:     mObserver = new nsCacheProfilePrefObserver();
43113:     if (!mObserver)  return NS_ERROR_OUT_OF_MEMORY;
43113:     NS_ADDREF(mObserver);
43113:     
43113:     mObserver->Install();
43113:     mEnableDiskDevice    = mObserver->DiskCacheEnabled();
43113:     mEnableOfflineDevice = mObserver->OfflineCacheEnabled();
43113:     mEnableMemoryDevice  = mObserver->MemoryCacheEnabled();
43113: 
43113:     mInitialized = PR_TRUE;
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::Shutdown()
43113: {
51302:     nsCOMPtr<nsIThread> cacheIOThread;
51302: 
51302:     {
43113:     nsCacheServiceAutoLock lock;
43113:     NS_ASSERTION(mInitialized, 
43113:                  "can't shutdown nsCacheService unless it has been initialized.");
43113: 
43113:     if (mInitialized) {
43113: 
43113:         mInitialized = PR_FALSE;
43113: 
43113:         mObserver->Remove();
43113:         NS_RELEASE(mObserver);
43113:         
43113:         // Clear entries
43113:         ClearDoomList();
43113:         ClearActiveEntries();
43113: 
43113:         // deallocate memory and disk caches
43113:         delete mMemoryDevice;
43113:         mMemoryDevice = nsnull;
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:         delete mDiskDevice;
43113:         mDiskDevice = nsnull;
43113: #endif // !NECKO_DISK_CACHE
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:         NS_IF_RELEASE(mOfflineDevice);
43113: #endif // !NECKO_OFFLINE_CACHE
43113: 
43113: #if defined(NECKO_DISK_CACHE) && defined(PR_LOGGING)
43113:         LogCacheStatistics();
43113: #endif
51302: 
51302:         mCacheIOThread.swap(cacheIOThread);
43113:     }
51302:     } // lock
51302: 
51302:     if (cacheIOThread)
51302:         cacheIOThread->Shutdown();
43113: }
43113: 
43113: 
46998: nsresult
43113: nsCacheService::Create(nsISupports* aOuter, const nsIID& aIID, void* *aResult)
43113: {
43113:     nsresult  rv;
43113: 
43113:     if (aOuter != nsnull)
43113:         return NS_ERROR_NO_AGGREGATION;
43113: 
43113:     nsCacheService * cacheService = new nsCacheService();
43113:     if (cacheService == nsnull)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     NS_ADDREF(cacheService);
43113:     rv = cacheService->Init();
43113:     if (NS_SUCCEEDED(rv)) {
43113:         rv = cacheService->QueryInterface(aIID, aResult);
43113:     }
43113:     NS_RELEASE(cacheService);
43113:     return rv;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP
43113: nsCacheService::CreateSession(const char *          clientID,
43113:                               nsCacheStoragePolicy  storagePolicy, 
43113:                               PRBool                streamBased,
43113:                               nsICacheSession     **result)
43113: {
43113:     *result = nsnull;
43113: 
43113:     if (this == nsnull)  return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     nsCacheSession * session = new nsCacheSession(clientID, storagePolicy, streamBased);
43113:     if (!session)  return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     NS_ADDREF(*result = session);
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::EvictEntriesForSession(nsCacheSession * session)
43113: {
43113:     NS_ASSERTION(gService, "nsCacheService::gService is null.");
43113:     return gService->EvictEntriesForClient(session->ClientID()->get(),
43113:                                  session->StoragePolicy());
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::EvictEntriesForClient(const char *          clientID,
43113:                                       nsCacheStoragePolicy  storagePolicy)
43113: {
43113:     if (this == nsnull) return NS_ERROR_NOT_AVAILABLE; // XXX eh?
43113: 
43113:     nsCOMPtr<nsIObserverService> obsSvc =
43113:         mozilla::services::GetObserverService();
43113:     if (obsSvc) {
43113:         // Proxy to the UI thread since the observer service isn't thredsafe.
43113:         // We use an async proxy, since this it's not important whether this
43113:         // notification happens before or after the actual eviction.
43113: 
43113:         nsCOMPtr<nsIObserverService> obsProxy;
43113:         NS_GetProxyForObject(NS_PROXY_TO_MAIN_THREAD,
43113:                              NS_GET_IID(nsIObserverService), obsSvc,
43113:                              NS_PROXY_ASYNC, getter_AddRefs(obsProxy));
43113: 
43113:         if (obsProxy) {
43113:             obsProxy->NotifyObservers(this,
43113:                                       NS_CACHESERVICE_EMPTYCACHE_TOPIC_ID,
43113:                                       nsnull);
43113:         }
43113:     }
43113: 
43113:     nsCacheServiceAutoLock lock;
43113:     nsresult res = NS_OK;
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:     if (storagePolicy == nsICache::STORE_ANYWHERE ||
43113:         storagePolicy == nsICache::STORE_ON_DISK) {
43113: 
43113:         if (mEnableDiskDevice) {
43113:             nsresult rv;
43113:             if (!mDiskDevice)
43113:                 rv = CreateDiskDevice();
43113:             if (mDiskDevice)
43113:                 rv = mDiskDevice->EvictEntries(clientID);
43113:             if (NS_FAILED(rv)) res = rv;
43113:         }
43113:     }
43113: #endif // ! NECKO_DISK_CACHE
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:     // Only clear the offline cache if it has been specifically asked for.
43113:     if (storagePolicy == nsICache::STORE_OFFLINE) {
43113:         if (mEnableOfflineDevice) {
43113:             nsresult rv;
43113:             if (!mOfflineDevice)
43113:                 rv = CreateOfflineDevice();
43113:             if (mOfflineDevice)
43113:                 rv = mOfflineDevice->EvictEntries(clientID);
43113:             if (NS_FAILED(rv)) res = rv;
43113:         }
43113:     }
43113: #endif // ! NECKO_OFFLINE_CACHE
43113: 
43113:     if (storagePolicy == nsICache::STORE_ANYWHERE ||
43113:         storagePolicy == nsICache::STORE_IN_MEMORY) {
43113: 
43113:         // If there is no memory device, there is no need to evict it...
43113:         if (mMemoryDevice) {
43113:             nsresult rv;
43113:             rv = mMemoryDevice->EvictEntries(clientID);
43113:             if (NS_FAILED(rv)) res = rv;
43113:         }
43113:     }
43113: 
43113:     return res;
43113: }
43113: 
43113: 
43113: nsresult        
43113: nsCacheService::IsStorageEnabledForPolicy(nsCacheStoragePolicy  storagePolicy,
43113:                                           PRBool *              result)
43113: {
43113:     if (gService == nsnull) return NS_ERROR_NOT_AVAILABLE;
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     *result = gService->IsStorageEnabledForPolicy_Locked(storagePolicy);
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: PRBool        
43113: nsCacheService::IsStorageEnabledForPolicy_Locked(nsCacheStoragePolicy  storagePolicy)
43113: {
43113:     if (gService->mEnableMemoryDevice &&
43113:         (storagePolicy == nsICache::STORE_ANYWHERE ||
43113:          storagePolicy == nsICache::STORE_IN_MEMORY)) {
43113:         return PR_TRUE;
43113:     }
43113:     if (gService->mEnableDiskDevice &&
43113:         (storagePolicy == nsICache::STORE_ANYWHERE ||
43113:          storagePolicy == nsICache::STORE_ON_DISK  ||
43113:          storagePolicy == nsICache::STORE_ON_DISK_AS_FILE)) {
43113:         return PR_TRUE;
43113:     }
43113:     if (gService->mEnableOfflineDevice &&
43113:         storagePolicy == nsICache::STORE_OFFLINE) {
43113:         return PR_TRUE;
43113:     }
43113:     
43113:     return PR_FALSE;
43113: }
43113: 
43113: NS_IMETHODIMP nsCacheService::VisitEntries(nsICacheVisitor *visitor)
43113: {
43113:     NS_ENSURE_ARG_POINTER(visitor);
43113: 
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     if (!(mEnableDiskDevice || mEnableMemoryDevice))
43113:         return NS_ERROR_NOT_AVAILABLE;
43113: 
43113:     // XXX record the fact that a visitation is in progress, 
43113:     // XXX i.e. keep list of visitors in progress.
43113:     
43113:     nsresult rv = NS_OK;
43113:     // If there is no memory device, there are then also no entries to visit...
43113:     if (mMemoryDevice) {
43113:         rv = mMemoryDevice->Visit(visitor);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:     if (mEnableDiskDevice) {
43113:         if (!mDiskDevice) {
43113:             rv = CreateDiskDevice();
43113:             if (NS_FAILED(rv)) return rv;
43113:         }
43113:         rv = mDiskDevice->Visit(visitor);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: #endif // !NECKO_DISK_CACHE
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:     if (mEnableOfflineDevice) {
43113:         if (!mOfflineDevice) {
43113:             rv = CreateOfflineDevice();
43113:             if (NS_FAILED(rv)) return rv;
43113:         }
43113:         rv = mOfflineDevice->Visit(visitor);
43113:         if (NS_FAILED(rv)) return rv;
43113:     }
43113: #endif // !NECKO_OFFLINE_CACHE
43113: 
43113:     // XXX notify any shutdown process that visitation is complete for THIS visitor.
43113:     // XXX keep queue of visitors
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: NS_IMETHODIMP nsCacheService::EvictEntries(nsCacheStoragePolicy storagePolicy)
43113: {
43113:     return  EvictEntriesForClient(nsnull, storagePolicy);
43113: }
43113: 
51302: NS_IMETHODIMP nsCacheService::GetCacheIOTarget(nsIEventTarget * *aCacheIOTarget)
51302: {
51302:     nsCacheServiceAutoLock lock;
51302: 
51302:     if (!mCacheIOThread)
51302:         return NS_ERROR_NOT_AVAILABLE;
51302: 
51302:     NS_ADDREF(*aCacheIOTarget = mCacheIOThread);
51302:     return NS_OK;
51302: }
51302: 
43113: /**
43113:  * Internal Methods
43113:  */
43113: nsresult
43113: nsCacheService::CreateDiskDevice()
43113: {
43113: #ifdef NECKO_DISK_CACHE
43113:     if (!mInitialized)      return NS_ERROR_NOT_AVAILABLE;
43113:     if (!mEnableDiskDevice) return NS_ERROR_NOT_AVAILABLE;
43113:     if (mDiskDevice)        return NS_OK;
43113: 
43113:     mDiskDevice = new nsDiskCacheDevice;
43113:     if (!mDiskDevice)       return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     // set the preferences
43113:     mDiskDevice->SetCacheParentDirectory(mObserver->DiskCacheParentDirectory());
43113:     mDiskDevice->SetCapacity(mObserver->DiskCacheCapacity());
43113:     
43113:     nsresult rv = mDiskDevice->Init();
43113:     if (NS_FAILED(rv)) {
43113: #if DEBUG
43113:         printf("###\n");
43113:         printf("### mDiskDevice->Init() failed (0x%.8x)\n", rv);
43113:         printf("###    - disabling disk cache for this session.\n");
43113:         printf("###\n");
43113: #endif        
43113:         mEnableDiskDevice = PR_FALSE;
43113:         delete mDiskDevice;
43113:         mDiskDevice = nsnull;
43113:     }
43113:     return rv;
43113: #else // !NECKO_DISK_CACHE
43113:     NS_NOTREACHED("nsCacheService::CreateDiskDevice");
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: #endif
43113: }
43113: 
43113: nsresult
43113: nsCacheService::CreateOfflineDevice()
43113: {
43113: #ifdef NECKO_OFFLINE_CACHE
43113:     CACHE_LOG_ALWAYS(("Creating offline device"));
43113: 
43113:     if (!mInitialized)         return NS_ERROR_NOT_AVAILABLE;
43113:     if (!mEnableOfflineDevice) return NS_ERROR_NOT_AVAILABLE;
43113:     if (mOfflineDevice)        return NS_OK;
43113: 
43113:     mOfflineDevice = new nsOfflineCacheDevice;
43113:     if (!mOfflineDevice)       return NS_ERROR_OUT_OF_MEMORY;
43113: 
43113:     NS_ADDREF(mOfflineDevice);
43113: 
43113:     // set the preferences
43113:     mOfflineDevice->SetCacheParentDirectory(
43113:         mObserver->OfflineCacheParentDirectory());
43113:     mOfflineDevice->SetCapacity(mObserver->OfflineCacheCapacity());
43113: 
43113:     nsresult rv = mOfflineDevice->Init();
43113:     if (NS_FAILED(rv)) {
43113:         CACHE_LOG_DEBUG(("mOfflineDevice->Init() failed (0x%.8x)\n", rv));
43113:         CACHE_LOG_DEBUG(("    - disabling offline cache for this session.\n"));
43113: 
43113:         mEnableOfflineDevice = PR_FALSE;
43113:         NS_RELEASE(mOfflineDevice);
43113:     }
43113:     return rv;
43113: #else // !NECKO_DISK_CACHE
43113:     NS_NOTREACHED("nsCacheService::CreateOfflineDevice");
43113:     return NS_ERROR_NOT_IMPLEMENTED;
43113: #endif
43113: }
43113: 
43113: nsresult
43113: nsCacheService::CreateMemoryDevice()
43113: {
43113:     if (!mInitialized)        return NS_ERROR_NOT_AVAILABLE;
43113:     if (!mEnableMemoryDevice) return NS_ERROR_NOT_AVAILABLE;
43113:     if (mMemoryDevice)        return NS_OK;
43113: 
43113:     mMemoryDevice = new nsMemoryCacheDevice;
43113:     if (!mMemoryDevice)       return NS_ERROR_OUT_OF_MEMORY;
43113:     
43113:     // set preference
43113:     PRInt32 capacity = mObserver->MemoryCacheCapacity();
43113:     CACHE_LOG_DEBUG(("Creating memory device with capacity %d\n", capacity));
43113:     mMemoryDevice->SetCapacity(capacity);
43113: 
43113:     nsresult rv = mMemoryDevice->Init();
43113:     if (NS_FAILED(rv)) {
43113:         NS_WARNING("Initialization of Memory Cache failed.");
43113:         delete mMemoryDevice;
43113:         mMemoryDevice = nsnull;
43113:     }
43113:     return rv;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::CreateRequest(nsCacheSession *   session,
43113:                               const nsACString & clientKey,
43113:                               nsCacheAccessMode  accessRequested,
43113:                               PRBool             blockingMode,
43113:                               nsICacheListener * listener,
43113:                               nsCacheRequest **  request)
43113: {
43113:     NS_ASSERTION(request, "CreateRequest: request is null");
43113:      
43113:     nsCString * key = new nsCString(*session->ClientID());
43113:     if (!key)
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     key->Append(':');
43113:     key->Append(clientKey);
43113: 
43113:     if (mMaxKeyLength < key->Length()) mMaxKeyLength = key->Length();
43113: 
43113:     // create request
43113:     *request = new  nsCacheRequest(key, listener, accessRequested, blockingMode, session);    
43113:     if (!*request) {
43113:         delete key;
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     }
43113: 
43113:     if (!listener)  return NS_OK;  // we're sync, we're done.
43113: 
43113:     // get the request's thread
43113:     (*request)->mThread = do_GetCurrentThread();
43113:     
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: class nsCacheListenerEvent : public nsRunnable
43113: {
43113: public:
43113:     nsCacheListenerEvent(nsICacheListener *listener,
43113:                          nsICacheEntryDescriptor *descriptor,
43113:                          nsCacheAccessMode accessGranted,
43113:                          nsresult status)
43113:         : mListener(listener)      // transfers reference
43113:         , mDescriptor(descriptor)  // transfers reference (may be null)
43113:         , mAccessGranted(accessGranted)
43113:         , mStatus(status)
43113:     {}
43113: 
43113:     NS_IMETHOD Run()
43113:     {
43113:         mListener->OnCacheEntryAvailable(mDescriptor, mAccessGranted, mStatus);
43113: 
43113:         NS_RELEASE(mListener);
43113:         NS_IF_RELEASE(mDescriptor);
43113:         return NS_OK;
43113:     }
43113: 
43113: private:
43113:     // We explicitly leak mListener or mDescriptor if Run is not called
43113:     // because otherwise we cannot guarantee that they are destroyed on
43113:     // the right thread.
43113: 
43113:     nsICacheListener        *mListener;
43113:     nsICacheEntryDescriptor *mDescriptor;
43113:     nsCacheAccessMode        mAccessGranted;
43113:     nsresult                 mStatus;
43113: };
43113: 
43113: 
43113: nsresult
43113: nsCacheService::NotifyListener(nsCacheRequest *          request,
43113:                                nsICacheEntryDescriptor * descriptor,
43113:                                nsCacheAccessMode         accessGranted,
43113:                                nsresult                  status)
43113: {
43113:     NS_ASSERTION(request->mThread, "no thread set in async request!");
43113: 
43113:     // Swap ownership, and release listener on target thread...
43113:     nsICacheListener *listener = request->mListener;
43113:     request->mListener = nsnull;
43113: 
43113:     nsCOMPtr<nsIRunnable> ev =
43113:             new nsCacheListenerEvent(listener, descriptor,
43113:                                      accessGranted, status);
43113:     if (!ev) {
43113:         // Better to leak listener and descriptor if we fail because we don't
43113:         // want to destroy them inside the cache service lock or on potentially
43113:         // the wrong thread.
43113:         return NS_ERROR_OUT_OF_MEMORY;
43113:     }
43113: 
43113:     return request->mThread->Dispatch(ev, NS_DISPATCH_NORMAL);
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::ProcessRequest(nsCacheRequest *           request,
43113:                                PRBool                     calledFromOpenCacheEntry,
43113:                                nsICacheEntryDescriptor ** result)
43113: {
43113:     // !!! must be called with mLock held !!!
43113:     nsresult           rv;
43113:     nsCacheEntry *     entry = nsnull;
43113:     nsCacheAccessMode  accessGranted = nsICache::ACCESS_NONE;
43113:     if (result) *result = nsnull;
43113: 
43113:     while(1) {  // Activate entry loop
43113:         rv = ActivateEntry(request, &entry);  // get the entry for this request
43113:         if (NS_FAILED(rv))  break;
43113: 
43113:         while(1) { // Request Access loop
43113:             NS_ASSERTION(entry, "no entry in Request Access loop!");
43113:             // entry->RequestAccess queues request on entry
43113:             rv = entry->RequestAccess(request, &accessGranted);
43113:             if (rv != NS_ERROR_CACHE_WAIT_FOR_VALIDATION) break;
43113:             
43113:             if (request->mListener) // async exits - validate, doom, or close will resume
43113:                 return rv;
43113:             
43113:             if (request->IsBlocking()) {
43113:                 // XXX this is probably wrong...
43113:                 Unlock();
43113:                 rv = request->WaitForValidation();
43113:                 Lock();
43113:             }
43113: 
43113:             PR_REMOVE_AND_INIT_LINK(request);
43113:             if (NS_FAILED(rv)) break;   // non-blocking mode returns WAIT_FOR_VALIDATION error
43113:             // okay, we're ready to process this request, request access again
43113:         }
43113:         if (rv != NS_ERROR_CACHE_ENTRY_DOOMED)  break;
43113: 
43113:         if (entry->IsNotInUse()) {
43113:             // this request was the last one keeping it around, so get rid of it
43113:             DeactivateEntry(entry);
43113:         }
43113:         // loop back around to look for another entry
43113:     }
43113: 
43113:     nsICacheEntryDescriptor *descriptor = nsnull;
43113:     
43113:     if (NS_SUCCEEDED(rv))
43113:         rv = entry->CreateDescriptor(request, accessGranted, &descriptor);
43113: 
43113:     if (request->mListener) {  // Asynchronous
43113:     
43113:         if (NS_FAILED(rv) && calledFromOpenCacheEntry)
43113:             return rv;  // skip notifying listener, just return rv to caller
43113:             
43113:         // call listener to report error or descriptor
43113:         nsresult rv2 = NotifyListener(request, descriptor, accessGranted, rv);
43113:         if (NS_FAILED(rv2) && NS_SUCCEEDED(rv)) {
43113:             rv = rv2;  // trigger delete request
43113:         }
43113:     } else {        // Synchronous
43113:         *result = descriptor;
43113:     }
43113:     return rv;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::OpenCacheEntry(nsCacheSession *           session,
43113:                                const nsACString &         key,
43113:                                nsCacheAccessMode          accessRequested,
43113:                                PRBool                     blockingMode,
43113:                                nsICacheListener *         listener,
43113:                                nsICacheEntryDescriptor ** result)
43113: {
43113:     CACHE_LOG_DEBUG(("Opening entry for session %p, key %s, mode %d, blocking %d\n",
43113:                      session, PromiseFlatCString(key).get(), accessRequested,
43113:                      blockingMode));
43113:     NS_ASSERTION(gService, "nsCacheService::gService is null.");
43113:     if (result)
43113:         *result = nsnull;
43113: 
43113:     if (!gService->mInitialized)
43113:         return NS_ERROR_NOT_INITIALIZED;
43113: 
43113:     nsCacheRequest * request = nsnull;
43113: 
43113:     nsCacheServiceAutoLock lock;
43113:     nsresult rv = gService->CreateRequest(session,
43113:                                           key,
43113:                                           accessRequested,
43113:                                           blockingMode,
43113:                                           listener,
43113:                                           &request);
43113:     if (NS_FAILED(rv))  return rv;
43113: 
43113:     CACHE_LOG_DEBUG(("Created request %p\n", request));
43113: 
51302:     // Process the request on the background thread if we are on the main thread
51302:     // and the the request is asynchronous
51302:     if (NS_IsMainThread() && listener && gService->mCacheIOThread) {
51302:         nsCOMPtr<nsIRunnable> ev =
51302:             new nsProcessRequestEvent(request);
51302:         if (ev) {
51302:             rv = gService->mCacheIOThread->Dispatch(ev, NS_DISPATCH_NORMAL);
51302:         } else {
51302:             rv = NS_ERROR_OUT_OF_MEMORY;
51302:         }
51302: 
51302:         // delete request if we didn't post the event
51302:         if (NS_FAILED(rv))
51302:             delete request;
51302:     }
53987:     else {
43113:         rv = gService->ProcessRequest(request, PR_TRUE, result);
43113: 
43113:         // delete requests that have completed
43113:         if (!(listener && (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION)))
43113:             delete request;
51302:     }
43113: 
43113:     return rv;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::ActivateEntry(nsCacheRequest * request, 
43113:                               nsCacheEntry ** result)
43113: {
43113:     CACHE_LOG_DEBUG(("Activate entry for request %p\n", request));
43113:     
43113:     nsresult        rv = NS_OK;
43113: 
43113:     NS_ASSERTION(request != nsnull, "ActivateEntry called with no request");
43113:     if (result) *result = nsnull;
43113:     if ((!request) || (!result))  return NS_ERROR_NULL_POINTER;
43113: 
43113:     // check if the request can be satisfied
43113:     if (!mEnableMemoryDevice && !request->IsStreamBased())
43113:         return NS_ERROR_FAILURE;
43113:     if (!IsStorageEnabledForPolicy_Locked(request->StoragePolicy()))
43113:         return NS_ERROR_FAILURE;
43113: 
43113:     // search active entries (including those not bound to device)
43113:     nsCacheEntry *entry = mActiveEntries.GetEntry(request->mKey);
43113:     CACHE_LOG_DEBUG(("Active entry for request %p is %p\n", request, entry));
43113: 
43113:     if (!entry) {
43113:         // search cache devices for entry
43113:         PRBool collision = PR_FALSE;
43113:         entry = SearchCacheDevices(request->mKey, request->StoragePolicy(), &collision);
43113:         CACHE_LOG_DEBUG(("Device search for request %p returned %p\n",
43113:                          request, entry));
43113:         // When there is a hashkey collision just refuse to cache it...
43113:         if (collision) return NS_ERROR_CACHE_IN_USE;
43113: 
43113:         if (entry)  entry->MarkInitialized();
43113:     }
43113: 
43113:     if (entry) {
43113:         ++mCacheHits;
43113:         entry->Fetched();
43113:     } else {
43113:         ++mCacheMisses;
43113:     }
43113: 
43113:     if (entry &&
43113:         ((request->AccessRequested() == nsICache::ACCESS_WRITE) ||
43113:          ((request->StoragePolicy() != nsICache::STORE_OFFLINE) &&
43113:           (entry->mExpirationTime <= SecondsFromPRTime(PR_Now()) &&
43113:            request->WillDoomEntriesIfExpired()))))
43113: 
43113:     {
43113:         // this is FORCE-WRITE request or the entry has expired
43113:         rv = DoomEntry_Internal(entry);
43113:         if (NS_FAILED(rv)) {
43113:             // XXX what to do?  Increment FailedDooms counter?
43113:         }
43113:         entry = nsnull;
43113:     }
43113: 
43113:     if (!entry) {
43113:         if (! (request->AccessRequested() & nsICache::ACCESS_WRITE)) {
43113:             // this is a READ-ONLY request
43113:             rv = NS_ERROR_CACHE_KEY_NOT_FOUND;
43113:             goto error;
43113:         }
43113: 
43113:         entry = new nsCacheEntry(request->mKey,
43113:                                  request->IsStreamBased(),
43113:                                  request->StoragePolicy());
43113:         if (!entry)
43113:             return NS_ERROR_OUT_OF_MEMORY;
43113:         
43113:         entry->Fetched();
43113:         ++mTotalEntries;
43113:         
43113:         // XXX  we could perform an early bind in some cases based on storage policy
43113:     }
43113: 
43113:     if (!entry->IsActive()) {
43113:         rv = mActiveEntries.AddEntry(entry);
43113:         if (NS_FAILED(rv)) goto error;
43113:         CACHE_LOG_DEBUG(("Added entry %p to mActiveEntries\n", entry));
43113:         entry->MarkActive();  // mark entry active, because it's now in mActiveEntries
43113:     }
43113:     *result = entry;
43113:     return NS_OK;
43113:     
43113:  error:
43113:     *result = nsnull;
43113:     if (entry) {
43113:         delete entry;
43113:     }
43113:     return rv;
43113: }
43113: 
43113: 
43113: nsCacheEntry *
43113: nsCacheService::SearchCacheDevices(nsCString * key, nsCacheStoragePolicy policy, PRBool *collision)
43113: {
43113:     nsCacheEntry * entry = nsnull;
43113: 
43113:     CACHE_LOG_DEBUG(("mMemoryDevice: 0x%p\n", mMemoryDevice));
43113: 
43113:     *collision = PR_FALSE;
43113:     if ((policy == nsICache::STORE_ANYWHERE) || (policy == nsICache::STORE_IN_MEMORY)) {
43113:         // If there is no memory device, then there is nothing to search...
43113:         if (mMemoryDevice) {
43113:             entry = mMemoryDevice->FindEntry(key, collision);
43113:             CACHE_LOG_DEBUG(("Searching mMemoryDevice for key %s found: 0x%p, "
43113:                              "collision: %d\n", key->get(), entry, collision));
43113:         }
43113:     }
43113: 
43113:     if (!entry && 
43113:         ((policy == nsICache::STORE_ANYWHERE) || (policy == nsICache::STORE_ON_DISK))) {
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:         if (mEnableDiskDevice) {
43113:             if (!mDiskDevice) {
43113:                 nsresult rv = CreateDiskDevice();
43113:                 if (NS_FAILED(rv))
43113:                     return nsnull;
43113:             }
43113:             
43113:             entry = mDiskDevice->FindEntry(key, collision);
43113:         }
43113: #endif // !NECKO_DISK_CACHE
43113:     }
43113: 
43113:     if (!entry && (policy == nsICache::STORE_OFFLINE ||
43113:                    (policy == nsICache::STORE_ANYWHERE &&
43113:                     gIOService->IsOffline()))) {
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:         if (mEnableOfflineDevice) {
43113:             if (!mOfflineDevice) {
43113:                 nsresult rv = CreateOfflineDevice();
43113:                 if (NS_FAILED(rv))
43113:                     return nsnull;
43113:             }
43113: 
43113:             entry = mOfflineDevice->FindEntry(key, collision);
43113:         }
43113: #endif // !NECKO_OFFLINE_CACHE
43113:     }
43113: 
43113:     return entry;
43113: }
43113: 
43113: 
43113: nsCacheDevice *
43113: nsCacheService::EnsureEntryHasDevice(nsCacheEntry * entry)
43113: {
43113:     nsCacheDevice * device = entry->CacheDevice();
43113:     if (device)  return device;
43113: 
52143:     PRInt64 predictedDataSize = entry->PredictedDataSize();
43113: #ifdef NECKO_DISK_CACHE
43113:     if (entry->IsStreamData() && entry->IsAllowedOnDisk() && mEnableDiskDevice) {
43113:         // this is the default
43113:         if (!mDiskDevice) {
43113:             (void)CreateDiskDevice();  // ignore the error (check for mDiskDevice instead)
43113:         }
43113: 
43113:         if (mDiskDevice) {
52143:             // Bypass the cache if Content-Length says the entry will be too big
52143:             if (predictedDataSize != -1 &&
52143:                 mDiskDevice->EntryIsTooBig(predictedDataSize)) {
52143:                 nsresult rv = nsCacheService::DoomEntry(entry);
52143:                 NS_ASSERTION(NS_SUCCEEDED(rv),"DoomEntry() failed.");
52143:                 return nsnull;
52143:             }
52143: 
43113:             entry->MarkBinding();  // enter state of binding
43113:             nsresult rv = mDiskDevice->BindEntry(entry);
43113:             entry->ClearBinding(); // exit state of binding
43113:             if (NS_SUCCEEDED(rv))
43113:                 device = mDiskDevice;
43113:         }
43113:     }
43113: #endif // !NECKO_DISK_CACHE
43113: 
43113:     // if we can't use mDiskDevice, try mMemoryDevice
43113:     if (!device && mEnableMemoryDevice && entry->IsAllowedInMemory()) {        
43113:         if (!mMemoryDevice) {
43113:             (void)CreateMemoryDevice();  // ignore the error (check for mMemoryDevice instead)
43113:         }
43113:         if (mMemoryDevice) {
52143:             // Bypass the cache if Content-Length says entry will be too big
52143:             if (predictedDataSize != -1 &&
52143:                 mMemoryDevice->EntryIsTooBig(predictedDataSize)) {
52143:                 nsresult rv = nsCacheService::DoomEntry(entry);
52143:                 NS_ASSERTION(NS_SUCCEEDED(rv),"DoomEntry() failed.");
52143:                 return nsnull;
52143:             }
52143: 
43113:             entry->MarkBinding();  // enter state of binding
43113:             nsresult rv = mMemoryDevice->BindEntry(entry);
43113:             entry->ClearBinding(); // exit state of binding
43113:             if (NS_SUCCEEDED(rv))
43113:                 device = mMemoryDevice;
43113:         }
43113:     }
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:     if (!device && entry->IsStreamData() &&
43113:         entry->IsAllowedOffline() && mEnableOfflineDevice) {
43113:         if (!mOfflineDevice) {
43113:             (void)CreateOfflineDevice(); // ignore the error (check for mOfflineDevice instead)
43113:         }
43113: 
43113:         if (mOfflineDevice) {
43113:             entry->MarkBinding();
43113:             nsresult rv = mOfflineDevice->BindEntry(entry);
43113:             entry->ClearBinding();
43113:             if (NS_SUCCEEDED(rv))
43113:                 device = mOfflineDevice;
43113:         }
43113:     }
43113: #endif // ! NECKO_OFFLINE_CACHE
43113: 
43113:     if (device) 
43113:         entry->SetCacheDevice(device);
43113:     return device;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::DoomEntry(nsCacheEntry * entry)
43113: {
43113:     return gService->DoomEntry_Internal(entry);
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::DoomEntry_Internal(nsCacheEntry * entry)
43113: {
43113:     if (entry->IsDoomed())  return NS_OK;
43113:     
43113:     CACHE_LOG_DEBUG(("Dooming entry %p\n", entry));
43113:     nsresult  rv = NS_OK;
43113:     entry->MarkDoomed();
43113:     
43113:     NS_ASSERTION(!entry->IsBinding(), "Dooming entry while binding device.");
43113:     nsCacheDevice * device = entry->CacheDevice();
43113:     if (device)  device->DoomEntry(entry);
43113: 
43113:     if (entry->IsActive()) {
43113:         // remove from active entries
43113:         mActiveEntries.RemoveEntry(entry);
43113:         CACHE_LOG_DEBUG(("Removed entry %p from mActiveEntries\n", entry));
43113:         entry->MarkInactive();
43113:      }
43113: 
43113:     // put on doom list to wait for descriptors to close
43113:     NS_ASSERTION(PR_CLIST_IS_EMPTY(entry), "doomed entry still on device list");
43113:     PR_APPEND_LINK(entry, &mDoomedEntries);
43113: 
43113:     // tell pending requests to get on with their lives...
43113:     rv = ProcessPendingRequests(entry);
43113:     
43113:     // All requests have been removed, but there may still be open descriptors
43113:     if (entry->IsNotInUse()) {
43113:         DeactivateEntry(entry); // tell device to get rid of it
43113:     }
43113:     return rv;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::OnProfileShutdown(PRBool cleanse)
43113: {
43113:     if (!gService)  return;
43113:     if (!gService->mInitialized) {
43113:         // The cache service has been shut down, but someone is still holding
43113:         // a reference to it. Ignore this call.
43113:         return;
43113:     }
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     gService->DoomActiveEntries();
43113:     gService->ClearDoomList();
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:     if (gService->mDiskDevice && gService->mEnableDiskDevice) {
43113:         if (cleanse)
43113:             gService->mDiskDevice->EvictEntries(nsnull);
43113: 
43113:         gService->mDiskDevice->Shutdown();
43113:     }
43113:     gService->mEnableDiskDevice = PR_FALSE;
43113: #endif // !NECKO_DISK_CACHE
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:     if (gService->mOfflineDevice && gService->mEnableOfflineDevice) {
43113:         if (cleanse)
43113:             gService->mOfflineDevice->EvictEntries(nsnull);
43113: 
43113:         gService->mOfflineDevice->Shutdown();
43113:     }
43113:     gService->mEnableOfflineDevice = PR_FALSE;
43113: #endif // !NECKO_OFFLINE_CACHE
43113: 
43113:     if (gService->mMemoryDevice) {
43113:         // clear memory cache
43113:         gService->mMemoryDevice->EvictEntries(nsnull);
43113:     }
43113: 
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::OnProfileChanged()
43113: {
43113:     if (!gService)  return;
43113: 
43113:     CACHE_LOG_DEBUG(("nsCacheService::OnProfileChanged"));
43113:  
43113:     nsCacheServiceAutoLock lock;
43113:     
43113:     gService->mEnableDiskDevice    = gService->mObserver->DiskCacheEnabled();
43113:     gService->mEnableOfflineDevice = gService->mObserver->OfflineCacheEnabled();
43113:     gService->mEnableMemoryDevice  = gService->mObserver->MemoryCacheEnabled();
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:     if (gService->mDiskDevice) {
43113:         gService->mDiskDevice->SetCacheParentDirectory(gService->mObserver->DiskCacheParentDirectory());
43113:         gService->mDiskDevice->SetCapacity(gService->mObserver->DiskCacheCapacity());
43113: 
43113:         // XXX initialization of mDiskDevice could be made lazily, if mEnableDiskDevice is false
43113:         nsresult rv = gService->mDiskDevice->Init();
43113:         if (NS_FAILED(rv)) {
43113:             NS_ERROR("nsCacheService::OnProfileChanged: Re-initializing disk device failed");
43113:             gService->mEnableDiskDevice = PR_FALSE;
43113:             // XXX delete mDiskDevice?
43113:         }
43113:     }
43113: #endif // !NECKO_DISK_CACHE
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:     if (gService->mOfflineDevice) {
43113:         gService->mOfflineDevice->SetCacheParentDirectory(gService->mObserver->OfflineCacheParentDirectory());
43113:         gService->mOfflineDevice->SetCapacity(gService->mObserver->OfflineCacheCapacity());
43113: 
43113:         // XXX initialization of mOfflineDevice could be made lazily, if mEnableOfflineDevice is false
43113:         nsresult rv = gService->mOfflineDevice->Init();
43113:         if (NS_FAILED(rv)) {
43113:             NS_ERROR("nsCacheService::OnProfileChanged: Re-initializing offline device failed");
43113:             gService->mEnableOfflineDevice = PR_FALSE;
43113:             // XXX delete mOfflineDevice?
43113:         }
43113:     }
43113: #endif // !NECKO_OFFLINE_CACHE
43113:     
43113:     // If memoryDevice exists, reset its size to the new profile
43113:     if (gService->mMemoryDevice) {
43113:         if (gService->mEnableMemoryDevice) {
43113:             // make sure that capacity is reset to the right value
43113:             PRInt32 capacity = gService->mObserver->MemoryCacheCapacity();
43113:             CACHE_LOG_DEBUG(("Resetting memory device capacity to %d\n",
43113:                              capacity));
43113:             gService->mMemoryDevice->SetCapacity(capacity);
43113:         } else {
43113:             // tell memory device to evict everything
43113:             CACHE_LOG_DEBUG(("memory device disabled\n"));
43113:             gService->mMemoryDevice->SetCapacity(0);
43113:             // Don't delete memory device, because some entries may be active still...
43113:         }
43113:     }
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::SetDiskCacheEnabled(PRBool  enabled)
43113: {
43113:     if (!gService)  return;
43113:     nsCacheServiceAutoLock lock;
43113:     gService->mEnableDiskDevice = enabled;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::SetDiskCacheCapacity(PRInt32  capacity)
43113: {
43113:     if (!gService)  return;
43113:     nsCacheServiceAutoLock lock;
43113: 
43113: #ifdef NECKO_DISK_CACHE
43113:     if (gService->mDiskDevice) {
43113:         gService->mDiskDevice->SetCapacity(capacity);
43113:     }
43113: #endif // !NECKO_DISK_CACHE
43113:     
53962:     if (gService->mObserver)
43113:         gService->mEnableDiskDevice = gService->mObserver->DiskCacheEnabled();
43113: }
43113: 
43113: void
43113: nsCacheService::SetOfflineCacheEnabled(PRBool  enabled)
43113: {
43113:     if (!gService)  return;
43113:     nsCacheServiceAutoLock lock;
43113:     gService->mEnableOfflineDevice = enabled;
43113: }
43113: 
43113: void
43113: nsCacheService::SetOfflineCacheCapacity(PRInt32  capacity)
43113: {
43113:     if (!gService)  return;
43113:     nsCacheServiceAutoLock lock;
43113: 
43113: #ifdef NECKO_OFFLINE_CACHE
43113:     if (gService->mOfflineDevice) {
43113:         gService->mOfflineDevice->SetCapacity(capacity);
43113:     }
43113: #endif // !NECKO_OFFLINE_CACHE
43113: 
43113:     gService->mEnableOfflineDevice = gService->mObserver->OfflineCacheEnabled();
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::SetMemoryCache()
43113: {
43113:     if (!gService)  return;
43113: 
43113:     CACHE_LOG_DEBUG(("nsCacheService::SetMemoryCache"));
43113: 
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     gService->mEnableMemoryDevice = gService->mObserver->MemoryCacheEnabled();
43113: 
43113:     if (gService->mEnableMemoryDevice) {
43113:         if (gService->mMemoryDevice) {
43113:             PRInt32 capacity = gService->mObserver->MemoryCacheCapacity();
43113:             // make sure that capacity is reset to the right value
43113:             CACHE_LOG_DEBUG(("Resetting memory device capacity to %d\n",
43113:                              capacity));
43113:             gService->mMemoryDevice->SetCapacity(capacity);
43113:         }
43113:     } else {
43113:         if (gService->mMemoryDevice) {
43113:             // tell memory device to evict everything
43113:             CACHE_LOG_DEBUG(("memory device disabled\n"));
43113:             gService->mMemoryDevice->SetCapacity(0);
43113:             // Don't delete memory device, because some entries may be active still...
43113:         }
43113:     }
43113: }
43113: 
43113: 
43113: /******************************************************************************
43113:  * static methods for nsCacheEntryDescriptor
43113:  *****************************************************************************/
43113: #ifdef XP_MAC
43113: #pragma mark -
43113: #endif
43113: 
43113: void
43113: nsCacheService::CloseDescriptor(nsCacheEntryDescriptor * descriptor)
43113: {
43113:     // ask entry to remove descriptor
43113:     nsCacheEntry * entry       = descriptor->CacheEntry();
43113:     PRBool         stillActive = entry->RemoveDescriptor(descriptor);
43113:     nsresult       rv          = NS_OK;
43113: 
43113:     if (!entry->IsValid()) {
43113:         rv = gService->ProcessPendingRequests(entry);
43113:     }
43113: 
43113:     if (!stillActive) {
43113:         gService->DeactivateEntry(entry);
43113:     }
43113: }
43113: 
43113: 
43113: nsresult        
43113: nsCacheService::GetFileForEntry(nsCacheEntry *         entry,
43113:                                 nsIFile **             result)
43113: {
43113:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
43113:     if (!device)  return  NS_ERROR_UNEXPECTED;
43113:     
43113:     return device->GetFileForEntry(entry, result);
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::OpenInputStreamForEntry(nsCacheEntry *     entry,
43113:                                         nsCacheAccessMode  mode,
43113:                                         PRUint32           offset,
43113:                                         nsIInputStream  ** result)
43113: {
43113:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
43113:     if (!device)  return  NS_ERROR_UNEXPECTED;
43113: 
43113:     return device->OpenInputStreamForEntry(entry, mode, offset, result);
43113: }
43113: 
43113: nsresult
43113: nsCacheService::OpenOutputStreamForEntry(nsCacheEntry *     entry,
43113:                                          nsCacheAccessMode  mode,
43113:                                          PRUint32           offset,
43113:                                          nsIOutputStream ** result)
43113: {
43113:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
43113:     if (!device)  return  NS_ERROR_UNEXPECTED;
43113: 
43113:     return device->OpenOutputStreamForEntry(entry, mode, offset, result);
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::OnDataSizeChange(nsCacheEntry * entry, PRInt32 deltaSize)
43113: {
43113:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
43113:     if (!device)  return  NS_ERROR_UNEXPECTED;
43113: 
43113:     return device->OnDataSizeChange(entry, deltaSize);
43113: }
43113: 
43113: void
43113: nsCacheService::Lock()
43113: {
43113:     PR_Lock(gService->mLock);
43113: 
43113: #if defined(DEBUG)
43113:     gService->mLockedThread = PR_GetCurrentThread();
43113: #endif
43113: }
43113: 
43113: void
43113: nsCacheService::Unlock()
43113: {
43113:     NS_ASSERTION(gService->mLockedThread == PR_GetCurrentThread(), "oops");
43113: 
43113:     nsTArray<nsISupports*> doomed;
43113:     doomed.SwapElements(gService->mDoomedObjects);
43113: 
43113: #if defined(DEBUG)
43113:     gService->mLockedThread = nsnull;
43113: #endif
43113:     PR_Unlock(gService->mLock);
43113: 
43113:     for (PRUint32 i = 0; i < doomed.Length(); ++i)
43113:         doomed[i]->Release();
43113: }
43113: 
43113: void
43113: nsCacheService::ReleaseObject_Locked(nsISupports * obj,
43113:                                      nsIEventTarget * target)
43113: {
43113:     NS_ASSERTION(gService->mLockedThread == PR_GetCurrentThread(), "oops");
43113: 
43113:     PRBool isCur;
51302:     if (!target || (NS_SUCCEEDED(target->IsOnCurrentThread(&isCur)) && isCur)) {
43113:         gService->mDoomedObjects.AppendElement(obj);
43113:     } else {
43113:         NS_ProxyRelease(target, obj);
43113:     }
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::SetCacheElement(nsCacheEntry * entry, nsISupports * element)
43113: {
43113:     entry->SetData(element);
43113:     entry->TouchData();
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::ValidateEntry(nsCacheEntry * entry)
43113: {
43113:     nsCacheDevice * device = gService->EnsureEntryHasDevice(entry);
43113:     if (!device)  return  NS_ERROR_UNEXPECTED;
43113: 
43113:     entry->MarkValid();
43113:     nsresult rv = gService->ProcessPendingRequests(entry);
43113:     NS_ASSERTION(rv == NS_OK, "ProcessPendingRequests failed.");
43113:     // XXX what else should be done?
43113: 
43113:     return rv;
43113: }
43113: 
43113: #ifdef XP_MAC
43113: #pragma mark -
43113: #endif
43113: 
43113: 
43113: void
43113: nsCacheService::DeactivateEntry(nsCacheEntry * entry)
43113: {
43113:     CACHE_LOG_DEBUG(("Deactivating entry %p\n", entry));
43113:     nsresult  rv = NS_OK;
43113:     NS_ASSERTION(entry->IsNotInUse(), "### deactivating an entry while in use!");
43113:     nsCacheDevice * device = nsnull;
43113: 
43113:     if (mMaxDataSize < entry->DataSize() )     mMaxDataSize = entry->DataSize();
43113:     if (mMaxMetaSize < entry->MetaDataSize() ) mMaxMetaSize = entry->MetaDataSize();
43113: 
43113:     if (entry->IsDoomed()) {
43113:         // remove from Doomed list
43113:         PR_REMOVE_AND_INIT_LINK(entry);
43113:     } else if (entry->IsActive()) {
43113:         // remove from active entries
43113:         mActiveEntries.RemoveEntry(entry);
43113:         CACHE_LOG_DEBUG(("Removed deactivated entry %p from mActiveEntries\n",
43113:                          entry));
43113:         entry->MarkInactive();
43113: 
43113:         // bind entry if necessary to store meta-data
43113:         device = EnsureEntryHasDevice(entry); 
43113:         if (!device) {
43113:             CACHE_LOG_DEBUG(("DeactivateEntry: unable to bind active "
43113:                              "entry %p\n",
43113:                              entry));
43113:             NS_WARNING("DeactivateEntry: unable to bind active entry\n");
43113:             return;
43113:         }
43113:     } else {
43113:         // if mInitialized == PR_FALSE,
43113:         // then we're shutting down and this state is okay.
43113:         NS_ASSERTION(!mInitialized, "DeactivateEntry: bad cache entry state.");
43113:     }
43113: 
43113:     device = entry->CacheDevice();
43113:     if (device) {
43113:         rv = device->DeactivateEntry(entry);
43113:         if (NS_FAILED(rv)) {
43113:             // increment deactivate failure count
43113:             ++mDeactivateFailures;
43113:         }
43113:     } else {
43113:         // increment deactivating unbound entry statistic
43113:         ++mDeactivatedUnboundEntries;
43113:         delete entry; // because no one else will
43113:     }
43113: }
43113: 
43113: 
43113: nsresult
43113: nsCacheService::ProcessPendingRequests(nsCacheEntry * entry)
43113: {
43113:     nsresult            rv = NS_OK;
43113:     nsCacheRequest *    request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);
43113:     nsCacheRequest *    nextRequest;
43113:     PRBool              newWriter = PR_FALSE;
43113:     
43113:     if (request == &entry->mRequestQ)  return NS_OK;    // no queued requests
43113: 
43113:     if (!entry->IsDoomed() && entry->IsInvalid()) {
43113:         // 1st descriptor closed w/o MarkValid()
43113:         NS_ASSERTION(PR_CLIST_IS_EMPTY(&entry->mDescriptorQ), "shouldn't be here with open descriptors");
43113: 
43113: #if DEBUG
43113:         // verify no ACCESS_WRITE requests(shouldn't have any of these)
43113:         while (request != &entry->mRequestQ) {
43113:             NS_ASSERTION(request->AccessRequested() != nsICache::ACCESS_WRITE,
43113:                          "ACCESS_WRITE request should have been given a new entry");
43113:             request = (nsCacheRequest *)PR_NEXT_LINK(request);
43113:         }
43113:         request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);        
43113: #endif
43113:         // find first request with ACCESS_READ_WRITE (if any) and promote it to 1st writer
43113:         while (request != &entry->mRequestQ) {
43113:             if (request->AccessRequested() == nsICache::ACCESS_READ_WRITE) {
43113:                 newWriter = PR_TRUE;
43113:                 break;
43113:             }
43113: 
43113:             request = (nsCacheRequest *)PR_NEXT_LINK(request);
43113:         }
43113:         
43113:         if (request == &entry->mRequestQ)   // no requests asked for ACCESS_READ_WRITE, back to top
43113:             request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);
43113:         
43113:         // XXX what should we do if there are only READ requests in queue?
43113:         // XXX serialize their accesses, give them only read access, but force them to check validate flag?
43113:         // XXX or do readers simply presume the entry is valid
43113:     }
43113: 
43113:     nsCacheAccessMode  accessGranted = nsICache::ACCESS_NONE;
43113: 
43113:     while (request != &entry->mRequestQ) {
43113:         nextRequest = (nsCacheRequest *)PR_NEXT_LINK(request);
43113: 
43113:         if (request->mListener) {
43113: 
43113:             // Async request
43113:             PR_REMOVE_AND_INIT_LINK(request);
43113: 
43113:             if (entry->IsDoomed()) {
43113:                 rv = ProcessRequest(request, PR_FALSE, nsnull);
43113:                 if (rv == NS_ERROR_CACHE_WAIT_FOR_VALIDATION)
43113:                     rv = NS_OK;
43113:                 else
43113:                     delete request;
43113: 
43113:                 if (NS_FAILED(rv)) {
43113:                     // XXX what to do?
43113:                 }
43113:             } else if (entry->IsValid() || newWriter) {
43113:                 rv = entry->RequestAccess(request, &accessGranted);
43113:                 NS_ASSERTION(NS_SUCCEEDED(rv),
43113:                              "if entry is valid, RequestAccess must succeed.");
43113:                 // XXX if (newWriter)  NS_ASSERTION( accessGranted == request->AccessRequested(), "why not?");
43113: 
43113:                 // entry->CreateDescriptor dequeues request, and queues descriptor
43113:                 nsICacheEntryDescriptor *descriptor = nsnull;
43113:                 rv = entry->CreateDescriptor(request,
43113:                                              accessGranted,
43113:                                              &descriptor);
43113:                 
43113:                 // post call to listener to report error or descriptor
43113:                 rv = NotifyListener(request, descriptor, accessGranted, rv);
43113:                 delete request;
43113:                 if (NS_FAILED(rv)) {
43113:                     // XXX what to do?
43113:                 }
43113:                 
43113:             } else {
43113:                 // XXX bad state
43113:             }
43113:         } else {
43113: 
43113:             // Synchronous request
43113:             request->WakeUp();
43113:         }
43113:         if (newWriter)  break;  // process remaining requests after validation
43113:         request = nextRequest;
43113:     }
43113: 
43113:     return NS_OK;
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::ClearPendingRequests(nsCacheEntry * entry)
43113: {
43113:     nsCacheRequest * request = (nsCacheRequest *)PR_LIST_HEAD(&entry->mRequestQ);
43113:     
43113:     while (request != &entry->mRequestQ) {
43113:         nsCacheRequest * next = (nsCacheRequest *)PR_NEXT_LINK(request);
43113: 
43113:         // XXX we're just dropping these on the floor for now...definitely wrong.
43113:         PR_REMOVE_AND_INIT_LINK(request);
43113:         delete request;
43113:         request = next;
43113:     }
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::ClearDoomList()
43113: {
43113:     nsCacheEntry * entry = (nsCacheEntry *)PR_LIST_HEAD(&mDoomedEntries);
43113: 
43113:     while (entry != &mDoomedEntries) {
43113:         nsCacheEntry * next = (nsCacheEntry *)PR_NEXT_LINK(entry);
43113:         
43113:          entry->DetachDescriptors();
43113:          DeactivateEntry(entry);
43113:          entry = next;
43113:     }        
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::ClearActiveEntries()
43113: {
43113:     mActiveEntries.VisitEntries(DeactivateAndClearEntry, nsnull);
43113:     mActiveEntries.Shutdown();
43113: }
43113: 
43113: 
43113: PLDHashOperator
43113: nsCacheService::DeactivateAndClearEntry(PLDHashTable *    table,
43113:                                         PLDHashEntryHdr * hdr,
43113:                                         PRUint32          number,
43113:                                         void *            arg)
43113: {
43113:     nsCacheEntry * entry = ((nsCacheEntryHashTableEntry *)hdr)->cacheEntry;
43113:     NS_ASSERTION(entry, "### active entry = nsnull!");
43113:     gService->ClearPendingRequests(entry);
43113:     entry->DetachDescriptors();
43113:     
43113:     entry->MarkInactive();  // so we don't call Remove() while we're enumerating
43113:     gService->DeactivateEntry(entry);
43113:     
43113:     return PL_DHASH_REMOVE; // and continue enumerating
43113: }
43113: 
43113: 
43113: void
43113: nsCacheService::DoomActiveEntries()
43113: {
43113:     nsAutoTArray<nsCacheEntry*, 8> array;
43113: 
43113:     mActiveEntries.VisitEntries(RemoveActiveEntry, &array);
43113: 
43113:     PRUint32 count = array.Length();
43113:     for (PRUint32 i=0; i < count; ++i)
43113:         DoomEntry_Internal(array[i]);
43113: }
43113: 
43113: 
43113: PLDHashOperator
43113: nsCacheService::RemoveActiveEntry(PLDHashTable *    table,
43113:                                   PLDHashEntryHdr * hdr,
43113:                                   PRUint32          number,
43113:                                   void *            arg)
43113: {
43113:     nsCacheEntry * entry = ((nsCacheEntryHashTableEntry *)hdr)->cacheEntry;
43113:     NS_ASSERTION(entry, "### active entry = nsnull!");
43113: 
43113:     nsTArray<nsCacheEntry*> * array = (nsTArray<nsCacheEntry*> *) arg;
43113:     NS_ASSERTION(array, "### array = nsnull!");
43113:     array->AppendElement(entry);
43113: 
43113:     // entry is being removed from the active entry list
43113:     entry->MarkInactive();
43113:     return PL_DHASH_REMOVE; // and continue enumerating
43113: }
43113: 
43113: 
43113: #if defined(PR_LOGGING)
43113: void
43113: nsCacheService::LogCacheStatistics()
43113: {
43113:     PRUint32 hitPercentage = (PRUint32)((((double)mCacheHits) /
43113:         ((double)(mCacheHits + mCacheMisses))) * 100);
43113:     CACHE_LOG_ALWAYS(("\nCache Service Statistics:\n\n"));
43113:     CACHE_LOG_ALWAYS(("    TotalEntries   = %d\n", mTotalEntries));
43113:     CACHE_LOG_ALWAYS(("    Cache Hits     = %d\n", mCacheHits));
43113:     CACHE_LOG_ALWAYS(("    Cache Misses   = %d\n", mCacheMisses));
43113:     CACHE_LOG_ALWAYS(("    Cache Hit %%    = %d%%\n", hitPercentage));
43113:     CACHE_LOG_ALWAYS(("    Max Key Length = %d\n", mMaxKeyLength));
43113:     CACHE_LOG_ALWAYS(("    Max Meta Size  = %d\n", mMaxMetaSize));
43113:     CACHE_LOG_ALWAYS(("    Max Data Size  = %d\n", mMaxDataSize));
43113:     CACHE_LOG_ALWAYS(("\n"));
43113:     CACHE_LOG_ALWAYS(("    Deactivate Failures         = %d\n",
43113:                       mDeactivateFailures));
43113:     CACHE_LOG_ALWAYS(("    Deactivated Unbound Entries = %d\n",
43113:                       mDeactivatedUnboundEntries));
43113: }
43113: #endif
43113: 
43113: 
43113: void
43113: nsCacheService::OnEnterExitPrivateBrowsing()
43113: {
43113:     if (!gService)  return;
43113:     nsCacheServiceAutoLock lock;
43113: 
43113:     gService->DoomActiveEntries();
43113: 
43113:     if (gService->mMemoryDevice) {
43113:         // clear memory cache
43113:         gService->mMemoryDevice->EvictEntries(nsnull);
43113:     }
43113: }
