29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifdef JS_THREADSAFE
    1: 
    1: /*
    1:  * JS locking stubs.
    1:  */
    1: #include <stdlib.h>
12814: #include <string.h>
    1: #include "jspubtd.h"
55477: #include "jsutil.h"
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsbit.h"
    1: #include "jscntxt.h"
    1: #include "jsgc.h"
    1: #include "jslock.h"
    1: #include "jsscope.h"
    1: #include "jsstr.h"
    1: 
40230: using namespace js;
40230: 
    1: #define ReadWord(W) (W)
    1: 
30633: #if !defined(__GNUC__)
30633: # define __asm__ asm
30633: # define __volatile__ volatile
30633: #endif
30633: 
15974: /* Implement NativeCompareAndSwap. */
    1: 
43208: #if defined(_MSC_VER) && defined(_M_IX86)
    1: #pragma warning( disable : 4035 )
12437: JS_BEGIN_EXTERN_C
11643: extern long __cdecl
11643: _InterlockedCompareExchange(long *volatile dest, long exchange, long comp);
12437: JS_END_EXTERN_C
10460: #pragma intrinsic(_InterlockedCompareExchange)
10206: 
24073: JS_STATIC_ASSERT(sizeof(jsword) == sizeof(long));
24073: 
16284: static JS_ALWAYS_INLINE int
52910: NativeCompareAndSwapHelper(volatile jsword *w, jsword ov, jsword nv)
10206: {
24073:     _InterlockedCompareExchange((long*) w, nv, ov);
10206:     __asm {
10206:         sete al
10206:     }
10206: }
    1: 
16284: static JS_ALWAYS_INLINE int
52910: NativeCompareAndSwap(volatile jsword *w, jsword ov, jsword nv)
    1: {
15974:     return (NativeCompareAndSwapHelper(w, ov, nv) & 1);
    1: }
    1: 
30777: #elif defined(_MSC_VER) && (defined(_M_AMD64) || defined(_M_X64))
30777: JS_BEGIN_EXTERN_C
30777: extern long long __cdecl
30777: _InterlockedCompareExchange64(long long *volatile dest, long long exchange, long long comp);
30777: JS_END_EXTERN_C
30777: #pragma intrinsic(_InterlockedCompareExchange64)
30777: 
30777: static JS_ALWAYS_INLINE int
52918: NativeCompareAndSwap(volatile jsword *w, jsword ov, jsword nv)
30777: {
53477:     return _InterlockedCompareExchange64((long long *volatile)w, nv, ov) == ov;
30777: }
30777: 
10205: #elif defined(XP_MACOSX) || defined(DARWIN)
10205: 
10205: #include <libkern/OSAtomic.h>
10205: 
16284: static JS_ALWAYS_INLINE int
52918: NativeCompareAndSwap(volatile jsword *w, jsword ov, jsword nv)
10205: {
10206:     /* Details on these functions available in the manpage for atomic */
42729:     return OSAtomicCompareAndSwapPtrBarrier(reinterpret_cast<void *>(ov),
42729:                                             reinterpret_cast<void *>(nv),
52919:                                             reinterpret_cast<void * volatile *>(w));
    1: }
    1: 
30633: #elif defined(__i386) && (defined(__GNUC__) || defined(__SUNPRO_CC))
    1: 
    1: /* Note: This fails on 386 cpus, cmpxchgl is a >= 486 instruction */
16284: static JS_ALWAYS_INLINE int
52918: NativeCompareAndSwap(volatile jsword *w, jsword ov, jsword nv)
    1: {
    1:     unsigned int res;
    1: 
    1:     __asm__ __volatile__ (
    1:                           "lock\n"
    1:                           "cmpxchgl %2, (%1)\n"
    1:                           "sete %%al\n"
    1:                           "andl $1, %%eax\n"
    1:                           : "=a" (res)
38505: #ifdef __SUNPRO_CC
38505: /* Different code for Sun Studio because of a bug of SS12U1 */
38505:                           : "c" (w), "d" (nv), "a" (ov)
38505: #else
    1:                           : "r" (w), "r" (nv), "a" (ov)
38505: #endif
    1:                           : "cc", "memory");
    1:     return (int)res;
    1: }
30633: #elif defined(__x86_64) && (defined(__GNUC__) || defined(__SUNPRO_CC))
30633: 
16284: static JS_ALWAYS_INLINE int
52918: NativeCompareAndSwap(volatile jsword *w, jsword ov, jsword nv)
16059: {
16059:     unsigned int res;
16059: 
16059:     __asm__ __volatile__ (
16059:                           "lock\n"
16059:                           "cmpxchgq %2, (%1)\n"
16059:                           "sete %%al\n"
16059:                           "movzbl %%al, %%eax\n"
16059:                           : "=a" (res)
16059:                           : "r" (w), "r" (nv), "a" (ov)
16059:                           : "cc", "memory");
16059:     return (int)res;
16059: }
16059: 
33041: #elif defined(__sparc)
33041: #if defined(__GNUC__)
    1: 
16284: static JS_ALWAYS_INLINE int
52918: NativeCompareAndSwap(volatile jsword *w, jsword ov, jsword nv)
    1: {
    1:     unsigned int res;
30633: 
30633:     __asm__ __volatile__ (
42713:                   "membar #StoreLoad | #LoadLoad\n"
42713: #if JS_BITS_PER_WORD == 32
30633:                   "cas [%1],%2,%3\n"
42713: #else
42713:                   "casx [%1],%2,%3\n"
42713: #endif
42713:                   "membar #StoreLoad | #LoadLoad\n"
30633:                   "cmp %2,%3\n"
30633:                   "be,a 1f\n"
30633:                   "mov 1,%0\n"
30633:                   "mov 0,%0\n"
30633:                   "1:"
    1:                   : "=r" (res)
    1:                   : "r" (w), "r" (ov), "r" (nv));
    1:     return (int)res;
    1: }
    1: 
33041: #elif defined(__SUNPRO_CC)
33041: 
33041: /* Implementation in lock_sparc*.il */
33041: extern "C" int
52918: NativeCompareAndSwap(volatile jsword *w, jsword ov, jsword nv);
33041: 
33041: #endif
33041: 
    1: #elif defined(AIX)
    1: 
    1: #include <sys/atomic_op.h>
    1: 
16284: static JS_ALWAYS_INLINE int
52918: NativeCompareAndSwap(volatile jsword *w, jsword ov, jsword nv)
    1: {
41310:     int res;
41310:     JS_STATIC_ASSERT(sizeof(jsword) == sizeof(long));
41310: 
41310:     res = compare_and_swaplp((atomic_l)w, &ov, nv);
41310:     if (res)
41310:         __asm__("isync");
41310:     return res;
    1: }
    1: 
15258: #elif defined(USE_ARM_KUSER)
15258: 
15258: /* See https://bugzilla.mozilla.org/show_bug.cgi?id=429387 for a
15258:  * description of this ABI; this is a function provided at a fixed
15258:  * location by the kernel in the memory space of each process.
15258:  */
15258: typedef int (__kernel_cmpxchg_t)(int oldval, int newval, volatile int *ptr);
15258: #define __kernel_cmpxchg (*(__kernel_cmpxchg_t *)0xffff0fc0)
15258: 
15258: JS_STATIC_ASSERT(sizeof(jsword) == sizeof(int));
15258: 
16284: static JS_ALWAYS_INLINE int
52918: NativeCompareAndSwap(volatile jsword *w, jsword ov, jsword nv)
15258: {
15258:     volatile int *vp = (volatile int *) w;
16115:     PRInt32 failed = 1;
16115: 
16115:     /* Loop until a __kernel_cmpxchg succeeds. See bug 446169 */
16115:     do {
16115:         failed = __kernel_cmpxchg(ov, nv, vp);
16115:     } while (failed && *vp == ov);
16115:     return !failed;
15258: }
15258: 
18370: #elif JS_HAS_NATIVE_COMPARE_AND_SWAP
    1: 
15974: #error "JS_HAS_NATIVE_COMPARE_AND_SWAP should be 0 if your platform lacks a compare-and-swap instruction."
    1: 
    1: #endif /* arch-tests */
    1: 
17049: #if JS_HAS_NATIVE_COMPARE_AND_SWAP
17049: 
17049: JSBool
52910: js_CompareAndSwap(volatile jsword *w, jsword ov, jsword nv)
17049: {
18998:     return !!NativeCompareAndSwap(w, ov, nv);
17049: }
17049: 
17049: #elif defined(NSPR_LOCK)
17049: 
17049: # ifdef __GNUC__
30633: # warning "js_CompareAndSwap is implemented using NSPR lock"
17049: # endif
17049: 
17049: JSBool
52918: js_CompareAndSwap(volatile jsword *w, jsword ov, jsword nv)
17049: {
17049:     int result;
17049:     static PRLock *CompareAndSwapLock = JS_NEW_LOCK();
17049: 
17049:     JS_ACQUIRE_LOCK(CompareAndSwapLock);
17049:     result = (*w == ov);
17049:     if (result)
17049:         *w = nv;
17049:     JS_RELEASE_LOCK(CompareAndSwapLock);
17049:     return result;
17049: }
17049: 
17049: #else /* !defined(NSPR_LOCK) */
17049: 
17049: #error "NSPR_LOCK should be on when the platform lacks native compare-and-swap."
17049: 
17049: #endif
17049: 
27477: void
53221: js_AtomicSetMask(volatile jsword *w, jsword mask)
27477: {
27477:     jsword ov, nv;
27477: 
27477:     do {
27477:         ov = *w;
27477:         nv = ov | mask;
27477:     } while (!js_CompareAndSwap(w, ov, nv));
27477: }
27477: 
52753: void
52910: js_AtomicClearMask(volatile jsword *w, jsword mask)
52753: {
52753:     jsword ov, nv;
52753: 
52753:     do {
52753:         ov = *w;
52755:         nv = ov & ~mask;
52753:     } while (!js_CompareAndSwap(w, ov, nv));
52753: }
52753: 
17049: #ifndef NSPR_LOCK
17049: 
15994: struct JSFatLock {
15994:     int         susp;
15994:     PRLock      *slock;
15994:     PRCondVar   *svar;
15994:     JSFatLock   *next;
15994:     JSFatLock   **prevp;
15994: };
15994: 
15994: typedef struct JSFatLockTable {
15994:     JSFatLock   *free;
15994:     JSFatLock   *taken;
15994: } JSFatLockTable;
15994: 
15994: #define GLOBAL_LOCK_INDEX(id)   (((uint32)(jsuword)(id)>>2) & global_locks_mask)
15994: 
15994: static void
15994: js_Dequeue(JSThinLock *);
15994: 
15974: static PRLock **global_locks;
15974: static uint32 global_lock_count = 1;
15974: static uint32 global_locks_log2 = 0;
15974: static uint32 global_locks_mask = 0;
15974: 
15974: static void
15974: js_LockGlobal(void *id)
15974: {
15974:     uint32 i = GLOBAL_LOCK_INDEX(id);
15974:     PR_Lock(global_locks[i]);
15974: }
15974: 
15974: static void
15974: js_UnlockGlobal(void *id)
15974: {
15974:     uint32 i = GLOBAL_LOCK_INDEX(id);
15974:     PR_Unlock(global_locks[i]);
15974: }
15974: 
    1: #endif /* !NSPR_LOCK */
    1: 
    1: void
    1: js_InitLock(JSThinLock *tl)
    1: {
    1: #ifdef NSPR_LOCK
    1:     tl->owner = 0;
    1:     tl->fat = (JSFatLock*)JS_NEW_LOCK();
    1: #else
40229:     PodZero(tl);
    1: #endif
    1: }
    1: 
    1: void
    1: js_FinishLock(JSThinLock *tl)
    1: {
    1: #ifdef NSPR_LOCK
    1:     tl->owner = 0xdeadbeef;
    1:     if (tl->fat)
    1:         JS_DESTROY_LOCK(((JSLock*)tl->fat));
    1: #else
    1:     JS_ASSERT(tl->owner == 0);
    1:     JS_ASSERT(tl->fat == NULL);
    1: #endif
    1: }
    1: 
    1: #ifdef DEBUG_SCOPE_COUNT
    1: 
    1: #include <stdio.h>
    1: #include "jsdhash.h"
    1: 
24876: static FILE *logfp = NULL;
    1: static JSDHashTable logtbl;
    1: 
    1: typedef struct logentry {
    1:     JSDHashEntryStub stub;
    1:     char             op;
    1:     const char       *file;
    1:     int              line;
    1: } logentry;
    1: 
    1: static void
24876: logit(JSTitle *title, char op, const char *file, int line)
    1: {
    1:     logentry *entry;
    1: 
    1:     if (!logfp) {
    1:         logfp = fopen("/tmp/scope.log", "w");
    1:         if (!logfp)
    1:             return;
    1:         setvbuf(logfp, NULL, _IONBF, 0);
    1:     }
24876:     fprintf(logfp, "%p %d %c %s %d\n", title, title->u.count, op, file, line);
    1: 
    1:     if (!logtbl.entryStore &&
    1:         !JS_DHashTableInit(&logtbl, JS_DHashGetStubOps(), NULL,
    1:                            sizeof(logentry), 100)) {
    1:         return;
    1:     }
24876:     entry = (logentry *) JS_DHashTableOperate(&logtbl, title, JS_DHASH_ADD);
    1:     if (!entry)
    1:         return;
24876:     entry->stub.key = title;
    1:     entry->op = op;
    1:     entry->file = file;
    1:     entry->line = line;
    1: }
    1: 
    1: void
24876: js_unlog_title(JSTitle *title)
    1: {
    1:     if (!logtbl.entryStore)
    1:         return;
24876:     (void) JS_DHashTableOperate(&logtbl, title, JS_DHASH_REMOVE);
    1: }
    1: 
24876: # define LOGIT(title,op) logit(title, op, __FILE__, __LINE__)
    1: 
    1: #else
    1: 
24876: # define LOGIT(title, op) /* nothing */
    1: 
    1: #endif /* DEBUG_SCOPE_COUNT */
    1: 
    1: /*
27384:  * Return true if we would deadlock waiting in ClaimTitle on
27384:  * rt->titleSharingDone until ownercx finishes its request and shares a title.
    1:  *
    1:  * (i) rt->gcLock held
    1:  */
27384: static bool
27384: WillDeadlock(JSContext *ownercx, JSThread *thread)
    1: {
27384:     JS_ASSERT(CURRENT_THREAD_IS_ME(thread));
27384:     JS_ASSERT(ownercx->thread != thread);
    1: 
27384:      for (;;) {
27384:         JS_ASSERT(ownercx->thread);
56229:         JS_ASSERT(ownercx->thread->requestDepth);
27384:         JSTitle *title = ownercx->thread->titleToShare;
27384:         if (!title || !title->ownercx) {
27384:             /*
27384:              * ownercx->thread doesn't wait or has just been notified that the
27384:              * title became shared.
27384:              */
27384:             return false;
27384:         }
27384: 
27384:         /*
27384:          * ownercx->thread is waiting in ClaimTitle for a context from some
27384:          * thread to finish its request. If that thread is the current thread,
27384:          * we would deadlock. Otherwise we must recursively check if that
27384:          * thread waits for the current thread.
27384:          */
27384:         if (title->ownercx->thread == thread) {
27384:             JS_RUNTIME_METER(ownercx->runtime, deadlocksAvoided);
27384:             return true;
27384:         }
11739:         ownercx = title->ownercx;
    1:      }
    1: }
    1: 
27384: static void
27384: FinishSharingTitle(JSContext *cx, JSTitle *title);
27384: 
    1: /*
11739:  * Make title multi-threaded, i.e. share its ownership among contexts in rt
    1:  * using a "thin" or (if necessary due to contention) "fat" lock.  Called only
11739:  * from ClaimTitle, immediately below, when we detect deadlock were we to wait
11739:  * for title's lock, because its ownercx is waiting on a title owned by the
    1:  * calling cx.
    1:  *
    1:  * (i) rt->gcLock held
    1:  */
    1: static void
11739: ShareTitle(JSContext *cx, JSTitle *title)
    1: {
    1:     JSRuntime *rt;
11739:     JSTitle **todop;
    1: 
    1:     rt = cx->runtime;
11739:     if (title->u.link) {
11739:         for (todop = &rt->titleSharingTodo; *todop != title;
    1:              todop = &(*todop)->u.link) {
11739:             JS_ASSERT(*todop != NO_TITLE_SHARING_TODO);
    1:         }
11739:         *todop = title->u.link;
11739:         title->u.link = NULL;       /* null u.link for sanity ASAP */
11739:         JS_NOTIFY_ALL_CONDVAR(rt->titleSharingDone);
    1:     }
27384:     FinishSharingTitle(cx, title);
    1: }
    1: 
    1: /*
27384:  * FinishSharingTitle is the tail part of ShareTitle, split out to become a
27384:  * subroutine of js_ShareWaitingTitles too. The bulk of the work here involves
27384:  * making mutable strings in the title's object's slots be immutable. We have
27384:  * to do this because such strings will soon be available to multiple threads,
27384:  * so their buffers can't be realloc'd any longer in js_ConcatStrings, and
48491:  * their members can't be modified by js_ConcatStrings, JSString::undepend, or
29366:  * MinimizeDependentStrings.
    1:  *
27384:  * The last bit of work done by this function nulls title->ownercx and updates
27384:  * rt->sharedTitles.
    1:  */
27384: static void
27384: FinishSharingTitle(JSContext *cx, JSTitle *title)
    1: {
27384:     js_InitLock(&title->lock);
27384:     title->u.count = 0;     /* NULL may not pun as 0 */
32684: 
52503:     JSObject *obj = TITLE_TO_OBJECT(title);
16522:     if (obj) {
53652:         uint32 nslots = obj->slotSpan();
55746:         for (uint32 i = 0; i != nslots; ++i) {
48470:             Value v = obj->getSlot(i);
48470:             if (v.isString() &&
48470:                 !js_MakeStringImmutable(cx, v.toString())) {
    1:                 /*
16522:                  * FIXME bug 363059: The following error recovery changes
16522:                  * runtime execution semantics, arbitrarily and silently
16522:                  * ignoring errors except out-of-memory, which should have been
16522:                  * reported through JS_ReportOutOfMemory at this point.
    1:                  */
48470:                 obj->setSlot(i, UndefinedValue());
    1:             }
    1:         }
16522:     }
    1: 
11739:     title->ownercx = NULL;  /* NB: set last, after lock init */
11739:     JS_RUNTIME_METER(cx->runtime, sharedTitles);
    1: }
    1: 
    1: /*
11739:  * Given a title with apparently non-null ownercx different from cx, try to
11739:  * set ownercx to cx, claiming exclusive (single-threaded) ownership of title.
    1:  * If we claim ownership, return true.  Otherwise, we wait for ownercx to be
11739:  * set to null (indicating that title is multi-threaded); or if waiting would
11739:  * deadlock, we set ownercx to null ourselves via ShareTitle.  In any case,
    1:  * once ownercx is null we return false.
    1:  */
    1: static JSBool
11739: ClaimTitle(JSTitle *title, JSContext *cx)
    1: {
37743:     JSRuntime *rt = cx->runtime;
56229:     JS_ASSERT_IF(!cx->thread->requestDepth, cx->thread == rt->gcThread && rt->gcRunning);
    1: 
    1:     JS_RUNTIME_METER(rt, claimAttempts);
40840:     AutoLockGC lock(rt);
    1: 
    1:     /* Reload in case ownercx went away while we blocked on the lock. */
37743:     while (JSContext *ownercx = title->ownercx) {
    1:         /*
    1:          * Avoid selflock if ownercx is dead, or is not running a request, or
37743:          * has the same thread as cx, or cx->thread runs the GC (in which case
37743:          * all other requests must be suspended), or ownercx->thread runs a GC
37743:          * and the GC waits for all requests to finish. Set title->ownercx to
52503:          * cx so that the matching JS_UNLOCK_OBJ macro call will take the fast
52503:          * path around the corresponding js_UnlockObj function call.
    1:          *
11739:          * If title->u.link is non-null, title has already been inserted on
11739:          * the rt->titleSharingTodo list, because another thread's context
11739:          * already wanted to lock title while ownercx was running a request.
37743:          * That context must still be in request and cannot be dead. Moreover,
37743:          * the GC can not run at this moment as it must wait until all the
37743:          * titles are shared and the threads that want to lock them finish
37743:          * their requests. Thus we can claim the title if its thread matches
37743:          * ours.
    1:          */
27384:         bool canClaim;
27384:         if (title->u.link) {
27384:             JS_ASSERT(js_ValidContextPointer(rt, ownercx));
56229:             JS_ASSERT(ownercx->thread->requestDepth);
37743:             JS_ASSERT(!rt->gcRunning);
37743:             canClaim = (ownercx->thread == cx->thread);
27384:         } else {
27384:             canClaim = (!js_ValidContextPointer(rt, ownercx) ||
48584:                         !ownercx->thread ||
56229:                         !ownercx->thread->requestDepth ||
37743:                         cx->thread == ownercx->thread  ||
37743:                         cx->thread == rt->gcThread ||
37743:                         ownercx->thread->gcWaiting);
27384:         }
27384:         if (canClaim) {
11739:             title->ownercx = cx;
11739:             JS_RUNTIME_METER(rt, claimedTitles);
    1:             return JS_TRUE;
    1:         }
    1: 
    1:         /*
27384:          * Avoid deadlock if title's owner thread is waiting on a title that
27384:          * the current thread owns, by revoking title's ownership. This
27384:          * approach to deadlock avoidance works because the engine never nests
27384:          * title locks.
    1:          *
27384:          * If cx->thread could hold locks on ownercx->thread->titleToShare, or
27384:          * if ownercx->thread could hold locks on title, we would need to keep
27384:          * reentrancy counts for all such "flyweight" (ownercx != NULL) locks,
27384:          * so that control would unwind properly once these locks became
27384:          * "thin" or "fat". The engine promotes a title from exclusive to
27384:          * shared access only when locking, never when holding or unlocking.
    1:          */
37743:         if (WillDeadlock(ownercx, cx->thread)) {
11739:             ShareTitle(cx, title);
    1:             break;
    1:         }
    1: 
    1:         /*
11739:          * Thanks to the non-zero NO_TITLE_SHARING_TODO link terminator, we
11739:          * can decide whether title is on rt->titleSharingTodo with a single
    1:          * non-null test, and avoid double-insertion bugs.
    1:          */
11739:         if (!title->u.link) {
11739:             title->u.link = rt->titleSharingTodo;
11739:             rt->titleSharingTodo = title;
    1:         }
    1: 
    1:         /*
11739:          * We know that some other thread's context owns title, which is now
11739:          * linked onto rt->titleSharingTodo, awaiting the end of that other
11739:          * thread's request. So it is safe to wait on rt->titleSharingDone.
27384:          * But before waiting, we force the operation callback for that other
27384:          * thread so it can quickly suspend.
    1:          */
56229:         JS_THREAD_DATA(ownercx)->triggerOperationCallback();
27384: 
27384:         JS_ASSERT(!cx->thread->titleToShare);
27384:         cx->thread->titleToShare = title;
27384: #ifdef DEBUG
27384:         PRStatus stat =
27384: #endif
27384:             PR_WaitCondVar(rt->titleSharingDone, PR_INTERVAL_NO_TIMEOUT);
    1:         JS_ASSERT(stat != PR_FAILURE);
27384:         cx->thread->titleToShare = NULL;
    1:     }
    1:     return JS_FALSE;
    1: }
    1: 
27384: void
27384: js_ShareWaitingTitles(JSContext *cx)
27384: {
27384:     JSTitle *title, **todop;
27384:     bool shared;
27384: 
27384:     /* See whether cx has any single-threaded titles to start sharing. */
27384:     todop = &cx->runtime->titleSharingTodo;
27384:     shared = false;
27384:     while ((title = *todop) != NO_TITLE_SHARING_TODO) {
37743:         if (title->ownercx->thread != cx->thread) {
27384:             todop = &title->u.link;
27384:             continue;
27384:         }
27384:         *todop = title->u.link;
27384:         title->u.link = NULL;           /* null u.link for sanity ASAP */
27384: 
27384:         FinishSharingTitle(cx, title);  /* set ownercx = NULL */
27384:         shared = true;
27384:     }
27384:     if (shared)
27384:         JS_NOTIFY_ALL_CONDVAR(cx->runtime->titleSharingDone);
27384: }
27384: 
    1: /* Exported to js.c, which calls it via OBJ_GET_* and JSVAL_IS_* macros. */
    1: JS_FRIEND_API(jsval)
    1: js_GetSlotThreadSafe(JSContext *cx, JSObject *obj, uint32 slot)
    1: {
    1:     jsval v;
    1: #ifndef NSPR_LOCK
    1:     JSThinLock *tl;
    1:     jsword me;
    1: #endif
    1: 
32603:     OBJ_CHECK_SLOT(obj, slot);
    1: 
    1:     /*
    1:      * Native object locking is inlined here to optimize the single-threaded
    1:      * and contention-free multi-threaded cases.
    1:      */
52503:     JS_ASSERT(obj->title.ownercx != cx);
53650:     JS_ASSERT(obj->containsSlot(slot));
    1: 
    1:     /*
54563:      * Avoid locking if called from the GC.  Also avoid locking a non-extensible
52503:      * object.  If neither of those special cases applies, try to claim obj's
52503:      * flyweight lock from whatever context may have had it in an earlier
52503:      * request.
    1:      */
    1:     if (CX_THREAD_IS_RUNNING_GC(cx) ||
54563:         !obj->isExtensible() ||
52503:         (obj->title.ownercx && ClaimTitle(&obj->title, cx))) {
48470:         return Jsvalify(obj->getSlot(slot));
    1:     }
    1: 
    1: #ifndef NSPR_LOCK
52503:     tl = &obj->title.lock;
    1:     me = CX_THINLOCK_ID(cx);
    1:     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
15974:     if (NativeCompareAndSwap(&tl->owner, 0, me)) {
    1:         /*
    1:          * Got the lock with one compare-and-swap. Even so, someone else may
52503:          * have mutated obj so it now has its own title lock, which would
    1:          * require either a restart from the top of this routine, or a thin
    1:          * lock release followed by fat lock acquisition.
    1:          */
48470:         v = Jsvalify(obj->getSlot(slot));
15974:         if (!NativeCompareAndSwap(&tl->owner, me, 0)) {
52503:             /* Assert that title locks never revert to flyweight. */
52503:             JS_ASSERT(obj->title.ownercx != cx);
52503:             LOGIT(obj->title, '1');
52503:             obj->title.u.count = 1;
    1:             js_UnlockObj(cx, obj);
    1:         }
    1:         return v;
    1:     }
52503:     if (Thin_RemoveWait(ReadWord(tl->owner)) == me)
48470:         return Jsvalify(obj->getSlot(slot));
    1: #endif
    1: 
    1:     js_LockObj(cx, obj);
48470:     v = Jsvalify(obj->getSlot(slot));
    1: 
    1:     /*
    1:      * Test whether cx took ownership of obj's scope during js_LockObj.
    1:      *
    1:      * This does not mean that a given scope reverted to flyweight from "thin"
    1:      * or "fat" -- it does mean that obj's map pointer changed due to another
    1:      * thread setting a property, requiring obj to cease sharing a prototype
    1:      * object's scope (whose lock was not flyweight, else we wouldn't be here
    1:      * in the first place!).
    1:      */
52503:     if (obj->title.ownercx != cx)
52503:         js_UnlockTitle(cx, &obj->title);
    1:     return v;
    1: }
    1: 
    1: void
    1: js_SetSlotThreadSafe(JSContext *cx, JSObject *obj, uint32 slot, jsval v)
    1: {
    1: #ifndef NSPR_LOCK
    1:     JSThinLock *tl;
    1:     jsword me;
    1: #endif
    1: 
32603:     OBJ_CHECK_SLOT(obj, slot);
32603: 
    1:     /* Any string stored in a thread-safe object must be immutable. */
    1:     if (JSVAL_IS_STRING(v) &&
 4718:         !js_MakeStringImmutable(cx, JSVAL_TO_STRING(v))) {
    1:         /* FIXME bug 363059: See comments in js_FinishSharingScope. */
    1:         v = JSVAL_NULL;
    1:     }
    1: 
    1:     /*
    1:      * Native object locking is inlined here to optimize the single-threaded
    1:      * and contention-free multi-threaded cases.
    1:      */
52503:     JS_ASSERT(obj->title.ownercx != cx);
53650:     JS_ASSERT(obj->containsSlot(slot));
    1: 
    1:     /*
54563:      * Avoid locking if called from the GC.  Also avoid locking a non-extensible
52503:      * object.  If neither of those special cases applies, try to claim obj's
52503:      * flyweight lock from whatever context may have had it in an earlier
52503:      * request.
    1:      */
    1:     if (CX_THREAD_IS_RUNNING_GC(cx) ||
54563:         !obj->isExtensible() ||
52503:         (obj->title.ownercx && ClaimTitle(&obj->title, cx))) {
48470:         obj->lockedSetSlot(slot, Valueify(v));
    1:         return;
    1:     }
    1: 
    1: #ifndef NSPR_LOCK
52503:     tl = &obj->title.lock;
    1:     me = CX_THINLOCK_ID(cx);
    1:     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
15974:     if (NativeCompareAndSwap(&tl->owner, 0, me)) {
48470:         obj->lockedSetSlot(slot, Valueify(v));
15974:         if (!NativeCompareAndSwap(&tl->owner, me, 0)) {
    1:             /* Assert that scope locks never revert to flyweight. */
52503:             JS_ASSERT(obj->title.ownercx != cx);
52503:             LOGIT(obj->title, '1');
52503:             obj->title.u.count = 1;
    1:             js_UnlockObj(cx, obj);
    1:         }
    1:         return;
    1:     }
52503:     if (Thin_RemoveWait(ReadWord(tl->owner)) == me) {
48470:         obj->lockedSetSlot(slot, Valueify(v));
    1:         return;
    1:     }
    1: #endif
    1: 
    1:     js_LockObj(cx, obj);
48470:     obj->lockedSetSlot(slot, Valueify(v));
    1: 
    1:     /*
11377:      * Same drill as above, in js_GetSlotThreadSafe.
    1:      */
52503:     if (obj->title.ownercx != cx)
52503:         js_UnlockTitle(cx, &obj->title);
    1: }
    1: 
    1: #ifndef NSPR_LOCK
    1: 
    1: static JSFatLock *
    1: NewFatlock()
    1: {
41099:     JSFatLock *fl = (JSFatLock *)js_malloc(sizeof(JSFatLock)); /* for now */
    1:     if (!fl) return NULL;
    1:     fl->susp = 0;
    1:     fl->next = NULL;
    1:     fl->prevp = NULL;
    1:     fl->slock = PR_NewLock();
    1:     fl->svar = PR_NewCondVar(fl->slock);
    1:     return fl;
    1: }
    1: 
    1: static void
    1: DestroyFatlock(JSFatLock *fl)
    1: {
    1:     PR_DestroyLock(fl->slock);
    1:     PR_DestroyCondVar(fl->svar);
30851:     js_free(fl);
    1: }
    1: 
    1: static JSFatLock *
    1: ListOfFatlocks(int listc)
    1: {
    1:     JSFatLock *m;
    1:     JSFatLock *m0;
    1:     int i;
    1: 
    1:     JS_ASSERT(listc>0);
    1:     m0 = m = NewFatlock();
    1:     for (i=1; i<listc; i++) {
    1:         m->next = NewFatlock();
    1:         m = m->next;
    1:     }
    1:     return m0;
    1: }
    1: 
    1: static void
    1: DeleteListOfFatlocks(JSFatLock *m)
    1: {
    1:     JSFatLock *m0;
    1:     for (; m; m=m0) {
    1:         m0 = m->next;
    1:         DestroyFatlock(m);
    1:     }
    1: }
    1: 
    1: static JSFatLockTable *fl_list_table = NULL;
    1: static uint32          fl_list_table_len = 0;
    1: static uint32          fl_list_chunk_len = 0;
    1: 
    1: static JSFatLock *
    1: GetFatlock(void *id)
    1: {
    1:     JSFatLock *m;
    1: 
    1:     uint32 i = GLOBAL_LOCK_INDEX(id);
    1:     if (fl_list_table[i].free == NULL) {
    1: #ifdef DEBUG
    1:         if (fl_list_table[i].taken)
    1:             printf("Ran out of fat locks!\n");
    1: #endif
    1:         fl_list_table[i].free = ListOfFatlocks(fl_list_chunk_len);
    1:     }
    1:     m = fl_list_table[i].free;
    1:     fl_list_table[i].free = m->next;
    1:     m->susp = 0;
    1:     m->next = fl_list_table[i].taken;
    1:     m->prevp = &fl_list_table[i].taken;
    1:     if (fl_list_table[i].taken)
    1:         fl_list_table[i].taken->prevp = &m->next;
    1:     fl_list_table[i].taken = m;
    1:     return m;
    1: }
    1: 
    1: static void
    1: PutFatlock(JSFatLock *m, void *id)
    1: {
    1:     uint32 i;
    1:     if (m == NULL)
    1:         return;
    1: 
    1:     /* Unlink m from fl_list_table[i].taken. */
    1:     *m->prevp = m->next;
    1:     if (m->next)
    1:         m->next->prevp = m->prevp;
    1: 
    1:     /* Insert m in fl_list_table[i].free. */
    1:     i = GLOBAL_LOCK_INDEX(id);
    1:     m->next = fl_list_table[i].free;
    1:     fl_list_table[i].free = m;
    1: }
    1: 
    1: #endif /* !NSPR_LOCK */
    1: 
    1: JSBool
    1: js_SetupLocks(int listc, int globc)
    1: {
    1: #ifndef NSPR_LOCK
    1:     uint32 i;
    1: 
    1:     if (global_locks)
    1:         return JS_TRUE;
    1: #ifdef DEBUG
    1:     if (listc > 10000 || listc < 0) /* listc == fat lock list chunk length */
    1:         printf("Bad number %d in js_SetupLocks()!\n", listc);
    1:     if (globc > 100 || globc < 0)   /* globc == number of global locks */
    1:         printf("Bad number %d in js_SetupLocks()!\n", listc);
    1: #endif
    1:     global_locks_log2 = JS_CeilingLog2(globc);
    1:     global_locks_mask = JS_BITMASK(global_locks_log2);
    1:     global_lock_count = JS_BIT(global_locks_log2);
30851:     global_locks = (PRLock **) js_malloc(global_lock_count * sizeof(PRLock*));
    1:     if (!global_locks)
    1:         return JS_FALSE;
    1:     for (i = 0; i < global_lock_count; i++) {
    1:         global_locks[i] = PR_NewLock();
    1:         if (!global_locks[i]) {
    1:             global_lock_count = i;
    1:             js_CleanupLocks();
    1:             return JS_FALSE;
    1:         }
    1:     }
30851:     fl_list_table = (JSFatLockTable *) js_malloc(i * sizeof(JSFatLockTable));
    1:     if (!fl_list_table) {
    1:         js_CleanupLocks();
    1:         return JS_FALSE;
    1:     }
    1:     fl_list_table_len = global_lock_count;
    1:     for (i = 0; i < global_lock_count; i++)
    1:         fl_list_table[i].free = fl_list_table[i].taken = NULL;
    1:     fl_list_chunk_len = listc;
    1: #endif /* !NSPR_LOCK */
    1:     return JS_TRUE;
    1: }
    1: 
    1: void
    1: js_CleanupLocks()
    1: {
    1: #ifndef NSPR_LOCK
    1:     uint32 i;
    1: 
    1:     if (global_locks) {
    1:         for (i = 0; i < global_lock_count; i++)
    1:             PR_DestroyLock(global_locks[i]);
30851:         js_free(global_locks);
    1:         global_locks = NULL;
    1:         global_lock_count = 1;
    1:         global_locks_log2 = 0;
    1:         global_locks_mask = 0;
    1:     }
    1:     if (fl_list_table) {
    1:         for (i = 0; i < fl_list_table_len; i++) {
    1:             DeleteListOfFatlocks(fl_list_table[i].free);
    1:             fl_list_table[i].free = NULL;
    1:             DeleteListOfFatlocks(fl_list_table[i].taken);
    1:             fl_list_table[i].taken = NULL;
    1:         }
30851:         js_free(fl_list_table);
    1:         fl_list_table = NULL;
    1:         fl_list_table_len = 0;
    1:     }
    1: #endif /* !NSPR_LOCK */
    1: }
    1: 
15994: #ifdef NSPR_LOCK
15994: 
16284: static JS_ALWAYS_INLINE void
15994: ThinLock(JSThinLock *tl, jsword me)
15994: {
15994:     JS_ACQUIRE_LOCK((JSLock *) tl->fat);
15994:     tl->owner = me;
15994: }
15994: 
16284: static JS_ALWAYS_INLINE void
15994: ThinUnlock(JSThinLock *tl, jsword /*me*/)
15994: {
15994:     tl->owner = 0;
15994:     JS_RELEASE_LOCK((JSLock *) tl->fat);
15994: }
15994: 
15994: #else
    1: 
    1: /*
    1:  * Fast locking and unlocking is implemented by delaying the allocation of a
    1:  * system lock (fat lock) until contention.  As long as a locking thread A
    1:  * runs uncontended, the lock is represented solely by storing A's identity in
    1:  * the object being locked.
    1:  *
    1:  * If another thread B tries to lock the object currently locked by A, B is
    1:  * enqueued into a fat lock structure (which might have to be allocated and
    1:  * pointed to by the object), and suspended using NSPR conditional variables
    1:  * (wait).  A wait bit (Bacon bit) is set in the lock word of the object,
    1:  * signalling to A that when releasing the lock, B must be dequeued and
    1:  * notified.
    1:  *
    1:  * The basic operation of the locking primitives (js_Lock, js_Unlock,
    1:  * js_Enqueue, and js_Dequeue) is compare-and-swap.  Hence, when locking into
    1:  * the word pointed at by p, compare-and-swap(p, 0, A) success implies that p
    1:  * is unlocked.  Similarly, when unlocking p, if compare-and-swap(p, A, 0)
    1:  * succeeds this implies that p is uncontended (no one is waiting because the
    1:  * wait bit is not set).
    1:  *
    1:  * When dequeueing, the lock is released, and one of the threads suspended on
    1:  * the lock is notified.  If other threads still are waiting, the wait bit is
    1:  * kept (in js_Enqueue), and if not, the fat lock is deallocated.
    1:  *
    1:  * The functions js_Enqueue, js_Dequeue, js_SuspendThread, and js_ResumeThread
    1:  * are serialized using a global lock.  For scalability, a hashtable of global
    1:  * locks is used, which is indexed modulo the thin lock pointer.
    1:  */
    1: 
    1: /*
    1:  * Invariants:
    1:  * (i)  global lock is held
    1:  * (ii) fl->susp >= 0
    1:  */
    1: static int
    1: js_SuspendThread(JSThinLock *tl)
    1: {
    1:     JSFatLock *fl;
    1:     PRStatus stat;
    1: 
    1:     if (tl->fat == NULL)
    1:         fl = tl->fat = GetFatlock(tl);
    1:     else
    1:         fl = tl->fat;
    1:     JS_ASSERT(fl->susp >= 0);
    1:     fl->susp++;
    1:     PR_Lock(fl->slock);
    1:     js_UnlockGlobal(tl);
    1:     stat = PR_WaitCondVar(fl->svar, PR_INTERVAL_NO_TIMEOUT);
    1:     JS_ASSERT(stat != PR_FAILURE);
    1:     PR_Unlock(fl->slock);
    1:     js_LockGlobal(tl);
    1:     fl->susp--;
    1:     if (fl->susp == 0) {
    1:         PutFatlock(fl, tl);
    1:         tl->fat = NULL;
    1:     }
    1:     return tl->fat == NULL;
    1: }
    1: 
    1: /*
    1:  * (i)  global lock is held
    1:  * (ii) fl->susp > 0
    1:  */
    1: static void
    1: js_ResumeThread(JSThinLock *tl)
    1: {
    1:     JSFatLock *fl = tl->fat;
    1:     PRStatus stat;
    1: 
    1:     JS_ASSERT(fl != NULL);
    1:     JS_ASSERT(fl->susp > 0);
    1:     PR_Lock(fl->slock);
    1:     js_UnlockGlobal(tl);
    1:     stat = PR_NotifyCondVar(fl->svar);
    1:     JS_ASSERT(stat != PR_FAILURE);
    1:     PR_Unlock(fl->slock);
    1: }
    1: 
    1: static void
    1: js_Enqueue(JSThinLock *tl, jsword me)
    1: {
    1:     jsword o, n;
    1: 
    1:     js_LockGlobal(tl);
    1:     for (;;) {
    1:         o = ReadWord(tl->owner);
    1:         n = Thin_SetWait(o);
15974:         if (o != 0 && NativeCompareAndSwap(&tl->owner, o, n)) {
    1:             if (js_SuspendThread(tl))
    1:                 me = Thin_RemoveWait(me);
    1:             else
    1:                 me = Thin_SetWait(me);
    1:         }
15974:         else if (NativeCompareAndSwap(&tl->owner, 0, me)) {
    1:             js_UnlockGlobal(tl);
    1:             return;
    1:         }
    1:     }
    1: }
    1: 
    1: static void
    1: js_Dequeue(JSThinLock *tl)
    1: {
    1:     jsword o;
    1: 
    1:     js_LockGlobal(tl);
    1:     o = ReadWord(tl->owner);
    1:     JS_ASSERT(Thin_GetWait(o) != 0);
    1:     JS_ASSERT(tl->fat != NULL);
15974:     if (!NativeCompareAndSwap(&tl->owner, o, 0)) /* release it */
    1:         JS_ASSERT(0);
    1:     js_ResumeThread(tl);
    1: }
    1: 
16284: static JS_ALWAYS_INLINE void
15994: ThinLock(JSThinLock *tl, jsword me)
    1: {
    1:     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
15974:     if (NativeCompareAndSwap(&tl->owner, 0, me))
    1:         return;
    1:     if (Thin_RemoveWait(ReadWord(tl->owner)) != me)
    1:         js_Enqueue(tl, me);
    1: #ifdef DEBUG
    1:     else
    1:         JS_ASSERT(0);
    1: #endif
    1: }
    1: 
16284: static JS_ALWAYS_INLINE void
15994: ThinUnlock(JSThinLock *tl, jsword me)
    1: {
    1:     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
    1: 
    1:     /*
15974:      * Since we can race with the NativeCompareAndSwap in js_Enqueue, we need
11120:      * to use a C_A_S here as well -- Arjan van de Ven 30/1/08
    1:      */
15974:     if (NativeCompareAndSwap(&tl->owner, me, 0))
    1:         return;
11120: 
    1:     JS_ASSERT(Thin_GetWait(tl->owner));
    1:     if (Thin_RemoveWait(ReadWord(tl->owner)) == me)
    1:         js_Dequeue(tl);
    1: #ifdef DEBUG
    1:     else
    1:         JS_ASSERT(0);   /* unbalanced unlock */
    1: #endif
    1: }
    1: 
    1: #endif /* !NSPR_LOCK */
    1: 
    1: void
15994: js_Lock(JSContext *cx, JSThinLock *tl)
15994: {
15994:     ThinLock(tl, CX_THINLOCK_ID(cx));
15994: }
15994: 
15994: void
15994: js_Unlock(JSContext *cx, JSThinLock *tl)
15994: {
15994:     ThinUnlock(tl, CX_THINLOCK_ID(cx));
15994: }
15994: 
15994: void
    1: js_LockRuntime(JSRuntime *rt)
    1: {
    1:     PR_Lock(rt->rtLock);
    1: #ifdef DEBUG
    1:     rt->rtLockOwner = js_CurrentThreadId();
    1: #endif
    1: }
    1: 
    1: void
    1: js_UnlockRuntime(JSRuntime *rt)
    1: {
    1: #ifdef DEBUG
42712:     rt->rtLockOwner = NULL;
    1: #endif
    1:     PR_Unlock(rt->rtLock);
    1: }
    1: 
    1: void
11739: js_LockTitle(JSContext *cx, JSTitle *title)
    1: {
    1:     jsword me = CX_THINLOCK_ID(cx);
    1: 
    1:     JS_ASSERT(CURRENT_THREAD_IS_ME(me));
11739:     JS_ASSERT(title->ownercx != cx);
    1:     if (CX_THREAD_IS_RUNNING_GC(cx))
    1:         return;
11739:     if (title->ownercx && ClaimTitle(title, cx))
    1:         return;
    1: 
11739:     if (Thin_RemoveWait(ReadWord(title->lock.owner)) == me) {
11739:         JS_ASSERT(title->u.count > 0);
52503:         LOGIT(title, '+');
11739:         title->u.count++;
    1:     } else {
15994:         ThinLock(&title->lock, me);
11739:         JS_ASSERT(title->u.count == 0);
52503:         LOGIT(title, '1');
11739:         title->u.count = 1;
    1:     }
    1: }
    1: 
    1: void
11739: js_UnlockTitle(JSContext *cx, JSTitle *title)
    1: {
    1:     jsword me = CX_THINLOCK_ID(cx);
    1: 
    1:     /* We hope compilers use me instead of reloading cx->thread in the macro. */
    1:     if (CX_THREAD_IS_RUNNING_GC(cx))
    1:         return;
53548:     if (cx->thread->lockedSealedTitle == title) {
53548:         cx->thread->lockedSealedTitle = NULL;
    1:         return;
    1:     }
    1: 
    1:     /*
11739:      * If title->ownercx is not null, it's likely that two contexts not using
11739:      * requests nested locks for title.  The first context, cx here, claimed
11739:      * title; the second, title->ownercx here, re-claimed it because the first
    1:      * was not in a request, or was on the same thread.  We don't want to keep
    1:      * track of such nesting, because it penalizes the common non-nested case.
11739:      * Instead of asserting here and silently coping, we simply re-claim title
    1:      * for cx and return.
    1:      *
    1:      * See http://bugzilla.mozilla.org/show_bug.cgi?id=229200 for a real world
    1:      * case where an asymmetric thread model (Mozilla's main thread is known
    1:      * to be the only thread that runs the GC) combined with multiple contexts
    1:      * per thread has led to such request-less nesting.
    1:      */
11739:     if (title->ownercx) {
11739:         JS_ASSERT(title->u.count == 0);
11739:         JS_ASSERT(title->lock.owner == 0);
11739:         title->ownercx = cx;
    1:         return;
    1:     }
    1: 
11739:     JS_ASSERT(title->u.count > 0);
11739:     if (Thin_RemoveWait(ReadWord(title->lock.owner)) != me) {
    1:         JS_ASSERT(0);   /* unbalanced unlock */
    1:         return;
    1:     }
24876:     LOGIT(title, '-');
15994:     if (--title->u.count == 0)
15994:         ThinUnlock(&title->lock, me);
    1: }
    1: 
    1: void
52503: js_LockObj(JSContext *cx, JSObject *obj)
    1: {
52503:     JS_ASSERT(obj->isNative());
    1: 
    1:     /*
52503:      * We must test whether the GC is calling and return without mutating any
53548:      * state, especially lockedSealedScope. Note asymmetry with respect to
52504:      * js_UnlockObj, which is a thin-layer on top of js_UnlockTitle.
    1:      */
    1:     if (CX_THREAD_IS_RUNNING_GC(cx))
    1:         return;
    1: 
54563:     if (!obj->isExtensible() && !cx->thread->lockedSealedTitle) {
53548:         cx->thread->lockedSealedTitle = &obj->title;
    1:         return;
    1:     }
    1: 
52503:     js_LockTitle(cx, &obj->title);
    1: }
    1: 
    1: void
    1: js_UnlockObj(JSContext *cx, JSObject *obj)
    1: {
40430:     JS_ASSERT(obj->isNative());
52503:     js_UnlockTitle(cx, &obj->title);
11739: }
11739: 
11739: void
11739: js_InitTitle(JSContext *cx, JSTitle *title)
11739: {
11739: #ifdef JS_THREADSAFE
11739:     title->ownercx = cx;
42744:     js_InitLock(&title->lock);
11739: 
11739:     /*
11739:      * Set u.link = NULL, not u.count = 0, in case the target architecture's
11739:      * null pointer has a non-zero integer representation.
11739:      */
11739:     title->u.link = NULL;
11739: #endif
11739: }
11739: 
11739: void
11739: js_FinishTitle(JSContext *cx, JSTitle *title)
11739: {
24876: #ifdef DEBUG_SCOPE_COUNT
24876:     js_unlog_title(title);
24876: #endif
24876: 
11739: #ifdef JS_THREADSAFE
11739:     /* Title must be single-threaded at this point, so set ownercx. */
11739:     JS_ASSERT(title->u.count == 0);
11739:     title->ownercx = cx;
11739:     js_FinishLock(&title->lock);
11739: #endif
    1: }
    1: 
    1: #ifdef DEBUG
    1: 
    1: JSBool
    1: js_IsRuntimeLocked(JSRuntime *rt)
    1: {
    1:     return js_CurrentThreadId() == rt->rtLockOwner;
    1: }
    1: 
    1: JSBool
    1: js_IsObjLocked(JSContext *cx, JSObject *obj)
    1: {
52503:     return js_IsTitleLocked(cx, &obj->title);
    1: }
    1: 
    1: JSBool
11739: js_IsTitleLocked(JSContext *cx, JSTitle *title)
    1: {
11739:     /* Special case: the GC locking any object's title, see js_LockTitle. */
    1:     if (CX_THREAD_IS_RUNNING_GC(cx))
    1:         return JS_TRUE;
    1: 
54563:     /* Special case: locked object is not extensible -- see js_LockObj. */
53548:     if (cx->thread->lockedSealedTitle == title)
    1:         return JS_TRUE;
    1: 
    1:     /*
41800:      * General case: the title is either exclusively owned by some context, or
41800:      * it has a thin or fat lock to cope with shared (concurrent) ownership.
41800:      *
41800:      * js_LockTitle(cx, title) must set ownercx to cx when claiming the title
41800:      * from another context on the same thread.
    1:      */
41800:     if (title->ownercx)
41800:         return title->ownercx == cx;
    1:     return js_CurrentThreadId() ==
11739:            ((JSThread *)Thin_RemoveWait(ReadWord(title->lock.owner)))->id;
    1: }
    1: 
    1: #endif /* DEBUG */
    1: #endif /* JS_THREADSAFE */
