29805: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
29805: /* vim: set ts=2 sw=2 et tw=78: */
29805: /* ***** BEGIN LICENSE BLOCK *****
29805:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
29805:  *
29805:  * The contents of this file are subject to the Mozilla Public License Version
29805:  * 1.1 (the "License"); you may not use this file except in compliance with
29805:  * the License. You may obtain a copy of the License at
29805:  * http://www.mozilla.org/MPL/
29805:  *
29805:  * Software distributed under the License is distributed on an "AS IS" basis,
29805:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
29805:  * for the specific language governing rights and limitations under the
29805:  * License.
29805:  *
29805:  * The Original Code is Mozilla Communicator client code.
29805:  *
29805:  * The Initial Developer of the Original Code is
29805:  * Netscape Communications Corporation.
29805:  * Portions created by the Initial Developer are Copyright (C) 1998
29805:  * the Initial Developer. All Rights Reserved.
29805:  *
29805:  * Contributor(s):
29805:  *   Pierre Phaneuf <pp@ludusdesign.com>
29805:  *   Henri Sivonen <hsivonen@iki.fi>
29805:  *
29805:  * Alternatively, the contents of this file may be used under the terms of
29805:  * either of the GNU General Public License Version 2 or later (the "GPL"),
29805:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
29805:  * in which case the provisions of the GPL or the LGPL are applicable instead
29805:  * of those above. If you wish to allow use of your version of this file only
29805:  * under the terms of either the GPL or the LGPL, and not to allow others to
29805:  * use your version of this file under the terms of the MPL, indicate your
29805:  * decision by deleting the provisions above and replace them with the notice
29805:  * and other provisions required by the GPL or the LGPL. If you do not delete
29805:  * the provisions above, a recipient may use your version of this file under
29805:  * the terms of any one of the MPL, the GPL or the LGPL.
29805:  *
29805:  * ***** END LICENSE BLOCK ***** */
29805: 
29805: #include "nsContentErrors.h"
29805: #include "nsIPresShell.h"
29805: #include "nsEvent.h"
29805: #include "nsGUIEvent.h"
29805: #include "nsEventDispatcher.h"
29805: #include "nsContentUtils.h"
29805: #include "nsNodeUtils.h"
29805: 
43088: #define NS_HTML5_TREE_DEPTH_LIMIT 200
43088: 
40660: class nsPresContext;
40660: 
29805: // this really should be autogenerated...
29805: jArray<PRUnichar,PRInt32> nsHtml5TreeBuilder::ISINDEX_PROMPT = jArray<PRUnichar,PRInt32>();
38132: nsHtml5TreeBuilder::nsHtml5TreeBuilder(nsAHtml5TreeOpSink* aOpSink,
39737:                                        nsHtml5TreeOpStage* aStage)
32917:   : scriptingEnabled(PR_FALSE)
29805:   , fragment(PR_FALSE)
29805:   , contextNode(nsnull)
29805:   , formPointer(nsnull)
29805:   , headPointer(nsnull)
34979:   , mOpSink(aOpSink)
34978:   , mHandles(new nsIContent*[NS_HTML5_TREE_BUILDER_HANDLE_ARRAY_LENGTH])
34978:   , mHandlesUsed(0)
39737:   , mSpeculativeLoadStage(aStage)
35607:   , mCurrentHtmlScriptIsAsyncOrDefer(PR_FALSE)
29805: #ifdef DEBUG
29805:   , mActive(PR_FALSE)
29805: #endif
29805: {
29805:   MOZ_COUNT_CTOR(nsHtml5TreeBuilder);
29805: }
29805: 
29805: nsHtml5TreeBuilder::~nsHtml5TreeBuilder()
29805: {
29805:   MOZ_COUNT_DTOR(nsHtml5TreeBuilder);
29805:   NS_ASSERTION(!mActive, "nsHtml5TreeBuilder deleted without ever calling end() on it!");
29805:   mOpQueue.Clear();
29805: }
29805: 
34978: nsIContent**
29805: nsHtml5TreeBuilder::createElement(PRInt32 aNamespace, nsIAtom* aName, nsHtml5HtmlAttributes* aAttributes)
29805: {
34981:   NS_PRECONDITION(aAttributes, "Got null attributes.");
35295:   NS_PRECONDITION(aName, "Got null name.");
35295:   NS_PRECONDITION(aNamespace == kNameSpaceID_XHTML || 
35295:                   aNamespace == kNameSpaceID_SVG || 
35295:                   aNamespace == kNameSpaceID_MathML,
35295:                   "Bogus namespace.");
34981: 
35294:   nsIContent** content = AllocateContentHandle();
35294:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
35294:   treeOp->Init(aNamespace, aName, aAttributes, content);
35294:   
35294:   // Start wall of code for speculative loading and line numbers
34981:   
39737:   if (mSpeculativeLoadStage) {
34981:     switch (aNamespace) {
34981:       case kNameSpaceID_XHTML:
34981:         if (nsHtml5Atoms::img == aName) {
34981:           nsString* url = aAttributes->getValue(nsHtml5AttributeName::ATTR_SRC);
34981:           if (url) {
39737:             mSpeculativeLoadQueue.AppendElement()->InitImage(*url);
34981:           }
34981:         } else if (nsHtml5Atoms::script == aName) {
35294:           nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:           NS_ASSERTION(treeOp, "Tree op allocation failed.");
35606:           treeOp->Init(eTreeOpSetScriptLineNumberAndFreeze, content, tokenizer->getLineNumber());
35294: 
34981:           nsString* url = aAttributes->getValue(nsHtml5AttributeName::ATTR_SRC);
34981:           if (url) {
34981:             nsString* charset = aAttributes->getValue(nsHtml5AttributeName::ATTR_CHARSET);
34981:             nsString* type = aAttributes->getValue(nsHtml5AttributeName::ATTR_TYPE);
39737:             mSpeculativeLoadQueue.AppendElement()->InitScript(*url,
34981:                                                    (charset) ? *charset : EmptyString(),
39737:                                                    (type) ? *type : EmptyString());
35607:             mCurrentHtmlScriptIsAsyncOrDefer = 
35607:               aAttributes->contains(nsHtml5AttributeName::ATTR_ASYNC) ||
35607:               aAttributes->contains(nsHtml5AttributeName::ATTR_DEFER);
34981:           }
34981:         } else if (nsHtml5Atoms::link == aName) {
34981:           nsString* rel = aAttributes->getValue(nsHtml5AttributeName::ATTR_REL);
34981:           // Not splitting on space here is bogus but the old parser didn't even
34981:           // do a case-insensitive check.
34981:           if (rel && rel->LowerCaseEqualsASCII("stylesheet")) {
34981:             nsString* url = aAttributes->getValue(nsHtml5AttributeName::ATTR_HREF);
34981:             if (url) {
34981:               nsString* charset = aAttributes->getValue(nsHtml5AttributeName::ATTR_CHARSET);
39737:               mSpeculativeLoadQueue.AppendElement()->InitStyle(*url,
39737:                                                     (charset) ? *charset : EmptyString());
34981:             }
34981:           }
34981:         } else if (nsHtml5Atoms::video == aName) {
34981:           nsString* url = aAttributes->getValue(nsHtml5AttributeName::ATTR_POSTER);
34981:           if (url) {
39737:             mSpeculativeLoadQueue.AppendElement()->InitImage(*url);
34981:           }
35294:         } else if (nsHtml5Atoms::style == aName) {
35294:           nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:           NS_ASSERTION(treeOp, "Tree op allocation failed.");
35294:           treeOp->Init(eTreeOpSetStyleLineNumber, content, tokenizer->getLineNumber());
38132:         } else if (nsHtml5Atoms::html == aName) {
38132:           nsString* url = aAttributes->getValue(nsHtml5AttributeName::ATTR_MANIFEST);
38132:           if (url) {
39737:             mSpeculativeLoadQueue.AppendElement()->InitManifest(*url);
38132:           }
34981:         }
34981:         break;
34981:       case kNameSpaceID_SVG:
34981:         if (nsHtml5Atoms::image == aName) {
34981:           nsString* url = aAttributes->getValue(nsHtml5AttributeName::ATTR_XLINK_HREF);
34981:           if (url) {
39737:             mSpeculativeLoadQueue.AppendElement()->InitImage(*url);
34981:           }
34981:         } else if (nsHtml5Atoms::script == aName) {
35294:           nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:           NS_ASSERTION(treeOp, "Tree op allocation failed.");
35606:           treeOp->Init(eTreeOpSetScriptLineNumberAndFreeze, content, tokenizer->getLineNumber());
35294: 
34981:           nsString* url = aAttributes->getValue(nsHtml5AttributeName::ATTR_XLINK_HREF);
34981:           if (url) {
34981:             nsString* type = aAttributes->getValue(nsHtml5AttributeName::ATTR_TYPE);
39737:             mSpeculativeLoadQueue.AppendElement()->InitScript(*url,
34981:                                                    EmptyString(),
39737:                                                    (type) ? *type : EmptyString());
34981:           }
34981:         } else if (nsHtml5Atoms::style == aName) {
35294:           nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:           NS_ASSERTION(treeOp, "Tree op allocation failed.");
35294:           treeOp->Init(eTreeOpSetStyleLineNumber, content, tokenizer->getLineNumber());
35294: 
34981:           nsString* url = aAttributes->getValue(nsHtml5AttributeName::ATTR_XLINK_HREF);
34981:           if (url) {
39737:             mSpeculativeLoadQueue.AppendElement()->InitStyle(*url, EmptyString());
34981:           }
34981:         }        
34981:         break;
34981:     }
35294:   } else if (aNamespace != kNameSpaceID_MathML) {
35607:     // No speculative loader--just line numbers and defer/async check
35294:     if (nsHtml5Atoms::style == aName) {
35294:       nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:       NS_ASSERTION(treeOp, "Tree op allocation failed.");
35294:       treeOp->Init(eTreeOpSetStyleLineNumber, content, tokenizer->getLineNumber());
35294:     } else if (nsHtml5Atoms::script == aName) {
35294:       nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:       NS_ASSERTION(treeOp, "Tree op allocation failed.");
35606:       treeOp->Init(eTreeOpSetScriptLineNumberAndFreeze, content, tokenizer->getLineNumber());
35607:       if (aNamespace == kNameSpaceID_XHTML) {
35607:         mCurrentHtmlScriptIsAsyncOrDefer = 
35607:           aAttributes->contains(nsHtml5AttributeName::ATTR_SRC) &&
35607:           (aAttributes->contains(nsHtml5AttributeName::ATTR_ASYNC) ||
35607:            aAttributes->contains(nsHtml5AttributeName::ATTR_DEFER));
35607:       }
38132:     } else if (aNamespace == kNameSpaceID_XHTML && nsHtml5Atoms::html == aName) {
38132:       nsString* url = aAttributes->getValue(nsHtml5AttributeName::ATTR_MANIFEST);
38132:       if (url) {
38132:         nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
38132:         NS_ASSERTION(treeOp, "Tree op allocation failed.");
38132:         treeOp->Init(eTreeOpProcessOfflineManifest, *url);
38132:       }
35294:     }
34981:   }
34981: 
34981:   // End wall of code for speculative loading
34981:   
34978:   return content;
29805: }
29805: 
34978: nsIContent**
34978: nsHtml5TreeBuilder::createElement(PRInt32 aNamespace, nsIAtom* aName, nsHtml5HtmlAttributes* aAttributes, nsIContent** aFormElement)
29805: {
34978:   nsIContent** content = createElement(aNamespace, aName, aAttributes);
29805:   if (aFormElement) {
34978:     nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:     NS_ASSERTION(treeOp, "Tree op allocation failed.");
34978:     treeOp->Init(eTreeOpSetFormElement, content, aFormElement);
29805:   }
29805:   return content;
29805: }
29805: 
34978: nsIContent**
29805: nsHtml5TreeBuilder::createHtmlElementSetAsRoot(nsHtml5HtmlAttributes* aAttributes)
29805: {
34978:   nsIContent** content = createElement(kNameSpaceID_XHTML, nsHtml5Atoms::html, aAttributes);
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
29805:   treeOp->Init(eTreeOpAppendToDocument, content);
29805:   return content;
29805: }
29805: 
29805: void
34978: nsHtml5TreeBuilder::detachFromParent(nsIContent** aElement)
29805: {
35295:   NS_PRECONDITION(aElement, "Null element");
35295: 
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
29805:   treeOp->Init(eTreeOpDetach, aElement);
29805: }
29805: 
29805: void
34978: nsHtml5TreeBuilder::appendElement(nsIContent** aChild, nsIContent** aParent)
29805: {
35295:   NS_PRECONDITION(aChild, "Null child");
35295:   NS_PRECONDITION(aParent, "Null parent");
43088:   if (mDeepTreeSurrogateParent) {
43088:     return;
43088:   }
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
34979:   treeOp->Init(eTreeOpAppend, aChild, aParent);
29805: }
29805: 
29805: void
34978: nsHtml5TreeBuilder::appendChildrenToNewParent(nsIContent** aOldParent, nsIContent** aNewParent)
29805: {
35295:   NS_PRECONDITION(aOldParent, "Null old parent");
35295:   NS_PRECONDITION(aNewParent, "Null new parent");
35295: 
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
29805:   treeOp->Init(eTreeOpAppendChildrenToNewParent, aOldParent, aNewParent);
29805: }
29805: 
29805: void
34978: nsHtml5TreeBuilder::insertFosterParentedCharacters(PRUnichar* aBuffer, PRInt32 aStart, PRInt32 aLength, nsIContent** aTable, nsIContent** aStackParent)
29805: {
35295:   NS_PRECONDITION(aBuffer, "Null buffer");
35295:   NS_PRECONDITION(aTable, "Null table");
35295:   NS_PRECONDITION(aStackParent, "Null stack parent");
35295: 
34978:   PRUnichar* bufferCopy = new PRUnichar[aLength];
34978:   memcpy(bufferCopy, aBuffer, aLength * sizeof(PRUnichar));
34978:   
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
35600:   treeOp->Init(eTreeOpFosterParentText, bufferCopy, aLength, aStackParent, aTable);
29805: }
29805: 
29805: void
34978: nsHtml5TreeBuilder::insertFosterParentedChild(nsIContent** aChild, nsIContent** aTable, nsIContent** aStackParent)
29805: {
35295:   NS_PRECONDITION(aChild, "Null child");
35295:   NS_PRECONDITION(aTable, "Null table");
35295:   NS_PRECONDITION(aStackParent, "Null stack parent");
35295: 
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
29805:   treeOp->Init(eTreeOpFosterParent, aChild, aStackParent, aTable);
29805: }
29805: 
29805: void
34978: nsHtml5TreeBuilder::appendCharacters(nsIContent** aParent, PRUnichar* aBuffer, PRInt32 aStart, PRInt32 aLength)
29805: {
35295:   NS_PRECONDITION(aBuffer, "Null buffer");
35295:   NS_PRECONDITION(aParent, "Null parent");
35295: 
34978:   PRUnichar* bufferCopy = new PRUnichar[aLength];
34978:   memcpy(bufferCopy, aBuffer, aLength * sizeof(PRUnichar));
34978:   
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
43088:   treeOp->Init(eTreeOpAppendText, bufferCopy, aLength,
43088:       mDeepTreeSurrogateParent ? mDeepTreeSurrogateParent : aParent);
29805: }
29805: 
29805: void
34978: nsHtml5TreeBuilder::appendComment(nsIContent** aParent, PRUnichar* aBuffer, PRInt32 aStart, PRInt32 aLength)
29805: {
35295:   NS_PRECONDITION(aBuffer, "Null buffer");
35295:   NS_PRECONDITION(aParent, "Null parent");
43088:   if (mDeepTreeSurrogateParent) {
43088:     return;
43088:   }
35295: 
34978:   PRUnichar* bufferCopy = new PRUnichar[aLength];
34978:   memcpy(bufferCopy, aBuffer, aLength * sizeof(PRUnichar));
34978:   
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
35600:   treeOp->Init(eTreeOpAppendComment, bufferCopy, aLength, aParent);
29805: }
29805: 
29805: void
29805: nsHtml5TreeBuilder::appendCommentToDocument(PRUnichar* aBuffer, PRInt32 aStart, PRInt32 aLength)
29805: {
35295:   NS_PRECONDITION(aBuffer, "Null buffer");
35295: 
34978:   PRUnichar* bufferCopy = new PRUnichar[aLength];
34978:   memcpy(bufferCopy, aBuffer, aLength * sizeof(PRUnichar));
34978:   
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
35600:   treeOp->Init(eTreeOpAppendCommentToDocument, bufferCopy, aLength);
29805: }
29805: 
29805: void
34978: nsHtml5TreeBuilder::addAttributesToElement(nsIContent** aElement, nsHtml5HtmlAttributes* aAttributes)
29805: {
35295:   NS_PRECONDITION(aElement, "Null element");
35295:   NS_PRECONDITION(aAttributes, "Null attributes");
35295: 
34978:   if (aAttributes == nsHtml5HtmlAttributes::EMPTY_ATTRIBUTES) {
34978:     return;
34978:   }
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
34978:   treeOp->Init(aElement, aAttributes);
29805: }
29805: 
29805: void
35295: nsHtml5TreeBuilder::markMalformedIfScript(nsIContent** aElement)
29805: {
35295:   NS_PRECONDITION(aElement, "Null element");
35295: 
34978:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
35295:   treeOp->Init(eTreeOpMarkMalformedIfScript, aElement);
29805: }
29805: 
29805: void
29805: nsHtml5TreeBuilder::start(PRBool fragment)
29805: {
35607:   mCurrentHtmlScriptIsAsyncOrDefer = PR_FALSE;
43088:   mDeepTreeSurrogateParent = nsnull;
29805: #ifdef DEBUG
29805:   mActive = PR_TRUE;
29805: #endif
29805: }
29805: 
29805: void
29805: nsHtml5TreeBuilder::end()
29805: {
32027:   mOpQueue.Clear();
29805: #ifdef DEBUG
29805:   mActive = PR_FALSE;
29805: #endif
29805: }
29805: 
29805: void
29805: nsHtml5TreeBuilder::appendDoctypeToDocument(nsIAtom* aName, nsString* aPublicId, nsString* aSystemId)
29805: {
35295:   NS_PRECONDITION(aName, "Null name");
35295: 
29805:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
35600:   treeOp->Init(aName, *aPublicId, *aSystemId);
29805:   // nsXMLContentSink can flush here, but what's the point?
29805:   // It can also interrupt here, but we can't.
29805: }
29805: 
29805: void
34978: nsHtml5TreeBuilder::elementPushed(PRInt32 aNamespace, nsIAtom* aName, nsIContent** aElement)
29805: {
39513:   NS_ASSERTION(aNamespace == kNameSpaceID_XHTML || aNamespace == kNameSpaceID_SVG || aNamespace == kNameSpaceID_MathML, "Element isn't HTML, SVG or MathML!");
39513:   NS_ASSERTION(aName, "Element doesn't have local name!");
39513:   NS_ASSERTION(aElement, "No element!");
43088:   /*
43088:    * The frame constructor uses recursive algorithms, so it can't deal with
43088:    * arbitrarily deep trees. This is especially a problem on Windows where
43088:    * the permitted depth of the runtime stack is rather small.
43088:    *
43088:    * The following is a protection against author incompetence--not against
43088:    * malice. There are other ways to make the DOM deep anyway.
43088:    *
43088:    * The basic idea is that when the tree builder stack gets too deep,
43088:    * append operations no longer append to the node that the HTML parsing
43088:    * algorithm says they should but instead text nodes are append to the last
43088:    * element that was seen before a magic tree builder stack threshold was
43088:    * reached and element and comment nodes aren't appended to the DOM at all.
43088:    *
43088:    * However, for security reasons, non-child descendant text nodes inside an
43088:    * SVG script or style element should not become children. Also, non-cell
43088:    * table elements shouldn't be used as surrogate parents for user experience
43088:    * reasons.
43088:    */
43088:   if (!mDeepTreeSurrogateParent && currentPtr >= NS_HTML5_TREE_DEPTH_LIMIT &&
43088:       !(aName == nsHtml5Atoms::script ||
43088:         aName == nsHtml5Atoms::table ||
43088:         aName == nsHtml5Atoms::thead ||
43088:         aName == nsHtml5Atoms::tfoot ||
43088:         aName == nsHtml5Atoms::tbody ||
43088:         aName == nsHtml5Atoms::tr ||
43088:         aName == nsHtml5Atoms::colgroup ||
43088:         aName == nsHtml5Atoms::style)) {
43088:     mDeepTreeSurrogateParent = aElement;
43088:   }
39513:   if (aNamespace != kNameSpaceID_XHTML) {
39513:     return;
39513:   }
39513:   if (aName == nsHtml5Atoms::body || aName == nsHtml5Atoms::frameset) {
39513:     nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
39513:     NS_ASSERTION(treeOp, "Tree op allocation failed.");
39513:     treeOp->Init(eTreeOpStartLayout);
39513:     return;
39513:   }
29805: }
29805: 
29805: void
34978: nsHtml5TreeBuilder::elementPopped(PRInt32 aNamespace, nsIAtom* aName, nsIContent** aElement)
29805: {
29805:   NS_ASSERTION(aNamespace == kNameSpaceID_XHTML || aNamespace == kNameSpaceID_SVG || aNamespace == kNameSpaceID_MathML, "Element isn't HTML, SVG or MathML!");
29805:   NS_ASSERTION(aName, "Element doesn't have local name!");
29805:   NS_ASSERTION(aElement, "No element!");
43088:   if (mDeepTreeSurrogateParent && currentPtr <= NS_HTML5_TREE_DEPTH_LIMIT) {
43088:     mDeepTreeSurrogateParent = nsnull;
43088:   }
29805:   if (aNamespace == kNameSpaceID_MathML) {
29805:     return;
29805:   }
29805:   // we now have only SVG and HTML
29805:   if (aName == nsHtml5Atoms::script) {
35607:     if (mCurrentHtmlScriptIsAsyncOrDefer) {
35607:       NS_ASSERTION(aNamespace == kNameSpaceID_XHTML, 
35607:                    "Only HTML scripts may be async/defer.");
35607:       nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35607:       NS_ASSERTION(treeOp, "Tree op allocation failed.");
35607:       treeOp->Init(eTreeOpRunScriptAsyncDefer, aElement);      
35607:       mCurrentHtmlScriptIsAsyncOrDefer = PR_FALSE;
35607:       return;
35607:     }
29805:     requestSuspension();
34978:     nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:     NS_ASSERTION(treeOp, "Tree op allocation failed.");
34981:     treeOp->InitScript(aElement);
29805:     return;
29805:   }
29805:   if (aName == nsHtml5Atoms::title) {
29805:     nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:     NS_ASSERTION(treeOp, "Tree op allocation failed.");
29805:     treeOp->Init(eTreeOpDoneAddingChildren, aElement);
29805:     return;
29805:   }
29805:   if (aName == nsHtml5Atoms::style || (aNamespace == kNameSpaceID_XHTML && aName == nsHtml5Atoms::link)) {
29805:     nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:     NS_ASSERTION(treeOp, "Tree op allocation failed.");
29805:     treeOp->Init(eTreeOpUpdateStyleSheet, aElement);
29805:     return;
29805:   }
29805:   if (aNamespace == kNameSpaceID_SVG) {
29805: #if 0
29805:     if (aElement->HasAttr(kNameSpaceID_None, nsHtml5Atoms::onload)) {
29805:       nsEvent event(PR_TRUE, NS_SVG_LOAD);
29805:       event.eventStructType = NS_SVG_EVENT;
29805:       event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
29805:       // Do we care about forcing presshell creation if it hasn't happened yet?
29805:       // That is, should this code flush or something?  Does it really matter?
29805:       // For that matter, do we really want to try getting the prescontext?  Does
29805:       // this event ever want one?
29805:       nsRefPtr<nsPresContext> ctx;
29805:       nsCOMPtr<nsIPresShell> shell = parser->GetDocument()->GetPrimaryShell();
29805:       if (shell) {
29805:         ctx = shell->GetPresContext();
29805:       }
29805:       nsEventDispatcher::Dispatch(aElement, ctx, &event);
29805:     }
29805: #endif
34979:     // TODO soft flush the op queue every now and then
29805:     return;
29805:   }
29805:   // we now have only HTML
29805:   // Some HTML nodes need DoneAddingChildren() called to initialize
30334:   // properly (e.g. form state restoration).
29805:   // XXX expose ElementName group here and do switch
37890:   if (aName == nsHtml5Atoms::video ||
29805:       aName == nsHtml5Atoms::audio ||
29805:       aName == nsHtml5Atoms::object ||
29805:       aName == nsHtml5Atoms::applet) {
29805:     nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:     NS_ASSERTION(treeOp, "Tree op allocation failed.");
29805:     treeOp->Init(eTreeOpDoneAddingChildren, aElement);
29805:     return;
29805:   }
37890:   if (aName == nsHtml5Atoms::select || 
37890:       aName == nsHtml5Atoms::textarea) {
37890:     if (!formPointer) {
37890:       // If form inputs don't belong to a form, their state preservation
37890:       // won't work right without an append notification flush at this 
37890:       // point. See bug 497861 and bug 539895.
37890:       nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
37890:       NS_ASSERTION(treeOp, "Tree op allocation failed.");
37890:       treeOp->Init(eTreeOpFlushPendingAppendNotifications);
37890:     }
37890:     nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
37890:     NS_ASSERTION(treeOp, "Tree op allocation failed.");
37890:     treeOp->Init(eTreeOpDoneAddingChildren, aElement);
37890:     return;
37890:   }
29805:   if (aName == nsHtml5Atoms::input ||
29805:       aName == nsHtml5Atoms::button) {
35590:     if (!formPointer) {
35590:       // If form inputs don't belong to a form, their state preservation
35590:       // won't work right without an append notification flush at this 
35590:       // point. See bug 497861.
35590:       nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35590:       NS_ASSERTION(treeOp, "Tree op allocation failed.");
35590:       treeOp->Init(eTreeOpFlushPendingAppendNotifications);
35590:     }
29805:     nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:     NS_ASSERTION(treeOp, "Tree op allocation failed.");
29805:     treeOp->Init(eTreeOpDoneCreatingElement, aElement);
29805:     return;
29805:   }
29805:   if (aName == nsHtml5Atoms::meta) {
29805:     nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:     NS_ASSERTION(treeOp, "Tree op allocation failed.");
29805:     treeOp->Init(eTreeOpProcessMeta, aElement);
29805:     return;
29805:   }
29805:   return;
29805: }
29805: 
29805: void
39515: nsHtml5TreeBuilder::accumulateCharacters(const PRUnichar* aBuf, PRInt32 aStart, PRInt32 aLength)
29805: {
39999:   PRInt32 newFillLen = charBufferLen + aLength;
39999:   if (newFillLen > charBuffer.length) {
39999:     PRInt32 newAllocLength = newFillLen + (newFillLen >> 1);
39999:     jArray<PRUnichar,PRInt32> newBuf(newAllocLength);
39999:     memcpy(newBuf, charBuffer, sizeof(PRUnichar) * charBufferLen);
39999:     charBuffer.release();
39999:     charBuffer = newBuf;
39999:   }
29805:   memcpy(charBuffer + charBufferLen, aBuf + aStart, sizeof(PRUnichar) * aLength);
39999:   charBufferLen = newFillLen;
29805: }
29805: 
34978: nsIContent**
34978: nsHtml5TreeBuilder::AllocateContentHandle()
29805: {
34978:   if (mHandlesUsed == NS_HTML5_TREE_BUILDER_HANDLE_ARRAY_LENGTH) {
34978:     mOldHandles.AppendElement(mHandles.forget());
34978:     mHandles = new nsIContent*[NS_HTML5_TREE_BUILDER_HANDLE_ARRAY_LENGTH];
34978:     mHandlesUsed = 0;
29805:   }
35295: #ifdef DEBUG
35295:   mHandles[mHandlesUsed] = (nsIContent*)0xC0DEDBAD;
35295: #endif
34978:   return &mHandles[mHandlesUsed++];
29805: }
29805: 
34978: PRBool
34978: nsHtml5TreeBuilder::HasScript()
29805: {
34978:   PRUint32 len = mOpQueue.Length();
34978:   if (!len) {
34978:     return PR_FALSE;
29805:   }
34978:   return mOpQueue.ElementAt(len - 1).IsRunScript();
29805: }
29805: 
35600: PRBool
34979: nsHtml5TreeBuilder::Flush()
34979: {
40983:   flushCharacters();
39737:   FlushLoads();
35600:   PRBool hasOps = !mOpQueue.IsEmpty();
35600:   if (hasOps) {
35600:     mOpSink->MoveOpsFrom(mOpQueue);
34979:   }
35600:   return hasOps;
34979: }
34979: 
34979: void
39737: nsHtml5TreeBuilder::FlushLoads()
39737: {
39737:   if (!mSpeculativeLoadQueue.IsEmpty()) {
39737:     mSpeculativeLoadStage->MoveSpeculativeLoadsFrom(mSpeculativeLoadQueue);
39737:   }
39737: }
39737: 
39737: void
39511: nsHtml5TreeBuilder::SetDocumentCharset(nsACString& aCharset, 
39511:                                        PRInt32 aCharsetSource)
34979: {
34979:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
39511:   treeOp->Init(eTreeOpSetDocumentCharset, aCharset, aCharsetSource);  
34979: }
34979: 
34979: void
34979: nsHtml5TreeBuilder::StreamEnded()
34979: {
34981:   // The fragment mode calls DidBuildModel from nsHtml5Parser. 
34979:   // Letting DidBuildModel be called from the executor in the fragment case
34979:   // confuses the EndLoad logic of nsHTMLDocument, since nsHTMLDocument
34979:   // thinks it is dealing with document.written content as opposed to 
34979:   // innerHTML content.
34979:   if (!fragment) {
34979:     nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:     NS_ASSERTION(treeOp, "Tree op allocation failed.");
34979:     treeOp->Init(eTreeOpStreamEnded);
34979:   }
34979: }
34979: 
34979: void
34979: nsHtml5TreeBuilder::NeedsCharsetSwitchTo(const nsACString& aCharset)
34979: {
34979:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
34979:   treeOp->Init(eTreeOpNeedsCharsetSwitchTo, aCharset);  
34979: }
34979: 
34979: void
35294: nsHtml5TreeBuilder::AddSnapshotToScript(nsAHtml5TreeBuilderState* aSnapshot, PRInt32 aLine)
34979: {
34979:   NS_PRECONDITION(HasScript(), "No script to add a snapshot to!");
34981:   NS_PRECONDITION(aSnapshot, "Got null snapshot.");
35294:   mOpQueue.ElementAt(mOpQueue.Length() - 1).SetSnapshot(aSnapshot, aLine);
34979: }
34979: 
35600: PRBool 
35600: nsHtml5TreeBuilder::IsDiscretionaryFlushSafe()
35600: {
35600:   return !(charBufferLen && 
35600:            currentPtr >= 0 && 
35600:            stack[currentPtr]->fosterParenting);
35600: }
35600: 
32917: // DocumentModeHandler
32917: void
32917: nsHtml5TreeBuilder::documentMode(nsHtml5DocumentMode m)
32917: {
32917:   nsHtml5TreeOperation* treeOp = mOpQueue.AppendElement();
35295:   NS_ASSERTION(treeOp, "Tree op allocation failed.");
32917:   treeOp->Init(m);
32917: }
