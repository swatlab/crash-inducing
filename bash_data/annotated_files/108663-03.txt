     1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * Header for JavaScript Debugging support - All public functions
     1:  */
     1: 
     1: #ifndef jsdebug_h___
     1: #define jsdebug_h___
     1: 
     1: /* Get jstypes.h included first. After that we can use PR macros for doing
     1: *  this extern "C" stuff!
     1: */
     1: #ifdef __cplusplus
     1: extern "C"
     1: {
     1: #endif
     1: #include "jstypes.h"
     1: #ifdef __cplusplus
     1: }
     1: #endif
     1: 
     1: #include "jsapi.h"
     1: #include "jsdbgapi.h"
     1: #ifdef LIVEWIRE
     1: #include "lwdbgapi.h"
     1: #endif
     1: 
     1: JS_BEGIN_EXTERN_C
     1: 
     1: /*
     1:  * The linkage of JSD API functions differs depending on whether the file is
     1:  * used within the JSD library or not.  Any source file within the JSD
     1:  * libraray should define EXPORT_JSD_API whereas any client of the library
     1:  * should not.
     1:  */
     1: #ifdef EXPORT_JSD_API
     1: #define JSD_PUBLIC_API(t)    JS_EXPORT_API(t)
     1: #define JSD_PUBLIC_DATA(t)   JS_EXPORT_DATA(t)
     1: #else
     1: #define JSD_PUBLIC_API(t)    JS_IMPORT_API(t)
     1: #define JSD_PUBLIC_DATA(t)   JS_IMPORT_DATA(t)
     1: #endif
     1: 
     1: #define JSD_FRIEND_API(t)    JSD_PUBLIC_API(t)
     1: #define JSD_FRIEND_DATA(t)   JSD_PUBLIC_DATA(t)
     1: 
     1: /***************************************************************************/
     1: /* Opaque typedefs for handles */
     1: 
     1: typedef struct JSDContext        JSDContext;
     1: typedef struct JSDScript         JSDScript;
     1: typedef struct JSDSourceText     JSDSourceText;
     1: typedef struct JSDThreadState    JSDThreadState;
     1: typedef struct JSDStackFrameInfo JSDStackFrameInfo;
     1: typedef struct JSDValue          JSDValue;
     1: typedef struct JSDProperty       JSDProperty;
     1: typedef struct JSDObject         JSDObject;
     1: 
     1: /***************************************************************************/
     1: /* High Level calls */
     1: 
     1: /*
     1: * callback stuff for calls in EXE to be accessed by this code
     1: * when it lives in an explicitly loaded DLL
     1: */
     1: 
     1: /*
     1: * This callback allows JSD to inform the embedding when JSD has been
     1: * turned on or off. This is especially useful in the Java-based debugging
     1: * system used in mozilla because the debugger applet controls starting
     1: * up the JSD system.
     1: */
     1: typedef void
 18907: (* JSD_SetContextProc)(JSDContext* jsdc, void* user);
     1: 
     1: /* This struct could have more fields in future versions */
     1: typedef struct
     1: {
 91237:     unsigned              size;       /* size of this struct (init before use)*/
     1:     JSD_SetContextProc setContext;
     1: } JSD_UserCallbacks;
     1: 
     1: /*
     1: * Used by an embedding to tell JSD what JSRuntime to use and to set
     1: * callbacks without starting up JSD. This assumes only one JSRuntime
     1: * will be used. This exists to support the mozilla Java-based debugger
     1: * system.
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_SetUserCallbacks(JSRuntime*         jsrt,
     1:                      JSD_UserCallbacks* callbacks,
     1:                      void*              user);
     1: 
     1: /*
     1: * Startup JSD.
     1: * This version of the init function requires that JSD_SetUserCallbacks()
     1: * has been previously called (with a non-NULL callback struct pointer)
     1: */
     1: extern JSD_PUBLIC_API(JSDContext*)
     1: JSD_DebuggerOn(void);
     1: 
     1: /*
     1: * Startup JSD on a particular JSRuntime with (optional) callbacks
     1: */
     1: extern JSD_PUBLIC_API(JSDContext*)
     1: JSD_DebuggerOnForUser(JSRuntime*         jsrt,
     1:                       JSD_UserCallbacks* callbacks,
     1:                       void*              user);
     1: 
     1: /*
 54154:  * Startup JSD in an application that uses compartments. Debugger
 54154:  * objects will be allocated in the same compartment as scopeobj.
 54154:  */
 54154: extern JSD_PUBLIC_API(JSDContext*)
 54154: JSD_DebuggerOnForUserWithCompartment(JSRuntime*         jsrt,
 54154:                                      JSD_UserCallbacks* callbacks,
 54154:                                      void*              user,
 54154:                                      JSObject*          scopeobj);
 54154: 
 54154: /*
     1: * Shutdown JSD for this JSDContext
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_DebuggerOff(JSDContext* jsdc);
     1: 
     1: /*
 35647:  * Pause JSD for this JSDContext
 35647:  */
 35647: extern JSD_PUBLIC_API(void)
 35647: JSD_DebuggerPause(JSDContext* jsdc);
 35647: 
 35647: /*
 35647:  * Unpause JSD for this JSDContext
 35647:  */
 35647: extern JSD_PUBLIC_API(void)
 35647: JSD_DebuggerUnpause(JSDContext* jsdc);
 35647: 
 35647: /*
     1: * Get the Major Version (initial JSD release used major version = 1)
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetMajorVersion(void);
     1: 
     1: /*
     1: * Get the Minor Version (initial JSD release used minor version = 0)
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetMinorVersion(void);
     1: 
     1: /*
     1: * Returns a 'dumb' JSContext that can be used for utility purposes as needed
     1: */
     1: extern JSD_PUBLIC_API(JSContext*)
     1: JSD_GetDefaultJSContext(JSDContext* jsdc);
     1: 
     1: /*
 94960: * Returns a JSRuntime this context is associated with
 94960: */
 94960: extern JSD_PUBLIC_API(JSRuntime*)
 94960: JSD_GetJSRuntime(JSDContext* jsdc);
 94960: 
 94960: /*
     1: * Set the private data for this context, returns previous value
     1: */
     1: extern JSD_PUBLIC_API(void *)
     1: JSD_SetContextPrivate(JSDContext *jsdc, void *data);
     1: 
     1: /*
     1: * Get the private data for this context
     1: */
     1: extern JSD_PUBLIC_API(void *)
     1: JSD_GetContextPrivate(JSDContext *jsdc);
     1: 
     1: /*
     1: * Clear profile data for all scripts
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_ClearAllProfileData(JSDContext* jsdc);
     1: 
     1: /*
     1: * Context flags.
     1: */
     1: 
     1: /* Include native frames in JSDThreadStates. */
     1: #define JSD_INCLUDE_NATIVE_FRAMES 0x01
     1: /*
     1: * Normally, if a script has a 0 in JSD_SCRIPT_PROFILE_BIT it is included in
     1: * profile data, otherwise it is not profiled.  Setting the JSD_PROFILE_WHEN_SET
     1: * flag reverses this convention.
     1: */
     1: #define JSD_PROFILE_WHEN_SET      0x02
     1: /*
     1: * Normally, when the script in the top frame of a thread state has a 1 in
     1: * JSD_SCRIPT_DEBUG_BIT, the execution hook is ignored.  Setting the
     1: * JSD_DEBUG_WHEN_SET flag reverses this convention.
     1: */
     1: #define JSD_DEBUG_WHEN_SET        0x04
     1: /*
     1: * When this flag is set the internal call hook will collect profile data.
     1: */
     1: #define JSD_COLLECT_PROFILE_DATA  0x08
     1: /*
     1: * When this flag is set, stack frames that are disabled for debugging
     1: * will not appear in the call stack chain.
     1: */
     1: #define JSD_HIDE_DISABLED_FRAMES  0x10
     1: /*
     1: * When this flag is set, the debugger will only check the
     1: * JSD_SCRIPT_DEBUG_BIT on the top (most recent) stack frame.  This
     1: * makes it possible to stop in an enabled frame which was called from
     1: * a stack that contains a disabled frame.
     1: *
     1: * When this flag is *not* set, any stack that contains a disabled frame
     1: * will not be debugged (the execution hook will not be invoked.)
     1: *
     1: * This only applies when the reason for calling the hook would have
     1: * been JSD_HOOK_INTERRUPTED or JSD_HOOK_THROW.  JSD_HOOK_BREAKPOINT,
     1: * JSD_HOOK_DEBUG_REQUESTED, and JSD_HOOK_DEBUGGER_KEYWORD always stop,
     1: * regardless of this setting, as long as the top frame is not disabled.
     1: *
     1: * If JSD_HIDE_DISABLED_FRAMES is set, this is effectively set as well.
     1: */
     1: #define JSD_MASK_TOP_FRAME_ONLY   0x20
 48556: 
     1: /*
 48556: * 0x40 was formerly used to hook into object creation.
     1: */
 48556: #define JSD_DISABLE_OBJECT_TRACE_RETIRED 0x40
 48556: 
     1: 
     1: extern JSD_PUBLIC_API(void)
 84755: JSD_SetContextFlags (JSDContext* jsdc, uint32_t flags);
     1: 
 84755: extern JSD_PUBLIC_API(uint32_t)
     1: JSD_GetContextFlags (JSDContext* jsdc);     
     1: 
     1: /*
     1: * Notify JSD that this JSContext is 'in use'. This allows JSD to hook the
     1: * ErrorReporter. For the most part this is done automatically whenever
     1: * events like script loading happen. But, it is a good idea to call this
     1: * from the embedding when new contexts come into use.
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_JSContextInUse(JSDContext* jsdc, JSContext* context);
     1: 
     1: /*
     1: * Find the JSDContext (if any) associated with the JSRuntime of a
     1: * given JSContext.
     1: */
     1: extern JSD_PUBLIC_API(JSDContext*)
     1: JSD_JSDContextForJSContext(JSContext* context);
     1: 
     1: /***************************************************************************/
     1: /* Script functions */
     1: 
     1: /*
     1: * Lock the entire script subsystem. This grabs a highlevel lock that
     1: * protects the JSD internal information about scripts. It is important
     1: * to wrap script related calls in this lock in multithreaded situations
     1: * -- i.e. where the debugger is running on a different thread than the
     1: * interpreter -- or when multiple debugger threads may be accessing this
     1: * subsystem. It is safe (and best) to use this locking even if the
     1: * environment might not be multi-threaded. Safely nestable.
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_LockScriptSubsystem(JSDContext* jsdc);
     1: 
     1: /*
     1: * Unlock the entire script subsystem -- see JSD_LockScriptSubsystem
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_UnlockScriptSubsystem(JSDContext* jsdc);
     1: 
     1: /*
     1: * Iterate through all the active scripts for this JSDContext.
     1: * NOTE: must initialize iterp to NULL to start iteration.
     1: * NOTE: must lock and unlock the subsystem
     1: * example:
     1: *
     1: *  JSDScript jsdscript;
     1: *  JSDScript iter = NULL;
     1: *
     1: *  JSD_LockScriptSubsystem(jsdc);
     1: *  while((jsdscript = JSD_IterateScripts(jsdc, &iter)) != NULL) {
     1: *     *** use jsdscript here ***
     1: *  }
     1: *  JSD_UnlockScriptSubsystem(jsdc);
     1: */
     1: extern JSD_PUBLIC_API(JSDScript*)
     1: JSD_IterateScripts(JSDContext* jsdc, JSDScript **iterp);
     1: 
     1: /*
     1: * Get the number of times this script has been called.
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetScriptCallCount(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Get the max number of times this script called itself, directly or indirectly.
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetScriptMaxRecurseDepth(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Get the shortest execution time recorded.
     1: */
 90955: extern JSD_PUBLIC_API(double)
     1: JSD_GetScriptMinExecutionTime(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Get the longest execution time recorded.
     1: */
 90955: extern JSD_PUBLIC_API(double)
     1: JSD_GetScriptMaxExecutionTime(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Get the total amount of time spent in this script.
     1: */
 90955: extern JSD_PUBLIC_API(double)
     1: JSD_GetScriptTotalExecutionTime(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Get the shortest execution time recorded, excluding time spent in called
     1: * functions.
     1: */
 90955: extern JSD_PUBLIC_API(double)
     1: JSD_GetScriptMinOwnExecutionTime(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Get the longest execution time recorded, excluding time spent in called
     1: * functions.
     1: */
 90955: extern JSD_PUBLIC_API(double)
     1: JSD_GetScriptMaxOwnExecutionTime(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Get the total amount of time spent in this script, excluding time spent
     1: * in called functions.
     1: */
 90955: extern JSD_PUBLIC_API(double)
     1: JSD_GetScriptTotalOwnExecutionTime(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Clear profile data for this script.
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_ClearScriptProfileData(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Get the JSScript for a JSDScript
     1: */
     1: extern JSD_PUBLIC_API(JSScript*)
     1: JSD_GetJSScript(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Get the JSFunction for a JSDScript
     1: */
     1: extern JSD_PUBLIC_API(JSFunction*)
     1: JSD_GetJSFunction(JSDContext* jsdc, JSDScript *script);
     1: 
     1: /*
     1: * Determines whether or not to collect profile information for this
     1: * script.  The context flag JSD_PROFILE_WHEN_SET decides the logic.
     1: */
     1: #define JSD_SCRIPT_PROFILE_BIT 0x01
     1: /*
     1: * Determines whether or not to ignore breakpoints, etc. in this script.
     1: * The context flag JSD_DEBUG_WHEN_SET decides the logic.
     1: */
     1: #define JSD_SCRIPT_DEBUG_BIT   0x02
108663: /*
108663:  * Determines whether to invoke the onScriptDestroy callback for this
108663:  * script. The default is for this to be true if the onScriptCreated
108663:  * callback was invoked for this script.
108663:  */
108663: #define JSD_SCRIPT_CALL_DESTROY_HOOK_BIT 0x04
     1: 
 84755: extern JSD_PUBLIC_API(uint32_t)
     1: JSD_GetScriptFlags(JSDContext *jsdc, JSDScript* jsdscript);
     1: 
     1: extern JSD_PUBLIC_API(void)
 84755: JSD_SetScriptFlags(JSDContext *jsdc, JSDScript* jsdscript, uint32_t flags);
     1: 
     1: /*
     1: * Set the private data for this script, returns previous value
     1: */
     1: extern JSD_PUBLIC_API(void *)
     1: JSD_SetScriptPrivate(JSDScript* jsdscript, void *data);
     1: 
     1: /*
     1: * Get the private data for this script
     1: */
     1: extern JSD_PUBLIC_API(void *)
     1: JSD_GetScriptPrivate(JSDScript* jsdscript);
     1: 
     1: /*
     1: * Determine if this script is still loaded in the interpreter
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsActiveScript(JSDContext* jsdc, JSDScript *jsdscript);
     1: 
     1: /*
     1: * Get the filename associated with this script
     1: */
     1: extern JSD_PUBLIC_API(const char*)
     1: JSD_GetScriptFilename(JSDContext* jsdc, JSDScript *jsdscript);
     1: 
     1: /*
 58976: * Get the function name associated with this script (NULL if not a function).
 61691: * If the function does not have a name the result is the string "anonymous".
 61691: * *** new for gecko 2.0 ****
     1: */
 58976: extern JSD_PUBLIC_API(JSString *)
 61691: JSD_GetScriptFunctionId(JSDContext* jsdc, JSDScript *jsdscript);
     1: 
     1: /*
     1: * Get the base linenumber of the sourcefile from which this script was loaded.
     1: * This is one-based -- i.e. the first line of a file is line '1'. This may
     1: * return 0 if this infomation is unknown.
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetScriptBaseLineNumber(JSDContext* jsdc, JSDScript *jsdscript);
     1: 
     1: /*
     1: * Get the count of source lines associated with this script (1 or greater)
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetScriptLineExtent(JSDContext* jsdc, JSDScript *jsdscript);
     1: 
     1: /*
     1: * Declaration of callback for notification of script creation and destruction.
     1: * 'creating' is JS_TRUE if creating new script, JS_FALSE if destroying existing
     1: * script (callback called just before actual destruction).
     1: * 'callerdata' is what was passed to JSD_SetScriptHook to set the hook.
     1: */
     1: typedef void
 18907: (* JSD_ScriptHookProc)(JSDContext* jsdc,
     1:                        JSDScript*  jsdscript,
     1:                        JSBool      creating,
     1:                        void*       callerdata);
     1: 
     1: /*
     1: * Set a hook to be called when scripts are created or destroyed (loaded or
     1: * unloaded).
     1: * 'callerdata' can be whatever you want it to be.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_SetScriptHook(JSDContext* jsdc, JSD_ScriptHookProc hook, void* callerdata);
     1: 
     1: /*
     1: * Get the current script hook.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_GetScriptHook(JSDContext* jsdc, JSD_ScriptHookProc* hook, void** callerdata);
     1: 
     1: /*
     1: * Get a 'Program Counter' value for a given line. This represents the location
     1: * of the first bit of executable code for this line of source. This 'pc' should 
     1: * be considered an opaque handle.
     1: * 0 is returned for invalid scripts, or lines that lie outside the script.
     1: * If no code is on the given line, then the returned pc represents the first
     1: * code within the script (if any) after the given line.
     1: * This function can be used to set breakpoints -- see JSD_SetExecutionHook
     1: */
 86976: extern JSD_PUBLIC_API(uintptr_t)
 91237: JSD_GetClosestPC(JSDContext* jsdc, JSDScript* jsdscript, unsigned line);
     1: 
     1: /*
     1: * Get the source line number for a given 'Program Counter' location.
     1: * Returns 0 if no source line information is appropriate (or available) for
     1: * the given pc.
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
 86976: JSD_GetClosestLine(JSDContext* jsdc, JSDScript* jsdscript, uintptr_t pc);
     1: 
 71318: /*
 71318:  * Get a list of lines and the corresponding earliest PC for each (see
 71318:  * JSD_GetClosestPC). Lines with no PCs associated will not be returned. NULL
 71318:  * may be passed for either lines or pcs to avoid filling anything in for that
 71318:  * argument.
 71318:  */
 71318: extern JSD_PUBLIC_API(JSBool)
 71318: JSD_GetLinePCs(JSDContext* jsdc, JSDScript* jsdscript,
 91237:                unsigned startLine, unsigned maxLines,
 91237:                unsigned* count, unsigned** lines, uintptr_t** pcs);
 71318: 
     1: /* these are only used in cases where scripts are created outside of JS*/
     1: 
     1: /*
     1: * Direct call to notify JSD that a script has been created.
     1: * Embeddings that use the normal jsapi script functions need not call this.
     1: * Any embedding that follows the (discouraged!) practice of contructing script
     1: * structures manually should call this function to inform JSD. (older ssjs
     1: * systems do this).
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_ScriptCreated(JSDContext* jsdc,
     1:                   JSContext   *cx,
     1:                   const char  *filename,    /* URL this script loads from */
 91237:                   unsigned       lineno,       /* line where this script starts */
     1:                   JSScript    *script,
     1:                   JSFunction  *fun);
     1: 
     1: /*
     1: * see JSD_ScriptCreated
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_ScriptDestroyed(JSDContext* jsdc,
 97529:                     JSFreeOp    *fop,
     1:                     JSScript    *script);
     1: 
     1: /***************************************************************************/
     1: /* Source Text functions */
     1: 
     1: /*
     1: * In some embeddings (e.g. mozilla) JavaScript source code from a 'file' may be
     1: * execute before the entire 'file' has even been loaded. This system supports
     1: * access to such incrmentally loaded source. It also allows for the possibility
     1: * that source loading may fail or be aborted (though the source that did load
     1: * may still be usable). Remember that this source is the entire 'file'
     1: * contents and that the JavaScript code may only be part of that source.
     1: *
     1: * For any given URL there can only be one source text item (the most recently
     1: * loaded).
     1: */
     1: 
     1: /* these coorespond to netscape.jsdebug.SourceTextItem.java values -
     1: *  change in both places if anywhere
     1: */
     1: 
     1: typedef enum
     1: {
     1:     JSD_SOURCE_INITED       = 0, /* initialized, but contains no source yet */
     1:     JSD_SOURCE_PARTIAL      = 1, /* some source loaded, more expected */
     1:     JSD_SOURCE_COMPLETED    = 2, /* all source finished loading */
     1:     JSD_SOURCE_ABORTED      = 3, /* user aborted loading, some may be loaded */
     1:     JSD_SOURCE_FAILED       = 4, /* loading failed, some may be loaded */
     1:     JSD_SOURCE_CLEARED      = 5  /* text has been cleared by debugger */
     1: } JSDSourceStatus;
     1: 
     1: /*
     1: * Lock the entire source text subsystem. This grabs a highlevel lock that
     1: * protects the JSD internal information about sources. It is important to
     1: * wrap source text related calls in this lock in multithreaded situations
     1: * -- i.e. where the debugger is running on a different thread than the
     1: * interpreter (or the loader of sources) -- or when multiple debugger
     1: * threads may be accessing this subsystem. It is safe (and best) to use
     1: * this locking even if the environment might not be multi-threaded.
     1: * Safely Nestable.
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_LockSourceTextSubsystem(JSDContext* jsdc);
     1: 
     1: /*
     1: * Unlock the entire source text subsystem. see JSD_LockSourceTextSubsystem.
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_UnlockSourceTextSubsystem(JSDContext* jsdc);
     1: 
     1: /*
     1: * Iterate the source test items. Use the same pattern of calls shown in
     1: * the example for JSD_IterateScripts - NOTE that the SourceTextSubsystem.
     1: * must be locked before and unlocked after iterating.
     1: */
     1: extern JSD_PUBLIC_API(JSDSourceText*)
     1: JSD_IterateSources(JSDContext* jsdc, JSDSourceText **iterp);
     1: 
     1: /*
     1: * Find the source text item for the given URL (or filename - or whatever
     1: * string the given embedding uses to describe source locations).
     1: * Returns NULL is not found.
     1: */
     1: extern JSD_PUBLIC_API(JSDSourceText*)
     1: JSD_FindSourceForURL(JSDContext* jsdc, const char* url);
     1: 
     1: /*
     1: * Get the URL string associated with the given source text item
     1: */
     1: extern JSD_PUBLIC_API(const char*)
     1: JSD_GetSourceURL(JSDContext* jsdc, JSDSourceText* jsdsrc);
     1: 
     1: /*
     1: * Get the actual source text. This gives access to the actual storage of
     1: * the source - it sHould *not* be written to.
     1: * The buffer is NOT zero terminated (nor is it guaranteed to have space to
     1: * hold a zero terminating char).
     1: * XXX this is 8-bit character data. Unicode source is not yet supported.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_GetSourceText(JSDContext* jsdc, JSDSourceText* jsdsrc,
 91237:                   const char** ppBuf, int* pLen);
     1: 
     1: /*
     1: * Clear the text -- delete the text and set the status to JSD_SOURCE_CLEARED.
     1: * This is useful if source is done loading and the debugger wishes to store
     1: * the text data itself (e.g. in a Java String). This allows avoidance of
     1: * storing the same text in multiple places.
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_ClearSourceText(JSDContext* jsdc, JSDSourceText* jsdsrc);
     1: 
     1: /*
     1: * Return the status of the source text item. see JSDSourceStatus enum.
     1: */
     1: extern JSD_PUBLIC_API(JSDSourceStatus)
     1: JSD_GetSourceStatus(JSDContext* jsdc, JSDSourceText* jsdsrc);
     1: 
     1: /*
     1: * Has the source been altered since the last call to JSD_SetSourceDirty?
     1: * Use of JSD_IsSourceDirty and JSD_SetSourceDirty is still supported, but
     1: * discouraged in favor of the JSD_GetSourceAlterCount system. This dirty
     1: * scheme ASSUMES that there is only one consumer of the data.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsSourceDirty(JSDContext* jsdc, JSDSourceText* jsdsrc);
     1: 
     1: /*
     1: * Clear the dirty flag
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_SetSourceDirty(JSDContext* jsdc, JSDSourceText* jsdsrc, JSBool dirty);
     1: 
     1: /*
     1: * Each time a source text item is altered this value is incremented. Any
     1: * consumer can store this value when they retieve other data about the
     1: * source text item and then check later to see if the current value is
     1: * different from their stored value. Thus they can know if they have stale
     1: * data or not. NOTE: this value is not gauranteed to start at any given number.
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetSourceAlterCount(JSDContext* jsdc, JSDSourceText* jsdsrc);
     1: 
     1: /*
     1: * Force an increment in the alter count for a source text item. This is
     1: * normally automatic when the item changes, but a give consumer may want to
     1: * force this to amke an item appear to have changed even if it has not.
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_IncrementSourceAlterCount(JSDContext* jsdc, JSDSourceText* jsdsrc);
     1: 
     1: /*
     1: * Destroy *all* the source text items
     1: * (new for server-side USE WITH CARE)
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_DestroyAllSources( JSDContext* jsdc );
     1: 
     1: /* functions for adding source items */
     1: 
     1: /*
     1: * Add a new item for a given URL. If an iten already exists for the given URL
     1: * then the old item is removed.
     1: * 'url' may not be NULL.
 64105: *
 64105: * ifdef LIVEWIRE url is treated as a char* and ownership is claimed by jsd
     1: */
     1: extern JSD_PUBLIC_API(JSDSourceText*)
     1: JSD_NewSourceText(JSDContext* jsdc, const char* url);
     1: 
     1: /*
     1: * Append text (or change status -- e.g. set completed) for a source text
     1: * item. Text need not be zero terminated. Callers should consider the returned
     1: * JSDSourceText to be the 'current' item for future use. This may return NULL
     1: * if called after this item has been replaced by a call to JSD_NewSourceText.
     1: */
     1: extern JSD_PUBLIC_API(JSDSourceText*)
     1: JSD_AppendSourceText(JSDContext*     jsdc,
     1:                      JSDSourceText*  jsdsrc,
     1:                      const char*     text,       /* *not* zero terminated */
     1:                      size_t          length,
     1:                      JSDSourceStatus status);
     1: 
     1: /*
     1: * Unicode varient of JSD_AppendSourceText.
     1: *
     1: * NOTE: At this point text is stored in 8bit ASCII so this function just
     1: * extracts the bottom 8bits from each jschar. At some future point we may
     1: * switch to storing and exposing 16bit Unicode.
     1: */
     1: extern JSD_PUBLIC_API(JSDSourceText*)
     1: JSD_AppendUCSourceText(JSDContext*     jsdc,
     1:                        JSDSourceText*  jsdsrc,
     1:                        const jschar*   text,       /* *not* zero terminated */
     1:                        size_t          length,
     1:                        JSDSourceStatus status);
     1: /*
     1:  * Convienence function for adding complete source of url in one call.
     1:  * same as:
     1:  *   JSDSourceText* jsdsrc;
     1:  *   JSD_LOCK_SOURCE_TEXT(jsdc);
     1:  *   jsdsrc = jsd_NewSourceText(jsdc, url);
     1:  *   if(jsdsrc)
     1:  *       jsdsrc = jsd_AppendSourceText(jsdc, jsdsrc,
     1:  *                                     text, length, JSD_SOURCE_PARTIAL);
     1:  *   if(jsdsrc)
     1:  *       jsdsrc = jsd_AppendSourceText(jsdc, jsdsrc,
     1:  *                                     NULL, 0, JSD_SOURCE_COMPLETED);
     1:  *   JSD_UNLOCK_SOURCE_TEXT(jsdc);
     1:  *   return jsdsrc ? JS_TRUE : JS_FALSE;
     1:  */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_AddFullSourceText(JSDContext* jsdc,
     1:                       const char* text,       /* *not* zero terminated */
     1:                       size_t      length,
     1:                       const char* url);
     1: 
     1: /***************************************************************************/
     1: /* Execution/Interrupt Hook functions */
     1: 
     1: /* possible 'type' params for JSD_ExecutionHookProc */
     1: #define JSD_HOOK_INTERRUPTED            0
     1: #define JSD_HOOK_BREAKPOINT             1
     1: #define JSD_HOOK_DEBUG_REQUESTED        2
     1: #define JSD_HOOK_DEBUGGER_KEYWORD       3
     1: #define JSD_HOOK_THROW                  4
     1: 
     1: /* legal return values for JSD_ExecutionHookProc */
     1: #define JSD_HOOK_RETURN_HOOK_ERROR      0
     1: #define JSD_HOOK_RETURN_CONTINUE        1
     1: #define JSD_HOOK_RETURN_ABORT           2
     1: #define JSD_HOOK_RETURN_RET_WITH_VAL    3
     1: #define JSD_HOOK_RETURN_THROW_WITH_VAL  4
     1: #define JSD_HOOK_RETURN_CONTINUE_THROW  5
     1: 
     1: /*
     1: * Implement a callback of this form in order to hook execution.
     1: */
 91237: typedef unsigned
 18907: (* JSD_ExecutionHookProc)(JSDContext*     jsdc,
     1:                           JSDThreadState* jsdthreadstate,
 91237:                           unsigned           type,
     1:                           void*           callerdata,
     1:                           jsval*          rval);
     1: 
     1: /* possible 'type' params for JSD_CallHookProc */
     1: #define JSD_HOOK_TOPLEVEL_START  0   /* about to evaluate top level script */
     1: #define JSD_HOOK_TOPLEVEL_END    1   /* done evaluting top level script    */
     1: #define JSD_HOOK_FUNCTION_CALL   2   /* about to call a function           */
     1: #define JSD_HOOK_FUNCTION_RETURN 3   /* done calling function              */
     1: 
     1: /*
     1: * Implement a callback of this form in order to hook function call/returns.
     1: * Return JS_TRUE from a TOPLEVEL_START or FUNCTION_CALL type call hook if you
     1: * want to hear about the TOPLEVEL_END or FUNCTION_RETURN too.  Return value is
     1: * ignored to TOPLEVEL_END and FUNCTION_RETURN type hooks.
     1: */
     1: typedef JSBool
 18907: (* JSD_CallHookProc)(JSDContext*     jsdc,
     1:                      JSDThreadState* jsdthreadstate,
 91237:                      unsigned           type,
     1:                      void*           callerdata);
     1: 
     1: /*
     1: * Set Hook to be called whenever the given pc is about to be executed --
     1: * i.e. for 'trap' or 'breakpoint'
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_SetExecutionHook(JSDContext*           jsdc,
     1:                      JSDScript*            jsdscript,
 86976:                      uintptr_t             pc,
     1:                      JSD_ExecutionHookProc hook,
     1:                      void*                 callerdata);
     1: 
     1: /*
     1: * Clear the hook for this pc
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_ClearExecutionHook(JSDContext*          jsdc,
     1:                        JSDScript*           jsdscript,
 86976:                        uintptr_t            pc);
     1: 
     1: /*
     1: * Clear all the pc specific hooks for this script
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_ClearAllExecutionHooksForScript(JSDContext* jsdc, JSDScript* jsdscript);
     1: 
     1: /*
     1: * Clear all the pc specific hooks for the entire JSRuntime associated with
     1: * this JSDContext
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_ClearAllExecutionHooks(JSDContext* jsdc);
     1: 
     1: /*
     1: * Set a hook to be called before the next instruction is executed. Depending
     1: * on the threading situation and whether or not an JS code is currently
     1: * executing the hook might be called before this call returns, or at some
     1: * future time. The hook will continue to be called as each instruction
     1: * executes until cleared.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_SetInterruptHook(JSDContext*           jsdc,
     1:                      JSD_ExecutionHookProc hook,
     1:                      void*                 callerdata);
     1: 
     1: /*
 59882: * Call the interrupt hook at least once per source line
 59882: */
 59882: extern JSD_PUBLIC_API(JSBool)
 59882: JSD_EnableSingleStepInterrupts(JSDContext* jsdc, JSDScript *jsdscript, JSBool enable);
 59882: 
 59882: /*
     1: * Clear the current interrupt hook.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_ClearInterruptHook(JSDContext* jsdc);
     1: 
     1: /*
     1: * Set the hook that should be called whenever a JSD_ErrorReporter hook
     1: * returns JSD_ERROR_REPORTER_DEBUG.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_SetDebugBreakHook(JSDContext*           jsdc,
     1:                       JSD_ExecutionHookProc hook,
     1:                       void*                 callerdata);
     1: 
     1: /*
     1: * Clear the debug break hook
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_ClearDebugBreakHook(JSDContext* jsdc);
     1: 
     1: /*
     1: * Set the hook that should be called when the 'debugger' keyword is
     1: * encountered by the JavaScript interpreter during execution.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_SetDebuggerHook(JSDContext*           jsdc,
     1:                     JSD_ExecutionHookProc hook,
     1:                     void*                 callerdata);
     1: 
     1: /*
     1: * Clear the 'debugger' keyword hook
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_ClearDebuggerHook(JSDContext* jsdc);
     1: 
     1: /*
     1: * Set the hook that should be called when a JS exception is thrown.
     1: * NOTE: the 'do default' return value is: JSD_HOOK_RETURN_CONTINUE_THROW
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_SetThrowHook(JSDContext*           jsdc,
     1:                  JSD_ExecutionHookProc hook,
     1:                  void*                 callerdata);
     1: /*
     1: * Clear the throw hook
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_ClearThrowHook(JSDContext* jsdc);
     1: 
     1: /*
     1: * Set the hook that should be called when a toplevel script begins or completes.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_SetTopLevelHook(JSDContext*      jsdc,
     1:                     JSD_CallHookProc hook,
     1:                     void*            callerdata);
     1: /*
     1: * Clear the toplevel call hook
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_ClearTopLevelHook(JSDContext* jsdc);
     1: 
     1: /*
     1: * Set the hook that should be called when a function call or return happens.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_SetFunctionHook(JSDContext*      jsdc,
     1:                     JSD_CallHookProc hook,
     1:                     void*            callerdata);
     1: /*
     1: * Clear the function call hook
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_ClearFunctionHook(JSDContext* jsdc);
     1: 
     1: /***************************************************************************/
     1: /* Stack Frame functions */
     1: 
     1: /*
     1: * Get the count of call stack frames for the given JSDThreadState
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetCountOfStackFrames(JSDContext* jsdc, JSDThreadState* jsdthreadstate);
     1: 
     1: /*
     1: * Get the 'current' call stack frame for the given JSDThreadState
     1: */
     1: extern JSD_PUBLIC_API(JSDStackFrameInfo*)
     1: JSD_GetStackFrame(JSDContext* jsdc, JSDThreadState* jsdthreadstate);
     1: 
     1: /*
     1: * Get the JSContext for the given JSDThreadState
     1: */
     1: extern JSD_PUBLIC_API(JSContext*)
     1: JSD_GetJSContext(JSDContext* jsdc, JSDThreadState* jsdthreadstate);
     1: 
     1: /*
     1: * Get the calling call stack frame for the given frame
     1: */
     1: extern JSD_PUBLIC_API(JSDStackFrameInfo*)
     1: JSD_GetCallingStackFrame(JSDContext* jsdc,
     1:                          JSDThreadState* jsdthreadstate,
     1:                          JSDStackFrameInfo* jsdframe);
     1: 
     1: /*
     1: * Get the script for the given call stack frame
     1: */
     1: extern JSD_PUBLIC_API(JSDScript*)
     1: JSD_GetScriptForStackFrame(JSDContext* jsdc,
     1:                            JSDThreadState* jsdthreadstate,
     1:                            JSDStackFrameInfo* jsdframe);
     1: 
     1: /*
     1: * Get the 'Program Counter' for the given call stack frame
     1: */
 86976: extern JSD_PUBLIC_API(uintptr_t)
     1: JSD_GetPCForStackFrame(JSDContext* jsdc,
     1:                        JSDThreadState* jsdthreadstate,
     1:                        JSDStackFrameInfo* jsdframe);
     1: 
     1: /*
     1: * Get the JavaScript Call Object for the given call stack frame.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetCallObjectForStackFrame(JSDContext* jsdc,
     1:                                JSDThreadState* jsdthreadstate,
     1:                                JSDStackFrameInfo* jsdframe);
     1: 
     1: /*
     1: * Get the head of the scope chain for the given call stack frame.
     1: * the chain can be traversed using JSD_GetValueParent.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetScopeChainForStackFrame(JSDContext* jsdc,
     1:                                JSDThreadState* jsdthreadstate,
     1:                                JSDStackFrameInfo* jsdframe);
     1: 
     1: /*
     1: * Get the 'this' Object for the given call stack frame.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetThisForStackFrame(JSDContext* jsdc,
     1:                          JSDThreadState* jsdthreadstate,
     1:                          JSDStackFrameInfo* jsdframe);
     1: 
     1: /*
     1: * Get the name of the function executing in this stack frame.  Especially useful
     1: * for native frames (without script objects.)
 61691: * *** new for gecko 2.0 ****
     1: */
 58976: extern JSD_PUBLIC_API(JSString *)
 61691: JSD_GetIdForStackFrame(JSDContext* jsdc,
     1:                        JSDThreadState* jsdthreadstate,
     1:                        JSDStackFrameInfo* jsdframe);
     1: 
     1: /*
     1: * True if stack frame represents a frame created as a result of a debugger
     1: * evaluation.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsStackFrameDebugger(JSDContext* jsdc,
     1:                          JSDThreadState* jsdthreadstate,
     1:                          JSDStackFrameInfo* jsdframe);
     1: 
     1: /*
     1: * True if stack frame is constructing a new object.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsStackFrameConstructing(JSDContext* jsdc,
     1:                              JSDThreadState* jsdthreadstate,
     1:                              JSDStackFrameInfo* jsdframe);
     1: 
     1: /*
     1: * Evaluate the given unicode source code in the context of the given stack frame.
     1: * returns JS_TRUE and puts result in rval on success, JS_FALSE on failure.
     1: * NOTE: The ErrorReporter hook might be called if this fails.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_EvaluateUCScriptInStackFrame(JSDContext* jsdc,
     1:                                  JSDThreadState* jsdthreadstate,
     1:                                  JSDStackFrameInfo* jsdframe,
 91237:                                  const jschar *bytes, unsigned length,
 91237:                                  const char *filename, unsigned lineno,
     1:                                  jsval *rval);
     1: 
     1: /*
     1: * Same as above, but does not eat exceptions.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_AttemptUCScriptInStackFrame(JSDContext* jsdc,
     1:                                 JSDThreadState* jsdthreadstate,
     1:                                 JSDStackFrameInfo* jsdframe,
 91237:                                 const jschar *bytes, unsigned length,
 91237:                                 const char *filename, unsigned lineno,
     1:                                 jsval *rval);
     1: 
     1: /* single byte character version of JSD_EvaluateUCScriptInStackFrame */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_EvaluateScriptInStackFrame(JSDContext* jsdc,
     1:                                JSDThreadState* jsdthreadstate,
     1:                                JSDStackFrameInfo* jsdframe,
 91237:                                const char *bytes, unsigned length,
 91237:                                const char *filename, unsigned lineno, jsval *rval);
     1: 
     1: /*
     1: * Same as above, but does not eat exceptions.
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_AttemptScriptInStackFrame(JSDContext* jsdc,
     1:                               JSDThreadState* jsdthreadstate,
     1:                               JSDStackFrameInfo* jsdframe,
 91237:                               const char *bytes, unsigned length,
 91237:                               const char *filename, unsigned lineno, jsval *rval);
     1: 
     1: /*
     1: * Convert the given jsval to a string
     1: * NOTE: The ErrorReporter hook might be called if this fails.
     1: */
     1: extern JSD_PUBLIC_API(JSString*)
     1: JSD_ValToStringInStackFrame(JSDContext* jsdc,
     1:                             JSDThreadState* jsdthreadstate,
     1:                             JSDStackFrameInfo* jsdframe,
     1:                             jsval val);
     1: 
     1: /*
     1: * Get the JSDValue currently being thrown as an exception (may be NULL).
     1: * NOTE: must eventually release by calling JSD_DropValue (if not NULL)
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetException(JSDContext* jsdc, JSDThreadState* jsdthreadstate);
     1: 
     1: /*
     1: * Set the JSDValue currently being thrown as an exception.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_SetException(JSDContext* jsdc, JSDThreadState* jsdthreadstate, 
     1:                  JSDValue* jsdval);
     1: 
     1: /***************************************************************************/
     1: /* Error Reporter functions */
     1: 
     1: /*
     1: * XXX The ErrorReporter Hook scheme is going to change soon to more
     1: *     Fully support exceptions.
     1: */
     1: 
     1: /* legal return values for JSD_ErrorReporter */
     1: #define JSD_ERROR_REPORTER_PASS_ALONG   0 /* pass along to regular reporter */
     1: #define JSD_ERROR_REPORTER_RETURN       1 /* don't pass to error reporter */
     1: #define JSD_ERROR_REPORTER_DEBUG        2 /* force call to DebugBreakHook */
     1: #define JSD_ERROR_REPORTER_CLEAR_RETURN 3 /* clear exception and don't pass */
     1: 
     1: /*
     1: * Implement a callback of this form in order to hook the ErrorReporter
     1: */
 91237: typedef unsigned
 18907: (* JSD_ErrorReporter)(JSDContext*     jsdc,
     1:                       JSContext*      cx,
     1:                       const char*     message,
     1:                       JSErrorReport*  report,
     1:                       void*           callerdata);
     1: 
     1: /* Set ErrorReporter hook */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_SetErrorReporter(JSDContext*       jsdc,
     1:                      JSD_ErrorReporter reporter,
     1:                      void*             callerdata);
     1: 
     1: /* Get Current ErrorReporter hook */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_GetErrorReporter(JSDContext*        jsdc,
     1:                      JSD_ErrorReporter* reporter,
     1:                      void**             callerdata);
     1: 
     1: /***************************************************************************/
     1: /* Generic locks that callers can use for their own purposes */
     1: 
     1: /*
     1: * Is Locking and GetThread supported in this build?
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsLockingAndThreadIdSupported();
     1: 
     1: /*
     1: * Create a reentrant/nestable lock
     1: */
     1: extern JSD_PUBLIC_API(void*)
     1: JSD_CreateLock();
     1: 
     1: /*
     1: * Aquire lock for this thread (or block until available). Increments a
     1: * counter if this thread already owns the lock.
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_Lock(void* lock);
     1: 
     1: /*
     1: * Release lock for this thread (or decrement the counter if JSD_Lock
     1: * was previous called more than once).
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_Unlock(void* lock);
     1: 
     1: /*
     1: * For debugging only if not (JS_THREADSAFE AND DEBUG) then returns JS_TRUE
     1: *    So JSD_IsLocked(lock) may not equal !JSD_IsUnlocked(lock)
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsLocked(void* lock);
     1: 
     1: /*
     1: * See above...
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsUnlocked(void* lock);
     1: 
     1: /*
     1: * return an ID uniquely identifying this thread.
     1: */
     1: extern JSD_PUBLIC_API(void*)
     1: JSD_CurrentThread();
     1: 
     1: /***************************************************************************/
     1: /* Value and Property Functions  --- All NEW for 1.1 --- */
     1: 
     1: /*
     1: * NOTE: JSDValue and JSDProperty objects are reference counted. This allows
     1: * for rooting these objects AND any underlying garbage collected jsvals.
     1: * ALL JSDValue and JSDProperty objects returned by the functions below
     1: * MUST eventually be released using the appropriate JSD_Dropxxx function.
     1: */
     1: 
     1: /*
     1: * Create a new JSDValue to wrap the given jsval
     1: * NOTE: must eventually release by calling JSD_DropValue (if not NULL)
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_NewValue(JSDContext* jsdc, jsval val);
     1: 
     1: /*
     1: * Release the JSDValue. After this call the object MUST not be referenced again!
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_DropValue(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Get the jsval wrapped by this JSDValue
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(jsval)
     1: JSD_GetValueWrappedJSVal(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Clear all property and association information about the given JSDValue.
     1: * Such information will be lazily regenerated when later accessed. This
     1: * function must be called to make changes to the properties of an object
     1: * visible to the accessor functions below (if the properties et.al. have
     1: * changed since a previous call to those accessors).
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_RefreshValue(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /**************************************************/
     1: 
     1: /*
     1: * Does the JSDValue wrap a JSObject?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValueObject(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Does the JSDValue wrap a number (int or double)?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValueNumber(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Does the JSDValue wrap an int?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValueInt(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Does the JSDValue wrap a double?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValueDouble(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Does the JSDValue wrap a JSString?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValueString(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Does the JSDValue wrap a JSBool?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValueBoolean(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Does the JSDValue wrap a JSVAL_NULL?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValueNull(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Does the JSDValue wrap a JSVAL_VOID?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValueVoid(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Does the JSDValue wrap a primative (not a JSObject)?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValuePrimitive(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Does the JSDValue wrap a function?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValueFunction(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Does the JSDValue wrap a native function?
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_IsValueNative(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /**************************************************/
     1: 
     1: /*
     1: * Return JSBool value (does NOT do conversion).
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSD_GetValueBoolean(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
 84755: * Return int32_t value (does NOT do conversion).
     1: * *** new for version 1.1 ****
     1: */
 84755: extern JSD_PUBLIC_API(int32_t)
     1: JSD_GetValueInt(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Return double value (does NOT do conversion).
     1: * *** new for version 1.1 ****
     1: */
 90955: extern JSD_PUBLIC_API(double)
     1: JSD_GetValueDouble(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Return JSString value (DOES do conversion if necessary).
     1: * NOTE that the JSString returned is not protected from garbage
     1: * collection. It should be immediately read or wrapped using
     1: * JSD_NewValue(jsdc,STRING_TO_JSVAL(str)) if necessary.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSString*)
     1: JSD_GetValueString(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Return name of function IFF JSDValue represents a function.
 61691: * *** new for gecko 2.0 ****
     1: */
 58976: extern JSD_PUBLIC_API(JSString *)
 61691: JSD_GetValueFunctionId(JSDContext* jsdc, JSDValue* jsdval);
     1: 
 60563: /*
 60563: * Return function object IFF JSDValue represents a function or an object
 60563: * wrapping a function.
 60563: * *** new for version 1.1 ****
 60563: */
 60563: extern JSD_PUBLIC_API(JSFunction*)
 60563: JSD_GetValueFunction(JSDContext* jsdc, JSDValue* jsdval);
 60563: 
     1: /**************************************************/
     1: 
     1: /*
     1: * Return the number of properties for the JSDValue.
     1: * *** new for version 1.1 ****
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetCountOfProperties(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Iterate through the properties of the JSDValue.
     1: * Use form similar to that shown for JSD_IterateScripts (no locking required).
     1: * NOTE: each JSDProperty returned must eventually be released by calling
     1: * JSD_DropProperty.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDProperty*)
     1: JSD_IterateProperties(JSDContext* jsdc, JSDValue* jsdval, JSDProperty **iterp);
     1: 
     1: /* 
     1: * Get the JSDProperty for the property of this JSDVal with this name.
     1: * NOTE: must eventually release by calling JSD_DropProperty (if not NULL)
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDProperty*)
     1: JSD_GetValueProperty(JSDContext* jsdc, JSDValue* jsdval, JSString* name);
     1: 
     1: /*
     1: * Get the prototype object for this JSDValue.
     1: * NOTE: must eventually release by calling JSD_DropValue (if not NULL)
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetValuePrototype(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Get the parent object for this JSDValue.
     1: * NOTE: must eventually release by calling JSD_DropValue (if not NULL)
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetValueParent(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Get the ctor object for this JSDValue (or likely its prototype's ctor).
     1: * NOTE: must eventually release by calling JSD_DropValue (if not NULL)
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetValueConstructor(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Get the name of the class for this object.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(const char*)
     1: JSD_GetValueClassName(JSDContext* jsdc, JSDValue* jsdval);
     1: 
 33644: /*
 33644: * Get the script for the given value if the given value represents a
 33644: * scripted function.  Otherwise, return null.
 33644: */
 33644: extern JSD_PUBLIC_API(JSDScript*)
 33644: JSD_GetScriptForValue(JSDContext* jsdc, JSDValue* jsdval);
 33644: 
     1: /**************************************************/
     1: 
     1: /* possible or'd together bitflags returned by JSD_GetPropertyFlags
     1:  *
     1:  * XXX these must stay the same as the JSPD_ flags in jsdbgapi.h
     1:  */
     1: #define JSDPD_ENUMERATE  JSPD_ENUMERATE    /* visible to for/in loop */
     1: #define JSDPD_READONLY   JSPD_READONLY     /* assignment is error */
     1: #define JSDPD_PERMANENT  JSPD_PERMANENT    /* property cannot be deleted */
     1: #define JSDPD_ALIAS      JSPD_ALIAS        /* property has an alias id */
     1: #define JSDPD_EXCEPTION  JSPD_EXCEPTION    /* exception occurred looking up */
     1:                                            /* proprety, value is exception  */
     1: #define JSDPD_ERROR      JSPD_ERROR        /* native getter returned JS_FALSE */
     1:                                            /* without throwing an exception */
     1: /* this is not one of the JSPD_ flags in jsdbgapi.h  - careful not to overlap*/
     1: #define JSDPD_HINTED     0x800             /* found via explicit lookup */
     1: 
     1: /*
     1: * Release this JSDProperty
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_DropProperty(JSDContext* jsdc, JSDProperty* jsdprop);
     1: 
     1: /*
     1: * Get the JSDValue represeting the name of this property (int or string)
     1: * NOTE: must eventually release by calling JSD_DropValue
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetPropertyName(JSDContext* jsdc, JSDProperty* jsdprop);
     1: 
     1: /*
     1: * Get the JSDValue represeting the current value of this property
     1: * NOTE: must eventually release by calling JSD_DropValue (if not NULL)
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetPropertyValue(JSDContext* jsdc, JSDProperty* jsdprop);
     1: 
     1: /*
     1: * Get the JSDValue represeting the alias of this property (if JSDPD_ALIAS set)
     1: * NOTE: must eventually release by calling JSD_DropValue (if not NULL)
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetPropertyAlias(JSDContext* jsdc, JSDProperty* jsdprop);
     1: 
     1: /*
     1: * Get the flags for this property
     1: * *** new for version 1.1 ****
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetPropertyFlags(JSDContext* jsdc, JSDProperty* jsdprop);
     1: 
     1: /***************************************************************************/
     1: /* Object Functions  --- All NEW for 1.1 --- */
     1: 
     1: /*
     1: * JSDObjects exist to allow a means of iterating through all JSObjects in the
     1: * engine. They are created and destroyed as the wrapped JSObjects are created
     1: * and destroyed in the engine. JSDObjects additionally track the location in
     1: * the JavaScript source where their wrapped JSObjects were created and the name
     1: * and location of the (non-native) constructor used.
     1: *
     1: * NOTE: JSDObjects are NOT reference counted. The have only weak links to
     1: * jsObjects - thus they do not inhibit garbage collection of JSObjects. If
     1: * you need a JSDObject to safely persist then wrap it in a JSDValue (using
     1: * jsd_GetValueForObject).
     1: */
     1: 
     1: /*
     1: * Lock the entire Object subsystem -- see JSD_UnlockObjectSubsystem
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_LockObjectSubsystem(JSDContext* jsdc);
     1: 
     1: /*
     1: * Unlock the entire Object subsystem -- see JSD_LockObjectSubsystem
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(void)
     1: JSD_UnlockObjectSubsystem(JSDContext* jsdc);
     1: 
     1: /*
     1: * Iterate through the known objects
     1: * Use form similar to that shown for JSD_IterateScripts.
     1: * NOTE: the ObjectSubsystem must be locked before and unlocked after iterating.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDObject*)
     1: JSD_IterateObjects(JSDContext* jsdc, JSDObject** iterp);
     1: 
     1: /*
     1: * Get the JSObject represented by this JSDObject
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSObject*)
     1: JSD_GetWrappedObject(JSDContext* jsdc, JSDObject* jsdobj);
     1: 
     1: /*
     1: * Get the URL of the line of source that caused this object to be created.
     1: * May be NULL.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(const char*)
     1: JSD_GetObjectNewURL(JSDContext* jsdc, JSDObject* jsdobj);
     1: 
     1: /*
     1: * Get the line number of the line of source that caused this object to be
     1: * created. May be 0 indicating that the line number is unknown.
     1: * *** new for version 1.1 ****
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetObjectNewLineNumber(JSDContext* jsdc, JSDObject* jsdobj);
     1: 
     1: /*
     1: * Get the URL of the line of source of the constructor for this object.
     1: * May be NULL.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(const char*)
     1: JSD_GetObjectConstructorURL(JSDContext* jsdc, JSDObject* jsdobj);
     1: 
     1: /*
     1: * Get the line number of the line of source of the constructor for this object.
     1: * created. May be 0 indicating that the line number is unknown.
     1: * *** new for version 1.1 ****
     1: */
 91237: extern JSD_PUBLIC_API(unsigned)
     1: JSD_GetObjectConstructorLineNumber(JSDContext* jsdc, JSDObject* jsdobj);
     1: 
     1: /*
     1: * Get the name of the constructor for this object.
     1: * May be NULL.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(const char*)
     1: JSD_GetObjectConstructorName(JSDContext* jsdc, JSDObject* jsdobj);
     1: 
     1: /*
     1: * Get JSDObject representing this JSObject.
     1: * May return NULL.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDObject*)
     1: JSD_GetJSDObjectForJSObject(JSDContext* jsdc, JSObject* jsobj);
     1: 
     1: /*
     1: * Get JSDObject representing this JSDValue.
     1: * May return NULL.
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDObject*)
     1: JSD_GetObjectForValue(JSDContext* jsdc, JSDValue* jsdval);
     1: 
     1: /*
     1: * Create a JSDValue to wrap (and root) this JSDObject.
     1: * NOTE: must eventually release by calling JSD_DropValue (if not NULL)
     1: * *** new for version 1.1 ****
     1: */
     1: extern JSD_PUBLIC_API(JSDValue*)
     1: JSD_GetValueForObject(JSDContext* jsdc, JSDObject* jsdobj);
     1: 
     1: /***************************************************************************/
     1: /* Livewire specific API */
     1: #ifdef LIVEWIRE
     1: 
     1: extern JSD_PUBLIC_API(LWDBGScript*)
     1: JSDLW_GetLWScript(JSDContext* jsdc, JSDScript* jsdscript);
     1: 
     1: extern JSD_PUBLIC_API(JSDSourceText*)
     1: JSDLW_PreLoadSource(JSDContext* jsdc, LWDBGApp* app,
     1:                     const char* filename, JSBool clear);
     1: 
     1: extern JSD_PUBLIC_API(JSDSourceText*)
     1: JSDLW_ForceLoadSource(JSDContext* jsdc, JSDSourceText* jsdsrc);
     1: 
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSDLW_RawToProcessedLineNumber(JSDContext* jsdc, JSDScript* jsdscript,
 91237:                                unsigned lineIn, unsigned* lineOut);
     1: 
     1: extern JSD_PUBLIC_API(JSBool)
     1: JSDLW_ProcessedToRawLineNumber(JSDContext* jsdc, JSDScript* jsdscript,
 91237:                                unsigned lineIn, unsigned* lineOut);
     1: 
     1: #endif
     1: /***************************************************************************/
     1: 
     1: JS_END_EXTERN_C
     1: 
     1: #endif /* jsdebug_h___ */
