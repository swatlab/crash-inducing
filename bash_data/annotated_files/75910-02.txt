52558: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52558:  * vim: set ts=4 sw=4 et tw=99:
52558:  *
52558:  * ***** BEGIN LICENSE BLOCK *****
52558:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52558:  *
52558:  * The contents of this file are subject to the Mozilla Public License Version
52558:  * 1.1 (the "License"); you may not use this file except in compliance with
52558:  * the License. You may obtain a copy of the License at
52558:  * http://www.mozilla.org/MPL/
52558:  *
52558:  * Software distributed under the License is distributed on an "AS IS" basis,
52558:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52558:  * for the specific language governing rights and limitations under the
52558:  * License.
52558:  *
52558:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52558:  * May 28, 2008.
52558:  *
52558:  * The Initial Developer of the Original Code is
52558:  *   Brendan Eich <brendan@mozilla.org>
52558:  *
52558:  * Contributor(s):
52558:  *   David Anderson <danderson@mozilla.com>
52558:  *   David Mandelin <dmandelin@mozilla.com>
52558:  *
52558:  * Alternatively, the contents of this file may be used under the terms of
52558:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52558:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52558:  * in which case the provisions of the GPL or the LGPL are applicable instead
52558:  * of those above. If you wish to allow use of your version of this file only
52558:  * under the terms of either the GPL or the LGPL, and not to allow others to
52558:  * use your version of this file under the terms of the MPL, indicate your
52558:  * decision by deleting the provisions above and replace them with the notice
52558:  * and other provisions required by the GPL or the LGPL. If you do not delete
52558:  * the provisions above, a recipient may use your version of this file under
52558:  * the terms of any one of the MPL, the GPL or the LGPL.
52558:  *
52558:  * ***** END LICENSE BLOCK ***** */
52558: #if !defined jsjaeger_compiler_h__ && defined JS_METHODJIT
52558: #define jsjaeger_compiler_h__
52558: 
56602: #include "jsanalyze.h"
52558: #include "jscntxt.h"
52558: #include "jstl.h"
52558: #include "MethodJIT.h"
52606: #include "CodeGenIncludes.h"
55463: #include "BaseCompiler.h"
52608: #include "StubCompiler.h"
52831: #include "MonoIC.h"
52880: #include "PolyIC.h"
52558: 
52558: namespace js {
52558: namespace mjit {
52558: 
75828: struct PatchableFrame {
75828:     JSStackFrame *fp;
75828:     jsbytecode *pc;
75892:     bool scriptedCall;
75828: };
75828: 
55463: class Compiler : public BaseCompiler
52558: {
57766:     friend class StubCompiler;
57766: 
52599:     struct BranchPatch {
75864:         BranchPatch(const Jump &j, jsbytecode *pc, uint32 inlineIndex)
75864:           : jump(j), pc(pc), inlineIndex(inlineIndex)
52599:         { }
52599: 
52599:         Jump jump;
52599:         jsbytecode *pc;
75864:         uint32 inlineIndex;
52599:     };
52599: 
53119: #if defined JS_MONOIC
62386:     struct GlobalNameICInfo {
62385:         Label fastPathStart;
62386:         Call slowPathCall;
62386:         DataLabel32 shape;
62386:         DataLabelPtr addrLabel;
62386:         bool usePropertyCache;
62386: 
62386:         void copyTo(ic::GlobalNameIC &to, JSC::LinkBuffer &full, JSC::LinkBuffer &stub) {
62386:             to.fastPathStart = full.locationOf(fastPathStart);
62386: 
62386:             int offset = full.locationOf(shape) - to.fastPathStart;
62386:             to.shapeOffset = offset;
62386:             JS_ASSERT(to.shapeOffset == offset);
62386: 
62386:             to.slowPathCall = stub.locationOf(slowPathCall);
62386:             to.usePropertyCache = usePropertyCache;
62386:         }
62386:     };
62386: 
62386:     struct GetGlobalNameICInfo : public GlobalNameICInfo {
62386:         Label load;
62386:     };
62386: 
62386:     struct SetGlobalNameICInfo : public GlobalNameICInfo {
62385:         Label slowPathStart;
62385:         Label fastPathRejoin;
60637:         DataLabel32 store;
62385:         Jump shapeGuardJump;
62385:         ValueRemat vr;
62385:         RegisterID objReg;
62385:         RegisterID shapeReg;
62385:         bool objConst;
52826:     };
53590: 
56192:     struct EqualityGenInfo {
56192:         DataLabelPtr addrLabel;
56192:         Label stubEntry;
56192:         Call stubCall;
56192:         BoolStub stub;
56192:         MaybeJump jumpToStub;
56192:         Label fallThrough;
56192:         jsbytecode *jumpTarget;
75649:         bool trampoline;
75649:         Label trampolineStart;
56192:         ValueRemat lvr, rvr;
56192:         Assembler::Condition cond;
56192:         JSC::MacroAssembler::RegisterID tempReg;
56192:     };
56192:     
56217:     struct TraceGenInfo {
56220:         bool initialized;
56217:         Label stubEntry;
56217:         DataLabelPtr addrLabel;
56217:         jsbytecode *jumpTarget;
75695:         bool fastTrampoline;
75649:         Label trampolineStart;
56217:         Jump traceHint;
56217:         MaybeJump slowTraceHint;
56220: 
56220:         TraceGenInfo() : initialized(false) {}
56217:     };
56217: 
53590:     /* InlineFrameAssembler wants to see this. */
53590:   public:
53590:     struct CallGenInfo {
53590:         /*
53590:          * These members map to members in CallICInfo. See that structure for
53590:          * more comments.
53590:          */
75864:         uint32       callIndex;
53590:         DataLabelPtr funGuard;
53590:         Jump         funJump;
54832:         Jump         hotJump;
53590:         Call         oolCall;
53590:         Label        joinPoint;
53590:         Label        slowJoinPoint;
53590:         Label        slowPathStart;
53590:         Label        hotPathLabel;
55503:         DataLabelPtr addrLabel1;
55503:         DataLabelPtr addrLabel2;
53590:         Jump         oolJump;
59895:         Label        icCall;
53590:         RegisterID   funObjReg;
53590:         RegisterID   funPtrReg;
57717:         FrameSize    frameSize;
75776:         bool         typeMonitored;
75794:         types::ClonedTypeSet *argTypes;
53590:     };
53590: 
53590:   private:
53119: #endif
52826: 
54832:     /*
54832:      * Writes of call return addresses which needs to be delayed until the final
54832:      * absolute address of the join point is known.
54832:      */
54832:     struct CallPatchInfo {
57713:         CallPatchInfo() : hasFastNcode(false), hasSlowNcode(false) {}
54832:         Label joinPoint;
54832:         DataLabelPtr fastNcodePatch;
54832:         DataLabelPtr slowNcodePatch;
57713:         bool hasFastNcode;
54832:         bool hasSlowNcode;
54832:     };
54832: 
56575:     struct BaseICInfo {
56738:         BaseICInfo(JSOp op) : op(op)
56738:         { }
56575:         Label fastPathStart;
56575:         Label fastPathRejoin;
56575:         Label slowPathStart;
56575:         Call slowPathCall;
56575:         DataLabelPtr paramAddr;
56738:         JSOp op;
56738: 
56738:         void copyTo(ic::BaseIC &to, JSC::LinkBuffer &full, JSC::LinkBuffer &stub) {
56738:             to.fastPathStart = full.locationOf(fastPathStart);
56738:             to.fastPathRejoin = full.locationOf(fastPathRejoin);
56738:             to.slowPathStart = stub.locationOf(slowPathStart);
56738:             to.slowPathCall = stub.locationOf(slowPathCall);
56738:             to.op = op;
56738:             JS_ASSERT(to.op == op);
56738:         }
56738:     };
56738: 
56738:     struct GetElementICInfo : public BaseICInfo {
56738:         GetElementICInfo(JSOp op) : BaseICInfo(op)
56738:         { }
56738:         RegisterID  typeReg;
56738:         RegisterID  objReg;
56738:         ValueRemat  id;
56738:         MaybeJump   typeGuard;
56738:         Jump        claspGuard;
56575:     };
56575: 
57671:     struct SetElementICInfo : public BaseICInfo {
57671:         SetElementICInfo(JSOp op) : BaseICInfo(op)
57671:         { }
57671:         RegisterID  objReg;
57671:         StateRemat  objRemat;
57671:         ValueRemat  vr;
57671:         Jump        capacityGuard;
57671:         Jump        claspGuard;
57671:         Jump        holeGuard;
57671:         Int32Key    key;
60164:         uint32      volatileMask;
57671:     };
57671: 
56575:     struct PICGenInfo : public BaseICInfo {
56738:         PICGenInfo(ic::PICInfo::Kind kind, JSOp op, bool usePropCache)
75794:           : BaseICInfo(op), kind(kind), usePropCache(usePropCache), typeMonitored(false)
52880:         { }
52880:         ic::PICInfo::Kind kind;
52884:         Label typeCheck;
52880:         RegisterID shapeReg;
52880:         RegisterID objReg;
52884:         RegisterID typeReg;
56201:         bool usePropCache;
52880:         Label shapeGuard;
56551:         jsbytecode *pc;
52892:         JSAtom *atom;
52884:         bool hasTypeCheck;
75775:         bool typeMonitored;
75794:         types::ClonedTypeSet *rhsTypes;
52887:         ValueRemat vr;
60590: #ifdef JS_HAS_IC_LABELS
60590:         union {
60590:             ic::GetPropLabels getPropLabels_;
60590:             ic::SetPropLabels setPropLabels_;
60590:             ic::BindNameLabels bindNameLabels_;
60594:             ic::ScopeNameLabels scopeNameLabels_;
60590:         };
60590: 
60590:         ic::GetPropLabels &getPropLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::GET || kind == ic::PICInfo::CALL);
60590:             return getPropLabels_;
60590:         }
60590:         ic::SetPropLabels &setPropLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::SET || kind == ic::PICInfo::SETMETHOD);
60590:             return setPropLabels_;
60590:         }
60590:         ic::BindNameLabels &bindNameLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::BIND);
60590:             return bindNameLabels_;
60590:         }
60594:         ic::ScopeNameLabels &scopeNameLabels() {
60594:             JS_ASSERT(kind == ic::PICInfo::NAME || kind == ic::PICInfo::XNAME);
60594:             return scopeNameLabels_;
60594:         }
60590: #else
60590:         ic::GetPropLabels &getPropLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::GET || kind == ic::PICInfo::CALL);
60590:             return ic::PICInfo::getPropLabels_;
60590:         }
60590:         ic::SetPropLabels &setPropLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::SET || kind == ic::PICInfo::SETMETHOD);
60590:             return ic::PICInfo::setPropLabels_;
60590:         }
60590:         ic::BindNameLabels &bindNameLabels() {
60590:             JS_ASSERT(kind == ic::PICInfo::BIND);
60590:             return ic::PICInfo::bindNameLabels_;
60590:         }
60594:         ic::ScopeNameLabels &scopeNameLabels() {
60594:             JS_ASSERT(kind == ic::PICInfo::NAME || kind == ic::PICInfo::XNAME);
60594:             return ic::PICInfo::scopeNameLabels_;
60594:         }
53315: #endif
53137: 
60590:         void copySimpleMembersTo(ic::PICInfo &ic) {
56575:             ic.kind = kind;
56575:             ic.shapeReg = shapeReg;
56575:             ic.objReg = objReg;
56575:             ic.atom = atom;
56575:             ic.usePropCache = usePropCache;
56575:             if (ic.isSet()) {
56575:                 ic.u.vr = vr;
56575:             } else if (ic.isGet()) {
56575:                 ic.u.get.typeReg = typeReg;
56575:                 ic.u.get.hasTypeCheck = hasTypeCheck;
53137:             }
75775:             ic.typeMonitored = typeMonitored;
75794:             ic.rhsTypes = rhsTypes;
60590: #ifdef JS_HAS_IC_LABELS
60590:             if (ic.isGet())
60590:                 ic.setLabels(getPropLabels());
60590:             else if (ic.isSet())
60590:                 ic.setLabels(setPropLabels());
60593:             else if (ic.isBind())
60590:                 ic.setLabels(bindNameLabels());
60594:             else if (ic.isScopeName())
60594:                 ic.setLabels(scopeNameLabels());
60590: #endif
53137:         }
53137: 
52880:     };
52880: 
52611:     struct Defs {
52611:         Defs(uint32 ndefs)
52611:           : ndefs(ndefs)
52611:         { }
52611:         uint32 ndefs;
52611:     };
52611: 
53168:     struct InternalCallSite {
57766:         uint32 returnOffset;
75864:         DataLabelPtr callPatch;
75864:         DataLabelPtr inlinePatch;
75864:         uint32 inlineIndex;
75864:         jsbytecode *inlinepc;
75636:         size_t id;
57766:         bool call;
57766:         bool ool;
57766: 
75864:         InternalCallSite(uint32 returnOffset,
75864:                          uint32 inlineIndex, jsbytecode *inlinepc, size_t id,
57766:                          bool call, bool ool)
75864:           : returnOffset(returnOffset),
75864:             inlineIndex(inlineIndex), inlinepc(inlinepc), id(id),
75864:             call(call), ool(ool)
57766:         { }
53168:     };
53168: 
53183:     struct DoublePatch {
53183:         double d;
53183:         DataLabelPtr label;
53183:         bool ool;
53183:     };
53183: 
59979:     struct JumpTable {
59979:         DataLabelPtr label;
59979:         size_t offsetIndex;
59979:     };
59979: 
75763:     struct LoopEntry {
75763:         uint32 pcOffset;
75763:         Label label;
75763:     };
75763: 
75864:     JSScript *outerScript;
75879:     bool isConstructing;
75879: 
75879:     JSObject *globalObj;
75828: 
75828:     /* Existing frames on the stack whose slots may need to be updated. */
75864:     const Vector<PatchableFrame> *patchFrames;
75864: 
75864:     bool *savedTraps;
75864:     Assembler masm;
75864:     FrameState frame;
75864: 
75864:     /*
75864:      * State for the current stack frame.
75864:      *
75864:      * When inlining function calls, we keep track of the state of each inline
75864:      * frame. The state of parent frames is not modified while analyzing an
75864:      * inner frame, though registers used by those parents can be spilled in
75864:      * the frame (reflected by the frame's active register state).
75864:      */
75864: 
75864:     struct ActiveFrame {
75864:         ActiveFrame *parent;
75864:         jsbytecode *parentPC;
75864:         JSScript *script;
75864:         uint32 inlineIndex;
75864:         analyze::Script analysis;
75864:         analyze::LifetimeScript liveness;
75864:         Label *jumpMap;
75864:         bool hasThisType;
75864:         JSValueType thisType;
75864:         JSValueType *argumentTypes;
75864:         JSValueType *localTypes;
75864:         uint32 depth;
75864:         Vector<UnsyncedEntry> unsyncedEntries; // :XXX: handle OOM
75864: 
75864:         /* State for managing return from inlined frames. */
75864:         bool needReturnValue;
75864:         bool syncReturnValue;
75864:         bool returnValueDouble;
75864:         bool returnSet;
75864:         AnyRegisterID returnRegister;
75864:         Registers returnParentRegs;
75870:         Registers temporaryParentRegs;
75870:         Vector<Jump, 4, CompilerAllocPolicy> *returnJumps;
75864: 
75864:         ActiveFrame(JSContext *cx);
75864:         ~ActiveFrame();
75864:     };
75864:     ActiveFrame *a;
75864:     ActiveFrame *outer;
75828: 
52558:     JSScript *script;
52558:     jsbytecode *PC;
75864: 
75864:     /* State spanning all stack frames. */
75864: 
75864:     js::Vector<ActiveFrame*, 4, CompilerAllocPolicy> inlineFrames;
57679:     js::Vector<BranchPatch, 64, CompilerAllocPolicy> branchPatches;
53119: #if defined JS_MONOIC
62386:     js::Vector<GetGlobalNameICInfo, 16, CompilerAllocPolicy> getGlobalNames;
62386:     js::Vector<SetGlobalNameICInfo, 16, CompilerAllocPolicy> setGlobalNames;
57679:     js::Vector<CallGenInfo, 64, CompilerAllocPolicy> callICs;
57679:     js::Vector<EqualityGenInfo, 64, CompilerAllocPolicy> equalityICs;
57679:     js::Vector<TraceGenInfo, 64, CompilerAllocPolicy> traceICs;
53119: #endif
53119: #if defined JS_POLYIC
57679:     js::Vector<PICGenInfo, 16, CompilerAllocPolicy> pics;
57679:     js::Vector<GetElementICInfo, 16, CompilerAllocPolicy> getElemICs;
57679:     js::Vector<SetElementICInfo, 16, CompilerAllocPolicy> setElemICs;
53119: #endif
57679:     js::Vector<CallPatchInfo, 64, CompilerAllocPolicy> callPatches;
57679:     js::Vector<InternalCallSite, 64, CompilerAllocPolicy> callSites;
57679:     js::Vector<DoublePatch, 16, CompilerAllocPolicy> doubleList;
59979:     js::Vector<JumpTable, 16> jumpTables;
59979:     js::Vector<uint32, 16> jumpTableOffsets;
75763:     js::Vector<LoopEntry, 16> loopEntries;
52608:     StubCompiler stubcc;
52872:     Label invokeLabel;
53590:     Label arityLabel;
75791: #ifdef JS_MONOIC
75791:     Label argsCheckStub;
75791:     Label argsCheckFallthrough;
75791:     Jump argsCheckJump;
75791: #endif
57766:     bool debugMode_;
53133:     bool addTraceHints;
75636:     bool recompiling;
75869:     bool inlining;
57679:     bool oomInVector;       // True if we have OOM'd appending to a vector. 
57718:     enum { NoApplyTricks, LazyArgsObj } applyTricks;
52599: 
56774:     Compiler *thisFromCtor() { return this; }
57679: 
57679:     friend class CompilerAllocPolicy;
52558:   public:
52558:     // Special atom index used to indicate that the atom is 'length'. This
52558:     // follows interpreter usage in JSOP_LENGTH.
52558:     enum { LengthAtomIndex = uint32(-2) };
52558: 
75910:     Compiler(JSContext *cx, JSScript *outerScript, bool isConstructing,
75879:              const Vector<PatchableFrame> *patchFrames, bool recompiling);
52558:     ~Compiler();
52558: 
75828:     CompileStatus compile();
52558: 
52611:     Label getLabel() { return masm.label(); }
52653:     bool knownJump(jsbytecode *pc);
75864:     Label labelOf(jsbytecode *target, uint32 inlineIndex);
57766:     void addCallSite(const InternalCallSite &callSite);
75864:     void addReturnSite(Label joinPoint, bool ool = false);
57766:     bool loadOldTraps(const Vector<CallSite> &site);
57766: 
57766:     bool debugMode() { return debugMode_; }
52608: 
75864:     jsbytecode *outerPC() {
75864:         if (a == outer)
75864:             return PC;
75864:         ActiveFrame *scan = a;
75864:         while (scan && scan->parent != outer)
75864:             scan = scan->parent;
75864:         return scan->parentPC;
75864:     }
75864: 
75864:     jsbytecode *inlinePC() { return PC; }
75864:     uint32 inlineIndex() { return a->inlineIndex; }
75864: 
52558:   private:
75828:     CompileStatus performCompilation(JITScript **jitp);
52558:     CompileStatus generatePrologue();
52558:     CompileStatus generateMethod();
52558:     CompileStatus generateEpilogue();
55503:     CompileStatus finishThisUp(JITScript **jitp);
75864:     CompileStatus pushActiveFrame(JSScript *script, uint32 argc);
75864:     void popActiveFrame();
52560: 
75625:     /* Analysis helpers. */
75864:     CompileStatus prepareInferenceTypes(JSScript *script, ActiveFrame *a);
75630:     void fixDoubleTypes(Uses uses);
75625:     void restoreAnalysisTypes(uint32 stackDepth);
75630:     JSValueType knownThisType();
75625:     JSValueType knownArgumentType(uint32 arg);
75625:     JSValueType knownLocalType(uint32 local);
75625:     JSValueType knownPushedType(uint32 pushed);
75677:     bool arrayPrototypeHasIndexedProperty();
75677:     bool mayPushUndefined(uint32 pushed);
75708:     types::TypeSet *argTypeSet(uint32 arg);
75708:     types::TypeSet *localTypeSet(uint32 local);
75851:     types::TypeSet *pushedTypeSet(uint32 which);
75708:     bool monitored(jsbytecode *pc);
75845:     bool testSingletonProperty(JSObject *obj, jsid id);
75871:     bool testSingletonPropertyTypes(FrameEntry *top, jsid id, bool *testObject);
75625: 
52560:     /* Non-emitting helpers. */
75708:     void pushSyncedEntry(uint32 pushed);
52560:     uint32 fullAtomIndex(jsbytecode *pc);
56766:     bool jumpInScript(Jump j, jsbytecode *pc);
52651:     bool compareTwoValues(JSContext *cx, JSOp op, const Value &lhs, const Value &rhs);
57718:     bool canUseApplyTricks();
52560: 
52645:     /* Emitting helpers. */
56766:     bool emitStubCmpOp(BoolStub stub, jsbytecode *target, JSOp fused);
61055:     bool iter(uintN flags);
52737:     void iterNext();
56766:     bool iterMore();
53404:     void iterEnd();
75630:     MaybeJump loadDouble(FrameEntry *fe, FPRegisterID *fpReg, bool *allocated);
55503: #ifdef JS_POLYIC
56738:     void passICAddress(BaseICInfo *ic);
55503: #endif
55503: #ifdef JS_MONOIC
62386:     void passMICAddress(GlobalNameICInfo &mic);
55503: #endif
56037:     bool constructThis();
75630:     void ensureDouble(FrameEntry *fe);
75630: 
75630:     /*
75630:      * Ensure fe is an integer, truncating from double if necessary, or jump to
75630:      * the slow path per uses.
75630:      */
75630:     void ensureInteger(FrameEntry *fe, Uses uses);
75630: 
75630:     /* Convert fe from a double to integer (per ValueToECMAInt32) in place. */
75630:     void truncateDoubleToInt32(FrameEntry *fe, Uses uses);
52645: 
52560:     /* Opcode handlers. */
75649:     bool jumpAndTrace(Jump j, jsbytecode *target, Jump *slow = NULL, bool *trampoline = NULL);
75649:     bool finishLoop(jsbytecode *head);
60526:     void jsop_bindname(JSAtom *atom, bool usePropCache);
52560:     void jsop_setglobal(uint32 index);
52560:     void jsop_getglobal(uint32 index);
56202:     void jsop_getprop_slow(JSAtom *atom, bool usePropCache = true);
56586:     void jsop_getarg(uint32 slot);
56586:     void jsop_setarg(uint32 slot, bool popped);
52741:     void jsop_this();
54832:     void emitReturn(FrameEntry *fe);
54832:     void emitFinalReturn(Assembler &masm);
55503:     void loadReturnValue(Assembler *masm, FrameEntry *fe);
55503:     void emitReturnValue(Assembler *masm, FrameEntry *fe);
75864:     void emitInlineReturnValue(FrameEntry *fe);
52847:     void dispatchCall(VoidPtrStubUInt32 stub, uint32 argc);
53223:     void interruptCheckHelper();
75869:     void recompileCheckHelper();
53590:     void emitUncachedCall(uint32 argc, bool callingNew);
57718:     void checkCallApplySpeculation(uint32 callImmArgc, uint32 speculatedArgc,
57718:                                    FrameEntry *origCallee, FrameEntry *origThis,
57713:                                    MaybeRegisterID origCalleeType, RegisterID origCalleeData,
57713:                                    MaybeRegisterID origThisType, RegisterID origThisData,
57713:                                    Jump *uncachedCallSlowRejoin, CallPatchInfo *uncachedCallPatch);
75776:     bool inlineCallHelper(uint32 argc, bool callingNew);
55503:     void fixPrimitiveReturn(Assembler *masm, FrameEntry *fe);
75872:     bool jsop_gnameinc(JSOp op, VoidStubAtom stub, uint32 index);
75872:     CompileStatus jsop_nameinc(JSOp op, VoidStubAtom stub, uint32 index);
75872:     CompileStatus jsop_propinc(JSOp op, VoidStubAtom stub, uint32 index);
52815:     void jsop_eleminc(JSOp op, VoidStub);
75790:     void jsop_getgname(uint32 index, JSValueType type);
52826:     void jsop_getgname_slow(uint32 index);
63236:     void jsop_callgname_epilogue();
60526:     void jsop_setgname(JSAtom *atom, bool usePropertyCache);
60526:     void jsop_setgname_slow(JSAtom *atom, bool usePropertyCache);
52826:     void jsop_bindgname();
52838:     void jsop_setelem_slow();
52843:     void jsop_getelem_slow();
57723:     void jsop_callelem_slow();
52874:     void jsop_unbrand();
75790:     bool jsop_getprop(JSAtom *atom, JSValueType type,
75708:                       bool typeCheck = true, bool usePropCache = true);
56037:     bool jsop_length();
56201:     bool jsop_setprop(JSAtom *atom, bool usePropCache = true);
56201:     void jsop_setprop_slow(JSAtom *atom, bool usePropCache = true);
52903:     bool jsop_callprop_slow(JSAtom *atom);
52903:     bool jsop_callprop(JSAtom *atom);
52903:     bool jsop_callprop_obj(JSAtom *atom);
52903:     bool jsop_callprop_str(JSAtom *atom);
52906:     bool jsop_callprop_generic(JSAtom *atom);
56037:     bool jsop_instanceof();
75790:     void jsop_name(JSAtom *atom, JSValueType type);
56037:     bool jsop_xname(JSAtom *atom);
54840:     void enterBlock(JSObject *obj);
54840:     void leaveBlock();
56775:     void emitEval(uint32 argc);
57718:     void jsop_arguments();
61233:     bool jsop_tableswitch(jsbytecode *pc);
60526:     void jsop_forprop(JSAtom *atom);
60526:     void jsop_forname(JSAtom *atom);
60526:     void jsop_forgname(JSAtom *atom);
52611: 
52963:     /* Fast arithmetic. */
75851:     bool jsop_binary(JSOp op, VoidStub stub, JSValueType type, types::TypeSet *typeSet);
75636:     void jsop_binary_full(FrameEntry *lhs, FrameEntry *rhs, JSOp op, VoidStub stub,
75636:                           JSValueType type);
75636:     void jsop_binary_full_simple(FrameEntry *fe, JSOp op, VoidStub stub,
75636:                                  JSValueType type);
75636:     void jsop_binary_double(FrameEntry *lhs, FrameEntry *rhs, JSOp op, VoidStub stub,
75636:                             JSValueType type);
52963:     void slowLoadConstantDouble(Assembler &masm, FrameEntry *fe,
52963:                                 FPRegisterID fpreg);
52963:     void maybeJumpIfNotInt32(Assembler &masm, MaybeJump &mj, FrameEntry *fe,
52963:                              MaybeRegisterID &mreg);
52963:     void maybeJumpIfNotDouble(Assembler &masm, MaybeJump &mj, FrameEntry *fe,
52963:                               MaybeRegisterID &mreg);
56766:     bool jsop_relational(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
56766:     bool jsop_relational_self(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
56766:     bool jsop_relational_full(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
56766:     bool jsop_relational_double(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
75649:     bool jsop_relational_int(JSOp op, jsbytecode *target, JSOp fused);
53201: 
53201:     void emitLeftDoublePath(FrameEntry *lhs, FrameEntry *rhs, FrameState::BinaryAlloc &regs,
53201:                             MaybeJump &lhsNotDouble, MaybeJump &rhsNotNumber,
53201:                             MaybeJump &lhsUnknownDone);
53201:     void emitRightDoublePath(FrameEntry *lhs, FrameEntry *rhs, FrameState::BinaryAlloc &regs,
53201:                              MaybeJump &rhsNotNumber2);
53318:     bool tryBinaryConstantFold(JSContext *cx, FrameState &frame, JSOp op,
75668:                                FrameEntry *lhs, FrameEntry *rhs, Value *vp);
52963: 
52617:     /* Fast opcodes. */
52617:     void jsop_bitop(JSOp op);
75668:     bool jsop_mod();
52713:     void jsop_neg();
52724:     void jsop_bitnot();
52734:     void jsop_not();
52738:     void jsop_typeof();
56766:     bool booleanJumpScript(JSOp op, jsbytecode *target);
56766:     bool jsop_ifneq(JSOp op, jsbytecode *target);
56766:     bool jsop_andor(JSOp op, jsbytecode *target);
75668:     bool jsop_arginc(JSOp op, uint32 slot, bool popped);
75668:     bool jsop_localinc(JSOp op, uint32 slot, bool popped);
75720:     bool jsop_newinit();
58056:     void jsop_initmethod();
58056:     void jsop_initprop();
58056:     void jsop_initelem();
75625:     void jsop_setelem_dense();
60164:     bool jsop_setelem(bool popGuaranteed);
57723:     bool jsop_getelem(bool isCall);
75625:     void jsop_getelem_dense(bool isPacked);
56775:     bool isCacheableBaseAndIndex(FrameEntry *obj, FrameEntry *id);
52855:     void jsop_stricteq(JSOp op);
56766:     bool jsop_equality(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
56766:     bool jsop_equality_int_string(JSOp op, BoolStub stub, jsbytecode *target, JSOp fused);
52916:     void jsop_pos();
52617: 
75833:     static inline Assembler::Condition
75833:     GetCompareCondition(JSOp op, JSOp fused)
75833:     {
75833:         bool ifeq = fused == JSOP_IFEQ;
75833:         switch (op) {
75833:           case JSOP_GT:
75833:             return ifeq ? Assembler::LessThanOrEqual : Assembler::GreaterThan;
75833:           case JSOP_GE:
75833:             return ifeq ? Assembler::LessThan : Assembler::GreaterThanOrEqual;
75833:           case JSOP_LT:
75833:             return ifeq ? Assembler::GreaterThanOrEqual : Assembler::LessThan;
75833:           case JSOP_LE:
75833:             return ifeq ? Assembler::GreaterThan : Assembler::LessThanOrEqual;
75833:           case JSOP_EQ:
75833:             return ifeq ? Assembler::NotEqual : Assembler::Equal;
75833:           case JSOP_NE:
75833:             return ifeq ? Assembler::Equal : Assembler::NotEqual;
75833:           default:
75833:             JS_NOT_REACHED("unrecognized op");
75833:             return Assembler::Equal;
75833:         }
75833:     }
52611: 
75845:     /* Fast builtins. */
75845:     JSObject *pushedSingleton(unsigned pushed);
75900:     CompileStatus callArrayBuiltin(uint32 argc, bool callingNew);
75845:     CompileStatus inlineNativeFunction(uint32 argc, bool callingNew);
75864:     CompileStatus inlineScriptedFunction(uint32 argc, bool callingNew);
75845:     CompileStatus compileMathAbsInt(FrameEntry *arg);
75845:     CompileStatus compileMathAbsDouble(FrameEntry *arg);
75845:     CompileStatus compileMathSqrt(FrameEntry *arg);
75845:     CompileStatus compileMathPowSimple(FrameEntry *arg1, FrameEntry *arg2);
75845: 
75845:     enum RoundingMode { Floor, Round };
75845:     CompileStatus compileRound(FrameEntry *arg, RoundingMode mode);
75845: 
75845:     enum GetCharMode { GetChar, GetCharCode };
75845:     CompileStatus compileGetChar(FrameEntry *thisValue, FrameEntry *arg, GetCharMode mode);
75845: 
57766:     void prepareStubCall(Uses uses);
75864:     Call emitStubCall(void *ptr, DataLabelPtr *pinline);
57766: };
52611: 
57766: // Given a stub call, emits the call into the inline assembly path. If
57766: // debug mode is on, adds the appropriate instrumentation for recompilation.
57766: #define INLINE_STUBCALL(stub)                                               \
57766:     do {                                                                    \
75636:         void *nstub = JS_FUNC_TO_DATA_PTR(void *, (stub));                  \
75864:         DataLabelPtr inlinePatch;                                           \
75864:         Call cl = emitStubCall(nstub, &inlinePatch);                        \
75864:         InternalCallSite site(masm.callReturnOffset(cl), a->inlineIndex, PC, (size_t)nstub, \
57766:                               true, false);                                 \
75864:         site.inlinePatch = inlinePatch;                                     \
57766:         addCallSite(site);                                                  \
57766:     } while (0)                                                             \
57766: 
57766: // Given a stub call, emits the call into the out-of-line assembly path. If
57766: // debug mode is on, adds the appropriate instrumentation for recompilation.
57766: // Unlike the INLINE_STUBCALL variant, this returns the Call offset.
57766: #define OOL_STUBCALL(stub)                                                  \
75636:     stubcc.emitStubCall(JS_FUNC_TO_DATA_PTR(void *, (stub)))
57766: 
57766: // Same as OOL_STUBCALL, but specifies a slot depth.
57787: #define OOL_STUBCALL_LOCAL_SLOTS(stub, slots)                               \
75636:     stubcc.emitStubCall(JS_FUNC_TO_DATA_PTR(void *, (stub)), (slots))       \
52558: 
52558: } /* namespace js */
52558: } /* namespace mjit */
52558: 
52558: #endif
52611: 
