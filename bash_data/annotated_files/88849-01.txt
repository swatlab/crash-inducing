32195: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
42402: /* ***** BEGIN LICENSE BLOCK *****
42402:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42402:  *
42402:  * The contents of this file are subject to the Mozilla Public License Version
42402:  * 1.1 (the "License"); you may not use this file except in compliance with
42402:  * the License. You may obtain a copy of the License at
42402:  * http://www.mozilla.org/MPL/
42402:  *
42402:  * Software distributed under the License is distributed on an "AS IS" basis,
42402:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42402:  * for the specific language governing rights and limitations under the
42402:  * License.
42402:  *
42402:  * The Original Code is mozilla.org code.
42402:  *
42402:  * The Initial Developer of the Original Code is
42402:  *   Mozilla Corporation.
42402:  * Portions created by the Initial Developer are Copyright (C) 2009
42402:  * the Initial Developer. All Rights Reserved.
42402:  *
42402:  * Contributor(s):
42402:  *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
42402:  *   Mark Steele <mwsteele@gmail.com>
42402:  *
42402:  * Alternatively, the contents of this file may be used under the terms of
42402:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42402:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42402:  * in which case the provisions of the GPL or the LGPL are applicable instead
42402:  * of those above. If you wish to allow use of your version of this file only
42402:  * under the terms of either the GPL or the LGPL, and not to allow others to
42402:  * use your version of this file under the terms of the MPL, indicate your
42402:  * decision by deleting the provisions above and replace them with the notice
42402:  * and other provisions required by the GPL or the LGPL. If you do not delete
42402:  * the provisions above, a recipient may use your version of this file under
42402:  * the terms of any one of the MPL, the GPL or the LGPL.
42402:  *
42402:  * ***** END LICENSE BLOCK ***** */
42402: 
32195: #include "WebGLContext.h"
79603: #include "WebGLExtensions.h"
32195: 
32195: #include "nsIConsoleService.h"
32195: #include "nsServiceManagerUtils.h"
32195: #include "nsIClassInfoImpl.h"
32195: #include "nsContentUtils.h"
34453: #include "nsIXPConnect.h"
32835: #include "nsDOMError.h"
54216: #include "nsIGfxInfo.h"
32195: 
57631: #include "nsIPropertyBag.h"
57631: #include "nsIVariant.h"
57631: 
57632: #include "imgIEncoder.h"
57632: 
32195: #include "gfxContext.h"
32195: #include "gfxPattern.h"
46990: #include "gfxUtils.h"
32195: 
34453: #include "CanvasUtils.h"
64542: #include "nsDisplayList.h"
34453: 
42402: #include "GLContextProvider.h"
42402: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
50430: #include "nsSVGEffects.h"
50430: 
49076: #include "prenv.h"
49076: 
73503: #include "mozilla/Preferences.h"
78509: #include "mozilla/Telemetry.h"
73503: 
32195: using namespace mozilla;
42403: using namespace mozilla::gl;
51950: using namespace mozilla::layers;
32195: 
73514: WebGLMemoryReporter* WebGLMemoryReporter::sUniqueInstance = nsnull;
73514: 
73514: NS_MEMORY_REPORTER_IMPLEMENT(WebGLTextureMemoryUsed,
73514:                              "webgl-texture-memory",
73514:                              KIND_OTHER,
73514:                              UNITS_BYTES,
73514:                              WebGLMemoryReporter::GetTextureMemoryUsed,
73516:                              "Memory used by WebGL textures. The OpenGL implementation is free to store these textures in either video memory or main memory. This measurement is only a lower bound, actual memory usage may be higher for example if the storage is strided.")
73514: 
73514: NS_MEMORY_REPORTER_IMPLEMENT(WebGLTextureCount,
73514:                              "webgl-texture-count",
73514:                              KIND_OTHER,
73514:                              UNITS_COUNT,
73514:                              WebGLMemoryReporter::GetTextureCount,
73514:                              "Number of WebGL textures.")
73514: 
73515: NS_MEMORY_REPORTER_IMPLEMENT(WebGLBufferMemoryUsed,
73515:                              "webgl-buffer-memory",
73515:                              KIND_OTHER,
73515:                              UNITS_BYTES,
73515:                              WebGLMemoryReporter::GetBufferMemoryUsed,
73516:                              "Memory used by WebGL buffers. The OpenGL implementation is free to store these buffers in either video memory or main memory. This measurement is only a lower bound, actual memory usage may be higher for example if the storage is strided.")
73515: 
73517: NS_MEMORY_REPORTER_IMPLEMENT(WebGLBufferCacheMemoryUsed,
74444:                              "explicit/webgl/buffer-cache-memory",
73517:                              KIND_HEAP,
73517:                              UNITS_BYTES,
73517:                              WebGLMemoryReporter::GetBufferCacheMemoryUsed,
73517:                              "Memory used by WebGL buffer caches. The WebGL implementation caches the contents of element array buffers only. This adds up with the webgl-buffer-memory value, but contrary to it, this one represents bytes on the heap, not managed by OpenGL.")
73517: 
73515: NS_MEMORY_REPORTER_IMPLEMENT(WebGLBufferCount,
73515:                              "webgl-buffer-count",
73515:                              KIND_OTHER,
73515:                              UNITS_COUNT,
73515:                              WebGLMemoryReporter::GetBufferCount,
73515:                              "Number of WebGL buffers.")
73515: 
73516: NS_MEMORY_REPORTER_IMPLEMENT(WebGLRenderbufferMemoryUsed,
73516:                              "webgl-renderbuffer-memory",
73516:                              KIND_OTHER,
73516:                              UNITS_BYTES,
73516:                              WebGLMemoryReporter::GetRenderbufferMemoryUsed,
73516:                              "Memory used by WebGL renderbuffers. The OpenGL implementation is free to store these renderbuffers in either video memory or main memory. This measurement is only a lower bound, actual memory usage may be higher for example if the storage is strided.")
73516: 
73516: NS_MEMORY_REPORTER_IMPLEMENT(WebGLRenderbufferCount,
73516:                              "webgl-renderbuffer-count",
73516:                              KIND_OTHER,
73516:                              UNITS_COUNT,
73516:                              WebGLMemoryReporter::GetRenderbufferCount,
73516:                              "Number of WebGL renderbuffers.")
73516: 
73518: NS_MEMORY_REPORTER_IMPLEMENT(WebGLShaderSourcesSize,
74444:                              "explicit/webgl/shader-sources-size",
73518:                              KIND_HEAP,
73518:                              UNITS_BYTES,
73518:                              WebGLMemoryReporter::GetShaderSourcesSize,
73518:                              "Combined size of WebGL shader ASCII sources, cached on the heap. This should always be at most a few kilobytes, or dozen kilobytes for very shader-intensive WebGL demos.")
73518: 
73518: NS_MEMORY_REPORTER_IMPLEMENT(WebGLShaderTranslationLogsSize,
74444:                              "explicit/webgl/shader-translationlogs-size",
73518:                              KIND_HEAP,
73518:                              UNITS_BYTES,
73518:                              WebGLMemoryReporter::GetShaderTranslationLogsSize,
73518:                              "Combined size of WebGL shader ASCII translation logs, cached on the heap.")
73518: 
73518: NS_MEMORY_REPORTER_IMPLEMENT(WebGLShaderCount,
73518:                              "webgl-shader-count",
73518:                              KIND_OTHER,
73518:                              UNITS_COUNT,
73518:                              WebGLMemoryReporter::GetShaderCount,
73518:                              "Number of WebGL shaders.")
73518: 
73514: NS_MEMORY_REPORTER_IMPLEMENT(WebGLContextCount,
73514:                              "webgl-context-count",
73514:                              KIND_OTHER,
73514:                              UNITS_COUNT,
73514:                              WebGLMemoryReporter::GetContextCount,
73514:                              "Number of WebGL contexts.")
73514: 
73514: WebGLMemoryReporter* WebGLMemoryReporter::UniqueInstance()
73514: {
73514:     if (!sUniqueInstance) {
73514:         sUniqueInstance = new WebGLMemoryReporter;
73514:     }
73514:     return sUniqueInstance;
73514: }
73514: 
73514: WebGLMemoryReporter::WebGLMemoryReporter()
73514:     : mTextureMemoryUsageReporter(new NS_MEMORY_REPORTER_NAME(WebGLTextureMemoryUsed))
73514:     , mTextureCountReporter(new NS_MEMORY_REPORTER_NAME(WebGLTextureCount))
73515:     , mBufferMemoryUsageReporter(new NS_MEMORY_REPORTER_NAME(WebGLBufferMemoryUsed))
73517:     , mBufferCacheMemoryUsageReporter(new NS_MEMORY_REPORTER_NAME(WebGLBufferCacheMemoryUsed))
73515:     , mBufferCountReporter(new NS_MEMORY_REPORTER_NAME(WebGLBufferCount))
73516:     , mRenderbufferMemoryUsageReporter(new NS_MEMORY_REPORTER_NAME(WebGLRenderbufferMemoryUsed))
73516:     , mRenderbufferCountReporter(new NS_MEMORY_REPORTER_NAME(WebGLRenderbufferCount))
73518:     , mShaderSourcesSizeReporter(new NS_MEMORY_REPORTER_NAME(WebGLShaderSourcesSize))
73518:     , mShaderTranslationLogsSizeReporter(new NS_MEMORY_REPORTER_NAME(WebGLShaderTranslationLogsSize))
73518:     , mShaderCountReporter(new NS_MEMORY_REPORTER_NAME(WebGLShaderCount))
73514:     , mContextCountReporter(new NS_MEMORY_REPORTER_NAME(WebGLContextCount))
73514: {
73514:     NS_RegisterMemoryReporter(mTextureMemoryUsageReporter);
73514:     NS_RegisterMemoryReporter(mTextureCountReporter);
73515:     NS_RegisterMemoryReporter(mBufferMemoryUsageReporter);
73517:     NS_RegisterMemoryReporter(mBufferCacheMemoryUsageReporter);    
73515:     NS_RegisterMemoryReporter(mBufferCountReporter);
73516:     NS_RegisterMemoryReporter(mRenderbufferMemoryUsageReporter);
73516:     NS_RegisterMemoryReporter(mRenderbufferCountReporter);
73518:     NS_RegisterMemoryReporter(mShaderSourcesSizeReporter);
73518:     NS_RegisterMemoryReporter(mShaderTranslationLogsSizeReporter);
73518:     NS_RegisterMemoryReporter(mShaderCountReporter);
73514:     NS_RegisterMemoryReporter(mContextCountReporter);
73514: }
73514: 
73514: WebGLMemoryReporter::~WebGLMemoryReporter()
73514: {
73514:     NS_UnregisterMemoryReporter(mTextureMemoryUsageReporter);
73514:     NS_UnregisterMemoryReporter(mTextureCountReporter);
73515:     NS_UnregisterMemoryReporter(mBufferMemoryUsageReporter);
73517:     NS_UnregisterMemoryReporter(mBufferCacheMemoryUsageReporter);
73515:     NS_UnregisterMemoryReporter(mBufferCountReporter);
73516:     NS_UnregisterMemoryReporter(mRenderbufferMemoryUsageReporter);
73516:     NS_UnregisterMemoryReporter(mRenderbufferCountReporter);
73518:     NS_UnregisterMemoryReporter(mShaderSourcesSizeReporter);
73518:     NS_UnregisterMemoryReporter(mShaderTranslationLogsSizeReporter);
73518:     NS_UnregisterMemoryReporter(mShaderCountReporter);
73514:     NS_UnregisterMemoryReporter(mContextCountReporter);
73514: }
73514: 
57635: nsresult NS_NewCanvasRenderingContextWebGL(nsIDOMWebGLRenderingContext** aResult);
32195: 
32195: nsresult
57635: NS_NewCanvasRenderingContextWebGL(nsIDOMWebGLRenderingContext** aResult)
32195: {
78509:     Telemetry::Accumulate(Telemetry::CANVAS_WEBGL_USED, 1);
57635:     nsIDOMWebGLRenderingContext* ctx = new WebGLContext();
32195:     if (!ctx)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     NS_ADDREF(*aResult = ctx);
32195:     return NS_OK;
32195: }
32195: 
32195: WebGLContext::WebGLContext()
42402:     : mCanvasElement(nsnull),
70164:       gl(nsnull)
32195: {
47653:     mGeneration = 0;
80486:     mInvalidated = false;
80486:     mResetLayer = true;
80486:     mVerbose = false;
80486:     mOptionsFrozen = false;
47653: 
47653:     mActiveTexture = 0;
73522:     mWebGLError = LOCAL_GL_NO_ERROR;
80486:     mPixelStoreFlipY = false;
80486:     mPixelStorePremultiplyAlpha = false;
58672:     mPixelStoreColorspaceConversion = BROWSER_DEFAULT_WEBGL;
47653: 
80486:     mShaderValidation = true;
47653: 
80486:     mBlackTexturesAreInitialized = false;
51422:     mFakeBlackStatus = DoNotNeedFakeBlack;
51898: 
51898:     mVertexAttrib0Vector[0] = 0;
51898:     mVertexAttrib0Vector[1] = 0;
51898:     mVertexAttrib0Vector[2] = 0;
51898:     mVertexAttrib0Vector[3] = 1;
63064:     mFakeVertexAttrib0BufferObjectVector[0] = 0;
63064:     mFakeVertexAttrib0BufferObjectVector[1] = 0;
63064:     mFakeVertexAttrib0BufferObjectVector[2] = 0;
63064:     mFakeVertexAttrib0BufferObjectVector[3] = 1;
63064:     mFakeVertexAttrib0BufferObjectSize = 0;
63064:     mFakeVertexAttrib0BufferObject = 0;
63064:     mFakeVertexAttrib0BufferStatus = VertexAttrib0Status::Default;
70166: 
70166:     // these are de default values, see 6.2 State tables in the OpenGL ES 2.0.25 spec
70166:     mColorWriteMask[0] = 1;
70166:     mColorWriteMask[1] = 1;
70166:     mColorWriteMask[2] = 1;
70166:     mColorWriteMask[3] = 1;
70166:     mDepthWriteMask = 1;
70166:     mColorClearValue[0] = 0.f;
70166:     mColorClearValue[1] = 0.f;
70166:     mColorClearValue[2] = 0.f;
70166:     mColorClearValue[3] = 0.f;
70166:     mDepthClearValue = 1.f;
70166:     mStencilClearValue = 0;
70170:     mStencilRefFront = 0;
70170:     mStencilRefBack = 0;
70170:     mStencilValueMaskFront = 0xffffffff;
70170:     mStencilValueMaskBack  = 0xffffffff;
70170:     mStencilWriteMaskFront = 0xffffffff;
70170:     mStencilWriteMaskBack  = 0xffffffff;
70170: 
70166:     mScissorTestEnabled = 0;
70166:     mDitherEnabled = 1;
70168:     mBackbufferClearingStatus = BackbufferClearingStatus::NotClearedSinceLastPresented;
72544:     
72544:     // initialize some GL values: we're going to get them from the GL and use them as the sizes of arrays,
72544:     // so in case glGetIntegerv leaves them uninitialized because of a GL bug, we would have very weird crashes.
72544:     mGLMaxVertexAttribs = 0;
72544:     mGLMaxTextureUnits = 0;
72544:     mGLMaxTextureSize = 0;
72544:     mGLMaxCubeMapTextureSize = 0;
72544:     mGLMaxTextureImageUnits = 0;
72544:     mGLMaxVertexTextureImageUnits = 0;
72544:     mGLMaxVaryingVectors = 0;
72544:     mGLMaxFragmentUniformVectors = 0;
72544:     mGLMaxVertexUniformVectors = 0;
72544:     
72544:     // See OpenGL ES 2.0.25 spec, 6.2 State Tables, table 6.13
72544:     mPixelStorePackAlignment = 4;
72544:     mPixelStoreUnpackAlignment = 4;
73514: 
73514:     WebGLMemoryReporter::AddWebGLContext(this);
80903: 
86626:     mAllowRestore = true;
82479:     mRobustnessTimerRunning = false;
82479:     mDrawSinceRobustnessTimerSet = false;
82479:     mContextRestorer = do_CreateInstance("@mozilla.org/timer;1");
86626:     mContextStatus = ContextStable;
86626:     mContextLostErrorSet = false;
86626:     mContextLostDueToTest = false;
32195: }
32195: 
32195: WebGLContext::~WebGLContext()
32195: {
47910:     DestroyResourcesAndContext();
73514:     WebGLMemoryReporter::RemoveWebGLContext(this);
82479:     TerminateRobustnessTimer();
82479:     mContextRestorer = nsnull;
47910: }
47910: 
47910: void
47910: WebGLContext::DestroyResourcesAndContext()
47910: {
47910:     if (!gl)
47910:         return;
47910: 
47910:     gl->MakeCurrent();
47910: 
83393:     mBound2DTextures.Clear();
83393:     mBoundCubeMapTextures.Clear();
83393:     mBoundArrayBuffer = nsnull;
83393:     mBoundElementArrayBuffer = nsnull;
83393:     mCurrentProgram = nsnull;
83393:     mBoundFramebuffer = nsnull;
83393:     mBoundRenderbuffer = nsnull;
47910: 
83393:     mAttribBuffers.Clear();
47910: 
83399:     while (mTextures.Length())
83399:         mTextures.Last()->DeleteOnce();
83400:     while (mBuffers.Length())
83400:         mBuffers.Last()->DeleteOnce();
83403:     while (mRenderbuffers.Length())
83403:         mRenderbuffers.Last()->DeleteOnce();
83404:     while (mFramebuffers.Length())
83404:         mFramebuffers.Last()->DeleteOnce();
83402:     while (mShaders.Length())
83402:         mShaders.Last()->DeleteOnce();
83401:     while (mPrograms.Length())
83401:         mPrograms.Last()->DeleteOnce();
83405:     while (mUniformLocations.Length())
83405:         mUniformLocations.Last()->DeleteOnce();
47910: 
51422:     if (mBlackTexturesAreInitialized) {
51422:         gl->fDeleteTextures(1, &mBlackTexture2D);
51422:         gl->fDeleteTextures(1, &mBlackTextureCubeMap);
80486:         mBlackTexturesAreInitialized = false;
51422:     }
51422: 
63064:     if (mFakeVertexAttrib0BufferObject) {
63064:         gl->fDeleteBuffers(1, &mFakeVertexAttrib0BufferObject);
63064:     }
63064: 
47910:     // We just got rid of everything, so the context had better
47910:     // have been going away.
53695: #ifdef DEBUG
47910:     printf_stderr("--- WebGL context destroyed: %p\n", gl.get());
53695: #endif
47910: 
47910:     gl = nsnull;
32195: }
32195: 
32195: void
32195: WebGLContext::Invalidate()
32195: {
64542:     if (mInvalidated)
64542:         return;
64542: 
32195:     if (!mCanvasElement)
32195:         return;
32195: 
50430:     nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
50430: 
80486:     mInvalidated = true;
64542:     HTMLCanvasElement()->InvalidateCanvasContent(nsnull);
39587: }
39587: 
43304: /* readonly attribute nsIDOMHTMLCanvasElement canvas; */
43304: NS_IMETHODIMP
43304: WebGLContext::GetCanvas(nsIDOMHTMLCanvasElement **canvas)
43304: {
43655:     NS_IF_ADDREF(*canvas = mCanvasElement);
43304: 
43304:     return NS_OK;
32195: }
32195: 
32195: //
32195: // nsICanvasRenderingContextInternal
32195: //
32195: 
32195: NS_IMETHODIMP
42402: WebGLContext::SetCanvasElement(nsHTMLCanvasElement* aParentCanvas)
32195: {
42402:     mCanvasElement = aParentCanvas;
32195: 
32195:     return NS_OK;
32195: }
32195: 
57631: static bool
57631: GetBoolFromPropertyBag(nsIPropertyBag *bag, const char *propName, bool *boolResult)
57631: {
57631:     nsCOMPtr<nsIVariant> vv;
79445:     bool bv;
57631: 
57631:     nsresult rv = bag->GetProperty(NS_ConvertASCIItoUTF16(propName), getter_AddRefs(vv));
57631:     if (NS_FAILED(rv) || !vv)
57631:         return false;
57631: 
57631:     rv = vv->GetAsBool(&bv);
57631:     if (NS_FAILED(rv))
57631:         return false;
57631: 
57631:     *boolResult = bv ? true : false;
57631:     return true;
57631: }
57631: 
57631: NS_IMETHODIMP
57631: WebGLContext::SetContextOptions(nsIPropertyBag *aOptions)
57631: {
57631:     if (!aOptions)
57631:         return NS_OK;
57631: 
57631:     WebGLContextOptions newOpts;
57631: 
70165:     GetBoolFromPropertyBag(aOptions, "stencil", &newOpts.stencil);
70165:     GetBoolFromPropertyBag(aOptions, "depth", &newOpts.depth);
70165:     GetBoolFromPropertyBag(aOptions, "alpha", &newOpts.alpha);
70165:     GetBoolFromPropertyBag(aOptions, "premultipliedAlpha", &newOpts.premultipliedAlpha);
70165:     GetBoolFromPropertyBag(aOptions, "antialias", &newOpts.antialias);
70165:     GetBoolFromPropertyBag(aOptions, "preserveDrawingBuffer", &newOpts.preserveDrawingBuffer);
57631: 
57631:     // enforce that if stencil is specified, we also give back depth
57631:     newOpts.depth |= newOpts.stencil;
57631: 
58583: #if 0
70165:     LogMessage("aaHint: %d stencil: %d depth: %d alpha: %d premult: %d preserve: %d\n",
70165:                newOpts.antialias ? 1 : 0,
57631:                newOpts.stencil ? 1 : 0,
57631:                newOpts.depth ? 1 : 0,
57631:                newOpts.alpha ? 1 : 0,
70165:                newOpts.premultipliedAlpha ? 1 : 0,
70165:                newOpts.preserveDrawingBuffer ? 1 : 0);
58583: #endif
57631: 
57631:     if (mOptionsFrozen && newOpts != mOptions) {
57631:         // Error if the options are already frozen, and the ones that were asked for
57631:         // aren't the same as what they were originally.
57631:         return NS_ERROR_FAILURE;
57631:     }
57631: 
57631:     mOptions = newOpts;
57631:     return NS_OK;
57631: }
57631: 
32195: NS_IMETHODIMP
32195: WebGLContext::SetDimensions(PRInt32 width, PRInt32 height)
32195: {
71572:     /*** early success return cases ***/
71572:   
64542:     if (mCanvasElement) {
64542:         HTMLCanvasElement()->InvalidateCanvas();
64542:     }
64542: 
69417:     if (gl && mWidth == width && mHeight == height)
47910:         return NS_OK;
47910: 
70071:     // Zero-sized surfaces can cause problems.
70071:     if (width == 0 || height == 0) {
70071:         width = 1;
70071:         height = 1;
70071:     }
70071: 
80612:     // If we already have a gl context, then we just need to resize it
80612:     if (gl) {
85066:         MakeContextCurrent();
85066: 
80612:         gl->ResizeOffscreen(gfxIntSize(width, height)); // Doesn't matter if it succeeds (soft-fail)
80612:         // It's unlikely that we'll get a proper-sized context if we recreate if we didn't on resize
80612: 
47910:         // everything's good, we're done here
80612:         mWidth = gl->OffscreenActualSize().width;
80612:         mHeight = gl->OffscreenActualSize().height;
80486:         mResetLayer = true;
85066: 
85066:         gl->ClearSafely();
85066: 
47910:         return NS_OK;
47910:     }
47910: 
71572:     /*** end of early success return cases ***/
71572: 
71572:     // At this point we know that the old context is not going to survive, even though we still don't
71572:     // know if creating the new context will succeed.
71572:     DestroyResourcesAndContext();
71572: 
71572:     // Get some prefs for some preferred/overriden things
73503:     NS_ENSURE_TRUE(Preferences::GetRootBranch(), NS_ERROR_FAILURE);
71572: 
79445:     bool forceOSMesa =
79445:         Preferences::GetBool("webgl.force_osmesa", false);
87420: #ifdef XP_WIN
79445:     bool preferEGL =
79445:         Preferences::GetBool("webgl.prefer-egl", false);
79445:     bool preferOpenGL =
79445:         Preferences::GetBool("webgl.prefer-native-gl", false);
84913: #endif
79445:     bool forceEnabled =
79445:         Preferences::GetBool("webgl.force-enabled", false);
79445:     bool disabled =
79445:         Preferences::GetBool("webgl.disabled", false);
79445:     bool verbose =
79445:         Preferences::GetBool("webgl.verbose", false);
71572: 
88849:     ScopedGfxFeatureReporter reporter("WebGL", forceEnabled);
88849: 
71572:     if (disabled)
71572:         return NS_ERROR_FAILURE;
71572: 
71572:     mVerbose = verbose;
71572: 
47910:     // We're going to create an entirely new context.  If our
47910:     // generation is not 0 right now (that is, if this isn't the first
47910:     // context we're creating), we may have to dispatch a context lost
47910:     // event.
47910: 
43099:     // If incrementing the generation would cause overflow,
43099:     // don't allow it.  Allowing this would allow us to use
43099:     // resource handles created from older context generations.
47204:     if (!(mGeneration+1).valid())
47204:         return NS_ERROR_FAILURE; // exit without changing the value of mGeneration
43099: 
47907:     gl::ContextFormat format(gl::ContextFormat::BasicRGBA32);
57631:     if (mOptions.depth) {
57631:         format.depth = 24;
57631:         format.minDepth = 16;
57631:     }
57631: 
57631:     if (mOptions.stencil) {
57631:         format.stencil = 8;
57631:         format.minStencil = 8;
57631:     }
57631: 
57631:     if (!mOptions.alpha) {
57631:         // Select 565; we won't/shouldn't hit this on the desktop,
57631:         // but let mobile know we're ok with it.
57631:         format.red = 5;
57631:         format.green = 6;
57631:         format.blue = 5;
57631: 
57631:         format.alpha = 0;
57631:         format.minAlpha = 0;
57631:     }
42403: 
81330:     bool forceMSAA =
81330:         Preferences::GetBool("webgl.msaa-force", false);
81330: 
81329:     PRInt32 status;
81329:     nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
81329:     if (mOptions.antialias &&
82628:         gfxInfo &&
81329:         NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_WEBGL_MSAA, &status))) {
81330:         if (status == nsIGfxInfo::FEATURE_NO_INFO || forceMSAA) {
80615:             PRUint32 msaaLevel = Preferences::GetUint("webgl.msaa-level", 2);
80615:             format.samples = msaaLevel*msaaLevel;
80615:         }
81329:     }
80615: 
87420: #ifdef XP_WIN
58583:     if (PR_GetEnv("MOZ_WEBGL_PREFER_EGL")) {
80486:         preferEGL = true;
58583:     }
87420: #endif
51417: 
55263:     // Ask GfxInfo about what we should use
79445:     bool useOpenGL = true;
87420: 
87420: #ifdef XP_WIN
79445:     bool useANGLE = true;
87420: #endif
54216: 
61566:     if (gfxInfo && !forceEnabled) {
54216:         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_WEBGL_OPENGL, &status))) {
61297:             if (status != nsIGfxInfo::FEATURE_NO_INFO) {
80486:                 useOpenGL = false;
54216:             }
54216:         }
87420: #ifdef XP_WIN
54216:         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_WEBGL_ANGLE, &status))) {
61297:             if (status != nsIGfxInfo::FEATURE_NO_INFO) {
80486:                 useANGLE = false;
54216:             }
54216:         }
87420: #endif
54216:     }
54216: 
87420: #ifdef XP_WIN
58583:     // allow forcing GL and not EGL/ANGLE
58583:     if (PR_GetEnv("MOZ_WEBGL_FORCE_OPENGL")) {
80486:         preferEGL = false;
80486:         useANGLE = false;
80486:         useOpenGL = true;
58583:     }
87420: #endif
58583: 
55263:     // if we're forcing osmesa, do it first
55263:     if (forceOSMesa) {
55263:         gl = gl::GLContextProviderOSMesa::CreateOffscreen(gfxIntSize(width, height), format);
55263:         if (!gl || !InitAndValidateGL()) {
56955:             LogMessage("OSMesa forced, but creating context failed -- aborting!");
55263:             return NS_ERROR_FAILURE;
55263:         }
56955:         LogMessage("Using software rendering via OSMesa (THIS WILL BE SLOW)");
55263:     }
55263: 
49076: #ifdef XP_WIN
58583:     // if we want EGL, try it now
58583:     if (!gl && (preferEGL || useANGLE) && !preferOpenGL) {
49076:         gl = gl::GLContextProviderEGL::CreateOffscreen(gfxIntSize(width, height), format);
84817:         if (gl) {
84817:             if (InitAndValidateGL()) {
84817:                 if (useANGLE) {
84817:                     gl->SetFlushGuaranteesResolve(true);
84817:                 }
84817:             } else {
87419:                 LogMessage("Error during ANGLE OpenGL ES initialization");
87419:                 return NS_ERROR_FAILURE;
49076:             }
49076:         }
84817:     }
87419: #endif
49076: 
87419:     // try the default provider, whatever that is
54216:     if (!gl && useOpenGL) {
47910:         gl = gl::GLContextProvider::CreateOffscreen(gfxIntSize(width, height), format);
49076:         if (gl && !InitAndValidateGL()) {
87419:             LogMessage("Error during OpenGL initialization");
87419:             return NS_ERROR_FAILURE;
49076:         }
49076:     }
49076: 
56957:     // finally, try OSMesa
56957:     if (!gl) {
56957:         gl = gl::GLContextProviderOSMesa::CreateOffscreen(gfxIntSize(width, height), format);
87419:         if (gl) {
87419:             if (!InitAndValidateGL()) {
87419:                 LogMessage("Error during OSMesa initialization");
87419:                 return NS_ERROR_FAILURE;
56957:             } else {
56957:                 LogMessage("Using software rendering via OSMesa (THIS WILL BE SLOW)");
56957:             }
56957:         }
87419:     }
56957: 
49076:     if (!gl) {
56955:         LogMessage("Can't get a usable WebGL context");
49076:         return NS_ERROR_FAILURE;
49076:     }
47910: 
53695: #ifdef DEBUG
47910:     printf_stderr ("--- WebGL context created: %p\n", gl.get());
53695: #endif
42402: 
39587:     mWidth = width;
39587:     mHeight = height;
80486:     mResetLayer = true;
80486:     mOptionsFrozen = true;
39587: 
82479:     mHasRobustness = gl->HasRobustness();
82479: 
43099:     // increment the generation number
47204:     ++mGeneration;
43099: 
47910: #if 0
47910:     if (mGeneration > 0) {
47910:         // XXX dispatch context lost event
47910:     }
47910: #endif
47910: 
43099:     MakeContextCurrent();
43099: 
39587:     // Make sure that we clear this out, otherwise
39587:     // we'll end up displaying random memory
47910:     gl->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, gl->GetOffscreenFBO());
85066: 
39587:     gl->fViewport(0, 0, mWidth, mHeight);
47910:     gl->fClearColor(0.0f, 0.0f, 0.0f, 0.0f);
48029:     gl->fClearDepth(1.0f);
47910:     gl->fClearStencil(0);
85066: 
85066:     gl->ClearSafely();
32195: 
63285:     reporter.SetSuccessful();
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::Render(gfxContext *ctx, gfxPattern::GraphicsFilter f)
32195: {
42402:     if (!gl)
32195:         return NS_OK;
32195: 
42402:     nsRefPtr<gfxImageSurface> surf = new gfxImageSurface(gfxIntSize(mWidth, mHeight),
42402:                                                          gfxASurface::ImageFormatARGB32);
42402:     if (surf->CairoStatus() != 0)
42402:         return NS_ERROR_FAILURE;
32195: 
55265:     gl->ReadPixelsIntoImageSurface(0, 0, mWidth, mHeight, surf);
42402:     gfxUtils::PremultiplyImageSurface(surf);
32195: 
42402:     nsRefPtr<gfxPattern> pat = new gfxPattern(surf);
42402:     pat->SetFilter(f);
32195: 
55265:     // Pixels from ReadPixels will be "upside down" compared to
55265:     // what cairo wants, so draw with a y-flip and a translte to
55265:     // flip them.
55265:     gfxMatrix m;
55265:     m.Translate(gfxPoint(0.0, mHeight));
55265:     m.Scale(1.0, -1.0);
55265:     pat->SetMatrix(m);
55265: 
32195:     ctx->NewPath();
32195:     ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);
32195:     ctx->Fill();
32195: 
42402:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::GetInputStream(const char* aMimeType,
32195:                              const PRUnichar* aEncoderOptions,
32195:                              nsIInputStream **aStream)
32195: {
57632:     NS_ASSERTION(gl, "GetInputStream on invalid context?");
57632:     if (!gl)
32195:         return NS_ERROR_FAILURE;
32195: 
57632:     nsRefPtr<gfxImageSurface> surf = new gfxImageSurface(gfxIntSize(mWidth, mHeight),
57632:                                                          gfxASurface::ImageFormatARGB32);
57632:     if (surf->CairoStatus() != 0)
32195:         return NS_ERROR_FAILURE;
32195: 
61665:     nsRefPtr<gfxContext> tmpcx = new gfxContext(surf);
61665:     // Use Render() to make sure that appropriate y-flip gets applied
61665:     nsresult rv = Render(tmpcx, gfxPattern::FILTER_NEAREST);
61665:     if (NS_FAILED(rv))
61665:         return rv;
57632: 
32195:     const char encoderPrefix[] = "@mozilla.org/image/encoder;2?type=";
57632:     nsAutoArrayPtr<char> conid(new char[strlen(encoderPrefix) + strlen(aMimeType) + 1]);
32195: 
32195:     if (!conid)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     strcpy(conid, encoderPrefix);
32195:     strcat(conid, aMimeType);
32195: 
32195:     nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(conid);
32195:     if (!encoder)
32195:         return NS_ERROR_FAILURE;
32195: 
57632:     rv = encoder->InitFromData(surf->Data(),
57632:                                mWidth * mHeight * 4,
57632:                                mWidth, mHeight,
57632:                                surf->Stride(),
32195:                                imgIEncoder::INPUT_FORMAT_HOSTARGB,
32195:                                nsDependentString(aEncoderOptions));
32195:     NS_ENSURE_SUCCESS(rv, rv);
32195: 
32195:     return CallQueryInterface(encoder, aStream);
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::GetThebesSurface(gfxASurface **surface)
32195: {
32195:     return NS_ERROR_NOT_AVAILABLE;
32195: }
32195: 
47731: static PRUint8 gWebGLLayerUserData;
47731: 
81126: namespace mozilla {
81126: 
64542: class WebGLContextUserData : public LayerUserData {
64542: public:
64542:     WebGLContextUserData(nsHTMLCanvasElement *aContent)
64542:     : mContent(aContent) {}
81126: 
81126:   /** DidTransactionCallback gets called by the Layers code everytime the WebGL canvas gets composite,
81126:     * so it really is the right place to put actions that have to be performed upon compositing
81126:     */
64542:   static void DidTransactionCallback(void* aData)
64542:   {
81126:     WebGLContextUserData *userdata = static_cast<WebGLContextUserData*>(aData);
81126:     nsHTMLCanvasElement *canvas = userdata->mContent;
81126:     WebGLContext *context = static_cast<WebGLContext*>(canvas->GetContextAtIndex(0));
81126: 
81126:     context->mBackbufferClearingStatus = BackbufferClearingStatus::NotClearedSinceLastPresented;
81126:     canvas->MarkContextClean();
64542:   }
64542: 
64542: private:
64542:   nsRefPtr<nsHTMLCanvasElement> mContent;
64542: };
64542: 
81126: } // end namespace mozilla
81126: 
42402: already_AddRefed<layers::CanvasLayer>
64542: WebGLContext::GetCanvasLayer(nsDisplayListBuilder* aBuilder,
64542:                              CanvasLayer *aOldLayer,
47731:                              LayerManager *aManager)
42402: {
86627:     if (!IsContextStable())
80903:         return nsnull;
80903: 
47731:     if (!mResetLayer && aOldLayer &&
51946:         aOldLayer->HasUserData(&gWebGLLayerUserData)) {
47731:         NS_ADDREF(aOldLayer);
47731:         return aOldLayer;
47731:     }
47731: 
47731:     nsRefPtr<CanvasLayer> canvasLayer = aManager->CreateCanvasLayer();
42402:     if (!canvasLayer) {
42402:         NS_WARNING("CreateCanvasLayer returned null!");
42402:         return nsnull;
32195:     }
64542:     WebGLContextUserData *userData = nsnull;
64542:     if (aBuilder->IsPaintingToWindow()) {
64542:       // Make the layer tell us whenever a transaction finishes (including
64542:       // the current transaction), so we can clear our invalidation state and
64542:       // start invalidating again. We need to do this for the layer that is
64542:       // being painted to a window (there shouldn't be more than one at a time,
64542:       // and if there is, flushing the invalidation state more often than
64542:       // necessary is harmless).
64542: 
64542:       // The layer will be destroyed when we tear down the presentation
64542:       // (at the latest), at which time this userData will be destroyed,
64542:       // releasing the reference to the element.
64542:       // The userData will receive DidTransactionCallbacks, which flush the
64542:       // the invalidation state to indicate that the canvas is up to date.
64542:       userData = new WebGLContextUserData(HTMLCanvasElement());
64542:       canvasLayer->SetDidTransactionCallback(
64542:               WebGLContextUserData::DidTransactionCallback, userData);
64542:     }
64542:     canvasLayer->SetUserData(&gWebGLLayerUserData, userData);
32195: 
42402:     CanvasLayer::Data data;
42402: 
42474:     // the gl context may either provide a native PBuffer, in which case we want to initialize
42474:     // data with the gl context directly, or may provide a surface to which it renders (this is the case
42474:     // of OSMesa contexts), in which case we want to initialize data with that surface.
42474: 
42474:     void* native_surface = gl->GetNativeData(gl::GLContext::NativeImageSurface);
42474: 
47910:     if (native_surface) {
47910:         data.mSurface = static_cast<gfxASurface*>(native_surface);
47910:     } else {
42402:         data.mGLContext = gl.get();
42474:     }
42474: 
42402:     data.mSize = nsIntSize(mWidth, mHeight);
80486:     data.mGLBufferIsPremultiplied = mOptions.premultipliedAlpha ? true : false;
42402: 
42402:     canvasLayer->Initialize(data);
51950:     PRUint32 flags = gl->CreationFormat().alpha == 0 ? Layer::CONTENT_OPAQUE : 0;
51950:     canvasLayer->SetContentFlags(flags);
64540:     canvasLayer->Updated();
42402: 
80486:     mResetLayer = false;
42402: 
42402:     return canvasLayer.forget().get();
39587: }
46955: 
57631: NS_IMETHODIMP
57631: WebGLContext::GetContextAttributes(jsval *aResult)
57631: {
86627:     if (!IsContextStable())
80903:     {
80903:         *aResult = OBJECT_TO_JSVAL(NULL);
80903:         return NS_OK;
80903:     }
80903: 
57631:     JSContext *cx = nsContentUtils::GetCurrentJSContext();
57631:     if (!cx)
57631:         return NS_ERROR_FAILURE;
57631: 
57631:     JSObject *obj = JS_NewObject(cx, NULL, NULL, NULL);
57631:     if (!obj)
57631:         return NS_ERROR_FAILURE;
57631: 
57631:     *aResult = OBJECT_TO_JSVAL(obj);
57631: 
57631:     gl::ContextFormat cf = gl->ActualFormat();
57631: 
57631:     if (!JS_DefineProperty(cx, obj, "alpha", cf.alpha > 0 ? JSVAL_TRUE : JSVAL_FALSE,
57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
57631:         !JS_DefineProperty(cx, obj, "depth", cf.depth > 0 ? JSVAL_TRUE : JSVAL_FALSE,
57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
57631:         !JS_DefineProperty(cx, obj, "stencil", cf.stencil > 0 ? JSVAL_TRUE : JSVAL_FALSE,
57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
80615:         !JS_DefineProperty(cx, obj, "antialias", cf.samples > 0 ? JSVAL_TRUE : JSVAL_FALSE,
57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
57631:         !JS_DefineProperty(cx, obj, "premultipliedAlpha",
57631:                            mOptions.premultipliedAlpha ? JSVAL_TRUE : JSVAL_FALSE,
70165:                            NULL, NULL, JSPROP_ENUMERATE) ||
70165:         !JS_DefineProperty(cx, obj, "preserveDrawingBuffer",
70165:                            mOptions.preserveDrawingBuffer ? JSVAL_TRUE : JSVAL_FALSE,
57631:                            NULL, NULL, JSPROP_ENUMERATE))
57631:     {
57631:         *aResult = JSVAL_VOID;
57631:         return NS_ERROR_FAILURE;
57631:     }
57631: 
57631:     return NS_OK;
57631: }
57631: 
59414: /* [noscript] DOMString mozGetUnderlyingParamString(in WebGLenum pname); */
59414: NS_IMETHODIMP
59414: WebGLContext::MozGetUnderlyingParamString(PRUint32 pname, nsAString& retval)
59414: {
86627:     if (!IsContextStable())
80903:         return NS_OK;
80903: 
80486:     retval.SetIsVoid(true);
59414: 
59414:     MakeContextCurrent();
59414: 
59414:     switch (pname) {
59414:     case LOCAL_GL_VENDOR:
59414:     case LOCAL_GL_RENDERER:
59414:     case LOCAL_GL_VERSION:
59414:     case LOCAL_GL_SHADING_LANGUAGE_VERSION:
59414:     case LOCAL_GL_EXTENSIONS: {
59414:         const char *s = (const char *) gl->fGetString(pname);
59414:         retval.Assign(NS_ConvertASCIItoUTF16(nsDependentCString(s)));
59414:     }
59414:         break;
59414: 
59414:     default:
59414:         return NS_ERROR_INVALID_ARG;
59414:     }
59414: 
59414:     return NS_OK;
59414: }
59414: 
76318: bool WebGLContext::IsExtensionSupported(WebGLExtensionID ei)
76318: {
79603:     bool isSupported;
79603: 
79603:     switch (ei) {
79603:         case WebGL_OES_texture_float:
76318:             MakeContextCurrent();
79603:             isSupported = gl->IsExtensionSupported(gl->IsGLES2() ? GLContext::OES_texture_float 
76318:                                                                  : GLContext::ARB_texture_float);
79603: 	    break;
79603:         case WebGL_OES_standard_derivatives:
79603:             // We always support this extension.
79603:             isSupported = true;
79603:             break;
86626:         case WebGL_MOZ_WEBGL_lose_context:
80903:             // We always support this extension.
80903:             isSupported = true;
80903:             break;
79603:         default:
79603:             isSupported = false;
76318:     }
79603: 
79603:     return isSupported;
76318: }
76318: 
70163: NS_IMETHODIMP
70163: WebGLContext::GetExtension(const nsAString& aName, nsIWebGLExtension **retval)
70163: {
70163:     *retval = nsnull;
86627:     if (!IsContextStable())
80903:         return NS_OK;
70163:     
80338:     if (mDisableExtensions) {
80338:         return NS_OK;
80338:     }
80338: 
70163:     // handle simple extensions that don't need custom objects first
70163:     WebGLExtensionID ei = WebGLExtensionID_Max;
70163:     if (aName.EqualsLiteral("OES_texture_float")) {
76318:         if (IsExtensionSupported(WebGL_OES_texture_float))
70163:             ei = WebGL_OES_texture_float;
70163:     }
79603:     else if (aName.EqualsLiteral("OES_standard_derivatives")) {
79603:         if (IsExtensionSupported(WebGL_OES_standard_derivatives))
79603:             ei = WebGL_OES_standard_derivatives;
79603:     }
86626:     else if (aName.EqualsLiteral("MOZ_WEBGL_lose_context")) {
86626:         if (IsExtensionSupported(WebGL_MOZ_WEBGL_lose_context))
86626:             ei = WebGL_MOZ_WEBGL_lose_context;
80903:     }
70163: 
70163:     if (ei != WebGLExtensionID_Max) {
70163:         if (!IsExtensionEnabled(ei)) {
79603:             switch (ei) {
79603:                 case WebGL_OES_standard_derivatives:
79603:                     mEnabledExtensions[ei] = new WebGLExtensionStandardDerivatives(this);
79603:                     break;
86626:                 case WebGL_MOZ_WEBGL_lose_context:
80903:                     mEnabledExtensions[ei] = new WebGLExtensionLoseContext(this);
80903:                     break;
79603:                 // create an extension for any types that don't
79603:                 // have any additional tokens or methods
79603:                 default:
70163:                     mEnabledExtensions[ei] = new WebGLExtension(this);
79603:                     break;
79603:             }
70163:         }
70163:         NS_ADDREF(*retval = mEnabledExtensions[ei]);
70163:     }
70163: 
70163:     return NS_OK;
70163: }
59414: 
70167: void
70167: WebGLContext::ForceClearFramebufferWithDefaultValues(PRUint32 mask, const nsIntRect& viewportRect)
70167: {
70167:     MakeContextCurrent();
70167: 
79445:     bool initializeColorBuffer = 0 != (mask & LOCAL_GL_COLOR_BUFFER_BIT);
79445:     bool initializeDepthBuffer = 0 != (mask & LOCAL_GL_DEPTH_BUFFER_BIT);
79445:     bool initializeStencilBuffer = 0 != (mask & LOCAL_GL_STENCIL_BUFFER_BIT);
70167: 
87421:     // fun GL fact: no need to worry about the viewport here, glViewport is just setting up a coordinates transformation,
87421:     // it doesn't affect glClear at all
87421: 
70167:     // prepare GL state for clearing
70167:     gl->fDisable(LOCAL_GL_SCISSOR_TEST);
70167:     gl->fDisable(LOCAL_GL_DITHER);
70167: 
70167:     if (initializeColorBuffer) {
70167:         gl->fColorMask(1, 1, 1, 1);
70167:         gl->fClearColor(0.f, 0.f, 0.f, 0.f);
70167:     }
70167: 
70167:     if (initializeDepthBuffer) {
70167:         gl->fDepthMask(1);
70167:         gl->fClearDepth(1.0f);
70167:     }
70167: 
70167:     if (initializeStencilBuffer) {
70167:         gl->fStencilMask(0xffffffff);
70167:         gl->fClearStencil(0);
70167:     }
70167: 
70167:     // do clear
70167:     gl->fClear(mask);
70167: 
70167:     // restore GL state after clearing
70167:     if (initializeColorBuffer) {
70167:         gl->fColorMask(mColorWriteMask[0],
70167:                        mColorWriteMask[1],
70167:                        mColorWriteMask[2],
70167:                        mColorWriteMask[3]);
70167:         gl->fClearColor(mColorClearValue[0],
70167:                         mColorClearValue[1],
70167:                         mColorClearValue[2],
70167:                         mColorClearValue[3]);
70167:     }
70167: 
70167:     if (initializeDepthBuffer) {
70167:         gl->fDepthMask(mDepthWriteMask);
70167:         gl->fClearDepth(mDepthClearValue);
70167:     }
70167: 
70167:     if (initializeStencilBuffer) {
70170:         gl->fStencilMaskSeparate(LOCAL_GL_FRONT, mStencilWriteMaskFront);
70170:         gl->fStencilMaskSeparate(LOCAL_GL_BACK, mStencilWriteMaskBack);
70167:         gl->fClearStencil(mStencilClearValue);
70167:     }
70167: 
70167:     if (mDitherEnabled)
70167:         gl->fEnable(LOCAL_GL_DITHER);
70167:     else
70167:         gl->fDisable(LOCAL_GL_DITHER);
70167: 
70167:     if (mScissorTestEnabled)
70167:         gl->fEnable(LOCAL_GL_SCISSOR_TEST);
70167:     else
70167:         gl->fDisable(LOCAL_GL_SCISSOR_TEST);
70167: }
70167: 
70168: void
70168: WebGLContext::EnsureBackbufferClearedAsNeeded()
70168: {
70168:     if (mOptions.preserveDrawingBuffer)
70168:         return;
70168: 
70168:     NS_ABORT_IF_FALSE(!mBoundFramebuffer,
70168:                       "EnsureBackbufferClearedAsNeeded must not be called when a FBO is bound");
70168: 
70168:     if (mBackbufferClearingStatus != BackbufferClearingStatus::NotClearedSinceLastPresented)
70168:         return;
70168: 
70168:     mBackbufferClearingStatus = BackbufferClearingStatus::ClearedToDefaultValues;
70168: 
70168:     ForceClearFramebufferWithDefaultValues(LOCAL_GL_COLOR_BUFFER_BIT |
70168:                                            LOCAL_GL_DEPTH_BUFFER_BIT |
70168:                                            LOCAL_GL_STENCIL_BUFFER_BIT,
70168:                                            nsIntRect(0, 0, mWidth, mHeight));
70168: 
70168:     Invalidate();
70168: }
70168: 
88091: nsresult
88091: WebGLContext::DummyFramebufferOperation(const char *info)
88091: {
88091:     WebGLenum status;
88091:     CheckFramebufferStatus(LOCAL_GL_FRAMEBUFFER, &status);
88091:     if (status == LOCAL_GL_FRAMEBUFFER_COMPLETE)
88091:         return NS_OK;
88091:     else
88091:         return ErrorInvalidFramebufferOperation("%s: incomplete framebuffer", info);
88091: }
88091: 
86626: // We use this timer for many things. Here are the things that it is activated for:
86626: // 1) If a script is using the MOZ_WEBGL_lose_context extension.
86626: // 2) If we are using EGL and _NOT ANGLE_, we query periodically to see if the
86626: //    CONTEXT_LOST_WEBGL error has been triggered.
86626: // 3) If we are using ANGLE, or anything that supports ARB_robustness, query the
86626: //    GPU periodically to see if the reset status bit has been set.
86626: // In all of these situations, we use this timer to send the script context lost
86626: // and restored events asynchronously. For example, if it triggers a context loss,
86626: // the webglcontextlost event will be sent to it the next time the robustness timer
86626: // fires.
86626: // Note that this timer mechanism is not used unless one of these 3 criteria
86626: // are met.
86626: // At a bare minimum, from context lost to context restores, it would take 3
86626: // full timer iterations: detection, webglcontextlost, webglcontextrestored.
80903: NS_IMETHODIMP
80903: WebGLContext::Notify(nsITimer* timer)
80903: {
82479:     TerminateRobustnessTimer();
86626:     // If the context has been lost and we're waiting for it to be restored, do
86626:     // that now.
86626:     if (mContextStatus == ContextLostAwaitingEvent) {
86626:         bool defaultAction;
86626:         nsContentUtils::DispatchTrustedEvent(HTMLCanvasElement()->OwnerDoc(),
86626:                                              (nsIDOMHTMLCanvasElement*) HTMLCanvasElement(),
86626:                                              NS_LITERAL_STRING("webglcontextlost"),
86626:                                              PR_TRUE,
86626:                                              PR_TRUE,
86626:                                              &defaultAction);
86626: 
86626:         // If the script didn't handle the event, we don't allow restores.
86626:         if (defaultAction)
86626:             mAllowRestore = false;
86626: 
86626:         // If the script handled the event and we are allowing restores, then
86626:         // mark it to be restored. Otherwise, leave it as context lost
86626:         // (unusable).
86626:         if (!defaultAction && mAllowRestore) {
86626:             ForceRestoreContext();
86626:             // Restart the timer so that it will be restored on the next
86626:             // callback.
86626:             SetupRobustnessTimer();
86626:         } else {
86626:             mContextStatus = ContextLost;
86626:         }
86626:     } else if (mContextStatus == ContextLostAwaitingRestore) {
86626:         // Try to restore the context. If it fails, try again later.
86626:         if (NS_FAILED(SetDimensions(mWidth, mHeight))) {
86626:             SetupRobustnessTimer();
86626:             return NS_OK;
86626:         }
86626:         mContextStatus = ContextStable;
86626:         nsContentUtils::DispatchTrustedEvent(HTMLCanvasElement()->OwnerDoc(),
86626:                                              (nsIDOMHTMLCanvasElement*) HTMLCanvasElement(),
86626:                                              NS_LITERAL_STRING("webglcontextrestored"),
86626:                                              PR_TRUE,
86626:                                              PR_TRUE);
86626:         // Set all flags back to the state they were in before the context was
86626:         // lost.
86626:         mContextLostErrorSet = false;
86626:         mContextLostDueToTest = false;
86626:         mAllowRestore = true;
86626:     }
86626: 
80903:     MaybeRestoreContext();
80903:     return NS_OK;
80903: }
80903: 
80903: void
80903: WebGLContext::MaybeRestoreContext()
80903: {
86626:     // Don't try to handle it if we already know it's busted.
86626:     if (mContextStatus != ContextStable || gl == nsnull)
80903:         return;
80903: 
84592:     bool isEGL = gl->GetContextType() == GLContext::ContextTypeEGL,
84592:          isANGLE = gl->IsANGLE();
84592: 
86626:     // If was lost due to a forced context loss, don't try to handle it.
86626:     // Also, we also don't try to handle if if we don't have robustness.
86626:     // Note that the code in this function is used only for situations where
86626:     // we have an actual context loss, and not a simulated one.
86626:     if (mContextLostDueToTest ||
86626:         (!mHasRobustness && !isEGL))
86626:         return;
86626: 
83211:     GLContext::ContextResetARB resetStatus = GLContext::CONTEXT_NO_ERROR;
83211:     if (mHasRobustness) {
82479:         gl->MakeCurrent();
83211:         resetStatus = (GLContext::ContextResetARB) gl->fGetGraphicsResetStatus();
84592:     } else if (isEGL) {
83211:         // Simulate a ARB_robustness guilty context loss for when we
83211:         // get an EGL_CONTEXT_LOST error. It may not actually be guilty,
83211:         // but we can't make any distinction, so we must assume the worst
83211:         // case.
83211:         if (!gl->MakeCurrent(true) && gl->IsContextLost()) {
83211:             resetStatus = GLContext::CONTEXT_GUILTY_CONTEXT_RESET_ARB;
83211:         }
83211:     }
80903:     
80903:     if (resetStatus != GLContext::CONTEXT_NO_ERROR) {
80903:         // It's already lost, but clean up after it and signal to JS that it is
80903:         // lost.
80903:         ForceLoseContext();
80903:     }
80903: 
80903:     switch (resetStatus) {
80903:         case GLContext::CONTEXT_NO_ERROR:
82479:             // If there has been activity since the timer was set, it's possible
82479:             // that we did or are going to miss something, so clear this flag and
82479:             // run it again some time later.
82479:             if (mDrawSinceRobustnessTimerSet)
82479:                 SetupRobustnessTimer();
86626:             break;
80903:         case GLContext::CONTEXT_GUILTY_CONTEXT_RESET_ARB:
80903:             NS_WARNING("WebGL content on the page caused the graphics card to reset; not restoring the context");
86626:             mAllowRestore = false;
86626:             break;
80903:         case GLContext::CONTEXT_INNOCENT_CONTEXT_RESET_ARB:
80903:             break;
80903:         case GLContext::CONTEXT_UNKNOWN_CONTEXT_RESET_ARB:
80903:             NS_WARNING("WebGL content on the page might have caused the graphics card to reset");
84592:             if (isEGL && isANGLE) {
84592:                 // If we're using ANGLE, we ONLY get back UNKNOWN context resets, including for guilty contexts.
84592:                 // This means that we can't restore it or risk restoring a guilty context. Should this ever change,
84592:                 // we can get rid of the whole IsANGLE() junk from GLContext.h since, as of writing, this is the
84592:                 // only use for it. See ANGLE issue 261.
86626:                 mAllowRestore = false;
84592:             }
80903:             break;
80903:     }
80903: }
80903: 
80903: void
80903: WebGLContext::ForceLoseContext()
80903: {
86626:     mContextStatus = ContextLostAwaitingEvent;
86626:     // Queue up a task to restore the event.
86626:     SetupRobustnessTimer();
80903:     DestroyResourcesAndContext();
80903: }
80903: 
80903: void
80903: WebGLContext::ForceRestoreContext()
80903: {
86626:     mContextStatus = ContextLostAwaitingRestore;
80903: }
80903: 
32195: //
32195: // XPCOM goop
32195: //
32195: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(WebGLContext)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(WebGLContext)
32195: 
43655: NS_IMPL_CYCLE_COLLECTION_CLASS(WebGLContext)
43655: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(WebGLContext)
43655:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCanvasElement)
43655: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(WebGLContext)
43655:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCanvasElement)
43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
39587: 
59162: DOMCI_DATA(WebGLRenderingContext, WebGLContext)
40490: 
43655: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(WebGLContext)
57635:   NS_INTERFACE_MAP_ENTRY(nsIDOMWebGLRenderingContext)
32195:   NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextInternal)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
80903:   NS_INTERFACE_MAP_ENTRY(nsITimerCallback)
57635:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMWebGLRenderingContext)
59162:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLRenderingContext)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLBuffer)
32195: NS_IMPL_RELEASE(WebGLBuffer)
32195: 
40490: DOMCI_DATA(WebGLBuffer, WebGLBuffer)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLBuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLBuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLBuffer)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLTexture)
32195: NS_IMPL_RELEASE(WebGLTexture)
32195: 
40490: DOMCI_DATA(WebGLTexture, WebGLTexture)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLTexture)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLTexture)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLTexture)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLProgram)
32195: NS_IMPL_RELEASE(WebGLProgram)
32195: 
40490: DOMCI_DATA(WebGLProgram, WebGLProgram)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLProgram)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLProgram)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLProgram)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLShader)
32195: NS_IMPL_RELEASE(WebGLShader)
32195: 
40490: DOMCI_DATA(WebGLShader, WebGLShader)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLShader)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLShader)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLShader)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLFramebuffer)
32195: NS_IMPL_RELEASE(WebGLFramebuffer)
32195: 
40490: DOMCI_DATA(WebGLFramebuffer, WebGLFramebuffer)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLFramebuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLFramebuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLFramebuffer)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLRenderbuffer)
32195: NS_IMPL_RELEASE(WebGLRenderbuffer)
32195: 
40490: DOMCI_DATA(WebGLRenderbuffer, WebGLRenderbuffer)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLRenderbuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLRenderbuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLRenderbuffer)
32195: NS_INTERFACE_MAP_END
32195: 
43010: NS_IMPL_ADDREF(WebGLUniformLocation)
43010: NS_IMPL_RELEASE(WebGLUniformLocation)
43010: 
43010: DOMCI_DATA(WebGLUniformLocation, WebGLUniformLocation)
43010: 
43010: NS_INTERFACE_MAP_BEGIN(WebGLUniformLocation)
43010:   NS_INTERFACE_MAP_ENTRY(nsIWebGLUniformLocation)
43010:   NS_INTERFACE_MAP_ENTRY(nsISupports)
43010:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLUniformLocation)
43010: NS_INTERFACE_MAP_END
43010: 
84804: NS_IMPL_ADDREF(WebGLShaderPrecisionFormat)
84804: NS_IMPL_RELEASE(WebGLShaderPrecisionFormat)
84804: 
84804: DOMCI_DATA(WebGLShaderPrecisionFormat, WebGLShaderPrecisionFormat)
84804: 
84804: NS_INTERFACE_MAP_BEGIN(WebGLShaderPrecisionFormat)
84804:   NS_INTERFACE_MAP_ENTRY(nsIWebGLShaderPrecisionFormat)
84804:   NS_INTERFACE_MAP_ENTRY(nsISupports)
84804:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLShaderPrecisionFormat)
84804: NS_INTERFACE_MAP_END
84804: 
51421: NS_IMPL_ADDREF(WebGLActiveInfo)
51421: NS_IMPL_RELEASE(WebGLActiveInfo)
51421: 
51421: DOMCI_DATA(WebGLActiveInfo, WebGLActiveInfo)
51421: 
51421: NS_INTERFACE_MAP_BEGIN(WebGLActiveInfo)
51421:   NS_INTERFACE_MAP_ENTRY(nsIWebGLActiveInfo)
51421:   NS_INTERFACE_MAP_ENTRY(nsISupports)
51421:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLActiveInfo)
51421: NS_INTERFACE_MAP_END
51421: 
42916: #define NAME_NOT_SUPPORTED(base) \
42916: NS_IMETHODIMP base::GetName(WebGLuint *aName) \
42916: { return NS_ERROR_NOT_IMPLEMENTED; } \
42916: NS_IMETHODIMP base::SetName(WebGLuint aName) \
42916: { return NS_ERROR_NOT_IMPLEMENTED; }
39587: 
42916: NAME_NOT_SUPPORTED(WebGLTexture)
42916: NAME_NOT_SUPPORTED(WebGLBuffer)
42916: NAME_NOT_SUPPORTED(WebGLProgram)
42916: NAME_NOT_SUPPORTED(WebGLShader)
42916: NAME_NOT_SUPPORTED(WebGLFramebuffer)
42916: NAME_NOT_SUPPORTED(WebGLRenderbuffer)
43010: 
70163: NS_IMPL_ADDREF(WebGLExtension)
70163: NS_IMPL_RELEASE(WebGLExtension)
70163: 
70163: DOMCI_DATA(WebGLExtension, WebGLExtension)
70163: 
70163: NS_INTERFACE_MAP_BEGIN(WebGLExtension)
70163:   NS_INTERFACE_MAP_ENTRY(nsIWebGLExtension)
70163:   NS_INTERFACE_MAP_ENTRY(nsISupports)
70163:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLExtension)
70163: NS_INTERFACE_MAP_END
70163: 
79603: NS_IMPL_ADDREF(WebGLExtensionStandardDerivatives)
79603: NS_IMPL_RELEASE(WebGLExtensionStandardDerivatives)
79603: 
79603: DOMCI_DATA(WebGLExtensionStandardDerivatives, WebGLExtensionStandardDerivatives)
79603: 
79603: NS_INTERFACE_MAP_BEGIN(WebGLExtensionStandardDerivatives)
79603:   NS_INTERFACE_MAP_ENTRY(nsIWebGLExtensionStandardDerivatives)
79603:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, WebGLExtension)
79603:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLExtensionStandardDerivatives)
79603: NS_INTERFACE_MAP_END_INHERITING(WebGLExtension)
79603: 
80903: NS_IMPL_ADDREF(WebGLExtensionLoseContext)
80903: NS_IMPL_RELEASE(WebGLExtensionLoseContext)
80903: 
80903: DOMCI_DATA(WebGLExtensionLoseContext, WebGLExtensionLoseContext)
80903: 
80903: NS_INTERFACE_MAP_BEGIN(WebGLExtensionLoseContext)
80903:   NS_INTERFACE_MAP_ENTRY(nsIWebGLExtensionLoseContext)
80903:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, WebGLExtension)
80903:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLExtensionLoseContext)
80903: NS_INTERFACE_MAP_END_INHERITING(WebGLExtension)
80903: 
77719: /* readonly attribute WebGLsizei drawingBufferWidth; */
77719: NS_IMETHODIMP
77719: WebGLContext::GetDrawingBufferWidth(WebGLsizei *aWidth)
77719: {
86627:     if (!IsContextStable())
80903:         return NS_OK;
80903: 
77719:     *aWidth = mWidth;
77719:     return NS_OK;
77719: }
77719: 
77719: /* readonly attribute WebGLsizei drawingBufferHeight; */
77719: NS_IMETHODIMP
77719: WebGLContext::GetDrawingBufferHeight(WebGLsizei *aHeight)
77719: {
86627:     if (!IsContextStable())
80903:         return NS_OK;
80903: 
77719:     *aHeight = mHeight;
77719:     return NS_OK;
77719: }
77719: 
43010: /* [noscript] attribute WebGLint location; */
59414: NS_IMETHODIMP
59414: WebGLUniformLocation::GetLocation(WebGLint *aLocation)
32195: {
32195:     return NS_ERROR_NOT_IMPLEMENTED;
32195: }
59414: 
59414: NS_IMETHODIMP
59414: WebGLUniformLocation::SetLocation(WebGLint aLocation)
32195: {
32195:     return NS_ERROR_NOT_IMPLEMENTED;
32195: }
51421: 
51421: /* readonly attribute WebGLint size; */
59414: NS_IMETHODIMP
59414: WebGLActiveInfo::GetSize(WebGLint *aSize)
51421: {
51421:     *aSize = mSize;
51421:     return NS_OK;
51421: }
51421: 
51421: /* readonly attribute WebGLenum type; */
59414: NS_IMETHODIMP
59414: WebGLActiveInfo::GetType(WebGLenum *aType)
51421: {
51421:     *aType = mType;
51421:     return NS_OK;
51421: }
51421: 
51421: /* readonly attribute DOMString name; */
59414: NS_IMETHODIMP
59414: WebGLActiveInfo::GetName(nsAString & aName)
51421: {
51421:     aName = mName;
51421:     return NS_OK;
51421: }
63219: 
84804: /* readonly attribute WebGLint rangeMin */
84804: NS_IMETHODIMP
84804: WebGLShaderPrecisionFormat::GetRangeMin(WebGLint *aRangeMin)
84804: {
84804:     *aRangeMin = mRangeMin;
84804:     return NS_OK;
84804: }
84804: 
84804: /* readonly attribute WebGLint rangeMax */
84804: NS_IMETHODIMP
84804: WebGLShaderPrecisionFormat::GetRangeMax(WebGLint *aRangeMax)
84804: {
84804:     *aRangeMax = mRangeMax;
84804:     return NS_OK;
84804: }
84804: 
84804: /* readonly attribute WebGLint precision */
84804: NS_IMETHODIMP
84804: WebGLShaderPrecisionFormat::GetPrecision(WebGLint *aPrecision)
84804: {
84804:     *aPrecision = mPrecision;
84804:     return NS_OK;
84804: }
84804: 
63219: NS_IMETHODIMP
63219: WebGLContext::GetSupportedExtensions(nsIVariant **retval)
63219: {
80338:     *retval = nsnull;
86627:     if (!IsContextStable())
80903:         return NS_OK;
80338:     
80338:     if (mDisableExtensions) {
80338:         return NS_OK;
80338:     }
80338:     
63219:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
63219:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
63219: 
63219:     nsTArray<const char *> extList;
63219: 
76318:     if (IsExtensionSupported(WebGL_OES_texture_float))
76318:         extList.InsertElementAt(extList.Length(), "OES_texture_float");
79603:     if (IsExtensionSupported(WebGL_OES_standard_derivatives))
79603:         extList.InsertElementAt(extList.Length(), "OES_standard_derivatives");
86626:     if (IsExtensionSupported(WebGL_MOZ_WEBGL_lose_context))
86626:         extList.InsertElementAt(extList.Length(), "MOZ_WEBGL_lose_context");
63219: 
63219:     nsresult rv;
63219:     if (extList.Length() > 0) {
63219:         rv = wrval->SetAsArray(nsIDataType::VTYPE_CHAR_STR, nsnull,
63219:                                extList.Length(), &extList[0]);
63219:     } else {
63219:         rv = wrval->SetAsEmptyArray();
63219:     }
63219:     if (NS_FAILED(rv))
63219:         return rv;
63219: 
63219:     *retval = wrval.forget().get();
63219:     return NS_OK;
63219: }
63219: 
63219: NS_IMETHODIMP
63221: WebGLContext::IsContextLost(WebGLboolean *retval)
63221: {
86626:     *retval = mContextStatus != ContextStable;
63221:     return NS_OK;
63221: }
63221: 
86626: // Internalized version of IsContextLost.
86626: bool
86626: WebGLContext::IsContextStable()
86626: {
86626:     return mContextStatus == ContextStable;
86626: }
