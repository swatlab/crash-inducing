 43788: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 43788: 
 43788: /**
 43788:  * A class which manages pending restyles.  This handles keeping track
 43788:  * of what nodes restyles need to happen on and so forth.
 43788:  */
 43788: 
 43819: #ifndef mozilla_css_RestyleTracker_h
 43819: #define mozilla_css_RestyleTracker_h
 43819: 
 43788: #include "mozilla/dom/Element.h"
 43788: #include "nsDataHashtable.h"
 43792: #include "nsIFrame.h"
125313: #include "nsTPriorityQueue.h"
129637: #include "mozilla/SplayTree.h"
 43788: 
 43788: class nsCSSFrameConstructor;
 43788: 
 43788: namespace mozilla {
 43788: namespace css {
 43788: 
125313: /** 
125313:  * Helper class that collects a list of frames that need
125313:  * UpdateOverflow() called on them, and coalesces them
125313:  * to avoid walking up the same ancestor tree multiple times.
125313:  */
125313: class OverflowChangedTracker
125313: {
125313: public:
125313: 
125313:   /**
125313:    * Add a frame that has had a style change, and needs its
125313:    * overflow updated.
125313:    *
125313:    * If there are pre-transform overflow areas stored for this
125313:    * frame, then we will call FinishAndStoreOverflow with those
125313:    * areas instead of UpdateOverflow().
125313:    *
125313:    * If the overflow area changes, then UpdateOverflow will also
125313:    * be called on the parent.
125313:    */
125313:   void AddFrame(nsIFrame* aFrame) {
129637:     if (!mEntryList.contains(Entry(aFrame, true))) {
129637:       mEntryList.insert(new Entry(aFrame, true));
129637:     }
129637:   }
129637: 
129637:   /**
129637:    * Remove a frame and all descendants of that frame.
129637:    */
129637:   void RemoveFrameAndDescendants(nsIFrame* aFrame) {
129637:     if (mEntryList.contains(Entry(aFrame, 0, false))) {
129637:       delete mEntryList.remove(Entry(aFrame, 0, false));
129637:     }
129637:     if (mEntryList.empty()) {
129637:       return;
129637:     }
129637: 
129637:     nsAutoTArray<nsIFrame::ChildList,4> childListArray;
129637:     aFrame->GetCrossDocChildLists(&childListArray);
129637: 
129637:     nsIFrame::ChildListArrayIterator lists(childListArray);
129637:     for (; !lists.IsDone(); lists.Next()) {
129637:       nsFrameList::Enumerator childFrames(lists.CurrentList());
129637:       for (; !childFrames.AtEnd(); childFrames.Next()) {
129637:         RemoveFrameAndDescendants(childFrames.get());
129637:         if (mEntryList.empty()) {
129637:           return;
129637:         }
129637:       }
129637:     }
125313:   }
125313: 
125313:   /**
125313:    * Update the overflow of all added frames, and clear the entry list.
125313:    *
125313:    * Start from those deepest in the frame tree and works upwards. This stops 
125313:    * us from processing the same frame twice.
125313:    */
125313:   void Flush() {
129637:     while (!mEntryList.empty()) {
129637:       Entry *entry = mEntryList.removeMin();
125313: 
129637:       nsIFrame *frame = entry->mFrame;
125313: 
125313:       bool updateParent = false;
129637:       if (entry->mInitial) {
125313:         nsOverflowAreas* pre = static_cast<nsOverflowAreas*>
125313:           (frame->Properties().Get(frame->PreTransformOverflowAreasProperty()));
125313:         if (pre) {
125313:           // FinishAndStoreOverflow will change the overflow areas passed in,
125313:           // so make a copy.
125313:           nsOverflowAreas overflowAreas = *pre;
125313:           frame->FinishAndStoreOverflow(overflowAreas, frame->GetSize());
125313:           // We can't tell if the overflow changed, so update the parent regardless
125313:           updateParent = true;
125313:         }
125313:       }
125313: 
125313:       // If the overflow changed, then we want to also update the parent's
125313:       // overflow. We always update the parent for initial frames.
125313:       if (!updateParent) {
129637:         updateParent = frame->UpdateOverflow() || entry->mInitial;
125313:       }
125313:       if (updateParent) {
125313:         nsIFrame *parent = frame->GetParent();
125313:         if (parent) {
129637:           if (!mEntryList.contains(Entry(parent, entry->mDepth - 1, false))) {
129637:             mEntryList.insert(new Entry(parent, entry->mDepth - 1, false));
125313:           }
125313:         }
125313:       }
129637:       delete entry;
129637:     }
125313:   }
125313:   
125313: private:
129637:   struct Entry : SplayTreeNode<Entry>
125313:   {
125313:     Entry(nsIFrame* aFrame, bool aInitial)
125313:       : mFrame(aFrame)
125313:       , mDepth(aFrame->GetDepthInFrameTree())
125313:       , mInitial(aInitial)
125313:     {}
125313:     
125313:     Entry(nsIFrame* aFrame, uint32_t aDepth, bool aInitial)
125313:       : mFrame(aFrame)
125313:       , mDepth(aDepth)
125313:       , mInitial(aInitial)
125313:     {}
125313: 
125313:     bool operator==(const Entry& aOther) const
125313:     {
125313:       return mFrame == aOther.mFrame;
125313:     }
125313:  
125313:     /**
125313:      * Sort by the depth in the frame tree, and then
125313:      * the frame pointer.
125313:      */
125313:     bool operator<(const Entry& aOther) const
125313:     {
125313:       if (mDepth != aOther.mDepth) {
125313:         // nsTPriorityQueue implements a min-heap and we
125313:         // want the highest depth first, so reverse this check.
125313:         return mDepth > aOther.mDepth;
125313:       }
125313: 
125313:       return mFrame < aOther.mFrame;
125313:     }
125313: 
129637:     static int compare(const Entry& aOne, const Entry& aTwo)
129637:     {
129637:       if (aOne < aTwo) {
129637:         return -1;
129637:       } else if (aOne == aTwo) {
129637:         return 0;
129637:       } else {
129637:         return 1;
129637:       }
129637:     }
129637: 
125313:     nsIFrame* mFrame;
125313:     /* Depth in the frame tree */
125313:     uint32_t mDepth;
125313:     /**
125313:      * True if the frame had the actual style change, and we
125313:      * want to check for pre-transform overflow areas.
125313:      */
125313:     bool mInitial;
125313:   };
125313: 
125313:   /* A list of frames to process, sorted by their depth in the frame tree */
129637:   SplayTree<Entry, Entry> mEntryList;
125313: };
125313: 
 43788: class RestyleTracker {
 43788: public:
 43788:   typedef mozilla::dom::Element Element;
 43788: 
108991:   RestyleTracker(uint32_t aRestyleBits,
 43788:                  nsCSSFrameConstructor* aFrameConstructor) :
 43792:     mRestyleBits(aRestyleBits), mFrameConstructor(aFrameConstructor),
 80486:     mHaveLaterSiblingRestyles(false)
 43788:   {
 43788:     NS_PRECONDITION((mRestyleBits & ~ELEMENT_ALL_RESTYLE_FLAGS) == 0,
 43788:                     "Why do we have these bits set?");
 43788:     NS_PRECONDITION((mRestyleBits & ELEMENT_PENDING_RESTYLE_FLAGS) != 0,
 43788:                     "Must have a restyle flag");
 43788:     NS_PRECONDITION((mRestyleBits & ELEMENT_PENDING_RESTYLE_FLAGS) !=
 43788:                       ELEMENT_PENDING_RESTYLE_FLAGS,
 43788:                     "Shouldn't have both restyle flags set");
 43788:     NS_PRECONDITION((mRestyleBits & ~ELEMENT_PENDING_RESTYLE_FLAGS) != 0,
 43788:                     "Must have root flag");
 43788:     NS_PRECONDITION((mRestyleBits & ~ELEMENT_PENDING_RESTYLE_FLAGS) !=
 43788:                     (ELEMENT_ALL_RESTYLE_FLAGS & ~ELEMENT_PENDING_RESTYLE_FLAGS),
 43788:                     "Shouldn't have both root flags");
 43788:   }
 43788: 
 98908:   void Init() {
 98908:     mPendingRestyles.Init();
 43788:   }
 43788: 
108991:   uint32_t Count() const {
 43788:     return mPendingRestyles.Count();
 43788:   }
 43788: 
 43788:   /**
 43792:    * Add a restyle for the given element to the tracker.  Returns true
 43792:    * if the element already had eRestyle_LaterSiblings set on it.
 43788:    */
 79445:   bool AddPendingRestyle(Element* aElement, nsRestyleHint aRestyleHint,
 43792:                            nsChangeHint aMinChangeHint);
 43788: 
 43788:   /**
 43788:    * Process the restyles we've been tracking.
 43788:    */
 84595:   void ProcessRestyles() {
 84595:     // Fast-path the common case (esp. for the animation restyle
 84595:     // tracker) of not having anything to do.
 84595:     if (mPendingRestyles.Count()) {
 84595:       DoProcessRestyles();
 84595:     }
 84595:   }
 43788: 
 43792:   // Return our ELEMENT_HAS_PENDING_(ANIMATION_)RESTYLE bit
108991:   uint32_t RestyleBit() const {
 43792:     return mRestyleBits & ELEMENT_PENDING_RESTYLE_FLAGS;
 43792:   }
 43792: 
 43792:   // Return our ELEMENT_IS_POTENTIAL_(ANIMATION_)RESTYLE_ROOT bit
108991:   uint32_t RootBit() const {
 43792:     return mRestyleBits & ~ELEMENT_PENDING_RESTYLE_FLAGS;
 43792:   }
 43792:   
 43788:   struct RestyleData {
 43788:     nsRestyleHint mRestyleHint;  // What we want to restyle
 43788:     nsChangeHint  mChangeHint;   // The minimal change hint for "self"
 43788:   };
 43788: 
 43792:   /**
 43792:    * If the given Element has a restyle pending for it, return the
 43792:    * relevant restyle data.  This function will clear everything other
 43792:    * than a possible eRestyle_LaterSiblings hint for aElement out of
 43792:    * our hashtable.  The returned aData will never have an
 43792:    * eRestyle_LaterSiblings hint in it.
 43792:    *
 43792:    * The return value indicates whether any restyle data was found for
 43792:    * the element.  If false is returned, then the state of *aData is
 43792:    * undefined.
 43792:    */
 79445:   bool GetRestyleData(Element* aElement, RestyleData* aData);
 43792: 
 43792:   /**
 43792:    * The document we're associated with.
 43792:    */
 43792:   inline nsIDocument* Document() const;
 43792: 
 43788:   struct RestyleEnumerateData : public RestyleData {
 48449:     nsRefPtr<Element> mElement;
 43788:   };
 43788: 
 43788: private:
 43791:   /**
 43792:    * Handle a single mPendingRestyles entry.  aRestyleHint must not
 43792:    * include eRestyle_LaterSiblings; that needs to be dealt with
 43792:    * before calling this function.
 43791:    */
 43789:   inline void ProcessOneRestyle(Element* aElement,
 43789:                                 nsRestyleHint aRestyleHint,
125314:                                 nsChangeHint aChangeHint,
125314:                                 OverflowChangedTracker& aTracker);
 43789: 
 84595:   /**
 84595:    * The guts of our restyle processing.
 84595:    */
 84595:   void DoProcessRestyles();
 84595: 
 43788:   typedef nsDataHashtable<nsISupportsHashKey, RestyleData> PendingRestyleTable;
 43792:   typedef nsAutoTArray< nsRefPtr<Element>, 32> RestyleRootArray;
 43788:   // Our restyle bits.  These will be a subset of ELEMENT_ALL_RESTYLE_FLAGS, and
 43788:   // will include one flag from ELEMENT_PENDING_RESTYLE_FLAGS and one flag
 43788:   // that's not in ELEMENT_PENDING_RESTYLE_FLAGS.
108991:   uint32_t mRestyleBits;
 43788:   nsCSSFrameConstructor* mFrameConstructor; // Owns us
 43792:   // A hashtable that maps elements to RestyleData structs.  The
 43792:   // values only make sense if the element's current document is our
 43792:   // document and it has our RestyleBit() flag set.  In particular,
 43792:   // said bit might not be set if the element had a restyle posted and
 43792:   // then was moved around in the DOM.
 43788:   PendingRestyleTable mPendingRestyles;
 43792:   // An array that keeps track of our possible restyle roots.  This
 43792:   // maintains the invariant that if A and B are both restyle roots
 43792:   // and A is an ancestor of B then A will come after B in the array.
 43792:   // We maintain this invariant by checking whether an element has an
 43792:   // ancestor with the restyle root bit set before appending it to the
 43792:   // array.
 43792:   RestyleRootArray mRestyleRoots;
 43792:   // True if we have some entries with the eRestyle_LaterSiblings
 43792:   // flag.  We need this to avoid enumerating the hashtable looking
 43792:   // for such entries when we can't possibly have any.
 79445:   bool mHaveLaterSiblingRestyles;
 43788: };
 43788: 
 79445: inline bool RestyleTracker::AddPendingRestyle(Element* aElement,
 43788:                                                 nsRestyleHint aRestyleHint,
 43788:                                                 nsChangeHint aMinChangeHint)
 43788: {
 43788:   RestyleData existingData;
 43788:   existingData.mRestyleHint = nsRestyleHint(0);
 43788:   existingData.mChangeHint = NS_STYLE_HINT_NONE;
 43788: 
 43792:   // Check the RestyleBit() flag before doing the hashtable Get, since
 43792:   // it's possible that the data in the hashtable isn't actually
 43792:   // relevant anymore (if the flag is not set).
 43792:   if (aElement->HasFlag(RestyleBit())) {
 43788:     mPendingRestyles.Get(aElement, &existingData);
 43792:   } else {
 43792:     aElement->SetFlags(RestyleBit());
 43792:   }
 43788: 
 79445:   bool hadRestyleLaterSiblings =
 43792:     (existingData.mRestyleHint & eRestyle_LaterSiblings) != 0;
 43788:   existingData.mRestyleHint =
 43792:     nsRestyleHint(existingData.mRestyleHint | aRestyleHint);
 43788:   NS_UpdateHint(existingData.mChangeHint, aMinChangeHint);
 43788: 
 43788:   mPendingRestyles.Put(aElement, existingData);
 43792: 
 43792:   // We can only treat this element as a restyle root if we would
 43792:   // actually restyle its descendants (so either call
 43792:   // ReResolveStyleContext on it or just reframe it).
 43794:   if ((aRestyleHint & (eRestyle_Self | eRestyle_Subtree)) ||
 43792:       (aMinChangeHint & nsChangeHint_ReconstructFrame)) {
 43792:     for (const Element* cur = aElement; !cur->HasFlag(RootBit()); ) {
 43792:       nsIContent* parent = cur->GetFlattenedTreeParent();
 43792:       // Stop if we have no parent or the parent is not an element or
 43792:       // we're part of the viewport scrollbars (because those are not
 43792:       // frametree descendants of the primary frame of the root
 43792:       // element).
 43792:       // XXXbz maybe the primary frame of the root should be the root scrollframe?
 43792:       if (!parent || !parent->IsElement() ||
 43792:           // If we've hit the root via a native anonymous kid and that
 43792:           // this native anonymous kid is not obviously a descendant
 43792:           // of the root's primary frame, assume we're under the root
 43792:           // scrollbars.  Since those don't get reresolved when
 43792:           // reresolving the root, we need to make sure to add the
 43792:           // element to mRestyleRoots.
 43792:           (cur->IsInNativeAnonymousSubtree() && !parent->GetParent() &&
 43792:            cur->GetPrimaryFrame() &&
 43792:            cur->GetPrimaryFrame()->GetParent() != parent->GetPrimaryFrame())) {
 43792:         mRestyleRoots.AppendElement(aElement);
 43792:         break;
 43792:       }
 43792:       cur = parent->AsElement();
 43792:     }
 43792:     // At this point some ancestor of aElement (possibly aElement
 43792:     // itself) is in mRestyleRoots.  Set the root bit on aElement, to
 43792:     // speed up searching for an existing root on its descendants.
 43792:     aElement->SetFlags(RootBit());
 43792:   }
 43792: 
 43792:   mHaveLaterSiblingRestyles =
 43792:     mHaveLaterSiblingRestyles || (aRestyleHint & eRestyle_LaterSiblings) != 0;
 43792:   return hadRestyleLaterSiblings;
 43788: }
 43788: 
 43788: } // namespace css
 43815: } // namespace mozilla
 43788: 
 43788: #endif /* mozilla_css_RestyleTracker_h */
