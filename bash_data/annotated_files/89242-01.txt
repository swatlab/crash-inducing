    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsView.h"
    1: #include "nsIWidget.h"
51050: #include "nsWidgetsCID.h"
    1: #include "nsViewManager.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsIComponentManager.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsIInterfaceRequestor.h"
    1: 
    1: //mmptemp
    1: 
20261: static nsEventStatus HandleEvent(nsGUIEvent *aEvent);
    1: 
    1: 
    1: //#define SHOW_VIEW_BORDERS
    1: 
    1: #define VIEW_WRAPPER_IID \
37085:   { 0xbf4e1841, 0xe9ec, 0x47f2, \
37085:     { 0xb4, 0x77, 0x0f, 0xf6, 0x0f, 0x5a, 0xac, 0xbd } }
    1: 
    1: /**
    1:  * nsISupports-derived helper class that allows to store and get a view
    1:  */
    1: class ViewWrapper : public nsIInterfaceRequestor
    1: {
    1:   public:
    1:     NS_DECLARE_STATIC_IID_ACCESSOR(VIEW_WRAPPER_IID)
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIINTERFACEREQUESTOR
    1: 
    1:     ViewWrapper(nsView* aView) : mView(aView) {}
    1: 
    1:     nsView* GetView() { return mView; }
    1:   private:
    1:     nsView* mView;
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(ViewWrapper, VIEW_WRAPPER_IID)
    1: 
    1: NS_IMPL_ADDREF(ViewWrapper)
    1: NS_IMPL_RELEASE(ViewWrapper)
    1: #ifndef DEBUG
    1: NS_IMPL_QUERY_INTERFACE2(ViewWrapper, ViewWrapper, nsIInterfaceRequestor)
    1: 
    1: #else
    1: NS_IMETHODIMP ViewWrapper::QueryInterface(REFNSIID aIID, void** aInstancePtr)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aInstancePtr);
    1: 
37085:   NS_ASSERTION(!aIID.Equals(NS_GET_IID(nsIView)),
    1:                "Someone expects a viewwrapper to be a view!");
    1:   
    1:   *aInstancePtr = nsnull;
    1:   
    1:   if (aIID.Equals(NS_GET_IID(nsISupports))) {
 3233:     *aInstancePtr = static_cast<nsISupports*>(this);
    1:   }
    1:   else if (aIID.Equals(NS_GET_IID(ViewWrapper))) {
    1:     *aInstancePtr = this;
    1:   }
    1:   else if (aIID.Equals(NS_GET_IID(nsIInterfaceRequestor))) {
    1:     *aInstancePtr = this;
    1:   }
    1: 
    1: 
    1:   if (*aInstancePtr) {
    1:     AddRef();
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_NOINTERFACE;
    1: }
    1: #endif
    1: 
    1: NS_IMETHODIMP ViewWrapper::GetInterface(REFNSIID aIID, void** aInstancePtr)
    1: {
    1:   if (aIID.Equals(NS_GET_IID(nsIView))) {
    1:     *aInstancePtr = mView;
    1:     return NS_OK;
    1:   }
    1:   return QueryInterface(aIID, aInstancePtr);
    1: }
    1: 
    1: /**
    1:  * Given a widget, returns the stored ViewWrapper on it, or NULL if no
    1:  * ViewWrapper is there.
    1:  */
    1: static ViewWrapper* GetWrapperFor(nsIWidget* aWidget)
    1: {
    1:   // The widget's client data points back to the owning view
    1:   if (aWidget) {
    1:     void* clientData;
    1:     aWidget->GetClientData(clientData);
    1:     nsISupports* data = (nsISupports*)clientData;
    1:     
    1:     if (data) {
    1:       ViewWrapper* wrapper;
    1:       CallQueryInterface(data, &wrapper);
    1:       // Give a weak reference to the caller. There will still be at least one
    1:       // reference left, since the wrapper was addrefed when set on the widget.
    1:       if (wrapper)
    1:         wrapper->Release();
    1:       return wrapper;
    1:     }
    1:   }
    1:   return nsnull;
    1: }
    1: 
    1: // Main events handler
46193: static nsEventStatus HandleEvent(nsGUIEvent *aEvent)
    1: {
46193: #if 0
87650:   printf(" %d %d %d (%d,%d) \n", aEvent->widget, aEvent->message);
46193: #endif
    1:   nsEventStatus result = nsEventStatus_eIgnore;
    1:   nsView *view = nsView::GetViewFor(aEvent->widget);
    1: 
    1:   if (view)
    1:   {
28334:     nsCOMPtr<nsIViewManager> vm = view->GetViewManager();
30521:     vm->DispatchEvent(aEvent, view, &result);
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
46193: // Attached widget event helpers
46193: static ViewWrapper* GetAttachedWrapperFor(nsIWidget* aWidget)
46193: {
46193:   NS_PRECONDITION(nsnull != aWidget, "null widget ptr");
46193:   return aWidget->GetAttachedViewPtr();
46193: }
46193: 
46193: static nsView* GetAttachedViewFor(nsIWidget* aWidget)
46193: {           
46193:   NS_PRECONDITION(nsnull != aWidget, "null widget ptr");
46193: 
46193:   ViewWrapper* wrapper = GetAttachedWrapperFor(aWidget);
46193:   if (!wrapper)
46193:     return nsnull;
46193:   return wrapper->GetView();
46193: }
46193: 
46193: // event handler
46193: static nsEventStatus AttachedHandleEvent(nsGUIEvent *aEvent)
46193: { 
46193:   nsEventStatus result = nsEventStatus_eIgnore;
46193:   nsView *view = GetAttachedViewFor(aEvent->widget);
46193: 
46193:   if (view)
46193:   {
46193:     nsCOMPtr<nsIViewManager> vm = view->GetViewManager();
46193:     vm->DispatchEvent(aEvent, view, &result);
46193:   }
46193: 
46193:   return result;
46193: }
46193: 
    1: nsView::nsView(nsViewManager* aViewManager, nsViewVisibility aVisibility)
    1: {
    1:   MOZ_COUNT_CTOR(nsView);
    1: 
    1:   mVis = aVisibility;
    1:   // Views should be transparent by default. Not being transparent is
    1:   // a promise that the view will paint all its pixels opaquely. Views
    1:   // should make this promise explicitly by calling
    1:   // SetViewContentTransparency.
    1:   mVFlags = 0;
    1:   mViewManager = aViewManager;
    1:   mDirtyRegion = nsnull;
 8292:   mDeletionObserver = nsnull;
80486:   mHaveInvalidationDimensions = false;
80486:   mWidgetIsTopLevel = false;
    1: }
    1: 
32435: void nsView::DropMouseGrabbing()
32435: {
82568:   nsIPresShell* presShell = mViewManager->GetPresShell();
82568:   if (presShell)
82568:     presShell->ClearMouseCaptureOnView(this);
    1: }
    1: 
    1: nsView::~nsView()
    1: {
    1:   MOZ_COUNT_DTOR(nsView);
    1: 
    1:   while (GetFirstChild())
    1:   {
    1:     nsView* child = GetFirstChild();
    1:     if (child->GetViewManager() == mViewManager) {
    1:       child->Destroy();
    1:     } else {
    1:       // just unhook it. Someone else will want to destroy this.
    1:       RemoveChild(child);
    1:     }
    1:   }
    1: 
    1:   if (mViewManager)
    1:   {
    1:     DropMouseGrabbing();
    1:   
64435:     nsView *rootView = mViewManager->GetRootViewImpl();
    1:     
    1:     if (rootView)
    1:     {
    1:       // Root views can have parents!
    1:       if (mParent)
    1:       {
    1:         mViewManager->RemoveChild(this);
    1:       }
    1: 
    1:       if (rootView == this)
    1:       {
    1:         // Inform the view manager that the root view has gone away...
    1:         mViewManager->SetRootView(nsnull);
    1:       }
    1:     }
    1:     else if (mParent)
    1:     {
    1:       mParent->RemoveChild(this);
    1:     }
    1:     
    1:     mViewManager = nsnull;
    1:   }
    1:   else if (mParent)
    1:   {
    1:     mParent->RemoveChild(this);
    1:   }
    1: 
    1:   // Destroy and release the widget
63824:   DestroyWidget();
63824: 
63824:   delete mDirtyRegion;
63824: 
63824:   if (mDeletionObserver) {
63824:     mDeletionObserver->Clear();
63824:   }
63824: }
63824: 
63824: void nsView::DestroyWidget()
63824: {
    1:   if (mWindow)
    1:   {
    1:     // Release memory for the view wrapper
    1:     ViewWrapper* wrapper = GetWrapperFor(mWindow);
    1:     NS_IF_RELEASE(wrapper);
    1: 
46193:     // If we are not attached to a base window, we're going to tear down our
46193:     // widget here. However, if we're attached to somebody elses widget, we
46193:     // want to leave the widget alone: don't reset the client data or call
46193:     // Destroy. Just clear our event view ptr and free our reference to it. 
46193:     if (mWidgetIsTopLevel) {
46193:       ViewWrapper* wrapper = GetAttachedWrapperFor(mWindow);
46193:       NS_IF_RELEASE(wrapper);
46193: 
46193:       mWindow->SetAttachedViewPtr(nsnull);
46193:     }
46193:     else {
    1:       mWindow->SetClientData(nsnull);
    1:       mWindow->Destroy();
46193:     }
46193: 
    1:     NS_RELEASE(mWindow);
    1:   }
    1: }
    1: 
    1: nsresult nsView::QueryInterface(const nsIID& aIID, void** aInstancePtr)
    1: {
    1:   if (nsnull == aInstancePtr) {
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1: 
    1:   NS_ASSERTION(!aIID.Equals(NS_GET_IID(nsISupports)),
    1:                "Someone expects views to be ISupports-derived!");
    1:   
    1:   *aInstancePtr = nsnull;
    1:   
    1:   if (aIID.Equals(NS_GET_IID(nsIView))) {
    1:     *aInstancePtr = (void*)(nsIView*)this;
    1:     return NS_OK;
    1:   }
    1: 
    1:   return NS_NOINTERFACE;
    1: }
    1: 
    1: nsIView* nsIView::GetViewFor(nsIWidget* aWidget)
    1: {           
    1:   NS_PRECONDITION(nsnull != aWidget, "null widget ptr");
    1: 
    1:   ViewWrapper* wrapper = GetWrapperFor(aWidget);
46193: 
87650:   if (!wrapper) {
46193:     wrapper = GetAttachedWrapperFor(aWidget);
87650:   }
46193: 
87650:   if (wrapper) {
    1:     return wrapper->GetView();
87650:   }
46193: 
    1:   return nsnull;
    1: }
    1: 
    1: void nsIView::Destroy()
    1: {
    1:   delete this;
    1: }
    1: 
    1: void nsView::SetPosition(nscoord aX, nscoord aY)
    1: {
    1:   mDimBounds.x += aX - mPosX;
    1:   mDimBounds.y += aY - mPosY;
    1:   mPosX = aX;
    1:   mPosY = aY;
    1: 
    1:   NS_ASSERTION(GetParent() || (aX == 0 && aY == 0),
    1:                "Don't try to move the root widget to something non-zero");
    1: 
87349:   ResetWidgetBounds(true, false);
    1: }
    1: 
63392: void nsIView::SetInvalidationDimensions(const nsRect* aRect)
63392: {
63392:   return Impl()->SetInvalidationDimensions(aRect);
63392: }
63392: 
87349: void nsView::ResetWidgetBounds(bool aRecurse, bool aForceSync)
87349: {
    1:   if (mWindow) {
87349:     if (!aForceSync) {
87349:       // Don't change widget geometry synchronously, since that can
87349:       // cause synchronous painting.
    1:       mViewManager->PostPendingUpdate();
87349:     } else {
87349:       DoResetWidgetBounds(false, true);
87349:     }
    1:     return;
    1:   }
    1: 
87349:   if (aRecurse) {
    1:     // reposition any widgets under this view
    1:     for (nsView* v = GetFirstChild(); v; v = v->GetNextSibling()) {
87349:       v->ResetWidgetBounds(true, aForceSync);
    1:     }
    1:   }
    1: }
    1: 
79445: bool nsIView::IsEffectivelyVisible()
30996: {
39430:   for (nsIView* v = this; v; v = v->mParent) {
30996:     if (v->GetVisibility() == nsViewVisibility_kHide)
80486:       return false;
30996:   }
80486:   return true;
30996: }
30996: 
39430: nsIntRect nsIView::CalcWidgetBounds(nsWindowType aType)
 1884: {
47897:   PRInt32 p2a = mViewManager->AppUnitsPerDevPixel();
 1884: 
 1884:   nsRect viewBounds(mDimBounds);
 1884: 
51042:   nsView* parent = GetParent()->Impl();
47897:   if (parent) {
 1884:     nsPoint offset;
47897:     nsIWidget* parentWidget = parent->GetNearestWidget(&offset, p2a);
41178:     // make viewBounds be relative to the parent widget, in appunits
 1884:     viewBounds += offset;
 1884: 
 2048:     if (parentWidget && aType == eWindowType_popup &&
30996:         IsEffectivelyVisible()) {
46193:       // put offset into screen coordinates. (based on client area origin)
25183:       nsIntPoint screenPoint = parentWidget->WidgetToScreenOffset();
25183:       viewBounds += nsPoint(NSIntPixelsToAppUnits(screenPoint.x, p2a),
25183:                             NSIntPixelsToAppUnits(screenPoint.y, p2a));
 1884:     }
 1884:   }
 1884: 
41178:   // Compute widget bounds in device pixels
28113:   nsIntRect newBounds = viewBounds.ToNearestPixels(p2a);
 1884: 
47897:   // Compute where the top-left of our widget ended up relative to the parent
47897:   // widget, in appunits.
 1884:   nsPoint roundedOffset(NSIntPixelsToAppUnits(newBounds.x, p2a),
 1884:                         NSIntPixelsToAppUnits(newBounds.y, p2a));
41178: 
41178:   // mViewToWidgetOffset is added to coordinates relative to the view origin
41178:   // to get coordinates relative to the widget.
41178:   // The view origin, relative to the parent widget, is at
41178:   // (mPosX,mPosY) - mDimBounds.TopLeft() + viewBounds.TopLeft().
41178:   // Our widget, relative to the parent widget, is roundedOffset.
41178:   mViewToWidgetOffset = nsPoint(mPosX, mPosY)
41178:     - mDimBounds.TopLeft() + viewBounds.TopLeft() - roundedOffset;
 1884: 
 1884:   return newBounds;
 1884: }
 1884: 
79445: void nsView::DoResetWidgetBounds(bool aMoveOnly,
79445:                                  bool aInvalidateChangedSize) {
    1:   // The geometry of a root view's widget is controlled externally,
    1:   // NOT by sizing or positioning the view
64435:   if (mViewManager->GetRootViewImpl() == this) {
    1:     return;
    1:   }
    1:   
23738:   nsIntRect curBounds;
83107:   mWindow->GetClientBounds(curBounds);
46193: 
    1:   nsWindowType type;
    1:   mWindow->GetWindowType(type);
    1: 
    1:   if (curBounds.IsEmpty() && mDimBounds.IsEmpty() && type == eWindowType_popup) {
    1:     // Don't manipulate empty popup widgets. For example there's no point
    1:     // moving hidden comboboxes around, or doing X server roundtrips
    1:     // to compute their true screen position. This could mean that WidgetToScreen
    1:     // operations on these widgets don't return up-to-date values, but popup
    1:     // positions aren't reliable anyway because of correction to be on or off-screen.
    1:     return;
    1:   }
    1: 
61364:   NS_PRECONDITION(mWindow, "Why was this called??");
61364: 
23738:   nsIntRect newBounds = CalcWidgetBounds(type);
    1: 
79445:   bool changedPos = curBounds.TopLeft() != newBounds.TopLeft();
79445:   bool changedSize = curBounds.Size() != newBounds.Size();
    1: 
46193:   // Child views are never attached to top level widgets, this is safe.
    1:   if (changedPos) {
    1:     if (changedSize && !aMoveOnly) {
83107:       mWindow->ResizeClient(newBounds.x, newBounds.y,
83107:                             newBounds.width, newBounds.height,
    1:                             aInvalidateChangedSize);
    1:     } else {
83107:       mWindow->MoveClient(newBounds.x, newBounds.y);
    1:     }
    1:   } else {
    1:     if (changedSize && !aMoveOnly) {
83107:       mWindow->ResizeClient(newBounds.width, newBounds.height,
83107:                             aInvalidateChangedSize);
    1:     } // else do nothing!
    1:   }
    1: }
    1: 
79445: void nsView::SetDimensions(const nsRect& aRect, bool aPaint, bool aResizeWidget)
    1: {
    1:   nsRect dims = aRect;
    1:   dims.MoveBy(mPosX, mPosY);
    1: 
    1:   // Don't use nsRect's operator== here, since it returns true when
    1:   // both rects are empty even if they have different widths and we
    1:   // have cases where that sort of thing matters to us.
    1:   if (mDimBounds.TopLeft() == dims.TopLeft() &&
    1:       mDimBounds.Size() == dims.Size()) {
    1:     return;
    1:   }
    1: 
    1:   mDimBounds = dims;
    1: 
    1:   if (aResizeWidget) {
87349:     ResetWidgetBounds(false, false);
    1:   }
    1: }
    1: 
63392: void nsView::SetInvalidationDimensions(const nsRect* aRect)
63392: {
63392:   if ((mHaveInvalidationDimensions = !!aRect)) {
63392:     mInvalidationDimensions = *aRect;
63392:   }
63392: }
63392: 
79445: void nsView::NotifyEffectiveVisibilityChanged(bool aEffectivelyVisible)
    1: {
30996:   if (!aEffectivelyVisible)
    1:   {
    1:     DropMouseGrabbing();
    1:   }
    1: 
    1:   if (nsnull != mWindow)
    1:   {
61364:     if (aEffectivelyVisible)
61364:     {
80486:       DoResetWidgetBounds(false, true);
80486:       mWindow->Show(true);
61364:     }
61364:     else
80486:       mWindow->Show(false);
    1:   }
    1: 
30996:   for (nsView* child = mFirstChild; child; child = child->mNextSibling) {
30996:     if (child->mVis == nsViewVisibility_kHide) {
30996:       // It was effectively hidden and still is
30996:       continue;
30996:     }
30996:     // Our child is visible if we are
30996:     child->NotifyEffectiveVisibilityChanged(aEffectivelyVisible);
30996:   }
30996: }
30996: 
30996: NS_IMETHODIMP nsView::SetVisibility(nsViewVisibility aVisibility)
30996: {
30996:   mVis = aVisibility;
30996:   NotifyEffectiveVisibilityChanged(IsEffectivelyVisible());
    1:   return NS_OK;
    1: }
    1: 
79445: NS_IMETHODIMP nsView::SetFloating(bool aFloatingView)
    1: {
    1: 	if (aFloatingView)
    1: 		mVFlags |= NS_VIEW_FLAG_FLOATING;
    1: 	else
    1: 		mVFlags &= ~NS_VIEW_FLAG_FLOATING;
    1: 
    1: #if 0
    1: 	// recursively make all sub-views "floating" grr.
    1: 	for (nsView* child = mFirstChild; chlid; child = child->GetNextSibling()) {
    1: 		child->SetFloating(aFloatingView);
    1: 	}
    1: #endif
    1: 
    1: 	return NS_OK;
    1: }
    1: 
    1: void nsView::InvalidateHierarchy(nsViewManager *aViewManagerParent)
    1: {
64435:   if (mViewManager->GetRootViewImpl() == this)
    1:     mViewManager->InvalidateHierarchy();
    1: 
    1:   for (nsView *child = mFirstChild; child; child = child->GetNextSibling())
    1:     child->InvalidateHierarchy(aViewManagerParent);
    1: }
    1: 
    1: void nsView::InsertChild(nsView *aChild, nsView *aSibling)
    1: {
    1:   NS_PRECONDITION(nsnull != aChild, "null ptr");
    1: 
    1:   if (nsnull != aChild)
    1:   {
    1:     if (nsnull != aSibling)
    1:     {
    1: #ifdef NS_DEBUG
    1:       NS_ASSERTION(aSibling->GetParent() == this, "tried to insert view with invalid sibling");
    1: #endif
    1:       //insert after sibling
    1:       aChild->SetNextSibling(aSibling->GetNextSibling());
    1:       aSibling->SetNextSibling(aChild);
    1:     }
    1:     else
    1:     {
    1:       aChild->SetNextSibling(mFirstChild);
    1:       mFirstChild = aChild;
    1:     }
    1:     aChild->SetParent(this);
    1: 
    1:     // If we just inserted a root view, then update the RootViewManager
    1:     // on all view managers in the new subtree.
    1: 
    1:     nsViewManager *vm = aChild->GetViewManager();
64435:     if (vm->GetRootViewImpl() == aChild)
    1:     {
    1:       aChild->InvalidateHierarchy(nsnull); // don't care about releasing grabs
    1:     }
    1:   }
    1: }
    1: 
    1: void nsView::RemoveChild(nsView *child)
    1: {
    1:   NS_PRECONDITION(nsnull != child, "null ptr");
    1: 
    1:   if (nsnull != child)
    1:   {
    1:     nsView* prevKid = nsnull;
    1:     nsView* kid = mFirstChild;
79445:     bool found = false;
    1:     while (nsnull != kid) {
    1:       if (kid == child) {
    1:         if (nsnull != prevKid) {
    1:           prevKid->SetNextSibling(kid->GetNextSibling());
    1:         } else {
    1:           mFirstChild = kid->GetNextSibling();
    1:         }
    1:         child->SetParent(nsnull);
80486:         found = true;
    1:         break;
    1:       }
    1:       prevKid = kid;
    1: 	    kid = kid->GetNextSibling();
    1:     }
    1:     NS_ASSERTION(found, "tried to remove non child");
    1: 
    1:     // If we just removed a root view, then update the RootViewManager
    1:     // on all view managers in the removed subtree.
    1: 
    1:     nsViewManager *vm = child->GetViewManager();
64435:     if (vm->GetRootViewImpl() == child)
    1:     {
    1:       child->InvalidateHierarchy(GetViewManager());
    1:     }
    1:   }
    1: }
    1: 
    1: // Native widgets ultimately just can't deal with the awesome power of
    1: // CSS2 z-index. However, we set the z-index on the widget anyway
    1: // because in many simple common cases the widgets do end up in the
    1: // right order. We set each widget's z-index to the z-index of the
    1: // nearest ancestor that has non-auto z-index.
    1: static void UpdateNativeWidgetZIndexes(nsView* aView, PRInt32 aZIndex)
    1: {
    1:   if (aView->HasWidget()) {
    1:     nsIWidget* widget = aView->GetWidget();
    1:     PRInt32 curZ;
    1:     widget->GetZIndex(&curZ);
    1:     if (curZ != aZIndex) {
    1:       widget->SetZIndex(aZIndex);
    1:     }
    1:   } else {
    1:     for (nsView* v = aView->GetFirstChild(); v; v = v->GetNextSibling()) {
    1:       if (v->GetZIndexIsAuto()) {
    1:         UpdateNativeWidgetZIndexes(v, aZIndex);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: static PRInt32 FindNonAutoZIndex(nsView* aView)
    1: {
    1:   while (aView) {
    1:     if (!aView->GetZIndexIsAuto()) {
    1:       return aView->GetZIndex();
    1:     }
    1:     aView = aView->GetParent();
    1:   }
    1:   return 0;
    1: }
    1: 
51050: nsresult nsIView::CreateWidget(nsWidgetInitData *aWidgetInitData,
79445:                                bool aEnableDragDrop,
79445:                                bool aResetVisibility)
51050: {
51050:   return Impl()->CreateWidget(aWidgetInitData,
54355:                               aEnableDragDrop, aResetVisibility);
51050: }
51050: 
51050: nsresult nsIView::CreateWidgetForParent(nsIWidget* aParentWidget,
    1:                                         nsWidgetInitData *aWidgetInitData,
79445:                                         bool aEnableDragDrop,
79445:                                         bool aResetVisibility)
    1: {
51050:   return Impl()->CreateWidgetForParent(aParentWidget, aWidgetInitData,
54355:                                        aEnableDragDrop, aResetVisibility);
51048: }
51048: 
51050: nsresult nsIView::CreateWidgetForPopup(nsWidgetInitData *aWidgetInitData,
51048:                                        nsIWidget* aParentWidget,
79445:                                        bool aEnableDragDrop,
79445:                                        bool aResetVisibility)
51048: {
51050:   return Impl()->CreateWidgetForPopup(aWidgetInitData, aParentWidget,
54355:                                       aEnableDragDrop, aResetVisibility);
51042: }
51042: 
63824: void nsIView::DestroyWidget()
63824: {
63824:   Impl()->DestroyWidget();
63824: }
63824: 
51346: struct DefaultWidgetInitData : public nsWidgetInitData {
51346:   DefaultWidgetInitData() : nsWidgetInitData()
51346:   {
51346:     mWindowType = eWindowType_child;
80486:     clipChildren = true;
80486:     clipSiblings = true;
51346:   }
51346: };
51346: 
51050: nsresult nsView::CreateWidget(nsWidgetInitData *aWidgetInitData,
79445:                               bool aEnableDragDrop,
79445:                               bool aResetVisibility)
51042: {
51050:   AssertNoWindow();
51048:   NS_ABORT_IF_FALSE(!aWidgetInitData ||
51048:                     aWidgetInitData->mWindowType != eWindowType_popup,
51048:                     "Use CreateWidgetForPopup");
    1: 
51346:   DefaultWidgetInitData defaultInitData;
79445:   bool initDataPassedIn = !!aWidgetInitData;
51346:   aWidgetInitData = aWidgetInitData ? aWidgetInitData : &defaultInitData;
51353:   defaultInitData.mListenForResizes =
51353:     (!initDataPassedIn && GetParent() &&
51353:      GetParent()->GetViewManager() != mViewManager);
51044: 
51044:   nsIntRect trect = CalcWidgetBounds(aWidgetInitData->mWindowType);
    1: 
68668:   nsRefPtr<nsDeviceContext> dx;
 1884:   mViewManager->GetDeviceContext(*getter_AddRefs(dx));
    1: 
51048:   nsIWidget* parentWidget =
51048:     GetParent() ? GetParent()->GetNearestWidget(nsnull) : nsnull;
51050:   if (!parentWidget) {
51050:     NS_ERROR("nsView::CreateWidget without suitable parent widget??");
51050:     return NS_ERROR_FAILURE;
51050:   }
51048: 
51050:   // XXX: using aForceUseIWidgetParent=true to preserve previous
51050:   // semantics.  It's not clear that it's actually needed.
51050:   mWindow = parentWidget->CreateChild(trect, ::HandleEvent,
80842:                                       dx, aWidgetInitData,
80486:                                       true).get();
51050:   if (!mWindow) {
51050:     return NS_ERROR_FAILURE;
51050:   }
51048:  
51048:   InitializeWindow(aEnableDragDrop, aResetVisibility);
51048: 
51048:   return NS_OK;
51048: }
51048: 
51050: nsresult nsView::CreateWidgetForParent(nsIWidget* aParentWidget,
51048:                                        nsWidgetInitData *aWidgetInitData,
79445:                                        bool aEnableDragDrop,
79445:                                        bool aResetVisibility)
51048: {
51050:   AssertNoWindow();
51048:   NS_ABORT_IF_FALSE(!aWidgetInitData ||
51048:                     aWidgetInitData->mWindowType != eWindowType_popup,
51048:                     "Use CreateWidgetForPopup");
51048:   NS_ABORT_IF_FALSE(aParentWidget, "Parent widget required");
51048: 
51346:   DefaultWidgetInitData defaultInitData;
51346:   aWidgetInitData = aWidgetInitData ? aWidgetInitData : &defaultInitData;
51346: 
51346:   nsIntRect trect = CalcWidgetBounds(aWidgetInitData->mWindowType);
51048: 
68668:   nsRefPtr<nsDeviceContext> dx;
51048:   mViewManager->GetDeviceContext(*getter_AddRefs(dx));
51048: 
51050:   mWindow =
51050:     aParentWidget->CreateChild(trect, ::HandleEvent,
80842:                                dx, aWidgetInitData).get();
51050:   if (!mWindow) {
51050:     return NS_ERROR_FAILURE;
51050:   }
51048: 
51048:   InitializeWindow(aEnableDragDrop, aResetVisibility);
51048: 
51048:   return NS_OK;
51048: }
51048: 
51050: nsresult nsView::CreateWidgetForPopup(nsWidgetInitData *aWidgetInitData,
51048:                                       nsIWidget* aParentWidget,
79445:                                       bool aEnableDragDrop,
79445:                                       bool aResetVisibility)
51048: {
51050:   AssertNoWindow();
51048:   NS_ABORT_IF_FALSE(aWidgetInitData, "Widget init data required");
51048:   NS_ABORT_IF_FALSE(aWidgetInitData->mWindowType == eWindowType_popup,
51048:                     "Use one of the other CreateWidget methods");
51048: 
51048:   nsIntRect trect = CalcWidgetBounds(aWidgetInitData->mWindowType);
51048: 
68668:   nsRefPtr<nsDeviceContext> dx;
51048:   mViewManager->GetDeviceContext(*getter_AddRefs(dx));
51048: 
51048:   // XXX/cjones: having these two separate creation cases seems ... um
51048:   // ... unnecessary, but it's the way the old code did it.  Please
51048:   // unify them by first finding a suitable parent nsIWidget, then
51050:   // getting rid of aForceUseIWidgetParent.
 8408:   if (aParentWidget) {
51050:     // XXX: using aForceUseIWidgetParent=true to preserve previous
51050:     // semantics.  It's not clear that it's actually needed.
51050:     mWindow = aParentWidget->CreateChild(trect, ::HandleEvent,
80842:                                          dx, aWidgetInitData,
80486:                                          true).get();
 8408:   }
 8408:   else {
51046:     nsIWidget* nearestParent = GetParent() ? GetParent()->GetNearestWidget(nsnull)
51046:                                            : nsnull;
51046:     if (!nearestParent) {
51046:       // Without a parent, we can't make a popup.  This can happen
51046:       // when printing
51046:       return NS_ERROR_FAILURE;
51046:     }
51046: 
51050:     mWindow =
51050:       nearestParent->CreateChild(trect, ::HandleEvent,
80842:                                  dx, aWidgetInitData).get();
51050:   }
51050:   if (!mWindow) {
51050:     return NS_ERROR_FAILURE;
51046:   }
51045: 
51047:   InitializeWindow(aEnableDragDrop, aResetVisibility);
51047: 
51047:   return NS_OK;
51047: }
51047: 
51047: void
79445: nsView::InitializeWindow(bool aEnableDragDrop, bool aResetVisibility)
51047: {
51047:   NS_ABORT_IF_FALSE(mWindow, "Must have a window to initialize");
51047: 
51050:   ViewWrapper* wrapper = new ViewWrapper(this);
51050:   NS_ADDREF(wrapper); // Will be released in ~nsView
51050:   mWindow->SetClientData(wrapper);
51050: 
    1:   if (aEnableDragDrop) {
80486:     mWindow->EnableDragDrop(true);
    1:   }
    1:       
    1:   // propagate the z-index to the widget.
51042:   UpdateNativeWidgetZIndexes(this, FindNonAutoZIndex(this));
    1: 
    1:   //make sure visibility state is accurate
    1: 
    1:   if (aResetVisibility) {
51042:     SetVisibility(GetVisibility());
    1:   }
    1: }
    1: 
46193: // Attach to a top level widget and start receiving mirrored events.
46193: nsresult nsIView::AttachToTopLevelWidget(nsIWidget* aWidget)
46193: {
46193:   NS_PRECONDITION(nsnull != aWidget, "null widget ptr");
46193:   /// XXXjimm This is a temporary workaround to an issue w/document
46193:   // viewer (bug 513162).
46193:   nsIView *oldView = GetAttachedViewFor(aWidget);
46193:   if (oldView) {
46193:     oldView->DetachFromTopLevelWidget();
46193:   }
46193: 
68668:   nsRefPtr<nsDeviceContext> dx;
46193:   mViewManager->GetDeviceContext(*getter_AddRefs(dx));
46193: 
46193:   // Note, the previous device context will be released. Detaching
46193:   // will not restore the old one.
62248:   nsresult rv = aWidget->AttachViewToTopLevel(
62248:     nsIWidget::UsePuppetWidgets() ? ::HandleEvent : ::AttachedHandleEvent, dx);
46193:   if (NS_FAILED(rv))
46193:     return rv;
46193: 
46193:   mWindow = aWidget;
46193:   NS_ADDREF(mWindow);
46193: 
51042:   ViewWrapper* wrapper = new ViewWrapper(Impl());
46193:   NS_ADDREF(wrapper);
46193:   mWindow->SetAttachedViewPtr(wrapper);
80486:   mWindow->EnableDragDrop(true);
80486:   mWidgetIsTopLevel = true;
46193: 
46193:   // Refresh the view bounds
46193:   nsWindowType type;
46193:   mWindow->GetWindowType(type);
46193:   CalcWidgetBounds(type);
46193: 
46193:   return NS_OK;
46193: }
46193: 
46193: // Detach this view from an attached widget. 
46193: nsresult nsIView::DetachFromTopLevelWidget()
46193: {
46193:   NS_PRECONDITION(mWidgetIsTopLevel, "Not attached currently!");
46193:   NS_PRECONDITION(mWindow, "null mWindow for DetachFromTopLevelWidget!");
46193: 
46193:   // Release memory for the view wrapper
46193:   ViewWrapper* wrapper = GetAttachedWrapperFor(mWindow);
46193:   NS_IF_RELEASE(wrapper);
46193: 
46193:   mWindow->SetAttachedViewPtr(nsnull);
46193:   NS_RELEASE(mWindow);
46193: 
80486:   mWidgetIsTopLevel = false;
46193:   
46193:   return NS_OK;
46193: }
46193: 
79445: void nsView::SetZIndex(bool aAuto, PRInt32 aZIndex, bool aTopMost)
    1: {
79445:   bool oldIsAuto = GetZIndexIsAuto();
    1:   mVFlags = (mVFlags & ~NS_VIEW_FLAG_AUTO_ZINDEX) | (aAuto ? NS_VIEW_FLAG_AUTO_ZINDEX : 0);
    1:   mZIndex = aZIndex;
    1:   SetTopMost(aTopMost);
    1:   
    1:   if (HasWidget() || !oldIsAuto || !aAuto) {
    1:     UpdateNativeWidgetZIndexes(this, FindNonAutoZIndex(this));
    1:   }
    1: }
    1: 
51050: void nsView::AssertNoWindow()
    1: {
51050:   // XXX: it would be nice to make this a strong assert
51048:   if (NS_UNLIKELY(mWindow)) {
51048:     NS_ERROR("We already have a window for this view? BAD");
51048:     ViewWrapper* wrapper = GetWrapperFor(mWindow);
51048:     NS_IF_RELEASE(wrapper);
51048:     mWindow->SetClientData(nsnull);
51048:     mWindow->Destroy();
51048:     NS_RELEASE(mWindow);
51048:   }
    1: }
    1: 
51050: //
51050: // internal window creation functions
51050: //
30522: EVENT_CALLBACK nsIView::AttachWidgetEventHandler(nsIWidget* aWidget)
30522: {
30522: #ifdef DEBUG
30522:   void* data = nsnull;
30522:   aWidget->GetClientData(data);
30522:   NS_ASSERTION(!data, "Already got client data");
30522: #endif
30522: 
51042:   ViewWrapper* wrapper = new ViewWrapper(Impl());
30522:   if (!wrapper)
30522:     return nsnull;
30522:   NS_ADDREF(wrapper); // Will be released in DetachWidgetEventHandler
30522:   aWidget->SetClientData(wrapper);
30522:   return ::HandleEvent;
30522: }
30522: 
30522: void nsIView::DetachWidgetEventHandler(nsIWidget* aWidget)
30522: {
30522:   ViewWrapper* wrapper = GetWrapperFor(aWidget);
30522:   NS_ASSERTION(!wrapper || wrapper->GetView() == this, "Wrong view");
30522:   NS_IF_RELEASE(wrapper);
30522:   aWidget->SetClientData(nsnull);
30522: }
30522: 
    1: #ifdef DEBUG
    1: void nsIView::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   PRInt32 i;
    1:   for (i = aIndent; --i >= 0; ) fputs("  ", out);
    1:   fprintf(out, "%p ", (void*)this);
    1:   if (nsnull != mWindow) {
47897:     nscoord p2a = mViewManager->AppUnitsPerDevPixel();
23738:     nsIntRect rect;
23738:     mWindow->GetClientBounds(rect);
28113:     nsRect windowBounds = rect.ToAppUnits(p2a);
23738:     mWindow->GetBounds(rect);
28113:     nsRect nonclientBounds = rect.ToAppUnits(p2a);
    1:     nsrefcnt widgetRefCnt = mWindow->AddRef() - 1;
    1:     mWindow->Release();
    1:     PRInt32 Z;
    1:     mWindow->GetZIndex(&Z);
    1:     fprintf(out, "(widget=%p[%d] z=%d pos={%d,%d,%d,%d}) ",
    1:             (void*)mWindow, widgetRefCnt, Z,
    1:             nonclientBounds.x, nonclientBounds.y,
    1:             windowBounds.width, windowBounds.height);
    1:   }
    1:   nsRect brect = GetBounds();
    1:   fprintf(out, "{%d,%d,%d,%d}",
    1:           brect.x, brect.y, brect.width, brect.height);
82566:   fprintf(out, " z=%d vis=%d frame=%p <\n",
82566:           mZIndex, mVis, mFrame);
    1:   for (nsView* kid = mFirstChild; kid; kid = kid->GetNextSibling()) {
    1:     NS_ASSERTION(kid->GetParent() == this, "incorrect parent");
    1:     kid->List(out, aIndent + 1);
    1:   }
    1:   for (i = aIndent; --i >= 0; ) fputs("  ", out);
    1:   fputs(">\n", out);
    1: }
    1: #endif // DEBUG
    1: 
    1: nsPoint nsIView::GetOffsetTo(const nsIView* aOther) const
    1: {
51042:   return Impl()->GetOffsetTo(static_cast<const nsView*>(aOther),
51042:                              Impl()->GetViewManager()->AppUnitsPerDevPixel());
47897: }
47897: 
47897: nsPoint nsView::GetOffsetTo(const nsView* aOther) const
47897: {
47897:   return GetOffsetTo(aOther, GetViewManager()->AppUnitsPerDevPixel());
47897: }
47897: 
47897: nsPoint nsView::GetOffsetTo(const nsView* aOther, const PRInt32 aAPD) const
47897: {
56350:   NS_ABORT_IF_FALSE(GetParent() || !aOther || aOther->GetParent() ||
56350:                     this == aOther, "caller of (outer) GetOffsetTo must not "
56350:                     "pass unrelated views");
47897:   // We accumulate the final result in offset
    1:   nsPoint offset(0, 0);
47897:   // The offset currently accumulated at the current APD
47897:   nsPoint docOffset(0, 0);
47897:   const nsView* v = this;
47897:   nsViewManager* currVM = v->GetViewManager();
47897:   PRInt32 currAPD = currVM->AppUnitsPerDevPixel();
47897:   const nsView* root = nsnull;
47897:   for ( ; v != aOther && v; root = v, v = v->GetParent()) {
47897:     nsViewManager* newVM = v->GetViewManager();
47897:     if (newVM != currVM) {
47897:       PRInt32 newAPD = newVM->AppUnitsPerDevPixel();
47897:       if (newAPD != currAPD) {
47897:         offset += docOffset.ConvertAppUnits(currAPD, aAPD);
47897:         docOffset.x = docOffset.y = 0;
47897:         currAPD = newAPD;
    1:       }
47897:       currVM = newVM;
47897:     }
47897:     docOffset += v->GetPosition();
47897:   }
47897:   offset += docOffset.ConvertAppUnits(currAPD, aAPD);
    1: 
    1:   if (v != aOther) {
    1:     // Looks like aOther wasn't an ancestor of |this|.  So now we have
47897:     // the root-VM-relative position of |this| in |offset|.  Get the
47897:     // root-VM-relative position of aOther and subtract it.
47897:     nsPoint negOffset = aOther->GetOffsetTo(root, aAPD);
47897:     offset -= negOffset;
    1:   }
    1: 
    1:   return offset;
    1: }
    1: 
47897: nsPoint nsIView::GetOffsetToWidget(nsIWidget* aWidget) const
47897: {
47897:   nsPoint pt;
47897:   // Get the view for widget
51042:   nsIView* widgetIView = GetViewFor(aWidget);
51042:   if (!widgetIView) {
47897:     return pt;
47897:   }
51042:   nsView* widgetView = widgetIView->Impl();
51042: 
47897:   // Get the offset to the widget view in the widget view's APD
47897:   // We get the offset in the widget view's APD first and then convert to our
47897:   // APD afterwards so that we can include the widget view's ViewToWidgetOffset
47897:   // in the sum in its native APD, and then convert the whole thing to our APD
47897:   // so that we don't have to convert the APD of the relatively small
47897:   // ViewToWidgetOffset by itself with a potentially large relative rounding
47897:   // error.
47897:   pt = -widgetView->GetOffsetTo(static_cast<const nsView*>(this));
47897:   // Add in the offset to the widget.
47897:   pt += widgetView->ViewToWidgetOffset();
47897: 
47897:   // Convert to our appunits.
47897:   PRInt32 widgetAPD = widgetView->GetViewManager()->AppUnitsPerDevPixel();
47897:   PRInt32 ourAPD = static_cast<const nsView*>(this)->
47897:                     GetViewManager()->AppUnitsPerDevPixel();
47897:   pt = pt.ConvertAppUnits(widgetAPD, ourAPD);
47897:   return pt;
47897: }
47897: 
    1: nsIWidget* nsIView::GetNearestWidget(nsPoint* aOffset) const
    1: {
51042:   return Impl()->GetNearestWidget(aOffset,
51042:                                   Impl()->GetViewManager()->AppUnitsPerDevPixel());
47897: }
47897: 
47897: nsIWidget* nsView::GetNearestWidget(nsPoint* aOffset) const
47897: {
47897:   return GetNearestWidget(aOffset, GetViewManager()->AppUnitsPerDevPixel());
47897: }
47897: 
47897: nsIWidget* nsView::GetNearestWidget(nsPoint* aOffset, const PRInt32 aAPD) const
47897: {
46193:   // aOffset is based on the view's position, which ignores any chrome on
46193:   // attached parent widgets.
46193: 
47897:   // We accumulate the final result in pt
    1:   nsPoint pt(0, 0);
47897:   // The offset currently accumulated at the current APD
47897:   nsPoint docPt(0,0);
47897:   const nsView* v = this;
47897:   nsViewManager* currVM = v->GetViewManager();
47897:   PRInt32 currAPD = currVM->AppUnitsPerDevPixel();
47897:   for ( ; v && !v->HasWidget(); v = v->GetParent()) {
47897:     nsViewManager* newVM = v->GetViewManager();
47897:     if (newVM != currVM) {
47897:       PRInt32 newAPD = newVM->AppUnitsPerDevPixel();
47897:       if (newAPD != currAPD) {
47897:         pt += docPt.ConvertAppUnits(currAPD, aAPD);
47897:         docPt.x = docPt.y = 0;
47897:         currAPD = newAPD;
47897:       }
47897:       currVM = newVM;
47897:     }
47897:     docPt += v->GetPosition();
    1:   }
    1:   if (!v) {
    1:     if (aOffset) {
47897:       pt += docPt.ConvertAppUnits(currAPD, aAPD);
    1:       *aOffset = pt;
    1:     }
30536:     return nsnull;
    1:   }
    1: 
47897:   // pt is now the offset from v's origin to this view's origin.
47897:   // We add the ViewToWidgetOffset to get the offset to the widget.
    1:   if (aOffset) {
47897:     docPt += v->ViewToWidgetOffset();
47897:     pt += docPt.ConvertAppUnits(currAPD, aAPD);
47897:     *aOffset = pt;
    1:   }
    1:   return v->GetWidget();
    1: }
    1: 
79445: bool nsIView::IsRoot() const
    1: {
    1:   NS_ASSERTION(mViewManager != nsnull," View manager is null in nsView::IsRoot()");
64435:   return mViewManager->GetRootViewImpl() == this;
    1: }
    1: 
79445: bool nsIView::ExternalIsRoot() const
    1: {
    1:   return nsIView::IsRoot();
    1: }
 8292: 
 8292: void
 8292: nsIView::SetDeletionObserver(nsWeakView* aDeletionObserver)
 8292: {
 8292:   if (mDeletionObserver && aDeletionObserver) {
 8292:     aDeletionObserver->SetPrevious(mDeletionObserver);
 8292:   }
 8292:   mDeletionObserver = aDeletionObserver;
 8292: }
47897: 
51042: nsView*
51042: nsIView::Impl()
51042: {
51042:   return static_cast<nsView*>(this);
51042: }
51042: 
51042: const nsView*
51042: nsIView::Impl() const
51042: {
51042:   return static_cast<const nsView*>(this);
51042: }
51042: 
47897: nsRect
47897: nsView::GetBoundsInParentUnits() const
47897: {
47897:   nsView* parent = GetParent();
47897:   nsViewManager* VM = GetViewManager();
64435:   if (this != VM->GetRootViewImpl() || !parent) {
47897:     return mDimBounds;
47897:   }
47897:   PRInt32 ourAPD = VM->AppUnitsPerDevPixel();
47897:   PRInt32 parentAPD = parent->GetViewManager()->AppUnitsPerDevPixel();
47897:   return mDimBounds.ConvertAppUnitsRoundOut(ourAPD, parentAPD);
47897: }
47897: 
47897: nsPoint
69702: nsIView::ConvertFromParentCoords(nsPoint aPt) const
47897: {
69702:   const nsView* view = static_cast<const nsView*>(this);
69702:   const nsView* parent = view->GetParent();
47897:   if (parent) {
47897:     aPt = aPt.ConvertAppUnits(parent->GetViewManager()->AppUnitsPerDevPixel(),
69702:                               view->GetViewManager()->AppUnitsPerDevPixel());
47897:   }
47897:   aPt -= GetPosition();
47897:   return aPt;
47897: }
