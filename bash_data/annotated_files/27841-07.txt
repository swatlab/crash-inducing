    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=80: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: //
    1: // Eric Vaughan
    1: // Netscape Communications
    1: //
    1: // See documentation in associated header file
    1: //
    1: 
    1: // How boxes layout
    1: // ----------------
    1: // Boxes layout a bit differently than html. html does a bottom up layout. Where boxes do a top down.
    1: // 1) First thing a box does it goes out and askes each child for its min, max, and preferred sizes.
    1: // 2) It then adds them up to determine its size.
    1: // 3) If the box was asked to layout it self intrinically it will layout its children at their preferred size
    1: //    otherwise it will layout the child at the size it was told to. It will squeeze or stretch its children if 
    1: //    Necessary.
    1: //
    1: // However there is a catch. Some html components like block frames can not determine their preferred size. 
    1: // this is their size if they were laid out intrinsically. So the box will flow the child to determine this can
    1: // cache the value.
    1: 
    1: // Boxes and Incremental Reflow
    1: // ----------------------------
    1: // Boxes layout out top down by adding up their children's min, max, and preferred sizes. Only problem is if a incremental
    1: // reflow occurs. The preferred size of a child deep in the hierarchy could change. And this could change
    1: // any number of syblings around the box. Basically any children in the reflow chain must have their caches cleared
    1: // so when asked for there current size they can relayout themselves. 
    1: 
    1: #include "nsBoxLayoutState.h"
    1: #include "nsBoxFrame.h"
    1: #include "nsStyleContext.h"
    1: #include "nsPresContext.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsIContent.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIView.h"
    1: #include "nsIPresShell.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIBoxLayout.h"
    1: #include "nsSprocketLayout.h"
    1: #include "nsIDocument.h"
    1: #include "nsIScrollableFrame.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsIScrollableView.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsITheme.h"
    1: #include "nsTransform2D.h"
    1: #include "nsIEventStateManager.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsIDOMEvent.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsContentUtils.h"
    1: #include "nsDisplayList.h"
    1: 
    1: // Needed for Print Preview
    1: #include "nsIDocument.h"
    1: #include "nsIURI.h"
    1: 
    1: 
    1: static NS_DEFINE_IID(kWidgetCID, NS_CHILD_CID);
    1: 
    1: //define DEBUG_REDRAW
    1: 
    1: #define DEBUG_SPRING_SIZE 8
    1: #define DEBUG_BORDER_SIZE 2
    1: #define COIL_SIZE 8
    1: 
    1: //#define TEST_SANITY
    1: 
    1: #ifdef DEBUG_rods
    1: //#define DO_NOISY_REFLOW
    1: #endif
    1: 
    1: #ifdef DEBUG_LAYOUT
    1: PRBool nsBoxFrame::gDebug = PR_FALSE;
    1: nsIBox* nsBoxFrame::mDebugChild = nsnull;
    1: #endif
    1: 
    1: nsIFrame*
    1: NS_NewBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRBool aIsRoot, nsIBoxLayout* aLayoutManager)
    1: {
    1:   return new (aPresShell) nsBoxFrame(aPresShell, aContext, aIsRoot, aLayoutManager);
    1: } // NS_NewBoxFrame
    1: 
23947: nsIFrame*
23947: NS_NewBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
23947: {
23947:   return new (aPresShell) nsBoxFrame(aPresShell, aContext);
23947: }
23947: 
    1: nsBoxFrame::nsBoxFrame(nsIPresShell* aPresShell,
    1:                        nsStyleContext* aContext,
    1:                        PRBool aIsRoot,
    1:                        nsIBoxLayout* aLayoutManager) :
 2547:   nsContainerFrame(aContext),
 2547:   mMouseThrough(unset)
    1: {
    1:   mState |= NS_STATE_IS_HORIZONTAL;
    1:   mState |= NS_STATE_AUTO_STRETCH;
    1: 
    1:   if (aIsRoot) 
    1:      mState |= NS_STATE_IS_ROOT;
    1: 
    1:   mValign = vAlign_Top;
    1:   mHalign = hAlign_Left;
    1:   
    1:   // if no layout manager specified us the static sprocket layout
    1:   nsCOMPtr<nsIBoxLayout> layout = aLayoutManager;
    1: 
    1:   if (layout == nsnull) {
    1:     NS_NewSprocketLayout(aPresShell, layout);
    1:   }
    1: 
    1:   SetLayoutManager(layout);
    1: }
    1: 
    1: nsBoxFrame::~nsBoxFrame()
    1: {
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::SetInitialChildList(nsIAtom*        aListName,
    1:                                 nsIFrame*       aChildList)
    1: {
    1:   nsresult r = nsContainerFrame::SetInitialChildList(aListName, aChildList);
    1:   if (r == NS_OK) {
    1:     // initialize our list of infos.
  238:     nsBoxLayoutState state(PresContext());
    1:     CheckBoxOrder(state);
    1:     if (mLayoutManager)
    1:       mLayoutManager->ChildrenSet(this, state, mFrames.FirstChild());
    1:   } else {
    1:     NS_WARNING("Warning add child failed!!\n");
    1:   }
    1: 
    1:   return r;
    1: }
    1: 
20441: /* virtual */ void
20836: nsBoxFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
    1: {
20836:   nsContainerFrame::DidSetStyleContext(aOldStyleContext);
20441: 
    1:   // The values that CacheAttributes() computes depend on our style,
    1:   // so we need to recompute them here...
    1:   CacheAttributes();
    1: }
    1: 
    1: /**
    1:  * Initialize us. This is a good time to get the alignment of the box
    1:  */
    1: NS_IMETHODIMP
    1: nsBoxFrame::Init(nsIContent*      aContent,
    1:                  nsIFrame*        aParent,
    1:                  nsIFrame*        aPrevInFlow)
    1: {
    1:   nsresult  rv = nsContainerFrame::Init(aContent, aParent, aPrevInFlow);
 1412:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   MarkIntrinsicWidthsDirty();
    1: 
    1:   // see if we need a widget
    1:   if (aParent && aParent->IsBoxFrame()) {
    1:     if (aParent->ChildrenMustHaveWidgets()) {
23395:         rv = nsHTMLContainerFrame::CreateViewForFrame(this, PR_TRUE);
 1412:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         nsIView* view = GetView();
    1:         if (!view->HasWidget())
    1:            view->CreateWidget(kWidgetCID);   
    1:     }
    1:   }
    1: 
    1:   CacheAttributes();
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:     // if we are root and this
    1:   if (mState & NS_STATE_IS_ROOT) 
    1:       GetDebugPref(GetPresContext());
    1: #endif
    1: 
 2547:   mMouseThrough = unset;
 2547: 
 2547:   UpdateMouseThrough();
 2547: 
    1:   // register access key
    1:   rv = RegUnregAccessKey(PR_TRUE);
    1: 
    1:   return rv;
    1: }
    1: 
 2547: void nsBoxFrame::UpdateMouseThrough()
 2547: {
 2547:   if (mContent) {
 2547:     static nsIContent::AttrValuesArray strings[] =
 2547:       {&nsGkAtoms::never, &nsGkAtoms::always, nsnull};
 2547:     static const eMouseThrough values[] = {never, always};
 2547:     PRInt32 index = mContent->FindAttrValueIn(kNameSpaceID_None,
 2547:         nsGkAtoms::mousethrough, strings, eCaseMatters);
 2547:     if (index >= 0) {
 2547:       mMouseThrough = values[index];
 2547:     }
 2547:   }
 2547: }
 2547: 
 2547: PRBool
 2547: nsBoxFrame::GetMouseThrough() const
 2547: {
 2547:   switch(mMouseThrough)
 2547:   {
 2547:     case always:
 2547:       return PR_TRUE;
 2547:     case never:
 2547:       return PR_FALSE;
 2547:     case unset:
 2547:       if (mParent && mParent->IsBoxFrame())
 2547:         return mParent->GetMouseThrough();
 2547:   }
 2547: 
 2547:   return PR_FALSE;
 2547: }
 2547: 
    1: void
    1: nsBoxFrame::CacheAttributes()
    1: {
    1:   /*
    1:   printf("Caching: ");
    1:   DumpBox(stdout);
    1:   printf("\n");
    1:    */
    1: 
    1:   mValign = vAlign_Top;
    1:   mHalign = hAlign_Left;
    1: 
    1:   PRBool orient = PR_FALSE;
    1:   GetInitialOrientation(orient); 
    1:   if (orient)
    1:     mState |= NS_STATE_IS_HORIZONTAL;
    1:   else
    1:     mState &= ~NS_STATE_IS_HORIZONTAL;
    1: 
    1:   PRBool normal = PR_TRUE;
    1:   GetInitialDirection(normal); 
    1:   if (normal)
    1:     mState |= NS_STATE_IS_DIRECTION_NORMAL;
    1:   else
    1:     mState &= ~NS_STATE_IS_DIRECTION_NORMAL;
    1: 
    1:   GetInitialVAlignment(mValign);
    1:   GetInitialHAlignment(mHalign);
    1:   
    1:   PRBool equalSize = PR_FALSE;
    1:   GetInitialEqualSize(equalSize); 
    1:   if (equalSize)
    1:         mState |= NS_STATE_EQUAL_SIZE;
    1:     else
    1:         mState &= ~NS_STATE_EQUAL_SIZE;
    1: 
 6770:   PRBool autostretch = !!(mState & NS_STATE_AUTO_STRETCH);
    1:   GetInitialAutoStretch(autostretch);
    1:   if (autostretch)
    1:         mState |= NS_STATE_AUTO_STRETCH;
    1:      else
    1:         mState &= ~NS_STATE_AUTO_STRETCH;
    1: 
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:   PRBool debug = mState & NS_STATE_SET_TO_DEBUG;
    1:   PRBool debugSet = GetInitialDebug(debug); 
    1:   if (debugSet) {
    1:         mState |= NS_STATE_DEBUG_WAS_SET;
    1:         if (debug)
    1:             mState |= NS_STATE_SET_TO_DEBUG;
    1:         else
    1:             mState &= ~NS_STATE_SET_TO_DEBUG;
    1:   } else {
    1:         mState &= ~NS_STATE_DEBUG_WAS_SET;
    1:   }
    1: #endif
    1: }
    1: 
    1: #ifdef DEBUG_LAYOUT
    1: PRBool
    1: nsBoxFrame::GetInitialDebug(PRBool& aDebug)
    1: {
 1749:   if (!GetContent())
    1:     return PR_FALSE;
    1: 
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::_false, &nsGkAtoms::_true, nsnull};
 1749:   PRInt32 index = GetContent()->FindAttrValueIn(kNameSpaceID_None,
    1:       nsGkAtoms::debug, strings, eCaseMatters);
    1:   if (index >= 0) {
    1:     aDebug = index == 1;
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: #endif
    1: 
    1: PRBool
    1: nsBoxFrame::GetInitialHAlignment(nsBoxFrame::Halignment& aHalign)
    1: {
 1749:   if (!GetContent())
    1:     return PR_FALSE;
    1: 
    1:   // XXXdwh Everything inside this if statement is deprecated code.
    1:   static nsIContent::AttrValuesArray alignStrings[] =
    1:     {&nsGkAtoms::left, &nsGkAtoms::right, nsnull};
    1:   static const Halignment alignValues[] = {hAlign_Left, hAlign_Right};
 1749:   PRInt32 index = GetContent()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::align,
    1:       alignStrings, eCaseMatters);
    1:   if (index >= 0) {
    1:     aHalign = alignValues[index];
    1:     return PR_TRUE;
    1:   }
    1:       
    1:   // Now that the deprecated stuff is out of the way, we move on to check the appropriate 
    1:   // attribute.  For horizontal boxes, we are checking the PACK attribute.  For vertical boxes
    1:   // we are checking the ALIGN attribute.
    1:   nsIAtom* attrName = IsHorizontal() ? nsGkAtoms::pack : nsGkAtoms::align;
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::_empty, &nsGkAtoms::start, &nsGkAtoms::center, &nsGkAtoms::end, nsnull};
    1:   static const Halignment values[] =
    1:     {hAlign_Left/*not used*/, hAlign_Left, hAlign_Center, hAlign_Right};
 1749:   index = GetContent()->FindAttrValueIn(kNameSpaceID_None, attrName,
    1:       strings, eCaseMatters);
    1: 
    1:   if (index == nsIContent::ATTR_VALUE_NO_MATCH) {
    1:     // The attr was present but had a nonsensical value. Revert to the default.
    1:     return PR_FALSE;
    1:   }
    1:   if (index > 0) {    
    1:     aHalign = values[index];
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // Now that we've checked for the attribute it's time to check CSS.  For 
    1:   // horizontal boxes we're checking PACK.  For vertical boxes we are checking
    1:   // ALIGN.
    1:   const nsStyleXUL* boxInfo = GetStyleXUL();
    1:   if (IsHorizontal()) {
    1:     switch (boxInfo->mBoxPack) {
    1:       case NS_STYLE_BOX_PACK_START:
    1:         aHalign = nsBoxFrame::hAlign_Left;
    1:         return PR_TRUE;
    1:       case NS_STYLE_BOX_PACK_CENTER:
    1:         aHalign = nsBoxFrame::hAlign_Center;
    1:         return PR_TRUE;
    1:       case NS_STYLE_BOX_PACK_END:
    1:         aHalign = nsBoxFrame::hAlign_Right;
    1:         return PR_TRUE;
    1:       default: // Nonsensical value. Just bail.
    1:         return PR_FALSE;
    1:     }
    1:   }
    1:   else {
    1:     switch (boxInfo->mBoxAlign) {
    1:       case NS_STYLE_BOX_ALIGN_START:
    1:         aHalign = nsBoxFrame::hAlign_Left;
    1:         return PR_TRUE;
    1:       case NS_STYLE_BOX_ALIGN_CENTER:
    1:         aHalign = nsBoxFrame::hAlign_Center;
    1:         return PR_TRUE;
    1:       case NS_STYLE_BOX_ALIGN_END:
    1:         aHalign = nsBoxFrame::hAlign_Right;
    1:         return PR_TRUE;
    1:       default: // Nonsensical value. Just bail.
    1:         return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsBoxFrame::GetInitialVAlignment(nsBoxFrame::Valignment& aValign)
    1: {
 1749:   if (!GetContent())
    1:     return PR_FALSE;
    1: 
    1:   static nsIContent::AttrValuesArray valignStrings[] =
    1:     {&nsGkAtoms::top, &nsGkAtoms::baseline, &nsGkAtoms::middle, &nsGkAtoms::bottom, nsnull};
    1:   static const Valignment valignValues[] =
    1:     {vAlign_Top, vAlign_BaseLine, vAlign_Middle, vAlign_Bottom};
 1749:   PRInt32 index = GetContent()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::valign,
    1:       valignStrings, eCaseMatters);
    1:   if (index >= 0) {
    1:     aValign = valignValues[index];
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // Now that the deprecated stuff is out of the way, we move on to check the appropriate 
    1:   // attribute.  For horizontal boxes, we are checking the ALIGN attribute.  For vertical boxes
    1:   // we are checking the PACK attribute.
    1:   nsIAtom* attrName = IsHorizontal() ? nsGkAtoms::align : nsGkAtoms::pack;
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::_empty, &nsGkAtoms::start, &nsGkAtoms::center,
    1:      &nsGkAtoms::baseline, &nsGkAtoms::end, nsnull};
    1:   static const Valignment values[] =
    1:     {vAlign_Top/*not used*/, vAlign_Top, vAlign_Middle, vAlign_BaseLine, vAlign_Bottom};
 1749:   index = GetContent()->FindAttrValueIn(kNameSpaceID_None, attrName,
    1:       strings, eCaseMatters);
    1:   if (index == nsIContent::ATTR_VALUE_NO_MATCH) {
    1:     // The attr was present but had a nonsensical value. Revert to the default.
    1:     return PR_FALSE;
    1:   }
    1:   if (index > 0) {
    1:     aValign = values[index];
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // Now that we've checked for the attribute it's time to check CSS.  For 
    1:   // horizontal boxes we're checking ALIGN.  For vertical boxes we are checking
    1:   // PACK.
    1:   const nsStyleXUL* boxInfo = GetStyleXUL();
    1:   if (IsHorizontal()) {
    1:     switch (boxInfo->mBoxAlign) {
    1:       case NS_STYLE_BOX_ALIGN_START:
    1:         aValign = nsBoxFrame::vAlign_Top;
    1:         return PR_TRUE;
    1:       case NS_STYLE_BOX_ALIGN_CENTER:
    1:         aValign = nsBoxFrame::vAlign_Middle;
    1:         return PR_TRUE;
    1:       case NS_STYLE_BOX_ALIGN_BASELINE:
    1:         aValign = nsBoxFrame::vAlign_BaseLine;
    1:         return PR_TRUE;
    1:       case NS_STYLE_BOX_ALIGN_END:
    1:         aValign = nsBoxFrame::vAlign_Bottom;
    1:         return PR_TRUE;
    1:       default: // Nonsensical value. Just bail.
    1:         return PR_FALSE;
    1:     }
    1:   }
    1:   else {
    1:     switch (boxInfo->mBoxPack) {
    1:       case NS_STYLE_BOX_PACK_START:
    1:         aValign = nsBoxFrame::vAlign_Top;
    1:         return PR_TRUE;
    1:       case NS_STYLE_BOX_PACK_CENTER:
    1:         aValign = nsBoxFrame::vAlign_Middle;
    1:         return PR_TRUE;
    1:       case NS_STYLE_BOX_PACK_END:
    1:         aValign = nsBoxFrame::vAlign_Bottom;
    1:         return PR_TRUE;
    1:       default: // Nonsensical value. Just bail.
    1:         return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: void
    1: nsBoxFrame::GetInitialOrientation(PRBool& aIsHorizontal)
    1: {
    1:  // see if we are a vertical or horizontal box.
 1749:   if (!GetContent())
    1:     return;
    1: 
    1:   // Check the style system first.
    1:   const nsStyleXUL* boxInfo = GetStyleXUL();
    1:   if (boxInfo->mBoxOrient == NS_STYLE_BOX_ORIENT_HORIZONTAL)
    1:     aIsHorizontal = PR_TRUE;
    1:   else 
    1:     aIsHorizontal = PR_FALSE;
    1: 
    1:   // Now see if we have an attribute.  The attribute overrides
    1:   // the style system value.
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::vertical, &nsGkAtoms::horizontal, nsnull};
 1749:   PRInt32 index = GetContent()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::orient,
    1:       strings, eCaseMatters);
    1:   if (index >= 0) {
    1:     aIsHorizontal = index == 1;
    1:   }
    1: }
    1: 
    1: void
    1: nsBoxFrame::GetInitialDirection(PRBool& aIsNormal)
    1: {
 1749:   if (!GetContent())
    1:     return;
    1: 
    1:   if (IsHorizontal()) {
    1:     // For horizontal boxes only, we initialize our value based off the CSS 'direction' property.
    1:     // This means that BiDI users will end up with horizontally inverted chrome.
    1:     aIsNormal = (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR); // If text runs RTL then so do we.
    1:   }
    1:   else
    1:     aIsNormal = PR_TRUE; // Assume a normal direction in the vertical case.
    1: 
    1:   // Now check the style system to see if we should invert aIsNormal.
    1:   const nsStyleXUL* boxInfo = GetStyleXUL();
    1:   if (boxInfo->mBoxDirection == NS_STYLE_BOX_DIRECTION_REVERSE)
    1:     aIsNormal = !aIsNormal; // Invert our direction.
    1:   
    1:   // Now see if we have an attribute.  The attribute overrides
    1:   // the style system value.
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::reverse, &nsGkAtoms::ltr, &nsGkAtoms::rtl, nsnull};
 1749:   PRInt32 index = GetContent()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::dir,
    1:       strings, eCaseMatters);
    1:   if (index >= 0) {
    1:     PRPackedBool values[] = {!aIsNormal, PR_TRUE, PR_FALSE};
    1:     aIsNormal = values[index];
    1:   }
    1: }
    1: 
    1: /* Returns true if it was set.
    1:  */
    1: PRBool
    1: nsBoxFrame::GetInitialEqualSize(PRBool& aEqualSize)
    1: {
    1:  // see if we are a vertical or horizontal box.
 1749:   if (!GetContent())
    1:      return PR_FALSE;
    1: 
 1749:   if (GetContent()->AttrValueIs(kNameSpaceID_None, nsGkAtoms::equalsize,
    1:                            nsGkAtoms::always, eCaseMatters)) {
    1:     aEqualSize = PR_TRUE;
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1: 
    1: /* Returns true if it was set.
    1:  */
    1: PRBool
    1: nsBoxFrame::GetInitialAutoStretch(PRBool& aStretch)
    1: {
 1749:   if (!GetContent())
    1:      return PR_FALSE;
    1:   
    1:   // Check the align attribute.
    1:   static nsIContent::AttrValuesArray strings[] =
    1:     {&nsGkAtoms::_empty, &nsGkAtoms::stretch, nsnull};
 1749:   PRInt32 index = GetContent()->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::align,
    1:       strings, eCaseMatters);
    1:   if (index != nsIContent::ATTR_MISSING && index != 0) {
    1:     aStretch = index == 1;
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // Check the CSS box-align property.
    1:   const nsStyleXUL* boxInfo = GetStyleXUL();
    1:   aStretch = (boxInfo->mBoxAlign == NS_STYLE_BOX_ALIGN_STRETCH);
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::DidReflow(nsPresContext*           aPresContext,
    1:                       const nsHTMLReflowState*  aReflowState,
    1:                       nsDidReflowStatus         aStatus)
    1: {
    1:   nsFrameState preserveBits =
    1:     mState & (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN);
    1:   nsresult rv = nsFrame::DidReflow(aPresContext, aReflowState, aStatus);
    1:   mState |= preserveBits;
    1:   return rv;
    1: }
    1: 
 6876: PRBool
 6876: nsBoxFrame::HonorPrintBackgroundSettings()
 6876: {
12250:   return (!mContent || !mContent->IsInNativeAnonymousSubtree()) &&
 6876:     nsContainerFrame::HonorPrintBackgroundSettings();
 6876: }
 6876: 
    1: #ifdef DO_NOISY_REFLOW
    1: static int myCounter = 0;
    1: static void printSize(char * aDesc, nscoord aSize) 
    1: {
    1:   printf(" %s: ", aDesc);
    1:   if (aSize == NS_UNCONSTRAINEDSIZE) {
    1:     printf("UC");
    1:   } else {
    1:     printf("%d", aSize);
    1:   }
    1: }
    1: #endif
    1: 
    1: /* virtual */ nscoord
    1: nsBoxFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result;
    1:   DISPLAY_MIN_WIDTH(this, result);
    1: 
  238:   nsBoxLayoutState state(PresContext(), aRenderingContext);
    1:   nsSize minSize = GetMinSize(state);
    1: 
    1:   // GetMinSize returns border-box width, and we want to return content
    1:   // width.  Since Reflow uses the reflow state's border and padding, we
    1:   // actually just want to subtract what GetMinSize added, which is the
    1:   // result of GetBorderAndPadding.
    1:   nsMargin bp;
    1:   GetBorderAndPadding(bp);
    1: 
    1:   result = minSize.width - bp.LeftRight();
16269:   result = PR_MAX(result, 0);
    1: 
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nscoord
    1: nsBoxFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   nscoord result;
    1:   DISPLAY_PREF_WIDTH(this, result);
    1: 
  238:   nsBoxLayoutState state(PresContext(), aRenderingContext);
    1:   nsSize prefSize = GetPrefSize(state);
    1: 
    1:   // GetPrefSize returns border-box width, and we want to return content
    1:   // width.  Since Reflow uses the reflow state's border and padding, we
    1:   // actually just want to subtract what GetPrefSize added, which is the
    1:   // result of GetBorderAndPadding.
    1:   nsMargin bp;
    1:   GetBorderAndPadding(bp);
    1: 
    1:   result = prefSize.width - bp.LeftRight();
16269:   result = PR_MAX(result, 0);
    1: 
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::Reflow(nsPresContext*          aPresContext,
    1:                    nsHTMLReflowMetrics&     aDesiredSize,
    1:                    const nsHTMLReflowState& aReflowState,
    1:                    nsReflowStatus&          aStatus)
    1: {
    1:   // If you make changes to this method, please keep nsLeafBoxFrame::Reflow
    1:   // in sync, if the changes are applicable there.
    1: 
    1:   DO_GLOBAL_REFLOW_COUNT("nsBoxFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1: 
18383:   NS_ASSERTION(aReflowState.ComputedWidth() >=0 &&
18383:                aReflowState.ComputedHeight() >= 0, "Computed Size < 0");
    1: 
    1: #ifdef DO_NOISY_REFLOW
    1:   printf("\n-------------Starting BoxFrame Reflow ----------------------------\n");
    1:   printf("%p ** nsBF::Reflow %d ", this, myCounter++);
    1:   
    1:   printSize("AW", aReflowState.availableWidth);
    1:   printSize("AH", aReflowState.availableHeight);
    1:   printSize("CW", aReflowState.ComputedWidth());
 4166:   printSize("CH", aReflowState.ComputedHeight());
    1: 
    1:   printf(" *\n");
    1: 
    1: #endif
    1: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1: 
    1:   // create the layout state
14159:   nsBoxLayoutState state(aPresContext, aReflowState.rendContext,
14159:                          aReflowState.mReflowDepth);
    1: 
 4166:   nsSize computedSize(aReflowState.ComputedWidth(),aReflowState.ComputedHeight());
    1: 
    1:   nsMargin m;
    1:   m = aReflowState.mComputedBorderPadding;
    1:   // GetBorderAndPadding(m);
    1: 
    1:   nsSize prefSize(0,0);
    1: 
    1:   // if we are told to layout intrinsic then get our preferred size.
    1:   NS_ASSERTION(computedSize.width != NS_INTRINSICSIZE,
    1:                "computed width should always be computed");
    1:   if (computedSize.height == NS_INTRINSICSIZE) {
    1:     prefSize = GetPrefSize(state);
    1:     nsSize minSize = GetMinSize(state);
    1:     nsSize maxSize = GetMaxSize(state);
 9862:     prefSize = BoundsCheck(minSize, prefSize, maxSize);
    1:   }
    1: 
    1:   // get our desiredSize
    1:   computedSize.width += m.left + m.right;
    1: 
 4166:   if (aReflowState.ComputedHeight() == NS_INTRINSICSIZE) {
    1:     computedSize.height = prefSize.height;
    1:   } else {
    1:     computedSize.height += m.top + m.bottom;
    1:   }
    1: 
    1:   // handle reflow state min and max sizes
    1: 
    1:   if (computedSize.width > aReflowState.mComputedMaxWidth)
    1:     computedSize.width = aReflowState.mComputedMaxWidth;
    1: 
    1:   if (computedSize.height > aReflowState.mComputedMaxHeight)
    1:     computedSize.height = aReflowState.mComputedMaxHeight;
    1: 
    1:   if (computedSize.width < aReflowState.mComputedMinWidth)
    1:     computedSize.width = aReflowState.mComputedMinWidth;
    1: 
    1:   if (computedSize.height < aReflowState.mComputedMinHeight)
    1:     computedSize.height = aReflowState.mComputedMinHeight;
    1: 
    1:   nsRect r(mRect.x, mRect.y, computedSize.width, computedSize.height);
    1: 
    1:   SetBounds(state, r);
    1:  
    1:   // layout our children
    1:   Layout(state);
    1:   
    1:   // ok our child could have gotten bigger. So lets get its bounds
    1:   
    1:   // get the ascent
    1:   nscoord ascent = mRect.height;
    1: 
    1:   // getting the ascent could be a lot of work. Don't get it if
    1:   // we are the root. The viewport doesn't care about it.
    1:   if (!(mState & NS_STATE_IS_ROOT)) {
    1:     ascent = GetBoxAscent(state);
    1:   }
    1: 
    1:   aDesiredSize.width  = mRect.width;
    1:   aDesiredSize.height = mRect.height;
    1:   aDesiredSize.ascent = ascent;
    1: 
 1717:   aDesiredSize.mOverflowArea = GetOverflowRect();
    1: 
    1: #ifdef DO_NOISY_REFLOW
    1:   {
    1:     printf("%p ** nsBF(done) W:%d H:%d  ", this, aDesiredSize.width, aDesiredSize.height);
    1: 
    1:     if (maxElementSize) {
    1:       printf("MW:%d\n", *maxElementWidth); 
    1:     } else {
    1:       printf("MW:?\n"); 
    1:     }
    1: 
    1:   }
    1: #endif
    1: 
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
    1:   return NS_OK;
    1: }
    1: 
    1: nsSize
    1: nsBoxFrame::GetPrefSize(nsBoxLayoutState& aBoxLayoutState)
    1: {
  918:   NS_ASSERTION(aBoxLayoutState.GetRenderingContext(),
  918:                "must have rendering context");
  918: 
    1:   nsSize size(0,0);
    1:   DISPLAY_PREF_SIZE(this, size);
    1:   if (!DoesNeedRecalc(mPrefSize)) {
    1:      size = mPrefSize;
    1:      return size;
    1:   }
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aBoxLayoutState);
    1: #endif
    1: 
    1:   if (IsCollapsed(aBoxLayoutState))
    1:     return size;
    1: 
    1:   // if the size was not completely redefined in CSS then ask our children
    1:   if (!nsIBox::AddCSSPrefSize(aBoxLayoutState, this, size))
    1:   {
    1:     if (mLayoutManager) {
10061:       size = mLayoutManager->GetPrefSize(this, aBoxLayoutState);
    1:       nsIBox::AddCSSPrefSize(aBoxLayoutState, this, size);
    1:     } else
    1:       size = nsBox::GetPrefSize(aBoxLayoutState);
    1:   }
    1: 
    1:   nsSize minSize = GetMinSize(aBoxLayoutState);
    1:   nsSize maxSize = GetMaxSize(aBoxLayoutState);
 9862:   mPrefSize = BoundsCheck(minSize, size, maxSize);
    1:  
 9862:   return mPrefSize;
    1: }
    1: 
    1: nscoord
    1: nsBoxFrame::GetBoxAscent(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:   if (!DoesNeedRecalc(mAscent))
    1:      return mAscent;
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aBoxLayoutState);
    1: #endif
    1: 
    1:   if (IsCollapsed(aBoxLayoutState))
    1:     return 0;
    1: 
    1:   if (mLayoutManager)
10061:     mAscent = mLayoutManager->GetAscent(this, aBoxLayoutState);
    1:   else
    1:     mAscent = nsBox::GetBoxAscent(aBoxLayoutState);
    1: 
    1:   return mAscent;
    1: }
    1: 
    1: nsSize
    1: nsBoxFrame::GetMinSize(nsBoxLayoutState& aBoxLayoutState)
    1: {
  918:   NS_ASSERTION(aBoxLayoutState.GetRenderingContext(),
  918:                "must have rendering context");
  918: 
    1:   nsSize size(0,0);
    1:   DISPLAY_MIN_SIZE(this, size);
    1:   if (!DoesNeedRecalc(mMinSize)) {
    1:     size = mMinSize;
    1:     return size;
    1:   }
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aBoxLayoutState);
    1: #endif
    1: 
    1:   if (IsCollapsed(aBoxLayoutState))
    1:     return size;
    1: 
    1:   // if the size was not completely redefined in CSS then ask our children
    1:   if (!nsIBox::AddCSSMinSize(aBoxLayoutState, this, size))
    1:   {
    1:     if (mLayoutManager) {
10061:       size = mLayoutManager->GetMinSize(this, aBoxLayoutState);
    1:       nsIBox::AddCSSMinSize(aBoxLayoutState, this, size);
    1:     } else {
    1:       size = nsBox::GetMinSize(aBoxLayoutState);
    1:     }
    1:   }
    1:   
    1:   mMinSize = size;
    1: 
    1:   return size;
    1: }
    1: 
    1: nsSize
    1: nsBoxFrame::GetMaxSize(nsBoxLayoutState& aBoxLayoutState)
    1: {
  918:   NS_ASSERTION(aBoxLayoutState.GetRenderingContext(),
  918:                "must have rendering context");
  918: 
    1:   nsSize size(NS_INTRINSICSIZE, NS_INTRINSICSIZE);
    1:   DISPLAY_MAX_SIZE(this, size);
    1:   if (!DoesNeedRecalc(mMaxSize)) {
    1:     size = mMaxSize;
    1:     return size;
    1:   }
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:   PropagateDebug(aBoxLayoutState);
    1: #endif
    1: 
    1:   if (IsCollapsed(aBoxLayoutState))
    1:     return size;
    1: 
    1:   // if the size was not completely redefined in CSS then ask our children
    1:   if (!nsIBox::AddCSSMaxSize(aBoxLayoutState, this, size))
    1:   {
    1:     if (mLayoutManager) {
10061:       size = mLayoutManager->GetMaxSize(this, aBoxLayoutState);
    1:       nsIBox::AddCSSMaxSize(aBoxLayoutState, this, size);
    1:     } else {
    1:       size = nsBox::GetMaxSize(aBoxLayoutState);
    1:     }
    1:   }
    1: 
    1:   mMaxSize = size;
    1: 
    1:   return size;
    1: }
    1: 
    1: nscoord
    1: nsBoxFrame::GetFlex(nsBoxLayoutState& aBoxLayoutState)
    1: {
    1:   if (!DoesNeedRecalc(mFlex))
    1:      return mFlex;
    1: 
    1:   mFlex = nsBox::GetFlex(aBoxLayoutState);
    1: 
    1:   return mFlex;
    1: }
    1: 
    1: /**
    1:  * If subclassing please subclass this method not layout. 
    1:  * layout will call this method.
    1:  */
    1: NS_IMETHODIMP
    1: nsBoxFrame::DoLayout(nsBoxLayoutState& aState)
    1: {
    1:   PRUint32 oldFlags = aState.LayoutFlags();
    1:   aState.SetLayoutFlags(0);
    1: 
    1:   nsresult rv = NS_OK;
    1:   if (mLayoutManager)
    1:     rv = mLayoutManager->Layout(this, aState);
    1: 
    1:   aState.SetLayoutFlags(oldFlags);
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsBoxFrame::Destroy()
    1: {
    1:   // unregister access key
    1:   RegUnregAccessKey(PR_FALSE);
    1: 
    1:   // clean up the container box's layout manager and child boxes
    1:   SetLayoutManager(nsnull);
    1: 
    1:   nsContainerFrame::Destroy();
    1: } 
    1: 
    1: #ifdef DEBUG_LAYOUT
    1: NS_IMETHODIMP
    1: nsBoxFrame::SetDebug(nsBoxLayoutState& aState, PRBool aDebug)
    1: {
    1:   // see if our state matches the given debug state
    1:   PRBool debugSet = mState & NS_STATE_CURRENTLY_IN_DEBUG;
    1:   PRBool debugChanged = (!aDebug && debugSet) || (aDebug && !debugSet);
    1: 
    1:   // if it doesn't then tell each child below us the new debug state
    1:   if (debugChanged)
    1:   {
    1:      if (aDebug) {
    1:          mState |= NS_STATE_CURRENTLY_IN_DEBUG;
    1:      } else {
    1:          mState &= ~NS_STATE_CURRENTLY_IN_DEBUG;
    1:      }
    1:  
    1:      SetDebugOnChildList(aState, mFirstChild, aDebug);
    1: 
    1:     MarkIntrinsicWidthsDirty();
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: /* virtual */ void
    1: nsBoxFrame::MarkIntrinsicWidthsDirty()
    1: {
    1:   SizeNeedsRecalc(mPrefSize);
    1:   SizeNeedsRecalc(mMinSize);
    1:   SizeNeedsRecalc(mMaxSize);
    1:   CoordNeedsRecalc(mFlex);
    1:   CoordNeedsRecalc(mAscent);
    1: 
    1:   if (mLayoutManager) {
  238:     nsBoxLayoutState state(PresContext());
    1:     mLayoutManager->IntrinsicWidthsDirty(this, state);
    1:   }
    1: 
    1:   // Don't call base class method, since everything it does is within an
    1:   // IsBoxWrapped check.
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::RemoveFrame(nsIAtom*        aListName,
    1:                         nsIFrame*       aOldFrame)
    1: {
    1:   NS_PRECONDITION(!aListName, "We don't support out-of-flow kids");
  238:   nsPresContext* presContext = PresContext();
    1:   nsBoxLayoutState state(presContext);
    1: 
    1:   // remove the child frame
    1:   mFrames.RemoveFrame(aOldFrame);
    1: 
    1:   // notify the layout manager
    1:   if (mLayoutManager)
    1:     mLayoutManager->ChildrenRemoved(this, state, aOldFrame);
    1: 
    1:   // destroy the child frame
    1:   aOldFrame->Destroy();
    1: 
    1:   // mark us dirty and generate a reflow command
  238:   PresContext()->PresShell()->
 1158:     FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                      NS_FRAME_HAS_DIRTY_CHILDREN);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::InsertFrames(nsIAtom*        aListName,
    1:                          nsIFrame*       aPrevFrame,
    1:                          nsIFrame*       aFrameList)
    1: {
    1:    NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
    1:                 "inserting after sibling frame with different parent");
 7067:    NS_ASSERTION(!aPrevFrame || mFrames.ContainsFrame(aPrevFrame),
 7067:                 "inserting after sibling frame not in our child list");
    1:    NS_PRECONDITION(!aListName, "We don't support out-of-flow kids");
  238:    nsBoxLayoutState state(PresContext());
    1: 
    1:    // insert the child frames
    1:    mFrames.InsertFrames(this, aPrevFrame, aFrameList);
    1: 
    1:    // notify the layout manager
    1:    if (mLayoutManager)
    1:      mLayoutManager->ChildrenInserted(this, state, aPrevFrame, aFrameList);
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:    // if we are in debug make sure our children are in debug as well.
    1:    if (mState & NS_STATE_CURRENTLY_IN_DEBUG)
    1:        SetDebugOnChildList(state, mFrames.FirstChild(), PR_TRUE);
    1: #endif
    1: 
  238:    PresContext()->PresShell()->
 1158:      FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                       NS_FRAME_HAS_DIRTY_CHILDREN);
    1:    return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::AppendFrames(nsIAtom*        aListName,
    1:                          nsIFrame*       aFrameList)
    1: {
    1:    NS_PRECONDITION(!aListName, "We don't support out-of-flow kids");
  238:    nsBoxLayoutState state(PresContext());
    1: 
    1:    // append the new frames
    1:    mFrames.AppendFrames(this, aFrameList);
    1: 
    1:    // notify the layout manager
    1:    if (mLayoutManager)
    1:      mLayoutManager->ChildrenAppended(this, state, aFrameList);
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:    // if we are in debug make sure our children are in debug as well.
    1:    if (mState & NS_STATE_CURRENTLY_IN_DEBUG)
    1:        SetDebugOnChildList(state, mFrames.FirstChild(), PR_TRUE);
    1: #endif
    1: 
 1158:    // XXXbz why is this NS_FRAME_FIRST_REFLOW check here?
    1:    if (!(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
  238:      PresContext()->PresShell()->
 1158:        FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                         NS_FRAME_HAS_DIRTY_CHILDREN);
    1:    }
    1:    return NS_OK;
    1: }
    1: 
 7189: /* virtual */ nsIFrame*
 7189: nsBoxFrame::GetContentInsertionFrame()
 7189: {
 7189:   if (GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK)
 7189:     return GetFirstChild(nsnull)->GetContentInsertionFrame();
 7189:   return nsContainerFrame::GetContentInsertionFrame();
 7189: }
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::AttributeChanged(PRInt32 aNameSpaceID,
    1:                              nsIAtom* aAttribute,
    1:                              PRInt32 aModType)
    1: {
    1:   nsresult rv = nsContainerFrame::AttributeChanged(aNameSpaceID, aAttribute,
    1:                                                    aModType);
    1: 
    1:   // Ignore 'width', 'height', 'screenX', 'screenY' and 'sizemode' on a
    1:   // <window>.
    1:   nsIAtom *tag = mContent->Tag();
    1:   if ((tag == nsGkAtoms::window ||
    1:        tag == nsGkAtoms::page ||
    1:        tag == nsGkAtoms::dialog ||
    1:        tag == nsGkAtoms::wizard) &&
    1:       (nsGkAtoms::width == aAttribute ||
    1:        nsGkAtoms::height == aAttribute ||
    1:        nsGkAtoms::screenX == aAttribute ||
    1:        nsGkAtoms::screenY == aAttribute ||
    1:        nsGkAtoms::sizemode == aAttribute)) {
    1:     return rv;
    1:   }
    1: 
    1:   if (aAttribute == nsGkAtoms::width       ||
    1:       aAttribute == nsGkAtoms::height      ||
    1:       aAttribute == nsGkAtoms::align       ||
    1:       aAttribute == nsGkAtoms::valign      ||
    1:       aAttribute == nsGkAtoms::left        ||
    1:       aAttribute == nsGkAtoms::top         ||
    1:       aAttribute == nsGkAtoms::minwidth     ||
    1:       aAttribute == nsGkAtoms::maxwidth     ||
    1:       aAttribute == nsGkAtoms::minheight    ||
    1:       aAttribute == nsGkAtoms::maxheight    ||
    1:       aAttribute == nsGkAtoms::flex         ||
    1:       aAttribute == nsGkAtoms::orient       ||
    1:       aAttribute == nsGkAtoms::pack         ||
    1:       aAttribute == nsGkAtoms::dir          ||
 2547:       aAttribute == nsGkAtoms::mousethrough ||
    1:       aAttribute == nsGkAtoms::equalsize) {
    1: 
    1:     if (aAttribute == nsGkAtoms::align  ||
    1:         aAttribute == nsGkAtoms::valign ||
    1:         aAttribute == nsGkAtoms::orient  ||
    1:         aAttribute == nsGkAtoms::pack    ||
    1: #ifdef DEBUG_LAYOUT
    1:         aAttribute == nsGkAtoms::debug   ||
    1: #endif
    1:         aAttribute == nsGkAtoms::dir) {
    1: 
    1:       mValign = nsBoxFrame::vAlign_Top;
    1:       mHalign = nsBoxFrame::hAlign_Left;
    1: 
    1:       PRBool orient = PR_TRUE;
    1:       GetInitialOrientation(orient); 
    1:       if (orient)
    1:         mState |= NS_STATE_IS_HORIZONTAL;
    1:       else
    1:         mState &= ~NS_STATE_IS_HORIZONTAL;
    1: 
    1:       PRBool normal = PR_TRUE;
    1:       GetInitialDirection(normal);
    1:       if (normal)
    1:         mState |= NS_STATE_IS_DIRECTION_NORMAL;
    1:       else
    1:         mState &= ~NS_STATE_IS_DIRECTION_NORMAL;
    1: 
    1:       GetInitialVAlignment(mValign);
    1:       GetInitialHAlignment(mHalign);
    1: 
    1:       PRBool equalSize = PR_FALSE;
    1:       GetInitialEqualSize(equalSize); 
    1:       if (equalSize)
    1:         mState |= NS_STATE_EQUAL_SIZE;
    1:       else
    1:         mState &= ~NS_STATE_EQUAL_SIZE;
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:       PRBool debug = mState & NS_STATE_SET_TO_DEBUG;
    1:       PRBool debugSet = GetInitialDebug(debug);
    1:       if (debugSet) {
    1:         mState |= NS_STATE_DEBUG_WAS_SET;
    1: 
    1:         if (debug)
    1:           mState |= NS_STATE_SET_TO_DEBUG;
    1:         else
    1:           mState &= ~NS_STATE_SET_TO_DEBUG;
    1:       } else {
    1:         mState &= ~NS_STATE_DEBUG_WAS_SET;
    1:       }
    1: #endif
    1: 
 6770:       PRBool autostretch = !!(mState & NS_STATE_AUTO_STRETCH);
    1:       GetInitialAutoStretch(autostretch);
    1:       if (autostretch)
    1:         mState |= NS_STATE_AUTO_STRETCH;
    1:       else
    1:         mState &= ~NS_STATE_AUTO_STRETCH;
    1:     }
    1:     else if (aAttribute == nsGkAtoms::left ||
    1:              aAttribute == nsGkAtoms::top) {
    1:       mState &= ~NS_STATE_STACK_NOT_POSITIONED;
    1:     }
 2547:     else if (aAttribute == nsGkAtoms::mousethrough) {
 2547:       UpdateMouseThrough();
 2547:     }
    1: 
  238:     PresContext()->PresShell()->
 1158:       FrameNeedsReflow(this, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
    1:   }
    1:   else if (aAttribute == nsGkAtoms::ordinal) {
  238:     nsBoxLayoutState state(PresContext());
 4722:     nsIBox* parent = GetParentBox();
    1:     // If our parent is not a box, there's not much we can do... but in that
    1:     // case our ordinal doesn't matter anyway, so that's ok.
 4722:     // Also don't bother with popup frames since they are kept on the 
 4722:     // nsGkAtoms::popupList and RelayoutChildAtOrdinal() only handles
 4722:     // principal children.
 4722:     if (parent && !(GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
 4722:         GetStyleDisplay()->mDisplay != NS_STYLE_DISPLAY_POPUP) {
 4722:       parent->RelayoutChildAtOrdinal(state, this);
    1:       // XXXldb Should this instead be a tree change on the child or parent?
  238:       PresContext()->PresShell()->
 1158:         FrameNeedsReflow(parent, nsIPresShell::eStyleChange,
 1158:                          NS_FRAME_IS_DIRTY);
    1:     }
    1:   }
    1:   // If the accesskey changed, register for the new value
    1:   // The old value has been unregistered in nsXULElement::SetAttr
    1:   else if (aAttribute == nsGkAtoms::accesskey) {
    1:     RegUnregAccessKey(PR_TRUE);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: #ifdef DEBUG_LAYOUT
    1: void
    1: nsBoxFrame::GetDebugPref(nsPresContext* aPresContext)
    1: {
    1:     gDebug = nsContentUtils::GetBoolPref("xul.debug.box");
    1: }
    1: 
    1: class nsDisplayXULDebug : public nsDisplayItem {
    1: public:
    1:   nsDisplayXULDebug(nsIFrame* aFrame) : nsDisplayItem(aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayXULDebug);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayXULDebug() {
    1:     MOZ_COUNT_DTOR(nsDisplayXULDebug);
    1:   }
    1: #endif
    1: 
 9799:   virtual nsIFrame* HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt,
 9799:                             HitTestState* aState) {
 3233:     static_cast<nsBoxFrame*>(mFrame)->
    1:       DisplayDebugInfoFor(this, aPt - aBuilder->ToReferenceFrame(mFrame));
    1:     return PR_TRUE;
    1:   }
    1:   virtual void Paint(nsDisplayListBuilder* aBuilder, nsIRenderingContext* aCtx,
    1:      const nsRect& aDirtyRect);
    1:   NS_DISPLAY_DECL_NAME("ComboboxFocus")
    1: };
    1: 
    1: void
    1: nsDisplayXULDebug::Paint(nsDisplayListBuilder* aBuilder,
    1:      nsIRenderingContext* aCtx, const nsRect& aDirtyRect)
    1: {
 3233:   static_cast<nsBoxFrame*>(mFrame)->
    1:     PaintXULDebugOverlay(*aCtx, aBuilder->ToReferenceFrame(mFrame));
    1: }
    1: 
    1: static void
    1: PaintXULDebugBackground(nsIFrame* aFrame, nsIRenderingContext* aCtx,
    1:                         const nsRect& aDirtyRect, nsPoint aPt)
    1: {
 3233:   static_cast<nsBoxFrame*>(aFrame)->PaintXULDebugBackground(*aCtx, aPt);
    1: }
    1: #endif
    1: 
    1: nsresult
    1: nsBoxFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                              const nsRect&           aDirtyRect,
    1:                              const nsDisplayListSet& aLists)
    1: {
    1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1: #ifdef DEBUG_LAYOUT
    1:   // REVIEW: From GetFrameForPoint
    1:   if (mState & NS_STATE_CURRENTLY_IN_DEBUG) {
    1:     rv = aLists.BorderBackground()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayGeneric(this, PaintXULDebugBackground, "XULDebugBackground"));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     rv = aLists.Outlines()->AppendNewToTop(new (aBuilder)
    1:         nsDisplayXULDebug(this));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: #endif
    1: 
    1:   rv = BuildDisplayListForChildren(aBuilder, aDirtyRect, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // see if we have to draw a selection frame around this container
    1:   return DisplaySelectionOverlay(aBuilder, aLists);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::BuildDisplayListForChildren(nsDisplayListBuilder*   aBuilder,
    1:                                         const nsRect&           aDirtyRect,
    1:                                         const nsDisplayListSet& aLists)
    1: {
    1:   nsIFrame* kid = mFrames.FirstChild();
    1:   // Put each child's background onto the BlockBorderBackgrounds list
    1:   // to emulate the existing two-layer XUL painting scheme.
    1:   nsDisplayListSet set(aLists, aLists.BlockBorderBackgrounds());
    1:   // The children should be in the right order
    1:   while (kid) {
    1:     nsresult rv = BuildDisplayListForChild(aBuilder, kid, aDirtyRect, set);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     kid = kid->GetNextSibling();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // REVIEW: PaintChildren did a few things none of which are a big deal
    1: // anymore:
    1: // * Paint some debugging rects for this frame.
    1: // This is done by nsDisplayXULDebugBackground, which goes in the
    1: // BorderBackground() layer so it isn't clipped by OVERFLOW_CLIP.
    1: // * Apply OVERFLOW_CLIP to the children.
    1: // This is now in nsFrame::BuildDisplayListForStackingContext/Child.
    1: // * Actually paint the children.
    1: // Moved to BuildDisplayList.
    1: // * Paint per-kid debug information.
    1: // This is done by nsDisplayXULDebug, which is in the Outlines()
    1: // layer so it goes on top. This means it is not clipped by OVERFLOW_CLIP,
    1: // whereas it did used to respect OVERFLOW_CLIP, but too bad.
    1: #ifdef DEBUG_LAYOUT
    1: void
    1: nsBoxFrame::PaintXULDebugBackground(nsIRenderingContext& aRenderingContext,
    1:                                     nsPoint aPt)
    1: {
    1:   nsMargin border;
    1:   GetBorder(border);
    1: 
    1:   nsMargin debugBorder;
    1:   nsMargin debugMargin;
    1:   nsMargin debugPadding;
    1: 
    1:   PRBool isHorizontal = IsHorizontal();
    1: 
    1:   GetDebugBorder(debugBorder);
    1:   PixelMarginToTwips(GetPresContext(), debugBorder);
    1: 
    1:   GetDebugMargin(debugMargin);
    1:   PixelMarginToTwips(GetPresContext(), debugMargin);
    1: 
    1:   GetDebugPadding(debugPadding);
    1:   PixelMarginToTwips(GetPresContext(), debugPadding);
    1: 
    1:   nsRect inner(mRect);
    1:   inner.MoveTo(aPt);
    1:   inner.Deflate(debugMargin);
    1:   inner.Deflate(border);
    1:   //nsRect borderRect(inner);
    1: 
    1:   nscolor color;
    1:   if (isHorizontal) {
    1:     color = NS_RGB(0,0,255);
    1:   } else {
    1:     color = NS_RGB(255,0,0);
    1:   }
    1: 
    1:   aRenderingContext.SetColor(color);
    1: 
    1:   //left
    1:   nsRect r(inner);
    1:   r.width = debugBorder.left;
    1:   aRenderingContext.FillRect(r);
    1: 
    1:   // top
    1:   r = inner;
    1:   r.height = debugBorder.top;
    1:   aRenderingContext.FillRect(r);
    1: 
    1:   //right
    1:   r = inner;
    1:   r.x = r.x + r.width - debugBorder.right;
    1:   r.width = debugBorder.right;
    1:   aRenderingContext.FillRect(r);
    1: 
    1:   //bottom
    1:   r = inner;
    1:   r.y = r.y + r.height - debugBorder.bottom;
    1:   r.height = debugBorder.bottom;
    1:   aRenderingContext.FillRect(r);
    1: 
    1:   
    1:   // if we have dirty children or we are dirty 
    1:   // place a green border around us.
 1158:   if (NS_SUBTREE_DIRTY(this)) {
    1:      nsRect dirtyr(inner);
    1:      aRenderingContext.SetColor(NS_RGB(0,255,0));
    1:      aRenderingContext.DrawRect(dirtyr);
    1:      aRenderingContext.SetColor(color);
    1:   }
    1: }
    1: 
    1: void
    1: nsBoxFrame::PaintXULDebugOverlay(nsIRenderingContext& aRenderingContext,
    1:                                  nsPoint aPt)
    1:   nsMargin border;
    1:   GetBorder(border);
    1: 
    1:   nsMargin debugMargin;
    1:   GetDebugMargin(debugMargin);
    1:   PixelMarginToTwips(GetPresContext(), debugMargin);
    1: 
    1:   nsRect inner(mRect);
    1:   inner.MoveTo(aPt);
    1:   inner.Deflate(debugMargin);
    1:   inner.Deflate(border);
    1: 
    1:   nscoord onePixel = GetPresContext()->IntScaledPixelsToTwips(1);
    1: 
    1:   kid = GetChildBox();
    1:   while (nsnull != kid) {
    1:     PRBool isHorizontal = IsHorizontal();
    1: 
    1:     nscoord x, y, borderSize, spacerSize;
    1:     
    1:     nsRect cr(kid->mRect);
    1:     nsMargin margin;
    1:     kid->GetMargin(margin);
    1:     cr.Inflate(margin);
    1:     
    1:     if (isHorizontal) 
    1:     {
    1:         cr.y = inner.y;
    1:         x = cr.x;
    1:         y = cr.y + onePixel;
    1:         spacerSize = debugBorder.top - onePixel*4;
    1:     } else {
    1:         cr.x = inner.x;
    1:         x = cr.y;
    1:         y = cr.x + onePixel;
    1:         spacerSize = debugBorder.left - onePixel*4;
    1:     }
    1: 
    1:     nsBoxLayoutState state(GetPresContext());
    1:     nscoord flex = kid->GetFlex(state);
    1: 
    1:     if (!kid->IsCollapsed(state)) {
    1:       aRenderingContext.SetColor(NS_RGB(255,255,255));
    1: 
    1:       if (isHorizontal) 
    1:           borderSize = cr.width;
    1:       else 
    1:           borderSize = cr.height;
    1:     
    1:       DrawSpacer(GetPresContext(), aRenderingContext, isHorizontal, flex, x, y, borderSize, spacerSize);
    1:     }
    1: 
    1:     kid = kid->GetNextBox();
    1:   }
    1: }
    1: #endif
    1: 
    1: #ifdef DEBUG_LAYOUT
    1: void
    1: nsBoxFrame::GetBoxName(nsAutoString& aName)
    1: {
    1:    GetFrameName(aName);
    1: }
    1: #endif
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsBoxFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Box"), aResult);
    1: }
    1: #endif
    1: 
    1: nsIAtom*
    1: nsBoxFrame::GetType() const
    1: {
    1:   return nsGkAtoms::boxFrame;
    1: }
    1: 
    1: #ifdef DEBUG_LAYOUT
    1: NS_IMETHODIMP
    1: nsBoxFrame::GetDebug(PRBool& aDebug)
    1: {
    1:   aDebug = (mState & NS_STATE_CURRENTLY_IN_DEBUG);
    1:   return NS_OK;
    1: }
    1: #endif
    1: 
    1: // REVIEW: nsBoxFrame::GetFrameForPoint is a problem because of 'mousethrough'
    1: // attribute support. Here's how it works:
    1: // * For each child frame F, we determine the target frame T(F) by recursively
    1: // invoking GetFrameForPoint on the child
    1: // * Let F' be the last child frame such that T(F') doesn't have mousethrough.
    1: // If F' exists, return T(F')
    1: // * Otherwise let F'' be the first child frame such that T(F'') is non-null.
    1: // If F'' exists, return T(F'')
    1: // * Otherwise return this frame, if this frame contains the point
    1: // * Otherwise return null
    1: // It's not clear how this should work for more complex z-ordering situations.
    1: // The basic principle seems to be that if a frame F has a descendant
    1: // 'mousethrough' frame that includes the target position, then F
    1: // will not receive events (unless it overrides GetFrameForPoint).
    1: // A 'mousethrough' frame will only receive an event if, after applying that rule,
    1: // all eligible frames are 'mousethrough'; the bottom-most inner-most 'mousethrough'
    1: // frame is then chosen (the first eligible frame reached in a
    1: // traversal of the frame tree --- pre/post is irrelevant since ancestors
    1: // of the mousethrough frames can't be eligible).
    1: // IMHO this is very bogus and adds a great deal of complexity for something
    1: // that is very rarely used. So I'm redefining 'mousethrough' to the following:
    1: // a frame with mousethrough is transparent to mouse events. This is compatible
    1: // with the way 'mousethrough' is used in Seamonkey's navigator.xul and
    1: // Firefox's browser.xul. The only other place it's used is in the 'expander'
    1: // XBL binding, which in our tree is only used by Thunderbird SMIME Advanced
    1: // Preferences, and I can't figure out what that does, so I'll have to test it.
    1: // If it's broken I'll probably just change the binding to use it more sensibly.
    1: // This new behaviour is implemented in nsDisplayList::HitTest. 
    1: // REVIEW: This debug-box stuff is annoying. I'm just going to put debug boxes
    1: // in the outline layer and avoid GetDebugBoxAt.
    1: 
    1: // REVIEW: GetCursor had debug-only event dumping code. I have replaced it
    1: // with instrumentation in nsDisplayXULDebug.
    1: 
    1: #ifdef DEBUG_LAYOUT
    1: void
    1: nsBoxFrame::DrawLine(nsIRenderingContext& aRenderingContext, PRBool aHorizontal, nscoord x1, nscoord y1, nscoord x2, nscoord y2)
    1: {
    1:     if (aHorizontal)
    1:        aRenderingContext.DrawLine(x1,y1,x2,y2);
    1:     else
    1:        aRenderingContext.DrawLine(y1,x1,y2,x2);
    1: }
    1: 
    1: void
    1: nsBoxFrame::FillRect(nsIRenderingContext& aRenderingContext, PRBool aHorizontal, nscoord x, nscoord y, nscoord width, nscoord height)
    1: {
    1:     if (aHorizontal)
    1:        aRenderingContext.FillRect(x,y,width,height);
    1:     else
    1:        aRenderingContext.FillRect(y,x,height,width);
    1: }
    1: 
    1: void 
    1: nsBoxFrame::DrawSpacer(nsPresContext* aPresContext, nsIRenderingContext& aRenderingContext, PRBool aHorizontal, PRInt32 flex, nscoord x, nscoord y, nscoord size, nscoord spacerSize)
    1: {    
    1:          nscoord onePixel = aPresContext->IntScaledPixelsToTwips(1);
    1: 
    1:      // if we do draw the coils
    1:         int distance = 0;
    1:         int center = 0;
    1:         int offset = 0;
    1:         int coilSize = COIL_SIZE*onePixel;
    1:         int halfSpacer = spacerSize/2;
    1: 
    1:         distance = size;
    1:         center = y + halfSpacer;
    1:         offset = x;
    1: 
    1:         int coils = distance/coilSize;
    1: 
    1:         int halfCoilSize = coilSize/2;
    1: 
    1:         if (flex == 0) {
    1:             DrawLine(aRenderingContext, aHorizontal, x,y + spacerSize/2, x + size, y + spacerSize/2);
    1:         } else {
    1:             for (int i=0; i < coils; i++)
    1:             {
    1:                    DrawLine(aRenderingContext, aHorizontal, offset, center+halfSpacer, offset+halfCoilSize, center-halfSpacer);
    1:                    DrawLine(aRenderingContext, aHorizontal, offset+halfCoilSize, center-halfSpacer, offset+coilSize, center+halfSpacer);
    1: 
    1:                    offset += coilSize;
    1:             }
    1:         }
    1: 
    1:         FillRect(aRenderingContext, aHorizontal, x + size - spacerSize/2, y, spacerSize/2, spacerSize);
    1:         FillRect(aRenderingContext, aHorizontal, x, y, spacerSize/2, spacerSize);
    1: 
    1:         //DrawKnob(aPresContext, aRenderingContext, x + size - spacerSize, y, spacerSize);
    1: }
    1: 
    1: void
    1: nsBoxFrame::GetDebugBorder(nsMargin& aInset)
    1: {
    1:     aInset.SizeTo(2,2,2,2);
    1: 
    1:     if (IsHorizontal()) 
    1:        aInset.top = 10;
    1:     else 
    1:        aInset.left = 10;
    1: }
    1: 
    1: void
    1: nsBoxFrame::GetDebugMargin(nsMargin& aInset)
    1: {
    1:     aInset.SizeTo(2,2,2,2);
    1: }
    1: 
    1: void
    1: nsBoxFrame::GetDebugPadding(nsMargin& aPadding)
    1: {
    1:     aPadding.SizeTo(2,2,2,2);
    1: }
    1: 
    1: void 
    1: nsBoxFrame::PixelMarginToTwips(nsPresContext* aPresContext, nsMargin& aMarginPixels)
    1: {
    1:   nscoord onePixel = nsPresContext::CSSPixelsToAppUnits(1);
    1:   aMarginPixels.left   *= onePixel;
    1:   aMarginPixels.right  *= onePixel;
    1:   aMarginPixels.top    *= onePixel;
    1:   aMarginPixels.bottom *= onePixel;
    1: }
    1: 
    1: void
    1: nsBoxFrame::GetValue(nsPresContext* aPresContext, const nsSize& a, const nsSize& b, char* ch) 
    1: {
    1:     float p2t = aPresContext->ScaledPixelsToTwips();
    1: 
    1:     char width[100];
    1:     char height[100];
    1:     
    1:     if (a.width == NS_INTRINSICSIZE)
    1:         sprintf(width,"%s","INF");
    1:     else
    1:         sprintf(width,"%d", nscoord(a.width/*/p2t*/));
    1:     
    1:     if (a.height == NS_INTRINSICSIZE)
    1:         sprintf(height,"%s","INF");
    1:     else 
    1:         sprintf(height,"%d", nscoord(a.height/*/p2t*/));
    1:     
    1: 
    1:     sprintf(ch, "(%s%s, %s%s)", width, (b.width != NS_INTRINSICSIZE ? "[SET]" : ""),
    1:                     height, (b.height != NS_INTRINSICSIZE ? "[SET]" : ""));
    1: 
    1: }
    1: 
    1: void
    1: nsBoxFrame::GetValue(nsPresContext* aPresContext, PRInt32 a, PRInt32 b, char* ch) 
    1: {
    1:     if (a == NS_INTRINSICSIZE)
    1:       sprintf(ch, "%d[SET]", b);             
    1:     else
    1:       sprintf(ch, "%d", a);             
    1: }
    1: 
    1: nsresult
    1: nsBoxFrame::DisplayDebugInfoFor(nsIBox*  aBox,
    1:                                 nsPoint& aPoint)
    1: {
    1:     nsBoxLayoutState state(GetPresContext());
    1: 
    1:     nscoord x = aPoint.x;
    1:     nscoord y = aPoint.y;
    1: 
    1:     // get the area inside our border but not our debug margins.
    1:     nsRect insideBorder(aBox->mRect);
    1:     insideBorder.MoveTo(0,0):
    1:     nsMargin border(0,0,0,0);
    1:     aBox->GetBorderAndPadding(border);
    1:     insideBorder.Deflate(border);
    1: 
    1:     PRBool isHorizontal = IsHorizontal();
    1: 
    1:     if (!insideBorder.Contains(nsPoint(x,y)))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     //printf("%%%%%% inside box %%%%%%%\n");
    1: 
    1:     int count = 0;
    1:     nsIBox* child = aBox->GetChildBox();
    1: 
    1:     nsMargin m;
    1:     nsMargin m2;
    1:     GetDebugBorder(m);
    1:     PixelMarginToTwips(aPresContext, m);
    1: 
    1:     GetDebugMargin(m2);
    1:     PixelMarginToTwips(aPresContext, m2);
    1: 
    1:     m += m2;
    1: 
    1:     if ((isHorizontal && y < insideBorder.y + m.top) ||
    1:         (!isHorizontal && x < insideBorder.x + m.left)) {
    1:         //printf("**** inside debug border *******\n");
    1:         while (child) 
    1:         {
    1:             const nsRect& r = child->mRect;
    1: 
    1:             // if we are not in the child. But in the spacer above the child.
    1:             if ((isHorizontal && x >= r.x && x < r.x + r.width) ||
    1:                 (!isHorizontal && y >= r.y && y < r.y + r.height)) {
    1:                 aCursor = NS_STYLE_CURSOR_POINTER;
    1:                    // found it but we already showed it.
    1:                     if (mDebugChild == child)
    1:                         return NS_OK;
    1: 
    1:                     if (aBox->GetContent()) {
    1:                       printf("---------------\n");
    1:                       DumpBox(stdout);
    1:                       printf("\n");
    1:                     }
    1: 
    1:                     if (child->GetContent()) {
    1:                         printf("child #%d: ", count);
    1:                         child->DumpBox(stdout);
    1:                         printf("\n");
    1:                     }
    1: 
    1:                     mDebugChild = child;
    1: 
    1:                     nsSize prefSizeCSS(NS_INTRINSICSIZE, NS_INTRINSICSIZE);
    1:                     nsSize minSizeCSS (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
    1:                     nsSize maxSizeCSS (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
    1:                     nscoord flexCSS = NS_INTRINSICSIZE;
    1: 
    1:                     nsIBox::AddCSSPrefSize(state, child, prefSizeCSS);
    1:                     nsIBox::AddCSSMinSize (state, child, minSizeCSS);
    1:                     nsIBox::AddCSSMaxSize (state, child, maxSizeCSS);
    1:                     nsIBox::AddCSSFlex    (state, child, flexCSS);
    1: 
    1:                     nsSize prefSize = child->GetPrefSize(state);
    1:                     nsSize minSize = child->GetMinSize(state);
    1:                     nsSize maxSize = child->GetMaxSize(state);
    1:                     nscoord flexSize = child->GetFlex(state);
    1:                     nscoord ascentSize = child->GetBoxAscent(state);
    1: 
    1:                     char min[100];
    1:                     char pref[100];
    1:                     char max[100];
    1:                     char calc[100];
    1:                     char flex[100];
    1:                     char ascent[100];
    1:                   
    1:                     nsSize actualSize;
    1:                     GetFrameSizeWithMargin(child, actualSize);
    1:                     nsSize actualSizeCSS (NS_INTRINSICSIZE, NS_INTRINSICSIZE);
    1: 
    1:                     GetValue(aPresContext, minSize,  minSizeCSS, min);
    1:                     GetValue(aPresContext, prefSize, prefSizeCSS, pref);
    1:                     GetValue(aPresContext, maxSize,  maxSizeCSS, max);
    1:                     GetValue(aPresContext, actualSize, actualSizeCSS, calc);
    1:                     GetValue(aPresContext, flexSize,  flexCSS, flex);
    1:                     GetValue(aPresContext, ascentSize,  NS_INTRINSICSIZE, ascent);
    1: 
    1: 
    1:                     printf("min%s, pref%s, max%s, actual%s, flex=%s, ascent=%s\n\n", 
    1:                         min,
    1:                         pref,
    1:                         max,
    1:                         calc,
    1:                         flex,
    1:                         ascent
    1:                     );
    1: 
    1:                     return NS_OK;   
    1:             }
    1: 
    1:           child = child->GetNextBox();
    1:           count++;
    1:         }
    1:     } else {
    1:     }
    1: 
    1:     mDebugChild = nsnull;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: nsBoxFrame::SetDebugOnChildList(nsBoxLayoutState& aState, nsIBox* aChild, PRBool aDebug)
    1: {
    1:     nsIBox* child = GetChildBox();
    1:      while (child)
    1:      {
    1:         child->SetDebug(aState, aDebug);
    1:         child = child->GetNextBox();
    1:      }
    1: }
    1: 
    1: nsresult
    1: nsBoxFrame::GetFrameSizeWithMargin(nsIBox* aBox, nsSize& aSize)
    1: {
    1:   nsRect rect(aBox->GetRect());
    1:   nsMargin margin(0,0,0,0);
    1:   aBox->GetMargin(margin);
    1:   rect.Inflate(margin);
    1:   aSize.width = rect.width;
    1:   aSize.height = rect.height;
    1:   return NS_OK;
    1: }
 1749: #endif
    1: 
    1: /**
    1:  * Boxed don't support fixed positionioning of their children.
10101:  * KEEP THIS IN SYNC WITH nsContainerFrame::CreateViewForFrame
10101:  * as much as possible. Until we get rid of views finally...
    1:  */
    1: nsresult
    1: nsBoxFrame::CreateViewForFrame(nsPresContext*  aPresContext,
    1:                                nsIFrame*        aFrame,
    1:                                nsStyleContext*  aStyleContext,
 3129:                                PRBool           aForce,
 3129:                                PRBool           aIsPopup)
    1: {
    1:   NS_ASSERTION(aForce, "We only get called to force view creation now");
    1:   // If we don't yet have a view, see if we need a view
    1:   if (!aFrame->HasView()) {
 3129:     nsViewVisibility visibility = nsViewVisibility_kShow;
    1:     PRInt32 zIndex = 0;
    1:     PRBool  autoZIndex = PR_FALSE;
    1: 
    1:     if (aForce) {
 3129:       nsIView* parentView;
26050:       nsIViewManager* viewManager = aPresContext->GetPresShell()->GetViewManager();
    1:       NS_ASSERTION(nsnull != viewManager, "null view manager");
    1: 
    1:       // Create a view
 3129:       if (aIsPopup) {
 3129:         viewManager->GetRootView(parentView);
 3129:         visibility = nsViewVisibility_kHide;
 3129:         zIndex = PR_INT32_MAX;
 3129:       }
 3129:       else {
10101:         parentView = aFrame->GetParent()->GetParentViewForChildFrame(aFrame);
 3129:       }
 3129: 
 3129:       NS_ASSERTION(parentView, "no parent view");
 3129: 
 3129:       // Create a view
 3129:       nsIView *view = viewManager->CreateView(aFrame->GetRect(), parentView, visibility);
    1:       if (view) {
    1:         // Insert the view into the view hierarchy. If the parent view is a
    1:         // scrolling view we need to do this differently
    1:         nsIScrollableView*  scrollingView = parentView->ToScrollableView();
    1:         if (scrollingView) {
    1:           scrollingView->SetScrolledView(view);
    1:         } else {
    1:           viewManager->SetViewZIndex(view, autoZIndex, zIndex);
    1:           // XXX put view last in document order until we can do better
    1:           viewManager->InsertChild(parentView, view, nsnull, PR_TRUE);
    1:         }
    1:       }
    1: 
    1:       // Remember our view
    1:       aFrame->SetView(view);
    1: 
    1:       NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
    1:         ("nsBoxFrame::CreateViewForFrame: frame=%p view=%p",
    1:          aFrame));
    1:       if (!view)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: // If you make changes to this function, check its counterparts
23176: // in nsTextBoxFrame and nsXULLabelFrame
    1: nsresult
    1: nsBoxFrame::RegUnregAccessKey(PRBool aDoReg)
    1: {
    1:   // if we have no content, we can't do anything
    1:   if (!mContent)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // find out what type of element this is
    1:   nsIAtom *atom = mContent->Tag();
    1: 
    1:   // only support accesskeys for the following elements
    1:   if (atom != nsGkAtoms::button &&
    1:       atom != nsGkAtoms::toolbarbutton &&
    1:       atom != nsGkAtoms::checkbox &&
    1:       atom != nsGkAtoms::textbox &&
    1:       atom != nsGkAtoms::tab &&
    1:       atom != nsGkAtoms::radio) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsAutoString accessKey;
    1:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accessKey);
    1: 
    1:   if (accessKey.IsEmpty())
    1:     return NS_OK;
    1: 
    1:   // With a valid PresContext we can get the ESM 
    1:   // and register the access key
  238:   nsIEventStateManager *esm = PresContext()->EventStateManager();
    1: 
    1:   nsresult rv;
    1: 
    1:   PRUint32 key = accessKey.First();
    1:   if (aDoReg)
    1:     rv = esm->RegisterAccessKey(mContent, key);
    1:   else
    1:     rv = esm->UnregisterAccessKey(mContent, key);
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsBoxFrame::FireDOMEventSynch(const nsAString& aDOMEventName, nsIContent *aContent)
    1: {
    1:   // XXX This will be deprecated, because it is not good to fire synchronous DOM events
    1:   // from layout. It's better to use nsFrame::FireDOMEvent() which is asynchronous.
  238:   nsPresContext *presContext = PresContext();
    1:   nsIContent *content = aContent ? aContent : mContent;
    1:   if (content && presContext) {
    1:     // Fire a DOM event
    1:     nsCOMPtr<nsIDOMEvent> event;
    1:     if (NS_SUCCEEDED(nsEventDispatcher::CreateEvent(presContext, nsnull,
    1:                                                     NS_LITERAL_STRING("Events"),
    1:                                                     getter_AddRefs(event)))) {
    1:       event->InitEvent(aDOMEventName, PR_TRUE, PR_TRUE);
    1: 
    1:       nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
    1:       privateEvent->SetTrusted(PR_TRUE);
    1: 
    1:       nsEventDispatcher::DispatchDOMEvent(content, nsnull, event,
    1:                                           presContext, nsnull);
    1:     }
    1:   }
    1: }
    1: 
23488: PRBool
23488: nsBoxFrame::SupportsOrdinalsInChildren()
23488: {
23488:   return PR_TRUE;
23488: }
23488: 
22468: static nsIFrame*
22468: SortedMerge(nsBoxLayoutState& aState, nsIFrame *aLeft, nsIFrame *aRight)
22468: {
22468:   NS_PRECONDITION(aLeft && aRight, "SortedMerge must have non-empty lists");
22468: 
22468:   nsIFrame *result;
22468:   // Unroll first iteration to avoid null-check 'result' inside the loop.
22468:   if (aLeft->GetOrdinal(aState) <= aRight->GetOrdinal(aState)) {
22468:     result = aLeft;
22468:     aLeft = aLeft->GetNextSibling();
22468:     if (!aLeft) {
22468:       result->SetNextSibling(aRight);
22468:       return result;
22468:     }
22468:   }
22468:   else {
22468:     result = aRight;
22468:     aRight = aRight->GetNextSibling();
22468:     if (!aRight) {
22468:       result->SetNextSibling(aLeft);
22468:       return result;
22468:     }
22468:   }
22468: 
22468:   nsIFrame *last = result;
22468:   for (;;) {
22468:     if (aLeft->GetOrdinal(aState) <= aRight->GetOrdinal(aState)) {
22468:       last->SetNextSibling(aLeft);
22468:       last = aLeft;
22468:       aLeft = aLeft->GetNextSibling();
22468:       if (!aLeft) {
22468:         last->SetNextSibling(aRight);
22468:         return result;
22468:       }
22468:     }
22468:     else {
22468:       last->SetNextSibling(aRight);
22468:       last = aRight;
22468:       aRight = aRight->GetNextSibling();
22468:       if (!aRight) {
22468:         last->SetNextSibling(aLeft);
22468:         return result;
22468:       }
22468:     }
22468:   }
22468: }
22468: 
22468: static nsIFrame*
22468: MergeSort(nsBoxLayoutState& aState, nsIFrame *aSource)
22468: {
22468:   NS_PRECONDITION(aSource, "MergeSort null arg");
22468: 
22468:   nsIFrame *sorted[32] = { nsnull };
22468:   nsIFrame **fill = &sorted[0];
22468:   nsIFrame **left;
22468:   nsIFrame *rest = aSource;
22468: 
22468:   do {
22468:     nsIFrame *current = rest;
22468:     rest = rest->GetNextSibling();
22468:     current->SetNextSibling(nsnull);
22468: 
22468:     // Merge it with sorted[0] if present; then merge the result with sorted[1] etc.
22468:     // sorted[0] is a list of length 1 (or nsnull).
22468:     // sorted[1] is a list of length 2 (or nsnull).
22468:     // sorted[2] is a list of length 4 (or nsnull). etc.
22468:     for (left = &sorted[0]; left != fill && *left; ++left) {
22468:       current = SortedMerge(aState, *left, current);
22468:       *left = nsnull;
22468:     }
22468: 
22468:     // Fill the empty slot that we couldn't merge with the last result.
22468:     *left = current;
22468: 
22468:     if (left == fill)
22468:       ++fill;
22468:   } while (rest);
22468: 
22468:   // Collect and merge the results.
22468:   nsIFrame *result = nsnull;
22468:   for (left = &sorted[0]; left != fill; ++left) {
22468:     if (*left) {
22468:       result = result ? SortedMerge(aState, *left, result) : *left;
22468:     }
22468:   }
22468:   return result;
22468: }
22468: 
    1: void 
    1: nsBoxFrame::CheckBoxOrder(nsBoxLayoutState& aState)
    1: {
22468:   nsIFrame *child = mFrames.FirstChild();
22468:   if (!child)
22468:     return;
22468: 
23488:   if (!SupportsOrdinalsInChildren())
23488:     return;
23488: 
    1:   // Run through our list of children and check whether we
22468:   // need to sort them.
22468:   PRUint32 maxOrdinal = child->GetOrdinal(aState);
22468:   child = child->GetNextSibling();
22468:   for ( ; child; child = child->GetNextSibling()) {
    1:     PRUint32 ordinal = child->GetOrdinal(aState);
22468:     if (ordinal < maxOrdinal)
22468:       break;
22468:     maxOrdinal = ordinal;
    1:   }
    1: 
22468:   if (!child)
    1:     return;
    1: 
22468:   mFrames.SetFrames(MergeSort(aState, mFrames.FirstChild()));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::SetLayoutManager(nsIBoxLayout* aLayout)
    1: {
    1:   mLayoutManager = aLayout;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::GetLayoutManager(nsIBoxLayout** aLayout)
    1: {
    1:   *aLayout = mLayoutManager;
    1:   NS_IF_ADDREF(*aLayout);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsBoxFrame::LayoutChildAt(nsBoxLayoutState& aState, nsIBox* aBox, const nsRect& aRect)
    1: {
    1:   // get the current rect
    1:   nsRect oldRect(aBox->GetRect());
    1:   aBox->SetBounds(aState, aRect);
    1: 
 1158:   PRBool layout = NS_SUBTREE_DIRTY(aBox);
    1:   
    1:   if (layout || (oldRect.width != aRect.width || oldRect.height != aRect.height))  {
    1:     return aBox->Layout(aState);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsBoxFrame::RelayoutChildAtOrdinal(nsBoxLayoutState& aState, nsIBox* aChild)
    1: {
23488:   if (!SupportsOrdinalsInChildren())
23488:     return NS_OK;
23488: 
    1:   PRUint32 ord = aChild->GetOrdinal(aState);
    1:   
    1:   nsIFrame *child = mFrames.FirstChild();
    1:   nsIFrame *curPrevSib = nsnull, *newPrevSib = nsnull;
    1:   PRBool foundPrevSib = PR_FALSE, foundNewPrevSib = PR_FALSE;
    1: 
    1:   while (child) {
    1:     if (child == aChild)
    1:       foundPrevSib = PR_TRUE;
    1:     else if (!foundPrevSib)
    1:       curPrevSib = child;
    1: 
    1:     PRUint32 ordCmp = child->GetOrdinal(aState);
    1:     if (ord < ordCmp)
    1:       foundNewPrevSib = PR_TRUE;
    1:     else if (!foundNewPrevSib && child != aChild)
    1:       newPrevSib = child;
    1: 
    1:     child = child->GetNextBox();
    1:   }
    1: 
    1:   NS_ASSERTION(foundPrevSib, "aChild not in frame list?");
    1: 
    1:   if (curPrevSib == newPrevSib) {
    1:     // This box is not moving.
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Take aChild out of its old position in the child list.
    1:   if (curPrevSib)
    1:     curPrevSib->SetNextSibling(aChild->GetNextSibling());
    1:   else
    1:     mFrames.SetFrames(aChild->GetNextSibling());
    1: 
    1:   nsIBox* newNextSib;
    1:   if (newPrevSib) {
    1:     // insert |aChild| between |newPrevSib| and its next sibling
    1:     newNextSib = newPrevSib->GetNextSibling();
    1:     newPrevSib->SetNextSibling(aChild);
    1:   } else {
    1:     // no |newPrevSib| found, so this box will become |mFirstChild|
    1:     newNextSib = mFrames.FirstChild();
    1:     mFrames.SetFrames(aChild);
    1:   }
    1: 
    1:   aChild->SetNextSibling(newNextSib);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:  * This wrapper class lets us redirect mouse hits from descendant frames
    1:  * of a menu to the menu itself, if they didn't specify 'allowevents'.
    1:  * 
    1:  * The wrapper simply turns a hit on a descendant element
    1:  * into a hit on the menu itself, unless there is an element between the target
    1:  * and the menu with the "allowevents" attribute.
    1:  * 
    1:  * This is used by nsMenuFrame and nsTreeColFrame.
    1:  * 
    1:  * Note that turning a hit on a descendant element into nsnull, so events
    1:  * could fall through to the menu background, might be an appealing simplification
    1:  * but it would mean slightly strange behaviour in some cases, because grabber
    1:  * wrappers can be created for many individual lists and items, so the exact
    1:  * fallthrough behaviour would be complex. E.g. an element with "allowevents"
    1:  * on top of the Content() list could receive the event even if it was covered
    1:  * by a PositionedDescenants() element without "allowevents". It is best to
    1:  * never convert a non-null hit into null.
    1:  */
    1: // REVIEW: This is roughly of what nsMenuFrame::GetFrameForPoint used to do.
    1: // I've made 'allowevents' affect child elements because that seems the only
    1: // reasonable thing to do.
    1: class nsDisplayXULEventRedirector : public nsDisplayWrapList {
    1: public:
    1:   nsDisplayXULEventRedirector(nsIFrame* aFrame, nsDisplayItem* aItem,
    1:                               nsIFrame* aTargetFrame)
    1:     : nsDisplayWrapList(aFrame, aItem), mTargetFrame(aTargetFrame) {}
    1:   nsDisplayXULEventRedirector(nsIFrame* aFrame, nsDisplayList* aList,
    1:                               nsIFrame* aTargetFrame)
    1:     : nsDisplayWrapList(aFrame, aList), mTargetFrame(aTargetFrame) {}
 9799:   virtual nsIFrame* HitTest(nsDisplayListBuilder* aBuilder, nsPoint aPt,
 9799:                             HitTestState* aState);
    1:   NS_DISPLAY_DECL_NAME("XULEventRedirector")
    1: private:
    1:   nsIFrame* mTargetFrame;
    1: };
    1: 
    1: nsIFrame* nsDisplayXULEventRedirector::HitTest(nsDisplayListBuilder* aBuilder,
 9799:     nsPoint aPt, HitTestState* aState)
    1: {
 9799:   nsIFrame* frame = mList.HitTest(aBuilder, aPt, aState);
    1:   if (!frame)
    1:     return nsnull;
    1: 
    1:   for (nsIContent* content = frame->GetContent();
    1:        content && content != mTargetFrame->GetContent();
    1:        content = content->GetParent()) {
    1:     if (content->AttrValueIs(kNameSpaceID_None, nsGkAtoms::allowevents,
    1:                              nsGkAtoms::_true, eCaseMatters)) {
    1:       // Events are allowed on 'frame', so let it go.
    1:       return frame;
    1:     }
    1:   }
    1:   // Treat it as a hit on the target frame itself.
    1:   return mTargetFrame;
    1: }
    1: 
    1: class nsXULEventRedirectorWrapper : public nsDisplayWrapper
    1: {
    1: public:
    1:   nsXULEventRedirectorWrapper(nsIFrame* aTargetFrame)
    1:       : mTargetFrame(aTargetFrame) {}
    1:   virtual nsDisplayItem* WrapList(nsDisplayListBuilder* aBuilder,
    1:                                   nsIFrame* aFrame, nsDisplayList* aList) {
    1:     return new (aBuilder)
    1:         nsDisplayXULEventRedirector(aFrame, aList, mTargetFrame);
    1:   }
    1:   virtual nsDisplayItem* WrapItem(nsDisplayListBuilder* aBuilder,
    1:                                   nsDisplayItem* aItem) {
    1:     return new (aBuilder)
    1:         nsDisplayXULEventRedirector(aItem->GetUnderlyingFrame(), aItem,
    1:                                     mTargetFrame);
    1:   }
    1: private:
    1:   nsIFrame* mTargetFrame;
    1: };
    1: 
    1: nsresult
    1: nsBoxFrame::WrapListsInRedirector(nsDisplayListBuilder*   aBuilder,
    1:                                   const nsDisplayListSet& aIn,
    1:                                   const nsDisplayListSet& aOut)
    1: {
    1:   nsXULEventRedirectorWrapper wrapper(this);
    1:   return wrapper.WrapLists(aBuilder, this, aIn, aOut);
    1: }
