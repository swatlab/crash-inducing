68895: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jsprvtd_h___
    1: #define jsprvtd_h___
    1: /*
    1:  * JS private typename definitions.
    1:  *
    1:  * This header is included only in other .h files, for convenience and for
    1:  * simplicity of type naming.  The alternative for structures is to use tags,
    1:  * which are named the same as their typedef names (legal in C/C++, and less
    1:  * noisy than suffixing the typedef name with "Struct" or "Str").  Instead,
    1:  * all .h files that include this file may use the same typedef name, whether
    1:  * declaring a pointer to struct type, or defining a member of struct type.
    1:  *
    1:  * A few fundamental scalar types are defined here too.  Neither the scalar
    1:  * nor the struct typedefs should change much, therefore the nearly-global
    1:  * make dependency induced by this file should not prove painful.
    1:  */
    1: 
78613: #include "jsapi.h"
86482: #include "jsutil.h"
84755: 
86482: #ifdef __cplusplus
86482: #include "js/HashTable.h"
86482: #include "js/Vector.h"
86482: #endif
    1: 
48470: JS_BEGIN_EXTERN_C
12582: 
 4529: /*
 8179:  * Convenience constants.
 8179:  */
 8367: #define JS_BITS_PER_UINT32_LOG2 5
 8367: #define JS_BITS_PER_UINT32      32
 8179: 
48470: /* The alignment required of objects stored in GC arenas. */
48470: static const uintN JS_GCTHING_ALIGN = 8;
48470: static const uintN JS_GCTHING_ZEROBITS = 3;
48470: 
    1: /* Scalar typedefs. */
84755: typedef uint8_t     jsbytecode;
84755: typedef uint8_t     jssrcnote;
72579: typedef uintptr_t   jsatomid;
    1: 
    1: /* Struct typedefs. */
    1: typedef struct JSArgumentFormatMap  JSArgumentFormatMap;
48583: typedef struct JSGCThing            JSGCThing;
    1: typedef struct JSGenerator          JSGenerator;
15613: typedef struct JSNativeEnumerator   JSNativeEnumerator;
26960: typedef struct JSProperty           JSProperty;
    1: typedef struct JSSharpObjectMap     JSSharpObjectMap;
    1: typedef struct JSThread             JSThread;
    1: typedef struct JSTryNote            JSTryNote;
    1: 
    1: /* Friend "Advanced API" typedefs. */
    1: typedef struct JSAtomState          JSAtomState;
    1: typedef struct JSCodeSpec           JSCodeSpec;
    1: typedef struct JSPrinter            JSPrinter;
    1: typedef struct JSStackHeader        JSStackHeader;
    1: typedef struct JSSubString          JSSubString;
32669: typedef struct JSSpecializedNative  JSSpecializedNative;
    1: typedef struct JSXML                JSXML;
    1: 
30023: /*
30023:  * Template declarations.
30023:  *
30023:  * jsprvtd.h can be included in both C and C++ translation units. For C++, it
30023:  * may possibly be wrapped in an extern "C" block which does not agree with
30028:  * templates.
30023:  */
30023: #ifdef __cplusplus
64345: 
30028: extern "C++" {
30023: 
64345: class JSDependentString;
64345: class JSExtensibleString;
68942: class JSExternalString;
64345: class JSLinearString;
64345: class JSFixedString;
64345: class JSStaticAtom;
64345: class JSRope;
64345: class JSAtom;
78613: class JSWrapper;
64345: 
32651: namespace js {
31477: 
52503: struct ArgumentsData;
78614: struct Class;
52503: 
80378: class RegExpObject;
82146: class RegExpMatcher;
81612: class RegExpObjectBuilder;
50491: class RegExpStatics;
80378: class MatchPairs;
79981: 
82146: namespace detail {
82146: 
82146: class RegExpPrivate;
82146: class RegExpPrivateCode;
82955: class RegExpPrivateCacheValue;
82146: 
82146: } /* namespace detail */
82146: 
79981: enum RegExpFlag
79981: {
80816:     IgnoreCaseFlag  = 0x01,
80816:     GlobalFlag      = 0x02,
80816:     MultilineFlag   = 0x04,
80816:     StickyFlag      = 0x08,
80816: 
80816:     NoFlags         = 0x00,
80816:     AllFlags        = 0x0f
79981: };
79981: 
80378: enum RegExpExecType
80378: {
80378:     RegExpExec,
80378:     RegExpTest
80378: };
80378: 
42714: class ExecuteArgsGuard;
42714: class InvokeFrameGuard;
42714: class InvokeArgsGuard;
69223: class StringBuffer;
69223: 
69223: class FrameRegs;
69223: class StackFrame;
69223: class StackSegment;
42714: class StackSpace;
69223: class ContextStack;
53840: class FrameRegsIter;
69223: class CallReceiver;
69223: class CallArgs;
37741: 
80964: struct BytecodeEmitter;
80634: struct Definition;
80634: struct FunctionBox;
80634: struct ObjectBox;
80634: struct ParseNode;
52503: struct Parser;
40433: class TokenStream;
40320: struct Token;
40320: struct TokenPos;
40320: struct TokenPtr;
80634: struct TreeContext;
73887: class UpvarCookie;
40320: 
79386: class Proxy;
79386: class ProxyHandler;
79386: class Wrapper;
79386: class CrossCompartmentWrapper;
79386: 
72091: class TempAllocPolicy;
75506: class RuntimeAllocPolicy;
30023: 
79410: class GlobalObject;
79410: 
72579: template <typename K,
72579:           typename V,
72579:           size_t InlineElems>
72579: class InlineMap;
72579: 
79410: class LifoAlloc;
79410: 
40391: class PropertyCache;
40362: struct PropertyCacheEntry;
41860: 
83229: class BaseShape;
83229: class UnownedBaseShape;
52503: struct Shape;
52503: struct EmptyShape;
83247: class ShapeKindArray;
64296: class Bindings;
41860: 
86437: struct StackBaseShape;
86437: struct StackShape;
86437: 
72579: class MultiDeclRange;
72579: class ParseMapPool;
72579: class DefnOrHeader;
80631: typedef InlineMap<JSAtom *, Definition *, 24> AtomDefnMap;
73887: typedef InlineMap<JSAtom *, jsatomid, 24> AtomIndexMap;
73887: typedef InlineMap<JSAtom *, DefnOrHeader, 24> AtomDOHMap;
73888: typedef Vector<UpvarCookie, 8> UpvarCookies;
72579: 
75506: class Breakpoint;
75506: class BreakpointSite;
76246: class Debugger;
74472: class WatchpointMap;
74472: 
82955: typedef HashMap<JSAtom *,
82955:                 detail::RegExpPrivateCacheValue,
82955:                 DefaultHasher<JSAtom *>,
82955:                 RuntimeAllocPolicy>
81612:     RegExpPrivateCache;
81612: 
84307: /*
84307:  * Env is the type of what ES5 calls "lexical environments" (runtime
84307:  * activations of lexical scopes). This is currently just JSObject, and is
84307:  * implemented by Call, Block, With, and DeclEnv objects, among others--but
84307:  * environments and objects are really two different concepts.
84307:  */
84307: typedef JSObject Env;
84307: 
78614: typedef JSNative             Native;
78614: typedef JSPropertyOp         PropertyOp;
78614: typedef JSStrictPropertyOp   StrictPropertyOp;
78614: typedef JSPropertyDescriptor PropertyDescriptor;
78614: 
79410: namespace analyze {
79410: 
79410: struct LifetimeVariable;
79410: class LoopAnalysis;
79410: class ScriptAnalysis;
79410: class SlotValue;
79410: class SSAValue;
79410: class SSAUseChain;
79410: 
79410: } /* namespace analyze */
79410: 
79410: namespace types {
79410: 
79410: class TypeSet;
79410: struct TypeCallsite;
79410: struct TypeObject;
79410: struct TypeCompartment;
79410: 
79410: } /* namespace types */
79410: 
86437: enum ThingRootKind
86437: {
86437:     THING_ROOT_OBJECT,
86437:     THING_ROOT_SHAPE,
86437:     THING_ROOT_BASE_SHAPE,
86437:     THING_ROOT_TYPE_OBJECT,
86437:     THING_ROOT_STRING,
86437:     THING_ROOT_SCRIPT,
86437:     THING_ROOT_ID,
86437:     THING_ROOT_VALUE,
86437:     THING_ROOT_LIMIT
86437: };
86437: 
86437: template <typename T> class Root;
86437: template <typename T> class RootedVar;
86437: 
86439: template <typename T>
86439: struct RootMethods { };
86439: 
86437: /*
86437:  * Reference to a stack location rooted for GC. See "Moving GC Stack Rooting"
86437:  * comment in jscntxt.h.
86437:  */
86437: template <typename T>
86437: class Handle
86437: {
86437:   public:
86574:     /* Copy handles of different types, with implicit coercion. */
86437:     template <typename S> Handle(Handle<S> handle) {
86437:         testAssign<S>();
86437:         ptr = reinterpret_cast<const T *>(handle.address());
86437:     }
86437: 
86574:     /* Get a handle from a rooted stack location, with implicit coercion. */
86437:     template <typename S> inline Handle(const Root<S> &root);
86437:     template <typename S> inline Handle(const RootedVar<S> &root);
86437: 
86437:     const T *address() { return ptr; }
86437: 
86437:     operator T () { return value(); }
86437:     T operator ->() { return value(); }
86437: 
86437:   private:
86437:     const T *ptr;
86437:     T value() { return *ptr; }
86437: 
86437:     template <typename S>
86437:     void testAssign() {
86437: #ifdef DEBUG
86439:         T a = RootMethods<T>::initial();
86439:         S b = RootMethods<S>::initial();
86437:         a = b;
86483:         (void)a;
86437: #endif
86437:     }
86437: };
86437: 
86437: typedef Handle<JSObject*>          HandleObject;
86437: typedef Handle<JSFunction*>        HandleFunction;
86437: typedef Handle<Shape*>             HandleShape;
86437: typedef Handle<BaseShape*>         HandleBaseShape;
86437: typedef Handle<types::TypeObject*> HandleTypeObject;
86437: typedef Handle<JSString*>          HandleString;
86437: typedef Handle<JSAtom*>            HandleAtom;
86437: typedef Handle<jsid>               HandleId;
86437: typedef Handle<Value>              HandleValue;
86437: 
32651: } /* namespace js */
32651: 
82323: namespace JSC {
82323: 
82323: class ExecutableAllocator;
82323: 
82323: } /* namespace JSC */
82323: 
82323: namespace WTF {
82323: 
82323: class BumpPointerAllocator;
82323: 
82323: } /* namespace WTF */
82323: 
32651: } /* export "C++" */
64345: 
64345: #else
64345: 
64345: typedef struct JSAtom JSAtom;
64345: 
30023: #endif  /* __cplusplus */
30023: 
    1: /* "Friend" types used by jscntxt.h and jsdbgapi.h. */
    1: typedef enum JSTrapStatus {
    1:     JSTRAP_ERROR,
    1:     JSTRAP_CONTINUE,
    1:     JSTRAP_RETURN,
    1:     JSTRAP_THROW,
    1:     JSTRAP_LIMIT
    1: } JSTrapStatus;
    1: 
    1: typedef JSTrapStatus
18907: (* JSTrapHandler)(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
41863:                   jsval closure);
41863: 
41863: typedef JSTrapStatus
41863: (* JSInterruptHook)(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
41863:                     void *closure);
41863: 
41863: typedef JSTrapStatus
41863: (* JSDebuggerHandler)(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
41863:                       void *closure);
41863: 
41863: typedef JSTrapStatus
41863: (* JSThrowHook)(JSContext *cx, JSScript *script, jsbytecode *pc, jsval *rval,
18907:                 void *closure);
    1: 
    1: typedef JSBool
48470: (* JSWatchPointHandler)(JSContext *cx, JSObject *obj, jsid id, jsval old,
18907:                         jsval *newp, void *closure);
    1: 
    1: /* called just after script creation */
    1: typedef void
18907: (* JSNewScriptHook)(JSContext  *cx,
    1:                     const char *filename,  /* URL of script */
    1:                     uintN      lineno,     /* first line */
    1:                     JSScript   *script,
    1:                     JSFunction *fun,
    1:                     void       *callerdata);
    1: 
    1: /* called just before script destruction */
    1: typedef void
18907: (* JSDestroyScriptHook)(JSContext *cx,
    1:                         JSScript  *script,
    1:                         void      *callerdata);
    1: 
    1: typedef void
71313: (* JSSourceHandler)(const char *filename, uintN lineno, const jschar *str,
18907:                     size_t length, void **listenerTSData, void *closure);
    1: 
    1: /*
    1:  * This hook captures high level script execution and function calls (JS or
    1:  * native).  It is used by JS_SetExecuteHook to hook top level scripts and by
    1:  * JS_SetCallHook to hook function calls.  It will get called twice per script
    1:  * or function call: just before execution begins and just after it finishes.
    1:  * In both cases the 'current' frame is that of the executing code.
    1:  *
    1:  * The 'before' param is JS_TRUE for the hook invocation before the execution
    1:  * and JS_FALSE for the invocation after the code has run.
    1:  *
    1:  * The 'ok' param is significant only on the post execution invocation to
    1:  * signify whether or not the code completed 'normally'.
    1:  *
    1:  * The 'closure' param is as passed to JS_SetExecuteHook or JS_SetCallHook
    1:  * for the 'before'invocation, but is whatever value is returned from that
    1:  * invocation for the 'after' invocation. Thus, the hook implementor *could*
    1:  * allocate a structure in the 'before' invocation and return a pointer to that
    1:  * structure. The pointer would then be handed to the hook for the 'after'
    1:  * invocation. Alternately, the 'before' could just return the same value as
    1:  * in 'closure' to cause the 'after' invocation to be called with the same
    1:  * 'closure' value as the 'before'.
    1:  *
    1:  * Returning NULL in the 'before' hook will cause the 'after' hook *not* to
    1:  * be called.
    1:  */
    1: typedef void *
18907: (* JSInterpreterHook)(JSContext *cx, JSStackFrame *fp, JSBool before,
    1:                       JSBool *ok, void *closure);
    1: 
    1: typedef JSBool
18907: (* JSDebugErrorHook)(JSContext *cx, const char *message, JSErrorReport *report,
18907:                      void *closure);
    1: 
 2433: typedef struct JSDebugHooks {
41863:     JSInterruptHook     interruptHook;
41863:     void                *interruptHookData;
 2433:     JSNewScriptHook     newScriptHook;
 2433:     void                *newScriptHookData;
 2433:     JSDestroyScriptHook destroyScriptHook;
 2433:     void                *destroyScriptHookData;
41863:     JSDebuggerHandler   debuggerHandler;
 2433:     void                *debuggerHandlerData;
 2433:     JSSourceHandler     sourceHandler;
 2433:     void                *sourceHandlerData;
 2433:     JSInterpreterHook   executeHook;
 2433:     void                *executeHookData;
 2433:     JSInterpreterHook   callHook;
 2433:     void                *callHookData;
41863:     JSThrowHook         throwHook;
 2433:     void                *throwHookData;
 2433:     JSDebugErrorHook    debugErrorHook;
 2433:     void                *debugErrorHookData;
 2433: } JSDebugHooks;
 2433: 
52503: /* js::ObjectOps function pointer typedefs. */
26817: 
26817: /*
26817:  * Look for id in obj and its prototype chain, returning false on error or
26817:  * exception, true on success.  On success, return null in *propp if id was
26817:  * not found.  If id was found, return the first object searching from obj
26817:  * along its prototype chain in which id names a direct property in *objp, and
26817:  * return a non-null, opaque property pointer in *propp.
26817:  *
26817:  * If JSLookupPropOp succeeds and returns with *propp non-null, that pointer
26817:  * may be passed as the prop parameter to a JSAttributesOp, as a short-cut
56567:  * that bypasses id re-lookup.
26817:  */
26817: typedef JSBool
26817: (* JSLookupPropOp)(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
26817:                    JSProperty **propp);
26817: 
26817: /*
26817:  * Get or set attributes of the property obj[id]. Return false on error or
43290:  * exception, true with current attributes in *attrsp.
26817:  */
26817: typedef JSBool
43290: (* JSAttributesOp)(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp);
26817: 
26817: /*
48622:  * A generic type for functions mapping an object to another object, or null
48622:  * if an error or exception was thrown on cx.
48622:  */
48622: typedef JSObject *
48622: (* JSObjectOp)(JSContext *cx, JSObject *obj);
48622: 
48622: /*
48622:  * Hook that creates an iterator object for a given object. Returns the
48622:  * iterator object or null if an error or exception was thrown on cx.
48622:  */
48622: typedef JSObject *
48622: (* JSIteratorOp)(JSContext *cx, JSObject *obj, JSBool keysonly);
48622: 
48622: /*
 8893:  * The following determines whether JS_EncodeCharacters and JS_DecodeBytes
 8893:  * treat char[] as utf-8 or simply as bytes that need to be inflated/deflated.
 8893:  */
 8893: #ifdef JS_C_STRINGS_ARE_UTF8
 8893: # define js_CStringsAreUTF8 JS_TRUE
 8893: #else
 8893: extern JSBool js_CStringsAreUTF8;
 8893: #endif
 3235: 
48470: JS_END_EXTERN_C
48470: 
    1: #endif /* jsprvtd_h___ */
