 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "prerror.h"
     1: #include "prprf.h"
     1: 
119899: #include "mozilla/Scoped.h"
     1: #include "nsNSSCertHelper.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsNSSCertificate.h"
     1: #include "cert.h"
     1: #include "keyhi.h"
 16022: #include "secder.h"
     1: #include "nsNSSCertValidity.h"
     1: #include "nsNSSASN1Object.h"
     1: #include "nsNSSComponent.h"
     1: #include "nsNSSCertTrust.h"
     1: #include "nsIDateTimeFormat.h"
     1: #include "nsDateTimeFormatCID.h"
129543: #include <algorithm>
     1: 
119899: using namespace mozilla;
119899:  
     1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
     1: 
     1: /* Object Identifier constants */
     1: #define CONST_OID static const unsigned char
     1: #define MICROSOFT_OID 0x2b, 0x6, 0x1, 0x4, 0x1, 0x82, 0x37
     1: #define PKIX_OID 0x2b, 0x6, 0x01, 0x05, 0x05, 0x07
     1: CONST_OID msCertExtCerttype[]      = { MICROSOFT_OID, 20, 2};
     1: CONST_OID msNTPrincipalName[]      = { MICROSOFT_OID, 20, 2, 3 };
     1: CONST_OID msCertsrvCAVersion[]     = { MICROSOFT_OID, 21, 1 };
     1: CONST_OID msNTDSReplication[]      = { MICROSOFT_OID, 25, 1 };
     1: CONST_OID pkixLogotype[]           = { PKIX_OID, 1, 12 };
     1: 
     1: #define OI(x) { siDEROID, (unsigned char *)x, sizeof x }
     1: #define OD(oid,desc,mech,ext) {OI(oid), SEC_OID_UNKNOWN, desc, mech, ext}
     1: #define SEC_OID(tag) more_oids[tag].offset
     1: 
     1: static SECOidData more_oids[] = {
     1:     /* Microsoft OIDs */
     1:     #define MS_CERT_EXT_CERTTYPE 0
     1:     OD( msCertExtCerttype,
     1:         "Microsoft Certificate Template Name", 
     1:         CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION ),
     1: 
     1:     #define MS_NT_PRINCIPAL_NAME 1
     1:     OD( msNTPrincipalName,
     1:         "Microsoft Principal Name", 
     1:         CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION ),
     1: 
     1:     #define MS_CERTSERV_CA_VERSION 2
     1:     OD( msCertsrvCAVersion,
     1:         "Microsoft CA Version", 
     1:         CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION ),
     1: 
     1:     #define MS_NTDS_REPLICATION 3
     1:     OD( msNTDSReplication,
     1:         "Microsoft Domain GUID", 
     1:         CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION ),
     1: 
     1:     #define PKIX_LOGOTYPE 4
     1:     OD( pkixLogotype,
     1:         "Logotype", 
     1:         CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION ),
     1: };
     1: 
     1: static const unsigned int numOids = (sizeof more_oids) / (sizeof more_oids[0]);
     1: 
     1: static nsresult
     1: GetIntValue(SECItem *versionItem, 
     1:             unsigned long *version)
     1: {
     1:   SECStatus srv;
     1: 
     1:   srv = SEC_ASN1DecodeInteger(versionItem,version);
     1:   if (srv != SECSuccess) {
 31561:     NS_ERROR("Could not decode version of cert");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessVersion(SECItem         *versionItem,
     1:                nsINSSComponent *nssComponent,
     1:                nsIASN1PrintableItem **retItem)
     1: {
     1:   nsresult rv;
     1:   nsAutoString text;
     1:   nsCOMPtr<nsIASN1PrintableItem> printableItem = new nsNSSASN1PrintableItem();
     1:  
     1:   nssComponent->GetPIPNSSBundleString("CertDumpVersion", text);
     1:   rv = printableItem->SetDisplayName(text);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   // Now to figure out what version this certificate is.
     1:   unsigned long version;
     1: 
     1:   if (versionItem->data) {
     1:     rv = GetIntValue(versionItem, &version);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1:   } else {
     1:     // If there is no version present in the cert, then rfc2459
     1:     // says we default to v1 (0)
     1:     version = 0;
     1:   }
     1: 
     1:   switch (version){
     1:   case 0:
     1:     rv = nssComponent->GetPIPNSSBundleString("CertDumpVersion1", text);
     1:     break;
     1:   case 1:
     1:     rv = nssComponent->GetPIPNSSBundleString("CertDumpVersion2", text);
     1:     break;
     1:   case 2:
     1:     rv = nssComponent->GetPIPNSSBundleString("CertDumpVersion3", text);
     1:     break;
     1:   default:
 31561:     NS_ERROR("Bad value for cert version");
     1:     rv = NS_ERROR_FAILURE;
     1:   }
     1:     
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   rv = printableItem->SetDisplayValue(text);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   *retItem = printableItem;
     1:   NS_ADDREF(*retItem);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult 
     1: ProcessSerialNumberDER(SECItem         *serialItem, 
     1:                        nsINSSComponent *nssComponent,
     1:                        nsIASN1PrintableItem **retItem)
     1: {
     1:   nsresult rv;
     1:   nsAutoString text;
     1:   nsCOMPtr<nsIASN1PrintableItem> printableItem = new nsNSSASN1PrintableItem();
     1: 
     1:   rv = nssComponent->GetPIPNSSBundleString("CertDumpSerialNo", text); 
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   rv = printableItem->SetDisplayName(text);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   nsXPIDLCString serialNumber;
     1:   serialNumber.Adopt(CERT_Hexify(serialItem, 1));
119899:   if (!serialNumber)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   rv = printableItem->SetDisplayValue(NS_ConvertASCIItoUTF16(serialNumber));
     1:   *retItem = printableItem;
     1:   NS_ADDREF(*retItem);
     1:   return rv;
     1: }
     1: 
     1: static nsresult
     1: GetDefaultOIDFormat(SECItem *oid,
 30840:                     nsINSSComponent *nssComponent,
     1:                     nsAString &outString,
     1:                     char separator)
     1: {
     1:   char buf[300];
 30840:   unsigned int len = 0;
 30840:   int written, invalidCount = 0;
     1:     
 30840:   unsigned int i;
 30840:   unsigned long val  = 0;
 79445:   bool invalid = false;
 79445:   bool first = true;
     1: 
     1:   val = 0;
 30840:   for (i = 0; i < oid->len; ++i) {
     1:     // In this loop, we have to parse a DER formatted 
     1:     // If the first bit is a 1, then the integer is 
     1:     // represented by more than one byte.  If the 
     1:     // first bit is set then we continue on and add
     1:     // the values of the later bytes until we get 
     1:     // a byte without the first bit set.
     1:     unsigned long j;
     1: 
     1:     j = oid->data[i];
     1:     val = (val << 7) | (j & 0x7f);
 30840:     if (j & 0x80) {
 30840:       // - If val is 0 in this block, the OID number particle starts with 0x80
 30840:       // what is specified as an invalid formating.
 30840:       // - If val is larger then 2^32-7, on next left shift by 7 we will loose
 30840:       // the most significant bits, this OID number particle cannot be read
 30840:       // by our implementation.
 30840:       // - If the first bit is set while this is the last component of the OID
 30840:       // we are also in an invalid state.
 30840:       if (val == 0 || (val >= (1 << (32-7))) || (i == oid->len-1)) {
 80486:         invalid = true;
 30840:       }
 30840: 
 30840:       if (i < oid->len-1)
     1:         continue;
 30840:     }
 30840: 
 30840:     if (!invalid) {
 30840:       if (first) {
129543:         unsigned long one = std::min(val/40, 2UL); // never > 2
 30840:         unsigned long two = val - (one * 40);
 30840: 
 30840:         written = PR_snprintf(&buf[len], sizeof(buf)-len, "%lu%c%lu", 
 30840: 			      one, separator, two);
 30840:       }
 30840:       else {
     1:         written = PR_snprintf(&buf[len], sizeof(buf)-len, "%c%lu", 
     1: 			      separator, val);
 30840:       }
 30840:     }
 30840:     else {
 30840:       nsAutoString unknownText;
 30840:       nssComponent->GetPIPNSSBundleString("CertUnknown", 
 30840:                                           unknownText);
 30840:       if (first) {
 30840:         written = PR_snprintf(&buf[len], sizeof(buf)-len, "%s",
 30840:                               NS_ConvertUTF16toUTF8(unknownText).get());
 30840:       }
 30840:       else {
 30840:         written = PR_snprintf(&buf[len], sizeof(buf)-len, "%c%s",
 30840:                               separator, 
 30840:                               NS_ConvertUTF16toUTF8(unknownText).get());
 30840:       }
 30840: 
 30840:       if (++invalidCount > 3) {
 30840:         // Allow only 3 occurences of Unknown in OID display string to
 30840:         // prevent bloat.
 30840:         break;
 30840:       }
 30840:     }
 30840: 
     1:     if (written < 0)
     1:       return NS_ERROR_FAILURE;
     1: 
     1:     len += written;
     1:     NS_ASSERTION(len < sizeof(buf), "OID data to big to display in 300 chars.");
     1:     val = 0;      
 80486:     invalid = false;
 80486:     first = false;
     1:   }
     1: 
     1:   CopyASCIItoUTF16(buf, outString);
     1:   return NS_OK; 
     1: }
     1: 
     1: static nsresult
     1: GetOIDText(SECItem *oid, nsINSSComponent *nssComponent, nsAString &text)
     1: { 
     1:   nsresult rv;
     1:   SECOidTag oidTag = SECOID_FindOIDTag(oid);
     1:   const char *bundlekey = 0;
     1: 
     1:   switch (oidTag) {
     1:   case SEC_OID_PKCS1_MD2_WITH_RSA_ENCRYPTION:
     1:     bundlekey = "CertDumpMD2WithRSA";
     1:     break;
     1:   case SEC_OID_PKCS1_MD5_WITH_RSA_ENCRYPTION:
     1:     bundlekey = "CertDumpMD5WithRSA";
     1:     break;
     1:   case SEC_OID_PKCS1_SHA1_WITH_RSA_ENCRYPTION:
     1:     bundlekey = "CertDumpSHA1WithRSA";
     1:     break;
     1:   case SEC_OID_PKCS1_SHA256_WITH_RSA_ENCRYPTION:
     1:     bundlekey = "CertDumpSHA256WithRSA";
     1:     break;
     1:   case SEC_OID_PKCS1_SHA384_WITH_RSA_ENCRYPTION:
     1:     bundlekey = "CertDumpSHA384WithRSA";
     1:     break;
     1:   case SEC_OID_PKCS1_SHA512_WITH_RSA_ENCRYPTION:
     1:     bundlekey = "CertDumpSHA512WithRSA";
     1:     break;
 63977:   case SEC_OID_PKCS1_RSA_ENCRYPTION:
 63977:     bundlekey = "CertDumpRSAEncr";
 63977:     break;
 63977:   case SEC_OID_PKCS1_RSA_PSS_SIGNATURE:
 63977:     bundlekey = "CertDumpRSAPSSSignature";
 63977:     break;
     1:   case SEC_OID_NS_CERT_EXT_CERT_TYPE:
     1:     bundlekey = "CertDumpCertType";
     1:     break;
     1:   case SEC_OID_NS_CERT_EXT_BASE_URL:
     1:     bundlekey = "CertDumpNSCertExtBaseUrl";
     1:     break;
     1:   case SEC_OID_NS_CERT_EXT_REVOCATION_URL:
     1:     bundlekey = "CertDumpNSCertExtRevocationUrl";
     1:     break;
     1:   case SEC_OID_NS_CERT_EXT_CA_REVOCATION_URL:
     1:     bundlekey = "CertDumpNSCertExtCARevocationUrl";
     1:     break;
     1:   case SEC_OID_NS_CERT_EXT_CERT_RENEWAL_URL:
     1:     bundlekey = "CertDumpNSCertExtCertRenewalUrl";
     1:     break;
     1:   case SEC_OID_NS_CERT_EXT_CA_POLICY_URL:
     1:     bundlekey = "CertDumpNSCertExtCAPolicyUrl";
     1:     break;
     1:   case SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME:
     1:     bundlekey = "CertDumpNSCertExtSslServerName";
     1:     break;
     1:   case SEC_OID_NS_CERT_EXT_COMMENT:
     1:     bundlekey = "CertDumpNSCertExtComment";
     1:     break;
     1:   case SEC_OID_NS_CERT_EXT_LOST_PASSWORD_URL:
     1:     bundlekey = "CertDumpNSCertExtLostPasswordUrl";
     1:     break;
     1:   case SEC_OID_NS_CERT_EXT_CERT_RENEWAL_TIME:
     1:     bundlekey = "CertDumpNSCertExtCertRenewalTime";
     1:     break;
     1:   case SEC_OID_NETSCAPE_AOLSCREENNAME:
     1:     bundlekey = "CertDumpNetscapeAolScreenname";
     1:     break;
     1:   case SEC_OID_AVA_COUNTRY_NAME:
     1:     bundlekey = "CertDumpAVACountry";
     1:     break;
     1:   case SEC_OID_AVA_COMMON_NAME:
     1:     bundlekey = "CertDumpAVACN";
     1:     break;
     1:   case SEC_OID_AVA_ORGANIZATIONAL_UNIT_NAME:
     1:     bundlekey = "CertDumpAVAOU";
     1:     break;
     1:   case SEC_OID_AVA_ORGANIZATION_NAME:
     1:     bundlekey = "CertDumpAVAOrg";
     1:     break;
     1:   case SEC_OID_AVA_LOCALITY:
     1:     bundlekey = "CertDumpAVALocality";
     1:     break;
     1:   case SEC_OID_AVA_DN_QUALIFIER:
     1:     bundlekey = "CertDumpAVADN";
     1:     break;
     1:   case SEC_OID_AVA_DC:
     1:     bundlekey = "CertDumpAVADC";
     1:     break;
     1:   case SEC_OID_AVA_STATE_OR_PROVINCE:
     1:     bundlekey = "CertDumpAVAState";
     1:     break;
 25594:   case SEC_OID_AVA_SURNAME:
 25594:     bundlekey = "CertDumpSurname";
 25594:     break;
 25594:   case SEC_OID_AVA_GIVEN_NAME:
 25594:     bundlekey = "CertDumpGivenName";
 25594:     break;
     1:   case SEC_OID_X509_SUBJECT_DIRECTORY_ATTR:
     1:     bundlekey = "CertDumpSubjectDirectoryAttr";
     1:     break;
     1:   case SEC_OID_X509_SUBJECT_KEY_ID:
     1:     bundlekey = "CertDumpSubjectKeyID";
     1:     break;
     1:   case SEC_OID_X509_KEY_USAGE:
     1:     bundlekey = "CertDumpKeyUsage";
     1:     break;
     1:   case SEC_OID_X509_SUBJECT_ALT_NAME:
     1:     bundlekey = "CertDumpSubjectAltName";
     1:     break;
     1:   case SEC_OID_X509_ISSUER_ALT_NAME:
     1:     bundlekey = "CertDumpIssuerAltName";
     1:     break;
     1:   case SEC_OID_X509_BASIC_CONSTRAINTS:
     1:     bundlekey = "CertDumpBasicConstraints";
     1:     break;
     1:   case SEC_OID_X509_NAME_CONSTRAINTS:
     1:     bundlekey = "CertDumpNameConstraints";
     1:     break;
     1:   case SEC_OID_X509_CRL_DIST_POINTS:
     1:     bundlekey = "CertDumpCrlDistPoints";
     1:     break;
     1:   case SEC_OID_X509_CERTIFICATE_POLICIES:
     1:     bundlekey = "CertDumpCertPolicies";
     1:     break;
     1:   case SEC_OID_X509_POLICY_MAPPINGS:
     1:     bundlekey = "CertDumpPolicyMappings";
     1:     break;
     1:   case SEC_OID_X509_POLICY_CONSTRAINTS:
     1:     bundlekey = "CertDumpPolicyConstraints";
     1:     break;
     1:   case SEC_OID_X509_AUTH_KEY_ID:
     1:     bundlekey = "CertDumpAuthKeyID";
     1:     break;
     1:   case SEC_OID_X509_EXT_KEY_USAGE:
     1:     bundlekey = "CertDumpExtKeyUsage";
     1:     break;
     1:   case SEC_OID_X509_AUTH_INFO_ACCESS:
     1:     bundlekey = "CertDumpAuthInfoAccess";
     1:     break;
     1:   case SEC_OID_ANSIX9_DSA_SIGNATURE:
     1:     bundlekey = "CertDumpAnsiX9DsaSignature";
     1:     break;
     1:   case SEC_OID_ANSIX9_DSA_SIGNATURE_WITH_SHA1_DIGEST:
     1:     bundlekey = "CertDumpAnsiX9DsaSignatureWithSha1";
     1:     break;
     1:   case SEC_OID_ANSIX962_ECDSA_SIGNATURE_WITH_SHA1_DIGEST:
     1:     bundlekey = "CertDumpAnsiX962ECDsaSignatureWithSha1";
     1:     break;
     1:   case SEC_OID_RFC1274_UID:
     1:     bundlekey = "CertDumpUserID";
     1:     break;
     1:   case SEC_OID_PKCS9_EMAIL_ADDRESS:
     1:     bundlekey = "CertDumpPK9Email";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_PUBLIC_KEY:
     1:     bundlekey = "CertDumpECPublicKey";
     1:     break;
     1:   /* ANSI X9.62 named elliptic curves (prime field) */
     1:   case SEC_OID_ANSIX962_EC_PRIME192V1:
     1:     /* same as SEC_OID_SECG_EC_SECP192r1 */
     1:     bundlekey = "CertDumpECprime192v1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_PRIME192V2:
     1:     bundlekey = "CertDumpECprime192v2";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_PRIME192V3:
     1:     bundlekey = "CertDumpECprime192v3";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_PRIME239V1:
     1:     bundlekey = "CertDumpECprime239v1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_PRIME239V2:
     1:     bundlekey = "CertDumpECprime239v2";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_PRIME239V3:
     1:     bundlekey = "CertDumpECprime239v3";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_PRIME256V1:
     1:     /* same as SEC_OID_SECG_EC_SECP256r1 */
     1:     bundlekey = "CertDumpECprime256v1";
     1:     break;
     1:   /* SECG named elliptic curves (prime field) */
     1:   case SEC_OID_SECG_EC_SECP112R1:
     1:     bundlekey = "CertDumpECsecp112r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP112R2:
     1:     bundlekey = "CertDumpECsecp112r2";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP128R1:
     1:     bundlekey = "CertDumpECsecp128r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP128R2:
     1:     bundlekey = "CertDumpECsecp128r2";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP160K1:
     1:     bundlekey = "CertDumpECsecp160k1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP160R1:
     1:     bundlekey = "CertDumpECsecp160r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP160R2:
     1:     bundlekey = "CertDumpECsecp160r2";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP192K1:
     1:     bundlekey = "CertDumpECsecp192k1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP224K1:
     1:     bundlekey = "CertDumpECsecp224k1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP224R1:
     1:     bundlekey = "CertDumpECsecp224r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP256K1:
     1:     bundlekey = "CertDumpECsecp256k1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECP384R1:
     1:     bundlekey = "CertDumpECsecp384r1";
     1:     break;
     1: 
     1:   case SEC_OID_SECG_EC_SECP521R1:
     1:     bundlekey = "CertDumpECsecp521r1";
     1:     break;
     1:   /* ANSI X9.62 named elliptic curves (characteristic two field) */
     1:   case SEC_OID_ANSIX962_EC_C2PNB163V1:
     1:     bundlekey = "CertDumpECc2pnb163v1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2PNB163V2:
     1:     bundlekey = "CertDumpECc2pnb163v2";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2PNB163V3:
     1:     bundlekey = "CertDumpECc2pnb163v3";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2PNB176V1:
     1:     bundlekey = "CertDumpECc2pnb176v1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2TNB191V1:
     1:     bundlekey = "CertDumpECc2tnb191v1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2TNB191V2:
     1:     bundlekey = "CertDumpECc2tnb191v2";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2TNB191V3:
     1:     bundlekey = "CertDumpECc2tnb191v3";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2ONB191V4:
     1:     bundlekey = "CertDumpECc2onb191v4";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2ONB191V5:
     1:     bundlekey = "CertDumpECc2onb191v5";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2PNB208W1:
     1:     bundlekey = "CertDumpECc2pnb208w1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2TNB239V1:
     1:     bundlekey = "CertDumpECc2tnb239v1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2TNB239V2:
     1:     bundlekey = "CertDumpECc2tnb239v2";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2TNB239V3:
     1:     bundlekey = "CertDumpECc2tnb239v3";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2ONB239V4:
     1:     bundlekey = "CertDumpECc2onb239v4";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2ONB239V5:
     1:     bundlekey = "CertDumpECc2onb239v5";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2PNB272W1:
     1:     bundlekey = "CertDumpECc2pnb272w1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2PNB304W1:
     1:     bundlekey = "CertDumpECc2pnb304w1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2TNB359V1:
     1:     bundlekey = "CertDumpECc2tnb359v1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2PNB368W1:
     1:     bundlekey = "CertDumpECc2pnb368w1";
     1:     break;
     1:   case SEC_OID_ANSIX962_EC_C2TNB431R1:
     1:     bundlekey = "CertDumpECc2tnb431r1";
     1:     break;
     1:   /* SECG named elliptic curves (characteristic two field) */
     1:   case SEC_OID_SECG_EC_SECT113R1:
     1:     bundlekey = "CertDumpECsect113r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT113R2:
     1:     bundlekey = "CertDumpECsect113r2";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT131R1:
     1:     bundlekey = "CertDumpECsect131r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT131R2:
     1:     bundlekey = "CertDumpECsect131r2";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT163K1:
     1:     bundlekey = "CertDumpECsect163k1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT163R1:
     1:     bundlekey = "CertDumpECsect163r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT163R2:
     1:     bundlekey = "CertDumpECsect163r2";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT193R1:
     1:     bundlekey = "CertDumpECsect193r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT193R2:
     1:     bundlekey = "CertDumpECsect193r2";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT233K1:
     1:     bundlekey = "CertDumpECsect233k1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT233R1:
     1:     bundlekey = "CertDumpECsect233r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT239K1:
     1:     bundlekey = "CertDumpECsect239k1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT283K1:
     1:     bundlekey = "CertDumpECsect283k1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT283R1:
     1:     bundlekey = "CertDumpECsect283r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT409K1:
     1:     bundlekey = "CertDumpECsect409k1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT409R1:
     1:     bundlekey = "CertDumpECsect409r1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT571K1:
     1:     bundlekey = "CertDumpECsect571k1";
     1:     break;
     1:   case SEC_OID_SECG_EC_SECT571R1:
     1:     bundlekey = "CertDumpECsect571r1";
     1:     break;
     1:   default: 
     1:     if (oidTag == SEC_OID(MS_CERT_EXT_CERTTYPE)) {
     1:       bundlekey = "CertDumpMSCerttype";
     1:       break;
     1:     }
     1:     if (oidTag == SEC_OID(MS_CERTSERV_CA_VERSION)) {
     1:       bundlekey = "CertDumpMSCAVersion";
     1:       break;
     1:     }
     1:     if (oidTag == SEC_OID(PKIX_LOGOTYPE)) {
     1:       bundlekey = "CertDumpLogotype";
     1:       break;
     1:     }
     1:     /* fallthrough */
     1:   }
     1: 
     1:   if (bundlekey) {
     1:     rv = nssComponent->GetPIPNSSBundleString(bundlekey, text);
     1:   } else {
     1:     nsAutoString text2;
 30840:     rv = GetDefaultOIDFormat(oid, nssComponent, text2, ' ');
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1: 
     1:     const PRUnichar *params[1] = {text2.get()};
     1:     rv = nssComponent->PIPBundleFormatStringFromName("CertDumpDefOID",
     1:                                                      params, 1, text);
     1:   }
     1:   return rv;  
     1: }
     1: 
     1: #define SEPARATOR "\n"
     1: 
     1: static nsresult
     1: ProcessRawBytes(nsINSSComponent *nssComponent, SECItem *data, 
 79445:                 nsAString &text, bool wantHeader = true)
     1: {
     1:   // This function is used to display some DER bytes
     1:   // that we have not added support for decoding.
 16022:   // If it's short, let's display as an integer, no size header.
 16022: 
 16022:   if (data->len <= 4) {
 16022:     int i_pv = DER_GetInteger(data);
 16022:     nsAutoString value;
 16022:     value.AppendInt(i_pv);
 16022:     text.Append(value);
 16022:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
 16022:     return NS_OK;
 16022:   }
 16022: 
 16022:   // Else produce a hex dump.
     1: 
     1:   if (wantHeader) {
     1:     nsAutoString bytelen, bitlen;
     1:     bytelen.AppendInt(data->len);
     1:     bitlen.AppendInt(data->len*8);
     1:   
     1:     const PRUnichar *params[2] = {bytelen.get(), bitlen.get()};
     1:     nsresult rv = nssComponent->PIPBundleFormatStringFromName("CertDumpRawBytesHeader",
     1:                                                               params, 2, text);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1: 
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1: 
 16022:   // This prints the value of the byte out into a 
 16022:   // string that can later be displayed as a byte
 16022:   // string.  We place a new line after 24 bytes
 16022:   // to break up extermaly long sequence of bytes.
 16022: 
108991:   uint32_t i;
     1:   char buffer[5];
     1:   for (i=0; i<data->len; i++) {
     1:     PR_snprintf(buffer, 5, "%02x ", data->data[i]);
     1:     AppendASCIItoUTF16(buffer, text);
     1:     if ((i+1)%16 == 0) {
     1:       text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:     }
     1:   }
     1:   return NS_OK;
     1: }    
     1: 
     1: static nsresult
     1: ProcessNSCertTypeExtensions(SECItem  *extData, 
     1:                             nsAString &text,
     1:                             nsINSSComponent *nssComponent)
     1: {
     1:   nsAutoString local;
     1:   SECItem decoded;
106838:   decoded.data = nullptr;
     1:   decoded.len  = 0;
106838:   if (SECSuccess != SEC_ASN1DecodeItem(nullptr, &decoded, 
     1: 		SEC_ASN1_GET(SEC_BitStringTemplate), extData)) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpExtensionFailure", local);
     1:     text.Append(local.get());
     1:     return NS_OK;
     1:   }
     1:   unsigned char nsCertType = decoded.data[0];
     1:   nsMemory::Free(decoded.data);
     1:   if (nsCertType & NS_CERT_TYPE_SSL_CLIENT) {
     1:     nssComponent->GetPIPNSSBundleString("VerifySSLClient", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (nsCertType & NS_CERT_TYPE_SSL_SERVER) {
     1:     nssComponent->GetPIPNSSBundleString("VerifySSLServer", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (nsCertType & NS_CERT_TYPE_EMAIL) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpCertTypeEmail", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (nsCertType & NS_CERT_TYPE_OBJECT_SIGNING) {
     1:     nssComponent->GetPIPNSSBundleString("VerifyObjSign", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (nsCertType & NS_CERT_TYPE_SSL_CA) {
     1:     nssComponent->GetPIPNSSBundleString("VerifySSLCA", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (nsCertType & NS_CERT_TYPE_EMAIL_CA) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpEmailCA", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (nsCertType & NS_CERT_TYPE_OBJECT_SIGNING_CA) {
     1:     nssComponent->GetPIPNSSBundleString("VerifyObjSign", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessKeyUsageExtension(SECItem *extData, nsAString &text,
     1:                          nsINSSComponent *nssComponent)
     1: {
     1:   nsAutoString local;
     1:   SECItem decoded;
106838:   decoded.data = nullptr;
     1:   decoded.len  = 0;
106838:   if (SECSuccess != SEC_ASN1DecodeItem(nullptr, &decoded, 
     1: 				SEC_ASN1_GET(SEC_BitStringTemplate), extData)) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpExtensionFailure", local);
     1:     text.Append(local.get());
     1:     return NS_OK;
     1:   }
     1:   unsigned char keyUsage = decoded.data[0];
     1:   nsMemory::Free(decoded.data);  
     1:   if (keyUsage & KU_DIGITAL_SIGNATURE) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpKUSign", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (keyUsage & KU_NON_REPUDIATION) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpKUNonRep", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (keyUsage & KU_KEY_ENCIPHERMENT) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpKUEnc", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (keyUsage & KU_DATA_ENCIPHERMENT) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpKUDEnc", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (keyUsage & KU_KEY_AGREEMENT) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpKUKA", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (keyUsage & KU_KEY_CERT_SIGN) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpKUCertSign", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1:   if (keyUsage & KU_CRL_SIGN) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpKUCRLSigner", local);
     1:     text.Append(local.get());
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessBasicConstraints(SECItem  *extData, 
     1:                         nsAString &text,
     1:                         nsINSSComponent *nssComponent)
     1: {
     1:   nsAutoString local;
     1:   CERTBasicConstraints value;
     1:   SECStatus rv;
     1:   nsresult rv2;
     1: 
     1:   value.pathLenConstraint = -1;
     1:   rv = CERT_DecodeBasicConstraintValue (&value, extData);
     1:   if (rv != SECSuccess) {
     1:     ProcessRawBytes(nssComponent, extData, text);
     1:     return NS_OK;
     1:   }
     1:   if (value.isCA)
     1:     rv2 = nssComponent->GetPIPNSSBundleString("CertDumpIsCA", local);
     1:   else
     1:     rv2 = nssComponent->GetPIPNSSBundleString("CertDumpIsNotCA", local);
     1:   if (NS_FAILED(rv2))
     1:     return rv2;
     1:   text.Append(local.get());
     1:   if (value.pathLenConstraint != -1) {
     1:     nsAutoString depth;
     1:     if (value.pathLenConstraint == CERT_UNLIMITED_PATH_CONSTRAINT)
     1:       nssComponent->GetPIPNSSBundleString("CertDumpPathLenUnlimited", depth);
     1:     else
     1:       depth.AppendInt(value.pathLenConstraint);
     1:     const PRUnichar *params[1] = {depth.get()};
     1:     rv2 = nssComponent->PIPBundleFormatStringFromName("CertDumpPathLen",
     1:                                                       params, 1, local);
     1:     if (NS_FAILED(rv2))
     1:       return rv2;
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:     text.Append(local.get());
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessExtKeyUsage(SECItem  *extData, 
     1:                    nsAString &text,
     1:                    nsINSSComponent *nssComponent)
     1: {
     1:   nsAutoString local;
119899:   CERTOidSequence *extKeyUsage = nullptr;
     1:   SECItem **oids;
     1:   SECItem *oid;
     1:   nsresult rv;
     1:   
     1:   extKeyUsage = CERT_DecodeOidSequence(extData);
119899:   if (!extKeyUsage)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   oids = extKeyUsage->oids;
119899:   while (oids && *oids) {
     1:     // For each OID, try to find a bundle string
     1:     // of the form CertDumpEKU_<underlined-OID>
     1:     nsAutoString oidname;
     1:     oid = *oids;
 30840:     rv = GetDefaultOIDFormat(oid, nssComponent, oidname, '_');
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1:     nsAutoString bundlekey = NS_LITERAL_STRING("CertDumpEKU_")+ oidname;
     1:     NS_ConvertUTF16toUTF8 bk_ascii(bundlekey);
     1:     
     1:     rv = nssComponent->GetPIPNSSBundleString(bk_ascii.get(), local);
 30840:     nsresult rv2 = GetDefaultOIDFormat(oid, nssComponent, oidname, '.');
     1:     if (NS_FAILED(rv2))
     1:       return rv2;
     1:     if (NS_SUCCEEDED(rv)) {
     1:       // display name and OID in parentheses
     1:       text.Append(local);
     1:       text.Append(NS_LITERAL_STRING(" ("));
     1:       text.Append(oidname);
     1:       text.Append(NS_LITERAL_STRING(")"));
     1:     } else
     1:       // If there is no bundle string, just display the OID itself
     1:       text.Append(oidname);
     1: 
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:     oids++;
     1:   }
     1: 
     1:   CERT_DestroyOidSequence(extKeyUsage);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessRDN(CERTRDN* rdn, nsAString &finalString, nsINSSComponent *nssComponent)
     1: {
     1:   nsresult rv;
     1:   CERTAVA** avas;
     1:   CERTAVA* ava;
106838:   SECItem *decodeItem = nullptr;
     1:   nsString avavalue;
     1:   nsString type;
     1:   nsAutoString temp;
     1:   const PRUnichar *params[2];
     1: 
     1:   avas = rdn->avas;
     1:   while ((ava = *avas++) != 0) {
     1:     rv = GetOIDText(&ava->type, nssComponent, type);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1:     
     1:     //This function returns a string in UTF8 format.
     1:     decodeItem = CERT_DecodeAVAValue(&ava->value);
     1:     if(!decodeItem) {
     1:       return NS_ERROR_FAILURE;
     1:     }
 30839: 
 30839:     // We know we can fit buffer of this length. CERT_RFC1485_EscapeAndQuote
 30839:     // will fail if we provide smaller buffer then the result can fit to.
107846:     int escapedValueCapacity = decodeItem->len * 3 + 3;
119899:     ScopedDeleteArray<char> escapedValue(new char[escapedValueCapacity]);
 30839: 
 30839:     SECStatus status = CERT_RFC1485_EscapeAndQuote(
 30839:           escapedValue.get(),
 30839:           escapedValueCapacity, 
 30839:           (char*)decodeItem->data, 
 30839:           decodeItem->len);
 41731:     if (SECSuccess != status) {
 80486:       SECITEM_FreeItem(decodeItem, true);
 30839:       return NS_ERROR_FAILURE;
 41731:     }
 30839: 
 30839:     avavalue = NS_ConvertUTF8toUTF16(escapedValue);
     1:     
 80486:     SECITEM_FreeItem(decodeItem, true);
     1:     params[0] = type.get();
     1:     params[1] = avavalue.get();
     1:     nssComponent->PIPBundleFormatStringFromName("AVATemplate",
     1:                                                   params, 2, temp);
     1:     finalString += temp + NS_LITERAL_STRING("\n");
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessName(CERTName *name, nsINSSComponent *nssComponent, PRUnichar **value)
     1: {
     1:   CERTRDN** rdns;
     1:   CERTRDN** rdn;
     1:   nsString finalString;
     1: 
     1:   rdns = name->rdns;
     1: 
     1:   nsresult rv;
     1:   CERTRDN **lastRdn;
     1:   lastRdn = rdns;
     1: 
     1: 
     1:   /* find last RDN */
     1:   lastRdn = rdns;
     1:   while (*lastRdn) lastRdn++;
     1:   // The above whille loop will put us at the last member
     1:   // of the array which is a NULL pointer.  So let's back
     1:   // up one spot so that we have the last non-NULL entry in 
     1:   // the array in preparation for traversing the 
     1:   // RDN's (Relative Distinguished Name) in reverse oder.
     1:   lastRdn--;
     1:    
     1:   /*
     1:    * Loop over name contents in _reverse_ RDN order appending to string
     1:    * When building the Ascii string, NSS loops over these entries in 
     1:    * reverse order, so I will as well.  The difference is that NSS
     1:    * will always place them in a one line string separated by commas,
     1:    * where I want each entry on a single line.  I can't just use a comma
     1:    * as my delimitter because it is a valid character to have in the 
     1:    * value portion of the AVA and could cause trouble when parsing.
     1:    */
     1:   for (rdn = lastRdn; rdn >= rdns; rdn--) {
     1:     rv = ProcessRDN(*rdn, finalString, nssComponent);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1:   }
     1:   *value = ToNewUnicode(finalString);    
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessIA5String(SECItem  *extData, 
     1: 		 nsAString &text,
     1: 		 nsINSSComponent *nssComponent)
     1: {
     1:   SECItem item;
     1:   nsAutoString local;
106838:   if (SECSuccess != SEC_ASN1DecodeItem(nullptr, &item, 
     1: 				       SEC_ASN1_GET(SEC_IA5StringTemplate),
     1: 				       extData))
     1:     return NS_ERROR_FAILURE;
     1:   local.AssignASCII((char*)item.data, item.len);
     1:   nsMemory::Free(item.data);
     1:   text.Append(local);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
119200: AppendBMPtoUTF16(PLArenaPool *arena,
     1: 		 unsigned char* data, unsigned int len,
     1: 		 nsAString& text)
     1: {
     1:   unsigned int   utf8ValLen;
     1:   unsigned char *utf8Val;
     1: 
     1:   if (len % 2 != 0)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   /* XXX instead of converting to and from UTF-8, it would
     1:      be sufficient to just swap bytes, or do nothing */
     1:   utf8ValLen = len * 3 + 1;
     1:   utf8Val = (unsigned char*)PORT_ArenaZAlloc(arena, utf8ValLen);
 80486:   if (!PORT_UCS2_UTF8Conversion(false, data, len,
     1: 				utf8Val, utf8ValLen, &utf8ValLen))
     1:     return NS_ERROR_FAILURE;
     1:   AppendUTF8toUTF16((char*)utf8Val, text);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessBMPString(SECItem  *extData, 
     1: 		 nsAString &text,
     1: 		 nsINSSComponent *nssComponent)
     1: {
     1:   SECItem item;
119200:   PLArenaPool *arena;
     1:   nsresult rv = NS_ERROR_FAILURE;
     1:   
     1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   if (SECSuccess == SEC_ASN1DecodeItem(arena, &item, 
     1: 				       SEC_ASN1_GET(SEC_BMPStringTemplate),
     1: 				       extData))
     1:     rv = AppendBMPtoUTF16(arena, item.data, item.len, text);
 80486:   PORT_FreeArena(arena, false);
     1:   return rv;
     1: }
     1: 
     1: static nsresult
119200: ProcessGeneralName(PLArenaPool *arena,
     1: 		   CERTGeneralName *current,
     1: 		   nsAString &text,
     1: 		   nsINSSComponent *nssComponent)
     1: {
 25338:   NS_ENSURE_ARG_POINTER(current);
 25338: 
     1:   nsAutoString key;
     1:   nsXPIDLString value;
     1:   nsresult rv = NS_OK;
     1: 
     1:   switch (current->type) {
     1:   case certOtherName: {
     1:     SECOidTag oidTag = SECOID_FindOIDTag(&current->name.OthName.oid);
     1:     if (oidTag == SEC_OID(MS_NT_PRINCIPAL_NAME)) {
     1: 	/* The type of this name is apparently nowhere explicitly
     1: 	   documented. However, in the generated templates, it is always
     1: 	   UTF-8. So try to decode this as UTF-8; if that fails, dump the
     1: 	   raw data. */
     1: 	SECItem decoded;
     1: 	nssComponent->GetPIPNSSBundleString("CertDumpMSNTPrincipal", key);
     1: 	if (SEC_ASN1DecodeItem(arena, &decoded, 
     1: 			       SEC_ASN1_GET(SEC_UTF8StringTemplate), 
     1: 			       &current->name.OthName.name) == SECSuccess) {
110974: 	  AppendUTF8toUTF16(nsAutoCString((char*)decoded.data, decoded.len),
     1: 			    value);
     1: 	} else {
     1: 	  ProcessRawBytes(nssComponent, &current->name.OthName.name, value);
     1: 	}
     1: 	break;
     1:     } else if (oidTag == SEC_OID(MS_NTDS_REPLICATION)) {
     1: 	/* This should be a 16-byte GUID */
     1: 	SECItem guid;
     1: 	nssComponent->GetPIPNSSBundleString("CertDumpMSDomainGUID", key);
     1: 	if (SEC_ASN1DecodeItem(arena, &guid,
     1: 			       SEC_ASN1_GET(SEC_OctetStringTemplate),
     1: 			       &current->name.OthName.name) == SECSuccess
     1: 	    && guid.len == 16) {
     1: 	  char buf[40];
     1: 	  unsigned char *d = guid.data;
     1: 	  PR_snprintf(buf, sizeof(buf), 
     1: 		      "{%.2x%.2x%.2x%.2x-%.2x%.2x-%.2x%.2x-%.2x%.2x-%.2x%.2x%.2x%.2x%.2x%.2x}",
     1: 		      d[3], d[2], d[1], d[0], d[5], d[4], d[7], d[6],
     1: 		      d[8], d[9], d[10], d[11], d[12], d[13], d[14], d[15]);
     1: 	  value.AssignASCII(buf);
     1: 	} else {
     1: 	  ProcessRawBytes(nssComponent, &current->name.OthName.name, value);
     1: 	}
     1:     } else {
 30840:       rv = GetDefaultOIDFormat(&current->name.OthName.oid, nssComponent, key, ' ');
     1:       if (NS_FAILED(rv))
     1: 	goto finish;
     1:       ProcessRawBytes(nssComponent, &current->name.OthName.name, value);
     1:     }
     1:     break;
     1:   }
     1:   case certRFC822Name:
     1:     nssComponent->GetPIPNSSBundleString("CertDumpRFC822Name", key);
     1:     value.AssignASCII((char*)current->name.other.data, current->name.other.len);
     1:     break;
     1:   case certDNSName:
     1:     nssComponent->GetPIPNSSBundleString("CertDumpDNSName", key);
     1:     value.AssignASCII((char*)current->name.other.data, current->name.other.len);
     1:     break;
     1:   case certX400Address:
     1:     nssComponent->GetPIPNSSBundleString("CertDumpX400Address", key);
     1:     ProcessRawBytes(nssComponent, &current->name.other, value);
     1:     break;
     1:   case certDirectoryName:
     1:     nssComponent->GetPIPNSSBundleString("CertDumpDirectoryName", key);
     1:     rv = ProcessName(&current->name.directoryName, nssComponent, 
     1: 		     getter_Copies(value));
     1:     if (NS_FAILED(rv))
     1:       goto finish;
     1:     break;
     1:   case certEDIPartyName:
     1:     nssComponent->GetPIPNSSBundleString("CertDumpEDIPartyName", key);
     1:     ProcessRawBytes(nssComponent, &current->name.other, value);
     1:     break;
     1:   case certURI:
     1:     nssComponent->GetPIPNSSBundleString("CertDumpURI", key);
     1:     value.AssignASCII((char*)current->name.other.data, current->name.other.len);
     1:     break;
     1:   case certIPAddress:
     1:     {
     1:       char buf[INET6_ADDRSTRLEN];
  9071:       PRStatus status = PR_FAILURE;
     1:       PRNetAddr addr;
  9071:       memset(&addr, 0, sizeof(addr));
     1:       nssComponent->GetPIPNSSBundleString("CertDumpIPAddress", key);
     1:       if (current->name.other.len == 4) {
     1:         addr.inet.family = PR_AF_INET;
     1:         memcpy(&addr.inet.ip, current->name.other.data, current->name.other.len);
  9071:         status = PR_NetAddrToString(&addr, buf, sizeof(buf));
     1:       } else if (current->name.other.len == 16) {
     1:         addr.ipv6.family = PR_AF_INET6;
     1:         memcpy(&addr.ipv6.ip, current->name.other.data, current->name.other.len);
  9071:         status = PR_NetAddrToString(&addr, buf, sizeof(buf));
  9071:       }
  9071:       if (status == PR_SUCCESS) {
     1:         value.AssignASCII(buf);
     1:       } else {
     1:         /* invalid IP address */
     1:         ProcessRawBytes(nssComponent, &current->name.other, value);
     1:       }
     1:       break;
     1:     }
     1:   case certRegisterID:
     1:     nssComponent->GetPIPNSSBundleString("CertDumpRegisterID", key);
 30840:     rv = GetDefaultOIDFormat(&current->name.other, nssComponent, value, '.');
     1:     if (NS_FAILED(rv))
     1:       goto finish;
     1:     break;
     1:   }
     1:   text.Append(key);
     1:   text.Append(NS_LITERAL_STRING(": "));
     1:   text.Append(value);
     1:   text.Append(NS_LITERAL_STRING(SEPARATOR));
     1:  finish:
     1:     return rv;
     1: }
     1: 
     1: static nsresult
119200: ProcessGeneralNames(PLArenaPool *arena,
     1: 		    CERTGeneralName *nameList,
     1: 		    nsAString &text,
     1: 		    nsINSSComponent *nssComponent)
     1: {
     1:   CERTGeneralName *current = nameList;
     1:   nsresult rv;
     1: 
     1:   do {
     1:     rv = ProcessGeneralName(arena, current, text, nssComponent);
     1:     if (NS_FAILED(rv))
     1:       break;
     1:     current = CERT_GetNextGeneralName(current);
     1:   } while (current != nameList);
     1:   return rv;
     1: }
     1: 
     1: static nsresult
     1: ProcessAltName(SECItem  *extData, 
     1: 	       nsAString &text,
     1: 	       nsINSSComponent *nssComponent)
     1: {
     1:   nsresult rv = NS_OK;
119200:   PLArenaPool *arena;
     1:   CERTGeneralName *nameList;
     1: 
     1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   nameList = CERT_DecodeAltNameExtension(arena, extData);
     1:   if (!nameList)
     1:     goto finish;
     1: 
     1:   rv = ProcessGeneralNames(arena, nameList, text, nssComponent);
     1: 
     1:  finish:
 80486:   PORT_FreeArena(arena, false);
     1:   return rv;
     1: }
     1: 
     1: static nsresult
     1: ProcessSubjectKeyId(SECItem  *extData, 
     1: 		    nsAString &text,
     1: 		    nsINSSComponent *nssComponent)
     1: {
119200:   PLArenaPool *arena;
     1:   nsresult rv = NS_OK;
     1:   SECItem decoded;
     1:   nsAutoString local;
     1: 
     1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   if (SEC_QuickDERDecodeItem(arena, &decoded, 
     1: 			     SEC_ASN1_GET(SEC_OctetStringTemplate), 
     1: 			     extData) != SECSuccess) {
     1:     rv = NS_ERROR_FAILURE;
     1:     goto finish;
     1:   }
     1:   
     1:   nssComponent->GetPIPNSSBundleString("CertDumpKeyID", local);
     1:   text.Append(local);
     1:   text.Append(NS_LITERAL_STRING(": "));
     1:   ProcessRawBytes(nssComponent, &decoded, text);
     1: 
     1:  finish:
 80486:   PORT_FreeArena(arena, false);
     1:   return rv;
     1: }
     1: 
     1: static nsresult
     1: ProcessAuthKeyId(SECItem  *extData, 
     1: 		 nsAString &text,
     1: 		 nsINSSComponent *nssComponent)
     1: {
     1:   CERTAuthKeyID *ret;
119200:   PLArenaPool *arena;
     1:   nsresult rv = NS_OK;
     1:   nsAutoString local;
     1: 
     1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena)
 60473:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   ret = CERT_DecodeAuthKeyID (arena, extData);
 60473:   if (!ret) {
 60473:     rv = NS_ERROR_FAILURE;
 60473:     goto finish;
 60473:   }
     1: 
     1:   if (ret->keyID.len > 0) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpKeyID", local);
     1:     text.Append(local);
     1:     text.Append(NS_LITERAL_STRING(": "));
     1:     ProcessRawBytes(nssComponent, &ret->keyID, text);
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR));
     1:   }
     1: 
     1:   if (ret->authCertIssuer) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpIssuer", local);
     1:     text.Append(local);
     1:     text.Append(NS_LITERAL_STRING(": "));
     1:     rv = ProcessGeneralNames(arena, ret->authCertIssuer, text, nssComponent);
     1:     if (NS_FAILED(rv))
     1:       goto finish;
     1:   }
     1: 
     1:   if (ret->authCertSerialNumber.len > 0) {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpSerialNo", local);
     1:     text.Append(local);
     1:     text.Append(NS_LITERAL_STRING(": "));
     1:     ProcessRawBytes(nssComponent, &ret->authCertSerialNumber, text);
     1:   }
     1: 
     1:  finish:
 80486:   PORT_FreeArena(arena, false);
     1:   return rv;
     1: }
     1: 
     1: static nsresult
     1: ProcessUserNotice(SECItem *der_notice,
     1: 		  nsAString &text,
     1: 		  nsINSSComponent *nssComponent)
     1: {
119899:   CERTUserNotice *notice = nullptr;
     1:   SECItem **itemList;
119200:   PLArenaPool *arena;
     1: 
     1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   notice = CERT_DecodeUserNotice(der_notice);
119899:   if (!notice) {
  9065:     ProcessRawBytes(nssComponent, der_notice, text);
     1:     goto finish;
     1:   }
     1: 
     1:   if (notice->noticeReference.organization.len != 0) {
  9065:     switch (notice->noticeReference.organization.type) {
  9065:     case siAsciiString:
  9065:     case siVisibleString:
  9065:     case siUTF8String:
  9065:       text.Append(NS_ConvertUTF8toUTF16(
  9065:                   (const char *)notice->noticeReference.organization.data,
  9065:                   notice->noticeReference.organization.len));
  9065:       break;
  9065:     case siBMPString:
  9065:       AppendBMPtoUTF16(arena, notice->noticeReference.organization.data,
  9065:                        notice->noticeReference.organization.len, text);
  9065:       break;
  9065:     default:
  9065:       break;
  9065:     }
  9065:     text.Append(NS_LITERAL_STRING(" - "));
     1:     itemList = notice->noticeReference.noticeNumbers;
     1:     while (*itemList) {
     1:       unsigned long number;
     1:       char buffer[60];
  9065:       if (SEC_ASN1DecodeInteger(*itemList, &number) == SECSuccess) {
  9065:         PR_snprintf(buffer, sizeof(buffer), "#%d", number);
  9065:         if (itemList != notice->noticeReference.noticeNumbers)
  9065:           text.Append(NS_LITERAL_STRING(", "));
  9065:         AppendASCIItoUTF16(buffer, text);
     1:       }
     1:       itemList++;
     1:     }
     1:   }
     1:   if (notice->displayText.len != 0) {
  9065:     text.Append(NS_LITERAL_STRING(SEPARATOR));
  9065:     text.Append(NS_LITERAL_STRING("    "));
  9065:     switch (notice->displayText.type) {
  9065:     case siAsciiString:
  9065:     case siVisibleString:
  9065:     case siUTF8String:
  9065:       text.Append(NS_ConvertUTF8toUTF16((const char *)notice->displayText.data,
  9065:                                         notice->displayText.len));
     1:       break;
  9065:     case siBMPString:
  9065:       AppendBMPtoUTF16(arena, notice->displayText.data, notice->displayText.len,
     1: 		       text);
     1:       break;
  9065:     default:
     1:       break;
     1:     }
     1:   }
     1:  finish:
     1:   if (notice)
     1:     CERT_DestroyUserNotice(notice);
 80486:   PORT_FreeArena(arena, false);
  9065:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessCertificatePolicies(SECItem  *extData, 
     1: 			   nsAString &text,
  7105:                            SECOidTag ev_oid_tag, // SEC_OID_UNKNOWN means: not EV
     1: 			   nsINSSComponent *nssComponent)
     1: {
     1:   CERTCertificatePolicies *policies;
     1:   CERTPolicyInfo **policyInfos, *policyInfo;
     1:   CERTPolicyQualifier **policyQualifiers, *policyQualifier;
     1:   nsAutoString local;
     1:   nsresult rv = NS_OK;
     1: 
     1:   policies = CERT_DecodeCertificatePoliciesExtension(extData);
119899:   if (!policies)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   policyInfos = policies->policyInfos;
119899:   while (*policyInfos) {
     1:     policyInfo = *policyInfos++;
     1:     switch (policyInfo->oid) {
     1:     case SEC_OID_VERISIGN_USER_NOTICES:
     1:       nssComponent->GetPIPNSSBundleString("CertDumpVerisignNotices", local);
     1:       text.Append(local);
     1:       break;
     1:     default:
 30840:       GetDefaultOIDFormat(&policyInfo->policyID, nssComponent, local, '.');
     1:       text.Append(local);
     1:     }
  7105: 
 79445:     bool needColon = true;
  7105:     if (ev_oid_tag != SEC_OID_UNKNOWN) {
  7105:       // This is an EV cert. Let's see if this oid is the EV oid,
  7105:       // because we want to display the EV information string
  7105:       // next to the correct OID.
  7105: 
 31560:       if (policyInfo->oid == ev_oid_tag) {
  7105:         text.Append(NS_LITERAL_STRING(":"));
  7105:         text.Append(NS_LITERAL_STRING(SEPARATOR));
 80486:         needColon = false;
  7105:         nssComponent->GetPIPNSSBundleString("CertDumpPolicyOidEV", local);
  7105:         text.Append(local);
  7105:       }
  7105:     }
  7105: 
     1:     if (policyInfo->policyQualifiers) {
     1:       /* Add all qualifiers on separate lines, indented */
     1:       policyQualifiers = policyInfo->policyQualifiers;
  7105:       if (needColon)
     1:         text.Append(NS_LITERAL_STRING(":"));
     1:       text.Append(NS_LITERAL_STRING(SEPARATOR));
119899:       while (*policyQualifiers) {
     1: 	text.Append(NS_LITERAL_STRING("  "));
     1: 	policyQualifier = *policyQualifiers++;
     1: 	switch(policyQualifier->oid) {
     1: 	case SEC_OID_PKIX_CPS_POINTER_QUALIFIER:
     1: 	  nssComponent->GetPIPNSSBundleString("CertDumpCPSPointer", local);
     1: 	  text.Append(local);
     1: 	  text.Append(NS_LITERAL_STRING(":"));
     1: 	  text.Append(NS_LITERAL_STRING(SEPARATOR));
     1: 	  text.Append(NS_LITERAL_STRING("    "));
     1: 	  /* The CPS pointer ought to be the cPSuri alternative
     1: 	     of the Qualifier choice. */
     1: 	  rv = ProcessIA5String(&policyQualifier->qualifierValue,
     1: 				text, nssComponent);
     1: 	  if (NS_FAILED(rv))
     1: 	    goto finish;
     1: 	  break;
     1: 	case SEC_OID_PKIX_USER_NOTICE_QUALIFIER:
     1: 	  nssComponent->GetPIPNSSBundleString("CertDumpUserNotice", local);
     1: 	  text.Append(local);
     1: 	  text.Append(NS_LITERAL_STRING(": "));
     1: 	  rv = ProcessUserNotice(&policyQualifier->qualifierValue,
     1: 				 text, nssComponent);
     1: 	  break;
     1: 	default:
 30840: 	  GetDefaultOIDFormat(&policyQualifier->qualifierID, nssComponent, local, '.');
     1: 	  text.Append(local);
     1: 	  text.Append(NS_LITERAL_STRING(": "));
     1: 	  ProcessRawBytes(nssComponent, &policyQualifier->qualifierValue, text);
     1: 	}
     1: 	text.Append(NS_LITERAL_STRING(SEPARATOR));
     1:       } /* while policyQualifiers */
     1:     } /* if policyQualifiers */
     1:     text.Append(NS_LITERAL_STRING(SEPARATOR));
     1:   }
     1: 
     1:  finish:
     1:   CERT_DestroyCertificatePoliciesExtension(policies);
     1:   return rv;
     1: }
     1: 
     1: static nsresult
     1: ProcessCrlDistPoints(SECItem  *extData, 
     1: 		     nsAString &text,
     1: 		     nsINSSComponent *nssComponent)
     1: {
     1:   CERTCrlDistributionPoints *crldp;
     1:   CRLDistributionPoint **points, *point;
119200:   PLArenaPool *arena;
     1:   nsresult rv = NS_OK;
     1:   nsAutoString local;
     1:   int reasons, comma;
     1: 
     1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   crldp = CERT_DecodeCRLDistributionPoints(arena, extData);
     1:   if (!crldp || !crldp->distPoints) {
     1:     rv = NS_ERROR_FAILURE;
     1:     goto finish;
     1:   }
     1: 
     1:   for(points = crldp->distPoints; *points; points++) {
     1:     point = *points;
     1:     switch (point->distPointType) {
     1:     case generalName:
     1:       rv = ProcessGeneralName(arena, point->distPoint.fullName,
     1: 			      text, nssComponent);
     1:       if (NS_FAILED(rv))
     1: 	goto finish;
     1:       break;
     1:     case relativeDistinguishedName:
     1:       rv = ProcessRDN(&point->distPoint.relativeName, 
     1: 		      text, nssComponent);
     1:       if (NS_FAILED(rv))
     1: 	goto finish;
     1:       break;
     1:     }
     1:     if (point->reasons.len) { 
     1:       reasons = point->reasons.data[0];
     1:       text.Append(NS_LITERAL_STRING(" "));
     1:       comma = 0;
     1:       if (reasons & RF_UNUSED) {
     1: 	nssComponent->GetPIPNSSBundleString("CertDumpUnused", local);
     1: 	text.Append(local); comma = 1;
     1:       }
     1:       if (reasons & RF_KEY_COMPROMISE) {
     1: 	if (comma) text.Append(NS_LITERAL_STRING(", "));
     1: 	nssComponent->GetPIPNSSBundleString("CertDumpKeyCompromise", local);
     1: 	text.Append(local); comma = 1;
     1:       }
     1:       if (reasons & RF_CA_COMPROMISE) {
     1: 	if (comma) text.Append(NS_LITERAL_STRING(", "));
     1: 	nssComponent->GetPIPNSSBundleString("CertDumpCACompromise", local);
     1: 	text.Append(local); comma = 1;
     1:       }
     1:       if (reasons & RF_AFFILIATION_CHANGED) {
     1: 	if (comma) text.Append(NS_LITERAL_STRING(", "));
     1: 	nssComponent->GetPIPNSSBundleString("CertDumpAffiliationChanged", local);
     1: 	text.Append(local); comma = 1;
     1:       }
     1:       if (reasons & RF_SUPERSEDED) {
     1: 	if (comma) text.Append(NS_LITERAL_STRING(", "));
     1: 	nssComponent->GetPIPNSSBundleString("CertDumpSuperseded", local);
     1: 	text.Append(local); comma = 1;
     1:       }
     1:       if (reasons & RF_CESSATION_OF_OPERATION) {
     1: 	if (comma) text.Append(NS_LITERAL_STRING(", "));
     1: 	nssComponent->GetPIPNSSBundleString("CertDumpCessation", local);
     1: 	text.Append(local); comma = 1;
     1:       }
     1:       if (reasons & RF_CERTIFICATE_HOLD) {
     1: 	if (comma) text.Append(NS_LITERAL_STRING(", "));
     1: 	nssComponent->GetPIPNSSBundleString("CertDumpHold", local);
     1: 	text.Append(local); comma = 1;
     1:       }
     1:       text.Append(NS_LITERAL_STRING(SEPARATOR));
     1:     }
     1:     if (point->crlIssuer) {
     1:       nssComponent->GetPIPNSSBundleString("CertDumpIssuer", local);
     1:       text.Append(local);
     1:       text.Append(NS_LITERAL_STRING(": "));
     1:       rv = ProcessGeneralNames(arena, point->crlIssuer,
     1: 			       text, nssComponent);
     1:       if (NS_FAILED(rv))
     1: 	goto finish;
     1:     }
     1:   }
     1:   
     1:  finish:
 80486:   PORT_FreeArena(arena, false);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessAuthInfoAccess(SECItem  *extData, 
     1: 		      nsAString &text,
     1: 		      nsINSSComponent *nssComponent)
     1: {
     1:   CERTAuthInfoAccess **aia, *desc;
119200:   PLArenaPool *arena;
     1:   nsresult rv = NS_OK;
     1:   nsAutoString local;
     1: 
     1:   arena = PORT_NewArena(DER_DEFAULT_CHUNKSIZE);
     1:   if (!arena)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   aia = CERT_DecodeAuthInfoAccessExtension(arena, extData);
119899:   if (!aia)
     1:     goto finish;
     1: 
119899:   while (*aia) {
     1:     desc = *aia++;
     1:     switch (SECOID_FindOIDTag(&desc->method)) {
     1:     case SEC_OID_PKIX_OCSP:
     1:       nssComponent->GetPIPNSSBundleString("CertDumpOCSPResponder", local);
     1:       break;
     1:     case SEC_OID_PKIX_CA_ISSUERS:
     1:       nssComponent->GetPIPNSSBundleString("CertDumpCAIssuers", local);
     1:       break;
     1:     default:
 30840:       rv = GetDefaultOIDFormat(&desc->method, nssComponent, local, '.');
     1:       if (NS_FAILED(rv))
     1: 	goto finish;
     1:     }
     1:     text.Append(local);
     1:     text.Append(NS_LITERAL_STRING(": "));
     1:     rv = ProcessGeneralName(arena, desc->location, text, nssComponent);
     1:     if (NS_FAILED(rv))
     1:       goto finish;
     1:   }
     1: 
     1:  finish:
 80486:   PORT_FreeArena(arena, false);
     1:   return rv;
     1: }
     1: 
     1: static nsresult
     1: ProcessMSCAVersion(SECItem  *extData, 
     1: 		   nsAString &text,
     1: 		   nsINSSComponent *nssComponent)
     1: {
     1:   unsigned long version;
     1:   nsresult rv;
     1:   char buf[50];
     1:   SECItem decoded;
     1: 
106838:   if (SECSuccess != SEC_ASN1DecodeItem(nullptr, &decoded, 
     1: 				       SEC_ASN1_GET(SEC_IntegerTemplate), 
     1: 				       extData))
     1:     /* This extension used to be an Integer when this code
     1:        was written, but apparently isn't anymore. Display
     1:        the raw bytes instead. */
     1:     return ProcessRawBytes(nssComponent, extData, text);
     1: 
     1:   rv = GetIntValue(&decoded, &version);
     1:   nsMemory::Free(decoded.data);
     1:   if (NS_FAILED(rv))
     1:     /* Value out of range, display raw bytes */
     1:     return ProcessRawBytes(nssComponent, extData, text);
     1: 
     1:   /* Apparently, the encoding is <minor><major>, with 16 bits each */
     1:   PR_snprintf(buf, sizeof(buf), "%d.%d", version & 0xFFFF, version>>16);
     1:   text.AppendASCII(buf);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessExtensionData(SECOidTag oidTag, SECItem *extData, 
  7105:                      nsAString &text, 
  7105:                      SECOidTag ev_oid_tag, // SEC_OID_UNKNOWN means: not EV
  7105:                      nsINSSComponent *nssComponent)
     1: {
     1:   nsresult rv;
     1:   switch (oidTag) {
     1:   case SEC_OID_NS_CERT_EXT_CERT_TYPE:
     1:     rv = ProcessNSCertTypeExtensions(extData, text, nssComponent);
     1:     break;
     1:   case SEC_OID_X509_KEY_USAGE:
     1:     rv = ProcessKeyUsageExtension(extData, text, nssComponent);
     1:     break;
     1:   case SEC_OID_X509_BASIC_CONSTRAINTS:
     1:     rv = ProcessBasicConstraints(extData, text, nssComponent);
     1:     break;
     1:   case SEC_OID_X509_EXT_KEY_USAGE:
     1:     rv = ProcessExtKeyUsage(extData, text, nssComponent);
     1:     break;
     1:   case SEC_OID_X509_ISSUER_ALT_NAME:
     1:   case SEC_OID_X509_SUBJECT_ALT_NAME:
     1:     rv = ProcessAltName(extData, text, nssComponent);
     1:     break;
     1:   case SEC_OID_X509_SUBJECT_KEY_ID:
     1:     rv = ProcessSubjectKeyId(extData, text, nssComponent);
     1:     break;
     1:   case SEC_OID_X509_AUTH_KEY_ID:
     1:     rv = ProcessAuthKeyId(extData, text, nssComponent);
     1:     break;
     1:   case SEC_OID_X509_CERTIFICATE_POLICIES:
  7105:     rv = ProcessCertificatePolicies(extData, text, ev_oid_tag, nssComponent);
     1:     break;
     1:   case SEC_OID_X509_CRL_DIST_POINTS:
     1:     rv = ProcessCrlDistPoints(extData, text, nssComponent);
     1:     break;
     1:   case SEC_OID_X509_AUTH_INFO_ACCESS:
     1:     rv = ProcessAuthInfoAccess(extData, text, nssComponent);
     1:     break;
     1:   case SEC_OID_NS_CERT_EXT_BASE_URL:
     1:   case SEC_OID_NS_CERT_EXT_REVOCATION_URL:
     1:   case SEC_OID_NS_CERT_EXT_CA_REVOCATION_URL:
     1:   case SEC_OID_NS_CERT_EXT_CA_CERT_URL:
     1:   case SEC_OID_NS_CERT_EXT_CERT_RENEWAL_URL:
     1:   case SEC_OID_NS_CERT_EXT_CA_POLICY_URL:
     1:   case SEC_OID_NS_CERT_EXT_HOMEPAGE_URL:
     1:   case SEC_OID_NS_CERT_EXT_COMMENT:
     1:   case SEC_OID_NS_CERT_EXT_SSL_SERVER_NAME:
     1:   case SEC_OID_NS_CERT_EXT_LOST_PASSWORD_URL:
     1:     rv = ProcessIA5String(extData, text, nssComponent);
     1:     break;
     1:   default:
     1:     if (oidTag == SEC_OID(MS_CERT_EXT_CERTTYPE)) {
     1:       rv = ProcessBMPString(extData, text, nssComponent);
     1:       break;
     1:     }
     1:     if (oidTag == SEC_OID(MS_CERTSERV_CA_VERSION)) {
     1:       rv = ProcessMSCAVersion(extData, text, nssComponent);
     1:       break;
     1:     }
     1:     rv = ProcessRawBytes(nssComponent, extData, text);
     1:     break; 
     1:   }
     1:   return rv;
     1: }
     1: 
     1: static nsresult
     1: ProcessSingleExtension(CERTCertExtension *extension,
  7105:                        SECOidTag ev_oid_tag, // SEC_OID_UNKNOWN means: not EV
     1:                        nsINSSComponent *nssComponent,
     1:                        nsIASN1PrintableItem **retExtension)
     1: {
     1:   nsAutoString text, extvalue;
     1:   GetOIDText(&extension->id, nssComponent, text);
     1:   nsCOMPtr<nsIASN1PrintableItem>extensionItem = new nsNSSASN1PrintableItem();
     1: 
     1:   extensionItem->SetDisplayName(text);
     1:   SECOidTag oidTag = SECOID_FindOIDTag(&extension->id);
     1:   text.Truncate();
119899:   if (extension->critical.data) {
     1:     if (extension->critical.data[0]) {
     1:       nssComponent->GetPIPNSSBundleString("CertDumpCritical", text);
     1:     } else {
     1:       nssComponent->GetPIPNSSBundleString("CertDumpNonCritical", text);
     1:     }
     1:   } else {
     1:     nssComponent->GetPIPNSSBundleString("CertDumpNonCritical", text);
     1:   }
     1:   text.Append(NS_LITERAL_STRING(SEPARATOR).get());
     1:   nsresult rv = ProcessExtensionData(oidTag, &extension->value, extvalue, 
  7105:                                      ev_oid_tag, nssComponent);
     1:   if (NS_FAILED(rv)) {
     1:     extvalue.Truncate();
 80486:     rv = ProcessRawBytes(nssComponent, &extension->value, extvalue, false);
     1:   }
     1:   text.Append(extvalue);
     1: 
     1:   extensionItem->SetDisplayValue(text);
     1:   *retExtension = extensionItem;
     1:   NS_ADDREF(*retExtension);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessSECAlgorithmID(SECAlgorithmID *algID,
     1:                       nsINSSComponent *nssComponent,
     1:                       nsIASN1Sequence **retSequence)
     1: {
     1:   SECOidTag algOIDTag = SECOID_FindOIDTag(&algID->algorithm);
119899:   SECItem paramsOID = { siBuffer, nullptr, 0 };
     1:   nsCOMPtr<nsIASN1Sequence> sequence = new nsNSSASN1Sequence();
     1: 
106838:   *retSequence = nullptr;
     1:   nsString text;
     1:   GetOIDText(&algID->algorithm, nssComponent, text);
     1:   if (!algID->parameters.len || algID->parameters.data[0] == nsIASN1Object::ASN1_NULL) {
     1:     sequence->SetDisplayValue(text);
 80486:     sequence->SetIsValidContainer(false);
     1:   } else {
     1:     nsCOMPtr<nsIASN1PrintableItem> printableItem = new nsNSSASN1PrintableItem();
     1: 
     1:     printableItem->SetDisplayValue(text);
     1:     nsCOMPtr<nsIMutableArray> asn1Objects;
     1:     sequence->GetASN1Objects(getter_AddRefs(asn1Objects));
 80486:     asn1Objects->AppendElement(printableItem, false);
     1:     nssComponent->GetPIPNSSBundleString("CertDumpAlgID", text);
     1:     printableItem->SetDisplayName(text);
     1: 
     1:     printableItem = new nsNSSASN1PrintableItem();
     1: 
 80486:     asn1Objects->AppendElement(printableItem, false);
     1:     nssComponent->GetPIPNSSBundleString("CertDumpParams", text);
     1:     printableItem->SetDisplayName(text);
     1:     if ((algOIDTag == SEC_OID_ANSIX962_EC_PUBLIC_KEY) &&
     1:         (algID->parameters.len > 2) && 
     1:         (algID->parameters.data[0] == nsIASN1Object::ASN1_OBJECT_ID)) {
     1:        paramsOID.len = algID->parameters.len - 2;
     1:        paramsOID.data = algID->parameters.data + 2;
     1:        GetOIDText(&paramsOID, nssComponent, text);
     1:     } else {
     1:        ProcessRawBytes(nssComponent, &algID->parameters,text);
     1:     }
     1:     printableItem->SetDisplayValue(text);
     1:   }
     1:   *retSequence = sequence;
     1:   NS_ADDREF(*retSequence);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessTime(PRTime dispTime, const PRUnichar *displayName, 
     1:             nsIASN1Sequence *parentSequence)
     1: {
     1:   nsresult rv;
     1:   nsCOMPtr<nsIDateTimeFormat> dateFormatter =
     1:      do_CreateInstance(NS_DATETIMEFORMAT_CONTRACTID, &rv);
     1:   if (NS_FAILED(rv)) 
     1:     return rv;
     1: 
     1:   nsString text;
     1:   nsString tempString;
     1: 
     1:   PRExplodedTime explodedTime;
     1:   PR_ExplodeTime(dispTime, PR_LocalTimeParameters, &explodedTime);
     1: 
106838:   dateFormatter->FormatPRExplodedTime(nullptr, kDateFormatShort, kTimeFormatSecondsForce24Hour,
     1:                               &explodedTime, tempString);
     1: 
     1:   text.Append(tempString);
     1:   text.AppendLiteral("\n(");
     1: 
     1:   PRExplodedTime explodedTimeGMT;
     1:   PR_ExplodeTime(dispTime, PR_GMTParameters, &explodedTimeGMT);
     1: 
106838:   dateFormatter->FormatPRExplodedTime(nullptr, kDateFormatShort, kTimeFormatSecondsForce24Hour,
     1:                               &explodedTimeGMT, tempString);
     1: 
     1:   text.Append(tempString);
     1:   text.Append(NS_LITERAL_STRING(" GMT)"));
     1: 
     1:   nsCOMPtr<nsIASN1PrintableItem> printableItem = new nsNSSASN1PrintableItem();
     1: 
     1:   printableItem->SetDisplayValue(text);
     1:   printableItem->SetDisplayName(nsDependentString(displayName));
     1:   nsCOMPtr<nsIMutableArray> asn1Objects;
     1:   parentSequence->GetASN1Objects(getter_AddRefs(asn1Objects));
 80486:   asn1Objects->AppendElement(printableItem, false);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessSubjectPublicKeyInfo(CERTSubjectPublicKeyInfo *spki, 
     1:                             nsIASN1Sequence *parentSequence,
     1:                             nsINSSComponent *nssComponent)
     1: {
     1:   nsCOMPtr<nsIASN1Sequence> spkiSequence = new nsNSSASN1Sequence();
     1: 
     1:   nsString text;
     1:   nssComponent->GetPIPNSSBundleString("CertDumpSPKI", text);
     1:   spkiSequence->SetDisplayName(text);
     1: 
     1:   nssComponent->GetPIPNSSBundleString("CertDumpSPKIAlg", text);
     1:   nsCOMPtr<nsIASN1Sequence> sequenceItem;
     1:   nsresult rv = ProcessSECAlgorithmID(&spki->algorithm, nssComponent,
     1:                                       getter_AddRefs(sequenceItem));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1:   sequenceItem->SetDisplayName(text);
     1:   nsCOMPtr<nsIMutableArray> asn1Objects;
     1:   spkiSequence->GetASN1Objects(getter_AddRefs(asn1Objects));
 80486:   asn1Objects->AppendElement(sequenceItem, false);
     1: 
     1:   nsCOMPtr<nsIASN1PrintableItem> printableItem = new nsNSSASN1PrintableItem();
     1: 
     1:   text.Truncate();
     1:  
     1:   SECKEYPublicKey *key = SECKEY_ExtractPublicKey(spki);
     1:   bool displayed = false;
119899:   if (key) {
     1:       switch (key->keyType) {
     1:       case rsaKey: {
     1:          displayed = true;
     1:          nsAutoString length1, length2, data1, data2;
     1:          length1.AppendInt(key->u.rsa.modulus.len * 8);
     1:          length2.AppendInt(key->u.rsa.publicExponent.len * 8);
     1:          ProcessRawBytes(nssComponent, &key->u.rsa.modulus, data1, 
 80486:                          false);
     1:          ProcessRawBytes(nssComponent, &key->u.rsa.publicExponent, data2,
 80486:                          false);
     1:          const PRUnichar *params[4] = {length1.get(), data1.get(), 
     1:                                        length2.get(), data2.get()};
     1:          nssComponent->PIPBundleFormatStringFromName("CertDumpRSATemplate",
     1:                                                      params, 4, text);
     1:          break;
     1:       }
 16022:       case ecKey: {
 16022:         displayed = true;
 16022:         SECKEYECPublicKey &ecpk = key->u.ec;
 16022:         int fieldSizeLenAsBits = 
 16022:               SECKEY_ECParamsToKeySize(&ecpk.DEREncodedParams);
 16022:         int basePointOrderLenAsBits = 
 16022:               SECKEY_ECParamsToBasePointOrderLen(&ecpk.DEREncodedParams);
 16022:         nsAutoString s_fsl, s_bpol, s_pv;
 16022:         s_fsl.AppendInt(fieldSizeLenAsBits);
 16022:         s_bpol.AppendInt(basePointOrderLenAsBits);
 16022: 
 16022:         if (ecpk.publicValue.len > 4) {
 80486:           ProcessRawBytes(nssComponent, &ecpk.publicValue, s_pv, false);
 16022:         } else {
 16022:           int i_pv = DER_GetInteger(&ecpk.publicValue);
 16022:           s_pv.AppendInt(i_pv);
 16022:         }
 16022:         const PRUnichar *params[] = {s_fsl.get(), s_bpol.get(), s_pv.get()};
 16022:         nssComponent->PIPBundleFormatStringFromName("CertDumpECTemplate",
 16022:                                                     params, 3, text);
 16022:         break;
 16022:       }
     1:       default:
 76375:          /* Algorithm unknown, or too rarely used to bother displaying it */
     1:          break;
     1:       }
     1:       SECKEY_DestroyPublicKey (key);
     1:   }
     1:   if (!displayed) {
     1:       // Algorithm unknown, display raw bytes
     1:       // The subjectPublicKey field is encoded as a bit string.
     1:       // ProcessRawBytes expects the length to be in bytes, so 
     1:       // let's convert the lenght into a temporary SECItem.
     1:       SECItem data;
     1:       data.data = spki->subjectPublicKey.data;
     1:       data.len  = spki->subjectPublicKey.len / 8;
     1:       ProcessRawBytes(nssComponent, &data, text);
     1:   
     1:   }
     1:  
     1:   printableItem->SetDisplayValue(text);
     1:   nssComponent->GetPIPNSSBundleString("CertDumpSubjPubKey", text);
     1:   printableItem->SetDisplayName(text);
 80486:   asn1Objects->AppendElement(printableItem, false);
     1:   
     1:   parentSequence->GetASN1Objects(getter_AddRefs(asn1Objects));
 80486:   asn1Objects->AppendElement(spkiSequence, false);
     1:   return NS_OK;
     1: }
     1: 
     1: static nsresult
     1: ProcessExtensions(CERTCertExtension **extensions, 
     1:                   nsIASN1Sequence *parentSequence,
  7105:                   SECOidTag ev_oid_tag, // SEC_OID_UNKNOWN means: not EV
     1:                   nsINSSComponent *nssComponent)
     1: {
     1:   nsCOMPtr<nsIASN1Sequence> extensionSequence = new nsNSSASN1Sequence;
     1: 
     1:   nsString text;
     1:   nssComponent->GetPIPNSSBundleString("CertDumpExtensions", text);
     1:   extensionSequence->SetDisplayName(text);
108991:   int32_t i;
     1:   nsresult rv;
     1:   nsCOMPtr<nsIASN1PrintableItem> newExtension;
     1:   nsCOMPtr<nsIMutableArray> asn1Objects;
     1:   extensionSequence->GetASN1Objects(getter_AddRefs(asn1Objects));
106838:   for (i=0; extensions[i] != nullptr; i++) {
  7105:     rv = ProcessSingleExtension(extensions[i], 
  7105:                                 ev_oid_tag,
  7105:                                 nssComponent,
     1:                                 getter_AddRefs(newExtension));
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1: 
 80486:     asn1Objects->AppendElement(newExtension, false);
     1:   }
     1:   parentSequence->GetASN1Objects(getter_AddRefs(asn1Objects));
 80486:   asn1Objects->AppendElement(extensionSequence, false);
     1:   return NS_OK;
     1: }
     1: 
     1: static bool registered;
     1: static SECStatus RegisterDynamicOids()
     1: {
     1:   unsigned int i;
     1:   SECStatus rv = SECSuccess;
     1: 
     1:   if (registered)
     1:     return rv;
     1: 
     1:   for (i = 0; i < numOids; i++) {
     1:     SECOidTag tag = SECOID_AddEntry(&more_oids[i]);
     1:     if (tag == SEC_OID_UNKNOWN) {
     1:       rv = SECFailure;
     1:       continue;
     1:     }
     1:     more_oids[i].offset = tag;
     1:   }
     1:   registered = true;
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsNSSCertificate::CreateTBSCertificateASN1Struct(nsIASN1Sequence **retSequence,
     1:                                                  nsINSSComponent *nssComponent)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   if (RegisterDynamicOids() != SECSuccess)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   //
     1:   //   TBSCertificate  ::=  SEQUENCE  {
     1:   //        version         [0]  EXPLICIT Version DEFAULT v1,
     1:   //        serialNumber         CertificateSerialNumber,
     1:   //        signature            AlgorithmIdentifier,
     1:   //        issuer               Name,
     1:   //        validity             Validity,
     1:   //        subject              Name,
     1:   //        subjectPublicKeyInfo SubjectPublicKeyInfo,
     1:   //        issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
     1:   //                             -- If present, version shall be v2 or v3
     1:   //        subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
     1:   //                             -- If present, version shall be v2 or v3
     1:   //        extensions      [3]  EXPLICIT Extensions OPTIONAL
     1:   //                            -- If present, version shall be v3
     1:   //        }
     1:   //
     1:   // This is the ASN1 structure we should be dealing with at this point.
     1:   // The code in this method will assert this is the structure we're dealing
     1:   // and then add more user friendly text for that field.
     1:   nsCOMPtr<nsIASN1Sequence> sequence = new nsNSSASN1Sequence();
     1: 
     1:   nsString text;
     1:   nssComponent->GetPIPNSSBundleString("CertDumpCertificate", text);
     1:   sequence->SetDisplayName(text);
     1:   nsCOMPtr<nsIASN1PrintableItem> printableItem;
     1:   
     1:   nsCOMPtr<nsIMutableArray> asn1Objects;
     1:   sequence->GetASN1Objects(getter_AddRefs(asn1Objects));
     1: 
     1:   nsresult rv = ProcessVersion(&mCert->version, nssComponent,
     1:                                getter_AddRefs(printableItem));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 80486:   asn1Objects->AppendElement(printableItem, false);
     1:   
     1:   rv = ProcessSerialNumberDER(&mCert->serialNumber, nssComponent,
     1:                               getter_AddRefs(printableItem));
     1: 
     1:   if (NS_FAILED(rv))
     1:     return rv;
 80486:   asn1Objects->AppendElement(printableItem, false);
     1: 
     1:   nsCOMPtr<nsIASN1Sequence> algID;
     1:   rv = ProcessSECAlgorithmID(&mCert->signature,
     1:                              nssComponent, getter_AddRefs(algID));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   nssComponent->GetPIPNSSBundleString("CertDumpSigAlg", text);
     1:   algID->SetDisplayName(text);
 80486:   asn1Objects->AppendElement(algID, false);
     1: 
     1:   nsXPIDLString value;
     1:   ProcessName(&mCert->issuer, nssComponent, getter_Copies(value));
     1: 
     1:   printableItem = new nsNSSASN1PrintableItem();
     1: 
     1:   printableItem->SetDisplayValue(value);
     1:   nssComponent->GetPIPNSSBundleString("CertDumpIssuer", text);
     1:   printableItem->SetDisplayName(text);
 80486:   asn1Objects->AppendElement(printableItem, false);
     1:   
     1:   nsCOMPtr<nsIASN1Sequence> validitySequence = new nsNSSASN1Sequence();
     1:   nssComponent->GetPIPNSSBundleString("CertDumpValidity", text);
     1:   validitySequence->SetDisplayName(text);
 80486:   asn1Objects->AppendElement(validitySequence, false);
     1:   nssComponent->GetPIPNSSBundleString("CertDumpNotBefore", text);
     1:   nsCOMPtr<nsIX509CertValidity> validityData;
     1:   GetValidity(getter_AddRefs(validityData));
     1:   PRTime notBefore, notAfter;
     1: 
     1:   validityData->GetNotBefore(&notBefore);
     1:   validityData->GetNotAfter(&notAfter);
     1:   validityData = 0;
     1:   rv = ProcessTime(notBefore, text.get(), validitySequence);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   nssComponent->GetPIPNSSBundleString("CertDumpNotAfter", text);
     1:   rv = ProcessTime(notAfter, text.get(), validitySequence);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   nssComponent->GetPIPNSSBundleString("CertDumpSubject", text);
     1: 
     1:   printableItem = new nsNSSASN1PrintableItem();
     1: 
     1:   printableItem->SetDisplayName(text);
     1:   ProcessName(&mCert->subject, nssComponent,getter_Copies(value));
     1:   printableItem->SetDisplayValue(value);
 80486:   asn1Objects->AppendElement(printableItem, false);
     1: 
     1:   rv = ProcessSubjectPublicKeyInfo(&mCert->subjectPublicKeyInfo, sequence,
     1:                                    nssComponent); 
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1:  
     1:   SECItem data; 
     1:   // Is there an issuerUniqueID?
119899:   if (mCert->issuerID.data) {
     1:     // The issuerID is encoded as a bit string.
     1:     // The function ProcessRawBytes expects the
     1:     // length to be in bytes, so let's convert the
     1:     // length in a temporary SECItem
     1:     data.data = mCert->issuerID.data;
 91856:     data.len  = (mCert->issuerID.len + 7) / 8;
     1: 
     1:     ProcessRawBytes(nssComponent, &data, text);
     1:     printableItem = new nsNSSASN1PrintableItem();
     1: 
     1:     printableItem->SetDisplayValue(text);
     1:     nssComponent->GetPIPNSSBundleString("CertDumpIssuerUniqueID", text);
     1:     printableItem->SetDisplayName(text);
 80486:     asn1Objects->AppendElement(printableItem, false);
     1:   }
     1: 
     1:   if (mCert->subjectID.data) {
     1:     // The subjectID is encoded as a bit string.
     1:     // The function ProcessRawBytes expects the
     1:     // length to be in bytes, so let's convert the
     1:     // length in a temporary SECItem
 91856:     data.data = mCert->subjectID.data;
 91856:     data.len  = (mCert->subjectID.len + 7) / 8;
     1: 
     1:     ProcessRawBytes(nssComponent, &data, text);
     1:     printableItem = new nsNSSASN1PrintableItem();
     1: 
     1:     printableItem->SetDisplayValue(text);
     1:     nssComponent->GetPIPNSSBundleString("CertDumpSubjectUniqueID", text);
     1:     printableItem->SetDisplayName(text);
 80486:     asn1Objects->AppendElement(printableItem, false);
     1: 
     1:   }
     1:   if (mCert->extensions) {
141170:     SECOidTag ev_oid_tag = SEC_OID_UNKNOWN;
141170: 
141170: #ifndef NSS_NO_LIBPKIX
 79445:     bool validEV;
  7105:     rv = hasValidEVOidTag(ev_oid_tag, validEV);
  7105:     if (NS_FAILED(rv))
  7105:       return rv;
  7105: 
  7105:     if (!validEV)
  7105:       ev_oid_tag = SEC_OID_UNKNOWN;
141170: #endif
  7105: 
  7105:     rv = ProcessExtensions(mCert->extensions, sequence, ev_oid_tag, nssComponent);
     1:     if (NS_FAILED(rv))
     1:       return rv;
     1:   }
     1:   *retSequence = sequence;
     1:   NS_ADDREF(*retSequence);  
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsNSSCertificate::CreateASN1Struct()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsCOMPtr<nsIASN1Sequence> sequence = new nsNSSASN1Sequence();
     1: 
     1:   mASN1Structure = sequence; 
     1: 
     1:   nsCOMPtr<nsIMutableArray> asn1Objects;
     1:   sequence->GetASN1Objects(getter_AddRefs(asn1Objects));
     1:   nsXPIDLCString title;
     1:   GetWindowTitle(getter_Copies(title));
     1:   
     1:   mASN1Structure->SetDisplayName(NS_ConvertUTF8toUTF16(title));
     1:   // This sequence will be contain the tbsCertificate, signatureAlgorithm,
     1:   // and signatureValue.
     1:   nsresult rv;
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
     1:   rv = CreateTBSCertificateASN1Struct(getter_AddRefs(sequence),
     1:                                       nssComponent);
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1: 
 80486:   asn1Objects->AppendElement(sequence, false);
     1:   nsCOMPtr<nsIASN1Sequence> algID;
     1: 
     1:   rv = ProcessSECAlgorithmID(&mCert->signatureWrap.signatureAlgorithm, 
     1:                              nssComponent, getter_AddRefs(algID));
     1:   if (NS_FAILED(rv))
     1:     return rv;
     1:   nsString text;
     1:   nssComponent->GetPIPNSSBundleString("CertDumpSigAlg", text);
     1:   algID->SetDisplayName(text);
 80486:   asn1Objects->AppendElement(algID, false);
     1:   nsCOMPtr<nsIASN1PrintableItem>printableItem = new nsNSSASN1PrintableItem();
     1:   nssComponent->GetPIPNSSBundleString("CertDumpCertSig", text);
     1:   printableItem->SetDisplayName(text);
     1:   // The signatureWrap is encoded as a bit string.
     1:   // The function ProcessRawBytes expects the
     1:   // length to be in bytes, so let's convert the
     1:   // length in a temporary SECItem
     1:   SECItem temp;
     1:   temp.data = mCert->signatureWrap.signature.data;
     1:   temp.len  = mCert->signatureWrap.signature.len / 8;
     1:   text.Truncate();
     1:   ProcessRawBytes(nssComponent, &temp,text);
     1:   printableItem->SetDisplayValue(text);
 80486:   asn1Objects->AppendElement(printableItem, false);
     1:   return NS_OK;
     1: }
     1: 
108991: uint32_t 
     1: getCertType(CERTCertificate *cert)
     1: {
     1:   nsNSSCertTrust trust(cert->trust);
     1:   if (cert->nickname && trust.HasAnyUser())
     1:     return nsIX509Cert::USER_CERT;
     1:   if (trust.HasAnyCA())
     1:     return nsIX509Cert::CA_CERT;
 80486:   if (trust.HasPeer(true, false, false))
     1:     return nsIX509Cert::SERVER_CERT;
 80486:   if (trust.HasPeer(false, true, false) && cert->emailAddr)
     1:     return nsIX509Cert::EMAIL_CERT;
119899:   if (CERT_IsCACert(cert, nullptr))
     1:     return nsIX509Cert::CA_CERT;
     1:   if (cert->emailAddr)
     1:     return nsIX509Cert::EMAIL_CERT;
     1:   return nsIX509Cert::UNKNOWN_CERT;
     1: }
     1: 
     1: CERTCertNicknames *
     1: getNSSCertNicknamesFromCertList(CERTCertList *certList)
     1: {
     1:   nsresult rv;
     1: 
     1:   nsCOMPtr<nsINSSComponent> nssComponent(do_GetService(kNSSComponentCID, &rv));
     1:   if (NS_FAILED(rv))
106838:     return nullptr;
     1: 
     1:   nsAutoString expiredString, notYetValidString;
     1:   nsAutoString expiredStringLeadingSpace, notYetValidStringLeadingSpace;
     1: 
     1:   nssComponent->GetPIPNSSBundleString("NicknameExpired", expiredString);
     1:   nssComponent->GetPIPNSSBundleString("NicknameNotYetValid", notYetValidString);
     1: 
     1:   expiredStringLeadingSpace.Append(NS_LITERAL_STRING(" "));
     1:   expiredStringLeadingSpace.Append(expiredString);
     1: 
     1:   notYetValidStringLeadingSpace.Append(NS_LITERAL_STRING(" "));
     1:   notYetValidStringLeadingSpace.Append(notYetValidString);
     1: 
     1:   NS_ConvertUTF16toUTF8 aUtf8ExpiredString(expiredStringLeadingSpace);
     1:   NS_ConvertUTF16toUTF8 aUtf8NotYetValidString(notYetValidStringLeadingSpace);
     1: 
     1:   return CERT_NicknameStringsFromCertList(certList,
  3233:                                           const_cast<char*>(aUtf8ExpiredString.get()),
  3233:                                           const_cast<char*>(aUtf8NotYetValidString.get()));
     1:   
     1: }
