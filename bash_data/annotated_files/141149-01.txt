 75157: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 54814: 
 75156: #include <algorithm>
 75156: 
 54814: #include "LayerManagerD3D10.h"
 54814: #include "LayerManagerD3D10Effect.h"
 54814: #include "gfxWindowsPlatform.h"
 54814: #include "gfxD2DSurface.h"
 62254: #include "gfxFailure.h"
 54814: #include "cairo-win32.h"
 54814: #include "dxgi.h"
 54814: 
 54814: #include "ContainerLayerD3D10.h"
 54814: #include "ThebesLayerD3D10.h"
 54814: #include "ColorLayerD3D10.h"
 54814: #include "CanvasLayerD3D10.h"
 62702: #include "ReadbackLayerD3D10.h"
 54814: #include "ImageLayerD3D10.h"
 75157: #include "mozilla/layers/PLayerChild.h"
106317: #include "mozilla/WidgetUtils.h"
 54814: 
 60419: #include "../d3d9/Nv3DVUtils.h"
 60419: 
 63285: #include "gfxCrashReporterUtils.h"
118928: #ifdef MOZ_METRO
118928: #include "DXGI1_2.h"
134615: #include "nsWindowsHelpers.h"
118928: #endif
 63285: 
 75156: using namespace std;
126621: using namespace mozilla::dom;
 72426: using namespace mozilla::gfx;
 72426: 
 54814: namespace mozilla {
 54814: namespace layers {
 54814: 
 54814: typedef HRESULT (WINAPI*D3D10CreateEffectFromMemoryFunc)(
 54814:     void *pData,
 54814:     SIZE_T DataLength,
 54814:     UINT FXFlags,
 54814:     ID3D10Device *pDevice, 
 54814:     ID3D10EffectPool *pEffectPool,
 54814:     ID3D10Effect **ppEffect
 54814: );
 54814: 
 54814: struct Vertex
 54814: {
 54814:     float position[2];
 54814: };
 54814: 
 62702: // {592BF306-0EED-4F76-9D03-A0846450F472}
 62702: static const GUID sDeviceAttachments = 
 62702: { 0x592bf306, 0xeed, 0x4f76, { 0x9d, 0x3, 0xa0, 0x84, 0x64, 0x50, 0xf4, 0x72 } };
 62702: // {716AEDB1-C9C3-4B4D-8332-6F65D44AF6A8}
 62702: static const GUID sLayerManagerCount = 
 62702: { 0x716aedb1, 0xc9c3, 0x4b4d, { 0x83, 0x32, 0x6f, 0x65, 0xd4, 0x4a, 0xf6, 0xa8 } };
 54814: 
 54814: cairo_user_data_key_t gKeyD3D10Texture;
 54814: 
 54814: LayerManagerD3D10::LayerManagerD3D10(nsIWidget *aWidget)
 54814:   : mWidget(aWidget)
 54814: {
 54814: }
 54814: 
 62702: struct DeviceAttachments
 62702: {
 62702:   nsRefPtr<ID3D10Effect> mEffect;
 62702:   nsRefPtr<ID3D10InputLayout> mInputLayout;
 62702:   nsRefPtr<ID3D10Buffer> mVertexBuffer;
 62702:   nsRefPtr<ReadbackManagerD3D10> mReadbackManager;
 62702: };
 62702: 
 54814: LayerManagerD3D10::~LayerManagerD3D10()
 54814: {
 62702:   if (mDevice) {
 62702:     int referenceCount = 0;
 62702:     UINT size = sizeof(referenceCount);
 62702:     HRESULT hr = mDevice->GetPrivateData(sLayerManagerCount, &size, &referenceCount);
 62702:     NS_ASSERTION(SUCCEEDED(hr), "Reference count not found on device.");
 62702:     referenceCount--;
 62702:     mDevice->SetPrivateData(sLayerManagerCount, sizeof(referenceCount), &referenceCount);
 62702: 
 62702:     if (!referenceCount) {
 62702:       DeviceAttachments *attachments;
 62702:       size = sizeof(attachments);
 62702:       mDevice->GetPrivateData(sDeviceAttachments, &size, &attachments);
 62702:       // No LayerManagers left for this device. Clear out interfaces stored which
 62702:       // hold a reference to the device.
 62702:       mDevice->SetPrivateData(sDeviceAttachments, 0, NULL);
 62702: 
 62702:       delete attachments;
 62702:     }
 62702:   }
 62702: 
 56116:   Destroy();
 54814: }
 54814: 
140122: _inline void
140122: SetHRESULT(HRESULT* aHresultPtr, HRESULT aHresult)
140122: {
140122:   if (aHresultPtr) {
140122:     *aHresultPtr = aHresult;
140122:   }
140122: }
140122:  
 54814: bool
140122: LayerManagerD3D10::Initialize(bool force, HRESULT* aHresultPtr)
 54814: {
 91135:   ScopedGfxFeatureReporter reporter("D3D10 Layers", force);
 63285: 
140122:   HRESULT hr = E_UNEXPECTED;
 54814: 
 60419:   /* Create an Nv3DVUtils instance */
 60419:   if (!mNv3DVUtils) {
 60419:     mNv3DVUtils = new Nv3DVUtils();
 60419:     if (!mNv3DVUtils) {
 60419:       NS_WARNING("Could not create a new instance of Nv3DVUtils.\n");
 60419:     }
 60419:   }
 60419: 
 60419:   /* Initialize the Nv3DVUtils object */
 60419:   if (mNv3DVUtils) {
 60419:     mNv3DVUtils->Initialize();
 60419:   }
 60419: 
 60089:   mDevice = gfxWindowsPlatform::GetPlatform()->GetD3D10Device();
 60089:   if (!mDevice) {
140122:       SetHRESULT(aHresultPtr, hr);
 54814:       return false;
 54814:   }
 54814: 
 60419:   /*
 60419:    * Do some post device creation setup
 60419:    */
 60419:   if (mNv3DVUtils) {
 60419:     IUnknown* devUnknown = NULL;
 60419:     if (mDevice) {
 60419:       mDevice->QueryInterface(IID_IUnknown, (void **)&devUnknown);
 60419:     }
 60419:     mNv3DVUtils->SetDeviceInfo(devUnknown);
 60419:   }
 60419: 
 62702:   int referenceCount = 0;
 62702:   UINT size = sizeof(referenceCount);
 62702:   // If this isn't there yet it'll fail, count will remain 0, which is correct.
 62702:   mDevice->GetPrivateData(sLayerManagerCount, &size, &referenceCount);
 62702:   referenceCount++;
 62702:   mDevice->SetPrivateData(sLayerManagerCount, sizeof(referenceCount), &referenceCount);
 62702: 
 62702:   DeviceAttachments *attachments;
 62702:   size = sizeof(DeviceAttachments*);
 62702:   if (FAILED(mDevice->GetPrivateData(sDeviceAttachments, &size, &attachments))) {
 62702:     attachments = new DeviceAttachments;
 62702:     mDevice->SetPrivateData(sDeviceAttachments, sizeof(attachments), &attachments);
 62702: 
140122:     SetLastError(0);
 54814:     D3D10CreateEffectFromMemoryFunc createEffect = (D3D10CreateEffectFromMemoryFunc)
 54814:       GetProcAddress(LoadLibraryA("d3d10_1.dll"), "D3D10CreateEffectFromMemory");
 54814:     if (!createEffect) {
140122:       SetHRESULT(aHresultPtr, HRESULT_FROM_WIN32(GetLastError()));
 54814:       return false;
 54814:     }
 54814: 
 54814:     hr = createEffect((void*)g_main,
 54814:                       sizeof(g_main),
 54814:                       D3D10_EFFECT_SINGLE_THREADED,
 54814:                       mDevice,
 54814:                       NULL,
 54814:                       getter_AddRefs(mEffect));
 54814:     
 54814:     if (FAILED(hr)) {
140122:       SetHRESULT(aHresultPtr, hr);
 54814:       return false;
 54814:     }
 54814: 
 62702:     attachments->mEffect = mEffect;
 54814:   
 54814:     D3D10_INPUT_ELEMENT_DESC layout[] =
 54814:     {
 54814:       { "POSITION", 0, DXGI_FORMAT_R32G32_FLOAT, 0, 0, D3D10_INPUT_PER_VERTEX_DATA, 0 },
 54814:     };
 54814:     D3D10_PASS_DESC passDesc;
 54814:     mEffect->GetTechniqueByName("RenderRGBLayerPremul")->GetPassByIndex(0)->
 54814:       GetDesc(&passDesc);
 54814: 
 54814:     hr = mDevice->CreateInputLayout(layout,
 54814:                                     sizeof(layout) / sizeof(D3D10_INPUT_ELEMENT_DESC),
 54814:                                     passDesc.pIAInputSignature,
 54814:                                     passDesc.IAInputSignatureSize,
 54814:                                     getter_AddRefs(mInputLayout));
 54814:     
 54814:     if (FAILED(hr)) {
140122:       SetHRESULT(aHresultPtr, hr);
 54814:       return false;
 54814:     }
 54814: 
 62702:     attachments->mInputLayout = mInputLayout;
 54814:   
 54814:     Vertex vertices[] = { {0.0, 0.0}, {1.0, 0.0}, {0.0, 1.0}, {1.0, 1.0} };
 54814:     CD3D10_BUFFER_DESC bufferDesc(sizeof(vertices), D3D10_BIND_VERTEX_BUFFER);
 54814:     D3D10_SUBRESOURCE_DATA data;
 54814:     data.pSysMem = (void*)vertices;
 54814: 
 54814:     hr = mDevice->CreateBuffer(&bufferDesc, &data, getter_AddRefs(mVertexBuffer));
 54814: 
 54814:     if (FAILED(hr)) {
140122:       SetHRESULT(aHresultPtr, hr);
 54814:       return false;
 54814:     }
 54814: 
 62702:     attachments->mVertexBuffer = mVertexBuffer;
 62702:   } else {
 62702:     mEffect = attachments->mEffect;
 62702:     mVertexBuffer = attachments->mVertexBuffer;
 62702:     mInputLayout = attachments->mInputLayout;
 54814:   }
 54814: 
 54814:   nsRefPtr<IDXGIDevice> dxgiDevice;
 54814:   nsRefPtr<IDXGIAdapter> dxgiAdapter;
 54814: 
 54814:   mDevice->QueryInterface(dxgiDevice.StartAssignment());
 54814:   dxgiDevice->GetAdapter(getter_AddRefs(dxgiAdapter));
 54814:   
105916: #ifdef MOZ_METRO
134615:   if (IsRunningInWindowsMetro()) {
105916:     nsRefPtr<IDXGIFactory2> dxgiFactory;
105916:     dxgiAdapter->GetParent(IID_PPV_ARGS(dxgiFactory.StartAssignment()));
105916: 
105916:     nsIntRect rect;
105916:     mWidget->GetClientBounds(rect);
105916: 
105916:     DXGI_SWAP_CHAIN_DESC1 swapDesc = { 0 };
105916:     // Automatically detect the width and the height from the winrt CoreWindow
105916:     swapDesc.Width = rect.width;
105916:     swapDesc.Height = rect.height;
105916:     // This is the most common swapchain format
105916:     swapDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
105916:     swapDesc.Stereo = false; 
105916:     // Don't use multi-sampling
105916:     swapDesc.SampleDesc.Count = 1;
105916:     swapDesc.SampleDesc.Quality = 0;
105916:     swapDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
105916:     // Use double buffering to enable flip
105916:     swapDesc.BufferCount = 2;
105916:     swapDesc.Scaling = DXGI_SCALING_STRETCH;
105916:     // All Metro style apps must use this SwapEffect
105916:     swapDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL;
105916:     swapDesc.Flags = 0;
105916: 
105916:     /**
105916:      * Create a swap chain, this swap chain will contain the backbuffer for
105916:      * the window we draw to. The front buffer is the full screen front
105916:      * buffer.
105916:     */
105916:     nsRefPtr<IDXGISwapChain1> swapChain1;
105916:     hr = dxgiFactory->CreateSwapChainForCoreWindow(
111471:            dxgiDevice, (IUnknown *)mWidget->GetNativeData(NS_NATIVE_ICOREWINDOW),
105916:            &swapDesc, nullptr, getter_AddRefs(swapChain1));
105916:     if (FAILED(hr)) {
140122:       SetHRESULT(aHresultPtr, hr);
105916:       return false;
105916:     }
105916:     mSwapChain = swapChain1;
105916:   } else
105916: #endif
105916:   {
105916:     nsRefPtr<IDXGIFactory> dxgiFactory;
 54814:     dxgiAdapter->GetParent(IID_PPV_ARGS(dxgiFactory.StartAssignment()));
 54814: 
 54814:     DXGI_SWAP_CHAIN_DESC swapDesc;
 54814:     ::ZeroMemory(&swapDesc, sizeof(swapDesc));
 54814:     swapDesc.BufferDesc.Width = 0;
 54814:     swapDesc.BufferDesc.Height = 0;
 54814:     swapDesc.BufferDesc.Format = DXGI_FORMAT_B8G8R8A8_UNORM;
 54814:     swapDesc.BufferDesc.RefreshRate.Numerator = 60;
 54814:     swapDesc.BufferDesc.RefreshRate.Denominator = 1;
 54814:     swapDesc.SampleDesc.Count = 1;
 54814:     swapDesc.SampleDesc.Quality = 0;
 54814:     swapDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
 54814:     swapDesc.BufferCount = 1;
105916:     swapDesc.OutputWindow = (HWND)mWidget->GetNativeData(NS_NATIVE_WINDOW);
105916:     swapDesc.Windowed = TRUE;
 59294:     // We don't really need this flag, however it seems on some NVidia hardware
 59396:     // smaller area windows do not present properly without this flag. This flag
 60236:     // should have no negative consequences by itself. See bug 613790. This flag
 60236:     // is broken on optimus devices. As a temporary solution we don't set it
 60236:     // there, the only way of reliably detecting we're on optimus is looking for
 60236:     // the DLL. See Bug 623807.
 63228:     if (gfxWindowsPlatform::IsOptimus()) {
 60236:       swapDesc.Flags = 0;
 60236:     } else {
 59294:       swapDesc.Flags = DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE;
 60236:     }
 54814: 
 54814:     /**
 54814:      * Create a swap chain, this swap chain will contain the backbuffer for
 54814:      * the window we draw to. The front buffer is the full screen front
 54814:      * buffer.
 54814:     */
 54814:     hr = dxgiFactory->CreateSwapChain(dxgiDevice, &swapDesc, getter_AddRefs(mSwapChain));
 54814:     if (FAILED(hr)) {
 54814:      return false;
 54814:     }
 54814: 
 55201:     // We need this because we don't want DXGI to respond to Alt+Enter.
 55201:     dxgiFactory->MakeWindowAssociation(swapDesc.OutputWindow, DXGI_MWA_NO_WINDOW_CHANGES);
105916:   }
 55201: 
 63285:   reporter.SetSuccessful();
 54814:   return true;
 54814: }
 54814: 
 54814: void
 56116: LayerManagerD3D10::Destroy()
 56116: {
 56116:   if (!IsDestroyed()) {
 56116:     if (mRoot) {
 56116:       static_cast<LayerD3D10*>(mRoot->ImplData())->LayerManagerDestroyed();
 56116:     }
 75158:     // XXX need to be careful here about surface destruction
 75158:     // racing with share-to-chrome message
 56116:   }
 56116:   LayerManager::Destroy();
 56116: }
 56116: 
 56116: void
 54814: LayerManagerD3D10::SetRoot(Layer *aRoot)
 54814: {
 54814:   mRoot = aRoot;
 54814: }
 54814: 
 54814: void
 54814: LayerManagerD3D10::BeginTransaction()
 54814: {
108476:   mInTransaction = true;
108476: 
 75150: #ifdef MOZ_LAYERS_HAVE_LOG
 75150:   MOZ_LAYERS_LOG(("[----- BeginTransaction"));
 75150:   Log();
 75150: #endif
 54814: }
 54814: 
 54814: void
 54814: LayerManagerD3D10::BeginTransactionWithTarget(gfxContext* aTarget)
 54814: {
108476:   mInTransaction = true;
 54814:   mTarget = aTarget;
 54814: }
 54814: 
 60859: bool
108188: LayerManagerD3D10::EndEmptyTransaction(EndTransactionFlags aFlags)
 60859: {
108476:   mInTransaction = false;
108476: 
 60859:   if (!mRoot)
 60859:     return false;
 60859: 
108188:   EndTransaction(nullptr, nullptr, aFlags);
 60859:   return true;
 60859: }
 60859: 
 59171: void
 54814: LayerManagerD3D10::EndTransaction(DrawThebesLayerCallback aCallback,
 78887:                                   void* aCallbackData,
 78887:                                   EndTransactionFlags aFlags)
 54814: {
108476:   mInTransaction = false;
108476: 
 78887:   if (mRoot && !(aFlags & END_NO_IMMEDIATE_REDRAW)) {
 54814:     mCurrentCallbackInfo.Callback = aCallback;
 54814:     mCurrentCallbackInfo.CallbackData = aCallbackData;
 57097: 
116071:     if (aFlags & END_NO_COMPOSITE) {
116071:       // Apply pending tree updates before recomputing effective
116071:       // properties.
116071:       mRoot->ApplyPendingUpdatesToSubtree();
116071:     }
116071: 
 57097:     // The results of our drawing always go directly into a pixel buffer,
 57097:     // so we don't need to pass any global transform here.
 57097:     mRoot->ComputeEffectiveTransforms(gfx3DMatrix());
 57097: 
 75150: #ifdef MOZ_LAYERS_HAVE_LOG
 75150:     MOZ_LAYERS_LOG(("  ----- (beginning paint)"));
 75150:     Log();
 75150: #endif
 75150: 
108187:     Render(aFlags);
106838:     mCurrentCallbackInfo.Callback = nullptr;
106838:     mCurrentCallbackInfo.CallbackData = nullptr;
 62292:   }
 62292: 
 75150: #ifdef MOZ_LAYERS_HAVE_LOG
 75150:   Log();
 75150:   MOZ_LAYERS_LOG(("]----- EndTransaction"));
 75150: #endif
 75150: 
106838:   mTarget = nullptr;
 54814: }
 54814: 
 54814: already_AddRefed<ThebesLayer>
 54814: LayerManagerD3D10::CreateThebesLayer()
 54814: {
 54814:   nsRefPtr<ThebesLayer> layer = new ThebesLayerD3D10(this);
 54814:   return layer.forget();
 54814: }
 54814: 
 54814: already_AddRefed<ContainerLayer>
 54814: LayerManagerD3D10::CreateContainerLayer()
 54814: {
 54814:   nsRefPtr<ContainerLayer> layer = new ContainerLayerD3D10(this);
 54814:   return layer.forget();
 54814: }
 54814: 
 54814: already_AddRefed<ImageLayer>
 54814: LayerManagerD3D10::CreateImageLayer()
 54814: {
 54814:   nsRefPtr<ImageLayer> layer = new ImageLayerD3D10(this);
 54814:   return layer.forget();
 54814: }
 54814: 
 54814: already_AddRefed<ColorLayer>
 54814: LayerManagerD3D10::CreateColorLayer()
 54814: {
 54814:   nsRefPtr<ColorLayer> layer = new ColorLayerD3D10(this);
 54814:   return layer.forget();
 54814: }
 54814: 
 54814: already_AddRefed<CanvasLayer>
 54814: LayerManagerD3D10::CreateCanvasLayer()
 54814: {
 54814:   nsRefPtr<CanvasLayer> layer = new CanvasLayerD3D10(this);
 54814:   return layer.forget();
 54814: }
 54814: 
 62702: already_AddRefed<ReadbackLayer>
 62702: LayerManagerD3D10::CreateReadbackLayer()
 62702: {
 62702:   nsRefPtr<ReadbackLayer> layer = new ReadbackLayerD3D10(this);
 62702:   return layer.forget();
 62702: }
 62702: 
 54814: static void ReleaseTexture(void *texture)
 54814: {
 54814:   static_cast<ID3D10Texture2D*>(texture)->Release();
 54814: }
 54814: 
 54814: already_AddRefed<gfxASurface>
 54814: LayerManagerD3D10::CreateOptimalSurface(const gfxIntSize &aSize,
 54814:                                    gfxASurface::gfxImageFormat aFormat)
 54814: {
 54814:   if ((aFormat != gfxASurface::ImageFormatRGB24 &&
 54814:        aFormat != gfxASurface::ImageFormatARGB32)) {
 54814:     return LayerManager::CreateOptimalSurface(aSize, aFormat);
 54814:   }
 54814: 
 54814:   nsRefPtr<ID3D10Texture2D> texture;
 54814:   
 54814:   CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM, aSize.width, aSize.height, 1, 1);
 54814:   desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
 54814:   
 54814:   HRESULT hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(texture));
 54814: 
 54814:   if (FAILED(hr)) {
 54814:     NS_WARNING("Failed to create new texture for CreateOptimalSurface!");
 54814:     return LayerManager::CreateOptimalSurface(aSize, aFormat);
 54814:   }
 54814: 
 54814:   nsRefPtr<gfxD2DSurface> surface =
 54814:     new gfxD2DSurface(texture, aFormat == gfxASurface::ImageFormatRGB24 ?
 54814:       gfxASurface::CONTENT_COLOR : gfxASurface::CONTENT_COLOR_ALPHA);
 54814: 
 54814:   if (!surface || surface->CairoStatus()) {
 54814:     return LayerManager::CreateOptimalSurface(aSize, aFormat);
 54814:   }
 54814: 
 54814:   surface->SetData(&gKeyD3D10Texture,
 54814:                    texture.forget().get(),
 54814:                    ReleaseTexture);
 54814: 
 54814:   return surface.forget();
 54814: }
 54814: 
102921: 
102921: already_AddRefed<gfxASurface>
102921: LayerManagerD3D10::CreateOptimalMaskSurface(const gfxIntSize &aSize)
102921: {
102921:   return CreateOptimalSurface(aSize, gfxASurface::ImageFormatARGB32);
102921: }
102921: 
102921: 
 72426: TemporaryRef<DrawTarget>
 72426: LayerManagerD3D10::CreateDrawTarget(const IntSize &aSize,
 72426:                                     SurfaceFormat aFormat)
 72426: {
 72426:   if ((aFormat != FORMAT_B8G8R8A8 &&
106616:        aFormat != FORMAT_B8G8R8X8) ||
107129:        gfxPlatform::GetPlatform()->GetPreferredCanvasBackend() != BACKEND_DIRECT2D) {
 72426:     return LayerManager::CreateDrawTarget(aSize, aFormat);
 72426:   }
 72426: 
 72426:   nsRefPtr<ID3D10Texture2D> texture;
 72426:   
 72426:   CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM, aSize.width, aSize.height, 1, 1);
 72426:   desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
 72426:   
 72426:   HRESULT hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(texture));
 72426: 
 72426:   if (FAILED(hr)) {
 72426:     NS_WARNING("Failed to create new texture for CreateOptimalSurface!");
 72426:     return LayerManager::CreateDrawTarget(aSize, aFormat);
 72426:   }
 72426: 
 72426:   RefPtr<DrawTarget> surface =
 72426:     Factory::CreateDrawTargetForD3D10Texture(texture, aFormat);
 72426: 
 72426:   if (!surface) {
 72426:     return LayerManager::CreateDrawTarget(aSize, aFormat);
 72426:   }
 72426:   
 72426:   return surface;
 72426: }
 72426: 
 62702: ReadbackManagerD3D10*
 62702: LayerManagerD3D10::readbackManager()
 62702: {
 62702:   EnsureReadbackManager();
 62702:   return mReadbackManager;
 62702: }
 62702: 
 54814: void
 54814: LayerManagerD3D10::SetViewport(const nsIntSize &aViewport)
 54814: {
 54814:   mViewport = aViewport;
 54814: 
 54814:   D3D10_VIEWPORT viewport;
 54814:   viewport.MaxDepth = 1.0f;
 54814:   viewport.MinDepth = 0;
 54814:   viewport.Width = aViewport.width;
 54814:   viewport.Height = aViewport.height;
 54814:   viewport.TopLeftX = 0;
 54814:   viewport.TopLeftY = 0;
 54814: 
 54814:   mDevice->RSSetViewports(1, &viewport);
 54814: 
 54814:   gfx3DMatrix projection;
 54814:   /*
 54814:    * Matrix to transform to viewport space ( <-1.0, 1.0> topleft,
 54814:    * <1.0, -1.0> bottomright)
 54814:    */
 54814:   projection._11 = 2.0f / aViewport.width;
 54814:   projection._22 = -2.0f / aViewport.height;
 74750:   projection._33 = 0.0f;
 54814:   projection._41 = -1.0f;
 54814:   projection._42 = 1.0f;
 54814:   projection._44 = 1.0f;
 54814: 
 54814:   HRESULT hr = mEffect->GetVariableByName("mProjection")->
 54814:     SetRawValue(&projection._11, 0, 64);
 54814: 
 54814:   if (FAILED(hr)) {
 54814:     NS_WARNING("Failed to set projection matrix.");
 54814:   }
 54814: }
 54814: 
 54814: void
 95178: LayerManagerD3D10::SetupInputAssembler()
 95178: {
 95178:   mDevice->IASetInputLayout(mInputLayout);
 95178: 
 95178:   UINT stride = sizeof(Vertex);
 95178:   UINT offset = 0;
 95178:   ID3D10Buffer *buffer = mVertexBuffer;
 95178:   mDevice->IASetVertexBuffers(0, 1, &buffer, &stride, &offset);
 95178:   mDevice->IASetPrimitiveTopology(D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
 95178: }
 95178: 
 95178: void
 54814: LayerManagerD3D10::SetupPipeline()
 54814: {
 54814:   VerifyBufferSize();
 54814:   UpdateRenderTarget();
 54814: 
 54814:   nsIntRect rect;
 54814:   mWidget->GetClientBounds(rect);
 54814: 
 54814:   HRESULT hr;
 54814: 
 54814:   hr = mEffect->GetVariableByName("vTextureCoords")->AsVector()->
 54814:     SetFloatVector(ShaderConstantRectD3D10(0, 0, 1.0f, 1.0f));
 54814: 
 54814:   if (FAILED(hr)) {
 54814:     NS_WARNING("Failed to set Texture Coordinates.");
 54814:     return;
 54814:   }
 54814: 
 54814:   ID3D10RenderTargetView *view = mRTView;
 54814:   mDevice->OMSetRenderTargets(1, &view, NULL);
 54814: 
 95178:   SetupInputAssembler();
 54814: 
 54814:   SetViewport(nsIntSize(rect.width, rect.height));
 54814: }
 54814: 
 54814: void
 54814: LayerManagerD3D10::UpdateRenderTarget()
 54814: {
140055:   if (mRTView || !mSwapChain) {
 54814:     return;
 54814:   }
 54814: 
 54814:   HRESULT hr;
 54814: 
 54814:   nsRefPtr<ID3D10Texture2D> backBuf;
 54814:   hr = mSwapChain->GetBuffer(0, __uuidof(ID3D10Texture2D), (void**)backBuf.StartAssignment());
 54814:   if (FAILED(hr)) {
 54814:     return;
 54814:   }
 54814:   mDevice->CreateRenderTargetView(backBuf, NULL, getter_AddRefs(mRTView));
 54814: }
 54814: 
 54814: void
 54814: LayerManagerD3D10::VerifyBufferSize()
 54814: {
 75156:   nsIntRect rect;
 75156:   mWidget->GetClientBounds(rect);
 75156: 
 75156:   if (mSwapChain) {
 73920:     DXGI_SWAP_CHAIN_DESC swapDesc;
 73920:     mSwapChain->GetDesc(&swapDesc);
 73920: 
 54814:     if (swapDesc.BufferDesc.Width == rect.width &&
 54814:         swapDesc.BufferDesc.Height == rect.height) {
 54814:       return;
 54814:     }
 54814: 
106838:     mRTView = nullptr;
106572:     if (gfxWindowsPlatform::IsOptimus()) { 
 60236:       mSwapChain->ResizeBuffers(1, rect.width, rect.height,
 60236:                                 DXGI_FORMAT_B8G8R8A8_UNORM,
 60236:                                 0);
134615: #ifdef MOZ_METRO
134615:     } else if (IsRunningInWindowsMetro()) {
106572:       mSwapChain->ResizeBuffers(2, rect.width, rect.height,
106572:                                 DXGI_FORMAT_B8G8R8A8_UNORM,
106572:                                 0);
134615: #endif
 60236:     } else {
 54814:       mSwapChain->ResizeBuffers(1, rect.width, rect.height,
 59294:                                 DXGI_FORMAT_B8G8R8A8_UNORM,
 59294:                                 DXGI_SWAP_CHAIN_FLAG_GDI_COMPATIBLE);
 60236:     }
 75156:   }
 54814: }
 54814: 
 54814: void
 62702: LayerManagerD3D10::EnsureReadbackManager()
 62702: {
 62702:   if (mReadbackManager) {
 62702:     return;
 62702:   }
 62702: 
 62702:   DeviceAttachments *attachments;
 62702:   UINT size = sizeof(DeviceAttachments*);
 62702:   if (FAILED(mDevice->GetPrivateData(sDeviceAttachments, &size, &attachments))) {
 62702:     // Strange! This shouldn't happen ... return a readback manager for this
 62702:     // layer manager only.
 62702:     mReadbackManager = new ReadbackManagerD3D10();
 62702:     gfx::LogFailure(NS_LITERAL_CSTRING("Couldn't get device attachments for device."));
 62702:     return;
 62702:   }
 62702: 
 62702:   if (attachments->mReadbackManager) {
 62702:     mReadbackManager = attachments->mReadbackManager;
 62702:     return;
 62702:   }
 62702: 
 62702:   mReadbackManager = new ReadbackManagerD3D10();
 62702:   attachments->mReadbackManager = mReadbackManager;
 62702: }
 62702: 
 62702: void
108187: LayerManagerD3D10::Render(EndTransactionFlags aFlags)
 54814: {
 54814:   static_cast<LayerD3D10*>(mRoot->ImplData())->Validate();
 54814: 
108187:   if (aFlags & END_NO_COMPOSITE) {
108187:     return;
108187:   }
108187: 
 54814:   SetupPipeline();
 54814: 
 54814:   float black[] = { 0, 0, 0, 0 };
 54814:   device()->ClearRenderTargetView(mRTView, black);
 54814: 
 54814:   nsIntRect rect;
 54814:   mWidget->GetClientBounds(rect);
 54814: 
 54814:   const nsIntRect *clipRect = mRoot->GetClipRect();
 54814:   D3D10_RECT r;
 54814:   if (clipRect) {
 54814:     r.left = (LONG)clipRect->x;
 54814:     r.top = (LONG)clipRect->y;
 54814:     r.right = (LONG)(clipRect->x + clipRect->width);
 54814:     r.bottom = (LONG)(clipRect->y + clipRect->height);
 54814:   } else {
 54814:     r.left = r.top = 0;
 54814:     r.right = rect.width;
 54814:     r.bottom = rect.height;
 54814:   }
 54814:   device()->RSSetScissorRects(1, &r);
 54814: 
 57097:   static_cast<LayerD3D10*>(mRoot->ImplData())->RenderLayer();
 54814: 
140043:   // See bug 630197 - we have some reasons to believe if an earlier call
140043:   // returned an error, the upcoming present call may raise an exception.
140043:   // This will check if any of the calls done recently has returned an error
140043:   // and bails on composition. On the -next- frame we will then abandon
140043:   // hardware acceleration from gfxWindowsPlatform::VerifyD2DDevice.
140043:   // This might not be the 'optimal' solution but it will help us assert
140043:   // whether our thoughts of the causes of the issues are correct.
140043:   if (FAILED(mDevice->GetDeviceRemovedReason())) {
140043:     return;
140043:   }
140043: 
 54814:   if (mTarget) {
 54814:     PaintToTarget();
 54814:   } else {
 54814:     mSwapChain->Present(0, 0);
 54814:   }
 86724:   LayerManager::PostPresent();
 54814: }
 54814: 
 54814: void
 54814: LayerManagerD3D10::PaintToTarget()
 54814: {
 54814:   nsRefPtr<ID3D10Texture2D> backBuf;
 54814:   
 54814:   mSwapChain->GetBuffer(0, __uuidof(ID3D10Texture2D), (void**)backBuf.StartAssignment());
 54814: 
 54814:   D3D10_TEXTURE2D_DESC bbDesc;
 54814:   backBuf->GetDesc(&bbDesc);
 54814: 
 54814:   CD3D10_TEXTURE2D_DESC softDesc(bbDesc.Format, bbDesc.Width, bbDesc.Height);
 54814:   softDesc.MipLevels = 1;
 54814:   softDesc.CPUAccessFlags = D3D10_CPU_ACCESS_READ;
 54814:   softDesc.Usage = D3D10_USAGE_STAGING;
 54814:   softDesc.BindFlags = 0;
 54814: 
 54814:   nsRefPtr<ID3D10Texture2D> readTexture;
 54814: 
 81355:   HRESULT hr = device()->CreateTexture2D(&softDesc, NULL, getter_AddRefs(readTexture));
 81355:   if (FAILED(hr)) {
 81355:     ReportFailure(NS_LITERAL_CSTRING("LayerManagerD3D10::PaintToTarget(): Failed to create texture"),
 81355:                   hr);
 81355:     return;
 81355:   }
 54814: 
 54814:   device()->CopyResource(readTexture, backBuf);
 54814: 
 54814:   D3D10_MAPPED_TEXTURE2D map;
 54814:   readTexture->Map(0, D3D10_MAP_READ, 0, &map);
 54814: 
 54814:   nsRefPtr<gfxImageSurface> tmpSurface =
 54814:     new gfxImageSurface((unsigned char*)map.pData,
 54814:                         gfxIntSize(bbDesc.Width, bbDesc.Height),
 54814:                         map.RowPitch,
 54814:                         gfxASurface::ImageFormatARGB32);
 54814: 
 54814:   mTarget->SetSource(tmpSurface);
 56115:   mTarget->SetOperator(gfxContext::OPERATOR_OVER);
 54814:   mTarget->Paint();
 56115: 
 56115:   readTexture->Unmap(0);
 54814: }
 54814: 
 60333: void
 60333: LayerManagerD3D10::ReportFailure(const nsACString &aMsg, HRESULT aCode)
 60333: {
 60333:   // We could choose to abort here when hr == E_OUTOFMEMORY.
 60333:   nsCString msg;
 60333:   msg.Append(aMsg);
 60333:   msg.AppendLiteral(" Error code: ");
108991:   msg.AppendInt(uint32_t(aCode));
 60333:   NS_WARNING(msg.BeginReading());
 62254: 
 62254:   gfx::LogFailure(msg);
 60333: }
 60333: 
 54814: LayerD3D10::LayerD3D10(LayerManagerD3D10 *aManager)
 54814:   : mD3DManager(aManager)
 54814: {
 54814: }
 54814: 
 97438: ID3D10EffectTechnique*
108991: LayerD3D10::SelectShader(uint8_t aFlags)
 97438: {
 97438:   switch (aFlags) {
 97438:   case (SHADER_RGBA | SHADER_NON_PREMUL | SHADER_LINEAR | SHADER_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBALayerNonPremulMask");
 97438:   case (SHADER_RGBA | SHADER_NON_PREMUL | SHADER_LINEAR | SHADER_NO_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBALayerNonPremul");
 97438:   case (SHADER_RGBA | SHADER_NON_PREMUL | SHADER_POINT | SHADER_NO_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBALayerNonPremulPoint");
 97438:   case (SHADER_RGBA | SHADER_NON_PREMUL | SHADER_POINT | SHADER_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBALayerNonPremulPointMask");
 97438:   case (SHADER_RGBA | SHADER_PREMUL | SHADER_LINEAR | SHADER_MASK_3D):
 97438:     return effect()->GetTechniqueByName("RenderRGBALayerPremulMask3D");
 97438:   case (SHADER_RGBA | SHADER_PREMUL | SHADER_LINEAR | SHADER_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBALayerPremulMask");
 97438:   case (SHADER_RGBA | SHADER_PREMUL | SHADER_LINEAR | SHADER_NO_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBALayerPremul");
 97438:   case (SHADER_RGBA | SHADER_PREMUL | SHADER_POINT | SHADER_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBALayerPremulPointMask");
 97438:   case (SHADER_RGBA | SHADER_PREMUL | SHADER_POINT | SHADER_NO_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBALayerPremulPoint");
 97438:   case (SHADER_RGB | SHADER_PREMUL | SHADER_POINT | SHADER_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBLayerPremulPointMask");
 97438:   case (SHADER_RGB | SHADER_PREMUL | SHADER_POINT | SHADER_NO_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBLayerPremulPoint");
 97438:   case (SHADER_RGB | SHADER_PREMUL | SHADER_LINEAR | SHADER_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBLayerPremulMask");
 97438:   case (SHADER_RGB | SHADER_PREMUL | SHADER_LINEAR | SHADER_NO_MASK):
 97438:     return effect()->GetTechniqueByName("RenderRGBLayerPremul");
 97438:   case (SHADER_SOLID | SHADER_MASK):
 97438:     return effect()->GetTechniqueByName("RenderSolidColorLayerMask");
 97438:   case (SHADER_SOLID | SHADER_NO_MASK):
 97438:     return effect()->GetTechniqueByName("RenderSolidColorLayer");
 97438:   case (SHADER_COMPONENT_ALPHA | SHADER_MASK):
 97438:     return effect()->GetTechniqueByName("RenderComponentAlphaLayerMask");
 97438:   case (SHADER_COMPONENT_ALPHA | SHADER_NO_MASK):
 97438:     return effect()->GetTechniqueByName("RenderComponentAlphaLayer");
 97438:   case (SHADER_YCBCR | SHADER_MASK):
 97438:     return effect()->GetTechniqueByName("RenderYCbCrLayerMask");
 97438:   case (SHADER_YCBCR | SHADER_NO_MASK):
 97438:     return effect()->GetTechniqueByName("RenderYCbCrLayer");
 97438:   default:
 97438:     NS_ERROR("Invalid shader.");
106838:     return nullptr;
 97438:   }
 97438: }
 97438: 
108991: uint8_t
 97438: LayerD3D10::LoadMaskTexture()
 97435: {
 97435:   if (Layer* maskLayer = GetLayer()->GetMaskLayer()) {
 97435:     gfxIntSize size;
 97435:     nsRefPtr<ID3D10ShaderResourceView> maskSRV =
 97435:       static_cast<LayerD3D10*>(maskLayer->ImplData())->GetAsTexture(&size);
 97435:   
 97435:     if (!maskSRV) {
 97438:       return SHADER_NO_MASK;
 97435:     }
 97435: 
 97435:     gfxMatrix maskTransform;
 97438:     bool maskIs2D = maskLayer->GetEffectiveTransform().CanDraw2D(&maskTransform);
 97435:     NS_ASSERTION(maskIs2D, "How did we end up with a 3D transform here?!");
 97438:     gfxRect bounds = gfxRect(gfxPoint(), size);
 97438:     bounds = maskTransform.TransformBounds(bounds);
 97435: 
 97435:     effect()->GetVariableByName("vMaskQuad")->AsVector()->SetFloatVector(
 97435:       ShaderConstantRectD3D10(
 97435:         (float)bounds.x,
 97435:         (float)bounds.y,
 97435:         (float)bounds.width,
 97435:         (float)bounds.height)
 97435:       );
 97435: 
 97435:     effect()->GetVariableByName("tMask")->AsShaderResource()->SetResource(maskSRV);
 97438:     return SHADER_MASK;
 97435:   }
 97435: 
 97438:   return SHADER_NO_MASK;
 97435: }
 97435: 
 54814: }
 54814: }
