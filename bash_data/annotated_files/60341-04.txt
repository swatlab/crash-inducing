    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
 4006:  *   Elika J. Etemad ("fantasai") <fantasai@inkedblade.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* base class #1 for rendering objects that have child lists */
    1: 
    1: #include "nsContainerFrame.h"
 4006: #include "nsHTMLContainerFrame.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: #include "nsPresContext.h"
    1: #include "nsIRenderingContext.h"
    1: #include "nsStyleContext.h"
    1: #include "nsRect.h"
    1: #include "nsPoint.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsIView.h"
    1: #include "nsHTMLContainerFrame.h"
    1: #include "nsFrameManager.h"
    1: #include "nsIPresShell.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIWidget.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsTransform2D.h"
    1: #include "nsRegion.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsDisplayList.h"
    1: #include "nsContentErrors.h"
    1: #include "nsIEventStateManager.h"
 9635: #include "nsListControlFrame.h"
10102: #include "nsIBaseWindow.h"
16601: #include "nsThemeConstants.h"
16601: #include "nsCSSFrameConstructor.h"
16601: #include "nsThemeConstants.h"
41930: #include "mozilla/dom/Element.h"
    1: 
    1: #ifdef NS_DEBUG
    1: #undef NOISY
    1: #else
    1: #undef NOISY
    1: #endif
    1: 
39965: using namespace mozilla;
41634: using namespace mozilla::dom;
39965: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsContainerFrame)
32423: 
    1: nsContainerFrame::~nsContainerFrame()
    1: {
    1: }
    1: 
32841: NS_QUERYFRAME_HEAD(nsContainerFrame)
32841:   NS_QUERYFRAME_ENTRY(nsContainerFrame)
32841: NS_QUERYFRAME_TAIL_INHERITING(nsSplittableFrame)
32841: 
    1: NS_IMETHODIMP
    1: nsContainerFrame::Init(nsIContent* aContent,
    1:                        nsIFrame*   aParent,
    1:                        nsIFrame*   aPrevInFlow)
    1: {
    1:   nsresult rv = nsSplittableFrame::Init(aContent, aParent, aPrevInFlow);
    1:   if (aPrevInFlow) {
    1:     // Make sure we copy bits from our prev-in-flow that will affect
    1:     // us. A continuation for a container frame needs to know if it
    1:     // has a child with a view so that we'll properly reposition it.
    1:     if (aPrevInFlow->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)
    1:       AddStateBits(NS_FRAME_HAS_CHILD_WITH_VIEW);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsContainerFrame::SetInitialChildList(nsIAtom*     aListName,
30790:                                       nsFrameList& aChildList)
    1: {
    1:   nsresult  result;
32843:   if (mFrames.NotEmpty()) {
    1:     // We already have child frames which means we've already been
    1:     // initialized
    1:     NS_NOTREACHED("unexpected second call to SetInitialChildList");
    1:     result = NS_ERROR_UNEXPECTED;
    1:   } else if (aListName) {
    1:     // All we know about is the unnamed principal child list
    1:     NS_NOTREACHED("unknown frame list");
    1:     result = NS_ERROR_INVALID_ARG;
    1:   } else {
    1: #ifdef NS_DEBUG
    1:     nsFrame::VerifyDirtyBitSet(aChildList);
    1: #endif
    1:     mFrames.SetFrames(aChildList);
    1:     result = NS_OK;
    1:   }
    1:   return result;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsContainerFrame::AppendFrames(nsIAtom*  aListName,
30941:                                nsFrameList& aFrameList)
    1: {
    1:   if (nsnull != aListName) {
    1: #ifdef IBMBIDI
    1:     if (aListName != nsGkAtoms::nextBidi)
    1: #endif
    1:     {
    1:       NS_ERROR("unexpected child list");
    1:       return NS_ERROR_INVALID_ARG;
    1:     }
    1:   }
30941:   if (aFrameList.NotEmpty()) {
    1:     mFrames.AppendFrames(this, aFrameList);
    1: 
    1:     // Ask the parent frame to reflow me.
    1: #ifdef IBMBIDI
    1:     if (nsnull == aListName)
    1: #endif
    1:     {
  238:       PresContext()->PresShell()->
27201:         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
27201:                          NS_FRAME_HAS_DIRTY_CHILDREN);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsContainerFrame::InsertFrames(nsIAtom*  aListName,
    1:                                nsIFrame* aPrevFrame,
30941:                                nsFrameList& aFrameList)
    1: {
    1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
    1:                "inserting after sibling frame with different parent");
    1: 
    1:   if (nsnull != aListName) {
    1: #ifdef IBMBIDI
    1:     if (aListName != nsGkAtoms::nextBidi)
    1: #endif
    1:     {
    1:       NS_ERROR("unexpected child list");
    1:       return NS_ERROR_INVALID_ARG;
    1:     }
    1:   }
30941:   if (aFrameList.NotEmpty()) {
    1:     // Insert frames after aPrevFrame
    1:     mFrames.InsertFrames(this, aPrevFrame, aFrameList);
    1: 
    1: #ifdef IBMBIDI
    1:     if (nsnull == aListName)
    1: #endif
    1:     {
  238:       PresContext()->PresShell()->
27201:         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
27201:                          NS_FRAME_HAS_DIRTY_CHILDREN);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsContainerFrame::RemoveFrame(nsIAtom*  aListName,
    1:                               nsIFrame* aOldFrame)
    1: {
    1:   if (nsnull != aListName) {
    1: #ifdef IBMBIDI
    1:     if (nsGkAtoms::nextBidi != aListName)
    1: #endif
    1:     {
    1:       NS_ERROR("unexpected child list");
    1:       return NS_ERROR_INVALID_ARG;
    1:     }
    1:   }
    1: 
    1:   if (aOldFrame) {
    1:     // Loop and destroy the frame and all of its continuations.
    1:     // If the frame we are removing is a brFrame, we need a reflow so
    1:     // the line the brFrame was on can attempt to pull up any frames
    1:     // that can fit from lines below it.
 8854:     PRBool generateReflowCommand = PR_TRUE;
 8854: #ifdef IBMBIDI
 8854:     if (nsGkAtoms::nextBidi == aListName) {
 8854:       generateReflowCommand = PR_FALSE;
 8854:     }
 8854: #endif
 3233:     nsContainerFrame* parent = static_cast<nsContainerFrame*>(aOldFrame->GetParent());
    1:     while (aOldFrame) {
    1:       // When the parent is an inline frame we have a simple task - just
    1:       // remove the frame from its parents list and generate a reflow
    1:       // command.
    1:       nsIFrame* oldFrameNextContinuation = aOldFrame->GetNextContinuation();
 4006:       //XXXfr probably should use StealFrame here. I'm not sure if we need to
 4006:       //      check the overflow lists atm, but we'll need a prescontext lookup
 4006:       //      for overflow containers once we can split abspos elements with
 4006:       //      inline containing blocks.
 6589:       if (parent == this) {
32844:         if (!parent->mFrames.DestroyFrameIfPresent(aOldFrame)) {
10266:           // Try to remove it from our overflow list, if we have one.
10266:           // The simplest way is to reuse StealFrame.
19448:           StealFrame(PresContext(), aOldFrame, PR_TRUE);
10266:           aOldFrame->Destroy();
10266:         }
 6589:       } else {
 6589:         // This recursive call takes care of all continuations after aOldFrame,
 6589:         // so we don't need to loop anymore.
 6589:         parent->RemoveFrame(nsnull, aOldFrame);
 6589:         break;
 6589:       }
    1:       aOldFrame = oldFrameNextContinuation;
    1:       if (aOldFrame) {
 3233:         parent = static_cast<nsContainerFrame*>(aOldFrame->GetParent());
    1:       }
    1:     }
    1: 
    1:     if (generateReflowCommand) {
  238:       PresContext()->PresShell()->
27201:         FrameNeedsReflow(this, nsIPresShell::eTreeChange,
27201:                          NS_FRAME_HAS_DIRTY_CHILDREN);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
36647: nsContainerFrame::DestroyFrom(nsIFrame* aDestructRoot)
    1: {
    1:   // Prevent event dispatch during destruction
    1:   if (HasView()) {
    1:     GetView()->SetClientData(nsnull);
    1:   }
    1: 
    1:   // Delete the primary child list
36647:   mFrames.DestroyFramesFrom(aDestructRoot);
    1: 
 4006:   // Destroy auxiliary frame lists
 4006:   nsPresContext* prescontext = PresContext();
 4006: 
36647:   DestroyOverflowList(prescontext, aDestructRoot);
    1: 
 4006:   if (IsFrameOfType(nsIFrame::eCanContainOverflowContainers)) {
39965:     nsFrameList* frameList =
39965:       RemovePropTableFrames(prescontext, OverflowContainersProperty());
 4006:     if (frameList)
36647:       frameList->DestroyFrom(aDestructRoot);
 4006: 
 4006:     frameList = RemovePropTableFrames(prescontext,
39965:                                       ExcessOverflowContainersProperty());
 4006:     if (frameList)
36647:       frameList->DestroyFrom(aDestructRoot);
 4006:   }
 4006: 
    1:   // Destroy the frame and remove the flow pointers
36647:   nsSplittableFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: /////////////////////////////////////////////////////////////////////////////
    1: // Child frame enumeration
    1: 
30783: nsFrameList
30783: nsContainerFrame::GetChildList(nsIAtom* aListName) const
    1: {
    1:   // We only know about the unnamed principal child list and the overflow
30783:   // lists
    1:   if (nsnull == aListName) {
30783:     return mFrames;
30783:   }
30783: 
30783:   if (nsGkAtoms::overflowList == aListName) {
30781:     nsFrameList* frameList = GetOverflowFrames();
30783:     return frameList ? *frameList : nsFrameList::EmptyList();
30783:   }
30783: 
30783:   if (nsGkAtoms::overflowContainersList == aListName) {
 4006:     nsFrameList* list = GetPropTableFrames(PresContext(),
39965:                                            OverflowContainersProperty());
30783:     return list ? *list : nsFrameList::EmptyList();
30783:   }
30783: 
30783:   if (nsGkAtoms::excessOverflowContainersList == aListName) {
 4006:     nsFrameList* list = GetPropTableFrames(PresContext(),
39965:                                            ExcessOverflowContainersProperty());
30783:     return list ? *list : nsFrameList::EmptyList();
    1:   }
30783: 
30783:   return nsFrameList::EmptyList();
    1: }
    1: 
 4006: #define NS_CONTAINER_FRAME_OVERFLOW_LIST_INDEX                   0
 4006: #define NS_CONTAINER_FRAME_OVERFLOW_CONTAINERS_LIST_INDEX        1
 4006: #define NS_CONTAINER_FRAME_EXCESS_OVERFLOW_CONTAINERS_LIST_INDEX 2
 4006: // If adding/removing lists, don't forget to update count in .h file
 4006: 
 4006: 
    1: nsIAtom*
    1: nsContainerFrame::GetAdditionalChildListName(PRInt32 aIndex) const
    1: {
 4006:   if (NS_CONTAINER_FRAME_OVERFLOW_LIST_INDEX == aIndex)
    1:     return nsGkAtoms::overflowList;
 4006:   else if (IsFrameOfType(nsIFrame::eCanContainOverflowContainers)) {
 4006:     if (NS_CONTAINER_FRAME_OVERFLOW_CONTAINERS_LIST_INDEX == aIndex)
 4006:       return nsGkAtoms::overflowContainersList;
 4006:     else if (NS_CONTAINER_FRAME_EXCESS_OVERFLOW_CONTAINERS_LIST_INDEX == aIndex)
 4006:       return nsGkAtoms::excessOverflowContainersList;
 4006:   }
    1:   return nsnull;
    1: }
    1: 
    1: /////////////////////////////////////////////////////////////////////////////
    1: // Painting/Events
    1: 
    1: NS_IMETHODIMP
    1: nsContainerFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                    const nsRect&           aDirtyRect,
    1:                                    const nsDisplayListSet& aLists)
    1: {
    1:   nsresult rv = DisplayBorderBackgroundOutline(aBuilder, aLists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return BuildDisplayListForNonBlockChildren(aBuilder, aDirtyRect, aLists);
    1: }
    1: 
    1: nsresult
    1: nsContainerFrame::BuildDisplayListForNonBlockChildren(nsDisplayListBuilder*   aBuilder,
    1:                                                       const nsRect&           aDirtyRect,
    1:                                                       const nsDisplayListSet& aLists,
    1:                                                       PRUint32                aFlags)
    1: {
    1:   nsIFrame* kid = mFrames.FirstChild();
    1:   // Put each child's background directly onto the content list
    1:   nsDisplayListSet set(aLists, aLists.Content());
    1:   // The children should be in content order
    1:   while (kid) {
    1:     nsresult rv = BuildDisplayListForChild(aBuilder, kid, aDirtyRect, set, aFlags);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     kid = kid->GetNextSibling();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ void
    1: nsContainerFrame::ChildIsDirty(nsIFrame* aChild)
    1: {
    1:   AddStateBits(NS_FRAME_HAS_DIRTY_CHILDREN);
    1: }
    1: 
    1: PRBool
    1: nsContainerFrame::IsLeaf() const
    1: {
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
    1: nsContainerFrame::PeekOffsetNoAmount(PRBool aForward, PRInt32* aOffset)
    1: {
    1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
    1:   // Don't allow the caret to stay in an empty (leaf) container frame.
    1:   return PR_FALSE;
    1: }
    1: 
    1: PRBool
59604: nsContainerFrame::PeekOffsetCharacter(PRBool aForward, PRInt32* aOffset,
59604:                                       PRBool aRespectClusters)
    1: {
    1:   NS_ASSERTION (aOffset && *aOffset <= 1, "aOffset out of range");
    1:   // Don't allow the caret to stay in an empty (leaf) container frame.
    1:   return PR_FALSE;
    1: }
    1: 
    1: /////////////////////////////////////////////////////////////////////////////
    1: // Helper member functions
    1: 
    1: /**
    1:  * Position the view associated with |aKidFrame|, if there is one. A
    1:  * container frame should call this method after positioning a frame,
    1:  * but before |Reflow|.
    1:  */
    1: void
    1: nsContainerFrame::PositionFrameView(nsIFrame* aKidFrame)
    1: {
    1:   nsIFrame* parentFrame = aKidFrame->GetParent();
    1:   if (!aKidFrame->HasView() || !parentFrame)
    1:     return;
    1: 
    1:   nsIView* view = aKidFrame->GetView();
    1:   nsIViewManager* vm = view->GetViewManager();
    1:   nsPoint pt;
    1:   nsIView* ancestorView = parentFrame->GetClosestView(&pt);
    1: 
    1:   if (ancestorView != view->GetParent()) {
    1:     NS_ASSERTION(ancestorView == view->GetParent()->GetParent(),
    1:                  "Allowed only one anonymous view between frames");
    1:     // parentFrame is responsible for positioning aKidFrame's view
    1:     // explicitly
    1:     return;
    1:   }
    1: 
    1:   pt += aKidFrame->GetPosition();
    1:   vm->MoveViewTo(view, pt.x, pt.y);
    1: }
    1: 
31401: static nsIWidget*
31401: GetPresContextContainerWidget(nsPresContext* aPresContext)
10102: {
10102:   nsCOMPtr<nsISupports> container = aPresContext->Document()->GetContainer();
10102:   nsCOMPtr<nsIBaseWindow> baseWindow = do_QueryInterface(container);
10102:   if (!baseWindow)
31401:     return nsnull;
10102: 
10102:   nsCOMPtr<nsIWidget> mainWidget;
10102:   baseWindow->GetMainWidget(getter_AddRefs(mainWidget));
31401:   return mainWidget;
31401: }
10102: 
31401: static PRBool
31401: IsTopLevelWidget(nsIWidget* aWidget)
31401: {
10102:   nsWindowType windowType;
31401:   aWidget->GetWindowType(windowType);
10102:   return windowType == eWindowType_toplevel ||
31401:          windowType == eWindowType_dialog ||
31401:          windowType == eWindowType_sheet;
10102:   // popups aren't toplevel so they're not handled here
10102: }
10102: 
31401: void
31401: nsContainerFrame::SyncWindowProperties(nsPresContext*       aPresContext,
    1:                                        nsIFrame*            aFrame,
31401:                                        nsIView*             aView)
    1: {
23154: #ifdef MOZ_XUL
31401:   if (!aView || !nsCSSRendering::IsCanvasFrame(aFrame) || !aView->HasWidget())
23154:     return;
23154: 
31401:   nsIWidget* windowWidget = GetPresContextContainerWidget(aPresContext);
31401:   if (!windowWidget || !IsTopLevelWidget(windowWidget))
25022:     return;
25022: 
25022:   nsIViewManager* vm = aView->GetViewManager();
    1:   nsIView* rootView;
    1:   vm->GetRootView(rootView);
    1: 
25022:   if (aView != rootView)
23154:     return;
23154: 
41634:   Element* rootElement = aPresContext->Document()->GetRootElement();
41634:   if (!rootElement || !rootElement->IsXUL()) {
23154:     // Scrollframes use native widgets which don't work well with
23154:     // translucent windows, at least in Windows XP. So if the document
23154:     // has a root scrollrame it's useless to try to make it transparent,
23154:     // we'll just get something broken.
23154:     // nsCSSFrameConstructor::ConstructRootFrame constructs root
23154:     // scrollframes whenever the root element is not a XUL element, so
23154:     // we test for that here. We can't just call
23154:     // presShell->GetRootScrollFrame() since that might not have
23154:     // been constructed yet.
23154:     // We can change this to allow translucent toplevel HTML documents
23154:     // (e.g. to do something like Dashboard widgets), once we
23154:     // have broad support for translucent scrolled documents, but be
23154:     // careful because apparently some Firefox extensions expect
23154:     // openDialog("something.html") to produce an opaque window
23154:     // even if the HTML doesn't have a background-color set.
23154:     return;
23154:   }
23154: 
31401:   nsIFrame *rootFrame = aPresContext->PresShell()->FrameConstructor()->GetRootElementStyleFrame();
31401:   if (!rootFrame)
31401:     return;
31401: 
31535:   nsTransparencyMode mode = nsLayoutUtils::GetFrameTransparency(aFrame, rootFrame);
31401:   nsIWidget* viewWidget = aView->GetWidget();
31401:   viewWidget->SetTransparencyMode(mode);
31401:   windowWidget->SetWindowShadowStyle(rootFrame->GetStyleUIReset()->mWindowShadow);
23154: #endif
    1: }
    1: 
    1: void
    1: nsContainerFrame::SyncFrameViewAfterReflow(nsPresContext* aPresContext,
    1:                                            nsIFrame*       aFrame,
    1:                                            nsIView*        aView,
55021:                                            const nsRect&   aVisualOverflowArea,
    1:                                            PRUint32        aFlags)
    1: {
    1:   if (!aView) {
    1:     return;
    1:   }
    1: 
    1:   // Make sure the view is sized and positioned correctly
    1:   if (0 == (aFlags & NS_FRAME_NO_MOVE_VIEW)) {
    1:     PositionFrameView(aFrame);
    1:   }
    1: 
    1:   if (0 == (aFlags & NS_FRAME_NO_SIZE_VIEW)) {
    1:     nsIViewManager* vm = aView->GetViewManager();
    1: 
55021:     vm->ResizeView(aView, aVisualOverflowArea, PR_TRUE);
    1:   }
    1: }
    1: 
    1: void
    1: nsContainerFrame::SyncFrameViewProperties(nsPresContext*  aPresContext,
    1:                                           nsIFrame*        aFrame,
    1:                                           nsStyleContext*  aStyleContext,
    1:                                           nsIView*         aView,
    1:                                           PRUint32         aFlags)
    1: {
    1:   NS_ASSERTION(!aStyleContext || aFrame->GetStyleContext() == aStyleContext,
    1:                "Wrong style context for frame?");
    1: 
    1:   if (!aView) {
    1:     return;
    1:   }
    1: 
    1:   nsIViewManager* vm = aView->GetViewManager();
    1: 
    1:   if (nsnull == aStyleContext) {
    1:     aStyleContext = aFrame->GetStyleContext();
    1:   }
    1: 
32181:   // Make sure visibility is correct. This only affects nsSubdocumentFrame.
32181:   if (0 == (aFlags & NS_FRAME_NO_VISIBILITY) &&
32181:       !aFrame->SupportsVisibilityHidden()) {
    1:     // See if the view should be hidden or visible
32181:     vm->SetViewVisibility(aView,
32181:         aStyleContext->GetStyleVisibility()->IsVisible()
32181:             ? nsViewVisibility_kShow : nsViewVisibility_kHide);
    1:   }
    1: 
    1:   // See if the frame is being relatively positioned or absolutely
    1:   // positioned
    1:   PRBool isPositioned = aStyleContext->GetStyleDisplay()->IsPositioned();
    1: 
    1:   PRInt32 zIndex = 0;
    1:   PRBool  autoZIndex = PR_FALSE;
    1: 
    1:   if (!isPositioned) {
    1:     autoZIndex = PR_TRUE;
    1:   } else {
    1:     // Make sure z-index is correct
    1:     const nsStylePosition* position = aStyleContext->GetStylePosition();
    1: 
    1:     if (position->mZIndex.GetUnit() == eStyleUnit_Integer) {
    1:       zIndex = position->mZIndex.GetIntValue();
    1:     } else if (position->mZIndex.GetUnit() == eStyleUnit_Auto) {
    1:       autoZIndex = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   vm->SetViewZIndex(aView, autoZIndex, zIndex, isPositioned);
    1: }
    1: 
    1: static nscoord GetCoord(const nsStyleCoord& aCoord, nscoord aIfNotCoord)
    1: {
51776:   if (aCoord.ConvertsToLength()) {
51776:     return nsRuleNode::ComputeCoordPercentCalc(aCoord, 0);
51776:   }
51776:   return aIfNotCoord;
    1: }
    1: 
    1: void
    1: nsContainerFrame::DoInlineIntrinsicWidth(nsIRenderingContext *aRenderingContext,
    1:                                          InlineIntrinsicWidthData *aData,
    1:                                          nsLayoutUtils::IntrinsicWidthType aType)
    1: {
    1:   if (GetPrevInFlow())
    1:     return; // Already added.
    1: 
    1:   NS_PRECONDITION(aType == nsLayoutUtils::MIN_WIDTH ||
    1:                   aType == nsLayoutUtils::PREF_WIDTH, "bad type");
    1: 
41419:   mozilla::css::Side startSide, endSide;
    1:   if (GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR) {
    1:     startSide = NS_SIDE_LEFT;
    1:     endSide = NS_SIDE_RIGHT;
    1:   } else {
    1:     startSide = NS_SIDE_RIGHT;
    1:     endSide = NS_SIDE_LEFT;
    1:   }
    1: 
    1:   const nsStylePadding *stylePadding = GetStylePadding();
    1:   const nsStyleBorder *styleBorder = GetStyleBorder();
    1:   const nsStyleMargin *styleMargin = GetStyleMargin();
    1: 
    1:   // This goes at the beginning no matter how things are broken and how
    1:   // messy the bidi situations are, since per CSS2.1 section 8.6
    1:   // (implemented in bug 328168), the startSide border is always on the
    1:   // first line.
12899:   // This frame is a first-in-flow, but it might have a previous bidi
12899:   // continuation, in which case that continuation should handle the startSide
12899:   // border.
12899:   if (!GetPrevContinuation()) {
    1:     aData->currentLine +=
52283:       // clamp negative calc() to 0
52283:       NS_MAX(GetCoord(stylePadding->mPadding.Get(startSide), 0), 0) +
15992:       styleBorder->GetActualBorderWidth(startSide) +
12630:       GetCoord(styleMargin->mMargin.Get(startSide), 0);
12899:   }
    1: 
10113:   const nsLineList_iterator* savedLine = aData->line;
25237:   nsIFrame* const savedLineContainer = aData->lineContainer;
10113: 
12899:   nsContainerFrame *lastInFlow;
10116:   for (nsContainerFrame *nif = this; nif;
25237:        nif = static_cast<nsContainerFrame*>(nif->GetNextInFlow())) {
    1:     for (nsIFrame *kid = nif->mFrames.FirstChild(); kid;
    1:          kid = kid->GetNextSibling()) {
    1:       if (aType == nsLayoutUtils::MIN_WIDTH)
    1:         kid->AddInlineMinWidth(aRenderingContext,
 3233:                                static_cast<InlineMinWidthData*>(aData));
    1:       else
    1:         kid->AddInlinePrefWidth(aRenderingContext,
 3233:                                 static_cast<InlinePrefWidthData*>(aData));
    1:     }
10113: 
25237:     // After we advance to our next-in-flow, the stored line and line container
25237:     // may no longer be correct. Just forget them.
10113:     aData->line = nsnull;
25237:     aData->lineContainer = nsnull;
25237: 
12899:     lastInFlow = nif;
    1:   }
10113: 
10113:   aData->line = savedLine;
25237:   aData->lineContainer = savedLineContainer;
    1: 
    1:   // This goes at the end no matter how things are broken and how
    1:   // messy the bidi situations are, since per CSS2.1 section 8.6
    1:   // (implemented in bug 328168), the endSide border is always on the
    1:   // last line.
12899:   // We reached the last-in-flow, but it might have a next bidi
12899:   // continuation, in which case that continuation should handle
12899:   // the endSide border.
12899:   if (!lastInFlow->GetNextContinuation()) {
    1:     aData->currentLine +=
52283:       // clamp negative calc() to 0
52283:       NS_MAX(GetCoord(stylePadding->mPadding.Get(endSide), 0), 0) +
15992:       styleBorder->GetActualBorderWidth(endSide) +
12630:       GetCoord(styleMargin->mMargin.Get(endSide), 0);
    1:   }
12899: }
    1: 
    1: /* virtual */ nsSize
    1: nsContainerFrame::ComputeAutoSize(nsIRenderingContext *aRenderingContext,
    1:                                   nsSize aCBSize, nscoord aAvailableWidth,
    1:                                   nsSize aMargin, nsSize aBorder,
    1:                                   nsSize aPadding, PRBool aShrinkWrap)
    1: {
    1:   nsSize result(0xdeadbeef, NS_UNCONSTRAINEDSIZE);
    1:   nscoord availBased = aAvailableWidth - aMargin.width - aBorder.width -
    1:                        aPadding.width;
    1:   // replaced elements always shrink-wrap
    1:   if (aShrinkWrap || IsFrameOfType(eReplaced)) {
    1:     // don't bother setting it if the result won't be used
    1:     if (GetStylePosition()->mWidth.GetUnit() == eStyleUnit_Auto) {
    1:       result.width = ShrinkWidthToFit(aRenderingContext, availBased);
    1:     }
    1:   } else {
    1:     result.width = availBased;
    1:   }
    1:   return result;
    1: }
    1: 
    1: /**
    1:  * Invokes the WillReflow() function, positions the frame and its view (if
    1:  * requested), and then calls Reflow(). If the reflow succeeds and the child
    1:  * frame is complete, deletes any next-in-flows using DeleteNextInFlowChild()
    1:  */
    1: nsresult
    1: nsContainerFrame::ReflowChild(nsIFrame*                aKidFrame,
    1:                               nsPresContext*           aPresContext,
    1:                               nsHTMLReflowMetrics&     aDesiredSize,
    1:                               const nsHTMLReflowState& aReflowState,
    1:                               nscoord                  aX,
    1:                               nscoord                  aY,
    1:                               PRUint32                 aFlags,
 4006:                               nsReflowStatus&          aStatus,
 4006:                               nsOverflowContinuationTracker* aTracker)
    1: {
    1:   NS_PRECONDITION(aReflowState.frame == aKidFrame, "bad reflow state");
    1: 
    1:   nsresult  result;
    1: 
    1:   // Send the WillReflow() notification, and position the child frame
    1:   // and its view if requested
    1:   aKidFrame->WillReflow(aPresContext);
    1: 
18884:   if (NS_FRAME_NO_MOVE_FRAME != (aFlags & NS_FRAME_NO_MOVE_FRAME)) {
11384:     if ((aFlags & NS_FRAME_INVALIDATE_ON_MOVE) &&
11384:         !(aKidFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) &&
11384:         aKidFrame->GetPosition() != nsPoint(aX, aY)) {
51756:       aKidFrame->InvalidateFrameSubtree();
11384:     }
    1:     aKidFrame->SetPosition(nsPoint(aX, aY));
    1:   }
    1: 
    1:   if (0 == (aFlags & NS_FRAME_NO_MOVE_VIEW)) {
    1:     PositionFrameView(aKidFrame);
    1:   }
    1: 
    1:   // Reflow the child frame
    1:   result = aKidFrame->Reflow(aPresContext, aDesiredSize, aReflowState,
    1:                              aStatus);
    1: 
    1:   // If the reflow was successful and the child frame is complete, delete any
    1:   // next-in-flows
 4006:   if (NS_SUCCEEDED(result) && NS_FRAME_IS_FULLY_COMPLETE(aStatus)) {
    1:     nsIFrame* kidNextInFlow = aKidFrame->GetNextInFlow();
    1:     if (nsnull != kidNextInFlow) {
    1:       // Remove all of the childs next-in-flows. Make sure that we ask
    1:       // the right parent to do the removal (it's possible that the
    1:       // parent is not this because we are executing pullup code)
 6521:       if (aTracker) aTracker->Finish(aKidFrame);
 3233:       static_cast<nsContainerFrame*>(kidNextInFlow->GetParent())
22195:         ->DeleteNextInFlowChild(aPresContext, kidNextInFlow, PR_TRUE);
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: 
    1: /**
    1:  * Position the views of |aFrame|'s descendants. A container frame
    1:  * should call this method if it moves a frame after |Reflow|.
    1:  */
    1: void
    1: nsContainerFrame::PositionChildViews(nsIFrame* aFrame)
    1: {
    1:   if (!(aFrame->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)) {
    1:     return;
    1:   }
    1: 
    1:   nsIAtom*  childListName = nsnull;
    1:   PRInt32   childListIndex = 0;
    1: 
    1:   do {
    1:     // Recursively walk aFrame's child frames
    1:     nsIFrame* childFrame = aFrame->GetFirstChild(childListName);
    1:     while (childFrame) {
    1:       // Position the frame's view (if it has one) otherwise recursively
    1:       // process its children
    1:       if (childFrame->HasView()) {
    1:         PositionFrameView(childFrame);
    1:       } else {
    1:         PositionChildViews(childFrame);
    1:       }
    1: 
    1:       // Get the next sibling child frame
    1:       childFrame = childFrame->GetNextSibling();
    1:     }
    1: 
 3129:     // also process the additional child lists, but skip the popup list as the
 3129:     // view for popups is managed by the parent. Currently only nsMenuFrame
 3129:     // has a popupList and during layout will call nsMenuPopupFrame::AdjustView.
 3129:     do {
    1:       childListName = aFrame->GetAdditionalChildListName(childListIndex++);
 3129:     } while (childListName == nsGkAtoms::popupList);
    1:   } while (childListName);
    1: }
    1: 
    1: /**
    1:  * The second half of frame reflow. Does the following:
    1:  * - sets the frame's bounds
    1:  * - sizes and positions (if requested) the frame's view. If the frame's final
    1:  *   position differs from the current position and the frame itself does not
    1:  *   have a view, then any child frames with views are positioned so they stay
    1:  *   in sync
    1:  * - sets the view's visibility, opacity, content transparency, and clip
    1:  * - invoked the DidReflow() function
    1:  *
    1:  * Flags:
    1:  * NS_FRAME_NO_MOVE_FRAME - don't move the frame. aX and aY are ignored in this
    1:  *    case. Also implies NS_FRAME_NO_MOVE_VIEW
    1:  * NS_FRAME_NO_MOVE_VIEW - don't position the frame's view. Set this if you
    1:  *    don't want to automatically sync the frame and view
    1:  * NS_FRAME_NO_SIZE_VIEW - don't size the frame's view
    1:  */
    1: nsresult
    1: nsContainerFrame::FinishReflowChild(nsIFrame*                  aKidFrame,
    1:                                     nsPresContext*             aPresContext,
    1:                                     const nsHTMLReflowState*   aReflowState,
 9771:                                     const nsHTMLReflowMetrics& aDesiredSize,
    1:                                     nscoord                    aX,
    1:                                     nscoord                    aY,
    1:                                     PRUint32                   aFlags)
    1: {
    1:   nsPoint curOrigin = aKidFrame->GetPosition();
    1:   nsRect  bounds(aX, aY, aDesiredSize.width, aDesiredSize.height);
    1: 
    1:   aKidFrame->SetRect(bounds);
    1: 
    1:   if (aKidFrame->HasView()) {
    1:     nsIView* view = aKidFrame->GetView();
    1:     // Make sure the frame's view is properly sized and positioned and has
    1:     // things like opacity correct
    1:     SyncFrameViewAfterReflow(aPresContext, aKidFrame, view,
55039:                              aDesiredSize.VisualOverflow(), aFlags);
    1:   }
    1: 
    1:   if (!(aFlags & NS_FRAME_NO_MOVE_VIEW) &&
    1:       (curOrigin.x != aX || curOrigin.y != aY)) {
    1:     if (!aKidFrame->HasView()) {
    1:       // If the frame has moved, then we need to make sure any child views are
    1:       // correctly positioned
    1:       PositionChildViews(aKidFrame);
    1:     }
    1: 
    1:     // We also need to redraw everything associated with the frame
    1:     // because if the frame's Reflow issued any invalidates, then they
    1:     // will be at the wrong offset ... note that this includes
    1:     // invalidates issued against the frame's children, so we need to
    1:     // invalidate the overflow area too.
55039:     aKidFrame->Invalidate(aDesiredSize.VisualOverflow());
    1:   }
    1: 
    1:   return aKidFrame->DidReflow(aPresContext, aReflowState, NS_FRAME_REFLOW_FINISHED);
    1: }
    1: 
 4006: nsresult
 4006: nsContainerFrame::ReflowOverflowContainerChildren(nsPresContext*           aPresContext,
 4006:                                                   const nsHTMLReflowState& aReflowState,
55023:                                                   nsOverflowAreas&         aOverflowRects,
 4006:                                                   PRUint32                 aFlags,
 4006:                                                   nsReflowStatus&          aStatus)
 4006: {
 4006:   NS_PRECONDITION(aPresContext, "null pointer");
 4006:   nsresult rv = NS_OK;
 4006: 
 4006:   nsFrameList* overflowContainers =
 4006:                GetPropTableFrames(aPresContext,
39965:                                   OverflowContainersProperty());
 4006: 
 4006:   NS_ASSERTION(!(overflowContainers && GetPrevInFlow()
 4006:                  && static_cast<nsContainerFrame*>(GetPrevInFlow())
 4006:                       ->GetPropTableFrames(aPresContext,
39965:                           ExcessOverflowContainersProperty())),
 4006:                "conflicting overflow containers lists");
 4006: 
 4006:   if (!overflowContainers) {
 4006:     // Drain excess from previnflow
 4006:     nsContainerFrame* prev = (nsContainerFrame*) GetPrevInFlow();
 4006:     if (prev) {
 4006:       nsFrameList* excessFrames =
 4006:         prev->RemovePropTableFrames(aPresContext,
39965:                                     ExcessOverflowContainersProperty());
 4006:       if (excessFrames) {
32843:         excessFrames->ApplySetParent(this);
32843:         nsHTMLContainerFrame::ReparentFrameViewList(aPresContext, *excessFrames,
 4006:                                                     prev, this);
 4006:         overflowContainers = excessFrames;
 4006:         rv = SetPropTableFrames(aPresContext, overflowContainers,
39965:                                 OverflowContainersProperty());
 4006:         if (NS_FAILED(rv)) {
 4006:           excessFrames->DestroyFrames();
 4006:           delete excessFrames;
 4006:           return rv;
 4006:         }
 4006:       }
 4006:     }
 4006:   }
 4006: 
 4006:   if (!overflowContainers)
 4006:     return NS_OK; // nothing to reflow
 4006: 
 6521:   nsOverflowContinuationTracker tracker(aPresContext, this, PR_FALSE, PR_FALSE);
42437:   PRBool shouldReflowAllKids = aReflowState.ShouldReflowAllKids();
42437: 
 4006:   for (nsIFrame* frame = overflowContainers->FirstChild(); frame;
 4006:        frame = frame->GetNextSibling()) {
28158:     if (frame->GetPrevInFlow()->GetParent() != GetPrevInFlow()) {
28158:       // frame's prevInFlow has moved, skip reflowing this frame;
28158:       // it will get reflowed once it's been placed
28158:       continue;
28158:     }
42437:     // If the available vertical height has changed, we need to reflow
42437:     // even if the frame isn't dirty.
42437:     if (shouldReflowAllKids || NS_SUBTREE_DIRTY(frame)) {
 4006:       // Get prev-in-flow
 4006:       nsIFrame* prevInFlow = frame->GetPrevInFlow();
 4006:       NS_ASSERTION(prevInFlow,
 4006:                    "overflow container frame must have a prev-in-flow");
 4006:       NS_ASSERTION(frame->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER,
 4006:                    "overflow container frame must have overflow container bit set");
 4006:       nsRect prevRect = prevInFlow->GetRect();
 4006: 
 4006:       // Initialize reflow params
 4006:       nsSize availSpace(prevRect.width, aReflowState.availableHeight);
 4006:       nsHTMLReflowMetrics desiredSize;
 4006:       nsHTMLReflowState frameState(aPresContext, aReflowState,
 4006:                                    frame, availSpace);
 4006:       nsReflowStatus frameStatus = NS_FRAME_COMPLETE;
 4006: 
 6521:       // Cache old bounds
 6521:       nsRect oldRect = frame->GetRect();
55040:       nsRect oldOverflow = frame->GetVisualOverflowRect();
 6521: 
 4006:       // Reflow
 4006:       rv = ReflowChild(frame, aPresContext, desiredSize, frameState,
 6521:                        prevRect.x, 0, aFlags, frameStatus, &tracker);
 4006:       NS_ENSURE_SUCCESS(rv, rv);
 4006:       //XXXfr Do we need to override any shrinkwrap effects here?
 4006:       // e.g. desiredSize.width = prevRect.width;
 4006:       rv = FinishReflowChild(frame, aPresContext, &frameState, desiredSize,
 4006:                              prevRect.x, 0, aFlags);
 4006:       NS_ENSURE_SUCCESS(rv, rv);
 4006: 
 6521:       // Invalidate if there was a position or size change
 6521:       nsRect rect = frame->GetRect();
 6521:       if (rect != oldRect) {
 6521:         nsRect dirtyRect = oldOverflow;
 6521:         dirtyRect.MoveBy(oldRect.x, oldRect.y);
 6521:         Invalidate(dirtyRect);
 6521: 
55039:         dirtyRect = frame->GetVisualOverflowRect();
 6521:         dirtyRect.MoveBy(rect.x, rect.y);
 6521:         Invalidate(dirtyRect);
 6521:       }
 6521: 
 4006:       // Handle continuations
 6521:       if (!NS_FRAME_IS_FULLY_COMPLETE(frameStatus)) {
 6521:         if (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 6521:           // Abspos frames can't cause their parent to be incomplete,
 6521:           // only overflow incomplete.
 6521:           NS_FRAME_SET_OVERFLOW_INCOMPLETE(frameStatus);
 6521:         }
 6521:         else {
 4006:           NS_ASSERTION(NS_FRAME_IS_COMPLETE(frameStatus),
 4006:                        "overflow container frames can't be incomplete, only overflow-incomplete");
 6521:         }
 6521: 
 4006:         // Acquire a next-in-flow, creating it if necessary
 4006:         nsIFrame* nif = frame->GetNextInFlow();
 4006:         if (!nif) {
 4006:           NS_ASSERTION(frameStatus & NS_FRAME_REFLOW_NEXTINFLOW,
 4006:                        "Someone forgot a REFLOW_NEXTINFLOW flag");
32841:           rv = aPresContext->PresShell()->FrameConstructor()->
32841:                  CreateContinuingFrame(aPresContext, frame, this, &nif);
32841:           NS_ENSURE_SUCCESS(rv, rv);
 4006:         }
 4006:         else if (!(nif->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
 4006:           // used to be a normal next-in-flow; steal it from the child list
 4006:           rv = static_cast<nsContainerFrame*>(nif->GetParent())
 4006:                  ->StealFrame(aPresContext, nif);
 4006:           NS_ENSURE_SUCCESS(rv, rv);
 4006:         }
 4006: 
 4006:         tracker.Insert(nif, frameStatus);
 4006:       }
15183:       NS_MergeReflowStatusInto(&aStatus, frameStatus);
 4006:       // At this point it would be nice to assert !frame->GetOverflowRect().IsEmpty(),
 4006:       // but we have some unsplittable frames that, when taller than
 4006:       // availableHeight will push zero-height content into a next-in-flow.
 4006:     }
 4006:     else {
 4006:       tracker.Skip(frame, aStatus);
32108:       if (aReflowState.mFloatManager)
32108:         nsBlockFrame::RecoverFloatsFor(frame, *aReflowState.mFloatManager);
 4006:     }
55023:     ConsiderChildOverflow(aOverflowRects, frame);
 4006:   }
 4006: 
 4006:   return NS_OK;
 4006: }
 4006: 
 4006: void
 4006: nsContainerFrame::DisplayOverflowContainers(nsDisplayListBuilder*   aBuilder,
 4006:                                             const nsRect&           aDirtyRect,
 4006:                                             const nsDisplayListSet& aLists)
 4006: {
39965:   nsFrameList* overflowconts =
39965:     GetPropTableFrames(PresContext(), OverflowContainersProperty());
 4006:   if (overflowconts) {
 4006:     for (nsIFrame* frame = overflowconts->FirstChild(); frame;
 4006:          frame = frame->GetNextSibling()) {
 4006:       BuildDisplayListForChild(aBuilder, frame, aDirtyRect, aLists);
 4006:     }
 4006:   }
 4006: }
 4006: 
 4006: nsresult
 4006: nsContainerFrame::StealFrame(nsPresContext* aPresContext,
 4006:                              nsIFrame*      aChild,
 4006:                              PRBool         aForceNormal)
 4006: {
 4006:   PRBool removed = PR_TRUE;
 4006:   if ((aChild->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)
 4006:       && !aForceNormal) {
 4006:     // Try removing from the overflow container list
 4006:     if (!RemovePropTableFrame(aPresContext, aChild,
39965:                               OverflowContainersProperty())) {
 4006:       // It must be in the excess overflow container list
 4006:       removed = RemovePropTableFrame(aPresContext, aChild,
39965:                                      ExcessOverflowContainersProperty());
 4006:     }
 4006:   }
 4006:   else {
32844:     if (!mFrames.RemoveFrameIfPresent(aChild)) {
32844:       removed = PR_FALSE;
 4006:       // We didn't find the child in the parent's principal child list.
 4006:       // Maybe it's on the overflow list?
30781:       nsFrameList* frameList = GetOverflowFrames();
30781:       if (frameList) {
32844:         removed = frameList->RemoveFrameIfPresent(aChild);
30781:         if (frameList->IsEmpty()) {
50444:           DestroyOverflowList(aPresContext, nsnull);
30781:         }
 4006:       }
 4006:     }
 4006:   }
32844: 
32844:   NS_POSTCONDITION(removed, "StealFrame: can't find aChild");
32844:   return removed ? NS_OK : NS_ERROR_UNEXPECTED;
 4006: }
 4006: 
32841: nsFrameList
32841: nsContainerFrame::StealFramesAfter(nsIFrame* aChild)
32841: {
32841:   NS_ASSERTION(!aChild ||
32841:                !(aChild->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER),
32841:                "StealFramesAfter doesn't handle overflow containers");
32841:   NS_ASSERTION(GetType() != nsGkAtoms::blockFrame, "unexpected call");
32841: 
32841:   if (!aChild) {
32841:     nsFrameList copy(mFrames);
32841:     mFrames.Clear();
32841:     return copy;
32841:   }
32841: 
32841:   for (nsFrameList::FrameLinkEnumerator iter(mFrames); !iter.AtEnd();
32841:        iter.Next()) {
32841:     if (iter.PrevFrame() == aChild) {
32841:       return mFrames.ExtractTail(iter);
32841:     }
32841:   }
32841: 
32841:   // We didn't find the child in the principal child list.
32841:   // Maybe it's on the overflow list?
32841:   nsFrameList* overflowFrames = GetOverflowFrames();
32841:   if (overflowFrames) {
32841:     for (nsFrameList::FrameLinkEnumerator iter(*overflowFrames); !iter.AtEnd();
32841:          iter.Next()) {
32841:       if (iter.PrevFrame() == aChild) {
32841:         return overflowFrames->ExtractTail(iter);
32841:       }
32841:     }
32841:   }
32841: 
32841:   NS_ERROR("StealFramesAfter: can't find aChild");
32841:   return nsFrameList::EmptyList();
32841: }
32841: 
30781: void
36647: nsContainerFrame::DestroyOverflowList(nsPresContext* aPresContext,
36647:                                       nsIFrame*      aDestructRoot)
30781: {
30781:   nsFrameList* list =
39965:     RemovePropTableFrames(aPresContext, OverflowProperty());
50444:   if (list) {
50444:     if (aDestructRoot)
36647:       list->DestroyFrom(aDestructRoot);
50444:     else
50444:       list->Destroy();
50444:   }
30781: }
30781: 
    1: /**
    1:  * Remove and delete aNextInFlow and its next-in-flows. Updates the sibling and flow
    1:  * pointers
    1:  */
    1: void
    1: nsContainerFrame::DeleteNextInFlowChild(nsPresContext* aPresContext,
22195:                                         nsIFrame*      aNextInFlow,
22195:                                         PRBool         aDeletingEmptyFrames)
    1: {
19448: #ifdef DEBUG
18981:   nsIFrame* prevInFlow = aNextInFlow->GetPrevInFlow();
19448: #endif
18981:   NS_PRECONDITION(prevInFlow, "bad prev-in-flow");
    1: 
    1:   // If the next-in-flow has a next-in-flow then delete it, too (and
    1:   // delete it first).
    1:   // Do this in a loop so we don't overflow the stack for frames
    1:   // with very many next-in-flows
    1:   nsIFrame* nextNextInFlow = aNextInFlow->GetNextInFlow();
    1:   if (nextNextInFlow) {
24551:     nsAutoTArray<nsIFrame*, 8> frames;
    1:     for (nsIFrame* f = nextNextInFlow; f; f = f->GetNextInFlow()) {
    1:       frames.AppendElement(f);
    1:     }
24551:     for (PRInt32 i = frames.Length() - 1; i >= 0; --i) {
24551:       nsIFrame* delFrame = frames.ElementAt(i);
 3233:       static_cast<nsContainerFrame*>(delFrame->GetParent())
22195:         ->DeleteNextInFlowChild(aPresContext, delFrame, aDeletingEmptyFrames);
    1:     }
    1:   }
    1: 
51756:   aNextInFlow->InvalidateFrameSubtree();
 6521: 
    1:   // Take the next-in-flow out of the parent's child list
19448: #ifdef DEBUG
19448:   nsresult rv =
19448: #endif
19448:     StealFrame(aPresContext, aNextInFlow);
 4006:   NS_ASSERTION(NS_SUCCEEDED(rv), "StealFrame failure");
    1: 
60341: #ifdef DEBUG
60341:   if (aDeletingEmptyFrames) {
60341:     nsLayoutUtils::AssertTreeOnlyEmptyNextInFlows(aNextInFlow);
60341:   }
60341: #endif
60341: 
22489:   // Delete the next-in-flow frame and its descendants. This will also
22489:   // remove it from its next-in-flow/prev-in-flow chain.
    1:   aNextInFlow->Destroy();
    1: 
    1:   NS_POSTCONDITION(!prevInFlow->GetNextInFlow(), "non null next-in-flow");
    1: }
    1: 
30781: /**
30781:  * Set the frames on the overflow list
30781:  */
30781: nsresult
30781: nsContainerFrame::SetOverflowFrames(nsPresContext* aPresContext,
30781:                                     const nsFrameList& aOverflowFrames)
30781: {
30781:   NS_PRECONDITION(aOverflowFrames.NotEmpty(), "Shouldn't be called");
30781:   nsFrameList* newList = new nsFrameList(aOverflowFrames);
30781:   if (!newList) {
30781:     // XXXbz should really destroy the frames here, but callers are holding
30781:     // pointers to them.... We should switch all callers to framelists, then
30781:     // audit and do that.
30781:     return NS_ERROR_OUT_OF_MEMORY;
30781:   }
30781: 
39965:   aPresContext->PropertyTable()->Set(this, OverflowProperty(), newList);
39965:   return NS_OK;
30781: }
30781: 
 4006: nsFrameList*
 4006: nsContainerFrame::GetPropTableFrames(nsPresContext*                 aPresContext,
39965:                                      const FramePropertyDescriptor* aProperty) const
 4006: {
39965:   FramePropertyTable* propTable = aPresContext->PropertyTable();
39965:   return static_cast<nsFrameList*>(propTable->Get(this, aProperty));
 4006: }
 4006: 
 4006: nsFrameList*
 4006: nsContainerFrame::RemovePropTableFrames(nsPresContext*                 aPresContext,
39965:                                         const FramePropertyDescriptor* aProperty)
 4006: {
39965:   FramePropertyTable* propTable = aPresContext->PropertyTable();
39965:   return static_cast<nsFrameList*>(propTable->Remove(this, aProperty));
 4006: }
 4006: 
 4006: PRBool
 4006: nsContainerFrame::RemovePropTableFrame(nsPresContext*                 aPresContext,
 4006:                                        nsIFrame*                      aFrame,
39965:                                        const FramePropertyDescriptor* aProperty)
 4006: {
39965:   nsFrameList* frameList = RemovePropTableFrames(aPresContext, aProperty);
 9422:   if (!frameList) {
 9422:     // No such list
 9422:     return PR_FALSE;
 9422:   }
32844:   if (!frameList->RemoveFrameIfPresent(aFrame)) {
 9422:     // Found list, but it doesn't have the frame. Put list back.
39965:     SetPropTableFrames(aPresContext, frameList, aProperty);
 4006:     return PR_FALSE;
 4006:   }
 4006: 
 4006:   if (frameList->IsEmpty()) {
 4006:     // Removed frame and now list is empty. Delete it.
 4006:     delete frameList;
 4006:   }
 4006:   else {
 4006:     // Removed frame, but list not empty. Put it back.
39965:     SetPropTableFrames(aPresContext, frameList, aProperty);
 4006:   }
 4006:   return PR_TRUE;
 4006: }
 4006: 
 4006: nsresult
 4006: nsContainerFrame::SetPropTableFrames(nsPresContext*                 aPresContext,
 4006:                                      nsFrameList*                   aFrameList,
39965:                                      const FramePropertyDescriptor* aProperty)
 4006: {
39965:   NS_PRECONDITION(aPresContext && aProperty && aFrameList, "null ptr");
40719:   NS_PRECONDITION(
40719:     (aProperty != nsContainerFrame::OverflowContainersProperty() &&
40719:      aProperty != nsContainerFrame::ExcessOverflowContainersProperty()) ||
40719:     IsFrameOfType(nsIFrame::eCanContainOverflowContainers),
40719:     "this type of frame can't have overflow containers");
39965:   aPresContext->PropertyTable()->Set(this, aProperty, aFrameList);
39965:   return NS_OK;
 4006: }
 4006: 
    1: /**
    1:  * Push aFromChild and its next siblings to the next-in-flow. Change the
    1:  * geometric parent of each frame that's pushed. If there is no next-in-flow
    1:  * the frames are placed on the overflow list (and the geometric parent is
    1:  * left unchanged).
    1:  *
    1:  * Updates the next-in-flow's child count. Does <b>not</b> update the
    1:  * pusher's child count.
    1:  *
    1:  * @param   aFromChild the first child frame to push. It is disconnected from
    1:  *            aPrevSibling
    1:  * @param   aPrevSibling aFromChild's previous sibling. Must not be null. It's
    1:  *            an error to push a parent's first child frame
    1:  */
    1: void
    1: nsContainerFrame::PushChildren(nsPresContext* aPresContext,
    1:                                nsIFrame*       aFromChild,
    1:                                nsIFrame*       aPrevSibling)
    1: {
32841:   NS_PRECONDITION(aFromChild, "null pointer");
32841:   NS_PRECONDITION(aPrevSibling, "pushing first child");
    1:   NS_PRECONDITION(aPrevSibling->GetNextSibling() == aFromChild, "bad prev sibling");
    1: 
    1:   // Disconnect aFromChild from its previous sibling
32841:   nsFrameList tail = mFrames.RemoveFramesAfter(aPrevSibling);
    1: 
32841:   nsContainerFrame* nextInFlow =
32841:     static_cast<nsContainerFrame*>(GetNextInFlow());
32841:   if (nextInFlow) {
    1:     // XXX This is not a very good thing to do. If it gets removed
    1:     // then remove the copy of this routine that doesn't do this from
    1:     // nsInlineFrame.
    1:     // When pushing and pulling frames we need to check for whether any
    1:     // views need to be reparented.
    1:     for (nsIFrame* f = aFromChild; f; f = f->GetNextSibling()) {
    1:       nsHTMLContainerFrame::ReparentFrameView(aPresContext, f, this, nextInFlow);
    1:     }
32841:     nextInFlow->mFrames.InsertFrames(nextInFlow, nsnull, tail);
    1:   }
    1:   else {
    1:     // Add the frames to our overflow list
32846:     SetOverflowFrames(aPresContext, tail);
    1:   }
    1: }
    1: 
    1: /**
    1:  * Moves any frames on the overflow lists (the prev-in-flow's overflow list and
    1:  * the receiver's overflow list) to the child list.
    1:  *
    1:  * Updates this frame's child count and content mapping.
    1:  *
    1:  * @return  PR_TRUE if any frames were moved and PR_FALSE otherwise
    1:  */
    1: PRBool
    1: nsContainerFrame::MoveOverflowToChildList(nsPresContext* aPresContext)
    1: {
    1:   PRBool result = PR_FALSE;
    1: 
    1:   // Check for an overflow list with our prev-in-flow
    1:   nsContainerFrame* prevInFlow = (nsContainerFrame*)GetPrevInFlow();
    1:   if (nsnull != prevInFlow) {
30781:     nsAutoPtr<nsFrameList> prevOverflowFrames(prevInFlow->StealOverflowFrames());
    1:     if (prevOverflowFrames) {
30781:       // Tables are special; they can have repeated header/footer
30781:       // frames on mFrames at this point.
30781:       NS_ASSERTION(mFrames.IsEmpty() || GetType() == nsGkAtoms::tableFrame,
30781:                    "bad overflow list");
    1:       // When pushing and pulling frames we need to check for whether any
    1:       // views need to be reparented.
30781:       nsHTMLContainerFrame::ReparentFrameViewList(aPresContext,
30781:                                                   *prevOverflowFrames,
30781:                                                   prevInFlow, this);
30781:       mFrames.AppendFrames(this, *prevOverflowFrames);
    1:       result = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   // It's also possible that we have an overflow list for ourselves
30781:   nsAutoPtr<nsFrameList> overflowFrames(StealOverflowFrames());
    1:   if (overflowFrames) {
    1:     NS_ASSERTION(mFrames.NotEmpty(), "overflow list w/o frames");
30781:     mFrames.AppendFrames(nsnull, *overflowFrames);
    1:     result = PR_TRUE;
    1:   }
    1:   return result;
    1: }
    1: 
 4006: nsOverflowContinuationTracker::nsOverflowContinuationTracker(nsPresContext*    aPresContext,
 4006:                                                              nsContainerFrame* aFrame,
 6521:                                                              PRBool            aWalkOOFFrames,
 4006:                                                              PRBool            aSkipOverflowContainerChildren)
 4006:   : mOverflowContList(nsnull),
 4006:     mPrevOverflowCont(nsnull),
 4006:     mSentry(nsnull),
 4006:     mParent(aFrame),
 6521:     mSkipOverflowContainerChildren(aSkipOverflowContainerChildren),
 6521:     mWalkOOFFrames(aWalkOOFFrames)
 4006: {
 4006:   NS_PRECONDITION(aFrame, "null frame pointer");
 4006:   nsContainerFrame* next = static_cast<nsContainerFrame*>
 4006:                              (aFrame->GetNextInFlow());
 4006:   if (next) {
39965:     mOverflowContList = next->GetPropTableFrames(aPresContext,
39965:       nsContainerFrame::OverflowContainersProperty());
 4006:     if (mOverflowContList) {
 4006:       mParent = next;
 4006:       SetUpListWalker();
 4006:     }
 4006:   }
 6758:   if (!mOverflowContList) {
39965:     mOverflowContList = mParent->GetPropTableFrames(aPresContext,
39965:       nsContainerFrame::ExcessOverflowContainersProperty());
 4006:     if (mOverflowContList) {
 4006:       SetUpListWalker();
 4006:     }
 4006:   }
 4006: }
 4006: 
 4006: /**
 4006:  * Helper function to walk past overflow continuations whose prev-in-flow
 4006:  * isn't a normal child and to set mSentry and mPrevOverflowCont correctly.
 4006:  */
 4006: void
 4006: nsOverflowContinuationTracker::SetUpListWalker()
 4006: {
 4006:   NS_ASSERTION(!mSentry && !mPrevOverflowCont,
 4006:                "forgot to reset mSentry or mPrevOverflowCont");
 4006:   if (mOverflowContList) {
 4006:     nsIFrame* cur = mOverflowContList->FirstChild();
 4006:     if (mSkipOverflowContainerChildren) {
 4006:       while (cur && (cur->GetPrevInFlow()->GetStateBits()
 4006:                      & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
 4006:         mPrevOverflowCont = cur;
 4006:         cur = cur->GetNextSibling();
 4006:       }
 8531:       while (cur && (!(cur->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 8531:                      == mWalkOOFFrames)) {
 6521:         mPrevOverflowCont = cur;
 6521:         cur = cur->GetNextSibling();
 6521:       }
 4006:     }
 4006:     if (cur) {
 4006:       mSentry = cur->GetPrevInFlow();
 4006:     }
 4006:   }
 4006: }
 4006: 
 4006: /**
 4006:  * Helper function to step forward through the overflow continuations list.
 6521:  * Sets mSentry and mPrevOverflowCont, skipping over OOF or non-OOF frames
 6521:  * as appropriate. May only be called when we have already set up an
 6521:  * mOverflowContList; mOverflowContList cannot be null.
 4006:  */
 4006: void
 4006: nsOverflowContinuationTracker::StepForward()
 4006: {
 4006:   NS_PRECONDITION(mOverflowContList, "null list");
 4006: 
 4006:   // Step forward
 4006:   if (mPrevOverflowCont) {
 4006:     mPrevOverflowCont = mPrevOverflowCont->GetNextSibling();
 4006:   }
 4006:   else {
 4006:     mPrevOverflowCont = mOverflowContList->FirstChild();
 4006:   }
 4006: 
 6521:   // Skip over oof or non-oof frames as appropriate
 6521:   if (mSkipOverflowContainerChildren) {
 6521:     nsIFrame* cur = mPrevOverflowCont->GetNextSibling();
 8531:     while (cur && (!(cur->GetStateBits() & NS_FRAME_OUT_OF_FLOW)
 8531:                    == mWalkOOFFrames)) {
 6521:       mPrevOverflowCont = cur;
 6521:       cur = cur->GetNextSibling();
 6521:     }
 6521:   }
 6521: 
 4006:   // Set up the sentry
 4006:   mSentry = (mPrevOverflowCont->GetNextSibling())
 4006:             ? mPrevOverflowCont->GetNextSibling()->GetPrevInFlow()
 4006:             : nsnull;
 4006: }
 4006: 
 4006: nsresult
 4006: nsOverflowContinuationTracker::Insert(nsIFrame*       aOverflowCont,
 4006:                                       nsReflowStatus& aReflowStatus)
 4006: {
 4006:   NS_PRECONDITION(aOverflowCont, "null frame pointer");
 8531:   NS_PRECONDITION(!mSkipOverflowContainerChildren || mWalkOOFFrames ==
 8531:                   !!(aOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW),
 8531:                   "shouldn't insert frame that doesn't match walker type");
 4006:   NS_PRECONDITION(aOverflowCont->GetPrevInFlow(),
 4006:                   "overflow containers must have a prev-in-flow");
 4006:   nsresult rv = NS_OK;
18883:   PRBool convertedToOverflowContainer = PR_FALSE;
18883:   nsPresContext* presContext = aOverflowCont->PresContext();
 4006:   if (!mSentry || aOverflowCont != mSentry->GetNextInFlow()) {
 4006:     // Not in our list, so we need to add it
 8049:     if (aOverflowCont->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER) {
 8049:       // aOverflowCont is in some other overflow container list,
 4006:       // steal it first
 8049:       NS_ASSERTION(!(mOverflowContList &&
 8049:                      mOverflowContList->ContainsFrame(aOverflowCont)),
 8049:                    "overflow containers out of order");
 4006:       rv = static_cast<nsContainerFrame*>(aOverflowCont->GetParent())
 4006:              ->StealFrame(presContext, aOverflowCont);
 4006:       NS_ENSURE_SUCCESS(rv, rv);
 4006:     }
 4006:     else {
 4006:       aOverflowCont->AddStateBits(NS_FRAME_IS_OVERFLOW_CONTAINER);
18883:       convertedToOverflowContainer = PR_TRUE;
 4006:     }
 4006:     if (!mOverflowContList) {
 4006:       mOverflowContList = new nsFrameList();
39965:       rv = mParent->SetPropTableFrames(presContext, mOverflowContList,
39965:         nsContainerFrame::ExcessOverflowContainersProperty());
 4006:       NS_ENSURE_SUCCESS(rv, rv);
 4006:       SetUpListWalker();
 4006:     }
 4006:     if (aOverflowCont->GetParent() != mParent) {
 4006:       nsHTMLContainerFrame::ReparentFrameView(presContext, aOverflowCont,
 4006:                                               aOverflowCont->GetParent(),
 4006:                                               mParent);
 4006:     }
 4006:     mOverflowContList->InsertFrame(mParent, mPrevOverflowCont, aOverflowCont);
 4006:     aReflowStatus |= NS_FRAME_REFLOW_NEXTINFLOW;
 4006:   }
 4006: 
 4006:   // If we need to reflow it, mark it dirty
 4006:   if (aReflowStatus & NS_FRAME_REFLOW_NEXTINFLOW)
 4006:     aOverflowCont->AddStateBits(NS_FRAME_IS_DIRTY);
 4006: 
 4006:   // It's in our list, just step forward
 4006:   StepForward();
 8531:   NS_ASSERTION(mPrevOverflowCont == aOverflowCont ||
 8531:                (mSkipOverflowContainerChildren &&
 8531:                 (mPrevOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW) !=
 8531:                 (aOverflowCont->GetStateBits() & NS_FRAME_OUT_OF_FLOW)),
 8531:               "OverflowContTracker in unexpected state");
18883: 
18883:   if (convertedToOverflowContainer) {
18883:     // Convert all non-overflow-container continuations of aOverflowCont
18883:     // into overflow containers and move them to our overflow
18883:     // tracker. This preserves the invariant that the next-continuations
18883:     // of an overflow container are also overflow containers.
18883:     nsIFrame* f = aOverflowCont->GetNextContinuation();
18883:     if (f && !(f->GetStateBits() & NS_FRAME_IS_OVERFLOW_CONTAINER)) {
18883:       nsContainerFrame* parent = static_cast<nsContainerFrame*>(f->GetParent());
18883:       rv = parent->StealFrame(presContext, f);
18883:       NS_ENSURE_SUCCESS(rv, rv);
18883:       Insert(f, aReflowStatus);
18883:     }
18883:   }
 4006:   return rv;
 4006: }
 4006: 
 4006: void
 4006: nsOverflowContinuationTracker::Finish(nsIFrame* aChild)
 4006: {
 4006:   NS_PRECONDITION(aChild, "null ptr");
 4006:   NS_PRECONDITION(aChild->GetNextInFlow(),
 6521:                 "supposed to call Finish *before* deleting next-in-flow!");
18883: 
18883:   for (nsIFrame* f = aChild; f; f = f->GetNextInFlow()) {
42242:     // Make sure we drop all references if the only frame
42242:     // in the overflow containers list is about to be destroyed
42242:     if (mOverflowContList &&
42242:         mOverflowContList->FirstChild() == f->GetNextInFlow() &&
42242:         !f->GetNextInFlow()->GetNextSibling()) {
 4006:       mOverflowContList = nsnull;
 4006:       mPrevOverflowCont = nsnull;
 4006:       mSentry = nsnull;
18883:       mParent = static_cast<nsContainerFrame*>(f->GetParent());
18883:       break;
 4006:     }
42242:     if (f == mSentry) {
 8531:       // Step past aChild
 6521:       nsIFrame* prevOverflowCont = mPrevOverflowCont;
 6521:       StepForward();
18883:       if (mPrevOverflowCont == f->GetNextInFlow()) {
 8531:         // Pull mPrevOverflowChild back to aChild's prevSibling:
 8531:         // aChild will be removed from our list by our caller
 6521:         mPrevOverflowCont = prevOverflowCont;
 4006:       }
 4006:     }
 4006:   }
 8531: }
 4006: 
    1: /////////////////////////////////////////////////////////////////////////////
    1: // Debugging
    1: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
    1: nsContainerFrame::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   IndentBy(out, aIndent);
    1:   ListTag(out);
    1: #ifdef DEBUG_waterson
 3233:   fprintf(out, " [parent=%p]", static_cast<void*>(mParent));
    1: #endif
    1:   if (HasView()) {
 3233:     fprintf(out, " [view=%p]", static_cast<void*>(GetView()));
    1:   }
32845:   if (GetNextSibling()) {
32845:     fprintf(out, " next=%p", static_cast<void*>(GetNextSibling()));
    1:   }
    1:   if (nsnull != GetPrevContinuation()) {
 3233:     fprintf(out, " prev-continuation=%p", static_cast<void*>(GetPrevContinuation()));
    1:   }
    1:   if (nsnull != GetNextContinuation()) {
 3233:     fprintf(out, " next-continuation=%p", static_cast<void*>(GetNextContinuation()));
    1:   }
39965:   void* IBsibling = Properties().Get(IBSplitSpecialSibling());
34444:   if (IBsibling) {
34444:     fprintf(out, " IBSplitSpecialSibling=%p", IBsibling);
34444:   }
39965:   void* IBprevsibling = Properties().Get(IBSplitSpecialPrevSibling());
34444:   if (IBprevsibling) {
34444:     fprintf(out, " IBSplitSpecialPrevSibling=%p", IBprevsibling);
34444:   }
    1:   fprintf(out, " {%d,%d,%d,%d}", mRect.x, mRect.y, mRect.width, mRect.height);
    1:   if (0 != mState) {
43479:     fprintf(out, " [state=%016llx]", mState);
    1:   }
 3233:   fprintf(out, " [content=%p]", static_cast<void*>(mContent));
 3233:   nsContainerFrame* f = const_cast<nsContainerFrame*>(this);
55040:   if (f->HasOverflowAreas()) {
55040:     nsRect overflowArea = f->GetVisualOverflowRect();
55040:     fprintf(out, " [vis-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
55040:             overflowArea.width, overflowArea.height);
55040:     overflowArea = f->GetScrollableOverflowRect();
55040:     fprintf(out, " [scr-overflow=%d,%d,%d,%d]", overflowArea.x, overflowArea.y,
11909:             overflowArea.width, overflowArea.height);
    1:   }
 3233:   fprintf(out, " [sc=%p]", static_cast<void*>(mStyleContext));
34387:   nsIAtom* pseudoTag = mStyleContext->GetPseudo();
    1:   if (pseudoTag) {
    1:     nsAutoString atomString;
    1:     pseudoTag->ToString(atomString);
    1:     fprintf(out, " pst=%s",
    1:             NS_LossyConvertUTF16toASCII(atomString).get());
    1:   }
    1: 
    1:   // Output the children
    1:   nsIAtom* listName = nsnull;
    1:   PRInt32 listIndex = 0;
    1:   PRBool outputOneList = PR_FALSE;
    1:   do {
    1:     nsIFrame* kid = GetFirstChild(listName);
    1:     if (nsnull != kid) {
    1:       if (outputOneList) {
    1:         IndentBy(out, aIndent);
    1:       }
    1:       outputOneList = PR_TRUE;
    1:       nsAutoString tmp;
    1:       if (nsnull != listName) {
    1:         listName->ToString(tmp);
    1:         fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
    1:       }
    1:       fputs("<\n", out);
    1:       while (nsnull != kid) {
    1:         // Verify the child frame's parent frame pointer is correct
    1:         NS_ASSERTION(kid->GetParent() == (nsIFrame*)this, "bad parent frame pointer");
    1: 
    1:         // Have the child frame list
31709:         kid->List(out, aIndent + 1);
    1:         kid = kid->GetNextSibling();
    1:       }
    1:       IndentBy(out, aIndent);
    1:       fputs(">\n", out);
    1:     }
    1:     listName = GetAdditionalChildListName(listIndex++);
    1:   } while(nsnull != listName);
    1: 
    1:   if (!outputOneList) {
    1:     fputs("<>\n", out);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: #endif
