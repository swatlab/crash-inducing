     1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /* Wrapper object for reflecting native xpcom objects into JavaScript. */
     1: 
     1: #include "xpcprivate.h"
     1: #include "nsCRT.h"
  4042: #include "XPCWrapper.h"
 80074: #include "nsWrapperCacheInlines.h"
 80384: #include "XPCLog.h"
 48124: #include "nsINode.h"
 80384: #include "XPCQuickStubs.h"
 55599: #include "jsproxy.h"
 55604: #include "AccessCheck.h"
 55659: #include "WrapperFactory.h"
101166: #include "XrayWrapper.h"
 80067: #include "dombindings.h"
     1: 
 91687: #include "nsContentUtils.h"
 91687: 
 95340: #include "mozilla/StandardInteger.h"
 82481: #include "mozilla/Util.h"
 82481: 
 99328: using namespace xpc;
 99328: 
 63538: bool
 63538: xpc_OkToHandOutWrapper(nsWrapperCache *cache)
 63538: {
 63538:     NS_ABORT_IF_FALSE(cache->GetWrapper(), "Must have wrapper");
 93879:     NS_ABORT_IF_FALSE(cache->IsDOMBinding() || IS_WN_WRAPPER(cache->GetWrapper()),
 63538:                       "Must have proxy or XPCWrappedNative wrapper");
 93879:     return cache->IsDOMBinding() ?
 80092:         mozilla::dom::binding::instanceIsProxy(cache->GetWrapper()) :
 63538:         !static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(cache->GetWrapper()))->
 80088:             NeedsSOW();
 63538: }
 63538: 
     1: /***************************************************************************/
     1: 
     1: NS_IMPL_CYCLE_COLLECTION_CLASS(XPCWrappedNative)
     1: 
     1: NS_IMETHODIMP
102293: NS_CYCLE_COLLECTION_CLASSNAME(XPCWrappedNative)::UnlinkImpl(void *p)
 12418: {
 12418:     XPCWrappedNative *tmp = static_cast<XPCWrappedNative*>(p);
 12418:     tmp->ExpireWrapper();
 12418:     return NS_OK;
 12418: }
 12418: 
 12418: NS_IMETHODIMP
102293: NS_CYCLE_COLLECTION_CLASSNAME(XPCWrappedNative)::TraverseImpl
102293:    (NS_CYCLE_COLLECTION_CLASSNAME(XPCWrappedNative) *that, void *p,
     1:     nsCycleCollectionTraversalCallback &cb)
     1: {
  3233:     XPCWrappedNative *tmp = static_cast<XPCWrappedNative*>(p);
     1:     if (!tmp->IsValid())
     1:         return NS_OK;
     1: 
 30096:     if (NS_UNLIKELY(cb.WantDebugInfo())) {
     1:         char name[72];
     1:         XPCNativeScriptableInfo* si = tmp->GetScriptableInfo();
     1:         if (si)
     1:             JS_snprintf(name, sizeof(name), "XPCWrappedNative (%s)",
     1:                         si->GetJSClass()->name);
     1:         else
     1:             JS_snprintf(name, sizeof(name), "XPCWrappedNative");
     1: 
 72420:         cb.DescribeRefCountedNode(tmp->mRefCnt.get(),
 30096:                                   sizeof(XPCWrappedNative), name);
 30096:     } else {
 72420:         NS_IMPL_CYCLE_COLLECTION_DESCRIBE(XPCWrappedNative, tmp->mRefCnt.get())
 30096:     }
     1: 
     1:     if (tmp->mRefCnt.get() > 1) {
     1: 
     1:         // If our refcount is > 1, our reference to the flat JS object is
     1:         // considered "strong", and we're going to traverse it.
     1:         //
     1:         // If our refcount is <= 1, our reference to the flat JS object is
     1:         // considered "weak", and we're *not* going to traverse it.
     1:         //
     1:         // This reasoning is in line with the slightly confusing lifecycle rules
     1:         // for XPCWrappedNatives, described in a larger comment below and also
     1:         // on our wiki at http://wiki.mozilla.org/XPConnect_object_wrapping
     1: 
 62690:         JSObject *obj = tmp->GetFlatJSObjectPreserveColor();
 67684:         NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mFlatJSObject");
 97523:         cb.NoteJSChild(obj);
     1:     }
     1: 
     1:     // XPCWrappedNative keeps its native object alive.
 67684:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mIdentity");
     1:     cb.NoteXPCOMChild(tmp->GetIdentityObject());
     1: 
  7286:     tmp->NoteTearoffs(cb);
  7286: 
     1:     return NS_OK;
     1: }
     1: 
  7286: void
  7286: XPCWrappedNative::NoteTearoffs(nsCycleCollectionTraversalCallback& cb)
     1: {
  7286:     // Tearoffs hold their native object alive. If their JS object hasn't been
  7286:     // finalized yet we'll note the edge between the JS object and the native
  7286:     // (see nsXPConnect::Traverse), but if their JS object has been finalized
  7286:     // then the tearoff is only reachable through the XPCWrappedNative, so we
  7286:     // record an edge here.
  7286:     XPCWrappedNativeTearOffChunk* chunk;
 80389:     for (chunk = &mFirstChunk; chunk; chunk = chunk->mNextChunk) {
  7286:         XPCWrappedNativeTearOff* to = chunk->mTearOffs;
 80389:         for (int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK-1; i >= 0; i--, to++) {
 89966:             JSObject* jso = to->GetJSObjectPreserveColor();
 80389:             if (!jso) {
 67684:                 NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "tearoff's mNative");
  7286:                 cb.NoteXPCOMChild(to->GetNative());
     1:             }
  7286:         }
  7286:     }
  7286: }
  7286: 
     1: #ifdef XPC_CHECK_CLASSINFO_CLAIMS
     1: static void DEBUG_CheckClassInfoClaims(XPCWrappedNative* wrapper);
     1: #else
     1: #define DEBUG_CheckClassInfoClaims(wrapper) ((void)0)
     1: #endif
     1: 
     1: #ifdef XPC_TRACK_WRAPPER_STATS
     1: static int DEBUG_TotalWrappedNativeCount;
     1: static int DEBUG_TotalLiveWrappedNativeCount;
     1: static int DEBUG_TotalMaxWrappedNativeCount;
     1: static int DEBUG_WrappedNativeWithProtoCount;
     1: static int DEBUG_LiveWrappedNativeWithProtoCount;
     1: static int DEBUG_MaxWrappedNativeWithProtoCount;
     1: static int DEBUG_WrappedNativeNoProtoCount;
     1: static int DEBUG_LiveWrappedNativeNoProtoCount;
     1: static int DEBUG_MaxWrappedNativeNoProtoCount;
     1: static int DEBUG_WrappedNativeTotalCalls;
     1: static int DEBUG_WrappedNativeMethodCalls;
     1: static int DEBUG_WrappedNativeGetterCalls;
     1: static int DEBUG_WrappedNativeSetterCalls;
     1: #define DEBUG_CHUNKS_TO_COUNT 4
     1: static int DEBUG_WrappedNativeTearOffChunkCounts[DEBUG_CHUNKS_TO_COUNT+1];
 79445: static bool    DEBUG_DumpedWrapperStats;
     1: #endif
     1: 
     1: #ifdef DEBUG
     1: static void DEBUG_TrackNewWrapper(XPCWrappedNative* wrapper)
     1: {
     1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
     1:     if (wrapper->GetRuntime())
     1:         wrapper->GetRuntime()->DEBUG_AddWrappedNative(wrapper);
     1:     else
     1:         NS_ERROR("failed to add wrapper");
     1: #endif
     1: #ifdef XPC_TRACK_WRAPPER_STATS
     1:     DEBUG_TotalWrappedNativeCount++;
     1:     DEBUG_TotalLiveWrappedNativeCount++;
     1:     if (DEBUG_TotalMaxWrappedNativeCount < DEBUG_TotalLiveWrappedNativeCount)
     1:         DEBUG_TotalMaxWrappedNativeCount = DEBUG_TotalLiveWrappedNativeCount;
     1: 
 80389:     if (wrapper->HasProto()) {
     1:         DEBUG_WrappedNativeWithProtoCount++;
     1:         DEBUG_LiveWrappedNativeWithProtoCount++;
     1:         if (DEBUG_MaxWrappedNativeWithProtoCount < DEBUG_LiveWrappedNativeWithProtoCount)
     1:             DEBUG_MaxWrappedNativeWithProtoCount = DEBUG_LiveWrappedNativeWithProtoCount;
 80390:     } else {
     1:         DEBUG_WrappedNativeNoProtoCount++;
     1:         DEBUG_LiveWrappedNativeNoProtoCount++;
     1:         if (DEBUG_MaxWrappedNativeNoProtoCount < DEBUG_LiveWrappedNativeNoProtoCount)
     1:             DEBUG_MaxWrappedNativeNoProtoCount = DEBUG_LiveWrappedNativeNoProtoCount;
     1:     }
     1: #endif
     1: }
     1: 
     1: static void DEBUG_TrackDeleteWrapper(XPCWrappedNative* wrapper)
     1: {
     1: #ifdef XPC_CHECK_WRAPPERS_AT_SHUTDOWN
 20312:     nsXPConnect::GetRuntimeInstance()->DEBUG_RemoveWrappedNative(wrapper);
     1: #endif
     1: #ifdef XPC_TRACK_WRAPPER_STATS
     1:     DEBUG_TotalLiveWrappedNativeCount--;
     1:     if (wrapper->HasProto())
     1:         DEBUG_LiveWrappedNativeWithProtoCount--;
     1:     else
     1:         DEBUG_LiveWrappedNativeNoProtoCount--;
     1: 
     1:     int extraChunkCount = wrapper->DEBUG_CountOfTearoffChunks() - 1;
     1:     if (extraChunkCount > DEBUG_CHUNKS_TO_COUNT)
     1:         extraChunkCount = DEBUG_CHUNKS_TO_COUNT;
     1:     DEBUG_WrappedNativeTearOffChunkCounts[extraChunkCount]++;
     1: #endif
     1: }
     1: static void DEBUG_TrackWrapperCall(XPCWrappedNative* wrapper,
     1:                                    XPCWrappedNative::CallMode mode)
     1: {
     1: #ifdef XPC_TRACK_WRAPPER_STATS
     1:     DEBUG_WrappedNativeTotalCalls++;
 80389:     switch (mode) {
     1:         case XPCWrappedNative::CALL_METHOD:
     1:             DEBUG_WrappedNativeMethodCalls++;
     1:             break;
     1:         case XPCWrappedNative::CALL_GETTER:
     1:             DEBUG_WrappedNativeGetterCalls++;
     1:             break;
     1:         case XPCWrappedNative::CALL_SETTER:
     1:             DEBUG_WrappedNativeSetterCalls++;
     1:             break;
     1:         default:
     1:             NS_ERROR("bad value");
     1:     }
     1: #endif
     1: }
     1: 
     1: static void DEBUG_TrackShutdownWrapper(XPCWrappedNative* wrapper)
     1: {
     1: #ifdef XPC_TRACK_WRAPPER_STATS
 80389:     if (!DEBUG_DumpedWrapperStats) {
 80486:         DEBUG_DumpedWrapperStats = true;
     1:         printf("%d WrappedNatives were constructed. "
     1:                "(%d w/ protos, %d w/o)\n",
     1:                DEBUG_TotalWrappedNativeCount,
     1:                DEBUG_WrappedNativeWithProtoCount,
     1:                DEBUG_WrappedNativeNoProtoCount);
     1: 
     1:         printf("%d WrappedNatives max alive at one time. "
     1:                "(%d w/ protos, %d w/o)\n",
     1:                DEBUG_TotalMaxWrappedNativeCount,
     1:                DEBUG_MaxWrappedNativeWithProtoCount,
     1:                DEBUG_MaxWrappedNativeNoProtoCount);
     1: 
     1:         printf("%d WrappedNatives alive now. "
     1:                "(%d w/ protos, %d w/o)\n",
     1:                DEBUG_TotalLiveWrappedNativeCount,
     1:                DEBUG_LiveWrappedNativeWithProtoCount,
     1:                DEBUG_LiveWrappedNativeNoProtoCount);
     1: 
     1:         printf("%d calls to WrappedNatives. "
     1:                "(%d methods, %d getters, %d setters)\n",
     1:                DEBUG_WrappedNativeTotalCalls,
     1:                DEBUG_WrappedNativeMethodCalls,
     1:                DEBUG_WrappedNativeGetterCalls,
     1:                DEBUG_WrappedNativeSetterCalls);
     1: 
     1:         printf("(wrappers / tearoffs): (");
     1:         int i;
 80389:         for (i = 0; i < DEBUG_CHUNKS_TO_COUNT; i++) {
     1:             printf("%d / %d, ",
     1:                    DEBUG_WrappedNativeTearOffChunkCounts[i],
     1:                    (i+1) * XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK);
     1:         }
     1:         printf("%d / more)\n", DEBUG_WrappedNativeTearOffChunkCounts[i]);
     1:     }
     1: #endif
     1: }
     1: #else
     1: #define DEBUG_TrackNewWrapper(wrapper) ((void)0)
     1: #define DEBUG_TrackDeleteWrapper(wrapper) ((void)0)
     1: #define DEBUG_TrackWrapperCall(wrapper, mode) ((void)0)
     1: #define DEBUG_TrackShutdownWrapper(wrapper) ((void)0)
     1: #endif
     1: 
     1: /***************************************************************************/
 30001: static nsresult
 30001: FinishCreate(XPCCallContext& ccx,
 30001:              XPCWrappedNativeScope* Scope,
 30001:              XPCNativeInterface* Interface,
 30001:              nsWrapperCache *cache,
 91581:              XPCWrappedNative* inWrapper,
 30001:              XPCWrappedNative** resultWrapper);
     1: 
     1: // static
 91588: //
 91588: // This method handles the special case of wrapping a new global object.
 91588: //
 91588: // The normal code path for wrapping natives goes through
 91588: // XPCConvert::NativeInterface2JSObject, XPCWrappedNative::GetNewOrUsed,
 91588: // and finally into XPCWrappedNative::Init. Unfortunately, this path assumes
 91588: // very early on that we have an XPCWrappedNativeScope and corresponding global
 91588: // JS object, which are the very things we need to create here. So we special-
 91588: // case the logic and do some things in a different order.
 91588: nsresult
 91588: XPCWrappedNative::WrapNewGlobal(XPCCallContext &ccx, xpcObjectHelper &nativeHelper,
 91588:                                 nsIPrincipal *principal, bool initStandardClasses,
 91588:                                 XPCWrappedNative **wrappedGlobal)
 91588: {
 91588:     bool success;
 91588:     nsresult rv;
 91588:     nsISupports *identity = nativeHelper.GetCanonical();
 91588: 
 91588:     // The object should specify that it's meant to be global.
 91588:     MOZ_ASSERT(nativeHelper.GetScriptableFlags() & nsIXPCScriptable::IS_GLOBAL_OBJECT);
 91588: 
 91588:     // We shouldn't be reusing globals.
 91588:     MOZ_ASSERT(!nativeHelper.GetWrapperCache() ||
 91588:                !nativeHelper.GetWrapperCache()->GetWrapperPreserveColor());
 91588: 
 91588:     // Put together the ScriptableCreateInfo...
 91588:     XPCNativeScriptableCreateInfo sciProto;
 91588:     XPCNativeScriptableCreateInfo sciMaybe;
 91588:     const XPCNativeScriptableCreateInfo& sciWrapper =
 91588:         GatherScriptableCreateInfo(identity, nativeHelper.GetClassInfo(),
 91588:                                    sciProto, sciMaybe);
 91588: 
 91588:     // ...and then ScriptableInfo. We need all this stuff now because it's going
 91588:     // to tell us the JSClass of the object we're going to create.
 98022:     AutoMarkingNativeScriptableInfoPtr
 98022:         si(ccx, XPCNativeScriptableInfo::Construct(ccx, &sciWrapper));
 98022:     MOZ_ASSERT(si.get());
 91588: 
 91588:     // Finally, we get to the JSClass.
 91588:     JSClass *clasp = si->GetJSClass();
 91588:     MOZ_ASSERT(clasp->flags & JSCLASS_IS_GLOBAL);
 91588: 
 91588:     // Create the global.
 91588:     JSObject *global;
 91588:     JSCompartment *compartment;
 91588:     rv = xpc_CreateGlobalObject(ccx, clasp, principal, nsnull, false,
 91588:                                 &global, &compartment);
 91588:     NS_ENSURE_SUCCESS(rv, rv);
 91588: 
 91588:     // Immediately enter the global's compartment, so that everything else we
 91588:     // create ends up there.
 91588:     JSAutoEnterCompartment ac;
 91588:     success = ac.enter(ccx, global);
 91588:     MOZ_ASSERT(success);
 91588: 
 91588:     // If requested, immediately initialize the standard classes on the global.
 91588:     // We need to do this before creating a scope, because
 91588:     // XPCWrappedNativeScope::SetGlobal resolves |Object| via
 91588:     // JS_ResolveStandardClass. JS_InitStandardClasses asserts if any of the
 91588:     // standard classes are already initialized, so this is a problem.
 91588:     if (initStandardClasses && ! JS_InitStandardClasses(ccx, global))
 91588:         return NS_ERROR_FAILURE;
 91588: 
 91588:     // Create a scope, but don't do any extra stuff like initializing |Components|.
 91588:     // All of that stuff happens in the caller.
 91588:     XPCWrappedNativeScope *scope = XPCWrappedNativeScope::GetNewOrUsed(ccx, global, identity);
 91588:     MOZ_ASSERT(scope);
 91588: 
 91588:     // Make a proto.
 91588:     XPCWrappedNativeProto *proto =
 91588:         XPCWrappedNativeProto::GetNewOrUsed(ccx, scope, nativeHelper.GetClassInfo(), &sciProto,
 91588:                                             UNKNOWN_OFFSETS, /* callPostCreatePrototype = */ false);
 91588:     if (!proto)
 91588:         return NS_ERROR_FAILURE;
 91588:     proto->CacheOffsets(identity);
 91588: 
 91588:     // Set up the prototype on the global.
 91588:     MOZ_ASSERT(proto->GetJSProtoObject());
 91588:     success = JS_SplicePrototype(ccx, global, proto->GetJSProtoObject());
 91588:     if (!success)
 91588:         return NS_ERROR_FAILURE;
 91588: 
 91588:     // Construct the wrapper.
 91588:     nsRefPtr<XPCWrappedNative> wrapper = new XPCWrappedNative(identity, proto);
 91588: 
 91588:     // The wrapper takes over the strong reference to the native object.
 91588:     nativeHelper.forgetCanonical();
 91588: 
 91588:     //
 91588:     // We don't call ::Init() on this wrapper, because our setup requirements
 91588:     // are different for globals. We do our setup inline here, instead.
 91588:     //
 91588: 
 91588:     // Share mScriptableInfo with the proto.
 91588:     //
 91588:     // This is probably more trouble than it's worth, since we've already created
 91588:     // an XPCNativeScriptableInfo for ourselves. Moreover, most of that class is
 91588:     // shared internally via XPCNativeScriptableInfoShared, so the memory
 91588:     // savings are negligible. Nevertheless, this is what ::Init() does, and we
 91588:     // want to be as consistent as possible with that code.
 91588:     XPCNativeScriptableInfo* siProto = proto->GetScriptableInfo();
 91588:     if (siProto && siProto->GetCallback() == sciWrapper.GetCallback()) {
 91588:         wrapper->mScriptableInfo = siProto;
 91588:         delete si;
 91588:     } else {
 91588:         wrapper->mScriptableInfo = si;
 91588:     }
 91588: 
 91588:     // Set the JS object to the global we already created.
 91588:     wrapper->mFlatJSObject = global;
 91588: 
 91588:     // Set the private to the XPCWrappedNative.
 91588:     JS_SetPrivate(global, wrapper);
 91588: 
 91588:     // There are dire comments elsewhere in the code about how a GC can
 91588:     // happen somewhere after wrapper initialization but before the wrapper is
 91588:     // added to the hashtable in FinishCreate(). It's not clear if that can
 91588:     // happen here, but let's just be safe for now.
 91588:     AutoMarkingWrappedNativePtr wrapperMarker(ccx, wrapper);
 91588: 
 91588:     // Call the common Init finish routine. This mainly just does an AddRef
 91588:     // on behalf of XPConnect (the corresponding Release is in the finalizer
 91588:     // hook), but it does some other miscellaneous things too, so we don't
 91588:     // inline it.
 91588:     success = wrapper->FinishInit(ccx);
 91588:     MOZ_ASSERT(success);
 91588: 
 91588:     // Go through some extra work to find the tearoff. This is kind of silly
 91588:     // on a conceptual level: the point of tearoffs is to cache the results
 91588:     // of QI-ing mIdentity to different interfaces, and we don't need that
 91588:     // since we're dealing with nsISupports. But lots of code expects tearoffs
 91588:     // to exist for everything, so we just follow along.
 91588:     XPCNativeInterface* iface = XPCNativeInterface::GetNewOrUsed(ccx, &NS_GET_IID(nsISupports));
 91588:     MOZ_ASSERT(iface);
 91588:     nsresult status;
 91588:     success = wrapper->FindTearOff(ccx, iface, false, &status);
 91588:     if (!success)
 91588:         return status;
 91588: 
 91588:     // Call the common creation finish routine. This does all of the bookkeeping
 91588:     // like inserting the wrapper into the wrapper map and setting up the wrapper
 91588:     // cache.
 91588:     return FinishCreate(ccx, scope, iface, nativeHelper.GetWrapperCache(),
 91588:                         wrapper, wrappedGlobal);
 91588: }
 91588: 
 91588: // static
     1: nsresult
     1: XPCWrappedNative::GetNewOrUsed(XPCCallContext& ccx,
 51515:                                xpcObjectHelper& helper,
     1:                                XPCWrappedNativeScope* Scope,
     1:                                XPCNativeInterface* Interface,
     1:                                XPCWrappedNative** resultWrapper)
     1: {
 51515:     nsWrapperCache *cache = helper.GetWrapperCache();
 51515: 
 62690:     NS_ASSERTION(!cache || !cache->GetWrapperPreserveColor(),
 26411:                  "We assume the caller already checked if it could get the "
 26411:                  "wrapper from the cache.");
 26411: 
     1:     nsresult rv;
     1: 
     1:     NS_ASSERTION(!Scope->GetRuntime()->GetThreadRunningGC(),
     1:                  "XPCWrappedNative::GetNewOrUsed called during GC");
 51515: 
 72277:     nsISupports *identity = helper.GetCanonical();
     1: 
 80389:     if (!identity) {
     1:         NS_ERROR("This XPCOM object fails in QueryInterface to nsISupports!");
     1:         return NS_ERROR_FAILURE;
     1:     }
     1: 
     1:     XPCLock* mapLock = Scope->GetRuntime()->GetMapLock();
     1: 
 91580:     nsRefPtr<XPCWrappedNative> wrapper;
     1: 
     1:     Native2WrappedNativeMap* map = Scope->GetWrappedNativeMap();
 80389:     if (!cache) {
     1:         {   // scoped lock
     1:             XPCAutoLock lock(mapLock);
     1:             wrapper = map->Find(identity);
     1:         }
     1: 
 80389:         if (wrapper) {
 26411:             if (Interface &&
 82794:                 !wrapper->FindTearOff(ccx, Interface, false, &rv)) {
     1:                 NS_ASSERTION(NS_FAILED(rv), "returning NS_OK on failure");
     1:                 return rv;
     1:             }
 91580:             *resultWrapper = wrapper.forget().get();
     1:             return NS_OK;
     1:         }
 26411:     }
 26411: #ifdef DEBUG
 62690:     else if (!cache->GetWrapperPreserveColor())
 26411:     {   // scoped lock
 26411:         XPCAutoLock lock(mapLock);
 26411:         NS_ASSERTION(!map->Find(identity),
 26411:                      "There's a wrapper in the hashtable but it wasn't cached?");
 26411:     }
 26411: #endif
     1: 
     1:     // There is a chance that the object wants to have the self-same JSObject
     1:     // reflection regardless of the scope into which we are reflecting it.
     1:     // Many DOM objects require this. The scriptable helper specifies this
     1:     // in preCreate by indicating a 'parent' of a particular scope.
     1:     //
     1:     // To handle this we need to get the scriptable helper early and ask it.
     1:     // It is possible that we will then end up forwarding this entire call
     1:     // to this same function but with a different scope.
     1: 
     1:     // If we are making a wrapper for the nsIClassInfo interface then
     1:     // We *don't* want to have it use the prototype meant for instances
     1:     // of that class.
104469:     bool iidIsClassInfo = Interface &&
 22842:                           Interface->GetIID()->Equals(NS_GET_IID(nsIClassInfo));
104469:     PRUint32 classInfoFlags;
104469:     bool isClassInfoSingleton = helper.GetClassInfo() == helper.Object() &&
104469:                                 NS_SUCCEEDED(helper.GetClassInfo()
104469:                                                    ->GetFlags(&classInfoFlags)) &&
104469:                                 (classInfoFlags & nsIClassInfo::SINGLETON_CLASSINFO);
104469:     bool isClassInfo = iidIsClassInfo || isClassInfoSingleton;
     1: 
 51515:     nsIClassInfo *info = helper.GetClassInfo();
     1: 
     1:     XPCNativeScriptableCreateInfo sciProto;
 40489:     XPCNativeScriptableCreateInfo sci;
     1: 
     1:     // Gather scriptable create info if we are wrapping something
     1:     // other than an nsIClassInfo object. We need to not do this for
     1:     // nsIClassInfo objects because often nsIClassInfo implementations
 42263:     // are also nsIXPCScriptable helper implementations, but the helper
     1:     // code is obviously intended for the implementation of the class
     1:     // described by the nsIClassInfo, not for the class info object
     1:     // itself.
 40489:     const XPCNativeScriptableCreateInfo& sciWrapper =
 40489:         isClassInfo ? sci :
 40489:         GatherScriptableCreateInfo(identity, info, sciProto, sci);
     1: 
     1:     JSObject* parent = Scope->GetGlobalJSObject();
     1: 
     1:     jsval newParentVal = JSVAL_NULL;
     1:     XPCMarkableJSVal newParentVal_markable(&newParentVal);
     1:     AutoMarkingJSVal newParentVal_automarker(ccx, &newParentVal_markable);
 82794:     JSBool needsSOW = false;
 82794:     JSBool needsCOW = false;
     1: 
 54733:     JSAutoEnterCompartment ac;
 53565: 
 80389:     if (sciWrapper.GetFlags().WantPreCreate()) {
     1:         JSObject* plannedParent = parent;
     1:         nsresult rv = sciWrapper.GetCallback()->PreCreate(identity, ccx,
     1:                                                           parent, &parent);
     1:         if (NS_FAILED(rv))
     1:             return rv;
     1: 
 47410:         if (rv == NS_SUCCESS_CHROME_ACCESS_ONLY)
 82794:             needsSOW = true;
 27664:         rv = NS_OK;
 27664: 
 55659:         NS_ASSERTION(!xpc::WrapperFactory::IsXrayWrapper(parent),
 55659:                      "Xray wrapper being used to parent XPCWrappedNative?");
     1: 
 55601:         if (!ac.enter(ccx, parent))
 55601:             return NS_ERROR_FAILURE;
 55601: 
 80389:         if (parent != plannedParent) {
     1:             XPCWrappedNativeScope* betterScope =
     1:                 XPCWrappedNativeScope::FindInJSObjectScope(ccx, parent);
     1:             if (betterScope != Scope)
 91578:                 return GetNewOrUsed(ccx, helper, betterScope, Interface, resultWrapper);
     1: 
     1:             newParentVal = OBJECT_TO_JSVAL(parent);
     1:         }
     1: 
     1:         // Take the performance hit of checking the hashtable again in case
     1:         // the preCreate call caused the wrapper to get created through some
     1:         // interesting path (the DOM code tends to make this happen sometimes).
     1: 
 80389:         if (cache) {
 30001:             JSObject *cached = cache->GetWrapper();
 80389:             if (cached) {
 80389:                 if (IS_SLIM_WRAPPER_OBJECT(cached)) {
 30001:                     if (!XPCWrappedNative::Morph(ccx, cached, Interface, cache,
 91580:                                                  getter_AddRefs(wrapper)))
 30001:                         return NS_ERROR_FAILURE;
 30001:                 } else {
 91580:                     wrapper = static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(cached));
 91580:                 }
 91580:             }
 91580:         } else {
 91580:             // scoped lock
     1:             XPCAutoLock lock(mapLock);
     1:             wrapper = map->Find(identity);
     1:         }
     1: 
 80389:         if (wrapper) {
 82794:             if (Interface && !wrapper->FindTearOff(ccx, Interface, false, &rv)) {
     1:                 NS_ASSERTION(NS_FAILED(rv), "returning NS_OK on failure");
     1:                 return rv;
     1:             }
 91580:             *resultWrapper = wrapper.forget().get();
     1:             return NS_OK;
     1:         }
 80390:     } else {
 54733:         if (!ac.enter(ccx, parent))
 53565:             return NS_ERROR_FAILURE;
 53565: 
 51515:         nsISupports *Object = helper.Object();
 80389:         if (nsXPCWrappedJSClass::IsWrappedJS(Object)) {
 30625:             nsCOMPtr<nsIXPConnectWrappedJS> wrappedjs(do_QueryInterface(Object));
 30625:             JSObject *obj;
 30625:             wrappedjs->GetJSObject(&obj);
 79734:             if (xpc::AccessCheck::isChrome(js::GetObjectCompartment(obj)) &&
 80389:                 !xpc::AccessCheck::isChrome(js::GetObjectCompartment(Scope->GetGlobalJSObject()))) {
 82794:                 needsCOW = true;
 30625:             }
 30625:         }
 30625:     }
     1: 
     1:     AutoMarkingWrappedNativeProtoPtr proto(ccx);
     1: 
     1:     // If there is ClassInfo (and we are not building a wrapper for the
     1:     // nsIClassInfo interface) then we use a wrapper that needs a prototype.
     1: 
     1:     // Note that the security check happens inside FindTearOff - after the
     1:     // wrapper is actually created, but before JS code can see it.
     1: 
 80389:     if (info && !isClassInfo) {
 91578:         proto = XPCWrappedNativeProto::GetNewOrUsed(ccx, Scope, info, &sciProto);
     1:         if (!proto)
     1:             return NS_ERROR_FAILURE;
     1: 
 21218:         proto->CacheOffsets(identity);
 21218: 
 58747:         wrapper = new XPCWrappedNative(identity, proto);
     1:         if (!wrapper)
     1:             return NS_ERROR_FAILURE;
 80390:     } else {
 28864:         AutoMarkingNativeInterfacePtr iface(ccx, Interface);
 28864:         if (!iface)
 28864:             iface = XPCNativeInterface::GetISupports(ccx);
 28864: 
     1:         AutoMarkingNativeSetPtr set(ccx);
 28864:         set = XPCNativeSet::GetNewOrUsed(ccx, nsnull, iface, 0);
     1: 
     1:         if (!set)
     1:             return NS_ERROR_FAILURE;
     1: 
 58747:         wrapper = new XPCWrappedNative(identity, Scope, set);
     1:         if (!wrapper)
     1:             return NS_ERROR_FAILURE;
     1: 
     1:         DEBUG_ReportShadowedMembers(set, wrapper, nsnull);
     1:     }
     1: 
 26411:     // The strong reference was taken over by the wrapper, so make the nsCOMPtr
 26411:     // forget about it.
 51515:     helper.forgetCanonical();
 26411: 
 55659:     NS_ASSERTION(!xpc::WrapperFactory::IsXrayWrapper(parent),
 55659:                  "Xray wrapper being used to parent XPCWrappedNative?");
     1: 
 91579:     // We use an AutoMarkingPtr here because it is possible for JS gc to happen
 91579:     // after we have Init'd the wrapper but *before* we add it to the hashtable.
 91579:     // This would cause the mSet to get collected and we'd later crash. I've
 91579:     // *seen* this happen.
 91579:     AutoMarkingWrappedNativePtr wrapperMarker(ccx, wrapper);
 91579: 
 91580:     if (!wrapper->Init(ccx, parent, &sciWrapper))
     1:         return NS_ERROR_FAILURE;
     1: 
 82794:     if (Interface && !wrapper->FindTearOff(ccx, Interface, false, &rv)) {
     1:         NS_ASSERTION(NS_FAILED(rv), "returning NS_OK on failure");
     1:         return rv;
     1:     }
     1: 
 47574:     if (needsSOW)
 47574:         wrapper->SetNeedsSOW();
 47574:     if (needsCOW)
 47574:         wrapper->SetNeedsCOW();
 28705: 
 91581:     return FinishCreate(ccx, Scope, Interface, cache, wrapper, resultWrapper);
 30001: }
 30001: 
 30001: static nsresult
 30001: FinishCreate(XPCCallContext& ccx,
 30001:              XPCWrappedNativeScope* Scope,
 30001:              XPCNativeInterface* Interface,
 30001:              nsWrapperCache *cache,
 91581:              XPCWrappedNative* inWrapper,
 30001:              XPCWrappedNative** resultWrapper)
 30001: {
 91581:     MOZ_ASSERT(inWrapper);
 91581: 
     1: #if DEBUG_xpc_leaks
     1:     {
     1:         char* s = wrapper->ToString(ccx);
 57794:         NS_ASSERTION(wrapper->IsValid(), "eh?");
     1:         printf("Created wrapped native %s, flat JSObject is %p\n",
 57794:                s, (void*)wrapper->GetFlatJSObjectNoMark());
     1:         if (s)
     1:             JS_smprintf_free(s);
     1:     }
     1: #endif
     1: 
 30001:     XPCLock* mapLock = Scope->GetRuntime()->GetMapLock();
 30001:     Native2WrappedNativeMap* map = Scope->GetWrappedNativeMap();
 30001: 
 91581:     nsRefPtr<XPCWrappedNative> wrapper;
     1:     {   // scoped lock
 91581: 
 91581:         // Deal with the case where the wrapper got created as a side effect
 91581:         // of one of our calls out of this code (or on another thread). Add()
 91581:         // returns the (possibly pre-existing) wrapper that ultimately ends up
 91581:         // in the map, which is what we want.
     1:         XPCAutoLock lock(mapLock);
 91581:         wrapper = map->Add(inWrapper);
 91581:         if (!wrapper)
 91581:             return NS_ERROR_FAILURE;
 91581:     }
 91581: 
 91581:     if (wrapper == inWrapper) {
 62690:         JSObject *flat = wrapper->GetFlatJSObject();
 62690:         NS_ASSERTION(!cache || !cache->GetWrapperPreserveColor() ||
 62690:                      flat == cache->GetWrapperPreserveColor(),
 30001:                      "This object has a cached wrapper that's different from "
 30001:                      "the JSObject held by its native wrapper?");
 30001: 
 62690:         if (cache && !cache->GetWrapperPreserveColor())
 30001:             cache->SetWrapper(flat);
 26503: 
     1:         // Our newly created wrapper is the one that we just added to the table.
     1:         // All is well. Call PostCreate as necessary.
     1:         XPCNativeScriptableInfo* si = wrapper->GetScriptableInfo();
 80389:         if (si && si->GetFlags().WantPostCreate()) {
 57794:             nsresult rv = si->GetCallback()->PostCreate(wrapper, ccx, flat);
 80389:             if (NS_FAILED(rv)) {
 14986:                 // PostCreate failed and that's Very Bad. We'll remove it from
 14986:                 // the map and mark it as invalid, but the PostCreate function
 14986:                 // may have handed the partially-constructed-and-now-invalid
 14986:                 // wrapper to someone before failing. Or, perhaps worse, the
 14986:                 // PostCreate call could have triggered code that reentered
 14986:                 // XPConnect and tried to wrap the same object. In that case
 14986:                 // *we* hand out the invalid wrapper since it is already in our
 14986:                 // map :(
 14986:                 NS_ERROR("PostCreate failed! This is known to cause "
 14986:                          "inconsistent state for some class types and may even "
 14986:                          "cause a crash in combination with a JS GC. Fix the "
 14986:                          "failing PostCreate ASAP!");
 14986: 
     1:                 {   // scoped lock
     1:                     XPCAutoLock lock(mapLock);
     1:                     map->Remove(wrapper);
     1:                 }
     1: 
 14986:                 // This would be a good place to tell the wrapper not to remove
 14986:                 // itself from the map when it dies... See bug 429442.
 14986: 
 26503:                 if (cache)
 26503:                     cache->ClearWrapper();
     1:                 wrapper->Release();
     1:                 return rv;
     1:             }
     1:         }
     1:     }
     1: 
     1:     DEBUG_CheckClassInfoClaims(wrapper);
 91581:     *resultWrapper = wrapper.forget().get();
     1:     return NS_OK;
     1: }
     1: 
     1: // static
     1: nsresult
 30001: XPCWrappedNative::Morph(XPCCallContext& ccx,
 30001:                         JSObject* existingJSObject,
 30001:                         XPCNativeInterface* Interface,
 30001:                         nsWrapperCache *cache,
 30001:                         XPCWrappedNative** resultWrapper)
 30001: {
 30001:     NS_ASSERTION(IS_SLIM_WRAPPER(existingJSObject),
 30001:                  "Trying to morph a JSObject that's not a slim wrapper?");
 30001: 
 30001:     nsISupports *identity =
 30001:         static_cast<nsISupports*>(xpc_GetJSPrivate(existingJSObject));
 30001:     XPCWrappedNativeProto *proto = GetSlimWrapperProto(existingJSObject);
 30001: 
 30001: #if DEBUG
 30001:     // FIXME Can't assert this until
 30001:     //       https://bugzilla.mozilla.org/show_bug.cgi?id=343141 is fixed.
 30001: #if 0
 80389:     if (proto->GetScriptableInfo()->GetFlags().WantPreCreate()) {
 89826:         JSObject* parent = JS_GetParent(existingJSObject);
 30001:         JSObject* plannedParent = parent;
 30001:         nsresult rv =
 30001:             proto->GetScriptableInfo()->GetCallback()->PreCreate(identity, ccx,
 30001:                                                                  parent,
 30001:                                                                  &parent);
 30001:         if (NS_FAILED(rv))
 30001:             return rv;
 30001: 
 30001:         NS_ASSERTION(parent == plannedParent,
 30001:                      "PreCreate returned a different parent");
 30001:     }
 30001: #endif
 30001: #endif
 30001: 
 91580:     nsRefPtr<XPCWrappedNative> wrapper = new XPCWrappedNative(dont_AddRef(identity), proto);
 30001:     if (!wrapper)
 30001:         return NS_ERROR_FAILURE;
 30001: 
 79734:     NS_ASSERTION(!xpc::WrapperFactory::IsXrayWrapper(js::GetObjectParent(existingJSObject)),
 55659:                  "Xray wrapper being used to parent XPCWrappedNative?");
 30001: 
 91579:     // We use an AutoMarkingPtr here because it is possible for JS gc to happen
 91579:     // after we have Init'd the wrapper but *before* we add it to the hashtable.
 91579:     // This would cause the mSet to get collected and we'd later crash. I've
 91579:     // *seen* this happen.
 91579:     AutoMarkingWrappedNativePtr wrapperMarker(ccx, wrapper);
 91579: 
 55601:     JSAutoEnterCompartment ac;
 94485:     if (!ac.enter(ccx, existingJSObject)) {
 94485:         wrapper->mIdentity = nsnull;
 94485:         return NS_ERROR_FAILURE;
 94485:     }
 94485:     if (!wrapper->Init(ccx, existingJSObject))
 30001:         return NS_ERROR_FAILURE;
 30001: 
 30001:     nsresult rv;
 82794:     if (Interface && !wrapper->FindTearOff(ccx, Interface, false, &rv)) {
 30001:         NS_ASSERTION(NS_FAILED(rv), "returning NS_OK on failure");
 30001:         return rv;
 30001:     }
 30001: 
 91581:     return FinishCreate(ccx, wrapper->GetScope(), Interface, cache, wrapper, resultWrapper);
 30001: }
 30001: 
 30001: // static
 30001: nsresult
     1: XPCWrappedNative::GetUsedOnly(XPCCallContext& ccx,
     1:                               nsISupports* Object,
     1:                               XPCWrappedNativeScope* Scope,
     1:                               XPCNativeInterface* Interface,
     1:                               XPCWrappedNative** resultWrapper)
     1: {
     1:     NS_ASSERTION(Object, "XPCWrappedNative::GetUsedOnly was called with a null Object");
 21618: 
 21618:     XPCWrappedNative* wrapper;
 21618:     nsWrapperCache* cache = nsnull;
 21618:     CallQueryInterface(Object, &cache);
 80389:     if (cache) {
 30001:         JSObject *flat = cache->GetWrapper();
 33785:         if (flat && IS_SLIM_WRAPPER_OBJECT(flat) && !MorphSlimWrapper(ccx, flat))
 30001:            return NS_ERROR_FAILURE;
 30001: 
 30001:         wrapper = flat ?
 30001:                   static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(flat)) :
 30001:                   nsnull;
 30001: 
 80389:         if (!wrapper) {
 21618:             *resultWrapper = nsnull;
 21618:             return NS_OK;
 21618:         }
 21618:         NS_ADDREF(wrapper);
 80390:     } else {
 72277:         nsCOMPtr<nsISupports> identity = do_QueryInterface(Object);
     1: 
 80389:         if (!identity) {
     1:             NS_ERROR("This XPCOM object fails in QueryInterface to nsISupports!");
     1:             return NS_ERROR_FAILURE;
     1:         }
     1: 
     1:         Native2WrappedNativeMap* map = Scope->GetWrappedNativeMap();
     1: 
     1:         {   // scoped lock
     1:             XPCAutoLock lock(Scope->GetRuntime()->GetMapLock());
     1:             wrapper = map->Find(identity);
 80389:             if (!wrapper) {
     1:                 *resultWrapper = nsnull;
     1:                 return NS_OK;
     1:             }
     1:             NS_ADDREF(wrapper);
     1:         }
 21618:     }
     1: 
     1:     nsresult rv;
 82794:     if (Interface && !wrapper->FindTearOff(ccx, Interface, false, &rv)) {
     1:         NS_RELEASE(wrapper);
     1:         NS_ASSERTION(NS_FAILED(rv), "returning NS_OK on failure");
     1:         return rv;
     1:     }
     1: 
     1:     *resultWrapper = wrapper;
     1:     return NS_OK;
     1: }
     1: 
     1: // This ctor is used if this object will have a proto.
 26411: XPCWrappedNative::XPCWrappedNative(already_AddRefed<nsISupports> aIdentity,
     1:                                    XPCWrappedNativeProto* aProto)
     1:     : mMaybeProto(aProto),
 24206:       mSet(aProto->GetSet()),
 48470:       mFlatJSObject(INVALID_OBJECT), // non-null to pass IsValid() test
     1:       mScriptableInfo(nsnull),
 30625:       mWrapperWord(0)
     1: {
 26411:     mIdentity = aIdentity.get();
     1: 
     1:     NS_ASSERTION(mMaybeProto, "bad ctor param");
 24206:     NS_ASSERTION(mSet, "bad ctor param");
     1: 
     1:     DEBUG_TrackNewWrapper(this);
     1: }
     1: 
     1: // This ctor is used if this object will NOT have a proto.
 26411: XPCWrappedNative::XPCWrappedNative(already_AddRefed<nsISupports> aIdentity,
     1:                                    XPCWrappedNativeScope* aScope,
     1:                                    XPCNativeSet* aSet)
     1: 
     1:     : mMaybeScope(TagScope(aScope)),
 24206:       mSet(aSet),
 48470:       mFlatJSObject(INVALID_OBJECT), // non-null to pass IsValid() test
     1:       mScriptableInfo(nsnull),
 30625:       mWrapperWord(0)
     1: {
 26411:     mIdentity = aIdentity.get();
     1: 
     1:     NS_ASSERTION(aScope, "bad ctor param");
     1:     NS_ASSERTION(aSet, "bad ctor param");
     1: 
     1:     DEBUG_TrackNewWrapper(this);
     1: }
     1: 
     1: XPCWrappedNative::~XPCWrappedNative()
     1: {
     1:     DEBUG_TrackDeleteWrapper(this);
     1: 
 68654:     Destroy();
 68654: }
 68654: 
 95340: static const intptr_t WRAPPER_WORD_POISON = 0xa8a8a8a8;
 82481: 
 68654: void
 68654: XPCWrappedNative::Destroy()
 68654: {
     1:     XPCWrappedNativeProto* proto = GetProto();
     1: 
     1:     if (mScriptableInfo &&
     1:         (!HasProto() ||
 80389:          (proto && proto->GetScriptableInfo() != mScriptableInfo))) {
     1:         delete mScriptableInfo;
 68654:         mScriptableInfo = nsnull;
     1:     }
     1: 
 12418:     XPCWrappedNativeScope *scope = GetScope();
 80389:     if (scope) {
 12418:         Native2WrappedNativeMap* map = scope->GetWrappedNativeMap();
 12418: 
 12418:         // scoped lock
     1:         XPCAutoLock lock(GetRuntime()->GetMapLock());
 14986: 
 14986:         // Post-1.9 we should not remove this wrapper from the map if it is
 14986:         // uninitialized.
     1:         map->Remove(this);
     1:     }
     1: 
 80389:     if (mIdentity) {
     1:         XPCJSRuntime* rt = GetRuntime();
 80389:         if (rt && rt->GetDoingFinalization()) {
 80389:             if (rt->DeferredRelease(mIdentity)) {
 68654:                 mIdentity = nsnull;
 80390:             } else {
     1:                 NS_WARNING("Failed to append object for deferred release.");
     1:                 // XXX do we really want to do this???
     1:                 NS_RELEASE(mIdentity);
     1:             }
 80390:         } else {
     1:             NS_RELEASE(mIdentity);
     1:         }
     1:     }
 68654: 
 82481:     /*
 82481:      * The only time GetRuntime() will be NULL is if Destroy is called a second
 82481:      * time on a wrapped native. Since we already unregistered the pointer the
 82481:      * first time, there's no need to unregister again. Unregistration is safe
 82481:      * the first time because mWrapperWord isn't used afterwards.
 82481:      */
 82481:     if (XPCJSRuntime *rt = GetRuntime()) {
 87981:         if (js::IsIncrementalBarrierNeeded(rt->GetJSRuntime()))
 87981:             js::IncrementalReferenceBarrier(GetWrapperPreserveColor());
 82481:         mWrapperWord = WRAPPER_WORD_POISON;
 82481:     } else {
 82481:         MOZ_ASSERT(mWrapperWord == WRAPPER_WORD_POISON);
 82481:     }
 82481: 
 68654:     mMaybeScope = nsnull;
 82129: }
 82129: 
 82129: void
 82129: XPCWrappedNative::UpdateScriptableInfo(XPCNativeScriptableInfo *si)
 82129: {
 82129:     NS_ASSERTION(mScriptableInfo, "UpdateScriptableInfo expects an existing scriptable info");
 82129: 
 82129:     // Write barrier for incremental GC.
 82129:     JSRuntime* rt = GetRuntime()->GetJSRuntime();
 87981:     if (js::IsIncrementalBarrierNeeded(rt))
 82129:         mScriptableInfo->Mark();
 82129: 
 82129:     mScriptableInfo = si;
 82129: }
 82129: 
 82129: void
 82129: XPCWrappedNative::SetProto(XPCWrappedNativeProto* p)
 82129: {
 82129:     NS_ASSERTION(!IsWrapperExpired(), "bad ptr!");
 82129: 
 87981:     MOZ_ASSERT(HasProto());
 87981: 
 82129:     // Write barrier for incremental GC.
 82129:     JSRuntime* rt = GetRuntime()->GetJSRuntime();
 87981:     GetProto()->WriteBarrierPre(rt);
 82129: 
 82129:     mMaybeProto = p;
     1: }
     1: 
     1: // This is factored out so that it can be called publicly
     1: // static
 40489: void
 80387: XPCWrappedNative::GatherProtoScriptableCreateInfo(nsIClassInfo* classInfo,
 40489:                                                   XPCNativeScriptableCreateInfo& sciProto)
     1: {
     1:     NS_ASSERTION(classInfo, "bad param");
 40489:     NS_ASSERTION(!sciProto.GetCallback(), "bad param");
 40489: 
 40489:     nsXPCClassInfo *classInfoHelper = nsnull;
 40489:     CallQueryInterface(classInfo, &classInfoHelper);
 80389:     if (classInfoHelper) {
 40489:         nsCOMPtr<nsIXPCScriptable> helper =
 40489:           dont_AddRef(static_cast<nsIXPCScriptable*>(classInfoHelper));
102191:         uint32_t flags = classInfoHelper->GetScriptableFlags();
 40489:         sciProto.SetCallback(helper.forget());
 40489:         sciProto.SetFlags(flags);
 40491:         sciProto.SetInterfacesBitmap(classInfoHelper->GetInterfacesBitmap());
 40489: 
 40489:         return;
 40489:     }
     1: 
     1:     nsCOMPtr<nsISupports> possibleHelper;
 80387:     nsresult rv = classInfo->GetHelperForLanguage(nsIProgrammingLanguage::JAVASCRIPT,
     1:                                                   getter_AddRefs(possibleHelper));
 80389:     if (NS_SUCCEEDED(rv) && possibleHelper) {
     1:         nsCOMPtr<nsIXPCScriptable> helper(do_QueryInterface(possibleHelper));
 80389:         if (helper) {
102191:             uint32_t flags = helper->GetScriptableFlags();
 40489:             sciProto.SetCallback(helper.forget());
 40489:             sciProto.SetFlags(flags);
 40489:         }
 40489:     }
     1: }
     1: 
     1: // static
 40489: const XPCNativeScriptableCreateInfo&
 80387: XPCWrappedNative::GatherScriptableCreateInfo(nsISupports* obj,
     1:                                              nsIClassInfo* classInfo,
 40489:                                              XPCNativeScriptableCreateInfo& sciProto,
 40489:                                              XPCNativeScriptableCreateInfo& sciWrapper)
 40489: {
 40489:     NS_ASSERTION(!sciWrapper.GetCallback(), "bad param");
     1: 
     1:     // Get the class scriptable helper (if present)
 80389:     if (classInfo) {
     1:         GatherProtoScriptableCreateInfo(classInfo, sciProto);
     1: 
 40489:         if (sciProto.GetFlags().DontAskInstanceForScriptable())
 40489:             return sciProto;
     1:     }
     1: 
     1:     // Do the same for the wrapper specific scriptable
     1:     nsCOMPtr<nsIXPCScriptable> helper(do_QueryInterface(obj));
 80389:     if (helper) {
102191:         uint32_t flags = helper->GetScriptableFlags();
 40489:         sciWrapper.SetCallback(helper.forget());
 40489:         sciWrapper.SetFlags(flags);
     1: 
     1:         // A whole series of assertions to catch bad uses of scriptable flags on
     1:         // the siWrapper...
     1: 
 40489:         NS_ASSERTION(!(sciWrapper.GetFlags().WantPreCreate() &&
 40489:                        !sciProto.GetFlags().WantPreCreate()),
     1:                      "Can't set WANT_PRECREATE on an instance scriptable "
     1:                      "without also setting it on the class scriptable");
     1: 
 40489:         NS_ASSERTION(!(sciWrapper.GetFlags().DontEnumStaticProps() &&
 40489:                        !sciProto.GetFlags().DontEnumStaticProps() &&
 86632:                        sciProto.GetCallback()),
     1:                      "Can't set DONT_ENUM_STATIC_PROPS on an instance scriptable "
     1:                      "without also setting it on the class scriptable (if present and shared)");
     1: 
 40489:         NS_ASSERTION(!(sciWrapper.GetFlags().DontEnumQueryInterface() &&
 40489:                        !sciProto.GetFlags().DontEnumQueryInterface() &&
 86632:                        sciProto.GetCallback()),
     1:                      "Can't set DONT_ENUM_QUERY_INTERFACE on an instance scriptable "
     1:                      "without also setting it on the class scriptable (if present and shared)");
     1: 
 40489:         NS_ASSERTION(!(sciWrapper.GetFlags().DontAskInstanceForScriptable() &&
 40489:                        !sciProto.GetFlags().DontAskInstanceForScriptable()),
     1:                      "Can't set DONT_ASK_INSTANCE_FOR_SCRIPTABLE on an instance scriptable "
     1:                      "without also setting it on the class scriptable");
     1: 
 40489:         NS_ASSERTION(!(sciWrapper.GetFlags().ClassInfoInterfacesOnly() &&
 40489:                        !sciProto.GetFlags().ClassInfoInterfacesOnly() &&
 86632:                        sciProto.GetCallback()),
     1:                      "Can't set CLASSINFO_INTERFACES_ONLY on an instance scriptable "
     1:                      "without also setting it on the class scriptable (if present and shared)");
     1: 
 40489:         NS_ASSERTION(!(sciWrapper.GetFlags().AllowPropModsDuringResolve() &&
 40489:                        !sciProto.GetFlags().AllowPropModsDuringResolve() &&
 86632:                        sciProto.GetCallback()),
     1:                      "Can't set ALLOW_PROP_MODS_DURING_RESOLVE on an instance scriptable "
     1:                      "without also setting it on the class scriptable (if present and shared)");
     1: 
 40489:         NS_ASSERTION(!(sciWrapper.GetFlags().AllowPropModsToPrototype() &&
 40489:                        !sciProto.GetFlags().AllowPropModsToPrototype() &&
 86632:                        sciProto.GetCallback()),
     1:                      "Can't set ALLOW_PROP_MODS_TO_PROTOTYPE on an instance scriptable "
     1:                      "without also setting it on the class scriptable (if present and shared)");
     1: 
 40489:         return sciWrapper;
 40489:     }
 40489: 
 40489:     return sciProto;
     1: }
     1: 
 30001: #ifdef DEBUG_slimwrappers
 30001: static PRUint32 sMorphedSlimWrappers;
 30001: #endif
 30001: 
     1: JSBool
 91578: XPCWrappedNative::Init(XPCCallContext& ccx, JSObject* parent,
     1:                        const XPCNativeScriptableCreateInfo* sci)
     1: {
     1:     // setup our scriptable info...
     1: 
 80389:     if (sci->GetCallback()) {
 80389:         if (HasProto()) {
     1:             XPCNativeScriptableInfo* siProto = GetProto()->GetScriptableInfo();
     1:             if (siProto && siProto->GetCallback() == sci->GetCallback())
     1:                 mScriptableInfo = siProto;
     1:         }
 80389:         if (!mScriptableInfo) {
     1:             mScriptableInfo =
 91578:                 XPCNativeScriptableInfo::Construct(ccx, sci);
     1: 
     1:             if (!mScriptableInfo)
 82794:                 return false;
     1:         }
     1:     }
     1:     XPCNativeScriptableInfo* si = mScriptableInfo;
     1: 
     1:     // create our flatJSObject
     1: 
 90308:     JSClass* jsclazz = si ? si->GetJSClass() : Jsvalify(&XPC_WN_NoHelper_JSClass.base);
     1: 
 91592:     // We should have the global jsclass flag if and only if we're a global.
 91592:     MOZ_ASSERT_IF(si, !!si->GetFlags().IsGlobalObject() == !!(jsclazz->flags & JSCLASS_IS_GLOBAL));
 19794: 
     1:     NS_ASSERTION(jsclazz &&
     1:                  jsclazz->name &&
     1:                  jsclazz->flags &&
     1:                  jsclazz->addProperty &&
     1:                  jsclazz->delProperty &&
     1:                  jsclazz->getProperty &&
     1:                  jsclazz->setProperty &&
     1:                  jsclazz->enumerate &&
     1:                  jsclazz->resolve &&
     1:                  jsclazz->convert &&
     1:                  jsclazz->finalize, "bad class");
     1: 
     1:     JSObject* protoJSObject = HasProto() ?
     1:                                 GetProto()->GetJSProtoObject() :
 10478:                                 GetScope()->GetPrototypeNoHelper(ccx);
 10478: 
 10478:     if (!protoJSObject) {
 82794:         return false;
 10478:     }
     1: 
 78614:     mFlatJSObject = xpc_NewSystemInheritingJSObject(ccx, jsclazz, protoJSObject, false, parent);
     1:     if (!mFlatJSObject)
 82794:         return false;
     1: 
 89826:     JS_SetPrivate(mFlatJSObject, this);
     1: 
 82129:     return FinishInit(ccx);
 82129: }
 82129: 
 82129: JSBool
 82129: XPCWrappedNative::Init(XPCCallContext &ccx, JSObject *existingJSObject)
 82129: {
101164:     // Set up the private to point to the WN.
 89826:     JS_SetPrivate(existingJSObject, this);
 82129: 
101164:     // Officially mark us as non-slim.
101164:     MorphMultiSlot(existingJSObject);
 82129: 
 82129:     mScriptableInfo = GetProto()->GetScriptableInfo();
 82129:     mFlatJSObject = existingJSObject;
 82129: 
 82129:     SLIM_LOG(("----- %i morphed slim wrapper (mFlatJSObject: %p, %p)\n",
 82129:               ++sMorphedSlimWrappers, mFlatJSObject,
 82129:               static_cast<nsISupports*>(xpc_GetJSPrivate(mFlatJSObject))));
 82129: 
 82129:     return FinishInit(ccx);
 82129: }
 82129: 
 82129: JSBool
 82129: XPCWrappedNative::FinishInit(XPCCallContext &ccx)
 82129: {
101164:     // For all WNs, we want to make sure that the multislot starts out as null.
101164:     // This happens explicitly when morphing a slim wrapper, but we need to
101164:     // make sure it happens in the other cases too.
101164:     JS_SetReservedSlot(mFlatJSObject, WRAPPER_MULTISLOT, JSVAL_NULL);
101164: 
     1:     // This reference will be released when mFlatJSObject is finalized.
     1:     // Since this reference will push the refcount to 2 it will also root
     1:     // mFlatJSObject;
     1:     NS_ASSERTION(1 == mRefCnt, "unexpected refcount value");
     1:     NS_ADDREF(this);
     1: 
 30001:     if (mScriptableInfo && mScriptableInfo->GetFlags().WantCreate() &&
 30001:         NS_FAILED(mScriptableInfo->GetCallback()->Create(this, ccx,
 80389:                                                          mFlatJSObject))) {
 82794:         return false;
     1:     }
     1: 
 34273:     // A hack for bug 517665, increase the probability for GC.
 34383:     JS_updateMallocCounter(ccx.GetJSContext(), 2 * sizeof(XPCWrappedNative));
 34273: 
 82794:     return true;
     1: }
     1: 
     1: 
   791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(XPCWrappedNative)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPConnectWrappedNative)
     1:   NS_INTERFACE_MAP_ENTRY(nsIXPConnectJSObjectHolder)
     1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIXPConnectWrappedNative)
     1: NS_INTERFACE_MAP_END_THREADSAFE
     1: 
     1: NS_IMPL_THREADSAFE_ADDREF(XPCWrappedNative)
     1: NS_IMPL_THREADSAFE_RELEASE(XPCWrappedNative)
     1: 
     1: /*
     1:  *  Wrapped Native lifetime management is messy!
     1:  *
     1:  *  - At creation we push the refcount to 2 (only one of which is owned by
     1:  *    the native caller that caused the wrapper creation).
     1:  *  - During the JS GC Mark phase we mark any wrapper with a refcount > 1.
     1:  *  - The *only* thing that can make the wrapper get destroyed is the
     1:  *    finalization of mFlatJSObject. And *that* should only happen if the only
     1:  *    reference is the single extra (internal) reference we hold.
     1:  *
     1:  *  - The wrapper has a pointer to the nsISupports 'view' of the wrapped native
     1:  *    object i.e... mIdentity. This is held until the wrapper's refcount goes
 68654:  *    to zero and the wrapper is released, or until an expired wrapper (i.e.,
 68654:  *    one unlinked by the cycle collector) has had its JS object finalized.
     1:  *
     1:  *  - The wrapper also has 'tearoffs'. It has one tearoff for each interface
     1:  *    that is actually used on the native object. 'Used' means we have either
     1:  *    needed to QueryInterface to verify the availability of that interface
     1:  *    of that we've had to QueryInterface in order to actually make a call
     1:  *    into the wrapped object via the pointer for the given interface.
     1:  *
     1:  *  - Each tearoff's 'mNative' member (if non-null) indicates one reference
     1:  *    held by our wrapper on the wrapped native for the given interface
     1:  *    associated with the tearoff. If we release that reference then we set
     1:  *    the tearoff's 'mNative' to null.
     1:  *
     1:  *  - We use the occasion of the JavaScript GCCallback for the JSGC_MARK_END
     1:  *    event to scan the tearoffs of all wrappers for non-null mNative members
     1:  *    that represent unused references. We can tell that a given tearoff's
     1:  *    mNative is unused by noting that no live XPCCallContexts hold a pointer
     1:  *    to the tearoff.
     1:  *
     1:  *  - As a time/space tradeoff we may decide to not do this scanning on
     1:  *    *every* JavaScript GC. We *do* want to do this *sometimes* because
     1:  *    we want to allow for wrapped native's to do their own tearoff patterns.
     1:  *    So, we want to avoid holding references to interfaces that we don't need.
     1:  *    At the same time, we don't want to be bracketing every call into a
     1:  *    wrapped native object with a QueryInterface/Release pair. And we *never*
     1:  *    make a call into the object except via the correct interface for which
     1:  *    we've QI'd.
     1:  *
     1:  *  - Each tearoff *can* have a mJSObject whose lazily resolved properties
     1:  *    represent the methods/attributes/constants of that specific interface.
     1:  *    This is optionally reflected into JavaScript as "foo.nsIFoo" when "foo"
     1:  *    is the name of mFlatJSObject and "nsIFoo" is the name of the given
     1:  *    interface associated with the tearoff. When we create the tearoff's
     1:  *    mJSObject we set it's parent to be mFlatJSObject. This way we know that
     1:  *    when mFlatJSObject get's collected there are no outstanding reachable
     1:  *    tearoff mJSObjects. Note that we must clear the private of any lingering
     1:  *    mJSObjects at this point because we have no guarentee of the *order* of
     1:  *    finalization within a given gc cycle.
     1:  */
     1: 
     1: void
 89826: XPCWrappedNative::FlatJSObjectFinalized()
     1: {
     1:     if (!IsValid())
     1:         return;
     1: 
     1:     // Iterate the tearoffs and null out each of their JSObject's privates.
     1:     // This will keep them from trying to access their pointers to the
     1:     // dying tearoff object. We can safely assume that those remaining
     1:     // JSObjects are about to be finalized too.
     1: 
     1:     XPCWrappedNativeTearOffChunk* chunk;
 80389:     for (chunk = &mFirstChunk; chunk; chunk = chunk->mNextChunk) {
     1:         XPCWrappedNativeTearOff* to = chunk->mTearOffs;
 80389:         for (int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK-1; i >= 0; i--, to++) {
 89966:             JSObject* jso = to->GetJSObjectPreserveColor();
 80389:             if (jso) {
 89658:                 NS_ASSERTION(JS_IsAboutToBeFinalized(jso), "bad!");
 89826:                 JS_SetPrivate(jso, nsnull);
     1:                 to->JSObjectFinalized();
     1:             }
     1: 
     1:             // We also need to release any native pointers held...
     1:             nsISupports* obj = to->GetNative();
 80389:             if (obj) {
     1: #ifdef XP_WIN
     1:                 // Try to detect free'd pointer
     1:                 NS_ASSERTION(*(int*)obj != 0xdddddddd, "bad pointer!");
     1:                 NS_ASSERTION(*(int*)obj != 0,          "bad pointer!");
     1: #endif
     1:                 XPCJSRuntime* rt = GetRuntime();
 80389:                 if (rt) {
 80389:                     if (!rt->DeferredRelease(obj)) {
     1:                         NS_WARNING("Failed to append object for deferred release.");
     1:                         // XXX do we really want to do this???
     1:                         obj->Release();
     1:                     }
 80390:                 } else {
     1:                     obj->Release();
     1:                 }
     1:                 to->SetNative(nsnull);
     1:             }
     1: 
     1:             to->SetInterface(nsnull);
     1:         }
     1:     }
     1: 
 26503:     nsWrapperCache *cache = nsnull;
 26503:     CallQueryInterface(mIdentity, &cache);
 26503:     if (cache)
 26503:         cache->ClearWrapper();
 26503: 
     1:     // This makes IsValid return false from now on...
     1:     mFlatJSObject = nsnull;
     1: 
     1:     NS_ASSERTION(mIdentity, "bad pointer!");
     1: #ifdef XP_WIN
     1:     // Try to detect free'd pointer
     1:     NS_ASSERTION(*(int*)mIdentity != 0xdddddddd, "bad pointer!");
     1:     NS_ASSERTION(*(int*)mIdentity != 0,          "bad pointer!");
     1: #endif
     1: 
 80389:     if (IsWrapperExpired()) {
 68654:         Destroy();
 68654:     }
 68654: 
     1:     // Note that it's not safe to touch mNativeWrapper here since it's
     1:     // likely that it has already been finalized.
     1: 
     1:     Release();
     1: }
     1: 
     1: void
 89826: XPCWrappedNative::SystemIsBeingShutDown()
     1: {
  2991: #ifdef DEBUG_xpc_hacker
  2991:     {
  2991:         printf("Removing root for still-live XPCWrappedNative %p wrapping:\n",
  3233:                static_cast<void*>(this));
 80389:         for (PRUint16 i = 0, i_end = mSet->GetInterfaceCount(); i < i_end; ++i) {
  2991:             nsXPIDLCString name;
 24206:             mSet->GetInterfaceAt(i)->GetInterfaceInfo()
  2991:                 ->GetName(getter_Copies(name));
  2991:             printf("  %s\n", name.get());
  2991:         }
  2991:     }
  2991: #endif
     1:     DEBUG_TrackShutdownWrapper(this);
     1: 
     1:     if (!IsValid())
     1:         return;
     1: 
     1:     // The long standing strategy is to leak some objects still held at shutdown.
     1:     // The general problem is that propagating release out of xpconnect at
     1:     // shutdown time causes a world of problems.
     1: 
     1:     // We leak mIdentity (see above).
     1: 
     1:     // short circuit future finalization
 89826:     JS_SetPrivate(mFlatJSObject, nsnull);
     1:     mFlatJSObject = nsnull; // This makes 'IsValid()' return false.
     1: 
     1:     XPCWrappedNativeProto* proto = GetProto();
     1: 
     1:     if (HasProto())
 89826:         proto->SystemIsBeingShutDown();
     1: 
     1:     if (mScriptableInfo &&
     1:         (!HasProto() ||
 80389:          (proto && proto->GetScriptableInfo() != mScriptableInfo))) {
     1:         delete mScriptableInfo;
     1:     }
     1: 
     1:     // cleanup the tearoffs...
     1: 
     1:     XPCWrappedNativeTearOffChunk* chunk;
 80389:     for (chunk = &mFirstChunk; chunk; chunk = chunk->mNextChunk) {
     1:         XPCWrappedNativeTearOff* to = chunk->mTearOffs;
 80389:         for (int i = XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK-1; i >= 0; i--, to++) {
 89966:             if (JSObject *jso = to->GetJSObjectPreserveColor()) {
 89966:                 JS_SetPrivate(jso, nsnull);
     1:                 to->SetJSObject(nsnull);
     1:             }
     1:             // We leak the tearoff mNative
     1:             // (for the same reason we leak mIdentity - see above).
     1:             to->SetNative(nsnull);
     1:             to->SetInterface(nsnull);
     1:         }
     1:     }
     1: 
 80389:     if (mFirstChunk.mNextChunk) {
     1:         delete mFirstChunk.mNextChunk;
     1:         mFirstChunk.mNextChunk = nsnull;
     1:     }
     1: }
     1: 
     1: /***************************************************************************/
     1: 
 91687: // If we have to transplant an object across compartments, we need to be
 91687: // careful if the underlying object implements nsWrapperCache and is preserving
 91687: // the wrapper.
 91687: //
 91687: // The class brackets a pair of Unpreserve/Preserve calls in the given scope.
 91687: //
 91687: // This class _must_ live on the stack, in part so that mPreservedWrapper is
 91687: // visible to the stack scanner. The caller wants the wrapper to be preserved,
 91687: // so we don't want it to get accidentally GCed.
 91687: class AutoWrapperChanger NS_STACK_CLASS {
 91687: public:
 91687:     AutoWrapperChanger() : mCache(nsnull)
 91687:                          , mCOMObj(nsnull)
 91687:                          , mPreservedWrapper(nsnull)
 91687:     {}
 91687: 
 91687:     void init(nsISupports* aCOMObj, nsWrapperCache* aWrapperCache) {
 91687:         mCOMObj = aCOMObj;
 91687:         mCache = aWrapperCache;
 91687:         if (mCache->PreservingWrapper()) {
 91687:             mPreservedWrapper = mCache->GetWrapper();
 91687:             MOZ_ASSERT(mPreservedWrapper);
 91687:             nsContentUtils::ReleaseWrapper(mCOMObj, mCache);
 91687:         }
 91687:     }
 91687: 
 91687:     ~AutoWrapperChanger() {
 91687:         if (mPreservedWrapper)
 91687:             nsContentUtils::PreserveWrapper(mCOMObj, mCache);
 91687:     }
 91687: 
 91687: private:
 91687:     nsWrapperCache* mCache;
 91687:     nsISupports* mCOMObj;
 91687:     JSObject* mPreservedWrapper;
 91687: };
 91687: 
     1: // static
     1: nsresult
     1: XPCWrappedNative::ReparentWrapperIfFound(XPCCallContext& ccx,
     1:                                          XPCWrappedNativeScope* aOldScope,
     1:                                          XPCWrappedNativeScope* aNewScope,
     1:                                          JSObject* aNewParent,
     1:                                          nsISupports* aCOMObj,
     1:                                          XPCWrappedNative** aWrapper)
     1: {
     1:     XPCNativeInterface* iface =
     1:         XPCNativeInterface::GetISupports(ccx);
     1: 
     1:     if (!iface)
     1:         return NS_ERROR_FAILURE;
     1: 
     1:     nsresult rv;
 30001: 
 30001:     nsRefPtr<XPCWrappedNative> wrapper;
 91687:     AutoWrapperChanger wrapperChanger;
 30001:     JSObject *flat;
 30001:     nsWrapperCache* cache = nsnull;
 30001:     CallQueryInterface(aCOMObj, &cache);
 80389:     if (cache) {
 91687: 
 91687:         // There's a wrapper cache. Make sure we keep it sane no matter what
 91687:         // happens.
 91687:         wrapperChanger.init(aCOMObj, cache);
 91687: 
 30001:         flat = cache->GetWrapper();
 80389:         if (flat && !IS_SLIM_WRAPPER_OBJECT(flat)) {
 30001:             wrapper = static_cast<XPCWrappedNative*>(xpc_GetJSPrivate(flat));
 40041:             NS_ASSERTION(wrapper->GetScope() == aOldScope,
 40041:                          "Incorrect scope passed");
 40041:         }
 80390:     } else {
 30001:         rv = XPCWrappedNative::GetUsedOnly(ccx, aCOMObj, aOldScope, iface,
 30001:                                            getter_AddRefs(wrapper));
     1:         if (NS_FAILED(rv))
     1:             return rv;
     1: 
 62690:         flat = wrapper->GetFlatJSObject();
 30001:     }
 30001: 
 80389:     if (!flat) {
     1:         *aWrapper = nsnull;
     1:         return NS_OK;
     1:     }
     1: 
 26165:     // ReparentWrapperIfFound is really only meant to be called from DOM code
 26165:     // which must happen only on the main thread. Bail if we're on some other
 26165:     // thread or have a non-main-thread-only wrapper.
102559:     if (wrapper &&
 30001:         wrapper->GetProto() &&
102559:         !wrapper->GetProto()->ClassIsMainThreadOnly()) {
 26165:         return NS_ERROR_FAILURE;
 26165:     }
 26165: 
 58714:     JSAutoEnterCompartment ac;
 58714:     if (!ac.enter(ccx, aNewScope->GetGlobalJSObject()))
 58714:         return NS_ERROR_FAILURE;
 58714: 
 80389:     if (aOldScope != aNewScope) {
     1:         // Oh, so now we need to move the wrapper to a different scope.
     1:         AutoMarkingWrappedNativeProtoPtr oldProto(ccx);
     1:         AutoMarkingWrappedNativeProtoPtr newProto(ccx);
     1: 
 98385:         // Cross-scope means cross-compartment.
 98385:         MOZ_ASSERT(js::GetObjectCompartment(aOldScope->GetGlobalJSObject()) !=
 98385:                    js::GetObjectCompartment(aNewScope->GetGlobalJSObject()));
 98385:         NS_ASSERTION(aNewParent, "won't be able to find the new parent");
 98385:         NS_ASSERTION(wrapper, "can't transplant slim wrappers");
 98385: 
 30001:         if (!wrapper)
 30001:             oldProto = GetSlimWrapperProto(flat);
 30001:         else if (wrapper->HasProto())
     1:             oldProto = wrapper->GetProto();
 30001: 
 80389:         if (oldProto) {
     1:             XPCNativeScriptableInfo *info = oldProto->GetScriptableInfo();
     1:             XPCNativeScriptableCreateInfo ci(*info);
     1:             newProto =
     1:                 XPCWrappedNativeProto::GetNewOrUsed(ccx, aNewScope,
     1:                                                     oldProto->GetClassInfo(),
 91578:                                                     &ci, oldProto->GetOffsetsMasked());
 80389:             if (!newProto) {
     1:                 return NS_ERROR_FAILURE;
     1:             }
     1:         }
     1: 
 80389:         if (wrapper) {
     1:             Native2WrappedNativeMap* oldMap = aOldScope->GetWrappedNativeMap();
     1:             Native2WrappedNativeMap* newMap = aNewScope->GetWrappedNativeMap();
     1: 
     1:             {   // scoped lock
     1:                 XPCAutoLock lock(aOldScope->GetRuntime()->GetMapLock());
     1: 
     1:                 oldMap->Remove(wrapper);
     1: 
     1:                 if (wrapper->HasProto())
 12418:                     wrapper->SetProto(newProto);
     1: 
     1:                 // If the wrapper has no scriptable or it has a non-shared
     1:                 // scriptable, then we don't need to mess with it.
     1:                 // Otherwise...
     1: 
     1:                 if (wrapper->mScriptableInfo &&
 80389:                     wrapper->mScriptableInfo == oldProto->GetScriptableInfo()) {
 30001:                     // The new proto had better have the same JSClass stuff as
 30001:                     // the old one! We maintain a runtime wide unique map of
 30001:                     // this stuff. So, if these don't match then the caller is
 30001:                     // doing something bad here.
     1: 
 80387:                     NS_ASSERTION(oldProto->GetScriptableInfo()->GetScriptableShared() ==
     1:                                  newProto->GetScriptableInfo()->GetScriptableShared(),
     1:                                  "Changing proto is also changing JSObject Classname or "
     1:                                  "helper's nsIXPScriptable flags. This is not allowed!");
     1: 
 82129:                     wrapper->UpdateScriptableInfo(newProto->GetScriptableInfo());
     1:                 }
     1: 
     1:                 NS_ASSERTION(!newMap->Find(wrapper->GetIdentityObject()),
     1:                              "wrapper already in new scope!");
     1: 
     1:                 (void) newMap->Add(wrapper);
     1:             }
 26165: 
 79734:             JSObject *newobj = JS_CloneObject(ccx, flat,
 79734:                                               newProto->GetJSProtoObject(),
 58714:                                               aNewParent);
 58714:             if (!newobj)
 58714:                 return NS_ERROR_FAILURE;
 58714: 
 58714:             JSObject *propertyHolder =
 58714:                 JS_NewObjectWithGivenProto(ccx, NULL, NULL, aNewParent);
 79734:             if (!propertyHolder || !JS_CopyPropertiesFrom(ccx, propertyHolder, flat))
 58714:                 return NS_ERROR_OUT_OF_MEMORY;
 58714: 
101166:             // Expandos from other compartments are attached to the target JS object.
101166:             // Copy them over, and let the old ones die a natural death.
101166:             SetExpandoChain(newobj, nsnull);
101166:             if (!XrayUtils::CloneExpandoChain(ccx, newobj, flat))
101166:                 return NS_ERROR_FAILURE;
101166: 
 94842:             // Before proceeding, eagerly create any same-compartment security wrappers
 94842:             // that the object might have. This forces us to take the 'WithWrapper' path
 94842:             // while transplanting that handles this stuff correctly.
 94842:             {
 94842:                 JSAutoEnterCompartment innerAC;
 94842:                 if (!innerAC.enter(ccx, aOldScope->GetGlobalJSObject()) ||
 94842:                     !wrapper->GetSameCompartmentSecurityWrapper(ccx))
 94842:                     return NS_ERROR_FAILURE;
 94842:             }
 94842: 
 98433:             // Null out the private of the JS reflector. If we don't, we'll end up
 98433:             // with two JS objects with the same WN in their private slot, and both
 98433:             // will try to delete it during finalization. The one in this
 98433:             // compartment will actually go away quite soon, because we swap() it
 98433:             // with another object during the transplant and let that object die.
 98433:             //
 98433:             // NB: It's important to do this _after_ copying the properties to
 98433:             // propertyHolder. Otherwise, an object with |foo.x === foo| will
 98433:             // crash when JS_CopyPropertiesFrom tries to call wrap() on foo.x.
 98433:             JS_SetPrivate(flat, nsnull);
 98433: 
 62975:             JSObject *ww = wrapper->GetWrapper();
 80389:             if (ww) {
 62975:                 JSObject *newwrapper;
 97171:                 MOZ_ASSERT(!xpc::WrapperFactory::IsComponentsObject(flat), 
 97171:                            "Components object should never get here");
 80389:                 if (xpc::WrapperFactory::IsLocationObject(flat)) {
 62975:                     newwrapper = xpc::WrapperFactory::WrapLocationObject(ccx, newobj);
 62975:                     if (!newwrapper)
 62975:                         return NS_ERROR_FAILURE;
 80390:                 } else {
 62975:                     NS_ASSERTION(wrapper->NeedsSOW(), "weird wrapper wrapper");
 62975:                     newwrapper = xpc::WrapperFactory::WrapSOWObject(ccx, newobj);
 62975:                     if (!newwrapper)
 62975:                         return NS_ERROR_FAILURE;
 62975:                 }
 62975: 
 94842:                 // Ok, now we do the special object-plus-wrapper transplant.
106125:                 ww = xpc::TransplantObjectWithWrapper(ccx, flat, ww, newobj,
 62975:                                                       newwrapper);
101170:                 if (!ww)
 62975:                     return NS_ERROR_FAILURE;
 94842: 
 62975:                 flat = newobj;
101170:                 wrapper->SetWrapper(ww);
 80390:             } else {
106125:                 flat = xpc::TransplantObject(ccx, flat, newobj);
 58714:                 if (!flat)
 58714:                     return NS_ERROR_FAILURE;
 62975:             }
 62975: 
 58714:             wrapper->mFlatJSObject = flat;
 58714:             if (cache)
 58714:                 cache->SetWrapper(flat);
 79734:             if (!JS_CopyPropertiesFrom(ccx, flat, propertyHolder))
 58714:                 return NS_ERROR_FAILURE;
 80390:         } else {
101164:             SetSlimWrapperProto(flat, newProto.get());
 89826:             if (!JS_SetPrototype(ccx, flat, newProto->GetJSProtoObject())) {
 30001:                 // this is bad, very bad
101164:                 SetSlimWrapperProto(flat, nsnull);
 30001:                 NS_ERROR("JS_SetPrototype failed");
 30001:                 return NS_ERROR_FAILURE;
 30001:             }
 30001:         }
104455: 
104455:         // Call the scriptable hook to indicate that we transplanted.
104455:         XPCNativeScriptableInfo* si = wrapper->GetScriptableInfo();
104455:         if (si->GetFlags().WantPostCreate())
104455:             (void) si->GetCallback()->PostTransplant(wrapper, ccx, flat);
 30001:     }
     1: 
     1:     // Now we can just fix up the parent and return the wrapper
     1: 
 80389:     if (aNewParent) {
 51080:         if (!JS_SetParent(ccx, flat, aNewParent))
     1:             return NS_ERROR_FAILURE;
     1: 
 51080:         JSObject *nw;
 51080:         if (wrapper &&
 51080:             (nw = wrapper->GetWrapper()) &&
 80389:             !JS_SetParent(ccx, nw, JS_GetGlobalForObject(ccx, aNewParent))) {
 51080:             return NS_ERROR_FAILURE;
 51080:         }
 51080:     }
 51080: 
 30001:     *aWrapper = nsnull;
 30001:     wrapper.swap(*aWrapper);
 30001: 
     1:     return NS_OK;
     1: }
     1: 
100253: XPCWrappedNative*
100253: XPCWrappedNative::GetParentWrapper()
100253: {
100253:     XPCWrappedNative *wrapper = nsnull;
100253:     JSObject *parent = js::GetObjectParent(mFlatJSObject);
100253:     if (parent && IS_WN_WRAPPER(parent)) {
100253:         wrapper = static_cast<XPCWrappedNative*>(js::GetObjectPrivate(parent));
100253:     }
100253:     return wrapper;
100253: }
100253: 
100253: // Orphans are sad little things - If only we could treat them better. :-(
100253: //
100253: // When a wrapper gets reparented to another scope (for example, when calling
100253: // adoptNode), it's entirely possible that it previously served as the parent for
100253: // other wrappers (via PreCreate hooks). When it moves, the old mFlatJSObject is
100253: // replaced by a cross-compartment wrapper. Its descendants really _should_ move
100253: // too, but we have no way of locating them short of a compartment-wide sweep
100253: // (which we believe to be prohibitively expensive).
100253: //
100253: // So we just leave them behind. In practice, the only time this turns out to
100253: // be a problem is during subsequent wrapper reparenting. When this happens, we
100253: // call into the below fixup code at the last minute and straighten things out
100253: // before proceeding.
100253: //
100253: // See bug 751995 for more information.
100253: 
100253: bool
100253: XPCWrappedNative::IsOrphan()
100253: {
100253:     JSObject *parent = js::GetObjectParent(mFlatJSObject);
100253: 
100253:     // If there's no parent, we've presumably got a global, which can't be an
100253:     // orphan by definition.
100253:     if (!parent)
100253:         return false;
100253: 
100253:     // If our parent is a cross-compartment wrapper, it has left us behind.
100253:     return js::IsCrossCompartmentWrapper(parent);
100253: }
100253: 
100253: // Recursively fix up orphans on the parent chain of a wrapper. Note that this
100253: // can cause a wrapper to move even if IsOrphan() is false, since its parent
100253: // might be an orphan, and fixing the parent causes this wrapper to become an
100253: // orphan.
100253: nsresult
100253: XPCWrappedNative::RescueOrphans(XPCCallContext& ccx)
100253: {
100253:     // Even if we're not an orphan at the moment, one of our ancestors might
100253:     // be. If so, we need to recursively rescue up the parent chain.
100253:     nsresult rv;
100253:     XPCWrappedNative *parentWrapper = GetParentWrapper();
100253:     if (parentWrapper && parentWrapper->IsOrphan()) {
100253:         rv = parentWrapper->RescueOrphans(ccx);
100253:         NS_ENSURE_SUCCESS(rv, rv);
100253:     }
100253: 
100253:     // Now that we know our parent is in the right place, determine if we've
100253:     // been orphaned. If not, we have nothing to do.
100253:     if (!IsOrphan())
100253:         return NS_OK;
100253: 
100253:     // We've been orphaned. Find where our parent went, and follow it.
100253:     JSObject *parentGhost = js::GetObjectParent(mFlatJSObject);
100253:     JSObject *realParent = js::UnwrapObject(parentGhost);
100253:     nsRefPtr<XPCWrappedNative> ignored;
100253:     return ReparentWrapperIfFound(ccx,
100253:                                   XPCWrappedNativeScope::
100253:                                     FindInJSObjectScope(ccx, parentGhost),
100253:                                   XPCWrappedNativeScope::
100253:                                     FindInJSObjectScope(ccx, realParent),
100253:                                   realParent, mIdentity, getter_AddRefs(ignored));
100253: }
100253: 
     1: #define IS_TEAROFF_CLASS(clazz)                                               \
     1:           ((clazz) == &XPC_WN_Tearoff_JSClass)
     1: 
     1: // static
     1: XPCWrappedNative*
     1: XPCWrappedNative::GetWrappedNativeOfJSObject(JSContext* cx,
     1:                                              JSObject* obj,
     1:                                              JSObject* funobj,
     1:                                              JSObject** pobj2,
     1:                                              XPCWrappedNativeTearOff** pTearOff)
     1: {
     1:     NS_PRECONDITION(obj, "bad param");
     1: 
 71347:     // fubobj must be null if called without cx.
 71347:     NS_PRECONDITION(cx || !funobj, "bad param");
 71347: 
 71347:     // *pTeaorOff must be null if pTearOff is given
 71347:     NS_PRECONDITION(!pTearOff || !*pTearOff, "bad param");
 71347: 
     1:     JSObject* cur;
     1: 
     1:     XPCWrappedNativeProto* proto = nsnull;
     1:     nsIClassInfo* protoClassInfo = nsnull;
     1: 
     1:     // If we were passed a function object then we need to find the correct
     1:     // wrapper out of those that might be in the callee obj's proto chain.
     1: 
 80389:     if (funobj) {
 79734:         JSObject* funObjParent = js::UnwrapObject(js::GetObjectParent(funobj));
 79734:         funObjParent = JS_ObjectToInnerObject(cx, funObjParent);
     1:         NS_ASSERTION(funObjParent, "funobj has no parent");
     1: 
 79734:         js::Class* funObjParentClass = js::GetObjectClass(funObjParent);
     1: 
 80389:         if (IS_PROTO_CLASS(funObjParentClass)) {
 79734:             NS_ASSERTION(js::GetObjectParent(funObjParent), "funobj's parent (proto) is global");
 79734:             proto = (XPCWrappedNativeProto*) js::GetObjectPrivate(funObjParent);
     1:             if (proto)
     1:                 protoClassInfo = proto->GetClassInfo();
 80390:         } else if (IS_WRAPPER_CLASS(funObjParentClass)) {
     1:             cur = funObjParent;
     1:             goto return_wrapper;
 80390:         } else if (IS_TEAROFF_CLASS(funObjParentClass)) {
 79734:             NS_ASSERTION(js::GetObjectParent(funObjParent), "funobj's parent (tearoff) is global");
     1:             cur = funObjParent;
     1:             goto return_tearoff;
 80390:         } else {
     1:             NS_ERROR("function object has parent of unknown class!");
     1:             return nsnull;
     1:         }
     1:     }
     1: 
 71347:   restart:
 80389:     for (cur = obj; cur; cur = js::GetObjectProto(cur)) {
     1:         // this is on two lines to make the compiler happy given the goto.
 48622:         js::Class* clazz;
 79734:         clazz = js::GetObjectClass(cur);
     1: 
 80389:         if (IS_WRAPPER_CLASS(clazz)) {
 33785: return_wrapper:
 33785:             JSBool isWN = IS_WN_WRAPPER_OBJECT(cur);
 33785:             XPCWrappedNative* wrapper =
 79734:                 isWN ? (XPCWrappedNative*) js::GetObjectPrivate(cur) : nsnull;
 80389:             if (proto) {
 30001:                 XPCWrappedNativeProto* wrapper_proto =
 33785:                     isWN ? wrapper->GetProto() : GetSlimWrapperProto(cur);
 30001:                 if (proto != wrapper_proto &&
 51078:                     (!protoClassInfo || !wrapper_proto ||
 30001:                      protoClassInfo != wrapper_proto->GetClassInfo()))
 30001:                     continue;
 30001:             }
 30001:             if (pobj2)
 33786:                 *pobj2 = isWN ? nsnull : cur;
     1:             return wrapper;
     1:         }
     1: 
 80389:         if (IS_TEAROFF_CLASS(clazz)) {
     1: return_tearoff:
     1:             XPCWrappedNative* wrapper =
 79734:                 (XPCWrappedNative*) js::GetObjectPrivate(js::GetObjectParent(cur));
     1:             if (proto && proto != wrapper->GetProto() &&
     1:                 (proto->GetScope() != wrapper->GetScope() ||
     1:                  !protoClassInfo || !wrapper->GetProto() ||
     1:                  protoClassInfo != wrapper->GetProto()->GetClassInfo()))
     1:                 continue;
     1:             if (pobj2)
 33786:                 *pobj2 = nsnull;
 79734:             XPCWrappedNativeTearOff* to = (XPCWrappedNativeTearOff*) js::GetObjectPrivate(cur);
     1:             if (!to)
     1:                 return nsnull;
     1:             if (pTearOff)
     1:                 *pTearOff = to;
     1:             return wrapper;
     1:         }
     1: 
 27664:         // Unwrap any wrapper wrappers.
 71347:         JSObject *unsafeObj = cx
 98427:                               ? XPCWrapper::Unwrap(cx, cur, /* stopAtOuter = */ false)
 98427:                               : js::UnwrapObject(cur, /* stopAtOuter = */ false);
 80389:         if (unsafeObj) {
 71347:             obj = unsafeObj;
 71347:             goto restart;
 71347:         }
     1:     }
     1: 
 30002:     if (pobj2)
 30002:         *pobj2 = nsnull;
     1:     return nsnull;
     1: }
     1: 
     1: JSBool
     1: XPCWrappedNative::ExtendSet(XPCCallContext& ccx, XPCNativeInterface* aInterface)
     1: {
     1:     // This is only called while locked (during XPCWrappedNative::FindTearOff).
 24206: 
 80389:     if (!mSet->HasInterface(aInterface)) {
     1:         AutoMarkingNativeSetPtr newSet(ccx);
 24206:         newSet = XPCNativeSet::GetNewOrUsed(ccx, mSet, aInterface,
 24206:                                             mSet->GetInterfaceCount());
     1:         if (!newSet)
 82794:             return false;
     1: 
 24206:         mSet = newSet;
     1: 
     1:         DEBUG_ReportShadowedMembers(newSet, this, GetProto());
     1:     }
 82794:     return true;
     1: }
     1: 
     1: XPCWrappedNativeTearOff*
     1: XPCWrappedNative::LocateTearOff(XPCCallContext& ccx,
     1:                                 XPCNativeInterface* aInterface)
     1: {
     1:     XPCAutoLock al(GetLock()); // hold the lock throughout
     1: 
 80387:     for (XPCWrappedNativeTearOffChunk* chunk = &mFirstChunk;
     1:          chunk != nsnull;
 80389:          chunk = chunk->mNextChunk) {
     1:         XPCWrappedNativeTearOff* tearOff = chunk->mTearOffs;
     1:         XPCWrappedNativeTearOff* const end = tearOff +
     1:             XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK;
 80387:         for (tearOff = chunk->mTearOffs;
     1:              tearOff < end;
 80389:              tearOff++) {
 80389:             if (tearOff->GetInterface() == aInterface) {
     1:                 return tearOff;
     1:             }
     1:         }
     1:     }
     1:     return nsnull;
     1: }
     1: 
     1: XPCWrappedNativeTearOff*
     1: XPCWrappedNative::FindTearOff(XPCCallContext& ccx,
     1:                               XPCNativeInterface* aInterface,
 82794:                               JSBool needJSObject /* = false */,
     1:                               nsresult* pError /* = nsnull */)
     1: {
     1:     XPCAutoLock al(GetLock()); // hold the lock throughout
     1: 
     1:     nsresult rv = NS_OK;
     1:     XPCWrappedNativeTearOff* to;
     1:     XPCWrappedNativeTearOff* firstAvailable = nsnull;
     1: 
     1:     XPCWrappedNativeTearOffChunk* lastChunk;
     1:     XPCWrappedNativeTearOffChunk* chunk;
     1:     for (lastChunk = chunk = &mFirstChunk;
     1:          chunk;
 80389:          lastChunk = chunk, chunk = chunk->mNextChunk) {
     1:         to = chunk->mTearOffs;
     1:         XPCWrappedNativeTearOff* const end = chunk->mTearOffs +
     1:             XPC_WRAPPED_NATIVE_TEAROFFS_PER_CHUNK;
 80387:         for (to = chunk->mTearOffs;
     1:              to < end;
 80389:              to++) {
 80389:             if (to->GetInterface() == aInterface) {
 89966:                 if (needJSObject && !to->GetJSObjectPreserveColor()) {
     1:                     AutoMarkingWrappedNativeTearOffPtr tearoff(ccx, to);
 60212:                     JSBool ok = InitTearOffJSObject(ccx, to);
     1:                     // During shutdown, we don't sweep tearoffs.  So make sure
     1:                     // to unmark manually in case the auto-marker marked us.
     1:                     // We shouldn't ever be getting here _during_ our
     1:                     // Mark/Sweep cycle, so this should be safe.
     1:                     to->Unmark();
 60212:                     if (!ok) {
     1:                         to = nsnull;
 60212:                         rv = NS_ERROR_OUT_OF_MEMORY;
 60212:                     }
     1:                 }
     1:                 goto return_result;
     1:             }
     1:             if (!firstAvailable && to->IsAvailable())
     1:                 firstAvailable = to;
     1:         }
     1:     }
     1: 
     1:     to = firstAvailable;
     1: 
 80389:     if (!to) {
     1:         XPCWrappedNativeTearOffChunk* newChunk =
     1:             new XPCWrappedNativeTearOffChunk();
 80389:         if (!newChunk) {
     1:             rv = NS_ERROR_OUT_OF_MEMORY;
     1:             goto return_result;
     1:         }
     1:         lastChunk->mNextChunk = newChunk;
     1:         to = newChunk->mTearOffs;
     1:     }
     1: 
     1:     {
     1:         // Scope keeps |tearoff| from leaking across the return_result: label
     1:         AutoMarkingWrappedNativeTearOffPtr tearoff(ccx, to);
     1:         rv = InitTearOff(ccx, to, aInterface, needJSObject);
     1:         // During shutdown, we don't sweep tearoffs.  So make sure to unmark
     1:         // manually in case the auto-marker marked us.  We shouldn't ever be
     1:         // getting here _during_ our Mark/Sweep cycle, so this should be safe.
     1:         to->Unmark();
     1:         if (NS_FAILED(rv))
     1:             to = nsnull;
     1:     }
     1: 
     1: return_result:
     1: 
     1:     if (pError)
     1:         *pError = rv;
     1:     return to;
     1: }
     1: 
     1: nsresult
     1: XPCWrappedNative::InitTearOff(XPCCallContext& ccx,
     1:                               XPCWrappedNativeTearOff* aTearOff,
     1:                               XPCNativeInterface* aInterface,
     1:                               JSBool needJSObject)
     1: {
     1:     // This is only called while locked (during XPCWrappedNative::FindTearOff).
     1: 
     1:     // Determine if the object really does this interface...
     1: 
     1:     const nsIID* iid = aInterface->GetIID();
     1:     nsISupports* identity = GetIdentityObject();
     1:     nsISupports* obj;
     1: 
     1:     // If the scriptable helper forbids us from reflecting additional
     1:     // interfaces, then don't even try the QI, just fail.
     1:     if (mScriptableInfo &&
     1:         mScriptableInfo->GetFlags().ClassInfoInterfacesOnly() &&
 24206:         !mSet->HasInterface(aInterface) &&
 80389:         !mSet->HasInterfaceWithAncestor(aInterface)) {
     1:         return NS_ERROR_NO_INTERFACE;
     1:     }
     1: 
     1:     // We are about to call out to unlock and other code.
     1:     // So protect our intended tearoff.
     1: 
     1:     aTearOff->SetReserved();
     1: 
     1:     {   // scoped *un*lock
     1:         XPCAutoUnlock unlock(GetLock());
     1: 
 80389:         if (NS_FAILED(identity->QueryInterface(*iid, (void**)&obj)) || !obj) {
     1:             aTearOff->SetInterface(nsnull);
     1:             return NS_ERROR_NO_INTERFACE;
     1:         }
     1: 
     1:         // Guard against trying to build a tearoff for a shared nsIClassInfo.
 80389:         if (iid->Equals(NS_GET_IID(nsIClassInfo))) {
     1:             nsCOMPtr<nsISupports> alternate_identity(do_QueryInterface(obj));
 80389:             if (alternate_identity.get() != identity) {
     1:                 NS_RELEASE(obj);
     1:                 aTearOff->SetInterface(nsnull);
     1:                 return NS_ERROR_NO_INTERFACE;
     1:             }
     1:         }
     1: 
     1:         // Guard against trying to build a tearoff for an interface that is
     1:         // aggregated and is implemented as a nsIXPConnectWrappedJS using this
     1:         // self-same JSObject. The XBL system does this. If we mutate the set
     1:         // of this wrapper then we will shadow the method that XBL has added to
     1:         // the JSObject that it has inserted in the JS proto chain between our
     1:         // JSObject and our XPCWrappedNativeProto's JSObject. If we let this
     1:         // set mutation happen then the interface's methods will be added to
     1:         // our JSObject, but calls on those methods will get routed up to
     1:         // native code and into the wrappedJS - which will do a method lookup
     1:         // on *our* JSObject and find the same method and make another call
     1:         // into an infinite loop.
     1:         // see: http://bugzilla.mozilla.org/show_bug.cgi?id=96725
     1: 
     1:         // The code in this block also does a check for the double wrapped
     1:         // nsIPropertyBag case.
     1: 
     1:         nsCOMPtr<nsIXPConnectWrappedJS> wrappedJS(do_QueryInterface(obj));
 80389:         if (wrappedJS) {
     1:             JSObject* jso = nsnull;
     1:             if (NS_SUCCEEDED(wrappedJS->GetJSObject(&jso)) &&
 80389:                 jso == mFlatJSObject) {
     1:                 // The implementing JSObject is the same as ours! Just say OK
     1:                 // without actually extending the set.
     1:                 //
     1:                 // XXX It is a little cheesy to have FindTearOff return an
     1:                 // 'empty' tearoff. But this is the centralized place to do the
     1:                 // QI activities on the underlying object. *And* most caller to
     1:                 // FindTearOff only look for a non-null result and ignore the
     1:                 // actual tearoff returned. The only callers that do use the
     1:                 // returned tearoff make sure to check for either a non-null
     1:                 // JSObject or a matching Interface before proceeding.
     1:                 // I think we can get away with this bit of ugliness.
     1: 
     1: #ifdef DEBUG_xpc_hacker
     1:                 {
     1:                     // I want to make sure this only happens in xbl-like cases.
     1:                     // So, some debug code to verify that there is at least
     1:                     // *some* object between our JSObject and its inital proto.
     1:                     // XXX This is a pretty funky test. Someone might hack it
     1:                     // a bit if false positives start showing up. Note that
     1:                     // this is only going to run for the few people in the
     1:                     // DEBUG_xpc_hacker list.
 80389:                     if (HasProto()) {
     1:                         JSObject* proto  = nsnull;
     1:                         JSObject* our_proto = GetProto()->GetJSProtoObject();
     1: 
 39928:                         proto = jso->getProto();
     1: 
     1:                         NS_ASSERTION(proto && proto != our_proto,
     1:                                      "!!! xpconnect/xbl check - wrapper has no special proto");
     1: 
 79445:                         bool found_our_proto = false;
     1:                         while (proto && !found_our_proto) {
 39928:                             proto = proto->getProto();
     1: 
     1:                             found_our_proto = proto == our_proto;
     1:                         }
     1: 
     1:                         NS_ASSERTION(found_our_proto,
     1:                                      "!!! xpconnect/xbl check - wrapper has extra proto");
 80390:                     } else {
     1:                         NS_WARNING("!!! xpconnect/xbl check - wrapper has no proto");
     1:                     }
     1:                 }
     1: #endif
     1:                 NS_RELEASE(obj);
     1:                 aTearOff->SetInterface(nsnull);
     1:                 return NS_OK;
     1:             }
     1: 
     1:             // Decide whether or not to expose nsIPropertyBag to calling
     1:             // JS code in the double wrapped case.
     1:             //
     1:             // Our rule here is that when JSObjects are double wrapped and
     1:             // exposed to other JSObjects then the nsIPropertyBag interface
     1:             // is only exposed on an 'opt-in' basis; i.e. if the underlying
     1:             // JSObject wants other JSObjects to be able to see this interface
     1:             // then it must implement QueryInterface and not throw an exception
     1:             // when asked for nsIPropertyBag. It need not actually *implement*
     1:             // nsIPropertyBag - xpconnect will do that work.
     1: 
     1:             nsXPCWrappedJSClass* clazz;
     1:             if (iid->Equals(NS_GET_IID(nsIPropertyBag)) && jso &&
     1:                 NS_SUCCEEDED(nsXPCWrappedJSClass::GetNewOrUsed(ccx,*iid,&clazz))&&
 80389:                 clazz) {
     1:                 JSObject* answer =
     1:                     clazz->CallQueryInterfaceOnJSObject(ccx, jso, *iid);
     1:                 NS_RELEASE(clazz);
 80389:                 if (!answer) {
     1:                     NS_RELEASE(obj);
     1:                     aTearOff->SetInterface(nsnull);
     1:                     return NS_ERROR_NO_INTERFACE;
     1:                 }
     1:             }
     1:         }
     1: 
     1:         nsIXPCSecurityManager* sm;
 80387:            sm = ccx.GetXPCContext()->GetAppropriateSecurityManager(nsIXPCSecurityManager::HOOK_CREATE_WRAPPER);
     1:         if (sm && NS_FAILED(sm->
     1:                             CanCreateWrapper(ccx, *iid, identity,
 80389:                                              GetClassInfo(), GetSecurityInfoAddr()))) {
     1:             // the security manager vetoed. It should have set an exception.
     1:             NS_RELEASE(obj);
     1:             aTearOff->SetInterface(nsnull);
     1:             return NS_ERROR_XPC_SECURITY_MANAGER_VETO;
     1:         }
     1:     }
     1:     // We are relocked from here on...
     1: 
     1:     // If this is not already in our set we need to extend our set.
     1:     // Note: we do not cache the result of the previous call to HasInterface()
     1:     // because we unlocked and called out in the interim and the result of the
     1:     // previous call might not be correct anymore.
     1: 
 80389:     if (!mSet->HasInterface(aInterface) && !ExtendSet(ccx, aInterface)) {
     1:         NS_RELEASE(obj);
     1:         aTearOff->SetInterface(nsnull);
     1:         return NS_ERROR_NO_INTERFACE;
     1:     }
     1: 
     1:     aTearOff->SetInterface(aInterface);
     1:     aTearOff->SetNative(obj);
     1:     if (needJSObject && !InitTearOffJSObject(ccx, aTearOff))
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: JSBool
     1: XPCWrappedNative::InitTearOffJSObject(XPCCallContext& ccx,
     1:                                       XPCWrappedNativeTearOff* to)
     1: {
     1:     // This is only called while locked (during XPCWrappedNative::FindTearOff).
     1: 
  7987:     JSObject* obj =
 78614:         xpc_NewSystemInheritingJSObject(ccx, Jsvalify(&XPC_WN_Tearoff_JSClass),
     1:                                         GetScope()->GetPrototypeJSObject(),
 77343:                                         false, mFlatJSObject);
     1: 
 89826:     if (!obj)
 82794:         return false;
     1: 
 89826:     JS_SetPrivate(obj, to);
     1:     to->SetJSObject(obj);
 82794:     return true;
     1: }
     1: 
 94841: JSObject*
 94841: XPCWrappedNative::GetSameCompartmentSecurityWrapper(JSContext *cx)
 94841: {
 94841:     // Grab the current state of affairs.
 94841:     JSObject *flat = GetFlatJSObject();
 94841:     JSObject *wrapper = GetWrapper();
 94841: 
 94842:     // If we already have a wrapper, it must be what we want.
 94842:     if (wrapper)
 94842:         return wrapper;
 94842: 
 94841:     // Chrome callers don't need same-compartment security wrappers.
 94841:     JSCompartment *cxCompartment = js::GetContextCompartment(cx);
 94841:     MOZ_ASSERT(cxCompartment == js::GetObjectCompartment(flat));
 94841:     if (xpc::AccessCheck::isChrome(cxCompartment)) {
 94841:         MOZ_ASSERT(wrapper == NULL);
 94841:         return flat;
 94841:     }
 94841: 
 94841:     // Check the possibilities. Note that we need to check for null in each
 94841:     // case in order to distinguish between the 'no need for wrapper' and
 94841:     // 'wrapping failed' cases.
 94841:     if (xpc::WrapperFactory::IsLocationObject(flat)) {
 94841:         wrapper = xpc::WrapperFactory::WrapLocationObject(cx, flat);
 94841:         if (!wrapper)
 94841:             return NULL;
 94841:     } else if (NeedsSOW()) {
 94841:         wrapper = xpc::WrapperFactory::WrapSOWObject(cx, flat);
 94841:         if (!wrapper)
 94841:             return NULL;
 97171:     } else if (xpc::WrapperFactory::IsComponentsObject(flat)) {
 97171:         wrapper = xpc::WrapperFactory::WrapComponentsObject(cx, flat);
 97171:         if (!wrapper)
 97171:             return NULL;
 94841:     }
 94841: 
 94841:     // If we made a wrapper, cache it and return it.
 94841:     if (wrapper) {
 94841:         SetWrapper(wrapper);
 94841:         return wrapper;
 94841:     }
 94841: 
 94841:     // Otherwise, just return the bare JS reflection.
 94841:     return flat;
 94841: }
 94841: 
     1: /***************************************************************************/
     1: 
 91237: static JSBool Throw(unsigned errNum, XPCCallContext& ccx)
     1: {
     1:     XPCThrower::Throw(errNum, ccx);
 82794:     return false;
     1: }
     1: 
     1: /***************************************************************************/
     1: 
 41138: class CallMethodHelper
 41138: {
 41138:     XPCCallContext& mCallContext;
 41138:     nsIInterfaceInfo* const mIFaceInfo;
 41138:     const nsXPTMethodInfo* mMethodInfo;
 41138:     nsISupports* const mCallee;
 86464:     const uint16_t mVTableIndex;
 41138:     const jsid mIdxValueId;
 41138: 
 41138:     nsAutoTArray<nsXPTCVariant, 8> mDispatchParams;
 86464:     uint8_t mJSContextIndex; // TODO make const
 86464:     uint8_t mOptArgcIndex; // TODO make const
 41138: 
 41138:     jsval* const mArgv;
 41138:     const PRUint32 mArgc;
 41138: 
 41138:     JS_ALWAYS_INLINE JSBool
 86464:     GetArraySizeFromParam(uint8_t paramIndex, uint32_t* result) const;
 41138: 
 41138:     JS_ALWAYS_INLINE JSBool
 86464:     GetInterfaceTypeFromParam(uint8_t paramIndex,
     1:                               const nsXPTType& datum_type,
 41138:                               nsID* result) const;
 41138: 
 41138:     JS_ALWAYS_INLINE JSBool
 86464:     GetOutParamSource(uint8_t paramIndex, jsval* srcp) const;
 41138: 
 41138:     JS_ALWAYS_INLINE JSBool
 41138:     GatherAndConvertResults();
 41138: 
 41138:     JS_ALWAYS_INLINE JSBool
 41138:     QueryInterfaceFastPath() const;
 41138: 
 41138:     nsXPTCVariant*
 86464:     GetDispatchParam(uint8_t paramIndex)
 41138:     {
 46381:         if (paramIndex >= mJSContextIndex)
 46381:             paramIndex += 1;
 41138:         if (paramIndex >= mOptArgcIndex)
 41138:             paramIndex += 1;
 41138:         return &mDispatchParams[paramIndex];
 41138:     }
 41138:     const nsXPTCVariant*
 86464:     GetDispatchParam(uint8_t paramIndex) const
 41138:     {
 41138:         return const_cast<CallMethodHelper*>(this)->GetDispatchParam(paramIndex);
 41138:     }
 41138: 
 41138:     JS_ALWAYS_INLINE JSBool InitializeDispatchParams();
 41138: 
 41138:     JS_ALWAYS_INLINE JSBool ConvertIndependentParams(JSBool* foundDependentParam);
 86464:     JS_ALWAYS_INLINE JSBool ConvertIndependentParam(uint8_t i);
 41138:     JS_ALWAYS_INLINE JSBool ConvertDependentParams();
 86464:     JS_ALWAYS_INLINE JSBool ConvertDependentParam(uint8_t i);
 41138: 
 78845:     JS_ALWAYS_INLINE void CleanupParam(nsXPTCMiniVariant& param, nsXPTType& type);
 78845: 
 78840:     JS_ALWAYS_INLINE JSBool HandleDipperParam(nsXPTCVariant* dp,
 78840:                                               const nsXPTParamInfo& paramInfo);
 78840: 
 41138:     JS_ALWAYS_INLINE nsresult Invoke();
 41138: 
 41138: public:
 41138: 
 41138:     CallMethodHelper(XPCCallContext& ccx)
 41138:         : mCallContext(ccx)
 41138:         , mIFaceInfo(ccx.GetInterface()->GetInterfaceInfo())
 41138:         , mMethodInfo(nsnull)
 41138:         , mCallee(ccx.GetTearOff()->GetNative())
 41138:         , mVTableIndex(ccx.GetMethodIndex())
 41138:         , mIdxValueId(ccx.GetRuntime()->GetStringID(XPCJSRuntime::IDX_VALUE))
 46381:         , mJSContextIndex(PR_UINT8_MAX)
 41138:         , mOptArgcIndex(PR_UINT8_MAX)
 41138:         , mArgv(ccx.GetArgv())
 41138:         , mArgc(ccx.GetArgc())
 41138: 
 41138:     {
 41138:         // Success checked later.
 41138:         mIFaceInfo->GetMethodInfo(mVTableIndex, &mMethodInfo);
 41138:     }
 41138: 
 41138:     ~CallMethodHelper();
 41138: 
 41138:     JS_ALWAYS_INLINE JSBool Call();
 41138: 
 41138: };
     1: 
     1: // static
 18741: NS_SUPPRESS_STACK_CHECK JSBool
     1: XPCWrappedNative::CallMethod(XPCCallContext& ccx,
     1:                              CallMode mode /*= CALL_METHOD */)
     1: {
 41138:     XPCContext* xpcc = ccx.GetXPCContext();
 41138:     NS_ASSERTION(xpcc->CallerTypeIsJavaScript(),
     1:                  "Native caller for XPCWrappedNative::CallMethod?");
     1: 
     1:     nsresult rv = ccx.CanCallNow();
 80389:     if (NS_FAILED(rv)) {
     1:         // If the security manager is complaining then this is not really an
     1:         // internal error in xpconnect. So, no reason to botch the assertion.
     1:         NS_ASSERTION(rv == NS_ERROR_XPC_SECURITY_MANAGER_VETO,
     1:                      "hmm? CanCallNow failed in XPCWrappedNative::CallMethod. "
     1:                      "We are finding out about this late!");
     1:         return Throw(rv, ccx);
     1:     }
     1: 
     1:     DEBUG_TrackWrapperCall(ccx.GetWrapper(), mode);
     1: 
     1:     // set up the method index and do the security check if needed
     1: 
     1:     PRUint32 secFlag;
     1:     PRUint32 secAction;
     1: 
 80389:     switch (mode) {
     1:         case CALL_METHOD:
     1:             secFlag   = nsIXPCSecurityManager::HOOK_CALL_METHOD;
     1:             secAction = nsIXPCSecurityManager::ACCESS_CALL_METHOD;
     1:             break;
     1:         case CALL_GETTER:
     1:             secFlag   = nsIXPCSecurityManager::HOOK_GET_PROPERTY;
     1:             secAction = nsIXPCSecurityManager::ACCESS_GET_PROPERTY;
     1:             break;
     1:         case CALL_SETTER:
     1:             secFlag   = nsIXPCSecurityManager::HOOK_SET_PROPERTY;
     1:             secAction = nsIXPCSecurityManager::ACCESS_SET_PROPERTY;
     1:             break;
     1:         default:
 31561:             NS_ERROR("bad value");
 82794:             return false;
     1:     }
     1: 
 41138:     nsIXPCSecurityManager* sm =
 41138:         xpcc->GetAppropriateSecurityManager(secFlag);
     1:     if (sm && NS_FAILED(sm->CanAccess(secAction, &ccx, ccx,
     1:                                       ccx.GetFlattenedJSObject(),
     1:                                       ccx.GetWrapper()->GetIdentityObject(),
 41138:                                       ccx.GetWrapper()->GetClassInfo(),
 41138:                                       ccx.GetMember()->GetName(),
 80389:                                       ccx.GetWrapper()->GetSecurityInfoAddr()))) {
     1:         // the security manager vetoed. It should have set an exception.
 82794:         return false;
  5838:     }
  5838: 
 41138:     return CallMethodHelper(ccx).Call();
 41138: }
 41138: 
 41138: JSBool
 41138: CallMethodHelper::Call()
 41138: {
 41138:     mCallContext.SetRetVal(JSVAL_VOID);
 41138: 
102557:     XPCJSRuntime::Get()->SetPendingException(nsnull);
 41138:     mCallContext.GetXPCContext()->SetLastResult(NS_ERROR_UNEXPECTED);
 41138: 
 80389:     if (mVTableIndex == 0) {
 41138:         return QueryInterfaceFastPath();
 41138:     }
 41138: 
 80389:     if (!mMethodInfo) {
 41138:         Throw(NS_ERROR_XPC_CANT_GET_METHOD_INFO, mCallContext);
 82794:         return false;
  5838:     }
 41138: 
 41138:     if (!InitializeDispatchParams())
 82794:         return false;
     1: 
     1:     // Iterate through the params doing conversions of independent params only.
     1:     // When we later convert the dependent params (if any) we will know that
     1:     // the params upon which they depend will have already been converted -
     1:     // regardless of ordering.
 82794:     JSBool foundDependentParam = false;
 41138:     if (!ConvertIndependentParams(&foundDependentParam))
 82794:         return false;
 41138: 
 41138:     if (foundDependentParam && !ConvertDependentParams())
 82794:         return false;
 41138: 
 41138:     nsresult invokeResult = Invoke();
 41138: 
 41138:     mCallContext.GetXPCContext()->SetLastResult(invokeResult);
 41138: 
 80389:     if (NS_FAILED(invokeResult)) {
 41138:         ThrowBadResult(invokeResult, mCallContext);
 82794:         return false;
 41138:     }
 41138: 
 80389:     if (JS_IsExceptionPending(mCallContext)) {
 82794:         return false;
 41138:     }
 41138: 
 41138:     return GatherAndConvertResults();
 41138: }
 41138: 
 41138: CallMethodHelper::~CallMethodHelper()
 41138: {
 86464:     uint8_t paramCount = mMethodInfo->GetParamCount();
 80389:     if (mDispatchParams.Length()) {
 86464:         for (uint8_t i = 0; i < paramCount; i++) {
 41138:             nsXPTCVariant* dp = GetDispatchParam(i);
 78845:             const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(i);
 78845: 
 80389:             if (paramInfo.GetType().IsArray()) {
 41138:                 void* p = dp->val.p;
 41138:                 if (!p)
     1:                     continue;
 41138: 
 78845:                 // Clean up the array contents if necessary.
 80389:                 if (dp->DoesValNeedCleanup()) {
 78845:                     // We need some basic information to properly destroy the array.
 84755:                     uint32_t array_count = 0;
 78845:                     nsXPTType datum_type;
 78845:                     if (!GetArraySizeFromParam(i, &array_count) ||
 78845:                         !NS_SUCCEEDED(mIFaceInfo->GetTypeForParam(mVTableIndex,
 78845:                                                                   &paramInfo,
 80389:                                                                   1, &datum_type))) {
 78845:                         // XXXbholley - I'm not convinced that the above calls will
 78845:                         // ever fail.
 78845:                         NS_ERROR("failed to get array information, we'll leak here");
 41138:                         continue;
 41138:                     }
 78845: 
 78845:                     // Loop over the array contents. For each one, we create a
 78845:                     // dummy 'val' and pass it to the cleanup helper.
 84755:                     for (uint32_t k = 0; k < array_count; k++) {
 78845:                         nsXPTCMiniVariant v;
 78845:                         v.val.p = static_cast<void**>(p)[k];
 78845:                         CleanupParam(v, datum_type);
 78845:                     }
 78845:                 }
 78845: 
 41138:                 // always free the array itself
 41138:                 nsMemory::Free(p);
 80390:             } else {
 78845:                 // Clean up single parameters (if requested).
 78845:                 if (dp->DoesValNeedCleanup())
 78845:                     CleanupParam(*dp, dp->type);
 48470:             }
 46230:         }
 46230:     }
 46230: 
 41138: }
 41138: 
 41138: JSBool
 86464: CallMethodHelper::GetArraySizeFromParam(uint8_t paramIndex,
 84755:                                         uint32_t* result) const
 41138: {
 41138:     nsresult rv;
 41138:     const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(paramIndex);
 41138: 
 41138:     // TODO fixup the various exceptions that are thrown
 41138: 
 41138:     rv = mIFaceInfo->GetSizeIsArgNumberForParam(mVTableIndex, &paramInfo, 0, &paramIndex);
 41138:     if (NS_FAILED(rv))
 41138:         return Throw(NS_ERROR_XPC_CANT_GET_ARRAY_INFO, mCallContext);
 41138: 
 41138:     *result = GetDispatchParam(paramIndex)->val.u32;
 41138: 
 82794:     return true;
 41138: }
 41138: 
 41138: JSBool
 86464: CallMethodHelper::GetInterfaceTypeFromParam(uint8_t paramIndex,
 41138:                                             const nsXPTType& datum_type,
 41138:                                             nsID* result) const
 41138: {
 41138:     nsresult rv;
 41138:     const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(paramIndex);
 86464:     uint8_t tag = datum_type.TagPart();
 41138: 
 41138:     // TODO fixup the various exceptions that are thrown
 41138: 
 80389:     if (tag == nsXPTType::T_INTERFACE) {
 41138:         rv = mIFaceInfo->GetIIDForParamNoAlloc(mVTableIndex, &paramInfo, result);
 41138:         if (NS_FAILED(rv))
 41138:             return ThrowBadParam(NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO,
 41138:                                  paramIndex, mCallContext);
 80390:     } else if (tag == nsXPTType::T_INTERFACE_IS) {
 41138:         rv = mIFaceInfo->GetInterfaceIsArgNumberForParam(mVTableIndex, &paramInfo,
 41138:                                                          &paramIndex);
 41138:         if (NS_FAILED(rv))
 41138:             return Throw(NS_ERROR_XPC_CANT_GET_ARRAY_INFO, mCallContext);
 41138: 
 41138:         nsID* p = (nsID*) GetDispatchParam(paramIndex)->val.p;
 41138:         if (!p)
 41138:             return ThrowBadParam(NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO,
 41138:                                  paramIndex, mCallContext);
 41138:         *result = *p;
 41138:     }
 82794:     return true;
 41138: }
 41138: 
 41138: JSBool
 86464: CallMethodHelper::GetOutParamSource(uint8_t paramIndex, jsval* srcp) const
 41138: {
 41138:     const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(paramIndex);
     1: 
  1869:     if ((paramInfo.IsOut() || paramInfo.IsDipper()) &&
 80389:         !paramInfo.IsRetval()) {
 41138:         NS_ASSERTION(paramIndex < mArgc || paramInfo.IsOptional(),
  8557:                      "Expected either enough arguments or an optional argument");
 41138:         jsval arg = paramIndex < mArgc ? mArgv[paramIndex] : JSVAL_NULL;
 41138:         if (paramIndex < mArgc &&
 41138:             (JSVAL_IS_PRIMITIVE(arg) ||
 41138:              !JS_GetPropertyById(mCallContext,
 41138:                                  JSVAL_TO_OBJECT(arg),
 41138:                                  mIdxValueId,
 80389:                                  srcp))) {
 41138:             // Explicitly passed in unusable value for out param.  Note
 41138:             // that if i >= mArgc we already know that |arg| is JSVAL_NULL,
 41138:             // and that's ok.
 41138:             ThrowBadParam(NS_ERROR_XPC_NEED_OUT_OBJECT, paramIndex,
 41138:                           mCallContext);
 82794:             return false;
 82794:         }
 82794:     }
 82794: 
 82794:     return true;
 41138: }
 41138: 
 41138: JSBool
 41138: CallMethodHelper::GatherAndConvertResults()
 41138: {
     1:     // now we iterate through the native params to gather and convert results
 86464:     uint8_t paramCount = mMethodInfo->GetParamCount();
 86464:     for (uint8_t i = 0; i < paramCount; i++) {
 41138:         const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(i);
     1:         if (!paramInfo.IsOut() && !paramInfo.IsDipper())
     1:             continue;
     1: 
     1:         const nsXPTType& type = paramInfo.GetType();
 41138:         nsXPTCVariant* dp = GetDispatchParam(i);
     1:         jsval v = JSVAL_NULL;
 41138:         AUTO_MARK_JSVAL(mCallContext, &v);
 84755:         uint32_t array_count = 0;
     1:         nsXPTType datum_type;
 79445:         bool isArray = type.IsArray();
 79445:         bool isSizedString = isArray ?
 82794:                 false :
     1:                 type.TagPart() == nsXPTType::T_PSTRING_SIZE_IS ||
     1:                 type.TagPart() == nsXPTType::T_PWSTRING_SIZE_IS;
     1: 
 80389:         if (isArray) {
 41138:             if (NS_FAILED(mIFaceInfo->GetTypeForParam(mVTableIndex, &paramInfo, 1,
 80389:                                                       &datum_type))) {
 41138:                 Throw(NS_ERROR_XPC_CANT_GET_ARRAY_INFO, mCallContext);
 82794:                 return false;
     1:             }
 80390:         } else
     1:             datum_type = type;
     1: 
 80389:         if (isArray || isSizedString) {
 41138:             if (!GetArraySizeFromParam(i, &array_count))
 82794:                 return false;
 41138:         }
 41138: 
 41138:         nsID param_iid;
     1:         if (datum_type.IsInterfacePointer() &&
 41138:             !GetInterfaceTypeFromParam(i, datum_type, &param_iid))
 82794:             return false;
 41138: 
 83339:         nsresult err;
 80389:         if (isArray) {
 41138:             XPCLazyCallContext lccx(mCallContext);
 31395:             if (!XPCConvert::NativeArray2JS(lccx, &v, (const void**)&dp->val,
     1:                                             datum_type, &param_iid,
 80389:                                             array_count, &err)) {
     1:                 // XXX need exception scheme for arrays to indicate bad element
 41138:                 ThrowBadParam(err, i, mCallContext);
 82794:                 return false;
     1:             }
 80390:         } else if (isSizedString) {
 41138:             if (!XPCConvert::NativeStringWithSize2JS(mCallContext, &v,
     1:                                                      (const void*)&dp->val,
     1:                                                      datum_type,
 80389:                                                      array_count, &err)) {
 41138:                 ThrowBadParam(err, i, mCallContext);
 82794:                 return false;
     1:             }
 80390:         } else {
 41138:             if (!XPCConvert::NativeData2JS(mCallContext, &v, &dp->val, datum_type,
 80389:                                            &param_iid, &err)) {
 41138:                 ThrowBadParam(err, i, mCallContext);
 82794:                 return false;
     1:             }
     1:         }
     1: 
 80389:         if (paramInfo.IsRetval()) {
 41138:             mCallContext.SetRetVal(v);
 80390:         } else if (i < mArgc) {
     1:             // we actually assured this before doing the invoke
 98362:             NS_ASSERTION(mArgv[i].isObject(), "out var is not object");
 41138:             if (!JS_SetPropertyById(mCallContext,
 98362:                                     &mArgv[i].toObject(),
 80389:                                     mIdxValueId, &v)) {
 41138:                 ThrowBadParam(NS_ERROR_XPC_CANT_SET_OUT_VAL, i, mCallContext);
 82794:                 return false;
     1:             }
 80390:         } else {
  8557:             NS_ASSERTION(paramInfo.IsOptional(),
  8557:                          "Expected either enough arguments or an optional argument");
  8557:         }
     1:     }
     1: 
 82794:     return true;
 41138: }
 41138: 
 41138: JSBool
 41138: CallMethodHelper::QueryInterfaceFastPath() const
 41138: {
 41138:     NS_ASSERTION(mVTableIndex == 0,
 41138:                  "Using the QI fast-path for a method other than QueryInterface");
 41138: 
 80389:     if (mArgc < 1) {
 41138:         Throw(NS_ERROR_XPC_NOT_ENOUGH_ARGS, mCallContext);
 82794:         return false;
 41138:     }
 98362:     
 98362:     if (!mArgv[0].isObject()) {
 98362:         ThrowBadParam(NS_ERROR_XPC_BAD_CONVERT_JS, 0, mCallContext);
 98362:         return false;
 98362:     }
 98362: 
 98362:     const nsID* iid = xpc_JSObjectToID(mCallContext, &mArgv[0].toObject());
 98362:     if (!iid) {
 41138:         ThrowBadParam(NS_ERROR_XPC_BAD_CONVERT_JS, 0, mCallContext);
 82794:         return false;
 41138:     }
 41138: 
 41138:     nsresult invokeResult;
 41138:     nsISupports* qiresult = nsnull;
 41138:     invokeResult = mCallee->QueryInterface(*iid, (void**) &qiresult);
 41138: 
 41138:     mCallContext.GetXPCContext()->SetLastResult(invokeResult);
 41138: 
 80389:     if (NS_FAILED(invokeResult)) {
 41138:         ThrowBadResult(invokeResult, mCallContext);
 82794:         return false;
 41138:     }
 41138: 
 41138:     jsval v = JSVAL_NULL;
 91237:     unsigned err;
 41138:     JSBool success =
 41138:         XPCConvert::NativeData2JS(mCallContext, &v, &qiresult,
 86117:                                   nsXPTType::T_INTERFACE_IS,
 62405:                                   iid, &err);
 41138:     NS_IF_RELEASE(qiresult);
 41138: 
 80389:     if (!success) {
 41138:         ThrowBadParam(err, 0, mCallContext);
 82794:         return false;
 41138:     }
 41138: 
 41138:     mCallContext.SetRetVal(v);
 82794:     return true;
 41138: }
 41138: 
 41138: JSBool
 41138: CallMethodHelper::InitializeDispatchParams()
 41138: {
 86464:     const uint8_t wantsOptArgc = mMethodInfo->WantsOptArgc() ? 1 : 0;
 86464:     const uint8_t wantsJSContext = mMethodInfo->WantsContext() ? 1 : 0;
 86464:     const uint8_t paramCount = mMethodInfo->GetParamCount();
 86464:     uint8_t requiredArgs = paramCount;
 86464:     uint8_t hasRetval = 0;
 41138: 
 41138:     // XXX ASSUMES that retval is last arg. The xpidl compiler ensures this.
 80389:     if (paramCount && mMethodInfo->GetParam(paramCount-1).IsRetval()) {
 46381:         hasRetval = 1;
 41138:         requiredArgs--;
 46381:     }
 41138: 
 80389:     if (mArgc < requiredArgs || wantsOptArgc) {
 41138:         if (wantsOptArgc)
 41138:             mOptArgcIndex = requiredArgs;
 41138: 
 41138:         // skip over any optional arguments
 41138:         while (requiredArgs && mMethodInfo->GetParam(requiredArgs-1).IsOptional())
 41138:             requiredArgs--;
 41138: 
 41138:         if (mArgc < requiredArgs) {
 41138:             Throw(NS_ERROR_XPC_NOT_ENOUGH_ARGS, mCallContext);
 82794:             return false;
 41138:         }
 41138:     }
 41138: 
 80389:     if (wantsJSContext) {
 46381:         if (wantsOptArgc)
 46381:             // Need to bump mOptArgcIndex up one here.
 46381:             mJSContextIndex = mOptArgcIndex++;
 74586:         else if (mMethodInfo->IsSetter() || mMethodInfo->IsGetter())
 74586:             // For attributes, we always put the JSContext* first.
 74586:             mJSContextIndex = 0;
 46381:         else
 46381:             mJSContextIndex = paramCount - hasRetval;
 46381:     }
 46381: 
 41138:     // iterate through the params to clear flags (for safe cleanup later)
 86464:     for (uint8_t i = 0; i < paramCount + wantsJSContext + wantsOptArgc; i++) {
 41138:         nsXPTCVariant* dp = mDispatchParams.AppendElement();
 41138:         dp->ClearFlags();
 41138:         dp->val.p = nsnull;
 41138:     }
 41138: 
 46381:     // Fill in the JSContext argument
 80389:     if (wantsJSContext) {
 46381:         nsXPTCVariant* dp = &mDispatchParams[mJSContextIndex];
 46381:         dp->type = nsXPTType::T_VOID;
 46381:         dp->val.p = mCallContext;
 46381:     }
 46381: 
 41138:     // Fill in the optional_argc argument
 80389:     if (wantsOptArgc) {
 41138:         nsXPTCVariant* dp = &mDispatchParams[mOptArgcIndex];
 41138:         dp->type = nsXPTType::T_U8;
 80181:         dp->val.u8 = NS_MIN<PRUint32>(mArgc, paramCount) - requiredArgs;
 41138:     }
 41138: 
 82794:     return true;
 41138: }
 41138: 
 41138: JSBool
 41138: CallMethodHelper::ConvertIndependentParams(JSBool* foundDependentParam)
 41138: {
 86464:     const uint8_t paramCount = mMethodInfo->GetParamCount();
 86464:     for (uint8_t i = 0; i < paramCount; i++) {
 78838:         const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(i);
 78838: 
 78838:         if (paramInfo.GetType().IsDependent())
 82794:             *foundDependentParam = true;
 78838:         else if (!ConvertIndependentParam(i))
 82794:             return false;
 82794: 
 82794:     }
 82794: 
 82794:     return true;
 78838: }
 78838: 
 78838: JSBool
 86464: CallMethodHelper::ConvertIndependentParam(uint8_t i)
 78838: {
 41138:     const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(i);
 41138:     const nsXPTType& type = paramInfo.GetType();
 86464:     uint8_t type_tag = type.TagPart();
 41138:     nsXPTCVariant* dp = GetDispatchParam(i);
 41138:     dp->type = type;
 78846:     NS_ABORT_IF_FALSE(!paramInfo.IsShared(), "[shared] implies [noscript]!");
 78780: 
 78840:     // Handle dipper types separately.
 78840:     if (paramInfo.IsDipper())
 78840:         return HandleDipperParam(dp, paramInfo);
 78840: 
 78843:     // Specify the correct storage/calling semantics.
 78843:     if (paramInfo.IsIndirect())
 78843:         dp->SetIndirect();
 78843: 
 78842:     // The JSVal proper is always stored within the 'val' union and passed
 78842:     // indirectly, regardless of in/out-ness.
 80389:     if (type_tag == nsXPTType::T_JSVAL) {
 78844:         // Root the value.
 78844:         dp->val.j = JSVAL_VOID;
 78844:         if (!JS_AddValueRoot(mCallContext, &dp->val.j))
 82794:             return false;
 82775:     }
 82775: 
 82775:     // Flag cleanup for anything that isn't self-contained.
 82775:     if (!type.IsArithmetic())
 78845:         dp->SetValNeedsCleanup();
 78803: 
 82780:     // Even if there's nothing to convert, we still need to examine the
 82780:     // JSObject container for out-params. If it's null or otherwise invalid,
 82780:     // we want to know before the call, rather than after.
 82780:     //
 82780:     // This is a no-op for 'in' params.
 82780:     jsval src;
 82780:     if (!GetOutParamSource(i, &src))
 82794:         return false;
 82780: 
 82780:     // All that's left to do is value conversion. Bail early if we don't need
 82780:     // to do that.
 41138:     if (!paramInfo.IsIn())
 82794:         return true;
 82780: 
 82780:     // We're definitely some variety of 'in' now, so there's something to
 82780:     // convert. The source value for conversion depends on whether we're
 82780:     // dealing with an 'in' or an 'inout' parameter. 'inout' was handled above,
 82780:     // so all that's left is 'in'.
 82780:     if (!paramInfo.IsOut()) {
 82780:         // Handle the 'in' case.
 41138:         NS_ASSERTION(i < mArgc || paramInfo.IsOptional(),
 41138:                      "Expected either enough arguments or an optional argument");
 47327:         if (i < mArgc)
 47327:             src = mArgv[i];
 47327:         else if (type_tag == nsXPTType::T_JSVAL)
 47327:             src = JSVAL_VOID;
 47327:         else
 47327:             src = JSVAL_NULL;
 41138:     }
 41138: 
 41138:     nsID param_iid;
 41138:     if (type_tag == nsXPTType::T_INTERFACE &&
 41138:         NS_FAILED(mIFaceInfo->GetIIDForParamNoAlloc(mVTableIndex, &paramInfo,
 80389:                                                     &param_iid))) {
 41138:         ThrowBadParam(NS_ERROR_XPC_CANT_GET_PARAM_IFACE_INFO, i, mCallContext);
 82794:         return false;
 41138:     }
 41138: 
 91237:     unsigned err;
 41138:     if (!XPCConvert::JSData2Native(mCallContext, &dp->val, src, type,
 82794:                                    true, &param_iid, &err)) {
 41138:         ThrowBadParam(err, i, mCallContext);
 82794:         return false;
 82794:     }
 82794: 
 82794:     return true;
 41138: }
 41138: 
 41138: JSBool
 41138: CallMethodHelper::ConvertDependentParams()
 41138: {
 86464:     const uint8_t paramCount = mMethodInfo->GetParamCount();
 86464:     for (uint8_t i = 0; i < paramCount; i++) {
 41138:         const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(i);
 82776: 
 82776:         if (!paramInfo.GetType().IsDependent())
 82776:             continue;
 82776:         if (!ConvertDependentParam(i))
 82794:             return false;
 82794:     }
 82794: 
 82794:     return true;
 82776: }
 82776: 
 82776: JSBool
 86464: CallMethodHelper::ConvertDependentParam(uint8_t i)
 82776: {
 82776:     const nsXPTParamInfo& paramInfo = mMethodInfo->GetParam(i);
 41138:     const nsXPTType& type = paramInfo.GetType();
 41138:     nsXPTType datum_type;
 84755:     uint32_t array_count = 0;
 79445:     bool isArray = type.IsArray();
 79445: 
 79445:     bool isSizedString = isArray ?
 82794:         false :
 41138:         type.TagPart() == nsXPTType::T_PSTRING_SIZE_IS ||
 41138:         type.TagPart() == nsXPTType::T_PWSTRING_SIZE_IS;
 41138: 
 41138:     nsXPTCVariant* dp = GetDispatchParam(i);
 41138:     dp->type = type;
 41138: 
 80389:     if (isArray) {
 41138:         if (NS_FAILED(mIFaceInfo->GetTypeForParam(mVTableIndex, &paramInfo, 1,
 80389:                                                   &datum_type))) {
 41138:             Throw(NS_ERROR_XPC_CANT_GET_ARRAY_INFO, mCallContext);
 82794:             return false;
 41138:         }
 82783:         NS_ABORT_IF_FALSE(datum_type.TagPart() != nsXPTType::T_JSVAL,
 82783:                           "Arrays of JSVals not currently supported - "
 82783:                           "see bug 693337.");
 82779:     } else {
 41138:         datum_type = type;
 82779:     }
 41138: 
 82781:     // Specify the correct storage/calling semantics.
 82781:     if (paramInfo.IsIndirect())
 82781:         dp->SetIndirect();
 82781: 
 82784:     // We have 3 possible type of dependent parameters: Arrays, Sized Strings,
 82784:     // and iid_is Interface pointers. The latter two always need cleanup, and
 82784:     // arrays need cleanup for all non-arithmetic types. Since the latter two
 82784:     // cases also happen to be non-arithmetic, we can just inspect datum_type
 82784:     // here.
 82784:     if (!datum_type.IsArithmetic())
 78845:         dp->SetValNeedsCleanup();
 82781: 
 82780:     // Even if there's nothing to convert, we still need to examine the
 82780:     // JSObject container for out-params. If it's null or otherwise invalid,
 82780:     // we want to know before the call, rather than after.
 82780:     //
 82780:     // This is a no-op for 'in' params.
 41138:     jsval src;
 41138:     if (!GetOutParamSource(i, &src))
 82794:         return false;
 41138: 
 82780:     // All that's left to do is value conversion. Bail early if we don't need
 82780:     // to do that.
 41138:     if (!paramInfo.IsIn())
 82794:         return true;
 82780: 
 82780:     // We're definitely some variety of 'in' now, so there's something to
 82780:     // convert. The source value for conversion depends on whether we're
 82780:     // dealing with an 'in' or an 'inout' parameter. 'inout' was handled above,
 82780:     // so all that's left is 'in'.
 82780:     if (!paramInfo.IsOut()) {
 82780:         // Handle the 'in' case.
 41138:         NS_ASSERTION(i < mArgc || paramInfo.IsOptional(),
 41138:                      "Expected either enough arguments or an optional argument");
 41138:         src = i < mArgc ? mArgv[i] : JSVAL_NULL;
 41138:     }
 41138: 
 41138:     nsID param_iid;
 41138:     if (datum_type.IsInterfacePointer() &&
 41138:         !GetInterfaceTypeFromParam(i, datum_type, &param_iid))
 82794:         return false;
 41138: 
 91237:     unsigned err;
 41138: 
 80389:     if (isArray || isSizedString) {
 81513:         if (!GetArraySizeFromParam(i, &array_count))
 82794:             return false;
 41138: 
 80389:         if (isArray) {
 41138:             if (array_count &&
 41138:                 !XPCConvert::JSArray2Native(mCallContext, (void**)&dp->val, src,
 81512:                                             array_count, datum_type, &param_iid,
 81512:                                             &err)) {
 41138:                 // XXX need exception scheme for arrays to indicate bad element
 41138:                 ThrowBadParam(err, i, mCallContext);
 82794:                 return false;
 41138:             }
 80390:         } else // if (isSizedString)
 41138:         {
 41138:             if (!XPCConvert::JSStringWithSize2Native(mCallContext,
 41138:                                                      (void*)&dp->val,
 81512:                                                      src, array_count,
 80389:                                                      datum_type, &err)) {
 41138:                 ThrowBadParam(err, i, mCallContext);
 82794:                 return false;
 41138:             }
 41138:         }
 80390:     } else {
 41138:         if (!XPCConvert::JSData2Native(mCallContext, &dp->val, src, type,
 82794:                                        true, &param_iid, &err)) {
 41138:             ThrowBadParam(err, i, mCallContext);
 82794:             return false;
 82794:         }
 82794:     }
 82794: 
 82794:     return true;
 41138: }
 41138: 
 78845: // Performs all necessary teardown on a parameter after method invocation.
 78845: //
 78845: // This method should only be called if the value in question was flagged
 78845: // for cleanup (ie, if dp->DoesValNeedCleanup()).
 78845: void
 78845: CallMethodHelper::CleanupParam(nsXPTCMiniVariant& param, nsXPTType& type)
 78845: {
 78845:     // We handle array elements, but not the arrays themselves.
 78845:     NS_ABORT_IF_FALSE(type.TagPart() != nsXPTType::T_ARRAY, "Can't handle arrays.");
 78845: 
 78845:     // Pointers may sometimes be null even if cleanup was requested. Combine
 78845:     // the null checking for all the different types into one check here.
 78845:     if (type.TagPart() != nsXPTType::T_JSVAL && param.val.p == nsnull)
 78845:         return;
 78845: 
 80389:     switch (type.TagPart()) {
 78845:         case nsXPTType::T_JSVAL:
 78845:             JS_RemoveValueRoot(mCallContext, (jsval*)&param.val);
 78845:             break;
 78845:         case nsXPTType::T_INTERFACE:
 78845:         case nsXPTType::T_INTERFACE_IS:
 78845:             ((nsISupports*)param.val.p)->Release();
 78845:             break;
 78845:         case nsXPTType::T_ASTRING:
 78845:         case nsXPTType::T_DOMSTRING:
 78845:             mCallContext.DeleteString((nsAString*)param.val.p);
 78845:             break;
 78845:         case nsXPTType::T_UTF8STRING:
 78845:         case nsXPTType::T_CSTRING:
 78845:             delete (nsCString*) param.val.p;
 78845:             break;
 78845:         default:
 82785:             NS_ABORT_IF_FALSE(!type.IsArithmetic(),
 82785:                               "Cleanup requested on unexpected type.");
 78845:             nsMemory::Free(param.val.p);
 78845:             break;
 78845:     }
 78845: }
 78845: 
 78840: // Handle parameters with dipper types.
 78840: //
 78840: // Dipper types are one of the more inscrutable aspects of xpidl. In a
 78840: // nutshell, dippers are empty container objects, created and passed by
 78840: // the caller, and filled by the callee. The callee receives a
 78840: // fully-formed object, and thus does not have to construct anything. But
 78840: // the object is functionally empty, and the callee is responsible for
 78840: // putting something useful inside of it.
 78840: //
 78840: // XPIDL decides which types to make dippers. The list of these types
 78840: // is given in the isDipperType() function in typelib.py, and is currently
 78840: // limited to 4 string types.
 78840: //
 78840: // When a dipper type is declared as an 'out' parameter, xpidl internally
 78840: // converts it to an 'in', and sets the XPT_PD_DIPPER flag on it. For this
 78840: // reason, dipper types are sometimes referred to as 'out parameters
 78840: // masquerading as in'. The burden of maintaining this illusion falls mostly
 78840: // on XPConnect - we create the empty containers, and harvest the results
 78840: // after the call.
 78840: //
 78840: // This method creates these empty containers.
 78840: JSBool
 78840: CallMethodHelper::HandleDipperParam(nsXPTCVariant* dp,
 78840:                                     const nsXPTParamInfo& paramInfo)
 78840: {
 78840:     // Get something we can make comparisons with.
 86464:     uint8_t type_tag = paramInfo.GetType().TagPart();
 78840: 
 78840:     // Dippers always have the 'in' and 'dipper' flags set. Never 'out'.
 78840:     NS_ABORT_IF_FALSE(!paramInfo.IsOut(), "Dipper has unexpected flags.");
 78840: 
 78840:     // xpidl.h specifies that dipper types will be used in exactly four
 78840:     // cases, all strings. Verify that here.
 78840:     NS_ABORT_IF_FALSE(type_tag == nsXPTType::T_ASTRING ||
 78840:                       type_tag == nsXPTType::T_DOMSTRING ||
 78840:                       type_tag == nsXPTType::T_UTF8STRING ||
 78840:                       type_tag == nsXPTType::T_CSTRING,
 78840:                       "Unexpected dipper type!");
 78840: 
 78840:     // ASTRING and DOMSTRING are very similar, and both use nsAutoString.
 78840:     // UTF8_STRING and CSTRING are also quite similar, and both use nsCString.
 78840:     if (type_tag == nsXPTType::T_ASTRING || type_tag == nsXPTType::T_DOMSTRING)
 78840:         dp->val.p = new nsAutoString();
 78840:     else
 78840:         dp->val.p = new nsCString();
 78840: 
 78840:     // Check for OOM, in either case.
 80389:     if (!dp->val.p) {
 78840:         JS_ReportOutOfMemory(mCallContext);
 82794:         return false;
 78840:     }
 78840: 
 78845:     // We allocated, so we need to deallocate after the method call completes.
 78845:     dp->SetValNeedsCleanup();
 78845: 
 82794:     return true;
 78840: }
 78840: 
 41138: nsresult
 41138: CallMethodHelper::Invoke()
 41138: {
 41138:     PRUint32 argc = mDispatchParams.Length();
 41138:     nsXPTCVariant* argv = mDispatchParams.Elements();
 41138: 
 41138:     return NS_InvokeByIndex(mCallee, mVTableIndex, argc, argv);
     1: }
     1: 
     1: /***************************************************************************/
     1: // interface methods
     1: 
     1: /* readonly attribute JSObjectPtr JSObject; */
     1: NS_IMETHODIMP XPCWrappedNative::GetJSObject(JSObject * *aJSObject)
     1: {
 62690:     *aJSObject = GetFlatJSObject();
     1:     return NS_OK;
     1: }
     1: 
     1: /* readonly attribute nsISupports Native; */
     1: NS_IMETHODIMP XPCWrappedNative::GetNative(nsISupports * *aNative)
     1: {
     1:     // No need to QI here, we already have the correct nsISupports
     1:     // vtable.
     1:     *aNative = mIdentity;
     1:     NS_ADDREF(*aNative);
     1:     return NS_OK;
     1: }
     1: 
 57794: /* reaonly attribute JSObjectPtr JSObjectPrototype; */
     1: NS_IMETHODIMP XPCWrappedNative::GetJSObjectPrototype(JSObject * *aJSObjectPrototype)
     1: {
     1:     *aJSObjectPrototype = HasProto() ?
 62690:                 GetProto()->GetJSProtoObject() : GetFlatJSObject();
     1:     return NS_OK;
     1: }
     1: 
     1: nsIPrincipal*
     1: XPCWrappedNative::GetObjectPrincipal() const
     1: {
     1:     nsIPrincipal* principal = GetScope()->GetPrincipal();
     1: #ifdef DEBUG
 90436:     // Because of inner window reuse, we can have objects with one principal
 90436:     // living in a scope with a different (but same-origin) principal. So
 90436:     // just check same-origin here.
     1:     nsCOMPtr<nsIScriptObjectPrincipal> objPrin(do_QueryInterface(mIdentity));
 90436:     if (objPrin) {
 90436:         bool equal;
 90436:         if (!principal)
 90436:             equal = !objPrin->GetPrincipal();
 90436:         else
 90436:             principal->Equals(objPrin->GetPrincipal(), &equal);
 90436:         NS_ASSERTION(equal, "Principal mismatch.  Expect bad things to happen");
 90436:     }
     1: #endif
     1:     return principal;
     1: }
     1: 
     1: /* readonly attribute nsIXPConnect XPConnect; */
     1: NS_IMETHODIMP XPCWrappedNative::GetXPConnect(nsIXPConnect * *aXPConnect)
     1: {
 80389:     if (IsValid()) {
     1:         nsIXPConnect* temp = GetRuntime()->GetXPConnect();
     1:         NS_IF_ADDREF(temp);
     1:         *aXPConnect = temp;
 80390:     } else
     1:         *aXPConnect = nsnull;
     1:     return NS_OK;
     1: }
     1: 
 42675: /* XPCNativeInterface FindInterfaceWithMember (in jsval name); */
 48470: NS_IMETHODIMP XPCWrappedNative::FindInterfaceWithMember(jsid name, nsIInterfaceInfo * *_retval)
     1: {
     1:     XPCNativeInterface* iface;
     1:     XPCNativeMember*  member;
     1: 
 80389:     if (GetSet()->FindMember(name, &member, &iface) && iface) {
     1:         nsIInterfaceInfo* temp = iface->GetInterfaceInfo();
     1:         NS_IF_ADDREF(temp);
     1:         *_retval = temp;
 80390:     } else
     1:         *_retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
 42675: /* XPCNativeInterface FindInterfaceWithName (in jsval name); */
 48470: NS_IMETHODIMP XPCWrappedNative::FindInterfaceWithName(jsid name, nsIInterfaceInfo * *_retval)
     1: {
     1:     XPCNativeInterface* iface = GetSet()->FindNamedInterface(name);
 80389:     if (iface) {
     1:         nsIInterfaceInfo* temp = iface->GetInterfaceInfo();
     1:         NS_IF_ADDREF(temp);
     1:         *_retval = temp;
 80390:     } else
     1:         *_retval = nsnull;
     1:     return NS_OK;
     1: }
     1: 
     1: inline nsresult UnexpectedFailure(nsresult rv)
     1: {
     1:     NS_ERROR("This is not supposed to fail!");
     1:     return rv;
     1: }
     1: 
 91590: /* void finishInitForWrappedGlobal (); */
 91590: NS_IMETHODIMP XPCWrappedNative::FinishInitForWrappedGlobal()
     1: {
 91590:     // We can only be called under certain conditions.
 91590:     MOZ_ASSERT(mScriptableInfo);
 91590:     MOZ_ASSERT(mScriptableInfo->GetFlags().IsGlobalObject());
 91590:     MOZ_ASSERT(HasProto());
 91590: 
 91590:     // Build a CCX.
     1:     XPCCallContext ccx(NATIVE_CALLER);
     1:     if (!ccx.IsValid())
     1:         return UnexpectedFailure(NS_ERROR_FAILURE);
     1: 
 91590:     // Call PostCreateProrotype.
 91590:     bool success = GetProto()->CallPostCreatePrototype(ccx);
 91590:     if (!success)
 91590:         return NS_ERROR_FAILURE;
     1: 
     1:     return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP XPCWrappedNative::GetSecurityInfoAddress(void*** securityInfoAddrPtr)
     1: {
     1:     NS_ENSURE_ARG_POINTER(securityInfoAddrPtr);
     1:     *securityInfoAddrPtr = GetSecurityInfoAddr();
     1:     return NS_OK;
     1: }
     1: 
     1: /* void debugDump (in short depth); */
     1: NS_IMETHODIMP XPCWrappedNative::DebugDump(PRInt16 depth)
     1: {
     1: #ifdef DEBUG
     1:     depth-- ;
     1:     XPC_LOG_ALWAYS(("XPCWrappedNative @ %x with mRefCnt = %d", this, mRefCnt.get()));
     1:     XPC_LOG_INDENT();
     1: 
 80389:         if (HasProto()) {
 12418:             XPCWrappedNativeProto* proto = GetProto();
 12418:             if (depth && proto)
 12418:                 proto->DebugDump(depth);
     1:             else
 12418:                 XPC_LOG_ALWAYS(("mMaybeProto @ %x", proto));
 80390:         } else
 12418:             XPC_LOG_ALWAYS(("Scope @ %x", GetScope()));
     1: 
 24206:         if (depth && mSet)
 24206:             mSet->DebugDump(depth);
     1:         else
 24206:             XPC_LOG_ALWAYS(("mSet @ %x", mSet));
     1: 
     1:         XPC_LOG_ALWAYS(("mFlatJSObject of %x", mFlatJSObject));
  2953:         XPC_LOG_ALWAYS(("mIdentity of %x", mIdentity));
     1:         XPC_LOG_ALWAYS(("mScriptableInfo @ %x", mScriptableInfo));
     1: 
 80389:         if (depth && mScriptableInfo) {
     1:             XPC_LOG_INDENT();
     1:             XPC_LOG_ALWAYS(("mScriptable @ %x", mScriptableInfo->GetCallback()));
     1:             XPC_LOG_ALWAYS(("mFlags of %x", (PRUint32)mScriptableInfo->GetFlags()));
     1:             XPC_LOG_ALWAYS(("mJSClass @ %x", mScriptableInfo->GetJSClass()));
     1:             XPC_LOG_OUTDENT();
     1:         }
     1:     XPC_LOG_OUTDENT();
     1: #endif
     1:     return NS_OK;
     1: }
     1: 
     1: /***************************************************************************/
     1: 
     1: char*
     1: XPCWrappedNative::ToString(XPCCallContext& ccx,
     1:                            XPCWrappedNativeTearOff* to /* = nsnull */ ) const
     1: {
     1: #ifdef DEBUG
     1: #  define FMT_ADDR " @ 0x%p"
     1: #  define FMT_STR(str) str
     1: #  define PARAM_ADDR(w) , w
     1: #else
     1: #  define FMT_ADDR ""
     1: #  define FMT_STR(str)
     1: #  define PARAM_ADDR(w)
     1: #endif
     1: 
     1:     char* sz = nsnull;
     1:     char* name = nsnull;
     1: 
     1:     XPCNativeScriptableInfo* si = GetScriptableInfo();
     1:     if (si)
     1:         name = JS_smprintf("%s", si->GetJSClass()->name);
 80389:     if (to) {
     1:         const char* fmt = name ? " (%s)" : "%s";
     1:         name = JS_sprintf_append(name, fmt,
     1:                                  to->GetInterface()->GetNameString());
 80390:     } else if (!name) {
     1:         XPCNativeSet* set = GetSet();
     1:         XPCNativeInterface** array = set->GetInterfaceArray();
     1:         PRUint16 count = set->GetInterfaceCount();
     1: 
     1:         if (count == 1)
     1:             name = JS_sprintf_append(name, "%s", array[0]->GetNameString());
     1:         else if (count == 2 &&
 80389:                  array[0] == XPCNativeInterface::GetISupports(ccx)) {
     1:             name = JS_sprintf_append(name, "%s", array[1]->GetNameString());
 80390:         } else {
 80389:             for (PRUint16 i = 0; i < count; i++) {
     1:                 const char* fmt = (i == 0) ?
     1:                                     "(%s" : (i == count-1) ?
     1:                                         ", %s)" : ", %s";
     1:                 name = JS_sprintf_append(name, fmt,
     1:                                          array[i]->GetNameString());
     1:             }
     1:         }
     1:     }
     1: 
 80389:     if (!name) {
     1:         return nsnull;
     1:     }
     1:     const char* fmt = "[xpconnect wrapped %s" FMT_ADDR FMT_STR(" (native")
     1:         FMT_ADDR FMT_STR(")") "]";
 80389:     if (si) {
     1:         fmt = "[object %s" FMT_ADDR FMT_STR(" (native") FMT_ADDR FMT_STR(")") "]";
     1:     }
     1:     sz = JS_smprintf(fmt, name PARAM_ADDR(this) PARAM_ADDR(mIdentity));
     1: 
     1:     JS_smprintf_free(name);
     1: 
     1: 
     1:     return sz;
     1: 
     1: #undef FMT_ADDR
     1: #undef PARAM_ADDR
     1: }
     1: 
     1: /***************************************************************************/
     1: 
     1: #ifdef XPC_CHECK_CLASSINFO_CLAIMS
     1: static void DEBUG_CheckClassInfoClaims(XPCWrappedNative* wrapper)
     1: {
     1:     if (!wrapper || !wrapper->GetClassInfo())
     1:         return;
     1: 
     1:     nsISupports* obj = wrapper->GetIdentityObject();
     1:     XPCNativeSet* set = wrapper->GetSet();
     1:     PRUint16 count = set->GetInterfaceCount();
 80389:     for (PRUint16 i = 0; i < count; i++) {
     1:         nsIClassInfo* clsInfo = wrapper->GetClassInfo();
     1:         XPCNativeInterface* iface = set->GetInterfaceAt(i);
     1:         nsIInterfaceInfo* info = iface->GetInterfaceInfo();
     1:         const nsIID* iid;
     1:         nsISupports* ptr;
     1: 
     1:         info->GetIIDShared(&iid);
     1:         nsresult rv = obj->QueryInterface(*iid, (void**)&ptr);
 80389:         if (NS_SUCCEEDED(rv)) {
     1:             NS_RELEASE(ptr);
     1:             continue;
     1:         }
     1:         if (rv == NS_ERROR_OUT_OF_MEMORY)
     1:             continue;
     1: 
     1:         // Houston, We have a problem...
     1: 
     1:         char* className = nsnull;
     1:         char* contractID = nsnull;
     1:         const char* interfaceName;
     1: 
     1:         info->GetNameShared(&interfaceName);
     1:         clsInfo->GetContractID(&contractID);
 80389:         if (wrapper->GetScriptableInfo()) {
     1:             wrapper->GetScriptableInfo()->GetCallback()->
     1:                 GetClassName(&className);
     1:         }
     1: 
     1: 
     1:         printf("\n!!! Object's nsIClassInfo lies about its interfaces!!!\n"
     1:                "   classname: %s \n"
     1:                "   contractid: %s \n"
     1:                "   unimplemented interface name: %s\n\n",
     1:                className ? className : "<unknown>",
     1:                contractID ? contractID : "<unknown>",
     1:                interfaceName);
     1: 
     1: #ifdef XPC_ASSERT_CLASSINFO_CLAIMS
     1:         NS_ERROR("Fix this QueryInterface or nsIClassInfo");
     1: #endif
     1: 
     1:         if (className)
     1:             nsMemory::Free(className);
     1:         if (contractID)
     1:             nsMemory::Free(contractID);
     1:     }
     1: }
     1: #endif
     1: 
     1: #ifdef XPC_REPORT_SHADOWED_WRAPPED_NATIVE_MEMBERS
     1: static void DEBUG_PrintShadowObjectInfo(const char* header,
     1:                                         XPCNativeSet* set,
     1:                                         XPCWrappedNative* wrapper,
     1:                                         XPCWrappedNativeProto* proto)
     1: 
     1: {
     1:     if (header)
     1:         printf("%s\n", header);
     1: 
     1:     printf("   XPCNativeSet @ 0x%p for the class:\n", (void*)set);
     1: 
     1:     char* className = nsnull;
     1:     char* contractID = nsnull;
     1: 
     1:     nsIClassInfo* clsInfo = proto ? proto->GetClassInfo() : nsnull;
     1:     if (clsInfo)
     1:         clsInfo->GetContractID(&contractID);
     1: 
     1:     XPCNativeScriptableInfo* si = wrapper ?
     1:             wrapper->GetScriptableInfo() :
     1:             proto->GetScriptableInfo();
     1:     if (si)
     1:         si->GetCallback()->GetClassName(&className);
     1: 
     1:     printf("   classname: %s \n"
     1:            "   contractid: %s \n",
     1:            className ? className : "<unknown>",
     1:            contractID ? contractID : "<unknown>");
     1: 
     1:     if (className)
     1:         nsMemory::Free(className);
     1:     if (contractID)
     1:         nsMemory::Free(contractID);
     1: 
     1:     printf("   claims to implement interfaces:\n");
     1: 
     1:     PRUint16 count = set->GetInterfaceCount();
 80389:     for (PRUint16 i = 0; i < count; i++) {
     1:         XPCNativeInterface* iface = set->GetInterfaceAt(i);
     1:         nsIInterfaceInfo* info = iface->GetInterfaceInfo();
     1:         const char* interfaceName;
     1:         info->GetNameShared(&interfaceName);
     1:         printf("      %s\n", interfaceName);
     1:     }
     1: }
     1: 
     1: static void ReportSingleMember(jsval ifaceName,
     1:                                jsval memberName)
     1: {
 57721:     JS_FileEscapedString(stdout, ifaceName, 0);
 57721:     if (JSVAL_IS_STRING(memberName)) {
 57721:         fputs("::", stdout);
 57721:         JS_FileEscapedString(stdout, memberName, 0);
 57721:     }
     1: }
     1: 
     1: static void ShowHeader(JSBool* printedHeader,
     1:                        const char* header,
     1:                        XPCNativeSet* set,
     1:                        XPCWrappedNative* wrapper,
     1:                        XPCWrappedNativeProto* proto)
     1: {
 80389:     if (!*printedHeader) {
     1:         DEBUG_PrintShadowObjectInfo(header, set, wrapper, proto);
 82794:         *printedHeader = true;
     1:     }
     1: 
     1: }
     1: 
     1: static void ShowOneShadow(jsval ifaceName1,
     1:                           jsval memberName1,
     1:                           jsval ifaceName2,
     1:                           jsval memberName2)
     1: {
     1:     ReportSingleMember(ifaceName1, memberName1);
     1:     printf(" shadows ");
     1:     ReportSingleMember(ifaceName2, memberName2);
     1:     printf("\n");
     1: }
     1: 
     1: static void ShowDuplicateInterface(jsval ifaceName)
     1: {
 57721:     fputs(" ! ", stdout);
 57721:     JS_FileEscapedString(stdout, ifaceName, 0);
 57721:     fputs(" appears twice in the nsIClassInfo interface set!\n", stdout);
     1: }
     1: 
     1: static JSBool InterfacesAreRelated(XPCNativeInterface* iface1,
     1:                                    XPCNativeInterface* iface2)
     1: {
     1:     nsIInterfaceInfo* info1 = iface1->GetInterfaceInfo();
     1:     nsIInterfaceInfo* info2 = iface2->GetInterfaceInfo();
     1: 
     1:     NS_ASSERTION(info1 != info2, "should not have different iface!");
     1: 
 79445:     bool match;
     1: 
     1:     return
     1:         (NS_SUCCEEDED(info1->HasAncestor(iface2->GetIID(), &match)) && match) ||
     1:         (NS_SUCCEEDED(info2->HasAncestor(iface1->GetIID(), &match)) && match);
     1: }
     1: 
     1: static JSBool MembersAreTheSame(XPCNativeInterface* iface1,
     1:                                 PRUint16 memberIndex1,
     1:                                 XPCNativeInterface* iface2,
     1:                                 PRUint16 memberIndex2)
     1: {
     1:     nsIInterfaceInfo* info1 = iface1->GetInterfaceInfo();
     1:     nsIInterfaceInfo* info2 = iface2->GetInterfaceInfo();
     1: 
     1:     XPCNativeMember* member1 = iface1->GetMemberAt(memberIndex1);
     1:     XPCNativeMember* member2 = iface2->GetMemberAt(memberIndex2);
     1: 
     1:     PRUint16 index1 = member1->GetIndex();
     1:     PRUint16 index2 = member2->GetIndex();
     1: 
     1:     // If they are both constants, then we'll just be sure that they are equivalent.
     1: 
 80389:     if (member1->IsConstant()) {
     1:         if (!member2->IsConstant())
 82794:             return false;
     1: 
     1:         const nsXPTConstant* constant1;
     1:         const nsXPTConstant* constant2;
     1: 
     1:         return NS_SUCCEEDED(info1->GetConstant(index1, &constant1)) &&
     1:                NS_SUCCEEDED(info2->GetConstant(index2, &constant2)) &&
     1:                constant1->GetType() == constant2->GetType() &&
     1:                constant1->GetValue() == constant2->GetValue();
     1:     }
     1: 
     1:     // Else we make sure they are of the same 'type' and return true only if
     1:     // they are inherited from the same interface.
     1: 
     1:     if (member1->IsMethod() != member2->IsMethod() ||
     1:         member1->IsWritableAttribute() != member2->IsWritableAttribute() ||
 80389:         member1->IsReadOnlyAttribute() != member2->IsReadOnlyAttribute()) {
 82794:         return false;
     1:     }
     1: 
     1:     const nsXPTMethodInfo* mi1;
     1:     const nsXPTMethodInfo* mi2;
     1: 
     1:     return NS_SUCCEEDED(info1->GetMethodInfo(index1, &mi1)) &&
     1:            NS_SUCCEEDED(info2->GetMethodInfo(index2, &mi2)) &&
     1:            mi1 == mi2;
     1: }
     1: 
     1: void DEBUG_ReportShadowedMembers(XPCNativeSet* set,
     1:                                  XPCWrappedNative* wrapper,
     1:                                  XPCWrappedNativeProto* proto)
     1: {
     1:     // NOTE: Either wrapper or proto could be null...
     1: 
     1:     if (!(proto || wrapper) || !set || set->GetInterfaceCount() < 2)
     1:         return;
     1: 
     1:     NS_ASSERTION(proto || wrapper, "bad param!");
     1:     XPCJSRuntime* rt = proto ? proto->GetRuntime() : wrapper->GetRuntime();
     1: 
     1:     // a quicky hack to avoid reporting info for the same set too often
     1:     static int nextSeenSet = 0;
     1:     static const int MAX_SEEN_SETS = 128;
     1:     static XPCNativeSet* SeenSets[MAX_SEEN_SETS];
     1:     for (int seen = 0; seen < MAX_SEEN_SETS; seen++)
     1:         if (set == SeenSets[seen])
     1:             return;
     1:     SeenSets[nextSeenSet] = set;
     1: 
     1: #ifdef off_DEBUG_jband
     1:     static int seenCount = 0;
     1:     printf("--- adding SeenSets[%d] = 0x%p\n", nextSeenSet, set);
     1:     DEBUG_PrintShadowObjectInfo(nsnull, set, wrapper, proto);
     1: #endif
     1:     int localNext = nextSeenSet+1;
     1:     nextSeenSet = localNext < MAX_SEEN_SETS ? localNext : 0;
     1: 
     1:     XPCNativeScriptableInfo* si = wrapper ?
     1:             wrapper->GetScriptableInfo() :
     1:             proto->GetScriptableInfo();
     1: 
     1:     // We just want to skip some classes...
 80389:     if (si) {
     1:         // Add any classnames to skip to this (null terminated) array...
     1:         static const char* skipClasses[] = {
     1:             "Window",
     1:             "HTMLDocument",
     1:             "HTMLCollection",
     1:             "Event",
     1:             "ChromeWindow",
     1:             nsnull
     1:         };
     1: 
 82794:         static bool warned = false;
 80389:         if (!warned) {
     1:             printf("!!! XPConnect won't warn about Shadowed Members of...\n  ");
     1:             for (const char** name = skipClasses; *name; name++)
     1:                 printf("%s %s", name == skipClasses ? "" : ",", *name);
     1:              printf("\n");
 82794:             warned = true;
 82794:         }
 82794: 
 82794:         bool quit = false;
     1:         char* className = nsnull;
     1:         si->GetCallback()->GetClassName(&className);
 80389:         if (className) {
 80389:             for (const char** name = skipClasses; *name; name++) {
 80389:                 if (!strcmp(*name, className)) {
 82794:                     quit = true;
     1:                     break;
     1:                 }
     1:             }
     1:             nsMemory::Free(className);
     1:         }
     1:         if (quit)
     1:             return;
     1:     }
     1: 
     1:     const char header[] =
     1:         "!!!Object wrapped by XPConnect has members whose names shadow each other!!!";
     1: 
 82794:     JSBool printedHeader = false;
     1: 
     1:     jsval QIName = rt->GetStringJSVal(XPCJSRuntime::IDX_QUERY_INTERFACE);
     1: 
     1:     PRUint16 ifaceCount = set->GetInterfaceCount();
     1:     PRUint16 i, j, k, m;
     1: 
     1:     // First look for duplicate interface entries
     1: 
 80389:     for (i = 0; i < ifaceCount; i++) {
     1:         XPCNativeInterface* ifaceOuter = set->GetInterfaceAt(i);
 80389:         for (k = i+1; k < ifaceCount; k++) {
     1:             XPCNativeInterface* ifaceInner = set->GetInterfaceAt(k);
 80389:             if (ifaceInner == ifaceOuter) {
     1:                 ShowHeader(&printedHeader, header, set, wrapper, proto);
     1:                 ShowDuplicateInterface(ifaceOuter->GetName());
     1:             }
     1:         }
     1:     }
     1: 
     1:     // Now scan for shadowing names
     1: 
 80389:     for (i = 0; i < ifaceCount; i++) {
     1:         XPCNativeInterface* ifaceOuter = set->GetInterfaceAt(i);
     1:         jsval ifaceOuterName = ifaceOuter->GetName();
     1: 
     1:         PRUint16 memberCountOuter = ifaceOuter->GetMemberCount();
 80389:         for (j = 0; j < memberCountOuter; j++) {
     1:             XPCNativeMember* memberOuter = ifaceOuter->GetMemberAt(j);
     1:             jsval memberOuterName = memberOuter->GetName();
     1: 
     1:             if (memberOuterName == QIName)
     1:                 continue;
     1: 
 80389:             for (k = i+1; k < ifaceCount; k++) {
     1:                 XPCNativeInterface* ifaceInner = set->GetInterfaceAt(k);
     1:                 jsval ifaceInnerName = ifaceInner->GetName();
     1: 
     1:                 // Reported elsewhere.
     1:                 if (ifaceInner == ifaceOuter)
     1:                     continue;
     1: 
     1:                 // We consider this not worth reporting because callers will
     1:                 // almost certainly be getting what they expect.
     1:                 if (InterfacesAreRelated(ifaceInner, ifaceOuter))
     1:                     continue;
     1: 
 80389:                 if (ifaceInnerName == memberOuterName) {
     1:                     ShowHeader(&printedHeader, header, set, wrapper, proto);
     1:                     ShowOneShadow(ifaceInnerName, JSVAL_NULL,
     1:                                   ifaceOuterName, memberOuterName);
     1:                 }
     1: 
     1:                 PRUint16 memberCountInner = ifaceInner->GetMemberCount();
     1: 
 80389:                 for (m = 0; m < memberCountInner; m++) {
     1:                     XPCNativeMember* memberInner = ifaceInner->GetMemberAt(m);
     1:                     jsval memberInnerName = memberInner->GetName();
     1: 
     1:                     if (memberInnerName == QIName)
     1:                         continue;
     1: 
     1:                     if (memberOuterName == memberInnerName &&
     1:                         !MembersAreTheSame(ifaceOuter, j, ifaceInner, m))
     1: 
     1:                     {
     1:                         ShowHeader(&printedHeader, header, set, wrapper, proto);
     1:                         ShowOneShadow(ifaceOuterName, memberOuterName,
     1:                                       ifaceInnerName, memberInnerName);
     1:                     }
     1:                 }
     1:             }
     1:         }
     1:     }
     1: }
     1: #endif
     1: 
     1: NS_IMPL_THREADSAFE_ISUPPORTS1(XPCJSObjectHolder, nsIXPConnectJSObjectHolder)
     1: 
     1: NS_IMETHODIMP
     1: XPCJSObjectHolder::GetJSObject(JSObject** aJSObj)
     1: {
     1:     NS_PRECONDITION(aJSObj, "bad param");
     1:     NS_PRECONDITION(mJSObj, "bad object state");
     1:     *aJSObj = mJSObj;
     1:     return NS_OK;
     1: }
     1: 
  2072: XPCJSObjectHolder::XPCJSObjectHolder(XPCCallContext& ccx, JSObject* obj)
  2072:     : mJSObj(obj)
     1: {
  2072:     ccx.GetRuntime()->AddObjectHolderRoot(this);
     1: }
     1: 
     1: XPCJSObjectHolder::~XPCJSObjectHolder()
     1: {
 57794:     RemoveFromRootSet(nsXPConnect::GetRuntimeInstance()->GetMapLock());
     1: }
     1: 
  2072: void
  2072: XPCJSObjectHolder::TraceJS(JSTracer *trc)
  2072: {
 98544:     JS_SET_TRACING_DETAILS(trc, GetTraceName, this, 0);
  2072:     JS_CallTracer(trc, mJSObj, JSTRACE_OBJECT);
  2072: }
  2072: 
  2072: // static
  2072: void
 98544: XPCJSObjectHolder::GetTraceName(JSTracer* trc, char *buf, size_t bufsize)
  2072: {
  2072:     JS_snprintf(buf, bufsize, "XPCJSObjectHolder[0x%p].mJSObj",
  2072:                 trc->debugPrintArg);
  2072: }
  2072: 
  2072: // static
     1: XPCJSObjectHolder*
  2072: XPCJSObjectHolder::newHolder(XPCCallContext& ccx, JSObject* obj)
     1: {
 80389:     if (!obj) {
 31561:         NS_ERROR("bad param");
     1:         return nsnull;
     1:     }
  2072:     return new XPCJSObjectHolder(ccx, obj);
     1: }
 30001: 
 30001: JSBool
 30001: MorphSlimWrapper(JSContext *cx, JSObject *obj)
 30001: {
 30001:     SLIM_LOG(("***** morphing from MorphSlimToWrapper (%p, %p)\n",
 30001:               obj, static_cast<nsISupports*>(xpc_GetJSPrivate(obj))));
 30001: 
 30001:     XPCCallContext ccx(JS_CALLER, cx);
 30001: 
 30001:     nsISupports* object = static_cast<nsISupports*>(xpc_GetJSPrivate(obj));
 30001:     nsWrapperCache *cache = nsnull;
 30001:     CallQueryInterface(object, &cache);
 30001:     nsRefPtr<XPCWrappedNative> wn;
 30001:     nsresult rv = XPCWrappedNative::Morph(ccx, obj, nsnull, cache,
 30001:                                           getter_AddRefs(wn));
 30001:     return NS_SUCCEEDED(rv);
 30001: }
 30001: 
 30001: #ifdef DEBUG_slimwrappers
 30001: static PRUint32 sSlimWrappers;
 30001: #endif
 30001: 
 30001: JSBool
 48124: ConstructSlimWrapper(XPCCallContext &ccx,
 51515:                      xpcObjectHelper &aHelper,
 31395:                      XPCWrappedNativeScope* xpcScope, jsval *rval)
 30001: {
 51515:     nsISupports *identityObj = aHelper.GetCanonical();
 51515:     nsXPCClassInfo *classInfoHelper = aHelper.GetXPCClassInfo();
 40489: 
102191:     XPCNativeScriptableFlags flags(classInfoHelper->GetScriptableFlags());
 40489: 
 40489:     NS_ASSERTION(flags.DontAskInstanceForScriptable(),
 40489:                  "Not supported for cached wrappers!");
 30001: 
 30001:     JSObject* parent = xpcScope->GetGlobalJSObject();
 80389:     if (!flags.WantPreCreate()) {
 30001:         SLIM_LOG_NOT_CREATED(ccx, identityObj,
 30001:                              "scriptable helper has no PreCreate hook");
 30001: 
 82794:         return false;
 30001:     }
 30001: 
 30001:     JSObject* plannedParent = parent;
102191:     nsresult rv = classInfoHelper->PreCreate(identityObj, ccx, parent, &parent);
 80389:     if (rv != NS_SUCCESS_ALLOW_SLIM_WRAPPERS) {
 30001:         SLIM_LOG_NOT_CREATED(ccx, identityObj, "PreCreate hook refused");
 30001: 
 82794:         return false;
 30001:     }
 30001: 
 86111:     if (!js::IsObjectInContextCompartment(parent, ccx.GetJSContext())) {
 55690:         SLIM_LOG_NOT_CREATED(ccx, identityObj, "wrong compartment");
 55690: 
 82794:         return false;
 55690:     }
 55690: 
 55601:     JSAutoEnterCompartment ac;
 80389:     if (!ac.enter(ccx, parent)) {
 55601:         SLIM_LOG_NOT_CREATED(ccx, identityObj, "unable to enter compartment");
 55601: 
 82794:         return false;
 55601:     }
 55601: 
 80389:     if (parent != plannedParent) {
 30001:         XPCWrappedNativeScope *newXpcScope =
 30001:             XPCWrappedNativeScope::FindInJSObjectScope(ccx, parent);
 80389:         if (newXpcScope != xpcScope) {
 30001:             SLIM_LOG_NOT_CREATED(ccx, identityObj, "crossing origins");
 30001: 
 82794:             return false;
 30001:         }
 30001:     }
 30001: 
 30384:     // The PreCreate hook could have forced the creation of a wrapper, need
 30384:     // to check for that here and return early.
 55577:     nsWrapperCache *cache = aHelper.GetWrapperCache();
 30384:     JSObject* wrapper = cache->GetWrapper();
 80389:     if (wrapper) {
 30384:         *rval = OBJECT_TO_JSVAL(wrapper);
 30384: 
 82794:         return true;
 30384:     }
 30384: 
 40493:     PRUint32 interfacesBitmap = classInfoHelper->GetInterfacesBitmap();
 40491:     XPCNativeScriptableCreateInfo
 51515:         sciProto(aHelper.forgetXPCClassInfo(), flags, interfacesBitmap);
 40489: 
 30001:     AutoMarkingWrappedNativeProtoPtr xpcproto(ccx);
 51515:     xpcproto = XPCWrappedNativeProto::GetNewOrUsed(ccx, xpcScope,
 91578:                                                    classInfoHelper, &sciProto);
 30001:     if (!xpcproto)
 82794:         return false;
 30001: 
 30001:     xpcproto->CacheOffsets(identityObj);
 30001: 
 30001:     XPCNativeScriptableInfo* si = xpcproto->GetScriptableInfo();
 30001:     JSClass* jsclazz = si->GetSlimJSClass();
 33785:     if (!jsclazz)
 82794:         return false;
 30001: 
 30384:     wrapper = xpc_NewSystemInheritingJSObject(ccx, jsclazz,
 30384:                                               xpcproto->GetJSProtoObject(),
 77343:                                               false, parent);
 89826:     if (!wrapper)
 82794:         return false;
 30001: 
 89826:     JS_SetPrivate(wrapper, identityObj);
101164:     SetSlimWrapperProto(wrapper, xpcproto.get());
 89826: 
 30001:     // Transfer ownership to the wrapper's private.
 51515:     aHelper.forgetCanonical();
 30001: 
 30001:     cache->SetWrapper(wrapper);
 30001: 
 30001:     SLIM_LOG(("+++++ %i created slim wrapper (%p, %p, %p)\n", ++sSlimWrappers,
 30001:               wrapper, p, xpcScope));
 30001: 
 30001:     *rval = OBJECT_TO_JSVAL(wrapper);
 30001: 
 82794:     return true;
 82794: }
