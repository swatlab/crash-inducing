16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:   function: LPC low level routines
31034:   last mod: $Id: lpc.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: /* Some of these routines (autocorrelator, LPC coefficient estimator)
16295:    are derived from code written by Jutta Degener and Carsten Bormann;
16295:    thus we include their copyright below.  The entirety of this file
16295:    is freely redistributable on the condition that both of these
16295:    copyright notices are preserved without modification.  */
16295: 
16295: /* Preserved Copyright: *********************************************/
16295: 
16295: /* Copyright 1992, 1993, 1994 by Jutta Degener and Carsten Bormann,
16295: Technische Universita"t Berlin
16295: 
16295: Any use of this software is permitted provided that this notice is not
16295: removed and that neither the authors nor the Technische Universita"t
16295: Berlin are deemed to have made any representations as to the
16295: suitability of this software for any purpose nor are held responsible
16295: for any defects of this software. THERE IS ABSOLUTELY NO WARRANTY FOR
16295: THIS SOFTWARE.
16295: 
16295: As a matter of courtesy, the authors request to be informed about uses
16295: this software has found, about bugs in this software, and about any
16295: improvements that may be of general interest.
16295: 
16295: Berlin, 28.11.1994
16295: Jutta Degener
16295: Carsten Bormann
16295: 
16295: *********************************************************************/
16295: 
16295: #include <stdlib.h>
16295: #include <string.h>
16295: #include <math.h>
16295: #include "os.h"
16295: #include "smallft.h"
16295: #include "lpc.h"
16295: #include "scales.h"
16295: #include "misc.h"
16295: 
16295: /* Autocorrelation LPC coeff generation algorithm invented by
16295:    N. Levinson in 1947, modified by J. Durbin in 1959. */
16295: 
16295: /* Input : n elements of time doamin data
16295:    Output: m lpc coefficients, excitation energy */
16295: 
16295: float vorbis_lpc_from_data(float *data,float *lpci,int n,int m){
16295:   double *aut=alloca(sizeof(*aut)*(m+1));
16295:   double *lpc=alloca(sizeof(*lpc)*(m));
16295:   double error;
30043:   double epsilon;
16295:   int i,j;
16295: 
16295:   /* autocorrelation, p+1 lag coefficients */
16295:   j=m+1;
16295:   while(j--){
16295:     double d=0; /* double needed for accumulator depth */
16295:     for(i=j;i<n;i++)d+=(double)data[i]*data[i-j];
16295:     aut[j]=d;
16295:   }
16295: 
16295:   /* Generate lpc coefficients from autocorr values */
16295: 
30043:   /* set our noise floor to about -100dB */
30043:   error=aut[0] * (1. + 1e-10);
30043:   epsilon=1e-9*aut[0]+1e-10;
16295: 
16295:   for(i=0;i<m;i++){
16295:     double r= -aut[i+1];
16295: 
30043:     if(error<epsilon){
30043:       memset(lpc+i,0,(m-i)*sizeof(*lpc));
30043:       goto done;
16295:     }
16295: 
16295:     /* Sum up this iteration's reflection coefficient; note that in
16295:        Vorbis we don't save it.  If anyone wants to recycle this code
16295:        and needs reflection coefficients, save the results of 'r' from
16295:        each iteration. */
16295: 
16295:     for(j=0;j<i;j++)r-=lpc[j]*aut[i-j];
16295:     r/=error;
16295: 
16295:     /* Update LPC coefficients and total error */
16295: 
16295:     lpc[i]=r;
16295:     for(j=0;j<i/2;j++){
16295:       double tmp=lpc[j];
16295: 
16295:       lpc[j]+=r*lpc[i-1-j];
16295:       lpc[i-1-j]+=r*tmp;
16295:     }
30043:     if(i&1)lpc[j]+=lpc[j]*r;
16295: 
30043:     error*=1.-r*r;
30043: 
30043:   }
30043: 
30043:  done:
30043: 
30043:   /* slightly damp the filter */
30043:   {
30043:     double g = .99;
30043:     double damp = g;
30043:     for(j=0;j<m;j++){
30043:       lpc[j]*=damp;
30043:       damp*=g;
30043:     }
16295:   }
16295: 
16295:   for(j=0;j<m;j++)lpci[j]=(float)lpc[j];
16295: 
16295:   /* we need the error value to know how big an impulse to hit the
16295:      filter with later */
16295: 
16295:   return error;
16295: }
16295: 
16295: void vorbis_lpc_predict(float *coeff,float *prime,int m,
16295:                      float *data,long n){
16295: 
16295:   /* in: coeff[0...m-1] LPC coefficients
16295:          prime[0...m-1] initial values (allocated size of n+m-1)
16295:     out: data[0...n-1] data samples */
16295: 
16295:   long i,j,o,p;
16295:   float y;
16295:   float *work=alloca(sizeof(*work)*(m+n));
16295: 
16295:   if(!prime)
16295:     for(i=0;i<m;i++)
16295:       work[i]=0.f;
16295:   else
16295:     for(i=0;i<m;i++)
16295:       work[i]=prime[i];
16295: 
16295:   for(i=0;i<n;i++){
16295:     y=0;
16295:     o=i;
16295:     p=m;
16295:     for(j=0;j<m;j++)
16295:       y-=work[o++]*coeff[--p];
16295: 
16295:     data[i]=work[o]=y;
16295:   }
16295: }
