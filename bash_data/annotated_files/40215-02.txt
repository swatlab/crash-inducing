    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License
    1:  * Version 1.1 (the "License"); you may not use this file except in
    1:  * compliance with the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is 
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Simon Fraser <sfraser@netscape.com>
    1:  *   Josh Aas <josh@mozilla.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or 
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsToolkit.h"
    1: 
    1: #include <ctype.h>
    1: #include <stdlib.h>
    1: #include <stdio.h>
    1: 
    1: #include <mach/mach_port.h>
    1: #include <mach/mach_interface.h>
    1: #include <mach/mach_init.h>
    1: 
40215: extern "C" {
40215: #include <mach-o/getsect.h>
40215: }
40215: #include <mach-o/dyld.h>
40215: #include <mach-o/nlist.h>
40215: #include <mach/vm_map.h>
40215: #include <unistd.h>
40215: #include <dlfcn.h>
40215: 
 1579: #import <Cocoa/Cocoa.h>
    1: #import <IOKit/pwr_mgt/IOPMLib.h>
    1: #import <IOKit/IOMessage.h>
    1: 
 3574: #include "nsCocoaUtils.h"
11978: #include "nsObjCExceptions.h"
 3574: 
    1: #include "nsWidgetAtoms.h"
 1579: #include "nsIRollupListener.h"
 1579: #include "nsIWidget.h"
    1: 
    1: #include "nsIObserverService.h"
    1: #include "nsIServiceManager.h"
 4686: #include "nsIPrefService.h"
 4686: #include "nsIPrefBranch.h"
    1: 
 1579: // defined in nsChildView.mm
 1579: extern nsIRollupListener * gRollupListener;
 1579: extern nsIWidget         * gRollupWidget;
 1579: 
    1: static io_connect_t gRootPort = MACH_PORT_NULL;
    1: 
    1: // Static thread local storage index of the Toolkit 
    1: // object associated with a given thread...
    1: static PRUintn gToolkitTLSIndex = 0;
    1: 
    1: nsToolkit::nsToolkit()
    1: : mInited(false)
    1: , mSleepWakeNotificationRLS(nsnull)
 3574: , mEventMonitorHandler(nsnull)
 3574: , mEventTapPort(nsnull)
 3574: , mEventTapRLS(nsnull)
    1: {
    1: }
    1: 
    1: nsToolkit::~nsToolkit()
    1: {
    1:   RemoveSleepWakeNotifcations();
 3574:   UnregisterAllProcessMouseEventHandlers();
    1:   // Remove the TLS reference to the toolkit...
    1:   PR_SetThreadPrivate(gToolkitTLSIndex, nsnull);
    1: }
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsToolkit, nsIToolkit);
    1: 
    1: NS_IMETHODIMP
    1: nsToolkit::Init(PRThread * aThread)
    1: {
    1:   nsWidgetAtoms::RegisterAtoms();
    1:   
    1:   mInited = true;
    1:   
    1:   RegisterForSleepWakeNotifcations();
 1579:   RegisterForAllProcessMouseEvents();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsToolkit* NS_CreateToolkitInstance()
    1: {
    1:   return new nsToolkit();
    1: }
    1: 
    1: void
    1: nsToolkit::PostSleepWakeNotification(const char* aNotification)
    1: {
    1:   nsCOMPtr<nsIObserverService> observerService = do_GetService("@mozilla.org/observer-service;1");
    1:   if (observerService)
    1:     observerService->NotifyObservers(nsnull, aNotification, nsnull);
    1: }
    1: 
    1: // http://developer.apple.com/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/PowerMgmt/chapter_10_section_3.html
    1: static void ToolkitSleepWakeCallback(void *refCon, io_service_t service, natural_t messageType, void * messageArgument)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   switch (messageType)
    1:   {
    1:     case kIOMessageSystemWillSleep:
    1:       // System is going to sleep now.
    1:       nsToolkit::PostSleepWakeNotification("sleep_notification");
    1:       ::IOAllowPowerChange(gRootPort, (long)messageArgument);
    1:       break;
    1:       
    1:     case kIOMessageCanSystemSleep:
    1:       // In this case, the computer has been idle for several minutes
    1:       // and will sleep soon so you must either allow or cancel
    1:       // this notification. Important: if you donâ€™t respond, there will
    1:       // be a 30-second timeout before the computer sleeps.
    1:       // In Mozilla's case, we always allow sleep.
    1:       ::IOAllowPowerChange(gRootPort,(long)messageArgument);
    1:       break;
    1:       
    1:     case kIOMessageSystemHasPoweredOn:
    1:       // Handle wakeup.
    1:       nsToolkit::PostSleepWakeNotification("wake_notification");
    1:       break;
    1:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
    1: nsresult
    1: nsToolkit::RegisterForSleepWakeNotifcations()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   IONotificationPortRef notifyPortRef;
    1: 
    1:   NS_ASSERTION(!mSleepWakeNotificationRLS, "Already registered for sleep/wake");
    1: 
    1:   gRootPort = ::IORegisterForSystemPower(0, &notifyPortRef, ToolkitSleepWakeCallback, &mPowerNotifier);
    1:   if (gRootPort == MACH_PORT_NULL) {
31561:     NS_ERROR("IORegisterForSystemPower failed");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   mSleepWakeNotificationRLS = ::IONotificationPortGetRunLoopSource(notifyPortRef);
    1:   ::CFRunLoopAddSource(::CFRunLoopGetCurrent(),
    1:                        mSleepWakeNotificationRLS,
    1:                        kCFRunLoopDefaultMode);
    1: 
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
    1: void
    1: nsToolkit::RemoveSleepWakeNotifcations()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
    1:   if (mSleepWakeNotificationRLS) {
    1:     ::IODeregisterForSystemPower(&mPowerNotifier);
    1:     ::CFRunLoopRemoveSource(::CFRunLoopGetCurrent(),
    1:                             mSleepWakeNotificationRLS,
    1:                             kCFRunLoopDefaultMode);
    1: 
    1:     mSleepWakeNotificationRLS = nsnull;
    1:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
    1: }
    1: 
35623: // This is the callback used in RegisterForAllProcessMouseEvents.
 3574: static OSStatus EventMonitorHandler(EventHandlerCallRef aCaller, EventRef aEvent, void* aRefcon)
 1579: {
35623:   // Up to Mac OS 10.4 (or when building with the 10.4 SDK), installing a Carbon
35623:   // event handler like this one caused the OS to post the equivalent Cocoa
35623:   // events to [NSApp sendEvent:]. When using the 10.5 SDK, this doesn't happen
35623:   // any more, so we need to do it manually.
35623:   [NSApp sendEvent:[NSEvent eventWithEventRef:aEvent]];
35623: 
 3574:   return eventNotHandledErr;
 1579: }
 1579: 
 3574: // Converts aPoint from the CoreGraphics "global display coordinate" system
 3574: // (which includes all displays/screens and has a top-left origin) to its
 3574: // (presumed) Cocoa counterpart (assumed to be the same as the "screen
 3574: // coordinates" system), which has a bottom-left origin.
 3574: static NSPoint ConvertCGGlobalToCocoaScreen(CGPoint aPoint)
 3574: {
 3574:   NSPoint cocoaPoint;
 3574:   cocoaPoint.x = aPoint.x;
 8779:   cocoaPoint.y = nsCocoaUtils::FlippedScreenY(aPoint.y);
 3574:   return cocoaPoint;
 1579: }
 1579: 
 3574: // Since our event tap is "listen only", events arrive here a little after
 3574: // they've already been processed.
 3574: static CGEventRef EventTapCallback(CGEventTapProxy proxy, CGEventType type, CGEventRef event, void *refcon)
 3574: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
 3574:   if ((type == kCGEventTapDisabledByUserInput) ||
 3574:       (type == kCGEventTapDisabledByTimeout))
 3574:     return event;
 3574:   if (!gRollupWidget || !gRollupListener || [NSApp isActive])
 3574:     return event;
 3574:   // Don't bother with rightMouseDown events here -- because of the delay,
 3574:   // we'll end up closing browser context menus that we just opened.  Since
 3574:   // these events usually raise a context menu, we'll handle them by hooking
 3574:   // the @"com.apple.HIToolbox.beginMenuTrackingNotification" distributed
 3574:   // notification (in nsAppShell.mm's AppShellDelegate).
 3574:   if (type == kCGEventRightMouseDown)
 3574:     return event;
 3574:   NSWindow *ctxMenuWindow = (NSWindow*) gRollupWidget->GetNativeData(NS_NATIVE_WINDOW);
 3574:   if (!ctxMenuWindow)
 3574:     return event;
 3574:   NSPoint screenLocation = ConvertCGGlobalToCocoaScreen(CGEventGetLocation(event));
 3574:   // Don't roll up the rollup widget if our mouseDown happens over it (doing
 3574:   // so would break the corresponding context menu).
 3574:   if (NSPointInRect(screenLocation, [ctxMenuWindow frame]))
 3574:     return event;
29148:   gRollupListener->Rollup(nsnull, nsnull);
 3574:   return event;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NULL);
 3574: }
 3574: 
 3574: // Cocoa Firefox's use of custom context menus requires that we explicitly
 3574: // handle mouse events from other processes that the OS handles
 3574: // "automatically" for native context menus -- mouseMoved events so that
 3574: // right-click context menus work properly when our browser doesn't have the
 3574: // focus (bmo bug 368077), and mouseDown events so that our browser can
 3574: // dismiss a context menu when a mouseDown happens in another process (bmo
 3574: // bug 339945).
 1579: void
 1579: nsToolkit::RegisterForAllProcessMouseEvents()
 1579: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 4686:   // Don't do this for apps that (like Camino) use native context menus.
 4686:   nsCOMPtr<nsIPrefBranch> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
 4686:   if (prefs) {
 4686:     PRBool useNativeContextMenus;
 4686:     nsresult rv = prefs->GetBoolPref("ui.use_native_popup_windows",
 4686:                                      &useNativeContextMenus);
 4686:     if (NS_SUCCEEDED(rv) && useNativeContextMenus)
 4686:       return;
 4686:   }
 3574:   if (!mEventMonitorHandler) {
 3574:     EventTypeSpec kEvents[] = {{kEventClassMouse, kEventMouseMoved}};
 3574:     InstallEventHandler(GetEventMonitorTarget(), EventMonitorHandler,
 3574:                         GetEventTypeCount(kEvents), kEvents, 0,
 3574:                         &mEventMonitorHandler);
 3574:   }
 3574:   if (!mEventTapRLS) {
 3574:     // Using an event tap for mouseDown events (instead of installing a
 3574:     // handler for them on the EventMonitor target) works around an Apple
 3574:     // bug that causes OS menus (like the Clock menu) not to work properly
 3574:     // on OS X 10.4.X and below (bmo bug 381448).
 3574:     // We install our event tap "listen only" to get around yet another Apple
 3574:     // bug -- when we install it as an event filter on any kind of mouseDown
 3574:     // event, that kind of event stops working in the main menu, and usually
 3574:     // mouse event processing stops working in all apps in the current login
 3574:     // session (so the entire OS appears to be hung)!  The downside of
 3574:     // installing listen-only is that events arrive at our handler slightly
 3574:     // after they've already been processed.
 3574:     mEventTapPort = CGEventTapCreate(kCGSessionEventTap,
 3574:                                      kCGHeadInsertEventTap,
 3574:                                      kCGEventTapOptionListenOnly,
 3574:                                      CGEventMaskBit(kCGEventLeftMouseDown)
 3574:                                        | CGEventMaskBit(kCGEventRightMouseDown)
 3574:                                        | CGEventMaskBit(kCGEventOtherMouseDown),
 3574:                                      EventTapCallback,
 3574:                                      nsnull);
 3574:     if (!mEventTapPort)
 3574:       return;
 3574:     mEventTapRLS = CFMachPortCreateRunLoopSource(nsnull, mEventTapPort, 0);
 3574:     if (!mEventTapRLS) {
 3574:       CFRelease(mEventTapPort);
 3574:       mEventTapPort = nsnull;
 3574:       return;
 3574:     }
 3574:     CFRunLoopAddSource(CFRunLoopGetCurrent(), mEventTapRLS, kCFRunLoopDefaultMode);
 3574:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 3574: }
 1579: 
 3574: void
 3574: nsToolkit::UnregisterAllProcessMouseEventHandlers()
 3574: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
11978: 
 3574:   if (mEventMonitorHandler) {
 3574:     RemoveEventHandler(mEventMonitorHandler);
 3574:     mEventMonitorHandler = nsnull;
 3574:   }
 3574:   if (mEventTapRLS) {
 3574:     CFRunLoopRemoveSource(CFRunLoopGetCurrent(), mEventTapRLS,
 3574:                           kCFRunLoopDefaultMode);
 3574:     CFRelease(mEventTapRLS);
 3574:     mEventTapRLS = nsnull;
 3574:   }
 3574:   if (mEventTapPort) {
23419:     // mEventTapPort must be invalidated as well as released.  Otherwise the
23419:     // event tap doesn't get destroyed until the browser process ends (it
23419:     // keeps showing up in the list returned by CGGetEventTapList()).
23419:     CFMachPortInvalidate(mEventTapPort);
 3574:     CFRelease(mEventTapPort);
 3574:     mEventTapPort = nsnull;
 3574:   }
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
 1579: }
 1579: 
    1: // Return the nsIToolkit for the current thread.  If a toolkit does not
    1: // yet exist, then one will be created...
11978: NS_IMETHODIMP NS_GetCurrentToolkit(nsIToolkit* *aResult)
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1:   *aResult = nsnull;
    1:   
    1:   // Create the TLS index the first time through...
    1:   if (gToolkitTLSIndex == 0) {
    1:     PRStatus status = PR_NewThreadPrivateIndex(&gToolkitTLSIndex, NULL);
    1:     if (PR_FAILURE == status)
    1:       return NS_ERROR_FAILURE;
    1:   }
    1:   
    1:   // Create a new toolkit for this thread...
    1:   nsToolkit* toolkit = (nsToolkit*)PR_GetThreadPrivate(gToolkitTLSIndex);
    1:   if (!toolkit) {
    1:     toolkit = NS_CreateToolkitInstance();
    1:     if (!toolkit)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     
    1:     NS_ADDREF(toolkit);
    1:     toolkit->Init(PR_GetCurrentThread());
    1:     //
    1:     // The reference stored in the TLS is weak.  It is removed in the
    1:     // nsToolkit destructor...
    1:     //
    1:     PR_SetThreadPrivate(gToolkitTLSIndex, (void*)toolkit);
    1:   }
    1:   else {
    1:     NS_ADDREF(toolkit);
    1:   }
    1:   *aResult = toolkit;
    1:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
    1: }
    1: 
31406: PRInt32 nsToolkit::OSXVersion()
    1: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
11978: 
31406:   static PRInt32 gOSXVersion = 0x0;
    1:   if (gOSXVersion == 0x0) {
31406:     OSErr err = ::Gestalt(gestaltSystemVersion, (SInt32*)&gOSXVersion);
    1:     if (err != noErr) {
    1:       // This should probably be changed when our minimum version changes
38441:       NS_ERROR("Couldn't determine OS X version, assuming 10.5");
38441:       gOSXVersion = MAC_OS_X_VERSION_10_5_HEX;
    1:     }
    1:   }
    1:   return gOSXVersion;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0);
    1: }
    1: 
32941: PRBool nsToolkit::OnSnowLeopardOrLater()
32941: {
32941:   return (OSXVersion() >= MAC_OS_X_VERSION_10_6_HEX);
    1: }
11675: 
11675: // An alternative to [NSObject poseAsClass:] that isn't deprecated on OS X
11675: // Leopard and is available to 64-bit binaries on Leopard and above.  Based on
11675: // ideas and code from http://www.cocoadev.com/index.pl?MethodSwizzling.
11675: // Since the Method type becomes an opaque type as of Objective-C 2.0, we'll
11675: // have to switch to using accessor methods like method_exchangeImplementations()
11675: // when we build 64-bit binaries that use Objective-C 2.0 (on and for Leopard
11675: // and above).  But these accessor methods aren't available in Objective-C 1
11675: // (or on Tiger).  So we need to access Method's members directly for (Tiger-
11675: // capable) binaries (32-bit or 64-bit) that use Objective-C 1 (as long as we
11675: // keep supporting Tiger).
11675: //
11675: // Be aware that, if aClass doesn't have an orgMethod selector but one of its
11675: // superclasses does, the method substitution will (in effect) take place in
11675: // that superclass (rather than in aClass itself).  The substitution has
11675: // effect on the class where it takes place and all of that class's
11675: // subclasses.  In order for method swizzling to work properly, posedMethod
11675: // needs to be unique in the class where the substitution takes place and all
11675: // of its subclasses.
13630: nsresult nsToolkit::SwizzleMethods(Class aClass, SEL orgMethod, SEL posedMethod,
13630:                                    PRBool classMethods)
11675: {
11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
11978: 
13630:   Method original = nil;
13630:   Method posed = nil;
13630: 
13630:   if (classMethods) {
13630:     original = class_getClassMethod(aClass, orgMethod);
13630:     posed = class_getClassMethod(aClass, posedMethod);
13630:   } else {
13630:     original = class_getInstanceMethod(aClass, orgMethod);
13630:     posed = class_getInstanceMethod(aClass, posedMethod);
13630:   }
11675: 
11675:   if (!original || !posed)
11675:     return NS_ERROR_FAILURE;
11675: 
31406: #ifdef __LP64__
31406:   method_exchangeImplementations(original, posed);
31406: #else
11675:   IMP aMethodImp = original->method_imp;
11675:   original->method_imp = posed->method_imp;
11675:   posed->method_imp = aMethodImp;
31406: #endif
11675: 
11675:   return NS_OK;
11978: 
11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
11675: }
40215: 
40215: #ifndef __LP64__
40215: 
40215: void ScanImportedFunctions(const struct mach_header* mh, intptr_t vmaddr_slide);
40215: 
40215: int gInWebInitForCarbonLevel = 0;
40215: 
40215: void Hooked_WebInitForCarbon();
40215: OSStatus Hooked_InstallEventLoopIdleTimer(
40215:    EventLoopRef inEventLoop,
40215:    EventTimerInterval inDelay,
40215:    EventTimerInterval inInterval,
40215:    EventLoopIdleTimerUPP inTimerProc,
40215:    void *inTimerData,
40215:    EventLoopTimerRef *outTimer
40215: );
40215: 
40215: void (*WebKit_WebInitForCarbon)() = NULL;
40215: OSStatus (*HIToolbox_InstallEventLoopIdleTimer)(
40215:    EventLoopRef inEventLoop,
40215:    EventTimerInterval inDelay,
40215:    EventTimerInterval inInterval,
40215:    EventLoopIdleTimerUPP inTimerProc,
40215:    void *inTimerData,
40215:    EventLoopTimerRef *outTimer
40215: ) = NULL;
40215: 
40215: typedef struct _nsHookedFunctionSpec {
40215:   const char *name;     // Includes leading underscore
40215:   void *newAddress;
40215:   void **oldAddressPtr;
40215: } nsHookedFunctionSpec;
40215: 
40215: nsHookedFunctionSpec gHookedFunctions[] = {
40215:   {"_WebInitForCarbon", (void *) Hooked_WebInitForCarbon,
40215:     (void **) &WebKit_WebInitForCarbon},
40215:   {"_InstallEventLoopIdleTimer", (void *) Hooked_InstallEventLoopIdleTimer,
40215:     (void **) &HIToolbox_InstallEventLoopIdleTimer},
40215:   {NULL, NULL, NULL}
40215: };
40215: 
40215: // Plugins may exist that use the WebKit framework.  Those that are
40215: // Carbon-based need to call WebKit's WebInitForCarbon() method.  There
40215: // currently appears to be only one Carbon WebKit plugin --
40215: // DivXBrowserPlugin (included with the DivX Web Player,
40215: // http://www.divx.com/en/downloads/divx/mac).  See bug 509130.
40215: //
40215: // The source-code for WebInitForCarbon() is in the WebKit source tree's
40215: // WebKit/mac/Carbon/CarbonUtils.mm file.  Among other things it installs
40215: // an idle timer on the main event loop, whose target is the PoolCleaner()
40215: // function (also in CarbonUtils.mm).  WebInitForCarbon() allocates an
40215: // NSAutoreleasePool object which it stores in the global sPool variable.
40215: // PoolCleaner() periodically releases/drains sPool and creates another
40215: // NSAutoreleasePool object to take its place.  The intention is to ensure
40215: // an autorelease pool is in place for whatever Objective-C code may be
40215: // called by WebKit code, and that it periodically gets "cleaned".  But we're
40215: // already doing this ourselves.  And PoolCleaner()'s periodic cleaning has a
40215: // very bad effect on us -- it causes objects to be deleted prematurely, so
40215: // that attempts to access them cause crashes.  This is probably because, when
40215: // WebInitForCarbon() is called from a plugin, one or more autorelease pools
40215: // are already in place.
40215: //
40215: // To get around this we hook/subclass WebInitForCarbon() and
40215: // InstallEventLoopIdleTimer() and make the latter return without doing
40215: // anything when called from the former.  This stops WebInitForCarbon()'s
40215: // (useless and harmful) idle timer from ever being installed.
40215: //
40215: // PoolCleaner() only "works" if the autorelease pool count (returned by
40215: // WKGetNSAutoreleasePoolCount(), stored in numPools) is the same as when
40215: // sPool was last set.  But WKGetNSAutoreleasePoolCount() only works on OS X
40215: // 10.5 and below.  So PoolCleaner() always fails 10.6 and above, and we
40215: // needn't do anything there.
40215: //
40215: // WKGetNSAutoreleasePoolCount() is a thin wrapper around the following code:
40215: //
40215: //   unsigned count = NSPushAutoreleasePool(0);
40215: //   NSPopAutoreleasePool(count);
40215: //   return count;
40215: //
40215: // NSPushAutoreleasePool() and NSPopAutoreleasePool() are undocumented
40215: // functions from the Foundation framework.  On OS X 10.5.X and below their
40215: // declarations are (as best I can tell) as follows.  ('capacity' is
40215: // presumably the initial capacity, in number of items, of the autorelease
40215: // pool to be created.)
40215: //
40215: //   unsigned NSPushAutoreleasePool(unsigned capacity);
40215: //   void NSPopAutoreleasePool(unsigned offset);
40215: //
40215: // But as of OS X 10.6 these functions appear to have changed as follows:
40215: //
40215: //   AutoreleasePool *NSPushAutoreleasePool(unsigned capacity);
40215: //   void NSPopAutoreleasePool(AutoreleasePool *aPool);
40215: 
40215: void Hooked_WebInitForCarbon()
40215: {
40215:   ++gInWebInitForCarbonLevel;
40215:   WebKit_WebInitForCarbon();
40215:   --gInWebInitForCarbonLevel;
40215: }
40215: 
40215: OSStatus Hooked_InstallEventLoopIdleTimer(
40215:    EventLoopRef inEventLoop,
40215:    EventTimerInterval inDelay,
40215:    EventTimerInterval inInterval,
40215:    EventLoopIdleTimerUPP inTimerProc,
40215:    void *inTimerData,
40215:    EventLoopTimerRef *outTimer
40215: )
40215: {
40215:   OSStatus rv = noErr;
40215:   if (gInWebInitForCarbonLevel <= 0) {
40215:     rv = HIToolbox_InstallEventLoopIdleTimer(inEventLoop, inDelay, inInterval,
40215:                                              inTimerProc, inTimerData, outTimer);
40215:   }
40215:   return rv;
40215: }
40215: 
40215: // Try to hook (or "subclass") the dynamically bound functions specified in
40215: // gHookedFunctions.  We don't hook these functions at their "original"
40215: // addresses, so we can only "subclass" calls to them from modules other than
40215: // the one in which they're defined.  Of course, this only works for globally
40215: // accessible functions.
40215: void HookImportedFunctions()
40215: {
40215:   // We currently only need to do anything on Tiger or Leopard.
40215:   if (nsToolkit::OnSnowLeopardOrLater())
40215:     return;
40215: 
40215:   // _dyld_register_func_for_add_image() makes the dynamic linker runtime call
40215:   // ScanImportedFunctions() "once for each of the images that are currently
40215:   // loaded into the program" (including the main image, i.e. firefox-bin).
40215:   // When a new image is added (e.g. a plugin), ScanImportedFunctions() is
40215:   // called again with data for that image.
40215:   //
40215:   // Calling HookImportedFunctions() from loadHandler's constructor (i.e. as
40215:   // the current module is being loaded) minimizes the likelihood that the
40215:   // imported functions in the already-loaded images will get called while
40215:   // we're resetting their pointers.
40215:   //
40215:   // _dyld_register_func_for_add_image()'s behavior when a new image is added
40215:   // allows us to reset its imported functions' pointers before they ever get
40215:   // called.
40215:   _dyld_register_func_for_add_image(ScanImportedFunctions);
40215: }
40215: 
40215: struct segment_command *GetSegmentFromMachHeader(const struct mach_header* mh,
40215:                                                  const char *segname,
40215:                                                  uint32_t *numFollowingCommands)
40215: {
40215:   if (numFollowingCommands)
40215:     *numFollowingCommands = 0;
40215:   uint32_t numCommands = mh->ncmds;
40215:   struct segment_command *aCommand = (struct segment_command *)
40215:     ((uint32_t)mh + sizeof(struct mach_header));
40215:   for (uint32_t i = 1; i <= numCommands; ++i) {
40215:     if (aCommand->cmd != LC_SEGMENT)
40215:       return NULL;
40215:     if (strcmp(segname, aCommand->segname) == 0) {
40215:       if (numFollowingCommands)
40215:         *numFollowingCommands = numCommands-i;
40215:       return aCommand;
40215:     }
40215:     aCommand = (struct segment_command *)
40215:       ((uint32_t)aCommand + aCommand->cmdsize);
40215:   }
40215:   return NULL;
40215: }
40215: 
40215: // Scan through parts of the "indirect symbol table" for imported functions
40215: // (functions dynamically bound from another module) whose names match those
40215: // we're trying to hook.  If we find one, change the corresponding pointer/
40215: // instruction in a "jump table" or "lazy pointer array" to point at the
40215: // function's replacement.  It appears we only need to look at "lazy bound"
40215: // symbols -- non-"lazy" symbols seem to always be for (imported) data.  (A
40215: // lazy bound symbol is one that's only resolved on first "use".)
40215: //
40215: // Most of what we do here is documented by Apple
40215: // (http://developer.apple.com/Mac/library/documentation/DeveloperTools/Conceptual/MachORuntime/Reference/reference.html,
40215: // http://developer.apple.com/mac/library/documentation/DeveloperTools/Reference/MachOReference/Reference/reference.html).
40215: // When Apple doesn't explicitly document something (e.g. the format of the
40215: // __LINKEDIT segment or the indirect symbol table), you can often get "hints"
40215: // from the output of 'otool -l' or 'otool -I".  And sometimes mach-o header
40215: // files contain additional information -- for example the format of the
40215: // indirect symbol table is described in the comment above the definitions of
40215: // INDIRECT_SYMBOL_LOCAL and INDIRECT_SYMBOL_ABS in mach-o/loader.h.
40215: //
40215: // The "__jump_table" section of the "__IMPORT" segment is an array of
40215: // assembler JMP or CALL instructions.  It's only present in i386 binaries
40215: // (ppc and x86_64 binaries use arrays of pointers).  Each instruction is
40215: // 5 bytes long.  The format is a byte-length opcode (0xE9 for JMP, 0xE8 for
40215: // CALL) followed by a four-byte relative address (relative to the start of
40215: // the next instruction in the table).  All the CALL instructions point to the
40215: // same code -- a 'dyld_stub_binding_helper()' that somehow locates the lazy-
40215: // bound function and replaces the CALL instruction with a JMP instruction
40215: // to the appropriate function.  If we replace the CALL instruction ourselves,
40215: // dyld_stub_binding_helper() never gets called (and never needs to be).
40215: void ScanImportedFunctions(const struct mach_header* mh, intptr_t vmaddr_slide)
40215: {
40215:   // While we're looking through all our images/modules, also scan for the
40215:   // original addresses of the functions we plan to hook.  Though
40215:   // NSLookupSymbolInImage() is deprecated (along with the entire NSModule
40215:   // API), it's by far the best (and most efficient) way to do what we need
40215:   // to do here (scan for the original addresses of symbols that aren't all
40215:   // loaded at the same time).  It's still available to 64-bit apps on OS X
40215:   // 10.6.X.
40215:   for (uint32_t i = 0; gHookedFunctions[i].name; ++i) {
40215:     // Since a symbol might be defined more than once, we record only its
40215:     // "first" address.
40215:     if (*gHookedFunctions[i].oldAddressPtr)
40215:       continue;
40215:     NSSymbol symbol =
40215:       NSLookupSymbolInImage(mh, gHookedFunctions[i].name,
40215:                             NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);
40215:     if (symbol)
40215:       *gHookedFunctions[i].oldAddressPtr = NSAddressOfSymbol(symbol);
40215:   }
40215: 
40215:   uint32_t numFollowingCommands = 0;
40215:   struct segment_command *linkeditSegment =
40215:     GetSegmentFromMachHeader(mh, "__LINKEDIT", &numFollowingCommands);
40215:   if (!linkeditSegment)
40215:     return;
40215:   uint32_t fileoffIncrement = linkeditSegment->vmaddr - linkeditSegment->fileoff;
40215: 
40215:   struct symtab_command *symtab =
40215:     (struct symtab_command *)((uint32_t)linkeditSegment + linkeditSegment->cmdsize);
40215:   for (uint32_t i = 1;; ++i) {
40215:     if (symtab->cmd == LC_SYMTAB)
40215:       break;
40215:     if (i == numFollowingCommands)
40215:       return;
40215:     symtab = (struct symtab_command *) ((uint32_t)symtab + symtab->cmdsize);
40215:   }
40215:   uint32_t symbolTableOffset = symtab->symoff + fileoffIncrement + vmaddr_slide;
40215:   uint32_t stringTableOffset = symtab->stroff + fileoffIncrement + vmaddr_slide;
40215: 
40215:   struct dysymtab_command *dysymtab =
40215:     (struct dysymtab_command *)((uint32_t)symtab + symtab->cmdsize);
40215:   if (dysymtab->cmd != LC_DYSYMTAB)
40215:     return;
40215:   uint32_t indirectSymbolTableOffset =
40215:     dysymtab->indirectsymoff + fileoffIncrement + vmaddr_slide;
40215: 
40215:   // Some i386 binaries on OS X 10.6.X use a __la_symbol_ptr section (in the
40215:   // __DATA segment) instead of a __jump_table section (in the __IMPORT
40215:   // segment).
40215:   const struct section *lazySymbols = NULL;
40215: #ifdef __i386__
40215:   struct segment_command *importSegment =
40215:     GetSegmentFromMachHeader(mh, "__IMPORT", nil);
40215:   const struct section *jumpTable =
40215:     getsectbynamefromheader(mh, "__IMPORT", "__jump_table");
40215:   if (!jumpTable)
40215: #endif
40215:   {
40215:     lazySymbols = getsectbynamefromheader(mh, "__DATA", "__la_symbol_ptr");
40215:     if (!lazySymbols)
40215:       return;
40215:   }
40215:   uint32_t numLazySymbols = 0;
40215:   uint32_t lazyBytes = 0;
40215:   unsigned char *lazy = NULL;
40215: #ifdef __i386__
40215:   uint32_t numJumpTableStubs = 0;
40215:   uint32_t stubsBytes = 0;
40215:   unsigned char *stubs = NULL;
40215:   vm_prot_t importSegProt = VM_PROT_NONE;
40215:   if (jumpTable) {
40215:     // Bail if we don't have an __IMPORT segment (which shouldn't be possible,
40215:     // but just in case).
40215:     if (!importSegment)
40215:       return;
40215:     importSegProt = importSegment->initprot;
40215:     // Bail if the size of each entry in the "jump table" isn't 5 bytes.
40215:     if (jumpTable->reserved2 != 5)
40215:       return;
40215:     numJumpTableStubs = jumpTable->size/5;
40215:     indirectSymbolTableOffset += jumpTable->reserved1*sizeof(uint32_t);
40215:     stubs = (unsigned char *)
40215:       (getsectdatafromheader(mh, "__IMPORT", "__jump_table", &stubsBytes) + vmaddr_slide);
40215:     // Bail if (for some reason) these figures don't agree.
40215:     if (stubsBytes != jumpTable->size)
40215:       return;
40215:   } else
40215: #endif
40215:   {
40215:     numLazySymbols = lazySymbols->size/4;
40215:     indirectSymbolTableOffset += lazySymbols->reserved1*sizeof(uint32_t);
40215:     lazy = (unsigned char *)
40215:       (getsectdatafromheader(mh, "__DATA", "__la_symbol_ptr", &lazyBytes) + vmaddr_slide);
40215:   }
40215: 
40215:   uint32_t items = 0;
40215: #ifdef __i386__
40215:   if (jumpTable) {
40215:     items = numJumpTableStubs;
40215:     // If the __IMPORT segment is read-only, we'll need to make it writeable
40215:     // before trying to change entries in its jump table.  Below we restore
40215:     // its original level of protection.
40215:     if (!(importSegProt & VM_PROT_WRITE)) {
40215:       void *protAddr = (void *) (importSegment->vmaddr + vmaddr_slide);
40215:       size_t protSize = importSegment->vmsize;
40215:       vm_protect(mach_task_self(), (vm_address_t) protAddr, protSize, NO,
40215:                  importSegProt | VM_PROT_WRITE);
40215:     }
40215:   } else
40215: #endif
40215:   {
40215:     items = numLazySymbols;
40215:   }
40215:   uint32_t *indirectSymbolTableItem = (uint32_t *) indirectSymbolTableOffset;
40215:   for (uint32_t i = 0; i < items; ++i, ++indirectSymbolTableItem) {
40215:     // Skip indirect symbol table items that are 0x80000000 (for a local
40215:     // symbol) and/or 0x40000000 (for an absolute symbol).  See
40215:     // mach-o/loader.h.
40215:     if (0xF0000000 & *indirectSymbolTableItem)
40215:       continue;
40215:     struct nlist *symbolTableItem = (struct nlist *)
40215:       (symbolTableOffset + *indirectSymbolTableItem*sizeof(struct nlist));
40215:     char *stringTableItem = (char *) (stringTableOffset + symbolTableItem->n_un.n_strx);
40215: 
40215:     for (uint32_t j = 0; gHookedFunctions[j].name; ++j) {
40215:       if (strcmp(stringTableItem, gHookedFunctions[j].name) != 0)
40215:         continue;
40215: #ifdef __i386__
40215:       if (jumpTable) {
40215:         unsigned char *opcodeAddr = stubs + (i * 5);
40215:         unsigned char oldOpcode = opcodeAddr[0];
40215:         int32_t *displacementAddr = (int32_t *) (opcodeAddr + 1);
40215:         int32_t eip = (int32_t) stubs + (i + 1) * 5;
40215:         int32_t displacement = (int32_t) (gHookedFunctions[j].newAddress) - eip;
40215:         displacementAddr[0] = displacement;
40215:         opcodeAddr[0] = 0xE9;
40215:       } else
40215: #endif
40215:       {
40215:         int32_t *lazySymbolAddr = (int32_t *) (lazy + (i * 4));
40215:         lazySymbolAddr[0] = (int32_t) (gHookedFunctions[j].newAddress);
40215:       }
40215:       break;
40215:     }
40215:   }
40215: 
40215: #ifdef __i386__
40215:   // If we needed to make an __IMPORT segment writeable above, restore its
40215:   // original protection level here.
40215:   if (jumpTable && !(importSegProt & VM_PROT_WRITE)) {
40215:     void *protAddr = (void *) (importSegment->vmaddr + vmaddr_slide);
40215:     size_t protSize = importSegment->vmsize;
40215:     vm_protect(mach_task_self(), (vm_address_t) protAddr, protSize,
40215:                NO, importSegProt);
40215:   }
40215: #endif
40215: }
40215: 
40215: class loadHandler
40215: {
40215: public:
40215:   loadHandler();
40215:   ~loadHandler() {}
40215: };
40215: 
40215: loadHandler::loadHandler()
40215: {
40215:   // Calling HookImportedFunctions() from here (i.e. as the current module is
40215:   // being loaded) minimizes the likelihood that the imported functions in
40215:   // the already-loaded images will get called while we're resetting their
40215:   // pointers.
40215:   HookImportedFunctions();
40215: }
40215: 
40215: loadHandler handler = loadHandler();
40215: 
40215: #endif // __LP64__
