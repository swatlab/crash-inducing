43129: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
43129: /* vim: set sw=2 ts=2 et tw=80: */
43129: /* ***** BEGIN LICENSE BLOCK *****
43129:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43129:  *
43129:  * The contents of this file are subject to the Mozilla Public License Version
43129:  * 1.1 (the "License"); you may not use this file except in compliance with
43129:  * the License. You may obtain a copy of the License at
43129:  * http://www.mozilla.org/MPL/
43129:  *
43129:  * Software distributed under the License is distributed on an "AS IS" basis,
43129:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43129:  * for the specific language governing rights and limitations under the
43129:  * License.
43129:  *
43129:  * The Original Code is Mozilla.org client code.
43129:  *
43129:  * The Initial Developer of the Original Code is Mozilla Foundation.
43129:  * Portions created by the Initial Developer are Copyright (C) 2009
43129:  * the Initial Developer. All Rights Reserved.
43129:  *
43129:  * Contributor(s):
43129:  *   Ehsan Akhgari <ehsan@mozilla.com> (Original Author)
43129:  *
43129:  * Alternatively, the contents of this file may be used under the terms of
43129:  * either of the GNU General Public License Version 2 or later (the "GPL"),
43129:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43129:  * in which case the provisions of the GPL or the LGPL are applicable instead
43129:  * of those above. If you wish to allow use of your version of this file only
43129:  * under the terms of either the GPL or the LGPL, and not to allow others to
43129:  * use your version of this file under the terms of the MPL, indicate your
43129:  * decision by deleting the provisions above and replace them with the notice
43129:  * and other provisions required by the GPL or the LGPL. If you do not delete
43129:  * the provisions above, a recipient may use your version of this file under
43129:  * the terms of any one of the MPL, the GPL or the LGPL.
43129:  *
43129:  * ***** END LICENSE BLOCK ***** */
43129: 
43129: #include "nsCOMPtr.h"
43129: #include "nsIPresShell.h"
43129: #include "nsIView.h"
43129: #include "nsCaret.h"
43129: #include "nsEditorCID.h"
43129: #include "nsLayoutCID.h"
43129: #include "nsITextControlFrame.h" 
43129: #include "nsIPlaintextEditor.h"
43129: #include "nsIDOMDocument.h"
43129: #include "nsContentCreatorFunctions.h"
43129: #include "nsTextControlFrame.h"
43129: #include "nsIControllers.h"
48892: #include "nsIDOMHTMLInputElement.h"
43129: #include "nsIDOMNSHTMLTextAreaElement.h"
43129: #include "nsITransactionManager.h"
43129: #include "nsIControllerContext.h"
43129: #include "nsAttrValue.h"
43129: #include "nsGenericHTMLElement.h"
43129: #include "nsIDOMKeyListener.h"
43129: #include "nsIEditorObserver.h"
43129: #include "nsINativeKeyBindings.h"
43129: #include "nsIDocumentEncoder.h"
43129: #include "nsISelectionPrivate.h"
43129: #include "nsPIDOMWindow.h"
43129: #include "nsServiceManagerUtils.h"
43129: #include "nsIDOMEventGroup.h"
43129: #include "nsIEditor.h"
43129: #include "nsTextEditRules.h"
43129: 
43129: #include "nsTextEditorState.h"
43129: 
56805: using namespace mozilla::dom;
56805: 
43129: static NS_DEFINE_CID(kTextEditorCID, NS_TEXTEDITOR_CID);
43129: 
43129: static nsINativeKeyBindings *sNativeInputBindings = nsnull;
43129: static nsINativeKeyBindings *sNativeTextAreaBindings = nsnull;
43129: 
55424: struct SelectionState {
55424:   PRInt32 mStart;
55424:   PRInt32 mEnd;
55424: };
55424: 
56444: class RestoreSelectionState : public nsRunnable {
56444: public:
68437:   RestoreSelectionState(nsTextEditorState *aState, nsTextControlFrame *aFrame,
68437:                         PRInt32 aStart, PRInt32 aEnd)
56444:     : mFrame(aFrame),
70659:       mWeakFrame(aFrame),
56444:       mStart(aStart),
68437:       mEnd(aEnd),
68437:       mTextEditorState(aState)
56444:   {
56444:   }
56444: 
56444:   NS_IMETHOD Run() {
70659:     if (mWeakFrame.IsAlive()) {
64662:       // SetSelectionRange leads to Selection::AddRange which flushes Layout -
64662:       // need to block script to avoid nested PrepareEditor calls (bug 642800).
64662:       nsAutoScriptBlocker scriptBlocker;
56444:       mFrame->SetSelectionRange(mStart, mEnd);
68437:       mTextEditorState->HideSelectionIfBlurred();
56444:     }
56444:     return NS_OK;
56444:   }
56444: 
56444: private:
56444:   nsTextControlFrame* mFrame;
70659:   nsWeakFrame mWeakFrame;
56444:   PRInt32 mStart;
56444:   PRInt32 mEnd;
68437:   nsTextEditorState* mTextEditorState;
56444: };
56444: 
43129: /*static*/
43129: PRBool
43129: nsITextControlElement::GetWrapPropertyEnum(nsIContent* aContent,
43129:   nsITextControlElement::nsHTMLTextWrap& aWrapProp)
43129: {
43129:   // soft is the default; "physical" defaults to soft as well because all other
43129:   // browsers treat it that way and there is no real reason to maintain physical
43129:   // and virtual as separate entities if no one else does.  Only hard and off
43129:   // do anything different.
43129:   aWrapProp = eHTMLTextWrap_Soft; // the default
43129: 
43129:   nsAutoString wrap;
43129:   if (aContent->IsHTML()) {
43129:     static nsIContent::AttrValuesArray strings[] =
43129:       {&nsGkAtoms::HARD, &nsGkAtoms::OFF, nsnull};
43129: 
43129:     switch (aContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::wrap,
43129:                                       strings, eIgnoreCase)) {
43129:       case 0: aWrapProp = eHTMLTextWrap_Hard; break;
43129:       case 1: aWrapProp = eHTMLTextWrap_Off; break;
43129:     }
43129: 
43129:     return PR_TRUE;
43129:   }
43129: 
43129:   return PR_FALSE;
43129: }
43129: 
43129: static PRBool
43129: SuppressEventHandlers(nsPresContext* aPresContext)
43129: {
43129:   PRBool suppressHandlers = PR_FALSE;
43129: 
43129:   if (aPresContext)
43129:   {
43129:     // Right now we only suppress event handlers and controller manipulation
43129:     // when in a print preview or print context!
43129: 
43129:     // In the current implementation, we only paginate when
43129:     // printing or in print preview.
43129: 
43129:     suppressHandlers = aPresContext->IsPaginated();
43129:   }
43129: 
43129:   return suppressHandlers;
43129: }
43129: 
43129: class nsAnonDivObserver : public nsStubMutationObserver
43129: {
43129: public:
43129:   nsAnonDivObserver(nsTextEditorState* aTextEditorState)
43129:   : mTextEditorState(aTextEditorState) {}
43129:   NS_DECL_ISUPPORTS
43129:   NS_DECL_NSIMUTATIONOBSERVER_CHARACTERDATACHANGED
43129:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
43129:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
43129:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
43129: 
43129: private:
43129:   nsTextEditorState* mTextEditorState;
43129: };
43129: 
43129: class nsTextInputSelectionImpl : public nsSupportsWeakReference
43129:                                , public nsISelectionController
43129: {
43129: public:
43129:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
43129:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsTextInputSelectionImpl, nsISelectionController)
43129: 
43129:   nsTextInputSelectionImpl(nsFrameSelection *aSel, nsIPresShell *aShell, nsIContent *aLimiter);
43129:   ~nsTextInputSelectionImpl(){}
43129: 
43129:   void SetScrollableFrame(nsIScrollableFrame *aScrollableFrame);
43129:   nsFrameSelection* GetConstFrameSelection()
43129:     { return mFrameSelection; }
43129: 
43129:   //NSISELECTIONCONTROLLER INTERFACES
43129:   NS_IMETHOD SetDisplaySelection(PRInt16 toggle);
43129:   NS_IMETHOD GetDisplaySelection(PRInt16 *_retval);
43129:   NS_IMETHOD SetSelectionFlags(PRInt16 aInEnable);
43129:   NS_IMETHOD GetSelectionFlags(PRInt16 *aOutEnable);
43129:   NS_IMETHOD GetSelection(PRInt16 type, nsISelection **_retval);
56442:   NS_IMETHOD ScrollSelectionIntoView(PRInt16 aType, PRInt16 aRegion, PRInt16 aFlags);
43129:   NS_IMETHOD RepaintSelection(PRInt16 type);
43129:   NS_IMETHOD RepaintSelection(nsPresContext* aPresContext, SelectionType aSelectionType);
43129:   NS_IMETHOD SetCaretEnabled(PRBool enabled);
43129:   NS_IMETHOD SetCaretReadOnly(PRBool aReadOnly);
43129:   NS_IMETHOD GetCaretEnabled(PRBool *_retval);
43129:   NS_IMETHOD GetCaretVisible(PRBool *_retval);
43129:   NS_IMETHOD SetCaretVisibilityDuringSelection(PRBool aVisibility);
43129:   NS_IMETHOD CharacterMove(PRBool aForward, PRBool aExtend);
43129:   NS_IMETHOD CharacterExtendForDelete();
43298:   NS_IMETHOD CharacterExtendForBackspace();
43129:   NS_IMETHOD WordMove(PRBool aForward, PRBool aExtend);
43129:   NS_IMETHOD WordExtendForDelete(PRBool aForward);
43129:   NS_IMETHOD LineMove(PRBool aForward, PRBool aExtend);
43129:   NS_IMETHOD IntraLineMove(PRBool aForward, PRBool aExtend);
43129:   NS_IMETHOD PageMove(PRBool aForward, PRBool aExtend);
43129:   NS_IMETHOD CompleteScroll(PRBool aForward);
43129:   NS_IMETHOD CompleteMove(PRBool aForward, PRBool aExtend);
43129:   NS_IMETHOD ScrollPage(PRBool aForward);
43129:   NS_IMETHOD ScrollLine(PRBool aForward);
43129:   NS_IMETHOD ScrollHorizontal(PRBool aLeft);
43129:   NS_IMETHOD SelectAll(void);
43129:   NS_IMETHOD CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, PRBool *_retval);
43129: 
43129: private:
70097:   nsRefPtr<nsFrameSelection> mFrameSelection;
43129:   nsCOMPtr<nsIContent>       mLimiter;
43129:   nsIScrollableFrame        *mScrollFrame;
43129:   nsWeakPtr mPresShellWeak;
43129: };
43129: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsTextInputSelectionImpl)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsTextInputSelectionImpl)
43129: NS_INTERFACE_TABLE_HEAD(nsTextInputSelectionImpl)
43129:   NS_INTERFACE_TABLE3(nsTextInputSelectionImpl,
43129:                       nsISelectionController,
43129:                       nsISelectionDisplay,
43129:                       nsISupportsWeakReference)
43129:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsTextInputSelectionImpl)
43129: NS_INTERFACE_MAP_END
43129: 
70355: NS_IMPL_CYCLE_COLLECTION_2(nsTextInputSelectionImpl, mFrameSelection, mLimiter)
43129: 
43129: 
43129: // BEGIN nsTextInputSelectionImpl
43129: 
43129: nsTextInputSelectionImpl::nsTextInputSelectionImpl(nsFrameSelection *aSel,
43129:                                                    nsIPresShell *aShell,
43129:                                                    nsIContent *aLimiter)
43129:   : mScrollFrame(nsnull)
43129: {
43129:   if (aSel && aShell)
43129:   {
43129:     mFrameSelection = aSel;//we are the owner now!
43129:     mLimiter = aLimiter;
43129:     mFrameSelection->Init(aShell, mLimiter);
43129:     mPresShellWeak = do_GetWeakReference(aShell);
43129:   }
43129: }
43129: 
43129: void
43129: nsTextInputSelectionImpl::SetScrollableFrame(nsIScrollableFrame *aScrollableFrame)
43129: {
43129:   mScrollFrame = aScrollableFrame;
43129:   if (!mScrollFrame && mFrameSelection) {
43129:     mFrameSelection->DisconnectFromPresShell();
43129:     mFrameSelection = nsnull;
43129:   }
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::SetDisplaySelection(PRInt16 aToggle)
43129: {
43129:   if (!mFrameSelection)
43129:     return NS_ERROR_NULL_POINTER;
43129:   
43129:   mFrameSelection->SetDisplaySelection(aToggle);
43129:   return NS_OK;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::GetDisplaySelection(PRInt16 *aToggle)
43129: {
43129:   if (!mFrameSelection)
43129:     return NS_ERROR_NULL_POINTER;
43129: 
43129:   *aToggle = mFrameSelection->GetDisplaySelection();
43129:   return NS_OK;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::SetSelectionFlags(PRInt16 aToggle)
43129: {
43129:   return NS_OK;//stub this out. not used in input
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::GetSelectionFlags(PRInt16 *aOutEnable)
43129: {
43129:   *aOutEnable = nsISelectionDisplay::DISPLAY_TEXT;
43129:   return NS_OK; 
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::GetSelection(PRInt16 type, nsISelection **_retval)
43129: {
43129:   if (!mFrameSelection)
43129:     return NS_ERROR_NULL_POINTER;
43129:     
43129:   *_retval = mFrameSelection->GetSelection(type);
43129:   
43129:   if (!(*_retval))
43129:     return NS_ERROR_FAILURE;
43129: 
43129:   NS_ADDREF(*_retval);
43129:   return NS_OK;
43129: }
43129: 
43129: NS_IMETHODIMP
56442: nsTextInputSelectionImpl::ScrollSelectionIntoView(PRInt16 aType, PRInt16 aRegion, PRInt16 aFlags)
43129: {
43129:   if (!mFrameSelection) 
43129:     return NS_ERROR_FAILURE; 
43129: 
56442:   return mFrameSelection->ScrollSelectionIntoView(aType, aRegion, aFlags);
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::RepaintSelection(PRInt16 type)
43129: {
43129:   if (!mFrameSelection)
43129:     return NS_ERROR_FAILURE;
43129: 
43129:   return mFrameSelection->RepaintSelection(type);
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::RepaintSelection(nsPresContext* aPresContext, SelectionType aSelectionType)
43129: {
43129:   if (!mFrameSelection)
43129:     return NS_ERROR_FAILURE;
43129: 
43129:   return mFrameSelection->RepaintSelection(aSelectionType);
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::SetCaretEnabled(PRBool enabled)
43129: {
43129:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
43129: 
43129:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak);
43129:   if (!shell) return NS_ERROR_FAILURE;
43129: 
43129:   // tell the pres shell to enable the caret, rather than settings its visibility directly.
43129:   // this way the presShell's idea of caret visibility is maintained.
43129:   nsCOMPtr<nsISelectionController> selCon = do_QueryInterface(shell);
43129:   if (!selCon) return NS_ERROR_NO_INTERFACE;
43129:   selCon->SetCaretEnabled(enabled);
43129: 
43129:   return NS_OK;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::SetCaretReadOnly(PRBool aReadOnly)
43129: {
43129:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
43129:   nsresult result;
43129:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
43129:   if (shell)
43129:   {
43129:     nsRefPtr<nsCaret> caret = shell->GetCaret();
43129:     if (caret) {
43129:       nsISelection* domSel = mFrameSelection->
43129:         GetSelection(nsISelectionController::SELECTION_NORMAL);
43129:       if (domSel)
43129:         caret->SetCaretReadOnly(aReadOnly);
43129:       return NS_OK;
43129:     }
43129:   }
43129:   return NS_ERROR_FAILURE;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::GetCaretEnabled(PRBool *_retval)
43129: {
43129:   return GetCaretVisible(_retval);
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::GetCaretVisible(PRBool *_retval)
43129: {
43129:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
43129:   nsresult result;
43129:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
43129:   if (shell)
43129:   {
43129:     nsRefPtr<nsCaret> caret = shell->GetCaret();
43129:     if (caret) {
43129:       nsISelection* domSel = mFrameSelection->
43129:         GetSelection(nsISelectionController::SELECTION_NORMAL);
43129:       if (domSel)
43129:         return caret->GetCaretVisible(_retval);
43129:     }
43129:   }
43129:   return NS_ERROR_FAILURE;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::SetCaretVisibilityDuringSelection(PRBool aVisibility)
43129: {
43129:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
43129:   nsresult result;
43129:   nsCOMPtr<nsIPresShell> shell = do_QueryReferent(mPresShellWeak, &result);
43129:   if (shell)
43129:   {
43129:     nsRefPtr<nsCaret> caret = shell->GetCaret();
43129:     if (caret) {
43129:       nsISelection* domSel = mFrameSelection->
43129:         GetSelection(nsISelectionController::SELECTION_NORMAL);
43129:       if (domSel)
43129:         caret->SetVisibilityDuringSelection(aVisibility);
43129:       return NS_OK;
43129:     }
43129:   }
43129:   return NS_ERROR_FAILURE;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::CharacterMove(PRBool aForward, PRBool aExtend)
43129: {
43129:   if (mFrameSelection)
43129:     return mFrameSelection->CharacterMove(aForward, aExtend);
43129:   return NS_ERROR_NULL_POINTER;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::CharacterExtendForDelete()
43129: {
43129:   if (mFrameSelection)
43129:     return mFrameSelection->CharacterExtendForDelete();
43129:   return NS_ERROR_NULL_POINTER;
43129: }
43129: 
43129: NS_IMETHODIMP
43298: nsTextInputSelectionImpl::CharacterExtendForBackspace()
43298: {
43298:   if (mFrameSelection)
43298:     return mFrameSelection->CharacterExtendForBackspace();
43298:   return NS_ERROR_NULL_POINTER;
43298: }
43298: 
43298: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::WordMove(PRBool aForward, PRBool aExtend)
43129: {
43129:   if (mFrameSelection)
43129:     return mFrameSelection->WordMove(aForward, aExtend);
43129:   return NS_ERROR_NULL_POINTER;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::WordExtendForDelete(PRBool aForward)
43129: {
43129:   if (mFrameSelection)
43129:     return mFrameSelection->WordExtendForDelete(aForward);
43129:   return NS_ERROR_NULL_POINTER;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::LineMove(PRBool aForward, PRBool aExtend)
43129: {
43129:   if (mFrameSelection)
43129:   {
43129:     nsresult result = mFrameSelection->LineMove(aForward, aExtend);
43129:     if (NS_FAILED(result))
43129:       result = CompleteMove(aForward,aExtend);
43129:     return result;
43129:   }
43129:   return NS_ERROR_NULL_POINTER;
43129: }
43129: 
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::IntraLineMove(PRBool aForward, PRBool aExtend)
43129: {
43129:   if (mFrameSelection)
43129:     return mFrameSelection->IntraLineMove(aForward, aExtend);
43129:   return NS_ERROR_NULL_POINTER;
43129: }
43129: 
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::PageMove(PRBool aForward, PRBool aExtend)
43129: {
43129:   // expected behavior for PageMove is to scroll AND move the caret
43129:   // and to remain relative position of the caret in view. see Bug 4302.
43129:   if (mScrollFrame)
43129:   {
43129:     mFrameSelection->CommonPageMove(aForward, aExtend, mScrollFrame);
43129:   }
43129:   // After ScrollSelectionIntoView(), the pending notifications might be
43129:   // flushed and PresShell/PresContext/Frames may be dead. See bug 418470.
56442:   return ScrollSelectionIntoView(nsISelectionController::SELECTION_NORMAL, nsISelectionController::SELECTION_FOCUS_REGION,
56442:                                  nsISelectionController::SCROLL_SYNCHRONOUS);
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::CompleteScroll(PRBool aForward)
43129: {
43129:   if (!mScrollFrame)
43129:     return NS_ERROR_NOT_INITIALIZED;
43129: 
43129:   mScrollFrame->ScrollBy(nsIntPoint(0, aForward ? 1 : -1),
43129:                          nsIScrollableFrame::WHOLE,
43129:                          nsIScrollableFrame::INSTANT);
43129:   return NS_OK;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::CompleteMove(PRBool aForward, PRBool aExtend)
43129: {
43129:   // grab the parent / root DIV for this text widget
43129:   nsIContent* parentDIV = mFrameSelection->GetLimiter();
43129:   if (!parentDIV)
43129:     return NS_ERROR_UNEXPECTED;
43129: 
43129:   // make the caret be either at the very beginning (0) or the very end
43129:   PRInt32 offset = 0;
43129:   nsFrameSelection::HINT hint = nsFrameSelection::HINTLEFT;
43129:   if (aForward)
43129:   {
43129:     offset = parentDIV->GetChildCount();
43129: 
43129:     // Prevent the caret from being placed after the last
43129:     // BR node in the content tree!
43129: 
43129:     if (offset > 0)
43129:     {
43129:       nsIContent *child = parentDIV->GetChildAt(offset - 1);
43129: 
43129:       if (child->Tag() == nsGkAtoms::br)
43129:       {
43129:         --offset;
43129:         hint = nsFrameSelection::HINTRIGHT; // for Bug 106855
43129:       }
43129:     }
43129:   }
43129: 
43129:   mFrameSelection->HandleClick(parentDIV, offset, offset, aExtend,
43129:                                PR_FALSE, hint);
43129: 
43129:   // if we got this far, attempt to scroll no matter what the above result is
43129:   return CompleteScroll(aForward);
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::ScrollPage(PRBool aForward)
43129: {
43129:   if (!mScrollFrame)
43129:     return NS_ERROR_NOT_INITIALIZED;
43129: 
43129:   mScrollFrame->ScrollBy(nsIntPoint(0, aForward ? 1 : -1),
43129:                          nsIScrollableFrame::PAGES,
43129:                          nsIScrollableFrame::SMOOTH);
43129:   return NS_OK;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::ScrollLine(PRBool aForward)
43129: {
43129:   if (!mScrollFrame)
43129:     return NS_ERROR_NOT_INITIALIZED;
43129: 
43129:   mScrollFrame->ScrollBy(nsIntPoint(0, aForward ? 1 : -1),
43129:                          nsIScrollableFrame::LINES,
43129:                          nsIScrollableFrame::SMOOTH);
43129:   return NS_OK;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::ScrollHorizontal(PRBool aLeft)
43129: {
43129:   if (!mScrollFrame)
43129:     return NS_ERROR_NOT_INITIALIZED;
43129: 
43129:   mScrollFrame->ScrollBy(nsIntPoint(aLeft ? -1 : 1, 0),
43129:                          nsIScrollableFrame::LINES,
43129:                          nsIScrollableFrame::SMOOTH);
43129:   return NS_OK;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::SelectAll()
43129: {
43129:   if (mFrameSelection)
43129:     return mFrameSelection->SelectAll();
43129:   return NS_ERROR_NULL_POINTER;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputSelectionImpl::CheckVisibility(nsIDOMNode *node, PRInt16 startOffset, PRInt16 EndOffset, PRBool *_retval)
43129: {
43129:   if (!mPresShellWeak) return NS_ERROR_NOT_INITIALIZED;
43129:   nsresult result;
43129:   nsCOMPtr<nsISelectionController> shell = do_QueryReferent(mPresShellWeak, &result);
43129:   if (shell)
43129:   {
43129:     return shell->CheckVisibility(node,startOffset,EndOffset, _retval);
43129:   }
43129:   return NS_ERROR_FAILURE;
43129: 
43129: }
43129: 
43129: class nsTextInputListener : public nsISelectionListener,
43129:                             public nsIDOMKeyListener,
43129:                             public nsIEditorObserver,
43129:                             public nsSupportsWeakReference
43129: {
43129: public:
43129:   /** the default constructor
43129:    */ 
43129:   explicit nsTextInputListener(nsITextControlElement* aTxtCtrlElement);
43129:   /** the default destructor. virtual due to the possibility of derivation.
43129:    */
43129:   virtual ~nsTextInputListener();
43129: 
43129:   /** SetEditor gives an address to the editor that will be accessed
43129:    *  @param aEditor the editor this listener calls for editing operations
43129:    */
43129:   void SetFrame(nsTextControlFrame *aFrame){mFrame = aFrame;}
43129: 
55124:   void SettingValue(PRBool aValue) { mSettingValue = aValue; }
55124: 
43129:   NS_DECL_ISUPPORTS
43129: 
43129:   NS_DECL_NSISELECTIONLISTENER
43129: 
43129:   NS_IMETHOD HandleEvent(nsIDOMEvent* aEvent);
43129: 
43129:   // nsIDOMKeyListener
43129:   NS_IMETHOD KeyDown(nsIDOMEvent *aKeyEvent);
43129:   NS_IMETHOD KeyPress(nsIDOMEvent *aKeyEvent);
43129:   NS_IMETHOD KeyUp(nsIDOMEvent *aKeyEvent);
43129: 
43129:   NS_DECL_NSIEDITOROBSERVER
43129: 
43129: protected:
43129: 
43129:   nsresult  UpdateTextInputCommands(const nsAString& commandsToUpdate);
43129: 
43129:   NS_HIDDEN_(nsINativeKeyBindings*) GetKeyBindings();
43129: 
43129: protected:
43129: 
70659:   nsWeakFrame mFrame;
43129: 
43129:   nsITextControlElement* const mTxtCtrlElement;
43129: 
43129:   PRPackedBool    mSelectionWasCollapsed;
43129:   /**
43129:    * Whether we had undo items or not the last time we got EditAction()
43129:    * notification (when this state changes we update undo and redo menus)
43129:    */
43129:   PRPackedBool    mHadUndoItems;
43129:   /**
43129:    * Whether we had redo items or not the last time we got EditAction()
43129:    * notification (when this state changes we update undo and redo menus)
43129:    */
43129:   PRPackedBool    mHadRedoItems;
55124:   /**
55124:    * Whether we're in the process of a SetValue call, and should therefore
55124:    * refrain from calling OnValueChanged.
55124:    */
55124:   PRPackedBool mSettingValue;
43129: };
43129: 
43129: 
43129: /*
43129:  * nsTextInputListener implementation
43129:  */
43129: 
43129: nsTextInputListener::nsTextInputListener(nsITextControlElement* aTxtCtrlElement)
70659: : mTxtCtrlElement(aTxtCtrlElement)
43129: , mSelectionWasCollapsed(PR_TRUE)
43129: , mHadUndoItems(PR_FALSE)
43129: , mHadRedoItems(PR_FALSE)
55124: , mSettingValue(PR_FALSE)
43129: {
43129: }
43129: 
43129: nsTextInputListener::~nsTextInputListener() 
43129: {
43129: }
43129: 
43129: NS_IMPL_ADDREF(nsTextInputListener)
43129: NS_IMPL_RELEASE(nsTextInputListener)
43129: 
43129: NS_INTERFACE_MAP_BEGIN(nsTextInputListener)
43129:   NS_INTERFACE_MAP_ENTRY(nsISelectionListener)
43129:   NS_INTERFACE_MAP_ENTRY(nsIEditorObserver)
43129:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
43129:   NS_INTERFACE_MAP_ENTRY(nsIDOMKeyListener)
43129:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsIDOMEventListener, nsIDOMKeyListener)
43129:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMKeyListener)
43129: NS_INTERFACE_MAP_END
43129: 
43129: // BEGIN nsIDOMSelectionListener
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputListener::NotifySelectionChanged(nsIDOMDocument* aDoc, nsISelection* aSel, PRInt16 aReason)
43129: {
43129:   PRBool collapsed;
70659:   if (!mFrame.IsAlive() || !aDoc || !aSel || NS_FAILED(aSel->GetIsCollapsed(&collapsed)))
43129:     return NS_OK;
43129: 
43129:   // Fire the select event
43129:   // The specs don't exactly say when we should fire the select event.
43129:   // IE: Whenever you add/remove a character to/from the selection. Also
43129:   //     each time for select all. Also if you get to the end of the text 
43129:   //     field you will get new event for each keypress or a continuous 
43129:   //     stream of events if you use the mouse. IE will fire select event 
43129:   //     when the selection collapses to nothing if you are holding down
43129:   //     the shift or mouse button.
43129:   // Mozilla: If we have non-empty selection we will fire a new event for each
43129:   //          keypress (or mouseup) if the selection changed. Mozilla will also
43129:   //          create the event each time select all is called, even if everything
43129:   //          was previously selected, becase technically select all will first collapse
43129:   //          and then extend. Mozilla will never create an event if the selection 
43129:   //          collapses to nothing.
43129:   if (!collapsed && (aReason & (nsISelectionListener::MOUSEUP_REASON | 
43129:                                 nsISelectionListener::KEYPRESS_REASON |
43129:                                 nsISelectionListener::SELECTALL_REASON)))
43129:   {
43129:     nsIContent* content = mFrame->GetContent();
43129:     if (content) 
43129:     {
43129:       nsCOMPtr<nsIDocument> doc = content->GetDocument();
43129:       if (doc) 
43129:       {
46225:         nsCOMPtr<nsIPresShell> presShell = doc->GetShell();
43129:         if (presShell) 
43129:         {
43129:           nsEventStatus status = nsEventStatus_eIgnore;
43129:           nsEvent event(PR_TRUE, NS_FORM_SELECTED);
43129: 
43129:           presShell->HandleEventWithTarget(&event, mFrame, content, &status);
43129:         }
43129:       }
43129:     }
43129:   }
43129: 
43129:   // if the collapsed state did not change, don't fire notifications
43129:   if (collapsed == mSelectionWasCollapsed)
43129:     return NS_OK;
43129:   
43129:   mSelectionWasCollapsed = collapsed;
43129: 
70659:   if (!mFrame.IsAlive() || !nsContentUtils::IsFocusedContent(mFrame->GetContent()))
43129:     return NS_OK;
43129: 
43129:   return UpdateTextInputCommands(NS_LITERAL_STRING("select"));
43129: }
43129: 
43129: // END nsIDOMSelectionListener
43129: 
43129: // BEGIN nsIDOMKeyListener
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputListener::HandleEvent(nsIDOMEvent* aEvent)
43129: {
43129:   return NS_OK;
43129: }
43129: 
43129: static void
43129: DoCommandCallback(const char *aCommand, void *aData)
43129: {
43129:   nsTextControlFrame *frame = static_cast<nsTextControlFrame*>(aData);
43129:   nsIContent *content = frame->GetContent();
43129: 
43129:   nsCOMPtr<nsIControllers> controllers;
48892:   nsCOMPtr<nsIDOMHTMLInputElement> input = do_QueryInterface(content);
43129:   if (input) {
43129:     input->GetControllers(getter_AddRefs(controllers));
43129:   } else {
43129:     nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textArea =
43129:       do_QueryInterface(content);
43129: 
43129:     if (textArea) {
43129:       textArea->GetControllers(getter_AddRefs(controllers));
43129:     }
43129:   }
43129: 
43129:   if (!controllers) {
43129:     NS_WARNING("Could not get controllers");
43129:     return;
43129:   }
43129: 
43129:   nsCOMPtr<nsIController> controller;
43129:   controllers->GetControllerForCommand(aCommand, getter_AddRefs(controller));
43129:   if (controller) {
43129:     controller->DoCommand(aCommand);
43129:   }
43129: }
43129: 
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputListener::KeyDown(nsIDOMEvent *aDOMEvent)
43129: {
70659:   NS_ENSURE_STATE(mFrame.IsAlive());
43129:   nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aDOMEvent));
43129:   NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
43129: 
43129:   nsNativeKeyEvent nativeEvent;
43129:   nsINativeKeyBindings *bindings = GetKeyBindings();
43129:   if (bindings &&
43129:       nsContentUtils::DOMEventToNativeKeyEvent(keyEvent, &nativeEvent, PR_FALSE)) {
43129:     if (bindings->KeyDown(nativeEvent, DoCommandCallback, mFrame)) {
43129:       aDOMEvent->PreventDefault();
43129:     }
43129:   }
43129: 
43129:   return NS_OK;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputListener::KeyPress(nsIDOMEvent *aDOMEvent)
43129: {
70659:   NS_ENSURE_STATE(mFrame.IsAlive());
43129:   nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aDOMEvent));
43129:   NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
43129: 
43129:   nsNativeKeyEvent nativeEvent;
43129:   nsINativeKeyBindings *bindings = GetKeyBindings();
43129:   if (bindings &&
43129:       nsContentUtils::DOMEventToNativeKeyEvent(keyEvent, &nativeEvent, PR_TRUE)) {
43129:     if (bindings->KeyPress(nativeEvent, DoCommandCallback, mFrame)) {
43129:       aDOMEvent->PreventDefault();
43129:     }
43129:   }
43129: 
43129:   return NS_OK;
43129: }
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputListener::KeyUp(nsIDOMEvent *aDOMEvent)
43129: {
70659:   NS_ENSURE_STATE(mFrame.IsAlive());
43129:   nsCOMPtr<nsIDOMKeyEvent> keyEvent(do_QueryInterface(aDOMEvent));
43129:   NS_ENSURE_TRUE(keyEvent, NS_ERROR_INVALID_ARG);
43129: 
43129:   nsNativeKeyEvent nativeEvent;
43129:   nsINativeKeyBindings *bindings = GetKeyBindings();
43129:   if (bindings &&
43129:       nsContentUtils::DOMEventToNativeKeyEvent(keyEvent, &nativeEvent, PR_FALSE)) {
43129:     if (bindings->KeyUp(nativeEvent, DoCommandCallback, mFrame)) {
43129:       aDOMEvent->PreventDefault();
43129:     }
43129:   }
43129: 
43129:   return NS_OK;
43129: }
43129: // END nsIDOMKeyListener
43129: 
43129: // BEGIN nsIEditorObserver
43129: 
43129: NS_IMETHODIMP
43129: nsTextInputListener::EditAction()
43129: {
70659:   NS_ENSURE_STATE(mFrame.IsAlive());
70659:   nsITextControlFrame* frameBase = do_QueryFrame(mFrame.GetFrame());
60698:   nsTextControlFrame* frame = static_cast<nsTextControlFrame*> (frameBase);
60698:   NS_ASSERTION(frame, "Where is our frame?");
43129:   //
43129:   // Update the undo / redo menus
43129:   //
43129:   nsCOMPtr<nsIEditor> editor;
60698:   frame->GetEditor(getter_AddRefs(editor));
43129: 
43129:   nsCOMPtr<nsITransactionManager> manager;
43129:   editor->GetTransactionManager(getter_AddRefs(manager));
43129:   NS_ENSURE_TRUE(manager, NS_ERROR_FAILURE);
43129: 
43129:   // Get the number of undo / redo items
43129:   PRInt32 numUndoItems = 0;
43129:   PRInt32 numRedoItems = 0;
43129:   manager->GetNumberOfUndoItems(&numUndoItems);
43129:   manager->GetNumberOfRedoItems(&numRedoItems);
43129:   if ((numUndoItems && !mHadUndoItems) || (!numUndoItems && mHadUndoItems) ||
43129:       (numRedoItems && !mHadRedoItems) || (!numRedoItems && mHadRedoItems)) {
43129:     // Modify the menu if undo or redo items are different
43129:     UpdateTextInputCommands(NS_LITERAL_STRING("undo"));
43129: 
43129:     mHadUndoItems = numUndoItems != 0;
43129:     mHadRedoItems = numRedoItems != 0;
43129:   }
43129: 
70659:   if (!mFrame.IsAlive()) {
60698:     return NS_OK;
60698:   }
60698: 
43129:   // Make sure we know we were changed (do NOT set this to false if there are
43129:   // no undo items; JS could change the value and we'd still need to save it)
60698:   frame->SetValueChanged(PR_TRUE);
43129: 
55124:   if (!mSettingValue) {
51178:     mTxtCtrlElement->OnValueChanged(PR_TRUE);
55124:   }
51178: 
59446:   // Fire input event
59460:   PRBool trusted = PR_FALSE;
67852:   editor->GetLastKeypressEventTrusted(&trusted);
60698:   frame->FireOnInput(trusted);
60698: 
60698:   // mFrame may be dead after this, but we don't need to check for it, because
60698:   // we are not uisng it in this function any more.
59446: 
43129:   return NS_OK;
43129: }
43129: 
43129: // END nsIEditorObserver
43129: 
43129: 
43129: nsresult
43129: nsTextInputListener::UpdateTextInputCommands(const nsAString& commandsToUpdate)
43129: {
70659:   NS_ENSURE_STATE(mFrame.IsAlive());
70659: 
43129:   nsIContent* content = mFrame->GetContent();
43129:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
43129:   
43129:   nsCOMPtr<nsIDocument> doc = content->GetDocument();
43129:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
43129: 
43129:   nsPIDOMWindow *domWindow = doc->GetWindow();
43129:   NS_ENSURE_TRUE(domWindow, NS_ERROR_FAILURE);
43129: 
43129:   return domWindow->UpdateCommands(commandsToUpdate);
43129: }
43129: 
43129: nsINativeKeyBindings*
43129: nsTextInputListener::GetKeyBindings()
43129: {
43129:   if (mTxtCtrlElement->IsTextArea()) {
43129:     static PRBool sNoTextAreaBindings = PR_FALSE;
43129: 
43129:     if (!sNativeTextAreaBindings && !sNoTextAreaBindings) {
43129:       CallGetService(NS_NATIVEKEYBINDINGS_CONTRACTID_PREFIX "textarea",
43129:                      &sNativeTextAreaBindings);
43129: 
43129:       if (!sNativeTextAreaBindings) {
43129:         sNoTextAreaBindings = PR_TRUE;
43129:       }
43129:     }
43129: 
43129:     return sNativeTextAreaBindings;
43129:   }
43129: 
43129:   static PRBool sNoInputBindings = PR_FALSE;
43129:   if (!sNativeInputBindings && !sNoInputBindings) {
43129:     CallGetService(NS_NATIVEKEYBINDINGS_CONTRACTID_PREFIX "input",
43129:                    &sNativeInputBindings);
43129: 
43129:     if (!sNativeInputBindings) {
43129:       sNoInputBindings = PR_TRUE;
43129:     }
43129:   }
43129: 
43129:   return sNativeInputBindings;
43129: }
43129: 
43129: // END nsTextInputListener
43129: 
43129: // nsTextEditorState
43129: 
43129: nsTextEditorState::nsTextEditorState(nsITextControlElement* aOwningElement)
43129:   : mTextCtrlElement(aOwningElement),
43129:     mBoundFrame(nsnull),
43129:     mTextListener(nsnull),
48847:     mEditorInitialized(PR_FALSE),
48847:     mInitializing(PR_FALSE)
43129: {
43129:   MOZ_COUNT_CTOR(nsTextEditorState);
43129: }
43129: 
43129: nsTextEditorState::~nsTextEditorState()
43129: {
43129:   MOZ_COUNT_DTOR(nsTextEditorState);
43129:   Clear();
43129: }
43129: 
43129: void
43129: nsTextEditorState::Clear()
43129: {
43129:   if (mBoundFrame) {
43129:     // Oops, we still have a frame!
43129:     // This should happen when the type of a text input control is being changed
43129:     // to something which is not a text control.  In this case, we should pretend
43129:     // that a frame is being destroyed, and clean up after ourselves properly.
43129:     UnbindFromFrame(mBoundFrame);
43129:     mEditor = nsnull;
43129:   } else {
43129:     // If we have a bound frame around, UnbindFromFrame will call DestroyEditor
43129:     // for us.
43129:     DestroyEditor();
43129:   }
43129:   NS_IF_RELEASE(mTextListener);
43129: }
43129: 
43129: NS_IMPL_CYCLE_COLLECTION_CLASS(nsTextEditorState)
43129: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsTextEditorState, AddRef)
43129: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsTextEditorState, Release)
43129: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_NATIVE(nsTextEditorState)
43129:   tmp->Clear();
43129: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
43129: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsTextEditorState)
43129:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mSelCon, nsISelectionController)
43129:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mEditor)
43129:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRootNode)
43129:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPlaceholderDiv)
43129: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
43129: 
43129: nsFrameSelection*
43129: nsTextEditorState::GetConstFrameSelection() {
43129:   if (mSelCon)
43129:     return mSelCon->GetConstFrameSelection();
43129:   return nsnull;
43129: }
43129: 
43129: nsIEditor*
43129: nsTextEditorState::GetEditor()
43129: {
43129:   if (!mEditor) {
43129:     nsresult rv = PrepareEditor();
43129:     NS_ENSURE_SUCCESS(rv, nsnull);
43129:   }
43129:   return mEditor;
43129: }
43129: 
43129: nsISelectionController*
43129: nsTextEditorState::GetSelectionController() const
43129: {
43129:   return mSelCon;
43129: }
43129: 
47892: // Helper class, used below in BindToFrame().
47892: class PrepareEditorEvent : public nsRunnable {
47892: public:
47892:   PrepareEditorEvent(nsTextEditorState &aState,
47892:                      nsIContent *aOwnerContent,
47892:                      const nsAString &aCurrentValue)
47892:     : mState(aState)
47892:     , mOwnerContent(aOwnerContent)
47892:     , mCurrentValue(aCurrentValue)
47892:   {
47892:   }
47892: 
47892:   NS_IMETHOD Run() {
47892:     // Transfer the saved value to the editor if we have one
47892:     const nsAString *value = nsnull;
47892:     if (!mCurrentValue.IsEmpty()) {
47892:       value = &mCurrentValue;
47892:     }
47892: 
47892:     mState.PrepareEditor(value);
47892: 
47892:     return NS_OK;
47892:   }
47892: 
47892: private:
47892:   nsTextEditorState &mState;
47892:   nsCOMPtr<nsIContent> mOwnerContent; // strong reference
47892:   nsAutoString mCurrentValue;
47892: };
47892: 
43129: nsresult
43129: nsTextEditorState::BindToFrame(nsTextControlFrame* aFrame)
43129: {
43129:   NS_ASSERTION(aFrame, "The frame to bind to should be valid");
43129:   NS_ENSURE_ARG_POINTER(aFrame);
43129: 
43129:   NS_ASSERTION(!mBoundFrame, "Cannot bind twice, need to unbind first");
43129:   NS_ENSURE_TRUE(!mBoundFrame, NS_ERROR_FAILURE);
43129: 
43129:   // If we'll need to transfer our current value to the editor, save it before
43129:   // binding to the frame.
43129:   nsAutoString currentValue;
43129:   if (mEditor) {
43129:     GetValue(currentValue, PR_TRUE);
43129:   }
43129: 
43129:   mBoundFrame = aFrame;
43129: 
43129:   nsIContent *rootNode = GetRootNode();
43129: 
43129:   nsIPresShell *shell = mBoundFrame->PresContext()->GetPresShell();
43129:   NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
43129: 
43129:   // Create selection
70098:   nsRefPtr<nsFrameSelection> frameSel = new nsFrameSelection();
43129: 
43129:   // Create a SelectionController
43129:   mSelCon = new nsTextInputSelectionImpl(frameSel, shell, rootNode);
43129:   NS_ENSURE_TRUE(mSelCon, NS_ERROR_OUT_OF_MEMORY);
43129:   mTextListener = new nsTextInputListener(mTextCtrlElement);
43129:   NS_ENSURE_TRUE(mTextListener, NS_ERROR_OUT_OF_MEMORY);
43129:   NS_ADDREF(mTextListener);
43129: 
43129:   mTextListener->SetFrame(mBoundFrame);
43129:   mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_ON);
43129: 
43129:   // Get the caret and make it a selection listener.
43129:   nsRefPtr<nsISelection> domSelection;
43129:   if (NS_SUCCEEDED(mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
43129:                                          getter_AddRefs(domSelection))) &&
43129:       domSelection) {
43129:     nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(domSelection));
43129:     nsRefPtr<nsCaret> caret = shell->GetCaret();
43129:     nsCOMPtr<nsISelectionListener> listener;
43129:     if (caret) {
43129:       listener = do_QueryInterface(caret);
43129:       if (listener) {
43129:         selPriv->AddSelectionListener(listener);
43129:       }
43129:     }
43129: 
43129:     selPriv->AddSelectionListener(static_cast<nsISelectionListener*>
43129:                                              (mTextListener));
43129:   }
43129: 
43129:   // If an editor exists from before, prepare it for usage
43129:   if (mEditor) {
43129:     nsCOMPtr<nsIContent> content = do_QueryInterface(mTextCtrlElement);
43129:     NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
43129: 
61556:     // Set the correct direction on the newly created root node
61556:     PRUint32 flags;
70098:     nsresult rv = mEditor->GetFlags(&flags);
61556:     NS_ENSURE_SUCCESS(rv, rv);
61556:     if (flags & nsIPlaintextEditor::eEditorRightToLeft) {
61556:       rootNode->SetAttr(kNameSpaceID_None, nsGkAtoms::dir, NS_LITERAL_STRING("rtl"), PR_FALSE);
61556:     } else if (flags & nsIPlaintextEditor::eEditorLeftToRight) {
61556:       rootNode->SetAttr(kNameSpaceID_None, nsGkAtoms::dir, NS_LITERAL_STRING("ltr"), PR_FALSE);
61556:     } else {
61556:       // otherwise, inherit the content node's direction
61556:     }
61556: 
43129:     if (!nsContentUtils::AddScriptRunner(
43129:           new PrepareEditorEvent(*this, content, currentValue)))
43129:       return NS_ERROR_OUT_OF_MEMORY;
43129:   }
43129: 
43129:   return NS_OK;
43129: }
43129: 
43129: nsresult
43129: nsTextEditorState::PrepareEditor(const nsAString *aValue)
43129: {
43129:   if (!mBoundFrame) {
43129:     // Cannot create an editor without a bound frame.
43129:     // Don't return a failure code, because js callers can't handle that.
43129:     return NS_OK;
43129:   }
43129: 
43129:   if (mEditorInitialized) {
43129:     // Do not initialize the editor multiple times.
43129:     return NS_OK;
43129:   }
43129: 
48847:   // Don't attempt to initialize recursively!
48847:   InitializationGuard guard(*this);
48847:   if (guard.IsInitializingRecursively()) {
48847:     return NS_ERROR_NOT_INITIALIZED;
48847:   }
48847: 
43129:   // Note that we don't check mEditor here, because we might already have one
43129:   // around, in which case we don't create a new one, and we'll just tie the
43129:   // required machinery to it.
43129: 
43129:   nsPresContext *presContext = mBoundFrame->PresContext();
43129:   nsIPresShell *shell = presContext->GetPresShell();
43129: 
43129:   // Setup the editor flags
43129:   PRUint32 editorFlags = 0;
43129:   if (IsPlainTextControl())
43129:     editorFlags |= nsIPlaintextEditor::eEditorPlaintextMask;
43129:   if (IsSingleLineTextControl())
43129:     editorFlags |= nsIPlaintextEditor::eEditorSingleLineMask;
43129:   if (IsPasswordTextControl())
43129:     editorFlags |= nsIPlaintextEditor::eEditorPasswordMask;
43129: 
43129:   // All nsTextControlFrames are widgets
43129:   editorFlags |= nsIPlaintextEditor::eEditorWidgetMask;
43129: 
43129:   // Use async reflow and painting for text widgets to improve
43129:   // performance.
55121:   editorFlags |= nsIPlaintextEditor::eEditorUseAsyncUpdatesMask;
43129: 
43129:   PRBool shouldInitializeEditor = PR_FALSE;
43129:   nsCOMPtr<nsIEditor> newEditor; // the editor that we might create
43129:   nsresult rv;
43129:   if (!mEditor) {
43129:     shouldInitializeEditor = PR_TRUE;
43129: 
43129:     // Create an editor
43129:     newEditor = do_CreateInstance(kTextEditorCID, &rv);
43129:     NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:     // Make sure we clear out the non-breaking space before we initialize the editor
43129:     rv = mBoundFrame->UpdateValueDisplay(PR_FALSE, PR_TRUE);
43129:     NS_ENSURE_SUCCESS(rv, rv);
43129:   } else {
55872:     if (aValue || !mEditorInitialized) {
43129:       // Set the correct value in the root node
55872:       rv = mBoundFrame->UpdateValueDisplay(PR_TRUE, !mEditorInitialized, aValue);
43129:       NS_ENSURE_SUCCESS(rv, rv);
43129:     }
43129: 
43129:     newEditor = mEditor; // just pretend that we have a new editor!
43129:   }
43129: 
43129:   if (!mEditorInitialized) {
43129:     // Now initialize the editor.
43129:     //
43129:     // NOTE: Conversion of '\n' to <BR> happens inside the
43129:     //       editor's Init() call.
43129: 
43129:     // Get the DOM document
43129:     nsCOMPtr<nsIDOMDocument> domdoc = do_QueryInterface(shell->GetDocument());
43129:     if (!domdoc)
43129:       return NS_ERROR_FAILURE;
43129: 
43129:     // What follows is a bit of a hack.  The editor uses the public DOM APIs
43129:     // for its content manipulations, and it causes it to fail some security
43129:     // checks deep inside when initializing.  So we push a null JSContext
43129:     // on the JS stack here to make it clear that we're native code.
43129:     // Note that any script that's directly trying to access our value
43129:     // has to be going through some scriptable object to do that and that
43129:     // already does the relevant security checks.
43129:     nsCxPusher pusher;
43129:     pusher.PushNull();
43129: 
63592:     rv = newEditor->Init(domdoc, GetRootNode(), mSelCon, editorFlags);
43129:     NS_ENSURE_SUCCESS(rv, rv);
43129:   }
43129: 
43129:   // Initialize the controller for the editor
43129: 
43129:   if (!SuppressEventHandlers(presContext)) {
43129:     nsCOMPtr<nsIControllers> controllers;
48892:     nsCOMPtr<nsIDOMHTMLInputElement> inputElement =
43129:       do_QueryInterface(mTextCtrlElement);
43129:     if (inputElement) {
43129:       rv = inputElement->GetControllers(getter_AddRefs(controllers));
43129:     } else {
43129:       nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textAreaElement =
43129:         do_QueryInterface(mTextCtrlElement);
43129: 
43129:       if (!textAreaElement)
43129:         return NS_ERROR_FAILURE;
43129: 
43129:       rv = textAreaElement->GetControllers(getter_AddRefs(controllers));
43129:     }
43129: 
43129:     NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:     if (controllers) {
43129:       PRUint32 numControllers;
43129:       PRBool found = PR_FALSE;
43129:       rv = controllers->GetControllerCount(&numControllers);
43129:       for (PRUint32 i = 0; i < numControllers; i ++) {
43129:         nsCOMPtr<nsIController> controller;
43129:         rv = controllers->GetControllerAt(i, getter_AddRefs(controller));
43129:         if (NS_SUCCEEDED(rv) && controller) {
43129:           nsCOMPtr<nsIControllerContext> editController =
43129:             do_QueryInterface(controller);
43129:           if (editController) {
43129:             editController->SetCommandContext(newEditor);
43129:             found = PR_TRUE;
43129:           }
43129:         }
43129:       }
43129:       if (!found)
43129:         rv = NS_ERROR_FAILURE;
43129:     }
43129:   }
43129: 
43129:   if (shouldInitializeEditor) {
43129:     // Initialize the plaintext editor
43129:     nsCOMPtr<nsIPlaintextEditor> textEditor(do_QueryInterface(newEditor));
43129:     if (textEditor) {
43129:       // Set up wrapping
43129:       textEditor->SetWrapColumn(GetWrapCols());
43129: 
43129:       // Set max text field length
43129:       PRInt32 maxLength;
43129:       if (GetMaxLength(&maxLength)) { 
43129:         textEditor->SetMaxTextLength(maxLength);
43129:       }
43129:     }
43129:   }
43129: 
43129:   nsCOMPtr<nsIContent> content = do_QueryInterface(mTextCtrlElement);
43129:   if (content) {
43129:     rv = newEditor->GetFlags(&editorFlags);
43129:     NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:     // Check if the readonly attribute is set.
43129:     if (content->HasAttr(kNameSpaceID_None, nsGkAtoms::readonly))
43129:       editorFlags |= nsIPlaintextEditor::eEditorReadonlyMask;
43129: 
43129:     // Check if the disabled attribute is set.
54342:     // TODO: call IsDisabled() here!
43129:     if (content->HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) 
43129:       editorFlags |= nsIPlaintextEditor::eEditorDisabledMask;
43129: 
43129:     // Disable the selection if necessary.
43129:     if (editorFlags & nsIPlaintextEditor::eEditorDisabledMask)
43129:       mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_OFF);
43129: 
43129:     newEditor->SetFlags(editorFlags);
43129:   }
43129: 
43129:   // Get the current value of the textfield from the content.
43129:   // Note that if we've created a new editor, mEditor is null at this stage,
43129:   // so we will get the real value from the content.
43129:   nsAutoString defaultValue;
43129:   if (aValue) {
43129:     defaultValue = *aValue;
43129:   } else {
43129:     GetValue(defaultValue, PR_TRUE);
43129:   }
43129: 
43129:   if (shouldInitializeEditor) {
43129:     // Hold on to the newly created editor
43129:     mEditor = newEditor;
43129:   }
43129: 
43129:   // If we have a default value, insert it under the div we created
43129:   // above, but be sure to use the editor so that '*' characters get
43129:   // displayed for password fields, etc. SetValue() will call the
43129:   // editor for us.
43129: 
43129:   if (!defaultValue.IsEmpty()) {
43129:     // Avoid causing reentrant painting and reflowing by telling the editor
43129:     // that we don't want it to force immediate view refreshes or force
43129:     // immediate reflows during any editor calls.
43129: 
43129:     rv = newEditor->SetFlags(editorFlags |
43129:                              nsIPlaintextEditor::eEditorUseAsyncUpdatesMask);
43129:     NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:     // Now call SetValue() which will make the necessary editor calls to set
43129:     // the default value.  Make sure to turn off undo before setting the default
43129:     // value, and turn it back on afterwards. This will make sure we can't undo
43129:     // past the default value.
43129: 
43129:     rv = newEditor->EnableUndo(PR_FALSE);
43129:     NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:     SetValue(defaultValue, PR_FALSE);
43129: 
43129:     rv = newEditor->EnableUndo(PR_TRUE);
43129:     NS_ASSERTION(NS_SUCCEEDED(rv),"Transaction Manager must have failed");
43129: 
43129:     // Now restore the original editor flags.
43129:     rv = newEditor->SetFlags(editorFlags);
43129:     NS_ENSURE_SUCCESS(rv, rv);
43129:   }
43129: 
43129:   nsCOMPtr<nsITransactionManager> transMgr;
43129:   newEditor->GetTransactionManager(getter_AddRefs(transMgr));
43129:   NS_ENSURE_TRUE(transMgr, NS_ERROR_FAILURE);
43129: 
43129:   transMgr->SetMaxTransactionCount(nsITextControlElement::DEFAULT_UNDO_CAP);
43129: 
43129:   if (IsPasswordTextControl()) {
43129:     // Disable undo for password textfields.  Note that we want to do this at
43129:     // the very end of InitEditor, so the calls to EnableUndo when setting the
43129:     // default value don't screw us up.
43129:     // Since changing the control type does a reframe, we don't have to worry
43129:     // about dynamic type changes here.
43129:     newEditor->EnableUndo(PR_FALSE);
43129:   }
43129: 
43129:   if (!mEditorInitialized) {
43129:     newEditor->PostCreate();
43129:     mEditorInitialized = PR_TRUE;
43129:   }
43129: 
43129:   if (mTextListener)
43129:     newEditor->AddEditorObserver(mTextListener);
43129: 
55424:   // Restore our selection after being bound to a new frame
55424:   if (mSelState) {
70659:     nsContentUtils::AddScriptRunner(new RestoreSelectionState(this, mBoundFrame, mSelState->mStart, mSelState->mEnd));
55424:     mSelState = nsnull;
55424:   }
55424: 
43129:   return rv;
43129: }
43129: 
43129: void
43129: nsTextEditorState::DestroyEditor()
43129: {
43129:   // notify the editor that we are going away
43129:   if (mEditorInitialized) {
43129:     if (mTextListener)
43129:       mEditor->RemoveEditorObserver(mTextListener);
43129: 
43129:     mEditor->PreDestroy(PR_TRUE);
43129:     mEditorInitialized = PR_FALSE;
43129:   }
43129: }
43129: 
43129: void
43129: nsTextEditorState::UnbindFromFrame(nsTextControlFrame* aFrame)
43129: {
43129:   NS_ENSURE_TRUE(mBoundFrame, );
43129: 
43129:   // If it was, however, it should be unbounded from the same frame.
43682:   NS_ASSERTION(!aFrame || aFrame == mBoundFrame, "Unbinding from the wrong frame");
43682:   NS_ENSURE_TRUE(!aFrame || aFrame == mBoundFrame, );
43129: 
43129:   // We need to start storing the value outside of the editor if we're not
43129:   // going to use it anymore, so retrieve it for now.
43129:   nsAutoString value;
43129:   GetValue(value, PR_TRUE);
43129: 
55424:   // Save our selection state if needed.
55424:   // Note that nsTextControlFrame::GetSelectionRange attempts to initialize the
55424:   // editor before grabbing the range, and because this is not an acceptable
55424:   // side effect for unbinding from a text control frame, we need to call
55424:   // GetSelectionRange before calling DestroyEditor, and only if
55424:   // mEditorInitialized indicates that we actually have an editor available.
55424:   if (mEditorInitialized) {
55424:     mSelState = new SelectionState();
55424:     nsresult rv = mBoundFrame->GetSelectionRange(&mSelState->mStart, &mSelState->mEnd);
55424:     if (NS_FAILED(rv)) {
55424:       mSelState = nsnull;
55424:     }
55424:   }
55424: 
43129:   // Destroy our editor
43129:   DestroyEditor();
43129: 
43129:   // Clean up the controller
43129:   if (!SuppressEventHandlers(mBoundFrame->PresContext()))
43129:   {
43129:     nsCOMPtr<nsIControllers> controllers;
48892:     nsCOMPtr<nsIDOMHTMLInputElement> inputElement =
43129:       do_QueryInterface(mTextCtrlElement);
43129:     if (inputElement)
43129:       inputElement->GetControllers(getter_AddRefs(controllers));
43129:     else
43129:     {
43129:       nsCOMPtr<nsIDOMNSHTMLTextAreaElement> textAreaElement =
43129:         do_QueryInterface(mTextCtrlElement);
43129:       if (textAreaElement) {
43129:         textAreaElement->GetControllers(getter_AddRefs(controllers));
43129:       }
43129:     }
43129: 
43129:     if (controllers)
43129:     {
43129:       PRUint32 numControllers;
43129:       nsresult rv = controllers->GetControllerCount(&numControllers);
43129:       NS_ASSERTION((NS_SUCCEEDED(rv)), "bad result in gfx text control destructor");
43129:       for (PRUint32 i = 0; i < numControllers; i ++)
43129:       {
43129:         nsCOMPtr<nsIController> controller;
43129:         rv = controllers->GetControllerAt(i, getter_AddRefs(controller));
43129:         if (NS_SUCCEEDED(rv) && controller)
43129:         {
43129:           nsCOMPtr<nsIControllerContext> editController = do_QueryInterface(controller);
43129:           if (editController)
43129:           {
43129:             editController->SetCommandContext(nsnull);
43129:           }
43129:         }
43129:       }
43129:     }
43129:   }
43129: 
43129:   if (mSelCon) {
43129:     if (mTextListener) {
43129:       nsRefPtr<nsISelection> domSelection;
43129:       if (NS_SUCCEEDED(mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
43129:                                              getter_AddRefs(domSelection))) &&
43129:           domSelection) {
43129:         nsCOMPtr<nsISelectionPrivate> selPriv(do_QueryInterface(domSelection));
43129: 
43129:         selPriv->RemoveSelectionListener(static_cast<nsISelectionListener*>
43129:                                          (mTextListener));
43129:       }
43129:     }
43129: 
43129:     mSelCon->SetScrollableFrame(nsnull);
43129:     mSelCon = nsnull;
43129:   }
43129: 
43129:   if (mTextListener)
43129:   {
43129:     mTextListener->SetFrame(nsnull);
43129: 
43129:     nsCOMPtr<nsIDOMEventGroup> systemGroup;
43129:     nsCOMPtr<nsIContent> content = do_QueryInterface(mTextCtrlElement);
43129:     content->GetSystemEventGroup(getter_AddRefs(systemGroup));
43129:     nsCOMPtr<nsIDOM3EventTarget> dom3Targ = do_QueryInterface(mTextCtrlElement);
43129:     if (dom3Targ) {
43129:       // cast because of ambiguous base
43129:       nsIDOMEventListener *listener = static_cast<nsIDOMKeyListener*>
43129:                                                  (mTextListener);
43129: 
43129:       dom3Targ->RemoveGroupedEventListener(NS_LITERAL_STRING("keydown"),
43129:                                            listener, PR_FALSE, systemGroup);
43129:       dom3Targ->RemoveGroupedEventListener(NS_LITERAL_STRING("keypress"),
43129:                                            listener, PR_FALSE, systemGroup);
43129:       dom3Targ->RemoveGroupedEventListener(NS_LITERAL_STRING("keyup"),
43129:                                            listener, PR_FALSE, systemGroup);
43129:     }
43129: 
43129:     NS_RELEASE(mTextListener);
43129:     mTextListener = nsnull;
43129:   }
43129: 
43129:   mBoundFrame = nsnull;
43129: 
43129:   // Now that we don't have a frame any more, store the value in the text buffer.
43129:   SetValue(value, PR_FALSE);
43129: 
43129:   if (mRootNode && mMutationObserver) {
43129:     mRootNode->RemoveMutationObserver(mMutationObserver);
43129:     mMutationObserver = nsnull;
43129:   }
43129: 
43129:   // Unbind the anonymous content from the tree.
43129:   // We actually hold a reference to the content nodes so that
43129:   // they're not actually destroyed.
43129:   nsContentUtils::DestroyAnonymousContent(&mRootNode);
43129:   nsContentUtils::DestroyAnonymousContent(&mPlaceholderDiv);
43129: }
43129: 
43129: nsresult
43129: nsTextEditorState::CreateRootNode()
43129: {
43129:   NS_ENSURE_TRUE(!mRootNode, NS_ERROR_UNEXPECTED);
43129:   NS_ENSURE_ARG_POINTER(mBoundFrame);
43129: 
43129:   nsIPresShell *shell = mBoundFrame->PresContext()->GetPresShell();
43129:   NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
43129: 
43129:   nsIDocument *doc = shell->GetDocument();
43129:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
43129: 
43129:   // Now create a DIV and add it to the anonymous content child list.
43129:   nsCOMPtr<nsINodeInfo> nodeInfo;
43129:   nodeInfo = doc->NodeInfoManager()->GetNodeInfo(nsGkAtoms::div, nsnull,
43129:                                                  kNameSpaceID_XHTML);
43129:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
43129: 
48124:   nsresult rv = NS_NewHTMLElement(getter_AddRefs(mRootNode), nodeInfo.forget(),
56805:                                   NOT_FROM_PARSER);
43129:   NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:   // Set the necessary classes on the text control. We use class values
43129:   // instead of a 'style' attribute so that the style comes from a user-agent
43129:   // style sheet and is still applied even if author styles are disabled.
43129:   nsAutoString classValue;
43129:   classValue.AppendLiteral("anonymous-div");
43129:   PRInt32 wrapCols = GetWrapCols();
43129:   if (wrapCols >= 0) {
43129:     classValue.AppendLiteral(" wrap");
43129:   }
43129:   if (!IsSingleLineTextControl()) {
43129:     // We can't just inherit the overflow because setting visible overflow will
43129:     // crash when the number of lines exceeds the height of the textarea and
43129:     // setting -moz-hidden-unscrollable overflow (NS_STYLE_OVERFLOW_CLIP)
43129:     // doesn't paint the caret for some reason.
43129:     const nsStyleDisplay* disp = mBoundFrame->GetStyleDisplay();
43129:     if (disp->mOverflowX != NS_STYLE_OVERFLOW_VISIBLE &&
43129:         disp->mOverflowX != NS_STYLE_OVERFLOW_CLIP) {
43129:       classValue.AppendLiteral(" inherit-overflow");
43129:     }
43129: 
43129:     mMutationObserver = new nsAnonDivObserver(this);
43129:     NS_ENSURE_TRUE(mMutationObserver, NS_ERROR_OUT_OF_MEMORY);
43129:     mRootNode->AddMutationObserver(mMutationObserver);
43129:   }
43129:   rv = mRootNode->SetAttr(kNameSpaceID_None, nsGkAtoms::_class,
43129:                           classValue, PR_FALSE);
43129:   NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:   rv = mBoundFrame->UpdateValueDisplay(PR_FALSE);
43129:   NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:   return rv;
43129: }
43129: 
43129: nsresult
43129: nsTextEditorState::CreatePlaceholderNode()
43129: {
56086: #ifdef DEBUG
56086:   {
56086:     nsCOMPtr<nsIContent> content = do_QueryInterface(mTextCtrlElement);
56086:     if (content) {
56086:       nsAutoString placeholderTxt;
56086:       content->GetAttr(kNameSpaceID_None, nsGkAtoms::placeholder,
56086:                        placeholderTxt);
56086:       nsContentUtils::RemoveNewlines(placeholderTxt);
56086:       NS_ASSERTION(!placeholderTxt.IsEmpty(), "CreatePlaceholderNode() shouldn't \
56086: be called if @placeholder is the empty string when trimmed from line breaks");
56086:     }
56086:   }
56086: #endif // DEBUG
56086: 
43129:   NS_ENSURE_TRUE(!mPlaceholderDiv, NS_ERROR_UNEXPECTED);
43129:   NS_ENSURE_ARG_POINTER(mBoundFrame);
43129: 
43129:   nsIPresShell *shell = mBoundFrame->PresContext()->GetPresShell();
43129:   NS_ENSURE_TRUE(shell, NS_ERROR_FAILURE);
43129: 
43129:   nsIDocument *doc = shell->GetDocument();
43129:   NS_ENSURE_TRUE(doc, NS_ERROR_FAILURE);
43129: 
43129:   nsNodeInfoManager* pNodeInfoManager = doc->NodeInfoManager();
43129:   NS_ENSURE_TRUE(pNodeInfoManager, NS_ERROR_OUT_OF_MEMORY);
43129: 
43129:   nsresult rv;
43129:   nsCOMPtr<nsIContent> placeholderText;
43129: 
43129:   // Create a DIV for the placeholder
43129:   // and add it to the anonymous content child list
43129:   nsCOMPtr<nsINodeInfo> nodeInfo;
43129:   nodeInfo = pNodeInfoManager->GetNodeInfo(nsGkAtoms::div, nsnull,
43129:                                            kNameSpaceID_XHTML);
43129:   NS_ENSURE_TRUE(nodeInfo, NS_ERROR_OUT_OF_MEMORY);
43129: 
48124:   rv = NS_NewHTMLElement(getter_AddRefs(mPlaceholderDiv), nodeInfo.forget(),
56805:                          NOT_FROM_PARSER);
43129:   NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:   // Create the text node for the placeholder text before doing anything else
43129:   rv = NS_NewTextNode(getter_AddRefs(placeholderText), pNodeInfoManager);
43129:   NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:   rv = mPlaceholderDiv->AppendChildTo(placeholderText, PR_FALSE);
43129:   NS_ENSURE_SUCCESS(rv, rv);
43129: 
43129:   // initialize the text
43129:   UpdatePlaceholderText(PR_FALSE);
43129: 
43129:   return NS_OK;
43129: }
43129: 
43129: PRBool
43129: nsTextEditorState::GetMaxLength(PRInt32* aMaxLength)
43129: {
43129:   nsCOMPtr<nsIContent> content = do_QueryInterface(mTextCtrlElement);
43129:   NS_ENSURE_TRUE(content, PR_FALSE);
43129:   nsGenericHTMLElement* element = nsGenericHTMLElement::FromContent(content);
43129:   NS_ENSURE_TRUE(element, PR_FALSE);
43129: 
43129:   const nsAttrValue* attr = element->GetParsedAttr(nsGkAtoms::maxlength);
43129:   if (attr && attr->Type() == nsAttrValue::eInteger) {
43129:     *aMaxLength = attr->GetIntegerValue();
43129: 
43129:     return PR_TRUE;
43129:   }
43129: 
43129:   return PR_FALSE;
43129: }
43129: 
43129: void
43129: nsTextEditorState::GetValue(nsAString& aValue, PRBool aIgnoreWrap) const
43129: {
58181:   if (mEditor && mBoundFrame && (mEditorInitialized || !IsSingleLineTextControl())) {
43129:     PRBool canCache = aIgnoreWrap && !IsSingleLineTextControl();
43129:     if (canCache && !mCachedValue.IsEmpty()) {
43129:       aValue = mCachedValue;
43129:       return;
43129:     }
43129: 
43129:     aValue.Truncate(); // initialize out param
43129: 
43129:     PRUint32 flags = (nsIDocumentEncoder::OutputLFLineBreak |
43129:                       nsIDocumentEncoder::OutputPreformatted |
43129:                       nsIDocumentEncoder::OutputPersistNBSP);
43129: 
43129:     if (IsPlainTextControl())
43129:     {
43129:       flags |= nsIDocumentEncoder::OutputBodyOnly;
43129:     }
43129: 
43129:     if (!aIgnoreWrap) {
43129:       nsITextControlElement::nsHTMLTextWrap wrapProp;
43129:       nsCOMPtr<nsIContent> content = do_QueryInterface(mTextCtrlElement);
43129:       if (content &&
43129:           nsITextControlElement::GetWrapPropertyEnum(content, wrapProp) &&
43129:           wrapProp == nsITextControlElement::eHTMLTextWrap_Hard) {
43129:         flags |= nsIDocumentEncoder::OutputWrap;
43129:       }
43129:     }
43129: 
43129:     // What follows is a bit of a hack.  The problem is that we could be in
43129:     // this method because we're being destroyed for whatever reason while
43129:     // script is executing.  If that happens, editor will run with the
43129:     // privileges of the executing script, which means it may not be able to
43129:     // access its own DOM nodes!  Let's try to deal with that by pushing a null
43129:     // JSContext on the JSContext stack to make it clear that we're native
43129:     // code.  Note that any script that's directly trying to access our value
43129:     // has to be going through some scriptable object to do that and that
43129:     // already does the relevant security checks.
43129:     // XXXbz if we could just get the textContent of our anonymous content (eg
43129:     // if plaintext editor didn't create <br> nodes all over), we wouldn't need
43129:     // this.
43129:     { /* Scope for context pusher */
43129:       nsCxPusher pusher;
43129:       pusher.PushNull();
43129: 
43129:       mEditor->OutputToString(NS_LITERAL_STRING("text/plain"), flags,
43129:                               aValue);
43129:     }
43129:     if (canCache) {
43129:       mCachedValue = aValue;
43129:     } else {
43129:       mCachedValue.Truncate();
43129:     }
43129:   } else {
43129:     if (!mTextCtrlElement->ValueChanged() || !mValue) {
43129:       mTextCtrlElement->GetDefaultValueFromContent(aValue);
43129:     } else {
43129:       aValue = NS_ConvertUTF8toUTF16(*mValue);
43129:     }
43129:   }
43129: }
43129: 
43129: void
43129: nsTextEditorState::SetValue(const nsAString& aValue, PRBool aUserInput)
43129: {
43129:   if (mEditor && mBoundFrame) {
43129:     // The InsertText call below might flush pending notifications, which
43129:     // could lead into a scheduled PrepareEditor to be called.  That will
43129:     // lead to crashes (or worse) because we'd be initializing the editor
43129:     // before InsertText returns.  This script blocker makes sure that
43129:     // PrepareEditor cannot be called prematurely.
43129:     nsAutoScriptBlocker scriptBlocker;
43129: 
43129:     PRBool fireChangeEvent = mBoundFrame->GetFireChangeEventState();
43129:     if (aUserInput) {
43129:       mBoundFrame->SetFireChangeEventState(PR_TRUE);
43129:     }
43129: 
58374: #ifdef DEBUG
58374:     if (IsSingleLineTextControl()) {
58181:       NS_ASSERTION(mEditorInitialized || mInitializing,
58181:                    "We should never try to use the editor if we're not initialized unless we're being initialized");
58374:     }
58374: #endif
58181: 
43129:     nsAutoString currentValue;
58181:     if (!mEditorInitialized && IsSingleLineTextControl()) {
58181:       // Grab the current value directly from the text node to make sure that we
58181:       // deal with stale data correctly.
58181:       NS_ASSERTION(mRootNode, "We should have a root node here");
58181:       nsIContent *textContent = mRootNode->GetChildAt(0);
58181:       nsCOMPtr<nsIDOMCharacterData> textNode = do_QueryInterface(textContent);
58181:       if (textNode) {
58181:         textNode->GetData(currentValue);
58181:       }
58181:     } else {
43129:       mBoundFrame->GetText(currentValue);
58181:     }
43129: 
43129:     nsWeakFrame weakFrame(mBoundFrame);
43129: 
43129:     // this is necessary to avoid infinite recursion
43129:     if (!currentValue.Equals(aValue))
43129:     {
43129:       nsTextControlFrame::ValueSetter valueSetter(mBoundFrame,
43129:                                                   mBoundFrame->mFocusedValue.Equals(currentValue));
43129: 
43129:       // \r is an illegal character in the dom, but people use them,
43129:       // so convert windows and mac platform linebreaks to \n:
43129:       // Unfortunately aValue is declared const, so we have to copy
43129:       // in order to do this substitution.
43129:       nsString newValue(aValue);
43129:       if (aValue.FindChar(PRUnichar('\r')) != -1) {
43129:         nsContentUtils::PlatformToDOMLineBreaks(newValue);
43129:       }
43129: 
43129:       nsCOMPtr<nsIDOMDocument> domDoc;
43129:       mEditor->GetDocument(getter_AddRefs(domDoc));
43129:       if (!domDoc) {
43129:         NS_WARNING("Why don't we have a document?");
43129:         return;
43129:       }
43129: 
43129:       // Time to mess with our security context... See comments in GetValue()
43129:       // for why this is needed.  Note that we have to do this up here, because
43129:       // otherwise SelectAll() will fail.
43129:       { /* Scope for context pusher */
43129:         nsCxPusher pusher;
43129:         pusher.PushNull();
43129: 
43129:         nsCOMPtr<nsISelection> domSel;
43129:         nsCOMPtr<nsISelectionPrivate> selPriv;
43129:         mSelCon->GetSelection(nsISelectionController::SELECTION_NORMAL,
43129:                               getter_AddRefs(domSel));
43129:         if (domSel)
43129:         {
43129:           selPriv = do_QueryInterface(domSel);
43129:           if (selPriv)
43129:             selPriv->StartBatchChanges();
43129:         }
43129: 
43129:         nsCOMPtr<nsISelectionController> kungFuDeathGrip = mSelCon.get();
43129:         PRUint32 currentLength = currentValue.Length();
43129:         PRUint32 newlength = newValue.Length();
43129:         if (!currentLength ||
43129:             !StringBeginsWith(newValue, currentValue)) {
43129:           // Replace the whole text.
43129:           currentLength = 0;
43129:           mSelCon->SelectAll();
43129:         } else {
43129:           // Collapse selection to the end so that we can append data.
43129:           mBoundFrame->SelectAllOrCollapseToEndOfText(PR_FALSE);
43129:         }
43129:         const nsAString& insertValue =
43129:           StringTail(newValue, newlength - currentLength);
43129:         nsCOMPtr<nsIPlaintextEditor> plaintextEditor = do_QueryInterface(mEditor);
43129:         if (!plaintextEditor || !weakFrame.IsAlive()) {
43129:           NS_WARNING("Somehow not a plaintext editor?");
43129:           return;
43129:         }
43129: 
43129:         valueSetter.Init();
43129: 
43129:         // get the flags, remove readonly and disabled, set the value,
43129:         // restore flags
43129:         PRUint32 flags, savedFlags;
43129:         mEditor->GetFlags(&savedFlags);
43129:         flags = savedFlags;
43129:         flags &= ~(nsIPlaintextEditor::eEditorDisabledMask);
43129:         flags &= ~(nsIPlaintextEditor::eEditorReadonlyMask);
43129:         flags |= nsIPlaintextEditor::eEditorUseAsyncUpdatesMask;
43129:         flags |= nsIPlaintextEditor::eEditorDontEchoPassword;
43129:         mEditor->SetFlags(flags);
43129: 
55124:         mTextListener->SettingValue(PR_TRUE);
55124: 
43129:         // Also don't enforce max-length here
43129:         PRInt32 savedMaxLength;
43129:         plaintextEditor->GetMaxTextLength(&savedMaxLength);
43129:         plaintextEditor->SetMaxTextLength(-1);
43129: 
43129:         if (insertValue.IsEmpty()) {
43129:           mEditor->DeleteSelection(nsIEditor::eNone);
43129:         } else {
43129:           plaintextEditor->InsertText(insertValue);
43129:         }
55124: 
55124:         mTextListener->SettingValue(PR_FALSE);
55124: 
43129:         if (!weakFrame.IsAlive()) {
46356:           // If the frame was destroyed because of a flush somewhere inside
46356:           // InsertText, mBoundFrame here will be false.  But it's also possible
46356:           // for the frame to go away because of another reason (such as deleting
46356:           // the existing selection -- see bug 574558), in which case we don't
46356:           // need to reset the value here.
46356:           if (!mBoundFrame) {
43129:             SetValue(newValue, PR_FALSE);
46356:           }
43129:           valueSetter.Cancel();
43129:           return;
43129:         }
43129: 
43129:         if (!IsSingleLineTextControl()) {
43129:           mCachedValue = newValue;
43129:         }
43129: 
43129:         plaintextEditor->SetMaxTextLength(savedMaxLength);
43129:         mEditor->SetFlags(savedFlags);
43129:         if (selPriv)
43129:           selPriv->EndBatchChanges();
43129:       }
43129:     }
43129: 
43129:     // This second check _shouldn't_ be necessary, but let's be safe.
43129:     if (!weakFrame.IsAlive()) {
43129:       return;
43129:     }
43129:     nsIScrollableFrame* scrollableFrame = do_QueryFrame(mBoundFrame->GetFirstChild(nsnull));
43129:     if (scrollableFrame)
43129:     {
43129:       // Scroll the upper left corner of the text control's
43129:       // content area back into view.
43129:       scrollableFrame->ScrollTo(nsPoint(0, 0), nsIScrollableFrame::INSTANT);
43129:     }
43129: 
43129:     if (aUserInput) {
43129:       mBoundFrame->SetFireChangeEventState(fireChangeEvent);
43129:     }
43129:   } else {
43129:     if (!mValue) {
43129:       mValue = new nsCString;
43129:     }
43129:     nsString value(aValue);
43129:     nsContentUtils::PlatformToDOMLineBreaks(value);
43898:     CopyUTF16toUTF8(value, *mValue);
43129: 
43129:     // Update the frame display if needed
43129:     if (mBoundFrame) {
43129:       mBoundFrame->UpdateValueDisplay(PR_TRUE);
43129:     }
43129:   }
43129: 
43129:   // If we've reached the point where the root node has been created, we
43129:   // can assume that it's safe to notify.
43129:   ValueWasChanged(!!mRootNode);
51178: 
51178:   mTextCtrlElement->OnValueChanged(!!mRootNode);
43129: }
43129: 
43129: void
43129: nsTextEditorState::InitializeKeyboardEventListeners()
43129: {
43129:   nsCOMPtr<nsIContent> content = do_QueryInterface(mTextCtrlElement);
43129: 
43129:   //register key listeners
43129:   nsCOMPtr<nsIDOMEventGroup> systemGroup;
43129:   content->GetSystemEventGroup(getter_AddRefs(systemGroup));
43129:   nsCOMPtr<nsIDOM3EventTarget> dom3Targ = do_QueryInterface(content);
43129:   if (dom3Targ) {
43129:     // cast because of ambiguous base
43129:     nsIDOMEventListener *listener = static_cast<nsIDOMKeyListener*>
43129:                                                (mTextListener);
43129: 
43129:     dom3Targ->AddGroupedEventListener(NS_LITERAL_STRING("keydown"),
43129:                                       listener, PR_FALSE, systemGroup);
43129:     dom3Targ->AddGroupedEventListener(NS_LITERAL_STRING("keypress"),
43129:                                       listener, PR_FALSE, systemGroup);
43129:     dom3Targ->AddGroupedEventListener(NS_LITERAL_STRING("keyup"),
43129:                                       listener, PR_FALSE, systemGroup);
43129:   }
43129: 
43129:   mSelCon->SetScrollableFrame(do_QueryFrame(mBoundFrame->GetFirstChild(nsnull)));
43129: }
43129: 
43129: /* static */ void
43129: nsTextEditorState::ShutDown()
43129: {
43129:   NS_IF_RELEASE(sNativeTextAreaBindings);
43129:   NS_IF_RELEASE(sNativeInputBindings);
43129: }
43129: 
43129: void
43129: nsTextEditorState::ValueWasChanged(PRBool aNotify)
43129: {
43129:   // placeholder management
56086:   if (!mPlaceholderDiv) {
56086:     return;
56086:   }
56086: 
43129:   PRBool showPlaceholder = PR_FALSE;
43129:   nsCOMPtr<nsIContent> content = do_QueryInterface(mTextCtrlElement);
43129:   if (!nsContentUtils::IsFocusedContent(content)) {
43129:     // If the content is focused, we don't care about the changes because
43129:     // the placeholder is going to be hidden/shown on blur.
43129:     nsAutoString valueString;
43129:     GetValue(valueString, PR_TRUE);
43129:     showPlaceholder = valueString.IsEmpty();
43129:   }
43129:   SetPlaceholderClass(showPlaceholder, aNotify);
43129: }
43129: 
43129: void
43129: nsTextEditorState::UpdatePlaceholderText(PRBool aNotify)
43129: {
56086:   NS_ASSERTION(mPlaceholderDiv, "This function should not be called if "
56086:                                 "mPlaceholderDiv isn't set");
56086: 
49041:   // If we don't have a placeholder div, there's nothing to do.
49041:   if (!mPlaceholderDiv)
49041:     return;
49041: 
43129:   nsAutoString placeholderValue;
43129: 
43129:   nsCOMPtr<nsIContent> content = do_QueryInterface(mTextCtrlElement);
43129:   content->GetAttr(kNameSpaceID_None, nsGkAtoms::placeholder, placeholderValue);
43129:   nsContentUtils::RemoveNewlines(placeholderValue);
43129:   NS_ASSERTION(mPlaceholderDiv->GetChildAt(0), "placeholder div has no child");
43129:   mPlaceholderDiv->GetChildAt(0)->SetText(placeholderValue, aNotify);
43129:   ValueWasChanged(aNotify);
43129: }
43129: 
43129: void
43129: nsTextEditorState::SetPlaceholderClass(PRBool aVisible,
43129:                                        PRBool aNotify)
43129: {
56086:   NS_ASSERTION(mPlaceholderDiv, "This function should not be called if "
56086:                                 "mPlaceholderDiv isn't set");
56086: 
43129:   // No need to do anything if we don't have a frame yet
43129:   if (!mBoundFrame)
43129:     return;
43129: 
43129:   nsAutoString classValue;
43129: 
43129:   classValue.Assign(NS_LITERAL_STRING("anonymous-div placeholder"));
43129: 
43129:   if (!aVisible)
43129:     classValue.AppendLiteral(" hidden");
43129: 
43129:   nsIContent* placeholderDiv = GetPlaceholderNode();
43129:   NS_ENSURE_TRUE(placeholderDiv, );
43129: 
43129:   placeholderDiv->SetAttr(kNameSpaceID_None, nsGkAtoms::_class,
43129:                           classValue, aNotify);
43129: }
43129: 
68437: void
68437: nsTextEditorState::HideSelectionIfBlurred()
68437: {
68437:   NS_ABORT_IF_FALSE(mSelCon, "Should have a selection controller if we have a frame!");
68437:   nsCOMPtr<nsIContent> content = do_QueryInterface(mTextCtrlElement);
68437:   if (!nsContentUtils::IsFocusedContent(content)) {
68437:     mSelCon->SetDisplaySelection(nsISelectionController::SELECTION_HIDDEN);
68437:   }
68437: }
68437: 
43129: NS_IMPL_ISUPPORTS1(nsAnonDivObserver, nsIMutationObserver)
43129: 
43129: void
43129: nsAnonDivObserver::CharacterDataChanged(nsIDocument*             aDocument,
43129:                                         nsIContent*              aContent,
43129:                                         CharacterDataChangeInfo* aInfo)
43129: {
43129:   mTextEditorState->ClearValueCache();
43129: }
43129: 
43129: void
43129: nsAnonDivObserver::ContentAppended(nsIDocument* aDocument,
43129:                                    nsIContent*  aContainer,
43129:                                    nsIContent*  aFirstNewContent,
43129:                                    PRInt32      /* unused */)
43129: {
43129:   mTextEditorState->ClearValueCache();
43129: }
43129: 
43129: void
43129: nsAnonDivObserver::ContentInserted(nsIDocument* aDocument,
43129:                                    nsIContent*  aContainer,
43129:                                    nsIContent*  aChild,
43129:                                    PRInt32      /* unused */)
43129: {
43129:   mTextEditorState->ClearValueCache();
43129: }
43129: 
43129: void
43129: nsAnonDivObserver::ContentRemoved(nsIDocument* aDocument,
43129:                                   nsIContent*  aContainer,
43129:                                   nsIContent*  aChild,
48038:                                   PRInt32      aIndexInContainer,
48038:                                   nsIContent*  aPreviousSibling)
43129: {
43129:   mTextEditorState->ClearValueCache();
43129: }
