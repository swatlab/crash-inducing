    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rendering object for CSS :first-letter pseudo-element */
    1: 
    1: #include "nsCOMPtr.h"
14210: #include "nsFirstLetterFrame.h"
    1: #include "nsPresContext.h"
    1: #include "nsStyleContext.h"
    1: #include "nsIContent.h"
    1: #include "nsLineLayout.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsStyleSet.h"
    1: #include "nsFrameManager.h"
39530: #include "nsPlaceholderFrame.h"
39530: #include "nsCSSFrameConstructor.h"
    1: 
    1: nsIFrame*
    1: NS_NewFirstLetterFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsFirstLetterFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsFirstLetterFrame)
32423: 
    1: #ifdef NS_DEBUG
    1: NS_IMETHODIMP
    1: nsFirstLetterFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Letter"), aResult);
    1: }
    1: #endif
    1: 
    1: nsIAtom*
    1: nsFirstLetterFrame::GetType() const
    1: {
    1:   return nsGkAtoms::letterFrame;
    1: }
    1: 
    1: PRIntn
    1: nsFirstLetterFrame::GetSkipSides() const
    1: {
    1:   return 0;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFirstLetterFrame::Init(nsIContent*      aContent,
    1:                          nsIFrame*        aParent,
    1:                          nsIFrame*        aPrevInFlow)
    1: {
    1:   nsRefPtr<nsStyleContext> newSC;
    1:   if (aPrevInFlow) {
    1:     // Get proper style context for ourselves.  We're creating the frame
    1:     // that represents everything *except* the first letter, so just create
    1:     // a style context like we would for a text node.
    1:     nsStyleContext* parentStyleContext = mStyleContext->GetParent();
    1:     if (parentStyleContext) {
    1:       newSC = mStyleContext->GetRuleNode()->GetPresContext()->StyleSet()->
    1:         ResolveStyleForNonElement(parentStyleContext);
    1:       if (newSC)
    1:         SetStyleContextWithoutNotification(newSC);
    1:     }
    1:   }
    1: 
    1:   return nsFirstLetterFrameSuper::Init(aContent, aParent, aPrevInFlow);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFirstLetterFrame::SetInitialChildList(nsIAtom*     aListName,
30790:                                         nsFrameList& aChildList)
    1: {
  238:   nsFrameManager *frameManager = PresContext()->FrameManager();
    1: 
30790:   for (nsFrameList::Enumerator e(aChildList); !e.AtEnd(); e.Next()) {
30790:     NS_ASSERTION(e.get()->GetParent() == this, "Unexpected parent");
30790:     frameManager->ReParentStyleContext(e.get());
    1:   }
30790: 
30790:   mFrames.SetFrames(aChildList);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsFirstLetterFrame::GetChildFrameContainingOffset(PRInt32 inContentOffset,
    1:                                                   PRBool inHint,
    1:                                                   PRInt32* outFrameContentOffset,
    1:                                                   nsIFrame **outChildFrame)
    1: {
    1:   nsIFrame *kid = mFrames.FirstChild();
    1:   if (kid)
    1:   {
    1:     return kid->GetChildFrameContainingOffset(inContentOffset, inHint, outFrameContentOffset, outChildFrame);
    1:   }
    1:   else
    1:     return nsFrame::GetChildFrameContainingOffset(inContentOffset, inHint, outFrameContentOffset, outChildFrame);
    1: }
    1: 
    1: // Needed for non-floating first-letter frames and for the continuations
    1: // following the first-letter that we also use nsFirstLetterFrame for.
    1: /* virtual */ void
    1: nsFirstLetterFrame::AddInlineMinWidth(nsIRenderingContext *aRenderingContext,
    1:                                       nsIFrame::InlineMinWidthData *aData)
    1: {
    1:   DoInlineIntrinsicWidth(aRenderingContext, aData, nsLayoutUtils::MIN_WIDTH);
    1: }
    1: 
    1: // Needed for non-floating first-letter frames and for the continuations
    1: // following the first-letter that we also use nsFirstLetterFrame for.
    1: /* virtual */ void
    1: nsFirstLetterFrame::AddInlinePrefWidth(nsIRenderingContext *aRenderingContext,
    1:                                        nsIFrame::InlinePrefWidthData *aData)
    1: {
    1:   DoInlineIntrinsicWidth(aRenderingContext, aData, nsLayoutUtils::PREF_WIDTH);
    1: }
    1: 
    1: // Needed for floating first-letter frames.
    1: /* virtual */ nscoord
    1: nsFirstLetterFrame::GetMinWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   return nsLayoutUtils::MinWidthFromInline(this, aRenderingContext);
    1: }
    1: 
    1: // Needed for floating first-letter frames.
    1: /* virtual */ nscoord
    1: nsFirstLetterFrame::GetPrefWidth(nsIRenderingContext *aRenderingContext)
    1: {
    1:   return nsLayoutUtils::PrefWidthFromInline(this, aRenderingContext);
    1: }
    1: 
 3666: /* virtual */ nsSize
 3666: nsFirstLetterFrame::ComputeSize(nsIRenderingContext *aRenderingContext,
 3666:                                 nsSize aCBSize, nscoord aAvailableWidth,
 3666:                                 nsSize aMargin, nsSize aBorder, nsSize aPadding,
 3666:                                 PRBool aShrinkWrap)
 3666: {
 3666:   if (GetPrevInFlow()) {
 3666:     // We're wrapping the text *after* the first letter, so behave like an
 3666:     // inline frame.
 3666:     return nsSize(NS_UNCONSTRAINEDSIZE, NS_UNCONSTRAINEDSIZE);
 3666:   }
 3666:   return nsFirstLetterFrameSuper::ComputeSize(aRenderingContext,
 3666:       aCBSize, aAvailableWidth, aMargin, aBorder, aPadding, aShrinkWrap);
 3666: }
 3666: 
    1: NS_IMETHODIMP
    1: nsFirstLetterFrame::Reflow(nsPresContext*          aPresContext,
    1:                            nsHTMLReflowMetrics&     aMetrics,
    1:                            const nsHTMLReflowState& aReflowState,
    1:                            nsReflowStatus&          aReflowStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsFirstLetterFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aMetrics, aReflowStatus);
    1:   nsresult rv = NS_OK;
    1: 
    1:   // Grab overflow list
    1:   DrainOverflowFrames(aPresContext);
    1: 
    1:   nsIFrame* kid = mFrames.FirstChild();
    1: 
    1:   // Setup reflow state for our child
    1:   nsSize availSize(aReflowState.availableWidth, aReflowState.availableHeight);
    1:   const nsMargin& bp = aReflowState.mComputedBorderPadding;
    1:   nscoord lr = bp.left + bp.right;
    1:   nscoord tb = bp.top + bp.bottom;
 8982:   NS_ASSERTION(availSize.width != NS_UNCONSTRAINEDSIZE,
 8982:                "should no longer use unconstrained widths");
    1:   availSize.width -= lr;
    1:   if (NS_UNCONSTRAINEDSIZE != availSize.height) {
    1:     availSize.height -= tb;
    1:   }
    1: 
    1:   // Reflow the child
    1:   if (!aReflowState.mLineLayout) {
    1:     // When there is no lineLayout provided, we provide our own. The
    1:     // only time that the first-letter-frame is not reflowing in a
    1:     // line context is when its floating.
    1:     nsHTMLReflowState rs(aPresContext, aReflowState, kid, availSize);
    1:     nsLineLayout ll(aPresContext, nsnull, &aReflowState, nsnull);
 8982:     ll.BeginLineReflow(bp.left, bp.top, availSize.width, NS_UNCONSTRAINEDSIZE,
    1:                        PR_FALSE, PR_TRUE);
    1:     rs.mLineLayout = &ll;
23308:     ll.SetInFirstLetter(PR_TRUE);
    1:     ll.SetFirstLetterStyleOK(PR_TRUE);
    1: 
    1:     kid->WillReflow(aPresContext);
    1:     kid->Reflow(aPresContext, aMetrics, rs, aReflowStatus);
    1: 
    1:     ll.EndLineReflow();
23308:     ll.SetInFirstLetter(PR_FALSE);
    1:   }
    1:   else {
    1:     // Pretend we are a span and reflow the child frame
    1:     nsLineLayout* ll = aReflowState.mLineLayout;
    1:     PRBool        pushedFrame;
    1: 
23308:     ll->SetInFirstLetter(
34387:       mStyleContext->GetPseudo() == nsCSSPseudoElements::firstLetter);
    1:     ll->BeginSpan(this, &aReflowState, bp.left, availSize.width);
    1:     ll->ReflowFrame(kid, aReflowStatus, &aMetrics, pushedFrame);
 8983:     ll->EndSpan(this);
23308:     ll->SetInFirstLetter(PR_FALSE);
    1:   }
    1: 
    1:   // Place and size the child and update the output metrics
    1:   kid->SetRect(nsRect(bp.left, bp.top, aMetrics.width, aMetrics.height));
14210:   kid->FinishAndStoreOverflow(&aMetrics);
    1:   kid->DidReflow(aPresContext, nsnull, NS_FRAME_REFLOW_FINISHED);
14210: 
    1:   aMetrics.width += lr;
    1:   aMetrics.height += tb;
    1:   aMetrics.ascent += bp.top;
14210:   mBaseline = aMetrics.ascent;
14210: 
14210:   // Ensure that the overflow rect contains the child textframe's overflow rect.
14210:   // Note that if this is floating, the overline/underline drawable area is in
14210:   // the overflow rect of the child textframe.
14210:   aMetrics.mOverflowArea.UnionRect(aMetrics.mOverflowArea,
14210:                            nsRect(0, 0, aMetrics.width, aMetrics.height));
14210:   ConsiderChildOverflow(aMetrics.mOverflowArea, kid);
    1: 
    1:   // Create a continuation or remove existing continuations based on
    1:   // the reflow completion status.
    1:   if (NS_FRAME_IS_COMPLETE(aReflowStatus)) {
 7814:     if (aReflowState.mLineLayout) {
 7814:       aReflowState.mLineLayout->SetFirstLetterStyleOK(PR_FALSE);
 7814:     }
    1:     nsIFrame* kidNextInFlow = kid->GetNextInFlow();
    1:     if (kidNextInFlow) {
    1:       // Remove all of the childs next-in-flows
 3233:       static_cast<nsContainerFrame*>(kidNextInFlow->GetParent())
22195:         ->DeleteNextInFlowChild(aPresContext, kidNextInFlow, PR_TRUE);
    1:     }
    1:   }
    1:   else {
    1:     // Create a continuation for the child frame if it doesn't already
    1:     // have one.
39530:     if (!GetStyleDisplay()->IsFloating()) {
    1:       nsIFrame* nextInFlow;
32841:       rv = CreateNextInFlow(aPresContext, kid, nextInFlow);
    1:       if (NS_FAILED(rv)) {
    1:         return rv;
    1:       }
    1: 
    1:       // And then push it to our overflow list
32846:       const nsFrameList& overflow = mFrames.RemoveFramesAfter(kid);
32846:       if (overflow.NotEmpty()) {
32846:         SetOverflowFrames(aPresContext, overflow);
    1:       }
39530:     } else if (!kid->GetNextInFlow()) {
39530:       // For floating first letter frames (if a continuation wasn't already
39530:       // created for us) we need to put the continuation with the rest of the
39530:       // text that the first letter frame was made out of.
39530:       nsIFrame* continuation;
39530:       rv = CreateContinuationForFloatingParent(aPresContext, kid,
39530:                                                &continuation, PR_TRUE);
39530:     }
    1:   }
    1: 
14210:   FinishAndStoreOverflow(&aMetrics);
14210: 
    1:   NS_FRAME_SET_TRUNCATION(aReflowStatus, aReflowState, aMetrics);
    1:   return rv;
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsFirstLetterFrame::CanContinueTextRun() const
    1: {
    1:   // We can continue a text run through a first-letter frame.
    1:   return PR_TRUE;
    1: }
    1: 
39530: nsresult
39530: nsFirstLetterFrame::CreateContinuationForFloatingParent(nsPresContext* aPresContext,
39530:                                                         nsIFrame* aChild,
39530:                                                         nsIFrame** aContinuation,
39530:                                                         PRBool aIsFluid)
39530: {
39530:   NS_ASSERTION(GetStyleDisplay()->IsFloating(),
39530:                "can only call this on floating first letter frames");
39530:   NS_PRECONDITION(aContinuation, "bad args");
39530: 
39530:   *aContinuation = nsnull;
39530:   nsresult rv = NS_OK;
39530: 
39530:   nsIPresShell* presShell = aPresContext->PresShell();
39530:   nsPlaceholderFrame* placeholderFrame =
39530:     presShell->FrameManager()->GetPlaceholderFrameFor(this);
39530:   nsIFrame* parent = placeholderFrame->GetParent();
39530: 
39530:   nsIFrame* continuation;
39530:   rv = presShell->FrameConstructor()->
39530:     CreateContinuingFrame(aPresContext, aChild, parent, &continuation, aIsFluid);
39530:   if (NS_FAILED(rv) || !continuation) {
39530:     return rv;
39530:   }
39530: 
39530:   // The continuation will have gotten the first letter style from it's
39530:   // prev continuation, so we need to repair the style context so it
39530:   // doesn't have the first letter styling.
39530:   nsStyleContext* parentSC = this->GetStyleContext()->GetParent();
39530:   if (parentSC) {
39530:     nsRefPtr<nsStyleContext> newSC;
39530:     newSC = presShell->StyleSet()->ResolveStyleForNonElement(parentSC);
39530:     if (newSC) {
39530:       continuation->SetStyleContext(newSC);
39530:     }
39530:   }
39530: 
39530:   //XXX Bidi may not be involved but we have to use the list name
39530:   // nsGkAtoms::nextBidi because this is just like creating a continuation
39530:   // except we have to insert it in a different place and we don't want a
39530:   // reflow command to try to be issued.
39530:   nsFrameList temp(continuation, continuation);
39530:   rv = parent->InsertFrames(nsGkAtoms::nextBidi, placeholderFrame, temp);
39530: 
39530:   *aContinuation = continuation;
39530:   return rv;
39530: }
39530: 
    1: void
    1: nsFirstLetterFrame::DrainOverflowFrames(nsPresContext* aPresContext)
    1: {
30781:   nsAutoPtr<nsFrameList> overflowFrames;
    1: 
    1:   // Check for an overflow list with our prev-in-flow
    1:   nsFirstLetterFrame* prevInFlow = (nsFirstLetterFrame*)GetPrevInFlow();
    1:   if (nsnull != prevInFlow) {
30781:     overflowFrames = prevInFlow->StealOverflowFrames();
    1:     if (overflowFrames) {
    1:       NS_ASSERTION(mFrames.IsEmpty(), "bad overflow list");
    1: 
    1:       // When pushing and pulling frames we need to check for whether any
    1:       // views need to be reparented.
30781:       nsHTMLContainerFrame::ReparentFrameViewList(aPresContext, *overflowFrames,
30781:                                                   prevInFlow, this);
30781:       mFrames.InsertFrames(this, nsnull, *overflowFrames);
    1:     }
    1:   }
    1: 
    1:   // It's also possible that we have an overflow list for ourselves
30781:   overflowFrames = StealOverflowFrames();
    1:   if (overflowFrames) {
    1:     NS_ASSERTION(mFrames.NotEmpty(), "overflow list w/o frames");
30781:     mFrames.AppendFrames(nsnull, *overflowFrames);
    1:   }
    1: 
    1:   // Now repair our first frames style context (since we only reflow
    1:   // one frame there is no point in doing any other ones until they
    1:   // are reflowed)
    1:   nsIFrame* kid = mFrames.FirstChild();
    1:   if (kid) {
    1:     nsRefPtr<nsStyleContext> sc;
    1:     nsIContent* kidContent = kid->GetContent();
    1:     if (kidContent) {
    1:       NS_ASSERTION(kidContent->IsNodeOfType(nsINode::eTEXT),
    1:                    "should contain only text nodes");
    1:       sc = aPresContext->StyleSet()->ResolveStyleForNonElement(mStyleContext);
    1:       if (sc) {
    1:         kid->SetStyleContext(sc);
    1:       }
    1:     }
    1:   }
    1: }
