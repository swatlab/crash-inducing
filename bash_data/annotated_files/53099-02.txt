29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
52522: #define __STDC_LIMIT_MACROS
52522: 
    1: /*
    1:  * JavaScript iterators.
    1:  */
    1: #include <string.h>     /* for memcpy */
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
    1: #include "jsutil.h"
    1: #include "jsarena.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
28089: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
    1: #include "jsexn.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
42641: #include "jshashtable.h"
    1: #include "jsinterp.h"
    1: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
    1: #include "jsopcode.h"
42733: #include "jsproxy.h"
 3164: #include "jsscan.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
24499: #include "jsstaticcheck.h"
24499: #include "jstracer.h"
42641: #include "jsvector.h"
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
42717: #include "jscntxtinlines.h"
40858: #include "jsobjinlines.h"
42641: #include "jsstrinlines.h"
40858: 
37741: using namespace js;
37741: 
42641: static void iterator_finalize(JSContext *cx, JSObject *obj);
42641: static void iterator_trace(JSTracer *trc, JSObject *obj);
42641: static JSObject *iterator_iterator(JSContext *cx, JSObject *obj, JSBool keysonly);
    1: 
52525: ExtendedClass js_IteratorClass = {
42641:   { "Iterator",
42641:     JSCLASS_HAS_PRIVATE |
42641:     JSCLASS_HAS_CACHED_PROTO(JSProto_Iterator) |
42641:     JSCLASS_MARK_IS_TRACE |
42641:     JSCLASS_IS_EXTENDED,
52525:     PropertyStub,     PropertyStub,    PropertyStub,     PropertyStub,
52525:     EnumerateStub,    ResolveStub,     ConvertStub,      iterator_finalize,
42641:     NULL,             NULL,            NULL,             NULL,
42641:     NULL,             NULL,            JS_CLASS_TRACE(iterator_trace), NULL },
42641:     NULL,             NULL,            NULL,             iterator_iterator,
42641:     NULL,
42641:     JSCLASS_NO_RESERVED_MEMBERS
42641: };
 3436: 
42641: void
42641: NativeIterator::mark(JSTracer *trc)
42641: {
53059:     if (isKeyIter())
53059:         MarkIdRange(trc, beginKey(), endKey(), "props");
52924:     else
53059:         MarkValueRange(trc, beginValue(), endValue(), "props");
52795:     MarkObject(trc, obj, "obj");
42641: }
 3436: 
    1: /*
    1:  * Shared code to close iterator's state either through an explicit call or
    1:  * when GC detects that the iterator is no longer reachable.
    1:  */
40857: static void
40857: iterator_finalize(JSContext *cx, JSObject *obj)
40857: {
42641:     JS_ASSERT(obj->getClass() == &js_IteratorClass.base);
42641: 
42641:     /* Avoid double work if the iterator was closed by JSOP_ENDITER. */
42641:     NativeIterator *ni = obj->getNativeIterator();
42641:     if (ni) {
42641:         cx->free(ni);
42641:         obj->setNativeIterator(NULL);
42641:     }
40857: }
40857: 
40857: static void
33128: iterator_trace(JSTracer *trc, JSObject *obj)
33128: {
42641:     NativeIterator *ni = obj->getNativeIterator();
42641: 
42641:     if (ni)
42641:         ni->mark(trc);
33128: }
33128: 
53059: struct IdHashPolicy {
53059:     typedef jsid Lookup;
53059:     static HashNumber hash(jsid id) {
53059:         return JSID_BITS(id);
53059:     }
53059:     static bool match(jsid id1, jsid id2) {
53059:         return id1 == id2;
53059:     }
53059: };
53059: 
53059: typedef HashSet<jsid, IdHashPolicy, ContextAllocPolicy> IdSet;
53059: 
52527: static inline bool
52924: NewKeyValuePair(JSContext *cx, jsid id, const Value &val, Value *rval)
42641: {
52924:     Value vec[2] = { IdToValue(id), val };
42641:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(vec), vec);
    1: 
42641:     JSObject *aobj = js_NewArrayObject(cx, 2, vec);
42641:     if (!aobj)
42641:         return false;
53021:     rval->setObject(*aobj);
42641:     return true;
42641: }
42641: 
53059: struct KeyEnumeration
47525: {
53059:     typedef AutoIdVector ResultVector;
47525: 
53059:     static JS_ALWAYS_INLINE bool
53064:     append(JSContext *, AutoIdVector &keys, JSObject *, jsid id, uintN flags)
52924:     {
52924:         JS_ASSERT((flags & JSITER_FOREACH) == 0);
53064:         return keys.append(id);
47525:     }
52924: };
52924: 
53059: struct ValueEnumeration
52924: {
53059:     typedef AutoValueVector ResultVector;
52924: 
53059:     static JS_ALWAYS_INLINE bool
53064:     append(JSContext *cx, AutoValueVector &vals, JSObject *obj, jsid id, uintN flags)
52924:     {
52924:         JS_ASSERT(flags & JSITER_FOREACH);
52924: 
53064:         if (!vals.growBy(1))
52924:             return false;
47525: 
47525:         /* Do the lookup on the original object instead of the prototype. */
53064:         Value *vp = vals.end() - 1;
47525:         if (!obj->getProperty(cx, id, vp))
47525:             return false;
47525:         if ((flags & JSITER_KEYVALUE) && !NewKeyValuePair(cx, id, *vp, vp))
47525:             return false;
52924: 
47525:         return true;
47525:     }
52924: };
47525: 
53059: template <class EnumPolicy>
42641: static inline bool
42691: Enumerate(JSContext *cx, JSObject *obj, JSObject *pobj, jsid id,
53063:           bool enumerable, bool sharedPermanent, uintN flags, IdSet& ht,
53064:           typename EnumPolicy::ResultVector &props)
    1: {
52527:     JS_ASSERT(JSID_IS_INT(id) || JSID_IS_ATOM(id));
42641: 
53059:     IdSet::AddPtr p = ht.lookupForAdd(id);
47569:     JS_ASSERT_IF(obj == pobj, !p);
47569: 
47569:     /* If we've already seen this, we definitely won't add it. */
42641:     if (JS_UNLIKELY(!!p))
42641:         return true;
47569: 
47569:     /*
47569:      * It's not necessary to add properties to the hash table at the end of the
47569:      * prototype chain.
47569:      */
42710:     if (pobj->getProto() && !ht.add(p, id))
42641:         return false;
47569: 
47569:     if (JS_UNLIKELY(flags & JSITER_OWNONLY)) {
47569:         /*
47569:          * Shared-permanent hack: If this property is shared permanent
47569:          * and pobj and obj have the same class, then treat it as an own
47569:          * property of obj, even if pobj != obj. (But see bug 575997.)
47569:          *
47569:          * Omit the magic __proto__ property so that JS code can use
47569:          * Object.getOwnPropertyNames without worrying about it.
47569:          */
47569:         if (!pobj->getProto() && id == ATOM_TO_JSID(cx->runtime->atomState.protoAtom))
47569:             return true;
47569:         if (pobj != obj && !(sharedPermanent && pobj->getClass() == obj->getClass()))
47569:             return true;
42641:     }
47569: 
52924:     if (enumerable || (flags & JSITER_HIDDEN))
53064:         return EnumPolicy::append(cx, props, obj, id, flags);
52924: 
42641:     return true;
42641: }
42641: 
53059: template <class EnumPolicy>
42641: static bool
53059: EnumerateNativeProperties(JSContext *cx, JSObject *obj, JSObject *pobj, uintN flags, IdSet &ht,
53064:                           typename EnumPolicy::ResultVector &props)
42641: {
52924:     JS_LOCK_OBJ(cx, pobj);
42641: 
53064:     size_t initialLength = props.length();
42641: 
42641:     /* Collect all unique properties from this object's scope. */
42691:     JSScope *scope = pobj->scope();
42641:     for (JSScopeProperty *sprop = scope->lastProperty(); sprop; sprop = sprop->parent) {
52924:         if (!JSID_IS_DEFAULT_XML_NAMESPACE(sprop->id) &&
42641:             !sprop->isAlias() &&
53063:             !Enumerate<EnumPolicy>(cx, obj, pobj, sprop->id, sprop->enumerable(), sprop->isSharedPermanent(),
53064:                                    flags, ht, props))
47569:         {
42641:             return false;
42641:         }
42641:     }
42641: 
53064:     Reverse(props.begin() + initialLength, props.end());
42641: 
42641:     JS_UNLOCK_SCOPE(cx, scope);
42641:     return true;
42641: }
42641: 
53059: template <class EnumPolicy>
42641: static bool
42691: EnumerateDenseArrayProperties(JSContext *cx, JSObject *obj, JSObject *pobj, uintN flags,
53064:                               IdSet &ht, typename EnumPolicy::ResultVector &props)
42641: {
53064:     if (!Enumerate<EnumPolicy>(cx, obj, pobj, ATOM_TO_JSID(cx->runtime->atomState.lengthAtom), false, true,
47569:                                flags, ht, props)) {
47569:         return false;
47569:     }
42641: 
47569:     if (pobj->getDenseArrayCount() > 0) {
42691:         size_t capacity = pobj->getDenseArrayCapacity();
52795:         Value *vp = pobj->dslots;
42641:         for (size_t i = 0; i < capacity; ++i, ++vp) {
52527:             if (!vp->isMagic(JS_ARRAY_HOLE)) {
42641:                 /* Dense arrays never get so large that i would not fit into an integer id. */
53063:                 if (!Enumerate<EnumPolicy>(cx, obj, pobj, INT_TO_JSID(i), true, false, flags, ht, props))
42641:                     return false;
42641:             }
42641:         }
42641:     }
47569: 
42641:     return true;
42641: }
42641: 
53059: template <class EnumPolicy>
47459: static bool
53064: Snapshot(JSContext *cx, JSObject *obj, uintN flags, typename EnumPolicy::ResultVector &props)
42641: {
47569:     /*
47569:      * FIXME: Bug 575997 - We won't need to initialize this hash table if
47569:      *        (flags & JSITER_OWNONLY) when we eliminate inheritance of
47569:      *        shared-permanent properties as own properties.
47569:      */
53059:     IdSet ht(cx);
47569:     if (!ht.init(32))
52924:         return NULL;
42641: 
42691:     JSObject *pobj = obj;
47459:     do {
52795:         Class *clasp = pobj->getClass();
42691:         if (pobj->isNative() &&
42691:             pobj->map->ops->enumerate == js_Enumerate &&
42641:             !(clasp->flags & JSCLASS_NEW_ENUMERATE)) {
42691:             if (!clasp->enumerate(cx, pobj))
47459:                 return false;
53064:             if (!EnumerateNativeProperties<EnumPolicy>(cx, obj, pobj, flags, ht, props))
47459:                 return false;
42691:         } else if (pobj->isDenseArray()) {
53064:             if (!EnumerateDenseArrayProperties<EnumPolicy>(cx, obj, pobj, flags, ht, props))
47459:                 return false;
42641:         } else {
42733:             if (pobj->isProxy()) {
53058:                 AutoIdVector proxyProps(cx);
42733:                 if (flags & JSITER_OWNONLY) {
47460:                     if (!JSProxy::enumerateOwn(cx, pobj, proxyProps))
47459:                         return false;
42733:                 } else {
47460:                     if (!JSProxy::enumerate(cx, pobj, proxyProps))
47459:                         return false;
42733:                 }
47460:                 for (size_t n = 0, len = proxyProps.length(); n < len; n++) {
53064:                     if (!Enumerate<EnumPolicy>(cx, obj, pobj, proxyProps[n], true, false, flags, ht, props))
47459:                         return false;
42733:                 }
42733:                 /* Proxy objects enumerate the prototype on their own, so we are done here. */
42733:                 break;
42733:             }
52795:             Value state;
47569:             JSIterateOp op = (flags & JSITER_HIDDEN) ? JSENUMERATE_INIT_ALL : JSENUMERATE_INIT;
47569:             if (!pobj->enumerate(cx, op, &state, NULL))
47459:                 return false;
52795:             if (state.isMagic(JS_NATIVE_ENUMERATE)) {
53064:                 if (!EnumerateNativeProperties<EnumPolicy>(cx, obj, pobj, flags, ht, props))
47459:                     return false;
42641:             } else {
42641:                 while (true) {
42641:                     jsid id;
42691:                     if (!pobj->enumerate(cx, JSENUMERATE_NEXT, &state, &id))
47459:                         return false;
52795:                     if (state.isNull())
42641:                         break;
53064:                     if (!Enumerate<EnumPolicy>(cx, obj, pobj, id, true, false, flags, ht, props))
47459:                         return false;
42641:                 }
42641:             }
42641:         }
    1: 
47569:         if (JS_UNLIKELY(pobj->isXML()))
42641:             break;
47459:     } while ((pobj = pobj->getProto()) != NULL);
    1: 
47459:     return true;
42641: }
42641: 
42641: bool
53059: VectorToIdArray(JSContext *cx, AutoIdVector &props, JSIdArray **idap)
42641: {
47459:     JS_STATIC_ASSERT(sizeof(JSIdArray) > sizeof(jsid));
47459:     size_t len = props.length();
47459:     size_t idsz = len * sizeof(jsid);
47459:     size_t sz = (sizeof(JSIdArray) - sizeof(jsid)) + idsz;
47459:     JSIdArray *ida = static_cast<JSIdArray *>(cx->malloc(sz));
47459:     if (!ida)
47459:         return false;
47459: 
47459:     ida->length = static_cast<jsint>(len);
47459:     memcpy(ida->vector, props.begin(), idsz);
42641:     *idap = ida;
42641:     return true;
42641: }
42641: 
42733: bool
53058: GetPropertyNames(JSContext *cx, JSObject *obj, uintN flags, AutoIdVector &props)
42733: {
53059:     return Snapshot<KeyEnumeration>(cx, obj, flags & (JSITER_OWNONLY | JSITER_HIDDEN), props);
42733: }
42733: 
42641: static inline bool
52527: GetCustomIterator(JSContext *cx, JSObject *obj, uintN flags, Value *vp)
42641: {
42641:     /* Check whether we have a valid __iterator__ method. */
42641:     JSAtom *atom = cx->runtime->atomState.iteratorAtom;
42641:     if (!js_GetMethod(cx, obj, ATOM_TO_JSID(atom), JSGET_NO_METHOD_BARRIER, vp))
42641:         return false;
42641: 
42641:     /* If there is no custom __iterator__ method, we are done here. */
52527:     if (vp->isUndefined())
42641:         return true;
42641: 
42641:     /* Otherwise call it and return that object. */
42641:     LeaveTrace(cx);
53076:     Value arg = BooleanValue((flags & JSITER_FOREACH) == 0);
52795:     if (!InternalCall(cx, obj, *vp, 1, &arg, vp))
42641:         return false;
52527:     if (vp->isPrimitive()) {
43211:         /*
43211:          * We are always coming from js_ValueToIterator, and we are no longer on
43211:          * trace, so the object we are iterating over is on top of the stack (-1).
43211:          */
43211:         js_ReportValueError2(cx, JSMSG_BAD_TRAP_RETURN_VALUE,
53076:                              -1, ObjectValue(*obj), NULL,
43211:                              js_AtomToPrintableString(cx, atom));
42641:         return false;
42641:     }
42641:     return true;
42641: }
42641: 
42641: template <typename T>
42641: static inline bool
42641: Compare(T *a, T *b, size_t c)
42641: {
42641:     size_t n = (c + size_t(7)) / size_t(8);
42641:     switch (c % 8) {
42641:       case 0: do { if (*a++ != *b++) return false;
42641:       case 7:      if (*a++ != *b++) return false;
42641:       case 6:      if (*a++ != *b++) return false;
42641:       case 5:      if (*a++ != *b++) return false;
42641:       case 4:      if (*a++ != *b++) return false;
42641:       case 3:      if (*a++ != *b++) return false;
42641:       case 2:      if (*a++ != *b++) return false;
42641:       case 1:      if (*a++ != *b++) return false;
42641:               } while (--n > 0);
42641:     }
42641:     return true;
42641: }
42641: 
47497: static inline JSObject *
43190: NewIteratorObject(JSContext *cx, uintN flags)
43190: {
47497:     if (flags & JSITER_ENUMERATE) {
47497:         /*
47497:          * Non-escaping native enumerator objects do not need map, proto, or
47497:          * parent. However, code in jstracer.cpp and elsewhere may find such a
47497:          * native enumerator object via the stack and (as for all objects that
47497:          * are not stillborn, with the exception of "NoSuchMethod" internal
47497:          * helper objects) expect it to have a non-null map pointer, so we
47497:          * share an empty Enumerator scope in the runtime.
47497:          */
47497:         JSObject *obj = js_NewGCObject(cx);
47497:         if (!obj)
47497:             return false;
47497:         obj->map = cx->runtime->emptyEnumeratorScope->hold();
53076:         obj->init(&js_IteratorClass.base, NULL, NULL, NullValue());
47497:         return obj;
47497:     }
47497: 
47497:     return NewBuiltinClassInstance(cx, &js_IteratorClass.base);
43190: }
43190: 
53059: NativeIterator *
53059: NativeIterator::allocateKeyIterator(JSContext *cx, uint32 slength, const AutoIdVector &props)
53059: {
53059:     size_t plength = props.length();
53059:     NativeIterator *ni = (NativeIterator *)
53059:         cx->malloc(sizeof(NativeIterator) + plength * sizeof(jsid) + slength * sizeof(uint32));
53059:     if (!ni)
53059:         return NULL;
53059:     ni->props_array = ni->props_cursor = (jsid *) (ni + 1);
53059:     ni->props_end = (jsid *)ni->props_array + plength;
53059:     if (plength)
53059:         memcpy(ni->props_array, props.begin(), plength * sizeof(jsid));
53059:     return ni;
53059: }
53059: 
53059: NativeIterator *
53059: NativeIterator::allocateValueIterator(JSContext *cx, uint32 slength, const AutoValueVector &props)
53059: {
53059:     size_t plength = props.length();
53059:     NativeIterator *ni = (NativeIterator *)
53059:         cx->malloc(sizeof(NativeIterator) + plength * sizeof(Value) + slength * sizeof(uint32));
53059:     if (!ni)
53059:         return NULL;
53059:     ni->props_array = ni->props_cursor = (Value *) (ni + 1);
53059:     ni->props_end = (Value *)ni->props_array + plength;
53059:     if (plength)
53059:         memcpy(ni->props_array, props.begin(), plength * sizeof(Value));
53059:     return ni;
53059: }
53059: 
53059: inline void
53059: NativeIterator::init(JSObject *obj, uintN flags, const uint32 *sarray, uint32 slength, uint32 key)
53059: {
53059:     this->obj = obj;
53059:     this->flags = flags;
53059:     this->shapes_array = (uint32 *) this->props_end;
53059:     this->shapes_length = slength;
53059:     this->shapes_key = key;
53059:     if (slength)
53059:         memcpy(this->shapes_array, sarray, slength * sizeof(uint32));
53059: }
53059: 
43281: static inline void
43281: RegisterEnumerator(JSContext *cx, JSObject *iterobj, NativeIterator *ni)
43281: {
43281:     /* Register non-escaping native enumerators (for-in) with the current context. */
43281:     if (ni->flags & JSITER_ENUMERATE) {
43281:         ni->next = cx->enumerators;
43281:         cx->enumerators = iterobj;
43281:     }
43281: }
43281: 
53059: static inline bool
53059: VectorToKeyIterator(JSContext *cx, JSObject *obj, uintN flags, AutoIdVector &keys,
53059:                     const uint32 *sarray, uint32 slength, uint32 key, Value *vp)
43190: {
53059:     JS_ASSERT(!(flags & JSITER_FOREACH));
53059: 
43190:     JSObject *iterobj = NewIteratorObject(cx, flags);
43190:     if (!iterobj)
43190:         return false;
43190: 
43190: 
53059:     NativeIterator *ni = NativeIterator::allocateKeyIterator(cx, slength, keys);
43190:     if (!ni)
53059:         return NULL;
53059:     ni->init(obj, flags, sarray, slength, key);
47525: 
43190:     iterobj->setNativeIterator(ni);
53059:     vp->setObject(*iterobj);
43281: 
43281:     RegisterEnumerator(cx, iterobj, ni);
43190:     return true;
43190: }
43190: 
43190: bool
53059: VectorToKeyIterator(JSContext *cx, JSObject *obj, uintN flags, AutoIdVector &props, Value *vp)
53059: {
53059:     return VectorToKeyIterator(cx, obj, flags, props, NULL, 0, 0, vp);
53059: }
53059: 
53059: static inline bool
53059: VectorToValueIterator(JSContext *cx, JSObject *obj, uintN flags, AutoValueVector &vals,
53059:                       const uint32 *sarray, uint32 slength, uint32 key, Value *vp)
53059: {
53059:     JS_ASSERT(flags & JSITER_FOREACH);
53059: 
53059:     JSObject *iterobj = NewIteratorObject(cx, flags);
53059:     if (!iterobj)
53059:         return false;
53059: 
53059:     NativeIterator *ni = NativeIterator::allocateValueIterator(cx, slength, vals);
53059:     if (!ni)
53059:         return NULL;
53059:     ni->init(obj, flags, sarray, slength, key);
53059: 
53059:     iterobj->setNativeIterator(ni);
53059:     vp->setObject(*iterobj);
53059: 
53059:     RegisterEnumerator(cx, iterobj, ni);
53059:     return true;
53059: }
53059: 
53059: bool
53059: VectorToValueIterator(JSContext *cx, JSObject *obj, uintN flags, AutoValueVector &props, Value *vp)
53059: {
53059:     return VectorToValueIterator(cx, obj, flags, props, NULL, 0, 0, vp);
53059: }
53059: 
53059: bool
53059: EnumeratedIdVectorToIterator(JSContext *cx, JSObject *obj, uintN flags, AutoIdVector &props, Value *vp)
53059: {
53059:     if (!(flags & JSITER_FOREACH))
53059:         return VectorToKeyIterator(cx, obj, flags, props, vp);
53059: 
53059:     /* For for-each iteration, we need to look up the value of each id. */
53059: 
53059:     size_t plength = props.length();
53059: 
53059:     AutoValueVector vals(cx);
53059:     if (!vals.reserve(plength))
53059:         return NULL;
53059: 
53059:     for (size_t i = 0; i < plength; ++i) {
53059:         if (!ValueEnumeration::append(cx, vals, obj, props[i], flags))
53059:             return false;
53059:     }
53059: 
53059:     return VectorToValueIterator(cx, obj, flags, vals, vp);
53059: }
53059: 
53059: typedef Vector<uint32, 8> ShapeVector;
53059: 
53059: bool
52527: GetIterator(JSContext *cx, JSObject *obj, uintN flags, Value *vp)
42641: {
42641:     uint32 hash;
42641:     JSObject **hp;
42641:     Vector<uint32, 8> shapes(cx);
42641:     uint32 key = 0;
42641: 
42641:     bool keysOnly = (flags == JSITER_ENUMERATE);
42641: 
42641:     if (obj) {
42641:         if (keysOnly) {
    1:             /*
42641:              * The iterator object for JSITER_ENUMERATE never escapes, so we
42641:              * don't care for the proper parent/proto to be set. This also
42641:              * allows us to re-use a previous iterator object that was freed
42641:              * by JSOP_ENDITER.
    1:              */
42641:             JSObject *pobj = obj;
42641:             do {
42641:                 if (!pobj->isNative() ||
42641:                     obj->map->ops->enumerate != js_Enumerate ||
42641:                     pobj->getClass()->enumerate != JS_EnumerateStub) {
42641:                     shapes.clear();
42641:                     goto miss;
    1:                 }
42641:                 uint32 shape = pobj->shape();
42641:                 key = (key + (key << 16)) ^ shape;
42641:                 if (!shapes.append(shape))
42641:                     return false;
42641:                 pobj = pobj->getProto();
42641:             } while (pobj);
42641: 
42641:             hash = key % JS_ARRAY_LENGTH(JS_THREAD_DATA(cx)->cachedNativeIterators);
42641:             hp = &JS_THREAD_DATA(cx)->cachedNativeIterators[hash];
42641:             JSObject *iterobj = *hp;
42641:             if (iterobj) {
43190:                 NativeIterator *ni = iterobj->getNativeIterator();
42641:                 if (ni->shapes_key == key &&
42641:                     ni->shapes_length == shapes.length() &&
42641:                     Compare(ni->shapes_array, shapes.begin(), ni->shapes_length)) {
53021:                     vp->setObject(*iterobj);
42641:                     *hp = ni->next;
43281: 
43281:                     RegisterEnumerator(cx, iterobj, ni);
42641:                     return true;
42641:                 }
42641:             }
42641:         }
42641: 
42641:       miss:
43190:         if (obj->isProxy())
43190:             return JSProxy::iterate(cx, obj, flags, vp);
42641:         if (!GetCustomIterator(cx, obj, flags, vp))
42641:             return false;
52527:         if (!vp->isUndefined())
42641:             return true;
42641:     }
42641: 
53059:     /* NB: for (var p in null) succeeds by iterating over no properties. */
53059: 
53059:     if (flags & JSITER_FOREACH) {
53059:         AutoValueVector vals(cx);
53059:         if (JS_LIKELY(obj != NULL) && !Snapshot<ValueEnumeration>(cx, obj, flags, vals))
42641:             return false;
53059:         return VectorToValueIterator(cx, obj, flags, vals, shapes.begin(), shapes.length(), key, vp);
53059:     }
42641: 
53059:     AutoIdVector keys(cx);
53059:     if (JS_LIKELY(obj != NULL) && !Snapshot<KeyEnumeration>(cx, obj, flags, keys))
47459:         return false;
53059:     return VectorToKeyIterator(cx, obj, flags, keys, shapes.begin(), shapes.length(), key, vp);
42641: }
42641: 
42641: static JSObject *
42641: iterator_iterator(JSContext *cx, JSObject *obj, JSBool keysonly)
42641: {
42641:     return obj;
    1: }
    1: 
    1: static JSBool
52527: Iterator(JSContext *cx, JSObject *iterobj, uintN argc, Value *argv, Value *rval)
    1: {
    1:     JSBool keyonly;
    1:     uintN flags;
    1: 
10449:     keyonly = js_ValueToBoolean(argv[1]);
43055:     flags = JSITER_OWNONLY | (keyonly ? 0 : (JSITER_FOREACH | JSITER_KEYVALUE));
    1:     *rval = argv[0];
    1:     return js_ValueToIterator(cx, flags, rval);
    1: }
    1: 
 6464: JSBool
 6464: js_ThrowStopIteration(JSContext *cx)
    1: {
52527:     Value v;
    1: 
    1:     JS_ASSERT(!JS_IsExceptionPending(cx));
38604:     if (js_FindClassObject(cx, NULL, JSProto_StopIteration, &v))
52527:         SetPendingException(cx, v);
    1:     return JS_FALSE;
    1: }
    1: 
    1: static JSBool
52527: iterator_next(JSContext *cx, uintN argc, Value *vp)
    1: {
 4127:     JSObject *obj;
 4127: 
53059:     obj = ComputeThisFromVp(cx, vp);
52527:     if (!InstanceOf(cx, obj, &js_IteratorClass.base, vp + 2))
42641:         return false;
    1: 
42641:     if (!js_IteratorMore(cx, obj, vp))
42641:         return false;
53076:     if (!vp->toBoolean()) {
 6464:         js_ThrowStopIteration(cx);
42641:         return false;
    1:     }
42641:     return js_IteratorNext(cx, obj, vp);
    1: }
    1: 
 4127: #define JSPROP_ROPERM   (JSPROP_READONLY | JSPROP_PERMANENT)
 4127: 
    1: static JSFunctionSpec iterator_methods[] = {
16519:     JS_FN(js_next_str,      iterator_next,  0,JSPROP_ROPERM),
 4127:     JS_FS_END
    1: };
    1: 
    1: /*
    1:  * Call ToObject(v).__iterator__(keyonly) if ToObject(v).__iterator__ exists.
11835:  * Otherwise construct the default iterator.
    1:  */
 9695: JS_FRIEND_API(JSBool)
52527: js_ValueToIterator(JSContext *cx, uintN flags, Value *vp)
    1: {
    1:     /* JSITER_KEYVALUE must always come with JSITER_FOREACH */
42641:     JS_ASSERT_IF(flags & JSITER_KEYVALUE, flags & JSITER_FOREACH);
42641: 
42641:     /*
42641:      * Make sure the more/next state machine doesn't get stuck. A value might be
42641:      * left in iterValue when a trace is left due to an operation time-out after
42641:      * JSOP_MOREITER but before the value is picked up by FOR*.
42641:      */
52527:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
    1: 
53059:     JSObject *obj;
52527:     if (vp->isObject()) {
40867:         /* Common case. */
53076:         obj = &vp->toObject();
    1:     } else {
    1:         /*
    1:          * Enumerating over null and undefined gives an empty enumerator.
    1:          * This is contrary to ECMA-262 9.9 ToObject, invoked from step 3 of
    1:          * the first production in 12.6.4 and step 4 of the second production,
40867:          * but it's "web JS" compatible. ES5 fixed for-in to match this de-facto
40867:          * standard.
    1:          */
    1:         if ((flags & JSITER_ENUMERATE)) {
53059:             if (!js_ValueToObjectOrNull(cx, *vp, &obj))
40395:                 return false;
    1:             if (!obj)
52527:                 return GetIterator(cx, NULL, flags, vp);
    1:         } else {
    1:             obj = js_ValueToNonNullObject(cx, *vp);
    1:             if (!obj)
40395:                 return false;
    1:         }
    1:     }
    1: 
53059:     AutoObjectRooter tvr(cx, obj);
    1: 
52527:     Class *clasp = obj->getClass();
52527:     ExtendedClass *xclasp;
 5899:     if ((clasp->flags & JSCLASS_IS_EXTENDED) &&
52527:         (xclasp = (ExtendedClass *) clasp)->iteratorObject) {
42641:         /* Enumerate Iterator.prototype directly. */
42641:         if (clasp != &js_IteratorClass.base || obj->getNativeIterator()) {
52527:             JSObject *iterobj = xclasp->iteratorObject(cx, obj, !(flags & JSITER_FOREACH));
 5899:             if (!iterobj)
40395:                 return false;
53021:             vp->setObject(*iterobj);
42641:             return true;
40844:         }
40844:     }
    1: 
42641:     return GetIterator(cx, obj, flags, vp);
 5899: }
    1: 
42641: #if JS_HAS_GENERATORS
42641: static JS_REQUIRES_STACK JSBool
42641: CloseGenerator(JSContext *cx, JSObject *genobj);
42641: #endif
    1: 
42641: JS_FRIEND_API(JSBool)
53099: js_CloseIterator(JSContext *cx, JSObject *obj)
 3025: {
52527:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
 3025: 
52527:     Class *clasp = obj->getClass();
42641:     if (clasp == &js_IteratorClass.base) {
43281:         /* Remove enumerators from the active list, which is a stack. */
43281:         NativeIterator *ni = obj->getNativeIterator();
43281:         if (ni->flags & JSITER_ENUMERATE) {
43281:             JS_ASSERT(cx->enumerators == obj);
43281:             cx->enumerators = ni->next;
43281:         }
43281: 
42641:         /* Cache the iterator object if possible. */
42641:         if (ni->shapes_length) {
43190:             uint32 hash = ni->shapes_key % NATIVE_ITER_CACHE_SIZE;
42641:             JSObject **hp = &JS_THREAD_DATA(cx)->cachedNativeIterators[hash];
42641:             ni->props_cursor = ni->props_array;
42641:             ni->next = *hp;
42641:             *hp = obj;
42641:         } else {
42641:             iterator_finalize(cx, obj);
42641:         }
 3025:     }
 3025: #if JS_HAS_GENERATORS
42641:     else if (clasp == &js_GeneratorClass.base) {
42641:         return CloseGenerator(cx, obj);
 3025:     }
 3025: #endif
 3025:     return JS_TRUE;
 3025: }
 3025: 
43281: /*
43281:  * Suppress enumeration of deleted properties. We maintain a list of all active
43281:  * non-escaping for-in enumerators. Whenever a property is deleted, we check
43281:  * whether any active enumerator contains the (obj, id) pair and has not
43281:  * enumerated id yet. If so, we delete the id from the list (or advance the
43281:  * cursor if it is the next id to be enumerated).
43281:  *
43281:  * We do not suppress enumeration of a property deleted along an object's
43281:  * prototype chain. Only direct deletions on the object are handled.
43281:  */
43281: bool
43281: js_SuppressDeletedProperty(JSContext *cx, JSObject *obj, jsid id)
43281: {
43281:     JSObject *iterobj = cx->enumerators;
43281:     while (iterobj) {
47383:       again:
43281:         NativeIterator *ni = iterobj->getNativeIterator();
52924:         /* This only works for identified surpressed keys, not values. */
53059:         if (ni->isKeyIter() && ni->obj == obj && ni->props_cursor < ni->props_end) {
43281:             /* Check whether id is still to come. */
53059:             jsid *props_cursor = ni->currentKey();
53059:             jsid *props_end = ni->endKey();
47383:             for (jsid *idp = props_cursor; idp < props_end; ++idp) {
43281:                 if (*idp == id) {
43281:                     /*
43281:                      * Check whether another property along the prototype chain
43281:                      * became visible as a result of this deletion.
43281:                      */
43281:                     if (obj->getProto()) {
43281:                         AutoObjectRooter proto(cx, obj->getProto());
43281:                         AutoObjectRooter obj2(cx);
43281:                         JSProperty *prop;
43281:                         if (!proto.object()->lookupProperty(cx, id, obj2.addr(), &prop))
43281:                             return false;
43290:                         if (prop) {
43281:                             uintN attrs;
43290:                             if (obj2.object()->isNative()) {
43290:                                 attrs = ((JSScopeProperty *) prop)->attributes();
43290:                                 JS_UNLOCK_OBJ(cx, obj2.object());
43290:                             } else if (!obj2.object()->getAttributes(cx, id, &attrs)) {
43281:                                 return false;
43290:                             }
43281:                             if (attrs & JSPROP_ENUMERATE)
43281:                                 continue;
43281:                         }
43281:                     }
43281: 
43281:                     /*
47383:                      * If lookupProperty or getAttributes above removed a property from
47383:                      * ni, start over.
47383:                      */
47383:                     if (props_end != ni->props_end || props_cursor != ni->props_cursor)
47383:                         goto again;
47383: 
47383:                     /*
43281:                      * No property along the prototype chain steppeded in to take the
43281:                      * property's place, so go ahead and delete id from the list.
43281:                      * If it is the next property to be enumerated, just skip it.
43281:                      */
47383:                     if (idp == props_cursor) {
53059:                         ni->incKeyCursor();
43281:                     } else {
47383:                         memmove(idp, idp + 1, (props_end - (idp + 1)) * sizeof(jsid));
53059:                         ni->props_end = ni->endKey() - 1;
43281:                     }
43281:                     break;
43281:                 }
43281:             }
43281:         }
43281:         iterobj = ni->next;
43281:     }
43281:     return true;
43281: }
43281: 
42641: JSBool
52527: js_IteratorMore(JSContext *cx, JSObject *iterobj, Value *rval)
    1: {
42641:     /* Fast path for native iterators */
42641:     if (iterobj->getClass() == &js_IteratorClass.base) {
    1:         /*
42641:          * Implement next directly as all the methods of native iterator are
42641:          * read-only and permanent.
    1:          */
42641:         NativeIterator *ni = iterobj->getNativeIterator();
52527:         rval->setBoolean(ni->props_cursor < ni->props_end);
42641:         return true;
    1:     }
    1: 
42641:     /* We might still have a pending value. */
52527:     if (!cx->iterValue.isMagic(JS_NO_ITER_VALUE)) {
52527:         rval->setBoolean(true);
42641:         return true;
    1:     }
    1: 
42641:     /* Fetch and cache the next value from the iterator. */
    1:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.nextAtom);
52527:     if (!js_GetMethod(cx, iterobj, id, JSGET_METHOD_BARRIER, rval))
42641:         return false;
52527:     if (!InternalCall(cx, iterobj, *rval, 0, NULL, rval)) {
    1:         /* Check for StopIteration. */
21685:         if (!cx->throwing || !js_ValueIsStopIteration(cx->exception))
42641:             return false;
    1: 
    1:         /* Inline JS_ClearPendingException(cx). */
    1:         cx->throwing = JS_FALSE;
52527:         cx->exception.setUndefined();
52527:         cx->iterValue.setMagic(JS_NO_ITER_VALUE);
52527:         rval->setBoolean(false);
42641:         return true;
    1:     }
    1: 
42641:     /* Cache the value returned by iterobj.next() so js_IteratorNext() can find it. */
52527:     JS_ASSERT(!rval->isMagic(JS_NO_ITER_VALUE));
42641:     cx->iterValue = *rval;
52527:     rval->setBoolean(true);
42641:     return true;
42641: }
42641: 
42641: JSBool
52527: js_IteratorNext(JSContext *cx, JSObject *iterobj, Value *rval)
42641: {
42641:     /* Fast path for native iterators */
42641:     if (iterobj->getClass() == &js_IteratorClass.base) {
42641:         /*
42641:          * Implement next directly as all the methods of the native iterator are
42641:          * read-only and permanent.
42641:          */
42641:         NativeIterator *ni = iterobj->getNativeIterator();
42641:         JS_ASSERT(ni->props_cursor < ni->props_end);
53059:         if (ni->isKeyIter()) {
53059:             *rval = IdToValue(*ni->currentKey());
53059:             ni->incKeyCursor();
52924:         } else {
53059:             *rval = *ni->currentValue();
52924:             ni->incValueCursor();
52924:         }
42641: 
53059:         if (rval->isString() || !ni->isKeyIter())
42641:             return true;
42641: 
42641:         JSString *str;
42641:         jsint i;
53076:         if (rval->isInt32() && (jsuint(i = rval->toInt32()) < INT_STRING_LIMIT)) {
42641:             str = JSString::intString(i);
42641:         } else {
42641:             str = js_ValueToString(cx, *rval);
42641:             if (!str)
42641:                 return false;
42641:         }
42641: 
52527:         rval->setString(str);
42641:         return true;
42641:     }
42641: 
52527:     JS_ASSERT(!cx->iterValue.isMagic(JS_NO_ITER_VALUE));
42641:     *rval = cx->iterValue;
52527:     cx->iterValue.setMagic(JS_NO_ITER_VALUE);
42641: 
42641:     return true;
    1: }
    1: 
    1: static JSBool
52924: stopiter_hasInstance(JSContext *cx, JSObject *obj, const Value *v, JSBool *bp)
    1: {
52924:     *bp = js_ValueIsStopIteration(*v);
    1:     return JS_TRUE;
    1: }
    1: 
52527: Class js_StopIterationClass = {
    1:     js_StopIteration_str,
    1:     JSCLASS_HAS_CACHED_PROTO(JSProto_StopIteration),
52527:     PropertyStub,     PropertyStub,
52527:     PropertyStub,     PropertyStub,
52527:     EnumerateStub,    ResolveStub,
52527:     ConvertStub,      NULL,
    1:     NULL,             NULL,
    1:     NULL,             NULL,
    1:     NULL,             stopiter_hasInstance,
    1:     NULL,             NULL
    1: };
    1: 
    1: #if JS_HAS_GENERATORS
    1: 
    1: static void
    1: generator_finalize(JSContext *cx, JSObject *obj)
    1: {
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
31452:     if (!gen)
31452:         return;
    1: 
    1:     /*
31452:      * gen is open when a script has not called its close method while
31452:      * explicitly manipulating it.
    1:      */
31452:     JS_ASSERT(gen->state == JSGEN_NEWBORN ||
31452:               gen->state == JSGEN_CLOSED ||
    1:               gen->state == JSGEN_OPEN);
30851:     cx->free(gen);
    1: }
    1: 
  583: static void
  583: generator_trace(JSTracer *trc, JSObject *obj)
    1: {
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
 4282:     if (!gen)
 4282:         return;
 4282: 
    1:     /*
42714:      * Do not mark if the generator is running; the contents may be trash and
42714:      * will be replaced when the generator stops.
    1:      */
42714:     if (gen->state == JSGEN_RUNNING || gen->state == JSGEN_CLOSING)
42714:         return;
 4282: 
42714:     JSStackFrame *fp = gen->getFloatingFrame();
42714:     JS_ASSERT(gen->getLiveFrame() == fp);
52539:     MarkValueRange(trc, gen->floatingStack, fp->argEnd(), "generator slots");
42714:     js_TraceStackFrame(trc, fp);
52539:     MarkValueRange(trc, fp->slots(), gen->savedRegs.sp, "generator slots");
    1: }
    1: 
52527: ExtendedClass js_GeneratorClass = {
42641:   { js_Generator_str,
42641:     JSCLASS_HAS_PRIVATE |
42641:     JSCLASS_HAS_CACHED_PROTO(JSProto_Generator) |
42641:     JSCLASS_IS_ANONYMOUS |
42641:     JSCLASS_MARK_IS_TRACE |
42641:     JSCLASS_IS_EXTENDED,
52527:     PropertyStub,     PropertyStub,    PropertyStub,    PropertyStub,
52527:     EnumerateStub,    ResolveStub,     ConvertStub,     generator_finalize,
    1:     NULL,             NULL,            NULL,            NULL,
42641:     NULL,             NULL,            JS_CLASS_TRACE(generator_trace), NULL },
42641:     NULL,             NULL,            NULL,            iterator_iterator,
42641:     NULL,
42641:     JSCLASS_NO_RESERVED_MEMBERS
    1: };
    1: 
    1: /*
    1:  * Called from the JSOP_GENERATOR case in the interpreter, with fp referring
    1:  * to the frame by which the generator function was activated.  Create a new
    1:  * JSGenerator object, which contains its own JSStackFrame that we populate
    1:  * from *fp.  We know that upon return, the JSOP_GENERATOR opcode will return
    1:  * from the activation in fp, so we can steal away fp->callobj and fp->argsobj
    1:  * if they are non-null.
    1:  */
37777: JS_REQUIRES_STACK JSObject *
37777: js_NewGenerator(JSContext *cx)
    1: {
47497:     JSObject *obj = NewBuiltinClassInstance(cx, &js_GeneratorClass.base);
    1:     if (!obj)
    1:         return NULL;
    1: 
    1:     /* Load and compute stack slot counts. */
37777:     JSStackFrame *fp = cx->fp;
42714:     uintN argc = fp->argc;
42714:     uintN nargs = JS_MAX(argc, fp->fun->nargs);
42714:     uintN vplen = 2 + nargs;
    1: 
42714:     /* Compute JSGenerator size. */
42714:     uintN nbytes = sizeof(JSGenerator) +
52527:                    (-1 + /* one Value included in JSGenerator */
42714:                     vplen +
42714:                     VALUES_PER_STACK_FRAME +
52527:                     fp->script->nslots) * sizeof(Value);
42714: 
42714:     JSGenerator *gen = (JSGenerator *) cx->malloc(nbytes);
    1:     if (!gen)
31452:         return NULL;
    1: 
42714:     /* Cut up floatingStack space. */
52527:     Value *vp = gen->floatingStack;
42714:     JSStackFrame *newfp = reinterpret_cast<JSStackFrame *>(vp + vplen);
52527:     Value *slots = newfp->slots();
42714: 
42714:     /* Initialize JSGenerator. */
42709:     gen->obj = obj;
42714:     gen->state = JSGEN_NEWBORN;
42717:     gen->savedRegs.pc = cx->regs->pc;
42717:     JS_ASSERT(cx->regs->sp == fp->slots() + fp->script->nfixed);
42714:     gen->savedRegs.sp = slots + fp->script->nfixed;
42714:     gen->vplen = vplen;
43281:     gen->enumerators = NULL;
42714:     gen->liveFrame = newfp;
42708: 
42714:     /* Copy generator's stack frame copy in from |cx->fp|. */
42714:     newfp->imacpc = NULL;
42714:     newfp->callobj = fp->callobj;
42714:     if (fp->callobj) {      /* Steal call object. */
42714:         fp->callobj->setPrivate(newfp);
    1:         fp->callobj = NULL;
    1:     }
42714:     newfp->argsobj = fp->argsobj;
42714:     if (fp->argsobj) {      /* Steal args object. */
53059:         fp->argsobj->setPrivate(newfp);
    1:         fp->argsobj = NULL;
    1:     }
42714:     newfp->script = fp->script;
42714:     newfp->fun = fp->fun;
42714:     newfp->thisv = fp->thisv;
42714:     newfp->argc = fp->argc;
42714:     newfp->argv = vp + 2;
42714:     newfp->rval = fp->rval;
42714:     newfp->annotation = NULL;
42714:     newfp->scopeChain = fp->scopeChain;
42714:     JS_ASSERT(!fp->blockChain);
42714:     newfp->blockChain = NULL;
42714:     newfp->flags = fp->flags | JSFRAME_GENERATOR | JSFRAME_FLOATING_GENERATOR;
42709: 
42714:     /* Copy in arguments and slots. */
52527:     memcpy(vp, fp->argv - 2, vplen * sizeof(Value));
52527:     memcpy(slots, fp->slots(), fp->script->nfixed * sizeof(Value));
    1: 
31452:     obj->setPrivate(gen);
    1:     return obj;
    1: }
    1: 
42714: JSGenerator *
42714: js_FloatingFrameToGenerator(JSStackFrame *fp)
42714: {
42714:     JS_ASSERT(fp->isGenerator() && fp->isFloatingGenerator());
42714:     char *floatingStackp = (char *)(fp->argv - 2);
42714:     char *p = floatingStackp - offsetof(JSGenerator, floatingStack);
42714:     return reinterpret_cast<JSGenerator *>(p);
42714: }
42714: 
    1: typedef enum JSGeneratorOp {
    1:     JSGENOP_NEXT,
    1:     JSGENOP_SEND,
    1:     JSGENOP_THROW,
    1:     JSGENOP_CLOSE
    1: } JSGeneratorOp;
    1: 
    1: /*
    1:  * Start newborn or restart yielding generator and perform the requested
    1:  * operation inside its frame.
    1:  */
24499: static JS_REQUIRES_STACK JSBool
    1: SendToGenerator(JSContext *cx, JSGeneratorOp op, JSObject *obj,
52527:                 JSGenerator *gen, const Value &arg)
    1: {
 3554:     if (gen->state == JSGEN_RUNNING || gen->state == JSGEN_CLOSING) {
 3554:         js_ReportValueError(cx, JSMSG_NESTING_GENERATOR,
53076:                             JSDVG_SEARCH_STACK, ObjectOrNullValue(obj),
42714:                             JS_GetFunctionId(gen->getFloatingFrame()->fun));
 3554:         return JS_FALSE;
 3554:     }
 3554: 
42714:     /* Check for OOM errors here, where we can fail easily. */
42714:     if (!cx->ensureGeneratorStackSpace())
42714:         return JS_FALSE;
42714: 
    1:     JS_ASSERT(gen->state ==  JSGEN_NEWBORN || gen->state == JSGEN_OPEN);
    1:     switch (op) {
    1:       case JSGENOP_NEXT:
    1:       case JSGENOP_SEND:
    1:         if (gen->state == JSGEN_OPEN) {
    1:             /*
    1:              * Store the argument to send as the result of the yield
    1:              * expression.
    1:              */
13168:             gen->savedRegs.sp[-1] = arg;
    1:         }
    1:         gen->state = JSGEN_RUNNING;
    1:         break;
    1: 
    1:       case JSGENOP_THROW:
52527:         SetPendingException(cx, arg);
    1:         gen->state = JSGEN_RUNNING;
    1:         break;
    1: 
    1:       default:
    1:         JS_ASSERT(op == JSGENOP_CLOSE);
53076:         SetPendingException(cx, MagicValue(JS_GENERATOR_CLOSING));
    1:         gen->state = JSGEN_CLOSING;
    1:         break;
    1:     }
    1: 
42714:     JSStackFrame *genfp = gen->getFloatingFrame();
42714:     JSBool ok;
42714:     {
52527:         Value *genVp = gen->floatingStack;
42714:         uintN vplen = gen->vplen;
42714:         uintN nfixed = genfp->script->nslots;
42652: 
42714:         /*
42714:          * Get a pointer to new frame/slots. This memory is not "claimed", so
42714:          * the code before pushExecuteFrame must not reenter the interpreter.
42714:          */
42714:         ExecuteFrameGuard frame;
42714:         if (!cx->stack().getExecuteFrame(cx, cx->fp, vplen, nfixed, frame)) {
42714:             gen->state = JSGEN_CLOSED;
42714:             return JS_FALSE;
42714:         }
42714: 
52527:         Value *vp = frame.getvp();
42714:         JSStackFrame *fp = frame.getFrame();
42714: 
42714:         /*
42714:          * Copy and rebase stack frame/args/slots. The "floating" flag must
42714:          * only be set on the generator's frame. See args_or_call_trace.
42714:          */
42714:         uintN usedBefore = gen->savedRegs.sp - genVp;
52527:         memcpy(vp, genVp, usedBefore * sizeof(Value));
42714:         fp->flags &= ~JSFRAME_FLOATING_GENERATOR;
42714:         fp->argv = vp + 2;
42714:         gen->savedRegs.sp = fp->slots() + (gen->savedRegs.sp - genfp->slots());
42714:         JS_ASSERT(uintN(gen->savedRegs.sp - fp->slots()) <= fp->script->nslots);
42714: 
42714: #ifdef DEBUG
42714:         JSObject *callobjBefore = fp->callobj;
53059:         JSObject *argsobjBefore = fp->argsobj;
42714: #endif
42714: 
42714:         /*
42714:          * Repoint Call, Arguments, Block and With objects to the new live
42714:          * frame. Call and Arguments are done directly because we have
42714:          * pointers to them. Block and With objects are done indirectly through
42714:          * 'liveFrame'. See js_LiveFrameToFloating comment in jsiter.h.
42714:          */
42714:         if (genfp->callobj)
42714:             fp->callobj->setPrivate(fp);
42714:         if (genfp->argsobj)
53059:             fp->argsobj->setPrivate(fp);
42714:         gen->liveFrame = fp;
42714:         (void)cx->enterGenerator(gen); /* OOM check above. */
42714: 
42714:         /* Officially push |fp|. |frame|'s destructor pops. */
42717:         cx->stack().pushExecuteFrame(cx, frame, gen->savedRegs, NULL);
42714: 
43281:         /* Swap the enumerators stack for the generator's stack. */
43281:         JSObject *enumerators = cx->enumerators;
43281:         cx->enumerators = gen->enumerators;
43281: 
52527:         ok = Interpret(cx);
42708: 
43281:         /* Restore the original enumerators stack. */
43281:         gen->enumerators = cx->enumerators;
43281:         cx->enumerators = enumerators;
43281: 
42714:         /* Restore call/args/block objects. */
42714:         cx->leaveGenerator(gen);
42714:         gen->liveFrame = genfp;
42714:         if (fp->argsobj)
53059:             fp->argsobj->setPrivate(genfp);
42714:         if (fp->callobj)
42714:             fp->callobj->setPrivate(genfp);
42708: 
42714:         JS_ASSERT_IF(argsobjBefore, argsobjBefore == fp->argsobj);
42714:         JS_ASSERT_IF(callobjBefore, callobjBefore == fp->callobj);
42714: 
42714:         /* Copy and rebase stack frame/args/slots. Restore "floating" flag. */
42714:         JS_ASSERT(uintN(gen->savedRegs.sp - fp->slots()) <= fp->script->nslots);
42714:         uintN usedAfter = gen->savedRegs.sp - vp;
52527:         memcpy(genVp, vp, usedAfter * sizeof(Value));
42714:         genfp->flags |= JSFRAME_FLOATING_GENERATOR;
42714:         genfp->argv = genVp + 2;
42714:         gen->savedRegs.sp = genfp->slots() + (gen->savedRegs.sp - fp->slots());
42714:         JS_ASSERT(uintN(gen->savedRegs.sp - genfp->slots()) <= genfp->script->nslots);
42714:     }
42714: 
42714:     if (gen->getFloatingFrame()->flags & JSFRAME_YIELDING) {
    1:         /* Yield cannot fail, throw or be called on closing. */
    1:         JS_ASSERT(ok);
    1:         JS_ASSERT(!cx->throwing);
    1:         JS_ASSERT(gen->state == JSGEN_RUNNING);
    1:         JS_ASSERT(op != JSGENOP_CLOSE);
42714:         genfp->flags &= ~JSFRAME_YIELDING;
    1:         gen->state = JSGEN_OPEN;
    1:         return JS_TRUE;
    1:     }
    1: 
52527:     genfp->rval.setUndefined();
    1:     gen->state = JSGEN_CLOSED;
    1:     if (ok) {
    1:         /* Returned, explicitly or by falling off the end. */
    1:         if (op == JSGENOP_CLOSE)
    1:             return JS_TRUE;
 6464:         return js_ThrowStopIteration(cx);
    1:     }
    1: 
    1:     /*
 9780:      * An error, silent termination by operation callback or an exception.
    1:      * Propagate the condition to the caller.
    1:      */
    1:     return JS_FALSE;
    1: }
    1: 
24499: static JS_REQUIRES_STACK JSBool
 3436: CloseGenerator(JSContext *cx, JSObject *obj)
    1: {
42641:     JS_ASSERT(obj->getClass() == &js_GeneratorClass.base);
 3025: 
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
 3025:     if (!gen) {
 3025:         /* Generator prototype object. */
 3025:         return JS_TRUE;
 3025:     }
 3025: 
 3025:     if (gen->state == JSGEN_CLOSED)
 3025:         return JS_TRUE;
 3025: 
53076:     return SendToGenerator(cx, JSGENOP_CLOSE, obj, gen, UndefinedValue());
    1: }
    1: 
    1: /*
    1:  * Common subroutine of generator_(next|send|throw|close) methods.
    1:  */
    1: static JSBool
52527: generator_op(JSContext *cx, JSGeneratorOp op, Value *vp, uintN argc)
    1: {
 4127:     JSObject *obj;
37741:     LeaveTrace(cx);
24499: 
53059:     obj = ComputeThisFromVp(cx, vp);
52527:     if (!InstanceOf(cx, obj, &js_GeneratorClass.base, vp + 2))
    1:         return JS_FALSE;
    1: 
31452:     JSGenerator *gen = (JSGenerator *) obj->getPrivate();
31452:     if (!gen) {
    1:         /* This happens when obj is the generator prototype. See bug 352885. */
    1:         goto closed_generator;
    1:     }
    1: 
 3554:     if (gen->state == JSGEN_NEWBORN) {
    1:         switch (op) {
    1:           case JSGENOP_NEXT:
    1:           case JSGENOP_THROW:
    1:             break;
    1: 
    1:           case JSGENOP_SEND:
52527:             if (argc >= 1 && !vp[2].isUndefined()) {
    1:                 js_ReportValueError(cx, JSMSG_BAD_GENERATOR_SEND,
 4127:                                     JSDVG_SEARCH_STACK, vp[2], NULL);
    1:                 return JS_FALSE;
    1:             }
    1:             break;
    1: 
    1:           default:
    1:             JS_ASSERT(op == JSGENOP_CLOSE);
    1:             gen->state = JSGEN_CLOSED;
    1:             return JS_TRUE;
    1:         }
 3554:     } else if (gen->state == JSGEN_CLOSED) {
    1:       closed_generator:
    1:         switch (op) {
    1:           case JSGENOP_NEXT:
    1:           case JSGENOP_SEND:
 6464:             return js_ThrowStopIteration(cx);
    1:           case JSGENOP_THROW:
53076:             SetPendingException(cx, argc >= 1 ? vp[2] : UndefinedValue());
    1:             return JS_FALSE;
    1:           default:
    1:             JS_ASSERT(op == JSGENOP_CLOSE);
    1:             return JS_TRUE;
    1:         }
    1:     }
    1: 
52527:     bool undef = ((op == JSGENOP_SEND || op == JSGENOP_THROW) && argc != 0);
53076:     if (!SendToGenerator(cx, op, obj, gen, undef ? vp[2] : UndefinedValue()))
    1:         return JS_FALSE;
42714:     *vp = gen->getFloatingFrame()->rval;
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
52527: generator_send(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return generator_op(cx, JSGENOP_SEND, vp, argc);
    1: }
    1: 
    1: static JSBool
52527: generator_next(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return generator_op(cx, JSGENOP_NEXT, vp, argc);
    1: }
    1: 
    1: static JSBool
52527: generator_throw(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return generator_op(cx, JSGENOP_THROW, vp, argc);
    1: }
    1: 
    1: static JSBool
52527: generator_close(JSContext *cx, uintN argc, Value *vp)
    1: {
16519:     return generator_op(cx, JSGENOP_CLOSE, vp, argc);
    1: }
    1: 
    1: static JSFunctionSpec generator_methods[] = {
16519:     JS_FN(js_next_str,      generator_next,     0,JSPROP_ROPERM),
16519:     JS_FN(js_send_str,      generator_send,     1,JSPROP_ROPERM),
16519:     JS_FN(js_throw_str,     generator_throw,    1,JSPROP_ROPERM),
16519:     JS_FN(js_close_str,     generator_close,    0,JSPROP_ROPERM),
 4127:     JS_FS_END
    1: };
    1: 
    1: #endif /* JS_HAS_GENERATORS */
    1: 
    1: JSObject *
    1: js_InitIteratorClasses(JSContext *cx, JSObject *obj)
    1: {
    1:     JSObject *proto, *stop;
    1: 
    1:     /* Idempotency required: we initialize several things, possibly lazily. */
    1:     if (!js_GetClassObject(cx, obj, JSProto_StopIteration, &stop))
    1:         return NULL;
    1:     if (stop)
    1:         return stop;
    1: 
52527:     proto = js_InitClass(cx, obj, NULL, &js_IteratorClass.base, Iterator, 2,
    1:                          NULL, iterator_methods, NULL, NULL);
    1:     if (!proto)
    1:         return NULL;
    1: 
    1: #if JS_HAS_GENERATORS
    1:     /* Initialize the generator internals if configured. */
52527:     if (!js_InitClass(cx, obj, NULL, &js_GeneratorClass.base, NULL, 0,
    1:                       NULL, generator_methods, NULL, NULL)) {
    1:         return NULL;
    1:     }
    1: #endif
    1: 
52527:     return js_InitClass(cx, obj, NULL, &js_StopIterationClass, NULL, 0,
    1:                         NULL, NULL, NULL, NULL);
    1: }
