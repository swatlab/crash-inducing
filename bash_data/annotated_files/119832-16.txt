 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
119363: #include "NSPRFormatTime.h" // must be before anything that includes prtime.h
     1: #include "nsNSSComponent.h" // for PIPNSS string bundle calls.
     1: #include "nsCertTree.h"
     1: #include "nsITreeColumns.h"
     1: #include "nsIX509Cert.h"
     1: #include "nsIX509CertValidity.h"
     1: #include "nsIX509CertDB.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsNSSCertificate.h"
     1: #include "nsNSSCertHelper.h"
     1: #include "nsINSSCertCache.h"
     1: #include "nsIMutableArray.h"
     1: #include "nsArrayUtils.h"
     1: #include "nsISupportsPrimitives.h"
     1: #include "nsXPCOMCID.h"
  6598: #include "nsTHashtable.h"
  6598: #include "nsHashKeys.h"
  6598: 
119832: 
119235: #include "prlog.h"
     1: #ifdef PR_LOGGING
     1: extern PRLogModuleInfo* gPIPNSSLog;
     1: #endif
     1: 
119832: #include "nsNSSCleaner.h"
  6598: NSSCleanupAutoPtrClass(CERTCertificate, CERT_DestroyCertificate)
  6598: 
     1: static NS_DEFINE_CID(kNSSComponentCID, NS_NSSCOMPONENT_CID);
 77089: static NS_DEFINE_CID(kCertOverrideCID, NS_CERTOVERRIDE_CID);
     1: 
     1: // treeArrayElStr
     1: //
     1: // structure used to hold map of tree.  Each thread (an organization
     1: // field from a cert) has an element in the array.  The numChildren field
     1: // stores the number of certs corresponding to that thread.
     1: struct treeArrayElStr {
     1:   nsString   orgName;     /* heading for thread                   */
 79445:   bool       open;        /* toggle open state for thread         */
108991:   int32_t    certIndex;   /* index into cert array for 1st cert   */
108991:   int32_t    numChildren; /* number of chidren (certs) for thread */
     1: };
     1: 
     1: CompareCacheHashEntryPtr::CompareCacheHashEntryPtr()
     1: {
     1:   entry = new CompareCacheHashEntry;
     1: }
     1: 
     1: CompareCacheHashEntryPtr::~CompareCacheHashEntryPtr()
     1: {
     1:   delete entry;
     1: }
     1: 
     1: CompareCacheHashEntry::CompareCacheHashEntry()
106838: :key(nullptr)
     1: {
     1:   for (int i = 0; i < max_criterions; ++i) {
 80486:     mCritInit[i] = false;
     1:   }
     1: }
     1: 
118449: static bool
     1: CompareCacheMatchEntry(PLDHashTable *table, const PLDHashEntryHdr *hdr,
     1:                          const void *key)
     1: {
  3233:   const CompareCacheHashEntryPtr *entryPtr = static_cast<const CompareCacheHashEntryPtr*>(hdr);
     1:   return entryPtr->entry->key == key;
     1: }
     1: 
118449: static bool
     1: CompareCacheInitEntry(PLDHashTable *table, PLDHashEntryHdr *hdr,
     1:                      const void *key)
     1: {
     1:   new (hdr) CompareCacheHashEntryPtr();
  3233:   CompareCacheHashEntryPtr *entryPtr = static_cast<CompareCacheHashEntryPtr*>(hdr);
     1:   if (!entryPtr->entry) {
 80486:     return false;
     1:   }
     1:   entryPtr->entry->key = (void*)key;
 80486:   return true;
     1: }
     1: 
118449: static void
     1: CompareCacheClearEntry(PLDHashTable *table, PLDHashEntryHdr *hdr)
     1: {
  3233:   CompareCacheHashEntryPtr *entryPtr = static_cast<CompareCacheHashEntryPtr*>(hdr);
     1:   entryPtr->~CompareCacheHashEntryPtr();
     1: }
     1: 
     1: static PLDHashTableOps gMapOps = {
     1:   PL_DHashAllocTable,
     1:   PL_DHashFreeTable,
     1:   PL_DHashVoidPtrKeyStub,
     1:   CompareCacheMatchEntry,
     1:   PL_DHashMoveEntryStub,
     1:   CompareCacheClearEntry,
     1:   PL_DHashFinalizeStub,
     1:   CompareCacheInitEntry
     1: };
     1: 
  6598: NS_IMPL_ISUPPORTS0(nsCertAddonInfo)
  6598: NS_IMPL_ISUPPORTS1(nsCertTreeDispInfo, nsICertTreeItem)
     1: 
  6598: nsCertTreeDispInfo::nsCertTreeDispInfo()
106838: :mAddonInfo(nullptr)
  6598: ,mTypeOfEntry(direct_db)
 14555: ,mPort(-1)
  6598: ,mOverrideBits(nsCertOverride::ob_None)
 80486: ,mIsTemporary(true)
  6598: {
  6598: }
  6598: 
  6598: nsCertTreeDispInfo::nsCertTreeDispInfo(nsCertTreeDispInfo &other)
  6598: {
  6598:   mAddonInfo = other.mAddonInfo;
  6598:   mTypeOfEntry = other.mTypeOfEntry;
 14555:   mAsciiHost = other.mAsciiHost;
 14555:   mPort = other.mPort;
  6598:   mOverrideBits = other.mOverrideBits;
  8176:   mIsTemporary = other.mIsTemporary;
 20772:   mCert = other.mCert;
  6598: }
  6598: 
  6598: nsCertTreeDispInfo::~nsCertTreeDispInfo()
  6598: {
  6598: }
  6598: 
  6598: NS_IMETHODIMP
  6598: nsCertTreeDispInfo::GetCert(nsIX509Cert **_cert)
  6598: {
  6598:   NS_ENSURE_ARG(_cert);
 20772:   if (mCert) {
 20772:     // we may already have the cert for temporary overrides
 20772:     *_cert = mCert;
 20772:     NS_IF_ADDREF(*_cert);
 20772:     return NS_OK;
 20772:   }
  6598:   if (mAddonInfo) {
  6598:     *_cert = mAddonInfo->mCert.get();
  6598:     NS_IF_ADDREF(*_cert);
  6598:   }
  6598:   else {
106838:     *_cert = nullptr;
  6598:   }
  6598:   return NS_OK;
  6598: }
  6598: 
  6598: NS_IMETHODIMP
  6598: nsCertTreeDispInfo::GetHostPort(nsAString &aHostPort)
  6598: {
110974:   nsAutoCString hostPort;
 14555:   nsCertOverrideService::GetHostWithPort(mAsciiHost, mPort, hostPort);
 14555:   aHostPort = NS_ConvertUTF8toUTF16(hostPort);
  6598:   return NS_OK;
  6598: }
     1: 
     1: NS_IMPL_ISUPPORTS2(nsCertTree, nsICertTree, nsITreeView)
     1: 
119832: nsCertTree::nsCertTree() : mTreeArray(NULL)
     1: {
106838:   mCompareCache.ops = nullptr;
     1:   mNSSComponent = do_GetService(kNSSComponentCID);
  6598:   mOverrideService = do_GetService("@mozilla.org/security/certoverride;1");
 77089:   // Might be a different service if someone is overriding the contract
 77089:   nsCOMPtr<nsICertOverrideService> origCertOverride =
 77089:     do_GetService(kCertOverrideCID);
 77089:   mOriginalOverrideService =
 77089:     static_cast<nsCertOverrideService*>(origCertOverride.get());
106838:   mCellText = nullptr;
     1: }
     1: 
     1: void nsCertTree::ClearCompareHash()
     1: {
     1:   if (mCompareCache.ops) {
     1:     PL_DHashTableFinish(&mCompareCache);
106838:     mCompareCache.ops = nullptr;
     1:   }
     1: }
     1: 
     1: nsresult nsCertTree::InitCompareHash()
     1: {
     1:   ClearCompareHash();
106838:   if (!PL_DHashTableInit(&mCompareCache, &gMapOps, nullptr,
     1:                          sizeof(CompareCacheHashEntryPtr), 128)) {
106838:     mCompareCache.ops = nullptr;
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: nsCertTree::~nsCertTree()
     1: {
     1:   ClearCompareHash();
     1:   delete [] mTreeArray;
     1: }
     1: 
     1: void
     1: nsCertTree::FreeCertArray()
     1: {
  6598:   mDispInfo.Clear();
     1: }
     1: 
     1: CompareCacheHashEntry *
     1: nsCertTree::getCacheEntry(void *cache, void *aCert)
     1: {
  3233:   PLDHashTable &aCompareCache = *reinterpret_cast<PLDHashTable*>(cache);
     1:   CompareCacheHashEntryPtr *entryPtr = 
  3233:     static_cast<CompareCacheHashEntryPtr*>
  3233:                (PL_DHashTableOperate(&aCompareCache, aCert, PL_DHASH_ADD));
119832:   return entryPtr ? entryPtr->entry : NULL;
     1: }
     1: 
     1: void nsCertTree::RemoveCacheEntry(void *key)
     1: {
     1:   PL_DHashTableOperate(&mCompareCache, key, PL_DHASH_REMOVE);
     1: }
     1: 
     1: // CountOrganizations
     1: //
     1: // Count the number of different organizations encountered in the cert
     1: // list.
108991: int32_t
     1: nsCertTree::CountOrganizations()
     1: {
108991:   uint32_t i, certCount;
  6598:   certCount = mDispInfo.Length();
     1:   if (certCount == 0) return 0;
106838:   nsCOMPtr<nsIX509Cert> orgCert = nullptr;
 95541:   nsCertAddonInfo *addonInfo = mDispInfo.ElementAt(0)->mAddonInfo;
 95541:   if (addonInfo) {
 95541:     orgCert = addonInfo->mCert;
  6598:   }
106838:   nsCOMPtr<nsIX509Cert> nextCert = nullptr;
108991:   int32_t orgCount = 1;
     1:   for (i=1; i<certCount; i++) {
106838:     nextCert = nullptr;
119832:     addonInfo = mDispInfo.SafeElementAt(i, NULL)->mAddonInfo;
 95541:     if (addonInfo) {
 95541:       nextCert = addonInfo->mCert;
  6598:     }
     1:     // XXX we assume issuer org is always criterion 1
     1:     if (CmpBy(&mCompareCache, orgCert, nextCert, sort_IssuerOrg, sort_None, sort_None) != 0) {
     1:       orgCert = nextCert;
     1:       orgCount++;
     1:     }
     1:   }
     1:   return orgCount;
     1: }
     1: 
     1: // GetThreadDescAtIndex
     1: //
     1: // If the row at index is an organization thread, return the collection
     1: // associated with that thread.  Otherwise, return null.
     1: treeArrayEl *
108991: nsCertTree::GetThreadDescAtIndex(int32_t index)
     1: {
     1:   int i, idx=0;
106838:   if (index < 0) return nullptr;
     1:   for (i=0; i<mNumOrgs; i++) {
     1:     if (index == idx) {
     1:       return &mTreeArray[i];
     1:     }
     1:     if (mTreeArray[i].open) {
     1:       idx += mTreeArray[i].numChildren;
     1:     }
     1:     idx++;
     1:     if (idx > index) break;
     1:   }
106838:   return nullptr;
     1: }
     1: 
     1: //  GetCertAtIndex
     1: //
     1: //  If the row at index is a cert, return that cert.  Otherwise, return null.
  7052: already_AddRefed<nsIX509Cert>
108991: nsCertTree::GetCertAtIndex(int32_t index, int32_t *outAbsoluteCertOffset)
     1: {
119832:   nsRefPtr<nsCertTreeDispInfo> certdi =
119832:     GetDispInfoAtIndex(index, outAbsoluteCertOffset);
  6598:   if (!certdi)
106838:     return nullptr;
  6598: 
106838:   nsIX509Cert *rawPtr = nullptr;
 20772:   if (certdi->mCert) {
 20772:     rawPtr = certdi->mCert;
 20772:   } else if (certdi->mAddonInfo) {
  6598:     rawPtr = certdi->mAddonInfo->mCert;
 20772:   }
  6598:   NS_IF_ADDREF(rawPtr);
  6598:   return rawPtr;
  6598: }
  6598: 
  6598: //  If the row at index is a cert, return that cert.  Otherwise, return null.
119832: already_AddRefed<nsCertTreeDispInfo>
108991: nsCertTree::GetDispInfoAtIndex(int32_t index, 
108991:                                int32_t *outAbsoluteCertOffset)
  6598: {
     1:   int i, idx = 0, cIndex = 0, nc;
106838:   if (index < 0) return nullptr;
     1:   // Loop over the threads
     1:   for (i=0; i<mNumOrgs; i++) {
106838:     if (index == idx) return nullptr; // index is for thread
     1:     idx++; // get past the thread
     1:     nc = (mTreeArray[i].open) ? mTreeArray[i].numChildren : 0;
     1:     if (index < idx + nc) { // cert is within range of this thread
108991:       int32_t certIndex = cIndex + index - idx;
     1:       if (outAbsoluteCertOffset)
     1:         *outAbsoluteCertOffset = certIndex;
119832:       nsRefPtr<nsCertTreeDispInfo> certdi = mDispInfo.SafeElementAt(certIndex, NULL);
  6598:       if (certdi) {
  6598:         nsCertTreeDispInfo *raw = certdi.get();
  6598:         NS_IF_ADDREF(raw);
  6598:         return raw;
  6598:       }
     1:       break;
     1:     }
     1:     if (mTreeArray[i].open)
     1:       idx += mTreeArray[i].numChildren;
     1:     cIndex += mTreeArray[i].numChildren;
     1:     if (idx > index) break;
     1:   }
106838:   return nullptr;
     1: }
     1: 
     1: nsCertTree::nsCertCompareFunc
108991: nsCertTree::GetCompareFuncFromCertType(uint32_t aType)
     1: {
     1:   switch (aType) {
     1:     case nsIX509Cert2::ANY_CERT:
     1:     case nsIX509Cert::USER_CERT:
     1:       return CmpUserCert;
     1:     case nsIX509Cert::CA_CERT:
     1:       return CmpCACert;
     1:     case nsIX509Cert::EMAIL_CERT:
     1:       return CmpEmailCert;
     1:     case nsIX509Cert::SERVER_CERT:
     1:     default:
     1:       return CmpWebSiteCert;
     1:   }
     1: }
     1: 
  6598: struct nsCertAndArrayAndPositionAndCounterAndTracker
  6598: {
119832:   nsRefPtr<nsCertAddonInfo> certai;
119832:   nsTArray< nsRefPtr<nsCertTreeDispInfo> > *array;
  6598:   int position;
  6598:   int counter;
  6598:   nsTHashtable<nsCStringHashKey> *tracker;
  6598: };
  6598: 
  6598: // Used to enumerate host:port overrides that match a stored
  6598: // certificate, creates and adds a display-info-object to the
  6598: // provided array. Increments insert position and entry counter.
  6598: // We remove the given key from the tracker, which is used to 
  6598: // track entries that have not yet been handled.
  6598: // The created display-info references the cert, so make a note
  6598: // of that by incrementing the cert usage counter.
118449: static void
  6598: MatchingCertOverridesCallback(const nsCertOverride &aSettings,
  6598:                               void *aUserData)
  6598: {
  6598:   nsCertAndArrayAndPositionAndCounterAndTracker *cap = 
  6598:     (nsCertAndArrayAndPositionAndCounterAndTracker*)aUserData;
  6598:   if (!cap)
  6598:     return;
  6598: 
  6598:   nsCertTreeDispInfo *certdi = new nsCertTreeDispInfo;
  6598:   if (certdi) {
  6598:     if (cap->certai)
  6598:       cap->certai->mUsageCount++;
  6598:     certdi->mAddonInfo = cap->certai;
  6598:     certdi->mTypeOfEntry = nsCertTreeDispInfo::host_port_override;
 14555:     certdi->mAsciiHost = aSettings.mAsciiHost;
 14555:     certdi->mPort = aSettings.mPort;
  6598:     certdi->mOverrideBits = aSettings.mOverrideBits;
  8176:     certdi->mIsTemporary = aSettings.mIsTemporary;
 20772:     certdi->mCert = aSettings.mCert;
  6598:     cap->array->InsertElementAt(cap->position, certdi);
  6598:     cap->position++;
  6598:     cap->counter++;
  6598:   }
  6598: 
  6598:   // this entry is now associated to a displayed cert, remove
  6598:   // it from the list of remaining entries
110974:   nsAutoCString hostPort;
 14555:   nsCertOverrideService::GetHostWithPort(aSettings.mAsciiHost, aSettings.mPort, hostPort);
 14555:   cap->tracker->RemoveEntry(hostPort);
  6598: }
  6598: 
  6598: // Used to collect a list of the (unique) host:port keys
  6598: // for all stored overrides.
118449: static void
  6598: CollectAllHostPortOverridesCallback(const nsCertOverride &aSettings,
  6598:                                     void *aUserData)
  6598: {
  6598:   nsTHashtable<nsCStringHashKey> *collectorTable =
  6598:     (nsTHashtable<nsCStringHashKey> *)aUserData;
  6598:   if (!collectorTable)
  6598:     return;
  6598: 
110974:   nsAutoCString hostPort;
 14555:   nsCertOverrideService::GetHostWithPort(aSettings.mAsciiHost, aSettings.mPort, hostPort);
 14555:   collectorTable->PutEntry(hostPort);
  6598: }
  6598: 
  6598: struct nsArrayAndPositionAndCounterAndTracker
  6598: {
119832:   nsTArray< nsRefPtr<nsCertTreeDispInfo> > *array;
  6598:   int position;
  6598:   int counter;
  6598:   nsTHashtable<nsCStringHashKey> *tracker;
  6598: };
  6598: 
  6598: // Used when enumerating the stored host:port overrides where
  6598: // no associated certificate was found in the NSS database.
118449: static void
  6598: AddRemaningHostPortOverridesCallback(const nsCertOverride &aSettings,
  6598:                                      void *aUserData)
  6598: {
  6598:   nsArrayAndPositionAndCounterAndTracker *cap = 
  6598:     (nsArrayAndPositionAndCounterAndTracker*)aUserData;
  6598:   if (!cap)
  6598:     return;
  6598: 
110974:   nsAutoCString hostPort;
 14555:   nsCertOverrideService::GetHostWithPort(aSettings.mAsciiHost, aSettings.mPort, hostPort);
 14555:   if (!cap->tracker->GetEntry(hostPort))
  6598:     return;
  6598: 
  6598:   // This entry is not associated to any stored cert,
  6598:   // so we still need to display it.
  6598: 
  6598:   nsCertTreeDispInfo *certdi = new nsCertTreeDispInfo;
  6598:   if (certdi) {
106838:     certdi->mAddonInfo = nullptr;
  6598:     certdi->mTypeOfEntry = nsCertTreeDispInfo::host_port_override;
 14555:     certdi->mAsciiHost = aSettings.mAsciiHost;
 14555:     certdi->mPort = aSettings.mPort;
  6598:     certdi->mOverrideBits = aSettings.mOverrideBits;
  8176:     certdi->mIsTemporary = aSettings.mIsTemporary;
 20772:     certdi->mCert = aSettings.mCert;
  6598:     cap->array->InsertElementAt(cap->position, certdi);
  6598:     cap->position++;
  6598:     cap->counter++;
  6598:   }
  6598: }
  6598: 
  6598: nsresult
     1: nsCertTree::GetCertsByTypeFromCertList(CERTCertList *aCertList,
108991:                                        uint32_t aWantedType,
     1:                                        nsCertCompareFunc  aCertCmpFn,
  6598:                                        void *aCertCmpFnArg)
     1: {
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("GetCertsByTypeFromCertList"));
     1:   if (!aCertList)
  6598:     return NS_ERROR_FAILURE;
  6598: 
 77089:   if (!mOriginalOverrideService)
  6598:     return NS_ERROR_FAILURE;
  6598: 
  6598:   nsTHashtable<nsCStringHashKey> allHostPortOverrideKeys;
 98908:   allHostPortOverrideKeys.Init();
  6598: 
  6598:   if (aWantedType == nsIX509Cert::SERVER_CERT) {
 77089:     mOriginalOverrideService->
106838:       EnumerateCertOverrides(nullptr, 
  6598:                              CollectAllHostPortOverridesCallback, 
  6598:                              &allHostPortOverrideKeys);
  6598:   }
  6598: 
     1:   CERTCertListNode *node;
     1:   int count = 0;
     1:   for (node = CERT_LIST_HEAD(aCertList);
     1:        !CERT_LIST_END(node, aCertList);
     1:        node = CERT_LIST_NEXT(node)) {
  6598: 
 79445:     bool wantThisCert = (aWantedType == nsIX509Cert2::ANY_CERT);
 79445:     bool wantThisCertIfNoOverrides = false;
 79445:     bool wantThisCertIfHaveOverrides = false;
 79445:     bool addOverrides = false;
  6598: 
  6598:     if (!wantThisCert) {
108991:       uint32_t thisCertType = getCertType(node->cert);
  6598: 
  6598:       // The output from getCertType is a "guess", which can be wrong.
  6598:       // The guess is based on stored trust flags, but for the host:port
  6598:       // overrides, we are storing certs without any trust flags associated.
  6598:       // So we must check whether the cert really belongs to the 
  6598:       // server, email or unknown tab. We will lookup the cert in the override
  6598:       // list to come to the decision. Unfortunately, the lookup in the
  6598:       // override list is quite expensive. Therefore we are using this 
  6598:       // lengthy if/else statement to minimize 
  6598:       // the number of override-list-lookups.
  6598: 
  6598:       if (aWantedType == nsIX509Cert::SERVER_CERT
  6598:           && thisCertType == nsIX509Cert::UNKNOWN_CERT) {
  6598:         // This unknown cert was stored without trust
  6598:         // Are there host:port based overrides stored?
  6598:         // If yes, display them.
 80486:         addOverrides = true;
  6598:       }
  6598:       else
  6598:       if (aWantedType == nsIX509Cert::UNKNOWN_CERT
  6598:           && thisCertType == nsIX509Cert::UNKNOWN_CERT) {
  6598:         // This unknown cert was stored without trust.
  6598:         // If there are associated overrides, do not show as unknown.
  6598:         // If there are no associated overrides, display as unknown.
 80486:         wantThisCertIfNoOverrides = true;
  6598:       }
  6598:       else
  6598:       if (aWantedType == nsIX509Cert::SERVER_CERT
  6598:           && thisCertType == nsIX509Cert::SERVER_CERT) {
  6598:         // This server cert is explicitly marked as a web site peer, 
  6598:         // with or without trust, but editable, so show it
 80486:         wantThisCert = true;
  6598:         // Are there host:port based overrides stored?
  6598:         // If yes, display them.
 80486:         addOverrides = true;
  6598:       }
  6598:       else
  6598:       if (aWantedType == nsIX509Cert::SERVER_CERT
  6598:           && thisCertType == nsIX509Cert::EMAIL_CERT) {
  6598:         // This cert might have been categorized as an email cert
  6598:         // because it carries an email address. But is it really one?
  6598:         // Our cert categorization is uncertain when it comes to
  6598:         // distinguish between email certs and web site certs.
  6598:         // So, let's see if we have an override for that cert
  6598:         // and if there is, conclude it's really a web site cert.
 80486:         addOverrides = true;
  6598:       }
  6598:       else
  6598:       if (aWantedType == nsIX509Cert::EMAIL_CERT
  6598:           && thisCertType == nsIX509Cert::EMAIL_CERT) {
  6598:         // This cert might have been categorized as an email cert
  6598:         // because it carries an email address. But is it really one?
  6598:         // Our cert categorization is uncertain when it comes to
  6598:         // distinguish between email certs and web site certs.
  6598:         // So, let's see if we have an override for that cert
  6598:         // and if there is, conclude it's really a web site cert.
 80486:         wantThisCertIfNoOverrides = true;
  6598:       }
  6598:       else
  6598:       if (thisCertType == aWantedType) {
 80486:         wantThisCert = true;
  6598:       }
  6598:     }
  6598: 
 56495:     nsCOMPtr<nsIX509Cert> pipCert = nsNSSCertificate::Create(node->cert);
  6598:     if (!pipCert)
  6598:       return NS_ERROR_OUT_OF_MEMORY;
  6598: 
  6598:     if (wantThisCertIfNoOverrides || wantThisCertIfHaveOverrides) {
108991:       uint32_t ocount = 0;
  8176:       nsresult rv = 
  8176:         mOverrideService->IsCertUsedForOverrides(pipCert, 
 80486:                                                  true, // we want temporaries
 80486:                                                  true, // we want permanents
  8176:                                                  &ocount);
  6598:       if (wantThisCertIfNoOverrides) {
  6598:         if (NS_FAILED(rv) || ocount == 0) {
  6598:           // no overrides for this cert
 80486:           wantThisCert = true;
  6598:         }
  6598:       }
  6598: 
  6598:       if (wantThisCertIfHaveOverrides) {
  6598:         if (NS_SUCCEEDED(rv) && ocount > 0) {
  6598:           // there are overrides for this cert
 80486:           wantThisCert = true;
  6598:         }
  6598:       }
  6598:     }
  6598: 
119832:     nsRefPtr<nsCertAddonInfo> certai = new nsCertAddonInfo;
119832:     if (!certai)
119832:       return NS_ERROR_OUT_OF_MEMORY;
119832: 
  6598:     certai->mCert = pipCert;
  6598:     certai->mUsageCount = 0;
  6598: 
  6598:     if (wantThisCert || addOverrides) {
  6598:       int InsertPosition = 0;
  6598:       for (; InsertPosition < count; ++InsertPosition) {
106838:         nsCOMPtr<nsIX509Cert> cert = nullptr;
119832:         nsRefPtr<nsCertTreeDispInfo> elem = mDispInfo.SafeElementAt(InsertPosition, NULL);
 95541:         if (elem && elem->mAddonInfo) {
 95541:           cert = elem->mAddonInfo->mCert;
  6598:         }
     1:         if ((*aCertCmpFn)(aCertCmpFnArg, pipCert, cert) < 0) {
     1:           break;
     1:         }
     1:       }
  6598:       if (wantThisCert) {
  6598:         nsCertTreeDispInfo *certdi = new nsCertTreeDispInfo;
119832:         if (!certdi)
119832:           return NS_ERROR_OUT_OF_MEMORY;
119832: 
  6598:         certdi->mAddonInfo = certai;
  6598:         certai->mUsageCount++;
  6598:         certdi->mTypeOfEntry = nsCertTreeDispInfo::direct_db;
 14555:         // not necessary: certdi->mAsciiHost.Clear(); certdi->mPort = -1;
  6598:         certdi->mOverrideBits = nsCertOverride::ob_None;
 80486:         certdi->mIsTemporary = false;
  6598:         mDispInfo.InsertElementAt(InsertPosition, certdi);
     1:         ++count;
  6598:         ++InsertPosition;
     1:       }
 77089:       if (addOverrides) {
  6598:         nsCertAndArrayAndPositionAndCounterAndTracker cap;
  6598:         cap.certai = certai;
  6598:         cap.array = &mDispInfo;
  6598:         cap.position = InsertPosition;
  6598:         cap.counter = 0;
  6598:         cap.tracker = &allHostPortOverrideKeys;
  6598: 
 77089:         mOriginalOverrideService->
 77089:           EnumerateCertOverrides(pipCert, MatchingCertOverridesCallback, &cap);
  6598:         count += cap.counter;
     1:       }
     1:     }
     1:   }
     1: 
  6598:   if (aWantedType == nsIX509Cert::SERVER_CERT) {
  6598:     nsArrayAndPositionAndCounterAndTracker cap;
  6598:     cap.array = &mDispInfo;
  6598:     cap.position = 0;
  6598:     cap.counter = 0;
  6598:     cap.tracker = &allHostPortOverrideKeys;
 77089:     mOriginalOverrideService->
106838:       EnumerateCertOverrides(nullptr, AddRemaningHostPortOverridesCallback, &cap);
  6598:   }
  6598: 
  6598:   return NS_OK;
  6598: }
  6598: 
  6598: nsresult 
108991: nsCertTree::GetCertsByType(uint32_t           aType,
     1:                            nsCertCompareFunc  aCertCmpFn,
  6598:                            void              *aCertCmpFnArg)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
119832:   CERTCertList *certList = NULL;
     1:   nsCOMPtr<nsIInterfaceRequestor> cxt = new PipUIContext();
     1:   certList = PK11_ListCerts(PK11CertListUnique, cxt);
  6598:   nsresult rv = GetCertsByTypeFromCertList(certList, aType, aCertCmpFn, aCertCmpFnArg);
     1:   if (certList)
     1:     CERT_DestroyCertList(certList);
     1:   return rv;
     1: }
     1: 
  6598: nsresult 
     1: nsCertTree::GetCertsByTypeFromCache(nsINSSCertCache   *aCache,
108991:                                     uint32_t           aType,
     1:                                     nsCertCompareFunc  aCertCmpFn,
  6598:                                     void              *aCertCmpFnArg)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aCache);
  3233:   CERTCertList *certList = reinterpret_cast<CERTCertList*>(aCache->GetCachedCerts());
     1:   if (!certList)
     1:     return NS_ERROR_FAILURE;
  6598:   return GetCertsByTypeFromCertList(certList, aType, aCertCmpFn, aCertCmpFnArg);
     1: }
     1: 
     1: // LoadCerts
     1: //
     1: // Load all of the certificates in the DB for this type.  Sort them
     1: // by token, organization, then common name.
     1: NS_IMETHODIMP 
108991: nsCertTree::LoadCertsFromCache(nsINSSCertCache *aCache, uint32_t aType)
     1: {
     1:   if (mTreeArray) {
     1:     FreeCertArray();
     1:     delete [] mTreeArray;
106838:     mTreeArray = nullptr;
     1:     mNumRows = 0;
     1:   }
     1:   nsresult rv = InitCompareHash();
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   rv = GetCertsByTypeFromCache(aCache, aType, 
  6598:                                GetCompareFuncFromCertType(aType), &mCompareCache);
     1:   if (NS_FAILED(rv)) return rv;
     1:   return UpdateUIContents();
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsCertTree::LoadCerts(uint32_t aType)
     1: {
     1:   if (mTreeArray) {
     1:     FreeCertArray();
     1:     delete [] mTreeArray;
106838:     mTreeArray = nullptr;
     1:     mNumRows = 0;
     1:   }
     1:   nsresult rv = InitCompareHash();
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   rv = GetCertsByType(aType, 
  6598:                       GetCompareFuncFromCertType(aType), &mCompareCache);
     1:   if (NS_FAILED(rv)) return rv;
     1:   return UpdateUIContents();
     1: }
     1: 
     1: nsresult
     1: nsCertTree::UpdateUIContents()
     1: {
108991:   uint32_t count = mDispInfo.Length();
     1:   mNumOrgs = CountOrganizations();
     1:   mTreeArray = new treeArrayEl[mNumOrgs];
119832:   if (!mTreeArray)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   mCellText = do_CreateInstance(NS_ARRAY_CONTRACTID);
     1: 
  6598: if (count) {
108991:   uint32_t j = 0;
106838:   nsCOMPtr<nsIX509Cert> orgCert = nullptr;
 95541:   nsCertAddonInfo *addonInfo = mDispInfo.ElementAt(j)->mAddonInfo;
 95541:   if (addonInfo) {
 95541:     orgCert = addonInfo->mCert;
  6598:   }
108991:   for (int32_t i=0; i<mNumOrgs; i++) {
     1:     nsString &orgNameRef = mTreeArray[i].orgName;
  6598:     if (!orgCert) {
  6598:       mNSSComponent->GetPIPNSSBundleString("CertOrgUnknown", orgNameRef);
  6598:     }
  6598:     else {
     1:       orgCert->GetIssuerOrganization(orgNameRef);
     1:       if (orgNameRef.IsEmpty())
     1:         orgCert->GetCommonName(orgNameRef);
  6598:     }
 80486:     mTreeArray[i].open = true;
     1:     mTreeArray[i].certIndex = j;
     1:     mTreeArray[i].numChildren = 1;
     1:     if (++j >= count) break;
106838:     nsCOMPtr<nsIX509Cert> nextCert = nullptr;
119832:     nsCertAddonInfo *addonInfo = mDispInfo.SafeElementAt(j, NULL)->mAddonInfo;
 95541:     if (addonInfo) {
 95541:       nextCert = addonInfo->mCert;
  6598:     }
     1:     while (0 == CmpBy(&mCompareCache, orgCert, nextCert, sort_IssuerOrg, sort_None, sort_None)) {
     1:       mTreeArray[i].numChildren++;
     1:       if (++j >= count) break;
106838:       nextCert = nullptr;
119832:       addonInfo = mDispInfo.SafeElementAt(j, NULL)->mAddonInfo;
 95541:       if (addonInfo) {
 95541:         nextCert = addonInfo->mCert;
  6598:       }
     1:     }
     1:     orgCert = nextCert;
     1:   }
  6598: }
     1:   if (mTree) {
     1:     mTree->BeginUpdateBatch();
     1:     mTree->RowCountChanged(0, -mNumRows);
     1:   }
     1:   mNumRows = count + mNumOrgs;
     1:   if (mTree)
     1:     mTree->EndUpdateBatch();
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
108991: nsCertTree::DeleteEntryObject(uint32_t index)
     1: {
 43686:   if (!mTreeArray) {
  6598:     return NS_ERROR_FAILURE;
  6598:   }
  6598: 
  6598:   nsCOMPtr<nsIX509CertDB> certdb = 
  6598:     do_GetService("@mozilla.org/security/x509certdb;1");
  6598:   if (!certdb) {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   int i;
108991:   uint32_t idx = 0, cIndex = 0, nc;
     1:   // Loop over the threads
     1:   for (i=0; i<mNumOrgs; i++) {
     1:     if (index == idx)
     1:       return NS_OK; // index is for thread
     1:     idx++; // get past the thread
     1:     nc = (mTreeArray[i].open) ? mTreeArray[i].numChildren : 0;
     1:     if (index < idx + nc) { // cert is within range of this thread
108991:       int32_t certIndex = cIndex + index - idx;
  6598: 
 95541:       bool canRemoveEntry = false;
119832:       nsRefPtr<nsCertTreeDispInfo> certdi = mDispInfo.SafeElementAt(certIndex, NULL);
 95541:       
 95541:       // We will remove the element from the visual tree.
 95541:       // Only if we have a certdi, then we can check for additional actions.
106838:       nsCOMPtr<nsIX509Cert> cert = nullptr;
 95541:       if (certdi) {
  6598:         if (certdi->mAddonInfo) {
  6598:           cert = certdi->mAddonInfo->mCert;
  6598:         }
106838:         nsCertAddonInfo *addonInfo = certdi->mAddonInfo ? certdi->mAddonInfo : nullptr;
  6598:         if (certdi->mTypeOfEntry == nsCertTreeDispInfo::host_port_override) {
 14555:           mOverrideService->ClearValidityOverride(certdi->mAsciiHost, certdi->mPort);
 95541:           if (addonInfo) {
 95541:             addonInfo->mUsageCount--;
 95541:             if (addonInfo->mUsageCount == 0) {
  6598:               // The certificate stored in the database is no longer
  6598:               // referenced by any other object displayed.
  6598:               // That means we no longer need to keep it around
  6598:               // and really can remove it.
 80486:               canRemoveEntry = true;
  6598:             }
  6598:           } 
  6598:         }
  6598:         else {
 95541:           if (addonInfo && addonInfo->mUsageCount > 1) {
  6598:             // user is trying to delete a perm trusted cert,
  6598:             // although there are still overrides stored,
  6598:             // so, we keep the cert, but remove the trust
  6598: 
106838:             CERTCertificate *nsscert = nullptr;
  6598:             CERTCertificateCleaner nsscertCleaner(nsscert);
  6598: 
  6598:             nsCOMPtr<nsIX509Cert2> cert2 = do_QueryInterface(cert);
  6598:             if (cert2) {
  6598:               nsscert = cert2->GetCert();
  6598:             }
  6598: 
  6598:             if (nsscert) {
  6598:               CERTCertTrust trust;
  6598:               memset((void*)&trust, 0, sizeof(trust));
  6598:             
  6598:               SECStatus srv = CERT_DecodeTrustString(&trust, ""); // no override 
  6598:               if (srv == SECSuccess) {
  6598:                 CERT_ChangeCertTrust(CERT_GetDefaultCertDB(), nsscert, &trust);
  6598:               }
  6598:             }
  6598:           }
  6598:           else {
 80486:             canRemoveEntry = true;
  6598:           }
  6598:         }
 95541:       }
  6598: 
  6598:       mDispInfo.RemoveElementAt(certIndex);
  6598: 
  6598:       if (canRemoveEntry) {
  6598:         RemoveCacheEntry(cert);
  6598:         certdb->DeleteCertificate(cert);
  6598:       }
  6598: 
     1:       delete [] mTreeArray;
106838:       mTreeArray = nullptr;
     1:       return UpdateUIContents();
     1:     }
     1:     if (mTreeArray[i].open)
     1:       idx += mTreeArray[i].numChildren;
     1:     cIndex += mTreeArray[i].numChildren;
     1:     if (idx > index)
     1:       break;
     1:   }
     1:   return NS_ERROR_FAILURE;
     1: }
     1: 
     1: //////////////////////////////////////////////////////////////////////////////
     1: //
     1: //  Begin nsITreeView methods
     1: //
     1: /////////////////////////////////////////////////////////////////////////////
     1: 
     1: /* nsIX509Cert getCert(in unsigned long index); */
     1: NS_IMETHODIMP
108991: nsCertTree::GetCert(uint32_t aIndex, nsIX509Cert **_cert)
     1: {
     1:   NS_ENSURE_ARG(_cert);
  7052:   *_cert = GetCertAtIndex(aIndex).get();
  6598:   return NS_OK;
  6598: }
  6598: 
  6598: NS_IMETHODIMP
108991: nsCertTree::GetTreeItem(uint32_t aIndex, nsICertTreeItem **_treeitem)
  6598: {
  6598:   NS_ENSURE_ARG(_treeitem);
  6598: 
119832:   nsRefPtr<nsCertTreeDispInfo> certdi = 
119832:     GetDispInfoAtIndex(aIndex);
  6598:   if (!certdi)
  6598:     return NS_ERROR_FAILURE;
  6598: 
  6598:   *_treeitem = certdi;
  6598:   NS_IF_ADDREF(*_treeitem);
  6598:   return NS_OK;
  6598: }
  6598: 
  6598: NS_IMETHODIMP
108991: nsCertTree::IsHostPortOverride(uint32_t aIndex, bool *_retval)
  6598: {
  6598:   NS_ENSURE_ARG(_retval);
  6598: 
119832:   nsRefPtr<nsCertTreeDispInfo> certdi = 
119832:     GetDispInfoAtIndex(aIndex);
  6598:   if (!certdi)
  6598:     return NS_ERROR_FAILURE;
  6598: 
  6598:   *_retval = (certdi->mTypeOfEntry == nsCertTreeDispInfo::host_port_override);
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute long rowCount; */
     1: NS_IMETHODIMP 
108991: nsCertTree::GetRowCount(int32_t *aRowCount)
     1: {
     1:   if (!mTreeArray)
     1:     return NS_ERROR_NOT_INITIALIZED;
108991:   uint32_t count = 0;
108991:   for (int32_t i=0; i<mNumOrgs; i++) {
     1:     if (mTreeArray[i].open) {
     1:       count += mTreeArray[i].numChildren;
     1:     }
     1:     count++;
     1:   }
     1:   *aRowCount = count;
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute nsITreeSelection selection; */
     1: NS_IMETHODIMP 
     1: nsCertTree::GetSelection(nsITreeSelection * *aSelection)
     1: {
     1:   *aSelection = mSelection;
     1:   NS_IF_ADDREF(*aSelection);
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP 
     1: nsCertTree::SetSelection(nsITreeSelection * aSelection)
     1: {
     1:   mSelection = aSelection;
     1:   return NS_OK;
     1: }
     1: 
     1: /* void getRowProperties (in long index, in nsISupportsArray properties); */
     1: NS_IMETHODIMP 
108991: nsCertTree::GetRowProperties(int32_t index, nsISupportsArray *properties)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /* void getCellProperties (in long row, in nsITreeColumn col, 
     1:  *                         in nsISupportsArray properties); 
     1:  */
     1: NS_IMETHODIMP 
108991: nsCertTree::GetCellProperties(int32_t row, nsITreeColumn* col, 
     1:                               nsISupportsArray* properties)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /* void getColumnProperties (in nsITreeColumn col, 
     1:  *                           in nsISupportsArray properties); 
     1:  */
     1: NS_IMETHODIMP 
     1: nsCertTree::GetColumnProperties(nsITreeColumn* col, 
     1:                                 nsISupportsArray* properties)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /* boolean isContainer (in long index); */
     1: NS_IMETHODIMP 
108991: nsCertTree::IsContainer(int32_t index, bool *_retval)
     1: {
     1:   if (!mTreeArray)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1:   treeArrayEl *el = GetThreadDescAtIndex(index);
     1:   if (el) {
 80486:     *_retval = true;
     1:   } else {
 80486:     *_retval = false;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* boolean isContainerOpen (in long index); */
     1: NS_IMETHODIMP 
108991: nsCertTree::IsContainerOpen(int32_t index, bool *_retval)
     1: {
     1:   if (!mTreeArray)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1:   treeArrayEl *el = GetThreadDescAtIndex(index);
     1:   if (el && el->open) {
 80486:     *_retval = true;
     1:   } else {
 80486:     *_retval = false;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* boolean isContainerEmpty (in long index); */
     1: NS_IMETHODIMP 
108991: nsCertTree::IsContainerEmpty(int32_t index, bool *_retval)
     1: {
     1:   *_retval = !mTreeArray;
     1:   return NS_OK;
     1: }
     1: 
     1: /* boolean isSeparator (in long index); */
     1: NS_IMETHODIMP 
108991: nsCertTree::IsSeparator(int32_t index, bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: /* long getParentIndex (in long rowIndex); */
     1: NS_IMETHODIMP 
108991: nsCertTree::GetParentIndex(int32_t rowIndex, int32_t *_retval)
     1: {
     1:   if (!mTreeArray)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1:   int i, idx = 0;
     1:   for (i = 0; i < mNumOrgs && idx < rowIndex; i++, idx++) {
     1:     if (mTreeArray[i].open) {
     1:       if (rowIndex <= idx + mTreeArray[i].numChildren) {
     1:         *_retval = idx;
     1:         return NS_OK;
     1:       }
     1:       idx += mTreeArray[i].numChildren;
     1:     }
     1:   }
     1:   *_retval = -1;
     1:   return NS_OK;
     1: }
     1: 
     1: /* boolean hasNextSibling (in long rowIndex, in long afterIndex); */
     1: NS_IMETHODIMP 
108991: nsCertTree::HasNextSibling(int32_t rowIndex, int32_t afterIndex, 
 79445:                                bool *_retval)
     1: {
     1:   if (!mTreeArray)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   int i, idx = 0;
     1:   for (i = 0; i < mNumOrgs && idx <= rowIndex; i++, idx++) {
     1:     if (mTreeArray[i].open) {
     1:       idx += mTreeArray[i].numChildren;
     1:       if (afterIndex <= idx) {
     1:         *_retval = afterIndex < idx;
     1:         return NS_OK;
     1:       }
     1:     }
     1:   }
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: /* long getLevel (in long index); */
     1: NS_IMETHODIMP 
108991: nsCertTree::GetLevel(int32_t index, int32_t *_retval)
     1: {
     1:   if (!mTreeArray)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1:   treeArrayEl *el = GetThreadDescAtIndex(index);
     1:   if (el) {
     1:     *_retval = 0;
     1:   } else {
     1:     *_retval = 1;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* Astring getImageSrc (in long row, in nsITreeColumn col); */
     1: NS_IMETHODIMP 
108991: nsCertTree::GetImageSrc(int32_t row, nsITreeColumn* col, 
     1:                         nsAString& _retval)
     1: {
     1:   _retval.Truncate();
     1:   return NS_OK;
     1: }
     1: 
     1: /* long getProgressMode (in long row, in nsITreeColumn col); */
     1: NS_IMETHODIMP
108991: nsCertTree::GetProgressMode(int32_t row, nsITreeColumn* col, int32_t* _retval)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /* Astring getCellValue (in long row, in nsITreeColumn col); */
     1: NS_IMETHODIMP 
108991: nsCertTree::GetCellValue(int32_t row, nsITreeColumn* col, 
     1:                          nsAString& _retval)
     1: {
     1:   _retval.Truncate();
     1:   return NS_OK;
     1: }
     1: 
     1: /* Astring getCellText (in long row, in nsITreeColumn col); */
     1: NS_IMETHODIMP 
108991: nsCertTree::GetCellText(int32_t row, nsITreeColumn* col, 
     1:                         nsAString& _retval)
     1: {
     1:   if (!mTreeArray)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1: 
     1:   nsresult rv;
     1:   _retval.Truncate();
     1: 
     1:   const PRUnichar* colID;
     1:   col->GetIdConst(&colID);
     1: 
     1:   treeArrayEl *el = GetThreadDescAtIndex(row);
119832:   if (el != nullptr) {
     1:     if (NS_LITERAL_STRING("certcol").Equals(colID))
     1:       _retval.Assign(el->orgName);
     1:     else
     1:       _retval.Truncate();
     1:     return NS_OK;
     1:   }
     1: 
108991:   int32_t absoluteCertOffset;
119832:   nsRefPtr<nsCertTreeDispInfo> certdi = 
119832:     GetDispInfoAtIndex(row, &absoluteCertOffset);
  6598:   if (!certdi)
  6598:     return NS_ERROR_FAILURE;
  6598: 
 20772:   nsCOMPtr<nsIX509Cert> cert = certdi->mCert;
 20772:   if (!cert && certdi->mAddonInfo) {
  6598:     cert = certdi->mAddonInfo->mCert;
  6598:   }
     1: 
108991:   int32_t colIndex;
     1:   col->GetIndex(&colIndex);
108991:   uint32_t arrayIndex=absoluteCertOffset+colIndex*(mNumRows-mNumOrgs);
108991:   uint32_t arrayLength=0;
     1:   if (mCellText) {
     1:     mCellText->GetLength(&arrayLength);
     1:   }
     1:   if (arrayIndex < arrayLength) {
     1:     nsCOMPtr<nsISupportsString> myString(do_QueryElementAt(mCellText, arrayIndex));
     1:     if (myString) {
     1:       myString->GetData(_retval);
     1:       return NS_OK;
     1:     }
     1:   }
     1: 
     1:   if (NS_LITERAL_STRING("certcol").Equals(colID)) {
  6598:     if (!cert) {
  6598:       mNSSComponent->GetPIPNSSBundleString("CertNotStored", _retval);
  6598:     }
  6598:     else {
     1:       rv = cert->GetCommonName(_retval);
     1:       if (NS_FAILED(rv) || _retval.IsEmpty()) {
     1:         // kaie: I didn't invent the idea to cut off anything before 
     1:         //       the first colon. :-)
     1:         nsAutoString nick;
     1:         rv = cert->GetNickname(nick);
     1:         
     1:         nsAString::const_iterator start, end, end2;
     1:         nick.BeginReading(start);
     1:         nick.EndReading(end);
     1:         end2 = end;
     1:   
     1:         if (FindInReadable(NS_LITERAL_STRING(":"), start, end)) {
     1:           // found. end points to the first char after the colon,
     1:           // that's what we want.
     1:           _retval = Substring(end, end2);
     1:         }
     1:         else {
     1:           _retval = nick;
     1:         }
     1:       }
  6598:     }
  6598:   } else if (NS_LITERAL_STRING("tokencol").Equals(colID) && cert) {
     1:     rv = cert->GetTokenName(_retval);
  6598:   } else if (NS_LITERAL_STRING("emailcol").Equals(colID) && cert) {
     1:     rv = cert->GetEmailAddress(_retval);
  6598:   } else if (NS_LITERAL_STRING("purposecol").Equals(colID) && mNSSComponent && cert) {
108991:     uint32_t verified;
     1: 
     1:     nsAutoString theUsages;
 80486:     rv = cert->GetUsagesString(false, &verified, theUsages); // allow OCSP
     1:     if (NS_FAILED(rv)) {
     1:       verified = nsIX509Cert::NOT_VERIFIED_UNKNOWN;
     1:     }
     1: 
     1:     switch (verified) {
     1:       case nsIX509Cert::VERIFIED_OK:
     1:         _retval = theUsages;
     1:         break;
     1: 
     1:       case nsIX509Cert::CERT_REVOKED:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("VerifyRevoked", _retval);
     1:         break;
     1:       case nsIX509Cert::CERT_EXPIRED:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("VerifyExpired", _retval);
     1:         break;
     1:       case nsIX509Cert::CERT_NOT_TRUSTED:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("VerifyNotTrusted", _retval);
     1:         break;
     1:       case nsIX509Cert::ISSUER_NOT_TRUSTED:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("VerifyIssuerNotTrusted", _retval);
     1:         break;
     1:       case nsIX509Cert::ISSUER_UNKNOWN:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("VerifyIssuerUnknown", _retval);
     1:         break;
     1:       case nsIX509Cert::INVALID_CA:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("VerifyInvalidCA", _retval);
     1:         break;
104409:       case nsIX509Cert::SIGNATURE_ALGORITHM_DISABLED:
104409:         rv = mNSSComponent->GetPIPNSSBundleString("VerifyDisabledAlgorithm", _retval);
104409:         break;
     1:       case nsIX509Cert::NOT_VERIFIED_UNKNOWN:
     1:       case nsIX509Cert::USAGE_NOT_ALLOWED:
     1:       default:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("VerifyUnknown", _retval);
     1:         break;
     1:     }
  6598:   } else if (NS_LITERAL_STRING("issuedcol").Equals(colID) && cert) {
     1:     nsCOMPtr<nsIX509CertValidity> validity;
     1: 
     1:     rv = cert->GetValidity(getter_AddRefs(validity));
     1:     if (NS_SUCCEEDED(rv)) {
     1:       validity->GetNotBeforeLocalDay(_retval);
     1:     }
  6598:   } else if (NS_LITERAL_STRING("expiredcol").Equals(colID) && cert) {
     1:     nsCOMPtr<nsIX509CertValidity> validity;
     1: 
     1:     rv = cert->GetValidity(getter_AddRefs(validity));
     1:     if (NS_SUCCEEDED(rv)) {
     1:       validity->GetNotAfterLocalDay(_retval);
     1:     }
  6598:   } else if (NS_LITERAL_STRING("serialnumcol").Equals(colID) && cert) {
     1:     rv = cert->GetSerialNumber(_retval);
  6598: 
  6598: 
  6598:   } else if (NS_LITERAL_STRING("overridetypecol").Equals(colID)) {
  6598:     // default to classic permanent-trust
  6598:     nsCertOverride::OverrideBits ob = nsCertOverride::ob_Untrusted;
  6598:     if (certdi->mTypeOfEntry == nsCertTreeDispInfo::host_port_override) {
  6598:       ob = certdi->mOverrideBits;
  6598:     }
110974:     nsAutoCString temp;
  6598:     nsCertOverride::convertBitsToString(ob, temp);
  6598:     _retval = NS_ConvertUTF8toUTF16(temp);
  6598:   } else if (NS_LITERAL_STRING("sitecol").Equals(colID)) {
  6598:     if (certdi->mTypeOfEntry == nsCertTreeDispInfo::host_port_override) {
110974:       nsAutoCString hostPort;
 14555:       nsCertOverrideService::GetHostWithPort(certdi->mAsciiHost, certdi->mPort, hostPort);
 14555:       _retval = NS_ConvertUTF8toUTF16(hostPort);
  6598:     }
  6598:     else {
  6598:       _retval = NS_LITERAL_STRING("*");
  6598:     }
  8176:   } else if (NS_LITERAL_STRING("lifetimecol").Equals(colID)) {
  8176:     const char *stringID = 
  8176:       (certdi->mIsTemporary) ? "CertExceptionTemporary" : "CertExceptionPermanent";
  8176:     rv = mNSSComponent->GetPIPNSSBundleString(stringID, _retval);
  6598:   } else if (NS_LITERAL_STRING("typecol").Equals(colID) && cert) {
     1:     nsCOMPtr<nsIX509Cert2> pipCert = do_QueryInterface(cert);
108991:     uint32_t type = nsIX509Cert::UNKNOWN_CERT;
     1: 
     1:     if (pipCert) {
     1: 	rv = pipCert->GetCertType(&type);
     1:     }
     1: 
     1:     switch (type) {
     1:     case nsIX509Cert::USER_CERT:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("CertUser", _retval);
     1: 	break;
     1:     case nsIX509Cert::CA_CERT:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("CertCA", _retval);
     1: 	break;
     1:     case nsIX509Cert::SERVER_CERT:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("CertSSL", _retval);
     1: 	break;
     1:     case nsIX509Cert::EMAIL_CERT:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("CertEmail", _retval);
     1: 	break;
     1:     default:
     1:         rv = mNSSComponent->GetPIPNSSBundleString("CertUnknown", _retval);
     1: 	break;
     1:     }
     1: 
     1:   } else {
     1:     return NS_ERROR_FAILURE;
     1:   }
     1:   if (mCellText) {
     1:     nsCOMPtr<nsISupportsString> text(do_CreateInstance(NS_SUPPORTS_STRING_CONTRACTID, &rv));
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:     text->SetData(_retval);
 80486:     mCellText->ReplaceElementAt(text, arrayIndex, false);
     1:   }
     1:   return rv;
     1: }
     1: 
     1: /* void setTree (in nsITreeBoxObject tree); */
     1: NS_IMETHODIMP 
     1: nsCertTree::SetTree(nsITreeBoxObject *tree)
     1: {
     1:   mTree = tree;
     1:   return NS_OK;
     1: }
     1: 
     1: /* void toggleOpenState (in long index); */
     1: NS_IMETHODIMP 
108991: nsCertTree::ToggleOpenState(int32_t index)
     1: {
     1:   if (!mTreeArray)
     1:     return NS_ERROR_NOT_INITIALIZED;
     1:   treeArrayEl *el = GetThreadDescAtIndex(index);
     1:   if (el) {
     1:     el->open = !el->open;
108991:     int32_t newChildren = (el->open) ? el->numChildren : -el->numChildren;
     1:     if (mTree) mTree->RowCountChanged(index + 1, newChildren);
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /* void cycleHeader (in nsITreeColumn); */
     1: NS_IMETHODIMP 
     1: nsCertTree::CycleHeader(nsITreeColumn* col)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /* void selectionChanged (); */
     1: NS_IMETHODIMP 
     1: nsCertTree::SelectionChanged()
     1: {
     1:   return NS_ERROR_NOT_IMPLEMENTED;
     1: }
     1: 
     1: /* void cycleCell (in long row, in nsITreeColumn col); */
     1: NS_IMETHODIMP 
108991: nsCertTree::CycleCell(int32_t row, nsITreeColumn* col)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /* boolean isEditable (in long row, in nsITreeColumn col); */
     1: NS_IMETHODIMP 
108991: nsCertTree::IsEditable(int32_t row, nsITreeColumn* col, bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: /* boolean isSelectable (in long row, in nsITreeColumn col); */
     1: NS_IMETHODIMP 
108991: nsCertTree::IsSelectable(int32_t row, nsITreeColumn* col, bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: /* void setCellValue (in long row, in nsITreeColumn col, in AString value); */
     1: NS_IMETHODIMP 
108991: nsCertTree::SetCellValue(int32_t row, nsITreeColumn* col, 
     1:                          const nsAString& value)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /* void setCellText (in long row, in nsITreeColumn col, in AString value); */
     1: NS_IMETHODIMP 
108991: nsCertTree::SetCellText(int32_t row, nsITreeColumn* col, 
     1:                         const nsAString& value)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /* void performAction (in wstring action); */
     1: NS_IMETHODIMP 
     1: nsCertTree::PerformAction(const PRUnichar *action)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /* void performActionOnRow (in wstring action, in long row); */
     1: NS_IMETHODIMP 
108991: nsCertTree::PerformActionOnRow(const PRUnichar *action, int32_t row)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: /* void performActionOnCell (in wstring action, in long row, 
     1:  *                           in wstring colID); 
     1:  */
     1: NS_IMETHODIMP 
108991: nsCertTree::PerformActionOnCell(const PRUnichar *action, int32_t row, 
     1:                                 nsITreeColumn* col)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: #ifdef DEBUG_CERT_TREE
     1: void
     1: nsCertTree::dumpMap()
     1: {
     1:   for (int i=0; i<mNumOrgs; i++) {
     1:     nsAutoString org(mTreeArray[i].orgName);
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("ORG[%s]", NS_LossyConvertUTF16toASCII(org).get()));
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("OPEN[%d]", mTreeArray[i].open));
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("INDEX[%d]", mTreeArray[i].certIndex));
     1:     PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("NCHILD[%d]", mTreeArray[i].numChildren));
     1:   }
     1:   for (int i=0; i<mNumRows; i++) {
     1:     treeArrayEl *el = GetThreadDescAtIndex(i);
119832:     if (el != nullptr) {
     1:       nsAutoString td(el->orgName);
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("thread desc[%d]: %s", i, NS_LossyConvertUTF16toASCII(td).get()));
     1:     }
  7052:     nsCOMPtr<nsIX509Cert> ct = GetCertAtIndex(i);
119832:     if (ct != nullptr) {
     1:       PRUnichar *goo;
     1:       ct->GetCommonName(&goo);
     1:       nsAutoString doo(goo);
     1:       PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("cert [%d]: %s", i, NS_LossyConvertUTF16toASCII(doo).get()));
     1:     }
     1:   }
     1: }
     1: #endif
     1: 
     1: //
     1: // CanDrop
     1: //
108991: NS_IMETHODIMP nsCertTree::CanDrop(int32_t index, int32_t orientation,
 79445:                                   nsIDOMDataTransfer* aDataTransfer, bool *_retval)
     1: {
     1:   NS_ENSURE_ARG_POINTER(_retval);
 80486:   *_retval = false;
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: //
     1: // Drop
     1: //
108991: NS_IMETHODIMP nsCertTree::Drop(int32_t row, int32_t orient, nsIDOMDataTransfer* aDataTransfer)
     1: {
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: //
     1: // IsSorted
     1: //
     1: // ...
     1: //
 79445: NS_IMETHODIMP nsCertTree::IsSorted(bool *_retval)
     1: {
 80486:   *_retval = false;
     1:   return NS_OK;
     1: }
     1: 
     1: #define RETURN_NOTHING
     1: 
     1: void 
     1: nsCertTree::CmpInitCriterion(nsIX509Cert *cert, CompareCacheHashEntry *entry,
108991:                              sortCriterion crit, int32_t level)
     1: {
119832:   NS_ENSURE_TRUE( (cert!=0 && entry!=0), RETURN_NOTHING );
     1: 
 80486:   entry->mCritInit[level] = true;
     1:   nsXPIDLString &str = entry->mCrit[level];
     1:   
     1:   switch (crit) {
     1:     case sort_IssuerOrg:
     1:       cert->GetIssuerOrganization(str);
     1:       if (str.IsEmpty())
     1:         cert->GetCommonName(str);
     1:       break;
     1:     case sort_Org:
     1:       cert->GetOrganization(str);
     1:       break;
     1:     case sort_Token:
     1:       cert->GetTokenName(str);
     1:       break;
     1:     case sort_CommonName:
     1:       cert->GetCommonName(str);
     1:       break;
     1:     case sort_IssuedDateDescending:
     1:       {
     1:         nsresult rv;
     1:         nsCOMPtr<nsIX509CertValidity> validity;
     1:         PRTime notBefore;
     1: 
     1:         rv = cert->GetValidity(getter_AddRefs(validity));
     1:         if (NS_SUCCEEDED(rv)) {
     1:           rv = validity->GetNotBefore(&notBefore);
     1:         }
     1: 
     1:         if (NS_SUCCEEDED(rv)) {
     1:           PRExplodedTime explodedTime;
     1:           PR_ExplodeTime(notBefore, PR_GMTParameters, &explodedTime);
     1:           char datebuf[20]; // 4 + 2 + 2 + 2 + 2 + 2 + 1 = 15
     1:           if (0 != PR_FormatTime(datebuf, sizeof(datebuf), "%Y%m%d%H%M%S", &explodedTime)) {
     1:             str = NS_ConvertASCIItoUTF16(nsDependentCString(datebuf));
     1:           }
     1:         }
     1:       }
     1:       break;
     1:     case sort_Email:
     1:       cert->GetEmailAddress(str);
     1:       break;
     1:     case sort_None:
     1:     default:
     1:       break;
     1:   }
     1: }
     1: 
108991: int32_t
     1: nsCertTree::CmpByCrit(nsIX509Cert *a, CompareCacheHashEntry *ace, 
     1:                       nsIX509Cert *b, CompareCacheHashEntry *bce, 
108991:                       sortCriterion crit, int32_t level)
     1: {
119832:   NS_ENSURE_TRUE( (a!=0 && ace!=0 && b!=0 && bce!=0), 0 );
     1: 
     1:   if (!ace->mCritInit[level]) {
     1:     CmpInitCriterion(a, ace, crit, level);
     1:   }
     1: 
     1:   if (!bce->mCritInit[level]) {
     1:     CmpInitCriterion(b, bce, crit, level);
     1:   }
     1: 
     1:   nsXPIDLString &str_a = ace->mCrit[level];
     1:   nsXPIDLString &str_b = bce->mCrit[level];
     1: 
108991:   int32_t result;
     1:   if (str_a && str_b)
     1:     result = Compare(str_a, str_b, nsCaseInsensitiveStringComparator());
     1:   else
     1:     result = !str_a ? (!str_b ? 0 : -1) : 1;
     1: 
     1:   if (sort_IssuedDateDescending == crit)
     1:     result *= -1; // reverse compare order
     1: 
     1:   return result;
     1: }
     1: 
108991: int32_t
     1: nsCertTree::CmpBy(void *cache, nsIX509Cert *a, nsIX509Cert *b, 
     1:                   sortCriterion c0, sortCriterion c1, sortCriterion c2)
     1: {
  6598:   // This will be called when comparing items for display sorting.
  6598:   // Some items might have no cert associated, so either a or b is null.
  6598:   // We want all those orphans show at the top of the list,
  6598:   // so we treat a null cert as "smaller" by returning -1.
  6598:   // We don't try to sort within the group of no-cert entries,
  6598:   // so we treat them as equal wrt sort order.
  6598: 
  6598:   if (!a && !b)
  6598:     return 0;
  6598: 
  6598:   if (!a)
  6598:     return -1;
  6598: 
  6598:   if (!b)
  6598:     return 1;
  6598: 
119832:   NS_ENSURE_TRUE( (cache!=0 && a!=0 && b!=0), 0 );
     1: 
     1:   CompareCacheHashEntry *ace = getCacheEntry(cache, a);
     1:   CompareCacheHashEntry *bce = getCacheEntry(cache, b);
     1: 
108991:   int32_t cmp;
     1:   cmp = CmpByCrit(a, ace, b, bce, c0, 0);
     1:   if (cmp != 0)
     1:     return cmp;
     1: 
     1:   if (c1 != sort_None) {
     1:     cmp = CmpByCrit(a, ace, b, bce, c1, 1);
     1:     if (cmp != 0)
     1:       return cmp;
     1:     
     1:     if (c2 != sort_None) {
     1:       return CmpByCrit(a, ace, b, bce, c2, 2);
     1:     }
     1:   }
     1: 
     1:   return cmp;
     1: }
     1: 
108991: int32_t
     1: nsCertTree::CmpCACert(void *cache, nsIX509Cert *a, nsIX509Cert *b)
     1: {
     1:   // XXX we assume issuer org is always criterion 1
     1:   return CmpBy(cache, a, b, sort_IssuerOrg, sort_Org, sort_Token);
     1: }
     1: 
108991: int32_t
     1: nsCertTree::CmpWebSiteCert(void *cache, nsIX509Cert *a, nsIX509Cert *b)
     1: {
     1:   // XXX we assume issuer org is always criterion 1
     1:   return CmpBy(cache, a, b, sort_IssuerOrg, sort_CommonName, sort_None);
     1: }
     1: 
108991: int32_t
     1: nsCertTree::CmpUserCert(void *cache, nsIX509Cert *a, nsIX509Cert *b)
     1: {
     1:   // XXX we assume issuer org is always criterion 1
     1:   return CmpBy(cache, a, b, sort_IssuerOrg, sort_Token, sort_IssuedDateDescending);
     1: }
     1: 
108991: int32_t
     1: nsCertTree::CmpEmailCert(void *cache, nsIX509Cert *a, nsIX509Cert *b)
     1: {
     1:   // XXX we assume issuer org is always criterion 1
     1:   return CmpBy(cache, a, b, sort_IssuerOrg, sort_Email, sort_CommonName);
     1: }
     1: 
