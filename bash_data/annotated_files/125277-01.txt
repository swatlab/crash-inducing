 91659: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 91659: /* This Source Code Form is subject to the terms of the Mozilla Public
 91659:  * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 91659:  * You can obtain one at http://mozilla.org/MPL/2.0/. */
 91659: 
 91659: #include "jsapi.h"
 91659: #include "jsbool.h"
 91659: #include "jscntxt.h"
 91659: #include "jscompartment.h"
 91659: #include "jsfriendapi.h"
 91660: #include "jsgc.h"
 91659: #include "jsobj.h"
 98670: #include "jsobjinlines.h"
 91659: #include "jsprf.h"
 91659: #include "jswrapper.h"
 91659: 
123695: #include "builtin/TestingFunctions.h"
 91659: #include "methodjit/MethodJIT.h"
 91659: 
 98272: #include "vm/Stack-inl.h"
 98272: 
 91659: using namespace js;
 91659: using namespace JS;
 91659: 
121250: using mozilla::ArrayLength;
121250: 
 91659: static JSBool
106214: GetBuildConfiguration(JSContext *cx, unsigned argc, jsval *vp)
106214: {
106214:     RootedObject info(cx, JS_NewObject(cx, NULL, NULL, NULL));
106214:     if (!info)
106214:         return false;
106214:     Value value;
106214: 
106214: #ifdef JSGC_ROOT_ANALYSIS
106214:     value = BooleanValue(true);
106214: #else
106214:     value = BooleanValue(false);
106214: #endif
106214:     if (!JS_SetProperty(cx, info, "rooting-analysis", &value))
106214:         return false;
106214: 
106214: #ifdef JSGC_USE_EXACT_ROOTING
106214:     value = BooleanValue(true);
106214: #else
106214:     value = BooleanValue(false);
106214: #endif
106214:     if (!JS_SetProperty(cx, info, "exact-rooting", &value))
106214:         return false;
106214: 
106214: #ifdef DEBUG
106214:     value = BooleanValue(true);
106214: #else
106214:     value = BooleanValue(false);
106214: #endif
106214:     if (!JS_SetProperty(cx, info, "debug", &value))
106214:         return false;
106214: 
106214: #ifdef JS_HAS_CTYPES
106214:     value = BooleanValue(true);
106214: #else
106214:     value = BooleanValue(false);
106214: #endif
106214:     if (!JS_SetProperty(cx, info, "has-ctypes", &value))
106214:         return false;
106214: 
106214: #ifdef JS_GC_ZEAL
106214:     value = BooleanValue(true);
106214: #else
106214:     value = BooleanValue(false);
106214: #endif
106214:     if (!JS_SetProperty(cx, info, "has-gczeal", &value))
106214:         return false;
106214: 
106214: #ifdef JS_THREADSAFE
106214:     value = BooleanValue(true);
106214: #else
106214:     value = BooleanValue(false);
106214: #endif
113939:     if (!JS_SetProperty(cx, info, "threadsafe", &value))
106214:         return false;
106214: 
106284: #ifdef JS_MORE_DETERMINISTIC
106284:     value = BooleanValue(true);
106284: #else
106284:     value = BooleanValue(false);
106284: #endif
106284:     if (!JS_SetProperty(cx, info, "more-deterministic", &value))
106284:         return false;
106284: 
106284: #ifdef MOZ_PROFILING
106284:     value = BooleanValue(true);
106284: #else
106284:     value = BooleanValue(false);
106284: #endif
106284:     if (!JS_SetProperty(cx, info, "profiling", &value))
106284:         return false;
106284: 
106284: #ifdef INCLUDE_MOZILLA_DTRACE
106284:     value = BooleanValue(true);
106284: #else
106284:     value = BooleanValue(false);
106284: #endif
106284:     if (!JS_SetProperty(cx, info, "dtrace", &value))
106284:         return false;
106284: 
106284: #ifdef MOZ_TRACE_JSCALLS
106284:     value = BooleanValue(true);
106284: #else
106284:     value = BooleanValue(false);
106284: #endif
106284:     if (!JS_SetProperty(cx, info, "trace-jscalls-api", &value))
106284:         return false;
106284: 
106284: #ifdef JSGC_INCREMENTAL
106284:     value = BooleanValue(true);
106284: #else
106284:     value = BooleanValue(false);
106284: #endif
106284:     if (!JS_SetProperty(cx, info, "incremental-gc", &value))
106284:         return false;
106284: 
106284: #ifdef JSGC_GENERATIONAL
106284:     value = BooleanValue(true);
106284: #else
106284:     value = BooleanValue(false);
106284: #endif
106284:     if (!JS_SetProperty(cx, info, "generational-gc", &value))
106284:         return false;
106284: 
106284: #ifdef MOZ_VALGRIND
106284:     value = BooleanValue(true);
106284: #else
106284:     value = BooleanValue(false);
106284: #endif
106284:     if (!JS_SetProperty(cx, info, "valgrind", &value))
106284:         return false;
106284: 
106284: #ifdef JS_OOM_DO_BACKTRACES
106284:     value = BooleanValue(true);
106284: #else
106284:     value = BooleanValue(false);
106284: #endif
106284:     if (!JS_SetProperty(cx, info, "oom-backtraces", &value))
106284:         return false;
106284: 
106284: #ifdef JS_METHODJIT
106284:     value = BooleanValue(true);
106284: #else
106284:     value = BooleanValue(false);
106284: #endif
106284:     if (!JS_SetProperty(cx, info, "methodjit", &value))
106284:         return false;
106284: 
106284: #ifdef JS_HAS_XML_SUPPORT
106284:     value = BooleanValue(true);
106284: #else
106284:     value = BooleanValue(false);
106284: #endif
106284:     if (!JS_SetProperty(cx, info, "e4x", &value))
106284:         return false;
106284: 
106214:     *vp = ObjectValue(*info);
106214:     return true;
106214: }
106214: 
106214: static JSBool
 91659: GC(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
 94872:     /*
 94872:      * If the first argument is 'compartment', we collect any compartments
 94872:      * previously scheduled for GC via schedulegc. If the first argument is an
119270:      * object, we collect the object's compartment (and any other compartments
119270:      * scheduled for GC). Otherwise, we collect all compartments.
 94872:      */
 94872:     JSBool compartment = false;
 91659:     if (argc == 1) {
 91659:         Value arg = vp[2];
 94872:         if (arg.isString()) {
 94872:             if (!JS_StringEqualsAscii(cx, arg.toString(), "compartment", &compartment))
 94872:                 return false;
 94872:         } else if (arg.isObject()) {
 94872:             PrepareCompartmentForGC(UnwrapObject(&arg.toObject())->compartment());
 94872:             compartment = true;
 94872:         }
 91659:     }
 91659: 
 91659: #ifndef JS_MORE_DETERMINISTIC
 91659:     size_t preBytes = cx->runtime->gcBytes;
 91659: #endif
 91659: 
 94872:     if (compartment)
 94872:         PrepareForDebugGC(cx->runtime);
 94871:     else
 94871:         PrepareForFullGC(cx->runtime);
 94960:     GCForReason(cx->runtime, gcreason::API);
 91659: 
 91659:     char buf[256] = { '\0' };
 91659: #ifndef JS_MORE_DETERMINISTIC
 91659:     JS_snprintf(buf, sizeof(buf), "before %lu, after %lu\n",
 91659:                 (unsigned long)preBytes, (unsigned long)cx->runtime->gcBytes);
 91659: #endif
 91659:     JSString *str = JS_NewStringCopyZ(cx, buf);
 91659:     if (!str)
 91659:         return false;
 91659:     *vp = STRING_TO_JSVAL(str);
 91659:     return true;
 91659: }
 91659: 
 91659: static const struct ParamPair {
 91659:     const char      *name;
 91659:     JSGCParamKey    param;
 91659: } paramMap[] = {
 91659:     {"maxBytes",            JSGC_MAX_BYTES },
 91659:     {"maxMallocBytes",      JSGC_MAX_MALLOC_BYTES},
 91659:     {"gcBytes",             JSGC_BYTES},
 91659:     {"gcNumber",            JSGC_NUMBER},
 91659:     {"sliceTimeBudget",     JSGC_SLICE_TIME_BUDGET}
 91659: };
 91659: 
 91659: static JSBool
 91659: GCParameter(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
 91659:     JSString *str;
 91659:     if (argc == 0) {
 91659:         str = JS_ValueToString(cx, JSVAL_VOID);
 91659:         JS_ASSERT(str);
 91659:     } else {
 91659:         str = JS_ValueToString(cx, vp[2]);
 91659:         if (!str)
 91659:             return JS_FALSE;
 91659:         vp[2] = STRING_TO_JSVAL(str);
 91659:     }
 91659: 
 91659:     JSFlatString *flatStr = JS_FlattenString(cx, str);
 91659:     if (!flatStr)
 91659:         return false;
 91659: 
 91659:     size_t paramIndex = 0;
 91659:     for (;; paramIndex++) {
 91659:         if (paramIndex == ArrayLength(paramMap)) {
 91659:             JS_ReportError(cx,
 91659:                            "the first argument argument must be maxBytes, "
 91659:                            "maxMallocBytes, gcStackpoolLifespan, gcBytes or "
 91659:                            "gcNumber");
 91659:             return false;
 91659:         }
 91659:         if (JS_FlatStringEqualsAscii(flatStr, paramMap[paramIndex].name))
 91659:             break;
 91659:     }
 91659:     JSGCParamKey param = paramMap[paramIndex].param;
 91659: 
 91659:     if (argc == 1) {
 91659:         uint32_t value = JS_GetGCParameter(cx->runtime, param);
107180:         vp[0] = JS_NumberValue(value);
107180:         return true;
 91659:     }
 91659: 
 91659:     if (param == JSGC_NUMBER ||
 91659:         param == JSGC_BYTES) {
 91659:         JS_ReportError(cx, "Attempt to change read-only parameter %s",
 91659:                        paramMap[paramIndex].name);
 91659:         return false;
 91659:     }
 91659: 
 91659:     uint32_t value;
 91659:     if (!JS_ValueToECMAUint32(cx, vp[3], &value)) {
 91659:         JS_ReportError(cx,
 91659:                        "the second argument must be convertable to uint32_t "
 91659:                        "with non-zero value");
 91659:         return false;
 91659:     }
 91659: 
 91659:     if (param == JSGC_MAX_BYTES) {
 91659:         uint32_t gcBytes = JS_GetGCParameter(cx->runtime, JSGC_BYTES);
 91659:         if (value < gcBytes) {
 91659:             JS_ReportError(cx,
 91659:                            "attempt to set maxBytes to the value less than the current "
 91659:                            "gcBytes (%u)",
 91659:                            gcBytes);
 91659:             return false;
 91659:         }
 91659:     }
 91659: 
 91659:     JS_SetGCParameter(cx->runtime, param, value);
 91659:     *vp = JSVAL_VOID;
 91659:     return true;
 91659: }
 91659: 
 91659: static JSBool
 98670: IsProxy(JSContext *cx, unsigned argc, jsval *vp)
 98670: {
 98670:     CallArgs args = CallArgsFromVp(argc, vp);
 98670:     if (argc != 1) {
 98670:         JS_ReportError(cx, "the function takes exactly one argument");
 98670:         return false;
 98670:     }
 98670:     if (!args[0].isObject()) {
 98670:         args.rval().setBoolean(false);
 98670:         return true;
 98670:     }
 98670:     args.rval().setBoolean(args[0].toObject().isProxy());
 98670:     return true;
 98670: }
 98670: 
 98670: static JSBool
 91659: InternalConst(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
 91659:     if (argc != 1) {
 91659:         JS_ReportError(cx, "the function takes exactly one argument");
 91659:         return false;
 91659:     }
 91659: 
 91659:     JSString *str = JS_ValueToString(cx, vp[2]);
 91659:     if (!str)
 91659:         return false;
 91659:     JSFlatString *flat = JS_FlattenString(cx, str);
 91659:     if (!flat)
 91659:         return false;
 91659: 
 91659:     if (JS_FlatStringEqualsAscii(flat, "MARK_STACK_LENGTH")) {
 91659:         vp[0] = UINT_TO_JSVAL(js::MARK_STACK_LENGTH);
 91659:     } else {
 91659:         JS_ReportError(cx, "unknown const name");
 91659:         return false;
 91659:     }
 91659:     return true;
 91659: }
 91659: 
 91659: #ifdef JS_GC_ZEAL
 91659: static JSBool
 91659: GCZeal(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
 91659:     uint32_t zeal, frequency = JS_DEFAULT_ZEAL_FREQ;
107154:     CallArgs args = CallArgsFromVp(argc, vp);
 91659: 
 94870:     if (argc > 2) {
107154:         RootedObject callee(cx, &args.callee());
107154:         ReportUsageError(cx, callee, "Too many arguments");
 91659:         return JS_FALSE;
 91659:     }
107154:     if (!JS_ValueToECMAUint32(cx, argc < 1 ? JSVAL_VOID : args[0], &zeal))
 91659:         return JS_FALSE;
 91659:     if (argc >= 2)
107154:         if (!JS_ValueToECMAUint32(cx, args[1], &frequency))
 91659:             return JS_FALSE;
 91659: 
 94870:     JS_SetGCZeal(cx, (uint8_t)zeal, frequency);
 91659:     *vp = JSVAL_VOID;
 91659:     return JS_TRUE;
 91659: }
 91659: 
 91659: static JSBool
 91659: ScheduleGC(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
107154:     CallArgs args = CallArgsFromVp(argc, vp);
107154: 
 94870:     if (argc != 1) {
107154:         RootedObject callee(cx, &args.callee());
107154:         ReportUsageError(cx, callee, "Wrong number of arguments");
 91659:         return JS_FALSE;
 91659:     }
 91659: 
107154:     if (args[0].isInt32()) {
 94872:         /* Schedule a GC to happen after |arg| allocations. */
107154:         JS_ScheduleGC(cx, args[0].toInt32());
107154:     } else if (args[0].isObject()) {
 94872:         /* Ensure that |comp| is collected during the next GC. */
107154:         JSCompartment *comp = UnwrapObject(&args[0].toObject())->compartment();
 94872:         PrepareCompartmentForGC(comp);
107154:     } else if (args[0].isString()) {
 94872:         /* This allows us to schedule atomsCompartment for GC. */
107154:         PrepareCompartmentForGC(args[0].toString()->compartment());
 94872:     }
 94872: 
 91659:     *vp = JSVAL_VOID;
 91659:     return JS_TRUE;
 91659: }
 91659: 
 91659: static JSBool
 94873: SelectForGC(JSContext *cx, unsigned argc, jsval *vp)
 94873: {
 94873:     JSRuntime *rt = cx->runtime;
 94873: 
 94873:     for (unsigned i = 0; i < argc; i++) {
 94873:         Value arg(JS_ARGV(cx, vp)[i]);
 94873:         if (arg.isObject()) {
 94873:             if (!rt->gcSelectedForMarking.append(&arg.toObject()))
 94873:                 return false;
 94873:         }
 94873:     }
 94873: 
 94873:     *vp = JSVAL_VOID;
 94873:     return true;
 94873: }
 94873: 
 94873: static JSBool
105981: VerifyPreBarriers(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
107154:     CallArgs args = CallArgsFromVp(argc, vp);
107154: 
 91659:     if (argc) {
107154:         RootedObject callee(cx, &args.callee());
107154:         ReportUsageError(cx, callee, "Too many arguments");
 91659:         return JS_FALSE;
 91659:     }
105981:     gc::VerifyBarriers(cx->runtime, gc::PreBarrierVerifier);
105981:     *vp = JSVAL_VOID;
105981:     return JS_TRUE;
105981: }
105981: 
105981: static JSBool
105981: VerifyPostBarriers(JSContext *cx, unsigned argc, jsval *vp)
105981: {
105981:     if (argc) {
107154:         RootedObject callee(cx, &JS_CALLEE(cx, vp).toObject());
107154:         ReportUsageError(cx, callee, "Too many arguments");
105981:         return JS_FALSE;
105981:     }
105981:     gc::VerifyBarriers(cx->runtime, gc::PostBarrierVerifier);
 91659:     *vp = JSVAL_VOID;
 91659:     return JS_TRUE;
 91659: }
 91659: 
 91659: static JSBool
 91659: GCSlice(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
 94873:     bool limit = true;
 94873:     uint32_t budget = 0;
107154:     CallArgs args = CallArgsFromVp(argc, vp);
 91659: 
 94873:     if (argc > 1) {
107154:         RootedObject callee(cx, &args.callee());
107154:         ReportUsageError(cx, callee, "Wrong number of arguments");
 91659:         return JS_FALSE;
 91659:     }
 91659: 
 94873:     if (argc == 1) {
107154:         if (!JS_ValueToECMAUint32(cx, args[0], &budget))
 94873:             return false;
 94873:     } else {
 94873:         limit = false;
 94873:     }
 91659: 
 94960:     GCDebugSlice(cx->runtime, limit, budget);
 91659:     *vp = JSVAL_VOID;
 91659:     return JS_TRUE;
 91659: }
 91660: 
 91660: static JSBool
125056: GCState(JSContext *cx, unsigned argc, jsval *vp)
125056: {
125056:     CallArgs args = CallArgsFromVp(argc, vp);
125056: 
125056:     if (argc != 0) {
125056:         RootedObject callee(cx, &args.callee());
125056:         ReportUsageError(cx, callee, "Too many arguments");
125056:         return false;
125056:     }
125056: 
125056:     const char *state;
125056:     gc::State globalState = cx->runtime->gcIncrementalState;
125056:     if (globalState == gc::NO_INCREMENTAL)
125056:         state = "none";
125056:     else if (globalState == gc::MARK)
125056:         state = "mark";
125056:     else if (globalState == gc::SWEEP)
125056:         state = "sweep";
125056:     else
125056:         JS_NOT_REACHED("Unobserveable global GC state");
125056: 
125056:     *vp = StringValue(js_NewStringCopyZ(cx, state));
125056:     return true;
125056: }
125056: 
125056: static JSBool
 98147: GCPreserveCode(JSContext *cx, unsigned argc, jsval *vp)
 98147: {
107154:     CallArgs args = CallArgsFromVp(argc, vp);
107154: 
 98147:     if (argc != 0) {
107154:         RootedObject callee(cx, &args.callee());
107154:         ReportUsageError(cx, callee, "Wrong number of arguments");
 98147:         return JS_FALSE;
 98147:     }
 98147: 
 98147:     cx->runtime->alwaysPreserveCode = true;
 98147: 
 98147:     *vp = JSVAL_VOID;
 98147:     return JS_TRUE;
 98147: }
 98147: 
 98147: static JSBool
 91660: DeterministicGC(JSContext *cx, unsigned argc, jsval *vp)
 91660: {
107154:     CallArgs args = CallArgsFromVp(argc, vp);
107154: 
 91660:     if (argc != 1) {
107154:         RootedObject callee(cx, &args.callee());
107154:         ReportUsageError(cx, callee, "Wrong number of arguments");
 91660:         return JS_FALSE;
 91660:     }
 91660: 
106378:     gc::SetDeterministicGC(cx, ToBoolean(vp[2]));
 91660:     *vp = JSVAL_VOID;
 91660:     return JS_TRUE;
 91660: }
 91659: #endif /* JS_GC_ZEAL */
 91659: 
108566: static JSBool
108566: ValidateGC(JSContext *cx, unsigned argc, jsval *vp)
108566: {
108566:     CallArgs args = CallArgsFromVp(argc, vp);
108566: 
108566:     if (argc != 1) {
108566:         RootedObject callee(cx, &args.callee());
108566:         ReportUsageError(cx, callee, "Wrong number of arguments");
108566:         return JS_FALSE;
108566:     }
108566: 
108566:     gc::SetValidateGC(cx, ToBoolean(vp[2]));
108566:     *vp = JSVAL_VOID;
108566:     return JS_TRUE;
108566: }
108566: 
124785: static JSBool
124785: NondeterminsticGetWeakMapKeys(JSContext *cx, unsigned argc, jsval *vp)
124785: {
124785:     CallArgs args = CallArgsFromVp(argc, vp);
124785: 
124785:     if (argc != 1) {
124785:         RootedObject callee(cx, &args.callee());
124785:         ReportUsageError(cx, callee, "Wrong number of arguments");
124785:         return false;
124785:     }
124785:     if (!args[0].isObject()) {
124785:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_EXPECTED_TYPE,
124785:                              "nondeterministicGetWeakMapKeys", "WeakMap",
124785:                              InformalValueTypeName(args[0]));
124785:         return false;
124785:     }
124785:     JSObject *arr;
124785:     if (!JS_NondeterministicGetWeakMapKeys(cx, &args[0].toObject(), &arr))
124785:         return false;
124785:     if (!arr) {
124785:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_EXPECTED_TYPE,
124785:                              "nondeterministicGetWeakMapKeys", "WeakMap",
124785:                              args[0].toObject().getClass()->name);
124785:         return false;
124785:     }
124785:     args.rval().setObject(*arr);
124785:     return true;
124785: }
124785: 
 91659: struct JSCountHeapNode {
 91659:     void                *thing;
 91659:     JSGCTraceKind       kind;
 91659:     JSCountHeapNode     *next;
 91659: };
 91659: 
 94610: typedef HashSet<void *, PointerHasher<void *, 3>, SystemAllocPolicy> VisitedSet;
 94610: 
 91659: typedef struct JSCountHeapTracer {
 91659:     JSTracer            base;
 94610:     VisitedSet          visited;
 91659:     JSCountHeapNode     *traceList;
 91659:     JSCountHeapNode     *recycleList;
 94610:     bool                ok;
 91659: } JSCountHeapTracer;
 91659: 
 91659: static void
 91659: CountHeapNotify(JSTracer *trc, void **thingp, JSGCTraceKind kind)
 91659: {
 94610:     JS_ASSERT(trc->callback == CountHeapNotify);
 94610: 
 94610:     JSCountHeapTracer *countTracer = (JSCountHeapTracer *)trc;
 91659:     void *thing = *thingp;
 91659: 
 91659:     if (!countTracer->ok)
 91659:         return;
 91659: 
 94610:     VisitedSet::AddPtr p = countTracer->visited.lookupForAdd(thing);
 94610:     if (p)
 94610:         return;
 94610: 
 94610:     if (!countTracer->visited.add(p, thing)) {
 91659:         countTracer->ok = false;
 91659:         return;
 91659:     }
 91659: 
 94610:     JSCountHeapNode *node = countTracer->recycleList;
 91659:     if (node) {
 91659:         countTracer->recycleList = node->next;
 91659:     } else {
110934:         node = js_pod_malloc<JSCountHeapNode>();
 91659:         if (!node) {
 91659:             countTracer->ok = false;
 91659:             return;
 91659:         }
 91659:     }
 91659:     node->thing = thing;
 91659:     node->kind = kind;
 91659:     node->next = countTracer->traceList;
 91659:     countTracer->traceList = node;
 91659: }
 91659: 
 91659: static const struct TraceKindPair {
 91659:     const char       *name;
 91659:     int32_t           kind;
 91659: } traceKindNames[] = {
 91659:     { "all",        -1                  },
 91659:     { "object",     JSTRACE_OBJECT      },
 91659:     { "string",     JSTRACE_STRING      },
 91659: #if JS_HAS_XML_SUPPORT
 91659:     { "xml",        JSTRACE_XML         },
 91659: #endif
 91659: };
 91659: 
 91659: static JSBool
 91659: CountHeap(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
 91659:     void* startThing;
 91659:     JSGCTraceKind startTraceKind;
 91659:     jsval v;
 91659:     int32_t traceKind;
 91659:     JSString *str;
 91659:     JSCountHeapTracer countTracer;
 91659:     JSCountHeapNode *node;
 91659:     size_t counter;
 91659: 
 91659:     startThing = NULL;
 91659:     startTraceKind = JSTRACE_OBJECT;
 91659:     if (argc > 0) {
 91659:         v = JS_ARGV(cx, vp)[0];
 91659:         if (JSVAL_IS_TRACEABLE(v)) {
 91659:             startThing = JSVAL_TO_TRACEABLE(v);
 91659:             startTraceKind = JSVAL_TRACE_KIND(v);
 91659:         } else if (!JSVAL_IS_NULL(v)) {
 91659:             JS_ReportError(cx,
 91659:                            "the first argument is not null or a heap-allocated "
 91659:                            "thing");
 91659:             return JS_FALSE;
 91659:         }
 91659:     }
 91659: 
 91659:     traceKind = -1;
 91659:     if (argc > 1) {
 91659:         str = JS_ValueToString(cx, JS_ARGV(cx, vp)[1]);
 91659:         if (!str)
 91659:             return JS_FALSE;
 91659:         JSFlatString *flatStr = JS_FlattenString(cx, str);
 91659:         if (!flatStr)
 91659:             return JS_FALSE;
 91659:         for (size_t i = 0; ;) {
 91659:             if (JS_FlatStringEqualsAscii(flatStr, traceKindNames[i].name)) {
 91659:                 traceKind = traceKindNames[i].kind;
 91659:                 break;
 91659:             }
 91659:             if (++i == ArrayLength(traceKindNames)) {
 91659:                 JSAutoByteString bytes(cx, str);
 91659:                 if (!!bytes)
 91659:                     JS_ReportError(cx, "trace kind name '%s' is unknown", bytes.ptr());
 91659:                 return JS_FALSE;
 91659:             }
 91659:         }
 91659:     }
 91659: 
 91659:     JS_TracerInit(&countTracer.base, JS_GetRuntime(cx), CountHeapNotify);
 94610:     if (!countTracer.visited.init()) {
 91659:         JS_ReportOutOfMemory(cx);
 91659:         return JS_FALSE;
 91659:     }
 91659:     countTracer.ok = true;
 91659:     countTracer.traceList = NULL;
 91659:     countTracer.recycleList = NULL;
 91659: 
 91659:     if (!startThing) {
 91659:         JS_TraceRuntime(&countTracer.base);
 91659:     } else {
 91659:         JS_SET_TRACING_NAME(&countTracer.base, "root");
 91659:         JS_CallTracer(&countTracer.base, startThing, startTraceKind);
 91659:     }
 91659: 
 91659:     counter = 0;
 91659:     while ((node = countTracer.traceList) != NULL) {
 91659:         if (traceKind == -1 || node->kind == traceKind)
 91659:             counter++;
 91659:         countTracer.traceList = node->next;
 91659:         node->next = countTracer.recycleList;
 91659:         countTracer.recycleList = node;
 91659:         JS_TraceChildren(&countTracer.base, node->thing, node->kind);
 91659:     }
 91659:     while ((node = countTracer.recycleList) != NULL) {
 91659:         countTracer.recycleList = node->next;
 91659:         js_free(node);
 91659:     }
 91659:     if (!countTracer.ok) {
 91659:         JS_ReportOutOfMemory(cx);
 91659:         return false;
 91659:     }
 91659: 
107180:     *vp = JS_NumberValue((double) counter);
107180:     return true;
 91659: }
 91659: 
 91659: static unsigned finalizeCount = 0;
 91659: 
 91659: static void
 94738: finalize_counter_finalize(JSFreeOp *fop, JSObject *obj)
 91659: {
121008:     ++finalizeCount;
 91659: }
 91659: 
 91659: static JSClass FinalizeCounterClass = {
 91659:     "FinalizeCounter", JSCLASS_IS_ANONYMOUS,
 91659:     JS_PropertyStub,       /* addProperty */
 91659:     JS_PropertyStub,       /* delProperty */
 91659:     JS_PropertyStub,       /* getProperty */
 91659:     JS_StrictPropertyStub, /* setProperty */
 91659:     JS_EnumerateStub,
 91659:     JS_ResolveStub,
 91659:     JS_ConvertStub,
 91659:     finalize_counter_finalize
 91659: };
 91659: 
 91659: static JSBool
 91659: MakeFinalizeObserver(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
107154:     RootedObject scope(cx, JS_GetGlobalForScopeChain(cx));
102341:     if (!scope)
102341:         return false;
102341: 
102341:     JSObject *obj = JS_NewObjectWithGivenProto(cx, &FinalizeCounterClass, NULL, scope);
 91659:     if (!obj)
 91659:         return false;
102341: 
 91659:     *vp = OBJECT_TO_JSVAL(obj);
 91659:     return true;
 91659: }
 91659: 
 91659: static JSBool
 91659: FinalizeCount(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
 91659:     *vp = INT_TO_JSVAL(finalizeCount);
 91659:     return true;
 91659: }
 91659: 
120827: static JSBool
120827: DumpHeapComplete(JSContext *cx, unsigned argc, jsval *vp)
120827: {
120827:     const char *fileName = NULL;
120827:     JSAutoByteString fileNameBytes;
120827:     if (argc > 0) {
120827:         Value v = JS_ARGV(cx, vp)[0];
120827:         if (v.isString()) {
120827:             JSString *str = v.toString();
120827:             if (!fileNameBytes.encode(cx, str))
120827:                 return false;
120827:             fileName = fileNameBytes.ptr();
120827:         }
120827:     }
120827: 
120827:     FILE *dumpFile;
120827:     if (!fileName) {
120827:         dumpFile = stdout;
120827:     } else {
120827:         dumpFile = fopen(fileName, "w");
120827:         if (!dumpFile) {
120827:             JS_ReportError(cx, "can't open %s", fileName);
120827:             return false;
120827:         }
120827:     }
120827: 
120827:     js::DumpHeapComplete(JS_GetRuntime(cx), dumpFile);
120827: 
120827:     fclose(dumpFile);
120827: 
120827:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
120827:     return true;
120827: }
120827: 
 91659: JSBool
 91659: MJitChunkLimit(JSContext *cx, unsigned argc, jsval *vp)
 91659: {
107154:     CallArgs args = CallArgsFromVp(argc, vp);
107154: 
 91659:     if (argc != 1) {
107154:         RootedObject callee(cx, &args.callee());
107154:         ReportUsageError(cx, callee, "Wrong number of arguments");
 91659:         return JS_FALSE;
 91659:     }
 91659: 
 99054:     if (cx->runtime->alwaysPreserveCode) {
 99054:         JS_ReportError(cx, "Can't change chunk limit after gcPreserveCode()");
 99054:         return JS_FALSE;
 99054:     }
 99054: 
125277:     for (CompartmentsIter c(cx->runtime); !c.done(); c.next()) {
125277:         if (c->lastAnimationTime != 0) {
125277:             JS_ReportError(cx, "Can't change chunk limit if code may be preserved");
125277:             return JS_FALSE;
125277:         }
125277:     }
125277: 
 91659:     double t;
107154:     if (!JS_ValueToNumber(cx, args[0], &t))
 91659:         return JS_FALSE;
 91659: 
 91659: #ifdef JS_METHODJIT
 91659:     mjit::SetChunkLimit((uint32_t) t);
 91659: #endif
 91659: 
 91659:     // Clear out analysis information which might refer to code compiled with
 91659:     // the previous chunk limit.
 94960:     JS_GC(cx->runtime);
 91659: 
 91659:     vp->setUndefined();
 91659:     return true;
 91659: }
 91659: 
 91659: static JSBool
 91659: Terminate(JSContext *cx, unsigned arg, jsval *vp)
 91659: {
 91659:     JS_ClearPendingException(cx);
 91659:     return JS_FALSE;
 91659: }
 91659: 
105458: static JSBool
105458: EnableSPSProfilingAssertions(JSContext *cx, unsigned argc, jsval *vp)
105458: {
107154:     CallArgs args = CallArgsFromVp(argc, vp);
107154:     if (argc == 0 || !args[0].isBoolean()) {
107154:         RootedObject arg(cx, &args.callee());
107154:         ReportUsageError(cx, arg, "Must have one boolean argument");
105458:         return false;
105458:     }
105458: 
105458:     static ProfileEntry stack[1000];
105458:     static uint32_t stack_size = 0;
105458: 
105458:     SetRuntimeProfilingStack(cx->runtime, stack, &stack_size, 1000);
107154:     cx->runtime->spsProfiler.enableSlowAssertions(args[0].toBoolean());
108147:     cx->runtime->spsProfiler.enable(true);
105458: 
105458:     JS_SET_RVAL(cx, vp, JSVAL_VOID);
105458:     return true;
105458: }
105458: 
109111: static JSBool
109111: DisplayName(JSContext *cx, unsigned argc, jsval *vp)
109111: {
109111:     CallArgs args = CallArgsFromVp(argc, vp);
109111:     if (argc == 0 || !args[0].isObject() || !args[0].toObject().isFunction()) {
109111:         RootedObject arg(cx, &args.callee());
109111:         ReportUsageError(cx, arg, "Must have one function argument");
109111:         return false;
109111:     }
109111: 
109111:     JSFunction *fun = args[0].toObject().toFunction();
109111:     JSString *str = fun->displayAtom();
109111:     vp->setString(str == NULL ? cx->runtime->emptyString : str);
109111:     return true;
109111: }
109111: 
 91659: static JSFunctionSpecWithHelp TestingFunctions[] = {
 91659:     JS_FN_HELP("gc", ::GC, 0, 0,
 94872: "gc([obj] | 'compartment')",
 94872: "  Run the garbage collector. When obj is given, GC only its compartment.\n"
 94872: "  If 'compartment' is given, GC any compartments that were scheduled for\n"
 94872: "  GC via schedulegc."),
 91659: 
 91659:     JS_FN_HELP("gcparam", GCParameter, 2, 0,
 91659: "gcparam(name [, value])",
 91659: "  Wrapper for JS_[GS]etGCParameter. The name is either maxBytes,\n"
 91659: "  maxMallocBytes, gcBytes, gcNumber, or sliceTimeBudget."),
 91659: 
106214:     JS_FN_HELP("getBuildConfiguration", GetBuildConfiguration, 0, 0,
106214: "getBuildConfiguration()",
106214: "  Return an object describing some of the configuration options SpiderMonkey\n"
106214: "  was built with."),
106214: 
 91659:     JS_FN_HELP("countHeap", CountHeap, 0, 0,
 91659: "countHeap([start[, kind]])",
 91659: "  Count the number of live GC things in the heap or things reachable from\n"
 91659: "  start when it is given and is not null. kind is either 'all' (default) to\n"
 91659: "  count all things or one of 'object', 'double', 'string', 'function',\n"
 91659: "  'qname', 'namespace', 'xml' to count only things of that kind."),
 91659: 
 91659:     JS_FN_HELP("makeFinalizeObserver", MakeFinalizeObserver, 0, 0,
 91659: "makeFinalizeObserver()",
 91659: "  Get a special object whose finalization increases the counter returned\n"
 91659: "  by the finalizeCount function."),
 91659: 
 91659:     JS_FN_HELP("finalizeCount", FinalizeCount, 0, 0,
 91659: "finalizeCount()",
 91659: "  Return the current value of the finalization counter that is incremented\n"
 91659: "  each time an object returned by the makeFinalizeObserver is finalized."),
 91659: 
 91659: #ifdef JS_GC_ZEAL
 91659:     JS_FN_HELP("gczeal", GCZeal, 2, 0,
 94870: "gczeal(level, [period])",
 91659: "  Specifies how zealous the garbage collector should be. Values for level:\n"
 91659: "    0: Normal amount of collection\n"
 91659: "    1: Collect when roots are added or removed\n"
 91659: "    2: Collect when memory is allocated\n"
 91659: "    3: Collect when the window paints (browser only)\n"
105981: "    4: Verify pre write barriers between instructions\n"
105981: "    5: Verify pre write barriers between paints\n"
102161: "    6: Verify stack rooting (ignoring XML and Reflect)\n"
102161: "    7: Verify stack rooting (all roots)\n"
105981: "    8: Incremental GC in two slices: 1) mark roots 2) finish collection\n"
105981: "    9: Incremental GC in two slices: 1) mark all 2) new marking and finish\n"
105981: "   10: Incremental GC in multiple slices\n"
105981: "   11: Verify post write barriers between instructions\n"
105981: "   12: Verify post write barriers between paints\n"
109045: "   13: Purge analysis state when memory is allocated\n"
 94870: "  Period specifies that collection happens every n allocations.\n"),
 91659: 
 91659:     JS_FN_HELP("schedulegc", ScheduleGC, 1, 0,
 94872: "schedulegc(num | obj)",
 94872: "  If num is given, schedule a GC after num allocations.\n"
 94872: "  If obj is given, schedule a GC of obj's compartment."),
 91659: 
 94873:     JS_FN_HELP("selectforgc", SelectForGC, 0, 0,
 94873: "selectforgc(obj1, obj2, ...)",
 94873: "  Schedule the given objects to be marked in the next GC slice."),
 94873: 
105981:     JS_FN_HELP("verifyprebarriers", VerifyPreBarriers, 0, 0,
105981: "verifyprebarriers()",
105981: "  Start or end a run of the pre-write barrier verifier."),
105981: 
105981:     JS_FN_HELP("verifypostbarriers", VerifyPostBarriers, 0, 0,
105981: "verifypostbarriers()",
105981: "  Start or end a run of the post-write barrier verifier."),
 91659: 
 91659:     JS_FN_HELP("gcslice", GCSlice, 1, 0,
 91659: "gcslice(n)",
 91659: "  Run an incremental GC slice that marks about n objects."),
 91660: 
125056:     JS_FN_HELP("gcstate", GCState, 0, 0,
125056: "gcstate()",
125056: "  Report the global GC state."),
125056: 
 98147:     JS_FN_HELP("gcPreserveCode", GCPreserveCode, 0, 0,
 98147: "gcPreserveCode()",
 98147: "  Preserve JIT code during garbage collections."),
 98147: 
 91660:     JS_FN_HELP("deterministicgc", DeterministicGC, 1, 0,
 91660: "deterministicgc(true|false)",
 91660: "  If true, only allow determinstic GCs to run."),
 91659: #endif
 91659: 
108566:     JS_FN_HELP("validategc", ValidateGC, 1, 0,
108566: "validategc(true|false)",
108566: "  If true, a separate validation step is performed after an incremental GC."),
108566: 
124785:     JS_FN_HELP("nondeterministicGetWeakMapKeys", NondeterminsticGetWeakMapKeys, 1, 0,
124785: "nondeterministicGetWeakMapKeys(weakmap)",
124785: "  Return an array of the keys in the given WeakMap."),
124785: 
 91659:     JS_FN_HELP("internalConst", InternalConst, 1, 0,
 91659: "internalConst(name)",
 91659: "  Query an internal constant for the engine. See InternalConst source for\n"
 91659: "  the list of constant names."),
 91659: 
 98670:     JS_FN_HELP("isProxy", IsProxy, 1, 0,
 98670: "isProxy(obj)",
 98670: "  If true, obj is a proxy of some sort"),
 98670: 
120827:     JS_FN_HELP("dumpHeapComplete", DumpHeapComplete, 1, 0,
120827: "dumpHeapComplete([filename])",
120827: "  Dump reachable and unreachable objects to a file."),
120827: 
 91659:     JS_FN_HELP("mjitChunkLimit", MJitChunkLimit, 1, 0,
 91659: "mjitChunkLimit(N)",
 91659: "  Specify limit on compiled chunk size during mjit compilation."),
 91659: 
 91659:     JS_FN_HELP("terminate", Terminate, 0, 0,
 91659: "terminate()",
 91659: "  Terminate JavaScript execution, as if we had run out of\n"
 91659: "  memory or been terminated by the slow script dialog."),
 91659: 
105458:     JS_FN_HELP("enableSPSProfilingAssertions", EnableSPSProfilingAssertions, 1, 0,
108147: "enableSPSProfilingAssertions(slow)",
108147: "  Enables SPS instrumentation and corresponding assertions. If 'slow' is\n"
108147: "  true, then even slower assertions are enabled for all generated JIT code.\n"
108147: "  When 'slow' is false, then instrumentation is enabled, but the slow\n"
108147: "  assertions are disabled."),
105458: 
109111:     JS_FN_HELP("displayName", DisplayName, 1, 0,
109111: "displayName(fn)",
109111: "  Gets the display name for a function, which can possibly be a guessed or\n"
109111: "  inferred name based on where the function was defined. This can be\n"
109111: "  different from the 'name' property on the function."),
109111: 
107788:     JS_FS_HELP_END
 91659: };
 91659: 
 91659: bool
123695: js::DefineTestingFunctions(JSContext *cx, HandleObject obj)
 91659: {
 91659:     return JS_DefineFunctionsWithHelp(cx, obj, TestingFunctions);
 91659: }
