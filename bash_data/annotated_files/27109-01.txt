    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * vim: set ts=8 sw=4 et tw=78:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef jscntxt_h___
    1: #define jscntxt_h___
    1: /*
    1:  * JS execution context.
    1:  */
    1: #include "jsarena.h" /* Added by JSIFY */
    1: #include "jsclist.h"
    1: #include "jslong.h"
    1: #include "jsatom.h"
18863: #include "jsversion.h"
    1: #include "jsdhash.h"
    1: #include "jsgc.h"
    1: #include "jsinterp.h"
    1: #include "jsobj.h"
    1: #include "jsprvtd.h"
    1: #include "jspubtd.h"
    1: #include "jsregexp.h"
    1: #include "jsutil.h"
    1: 
    1: JS_BEGIN_EXTERN_C
    1: 
    1: /*
    1:  * js_GetSrcNote cache to avoid O(n^2) growth in finding a source note for a
15530:  * given pc in a script. We use the script->code pointer to tag the cache,
15530:  * instead of the script address itself, so that source notes are always found
15530:  * by offset from the bytecode with which they were generated.
    1:  */
    1: typedef struct JSGSNCache {
15530:     jsbytecode      *code;
    1:     JSDHashTable    table;
    1: #ifdef JS_GSNMETER
    1:     uint32          hits;
    1:     uint32          misses;
    1:     uint32          fills;
26569:     uint32          purges;
    1: # define GSN_CACHE_METER(cache,cnt) (++(cache)->cnt)
    1: #else
    1: # define GSN_CACHE_METER(cache,cnt) /* nothing */
    1: #endif
    1: } JSGSNCache;
    1: 
26569: #define js_FinishGSNCache(cache) js_PurgeGSNCache(cache)
26569: 
26569: extern void
26569: js_PurgeGSNCache(JSGSNCache *cache);
    1: 
    1: /* These helper macros take a cx as parameter and operate on its GSN cache. */
26569: #define JS_PURGE_GSN_CACHE(cx)      js_PurgeGSNCache(&JS_GSN_CACHE(cx))
    1: #define JS_METER_GSN_CACHE(cx,cnt)  GSN_CACHE_METER(&JS_GSN_CACHE(cx), cnt)
    1: 
24612: typedef struct InterpState InterpState;
24612: typedef struct VMSideExit VMSideExit;
24612: 
18022: #ifdef __cplusplus
17583: namespace nanojit {
17937:     class Fragment;
17583:     class Fragmento;
23237:     class LirBuffer;
17583: }
17583: class TraceRecorder;
18497: extern "C++" { template<typename T> class Queue; }
18223: typedef Queue<uint16> SlotList;
17583: 
18022: # define CLS(T)  T*
18022: #else
18022: # define CLS(T)  void*
18022: #endif
18022: 
24307: #define FRAGMENT_TABLE_SIZE 512
24307: struct VMFragment;
24307: 
24491: #define MONITOR_N_GLOBAL_STATES 4
24491: struct GlobalState {
26819:     JSObject*               globalObj;
24491:     uint32                  globalShape;
24491:     CLS(SlotList)           globalSlots;
24491: };
24491: 
17583: /*
17583:  * Trace monitor. Every JSThread (if JS_THREADSAFE) or JSRuntime (if not
17583:  * JS_THREADSAFE) has an associated trace monitor that keeps track of loop
17583:  * frequencies for all JavaScript code loaded into that runtime.
17583:  */
26569: struct JSTraceMonitor {
18782:     /*
18782:      * Flag set when running (or recording) JIT-compiled code. This prevents
18782:      * both interpreter activation and last-ditch garbage collection when up
18782:      * against our runtime's memory limits. This flag also suppresses calls to
18782:      * JS_ReportOutOfMemory when failing due to runtime limits.
24613:      *
24613:      * !onTrace && !recorder: not on trace.
24613:      * onTrace && recorder: recording a trace.
24613:      * onTrace && !recorder: executing a trace.
24613:      * !onTrace && recorder && !prohibitRecording:
24613:      *      not on trace; deep-aborted while recording.
24613:      * !onTrace && recorder && prohibitRecording:
24613:      *      not on trace; deep-bailed in SpiderMonkey code called from a
24613:      *      trace. JITted code is on the stack.
18782:      */
24613:     JSPackedBool            onTrace;
24613: 
24613:     /*
24613:      * Do not start recording after a deep bail.  That would free JITted code
24613:      * pages that we will later return to.
24613:      */
24613:     JSPackedBool            prohibitRecording;
24613: 
24613:     /* See reservedObjects below. */
24613:     JSPackedBool            useReservedObjects;
24598: 
23264:     CLS(nanojit::LirBuffer) lirbuf;
18022:     CLS(nanojit::Fragmento) fragmento;
18022:     CLS(TraceRecorder)      recorder;
23449:     jsval                   *reservedDoublePool;
23449:     jsval                   *reservedDoublePoolPtr;
21491: 
24491:     struct GlobalState globalStates[MONITOR_N_GLOBAL_STATES];
24307:     struct VMFragment* vmfragments[FRAGMENT_TABLE_SIZE];
24491:     JSBool needFlush;
24307: 
23448:     /*
23448:      * reservedObjects is a linked list (via fslots[0]) of preallocated JSObjects.
23448:      * The JIT uses this to ensure that leaving a trace tree can't fail.
23448:      */
23448:     JSObject                *reservedObjects;
23448: 
21491:     /* Fragmento for the regular expression compiler. This is logically
21491:      * a distinct compiler but needs to be managed in exactly the same
21491:      * way as the real tracing Fragmento. */
23237:     CLS(nanojit::LirBuffer) reLirBuf;
21491:     CLS(nanojit::Fragmento) reFragmento;
21723: 
21723:     /* Keep a list of recorders we need to abort on cache flush. */
21723:     CLS(TraceRecorder)      abortStack;
26569: };
17583: 
24612: typedef struct InterpStruct InterpStruct;
24612: 
18782: #ifdef JS_TRACER
18782: # define JS_ON_TRACE(cx)            (JS_TRACE_MONITOR(cx).onTrace)
18782: #else
18782: # define JS_ON_TRACE(cx)            JS_FALSE
18782: #endif
18782: 
24375: #ifdef DEBUG
24375: # define JS_EVAL_CACHE_METERING     1
27012: # define JS_FUNCTION_METERING       1
24375: #endif
24375: 
24375: /* Number of potentially reusable scriptsToGC to search for the eval cache. */
24375: #ifndef JS_EVAL_CACHE_SHIFT
24375: # define JS_EVAL_CACHE_SHIFT        6
24375: #endif
24375: #define JS_EVAL_CACHE_SIZE          JS_BIT(JS_EVAL_CACHE_SHIFT)
24375: 
24375: #ifdef JS_EVAL_CACHE_METERING
24375: # define EVAL_CACHE_METER_LIST(_)   _(probe), _(hit), _(step), _(noscope)
27012: # define identity(x)                x
24375: 
24375: /* Have to typedef this for LiveConnect C code, which includes us. */
24375: typedef struct JSEvalCacheMeter {
27012:     uint64 EVAL_CACHE_METER_LIST(identity);
24375: } JSEvalCacheMeter;
24375: 
27012: # undef identity
27012: #endif
27012: 
27012: #ifdef JS_FUNCTION_METERING
27012: # define FUNCTION_KIND_METER_LIST(_)                                          \
27012:                         _(allfun), _(heavy), _(nofreeupvar), _(onlyfreevar),  \
27012:                         _(display), _(flat), _(setupvar), _(badfunarg)
27012: # define identity(x)    x
27012: 
27012: typedef struct JSFunctionMeter {
27012:     int32 FUNCTION_KIND_METER_LIST(identity);
27012: } JSFunctionMeter;
27012: 
27012: # undef identity
24375: #endif
24375: 
26569: struct JSThreadData {
26569:     /*
26569:      * The GSN cache is per thread since even multi-cx-per-thread embeddings
26569:      * do not interleave js_GetSrcNote calls.
26569:      */
26569:     JSGSNCache          gsnCache;
26569: 
26569:     /* Property cache for faster call/get/set invocation. */
26569:     JSPropertyCache     propertyCache;
26569: 
26569: #ifdef JS_TRACER
26569:     /* Trace-tree JIT recorder/interpreter state. */
26569:     JSTraceMonitor      traceMonitor;
26569: #endif
26569: 
26569:     /* Lock-free hashed lists of scripts created by eval to garbage-collect. */
26569:     JSScript            *scriptsToGC[JS_EVAL_CACHE_SIZE];
26569: 
26569: #ifdef JS_EVAL_CACHE_METERING
26569:     JSEvalCacheMeter    evalCacheMeter;
26569: #endif
26569: };
26569: 
    1: #ifdef JS_THREADSAFE
    1: 
    1: /*
    1:  * Structure uniquely representing a thread.  It holds thread-private data
    1:  * that can be accessed without a global lock.
    1:  */
    1: struct JSThread {
    1:     /* Linked list of all contexts active on this thread. */
    1:     JSCList             contextList;
    1: 
    1:     /* Opaque thread-id, from NSPR's PR_GetCurrentThread(). */
    1:     jsword              id;
    1: 
    1:     /*
    1:      * Thread-local version of JSRuntime.gcMallocBytes to avoid taking
    1:      * locks on each JS_malloc.
    1:      */
    1:     uint32              gcMallocBytes;
    1: 
26569:     JSThreadData        data;
    1: };
    1: 
26569: #define JS_THREAD_DATA(cx)      (&(cx)->thread->data)
    1: 
26569: struct JSThreadsHashEntry {
26569:     JSDHashEntryHdr     base;
26569:     JSThread            *thread;
26569: };
26569: 
26569: /*
26569:  * The function takes the GC lock and does not release in successful return.
26569:  * On error (out of memory) the function releases the lock but delegates
26569:  * the error reporting to the caller.
26569:  */
26569: extern JSBool
26569: js_InitContextThread(JSContext *cx);
26569: 
26569: /*
26569:  * On entrance the GC lock must be held and it will be held on exit.
26569:  */
26561: extern void
26569: js_ClearContextThread(JSContext *cx);
    1: 
    1: #endif /* JS_THREADSAFE */
    1: 
    1: typedef enum JSDestroyContextMode {
    1:     JSDCM_NO_GC,
    1:     JSDCM_MAYBE_GC,
    1:     JSDCM_FORCE_GC,
    1:     JSDCM_NEW_FAILED
    1: } JSDestroyContextMode;
    1: 
    1: typedef enum JSRuntimeState {
    1:     JSRTS_DOWN,
    1:     JSRTS_LAUNCHING,
    1:     JSRTS_UP,
    1:     JSRTS_LANDING
    1: } JSRuntimeState;
    1: 
24612: #ifdef JS_TRACER
24612: typedef enum JSBuiltinStatus {
24612:     JSBUILTIN_OK = 0,
24612:     JSBUILTIN_BAILED = 1,
24612:     JSBUILTIN_ERROR = 2
24612: } JSBuiltinStatus;
24612: #endif
24612: 
24384: typedef enum JSBuiltinFunctionId {
24384:     JSBUILTIN_ObjectToIterator,
24384:     JSBUILTIN_CallIteratorNext,
24489:     JSBUILTIN_GetProperty,
24489:     JSBUILTIN_GetElement,
24489:     JSBUILTIN_SetProperty,
24489:     JSBUILTIN_SetElement,
24384:     JSBUILTIN_LIMIT
24384: } JSBuiltinFunctionId;
24384: 
    1: typedef struct JSPropertyTreeEntry {
    1:     JSDHashEntryHdr     hdr;
    1:     JSScopeProperty     *child;
    1: } JSPropertyTreeEntry;
    1: 
11041: typedef struct JSSetSlotRequest JSSetSlotRequest;
11041: 
11041: struct JSSetSlotRequest {
11041:     JSObject            *obj;           /* object containing slot to set */
11041:     JSObject            *pobj;          /* new proto or parent reference */
11041:     uint16              slot;           /* which to set, proto or parent */
11041:     uint16              errnum;         /* JSMSG_NO_ERROR or error result */
11041:     JSSetSlotRequest    *next;          /* next request in GC worklist */
11041: };
11041: 
    1: struct JSRuntime {
    1:     /* Runtime state, synchronized by the stateChange/gcLock condvar/lock. */
    1:     JSRuntimeState      state;
    1: 
    1:     /* Context create/destroy callback. */
    1:     JSContextCallback   cxCallback;
    1: 
    1:     /* Garbage collector state, used by jsgc.c. */
 5917:     JSGCChunkInfo       *gcChunkList;
    1:     JSGCArenaList       gcArenaList[GC_NUM_FREELISTS];
12282:     JSGCDoubleArenaList gcDoubleArenaList;
19699:     JSGCFreeListSet     *gcFreeListsPool;
    1:     JSDHashTable        gcRootsHash;
    1:     JSDHashTable        *gcLocksHash;
    1:     jsrefcount          gcKeepAtoms;
    1:     uint32              gcBytes;
    1:     uint32              gcLastBytes;
    1:     uint32              gcMaxBytes;
    1:     uint32              gcMaxMallocBytes;
19196:     uint32              gcEmptyArenaPoolLifespan;
    1:     uint32              gcLevel;
    1:     uint32              gcNumber;
  583:     JSTracer            *gcMarkingTracer;
24313:     uint32              gcTriggerFactor;
    1: 
    1:     /*
    1:      * NB: do not pack another flag here by claiming gcPadding unless the new
    1:      * flag is written only by the GC thread.  Atomic updates to packed bytes
    1:      * are not guaranteed, so stores issued by one thread may be lost due to
    1:      * unsynchronized read-modify-write cycles on other threads.
    1:      */
    1:     JSPackedBool        gcPoke;
    1:     JSPackedBool        gcRunning;
 7944:     uint16              gcPadding;
 1492: #ifdef JS_GC_ZEAL
 7944:     jsrefcount          gcZeal;
 1492: #endif
    1: 
    1:     JSGCCallback        gcCallback;
    1:     uint32              gcMallocBytes;
 5917:     JSGCArenaInfo       *gcUntracedArenaStackTop;
    1: #ifdef DEBUG
 5917:     size_t              gcTraceLaterCount;
    1: #endif
    1: 
    1:     /*
    1:      * Table for tracking iterators to ensure that we close iterator's state
    1:      * before finalizing the iterable object.
    1:      */
    1:     JSPtrTable          gcIteratorTable;
    1: 
  958:     /*
  958:      * The trace operation and its data argument to trace embedding-specific
  958:      * GC roots.
  958:      */
  958:     JSTraceDataOp       gcExtraRootsTraceOp;
  958:     void                *gcExtraRootsData;
  958: 
11041:     /*
11041:      * Used to serialize cycle checks when setting __proto__ or __parent__ by
11041:      * requesting the GC handle the required cycle detection. If the GC hasn't
11041:      * been poked, it won't scan for garbage. This member is protected by
11041:      * rt->gcLock.
11041:      */
11041:     JSSetSlotRequest    *setSlotRequests;
11041: 
    1:     /* Random number generator state, used by jsmath.c. */
    1:     JSBool              rngInitialized;
    1:     int64               rngMultiplier;
    1:     int64               rngAddend;
    1:     int64               rngMask;
    1:     int64               rngSeed;
    1:     jsdouble            rngDscale;
    1: 
    1:     /* Well-known numbers held for use by this runtime's contexts. */
    1:     jsdouble            *jsNaN;
    1:     jsdouble            *jsNegativeInfinity;
    1:     jsdouble            *jsPositiveInfinity;
    1: 
    1: #ifdef JS_THREADSAFE
    1:     JSLock              *deflatedStringCacheLock;
    1: #endif
    1:     JSHashTable         *deflatedStringCache;
    1: #ifdef DEBUG
    1:     uint32              deflatedStringCacheBytes;
    1: #endif
    1: 
 4127:     /*
 4127:      * Empty and unit-length strings held for use by this runtime's contexts.
 4127:      * The unitStrings array and its elements are created on demand.
 4127:      */
    1:     JSString            *emptyString;
 4127:     JSString            **unitStrings;
    1: 
24384:     /*
24384:      * Builtin functions, lazily created and held for use by the trace recorder.
24384:      *
24384:      * This field would be #ifdef JS_TRACER, but XPConnect is compiled without
24384:      * -DJS_TRACER and includes this header.
24384:      */
24384:     JSObject            *builtinFunctions[JSBUILTIN_LIMIT];
24384: 
    1:     /* List of active contexts sharing this runtime; protected by gcLock. */
    1:     JSCList             contextList;
    1: 
 2433:     /* Per runtime debug hooks -- see jsprvtd.h and jsdbgapi.h. */
 2433:     JSDebugHooks        globalDebugHooks;
    1: 
    1:     /* More debugging state, see jsdbgapi.c. */
    1:     JSCList             trapList;
    1:     JSCList             watchPointList;
    1: 
20312:     /* Client opaque pointers */
    1:     void                *data;
    1: 
    1: #ifdef JS_THREADSAFE
    1:     /* These combine to interlock the GC and new requests. */
    1:     PRLock              *gcLock;
    1:     PRCondVar           *gcDone;
    1:     PRCondVar           *requestDone;
    1:     uint32              requestCount;
    1:     JSThread            *gcThread;
    1: 
    1:     /* Lock and owning thread pointer for JS_LOCK_RUNTIME. */
    1:     PRLock              *rtLock;
    1: #ifdef DEBUG
    1:     jsword              rtLockOwner;
    1: #endif
    1: 
    1:     /* Used to synchronize down/up state change; protected by gcLock. */
    1:     PRCondVar           *stateChange;
    1: 
    1:     /*
11739:      * State for sharing single-threaded titles, once a second thread tries to
11739:      * lock a title.  The titleSharingDone condvar is protected by rt->gcLock
    1:      * to minimize number of locks taken in JS_EndRequest.
    1:      *
11739:      * The titleSharingTodo linked list is likewise "global" per runtime, not
    1:      * one-list-per-context, to conserve space over all contexts, optimizing
11739:      * for the likely case that titles become shared rarely, and among a very
    1:      * small set of threads (contexts).
    1:      */
11739:     PRCondVar           *titleSharingDone;
11739:     JSTitle             *titleSharingTodo;
    1: 
    1: /*
11739:  * Magic terminator for the rt->titleSharingTodo linked list, threaded through
11739:  * title->u.link.  This hack allows us to test whether a title is on the list
11739:  * by asking whether title->u.link is non-null.  We use a large, likely bogus
    1:  * pointer here to distinguish this value from any valid u.count (small int)
    1:  * value.
    1:  */
11739: #define NO_TITLE_SHARING_TODO   ((JSTitle *) 0xfeedbeef)
    1: 
    1:     /*
    1:      * Lock serializing trapList and watchPointList accesses, and count of all
    1:      * mutations to trapList and watchPointList made by debugger threads.  To
    1:      * keep the code simple, we define debuggerMutations for the thread-unsafe
    1:      * case too.
    1:      */
    1:     PRLock              *debuggerLock;
26569: 
26569:     JSDHashTable        threads;
    1: #endif /* JS_THREADSAFE */
    1:     uint32              debuggerMutations;
    1: 
    1:     /*
18870:      * Security callbacks set on the runtime are used by each context unless
18870:      * an override is set on the context.
    1:      */
18870:     JSSecurityCallbacks *securityCallbacks;
    1: 
    1:     /*
    1:      * Shared scope property tree, and arena-pool for allocating its nodes.
    1:      * The propertyRemovals counter is incremented for every js_ClearScope,
    1:      * and for each js_RemoveScopeProperty that frees a slot in an object.
    1:      * See js_NativeGet and js_NativeSet in jsobj.c.
    1:      */
    1:     JSDHashTable        propertyTreeHash;
    1:     JSScopeProperty     *propertyFreeList;
    1:     JSArenaPool         propertyArenaPool;
    1:     int32               propertyRemovals;
    1: 
    1:     /* Script filename table. */
    1:     struct JSHashTable  *scriptFilenameTable;
    1:     JSCList             scriptFilenamePrefixes;
    1: #ifdef JS_THREADSAFE
    1:     PRLock              *scriptFilenameTableLock;
    1: #endif
    1: 
    1:     /* Number localization, used by jsnum.c */
    1:     const char          *thousandsSeparator;
    1:     const char          *decimalSeparator;
    1:     const char          *numGrouping;
    1: 
    1:     /*
    1:      * Weak references to lazily-created, well-known XML singletons.
    1:      *
    1:      * NB: Singleton objects must be carefully disconnected from the rest of
    1:      * the object graph usually associated with a JSContext's global object,
    1:      * including the set of standard class objects.  See jsxml.c for details.
    1:      */
    1:     JSObject            *anynameObject;
    1:     JSObject            *functionNamespaceObject;
    1: 
    1:     /*
    1:      * A helper list for the GC, so it can mark native iterator states. See
15613:      * js_TraceNativeEnumerators for details.
    1:      */
15613:     JSNativeEnumerator  *nativeEnumerators;
    1: 
    1: #ifndef JS_THREADSAFE
26569:     JSThreadData        threadData;
    1: 
26569: #define JS_THREAD_DATA(cx)      (&(cx)->runtime->threadData)
    1: #endif
    1: 
11377:     /*
11377:      * Object shape (property cache structural type) identifier generator.
11377:      *
11377:      * Type 0 stands for the empty scope, and must not be regenerated due to
11377:      * uint32 wrap-around. Since we use atomic pre-increment, the initial
11377:      * value for the first typed non-empty scope will be 1.
11377:      *
11377:      * The GC compresses live types, minimizing rt->shapeGen in the process.
11377:      * If this counter overflows into SHAPE_OVERFLOW_BIT (in jsinterp.h), the
11377:      * GC will disable property caches for all threads, to avoid aliasing two
11377:      * different types. Updated by js_GenerateShape (in jsinterp.c).
11377:      */
11377:     uint32              shapeGen;
11377: 
 4342:     /* Literal table maintained by jsatom.c functions. */
 4342:     JSAtomState         atomState;
 4342: 
10954:     /*
17049:      * Cache of reusable JSNativeEnumerators mapped by shape identifiers (as
17049:      * stored in scope->shape). This cache is nulled by the GC and protected
17049:      * by gcLock.
17049:      */
17049: #define NATIVE_ENUM_CACHE_LOG2  8
17049: #define NATIVE_ENUM_CACHE_MASK  JS_BITMASK(NATIVE_ENUM_CACHE_LOG2)
17049: #define NATIVE_ENUM_CACHE_SIZE  JS_BIT(NATIVE_ENUM_CACHE_LOG2)
17049: 
17049: #define NATIVE_ENUM_CACHE_HASH(shape)                                         \
17049:     ((((shape) >> NATIVE_ENUM_CACHE_LOG2) ^ (shape)) & NATIVE_ENUM_CACHE_MASK)
17049: 
17049:     jsuword             nativeEnumCache[NATIVE_ENUM_CACHE_SIZE];
17049: 
17049:     /*
10954:      * Various metering fields are defined at the end of JSRuntime. In this
10954:      * way there is no need to recompile all the code that refers to other
10954:      * fields of JSRuntime after enabling the corresponding metering macro.
10954:      */
17049: #ifdef JS_DUMP_ENUM_CACHE_STATS
17049:     int32               nativeEnumProbes;
17049:     int32               nativeEnumMisses;
17049: # define ENUM_CACHE_METER(name)     JS_ATOMIC_INCREMENT(&cx->runtime->name)
17049: #else
17049: # define ENUM_CACHE_METER(name)     ((void) 0)
17049: #endif
10954: 
17182: #ifdef JS_DUMP_LOOP_STATS
17182:     /* Loop statistics, to trigger trace recording and compiling. */
17182:     JSBasicStats        loopStats;
17182: #endif
17182: 
10217: #if defined DEBUG || defined JS_DUMP_PROPTREE_STATS
    1:     /* Function invocation metering. */
    1:     jsrefcount          inlineCalls;
    1:     jsrefcount          nativeCalls;
    1:     jsrefcount          nonInlineCalls;
    1:     jsrefcount          constructs;
    1: 
11739:     /* Title lock and scope property metering. */
    1:     jsrefcount          claimAttempts;
11739:     jsrefcount          claimedTitles;
    1:     jsrefcount          deadContexts;
    1:     jsrefcount          deadlocksAvoided;
    1:     jsrefcount          liveScopes;
11739:     jsrefcount          sharedTitles;
    1:     jsrefcount          totalScopes;
    1:     jsrefcount          liveScopeProps;
10217:     jsrefcount          liveScopePropsPreSweep;
    1:     jsrefcount          totalScopeProps;
    1:     jsrefcount          livePropTreeNodes;
    1:     jsrefcount          duplicatePropTreeNodes;
    1:     jsrefcount          totalPropTreeNodes;
    1:     jsrefcount          propTreeKidsChunks;
    1:     jsrefcount          middleDeleteFixups;
    1: 
    1:     /* String instrumentation. */
    1:     jsrefcount          liveStrings;
    1:     jsrefcount          totalStrings;
    1:     jsrefcount          liveDependentStrings;
    1:     jsrefcount          totalDependentStrings;
10217:     jsrefcount          badUndependStrings;
    1:     double              lengthSum;
    1:     double              lengthSquaredSum;
    1:     double              strdepLengthSum;
    1:     double              strdepLengthSquaredSum;
10217: #endif /* DEBUG || JS_DUMP_PROPTREE_STATS */
10217: 
10217: #ifdef JS_SCOPE_DEPTH_METER
10217:     /*
10217:      * Stats on runtime prototype chain lookups and scope chain depths, i.e.,
10217:      * counts of objects traversed on a chain until the wanted id is found.
10217:      */
10217:     JSBasicStats        protoLookupDepthStats;
10217:     JSBasicStats        scopeSearchDepthStats;
10217: 
10217:     /*
10217:      * Stats on compile-time host environment and lexical scope chain lengths
10217:      * (maximum depths).
10217:      */
10217:     JSBasicStats        hostenvScopeDepthStats;
10217:     JSBasicStats        lexicalScopeDepthStats;
    1: #endif
10954: 
10954: #ifdef JS_GCMETER
10954:     JSGCStats           gcStats;
10954: #endif
27012: 
27012: #ifdef JS_FUNCTION_METERING
27012:     JSFunctionMeter     functionMeter;
27012:     char                lastScriptFilename[1024];
27012: #endif
    1: };
    1: 
24375: /* Common macros to access thread-local caches in JSThread or JSRuntime. */
26569: #define JS_GSN_CACHE(cx)        (JS_THREAD_DATA(cx)->gsnCache)
26569: #define JS_PROPERTY_CACHE(cx)   (JS_THREAD_DATA(cx)->propertyCache)
26569: #define JS_TRACE_MONITOR(cx)    (JS_THREAD_DATA(cx)->traceMonitor)
26569: #define JS_SCRIPTS_TO_GC(cx)    (JS_THREAD_DATA(cx)->scriptsToGC)
24375: 
24375: #ifdef JS_EVAL_CACHE_METERING
26569: # define EVAL_CACHE_METER(x)    (JS_THREAD_DATA(cx)->evalCacheMeter.x++)
24375: #else
24375: # define EVAL_CACHE_METER(x)    ((void) 0)
24375: #endif
24375: 
    1: #ifdef DEBUG
    1: # define JS_RUNTIME_METER(rt, which)    JS_ATOMIC_INCREMENT(&(rt)->which)
    1: # define JS_RUNTIME_UNMETER(rt, which)  JS_ATOMIC_DECREMENT(&(rt)->which)
    1: #else
    1: # define JS_RUNTIME_METER(rt, which)    /* nothing */
    1: # define JS_RUNTIME_UNMETER(rt, which)  /* nothing */
    1: #endif
    1: 
    1: #define JS_KEEP_ATOMS(rt)   JS_ATOMIC_INCREMENT(&(rt)->gcKeepAtoms);
    1: #define JS_UNKEEP_ATOMS(rt) JS_ATOMIC_DECREMENT(&(rt)->gcKeepAtoms);
    1: 
    1: #ifdef JS_ARGUMENT_FORMATTER_DEFINED
    1: /*
    1:  * Linked list mapping format strings for JS_{Convert,Push}Arguments{,VA} to
    1:  * formatter functions.  Elements are sorted in non-increasing format string
    1:  * length order.
    1:  */
    1: struct JSArgumentFormatMap {
    1:     const char          *format;
    1:     size_t              length;
    1:     JSArgumentFormatter formatter;
    1:     JSArgumentFormatMap *next;
    1: };
    1: #endif
    1: 
    1: struct JSStackHeader {
    1:     uintN               nslots;
    1:     JSStackHeader       *down;
    1: };
    1: 
    1: #define JS_STACK_SEGMENT(sh)    ((jsval *)(sh) + 2)
    1: 
    1: /*
    1:  * Key and entry types for the JSContext.resolvingTable hash table, typedef'd
    1:  * here because all consumers need to see these declarations (and not just the
    1:  * typedef names, as would be the case for an opaque pointer-to-typedef'd-type
    1:  * declaration), along with cx->resolvingTable.
    1:  */
    1: typedef struct JSResolvingKey {
    1:     JSObject            *obj;
    1:     jsid                id;
    1: } JSResolvingKey;
    1: 
    1: typedef struct JSResolvingEntry {
    1:     JSDHashEntryHdr     hdr;
    1:     JSResolvingKey      key;
    1:     uint32              flags;
    1: } JSResolvingEntry;
    1: 
    1: #define JSRESFLAG_LOOKUP        0x1     /* resolving id from lookup */
    1: #define JSRESFLAG_WATCH         0x2     /* resolving id from watch */
    1: 
    1: typedef struct JSLocalRootChunk JSLocalRootChunk;
    1: 
    1: #define JSLRS_CHUNK_SHIFT       8
    1: #define JSLRS_CHUNK_SIZE        JS_BIT(JSLRS_CHUNK_SHIFT)
    1: #define JSLRS_CHUNK_MASK        JS_BITMASK(JSLRS_CHUNK_SHIFT)
    1: 
    1: struct JSLocalRootChunk {
    1:     jsval               roots[JSLRS_CHUNK_SIZE];
    1:     JSLocalRootChunk    *down;
    1: };
    1: 
    1: typedef struct JSLocalRootStack {
    1:     uint32              scopeMark;
    1:     uint32              rootCount;
    1:     JSLocalRootChunk    *topChunk;
    1:     JSLocalRootChunk    firstChunk;
    1: } JSLocalRootStack;
    1: 
    1: #define JSLRS_NULL_MARK ((uint32) -1)
    1: 
 3235: /*
 3235:  * Macros to push/pop JSTempValueRooter instances to context-linked stack of
 3235:  * temporary GC roots. If you need to protect a result value that flows out of
 3235:  * a C function across several layers of other functions, use the
 3235:  * js_LeaveLocalRootScopeWithResult internal API (see further below) instead.
 3235:  *
10448:  * The macros also provide a simple way to get a single rooted pointer via
10448:  * JS_PUSH_TEMP_ROOT_<KIND>(cx, NULL, &tvr). Then &tvr.u.<kind> gives the
10448:  * necessary pointer.
10448:  *
 3235:  * JSTempValueRooter.count defines the type of the rooted value referenced by
10448:  * JSTempValueRooter.u union of type JSTempValueUnion. When count is positive
10448:  * or zero, u.array points to a vector of jsvals. Otherwise it must be one of
10448:  * the following constants:
 3235:  */
10448: #define JSTVU_SINGLE        (-1)    /* u.value or u.<gcthing> is single jsval
10448:                                        or GC-thing */
10448: #define JSTVU_TRACE         (-2)    /* u.trace is a hook to trace a custom
10448:                                      * structure */
10448: #define JSTVU_SPROP         (-3)    /* u.sprop roots property tree node */
10448: #define JSTVU_WEAK_ROOTS    (-4)    /* u.weakRoots points to saved weak roots */
27012: #define JSTVU_COMPILER      (-5)    /* u.compiler roots JSCompiler* */
10448: #define JSTVU_SCRIPT        (-6)    /* u.script roots JSScript* */
    1: 
    1: /*
10448:  * Here single JSTVU_SINGLE covers both jsval and pointers to any GC-thing via
10448:  * reinterpreting the thing as JSVAL_OBJECT. It works because the GC-thing is
10448:  * aligned on a 0 mod 8 boundary, and object has the 0 jsval tag. So any
10448:  * GC-thing may be tagged as if it were an object and untagged, if it's then
10448:  * used only as an opaque pointer until discriminated by other means than tag
10448:  * bits. This is how, for example, js_GetGCThingTraceKind uses its |thing|
10448:  * parameter -- it consults GC-thing flags stored separately from the thing to
10448:  * decide the kind of thing.
    1:  */
10448: #define JS_PUSH_TEMP_ROOT_COMMON(cx,x,tvr,cnt,kind)                           \
    1:     JS_BEGIN_MACRO                                                            \
    1:         JS_ASSERT((cx)->tempValueRooters != (tvr));                           \
10448:         (tvr)->count = (cnt);                                                 \
10448:         (tvr)->u.kind = (x);                                                  \
    1:         (tvr)->down = (cx)->tempValueRooters;                                 \
    1:         (cx)->tempValueRooters = (tvr);                                       \
    1:     JS_END_MACRO
    1: 
    1: #define JS_POP_TEMP_ROOT(cx,tvr)                                              \
    1:     JS_BEGIN_MACRO                                                            \
    1:         JS_ASSERT((cx)->tempValueRooters == (tvr));                           \
    1:         (cx)->tempValueRooters = (tvr)->down;                                 \
    1:     JS_END_MACRO
    1: 
10448: #define JS_PUSH_TEMP_ROOT(cx,cnt,arr,tvr)                                     \
    1:     JS_BEGIN_MACRO                                                            \
10448:         JS_ASSERT((int)(cnt) >= 0);                                           \
10448:         JS_PUSH_TEMP_ROOT_COMMON(cx, arr, tvr, (ptrdiff_t) (cnt), array);     \
    1:     JS_END_MACRO
    1: 
10448: #define JS_PUSH_SINGLE_TEMP_ROOT(cx,val,tvr)                                  \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, val, tvr, JSTVU_SINGLE, value)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_OBJECT(cx,obj,tvr)                                  \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, obj, tvr, JSTVU_SINGLE, object)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_STRING(cx,str,tvr)                                  \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, str, tvr, JSTVU_SINGLE, string)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_XML(cx,xml_,tvr)                                    \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, xml_, tvr, JSTVU_SINGLE, xml)
10448: 
10448: #define JS_PUSH_TEMP_ROOT_TRACE(cx,trace_,tvr)                                \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, trace_, tvr, JSTVU_TRACE, trace)
10448: 
    1: #define JS_PUSH_TEMP_ROOT_SPROP(cx,sprop_,tvr)                                \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, sprop_, tvr, JSTVU_SPROP, sprop)
    1: 
    1: #define JS_PUSH_TEMP_ROOT_WEAK_COPY(cx,weakRoots_,tvr)                        \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, weakRoots_, tvr, JSTVU_WEAK_ROOTS, weakRoots)
    1: 
27012: #define JS_PUSH_TEMP_ROOT_COMPILER(cx,pc,tvr)                                 \
27012:     JS_PUSH_TEMP_ROOT_COMMON(cx, pc, tvr, JSTVU_COMPILER, compiler)
 3235: 
 7359: #define JS_PUSH_TEMP_ROOT_SCRIPT(cx,script_,tvr)                              \
10448:     JS_PUSH_TEMP_ROOT_COMMON(cx, script_, tvr, JSTVU_SCRIPT, script)
 7359: 
19712: 
19712: #define JSRESOLVE_INFER         0xffff  /* infer bits from current bytecode */
19712: 
    1: struct JSContext {
 9780:     /*
25087:      * If this flag is set, we were asked to call back the operation callback
25087:      * as soon as possible.
 9780:      */
25087:     volatile jsint      operationCallbackFlag;
    1: 
23092:     /* JSRuntime contextList linkage. */
23092:     JSCList             link;
23092: 
    1: #if JS_HAS_XML_SUPPORT
    1:     /*
    1:      * Bit-set formed from binary exponentials of the XML_* tiny-ids defined
    1:      * for boolean settings in jsxml.c, plus an XSF_CACHE_VALID bit.  Together
    1:      * these act as a cache of the boolean XML.ignore* and XML.prettyPrinting
    1:      * property values associated with this context's global object.
    1:      */
    1:     uint8               xmlSettingFlags;
18782:     uint8               padding;
18041: #else
18782:     uint16              padding;
    1: #endif
    1: 
18041:     /*
18308:      * Classic Algol "display" static link optimization.
18308:      */
27109: #define JS_DISPLAY_SIZE 16U
18308: 
18308:     JSStackFrame        *display[JS_DISPLAY_SIZE];
18308: 
    1:     /* Runtime version control identifier. */
    1:     uint16              version;
    1: 
    1:     /* Per-context options. */
    1:     uint32              options;            /* see jsapi.h for JSOPTION_* */
    1: 
    1:     /* Locale specific callbacks for string conversion. */
    1:     JSLocaleCallbacks   *localeCallbacks;
    1: 
    1:     /*
    1:      * cx->resolvingTable is non-null and non-empty if we are initializing
    1:      * standard classes lazily, or if we are otherwise recursing indirectly
    1:      * from js_LookupProperty through a JSClass.resolve hook.  It is used to
    1:      * limit runaway recursion (see jsapi.c and jsobj.c).
    1:      */
    1:     JSDHashTable        *resolvingTable;
    1: 
    1: #if JS_HAS_LVALUE_RETURN
    1:     /*
    1:      * Secondary return value from native method called on the left-hand side
    1:      * of an assignment operator.  The native should store the object in which
    1:      * to set a property in *rval, and return the property's id expressed as a
    1:      * jsval by calling JS_SetCallReturnValue2(cx, idval).
    1:      */
    1:     jsval               rval2;
    1:     JSPackedBool        rval2set;
    1: #endif
    1: 
    1:     /*
    1:      * True if generating an error, to prevent runaway recursion.
    1:      * NB: generatingError packs with rval2set, #if JS_HAS_LVALUE_RETURN;
    1:      * with insideGCMarkCallback and with throwing below.
    1:      */
    1:     JSPackedBool        generatingError;
    1: 
    1:     /* Flag to indicate that we run inside gcCallback(cx, JSGC_MARK_END). */
    1:     JSPackedBool        insideGCMarkCallback;
    1: 
    1:     /* Exception state -- the exception member is a GC root by definition. */
    1:     JSPackedBool        throwing;           /* is there a pending exception? */
    1:     jsval               exception;          /* most-recently-thrown exception */
    1: 
 5344:     /* Limit pointer for checking native stack consumption during recursion. */
    1:     jsuword             stackLimit;
    1: 
 5344:     /* Quota on the size of arenas used to compile and execute scripts. */
 5344:     size_t              scriptStackQuota;
 5344: 
    1:     /* Data shared by threads in an address space. */
    1:     JSRuntime           *runtime;
    1: 
    1:     /* Stack arena pool and frame pointer register. */
24499:     JS_REQUIRES_STACK
    1:     JSArenaPool         stackPool;
22652: 
22652:     JS_REQUIRES_STACK
    1:     JSStackFrame        *fp;
    1: 
    1:     /* Temporary arena pool used while compiling and decompiling. */
    1:     JSArenaPool         tempPool;
    1: 
    1:     /* Top-level object and pointer to top stack frame's scope chain. */
    1:     JSObject            *globalObject;
    1: 
    1:     /* Storage to root recently allocated GC things and script result. */
    1:     JSWeakRoots         weakRoots;
    1: 
    1:     /* Regular expression class statics (XXX not shared globally). */
    1:     JSRegExpStatics     regExpStatics;
    1: 
    1:     /* State for object and array toSource conversion. */
    1:     JSSharpObjectMap    sharpObjectMap;
    1: 
    1:     /* Argument formatter support for JS_{Convert,Push}Arguments{,VA}. */
    1:     JSArgumentFormatMap *argumentFormatMap;
    1: 
    1:     /* Last message string and trace file for debugging. */
    1:     char                *lastMessage;
    1: #ifdef DEBUG
    1:     void                *tracefp;
26954:     JSOp                tracePrevOp;
    1: #endif
    1: 
 9780:     /* Per-context optional error reporter. */
    1:     JSErrorReporter     errorReporter;
    1: 
25087:     /* Branch callback. */
 9780:     JSOperationCallback operationCallback;
 9780: 
    1:     /* Interpreter activation count. */
    1:     uintN               interpLevel;
    1: 
20312:     /* Client opaque pointers. */
    1:     void                *data;
20312:     void                *data2;
    1: 
    1:     /* GC and thread-safe state. */
    1:     JSStackFrame        *dormantFrameChain; /* dormant stack frame to scan */
    1: #ifdef JS_THREADSAFE
    1:     JSThread            *thread;
    1:     jsrefcount          requestDepth;
 7286:     /* Same as requestDepth but ignoring JS_SuspendRequest/JS_ResumeRequest */
 7286:     jsrefcount          outstandingRequests;
11739:     JSTitle             *titleToShare;      /* weak reference, see jslock.c */
11739:     JSTitle             *lockedSealedTitle; /* weak ref, for low-cost sealed
11739:                                                title locking */
    1:     JSCList             threadLinks;        /* JSThread contextList linkage */
    1: 
    1: #define CX_FROM_THREAD_LINKS(tl) \
    1:     ((JSContext *)((char *)(tl) - offsetof(JSContext, threadLinks)))
    1: #endif
    1: 
    1:     /* PDL of stack headers describing stack slots not rooted by argv, etc. */
    1:     JSStackHeader       *stackHeaders;
    1: 
    1:     /* Optional stack of heap-allocated scoped local GC roots. */
    1:     JSLocalRootStack    *localRootStack;
    1: 
    1:     /* Stack of thread-stack-allocated temporary GC roots. */
    1:     JSTempValueRooter   *tempValueRooters;
 2433: 
19699: #ifdef JS_THREADSAFE
19699:     JSGCFreeListSet     *gcLocalFreeLists;
19699: #endif
19699: 
12282:     /* List of pre-allocated doubles. */
12282:     JSGCDoubleCell      *doubleFreeList;
12282: 
 2433:     /* Debug hooks associated with the current context. */
 2433:     JSDebugHooks        *debugHooks;
18870: 
18870:     /* Security callbacks that override any defined on the runtime. */
18870:     JSSecurityCallbacks *securityCallbacks;
19196: 
19196:     /* Pinned regexp pool used for regular expressions. */
19196:     JSArenaPool         regexpPool;
19712: 
19712:     /* Stored here to avoid passing it around as a parameter. */
19712:     uintN               resolveFlags;
24598: 
24612: #ifdef JS_TRACER
24612:     /*
24612:      * State for the current tree execution.  bailExit is valid if the tree has
24612:      * called back into native code via a _FAIL builtin and has not yet bailed,
24612:      * else garbage (NULL in debug builds).
24612:      */
24612:     InterpState         *interpState;
24612:     VMSideExit          *bailExit;
24612: 
24612:     /*
24612:      * Used by _FAIL builtins; see jsbuiltins.h. The builtin sets the
24612:      * JSBUILTIN_BAILED bit if it bails off trace and the JSBUILTIN_ERROR bit
24612:      * if an error or exception occurred. Cleared on side exit.
24612:      */
24612:     uint32              builtinStatus;
24612: #endif
    1: };
    1: 
    1: #ifdef JS_THREADSAFE
    1: # define JS_THREAD_ID(cx)       ((cx)->thread ? (cx)->thread->id : 0)
    1: #endif
    1: 
    1: #ifdef __cplusplus
24293: 
24293: static inline JSAtom **
24293: FrameAtomBase(JSContext *cx, JSStackFrame *fp)
24293: {
24293:     return fp->imacpc
24293:            ? COMMON_ATOMS_START(&cx->runtime->atomState)
24293:            : fp->script->atomMap.vector;
24293: }
24293: 
    1: /* FIXME(bug 332648): Move this into a public header. */
    1: class JSAutoTempValueRooter
    1: {
    1:   public:
    1:     JSAutoTempValueRooter(JSContext *cx, size_t len, jsval *vec)
    1:         : mContext(cx) {
    1:         JS_PUSH_TEMP_ROOT(mContext, len, vec, &mTvr);
    1:     }
25094:     explicit JSAutoTempValueRooter(JSContext *cx, jsval v = JSVAL_NULL)
    1:         : mContext(cx) {
    1:         JS_PUSH_SINGLE_TEMP_ROOT(mContext, v, &mTvr);
    1:     }
23914:     JSAutoTempValueRooter(JSContext *cx, JSString *str)
23914:         : mContext(cx) {
23914:         JS_PUSH_TEMP_ROOT_STRING(mContext, str, &mTvr);
23914:     }
26238:     JSAutoTempValueRooter(JSContext *cx, JSObject *obj)
26238:         : mContext(cx) {
26238:         JS_PUSH_TEMP_ROOT_OBJECT(mContext, obj, &mTvr);
26238:     }
    1: 
    1:     ~JSAutoTempValueRooter() {
    1:         JS_POP_TEMP_ROOT(mContext, &mTvr);
    1:     }
    1: 
25094:     jsval value() { return mTvr.u.value; }
25094:     jsval *addr() { return &mTvr.u.value; }
25094: 
20444:   protected:
20444:     JSContext *mContext;
20444: 
    1:   private:
15009: #ifndef AIX
    1:     static void *operator new(size_t);
    1:     static void operator delete(void *, size_t);
15009: #endif
    1: 
    1:     JSTempValueRooter mTvr;
    1: };
19712: 
25094: class JSAutoTempIdRooter
25094: {
25094: public:
25094:     explicit JSAutoTempIdRooter(JSContext *cx, jsid id = INT_TO_JSID(0))
25094:         : mContext(cx) {
25094:         JS_PUSH_SINGLE_TEMP_ROOT(mContext, ID_TO_VALUE(id), &mTvr);
25094:     }
25094: 
25094:     ~JSAutoTempIdRooter() {
25094:         JS_POP_TEMP_ROOT(mContext, &mTvr);
25094:     }
25094: 
25094:     jsid id() { return (jsid) mTvr.u.value; }
25094:     jsid * addr() { return (jsid *) &mTvr.u.value; }
25094: 
25094: private:
25094:     JSContext *mContext;
25094:     JSTempValueRooter mTvr;
25094: };
25094: 
19712: class JSAutoResolveFlags
19712: {
19712:   public:
19712:     JSAutoResolveFlags(JSContext *cx, uintN flags)
19712:         : mContext(cx), mSaved(cx->resolveFlags) {
19712:         cx->resolveFlags = flags;
19712:     }
19712: 
19712:     ~JSAutoResolveFlags() { mContext->resolveFlags = mSaved; }
19712: 
19712:   private:
19712:     JSContext *mContext;
19712:     uintN mSaved;
19712: };
24293: 
24293: #endif /* __cpluscplus */
    1: 
    1: /*
    1:  * Slightly more readable macros for testing per-context option settings (also
    1:  * to hide bitset implementation detail).
    1:  *
    1:  * JSOPTION_XML must be handled specially in order to propagate from compile-
    1:  * to run-time (from cx->options to script->version/cx->version).  To do that,
    1:  * we copy JSOPTION_XML from cx->options into cx->version as JSVERSION_HAS_XML
    1:  * whenever options are set, and preserve this XML flag across version number
    1:  * changes done via the JS_SetVersion API.
    1:  *
    1:  * But when executing a script or scripted function, the interpreter changes
    1:  * cx->version, including the XML flag, to script->version.  Thus JSOPTION_XML
    1:  * is a compile-time option that causes a run-time version change during each
    1:  * activation of the compiled script.  That version change has the effect of
    1:  * changing JS_HAS_XML_OPTION, so that any compiling done via eval enables XML
    1:  * support.  If an XML-enabled script or function calls a non-XML function,
    1:  * the flag bit will be cleared during the callee's activation.
    1:  *
    1:  * Note that JS_SetVersion API calls never pass JSVERSION_HAS_XML or'd into
    1:  * that API's version parameter.
    1:  *
    1:  * Note also that script->version must contain this XML option flag in order
    1:  * for XDR'ed scripts to serialize and deserialize with that option preserved
    1:  * for detection at run-time.  We can't copy other compile-time options into
    1:  * script->version because that would break backward compatibility (certain
    1:  * other options, e.g. JSOPTION_VAROBJFIX, are analogous to JSOPTION_XML).
    1:  */
    1: #define JS_HAS_OPTION(cx,option)        (((cx)->options & (option)) != 0)
    1: #define JS_HAS_STRICT_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_STRICT)
    1: #define JS_HAS_WERROR_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_WERROR)
    1: #define JS_HAS_COMPILE_N_GO_OPTION(cx)  JS_HAS_OPTION(cx, JSOPTION_COMPILE_N_GO)
    1: #define JS_HAS_ATLINE_OPTION(cx)        JS_HAS_OPTION(cx, JSOPTION_ATLINE)
    1: 
    1: #define JSVERSION_MASK                  0x0FFF  /* see JSVersion in jspubtd.h */
    1: #define JSVERSION_HAS_XML               0x1000  /* flag induced by XML option */
24375: #define JSVERSION_ANONFUNFIX            0x2000  /* see jsapi.h, the comments
24375:                                                    for JSOPTION_ANONFUNFIX */
    1: 
 3164: #define JSVERSION_NUMBER(cx)            ((JSVersion)((cx)->version &          \
 3164:                                                      JSVERSION_MASK))
    1: #define JS_HAS_XML_OPTION(cx)           ((cx)->version & JSVERSION_HAS_XML || \
    1:                                          JSVERSION_NUMBER(cx) >= JSVERSION_1_6)
    1: 
    1: extern JSBool
26569: js_InitThreads(JSRuntime *rt);
    1: 
26569: extern void
26569: js_FinishThreads(JSRuntime *rt);
26569: 
26569: extern void
26569: js_PurgeThreads(JSContext *cx);
22627: 
22627: /*
24874:  * Ensures the JSOPTION_XML and JSOPTION_ANONFUNFIX bits of cx->options are
24874:  * reflected in cx->version, since each bit must travel with a script that has
24874:  * it set.
24874:  */
24874: extern void
24874: js_SyncOptionsToVersion(JSContext *cx);
24874: 
24874: /*
    1:  * Common subroutine of JS_SetVersion and js_SetVersion, to update per-context
    1:  * data that depends on version.
    1:  */
    1: extern void
    1: js_OnVersionChange(JSContext *cx);
    1: 
    1: /*
    1:  * Unlike the JS_SetVersion API, this function stores JSVERSION_HAS_XML and
    1:  * any future non-version-number flags induced by compiler options.
    1:  */
    1: extern void
    1: js_SetVersion(JSContext *cx, JSVersion version);
    1: 
    1: /*
    1:  * Create and destroy functions for JSContext, which is manually allocated
    1:  * and exclusively owned.
    1:  */
    1: extern JSContext *
    1: js_NewContext(JSRuntime *rt, size_t stackChunkSize);
    1: 
    1: extern void
    1: js_DestroyContext(JSContext *cx, JSDestroyContextMode mode);
    1: 
    1: /*
    1:  * Return true if cx points to a context in rt->contextList, else return false.
11739:  * NB: the caller (see jslock.c:ClaimTitle) must hold rt->gcLock.
    1:  */
    1: extern JSBool
    1: js_ValidContextPointer(JSRuntime *rt, JSContext *cx);
    1: 
23092: static JS_INLINE JSContext *
23092: js_ContextFromLinkField(JSCList *link)
23092: {
23092:     JS_ASSERT(link);
23092:     return (JSContext *) ((uint8 *) link - offsetof(JSContext, link));
23092: }
23092: 
    1: /*
    1:  * If unlocked, acquire and release rt->gcLock around *iterp update; otherwise
    1:  * the caller must be holding rt->gcLock.
    1:  */
23442: extern JSContext *
    1: js_ContextIterator(JSRuntime *rt, JSBool unlocked, JSContext **iterp);
    1: 
    1: /*
25087:  * Iterate through contexts with active requests. The caller must be holding
25087:  * rt->gcLock in case of a thread-safe build, or otherwise guarantee that the
25087:  * context list is not alternated asynchroniously.
25087:  */
25087: extern JS_FRIEND_API(JSContext *)
25087: js_NextActiveContext(JSRuntime *, JSContext *);
25087: 
25087: /*
    1:  * JSClass.resolve and watchpoint recursion damping machinery.
    1:  */
    1: extern JSBool
    1: js_StartResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
    1:                   JSResolvingEntry **entryp);
    1: 
    1: extern void
    1: js_StopResolving(JSContext *cx, JSResolvingKey *key, uint32 flag,
    1:                  JSResolvingEntry *entry, uint32 generation);
    1: 
    1: /*
    1:  * Local root set management.
    1:  *
    1:  * NB: the jsval parameters below may be properly tagged jsvals, or GC-thing
    1:  * pointers cast to (jsval).  This relies on JSObject's tag being zero, but
    1:  * on the up side it lets us push int-jsval-encoded scopeMark values on the
    1:  * local root stack.
    1:  */
    1: extern JSBool
    1: js_EnterLocalRootScope(JSContext *cx);
    1: 
    1: #define js_LeaveLocalRootScope(cx) \
    1:     js_LeaveLocalRootScopeWithResult(cx, JSVAL_NULL)
    1: 
    1: extern void
    1: js_LeaveLocalRootScopeWithResult(JSContext *cx, jsval rval);
    1: 
    1: extern void
    1: js_ForgetLocalRoot(JSContext *cx, jsval v);
    1: 
    1: extern int
    1: js_PushLocalRoot(JSContext *cx, JSLocalRootStack *lrs, jsval v);
    1: 
    1: extern void
  583: js_TraceLocalRoots(JSTracer *trc, JSLocalRootStack *lrs);
    1: 
    1: /*
    1:  * Report an exception, which is currently realized as a printf-style format
    1:  * string and its arguments.
    1:  */
    1: typedef enum JSErrNum {
    1: #define MSG_DEF(name, number, count, exception, format) \
    1:     name = number,
    1: #include "js.msg"
    1: #undef MSG_DEF
    1:     JSErr_Limit
    1: } JSErrNum;
    1: 
18543: extern JS_FRIEND_API(const JSErrorFormatString *)
    1: js_GetErrorMessage(void *userRef, const char *locale, const uintN errorNumber);
    1: 
    1: #ifdef va_start
    1: extern JSBool
    1: js_ReportErrorVA(JSContext *cx, uintN flags, const char *format, va_list ap);
    1: 
    1: extern JSBool
    1: js_ReportErrorNumberVA(JSContext *cx, uintN flags, JSErrorCallback callback,
    1:                        void *userRef, const uintN errorNumber,
    1:                        JSBool charArgs, va_list ap);
    1: 
    1: extern JSBool
    1: js_ExpandErrorArguments(JSContext *cx, JSErrorCallback callback,
    1:                         void *userRef, const uintN errorNumber,
    1:                         char **message, JSErrorReport *reportp,
    1:                         JSBool *warningp, JSBool charArgs, va_list ap);
    1: #endif
    1: 
    1: extern void
    1: js_ReportOutOfMemory(JSContext *cx);
    1: 
    1: /*
 8296:  * Report that cx->scriptStackQuota is exhausted.
 8296:  */
 8296: extern void
 8296: js_ReportOutOfScriptQuota(JSContext *cx);
 8296: 
 8296: extern void
 8296: js_ReportOverRecursed(JSContext *cx);
 8296: 
12983: extern void
12983: js_ReportAllocationOverflow(JSContext *cx);
12983: 
11139: #define JS_CHECK_RECURSION(cx, onerror)                                       \
11139:     JS_BEGIN_MACRO                                                            \
11139:         int stackDummy_;                                                      \
11139:                                                                               \
11139:         if (!JS_CHECK_STACK_SIZE(cx, stackDummy_)) {                          \
11139:             js_ReportOverRecursed(cx);                                        \
11139:             onerror;                                                          \
11139:         }                                                                     \
11139:     JS_END_MACRO
11139: 
 8296: /*
    1:  * Report an exception using a previously composed JSErrorReport.
    1:  * XXXbe remove from "friend" API
    1:  */
    1: extern JS_FRIEND_API(void)
    1: js_ReportErrorAgain(JSContext *cx, const char *message, JSErrorReport *report);
    1: 
    1: extern void
    1: js_ReportIsNotDefined(JSContext *cx, const char *name);
    1: 
    1: /*
 7897:  * Report an attempt to access the property of a null or undefined value (v).
 7897:  */
 7897: extern JSBool
 7897: js_ReportIsNullOrUndefined(JSContext *cx, intN spindex, jsval v,
 7897:                            JSString *fallback);
 7897: 
16519: extern void
16519: js_ReportMissingArg(JSContext *cx, jsval *vp, uintN arg);
16519: 
 7897: /*
    1:  * Report error using js_DecompileValueGenerator(cx, spindex, v, fallback) as
    1:  * the first argument for the error message. If the error message has less
    1:  * then 3 arguments, use null for arg1 or arg2.
    1:  */
    1: extern JSBool
    1: js_ReportValueErrorFlags(JSContext *cx, uintN flags, const uintN errorNumber,
    1:                          intN spindex, jsval v, JSString *fallback,
    1:                          const char *arg1, const char *arg2);
    1: 
    1: #define js_ReportValueError(cx,errorNumber,spindex,v,fallback)                \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, NULL, NULL))
    1: 
    1: #define js_ReportValueError2(cx,errorNumber,spindex,v,fallback,arg1)          \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, arg1, NULL))
    1: 
    1: #define js_ReportValueError3(cx,errorNumber,spindex,v,fallback,arg1,arg2)     \
    1:     ((void)js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,          \
    1:                                     spindex, v, fallback, arg1, arg2))
    1: 
    1: extern JSErrorFormatString js_ErrorFormatString[JSErr_Limit];
    1: 
    1: /*
    1:  * See JS_SetThreadStackLimit in jsapi.c, where we check that the stack grows
    1:  * in the expected direction.  On Unix-y systems, JS_STACK_GROWTH_DIRECTION is
    1:  * computed on the build host by jscpucfg.c and written into jsautocfg.h.  The
    1:  * macro is hardcoded in jscpucfg.h on Windows and Mac systems (for historical
    1:  * reasons pre-dating autoconf usage).
    1:  */
    1: #if JS_STACK_GROWTH_DIRECTION > 0
    1: # define JS_CHECK_STACK_SIZE(cx, lval)  ((jsuword)&(lval) < (cx)->stackLimit)
    1: #else
    1: # define JS_CHECK_STACK_SIZE(cx, lval)  ((jsuword)&(lval) > (cx)->stackLimit)
    1: #endif
    1: 
 9780: /*
25087:  * If the operation callback flag was set, call the operation callback.
 9780:  * This macro can run the full GC. Return true if it is OK to continue and
 9780:  * false otherwise.
 9780:  */
25087: #define JS_CHECK_OPERATION_LIMIT(cx) \
25087:     (!(cx)->operationCallbackFlag || js_InvokeOperationCallback(cx))
 9780: 
 9780: /*
25087:  * Invoke the operation callback and return false if the current execution
25087:  * is to be terminated.
    1:  */
    1: extern JSBool
25087: js_InvokeOperationCallback(JSContext *cx);
23726: 
25214: extern JSStackFrame *
25214: js_GetScriptedCaller(JSContext *cx, JSStackFrame *fp);
25214: 
26550: extern jsbytecode*
26550: js_GetCurrentBytecodePC(JSContext* cx);
26550: 
25214: #ifdef JS_TRACER
25214: /*
25214:  * Reconstruct the JS stack and clear cx->onTrace. We must be currently
25214:  * executing a _FAIL builtin from trace on cx. The machine code for the trace
25214:  * remains on the C stack when js_DeepBail returns.
25214:  *
25214:  * Implemented in jstracer.cpp.
25214:  */
25214: JS_FORCES_STACK JS_FRIEND_API(void)
25214: js_DeepBail(JSContext *cx);
25214: #endif
25214: 
25214: static JS_FORCES_STACK JS_INLINE void
25214: js_LeaveTrace(JSContext *cx)
25214: {
25214: #ifdef JS_TRACER
25214:     if (JS_ON_TRACE(cx))
25214:         js_DeepBail(cx);
25214: #endif
25214: }
25214: 
25214: static JS_INLINE JSBool
25214: js_CanLeaveTrace(JSContext *cx)
25214: {
25214:     JS_ASSERT(JS_ON_TRACE(cx));
25214: #ifdef JS_TRACER
25214:     return cx->bailExit != NULL;
25214: #else
25214:     return JS_FALSE;
25214: #endif
25214: }
25214: 
22652: /*
22652:  * Get the current cx->fp, first lazily instantiating stack frames if needed.
22652:  * (Do not access cx->fp directly except in JS_REQUIRES_STACK code.)
22652:  *
22652:  * Defined in jstracer.cpp if JS_TRACER is defined.
22652:  */
25214: static JS_FORCES_STACK JS_INLINE JSStackFrame *
25214: js_GetTopStackFrame(JSContext *cx)
25214: {
25214:     js_LeaveTrace(cx);
25214:     return cx->fp;
25214: }
22652: 
    1: JS_END_EXTERN_C
    1: 
    1: #endif /* jscntxt_h___ */
