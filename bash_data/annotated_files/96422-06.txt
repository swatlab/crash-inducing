95533: /* vim: set shiftwidth=2 tabstop=8 autoindent cindent expandtab: */
95533: /* ***** BEGIN LICENSE BLOCK *****
95533:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
95533:  *
95533:  * The contents of this file are subject to the Mozilla Public License Version
95533:  * 1.1 (the "License"); you may not use this file except in compliance with
95533:  * the License. You may obtain a copy of the License at
95533:  * http://www.mozilla.org/MPL/
95533:  *
95533:  * Software distributed under the License is distributed on an "AS IS" basis,
95533:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
95533:  * for the specific language governing rights and limitations under the
95533:  * License.
95533:  *
95533:  * The Original Code is the font size inflation manager.
95533:  *
95533:  * The Initial Developer of the Original Code is the Mozilla Foundation.
95533:  * Portions created by the Initial Developer are Copyright (C) 2012
95533:  * the Initial Developer. All Rights Reserved.
95533:  *
95533:  * Contributor(s):
95533:  *   L. David Baron <dbaron@dbaron.org>, Mozilla Corporation (original author)
95533:  *
95533:  * Alternatively, the contents of this file may be used under the terms of
95533:  * either the GNU General Public License Version 2 or later (the "GPL"), or
95533:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
95533:  * in which case the provisions of the GPL or the LGPL are applicable instead
95533:  * of those above. If you wish to allow use of your version of this file only
95533:  * under the terms of either the GPL or the LGPL, and not to allow others to
95533:  * use your version of this file under the terms of the MPL, indicate your
95533:  * decision by deleting the provisions above and replace them with the notice
95533:  * and other provisions required by the GPL or the LGPL. If you do not delete
95533:  * the provisions above, a recipient may use your version of this file under
95533:  * the terms of any one of the MPL, the GPL or the LGPL.
95533:  *
95533:  * ***** END LICENSE BLOCK ***** */
95533: 
95533: /* Per-block-formatting-context manager of font size inflation for pan and zoom UI. */
95533: 
95533: #include "nsFontInflationData.h"
95533: #include "FramePropertyTable.h"
95534: #include "nsTextFragment.h"
95534: #include "nsIFormControlFrame.h"
96178: #include "nsTextControlFrame.h"
96178: #include "nsListControlFrame.h"
96178: #include "nsComboboxControlFrame.h"
95534: #include "nsHTMLReflowState.h"
95534: #include "nsTextFrameUtils.h"
95533: 
95533: using namespace mozilla;
95534: using namespace mozilla::layout;
95533: 
95533: static void
95533: DestroyFontInflationData(void *aPropertyValue)
95533: {
95533:   delete static_cast<nsFontInflationData*>(aPropertyValue);
95533: }
95533: 
95533: NS_DECLARE_FRAME_PROPERTY(FontInflationDataProperty, DestroyFontInflationData);
95533: 
95533: /* static */ nsFontInflationData*
95533: nsFontInflationData::FindFontInflationDataFor(const nsIFrame *aFrame)
95533: {
95533:   // We have one set of font inflation data per block formatting context.
95533:   const nsIFrame *bfc = FlowRootFor(aFrame);
95534:   NS_ASSERTION(bfc->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
95534:                "should have found a flow root");
95533: 
95533:   return static_cast<nsFontInflationData*>(
95533:              bfc->Properties().Get(FontInflationDataProperty()));
95533: }
95534: 
95534: /* static */ void
95534: nsFontInflationData::UpdateFontInflationDataWidthFor(const nsHTMLReflowState& aReflowState)
95534: {
95534:   nsIFrame *bfc = aReflowState.frame;
95534:   NS_ASSERTION(bfc->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
95534:                "should have been given a flow root");
95534:   FrameProperties bfcProps(bfc->Properties());
95534:   nsFontInflationData *data = static_cast<nsFontInflationData*>(
95534:                                 bfcProps.Get(FontInflationDataProperty()));
95534:   if (!data) {
95534:     data = new nsFontInflationData(bfc);
95534:     bfcProps.Set(FontInflationDataProperty(), data);
95534:   }
95534: 
95534:   data->UpdateWidth(aReflowState);
95534: }
95534: 
95534: /* static */ void
95534: nsFontInflationData::MarkFontInflationDataTextDirty(nsIFrame *aBFCFrame)
95534: {
95534:   NS_ASSERTION(aBFCFrame->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
95534:                "should have been given a flow root");
95534: 
95534:   FrameProperties bfcProps(aBFCFrame->Properties());
95534:   nsFontInflationData *data = static_cast<nsFontInflationData*>(
95534:                                 bfcProps.Get(FontInflationDataProperty()));
95534:   if (data) {
95534:     data->MarkTextDirty();
95534:   }
95534: }
95534: 
95534: nsFontInflationData::nsFontInflationData(nsIFrame *aBFCFrame)
95534:   : mBFCFrame(aBFCFrame)
95534:   , mTextAmount(0)
95534:   , mTextThreshold(0)
95534:   , mInflationEnabled(false)
95534:   , mTextDirty(true)
95534: {
95534: }
95534: 
95534: /**
95534:  * Find the closest common ancestor between aFrame1 and aFrame2, except
95534:  * treating the parent of a frame as the first-in-flow of its parent (so
95534:  * the result doesn't change when breaking changes).
95534:  *
95534:  * aKnownCommonAncestor is a known common ancestor of both.
95534:  */
95534: static nsIFrame*
95534: NearestCommonAncestorFirstInFlow(nsIFrame *aFrame1, nsIFrame *aFrame2,
95534:                                  nsIFrame *aKnownCommonAncestor)
95534: {
95534:   aFrame1 = aFrame1->GetFirstInFlow();
95534:   aFrame2 = aFrame2->GetFirstInFlow();
95534:   aKnownCommonAncestor = aKnownCommonAncestor->GetFirstInFlow();
95534: 
95534:   nsAutoTArray<nsIFrame*, 32> ancestors1, ancestors2;
95534:   for (nsIFrame *f = aFrame1; f != aKnownCommonAncestor;
95534:        (f = f->GetParent()) && (f = f->GetFirstInFlow())) {
95534:     ancestors1.AppendElement(f);
95534:   }
95534:   for (nsIFrame *f = aFrame2; f != aKnownCommonAncestor;
95534:        (f = f->GetParent()) && (f = f->GetFirstInFlow())) {
95534:     ancestors2.AppendElement(f);
95534:   }
95534: 
95534:   nsIFrame *result = aKnownCommonAncestor;
95534:   PRUint32 i1 = ancestors1.Length(),
95534:            i2 = ancestors2.Length();
95534:   while (i1-- != 0 && i2-- != 0) {
95534:     if (ancestors1[i1] != ancestors2[i2]) {
95534:       break;
95534:     }
95534:     result = ancestors1[i1];
95534:   }
95534: 
95534:   return result;
95534: }
95534: 
95534: static nscoord
95534: ComputeDescendantWidth(const nsHTMLReflowState& aAncestorReflowState,
95534:                        nsIFrame *aDescendantFrame)
95534: {
95534:   nsIFrame *ancestorFrame = aAncestorReflowState.frame->GetFirstInFlow();
95534:   if (aDescendantFrame == ancestorFrame) {
95534:     return aAncestorReflowState.ComputedWidth();
95534:   }
95534: 
95534:   AutoInfallibleTArray<nsIFrame*, 16> frames;
95534:   for (nsIFrame *f = aDescendantFrame; f != ancestorFrame;
96196:        f = f->GetParent()->GetFirstInFlow()) {
95534:     frames.AppendElement(f);
95534:   }
95534: 
95534:   PRUint32 len = frames.Length();
95534:   nsHTMLReflowState *reflowStates = static_cast<nsHTMLReflowState*>
95534:                                 (moz_xmalloc(sizeof(nsHTMLReflowState) * len));
95534:   nsPresContext *presContext = aDescendantFrame->PresContext();
95534:   for (PRUint32 i = 0; i < len; ++i) {
95534:     const nsHTMLReflowState &parentReflowState =
95534:       (i == 0) ? aAncestorReflowState : reflowStates[i - 1];
95534:     nsSize availSize(parentReflowState.ComputedWidth(), NS_UNCONSTRAINEDSIZE);
95534:     nsIFrame *frame = frames[len - i - 1];
95534:     NS_ABORT_IF_FALSE(frame->GetParent()->GetFirstInFlow() ==
95534:                         parentReflowState.frame->GetFirstInFlow(),
95534:                       "bad logic in this function");
95534:     new (reflowStates + i) nsHTMLReflowState(presContext, parentReflowState,
95534:                                              frame, availSize);
95534:   }
95534: 
95534:   NS_ABORT_IF_FALSE(reflowStates[len - 1].frame == aDescendantFrame,
95534:                     "bad logic in this function");
95534:   nscoord result = reflowStates[len - 1].ComputedWidth();
95534: 
95534:   for (PRUint32 i = len; i-- != 0; ) {
95534:     reflowStates[i].~nsHTMLReflowState();
95534:   }
95534:   moz_free(reflowStates);
95534: 
95534:   return result;
95534: }
95534: 
95534: void
95534: nsFontInflationData::UpdateWidth(const nsHTMLReflowState &aReflowState)
95534: {
95534:   nsIFrame *bfc = aReflowState.frame;
95534:   NS_ASSERTION(bfc->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT,
95534:                "must be block formatting context");
95534: 
95534:   nsIFrame *firstInflatableDescendant =
95534:              FindEdgeInflatableFrameIn(bfc, eFromStart);
95534:   if (!firstInflatableDescendant) {
95534:     mTextAmount = 0;
95534:     mTextThreshold = 0; // doesn't matter
95534:     mTextDirty = false;
95534:     mInflationEnabled = false;
95534:     return;
95534:   }
95534:   nsIFrame *lastInflatableDescendant =
95534:              FindEdgeInflatableFrameIn(bfc, eFromEnd);
95534:   NS_ABORT_IF_FALSE(!firstInflatableDescendant == !lastInflatableDescendant,
95534:                     "null-ness should match; NearestCommonAncestorFirstInFlow"
95534:                     " will crash when passed null");
95534: 
95534:   // Particularly when we're computing for the root BFC, the width of
95534:   // nca might differ significantly for the width of bfc.
95534:   nsIFrame *nca = NearestCommonAncestorFirstInFlow(firstInflatableDescendant,
95534:                                                    lastInflatableDescendant,
95534:                                                    bfc);
95534:   while (!nsLayoutUtils::IsContainerForFontSizeInflation(nca)) {
96195:     nca = nca->GetParent()->GetFirstInFlow();
95534:   }
95534: 
95534:   nscoord newNCAWidth = ComputeDescendantWidth(aReflowState, nca);
95534: 
95534:   // See comment above "font.size.inflation.lineThreshold" in
95534:   // modules/libpref/src/init/all.js .
96422:   nsIPresShell* presShell = bfc->PresContext()->PresShell();
96422:   PRUint32 lineThreshold = presShell->FontSizeInflationLineThreshold();
95534:   nscoord newTextThreshold = (newNCAWidth * lineThreshold) / 100;
95534: 
95534:   if (mTextThreshold <= mTextAmount && mTextAmount < newTextThreshold) {
95534:     // Because we truncate our scan when we hit sufficient text, we now
95534:     // need to rescan.
95534:     mTextDirty = true;
95534:   }
95534: 
96284:   mNCAWidth = newNCAWidth;
95534:   mTextThreshold = newTextThreshold;
95534:   mInflationEnabled = mTextAmount >= mTextThreshold;
95534: }
95534: 
95534: /* static */ nsIFrame*
95534: nsFontInflationData::FindEdgeInflatableFrameIn(nsIFrame* aFrame,
95534:                                                SearchDirection aDirection)
95534: {
95534:   // NOTE: This function has a similar structure to ScanTextIn!
95534: 
95534:   // FIXME: Should probably only scan the text that's actually going to
95534:   // be inflated!
95534: 
95534:   nsIFormControlFrame* fcf = do_QueryFrame(aFrame);
95534:   if (fcf) {
95534:     return aFrame;
95534:   }
95534: 
95534:   // FIXME: aDirection!
95534:   nsAutoTArray<FrameChildList, 4> lists;
95534:   aFrame->GetChildLists(&lists);
95534:   for (PRUint32 i = 0, len = lists.Length(); i < len; ++i) {
95534:     const nsFrameList& list =
95534:       lists[(aDirection == eFromStart) ? i : len - i - 1].mList;
95534:     for (nsIFrame *kid = (aDirection == eFromStart) ? list.FirstChild()
95534:                                                     : list.LastChild();
95534:          kid;
95534:          kid = (aDirection == eFromStart) ? kid->GetNextSibling()
95534:                                           : kid->GetPrevSibling()) {
95534:       if (kid->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
95534:         // Goes in a different set of inflation data.
95534:         continue;
95534:       }
95534: 
95534:       if (kid->GetType() == nsGkAtoms::textFrame) {
95534:         nsIContent *content = kid->GetContent();
95534:         if (content && kid == content->GetPrimaryFrame()) {
95534:           PRUint32 len = nsTextFrameUtils::
95534:             ComputeApproximateLengthWithWhitespaceCompression(
95534:               content, kid->GetStyleText());
95534:           if (len != 0) {
95534:             return kid;
95534:           }
95534:         }
95534:       } else {
95534:         nsIFrame *kidResult =
95534:           FindEdgeInflatableFrameIn(kid, aDirection);
95534:         if (kidResult) {
95534:           return kidResult;
95534:         }
95534:       }
95534:     }
95534:   }
95534: 
95534:   return nsnull;
95534: }
95534: 
95534: void
95534: nsFontInflationData::ScanText()
95534: {
95534:   mTextDirty = false;
95534:   mTextAmount = 0;
95534:   ScanTextIn(mBFCFrame);
95534:   mInflationEnabled = mTextAmount >= mTextThreshold;
95534: }
95534: 
96178: static PRUint32
96178: DoCharCountOfLargestOption(nsIFrame *aContainer)
96178: {
96178:   PRUint32 result = 0;
96178:   for (nsIFrame* option = aContainer->GetFirstPrincipalChild();
96178:        option; option = option->GetNextSibling()) {
96178:     PRUint32 optionResult;
96178:     if (option->GetContent()->IsHTML(nsGkAtoms::optgroup)) {
96178:       optionResult = DoCharCountOfLargestOption(option);
96178:     } else {
96178:       // REVIEW: Check the frame structure for this!
96178:       optionResult = 0;
96178:       for (nsIFrame *optionChild = option->GetFirstPrincipalChild();
96178:            optionChild; optionChild = optionChild->GetNextSibling()) {
96178:         if (optionChild->GetType() == nsGkAtoms::textFrame) {
96178:           optionResult += nsTextFrameUtils::
96178:             ComputeApproximateLengthWithWhitespaceCompression(
96178:               optionChild->GetContent(), optionChild->GetStyleText());
96178:         }
96178:       }
96178:     }
96178:     if (optionResult > result) {
96178:       result = optionResult;
96178:     }
96178:   }
96178:   return result;
96178: }
96178: 
96178: static PRUint32
96178: CharCountOfLargestOption(nsIFrame *aListControlFrame)
96178: {
96178:   return DoCharCountOfLargestOption(
96178:     static_cast<nsListControlFrame*>(aListControlFrame)->GetOptionsContainer());
96178: }
96178: 
95534: void
95534: nsFontInflationData::ScanTextIn(nsIFrame *aFrame)
95534: {
95534:   // NOTE: This function has a similar structure to FindEdgeInflatableFrameIn!
95534: 
95534:   // FIXME: Should probably only scan the text that's actually going to
95534:   // be inflated!
95534: 
95534:   nsIFrame::ChildListIterator lists(aFrame);
95534:   for (; !lists.IsDone(); lists.Next()) {
95534:     nsFrameList::Enumerator kids(lists.CurrentList());
95534:     for (; !kids.AtEnd(); kids.Next()) {
95534:       nsIFrame *kid = kids.get();
95534:       if (kid->GetStateBits() & NS_FRAME_FONT_INFLATION_FLOW_ROOT) {
95534:         // Goes in a different set of inflation data.
95534:         continue;
95534:       }
95534: 
96178:       nsIAtom *fType = kid->GetType();
96178:       if (fType == nsGkAtoms::textFrame) {
95534:         nsIContent *content = kid->GetContent();
95534:         if (content && kid == content->GetPrimaryFrame()) {
95534:           PRUint32 len = nsTextFrameUtils::
95534:             ComputeApproximateLengthWithWhitespaceCompression(
95534:               content, kid->GetStyleText());
95534:           if (len != 0) {
95534:             nscoord fontSize = kid->GetStyleFont()->mFont.size;
95534:             if (fontSize > 0) {
95534:               mTextAmount += fontSize * len;
95534:             }
95534:           }
95534:         }
96178:       } else if (fType == nsGkAtoms::textInputFrame) {
96178:         // We don't want changes to the amount of text in a text input
96178:         // to change what we count towards inflation.
96178:         nscoord fontSize = kid->GetStyleFont()->mFont.size;
96178:         PRInt32 charCount = static_cast<nsTextControlFrame*>(kid)->GetCols();
96178:         mTextAmount += charCount * fontSize;
96178:       } else if (fType == nsGkAtoms::comboboxControlFrame) {
96178:         // See textInputFrame above (with s/amount of text/selected option/).
96178:         // Don't just recurse down to the list control inside, since we
96178:         // need to exclude the display frame.
96178:         nscoord fontSize = kid->GetStyleFont()->mFont.size;
96178:         PRInt32 charCount = CharCountOfLargestOption(
96178:           static_cast<nsComboboxControlFrame*>(kid)->GetDropDown());
96178:         mTextAmount += charCount * fontSize;
96178:       } else if (fType == nsGkAtoms::listControlFrame) {
96178:         // See textInputFrame above (with s/amount of text/selected option/).
96178:         nscoord fontSize = kid->GetStyleFont()->mFont.size;
96178:         PRInt32 charCount = CharCountOfLargestOption(kid);
96178:         mTextAmount += charCount * fontSize;
95534:       } else {
95534:         // recursive step
95534:         ScanTextIn(kid);
95534:       }
95534: 
95534:       if (mTextAmount >= mTextThreshold) {
95534:         return;
95534:       }
95534:     }
95534:   }
95534: }
