     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: // vim:cindent:ts=2:et:sw=2:
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * construction of a frame tree that is nearly isomorphic to the content
     1:  * tree and updating of that tree in response to dynamic changes
     1:  */
     1: 
126025: #include "mozilla/DebugOnly.h"
120353: #include "mozilla/Likely.h"
125820: #include "mozilla/LinkedList.h"
 80467: 
     1: #include "nsCSSFrameConstructor.h"
125899: #include "nsAbsoluteContainingBlock.h"
     1: #include "nsCRT.h"
     1: #include "nsIAtom.h"
     1: #include "nsIURL.h"
     1: #include "nsHashtable.h"
     1: #include "nsIHTMLDocument.h"
     1: #include "nsIStyleRule.h"
     1: #include "nsIFrame.h"
     1: #include "nsGkAtoms.h"
     1: #include "nsPresContext.h"
     1: #include "nsILinkHandler.h"
     1: #include "nsIDocument.h"
     1: #include "nsTableFrame.h"
     1: #include "nsTableColGroupFrame.h"
     1: #include "nsTableColFrame.h"
     1: #include "nsIDOMHTMLDocument.h"
     1: #include "nsIDOMHTMLTableColElement.h"
     1: #include "nsIDOMHTMLTableCaptionElem.h"
     1: #include "nsHTMLParts.h"
     1: #include "nsIPresShell.h"
 33262: #include "nsUnicharUtils.h"
     1: #include "nsStyleSet.h"
127607: #include "nsViewManager.h"
 68780: #include "nsEventStates.h"
     1: #include "nsStyleConsts.h"
     1: #include "nsTableOuterFrame.h"
     1: #include "nsIDOMXULElement.h"
 86231: #include "nsContainerFrame.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsIDOMHTMLSelectElement.h"
     1: #include "nsIDOMHTMLLegendElement.h"
     1: #include "nsIComboboxControlFrame.h"
     1: #include "nsIListControlFrame.h"
     1: #include "nsISelectControlFrame.h"
     1: #include "nsIDOMCharacterData.h"
     1: #include "nsIDOMHTMLImageElement.h"
     1: #include "nsPlaceholderFrame.h"
     1: #include "nsTableRowGroupFrame.h"
     1: #include "nsStyleChangeList.h"
     1: #include "nsIFormControl.h"
     1: #include "nsCSSAnonBoxes.h"
     1: #include "nsTextFragment.h"
     1: #include "nsIAnonymousContentCreator.h"
     1: #include "nsLegendFrame.h"
     1: #include "nsIContentIterator.h"
     1: #include "nsBoxLayoutState.h"
     1: #include "nsBindingManager.h"
     1: #include "nsXBLBinding.h"
     1: #include "nsITheme.h"
     1: #include "nsContentCID.h"
     1: #include "nsContentUtils.h"
  7189: #include "nsIScriptError.h"
     1: #include "nsIDocShell.h"
     1: #include "nsIDocShellTreeItem.h"
     1: #include "nsObjectFrame.h"
     1: #include "nsRuleNode.h"
     1: #include "nsIDOMMutationEvent.h"
     1: #include "nsChildIterator.h"
     1: #include "nsCSSRendering.h"
108290: #include "nsError.h"
     1: #include "nsLayoutUtils.h"
     1: #include "nsAutoPtr.h"
     1: #include "nsBoxFrame.h"
 73636: #include "nsBoxLayout.h"
     1: #include "nsImageFrame.h"
     1: #include "nsIObjectLoadingContent.h"
  3645: #include "nsIPrincipal.h"
 11845: #include "nsStyleUtil.h"
     1: #include "nsBox.h"
 24551: #include "nsTArray.h"
 27311: #include "nsGenericDOMDataNode.h"
 41930: #include "mozilla/dom/Element.h"
 47753: #include "FrameLayerBuilder.h"
 75018: #include "nsAutoLayoutPhase.h"
101252: #include "nsCSSRenderingBorders.h"
101252: #include "nsRenderingContext.h"
107226: #include "nsStyleStructInlines.h"
125555: #include "nsAnimationManager.h"
125555: #include "nsTransitionManager.h"
129543: #include <algorithm>
     1: 
     1: #ifdef MOZ_XUL
     1: #include "nsIRootBox.h"
     1: #include "nsIDOMXULCommandDispatcher.h"
     1: #include "nsIDOMXULDocument.h"
     1: #include "nsIXULDocument.h"
     1: #endif
103020: #ifdef MOZ_FLEXBOX
103020: #include "nsFlexContainerFrame.h"
103020: #endif
     1: #ifdef ACCESSIBILITY
 61464: #include "nsAccessibilityService.h"
     1: #endif
     1: 
     1: #include "nsInlineFrame.h"
     1: #include "nsBlockFrame.h"
     1: 
     1: #include "nsIScrollableFrame.h"
     1: 
 99253: #include "nsXBLService.h"
     1: 
     1: #undef NOISY_FIRST_LETTER
     1: 
     1: #include "nsMathMLParts.h"
 82586: #include "nsIDOMSVGFilters.h"
 86429: #include "DOMSVGTests.h"
 19948: #include "nsSVGEffects.h"
132157: #include "nsSVGTextFrame2.h"
121211: #include "nsSVGTextPathFrame.h"
 24030: #include "nsSVGUtils.h"
     1: 
 50698: #include "nsRefreshDriver.h"
 64158: #include "nsRuleProcessorData.h"
113744: #include "sampler.h"
 50698: 
 39965: using namespace mozilla;
 41634: using namespace mozilla::dom;
 39965: 
 77155: // An alias for convenience.
 77155: static const nsIFrame::ChildListID kPrincipalList = nsIFrame::kPrincipalList;
 77155: 
     1: nsIFrame*
     1: NS_NewHTMLCanvasFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
 15751: #if defined(MOZ_MEDIA)
 15751: nsIFrame*
 15751: NS_NewHTMLVideoFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
 15751: #endif
 15751: 
 29052: #include "nsSVGTextContainerFrame.h"
132160: #include "nsSVGTextFrame2.h"
     1: 
     1: nsIFrame*
 23953: NS_NewSVGOuterSVGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
103952: NS_NewSVGOuterSVGAnonChildFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
103952: nsIFrame*
 23953: NS_NewSVGInnerSVGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGPathGeometryFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGGFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGGenericContainerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGForeignObjectFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGAFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGGlyphFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGSwitchFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 15895: nsIFrame*
 23953: NS_NewSVGTextFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
132160: NS_NewSVGTextFrame2(nsIPresShell* aPresShell, nsStyleContext* aContext);
132160: nsIFrame*
 23953: NS_NewSVGTSpanFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGContainerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGUseFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
111533: nsIFrame*
111533: NS_NewSVGViewFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: extern nsIFrame*
 23953: NS_NewSVGLinearGradientFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
     1: extern nsIFrame*
 23953: NS_NewSVGRadialGradientFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
     1: extern nsIFrame*
 23953: NS_NewSVGStopFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGMarkerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: extern nsIFrame*
 23953: NS_NewSVGImageFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGClipPathFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGTextPathFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGFilterFrame(nsIPresShell *aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGPatternFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23953: NS_NewSVGMaskFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 82586: NS_NewSVGFEContainerFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 82586: nsIFrame*
 82586: NS_NewSVGFELeafFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 82586: nsIFrame*
 82586: NS_NewSVGFEImageFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 82586: nsIFrame*
 82586: NS_NewSVGFEUnstyledLeafFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: #include "nsIScrollable.h"
 94340: #include "nsINodeInfo.h"
     1: #include "prenv.h"
     1: #include "nsWidgetsCID.h"
     1: #include "nsNodeInfoManager.h"
     1: #include "nsContentCreatorFunctions.h"
     1: #include "nsIServiceManager.h"
     1: 
     1: #ifdef DEBUG
     1: // Set the environment variable GECKO_FRAMECTOR_DEBUG_FLAGS to one or
     1: // more of the following flags (comma separated) for handy debug
     1: // output.
 79445: static bool gNoisyContentUpdates = false;
 79445: static bool gReallyNoisyContentUpdates = false;
 79445: static bool gNoisyInlineConstruction = false;
     1: 
     1: struct FrameCtorDebugFlags {
     1:   const char* name;
 79445:   bool* on;
     1: };
     1: 
     1: static FrameCtorDebugFlags gFlags[] = {
     1:   { "content-updates",              &gNoisyContentUpdates },
     1:   { "really-noisy-content-updates", &gReallyNoisyContentUpdates },
 36653:   { "noisy-inline",                 &gNoisyInlineConstruction }
     1: };
     1: 
     1: #define NUM_DEBUG_FLAGS (sizeof(gFlags) / sizeof(gFlags[0]))
     1: #endif
     1: 
     1: 
     1: #ifdef MOZ_XUL
     1: #include "nsMenuFrame.h"
 38004: #include "nsMenuPopupFrame.h"
     1: #include "nsPopupSetFrame.h"
     1: #include "nsTreeColFrame.h"
     1: #include "nsIBoxObject.h"
     1: #include "nsPIListBoxObject.h"
     1: #include "nsListBoxBodyFrame.h"
     1: #include "nsListItemFrame.h"
 23176: #include "nsXULLabelFrame.h"
     1: 
     1: //------------------------------------------------------------------
     1: 
     1: nsIFrame*
     1: NS_NewAutoRepeatBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewRootBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewDocElementBoxFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewThumbFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
 23947: NS_NewDeckFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewLeafBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
 23947: NS_NewStackFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewProgressMeterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
132802: NS_NewRangeFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
132802: 
132802: nsIFrame*
     1: NS_NewImageBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewTextBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewGroupBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewButtonBoxFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewSplitterFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewMenuPopupFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewPopupSetFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
108991: NS_NewMenuFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, uint32_t aFlags);
     1: 
     1: nsIFrame*
     1: NS_NewMenuBarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewTreeBodyFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: // grid
     1: nsresult
 73636: NS_NewGridLayout2 ( nsIPresShell* aPresShell, nsBoxLayout** aNewLayout );
     1: nsIFrame*
 23947: NS_NewGridRowLeafFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: nsIFrame*
 23947: NS_NewGridRowGroupFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: // end grid
     1: 
     1: nsIFrame*
     1: NS_NewTitleBarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewResizerFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: 
     1: #endif
     1: 
     1: nsIFrame*
 79445: NS_NewHTMLScrollFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, bool aIsRoot);
     1: 
     1: nsIFrame*
 79445: NS_NewXULScrollFrame (nsIPresShell* aPresShell, nsStyleContext* aContext, bool aIsRoot);
     1: 
     1: nsIFrame*
     1: NS_NewSliderFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewScrollbarFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: nsIFrame*
     1: NS_NewScrollbarButtonFrame (nsIPresShell* aPresShell, nsStyleContext* aContext);
     1: 
     1: 
     1: #ifdef NOISY_FINDFRAME
108991: static int32_t FFWC_totalCount=0;
108991: static int32_t FFWC_doLoop=0;
108991: static int32_t FFWC_doSibling=0;
108991: static int32_t FFWC_recursions=0;
108991: static int32_t FFWC_nextInFlows=0;
     1: #endif
     1: 
103019: #ifdef MOZ_FLEXBOX
103019: // Returns true if aFrame is an anonymous flex item
103019: static inline bool
103019: IsAnonymousFlexItem(const nsIFrame* aFrame)
103019: {
132768:   const nsIAtom* pseudoType = aFrame->StyleContext()->GetPseudo();
103019:   return pseudoType == nsCSSAnonBoxes::anonymousFlexItem;
103019: }
103019: #endif // MOZ_FLEXBOX
103019: 
     1: static inline nsIFrame*
 23176: GetFieldSetBlockFrame(nsIFrame* aFieldsetFrame)
     1: {
     1:   // Depends on the fieldset child frame order - see ConstructFieldSetFrame() below.
 77154:   nsIFrame* firstChild = aFieldsetFrame->GetFirstPrincipalChild();
     1:   return firstChild && firstChild->GetNextSibling() ? firstChild->GetNextSibling() : firstChild;
     1: }
     1: 
 30785: #define FCDATA_DECL(_flags, _func)                          \
106838:   { _flags, { (FrameCreationFunc)_func }, nullptr, nullptr }
 90621: #define FCDATA_WITH_WRAPPING_BLOCK(_flags, _func, _anon_box)  \
 90621:   { _flags | FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS,        \
106838:       { (FrameCreationFunc)_func }, nullptr, &_anon_box }
 30785: 
     1: //----------------------------------------------------------------------
     1: 
  4696: /**
  4696:  * True if aFrame is an actual inline frame in the sense of non-replaced
  4696:  * display:inline CSS boxes.  In other words, it can be affected by {ib}
  4696:  * splitting and can contain first-letter frames.  Basically, this is either an
  4696:  * inline frame (positioned or otherwise) or an line frame (this last because
  4696:  * it can contain first-letter and because inserting blocks in the middle of it
  4696:  * needs to terminate it).
  4696:  */
 79445: static bool
  4696: IsInlineFrame(const nsIFrame* aFrame)
  4696: {
  4696:   return aFrame->IsFrameOfType(nsIFrame::eLineParticipant);
     1: }
     1: 
  7189: /**
107479:  * True if aFrame is an instance of an SVG frame class or is an inline/block
107479:  * frame being used for SVG text.
107479:  */
107479: static bool
107479: IsFrameForSVG(const nsIFrame* aFrame)
107479: {
107479:   return aFrame->IsFrameOfType(nsIFrame::eSVG) ||
107479:          aFrame->IsSVGText();
107479: }
107479: 
107479: /**
103018:  * Returns true iff aFrame explicitly prevents its descendants from floating
103018:  * (at least, down to the level of descendants which themselves are
103018:  * float-containing blocks -- those will manage the floating status of any
103018:  * lower-level descendents inside them, of course).
103018:  */
103018: static bool
103018: ShouldSuppressFloatingOfDescendants(nsIFrame* aFrame)
103018: {
103018:   return aFrame->IsFrameOfType(nsIFrame::eMathML) ||
103018:     aFrame->IsBoxFrame() ||
103018:     aFrame->GetType() == nsGkAtoms::flexContainerFrame;
103018: }
103018: 
103018: /**
  7189:  * If any children require a block parent, return the first such child.
  7189:  * Otherwise return null.
  7189:  */
  7189: static nsIContent*
  7189: AnyKidsNeedBlockParent(nsIFrame *aFrameList)
  7189: {
  7189:   for (nsIFrame *k = aFrameList; k; k = k->GetNextSibling()) {
  7189:     // Line participants, such as text and inline frames, can't be
  7189:     // directly inside a XUL box; they must be wrapped in an
  7189:     // intermediate block.
  7189:     if (k->IsFrameOfType(nsIFrame::eLineParticipant)) {
  7189:       return k->GetContent();
  7189:     }
  7189:   }
106838:   return nullptr;
  7189: }
  7189: 
  7189: // Reparent a frame into a wrapper frame that is a child of its old parent.
  7189: static void
  7189: ReparentFrame(nsFrameManager* aFrameManager,
  7189:               nsIFrame* aNewParentFrame,
  7189:               nsIFrame* aFrame)
  7189: {
  7189:   aFrame->SetParent(aNewParentFrame);
 40137:   aFrameManager->ReparentStyleContext(aFrame);
  7189: }
  7189: 
 30785: static void
 30785: ReparentFrames(nsFrameManager* aFrameManager,
 30785:                nsIFrame* aNewParentFrame,
 30785:                const nsFrameList& aFrameList)
 30785: {
 30785:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
 30785:     ReparentFrame(aFrameManager, aNewParentFrame, e.get());
 30785:   }
 30785: }
 30785: 
     1: //----------------------------------------------------------------------
  5324: //
  5324: // When inline frames get weird and have block frames in them, we
  5324: // annotate them to help us respond to incremental content changes
  5324: // more easily.
  5324: 
 79445: static inline bool
  5324: IsFrameSpecial(nsIFrame* aFrame)
  5324: {
  5324:   return (aFrame->GetStateBits() & NS_FRAME_IS_SPECIAL) != 0;
  5324: }
  5324: 
  5324: static nsIFrame* GetSpecialSibling(nsIFrame* aFrame)
  5324: {
 34459:   NS_PRECONDITION(IsFrameSpecial(aFrame), "Shouldn't call this");
 34459: 
  5324:   // We only store the "special sibling" annotation with the first
  5324:   // frame in the continuation chain. Walk back to find that frame now.
 39965:   return static_cast<nsIFrame*>
 34459:     (aFrame->GetFirstContinuation()->
 39965:        Properties().Get(nsIFrame::IBSplitSpecialSibling()));
 34459: }
 34459: 
 34459: static nsIFrame* GetSpecialPrevSibling(nsIFrame* aFrame)
 34459: {
 34459:   NS_PRECONDITION(IsFrameSpecial(aFrame), "Shouldn't call this");
  5324:   
  5324:   // We only store the "special sibling" annotation with the first
  5324:   // frame in the continuation chain. Walk back to find that frame now.  
 39965:   return static_cast<nsIFrame*>
  5324:     (aFrame->GetFirstContinuation()->
 39965:        Properties().Get(nsIFrame::IBSplitSpecialPrevSibling()));
  5324: }
  5324: 
  5324: static nsIFrame*
 79445: GetLastSpecialSibling(nsIFrame* aFrame, bool aReturnEmptyTrailingInline)
  5324: {
  5324:   for (nsIFrame *frame = aFrame, *next; ; frame = next) {
  5324:     next = GetSpecialSibling(frame);
 25738:     if (!next ||
 77154:         (!aReturnEmptyTrailingInline && !next->GetFirstPrincipalChild() &&
 34462:          !GetSpecialSibling(next))) {
107226:       NS_ASSERTION(!next || !frame->IsInlineOutside(),
 34462:                    "Should have a block here!");
  5324:       return frame;
  5324:     }
 34462:   }
  5324:   NS_NOTREACHED("unreachable code");
106838:   return nullptr;
  5324: }
  5324: 
  5324: static void
  5324: SetFrameIsSpecial(nsIFrame* aFrame, nsIFrame* aSpecialSibling)
  5324: {
  5324:   NS_PRECONDITION(aFrame, "bad args!");
  5324: 
 34459:   // We should be the only continuation
 28217:   NS_ASSERTION(!aFrame->GetPrevContinuation(),
 28217:                "assigning special sibling to other than first continuation!");
 34462:   NS_ASSERTION(!aFrame->GetNextContinuation() ||
 34462:                IsFrameSpecial(aFrame->GetNextContinuation()),
 34462:                "should have no non-special continuations here");
 34459: 
 34459:   // Mark the frame as "special".
 34459:   aFrame->AddStateBits(NS_FRAME_IS_SPECIAL);
 34459: 
 34459:   if (aSpecialSibling) {
 34459:     NS_ASSERTION(!aSpecialSibling->GetPrevContinuation(),
 34459:                  "assigning something other than the first continuation as the "
 34459:                  "special sibling");
  5324: 
  5324:     // Store the "special sibling" (if we were given one) with the
  5324:     // first frame in the flow.
 39965:     FramePropertyTable* props = aFrame->PresContext()->PropertyTable();
 39965:     props->Set(aFrame, nsIFrame::IBSplitSpecialSibling(), aSpecialSibling);
 39965:     props->Set(aSpecialSibling, nsIFrame::IBSplitSpecialPrevSibling(), aFrame);
  5324:   }
  5324: }
  5324: 
  5324: static nsIFrame*
  5324: GetIBContainingBlockFor(nsIFrame* aFrame)
  5324: {
  5324:   NS_PRECONDITION(IsFrameSpecial(aFrame),
  5324:                   "GetIBContainingBlockFor() should only be called on known IB frames");
  5324: 
  5324:   // Get the first "normal" ancestor of the target frame.
  5324:   nsIFrame* parentFrame;
  5324:   do {
  5324:     parentFrame = aFrame->GetParent();
  5324: 
  5324:     if (! parentFrame) {
  5324:       NS_ERROR("no unsplit block frame in IB hierarchy");
  5324:       return aFrame;
  5324:     }
  5324: 
  5324:     // Note that we ignore non-special frames which have a pseudo on their
  5324:     // style context -- they're not the frames we're looking for!  In
  5324:     // particular, they may be hiding a real parent that _is_ special.
  5324:     if (!IsFrameSpecial(parentFrame) &&
132768:         !parentFrame->StyleContext()->GetPseudo())
  5324:       break;
  5324: 
  5324:     aFrame = parentFrame;
  5324:   } while (1);
  5324:  
  5324:   // post-conditions
  5324:   NS_ASSERTION(parentFrame, "no normal ancestor found for special frame in GetIBContainingBlockFor");
  5324:   NS_ASSERTION(parentFrame != aFrame, "parentFrame is actually the child frame - bogus reslt");
  5324: 
  5324:   return parentFrame;
  5324: }
  5324: 
  5324: //----------------------------------------------------------------------
     1: 
     1: // Block/inline frame construction logic. We maintain a few invariants here:
     1: //
     1: // 1. Block frames contain block and inline frames.
     1: //
     1: // 2. Inline frames only contain inline frames. If an inline parent has a block
     1: // child then the block child is migrated upward until it lands in a block
     1: // parent (the inline frames containing block is where it will end up).
     1: 
 30789: // After this function returns, aLink is pointing to the first link at or
 30789: // after its starting position for which the next frame is a block.  If there
 30789: // is no such link, it points to the end of the list.
 30789: static void
 30789: FindFirstBlock(nsFrameList::FrameLinkEnumerator& aLink)
 30789: {
 30789:   for ( ; !aLink.AtEnd(); aLink.Next()) {
107226:     if (!aLink.NextFrame()->IsInlineOutside()) {
 30789:       return;
 30789:     }
 30789:   }
 30789: }
 30789: 
 34462: // This function returns a frame link enumerator pointing to the first link in
 34462: // the list for which the next frame is not block.  If there is no such link,
 34462: // it points to the end of the list.
 30789: static nsFrameList::FrameLinkEnumerator
 34462: FindFirstNonBlock(const nsFrameList& aList)
 34462: {
 34462:   nsFrameList::FrameLinkEnumerator link(aList);
 34462:   for (; !link.AtEnd(); link.Next()) {
107226:     if (link.NextFrame()->IsInlineOutside()) {
 34462:       break;
 34462:     }
 34462:   }
 34462:   return link;
     1: }
     1: 
 30790: inline void
 30790: SetInitialSingleChild(nsIFrame* aParent, nsIFrame* aFrame)
 30790: {
 30790:   NS_PRECONDITION(!aFrame->GetNextSibling(), "Should be using a frame list");
 32846:   nsFrameList temp(aFrame, aFrame);
 77155:   aParent->SetInitialChildList(kPrincipalList, temp);
 30790: }
 30790: 
     1: // -----------------------------------------------------------
     1: 
 32843: // Structure used when constructing formatting object trees.
 32843: struct nsFrameItems : public nsFrameList
 32843: {
 32843:   // Appends the frame to the end of the list
 32843:   void AddChild(nsIFrame* aChild);
 32843: };
     1: 
     1: void 
     1: nsFrameItems::AddChild(nsIFrame* aChild)
     1: {
 32843:   NS_PRECONDITION(aChild, "nsFrameItems::AddChild");
 32843: 
 77155:   // It'd be really nice if we could just AppendFrames(kPrincipalList, aChild) here,
 32843:   // but some of our callers put frames that have different
 30785:   // parents (caption, I'm looking at you) on the same framelist, and
 30785:   // nsFrameList asserts if you try to do that.
 30785:   if (IsEmpty()) {
 32843:     SetFrames(aChild);
 32843:   }
 32843:   else {
 32843:     NS_ASSERTION(aChild != mLastChild,
     1:                  "Same frame being added to frame list twice?");
 32843:     mLastChild->SetNextSibling(aChild);
 32843:     mLastChild = nsLayoutUtils::GetLastSibling(aChild);
 32843:   }
     1: }
     1: 
     1: // -----------------------------------------------------------
     1: 
     1: // Structure used when constructing formatting object trees. Contains
     1: // state information needed for absolutely positioned elements
     1: struct nsAbsoluteItems : nsFrameItems {
     1:   // containing block for absolutely positioned elements
     1:   nsIFrame* containingBlock;
     1:   
     1:   nsAbsoluteItems(nsIFrame* aContainingBlock);
     1: #ifdef DEBUG
     1:   // XXXbz Does this need a debug-only assignment operator that nulls out the
     1:   // childList in the nsAbsoluteItems we're copying?  Introducing a difference
     1:   // between debug and non-debug behavior seems bad, so I guess not...
     1:   ~nsAbsoluteItems() {
 30785:     NS_ASSERTION(!FirstChild(),
     1:                  "Dangling child list.  Someone forgot to insert it?");
     1:   }
     1: #endif
     1:   
     1:   // Appends the frame to the end of the list
     1:   void AddChild(nsIFrame* aChild);
     1: };
     1: 
     1: nsAbsoluteItems::nsAbsoluteItems(nsIFrame* aContainingBlock)
     1:   : containingBlock(aContainingBlock)
     1: {
     1: }
     1: 
     1: // Additional behavior is that it sets the frame's NS_FRAME_OUT_OF_FLOW flag
     1: void
     1: nsAbsoluteItems::AddChild(nsIFrame* aChild)
     1: {
   238:   NS_ASSERTION(aChild->PresContext()->FrameManager()->
     1:                GetPlaceholderFrameFor(aChild),
     1:                "Child without placeholder being added to nsAbsoluteItems?");
     1:   aChild->AddStateBits(NS_FRAME_OUT_OF_FLOW);
     1:   nsFrameItems::AddChild(aChild);
     1: }
     1: 
     1: // -----------------------------------------------------------
     1: 
     1: // Structure for saving the existing state when pushing/poping containing
     1: // blocks. The destructor restores the state to its previous state
 25768: class NS_STACK_CLASS nsFrameConstructorSaveState {
     1: public:
 77154:   typedef nsIFrame::ChildListID ChildListID;
     1:   nsFrameConstructorSaveState();
     1:   ~nsFrameConstructorSaveState();
     1: 
     1: private:
     1:   nsAbsoluteItems* mItems;      // pointer to struct whose data we save/restore
     1:   nsAbsoluteItems  mSavedItems; // copy of original data
     1: 
     1:   // The name of the child list in which our frames would belong
 77154:   ChildListID mChildListID;
     1:   nsFrameConstructorState* mState;
     1: 
129231:   // State used only when we're saving the abs-pos state for a transformed
129231:   // element.
129231:   nsAbsoluteItems mSavedFixedItems;
129231: 
129231:   bool mSavedFixedPosIsAbsPos;
129231: 
     1:   friend class nsFrameConstructorState;
     1: };
     1: 
 34614: // Structure used to keep track of a list of bindings we need to call
 34614: // AddToAttachedQueue on.  These should be in post-order depth-first
 34614: // flattened tree traversal order.
125820: struct PendingBinding : public LinkedListElement<PendingBinding>
 34614: {
 34614: #ifdef NS_BUILD_REFCNT_LOGGING
 34614:   PendingBinding() {
 34614:     MOZ_COUNT_CTOR(PendingBinding);
 34614:   }
 34614:   ~PendingBinding() {
 34614:     MOZ_COUNT_DTOR(PendingBinding);
 34614:   }
 34614: #endif
 34614: 
 34614:   nsRefPtr<nsXBLBinding> mBinding;
 34614: };
 34614: 
     1: // Structure used for maintaining state information during the
     1: // frame construction process
 15599: class NS_STACK_CLASS nsFrameConstructorState {
     1: public:
 77154:   typedef nsIFrame::ChildListID ChildListID;
 77154: 
     1:   nsPresContext            *mPresContext;
     1:   nsIPresShell             *mPresShell;
     1:   nsFrameManager           *mFrameManager;
     1: 
     1: #ifdef MOZ_XUL
 77154:   // Frames destined for the kPopupList.
     1:   nsAbsoluteItems           mPopupItems;
     1: #endif
     1: 
     1:   // Containing block information for out-of-flow frames.
     1:   nsAbsoluteItems           mFixedItems;
     1:   nsAbsoluteItems           mAbsoluteItems;
     1:   nsAbsoluteItems           mFloatedItems;
 19214: 
 28329:   nsCOMPtr<nsILayoutHistoryState> mFrameState;
 28329:   // These bits will be added to the state bits of any frame we construct
 28329:   // using this state.
 28329:   nsFrameState              mAdditionalStateBits;
 28329: 
 19214:   // When working with the -moz-transform property, we want to hook
 19214:   // the abs-pos and fixed-pos lists together, since transformed
 19214:   // elements are fixed-pos containing blocks.  This flag determines
 19214:   // whether or not we want to wire the fixed-pos and abs-pos lists
 19214:   // together.
 79445:   bool                      mFixedPosIsAbsPos;
 25768: 
 25768:   // A boolean to indicate whether we have a "pending" popupgroup.  That is, we
 25768:   // have already created the FrameConstructionItem for the root popupgroup but
 25768:   // we have not yet created the relevant frame.
 79445:   bool                      mHavePendingPopupgroup;
 19214: 
 56439:   // If false (which is the default) then call SetPrimaryFrame() as needed
 56439:   // during frame construction.  If true, don't make any SetPrimaryFrame()
 74643:   // calls, except for generated content which doesn't have a primary frame
 80486:   // yet.  The mCreatingExtraFrames == true mode is meant to be used for
 41931:   // construction of random "extra" frames for elements via normal frame
 41931:   // construction APIs (e.g. replication of things across pages in paginated
 41931:   // mode).
 79445:   bool                      mCreatingExtraFrames;
 41931: 
 31438:   nsCOMArray<nsIContent>    mGeneratedTextNodesWithInitializer;
 31438: 
 64158:   TreeMatchContext          mTreeMatchContext;
 64158: 
     1:   // Constructor
     1:   // Use the passed-in history state.
     1:   nsFrameConstructorState(nsIPresShell*          aPresShell,
     1:                           nsIFrame*              aFixedContainingBlock,
     1:                           nsIFrame*              aAbsoluteContainingBlock,
     1:                           nsIFrame*              aFloatContainingBlock,
     1:                           nsILayoutHistoryState* aHistoryState);
     1:   // Get the history state from the pres context's pres shell.
     1:   nsFrameConstructorState(nsIPresShell*          aPresShell,
     1:                           nsIFrame*              aFixedContainingBlock,
     1:                           nsIFrame*              aAbsoluteContainingBlock,
     1:                           nsIFrame*              aFloatContainingBlock);
     1: 
     1:   ~nsFrameConstructorState();
     1:   
     1:   // Function to push the existing absolute containing block state and
     1:   // create a new scope. Code that uses this function should get matching
     1:   // logic in GetAbsoluteContainingBlock.
129231:   // Also makes aNewAbsoluteContainingBlock the containing block for
129231:   // fixed-pos elements if necessary.
     1:   void PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
     1:                                    nsFrameConstructorSaveState& aSaveState);
     1: 
     1:   // Function to push the existing float containing block state and
     1:   // create a new scope. Code that uses this function should get matching
     1:   // logic in GetFloatContainingBlock.
     1:   // Pushing a null float containing block forbids any frames from being
     1:   // floated until a new float containing block is pushed.
     1:   // XXX we should get rid of null float containing blocks and teach the
     1:   // various frame classes to deal with floats instead.
     1:   void PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
 23352:                                 nsFrameConstructorSaveState& aSaveState);
     1: 
     1:   // Function to return the proper geometric parent for a frame with display
     1:   // struct given by aStyleDisplay and parent's frame given by
 23944:   // aContentParentFrame.
     1:   nsIFrame* GetGeometricParent(const nsStyleDisplay* aStyleDisplay,
 94107:                                nsIFrame* aContentParentFrame) const;
     1: 
     1:   /**
     1:    * Function to add a new frame to the right frame list.  This MUST be called
     1:    * on frames before their children have been processed if the frames might
     1:    * conceivably be out-of-flow; otherwise cleanup in error cases won't work
     1:    * right.  Also, this MUST be called on frames after they have been
     1:    * initialized.
     1:    * @param aNewFrame the frame to add
     1:    * @param aFrameItems the list to add in-flow frames to
     1:    * @param aContent the content pointer for aNewFrame
  7807:    * @param aStyleContext the style context resolved for aContent
     1:    * @param aParentFrame the parent frame for the content if it were in-flow
     1:    * @param aCanBePositioned pass false if the frame isn't allowed to be
     1:    *        positioned
     1:    * @param aCanBeFloated pass false if the frame isn't allowed to be
     1:    *        floated
     1:    * @param aIsOutOfFlowPopup pass true if the frame is an out-of-flow popup
     1:    *        (XUL-only)
     1:    * @throws NS_ERROR_OUT_OF_MEMORY if it happens.
     1:    * @note If this method throws, that means that aNewFrame was not inserted
     1:    *       into any frame lists.  Furthermore, this method will handle cleanup
 36646:    *       of aNewFrame (via calling Destroy() on it).
     1:    */
     1:   nsresult AddChild(nsIFrame* aNewFrame,
     1:                     nsFrameItems& aFrameItems,
     1:                     nsIContent* aContent,
     1:                     nsStyleContext* aStyleContext,
     1:                     nsIFrame* aParentFrame,
 79445:                     bool aCanBePositioned = true,
 79445:                     bool aCanBeFloated = true,
 79445:                     bool aIsOutOfFlowPopup = false,
 79445:                     bool aInsertAfter = false,
106838:                     nsIFrame* aInsertAfterFrame = nullptr);
     1: 
 19214:   /**
 19214:    * Function to return the fixed-pos element list.  Normally this will just hand back the
 19214:    * fixed-pos element list, but in case we're dealing with a transformed element that's
 19214:    * acting as an abs-pos and fixed-pos container, we'll hand back the abs-pos list.  Callers should
 19214:    * use this function if they want to get the list acting as the fixed-pos item parent.
 19214:    */
 19214:   nsAbsoluteItems& GetFixedItems()
 19214:   {
 19214:     return mFixedPosIsAbsPos ? mAbsoluteItems : mFixedItems;
 19214:   }
 19214:   const nsAbsoluteItems& GetFixedItems() const
 19214:   {
 19214:     return mFixedPosIsAbsPos ? mAbsoluteItems : mFixedItems;
 19214:   }
 19214: 
 34614: 
 34614:   /**
 34614:    * class to automatically push and pop a pending binding in the frame
 34614:    * constructor state.  See nsCSSFrameConstructor::FrameConstructionItem
 34614:    * mPendingBinding documentation.
 34614:    */
 34614:   class PendingBindingAutoPusher;
 34614:   friend class PendingBindingAutoPusher;
 34614:   class NS_STACK_CLASS PendingBindingAutoPusher {
 34614:   public:
 34614:     PendingBindingAutoPusher(nsFrameConstructorState& aState,
 34614:                              PendingBinding* aPendingBinding) :
 34614:       mState(aState),
 34614:       mPendingBinding(aState.mCurrentPendingBindingInsertionPoint)
 34614:         {
 34614:           if (aPendingBinding) {
 34614:             aState.mCurrentPendingBindingInsertionPoint = aPendingBinding;
 34614:           }
 34614:         }
 34614: 
 34614:     ~PendingBindingAutoPusher()
 34614:       {
 34614:         mState.mCurrentPendingBindingInsertionPoint = mPendingBinding;
 34614:       }
 34614: 
 34614:   private:
 34614:     nsFrameConstructorState& mState;
125820:     PendingBinding* mPendingBinding;
 34614:   };
 34614: 
 34614:   /**
 34614:    * Add a new pending binding to the list
 34614:    */
 34614:   void AddPendingBinding(PendingBinding* aPendingBinding) {
125820:     if (mCurrentPendingBindingInsertionPoint) {
125820:       mCurrentPendingBindingInsertionPoint->setPrevious(aPendingBinding);
125820:     } else {
125820:       mPendingBindings.insertBack(aPendingBinding);
125820:     }
 34614:   }
 34614: 
     1: protected:
     1:   friend class nsFrameConstructorSaveState;
     1: 
     1:   /**
     1:    * ProcessFrameInsertions takes the frames in aFrameItems and adds them as
 77154:    * kids to the aChildListID child list of |aFrameItems.containingBlock|.
     1:    */
     1:   void ProcessFrameInsertions(nsAbsoluteItems& aFrameItems,
 77154:                               ChildListID aChildListID);
 34614: 
 34614:   // Our list of all pending bindings.  When we're done, we need to call
 34614:   // AddToAttachedQueue on all of them, in order.
125820:   LinkedList<PendingBinding> mPendingBindings;
125820: 
125820:   PendingBinding* mCurrentPendingBindingInsertionPoint;
     1: };
     1: 
     1: nsFrameConstructorState::nsFrameConstructorState(nsIPresShell*          aPresShell,
     1:                                                  nsIFrame*              aFixedContainingBlock,
     1:                                                  nsIFrame*              aAbsoluteContainingBlock,
     1:                                                  nsIFrame*              aFloatContainingBlock,
     1:                                                  nsILayoutHistoryState* aHistoryState)
     1:   : mPresContext(aPresShell->GetPresContext()),
     1:     mPresShell(aPresShell),
     1:     mFrameManager(aPresShell->FrameManager()),
     1: #ifdef MOZ_XUL    
106838:     mPopupItems(nullptr),
     1: #endif
     1:     mFixedItems(aFixedContainingBlock),
     1:     mAbsoluteItems(aAbsoluteContainingBlock),
     1:     mFloatedItems(aFloatContainingBlock),
 22341:     // See PushAbsoluteContaningBlock below
 28329:     mFrameState(aHistoryState),
 28329:     mAdditionalStateBits(0),
130516:     // If the fixed-pos containing block is equal to the abs-pos containing
130516:     // block, use the abs-pos containing block's abs-pos list for fixed-pos
130516: 	// frames.
130516:     mFixedPosIsAbsPos(aFixedContainingBlock == aAbsoluteContainingBlock),
 80486:     mHavePendingPopupgroup(false),
 80486:     mCreatingExtraFrames(false),
 80486:     mTreeMatchContext(true, nsRuleWalker::eRelevantLinkUnvisited,
 64158:                       aPresShell->GetDocument()),
125820:     mCurrentPendingBindingInsertionPoint(nullptr)
     1: {
 23951: #ifdef MOZ_XUL
 23951:   nsIRootBox* rootBox = nsIRootBox::GetRootBox(aPresShell);
 23951:   if (rootBox) {
 23951:     mPopupItems.containingBlock = rootBox->GetPopupSetFrame();
 23951:   }
 23951: #endif
  5327:   MOZ_COUNT_CTOR(nsFrameConstructorState);
     1: }
     1: 
     1: nsFrameConstructorState::nsFrameConstructorState(nsIPresShell* aPresShell,
     1:                                                  nsIFrame*     aFixedContainingBlock,
     1:                                                  nsIFrame*     aAbsoluteContainingBlock,
     1:                                                  nsIFrame*     aFloatContainingBlock)
     1:   : mPresContext(aPresShell->GetPresContext()),
     1:     mPresShell(aPresShell),
     1:     mFrameManager(aPresShell->FrameManager()),
     1: #ifdef MOZ_XUL    
106838:     mPopupItems(nullptr),
     1: #endif
     1:     mFixedItems(aFixedContainingBlock),
     1:     mAbsoluteItems(aAbsoluteContainingBlock),
     1:     mFloatedItems(aFloatContainingBlock),
 22341:     // See PushAbsoluteContaningBlock below
 28329:     mAdditionalStateBits(0),
130516:     // If the fixed-pos containing block is equal to the abs-pos containing
130516:     // block, use the abs-pos containing block's abs-pos list for fixed-pos
130516: 	// frames.
130516:     mFixedPosIsAbsPos(aFixedContainingBlock == aAbsoluteContainingBlock),
 80486:     mHavePendingPopupgroup(false),
 80486:     mCreatingExtraFrames(false),
 80486:     mTreeMatchContext(true, nsRuleWalker::eRelevantLinkUnvisited,
 64158:                       aPresShell->GetDocument()),
125820:     mCurrentPendingBindingInsertionPoint(nullptr)
     1: {
 23951: #ifdef MOZ_XUL
 23951:   nsIRootBox* rootBox = nsIRootBox::GetRootBox(aPresShell);
 23951:   if (rootBox) {
 23951:     mPopupItems.containingBlock = rootBox->GetPopupSetFrame();
 23951:   }
 23951: #endif
  5327:   MOZ_COUNT_CTOR(nsFrameConstructorState);
     1:   mFrameState = aPresShell->GetDocument()->GetLayoutHistoryState();
     1: }
     1: 
     1: nsFrameConstructorState::~nsFrameConstructorState()
     1: {
     1:   // Frame order comparison functions only work properly when the placeholders
     1:   // have been inserted into the frame tree. So for example if we have a new float
     1:   // containing the placeholder for a new abs-pos frame, and we process the abs-pos
     1:   // insertion first, then we won't be able to find the right place to insert in
     1:   // in the abs-pos list. So put floats in first, because they can contain placeholders
     1:   // for abs-pos and fixed-pos items whose containing blocks are outside the floats.
     1:   // Then put abs-pos frames in, because they can contain placeholders for fixed-pos
     1:   // items whose containing block is outside the abs-pos frames. 
  5327:   MOZ_COUNT_DTOR(nsFrameConstructorState);
 77154:   ProcessFrameInsertions(mFloatedItems, nsIFrame::kFloatList);
 77154:   ProcessFrameInsertions(mAbsoluteItems, nsIFrame::kAbsoluteList);
 77154:   ProcessFrameInsertions(mFixedItems, nsIFrame::kFixedList);
     1: #ifdef MOZ_XUL
 77154:   ProcessFrameInsertions(mPopupItems, nsIFrame::kPopupList);
     1: #endif
108991:   for (int32_t i = mGeneratedTextNodesWithInitializer.Count() - 1; i >= 0; --i) {
 31438:     mGeneratedTextNodesWithInitializer[i]->
 31438:       DeleteProperty(nsGkAtoms::genConInitializerProperty);
 31438:   }
125820:   if (!mPendingBindings.isEmpty()) {
 34614:     nsBindingManager* bindingManager = mPresShell->GetDocument()->BindingManager();
 34614:     do {
125820:       nsAutoPtr<PendingBinding> pendingBinding;
125820:       pendingBinding = mPendingBindings.popFirst();
 34614:       bindingManager->AddToAttachedQueue(pendingBinding->mBinding);
125820:     } while (!mPendingBindings.isEmpty());
125820:     mCurrentPendingBindingInsertionPoint = nullptr;
 34614:   }
     1: }
     1: 
     1: static nsIFrame*
  7680: AdjustAbsoluteContainingBlock(nsIFrame* aContainingBlockIn)
     1: {
     1:   if (!aContainingBlockIn) {
106838:     return nullptr;
     1:   }
     1:   
  7680:   // Always use the container's first continuation. (Inline frames can have
  7680:   // non-fluid bidi continuations...)
  7680:   return aContainingBlockIn->GetFirstContinuation();
     1: }
     1: 
     1: void
     1: nsFrameConstructorState::PushAbsoluteContainingBlock(nsIFrame* aNewAbsoluteContainingBlock,
     1:                                                      nsFrameConstructorSaveState& aSaveState)
     1: {
     1:   aSaveState.mItems = &mAbsoluteItems;
     1:   aSaveState.mSavedItems = mAbsoluteItems;
 77154:   aSaveState.mChildListID = nsIFrame::kAbsoluteList;
     1:   aSaveState.mState = this;
 19214:   aSaveState.mSavedFixedPosIsAbsPos = mFixedPosIsAbsPos;
 19214: 
129231:   if (mFixedPosIsAbsPos) {
129231:     // Since we're going to replace mAbsoluteItems, we need to save it into
129231:     // mFixedItems now (and save the current value of mFixedItems).
129231:     aSaveState.mSavedFixedItems = mFixedItems;
129231:     mFixedItems = mAbsoluteItems;
129231:   }
129231: 
     1:   mAbsoluteItems = 
  7680:     nsAbsoluteItems(AdjustAbsoluteContainingBlock(aNewAbsoluteContainingBlock));
 19214: 
 19214:   /* See if we're wiring the fixed-pos and abs-pos lists together.  This happens iff
 19214:    * we're a transformed element.
 19214:    */
127106:   mFixedPosIsAbsPos = aNewAbsoluteContainingBlock &&
132812:     aNewAbsoluteContainingBlock->StyleDisplay()->HasTransform(aNewAbsoluteContainingBlock);
 79482: 
 79483:   if (aNewAbsoluteContainingBlock) {
 79482:     aNewAbsoluteContainingBlock->MarkAsAbsoluteContainingBlock();
 69409:   }
 79483: }
     1: 
     1: void
     1: nsFrameConstructorState::PushFloatContainingBlock(nsIFrame* aNewFloatContainingBlock,
 23352:                                                   nsFrameConstructorSaveState& aSaveState)
 23352: {
     1:   NS_PRECONDITION(!aNewFloatContainingBlock ||
 23352:                   aNewFloatContainingBlock->IsFloatContainingBlock(),
     1:                   "Please push a real float containing block!");
     1:   aSaveState.mItems = &mFloatedItems;
     1:   aSaveState.mSavedItems = mFloatedItems;
 77154:   aSaveState.mChildListID = nsIFrame::kFloatList;
     1:   aSaveState.mState = this;
     1:   mFloatedItems = nsAbsoluteItems(aNewFloatContainingBlock);
     1: }
     1: 
     1: nsIFrame*
     1: nsFrameConstructorState::GetGeometricParent(const nsStyleDisplay* aStyleDisplay,
 94107:                                             nsIFrame* aContentParentFrame) const
     1: {
     1:   NS_PRECONDITION(aStyleDisplay, "Must have display struct!");
     1: 
     1:   // If there is no container for a fixed, absolute, or floating root
     1:   // frame, we will ignore the positioning.  This hack is originally
     1:   // brought to you by the letter T: tables, since other roots don't
     1:   // even call into this code.  See bug 178855.
     1:   //
     1:   // XXX Disabling positioning in this case is a hack.  If one was so inclined,
     1:   // one could support this either by (1) inserting a dummy block between the
     1:   // table and the canvas or (2) teaching the canvas how to reflow positioned
     1:   // elements. (1) has the usual problems when multiple frames share the same
     1:   // content (notice all the special cases in this file dealing with inner
     1:   // tables and outer tables which share the same content). (2) requires some
     1:   // work and possible factoring.
     1:   //
     1:   // XXXbz couldn't we just force position to "static" on roots and
     1:   // float to "none"?  That's OK per CSS 2.1, as far as I can tell.
     1:   
107224:   if (aContentParentFrame && aContentParentFrame->IsSVGText()) {
107224:     return aContentParentFrame;
107224:   }
107224: 
107224:   if (aStyleDisplay->IsFloatingStyle() && mFloatedItems.containingBlock) {
107225:     NS_ASSERTION(!aStyleDisplay->IsAbsolutelyPositionedStyle(),
     1:                  "Absolutely positioned _and_ floating?");
     1:     return mFloatedItems.containingBlock;
     1:   }
     1: 
     1:   if (aStyleDisplay->mPosition == NS_STYLE_POSITION_ABSOLUTE &&
     1:       mAbsoluteItems.containingBlock) {
     1:     return mAbsoluteItems.containingBlock;
     1:   }
     1: 
     1:   if (aStyleDisplay->mPosition == NS_STYLE_POSITION_FIXED &&
 19214:       GetFixedItems().containingBlock) {
 19214:     return GetFixedItems().containingBlock;
     1:   }
     1: 
     1:   return aContentParentFrame;
     1: }
     1: 
     1: nsresult
     1: nsFrameConstructorState::AddChild(nsIFrame* aNewFrame,
     1:                                   nsFrameItems& aFrameItems,
     1:                                   nsIContent* aContent,
     1:                                   nsStyleContext* aStyleContext,
     1:                                   nsIFrame* aParentFrame,
 79445:                                   bool aCanBePositioned,
 79445:                                   bool aCanBeFloated,
 79445:                                   bool aIsOutOfFlowPopup,
 79445:                                   bool aInsertAfter,
     1:                                   nsIFrame* aInsertAfterFrame)
     1: {
 30785:   NS_PRECONDITION(!aNewFrame->GetNextSibling(), "Shouldn't happen");
 30785:   
132812:   const nsStyleDisplay* disp = aNewFrame->StyleDisplay();
  7807:   
     1:   // The comments in GetGeometricParent regarding root table frames
     1:   // all apply here, unfortunately.
     1: 
 79445:   bool needPlaceholder = false;
 34912:   nsFrameState placeholderType;
     1:   nsFrameItems* frameItems = &aFrameItems;
     1: #ifdef MOZ_XUL
120353:   if (MOZ_UNLIKELY(aIsOutOfFlowPopup)) {
     1:       NS_ASSERTION(aNewFrame->GetParent() == mPopupItems.containingBlock,
     1:                    "Popup whose parent is not the popup containing block?");
     1:       NS_ASSERTION(mPopupItems.containingBlock, "Must have a popup set frame!");
 80486:       needPlaceholder = true;
     1:       frameItems = &mPopupItems;
 34912:       placeholderType = PLACEHOLDER_FOR_POPUP;
     1:   }
     1:   else
     1: #endif // MOZ_XUL
107224:   if (aCanBeFloated && aNewFrame->IsFloating() &&
     1:       mFloatedItems.containingBlock) {
     1:     NS_ASSERTION(aNewFrame->GetParent() == mFloatedItems.containingBlock,
     1:                  "Float whose parent is not the float containing block?");
 80486:     needPlaceholder = true;
     1:     frameItems = &mFloatedItems;
 34912:     placeholderType = PLACEHOLDER_FOR_FLOAT;
     1:   }
     1:   else if (aCanBePositioned) {
  8199:     if (disp->mPosition == NS_STYLE_POSITION_ABSOLUTE &&
     1:         mAbsoluteItems.containingBlock) {
     1:       NS_ASSERTION(aNewFrame->GetParent() == mAbsoluteItems.containingBlock,
     1:                    "Abs pos whose parent is not the abs pos containing block?");
 80486:       needPlaceholder = true;
     1:       frameItems = &mAbsoluteItems;
 34912:       placeholderType = PLACEHOLDER_FOR_ABSPOS;
     1:     }
  8199:     if (disp->mPosition == NS_STYLE_POSITION_FIXED &&
 19214:         GetFixedItems().containingBlock) {
 19214:       NS_ASSERTION(aNewFrame->GetParent() == GetFixedItems().containingBlock,
     1:                    "Fixed pos whose parent is not the fixed pos containing block?");
 80486:       needPlaceholder = true;
 19214:       frameItems = &GetFixedItems();
 34912:       placeholderType = PLACEHOLDER_FOR_FIXEDPOS;
     1:     }
     1:   }
     1: 
     1:   if (needPlaceholder) {
     1:     NS_ASSERTION(frameItems != &aFrameItems,
     1:                  "Putting frame in-flow _and_ want a placeholder?");
     1:     nsIFrame* placeholderFrame;
     1:     nsresult rv =
     1:       nsCSSFrameConstructor::CreatePlaceholderFrameFor(mPresShell,
     1:                                                        aContent,
     1:                                                        aNewFrame,
     1:                                                        aStyleContext,
     1:                                                        aParentFrame,
106838:                                                        nullptr,
 34912:                                                        placeholderType,
     1:                                                        &placeholderFrame);
     1:     if (NS_FAILED(rv)) {
     1:       // Note that aNewFrame could be the top frame for a scrollframe setup,
     1:       // hence already set as the primary frame.  So we have to clean up here.
     1:       // But it shouldn't have any out-of-flow kids.
     1:       // XXXbz Maybe add a utility function to assert that?
     1:       aNewFrame->Destroy();
     1:       return rv;
     1:     }
     1: 
 16976:     placeholderFrame->AddStateBits(mAdditionalStateBits);
     1:     // Add the placeholder frame to the flow
     1:     aFrameItems.AddChild(placeholderFrame);
     1:   }
     1: #ifdef DEBUG
     1:   else {
     1:     NS_ASSERTION(aNewFrame->GetParent() == aParentFrame,
     1:                  "In-flow frame has wrong parent");
     1:   }
     1: #endif
     1: 
     1:   if (aInsertAfter) {
106838:     frameItems->InsertFrame(nullptr, aInsertAfterFrame, aNewFrame);
     1:   } else {
     1:     frameItems->AddChild(aNewFrame);
     1:   }
     1:   
     1:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsFrameConstructorState::ProcessFrameInsertions(nsAbsoluteItems& aFrameItems,
 77154:                                                 ChildListID aChildListID)
     1: {
     1: #define NS_NONXUL_LIST_TEST (&aFrameItems == &mFloatedItems &&            \
 77154:                              aChildListID == nsIFrame::kFloatList)    ||  \
     1:                             (&aFrameItems == &mAbsoluteItems &&           \
 77154:                              aChildListID == nsIFrame::kAbsoluteList) ||  \
     1:                             (&aFrameItems == &mFixedItems &&              \
 77154:                              aChildListID == nsIFrame::kFixedList)
     1: #ifdef MOZ_XUL
     1:   NS_PRECONDITION(NS_NONXUL_LIST_TEST ||
     1:                   (&aFrameItems == &mPopupItems &&
 77154:                    aChildListID == nsIFrame::kPopupList), 
 77154:                   "Unexpected aFrameItems/aChildListID combination");
     1: #else
     1:   NS_PRECONDITION(NS_NONXUL_LIST_TEST,
 77154:                   "Unexpected aFrameItems/aChildListID combination");
     1: #endif
     1: 
 30785:   if (aFrameItems.IsEmpty()) {
     1:     return;
     1:   }
     1:   
     1:   nsIFrame* containingBlock = aFrameItems.containingBlock;
     1: 
     1:   NS_ASSERTION(containingBlock,
     1:                "Child list without containing block?");
     1: 
132252:   if (aChildListID == nsIFrame::kFixedList) {
132252:     // Put this frame on the transformed-frame's abs-pos list instead, if
132252:     // it has abs-pos children instead of fixed-pos children.
132252:     aChildListID = containingBlock->GetAbsoluteListID();
129231:   }
129231: 
     1:   // Insert the frames hanging out in aItems.  We can use SetInitialChildList()
 30710:   // if the containing block hasn't been reflowed yet (so NS_FRAME_FIRST_REFLOW
 77154:   // is set) and doesn't have any frames in the aChildListID child list yet.
 77154:   const nsFrameList& childList = containingBlock->GetChildList(aChildListID);
124463:   DebugOnly<nsresult> rv = NS_OK;
 30785:   if (childList.IsEmpty() &&
 30785:       (containingBlock->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
 79483:     // If we're injecting absolutely positioned frames, inject them on the
 79483:     // absolute containing block
 79483:     if (aChildListID == containingBlock->GetAbsoluteListID()) {
 79483:       rv = containingBlock->GetAbsoluteContainingBlock()->
 79483:            SetInitialChildList(containingBlock, aChildListID, aFrameItems);
 79483:     } else {
 77154:       rv = containingBlock->SetInitialChildList(aChildListID, aFrameItems);
 79483:     }
     1:   } else {
     1:     // Note that whether the frame construction context is doing an append or
     1:     // not is not helpful here, since it could be appending to some frame in
     1:     // the middle of the document, which means we're not necessarily
     1:     // appending to the children of the containing block.
     1:     //
     1:     // We need to make sure the 'append to the end of document' case is fast.
     1:     // So first test the last child of the containing block
 30785:     nsIFrame* lastChild = childList.LastChild();
     1: 
     1:     // CompareTreePosition uses placeholder hierarchy for out of flow frames,
     1:     // so this will make out-of-flows respect the ordering of placeholders,
     1:     // which is great because it takes care of anonymous content.
 30785:     nsIFrame* firstNewFrame = aFrameItems.FirstChild();  
     1:     if (!lastChild ||
     1:         nsLayoutUtils::CompareTreePosition(lastChild, firstNewFrame, containingBlock) < 0) {
 32843:       // no lastChild, or lastChild comes before the new children, so just append
 79483:       rv = mFrameManager->AppendFrames(containingBlock, aChildListID, aFrameItems);
     1:     } else {
     1:       // try the other children
106838:       nsIFrame* insertionPoint = nullptr;
 30785:       for (nsIFrame* f = childList.FirstChild(); f != lastChild;
 30785:            f = f->GetNextSibling()) {
108991:         int32_t compare =
     1:           nsLayoutUtils::CompareTreePosition(f, firstNewFrame, containingBlock);
     1:         if (compare > 0) {
     1:           // f comes after the new children, so stop here and insert after
     1:           // the previous frame
     1:           break;
     1:         }
     1:         insertionPoint = f;
     1:       }
 79483:       rv = mFrameManager->InsertFrames(containingBlock, aChildListID,
 79483:                                        insertionPoint, aFrameItems);
 30790:     }
 32843:   }
 30790: 
 30790:   NS_POSTCONDITION(aFrameItems.IsEmpty(), "How did that happen?");
 30790: 
     1:   // XXXbz And if NS_FAILED(rv), what?  I guess we need to clean up the list
     1:   // and deal with all the placeholders... but what if the placeholders aren't
     1:   // in the document yet?  Could that happen?
     1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Frames getting lost!");
     1: }
     1: 
     1: 
     1: nsFrameConstructorSaveState::nsFrameConstructorSaveState()
106838:   : mItems(nullptr),
106838:     mSavedItems(nullptr),
 77155:     mChildListID(kPrincipalList),
129231:     mState(nullptr),
129231:     mSavedFixedItems(nullptr),
129231:     mSavedFixedPosIsAbsPos(false)
     1: {
     1: }
     1: 
     1: nsFrameConstructorSaveState::~nsFrameConstructorSaveState()
     1: {
     1:   // Restore the state
     1:   if (mItems) {
     1:     NS_ASSERTION(mState, "Can't have mItems set without having a state!");
 77154:     mState->ProcessFrameInsertions(*mItems, mChildListID);
     1:     *mItems = mSavedItems;
     1: #ifdef DEBUG
     1:     // We've transferred the child list, so drop the pointer we held to it.
     1:     // Note that this only matters for the assert in ~nsAbsoluteItems.
 30785:     mSavedItems.Clear();
     1: #endif
129231:     if (mItems == &mState->mAbsoluteItems) {
129231:       mState->mFixedPosIsAbsPos = mSavedFixedPosIsAbsPos;
129231:       if (mSavedFixedPosIsAbsPos) {
129231:         // mAbsoluteItems was moved to mFixedItems, so move mFixedItems back
129231:         // and repair the old mFixedItems now.
129231:         mState->mAbsoluteItems = mState->mFixedItems;
129231:         mState->mFixedItems = mSavedFixedItems;
129231: #ifdef DEBUG
129231:         mSavedFixedItems.Clear();
129231: #endif
129231:       }
129231:     }
129231:     NS_ASSERTION(!mItems->LastChild() || !mItems->LastChild()->GetNextSibling(),
129231:                  "Something corrupted our list");
 19214:   }
     1: }
     1: 
     1: static 
 79445: bool IsBorderCollapse(nsIFrame* aFrame)
     1: {
     1:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
     1:     if (nsGkAtoms::tableFrame == frame->GetType()) {
     1:       return ((nsTableFrame*)frame)->IsBorderCollapse();
     1:     }
     1:   }
 80486:   NS_ASSERTION(false, "program error");
 80486:   return false;
     1: }
     1: 
     1: /**
 34464:  * Moves aFrameList from aOldParent to aNewParent.  This updates the parent
 51752:  * pointer of the frames in the list, and reparents their views as needed.
 51752:  * nsFrame::SetParent sets the NS_FRAME_HAS_VIEW bit on aNewParent and its
 51752:  * ancestors as needed. Then it sets the list as the initial child list
 51752:  * on aNewParent, unless aNewParent either already has kids or has been
 51752:  * reflowed; in that case it appends the new frames.  Note that this
 51752:  * method differs from ReparentFrames in that it doesn't change the kids'
 51752:  * style contexts.
     1:  */
 34464: // XXXbz Since this is only used for {ib} splits, could we just copy the view
 34464: // bits from aOldParent to aNewParent and then use the
 34464: // nsFrameList::ApplySetParent?  That would still leave us doing two passes
 34464: // over the list, of course; if we really wanted to we could factor out the
 34464: // relevant part of ReparentFrameViewList, I suppose...  Or just get rid of
 34464: // views, which would make most of this function go away.
     1: static void
 34464: MoveChildrenTo(nsPresContext* aPresContext,
 34464:                nsIFrame* aOldParent,
     1:                nsIFrame* aNewParent,
 34464:                nsFrameList& aFrameList)
 34464: {
 79445:   bool sameGrandParent = aOldParent->GetParent() == aNewParent->GetParent();
 36624: 
 36624:   if (aNewParent->HasView() || aOldParent->HasView() || !sameGrandParent) {
 34464:     // Move the frames into the new view
 68656:     nsContainerFrame::ReparentFrameViewList(aPresContext, aFrameList,
 34464:                                             aOldParent, aNewParent);
 34464:   }
 34464: 
 34464:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
 34464:     e.get()->SetParent(aNewParent);
     1:   }
     1: 
 77154:   if (aNewParent->PrincipalChildList().IsEmpty() &&
 35611:       (aNewParent->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
 77155:     aNewParent->SetInitialChildList(kPrincipalList, aFrameList);
 35611:   } else {
 77155:     aNewParent->AppendFrames(kPrincipalList, aFrameList);
 35611:   }
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: nsCSSFrameConstructor::nsCSSFrameConstructor(nsIDocument *aDocument,
     1:                                              nsIPresShell *aPresShell)
 89328:   : nsFrameManager(aPresShell)
 89328:   , mDocument(aDocument)
106838:   , mRootElementFrame(nullptr)
106838:   , mRootElementStyleFrame(nullptr)
106838:   , mFixedContainingBlock(nullptr)
106838:   , mDocElementContainingBlock(nullptr)
106838:   , mGfxScrollFrame(nullptr)
106838:   , mPageSequenceFrame(nullptr)
     1:   , mUpdateCount(0)
 80486:   , mQuotesDirty(false)
 80486:   , mCountersDirty(false)
 80486:   , mIsDestroyingFrameTree(false)
 80486:   , mRebuildAllStyleData(false)
 80486:   , mHasRootAbsPosContainingBlock(false)
 80486:   , mObservingRefreshDriver(false)
 80486:   , mInStyleRefresh(false)
 22471:   , mHoverGeneration(0)
 22339:   , mRebuildAllExtraHint(nsChangeHint(0))
125555:   , mAnimationGeneration(0)
 43788:   , mPendingRestyles(ELEMENT_HAS_PENDING_RESTYLE |
 43788:                      ELEMENT_IS_POTENTIAL_RESTYLE_ROOT, this)
 43788:   , mPendingAnimationRestyles(ELEMENT_HAS_PENDING_ANIMATION_RESTYLE |
 43788:                               ELEMENT_IS_POTENTIAL_ANIMATION_RESTYLE_ROOT, this)
     1: {
     1:   // XXXbz this should be in Init() or something!
 98908:   mPendingRestyles.Init();
 98908:   mPendingAnimationRestyles.Init();
     1: 
     1: #ifdef DEBUG
 79445:   static bool gFirstTime = true;
     1:   if (gFirstTime) {
 80486:     gFirstTime = false;
     1:     char* flags = PR_GetEnv("GECKO_FRAMECTOR_DEBUG_FLAGS");
     1:     if (flags) {
 79445:       bool error = false;
     1:       for (;;) {
     1:         char* comma = PL_strchr(flags, ',');
     1:         if (comma)
     1:           *comma = '\0';
     1: 
 79445:         bool found = false;
     1:         FrameCtorDebugFlags* flag = gFlags;
     1:         FrameCtorDebugFlags* limit = gFlags + NUM_DEBUG_FLAGS;
     1:         while (flag < limit) {
     1:           if (PL_strcasecmp(flag->name, flags) == 0) {
 80486:             *(flag->on) = true;
     1:             printf("nsCSSFrameConstructor: setting %s debug flag on\n", flag->name);
 80486:             found = true;
     1:             break;
     1:           }
     1:           ++flag;
     1:         }
     1: 
     1:         if (! found)
 80486:           error = true;
     1: 
     1:         if (! comma)
     1:           break;
     1: 
     1:         *comma = ',';
     1:         flags = comma + 1;
     1:       }
     1: 
     1:       if (error) {
     1:         printf("Here are the available GECKO_FRAMECTOR_DEBUG_FLAGS:\n");
     1:         FrameCtorDebugFlags* flag = gFlags;
     1:         FrameCtorDebugFlags* limit = gFlags + NUM_DEBUG_FLAGS;
     1:         while (flag < limit) {
     1:           printf("  %s\n", flag->name);
     1:           ++flag;
     1:         }
     1:         printf("Note: GECKO_FRAMECTOR_DEBUG_FLAGS is a comma separated list of flag\n");
     1:         printf("names (no whitespace)\n");
     1:       }
     1:     }
     1:   }
     1: #endif
     1: }
     1: 
     1: void
     1: nsCSSFrameConstructor::NotifyDestroyingFrame(nsIFrame* aFrame)
     1: {
  6518:   NS_PRECONDITION(mUpdateCount != 0,
  6518:                   "Should be in an update while destroying frames");
  6518: 
 16477:   if (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
 16477:     if (mQuoteList.DestroyNodesFor(aFrame))
     1:       QuotesDirty();
     1:   }
 16477: 
 16477:   if (mCounterManager.DestroyNodesFor(aFrame)) {
     1:     // Technically we don't need to update anything if we destroyed only
     1:     // USE nodes.  However, this is unlikely to happen in the real world
     1:     // since USE nodes generally go along with INCREMENT nodes.
     1:     CountersDirty();
     1:   }
 89328: 
133599:   mOverflowChangedTracker.RemoveFrame(aFrame);
130708: 
 89328:   nsFrameManager::NotifyDestroyingFrame(aFrame);
     1: }
 16477: 
 16976: struct nsGenConInitializer {
 16976:   nsAutoPtr<nsGenConNode> mNode;
 16976:   nsGenConList*           mList;
 16976:   void (nsCSSFrameConstructor::*mDirtyAll)();
 16976:   
 16976:   nsGenConInitializer(nsGenConNode* aNode, nsGenConList* aList,
 16976:                       void (nsCSSFrameConstructor::*aDirtyAll)())
 16976:     : mNode(aNode), mList(aList), mDirtyAll(aDirtyAll) {}
 16976: };
 16976: 
 16976: static void
 16976: DestroyGenConInitializer(void*    aFrame,
 16976:                          nsIAtom* aPropertyName,
 16976:                          void*    aPropertyValue,
 16976:                          void*    aDtorData)
 16976: {
 16976:   delete static_cast<nsGenConInitializer*>(aPropertyValue);
 16976: }
 16976: 
 16976: already_AddRefed<nsIContent>
 31438: nsCSSFrameConstructor::CreateGenConTextNode(nsFrameConstructorState& aState,
 31438:                                             const nsString& aString,
 16976:                                             nsCOMPtr<nsIDOMCharacterData>* aText,
 16976:                                             nsGenConInitializer* aInitializer)
 16976: {
 16976:   nsCOMPtr<nsIContent> content;
 16976:   NS_NewTextNode(getter_AddRefs(content), mDocument->NodeInfoManager());
 16976:   if (!content) {
 16976:     // XXX The quotes/counters code doesn't like the text pointer
 16976:     // being null in case of dynamic changes!
 16976:     NS_ASSERTION(!aText, "this OOM case isn't handled very well");
106838:     return nullptr;
 16976:   }
 80486:   content->SetText(aString, false);
 16976:   if (aText) {
 16976:     *aText = do_QueryInterface(content);
 16976:   }
 16976:   if (aInitializer) {
 16976:     content->SetProperty(nsGkAtoms::genConInitializerProperty, aInitializer,
 16976:                          DestroyGenConInitializer);
 31438:     aState.mGeneratedTextNodesWithInitializer.AppendObject(content);
 16976:   }
 16976:   return content.forget();
 16976: }
 16976: 
 16976: already_AddRefed<nsIContent>
 31438: nsCSSFrameConstructor::CreateGeneratedContent(nsFrameConstructorState& aState,
 31438:                                               nsIContent*     aParentContent,
 16477:                                               nsStyleContext* aStyleContext,
108991:                                               uint32_t        aContentIndex)
 16976: {
     1:   // Get the content value
 16976:   const nsStyleContentData &data =
132812:     aStyleContext->StyleContent()->ContentAt(aContentIndex);
     1:   nsStyleContentType type = data.mType;
     1: 
     1:   if (eStyleContentType_Image == type) {
     1:     if (!data.mContent.mImage) {
     1:       // CSS had something specified that couldn't be converted to an
     1:       // image object
106838:       return nullptr;
     1:     }
     1:     
     1:     // Create an image content object and pass it the image request.
     1:     // XXX Check if it's an image type we can handle...
     1: 
 94340:     nsCOMPtr<nsINodeInfo> nodeInfo;
 71770:     nodeInfo = mDocument->NodeInfoManager()->
106838:       GetNodeInfo(nsGkAtoms::mozgeneratedcontentimage, nullptr,
 71770:                   kNameSpaceID_XHTML, nsIDOMNode::ELEMENT_NODE);
     1: 
 16976:     nsCOMPtr<nsIContent> content;
 48124:     NS_NewGenConImageContent(getter_AddRefs(content), nodeInfo.forget(),
     1:                              data.mContent.mImage);
 16976:     return content.forget();
 16976:   }
     1: 
     1:   switch (type) {
     1:   case eStyleContentType_String:
 31438:     return CreateGenConTextNode(aState,
 31438:                                 nsDependentString(data.mContent.mString),
106838:                                 nullptr, nullptr);
     1: 
     1:   case eStyleContentType_Attr:
     1:     {
     1:       nsCOMPtr<nsIAtom> attrName;
108991:       int32_t attrNameSpace = kNameSpaceID_None;
 16976:       nsAutoString contentString(data.mContent.mString);
 33262:       
108991:       int32_t barIndex = contentString.FindChar('|'); // CSS namespace delimiter
     1:       if (-1 != barIndex) {
     1:         nsAutoString  nameSpaceVal;
     1:         contentString.Left(nameSpaceVal, barIndex);
106878:         nsresult error;
     1:         attrNameSpace = nameSpaceVal.ToInteger(&error, 10);
     1:         contentString.Cut(0, barIndex + 1);
     1:         if (contentString.Length()) {
 33329:           if (mDocument->IsHTML() && aParentContent->IsHTML()) {
 33262:             ToLowerCase(contentString);
 33262:           }
     1:           attrName = do_GetAtom(contentString);
     1:         }
     1:       }
     1:       else {
 33329:         if (mDocument->IsHTML() && aParentContent->IsHTML()) {
 33262:           ToLowerCase(contentString);
 33262:         }
     1:         attrName = do_GetAtom(contentString);
     1:       }
     1: 
     1:       if (!attrName) {
106838:         return nullptr;
 16976:       }
 16976: 
 16976:       nsCOMPtr<nsIContent> content;
 16976:       NS_NewAttributeContent(mDocument->NodeInfoManager(),
 16976:                              attrNameSpace, attrName, getter_AddRefs(content));
 16976:       return content.forget();
 16976:     }
     1: 
     1:   case eStyleContentType_Counter:
     1:   case eStyleContentType_Counters:
     1:     {
     1:       nsCSSValue::Array* counters = data.mContent.mCounters;
     1:       nsCounterList* counterList = mCounterManager.CounterListFor(
     1:           nsDependentString(counters->Item(0).GetStringBufferValue()));
     1:       if (!counterList)
106838:         return nullptr;
     1: 
     1:       nsCounterUseNode* node =
 16976:         new nsCounterUseNode(counters, aContentIndex,
 16477:                              type == eStyleContentType_Counters);
 16976: 
 16976:       nsGenConInitializer* initializer =
 16976:         new nsGenConInitializer(node, counterList,
 16976:                                 &nsCSSFrameConstructor::CountersDirty);
 31438:       return CreateGenConTextNode(aState, EmptyString(), &node->mText,
 31438:                                   initializer);
 16976:     }
     1: 
     1:   case eStyleContentType_Image:
     1:     NS_NOTREACHED("handled by if above");
106838:     return nullptr;
     1: 
     1:   case eStyleContentType_OpenQuote:
     1:   case eStyleContentType_CloseQuote:
     1:   case eStyleContentType_NoOpenQuote:
     1:   case eStyleContentType_NoCloseQuote:
     1:     {
 16976:       nsQuoteNode* node =
 16976:         new nsQuoteNode(type, aContentIndex);
 16976: 
 16976:       nsGenConInitializer* initializer =
 16976:         new nsGenConInitializer(node, &mQuoteList,
 16976:                                 &nsCSSFrameConstructor::QuotesDirty);
 31438:       return CreateGenConTextNode(aState, EmptyString(), &node->mText,
 31438:                                   initializer);
 16976:     }
     1:   
     1:   case eStyleContentType_AltContent:
     1:     {
     1:       // Use the "alt" attribute; if that fails and the node is an HTML
     1:       // <input>, try the value attribute and then fall back to some default
     1:       // localized text we have.
 16976:       // XXX what if the 'alt' attribute is added later, how will we
 16976:       // detect that and do the right thing here?
 16976:       if (aParentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::alt)) {
 16976:         nsCOMPtr<nsIContent> content;
 16976:         NS_NewAttributeContent(mDocument->NodeInfoManager(),
 16976:                                kNameSpaceID_None, nsGkAtoms::alt, getter_AddRefs(content));
 16976:         return content.forget();
 16976:       }
 16976: 
 33329:       if (aParentContent->IsHTML() &&
 16976:           aParentContent->NodeInfo()->Equals(nsGkAtoms::input)) {
 16976:         if (aParentContent->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
 16976:           nsCOMPtr<nsIContent> content;
 16976:           NS_NewAttributeContent(mDocument->NodeInfoManager(),
 16976:                                  kNameSpaceID_None, nsGkAtoms::value, getter_AddRefs(content));
 16976:           return content.forget();
 16976:         }
 16976: 
     1:         nsXPIDLString temp;
 16976:         nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
     1:                                            "Submit", temp);
106838:         return CreateGenConTextNode(aState, temp, nullptr, nullptr);
 16976:       }
 16976: 
     1:       break;
 16976:     }
     1:   } // switch
     1: 
106838:   return nullptr;
 16976: }
 16976: 
     1: /*
 16976:  * aParentFrame - the frame that should be the parent of the generated
     1:  *   content.  This is the frame for the corresponding content node,
     1:  *   which must not be a leaf frame.
 16976:  * 
 25768:  * Any items created are added to aItems.
 16976:  * 
 16976:  * We create an XML element (tag _moz_generated_content_before or
 16976:  * _moz_generated_content_after) representing the pseudoelement. We
 16976:  * create a DOM node for each 'content' item and make those nodes the
 16976:  * children of the XML element. Then we create a frame subtree for
 16976:  * the XML element as if it were a regular child of
 16976:  * aParentFrame/aParentContent, giving the XML element the ::before or
 16976:  * ::after style.
     1:  */
 16976: void
 25768: nsCSSFrameConstructor::CreateGeneratedContentItem(nsFrameConstructorState& aState,
 16976:                                                   nsIFrame*        aParentFrame,
 16976:                                                   nsIContent*      aParentContent,
     1:                                                   nsStyleContext*  aStyleContext,
 35554:                                                   nsCSSPseudoElements::Type aPseudoElement,
 25774:                                                   FrameConstructionItemList& aItems)
 25768: {
 25768:   // XXXbz is this ever true?
 41640:   if (!aParentContent->IsElement()) {
 41640:     NS_ERROR("Bogus generated content parent");
 16976:     return;
 41640:   }
     1: 
     1:   nsStyleSet *styleSet = mPresShell->StyleSet();
     1: 
     1:   // Probe for the existence of the pseudo-element
     1:   nsRefPtr<nsStyleContext> pseudoStyleContext;
 41640:   pseudoStyleContext =
 41640:     styleSet->ProbePseudoElementStyle(aParentContent->AsElement(),
     1:                                       aPseudoElement,
 64158:                                       aStyleContext,
 64158:                                       aState.mTreeMatchContext);
 16976:   if (!pseudoStyleContext)
 16976:     return;
 16976:   // |ProbePseudoStyleFor| checked the 'display' property and the
     1:   // |ContentCount()| of the 'content' property for us.
 94340:   nsCOMPtr<nsINodeInfo> nodeInfo;
 35554:   nsIAtom* elemName = aPseudoElement == nsCSSPseudoElements::ePseudo_before ?
 16976:     nsGkAtoms::mozgeneratedcontentbefore : nsGkAtoms::mozgeneratedcontentafter;
106838:   nodeInfo = mDocument->NodeInfoManager()->GetNodeInfo(elemName, nullptr,
 71770:                                                        kNameSpaceID_None,
 71770:                                                        nsIDOMNode::ELEMENT_NODE);
 25768:   nsCOMPtr<nsIContent> container;
 48124:   nsresult rv = NS_NewXMLElement(getter_AddRefs(container), nodeInfo.forget());
 16976:   if (NS_FAILED(rv))
 16976:     return;
 16976:   container->SetNativeAnonymous();
 16976: 
 80486:   rv = container->BindToTree(mDocument, aParentContent, aParentContent, true);
 16976:   if (NS_FAILED(rv)) {
 16976:     container->UnbindFromTree();
 16976:     return;
 16976:   }
 16976: 
132812:   uint32_t contentCount = pseudoStyleContext->StyleContent()->ContentCount();
108991:   for (uint32_t contentIndex = 0; contentIndex < contentCount; contentIndex++) {
 16976:     nsCOMPtr<nsIContent> content =
 31438:       CreateGeneratedContent(aState, aParentContent, pseudoStyleContext,
 31438:                              contentIndex);
 16976:     if (content) {
 80486:       container->AppendChildTo(content, false);
 16976:     }
 16976:   }
 16976: 
 25771:   AddFrameConstructionItemsInternal(aState, container, aParentFrame, elemName,
 80486:                                     kNameSpaceID_None, true,
 47661:                                     pseudoStyleContext,
 25768:                                     ITEM_IS_GENERATED_CONTENT, aItems);
     1: }
     1:     
     1: /****************************************************
     1:  **  BEGIN TABLE SECTION
     1:  ****************************************************/
     1: 
     1: // The term pseudo frame is being used instead of anonymous frame, since anonymous
     1: // frame has been used elsewhere to refer to frames that have generated content
     1: 
 26471: // Return whether the given frame is a table pseudo-frame.  Note that
 26471: // cell-content and table-outer frames have pseudo-types, but are always
 26471: // created, even for non-anonymous cells and tables respectively.  So for those
 26471: // we have to examine the cell or table frame to see whether it's a pseudo
 26471: // frame.  In particular, a lone table caption will have an outer table as its
 26471: // parent, but will also trigger construction of an empty inner table, which
 26471: // will be the one we can examine to see whether the outer was a pseudo-frame.
 79445: static bool
 26471: IsTablePseudo(nsIFrame* aFrame)
 26471: {
132768:   nsIAtom* pseudoType = aFrame->StyleContext()->GetPseudo();
 26471:   return pseudoType &&
 26471:     (pseudoType == nsCSSAnonBoxes::table ||
 26471:      pseudoType == nsCSSAnonBoxes::inlineTable ||
 26471:      pseudoType == nsCSSAnonBoxes::tableColGroup ||
 26471:      pseudoType == nsCSSAnonBoxes::tableRowGroup ||
 26471:      pseudoType == nsCSSAnonBoxes::tableRow ||
 26471:      pseudoType == nsCSSAnonBoxes::tableCell ||
 26471:      (pseudoType == nsCSSAnonBoxes::cellContent &&
132768:       aFrame->GetParent()->StyleContext()->GetPseudo() ==
 26471:         nsCSSAnonBoxes::tableCell) ||
 26471:      (pseudoType == nsCSSAnonBoxes::tableOuter &&
132768:       (aFrame->GetFirstPrincipalChild()->StyleContext()->GetPseudo() ==
 26471:          nsCSSAnonBoxes::table ||
132768:        aFrame->GetFirstPrincipalChild()->StyleContext()->GetPseudo() ==
 26471:          nsCSSAnonBoxes::inlineTable)));
 26471: }
 26471: 
 26208: /* static */
 26208: nsCSSFrameConstructor::ParentType
 29580: nsCSSFrameConstructor::GetParentType(nsIAtom* aFrameType)
 29580: {
 29580:   if (aFrameType == nsGkAtoms::tableFrame) {
 26208:     return eTypeTable;
 26208:   }
 29580:   if (aFrameType == nsGkAtoms::tableRowGroupFrame) {
 26208:     return eTypeRowGroup;
 26208:   }
 29580:   if (aFrameType == nsGkAtoms::tableRowFrame) {
 26208:     return eTypeRow;
 26208:   }
 29580:   if (aFrameType == nsGkAtoms::tableColGroupFrame) {
 26208:     return eTypeColGroup;
 26208:   }
 26208: 
 26208:   return eTypeBlock;
     1: }
     1:            
     1: static nsIFrame*
     1: AdjustCaptionParentFrame(nsIFrame* aParentFrame) 
     1: {
     1:   if (nsGkAtoms::tableFrame == aParentFrame->GetType()) {
     1:     return aParentFrame->GetParent();;
     1:   }
     1:   return aParentFrame;
     1: }
     1:  
     1: /**
     1:  * If the parent frame is a |tableFrame| and the child is a
     1:  * |captionFrame|, then we want to insert the frames beneath the
 80486:  * |tableFrame|'s parent frame. Returns |true| if the parent frame
     1:  * needed to be fixed up.
     1:  */
 79445: static bool
     1: GetCaptionAdjustedParent(nsIFrame*        aParentFrame,
     1:                          const nsIFrame*  aChildFrame,
     1:                          nsIFrame**       aAdjParentFrame)
     1: {
     1:   *aAdjParentFrame = aParentFrame;
 79445:   bool haveCaption = false;
     1: 
     1:   if (nsGkAtoms::tableCaptionFrame == aChildFrame->GetType()) {
 80486:     haveCaption = true;
     1:     *aAdjParentFrame = AdjustCaptionParentFrame(aParentFrame);
     1:   }
     1:   return haveCaption;
     1: }
     1: 
 26208: void
 26208: nsCSSFrameConstructor::AdjustParentFrame(nsIFrame* &                  aParentFrame,
 23955:                                          const FrameConstructionData* aFCData,
 26208:                                          nsStyleContext*              aStyleContext)
     1: {
 25768:   NS_PRECONDITION(aStyleContext, "Must have child's style context");
 25131:   NS_PRECONDITION(aFCData, "Must have frame construction data");
     1: 
 79445:   bool tablePart = ((aFCData->mBits & FCDATA_IS_TABLE_PART) != 0);
 25131: 
132812:   if (tablePart && aStyleContext->StyleDisplay()->mDisplay ==
 26208:       NS_STYLE_DISPLAY_TABLE_CAPTION) {
 26207:     aParentFrame = AdjustCaptionParentFrame(aParentFrame);
 26208:   }
     1: }
     1: 
  4368: // Pull all the captions present in aItems out  into aCaptions
  4368: static void
  4368: PullOutCaptionFrames(nsFrameItems& aItems, nsFrameItems& aCaptions)
  4368: {
 30785:   nsIFrame *child = aItems.FirstChild();
  4368:   while (child) {
  4368:     nsIFrame *nextSibling = child->GetNextSibling();
  4368:     if (nsGkAtoms::tableCaptionFrame == child->GetType()) {
 33388:       aItems.RemoveFrame(child);
  4368:       aCaptions.AddChild(child);
  4368:     }
  4368:     child = nextSibling;
  4368:   }
  4368: }
  4368: 
  4368: 
     1: // Construct the outer, inner table frames and the children frames for the table. 
     1: // XXX Page break frames for pseudo table frames are not constructed to avoid the risk
     1: // associated with revising the pseudo frame mechanism. The long term solution
     1: // of having frames handle page-break-before/after will solve the problem. 
     1: nsresult
 26208: nsCSSFrameConstructor::ConstructTable(nsFrameConstructorState& aState,
 26208:                                       FrameConstructionItem&   aItem,
 26208:                                       nsIFrame*                aParentFrame,
 26208:                                       const nsStyleDisplay*    aDisplay,
 26208:                                       nsFrameItems&            aFrameItems,
 26208:                                       nsIFrame**               aNewFrame)
 26208: {
 26208:   NS_PRECONDITION(aDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE ||
 26208:                   aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_TABLE,
 26208:                   "Unexpected call");
 26208: 
 26208:   nsIContent* const content = aItem.mContent;
 26208:   nsStyleContext* const styleContext = aItem.mStyleContext;
108991:   const uint32_t nameSpaceID = aItem.mNameSpaceID;
 26208: 
     1:   nsresult rv = NS_OK;
     1: 
     1:   // create the pseudo SC for the outer table as a child of the inner SC
     1:   nsRefPtr<nsStyleContext> outerStyleContext;
     1:   outerStyleContext = mPresShell->StyleSet()->
 35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::tableOuter, styleContext);
     1: 
     1:   // Create the outer table frame which holds the caption and inner table frame
 26208:   nsIFrame* newFrame;
 26208:   if (kNameSpaceID_MathML == nameSpaceID)
 26208:     newFrame = NS_NewMathMLmtableOuterFrame(mPresShell, outerStyleContext);
     1:   else
 26208:     newFrame = NS_NewTableOuterFrame(mPresShell, outerStyleContext);
 26208: 
 26208:   nsIFrame* geometricParent =
132812:     aState.GetGeometricParent(outerStyleContext->StyleDisplay(),
 26208:                               aParentFrame);
     1: 
 69112:   // Init the table outer frame
106838:   InitAndRestoreFrame(aState, content, geometricParent, nullptr, newFrame);  
     1: 
     1:   // Create the inner table frame
 26208:   nsIFrame* innerFrame;
 26208:   if (kNameSpaceID_MathML == nameSpaceID)
 26208:     innerFrame = NS_NewMathMLmtableFrame(mPresShell, styleContext);
     1:   else
 26208:     innerFrame = NS_NewTableFrame(mPresShell, styleContext);
 26208: 
106838:   InitAndRestoreFrame(aState, content, newFrame, nullptr, innerFrame);
 26208: 
     1:   // Put the newly created frames into the right child list
 30790:   SetInitialSingleChild(newFrame, innerFrame);
 26208: 
 26208:   rv = aState.AddChild(newFrame, aFrameItems, content, styleContext,
 26208:                        aParentFrame);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
 24659:   if (!mRootElementFrame) {
 24659:     // The frame we're constructing will be the root element frame.
 24659:     // Set mRootElementFrame before processing children.
 26208:     mRootElementFrame = newFrame;
 20147:   }
 20147: 
     1:   nsFrameItems childItems;
 79486: 
 79486:   // Process children
 79486:   nsFrameConstructorSaveState absoluteSaveState;
132812:   const nsStyleDisplay* display = outerStyleContext->StyleDisplay();
 79486: 
 79486:   // Mark the table frame as an absolute container if needed
120781:   newFrame->AddStateBits(NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
107225:   if (display->IsPositioned(aParentFrame)) {
 79486:     aState.PushAbsoluteContainingBlock(newFrame, absoluteSaveState);
 79486:   }
 26208:   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
 26208:     rv = ConstructFramesFromItemList(aState, aItem.mChildItems,
 26208:                                      innerFrame, childItems);
 26208:   } else {
 26208:     rv = ProcessChildren(aState, content, styleContext, innerFrame,
 80486:                          true, childItems, false, aItem.mPendingBinding);
 26208:   }
     1:   // XXXbz what about cleaning up?
     1:   if (NS_FAILED(rv)) return rv;
     1: 
     1:   nsFrameItems captionItems;
  4368:   PullOutCaptionFrames(childItems, captionItems);
  4368: 
     1:   // Set the inner table frame's initial primary list 
 77155:   innerFrame->SetInitialChildList(kPrincipalList, childItems);
     1: 
     1:   // Set the outer table frame's secondary childlist lists
 30785:   if (captionItems.NotEmpty()) {
 77154:     newFrame->SetInitialChildList(nsIFrame::kCaptionList, captionItems);
     1:   }
 26208: 
 26208:   *aNewFrame = newFrame;
     1:   return rv;
     1: }
     1: 
     1: nsresult
 26208: nsCSSFrameConstructor::ConstructTableRow(nsFrameConstructorState& aState,
 26208:                                          FrameConstructionItem&   aItem,
 26208:                                          nsIFrame*                aParentFrame,
 26208:                                          const nsStyleDisplay*    aDisplay,
 26208:                                          nsFrameItems&            aFrameItems,
 26208:                                          nsIFrame**               aNewFrame)
 26208: {
 26208:   NS_PRECONDITION(aDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_ROW,
 26208:                   "Unexpected call");
 26208:   nsIContent* const content = aItem.mContent;
 26208:   nsStyleContext* const styleContext = aItem.mStyleContext;
108991:   const uint32_t nameSpaceID = aItem.mNameSpaceID;
 26208: 
 26208:   nsIFrame* newFrame;
 26208:   if (kNameSpaceID_MathML == nameSpaceID)
 26208:     newFrame = NS_NewMathMLmtrFrame(mPresShell, styleContext);
     1:   else
 26208:     newFrame = NS_NewTableRowFrame(mPresShell, styleContext);
 26208: 
106838:   InitAndRestoreFrame(aState, content, aParentFrame, nullptr, newFrame);
 26208: 
     1:   nsFrameItems childItems;
 26208:   nsresult rv;
 26208:   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
 26208:     rv = ConstructFramesFromItemList(aState, aItem.mChildItems, newFrame,
 26208:                                      childItems);
 26208:   } else {
 26208:     rv = ProcessChildren(aState, content, styleContext, newFrame,
 80486:                          true, childItems, false, aItem.mPendingBinding);
 26208:   }
     1:   if (NS_FAILED(rv)) return rv;
     1: 
 77155:   newFrame->SetInitialChildList(kPrincipalList, childItems);
 26208:   aFrameItems.AddChild(newFrame);
 26208:   *aNewFrame = newFrame;
     1: 
 25130:   return NS_OK;
     1: }
     1: 
     1: nsresult
 26207: nsCSSFrameConstructor::ConstructTableCol(nsFrameConstructorState& aState,
 26207:                                          FrameConstructionItem&   aItem,
 26207:                                          nsIFrame*                aParentFrame,
 26207:                                          const nsStyleDisplay*    aStyleDisplay,
 26207:                                          nsFrameItems&            aFrameItems,
 26207:                                          nsIFrame**               aNewFrame)
 26207: {
 26207:   nsIContent* const content = aItem.mContent;
 26207:   nsStyleContext* const styleContext = aItem.mStyleContext;
 26207: 
 26207:   nsTableColFrame* colFrame = NS_NewTableColFrame(mPresShell, styleContext);
106838:   InitAndRestoreFrame(aState, content, aParentFrame, nullptr, colFrame);
 26207: 
132768:   NS_ASSERTION(colFrame->StyleContext() == styleContext,
 26207:                "Unexpected style context");
     1: 
 32841:   aFrameItems.AddChild(colFrame);
 32841:   *aNewFrame = colFrame;
 32841: 
     1:   // construct additional col frames if the col frame has a span > 1
108991:   int32_t span = colFrame->GetSpan();
108991:   for (int32_t spanX = 1; spanX < span; spanX++) {
  8151:     nsTableColFrame* newCol = NS_NewTableColFrame(mPresShell, styleContext);
106838:     InitAndRestoreFrame(aState, content, aParentFrame, nullptr, newCol,
 80486:                         false);
 32841:     aFrameItems.LastChild()->SetNextContinuation(newCol);
 32841:     newCol->SetPrevContinuation(aFrameItems.LastChild());
 32841:     aFrameItems.AddChild(newCol);
  8151:     newCol->SetColType(eColAnonymousCol);
 32841:   }
     1: 
 25130:   return NS_OK;
     1: }
     1: 
     1: nsresult
 26208: nsCSSFrameConstructor::ConstructTableCell(nsFrameConstructorState& aState,
 26208:                                           FrameConstructionItem&   aItem,
 26208:                                           nsIFrame*                aParentFrame,
 26208:                                           const nsStyleDisplay*    aDisplay,
 26208:                                           nsFrameItems&            aFrameItems,
 26208:                                           nsIFrame**               aNewFrame)
 26208: {
 26208:   NS_PRECONDITION(aDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_CELL,
 26208:                   "Unexpected call");
 26208: 
 26208:   nsIContent* const content = aItem.mContent;
 26208:   nsStyleContext* const styleContext = aItem.mStyleContext;
108991:   const uint32_t nameSpaceID = aItem.mNameSpaceID;
 26208: 
 79445:   bool borderCollapse = IsBorderCollapse(aParentFrame);
 26208:   nsIFrame* newFrame;
     1:   // <mtable> is border separate in mathml.css and the MathML code doesn't implement
     1:   // border collapse. For those users who style <mtable> with border collapse,
 26208:   // give them the default non-MathML table frames that understand border collapse.
     1:   // This won't break us because MathML table frames are all subclasses of the default
     1:   // table code, and so we can freely mix <mtable> with <mtr> or <tr>, <mtd> or <td>.
     1:   // What will happen is just that non-MathML frames won't understand MathML attributes
     1:   // and will therefore miss the special handling that the MathML code does.
 26208:   if (kNameSpaceID_MathML == nameSpaceID && !borderCollapse)
 26208:     newFrame = NS_NewMathMLmtdFrame(mPresShell, styleContext);
     1:   else
  8578:     // Warning: If you change this and add a wrapper frame around table cell
  8578:     // frames, make sure Bug 368554 doesn't regress!
  8578:     // See IsInAutoWidthTableCellForQuirk() in nsImageFrame.cpp.    
 26208:     newFrame = NS_NewTableCellFrame(mPresShell, styleContext, borderCollapse);
 26208: 
     1:   // Initialize the table cell frame
106838:   InitAndRestoreFrame(aState, content, aParentFrame, nullptr, newFrame);
     1:   
     1:   // Resolve pseudo style and initialize the body cell frame
     1:   nsRefPtr<nsStyleContext> innerPseudoStyle;
     1:   innerPseudoStyle = mPresShell->StyleSet()->
 35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::cellContent, styleContext);
     1: 
     1:   // Create a block frame that will format the cell's content
 79445:   bool isBlock;
 26208:   nsIFrame* cellInnerFrame;
 26208:   if (kNameSpaceID_MathML == nameSpaceID) {
 26208:     cellInnerFrame = NS_NewMathMLmtdInnerFrame(mPresShell, innerPseudoStyle);
 80486:     isBlock = false;
 71203:   } else {
 26208:     cellInnerFrame = NS_NewBlockFormattingContext(mPresShell, innerPseudoStyle);
 80486:     isBlock = true;
  6818:   }
     1: 
106838:   InitAndRestoreFrame(aState, content, newFrame, nullptr, cellInnerFrame);
 26208: 
 26208:   nsFrameItems childItems;
 26208:   nsresult rv;
 26208:   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
 26208:     // Need to push ourselves as a float containing block.
 26208:     // XXXbz it might be nice to work on getting the parent
 26208:     // FrameConstructionItem down into ProcessChildren and just making use of
 26208:     // the push there, but that's a bit of work.
 26208:     nsFrameConstructorSaveState floatSaveState;
 26208:     if (!isBlock) { /* MathML case */
106838:       aState.PushFloatContainingBlock(nullptr, floatSaveState);
 26208:     } else {
 26208:       aState.PushFloatContainingBlock(cellInnerFrame, floatSaveState);
 26208:     }
 26208: 
 26208:     rv = ConstructFramesFromItemList(aState, aItem.mChildItems, cellInnerFrame,
 26208:                                      childItems);
 26208:   } else {
     1:     // Process the child content
 26208:     rv = ProcessChildren(aState, content, styleContext, cellInnerFrame,
 80486:                          true, childItems, isBlock, aItem.mPendingBinding);
 26208:   }
     1:   
     1:   if (NS_FAILED(rv)) {
     1:     // Clean up
     1:     // XXXbz kids of this stuff need to be cleaned up too!
 26208:     cellInnerFrame->Destroy();
 26208:     newFrame->Destroy();
     1:     return rv;
     1:   }
     1: 
 77155:   cellInnerFrame->SetInitialChildList(kPrincipalList, childItems);
 30790:   SetInitialSingleChild(newFrame, cellInnerFrame);
 26208:   aFrameItems.AddChild(newFrame);
 26208:   *aNewFrame = newFrame;
     1: 
 25130:   return NS_OK;
     1: }
     1: 
 79445: static inline bool 
 41931: NeedFrameFor(const nsFrameConstructorState& aState,
 41931:              nsIFrame*   aParentFrame,
     1:              nsIContent* aChildContent) 
     1: {
 37483:   // XXX the GetContent() != aChildContent check is needed due to bug 135040.
 37483:   // Remove it once that's fixed.
 37483:   NS_PRECONDITION(!aChildContent->GetPrimaryFrame() ||
 56439:                   aState.mCreatingExtraFrames ||
 37483:                   aChildContent->GetPrimaryFrame()->GetContent() != aChildContent,
 37483:                   "Why did we get called?");
 36794: 
 16976:   // don't create a whitespace frame if aParentFrame doesn't want it.
 16976:   // always create frames for children in generated content. counter(),
 16976:   // quotes, and attr() content can easily change dynamically and we don't
 16976:   // want to be reconstructing frames. It's not even clear that these
 16976:   // should be considered ignorable just because they evaluate to
 16976:   // whitespace.
 27311: 
 27311:   // We could handle all this in CreateNeededTablePseudos or some other place
 27311:   // after we build our frame construction items, but that would involve
 27311:   // creating frame construction items for whitespace kids of
 27311:   // eExcludesIgnorableWhitespace frames, where we know we'll be dropping them
 27311:   // all anyway, and involve an extra walk down the frame construction item
 27311:   // list.
 27311:   if (!aParentFrame->IsFrameOfType(nsIFrame::eExcludesIgnorableWhitespace) ||
 27311:       aParentFrame->IsGeneratedContentFrame() ||
 27311:       !aChildContent->IsNodeOfType(nsINode::eTEXT)) {
 80486:     return true;
 27311:   }
 27311: 
 29809:   aChildContent->SetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE |
 29809:                           NS_REFRAME_IF_WHITESPACE);
 27311:   return !aChildContent->TextIsOnlyWhitespace();
     1: }
     1: 
     1: /***********************************************
     1:  * END TABLE SECTION
     1:  ***********************************************/
     1: 
 79445: static bool CheckOverflow(nsPresContext* aPresContext,
     1:                             const nsStyleDisplay* aDisplay)
     1: {
     1:   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_VISIBLE)
 80486:     return false;
     1: 
     1:   if (aDisplay->mOverflowX == NS_STYLE_OVERFLOW_CLIP)
     1:     aPresContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_HIDDEN,
     1:                                               NS_STYLE_OVERFLOW_HIDDEN);
     1:   else
     1:     aPresContext->SetViewportOverflowOverride(aDisplay->mOverflowX,
     1:                                               aDisplay->mOverflowY);
 80486:   return true;
     1: }
     1: 
     1: /**
     1:  * This checks the root element and the HTML BODY, if any, for an "overflow" property
     1:  * that should be applied to the viewport. If one is found then we return the
     1:  * element that we took the overflow from (which should then be treated as
     1:  * "overflow:visible"), and we store the overflow style in the prescontext.
     1:  * @return if scroll was propagated from some content node, the content node it
     1:  *         was propagated from.
     1:  */
     1: nsIContent*
     1: nsCSSFrameConstructor::PropagateScrollToViewport()
     1: {
     1:   // Set default
     1:   nsPresContext* presContext = mPresShell->GetPresContext();
     1:   presContext->SetViewportOverflowOverride(NS_STYLE_OVERFLOW_AUTO,
     1:                                            NS_STYLE_OVERFLOW_AUTO);
     1: 
     1:   // We never mess with the viewport scroll state
     1:   // when printing or in print preview
     1:   if (presContext->IsPaginated()) {
106838:     return nullptr;
     1:   }
     1: 
 41634:   Element* docElement = mDocument->GetRootElement();
     1: 
     1:   // Check the style on the document root element
     1:   nsStyleSet *styleSet = mPresShell->StyleSet();
     1:   nsRefPtr<nsStyleContext> rootStyle;
106838:   rootStyle = styleSet->ResolveStyleFor(docElement, nullptr);
     1:   if (!rootStyle) {
106838:     return nullptr;
     1:   }
132812:   if (CheckOverflow(presContext, rootStyle->StyleDisplay())) {
     1:     // tell caller we stole the overflow style from the root element
     1:     return docElement;
     1:   }
     1:   
     1:   // Don't look in the BODY for non-HTML documents or HTML documents
     1:   // with non-HTML roots
     1:   // XXX this should be earlier; we shouldn't even look at the document root
     1:   // for non-HTML documents. Fix this once we support explicit CSS styling
     1:   // of the viewport
     1:   // XXX what about XHTML?
     1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(mDocument));
 33329:   if (!htmlDoc || !docElement->IsHTML()) {
106838:     return nullptr;
     1:   }
     1:   
     1:   nsCOMPtr<nsIDOMHTMLElement> body;
     1:   htmlDoc->GetBody(getter_AddRefs(body));
     1:   nsCOMPtr<nsIContent> bodyElement = do_QueryInterface(body);
     1:   
     1:   if (!bodyElement ||
     1:       !bodyElement->NodeInfo()->Equals(nsGkAtoms::body)) {
     1:     // The body is not a <body> tag, it's a <frameset>.
106838:     return nullptr;
     1:   }
     1: 
     1:   nsRefPtr<nsStyleContext> bodyStyle;
 41640:   bodyStyle = styleSet->ResolveStyleFor(bodyElement->AsElement(), rootStyle);
     1:   if (!bodyStyle) {
106838:     return nullptr;
     1:   }
     1: 
132812:   if (CheckOverflow(presContext, bodyStyle->StyleDisplay())) {
     1:     // tell caller we stole the overflow style from the body element
     1:     return bodyElement;
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: nsresult
 41640: nsCSSFrameConstructor::ConstructDocElementFrame(Element*                 aDocElement,
 28215:                                                 nsILayoutHistoryState*   aFrameState,
     1:                                                 nsIFrame**               aNewFrame)
     1: {
 28215:   NS_PRECONDITION(mFixedContainingBlock,
 28215:                   "No viewport?  Someone forgot to call ConstructRootFrame!");
 89328:   NS_PRECONDITION(mFixedContainingBlock == GetRootFrame(),
 28215:                   "Unexpected mFixedContainingBlock");
 30941:   NS_PRECONDITION(!mDocElementContainingBlock,
 30941:                   "Shouldn't have a doc element containing block here");
 28215: 
106838:   *aNewFrame = nullptr;
     1: 
 30585:   // Make sure to call PropagateScrollToViewport before
 30585:   // SetUpDocElementContainingBlock, since it sets up our scrollbar state
 30585:   // properly.
 64056: #ifdef DEBUG
 64056:   nsIContent* propagatedScrollFrom =
 64056: #endif
 64056:     PropagateScrollToViewport();
 30585: 
 28215:   SetUpDocElementContainingBlock(aDocElement);
 28215: 
 28215:   NS_ASSERTION(mDocElementContainingBlock, "Should have parent by now");
 28215: 
106838:   nsFrameConstructorState state(mPresShell, mFixedContainingBlock, nullptr,
106838:                                 nullptr, aFrameState);
 92183:   // Initialize the ancestor filter with null for now; we'll push
 92183:   // aDocElement once we finish resolving style for it.
128828:   state.mTreeMatchContext.InitAncestors(nullptr);
 28215: 
 28215:   // XXXbz why, exactly?
     1:   if (!mTempFrameTreeState)
 28215:     state.mPresShell->CaptureHistoryState(getter_AddRefs(mTempFrameTreeState));
     1: 
 43792:   // Make sure that we'll handle restyles for this document element in
 43792:   // the future.  We need this, because the document element might
 43792:   // have stale restyle bits from a previous frame constructor for
 43792:   // this document.  Unlike in AddFrameConstructionItems, it's safe to
 43792:   // unset all element restyle flags, since we don't have any
 43792:   // siblings.
 43792:   aDocElement->UnsetFlags(ELEMENT_ALL_RESTYLE_FLAGS);
 43792: 
     1:   // --------- CREATE AREA OR BOX FRAME -------
     1:   nsRefPtr<nsStyleContext> styleContext;
     1:   styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
106838:                                                          nullptr);
     1: 
132812:   const nsStyleDisplay* display = styleContext->StyleDisplay();
     1: 
     1:   // Ensure that our XBL bindings are installed.
     1:   if (display->mBinding) {
     1:     // Get the XBL loader.
     1:     nsresult rv;
 79445:     bool resolveStyle;
     1:     
 99253:     nsXBLService* xblService = nsXBLService::GetInstance();
     1:     if (!xblService)
     1:       return NS_ERROR_FAILURE;
     1: 
 34550:     nsRefPtr<nsXBLBinding> binding;
 69701:     rv = xblService->LoadBindings(aDocElement, display->mBinding->GetURI(),
  3645:                                   display->mBinding->mOriginPrincipal,
130431:                                   getter_AddRefs(binding), &resolveStyle);
 53995:     if (NS_FAILED(rv) && rv != NS_ERROR_XBL_BLOCKED)
     1:       return NS_OK; // Binding will load asynchronously.
     1: 
 34550:     if (binding) {
 34614:       // For backwards compat, keep firing the root's constructor
 34614:       // after all of its kids' constructors.  So tell the binding
 34614:       // manager about it right now.
 34550:       mDocument->BindingManager()->AddToAttachedQueue(binding);
 53759:     }
     1: 
     1:     if (resolveStyle) {
     1:       styleContext = mPresShell->StyleSet()->ResolveStyleFor(aDocElement,
106838:                                                              nullptr);
132812:       display = styleContext->StyleDisplay();
     1:     }
     1:   }
     1: 
     1:   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
     1: 
     1: #ifdef DEBUG
     1:   NS_ASSERTION(!display->IsScrollableOverflow() || 
 28215:                state.mPresContext->IsPaginated() ||
 30585:                propagatedScrollFrom == aDocElement,
     1:                "Scrollbars should have been propagated to the viewport");
     1: #endif
     1: 
120353:   if (MOZ_UNLIKELY(display->mDisplay == NS_STYLE_DISPLAY_NONE)) {
 89328:     SetUndisplayedContent(aDocElement, styleContext);
 19172:     return NS_OK;
 19172:   }
 19172: 
128828:   TreeMatchContext::AutoAncestorPusher
128828:     ancestorPusher(true, state.mTreeMatchContext, aDocElement);
 92183: 
 62083:   // Make sure to start any background image loads for the root element now.
 62083:   styleContext->StartBackgroundImageLoads();
 62083: 
 18953:   nsFrameConstructorSaveState absoluteSaveState;
 18953:   if (mHasRootAbsPosContainingBlock) {
 18953:     // Push the absolute containing block now so we can absolutely position
 18953:     // the root element
120781:     mDocElementContainingBlock->AddStateBits(NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
 28215:     state.PushAbsoluteContainingBlock(mDocElementContainingBlock,
 28215:                                       absoluteSaveState);
 18953:   }
 18953: 
     1:   nsresult rv;
     1: 
     1:   // The rules from CSS 2.1, section 9.2.4, have already been applied
     1:   // by the style system, so we can assume that display->mDisplay is
     1:   // either NONE, BLOCK, or TABLE.
     1: 
 18953:   // contentFrame is the primary frame for the root element. *aNewFrame
 18953:   // is the frame that will be the child of the initial containing block.
 18953:   // These are usually the same frame but they can be different, in
 18953:   // particular if the root frame is positioned, in which case
 18953:   // contentFrame is the out-of-flow frame and *aNewFrame is the
 18953:   // placeholder.
 18953:   nsIFrame* contentFrame;
 79445:   bool processChildren = false;
 23938: 
 23938:   // Check whether we need to build a XUL box or SVG root frame
 23938: #ifdef MOZ_XUL
 33329:   if (aDocElement->IsXUL()) {
 23938:     contentFrame = NS_NewDocElementBoxFrame(mPresShell, styleContext);
106838:     InitAndRestoreFrame(state, aDocElement, mDocElementContainingBlock, nullptr,
 28215:                         contentFrame);
 23938:     *aNewFrame = contentFrame;
 80486:     processChildren = true;
 23938:   }
 23938:   else
 23938: #endif
 84637:   if (aDocElement->IsSVG()) {
 58951:     if (aDocElement->Tag() == nsGkAtoms::svg) {
103952:       // We're going to call the right function ourselves, so no need to give a
103952:       // function to this FrameConstructionData.
103952: 
103952:       // XXXbz on the other hand, if we converted this whole function to
103952:       // FrameConstructionData/Item, then we'd need the right function
103952:       // here... but would probably be able to get away with less code in this
103952:       // function in general.
103952:       // Use a null PendingBinding, since our binding is not in fact pending.
106838:       static const FrameConstructionData rootSVGData = FCDATA_DECL(0, nullptr);
103952:       nsRefPtr<nsStyleContext> extraRef(styleContext);
103952:       FrameConstructionItem item(&rootSVGData, aDocElement,
103952:                                  aDocElement->Tag(), kNameSpaceID_SVG,
106838:                                  nullptr, extraRef.forget(), true);
103952: 
 23938:       nsFrameItems frameItems;
103952:       rv = ConstructOuterSVG(state, item, mDocElementContainingBlock,
132812:                              styleContext->StyleDisplay(),
103952:                              frameItems, &contentFrame);
103952:       if (NS_FAILED(rv))
 23938:         return rv;
103952:       if (!contentFrame || frameItems.IsEmpty())
103952:         return NS_ERROR_FAILURE;
 30785:       *aNewFrame = frameItems.FirstChild();
103952:       NS_ASSERTION(frameItems.OnlyChild(), "multiple root element frames");
 23938:     } else {
 23938:       return NS_ERROR_FAILURE;
 23938:     }
 58951:   } else {
 79445:     bool docElemIsTable = (display->mDisplay == NS_STYLE_DISPLAY_TABLE);
     1:     if (docElemIsTable) {
 26208:       // We're going to call the right function ourselves, so no need to give a
 26208:       // function to this FrameConstructionData.
 26208: 
 26208:       // XXXbz on the other hand, if we converted this whole function to
 26208:       // FrameConstructionData/Item, then we'd need the right function
 26208:       // here... but would probably be able to get away with less code in this
 26208:       // function in general.
 34614:       // Use a null PendingBinding, since our binding is not in fact pending.
106838:       static const FrameConstructionData rootTableData = FCDATA_DECL(0, nullptr);
 26208:       nsRefPtr<nsStyleContext> extraRef(styleContext);
 26208:       FrameConstructionItem item(&rootTableData, aDocElement,
 26208:                                  aDocElement->Tag(), kNameSpaceID_None,
106838:                                  nullptr, extraRef.forget(), true);
 26208: 
 18953:       nsFrameItems frameItems;
     1:       // if the document is a table then just populate it.
 28215:       rv = ConstructTable(state, item, mDocElementContainingBlock,
132812:                           styleContext->StyleDisplay(),
 26208:                           frameItems, &contentFrame);
 18953:       if (NS_FAILED(rv))
 18953:         return rv;
 30785:       if (!contentFrame || frameItems.IsEmpty())
 18953:         return NS_ERROR_FAILURE;
 30785:       *aNewFrame = frameItems.FirstChild();
 30785:       NS_ASSERTION(frameItems.OnlyChild(), "multiple root element frames");
     1:     } else {
 58471:       contentFrame = NS_NewBlockFormattingContext(mPresShell, styleContext);
 18953:       if (!contentFrame)
 18885:         return NS_ERROR_OUT_OF_MEMORY;
 18953:       nsFrameItems frameItems;
 34614:       // Use a null PendingBinding, since our binding is not in fact pending.
 28215:       rv = ConstructBlock(state, display, aDocElement,
 28215:                           state.GetGeometricParent(display,
 28215:                                                    mDocElementContainingBlock),
 28215:                           mDocElementContainingBlock, styleContext,
107225:                           &contentFrame, frameItems,
107225:                           display->IsPositioned(contentFrame), nullptr);
 30785:       if (NS_FAILED(rv) || frameItems.IsEmpty())
 18953:         return rv;
 30785:       *aNewFrame = frameItems.FirstChild();
 30785:       NS_ASSERTION(frameItems.OnlyChild(), "multiple root element frames");
 18953:     }
     1:   }
     1: 
     1:   // set the primary frame
 36653:   aDocElement->SetPrimaryFrame(contentFrame);
     1: 
 24659:   NS_ASSERTION(processChildren ? !mRootElementFrame :
 24659:                  mRootElementFrame == contentFrame,
 24659:                "unexpected mRootElementFrame");
 24659:   mRootElementFrame = contentFrame;
     1: 
 16509:   // Figure out which frame has the main style for the document element,
 16509:   // assigning it to mRootElementStyleFrame.
 16509:   // Backgrounds should be propagated from that frame to the viewport.
 78202:   mRootElementStyleFrame = contentFrame->GetParentStyleContextFrame();
 78202:   bool isChild = mRootElementStyleFrame &&
 78202:                  mRootElementStyleFrame->GetParent() == contentFrame;
 16509:   if (!isChild) {
 24659:     mRootElementStyleFrame = mRootElementFrame;
 16509:   }
 16509: 
 18953:   if (processChildren) {
 18953:     // Still need to process the child content
     1:     nsFrameItems childItems;
     1: 
103952:     NS_ASSERTION(!nsLayoutUtils::GetAsBlock(contentFrame) &&
103952:                  !contentFrame->IsFrameOfType(nsIFrame::eSVG),
103952:                  "Only XUL frames should reach here");
 34614:     // Use a null PendingBinding, since our binding is not in fact pending.
 80486:     ProcessChildren(state, aDocElement, styleContext, contentFrame, true,
106838:                     childItems, false, nullptr);
     1: 
     1:     // Set the initial child lists
 77155:     contentFrame->SetInitialChildList(kPrincipalList, childItems);
     1:   }
     1: 
 30941:   SetInitialSingleChild(mDocElementContainingBlock, *aNewFrame);
 28215: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: nsresult
 28215: nsCSSFrameConstructor::ConstructRootFrame(nsIFrame** aNewFrame)
     1: {
     1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
     1:   NS_PRECONDITION(aNewFrame, "null out param");
     1: 
 28215:   nsStyleSet *styleSet = mPresShell->StyleSet();
 28215: 
 28215:   // Set up our style rule observer.
 28215:   // XXXbz wouldn't this make more sense as part of presshell init?
 28215:   {
 28215:     styleSet->SetBindingManager(mDocument->BindingManager());
 28215:   }
 28215: 
 28215:   // --------- BUILD VIEWPORT -----------
106838:   nsIFrame*                 viewportFrame = nullptr;
 28215:   nsRefPtr<nsStyleContext> viewportPseudoStyle;
 28215: 
 35554:   viewportPseudoStyle =
106838:     styleSet->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::viewport, nullptr);
 28215: 
 28215:   viewportFrame = NS_NewViewportFrame(mPresShell, viewportPseudoStyle);
 28215: 
 28215:   // XXXbz do we _have_ to pass a null content pointer to that frame?
 28215:   // Would it really kill us to pass in the root element or something?
 28215:   // What would that break?
106838:   viewportFrame->Init(nullptr, nullptr, nullptr);
 28215: 
 28215:   // Bind the viewport frame to the root view
127357:   nsView* rootView = mPresShell->GetViewManager()->GetRootView();
 28215:   viewportFrame->SetView(rootView);
 28215: 
 28215:   nsContainerFrame::SyncFrameViewProperties(mPresShell->GetPresContext(), viewportFrame,
 28215:                                             viewportPseudoStyle, rootView);
 31401:   nsContainerFrame::SyncWindowProperties(mPresShell->GetPresContext(), viewportFrame,
 31401:                                          rootView);
 28215: 
 28215:   // The viewport is the containing block for 'fixed' elements
 28215:   mFixedContainingBlock = viewportFrame;
 79483:   // Make it an absolute container for fixed-pos elements
120781:   mFixedContainingBlock->AddStateBits(NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
 79483:   mFixedContainingBlock->MarkAsAbsoluteContainingBlock();
 28215: 
 28215:   *aNewFrame = viewportFrame;
 28215:   return NS_OK;
 28215: }
 28215: 
 28215: nsresult
 28215: nsCSSFrameConstructor::SetUpDocElementContainingBlock(nsIContent* aDocElement)
 28215: {
 28215:   NS_PRECONDITION(aDocElement, "No element?");
 28215:   NS_PRECONDITION(!aDocElement->GetParent(), "Not root content?");
 28215:   NS_PRECONDITION(aDocElement->GetCurrentDoc(), "Not in a document?");
 41634:   NS_PRECONDITION(aDocElement->GetCurrentDoc()->GetRootElement() ==
 28215:                   aDocElement, "Not the root of the document?");
 28215: 
     1:   /*
 18953:     how the root frame hierarchy should look
 18953: 
102692:   Galley presentation, non-XUL, with scrolling:
 18953:   
 18953:       ViewportFrame [fixed-cb]
 18953:         nsHTMLScrollFrame
 34149:           nsCanvasFrame [abs-cb]
 18953:             root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
 18953:                                 nsTableOuterFrame, nsPlaceholderFrame)
 18953: 
 18953:   Galley presentation, XUL
 18953:   
 18953:       ViewportFrame [fixed-cb]
 18953:         nsRootBoxFrame
 18953:           root element frame (nsDocElementBoxFrame)
 18953: 
 18953:   Print presentation, non-XUL
 18953: 
 18953:       ViewportFrame
 18953:         nsSimplePageSequenceFrame
 18953:           nsPageFrame [fixed-cb]
 18953:             nsPageContentFrame
 34149:               nsCanvasFrame [abs-cb]
 18953:                 root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
 18953:                                     nsTableOuterFrame, nsPlaceholderFrame)
 18953: 
 18953:   Print-preview presentation, non-XUL
 18953: 
 18953:       ViewportFrame
 18953:         nsHTMLScrollFrame
 18953:           nsSimplePageSequenceFrame
 18953:             nsPageFrame [fixed-cb]
 18953:               nsPageContentFrame
 34149:                 nsCanvasFrame [abs-cb]
 18953:                   root element frame (nsBlockFrame, nsSVGOuterSVGFrame,
 18953:                                       nsTableOuterFrame, nsPlaceholderFrame)
 18953: 
 18953:   Print/print preview of XUL is not supported.
 18953:   [fixed-cb]: the default containing block for fixed-pos content
 18953:   [abs-cb]: the default containing block for abs-pos content
 18953:  
 18953:   Meaning of nsCSSFrameConstructor fields:
 28215:     mRootElementFrame is "root element frame".  This is the primary frame for
 28215:       the root element.
 24659:     mDocElementContainingBlock is the parent of mRootElementFrame
 34149:       (i.e. nsCanvasFrame or nsRootBoxFrame)
 18953:     mFixedContainingBlock is the [fixed-cb]
 18953:     mGfxScrollFrame is the nsHTMLScrollFrame mentioned above, or null if there isn't one
 18953:     mPageSequenceFrame is the nsSimplePageSequenceFrame, or null if there isn't one
     1:   */
     1: 
     1:   // --------- CREATE ROOT FRAME -------
     1: 
     1: 
     1:   // Create the root frame. The document element's frame is a child of the
     1:   // root frame.
     1:   //
     1:   // The root frame serves two purposes:
     1:   // - reserves space for any margins needed for the document element's frame
     1:   // - renders the document element's background. This ensures the background covers
     1:   //   the entire canvas as specified by the CSS2 spec
     1: 
 28215:   nsPresContext* presContext = mPresShell->GetPresContext();
 79445:   bool isPaginated = presContext->IsRootPaginatedDocument();
 28215:   nsIFrame* viewportFrame = mFixedContainingBlock;
132768:   nsStyleContext* viewportPseudoStyle = viewportFrame->StyleContext();
     1: 
106838:   nsIFrame* rootFrame = nullptr;
     1:   nsIAtom* rootPseudo;
     1:         
     1:   if (!isPaginated) {
     1: #ifdef MOZ_XUL
 33329:     if (aDocElement->IsXUL())
     1:     {
     1:       // pass a temporary stylecontext, the correct one will be set later
     1:       rootFrame = NS_NewRootBoxFrame(mPresShell, viewportPseudoStyle);
     1:     } else
     1: #endif
     1:     {
     1:       // pass a temporary stylecontext, the correct one will be set later
     1:       rootFrame = NS_NewCanvasFrame(mPresShell, viewportPseudoStyle);
 80486:       mHasRootAbsPosContainingBlock = true;
     1:     }
     1: 
     1:     rootPseudo = nsCSSAnonBoxes::canvas;
     1:     mDocElementContainingBlock = rootFrame;
     1:   } else {
     1:     // Create a page sequence frame
     1:     rootFrame = NS_NewSimplePageSequenceFrame(mPresShell, viewportPseudoStyle);
     1:     mPageSequenceFrame = rootFrame;
     1:     rootPseudo = nsCSSAnonBoxes::pageSequence;
     1:   }
     1: 
     1: 
     1:   // --------- IF SCROLLABLE WRAP IN SCROLLFRAME --------
     1: 
     1:   // If the device supports scrolling (e.g., in galley mode on the screen and
     1:   // for print-preview, but not when printing), then create a scroll frame that
     1:   // will act as the scrolling mechanism for the viewport. 
     1:   // XXX Do we even need a viewport when printing to a printer?
     1: 
 28078:   // As long as the docshell doesn't prohibit it, and the device supports
     1:   // it, create a scroll frame that will act as the scolling mechanism for
     1:   // the viewport.
     1:   //
     1:   // Threre are three possible values stored in the docshell:
     1:   //  1) nsIScrollable::Scrollbar_Never = no scrollbars
     1:   //  2) nsIScrollable::Scrollbar_Auto = scrollbars appear if needed
     1:   //  3) nsIScrollable::Scrollbar_Always = scrollbars always
     1:   // Only need to create a scroll frame/view for cases 2 and 3.
     1: 
 79445:   bool isHTML = aDocElement->IsHTML();
 79445:   bool isXUL = false;
     1: 
     1:   if (!isHTML) {
 33329:     isXUL = aDocElement->IsXUL();
     1:   }
     1: 
     1:   // Never create scrollbars for XUL documents
102692:   bool isScrollable = isPaginated ? presContext->HasPaginatedScrolling() : !isXUL;
     1: 
     1:   // We no longer need to do overflow propagation here. It's taken care of
     1:   // when we construct frames for the element whose overflow might be
     1:   // propagated
     1:   NS_ASSERTION(!isScrollable || !isXUL,
     1:                "XUL documents should never be scrollable - see above");
     1: 
     1:   nsIFrame* newFrame = rootFrame;
     1:   nsRefPtr<nsStyleContext> rootPseudoStyle;
     1:   // we must create a state because if the scrollbars are GFX it needs the 
     1:   // state to build the scrollbar frames.
106838:   nsFrameConstructorState state(mPresShell, nullptr, nullptr, nullptr);
     1: 
 28215:   // Start off with the viewport as parent; we'll adjust it as needed.
     1:   nsIFrame* parentFrame = viewportFrame;
     1: 
 28215:   nsStyleSet* styleSet = mPresShell->StyleSet();
     1:   // If paginated, make sure we don't put scrollbars in
     1:   if (!isScrollable) {
 35554:     rootPseudoStyle = styleSet->ResolveAnonymousBoxStyle(rootPseudo,
     1:                                                          viewportPseudoStyle);
     1:   } else {
     1:       if (rootPseudo == nsCSSAnonBoxes::canvas) {
     1:         rootPseudo = nsCSSAnonBoxes::scrolledCanvas;
     1:       } else {
     1:         NS_ASSERTION(rootPseudo == nsCSSAnonBoxes::pageSequence,
     1:                      "Unknown root pseudo");
     1:         rootPseudo = nsCSSAnonBoxes::scrolledPageSequence;
     1:       }
     1: 
 28215:       // Build the frame. We give it the content we are wrapping which is the
 28215:       // document element, the root frame, the parent view port frame, and we
 28215:       // should get back the new frame and the scrollable view if one was
 28215:       // created.
     1: 
     1:       // resolve a context for the scrollframe
     1:       nsRefPtr<nsStyleContext>  styleContext;
 35554:       styleContext = styleSet->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::viewportScroll,
     1:                                                         viewportPseudoStyle);
     1: 
     1:       // Note that the viewport scrollframe is always built with
     1:       // overflow:auto style. This forces the scroll frame to create
     1:       // anonymous content for both scrollbars. This is necessary even
     1:       // if the HTML or BODY elements are overriding the viewport
     1:       // scroll style to 'hidden' --- dynamic style changes might put
     1:       // scrollbars back on the viewport and we don't want to have to
     1:       // reframe the viewport to create the scrollbar content.
106838:       newFrame = nullptr;
     1:       rootPseudoStyle = BeginBuildingScrollFrame( state,
     1:                                                   aDocElement,
     1:                                                   styleContext,
     1:                                                   viewportFrame,
     1:                                                   rootPseudo,
 80486:                                                   true,
     1:                                                   newFrame);
     1:       parentFrame = newFrame;
     1:       mGfxScrollFrame = newFrame;
     1:   }
     1:   
     1:   rootFrame->SetStyleContextWithoutNotification(rootPseudoStyle);
106838:   rootFrame->Init(aDocElement, parentFrame, nullptr);
     1:   
     1:   if (isScrollable) {
     1:     FinishBuildingScrollFrame(parentFrame, rootFrame);
     1:   }
     1:   
     1:   if (isPaginated) { // paginated
     1:     // Create the first page
     1:     // Set the initial child lists
 18953:     nsIFrame *pageFrame, *canvasFrame;
106838:     ConstructPageFrame(mPresShell, presContext, rootFrame, nullptr,
 18953:                        pageFrame, canvasFrame);
 30790:     SetInitialSingleChild(rootFrame, pageFrame);
     1: 
     1:     // The eventual parent of the document element frame.
     1:     // XXX should this be set for every new page (in ConstructPageFrame)?
 18953:     mDocElementContainingBlock = canvasFrame;
 80486:     mHasRootAbsPosContainingBlock = true;
     1:   }
     1: 
 28215:   if (viewportFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
 32846:     SetInitialSingleChild(viewportFrame, newFrame);
 28215:   } else {
 32846:     nsFrameList newFrameList(newFrame, newFrame);
 77155:     viewportFrame->AppendFrames(kPrincipalList, newFrameList);
 28215:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::ConstructPageFrame(nsIPresShell*  aPresShell,
     1:                                           nsPresContext* aPresContext,
     1:                                           nsIFrame*      aParentFrame,
     1:                                           nsIFrame*      aPrevPageFrame,
     1:                                           nsIFrame*&     aPageFrame,
 18953:                                           nsIFrame*&     aCanvasFrame)
     1: {
132768:   nsStyleContext* parentStyleContext = aParentFrame->StyleContext();
     1:   nsStyleSet *styleSet = aPresShell->StyleSet();
     1: 
     1:   nsRefPtr<nsStyleContext> pagePseudoStyle;
 35554:   pagePseudoStyle = styleSet->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::page,
     1:                                                        parentStyleContext);
     1: 
     1:   aPageFrame = NS_NewPageFrame(aPresShell, pagePseudoStyle);
     1: 
     1:   // Initialize the page frame and force it to have a view. This makes printing of
     1:   // the pages easier and faster.
106838:   aPageFrame->Init(nullptr, aParentFrame, aPrevPageFrame);
     1: 
     1:   nsRefPtr<nsStyleContext> pageContentPseudoStyle;
 35554:   pageContentPseudoStyle =
 35554:     styleSet->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::pageContent,
     1:                                        pagePseudoStyle);
     1: 
 18953:   nsIFrame* pageContentFrame = NS_NewPageContentFrame(aPresShell, pageContentPseudoStyle);
     1: 
     1:   // Initialize the page content frame and force it to have a view. Also make it the
     1:   // containing block for fixed elements which are repeated on every page.
106838:   nsIFrame* prevPageContentFrame = nullptr;
  4006:   if (aPrevPageFrame) {
 77154:     prevPageContentFrame = aPrevPageFrame->GetFirstPrincipalChild();
  4006:     NS_ASSERTION(prevPageContentFrame, "missing page content frame");
  4006:   }
106838:   pageContentFrame->Init(nullptr, aPageFrame, prevPageContentFrame);
 30790:   SetInitialSingleChild(aPageFrame, pageContentFrame);
 18953:   mFixedContainingBlock = pageContentFrame;
 79483:   // Make it an absolute container for fixed-pos elements
120781:   mFixedContainingBlock->AddStateBits(NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
 79483:   mFixedContainingBlock->MarkAsAbsoluteContainingBlock();
 18953: 
 18953:   nsRefPtr<nsStyleContext> canvasPseudoStyle;
 35554:   canvasPseudoStyle = styleSet->ResolveAnonymousBoxStyle(nsCSSAnonBoxes::canvas,
 18953:                                                          pageContentPseudoStyle);
 18953: 
 18953:   aCanvasFrame = NS_NewCanvasFrame(aPresShell, canvasPseudoStyle);
 18953: 
106838:   nsIFrame* prevCanvasFrame = nullptr;
 18953:   if (prevPageContentFrame) {
 77154:     prevCanvasFrame = prevPageContentFrame->GetFirstPrincipalChild();
 18953:     NS_ASSERTION(prevCanvasFrame, "missing canvas frame");
 18953:   }
106838:   aCanvasFrame->Init(nullptr, pageContentFrame, prevCanvasFrame);
 30790:   SetInitialSingleChild(pageContentFrame, aCanvasFrame);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: /* static */
     1: nsresult
     1: nsCSSFrameConstructor::CreatePlaceholderFrameFor(nsIPresShell*    aPresShell, 
     1:                                                  nsIContent*      aContent,
     1:                                                  nsIFrame*        aFrame,
     1:                                                  nsStyleContext*  aStyleContext,
     1:                                                  nsIFrame*        aParentFrame,
  6219:                                                  nsIFrame*        aPrevInFlow,
 34912:                                                  nsFrameState     aTypeBit,
     1:                                                  nsIFrame**       aPlaceholderFrame)
     1: {
     1:   nsRefPtr<nsStyleContext> placeholderStyle = aPresShell->StyleSet()->
     1:     ResolveStyleForNonElement(aStyleContext->GetParent());
     1:   
     1:   // The placeholder frame gets a pseudo style context
     1:   nsPlaceholderFrame* placeholderFrame =
 34912:     (nsPlaceholderFrame*)NS_NewPlaceholderFrame(aPresShell, placeholderStyle,
 34912:                                                 aTypeBit);
     1: 
  6219:   placeholderFrame->Init(aContent, aParentFrame, aPrevInFlow);
     1: 
     1:   // The placeholder frame has a pointer back to the out-of-flow frame
     1:   placeholderFrame->SetOutOfFlowFrame(aFrame);
     1: 
     1:   aFrame->AddStateBits(NS_FRAME_OUT_OF_FLOW);
     1: 
     1:   // Add mapping from absolutely positioned frame to its placeholder frame
  6219:   aPresShell->FrameManager()->RegisterPlaceholderFrame(placeholderFrame);
     1: 
  3233:   *aPlaceholderFrame = static_cast<nsIFrame*>(placeholderFrame);
     1: 
     1:   return NS_OK;
     1: }
     1: 
 47657: // Clears any lazy bits set in the range [aStartContent, aEndContent).  If
 47657: // aEndContent is null, that means to clear bits in all siblings starting with
 47657: // aStartContent.  aStartContent must not be null unless aEndContent is also
 47657: // null.  We do this so that when new children are inserted under elements whose
 47657: // frame is a leaf the new children don't cause us to try to construct frames
 47657: // for the existing children again.
 47657: static inline void
 47657: ClearLazyBits(nsIContent* aStartContent, nsIContent* aEndContent)
 47657: {
 47657:   NS_PRECONDITION(aStartContent || !aEndContent,
 47657:                   "Must have start child if we have an end child");
 47657:   for (nsIContent* cur = aStartContent; cur != aEndContent;
 47657:        cur = cur->GetNextSibling()) {
 47657:     cur->UnsetFlags(NODE_DESCENDANTS_NEED_FRAMES | NODE_NEEDS_FRAME);
 47657:   }
 47657: }
 40938: 
     1: nsresult
     1: nsCSSFrameConstructor::ConstructSelectFrame(nsFrameConstructorState& aState,
 25769:                                             FrameConstructionItem&   aItem,
     1:                                             nsIFrame*                aParentFrame,
     1:                                             const nsStyleDisplay*    aStyleDisplay,
 23944:                                             nsFrameItems&            aFrameItems,
 23944:                                             nsIFrame**               aNewFrame)
     1: {
     1:   nsresult rv = NS_OK;
     1: 
 25769:   nsIContent* const content = aItem.mContent;
 25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
 25769: 
     1:   // Construct a frame-based listbox or combobox
 25769:   nsCOMPtr<nsIDOMHTMLSelectElement> sel(do_QueryInterface(content));
108991:   uint32_t size = 1;
     1:   if (sel) {
     1:     sel->GetSize(&size); 
 79445:     bool multipleSelect = false;
     1:     sel->GetMultiple(&multipleSelect);
     1:      // Construct a combobox if size=1 or no size is specified and its multiple select
103380:     if ((1 == size || 0 == size) && !multipleSelect) {
     1:         // Construct a frame-based combo box.
     1:         // The frame-based combo box is built out of three parts. A display area, a button and
     1:         // a dropdown list. The display area and button are created through anonymous content.
     1:         // The drop-down list's frame is created explicitly. The combobox frame shares its content
     1:         // with the drop-down list.
108991:       uint32_t flags = NS_BLOCK_FLOAT_MGR;
 25769:       nsIFrame* comboboxFrame = NS_NewComboboxControlFrame(mPresShell, styleContext, flags);
     1: 
     1:       // Save the history state so we don't restore during construction
     1:       // since the complete tree is required before we restore.
     1:       nsILayoutHistoryState *historyState = aState.mFrameState;
106838:       aState.mFrameState = nullptr;
     1:       // Initialize the combobox frame
 25769:       InitAndRestoreFrame(aState, content,
     1:                           aState.GetGeometricParent(aStyleDisplay, aParentFrame),
106838:                           nullptr, comboboxFrame);
     1: 
 25769:       rv = aState.AddChild(comboboxFrame, aFrameItems, content, styleContext,
  8199:                            aParentFrame);
     1:       if (NS_FAILED(rv)) {
     1:         return rv;
     1:       }
     1:       
 23554:       nsIComboboxControlFrame* comboBox = do_QueryFrame(comboboxFrame);
     1:       NS_ASSERTION(comboBox, "NS_NewComboboxControlFrame returned frame that "
     1:                              "doesn't implement nsIComboboxControlFrame");
     1: 
     1:         // Resolve pseudo element style for the dropdown list
     1:       nsRefPtr<nsStyleContext> listStyle;
 35554:       listStyle = mPresShell->StyleSet()->
 35554:         ResolveAnonymousBoxStyle(nsCSSAnonBoxes::dropDownList, styleContext);
     1: 
     1:         // Create a listbox
     1:       nsIFrame* listFrame = NS_NewListControlFrame(mPresShell, listStyle);
     1: 
     1:         // Notify the listbox that it is being used as a dropdown list.
 23554:       nsIListControlFrame * listControlFrame = do_QueryFrame(listFrame);
 23554:       if (listControlFrame) {
     1:         listControlFrame->SetComboboxFrame(comboboxFrame);
     1:       }
     1:          // Notify combobox that it should use the listbox as it's popup
     1:       comboBox->SetDropDown(listFrame);
     1: 
107225:       NS_ASSERTION(!listFrame->IsPositioned(),
     1:                    "Ended up with positioned dropdown list somehow.");
107224:       NS_ASSERTION(!listFrame->IsFloating(),
     1:                    "Ended up with floating dropdown list somehow.");
     1:       
     1:       // Initialize the scroll frame positioned. Note that it is NOT
     1:       // initialized as absolutely positioned.
 25769:       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(mPresShell, styleContext, flags);
 25769: 
 25769:       InitializeSelectFrame(aState, listFrame, scrolledFrame, content,
 80486:                             comboboxFrame, listStyle, true,
 34614:                             aItem.mPendingBinding, aFrameItems);
     1: 
106838:       NS_ASSERTION(listFrame->GetView(), "ListFrame's view is nullptr");
     1: 
     1:       // Create display and button frames from the combobox's anonymous content.
     1:       // The anonymous content is appended to existing anonymous content for this
     1:       // element (the scrollbars).
     1: 
     1:       nsFrameItems childItems;
 34614:       CreateAnonymousFrames(aState, content, comboboxFrame,
 34614:                             aItem.mPendingBinding, childItems);
     1:   
 77155:       comboboxFrame->SetInitialChildList(kPrincipalList, childItems);
     1: 
     1:       // Initialize the additional popup child list which contains the
     1:       // dropdown list frame.
     1:       nsFrameItems popupItems;
     1:       popupItems.AddChild(listFrame);
 77154:       comboboxFrame->SetInitialChildList(nsIFrame::kSelectPopupList,
 30785:                                          popupItems);
     1: 
 23944:       *aNewFrame = comboboxFrame;
     1:       aState.mFrameState = historyState;
 89328:       if (aState.mFrameState) {
     1:         // Restore frame state for the entire subtree of |comboboxFrame|.
 89328:         RestoreFrameState(comboboxFrame, aState.mFrameState);
     1:       }
     1:     } else {
 25769:       nsIFrame* listFrame = NS_NewListControlFrame(mPresShell, styleContext);
     1:       rv = NS_OK;
     1: 
     1:       nsIFrame* scrolledFrame = NS_NewSelectsAreaFrame(
 25769:         mPresShell, styleContext, NS_BLOCK_FLOAT_MGR);
     1: 
     1:       // ******* this code stolen from Initialze ScrollFrame ********
     1:       // please adjust this code to use BuildScrollFrame.
     1: 
 25769:       InitializeSelectFrame(aState, listFrame, scrolledFrame, content,
 80486:                             aParentFrame, styleContext, false,
 34614:                             aItem.mPendingBinding, aFrameItems);
     1: 
 23944:       *aNewFrame = listFrame;
     1:     }
     1:   }
     1:   return rv;
     1: 
     1: }
     1: 
     1: /**
     1:  * Used to be InitializeScrollFrame but now it's only used for the select tag
     1:  * But the select tag should really be fixed to use GFX scrollbars that can
     1:  * be create with BuildScrollFrame.
     1:  */
     1: nsresult
     1: nsCSSFrameConstructor::InitializeSelectFrame(nsFrameConstructorState& aState,
     1:                                              nsIFrame*                scrollFrame,
     1:                                              nsIFrame*                scrolledFrame,
     1:                                              nsIContent*              aContent,
     1:                                              nsIFrame*                aParentFrame,
     1:                                              nsStyleContext*          aStyleContext,
 79445:                                              bool                     aBuildCombobox,
 34614:                                              PendingBinding*          aPendingBinding,
     1:                                              nsFrameItems&            aFrameItems)
     1: {
132812:   const nsStyleDisplay* display = aStyleContext->StyleDisplay();
     1: 
     1:   // Initialize it
     1:   nsIFrame* geometricParent = aState.GetGeometricParent(display, aParentFrame);
     1:     
     1:   // We don't call InitAndRestoreFrame for scrollFrame because we can only
     1:   // restore the frame state after its parts have been created (in particular,
     1:   // the scrollable view). So we have to split Init and Restore.
     1: 
     1:   // Initialize the frame
106838:   scrollFrame->Init(aContent, geometricParent, nullptr);
     1: 
     1:   if (!aBuildCombobox) {
  8199:     nsresult rv = aState.AddChild(scrollFrame, aFrameItems, aContent,
  8199:                                   aStyleContext, aParentFrame);
     1:     if (NS_FAILED(rv)) {
     1:       return rv;
     1:     }
     1:   }
     1:       
 69112:   if (aBuildCombobox) {
 80486:     nsContainerFrame::CreateViewForFrame(scrollFrame, true);
 69112:   }
     1: 
     1:   BuildScrollFrame(aState, aContent, aStyleContext, scrolledFrame,
 23950:                    geometricParent, scrollFrame);
     1: 
 89328:   if (aState.mFrameState) {
     1:     // Restore frame state for the scroll frame
 89328:     RestoreFrameStateFor(scrollFrame, aState.mFrameState);
     1:   }
     1: 
     1:   // Process children
     1:   nsFrameItems                childItems;
     1: 
 80486:   ProcessChildren(aState, aContent, aStyleContext, scrolledFrame, false,
 80486:                   childItems, false, aPendingBinding);
     1: 
     1:   // Set the scrolled frame's initial child lists
 77155:   scrolledFrame->SetInitialChildList(kPrincipalList, childItems);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::ConstructFieldSetFrame(nsFrameConstructorState& aState,
 25769:                                               FrameConstructionItem&   aItem,
     1:                                               nsIFrame*                aParentFrame,
 23944:                                               const nsStyleDisplay*    aStyleDisplay,
     1:                                               nsFrameItems&            aFrameItems,
 23944:                                               nsIFrame**               aNewFrame)
     1: {
 25769:   nsIContent* const content = aItem.mContent;
 25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
 25769: 
 25769:   nsIFrame* newFrame = NS_NewFieldSetFrame(mPresShell, styleContext);
     1: 
     1:   // Initialize it
 25769:   InitAndRestoreFrame(aState, content,
     1:                       aState.GetGeometricParent(aStyleDisplay, aParentFrame),
106838:                       nullptr, newFrame);
     1: 
     1:   // Resolve style and initialize the frame
 25769:   nsRefPtr<nsStyleContext> fieldsetContentStyle;
 35554:   fieldsetContentStyle = mPresShell->StyleSet()->
 35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::fieldsetContent, styleContext);
 25769: 
 25769:   nsIFrame* blockFrame = NS_NewBlockFrame(mPresShell, fieldsetContentStyle,
 23305:                                           NS_BLOCK_FLOAT_MGR |
 23176:                                           NS_BLOCK_MARGIN_ROOT);
106838:   InitAndRestoreFrame(aState, content, newFrame, nullptr, blockFrame);
 25769: 
 25769:   nsresult rv = aState.AddChild(newFrame, aFrameItems, content, styleContext,
  8199:                                 aParentFrame);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1:   
     1:   // Process children
     1:   nsFrameConstructorSaveState absoluteSaveState;
     1:   nsFrameItems                childItems;
     1: 
120781:   newFrame->AddStateBits(NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
107225:   if (newFrame->IsPositioned()) {
 79488:     aState.PushAbsoluteContainingBlock(newFrame, absoluteSaveState);
 23176:   }
 23176: 
 80486:   ProcessChildren(aState, content, styleContext, blockFrame, true,
 80486:                   childItems, true, aItem.mPendingBinding);
     1: 
 30790:   nsFrameItems fieldsetKids;
 30790:   fieldsetKids.AddChild(blockFrame);
 30790: 
 33388:   for (nsFrameList::Enumerator e(childItems); !e.AtEnd(); e.Next()) {
 95362:     nsIFrame* child = e.get();
 95362:     if (child->GetContentInsertionFrame()->GetType() == nsGkAtoms::legendFrame) {
     1:       // We want the legend to be the first frame in the fieldset child list.
     1:       // That way the EventStateManager will do the right thing when tabbing
     1:       // from a selection point within the legend (bug 236071), which is
     1:       // used for implementing legend access keys (bug 81481).
     1:       // GetAdjustedParentFrame() below depends on this frame order.
 95362:       childItems.RemoveFrame(child);
 30790:       // Make sure to reparent the legend so it has the fieldset as the parent.
106838:       fieldsetKids.InsertFrame(newFrame, nullptr, child);
     1:       break;
     1:     }
 30790:   }
 30790: 
 30790:   // Set the inner frame's initial child lists
 77155:   blockFrame->SetInitialChildList(kPrincipalList, childItems);
     1: 
 30790:   // Set the outer frame's initial child list
 77155:   newFrame->SetInitialChildList(kPrincipalList, fieldsetKids);
     1: 
101719:   newFrame->AddStateBits(NS_FRAME_MAY_HAVE_GENERATED_CONTENT);
101719: 
127459:   // Our new frame returned is the outer frame, which is the fieldset frame.
 23944:   *aNewFrame = newFrame; 
     1: 
     1:   return NS_OK;
     1: }
     1: 
 16976: static nsIFrame*
 16976: FindAncestorWithGeneratedContentPseudo(nsIFrame* aFrame)
 16976: {
 16976:   for (nsIFrame* f = aFrame->GetParent(); f; f = f->GetParent()) {
 16976:     NS_ASSERTION(f->IsGeneratedContentFrame(),
 16976:                  "should not have exited generated content");
132768:     nsIAtom* pseudo = f->StyleContext()->GetPseudo();
 16976:     if (pseudo == nsCSSPseudoElements::before ||
 16976:         pseudo == nsCSSPseudoElements::after)
 16976:       return f;
 16976:   }
106838:   return nullptr;
 16976: }
 16976: 
 23955: #define SIMPLE_FCDATA(_func) FCDATA_DECL(0, _func)
 25131: #define FULL_CTOR_FCDATA(_flags, _func)                             \
106838:   { _flags | FCDATA_FUNC_IS_FULL_CTOR, { nullptr }, _func, nullptr }
 23955: 
 23955: /* static */
 23955: const nsCSSFrameConstructor::FrameConstructionData*
 23955: nsCSSFrameConstructor::FindTextData(nsIFrame* aParentFrame)
 23955: {
132160:   if (aParentFrame && IsFrameForSVG(aParentFrame)) {
 23953:     nsIFrame *ancestorFrame =
 23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
 23167:     if (ancestorFrame) {
132160:       if (NS_SVGTextCSSFramesEnabled()) {
132160:         static const FrameConstructionData sSVGTextData =
132160:           FCDATA_DECL(FCDATA_IS_LINE_PARTICIPANT | FCDATA_IS_SVG_TEXT,
132160:                       NS_NewTextFrame);
132160:         if (ancestorFrame->IsSVGText()) {
132160:           return &sSVGTextData;
132160:         }
132160:       } else {
132160:         static const FrameConstructionData sSVGGlyphData =
132160:           SIMPLE_FCDATA(NS_NewSVGGlyphFrame);
 29052:         nsSVGTextContainerFrame* metrics = do_QueryFrame(ancestorFrame);
 23955:         if (metrics) {
 23955:           return &sSVGGlyphData;
 23955:         }
 23955:       }
132160:     }
106838:     return nullptr;
 23955:   }
 23955: 
 25773:   static const FrameConstructionData sTextData =
 25773:     FCDATA_DECL(FCDATA_IS_LINE_PARTICIPANT, NS_NewTextFrame);
 23955:   return &sTextData;
 23955: }
 23955: 
 23955: nsresult
 23955: nsCSSFrameConstructor::ConstructTextFrame(const FrameConstructionData* aData,
 23955:                                           nsFrameConstructorState& aState,
     1:                                           nsIContent*              aContent,
     1:                                           nsIFrame*                aParentFrame,
     1:                                           nsStyleContext*          aStyleContext,
 26208:                                           nsFrameItems&            aFrameItems)
     1: {
 25131:   NS_PRECONDITION(aData, "Must have frame construction data");
 23955: 
 23955:   nsIFrame* newFrame = (*aData->mFunc.mCreationFunc)(mPresShell, aStyleContext);
     1: 
120353:   if (MOZ_UNLIKELY(!newFrame))
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   nsresult rv = InitAndRestoreFrame(aState, aContent, aParentFrame,
106838:                                     nullptr, newFrame);
     1: 
     1:   if (NS_FAILED(rv)) {
     1:     newFrame->Destroy();
     1:     return rv;
     1:   }
     1: 
     1:   // We never need to create a view for a text frame.
     1: 
 16976:   if (newFrame->IsGeneratedContentFrame()) {
 16976:     nsAutoPtr<nsGenConInitializer> initializer;
 16976:     initializer =
 16976:       static_cast<nsGenConInitializer*>(
 16976:         aContent->UnsetProperty(nsGkAtoms::genConInitializerProperty));
 16976:     if (initializer) {
 16976:       if (initializer->mNode->InitTextFrame(initializer->mList,
 16976:               FindAncestorWithGeneratedContentPseudo(newFrame), newFrame)) {
 16976:         (this->*(initializer->mDirtyAll))();
 16976:       }
 16976:       initializer->mNode.forget();
 16976:     }
 16976:   }
     1:   
     1:   // Add the newly constructed frame to the flow
     1:   aFrameItems.AddChild(newFrame);
     1: 
 56439:   if (!aState.mCreatingExtraFrames)
 36653:     aContent->SetPrimaryFrame(newFrame);
     1:   
     1:   return rv;
     1: }
     1: 
 23944: /* static */
 23944: const nsCSSFrameConstructor::FrameConstructionData*
108991: nsCSSFrameConstructor::FindDataByInt(int32_t aInt,
 63575:                                      Element* aElement,
 23944:                                      nsStyleContext* aStyleContext,
 23944:                                      const FrameConstructionDataByInt* aDataPtr,
108991:                                      uint32_t aDataLength)
 23944: {
 23944:   for (const FrameConstructionDataByInt *curData = aDataPtr,
 23944:          *endData = aDataPtr + aDataLength;
 23944:        curData != endData;
 23944:        ++curData) {
 23944:     if (curData->mInt == aInt) {
 23944:       const FrameConstructionData* data = &curData->mData;
 23944:       if (data->mBits & FCDATA_FUNC_IS_DATA_GETTER) {
 63575:         return data->mFunc.mDataGetter(aElement, aStyleContext);
 23944:       }
 23944: 
 23944:       return data;
 23944:     }
 23944:   }
 23944: 
106838:   return nullptr;
 23944: }
 23944: 
 23944: /* static */
 23944: const nsCSSFrameConstructor::FrameConstructionData*
 23944: nsCSSFrameConstructor::FindDataByTag(nsIAtom* aTag,
 63575:                                      Element* aElement,
 23944:                                      nsStyleContext* aStyleContext,
 23944:                                      const FrameConstructionDataByTag* aDataPtr,
108991:                                      uint32_t aDataLength)
 23944: {
 23944:   for (const FrameConstructionDataByTag *curData = aDataPtr,
 23944:          *endData = aDataPtr + aDataLength;
 23944:        curData != endData;
 23944:        ++curData) {
 23944:     if (*curData->mTag == aTag) {
 23944:       const FrameConstructionData* data = &curData->mData;
 23944:       if (data->mBits & FCDATA_FUNC_IS_DATA_GETTER) {
 63575:         return data->mFunc.mDataGetter(aElement, aStyleContext);
 23944:       }
 23944: 
 23944:       return data;
 23944:     }
 23944:   }
 23944: 
106838:   return nullptr;
106838: }
106838: 
106838: #define SUPPRESS_FCDATA() FCDATA_DECL(FCDATA_SUPPRESS_FRAME, nullptr)
 23944: #define SIMPLE_INT_CREATE(_int, _func) { _int, SIMPLE_FCDATA(_func) }
 23944: #define SIMPLE_INT_CHAIN(_int, _func)                       \
 23944:   { _int, FCDATA_DECL(FCDATA_FUNC_IS_DATA_GETTER, _func) }
 23944: #define COMPLEX_INT_CREATE(_int, _func)         \
 25131:   { _int, FULL_CTOR_FCDATA(0, _func) }
 23944: 
 23944: #define SIMPLE_TAG_CREATE(_tag, _func)          \
 23944:   { &nsGkAtoms::_tag, SIMPLE_FCDATA(_func) }
 23944: #define SIMPLE_TAG_CHAIN(_tag, _func)                                   \
 23944:   { &nsGkAtoms::_tag, FCDATA_DECL(FCDATA_FUNC_IS_DATA_GETTER,  _func) }
 23944: #define COMPLEX_TAG_CREATE(_tag, _func)             \
 25131:   { &nsGkAtoms::_tag, FULL_CTOR_FCDATA(0, _func) }
 23944: 
 23944: /* static */
 23944: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindHTMLData(Element* aElement,
 23167:                                     nsIAtom* aTag,
108991:                                     int32_t aNameSpaceID,
 24550:                                     nsIFrame* aParentFrame,
 23944:                                     nsStyleContext* aStyleContext)
 23167: {
 23167:   // Ignore the tag if it's not HTML content and if it doesn't extend (via XBL)
 23167:   // a valid HTML namespace.  This check must match the one in
 23167:   // ShouldHaveFirstLineStyle.
 47707:   if (aNameSpaceID != kNameSpaceID_XHTML) {
106838:     return nullptr;
 23944:   }
 23944: 
 24550:   NS_ASSERTION(!aParentFrame ||
132768:                aParentFrame->StyleContext()->GetPseudo() !=
 24550:                  nsCSSAnonBoxes::fieldsetContent ||
 24550:                aParentFrame->GetParent()->GetType() == nsGkAtoms::fieldSetFrame,
 24550:                "Unexpected parent for fieldset content anon box");
 24550:   if (aTag == nsGkAtoms::legend &&
 24550:       (!aParentFrame ||
 24550:        (aParentFrame->GetType() != nsGkAtoms::fieldSetFrame &&
132768:         aParentFrame->StyleContext()->GetPseudo() !=
 30867:           nsCSSAnonBoxes::fieldsetContent) ||
 63575:        !aElement->GetParent() ||
 63575:        !aElement->GetParent()->IsHTML(nsGkAtoms::fieldset) ||
132812:        aStyleContext->StyleDisplay()->IsFloatingStyle() ||
132812:        aStyleContext->StyleDisplay()->IsAbsolutelyPositionedStyle())) {
 31229:     // <legend> is only special inside fieldset, check both the frame tree
 31229:     // parent and content tree parent due to XBL issues. For floated or
 30867:     // absolutely positioned legends we want to construct by display type and
 31229:     // not do special legend stuff.
 24550:     // XXXbz it would be nice if we could just decide this based on the parent
 24550:     // tag, and hence just use a SIMPLE_TAG_CHAIN for legend below, but the
 24550:     // fact that with XBL we could end up with this legend element in some
 24550:     // totally weird insertion point makes that chancy, I think.
106838:     return nullptr;
 24550:   }
 24550: 
 23944:   static const FrameConstructionDataByTag sHTMLData[] = {
 23944:     SIMPLE_TAG_CHAIN(img, nsCSSFrameConstructor::FindImgData),
 23944:     SIMPLE_TAG_CHAIN(mozgeneratedcontentimage,
 23944:                      nsCSSFrameConstructor::FindImgData),
 25773:     { &nsGkAtoms::br,
 36653:       FCDATA_DECL(FCDATA_IS_LINE_PARTICIPANT | FCDATA_IS_LINE_BREAK,
 25773:                   NS_NewBRFrame) },
 23977:     SIMPLE_TAG_CREATE(wbr, NS_NewWBRFrame),
 23944:     SIMPLE_TAG_CHAIN(input, nsCSSFrameConstructor::FindInputData),
 23944:     SIMPLE_TAG_CREATE(textarea, NS_NewTextControlFrame),
 23944:     COMPLEX_TAG_CREATE(select, &nsCSSFrameConstructor::ConstructSelectFrame),
 23944:     SIMPLE_TAG_CHAIN(object, nsCSSFrameConstructor::FindObjectData),
 23944:     SIMPLE_TAG_CHAIN(applet, nsCSSFrameConstructor::FindObjectData),
 23944:     SIMPLE_TAG_CHAIN(embed, nsCSSFrameConstructor::FindObjectData),
 23944:     COMPLEX_TAG_CREATE(fieldset,
 23944:                        &nsCSSFrameConstructor::ConstructFieldSetFrame),
 52104:     { &nsGkAtoms::legend,
 95362:       FCDATA_DECL(FCDATA_ALLOW_BLOCK_STYLES | FCDATA_MAY_NEED_SCROLLFRAME,
 95362:                   NS_NewLegendFrame) },
 23944:     SIMPLE_TAG_CREATE(frameset, NS_NewHTMLFramesetFrame),
 23944:     SIMPLE_TAG_CREATE(iframe, NS_NewSubDocumentFrame),
 90621:     { &nsGkAtoms::button,
 90621:       FCDATA_WITH_WRAPPING_BLOCK(FCDATA_ALLOW_BLOCK_STYLES,
 90621:                                  NS_NewHTMLButtonControlFrame,
 90621:                                  nsCSSAnonBoxes::buttonContent) },
 86029:     SIMPLE_TAG_CHAIN(canvas, nsCSSFrameConstructor::FindCanvasData),
 23944: #if defined(MOZ_MEDIA)
 23944:     SIMPLE_TAG_CREATE(video, NS_NewHTMLVideoFrame),
 23944:     SIMPLE_TAG_CREATE(audio, NS_NewHTMLVideoFrame),
 23944: #endif
101226:     SIMPLE_TAG_CREATE(progress, NS_NewProgressFrame),
101226:     SIMPLE_TAG_CREATE(meter, NS_NewMeterFrame)
 23944:   };
 23944: 
 63575:   return FindDataByTag(aTag, aElement, aStyleContext, sHTMLData,
 80467:                        ArrayLength(sHTMLData));
 23944: }
 23944: 
 23944: /* static */
 23944: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindImgData(Element* aElement,
 23944:                                    nsStyleContext* aStyleContext)
 23944: {
 63575:   if (!nsImageFrame::ShouldCreateImageFrameFor(aElement, aStyleContext)) {
106838:     return nullptr;
 23944:   }
 23944: 
 23944:   static const FrameConstructionData sImgData = SIMPLE_FCDATA(NS_NewImageFrame);
 23944:   return &sImgData;
 23944: }
 23944: 
 23944: /* static */
 23944: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindImgControlData(Element* aElement,
 23944:                                           nsStyleContext* aStyleContext)
 23944: {
 63575:   if (!nsImageFrame::ShouldCreateImageFrameFor(aElement, aStyleContext)) {
106838:     return nullptr;
 23944:   }
 23944: 
 23944:   static const FrameConstructionData sImgControlData =
 23944:     SIMPLE_FCDATA(NS_NewImageControlFrame);
 23944:   return &sImgControlData;
 23944: }
 23944: 
 23944: /* static */
 23944: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindInputData(Element* aElement,
 23944:                                      nsStyleContext* aStyleContext)
 23944: {
 23944:   static const FrameConstructionDataByInt sInputData[] = {
 23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_CHECKBOX, NS_NewGfxCheckboxControlFrame),
 23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_RADIO, NS_NewGfxRadioControlFrame),
 23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_FILE, NS_NewFileControlFrame),
 23944:     SIMPLE_INT_CHAIN(NS_FORM_INPUT_IMAGE,
 23944:                      nsCSSFrameConstructor::FindImgControlData),
 50907:     SIMPLE_INT_CREATE(NS_FORM_INPUT_EMAIL, NS_NewTextControlFrame),
 42372:     SIMPLE_INT_CREATE(NS_FORM_INPUT_SEARCH, NS_NewTextControlFrame),
 23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_TEXT, NS_NewTextControlFrame),
 42192:     SIMPLE_INT_CREATE(NS_FORM_INPUT_TEL, NS_NewTextControlFrame),
 50909:     SIMPLE_INT_CREATE(NS_FORM_INPUT_URL, NS_NewTextControlFrame),
132802:     SIMPLE_INT_CREATE(NS_FORM_INPUT_RANGE, NS_NewRangeFrame),
 23944:     SIMPLE_INT_CREATE(NS_FORM_INPUT_PASSWORD, NS_NewTextControlFrame),
103657:     // TODO: this is temporary until a frame is written: bug 635240.
103657:     SIMPLE_INT_CREATE(NS_FORM_INPUT_NUMBER, NS_NewTextControlFrame),
126970:     // TODO: this is temporary until a frame is written: bug 773205.
126970:     SIMPLE_INT_CREATE(NS_FORM_INPUT_DATE, NS_NewTextControlFrame),
128902:     // TODO: this is temporary until a frame is written: bug 773205
128902:     SIMPLE_INT_CREATE(NS_FORM_INPUT_TIME, NS_NewTextControlFrame),
 90621:     { NS_FORM_INPUT_SUBMIT,
 90621:       FCDATA_WITH_WRAPPING_BLOCK(0, NS_NewGfxButtonControlFrame,
 90621:                                  nsCSSAnonBoxes::buttonContent) },
 90621:     { NS_FORM_INPUT_RESET,
 90621:       FCDATA_WITH_WRAPPING_BLOCK(0, NS_NewGfxButtonControlFrame,
 90621:                                  nsCSSAnonBoxes::buttonContent) },
 90621:     { NS_FORM_INPUT_BUTTON,
 90621:       FCDATA_WITH_WRAPPING_BLOCK(0, NS_NewGfxButtonControlFrame,
 90621:                                  nsCSSAnonBoxes::buttonContent) }
 23944:     // Keeping hidden inputs out of here on purpose for so they get frames by
 23944:     // display (in practice, none).
 23944:   };
 23944: 
 63575:   nsCOMPtr<nsIFormControl> control = do_QueryInterface(aElement);
 23944:   NS_ASSERTION(control, "input doesn't implement nsIFormControl?");
 23944: 
 63575:   return FindDataByInt(control->GetType(), aElement, aStyleContext,
 80467:                        sInputData, ArrayLength(sInputData));
 23944: }
 23944: 
 23944: /* static */
 23944: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindObjectData(Element* aElement,
 23944:                                       nsStyleContext* aStyleContext)
 23944: {
 23944:   // GetDisplayedType isn't necessarily nsIObjectLoadingContent::TYPE_NULL for
 23944:   // cases when the object is broken/suppressed/etc (e.g. a broken image), but
 23944:   // we want to treat those cases as TYPE_NULL
108991:   uint32_t type;
 71116:   if (aElement->State().HasAtLeastOneOfStates(NS_EVENT_STATE_BROKEN |
 56168:                                               NS_EVENT_STATE_USERDISABLED |
 23944:                                               NS_EVENT_STATE_SUPPRESSED)) {
 23944:     type = nsIObjectLoadingContent::TYPE_NULL;
 23944:   } else {
 63575:     nsCOMPtr<nsIObjectLoadingContent> objContent(do_QueryInterface(aElement));
 23944:     NS_ASSERTION(objContent,
 23944:                  "applet, embed and object must implement "
 23944:                  "nsIObjectLoadingContent!");
 23944: 
 23944:     objContent->GetDisplayedType(&type);
 23944:   }
 23944: 
 23944:   static const FrameConstructionDataByInt sObjectData[] = {
 23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_LOADING,
 23944:                       NS_NewEmptyFrame),
 23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_PLUGIN,
 23944:                       NS_NewObjectFrame),
 23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_IMAGE,
 23944:                       NS_NewImageFrame),
 23944:     SIMPLE_INT_CREATE(nsIObjectLoadingContent::TYPE_DOCUMENT,
 23944:                       NS_NewSubDocumentFrame)
 23944:     // Nothing for TYPE_NULL so we'll construct frames by display there
 23944:   };
 23944: 
108991:   return FindDataByInt((int32_t)type, aElement, aStyleContext,
 80467:                        sObjectData, ArrayLength(sObjectData));
 23944: }
 23944: 
 86029: /* static */
 86029: const nsCSSFrameConstructor::FrameConstructionData*
 86029: nsCSSFrameConstructor::FindCanvasData(Element* aElement,
 86029:                                       nsStyleContext* aStyleContext)
 86029: {
 91978:   // We want to check whether script is enabled on the document that
 91978:   // could be painting to the canvas.  That's the owner document of
 91978:   // the canvas, except when the owner document is a static document,
 91978:   // in which case it's the original document it was cloned from.
 91978:   nsIDocument* doc = aElement->OwnerDoc();
 91978:   if (doc->IsStaticDocument()) {
 91978:     doc = doc->GetOriginalDocument();
 91978:   }
 91978:   if (!doc->IsScriptEnabled()) {
106838:     return nullptr;
 86029:   }
 86029: 
 86029:   static const FrameConstructionData sCanvasData =
 91306:     FCDATA_WITH_WRAPPING_BLOCK(0, NS_NewHTMLCanvasFrame,
 91306:                                nsCSSAnonBoxes::htmlCanvasContent);
 86029:   return &sCanvasData;
 86029: }
 86029: 
 23944: nsresult
 25769: nsCSSFrameConstructor::ConstructFrameFromItemInternal(FrameConstructionItem& aItem,
 23944:                                                       nsFrameConstructorState& aState,
     1:                                                       nsIFrame* aParentFrame,
 26208:                                                       nsFrameItems& aFrameItems)
     1: {
 25769:   const FrameConstructionData* data = aItem.mFCData;
 25769:   NS_ASSERTION(data, "Must have frame construction data");
 25769: 
108991:   uint32_t bits = data->mBits;
 23944: 
 23944:   NS_ASSERTION(!(bits & FCDATA_FUNC_IS_DATA_GETTER),
 23944:                "Should have dealt with this inside the data finder");
 23944: 
 23952:   // Some sets of bits are not compatible with each other
 23952: #define CHECK_ONLY_ONE_BIT(_bit1, _bit2)               \
 23952:   NS_ASSERTION(!(bits & _bit1) || !(bits & _bit2),     \
 23952:                "Only one of these bits should be set")
 23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_FORCE_NULL_ABSPOS_CONTAINER);
 23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_WRAP_KIDS_IN_BLOCKS);
 23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_MAY_NEED_SCROLLFRAME);
 23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_IS_POPUP);
 23952:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_SKIP_ABSPOS_PUSH);
 23954:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR,
 23954:                      FCDATA_DISALLOW_GENERATED_CONTENT);
 26207:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR, FCDATA_ALLOW_BLOCK_STYLES);
 90621:   CHECK_ONLY_ONE_BIT(FCDATA_FUNC_IS_FULL_CTOR,
 90621:                      FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS);
 90621:   CHECK_ONLY_ONE_BIT(FCDATA_WRAP_KIDS_IN_BLOCKS,
 90621:                      FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS);
 23952: #undef CHECK_ONLY_ONE_BIT
 58471:   NS_ASSERTION(!(bits & FCDATA_FORCED_NON_SCROLLABLE_BLOCK) ||
 58471:                ((bits & FCDATA_FUNC_IS_FULL_CTOR) &&
 58471:                 data->mFullConstructor ==
 58471:                   &nsCSSFrameConstructor::ConstructNonScrollableBlock),
 58471:                "Unexpected FCDATA_FORCED_NON_SCROLLABLE_BLOCK flag");
 23952: 
 56440:   // Don't create a subdocument frame for iframes if we're creating extra frames
 56440:   if (aState.mCreatingExtraFrames && aItem.mContent->IsHTML() &&
 56440:       aItem.mContent->Tag() == nsGkAtoms::iframe)
 56440:   {
 56440:     return NS_OK;
 56440:   }
 56440: 
 25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
132812:   const nsStyleDisplay* display = styleContext->StyleDisplay();
 92183:   nsIContent* const content = aItem.mContent;
 92183: 
 92183:   // Push the content as a style ancestor now, so we don't have to do
 92183:   // it in our various full-constructor functions.  In particular,
 92183:   // since a number of full-constructor functions don't actually call
 92183:   // ProcessChildren in some cases (e.g. for CSS anonymous table boxes
 92183:   // or for situations where only anonymouse children are having
 92183:   // frames constructed), this is the best place to bottleneck the
 92183:   // pushing of the content instead of having to do it in multiple
 92183:   // places.
128828:   TreeMatchContext::AutoAncestorPusher
 92183:     ancestorPusher(aState.mTreeMatchContext.mAncestorFilter.HasFilter(),
128828:                    aState.mTreeMatchContext,
106838:                    content->IsElement() ? content->AsElement() : nullptr);
 23944: 
 23944:   nsIFrame* newFrame;
 36793:   nsIFrame* primaryFrame;
 23944:   if (bits & FCDATA_FUNC_IS_FULL_CTOR) {
 23944:     nsresult rv =
 25769:       (this->*(data->mFullConstructor))(aState, aItem, aParentFrame,
 25131:                                         display, aFrameItems, &newFrame);
 23944:     if (NS_FAILED(rv)) {
 23944:       return rv;
 23944:     }
 36793: 
 36793:     primaryFrame = newFrame;
 23944:   } else {
 23944:     newFrame =
 25769:       (*data->mFunc.mCreationFunc)(mPresShell, styleContext);
 23944: 
 79445:     bool allowOutOfFlow = !(bits & FCDATA_DISALLOW_OUT_OF_FLOW);
 79445:     bool isPopup = aItem.mIsPopup;
 23952:     NS_ASSERTION(!isPopup ||
 23952:                  (aState.mPopupItems.containingBlock &&
 23952:                   aState.mPopupItems.containingBlock->GetType() ==
 23952:                     nsGkAtoms::popupSetFrame),
 23952:                  "Should have a containing block here!");
 23952: 
 23944:     nsIFrame* geometricParent =
 23952:       isPopup ? aState.mPopupItems.containingBlock :
 23952:       (allowOutOfFlow ? aState.GetGeometricParent(display, aParentFrame)
 23952:                       : aParentFrame);
 23952: 
 23952:     nsresult rv = NS_OK;
 23952: 
 23952:     // Must init frameToAddToList to null, since it's inout
106838:     nsIFrame* frameToAddToList = nullptr;
 23952:     if ((bits & FCDATA_MAY_NEED_SCROLLFRAME) &&
 23952:         display->IsScrollableOverflow()) {
 25769:       BuildScrollFrame(aState, content, styleContext, newFrame,
 23952:                        geometricParent, frameToAddToList);
 23952:     } else {
106838:       rv = InitAndRestoreFrame(aState, content, geometricParent, nullptr,
 23944:                                newFrame);
     1:       NS_ASSERTION(NS_SUCCEEDED(rv), "InitAndRestoreFrame failed");
 23944:       // See whether we need to create a view
 80486:       nsContainerFrame::CreateViewForFrame(newFrame, false);
 23952:       frameToAddToList = newFrame;
 23952:     }
 23952: 
 36793:     // Use frameToAddToList as the primary frame.  In the non-scrollframe case
 36793:     // they're equal, but in the scrollframe case newFrame is the scrolled
 36793:     // frame, while frameToAddToList is the scrollframe (and should be the
 36793:     // primary frame).
 36793:     primaryFrame = frameToAddToList;
 36793: 
 90621:     // If we need to create a block formatting context to wrap our
 90621:     // kids, do it now.
 90621:     const nsStyleDisplay* maybeAbsoluteContainingBlockDisplay = display;
 90621:     nsIFrame* maybeAbsoluteContainingBlock = newFrame;
 90621:     nsIFrame* possiblyLeafFrame = newFrame;
 90621:     if (bits & FCDATA_CREATE_BLOCK_WRAPPER_FOR_ALL_KIDS) {
 90621:       nsRefPtr<nsStyleContext> blockContext;
 90621:       blockContext =
 90621:         mPresShell->StyleSet()->ResolveAnonymousBoxStyle(*data->mAnonBoxPseudo,
 90621:                                                          styleContext);
 90621:       nsIFrame* blockFrame =
 90621:         NS_NewBlockFormattingContext(mPresShell, blockContext);
120353:       if (MOZ_UNLIKELY(!blockFrame)) {
 90621:         primaryFrame->Destroy();
 90621:         return NS_ERROR_OUT_OF_MEMORY;
 90621:       }
 90621: 
106838:       rv = InitAndRestoreFrame(aState, content, newFrame, nullptr, blockFrame);
 90621:       if (NS_FAILED(rv)) {
 90621:         blockFrame->Destroy();
 90621:         primaryFrame->Destroy();
 90621:         return rv;
 90621:       }
 90621: 
 90621:       SetInitialSingleChild(newFrame, blockFrame);
 90621: 
 90621:       // Now figure out whether newFrame or blockFrame should be the
 90621:       // absolute container.  It should be the latter if it's
 90621:       // positioned, otherwise the former.
132812:       const nsStyleDisplay* blockDisplay = blockContext->StyleDisplay();
107225:       if (blockDisplay->IsPositioned(blockFrame)) {
 90621:         maybeAbsoluteContainingBlockDisplay = blockDisplay;
 90621:         maybeAbsoluteContainingBlock = blockFrame;
 90621:       }
 90621:       
 90621:       // Our kids should go into the blockFrame
 90621:       newFrame = blockFrame;
 90621:     }
 90621: 
 25769:     rv = aState.AddChild(frameToAddToList, aFrameItems, content, styleContext,
 23952:                          aParentFrame, allowOutOfFlow, allowOutOfFlow, isPopup);
     1:     if (NS_FAILED(rv)) {
     1:       return rv;
     1:     }
 23167: 
 23952: #ifdef MOZ_XUL
 23952:     // Icky XUL stuff, sadly
 25768: 
 25769:     if (aItem.mIsRootPopupgroup) {
 25768:       NS_ASSERTION(nsIRootBox::GetRootBox(mPresShell) &&
 25768:                    nsIRootBox::GetRootBox(mPresShell)->GetPopupSetFrame() ==
 25768:                      newFrame,
 23952:                    "Unexpected PopupSetFrame");
 25768:       aState.mPopupItems.containingBlock = newFrame;
 80486:       aState.mHavePendingPopupgroup = false;
 23952:     }
 23952: #endif /* MOZ_XUL */
     1: 
     1:     // Process the child content if requested
     1:     nsFrameItems childItems;
     1:     nsFrameConstructorSaveState absoluteSaveState;
 23343: 
 23944:     if (bits & FCDATA_FORCE_NULL_ABSPOS_CONTAINER) {
106838:       aState.PushAbsoluteContainingBlock(nullptr, absoluteSaveState);
120781:     } else if (!(bits & FCDATA_SKIP_ABSPOS_PUSH)) {
120781:       nsIFrame* cb = maybeAbsoluteContainingBlock;
120781:       cb->AddStateBits(NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
120781:       if (maybeAbsoluteContainingBlockDisplay->IsPositioned(cb)) {
120781:         aState.PushAbsoluteContainingBlock(cb, absoluteSaveState);
120781:       }
     1:     }
 23352: 
 26208:     if (bits & FCDATA_USE_CHILD_ITEMS) {
103018:       NS_ASSERTION(!ShouldSuppressFloatingOfDescendants(newFrame),
103018:                    "uh oh -- this frame is supposed to _suppress_ floats, but "
103018:                    "we're about to push it as a float containing block...");
103018: 
103018:       nsFrameConstructorSaveState floatSaveState;
103018:       if (newFrame->IsFloatContainingBlock()) {
103018:         aState.PushFloatContainingBlock(newFrame, floatSaveState);
103018:       }
 26208:       rv = ConstructFramesFromItemList(aState, aItem.mChildItems, newFrame,
 26208:                                        childItems);
 26208:     } else {
 26207:       // Process the child frames.
 25769:       rv = ProcessChildren(aState, content, styleContext, newFrame,
 23954:                            !(bits & FCDATA_DISALLOW_GENERATED_CONTENT),
 26207:                            childItems,
 34614:                            (bits & FCDATA_ALLOW_BLOCK_STYLES) != 0,
 90621:                            aItem.mPendingBinding, possiblyLeafFrame);
 26208:     }
 23167: 
 23952: #ifdef MOZ_XUL
 23952:     // More icky XUL stuff
 25769:     if (aItem.mNameSpaceID == kNameSpaceID_XUL &&
 25769:         (aItem.mTag == nsGkAtoms::treechildren || // trees always need titletips
 25769:          content->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltiptext) ||
 25769:          content->HasAttr(kNameSpaceID_None, nsGkAtoms::tooltip))) {
 23952:       nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
 23952:       if (rootBox) {
 25769:         rootBox->AddTooltipSupport(content);
 23952:       }
 23952:     }
 23952: #endif
 23952: 
 23946:     if (NS_SUCCEEDED(rv) && (bits & FCDATA_WRAP_KIDS_IN_BLOCKS)) {
 23946:       nsFrameItems newItems;
 93793:       nsFrameItems currentBlockItems;
 23946:       nsIFrame* f;
106838:       while ((f = childItems.FirstChild()) != nullptr) {
 79445:         bool wrapFrame = IsInlineFrame(f) || IsFrameSpecial(f);
 23946:         if (!wrapFrame) {
 93793:           rv = FlushAccumulatedBlock(aState, content, newFrame,
 93793:                                      currentBlockItems, newItems);
 23946:           if (NS_FAILED(rv))
 23946:             break;
 23946:         }
 23946: 
 33388:         childItems.RemoveFrame(f);
 23946:         if (wrapFrame) {
 93793:           currentBlockItems.AddChild(f);
 23946:         } else {
 23946:           newItems.AddChild(f);
 23946:         }
 23946:       }
 93793:       rv = FlushAccumulatedBlock(aState, content, newFrame,
 93793:                                  currentBlockItems, newItems);
 23946: 
 30785:       if (childItems.NotEmpty()) {
 23946:         // an error must have occurred, delete unprocessed frames
 30785:         childItems.DestroyFrames();
 23946:       }
 23946: 
 23946:       childItems = newItems;
 23946:     }
     1: 
     1:     // Set the frame's initial child list
 23946:     // Note that MathML depends on this being called even if
 30785:     // childItems is empty!
 77155:     newFrame->SetInitialChildList(kPrincipalList, childItems);
     1:   }
 23167: 
 25773:   NS_ASSERTION(newFrame->IsFrameOfType(nsIFrame::eLineParticipant) ==
 25773:                ((bits & FCDATA_IS_LINE_PARTICIPANT) != 0),
 25773:                "Incorrectly set FCDATA_IS_LINE_PARTICIPANT bits");
 25773: 
 74643:   // Even if mCreatingExtraFrames is set, we may need to SetPrimaryFrame for
 74643:   // generated content that doesn't have one yet.  Note that we have to examine
 74643:   // the frame bit, because by this point mIsGeneratedContent has been cleared
 74643:   // on aItem.
 74643:   if ((!aState.mCreatingExtraFrames ||
 74643:        ((primaryFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) &&
 74643:         !aItem.mContent->GetPrimaryFrame())) &&
 74643:        !(bits & FCDATA_SKIP_FRAMESET)) {
 36793:     aItem.mContent->SetPrimaryFrame(primaryFrame);
     1:   }
     1: 
 23944:   return NS_OK;
     1: }
     1: 
     1: // after the node has been constructed and initialized create any
     1: // anonymous content a node needs.
     1: nsresult
     1: nsCSSFrameConstructor::CreateAnonymousFrames(nsFrameConstructorState& aState,
     1:                                              nsIContent*              aParent,
     1:                                              nsIFrame*                aParentFrame,
 34614:                                              PendingBinding*          aPendingBinding,
     1:                                              nsFrameItems&            aChildItems)
     1: {
 69438:   nsAutoTArray<nsIAnonymousContentCreator::ContentInfo, 4> newAnonymousItems;
 25768:   nsresult rv = GetAnonymousContent(aParent, aParentFrame, newAnonymousItems);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
108991:   uint32_t count = newAnonymousItems.Length();
     1:   if (count == 0) {
     1:     return NS_OK;
     1:   }
     1: 
 34614:   nsFrameConstructorState::PendingBindingAutoPusher pusher(aState,
 34614:                                                            aPendingBinding);
128828:   TreeMatchContext::AutoAncestorPusher
 92183:     ancestorPusher(aState.mTreeMatchContext.mAncestorFilter.HasFilter(),
128828:                    aState.mTreeMatchContext,
 92183:                    aParent->AsElement());
 34614: 
 25768:   nsIAnonymousContentCreator* creator = do_QueryFrame(aParentFrame);
 25768:   NS_ASSERTION(creator,
 25768:                "How can that happen if we have nodes to construct frames for?");
 25768: 
108991:   for (uint32_t i=0; i < count; i++) {
 69438:     nsIContent* content = newAnonymousItems[i].mContent;
 25768:     NS_ASSERTION(content, "null anonymous content?");
 69438:     NS_ASSERTION(!newAnonymousItems[i].mStyleContext, "Unexpected style context");
 25768: 
 25768:     nsIFrame* newFrame = creator->CreateFrameFor(content);
 25768:     if (newFrame) {
 42522:       NS_ASSERTION(content->GetPrimaryFrame(),
 42522:                    "Content must have a primary frame now");
 25768:       aChildItems.AddChild(newFrame);
 25768:     }
 25768:     else {
 25768:       // create the frame and attach it to our frame
 25768:       ConstructFrame(aState, content, aParentFrame, aChildItems);
 25768:     }
 25768:   }
 25768: 
 25768:   return NS_OK;
 25768: }
 25768: 
 98127: static void
115682: SetFlagsOnSubtree(nsIContent *aNode, uintptr_t aFlagsToSet)
 98127: {
 98127: #ifdef DEBUG
 98127:   // Make sure that the node passed to us doesn't have any XBL children
 98127:   {
 98127:     nsIDocument *doc = aNode->OwnerDoc();
 98127:     NS_ASSERTION(doc, "The node must be in a document");
 98127:     NS_ASSERTION(!doc->BindingManager()->GetXBLChildNodesFor(aNode),
 98127:                  "The node should not have any XBL children");
 98127:   }
 98127: #endif
 98127: 
 98127:   // Set the flag on the node itself
 98127:   aNode->SetFlags(aFlagsToSet);
 98127: 
 98127:   // Set the flag on all of its children recursively
108991:   uint32_t count;
 98127:   nsIContent * const *children = aNode->GetChildArray(&count);
 98127: 
108991:   for (uint32_t index = 0; index < count; ++index) {
 98127:     SetFlagsOnSubtree(children[index], aFlagsToSet);
 98127:   }
 98127: }
 98127: 
 25768: nsresult
 25768: nsCSSFrameConstructor::GetAnonymousContent(nsIContent* aParent,
 25768:                                            nsIFrame* aParentFrame,
 69438:                                            nsTArray<nsIAnonymousContentCreator::ContentInfo>& aContent)
 25768: {
 25768:   nsIAnonymousContentCreator* creator = do_QueryFrame(aParentFrame);
 25768:   if (!creator)
 25768:     return NS_OK;
 25768: 
 25768:   nsresult rv = creator->CreateAnonymousContent(aContent);
 25768:   NS_ENSURE_SUCCESS(rv, rv);
 25768: 
108991:   uint32_t count = aContent.Length();
108991:   for (uint32_t i=0; i < count; i++) {
     1:     // get our child's content and set its parent to our content
 69438:     nsIContent* content = aContent[i].mContent;
     1:     NS_ASSERTION(content, "null anonymous content?");
     1: 
     1:     // least-surprise CSS binding until we do the SVG specified
     1:     // cascading rules for <svg:use> - bug 265894
119545:     if (aParentFrame->GetType() == nsGkAtoms::svgUseFrame) {
 25511:       content->SetFlags(NODE_IS_ANONYMOUS);
 58951:     } else {
 12250:       content->SetNativeAnonymous();
 12250:     }
     1: 
 98127:     bool anonContentIsEditable = content->HasFlag(NODE_IS_EDITABLE);
 80486:     rv = content->BindToTree(mDocument, aParent, aParent, true);
 98127:     // If the anonymous content creator requested that the content should be
 98127:     // editable, honor its request.
 98127:     // We need to set the flag on the whole subtree, because existing
 98127:     // children's flags have already been set as part of the BindToTree operation.
 98127:     if (anonContentIsEditable) {
 98127:       NS_ASSERTION(aParentFrame->GetType() == nsGkAtoms::textInputFrame,
 98127:                    "We only expect this for anonymous content under a text control frame");
 98127:       SetFlagsOnSubtree(content, NODE_IS_EDITABLE);
 98127:     }
     1:     if (NS_FAILED(rv)) {
     1:       content->UnbindFromTree();
     1:       return rv;
     1:     }
 25768:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: static
 79445: bool IsXULDisplayType(const nsStyleDisplay* aDisplay)
     1: {
     1:   return (aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX || 
 25114: #ifdef MOZ_XUL
     1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_GRID || 
     1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_INLINE_STACK ||
 25114: #endif
 25114:           aDisplay->mDisplay == NS_STYLE_DISPLAY_BOX
 25114: #ifdef MOZ_XUL
 25114:           || aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID ||
     1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_STACK ||
     1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID_GROUP ||
     1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GRID_LINE ||
     1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_DECK ||
     1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_POPUP ||
     1:           aDisplay->mDisplay == NS_STYLE_DISPLAY_GROUPBOX
 25114: #endif
     1:           );
     1: }
     1: 
 23952: 
 23952: // XUL frames are not allowed to be out of flow.
 23952: #define SIMPLE_XUL_FCDATA(_func)                                        \
 23952:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH,    \
 23952:               _func)
 23952: #define SCROLLABLE_XUL_FCDATA(_func)                                    \
 23952:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH |   \
 23952:               FCDATA_MAY_NEED_SCROLLFRAME, _func)
 92005: // .. but we allow some XUL frames to be _containers_ for out-of-flow content
 92005: // (This is the same as SCROLLABLE_XUL_FCDATA, but w/o FCDATA_SKIP_ABSPOS_PUSH)
 92005: #define SCROLLABLE_ABSPOS_CONTAINER_XUL_FCDATA(_func)                   \
 92005:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW |                             \
 92005:               FCDATA_MAY_NEED_SCROLLFRAME, _func)
 92005: 
 23952: #define SIMPLE_XUL_CREATE(_tag, _func)            \
 23952:   { &nsGkAtoms::_tag, SIMPLE_XUL_FCDATA(_func) }
 23952: #define SCROLLABLE_XUL_CREATE(_tag, _func)            \
 23952:   { &nsGkAtoms::_tag, SCROLLABLE_XUL_FCDATA(_func) }
 23952: #define SIMPLE_XUL_INT_CREATE(_int, _func)      \
 23952:   { _int, SIMPLE_XUL_FCDATA(_func) }
 23952: #define SCROLLABLE_XUL_INT_CREATE(_int, _func)                          \
 23952:   { _int, SCROLLABLE_XUL_FCDATA(_func) }
 92005: #define SCROLLABLE_ABSPOS_CONTAINER_XUL_INT_CREATE(_int, _func)         \
 92005:   { _int, SCROLLABLE_ABSPOS_CONTAINER_XUL_FCDATA(_func) }
 23952: 
 23952: static
 23952: nsIFrame* NS_NewGridBoxFrame(nsIPresShell* aPresShell,
 23952:                              nsStyleContext* aStyleContext)
 23952: {
 73636:   nsCOMPtr<nsBoxLayout> layout;
 23952:   NS_NewGridLayout2(aPresShell, getter_AddRefs(layout));
 80486:   return NS_NewBoxFrame(aPresShell, aStyleContext, false, layout);
 23952: }
 23952: 
 23952: /* static */
 23952: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindXULTagData(Element* aElement,
     1:                                       nsIAtom* aTag,
108991:                                       int32_t aNameSpaceID,
 23952:                                       nsStyleContext* aStyleContext)
 23952: {
 23952:   if (aNameSpaceID != kNameSpaceID_XUL) {
106838:     return nullptr;
 23952:   }
 23952: 
 23952:   static const FrameConstructionDataByTag sXULTagData[] = {
     1: #ifdef MOZ_XUL
 23952:     SCROLLABLE_XUL_CREATE(button, NS_NewButtonBoxFrame),
 23952:     SCROLLABLE_XUL_CREATE(checkbox, NS_NewButtonBoxFrame),
 23952:     SCROLLABLE_XUL_CREATE(radio, NS_NewButtonBoxFrame),
 23952:     SCROLLABLE_XUL_CREATE(autorepeatbutton, NS_NewAutoRepeatBoxFrame),
 23952:     SCROLLABLE_XUL_CREATE(titlebar, NS_NewTitleBarFrame),
 23952:     SCROLLABLE_XUL_CREATE(resizer, NS_NewResizerFrame),
 23952:     SIMPLE_XUL_CREATE(image, NS_NewImageBoxFrame),
 23952:     SIMPLE_XUL_CREATE(spring, NS_NewLeafBoxFrame),
 23952:     SIMPLE_XUL_CREATE(spacer, NS_NewLeafBoxFrame),
 23952:     SIMPLE_XUL_CREATE(treechildren, NS_NewTreeBodyFrame),
 23952:     SIMPLE_XUL_CREATE(treecol, NS_NewTreeColFrame),
 23952:     SIMPLE_XUL_CREATE(text, NS_NewTextBoxFrame),
 23952:     SIMPLE_TAG_CHAIN(label, nsCSSFrameConstructor::FindXULLabelData),
 23952:     SIMPLE_TAG_CHAIN(description, nsCSSFrameConstructor::FindXULDescriptionData),
 23952:     SIMPLE_XUL_CREATE(menu, NS_NewMenuFrame),
 23952:     SIMPLE_XUL_CREATE(menubutton, NS_NewMenuFrame),
 23952:     SIMPLE_XUL_CREATE(menuitem, NS_NewMenuItemFrame),
     1: #ifdef XP_MACOSX
 23952:     SIMPLE_TAG_CHAIN(menubar, nsCSSFrameConstructor::FindXULMenubarData),
 23952: #else
 23952:     SIMPLE_XUL_CREATE(menubar, NS_NewMenuBarFrame),
 23952: #endif /* XP_MACOSX */
 23952:     SIMPLE_TAG_CHAIN(popupgroup, nsCSSFrameConstructor::FindPopupGroupData),
 23952:     SIMPLE_XUL_CREATE(iframe, NS_NewSubDocumentFrame),
 23952:     SIMPLE_XUL_CREATE(editor, NS_NewSubDocumentFrame),
 23952:     SIMPLE_XUL_CREATE(browser, NS_NewSubDocumentFrame),
 23952:     SIMPLE_XUL_CREATE(progressmeter, NS_NewProgressMeterFrame),
 23952:     SIMPLE_XUL_CREATE(splitter, NS_NewSplitterFrame),
 23952:     SIMPLE_TAG_CHAIN(listboxbody,
 23952:                      nsCSSFrameConstructor::FindXULListBoxBodyData),
 23952:     SIMPLE_TAG_CHAIN(listitem, nsCSSFrameConstructor::FindXULListItemData),
 23952: #endif /* MOZ_XUL */
 23952:     SIMPLE_XUL_CREATE(slider, NS_NewSliderFrame),
 23952:     SIMPLE_XUL_CREATE(scrollbar, NS_NewScrollbarFrame),
 23952:     SIMPLE_XUL_CREATE(scrollbarbutton, NS_NewScrollbarButtonFrame)
 23952: };
 23952: 
 63575:   return FindDataByTag(aTag, aElement, aStyleContext, sXULTagData,
 80467:                        ArrayLength(sXULTagData));
 23952: }
 23952: 
 23952: #ifdef MOZ_XUL
 23952: /* static */
 23952: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindPopupGroupData(Element* aElement,
 23952:                                           nsStyleContext* /* unused */)
 23952: {
 63575:   if (!aElement->IsRootOfNativeAnonymousSubtree()) {
106838:     return nullptr;
 23952:   }
 23952: 
 23952:   static const FrameConstructionData sPopupSetData =
 23952:     SIMPLE_XUL_FCDATA(NS_NewPopupSetFrame);
 23952:   return &sPopupSetData;
 23952: }
 23952: 
 23952: /* static */
 23952: const nsCSSFrameConstructor::FrameConstructionData
 23952: nsCSSFrameConstructor::sXULTextBoxData = SIMPLE_XUL_FCDATA(NS_NewTextBoxFrame);
 23952: 
 23952: /* static */
 23952: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindXULLabelData(Element* aElement,
 23952:                                         nsStyleContext* /* unused */)
 23952: {
 63575:   if (aElement->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
 23952:     return &sXULTextBoxData;
 23952:   }
 23952: 
 23952:   static const FrameConstructionData sLabelData =
 23952:     SIMPLE_XUL_FCDATA(NS_NewXULLabelFrame);
 23952:   return &sLabelData;
 23952: }
 23952: 
 23952: static nsIFrame*
 23952: NS_NewXULDescriptionFrame(nsIPresShell* aPresShell, nsStyleContext *aContext)
 23952: {
 23952:   // XXXbz do we really need to set those flags?  If the parent is not
 23952:   // a block we'll get them anyway, and if it is, do we want them?
 23952:   return NS_NewBlockFrame(aPresShell, aContext,
 23952:                           NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
 23952: }
 23952: 
 23952: /* static */
 23952: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindXULDescriptionData(Element* aElement,
 23952:                                               nsStyleContext* /* unused */)
 23952: {
 63575:   if (aElement->HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
 23952:     return &sXULTextBoxData;
 23952:   }
 23952: 
 23952:   static const FrameConstructionData sDescriptionData =
 23952:     SIMPLE_XUL_FCDATA(NS_NewXULDescriptionFrame);
 23952:   return &sDescriptionData;
 23952: }
 23952: 
 23952: #ifdef XP_MACOSX
 23952: /* static */
 23952: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindXULMenubarData(Element* aElement,
 23952:                                           nsStyleContext* aStyleContext)
 23952: {
 23952:   nsCOMPtr<nsISupports> container =
 23952:     aStyleContext->PresContext()->GetContainer();
     1:   if (container) {
     1:     nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
     1:     if (treeItem) {
108991:       int32_t type;
     1:       treeItem->GetItemType(&type);
     1:       if (nsIDocShellTreeItem::typeChrome == type) {
     1:         nsCOMPtr<nsIDocShellTreeItem> parent;
     1:         treeItem->GetParent(getter_AddRefs(parent));
 23952:         if (!parent) {
 23952:           // This is the root.  Suppress the menubar, since on Mac
 23952:           // window menus are not attached to the window.
 23952:           static const FrameConstructionData sSuppressData = SUPPRESS_FCDATA();
 23952:           return &sSuppressData;
 23952:         }
 23952:       }
 23952:     }
 23952:   }
 23952: 
 23952:   static const FrameConstructionData sMenubarData =
 23952:     SIMPLE_XUL_FCDATA(NS_NewMenuBarFrame);
 23952:   return &sMenubarData;
 23952: }
 23952: #endif /* XP_MACOSX */
 23952: 
 23952: /* static */
 23952: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindXULListBoxBodyData(Element* aElement,
 23952:                                               nsStyleContext* aStyleContext)
 23952: {
132812:   if (aStyleContext->StyleDisplay()->mDisplay !=
 23952:         NS_STYLE_DISPLAY_GRID_GROUP) {
106838:     return nullptr;
 23952:   }
 23952: 
 23952:   static const FrameConstructionData sListBoxBodyData =
 23952:     SCROLLABLE_XUL_FCDATA(NS_NewListBoxBodyFrame);
 23952:   return &sListBoxBodyData;
 23952: }
 23952: 
 23952: /* static */
 23952: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindXULListItemData(Element* aElement,
 23952:                                            nsStyleContext* aStyleContext)
 23952: {
132812:   if (aStyleContext->StyleDisplay()->mDisplay !=
 23952:         NS_STYLE_DISPLAY_GRID_LINE) {
106838:     return nullptr;
 23952:   }
 23952: 
 23952:   static const FrameConstructionData sListItemData =
 23952:     SCROLLABLE_XUL_FCDATA(NS_NewListItemFrame);
 23952:   return &sListItemData;
 23952: }
 23952: 
 23952: #endif /* MOZ_XUL */
 23952: 
 23952: /* static */
 23952: const nsCSSFrameConstructor::FrameConstructionData*
 23955: nsCSSFrameConstructor::FindXULDisplayData(const nsStyleDisplay* aDisplay,
 63575:                                           Element* aElement,
 23952:                                           nsStyleContext* aStyleContext)
 23952: {
 23952:   static const FrameConstructionDataByInt sXULDisplayData[] = {
 92005:     SCROLLABLE_ABSPOS_CONTAINER_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_BOX,
 92005:                                                NS_NewBoxFrame),
 92005:     SCROLLABLE_ABSPOS_CONTAINER_XUL_INT_CREATE(NS_STYLE_DISPLAY_BOX,
 92005:                                                NS_NewBoxFrame),
     1: #ifdef MOZ_XUL
 23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_GRID, NS_NewGridBoxFrame),
 23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID, NS_NewGridBoxFrame),
 23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID_GROUP,
 23952:                               NS_NewGridRowGroupFrame),
 23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GRID_LINE,
 23952:                               NS_NewGridRowLeafFrame),
 23952:     SIMPLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_DECK, NS_NewDeckFrame),
 23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_GROUPBOX, NS_NewGroupBoxFrame),
 23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_INLINE_STACK, NS_NewStackFrame),
 23952:     SCROLLABLE_XUL_INT_CREATE(NS_STYLE_DISPLAY_STACK, NS_NewStackFrame),
 23952:     { NS_STYLE_DISPLAY_POPUP,
 23952:       FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_IS_POPUP |
 23952:                   FCDATA_SKIP_ABSPOS_PUSH, NS_NewMenuPopupFrame) }
 23952: #endif /* MOZ_XUL */
 23952:   };
 23952: 
 23952:   // Processing by display here:
 63575:   return FindDataByInt(aDisplay->mDisplay, aElement, aStyleContext,
 80467:                        sXULDisplayData, ArrayLength(sXULDisplayData));
     1: }
     1: 
     1: already_AddRefed<nsStyleContext>
     1: nsCSSFrameConstructor::BeginBuildingScrollFrame(nsFrameConstructorState& aState,
     1:                                                 nsIContent*              aContent,
     1:                                                 nsStyleContext*          aContentStyle,
     1:                                                 nsIFrame*                aParentFrame,
     1:                                                 nsIAtom*                 aScrolledPseudo,
 79445:                                                 bool                     aIsRoot,
     1:                                                 nsIFrame*&               aNewFrame)
     1: {
     1:   nsIFrame* gfxScrollFrame = aNewFrame;
     1: 
     1:   nsFrameItems anonymousItems;
     1: 
     1:   nsRefPtr<nsStyleContext> contentStyle = aContentStyle;
     1: 
     1:   if (!gfxScrollFrame) {
     1:     // Build a XULScrollFrame when the child is a box, otherwise an
     1:     // HTMLScrollFrame
 25114:     // XXXbz this is the lone remaining consumer of IsXULDisplayType.
 25114:     // I wonder whether we can eliminate that somehow.
132812:     if (IsXULDisplayType(aContentStyle->StyleDisplay())) {
     1:       gfxScrollFrame = NS_NewXULScrollFrame(mPresShell, contentStyle, aIsRoot);
     1:     } else {
     1:       gfxScrollFrame = NS_NewHTMLScrollFrame(mPresShell, contentStyle, aIsRoot);
     1:     }
     1: 
106838:     InitAndRestoreFrame(aState, aContent, aParentFrame, nullptr, gfxScrollFrame);
     1:   }
     1: 
     1:   // if there are any anonymous children for the scroll frame, create
     1:   // frames for them.
 34614:   // Pass a null pending binding: we don't care how constructors for any of
 34614:   // this anonymous content order with anything else.  It's never been
 34614:   // consistent anyway.
106838:   CreateAnonymousFrames(aState, aContent, gfxScrollFrame, nullptr,
 34614:                         anonymousItems);
     1: 
     1:   aNewFrame = gfxScrollFrame;
     1: 
     1:   // we used the style that was passed in. So resolve another one.
     1:   nsStyleSet *styleSet = mPresShell->StyleSet();
 35554:   nsStyleContext* aScrolledChildStyle =
 35554:     styleSet->ResolveAnonymousBoxStyle(aScrolledPseudo, contentStyle).get();
     1: 
     1:   if (gfxScrollFrame) {
 77155:      gfxScrollFrame->SetInitialChildList(kPrincipalList, anonymousItems);
     1:   }
     1: 
     1:   return aScrolledChildStyle;
     1: }
     1: 
     1: void
     1: nsCSSFrameConstructor::FinishBuildingScrollFrame(nsIFrame* aScrollFrame,
     1:                                                  nsIFrame* aScrolledFrame)
     1: {
 32846:   nsFrameList scrolled(aScrolledFrame, aScrolledFrame);
 77155:   aScrollFrame->AppendFrames(kPrincipalList, scrolled);
     1: }
     1: 
     1: 
     1: /**
     1:  * Called to wrap a gfx scrollframe around a frame. The hierarchy will look like this
     1:  *
     1:  * ------- for gfx scrollbars ------
     1:  *
     1:  *
     1:  *            ScrollFrame
     1:  *                 ^
     1:  *                 |
     1:  *               Frame (scrolled frame you passed in)
     1:  *
     1:  *
     1:  *-----------------------------------
     1:  * LEGEND:
     1:  * 
     1:  * ScrollFrame: This is a frame that manages gfx cross platform frame based scrollbars.
     1:  *
     1:  * @param aContent the content node of the child to wrap.
     1:  * @param aScrolledFrame The frame of the content to wrap. This should not be
     1:  *                    Initialized. This method will initialize it with a scrolled pseudo
     1:  *                    and no nsIContent. The content will be attached to the scrollframe 
     1:  *                    returned.
     1:  * @param aContentStyle the style context that has already been resolved for the content being passed in.
     1:  *
     1:  * @param aParentFrame The parent to attach the scroll frame to
     1:  *
     1:  * @param aNewFrame The new scrollframe or gfx scrollframe that we create. It will contain the
     1:  *                  scrolled frame you passed in. (returned)
     1:  *                  If this is not null, we'll just use it
     1:  * @param aScrolledContentStyle the style that was resolved for the scrolled frame. (returned)
     1:  */
     1: nsresult
     1: nsCSSFrameConstructor::BuildScrollFrame(nsFrameConstructorState& aState,
     1:                                         nsIContent*              aContent,
     1:                                         nsStyleContext*          aContentStyle,
     1:                                         nsIFrame*                aScrolledFrame,
     1:                                         nsIFrame*                aParentFrame,
 23950:                                         nsIFrame*&               aNewFrame)
     1: {
     1:     nsRefPtr<nsStyleContext> scrolledContentStyle =
     1:       BeginBuildingScrollFrame(aState, aContent, aContentStyle, aParentFrame,
 23395:                                nsCSSAnonBoxes::scrolledContent,
 80486:                                false, aNewFrame);
     1:     
     1:     aScrolledFrame->SetStyleContextWithoutNotification(scrolledContentStyle);
106838:     InitAndRestoreFrame(aState, aContent, aNewFrame, nullptr, aScrolledFrame);
     1: 
     1:     FinishBuildingScrollFrame(aNewFrame, aScrolledFrame);
     1:     return NS_OK;
     1: }
     1: 
 25131: const nsCSSFrameConstructor::FrameConstructionData*
 25131: nsCSSFrameConstructor::FindDisplayData(const nsStyleDisplay* aDisplay,
 63575:                                        Element* aElement,
107226:                                        nsIFrame* aParentFrame,
 26207:                                        nsStyleContext* aStyleContext)
 25131: {
 26208:   PR_STATIC_ASSERT(eParentTypeCount < (1 << (32 - FCDATA_PARENT_TYPE_OFFSET)));
 26208: 
     1:   // The style system ensures that floated and positioned frames are
     1:   // block-level.
107224:   NS_ASSERTION(!(aDisplay->IsFloatingStyle() ||
107225:                  aDisplay->IsAbsolutelyPositionedStyle()) ||
107226:                aDisplay->IsBlockOutsideStyle(),
     1:                "Style system did not apply CSS2.1 section 9.7 fixups");
     1: 
     1:   // If this is "body", try propagating its scroll style to the viewport
     1:   // Note that we need to do this even if the body is NOT scrollable;
     1:   // it might have dynamically changed from scrollable to not scrollable,
     1:   // and that might need to be propagated.
 25131:   // XXXbz is this the right place to do this?  If this code moves,
 25131:   // make this function static.
 79445:   bool propagatedScrollToViewport = false;
 63575:   if (aElement->IsHTML(nsGkAtoms::body)) {
     1:     propagatedScrollToViewport =
 63575:       PropagateScrollToViewport() == aElement;
     1:   }
     1: 
 55006:   NS_ASSERTION(!propagatedScrollToViewport ||
 55006:                !mPresShell->GetPresContext()->IsPaginated(),
 55006:                "Shouldn't propagate scroll in paginated contexts");
 55006: 
 55014:   // If the frame is a block-level frame and is scrollable, then wrap it in a
 58471:   // scroll frame.
     1:   // XXX Ignore tables for the time being
 25129:   // XXXbz it would be nice to combine this with the other block
 25129:   // case... Think about how do do this?
107226:   if ((aParentFrame ? aDisplay->IsBlockInside(aParentFrame) :
107226:                       aDisplay->IsBlockInsideStyle()) &&
     1:       aDisplay->IsScrollableOverflow() &&
 58471:       !propagatedScrollToViewport) {
 58471:     // Except we don't want to do that for paginated contexts for
 58471:     // frames that are block-outside and aren't frames for native
 58471:     // anonymous stuff.
 58471:     if (mPresShell->GetPresContext()->IsPaginated() &&
107226:         aDisplay->IsBlockOutsideStyle() &&
 63575:         !aElement->IsInNativeAnonymousSubtree()) {
 58471:       static const FrameConstructionData sForcedNonScrollableBlockData =
 58471:         FULL_CTOR_FCDATA(FCDATA_FORCED_NON_SCROLLABLE_BLOCK,
 58471:                          &nsCSSFrameConstructor::ConstructNonScrollableBlock);
 58471:       return &sForcedNonScrollableBlockData;
 58471:     }
 58471: 
 25131:     static const FrameConstructionData sScrollableBlockData =
 25131:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructScrollableBlock);
 25131:     return &sScrollableBlockData;
 25131:   }
 25131: 
 25131:   // Handle various non-scrollable blocks
107226:   if ((aParentFrame ? aDisplay->IsBlockInside(aParentFrame) :
107226:                       aDisplay->IsBlockInsideStyle())) {
 25131:     static const FrameConstructionData sNonScrollableBlockData =
 25131:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructNonScrollableBlock);
 25131:     return &sNonScrollableBlockData;
 25131:   }
 25131: 
 26207:   static const FrameConstructionDataByInt sDisplayData[] = {
 25131:     // To keep the hash table small don't add inline frames (they're
 25131:     // typically things like FONT and B), because we can quickly
 25131:     // find them if we need to.
 25131:     // XXXbz the "quickly" part is a bald-faced lie!
 26207:     { NS_STYLE_DISPLAY_INLINE,
 36653:       FULL_CTOR_FCDATA(FCDATA_IS_INLINE | FCDATA_IS_LINE_PARTICIPANT,
 26207:                        &nsCSSFrameConstructor::ConstructInline) },
103018: #ifdef MOZ_FLEXBOX
103018:     { NS_STYLE_DISPLAY_FLEX,
103018:       FCDATA_DECL(0, NS_NewFlexContainerFrame) },
103018:     { NS_STYLE_DISPLAY_INLINE_FLEX,
103018:       FCDATA_DECL(0, NS_NewFlexContainerFrame) },
103018: #endif // MOZ_FLEXBOX
 26208:     { NS_STYLE_DISPLAY_TABLE,
 26208:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructTable) },
 26208:     { NS_STYLE_DISPLAY_INLINE_TABLE,
 26208:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructTable) },
121232:     // NOTE: In the unlikely event that we add another table-part here that has
121232:     // a desired-parent-type (& hence triggers table fixup), we'll need to also
121232:     // update the flexbox chunk in nsStyleContext::ApplyStyleFixups().
 26207:     { NS_STYLE_DISPLAY_TABLE_CAPTION,
 36653:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_ALLOW_BLOCK_STYLES |
 36653:                   FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_SKIP_ABSPOS_PUSH |
 26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
 26207:                   NS_NewTableCaptionFrame) },
 26207:     { NS_STYLE_DISPLAY_TABLE_ROW_GROUP,
 36653:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_DISALLOW_OUT_OF_FLOW |
 37262:                   FCDATA_SKIP_ABSPOS_PUSH |
 26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
 26207:                   NS_NewTableRowGroupFrame) },
 26207:     { NS_STYLE_DISPLAY_TABLE_HEADER_GROUP,
 36653:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_DISALLOW_OUT_OF_FLOW |
 37262:                   FCDATA_SKIP_ABSPOS_PUSH |
 26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
 26207:                   NS_NewTableRowGroupFrame) },
 26207:     { NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP,
 36653:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_DISALLOW_OUT_OF_FLOW |
 37262:                   FCDATA_SKIP_ABSPOS_PUSH |
 26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
 26207:                   NS_NewTableRowGroupFrame) },
 26207:     { NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP,
 36653:       FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_DISALLOW_OUT_OF_FLOW |
 36653:                   FCDATA_SKIP_ABSPOS_PUSH |
 26208:                   FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
 26207:                   NS_NewTableColGroupFrame) },
 26207:     { NS_STYLE_DISPLAY_TABLE_COLUMN,
 36653:       FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART |
 26208:                        FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeColGroup),
 26207:                        &nsCSSFrameConstructor::ConstructTableCol) },
 26207:     { NS_STYLE_DISPLAY_TABLE_ROW,
 36653:       FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART |
 26208:                        FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRowGroup),
 26207:                        &nsCSSFrameConstructor::ConstructTableRow) },
 26207:     { NS_STYLE_DISPLAY_TABLE_CELL,
 36653:       FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART |
 26208:                        FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRow),
 26207:                        &nsCSSFrameConstructor::ConstructTableCell) }
 26207:   };
 26207: 
107226:   return FindDataByInt((aParentFrame ? aDisplay->GetDisplay(aParentFrame) :
107226:                                        aDisplay->mDisplay),
107226:                        aElement, aStyleContext, sDisplayData,
107226:                        ArrayLength(sDisplayData));
 25131: }
 25131: 
 25131: nsresult
 25131: nsCSSFrameConstructor::ConstructScrollableBlock(nsFrameConstructorState& aState,
 25769:                                                 FrameConstructionItem&   aItem,
 25131:                                                 nsIFrame*                aParentFrame,
 25131:                                                 const nsStyleDisplay*    aDisplay,
 25131:                                                 nsFrameItems&            aFrameItems,
 25131:                                                 nsIFrame**               aNewFrame)
 25131: {
 25769:   nsIContent* const content = aItem.mContent;
 25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
 25769: 
106838:   *aNewFrame = nullptr;
     1:   nsRefPtr<nsStyleContext> scrolledContentStyle
 25769:     = BeginBuildingScrollFrame(aState, content, styleContext,
     1:                                aState.GetGeometricParent(aDisplay, aParentFrame),
     1:                                nsCSSAnonBoxes::scrolledContent,
 80486:                                false, *aNewFrame);
 25131: 
 25131:   // Create our block frame
     1:   // pass a temporary stylecontext, the correct one will be set later
     1:   nsIFrame* scrolledFrame =
 25769:     NS_NewBlockFormattingContext(mPresShell, styleContext);
     1: 
     1:   nsFrameItems blockItem;
 25131:   nsresult rv = ConstructBlock(aState,
132812:                                scrolledContentStyle->StyleDisplay(), content,
 25131:                                *aNewFrame, *aNewFrame, scrolledContentStyle,
107225:                                &scrolledFrame, blockItem,
107225:                                aDisplay->IsPositioned(scrolledFrame),
 34614:                                aItem.mPendingBinding);
120353:   if (MOZ_UNLIKELY(NS_FAILED(rv))) {
 25131:     // XXXbz any cleanup needed here?
 25131:     return rv;
 25131:   }
 25131: 
 30785:   NS_ASSERTION(blockItem.FirstChild() == scrolledFrame,
     1:                "Scrollframe's frameItems should be exactly the scrolled frame");
 25131:   FinishBuildingScrollFrame(*aNewFrame, scrolledFrame);
 25131: 
 25769:   rv = aState.AddChild(*aNewFrame, aFrameItems, content, styleContext,
  8199:                        aParentFrame);
 25131:   return rv;
 25131: }
 25131: 
 25131: nsresult
 25131: nsCSSFrameConstructor::ConstructNonScrollableBlock(nsFrameConstructorState& aState,
 25769:                                                    FrameConstructionItem&   aItem,
 25131:                                                    nsIFrame*                aParentFrame,
 25131:                                                    const nsStyleDisplay*    aDisplay,
 25131:                                                    nsFrameItems&            aFrameItems,
 25131:                                                    nsIFrame**               aNewFrame)
 25131: {
 25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
 25769: 
 58471:   // We want a block formatting context root in paginated contexts for
 58471:   // every block that would be scrollable in a non-paginated context.
 58471:   // We mark our blocks with a bit here if this condition is true, so
 58471:   // we can check it later in nsFrame::ApplyPaginatedOverflowClipping.
 79445:   bool clipPaginatedOverflow =
 58471:     (aItem.mFCData->mBits & FCDATA_FORCED_NON_SCROLLABLE_BLOCK) != 0;
107225:   if ((aDisplay->IsAbsolutelyPositionedStyle() ||
107224:        aDisplay->IsFloatingStyle() ||
 55006:        NS_STYLE_DISPLAY_INLINE_BLOCK == aDisplay->mDisplay ||
107224:        clipPaginatedOverflow) &&
107224:       !aParentFrame->IsSVGText()) {
 25769:     *aNewFrame = NS_NewBlockFormattingContext(mPresShell, styleContext);
 58471:     if (clipPaginatedOverflow) {
 58471:       (*aNewFrame)->AddStateBits(NS_BLOCK_CLIP_PAGINATED_OVERFLOW);
 58471:     }
 25129:   } else {
 25769:     *aNewFrame = NS_NewBlockFrame(mPresShell, styleContext);
 25769:   }
 25769: 
 25769:   return ConstructBlock(aState, aDisplay, aItem.mContent,
 25129:                         aState.GetGeometricParent(aDisplay, aParentFrame),
 25769:                         aParentFrame, styleContext, aNewFrame,
107225:                         aFrameItems, aDisplay->IsPositioned(*aNewFrame),
 34614:                         aItem.mPendingBinding);
 25131: }
 25131: 
 25131: 
 25131: nsresult 
     1: nsCSSFrameConstructor::InitAndRestoreFrame(const nsFrameConstructorState& aState,
     1:                                            nsIContent*              aContent,
     1:                                            nsIFrame*                aParentFrame,
     1:                                            nsIFrame*                aPrevInFlow,
     1:                                            nsIFrame*                aNewFrame,
 79445:                                            bool                     aAllowCounters)
     1: {
  6518:   NS_PRECONDITION(mUpdateCount != 0,
  6518:                   "Should be in an update while creating frames");
  6518:   
     1:   nsresult rv = NS_OK;
     1:   
     1:   NS_ASSERTION(aNewFrame, "Null frame cannot be initialized");
     1:   if (!aNewFrame)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
     1:   // Initialize the frame
     1:   rv = aNewFrame->Init(aContent, aParentFrame, aPrevInFlow);
 16976:   aNewFrame->AddStateBits(aState.mAdditionalStateBits);
     1: 
 89328:   if (aState.mFrameState) {
     1:     // Restore frame state for just the newly created frame.
 89328:     RestoreFrameStateFor(aNewFrame, aState.mFrameState);
     1:   }
     1: 
     1:   if (aAllowCounters && !aPrevInFlow &&
     1:       mCounterManager.AddCounterResetsAndIncrements(aNewFrame)) {
     1:     CountersDirty();
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: already_AddRefed<nsStyleContext>
     1: nsCSSFrameConstructor::ResolveStyleContext(nsIFrame*         aParentFrame,
 64158:                                            nsIContent*       aContent,
 64158:                                            nsFrameConstructorState* aState)
     1: {
106838:   nsStyleContext* parentStyleContext = nullptr;
 28215:   NS_ASSERTION(aContent->GetParent(), "Must have parent here");
 28215: 
106838:   aParentFrame = nsFrame::CorrectStyleParentFrame(aParentFrame, nullptr);
   549: 
 18953:   if (aParentFrame) {
     1:     // Resolve the style context based on the content object and the parent
     1:     // style context
132768:     parentStyleContext = aParentFrame->StyleContext();
   822:   } else {
 18953:     // Perhaps aParentFrame is a canvasFrame and we're replicating
 18953:     // fixed-pos frames.
 18953:     // XXX should we create a way to tell ConstructFrame which style
 18953:     // context to use, and pass it the style context for the
 18953:     // previous page's fixed-pos frame?
 18953:   }
     1: 
 64158:   return ResolveStyleContext(parentStyleContext, aContent, aState);
 25772: }
 25772: 
 25772: already_AddRefed<nsStyleContext>
 25772: nsCSSFrameConstructor::ResolveStyleContext(nsStyleContext* aParentStyleContext,
 64158:                                            nsIContent* aContent,
 64158:                                            nsFrameConstructorState* aState)
 25772: {
     1:   nsStyleSet *styleSet = mPresShell->StyleSet();
 82192:   aContent->OwnerDoc()->FlushPendingLinkUpdates();
     1:   
 41640:   if (aContent->IsElement()) {
 64158:     if (aState) {
 64158:       return styleSet->ResolveStyleFor(aContent->AsElement(),
 64158:                                        aParentStyleContext,
 64158:                                        aState->mTreeMatchContext);
 64158:     }
 41640:     return styleSet->ResolveStyleFor(aContent->AsElement(), aParentStyleContext);
 64158: 
 25772:   }
     1: 
     1:   NS_ASSERTION(aContent->IsNodeOfType(nsINode::eTEXT),
     1:                "shouldn't waste time creating style contexts for "
     1:                "comments and processing instructions");
     1: 
 25772:   return styleSet->ResolveStyleForNonElement(aParentStyleContext);
     1: }
     1: 
     1: // MathML Mod - RBS
     1: nsresult
  6862: nsCSSFrameConstructor::FlushAccumulatedBlock(nsFrameConstructorState& aState,
  6862:                                              nsIContent* aContent,
  6862:                                              nsIFrame* aParentFrame,
 93793:                                              nsFrameItems& aBlockItems,
 93793:                                              nsFrameItems& aNewItems)
 93793: {
 93793:   if (aBlockItems.IsEmpty()) {
  6862:     // Nothing to do
  6862:     return NS_OK;
  6862:   }
  6862: 
 93793:   nsIAtom* anonPseudo = nsCSSAnonBoxes::mozMathMLAnonymousBlock;
 93793: 
  6862:   nsStyleContext* parentContext =
  6862:     nsFrame::CorrectStyleParentFrame(aParentFrame,
132768:                                      anonPseudo)->StyleContext();
  6862:   nsStyleSet* styleSet = mPresShell->StyleSet();
  6862:   nsRefPtr<nsStyleContext> blockContext;
 35554:   blockContext = styleSet->
 93793:     ResolveAnonymousBoxStyle(anonPseudo, parentContext);
 93793: 
  6862: 
  6862:   // then, create a block frame that will wrap the child frames. Make it a
  6862:   // MathML frame so that Get(Absolute/Float)ContainingBlockFor know that this
  6862:   // is not a suitable block.
 93793:   nsIFrame* blockFrame =
 93793:       NS_NewMathMLmathBlockFrame(mPresShell, blockContext,
 23305:                                  NS_BLOCK_FLOAT_MGR | NS_BLOCK_MARGIN_ROOT);
  6862: 
106838:   InitAndRestoreFrame(aState, aContent, aParentFrame, nullptr, blockFrame);
 93793:   ReparentFrames(this, blockFrame, aBlockItems);
  6862:   // abs-pos and floats are disabled in MathML children so we don't have to
  6862:   // worry about messing up those.
 93793:   blockFrame->SetInitialChildList(kPrincipalList, aBlockItems);
 93793:   NS_ASSERTION(aBlockItems.IsEmpty(), "What happened?");
 93793:   aBlockItems.Clear();
 93793:   aNewItems.AddChild(blockFrame);
  6862:   return NS_OK;
  6862: }
  6862: 
 23946: // Only <math> elements can be floated or positioned.  All other MathML
 23946: // should be in-flow.
 23946: #define SIMPLE_MATHML_CREATE(_tag, _func)                               \
 23946:   { &nsGkAtoms::_tag,                                                   \
 23946:       FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW |                         \
 23946:                   FCDATA_FORCE_NULL_ABSPOS_CONTAINER |                  \
 36653:                   FCDATA_WRAP_KIDS_IN_BLOCKS, _func) }
 23946: 
 23946: /* static */
 23946: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindMathMLData(Element* aElement,
     1:                                       nsIAtom* aTag,
108991:                                       int32_t aNameSpaceID,
 23946:                                       nsStyleContext* aStyleContext)
     1: {
     1:   // Make sure that we remain confined in the MathML world
     1:   if (aNameSpaceID != kNameSpaceID_MathML) 
106838:     return nullptr;
 23946: 
 25773:   // Handle <math> specially, because it sometimes produces inlines
 25773:   if (aTag == nsGkAtoms::math) {
 38776:     // This needs to match the test in EnsureBlockDisplay in
 38776:     // nsRuleNode.cpp.  Though the behavior here for the display:table
 38776:     // case is pretty weird...
132812:     if (aStyleContext->StyleDisplay()->IsBlockOutsideStyle()) {
 25773:       static const FrameConstructionData sBlockMathData =
 25773:         FCDATA_DECL(FCDATA_FORCE_NULL_ABSPOS_CONTAINER |
 36653:                     FCDATA_WRAP_KIDS_IN_BLOCKS,
 25773:                     NS_CreateNewMathMLmathBlockFrame);
 25773:       return &sBlockMathData;
 25773:     }
 25773: 
 25773:     static const FrameConstructionData sInlineMathData =
 25773:       FCDATA_DECL(FCDATA_FORCE_NULL_ABSPOS_CONTAINER |
 36698:                   FCDATA_IS_LINE_PARTICIPANT |
 36653:                   FCDATA_WRAP_KIDS_IN_BLOCKS,
 25773:                   NS_NewMathMLmathInlineFrame);
 25773:     return &sInlineMathData;
 25773:   }
 25773:       
 25773: 
 23946:   static const FrameConstructionDataByTag sMathMLData[] = {
 23946:     SIMPLE_MATHML_CREATE(mi_, NS_NewMathMLTokenFrame),
 23946:     SIMPLE_MATHML_CREATE(mn_, NS_NewMathMLTokenFrame),
 23946:     SIMPLE_MATHML_CREATE(ms_, NS_NewMathMLTokenFrame),
 23946:     SIMPLE_MATHML_CREATE(mtext_, NS_NewMathMLTokenFrame),
 23946:     SIMPLE_MATHML_CREATE(mo_, NS_NewMathMLmoFrame),
 23946:     SIMPLE_MATHML_CREATE(mfrac_, NS_NewMathMLmfracFrame),
 23946:     SIMPLE_MATHML_CREATE(msup_, NS_NewMathMLmsupFrame),
 23946:     SIMPLE_MATHML_CREATE(msub_, NS_NewMathMLmsubFrame),
 23946:     SIMPLE_MATHML_CREATE(msubsup_, NS_NewMathMLmsubsupFrame),
 75393:     SIMPLE_MATHML_CREATE(munder_, NS_NewMathMLmunderoverFrame),
 75393:     SIMPLE_MATHML_CREATE(mover_, NS_NewMathMLmunderoverFrame),
 23946:     SIMPLE_MATHML_CREATE(munderover_, NS_NewMathMLmunderoverFrame),
 23946:     SIMPLE_MATHML_CREATE(mphantom_, NS_NewMathMLmphantomFrame),
 23946:     SIMPLE_MATHML_CREATE(mpadded_, NS_NewMathMLmpaddedFrame),
 23946:     SIMPLE_MATHML_CREATE(mspace_, NS_NewMathMLmspaceFrame),
 23946:     SIMPLE_MATHML_CREATE(none, NS_NewMathMLmspaceFrame),
 23946:     SIMPLE_MATHML_CREATE(mprescripts_, NS_NewMathMLmspaceFrame),
 23946:     SIMPLE_MATHML_CREATE(mfenced_, NS_NewMathMLmfencedFrame),
 23946:     SIMPLE_MATHML_CREATE(mmultiscripts_, NS_NewMathMLmmultiscriptsFrame),
 23946:     SIMPLE_MATHML_CREATE(mstyle_, NS_NewMathMLmstyleFrame),
 23946:     SIMPLE_MATHML_CREATE(msqrt_, NS_NewMathMLmsqrtFrame),
 23946:     SIMPLE_MATHML_CREATE(mroot_, NS_NewMathMLmrootFrame),
 23946:     SIMPLE_MATHML_CREATE(maction_, NS_NewMathMLmactionFrame),
 23946:     SIMPLE_MATHML_CREATE(mrow_, NS_NewMathMLmrowFrame),
 31351:     SIMPLE_MATHML_CREATE(merror_, NS_NewMathMLmrowFrame),
 42199:     SIMPLE_MATHML_CREATE(menclose_, NS_NewMathMLmencloseFrame),
 42199:     SIMPLE_MATHML_CREATE(semantics_, NS_NewMathMLsemanticsFrame)
 23946:   };
 23946: 
 63575:   return FindDataByTag(aTag, aElement, aStyleContext, sMathMLData,
 80467:                        ArrayLength(sMathMLData));
 23167: }
 23167: 
103952: 
103952: // Construct an nsSVGOuterSVGFrame, the anonymous child that wraps its real
103952: // children, and its descendant frames.
103952: nsresult
103952: nsCSSFrameConstructor::ConstructOuterSVG(nsFrameConstructorState& aState,
103952:                                          FrameConstructionItem&   aItem,
103952:                                          nsIFrame*                aParentFrame,
103952:                                          const nsStyleDisplay*    aDisplay,
103952:                                          nsFrameItems&            aFrameItems,
103952:                                          nsIFrame**               aNewFrame)
103952: {
103952:   nsIContent* const content = aItem.mContent;
103952:   nsStyleContext* const styleContext = aItem.mStyleContext;
103952: 
103952:   nsresult rv = NS_OK;
103952: 
103952:   // Create the nsSVGOuterSVGFrame:
103952:   nsIFrame* newFrame = NS_NewSVGOuterSVGFrame(mPresShell, styleContext);
103952: 
103952:   nsIFrame* geometricParent =
132812:     aState.GetGeometricParent(styleContext->StyleDisplay(),
103952:                               aParentFrame);
103952: 
106838:   InitAndRestoreFrame(aState, content, geometricParent, nullptr, newFrame);
103952: 
103952:   // Create the pseudo SC for the anonymous wrapper child as a child of the SC:
103952:   nsRefPtr<nsStyleContext> scForAnon;
103952:   scForAnon = mPresShell->StyleSet()->
103952:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::mozSVGOuterSVGAnonChild,
103952:                              styleContext);
103952: 
103952:   // Create the anonymous inner wrapper frame
103952:   nsIFrame* innerFrame = NS_NewSVGOuterSVGAnonChildFrame(mPresShell, scForAnon);
103952: 
106838:   InitAndRestoreFrame(aState, content, newFrame, nullptr, innerFrame);
103952: 
103952:   // Put the newly created frames into the right child list
103952:   SetInitialSingleChild(newFrame, innerFrame);
103952: 
103952:   rv = aState.AddChild(newFrame, aFrameItems, content, styleContext,
103952:                        aParentFrame);
103952:   if (NS_FAILED(rv)) {
103952:     return rv;
103952:   }
103952: 
103952:   if (!mRootElementFrame) {
103952:     // The frame we're constructing will be the root element frame.
103952:     // Set mRootElementFrame before processing children.
103952:     mRootElementFrame = newFrame;
103952:   }
103952: 
103952:   nsFrameItems childItems;
103952: 
103952:   // Process children
103952:   if (aItem.mFCData->mBits & FCDATA_USE_CHILD_ITEMS) {
103952:     rv = ConstructFramesFromItemList(aState, aItem.mChildItems,
103952:                                      innerFrame, childItems);
103952:   } else {
103952:     rv = ProcessChildren(aState, content, styleContext, innerFrame,
103952:                          true, childItems, false, aItem.mPendingBinding);
103952:   }
103952:   // XXXbz what about cleaning up?
103952:   if (NS_FAILED(rv)) return rv;
103952: 
103952:   // Set the inner wrapper frame's initial primary list
103952:   innerFrame->SetInitialChildList(kPrincipalList, childItems);
103952: 
103952:   *aNewFrame = newFrame;
103952:   return rv;
103952: }
103952: 
 23954: // Only outer <svg> elements can be floated or positioned.  All other SVG
     1: // should be in-flow.
 23954: #define SIMPLE_SVG_FCDATA(_func)                                        \
 23954:   FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW |                             \
 36653:               FCDATA_SKIP_ABSPOS_PUSH |                                 \
 23954:               FCDATA_DISALLOW_GENERATED_CONTENT,  _func)
 23954: #define SIMPLE_SVG_CREATE(_tag, _func)            \
 23954:   { &nsGkAtoms::_tag, SIMPLE_SVG_FCDATA(_func) }
 23954: 
 85073: static bool
 85073: IsFilterPrimitiveChildTag(const nsIAtom* aTag)
 85073: {
 85073:   return aTag == nsGkAtoms::feDistantLight ||
 85073:          aTag == nsGkAtoms::fePointLight ||
 85073:          aTag == nsGkAtoms::feSpotLight ||
 85073:          aTag == nsGkAtoms::feFuncR ||
 85073:          aTag == nsGkAtoms::feFuncG ||
 85073:          aTag == nsGkAtoms::feFuncB ||
 85073:          aTag == nsGkAtoms::feFuncA ||
 85073:          aTag == nsGkAtoms::feMergeNode;
 85073: }
 85073: 
 23954: /* static */
 23954: const nsCSSFrameConstructor::FrameConstructionData*
 63575: nsCSSFrameConstructor::FindSVGData(Element* aElement,
     1:                                    nsIAtom* aTag,
108991:                                    int32_t aNameSpaceID,
 23954:                                    nsIFrame* aParentFrame,
132160:                                    bool aIsWithinSVGText,
132160:                                    bool aAllowsTextPathChild,
 23954:                                    nsStyleContext* aStyleContext)
 23954: {
 58951:   if (aNameSpaceID != kNameSpaceID_SVG) {
106838:     return nullptr;
 23954:   }
 23954: 
 23954:   static const FrameConstructionData sSuppressData = SUPPRESS_FCDATA();
 58309:   static const FrameConstructionData sContainerData =
 58309:     SIMPLE_SVG_FCDATA(NS_NewSVGContainerFrame);
     1: 
132160:   bool parentIsSVG = aIsWithinSVGText;
 23954:   nsIContent* parentContent =
106838:     aParentFrame ? aParentFrame->GetContent() : nullptr;
 23954:   // XXXbz should this really be based on the XBL-resolved tag of the parent
 23954:   // frame's content?  Should it not be based on the type of the parent frame
 23954:   // (e.g. whether it's an SVG frame)?
 23954:   if (parentContent) {
108991:     int32_t parentNSID;
     1:     nsIAtom* parentTag =
 80526:       parentContent->OwnerDoc()->BindingManager()->
 82586:         ResolveTag(parentContent, &parentNSID);
     1: 
     1:     // It's not clear whether the SVG spec intends to allow any SVG
     1:     // content within svg:foreignObject at all (SVG 1.1, section
     1:     // 23.2), but if it does, it better be svg:svg.  So given that
     1:     // we're allowing it, treat it as a non-SVG parent.
 16967:     parentIsSVG = parentNSID == kNameSpaceID_SVG &&
 16967:                   parentTag != nsGkAtoms::foreignObject;
     1:   }
     1: 
     1:   if ((aTag != nsGkAtoms::svg && !parentIsSVG) ||
 82586:       (aTag == nsGkAtoms::desc || aTag == nsGkAtoms::title)) {
     1:     // Sections 5.1 and G.4 of SVG 1.1 say that SVG elements other than
     1:     // svg:svg not contained within svg:svg are incorrect, although they
     1:     // don't seem to specify error handling.  Ignore them, since many of
     1:     // our frame classes can't deal.  It *may* be that the document
     1:     // should at that point be considered in error according to F.2, but
     1:     // it's hard to tell.
     1:     //
     1:     // Style mutation can't change this situation, so don't bother
     1:     // adding to the undisplayed content map.
     1:     //
     1:     // We don't currently handle any UI for desc/title
 23954:     return &sSuppressData;
     1:   }
     1: 
 39637:   // We don't need frames for animation elements
 63575:   if (aElement->IsNodeOfType(nsINode::eANIMATION)) {
 39637:     return &sSuppressData;
 39637:   }
 39637: 
 58894:   if (aTag == nsGkAtoms::svg && !parentIsSVG) {
 58894:     // We need outer <svg> elements to have an nsSVGOuterSVGFrame regardless
 58894:     // of whether they fail conditional processing attributes, since various
 58894:     // SVG frames assume that one exists.  We handle the non-rendering
 58894:     // of failing outer <svg> element contents like <switch> statements,
 58894:     // and do the PassesConditionalProcessingTests call in
 58894:     // nsSVGOuterSVGFrame::Init.
 23954:     static const FrameConstructionData sOuterSVGData =
103952:       FULL_CTOR_FCDATA(0, &nsCSSFrameConstructor::ConstructOuterSVG);
 23954:     return &sOuterSVGData;
 23954:   }
 23954:   
 86429:   nsCOMPtr<DOMSVGTests> tests(do_QueryInterface(aElement));
 86429:   if (tests && !tests->PassesConditionalProcessingTests()) {
 58894:     // Elements with failing conditional processing attributes never get
 58894:     // rendered.  Note that this is not where we select which frame in a
 58894:     // <switch> to render!  That happens in nsSVGSwitchFrame::PaintSVG.
 58894:     return &sContainerData;
 58894:   }
 58894: 
 85073:   // Prevent bad frame types being children of filters or parents of filter
132160:   // primitives.  If aParentFrame is null, we know that the frame that will
132160:   // be created will be an nsInlineFrame, so it can never be a filter.
132160:   bool parentIsFilter = aParentFrame &&
132160:     aParentFrame->GetType() == nsGkAtoms::svgFilterFrame;
 82586:   nsCOMPtr<nsIDOMSVGFilterPrimitiveStandardAttributes> filterPrimitive =
 82586:     do_QueryInterface(aElement);
 85073:   if ((parentIsFilter && !filterPrimitive) ||
 85073:       (!parentIsFilter && filterPrimitive)) {
 82586:     return &sSuppressData;
 82586:   }
 82586: 
 85073:   // Prevent bad frame types being children of filter primitives or parents of
132160:   // filter primitive children.  If aParentFrame is null, we know that the frame
132160:   // that will be created will be an nsInlineFrame, so it can never be a filter
132160:   // primitive.
132160:   bool parentIsFEContainerFrame = aParentFrame &&
 85073:     aParentFrame->GetType() == nsGkAtoms::svgFEContainerFrame;
 85073:   if ((parentIsFEContainerFrame && !IsFilterPrimitiveChildTag(aTag)) ||
 85073:       (!parentIsFEContainerFrame && IsFilterPrimitiveChildTag(aTag))) {
 82586:     return &sSuppressData;
 82586:   }
 82586: 
 57186:   // Special cases for text/tspan/textPath, because the kind of frame
 57186:   // they get depends on the parent frame.  We ignore 'a' elements when
 57186:   // determining the parent, however.
132160:   if (aIsWithinSVGText) {
132161:     // If aIsWithinSVGText is true, then we know that the "SVG text uses
132161:     // CSS frames" pref was true when this SVG fragment was first constructed.
132161: 
132160:     // We don't use ConstructInline because we want different behavior
132160:     // for generated content.
132160:     static const FrameConstructionData sTSpanData =
132160:       FCDATA_DECL(FCDATA_DISALLOW_OUT_OF_FLOW |
132160:                   FCDATA_SKIP_ABSPOS_PUSH |
132160:                   FCDATA_DISALLOW_GENERATED_CONTENT |
132160:                   FCDATA_IS_LINE_PARTICIPANT |
132160:                   FCDATA_IS_INLINE |
132160:                   FCDATA_USE_CHILD_ITEMS,
132160:                   NS_NewInlineFrame);
132160:     if (aTag == nsGkAtoms::textPath) {
132160:       if (aAllowsTextPathChild) {
132160:         return &sTSpanData;
132160:       }
132160:     } else if (aTag == nsGkAtoms::tspan ||
132160:                aTag == nsGkAtoms::altGlyph ||
132160:                aTag == nsGkAtoms::a) {
132160:       return &sTSpanData;
132160:     }
132160:     return &sSuppressData;
132161:   } else if (NS_SVGTextCSSFramesEnabled()) {
132160:     if (aTag == nsGkAtoms::text) {
132160:       static const FrameConstructionData sTextData =
132160:         FCDATA_WITH_WRAPPING_BLOCK(FCDATA_DISALLOW_OUT_OF_FLOW |
132160:                                    FCDATA_ALLOW_BLOCK_STYLES,
132160:                                    NS_NewSVGTextFrame2,
132160:                                    nsCSSAnonBoxes::mozSVGText);
132160:       return &sTextData;
132160:     } else if (aTag == nsGkAtoms::tspan ||
132160:                aTag == nsGkAtoms::altGlyph ||
132160:                aTag == nsGkAtoms::textPath) {
132160:       return &sSuppressData;
132160:     }
132160:   } else {
 23953:     nsIFrame *ancestorFrame =
 23953:       nsSVGUtils::GetFirstNonAAncestorFrame(aParentFrame);
 16390:     if (ancestorFrame) {
 57186:       if (aTag == nsGkAtoms::tspan || aTag == nsGkAtoms::altGlyph) {
 57186:         // tspan and altGlyph must be children of another text content element.
 29052:         nsSVGTextContainerFrame* metrics = do_QueryFrame(ancestorFrame);
 23954:         if (!metrics) {
 57186:           return &sSuppressData;
 57186:         }
 57186:       } else if (aTag == nsGkAtoms::textPath) {
 57186:         // textPath must be a child of text.
 57186:         nsIAtom* ancestorFrameType = ancestorFrame->GetType();
 57186:         if (ancestorFrameType != nsGkAtoms::svgTextFrame) {
 57186:           return &sSuppressData;
 57186:         }
 57186:       } else if (aTag != nsGkAtoms::a) {
 57186:         // Every other element except 'a' must not be a child of a text content
 57186:         // element.
 57186:         nsSVGTextContainerFrame* metrics = do_QueryFrame(ancestorFrame);
 57186:         if (metrics) {
 57186:           return &sSuppressData;
 57186:         }
 23954:       }
 23954:     }
132160:   }
 23954: 
 23954:   static const FrameConstructionDataByTag sSVGData[] = {
 58894:     SIMPLE_SVG_CREATE(svg, NS_NewSVGInnerSVGFrame),
 23954:     SIMPLE_SVG_CREATE(g, NS_NewSVGGFrame),
 23954:     SIMPLE_SVG_CREATE(svgSwitch, NS_NewSVGSwitchFrame),
 23954:     SIMPLE_SVG_CREATE(polygon, NS_NewSVGPathGeometryFrame),
 23954:     SIMPLE_SVG_CREATE(polyline, NS_NewSVGPathGeometryFrame),
 23954:     SIMPLE_SVG_CREATE(circle, NS_NewSVGPathGeometryFrame),
 23954:     SIMPLE_SVG_CREATE(ellipse, NS_NewSVGPathGeometryFrame),
 23954:     SIMPLE_SVG_CREATE(line, NS_NewSVGPathGeometryFrame),
 23954:     SIMPLE_SVG_CREATE(rect, NS_NewSVGPathGeometryFrame),
 23954:     SIMPLE_SVG_CREATE(path, NS_NewSVGPathGeometryFrame),
 23954:     SIMPLE_SVG_CREATE(defs, NS_NewSVGContainerFrame),
 93780:     SIMPLE_SVG_CREATE(generic_, NS_NewSVGGenericContainerFrame),
 25772:     { &nsGkAtoms::foreignObject,
 90621:       FCDATA_WITH_WRAPPING_BLOCK(FCDATA_DISALLOW_OUT_OF_FLOW,
 90621:                                  NS_NewSVGForeignObjectFrame,
 90621:                                  nsCSSAnonBoxes::mozSVGForeignContent) },
 23954:     SIMPLE_SVG_CREATE(a, NS_NewSVGAFrame),
 40733:     SIMPLE_SVG_CREATE(altGlyph, NS_NewSVGTSpanFrame),
 23954:     SIMPLE_SVG_CREATE(text, NS_NewSVGTextFrame),
 23954:     SIMPLE_SVG_CREATE(tspan, NS_NewSVGTSpanFrame),
 23954:     SIMPLE_SVG_CREATE(linearGradient, NS_NewSVGLinearGradientFrame),
 23954:     SIMPLE_SVG_CREATE(radialGradient, NS_NewSVGRadialGradientFrame),
 23954:     SIMPLE_SVG_CREATE(stop, NS_NewSVGStopFrame),
 23954:     SIMPLE_SVG_CREATE(use, NS_NewSVGUseFrame),
111533:     SIMPLE_SVG_CREATE(view, NS_NewSVGViewFrame),
 23954:     SIMPLE_SVG_CREATE(marker, NS_NewSVGMarkerFrame),
 23954:     SIMPLE_SVG_CREATE(image, NS_NewSVGImageFrame),
 23954:     SIMPLE_SVG_CREATE(clipPath, NS_NewSVGClipPathFrame),
 23954:     SIMPLE_SVG_CREATE(textPath, NS_NewSVGTextPathFrame),
 23954:     SIMPLE_SVG_CREATE(filter, NS_NewSVGFilterFrame),
 23954:     SIMPLE_SVG_CREATE(pattern, NS_NewSVGPatternFrame),
 23954:     SIMPLE_SVG_CREATE(mask, NS_NewSVGMaskFrame),
 82586:     SIMPLE_SVG_CREATE(feDistantLight, NS_NewSVGFEUnstyledLeafFrame),
 82586:     SIMPLE_SVG_CREATE(fePointLight, NS_NewSVGFEUnstyledLeafFrame),
 82586:     SIMPLE_SVG_CREATE(feSpotLight, NS_NewSVGFEUnstyledLeafFrame),
 82586:     SIMPLE_SVG_CREATE(feBlend, NS_NewSVGFELeafFrame),
 82586:     SIMPLE_SVG_CREATE(feColorMatrix, NS_NewSVGFELeafFrame),
 82586:     SIMPLE_SVG_CREATE(feFuncR, NS_NewSVGFEUnstyledLeafFrame),
 82586:     SIMPLE_SVG_CREATE(feFuncG, NS_NewSVGFEUnstyledLeafFrame),
 82586:     SIMPLE_SVG_CREATE(feFuncB, NS_NewSVGFEUnstyledLeafFrame),
 82586:     SIMPLE_SVG_CREATE(feFuncA, NS_NewSVGFEUnstyledLeafFrame),
 82586:     SIMPLE_SVG_CREATE(feComposite, NS_NewSVGFELeafFrame),
 82586:     SIMPLE_SVG_CREATE(feComponentTransfer, NS_NewSVGFEContainerFrame),
 82586:     SIMPLE_SVG_CREATE(feConvolveMatrix, NS_NewSVGFELeafFrame),
 82586:     SIMPLE_SVG_CREATE(feDiffuseLighting, NS_NewSVGFEContainerFrame),
 82586:     SIMPLE_SVG_CREATE(feDisplacementMap, NS_NewSVGFELeafFrame),
 82586:     SIMPLE_SVG_CREATE(feFlood, NS_NewSVGFELeafFrame),
 82586:     SIMPLE_SVG_CREATE(feGaussianBlur, NS_NewSVGFELeafFrame),
 82586:     SIMPLE_SVG_CREATE(feImage, NS_NewSVGFEImageFrame),
 82586:     SIMPLE_SVG_CREATE(feMerge, NS_NewSVGFEContainerFrame),
 82586:     SIMPLE_SVG_CREATE(feMergeNode, NS_NewSVGFEUnstyledLeafFrame),
 82586:     SIMPLE_SVG_CREATE(feMorphology, NS_NewSVGFELeafFrame), 
 82586:     SIMPLE_SVG_CREATE(feOffset, NS_NewSVGFELeafFrame), 
 82586:     SIMPLE_SVG_CREATE(feSpecularLighting, NS_NewSVGFEContainerFrame),
 82586:     SIMPLE_SVG_CREATE(feTile, NS_NewSVGFELeafFrame), 
 82586:     SIMPLE_SVG_CREATE(feTurbulence, NS_NewSVGFELeafFrame) 
 23954:   };
 23954: 
 23954:   const FrameConstructionData* data =
 63575:     FindDataByTag(aTag, aElement, aStyleContext, sSVGData,
 80467:                   ArrayLength(sSVGData));
 23954: 
 23954:   if (!data) {
 58309:     data = &sContainerData;
 23954:   }
 23954: 
 23954:   return data;
 23954: }
 23954: 
 25771: void
 25771: nsCSSFrameConstructor::AddPageBreakItem(nsIContent* aContent,
 25771:                                         nsStyleContext* aMainStyleContext,
 25774:                                         FrameConstructionItemList& aItems)
     1: {
     1:   nsRefPtr<nsStyleContext> pseudoStyle;
 25771:   // Use the same parent style context that |aMainStyleContext| has, since
 23162:   // that's easier to re-resolve and it doesn't matter in practice.
 23162:   // (Getting different parents can result in framechange hints, e.g.,
 23162:   // for user-modify.)
 25771:   pseudoStyle =
 25771:     mPresShell->StyleSet()->
 35554:       ResolveAnonymousBoxStyle(nsCSSAnonBoxes::pageBreak,
 25771:                                aMainStyleContext->GetParent());
 25772: 
132812:   NS_ASSERTION(pseudoStyle->StyleDisplay()->mDisplay ==
 25772:                  NS_STYLE_DISPLAY_BLOCK, "Unexpected display");
 25772: 
 25771:   static const FrameConstructionData sPageBreakData =
 36653:     FCDATA_DECL(FCDATA_SKIP_FRAMESET, NS_NewPageBreakFrame);
 25771: 
 25771:   // Lie about the tag and namespace so we don't trigger anything
 25771:   // interesting during frame construction.
 25981:   aItems.AppendItem(&sPageBreakData, aContent, nsCSSAnonBoxes::pageBreak,
106838:                     kNameSpaceID_None, nullptr, pseudoStyle.forget(), true);
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::ConstructFrame(nsFrameConstructorState& aState,
     1:                                       nsIContent*              aContent,
     1:                                       nsIFrame*                aParentFrame,
     1:                                       nsFrameItems&            aFrameItems)
     1: 
     1: {
133735:   NS_PRECONDITION(aParentFrame, "no parent frame");
133735:   // NOTE: If we start using this code for non-anonymous content, we'll need
133735:   // to evaluate whether the AutoFlexItemStyleFixupSkipper (instantiated below)
133735:   // is appropriate for that content.
133735:   NS_PRECONDITION(aContent->IsRootOfNativeAnonymousSubtree(),
133735:                   "ConstructFrame should only be used for anonymous content");
133735: 
 25774:   FrameConstructionItemList items;
133735:   {
133735:     // Skip flex item style-fixup during our AddFrameConstructionItems() call:
133735:     TreeMatchContext::AutoFlexItemStyleFixupSkipper
133735:       flexItemStyleFixupSkipper(aState.mTreeMatchContext);
133735: 
 80486:     AddFrameConstructionItems(aState, aContent, true, aParentFrame, items);
133735:   }
 93524:   items.SetTriedConstructingFrames();
 25771: 
 25774:   for (FCItemIterator iter(items); !iter.IsDone(); iter.Next()) {
 26208:     NS_ASSERTION(iter.item().DesiredParentType() == GetParentType(aParentFrame),
 26208:                  "This is not going to work");
 25771:     nsresult rv =
 25774:       ConstructFramesFromItem(aState, iter, aParentFrame, aFrameItems);
 25771:     NS_ENSURE_SUCCESS(rv, rv);
 25771:   }
 25771: 
 25768:   return NS_OK;
 25768: }
 25768: 
 25768: void
 25771: nsCSSFrameConstructor::AddFrameConstructionItems(nsFrameConstructorState& aState,
 25768:                                                  nsIContent* aContent,
 79445:                                                  bool aSuppressWhiteSpaceOptimizations,
 25768:                                                  nsIFrame* aParentFrame,
 25774:                                                  FrameConstructionItemList& aItems)
 25768: {
 40938:   aContent->UnsetFlags(NODE_DESCENDANTS_NEED_FRAMES | NODE_NEEDS_FRAME);
 43792:   if (aContent->IsElement()) {
 43792:     // We can't just remove our pending restyle flags, since we may
 43792:     // have restyle-later-siblings set on us.  But we _can_ remove the
 43792:     // "is possible restyle root" flags, and need to.  Otherwise we can
 43792:     // end up with stale such flags (e.g. if we used to have a
 43792:     // display:none parent when our last restyle was posted and
 43792:     // processed and now no longer do).
 43792:     aContent->UnsetFlags(ELEMENT_ALL_RESTYLE_FLAGS &
 43792:                          ~ELEMENT_PENDING_RESTYLE_FLAGS);
 43792:   }
 40938: 
 58204:   // XXX the GetContent() != aContent check is needed due to bug 135040.
 58204:   // Remove it once that's fixed.  
 58205:   if (aContent->GetPrimaryFrame() &&
 58205:       aContent->GetPrimaryFrame()->GetContent() == aContent &&
 58205:       !aState.mCreatingExtraFrames) {
 58205:     NS_ERROR("asked to create frame construction item for a node that already "
 58205:              "has a frame");
 58205:     return;
 58205:   }
 58204: 
     1:   // don't create a whitespace frame if aParent doesn't want it
 41931:   if (!NeedFrameFor(aState, aParentFrame, aContent)) {
 25768:     return;
     1:   }
     1: 
     1:   // never create frames for comments or PIs
     1:   if (aContent->IsNodeOfType(nsINode::eCOMMENT) ||
     1:       aContent->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION))
 25768:     return;
     1: 
     1:   nsRefPtr<nsStyleContext> styleContext;
 64158:   styleContext = ResolveStyleContext(aParentFrame, aContent, &aState);
     1: 
132160:   uint32_t flags = ITEM_ALLOW_XBL_BASE | ITEM_ALLOW_PAGE_BREAK;
132160:   if (aParentFrame->IsSVGText()) {
132160:     flags |= ITEM_IS_WITHIN_SVG_TEXT;
132160:   }
132160:   if (aParentFrame->GetType() == nsGkAtoms::blockFrame &&
132160:       aParentFrame->GetParent() &&
132160:       aParentFrame->GetParent()->GetType() == nsGkAtoms::svgTextFrame2) {
132160:     flags |= ITEM_ALLOWS_TEXT_PATH_CHILD;
132160:   }
 25771:   AddFrameConstructionItemsInternal(aState, aContent, aParentFrame,
     1:                                     aContent->Tag(), aContent->GetNameSpaceID(),
 47661:                                     aSuppressWhiteSpaceOptimizations,
 47661:                                     styleContext,
132160:                                     flags,
 25768:                                     aItems);
 25768: }
 25768: 
 93524: /* static */ void
 93524: nsCSSFrameConstructor::SetAsUndisplayedContent(FrameConstructionItemList& aList,
 93524:                                                nsIContent* aContent,
 28357:                                                nsStyleContext* aStyleContext,
 79445:                                                bool aIsGeneratedContent)
 28357: {
 34387:   if (aStyleContext->GetPseudo()) {
 28357:     if (aIsGeneratedContent) {
 28357:       aContent->UnbindFromTree();
 28357:     }
 28357:     return;
 28357:   }
 28357: 
 28357:   NS_ASSERTION(!aIsGeneratedContent, "Should have had pseudo type");
 93524:   aList.AppendUndisplayedItem(aContent, aStyleContext);
 28357: }
 25768: 
 25768: void
 25771: nsCSSFrameConstructor::AddFrameConstructionItemsInternal(nsFrameConstructorState& aState,
     1:                                                          nsIContent* aContent,
     1:                                                          nsIFrame* aParentFrame,
     1:                                                          nsIAtom* aTag,
108991:                                                          int32_t aNameSpaceID,
 79445:                                                          bool aSuppressWhiteSpaceOptimizations,
     1:                                                          nsStyleContext* aStyleContext,
108991:                                                          uint32_t aFlags,
 25774:                                                          FrameConstructionItemList& aItems)
     1: {
 63575:   NS_PRECONDITION(aContent->IsNodeOfType(nsINode::eTEXT) ||
 63575:                   aContent->IsElement(),
 63575:                   "Shouldn't get anything else here!");
 63575: 
     1:   // The following code allows the user to specify the base tag
     1:   // of an element using XBL.  XUL and HTML objects (like boxes, menus, etc.)
     1:   // can then be extended arbitrarily.
132812:   const nsStyleDisplay* display = aStyleContext->StyleDisplay();
     1:   nsRefPtr<nsStyleContext> styleContext(aStyleContext);
106838:   PendingBinding* pendingBinding = nullptr;
 25768:   if ((aFlags & ITEM_ALLOW_XBL_BASE) && display->mBinding)
 25649:   {
     1:     // Ensure that our XBL bindings are installed.
     1: 
 99253:     nsXBLService* xblService = nsXBLService::GetInstance();
     1:     if (!xblService)
 25768:       return;
     1: 
 79445:     bool resolveStyle;
 25649: 
 34614:     nsAutoPtr<PendingBinding> newPendingBinding(new PendingBinding());
 72510: 
 69701:     nsresult rv = xblService->LoadBindings(aContent, display->mBinding->GetURI(),
  3645:                                            display->mBinding->mOriginPrincipal,
 34614:                                            getter_AddRefs(newPendingBinding->mBinding),
     1:                                            &resolveStyle);
 53995:     if (NS_FAILED(rv) && rv != NS_ERROR_XBL_BLOCKED)
 25768:       return;
     1: 
 34614:     if (newPendingBinding->mBinding) {
 34614:       pendingBinding = newPendingBinding;
 34614:       // aState takes over owning newPendingBinding
 34614:       aState.AddPendingBinding(newPendingBinding.forget());
 53759:     }
 34614: 
     1:     if (resolveStyle) {
 64158:       styleContext =
 64158:         ResolveStyleContext(styleContext->GetParent(), aContent, &aState);
132812:       display = styleContext->StyleDisplay();
 25649:       aStyleContext = styleContext;
 25649:     }
 25649: 
 25649:     aTag = mDocument->BindingManager()->ResolveTag(aContent, &aNameSpaceID);
     1:   }
     1: 
 79445:   bool isGeneratedContent = ((aFlags & ITEM_IS_GENERATED_CONTENT) != 0);
 28357: 
     1:   // Pre-check for display "none" - if we find that, don't create
     1:   // any frame at all
     1:   if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
 93524:     SetAsUndisplayedContent(aItems, aContent, styleContext, isGeneratedContent);
 25768:     return;
     1:   }
     1: 
 79445:   bool isText = !aContent->IsElement();
 58592: 
 58592:   // never create frames for non-option/optgroup kids of <select> and
 58592:   // non-option kids of <optgroup> inside a <select>.
 58592:   // XXXbz it's not clear how this should best work with XBL.
 58592:   nsIContent *parent = aContent->GetParent();
 58592:   if (parent) {
 58592:     // Check tag first, since that check will usually fail
 58592:     nsIAtom* parentTag = parent->Tag();
 58592:     if ((parentTag == nsGkAtoms::select || parentTag == nsGkAtoms::optgroup) &&
 58592:         parent->IsHTML() &&
 58592:         // <option> is ok no matter what
 58592:         !aContent->IsHTML(nsGkAtoms::option) &&
 58592:         // <optgroup> is OK in <select> but not in <optgroup>
 58592:         (!aContent->IsHTML(nsGkAtoms::optgroup) ||
 58594:          parentTag != nsGkAtoms::select) &&
 58594:         // Allow native anonymous content no matter what
 58594:         !aContent->IsRootOfNativeAnonymousSubtree()) {
 58592:       // No frame for aContent
 58592:       if (!isText) {
 93524:         SetAsUndisplayedContent(aItems, aContent, styleContext,
 93524:                                 isGeneratedContent);
 58592:       }
 58592:       return;
 58592:     }
 58592:   }
 58592: 
 79445:   bool isPopup = false;
 23955:   // Try to find frame construction data for this content
 23955:   const FrameConstructionData* data;
 23955:   if (isText) {
 23955:     data = FindTextData(aParentFrame);
 25131:     if (!data) {
 25131:       // Nothing to do here; suppressed text inside SVG
 25768:       return;
 25131:     }
 23955:   } else {
 63575:     Element* element = aContent->AsElement();
 63575: 
 25131:     // Don't create frames for non-SVG element children of SVG elements.
 25131:     if (aNameSpaceID != kNameSpaceID_SVG &&
132510:         ((aParentFrame &&
107479:           IsFrameForSVG(aParentFrame) &&
132510:           !aParentFrame->IsFrameOfType(nsIFrame::eSVGForeignObject)) ||
132510:          (aFlags & ITEM_IS_WITHIN_SVG_TEXT))) {
 93524:       SetAsUndisplayedContent(aItems, element, styleContext,
 28357:                               isGeneratedContent);
 25768:       return;
 25131:     }
 25131: 
 63575:     data = FindHTMLData(element, aTag, aNameSpaceID, aParentFrame,
 24550:                         styleContext);
 23955:     if (!data) {
 63575:       data = FindXULTagData(element, aTag, aNameSpaceID, styleContext);
 23955:     }
 23955:     if (!data) {
 63575:       data = FindMathMLData(element, aTag, aNameSpaceID, styleContext);
 23955:     }
 23955:     if (!data) {
 63575:       data = FindSVGData(element, aTag, aNameSpaceID, aParentFrame,
132160:                          aFlags & ITEM_IS_WITHIN_SVG_TEXT,
132160:                          aFlags & ITEM_ALLOWS_TEXT_PATH_CHILD,
 23955:                          styleContext);
 23955:     }
 23955: 
 25131:     // Now check for XUL display types
 25131:     if (!data) {
 63575:       data = FindXULDisplayData(display, element, styleContext);
 25131:     }
 25131: 
 25131:     // And general display types
 25131:     if (!data) {
107226:       data = FindDisplayData(display, element, aParentFrame, styleContext);
 25131:     }
 25131: 
 25131:     NS_ASSERTION(data, "Should have frame construction data now");
 25131: 
 25131:     if (data->mBits & FCDATA_SUPPRESS_FRAME) {
 93524:       SetAsUndisplayedContent(aItems, element, styleContext, isGeneratedContent);
 25768:       return;
 23955:     }
 25650: 
 25650: #ifdef MOZ_XUL
 25650:     if ((data->mBits & FCDATA_IS_POPUP) &&
 25772:         (!aParentFrame || // Parent is inline
 25772:          aParentFrame->GetType() != nsGkAtoms::menuFrame)) {
 25772:       if (!aState.mPopupItems.containingBlock &&
 25768:           !aState.mHavePendingPopupgroup) {
 93524:         SetAsUndisplayedContent(aItems, element, styleContext,
 28357:                                 isGeneratedContent);
 25768:         return;
 25650:       }
 25772: 
 80486:       isPopup = true;
 25772:     }
 25650: #endif /* MOZ_XUL */
 23955:   }
 23955: 
108991:   uint32_t bits = data->mBits;
 25772: 
 25770:   // Inside colgroups, suppress everything except columns.
 25770:   if (aParentFrame &&
 25770:       aParentFrame->GetType() == nsGkAtoms::tableColGroupFrame &&
 25772:       (!(bits & FCDATA_IS_TABLE_PART) ||
 25770:        display->mDisplay != NS_STYLE_DISPLAY_TABLE_COLUMN)) {
 93524:     SetAsUndisplayedContent(aItems, aContent, styleContext, isGeneratedContent);
 25770:     return;
 25770:   }
 25770: 
 79445:   bool canHavePageBreak =
 25771:     (aFlags & ITEM_ALLOW_PAGE_BREAK) &&
 25771:     aState.mPresContext->IsPaginated() &&
107225:     !display->IsAbsolutelyPositionedStyle() &&
107225:     !(bits & FCDATA_IS_TABLE_PART) &&
107225:     !(bits & FCDATA_IS_SVG_TEXT);
 25771: 
 25771:   if (canHavePageBreak && display->mBreakBefore) {
 25771:     AddPageBreakItem(aContent, aStyleContext, aItems);
 25771:   }
 25771: 
 25981:   FrameConstructionItem* item =
 47661:     aItems.AppendItem(data, aContent, aTag, aNameSpaceID,
 47661:                       pendingBinding, styleContext.forget(),
 47661:                       aSuppressWhiteSpaceOptimizations);
 25768:   if (!item) {
 25768:     if (isGeneratedContent) {
 25768:       aContent->UnbindFromTree();
 25768:     }
 25768:     return;
 25768:   }
 25768: 
 25768:   item->mIsText = isText;
 25768:   item->mIsGeneratedContent = isGeneratedContent;
 25768:   if (isGeneratedContent) {
 25768:     NS_ADDREF(item->mContent);
 25768:   }
 25769:   item->mIsRootPopupgroup =
 25769:     aNameSpaceID == kNameSpaceID_XUL && aTag == nsGkAtoms::popupgroup &&
 25769:     aContent->IsRootOfNativeAnonymousSubtree();
 25769:   if (item->mIsRootPopupgroup) {
 80486:     aState.mHavePendingPopupgroup = true;
 25769:   }
 25772:   item->mIsPopup = isPopup;
132160:   item->mIsForSVGAElement = aNameSpaceID == kNameSpaceID_SVG &&
132160:                             aTag == nsGkAtoms::a;
 25771: 
 25771:   if (canHavePageBreak && display->mBreakAfter) {
 25771:     AddPageBreakItem(aContent, aStyleContext, aItems);
 25771:   }
 25772: 
 25772:   if (bits & FCDATA_IS_INLINE) {
 25772:     // To correctly set item->mIsAllInline we need to build up our child items
 25772:     // right now.
132160:     BuildInlineChildItems(aState, *item,
132160:                           aFlags & ITEM_IS_WITHIN_SVG_TEXT,
132160:                           aFlags & ITEM_ALLOWS_TEXT_PATH_CHILD);
 80486:     item->mHasInlineEnds = true;
 80486:     item->mIsBlock = false;
 25772:   } else {
 34462:     // Compute a boolean isInline which is guaranteed to be false for blocks
 34462:     // (but may also be false for some inlines).
 79445:     bool isInline =
 34462:       // Table-internal things are inline-outside if and only if they're kids of
 25772:       // inlines, since they'll trigger construction of inline-table
 25772:       // pseudos.
 25772:       ((bits & FCDATA_IS_TABLE_PART) &&
 25772:        (!aParentFrame || // No aParentFrame means inline
132812:         aParentFrame->StyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE)) ||
 25772:       // Things that are inline-outside but aren't inline frames are inline
107226:       (aParentFrame ? display->IsInlineOutside(aParentFrame) :
107226:                       display->IsInlineOutsideStyle()) ||
 25772:       // Popups that are certainly out of flow.
 25772:       isPopup;
 34462: 
 34462:     // Set mIsAllInline conservatively.  It just might be that even an inline
 34462:     // that has mIsAllInline false doesn't need an {ib} split.  So this is just
 34462:     // an optimization to keep from doing too much work in cases when we can
 34462:     // show that mIsAllInline is true..
 34462:     item->mIsAllInline = item->mHasInlineEnds = isInline ||
 34462:       // Figure out whether we're guaranteed this item will be out of flow.
 34462:       // This is not a precise test, since one of our ancestor inlines might add
 34462:       // an absolute containing block (if it's relatively positioned) when there
 34462:       // wasn't such a containing block before.  But it's conservative in the
 34462:       // sense that anything that will really end up as an in-flow non-inline
 34462:       // will test false here.  In other words, if this test is true we're
 34462:       // guaranteed to be inline; if it's false we don't know what we'll end up
 34462:       // as.
 34462:       //
 34462:       // If we make this test precise, we can remove some of the code dealing
 34462:       // with the imprecision in ConstructInline and adjust the comments on
 34462:       // mIsAllInline and mIsBlock in the header.  And probably remove mIsBlock
 34462:       // altogether, since then it will always be equal to !mHasInlineEnds.
 34462:       (!(bits & FCDATA_DISALLOW_OUT_OF_FLOW) &&
106838:        aState.GetGeometricParent(display, nullptr));
 34462: 
 34462:     // Set mIsBlock conservatively.  It's OK to set it false for some real
 34462:     // blocks, but not OK to set it true for things that aren't blocks.  Since
 34462:     // isOutOfFlow might be false even in cases when the frame will end up
 34462:     // out-of-flow, we can't use it here.  But we _can_ say that the frame will
 34462:     // for sure end up in-flow if it's not floated or absolutely positioned.
107224:     item->mIsBlock = !isInline &&
107225:                      !display->IsAbsolutelyPositionedStyle() &&
107225:                      !display->IsFloatingStyle() &&
107225:                      !(bits & FCDATA_IS_SVG_TEXT);
 25772:   }
 25774: 
 25774:   if (item->mIsAllInline) {
 25774:     aItems.InlineItemAdded();
 34462:   } else if (item->mIsBlock) {
 34462:     aItems.BlockItemAdded();
 25774:   }
 25774: 
 29075:   // Our item should be treated as a line participant if we have the relevant
 29075:   // bit and are going to be in-flow.  Note that this really only matters if
 29075:   // our ancestor is a box or some such, so the fact that we might have an
 29075:   // inline ancestor that might become a containing block is not relevant here.
 29075:   if ((bits & FCDATA_IS_LINE_PARTICIPANT) &&
 29075:       ((bits & FCDATA_DISALLOW_OUT_OF_FLOW) ||
106838:        !aState.GetGeometricParent(display, nullptr))) {
 80486:     item->mIsLineParticipant = true;
 25774:     aItems.LineParticipantItemAdded();
 25774:   }
 25768: }
 25768: 
 39965: static void
 39965: DestroyContent(void* aPropertyValue)
 25768: {
 25768:   nsIContent* content = static_cast<nsIContent*>(aPropertyValue);
 25768:   content->UnbindFromTree();
 25768:   NS_RELEASE(content);
 25768: }
 25768: 
 39965: NS_DECLARE_FRAME_PROPERTY(BeforeProperty, DestroyContent)
 39965: NS_DECLARE_FRAME_PROPERTY(AfterProperty, DestroyContent)
 39965: 
 39965: static const FramePropertyDescriptor*
 39965: GenConPseudoToProperty(nsIAtom* aPseudo)
 39965: {
 39965:   NS_ASSERTION(aPseudo == nsCSSPseudoElements::before ||
 39965:                aPseudo == nsCSSPseudoElements::after,
 39965:                "Bad gen-con pseudo");
 39965:   return aPseudo == nsCSSPseudoElements::before ? BeforeProperty()
 39965:       : AfterProperty();
 39965: }
 39965: 
 29501: /**
 29501:  * Return true if the frame construction item pointed to by aIter will
 29501:  * create a frame adjacent to a line boundary in the frame tree, and that
 29501:  * line boundary is induced by a content node adjacent to the frame's
 29501:  * content node in the content tree. The latter condition is necessary so
 29501:  * that ContentAppended/ContentInserted/ContentRemoved can easily find any
 29501:  * text nodes that were suppressed here.
 29501:  */
 79445: bool
 29501: nsCSSFrameConstructor::AtLineBoundary(FCItemIterator& aIter)
 29501: {
 47661:   if (aIter.item().mSuppressWhiteSpaceOptimizations) {
 80486:     return false;
 29501:   }
 29501: 
 29501:   if (aIter.AtStart()) {
 29501:     if (aIter.List()->HasLineBoundaryAtStart() &&
 47661:         !aIter.item().mContent->GetPreviousSibling())
 80486:       return true;
 29501:   } else {
 29501:     FCItemIterator prev = aIter;
 29501:     prev.Prev();
 29501:     if (prev.item().IsLineBoundary() &&
 47661:         !prev.item().mSuppressWhiteSpaceOptimizations &&
 47661:         aIter.item().mContent->GetPreviousSibling() == prev.item().mContent)
 80486:       return true;
 29501:   }
 29501: 
 29501:   FCItemIterator next = aIter;
 29501:   next.Next();
 29501:   if (next.IsDone()) {
 29501:     if (aIter.List()->HasLineBoundaryAtEnd() &&
 47661:         !aIter.item().mContent->GetNextSibling())
 80486:       return true;
 29501:   } else {
 29501:     if (next.item().IsLineBoundary() &&
 47661:         !next.item().mSuppressWhiteSpaceOptimizations &&
 47661:         aIter.item().mContent->GetNextSibling() == next.item().mContent)
 80486:       return true;
 80486:   }
 80486: 
 80486:   return false;
 29501: }
 29501: 
 25768: nsresult
 25768: nsCSSFrameConstructor::ConstructFramesFromItem(nsFrameConstructorState& aState,
 29501:                                                FCItemIterator& aIter,
 25768:                                                nsIFrame* aParentFrame,
 25768:                                                nsFrameItems& aFrameItems)
 25768: {
     1:   nsIFrame* adjParentFrame = aParentFrame;
 29501:   FrameConstructionItem& item = aIter.item();
 29501:   nsStyleContext* styleContext = item.mStyleContext;
 29501:   AdjustParentFrame(adjParentFrame, item.mFCData, styleContext);
 29501: 
 29501:   if (item.mIsText) {
 29501:     // If this is collapsible whitespace next to a line boundary,
 29809:     // don't create a frame. item.IsWhitespace() also sets the
 29809:     // NS_CREATE_FRAME_IF_NON_WHITESPACE flag in the text node. (If we
 29809:     // end up creating a frame, nsTextFrame::Init will clear the flag.)
 29501:     // We don't do this for generated content, because some generated
 29501:     // text content is empty text nodes that are about to be initialized.
 29501:     // (We check mAdditionalStateBits because only the generated content
 29501:     // container's frame construction item is marked with
 29501:     // mIsGeneratedContent, and we might not have an aParentFrame.)
 29501:     // We don't do it for content that may have XBL anonymous siblings,
 29501:     // because they make it difficult to correctly create the frame
 29501:     // due to dynamic changes.
107480:     // We don't do it for SVG text, since we might need to position and
107480:     // measure the white space glyphs due to x/y/dx/dy attributes.
 29501:     if (AtLineBoundary(aIter) &&
132812:         !styleContext->StyleText()->WhiteSpaceOrNewlineIsSignificant() &&
 29501:         aIter.List()->ParentHasNoXBLChildren() &&
 29501:         !(aState.mAdditionalStateBits & NS_FRAME_GENERATED_CONTENT) &&
 29992:         (item.mFCData->mBits & FCDATA_IS_LINE_PARTICIPANT) &&
107480:         !(item.mFCData->mBits & FCDATA_IS_SVG_TEXT) &&
 41931:         item.IsWhitespace(aState))
 29501:       return NS_OK;
 29501: 
 29501:     return ConstructTextFrame(item.mFCData, aState, item.mContent,
 25768:                               adjParentFrame, styleContext,
 26208:                               aFrameItems);
 23955:   }
     1: 
 62083:   // Start background loads during frame construction so that we're
 62083:   // guaranteed that they will be started before onload fires.
 62083:   styleContext->StartBackgroundImageLoads();
     1: 
 25768:   nsFrameState savedStateBits = aState.mAdditionalStateBits;
 29501:   if (item.mIsGeneratedContent) {
 25768:     // Ensure that frames created here are all tagged with
 25768:     // NS_FRAME_GENERATED_CONTENT.
 25768:     aState.mAdditionalStateBits |= NS_FRAME_GENERATED_CONTENT;
 25768: 
 26208:     // Note that we're not necessarily setting this property on the primary
 26208:     // frame for the content for which this is generated content.  We might be
 26208:     // setting it on a table pseudo-frame inserted under that instead.  That's
 26208:     // OK, though; we just need to do the property set so that the content will
 26208:     // get cleaned up when the frame is destroyed.
 39965:     aParentFrame->Properties().Set(GenConPseudoToProperty(styleContext->GetPseudo()),
 39965:                                    item.mContent);
 29501: 
 29501:     // Now that we've passed ownership of item.mContent to the frame, unset
 25768:     // our generated content flag so we don't release or unbind it ourselves.
 80486:     item.mIsGeneratedContent = false;
 25768:   }
 25768: 
 25769:   // XXXbz maybe just inline ConstructFrameFromItemInternal here or something?
 29501:   nsresult rv = ConstructFrameFromItemInternal(item, aState, adjParentFrame,
 26208:                                                aFrameItems);
 25649: 
 25768:   aState.mAdditionalStateBits = savedStateBits;
 25649: 
 25649:   return rv;
     1: }
     1: 
     1: 
 79445: inline bool
     1: IsRootBoxFrame(nsIFrame *aFrame)
     1: {
     1:   return (aFrame->GetType() == nsGkAtoms::rootFrame);
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::ReconstructDocElementHierarchy()
     1: {
 62608:   Element* rootElement = mDocument->GetRootElement();
 62608:   if (!rootElement) {
 62608:     /* nothing to do */
 62608:     return NS_OK;
 62608:   }
 80486:   return RecreateFramesForContent(rootElement, false);
 28215: }
     1: 
     1: nsIFrame*
     1: nsCSSFrameConstructor::GetFrameFor(nsIContent* aContent)
     1: {
     1:   // Get the primary frame associated with the content
 36656:   nsIFrame* frame = aContent->GetPrimaryFrame();
     1: 
     1:   if (!frame)
106838:     return nullptr;
     1: 
 47150:   // If the content of the frame is not the desired content then this is not
 47150:   // really a frame for the desired content.
 47150:   // XXX This check is needed due to bug 135040. Remove it once that's fixed.
 47150:   if (frame->GetContent() != aContent) {
106838:     return nullptr;
 47150:   }
 47150: 
     1:   nsIFrame* insertionFrame = frame->GetContentInsertionFrame();
     1: 
     1:   NS_ASSERTION(insertionFrame == frame || !frame->IsLeaf(),
     1:     "The insertion frame is the primary frame or the primary frame isn't a leaf");
     1: 
     1:   return insertionFrame;
     1: }
     1: 
     1: nsIFrame*
130516: nsCSSFrameConstructor::GetAbsoluteContainingBlock(nsIFrame* aFrame,
130516:                                                   ContainingBlockType aType)
     1: {
106838:   NS_PRECONDITION(nullptr != mRootElementFrame, "no root element frame");
     1: 
     1:   // Starting with aFrame, look for a frame that is absolutely positioned or
130516:   // relatively positioned (and transformed, if aType is FIXED)
 79488:   for (nsIFrame* frame = aFrame; frame; frame = frame->GetParent()) {
     1:     if (frame->IsFrameOfType(nsIFrame::eMathML)) {
     1:       // If it's mathml, bail out -- no absolute positioning out from inside
     1:       // mathml frames.  Note that we don't make this part of the loop
 20147:       // condition because of the stuff at the end of this method...
106838:       return nullptr;
     1:     }
     1: 
 79488:     // If the frame is positioned, we will probably return it as the containing
 79488:     // block (see the exceptions below).  Otherwise, we'll start looking at the
 79488:     // parent frame, unless we're dealing with a scrollframe.
 79488:     // Scrollframes are special since they're not positioned, but their
 79488:     // scrolledframe might be.  So, we need to check this special case to return
 79488:     // the correct containing block (the scrolledframe) in that case.
130516:     // If we're looking for a fixed-pos containing block and the frame is
130516:     // not transformed, skip it.
130516:     if (!frame->IsPositioned() ||
132812:         (aType == FIXED_POS && !frame->StyleDisplay()->HasTransform(frame))) {
 79486:       continue;
 79486:     }
106838:     nsIFrame* absPosCBCandidate = nullptr;
 79488:     if (frame->GetType() == nsGkAtoms::scrollFrame) {
 79488:       nsIScrollableFrame* scrollFrame = do_QueryFrame(frame);
 79488:       absPosCBCandidate = scrollFrame->GetScrolledFrame();
 79488:     } else {
 79488:       // Only first continuations can be containing blocks.
 79488:       absPosCBCandidate = frame->GetFirstContinuation();
 79488:     }
 79488:     // Is the frame really an absolute container?
 79488:     if (!absPosCBCandidate || !absPosCBCandidate->IsAbsoluteContainer()) {
 79488:       continue;
 79488:     }
 79488: 
130516:     // For tables, skip the inner frame and consider the outer table frame.
 79488:     if (absPosCBCandidate->GetType() == nsGkAtoms::tableFrame) {
130516:       continue;
 79488:     }
 79488:     // For outer table frames, we can just return absPosCBCandidate.
 79488:     return absPosCBCandidate;
 79488:   }
 79488: 
 79488:   // It is possible for the search for the containing block to fail, because
 79488:   // no absolute container can be found in the parent chain.  In those cases,
 79488:   // we fall back to the document element's containing block.
130516:   if (aType == FIXED_POS) {
130516:     return mFixedContainingBlock;
130516:   }
130515:   return mHasRootAbsPosContainingBlock ? mDocElementContainingBlock : nullptr;
130515: }
130515: 
130515: nsIFrame*
     1: nsCSSFrameConstructor::GetFloatContainingBlock(nsIFrame* aFrame)
     1: {
     1:   // Starting with aFrame, look for a frame that is a float containing block.
     1:   // IF we hit a mathml frame, bail out; we don't allow floating out of mathml
     1:   // frames, because they don't seem to be able to deal.
 23352:   // The logic here needs to match the logic in ProcessChildren()
     1:   for (nsIFrame* containingBlock = aFrame;
103018:        containingBlock &&
103018:          !ShouldSuppressFloatingOfDescendants(containingBlock);
     1:        containingBlock = containingBlock->GetParent()) {
     1:     if (containingBlock->IsFloatContainingBlock()) {
     1:       return containingBlock;
     1:     }
     1:   }
     1: 
     1:   // If we didn't find a containing block, then there just isn't
     1:   // one.... return null
106838:   return nullptr;
     1: }
     1: 
     1: /**
     1:  * This function will check whether aContainer has :after generated content.
     1:  * If so, appending to it should actually insert.  The return value is the
     1:  * parent to use for newly-appended content.  *aAfterFrame points to the :after
     1:  * frame before which appended content should go, if there is one.
     1:  */
     1: static nsIFrame*
     1: AdjustAppendParentForAfterContent(nsPresContext* aPresContext,
     1:                                   nsIContent* aContainer,
     1:                                   nsIFrame* aParentFrame,
     1:                                   nsIFrame** aAfterFrame)
     1: {
     1:   // See if the parent has an :after pseudo-element.  Check for the presence
     1:   // of style first, since nsLayoutUtils::GetAfterFrame is sorta expensive.
132768:   nsStyleContext* parentStyle = aParentFrame->StyleContext();
     1:   if (nsLayoutUtils::HasPseudoStyle(aContainer, parentStyle,
 35554:                                     nsCSSPseudoElements::ePseudo_after,
     1:                                     aPresContext)) {
114181:     // Ensure that the :after frame is on the principal child list.
114181:     aParentFrame->DrainSelfOverflowList();
114181: 
     1:     nsIFrame* afterFrame = nsLayoutUtils::GetAfterFrame(aParentFrame);
     1:     if (afterFrame) {
     1:       *aAfterFrame = afterFrame;
     1:       return afterFrame->GetParent();
     1:     }
     1:   }
     1: 
106838:   *aAfterFrame = nullptr;
 34462: 
 34462:   if (IsFrameSpecial(aParentFrame)) {
 34462:     // We might be in a situation where the last part of the {ib} split was
 34462:     // empty.  Since we have no ::after pseudo-element, we do in fact want to be
 34462:     // appending to that last part, so advance to it if needed.  Note that here
 34462:     // aParentFrame is the result of a GetLastSpecialSibling call, so must be
 34462:     // either the last or next to last special sibling.
 34462:     nsIFrame* trailingInline = GetSpecialSibling(aParentFrame);
 34462:     if (trailingInline) {
 34996:       aParentFrame = trailingInline;
 34996:     }
 34996: 
 34996:     // Always make sure to look at the last continuation of the frame
 34996:     // for the {ib} case, even if that continuation is empty.  We
 34996:     // don't do this for the non-special-frame case, since in the
 34996:     // other cases appending to the last nonempty continuation is fine
 34996:     // and in fact not doing that can confuse code that doesn't know
 34996:     // to pull kids from continuations other than its next one.
 34996:     aParentFrame = aParentFrame->GetLastContinuation();
 34462:   }
 34462: 
     1:   return aParentFrame;
     1: }
     1: 
     1: /**
 27310:  * This function will get the previous sibling to use for an append operation.
 27310:  * it takes a parent frame (must not be null) and its :after frame (may be
 27310:  * null).
 27310:  */
 27310: static nsIFrame*
 27310: FindAppendPrevSibling(nsIFrame* aParentFrame, nsIFrame* aAfterFrame)
 27310: {
 30827:   if (aAfterFrame) {
 27310:     NS_ASSERTION(aAfterFrame->GetParent() == aParentFrame, "Wrong parent");
114181:     NS_ASSERTION(aAfterFrame->GetPrevSibling() ||
114181:                  aParentFrame->GetFirstPrincipalChild() == aAfterFrame,
114181:                  ":after frame must be on the principal child list here");
 33388:     return aAfterFrame->GetPrevSibling();
 27310:   }
 27310: 
114181:   aParentFrame->DrainSelfOverflowList();
114181: 
 77155:   return aParentFrame->GetLastChild(kPrincipalList);
 27310: }
 27310: 
 27310: /**
 27310:  * This function will get the next sibling for a frame insert operation given
 27310:  * the parent and previous sibling.  aPrevSibling may be null.
 27310:  */
 27310: static nsIFrame*
 27310: GetInsertNextSibling(nsIFrame* aParentFrame, nsIFrame* aPrevSibling)
 27310: {
 27310:   if (aPrevSibling) {
 27310:     return aPrevSibling->GetNextSibling();
 27310:   }
 27310: 
 77154:   return aParentFrame->GetFirstPrincipalChild();
 27310: }
 27310: 
 27310: /**
 27310:  * This function is called by ContentAppended() and ContentInserted() when
 27310:  * appending flowed frames to a parent's principal child list. It handles the
 34462:  * case where the parent is the trailing inline of an {ib} split.
     1:  */
     1: nsresult
 89328: nsCSSFrameConstructor::AppendFramesToParent(nsFrameConstructorState&       aState,
     1:                                             nsIFrame*                      aParentFrame,
  4696:                                             nsFrameItems&                  aFrameList,
 36623:                                             nsIFrame*                      aPrevSibling,
 79445:                                             bool                           aIsRecursiveCall)
 27310: {
 27310:   NS_PRECONDITION(!IsFrameSpecial(aParentFrame) ||
 27310:                   !GetSpecialSibling(aParentFrame) ||
 77154:                   !GetSpecialSibling(aParentFrame)->GetFirstPrincipalChild(),
 27310:                   "aParentFrame has a special sibling with kids?");
 27310:   NS_PRECONDITION(!aPrevSibling || aPrevSibling->GetParent() == aParentFrame,
 27310:                   "Parent and prevsibling don't match");
 27310: 
 27310:   nsIFrame* nextSibling = ::GetInsertNextSibling(aParentFrame, aPrevSibling);
 27310: 
 27310:   NS_ASSERTION(nextSibling ||
 27310:                !aParentFrame->GetNextContinuation() ||
 77154:                !aParentFrame->GetNextContinuation()->GetFirstPrincipalChild() ||
 36623:                aIsRecursiveCall,
 27310:                "aParentFrame has later continuations with kids?");
 34462:   NS_ASSERTION(nextSibling ||
 34462:                !IsFrameSpecial(aParentFrame) ||
 34462:                (IsInlineFrame(aParentFrame) &&
 34462:                 !GetSpecialSibling(aParentFrame) &&
 36623:                 !aParentFrame->GetNextContinuation()) ||
 36623:                aIsRecursiveCall,
 34462:                "aParentFrame is not last?");
 34462: 
 34462:   // If we're inserting a list of frames at the end of the trailing inline
 34462:   // of an {ib} split, we may need to create additional {ib} siblings to parent
 34462:   // them.
 34462:   if (!nextSibling && IsFrameSpecial(aParentFrame)) {
 35611:     // When we get here, our frame list might start with a block.  If it does
 35611:     // so, and aParentFrame is an inline, and it and all its previous
 35611:     // continuations have no siblings, then put the initial blocks from the
 35611:     // frame list into the previous block of the {ib} split.  Note that we
 35611:     // didn't want to stop at the block part of the split when figuring out
 35611:     // initial parent, because that could screw up float parenting; it's easier
 35611:     // to do this little fixup here instead.
107226:     if (aFrameList.NotEmpty() && !aFrameList.FirstChild()->IsInlineOutside()) {
 36624:       // See whether our trailing inline is empty
 35611:       nsIFrame* firstContinuation = aParentFrame->GetFirstContinuation();
 77154:       if (firstContinuation->PrincipalChildList().IsEmpty()) {
 35611:         // Our trailing inline is empty.  Collect our starting blocks from
 35611:         // aFrameList, get the right parent frame for them, and put them in.
 35611:         nsFrameList::FrameLinkEnumerator firstNonBlockEnumerator =
 35611:           FindFirstNonBlock(aFrameList);
 35611:         nsFrameList blockKids = aFrameList.ExtractHead(firstNonBlockEnumerator);
 35611:         NS_ASSERTION(blockKids.NotEmpty(), "No blocks?");
 35611: 
 35611:         nsIFrame* prevBlock =
 35611:           GetSpecialPrevSibling(firstContinuation)->GetLastContinuation();
 35611:         NS_ASSERTION(prevBlock, "Should have previous block here");
 35611: 
 35611:         MoveChildrenTo(aState.mPresContext, aParentFrame, prevBlock, blockKids);
 35611:       }
 35611:     }
 35611: 
 34462:     // We want to put some of the frames into this inline frame.
 34462:     nsFrameList::FrameLinkEnumerator firstBlockEnumerator(aFrameList);
 34462:     FindFirstBlock(firstBlockEnumerator);
 34462: 
 34462:     nsFrameList inlineKids = aFrameList.ExtractHead(firstBlockEnumerator);
 34462:     if (!inlineKids.IsEmpty()) {
 89328:       AppendFrames(aParentFrame, kPrincipalList, inlineKids);
 34462:     }
 34462: 
 34462:     if (!aFrameList.IsEmpty()) {
132812:       const nsStyleDisplay* parentDisplay = aParentFrame->StyleDisplay();
 79445:       bool positioned =
127105:         parentDisplay->mPosition == NS_STYLE_POSITION_RELATIVE &&
107225:         !aParentFrame->IsSVGText();
 34462:       nsFrameItems ibSiblings;
 34462:       CreateIBSiblings(aState, aParentFrame, positioned, aFrameList,
 34462:                        ibSiblings);
 34462: 
 34462:       // Make sure to trigger reflow of the inline that used to be our
 34462:       // last one and now isn't anymore, since its GetSkipSides() has
 34462:       // changed.
 34462:       mPresShell->FrameNeedsReflow(aParentFrame,
 34462:                                    nsIPresShell::eTreeChange,
 34462:                                    NS_FRAME_HAS_DIRTY_CHILDREN);
 34462: 
 35612:       // Recurse so we create new ib siblings as needed for aParentFrame's parent
 89328:       return AppendFramesToParent(aState, aParentFrame->GetParent(), ibSiblings,
 80486:                                   aParentFrame, true);
 34462:     }
 34462: 
  4696:     return NS_OK;
  4696:   }
  4696:   
 36623:   // Insert the frames after our aPrevSibling
 89328:   return InsertFrames(aParentFrame, kPrincipalList, aPrevSibling, aFrameList);
     1: }
     1: 
  7655: #define UNSET_DISPLAY 255
  7655: 
 40939: // This gets called to see if the frames corresponding to aSibling and aContent
 40939: // should be siblings in the frame tree. Although (1) rows and cols, (2) row
 40939: // groups and col groups, (3) row groups and captions, (4) legends and content
 40939: // inside fieldsets, (5) popups and other kids of the menu are siblings from a
 40939: // content perspective, they are not considered siblings in the frame tree.
 79445: bool
  7655: nsCSSFrameConstructor::IsValidSibling(nsIFrame*              aSibling,
  7655:                                       nsIContent*            aContent,
108991:                                       uint8_t&               aDisplay)
     1: {
  8009:   nsIFrame* parentFrame = aSibling->GetParent();
106838:   nsIAtom* parentType = nullptr;
106838:   nsIAtom* grandparentType = nullptr;
  8009:   if (parentFrame) {
  8009:     parentType = parentFrame->GetType();
  8009:     nsIFrame* grandparentFrame = parentFrame->GetParent();
  8009:     if (grandparentFrame) {
  8009:       grandparentType = grandparentFrame->GetType();
  8009:     }
  8009:   }
  8009: 
108991:   uint8_t siblingDisplay = aSibling->GetDisplay();
  7655:   if ((NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == siblingDisplay) ||
  7655:       (NS_STYLE_DISPLAY_TABLE_COLUMN       == siblingDisplay) ||
  7655:       (NS_STYLE_DISPLAY_TABLE_CAPTION      == siblingDisplay) ||
  7655:       (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == siblingDisplay) ||
  7655:       (NS_STYLE_DISPLAY_TABLE_ROW_GROUP    == siblingDisplay) ||
  7655:       (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == siblingDisplay) ||
  7655:       nsGkAtoms::menuFrame == parentType) {
     1:     // if we haven't already, construct a style context to find the display type of aContent
     1:     if (UNSET_DISPLAY == aDisplay) {
     1:       nsRefPtr<nsStyleContext> styleContext;
 78202:       nsIFrame* styleParent = aSibling->GetParentStyleContextFrame();
 78202:       if (!styleParent) {
  1502:         NS_NOTREACHED("Shouldn't happen");
 80486:         return false;
  1502:       }
 64158:       // XXXbz when this code is killed, the state argument to
 64158:       // ResolveStyleContext can be made non-optional.
106838:       styleContext = ResolveStyleContext(styleParent, aContent, nullptr);
 80486:       if (!styleContext) return false;
132812:       const nsStyleDisplay* display = styleContext->StyleDisplay();
     1:       aDisplay = display->mDisplay;
     1:     }
  7655:     if (nsGkAtoms::menuFrame == parentType) {
  7655:       return
  7655:         (NS_STYLE_DISPLAY_POPUP == aDisplay) ==
  7655:         (NS_STYLE_DISPLAY_POPUP == siblingDisplay);
  7655:     }
 34953:     // To have decent performance we want to return false in cases in which
 34953:     // reordering the two siblings has no effect on display.  To ensure
 34953:     // correctness, we MUST return false in cases where the two siblings have
 34953:     // the same desired parent type and live on different display lists.
 34953:     // Specificaly, columns and column groups should only consider columns and
 34953:     // column groups as valid siblings.  Captions should only consider other
 34953:     // captions.  All other things should consider each other as valid
 34953:     // siblings.  The restriction in the |if| above on siblingDisplay is ok,
 34953:     // because for correctness the only part that really needs to happen is to
 34953:     // not consider captions, column groups, and row/header/footer groups
 34953:     // siblings of each other.  Treating a column or colgroup as a valid
 34953:     // sibling of a non-table-related frame will just mean we end up reframing.
 34953:     if ((siblingDisplay == NS_STYLE_DISPLAY_TABLE_CAPTION) !=
 34953:         (aDisplay == NS_STYLE_DISPLAY_TABLE_CAPTION)) {
 34953:       // One's a caption and the other is not.  Not valid siblings.
 80486:       return false;
 34953:     }
 34953: 
 34953:     if ((siblingDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP ||
 34953:          siblingDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN) !=
 34953:         (aDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP ||
 34953:          aDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN)) {
 34953:       // One's a column or column group and the other is not.  Not valid
 34953:       // siblings.
 80486:       return false;
 80486:     }
 80486: 
 80486:     return true;
     1:   }
  8009:   else if (nsGkAtoms::fieldSetFrame == parentType ||
  8009:            (nsGkAtoms::fieldSetFrame == grandparentType &&
 23176:             nsGkAtoms::blockFrame == parentType)) {
     1:     // Legends can be sibling of legends but not of other content in the fieldset
 95362:     nsIAtom* sibType = aSibling->GetContentInsertionFrame()->GetType();
  7655:     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(aContent));
     1: 
     1:     if ((legendContent  && (nsGkAtoms::legendFrame != sibType)) ||
     1:         (!legendContent && (nsGkAtoms::legendFrame == sibType)))
 80486:       return false;
 80486:   }
 80486: 
 80486:   return true;
     1: }
     1: 
  7655: nsIFrame*
  7655: nsCSSFrameConstructor::FindFrameForContentSibling(nsIContent* aContent,
  7655:                                                   nsIContent* aTargetContent,
108991:                                                   uint8_t& aTargetContentDisplay,
 79445:                                                   bool aPrevSibling)
  7655: {
 36656:   nsIFrame* sibling = aContent->GetPrimaryFrame();
 34147:   if (!sibling || sibling->GetContent() != aContent) {
 34147:     // XXX the GetContent() != aContent check is needed due to bug 135040.
 34147:     // Remove it once that's fixed.
106838:     return nullptr;
  7655:   }
  7655: 
 36656:   // If the frame is out-of-flow, GetPrimaryFrame() will have returned the
  7655:   // out-of-flow frame; we want the placeholder.
  7655:   if (sibling->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 89328:     nsIFrame* placeholderFrame = GetPlaceholderFrameFor(sibling);
  7655:     NS_ASSERTION(placeholderFrame, "no placeholder for out-of-flow frame");
  7655:     sibling = placeholderFrame;
  7655:   }
  7655: 
  8406:   // The frame we have now should never be a continuation
  8406:   NS_ASSERTION(!sibling->GetPrevContinuation(), "How did that happen?");
  7655: 
  7655:   if (aPrevSibling) {
  7655:     // The frame may be a special frame (a split inline frame that
  7655:     // contains a block).  Get the last part of that split.
  7655:     if (IsFrameSpecial(sibling)) {
 80486:       sibling = GetLastSpecialSibling(sibling, true);
  7655:     }
  7655: 
  7655:     // The frame may have a continuation. If so, we want the last
  7655:     // non-overflow-container continuation as our previous sibling.
 10780:     sibling = sibling->GetTailContinuation();
  7655:   }
  7655: 
  7655:   if (aTargetContent &&
  7655:       !IsValidSibling(sibling, aTargetContent, aTargetContentDisplay)) {
106838:     sibling = nullptr;
  7655:   }
  7655: 
  7655:   return sibling;
  7655: }
  7655: 
     1: nsIFrame*
 24404: nsCSSFrameConstructor::FindPreviousSibling(const ChildIterator& aFirst,
 40939:                                            ChildIterator aIter,
108991:                                            uint8_t& aTargetContentDisplay)
 24404: {
 24404:   nsIContent* child = *aIter;
     1: 
     1:   // Note: not all content objects are associated with a frame (e.g., if it's
  7655:   // `display: none') so keep looking until we find a previous frame
 47662:   while (aIter != aFirst) {
 47662:     --aIter;
  7655:     nsIFrame* prevSibling =
 80486:       FindFrameForContentSibling(*aIter, child, aTargetContentDisplay, true);
     1: 
     1:     if (prevSibling) {
     1:       // Found a previous sibling, we're done!
     1:       return prevSibling;
     1:     }
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: nsIFrame*
 24404: nsCSSFrameConstructor::FindNextSibling(ChildIterator aIter,
 40939:                                        const ChildIterator& aLast,
108991:                                        uint8_t& aTargetContentDisplay)
 24404: {
 24404:   if (aIter == aLast) {
 24404:     // XXXbz Can happen when XBL lies to us about insertion points.  This check
 24404:     // might be able to go away once bug 474324 is fixed.
106838:     return nullptr;
 24404:   }
 24404: 
 24404:   nsIContent* child = *aIter;
     1: 
 24404:   while (++aIter != aLast) {
     1:     nsIFrame* nextSibling =
 80486:       FindFrameForContentSibling(*aIter, child, aTargetContentDisplay, false);
     1: 
     1:     if (nextSibling) {
     1:       // We found a next sibling, we're done!
     1:       return nextSibling;
     1:     }
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: // For fieldsets, returns the area frame, if the child is not a legend. 
     1: static nsIFrame*
     1: GetAdjustedParentFrame(nsIFrame*       aParentFrame,
     1:                        nsIAtom*        aParentFrameType,
 24404:                        nsIContent*     aChildContent)
     1: {
  4194:   NS_PRECONDITION(nsGkAtoms::tableOuterFrame != aParentFrameType,
  4194:                   "Shouldn't be happening!");
  4194:   
106838:   nsIFrame* newParent = nullptr;
     1: 
  4194:   if (nsGkAtoms::fieldSetFrame == aParentFrameType) {
     1:     // If the parent is a fieldSet, use the fieldSet's area frame as the
     1:     // parent unless the new content is a legend. 
 24404:     nsCOMPtr<nsIDOMHTMLLegendElement> legendContent(do_QueryInterface(aChildContent));
     1:     if (!legendContent) {
 23176:       newParent = GetFieldSetBlockFrame(aParentFrame);
     1:     }
     1:   }
     1:   return (newParent) ? newParent : aParentFrame;
     1: }
     1: 
 27696: nsIFrame*
 27696: nsCSSFrameConstructor::GetInsertionPrevSibling(nsIFrame*& aParentFrame,
 27696:                                                nsIContent* aContainer,
 27696:                                                nsIContent* aChild,
 79445:                                                bool* aIsAppend,
 79445:                                                bool* aIsRangeInsertSafe,
 40939:                                                nsIContent* aStartSkipChild,
 40939:                                                nsIContent* aEndSkipChild)
 40939: {
 80486:   *aIsAppend = false;
 27696: 
 27696:   // Find the frame that precedes the insertion point. Walk backwards
 27696:   // from the parent frame to get the parent content, because if an
 27696:   // XBL insertion point is involved, we'll need to use _that_ to find
 27696:   // the preceding frame.
 27696: 
 27696:   NS_PRECONDITION(aParentFrame, "Must have parent frame to start with");
 27696:   nsIContent* container = aParentFrame->GetContent();
 27696: 
 27696:   ChildIterator first, last;
 27696:   ChildIterator::Init(container, &first, &last);
 27696:   ChildIterator iter(first);
 79445:   bool xblCase = iter.XBLInvolved() || container != aContainer;
 47662:   if (xblCase || !aChild->IsRootOfAnonymousSubtree()) {
 47662:     // The check for IsRootOfAnonymousSubtree() is because editor is
 47662:     // severely broken and calls us directly for native anonymous
 47662:     // nodes that it creates.
 40939:     if (aStartSkipChild) {
 40939:       iter.seek(aStartSkipChild);
 40939:     } else {
 27696:       iter.seek(aChild);
 40939:     }
 47662:   }
 27696: #ifdef DEBUG
 27696:   else {
 27696:     NS_WARNING("Someone passed native anonymous content directly into frame "
 27696:                "construction.  Stop doing that!");
 27696:   }
 27696: #endif
 27696: 
108991:   uint8_t childDisplay = UNSET_DISPLAY;
 40939:   nsIFrame* prevSibling = FindPreviousSibling(first, iter, childDisplay);
 27696: 
 27696:   // Now, find the geometric parent so that we can handle
 27696:   // continuations properly. Use the prev sibling if we have it;
 27696:   // otherwise use the next sibling.
 27696:   if (prevSibling) {
 27696:     aParentFrame = prevSibling->GetParent()->GetContentInsertionFrame();
 27696:   }
 27696:   else {
 27696:     // If there is no previous sibling, then find the frame that follows
 40939:     if (aEndSkipChild) {
 40939:       iter.seek(aEndSkipChild);
 40939:       iter--;
 40939:     }
 40939:     nsIFrame* nextSibling = FindNextSibling(iter, last, childDisplay);
 27696: 
 27696:     if (nextSibling) {
 27696:       aParentFrame = nextSibling->GetParent()->GetContentInsertionFrame();
 27696:     }
 27696:     else {
 27696:       // No previous or next sibling, so treat this like an appended frame.
 80486:       *aIsAppend = true;
 27696:       if (IsFrameSpecial(aParentFrame)) {
 27696:         // Since we're appending, we'll walk to the last anonymous frame
 27696:         // that was created for the broken inline frame.  But don't walk
 27696:         // to the trailing inline if it's empty; stop at the block.
 80486:         aParentFrame = GetLastSpecialSibling(aParentFrame, false);
 27696:       }
 27696:       // Get continuation that parents the last child.  This MUST be done
 27696:       // before the AdjustAppendParentForAfterContent call.
 27696:       aParentFrame = nsLayoutUtils::GetLastContinuationWithChild(aParentFrame);
 27696:       // Deal with fieldsets
 27696:       aParentFrame = ::GetAdjustedParentFrame(aParentFrame,
 27696:                                               aParentFrame->GetType(),
 27696:                                               aChild);
 27696:       nsIFrame* appendAfterFrame;
 27696:       aParentFrame =
 27696:         ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
 27696:                                             container, aParentFrame,
 27696:                                             &appendAfterFrame);
 27696:       prevSibling = ::FindAppendPrevSibling(aParentFrame, appendAfterFrame);
 27696:     }
 27696:   }
 27696: 
 40939:   *aIsRangeInsertSafe = (childDisplay == UNSET_DISPLAY);
 27696:   return prevSibling;
 27696: }
 27696: 
 79445: static bool
     1: IsSpecialFramesetChild(nsIContent* aContent)
     1: {
     1:   // IMPORTANT: This must match the conditions in nsHTMLFramesetFrame::Init.
 33329:   return aContent->IsHTML() &&
     1:     (aContent->Tag() == nsGkAtoms::frameset ||
     1:      aContent->Tag() == nsGkAtoms::frame);
     1: }
     1: 
 28215: static void
 28215: InvalidateCanvasIfNeeded(nsIPresShell* presShell, nsIContent* node);
 28215: 
 28865: #ifdef MOZ_XUL
 28865: 
 28865: static
 79445: bool
 40939: IsXULListBox(nsIContent* aContainer)
 40939: {
 40939:   return (aContainer->IsXUL() && aContainer->Tag() == nsGkAtoms::listbox);
 40939: }
 40939: 
 40939: static
 28865: nsListBoxBodyFrame*
 28865: MaybeGetListBoxBodyFrame(nsIContent* aContainer, nsIContent* aChild)
 28865: {
 28865:   if (!aContainer)
106838:     return nullptr;
 28865: 
 40939:   if (IsXULListBox(aContainer) &&
 40939:       aChild->IsXUL() && aChild->Tag() == nsGkAtoms::listitem) {
 28865:     nsCOMPtr<nsIDOMXULElement> xulElement = do_QueryInterface(aContainer);
 28865:     nsCOMPtr<nsIBoxObject> boxObject;
 28865:     xulElement->GetBoxObject(getter_AddRefs(boxObject));
 28865:     nsCOMPtr<nsPIListBoxObject> listBoxObject = do_QueryInterface(boxObject);
 28865:     if (listBoxObject) {
 80486:       return listBoxObject->GetListBoxBody(false);
 28865:     }
 28865:   }
 28865: 
106838:   return nullptr;
 28865: }
 28865: #endif
 28865: 
 29501: void
 29525: nsCSSFrameConstructor::AddTextItemIfNeeded(nsFrameConstructorState& aState,
 29525:                                            nsIFrame* aParentFrame,
 47665:                                            nsIContent* aPossibleTextContent,
 29501:                                            FrameConstructionItemList& aItems)
 29501: {
 47665:   NS_PRECONDITION(aPossibleTextContent, "Must have node");
 47665:   if (!aPossibleTextContent->IsNodeOfType(nsINode::eTEXT) ||
 47665:       !aPossibleTextContent->HasFlag(NS_CREATE_FRAME_IF_NON_WHITESPACE)) {
 29501:     // Not text, or not suppressed due to being all-whitespace (if it
 29809:     // were being suppressed, it would have the
 29809:     // NS_CREATE_FRAME_IF_NON_WHITESPACE flag)
 29501:     return;
 29501:   }
 47665:   NS_ASSERTION(!aPossibleTextContent->GetPrimaryFrame(),
 29809:                "Text node has a frame and NS_CREATE_FRAME_IF_NON_WHITESPACE");
 80486:   AddFrameConstructionItems(aState, aPossibleTextContent, false,
 47665:                             aParentFrame, aItems);
 29501: }
 29501: 
 29501: void
 29501: nsCSSFrameConstructor::ReframeTextIfNeeded(nsIContent* aParentContent,
 47669:                                            nsIContent* aContent)
 47669: {
 47669:   if (!aContent->IsNodeOfType(nsINode::eTEXT) ||
 47669:       !aContent->HasFlag(NS_CREATE_FRAME_IF_NON_WHITESPACE)) {
 29501:     // Not text, or not suppressed due to being all-whitespace (if it
 29809:     // were being suppressed, it would have the
 29809:     // NS_CREATE_FRAME_IF_NON_WHITESPACE flag)
 29501:     return;
 29501:   }
 47669:   NS_ASSERTION(!aContent->GetPrimaryFrame(),
 29809:                "Text node has a frame and NS_CREATE_FRAME_IF_NON_WHITESPACE");
106838:   ContentInserted(aParentContent, aContent, nullptr, false);
 40938: }
 40938: 
 40938: // For inserts aChild should be valid, for appends it should be null.
 40938: // Returns true if this operation can be lazy, false if not.
 79445: bool
 40938: nsCSSFrameConstructor::MaybeConstructLazily(Operation aOperation,
 40938:                                             nsIContent* aContainer,
 47659:                                             nsIContent* aChild)
 40938: {
 40938:   if (mPresShell->GetPresContext()->IsChrome() || !aContainer ||
 40938:       aContainer->IsInNativeAnonymousSubtree() || aContainer->IsXUL()) {
 80486:     return false;
 40938:   }
 40938: 
 40938:   if (aOperation == CONTENTINSERT) {
 47659:     if (aChild->IsRootOfAnonymousSubtree() ||
 98127:         aChild->IsEditable() || aChild->IsXUL()) {
 80486:       return false;
 40938:     }
 40938:   } else { // CONTENTAPPEND
 40938:     NS_ASSERTION(aOperation == CONTENTAPPEND,
 40938:                  "operation should be either insert or append");
 47659:     for (nsIContent* child = aChild; child; child = child->GetNextSibling()) {
 47659:       NS_ASSERTION(!child->IsRootOfAnonymousSubtree(),
 47659:                    "Should be coming through the CONTENTAPPEND case");
 98127:       if (child->IsXUL() || child->IsEditable()) {
 80486:         return false;
 40938:       }
 40938:     }
 40938:   }
 40938: 
 40938:   // We can construct lazily; just need to set suitable bits in the content
 40938:   // tree.
 40938: 
 40938:   // Walk up the tree setting the NODE_DESCENDANTS_NEED_FRAMES bit as we go.
 40938:   nsIContent* content = aContainer;
 42284: #ifdef DEBUG
 42558:   // If we hit a node with no primary frame, or the NODE_NEEDS_FRAME bit set
 42558:   // we want to assert, but leaf frames that process their own children and may
 42558:   // ignore anonymous children (eg framesets) make this complicated. So we set
 42558:   // these two booleans if we encounter these situations and unset them if we
 42558:   // hit a node with a leaf frame.
 79445:   bool noPrimaryFrame = false;
 79445:   bool needsFrameBitSet = false;
 42284: #endif
 40938:   while (content &&
 40938:          !content->HasFlag(NODE_DESCENDANTS_NEED_FRAMES)) {
 42284: #ifdef DEBUG
 42558:     if (content->GetPrimaryFrame() && content->GetPrimaryFrame()->IsLeaf()) {
 80486:       noPrimaryFrame = needsFrameBitSet = false;
 42558:     }
 47150:     if (!noPrimaryFrame && !content->GetPrimaryFrame()) {
 80486:       noPrimaryFrame = true;
 42558:     }
 47150:     if (!needsFrameBitSet && content->HasFlag(NODE_NEEDS_FRAME)) {
 80486:       needsFrameBitSet = true;
 42558:     }
 42284: #endif
 40938:     content->SetFlags(NODE_DESCENDANTS_NEED_FRAMES);
 40938:     content = content->GetFlattenedTreeParent();
 40938:   }
 42558: #ifdef DEBUG
 42558:   if (content && content->GetPrimaryFrame() &&
 42558:       content->GetPrimaryFrame()->IsLeaf()) {
 80486:     noPrimaryFrame = needsFrameBitSet = false;
 42558:   }
 42558:   NS_ASSERTION(!noPrimaryFrame, "Ancestors of nodes with frames to be "
 42558:     "constructed lazily should have frames");
 42558:   NS_ASSERTION(!needsFrameBitSet, "Ancestors of nodes with frames to be "
 42558:     "constructed lazily should not have NEEDS_FRAME bit set");
 42558: #endif
 40938: 
 40938:   // Set NODE_NEEDS_FRAME on the new nodes.
 40938:   if (aOperation == CONTENTINSERT) {
 41678:     NS_ASSERTION(!aChild->GetPrimaryFrame() ||
 41678:                  aChild->GetPrimaryFrame()->GetContent() != aChild,
 41678:                  //XXX the aChild->GetPrimaryFrame()->GetContent() != aChild
 41678:                  // check is needed due to bug 135040. Remove it once that's
 41678:                  // fixed.
 40938:                  "setting NEEDS_FRAME on a node that already has a frame?");
 40938:     aChild->SetFlags(NODE_NEEDS_FRAME);
 40938:   } else { // CONTENTAPPEND
 47659:     for (nsIContent* child = aChild; child; child = child->GetNextSibling()) {
 41678:       NS_ASSERTION(!child->GetPrimaryFrame() ||
 41678:                    child->GetPrimaryFrame()->GetContent() != child,
 41678:                    //XXX the child->GetPrimaryFrame()->GetContent() != child
 41678:                    // check is needed due to bug 135040. Remove it once that's
 41678:                    // fixed.
 40938:                    "setting NEEDS_FRAME on a node that already has a frame?");
 40938:       child->SetFlags(NODE_NEEDS_FRAME);
 40938:     }
 40938:   }
 40938: 
 80486:   PostRestyleEventInternal(true);
 80486:   return true;
 40938: }
 40938: 
 40938: void
 40938: nsCSSFrameConstructor::CreateNeededFrames(nsIContent* aContent)
 40938: {
 40938:   NS_ASSERTION(!aContent->HasFlag(NODE_NEEDS_FRAME),
 40938:     "shouldn't get here with a content node that has needs frame bit set");
 40938:   NS_ASSERTION(aContent->HasFlag(NODE_DESCENDANTS_NEED_FRAMES),
 40938:     "should only get here with a content node that has descendants needing frames");
 40938: 
 40938:   aContent->UnsetFlags(NODE_DESCENDANTS_NEED_FRAMES);
 40938: 
 40938:   // We could either descend first (on nodes that don't have NODE_NEEDS_FRAME
 40938:   // set) or issue content notifications for our kids first. In absence of
 40938:   // anything definitive either way we'll go with the latter.
 40938: 
 40938:   // It might be better to use GetChildArray and scan it completely first and
 40938:   // then issue all notifications. (We have to scan it completely first because
 40938:   // constructing frames can set attributes, which can change the storage of
 40938:   // child lists).
 40938: 
 40938:   // Scan the children of aContent to see what operations (if any) we need to
 40938:   // perform.
108991:   uint32_t childCount = aContent->GetChildCount();
 79445:   bool inRun = false;
106838:   nsIContent* firstChildInRun = nullptr;
108991:   for (uint32_t i = 0; i < childCount; i++) {
 40938:     nsIContent* child = aContent->GetChildAt(i);
 40938:     if (child->HasFlag(NODE_NEEDS_FRAME)) {
 41678:       NS_ASSERTION(!child->GetPrimaryFrame() ||
 41678:                    child->GetPrimaryFrame()->GetContent() != child,
 41678:                    //XXX the child->GetPrimaryFrame()->GetContent() != child
 41678:                    // check is needed due to bug 135040. Remove it once that's
 41678:                    // fixed.
 40938:                    "NEEDS_FRAME set on a node that already has a frame?");
 40938:       if (!inRun) {
 80486:         inRun = true;
 40938:         firstChildInRun = child;
 40938:       }
 40938:     } else {
 40938:       if (inRun) {
 80486:         inRun = false;
 40939:         // generate a ContentRangeInserted for [startOfRun,i)
106838:         ContentRangeInserted(aContent, firstChildInRun, child, nullptr,
 80486:                              false);
 40938:       }
 40938:     }
 40938:   }
 40938:   if (inRun) {
 80486:     ContentAppended(aContent, firstChildInRun, false);
 40938:   }
 40938: 
 40938:   // Now descend.
 40938:   ChildIterator iter, last;
 40938:   for (ChildIterator::Init(aContent, &iter, &last);
 40938:        iter != last;
 40938:        ++iter) {
 40938:     nsIContent* child = *iter;
 40938:     if (child->HasFlag(NODE_DESCENDANTS_NEED_FRAMES)) {
 40938:       CreateNeededFrames(child);
 40938:     }
 40938:   }
 40938: }
 40938: 
 40938: void nsCSSFrameConstructor::CreateNeededFrames()
 40938: {
 40938:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
 40938:                "Someone forgot a script blocker");
 40938: 
 41634:   Element* rootElement = mDocument->GetRootElement();
 41634:   NS_ASSERTION(!rootElement || !rootElement->HasFlag(NODE_NEEDS_FRAME),
 41634:     "root element should not have frame created lazily");
 41634:   if (rootElement && rootElement->HasFlag(NODE_DESCENDANTS_NEED_FRAMES)) {
 40938:     BeginUpdate();
 41634:     CreateNeededFrames(rootElement);
 40938:     EndUpdate();
 40938:   }
 29501: }
 29501: 
 40939: void
 40939: nsCSSFrameConstructor::IssueSingleInsertNofications(nsIContent* aContainer,
 47667:                                                     nsIContent* aStartChild,
 47667:                                                     nsIContent* aEndChild,
 79445:                                                     bool aAllowLazyConstruction)
     1: {
 47667:   for (nsIContent* child = aStartChild;
 47667:        child != aEndChild;
 47667:        child = child->GetNextSibling()) {
 40939:     if ((child->GetPrimaryFrame() ||
 89328:          GetUndisplayedContent(child))
 40939: #ifdef MOZ_XUL
 40939:         //  Except listboxes suck, so do NOT skip anything here if
 40939:         //  we plan to notify a listbox.
 40939:         && !MaybeGetListBoxBodyFrame(aContainer, child)
 40939: #endif
 40939:         ) {
 40939:       // Already have a frame or undisplayed entry for this content; a
 40939:       // previous ContentInserted in this loop must have reconstructed
 40939:       // its insertion parent.  Skip it.
 40939:       continue;
 40939:     }
 47667:     // Call ContentInserted with this node.
 47667:     ContentInserted(aContainer, child, mTempFrameTreeState,
 40938:                     aAllowLazyConstruction);
 40939:   }
 40939: }
 40939: 
 40939: nsIFrame*
 40939: nsCSSFrameConstructor::GetRangeInsertionPoint(nsIContent* aContainer,
 40939:                                               nsIFrame* aParentFrame,
 47664:                                               nsIContent* aStartChild,
 47664:                                               nsIContent* aEndChild,
 79445:                                               bool aAllowLazyConstruction)
 40939: {
     1:   // See if we have an XBL insertion point. If so, then that's our
     1:   // real parent frame; if not, then the frame hasn't been built yet
     1:   // and we just bail.
     1:   nsIFrame* insertionPoint;
 79445:   bool multiple = false;
106838:   GetInsertionPoint(aParentFrame, nullptr, &insertionPoint, &multiple);
     1:   if (! insertionPoint)
106838:     return nullptr; // Don't build the frames.
     1:  
 79445:   bool hasInsertion = false;
     1:   if (!multiple) {
 47664:     // XXXbz XBL2/sXBL issue
 47664:     nsIDocument* document = aStartChild->GetDocument();
 47664:     // XXXbz how would |document| be null here?
     1:     if (document &&
 47664:         document->BindingManager()->GetInsertionParent(aStartChild)) {
 80486:       hasInsertion = true;
     1:     }
     1:   }
     1: 
     1:   if (multiple || hasInsertion) {
     1:     // We have an insertion point.  There are some additional tests we need to do
     1:     // in order to ensure that an append is a safe operation.
108991:     uint32_t childCount = 0;
     1: 
     1:     if (!multiple) {
     1:       // We may need to make multiple ContentInserted calls instead.  A
     1:       // reasonable heuristic to employ (in order to maintain good performance)
     1:       // is to find out if the insertion point's content node contains any
     1:       // explicit children.  If it does not, then it is highly likely that 
     1:       // an append is occurring.  (Note it is not definite, and there are insane
     1:       // cases we will not deal with by employing this heuristic, but it beats
     1:       // always falling back to multiple ContentInserted calls).
     1:       //
     1:       // In the multiple insertion point case, we know we're going to need to do
     1:       // multiple ContentInserted calls anyway.
     1:       childCount = insertionPoint->GetContent()->GetChildCount();
     1:     }
     1:  
 40939:     // If we have multiple insertion points or if we have an insertion point
 40939:     // and the operation is not a true append or if the insertion point already
 40939:     // has explicit children, then we must fall back.
106838:     if (multiple || aEndChild != nullptr || childCount > 0) {
 47664:       // Now comes the fun part.  For each inserted child, make a
 47667:       // ContentInserted call as if it had just gotten inserted and
 47667:       // let ContentInserted handle the mess.
 47667:       IssueSingleInsertNofications(aContainer, aStartChild, aEndChild,
 47667:                                    aAllowLazyConstruction);
106838:       return nullptr;
 40939:     }
 40939:   }
 40939: 
 40939:   return insertionPoint;
 40939: }
 40939: 
 79445: bool
 47658: nsCSSFrameConstructor::MaybeRecreateForFrameset(nsIFrame* aParentFrame,
 47658:                                                 nsIContent* aStartChild,
 47658:                                                 nsIContent* aEndChild)
 40939: {
 40939:   if (aParentFrame->GetType() == nsGkAtoms::frameSetFrame) {
     1:     // Check whether we have any kids we care about.
 47658:     for (nsIContent* cur = aStartChild;
 47658:          cur != aEndChild;
 47658:          cur = cur->GetNextSibling()) {
 47658:       if (IsSpecialFramesetChild(cur)) {
     1:         // Just reframe the parent, since framesets are weird like that.
 80486:         RecreateFramesForContent(aParentFrame->GetContent(), false);
 80486:         return true;
 80486:       }
 80486:     }
 80486:   }
 80486:   return false;
 40939: }
 40939: 
 40939: nsresult
 40939: nsCSSFrameConstructor::ContentAppended(nsIContent*     aContainer,
 42107:                                        nsIContent*     aFirstNewContent,
 79445:                                        bool            aAllowLazyConstruction)
 40939: {
 40939:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
 40939:   NS_PRECONDITION(mUpdateCount != 0,
 40939:                   "Should be in an update while creating frames");
 40939: 
 40939: #ifdef DEBUG
 40939:   if (gNoisyContentUpdates) {
 47668:     printf("nsCSSFrameConstructor::ContentAppended container=%p "
 47668:            "first-child=%p lazy=%d\n",
 47668:            static_cast<void*>(aContainer), aFirstNewContent,
 40939:            aAllowLazyConstruction);
 40939:     if (gReallyNoisyContentUpdates && aContainer) {
 40939:       aContainer->List(stdout, 0);
 40939:     }
 40939:   }
 40939: #endif
 40939: 
 58204: #ifdef DEBUG
 58204:   for (nsIContent* child = aFirstNewContent;
 58204:        child;
 58204:        child = child->GetNextSibling()) {
 58204:     // XXX the GetContent() != child check is needed due to bug 135040.
 58204:     // Remove it once that's fixed.  
 58204:     NS_ASSERTION(!child->GetPrimaryFrame() ||
 58204:                  child->GetPrimaryFrame()->GetContent() != child,
 58204:                  "asked to construct a frame for a node that already has a frame");
 58204:   }
 58204: #endif
 58204: 
 40939: #ifdef MOZ_XUL
 40939:   if (aContainer) {
108991:     int32_t namespaceID;
 40939:     nsIAtom* tag =
 40939:       mDocument->BindingManager()->ResolveTag(aContainer, &namespaceID);
 40939: 
 40939:     // Just ignore tree tags, anyway we don't create any frames for them.
 40939:     if (tag == nsGkAtoms::treechildren ||
 40939:         tag == nsGkAtoms::treeitem ||
 40939:         tag == nsGkAtoms::treerow)
 40939:       return NS_OK;
 40939: 
 40939:   }
 40939: #endif // MOZ_XUL
 40939: 
 40939:   // Get the frame associated with the content
 40939:   nsIFrame* parentFrame = GetFrameFor(aContainer);
 40939:   if (! parentFrame)
 40939:     return NS_OK;
 40939: 
 40939:   if (aAllowLazyConstruction &&
 47659:       MaybeConstructLazily(CONTENTAPPEND, aContainer, aFirstNewContent)) {
 40939:     return NS_OK;
 40939:   }
 40939: 
 30749:   LAYOUT_PHASE_TEMP_EXIT();
 40939:   parentFrame = GetRangeInsertionPoint(aContainer, parentFrame,
106838:                                        aFirstNewContent, nullptr,
 47664:                                        aAllowLazyConstruction);
 30749:   LAYOUT_PHASE_TEMP_REENTER();
 40939:   if (!parentFrame) {
 40939:     return NS_OK;
 40939:   }
 40939: 
 40939:   LAYOUT_PHASE_TEMP_EXIT();
106838:   if (MaybeRecreateForFrameset(parentFrame, aFirstNewContent, nullptr)) {
 40939:     LAYOUT_PHASE_TEMP_REENTER();
 40939:     return NS_OK;
 40939:   }
 40939:   LAYOUT_PHASE_TEMP_REENTER();  
     1: 
     1:   if (parentFrame->IsLeaf()) {
     1:     // Nothing to do here; we shouldn't be constructing kids of leaves
 40938:     // Clear lazy bits so we don't try to construct again.
106838:     ClearLazyBits(aFirstNewContent, nullptr);
     1:     return NS_OK;
     1:   }
     1:   
 30749:   if (parentFrame->IsFrameOfType(nsIFrame::eMathML)) {
 30749:     LAYOUT_PHASE_TEMP_EXIT();
 80486:     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), false);
 30749:     LAYOUT_PHASE_TEMP_REENTER();
 30749:     return rv;
 30749:   }
  6862: 
  4696:   // If the frame we are manipulating is a ``special'' frame (that is, one
  4696:   // that's been created as a result of a block-in-inline situation) then we
  4696:   // need to append to the last special sibling, not to the frame itself.
 79445:   bool parentSpecial = IsFrameSpecial(parentFrame);
 29501:   if (parentSpecial) {
     1: #ifdef DEBUG
     1:     if (gNoisyContentUpdates) {
     1:       printf("nsCSSFrameConstructor::ContentAppended: parentFrame=");
     1:       nsFrame::ListTag(stdout, parentFrame);
     1:       printf(" is special\n");
     1:     }
     1: #endif
     1: 
     1:     // Since we're appending, we'll walk to the last anonymous frame
 25738:     // that was created for the broken inline frame.  But don't walk
 27309:     // to the trailing inline if it's empty; stop at the block.
 80486:     parentFrame = GetLastSpecialSibling(parentFrame, false);
     1:   }
     1: 
 27310:   // Get continuation that parents the last child.  This MUST be done
 27310:   // before the AdjustAppendParentForAfterContent call.
 10780:   parentFrame = nsLayoutUtils::GetLastContinuationWithChild(parentFrame);
     1: 
 24404:   // We should never get here with fieldsets, since they have multiple
 24404:   // insertion points.
 29501:   NS_ASSERTION(parentFrame->GetType() != nsGkAtoms::fieldSetFrame,
 24404:                "Unexpected parent");
     1: 
     1:   // Deal with possible :after generated content on the parent
     1:   nsIFrame* parentAfterFrame;
     1:   parentFrame =
     1:     ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
     1:                                         aContainer, parentFrame,
     1:                                         &parentAfterFrame);
     1:   
     1:   // Create some new frames
130516:   nsFrameConstructorState state(mPresShell,
130516:                                 GetAbsoluteContainingBlock(parentFrame, FIXED_POS),
130516:                                 GetAbsoluteContainingBlock(parentFrame, ABS_POS),
     1:                                 GetFloatContainingBlock(parentFrame));
128828:   state.mTreeMatchContext.InitAncestors(aContainer->AsElement());
     1: 
     1:   // See if the containing block has :first-letter style applied.
 79445:   bool haveFirstLetterStyle = false, haveFirstLineStyle = false;
     1:   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
     1:   if (containingBlock) {
  1254:     haveFirstLetterStyle = HasFirstLetterStyle(containingBlock);
  1243:     haveFirstLineStyle =
  1254:       ShouldHaveFirstLineStyle(containingBlock->GetContent(),
132768:                                containingBlock->StyleContext());
     1:   }
     1: 
     1:   if (haveFirstLetterStyle) {
     1:     // Before we get going, remove the current letter frames
     1:     RemoveLetterFrames(state.mPresContext, state.mPresShell,
 89328:                        containingBlock);
     1:   }
     1: 
 29501:   nsIAtom* frameType = parentFrame->GetType();
 79445:   bool haveNoXBLChildren =
106838:     mDocument->BindingManager()->GetXBLChildNodesFor(aContainer) == nullptr;
 25774:   FrameConstructionItemList items;
 47665:   if (aFirstNewContent->GetPreviousSibling() &&
 47665:       GetParentType(frameType) == eTypeBlock &&
 36794:       haveNoXBLChildren) {
 29838:     // If there's a text node in the normal content list just before the new
 29838:     // items, and it has no frame, make a frame construction item for it. If it
 29838:     // doesn't need a frame, ConstructFramesFromItemList below won't give it
 29838:     // one.  No need to do all this if our parent type is not block, though,
 29838:     // since WipeContainingBlock already handles that situation.
 29838:     //
 29501:     // Because we're appending, we don't need to worry about any text
 29501:     // after the appended content; there can only be XBL anonymous content
 29501:     // (text in an XBL binding is not suppressed) or generated content
 29501:     // (and bare text nodes are not generated). Native anonymous content
 29501:     // generated by frames never participates in inline layout.
 47665:     AddTextItemIfNeeded(state, parentFrame,
 47665:                         aFirstNewContent->GetPreviousSibling(), items);
 29501:   }
 47668:   for (nsIContent* child = aFirstNewContent;
 47668:        child;
 47668:        child = child->GetNextSibling()) {
 80486:     AddFrameConstructionItems(state, child, false, parentFrame, items);
 25773:   }
 25773: 
 27310:   nsIFrame* prevSibling = ::FindAppendPrevSibling(parentFrame, parentAfterFrame);
 27310: 
 25773:   // Perform special check for diddling around with the frames in
 25773:   // a special inline frame.
 25773:   // If we're appending before :after content, then we're not really
 25773:   // appending, so let WipeContainingBlock know that.
 26720:   LAYOUT_PHASE_TEMP_EXIT();
 25773:   if (WipeContainingBlock(state, containingBlock, parentFrame, items,
 80486:                           true, prevSibling)) {
 26720:     LAYOUT_PHASE_TEMP_REENTER();
 25773:     return NS_OK;
 25773:   }
 26720:   LAYOUT_PHASE_TEMP_REENTER();
 25773: 
 29501:   // If the parent is a block frame, and we're not in a special case
 29501:   // where frames can be moved around, determine if the list is for the
 29501:   // start or end of the block.
 29501:   if (nsLayoutUtils::GetAsBlock(parentFrame) && !haveFirstLetterStyle &&
 29501:       !haveFirstLineStyle && !parentSpecial) {
 29501:     items.SetLineBoundaryAtStart(!prevSibling ||
107226:         !prevSibling->IsInlineOutside() ||
 29501:         prevSibling->GetType() == nsGkAtoms::brFrame);
 29501:     // :after content can't be <br> so no need to check it
 29501:     items.SetLineBoundaryAtEnd(!parentAfterFrame ||
107226:         !parentAfterFrame->IsInlineOutside());
 29501:   }
 29501:   // To suppress whitespace-only text frames, we have to verify that
 29501:   // our container's DOM child list matches its flattened tree child list.
 29501:   // This is guaranteed to be true if GetXBLChildNodesFor() returns null.
 36794:   items.SetParentHasNoXBLChildren(haveNoXBLChildren);
 29501: 
 25773:   nsFrameItems frameItems;
 26216:   ConstructFramesFromItemList(state, items, parentFrame, frameItems);
 26216: 
 47668:   for (nsIContent* child = aFirstNewContent;
 47668:        child;
 47668:        child = child->GetNextSibling()) {
 26216:     // Invalidate now instead of before the WipeContainingBlock call, just in
 26216:     // case we do wipe; in that case we don't need to do this walk at all.
 26216:     // XXXbz does that matter?  Would it make more sense to save some virtual
 26216:     // GetChildAt calls instead and do this during construction of our
 26216:     // FrameConstructionItemList?
 47668:     InvalidateCanvasIfNeeded(mPresShell, child);
 26216:   }
 26216: 
 26216:   // if the container is a table and a caption was appended, it needs to be put
 26216:   // in the outer table frame's additional child list.
     1:   nsFrameItems captionItems;
  4368:   if (nsGkAtoms::tableFrame == frameType) {
  4368:     // Pull out the captions.  Note that we don't want to do that as we go,
  4368:     // because processing a single caption can add a whole bunch of things to
  4368:     // the frame items due to pseudoframe processing.  So we'd have to pull
  4368:     // captions from a list anyway; might as well do that here.
 26208:     // XXXbz this is no longer true; we could pull captions directly out of the
 26208:     // FrameConstructionItemList now.
  4368:     PullOutCaptionFrames(frameItems, captionItems);
  4368:   }
  4368:   
     1:   if (haveFirstLineStyle && parentFrame == containingBlock) {
     1:     // It's possible that some of the new frames go into a
     1:     // first-line frame. Look at them and see...
     1:     AppendFirstLineFrames(state, containingBlock->GetContent(),
     1:                           containingBlock, frameItems); 
     1:   }
     1: 
     1:   // Notify the parent frame passing it the list of new frames
 27310:   // Append the flowed frames to the principal child list; captions
 27310:   // need special treatment
 30785:   if (captionItems.NotEmpty()) { // append the caption to the outer table
 27310:     NS_ASSERTION(nsGkAtoms::tableFrame == frameType, "how did that happen?");
     1:     nsIFrame* outerTable = parentFrame->GetParent();
 89328:     AppendFrames(outerTable, nsIFrame::kCaptionList, captionItems);
 30785:   }
 30785: 
 30785:   if (frameItems.NotEmpty()) { // append the in-flow kids
 89328:     AppendFramesToParent(state, parentFrame, frameItems, prevSibling);
     1:   }
     1: 
     1:   // Recover first-letter frames
     1:   if (haveFirstLetterStyle) {
 23461:     RecoverLetterFrames(containingBlock);
     1:   }
     1: 
     1: #ifdef DEBUG
     1:   if (gReallyNoisyContentUpdates) {
     1:     printf("nsCSSFrameConstructor::ContentAppended: resulting frame model:\n");
 31709:     parentFrame->List(stdout, 0);
     1:   }
     1: #endif
     1: 
 56292: #ifdef ACCESSIBILITY
 61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
 56292:   if (accService) {
 56292:     accService->ContentRangeInserted(mPresShell, aContainer,
106838:                                      aFirstNewContent, nullptr);
 56292:   }
 56292: #endif
 56292: 
     1:   return NS_OK;
     1: }
     1: 
     1: #ifdef MOZ_XUL
     1: 
     1: enum content_operation
     1: {
     1:     CONTENT_INSERTED,
     1:     CONTENT_REMOVED
     1: };
     1: 
     1: // Helper function to lookup the listbox body frame and send a notification
     1: // for insertion or removal of content
     1: static
 79445: bool NotifyListBoxBody(nsPresContext*    aPresContext,
     1:                          nsIContent*        aContainer,
     1:                          nsIContent*        aChild,
 47669:                          // Only used for the removed notification
 47669:                          nsIContent*        aOldNextSibling,
     1:                          nsIDocument*       aDocument,                         
     1:                          nsIFrame*          aChildFrame,
     1:                          content_operation  aOperation)
     1: {
 28865:   nsListBoxBodyFrame* listBoxBodyFrame =
 28865:     MaybeGetListBoxBodyFrame(aContainer, aChild);
 20990:   if (listBoxBodyFrame) {
     1:     if (aOperation == CONTENT_REMOVED) {
     1:       // Except if we have an aChildFrame and its parent is not the right
     1:       // thing, then we don't do this.  Pseudo frames are so much fun....
     1:       if (!aChildFrame || aChildFrame->GetParent() == listBoxBodyFrame) {
 31436:         listBoxBodyFrame->OnContentRemoved(aPresContext, aContainer,
 47669:                                            aChildFrame, aOldNextSibling);
 80486:         return true;
     1:       }
     1:     } else {
     1:       listBoxBodyFrame->OnContentInserted(aPresContext, aChild);
 80486:       return true;
 80486:     }
 80486:   }
 80486: 
 80486:   return false;
     1: }
     1: #endif // MOZ_XUL
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::ContentInserted(nsIContent*            aContainer,
     1:                                        nsIContent*            aChild,
 40938:                                        nsILayoutHistoryState* aFrameState,
 79445:                                        bool                   aAllowLazyConstruction)
     1: {
 40939:   return ContentRangeInserted(aContainer,
 40939:                               aChild,
 47656:                               aChild->GetNextSibling(),
 40939:                               aFrameState,
 40939:                               aAllowLazyConstruction);
 40939: }
 40939: 
 40939: // ContentRangeInserted handles creating frames for a range of nodes that
 40939: // aren't at the end of their childlist. ContentRangeInserted isn't a real
 40939: // content notification, but rather it handles regular ContentInserted calls
 40939: // for a single node as well as the lazy construction of frames for a range of
 40939: // nodes when called from CreateNeededFrames. For a range of nodes to be
 40939: // suitable to have its frames constructed all at once they must meet the same
 40939: // conditions that ContentAppended imposes (GetRangeInsertionPoint checks
 40939: // these), plus more. Namely when finding the insertion prevsibling we must not
 40939: // need to consult something specific to any one node in the range, so that the
 40939: // insertion prevsibling would be the same for each node in the range. So we
 40939: // pass the first node in the range to GetInsertionPrevSibling, and if
 40939: // IsValidSibling (the only place GetInsertionPrevSibling might look at the
 40939: // passed in node itself) needs to resolve style on the node we record this and
 40939: // return that this range needs to be split up and inserted separately. Table
 40939: // captions need extra attention as we need to determine where to insert them
 40939: // in the caption list, while skipping any nodes in the range being inserted
 40939: // (because when we treat the caption frames the other nodes have had their
 40939: // frames constructed but not yet inserted into the frame tree).
 40939: nsresult
 40939: nsCSSFrameConstructor::ContentRangeInserted(nsIContent*            aContainer,
 47656:                                             nsIContent*            aStartChild,
 47656:                                             nsIContent*            aEndChild,
 40939:                                             nsILayoutHistoryState* aFrameState,
 79445:                                             bool                   aAllowLazyConstruction)
 40939: {
     1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
  6518:   NS_PRECONDITION(mUpdateCount != 0,
  6518:                   "Should be in an update while creating frames");
  6518: 
 47656:   NS_PRECONDITION(aStartChild, "must always pass a child");
 40939: 
     1:   // XXXldb Do we need to re-resolve style to handle the CSS2 + combinator and
     1:   // the :empty pseudo-class?
     1: #ifdef DEBUG
     1:   if (gNoisyContentUpdates) {
 47656:     printf("nsCSSFrameConstructor::ContentRangeInserted container=%p "
 47666:            "start-child=%p end-child=%p lazy=%d\n",
 47656:            static_cast<void*>(aContainer),
 47656:            static_cast<void*>(aStartChild), static_cast<void*>(aEndChild),
 47666:            aAllowLazyConstruction);
     1:     if (gReallyNoisyContentUpdates) {
 40939:       if (aContainer) {
 40939:         aContainer->List(stdout,0);
 40939:       } else {
 47656:         aStartChild->List(stdout, 0);
 40939:       }
     1:     }
     1:   }
     1: #endif
     1: 
 58204: #ifdef DEBUG
 58204:   for (nsIContent* child = aStartChild;
 58204:        child != aEndChild;
 58204:        child = child->GetNextSibling()) {
 58204:     // XXX the GetContent() != child check is needed due to bug 135040.
 58204:     // Remove it once that's fixed.  
 58204:     NS_ASSERTION(!child->GetPrimaryFrame() ||
 58204:                  child->GetPrimaryFrame()->GetContent() != child,
 58204:                  "asked to construct a frame for a node that already has a frame");
 58204:   }
 58204: #endif
 58204: 
     1:   nsresult rv = NS_OK;
     1: 
 79445:   bool isSingleInsert = (aStartChild->GetNextSibling() == aEndChild);
 40939:   NS_ASSERTION(isSingleInsert || !aAllowLazyConstruction,
 40939:                "range insert shouldn't be lazy");
 47667:   NS_ASSERTION(isSingleInsert || aEndChild,
 47667:                "range should not include all nodes after aStartChild");
 40939: 
     1: #ifdef MOZ_XUL
 40939:   if (aContainer && IsXULListBox(aContainer)) {
 40939:     if (isSingleInsert) {
 47656:       if (NotifyListBoxBody(mPresShell->GetPresContext(), aContainer,
 47666:                             // The insert case in NotifyListBoxBody
 47669:                             // doesn't use "old next sibling".
106838:                             aStartChild, nullptr, 
106838:                             mDocument, nullptr, CONTENT_INSERTED)) {
 40939:         return NS_OK;
 40939:       }
 40939:     } else {
 40939:       // We don't handle a range insert to a listbox parent, issue single
 40939:       // ContertInserted calls for each node inserted.
 40939:       LAYOUT_PHASE_TEMP_EXIT();
 47667:       IssueSingleInsertNofications(aContainer, aStartChild, aEndChild,
 40939:                                    aAllowLazyConstruction);
 40939:       LAYOUT_PHASE_TEMP_REENTER();
 40939:       return NS_OK;
 40939:     }
 40939:   }
     1: #endif // MOZ_XUL
     1:   
 28215:   // If we have a null parent, then this must be the document element being
 28215:   // inserted, or some other child of the document in the DOM (might be a PI,
 28215:   // say).
     1:   if (! aContainer) {
 40939:     NS_ASSERTION(isSingleInsert,
 40939:                  "root node insertion should be a single insertion");
 41634:     Element *docElement = mDocument->GetRootElement();
     1: 
 47656:     if (aStartChild != docElement) {
 28215:       // Not the root element; just bail out
 28215:       return NS_OK;
 28215:     }
 28215: 
106838:     NS_PRECONDITION(nullptr == mRootElementFrame,
 28215:                     "root element frame already created");
     1: 
     1:     // Create frames for the document element and its child elements
     1:     nsIFrame*               docElementFrame;
 28215:     rv = ConstructDocElementFrame(docElement, aFrameState, &docElementFrame);
     1: 
  3026:     if (NS_SUCCEEDED(rv) && docElementFrame) {
 47656:       InvalidateCanvasIfNeeded(mPresShell, aStartChild);
     1: #ifdef DEBUG
  3026:       if (gReallyNoisyContentUpdates) {
 40939:         printf("nsCSSFrameConstructor::ContentRangeInserted: resulting frame "
 28215:                "model:\n");
 31709:         mFixedContainingBlock->List(stdout, 0);
     1:       }
     1: #endif
     1:     }
 28215: 
121997:     if (aFrameState) {
121997:       // Restore frame state for the root scroll frame if there is one
121997:       nsIFrame* rootScrollFrame = mPresShell->GetRootScrollFrame();
121997:       if (rootScrollFrame) {
121997:         RestoreFrameStateFor(rootScrollFrame, aFrameState);
121997:       }
121997:     }
121997: 
 56987: #ifdef ACCESSIBILITY
 61464:     nsAccessibilityService* accService = nsIPresShell::AccService();
 56987:     if (accService) {
 56987:       accService->ContentRangeInserted(mPresShell, aContainer,
 56987:                                        aStartChild, aEndChild);
 56987:     }
 56987: #endif
 56987: 
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Otherwise, we've got parent content. Find its frame.
     1:   nsIFrame* parentFrame = GetFrameFor(aContainer);
     1:   if (! parentFrame)
 28215:     return NS_OK;
     1: 
 40938:   if (aAllowLazyConstruction &&
 47659:       MaybeConstructLazily(CONTENTINSERT, aContainer, aStartChild)) {
 40938:     return NS_OK;
 40938:   }
 40938: 
 40939:   if (isSingleInsert) {
     1:     // See if we have an XBL insertion point. If so, then that's our
     1:     // real parent frame; if not, then the frame hasn't been built yet
     1:     // and we just bail.
     1:     nsIFrame* insertionPoint;
 47656:     GetInsertionPoint(parentFrame, aStartChild, &insertionPoint);
     1:     if (! insertionPoint)
     1:       return NS_OK; // Don't build the frames.
     1: 
     1:     parentFrame = insertionPoint;
 40939:   } else {
 40939:     // Get our insertion point. If we need to issue single ContentInserted's
 40939:     // GetRangeInsertionPoint will take care of that for us.
 40939:     LAYOUT_PHASE_TEMP_EXIT();
 40939:     parentFrame = GetRangeInsertionPoint(aContainer, parentFrame,
 47664:                                          aStartChild, aEndChild,
 47664:                                          aAllowLazyConstruction);
 40939:     LAYOUT_PHASE_TEMP_REENTER();
 40939:     if (!parentFrame) {
 40939:       return NS_OK;
 40939:     }
 40939:   }
 40939: 
 79445:   bool isAppend, isRangeInsertSafe;
 27696:   nsIFrame* prevSibling =
 47663:     GetInsertionPrevSibling(parentFrame, aContainer, aStartChild,
 40939:                             &isAppend, &isRangeInsertSafe);
 40939: 
 40939:   // check if range insert is safe
 40939:   if (!isSingleInsert && !isRangeInsertSafe) {
 40939:     // must fall back to a single ContertInserted for each child in the range
 40939:     LAYOUT_PHASE_TEMP_EXIT();
 47667:     IssueSingleInsertNofications(aContainer, aStartChild, aEndChild,
 47667:                                  aAllowLazyConstruction);
 40939:     LAYOUT_PHASE_TEMP_REENTER();
 40939:     return NS_OK;
 40939:   }
 27696: 
     1:   nsIContent* container = parentFrame->GetContent();
     1: 
 29110:   nsIAtom* frameType = parentFrame->GetType();
 30749:   LAYOUT_PHASE_TEMP_EXIT();
 47658:   if (MaybeRecreateForFrameset(parentFrame, aStartChild, aEndChild)) {
 30749:     LAYOUT_PHASE_TEMP_REENTER();
 47658:     return NS_OK;
 47658:   }
 40939:   LAYOUT_PHASE_TEMP_REENTER();
 40939: 
 40939:   // We should only get here with fieldsets when doing a single insert, because
 40939:   // fieldsets have multiple insertion points.
 40939:   NS_ASSERTION(isSingleInsert || frameType != nsGkAtoms::fieldSetFrame,
 40939:                "Unexpected parent");
 29110:   if (frameType == nsGkAtoms::fieldSetFrame &&
 47656:       aStartChild->Tag() == nsGkAtoms::legend) {
 29110:     // Just reframe the parent, since figuring out whether this
 29110:     // should be the new legend and then handling it is too complex.
 29110:     // We could do a little better here --- check if the fieldset already
 29110:     // has a legend which occurs earlier in its child list than this node,
 29110:     // and if so, proceed. But we'd have to extend nsFieldSetFrame
 29110:     // to locate this legend in the inserted frames and extract it.
 30749:     LAYOUT_PHASE_TEMP_EXIT();
 80486:     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), false);
 30749:     LAYOUT_PHASE_TEMP_REENTER();
 30749:     return rv;
 29110:   }
 29110: 
     1:   // Don't construct kids of leaves
     1:   if (parentFrame->IsLeaf()) {
 40938:     // Clear lazy bits so we don't try to construct again.
 47657:     ClearLazyBits(aStartChild, aEndChild);
     1:     return NS_OK;
     1:   }
     1: 
 30749:   if (parentFrame->IsFrameOfType(nsIFrame::eMathML)) {
 30749:     LAYOUT_PHASE_TEMP_EXIT();
 80486:     nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), false);
 30749:     LAYOUT_PHASE_TEMP_REENTER();
 30749:     return rv;
 30749:   }
  6862: 
130516:   nsFrameConstructorState state(mPresShell,
130516:                                 GetAbsoluteContainingBlock(parentFrame, FIXED_POS),
130516:                                 GetAbsoluteContainingBlock(parentFrame, ABS_POS),
     1:                                 GetFloatContainingBlock(parentFrame),
     1:                                 aFrameState);
128828:   state.mTreeMatchContext.InitAncestors(aContainer ?
 92183:                                           aContainer->AsElement() :
106838:                                           nullptr);
     1: 
     1:   // Recover state for the containing block - we need to know if
     1:   // it has :first-letter or :first-line style applied to it. The
     1:   // reason we care is that the internal structure in these cases
     1:   // is not the normal structure and requires custom updating
     1:   // logic.
     1:   nsIFrame* containingBlock = state.mFloatedItems.containingBlock;
 79445:   bool haveFirstLetterStyle = false;
 79445:   bool haveFirstLineStyle = false;
     1: 
     1:   // In order to shave off some cycles, we only dig up the
     1:   // containing block haveFirst* flags if the parent frame where
     1:   // the insertion/append is occurring is an inline or block
     1:   // container. For other types of containers this isn't relevant.
108991:   uint8_t parentDisplay = parentFrame->GetDisplay();
     1: 
     1:   // Examine the parentFrame where the insertion is taking
     1:   // place. If it's a certain kind of container then some special
     1:   // processing is done.
107226:   if ((NS_STYLE_DISPLAY_BLOCK == parentDisplay) ||
107226:       (NS_STYLE_DISPLAY_LIST_ITEM == parentDisplay) ||
107226:       (NS_STYLE_DISPLAY_INLINE == parentDisplay) ||
107226:       (NS_STYLE_DISPLAY_INLINE_BLOCK == parentDisplay)) {
     1:     // Recover the special style flags for the containing block
     1:     if (containingBlock) {
  1254:       haveFirstLetterStyle = HasFirstLetterStyle(containingBlock);
  1243:       haveFirstLineStyle =
  1254:         ShouldHaveFirstLineStyle(containingBlock->GetContent(),
132768:                                  containingBlock->StyleContext());
     1:     }
     1: 
     1:     if (haveFirstLetterStyle) {
 27696:       // If our current parentFrame is a Letter frame, use its parent as our
 27696:       // new parent hint
     1:       if (parentFrame->GetType() == nsGkAtoms::letterFrame) {
 34148:         // If parentFrame is out of flow, then we actually want the parent of
 34148:         // the placeholder frame.
 34148:         if (parentFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 34148:           nsPlaceholderFrame* placeholderFrame =
 89328:             GetPlaceholderFrameFor(parentFrame);
 34148:           NS_ASSERTION(placeholderFrame, "No placeholder for out-of-flow?");
 34148:           parentFrame = placeholderFrame->GetParent();
 34148:         } else {
     1:           parentFrame = parentFrame->GetParent();
     1:         }
 34148:       }
     1: 
     1:       // Remove the old letter frames before doing the insertion
     1:       RemoveLetterFrames(state.mPresContext, mPresShell,
     1:                          state.mFloatedItems.containingBlock);
     1: 
     1:       // Removing the letterframes messes around with the frame tree, removing
 27696:       // and creating frames.  We need to reget our prevsibling, parent frame,
 27696:       // etc.
 47656:       prevSibling = GetInsertionPrevSibling(parentFrame, aContainer,
 47663:                                             aStartChild, &isAppend,
 47663:                                             &isRangeInsertSafe);
 40939: 
 40939:       // Need check whether a range insert is still safe.
 40939:       if (!isSingleInsert && !isRangeInsertSafe) {
 40939:         // Need to recover the letter frames first.
 40939:         RecoverLetterFrames(state.mFloatedItems.containingBlock);
 40939: 
 40939:         // must fall back to a single ContertInserted for each child in the range
 40939:         LAYOUT_PHASE_TEMP_EXIT();
 47667:         IssueSingleInsertNofications(aContainer, aStartChild, aEndChild,
 40939:                                      aAllowLazyConstruction);
 40939:         LAYOUT_PHASE_TEMP_REENTER();
 40939:         return NS_OK;
 40939:       }
 40939: 
 27696:       container = parentFrame->GetContent();
 29838:       frameType = parentFrame->GetType();
     1:     }
     1:   }
     1: 
  8154:   if (!prevSibling) {
 40939:     // We're inserting the new frames as the first child. See if the
  8154:     // parent has a :before pseudo-element
 77154:     nsIFrame* firstChild = parentFrame->GetFirstPrincipalChild();
  8154: 
  8154:     if (firstChild &&
 26101:         nsLayoutUtils::IsGeneratedContentFor(container, firstChild,
  8154:                                              nsCSSPseudoElements::before)) {
  8154:       // Insert the new frames after the last continuation of the :before
 10780:       prevSibling = firstChild->GetTailContinuation();
 27696:       parentFrame = prevSibling->GetParent()->GetContentInsertionFrame();
 27310:       // Don't change isAppend here; we'll can call AppendFrames as needed, and
 27310:       // the change to our prevSibling doesn't affect that.
  8154:     }
  8154:   }
  8154: 
 25774:   FrameConstructionItemList items;
 29838:   ParentType parentType = GetParentType(frameType);
 79445:   bool haveNoXBLChildren =
106838:     mDocument->BindingManager()->GetXBLChildNodesFor(aContainer) == nullptr;
 47665:   if (aStartChild->GetPreviousSibling() &&
 47665:       parentType == eTypeBlock && haveNoXBLChildren) {
 29838:     // If there's a text node in the normal content list just before the
 40939:     // new nodes, and it has no frame, make a frame construction item for
 29838:     // it, because it might need a frame now.  No need to do this if our
 29838:     // parent type is not block, though, since WipeContainingBlock
 29838:     // already handles that sitation.
 47665:     AddTextItemIfNeeded(state, parentFrame, aStartChild->GetPreviousSibling(),
 29501:                         items);
 29501:   }
 29501: 
 40939:   if (isSingleInsert) {
 47666:     AddFrameConstructionItems(state, aStartChild,
 47666:                               aStartChild->IsRootOfAnonymousSubtree(),
 47656:                               parentFrame, items);
 40939:   } else {
 47666:     for (nsIContent* child = aStartChild;
 47666:          child != aEndChild;
 47666:          child = child->GetNextSibling()){
 80486:       AddFrameConstructionItems(state, child, false, parentFrame, items);
 40939:     }
 40939:   }
 40939: 
 47665:   if (aEndChild && parentType == eTypeBlock && haveNoXBLChildren) {
 29838:     // If there's a text node in the normal content list just after the
 40939:     // new nodes, and it has no frame, make a frame construction item for
 29838:     // it, because it might need a frame now.  No need to do this if our
 29838:     // parent type is not block, though, since WipeContainingBlock
 29838:     // already handles that sitation.
 47665:     AddTextItemIfNeeded(state, parentFrame, aEndChild, items);
 29501:   }
 25773: 
 25773:   // Perform special check for diddling around with the frames in
 25773:   // a special inline frame.
 25773:   // If we're appending before :after content, then we're not really
 25773:   // appending, so let WipeContainingBlock know that.
 26720:   LAYOUT_PHASE_TEMP_EXIT();
 25773:   if (WipeContainingBlock(state, containingBlock, parentFrame, items,
 27310:                           isAppend, prevSibling)) {
 26720:     LAYOUT_PHASE_TEMP_REENTER();
 25773:     return NS_OK;
 26720:   }
 26720:   LAYOUT_PHASE_TEMP_REENTER();
 25773: 
 29501:   // If the container is a table and a caption will be appended, it needs to be
     1:   // put in the outer table frame's additional child list.
 29501:   // We make no attempt here to set flags to indicate whether the list
 29501:   // will be at the start or end of a block. It doesn't seem worthwhile.
     1:   nsFrameItems frameItems, captionItems;
 26216:   ConstructFramesFromItemList(state, items, parentFrame, frameItems);
 26216: 
 30785:   if (frameItems.NotEmpty()) {
 47666:     for (nsIContent* child = aStartChild;
 47666:          child != aEndChild;
 47666:          child = child->GetNextSibling()){
 47666:       InvalidateCanvasIfNeeded(mPresShell, child);
 40939:     }
 40939: 
 40939:     if (nsGkAtoms::tableFrame == frameType ||
 40939:         nsGkAtoms::tableOuterFrame == frameType) {
 40939:       PullOutCaptionFrames(frameItems, captionItems);
     1:     }
     1:   }
     1: 
  4194:   // If the parent of our current prevSibling is different from the frame we'll
  4194:   // actually use as the parent, then the calculated insertion point is now
  4194:   // invalid and as it is unknown where to insert correctly we append instead
  4194:   // (bug 341858).
 27310:   // This can affect our prevSibling and isAppend, but should not have any
 27310:   // effect on the WipeContainingBlock above, since this should only happen
 27310:   // when neither parent is a special frame and should not affect whitespace
 27310:   // handling inside table-related frames (and in fact, can only happen when
 27310:   // one of the parents is an outer table and one is an inner table or when the
 27311:   // parent is a fieldset or fieldset content frame).  So it won't affect the
 27311:   // {ib} or XUL box cases in WipeContainingBlock(), and the table pseudo
 27311:   // handling will only be affected by us maybe thinking we're not inserting
 27311:   // at the beginning, whereas we really are.  That would have made us reframe
 27311:   // unnecessarily, but that's ok.
 25773:   // XXXbz we should push our frame construction item code up higher, so we
 25773:   // know what our items are by the time we start figuring out previous
 25773:   // siblings
 30785:   if (prevSibling && frameItems.NotEmpty() &&
 30785:       frameItems.FirstChild()->GetParent() != prevSibling->GetParent()) {
 25773: #ifdef DEBUG
 30785:     nsIFrame* frame1 = frameItems.FirstChild()->GetParent();
 25773:     nsIFrame* frame2 = prevSibling->GetParent();
 25773:     NS_ASSERTION(!IsFrameSpecial(frame1) && !IsFrameSpecial(frame2),
 25773:                  "Neither should be special");
 25773:     NS_ASSERTION((frame1->GetType() == nsGkAtoms::tableFrame &&
 25773:                   frame2->GetType() == nsGkAtoms::tableOuterFrame) ||
 25773:                  (frame1->GetType() == nsGkAtoms::tableOuterFrame &&
 25773:                   frame2->GetType() == nsGkAtoms::tableFrame) ||
 25773:                  frame1->GetType() == nsGkAtoms::fieldSetFrame ||
 25773:                  (frame1->GetParent() &&
 25773:                   frame1->GetParent()->GetType() == nsGkAtoms::fieldSetFrame),
 25773:                  "Unexpected frame types");
 25773: #endif
 80486:     isAppend = true;
 27310:     nsIFrame* appendAfterFrame;
     1:     parentFrame =
     1:       ::AdjustAppendParentForAfterContent(mPresShell->GetPresContext(),
 26101:                                           container,
 30785:                                           frameItems.FirstChild()->GetParent(),
     1:                                           &appendAfterFrame);
 27310:     prevSibling = ::FindAppendPrevSibling(parentFrame, appendAfterFrame);
     1:   }
     1: 
     1:   if (haveFirstLineStyle && parentFrame == containingBlock) {
     1:     // It's possible that the new frame goes into a first-line
     1:     // frame. Look at it and see...
     1:     if (isAppend) {
     1:       // Use append logic when appending
     1:       AppendFirstLineFrames(state, containingBlock->GetContent(),
     1:                             containingBlock, frameItems); 
     1:     }
     1:     else {
     1:       // Use more complicated insert logic when inserting
 26101:       // XXXbz this method is a no-op, so it's easy for the args being passed
 26101:       // here to make no sense without anyone noticing...  If it ever stops
 26101:       // being a no-op, vet them carefully!
 26101:       InsertFirstLineFrames(state, container, containingBlock, &parentFrame,
     1:                             prevSibling, frameItems);
     1:     }
     1:   }
     1:       
 40939:   // We might have captions; put them into the caption list of the
 40939:   // outer table frame.
 40939:   if (captionItems.NotEmpty()) {
 40939:     NS_ASSERTION(nsGkAtoms::tableFrame == frameType ||
 40939:                  nsGkAtoms::tableOuterFrame == frameType,
 40939:                  "parent for caption is not table?");
 40939:     // We need to determine where to put the caption items; start with the
 40939:     // the parent frame that has already been determined and get the insertion
 40939:     // prevsibling of the first caption item.
 40939:     nsIFrame* captionParent = parentFrame;
 79445:     bool captionIsAppend;
106838:     nsIFrame* captionPrevSibling = nullptr;
 40939: 
 40939:     // aIsRangeInsertSafe is ignored on purpose because it is irrelevant here.
 79445:     bool ignored;
 40939:     if (isSingleInsert) {
 40939:       captionPrevSibling =
 47656:         GetInsertionPrevSibling(captionParent, aContainer, aStartChild,
 47663:                                 &captionIsAppend, &ignored);
 40939:     } else {
 40939:       nsIContent* firstCaption = captionItems.FirstChild()->GetContent();
 40939:       // It is very important here that we skip the children in
 47663:       // [aStartChild,aEndChild) when looking for a
 40939:       // prevsibling.
 40939:       captionPrevSibling =
 40939:         GetInsertionPrevSibling(captionParent, aContainer, firstCaption,
 47663:                                 &captionIsAppend, &ignored,
 47663:                                 aStartChild, aEndChild);
 40939:     }
 40939: 
106838:     nsIFrame* outerTable = nullptr;
 40939:     if (GetCaptionAdjustedParent(captionParent, captionItems.FirstChild(),
 40939:                                  &outerTable)) {
 40939:       // If the parent is not an outer table frame we will try to add frames
 40939:       // to a named child list that the parent does not honour and the frames
 40939:       // will get lost
 40939:       NS_ASSERTION(nsGkAtoms::tableOuterFrame == outerTable->GetType(),
 40939:                    "Pseudo frame construction failure; "
 40939:                    "a caption can be only a child of an outer table frame");
 40939: 
 40939:       // If the parent of our current prevSibling is different from the frame
 40939:       // we'll actually use as the parent, then the calculated insertion
 40939:       // point is now invalid (bug 341382).
 40939:       if (captionPrevSibling &&
 40939:           captionPrevSibling->GetParent() != outerTable) {
106838:           captionPrevSibling = nullptr;
 40939:       }
 40939:       if (captionIsAppend) {
 89328:         AppendFrames(outerTable, nsIFrame::kCaptionList, captionItems);
 40939:       } else {
 89328:         InsertFrames(outerTable, nsIFrame::kCaptionList,
 40939:                      captionPrevSibling, captionItems);
 40939:       }
 40939:     }
 40939:   }
 40939: 
 40939:   if (frameItems.NotEmpty()) {
  3663:     // Notify the parent frame
  3663:     if (isAppend) {
 89328:       AppendFramesToParent(state, parentFrame, frameItems, prevSibling);
  3663:     } else {
 89328:       InsertFrames(parentFrame, kPrincipalList, prevSibling, frameItems);
     1:     }
     1:   }
     1: 
     1:   if (haveFirstLetterStyle) {
     1:     // Recover the letter frames for the containing block when
     1:     // it has first-letter style.
 23461:     RecoverLetterFrames(state.mFloatedItems.containingBlock);
     1:   }
     1: 
     1: #ifdef DEBUG
     1:   if (gReallyNoisyContentUpdates && parentFrame) {
 40939:     printf("nsCSSFrameConstructor::ContentRangeInserted: resulting frame model:\n");
 31709:     parentFrame->List(stdout, 0);
     1:   }
     1: #endif
     1: 
 56292: #ifdef ACCESSIBILITY
 61464:   nsAccessibilityService* accService = nsIPresShell::AccService();
 56292:   if (accService) {
 56292:     accService->ContentRangeInserted(mPresShell, aContainer,
 56292:                                      aStartChild, aEndChild);
 56292:   }
 56292: #endif
 56292: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::ContentRemoved(nsIContent* aContainer,
     1:                                       nsIContent* aChild,
 47669:                                       nsIContent* aOldNextSibling,
 29501:                                       RemoveFlags aFlags,
 79445:                                       bool*     aDidReconstruct)
     1: {
     1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
  6518:   NS_PRECONDITION(mUpdateCount != 0,
  6518:                   "Should be in an update while destroying frames");
  6518: 
 80486:   *aDidReconstruct = false;
  7681:   
     1:   // XXXldb Do we need to re-resolve style to handle the CSS2 + combinator and
     1:   // the :empty pseudo-class?
     1: 
     1: #ifdef DEBUG
     1:   if (gNoisyContentUpdates) {
 47669:     printf("nsCSSFrameConstructor::ContentRemoved container=%p child=%p "
 47669:            "old-next-sibling=%p\n",
  3233:            static_cast<void*>(aContainer),
  3233:            static_cast<void*>(aChild),
 47669:            static_cast<void*>(aOldNextSibling));
     1:     if (gReallyNoisyContentUpdates) {
     1:       aContainer->List(stdout, 0);
     1:     }
     1:   }
     1: #endif
     1: 
     1:   nsPresContext *presContext = mPresShell->GetPresContext();
     1:   nsresult                  rv = NS_OK;
     1: 
     1:   // Find the child frame that maps the content
 36656:   nsIFrame* childFrame = aChild->GetPrimaryFrame();
     1: 
 21936:   if (!childFrame || childFrame->GetContent() != aChild) {
 21936:     // XXXbz the GetContent() != aChild check is needed due to bug 135040.
 21936:     // Remove it once that's fixed.
 89328:     ClearUndisplayedContentIn(aChild, aContainer);
     1:   }
     1: 
     1: #ifdef MOZ_XUL
 47669:   if (NotifyListBoxBody(presContext, aContainer, aChild, aOldNextSibling, 
 23941:                         mDocument, childFrame, CONTENT_REMOVED))
     1:     return NS_OK;
     1: 
     1: #endif // MOZ_XUL
     1: 
 28215:   // If we're removing the root, then make sure to remove things starting at
 28215:   // the viewport's child instead of the primary frame (which might even be
 28215:   // null if the root had an XBL binding or display:none, even though the
 28215:   // frames above it got created).  We do the adjustment after the childFrame
 28215:   // check above, because we do want to clear any undisplayed content we might
 28215:   // have for the root.  Detecting removal of a root is a little exciting; in
 28215:   // particular, having a null aContainer is necessary but NOT sufficient.  Due
 28215:   // to how we process reframes, the content node might not even be in our
 28215:   // document by now.  So explicitly check whether the viewport's first kid's
 28215:   // content node is aChild.
 79445:   bool isRoot = false;
 28215:   if (!aContainer) {
 89328:     nsIFrame* viewport = GetRootFrame();
 28215:     if (viewport) {
 77154:       nsIFrame* firstChild = viewport->GetFirstPrincipalChild();
 28215:       if (firstChild && firstChild->GetContent() == aChild) {
 80486:         isRoot = true;
 28215:         childFrame = firstChild;
 28215:         NS_ASSERTION(!childFrame->GetNextSibling(), "How did that happen?");
 28215:       }
 28215:     }
 28215:   }
 28215: 
     1:   if (childFrame) {
 26216:     InvalidateCanvasIfNeeded(mPresShell, aChild);
     1:     
 26471:     // See whether we need to remove more than just childFrame
 30749:     LAYOUT_PHASE_TEMP_EXIT();
 26471:     if (MaybeRecreateContainerForFrameRemoval(childFrame, &rv)) {
 30749:       LAYOUT_PHASE_TEMP_REENTER();
 80486:       *aDidReconstruct = true;
  4696:       return rv;
     1:     }
 30749:     LAYOUT_PHASE_TEMP_REENTER();
     1: 
     1:     // Get the childFrame's parent frame
     1:     nsIFrame* parentFrame = childFrame->GetParent();
  6862:     nsIAtom* parentType = parentFrame->GetType();
  6862: 
  6862:     if (parentType == nsGkAtoms::frameSetFrame &&
     1:         IsSpecialFramesetChild(aChild)) {
     1:       // Just reframe the parent, since framesets are weird like that.
 80486:       *aDidReconstruct = true;
 30749:       LAYOUT_PHASE_TEMP_EXIT();
 80486:       nsresult rv = RecreateFramesForContent(parentFrame->GetContent(), false);
 30749:       LAYOUT_PHASE_TEMP_REENTER();
 30749:       return rv;
     1:     }
     1: 
  6862:     // If we're a child of MathML, then we should reframe the MathML content.
  6862:     // If we're non-MathML, then we would be wrapped in a block so we need to
  6862:     // check our grandparent in that case.
  6862:     nsIFrame* possibleMathMLAncestor = parentType == nsGkAtoms::blockFrame ? 
  6862:          parentFrame->GetParent() : parentFrame;
  7681:     if (possibleMathMLAncestor->IsFrameOfType(nsIFrame::eMathML)) {
 80486:       *aDidReconstruct = true;
 30749:       LAYOUT_PHASE_TEMP_EXIT();
 80486:       nsresult rv = RecreateFramesForContent(possibleMathMLAncestor->GetContent(), false);
 30749:       LAYOUT_PHASE_TEMP_REENTER();
 30749:       return rv;
  7681:     }
  6862: 
  7189:     // Undo XUL wrapping if it's no longer needed.
  7189:     // (If we're in the XUL block-wrapping situation, parentFrame is the
  7189:     // wrapper frame.)
  7189:     nsIFrame* grandparentFrame = parentFrame->GetParent();
  7189:     if (grandparentFrame && grandparentFrame->IsBoxFrame() &&
  7189:         (grandparentFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
  7189:         // check if this frame is the only one needing wrapping
 77154:         aChild == AnyKidsNeedBlockParent(parentFrame->GetFirstPrincipalChild()) &&
  7189:         !AnyKidsNeedBlockParent(childFrame->GetNextSibling())) {
 80486:       *aDidReconstruct = true;
 30749:       LAYOUT_PHASE_TEMP_EXIT();
 80486:       nsresult rv = RecreateFramesForContent(grandparentFrame->GetContent(), true);
 30749:       LAYOUT_PHASE_TEMP_REENTER();
 30749:       return rv;
  7189:     }
  7189: 
 56292: #ifdef ACCESSIBILITY
 61464:     nsAccessibilityService* accService = nsIPresShell::AccService();
 56292:     if (accService) {
 56292:       accService->ContentRemoved(mPresShell, aContainer, aChild);
 56292:     }
 56292: #endif
 56292: 
     1:     // Examine the containing-block for the removed content and see if
     1:     // :first-letter style applies.
 36805:     nsIFrame* inflowChild = childFrame;
 36805:     if (childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 89328:       inflowChild = GetPlaceholderFrameFor(childFrame);
 36805:       NS_ASSERTION(inflowChild, "No placeholder for out-of-flow?");
 36805:     }
 36805:     nsIFrame* containingBlock =
 36805:       GetFloatContainingBlock(inflowChild->GetParent());
 79445:     bool haveFLS = containingBlock && HasFirstLetterStyle(containingBlock);
     1:     if (haveFLS) {
     1:       // Trap out to special routine that handles adjusting a blocks
     1:       // frame tree when first-letter style is present.
     1: #ifdef NOISY_FIRST_LETTER
     1:       printf("ContentRemoved: containingBlock=");
     1:       nsFrame::ListTag(stdout, containingBlock);
     1:       printf(" parentFrame=");
     1:       nsFrame::ListTag(stdout, parentFrame);
     1:       printf(" childFrame=");
     1:       nsFrame::ListTag(stdout, childFrame);
     1:       printf("\n");
     1: #endif
     1: 
     1:       // First update the containing blocks structure by removing the
     1:       // existing letter frames. This makes the subsequent logic
     1:       // simpler.
 89328:       RemoveLetterFrames(presContext, mPresShell, containingBlock);
     1: 
     1:       // Recover childFrame and parentFrame
 36656:       childFrame = aChild->GetPrimaryFrame();
 21936:       if (!childFrame || childFrame->GetContent() != aChild) {
 21936:         // XXXbz the GetContent() != aChild check is needed due to bug 135040.
 21936:         // Remove it once that's fixed.
 89328:         ClearUndisplayedContentIn(aChild, aContainer);
     1:         return NS_OK;
     1:       }
     1:       parentFrame = childFrame->GetParent();
 29580:       parentType = parentFrame->GetType();
     1: 
     1: #ifdef NOISY_FIRST_LETTER
     1:       printf("  ==> revised parentFrame=");
     1:       nsFrame::ListTag(stdout, parentFrame);
     1:       printf(" childFrame=");
     1:       nsFrame::ListTag(stdout, childFrame);
     1:       printf("\n");
     1: #endif
     1:     }
     1: 
     1: #ifdef DEBUG
     1:     if (gReallyNoisyContentUpdates) {
     1:       printf("nsCSSFrameConstructor::ContentRemoved: childFrame=");
     1:       nsFrame::ListTag(stdout, childFrame);
 31709:       putchar('\n');
 31709:       parentFrame->List(stdout, 0);
     1:     }
     1: #endif
     1: 
 36646: 
 36646:     // Notify the parent frame that it should delete the frame
     1:     if (childFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
 89328:       childFrame = GetPlaceholderFrameFor(childFrame);
 36646:       NS_ASSERTION(childFrame, "Missing placeholder frame for out of flow.");
 36646:       parentFrame = childFrame->GetParent();
 36646:     }
 89328:     rv = RemoveFrame(nsLayoutUtils::GetChildListNameFor(childFrame),
     1:                      childFrame);
 36646:     //XXXfr NS_ENSURE_SUCCESS(rv, rv) ?
     1: 
 28215:     if (isRoot) {
106838:       mRootElementFrame = nullptr;
106838:       mRootElementStyleFrame = nullptr;
106838:       mDocElementContainingBlock = nullptr;
106838:       mPageSequenceFrame = nullptr;
106838:       mGfxScrollFrame = nullptr;
 80486:       mHasRootAbsPosContainingBlock = false;
 89328:       mFixedContainingBlock = GetRootFrame();
     1:     }
     1: 
 24659:     if (haveFLS && mRootElementFrame) {
 23461:       RecoverLetterFrames(containingBlock);
     1:     }
     1: 
 29501:     // If we're just reconstructing frames for the element, then the
 29501:     // following ContentInserted notification on the element will
 29580:     // take care of fixing up any adjacent text nodes.  We don't need
 29580:     // to do this if the table parent type of our parent type is not
 29580:     // eTypeBlock, though, because in that case the whitespace isn't
 29580:     // being suppressed due to us anyway.
 47669:     if (aContainer && !aChild->IsRootOfAnonymousSubtree() &&
 29580:         aFlags != REMOVE_FOR_RECONSTRUCTION &&
 29580:         GetParentType(parentType) == eTypeBlock) {
 29501:       // Adjacent whitespace-only text nodes might have been suppressed if
 29501:       // this node does not have inline ends. Create frames for them now
 29501:       // if necessary.
 29525:       // Reframe any text node just before the node being removed, if there is
 29525:       // one, and if it's not the last child or the first child. If a whitespace
 29525:       // textframe was being suppressed and it's now the last child or first
 29525:       // child then it can stay suppressed since the parent must be a block
 29525:       // and hence it's adjacent to a block end.
 47669:       // If aOldNextSibling is null, then the text node before the node being
 47669:       // removed is the last node, and we don't need to worry about it.
 47669:       if (aOldNextSibling) {
 47669:         nsIContent* prevSibling = aOldNextSibling->GetPreviousSibling();
 47669:         if (prevSibling && prevSibling->GetPreviousSibling()) {
 30749:           LAYOUT_PHASE_TEMP_EXIT();
 47669:           ReframeTextIfNeeded(aContainer, prevSibling);
 30749:           LAYOUT_PHASE_TEMP_REENTER();
 29525:         }
 47669:       }
 29525:       // Reframe any text node just after the node being removed, if there is
 29525:       // one, and if it's not the last child or the first child.
 47669:       if (aOldNextSibling && aOldNextSibling->GetNextSibling() &&
 47669:           aOldNextSibling->GetPreviousSibling()) {
 30749:         LAYOUT_PHASE_TEMP_EXIT();
 47669:         ReframeTextIfNeeded(aContainer, aOldNextSibling);
 30749:         LAYOUT_PHASE_TEMP_REENTER();
 29501:       }
 29501:     }
 29501: 
     1: #ifdef DEBUG
     1:     if (gReallyNoisyContentUpdates && parentFrame) {
     1:       printf("nsCSSFrameConstructor::ContentRemoved: resulting frame model:\n");
 31709:       parentFrame->List(stdout, 0);
     1:     }
     1: #endif
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: #ifdef DEBUG
     1:   // To ensure that the functions below are only called within
     1:   // |ApplyRenderingChangeToTree|.
 79445: static bool gInApplyRenderingChangeToTree = false;
     1: #endif
     1: 
     1: static void
     1: DoApplyRenderingChangeToTree(nsIFrame* aFrame,
     1:                              nsFrameManager* aFrameManager,
     1:                              nsChangeHint aChange);
     1: 
     1: /**
     1:  * This rect is relative to aFrame's parent
     1:  */
     1: static void
 87352: UpdateViewsForTree(nsIFrame* aFrame,
     1:                    nsFrameManager* aFrameManager,
   134:                    nsChangeHint aChange)
     1: {
     1:   NS_PRECONDITION(gInApplyRenderingChangeToTree,
     1:                   "should only be called within ApplyRenderingChangeToTree");
     1: 
127357:   nsView* view = aFrame->GetView();
     1:   if (view) {
     1:     if (aChange & nsChangeHint_SyncFrameView) {
   238:       nsContainerFrame::SyncFrameViewProperties(aFrame->PresContext(),
106838:                                                 aFrame, nullptr, view);
     1:     }
     1:   }
     1: 
 77153:   nsIFrame::ChildListIterator lists(aFrame);
 77153:   for (; !lists.IsDone(); lists.Next()) {
 77153:     nsFrameList::Enumerator childFrames(lists.CurrentList());
 77153:     for (; !childFrames.AtEnd(); childFrames.Next()) {
 77153:       nsIFrame* child = childFrames.get();
 59405:       if (!(child->GetStateBits() & NS_FRAME_OUT_OF_FLOW)) {
  7655:         // only do frames that don't have placeholders
 49314:         if (nsGkAtoms::placeholderFrame == child->GetType()) {
 49314:           // do the out-of-flow frame and its continuations
     1:           nsIFrame* outOfFlowFrame =
     1:             nsPlaceholderFrame::GetRealFrameForPlaceholder(child);
 49314:           do {
 87352:             DoApplyRenderingChangeToTree(outOfFlowFrame, aFrameManager,
 87352:                                          aChange);
 62664:           } while ((outOfFlowFrame = outOfFlowFrame->GetNextContinuation()));
 77153:         } else if (lists.CurrentID() == nsIFrame::kPopupList) {
 87352:           DoApplyRenderingChangeToTree(child, aFrameManager,
 87352:                                        aChange);
 48167:         } else {  // regular frame
 87352:           UpdateViewsForTree(child, aFrameManager, aChange);
     1:         }
     1:       }
 77153:     }
 77153:   }
     1: }
     1: 
119514: /**
119514:  * To handle nsChangeHint_ChildrenOnlyTransform we must iterate over the child
119514:  * frames of the SVG frame concerned. This helper function is used to find that
119514:  * SVG frame when we encounter nsChangeHint_ChildrenOnlyTransform to ensure
119514:  * that we iterate over the intended children, since sometimes we end up
119514:  * handling that hint while processing hints for one of the SVG frame's
119514:  * ancestor frames.
119514:  *
119514:  * The reason that we sometimes end up trying to process the hint for an
119514:  * ancestor of the SVG frame that the hint is intended for is due to the way we
119514:  * process restyle events. ApplyRenderingChangeToTree adjusts the frame from
119514:  * the restyled element's principle frame to one of its ancestor frames based
119514:  * on what nsCSSRendering::FindBackground returns, since the background style
119514:  * may have been propagated up to an ancestor frame. Processing hints using an
119514:  * ancestor frame is fine in general, but nsChangeHint_ChildrenOnlyTransform is
119514:  * a special case since it is intended to update the children of a specific
119514:  * frame.
119514:  */
119514: static nsIFrame*
119514: GetFrameForChildrenOnlyTransformHint(nsIFrame *aFrame)
119514: {
119514:   if (aFrame->GetType() == nsGkAtoms::viewportFrame) {
119514:     // This happens if the root-<svg> is fixed positioned, in which case we
119514:     // can't use aFrame->GetContent() to find the primary frame, since
119514:     // GetContent() returns nullptr for ViewportFrame.
119514:     aFrame = aFrame->GetFirstPrincipalChild();
119514:   }
119514:   // For an nsHTMLScrollFrame, this will get the SVG frame that has the
119514:   // children-only transforms:
119514:   aFrame = aFrame->GetContent()->GetPrimaryFrame();
126160:   if (aFrame->GetType() == nsGkAtoms::svgOuterSVGFrame) {
126160:     aFrame = aFrame->GetFirstPrincipalChild();
126160:     NS_ABORT_IF_FALSE(aFrame->GetType() == nsGkAtoms::svgOuterSVGAnonChildFrame,
126160:                       "Where is the nsSVGOuterSVGFrame's anon child??");
126160:   }
119514:   NS_ABORT_IF_FALSE(aFrame->IsFrameOfType(nsIFrame::eSVG |
119514:                                           nsIFrame::eSVGContainer),
119514:                     "Children-only transforms only expected on SVG frames");
119514:   return aFrame;
119514: }
119514: 
     1: static void
     1: DoApplyRenderingChangeToTree(nsIFrame* aFrame,
     1:                              nsFrameManager* aFrameManager,
     1:                              nsChangeHint aChange)
     1: {
     1:   NS_PRECONDITION(gInApplyRenderingChangeToTree,
     1:                   "should only be called within ApplyRenderingChangeToTree");
     1: 
    94:   for ( ; aFrame; aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame)) {
     1:     // Get view if this frame has one and trigger an update. If the
     1:     // frame doesn't have a view, find the nearest containing view
     1:     // (adjusting r's coordinate system to reflect the nesting) and
     1:     // update there.
 89651:     // We don't need to update transforms in UpdateViewsForTree, because
 89651:     // there can't be any out-of-flows or popups that need to be transformed;
 89651:     // all out-of-flow descendants of the transformed element must also be
 89651:     // descendants of the transformed frame.
 89651:     UpdateViewsForTree(aFrame, aFrameManager,
 89651:                        nsChangeHint(aChange & (nsChangeHint_RepaintFrame |
 89651:                                                nsChangeHint_SyncFrameView |
 89651:                                                nsChangeHint_UpdateOpacityLayer)));
116072:     // This must be set to true if the rendering change needs to
116072:     // invalidate content.  If it's false, a composite-only paint
116072:     // (empty transaction) will be scheduled.
116072:     bool needInvalidatingPaint = false;
     1: 
     1:     // if frame has view, will already be invalidated
 24030:     if (aChange & nsChangeHint_RepaintFrame) {
102845:       if (aFrame->IsFrameOfType(nsIFrame::eSVG) &&
102845:           !(aFrame->GetStateBits() & NS_STATE_IS_OUTER_SVG)) {
 91898:         if (aChange & nsChangeHint_UpdateEffects) {
116072:           needInvalidatingPaint = true;
 93574:           // Invalidate and update our area:
126095:           nsSVGUtils::InvalidateBounds(aFrame, false);
126095:           nsSVGUtils::ScheduleReflowSVG(aFrame);
 24030:         } else {
116072:           needInvalidatingPaint = true;
 91898:           // Just invalidate our area:
 93574:           nsSVGUtils::InvalidateBounds(aFrame);
 91898:         }
 91898:       } else {
116072:         needInvalidatingPaint = true;
115305:         aFrame->InvalidateFrameSubtree();
     1:       }
     1:     }
121211:     if (aChange & nsChangeHint_UpdateTextPath) {
132157:       if (aFrame->GetType() == nsGkAtoms::svgTextPathFrame) {
121211:         // Invalidate and reflow the entire nsSVGTextFrame:
121211:         static_cast<nsSVGTextPathFrame*>(aFrame)->NotifyGlyphMetricsChange();
132157:       } else if (aFrame->IsSVGText()) {
132157:         // Invalidate and reflow the entire nsSVGTextFrame2:
132157:         NS_ASSERTION(aFrame->GetContent()->IsSVG(nsGkAtoms::textPath),
132157:                      "expected frame for a <textPath> element");
132157:         nsIFrame* text = nsLayoutUtils::GetClosestFrameOfType(
132157:                                                       aFrame,
132157:                                                       nsGkAtoms::svgTextFrame2);
132157:         NS_ASSERTION(text, "expected to find an ancestor nsSVGTextFrame2");
132157:         static_cast<nsSVGTextFrame2*>(text)->NotifyGlyphMetricsChange();
132157:       } else {
132157:         NS_ABORT_IF_FALSE(false, "unexpected frame got "
132157:                                  "nsChangeHint_UpdateTextPath");
132157:       }
121211:     }
 47740:     if (aChange & nsChangeHint_UpdateOpacityLayer) {
116072:       // FIXME/bug 796697: we can get away with empty transactions for
116072:       // opacity updates in many cases.
116072:       needInvalidatingPaint = true;
 72242:       aFrame->MarkLayersActive(nsChangeHint_UpdateOpacityLayer);
 47740:     }
127106:     if ((aChange & nsChangeHint_UpdateTransformLayer) &&
127106:         aFrame->IsTransformed()) {
 72242:       aFrame->MarkLayersActive(nsChangeHint_UpdateTransformLayer);
116072:       // If we're not already going to do an invalidating paint, see
116072:       // if we can get away with only updating the transform on a
116072:       // layer for this frame, and not scheduling an invalidating
116072:       // paint.
116072:       if (!needInvalidatingPaint) {
116072:         needInvalidatingPaint |= !aFrame->TryUpdateTransformOnly();
116072:       }
103530:     }
105956:     if (aChange & nsChangeHint_ChildrenOnlyTransform) {
116072:       needInvalidatingPaint = true;
119514:       nsIFrame* childFrame =
119514:         GetFrameForChildrenOnlyTransformHint(aFrame)->GetFirstPrincipalChild();
105956:       for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
105956:         childFrame->MarkLayersActive(nsChangeHint_UpdateTransformLayer);
115305:       }
115305:     }
116072:     aFrame->SchedulePaint(needInvalidatingPaint ?
116072:                           nsIFrame::PAINT_DEFAULT :
116072:                           nsIFrame::PAINT_COMPOSITE_ONLY);
     1:   }
 24030: }
     1: 
     1: static void
     1: ApplyRenderingChangeToTree(nsPresContext* aPresContext,
     1:                            nsIFrame* aFrame,
     1:                            nsChangeHint aChange)
     1: {
132812:   // We check StyleDisplay()->HasTransform() in addition to checking
125199:   // IsTransformed() since we can get here for some frames that don't support
125199:   // CSS transforms.
 91352:   NS_ASSERTION(!(aChange & nsChangeHint_UpdateTransformLayer) ||
 98711:                aFrame->IsTransformed() ||
132812:                aFrame->StyleDisplay()->HasTransformStyle(),
 98711:                "Unexpected UpdateTransformLayer hint");
 90031: 
     1:   nsIPresShell *shell = aPresContext->PresShell();
 40049:   if (shell->IsPaintingSuppressed()) {
     1:     // Don't allow synchronous rendering changes when painting is turned off.
     1:     aChange = NS_SubtractHint(aChange, nsChangeHint_RepaintFrame);
     1:     if (!aChange) {
     1:       return;
     1:     }
     1:   }
     1: 
     1:   // If the frame's background is propagated to an ancestor, walk up to
     1:   // that ancestor.
 40177:   nsStyleContext *bgSC;
 40177:   while (!nsCSSRendering::FindBackground(aPresContext, aFrame, &bgSC)) {
     1:     aFrame = aFrame->GetParent();
     1:     NS_ASSERTION(aFrame, "root frame must paint");
     1:   }
     1: 
     1:   // Trigger rendering updates by damaging this frame and any
     1:   // continuations of this frame.
     1: 
     1:   // XXX this needs to detect the need for a view due to an opacity change and deal with it...
     1: 
     1: #ifdef DEBUG
 80486:   gInApplyRenderingChangeToTree = true;
     1: #endif
 87352:   DoApplyRenderingChangeToTree(aFrame, shell->FrameManager(), aChange);
     1: #ifdef DEBUG
 80486:   gInApplyRenderingChangeToTree = false;
     1: #endif
     1: }
     1: 
     1: /**
     1:  * This method invalidates the canvas when frames are removed or added for a
     1:  * node that might have its background propagated to the canvas, i.e., a
     1:  * document root node or an HTML BODY which is a child of the root node.
     1:  *
 26471:  * @param aFrame a frame for a content node about to be removed or a frame that
     1:  *               was just created for a content node that was inserted.
     1:  */ 
     1: static void
 26216: InvalidateCanvasIfNeeded(nsIPresShell* presShell, nsIContent* node)
 26216: {
 26216:   NS_PRECONDITION(presShell->GetRootFrame(), "What happened here?");
 26216:   NS_PRECONDITION(presShell->GetPresContext(), "Say what?");
 26216: 
 26216:   //  Note that both in ContentRemoved and ContentInserted the content node
     1:   //  will still have the right parent pointer, so looking at that is ok.
     1:   
     1:   nsIContent* parent = node->GetParent();
     1:   if (parent) {
     1:     // Has a parent; might not be what we want
     1:     nsIContent* grandParent = parent->GetParent();
     1:     if (grandParent) {
     1:       // Has a grandparent, so not what we want
     1:       return;
     1:     }
     1: 
     1:     // Check whether it's an HTML body
     1:     if (node->Tag() != nsGkAtoms::body ||
 33329:         !node->IsHTML()) {
     1:       return;
     1:     }
     1:   }
     1: 
     1:   // At this point the node has no parent or it's an HTML <body> child of the
     1:   // root.  We might not need to invalidate in this case (eg we might be in
 26216:   // XHTML or something), but chances are we want to.  Play it safe.
 26216:   // Invalidate the viewport.
 26216: 
 34785:   nsIFrame* rootFrame = presShell->GetRootFrame();
 51756:   rootFrame->InvalidateFrameSubtree();
     1: }
     1: 
     1: nsresult
 31101: nsCSSFrameConstructor::StyleChangeReflow(nsIFrame* aFrame,
 31101:                                          nsChangeHint aHint)
     1: {
     1:   // If the frame hasn't even received an initial reflow, then don't
     1:   // send it a style-change reflow!
     1:   if (aFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)
     1:     return NS_OK;
     1: 
     1: #ifdef DEBUG
     1:   if (gNoisyContentUpdates) {
     1:     printf("nsCSSFrameConstructor::StyleChangeReflow: aFrame=");
     1:     nsFrame::ListTag(stdout, aFrame);
     1:     printf("\n");
     1:   }
     1: #endif
     1: 
 31101:   nsIPresShell::IntrinsicDirty dirtyType;
 31101:   if (aHint & nsChangeHint_ClearDescendantIntrinsics) {
 31101:     NS_ASSERTION(aHint & nsChangeHint_ClearAncestorIntrinsics,
 31101:                  "Please read the comments in nsChangeHint.h");
 31101:     dirtyType = nsIPresShell::eStyleChange;
 31101:   } else if (aHint & nsChangeHint_ClearAncestorIntrinsics) {
 31101:     dirtyType = nsIPresShell::eTreeChange;
 31101:   } else {
 31101:     dirtyType = nsIPresShell::eResize;
 31101:   }
 31101: 
 31101:   nsFrameState dirtyBits;
 31101:   if (aHint & nsChangeHint_NeedDirtyReflow) {
 31101:     dirtyBits = NS_FRAME_IS_DIRTY;
 31101:   } else {
 31101:     dirtyBits = NS_FRAME_HAS_DIRTY_CHILDREN;
 31101:   }
     1: 
  6521:   do {
 31101:     mPresShell->FrameNeedsReflow(aFrame, dirtyType, dirtyBits);
 31101:     aFrame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(aFrame);
  6521:   } while (aFrame);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::CharacterDataChanged(nsIContent* aContent,
 31131:                                             CharacterDataChangeInfo* aInfo)
     1: {
     1:   AUTO_LAYOUT_PHASE_ENTRY_POINT(mPresShell->GetPresContext(), FrameC);
     1:   nsresult      rv = NS_OK;
     1: 
 29809:   if ((aContent->HasFlag(NS_CREATE_FRAME_IF_NON_WHITESPACE) &&
 29809:        !aContent->TextIsOnlyWhitespace()) ||
 29809:       (aContent->HasFlag(NS_REFRAME_IF_WHITESPACE) &&
 29809:        aContent->TextIsOnlyWhitespace())) {
 27311: #ifdef DEBUG
 36656:     nsIFrame* frame = aContent->GetPrimaryFrame();
 27311:     NS_ASSERTION(!frame || !frame->IsGeneratedContentFrame(),
 27311:                  "Bit should never be set on generated content");
 27311: #endif
 30749:     LAYOUT_PHASE_TEMP_EXIT();
 80486:     nsresult rv = RecreateFramesForContent(aContent, false);
 30749:     LAYOUT_PHASE_TEMP_REENTER();
 30749:     return rv;
 27311:   }
 27311: 
     1:   // Find the child frame
 36656:   nsIFrame* frame = aContent->GetPrimaryFrame();
     1: 
     1:   // Notify the first frame that maps the content. It will generate a reflow
     1:   // command
     1: 
     1:   // It's possible the frame whose content changed isn't inserted into the
     1:   // frame hierarchy yet, or that there is no frame that maps the content
106838:   if (nullptr != frame) {
     1: #if 0
     1:     NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
     1:        ("nsCSSFrameConstructor::CharacterDataChanged: content=%p[%s] subcontent=%p frame=%p",
     1:         aContent, ContentTag(aContent, 0),
     1:         aSubContent, frame));
     1: #endif
     1: 
     1:     // Special check for text content that is a child of a letter frame.  If
     1:     // this happens, we should remove the letter frame, do whatever we're
     1:     // planning to do with this notification, then put the letter frame back.
 28215:     // Note that this is basically what RecreateFramesForContent ends up doing;
 28215:     // the reason we dont' want to call that here is that our text content
 28215:     // could be native anonymous, in which case RecreateFramesForContent would
 28215:     // completely barf on it.  And recreating the non-anonymous ancestor would
 28215:     // just lead us to come back into this notification (e.g. if quotes or
 28215:     // counters are involved), leading to a loop.
     1:     nsIFrame* block = GetFloatContainingBlock(frame);
 79445:     bool haveFirstLetterStyle = false;
     1:     if (block) {
     1:       // See if the block has first-letter style applied to it.
  1254:       haveFirstLetterStyle = HasFirstLetterStyle(block);
     1:       if (haveFirstLetterStyle) {
     1:         RemoveLetterFrames(mPresShell->GetPresContext(), mPresShell,
 89328:                            block);
     1:         // Reget |frame|, since we might have killed it.
     1:         // Do we really need to call CharacterDataChanged in this case, though?
 36656:         frame = aContent->GetPrimaryFrame();
     1:         NS_ASSERTION(frame, "Should have frame here!");
     1:       }
     1:     }
     1: 
 31131:     frame->CharacterDataChanged(aInfo);
     1: 
     1:     if (haveFirstLetterStyle) {
 23461:       RecoverLetterFrames(block);
     1:     }
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
106838: NS_DECLARE_FRAME_PROPERTY(ChangeListProperty, nullptr)
 39965: 
108182: /**
118899:  * Return true if aFrame's subtree has placeholders for out-of-flow content
118899:  * whose 'position' style's bit in aPositionMask is set.
108182:  */
108182: static bool
118899: FrameHasPositionedPlaceholderDescendants(nsIFrame* aFrame, uint32_t aPositionMask)
108182: {
108182:   const nsIFrame::ChildListIDs skip(nsIFrame::kAbsoluteList |
108182:                                     nsIFrame::kFixedList);
108182:   for (nsIFrame::ChildListIterator lists(aFrame); !lists.IsDone(); lists.Next()) {
108182:     if (!skip.Contains(lists.CurrentID())) {
108182:       for (nsFrameList::Enumerator childFrames(lists.CurrentList());
108182:            !childFrames.AtEnd(); childFrames.Next()) {
108182:         nsIFrame* f = childFrames.get();
118899:         if (f->GetType() == nsGkAtoms::placeholderFrame) {
118899:           nsIFrame* outOfFlow = nsPlaceholderFrame::GetRealFrameForPlaceholder(f);
118899:           // If SVG text frames could appear here, they could confuse us since
118899:           // they ignore their position style ... but they can't.
118899:           NS_ASSERTION(!outOfFlow->IsSVGText(),
118899:                        "SVG text frames can't be out of flow");
132812:           if (aPositionMask & (1 << outOfFlow->StyleDisplay()->mPosition)) {
108182:             return true;
108182:           }
108182:         }
118899:         if (FrameHasPositionedPlaceholderDescendants(f, aPositionMask)) {
118899:           return true;
118899:         }
118899:       }
108182:     }
108182:   }
108182:   return false;
108182: }
108182: 
118899: static bool
118899: NeedToReframeForAddingOrRemovingTransform(nsIFrame* aFrame)
118899: {
118899:   MOZ_STATIC_ASSERT(0 <= NS_STYLE_POSITION_ABSOLUTE &&
118899:                     NS_STYLE_POSITION_ABSOLUTE < 32, "Style constant out of range");
118899:   MOZ_STATIC_ASSERT(0 <= NS_STYLE_POSITION_FIXED &&
118899:                     NS_STYLE_POSITION_FIXED < 32, "Style constant out of range");
118899: 
118899:   uint32_t positionMask;
118899:   // Don't call aFrame->IsPositioned here, since that returns true if
118899:   // the frame already has a transform, and we want to ignore that here
118899:   if (aFrame->IsAbsolutelyPositioned() ||
118899:       aFrame->IsRelativelyPositioned()) {
118899:     // This frame is a container for abs-pos descendants whether or not it
118899:     // has a transform.
118899:     // So abs-pos descendants are no problem; we only need to reframe if
118899:     // we have fixed-pos descendants.
118899:     positionMask = 1 << NS_STYLE_POSITION_FIXED;
118899:   } else {
118899:     // This frame may not be a container for abs-pos descendants already.
118899:     // So reframe if we have abs-pos or fixed-pos descendants.
118899:     positionMask = (1 << NS_STYLE_POSITION_FIXED) |
118899:         (1 << NS_STYLE_POSITION_ABSOLUTE);
118899:   }
123554:   for (nsIFrame* f = aFrame; f;
123554:        f = nsLayoutUtils::GetNextContinuationOrSpecialSibling(f)) {
123554:     if (FrameHasPositionedPlaceholderDescendants(f, positionMask)) {
123554:       return true;
123554:     }
123554:   }
123554:   return false;
118899: }
118899: 
     1: nsresult
133599: nsCSSFrameConstructor::ProcessRestyledFrames(nsStyleChangeList& aChangeList)
     1: {
 23652:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
 23652:                "Someone forgot a script blocker");
108991:   int32_t count = aChangeList.Count();
     1:   if (!count)
     1:     return NS_OK;
     1: 
113744:   SAMPLE_LABEL("CSS", "ProcessRestyledFrames");
113744: 
  6467:   // Make sure to not rebuild quote or counter lists while we're
  6467:   // processing restyles
  6467:   BeginUpdate();
  6467: 
 30522:   nsPresContext* presContext = mPresShell->GetPresContext();
 39965:   FramePropertyTable* propTable = presContext->PropertyTable();
     1: 
     1:   // Mark frames so that we skip frames that die along the way, bug 123049.
     1:   // A frame can be in the list multiple times with different hints. Further
     1:   // optmization is possible if nsStyleChangeList::AppendChange could coalesce
108991:   int32_t index = count;
     1: 
     1:   while (0 <= --index) {
     1:     const nsStyleChangeData* changeData;
     1:     aChangeList.ChangeAt(index, &changeData);
     1:     if (changeData->mFrame) {
 39965:       propTable->Set(changeData->mFrame, ChangeListProperty(),
 39965:                      NS_INT32_TO_PTR(1));
     1:     }
     1:   }
     1: 
     1:   index = count;
 30522: 
     1:   while (0 <= --index) {
     1:     nsIFrame* frame;
     1:     nsIContent* content;
101252:     bool didReflowThisFrame = false;
     1:     nsChangeHint hint;
     1:     aChangeList.ChangeAt(index, frame, content, hint);
 31101: 
111494:     NS_ASSERTION(!(hint & nsChangeHint_AllReflowHints) ||
 31101:                  (hint & nsChangeHint_NeedReflow),
 31101:                  "Reflow hint bits set without actually asking for a reflow");
 31101: 
126990:     // skip any frame that has been destroyed due to a ripple effect
126990:     if (frame && !propTable->Get(frame, ChangeListProperty())) {
126990:       continue;
126990:     }
126990: 
 21936:     if (frame && frame->GetContent() != content) {
 36653:       // XXXbz this is due to image maps messing with the primary frame of
 36653:       // <area>s.  See bug 135040.  Remove this block once that's fixed.
106838:       frame = nullptr;
 21936:       if (!(hint & nsChangeHint_ReconstructFrame)) {
 21936:         continue;
 21936:       }
 21936:     }
     1: 
108182:     if ((hint & nsChangeHint_AddOrRemoveTransform) && frame &&
108182:         !(hint & nsChangeHint_ReconstructFrame)) {
118899:       if (NeedToReframeForAddingOrRemovingTransform(frame)) {
108182:         NS_UpdateHint(hint, nsChangeHint_ReconstructFrame);
108182:       } else {
120164:         // Normally frame construction would set state bits as needed,
120164:         // but we're not going to reconstruct the frame so we need to set them.
120164:         // It's because we need to set this state on each affected frame
108182:         // that we can't coalesce nsChangeHint_AddOrRemoveTransform hints up
108182:         // to ancestors (i.e. it can't be an inherited change hint).
120164:         if (frame->IsPositioned()) {
120164:           // If a transform has been added, we'll be taking this path,
120164:           // but we may be taking this path even if a transform has been
120164:           // removed. It's OK to add the bit even if it's not needed.
108182:           frame->AddStateBits(NS_FRAME_MAY_BE_TRANSFORMED);
120781:           if (!frame->IsAbsoluteContainer() &&
120781:               (frame->GetStateBits() & NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN)) {
120164:             frame->MarkAsAbsoluteContainingBlock();
120164:           }
120164:         } else {
120164:           // Don't remove NS_FRAME_MAY_BE_TRANSFORMED since it may still by
120164:           // transformed by other means. It's OK to have the bit even if it's
120164:           // not needed.
120164:           if (frame->IsAbsoluteContainer()) {
120164:             frame->MarkAsNotAbsoluteContainingBlock();
120164:           }
120164:         }
108182:       }
108182:     }
     1:     if (hint & nsChangeHint_ReconstructFrame) {
 80486:       // If we ever start passing true here, be careful of restyles
 78544:       // that involve a reframe and animations.  In particular, if the
 78544:       // restyle we're processing here is an animation restyle, but
 78544:       // the style resolution we will do for the frame construction
 78544:       // happens async when we're not in an animation restyle already,
 78544:       // problems could arise.
 80486:       RecreateFramesForContent(content, false);
     1:     } else {
121082:       NS_ASSERTION(frame, "This shouldn't happen");
121082: 
120169:       if ((frame->GetStateBits() & NS_FRAME_SVG_LAYOUT) &&
120169:           (frame->GetStateBits() & NS_STATE_SVG_NONDISPLAY_CHILD)) {
120169:         // frame does not maintain overflow rects, so avoid calling
120169:         // FinishAndStoreOverflow on it:
120169:         hint = NS_SubtractHint(hint,
120169:                  NS_CombineHint(nsChangeHint_UpdateOverflow,
120169:                                 nsChangeHint_ChildrenOnlyTransform));
120169:       }
120169: 
 16411:       if (hint & nsChangeHint_UpdateEffects) {
 19948:         nsSVGEffects::UpdateEffects(frame);
 16411:       }
 31101:       if (hint & nsChangeHint_NeedReflow) {
 31101:         StyleChangeReflow(frame, hint);
101252:         didReflowThisFrame = true;
     1:       }
 47740:       if (hint & (nsChangeHint_RepaintFrame | nsChangeHint_SyncFrameView |
105956:                   nsChangeHint_UpdateOpacityLayer | nsChangeHint_UpdateTransformLayer |
105956:                   nsChangeHint_ChildrenOnlyTransform)) {
 30522:         ApplyRenderingChangeToTree(presContext, frame, hint);
     1:       }
101252:       if ((hint & nsChangeHint_RecomputePosition) && !didReflowThisFrame) {
101252:         // It is possible for this to fall back to a reflow
101252:         if (!RecomputePosition(frame)) {
101252:           didReflowThisFrame = true;
101252:         }
101252:       }
 98711:       NS_ASSERTION(!(hint & nsChangeHint_ChildrenOnlyTransform) ||
 98711:                    (hint & nsChangeHint_UpdateOverflow),
 98711:                    "nsChangeHint_UpdateOverflow should be passed too");
101252:       if ((hint & nsChangeHint_UpdateOverflow) && !didReflowThisFrame) {
 98711:         if (hint & nsChangeHint_ChildrenOnlyTransform) {
126160:           // The overflow areas of the child frames need to be updated:
126160:           nsIFrame* hintFrame = GetFrameForChildrenOnlyTransformHint(frame);
126160:           nsIFrame* childFrame = hintFrame->GetFirstPrincipalChild();
 98711:           for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
 98711:             NS_ABORT_IF_FALSE(childFrame->IsFrameOfType(nsIFrame::eSVG),
 98711:                               "Not expecting non-SVG children");
126160:             // If |childFrame| is dirty or has dirty children, we don't bother
126160:             // updating overflows since that will happen when it's reflowed.
120515:             if (!(childFrame->GetStateBits() &
120515:                   (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN))) {
133599:               mOverflowChangedTracker.AddFrame(childFrame);
120515:             }
 98711:             NS_ASSERTION(!nsLayoutUtils::GetNextContinuationOrSpecialSibling(childFrame),
 98711:                          "SVG frames should not have continuations or special siblings");
126160:             NS_ASSERTION(childFrame->GetParent() == hintFrame,
 98711:                          "SVG child frame not expected to have different parent");
 98711:           }
 98711:         }
120515:         // If |frame| is dirty or has dirty children, we don't bother updating
120515:         // overflows since that will happen when it's reflowed.
120515:         if (!(frame->GetStateBits() &
120515:               (NS_FRAME_IS_DIRTY | NS_FRAME_HAS_DIRTY_CHILDREN))) {
 87627:           while (frame) {
133599:             mOverflowChangedTracker.AddFrame(frame);
125314: 
125314:             frame =
 87627:               nsLayoutUtils::GetNextContinuationOrSpecialSibling(frame);
 87627:           }
 87627:         }
120515:       }
     1:       if (hint & nsChangeHint_UpdateCursor) {
 80486:         mPresShell->SynthesizeMouseMove(false);
     1:       }
     1:     }
     1:   }
     1: 
  6467:   EndUpdate();
  6467: 
  6739:   // cleanup references and verify the style tree.  Note that the latter needs
  6739:   // to happen once we've processed the whole list, since until then the tree
  6739:   // is not in fact in a consistent state.
     1:   index = count;
     1:   while (0 <= --index) {
     1:     const nsStyleChangeData* changeData;
     1:     aChangeList.ChangeAt(index, &changeData);
     1:     if (changeData->mFrame) {
 39965:       propTable->Delete(changeData->mFrame, ChangeListProperty());
     1:     }
  6739: 
  6739: #ifdef DEBUG
  6739:     // reget frame from content since it may have been regenerated...
  6739:     if (changeData->mContent) {
125555:       if (!nsAnimationManager::ContentOrAncestorHasAnimation(changeData->mContent) &&
125555:           !nsTransitionManager::ContentOrAncestorHasTransition(changeData->mContent)) {
 36656:         nsIFrame* frame = changeData->mContent->GetPrimaryFrame();
  6739:         if (frame) {
 89328:           DebugVerifyStyleTree(frame);
  6739:         }
125555:       }
  6739:     } else {
  6739:       NS_WARNING("Unable to test style tree integrity -- no content node");
  6739:     }
  6739: #endif
     1:   }
     1: 
     1:   aChangeList.Clear();
     1:   return NS_OK;
     1: }
     1: 
     1: void
 42329: nsCSSFrameConstructor::RestyleElement(Element        *aElement,
     1:                                       nsIFrame       *aPrimaryFrame,
 43790:                                       nsChangeHint   aMinHint,
 43794:                                       RestyleTracker& aRestyleTracker,
133599:                                       bool            aRestyleDescendants)
     1: {
 42329:   NS_ASSERTION(aPrimaryFrame == aElement->GetPrimaryFrame(),
 11409:                "frame/content mismatch");
 42329:   if (aPrimaryFrame && aPrimaryFrame->GetContent() != aElement) {
 36653:     // XXXbz this is due to image maps messing with the primary frame pointer
 36653:     // of <area>s.  See bug 135040.  We can remove this block once that's fixed.
106838:     aPrimaryFrame = nullptr;
 21936:   }
 42329:   NS_ASSERTION(!aPrimaryFrame || aPrimaryFrame->GetContent() == aElement,
 11409:                "frame/content mismatch");
 11409: 
120184:   // If we're restyling the root element and there are 'rem' units in
120184:   // use, handle dynamic changes to the definition of a 'rem' here.
120184:   if (GetPresContext()->UsesRootEMUnits() && aPrimaryFrame) {
132768:     nsStyleContext *oldContext = aPrimaryFrame->StyleContext();
120184:     if (!oldContext->GetParent()) { // check that we're the root element
120184:       nsRefPtr<nsStyleContext> newContext = mPresShell->StyleSet()->
120184:         ResolveStyleFor(aElement, nullptr /* == oldContext->GetParent() */);
132812:       if (oldContext->StyleFont()->mFont.size !=
132812:           newContext->StyleFont()->mFont.size) {
120184:         // The basis for 'rem' units has changed.
132244:         newContext = nullptr;
120184:         DoRebuildAllStyleData(aRestyleTracker, nsChangeHint(0));
120184:         if (aMinHint == 0) {
120184:           return;
120184:         }
120184:         aPrimaryFrame = aElement->GetPrimaryFrame();
120184:       }
120184:     }
120184:   }
120184: 
     1:   if (aMinHint & nsChangeHint_ReconstructFrame) {
 80486:     RecreateFramesForContent(aElement, false);
     1:   } else if (aPrimaryFrame) {
     1:     nsStyleChangeList changeList;
 43790:     ComputeStyleChangeFor(aPrimaryFrame, &changeList, aMinHint,
 43794:                           aRestyleTracker, aRestyleDescendants);
133599:     ProcessRestyledFrames(changeList);
     1:   } else {
     1:     // no frames, reconstruct for content
 42329:     MaybeRecreateFramesForElement(aElement);
     1:   }
     1: }
     1: 
     1: nsresult
 64120: nsCSSFrameConstructor::ContentStateChanged(nsIContent* aContent,
 56168:                                            nsEventStates aStateMask)
     1: {
 42323:   // XXXbz it would be good if this function only took Elements, but
 42323:   // we'd have to make ESM guarantee that usefully.
 64120:   if (!aContent->IsElement()) {
 64120:     return NS_OK;
 64120:   }
 64120: 
 64120:   Element* aElement = aContent->AsElement();
 64120: 
     1:   nsStyleSet *styleSet = mPresShell->StyleSet();
     1:   nsPresContext *presContext = mPresShell->GetPresContext();
     1:   NS_ASSERTION(styleSet, "couldn't get style set");
     1: 
     1:   nsChangeHint hint = NS_STYLE_HINT_NONE;
     1:   // Any change to a content state that affects which frames we construct
     1:   // must lead to a frame reconstruct here if we already have a frame.
     1:   // Note that we never decide through non-CSS means to not create frames
     1:   // based on content states, so if we already don't have a frame we don't
     1:   // need to force a reframe -- if it's needed, the HasStateDependentStyle
     1:   // call will handle things.
 42323:   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
     1:   if (primaryFrame) {
     1:     // If it's generated content, ignore LOADING/etc state changes on it.
     1:     if (!primaryFrame->IsGeneratedContentFrame() &&
 56168:         aStateMask.HasAtLeastOneOfStates(NS_EVENT_STATE_BROKEN |
 56168:                                          NS_EVENT_STATE_USERDISABLED |
 56168:                                          NS_EVENT_STATE_SUPPRESSED |
 56168:                                          NS_EVENT_STATE_LOADING)) {
     1:       hint = nsChangeHint_ReconstructFrame;
     1:     } else {
132812:       uint8_t app = primaryFrame->StyleDisplay()->mAppearance;
     1:       if (app) {
     1:         nsITheme *theme = presContext->GetTheme();
     1:         if (theme && theme->ThemeSupportsWidget(presContext,
     1:                                                 primaryFrame, app)) {
 79445:           bool repaint = false;
106838:           theme->WidgetStateChanged(primaryFrame, app, nullptr, &repaint);
     1:           if (repaint) {
     1:             NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
     1:           }
     1:         }
     1:       }
     1:     }
 59447: 
 59447:     primaryFrame->ContentStatesChanged(aStateMask);
     1:   }
     1: 
 99664: 
 99664:   nsRestyleHint rshint = 
 42323:     styleSet->HasStateDependentStyle(presContext, aElement, aStateMask);
     1:       
 56168:   if (aStateMask.HasState(NS_EVENT_STATE_HOVER) && rshint != 0) {
 22471:     ++mHoverGeneration;
 22471:   }
 22471: 
 56168:   if (aStateMask.HasState(NS_EVENT_STATE_VISITED)) {
 40172:     // Exposing information to the page about whether the link is
 40172:     // visited or not isn't really something we can worry about here.
 40172:     // FIXME: We could probably do this a bit better.
 40172:     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
 40172:   }
 40172: 
 42323:   PostRestyleEvent(aElement, rshint, hint);
 64120:   return NS_OK;
     1: }
     1: 
 35534: void
 51352: nsCSSFrameConstructor::AttributeWillChange(Element* aElement,
108991:                                            int32_t aNameSpaceID,
 35534:                                            nsIAtom* aAttribute,
108991:                                            int32_t aModType)
 35534: {
 40075:   nsRestyleHint rshint =
 42321:     mPresShell->StyleSet()->HasAttributeDependentStyle(mPresShell->GetPresContext(),
 42323:                                                        aElement,
 35534:                                                        aAttribute,
 35534:                                                        aModType,
 80486:                                                        false);
 42323:   PostRestyleEvent(aElement, rshint, NS_STYLE_HINT_NONE);
 35534: }
 35534: 
 35534: void
 51350: nsCSSFrameConstructor::AttributeChanged(Element* aElement,
108991:                                         int32_t aNameSpaceID,
     1:                                         nsIAtom* aAttribute,
108991:                                         int32_t aModType)
     1: {
     1:   // Hold onto the PresShell to prevent ourselves from being destroyed.
     1:   // XXXbz how, exactly, would this attribute change cause us to be
     1:   // destroyed from inside this function?
     1:   nsCOMPtr<nsIPresShell> shell = mPresShell;
     1: 
     1:   // Get the frame associated with the content which is the highest in the frame tree
 42323:   nsIFrame* primaryFrame = aElement->GetPrimaryFrame();
     1: 
     1: #if 0
     1:   NS_FRAME_LOG(NS_FRAME_TRACE_CALLS,
     1:      ("HTMLStyleSheet::AttributeChanged: content=%p[%s] frame=%p",
 42323:       aContent, ContentTag(aElement, 0), frame));
     1: #endif
     1: 
     1:   // the style tag has its own interpretation based on aHint 
 42323:   nsChangeHint hint = aElement->GetAttributeChangeHint(aAttribute, aModType);
     1: 
 79445:   bool reframe = (hint & nsChangeHint_ReconstructFrame) != 0;
     1: 
     1: #ifdef MOZ_XUL
     1:   // The following listbox widget trap prevents offscreen listbox widget
     1:   // content from being removed and re-inserted (which is what would
     1:   // happen otherwise).
     1:   if (!primaryFrame && !reframe) {
108991:     int32_t namespaceID;
     1:     nsIAtom* tag =
 42323:       mDocument->BindingManager()->ResolveTag(aElement, &namespaceID);
     1: 
     1:     if (namespaceID == kNameSpaceID_XUL &&
     1:         (tag == nsGkAtoms::listitem ||
     1:          tag == nsGkAtoms::listcell))
 35534:       return;
     1:   }
     1: 
     1:   if (aAttribute == nsGkAtoms::tooltiptext ||
     1:       aAttribute == nsGkAtoms::tooltip) 
     1:   {
     1:     nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
     1:     if (rootBox) {
     1:       if (aModType == nsIDOMMutationEvent::REMOVAL)
 42323:         rootBox->RemoveTooltipSupport(aElement);
     1:       if (aModType == nsIDOMMutationEvent::ADDITION)
 42323:         rootBox->AddTooltipSupport(aElement);
     1:     }
     1:   }
     1: 
     1: #endif // MOZ_XUL
     1: 
     1:   if (primaryFrame) {
     1:     // See if we have appearance information for a theme.
132812:     const nsStyleDisplay* disp = primaryFrame->StyleDisplay();
     1:     if (disp->mAppearance) {
     1:       nsPresContext* presContext = mPresShell->GetPresContext();
     1:       nsITheme *theme = presContext->GetTheme();
  4036:       if (theme && theme->ThemeSupportsWidget(presContext, primaryFrame, disp->mAppearance)) {
 79445:         bool repaint = false;
  4036:         theme->WidgetStateChanged(primaryFrame, disp->mAppearance, aAttribute, &repaint);
     1:         if (repaint)
     1:           NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
     1:       }
     1:     }
     1:    
     1:     // let the frame deal with it now, so we don't have to deal later
 35534:     primaryFrame->AttributeChanged(aNameSpaceID, aAttribute, aModType);
     1:     // XXXwaterson should probably check for special IB siblings
     1:     // here, and propagate the AttributeChanged notification to
     1:     // them, as well. Currently, inline frames don't do anything on
     1:     // this notification, so it's not that big a deal.
     1:   }
     1: 
     1:   // See if we can optimize away the style re-resolution -- must be called after
     1:   // the frame's AttributeChanged() in case it does something that affects the style
 42321:   nsRestyleHint rshint =
 42321:     mPresShell->StyleSet()->HasAttributeDependentStyle(mPresShell->GetPresContext(),
 42323:                                                        aElement,
     1:                                                        aAttribute,
  3410:                                                        aModType,
 80486:                                                        true);
     1: 
 42323:   PostRestyleEvent(aElement, rshint, hint);
     1: }
     1: 
     1: void
 11855: nsCSSFrameConstructor::BeginUpdate() {
 29072:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
 29072:                "Someone forgot a script blocker");
 29072: 
 54261:   nsRootPresContext* rootPresContext =
 54261:     mPresShell->GetPresContext()->GetRootPresContext();
 54261:   if (rootPresContext) {
 54261:     rootPresContext->IncrementDOMGeneration();
 54261:   }
 54261: 
103882:   ++sGlobalGenerationNumber;
 11855:   ++mUpdateCount;
 11855: }
 11855: 
 11855: void
     1: nsCSSFrameConstructor::EndUpdate()
     1: {
     1:   if (mUpdateCount == 1) {
     1:     // This is the end of our last update.  Before we decrement
     1:     // mUpdateCount, recalc quotes and counters as needed.
     1: 
   550:     RecalcQuotesAndCounters();
   550:     NS_ASSERTION(mUpdateCount == 1, "Odd update count");
   550:   }
 69575:   NS_ASSERTION(mUpdateCount, "Negative mUpdateCount!");
 22957:   --mUpdateCount;
   550: }
   550: 
   550: void
   550: nsCSSFrameConstructor::RecalcQuotesAndCounters()
   550: {
     1:   if (mQuotesDirty) {
 80486:     mQuotesDirty = false;
     1:     mQuoteList.RecalcAll();
     1:   }
     1: 
     1:   if (mCountersDirty) {
 80486:     mCountersDirty = false;
     1:     mCounterManager.RecalcAll();
     1:   }
     1: 
     1:   NS_ASSERTION(!mQuotesDirty, "Quotes updates will be lost");
     1:   NS_ASSERTION(!mCountersDirty, "Counter updates will be lost");  
     1: }
     1: 
     1: void
 26803: nsCSSFrameConstructor::WillDestroyFrameTree()
     1: {
     1: #if defined(DEBUG_dbaron_off)
     1:   mCounterManager.Dump();
     1: #endif
     1: 
 80486:   mIsDestroyingFrameTree = true;
     1: 
     1:   // Prevent frame tree destruction from being O(N^2)
     1:   mQuoteList.Clear();
     1:   mCounterManager.Clear();
     1: 
 50365:   // Remove our presshell as a style flush observer.  But leave
 50365:   // mObservingRefreshDriver true so we don't readd to it even if someone tries
 50365:   // to post restyle events on us from this point on for some reason.
 36797:   mPresShell->GetPresContext()->RefreshDriver()->
 50365:     RemoveStyleFlushObserver(mPresShell);
 89328: 
 89328:   nsFrameManager::Destroy();
     1: }
     1: 
     1: //STATIC
     1: 
     1: // XXXbz I'd really like this method to go away. Once we have inline-block and
     1: // I can just use that for sized broken images, that can happen, maybe.
     1: void nsCSSFrameConstructor::GetAlternateTextFor(nsIContent*    aContent,
     1:                                                 nsIAtom*       aTag,  // content object's tag
     1:                                                 nsXPIDLString& aAltText)
     1: {
     1:   // The "alt" attribute specifies alternate text that is rendered
     1:   // when the image can not be displayed
     1: 
     1:   // If there's no "alt" attribute, and aContent is an input    
     1:   // element, then use the value of the "value" attribute
     1:   if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::alt, aAltText) &&
     1:       nsGkAtoms::input == aTag) {
     1:     // If there's no "value" attribute either, then use the localized string 
     1:     // for "Submit" as the alternate text.
     1:     if (!aContent->GetAttr(kNameSpaceID_None, nsGkAtoms::value, aAltText)) {
     1:       nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
     1:                                          "Submit", aAltText);      
     1:     }
     1:   }
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::CreateContinuingOuterTableFrame(nsIPresShell*    aPresShell,
     1:                                                        nsPresContext*  aPresContext,
     1:                                                        nsIFrame*        aFrame,
     1:                                                        nsIFrame*        aParentFrame,
     1:                                                        nsIContent*      aContent,
     1:                                                        nsStyleContext*  aStyleContext,
     1:                                                        nsIFrame**       aContinuingFrame)
     1: {
     1:   nsIFrame* newFrame = NS_NewTableOuterFrame(aPresShell, aStyleContext);
     1: 
     1:   newFrame->Init(aContent, aParentFrame, aFrame);
     1: 
     1:   // Create a continuing inner table frame, and if there's a caption then
     1:   // replicate the caption
     1:   nsFrameItems  newChildFrames;
     1: 
 77154:   nsIFrame* childFrame = aFrame->GetFirstPrincipalChild();
     1:   if (childFrame) {
     1:     nsIFrame* continuingTableFrame;
     1:     nsresult rv = CreateContinuingFrame(aPresContext, childFrame, newFrame,
     1:                                         &continuingTableFrame);
     1:     if (NS_FAILED(rv)) {
     1:       newFrame->Destroy();
106838:       *aContinuingFrame = nullptr;
     1:       return rv;
     1:     }
     1:     newChildFrames.AddChild(continuingTableFrame);
     1: 
     1:     NS_ASSERTION(!childFrame->GetNextSibling(),"there can be only one inner table frame");
     1:   }
     1: 
     1:   // Set the outer table's initial child list
 77155:   newFrame->SetInitialChildList(kPrincipalList, newChildFrames);
     1: 
     1:   *aContinuingFrame = newFrame;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::CreateContinuingTableFrame(nsIPresShell* aPresShell, 
     1:                                                   nsPresContext*  aPresContext,
     1:                                                   nsIFrame*        aFrame,
     1:                                                   nsIFrame*        aParentFrame,
     1:                                                   nsIContent*      aContent,
     1:                                                   nsStyleContext*  aStyleContext,
     1:                                                   nsIFrame**       aContinuingFrame)
     1: {
     1:   nsIFrame* newFrame = NS_NewTableFrame(aPresShell, aStyleContext);
     1: 
     1:   newFrame->Init(aContent, aParentFrame, aFrame);
     1: 
     1:   // Replicate any header/footer frames
     1:   nsFrameItems  childFrames;
 77154:   nsIFrame* childFrame = aFrame->GetFirstPrincipalChild();
     1:   for ( ; childFrame; childFrame = childFrame->GetNextSibling()) {
     1:     // See if it's a header/footer, possibly wrapped in a scroll frame.
     1:     nsTableRowGroupFrame* rowGroupFrame =
 37262:       static_cast<nsTableRowGroupFrame*>(childFrame);
     1:     // If the row group was continued, then don't replicate it.
     1:     nsIFrame* rgNextInFlow = rowGroupFrame->GetNextInFlow();
     1:     if (rgNextInFlow) {
 80486:       rowGroupFrame->SetRepeatable(false);
     1:     }
     1:     else if (rowGroupFrame->IsRepeatable()) {
     1:       // Replicate the header/footer frame.
     1:       nsTableRowGroupFrame*   headerFooterFrame;
     1:       nsFrameItems            childItems;
130516:       nsFrameConstructorState state(mPresShell,
130516:                                     GetAbsoluteContainingBlock(newFrame, FIXED_POS),
130516:                                     GetAbsoluteContainingBlock(newFrame, ABS_POS),
106838:                                     nullptr);
 80486:       state.mCreatingExtraFrames = true;
     1: 
  3233:       headerFooterFrame = static_cast<nsTableRowGroupFrame*>
132768:                                      (NS_NewTableRowGroupFrame(aPresShell, rowGroupFrame->StyleContext()));
     1:       nsIContent* headerFooter = rowGroupFrame->GetContent();
106838:       headerFooterFrame->Init(headerFooter, newFrame, nullptr);
132768:       ProcessChildren(state, headerFooter, rowGroupFrame->StyleContext(),
 80486:                       headerFooterFrame, true, childItems, false,
106838:                       nullptr);
 30785:       NS_ASSERTION(state.mFloatedItems.IsEmpty(), "unexpected floated element");
 77155:       headerFooterFrame->SetInitialChildList(kPrincipalList, childItems);
 80486:       headerFooterFrame->SetRepeatable(true);
     1: 
     1:       // Table specific initialization
     1:       headerFooterFrame->InitRepeatedFrame(aPresContext, rowGroupFrame);
     1: 
     1:       // XXX Deal with absolute and fixed frames...
     1:       childFrames.AddChild(headerFooterFrame);
     1:     }
     1:   }
     1: 
     1:   // Set the table frame's initial child list
 77155:   newFrame->SetInitialChildList(kPrincipalList, childFrames);
     1: 
     1:   *aContinuingFrame = newFrame;
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::CreateContinuingFrame(nsPresContext* aPresContext,
     1:                                              nsIFrame*       aFrame,
     1:                                              nsIFrame*       aParentFrame,
     1:                                              nsIFrame**      aContinuingFrame,
 79445:                                              bool            aIsFluid)
     1: {
     1:   nsIPresShell*              shell = aPresContext->PresShell();
132768:   nsStyleContext*            styleContext = aFrame->StyleContext();
106838:   nsIFrame*                  newFrame = nullptr;
     1:   nsresult                   rv = NS_OK;
     1:   nsIFrame*                  nextContinuation = aFrame->GetNextContinuation();
     1:   nsIFrame*                  nextInFlow = aFrame->GetNextInFlow();
     1: 
     1:   // Use the frame type to determine what type of frame to create
     1:   nsIAtom* frameType = aFrame->GetType();
     1:   nsIContent* content = aFrame->GetContent();
     1: 
     1:   NS_ASSERTION(aFrame->GetSplittableType() != NS_FRAME_NOT_SPLITTABLE,
     1:                "why CreateContinuingFrame for a non-splittable frame?");
     1:   
     1:   if (nsGkAtoms::textFrame == frameType) {
     1:     newFrame = NS_NewContinuingTextFrame(shell, styleContext);
     1:     newFrame->Init(content, aParentFrame, aFrame);
     1:   } else if (nsGkAtoms::inlineFrame == frameType) {
     1:     newFrame = NS_NewInlineFrame(shell, styleContext);
     1:     newFrame->Init(content, aParentFrame, aFrame);
     1:   } else if (nsGkAtoms::blockFrame == frameType) {
     1:     newFrame = NS_NewBlockFrame(shell, styleContext);
     1:     newFrame->Init(content, aParentFrame, aFrame);
 23176: #ifdef MOZ_XUL
 23176:   } else if (nsGkAtoms::XULLabelFrame == frameType) {
 23947:     newFrame = NS_NewXULLabelFrame(shell, styleContext);
     1:     newFrame->Init(content, aParentFrame, aFrame);
 23176: #endif  
     1:   } else if (nsGkAtoms::columnSetFrame == frameType) {
     1:     newFrame = NS_NewColumnSetFrame(shell, styleContext, 0);
     1:     newFrame->Init(content, aParentFrame, aFrame);
     1:   } else if (nsGkAtoms::pageFrame == frameType) {
 18953:     nsIFrame* canvasFrame;
     1:     rv = ConstructPageFrame(shell, aPresContext, aParentFrame, aFrame,
 18953:                             newFrame, canvasFrame);
     1:   } else if (nsGkAtoms::tableOuterFrame == frameType) {
     1:     rv = CreateContinuingOuterTableFrame(shell, aPresContext, aFrame, aParentFrame,
     1:                                          content, styleContext, &newFrame);
     1: 
     1:   } else if (nsGkAtoms::tableFrame == frameType) {
     1:     rv = CreateContinuingTableFrame(shell, aPresContext, aFrame, aParentFrame,
     1:                                     content, styleContext, &newFrame);
     1: 
     1:   } else if (nsGkAtoms::tableRowGroupFrame == frameType) {
     1:     newFrame = NS_NewTableRowGroupFrame(shell, styleContext);
     1:     newFrame->Init(content, aParentFrame, aFrame);
     1:   } else if (nsGkAtoms::tableRowFrame == frameType) {
     1:     newFrame = NS_NewTableRowFrame(shell, styleContext);
     1: 
     1:     newFrame->Init(content, aParentFrame, aFrame);
     1: 
     1:     // Create a continuing frame for each table cell frame
     1:     nsFrameItems  newChildList;
 77154:     nsIFrame* cellFrame = aFrame->GetFirstPrincipalChild();
     1:     while (cellFrame) {
     1:       // See if it's a table cell frame
     1:       if (IS_TABLE_CELL(cellFrame->GetType())) {
     1:         nsIFrame* continuingCellFrame;
     1:         rv = CreateContinuingFrame(aPresContext, cellFrame, newFrame,
     1:                                    &continuingCellFrame);
     1:         if (NS_FAILED(rv)) {
 30785:           newChildList.DestroyFrames();
     1:           newFrame->Destroy();
106838:           *aContinuingFrame = nullptr;
     1:           return NS_ERROR_OUT_OF_MEMORY;
     1:         }
     1:         newChildList.AddChild(continuingCellFrame);
     1:       }
     1:       cellFrame = cellFrame->GetNextSibling();
     1:     }
     1: 
     1:     // Set the table cell's initial child list
 77155:     newFrame->SetInitialChildList(kPrincipalList, newChildList);
     1: 
     1:   } else if (IS_TABLE_CELL(frameType)) {
  8578:     // Warning: If you change this and add a wrapper frame around table cell
  8578:     // frames, make sure Bug 368554 doesn't regress!
  8578:     // See IsInAutoWidthTableCellForQuirk() in nsImageFrame.cpp.
     1:     newFrame = NS_NewTableCellFrame(shell, styleContext, IsBorderCollapse(aParentFrame));
     1: 
     1:     newFrame->Init(content, aParentFrame, aFrame);
     1: 
     1:     // Create a continuing area frame
 23296:     nsIFrame* continuingBlockFrame;
 77154:     nsIFrame* blockFrame = aFrame->GetFirstPrincipalChild();
 23176:     rv = CreateContinuingFrame(aPresContext, blockFrame, newFrame,
 23296:                                &continuingBlockFrame);
     1:     if (NS_FAILED(rv)) {
     1:       newFrame->Destroy();
106838:       *aContinuingFrame = nullptr;
     1:       return rv;
     1:     }
     1: 
     1:     // Set the table cell's initial child list
 30790:     SetInitialSingleChild(newFrame, continuingBlockFrame);
     1:   } else if (nsGkAtoms::lineFrame == frameType) {
     1:     newFrame = NS_NewFirstLineFrame(shell, styleContext);
     1:     newFrame->Init(content, aParentFrame, aFrame);
     1:   } else if (nsGkAtoms::letterFrame == frameType) {
     1:     newFrame = NS_NewFirstLetterFrame(shell, styleContext);
     1:     newFrame->Init(content, aParentFrame, aFrame);
     1:   } else if (nsGkAtoms::imageFrame == frameType) {
     1:     newFrame = NS_NewImageFrame(shell, styleContext);
     1:     newFrame->Init(content, aParentFrame, aFrame);
  9869:   } else if (nsGkAtoms::imageControlFrame == frameType) {
  9869:     newFrame = NS_NewImageControlFrame(shell, styleContext);
  9869:     newFrame->Init(content, aParentFrame, aFrame);
     1:   } else if (nsGkAtoms::placeholderFrame == frameType) {
     1:     // create a continuing out of flow frame
     1:     nsIFrame* oofFrame = nsPlaceholderFrame::GetRealFrameForPlaceholder(aFrame);
     1:     nsIFrame* oofContFrame;
     1:     rv = CreateContinuingFrame(aPresContext, oofFrame, aParentFrame, &oofContFrame);
     1:     if (NS_FAILED(rv)) {
106838:       *aContinuingFrame = nullptr;
     1:       return rv;
     1:     }
     1:     // create a continuing placeholder frame
  6219:     rv = CreatePlaceholderFrameFor(shell, content, oofContFrame, styleContext,
 34912:                                    aParentFrame, aFrame,
 34912:                                    aFrame->GetStateBits() & PLACEHOLDER_TYPE_MASK,
 34912:                                    &newFrame);
     1:     if (NS_FAILED(rv)) {
     1:       oofContFrame->Destroy();
106838:       *aContinuingFrame = nullptr;
     1:       return rv;
     1:     }
     1:   } else if (nsGkAtoms::fieldSetFrame == frameType) {
     1:     newFrame = NS_NewFieldSetFrame(shell, styleContext);
     1: 
     1:     newFrame->Init(content, aParentFrame, aFrame);
     1: 
     1:     // Create a continuing area frame
     1:     // XXXbz we really shouldn't have to do this by hand!
 23296:     nsIFrame* continuingBlockFrame;
 23176:     nsIFrame* blockFrame = GetFieldSetBlockFrame(aFrame);
 23176:     rv = CreateContinuingFrame(aPresContext, blockFrame, newFrame,
 23296:                                &continuingBlockFrame);
     1:     if (NS_FAILED(rv)) {
     1:       newFrame->Destroy();
106838:       *aContinuingFrame = nullptr;
     1:       return rv;
     1:     }
     1:     // Set the fieldset's initial child list
 30790:     SetInitialSingleChild(newFrame, continuingBlockFrame);
 24414:   } else if (nsGkAtoms::legendFrame == frameType) {
 24414:     newFrame = NS_NewLegendFrame(shell, styleContext);
 24414:     newFrame->Init(content, aParentFrame, aFrame);
     1:   } else {
     1:     NS_NOTREACHED("unexpected frame type");
106838:     *aContinuingFrame = nullptr;
     1:     return NS_ERROR_UNEXPECTED;
     1:   }
     1: 
     1:   *aContinuingFrame = newFrame;
     1: 
     1:   if (!newFrame) {
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1: 
     1:   // Init() set newFrame to be a fluid continuation of aFrame.
     1:   // If we want a non-fluid continuation, we need to call SetPrevContinuation()
     1:   // to reset NS_FRAME_IS_FLUID_CONTINUATION.
     1:   if (!aIsFluid) {
     1:     newFrame->SetPrevContinuation(aFrame);
     1:   }
     1: 
     1:   // A continuation of generated content is also generated content
     1:   if (aFrame->GetStateBits() & NS_FRAME_GENERATED_CONTENT) {
     1:     newFrame->AddStateBits(NS_FRAME_GENERATED_CONTENT);
     1:   }
     1: 
  6521:   // A continuation of an out-of-flow is also an out-of-flow
  6521:   if (aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) {
  6521:     newFrame->AddStateBits(NS_FRAME_OUT_OF_FLOW);
  6521:   }
  6521: 
     1:   if (nextInFlow) {
     1:     nextInFlow->SetPrevInFlow(newFrame);
     1:     newFrame->SetNextInFlow(nextInFlow);
     1:   } else if (nextContinuation) {
     1:     nextContinuation->SetPrevContinuation(newFrame);
     1:     newFrame->SetNextContinuation(nextContinuation);
     1:   }
 32841: 
 32841:   NS_POSTCONDITION(!newFrame->GetNextSibling(), "unexpected sibling");
     1:   return NS_OK;
     1: }
     1: 
  4347: nsresult
  4347: nsCSSFrameConstructor::ReplicateFixedFrames(nsPageContentFrame* aParentFrame)
  4347: {
 18953:   // Now deal with fixed-pos things....  They should appear on all pages,
 18953:   // so we want to move over the placeholders when processing the child
 18953:   // of the pageContentFrame.
  4347: 
  4347:   nsIFrame* prevPageContentFrame = aParentFrame->GetPrevInFlow();
     1:   if (!prevPageContentFrame) {
  4347:     return NS_OK;
  4347:   }
 77154:   nsIFrame* canvasFrame = aParentFrame->GetFirstPrincipalChild();
 77154:   nsIFrame* prevCanvasFrame = prevPageContentFrame->GetFirstPrincipalChild();
 18953:   if (!canvasFrame || !prevCanvasFrame) {
  4366:     // document's root element frame missing
     1:     return NS_ERROR_UNEXPECTED;
     1:   }
     1: 
     1:   nsFrameItems fixedPlaceholders;
 77154:   nsIFrame* firstFixed = prevPageContentFrame->GetFirstChild(nsIFrame::kFixedList);
     1:   if (!firstFixed) {
     1:     return NS_OK;
     1:   }
     1: 
  8933:   // Don't allow abs-pos descendants of the fixed content to escape the content.
  8933:   // This should not normally be possible (because fixed-pos elements should
  8933:   // be absolute containers) but fixed-pos tables currently aren't abs-pos
  8933:   // containers.
     1:   nsFrameConstructorState state(mPresShell, aParentFrame,
106838:                                 nullptr,
 24659:                                 mRootElementFrame);
 80486:   state.mCreatingExtraFrames = true;
     1: 
 92183:   // We can't use an ancestor filter here, because we're not going to
 92183:   // be usefully recurring down the tree.  This means that other
 92183:   // places in frame construction can't assume a filter is
 92183:   // initialized!
 92183: 
  4366:   // Iterate across fixed frames and replicate each whose placeholder is a
  4366:   // descendant of aFrame. (We don't want to explicitly copy placeholders that
  4366:   // are within fixed frames, because that would cause duplicates on the new
  4366:   // page - bug 389619)
     1:   for (nsIFrame* fixed = firstFixed; fixed; fixed = fixed->GetNextSibling()) {
 89328:     nsIFrame* prevPlaceholder = GetPlaceholderFrameFor(fixed);
  4366:     if (prevPlaceholder &&
 18953:         nsLayoutUtils::IsProperAncestorFrame(prevCanvasFrame, prevPlaceholder)) {
 60510:       // We want to use the same style as the primary style frame for
 60510:       // our content
 60510:       nsIContent* content = fixed->GetContent();
 60510:       nsStyleContext* styleContext =
 60510:         nsLayoutUtils::GetStyleFrame(content->GetPrimaryFrame())->
132768:           StyleContext();
 60510:       FrameConstructionItemList items;
 60510:       AddFrameConstructionItemsInternal(state, content, canvasFrame,
 60510:                                         content->Tag(),
 60510:                                         content->GetNameSpaceID(),
 80486:                                         true,
 60510:                                         styleContext,
 60510:                                         ITEM_ALLOW_XBL_BASE |
 60510:                                           ITEM_ALLOW_PAGE_BREAK,
 60510:                                         items);
 93524:       items.SetTriedConstructingFrames();
 60510:       for (FCItemIterator iter(items); !iter.IsDone(); iter.Next()) {
 60510:         NS_ASSERTION(iter.item().DesiredParentType() ==
 60510:                        GetParentType(canvasFrame),
 60510:                      "This is not going to work");
 60510:         nsresult rv =
 60510:           ConstructFramesFromItem(state, iter, canvasFrame, fixedPlaceholders);
  4347:         NS_ENSURE_SUCCESS(rv, rv);
     1:       }
  4366:     }
 60510:   }
     1: 
     1:   // Add the placeholders to our primary child list.
 18953:   // XXXbz this is a little screwed up, since the fixed frames will have 
 18953:   // broken auto-positioning. Oh, well.
 77154:   NS_ASSERTION(!canvasFrame->GetFirstPrincipalChild(),
  4347:                "leaking frames; doc root continuation must be empty");
 77155:   canvasFrame->SetInitialChildList(kPrincipalList, fixedPlaceholders);
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::GetInsertionPoint(nsIFrame*     aParentFrame,
     1:                                          nsIContent*   aChildContent,
     1:                                          nsIFrame**    aInsertionPoint,
 79445:                                          bool*       aMultiple)
     1: {
     1:   // Make the insertion point be the parent frame by default, in case
     1:   // we have to bail early.
     1:   *aInsertionPoint = aParentFrame;
     1: 
     1:   nsIContent* container = aParentFrame->GetContent();
     1:   if (!container)
     1:     return NS_OK;
     1: 
     1:   nsBindingManager *bindingManager = mDocument->BindingManager();
     1: 
     1:   nsIContent* insertionElement;
     1:   if (aChildContent) {
     1:     // We've got an explicit insertion child. Check to see if it's
     1:     // anonymous.
     1:     if (aChildContent->GetBindingParent() == container) {
     1:       // This child content is anonymous. Don't use the insertion
     1:       // point, since that's only for the explicit kids.
     1:       return NS_OK;
     1:     }
     1: 
108991:     uint32_t index;
     1:     insertionElement = bindingManager->GetInsertionPoint(container,
     1:                                                          aChildContent,
     1:                                                          &index);
     1:   }
     1:   else {
 79445:     bool multiple;
108991:     uint32_t index;
     1:     insertionElement = bindingManager->GetSingleInsertionPoint(container,
     1:                                                                &index,
     1:                                                                &multiple);
     1:     if (multiple && aMultiple)
     1:       *aMultiple = multiple; // Record the fact that filters are in use.
     1:   }
     1: 
     1:   if (insertionElement) {
 36656:     nsIFrame* insertionPoint = insertionElement->GetPrimaryFrame();
     1:     if (insertionPoint) {
     1:       // Use the content insertion frame of the insertion point.
     1:       insertionPoint = insertionPoint->GetContentInsertionFrame();
     1:       if (insertionPoint && insertionPoint != aParentFrame) 
     1:         GetInsertionPoint(insertionPoint, aChildContent, aInsertionPoint, aMultiple);
     1:     }
     1:     else {
     1:       // There was no frame created yet for the insertion point.
106838:       *aInsertionPoint = nullptr;
     1:     }
     1:   }
     1: 
     1:   // fieldsets have multiple insertion points.  Note that we might
     1:   // have to look at insertionElement here...
     1:   if (aMultiple && !*aMultiple) {
     1:     nsIContent* content = insertionElement ? insertionElement : container;
 63575:     if (content->IsHTML(nsGkAtoms::fieldset)) {
 80486:       *aMultiple = true;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: // Capture state for the frame tree rooted at the frame associated with the
     1: // content object, aContent
 98178: void
     1: nsCSSFrameConstructor::CaptureStateForFramesOf(nsIContent* aContent,
     1:                                                nsILayoutHistoryState* aHistoryState)
     1: {
 98178:   if (!aHistoryState) {
 98178:     return;
 98178:   }
 36656:   nsIFrame* frame = aContent->GetPrimaryFrame();
 28215:   if (frame == mRootElementFrame) {
 28215:     frame = mFixedContainingBlock;
 28215:   }
 98178:   for ( ; frame;
 98178:         frame = nsLayoutUtils::GetNextContinuationOrSpecialSibling(frame)) {
 98178:     CaptureFrameState(frame, aHistoryState);
 98178:   }
     1: }
     1: 
116370: static bool EqualURIs(mozilla::css::URLValue *aURI1,
116370:                       mozilla::css::URLValue *aURI2)
116370: {
116370:   return aURI1 == aURI2 ||    // handle null==null, and optimize
116370:          (aURI1 && aURI2 && aURI1->URIEquals(*aURI2));
116370: }
116370: 
     1: nsresult
 42329: nsCSSFrameConstructor::MaybeRecreateFramesForElement(Element* aElement)
     1: {
116370:   nsRefPtr<nsStyleContext> oldContext = GetUndisplayedContent(aElement);
116370:   if (!oldContext) {
116370:     return NS_OK;
116370:   }
116370: 
     1:   // The parent has a frame, so try resolving a new context.
     1:   nsRefPtr<nsStyleContext> newContext = mPresShell->StyleSet()->
 42329:     ResolveStyleFor(aElement, oldContext->GetParent());
 42329: 
 89328:   ChangeUndisplayedContent(aElement, newContext);
132812:   const nsStyleDisplay* disp = newContext->StyleDisplay();
116370:   if (disp->mDisplay == NS_STYLE_DISPLAY_NONE) {
116370:     // We can skip trying to recreate frames here, but only if our style
116370:     // context does not have a binding URI that differs from our old one.
116370:     // Otherwise, we should try to recreate, because we may want to apply the
116370:     // new binding
116370:     if (!disp->mBinding) {
116370:       return NS_OK;
116370:     }
116370:     const nsStyleDisplay* oldDisp = oldContext->PeekStyleDisplay();
116370:     if (oldDisp && EqualURIs(disp->mBinding, oldDisp->mBinding)) {
116370:       return NS_OK;
116370:     }
116370:   }
116370: 
116370:   return RecreateFramesForContent(aElement, false);
     1: }
     1: 
 27311: static nsIFrame*
 27311: FindFirstNonWhitespaceChild(nsIFrame* aParentFrame)
 27311: {
 77154:   nsIFrame* f = aParentFrame->GetFirstPrincipalChild();
 27311:   while (f && f->GetType() == nsGkAtoms::textFrame &&
 27311:          f->GetContent()->TextIsOnlyWhitespace()) {
 27311:     f = f->GetNextSibling();
 27311:   }
 27311:   return f;
 27311: }
 27311: 
 27311: static nsIFrame*
 27311: FindNextNonWhitespaceSibling(nsIFrame* aFrame)
 27311: {
 27311:   nsIFrame* f = aFrame;
 27311:   do {
 27311:     f = f->GetNextSibling();
 27311:   } while (f && f->GetType() == nsGkAtoms::textFrame &&
 27311:            f->GetContent()->TextIsOnlyWhitespace());
 27311:   return f;
 27311: }
 27311: 
 79445: bool
 26471: nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval(nsIFrame* aFrame,
  4696:                                                              nsresult* aResult)
  4696: {
  4696:   NS_PRECONDITION(aFrame, "Must have a frame");
  4696:   NS_PRECONDITION(aFrame->GetParent(), "Frame shouldn't be root");
  4696:   NS_PRECONDITION(aResult, "Null out param?");
  4696:   NS_PRECONDITION(aFrame == aFrame->GetFirstContinuation(),
 36656:                   "aFrame not the result of GetPrimaryFrame()?");
  4696: 
  4696:   if (IsFrameSpecial(aFrame)) {
  4696:     // The removal functions can't handle removal of an {ib} split directly; we
  4696:     // need to rebuild the containing block.
     1: #ifdef DEBUG
     1:     if (gNoisyContentUpdates) {
 26471:       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
  4696:              "frame=");
     1:       nsFrame::ListTag(stdout, aFrame);
     1:       printf(" is special\n");
     1:     }
     1: #endif
  4696: 
     1:     *aResult = ReframeContainingBlock(aFrame);
 80486:     return true;
     1:   }
     1: 
 95362:   if (aFrame->GetContentInsertionFrame()->GetType() == nsGkAtoms::legendFrame &&
 29110:       aFrame->GetParent()->GetType() == nsGkAtoms::fieldSetFrame) {
 29110:     // When we remove the legend for a fieldset, we should reframe
 29110:     // the fieldset to ensure another legend is used, if there is one
 80486:     *aResult = RecreateFramesForContent(aFrame->GetParent()->GetContent(), false);
 80486:     return true;
 29110:   }
 29110: 
 26471:   // Now check for possibly needing to reconstruct due to a pseudo parent
 26471:   nsIFrame* inFlowFrame =
 26471:     (aFrame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) ?
 89328:       GetPlaceholderFrameFor(aFrame) : aFrame;
 26471:   NS_ASSERTION(inFlowFrame, "How did that happen?");
 26471:   nsIFrame* parent = inFlowFrame->GetParent();
 26471:   if (IsTablePseudo(parent)) {
 27311:     if (FindFirstNonWhitespaceChild(parent) == inFlowFrame ||
 27311:         !FindNextNonWhitespaceSibling(inFlowFrame->GetLastContinuation()) ||
 26471:         // If we're a table-column-group, then the GetFirstChild check above is
 26471:         // not going to catch cases when we're the first child.
 26471:         (inFlowFrame->GetType() == nsGkAtoms::tableColGroupFrame &&
 77154:          parent->GetFirstChild(nsIFrame::kColGroupList) == inFlowFrame) ||
 26471:         // Similar if we're a table-caption.
 26471:         (inFlowFrame->GetType() == nsGkAtoms::tableCaptionFrame &&
 77154:          parent->GetFirstChild(nsIFrame::kCaptionList) == inFlowFrame)) {
 26471:       // We're the first or last frame in the pseudo.  Need to reframe.
 26471:       // Good enough to recreate frames for |parent|'s content
 80486:       *aResult = RecreateFramesForContent(parent->GetContent(), true);
 80486:       return true;
 26471:     }
 26471:   }
 26471: 
 26607:   // Might need to reconstruct things if this frame's nextSibling is a table
 26607:   // pseudo, since removal of this frame might mean that this pseudo needs to
 26607:   // get merged with the frame's prevSibling.
 26607:   // XXXbz it would be really nice if we had the prevSibling here too, to check
 26607:   // whether this is in fact the case...
 27866:   nsIFrame* nextSibling =
 27866:     FindNextNonWhitespaceSibling(inFlowFrame->GetLastContinuation());
 26607:   NS_ASSERTION(!IsTablePseudo(inFlowFrame), "Shouldn't happen here");
 26607:   if (nextSibling && IsTablePseudo(nextSibling)) {
 26607: #ifdef DEBUG
 26607:     if (gNoisyContentUpdates) {
 26607:       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
 26607:              "frame=");
 26607:       nsFrame::ListTag(stdout, aFrame);
 26607:       printf(" has a table pseudo next sibling of different type\n");
 26607:     }
 26607: #endif
 26607:     // Good enough to recreate frames for aFrame's parent's content; even if
 26607:     // aFrame's parent is a table pseudo, that'll be the right content node.
 80486:     *aResult = RecreateFramesForContent(parent->GetContent(), true);
 80486:     return true;
 26607:   }
 26607: 
103019: #ifdef MOZ_FLEXBOX
103019:   // Might need to reconstruct things if the removed frame's nextSibling is an
103019:   // anonymous flex item.  The removed frame might've been what divided two
103019:   // runs of inline content into two anonymous flex items, which would now
103019:   // need to be merged.
103019:   // NOTE: It's fine that we've advanced nextSibling past whitespace (up above);
103019:   // we're only interested in anonymous flex items here, and those can never
103019:   // be adjacent to whitespace, since they absorb contiguous runs of inline
103019:   // non-replaced content (including whitespace).
103019:   if (nextSibling && IsAnonymousFlexItem(nextSibling)) {
103019:     NS_ABORT_IF_FALSE(parent->GetType() == nsGkAtoms::flexContainerFrame,
103019:                       "anonymous flex items should only exist as children "
103019:                       "of flex container frames");
103019: #ifdef DEBUG
103019:     if (gNoisyContentUpdates) {
103019:       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
103019:              "frame=");
103019:       nsFrame::ListTag(stdout, aFrame);
103019:       printf(" has an anonymous flex item as its next sibling\n");
103019:     }
103019: #endif // DEBUG
103019:     // Recreate frames for the flex container (the removed frame's parent)
103019:     *aResult = RecreateFramesForContent(parent->GetContent(), true);
103019:     return true;
103019:   }
103019: 
103019:   // Might need to reconstruct things if the removed frame's nextSibling is
103019:   // null and its parent is an anonymous flex item. (This might be the last
103019:   // remaining child of that anonymous flex item, which can then go away.)
103019:   if (!nextSibling && IsAnonymousFlexItem(parent)) {
103019:     NS_ABORT_IF_FALSE(parent->GetParent() &&
103019:                       parent->GetParent()->GetType() == nsGkAtoms::flexContainerFrame,
103019:                       "anonymous flex items should only exist as children "
103019:                       "of flex container frames");
103019: #ifdef DEBUG
103019:     if (gNoisyContentUpdates) {
103019:       printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
103019:              "frame=");
103019:       nsFrame::ListTag(stdout, aFrame);
103019:       printf(" has an anonymous flex item as its parent\n");
103019:     }
103019: #endif // DEBUG
103019:     // Recreate frames for the flex container (the removed frame's grandparent)
103019:     *aResult = RecreateFramesForContent(parent->GetParent()->GetContent(),
103019:                                         true);
103019:     return true;
103019:   }
103019: #endif // MOZ_FLEXBOX
103019: 
 40762: #ifdef MOZ_XUL
 40762:   if (aFrame->GetType() == nsGkAtoms::popupSetFrame) {
 40762:     nsIRootBox* rootBox = nsIRootBox::GetRootBox(mPresShell);
 40762:     if (rootBox && rootBox->GetPopupSetFrame() == aFrame) {
 40762:       *aResult = ReconstructDocElementHierarchy();
 80486:       return true;
 40762:     }
 40762:   }
 40762: #endif
 40762: 
 88280:   // Reconstruct if inflowFrame is parent's only child, and parent is, or has,
 88280:   // a non-fluid continuation, i.e. it was split by bidi resolution
 88280:   if (!inFlowFrame->GetPrevSibling() &&
 88280:       !inFlowFrame->GetNextSibling() &&
 95620:       ((parent->GetPrevContinuation() && !parent->GetPrevInFlow()) ||
 95620:        (parent->GetNextContinuation() && !parent->GetNextInFlow()))) {
 88280:     *aResult = RecreateFramesForContent(parent->GetContent(), true);
 88280:     return true;
 88280:   }
 88280: 
 26471:   // We might still need to reconstruct things if the parent of inFlowFrame is
  4696:   // special, since in that case the removal of aFrame might affect the
  4696:   // splitting of its parent.
  4696:   if (!IsFrameSpecial(parent)) {
 80486:     return false;
  4696:   }
  4696: 
 34462:   // If inFlowFrame is not the only in-flow child of |parent|, then removing
 34462:   // it will change nothing about the {ib} split.
 77154:   if (inFlowFrame != parent->GetFirstPrincipalChild() ||
 34462:       inFlowFrame->GetLastContinuation()->GetNextSibling()) {
 80486:     return false;
  4717:   }
  4717: 
 34462:   // If the parent is the first or last part of the {ib} split, then
 34462:   // removing one of its kids will have no effect on the splitting.
 34462:   // Get the first continuation up front so we don't have to do it twice.
 34462:   nsIFrame* parentFirstContinuation = parent->GetFirstContinuation();
 34462:   if (!GetSpecialSibling(parentFirstContinuation) ||
 34462:       !GetSpecialPrevSibling(parentFirstContinuation)) {
 80486:     return false;
 26332:   }
 26332: 
  4696: #ifdef DEBUG
  5310:   if (gNoisyContentUpdates) {
 26471:     printf("nsCSSFrameConstructor::MaybeRecreateContainerForFrameRemoval: "
  4696:            "frame=");
  4696:     nsFrame::ListTag(stdout, parent);
  4696:     printf(" is special\n");
  4696:   }
  4696: #endif
  4696: 
  4696:   *aResult = ReframeContainingBlock(parent);
 80486:   return true;
  4696: }
  4696:  
     1: nsresult
 31031: nsCSSFrameConstructor::RecreateFramesForContent(nsIContent* aContent,
 79445:                                                 bool aAsyncInsert)
     1: {
 42328:   NS_PRECONDITION(!aAsyncInsert || aContent->IsElement(),
 42328:                   "Can only insert elements async");
     1:   // If there is no document, we don't want to recreate frames for it.  (You
     1:   // shouldn't generally be giving this method content without a document
     1:   // anyway).
     1:   // Rebuilding the frame tree can have bad effects, especially if it's the
     1:   // frame tree for chrome (see bug 157322).
     1:   NS_ENSURE_TRUE(aContent->GetDocument(), NS_ERROR_FAILURE);
     1: 
     1:   // Is the frame `special'? If so, we need to reframe the containing
     1:   // block *here*, rather than trying to remove and re-insert the
     1:   // content (which would otherwise result in *two* nested reframe
     1:   // containing block from ContentRemoved() and ContentInserted(),
  4696:   // below!).  We'd really like to optimize away one of those
  4696:   // containing block reframes, hence the code here.
     1: 
 36656:   nsIFrame* frame = aContent->GetPrimaryFrame();
  6862:   if (frame && frame->IsFrameOfType(nsIFrame::eMathML)) {
  6862:     // Reframe the topmost MathML element to prevent exponential blowup
  6862:     // (see bug 397518)
 80486:     while (true) {
  6862:       nsIContent* parentContent = aContent->GetParent();
 36656:       nsIFrame* parentContentFrame = parentContent->GetPrimaryFrame();
  6862:       if (!parentContentFrame || !parentContentFrame->IsFrameOfType(nsIFrame::eMathML))
  6862:         break;
  6862:       aContent = parentContent;
  6862:       frame = parentContentFrame;
  6862:     }
  6862:   }
     1: 
 21943:   if (frame) {
 21943:     nsIFrame* nonGeneratedAncestor = nsLayoutUtils::GetNonGeneratedAncestor(frame);
 21943:     if (nonGeneratedAncestor->GetContent() != aContent) {
 31031:       return RecreateFramesForContent(nonGeneratedAncestor->GetContent(), aAsyncInsert);
 21943:     }
 47706: 
 47706:     nsIFrame* parent = frame->GetParent();
106838:     nsIContent* parentContent = parent ? parent->GetContent() : nullptr;
 47706:     // If the parent frame is a leaf then the subsequent insert will fail to
 47706:     // create a frame, so we need to recreate the parent content. This happens
 47706:     // with native anonymous content from the editor.
 47706:     if (parent && parent->IsLeaf() && parentContent &&
 47706:         parentContent != aContent) {
 47706:       return RecreateFramesForContent(parentContent, aAsyncInsert);
 47706:     }
 21943:   }
 21943: 
     1:   nsresult rv = NS_OK;
     1: 
 26471:   if (frame && MaybeRecreateContainerForFrameRemoval(frame, &rv)) {
     1:     return rv;
     1:   }
     1: 
119415:   nsINode* containerNode = aContent->GetParentNode();
 47669:   // XXXbz how can containerNode be null here?
 28215:   if (containerNode) {
     1:     // Before removing the frames associated with the content object,
     1:     // ask them to save their state onto a temporary state object.
     1:     CaptureStateForFramesOf(aContent, mTempFrameTreeState);
     1: 
 47669:     // Need the nsIContent parent, which might be null here, since we need to
 47669:     // pass it to ContentInserted and ContentRemoved.
 28215:     nsCOMPtr<nsIContent> container = aContent->GetParent();
 28215: 
 47669:     // Remove the frames associated with the content object.
 79445:     bool didReconstruct;
 47669:     rv = ContentRemoved(container, aContent,
 47669:                         aContent->IsRootOfAnonymousSubtree() ?
106838:                           nullptr :
 47669:                           aContent->GetNextSibling(),
 29501:                         REMOVE_FOR_RECONSTRUCTION, &didReconstruct);
  7681: 
  7681:     if (NS_SUCCEEDED(rv) && !didReconstruct) {
  7681:       // Now, recreate the frames associated with this content object. If
  7681:       // ContentRemoved triggered reconstruction, then we don't need to do this
  7681:       // because the frames will already have been built.
 31031:       if (aAsyncInsert) {
 42328:         PostRestyleEvent(aContent->AsElement(), nsRestyleHint(0),
 42328:                          nsChangeHint_ReconstructFrame);
 31031:       } else {
 80486:         rv = ContentInserted(container, aContent, mTempFrameTreeState, false);
     1:       }
     1:     }
 31031:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: //////////////////////////////////////////////////////////////////////
     1: 
     1: // Block frame construction code
     1: 
     1: already_AddRefed<nsStyleContext>
     1: nsCSSFrameConstructor::GetFirstLetterStyle(nsIContent* aContent,
     1:                                            nsStyleContext* aStyleContext)
     1: {
     1:   if (aContent) {
     1:     return mPresShell->StyleSet()->
 41640:       ResolvePseudoElementStyle(aContent->AsElement(),
 35554:                                 nsCSSPseudoElements::ePseudo_firstLetter,
 35554:                                 aStyleContext);
     1:   }
106838:   return nullptr;
     1: }
     1: 
     1: already_AddRefed<nsStyleContext>
     1: nsCSSFrameConstructor::GetFirstLineStyle(nsIContent* aContent,
     1:                                          nsStyleContext* aStyleContext)
     1: {
     1:   if (aContent) {
     1:     return mPresShell->StyleSet()->
 41640:       ResolvePseudoElementStyle(aContent->AsElement(),
 35554:                                 nsCSSPseudoElements::ePseudo_firstLine,
 35554:                                 aStyleContext);
     1:   }
106838:   return nullptr;
     1: }
     1: 
     1: // Predicate to see if a given content (block element) has
     1: // first-letter style applied to it.
 79445: bool
  1254: nsCSSFrameConstructor::ShouldHaveFirstLetterStyle(nsIContent* aContent,
     1:                                                   nsStyleContext* aStyleContext)
     1: {
     1:   return nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
 35554:                                        nsCSSPseudoElements::ePseudo_firstLetter,
     1:                                        mPresShell->GetPresContext());
     1: }
     1: 
 79445: bool
  1254: nsCSSFrameConstructor::HasFirstLetterStyle(nsIFrame* aBlockFrame)
   551: {
   551:   NS_PRECONDITION(aBlockFrame, "Need a frame");
 15909:   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlockFrame),
   551:                "Not a block frame?");
   551: 
   551:   return (aBlockFrame->GetStateBits() & NS_BLOCK_HAS_FIRST_LETTER_STYLE) != 0;
   551: }
   551: 
 79445: bool
  1254: nsCSSFrameConstructor::ShouldHaveFirstLineStyle(nsIContent* aContent,
     1:                                                 nsStyleContext* aStyleContext)
     1: {
 79445:   bool hasFirstLine =
 16270:     nsLayoutUtils::HasPseudoStyle(aContent, aStyleContext,
 35554:                                   nsCSSPseudoElements::ePseudo_firstLine,
     1:                                   mPresShell->GetPresContext());
 16270:   if (hasFirstLine) {
 16270:     // But disable for fieldsets
108991:     int32_t namespaceID;
 16270:     nsIAtom* tag = mDocument->BindingManager()->ResolveTag(aContent,
 16270:                                                            &namespaceID);
 23944:     // This check must match the one in FindHTMLData.
 16270:     hasFirstLine = tag != nsGkAtoms::fieldset ||
 47707:       namespaceID != kNameSpaceID_XHTML;
 16270:   }
 16274: 
 16274:   return hasFirstLine;
     1: }
     1: 
     1: void
  1254: nsCSSFrameConstructor::ShouldHaveSpecialBlockStyle(nsIContent* aContent,
     1:                                                    nsStyleContext* aStyleContext,
 79445:                                                    bool* aHaveFirstLetterStyle,
 79445:                                                    bool* aHaveFirstLineStyle)
     1: {
     1:   *aHaveFirstLetterStyle =
  1254:     ShouldHaveFirstLetterStyle(aContent, aStyleContext);
     1:   *aHaveFirstLineStyle =
  1254:     ShouldHaveFirstLineStyle(aContent, aStyleContext);
     1: }
     1: 
 26208: /* static */
 26208: const nsCSSFrameConstructor::PseudoParentData
 26208: nsCSSFrameConstructor::sPseudoParentData[eParentTypeCount] = {
 26208:   { // Cell
 36653:     FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMESET |
 26208:                      FCDATA_USE_CHILD_ITEMS |
 26208:                      FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRow),
 26208:                      &nsCSSFrameConstructor::ConstructTableCell),
 26208:     &nsCSSAnonBoxes::tableCell
 26208:   },
 26208:   { // Row
 36653:     FULL_CTOR_FCDATA(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMESET |
 26208:                      FCDATA_USE_CHILD_ITEMS |
 26208:                      FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeRowGroup),
 26208:                      &nsCSSFrameConstructor::ConstructTableRow),
 26208:     &nsCSSAnonBoxes::tableRow
 26208:   },
 26208:   { // Row group
 36653:     FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMESET |
 26208:                 FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_USE_CHILD_ITEMS |
 26776:                 FCDATA_SKIP_ABSPOS_PUSH |
 26208:                 FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
 26208:                 NS_NewTableRowGroupFrame),
 26208:     &nsCSSAnonBoxes::tableRowGroup
 26208:   },
 26208:   { // Column group
 36653:     FCDATA_DECL(FCDATA_IS_TABLE_PART | FCDATA_SKIP_FRAMESET |
 26208:                 FCDATA_DISALLOW_OUT_OF_FLOW | FCDATA_USE_CHILD_ITEMS |
 26776:                 FCDATA_SKIP_ABSPOS_PUSH |
 26208:                 FCDATA_DESIRED_PARENT_TYPE_TO_BITS(eTypeTable),
 26208:                 NS_NewTableColGroupFrame),
 26208:     &nsCSSAnonBoxes::tableColGroup
 26208:   },
 26208:   { // Table
 36653:     FULL_CTOR_FCDATA(FCDATA_SKIP_FRAMESET | FCDATA_USE_CHILD_ITEMS,
 26208:                      &nsCSSFrameConstructor::ConstructTable),
 26208:     &nsCSSAnonBoxes::table
 26208:   }
 26208: };
 26208: 
103018: #ifdef MOZ_FLEXBOX
103018: void
103018: nsCSSFrameConstructor::CreateNeededAnonFlexItems(
103018:   nsFrameConstructorState& aState,
103018:   FrameConstructionItemList& aItems,
103018:   nsIFrame* aParentFrame)
103018: {
103018:   NS_ABORT_IF_FALSE(aParentFrame->GetType() == nsGkAtoms::flexContainerFrame,
103018:                     "Should only be called for items in a flex container frame");
103018:   if (aItems.IsEmpty()) {
103018:     return;
103018:   }
103018: 
103018:   FCItemIterator iter(aItems);
103018:   do {
103018:     // Advance iter past children that don't want to be wrapped
103018:     if (iter.SkipItemsThatDontNeedAnonFlexItem(aState)) {
103018:       // Hit the end of the items without finding any remaining children that
103018:       // need to be wrapped. We're finished!
103018:       return;
103018:     }
103018: 
103018:     // If our next potentially-wrappable child is whitespace, then see if
103018:     // there's anything wrappable immediately after it. If not, we just drop
103018:     // the whitespace and move on. (We're not supposed to create any anonymous
103018:     // flex items that _only_ contain whitespace).
127578:     // (BUT if this is generated content, then we don't give whitespace nodes
127578:     // any special treatment, because they're probably not really whitespace --
127578:     // they're just temporarily empty, waiting for their generated text.)
127578:     // XXXdholbert If this node's generated text will *actually end up being
127578:     // entirely whitespace*, then we technically should still skip over it, per
127578:     // the flexbox spec. I'm not bothering with that at this point, since it's
127578:     // a pretty extreme edge case.
127578:     if (!aParentFrame->IsGeneratedContentFrame() &&
127578:         iter.item().IsWhitespace(aState)) {
103018:       FCItemIterator afterWhitespaceIter(iter);
103018:       bool hitEnd = afterWhitespaceIter.SkipWhitespace(aState);
103018:       bool nextChildNeedsAnonFlexItem =
103018:         !hitEnd && afterWhitespaceIter.item().NeedsAnonFlexItem(aState);
103018: 
103018:       if (!nextChildNeedsAnonFlexItem) {
103018:         // There's nothing after the whitespace that we need to wrap, so we
103018:         // just drop this run of whitespace.
103018:         iter.DeleteItemsTo(afterWhitespaceIter);
103018:         if (hitEnd) {
103018:           // Nothing left to do -- we're finished!
103018:           return;
103018:         }
103018:         // else, we have a next child and it does not want to be wrapped.  So,
103018:         // we jump back to the beginning of the loop to skip over that child
103018:         // (and anything else non-wrappable after it)
103018:         NS_ABORT_IF_FALSE(!iter.IsDone() &&
103018:                           !iter.item().NeedsAnonFlexItem(aState),
103018:                           "hitEnd and/or nextChildNeedsAnonFlexItem lied");
103018:         continue;
103018:       }
103018:     }
103018: 
103018:     // Now |iter| points to the first child that needs to be wrapped in an
103018:     // anonymous flex item. Now we see how many children after it also want
103018:     // to be wrapped in an anonymous flex item.
103018:     FCItemIterator endIter(iter); // iterator to find the end of the group
103018:     endIter.SkipItemsThatNeedAnonFlexItem(aState);
103018: 
103018:     NS_ASSERTION(iter != endIter,
103018:                  "Should've had at least one wrappable child to seek past");
103018: 
103018:     // Now, we create the anonymous flex item to contain the children
103018:     // between |iter| and |endIter|.
103018:     nsIAtom* pseudoType = nsCSSAnonBoxes::anonymousFlexItem;
132768:     nsStyleContext* parentStyle = aParentFrame->StyleContext();
103018:     nsIContent* parentContent = aParentFrame->GetContent();
103018:     nsRefPtr<nsStyleContext> wrapperStyle =
103018:       mPresShell->StyleSet()->ResolveAnonymousBoxStyle(pseudoType, parentStyle);
103018: 
103018:     static const FrameConstructionData sBlockFormattingContextFCData =
103018:       FCDATA_DECL(FCDATA_SKIP_FRAMESET | FCDATA_USE_CHILD_ITEMS,
103018:                   NS_NewBlockFormattingContext);
103018: 
103018:     FrameConstructionItem* newItem =
103018:       new FrameConstructionItem(&sBlockFormattingContextFCData,
103018:                                 // Use the content of our parent frame
103018:                                 parentContent,
103018:                                 // Lie about the tag; it doesn't matter anyway
103018:                                 pseudoType,
103018:                                 iter.item().mNameSpaceID,
103018:                                 // no pending binding
106838:                                 nullptr,
103018:                                 wrapperStyle.forget(),
103018:                                 true);
103018: 
103018:     newItem->mIsAllInline = newItem->mHasInlineEnds =
132812:       newItem->mStyleContext->StyleDisplay()->IsInlineOutsideStyle();
103018:     newItem->mIsBlock = !newItem->mIsAllInline;
103018: 
103018:     NS_ABORT_IF_FALSE(!newItem->mIsAllInline && newItem->mIsBlock,
103018:                       "expecting anonymous flex items to be block-level "
103018:                       "(this will make a difference when we encounter "
103018:                       "'flex-align: baseline')");
103018: 
103018:     // Anonymous flex items induce line boundaries around their
103018:     // contents.
103018:     newItem->mChildItems.SetLineBoundaryAtStart(true);
103018:     newItem->mChildItems.SetLineBoundaryAtEnd(true);
103018:     // The parent of the items in aItems is also the parent of the items
103018:     // in mChildItems
103018:     newItem->mChildItems.SetParentHasNoXBLChildren(
103018:       aItems.ParentHasNoXBLChildren());
103018: 
103018:     // Eat up all items between |iter| and |endIter| and put them in our
103018:     // wrapper. This advances |iter| to point to |endIter|.
103018:     iter.AppendItemsToList(endIter, newItem->mChildItems);
103018: 
103018:     iter.InsertItem(newItem);
103018:   } while (!iter.IsDone());
103018: }
103018: #endif // MOZ_FLEXBOX
103018: 
 26208: /*
 26208:  * This function works as follows: we walk through the child list (aItems) and
 26208:  * find items that cannot have aParentFrame as their parent.  We wrap
 26208:  * continuous runs of such items into a FrameConstructionItem for a frame that
 26208:  * gets them closer to their desired parents.  For example, a run of non-row
 26208:  * children of a row-group will get wrapped in a row.  When we later construct
 26208:  * the frame for this wrapper (in this case for the row), it'll be the correct
 26208:  * parent for the cells in the set of items we wrapped or we'll wrap cells
 26208:  * around everything else.  At the end of this method, aItems is guaranteed to
 26208:  * contain only items for frames that can be direct kids of aParentFrame.
 26208:  */
 94297: void
 41931: nsCSSFrameConstructor::CreateNeededTablePseudos(nsFrameConstructorState& aState,
 41931:                                                 FrameConstructionItemList& aItems,
 26208:                                                 nsIFrame* aParentFrame)
 26208: {
 26208:   ParentType ourParentType = GetParentType(aParentFrame);
 26208:   if (aItems.AllWantParentType(ourParentType)) {
 26208:     // Nothing to do here
 94297:     return;
 26208:   }
 26208: 
 26208:   FCItemIterator iter(aItems);
 26208:   do {
 27311:     if (iter.SkipItemsWantingParentType(ourParentType)) {
 26208:       // Nothing else to do here; we're finished
 94297:       return;
 26208:     }
 26208: 
 26208:     // Now we're pointing to the first child that wants a different parent
 27311:     // type.
 26208: 
 26208:     // Now try to figure out what kids we can group together.  We can generally
 26208:     // group everything that has a different desired parent type from us.  Two
 26208:     // exceptions to this:
 26208:     // 1) If our parent type is table, we can't group columns with anything
 26208:     //    else other than whitespace.
 27311:     // 2) Whitespace that lies between two things we can group which both want
 27311:     //    a non-block parent should be dropped, even if we can't group them
 27311:     //    with each other and even if the whitespace wants a parent of
 27311:     //    ourParentType.  Ends of the list count as things that don't want a
 27311:     //    block parent (so that for example we'll drop a whitespace-only list).
 26208: 
 26208:     FCItemIterator endIter(iter); /* iterator to find the end of the group */
 26208:     ParentType groupingParentType = endIter.item().DesiredParentType();
 27311:     if (aItems.AllWantParentType(groupingParentType) &&
 27311:         groupingParentType != eTypeBlock) {
 27311:       // Just group them all and be done with it.  We need the check for
 27311:       // eTypeBlock here to catch the "all the items are whitespace" case
 27311:       // described above.
 27311:       endIter.SetToEnd();
 27311:     } else {
 27311:       // Locate the end of the group.
 27311: 
 27311:       // Keep track of the type the previous item wanted, in case we have to
 27311:       // deal with whitespace.  Start it off with ourParentType, since that's
 27311:       // the last thing |iter| would have skipped over.
 27311:       ParentType prevParentType = ourParentType;
 26208:       do {
 27311:         /* Walk an iterator past any whitespace that we might be able to drop from the list */
 27311:         FCItemIterator spaceEndIter(endIter);
 27311:         if (prevParentType != eTypeBlock &&
 27311:             !aParentFrame->IsGeneratedContentFrame() &&
 41931:             spaceEndIter.item().IsWhitespace(aState)) {
 79445:           bool trailingSpaces = spaceEndIter.SkipWhitespace(aState);
 27311: 
 80657:           // We drop the whitespace if these are not trailing spaces and the next item
 80657:           // does not want a block parent (see case 2 above)
 80657:           // if these are trailing spaces and aParentFrame is a tabular container
 80657:           // according to rule 1.3 of CSS 2.1 Sec 17.2.1. (Being a tabular container
 80657:           // pretty much means ourParentType != eTypeBlock besides the eTypeColGroup case,
 80657:           // which won't reach here.)
 80657:           if ((trailingSpaces && ourParentType != eTypeBlock) ||
 80657:               (!trailingSpaces && spaceEndIter.item().DesiredParentType() != 
 80657:                eTypeBlock)) {
 79445:             bool updateStart = (iter == endIter);
 27311:             endIter.DeleteItemsTo(spaceEndIter);
 27311:             NS_ASSERTION(trailingSpaces == endIter.IsDone(), "These should match");
 27311: 
 27311:             if (updateStart) {
 27311:               iter = endIter;
 27311:             }
 27311: 
 27311:             if (trailingSpaces) {
 27311:               break; /* Found group end */
 27311:             }
 27311: 
 27311:             if (updateStart) {
 27311:               // Update groupingParentType, since it might have been eTypeBlock
 27311:               // just because of the whitespace.
 27311:               groupingParentType = iter.item().DesiredParentType();
 27311:             }
 27311:           }
 27311:         }
 27311: 
 27311:         // Now endIter points to a non-whitespace item or a non-droppable
 27311:         // whitespace item. In the latter case, if this is the end of the group
 27311:         // we'll traverse this whitespace again.  But it'll all just be quick
 27311:         // DesiredParentType() checks which will match ourParentType (that's
 27311:         // what it means that this is the group end), so it's OK.
 27311:         prevParentType = endIter.item().DesiredParentType();
 27311:         if (prevParentType == ourParentType) {
 27311:           // End the group at endIter.
 26208:           break;
 26208:         }
 26208: 
 26208:         if (ourParentType == eTypeTable &&
 27311:             (prevParentType == eTypeColGroup) !=
 26208:             (groupingParentType == eTypeColGroup)) {
 26208:           // Either we started with columns and now found something else, or vice
 26208:           // versa.  In any case, end the grouping.
 26208:           break;
 26208:         }
 27311: 
 27311:         // Include the whitespace we didn't drop (if any) in the group, since
 27311:         // this is not the end of the group.  Note that this doesn't change
 27311:         // prevParentType, since if we didn't drop the whitespace then we ended
 27311:         // at something that wants a block parent.
 27311:         endIter = spaceEndIter;
 27311: 
 27311:         endIter.Next();
 27311:       } while (!endIter.IsDone());
 27311:     }
 27311: 
 27311:     if (iter == endIter) {
 27311:       // Nothing to wrap here; just skipped some whitespace
 27311:       continue;
 27311:     }
 26208: 
 26208:     // Now group together all the items between iter and endIter.  The right
 26208:     // parent type to use depends on ourParentType.
 26208:     ParentType wrapperType;
 26208:     switch (ourParentType) {
 26208:       case eTypeBlock:
 26208:         wrapperType = eTypeTable;
 26208:         break;
 26208:       case eTypeRow:
 26208:         // The parent type for a cell is eTypeBlock, since that's what a cell
 26208:         // looks like to its kids.
 26208:         wrapperType = eTypeBlock;
 26208:         break;
 26208:       case eTypeRowGroup:
 26208:         wrapperType = eTypeRow;
 26208:         break;
 26208:       case eTypeTable:
 26208:         // Either colgroup or rowgroup, depending on what we're grouping.
 26208:         wrapperType = groupingParentType == eTypeColGroup ?
 26208:           eTypeColGroup : eTypeRowGroup;
 26208:         break;
 26208:       default:
126048:         MOZ_NOT_REACHED("Colgroups should be suppresing non-col child items");
 26208:         break;
 26208:     }
 26208: 
 26208:     const PseudoParentData& pseudoData = sPseudoParentData[wrapperType];
 26208:     nsIAtom* pseudoType = *pseudoData.mPseudoType;
132768:     nsStyleContext* parentStyle = aParentFrame->StyleContext();
 26208:     nsIContent* parentContent = aParentFrame->GetContent();
 26208: 
 26208:     if (pseudoType == nsCSSAnonBoxes::table &&
132812:         parentStyle->StyleDisplay()->mDisplay == NS_STYLE_DISPLAY_INLINE) {
 26208:       pseudoType = nsCSSAnonBoxes::inlineTable;
 26208:     }
 26208: 
 26208:     nsRefPtr<nsStyleContext> wrapperStyle =
 35554:       mPresShell->StyleSet()->ResolveAnonymousBoxStyle(pseudoType, parentStyle);
 26208:     FrameConstructionItem* newItem =
 26208:       new FrameConstructionItem(&pseudoData.mFCData,
 26208:                                 // Use the content of our parent frame
 26208:                                 parentContent,
 26208:                                 // Lie about the tag; it doesn't matter anyway
 26208:                                 pseudoType,
 26208:                                 // The namespace does matter, however; it needs
 26208:                                 // to match that of our first child item to
 26208:                                 // match the old behavior
 26208:                                 iter.item().mNameSpaceID,
 34614:                                 // no pending binding
106838:                                 nullptr,
 47661:                                 wrapperStyle.forget(),
 80486:                                 true);
 26208: 
 26208:     // Here we're cheating a tad... technically, table-internal items should be
 26208:     // inline if aParentFrame is inline, but they'll get wrapped in an
 26208:     // inline-table in the end, so it'll all work out.  In any case, arguably
 26208:     // we don't need to maintain this state at this point... but it's better
 26208:     // to, I guess.
 26208:     newItem->mIsAllInline = newItem->mHasInlineEnds =
132812:       newItem->mStyleContext->StyleDisplay()->IsInlineOutsideStyle();
 26208: 
 29501:     // Table pseudo frames always induce line boundaries around their
 29501:     // contents.
 80486:     newItem->mChildItems.SetLineBoundaryAtStart(true);
 80486:     newItem->mChildItems.SetLineBoundaryAtEnd(true);
 29501:     // The parent of the items in aItems is also the parent of the items
 29501:     // in mChildItems
 29501:     newItem->mChildItems.SetParentHasNoXBLChildren(
 29501:       aItems.ParentHasNoXBLChildren());
 29501: 
 26208:     // Eat up all items between |iter| and |endIter| and put them in our wrapper
 26208:     // Advances |iter| to point to |endIter|.
 26208:     iter.AppendItemsToList(endIter, newItem->mChildItems);
 26208: 
 26208:     iter.InsertItem(newItem);
 26208: 
 26208:     // Now |iter| points to the item that was the first one we didn't wrap;
 26208:     // loop and see whether we need to skip it or wrap it in something
 26208:     // different.
 26208:   } while (!iter.IsDone());
 26208: }
 26208: 
 41931: inline nsresult
 25774: nsCSSFrameConstructor::ConstructFramesFromItemList(nsFrameConstructorState& aState,
 25774:                                                    FrameConstructionItemList& aItems,
 25772:                                                    nsIFrame* aParentFrame,
 25772:                                                    nsFrameItems& aFrameItems)
 25772: {
 93524:   aItems.SetTriedConstructingFrames();
 93524: 
 94297:   CreateNeededTablePseudos(aState, aItems, aParentFrame);
 26208: 
103018: #ifdef MOZ_FLEXBOX
103018:   if (aParentFrame->GetType() == nsGkAtoms::flexContainerFrame) {
103018:     CreateNeededAnonFlexItems(aState, aItems, aParentFrame);
103018:   }
103018: #endif // MOZ_FLEXBOX
103018: 
 26208: #ifdef DEBUG
 25774:   for (FCItemIterator iter(aItems); !iter.IsDone(); iter.Next()) {
 26208:     NS_ASSERTION(iter.item().DesiredParentType() == GetParentType(aParentFrame),
 26208:                  "Needed pseudos didn't get created; expect bad things");
 26208:   }
 26208: #endif
 26208: 
 26208:   for (FCItemIterator iter(aItems); !iter.IsDone(); iter.Next()) {
 94297:     nsresult rv = ConstructFramesFromItem(aState, iter, aParentFrame, aFrameItems);
 25772:     NS_ENSURE_SUCCESS(rv, rv);
 25772:   }
 25772: 
 25772:   NS_ASSERTION(!aState.mHavePendingPopupgroup,
 25772:                "Should have proccessed it by now");
 25772: 
 25772:   return NS_OK;
 25772: }
 25772: 
     1: nsresult
     1: nsCSSFrameConstructor::ProcessChildren(nsFrameConstructorState& aState,
     1:                                        nsIContent*              aContent,
 23352:                                        nsStyleContext*          aStyleContext,
     1:                                        nsIFrame*                aFrame,
 79445:                                        const bool               aCanHaveGeneratedContent,
     1:                                        nsFrameItems&            aFrameItems,
 79445:                                        const bool               aAllowBlockStyles,
 90621:                                        PendingBinding*          aPendingBinding,
 90621:                                        nsIFrame*                aPossiblyLeafFrame)
 23352: {
 23352:   NS_PRECONDITION(aFrame, "Must have parent frame here");
 23352:   NS_PRECONDITION(aFrame->GetContentInsertionFrame() == aFrame,
 23352:                   "Parent frame in ProcessChildren should be its own "
 23352:                   "content insertion frame");
 23352: 
 90621:   if (!aPossiblyLeafFrame) {
 90621:     aPossiblyLeafFrame = aFrame;
 90621:   }
 90621: 
     1:   // XXXbz ideally, this would do all the pushing of various
     1:   // containing blocks as needed, so callers don't have to do it...
 23343: 
 79445:   bool haveFirstLetterStyle = false, haveFirstLineStyle = false;
 23352:   if (aAllowBlockStyles) {
 23352:     ShouldHaveSpecialBlockStyle(aContent, aStyleContext, &haveFirstLetterStyle,
 23352:                                 &haveFirstLineStyle);
 23352:   }
 23352: 
 23352:   // The logic here needs to match the logic in GetFloatContainingBlock()
 23352:   nsFrameConstructorSaveState floatSaveState;
103018:   if (ShouldSuppressFloatingOfDescendants(aFrame)) {
106838:     aState.PushFloatContainingBlock(nullptr, floatSaveState);
 23352:   } else if (aFrame->IsFloatContainingBlock()) {
 23352:     aState.PushFloatContainingBlock(aFrame, floatSaveState);
 23352:   }
     1: 
 34614:   nsFrameConstructorState::PendingBindingAutoPusher pusher(aState,
 34614:                                                            aPendingBinding);
 34614: 
 25774:   FrameConstructionItemList itemsToConstruct;
 25768:   nsresult rv = NS_OK;
 25768: 
 29501:   // If we have first-letter or first-line style then frames can get
 29501:   // moved around so don't set these flags.
 29501:   if (aAllowBlockStyles && !haveFirstLetterStyle && !haveFirstLineStyle) {
 80486:     itemsToConstruct.SetLineBoundaryAtStart(true);
 80486:     itemsToConstruct.SetLineBoundaryAtEnd(true);
 29501:   }
 29501: 
 25811:   // Create any anonymous frames we need here.  This must happen before the
 25811:   // non-anonymous children are processed to ensure that popups are never
 25811:   // constructed before the popupset.
 69438:   nsAutoTArray<nsIAnonymousContentCreator::ContentInfo, 4> anonymousItems;
 90621:   GetAnonymousContent(aContent, aPossiblyLeafFrame, anonymousItems);
108991:   for (uint32_t i = 0; i < anonymousItems.Length(); ++i) {
 69439:     nsIContent* content = anonymousItems[i].mContent;
 25768: #ifdef DEBUG
 25768:     nsIAnonymousContentCreator* creator = do_QueryFrame(aFrame);
 69439:     NS_ASSERTION(!creator || !creator->CreateFrameFor(content),
 25768:                  "If you need to use CreateFrameFor, you need to call "
 25768:                  "CreateAnonymousFrames manually and not follow the standard "
 25768:                  "ProcessChildren() codepath for this frame");
 25768: #endif
 69439:     // Assert some things about this content
 69439:     NS_ABORT_IF_FALSE(!(content->GetFlags() &
 69439:                         (NODE_DESCENDANTS_NEED_FRAMES | NODE_NEEDS_FRAME)),
 69439:                       "Should not be marked as needing frames");
 69439:     NS_ABORT_IF_FALSE(!content->IsElement() ||
 69439:                       !(content->GetFlags() & ELEMENT_ALL_RESTYLE_FLAGS),
 69439:                       "Should have no pending restyle flags");
 69439:     NS_ABORT_IF_FALSE(!content->GetPrimaryFrame(),
 69439:                       "Should have no existing frame");
 69439:     NS_ABORT_IF_FALSE(!content->IsNodeOfType(nsINode::eCOMMENT) &&
 69439:                       !content->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION),
 69439:                       "Why is someone creating garbage anonymous content");
 69439: 
 69439:     nsRefPtr<nsStyleContext> styleContext;
 69439:     if (anonymousItems[i].mStyleContext) {
 69439:       styleContext = anonymousItems[i].mStyleContext.forget();
 69439:     } else {
 69439:       styleContext = ResolveStyleContext(aFrame, content, &aState);
 69439:     }
 69439: 
 69439:     AddFrameConstructionItemsInternal(aState, content, aFrame,
 69439:                                       content->Tag(), content->GetNameSpaceID(),
 80486:                                       true, styleContext,
 69439:                                       ITEM_ALLOW_XBL_BASE | ITEM_ALLOW_PAGE_BREAK,
 25768:                                       itemsToConstruct);
 25768:   }
 25768: 
 90621:   if (!aPossiblyLeafFrame->IsLeaf()) {
 23167:     // :before/:after content should have the same style context parent
 23167:     // as normal kids.
 23352:     // Note that we don't use this style context for looking up things like
 23352:     // special block styles because in some cases involving table pseudo-frames
 23352:     // it has nothing to do with the parent frame's desired behavior.
 25768:     nsStyleContext* styleContext;
 25768: 
 25768:     if (aCanHaveGeneratedContent) {
 99736:       aFrame->AddStateBits(NS_FRAME_MAY_HAVE_GENERATED_CONTENT);
 25768:       styleContext =
132768:         nsFrame::CorrectStyleParentFrame(aFrame, nullptr)->StyleContext();
 16976:       // Probe for generated content before
 35554:       CreateGeneratedContentItem(aState, aFrame, aContent, styleContext,
 35554:                                  nsCSSPseudoElements::ePseudo_before,
 25768:                                  itemsToConstruct);
 16976:     }
 16976: 
     1:     ChildIterator iter, last;
     1:     for (ChildIterator::Init(aContent, &iter, &last);
     1:          iter != last;
     1:          ++iter) {
 43792:       nsIContent* child = *iter;
 43792:       // Frame construction item construction should not post
 43792:       // restyles, so removing restyle flags here is safe.
 43792:       if (child->IsElement()) {
 43792:         child->UnsetFlags(ELEMENT_ALL_RESTYLE_FLAGS);
 43792:       }
 47661:       AddFrameConstructionItems(aState, child, iter.XBLInvolved(), aFrame,
 47661:                                 itemsToConstruct);
 29501:     }
 29501:     itemsToConstruct.SetParentHasNoXBLChildren(!iter.XBLInvolved());
     1: 
 16976:     if (aCanHaveGeneratedContent) {
 16976:       // Probe for generated content after
 35554:       CreateGeneratedContentItem(aState, aFrame, aContent, styleContext,
 35554:                                  nsCSSPseudoElements::ePseudo_after,
 25768:                                  itemsToConstruct);
 25768:     }
 40938:   } else {
106838:     ClearLazyBits(aContent->GetFirstChild(), nullptr);
 25768:   }
 25768: 
 25774:   rv = ConstructFramesFromItemList(aState, itemsToConstruct, aFrame,
 16976:                                    aFrameItems);
 25768:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 23352:   NS_ASSERTION(!aAllowBlockStyles || !aFrame->IsBoxFrame(),
 22859:                "can't be both block and box");
 22859: 
 23352:   if (haveFirstLetterStyle) {
 23461:     rv = WrapFramesInFirstLetterFrame(aContent, aFrame, aFrameItems);
 23167:   }
 23352:   if (haveFirstLineStyle) {
106838:     rv = WrapFramesInFirstLineFrame(aState, aContent, aFrame, nullptr,
 30788:                                     aFrameItems);
     1:   }
     1: 
 26208:   // We might end up with first-line frames that change
 26208:   // AnyKidsNeedBlockParent() without changing itemsToConstruct, but that
 26208:   // should never happen for cases whan aFrame->IsBoxFrame().
 26208:   NS_ASSERTION(!haveFirstLineStyle || !aFrame->IsBoxFrame(),
 26208:                "Shouldn't have first-line style if we're a box");
 26208:   NS_ASSERTION(!aFrame->IsBoxFrame() ||
 26208:                itemsToConstruct.AnyItemsNeedBlockParent() ==
106838:                  (AnyKidsNeedBlockParent(aFrameItems.FirstChild()) != nullptr),
 26208:                "Something went awry in our block parent calculations");
 26208: 
 26208:   if (aFrame->IsBoxFrame() && itemsToConstruct.AnyItemsNeedBlockParent()) {
 26208:     // XXXbz we could do this on the FrameConstructionItemList level,
 26208:     // no?  And if we cared we could look through the item list
 26208:     // instead of groveling through the framelist here..
 30785:     nsIContent *badKid = AnyKidsNeedBlockParent(aFrameItems.FirstChild());
 39101:     nsDependentAtomString parentTag(aContent->Tag()), kidTag(badKid->Tag());
 22859:     const PRUnichar* params[] = { parentTag.get(), kidTag.get() };
132768:     nsStyleContext *frameStyleContext = aFrame->StyleContext();
132812:     const nsStyleDisplay *display = frameStyleContext->StyleDisplay();
 22859:     const char *message =
 22859:       (display->mDisplay == NS_STYLE_DISPLAY_INLINE_BOX)
 22859:         ? "NeededToWrapXULInlineBox" : "NeededToWrapXUL";
 84636:     nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
 84636:                                     "FrameConstructor", mDocument,
 84636:                                     nsContentUtils::eXUL_PROPERTIES,
 22859:                                     message,
 84636:                                     params, ArrayLength(params));
 22859: 
 22859:     nsRefPtr<nsStyleContext> blockSC = mPresShell->StyleSet()->
 35554:       ResolveAnonymousBoxStyle(nsCSSAnonBoxes::mozXULAnonymousBlock,
 22859:                                frameStyleContext);
 22859:     nsIFrame *blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
 23305:     // We might, in theory, want to set NS_BLOCK_FLOAT_MGR and
 22859:     // NS_BLOCK_MARGIN_ROOT, but I think it's a bad idea given that
 22859:     // a real block placed here wouldn't get those set on it.
 22859: 
106838:     InitAndRestoreFrame(aState, aContent, aFrame, nullptr,
 80486:                         blockFrame, false);
 22859: 
 22859:     NS_ASSERTION(!blockFrame->HasView(), "need to do view reparenting");
 89328:     ReparentFrames(this, blockFrame, aFrameItems);
 30785: 
 77155:     blockFrame->SetInitialChildList(kPrincipalList, aFrameItems);
 30790:     NS_ASSERTION(aFrameItems.IsEmpty(), "How did that happen?");
 30790:     aFrameItems.Clear();
 22859:     aFrameItems.AddChild(blockFrame);
 22859: 
 22859:     aFrame->AddStateBits(NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK);
 22859:   }
 22859: 
     1:   return rv;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: // Support for :first-line style
     1: 
     1: // Special routine to handle placing a list of frames into a block
     1: // frame that has first-line style. The routine ensures that the first
     1: // collection of inline frames end up in a first-line frame.
 23461: // NOTE: aState may have containing block information related to a
 23461: // different part of the frame tree than where the first line occurs.
 23461: // In particular aState may be set up for where ContentInserted or
 23461: // ContentAppended is inserting content, which may be some
 23461: // non-first-in-flow continuation of the block to which the first-line
 23461: // belongs. So this function needs to be careful about how it uses
 23461: // aState.
     1: nsresult
     1: nsCSSFrameConstructor::WrapFramesInFirstLineFrame(
     1:   nsFrameConstructorState& aState,
     1:   nsIContent*              aBlockContent,
     1:   nsIFrame*                aBlockFrame,
 30788:   nsIFrame*                aLineFrame,
     1:   nsFrameItems&            aFrameItems)
     1: {
     1:   nsresult rv = NS_OK;
     1: 
 30788:   // Find the part of aFrameItems that we want to put in the first-line
 30788:   nsFrameList::FrameLinkEnumerator link(aFrameItems);
107226:   while (!link.AtEnd() && link.NextFrame()->IsInlineOutside()) {
 30788:     link.Next();
 30788:   }
 30788: 
 32843:   nsFrameList firstLineChildren = aFrameItems.ExtractHead(link);
 30788: 
 30788:   if (firstLineChildren.IsEmpty()) {
 30788:     // Nothing is supposed to go into the first-line; nothing to do
 30788:     return NS_OK;
 30788:   }
 30788: 
 30788:   if (!aLineFrame) {
     1:     // Create line frame
  7706:     nsStyleContext* parentStyle =
  7706:       nsFrame::CorrectStyleParentFrame(aBlockFrame,
  7706:                                        nsCSSPseudoElements::firstLine)->
132768:         StyleContext();
     1:     nsRefPtr<nsStyleContext> firstLineStyle = GetFirstLineStyle(aBlockContent,
     1:                                                                 parentStyle);
     1: 
 30788:     aLineFrame = NS_NewFirstLineFrame(mPresShell, firstLineStyle);
 30788: 
     1:     // Initialize the line frame
106838:     rv = InitAndRestoreFrame(aState, aBlockContent, aBlockFrame, nullptr,
 30788:                              aLineFrame);
     1: 
     1:     // The lineFrame will be the block's first child; the rest of the
     1:     // frame list (after lastInlineFrame) will be the second and
 30788:     // subsequent children; insert lineFrame into aFrameItems.
106838:     aFrameItems.InsertFrame(nullptr, nullptr, aLineFrame);
 30788: 
132768:     NS_ASSERTION(aLineFrame->StyleContext() == firstLineStyle,
 30788:                  "Bogus style context on line frame");
 30788:   }
 30788: 
 30788:   if (aLineFrame) {
     1:     // Give the inline frames to the lineFrame <b>after</b> reparenting them
 89328:     ReparentFrames(this, aLineFrame, firstLineChildren);
 77154:     if (aLineFrame->PrincipalChildList().IsEmpty() &&
 30788:         (aLineFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
 77155:       aLineFrame->SetInitialChildList(kPrincipalList, firstLineChildren);
 30788:     } else {
 89328:       AppendFrames(aLineFrame, kPrincipalList, firstLineChildren);
 30788:     }
     1:   }
     1:   else {
     1:     rv = NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: // Special routine to handle appending a new frame to a block frame's
     1: // child list. Takes care of placing the new frame into the right
     1: // place when first-line style is present.
     1: nsresult
     1: nsCSSFrameConstructor::AppendFirstLineFrames(
     1:   nsFrameConstructorState& aState,
     1:   nsIContent*              aBlockContent,
     1:   nsIFrame*                aBlockFrame,
     1:   nsFrameItems&            aFrameItems)
     1: {
     1:   // It's possible that aBlockFrame needs to have a first-line frame
     1:   // created because it doesn't currently have any children.
 77154:   const nsFrameList& blockKids = aBlockFrame->PrincipalChildList();
 30788:   if (blockKids.IsEmpty()) {
     1:     return WrapFramesInFirstLineFrame(aState, aBlockContent,
106838:                                       aBlockFrame, nullptr, aFrameItems);
     1:   }
     1: 
     1:   // Examine the last block child - if it's a first-line frame then
     1:   // appended frames need special treatment.
 30788:   nsIFrame* lastBlockKid = blockKids.LastChild();
     1:   if (lastBlockKid->GetType() != nsGkAtoms::lineFrame) {
     1:     // No first-line frame at the end of the list, therefore there is
 30788:     // an intervening block between any first-line frame the frames
     1:     // we are appending. Therefore, we don't need any special
     1:     // treatment of the appended frames.
 30788:     return NS_OK;
 30788:   }
 30788: 
 30788:   return WrapFramesInFirstLineFrame(aState, aBlockContent, aBlockFrame,
 30788:                                     lastBlockKid, aFrameItems);
     1: }
     1: 
     1: // Special routine to handle inserting a new frame into a block
     1: // frame's child list. Takes care of placing the new frame into the
     1: // right place when first-line style is present.
     1: nsresult
     1: nsCSSFrameConstructor::InsertFirstLineFrames(
     1:   nsFrameConstructorState& aState,
     1:   nsIContent*              aContent,
     1:   nsIFrame*                aBlockFrame,
     1:   nsIFrame**               aParentFrame,
     1:   nsIFrame*                aPrevSibling,
     1:   nsFrameItems&            aFrameItems)
     1: {
     1:   nsresult rv = NS_OK;
 30941:   // XXXbz If you make this method actually do something, check to
 30941:   // make sure that the caller is passing what you expect.  In
 30941:   // particular, which content is aContent?  And audit the rest of
 30941:   // this code too; it makes bogus assumptions and may not build.
     1: #if 0
     1:   nsIFrame* parentFrame = *aParentFrame;
     1:   nsIFrame* newFrame = aFrameItems.childList;
 79445:   bool isInline = IsInlineOutside(newFrame);
     1: 
     1:   if (!aPrevSibling) {
     1:     // Insertion will become the first frame. Two cases: we either
     1:     // already have a first-line frame or we don't.
 77154:     nsIFrame* firstBlockKid = aBlockFrame->GetFirstPrincipalChild();
     1:     if (firstBlockKid->GetType() == nsGkAtoms::lineFrame) {
     1:       // We already have a first-line frame
     1:       nsIFrame* lineFrame = firstBlockKid;
     1: 
     1:       if (isInline) {
     1:         // Easy case: the new inline frame will go into the lineFrame.
 89328:         ReparentFrame(this, lineFrame, newFrame);
106838:         InsertFrames(lineFrame, kPrincipalList, nullptr, newFrame);
     1: 
     1:         // Since the frame is going into the lineFrame, don't let it
     1:         // go into the block too.
106838:         aFrameItems.childList = nullptr;
106838:         aFrameItems.lastChild = nullptr;
     1:       }
     1:       else {
     1:         // Harder case: We are about to insert a block level element
     1:         // before the first-line frame.
     1:         // XXX need a method to steal away frames from the line-frame
     1:       }
     1:     }
     1:     else {
     1:       // We do not have a first-line frame
     1:       if (isInline) {
     1:         // We now need a first-line frame to contain the inline frame.
     1:         nsIFrame* lineFrame = NS_NewFirstLineFrame(firstLineStyle);
     1: 
     1:         if (NS_SUCCEEDED(rv)) {
     1:           // Lookup first-line style context
  7706:           nsStyleContext* parentStyle =
  7706:             nsFrame::CorrectStyleParentFrame(aBlockFrame,
  7706:                                              nsCSSPseudoElements::firstLine)->
132768:               StyleContext();
     1:           nsRefPtr<nsStyleContext> firstLineStyle =
     1:             GetFirstLineStyle(aContent, parentStyle);
     1: 
     1:           // Initialize the line frame
     1:           rv = InitAndRestoreFrame(aState, aContent, aBlockFrame,
106838:                                    nullptr, lineFrame);
     1: 
     1:           // Make sure the caller inserts the lineFrame into the
     1:           // blocks list of children.
     1:           aFrameItems.childList = lineFrame;
     1:           aFrameItems.lastChild = lineFrame;
     1: 
     1:           // Give the inline frames to the lineFrame <b>after</b>
     1:           // reparenting them
132768:           NS_ASSERTION(lineFrame->StyleContext() == firstLineStyle,
     1:                        "Bogus style context on line frame");
     1:           ReparentFrame(aPresContext, lineFrame, newFrame);
 77155:           lineFrame->SetInitialChildList(kPrincipalList, newFrame);
     1:         }
     1:       }
     1:       else {
     1:         // Easy case: the regular insertion logic can insert the new
     1:         // frame because it's a block frame.
     1:       }
     1:     }
     1:   }
     1:   else {
     1:     // Insertion will not be the first frame.
     1:     nsIFrame* prevSiblingParent = aPrevSibling->GetParent();
     1:     if (prevSiblingParent == aBlockFrame) {
     1:       // Easy case: The prev-siblings parent is the block
     1:       // frame. Therefore the prev-sibling is not currently in a
     1:       // line-frame. Therefore the new frame which is going after it,
     1:       // regardless of type, is not going into a line-frame.
     1:     }
     1:     else {
     1:       // If the prevSiblingParent is not the block-frame then it must
     1:       // be a line-frame (if it were a letter-frame, that logic would
     1:       // already have adjusted the prev-sibling to be the
     1:       // letter-frame).
     1:       if (isInline) {
     1:         // Easy case: the insertion can go where the caller thinks it
     1:         // should go (which is into prevSiblingParent).
     1:       }
     1:       else {
     1:         // Block elements don't end up in line-frames, therefore
     1:         // change the insertion point to aBlockFrame. However, there
     1:         // might be more inline elements following aPrevSibling that
     1:         // need to be pulled out of the line-frame and become children
     1:         // of the block.
     1:         nsIFrame* nextSibling = aPrevSibling->GetNextSibling();
     1:         nsIFrame* nextLineFrame = prevSiblingParent->GetNextInFlow();
     1:         if (nextSibling || nextLineFrame) {
     1:           // Oy. We have work to do. Create a list of the new frames
     1:           // that are going into the block by stripping them away from
     1:           // the line-frame(s).
     1:           if (nextSibling) {
     1:             nsLineFrame* lineFrame = (nsLineFrame*) prevSiblingParent;
 32841:             nsFrameList tail = lineFrame->StealFramesAfter(aPrevSibling);
 32841:             // XXX do something with 'tail'
     1:           }
     1: 
     1:           nsLineFrame* nextLineFrame = (nsLineFrame*) lineFrame;
     1:           for (;;) {
     1:             nextLineFrame = nextLineFrame->GetNextInFlow();
     1:             if (!nextLineFrame) {
     1:               break;
     1:             }
 77154:             nsIFrame* kids = nextLineFrame->GetFirstPrincipalChild();
     1:           }
     1:         }
     1:         else {
     1:           // We got lucky: aPrevSibling was the last inline frame in
     1:           // the line-frame.
 89328:           ReparentFrame(this, aBlockFrame, newFrame);
 89328:           InsertFrames(aBlockFrame, kPrincipalList,
     1:                        prevSiblingParent, newFrame);
106838:           aFrameItems.childList = nullptr;
106838:           aFrameItems.lastChild = nullptr;
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1: #endif
     1:   return rv;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: // First-letter support
     1: 
     1: // Determine how many characters in the text fragment apply to the
     1: // first letter
108991: static int32_t
     1: FirstLetterCount(const nsTextFragment* aFragment)
     1: {
108991:   int32_t count = 0;
108991:   int32_t firstLetterLength = 0;
108991: 
108991:   int32_t i, n = aFragment->GetLength();
     1:   for (i = 0; i < n; i++) {
     1:     PRUnichar ch = aFragment->CharAt(i);
124461:     // FIXME: take content language into account when deciding whitespace.
124461:     if (dom::IsSpaceCharacter(ch)) {
     1:       if (firstLetterLength) {
     1:         break;
     1:       }
     1:       count++;
     1:       continue;
     1:     }
     1:     // XXX I18n
     1:     if ((ch == '\'') || (ch == '\"')) {
     1:       if (firstLetterLength) {
     1:         break;
     1:       }
     1:       // keep looping
     1:       firstLetterLength = 1;
     1:     }
     1:     else {
     1:       count++;
     1:       break;
     1:     }
     1:   }
     1: 
     1:   return count;
     1: }
     1: 
 79445: static bool
     1: NeedFirstLetterContinuation(nsIContent* aContent)
     1: {
     1:   NS_PRECONDITION(aContent, "null ptr");
     1: 
 79445:   bool result = false;
     1:   if (aContent) {
     1:     const nsTextFragment* frag = aContent->GetText();
     1:     if (frag) {
108991:       int32_t flc = FirstLetterCount(frag);
108991:       int32_t tl = frag->GetLength();
     1:       if (flc < tl) {
 80486:         result = true;
     1:       }
     1:     }
     1:   }
     1:   return result;
     1: }
     1: 
 79445: static bool IsFirstLetterContent(nsIContent* aContent)
     1: {
     1:   return aContent->TextLength() &&
     1:          !aContent->TextIsOnlyWhitespace();
     1: }
     1: 
     1: /**
     1:  * Create a letter frame, only make it a floating frame.
     1:  */
     1: void
     1: nsCSSFrameConstructor::CreateFloatingLetterFrame(
     1:   nsFrameConstructorState& aState,
     1:   nsIFrame* aBlockFrame,
     1:   nsIContent* aTextContent,
     1:   nsIFrame* aTextFrame,
     1:   nsIContent* aBlockContent,
     1:   nsIFrame* aParentFrame,
     1:   nsStyleContext* aStyleContext,
     1:   nsFrameItems& aResult)
     1: {
     1:   // Create the first-letter-frame
     1:   nsresult rv;
     1:   nsIFrame* letterFrame;
     1:   nsStyleSet *styleSet = mPresShell->StyleSet();
     1: 
     1:   letterFrame = NS_NewFirstLetterFrame(mPresShell, aStyleContext);
     1:   // We don't want to use a text content for a non-text frame (because we want
     1:   // its primary frame to be a text frame).  So use its parent for the
     1:   // first-letter.
     1:   nsIContent* letterContent = aTextContent->GetParent();
 37867:   nsIFrame* containingBlock = aState.GetGeometricParent(
132812:     aStyleContext->StyleDisplay(), aParentFrame);
106838:   InitAndRestoreFrame(aState, letterContent, containingBlock, nullptr,
 37867:                       letterFrame);
     1: 
     1:   // Init the text frame to refer to the letter frame. Make sure we
     1:   // get a proper style context for it (the one passed in is for the
     1:   // letter frame and will have the float property set on it; the text
     1:   // frame shouldn't have that set).
     1:   nsRefPtr<nsStyleContext> textSC;
     1:   textSC = styleSet->ResolveStyleForNonElement(aStyleContext);
     1:   aTextFrame->SetStyleContextWithoutNotification(textSC);
106838:   InitAndRestoreFrame(aState, aTextContent, letterFrame, nullptr, aTextFrame);
     1: 
     1:   // And then give the text frame to the letter frame
 30790:   SetInitialSingleChild(letterFrame, aTextFrame);
     1: 
     1:   // See if we will need to continue the text frame (does it contain
     1:   // more than just the first-letter text or not?) If it does, then we
     1:   // create (in advance) a continuation frame for it.
106838:   nsIFrame* nextTextFrame = nullptr;
     1:   if (NeedFirstLetterContinuation(aTextContent)) {
     1:     // Create continuation
     1:     rv = CreateContinuingFrame(aState.mPresContext, aTextFrame, aParentFrame,
     1:                                &nextTextFrame);
     1:     if (NS_FAILED(rv)) {
     1:       letterFrame->Destroy();
     1:       return;
     1:     }
     1:     // Repair the continuations style context
     1:     nsStyleContext* parentStyleContext = aStyleContext->GetParent();
     1:     if (parentStyleContext) {
     1:       nsRefPtr<nsStyleContext> newSC;
     1:       newSC = styleSet->ResolveStyleForNonElement(parentStyleContext);
     1:       if (newSC) {
     1:         nextTextFrame->SetStyleContext(newSC);
     1:       }
     1:     }
     1:   }
     1: 
 30785:   NS_ASSERTION(aResult.IsEmpty(), "aResult should be an empty nsFrameItems!");
 37867:   // Put the new float before any of the floats in the block we're doing
 37867:   // first-letter for, that is, before any floats whose parent is
 37867:   // containingBlock.
 30788:   nsFrameList::FrameLinkEnumerator link(aState.mFloatedItems);
 37867:   while (!link.AtEnd() && link.NextFrame()->GetParent() != containingBlock) {
 30788:     link.Next();
     1:   }
     1: 
  8199:   rv = aState.AddChild(letterFrame, aResult, letterContent, aStyleContext,
 80486:                        aParentFrame, false, true, false, true,
 30788:                        link.PrevFrame());
     1: 
     1:   if (nextTextFrame) {
     1:     if (NS_FAILED(rv)) {
     1:       nextTextFrame->Destroy();
     1:     } else {
     1:       aResult.AddChild(nextTextFrame);
     1:     }
     1:   }
     1: }
     1: 
     1: /**
     1:  * Create a new letter frame for aTextFrame. The letter frame will be
     1:  * a child of aParentFrame.
     1:  */
     1: nsresult
 23461: nsCSSFrameConstructor::CreateLetterFrame(nsIFrame* aBlockFrame,
 37867:                                          nsIFrame* aBlockContinuation,
     1:                                          nsIContent* aTextContent,
     1:                                          nsIFrame* aParentFrame,
     1:                                          nsFrameItems& aResult)
     1: {
     1:   NS_PRECONDITION(aTextContent->IsNodeOfType(nsINode::eTEXT),
     1:                   "aTextContent isn't text");
 15909:   NS_ASSERTION(nsLayoutUtils::GetAsBlock(aBlockFrame),
   551:                  "Not a block frame?");
   551: 
     1:   // Get style context for the first-letter-frame
  7706:   nsStyleContext* parentStyleContext =
  7706:     nsFrame::CorrectStyleParentFrame(aParentFrame,
  7706:                                      nsCSSPseudoElements::firstLetter)->
132768:       StyleContext();
 23461: 
     1:   // Use content from containing block so that we can actually
     1:   // find a matching style rule.
 23461:   nsIContent* blockContent = aBlockFrame->GetContent();
     1: 
     1:   // Create first-letter style rule
     1:   nsRefPtr<nsStyleContext> sc = GetFirstLetterStyle(blockContent,
     1:                                                     parentStyleContext);
     1:   if (sc) {
     1:     nsRefPtr<nsStyleContext> textSC;
     1:     textSC = mPresShell->StyleSet()->ResolveStyleForNonElement(sc);
     1:     
     1:     // Create a new text frame (the original one will be discarded)
 36793:     // pass a temporary stylecontext, the correct one will be set
 36793:     // later.  Start off by unsetting the primary frame for
 36793:     // aTextContent, so it's no longer pointing to the to-be-destroyed
 36793:     // frame.
 36793:     // XXXbz it would be really nice to destroy the old frame _first_,
 36793:     // then create the new one, so we could avoid this hack.
106838:     aTextContent->SetPrimaryFrame(nullptr);
     1:     nsIFrame* textFrame = NS_NewTextFrame(mPresShell, textSC);
     1: 
 37867:     NS_ASSERTION(aBlockContinuation == GetFloatContainingBlock(aParentFrame),
 23461:                  "Containing block is confused");
130516:     nsFrameConstructorState state(mPresShell,
130516:                                   GetAbsoluteContainingBlock(aParentFrame, FIXED_POS),
130516:                                   GetAbsoluteContainingBlock(aParentFrame, ABS_POS),
 37867:                                   aBlockContinuation);
 23461: 
     1:     // Create the right type of first-letter frame
132812:     const nsStyleDisplay* display = sc->StyleDisplay();
107224:     if (display->IsFloating(aParentFrame)) {
     1:       // Make a floating first-letter frame
 23461:       CreateFloatingLetterFrame(state, aBlockFrame, aTextContent, textFrame,
 37867:                                 blockContent, aParentFrame, sc, aResult);
     1:     }
     1:     else {
     1:       // Make an inflow first-letter frame
     1:       nsIFrame* letterFrame = NS_NewFirstLetterFrame(mPresShell, sc);
     1: 
     1:       // Initialize the first-letter-frame.  We don't want to use a text
     1:       // content for a non-text frame (because we want its primary frame to
     1:       // be a text frame).  So use its parent for the first-letter.
     1:       nsIContent* letterContent = aTextContent->GetParent();
106838:       letterFrame->Init(letterContent, aParentFrame, nullptr);
106838: 
106838:       InitAndRestoreFrame(state, aTextContent, letterFrame, nullptr,
     1:                           textFrame);
     1: 
 30790:       SetInitialSingleChild(letterFrame, textFrame);
 30785:       aResult.Clear();
 30785:       aResult.AddChild(letterFrame);
 36804:       NS_ASSERTION(!aBlockFrame->GetPrevContinuation(),
 36804:                    "should have the first continuation here");
  8759:       aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_CHILD);
     1:     }
 36653:     aTextContent->SetPrimaryFrame(textFrame);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::WrapFramesInFirstLetterFrame(
     1:   nsIContent*              aBlockContent,
     1:   nsIFrame*                aBlockFrame,
     1:   nsFrameItems&            aBlockFrames)
     1: {
     1:   nsresult rv = NS_OK;
     1: 
   551:   aBlockFrame->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_STYLE);
   551: 
106838:   nsIFrame* parentFrame = nullptr;
106838:   nsIFrame* textFrame = nullptr;
106838:   nsIFrame* prevFrame = nullptr;
     1:   nsFrameItems letterFrames;
 79445:   bool stopLooking = false;
 37867:   rv = WrapFramesInFirstLetterFrame(aBlockFrame, aBlockFrame, aBlockFrame,
 30785:                                     aBlockFrames.FirstChild(),
     1:                                     &parentFrame, &textFrame, &prevFrame,
     1:                                     letterFrames, &stopLooking);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1:   if (parentFrame) {
     1:     if (parentFrame == aBlockFrame) {
 30785:       // Take textFrame out of the block's frame list and substitute the
     1:       // letter frame(s) instead.
 33388:       aBlockFrames.DestroyFrame(textFrame);
106838:       aBlockFrames.InsertFrames(nullptr, prevFrame, letterFrames);
     1:     }
     1:     else {
 30941:       // Take the old textFrame out of the inline parent's child list
 89328:       RemoveFrame(kPrincipalList, textFrame);
     1: 
     1:       // Insert in the letter frame(s)
 77155:       parentFrame->InsertFrames(kPrincipalList, prevFrame, letterFrames);
     1:     }
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::WrapFramesInFirstLetterFrame(
     1:   nsIFrame*                aBlockFrame,
 37867:   nsIFrame*                aBlockContinuation,
     1:   nsIFrame*                aParentFrame,
     1:   nsIFrame*                aParentFrameList,
     1:   nsIFrame**               aModifiedParent,
     1:   nsIFrame**               aTextFrame,
     1:   nsIFrame**               aPrevFrame,
     1:   nsFrameItems&            aLetterFrames,
 79445:   bool*                  aStopLooking)
     1: {
     1:   nsresult rv = NS_OK;
     1: 
106838:   nsIFrame* prevFrame = nullptr;
     1:   nsIFrame* frame = aParentFrameList;
     1: 
     1:   while (frame) {
     1:     nsIFrame* nextFrame = frame->GetNextSibling();
     1: 
 16291:     nsIAtom* frameType = frame->GetType();
 16291:     if (nsGkAtoms::textFrame == frameType) {
     1:       // Wrap up first-letter content in a letter frame
     1:       nsIContent* textContent = frame->GetContent();
     1:       if (IsFirstLetterContent(textContent)) {
     1:         // Create letter frame to wrap up the text
 37867:         rv = CreateLetterFrame(aBlockFrame, aBlockContinuation, textContent,
     1:                                aParentFrame, aLetterFrames);
     1:         if (NS_FAILED(rv)) {
     1:           return rv;
     1:         }
     1: 
     1:         // Provide adjustment information for parent
     1:         *aModifiedParent = aParentFrame;
     1:         *aTextFrame = frame;
     1:         *aPrevFrame = prevFrame;
 80486:         *aStopLooking = true;
     1:         return NS_OK;
     1:       }
     1:     }
 16291:     else if (IsInlineFrame(frame) && frameType != nsGkAtoms::brFrame) {
 77154:       nsIFrame* kids = frame->GetFirstPrincipalChild();
 37867:       WrapFramesInFirstLetterFrame(aBlockFrame, aBlockContinuation, frame,
 37867:                                    kids, aModifiedParent, aTextFrame,
     1:                                    aPrevFrame, aLetterFrames, aStopLooking);
     1:       if (*aStopLooking) {
     1:         return NS_OK;
     1:       }
     1:     }
     1:     else {
     1:       // This will stop us looking to create more letter frames. For
     1:       // example, maybe the frame-type is "letterFrame" or
     1:       // "placeholderFrame". This keeps us from creating extra letter
     1:       // frames, and also prevents us from creating letter frames when
     1:       // the first real content child of a block is not text (e.g. an
     1:       // image, hr, etc.)
 80486:       *aStopLooking = true;
     1:       break;
     1:     }
     1: 
     1:     prevFrame = frame;
     1:     frame = nextFrame;
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::RemoveFloatingFirstLetterFrames(
     1:   nsPresContext* aPresContext,
     1:   nsIPresShell* aPresShell,
     1:   nsIFrame* aBlockFrame,
 79445:   bool* aStopLooking)
     1: {
     1:   // First look for the float frame that is a letter frame
 77154:   nsIFrame* floatFrame = aBlockFrame->GetFirstChild(nsIFrame::kFloatList);
     1:   while (floatFrame) {
     1:     // See if we found a floating letter frame
     1:     if (nsGkAtoms::letterFrame == floatFrame->GetType()) {
     1:       break;
     1:     }
     1:     floatFrame = floatFrame->GetNextSibling();
     1:   }
     1:   if (!floatFrame) {
     1:     // No such frame
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Take the text frame away from the letter frame (so it isn't
     1:   // destroyed when we destroy the letter frame).
 77154:   nsIFrame* textFrame = floatFrame->GetFirstPrincipalChild();
     1:   if (!textFrame) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Discover the placeholder frame for the letter frame
     1:   nsIFrame* parentFrame;
 89328:   nsPlaceholderFrame* placeholderFrame = GetPlaceholderFrameFor(floatFrame);
     1: 
     1:   if (!placeholderFrame) {
     1:     // Somethings really wrong
     1:     return NS_OK;
     1:   }
     1:   parentFrame = placeholderFrame->GetParent();
     1:   if (!parentFrame) {
     1:     // Somethings really wrong
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Create a new text frame with the right style context that maps
     1:   // all of the content that was previously part of the letter frame
     1:   // (and probably continued elsewhere).
132768:   nsStyleContext* parentSC = parentFrame->StyleContext();
     1:   nsIContent* textContent = textFrame->GetContent();
     1:   if (!textContent) {
     1:     return NS_OK;
     1:   }
     1:   nsRefPtr<nsStyleContext> newSC;
     1:   newSC = aPresShell->StyleSet()->ResolveStyleForNonElement(parentSC);
     1:   if (!newSC) {
     1:     return NS_OK;
     1:   }
     1:   nsIFrame* newTextFrame = NS_NewTextFrame(aPresShell, newSC);
106838:   newTextFrame->Init(textContent, parentFrame, nullptr);
     1: 
     1:   // Destroy the old text frame's continuations (the old text frame
     1:   // will be destroyed when its letter frame is destroyed).
 27214:   nsIFrame* frameToDelete = textFrame->GetLastContinuation();
 27214:   while (frameToDelete != textFrame) {
 27214:     nsIFrame* nextFrameToDelete = frameToDelete->GetPrevContinuation();
 89328:     RemoveFrame(kPrincipalList, frameToDelete);
 27214:     frameToDelete = nextFrameToDelete;
     1:   }
     1: 
 33388:   nsIFrame* prevSibling = placeholderFrame->GetPrevSibling();
     1: 
     1:   // Now that everything is set...
     1: #ifdef NOISY_FIRST_LETTER
     1:   printf("RemoveFloatingFirstLetterFrames: textContent=%p oldTextFrame=%p newTextFrame=%p\n",
     1:          textContent.get(), textFrame, newTextFrame);
     1: #endif
  4162: 
 36646:   // Remove placeholder frame and the float
 89328:   RemoveFrame(kPrincipalList, placeholderFrame);
     1: 
 36793:   // Now that the old frames are gone, we can start pointing to our
 36793:   // new primary frame.
 36793:   textContent->SetPrimaryFrame(newTextFrame);
 36793: 
132953:   // Wallpaper bug 822910.
132953:   if (prevSibling && prevSibling->GetType() == nsGkAtoms::textFrame) {
132953:     prevSibling->AddStateBits(NS_FRAME_IS_DIRTY);
132953:   }
132953: 
     1:   // Insert text frame in its place
 32846:   nsFrameList textList(newTextFrame, newTextFrame);
 89328:   InsertFrames(parentFrame, kPrincipalList, prevSibling, textList);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::RemoveFirstLetterFrames(nsPresContext* aPresContext,
     1:                                                nsIPresShell* aPresShell,
     1:                                                nsIFrame* aFrame,
 36804:                                                nsIFrame* aBlockFrame,
 79445:                                                bool* aStopLooking)
     1: {
106838:   nsIFrame* prevSibling = nullptr;
 77154:   nsIFrame* kid = aFrame->GetFirstPrincipalChild();
     1: 
     1:   while (kid) {
  4696:     if (nsGkAtoms::letterFrame == kid->GetType()) {
     1:       // Bingo. Found it. First steal away the text frame.
 77154:       nsIFrame* textFrame = kid->GetFirstPrincipalChild();
     1:       if (!textFrame) {
     1:         break;
     1:       }
     1: 
     1:       // Create a new textframe
132768:       nsStyleContext* parentSC = aFrame->StyleContext();
     1:       if (!parentSC) {
     1:         break;
     1:       }
     1:       nsIContent* textContent = textFrame->GetContent();
     1:       if (!textContent) {
     1:         break;
     1:       }
     1:       nsRefPtr<nsStyleContext> newSC;
     1:       newSC = aPresShell->StyleSet()->ResolveStyleForNonElement(parentSC);
     1:       if (!newSC) {
     1:         break;
     1:       }
     1:       textFrame = NS_NewTextFrame(aPresShell, newSC);
106838:       textFrame->Init(textContent, aFrame, nullptr);
     1: 
     1:       // Next rip out the kid and replace it with the text frame
 89328:       RemoveFrame(kPrincipalList, kid);
     1: 
 36793:       // Now that the old frames are gone, we can start pointing to our
 36793:       // new primary frame.
 36793:       textContent->SetPrimaryFrame(textFrame);
 36793: 
132953:       // Wallpaper bug 822910.
132953:       if (prevSibling && prevSibling->GetType() == nsGkAtoms::textFrame) {
132953:         prevSibling->AddStateBits(NS_FRAME_IS_DIRTY);
132953:       }
132953: 
     1:       // Insert text frame in its place
 32846:       nsFrameList textList(textFrame, textFrame);
 89328:       InsertFrames(aFrame, kPrincipalList, prevSibling, textList);
     1: 
 80486:       *aStopLooking = true;
 36804:       NS_ASSERTION(!aBlockFrame->GetPrevContinuation(),
 36804:                    "should have the first continuation here");
 36804:       aBlockFrame->RemoveStateBits(NS_BLOCK_HAS_FIRST_LETTER_CHILD);
     1:       break;
     1:     }
  4696:     else if (IsInlineFrame(kid)) {
     1:       // Look inside child inline frame for the letter frame
 89328:       RemoveFirstLetterFrames(aPresContext, aPresShell,
 36804:                               kid, aBlockFrame, aStopLooking);
     1:       if (*aStopLooking) {
     1:         break;
     1:       }
     1:     }
     1:     prevSibling = kid;
     1:     kid = kid->GetNextSibling();
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::RemoveLetterFrames(nsPresContext* aPresContext,
     1:                                           nsIPresShell* aPresShell,
     1:                                           nsIFrame* aBlockFrame)
     1: {
  8324:   aBlockFrame = aBlockFrame->GetFirstContinuation();
 36804:   nsIFrame* continuation = aBlockFrame;
  8324: 
 79445:   bool stopLooking = false;
 10280:   nsresult rv;
 10280:   do {
 10280:     rv = RemoveFloatingFirstLetterFrames(aPresContext, aPresShell,
 36804:                                          continuation, &stopLooking);
     1:     if (NS_SUCCEEDED(rv) && !stopLooking) {
 89328:       rv = RemoveFirstLetterFrames(aPresContext, aPresShell,
 36804:                                    continuation, aBlockFrame, &stopLooking);
     1:     }
 10280:     if (stopLooking) {
 10280:       break;
 10280:     }
 36804:     continuation = continuation->GetNextContinuation();
 36804:   }  while (continuation);
     1:   return rv;
     1: }
     1: 
     1: // Fixup the letter frame situation for the given block
     1: nsresult
 23461: nsCSSFrameConstructor::RecoverLetterFrames(nsIFrame* aBlockFrame)
     1: {
  8324:   aBlockFrame = aBlockFrame->GetFirstContinuation();
 36804:   nsIFrame* continuation = aBlockFrame;
  8324: 
106838:   nsIFrame* parentFrame = nullptr;
106838:   nsIFrame* textFrame = nullptr;
106838:   nsIFrame* prevFrame = nullptr;
     1:   nsFrameItems letterFrames;
 79445:   bool stopLooking = false;
 10280:   nsresult rv;
 10280:   do {
 10280:     // XXX shouldn't this bit be set already (bug 408493), assert instead?
 36804:     continuation->AddStateBits(NS_BLOCK_HAS_FIRST_LETTER_STYLE);
 37867:     rv = WrapFramesInFirstLetterFrame(aBlockFrame, continuation, continuation,
 77154:                                       continuation->GetFirstPrincipalChild(),
     1:                                       &parentFrame, &textFrame, &prevFrame,
     1:                                       letterFrames, &stopLooking);
     1:     if (NS_FAILED(rv)) {
     1:       return rv;
     1:     }
 10280:     if (stopLooking) {
 10280:       break;
 10280:     }
 36804:     continuation = continuation->GetNextContinuation();
 36804:   } while (continuation);
 10280: 
     1:   if (parentFrame) {
     1:     // Take the old textFrame out of the parents child list
 89328:     RemoveFrame(kPrincipalList, textFrame);
     1: 
     1:     // Insert in the letter frame(s)
 77155:     parentFrame->InsertFrames(kPrincipalList, prevFrame, letterFrames);
     1:   }
     1:   return rv;
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: // listbox Widget Routines
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::CreateListBoxContent(nsPresContext* aPresContext,
     1:                                             nsIFrame*       aParentFrame,
     1:                                             nsIFrame*       aPrevFrame,
     1:                                             nsIContent*     aChild,
     1:                                             nsIFrame**      aNewFrame,
 79445:                                             bool            aIsAppend,
 79445:                                             bool            aIsScrollbar,
     1:                                             nsILayoutHistoryState* aFrameState)
     1: {
     1: #ifdef MOZ_XUL
     1:   nsresult rv = NS_OK;
     1: 
     1:   // Construct a new frame
106838:   if (nullptr != aParentFrame) {
     1:     nsFrameItems            frameItems;
130516:     nsFrameConstructorState state(mPresShell, GetAbsoluteContainingBlock(aParentFrame, FIXED_POS),
130516:                                   GetAbsoluteContainingBlock(aParentFrame, ABS_POS),
     1:                                   GetFloatContainingBlock(aParentFrame), 
     1:                                   mTempFrameTreeState);
     1: 
 92183:     // If we ever initialize the ancestor filter on |state|, make sure
 92183:     // to push the right parent!
 92183: 
     1:     nsRefPtr<nsStyleContext> styleContext;
 64158:     styleContext = ResolveStyleContext(aParentFrame, aChild, &state);
     1: 
     1:     // Pre-check for display "none" - only if we find that, do we create
     1:     // any frame at all
132812:     const nsStyleDisplay* display = styleContext->StyleDisplay();
     1: 
     1:     if (NS_STYLE_DISPLAY_NONE == display->mDisplay) {
106838:       *aNewFrame = nullptr;
     1:       return NS_OK;
     1:     }
     1: 
  6737:     BeginUpdate();
  6737: 
 25774:     FrameConstructionItemList items;
 25771:     AddFrameConstructionItemsInternal(state, aChild, aParentFrame,
 25771:                                       aChild->Tag(), aChild->GetNameSpaceID(),
 80486:                                       true, styleContext,
 47661:                                       ITEM_ALLOW_XBL_BASE, items);
 25774:     ConstructFramesFromItemList(state, items, aParentFrame, frameItems);
     1: 
 30785:     nsIFrame* newFrame = frameItems.FirstChild();
     1:     *aNewFrame = newFrame;
     1: 
 94148:     if (newFrame) {
     1:       // Notify the parent frame
     1:       if (aIsAppend)
 30941:         rv = ((nsListBoxBodyFrame*)aParentFrame)->ListBoxAppendFrames(frameItems);
     1:       else
 30941:         rv = ((nsListBoxBodyFrame*)aParentFrame)->ListBoxInsertFrames(aPrevFrame, frameItems);
     1:     }
  6737: 
  6737:     EndUpdate();
 94148: 
 94148: #ifdef ACCESSIBILITY
 94148:     if (newFrame) {
 94148:       nsAccessibilityService* accService = nsIPresShell::AccService();
 94148:       if (accService) {
 94148:         accService->ContentRangeInserted(mPresShell, aChild->GetParent(),
 94148:                                          aChild, aChild->GetNextSibling());
 94148:       }
 94148:     }
 94148: #endif
     1:   }
     1: 
     1:   return rv;
     1: #else
     1:   return NS_ERROR_FAILURE;
     1: #endif
     1: }
     1: 
     1: //----------------------------------------
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::ConstructBlock(nsFrameConstructorState& aState,
     1:                                       const nsStyleDisplay*    aDisplay,
     1:                                       nsIContent*              aContent,
     1:                                       nsIFrame*                aParentFrame,
     1:                                       nsIFrame*                aContentParentFrame,
     1:                                       nsStyleContext*          aStyleContext,
     1:                                       nsIFrame**               aNewFrame,
     1:                                       nsFrameItems&            aFrameItems,
 79445:                                       bool                     aAbsPosContainer,
 34614:                                       PendingBinding*          aPendingBinding)
     1: {
     1:   // Create column wrapper if necessary
     1:   nsIFrame* blockFrame = *aNewFrame;
 69112:   NS_ASSERTION(blockFrame->GetType() == nsGkAtoms::blockFrame, "not a block frame?");
     1:   nsIFrame* parent = aParentFrame;
     1:   nsRefPtr<nsStyleContext> blockStyle = aStyleContext;
132812:   const nsStyleColumn* columns = aStyleContext->StyleColumn();
     1: 
     1:   if (columns->mColumnCount != NS_STYLE_COLUMN_COUNT_AUTO
     1:       || columns->mColumnWidth.GetUnit() != eStyleUnit_Auto) {
106838:     nsIFrame* columnSetFrame = nullptr;
     1:     columnSetFrame = NS_NewColumnSetFrame(mPresShell, aStyleContext, 0);
     1: 
106838:     InitAndRestoreFrame(aState, aContent, aParentFrame, nullptr, columnSetFrame);
     1:     blockStyle = mPresShell->StyleSet()->
 35554:       ResolveAnonymousBoxStyle(nsCSSAnonBoxes::columnContent, aStyleContext);
     1:     parent = columnSetFrame;
     1:     *aNewFrame = columnSetFrame;
     1: 
 30790:     SetInitialSingleChild(columnSetFrame, blockFrame);
     1:   }
     1: 
     1:   blockFrame->SetStyleContextWithoutNotification(blockStyle);
106838:   InitAndRestoreFrame(aState, aContent, parent, nullptr, blockFrame);
     1: 
  8199:   nsresult rv = aState.AddChild(*aNewFrame, aFrameItems, aContent,
  8199:                                 aStyleContext,
     1:                                 aContentParentFrame ? aContentParentFrame :
     1:                                                       aParentFrame);
     1:   if (NS_FAILED(rv)) {
     1:     return rv;
     1:   }
     1: 
 24659:   if (!mRootElementFrame) {
 24659:     // The frame we're constructing will be the root element frame.
 24659:     // Set mRootElementFrame before processing children.
 24659:     mRootElementFrame = *aNewFrame;
 20147:   }
 20147: 
     1:   // We should make the outer frame be the absolute containing block,
     1:   // if one is required. We have to do this because absolute
     1:   // positioning must be computed with respect to the CSS dimensions
     1:   // of the element, which are the dimensions of the outer block. But
     1:   // we can't really do that because only blocks can have absolute
     1:   // children. So use the block and try to compensate with hacks
     1:   // in nsBlockFrame::CalculateContainingBlockSizeForAbsolutes.
     1:   nsFrameConstructorSaveState absoluteSaveState;
120781:   (*aNewFrame)->AddStateBits(NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
     1:   if (aAbsPosContainer) {
     1:     //    NS_ASSERTION(aRelPos, "should have made area frame for this");
 79488:     aState.PushAbsoluteContainingBlock(*aNewFrame, absoluteSaveState);
     1:   }
     1: 
     1:   // Process the child content
     1:   nsFrameItems childItems;
 80486:   rv = ProcessChildren(aState, aContent, aStyleContext, blockFrame, true,
 80486:                        childItems, true, aPendingBinding);
     1: 
     1:   // Set the frame's initial child list
 77155:   blockFrame->SetInitialChildList(kPrincipalList, childItems);
     1: 
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::ConstructInline(nsFrameConstructorState& aState,
 25769:                                        FrameConstructionItem&   aItem,
     1:                                        nsIFrame*                aParentFrame,
 25131:                                        const nsStyleDisplay*    aDisplay,
 25131:                                        nsFrameItems&            aFrameItems,
 25131:                                        nsIFrame**               aNewFrame)
 25131: {
 34462:   // If an inline frame has non-inline kids, then we chop up the child list
 34462:   // into runs of blocks and runs of inlines, create anonymous block frames to
 34462:   // contain the runs of blocks, inline frames with our style context for the
 34462:   // runs of inlines, and put all these frames, in order, into aFrameItems.  We
 34462:   // put the first one into *aNewFrame.  The whole setup is called an {ib}
 34462:   // split; in what follows "frames in the split" refers to the anonymous blocks
 34462:   // and inlines that contain our children.
 34462:   //
 34462:   // {ib} splits maintain the following invariants:
 34462:   // 1) All frames in the split have the NS_FRAME_IS_SPECIAL bit set.
 39965:   // 2) Each frame in the split has the nsIFrame::IBSplitSpecialSibling
 34462:   //    property pointing to the next frame in the split, except for the last
 34462:   //    one, which does not have it set.
 39965:   // 3) Each frame in the split has the nsIFrame::IBSplitSpecialPrevSibling
 34462:   //    property pointing to the previous frame in the split, except for the
 34462:   //    first one, which does not have it set.
 34462:   // 4) The first and last frame in the split are always inlines.
 34462:   //
 34462:   // An invariant that is NOT maintained is that the wrappers are actually
 34462:   // linked via GetNextSibling linkage.  A simple example is an inline
 34462:   // containing an inline that contains a block.  The three parts of the inner
 34462:   // inline end up with three different parents.
 34462:   //
 34462:   // For example, this HTML:
 34462:   // <span>
 34462:   //   <div>a</div>
 34462:   //   <span>
 34462:   //     b
 34462:   //     <div>c</div>
 34462:   //   </span>
 34462:   //   d
 34462:   //   <div>e</div>
 34462:   //   f
 34462:   //  </span>
 34462:   // Gives the following frame tree:
 34462:   //
 34462:   // Inline (outer span)
 34462:   // Block (anonymous, outer span)
 34462:   //   Block (div)
 34462:   //     Text("a")
 34462:   // Inline (outer span)
 34462:   //   Inline (inner span)
 34462:   //     Text("b")
 34462:   // Block (anonymous, outer span)
 34462:   //   Block (anonymous, inner span)
 34462:   //     Block (div)
 34462:   //       Text("c")
 34462:   // Inline (outer span)
 34462:   //   Inline (inner span)
 34462:   //   Text("d")
 34462:   // Block (anonymous, outer span)
 34462:   //   Block (div)
 34462:   //     Text("e")
 34462:   // Inline (outer span)
 34462:   //   Text("f")
 34462: 
 25769:   nsIContent* const content = aItem.mContent;
 25769:   nsStyleContext* const styleContext = aItem.mStyleContext;
 25769: 
 79445:   bool positioned =
 25131:     NS_STYLE_DISPLAY_INLINE == aDisplay->mDisplay &&
127105:     NS_STYLE_POSITION_RELATIVE == aDisplay->mPosition &&
107225:     !aParentFrame->IsSVGText();
 93590: 
 93590:   nsIFrame* newFrame = NS_NewInlineFrame(mPresShell, styleContext);
 25131: 
     1:   // Initialize the frame
106838:   InitAndRestoreFrame(aState, content, aParentFrame, nullptr, newFrame);
     1: 
 99736:   // Inline frames can always have generated content
 99736:   newFrame->AddStateBits(NS_FRAME_MAY_HAVE_GENERATED_CONTENT);
 99736: 
     1:   nsFrameConstructorSaveState absoluteSaveState;  // definition cannot be inside next block
     1:                                                   // because the object's destructor is significant
     1:                                                   // this is part of the fix for bug 42372
     1: 
120781:   newFrame->AddStateBits(NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
 25131:   if (positioned) {
     1:     // Relatively positioned frames becomes a container for child
     1:     // frames that are positioned
 25131:     aState.PushAbsoluteContainingBlock(newFrame, absoluteSaveState);
     1:   }
     1: 
     1:   // Process the child content
     1:   nsFrameItems childItems;
 26208:   nsresult rv = ConstructFramesFromItemList(aState, aItem.mChildItems, newFrame,
 26208:                                             childItems);
 25772:   if (NS_FAILED(rv)) {
 93590:     // Clean up.
 93590:     // Link up any successfully-created child frames here, so that we'll
 93590:     // clean them up as well.
 93590:     newFrame->SetInitialChildList(kPrincipalList, childItems);
 93590:     newFrame->Destroy();
 25772:     return rv;
 25772:   }
 25772: 
 30789:   nsFrameList::FrameLinkEnumerator firstBlockEnumerator(childItems);
 30789:   if (!aItem.mIsAllInline) {
 30789:     FindFirstBlock(firstBlockEnumerator);
 30789:   }
 30789: 
 30789:   if (aItem.mIsAllInline || firstBlockEnumerator.AtEnd()) { 
 25772:     // This part is easy.  We either already know we have no non-inline kids,
 25772:     // or haven't found any when constructing actual frames (the latter can
 25772:     // happen only if out-of-flows that we thought had no containing block
 25772:     // acquired one when ancestor inline frames and {ib} splits got
 25772:     // constructed).  Just put all the kids into the single inline frame and
 25772:     // bail.
 77155:     newFrame->SetInitialChildList(kPrincipalList, childItems);
 25131:     if (NS_SUCCEEDED(rv)) {
 25769:       aState.AddChild(newFrame, aFrameItems, content, styleContext, aParentFrame);
 25131:       *aNewFrame = newFrame;
 25131:     }
     1:     return rv;
     1:   }
     1: 
 34462:   // This inline frame contains several types of children. Therefore this frame
 34462:   // has to be chopped into several pieces, as described above.
     1: 
 30789:   // Grab the first inline's kids
 32843:   nsFrameList firstInlineKids = childItems.ExtractHead(firstBlockEnumerator);
 77155:   newFrame->SetInitialChildList(kPrincipalList, firstInlineKids);
 30789: 
 34462:   aFrameItems.AddChild(newFrame);
 34462: 
 34462:   CreateIBSiblings(aState, newFrame, positioned, childItems, aFrameItems);
 34462: 
 34462:   *aNewFrame = newFrame;
 34462:   return NS_OK;
 34462: }
 34462: 
 34462: void
 34462: nsCSSFrameConstructor::CreateIBSiblings(nsFrameConstructorState& aState,
 34462:                                         nsIFrame* aInitialInline,
 79445:                                         bool aIsPositioned,
 34462:                                         nsFrameItems& aChildItems,
 34462:                                         nsFrameItems& aSiblings)
 34462: {
 34462:   nsIContent* content = aInitialInline->GetContent();
132768:   nsStyleContext* styleContext = aInitialInline->StyleContext();
 34462:   nsIFrame* parentFrame = aInitialInline->GetParent();
 34462: 
 34462:   // Resolve the right style context for our anonymous blocks.
 78154:   // The distinction in styles is needed because of CSS 2.1, section
 78154:   // 9.2.1.1, which says:
 78154:   //   When such an inline box is affected by relative positioning, any
 78154:   //   resulting translation also affects the block-level box contained
 78154:   //   in the inline box.
 34462:   nsRefPtr<nsStyleContext> blockSC =
 34462:     mPresShell->StyleSet()->
 35554:       ResolveAnonymousBoxStyle(aIsPositioned ?
 34462:                                  nsCSSAnonBoxes::mozAnonymousPositionedBlock :
 34462:                                  nsCSSAnonBoxes::mozAnonymousBlock,
 34462:                                styleContext);
 34462: 
 34462:   nsIFrame* lastNewInline = aInitialInline->GetFirstContinuation();
 34462:   do {
 34462:     // On entry to this loop aChildItems is not empty and the first frame in it
 34462:     // is block-level.
 34462:     NS_PRECONDITION(aChildItems.NotEmpty(), "Should have child items");
107226:     NS_PRECONDITION(!aChildItems.FirstChild()->IsInlineOutside(),
 34462:                     "Must have list starting with block");
 34462: 
 34462:     // The initial run of blocks belongs to an anonymous block that we create
 34462:     // right now. The anonymous block will be the parent of these block
 34462:     // children of the inline.
     1:     nsIFrame* blockFrame;
     1:     blockFrame = NS_NewBlockFrame(mPresShell, blockSC);
     1: 
106838:     InitAndRestoreFrame(aState, content, parentFrame, nullptr, blockFrame,
 80486:                         false);
 34462: 
 34462:     // Find the first non-block child which defines the end of our block kids
 34462:     // and the start of our next inline's kids
 34462:     nsFrameList::FrameLinkEnumerator firstNonBlock =
 34462:       FindFirstNonBlock(aChildItems);
 34462:     nsFrameList blockKids = aChildItems.ExtractHead(firstNonBlock);
 34462: 
 34464:     MoveChildrenTo(aState.mPresContext, aInitialInline, blockFrame, blockKids);
 34462: 
 34462:     SetFrameIsSpecial(lastNewInline, blockFrame);
 34462:     aSiblings.AddChild(blockFrame);
 34462: 
 34462:     // Now grab the initial inlines in aChildItems and put them into an inline
 34462:     // frame
 79483:     nsIFrame* inlineFrame = NS_NewInlineFrame(mPresShell, styleContext);
 25769: 
106838:     InitAndRestoreFrame(aState, content, parentFrame, nullptr, inlineFrame,
 80486:                         false);
 25738: 
120781:     inlineFrame->AddStateBits(NS_FRAME_MAY_HAVE_GENERATED_CONTENT |
120781:                               NS_FRAME_CAN_HAVE_ABSPOS_CHILDREN);
 79483:     if (aIsPositioned) {
 79483:       inlineFrame->MarkAsAbsoluteContainingBlock();
 79483:     }
 79483: 
 34462:     if (aChildItems.NotEmpty()) {
 34462:       nsFrameList::FrameLinkEnumerator firstBlock(aChildItems);
 34462:       FindFirstBlock(firstBlock);
 34462:       nsFrameList inlineKids = aChildItems.ExtractHead(firstBlock);
 34463: 
 34464:       MoveChildrenTo(aState.mPresContext, aInitialInline, inlineFrame,
 34464:                      inlineKids);
 34462:     }
 34462: 
     1:     SetFrameIsSpecial(blockFrame, inlineFrame);
 34462:     aSiblings.AddChild(inlineFrame);
 34462:     lastNewInline = inlineFrame;
 34462:   } while (aChildItems.NotEmpty());
 34462: 
106838:   SetFrameIsSpecial(lastNewInline, nullptr);
     1: }
     1: 
 25738: void
 25772: nsCSSFrameConstructor::BuildInlineChildItems(nsFrameConstructorState& aState,
132160:                                              FrameConstructionItem& aParentItem,
132160:                                              bool aItemIsWithinSVGText,
132160:                                              bool aItemAllowsTextPathChild)
 25772: {
 25772:   // XXXbz should we preallocate aParentItem.mChildItems to some sane
 25772:   // length?  Maybe even to parentContent->GetChildCount()?
 34614:   nsFrameConstructorState::PendingBindingAutoPusher
 34614:     pusher(aState, aParentItem.mPendingBinding);
 25772: 
 25772:   nsStyleContext* const parentStyleContext = aParentItem.mStyleContext;
 25772:   nsIContent* const parentContent = aParentItem.mContent;
 92183: 
128828:   TreeMatchContext::AutoAncestorPusher
 92183:     ancestorPusher(aState.mTreeMatchContext.mAncestorFilter.HasFilter(),
128828:                    aState.mTreeMatchContext,
 92183:                    parentContent->AsElement());
 92183:   
132160:   if (!aItemIsWithinSVGText) {
132160:     // Probe for generated content before
106838:     CreateGeneratedContentItem(aState, nullptr, parentContent, parentStyleContext,
 35554:                                nsCSSPseudoElements::ePseudo_before,
 25772:                                aParentItem.mChildItems);
132160:   }
 25772: 
     1:   ChildIterator iter, last;
 25772:   for (ChildIterator::Init(parentContent, &iter, &last);
     1:        iter != last;
     1:        ++iter) {
 63575:     // Manually check for comments/PIs, since we don't have a frame to pass to
 25772:     // AddFrameConstructionItems.  We know our parent is a non-replaced inline,
 25772:     // so there is no need to do the NeedFrameFor check.
 25772:     nsIContent* content = *iter;
 40938:     content->UnsetFlags(NODE_DESCENDANTS_NEED_FRAMES | NODE_NEEDS_FRAME);
 25772:     if (content->IsNodeOfType(nsINode::eCOMMENT) ||
 25772:         content->IsNodeOfType(nsINode::ePROCESSING_INSTRUCTION)) {
 25772:       continue;
 25772:     }
 43792:     if (content->IsElement()) {
 43792:       // See comment explaining why we need to remove the "is possible
 43792:       // restyle root" flags in AddFrameConstructionItems.  But note
 43792:       // that we can remove all restyle flags, just like in
 43792:       // ProcessChildren and for the same reason.
 43792:       content->UnsetFlags(ELEMENT_ALL_RESTYLE_FLAGS);
 43792:     }
 25772: 
 25772:     nsRefPtr<nsStyleContext> childContext =
 64158:       ResolveStyleContext(parentStyleContext, content, &aState);
 25772: 
132160:     uint32_t flags = ITEM_ALLOW_XBL_BASE | ITEM_ALLOW_PAGE_BREAK;
132160:     if (aItemIsWithinSVGText) {
132160:       flags |= ITEM_IS_WITHIN_SVG_TEXT;
132160:     }
132160:     if (aItemAllowsTextPathChild && aParentItem.mIsForSVGAElement) {
132160:       flags |= ITEM_ALLOWS_TEXT_PATH_CHILD;
132160:     }
106838:     AddFrameConstructionItemsInternal(aState, content, nullptr, content->Tag(),
 47661:                                       content->GetNameSpaceID(),
 47661:                                       iter.XBLInvolved(), childContext,
132160:                                       flags,
 25772:                                       aParentItem.mChildItems);
 25772:   }
 25772: 
132160:   if (!aItemIsWithinSVGText) {
 25768:     // Probe for generated content after
106838:     CreateGeneratedContentItem(aState, nullptr, parentContent, parentStyleContext,
 35554:                                nsCSSPseudoElements::ePseudo_after,
 25772:                                aParentItem.mChildItems);
132160:   }
 25772: 
 25774:   aParentItem.mIsAllInline = aParentItem.mChildItems.AreAllItemsInline();
     1: }
     1: 
 35612: // return whether it's ok to append (in the AppendFrames sense) to
 35612: // aParentFrame if our nextSibling is aNextSibling.  aParentFrame must
 35612: // be an {ib} special inline.
 79445: static bool
 35612: IsSafeToAppendToSpecialInline(nsIFrame* aParentFrame, nsIFrame* aNextSibling)
 35612: {
 35612:   NS_PRECONDITION(IsInlineFrame(aParentFrame),
 35612:                   "Must have an inline parent here");
 35612:   do {
 35612:     NS_ASSERTION(IsFrameSpecial(aParentFrame), "How is this not special?");
 35612:     if (aNextSibling || aParentFrame->GetNextContinuation() ||
 35612:         GetSpecialSibling(aParentFrame)) {
 80486:       return false;
 35612:     }
 35612: 
 35612:     aNextSibling = aParentFrame->GetNextSibling();
 35612:     aParentFrame = aParentFrame->GetParent();
 35612:   } while (IsInlineFrame(aParentFrame));
 36325: 
 80486:   return true;
 35612: }
 35612: 
 79445: bool
     1: nsCSSFrameConstructor::WipeContainingBlock(nsFrameConstructorState& aState,
     1:                                            nsIFrame* aContainingBlock,
     1:                                            nsIFrame* aFrame,
 27311:                                            FrameConstructionItemList& aItems,
 79445:                                            bool aIsAppend,
  4696:                                            nsIFrame* aPrevSibling)
  4696: {
 25774:   if (aItems.IsEmpty()) {
 80486:     return false;
  4696:   }
  4696:   
 34462:   // Before we go and append the frames, we must check for several
  7189:   // special situations.
  7189: 
  7189:   // Situation #1 is a XUL frame that contains frames that are required
  7189:   // to be wrapped in blocks.
  7189:   if (aFrame->IsBoxFrame() &&
  7189:       !(aFrame->GetStateBits() & NS_STATE_BOX_WRAPS_KIDS_IN_BLOCK) &&
 25774:       aItems.AnyItemsNeedBlockParent()) {
 80486:     RecreateFramesForContent(aFrame->GetContent(), true);
 80486:     return true;
  7189:   }
  7189: 
 27311:   nsIFrame* nextSibling = ::GetInsertNextSibling(aFrame, aPrevSibling);
 27311: 
103019: #ifdef MOZ_FLEXBOX
103019:   // Situation #2 is a flex container frame into which we're inserting new
103019:   // inline non-replaced children, adjacent to an existing anonymous flex item.
103019:   if (aFrame->GetType() == nsGkAtoms::flexContainerFrame) {
103019:     FCItemIterator iter(aItems);
103019: 
103019:     // Check if we're adding to-be-wrapped content right *after* an existing
103019:     // anonymous flex item (which would need to absorb this content).
103019:     if (aPrevSibling && IsAnonymousFlexItem(aPrevSibling) &&
103019:         iter.item().NeedsAnonFlexItem(aState)) {
103019:       RecreateFramesForContent(aFrame->GetContent(), true);
103019:       return true;
103019:     }
103019: 
103019:     // Check if we're adding to-be-wrapped content right *before* an existing
103019:     // anonymous flex item (which would need to absorb this content).
103019:     if (nextSibling && IsAnonymousFlexItem(nextSibling)) {
103019:       // Jump to the last entry in the list
103019:       iter.SetToEnd();
103019:       iter.Prev();
103019:       if (iter.item().NeedsAnonFlexItem(aState)) {
103019:         RecreateFramesForContent(aFrame->GetContent(), true);
103019:         return true;
103019:       }
103019:     }
103019:   }
103019: 
103019:   // Situation #3 is an anonymous flex item that's getting new children who
103019:   // don't want to be wrapped.
103019:   if (IsAnonymousFlexItem(aFrame)) {
103019:     nsIFrame* flexContainerFrame = aFrame->GetParent();
103019:     NS_ABORT_IF_FALSE(flexContainerFrame &&
103019:                       flexContainerFrame->GetType() == nsGkAtoms::flexContainerFrame,
103019:                       "anonymous flex items should only exist as children "
103019:                       "of flex container frames");
103019: 
103019:     // We need to push a null float containing block to be sure that
103019:     // "NeedsAnonFlexItem" will know we're not honoring floats for this
103019:     // inserted content. (In particular, this is necessary in order for
103019:     // NeedsAnonFlexItem's "GetGeometricParent" call to return the correct
103019:     // result.) We're not honoring floats on this content because it has the
103019:     // _flex container_ as its parent in the content tree.
103019:     nsFrameConstructorSaveState floatSaveState;
106838:     aState.PushFloatContainingBlock(nullptr, floatSaveState);
103019: 
103019:     FCItemIterator iter(aItems);
103019:     // Skip over things that _do_ need an anonymous flex item, because
103019:     // they're perfectly happy to go here -- they won't cause a reframe.
103019:     if (!iter.SkipItemsThatNeedAnonFlexItem(aState)) {
103019:       // We hit something that _doesn't_ need an anonymous flex item!
103019:       // Rebuild the flex container to bust it out.
103019:       RecreateFramesForContent(flexContainerFrame->GetContent(), true);
103019:       return true;
103019:     }
103019: 
103019:     // If we get here, then everything in |aItems| needs to be wrapped in
103019:     // an anonymous flex item.  That's where it's already going - good!
103019:   }
103019: #endif // MOZ_FLEXBOX
103019: 
103019:   // Situation #4 is a case when table pseudo-frames don't work out right
 26607:   ParentType parentType = GetParentType(aFrame);
 26607:   // If all the kids want a parent of the type that aFrame is, then we're all
 26607:   // set to go.  Indeed, there won't be any table pseudo-frames created between
 26607:   // aFrame and the kids, so those won't need to be merged with any table
 26607:   // pseudo-frames that might already be kids of aFrame.  If aFrame itself is a
 26607:   // table pseudo-frame, then all the kids in this list would have wanted a
 26607:   // frame of that type wrapping them anyway, so putting them inside it is ok.
 26607:   if (!aItems.AllWantParentType(parentType)) {
 27311:     // Don't give up yet.  If parentType is not eTypeBlock and the parent is
 27311:     // not a generated content frame, then try filtering whitespace out of the
 27311:     // list.
 27311:     if (parentType != eTypeBlock && !aFrame->IsGeneratedContentFrame()) {
 27311:       // For leading whitespace followed by a kid that wants our parent type,
 27311:       // there are four cases:
 27311:       // 1) We have a previous sibling which is not a table pseudo.  That means
 27311:       //    that previous sibling wanted a (non-block) parent of the type we're
 27311:       //    looking at.  Then the whitespace comes between two table-internal
 27311:       //    elements, so should be collapsed out.
 27311:       // 2) We have a previous sibling which is a table pseudo.  It might have
 27311:       //    kids who want this whitespace, so we need to reframe.
 29838:       // 3) We have no previous sibling and our parent frame is not a table
 29838:       //    pseudo.  That means that we'll be at the beginning of our actual
 29838:       //    non-block-type parent, and the whitespace is OK to collapse out.
 29838:       //    If something is ever inserted before us, it'll find our own parent
 29838:       //    as its parent and if it's something that would care about the
 29838:       //    whitespace it'll want a block parent, so it'll trigger a reframe at
 29838:       //    that point.
 29838:       // 4) We have no previous sibling and our parent frame is a table pseudo.
 29838:       //    Need to reframe.
 29838:       // All that is predicated on finding the correct previous sibling.  We
 29838:       // might have to walk backwards along continuations from aFrame to do so.
 27311:       //
 27311:       // It's always OK to drop whitespace between any two items that want a
 27311:       // parent of type parentType.
 27311:       //
 29838:       // For trailing whitespace preceded by a kid that wants our parent type,
 29838:       // there are four cases:
 29838:       // 1) We have a next sibling which is not a table pseudo.  That means
 29838:       //    that next sibling wanted a (non-block) parent of the type we're
 29838:       //    looking at.  Then the whitespace comes between two table-internal
 29838:       //    elements, so should be collapsed out.
 29838:       // 2) We have a next sibling which is a table pseudo.  It might have
 29838:       //    kids who want this whitespace, so we need to reframe.
 29838:       // 3) We have no next sibling and our parent frame is not a table
 29838:       //    pseudo.  That means that we'll be at the end of our actual
 29838:       //    non-block-type parent, and the whitespace is OK to collapse out.
 29838:       //    If something is ever inserted after us, it'll find our own parent
 29838:       //    as its parent and if it's something that would care about the
 29838:       //    whitespace it'll want a block parent, so it'll trigger a reframe at
 29838:       //    that point.
 29838:       // 4) We have no next sibling and our parent frame is a table pseudo.
 29838:       //    Need to reframe.
 29838:       // All that is predicated on finding the correct next sibling.  We might
 29838:       // have to walk forward along continuations from aFrame to do so.  That
 29838:       // said, in the case when nextSibling is null at this point and aIsAppend
 29838:       // is true, we know we're in case 3.  Furthermore, in that case we don't
 29838:       // even have to worry about the table pseudo situation; we know our
 29838:       // parent is not a table pseudo there.
 27311:       FCItemIterator iter(aItems);
 27311:       FCItemIterator start(iter);
 27311:       do {
 27311:         if (iter.SkipItemsWantingParentType(parentType)) {
 27311:           break;
 27311:         }
 27311: 
 27311:         // iter points to an item that wants a different parent.  If it's not
 27311:         // whitespace, we're done; no more point scanning the list.
 41931:         if (!iter.item().IsWhitespace(aState)) {
 27311:           break;
 27311:         }
 27311: 
 27311:         if (iter == start) {
 29838:           // Leading whitespace.  How to handle this depends on our
 29838:           // previous sibling and aFrame.  See the long comment above.
 29838:           nsIFrame* prevSibling = aPrevSibling;
 29838:           if (!prevSibling) {
 29838:             // Try to find one after all
 29838:             nsIFrame* parentPrevCont = aFrame->GetPrevContinuation();
 29838:             while (parentPrevCont) {
 77155:               prevSibling = parentPrevCont->GetLastChild(kPrincipalList);
 29838:               if (prevSibling) {
 29838:                 break;
 29838:               }
 29838:               parentPrevCont = parentPrevCont->GetPrevContinuation();
 29838:             }
 29838:           };
 29838:           if (prevSibling) {
 29838:             if (IsTablePseudo(prevSibling)) {
 27311:               // need to reframe
 27311:               break;
 27311:             }
 29838:           } else if (IsTablePseudo(aFrame)) {
 27311:             // need to reframe
 27311:             break;
 27311:           }
 27311:         }
 27311: 
 27311:         FCItemIterator spaceEndIter(iter);
 27311:         // Advance spaceEndIter past any whitespace
 79445:         bool trailingSpaces = spaceEndIter.SkipWhitespace(aState);
 79445: 
 79445:         bool okToDrop;
 29838:         if (trailingSpaces) {
 29838:           // Trailing whitespace.  How to handle this depeds on aIsAppend, our
 29838:           // next sibling and aFrame.  See the long comment above.
 29838:           okToDrop = aIsAppend && !nextSibling;
 29838:           if (!okToDrop) {
 29838:             if (!nextSibling) {
 29838:               // Try to find one after all
 29838:               nsIFrame* parentNextCont = aFrame->GetNextContinuation();
 29838:               while (parentNextCont) {
 77154:                 nextSibling = parentNextCont->GetFirstPrincipalChild();
 29838:                 if (nextSibling) {
 29838:                   break;
 29838:                 }
 29838:                 parentNextCont = parentNextCont->GetNextContinuation();
 29838:               }
 29838:             }
 29838: 
 29838:             okToDrop = (nextSibling && !IsTablePseudo(nextSibling)) ||
 29838:                        (!nextSibling && !IsTablePseudo(aFrame));
 29838:           }
 29838: #ifdef DEBUG
 29838:           else {
 29838:             NS_ASSERTION(!IsTablePseudo(aFrame), "How did that happen?");
 29838:           }
 29838: #endif
 29838:         } else {
 29838:           okToDrop = (spaceEndIter.item().DesiredParentType() == parentType);
 29838:         }
 29838: 
 29838:         if (okToDrop) {
 27311:           iter.DeleteItemsTo(spaceEndIter);
 27311:         } else {
 27311:           // We're done: we don't want to drop the whitespace, and it has the
 27311:           // wrong parent type.
 27311:           break;
 27311:         }
 27311: 
 27311:         // Now loop, since |iter| points to item right after the whitespace we
 27311:         // removed.
 27311:       } while (!iter.IsDone());
 27311:     }
 27311: 
 26607:     // We might be able to figure out some sort of optimizations here, but they
 26607:     // would have to depend on having a correct aPrevSibling and a correct next
 26607:     // sibling.  For example, we can probably avoid reframing if none of
 26607:     // aFrame, aPrevSibling, and next sibling are table pseudo-frames.  But it
 26607:     // doesn't seem worth it to worry about that for now, especially since we
 26607:     // in fact do not have a reliable aPrevSibling, nor any next sibling, in
 26607:     // this method.
 26607: 
 27311:     // aItems might have changed, so recheck the parent type thing.  In fact,
 27311:     // it might be empty, so recheck that too.
 27311:     if (aItems.IsEmpty()) {
 80486:       return false;
 27311:     }
 27311: 
 27311:     if (!aItems.AllWantParentType(parentType)) {
 26607:       // Reframing aFrame->GetContent() is good enough, since the content of
 26607:       // table pseudo-frames is the ancestor content.
 80486:       RecreateFramesForContent(aFrame->GetContent(), true);
 80486:       return true;
 26607:     }
 27311:   }
 26607: 
 34462:   // Now we have several cases involving {ib} splits.  Put them all in a
 34462:   // do/while with breaks to take us to the "go and reconstruct" code.
 34462:   do {
  4696:     if (IsInlineFrame(aFrame)) {
 25774:       if (aItems.AreAllItemsInline()) {
 34462:         // We can just put the kids in.
 80486:         return false;
  4696:       }
 34462: 
 34462:       if (!IsFrameSpecial(aFrame)) {
 34462:         // Need to go ahead and reconstruct.
 34462:         break;
 34462:       }
 34462: 
 34462:       // Now we're adding kids including some blocks to an inline part of an
 34462:       // {ib} split.  If we plan to call AppendFrames, and don't have a next
 34462:       // sibling for the new frames, and our parent is the last continuation of
 35612:       // the last part of the {ib} split, and the same is true of all our
 35612:       // ancestor inlines (they have no following continuations and they're the
 35612:       // last part of their {ib} splits and we'd be adding to the end for all
 35612:       // of them), then AppendFrames will handle things for us.  Bail out in
 35612:       // that case.
 35612:       if (aIsAppend && IsSafeToAppendToSpecialInline(aFrame, nextSibling)) {
 80486:         return false;
 34462:       }
 34462: 
 34462:       // Need to reconstruct.
 34462:       break;
 34462:     }
 34462: 
 34462:     // Now we know we have a block parent.  If it's not special, we're all set.
 34462:     if (!IsFrameSpecial(aFrame)) {
 80486:       return false;
 27310:     }
 27310: 
 34462:     // We're adding some kids to a block part of an {ib} split.  If all the
 34462:     // kids are blocks, we don't need to reconstruct.
 34462:     if (aItems.AreAllItemsBlock()) {
 80486:       return false;
 34462:     }
 34462: 
 34462:     // We might have some inline kids for this block.  Just reconstruct.
  5324:     break;
 34462:   } while (0);
     1: 
     1:   // If we don't have a containing block, start with aFrame and look for one.
     1:   if (!aContainingBlock) {
     1:     aContainingBlock = aFrame;
     1:   }
     1:   
     1:   // To find the right block to reframe, just walk up the tree until we find a
     1:   // frame that is:
     1:   // 1)  Not part of an IB split (not special)
     1:   // 2)  Not a pseudo-frame
     1:   // 3)  Not an inline frame
     1:   // We're guaranteed to find one, since nsStyleContext::ApplyStyleFixups
     1:   // enforces that the root is display:none, display:table, or display:block.
     1:   // Note that walking up "too far" is OK in terms of correctness, even if it
     1:   // might be a little inefficient.  This is why we walk out of all
     1:   // pseudo-frames -- telling which ones are or are not OK to walk out of is
     1:   // too hard (and I suspect that we do in fact need to walk out of all of
     1:   // them).
107226:   while (IsFrameSpecial(aContainingBlock) || aContainingBlock->IsInlineOutside() ||
132768:          aContainingBlock->StyleContext()->GetPseudo()) {
     1:     aContainingBlock = aContainingBlock->GetParent();
     1:     NS_ASSERTION(aContainingBlock,
     1:                  "Must have non-inline, non-special, non-pseudo frame as root "
     1:                  "(or child of root, for a table root)!");
     1:   }
     1: 
     1:   // Tell parent of the containing block to reformulate the
     1:   // entire block. This is painful and definitely not optimal
     1:   // but it will *always* get the right answer.
     1: 
     1:   nsIContent *blockContent = aContainingBlock->GetContent();
     1: #ifdef DEBUG
     1:   if (gNoisyContentUpdates) {
 28215:     printf("nsCSSFrameConstructor::WipeContainingBlock: blockContent=%p\n",
 28215:            static_cast<void*>(blockContent));
 28215:   }
 28215: #endif
 80486:   RecreateFramesForContent(blockContent, true);
 80486:   return true;
     1: }
     1: 
     1: nsresult
     1: nsCSSFrameConstructor::ReframeContainingBlock(nsIFrame* aFrame)
     1: {
     1: 
     1: #ifdef DEBUG
     1:   // ReframeContainingBlock is a NASTY routine, it causes terrible performance problems
     1:   // so I want to see when it is happening!  Unfortunately, it is happening way to often because
     1:   // so much content on the web causes 'special' block-in-inline frame situations and we handle them
     1:   // very poorly
     1:   if (gNoisyContentUpdates) {
     1:     printf("nsCSSFrameConstructor::ReframeContainingBlock frame=%p\n",
  3233:            static_cast<void*>(aFrame));
     1:   }
     1: #endif
     1: 
 28215:   // XXXbz how exactly would we get here while isReflowing anyway?  Should this
 28215:   // whole test be ifdef DEBUG?
 40048:   if (mPresShell->IsReflowLocked()) {
     1:     // don't ReframeContainingBlock, this will result in a crash
     1:     // if we remove a tree that's in reflow - see bug 121368 for testcase
 31561:     NS_ERROR("Atemptted to nsCSSFrameConstructor::ReframeContainingBlock during a Reflow!!!");
     1:     return NS_OK;
     1:   }
     1: 
     1:   // Get the first "normal" ancestor of the target frame.
     1:   nsIFrame* containingBlock = GetIBContainingBlockFor(aFrame);
     1:   if (containingBlock) {
     1:     // From here we look for the containing block in case the target
     1:     // frame is already a block (which can happen when an inline frame
     1:     // wraps some of its content in an anonymous block; see
     1:     // ConstructInline)
     1:    
     1:     // NOTE: We used to get the FloatContainingBlock here, but it was often wrong.
     1:     // GetIBContainingBlock works much better and provides the correct container in all cases
     1:     // so GetFloatContainingBlock(aFrame) has been removed
     1: 
     1:     // And get the containingBlock's content
     1:     nsCOMPtr<nsIContent> blockContent = containingBlock->GetContent();
     1:     if (blockContent) {
     1: #ifdef DEBUG
     1:       if (gNoisyContentUpdates) {
 28215:         printf("  ==> blockContent=%p\n", static_cast<void*>(blockContent));
 28215:       }
 28215: #endif
 80486:       return RecreateFramesForContent(blockContent, true);
     1:     }
     1:   }
     1: 
     1:   // If we get here, we're screwed!
 41634:   return RecreateFramesForContent(mPresShell->GetDocument()->GetRootElement(),
 80486: 				  true);
     1: }
     1: 
 11845: void
 42349: nsCSSFrameConstructor::RestyleForEmptyChange(Element* aContainer)
 42349: {
 42349:   // In some cases (:empty + E, :empty ~ E), a change if the content of
 43794:   // an element requires restyling its parent's siblings.
 43793:   nsRestyleHint hint = eRestyle_Subtree;
 42349:   nsIContent* grandparent = aContainer->GetParent();
 42349:   if (grandparent &&
 42350:       (grandparent->GetFlags() & NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS)) {
 42350:     hint = nsRestyleHint(hint | eRestyle_LaterSiblings);
 42350:   }
 42350:   PostRestyleEvent(aContainer, hint, NS_STYLE_HINT_NONE);
 42349: }
 42349: 
 42349: void
 42324: nsCSSFrameConstructor::RestyleForAppend(Element* aContainer,
 42324:                                         nsIContent* aFirstNewContent)
 11845: {
 11845:   NS_ASSERTION(aContainer, "must have container for append");
 15302: #ifdef DEBUG
 15302:   {
 42324:     for (nsIContent* cur = aFirstNewContent; cur; cur = cur->GetNextSibling()) {
 42324:       NS_ASSERTION(!cur->IsRootOfAnonymousSubtree(),
 16128:                    "anonymous nodes should not be in child lists");
 15302:     }
 15302:   }
 15302: #endif
108991:   uint32_t selectorFlags =
 11845:     aContainer->GetFlags() & (NODE_ALL_SELECTOR_FLAGS &
 42350:                               ~NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS);
 11845:   if (selectorFlags == 0)
 11845:     return;
 11845: 
 11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
 11845:     // see whether we need to restyle the container
 79445:     bool wasEmpty = true; // :empty or :-moz-only-whitespace
 42324:     for (nsIContent* cur = aContainer->GetFirstChild();
 42324:          cur != aFirstNewContent;
 42324:          cur = cur->GetNextSibling()) {
 11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
 11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
 11845:       // IsSignificantChild less likely to be true, and thus make us more
 11845:       // likely to restyle).
 80486:       if (nsStyleUtil::IsSignificantChild(cur, true, false)) {
 80486:         wasEmpty = false;
 11845:         break;
 11845:       }
 11845:     }
 11845:     if (wasEmpty) {
 42349:       RestyleForEmptyChange(aContainer);
 42349:       return;
 42349:     }
 42349:   }
 42349: 
 42349:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
 43793:     PostRestyleEvent(aContainer, eRestyle_Subtree, NS_STYLE_HINT_NONE);
 11845:     // Restyling the container is the most we can do here, so we're done.
 11845:     return;
 11845:   }
 42349: 
 11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
 11845:     // restyle the last element child before this node
 42324:     for (nsIContent* cur = aFirstNewContent->GetPreviousSibling();
 42324:          cur;
 42324:          cur = cur->GetPreviousSibling()) {
 42324:       if (cur->IsElement()) {
 43793:         PostRestyleEvent(cur->AsElement(), eRestyle_Subtree, NS_STYLE_HINT_NONE);
 11845:         break;
 11845:       }
 11845:     }
 11845:   }
 11845: }
 11845: 
 42350: // Needed since we can't use PostRestyleEvent on non-elements (with
 43793: // eRestyle_LaterSiblings or nsRestyleHint(eRestyle_Subtree |
 42350: // eRestyle_LaterSiblings) as appropriate).
 42350: static void
 42350: RestyleSiblingsStartingWith(nsCSSFrameConstructor *aFrameConstructor,
 42350:                             nsIContent *aStartingSibling /* may be null */)
 42350: {
 43792:   for (nsIContent *sibling = aStartingSibling; sibling;
 43792:        sibling = sibling->GetNextSibling()) {
 43792:     if (sibling->IsElement()) {
 43792:       aFrameConstructor->
 43792:         PostRestyleEvent(sibling->AsElement(),
 43793:                          nsRestyleHint(eRestyle_Subtree | eRestyle_LaterSiblings),
 42350:                          NS_STYLE_HINT_NONE);
 43792:       break;
 42350:     }
 42350:   }
 42350: }
 42350: 
 11845: // Restyling for a ContentInserted or CharacterDataChanged notification.
 11845: // This could be used for ContentRemoved as well if we got the
 11845: // notification before the removal happened (and sometimes
 11845: // CharacterDataChanged is more like a removal than an addition).
 11845: // The comments are written and variables are named in terms of it being
 11845: // a ContentInserted notification.
 11845: void
 42324: nsCSSFrameConstructor::RestyleForInsertOrChange(Element* aContainer,
 11845:                                                 nsIContent* aChild)
 11845: {
 16128:   NS_ASSERTION(!aChild->IsRootOfAnonymousSubtree(),
 16128:                "anonymous nodes should not be in child lists");
108991:   uint32_t selectorFlags =
 11845:     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
 11845:   if (selectorFlags == 0)
 11845:     return;
 11845: 
 11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
 11845:     // see whether we need to restyle the container
 79445:     bool wasEmpty = true; // :empty or :-moz-only-whitespace
 42324:     for (nsIContent* child = aContainer->GetFirstChild();
 42324:          child;
 42324:          child = child->GetNextSibling()) {
 11845:       if (child == aChild)
 11845:         continue;
 11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
 11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
 11845:       // IsSignificantChild less likely to be true, and thus make us more
 11845:       // likely to restyle).
 80486:       if (nsStyleUtil::IsSignificantChild(child, true, false)) {
 80486:         wasEmpty = false;
 11845:         break;
 11845:       }
 11845:     }
 11845:     if (wasEmpty) {
 42349:       RestyleForEmptyChange(aContainer);
 42349:       return;
 42349:     }
 42349:   }
 42349: 
 42350:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
 43793:     PostRestyleEvent(aContainer, eRestyle_Subtree, NS_STYLE_HINT_NONE);
 11845:     // Restyling the container is the most we can do here, so we're done.
 11845:     return;
 11845:   }
 11845: 
 42350:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS) {
 42350:     // Restyle all later siblings.
 42350:     RestyleSiblingsStartingWith(this, aChild->GetNextSibling());
 42350:   }
 42350: 
 11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
 11845:     // restyle the previously-first element child if it is after this node
 79445:     bool passedChild = false;
 42324:     for (nsIContent* content = aContainer->GetFirstChild();
 42324:          content;
 42324:          content = content->GetNextSibling()) {
 11845:       if (content == aChild) {
 80486:         passedChild = true;
 11845:         continue;
 11845:       }
 41640:       if (content->IsElement()) {
 11845:         if (passedChild) {
 43793:           PostRestyleEvent(content->AsElement(), eRestyle_Subtree,
 42324:                            NS_STYLE_HINT_NONE);
 11845:         }
 11845:         break;
 11845:       }
 11845:     }
 11845:     // restyle the previously-last element child if it is before this node
 80486:     passedChild = false;
 42324:     for (nsIContent* content = aContainer->GetLastChild();
 42324:          content;
 42324:          content = content->GetPreviousSibling()) {
 11845:       if (content == aChild) {
 80486:         passedChild = true;
 11845:         continue;
 11845:       }
 41640:       if (content->IsElement()) {
 11845:         if (passedChild) {
 43793:           PostRestyleEvent(content->AsElement(), eRestyle_Subtree,
 42324:                            NS_STYLE_HINT_NONE);
 11845:         }
 11845:         break;
 11845:       }
 11845:     }
 11845:   }
 11845: }
 11845: 
 11845: void
 42324: nsCSSFrameConstructor::RestyleForRemove(Element* aContainer,
 11845:                                         nsIContent* aOldChild,
 42324:                                         nsIContent* aFollowingSibling)
 11845: {
 98841:   if (aOldChild->IsRootOfAnonymousSubtree()) {
 98841:     // This should be an assert, but this is called incorrectly in
 98841:     // nsHTMLEditor::DeleteRefToAnonymousNode and the assertions were clogging
 98841:     // up the logs.  Make it an assert again when that's fixed.
 98841:     NS_WARNING("anonymous nodes should not be in child lists (bug 439258)");
 98841:   }
108991:   uint32_t selectorFlags =
 11845:     aContainer ? (aContainer->GetFlags() & NODE_ALL_SELECTOR_FLAGS) : 0;
 11845:   if (selectorFlags == 0)
 11845:     return;
 11845: 
 11845:   if (selectorFlags & NODE_HAS_EMPTY_SELECTOR) {
 11845:     // see whether we need to restyle the container
 79445:     bool isEmpty = true; // :empty or :-moz-only-whitespace
 42324:     for (nsIContent* child = aContainer->GetFirstChild();
 42324:          child;
 42324:          child = child->GetNextSibling()) {
 11845:       // We don't know whether we're testing :empty or :-moz-only-whitespace,
 11845:       // so be conservative and assume :-moz-only-whitespace (i.e., make
 11845:       // IsSignificantChild less likely to be true, and thus make us more
 11845:       // likely to restyle).
 80486:       if (nsStyleUtil::IsSignificantChild(child, true, false)) {
 80486:         isEmpty = false;
 11845:         break;
 11845:       }
 11845:     }
 11845:     if (isEmpty) {
 42349:       RestyleForEmptyChange(aContainer);
 42349:       return;
 42349:     }
 42349:   }
 42349: 
 42350:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR) {
 43793:     PostRestyleEvent(aContainer, eRestyle_Subtree, NS_STYLE_HINT_NONE);
 11845:     // Restyling the container is the most we can do here, so we're done.
 11845:     return;
 11845:   }
 11845: 
 42350:   if (selectorFlags & NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS) {
 42350:     // Restyle all later siblings.
 42350:     RestyleSiblingsStartingWith(this, aFollowingSibling);
 42350:   }
 42350: 
 11845:   if (selectorFlags & NODE_HAS_EDGE_CHILD_SELECTOR) {
 42324:     // restyle the now-first element child if it was after aOldChild
 79445:     bool reachedFollowingSibling = false;
 42324:     for (nsIContent* content = aContainer->GetFirstChild();
 42324:          content;
 42324:          content = content->GetNextSibling()) {
 42324:       if (content == aFollowingSibling) {
 80486:         reachedFollowingSibling = true;
 42324:         // do NOT continue here; we might want to restyle this node
 42324:       }
 41640:       if (content->IsElement()) {
 42324:         if (reachedFollowingSibling) {
 43793:           PostRestyleEvent(content->AsElement(), eRestyle_Subtree,
 42324:                            NS_STYLE_HINT_NONE);
 11845:         }
 11845:         break;
 11845:       }
 11845:     }
 42324:     // restyle the now-last element child if it was before aOldChild
106838:     reachedFollowingSibling = (aFollowingSibling == nullptr);
 42324:     for (nsIContent* content = aContainer->GetLastChild();
 42324:          content;
 42324:          content = content->GetPreviousSibling()) {
 41640:       if (content->IsElement()) {
 42324:         if (reachedFollowingSibling) {
 43793:           PostRestyleEvent(content->AsElement(), eRestyle_Subtree, NS_STYLE_HINT_NONE);
 11845:         }
 11845:         break;
 11845:       }
 42324:       if (content == aFollowingSibling) {
 80486:         reachedFollowingSibling = true;
 42324:       }
 11845:     }
 11845:   }
 11845: }
 11845: 
 11845: 
     1: void
 11409: nsCSSFrameConstructor::RebuildAllStyleData(nsChangeHint aExtraHint)
 11409: {
 11409:   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
 11409:                "Should not reconstruct the root of the frame tree.  "
 11409:                "Use ReconstructDocElementHierarchy instead.");
 11409: 
 80486:   mRebuildAllStyleData = false;
 22339:   NS_UpdateHint(aExtraHint, mRebuildAllExtraHint);
 22339:   mRebuildAllExtraHint = nsChangeHint(0);
 10073: 
 35581:   if (!mPresShell || !mPresShell->GetRootFrame())
 10073:     return;
 10073: 
 23652:   // Make sure that the viewmanager will outlive the presshell
127608:   nsRefPtr<nsViewManager> vm = mPresShell->GetViewManager();
 23652: 
 21202:   // Processing the style changes could cause a flush that propagates to
 21202:   // the parent frame and thus destroys the pres shell.
 21202:   nsCOMPtr<nsIPresShell> kungFuDeathGrip(mPresShell);
 21202: 
 36817:   // We may reconstruct frames below and hence process anything that is in the
 36817:   // tree. We don't want to get notified to process those items again after.
 36817:   mPresShell->GetDocument()->FlushPendingNotifications(Flush_ContentAndNotify);
 36817: 
 36817:   nsAutoScriptBlocker scriptBlocker;
 36817: 
120183:   nsPresContext *presContext = mPresShell->GetPresContext();
120183:   presContext->SetProcessingRestyles(true);
120183: 
120183:   DoRebuildAllStyleData(mPendingRestyles, aExtraHint);
120183: 
120183:   presContext->SetProcessingRestyles(false);
120183: 
120183:   // Make sure that we process any pending animation restyles from the
120183:   // above style change.  Note that we can *almost* implement the above
120183:   // by just posting a style change -- except we really need to restyle
120183:   // the root frame rather than the root element's primary frame.
120183:   ProcessPendingRestyles();
120183: }
120183: 
120183: void
120183: nsCSSFrameConstructor::DoRebuildAllStyleData(RestyleTracker& aRestyleTracker,
120183:                                              nsChangeHint aExtraHint)
120183: {
 10073:   // Tell the style set to get the old rule tree out of the way
 10073:   // so we can recalculate while maintaining rule tree immutability
 10073:   nsresult rv = mPresShell->StyleSet()->BeginReconstruct();
 23652:   if (NS_FAILED(rv)) {
 10073:     return;
 23652:   }
 10073: 
 10073:   // Recalculate all of the style contexts for the document
 10073:   // Note that we can ignore the return value of ComputeStyleChangeFor
 10073:   // because we never need to reframe the root frame
 10073:   // XXX This could be made faster by not rerunning rule matching
 10073:   // (but note that nsPresShell::SetPreferenceStyleRules currently depends
 10073:   // on us re-running rule matching here
 10073:   nsStyleChangeList changeList;
 11409:   // XXX Does it matter that we're passing aExtraHint to the real root
 11409:   // frame and not the root node's primary frame?
 43790:   // Note: The restyle tracker we pass in here doesn't matter.
 89328:   ComputeStyleChangeFor(mPresShell->GetRootFrame(),
 43790:                         &changeList, aExtraHint,
120183:                         aRestyleTracker, true);
 10073:   // Process the required changes
133599:   ProcessRestyledFrames(changeList);
133599:   FlushOverflowChangedTracker();
 64401: 
 10073:   // Tell the style set it's safe to destroy the old rule tree.  We
 10073:   // must do this after the ProcessRestyledFrames call in case the
 10073:   // change list has frame reconstructs in it (since frames to be
 10073:   // reconstructed will still have their old style context pointers
 10073:   // until they are destroyed).
 10073:   mPresShell->StyleSet()->EndReconstruct();
 10073: }
 10073: 
 10073: void
 32401: nsCSSFrameConstructor::ProcessPendingRestyles()
 32401: {
 38816:   NS_PRECONDITION(mDocument, "No document?  Pshaw!");
 32401:   NS_PRECONDITION(!nsContentUtils::IsSafeToRunScript(),
 32401:                   "Missing a script blocker!");
 32401: 
 32401:   // Process non-animation restyles...
 38816:   nsPresContext *presContext = mPresShell->GetPresContext();
 38816:   NS_ABORT_IF_FALSE(!presContext->IsProcessingRestyles(),
 38816:                     "Nesting calls to ProcessPendingRestyles?");
 80486:   presContext->SetProcessingRestyles(true);
 38816: 
125555:   // Before we process any restyles, we need to ensure that style
125555:   // resulting from any throttled animations (animations that we're
125555:   // running entirely on the compositor thread) is up-to-date, so that
125555:   // if any style changes we cause trigger transitions, we have the
125555:   // correct old style for starting the transition.
125555:   if (css::CommonAnimationManager::ThrottlingEnabled() &&
125555:       mPendingRestyles.Count() > 0) {
125555:     ++mAnimationGeneration;
125555:     presContext->TransitionManager()->UpdateAllThrottledStyles();
125555:   }
125555: 
 43788:   mPendingRestyles.ProcessRestyles();
 32401: 
 40125: #ifdef DEBUG
108991:   uint32_t oldPendingRestyleCount = mPendingRestyles.Count();
 40125: #endif
 36797: 
 32401:   // ...and then process animation restyles.  This needs to happen
 32401:   // second because we need to start animations that resulted from the
 32401:   // first set of restyles (e.g., CSS transitions with negative
 32401:   // transition-delay), and because we need to immediately
 32401:   // restyle-with-animation any just-restyled elements that are
 32401:   // mid-transition (since processing the non-animation restyle ignores
 32401:   // the running transition so it can check for a new change on the same
 32401:   // property, and then posts an immediate animation style change).
 80486:   presContext->SetProcessingAnimationStyleChange(true);
 43788:   mPendingAnimationRestyles.ProcessRestyles();
 80486:   presContext->SetProcessingAnimationStyleChange(false);
 80486: 
 80486:   presContext->SetProcessingRestyles(false);
 40125:   NS_POSTCONDITION(mPendingRestyles.Count() == oldPendingRestyleCount,
 36797:                    "We should not have posted new non-animation restyles while "
 36797:                    "processing animation restyles");
 36797: 
 10073:   if (mRebuildAllStyleData) {
 10073:     // We probably wasted a lot of work up above, but this seems safest
 10073:     // and it should be rarely used.
 36797:     // This might add us as a refresh observer again; that's ok.
 11409:     RebuildAllStyleData(nsChangeHint(0));
 10073:   }
     1: }
     1: 
     1: void
 42328: nsCSSFrameConstructor::PostRestyleEventCommon(Element* aElement,
 40075:                                               nsRestyleHint aRestyleHint,
 32401:                                               nsChangeHint aMinChangeHint,
 79445:                                               bool aForAnimation)
     1: {
120353:   if (MOZ_UNLIKELY(mPresShell->IsDestroying())) {
 10402:     return;
 10402:   }
 10402: 
     1:   if (aRestyleHint == 0 && !aMinChangeHint) {
     1:     // Nothing to do here
     1:     return;
     1:   }
     1: 
 43788:   RestyleTracker& tracker =
 32401:     aForAnimation ? mPendingAnimationRestyles : mPendingRestyles;
 43788:   tracker.AddPendingRestyle(aElement, aRestyleHint, aMinChangeHint);
     1: 
 80486:   PostRestyleEventInternal(false);
 22339: }
 22339:     
 22339: void
 79445: nsCSSFrameConstructor::PostRestyleEventInternal(bool aForLazyConstruction)
 22339: {
 36797:   // Make sure we're not in a style refresh; if we are, we still have
 36797:   // a call to ProcessPendingRestyles coming and there's no need to
 36797:   // add ourselves as a refresh observer until then.
 79445:   bool inRefresh = !aForLazyConstruction && mInStyleRefresh;
 40938:   if (!mObservingRefreshDriver && !inRefresh) {
 50365:     mObservingRefreshDriver = mPresShell->GetPresContext()->RefreshDriver()->
 50365:       AddStyleFlushObserver(mPresShell);
 50365:   }
 84597: 
 84597:   // Unconditionally flag our document as needing a flush.  The other
 84597:   // option here would be a dedicated boolean to track whether we need
 84597:   // to do so (set here and unset in ProcessPendingRestyles).
 84597:   mPresShell->GetDocument()->SetNeedStyleFlush();
     1: }
     1: 
 10073: void
 22339: nsCSSFrameConstructor::PostRebuildAllStyleDataEvent(nsChangeHint aExtraHint)
 22339: {
 22339:   NS_ASSERTION(!(aExtraHint & nsChangeHint_ReconstructFrame),
 22339:                "Should not reconstruct the root of the frame tree.  "
 22339:                "Use ReconstructDocElementHierarchy instead.");
 22339: 
 80486:   mRebuildAllStyleData = true;
 22339:   NS_UpdateHint(mRebuildAllExtraHint, aExtraHint);
 10073:   // Get a restyle event posted if necessary
 80486:   PostRestyleEventInternal(false);
 10073: }
 10073: 
 52061: nsresult
 52061: nsCSSFrameConstructor::GenerateChildFrames(nsIFrame* aFrame)
 52061: {
 23256:   {
 23256:     nsAutoScriptBlocker scriptBlocker;
 52061:     BeginUpdate();
  6518: 
  3129:     nsFrameItems childItems;
106838:     nsFrameConstructorState state(mPresShell, nullptr, nullptr, nullptr);
 34614:     // We don't have a parent frame with a pending binding constructor here,
 34614:     // so no need to worry about ordering of the kids' constructors with it.
 34614:     // Pass null for the PendingBinding.
132768:     nsresult rv = ProcessChildren(state, aFrame->GetContent(), aFrame->StyleContext(),
 80486:                                   aFrame, false, childItems, false,
106838:                                   nullptr);
 23652:     if (NS_FAILED(rv)) {
 52061:       EndUpdate();
 23652:       return rv;
 23652:     }
 23167: 
 77155:     aFrame->SetInitialChildList(kPrincipalList, childItems);
 52061: 
 52061:     EndUpdate();
 52061:   }
  3129: 
 62502: #ifdef ACCESSIBILITY
 62502:   nsAccessibilityService* accService = nsIPresShell::AccService();
 62502:   if (accService) {
 62502:     nsIContent* container = aFrame->GetContent();
 62502:     nsIContent* child = container->GetFirstChild();
 62502:     if (child) {
106838:       accService->ContentRangeInserted(mPresShell, container, child, nullptr);
 62502:     }
 62502:   }
 62502: #endif
 62502: 
  3129:   // call XBL constructors after the frames are created
  3129:   mPresShell->GetDocument()->BindingManager()->ProcessAttachedQueue();
  3129: 
  3129:   return NS_OK;
  3129: }
 26208: 
 27311: //////////////////////////////////////////////////////////
 27311: // nsCSSFrameConstructor::FrameConstructionItem methods //
 27311: //////////////////////////////////////////////////////////
 79445: bool
 41931: nsCSSFrameConstructor::
 41931: FrameConstructionItem::IsWhitespace(nsFrameConstructorState& aState) const
 41931: {
 56439:   NS_PRECONDITION(aState.mCreatingExtraFrames ||
 41931:                   !mContent->GetPrimaryFrame(), "How did that happen?");
 27311:   if (!mIsText) {
 80486:     return false;
 27311:   }
 29809:   mContent->SetFlags(NS_CREATE_FRAME_IF_NON_WHITESPACE |
 29809:                      NS_REFRAME_IF_WHITESPACE);
 27311:   return mContent->TextIsOnlyWhitespace();
 27311: }
 27311: 
 26208: //////////////////////////////////////////////////////////////
 26208: // nsCSSFrameConstructor::FrameConstructionItemList methods //
 26208: //////////////////////////////////////////////////////////////
 26208: void
 26208: nsCSSFrameConstructor::FrameConstructionItemList::
108991: AdjustCountsForItem(FrameConstructionItem* aItem, int32_t aDelta)
 26208: {
 26208:   NS_PRECONDITION(aDelta == 1 || aDelta == -1, "Unexpected delta");
 26208:   mItemCount += aDelta;
 26208:   if (aItem->mIsAllInline) {
 26208:     mInlineCount += aDelta;
 26208:   }
 34462:   if (aItem->mIsBlock) {
 34462:     mBlockCount += aDelta;
 34462:   }
 29075:   if (aItem->mIsLineParticipant) {
 26208:     mLineParticipantCount += aDelta;
 26208:   }
 26208:   mDesiredParentCounts[aItem->DesiredParentType()] += aDelta;
 26208: }
 26208: 
 26208: ////////////////////////////////////////////////////////////////////////
 26208: // nsCSSFrameConstructor::FrameConstructionItemList::Iterator methods //
 26208: ////////////////////////////////////////////////////////////////////////
 79445: inline bool
 27311: nsCSSFrameConstructor::FrameConstructionItemList::
 27311: Iterator::SkipItemsWantingParentType(ParentType aParentType)
 27311: {
 27311:   NS_PRECONDITION(!IsDone(), "Shouldn't be done yet");
 27311:   while (item().DesiredParentType() == aParentType) {
 27311:     Next();
 27311:     if (IsDone()) {
 80486:       return true;
 80486:     }
 80486:   }
 80486:   return false;
 27311: }
 27311: 
103018: #ifdef MOZ_FLEXBOX
103018: bool
103018: nsCSSFrameConstructor::FrameConstructionItem::
103018:   NeedsAnonFlexItem(const nsFrameConstructorState& aState)
103018: {
103018:   if (mFCData->mBits & FCDATA_IS_LINE_PARTICIPANT) {
103018:     // This will be an inline non-replaced box.
103018:     return true;
103018:   }
103018: 
103018:   if (!(mFCData->mBits & FCDATA_DISALLOW_OUT_OF_FLOW) &&
132812:       aState.GetGeometricParent(mStyleContext->StyleDisplay(), nullptr)) {
103018:     // We're abspos or fixedpos, which means we'll spawn a placeholder which
103018:     // we'll need to wrap in an anonymous flex item.  So, we just treat
103018:     // _this_ frame as if _it_ needs to be wrapped in an anonymous flex item,
103018:     // and then when we spawn the placeholder, it'll end up in the right spot.
103018:     return true;
103018:   }
103018: 
103018:   return false;
103018: }
103018: 
103018: inline bool
103018: nsCSSFrameConstructor::FrameConstructionItemList::
103018: Iterator::SkipItemsThatNeedAnonFlexItem(
103018:   const nsFrameConstructorState& aState)
103018: {
103018:   NS_PRECONDITION(!IsDone(), "Shouldn't be done yet");
103018:   while (item().NeedsAnonFlexItem(aState)) {
103018:     Next();
103018:     if (IsDone()) {
103018:       return true;
103018:     }
103018:   }
103018:   return false;
103018: }
103018: 
103018: inline bool
103018: nsCSSFrameConstructor::FrameConstructionItemList::
103018: Iterator::SkipItemsThatDontNeedAnonFlexItem(
103018:   const nsFrameConstructorState& aState)
103018: {
103018:   NS_PRECONDITION(!IsDone(), "Shouldn't be done yet");
103018:   while (!(item().NeedsAnonFlexItem(aState))) {
103018:     Next();
103018:     if (IsDone()) {
103018:       return true;
103018:     }
103018:   }
103018:   return false;
103018: }
103018: #endif // MOZ_FLEXBOX
103018: 
 79445: inline bool
 27311: nsCSSFrameConstructor::FrameConstructionItemList::
 41931: Iterator::SkipWhitespace(nsFrameConstructorState& aState)
 27311: {
 27311:   NS_PRECONDITION(!IsDone(), "Shouldn't be done yet");
 41931:   NS_PRECONDITION(item().IsWhitespace(aState), "Not pointing to whitespace?");
 27311:   do {
 27311:     Next();
 27311:     if (IsDone()) {
 80486:       return true;
 27311:     }
 41931:   } while (item().IsWhitespace(aState));
 27311: 
 80486:   return false;
 27311: }
 27311: 
 26208: void
 26208: nsCSSFrameConstructor::FrameConstructionItemList::
 26208: Iterator::AppendItemToList(FrameConstructionItemList& aTargetList)
 26208: {
 26208:   NS_ASSERTION(&aTargetList != &mList, "Unexpected call");
 26208:   NS_PRECONDITION(!IsDone(), "should not be done");
 26208: 
 26208:   FrameConstructionItem* item = ToItem(mCurrent);
 26208:   Next();
 26208:   PR_REMOVE_LINK(item);
 26208:   PR_APPEND_LINK(item, &aTargetList.mItems);
 26208: 
 26208:   mList.AdjustCountsForItem(item, -1);
 26208:   aTargetList.AdjustCountsForItem(item, 1);
 26208: }
 26208: 
 26208: void
 26208: nsCSSFrameConstructor::FrameConstructionItemList::
 26208: Iterator::AppendItemsToList(const Iterator& aEnd,
 26208:                             FrameConstructionItemList& aTargetList)
 26208: {
 26208:   NS_ASSERTION(&aTargetList != &mList, "Unexpected call");
 26208:   NS_PRECONDITION(mEnd == aEnd.mEnd, "end iterator for some other list?");
 26208: 
 93524:   // We can't just move our guts to the other list if it already has
 93524:   // some information or if we're not moving our entire list.
 93524:   if (!AtStart() || !aEnd.IsDone() || !aTargetList.IsEmpty() ||
 93524:       !aTargetList.mUndisplayedItems.IsEmpty()) {
 26208:     do {
 26208:       AppendItemToList(aTargetList);
 26208:     } while (*this != aEnd);
 26208:     return;
 26208:   }
 26208: 
 26208:   // move over the list of items
 26208:   PR_INSERT_AFTER(&aTargetList.mItems, &mList.mItems);
 93524:   // Need to init when we remove to makd ~FrameConstructionItemList work right.
 93524:   PR_REMOVE_AND_INIT_LINK(&mList.mItems);
 26208: 
 26208:   // Copy over the various counters
 26208:   aTargetList.mInlineCount = mList.mInlineCount;
 34462:   aTargetList.mBlockCount = mList.mBlockCount;
 26208:   aTargetList.mLineParticipantCount = mList.mLineParticipantCount;
 26208:   aTargetList.mItemCount = mList.mItemCount;
 26208:   memcpy(aTargetList.mDesiredParentCounts, mList.mDesiredParentCounts,
 26208:          sizeof(aTargetList.mDesiredParentCounts));
 26208: 
 93524:   // Swap out undisplayed item arrays, before we nuke the array on our end
 93524:   aTargetList.mUndisplayedItems.SwapElements(mList.mUndisplayedItems);
 93524: 
 26208:   // reset mList
 93524:   mList.~FrameConstructionItemList();
 26208:   new (&mList) FrameConstructionItemList();
 26208: 
 26208:   // Point ourselves to aEnd, as advertised
 26208:   mCurrent = mEnd = &mList.mItems;
 26208:   NS_POSTCONDITION(*this == aEnd, "How did that happen?");
 26208: }
 26208: 
 26208: void
 26208: nsCSSFrameConstructor::FrameConstructionItemList::
 26208: Iterator::InsertItem(FrameConstructionItem* aItem)
 26208: {
 26208:   // Just insert the item before us.  There's no magic here.
 26208:   PR_INSERT_BEFORE(aItem, mCurrent);
 26208:   mList.AdjustCountsForItem(aItem, 1);
 26208: 
 26208:   NS_POSTCONDITION(PR_NEXT_LINK(aItem) == mCurrent, "How did that happen?");
 26208: }
 26208: 
 26208: void
 27311: nsCSSFrameConstructor::FrameConstructionItemList::
 27311: Iterator::DeleteItemsTo(const Iterator& aEnd)
 27311: {
 27311:   NS_PRECONDITION(mEnd == aEnd.mEnd, "end iterator for some other list?");
 27311:   NS_PRECONDITION(*this != aEnd, "Shouldn't be at aEnd yet");
 27311: 
 27311:   do {
 27311:     NS_ASSERTION(!IsDone(), "Ran off end of list?");
 26208:     FrameConstructionItem* item = ToItem(mCurrent);
 26208:     Next();
 26208:     PR_REMOVE_LINK(item);
 26208:     mList.AdjustCountsForItem(item, -1);
 26208:     delete item;
 27311:   } while (*this != aEnd);
 27311: }
101252: 
101252: bool
101252: nsCSSFrameConstructor::RecomputePosition(nsIFrame* aFrame)
101252: {
103122:   // Don't process position changes on table frames, since we already handle
103122:   // the dynamic position change on the outer table frame, and the reflow-based
103122:   // fallback code path also ignores positions on inner table frames.
103122:   if (aFrame->GetType() == nsGkAtoms::tableFrame) {
103122:     return true;
103122:   }
103122: 
110644:   // Don't process position changes on frames which have views or the ones which
110644:   // have a view somewhere in their descendants, because the corresponding view
110644:   // needs to be repositioned properly as well.
110644:   if (aFrame->HasView() ||
110644:       (aFrame->GetStateBits() & NS_FRAME_HAS_CHILD_WITH_VIEW)) {
110644:     StyleChangeReflow(aFrame, nsChangeHint_NeedReflow);
110644:     return false;
110644:   }
110644: 
132812:   const nsStyleDisplay* display = aFrame->StyleDisplay();
101252:   // Changes to the offsets of a non-positioned element can safely be ignored.
101252:   if (display->mPosition == NS_STYLE_POSITION_STATIC) {
101252:     return true;
101252:   }
101252: 
115305:   aFrame->SchedulePaint();
115305: 
101252:   // For relative positioning, we can simply update the frame rect
101252:   if (display->mPosition == NS_STYLE_POSITION_RELATIVE) {
101252:     nsIFrame* cb = aFrame->GetContainingBlock();
101252:     const nsSize size = cb->GetSize();
101252:     const nsPoint oldOffsets = aFrame->GetRelativeOffset();
101252:     nsMargin newOffsets;
101252: 
101252:     // Move the frame
101252:     nsHTMLReflowState::ComputeRelativeOffsets(
132812:         cb->StyleVisibility()->mDirection,
101252:         aFrame, size.width, size.height, newOffsets);
101252:     NS_ASSERTION(newOffsets.left == -newOffsets.right &&
101252:                  newOffsets.top == -newOffsets.bottom,
101252:                  "ComputeRelativeOffsets should return valid results");
101252:     aFrame->SetPosition(aFrame->GetPosition() - oldOffsets +
101252:                         nsPoint(newOffsets.left, newOffsets.top));
101252: 
101252:     return true;
101252:   }
101252: 
101252:   // For absolute positioning, the width can potentially change if width is
101252:   // auto and either of left or right are not.  The height can also potentially
101252:   // change if height is auto and either of top or bottom are not.  In these
101252:   // cases we fall back to a reflow, and in all other cases, we attempt to
101252:   // move the frame here.
101252:   // Note that it is possible for the dimensions to not change in the above
101252:   // cases, so we should be a little smarter here and only fall back to reflow
101252:   // when the dimensions will really change (bug 745485).
132812:   const nsStylePosition* position = aFrame->StylePosition();
101252:   if (position->mWidth.GetUnit() != eStyleUnit_Auto &&
101252:       position->mHeight.GetUnit() != eStyleUnit_Auto) {
101252:     // For the absolute positioning case, set up a fake HTML reflow state for
101252:     // the frame, and then get the offsets from it.
101252:     nsRefPtr<nsRenderingContext> rc = aFrame->PresContext()->GetPresShell()->
101252:       GetReferenceRenderingContext();
101252: 
101252:     // Construct a bogus parent reflow state so that there's a usable
101252:     // containing block reflow state.
101252:     nsIFrame *parentFrame = aFrame->GetParent();
101252:     nsSize parentSize = parentFrame->GetSize();
101252: 
101252:     nsFrameState savedState = parentFrame->GetStateBits();
101252:     nsHTMLReflowState parentReflowState(aFrame->PresContext(), parentFrame,
101252:                                         rc, parentSize);
101252:     parentFrame->RemoveStateBits(~nsFrameState(0));
101252:     parentFrame->AddStateBits(savedState);
101252: 
104068:     NS_WARN_IF_FALSE(parentSize.width != NS_INTRINSICSIZE &&
101252:                      parentSize.height != NS_INTRINSICSIZE,
101252:                      "parentSize should be valid");
129543:     parentReflowState.SetComputedWidth(std::max(parentSize.width, 0));
129543:     parentReflowState.SetComputedHeight(std::max(parentSize.height, 0));
101252:     parentReflowState.mComputedMargin.SizeTo(0, 0, 0, 0);
101252:     parentSize.height = NS_AUTOHEIGHT;
101252: 
101252:     parentReflowState.mComputedPadding = parentFrame->GetUsedPadding();
101252:     parentReflowState.mComputedBorderPadding =
101252:       parentFrame->GetUsedBorderAndPadding();
101252: 
101252:     nsSize availSize(parentSize.width, NS_INTRINSICSIZE);
101252: 
101252:     nsSize size = aFrame->GetSize();
101252:     nsSize cbSize = aFrame->GetContainingBlock()->GetSize();
101252:     const nsMargin& parentBorder =
101252:       parentReflowState.mStyleBorder->GetComputedBorder();
101252:     cbSize -= nsSize(parentBorder.LeftRight(), parentBorder.TopBottom());
101252:     nsHTMLReflowState reflowState(aFrame->PresContext(), parentReflowState,
101252:                                   aFrame, availSize, cbSize.width,
101252:                                   cbSize.height);
101252: 
101252:     // If we're solving for 'left' or 'top', then compute it here, in order to
101252:     // match the reflow code path.
101252:     if (NS_AUTOOFFSET == reflowState.mComputedOffsets.left) {
101252:       reflowState.mComputedOffsets.left = cbSize.width -
101252:                                           reflowState.mComputedOffsets.right -
101252:                                           reflowState.mComputedMargin.right -
101252:                                           size.width -
101252:                                           reflowState.mComputedMargin.left;
101252:     }
101252: 
101252:     if (NS_AUTOOFFSET == reflowState.mComputedOffsets.top) {
101252:       reflowState.mComputedOffsets.top = cbSize.height -
101252:                                          reflowState.mComputedOffsets.bottom -
101252:                                          reflowState.mComputedMargin.bottom -
101252:                                          size.height -
101252:                                          reflowState.mComputedMargin.top;
101252:     }
101252:     
101252:     // Move the frame
101252:     nsPoint pos(parentBorder.left + reflowState.mComputedOffsets.left +
101252:                 reflowState.mComputedMargin.left,
101252:                 parentBorder.top + reflowState.mComputedOffsets.top +
101252:                 reflowState.mComputedMargin.top);
101252:     aFrame->SetPosition(pos);
101252: 
101252:     return true;
101252:   }
101252: 
101252:   // Fall back to a reflow
101252:   StyleChangeReflow(aFrame, nsChangeHint_NeedReflow);
101252:   return false;
101252: }
