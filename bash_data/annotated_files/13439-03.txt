    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *   Masatoshi Kimura <VYV03354@nifty.ne.jp>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "gfxWindowsPlatform.h"
    1: 
    1: #include "gfxImageSurface.h"
    1: #include "gfxWindowsSurface.h"
    1: 
    1: #include "nsUnicharUtils.h"
    1: 
    1: #include "nsIPref.h"
    1: #include "nsServiceManagerUtils.h"
    1: 
    1: #include "nsIWindowsRegKey.h"
    1: 
  270: #include "gfxWindowsFonts.h"
  270: 
    1: #include <string>
    1: 
 3787: #include "lcms.h"
 3787: 
 1959: //#define DEBUG_CMAP_SIZE 1
 1959: 
13280: static nsresult ReadCMAP(HDC hdc, FontEntry *aFontEntry);
13280: 
 5254: int PR_CALLBACK
 5254: gfxWindowsPlatform::PrefChangedCallback(const char *aPrefName, void *closure)
 5254: {
 5259:     // XXX this could be made to only clear out the cache for the prefs that were changed
 5259:     // but it probably isn't that big a deal.
 5254:     gfxWindowsPlatform *plat = static_cast<gfxWindowsPlatform *>(closure);
 5254:     plat->mPrefFonts.Clear();
 5254:     return 0;
 5254: }
 1959: 
    1: gfxWindowsPlatform::gfxWindowsPlatform()
    1: {
    1:     mFonts.Init(200);
    1:     mFontAliases.Init(20);
    1:     mFontSubstitutes.Init(50);
 5254:     mPrefFonts.Init(10);
 5254: 
    1:     UpdateFontList();
 5254: 
 5254:     nsCOMPtr<nsIPref> pref = do_GetService(NS_PREF_CONTRACTID);
 5254:     pref->RegisterCallback("font.", PrefChangedCallback, this);
 5254:     pref->RegisterCallback("font.name-list.", PrefChangedCallback, this);
 5259:     pref->RegisterCallback("intl.accept_languages", PrefChangedCallback, this);
 5254:     // don't bother unregistering.  We'll get shutdown after the pref service
    1: }
    1: 
    1: gfxWindowsPlatform::~gfxWindowsPlatform()
    1: {
    1: }
    1: 
    1: already_AddRefed<gfxASurface>
    1: gfxWindowsPlatform::CreateOffscreenSurface(const gfxIntSize& size,
    1:                                            gfxASurface::gfxImageFormat imageFormat)
    1: {
    1:     gfxASurface *surf = new gfxWindowsSurface(size, imageFormat);
    1:     NS_IF_ADDREF(surf);
    1:     return surf;
    1: }
    1: 
    1: int CALLBACK 
    1: gfxWindowsPlatform::FontEnumProc(const ENUMLOGFONTEXW *lpelfe,
    1:                                  const NEWTEXTMETRICEXW *nmetrics,
    1:                                  DWORD fontType, LPARAM data)
    1: {
13280:     FontTable *ht = reinterpret_cast<FontTable*>(data);
    1: 
    1:     const NEWTEXTMETRICW& metrics = nmetrics->ntmTm;
13280:     LOGFONTW logFont = lpelfe->elfLogFont;
13280: 
13280:     // Ignore vertical fonts
13280:     if (logFont.lfFaceName[0] == L'@') {
13280:         return 1;
13280:     }
    1: 
 2824: #ifdef DEBUG_pavlov
 2773:     printf("%s %d %d %d\n", NS_ConvertUTF16toUTF8(nsDependentString(logFont.lfFaceName)).get(),
 2773:            logFont.lfCharSet, logFont.lfItalic, logFont.lfWeight);
 2824: #endif
 2773: 
    1:     nsString name(logFont.lfFaceName);
    1:     ToLowerCase(name);
    1: 
13280:     nsRefPtr<FontFamily> ff;
13280:     if (!ht->Get(name, &ff)) {
13280:         ff = new FontFamily(nsDependentString(logFont.lfFaceName));
13280:         ht->Put(name, ff);
13280:     }
13280: 
    1:     nsRefPtr<FontEntry> fe;
13280:     for (PRUint32 i = 0; i < ff->mVariations.Length(); ++i) {
13280:         fe = ff->mVariations[i];
13280:         if (fe->mWeight == logFont.lfWeight &&
13280:             fe->mItalic == (logFont.lfItalic == 0xFF)) {
13280:             return 1; /* we already know about this font */
    1:         }
13280:     }
13280: 
13280:     fe = new FontEntry(ff);
13280:     /* don't append it until the end in case of error */
13280: 
13280:     fe->mItalic = (logFont.lfItalic == 0xFF);
13280:     fe->mWeight = logFont.lfWeight;
    1: 
12992:     if (metrics.ntmFlags & NTM_TYPE1)
13439:         fe->mIsType1 = fe->mForceGDI = PR_TRUE;
13340:     if (metrics.ntmFlags & (NTM_PS_OPENTYPE | NTM_TT_OPENTYPE))
13340:         fe->mTrueType = PR_TRUE;
12992: 
    1:     // mark the charset bit
    1:     fe->mCharset[metrics.tmCharSet] = 1;
    1: 
13280:     fe->mWindowsFamily = logFont.lfPitchAndFamily & 0xF0;
13280:     fe->mWindowsPitch = logFont.lfPitchAndFamily & 0x0F;
    1: 
    1:     if (nmetrics->ntmFontSig.fsUsb[0] == 0x00000000 &&
    1:         nmetrics->ntmFontSig.fsUsb[1] == 0x00000000 &&
    1:         nmetrics->ntmFontSig.fsUsb[2] == 0x00000000 &&
    1:         nmetrics->ntmFontSig.fsUsb[3] == 0x00000000) {
    1:         // no unicode ranges
    1:         fe->mUnicodeFont = PR_FALSE;
    1:     } else {
    1:         fe->mUnicodeFont = PR_TRUE;
    1: 
    1:         // set the unicode ranges
    1:         PRUint32 x = 0;
    1:         for (PRUint32 i = 0; i < 4; ++i) {
    1:             DWORD range = nmetrics->ntmFontSig.fsUsb[i];
    1:             for (PRUint32 k = 0; k < 32; ++k) {
    1:                 fe->mUnicodeRanges[x++] = (range & (1 << k)) != 0;
    1:             }
    1:         }
    1:     }
    1: 
13280:     /* read in the character map */
13280:     HDC hdc = GetDC(nsnull);
13280:     logFont.lfCharSet = DEFAULT_CHARSET;
13280:     HFONT font = CreateFontIndirectW(&logFont);
13280: 
13280:     NS_ASSERTION(font, "This font creation should never ever ever fail");
13280:     if (font) {
13280:         HFONT oldFont = (HFONT)SelectObject(hdc, font);
13280: 
13280:         TEXTMETRIC metrics;
13280:         GetTextMetrics(hdc, &metrics);
13280:         if (metrics.tmPitchAndFamily & TMPF_TRUETYPE)
13280:             fe->mTrueType = PR_TRUE;
13280: 
13280:         if (NS_FAILED(ReadCMAP(hdc, fe))) {
13280:             // Type1 fonts aren't necessarily Unicode but
13280:             // this is the best guess we can make here
13280:             if (fe->mIsType1)
13280:                 fe->mUnicodeFont = PR_TRUE;
13280:             else
13280:                 fe->mUnicodeFont = PR_FALSE;
13280: 
13280:             //printf("%d, %s failed to get cmap\n", aFontEntry->mIsType1, NS_ConvertUTF16toUTF8(aFontEntry->mName).get());
13280:         }
13280: 
13280:         SelectObject(hdc, oldFont);
13280:         DeleteObject(font);
13280:     }
13280: 
13280:     ReleaseDC(nsnull, hdc);
13280: 
13280:     if (!fe->mUnicodeFont) {
13280:         /* non-unicode fonts.. boy lets just set all code points
13280:            between 0x20 and 0xFF.  All the ones on my system do...
13280:            If we really wanted to test which characters in this
13280:            range were supported we could just generate a string with
13280:            each codepoint and do GetGlyphIndicies or similar to determine
13280:            what is there.
13280:         */
13280:         fe->mCharacterMap.SetRange(0x20, 0xFF);
13280:     }
13280: 
13280:     /* append the variation to the font family */
13280:     ff->mVariations.AppendElement(fe);
13280: 
    1:     return 1;
    1: }
    1: 
 9699: // general cmap reading routines moved to gfxFontUtils.cpp
 1959: 
 1959: static nsresult
 1959: ReadCMAP(HDC hdc, FontEntry *aFontEntry)
 1959: {
 1959:     const PRUint32 kCMAP = (('c') | ('m' << 8) | ('a' << 16) | ('p' << 24));
 1959: 
 1959:     DWORD len = GetFontData(hdc, kCMAP, 0, nsnull, 0);
 7376:     if (len == GDI_ERROR || len == 0) // not a truetype font --
 7376:         return NS_ERROR_FAILURE;      // we'll treat it as a symbol font
 1959: 
 1959:     nsAutoTArray<PRUint8,16384> buffer;
 1959:     if (!buffer.AppendElements(len))
 1959:         return NS_ERROR_OUT_OF_MEMORY;
 1959:     PRUint8 *buf = buffer.Elements();
 1959: 
 1959:     DWORD newLen = GetFontData(hdc, kCMAP, 0, buf, len);
 1959:     NS_ENSURE_TRUE(newLen == len, NS_ERROR_FAILURE);
 1959:     
 9699:     return gfxFontUtils::ReadCMAP(buf, len, aFontEntry->mCharacterMap, aFontEntry->mUnicodeRanges,
 9699:                                   aFontEntry->mUnicodeFont, aFontEntry->mSymbolFont);
 1959: }
 1959: 
 1959: PLDHashOperator PR_CALLBACK
13280: gfxWindowsPlatform::FontGetStylesProc(nsStringHashKey::KeyType aKey,
13280:                                       nsRefPtr<FontFamily>& aFontFamily,
 1959:                                       void* userArg)
 1959: {
13280:     NS_ASSERTION(aFontFamily->mVariations.Length() == 1, "We should only have 1 variation here");
13280:     nsRefPtr<FontEntry> aFontEntry = aFontFamily->mVariations[0];
13280: 
 1959:     HDC hdc = GetDC(nsnull);
 1959: 
 1959:     LOGFONTW logFont;
 1959:     memset(&logFont, 0, sizeof(LOGFONTW));
 1959:     logFont.lfCharSet = DEFAULT_CHARSET;
 1959:     logFont.lfPitchAndFamily = 0;
13280:     PRUint32 l = PR_MIN(aFontEntry->GetName().Length(), LF_FACESIZE - 1);
 1959:     memcpy(logFont.lfFaceName,
13280:            nsPromiseFlatString(aFontEntry->GetName()).get(),
 1959:            l * sizeof(PRUnichar));
 1959:     logFont.lfFaceName[l] = 0;
 1959: 
13280:     EnumFontFamiliesExW(hdc, &logFont, (FONTENUMPROCW)gfxWindowsPlatform::FontEnumProc, (LPARAM)userArg, 0);
 1959: 
 1959:     ReleaseDC(nsnull, hdc);
 1959: 
13360:     // Look for font families without bold variations and add a FontEntry
13360:     // with synthetic bold (weight 600) for them.
13360:     nsRefPtr<FontEntry> darkestItalic;
13360:     nsRefPtr<FontEntry> darkestNonItalic;
13360:     PRUint8 highestItalic = 0, highestNonItalic = 0;
13360:     for (PRUint32 i = 0; i < aFontFamily->mVariations.Length(); i++) {
13360:         nsRefPtr<FontEntry> fe = aFontFamily->mVariations[i];
13360:         if (fe->mItalic) {
13360:             if (!darkestItalic || fe->mWeight > darkestItalic->mWeight)
13360:                 darkestItalic = fe;
13360:         } else {
13360:             if (!darkestNonItalic || fe->mWeight > darkestNonItalic->mWeight)
13360:                 darkestNonItalic = fe;
13360:         }
13360:     }
13360: 
13360:     if (darkestItalic && darkestItalic->mWeight < 600) {
13360:         nsRefPtr<FontEntry> newEntry = new FontEntry(*darkestItalic.get());
13360:         newEntry->mWeight = 600;
13360:         aFontFamily->mVariations.AppendElement(newEntry);
13360:     }
13360:     if (darkestNonItalic && darkestNonItalic->mWeight < 600) {
13360:         nsRefPtr<FontEntry> newEntry = new FontEntry(*darkestNonItalic.get());
13360:         newEntry->mWeight = 600;
13360:         aFontFamily->mVariations.AppendElement(newEntry);
13360:     }
13360: 
 7376:     return PL_DHASH_NEXT;
 7376: }
 7376: 
    1: struct FontListData {
    1:     FontListData(const nsACString& aLangGroup, const nsACString& aGenericFamily, nsStringArray& aListOfFonts) :
    1:         mLangGroup(aLangGroup), mGenericFamily(aGenericFamily), mStringArray(aListOfFonts) {}
    1:     const nsACString& mLangGroup;
    1:     const nsACString& mGenericFamily;
    1:     nsStringArray& mStringArray;
    1: };
    1: 
    1: PLDHashOperator PR_CALLBACK
    1: gfxWindowsPlatform::HashEnumFunc(nsStringHashKey::KeyType aKey,
13280:                                  nsRefPtr<FontFamily>& aFontFamily,
    1:                                  void* userArg)
    1: {
    1:     FontListData *data = (FontListData*)userArg;
    1: 
13280:     // use the first variation for now.  This data should be the same
13280:     // for all the variations and should probably be moved up to
13280:     // the Family
13280:     nsRefPtr<FontEntry> aFontEntry = aFontFamily->mVariations[0];
13280: 
 2773:     /* skip symbol fonts */
 2773:     if (aFontEntry->mSymbolFont)
 2773:         return PL_DHASH_NEXT;
 2773: 
    1:     if (aFontEntry->SupportsLangGroup(data->mLangGroup) &&
    1:         aFontEntry->MatchesGenericFamily(data->mGenericFamily))
13280:         data->mStringArray.AppendString(aFontFamily->mName);
    1: 
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
    1: nsresult
    1: gfxWindowsPlatform::GetFontList(const nsACString& aLangGroup,
    1:                                 const nsACString& aGenericFamily,
    1:                                 nsStringArray& aListOfFonts)
    1: {
    1:     FontListData data(aLangGroup, aGenericFamily, aListOfFonts);
    1: 
    1:     mFonts.Enumerate(gfxWindowsPlatform::HashEnumFunc, &data);
    1: 
    1:     aListOfFonts.Sort();
    1:     aListOfFonts.Compact();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: static void
    1: RemoveCharsetFromFontSubstitute(nsAString &aName)
    1: {
    1:     PRInt32 comma = aName.FindChar(PRUnichar(','));
    1:     if (comma >= 0)
    1:         aName.Truncate(comma);
    1: }
    1: 
    1: static void
    1: BuildKeyNameFromFontName(nsAString &aName)
    1: {
    1:     if (aName.Length() >= LF_FACESIZE)
    1:         aName.Truncate(LF_FACESIZE - 1);
    1:     ToLowerCase(aName);
    1: }
    1: 
    1: nsresult
    1: gfxWindowsPlatform::UpdateFontList()
    1: {
    1:     mFonts.Clear();
    1:     mFontAliases.Clear();
    1:     mNonExistingFonts.Clear();
    1:     mFontSubstitutes.Clear();
 5254:     mPrefFonts.Clear();
12526:     mCodepointsWithNoFonts.reset();
    1: 
    1:     LOGFONTW logFont;
    1:     logFont.lfCharSet = DEFAULT_CHARSET;
    1:     logFont.lfFaceName[0] = 0;
    1:     logFont.lfPitchAndFamily = 0;
    1: 
    1:     // Use the screen DC here.. should we use something else for printing?
    1:     HDC dc = ::GetDC(nsnull);
13280:     EnumFontFamiliesExW(dc, &logFont, (FONTENUMPROCW)gfxWindowsPlatform::FontEnumProc, (LPARAM)&mFonts, 0);
    1:     ::ReleaseDC(nsnull, dc);
    1: 
13280:     // Look for additional styles
13280:     mFonts.Enumerate(gfxWindowsPlatform::FontGetStylesProc, &mFonts);
 1959: 
    1:     // Create the list of FontSubstitutes
 1959:     nsCOMPtr<nsIWindowsRegKey> regKey = do_CreateInstance("@mozilla.org/windows-registry-key;1");
    1:     if (!regKey)
    1:         return NS_ERROR_FAILURE;
 1959:      NS_NAMED_LITERAL_STRING(kFontSubstitutesKey, "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes");
    1: 
 1959:     nsresult rv = regKey->Open(nsIWindowsRegKey::ROOT_KEY_LOCAL_MACHINE,
    1:                                kFontSubstitutesKey, nsIWindowsRegKey::ACCESS_READ);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRUint32 count;
    1:     rv = regKey->GetValueCount(&count);
    1:     if (NS_FAILED(rv) || count == 0)
    1:         return rv;
    1:     for (PRUint32 i = 0; i < count; i++) {
    1:         nsAutoString substituteName;
    1:         rv = regKey->GetValueName(i, substituteName);
    1:         if (NS_FAILED(rv) || substituteName.IsEmpty() ||
    1:             substituteName.CharAt(1) == PRUnichar('@'))
    1:             continue;
    1:         PRUint32 valueType;
    1:         rv = regKey->GetValueType(substituteName, &valueType);
    1:         if (NS_FAILED(rv) || valueType != nsIWindowsRegKey::TYPE_STRING)
    1:             continue;
    1:         nsAutoString actualFontName;
    1:         rv = regKey->ReadStringValue(substituteName, actualFontName);
    1:         if (NS_FAILED(rv))
    1:             continue;
    1: 
    1:         RemoveCharsetFromFontSubstitute(substituteName);
    1:         BuildKeyNameFromFontName(substituteName);
    1:         RemoveCharsetFromFontSubstitute(actualFontName);
    1:         BuildKeyNameFromFontName(actualFontName);
13280:         nsRefPtr<FontFamily> ff;
13280:         if (!actualFontName.IsEmpty() && mFonts.Get(actualFontName, &ff))
13280:             mFontSubstitutes.Put(substituteName, ff);
    1:         else
    1:             mNonExistingFonts.AppendString(substituteName);
    1:     }
    1: 
12526:     // initialize ranges of characters for which system-wide font search should be skipped
12526:     mCodepointsWithNoFonts.SetRange(0,0x1f);     // C0 controls
12526:     mCodepointsWithNoFonts.SetRange(0x7f,0x9f);  // C1 controls
12526: 
12989:     InitBadUnderlineList();
12989: 
    1:     return NS_OK;
    1: }
    1: 
12989: static PRBool SimpleResolverCallback(const nsAString& aName, void* aClosure)
12989: {
12989:     nsString* result = static_cast<nsString*>(aClosure);
12989:     result->Assign(aName);
12989:     return PR_FALSE;
12989: }
12989: 
12989: void
12989: gfxWindowsPlatform::InitBadUnderlineList()
12989: {
12989:     nsAutoTArray<nsAutoString, 10> blacklist;
12989:     gfxFontUtils::GetPrefsFontList("font.blacklist.underline_offset", blacklist);
12989:     PRUint32 numFonts = blacklist.Length();
12989:     for (PRUint32 i = 0; i < numFonts; i++) {
12989:         PRBool aborted;
12989:         nsAutoString resolved;
12989:         ResolveFontName(blacklist[i], SimpleResolverCallback, &resolved, aborted);
12989:         if (resolved.IsEmpty())
12989:             continue;
13280:         FontFamily *ff = FindFontFamily(resolved);
13280:         if (!ff)
12989:             continue;
13280:         for (PRUint32 j = 0; j < ff->mVariations.Length(); ++j) {
13280:             nsRefPtr<FontEntry> fe = ff->mVariations[j];
12989:             fe->mIsBadUnderlineFont = 1;
12989:         }
12989:     }
13280: }
12989: 
13003: nsresult
13003: gfxWindowsPlatform::GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName)
13003: {
13003:     aFamilyName.Truncate();
13003:     PRBool aborted;
13003:     return ResolveFontName(aFontName, SimpleResolverCallback, &aFamilyName, aborted);
13003: }
13003: 
    1: struct ResolveData {
    1:     ResolveData(gfxPlatform::FontResolverCallback aCallback,
    1:                 gfxWindowsPlatform *aCaller, const nsAString *aFontName,
    1:                 void *aClosure) :
    1:         mFoundCount(0), mCallback(aCallback), mCaller(aCaller),
    1:         mFontName(aFontName), mClosure(aClosure) {}
    1:     PRUint32 mFoundCount;
    1:     gfxPlatform::FontResolverCallback mCallback;
    1:     gfxWindowsPlatform *mCaller;
    1:     const nsAString *mFontName;
    1:     void *mClosure;
    1: };
    1: 
    1: nsresult
    1: gfxWindowsPlatform::ResolveFontName(const nsAString& aFontName,
    1:                                     FontResolverCallback aCallback,
    1:                                     void *aClosure,
    1:                                     PRBool& aAborted)
    1: {
    1:     if (aFontName.IsEmpty())
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsAutoString keyName(aFontName);
    1:     BuildKeyNameFromFontName(keyName);
    1: 
13280:     nsRefPtr<FontFamily> ff;
13280:     if (mFonts.Get(keyName, &ff) ||
13280:         mFontSubstitutes.Get(keyName, &ff) ||
13280:         mFontAliases.Get(keyName, &ff)) {
13280:         aAborted = !(*aCallback)(ff->mName, aClosure);
    1:         // XXX If the font has font link, we should add the linked font.
    1:         return NS_OK;
    1:     }
    1: 
    1:     if (mNonExistingFonts.IndexOf(keyName) >= 0) {
    1:         aAborted = PR_FALSE;
    1:         return NS_OK;
    1:     }
    1: 
    1:     LOGFONTW logFont;
    1:     logFont.lfCharSet = DEFAULT_CHARSET;
    1:     logFont.lfPitchAndFamily = 0;
    1:     PRInt32 len = aFontName.Length();
    1:     if (len >= LF_FACESIZE)
    1:         len = LF_FACESIZE - 1;
    1:     memcpy(logFont.lfFaceName,
    1:            nsPromiseFlatString(aFontName).get(), len * sizeof(PRUnichar));
    1:     logFont.lfFaceName[len] = 0;
    1: 
    1:     HDC dc = ::GetDC(nsnull);
    1:     ResolveData data(aCallback, this, &keyName, aClosure);
13280:     aAborted = !EnumFontFamiliesExW(dc, &logFont,
    1:                                     (FONTENUMPROCW)gfxWindowsPlatform::FontResolveProc,
    1:                                     (LPARAM)&data, 0);
    1:     if (data.mFoundCount == 0)
    1:         mNonExistingFonts.AppendString(keyName);
    1:     ::ReleaseDC(nsnull, dc);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: int CALLBACK 
    1: gfxWindowsPlatform::FontResolveProc(const ENUMLOGFONTEXW *lpelfe,
    1:                                     const NEWTEXTMETRICEXW *nmetrics,
    1:                                     DWORD fontType, LPARAM data)
    1: {
    1:     const LOGFONTW& logFont = lpelfe->elfLogFont;
    1:     // Ignore vertical fonts
    1:     if (logFont.lfFaceName[0] == L'@' || logFont.lfFaceName[0] == 0)
    1:         return 1;
    1: 
    1:     ResolveData *rData = reinterpret_cast<ResolveData*>(data);
    1: 
    1:     nsAutoString name(logFont.lfFaceName);
    1: 
    1:     // Save the alias name to cache
13280:     nsRefPtr<FontFamily> ff;
    1:     nsAutoString keyName(name);
    1:     BuildKeyNameFromFontName(keyName);
13280:     if (!rData->mCaller->mFonts.Get(keyName, &ff)) {
    1:         // This case only occurs on failing to build
    1:         // the list of font substitue. In this case, the user should
    1:         // reboot the Windows. Probably, we don't have the good way for
    1:         // resolving in this time.
    1:         NS_WARNING("Cannot find actual font");
    1:         return 1;
    1:     }
    1: 
    1:     rData->mFoundCount++;
13280:     rData->mCaller->mFontAliases.Put(*(rData->mFontName), ff);
    1: 
    1:     return (rData->mCallback)(name, rData->mClosure);
    1: 
    1:     // XXX If the font has font link, we should add the linked font.
    1: }
    1: 
    1: struct FontSearch {
12526:     FontSearch(PRUint32 aCh, gfxWindowsFont *aFont) :
12526:         ch(aCh), fontToMatch(aFont), matchRank(0) {
    1:     }
12526:     PRUint32 ch;
 1959:     nsRefPtr<gfxWindowsFont> fontToMatch;
 1959:     PRInt32 matchRank;
 1959:     nsRefPtr<FontEntry> bestMatch;
    1: };
    1: 
    1: PLDHashOperator PR_CALLBACK
12526: gfxWindowsPlatform::FindFontForCharProc(nsStringHashKey::KeyType aKey,
13280:                                         nsRefPtr<FontFamily>& aFontFamily,
    1:                                         void* userArg)
    1: {
13340:     FontSearch *data = (FontSearch*)userArg;
13280: 
13340:     const PRUint32 ch = data->ch;
13340: 
13340:     nsRefPtr<FontEntry> fe = GetPlatform()->FindFontEntry(aFontFamily, data->fontToMatch->GetStyle());
13340: 
13340:     // skip over non-unicode and bitmap fonts and fonts that don't have
13340:     // the code point we're looking for
13340:     if (fe->IsCrappyFont() || !fe->mCharacterMap.test(ch))
    1:         return PL_DHASH_NEXT;
    1: 
 1959:     PRInt32 rank = 0;
 1959:     // fonts that claim to support the range are more
 1959:     // likely to be "better fonts" than ones that don't... (in theory)
13280:     if (fe->SupportsRange(gfxFontUtils::CharRangeBit(ch)))
 1959:         rank += 1;
 1959: 
13280:     if (fe->SupportsLangGroup(data->fontToMatch->GetStyle()->langGroup))
13340:         rank += 2;
 1959: 
13280:     if (fe->mWindowsFamily == data->fontToMatch->GetFontEntry()->mWindowsFamily)
13340:         rank += 3;
13280:     if (fe->mWindowsPitch == data->fontToMatch->GetFontEntry()->mWindowsFamily)
13340:         rank += 3;
 1959: 
13280:     /* italic */
13280:     const PRBool italic = (data->fontToMatch->GetStyle()->style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) ? PR_TRUE : PR_FALSE;
13340:     if (fe->mItalic != italic)
13340:         rank += 3;
13280: 
 1959:     /* weight */
 1959:     PRInt8 baseWeight, weightDistance;
 1959:     data->fontToMatch->GetStyle()->ComputeWeightAndOffset(&baseWeight, &weightDistance);
13340:     if (fe->mWeight == (baseWeight * 100) + (weightDistance * 100))
13340:         rank += 2;
13340:     else if (fe->mWeight == data->fontToMatch->GetFontEntry()->mWeight)
13340:         rank += 1;
 1959: 
 2459:     if (rank > data->matchRank ||
13280:         (rank == data->matchRank && Compare(fe->GetName(), data->bestMatch->GetName()) > 0)) {
13280:         data->bestMatch = fe;
 1959:         data->matchRank = rank;
    1:     }
    1: 
    1:     return PL_DHASH_NEXT;
    1: }
    1: 
 1959: 
 1959: FontEntry *
12526: gfxWindowsPlatform::FindFontForChar(PRUint32 aCh, gfxWindowsFont *aFont)
 1943: {
12526:     // is codepoint with no matching font? return null immediately
12526:     if (mCodepointsWithNoFonts.test(aCh)) {
12526:         return nsnull;
12526:     }
12526: 
12526:     FontSearch data(aCh, aFont);
 1940: 
 1959:     // find fonts that support the character
12526:     mFonts.Enumerate(gfxWindowsPlatform::FindFontForCharProc, &data);
12526: 
12526:     // no match? add to set of non-matching codepoints
12526:     if (!data.bestMatch) {
12526:         mCodepointsWithNoFonts.set(aCh);
12526:     }
 1943:     
 1959:     return data.bestMatch;
    1: }
  270: 
  270: gfxFontGroup *
  270: gfxWindowsPlatform::CreateFontGroup(const nsAString &aFamilies,
  270:                                     const gfxFontStyle *aStyle)
  270: {
  270:     return new gfxWindowsFontGroup(aFamilies, aStyle);
  270: }
 1959: 
13280: FontFamily *
13280: gfxWindowsPlatform::FindFontFamily(const nsAString& aName)
 1959: {
 1959:     nsString name(aName);
 1959:     ToLowerCase(name);
 1959: 
13280:     nsRefPtr<FontFamily> ff;
13280:     if (!mFonts.Get(name, &ff) &&
13280:         !mFontSubstitutes.Get(name, &ff) &&
13280:         !mFontAliases.Get(name, &ff)) {
 1959:         return nsnull;
 1959:     }
13280:     return ff.get();
13280: }
13280: 
13280: FontEntry *
13280: gfxWindowsPlatform::FindFontEntry(const nsAString& aName, const gfxFontStyle *aFontStyle)
13280: {
13280:     nsRefPtr<FontFamily> ff = FindFontFamily(aName);
13280:     if (!ff)
13280:         return nsnull;
13280: 
13340:     return FindFontEntry(ff, aFontStyle);
13340: }
13340: 
13340: FontEntry *
13340: gfxWindowsPlatform::FindFontEntry(FontFamily *aFontFamily, const gfxFontStyle *aFontStyle)
13340: {
13280:     PRUint8 bestMatch = 0;
13397:     PRBool italic = (aFontStyle->style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0;
13280: 
13280:     nsAutoTArray<nsRefPtr<FontEntry>, 10> weightList;
13280:     weightList.AppendElements(10);
13397:     for (PRUint32 j = 0; j < 2; j++) {
13397:         PRBool matchesSomething = PR_FALSE;
13397:         // build up an array of weights that match the italicness we're looking for
13340:         for (PRInt32 i = 0; i < aFontFamily->mVariations.Length(); i++) {
13340:             nsRefPtr<FontEntry> fe = aFontFamily->mVariations[i];
13397:             const PRUint8 weight = (fe->mWeight / 100);
13397:             if (fe->mItalic == italic) {
13280:                 weightList[weight] = fe;
13397:                 matchesSomething = PR_TRUE;
13397:             }
13397:         }
13397:         if (matchesSomething)
13397:             break;
13397:         italic = !italic;
13280:     }
13280: 
13280:     PRInt8 baseWeight, weightDistance;
13280:     aFontStyle->ComputeWeightAndOffset(&baseWeight, &weightDistance);
13280: 
13397:     // 500 isn't quite bold so we want to treat it as 400 if we don't
13397:     // have a 500 weight
13397:     if (baseWeight == 5 && weightDistance == 0) {
13397:         // If we have a 500 weight then use it
13397:         if (weightList[5])
13397:             return weightList[5];
13280: 
13397:         // Otherwise treat as 400
13397:         baseWeight = 4;
13280:     }
13397: 
13397: 
13397:     PRInt8 matchBaseWeight = 0;
13397:     PRInt8 direction = (baseWeight > 5) ? 1 : -1;
13397:     for (PRInt8 i = baseWeight; ; i += direction) {
13397:         if (weightList[i]) {
13397:             matchBaseWeight = i;
13280:             break;
13280:         }
13397: 
13397:         // if we've reached one side without finding a font,
13397:         // go the other direction until we find a match
13397:         if (i == 1 || i == 9)
13397:             direction = -direction;
13280:     }
13280: 
13397:     nsRefPtr<FontEntry> matchFE;
13397:     const PRInt8 absDistance = abs(weightDistance);
13397:     direction = (weightDistance >= 0) ? 1 : -1;
13397:     for (PRInt8 i = matchBaseWeight, k = 0; i < 10 && i > 0; i += direction) {
13397:         if (weightList[i]) {
13397:             matchFE = weightList[i];
13397:             k++;
13280:         }
13397:         if (k > absDistance)
13280:             break;
13280:     }
13280: 
13280:     if (!matchFE) {
13397:         /* if we still don't have a match, grab the closest thing in the other direction */
13397:         direction = -direction;
13397:         for (PRInt8 i = matchBaseWeight; i < 10 && i > 0; i += direction) {
13397:             if (weightList[i]) {
13397:                 matchFE = weightList[i];
13397:             }
13397:         }
13397:     }
13340: 
13397: 
13397:     NS_ASSERTION(matchFE, "we should always be able to return something here");
13280:     return matchFE;
 1959: }
 3787: 
 3787: cmsHPROFILE
 3787: gfxWindowsPlatform::GetPlatformCMSOutputProfile()
 3787: {
 3787:     WCHAR str[1024+1];
 3787:     DWORD size = 1024;
 3787: 
 3787:     HDC dc = GetDC(nsnull);
 3787:     GetICMProfileW(dc, &size, (LPWSTR)&str);
 3787:     ReleaseDC(nsnull, dc);
 3787: 
 3787:     cmsHPROFILE profile =
 3787:         cmsOpenProfileFromFile(NS_ConvertUTF16toUTF8(str).get(), "r");
 3787: #ifdef DEBUG_tor
 3787:     if (profile)
 3787:         fprintf(stderr,
 3787:                 "ICM profile read from %s successfully\n",
 3787:                 NS_ConvertUTF16toUTF8(str).get());
 3787: #endif
 3787:     return profile;
 3787: }
 5254: 
 5254: PRBool
13280: gfxWindowsPlatform::GetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<FontEntry> > *array)
 5254: {
13280:     return mPrefFonts.Get(aKey, array);
 5254: }
 5254: 
 5254: void
13280: gfxWindowsPlatform::SetPrefFontEntries(const nsCString& aKey, nsTArray<nsRefPtr<FontEntry> >& array)
 5254: {
13280:     mPrefFonts.Put(aKey, array);
 5254: }
