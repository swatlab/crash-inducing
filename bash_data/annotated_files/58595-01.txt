16150: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
16150: // vim:cindent:ts=2:et:sw=2:
16150: /* ***** BEGIN LICENSE BLOCK *****
16150:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
16150:  *
16150:  * The contents of this file are subject to the Mozilla Public License Version
16150:  * 1.1 (the "License"); you may not use this file except in compliance with
16150:  * the License. You may obtain a copy of the License at
16150:  * http://www.mozilla.org/MPL/
16150:  *
16150:  * Software distributed under the License is distributed on an "AS IS" basis,
16150:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
16150:  * for the specific language governing rights and limitations under the
16150:  * License.
16150:  *
16150:  * The Original Code is mozilla.org code.
16150:  *
16150:  * The Initial Developer of the Original Code is
16150:  *   Mozilla Corporation
16150:  * Portions created by the Initial Developer are Copyright (C) 2008
16150:  * the Initial Developer. All Rights Reserved.
16150:  *
16150:  * Contributor(s):
16150:  *   Vladimir Vukicevic <vladimir@pobox.com>
58478:  *   Bas Schouten <bschouten@mozilla.com>
16150:  *
16150:  * Alternatively, the contents of this file may be used under the terms of
16150:  * either of the GNU General Public License Version 2 or later (the "GPL"),
16150:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
16150:  * in which case the provisions of the GPL or the LGPL are applicable instead
16150:  * of those above. If you wish to allow use of your version of this file only
16150:  * under the terms of either the GPL or the LGPL, and not to allow others to
16150:  * use your version of this file under the terms of the MPL, indicate your
16150:  * decision by deleting the provisions above and replace them with the notice
16150:  * and other provisions required by the GPL or the LGPL. If you do not delete
16150:  * the provisions above, a recipient may use your version of this file under
16150:  * the terms of any one of the MPL, the GPL or the LGPL.
16150:  *
16150:  * ***** END LICENSE BLOCK ***** */
16150: 
16150: #include "nsStyleConsts.h"
16150: #include "nsIFrame.h"
16150: #include "nsPoint.h"
16150: #include "nsRect.h"
16150: #include "nsIViewManager.h"
16150: #include "nsFrameManager.h"
16150: #include "nsStyleContext.h"
16150: #include "nsGkAtoms.h"
16150: #include "nsCSSAnonBoxes.h"
16150: #include "nsTransform2D.h"
16150: #include "nsIDeviceContext.h"
16150: #include "nsIContent.h"
16150: #include "nsIDocument.h"
16150: #include "nsIScrollableFrame.h"
16150: #include "imgIRequest.h"
16150: #include "imgIContainer.h"
16150: #include "nsCSSRendering.h"
16150: #include "nsCSSColorUtils.h"
16150: #include "nsITheme.h"
16150: #include "nsThemeConstants.h"
16150: #include "nsIServiceManager.h"
16150: #include "nsIHTMLDocument.h"
16150: #include "nsLayoutUtils.h"
16150: #include "nsINameSpaceManager.h"
16150: #include "nsBlockFrame.h"
16150: 
16150: #include "gfxContext.h"
16150: 
16150: #include "nsCSSRenderingBorders.h"
16150: 
16150: /**
16150:  * nsCSSRendering::PaintBorder
16150:  * nsCSSRendering::PaintOutline
16150:  *   -> DrawBorders
16150:  *
16150:  * DrawBorders
58478:  *   -> Ability to use specialized approach?
58478:  *      |- Draw using specialized function
16150:  *   |- separate corners?
16150:  *   |- dashed side mask
16150:  *   |
16150:  *   -> can border be drawn in 1 pass? (e.g., solid border same color all around)
16150:  *      |- DrawBorderSides with all 4 sides
16150:  *   -> more than 1 pass?
16150:  *      |- for each corner
16150:  *         |- clip to DoCornerClipSubPath
16150:  *         |- PushGroup
16150:  *         |- for each side adjacent to corner
16150:  *            |- clip to DoSideClipSubPath
16150:  *            |- DrawBorderSides with one side
16150:  *         |- PopGroup
16150:  *      |- for each side
16150:  *         |- DoSideClipWithoutCornersSubPath
16150:  *         |- DrawDashedSide || DrawBorderSides with one side
16150:  */
16150: 
16150: static void ComputeBorderCornerDimensions(const gfxRect& aOuterRect,
16150:                                           const gfxRect& aInnerRect,
16150:                                           const gfxCornerSizes& aRadii,
16150:                                           gfxCornerSizes *aDimsResult);
16150: 
16150: // given a side index, get the previous and next side index
41419: #define NEXT_SIDE(_s) mozilla::css::Side(((_s) + 1) & 3)
41419: #define PREV_SIDE(_s) mozilla::css::Side(((_s) + 3) & 3)
16150: 
16150: // from the given base color and the background color, turn
16150: // color into a color for the given border pattern style
16150: static gfxRGBA MakeBorderColor(const gfxRGBA& aColor,
16150:                                const gfxRGBA& aBackgroundColor,
16150:                                BorderColorStyle aBorderColorStyle);
16150: 
16150: 
16150: // Given a line index (an index starting from the outside of the
16150: // border going inwards) and an array of line styles, calculate the
16150: // color that that stripe of the border should be rendered in.
16150: static gfxRGBA ComputeColorForLine(PRUint32 aLineIndex,
16150:                                    const BorderColorStyle* aBorderColorStyle,
16150:                                    PRUint32 aBorderColorStyleCount,
16150:                                    nscolor aBorderColor,
16150:                                    nscolor aBackgroundColor);
16150: 
16150: static gfxRGBA ComputeCompositeColorForLine(PRUint32 aLineIndex,
16150:                                             const nsBorderColors* aBorderColors);
16150: 
16150: // little helper function to check if the array of 4 floats given are
16150: // equal to the given value
16150: static PRBool
16150: CheckFourFloatsEqual(const gfxFloat *vals, gfxFloat k)
16150: {
16150:   return (vals[0] == k &&
16150:           vals[1] == k &&
16150:           vals[2] == k &&
16150:           vals[3] == k);
16150: }
16150: 
16150: static bool
16150: IsZeroSize(const gfxSize& sz) {
16150:   return sz.width == 0.0 || sz.height == 0.0;
16150: }
16150: 
16150: static bool
16150: AllCornersZeroSize(const gfxCornerSizes& corners) {
41419:   return IsZeroSize(corners[NS_CORNER_TOP_LEFT]) &&
41419:     IsZeroSize(corners[NS_CORNER_TOP_RIGHT]) &&
41419:     IsZeroSize(corners[NS_CORNER_BOTTOM_RIGHT]) &&
41419:     IsZeroSize(corners[NS_CORNER_BOTTOM_LEFT]);
16150: }
16150: 
16150: typedef enum {
16150:   // Normal solid square corner.  Will be rectangular, the size of the
16150:   // adjacent sides.  If the corner has a border radius, the corner
16150:   // will always be solid, since we don't do dotted/dashed etc.
16150:   CORNER_NORMAL,
16150: 
16150:   // Paint the corner in whatever style is not dotted/dashed of the
16150:   // adjacent corners.
16150:   CORNER_SOLID,
16150: 
16150:   // Paint the corner as a dot, the size of the bigger of the adjacent
16150:   // sides.
16150:   CORNER_DOT
16150: } CornerStyle;
16150: 
16150: nsCSSBorderRenderer::nsCSSBorderRenderer(PRInt32 aAppUnitsPerPixel,
16150:                                          gfxContext* aDestContext,
16150:                                          gfxRect& aOuterRect,
16150:                                          const PRUint8* aBorderStyles,
16150:                                          const gfxFloat* aBorderWidths,
16150:                                          gfxCornerSizes& aBorderRadii,
16150:                                          const nscolor* aBorderColors,
16150:                                          nsBorderColors* const* aCompositeColors,
16150:                                          PRIntn aSkipSides,
16424:                                          nscolor aBackgroundColor)
28329:   : mContext(aDestContext),
16150:     mOuterRect(aOuterRect),
16150:     mBorderStyles(aBorderStyles),
16150:     mBorderWidths(aBorderWidths),
16150:     mBorderRadii(aBorderRadii),
16150:     mBorderColors(aBorderColors),
16150:     mCompositeColors(aCompositeColors),
28329:     mAUPP(aAppUnitsPerPixel),
16150:     mSkipSides(aSkipSides),
16424:     mBackgroundColor(aBackgroundColor)
16150: {
16150:   if (!mCompositeColors) {
16150:     static nsBorderColors * const noColors[4] = { NULL };
16150:     mCompositeColors = &noColors[0];
16150:   }
16150: 
16150:   mInnerRect = mOuterRect;
58478:   mInnerRect.Inset(mBorderStyles[0] != NS_STYLE_BORDER_STYLE_NONE ? mBorderWidths[0] : 0,
58478:                    mBorderStyles[1] != NS_STYLE_BORDER_STYLE_NONE ? mBorderWidths[1] : 0,
58478:                    mBorderStyles[2] != NS_STYLE_BORDER_STYLE_NONE ? mBorderWidths[2] : 0,
58478:                    mBorderStyles[3] != NS_STYLE_BORDER_STYLE_NONE ? mBorderWidths[3] : 0);
16150: 
16150:   ComputeBorderCornerDimensions(mOuterRect, mInnerRect, mBorderRadii, &mBorderCornerDimensions);
16151: 
16151:   mOneUnitBorder = CheckFourFloatsEqual(mBorderWidths, 1.0);
16151:   mNoBorderRadius = AllCornersZeroSize(mBorderRadii);
16150: }
16150: 
23493: /* static */ void
23493: nsCSSBorderRenderer::ComputeInnerRadii(const gfxCornerSizes& aRadii,
16150:                                        const gfxFloat *aBorderSizes,
16150:                                        gfxCornerSizes *aInnerRadiiRet)
16150: {
16150:   gfxCornerSizes& iRadii = *aInnerRadiiRet;
16150: 
32531:   iRadii[C_TL].width = NS_MAX(0.0, aRadii[C_TL].width - aBorderSizes[NS_SIDE_LEFT]);
32531:   iRadii[C_TL].height = NS_MAX(0.0, aRadii[C_TL].height - aBorderSizes[NS_SIDE_TOP]);
16150: 
32531:   iRadii[C_TR].width = NS_MAX(0.0, aRadii[C_TR].width - aBorderSizes[NS_SIDE_RIGHT]);
32531:   iRadii[C_TR].height = NS_MAX(0.0, aRadii[C_TR].height - aBorderSizes[NS_SIDE_TOP]);
16150: 
32531:   iRadii[C_BR].width = NS_MAX(0.0, aRadii[C_BR].width - aBorderSizes[NS_SIDE_RIGHT]);
32531:   iRadii[C_BR].height = NS_MAX(0.0, aRadii[C_BR].height - aBorderSizes[NS_SIDE_BOTTOM]);
16150: 
32531:   iRadii[C_BL].width = NS_MAX(0.0, aRadii[C_BL].width - aBorderSizes[NS_SIDE_LEFT]);
32531:   iRadii[C_BL].height = NS_MAX(0.0, aRadii[C_BL].height - aBorderSizes[NS_SIDE_BOTTOM]);
16150: }
16150: 
16150: /*static*/ void
16150: ComputeBorderCornerDimensions(const gfxRect& aOuterRect,
16150:                               const gfxRect& aInnerRect,
16150:                               const gfxCornerSizes& aRadii,
16150:                               gfxCornerSizes *aDimsRet)
16150: {
16150:   gfxFloat topWidth = aInnerRect.pos.y - aOuterRect.pos.y;
16150:   gfxFloat leftWidth = aInnerRect.pos.x - aOuterRect.pos.x;
16150:   gfxFloat rightWidth = aOuterRect.size.width - aInnerRect.size.width - leftWidth;
16150:   gfxFloat bottomWidth = aOuterRect.size.height - aInnerRect.size.height - topWidth;
16150: 
16150:   if (AllCornersZeroSize(aRadii)) {
16150:     // These will always be in pixel units from CSS
16150:     (*aDimsRet)[C_TL] = gfxSize(leftWidth, topWidth);
16150:     (*aDimsRet)[C_TR] = gfxSize(rightWidth, topWidth);
16150:     (*aDimsRet)[C_BR] = gfxSize(rightWidth, bottomWidth);
16150:     (*aDimsRet)[C_BL] = gfxSize(leftWidth, bottomWidth);
16150:   } else {
16150:     // Always round up to whole pixels for the corners; it's safe to
16150:     // make the corners bigger than necessary, and this way we ensure
16150:     // that we avoid seams.
32531:     (*aDimsRet)[C_TL] = gfxSize(ceil(NS_MAX(leftWidth, aRadii[C_TL].width)),
32531:                                 ceil(NS_MAX(topWidth, aRadii[C_TL].height)));
32531:     (*aDimsRet)[C_TR] = gfxSize(ceil(NS_MAX(rightWidth, aRadii[C_TR].width)),
32531:                                 ceil(NS_MAX(topWidth, aRadii[C_TR].height)));
32531:     (*aDimsRet)[C_BR] = gfxSize(ceil(NS_MAX(rightWidth, aRadii[C_BR].width)),
32531:                                 ceil(NS_MAX(bottomWidth, aRadii[C_BR].height)));
32531:     (*aDimsRet)[C_BL] = gfxSize(ceil(NS_MAX(leftWidth, aRadii[C_BL].width)),
32531:                                 ceil(NS_MAX(bottomWidth, aRadii[C_BL].height)));
16150:   }
16150: }
16150: 
16150: PRBool
16150: nsCSSBorderRenderer::AreBorderSideFinalStylesSame(PRUint8 aSides)
16150: {
16150:   NS_ASSERTION(aSides != 0 && (aSides & ~SIDE_BITS_ALL) == 0,
16150:                "AreBorderSidesSame: invalid whichSides!");
16150: 
16150:   /* First check if the specified styles and colors are the same for all sides */
16150:   int firstStyle = 0;
16150:   NS_FOR_CSS_SIDES (i) {
16150:     if (firstStyle == i) {
16150:       if (((1 << i) & aSides) == 0)
16150:         firstStyle++;
16150:       continue;
16150:     }
16150: 
21826:     if (((1 << i) & aSides) == 0) {
21826:       continue;
21826:     }
21826: 
16150:     if (mBorderStyles[firstStyle] != mBorderStyles[i] ||
16150:         mBorderColors[firstStyle] != mBorderColors[i] ||
19182:         !nsBorderColors::Equal(mCompositeColors[firstStyle],
19182:                                mCompositeColors[i]))
16150:       return PR_FALSE;
16150:   }
16150: 
16150:   /* Then if it's one of the two-tone styles and we're not
16150:    * just comparing the TL or BR sides */
16150:   switch (mBorderStyles[firstStyle]) {
16150:     case NS_STYLE_BORDER_STYLE_GROOVE:
16150:     case NS_STYLE_BORDER_STYLE_RIDGE:
16150:     case NS_STYLE_BORDER_STYLE_INSET:
16150:     case NS_STYLE_BORDER_STYLE_OUTSET:
16150:       return ((aSides & ~(SIDE_BIT_TOP | SIDE_BIT_LEFT)) == 0 ||
16150:               (aSides & ~(SIDE_BIT_BOTTOM | SIDE_BIT_RIGHT)) == 0);
16150:   }
16150: 
16150:   return PR_TRUE;
16150: }
16150: 
16151: PRBool
41419: nsCSSBorderRenderer::IsSolidCornerStyle(PRUint8 aStyle, mozilla::css::Corner aCorner)
16151: {
16151:   switch (aStyle) {
16151:     case NS_STYLE_BORDER_STYLE_DOTTED:
16151:     case NS_STYLE_BORDER_STYLE_DASHED:
16151:     case NS_STYLE_BORDER_STYLE_SOLID:
16151:       return PR_TRUE;
16151: 
16151:     case NS_STYLE_BORDER_STYLE_INSET:
16151:     case NS_STYLE_BORDER_STYLE_OUTSET:
41419:       return (aCorner == NS_CORNER_TOP_LEFT || aCorner == NS_CORNER_BOTTOM_RIGHT);
16151: 
16151:     case NS_STYLE_BORDER_STYLE_GROOVE:
16151:     case NS_STYLE_BORDER_STYLE_RIDGE:
41419:       return mOneUnitBorder && (aCorner == NS_CORNER_TOP_LEFT || aCorner == NS_CORNER_BOTTOM_RIGHT);
16151: 
16151:     case NS_STYLE_BORDER_STYLE_DOUBLE:
16151:       return mOneUnitBorder;
16151: 
16151:     default:
16151:       return PR_FALSE;
16151:   }
16151: }
16151: 
16151: BorderColorStyle
41419: nsCSSBorderRenderer::BorderColorStyleForSolidCorner(PRUint8 aStyle, mozilla::css::Corner aCorner)
16151: {
16151:   // note that this function assumes that the corner is already solid,
16151:   // as per the earlier function
16151:   switch (aStyle) {
16151:     case NS_STYLE_BORDER_STYLE_DOTTED:
16151:     case NS_STYLE_BORDER_STYLE_DASHED:
16151:     case NS_STYLE_BORDER_STYLE_SOLID:
16151:     case NS_STYLE_BORDER_STYLE_DOUBLE:
16151:       return BorderColorStyleSolid;
16151: 
16151:     case NS_STYLE_BORDER_STYLE_INSET:
16151:     case NS_STYLE_BORDER_STYLE_GROOVE:
41419:       if (aCorner == NS_CORNER_TOP_LEFT)
16151:         return BorderColorStyleDark;
41419:       else if (aCorner == NS_CORNER_BOTTOM_RIGHT)
16151:         return BorderColorStyleLight;
16151:       break;
16151: 
16151:     case NS_STYLE_BORDER_STYLE_OUTSET:
16151:     case NS_STYLE_BORDER_STYLE_RIDGE:
41419:       if (aCorner == NS_CORNER_TOP_LEFT)
16151:         return BorderColorStyleLight;
41419:       else if (aCorner == NS_CORNER_BOTTOM_RIGHT)
16151:         return BorderColorStyleDark;
16151:       break;
16151:   }
16151: 
16151:   return BorderColorStyleNone;
16151: }
16150: 
16150: void
41419: nsCSSBorderRenderer::DoCornerSubPath(mozilla::css::Corner aCorner)
16150: {
16150:   gfxPoint offset(0.0, 0.0);
16150: 
16150:   if (aCorner == C_TR || aCorner == C_BR)
16150:     offset.x = mOuterRect.size.width - mBorderCornerDimensions[aCorner].width;
16150:   if (aCorner == C_BR || aCorner == C_BL)
16150:     offset.y = mOuterRect.size.height - mBorderCornerDimensions[aCorner].height;
16150: 
16150:   mContext->Rectangle(gfxRect(mOuterRect.pos + offset,
16150:                               mBorderCornerDimensions[aCorner]));
16150: }
16150: 
16150: void
41419: nsCSSBorderRenderer::DoSideClipWithoutCornersSubPath(mozilla::css::Side aSide)
16150: {
16150:   gfxPoint offset(0.0, 0.0);
16150: 
16150:   // The offset from the outside rect to the start of this side's
16150:   // box.  For the top and bottom sides, the height of the box
16150:   // must be the border height; the x start must take into account
16150:   // the corner size (which may be bigger than the right or left
16150:   // side's width).  The same applies to the right and left sides.
16150:   if (aSide == NS_SIDE_TOP) {
16150:     offset.x = mBorderCornerDimensions[C_TL].width;
16150:   } else if (aSide == NS_SIDE_RIGHT) {
16150:     offset.x = mOuterRect.size.width - mBorderWidths[NS_SIDE_RIGHT];
16150:     offset.y = mBorderCornerDimensions[C_TR].height;
16150:   } else if (aSide == NS_SIDE_BOTTOM) {
16150:     offset.x = mBorderCornerDimensions[C_BL].width;
16150:     offset.y = mOuterRect.size.height - mBorderWidths[NS_SIDE_BOTTOM];
16150:   } else if (aSide == NS_SIDE_LEFT) {
16150:     offset.y = mBorderCornerDimensions[C_TL].height;
16150:   }
16150: 
16150:   // The sum of the width & height of the corners adjacent to the
16150:   // side.  This relies on the relationship between side indexing and
16150:   // corner indexing; that is, 0 == SIDE_TOP and 0 == CORNER_TOP_LEFT,
16150:   // with both proceeding clockwise.
41419:   gfxSize sideCornerSum = mBorderCornerDimensions[mozilla::css::Corner(aSide)]
41419:                         + mBorderCornerDimensions[mozilla::css::Corner(NEXT_SIDE(aSide))];
16150:   gfxRect rect(mOuterRect.pos + offset,
16150:                mOuterRect.size - sideCornerSum);
16150: 
16150:   if (aSide == NS_SIDE_TOP || aSide == NS_SIDE_BOTTOM)
16150:     rect.size.height = mBorderWidths[aSide];
16150:   else
16150:     rect.size.width = mBorderWidths[aSide];
16150: 
16150:   mContext->Rectangle(rect);
16150: }
16150: 
16150: // The side border type and the adjacent border types are
16150: // examined and one of the different types of clipping (listed
16150: // below) is selected.
16150: 
16150: typedef enum {
16150:   // clip to the trapezoid formed by the corners of the
16150:   // inner and outer rectangles for the given side
16150:   SIDE_CLIP_TRAPEZOID,
16150: 
16150:   // clip to the trapezoid formed by the outer rectangle
16150:   // corners and the center of the region, making sure
16150:   // that diagonal lines all go directly from the outside
16150:   // corner to the inside corner, but that they then continue on
16150:   // to the middle.
16150:   //
16150:   // This is needed for correctly clipping rounded borders,
16150:   // which might extend past the SIDE_CLIP_TRAPEZOID trap.
16150:   SIDE_CLIP_TRAPEZOID_FULL,
16150: 
16150:   // clip to the rectangle formed by the given side; a specific
16150:   // overlap algorithm is used; see the function for details.
16150:   // this is currently used for dashing.
16150:   SIDE_CLIP_RECTANGLE
16150: } SideClipType;
16150: 
57248: // Given three points, p0, p1, and midPoint, move p1 further in to the
57248: // rectangle (of which aMidPoint is the center) so that it reaches the
57248: // closer of the horizontal or vertical lines intersecting the midpoint,
57580: // while maintaing the slope of the line.  If p0 and p1 are the same,
57580: // just move p1 to midPoint (since there's no slope to maintain).
57248: // FIXME: Extending only to the midpoint isn't actually sufficient for
57248: // boxes with asymmetric radii.
16150: static void
16150: MaybeMoveToMidPoint(gfxPoint& aP0, gfxPoint& aP1, const gfxPoint& aMidPoint)
16150: {
16150:   gfxPoint ps = aP1 - aP0;
16150: 
56512:   if (ps.x == 0.0) {
56512:     if (ps.y == 0.0) {
57580:       aP1 = aMidPoint;
56512:     } else {
56512:       aP1.y = aMidPoint.y;
56512:     }
56512:   } else {
56512:     if (ps.y == 0.0) {
56512:       aP1.x = aMidPoint.x;
56512:     } else {
32531:       gfxFloat k = NS_MIN((aMidPoint.x - aP0.x) / ps.x,
57248:                           (aMidPoint.y - aP0.y) / ps.y);
16150:       aP1 = aP0 + ps * k;
16150:     }
16150:   }
56512: }
16150: 
16150: void
41419: nsCSSBorderRenderer::DoSideClipSubPath(mozilla::css::Side aSide)
16150: {
16150:   // the clip proceeds clockwise from the top left corner;
16150:   // so "start" in each case is the start of the region from that side.
16150:   //
16150:   // the final path will be formed like:
16150:   // s0 ------- e0
16150:   // |         /
16150:   // s1 ----- e1
16150:   //
16150:   // that is, the second point will always be on the inside
16150: 
16150:   gfxPoint start[2];
16150:   gfxPoint end[2];
16150: 
16150: #define IS_DASHED_OR_DOTTED(_s)  ((_s) == NS_STYLE_BORDER_STYLE_DASHED || (_s) == NS_STYLE_BORDER_STYLE_DOTTED)
16150:   PRBool isDashed      = IS_DASHED_OR_DOTTED(mBorderStyles[aSide]);
16150:   PRBool startIsDashed = IS_DASHED_OR_DOTTED(mBorderStyles[PREV_SIDE(aSide)]);
16150:   PRBool endIsDashed   = IS_DASHED_OR_DOTTED(mBorderStyles[NEXT_SIDE(aSide)]);
16150: #undef IS_DASHED_OR_DOTTED
16150: 
16150:   SideClipType startType = SIDE_CLIP_TRAPEZOID;
16150:   SideClipType endType = SIDE_CLIP_TRAPEZOID;
16150: 
41419:   if (!IsZeroSize(mBorderRadii[mozilla::css::Corner(aSide)]))
16150:     startType = SIDE_CLIP_TRAPEZOID_FULL;
16150:   else if (startIsDashed && isDashed)
16150:     startType = SIDE_CLIP_RECTANGLE;
16150: 
41419:   if (!IsZeroSize(mBorderRadii[mozilla::css::Corner(NEXT_SIDE(aSide))]))
16150:     endType = SIDE_CLIP_TRAPEZOID_FULL;
16150:   else if (endIsDashed && isDashed)
16150:     endType = SIDE_CLIP_RECTANGLE;
16150: 
16150:   gfxPoint midPoint = mInnerRect.pos + mInnerRect.size / 2.0;
16150: 
41419:   start[0] = mOuterRect.CCWCorner(aSide);
41419:   start[1] = mInnerRect.CCWCorner(aSide);
16150: 
41419:   end[0] = mOuterRect.CWCorner(aSide);
41419:   end[1] = mInnerRect.CWCorner(aSide);
16150: 
16150:   if (startType == SIDE_CLIP_TRAPEZOID_FULL) {
16150:     MaybeMoveToMidPoint(start[0], start[1], midPoint);
16150:   } else if (startType == SIDE_CLIP_RECTANGLE) {
16150:     if (aSide == NS_SIDE_TOP || aSide == NS_SIDE_BOTTOM)
41419:       start[1] = gfxPoint(mOuterRect.CCWCorner(aSide).x, mInnerRect.CCWCorner(aSide).y);
16150:     else
41419:       start[1] = gfxPoint(mInnerRect.CCWCorner(aSide).x, mOuterRect.CCWCorner(aSide).y);
16150:   }
16150: 
16150:   if (endType == SIDE_CLIP_TRAPEZOID_FULL) {
16150:     MaybeMoveToMidPoint(end[0], end[1], midPoint);
16150:   } else if (endType == SIDE_CLIP_RECTANGLE) {
16150:     if (aSide == NS_SIDE_TOP || aSide == NS_SIDE_BOTTOM)
41419:       end[0] = gfxPoint(mInnerRect.CWCorner(aSide).x, mOuterRect.CWCorner(aSide).y);
16150:     else
41419:       end[0] = gfxPoint(mOuterRect.CWCorner(aSide).x, mInnerRect.CWCorner(aSide).y);
16150:   }
16150: 
16150:   mContext->MoveTo(start[0]);
16150:   mContext->LineTo(end[0]);
16150:   mContext->LineTo(end[1]);
16150:   mContext->LineTo(start[1]);
16150:   mContext->ClosePath();
16150: }
16150: 
16150: void
16150: nsCSSBorderRenderer::FillSolidBorder(const gfxRect& aOuterRect,
16150:                                      const gfxRect& aInnerRect,
16150:                                      const gfxCornerSizes& aBorderRadii,
16150:                                      const gfxFloat *aBorderSizes,
16150:                                      PRIntn aSides,
16150:                                      const gfxRGBA& aColor)
16150: {
16150:   mContext->SetColor(aColor);
16151:   // Note that this function is allowed to draw more than just the
16151:   // requested sides.
16151: 
16151:   // If we have a border radius, do full rounded rectangles
16151:   // and fill, regardless of what sides we're asked to draw.
16151:   if (!AllCornersZeroSize(aBorderRadii)) {
16151:     gfxCornerSizes innerRadii;
16151:     ComputeInnerRadii(aBorderRadii, aBorderSizes, &innerRadii);
16150: 
16150:     mContext->NewPath();
16150: 
16150:     // do the outer border
16150:     mContext->RoundedRectangle(aOuterRect, aBorderRadii, PR_TRUE);
16150: 
16150:     // then do the inner border CCW
16150:     mContext->RoundedRectangle(aInnerRect, innerRadii, PR_FALSE);
16150: 
16150:     mContext->Fill();
16151: 
16151:     return;
16151:   }
16151: 
16151:   // If we're asked to draw all sides of an equal-sized border,
16151:   // stroking is fastest.  This is a fairly common path, but partial
16151:   // sides is probably second in the list -- there are a bunch of
16151:   // common border styles, such as inset and outset, that are
16151:   // top-left/bottom-right split.
16151:   if (aSides == SIDE_BITS_ALL &&
16151:       CheckFourFloatsEqual(aBorderSizes, aBorderSizes[0]))
16151:   {
16151:     gfxRect r(aOuterRect);
16151:     r.Inset(aBorderSizes[0] / 2.0);
16151:     mContext->SetLineWidth(aBorderSizes[0]);
16151: 
16151:     mContext->NewPath();
16151:     mContext->Rectangle(r);
16151:     mContext->Stroke();
16151: 
16151:     return;
16151:   }
16151: 
16151:   // Otherwise, we have unequal sized borders or we're only
16151:   // drawing some sides; create rectangles for each side
16151:   // and fill them.
16151: 
16151:   gfxRect r[4];
16151: 
16151:   // compute base rects for each side
16151:   if (aSides & SIDE_BIT_TOP) {
16151:     r[NS_SIDE_TOP].pos = aOuterRect.TopLeft();
16151:     r[NS_SIDE_TOP].size.width = aOuterRect.size.width;
16151:     r[NS_SIDE_TOP].size.height = aBorderSizes[NS_SIDE_TOP];
16151:   }
16151: 
16151:   if (aSides & SIDE_BIT_BOTTOM) {
16151:     r[NS_SIDE_BOTTOM].pos = aOuterRect.BottomLeft();
16151:     r[NS_SIDE_BOTTOM].pos.y -= aBorderSizes[NS_SIDE_BOTTOM];
16151:     r[NS_SIDE_BOTTOM].size.width = aOuterRect.size.width;
16151:     r[NS_SIDE_BOTTOM].size.height = aBorderSizes[NS_SIDE_BOTTOM];
16151:   }
16151: 
16151:   if (aSides & SIDE_BIT_LEFT) {
16151:     r[NS_SIDE_LEFT].pos = aOuterRect.TopLeft();
16151:     r[NS_SIDE_LEFT].size.width = aBorderSizes[NS_SIDE_LEFT];
16151:     r[NS_SIDE_LEFT].size.height = aOuterRect.size.height;
16151:   }
16151: 
16151:   if (aSides & SIDE_BIT_RIGHT) {
16151:     r[NS_SIDE_RIGHT].pos = aOuterRect.TopRight();
16151:     r[NS_SIDE_RIGHT].pos.x -= aBorderSizes[NS_SIDE_RIGHT];
16151:     r[NS_SIDE_RIGHT].size.width = aBorderSizes[NS_SIDE_RIGHT];
16151:     r[NS_SIDE_RIGHT].size.height = aOuterRect.size.height;
16151:   }
16151: 
16151:   // If two sides meet at a corner that we're rendering, then
16151:   // make sure that we adjust one of the sides to avoid overlap.
16151:   // This is especially important in the case of colors with
16151:   // an alpha channel.
16151: 
16151:   if ((aSides & (SIDE_BIT_TOP | SIDE_BIT_LEFT)) == (SIDE_BIT_TOP | SIDE_BIT_LEFT)) {
16151:     // adjust the left's top down a bit
16151:     r[NS_SIDE_LEFT].pos.y += aBorderSizes[NS_SIDE_TOP];
16151:     r[NS_SIDE_LEFT].size.height -= aBorderSizes[NS_SIDE_TOP];
16151:   }
16151: 
16151:   if ((aSides & (SIDE_BIT_TOP | SIDE_BIT_RIGHT)) == (SIDE_BIT_TOP | SIDE_BIT_RIGHT)) {
16151:     // adjust the top's left a bit
16151:     r[NS_SIDE_TOP].size.width -= aBorderSizes[NS_SIDE_RIGHT];
16151:   }
16151: 
16151:   if ((aSides & (SIDE_BIT_BOTTOM | SIDE_BIT_RIGHT)) == (SIDE_BIT_BOTTOM | SIDE_BIT_RIGHT)) {
16151:     // adjust the right's bottom a bit
16151:     r[NS_SIDE_RIGHT].size.height -= aBorderSizes[NS_SIDE_BOTTOM];
16151:   }
16151: 
16151:   if ((aSides & (SIDE_BIT_BOTTOM | SIDE_BIT_LEFT)) == (SIDE_BIT_BOTTOM | SIDE_BIT_LEFT)) {
16151:     // adjust the bottom's left a bit
16151:     r[NS_SIDE_BOTTOM].pos.x += aBorderSizes[NS_SIDE_LEFT];
16151:     r[NS_SIDE_BOTTOM].size.width -= aBorderSizes[NS_SIDE_LEFT];
16151:   }
16151: 
16151:   // Filling these one by one is faster than filling them all at once.
16151:   for (PRUint32 i = 0; i < 4; i++) {
16151:     if (aSides & (1 << i)) {
16151:       mContext->NewPath();
16151:       mContext->Rectangle(r[i]);
16151:       mContext->Fill();
16151:     }
16151:   }
16150: }
16150: 
16150: gfxRGBA
16150: MakeBorderColor(const gfxRGBA& aColor, const gfxRGBA& aBackgroundColor, BorderColorStyle aBorderColorStyle)
16150: {
16150:   nscolor colors[2];
16150:   int k = 0;
16150: 
16150:   switch (aBorderColorStyle) {
16150:     case BorderColorStyleNone:
16150:       return gfxRGBA(0.0, 0.0, 0.0, 0.0);
16150: 
16150:     case BorderColorStyleLight:
16150:       k = 1;
16150:       /* fall through */
16150:     case BorderColorStyleDark:
16150:       NS_GetSpecial3DColors(colors, aBackgroundColor.Packed(), aColor.Packed());
16150:       return gfxRGBA(colors[k]);
16150: 
16150:     case BorderColorStyleSolid:
16150:     default:
16150:       return aColor;
16150:   }
16150: }
16150: 
16150: gfxRGBA
16150: ComputeColorForLine(PRUint32 aLineIndex,
16150:                     const BorderColorStyle* aBorderColorStyle,
16150:                     PRUint32 aBorderColorStyleCount,
16150:                     nscolor aBorderColor,
16150:                     nscolor aBackgroundColor)
16150: {
16150:   NS_ASSERTION(aLineIndex < aBorderColorStyleCount, "Invalid lineIndex given");
16150: 
16150:   return MakeBorderColor(gfxRGBA(aBorderColor), gfxRGBA(aBackgroundColor), aBorderColorStyle[aLineIndex]);
16150: }
16150: 
16150: gfxRGBA
16150: ComputeCompositeColorForLine(PRUint32 aLineIndex,
16150:                              const nsBorderColors* aBorderColors)
16150: {
16150:   while (aLineIndex-- && aBorderColors->mNext)
16150:     aBorderColors = aBorderColors->mNext;
16150: 
16150:   return gfxRGBA(aBorderColors->mColor);
16150: }
16150: 
16150: void
16150: nsCSSBorderRenderer::DrawBorderSidesCompositeColors(PRIntn aSides, const nsBorderColors *aCompositeColors)
16150: {
16150:   gfxCornerSizes radii = mBorderRadii;
16150: 
16150:   // the generic composite colors path; each border is 1px in size
16150:   gfxRect soRect = mOuterRect;
16150:   gfxRect siRect;
16150:   gfxFloat maxBorderWidth = 0;
16150:   NS_FOR_CSS_SIDES (i) {
32531:     maxBorderWidth = NS_MAX(maxBorderWidth, mBorderWidths[i]);
16150:   }
16150: 
16150:   gfxFloat fakeBorderSizes[4];
16150: 
16150:   gfxRGBA lineColor;
16150:   gfxPoint tl, br;
16150: 
16150:   gfxPoint itl = mInnerRect.TopLeft();
16150:   gfxPoint ibr = mInnerRect.BottomRight();
16150: 
16150:   for (PRUint32 i = 0; i < PRUint32(maxBorderWidth); i++) {
16150:     lineColor = ComputeCompositeColorForLine(i, aCompositeColors);
16150: 
16150:     siRect = soRect;
16150:     siRect.Inset(1.0, 1.0, 1.0, 1.0);
16150: 
16150:     // now cap the rects to the real mInnerRect
16150:     tl = siRect.TopLeft();
16150:     br = siRect.BottomRight();
16150: 
32531:     tl.x = NS_MIN(tl.x, itl.x);
32531:     tl.y = NS_MIN(tl.y, itl.y);
16150: 
32531:     br.x = NS_MAX(br.x, ibr.x);
32531:     br.y = NS_MAX(br.y, ibr.y);
16150: 
16150:     siRect.pos = tl;
16150:     siRect.size.width = br.x - tl.x;
16150:     siRect.size.height = br.y - tl.y;
16150: 
16150:     fakeBorderSizes[NS_SIDE_TOP] = siRect.TopLeft().y - soRect.TopLeft().y;
16150:     fakeBorderSizes[NS_SIDE_RIGHT] = soRect.TopRight().x - siRect.TopRight().x;
16150:     fakeBorderSizes[NS_SIDE_BOTTOM] = soRect.BottomRight().y - siRect.BottomRight().y;
16150:     fakeBorderSizes[NS_SIDE_LEFT] = siRect.BottomLeft().x - soRect.BottomLeft().x;
16150: 
16150:     FillSolidBorder(soRect, siRect, radii, fakeBorderSizes, aSides, lineColor);
16150: 
16150:     soRect = siRect;
16150: 
16150:     ComputeInnerRadii(radii, fakeBorderSizes, &radii);
16150:   }
16150: }
16150: 
16150: void
16150: nsCSSBorderRenderer::DrawBorderSides(PRIntn aSides)
16150: {
16150:   if (aSides == 0 || (aSides & ~SIDE_BITS_ALL) != 0) {
16150:     NS_WARNING("DrawBorderSides: invalid sides!");
16150:     return;
16150:   }
16150: 
16150:   PRUint8 borderRenderStyle;
16150:   nscolor borderRenderColor;
16150:   const nsBorderColors *compositeColors = nsnull;
16150: 
16150:   PRUint32 borderColorStyleCount = 0;
16150:   BorderColorStyle borderColorStyleTopLeft[3], borderColorStyleBottomRight[3];
16150:   BorderColorStyle *borderColorStyle = nsnull;
16150: 
16150:   NS_FOR_CSS_SIDES (i) {
16150:     if ((aSides & (1 << i)) == 0)
16150:       continue;
16150:     borderRenderStyle = mBorderStyles[i];
16150:     borderRenderColor = mBorderColors[i];
16150:     compositeColors = mCompositeColors[i];
16150:     break;
16150:   }
16150: 
16150:   if (borderRenderStyle == NS_STYLE_BORDER_STYLE_NONE ||
16150:       borderRenderStyle == NS_STYLE_BORDER_STYLE_HIDDEN)
16150:     return;
16150: 
16150:   // -moz-border-colors is a hack; if we have it for a border, then
16150:   // it's always drawn solid, and each color is given 1px.  The last
16150:   // color is used for the remainder of the border's size.  Just
16150:   // hand off to another function to do all that.
16150:   if (compositeColors) {
16150:     DrawBorderSidesCompositeColors(aSides, compositeColors);
16150:     return;
16150:   }
16150: 
16150:   // We're not doing compositeColors, so we can calculate the
16150:   // borderColorStyle based on the specified style.  The
16150:   // borderColorStyle array goes from the outer to the inner style.
16150:   //
16150:   // If the border width is 1, we need to change the borderRenderStyle
16150:   // a bit to make sure that we get the right colors -- e.g. 'ridge'
16150:   // with a 1px border needs to look like solid, not like 'outset'.
16151:   if (mOneUnitBorder &&
16151:       (borderRenderStyle == NS_STYLE_BORDER_STYLE_RIDGE ||
16150:        borderRenderStyle == NS_STYLE_BORDER_STYLE_GROOVE ||
16151:        borderRenderStyle == NS_STYLE_BORDER_STYLE_DOUBLE))
16150:     borderRenderStyle = NS_STYLE_BORDER_STYLE_SOLID;
16150: 
16150:   switch (borderRenderStyle) {
16150:     case NS_STYLE_BORDER_STYLE_SOLID:
16150:     case NS_STYLE_BORDER_STYLE_DASHED:
16150:     case NS_STYLE_BORDER_STYLE_DOTTED:
16150:       borderColorStyleTopLeft[0] = BorderColorStyleSolid;
16150: 
16150:       borderColorStyleBottomRight[0] = BorderColorStyleSolid;
16150: 
16150:       borderColorStyleCount = 1;
16150:       break;
16150: 
16150:     case NS_STYLE_BORDER_STYLE_GROOVE:
16150:       borderColorStyleTopLeft[0] = BorderColorStyleDark;
16150:       borderColorStyleTopLeft[1] = BorderColorStyleLight;
16150: 
16150:       borderColorStyleBottomRight[0] = BorderColorStyleLight;
16150:       borderColorStyleBottomRight[1] = BorderColorStyleDark;
16150: 
16150:       borderColorStyleCount = 2;
16150:       break;
16150: 
16150:     case NS_STYLE_BORDER_STYLE_RIDGE:
16150:       borderColorStyleTopLeft[0] = BorderColorStyleLight;
16150:       borderColorStyleTopLeft[1] = BorderColorStyleDark;
16150: 
16150:       borderColorStyleBottomRight[0] = BorderColorStyleDark;
16150:       borderColorStyleBottomRight[1] = BorderColorStyleLight;
16150: 
16150:       borderColorStyleCount = 2;
16150:       break;
16150: 
16150:     case NS_STYLE_BORDER_STYLE_DOUBLE:
16150:       borderColorStyleTopLeft[0] = BorderColorStyleSolid;
16150:       borderColorStyleTopLeft[1] = BorderColorStyleNone;
16150:       borderColorStyleTopLeft[2] = BorderColorStyleSolid;
16150: 
16150:       borderColorStyleBottomRight[0] = BorderColorStyleSolid;
16150:       borderColorStyleBottomRight[1] = BorderColorStyleNone;
16150:       borderColorStyleBottomRight[2] = BorderColorStyleSolid;
16150: 
16150:       borderColorStyleCount = 3;
16150:       break;
16150: 
16150:     case NS_STYLE_BORDER_STYLE_INSET:
16150:       borderColorStyleTopLeft[0] = BorderColorStyleDark;
16150:       borderColorStyleBottomRight[0] = BorderColorStyleLight;
16150: 
16150:       borderColorStyleCount = 1;
16150:       break;
16150: 
16150:     case NS_STYLE_BORDER_STYLE_OUTSET:
16150:       borderColorStyleTopLeft[0] = BorderColorStyleLight;
16150:       borderColorStyleBottomRight[0] = BorderColorStyleDark;
16150: 
16150:       borderColorStyleCount = 1;
16150:       break;
16150: 
16150:     default:
16150:       NS_NOTREACHED("Unhandled border style!!");
16150:       break;
16150:   }
16150: 
16150:   // The only way to get to here is by having a
16150:   // borderColorStyleCount < 1 or > 3; this should never happen,
16150:   // since -moz-border-colors doesn't get handled here.
16150:   NS_ASSERTION(borderColorStyleCount > 0 && borderColorStyleCount < 4,
16150:                "Non-border-colors case with borderColorStyleCount < 1 or > 3; what happened?");
16150: 
16150:   // The caller should never give us anything with a mix
16150:   // of TL/BR if the border style would require a
16150:   // TL/BR split.
16150:   if (aSides & (SIDE_BIT_BOTTOM | SIDE_BIT_RIGHT))
16150:     borderColorStyle = borderColorStyleBottomRight;
16150:   else
16150:     borderColorStyle = borderColorStyleTopLeft;
16150: 
16150:   // Distribute the border across the available space.
16150:   gfxFloat borderWidths[3][4];
16150: 
16150:   if (borderColorStyleCount == 1) {
16150:     NS_FOR_CSS_SIDES (i) {
16150:       borderWidths[0][i] = mBorderWidths[i];
16150:     }
16150:   } else if (borderColorStyleCount == 2) {
16150:     // with 2 color styles, any extra pixel goes to the outside
16150:     NS_FOR_CSS_SIDES (i) {
16150:       borderWidths[0][i] = PRInt32(mBorderWidths[i]) / 2 + PRInt32(mBorderWidths[i]) % 2;
16150:       borderWidths[1][i] = PRInt32(mBorderWidths[i]) / 2;
16150:     }
16150:   } else if (borderColorStyleCount == 3) {
16150:     // with 3 color styles, any extra pixel (or lack of extra pixel)
16150:     // goes to the middle
16150:     NS_FOR_CSS_SIDES (i) {
16150:       if (mBorderWidths[i] == 1.0) {
16150:         borderWidths[0][i] = 1.0;
16150:         borderWidths[1][i] = borderWidths[2][i] = 0.0;
16150:       } else {
16150:         PRInt32 rest = PRInt32(mBorderWidths[i]) % 3;
16150:         borderWidths[0][i] = borderWidths[2][i] = borderWidths[1][i] = (PRInt32(mBorderWidths[i]) - rest) / 3;
16150: 
16150:         if (rest == 1) {
16150:           borderWidths[1][i] += 1.0;
16150:         } else if (rest == 2) {
16150:           borderWidths[0][i] += 1.0;
16150:           borderWidths[2][i] += 1.0;
16150:         }
16150:       }
16150:     }
16150:   }
16150: 
16150:   // make a copy that we can modify
16150:   gfxCornerSizes radii = mBorderRadii;
16150: 
16150:   gfxRect soRect(mOuterRect);
16150:   gfxRect siRect(mOuterRect);
16150: 
16150:   for (unsigned int i = 0; i < borderColorStyleCount; i++) {
16150:     // walk siRect inwards at the start of the loop to get the
16150:     // correct inner rect.
16150:     siRect.Inset(borderWidths[i]);
16150: 
16150:     if (borderColorStyle[i] != BorderColorStyleNone) {
16150:       gfxRGBA color = ComputeColorForLine(i,
16150:                                           borderColorStyle, borderColorStyleCount,
16150:                                           borderRenderColor, mBackgroundColor);
16150: 
16150:       FillSolidBorder(soRect, siRect, radii, borderWidths[i], aSides, color);
16150:     }
16150: 
16150:     ComputeInnerRadii(radii, borderWidths[i], &radii);
16150: 
16150:     // And now soRect is the same as siRect, for the next line in.
16150:     soRect = siRect;
16150:   }
16150: }
16150: 
16150: void
41419: nsCSSBorderRenderer::DrawDashedSide(mozilla::css::Side aSide)
16150: {
16150:   gfxFloat dashWidth;
16150:   gfxFloat dash[2];
16150: 
16150:   PRUint8 style = mBorderStyles[aSide];
16150:   gfxFloat borderWidth = mBorderWidths[aSide];
16150:   nscolor borderColor = mBorderColors[aSide];
16150: 
16150:   if (borderWidth == 0.0)
16150:     return;
16150: 
16150:   if (style == NS_STYLE_BORDER_STYLE_NONE ||
16150:       style == NS_STYLE_BORDER_STYLE_HIDDEN)
16150:     return;
16150: 
16150:   if (style == NS_STYLE_BORDER_STYLE_DASHED) {
16150:     dashWidth = gfxFloat(borderWidth * DOT_LENGTH * DASH_LENGTH);
16150: 
16150:     dash[0] = dashWidth;
16150:     dash[1] = dashWidth;
16150: 
16150:     mContext->SetLineCap(gfxContext::LINE_CAP_BUTT);
16150:   } else if (style == NS_STYLE_BORDER_STYLE_DOTTED) {
16150:     dashWidth = gfxFloat(borderWidth * DOT_LENGTH);
16150: 
16150:     if (borderWidth > 2.0) {
16150:       dash[0] = 0.0;
16150:       dash[1] = dashWidth * 2.0;
16150: 
16150:       mContext->SetLineCap(gfxContext::LINE_CAP_ROUND);
16150:     } else {
16150:       dash[0] = dashWidth;
16150:       dash[1] = dashWidth;
16150:     }
16150:   } else {
16150:     SF("DrawDashedSide: style: %d!!\n", style);
16150:     NS_ERROR("DrawDashedSide called with style other than DASHED or DOTTED; someone's not playing nice");
16150:     return;
16150:   }
16150: 
16150:   SF("dash: %f %f\n", dash[0], dash[1]);
16150: 
16150:   mContext->SetDash(dash, 2, 0.0);
16150: 
41419:   gfxPoint start = mOuterRect.CCWCorner(aSide);
41419:   gfxPoint end = mOuterRect.CWCorner(aSide);
16150: 
16150:   if (aSide == NS_SIDE_TOP) {
16150:     start.x += mBorderCornerDimensions[C_TL].width;
16150:     end.x -= mBorderCornerDimensions[C_TR].width;
16150: 
16150:     start.y += borderWidth / 2.0;
16150:     end.y += borderWidth / 2.0;
16150:   } else if (aSide == NS_SIDE_RIGHT) {
16150:     start.x -= borderWidth / 2.0;
16150:     end.x -= borderWidth / 2.0;
16150: 
16150:     start.y += mBorderCornerDimensions[C_TR].height;
16150:     end.y -= mBorderCornerDimensions[C_BR].height;
16150:   } else if (aSide == NS_SIDE_BOTTOM) {
16150:     start.x -= mBorderCornerDimensions[C_BR].width;
16150:     end.x += mBorderCornerDimensions[C_BL].width;
16150: 
16150:     start.y -= borderWidth / 2.0;
16150:     end.y -= borderWidth / 2.0;
16150:   } else if (aSide == NS_SIDE_LEFT) {
16150:     start.x += borderWidth / 2.0;
16150:     end.x += borderWidth / 2.0;
16150: 
16150:     start.y -= mBorderCornerDimensions[C_BL].height;
16150:     end.y += mBorderCornerDimensions[C_TL].height;
16150:   }
16150: 
16150:   mContext->NewPath();
16150:   mContext->MoveTo(start);
16150:   mContext->LineTo(end);
16150:   mContext->SetLineWidth(borderWidth);
16150:   mContext->SetColor(gfxRGBA(borderColor));
16150:   //mContext->SetColor(gfxRGBA(1.0, 0.0, 0.0, 1.0));
16150:   mContext->Stroke();
16150: }
16150: 
16150: void
58478: nsCSSBorderRenderer::SetupStrokeStyle(mozilla::css::Side aSide)
58478: {
58478:   mContext->SetColor(gfxRGBA(mBorderColors[aSide]));
58478:   mContext->SetLineWidth(mBorderWidths[aSide]);
58478: }
58478: 
58478: bool
58478: nsCSSBorderRenderer::AllBordersSameWidth()
58478: {
58478:   if (mBorderWidths[0] == mBorderWidths[1] &&
58478:       mBorderWidths[0] == mBorderWidths[2] &&
58478:       mBorderWidths[0] == mBorderWidths[3])
58478:   {
58478:     return true;
58478:   }
58478: 
58478:   return false;
58478: }
58478: 
58478: bool
58478: nsCSSBorderRenderer::AllBordersSolid(bool *aHasCompositeColors)
58478: {
58478:   *aHasCompositeColors = false;
58478:   NS_FOR_CSS_SIDES(i) {
58478:     if (mCompositeColors[i] != nsnull) {
58478:       *aHasCompositeColors = true;
58478:     }
58478:     if (mBorderStyles[i] == NS_STYLE_BORDER_STYLE_SOLID ||
58478:         mBorderStyles[i] == NS_STYLE_BORDER_STYLE_NONE ||
58478:         mBorderStyles[i] == NS_STYLE_BORDER_STYLE_HIDDEN)
58478:     {
58478:       continue;
58478:     }
58478:     return false;
58478:   }
58478: 
58478:   return true;
58478: }
58478: 
58478: bool IsVisible(int aStyle)
58478: {
58478:   if (aStyle != NS_STYLE_BORDER_STYLE_NONE &&
58478:       aStyle != NS_STYLE_BORDER_STYLE_HIDDEN) {
58478:         return true;
58478:   }
58478:   return false;
58478: }
58478: 
58478: already_AddRefed<gfxPattern>
58478: nsCSSBorderRenderer::CreateCornerGradient(mozilla::css::Corner aCorner,
58478:                                           const gfxRGBA &aFirstColor,
58478:                                           const gfxRGBA &aSecondColor)
58478: {
58478:   typedef struct { gfxFloat a, b; } twoFloats;
58478: 
58478:   const twoFloats gradientCoeff[4] = { { -1, +1 },
58478:                                        { -1, -1 },
58478:                                        { +1, -1 },
58478:                                        { +1, +1 } };
58478:   
58478:   // Sides which form the 'width' and 'height' for the calculation of the angle
58478:   // for our gradient.
58478:   const int cornerWidth[4] = { 3, 1, 1, 3 };
58478:   const int cornerHeight[4] = { 0, 0, 2, 2 };
58478: 
58478:   gfxPoint cornerOrigin = mOuterRect.AtCorner(aCorner);
58478: 
58478:   gfxPoint pat1, pat2;
58478:   pat1.x = cornerOrigin.x +
58478:     mBorderWidths[cornerHeight[aCorner]] * gradientCoeff[aCorner].a;
58478:   pat1.y = cornerOrigin.y +
58478:     mBorderWidths[cornerWidth[aCorner]]  * gradientCoeff[aCorner].b;
58478:   pat2.x = cornerOrigin.x -
58478:     mBorderWidths[cornerHeight[aCorner]] * gradientCoeff[aCorner].a;
58478:   pat2.y = cornerOrigin.y -
58478:     mBorderWidths[cornerWidth[aCorner]]  * gradientCoeff[aCorner].b;
58478: 
58478:   float gradientOffset;
58478:   
58478:   if (mContext->OriginalSurface()->GetType() == gfxASurface::SurfaceTypeD2D ||
58478:       mContext->OriginalSurface()->GetType() == gfxASurface::SurfaceTypeQuartz)
58478:   {
58478:     // On quarz this doesn't do exactly the right thing, but it does do what
58478:     // most other browsers do and doing the 'right' thing seems to be
58478:     // hard with the quartz cairo backend.
58478:     gradientOffset = 0;
58478:   } else {
58478:     // When cairo does the gradient drawing this gives us pretty nice behavior!
58478:     gradientOffset = 0.25 / sqrt(pow(mBorderWidths[cornerHeight[aCorner]], 2) +
58478:                                  pow(mBorderWidths[cornerHeight[aCorner]], 2));
58478:   }
58478: 
58478:   nsRefPtr<gfxPattern> pattern = new gfxPattern(pat1.x, pat1.y, pat2.x, pat2.y);
58478:   pattern->AddColorStop(0.5 - gradientOffset, gfxRGBA(aFirstColor));
58478:   pattern->AddColorStop(0.5 + gradientOffset, gfxRGBA(aSecondColor));
58478: 
58478:   return pattern.forget();
58478: }
58478: 
58478: typedef struct { gfxFloat a, b; } twoFloats;
58478: 
58478: void
58478: nsCSSBorderRenderer::DrawSingleWidthSolidBorder()
58478: {
58478:   // Easy enough to deal with.
58478:   mContext->SetLineWidth(1);
58478:   gfxRect rect = mOuterRect;
58478:   rect.Inset(0.5);
58478: 
58478:   const twoFloats cornerAdjusts[4] = { { +0.5,  0   },
58478:                                        {    0, +0.5 },
58478:                                        { -0.5,  0   },
58478:                                        {    0, -0.5 } };
58478: 
58478:     
58478:   NS_FOR_CSS_SIDES(side) {
58478:     gfxPoint firstCorner = rect.CCWCorner(side);
58478:     firstCorner.x += cornerAdjusts[side].a;
58478:     firstCorner.y += cornerAdjusts[side].b;
58478:     gfxPoint secondCorner = rect.CWCorner(side);
58478:     secondCorner.x += cornerAdjusts[side].a;
58478:     secondCorner.y += cornerAdjusts[side].b;
58478:         
58478:     mContext->SetColor(gfxRGBA(mBorderColors[side]));
58478:     mContext->NewPath();
58478:     mContext->MoveTo(firstCorner);
58478:     mContext->LineTo(secondCorner);
58478:     mContext->Stroke();
58478:   }
58478: }
58478: 
58478: void
58478: nsCSSBorderRenderer::DrawNoCompositeColorSolidBorder()
58478: {
58478:   const gfxFloat alpha = 0.55191497064665766025;
58478: 
58478:   const twoFloats cornerMults[4] = { { -1,  0 },
58478:                                       {  0, -1 },
58478:                                       { +1,  0 },
58478:                                       {  0, +1 } };
58478: 
58478:   const twoFloats centerAdjusts[4] = { { 0, +0.5 },
58478:                                         { -0.5, 0 },
58478:                                         { 0, -0.5 },
58478:                                         { +0.5, 0 } };
58478: 
58478:   gfxPoint pc, pci, p0, p1, p2, p3, pd, p3i;
58478: 
58478:   gfxCornerSizes innerRadii;
58478:   ComputeInnerRadii(mBorderRadii, mBorderWidths, &innerRadii);
58478: 
58478:   gfxRect strokeRect = mOuterRect;
58478:   strokeRect.Inset(mBorderWidths[0] / 2.0, mBorderWidths[1] / 2.0,
58478:                     mBorderWidths[2] / 2.0, mBorderWidths[3] / 2.0);
58478: 
58478:   NS_FOR_CSS_CORNERS(i) {
58478:       // the corner index -- either 1 2 3 0 (cw) or 0 3 2 1 (ccw)
58478:     mozilla::css::Corner c = mozilla::css::Corner((i+1) % 4);
58478:     mozilla::css::Corner prevCorner = mozilla::css::Corner(i);
58478: 
58478:     // i+2 and i+3 respectively.  These are used to index into the corner
58478:     // multiplier table, and were deduced by calculating out the long form
58478:     // of each corner and finding a pattern in the signs and values.
58478:     int i1 = (i+1) % 4;
58478:     int i2 = (i+2) % 4;
58478:     int i3 = (i+3) % 4;
58478: 
58478:     pc = mOuterRect.AtCorner(c);
58478:     pci = mInnerRect.AtCorner(c);
58478:     mContext->SetLineWidth(mBorderWidths[i]);
58478: 
58478:     nscolor firstColor, secondColor;
58478:     if (IsVisible(mBorderStyles[i]) && IsVisible(mBorderStyles[i1])) {
58478:       firstColor = mBorderColors[i];
58478:       secondColor = mBorderColors[i1];
58478:     } else if (IsVisible(mBorderStyles[i])) {
58478:       firstColor = mBorderColors[i];
58478:       secondColor = mBorderColors[i];
58478:     } else {
58478:       firstColor = mBorderColors[i1];
58478:       secondColor = mBorderColors[i1];
58478:     }
58478: 
58478:     mContext->NewPath();
58478: 
58478:     gfxPoint strokeStart, strokeEnd;
58478: 
58478:     strokeStart.x = mOuterRect.AtCorner(prevCorner).x +
58478:       mBorderCornerDimensions[prevCorner].width * cornerMults[i2].a;
58478:     strokeStart.y = mOuterRect.AtCorner(prevCorner).y +
58478:       mBorderCornerDimensions[prevCorner].height * cornerMults[i2].b;
58478: 
58478:     strokeEnd.x = pc.x + mBorderCornerDimensions[c].width * cornerMults[i].a;
58478:     strokeEnd.y = pc.y + mBorderCornerDimensions[c].height * cornerMults[i].b;
58478: 
58478:     strokeStart.x += centerAdjusts[i].a * mBorderWidths[i];
58478:     strokeStart.y += centerAdjusts[i].b * mBorderWidths[i];
58478:     strokeEnd.x += centerAdjusts[i].a * mBorderWidths[i];
58478:     strokeEnd.y += centerAdjusts[i].b * mBorderWidths[i];
58478: 
58478:     mContext->MoveTo(strokeStart);
58478:     mContext->LineTo(strokeEnd);
58478:     mContext->SetColor(gfxRGBA(mBorderColors[i]));
58478:     mContext->Stroke();
58478: 
58478:     if (firstColor != secondColor) {
58478:       nsRefPtr<gfxPattern> pattern =
58478:         CreateCornerGradient(c, firstColor, secondColor);
58478:       mContext->SetPattern(pattern);
58478:     } else {
58478:       mContext->SetColor(firstColor);
58478:     }     
58478:     
58478:     if (mBorderRadii[c].width > 0 && mBorderRadii[c].height > 0) {
58478:       p0.x = pc.x + cornerMults[i].a * mBorderRadii[c].width;
58478:       p0.y = pc.y + cornerMults[i].b * mBorderRadii[c].height;
58478: 
58478:       p3.x = pc.x + cornerMults[i3].a * mBorderRadii[c].width;
58478:       p3.y = pc.y + cornerMults[i3].b * mBorderRadii[c].height;
58478: 
58478:       p1.x = p0.x + alpha * cornerMults[i2].a * mBorderRadii[c].width;
58478:       p1.y = p0.y + alpha * cornerMults[i2].b * mBorderRadii[c].height;
58478: 
58478:       p2.x = p3.x - alpha * cornerMults[i3].a * mBorderRadii[c].width;
58478:       p2.y = p3.y - alpha * cornerMults[i3].b * mBorderRadii[c].height;
58478: 
58478:       mContext->NewPath();
58478:             
58478:       gfxPoint cornerStart;
58478:       cornerStart.x = pc.x + cornerMults[i].a * mBorderCornerDimensions[c].width;
58478:       cornerStart.y = pc.y + cornerMults[i].b * mBorderCornerDimensions[c].height;
58478: 
58478:       mContext->MoveTo(cornerStart);
58478:       mContext->LineTo(p0);
58478: 
58478:       mContext->CurveTo(p1, p2, p3);
58478:             
58478:       gfxPoint outerCornerEnd;
58478:       outerCornerEnd.x = pc.x + cornerMults[i3].a * mBorderCornerDimensions[c].width;
58478:       outerCornerEnd.y = pc.y + cornerMults[i3].b * mBorderCornerDimensions[c].height;
58478: 
58478:       mContext->LineTo(outerCornerEnd);
58478: 
58478:       p0.x = pci.x + cornerMults[i].a * innerRadii[c].width;
58478:       p0.y = pci.y + cornerMults[i].b * innerRadii[c].height;
58478: 
58478:       p3i.x = pci.x + cornerMults[i3].a * innerRadii[c].width;
58478:       p3i.y = pci.y + cornerMults[i3].b * innerRadii[c].height;
58478: 
58478:       p1.x = p0.x + alpha * cornerMults[i2].a * innerRadii[c].width;
58478:       p1.y = p0.y + alpha * cornerMults[i2].b * innerRadii[c].height;
58478: 
58478:       p2.x = p3i.x - alpha * cornerMults[i3].a * innerRadii[c].width;
58478:       p2.y = p3i.y - alpha * cornerMults[i3].b * innerRadii[c].height;
58478:       mContext->LineTo(p3i);
58478:       mContext->CurveTo(p2, p1, p0);
58478:       mContext->ClosePath();
58478:       mContext->Fill();
58478:     } else {
58478:       gfxPoint c1, c2, c3, c4;
58478: 
58478:       c1.x = pc.x + cornerMults[i].a * mBorderCornerDimensions[c].width;
58478:       c1.y = pc.y + cornerMults[i].b * mBorderCornerDimensions[c].height;
58478:       c2 = pc;
58478:       c3.x = pc.x + cornerMults[i3].a * mBorderCornerDimensions[c].width;
58478:       c3.y = pc.y + cornerMults[i3].b * mBorderCornerDimensions[c].height;
58478: 
58478:       mContext->NewPath();
58478:       mContext->MoveTo(c1);
58478:       mContext->LineTo(c2);
58478:       mContext->LineTo(c3);
58478:       mContext->LineTo(pci);
58478:       mContext->ClosePath();
58478: 
58478:       mContext->Fill();
58478:     }
58478:   }
58478: }
58478: 
58478: void
58478: nsCSSBorderRenderer::DrawRectangularCompositeColors()
58478: {
58478:   nsBorderColors *currentColors[4];
58478:   mContext->SetLineWidth(1);
58478:   memcpy(currentColors, mCompositeColors, sizeof(nsBorderColors*) * 4);
58478:   gfxRect rect = mOuterRect;
58478:   rect.Inset(0.5);
58478: 
58478:   const twoFloats cornerAdjusts[4] = { { +0.5,  0   },
58478:                                         {    0, +0.5 },
58478:                                         { -0.5,  0   },
58478:                                         {    0, -0.5 } };
58478: 
58478:   for (int i = 0; i < mBorderWidths[0]; i++) {
58478:     NS_FOR_CSS_SIDES(side) {
58478:       int sideNext = (side + 1) % 4;
58478: 
58478:       gfxPoint firstCorner = rect.CCWCorner(side);
58478:       firstCorner.x += cornerAdjusts[side].a;
58478:       firstCorner.y += cornerAdjusts[side].b;
58478:       gfxPoint secondCorner = rect.CWCorner(side);
58478:       secondCorner.x -= cornerAdjusts[side].a;
58478:       secondCorner.y -= cornerAdjusts[side].b;
58478:         
58595:       gfxRGBA currentColor =
58595:         currentColors[side] ? gfxRGBA(currentColors[side]->mColor)
58595:                             : gfxRGBA(mBorderColors[side]);
58478: 
58478:       mContext->SetColor(currentColor);
58478:       mContext->NewPath();
58478:       mContext->MoveTo(firstCorner);
58478:       mContext->LineTo(secondCorner);
58478:       mContext->Stroke();
58478: 
58478:       mContext->NewPath();
58478:       gfxPoint cornerTopLeft = rect.CWCorner(side);
58478:       cornerTopLeft.x -= 0.5;
58478:       cornerTopLeft.y -= 0.5;
58478:       mContext->Rectangle(gfxRect(cornerTopLeft, gfxSize(1, 1)));
58595:       gfxRGBA nextColor =
58595:         currentColors[sideNext] ? gfxRGBA(currentColors[sideNext]->mColor)
58595:                                 : gfxRGBA(mBorderColors[sideNext]);
58595: 
58478:       gfxRGBA cornerColor((currentColor.r + nextColor.r) / 2.0,
58478:                           (currentColor.g + nextColor.g) / 2.0,
58478:                           (currentColor.b + nextColor.b) / 2.0,
58478:                           (currentColor.a + nextColor.a) / 2.0);
58478:       mContext->SetColor(cornerColor);
58478:       mContext->Fill();
58478: 
58478:       if (side != 0) {
58478:         // We'll have to keep side 0 for the color averaging on side 3.
58595:         if (currentColors[side] && currentColors[side]->mNext) {
58478:           currentColors[side] = currentColors[side]->mNext;
58478:         }
58478:       }
58478:     }
58478:     // Now advance the color for side 0.
58595:     if (currentColors[0] && currentColors[0]->mNext) {
58478:       currentColors[0] = currentColors[0]->mNext;
58478:     }
58478:     rect.Inset(1);
58478:   }
58478: }
58478: 
58478: void
16150: nsCSSBorderRenderer::DrawBorders()
16150: {
16150:   PRBool forceSeparateCorners = PR_FALSE;
16150: 
16150:   // Examine the border style to figure out if we can draw it in one
16150:   // go or not.
16151:   PRBool tlBordersSame = AreBorderSideFinalStylesSame(SIDE_BIT_TOP | SIDE_BIT_LEFT);
16151:   PRBool brBordersSame = AreBorderSideFinalStylesSame(SIDE_BIT_BOTTOM | SIDE_BIT_RIGHT);
16150:   PRBool allBordersSame = AreBorderSideFinalStylesSame(SIDE_BITS_ALL);
16150:   if (allBordersSame &&
57124:       ((mCompositeColors[0] == NULL &&
16150:        (mBorderStyles[0] == NS_STYLE_BORDER_STYLE_NONE ||
16150:         mBorderStyles[0] == NS_STYLE_BORDER_STYLE_HIDDEN ||
57124:         mBorderColors[0] == NS_RGBA(0,0,0,0))) ||
57124:        (mCompositeColors[0] &&
57124:         (mCompositeColors[0]->mColor == NS_RGBA(0,0,0,0) &&
57124:          !mCompositeColors[0]->mNext))))
16150:   {
16150:     // All borders are the same style, and the style is either none or hidden, or the color
16150:     // is transparent.
57124:     // This also checks if the first composite color is transparent, and there are
57124:     // no others. It doesn't check if there are subsequent transparent ones, because
57124:     // that would be very silly.
16150:     return;
16150:   }
16150: 
58478:   // round mOuterRect and mInnerRect; they're already an integer
58478:   // number of pixels apart and should stay that way after
58478:   // rounding.
58478:   mOuterRect.Round();
58478:   mInnerRect.Round();
58478: 
58478:   gfxMatrix mat = mContext->CurrentMatrix();
58478: 
58478:   // Clamp the CTM to be pixel-aligned; we do this only
58478:   // for translation-only matrices now, but we could do it
58478:   // if the matrix has just a scale as well.  We should not
58478:   // do it if there's a rotation.
58478:   if (!mat.HasNonTranslation()) {
58478:     mat.x0 = floor(mat.x0 + 0.5);
58478:     mat.y0 = floor(mat.y0 + 0.5);
58478:     mContext->SetMatrix(mat);
58478:   }
58478: 
58478:   PRBool allBordersSameWidth = AllBordersSameWidth();
58478: 
58478:   PRBool allBordersSolid;
58478:   bool noCornerOutsideCenter = true;
58478: 
58478:   // First there's a couple of 'special cases' that have specifically optimized
58478:   // drawing paths, when none of these can be used we move on to the generalized
58478:   // border drawing code.
58478:   if (allBordersSame &&
58478:       mCompositeColors[0] == NULL &&
58478:       allBordersSameWidth &&
58478:       mBorderStyles[0] == NS_STYLE_BORDER_STYLE_SOLID &&
58478:       mNoBorderRadius)
58478:   {
58478:     // Very simple case.
58478:     SetupStrokeStyle(NS_SIDE_TOP);
58478:     gfxRect rect = mOuterRect;
58478:     rect.Inset(mBorderWidths[0] / 2.0);
58478:     mContext->NewPath();
58478:     mContext->Rectangle(rect);
58478:     mContext->Stroke();
58478:     return;
58478:   }
58478: 
58478:   if (allBordersSame &&
58478:       mCompositeColors[0] == NULL &&
58478:       allBordersSameWidth &&
58478:       mBorderStyles[0] == NS_STYLE_BORDER_STYLE_DOTTED &&
58478:       mBorderWidths[0] < 3 &&
58478:       mNoBorderRadius)
58478:   {
58478:     // Very simple case. We draw this rectangular dotted borner without
58478:     // antialiasing. The dots should be pixel aligned.
58478:     SetupStrokeStyle(NS_SIDE_TOP);
58478:     
58478:     gfxFloat dash = mBorderWidths[0];
58478:     mContext->SetDash(&dash, 1, 0.5);
58478:     mContext->SetAntialiasMode(gfxContext::MODE_ALIASED);
58478:     gfxRect rect = mOuterRect;
58478:     rect.Inset(mBorderWidths[0] / 2.0);
58478:     mContext->NewPath();
58478:     mContext->Rectangle(rect);
58478:     mContext->Stroke();
58478:     return;
58478:   }
58478: 
58478:   
58478:   if (allBordersSame &&
58478:       allBordersSameWidth &&
58478:       mCompositeColors[0] == NULL &&
58478:       mBorderStyles[0] == NS_STYLE_BORDER_STYLE_SOLID)
58478:   {
58478:     NS_FOR_CSS_CORNERS(i) {
58478:       if (mBorderRadii[i].width <= mBorderWidths[0]) {
58478:         noCornerOutsideCenter = false;
58478:       }
58478:       if (mBorderRadii[i].height <= mBorderWidths[0]) {
58478:         noCornerOutsideCenter = false;
58478:       }
58478:     }
58478: 
58478:     // We can only do a stroke here if all border radii centers are inside the
58478:     // inner rect, otherwise we get rendering artifacts.
58478: 
58478:     if (noCornerOutsideCenter) {
58478:       // Relatively simple case.
58478:       SetupStrokeStyle(NS_SIDE_TOP);
58478:       mOuterRect.Inset(mBorderWidths[0] / 2.0);
58478:       NS_FOR_CSS_CORNERS(corner) {
58478:         if (mBorderRadii.sizes[corner].height == 0 || mBorderRadii.sizes[corner].width == 0) {
58478:           continue;
58478:         }
58478:         mBorderRadii.sizes[corner].width -= mBorderWidths[0] / 2;
58478:         mBorderRadii.sizes[corner].height -= mBorderWidths[0] / 2;
58478:       }
58478: 
58478:       mContext->NewPath();
58478:       mContext->RoundedRectangle(mOuterRect, mBorderRadii);
58478:       mContext->Stroke();
58478:       return;
58478:     }
58478:   }
58478: 
58478:   bool hasCompositeColors;
58478: 
58478:   allBordersSolid = AllBordersSolid(&hasCompositeColors);
58478:   // This leaves the border corners non-interpolated for single width borders.
58478:   // Doing this is slightly faster and shouldn't be a problem visually.
58478:   if (allBordersSolid &&
58478:       allBordersSameWidth &&
58478:       mCompositeColors[0] == NULL &&
58478:       mBorderWidths[0] == 1 &&
58478:       mNoBorderRadius)
58478:   {
58478:     DrawSingleWidthSolidBorder();
58478:     return;
58478:   }
58478: 
58478:   if (allBordersSolid && !hasCompositeColors)
58478:   {
58478:     DrawNoCompositeColorSolidBorder();
58478:     return;
58478:   }
58478: 
58478:   if (allBordersSolid &&
58478:       allBordersSameWidth &&
58478:       mNoBorderRadius)
58478:   {
58478:     // Easy enough to deal with.
58478:     DrawRectangularCompositeColors();
58478:     return;
58478:   }
58478: 
16150:   // If we have composite colors -and- border radius,
16150:   // then use separate corners so we get OPERATOR_ADD for the corners.
16150:   // Otherwise, we'll get artifacts as we draw stacked 1px-wide curves.
16151:   if (allBordersSame && mCompositeColors[0] != nsnull && !mNoBorderRadius)
16150:     forceSeparateCorners = PR_TRUE;
16150: 
16150:   S(" mOuterRect: "), S(mOuterRect), SN();
16150:   S(" mInnerRect: "), S(mInnerRect), SN();
16150:   SF(" mBorderColors: 0x%08x 0x%08x 0x%08x 0x%08x\n", mBorderColors[0], mBorderColors[1], mBorderColors[2], mBorderColors[3]);
16150: 
16150:   // if conditioning the outside rect failed, then bail -- the outside
16150:   // rect is supposed to enclose the entire border
16150:   mOuterRect.Condition();
16150:   if (mOuterRect.IsEmpty())
16150:     return;
16150: 
16150:   mInnerRect.Condition();
58478:   PRIntn dashedSides = 0;
16150: 
16150:   NS_FOR_CSS_SIDES(i) {
16150:     PRUint8 style = mBorderStyles[i];
16150:     if (style == NS_STYLE_BORDER_STYLE_DASHED ||
16150:         style == NS_STYLE_BORDER_STYLE_DOTTED)
16150:     {
16150:       // pretend that all borders aren't the same; we need to draw
16150:       // things separately for dashed/dotting
16150:       allBordersSame = PR_FALSE;
16150:       dashedSides |= (1 << i);
16150:     }
16150:   }
16150: 
16150:   SF(" allBordersSame: %d dashedSides: 0x%02x\n", allBordersSame, dashedSides);
16150: 
16150:   if (allBordersSame && !forceSeparateCorners) {
16150:     /* Draw everything in one go */
16150:     DrawBorderSides(SIDE_BITS_ALL);
16150:     SN("---------------- (1)");
16150:   } else {
16150:     /* We have more than one pass to go.  Draw the corners separately from the sides. */
16150: 
16151:     /*
16151:      * If we have a 1px-wide border, the corners are going to be
16151:      * negligible, so don't bother doing anything fancy.  Just extend
16151:      * the top and bottom borders to the right 1px and the left border
16151:      * to the bottom 1px.  We do this by twiddling the corner dimensions,
16151:      * which causes the right to happen later on.  Only do this if we have
16151:      * a 1.0 unit border all around and no border radius.
16151:      */
16151: 
41419:     NS_FOR_CSS_CORNERS(corner) {
41419:       const mozilla::css::Side sides[2] = { mozilla::css::Side(corner), PREV_SIDE(corner) };
16151: 
16151:       if (!IsZeroSize(mBorderRadii[corner]))
16151:         continue;
16151: 
16151:       if (mBorderWidths[sides[0]] == 1.0 && mBorderWidths[sides[1]] == 1.0) {
41419:         if (corner == NS_CORNER_TOP_LEFT || corner == NS_CORNER_TOP_RIGHT)
16151:           mBorderCornerDimensions[corner].width = 0.0;
16151:         else
16151:           mBorderCornerDimensions[corner].height = 0.0;
16151:       }
16151:     }
16151: 
16150:     // First, the corners
41419:     NS_FOR_CSS_CORNERS(corner) {
16151:       // if there's no corner, don't do all this work for it
16151:       if (IsZeroSize(mBorderCornerDimensions[corner]))
16151:         continue;
16151: 
16150:       const PRIntn sides[2] = { corner, PREV_SIDE(corner) };
16150:       PRIntn sideBits = (1 << sides[0]) | (1 << sides[1]);
16150: 
16151:       PRBool simpleCornerStyle = mCompositeColors[sides[0]] == NULL &&
16151:                                  mCompositeColors[sides[1]] == NULL &&
16151:                                  AreBorderSideFinalStylesSame(sideBits);
16151: 
16151:       // If we don't have anything complex going on in this corner,
16151:       // then we can just fill the corner with a solid color, and avoid
16151:       // the potentially expensive clip.
16151:       if (simpleCornerStyle &&
16151:           IsZeroSize(mBorderRadii[corner]) &&
16151:           IsSolidCornerStyle(mBorderStyles[sides[0]], corner))
16151:       {
16151:         mContext->NewPath();
16151:         DoCornerSubPath(corner);
16151:         mContext->SetColor(MakeBorderColor(mBorderColors[sides[0]],
16151:                                            mBackgroundColor,
16151:                                            BorderColorStyleForSolidCorner(mBorderStyles[sides[0]], corner)));
16151:         mContext->Fill();
16151:         continue;
16151:       }
16151: 
16150:       mContext->Save();
16150: 
16150:       // clip to the corner
16150:       mContext->NewPath();
16151:       DoCornerSubPath(corner);
16150:       mContext->Clip();
16150: 
16151:       if (simpleCornerStyle) {
16151:         // we don't need a group for this corner, the sides are the same,
16151:         // but we weren't able to render just a solid block for the corner.
16150:         DrawBorderSides(sideBits);
16150:       } else {
16150:         // Sides are different.  We need to draw using OPERATOR_ADD to
16150:         // get correct color blending behaviour at the seam.  We need
16150:         // to do it in an offscreen surface to ensure that we're
16150:         // always compositing on transparent black.  If the colors
16150:         // don't have transparency and the current destination surface
16150:         // has an alpha channel, we could just clear the region and
16150:         // avoid the temporary, but that situation doesn't happen all
16150:         // that often in practice (we double buffer to no-alpha
16150:         // surfaces).
16150: 
16150:         mContext->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
16150:         mContext->SetOperator(gfxContext::OPERATOR_ADD);
16150: 
16150:         for (int cornerSide = 0; cornerSide < 2; cornerSide++) {
41419:           mozilla::css::Side side = mozilla::css::Side(sides[cornerSide]);
16150:           PRUint8 style = mBorderStyles[side];
16150: 
16150:           SF("corner: %d cornerSide: %d side: %d style: %d\n", corner, cornerSide, side, style);
16150: 
16150:           mContext->Save();
16150: 
16150:           mContext->NewPath();
16150:           DoSideClipSubPath(side);
16150:           mContext->Clip();
16150: 
16150:           DrawBorderSides(1 << side);
16150: 
16150:           mContext->Restore();
16150:         }
16150: 
16150:         mContext->PopGroupToSource();
16150:         mContext->SetOperator(gfxContext::OPERATOR_OVER);
16150:         mContext->Paint();
16150:       }
16150: 
16150:       mContext->Restore();
16150: 
16150:       SN();
16150:     }
16150: 
16151:     // in the case of a single-unit border, we already munged the
16151:     // corners up above; so we can just draw the top left and bottom
16151:     // right sides separately, if they're the same.
20225:     //
20225:     // We need to check for mNoBorderRadius, because when there is
20225:     // one, FillSolidBorder always draws the full rounded rectangle
20225:     // and expects there to be a clip in place.
16151:     PRIntn alreadyDrawnSides = 0;
20225:     if (mOneUnitBorder &&
20225:         mNoBorderRadius &&
20225:         (dashedSides & (SIDE_BIT_TOP | SIDE_BIT_LEFT)) == 0)
20225:     {
16151:       if (tlBordersSame) {
16151:         DrawBorderSides(SIDE_BIT_TOP | SIDE_BIT_LEFT);
16151:         alreadyDrawnSides |= (SIDE_BIT_TOP | SIDE_BIT_LEFT);
16151:       }
16151: 
16151:       if (brBordersSame && (dashedSides & (SIDE_BIT_BOTTOM | SIDE_BIT_RIGHT)) == 0) {
16151:         DrawBorderSides(SIDE_BIT_BOTTOM | SIDE_BIT_RIGHT);
16151:         alreadyDrawnSides |= (SIDE_BIT_BOTTOM | SIDE_BIT_RIGHT);
16151:       }
16151:     }
16151: 
16150:     // We're done with the corners, now draw the sides.
16150:     NS_FOR_CSS_SIDES (side) {
16151:       // if we drew it above, skip it
16151:       if (alreadyDrawnSides & (1 << side))
16151:         continue;
16151: 
16151:       // If there's no border on this side, skip it
16151:       if (mBorderWidths[side] == 0.0 ||
16151:           mBorderStyles[side] == NS_STYLE_BORDER_STYLE_HIDDEN ||
16151:           mBorderStyles[side] == NS_STYLE_BORDER_STYLE_NONE)
16151:         continue;
16151: 
16151: 
16151:       if (dashedSides & (1 << side)) {
16151:         // Dashed sides will always draw just the part ignoring the
16151:         // corners for the side, so no need to clip.
16151:         DrawDashedSide (side);
16151: 
16151:         SN("---------------- (d)");
16151:         continue;
16151:       }
16151: 
16151:       // Undashed sides will currently draw the entire side,
16151:       // including parts that would normally be covered by a corner,
16151:       // so we need to clip.
16151:       //
16151:       // XXX Optimization -- it would be good to make this work like
16151:       // DrawDashedSide, and have a DrawOneSide function that just
16151:       // draws one side and not the corners, because then we can
16151:       // avoid the potentially expensive clip.
16150:       mContext->Save();
16150:       mContext->NewPath();
16150:       DoSideClipWithoutCornersSubPath(side);
16150:       mContext->Clip();
16150: 
16150:       DrawBorderSides(1 << side);
16151: 
16151:       mContext->Restore();
16151: 
16150:       SN("---------------- (*)");
16150:     }
16150:   }
16150: }
