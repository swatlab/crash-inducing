     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
163122: // IWYU pragma: private, include "nsString.h"
     1: 
     1: #ifndef nsReadableUtils_h___
     1: #define nsReadableUtils_h___
     1: 
     1:   /**
     1:    * I guess all the routines in this file are all mis-named.
     1:    * According to our conventions, they should be |NS_xxx|.
     1:    */
     1: 
     1: #ifndef nsAString_h___
     1: #include "nsAString.h"
     1: #endif
136246: 
136246: template<class E> class nsTArray;
     1: 
179103: inline size_t Distance( const nsReadingIterator<char16_t>& start, const nsReadingIterator<char16_t>& end )
     1:   {
     1:     return end.get() - start.get();
     1:   }
     1: inline size_t Distance( const nsReadingIterator<char>& start, const nsReadingIterator<char>& end )
     1:   {
     1:     return end.get() - start.get();
     1:   }
     1: 
106217: void LossyCopyUTF16toASCII( const nsAString& aSource, nsACString& aDest );
106217: void CopyASCIItoUTF16( const nsACString& aSource, nsAString& aDest );
     1: 
179103: void LossyCopyUTF16toASCII( const char16_t* aSource, nsACString& aDest );
106217: void CopyASCIItoUTF16( const char* aSource, nsAString& aDest );
     1: 
106217: void CopyUTF16toUTF8( const nsAString& aSource, nsACString& aDest );
106217: void CopyUTF8toUTF16( const nsACString& aSource, nsAString& aDest );
     1: 
179103: void CopyUTF16toUTF8( const char16_t* aSource, nsACString& aDest );
106217: void CopyUTF8toUTF16( const char* aSource, nsAString& aDest );
     1: 
 76805: void LossyAppendUTF16toASCII( const nsAString& aSource, nsACString& aDest );
 76805: void AppendASCIItoUTF16( const nsACString& aSource, nsAString& aDest );
186279: bool AppendASCIItoUTF16( const nsACString& aSource, nsAString& aDest,
186279:                          const mozilla::fallible_t& ) NS_WARN_UNUSED_RESULT;
     1: 
179103: void LossyAppendUTF16toASCII( const char16_t* aSource, nsACString& aDest );
 76805: void AppendASCIItoUTF16( const char* aSource, nsAString& aDest );
     1: 
 76805: void AppendUTF16toUTF8( const nsAString& aSource, nsACString& aDest );
179373: bool AppendUTF16toUTF8( const nsAString& aSource, nsACString& aDest,
179373:                         const mozilla::fallible_t& ) NS_WARN_UNUSED_RESULT;
 76805: void AppendUTF8toUTF16( const nsACString& aSource, nsAString& aDest );
135452: bool AppendUTF8toUTF16( const nsACString& aSource, nsAString& aDest,
135452:                         const mozilla::fallible_t& ) NS_WARN_UNUSED_RESULT;
     1: 
179103: void AppendUTF16toUTF8( const char16_t* aSource, nsACString& aDest );
 76805: void AppendUTF8toUTF16( const char* aSource, nsAString& aDest );
     1: 
173417: #ifdef MOZ_USE_CHAR16_WRAPPER
173417: inline void AppendUTF16toUTF8( char16ptr_t aSource, nsACString& aDest )
173417:   {
173417:     return AppendUTF16toUTF8(static_cast<const char16_t*>(aSource), aDest);
173417:   }
173417: #endif
173417: 
     1:   /**
     1:    * Returns a new |char| buffer containing a zero-terminated copy of |aSource|.
     1:    *
     1:    * Allocates and returns a new |char| buffer which you must free with |nsMemory::Free|.
     1:    * Performs a lossy encoding conversion by chopping 16-bit wide characters down to 8-bits wide while copying |aSource| to your new buffer.
     1:    * This conversion is not well defined; but it reproduces legacy string behavior.
     1:    * The new buffer is zero-terminated, but that may not help you if |aSource| contains embedded nulls.
     1:    *
     1:    * @param aSource a 16-bit wide string
     1:    * @return a new |char| buffer you must free with |nsMemory::Free|.
     1:    */
 76805: char* ToNewCString( const nsAString& aSource );
     1: 
     1: 
     1:   /**
     1:    * Returns a new |char| buffer containing a zero-terminated copy of |aSource|.
     1:    *
     1:    * Allocates and returns a new |char| buffer which you must free with |nsMemory::Free|.
     1:    * The new buffer is zero-terminated, but that may not help you if |aSource| contains embedded nulls.
     1:    *
     1:    * @param aSource an 8-bit wide string
     1:    * @return a new |char| buffer you must free with |nsMemory::Free|.
     1:    */
 76805: char* ToNewCString( const nsACString& aSource );
     1: 
     1:   /**
     1:    * Returns a new |char| buffer containing a zero-terminated copy of |aSource|.
     1:    *
     1:    * Allocates and returns a new |char| buffer which you must free with 
     1:    * |nsMemory::Free|.
     1:    * Performs an encoding conversion from a UTF-16 string to a UTF-8 string
     1:    * copying |aSource| to your new buffer.
     1:    * The new buffer is zero-terminated, but that may not help you if |aSource| 
     1:    * contains embedded nulls.
     1:    *
179103:    * @param aSource a UTF-16 string (made of char16_t's)
     1:    * @param aUTF8Count the number of 8-bit units that was returned
     1:    * @return a new |char| buffer you must free with |nsMemory::Free|.
     1:    */
     1: 
108991: char* ToNewUTF8String( const nsAString& aSource, uint32_t *aUTF8Count = nullptr );
     1: 
     1: 
     1:   /**
179103:    * Returns a new |char16_t| buffer containing a zero-terminated copy of 
     1:    * |aSource|.
     1:    *
179103:    * Allocates and returns a new |char16_t| buffer which you must free with 
     1:    * |nsMemory::Free|.
     1:    * The new buffer is zero-terminated, but that may not help you if |aSource| 
     1:    * contains embedded nulls.
     1:    *
     1:    * @param aSource a UTF-16 string
179103:    * @return a new |char16_t| buffer you must free with |nsMemory::Free|.
     1:    */
179103: char16_t* ToNewUnicode( const nsAString& aSource );
     1: 
     1: 
     1:   /**
179103:    * Returns a new |char16_t| buffer containing a zero-terminated copy of |aSource|.
     1:    *
179103:    * Allocates and returns a new |char16_t| buffer which you must free with |nsMemory::Free|.
     1:    * Performs an encoding conversion by 0-padding 8-bit wide characters up to 16-bits wide while copying |aSource| to your new buffer.
     1:    * This conversion is not well defined; but it reproduces legacy string behavior.
     1:    * The new buffer is zero-terminated, but that may not help you if |aSource| contains embedded nulls.
     1:    *
     1:    * @param aSource an 8-bit wide string (a C-string, NOT UTF-8)
179103:    * @return a new |char16_t| buffer you must free with |nsMemory::Free|.
     1:    */
179103: char16_t* ToNewUnicode( const nsACString& aSource );
     1: 
     1:   /**
179103:    * Returns the required length for a char16_t buffer holding
130890:    * a copy of aSource, using UTF-8 to UTF-16 conversion.
130890:    * The length does NOT include any space for zero-termination.
130890:    *
130890:    * @param aSource an 8-bit wide string, UTF-8 encoded
130890:    * @return length of UTF-16 encoded string copy, not zero-terminated
130890:    */
130890: uint32_t CalcUTF8ToUnicodeLength( const nsACString& aSource );
130890: 
130890:   /**
130890:    * Copies the source string into the specified buffer, converting UTF-8 to
130890:    * UTF-16 in the process. The conversion is well defined for valid UTF-8
130890:    * strings.
130890:    * The copied string will be zero-terminated! Any embedded nulls will be
130890:    * copied nonetheless. It is the caller's responsiblity to ensure the buffer
179103:    * is large enough to hold the string copy plus one char16_t for
130890:    * zero-termination!
130890:    *
130890:    * @see CalcUTF8ToUnicodeLength( const nsACString& )
130890:    * @see UTF8ToNewUnicode( const nsACString&, uint32_t* )
130890:    *
130890:    * @param aSource an 8-bit wide string, UTF-8 encoded
130890:    * @param aBuffer the buffer holding the converted string copy
130890:    * @param aUTF16Count receiving optionally the number of 16-bit units that
130890:    *                    were copied
130890:    * @return aBuffer pointer, for convenience 
130890:    */
179103: char16_t* UTF8ToUnicodeBuffer( const nsACString& aSource,
179103:                                 char16_t *aBuffer,
130890:                                 uint32_t *aUTF16Count = nullptr );
130890: 
130890:   /**
179103:    * Returns a new |char16_t| buffer containing a zero-terminated copy
     1:    * of |aSource|.
     1:    *
     1:    * Allocates and returns a new |char| buffer which you must free with
     1:    * |nsMemory::Free|.  Performs an encoding conversion from UTF-8 to UTF-16 
     1:    * while copying |aSource| to your new buffer.  This conversion is well defined
     1:    * for a valid UTF-8 string.  The new buffer is zero-terminated, but that 
     1:    * may not help you if |aSource| contains embedded nulls.
     1:    *
     1:    * @param aSource an 8-bit wide string, UTF-8 encoded
     1:    * @param aUTF16Count the number of 16-bit units that was returned
179103:    * @return a new |char16_t| buffer you must free with |nsMemory::Free|.
     1:    *         (UTF-16 encoded)
     1:    */
179103: char16_t* UTF8ToNewUnicode( const nsACString& aSource, uint32_t *aUTF16Count = nullptr );
     1: 
     1:   /**
     1:    * Copies |aLength| 16-bit code units from the start of |aSource| to the
179103:    * |char16_t| buffer |aDest|.
     1:    *
     1:    * After this operation |aDest| is not null terminated.
     1:    *
     1:    * @param aSource a UTF-16 string
     1:    * @param aSrcOffset start offset in the source string
179103:    * @param aDest a |char16_t| buffer
     1:    * @param aLength the number of 16-bit code units to copy
     1:    * @return pointer to destination buffer - identical to |aDest|
     1:    */
179103: char16_t* CopyUnicodeTo( const nsAString& aSource,
108991:                                  uint32_t aSrcOffset,
179103:                                  char16_t* aDest,
108991:                                  uint32_t aLength );
     1: 
     1: 
     1:   /**
     1:    * Copies 16-bit characters between iterators |aSrcStart| and
     1:    * |aSrcEnd| to the writable string |aDest|. Similar to the
     1:    * |nsString::Mid| method.
     1:    *
     1:    * After this operation |aDest| is not null terminated.
     1:    *
     1:    * @param aSrcStart start source iterator
     1:    * @param aSrcEnd end source iterator
     1:    * @param aDest destination for the copy
     1:    */
 76805: void CopyUnicodeTo( const nsAString::const_iterator& aSrcStart,
     1:                            const nsAString::const_iterator& aSrcEnd,
     1:                            nsAString& aDest );
     1: 
     1:   /**
     1:    * Appends 16-bit characters between iterators |aSrcStart| and
     1:    * |aSrcEnd| to the writable string |aDest|. 
     1:    *
     1:    * After this operation |aDest| is not null terminated.
     1:    *
     1:    * @param aSrcStart start source iterator
     1:    * @param aSrcEnd end source iterator
     1:    * @param aDest destination for the copy
     1:    */
 76805: void AppendUnicodeTo( const nsAString::const_iterator& aSrcStart,
     1:                              const nsAString::const_iterator& aSrcEnd,
     1:                              nsAString& aDest );
     1: 
     1:   /**
 80486:    * Returns |true| if |aString| contains only ASCII characters, that is, characters in the range (0x00, 0x7F).
     1:    *
     1:    * @param aString a 16-bit wide string to scan
     1:    */
 79445: bool IsASCII( const nsAString& aString );
     1: 
     1:   /**
 80486:    * Returns |true| if |aString| contains only ASCII characters, that is, characters in the range (0x00, 0x7F).
     1:    *
     1:    * @param aString a 8-bit wide string to scan
     1:    */
 79445: bool IsASCII( const nsACString& aString );
     1: 
     1:   /**
 80486:    * Returns |true| if |aString| is a valid UTF-8 string.
     1:    * XXX This is not bullet-proof and nor an all-purpose UTF-8 validator. 
     1:    * It is mainly written to replace and roughly equivalent to
     1:    *
     1:    *    str.Equals(NS_ConvertUTF16toUTF8(NS_ConvertUTF8toUTF16(str)))
     1:    *
     1:    * (see bug 191541)
     1:    * As such,  it does not check for non-UTF-8 7bit encodings such as 
 78539:    * ISO-2022-JP and HZ. 
 78539:    *
 78539:    * It rejects sequences with the following errors:
 78539:    *
 78539:    * byte sequences that cannot be decoded into characters according to
 78539:    *   UTF-8's rules (including cases where the input is part of a valid
 78539:    *   UTF-8 sequence but starts or ends mid-character)
 78539:    * overlong sequences (i.e., cases where a character was encoded
 78539:    *   non-canonically by using more bytes than necessary)
 78539:    * surrogate codepoints (i.e., the codepoints reserved for
 78539:        representing astral characters in UTF-16)
 78539:    * codepoints above the unicode range (i.e., outside the first 17
 78539:    *   planes; higher than U+10FFFF), in accordance with
 78539:    *   http://tools.ietf.org/html/rfc3629
 78539:    * when aRejectNonChar is true (the default), any codepoint whose low
 78539:    *   16 bits are 0xFFFE or 0xFFFF
 78539: 
     1:    *
     1:    * @param aString an 8-bit wide string to scan
 78539:    * @param aRejectNonChar a boolean to control the rejection of utf-8
 78539:    *        non characters
     1:    */
 79445: bool IsUTF8( const nsACString& aString, bool aRejectNonChar = true );
     1: 
 79445: bool ParseString(const nsACString& aAstring, char aDelimiter, 
 24031:                           nsTArray<nsCString>& aArray);
     1: 
     1:   /**
     1:    * Converts case in place in the argument string.
     1:    */
 76805: void ToUpperCase( nsACString& );
     1: 
 76805: void ToLowerCase( nsACString& );
     1: 
 76805: void ToUpperCase( nsCSubstring& );
     1: 
 76805: void ToLowerCase( nsCSubstring& );
     1: 
     1:   /**
     1:    * Converts case from string aSource to aDest.
     1:    */
 76805: void ToUpperCase( const nsACString& aSource, nsACString& aDest );
     1: 
 76805: void ToLowerCase( const nsACString& aSource, nsACString& aDest );
     1: 
     1:   /**
     1:    * Finds the leftmost occurrence of |aPattern|, if any in the range |aSearchStart|..|aSearchEnd|.
     1:    *
 80486:    * Returns |true| if a match was found, and adjusts |aSearchStart| and |aSearchEnd| to
 80486:    * point to the match.  If no match was found, returns |false| and makes |aSearchStart == aSearchEnd|.
     1:    *
     1:    * Currently, this is equivalent to the O(m*n) implementation previously on |ns[C]String|.
     1:    * If we need something faster, then we can implement that later.
     1:    */
     1: 
 79445: bool FindInReadable( const nsAString& aPattern, nsAString::const_iterator&, nsAString::const_iterator&, const nsStringComparator& = nsDefaultStringComparator() );
 79445: bool FindInReadable( const nsACString& aPattern, nsACString::const_iterator&, nsACString::const_iterator&, const nsCStringComparator& = nsDefaultCStringComparator() );
     1: 
     1: /* sometimes we don't care about where the string was, just that we
     1:  * found it or not */
 79445: inline bool FindInReadable( const nsAString& aPattern, const nsAString& aSource, const nsStringComparator& compare = nsDefaultStringComparator() )
     1: {
     1:   nsAString::const_iterator start, end;
     1:   aSource.BeginReading(start);
     1:   aSource.EndReading(end);
     1:   return FindInReadable(aPattern, start, end, compare);
     1: }
     1: 
 79445: inline bool FindInReadable( const nsACString& aPattern, const nsACString& aSource, const nsCStringComparator& compare = nsDefaultCStringComparator() )
     1: {
     1:   nsACString::const_iterator start, end;
     1:   aSource.BeginReading(start);
     1:   aSource.EndReading(end);
     1:   return FindInReadable(aPattern, start, end, compare);
     1: }
     1: 
     1: 
 79445: bool CaseInsensitiveFindInReadable( const nsACString& aPattern, nsACString::const_iterator&, nsACString::const_iterator& );
     1: 
     1:   /**
     1:    * Finds the rightmost occurrence of |aPattern| 
 80486:    * Returns |true| if a match was found, and adjusts |aSearchStart| and |aSearchEnd| to
 80486:    * point to the match.  If no match was found, returns |false| and makes |aSearchStart == aSearchEnd|.
     1:    *
     1:    */
 79445: bool RFindInReadable( const nsAString& aPattern, nsAString::const_iterator&, nsAString::const_iterator&, const nsStringComparator& = nsDefaultStringComparator() );
 79445: bool RFindInReadable( const nsACString& aPattern, nsACString::const_iterator&, nsACString::const_iterator&, const nsCStringComparator& = nsDefaultCStringComparator() );
     1: 
     1:    /**
     1:    * Finds the leftmost occurrence of |aChar|, if any in the range 
     1:    * |aSearchStart|..|aSearchEnd|.
     1:    *
 80486:    * Returns |true| if a match was found, and adjusts |aSearchStart| to
 80486:    * point to the match.  If no match was found, returns |false| and 
     1:    * makes |aSearchStart == aSearchEnd|.
     1:    */
179103: bool FindCharInReadable( char16_t aChar, nsAString::const_iterator& aSearchStart, const nsAString::const_iterator& aSearchEnd );
 79445: bool FindCharInReadable( char aChar, nsACString::const_iterator& aSearchStart, const nsACString::const_iterator& aSearchEnd );
     1: 
     1:     /**
     1:     * Finds the number of occurences of |aChar| in the string |aStr|
     1:     */
108991: uint32_t CountCharInReadable( const nsAString& aStr,
179103:                                      char16_t aChar );
108991: uint32_t CountCharInReadable( const nsACString& aStr,
     1:                                      char aChar );
     1: 
 79445: bool
     1: StringBeginsWith( const nsAString& aSource, const nsAString& aSubstring,
     1:                   const nsStringComparator& aComparator =
     1:                                               nsDefaultStringComparator() );
 79445: bool
     1: StringBeginsWith( const nsACString& aSource, const nsACString& aSubstring,
     1:                   const nsCStringComparator& aComparator =
     1:                                                nsDefaultCStringComparator() );
 79445: bool
     1: StringEndsWith( const nsAString& aSource, const nsAString& aSubstring,
     1:                 const nsStringComparator& aComparator =
     1:                                             nsDefaultStringComparator() );
 79445: bool
     1: StringEndsWith( const nsACString& aSource, const nsACString& aSubstring,
     1:                 const nsCStringComparator& aComparator =
     1:                                              nsDefaultCStringComparator() );
     1: 
 76805: const nsAFlatString& EmptyString();
 76805: const nsAFlatCString& EmptyCString();
     1: 
 85953: const nsAFlatString& NullString();
 85953: const nsAFlatCString& NullCString();
 85953: 
     1:    /**
     1:    * Compare a UTF-8 string to an UTF-16 string.
     1:    *
     1:    * Returns 0 if the strings are equal, -1 if aUTF8String is less
     1:    * than aUTF16Count, and 1 in the reverse case.  In case of fatal
     1:    * error (eg the strings are not valid UTF8 and UTF16 respectively),
115367:    * this method will return INT32_MIN.
     1:    */
108991: int32_t
     1: CompareUTF8toUTF16(const nsASingleFragmentCString& aUTF8String,
     1:                    const nsASingleFragmentString& aUTF16String);
     1: 
 76805: void
108991: AppendUCS4ToUTF16(const uint32_t aSource, nsAString& aDest);
     1: 
     1: template<class T>
108991: inline bool EnsureStringLength(T& aStr, uint32_t aLen)
     1: {
     1:     aStr.SetLength(aLen);
     1:     return (aStr.Length() == aLen);
     1: }
     1: 
     1: #endif // !defined(nsReadableUtils_h___)
