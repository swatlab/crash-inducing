    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla.com.
    1:  * Portions created by the Initial Developer are Copyright (C) 2006
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *         Boris Zbarsky <bzbarsky@mit.edu> (Original Author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsINode_h___
    1: #define nsINode_h___
    1: 
72326: #include "nsIDOMEventTarget.h"
    1: #include "nsEvent.h"
    1: #include "nsPropertyTable.h"
    1: #include "nsTObserverArray.h"
94340: #include "nsINodeInfo.h"
    1: #include "nsCOMPtr.h"
21618: #include "nsWrapperCache.h"
28073: #include "nsIProgrammingLanguage.h" // for ::JAVASCRIPT
39585: #include "nsDOMError.h"
41907: #include "nsDOMString.h"
77149: #include "jspubtd.h"
91414: #include "nsWindowMemoryReporter.h"
81389: #include "nsIVariant.h"
89350: #include "nsGkAtoms.h"
    1: 
81334: // Including 'windows.h' will #define GetClassInfo to something else.
81334: #ifdef XP_WIN
81334: #ifdef GetClassInfo
81334: #undef GetClassInfo
81334: #endif
81334: #endif
81334: 
    1: class nsIContent;
    1: class nsIDocument;
    1: class nsIDOMEvent;
23258: class nsIDOMNode;
78189: class nsIDOMElement;
23258: class nsIDOMNodeList;
24403: class nsINodeList;
11914: class nsIPresShell;
  723: class nsEventChainVisitor;
    1: class nsEventChainPreVisitor;
    1: class nsEventChainPostVisitor;
72328: class nsEventListenerManager;
    1: class nsIPrincipal;
    1: class nsIMutationObserver;
    1: class nsChildContentList;
    1: class nsNodeWeakReference;
    1: class nsNodeSupportsWeakRefTearoff;
11914: class nsIEditor;
41902: class nsIDOMUserDataHandler;
42104: class nsAttrAndChildArray;
48124: class nsXPCClassInfo;
    1: 
41632: namespace mozilla {
41632: namespace dom {
41632: class Element;
41632: } // namespace dom
41632: } // namespace mozilla
41632: 
 3303: enum {
91087:   // This bit will be set if the node has a listener manager.
67611:   NODE_HAS_LISTENERMANAGER =     0x00000001U,
    1: 
    1:   // Whether this node has had any properties set on it
67611:   NODE_HAS_PROPERTIES =          0x00000002U,
    1: 
25511:   // Whether this node is the root of an anonymous subtree.  Note that this
25511:   // need not be a native anonymous subtree.  Any anonymous subtree, including
25511:   // XBL-generated ones, will do.  This flag is set-once: once a node has it,
25511:   // it must not be removed.
    1:   // NOTE: Should only be used on nsIContent nodes
67611:   NODE_IS_ANONYMOUS =            0x00000004U,
    1: 
25511:   // Whether the node has some ancestor, possibly itself, that is native
25511:   // anonymous.  This includes ancestors crossing XBL scopes, in cases when an
25511:   // XBL binding is attached to an element which has a native anonymous
25511:   // ancestor.  This flag is set-once: once a node has it, it must not be
25511:   // removed.
25511:   // NOTE: Should only be used on nsIContent nodes
67611:   NODE_IS_IN_ANONYMOUS_SUBTREE = 0x00000008U,
14239: 
25511:   // Whether this node is the root of a native anonymous (from the perspective
25511:   // of its parent) subtree.  This flag is set-once: once a node has it, it
25511:   // must not be removed.
25511:   // NOTE: Should only be used on nsIContent nodes
67611:   NODE_IS_NATIVE_ANONYMOUS_ROOT = 0x00000010U,
25511: 
 1684:   // Forces the XBL code to treat this node as if it were
 1684:   // in the document and therefore should get bindings attached.
67611:   NODE_FORCE_XBL_BINDINGS =      0x00000020U,
 1353: 
 1376:   // Whether a binding manager may have a pointer to this
67611:   NODE_MAY_BE_IN_BINDING_MNGR =  0x00000040U,
 1376: 
67611:   NODE_IS_EDITABLE =             0x00000080U,
 2896: 
19132:   // For all Element nodes, NODE_MAY_HAVE_CLASS is guaranteed to be set if the
19132:   // node in fact has a class, but may be set even if it doesn't.
67611:   NODE_MAY_HAVE_CLASS =          0x00000100U,
 6041: 
67611:   NODE_IS_INSERTION_PARENT =     0x00000200U,
 6864: 
11845:   // Node has an :empty or :-moz-only-whitespace selector
67611:   NODE_HAS_EMPTY_SELECTOR =      0x00000400U,
11845: 
11845:   // A child of the node has a selector such that any insertion,
11845:   // removal, or appending of children requires restyling the parent.
67611:   NODE_HAS_SLOW_SELECTOR =       0x00000800U,
11845: 
11845:   // A child of the node has a :first-child, :-moz-first-node,
11845:   // :only-child, :last-child or :-moz-last-node selector.
67611:   NODE_HAS_EDGE_CHILD_SELECTOR = 0x00001000U,
11845: 
11845:   // A child of the node has a selector such that any insertion or
42350:   // removal of children requires restyling later siblings of that
42350:   // element.  Additionally (in this manner it is stronger than
42350:   // NODE_HAS_SLOW_SELECTOR), if a child's style changes due to any
42350:   // other content tree changes (e.g., the child changes to or from
42350:   // matching :empty due to a grandchild insertion or removal), the
42350:   // child's later siblings must also be restyled.
42350:   NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS
67611:                                = 0x00002000U,
11845: 
11845:   NODE_ALL_SELECTOR_FLAGS =      NODE_HAS_EMPTY_SELECTOR |
11845:                                  NODE_HAS_SLOW_SELECTOR |
11845:                                  NODE_HAS_EDGE_CHILD_SELECTOR |
42350:                                  NODE_HAS_SLOW_SELECTOR_LATER_SIBLINGS,
11845: 
30001:   NODE_ATTACH_BINDING_ON_POSTCREATE
67611:                                = 0x00004000U,
30001: 
40936:   // This node needs to go through frame construction to get a frame (or
40936:   // undisplayed entry).
67611:   NODE_NEEDS_FRAME =             0x00008000U,
40936: 
40936:   // At least one descendant in the flattened tree has NODE_NEEDS_FRAME set.
40936:   // This should be set on every node on the flattened tree path between the
40936:   // node(s) with NODE_NEEDS_FRAME and the root content.
67611:   NODE_DESCENDANTS_NEED_FRAMES = 0x00010000U,
41631: 
43077:   // Set if the node has the accesskey attribute set.
67611:   NODE_HAS_ACCESSKEY           = 0x00020000U,
43079: 
67818:   // Set if the node is handling a click.
67818:   NODE_HANDLING_CLICK          = 0x00040000U,
67818: 
92184:   // Set if the node has had :hover selectors matched against it
92184:   NODE_HAS_RELEVANT_HOVER_RULES = 0x00080000U,
92184: 
    1:   // Remaining bits are node type specific.
94563:   NODE_TYPE_SPECIFIC_BITS_OFFSET =        20
 3303: };
    1: 
 3303: // Useful inline function for getting a node given an nsIContent and an
 3303: // nsIDocument.  Returns the first argument cast to nsINode if it is non-null,
 3303: // otherwise returns the second (which may be null).  We use type variables
 3303: // instead of nsIContent* and nsIDocument* because the actual types must be
 3303: // known for the cast to work.
 3303: template<class C, class D>
 3303: inline nsINode* NODE_FROM(C& aContent, D& aDocument)
 3303: {
 3303:   if (aContent)
 3303:     return static_cast<nsINode*>(aContent);
 3303:   return static_cast<nsINode*>(aDocument);
 3303: }
    1: 
27150: /**
27150:  * Class used to detect unexpected mutations. To use the class create an
27150:  * nsMutationGuard on the stack before unexpected mutations could occur.
27150:  * You can then at any time call Mutated to check if any unexpected mutations
42263:  * have occurred.
27150:  *
27150:  * When a guard is instantiated sMutationCount is set to 300. It is then
27150:  * decremented by every mutation (capped at 0). This means that we can only
27150:  * detect 300 mutations during the lifetime of a single guard, however that
27150:  * should be more then we ever care about as we usually only care if more then
42263:  * one mutation has occurred.
27150:  *
27150:  * When the guard goes out of scope it will adjust sMutationCount so that over
27150:  * the lifetime of the guard the guard itself has not affected sMutationCount,
27150:  * while mutations that happened while the guard was alive still will. This
27150:  * allows a guard to be instantiated even if there is another guard higher up
27150:  * on the callstack watching for mutations.
27150:  *
27150:  * The only thing that has to be avoided is for an outer guard to be used
27150:  * while an inner guard is alive. This can be avoided by only ever
27150:  * instantiating a single guard per scope and only using the guard in the
27150:  * current scope.
27150:  */
27150: class nsMutationGuard {
27150: public:
27150:   nsMutationGuard()
27150:   {
27150:     mDelta = eMaxMutations - sMutationCount;
27150:     sMutationCount = eMaxMutations;
27150:   }
27150:   ~nsMutationGuard()
27150:   {
27150:     sMutationCount =
27150:       mDelta > sMutationCount ? 0 : sMutationCount - mDelta;
27150:   }
27150: 
27150:   /**
42263:    * Returns true if any unexpected mutations have occurred. You can pass in
27150:    * an 8-bit ignore count to ignore a number of expected mutations.
27150:    */
79445:   bool Mutated(PRUint8 aIgnoreCount)
27150:   {
27150:     return sMutationCount < static_cast<PRUint32>(eMaxMutations - aIgnoreCount);
27150:   }
27150: 
27150:   // This function should be called whenever a mutation that we want to keep
27150:   // track of happen. For now this is only done when children are added or
27150:   // removed, but we might do it for attribute changes too in the future.
27150:   static void DidMutate()
27150:   {
27150:     if (sMutationCount) {
27150:       --sMutationCount;
27150:     }
27150:   }
27150: 
27150: private:
27150:   // mDelta is the amount sMutationCount was adjusted when the guard was
27150:   // initialized. It is needed so that we can undo that adjustment once
27150:   // the guard dies.
27150:   PRUint32 mDelta;
27150: 
27150:   // The value 300 is not important, as long as it is bigger then anything
27150:   // ever passed to Mutated().
27150:   enum { eMaxMutations = 300 };
27150: 
27150:   
27150:   // sMutationCount is a global mutation counter which is decreased by one at
27150:   // every mutation. It is capped at 0 to avoid wrapping.
27150:   // Its value is always between 0 and 300, inclusive.
27150:   static PRUint32 sMutationCount;
27150: };
    1: 
41182: // Categories of node properties
41182: // 0 is global.
41182: #define DOM_USER_DATA         1
41182: #define DOM_USER_DATA_HANDLER 2
41182: #define SMIL_MAPPED_ATTR_ANIMVAL 3
41182: 
    1: // IID for the nsINode interface
    1: #define NS_INODE_IID \
96083: { 0xfcd3b0d1, 0x75db, 0x46c4, \
96083:   { 0xa1, 0xf5, 0x07, 0xc2, 0x09, 0xf8, 0x1f, 0x44 } }
    1: 
    1: /**
    1:  * An internal interface that abstracts some DOMNode-related parts that both
    1:  * nsIContent and nsIDocument share.  An instance of this interface has a list
    1:  * of nsIContent children and provides access to them.
    1:  */
72322: class nsINode : public nsIDOMEventTarget,
21618:                 public nsWrapperCache
21618: {
    1: public:
 9807:   NS_DECLARE_STATIC_IID_ACCESSOR(NS_INODE_IID)
 9807: 
91403:   // Among the sub-classes that inherit (directly or indirectly) from nsINode,
91403:   // measurement of the following members may be added later if DMD finds it is
91403:   // worthwhile:
91403:   // - nsGenericHTMLElement:  mForm, mFieldSet
91403:   // - nsGenericHTMLFrameElement: mFrameLoader (bug 672539), mTitleChangedListener
91403:   // - nsHTMLBodyElement:     mContentStyleRule
91403:   // - nsHTMLDataListElement: mOptions
91403:   // - nsHTMLFieldSetElement: mElements, mDependentElements, mFirstLegend
91403:   // - nsHTMLFormElement:     many!
91403:   // - nsHTMLFrameSetElement: mRowSpecs, mColSpecs
91403:   // - nsHTMLInputElement:    mInputData, mFiles, mFileList, mStaticDocfileList
91403:   // - nsHTMLMapElement:      mAreas
91403:   // - nsHTMLMediaElement:    many!
91403:   // - nsHTMLOutputElement:   mDefaultValue, mTokenList
91403:   // - nsHTMLRowElement:      mCells
91403:   // - nsHTMLSelectElement:   mOptions, mRestoreState
91403:   // - nsHTMLTableElement:    mTBodies, mRows, mTableInheritedAttributes
91403:   // - nsHTMLTableSectionElement: mRows
91403:   // - nsHTMLTextAreaElement: mControllers, mState
91403:   //
91403:   // The following members don't need to be measured:
91403:   // - nsIContent: mPrimaryFrame, because it's non-owning and measured elsewhere
91403:   //
91403:   NS_DECL_SIZEOF_EXCLUDING_THIS
91403: 
91403:   // SizeOfIncludingThis doesn't need to be overridden by sub-classes because
91403:   // sub-classes of nsINode are guaranteed to be laid out in memory in such a
91403:   // way that |this| points to the start of the allocated object, even in
91403:   // methods of nsINode's sub-classes, and so |aMallocSizeOf(this)| is always
91403:   // safe to call no matter which object it was invoked on.
91403:   virtual size_t SizeOfIncludingThis(nsMallocSizeOfFun aMallocSizeOf) const {
91403:     return aMallocSizeOf(this) + SizeOfExcludingThis(aMallocSizeOf);
91403:   }
73673: 
    1:   friend class nsNodeUtils;
    1:   friend class nsNodeWeakReference;
    1:   friend class nsNodeSupportsWeakRefTearoff;
42104:   friend class nsAttrAndChildArray;
    1: 
    1: #ifdef MOZILLA_INTERNAL_API
94340:   nsINode(already_AddRefed<nsINodeInfo> aNodeInfo)
    1:   : mNodeInfo(aNodeInfo),
67605:     mParent(nsnull),
67604:     mFlags(0),
90468:     mBoolFlags(0),
90468:     mNextSibling(nsnull),
90468:     mPreviousSibling(nsnull),
50423:     mFirstChild(nsnull),
67604:     mSlots(nsnull)
    1:   {
90468:   }
90126: 
    1: #endif
    1: 
    1:   virtual ~nsINode();
    1: 
    1:   /**
    1:    * Bit-flags to pass (or'ed together) to IsNodeOfType()
    1:    */
    1:   enum {
    1:     /** nsIContent nodes */
    1:     eCONTENT             = 1 << 0,
    1:     /** nsIDocument nodes */
    1:     eDOCUMENT            = 1 << 1,
    1:     /** nsIAttribute nodes */
    1:     eATTRIBUTE           = 1 << 2,
    1:     /** text nodes */
41646:     eTEXT                = 1 << 3,
    1:     /** xml processing instructions */
41646:     ePROCESSING_INSTRUCTION = 1 << 4,
    1:     /** comment nodes */
41646:     eCOMMENT             = 1 << 5,
    1:     /** form control elements */
41646:     eHTML_FORM_CONTROL   = 1 << 6,
    1:     /** document fragments */
84223:     eDOCUMENT_FRAGMENT   = 1 << 7,
    1:     /** data nodes (comments, PIs, text). Nodes of this type always
    1:      returns a non-null value for nsIContent::GetText() */
84223:     eDATA_NODE           = 1 << 8,
25018:     /** nsHTMLMediaElement */
84223:     eMEDIA               = 1 << 9,
39637:     /** animation elements */
84223:     eANIMATION           = 1 << 10
    1:   };
    1: 
    1:   /**
    1:    * API for doing a quick check if a content is of a given
33329:    * type, such as Text, Document, Comment ...  Use this when you can instead of
    1:    * checking the tag.
    1:    *
    1:    * @param aFlags what types you want to test for (see above)
    1:    * @return whether the content matches ALL flags passed in
    1:    */
79445:   virtual bool IsNodeOfType(PRUint32 aFlags) const = 0;
    1: 
    1:   /**
41631:    * Return whether the node is an Element node
41631:    */
67606:   bool IsElement() const {
67606:     return GetBoolFlag(NodeIsElement);
41631:   }
41631: 
41631:   /**
41632:    * Return this node as an Element.  Should only be used for nodes
41632:    * for which IsElement() is true.
41632:    */
41632:   mozilla::dom::Element* AsElement();
41632: 
41632:   /**
88030:    * Return if this node has any children.
88030:    */
88030:   bool HasChildren() const { return !!mFirstChild; }
88030: 
88030:   /**
    1:    * Get the number of children
    1:    * @return the number of children
    1:    */
    1:   virtual PRUint32 GetChildCount() const = 0;
    1: 
    1:   /**
    1:    * Get a child by index
    1:    * @param aIndex the index of the child to get
    1:    * @return the child, or null if index out of bounds
    1:    */
    1:   virtual nsIContent* GetChildAt(PRUint32 aIndex) const = 0;
    1: 
    1:   /**
15810:    * Get a raw pointer to the child array.  This should only be used if you
15810:    * plan to walk a bunch of the kids, promise to make sure that nothing ever
15810:    * mutates (no attribute changes, not DOM tree changes, no script execution,
15810:    * NOTHING), and will never ever peform an out-of-bounds access here.  This
15810:    * method may return null if there are no children, or it may return a
22251:    * garbage pointer.  In all cases the out param will be set to the number of
22251:    * children.
15810:    */
22251:   virtual nsIContent * const * GetChildArray(PRUint32* aChildCount) const = 0;
15810: 
15810:   /**
    1:    * Get the index of a child within this content
    1:    * @param aPossibleChild the child to get the index of.
    1:    * @return the index of the child, or -1 if not a child
    1:    *
    1:    * If the return value is not -1, then calling GetChildAt() with that value
    1:    * will return aPossibleChild.
    1:    */
    1:   virtual PRInt32 IndexOf(nsINode* aPossibleChild) const = 0;
    1: 
    1:   /**
    1:    * Return the "owner document" of this node.  Note that this is not the same
    1:    * as the DOM ownerDocument -- that's null for Document nodes, whereas for a
    1:    * nsIDocument GetOwnerDocument returns the document itself.  For nsIContent
    1:    * implementations the two are the same.
    1:    */
80526:   nsIDocument *OwnerDoc() const
    1:   {
    1:     return mNodeInfo->GetDocument();
    1:   }
    1: 
    1:   /**
    1:    * Returns true if the content has an ancestor that is a document.
    1:    *
    1:    * @return whether this content is in a document tree
    1:    */
67605:   bool IsInDoc() const
    1:   {
67605:     return GetBoolFlag(IsInDocument);
    1:   }
    1: 
    1:   /**
    1:    * Get the document that this content is currently in, if any. This will be
    1:    * null if the content has no ancestor that is a document.
    1:    *
    1:    * @return the current document
    1:    */
    1:   nsIDocument *GetCurrentDoc() const
    1:   {
80526:     return IsInDoc() ? OwnerDoc() : nsnull;
    1:   }
    1: 
71771:   /**
71771:    * The values returned by this function are the ones defined for
71771:    * nsIDOMNode.nodeType
71771:    */
71771:   PRUint16 NodeType() const
71771:   {
71771:     return mNodeInfo->NodeType();
71771:   }
71771:   const nsString& NodeName() const
71771:   {
71771:     return mNodeInfo->NodeName();
71771:   }
71771:   const nsString& LocalName() const
71771:   {
71771:     return mNodeInfo->LocalName();
71771:   }
39585: 
39585:   nsINode*
39585:   InsertBefore(nsINode *aNewChild, nsINode *aRefChild, nsresult *aReturn)
39585:   {
80486:     return ReplaceOrInsertBefore(false, aNewChild, aRefChild, aReturn);
39585:   }
39585:   nsINode*
39585:   ReplaceChild(nsINode *aNewChild, nsINode *aOldChild, nsresult *aReturn)
39585:   {
80486:     return ReplaceOrInsertBefore(true, aNewChild, aOldChild, aReturn);
39585:   }
39585:   nsINode*
39585:   AppendChild(nsINode *aNewChild, nsresult *aReturn)
39585:   {
39585:     return InsertBefore(aNewChild, nsnull, aReturn);
39585:   }
69573:   nsresult RemoveChild(nsINode *aOldChild);
39585: 
    1:   /**
    1:    * Insert a content node at a particular index.  This method handles calling
    1:    * BindToTree on the child appropriately.
    1:    *
    1:    * @param aKid the content to insert
    1:    * @param aIndex the index it is being inserted at (the index it will have
    1:    *        after it is inserted)
    1:    * @param aNotify whether to notify the document (current document for
    1:    *        nsIContent, and |this| for nsIDocument) that the insert has
    1:    *        occurred
    1:    *
    1:    * @throws NS_ERROR_DOM_HIERARCHY_REQUEST_ERR if one attempts to have more
    1:    * than one element node as a child of a document.  Doing this will also
    1:    * assert -- you shouldn't be doing it!  Check with
41634:    * nsIDocument::GetRootElement() first if you're not sure.  Apart from this
    1:    * one constraint, this doesn't do any checking on whether aKid is a valid
    1:    * child of |this|.
    1:    *
    1:    * @throws NS_ERROR_OUT_OF_MEMORY in some cases (from BindToTree).
    1:    */
    1:   virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
79445:                                  bool aNotify) = 0;
    1: 
    1:   /**
    1:    * Append a content node to the end of the child list.  This method handles
    1:    * calling BindToTree on the child appropriately.
    1:    *
    1:    * @param aKid the content to append
    1:    * @param aNotify whether to notify the document (current document for
    1:    *        nsIContent, and |this| for nsIDocument) that the append has
    1:    *        occurred
    1:    *
    1:    * @throws NS_ERROR_DOM_HIERARCHY_REQUEST_ERR if one attempts to have more
    1:    * than one element node as a child of a document.  Doing this will also
    1:    * assert -- you shouldn't be doing it!  Check with
41634:    * nsIDocument::GetRootElement() first if you're not sure.  Apart from this
    1:    * one constraint, this doesn't do any checking on whether aKid is a valid
    1:    * child of |this|.
    1:    *
    1:    * @throws NS_ERROR_OUT_OF_MEMORY in some cases (from BindToTree).
    1:    */
79445:   nsresult AppendChildTo(nsIContent* aKid, bool aNotify)
    1:   {
    1:     return InsertChildAt(aKid, GetChildCount(), aNotify);
    1:   }
    1:   
    1:   /**
    1:    * Remove a child from this node.  This method handles calling UnbindFromTree
    1:    * on the child appropriately.
    1:    *
    1:    * @param aIndex the index of the child to remove
    1:    * @param aNotify whether to notify the document (current document for
    1:    *        nsIContent, and |this| for nsIDocument) that the remove has
    1:    *        occurred
    1:    *
    1:    * Note: If there is no child at aIndex, this method will simply do nothing.
    1:    */
94359:   virtual void RemoveChildAt(PRUint32 aIndex, bool aNotify) = 0;
    1: 
    1:   /**
    1:    * Get a property associated with this node.
    1:    *
    1:    * @param aPropertyName  name of property to get.
    1:    * @param aStatus        out parameter for storing resulting status.
    1:    *                       Set to NS_PROPTABLE_PROP_NOT_THERE if the property
    1:    *                       is not set.
    1:    * @return               the property. Null if the property is not set
    1:    *                       (though a null return value does not imply the
    1:    *                       property was not set, i.e. it can be set to null).
    1:    */
    1:   void* GetProperty(nsIAtom *aPropertyName,
    1:                     nsresult *aStatus = nsnull) const
    1:   {
    1:     return GetProperty(0, aPropertyName, aStatus);
    1:   }
    1: 
    1:   /**
    1:    * Get a property associated with this node.
    1:    *
    1:    * @param aCategory      category of property to get.
    1:    * @param aPropertyName  name of property to get.
    1:    * @param aStatus        out parameter for storing resulting status.
    1:    *                       Set to NS_PROPTABLE_PROP_NOT_THERE if the property
    1:    *                       is not set.
    1:    * @return               the property. Null if the property is not set
    1:    *                       (though a null return value does not imply the
    1:    *                       property was not set, i.e. it can be set to null).
    1:    */
    1:   virtual void* GetProperty(PRUint16 aCategory,
    1:                             nsIAtom *aPropertyName,
    1:                             nsresult *aStatus = nsnull) const;
    1: 
    1:   /**
    1:    * Set a property to be associated with this node. This will overwrite an
    1:    * existing value if one exists. The existing value is destroyed using the
    1:    * destructor function given when that value was set.
    1:    *
    1:    * @param aPropertyName  name of property to set.
    1:    * @param aValue         new value of property.
    1:    * @param aDtor          destructor function to be used when this property
    1:    *                       is destroyed.
80486:    * @param aTransfer      if true the property will not be deleted when the
80486:    *                       ownerDocument of the node changes, if false it
    1:    *                       will be deleted.
    1:    *
    1:    * @return NS_PROPTABLE_PROP_OVERWRITTEN (success value) if the property
    1:    *                                       was already set
    1:    * @throws NS_ERROR_OUT_OF_MEMORY if that occurs
    1:    */
    1:   nsresult SetProperty(nsIAtom *aPropertyName,
    1:                        void *aValue,
    1:                        NSPropertyDtorFunc aDtor = nsnull,
79445:                        bool aTransfer = false)
    1:   {
    1:     return SetProperty(0, aPropertyName, aValue, aDtor, aTransfer);
    1:   }
    1: 
    1:   /**
    1:    * Set a property to be associated with this node. This will overwrite an
    1:    * existing value if one exists. The existing value is destroyed using the
    1:    * destructor function given when that value was set.
    1:    *
    1:    * @param aCategory       category of property to set.
    1:    * @param aPropertyName   name of property to set.
    1:    * @param aValue          new value of property.
    1:    * @param aDtor           destructor function to be used when this property
    1:    *                        is destroyed.
80486:    * @param aTransfer       if true the property will not be deleted when the
80486:    *                        ownerDocument of the node changes, if false it
    1:    *                        will be deleted.
    1:    * @param aOldValue [out] previous value of property.
    1:    *
    1:    * @return NS_PROPTABLE_PROP_OVERWRITTEN (success value) if the property
    1:    *                                       was already set
    1:    * @throws NS_ERROR_OUT_OF_MEMORY if that occurs
    1:    */
    1:   virtual nsresult SetProperty(PRUint16 aCategory,
    1:                                nsIAtom *aPropertyName,
    1:                                void *aValue,
    1:                                NSPropertyDtorFunc aDtor = nsnull,
79445:                                bool aTransfer = false,
    1:                                void **aOldValue = nsnull);
    1: 
    1:   /**
    1:    * Destroys a property associated with this node. The value is destroyed
    1:    * using the destruction function given when that value was set.
    1:    *
    1:    * @param aPropertyName  name of property to destroy.
    1:    */
43457:   void DeleteProperty(nsIAtom *aPropertyName)
    1:   {
43457:     DeleteProperty(0, aPropertyName);
    1:   }
    1: 
    1:   /**
    1:    * Destroys a property associated with this node. The value is destroyed
    1:    * using the destruction function given when that value was set.
    1:    *
    1:    * @param aCategory      category of property to destroy.
    1:    * @param aPropertyName  name of property to destroy.
    1:    */
43457:   virtual void DeleteProperty(PRUint16 aCategory, nsIAtom *aPropertyName);
    1: 
    1:   /**
    1:    * Unset a property associated with this node. The value will not be
    1:    * destroyed but rather returned. It is the caller's responsibility to
    1:    * destroy the value after that point.
    1:    *
    1:    * @param aPropertyName  name of property to unset.
    1:    * @param aStatus        out parameter for storing resulting status.
    1:    *                       Set to NS_PROPTABLE_PROP_NOT_THERE if the property
    1:    *                       is not set.
    1:    * @return               the property. Null if the property is not set
    1:    *                       (though a null return value does not imply the
    1:    *                       property was not set, i.e. it can be set to null).
    1:    */
    1:   void* UnsetProperty(nsIAtom  *aPropertyName,
    1:                       nsresult *aStatus = nsnull)
    1:   {
    1:     return UnsetProperty(0, aPropertyName, aStatus);
    1:   }
    1: 
    1:   /**
    1:    * Unset a property associated with this node. The value will not be
    1:    * destroyed but rather returned. It is the caller's responsibility to
    1:    * destroy the value after that point.
    1:    *
    1:    * @param aCategory      category of property to unset.
    1:    * @param aPropertyName  name of property to unset.
    1:    * @param aStatus        out parameter for storing resulting status.
    1:    *                       Set to NS_PROPTABLE_PROP_NOT_THERE if the property
    1:    *                       is not set.
    1:    * @return               the property. Null if the property is not set
    1:    *                       (though a null return value does not imply the
    1:    *                       property was not set, i.e. it can be set to null).
    1:    */
    1:   virtual void* UnsetProperty(PRUint16 aCategory,
    1:                               nsIAtom *aPropertyName,
    1:                               nsresult *aStatus = nsnull);
    1:   
79445:   bool HasProperties() const
    1:   {
    1:     return HasFlag(NODE_HAS_PROPERTIES);
    1:   }
    1: 
    1:   /**
    1:    * Return the principal of this node.  This is guaranteed to never be a null
    1:    * pointer.
    1:    */
    1:   nsIPrincipal* NodePrincipal() const {
    1:     return mNodeInfo->NodeInfoManager()->DocumentPrincipal();
    1:   }
    1: 
    1:   /**
    1:    * Get the parent nsIContent for this node.
    1:    * @return the parent, or null if no parent or the parent is not an nsIContent
    1:    */
67605:   nsIContent* GetParent() const {
67605:     return NS_LIKELY(GetBoolFlag(ParentIsContent)) ?
67605:       reinterpret_cast<nsIContent*>(mParent) : nsnull;
    1:   }
    1: 
    1:   /**
    1:    * Get the parent nsINode for this node. This can be either an nsIContent,
    1:    * an nsIDocument or an nsIAttribute.
    1:    * @return the parent node
    1:    */
    1:   nsINode* GetNodeParent() const
    1:   {
67605:     return mParent;
    1:   }
    1:   
    1:   /**
78189:    * Get the parent nsINode for this node if it is an Element.
78189:    * @return the parent node
78189:    */
78189:   nsINode* GetElementParent() const
78189:   {
78189:     return mParent && mParent->IsElement() ? mParent : nsnull;
78189:   }
78189: 
78189:   /**
72324:    * See nsIDOMEventTarget
72322:    */
72324:   NS_DECL_NSIDOMEVENTTARGET
72628:   using nsIDOMEventTarget::AddEventListener;
82743:   using nsIDOMEventTarget::AddSystemEventListener;
72322: 
72322:   /**
    1:    * Adds a mutation observer to be notified when this node, or any of its
    1:    * descendants, are modified. The node will hold a weak reference to the
    1:    * observer, which means that it is the responsibility of the observer to
    1:    * remove itself in case it dies before the node.  If an observer is added
    1:    * while observers are being notified, it may also be notified.  In general,
41925:    * adding observers while inside a notification is not a good idea.  An
41925:    * observer that is already observing the node must not be added without
41925:    * being removed first.
    1:    */
41925:   void AddMutationObserver(nsIMutationObserver* aMutationObserver)
41925:   {
42237:     nsSlots* s = GetSlots();
42237:     if (s) {
42237:       NS_ASSERTION(s->mMutationObservers.IndexOf(aMutationObserver) ==
57140:                    nsTArray<int>::NoIndex,
41925:                    "Observer already in the list");
42237:       s->mMutationObservers.AppendElement(aMutationObserver);
41925:     }
41925:   }
41925: 
41925:   /**
41925:    * Same as above, but only adds the observer if its not observing
41925:    * the node already.
41925:    */
41925:   void AddMutationObserverUnlessExists(nsIMutationObserver* aMutationObserver)
41925:   {
42237:     nsSlots* s = GetSlots();
42237:     if (s) {
42237:       s->mMutationObservers.AppendElementUnlessExists(aMutationObserver);
41925:     }
41925:   }
    1: 
    1:   /**
    1:    * Removes a mutation observer.
    1:    */
41925:   void RemoveMutationObserver(nsIMutationObserver* aMutationObserver)
41925:   {
42237:     nsSlots* s = GetExistingSlots();
42237:     if (s) {
42237:       s->mMutationObservers.RemoveElement(aMutationObserver);
41925:     }
41925:   }
    1: 
    1:   /**
    1:    * Clones this node. This needs to be overriden by all node classes. aNodeInfo
    1:    * should be identical to this node's nodeInfo, except for the document which
    1:    * may be different. When cloning an element, all attributes of the element
    1:    * will be cloned. The children of the node will not be cloned.
    1:    *
    1:    * @param aNodeInfo the nodeinfo to use for the clone
    1:    * @param aResult the clone
    1:    */
94340:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const = 0;
    1: 
    1:   /**
    1:    * Checks if a node has the same ownerDocument as this one. Note that this
    1:    * actually compares nodeinfo managers because nodes always have one, even
80486:    * when they don't have an ownerDocument. If this function returns true
    1:    * it doesn't mean that the nodes actually have an ownerDocument.
    1:    *
    1:    * @param aOther Other node to check
    1:    * @return Whether the owner documents of this node and of aOther are the
    1:    *         same.
    1:    */
79445:   bool HasSameOwnerDoc(nsINode *aOther)
    1:   {
    1:     // We compare nodeinfo managers because nodes always have one, even when
    1:     // they don't have an ownerDocument.
    1:     return mNodeInfo->NodeInfoManager() == aOther->mNodeInfo->NodeInfoManager();
    1:   }
    1: 
    1:   // This class can be extended by subclasses that wish to store more
    1:   // information in the slots.
    1:   class nsSlots
    1:   {
    1:   public:
67604:     nsSlots()
67604:       : mChildNodes(nsnull),
    1:         mWeakReference(nsnull)
    1:     {
    1:     }
    1: 
    1:     // If needed we could remove the vtable pointer this dtor causes by
    1:     // putting a DestroySlots function on nsINode
    1:     virtual ~nsSlots();
    1: 
77323:     void Traverse(nsCycleCollectionTraversalCallback &cb);
77323:     void Unlink();
77323: 
    1:     /**
    1:      * A list of mutation observers
    1:      */
 9536:     nsTObserverArray<nsIMutationObserver*> mMutationObservers;
    1: 
    1:     /**
    1:      * An object implementing nsIDOMNodeList for this content (childNodes)
    1:      * @see nsIDOMNodeList
    1:      * @see nsGenericHTMLElement::GetChildNodes
    1:      *
    1:      * MSVC 7 doesn't like this as an nsRefPtr
    1:      */
    1:     nsChildContentList* mChildNodes;
    1: 
    1:     /**
    1:      * Weak reference to this node
    1:      */
    1:     nsNodeWeakReference* mWeakReference;
    1:   };
    1: 
    1:   /**
    1:    * Functions for managing flags and slots
    1:    */
    1: #ifdef DEBUG
    1:   nsSlots* DebugGetSlots()
    1:   {
    1:     return GetSlots();
    1:   }
    1: #endif
    1: 
79445:   bool HasFlag(PtrBits aFlag) const
    1:   {
    1:     return !!(GetFlags() & aFlag);
    1:   }
    1: 
67604:   PRUint32 GetFlags() const
    1:   {
67604:     return mFlags;
    1:   }
    1: 
67604:   void SetFlags(PRUint32 aFlagsToSet)
    1:   {
25511:     NS_ASSERTION(!(aFlagsToSet & (NODE_IS_ANONYMOUS |
25511:                                   NODE_IS_NATIVE_ANONYMOUS_ROOT |
30001:                                   NODE_IS_IN_ANONYMOUS_SUBTREE |
40936:                                   NODE_ATTACH_BINDING_ON_POSTCREATE |
40936:                                   NODE_DESCENDANTS_NEED_FRAMES |
40936:                                   NODE_NEEDS_FRAME)) ||
    1:                  IsNodeOfType(eCONTENT),
    1:                  "Flag only permitted on nsIContent nodes");
67604:     mFlags |= aFlagsToSet;
    1:   }
    1: 
67604:   void UnsetFlags(PRUint32 aFlagsToUnset)
    1:   {
25511:     NS_ASSERTION(!(aFlagsToUnset &
25511:                    (NODE_IS_ANONYMOUS |
25511:                     NODE_IS_IN_ANONYMOUS_SUBTREE |
25511:                     NODE_IS_NATIVE_ANONYMOUS_ROOT)),
25511:                  "Trying to unset write-only flags");
67604:     mFlags &= ~aFlagsToUnset;
    1:   }
    1: 
79445:   void SetEditableFlag(bool aEditable)
 2896:   {
 2896:     if (aEditable) {
 2896:       SetFlags(NODE_IS_EDITABLE);
 2896:     }
 2896:     else {
 2896:       UnsetFlags(NODE_IS_EDITABLE);
 2896:     }
 2896:   }
 2896: 
79445:   bool IsEditable() const
 3333:   {
 3333: #ifdef _IMPL_NS_LAYOUT
 3333:     return IsEditableInternal();
 3333: #else
 3333:     return IsEditableExternal();
 3333: #endif
 3333:   }
 3333: 
11914:   /**
80486:    * Returns true if |this| or any of its ancestors is native anonymous.
27664:    */
79445:   bool IsInNativeAnonymousSubtree() const
27664:   {
27664: #ifdef DEBUG
27664:     if (HasFlag(NODE_IS_IN_ANONYMOUS_SUBTREE)) {
80486:       return true;
27664:     }
27664:     CheckNotNativeAnonymous();
80486:     return false;
27664: #else
27664:     return HasFlag(NODE_IS_IN_ANONYMOUS_SUBTREE);
27664: #endif
27664:   }
27664: 
27664:   /**
85101:    * Returns true if |this| node is the common ancestor of the start/end
85101:    * nodes of a Range in a Selection or a descendant of such a common ancestor.
85101:    * This node is definitely not selected when |false| is returned, but it may
85101:    * or may not be selected when |true| is returned.
85101:    */
85101:   bool IsSelectionDescendant() const
85101:   {
85101:     return IsDescendantOfCommonAncestorForRangeInSelection() ||
85101:            IsCommonAncestorForRangeInSelection();
85101:   }
85101: 
85101:   /**
11914:    * Get the root content of an editor. So, this node must be a descendant of
11914:    * an editor. Note that this should be only used for getting input or textarea
11914:    * editor's root content. This method doesn't support HTML editors.
11914:    */
11914:   nsIContent* GetTextEditorRootContent(nsIEditor** aEditor = nsnull);
11914: 
11914:   /**
11914:    * Get the nearest selection root, ie. the node that will be selected if the
11914:    * user does "Select All" while the focus is in this node. Note that if this
11914:    * node is not in an editor, the result comes from the nsFrameSelection that
11914:    * is related to aPresShell, so the result might not be the ancestor of this
35608:    * node. Be aware that if this node and the computed selection limiter are
35608:    * not in same subtree, this returns the root content of the closeset subtree.
11914:    */
11914:   nsIContent* GetSelectionRootContent(nsIPresShell* aPresShell);
11914: 
24403:   virtual nsINodeList* GetChildNodesList();
42105:   nsIContent* GetFirstChild() const { return mFirstChild; }
23258:   nsIContent* GetLastChild() const
23258:   {
23258:     PRUint32 count;
23258:     nsIContent* const* children = GetChildArray(&count);
23258: 
23258:     return count > 0 ? children[count - 1] : nsnull;
23258:   }
23258: 
23258:   /**
23258:    * Implementation is in nsIDocument.h, because it needs to cast from
23258:    * nsIDocument* to nsINode*.
23258:    */
23258:   nsIDocument* GetOwnerDocument() const;
23258: 
72437:   nsresult Normalize();
72437: 
41900:   /**
41900:    * Get the base URI for any relative URIs within this piece of
41900:    * content. Generally, this is the document's base URI, but certain
41900:    * content carries a local base for backward compatibility, and XML
41900:    * supports setting a per-node base URI.
41900:    *
41900:    * @return the base URI
41900:    */
41900:   virtual already_AddRefed<nsIURI> GetBaseURI() const = 0;
41900: 
89350:   /**
89350:    * Facility for explicitly setting a base URI on a node.
89350:    */
89350:   nsresult SetExplicitBaseURI(nsIURI* aURI);
89350:   /**
89350:    * The explicit base URI, if set, otherwise null
89350:    */
89350: protected:
89350:   nsIURI* GetExplicitBaseURI() const {
89350:     if (HasExplicitBaseURI()) {
89350:       return static_cast<nsIURI*>(GetProperty(nsGkAtoms::baseURIProperty));
89350:     }
89350:     return nsnull;
89350:   }
89350:   
89350: public:
71768:   nsresult GetDOMBaseURI(nsAString &aURI) const;
41900: 
71768:   // Note! This function must never fail. It only return an nsresult so that
71768:   // we can use it to implement nsIDOMNode
71768:   NS_IMETHOD GetTextContent(nsAString &aTextContent)
41907:   {
41907:     SetDOMStringToNull(aTextContent);
71768:     return NS_OK;
41907:   }
71768:   NS_IMETHOD SetTextContent(const nsAString& aTextContent)
41907:   {
41907:     return NS_OK;
41907:   }
41907: 
41902:   /**
41902:    * Associate an object aData to aKey on this node. If aData is null any
41902:    * previously registered object and UserDataHandler associated to aKey on
41902:    * this node will be removed.
41902:    * Should only be used to implement the DOM Level 3 UserData API.
41902:    *
41902:    * @param aKey the key to associate the object to
41902:    * @param aData the object to associate to aKey on this node (may be null)
41902:    * @param aHandler the UserDataHandler to call when the node is
41902:    *                 cloned/deleted/imported/renamed (may be null)
41902:    * @param aResult [out] the previously registered object for aKey on this
41902:    *                      node, if any
41902:    * @return whether adding the object and UserDataHandler succeeded
41902:    */
41902:   nsresult SetUserData(const nsAString& aKey, nsIVariant* aData,
41902:                        nsIDOMUserDataHandler* aHandler, nsIVariant** aResult);
41902: 
41902:   /**
41902:    * Get the UserData object registered for a Key on this node, if any.
41902:    * Should only be used to implement the DOM Level 3 UserData API.
41902:    *
41902:    * @param aKey the key to get UserData for
41902:    * @return aResult the previously registered object for aKey on this node, if
41902:    *                 any
41902:    */
41902:   nsIVariant* GetUserData(const nsAString& aKey)
41902:   {
41902:     nsCOMPtr<nsIAtom> key = do_GetAtom(aKey);
41902:     if (!key) {
41902:       return nsnull;
41902:     }
41902: 
41902:     return static_cast<nsIVariant*>(GetProperty(DOM_USER_DATA, key));
41902:   }
41902: 
71768:   nsresult GetUserData(const nsAString& aKey, nsIVariant** aResult)
71768:   {
71768:     NS_IF_ADDREF(*aResult = GetUserData(aKey));
71768:   
71768:     return NS_OK;
71768:   }
71768: 
41905: 
41906:   /**
41906:    * Compares the document position of a node to this node.
41906:    *
41906:    * @param aOtherNode The node whose position is being compared to this node
41906:    *
41906:    * @return  The document position flags of the nodes. aOtherNode is compared
41906:    *          to this node, i.e. if aOtherNode is before this node then
41906:    *          DOCUMENT_POSITION_PRECEDING will be set.
41906:    *
41906:    * @see nsIDOMNode
41906:    */
71768:   PRUint16 CompareDocPosition(nsINode* aOtherNode);
71768:   nsresult CompareDocPosition(nsINode* aOtherNode, PRUint16* aReturn)
41906:   {
41906:     NS_ENSURE_ARG(aOtherNode);
71768:     *aReturn = CompareDocPosition(aOtherNode);
41906:     return NS_OK;
41906:   }
71768:   nsresult CompareDocumentPosition(nsIDOMNode* aOther,
71768:                                    PRUint16* aReturn);
41906: 
71768:   nsresult LookupPrefix(const nsAString& aNamespaceURI, nsAString& aPrefix);
79445:   nsresult IsDefaultNamespace(const nsAString& aNamespaceURI, bool* aResult)
41904:   {
41904:     nsAutoString defaultNamespace;
41904:     LookupNamespaceURI(EmptyString(), defaultNamespace);
71768:     *aResult = aNamespaceURI.Equals(defaultNamespace);
71768:     return NS_OK;
41904:   }
71768:   nsresult LookupNamespaceURI(const nsAString& aNamespacePrefix,
41904:                               nsAString& aNamespaceURI);
41904: 
79445:   nsresult IsEqualNode(nsIDOMNode* aOther, bool* aReturn);
79445:   bool IsEqualTo(nsINode* aOther);
71768: 
90468:   nsIContent* GetNextSibling() const { return mNextSibling; }
90468:   nsIContent* GetPreviousSibling() const { return mPreviousSibling; }
42104: 
42105:   /**
42105:    * Get the next node in the pre-order tree traversal of the DOM.  If
42105:    * aRoot is non-null, then it must be an ancestor of |this|
42105:    * (possibly equal to |this|) and only nodes that are descendants of
42105:    * aRoot, not including aRoot itself, will be returned.  Returns
42105:    * null if there are no more nodes to traverse.
42105:    */
42105:   nsIContent* GetNextNode(const nsINode* aRoot = nsnull) const
42105:   {
80486:     return GetNextNodeImpl(aRoot, false);
74556:   }
74556: 
74556:   /**
74556:    * Get the next node in the pre-order tree traversal of the DOM but ignoring
74556:    * the children of this node.  If aRoot is non-null, then it must be an
74556:    * ancestor of |this| (possibly equal to |this|) and only nodes that are
74556:    * descendants of aRoot, not including aRoot itself, will be returned.
74556:    * Returns null if there are no more nodes to traverse.
74556:    */
74556:   nsIContent* GetNextNonChildNode(const nsINode* aRoot = nsnull) const
74556:   {
80486:     return GetNextNodeImpl(aRoot, true);
74556:   }
74556: 
77764:   /**
77764:    * Returns true if 'this' is either document or element or
77764:    * document fragment and aOther is a descendant in the same
77764:    * anonymous tree.
77764:    */
79445:   bool Contains(const nsINode* aOther) const;
79445:   nsresult Contains(nsIDOMNode* aOther, bool* aReturn);
77764: 
74556: private:
74556: 
74556:   nsIContent* GetNextNodeImpl(const nsINode* aRoot,
79445:                               const bool aSkipChildren) const
74556:   {
42105:     // Can't use nsContentUtils::ContentIsDescendantOf here, since we
42105:     // can't include it here.
42105: #ifdef DEBUG
42105:     if (aRoot) {
42105:       const nsINode* cur = this;
42105:       for (; cur; cur = cur->GetNodeParent())
42105:         if (cur == aRoot) break;
42105:       NS_ASSERTION(cur, "aRoot not an ancestor of |this|?");
42105:     }
42105: #endif
74556:     if (!aSkipChildren) {
42105:       nsIContent* kid = GetFirstChild();
42105:       if (kid) {
42105:         return kid;
42105:       }
74556:     }
42105:     if (this == aRoot) {
42105:       return nsnull;
42105:     }
42105:     const nsINode* cur = this;
42105:     while (1) {
42105:       nsIContent* next = cur->GetNextSibling();
42105:       if (next) {
42105:         return next;
42105:       }
42105:       nsINode* parent = cur->GetNodeParent();
42105:       if (parent == aRoot) {
42105:         return nsnull;
42105:       }
42105:       cur = parent;
42105:     }
42105:     NS_NOTREACHED("How did we get here?");
42105:   }
42105: 
74556: public:
74556: 
67605:   /**
69185:    * Get the previous nsIContent in the pre-order tree traversal of the DOM.  If
69185:    * aRoot is non-null, then it must be an ancestor of |this|
69185:    * (possibly equal to |this|) and only nsIContents that are descendants of
69185:    * aRoot, including aRoot itself, will be returned.  Returns
69185:    * null if there are no more nsIContents to traverse.
69185:    */
69185:   nsIContent* GetPreviousContent(const nsINode* aRoot = nsnull) const
69185:   {
69185:       // Can't use nsContentUtils::ContentIsDescendantOf here, since we
69185:       // can't include it here.
69185: #ifdef DEBUG
69185:       if (aRoot) {
69185:         const nsINode* cur = this;
69185:         for (; cur; cur = cur->GetNodeParent())
69185:           if (cur == aRoot) break;
69185:         NS_ASSERTION(cur, "aRoot not an ancestor of |this|?");
69185:       }
69185: #endif
69185: 
69185:     if (this == aRoot) {
69185:       return nsnull;
69185:     }
69185:     nsIContent* cur = this->GetParent();
69185:     nsIContent* iter = this->GetPreviousSibling();
69185:     while (iter) {
69185:       cur = iter;
69185:       iter = reinterpret_cast<nsINode*>(iter)->GetLastChild();
69185:     }
69185:     return cur;
69185:   }
69185: 
69185:   /**
67605:    * Boolean flags
67605:    */
67605: private:
67605:   enum BooleanFlag {
67605:     // Set if we're being used from -moz-element
67605:     NodeHasRenderingObservers,
67605:     // Set if our parent chain (including this node itself) terminates
67605:     // in a document
67605:     IsInDocument,
67605:     // Set if mParent is an nsIContent
67605:     ParentIsContent,
67606:     // Set if this node is an Element
67606:     NodeIsElement,
67607:     // Set if the element has a non-empty id attribute. This can in rare
67607:     // cases lie for nsXMLElement, such as when the node has been moved between
67607:     // documents with different id mappings.
67607:     ElementHasID,
67608:     // Set if the element might have inline style.
67608:     ElementMayHaveStyle,
67609:     // Set if the element has a name attribute set.
67609:     ElementHasName,
67610:     // Set if the element might have a contenteditable attribute set.
67610:     ElementMayHaveContentEditableAttr,
85101:     // Set if the node is the common ancestor of the start/end nodes of a Range
85101:     // that is in a Selection.
85101:     NodeIsCommonAncestorForRangeInSelection,
85101:     // Set if the node is a descendant of a node with the above bit set.
85101:     NodeIsDescendantOfCommonAncestorForRangeInSelection,
88521:     // Set if CanSkipInCC check has been done for this subtree root.
88521:     NodeIsCCMarkedRoot,
88521:     // Maybe set if this node is in black subtree.
88521:     NodeIsCCBlackTree,
88521:     // Maybe set if the node is a root of a subtree 
88521:     // which needs to be kept in the purple buffer.
88521:     NodeIsPurpleRoot,
89350:     // Set if the node has an explicit base URI stored
89350:     NodeHasExplicitBaseURI,
89714:     // Set if the element has some style states locked
89714:     ElementHasLockedStyleStates,
95203:     // Set if element has pointer locked
95203:     ElementHasPointerLock,
94465:     // Set if the node may have DOMMutationObserver attached to it.
94465:     NodeMayHaveDOMMutationObserver,
67607:     // Guard value
67605:     BooleanFlagCount
67605:   };
67605: 
67605:   void SetBoolFlag(BooleanFlag name, bool value) {
67605:     PR_STATIC_ASSERT(BooleanFlagCount <= 8*sizeof(mBoolFlags));
67605:     mBoolFlags = (mBoolFlags & ~(1 << name)) | (value << name);
67605:   }
67605: 
67605:   void SetBoolFlag(BooleanFlag name) {
67605:     PR_STATIC_ASSERT(BooleanFlagCount <= 8*sizeof(mBoolFlags));
67605:     mBoolFlags |= (1 << name);
67605:   }
67605: 
67605:   void ClearBoolFlag(BooleanFlag name) {
67605:     PR_STATIC_ASSERT(BooleanFlagCount <= 8*sizeof(mBoolFlags));
67605:     mBoolFlags &= ~(1 << name);
67605:   }
67605: 
67605:   bool GetBoolFlag(BooleanFlag name) const {
67605:     PR_STATIC_ASSERT(BooleanFlagCount <= 8*sizeof(mBoolFlags));
67605:     return mBoolFlags & (1 << name);
67605:   }
67605: 
67605: public:
67605:   bool HasRenderingObservers() const
67605:     { return GetBoolFlag(NodeHasRenderingObservers); }
50423:   void SetHasRenderingObservers(bool aValue)
67605:     { SetBoolFlag(NodeHasRenderingObservers, aValue); }
67607:   bool HasID() const { return GetBoolFlag(ElementHasID); }
67608:   bool MayHaveStyle() const { return GetBoolFlag(ElementMayHaveStyle); }
67609:   bool HasName() const { return GetBoolFlag(ElementHasName); }
67610:   bool MayHaveContentEditableAttr() const
67610:     { return GetBoolFlag(ElementMayHaveContentEditableAttr); }
85101:   bool IsCommonAncestorForRangeInSelection() const
85101:     { return GetBoolFlag(NodeIsCommonAncestorForRangeInSelection); }
85101:   void SetCommonAncestorForRangeInSelection()
85101:     { SetBoolFlag(NodeIsCommonAncestorForRangeInSelection); }
85101:   void ClearCommonAncestorForRangeInSelection()
85101:     { ClearBoolFlag(NodeIsCommonAncestorForRangeInSelection); }
85101:   bool IsDescendantOfCommonAncestorForRangeInSelection() const
85101:     { return GetBoolFlag(NodeIsDescendantOfCommonAncestorForRangeInSelection); }
85101:   void SetDescendantOfCommonAncestorForRangeInSelection()
85101:     { SetBoolFlag(NodeIsDescendantOfCommonAncestorForRangeInSelection); }
85101:   void ClearDescendantOfCommonAncestorForRangeInSelection()
85101:     { ClearBoolFlag(NodeIsDescendantOfCommonAncestorForRangeInSelection); }
67605: 
88521:   void SetCCMarkedRoot(bool aValue)
88521:     { SetBoolFlag(NodeIsCCMarkedRoot, aValue); }
88521:   bool CCMarkedRoot() const { return GetBoolFlag(NodeIsCCMarkedRoot); }
88521:   void SetInCCBlackTree(bool aValue)
88521:     { SetBoolFlag(NodeIsCCBlackTree, aValue); }
88521:   bool InCCBlackTree() const { return GetBoolFlag(NodeIsCCBlackTree); }
88521:   void SetIsPurpleRoot(bool aValue)
88521:     { SetBoolFlag(NodeIsPurpleRoot, aValue); }
88521:   bool IsPurpleRoot() const { return GetBoolFlag(NodeIsPurpleRoot); }
94465:   bool MayHaveDOMMutationObserver()
94465:     { return GetBoolFlag(NodeMayHaveDOMMutationObserver); }
94465:   void SetMayHaveDOMMutationObserver()
94465:     { SetBoolFlag(NodeMayHaveDOMMutationObserver, true); }
91087:   bool HasListenerManager() { return HasFlag(NODE_HAS_LISTENERMANAGER); }
95203:   bool HasPointerLock() const { return GetBoolFlag(ElementHasPointerLock); }
95203:   void SetPointerLock() { SetBoolFlag(ElementHasPointerLock); }
95203:   void ClearPointerLock() { ClearBoolFlag(ElementHasPointerLock); }
67605: protected:
67605:   void SetParentIsContent(bool aValue) { SetBoolFlag(ParentIsContent, aValue); }
67605:   void SetInDocument() { SetBoolFlag(IsInDocument); }
67605:   void ClearInDocument() { ClearBoolFlag(IsInDocument); }
67606:   void SetIsElement() { SetBoolFlag(NodeIsElement); }
67606:   void ClearIsElement() { ClearBoolFlag(NodeIsElement); }
67607:   void SetHasID() { SetBoolFlag(ElementHasID); }
67607:   void ClearHasID() { ClearBoolFlag(ElementHasID); }
67608:   void SetMayHaveStyle() { SetBoolFlag(ElementMayHaveStyle); }
67609:   void SetHasName() { SetBoolFlag(ElementHasName); }
67609:   void ClearHasName() { ClearBoolFlag(ElementHasName); }
67610:   void SetMayHaveContentEditableAttr()
67610:     { SetBoolFlag(ElementMayHaveContentEditableAttr); }
89350:   bool HasExplicitBaseURI() const { return GetBoolFlag(NodeHasExplicitBaseURI); }
89350:   void SetHasExplicitBaseURI() { SetBoolFlag(NodeHasExplicitBaseURI); }
89714:   void SetHasLockedStyleStates() { SetBoolFlag(ElementHasLockedStyleStates); }
89714:   void ClearHasLockedStyleStates() { ClearBoolFlag(ElementHasLockedStyleStates); }
89714:   bool HasLockedStyleStates() const
89714:     { return GetBoolFlag(ElementHasLockedStyleStates); }
67605: 
67605: public:
51515:   // Optimized way to get classinfo.
48124:   virtual nsXPCClassInfo* GetClassInfo() = 0;
91403: 
94465:   // Makes nsINode object to keep aObject alive.
94465:   void BindObject(nsISupports* aObject);
94465:   // After calling UnbindObject nsINode object doesn't keep
94465:   // aObject alive anymore.
94465:   void UnbindObject(nsISupports* aObject);
94465: 
94357:   /**
94357:    * Returns the length of this node, as specified at
94357:    * <http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html#concept-node-length>
94357:    */
94357:   PRUint32 Length() const;
94357: 
    1: protected:
    1: 
    1:   // Override this function to create a custom slots class.
    1:   virtual nsINode::nsSlots* CreateSlots();
    1: 
79445:   bool HasSlots() const
    1:   {
67604:     return mSlots != nsnull;
    1:   }
    1: 
    1:   nsSlots* GetExistingSlots() const
    1:   {
67604:     return mSlots;
    1:   }
    1: 
    1:   nsSlots* GetSlots()
    1:   {
67604:     if (!HasSlots()) {
67604:       mSlots = CreateSlots();
    1:     }
67604:     return GetExistingSlots();
    1:   }
    1: 
 9764:   nsTObserverArray<nsIMutationObserver*> *GetMutationObservers()
 9764:   {
67604:     return HasSlots() ? &GetExistingSlots()->mMutationObservers : nsnull;
 9764:   }
 9764: 
79445:   bool IsEditableInternal() const;
79445:   virtual bool IsEditableExternal() const
 3333:   {
 3333:     return IsEditableInternal();
 3333:   }
 3333: 
27664: #ifdef DEBUG
27664:   // Note: virtual so that IsInNativeAnonymousSubtree can be called accross
27664:   // module boundaries.
27664:   virtual void CheckNotNativeAnonymous() const;
27664: #endif
27664: 
23258:   nsresult GetParentNode(nsIDOMNode** aParentNode);
78189:   nsresult GetParentElement(nsIDOMElement** aParentElement);
23258:   nsresult GetChildNodes(nsIDOMNodeList** aChildNodes);
23258:   nsresult GetFirstChild(nsIDOMNode** aFirstChild);
23258:   nsresult GetLastChild(nsIDOMNode** aLastChild);
23258:   nsresult GetPreviousSibling(nsIDOMNode** aPrevSibling);
23258:   nsresult GetNextSibling(nsIDOMNode** aNextSibling);
23258:   nsresult GetOwnerDocument(nsIDOMDocument** aOwnerDocument);
23258: 
79445:   nsresult ReplaceOrInsertBefore(bool aReplace, nsIDOMNode *aNewChild,
39585:                                  nsIDOMNode *aRefChild, nsIDOMNode **aReturn);
79445:   nsINode* ReplaceOrInsertBefore(bool aReplace, nsINode *aNewChild,
39585:                                  nsINode *aRefChild, nsresult *aReturn)
39585:   {
39585:     *aReturn = ReplaceOrInsertBefore(aReplace, aNewChild, aRefChild);
39585:     if (NS_FAILED(*aReturn)) {
39585:       return nsnull;
39585:     }
39585: 
39585:     return aReplace ? aRefChild : aNewChild;
39585:   }
79445:   virtual nsresult ReplaceOrInsertBefore(bool aReplace, nsINode* aNewChild,
39585:                                          nsINode* aRefChild);
39585:   nsresult RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn);
39585: 
41904:   /**
41904:    * Returns the Element that should be used for resolving namespaces
41904:    * on this node (ie the ownerElement for attributes, the documentElement for
41904:    * documents, the node itself for elements and for other nodes the parentNode
41904:    * if it is an element).
41904:    */
41904:   virtual mozilla::dom::Element* GetNameSpaceElement() = 0;
41904: 
42105:   /**
42105:    * Most of the implementation of the nsINode RemoveChildAt method.
42105:    * Should only be called on document, element, and document fragment
42105:    * nodes.  The aChildArray passed in should be the one for |this|.
42105:    *
42105:    * @param aIndex The index to remove at.
42105:    * @param aNotify Whether to notify.
42105:    * @param aKid The kid at aIndex.  Must not be null.
42105:    * @param aChildArray The child array to work with.
42105:    * @param aMutationEvent whether to fire a mutation event for this removal.
42105:    */
94358:   void doRemoveChildAt(PRUint32 aIndex, bool aNotify, nsIContent* aKid,
70878:                        nsAttrAndChildArray& aChildArray);
42105: 
42105:   /**
42105:    * Most of the implementation of the nsINode InsertChildAt method.
42105:    * Should only be called on document, element, and document fragment
42105:    * nodes.  The aChildArray passed in should be the one for |this|.
42105:    *
42105:    * @param aKid The child to insert.
42105:    * @param aIndex The index to insert at.
42105:    * @param aNotify Whether to notify.
42105:    * @param aChildArray The child array to work with
42105:    */
42105:   nsresult doInsertChildAt(nsIContent* aKid, PRUint32 aIndex,
79445:                            bool aNotify, nsAttrAndChildArray& aChildArray);
42105: 
80118: public:
77149:   /* Event stuff that documents and elements share.  This needs to be
77149:      NS_IMETHOD because some subclasses implement DOM methods with
77149:      this exact name and signature and then the calling convention
78484:      needs to match.
78484: 
78484:      Note that we include DOCUMENT_ONLY_EVENT events here so that we
78484:      can forward all the document stuff to this implementation.
78484:   */
77149: #define EVENT(name_, id_, type_, struct_)                         \
78613:   NS_IMETHOD GetOn##name_(JSContext *cx, JS::Value *vp);          \
78613:   NS_IMETHOD SetOn##name_(JSContext *cx, const JS::Value &v);
77149: #define TOUCH_EVENT EVENT
78484: #define DOCUMENT_ONLY_EVENT EVENT
77149: #include "nsEventNameList.h"
78484: #undef DOCUMENT_ONLY_EVENT
77149: #undef TOUCH_EVENT
77149: #undef EVENT  
77149: 
80118: protected:
77323:   static void Trace(nsINode *tmp, TraceCallback cb, void *closure);
77323:   static bool Traverse(nsINode *tmp, nsCycleCollectionTraversalCallback &cb);
77323:   static void Unlink(nsINode *tmp);
77323: 
94340:   nsCOMPtr<nsINodeInfo> mNodeInfo;
    1: 
67605:   nsINode* mParent;
    1: 
67604:   PRUint32 mFlags;
42104: 
67605: private:
67605:   // Boolean flags.
67605:   PRUint32 mBoolFlags;
67605: 
67605: protected:
42104:   nsIContent* mNextSibling;
42104:   nsIContent* mPreviousSibling;
42105:   nsIContent* mFirstChild;
50423: 
67604:   // Storage for more members that are usually not needed; allocated lazily.
67604:   nsSlots* mSlots;
    1: };
    1: 
21218: 
21218: extern const nsIID kThisPtrOffsetsSID;
21218: 
21218: // _implClass is the class to use to cast to nsISupports
21218: #define NS_OFFSET_AND_INTERFACE_TABLE_BEGIN_AMBIGUOUS(_class, _implClass)     \
21218:   static const QITableEntry offsetAndQITable[] = {                            \
21218:     NS_INTERFACE_TABLE_ENTRY_AMBIGUOUS(_class, nsISupports, _implClass)
21218: 
21218: #define NS_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                           \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_BEGIN_AMBIGUOUS(_class, _class)
21218: 
21218: #define NS_OFFSET_AND_INTERFACE_TABLE_END                                     \
21218:   { nsnull, 0 } };                                                            \
21218:   if (aIID.Equals(kThisPtrOffsetsSID)) {                                      \
21218:     *aInstancePtr =                                                           \
21218:       const_cast<void*>(static_cast<const void*>(&offsetAndQITable));         \
21218:     return NS_OK;                                                             \
21218:   }
21218: 
21218: #define NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE                            \
21218:   rv = NS_TableDrivenQI(this, offsetAndQITable, aIID, aInstancePtr);          \
21218:   NS_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: // nsNodeSH::PreCreate() depends on the identity pointer being the same as
21218: // nsINode, so if you change the nsISupports line  below, make sure
21218: // nsNodeSH::PreCreate() still does the right thing!
21218: #define NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                      \
23258:   NS_OFFSET_AND_INTERFACE_TABLE_BEGIN_AMBIGUOUS(_class, nsINode)              \
23258:     NS_INTERFACE_TABLE_ENTRY(_class, nsINode)                       
21218: 
21218: #define NS_NODE_INTERFACE_TABLE2(_class, _i1, _i2)                            \
21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: #define NS_NODE_INTERFACE_TABLE3(_class, _i1, _i2, _i3)                       \
21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: #define NS_NODE_INTERFACE_TABLE4(_class, _i1, _i2, _i3, _i4)                  \
21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: #define NS_NODE_INTERFACE_TABLE5(_class, _i1, _i2, _i3, _i4, _i5)             \
21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: #define NS_NODE_INTERFACE_TABLE6(_class, _i1, _i2, _i3, _i4, _i5, _i6)        \
21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: #define NS_NODE_INTERFACE_TABLE7(_class, _i1, _i2, _i3, _i4, _i5, _i6, _i7)   \
21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i7)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: #define NS_NODE_INTERFACE_TABLE8(_class, _i1, _i2, _i3, _i4, _i5, _i6, _i7,   \
21218:                                  _i8)                                         \
21218:   NS_NODE_OFFSET_AND_INTERFACE_TABLE_BEGIN(_class)                            \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i1)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i2)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i3)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i4)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i5)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i6)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i7)                                     \
21218:     NS_INTERFACE_TABLE_ENTRY(_class, _i8)                                     \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_END                                           \
21218:   NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: 
 9807: NS_DEFINE_STATIC_IID_ACCESSOR(nsINode, NS_INODE_IID)
    1: 
21618: 
30001: #define NS_IMPL_CYCLE_COLLECTION_TRACE_PRESERVED_WRAPPER \
30001:   nsContentUtils::TraceWrapper(tmp, aCallback, aClosure);
21618: 
21618: #define NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER \
30001:   nsContentUtils::ReleaseWrapper(s, tmp);
21618: 
21618: 
    1: #endif /* nsINode_h___ */
