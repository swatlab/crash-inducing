16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: maintain the info structure, info <-> header packets
31034:  last mod: $Id: info.c 16243 2009-07-10 02:49:31Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: /* general handling of the header and the vorbis_info structure (and
16295:    substructures) */
16295: 
16295: #include <stdlib.h>
16295: #include <string.h>
16295: #include <ctype.h>
16295: #include <ogg/ogg.h>
16295: #include "vorbis/codec.h"
16295: #include "codec_internal.h"
16295: #include "codebook.h"
16295: #include "registry.h"
16295: #include "window.h"
16295: #include "psy.h"
16295: #include "misc.h"
16295: #include "os.h"
16295: 
31034: #define GENERAL_VENDOR_STRING "Xiph.Org libVorbis 1.2.3"
31034: #define ENCODE_VENDOR_STRING "Xiph.Org libVorbis I 20090709"
30043: 
16295: /* helpers */
16295: static int ilog2(unsigned int v){
16295:   int ret=0;
16295:   if(v)--v;
16295:   while(v){
16295:     ret++;
16295:     v>>=1;
16295:   }
16295:   return(ret);
16295: }
16295: 
30043: static void _v_writestring(oggpack_buffer *o,const char *s, int bytes){
16295: 
16295:   while(bytes--){
16295:     oggpack_write(o,*s++,8);
16295:   }
16295: }
16295: 
16295: static void _v_readstring(oggpack_buffer *o,char *buf,int bytes){
16295:   while(bytes--){
16295:     *buf++=oggpack_read(o,8);
16295:   }
16295: }
16295: 
16295: void vorbis_comment_init(vorbis_comment *vc){
16295:   memset(vc,0,sizeof(*vc));
16295: }
16295: 
30043: void vorbis_comment_add(vorbis_comment *vc,const char *comment){
16295:   vc->user_comments=_ogg_realloc(vc->user_comments,
16295:                             (vc->comments+2)*sizeof(*vc->user_comments));
16295:   vc->comment_lengths=_ogg_realloc(vc->comment_lengths,
16295:                                   (vc->comments+2)*sizeof(*vc->comment_lengths));
16295:   vc->comment_lengths[vc->comments]=strlen(comment);
16295:   vc->user_comments[vc->comments]=_ogg_malloc(vc->comment_lengths[vc->comments]+1);
16295:   strcpy(vc->user_comments[vc->comments], comment);
16295:   vc->comments++;
16295:   vc->user_comments[vc->comments]=NULL;
16295: }
16295: 
30043: void vorbis_comment_add_tag(vorbis_comment *vc, const char *tag, const char *contents){
16295:   char *comment=alloca(strlen(tag)+strlen(contents)+2); /* +2 for = and \0 */
16295:   strcpy(comment, tag);
16295:   strcat(comment, "=");
16295:   strcat(comment, contents);
16295:   vorbis_comment_add(vc, comment);
16295: }
16295: 
16295: /* This is more or less the same as strncasecmp - but that doesn't exist
16295:  * everywhere, and this is a fairly trivial function, so we include it */
16295: static int tagcompare(const char *s1, const char *s2, int n){
16295:   int c=0;
16295:   while(c < n){
16295:     if(toupper(s1[c]) != toupper(s2[c]))
16295:       return !0;
16295:     c++;
16295:   }
16295:   return 0;
16295: }
16295: 
30043: char *vorbis_comment_query(vorbis_comment *vc, const char *tag, int count){
16295:   long i;
16295:   int found = 0;
16295:   int taglen = strlen(tag)+1; /* +1 for the = we append */
16295:   char *fulltag = alloca(taglen+ 1);
16295: 
16295:   strcpy(fulltag, tag);
16295:   strcat(fulltag, "=");
16295: 
16295:   for(i=0;i<vc->comments;i++){
16295:     if(!tagcompare(vc->user_comments[i], fulltag, taglen)){
16295:       if(count == found)
16295:         /* We return a pointer to the data, not a copy */
16295:               return vc->user_comments[i] + taglen;
16295:       else
16295:         found++;
16295:     }
16295:   }
16295:   return NULL; /* didn't find anything */
16295: }
16295: 
30043: int vorbis_comment_query_count(vorbis_comment *vc, const char *tag){
16295:   int i,count=0;
16295:   int taglen = strlen(tag)+1; /* +1 for the = we append */
16295:   char *fulltag = alloca(taglen+1);
16295:   strcpy(fulltag,tag);
16295:   strcat(fulltag, "=");
16295: 
16295:   for(i=0;i<vc->comments;i++){
16295:     if(!tagcompare(vc->user_comments[i], fulltag, taglen))
16295:       count++;
16295:   }
16295: 
16295:   return count;
16295: }
16295: 
16295: void vorbis_comment_clear(vorbis_comment *vc){
16295:   if(vc){
16295:     long i;
29347:     if(vc->user_comments){
16295:       for(i=0;i<vc->comments;i++)
16295:         if(vc->user_comments[i])_ogg_free(vc->user_comments[i]);
29347:       _ogg_free(vc->user_comments);
29347:     }
16295:     if(vc->comment_lengths)_ogg_free(vc->comment_lengths);
16295:     if(vc->vendor)_ogg_free(vc->vendor);
16295:     memset(vc,0,sizeof(*vc));
16295:   }
16295: }
16295: 
16295: /* blocksize 0 is guaranteed to be short, 1 is guaranteed to be long.
16295:    They may be equal, but short will never ge greater than long */
16295: int vorbis_info_blocksize(vorbis_info *vi,int zo){
16295:   codec_setup_info *ci = vi->codec_setup;
16295:   return ci ? ci->blocksizes[zo] : -1;
16295: }
16295: 
16295: /* used by synthesis, which has a full, alloced vi */
16295: void vorbis_info_init(vorbis_info *vi){
16295:   memset(vi,0,sizeof(*vi));
16295:   vi->codec_setup=_ogg_calloc(1,sizeof(codec_setup_info));
16295: }
16295: 
16295: void vorbis_info_clear(vorbis_info *vi){
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   int i;
16295: 
16295:   if(ci){
16295: 
16295:     for(i=0;i<ci->modes;i++)
16295:       if(ci->mode_param[i])_ogg_free(ci->mode_param[i]);
16295: 
16295:     for(i=0;i<ci->maps;i++) /* unpack does the range checking */
16295:       if(ci->map_param[i]) /* this may be cleaning up an aborted
16295:                               unpack, in which case the below type
16295:                               cannot be trusted */
16295:         _mapping_P[ci->map_type[i]]->free_info(ci->map_param[i]);
16295: 
16295:     for(i=0;i<ci->floors;i++) /* unpack does the range checking */
16295:       if(ci->floor_param[i]) /* this may be cleaning up an aborted
16295:                                 unpack, in which case the below type
16295:                                 cannot be trusted */
16295:         _floor_P[ci->floor_type[i]]->free_info(ci->floor_param[i]);
16295: 
16295:     for(i=0;i<ci->residues;i++) /* unpack does the range checking */
16295:       if(ci->residue_param[i]) /* this may be cleaning up an aborted
16295:                                   unpack, in which case the below type
16295:                                   cannot be trusted */
16295:         _residue_P[ci->residue_type[i]]->free_info(ci->residue_param[i]);
16295: 
16295:     for(i=0;i<ci->books;i++){
16295:       if(ci->book_param[i]){
16295:         /* knows if the book was not alloced */
16295:         vorbis_staticbook_destroy(ci->book_param[i]);
16295:       }
16295:       if(ci->fullbooks)
16295:         vorbis_book_clear(ci->fullbooks+i);
16295:     }
16295:     if(ci->fullbooks)
16295:         _ogg_free(ci->fullbooks);
16295: 
16295:     for(i=0;i<ci->psys;i++)
16295:       _vi_psy_free(ci->psy_param[i]);
16295: 
16295:     _ogg_free(ci);
16295:   }
16295: 
16295:   memset(vi,0,sizeof(*vi));
16295: }
16295: 
16295: /* Header packing/unpacking ********************************************/
16295: 
16295: static int _vorbis_unpack_info(vorbis_info *vi,oggpack_buffer *opb){
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   if(!ci)return(OV_EFAULT);
16295: 
16295:   vi->version=oggpack_read(opb,32);
16295:   if(vi->version!=0)return(OV_EVERSION);
16295: 
16295:   vi->channels=oggpack_read(opb,8);
16295:   vi->rate=oggpack_read(opb,32);
16295: 
16295:   vi->bitrate_upper=oggpack_read(opb,32);
16295:   vi->bitrate_nominal=oggpack_read(opb,32);
16295:   vi->bitrate_lower=oggpack_read(opb,32);
16295: 
16295:   ci->blocksizes[0]=1<<oggpack_read(opb,4);
16295:   ci->blocksizes[1]=1<<oggpack_read(opb,4);
16295: 
16295:   if(vi->rate<1)goto err_out;
16295:   if(vi->channels<1)goto err_out;
16295:   if(ci->blocksizes[0]<64)goto err_out;
16295:   if(ci->blocksizes[1]<ci->blocksizes[0])goto err_out;
16295:   if(ci->blocksizes[1]>8192)goto err_out;
16295: 
16295:   if(oggpack_read(opb,1)!=1)goto err_out; /* EOP check */
16295: 
16295:   return(0);
16295:  err_out:
16295:   vorbis_info_clear(vi);
16295:   return(OV_EBADHEADER);
16295: }
16295: 
16295: static int _vorbis_unpack_comment(vorbis_comment *vc,oggpack_buffer *opb){
16295:   int i;
16295:   int vendorlen=oggpack_read(opb,32);
30043:   if(vendorlen<0)goto err_out;
31034:   if(vendorlen>opb->storage-8)goto err_out;
16295:   vc->vendor=_ogg_calloc(vendorlen+1,1);
16295:   _v_readstring(opb,vc->vendor,vendorlen);
30043:   i=oggpack_read(opb,32);
30043:   if(i<0)goto err_out;
31034:   if(i>((opb->storage-oggpack_bytes(opb))>>2))goto err_out;
30043:   vc->comments=i;
16295:   vc->user_comments=_ogg_calloc(vc->comments+1,sizeof(*vc->user_comments));
16295:   vc->comment_lengths=_ogg_calloc(vc->comments+1, sizeof(*vc->comment_lengths));
16295: 
16295:   for(i=0;i<vc->comments;i++){
16295:     int len=oggpack_read(opb,32);
30043:     if(len<0)goto err_out;
31034:     if(len>opb->storage-oggpack_bytes(opb))goto err_out;
16295:     vc->comment_lengths[i]=len;
16295:     vc->user_comments[i]=_ogg_calloc(len+1,1);
16295:     _v_readstring(opb,vc->user_comments[i],len);
16295:   }
16295:   if(oggpack_read(opb,1)!=1)goto err_out; /* EOP check */
16295: 
16295:   return(0);
16295:  err_out:
16295:   vorbis_comment_clear(vc);
16295:   return(OV_EBADHEADER);
16295: }
16295: 
16295: /* all of the real encoding details are here.  The modes, books,
16295:    everything */
16295: static int _vorbis_unpack_books(vorbis_info *vi,oggpack_buffer *opb){
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   int i;
16295:   if(!ci)return(OV_EFAULT);
16295: 
16295:   /* codebooks */
16295:   ci->books=oggpack_read(opb,8)+1;
31034:   if(ci->books<=0)goto err_out;
16295:   for(i=0;i<ci->books;i++){
16295:     ci->book_param[i]=_ogg_calloc(1,sizeof(*ci->book_param[i]));
16295:     if(vorbis_staticbook_unpack(opb,ci->book_param[i]))goto err_out;
16295:   }
16295: 
16295:   /* time backend settings; hooks are unused */
16295:   {
16295:     int times=oggpack_read(opb,6)+1;
31034:     if(times<=0)goto err_out;
16295:     for(i=0;i<times;i++){
16295:       int test=oggpack_read(opb,16);
16295:       if(test<0 || test>=VI_TIMEB)goto err_out;
16295:     }
16295:   }
16295: 
16295:   /* floor backend settings */
16295:   ci->floors=oggpack_read(opb,6)+1;
31034:   if(ci->floors<=0)goto err_out;
16295:   for(i=0;i<ci->floors;i++){
16295:     ci->floor_type[i]=oggpack_read(opb,16);
16295:     if(ci->floor_type[i]<0 || ci->floor_type[i]>=VI_FLOORB)goto err_out;
16295:     ci->floor_param[i]=_floor_P[ci->floor_type[i]]->unpack(vi,opb);
16295:     if(!ci->floor_param[i])goto err_out;
16295:   }
16295: 
16295:   /* residue backend settings */
16295:   ci->residues=oggpack_read(opb,6)+1;
31034:   if(ci->residues<=0)goto err_out;
16295:   for(i=0;i<ci->residues;i++){
16295:     ci->residue_type[i]=oggpack_read(opb,16);
16295:     if(ci->residue_type[i]<0 || ci->residue_type[i]>=VI_RESB)goto err_out;
16295:     ci->residue_param[i]=_residue_P[ci->residue_type[i]]->unpack(vi,opb);
16295:     if(!ci->residue_param[i])goto err_out;
16295:   }
16295: 
16295:   /* map backend settings */
16295:   ci->maps=oggpack_read(opb,6)+1;
31034:   if(ci->maps<=0)goto err_out;
16295:   for(i=0;i<ci->maps;i++){
16295:     ci->map_type[i]=oggpack_read(opb,16);
16295:     if(ci->map_type[i]<0 || ci->map_type[i]>=VI_MAPB)goto err_out;
16295:     ci->map_param[i]=_mapping_P[ci->map_type[i]]->unpack(vi,opb);
16295:     if(!ci->map_param[i])goto err_out;
16295:   }
16295: 
16295:   /* mode settings */
16295:   ci->modes=oggpack_read(opb,6)+1;
31034:   if(ci->modes<=0)goto err_out;
16295:   for(i=0;i<ci->modes;i++){
16295:     ci->mode_param[i]=_ogg_calloc(1,sizeof(*ci->mode_param[i]));
16295:     ci->mode_param[i]->blockflag=oggpack_read(opb,1);
16295:     ci->mode_param[i]->windowtype=oggpack_read(opb,16);
16295:     ci->mode_param[i]->transformtype=oggpack_read(opb,16);
16295:     ci->mode_param[i]->mapping=oggpack_read(opb,8);
16295: 
16295:     if(ci->mode_param[i]->windowtype>=VI_WINDOWB)goto err_out;
16295:     if(ci->mode_param[i]->transformtype>=VI_WINDOWB)goto err_out;
16295:     if(ci->mode_param[i]->mapping>=ci->maps)goto err_out;
31034:     if(ci->mode_param[i]->mapping<0)goto err_out;
16295:   }
16295: 
16295:   if(oggpack_read(opb,1)!=1)goto err_out; /* top level EOP check */
16295: 
16295:   return(0);
16295:  err_out:
16295:   vorbis_info_clear(vi);
16295:   return(OV_EBADHEADER);
16295: }
16295: 
16295: /* Is this packet a vorbis ID header? */
16295: int vorbis_synthesis_idheader(ogg_packet *op){
16295:   oggpack_buffer opb;
16295:   char buffer[6];
16295: 
16295:   if(op){
16295:     oggpack_readinit(&opb,op->packet,op->bytes);
16295: 
16295:     if(!op->b_o_s)
16295:       return(0); /* Not the initial packet */
16295: 
16295:     if(oggpack_read(&opb,8) != 1)
16295:       return 0; /* not an ID header */
16295: 
16295:     memset(buffer,0,6);
16295:     _v_readstring(&opb,buffer,6);
16295:     if(memcmp(buffer,"vorbis",6))
16295:       return 0; /* not vorbis */
16295: 
16295:     return 1;
16295:   }
16295: 
16295:   return 0;
16295: }
16295: 
16295: /* The Vorbis header is in three packets; the initial small packet in
16295:    the first page that identifies basic parameters, a second packet
16295:    with bitstream comments and a third packet that holds the
16295:    codebook. */
16295: 
16295: int vorbis_synthesis_headerin(vorbis_info *vi,vorbis_comment *vc,ogg_packet *op){
16295:   oggpack_buffer opb;
16295: 
16295:   if(op){
16295:     oggpack_readinit(&opb,op->packet,op->bytes);
16295: 
16295:     /* Which of the three types of header is this? */
16295:     /* Also verify header-ness, vorbis */
16295:     {
16295:       char buffer[6];
16295:       int packtype=oggpack_read(&opb,8);
16295:       memset(buffer,0,6);
16295:       _v_readstring(&opb,buffer,6);
16295:       if(memcmp(buffer,"vorbis",6)){
16295:         /* not a vorbis header */
16295:         return(OV_ENOTVORBIS);
16295:       }
16295:       switch(packtype){
16295:       case 0x01: /* least significant *bit* is read first */
16295:         if(!op->b_o_s){
16295:           /* Not the initial packet */
16295:           return(OV_EBADHEADER);
16295:         }
16295:         if(vi->rate!=0){
16295:           /* previously initialized info header */
16295:           return(OV_EBADHEADER);
16295:         }
16295: 
16295:         return(_vorbis_unpack_info(vi,&opb));
16295: 
16295:       case 0x03: /* least significant *bit* is read first */
16295:         if(vi->rate==0){
16295:           /* um... we didn't get the initial header */
16295:           return(OV_EBADHEADER);
16295:         }
16295: 
16295:         return(_vorbis_unpack_comment(vc,&opb));
16295: 
16295:       case 0x05: /* least significant *bit* is read first */
16295:         if(vi->rate==0 || vc->vendor==NULL){
16295:           /* um... we didn;t get the initial header or comments yet */
16295:           return(OV_EBADHEADER);
16295:         }
16295: 
16295:         return(_vorbis_unpack_books(vi,&opb));
16295: 
16295:       default:
16295:         /* Not a valid vorbis header type */
16295:         return(OV_EBADHEADER);
16295:         break;
16295:       }
16295:     }
16295:   }
16295:   return(OV_EBADHEADER);
16295: }
16295: 
16295: /* pack side **********************************************************/
16295: 
16295: static int _vorbis_pack_info(oggpack_buffer *opb,vorbis_info *vi){
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   if(!ci)return(OV_EFAULT);
16295: 
16295:   /* preamble */
16295:   oggpack_write(opb,0x01,8);
16295:   _v_writestring(opb,"vorbis", 6);
16295: 
16295:   /* basic information about the stream */
16295:   oggpack_write(opb,0x00,32);
16295:   oggpack_write(opb,vi->channels,8);
16295:   oggpack_write(opb,vi->rate,32);
16295: 
16295:   oggpack_write(opb,vi->bitrate_upper,32);
16295:   oggpack_write(opb,vi->bitrate_nominal,32);
16295:   oggpack_write(opb,vi->bitrate_lower,32);
16295: 
16295:   oggpack_write(opb,ilog2(ci->blocksizes[0]),4);
16295:   oggpack_write(opb,ilog2(ci->blocksizes[1]),4);
16295:   oggpack_write(opb,1,1);
16295: 
16295:   return(0);
16295: }
16295: 
16295: static int _vorbis_pack_comment(oggpack_buffer *opb,vorbis_comment *vc){
30043:   int bytes = strlen(ENCODE_VENDOR_STRING);
16295: 
16295:   /* preamble */
16295:   oggpack_write(opb,0x03,8);
16295:   _v_writestring(opb,"vorbis", 6);
16295: 
16295:   /* vendor */
16295:   oggpack_write(opb,bytes,32);
30043:   _v_writestring(opb,ENCODE_VENDOR_STRING, bytes);
16295: 
16295:   /* comments */
16295: 
16295:   oggpack_write(opb,vc->comments,32);
16295:   if(vc->comments){
16295:     int i;
16295:     for(i=0;i<vc->comments;i++){
16295:       if(vc->user_comments[i]){
16295:         oggpack_write(opb,vc->comment_lengths[i],32);
16295:         _v_writestring(opb,vc->user_comments[i], vc->comment_lengths[i]);
16295:       }else{
16295:         oggpack_write(opb,0,32);
16295:       }
16295:     }
16295:   }
16295:   oggpack_write(opb,1,1);
16295: 
16295:   return(0);
16295: }
16295: 
16295: static int _vorbis_pack_books(oggpack_buffer *opb,vorbis_info *vi){
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   int i;
16295:   if(!ci)return(OV_EFAULT);
16295: 
16295:   oggpack_write(opb,0x05,8);
16295:   _v_writestring(opb,"vorbis", 6);
16295: 
16295:   /* books */
16295:   oggpack_write(opb,ci->books-1,8);
16295:   for(i=0;i<ci->books;i++)
16295:     if(vorbis_staticbook_pack(ci->book_param[i],opb))goto err_out;
16295: 
16295:   /* times; hook placeholders */
16295:   oggpack_write(opb,0,6);
16295:   oggpack_write(opb,0,16);
16295: 
16295:   /* floors */
16295:   oggpack_write(opb,ci->floors-1,6);
16295:   for(i=0;i<ci->floors;i++){
16295:     oggpack_write(opb,ci->floor_type[i],16);
16295:     if(_floor_P[ci->floor_type[i]]->pack)
16295:       _floor_P[ci->floor_type[i]]->pack(ci->floor_param[i],opb);
16295:     else
16295:       goto err_out;
16295:   }
16295: 
16295:   /* residues */
16295:   oggpack_write(opb,ci->residues-1,6);
16295:   for(i=0;i<ci->residues;i++){
16295:     oggpack_write(opb,ci->residue_type[i],16);
16295:     _residue_P[ci->residue_type[i]]->pack(ci->residue_param[i],opb);
16295:   }
16295: 
16295:   /* maps */
16295:   oggpack_write(opb,ci->maps-1,6);
16295:   for(i=0;i<ci->maps;i++){
16295:     oggpack_write(opb,ci->map_type[i],16);
16295:     _mapping_P[ci->map_type[i]]->pack(vi,ci->map_param[i],opb);
16295:   }
16295: 
16295:   /* modes */
16295:   oggpack_write(opb,ci->modes-1,6);
16295:   for(i=0;i<ci->modes;i++){
16295:     oggpack_write(opb,ci->mode_param[i]->blockflag,1);
16295:     oggpack_write(opb,ci->mode_param[i]->windowtype,16);
16295:     oggpack_write(opb,ci->mode_param[i]->transformtype,16);
16295:     oggpack_write(opb,ci->mode_param[i]->mapping,8);
16295:   }
16295:   oggpack_write(opb,1,1);
16295: 
16295:   return(0);
16295: err_out:
16295:   return(-1);
16295: }
16295: 
16295: int vorbis_commentheader_out(vorbis_comment *vc,
16295:                                           ogg_packet *op){
16295: 
16295:   oggpack_buffer opb;
16295: 
16295:   oggpack_writeinit(&opb);
16295:   if(_vorbis_pack_comment(&opb,vc)) return OV_EIMPL;
16295: 
16295:   op->packet = _ogg_malloc(oggpack_bytes(&opb));
16295:   memcpy(op->packet, opb.buffer, oggpack_bytes(&opb));
16295: 
16295:   op->bytes=oggpack_bytes(&opb);
16295:   op->b_o_s=0;
16295:   op->e_o_s=0;
16295:   op->granulepos=0;
16295:   op->packetno=1;
16295: 
16295:   return 0;
16295: }
16295: 
16295: int vorbis_analysis_headerout(vorbis_dsp_state *v,
16295:                               vorbis_comment *vc,
16295:                               ogg_packet *op,
16295:                               ogg_packet *op_comm,
16295:                               ogg_packet *op_code){
16295:   int ret=OV_EIMPL;
16295:   vorbis_info *vi=v->vi;
16295:   oggpack_buffer opb;
16295:   private_state *b=v->backend_state;
16295: 
16295:   if(!b){
16295:     ret=OV_EFAULT;
16295:     goto err_out;
16295:   }
16295: 
16295:   /* first header packet **********************************************/
16295: 
16295:   oggpack_writeinit(&opb);
16295:   if(_vorbis_pack_info(&opb,vi))goto err_out;
16295: 
16295:   /* build the packet */
16295:   if(b->header)_ogg_free(b->header);
16295:   b->header=_ogg_malloc(oggpack_bytes(&opb));
16295:   memcpy(b->header,opb.buffer,oggpack_bytes(&opb));
16295:   op->packet=b->header;
16295:   op->bytes=oggpack_bytes(&opb);
16295:   op->b_o_s=1;
16295:   op->e_o_s=0;
16295:   op->granulepos=0;
16295:   op->packetno=0;
16295: 
16295:   /* second header packet (comments) **********************************/
16295: 
16295:   oggpack_reset(&opb);
16295:   if(_vorbis_pack_comment(&opb,vc))goto err_out;
16295: 
16295:   if(b->header1)_ogg_free(b->header1);
16295:   b->header1=_ogg_malloc(oggpack_bytes(&opb));
16295:   memcpy(b->header1,opb.buffer,oggpack_bytes(&opb));
16295:   op_comm->packet=b->header1;
16295:   op_comm->bytes=oggpack_bytes(&opb);
16295:   op_comm->b_o_s=0;
16295:   op_comm->e_o_s=0;
16295:   op_comm->granulepos=0;
16295:   op_comm->packetno=1;
16295: 
16295:   /* third header packet (modes/codebooks) ****************************/
16295: 
16295:   oggpack_reset(&opb);
16295:   if(_vorbis_pack_books(&opb,vi))goto err_out;
16295: 
16295:   if(b->header2)_ogg_free(b->header2);
16295:   b->header2=_ogg_malloc(oggpack_bytes(&opb));
16295:   memcpy(b->header2,opb.buffer,oggpack_bytes(&opb));
16295:   op_code->packet=b->header2;
16295:   op_code->bytes=oggpack_bytes(&opb);
16295:   op_code->b_o_s=0;
16295:   op_code->e_o_s=0;
16295:   op_code->granulepos=0;
16295:   op_code->packetno=2;
16295: 
16295:   oggpack_writeclear(&opb);
16295:   return(0);
16295:  err_out:
16295:   oggpack_writeclear(&opb);
16295:   memset(op,0,sizeof(*op));
16295:   memset(op_comm,0,sizeof(*op_comm));
16295:   memset(op_code,0,sizeof(*op_code));
16295: 
16295:   if(b){
16295:     if(b->header)_ogg_free(b->header);
16295:     if(b->header1)_ogg_free(b->header1);
16295:     if(b->header2)_ogg_free(b->header2);
16295:     b->header=NULL;
16295:     b->header1=NULL;
16295:     b->header2=NULL;
16295:   }
16295:   return(ret);
16295: }
16295: 
16295: double vorbis_granule_time(vorbis_dsp_state *v,ogg_int64_t granulepos){
16295:   if(granulepos>=0)
16295:     return((double)granulepos/v->vi->rate);
16295:   return(-1);
16295: }
30043: 
30043: const char *vorbis_version_string(void){
30043:   return GENERAL_VENDOR_STRING;
30043: }
