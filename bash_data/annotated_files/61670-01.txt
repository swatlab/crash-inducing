42593: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
42593:  * ***** BEGIN LICENSE BLOCK *****
42593:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42593:  *
42593:  * The contents of this file are subject to the Mozilla Public License Version
42593:  * 1.1 (the "License"); you may not use this file except in compliance with
42593:  * the License. You may obtain a copy of the License at
42593:  * http://www.mozilla.org/MPL/
42593:  *
42593:  * Software distributed under the License is distributed on an "AS IS" basis,
42593:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42593:  * for the specific language governing rights and limitations under the
42593:  * License.
42593:  *
42593:  * The Original Code is Mozilla Corporation code.
42593:  *
42593:  * The Initial Developer of the Original Code is Mozilla Foundation.
42593:  * Portions created by the Initial Developer are Copyright (C) 2010
42593:  * the Initial Developer. All Rights Reserved.
42593:  *
42593:  * Contributor(s):
42593:  *   Robert O'Callahan <robert@ocallahan.org>
42593:  *
42593:  * Alternatively, the contents of this file may be used under the terms of
42593:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42593:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42593:  * in which case the provisions of the GPL or the LGPL are applicable instead
42593:  * of those above. If you wish to allow use of your version of this file only
42593:  * under the terms of either the GPL or the LGPL, and not to allow others to
42593:  * use your version of this file under the terms of the MPL, indicate your
42593:  * decision by deleting the provisions above and replace them with the notice
42593:  * and other provisions required by the GPL or the LGPL. If you do not delete
42593:  * the provisions above, a recipient may use your version of this file under
42593:  * the terms of any one of the MPL, the GPL or the LGPL.
42593:  *
42593:  * ***** END LICENSE BLOCK ***** */
42593: 
42593: #include "FrameLayerBuilder.h"
42593: 
42593: #include "nsDisplayList.h"
42593: #include "nsPresContext.h"
42593: #include "nsLayoutUtils.h"
47736: #include "Layers.h"
47751: #include "BasicLayers.h"
51754: #include "nsSubDocumentFrame.h"
52292: #include "nsCSSRendering.h"
54261: #include "nsCSSFrameConstructor.h"
58579: #include "gfxUtils.h"
60712: #include "nsImageFrame.h"
47736: 
47736: #ifdef DEBUG
47736: #include <stdio.h>
47736: #endif
42593: 
42593: using namespace mozilla::layers;
42593: 
42593: namespace mozilla {
42593: 
42593: namespace {
42593: 
42593: /**
47736:  * This is the userdata we associate with a layer manager.
42593:  */
51946: class LayerManagerData : public LayerUserData {
42593: public:
58809:   LayerManagerData(LayerManager *aManager) :
47736:     mInvalidateAllThebesContent(PR_FALSE),
58809:     mInvalidateAllLayers(PR_FALSE),
58809:     mLayerManager(aManager)
42593:   {
51946:     MOZ_COUNT_CTOR(LayerManagerData);
47736:     mFramesWithLayers.Init();
42593:   }
51946:   ~LayerManagerData() {
51947:     // Remove display item data properties now, since we won't be able
51947:     // to find these frames again without mFramesWithLayers.
51947:     mFramesWithLayers.EnumerateEntries(
51947:         FrameLayerBuilder::RemoveDisplayItemDataForFrame, nsnull);
51946:     MOZ_COUNT_DTOR(LayerManagerData);
51946:   }
42593: 
47736:   /**
47736:    * Tracks which frames have layers associated with them.
47736:    */
47736:   nsTHashtable<nsPtrHashKey<nsIFrame> > mFramesWithLayers;
47736:   PRPackedBool mInvalidateAllThebesContent;
47736:   PRPackedBool mInvalidateAllLayers;
58809:   /** Layer manager we belong to, we hold a reference to this object. */
58809:   nsRefPtr<LayerManager> mLayerManager;
42593: };
42593: 
47736: static void DestroyRegion(void* aPropertyValue)
42593: {
47736:   delete static_cast<nsRegion*>(aPropertyValue);
42593: }
42593: 
47736: /**
47736:  * This property represents a region that should be invalidated in every
47736:  * ThebesLayer child whose parent ContainerLayer is associated with the
47736:  * frame. This is an nsRegion*; the coordinates of the region are
47736:  * relative to the top-left of the border-box of the frame the property
47736:  * is attached to (which is the frame for the ContainerLayer).
47736:  * 
47736:  * We add to this region in InvalidateThebesLayerContents. The region
47736:  * is propagated to ContainerState in BuildContainerLayerFor, and then
47736:  * the region(s) are actually invalidated in CreateOrRecycleThebesLayer.
51752:  *
51752:  * When the property value is null, the region is infinite --- i.e. all
51752:  * areas of the ThebesLayers should be invalidated.
47736:  */
47736: NS_DECLARE_FRAME_PROPERTY(ThebesLayerInvalidRegionProperty, DestroyRegion)
47736: 
47736: /**
47736:  * This is a helper object used to build up the layer children for
47736:  * a ContainerLayer.
47736:  */
47736: class ContainerState {
47736: public:
47736:   ContainerState(nsDisplayListBuilder* aBuilder,
47736:                  LayerManager* aManager,
47736:                  nsIFrame* aContainerFrame,
47736:                  ContainerLayer* aContainerLayer) :
47736:     mBuilder(aBuilder), mManager(aManager),
47736:     mContainerFrame(aContainerFrame), mContainerLayer(aContainerLayer),
47745:     mNextFreeRecycledThebesLayer(0), mNextFreeRecycledColorLayer(0),
60712:     mNextFreeRecycledImageLayer(0), mInvalidateAllThebesContent(PR_FALSE)
47736:   {
47745:     CollectOldLayers();
47736:   }
47736: 
47736:   void SetInvalidThebesContent(const nsIntRegion& aRegion)
47736:   {
47736:     mInvalidThebesContent = aRegion;
47736:   }
47736:   void SetInvalidateAllThebesContent()
47736:   {
47736:     mInvalidateAllThebesContent = PR_TRUE;
47736:   }
47736:   /**
47736:    * This is the method that actually walks a display list and builds
47736:    * the child layers. We invoke it recursively to process clipped sublists.
47736:    * @param aClipRect the clip rect to apply to the list items, or null
47736:    * if no clipping is required
47736:    */
47736:   void ProcessDisplayItems(const nsDisplayList& aList,
61322:                            FrameLayerBuilder::Clip& aClip);
47736:   /**
47736:    * This finalizes all the open ThebesLayers by popping every element off
47736:    * mThebesLayerDataStack, then sets the children of the container layer
47736:    * to be all the layers in mNewChildLayers in that order and removes any
47736:    * layers as children of the container that aren't in mNewChildLayers.
59482:    * @param aTextContentFlags if any child layer has CONTENT_COMPONENT_ALPHA,
59482:    * set *aTextContentFlags to CONTENT_COMPONENT_ALPHA
47736:    */
59481:   void Finish(PRUint32 *aTextContentFlags);
47736: 
47736: protected:
47736:   /**
47736:    * We keep a stack of these to represent the ThebesLayers that are
47736:    * currently available to have display items added to.
47736:    * We use a stack here because as much as possible we want to
47736:    * assign display items to existing ThebesLayers, and to the lowest
47736:    * ThebesLayer in z-order. This reduces the number of layers and
47736:    * makes it more likely a display item will be rendered to an opaque
47736:    * layer, giving us the best chance of getting subpixel AA.
47736:    */
47736:   class ThebesLayerData {
47736:   public:
47745:     ThebesLayerData() :
47745:       mActiveScrolledRoot(nsnull), mLayer(nsnull),
51951:       mIsSolidColorInVisibleRegion(PR_FALSE),
59482:       mNeedComponentAlpha(PR_FALSE),
60712:       mForceTransparentSurface(PR_FALSE),
60712:       mImage(nsnull) {}
47736:     /**
47736:      * Record that an item has been added to the ThebesLayer, so we
47736:      * need to update our regions.
47772:      * @param aVisibleRect the area of the item that's visible
48689:      * @param aDrawRect the area of the item that would be drawn if it
48689:      * was completely visible
47772:      * @param aOpaqueRect if non-null, the area of the item that's opaque.
47772:      * We pass in a separate opaque rect because the opaque rect can be
47772:      * bigger than the visible rect, and we want to have the biggest
47772:      * opaque rect that we can.
47772:      * @param aSolidColor if non-null, the visible area of the item is
47772:      * a constant color given by *aSolidColor
47736:      */
51949:     void Accumulate(nsDisplayListBuilder* aBuilder,
51949:                     nsDisplayItem* aItem,
51949:                     const nsIntRect& aVisibleRect,
59779:                     const nsIntRect& aDrawRect,
59779:                     const FrameLayerBuilder::Clip& aClip);
47736:     nsIFrame* GetActiveScrolledRoot() { return mActiveScrolledRoot; }
47736: 
47736:     /**
60712:      * If this represents only a nsDisplayImage, and the image type
60712:      * supports being optimized to an ImageLayer (TYPE_RASTER only) returns
60712:      * an ImageContainer for the image.
60712:      */
60712:     nsRefPtr<ImageContainer> CanOptimizeImageLayer(LayerManager* aManager);
60712: 
60712:     /**
47736:      * The region of visible content in the layer, relative to the
47736:      * container layer (which is at the snapped top-left of the display
47736:      * list reference frame).
47736:      */
47736:     nsIntRegion  mVisibleRegion;
47736:     /**
47736:      * The region of visible content above the layer and below the
47736:      * next ThebesLayerData currently in the stack, if any. Note that not
47736:      * all ThebesLayers for the container are in the ThebesLayerData stack.
47736:      * Same coordinate system as mVisibleRegion.
47736:      */
47736:     nsIntRegion  mVisibleAboveRegion;
47736:     /**
48689:      * The region containing the bounds of all display items in the layer,
48689:      * regardless of visbility.
48689:      * Same coordinate system as mVisibleRegion.
48689:      */
48689:     nsIntRegion  mDrawRegion;
48689:     /**
48689:      * The region containing the bounds of all display items (regardless
48689:      * of visibility) in the layer and below the next ThebesLayerData
48689:      * currently in the stack, if any.
48689:      * Note that not all ThebesLayers for the container are in the
48689:      * ThebesLayerData stack.
48689:      * Same coordinate system as mVisibleRegion.
48689:      */
48689:     nsIntRegion  mDrawAboveRegion;
48689:     /**
47736:      * The region of visible content in the layer that is opaque.
47736:      * Same coordinate system as mVisibleRegion.
47736:      */
47736:     nsIntRegion  mOpaqueRegion;
47736:     /**
47736:      * The "active scrolled root" for all content in the layer. Must
47736:      * be non-null; all content in a ThebesLayer must have the same
47736:      * active scrolled root.
47736:      */
47736:     nsIFrame*    mActiveScrolledRoot;
47736:     ThebesLayer* mLayer;
47745:     /**
47745:      * If mIsSolidColorInVisibleRegion is true, this is the color of the visible
47745:      * region.
47745:      */
47745:     nscolor      mSolidColor;
47745:     /**
47745:      * True if every pixel in mVisibleRegion will have color mSolidColor.
47745:      */
47745:     PRPackedBool mIsSolidColorInVisibleRegion;
51951:     /**
51951:      * True if there is any text visible in the layer that's over
51951:      * transparent pixels in the layer.
51951:      */
59482:     PRPackedBool mNeedComponentAlpha;
56101:     /**
56101:      * Set if the layer should be treated as transparent, even if its entire
56101:      * area is covered by opaque display items. For example, this needs to
56101:      * be set if something is going to "punch holes" in the layer by clearing
56101:      * part of its surface.
56101:      */
56101:     PRPackedBool mForceTransparentSurface;
60712: 
60712:     /**
60712:      * Stores the pointer to the nsDisplayImage if we want to
60712:      * convert this to an ImageLayer.
60712:      */
60712:     nsDisplayImage* mImage;
42593:   };
42593: 
42593:   /**
47736:    * Grab the next recyclable ThebesLayer, or create one if there are no
47736:    * more recyclable ThebesLayers. Does any necessary invalidation of
47736:    * a recycled ThebesLayer, and sets up the transform on the ThebesLayer
47745:    * to account for scrolling.
42593:    */
47736:   already_AddRefed<ThebesLayer> CreateOrRecycleThebesLayer(nsIFrame* aActiveScrolledRoot);
47736:   /**
47745:    * Grab the next recyclable ColorLayer, or create one if there are no
47745:    * more recyclable ColorLayers.
47745:    */
47745:   already_AddRefed<ColorLayer> CreateOrRecycleColorLayer();
47745:   /**
60712:    * Grab the next recyclable ImageLayer, or create one if there are no
60712:    * more recyclable ImageLayers.
60712:    */
60712:   already_AddRefed<ImageLayer> CreateOrRecycleImageLayer();
60712:   /**
47745:    * Grabs all ThebesLayers and ColorLayers from the ContainerLayer and makes them
47736:    * available for recycling.
47736:    */
47745:   void CollectOldLayers();
47736:   /**
47751:    * If aItem used to belong to a ThebesLayer, invalidates the area of
47751:    * aItem in that layer. If aNewLayer is a ThebesLayer, invalidates the area of
47751:    * aItem in that layer.
47751:    */
47751:   void InvalidateForLayerChange(nsDisplayItem* aItem, Layer* aNewLayer);
47751:   /**
51947:    * Try to determine whether the ThebesLayer at aThebesLayerIndex
60025:    * has a single opaque color behind it, over the entire bounds of its visible
60025:    * region.
51947:    * If successful, return that color, otherwise return NS_RGBA(0,0,0,0).
51947:    */
51947:   nscolor FindOpaqueBackgroundColorFor(PRInt32 aThebesLayerIndex);
51947:   /**
47736:    * Indicate that we are done adding items to the ThebesLayer at the top of
47736:    * mThebesLayerDataStack. Set the final visible region and opaque-content
47736:    * flag, and pop it off the stack.
47736:    */
47736:   void PopThebesLayerData();
47736:   /**
47736:    * Find the ThebesLayer to which we should assign the next display item.
48689:    * We scan the ThebesLayerData stack to find the topmost ThebesLayer
48689:    * that is compatible with the display item (i.e., has the same
48689:    * active scrolled root), and that has no content from other layers above
48689:    * it and intersecting the aVisibleRect.
47736:    * Returns the layer, and also updates the ThebesLayerData. Will
48689:    * push a new ThebesLayerData onto the stack if no suitable existing
48689:    * layer is found. If we choose a ThebesLayer that's already on the
48689:    * ThebesLayerData stack, later elements on the stack will be popped off.
47736:    * @param aVisibleRect the area of the next display item that's visible
47736:    * @param aActiveScrolledRoot the active scrolled root for the next
47736:    * display item
47772:    * @param aOpaqueRect if non-null, a region of the display item that is opaque
47745:    * @param aSolidColor if non-null, indicates that every pixel in aVisibleRect
47745:    * will be painted with aSolidColor by the item
47736:    */
51949:   already_AddRefed<ThebesLayer> FindThebesLayerFor(nsDisplayItem* aItem,
51949:                                                    const nsIntRect& aVisibleRect,
48689:                                                    const nsIntRect& aDrawRect,
59779:                                                    const FrameLayerBuilder::Clip& aClip,
51949:                                                    nsIFrame* aActiveScrolledRoot);
47736:   ThebesLayerData* GetTopThebesLayerData()
47736:   {
47736:     return mThebesLayerDataStack.IsEmpty() ? nsnull
47736:         : mThebesLayerDataStack[mThebesLayerDataStack.Length() - 1].get();
47736:   }
42593: 
47736:   nsDisplayListBuilder*            mBuilder;
47736:   LayerManager*                    mManager;
47736:   nsIFrame*                        mContainerFrame;
47736:   ContainerLayer*                  mContainerLayer;
47736:   /**
47736:    * The region of ThebesLayers that should be invalidated every time
47736:    * we recycle one.
47736:    */
47736:   nsIntRegion                      mInvalidThebesContent;
47736:   nsAutoTArray<nsAutoPtr<ThebesLayerData>,1>  mThebesLayerDataStack;
47736:   /**
47736:    * We collect the list of children in here. During ProcessDisplayItems,
47736:    * the layers in this array either have mContainerLayer as their parent,
47736:    * or no parent.
47736:    */
57140:   typedef nsAutoTArray<nsRefPtr<Layer>,1> AutoLayersArray;
57140:   AutoLayersArray                  mNewChildLayers;
47736:   nsTArray<nsRefPtr<ThebesLayer> > mRecycledThebesLayers;
47745:   nsTArray<nsRefPtr<ColorLayer> >  mRecycledColorLayers;
60712:   nsTArray<nsRefPtr<ImageLayer> >  mRecycledImageLayers;
47736:   PRUint32                         mNextFreeRecycledThebesLayer;
47745:   PRUint32                         mNextFreeRecycledColorLayer;
60712:   PRUint32                         mNextFreeRecycledImageLayer;
47736:   PRPackedBool                     mInvalidateAllThebesContent;
42593: };
42593: 
51947: class ThebesDisplayItemLayerUserData : public LayerUserData
51947: {
51947: public:
51947:   ThebesDisplayItemLayerUserData() :
51947:     mForcedBackgroundColor(NS_RGBA(0,0,0,0)) {}
51947: 
60025:   /**
60025:    * A color that should be painted over the bounds of the layer's visible
60025:    * region before any other content is painted.
60025:    */
51947:   nscolor mForcedBackgroundColor;
51947: };
51947: 
42593: /**
47736:  * The address of gThebesDisplayItemLayerUserData is used as the user
51946:  * data key for ThebesLayers created by FrameLayerBuilder.
47736:  * It identifies ThebesLayers used to draw non-layer content, which are
47736:  * therefore eligible for recycling. We want display items to be able to
47736:  * create their own dedicated ThebesLayers in BuildLayer, if necessary,
47736:  * and we wouldn't want to accidentally recycle those.
51947:  * The user data is a ThebesDisplayItemLayerUserData.
42593:  */
51946: PRUint8 gThebesDisplayItemLayerUserData;
47745: /**
47745:  * The address of gColorLayerUserData is used as the user
51946:  * data key for ColorLayers created by FrameLayerBuilder.
51946:  * The user data is null.
47745:  */
51946: PRUint8 gColorLayerUserData;
51946: /**
60712:  * The address of gImageLayerUserData is used as the user
60712:  * data key for ImageLayers created by FrameLayerBuilder.
60712:  * The user data is null.
60712:  */
60712: PRUint8 gImageLayerUserData;
60712: /**
51946:  * The address of gLayerManagerUserData is used as the user
51946:  * data key for retained LayerManagers managed by FrameLayerBuilder.
51946:  * The user data is a LayerManagerData.
51946:  */
51946: PRUint8 gLayerManagerUserData;
42593: 
47736: } // anonymous namespace
47736: 
54261: void
54261: FrameLayerBuilder::Init(nsDisplayListBuilder* aBuilder)
54261: {
54261:   mRootPresContext = aBuilder->ReferenceFrame()->PresContext()->GetRootPresContext();
54261:   if (mRootPresContext) {
54261:     mInitialDOMGeneration = mRootPresContext->GetDOMGeneration();
54261:   }
54261: }
54261: 
47736: PRBool
47736: FrameLayerBuilder::DisplayItemDataEntry::HasContainerLayer()
42593: {
47736:   for (PRUint32 i = 0; i < mData.Length(); ++i) {
47736:     if (mData[i].mLayer->GetType() == Layer::TYPE_CONTAINER)
47736:       return PR_TRUE;
47736:   }
47736:   return PR_FALSE;
42593: }
42593: 
47736: /* static */ void
47736: FrameLayerBuilder::InternalDestroyDisplayItemData(nsIFrame* aFrame,
47736:                                                   void* aPropertyValue,
47736:                                                   PRBool aRemoveFromFramesWithLayers)
47736: {
47736:   nsRefPtr<LayerManager> managerRef;
47736:   nsTArray<DisplayItemData>* array =
47736:     reinterpret_cast<nsTArray<DisplayItemData>*>(&aPropertyValue);
47736:   NS_ASSERTION(!array->IsEmpty(), "Empty arrays should not be stored");
47736: 
47736:   if (aRemoveFromFramesWithLayers) {
47736:     LayerManager* manager = array->ElementAt(0).mLayer->Manager();
47736:     LayerManagerData* data = static_cast<LayerManagerData*>
51946:       (manager->GetUserData(&gLayerManagerUserData));
47736:     NS_ASSERTION(data, "Frame with layer should have been recorded");
47736:     data->mFramesWithLayers.RemoveEntry(aFrame);
47736:     if (data->mFramesWithLayers.Count() == 0) {
58809:       // Destroying our user data will consume a reference from the layer
58809:       // manager. But don't actually release until we've released all the layers
58809:       // in the DisplayItemData array below!
58809:       managerRef = manager;
51946:       manager->RemoveUserData(&gLayerManagerUserData);
42593:     }
42593:   }
42593: 
47736:   array->~nsTArray<DisplayItemData>();
42593: }
42593: 
47736: /* static */ void
47736: FrameLayerBuilder::DestroyDisplayItemData(nsIFrame* aFrame,
47736:                                           void* aPropertyValue)
47736: {
47736:   InternalDestroyDisplayItemData(aFrame, aPropertyValue, PR_TRUE);
47736: }
47736: 
47736: void
60857: FrameLayerBuilder::DidBeginRetainedLayerTransaction(LayerManager* aManager)
47736: {
47736:   mRetainingManager = aManager;
47736:   LayerManagerData* data = static_cast<LayerManagerData*>
51946:     (aManager->GetUserData(&gLayerManagerUserData));
47736:   if (data) {
47736:     mInvalidateAllThebesContent = data->mInvalidateAllThebesContent;
47736:     mInvalidateAllLayers = data->mInvalidateAllLayers;
47736:   }
42593: }
42593: 
42593: /**
47736:  * A helper function to remove the mThebesLayerItems entries for every
47736:  * layer in aLayer's subtree.
42593:  */
47736: void
47736: FrameLayerBuilder::RemoveThebesItemsForLayerSubtree(Layer* aLayer)
42593: {
47736:   ThebesLayer* thebes = aLayer->AsThebesLayer();
47736:   if (thebes) {
47736:     mThebesLayerItems.RemoveEntry(thebes);
47736:     return;
42593:   }
42593: 
47736:   for (Layer* child = aLayer->GetFirstChild(); child;
47736:        child = child->GetNextSibling()) {
47736:     RemoveThebesItemsForLayerSubtree(child);
47736:   }
47736: }
47736: 
47736: void
47736: FrameLayerBuilder::DidEndTransaction(LayerManager* aManager)
42593: {
47736:   if (aManager != mRetainingManager) {
47736:     Layer* root = aManager->GetRoot();
47736:     if (root) {
47736:       RemoveThebesItemsForLayerSubtree(root);
42593:     }
47771:   }
42593: }
47736: 
47771: void
47771: FrameLayerBuilder::WillEndTransaction(LayerManager* aManager)
47771: {
47771:   if (aManager != mRetainingManager)
47771:     return;
47771: 
47771:   // We need to save the data we'll need to support retaining. We do this
47771:   // before we paint so that invalidation triggered by painting will
47771:   // be able to update the ThebesLayerInvalidRegionProperty values
47771:   // correctly and the NS_FRAME_HAS_CONTAINER_LAYER bits will be set
47771:   // correctly.
47736:   LayerManagerData* data = static_cast<LayerManagerData*>
51946:     (mRetainingManager->GetUserData(&gLayerManagerUserData));
47736:   if (data) {
47736:     // Update all the frames that used to have layers.
47736:     data->mFramesWithLayers.EnumerateEntries(UpdateDisplayItemDataForFrame, this);
47736:   } else {
58809:     data = new LayerManagerData(mRetainingManager);
51946:     mRetainingManager->SetUserData(&gLayerManagerUserData, data);
47736:   }
47736:   // Now go through all the frames that didn't have any retained
47736:   // display items before, and record those retained display items.
47736:   // This also empties mNewDisplayItemData.
47736:   mNewDisplayItemData.EnumerateEntries(StoreNewDisplayItemData, data);
47736:   data->mInvalidateAllThebesContent = PR_FALSE;
47736:   data->mInvalidateAllLayers = PR_FALSE;
47736: 
47736:   NS_ASSERTION(data->mFramesWithLayers.Count() > 0,
47736:                "Some frame must have a layer!");
47736: }
47736: 
47736: /* static */ PLDHashOperator
47736: FrameLayerBuilder::UpdateDisplayItemDataForFrame(nsPtrHashKey<nsIFrame>* aEntry,
47736:                                                  void* aUserArg)
47736: {
47736:   FrameLayerBuilder* builder = static_cast<FrameLayerBuilder*>(aUserArg);
47736:   nsIFrame* f = aEntry->GetKey();
47736:   FrameProperties props = f->Properties();
47736:   DisplayItemDataEntry* newDisplayItems =
51947:     builder ? builder->mNewDisplayItemData.GetEntry(f) : nsnull;
47736:   if (!newDisplayItems) {
47736:     // This frame was visible, but isn't anymore.
47736:     PRBool found;
47736:     void* prop = props.Remove(DisplayItemDataProperty(), &found);
47736:     NS_ASSERTION(found, "How can the frame property be missing?");
47736:     // Pass PR_FALSE to not remove from mFramesWithLayers, we'll remove it
47736:     // by returning PL_DHASH_REMOVE below.
47736:     // Note that DestroyDisplayItemData would delete the user data
47736:     // for the retained layer manager if it removed the last entry from
47736:     // mFramesWithLayers, but we won't. That's OK because our caller
47736:     // is DidEndTransaction, which would recreate the user data
47736:     // anyway.
47736:     InternalDestroyDisplayItemData(f, prop, PR_FALSE);
47736:     props.Delete(ThebesLayerInvalidRegionProperty());
47736:     f->RemoveStateBits(NS_FRAME_HAS_CONTAINER_LAYER);
47736:     return PL_DHASH_REMOVE;
47736:   }
47736: 
51752:   if (newDisplayItems->HasContainerLayer()) {
51752:     // Reset or create the invalid region now so we can start collecting
51752:     // new dirty areas.
51870:     // Note that the NS_FRAME_HAS_CONTAINER_LAYER bit is set in
51870:     // BuildContainerLayerFor, so we don't need to set it here.
47736:     nsRegion* invalidRegion = static_cast<nsRegion*>
47736:       (props.Get(ThebesLayerInvalidRegionProperty()));
47736:     if (invalidRegion) {
47736:       invalidRegion->SetEmpty();
51752:     } else {
51752:       props.Set(ThebesLayerInvalidRegionProperty(), new nsRegion());
51752:     }
51752:   } else {
51752:     props.Delete(ThebesLayerInvalidRegionProperty());
51752:     f->RemoveStateBits(NS_FRAME_HAS_CONTAINER_LAYER);
47736:   }
47736: 
47736:   // We need to remove and re-add the DisplayItemDataProperty in
47736:   // case the nsTArray changes the value of its mHdr.
47736:   void* propValue = props.Remove(DisplayItemDataProperty());
47736:   NS_ASSERTION(propValue, "mFramesWithLayers out of sync");
47736:   PR_STATIC_ASSERT(sizeof(nsTArray<DisplayItemData>) == sizeof(void*));
47736:   nsTArray<DisplayItemData>* array =
47736:     reinterpret_cast<nsTArray<DisplayItemData>*>(&propValue);
47736:   // Steal the list of display item layers
47736:   array->SwapElements(newDisplayItems->mData);
47736:   props.Set(DisplayItemDataProperty(), propValue);
47736:   // Don't need to process this frame again
47736:   builder->mNewDisplayItemData.RawRemoveEntry(newDisplayItems);
47736:   return PL_DHASH_NEXT;
47736: }
47736: 
47736: /* static */ PLDHashOperator
47736: FrameLayerBuilder::StoreNewDisplayItemData(DisplayItemDataEntry* aEntry,
47736:                                            void* aUserArg)
47736: {
47736:   LayerManagerData* data = static_cast<LayerManagerData*>(aUserArg);
47736:   nsIFrame* f = aEntry->GetKey();
51870:   FrameProperties props = f->Properties();
47736:   // Remember that this frame has display items in retained layers
47736:   NS_ASSERTION(!data->mFramesWithLayers.GetEntry(f),
47736:                "We shouldn't get here if we're already in mFramesWithLayers");
47736:   data->mFramesWithLayers.PutEntry(f);
51870:   NS_ASSERTION(!props.Get(DisplayItemDataProperty()),
47736:                "mFramesWithLayers out of sync");
47736: 
47736:   void* propValue;
47736:   nsTArray<DisplayItemData>* array =
47736:     new (&propValue) nsTArray<DisplayItemData>();
47736:   // Steal the list of display item layers
47736:   array->SwapElements(aEntry->mData);
47736:   // Save it
51870:   props.Set(DisplayItemDataProperty(), propValue);
47736: 
51870:   if (f->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER) {
51870:     props.Set(ThebesLayerInvalidRegionProperty(), new nsRegion());
51870:   }
47736:   return PL_DHASH_REMOVE;
47736: }
47736: 
47736: Layer*
47736: FrameLayerBuilder::GetOldLayerFor(nsIFrame* aFrame, PRUint32 aDisplayItemKey)
47736: {
47736:   // If we need to build a new layer tree, then just refuse to recycle
47736:   // anything.
47736:   if (!mRetainingManager || mInvalidateAllLayers)
47736:     return nsnull;
47736: 
47736:   void* propValue = aFrame->Properties().Get(DisplayItemDataProperty());
47736:   if (!propValue)
47736:     return nsnull;
47736: 
47736:   nsTArray<DisplayItemData>* array =
47736:     (reinterpret_cast<nsTArray<DisplayItemData>*>(&propValue));
47736:   for (PRUint32 i = 0; i < array->Length(); ++i) {
47736:     if (array->ElementAt(i).mDisplayItemKey == aDisplayItemKey) {
47736:       Layer* layer = array->ElementAt(i).mLayer;
47736:       if (layer->Manager() == mRetainingManager)
47736:         return layer;
47736:     }
47736:   }
47736:   return nsnull;
42593: }
42593: 
42593: /**
47736:  * Invalidate aRegion in aLayer. aLayer is in the coordinate system
47736:  * *after* aLayer's transform has been applied, so we need to
47736:  * apply the inverse of that transform before calling InvalidateRegion.
47736:  * Currently we assume that the transform is just an integer translation,
47736:  * since that's all we need for scrolling.
42593:  */
47736: static void
47736: InvalidatePostTransformRegion(ThebesLayer* aLayer, const nsIntRegion& aRegion)
42593: {
47736:   gfxMatrix transform;
47736:   if (aLayer->GetTransform().Is2D(&transform)) {
47736:     NS_ASSERTION(!transform.HasNonIntegerTranslation(),
47736:                  "Matrix not just an integer translation?");
47736:     // Convert the region from the coordinates of the container layer
47736:     // (relative to the snapped top-left of the display list reference frame)
47736:     // to the ThebesLayer's own coordinates
47736:     nsIntRegion rgn = aRegion;
47736:     rgn.MoveBy(-nsIntPoint(PRInt32(transform.x0), PRInt32(transform.y0)));
47736:     aLayer->InvalidateRegion(rgn);
42593:   } else {
47736:     NS_ERROR("Only 2D transformations currently supported");
42593:   }
42593: }
42593: 
47745: already_AddRefed<ColorLayer>
47745: ContainerState::CreateOrRecycleColorLayer()
47745: {
47745:   nsRefPtr<ColorLayer> layer;
47745:   if (mNextFreeRecycledColorLayer < mRecycledColorLayers.Length()) {
47745:     // Recycle a layer
47745:     layer = mRecycledColorLayers[mNextFreeRecycledColorLayer];
47745:     ++mNextFreeRecycledColorLayer;
47745:     // Clear clip rect so we don't accidentally stay clipped. We will
47745:     // reapply any necessary clipping.
47745:     layer->SetClipRect(nsnull);
47745:   } else {
47745:     // Create a new layer
47745:     layer = mManager->CreateColorLayer();
47745:     if (!layer)
47745:       return nsnull;
47745:     // Mark this layer as being used for Thebes-painting display items
51946:     layer->SetUserData(&gColorLayerUserData, nsnull);
47745:   }
47745:   return layer.forget();
47745: }
47745: 
60712: already_AddRefed<ImageLayer>
60712: ContainerState::CreateOrRecycleImageLayer()
60712: {
60712:   nsRefPtr<ImageLayer> layer;
60712:   if (mNextFreeRecycledImageLayer < mRecycledImageLayers.Length()) {
60712:     // Recycle a layer
60712:     layer = mRecycledImageLayers[mNextFreeRecycledImageLayer];
60712:     ++mNextFreeRecycledImageLayer;
60712:     // Clear clip rect so we don't accidentally stay clipped. We will
60712:     // reapply any necessary clipping.
60712:     layer->SetClipRect(nsnull);
60712:   } else {
60712:     // Create a new layer
60712:     layer = mManager->CreateImageLayer();
60712:     if (!layer)
60712:       return nsnull;
60712:     // Mark this layer as being used for Thebes-painting display items
60712:     layer->SetUserData(&gImageLayerUserData, nsnull);
60712:   }
60712:   return layer.forget();
60712: }
60712: 
47736: already_AddRefed<ThebesLayer>
47736: ContainerState::CreateOrRecycleThebesLayer(nsIFrame* aActiveScrolledRoot)
47736: {
47736:   // We need a new thebes layer
47736:   nsRefPtr<ThebesLayer> layer;
47745:   if (mNextFreeRecycledThebesLayer < mRecycledThebesLayers.Length()) {
47736:     // Recycle a layer
47736:     layer = mRecycledThebesLayers[mNextFreeRecycledThebesLayer];
47736:     ++mNextFreeRecycledThebesLayer;
47745:     // Clear clip rect so we don't accidentally stay clipped. We will
47745:     // reapply any necessary clipping.
47745:     layer->SetClipRect(nsnull);
47736: 
47736:     // This gets called on recycled ThebesLayers that are going to be in the
47736:     // final layer tree, so it's a convenient time to invalidate the
47736:     // content that changed where we don't know what ThebesLayer it belonged
47736:     // to, or if we need to invalidate the entire layer, we can do that.
47736:     // This needs to be done before we update the ThebesLayer to its new
47736:     // transform. See nsGfxScrollFrame::InvalidateInternal, where
47736:     // we ensure that mInvalidThebesContent is updated according to the
47736:     // scroll position as of the most recent paint.
47736:     if (mInvalidateAllThebesContent) {
47736:       nsIntRect invalidate = layer->GetValidRegion().GetBounds();
47736:       layer->InvalidateRegion(invalidate);
47736:     } else {
47736:       InvalidatePostTransformRegion(layer, mInvalidThebesContent);
42593:     }
47736:     // We do not need to Invalidate these areas in the widget because we
47736:     // assume the caller of InvalidateThebesLayerContents or
47736:     // InvalidateAllThebesLayerContents has ensured
47736:     // the area is invalidated in the widget.
47736:   } else {
47736:     // Create a new thebes layer
47736:     layer = mManager->CreateThebesLayer();
47736:     if (!layer)
47736:       return nsnull;
47736:     // Mark this layer as being used for Thebes-painting display items
51947:     layer->SetUserData(&gThebesDisplayItemLayerUserData,
51947:         new ThebesDisplayItemLayerUserData());
42593:   }
42593: 
47736:   // Set up transform so that 0,0 in the Thebes layer corresponds to the
47736:   // (pixel-snapped) top-left of the aActiveScrolledRoot.
47736:   nsPoint offset = mBuilder->ToReferenceFrame(aActiveScrolledRoot);
61670:   nsIntPoint pixOffset;
61670:   pixOffset.x = NSToIntRound(NSAppUnitsToFloatPixels(offset.x, float(aActiveScrolledRoot->PresContext()->AppUnitsPerDevPixel())));
61670:   pixOffset.y = NSToIntRound(NSAppUnitsToFloatPixels(offset.y, float(aActiveScrolledRoot->PresContext()->AppUnitsPerDevPixel())));
61670:   nsIntPoint pixOffset2 = offset.ToNearestPixels(
47736:       aActiveScrolledRoot->PresContext()->AppUnitsPerDevPixel());
61670:   if (pixOffset != pixOffset2) {
61670:     printf("offset %d %d offset/60 %d %d pixoffset %d %d pixoffset2 %d %d", offset.x, offset.y, offset.x/60, offset.y/60, pixOffset.x, pixOffset.y, pixOffset2.x, pixOffset2.y);
61670:     if (offset.y % 60 == 0) printf(" exact");
61670:     if ((offset.y / 60)*60 == offset.y) printf(" exact2");
61670:     printf(" float val %f double val %fL", NSAppUnitsToFloatPixels(offset.y, float(aActiveScrolledRoot->PresContext()->AppUnitsPerDevPixel())),
61670:       double(offset.y)/double(aActiveScrolledRoot->PresContext()->AppUnitsPerDevPixel()));
61670:     printf("\n");
61670:   }
61670:   pixOffset.x = NSToIntRound(float(double(offset.x)/double(aActiveScrolledRoot->PresContext()->AppUnitsPerDevPixel())));
61670:   pixOffset.y = NSToIntRound(float(double(offset.y)/double(aActiveScrolledRoot->PresContext()->AppUnitsPerDevPixel())));
47736:   gfxMatrix matrix;
47736:   matrix.Translate(gfxPoint(pixOffset.x, pixOffset.y));
47736:   layer->SetTransform(gfx3DMatrix::From2D(matrix));
47736: 
47736:   return layer.forget();
42593: }
42593: 
47736: /**
47736:  * Returns the appunits per dev pixel for the item's frame. The item must
47736:  * have a frame because only nsDisplayClip items don't have a frame,
47736:  * and those items are flattened away by ProcessDisplayItems.
47736:  */
51871: static PRInt32
47736: AppUnitsPerDevPixel(nsDisplayItem* aItem)
47736: {
49158:   // The underlying frame for zoom items is the root frame of the subdocument.
49158:   // But zoom display items report their bounds etc using the parent document's
49158:   // APD because zoom items act as a conversion layer between the two different
49158:   // APDs.
49158:   if (aItem->GetType() == nsDisplayItem::TYPE_ZOOM) {
49158:     return static_cast<nsDisplayZoom*>(aItem)->GetParentAppUnitsPerDevPixel();
49158:   }
47736:   return aItem->GetUnderlyingFrame()->PresContext()->AppUnitsPerDevPixel();
42593: }
42593: 
47736: /**
47736:  * Set the visible rect of aLayer. aLayer is in the coordinate system
47736:  * *after* aLayer's transform has been applied, so we need to
47736:  * apply the inverse of that transform before calling SetVisibleRegion.
47736:  */
47736: static void
47736: SetVisibleRectForLayer(Layer* aLayer, const nsIntRect& aRect)
47736: {
42593:   gfxMatrix transform;
47736:   if (aLayer->GetTransform().Is2D(&transform)) {
42593:     // if 'transform' is not invertible, then nothing will be displayed
42593:     // for the layer, so it doesn't really matter what we do here
42593:     transform.Invert();
42593:     gfxRect layerVisible = transform.TransformBounds(
47736:         gfxRect(aRect.x, aRect.y, aRect.width, aRect.height));
42593:     layerVisible.RoundOut();
47736:     nsIntRect visibleRect;
58579:     if (!gfxUtils::GfxRectToIntRect(layerVisible, &visibleRect)) {
48693:       visibleRect = nsIntRect(0, 0, 0, 0);
48693:       NS_WARNING("Visible rect transformed out of bounds");
42593:     }
47736:     aLayer->SetVisibleRegion(visibleRect);
42593:   } else {
42593:     NS_ERROR("Only 2D transformations currently supported");
42593:   }
42593: }
42593: 
51947: nscolor
51947: ContainerState::FindOpaqueBackgroundColorFor(PRInt32 aThebesLayerIndex)
51947: {
51947:   ThebesLayerData* target = mThebesLayerDataStack[aThebesLayerIndex];
51947:   for (PRInt32 i = aThebesLayerIndex - 1; i >= 0; --i) {
51947:     ThebesLayerData* candidate = mThebesLayerDataStack[i];
51947:     nsIntRegion visibleAboveIntersection;
51947:     visibleAboveIntersection.And(candidate->mVisibleAboveRegion, target->mVisibleRegion);
51947:     if (!visibleAboveIntersection.IsEmpty()) {
51947:       // Some non-Thebes content between target and candidate; this is
51947:       // hopeless
51947:       break;
51947:     }
51947: 
51947:     nsIntRegion intersection;
51947:     intersection.And(candidate->mVisibleRegion, target->mVisibleRegion);
51947:     if (intersection.IsEmpty()) {
51947:       // The layer doesn't intersect our target, ignore it and move on
51947:       continue;
51947:     }
51947:  
51947:     // The candidate intersects our target. If any layer has a solid-color
51947:     // area behind our target, this must be it. Scan its display items.
51947:     nsPresContext* presContext = mContainerFrame->PresContext();
51947:     nscoord appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
51947:     nsRect rect =
51947:       target->mVisibleRegion.GetBounds().ToAppUnits(appUnitsPerDevPixel);
51947:     return mBuilder->LayerBuilder()->
51947:       FindOpaqueColorCovering(mBuilder, candidate->mLayer, rect);
51947:   }
51947:   return NS_RGBA(0,0,0,0);
51947: }
51947: 
60712: nsRefPtr<ImageContainer>
60712: ContainerState::ThebesLayerData::CanOptimizeImageLayer(LayerManager* aManager)
60712: {
60712:   if (!mImage) {
60712:     return nsnull;
60712:   }
60712: 
60712:   return mImage->GetContainer(aManager);
60712: }
60712: 
47736: void
47736: ContainerState::PopThebesLayerData()
47736: {
47736:   NS_ASSERTION(!mThebesLayerDataStack.IsEmpty(), "Can't pop");
47736: 
47736:   PRInt32 lastIndex = mThebesLayerDataStack.Length() - 1;
47736:   ThebesLayerData* data = mThebesLayerDataStack[lastIndex];
47736: 
60712:   nsRefPtr<Layer> layer;
60712:   nsRefPtr<ImageContainer> imageContainer = data->CanOptimizeImageLayer(mManager); 
60712: 
60712:   if (data->mIsSolidColorInVisibleRegion || imageContainer) {
60712:     NS_ASSERTION(!(data->mIsSolidColorInVisibleRegion && imageContainer),
60712:                  "Can't be a solid color as well as an image!");
60712:     if (imageContainer) {
60712:       nsRefPtr<ImageLayer> imageLayer = CreateOrRecycleImageLayer();
60712:       imageLayer->SetContainer(imageContainer);
60712:       data->mImage->ConfigureLayer(imageLayer);
60712:       layer = imageLayer;
60712:     } else {
47745:       nsRefPtr<ColorLayer> colorLayer = CreateOrRecycleColorLayer();
47745:       colorLayer->SetColor(data->mSolidColor);
47745: 
60712:       // Copy transform
60712:       colorLayer->SetTransform(data->mLayer->GetTransform());
47745:       
47745:       // Clip colorLayer to its visible region, since ColorLayers are
47745:       // allowed to paint outside the visible region. Here we rely on the
47745:       // fact that uniform display items fill rectangles; obviously the
47745:       // area to fill must contain the visible region, and because it's
47745:       // a rectangle, it must therefore contain the visible region's GetBounds.
47745:       // Note that the visible region is already clipped appropriately.
47745:       nsIntRect visibleRect = data->mVisibleRegion.GetBounds();
47745:       colorLayer->SetClipRect(&visibleRect);
47745: 
60712:       layer = colorLayer;
60712:     }
60712: 
60712:     NS_ASSERTION(!mNewChildLayers.Contains(layer), "Layer already in list???");
60712:     AutoLayersArray::index_type index = mNewChildLayers.IndexOf(data->mLayer);
60712:     NS_ASSERTION(index != AutoLayersArray::NoIndex, "Thebes layer not found?");
60712:     mNewChildLayers.InsertElementAt(index + 1, layer);
60712: 
47745:     // Hide the ThebesLayer. We leave it in the layer tree so that we
47745:     // can find and recycle it later.
47745:     data->mLayer->IntersectClipRect(nsIntRect());
47745:     data->mLayer->SetVisibleRegion(nsIntRegion());
47745:   } else {
47745:     layer = data->mLayer;
47745:   }
47745: 
47736:   gfxMatrix transform;
60712:   if (!layer->GetTransform().Is2D(&transform)) {
60712:     NS_ERROR("Only 2D transformations currently supported");
60712:   }
60712:   
60712:   //ImageLayers are already configured with a visible region
60712:   if (!imageContainer) {
47736:     NS_ASSERTION(!transform.HasNonIntegerTranslation(),
47736:                  "Matrix not just an integer translation?");
47736:     // Convert from relative to the container to relative to the
47736:     // ThebesLayer itself.
47736:     nsIntRegion rgn = data->mVisibleRegion;
47736:     rgn.MoveBy(-nsIntPoint(PRInt32(transform.x0), PRInt32(transform.y0)));
47745:     layer->SetVisibleRegion(rgn);
47736:   }
47736: 
47736:   nsIntRegion transparentRegion;
47736:   transparentRegion.Sub(data->mVisibleRegion, data->mOpaqueRegion);
51947:   PRBool isOpaque = transparentRegion.IsEmpty();
51947:   // For translucent ThebesLayers, try to find an opaque background
51947:   // color that covers the entire area beneath it so we can pull that
51947:   // color into this layer to make it opaque.
51947:   if (layer == data->mLayer) {
51947:     nscolor backgroundColor = NS_RGBA(0,0,0,0);
51947:     if (!isOpaque) {
51947:       backgroundColor = FindOpaqueBackgroundColorFor(lastIndex);
51947:       if (NS_GET_A(backgroundColor) == 255) {
51947:         isOpaque = PR_TRUE;
51947:       }
51947:     }
51947: 
51947:     // Store the background color
51947:     ThebesDisplayItemLayerUserData* userData =
51947:       static_cast<ThebesDisplayItemLayerUserData*>
51947:         (data->mLayer->GetUserData(&gThebesDisplayItemLayerUserData));
51947:     NS_ASSERTION(userData, "where did our user data go?");
51947:     if (userData->mForcedBackgroundColor != backgroundColor) {
51947:       // Invalidate the entire target ThebesLayer since we're changing
51947:       // the background color
51947:       data->mLayer->InvalidateRegion(data->mLayer->GetValidRegion());
51947:     }
51947:     userData->mForcedBackgroundColor = backgroundColor;
51947:   }
59482:   PRUint32 flags;
59482:   if (isOpaque && !data->mForceTransparentSurface) {
59482:     flags = Layer::CONTENT_OPAQUE;
59482:   } else if (data->mNeedComponentAlpha) {
59482:     flags = Layer::CONTENT_COMPONENT_ALPHA;
59482:   } else {
59482:     flags = 0;
59482:   }
51950:   layer->SetContentFlags(flags);
51947: 
51947:   if (lastIndex > 0) {
51947:     // Since we're going to pop off the last ThebesLayerData, the
51947:     // mVisibleAboveRegion of the second-to-last item will need to include
51947:     // the regions of the last item.
51947:     ThebesLayerData* nextData = mThebesLayerDataStack[lastIndex - 1];
51947:     nextData->mVisibleAboveRegion.Or(nextData->mVisibleAboveRegion,
51947:                                      data->mVisibleAboveRegion);
51947:     nextData->mVisibleAboveRegion.Or(nextData->mVisibleAboveRegion,
51947:                                      data->mVisibleRegion);
51947:     nextData->mDrawAboveRegion.Or(nextData->mDrawAboveRegion,
51947:                                      data->mDrawAboveRegion);
51947:     nextData->mDrawAboveRegion.Or(nextData->mDrawAboveRegion,
51947:                                      data->mDrawRegion);
51947:   }
47736: 
47736:   mThebesLayerDataStack.RemoveElementAt(lastIndex);
47736: }
47736: 
59778: static PRBool
59778: SuppressComponentAlpha(nsDisplayListBuilder* aBuilder,
59781:                        nsDisplayItem* aItem,
59781:                        const nsRect& aComponentAlphaBounds)
59778: {
59778:   const nsRegion* windowTransparentRegion = aBuilder->GetFinalTransparentRegion();
59778:   if (!windowTransparentRegion || windowTransparentRegion->IsEmpty())
59778:     return PR_FALSE;
59778: 
59778:   // Suppress component alpha for items in the toplevel window that are over
59778:   // the window translucent area
59778:   nsIFrame* f = aItem->GetUnderlyingFrame();
59778:   nsIFrame* ref = aBuilder->ReferenceFrame();
59778:   if (f->PresContext() != ref->PresContext())
59778:     return PR_FALSE;
59778: 
59778:   for (nsIFrame* t = f; t; t = t->GetParent()) {
59778:     if (t->IsTransformed())
59778:       return PR_FALSE;
59778:   }
59778: 
59781:   return windowTransparentRegion->Intersects(aComponentAlphaBounds);
59778: }
59778: 
59782: static PRBool
59782: WindowHasTransparency(nsDisplayListBuilder* aBuilder)
59782: {
59782:   const nsRegion* windowTransparentRegion = aBuilder->GetFinalTransparentRegion();
59782:   return windowTransparentRegion && !windowTransparentRegion->IsEmpty();
59782: }
59782: 
47736: void
51949: ContainerState::ThebesLayerData::Accumulate(nsDisplayListBuilder* aBuilder,
51949:                                             nsDisplayItem* aItem,
51949:                                             const nsIntRect& aVisibleRect,
59779:                                             const nsIntRect& aDrawRect,
59779:                                             const FrameLayerBuilder::Clip& aClip)
47736: {
51949:   nscolor uniformColor;
60675:   PRBool isUniform = aItem->IsUniform(aBuilder, &uniformColor);
60675:   // Some display items have to exist (so they can set forceTransparentSurface
60675:   // below) but don't draw anything. They'll return true for isUniform but
60675:   // a color with opacity 0.
60675:   if (!isUniform || NS_GET_A(uniformColor) > 0) {
60675:     if (isUniform &&
60024:         aItem->GetBounds(aBuilder).ToInsidePixels(AppUnitsPerDevPixel(aItem)).Contains(aVisibleRect)) {
47745:       if (mVisibleRegion.IsEmpty()) {
47745:         // This color is all we have
51949:         mSolidColor = uniformColor;
47745:         mIsSolidColorInVisibleRegion = PR_TRUE;
47745:       } else if (mIsSolidColorInVisibleRegion &&
48689:                  mVisibleRegion.IsEqual(nsIntRegion(aVisibleRect))) {
47745:         // we can just blend the colors together
51949:         mSolidColor = NS_ComposeColors(mSolidColor, uniformColor);
47745:       } else {
47745:         mIsSolidColorInVisibleRegion = PR_FALSE;
47745:       }
47745:     } else {
47745:       mIsSolidColorInVisibleRegion = PR_FALSE;
47745:     }
47745: 
48689:     mVisibleRegion.Or(mVisibleRegion, aVisibleRect);
47736:     mVisibleRegion.SimplifyOutward(4);
48689:     mDrawRegion.Or(mDrawRegion, aDrawRect);
48689:     mDrawRegion.SimplifyOutward(4);
60675:   }
51949: 
60712:   /* Mark as available for conversion to image layer if this is a nsDisplayImage and
60712:    * we are the first visible item in the ThebesLayerData object.
60712:    */
60712:   if (aItem->GetType() == nsDisplayItem::TYPE_IMAGE && mVisibleRegion.IsEmpty()) {
60712:     mImage = static_cast<nsDisplayImage*>(aItem);
60712:   } else {
60712:     mImage = nsnull;
60712:   }
60712:   
56101:   PRBool forceTransparentSurface = PR_FALSE;
59779:   nsRegion opaque = aItem->GetOpaqueRegion(aBuilder, &forceTransparentSurface);
59779:   if (!opaque.IsEmpty()) {
59779:     nsRegionRectIterator iter(opaque);
59779:     nscoord appUnitsPerDevPixel = AppUnitsPerDevPixel(aItem);
59779:     for (const nsRect* r = iter.Next(); r; r = iter.Next()) {
47772:       // We don't use SimplifyInward here since it's not defined exactly
47772:       // what it will discard. For our purposes the most important case
47772:       // is a large opaque background at the bottom of z-order (e.g.,
47772:       // a canvas background), so we need to make sure that the first rect
47772:       // we see doesn't get discarded.
60024:       nsIntRect rect = aClip.ApproximateIntersect(*r).ToInsidePixels(appUnitsPerDevPixel);
47772:       nsIntRegion tmp;
59779:       tmp.Or(mOpaqueRegion, rect);
59782:        // Opaque display items in chrome documents whose window is partially
59782:        // transparent are always added to the opaque region. This helps ensure
59782:        // that we get as much subpixel-AA as possible in the chrome.
59782:        if (tmp.GetNumRects() <= 4 ||
59782:            (WindowHasTransparency(aBuilder) &&
59782:             aItem->GetUnderlyingFrame()->PresContext()->IsChrome())) {
47772:         mOpaqueRegion = tmp;
47772:       }
59779:     }
59779:   }
59781:   nsRect componentAlpha = aItem->GetComponentAlphaBounds(aBuilder);
59781:   componentAlpha.IntersectRect(componentAlpha, aItem->GetVisibleRect());
59781:   if (!componentAlpha.IsEmpty()) {
59781:     nscoord appUnitsPerDevPixel = AppUnitsPerDevPixel(aItem);
59781:     if (!mOpaqueRegion.Contains(componentAlpha.ToOutsidePixels(appUnitsPerDevPixel))) {
59781:       if (SuppressComponentAlpha(aBuilder, aItem, componentAlpha)) {
59778:         aItem->DisableComponentAlpha();
59778:       } else {
59482:         mNeedComponentAlpha = PR_TRUE;
51951:       }
47736:     }
59778:   }
56101:   mForceTransparentSurface = mForceTransparentSurface || forceTransparentSurface;
47736: }
47736: 
47736: already_AddRefed<ThebesLayer>
51949: ContainerState::FindThebesLayerFor(nsDisplayItem* aItem,
51949:                                    const nsIntRect& aVisibleRect,
48689:                                    const nsIntRect& aDrawRect,
59779:                                    const FrameLayerBuilder::Clip& aClip,
51949:                                    nsIFrame* aActiveScrolledRoot)
47736: {
47736:   PRInt32 i;
47736:   PRInt32 lowestUsableLayerWithScrolledRoot = -1;
47736:   PRInt32 topmostLayerWithScrolledRoot = -1;
47736:   for (i = mThebesLayerDataStack.Length() - 1; i >= 0; --i) {
47736:     ThebesLayerData* data = mThebesLayerDataStack[i];
48689:     if (data->mDrawAboveRegion.Intersects(aVisibleRect)) {
47736:       ++i;
47736:       break;
47736:     }
47736:     if (data->mActiveScrolledRoot == aActiveScrolledRoot) {
47736:       lowestUsableLayerWithScrolledRoot = i;
47736:       if (topmostLayerWithScrolledRoot < 0) {
47736:         topmostLayerWithScrolledRoot = i;
47736:       }
47736:     }
48689:     if (data->mDrawRegion.Intersects(aVisibleRect))
47736:       break;
47736:   }
47736:   if (topmostLayerWithScrolledRoot < 0) {
47736:     --i;
47736:     for (; i >= 0; --i) {
47736:       ThebesLayerData* data = mThebesLayerDataStack[i];
47736:       if (data->mActiveScrolledRoot == aActiveScrolledRoot) {
47736:         topmostLayerWithScrolledRoot = i;
47736:         break;
47736:       }
47736:     }
47736:   }
47736: 
47736:   if (topmostLayerWithScrolledRoot >= 0) {
47736:     while (PRUint32(topmostLayerWithScrolledRoot + 1) < mThebesLayerDataStack.Length()) {
47736:       PopThebesLayerData();
47736:     }
47736:   }
47736: 
47736:   nsRefPtr<ThebesLayer> layer;
47736:   ThebesLayerData* thebesLayerData = nsnull;
47736:   if (lowestUsableLayerWithScrolledRoot < 0) {
47736:     layer = CreateOrRecycleThebesLayer(aActiveScrolledRoot);
47745: 
47745:     NS_ASSERTION(!mNewChildLayers.Contains(layer), "Layer already in list???");
47745:     mNewChildLayers.AppendElement(layer);
47745: 
47736:     thebesLayerData = new ThebesLayerData();
47736:     mThebesLayerDataStack.AppendElement(thebesLayerData);
47736:     thebesLayerData->mLayer = layer;
47736:     thebesLayerData->mActiveScrolledRoot = aActiveScrolledRoot;
47736:   } else {
47736:     thebesLayerData = mThebesLayerDataStack[lowestUsableLayerWithScrolledRoot];
47736:     layer = thebesLayerData->mLayer;
47736:   }
47736: 
59779:   thebesLayerData->Accumulate(mBuilder, aItem, aVisibleRect, aDrawRect, aClip);
47736:   return layer.forget();
47736: }
47736: 
48765: static already_AddRefed<BasicLayerManager>
48765: BuildTempManagerForInactiveLayer(nsDisplayListBuilder* aBuilder,
48765:                                  nsDisplayItem* aItem)
48765: {
48765:   // This item has an inactive layer. We will render it to a ThebesLayer
48765:   // using a temporary BasicLayerManager. Set up the layer
48765:   // manager now so that if we need to modify the retained layer
48765:   // tree during this process, those modifications will happen
48765:   // during the construction phase for the retained layer tree.
48765:   nsRefPtr<BasicLayerManager> tempManager = new BasicLayerManager();
48765:   tempManager->BeginTransaction();
48765:   nsRefPtr<Layer> layer = aItem->BuildLayer(aBuilder, tempManager);
48765:   if (!layer) {
48765:     tempManager->EndTransaction(nsnull, nsnull);
48765:     return nsnull;
48765:   }
48765:   PRInt32 appUnitsPerDevPixel = AppUnitsPerDevPixel(aItem);
48765:   nsIntRect itemVisibleRect =
60024:     aItem->GetVisibleRect().ToOutsidePixels(appUnitsPerDevPixel);
48765:   SetVisibleRectForLayer(layer, itemVisibleRect);
48765: 
48765:   tempManager->SetRoot(layer);
48765:   // No painting should occur yet, since there is no target context.
48765:   tempManager->EndTransaction(nsnull, nsnull);
48765:   return tempManager.forget();
48765: }
48765: 
47736: /*
47736:  * Iterate through the non-clip items in aList and its descendants.
47736:  * For each item we compute the effective clip rect. Each item is assigned
47736:  * to a layer. We invalidate the areas in ThebesLayers where an item
47736:  * has moved from one ThebesLayer to another. Also,
47736:  * aState->mInvalidThebesContent is invalidated in every ThebesLayer.
47736:  * We set the clip rect for items that generated their own layer.
47736:  * (ThebesLayers don't need a clip rect on the layer, we clip the items
47736:  * individually when we draw them.)
52292:  * If we have to clip to a rounded rect, we treat any active layer as
52292:  * though it's inactive so that we draw it ourselves into the thebes layer.
47736:  * We set the visible rect for all layers, although the actual setting
47736:  * of visible rects for some ThebesLayers is deferred until the calling
47736:  * of ContainerState::Finish.
47736:  */
47736: void
47736: ContainerState::ProcessDisplayItems(const nsDisplayList& aList,
61322:                                     FrameLayerBuilder::Clip& aClip)
47736: {
49164:   PRInt32 appUnitsPerDevPixel =
49164:     mContainerFrame->PresContext()->AppUnitsPerDevPixel();
49164: 
47736:   for (nsDisplayItem* item = aList.GetBottom(); item; item = item->GetAbove()) {
52292:     nsDisplayItem::Type type = item->GetType();
52292:     if (type == nsDisplayItem::TYPE_CLIP ||
52292:         type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT) {
52292:       FrameLayerBuilder::Clip childClip(aClip, item);
52292:       ProcessDisplayItems(*item->GetList(), childClip);
47736:       continue;
47736:     }
47736: 
49164:     NS_ASSERTION(appUnitsPerDevPixel == AppUnitsPerDevPixel(item),
49164:       "items in a container layer should all have the same app units per dev pixel");
49164: 
47736:     nsIntRect itemVisibleRect =
60024:       item->GetVisibleRect().ToOutsidePixels(appUnitsPerDevPixel);
48689:     nsRect itemContent = item->GetBounds(mBuilder);
52292:     if (aClip.mHaveClipRect) {
52292:       itemContent.IntersectRect(aClip.mClipRect, itemContent);
48689:     }
60024:     nsIntRect itemDrawRect = itemContent.ToOutsidePixels(appUnitsPerDevPixel);
47751:     nsDisplayItem::LayerState layerState =
47751:       item->GetLayerState(mBuilder, mManager);
47751: 
47751:     // Assign the item to a layer
61322:     if (layerState == LAYER_ACTIVE && (aClip.mRoundedClipRects.IsEmpty() ||
61322:         // We can use the visible rect here only because the item has its own
61322:         // layer, like the comment below.
61322:         !aClip.IsRectClippedByRoundedCorner(item->GetVisibleRect()))) {
47763:       // If the item would have its own layer but is invisible, just hide it.
47763:       // Note that items without their own layers can't be skipped this
47763:       // way, since their ThebesLayer may decide it wants to draw them
47763:       // into its buffer even if they're currently covered.
47763:       if (itemVisibleRect.IsEmpty()) {
47763:         InvalidateForLayerChange(item, nsnull);
47763:         continue;
47763:       }
47763: 
61322:       aClip.RemoveRoundedCorners();
61322: 
47751:       // Just use its layer.
47736:       nsRefPtr<Layer> ownLayer = item->BuildLayer(mBuilder, mManager);
47751:       if (!ownLayer) {
47751:         InvalidateForLayerChange(item, ownLayer);
47751:         continue;
47751:       }
47751: 
47751:       // Update that layer's clip and visible rects.
47736:       NS_ASSERTION(ownLayer->Manager() == mManager, "Wrong manager");
51946:       NS_ASSERTION(!ownLayer->HasUserData(&gLayerManagerUserData),
47736:                    "We shouldn't have a FrameLayerBuilder-managed layer here!");
47736:       // It has its own layer. Update that layer's clip and visible rects.
52292:       if (aClip.mHaveClipRect) {
47736:         ownLayer->IntersectClipRect(
52292:             aClip.mClipRect.ToNearestPixels(appUnitsPerDevPixel));
47736:       }
47736:       ThebesLayerData* data = GetTopThebesLayerData();
47736:       if (data) {
47736:         data->mVisibleAboveRegion.Or(data->mVisibleAboveRegion, itemVisibleRect);
48689:         // Add the entire bounds rect to the mDrawAboveRegion.
48689:         // The visible region may be excluding opaque content above the
48689:         // item, and we need to ensure that that content is not placed
48689:         // in a ThebesLayer below the item!
48689:         data->mDrawAboveRegion.Or(data->mDrawAboveRegion, itemDrawRect);
47736:       }
47736:       SetVisibleRectForLayer(ownLayer, itemVisibleRect);
47736:       ContainerLayer* oldContainer = ownLayer->GetParent();
47736:       if (oldContainer && oldContainer != mContainerLayer) {
47736:         oldContainer->RemoveChild(ownLayer);
47736:       }
47736:       NS_ASSERTION(!mNewChildLayers.Contains(ownLayer),
47736:                    "Layer already in list???");
47751: 
47751:       InvalidateForLayerChange(item, ownLayer);
47751: 
47736:       mNewChildLayers.AppendElement(ownLayer);
47736:       mBuilder->LayerBuilder()->AddLayerDisplayItem(ownLayer, item);
47736:     } else {
48765:       nsRefPtr<BasicLayerManager> tempLayerManager;
52292:       if (layerState != LAYER_NONE) {
48765:         tempLayerManager = BuildTempManagerForInactiveLayer(mBuilder, item);
48765:         if (!tempLayerManager)
48765:           continue;
48765:       }
48765: 
47736:       nsIFrame* f = item->GetUnderlyingFrame();
47736:       nsIFrame* activeScrolledRoot =
49156:         nsLayoutUtils::GetActiveScrolledRootFor(f, mBuilder->ReferenceFrame());
47754:       if (item->IsFixedAndCoveringViewport(mBuilder)) {
47754:         // Make its active scrolled root be the active scrolled root of
47754:         // the enclosing viewport, since it shouldn't be scrolled by scrolled
47754:         // frames in its document. InvalidateFixedBackgroundFramesFromList in
47754:         // nsGfxScrollFrame will not repaint this item when scrolling occurs.
47754:         nsIFrame* viewportFrame =
47754:           nsLayoutUtils::GetClosestFrameOfType(f, nsGkAtoms::viewportFrame);
47754:         NS_ASSERTION(viewportFrame, "no viewport???");
47754:         activeScrolledRoot =
49156:           nsLayoutUtils::GetActiveScrolledRootFor(viewportFrame, mBuilder->ReferenceFrame());
47754:       }
47736: 
47736:       nsRefPtr<ThebesLayer> thebesLayer =
59779:         FindThebesLayerFor(item, itemVisibleRect, itemDrawRect, aClip,
51949:                            activeScrolledRoot);
47736: 
47751:       InvalidateForLayerChange(item, thebesLayer);
47751: 
47751:       mBuilder->LayerBuilder()->
52292:         AddThebesDisplayItem(thebesLayer, item, aClip, mContainerFrame,
48765:                              layerState, tempLayerManager);
47751:     }
47751:   }
47751: }
47751: 
47751: void
47751: ContainerState::InvalidateForLayerChange(nsDisplayItem* aItem, Layer* aNewLayer)
47751: {
47751:   nsIFrame* f = aItem->GetUnderlyingFrame();
47736:   NS_ASSERTION(f, "Display items that render using Thebes must have a frame");
47751:   PRUint32 key = aItem->GetPerFrameKey();
47736:   NS_ASSERTION(key, "Display items that render using Thebes must have a key");
47736:   Layer* oldLayer = mBuilder->LayerBuilder()->GetOldLayerFor(f, key);
47751:   if (!oldLayer) {
47751:     // Nothing to do here, this item didn't have a layer before
47751:     return;
47751:   }
47751:   if (aNewLayer != oldLayer) {
47736:     // The item has changed layers.
47736:     // Invalidate the bounds in the old layer and new layer.
47736:     // The bounds might have changed, but we assume that any difference
47736:     // in the bounds will have been invalidated for all Thebes layers
47736:     // in the container via regular frame invalidation.
47751:     nsRect bounds = aItem->GetBounds(mBuilder);
47751:     PRInt32 appUnitsPerDevPixel = AppUnitsPerDevPixel(aItem);
47736:     nsIntRect r = bounds.ToOutsidePixels(appUnitsPerDevPixel);
47736: 
47751:     ThebesLayer* t = oldLayer->AsThebesLayer();
47751:     if (t) {
47751:       InvalidatePostTransformRegion(t, r);
47751:     }
47751:     if (aNewLayer) {
47751:       ThebesLayer* newLayer = aNewLayer->AsThebesLayer();
47751:       if (newLayer) {
47751:         InvalidatePostTransformRegion(newLayer, r);
47751:       }
47736:     }
47736: 
49162:     NS_ASSERTION(appUnitsPerDevPixel ==
49162:                    mContainerFrame->PresContext()->AppUnitsPerDevPixel(),
49162:                  "app units per dev pixel should be constant in a container");
47771:     mContainerFrame->InvalidateWithFlags(
47771:         bounds - mBuilder->ToReferenceFrame(mContainerFrame),
47771:         nsIFrame::INVALIDATE_NO_THEBES_LAYERS |
47771:         nsIFrame::INVALIDATE_EXCLUDE_CURRENT_PAINT);
47736:   }
47736: }
47736: 
47736: void
47736: FrameLayerBuilder::AddThebesDisplayItem(ThebesLayer* aLayer,
47736:                                         nsDisplayItem* aItem,
52292:                                         const Clip& aClip,
47751:                                         nsIFrame* aContainerLayerFrame,
48765:                                         LayerState aLayerState,
48765:                                         LayerManager* aTempManager)
47736: {
47736:   AddLayerDisplayItem(aLayer, aItem);
47736: 
47736:   ThebesLayerItemsEntry* entry = mThebesLayerItems.PutEntry(aLayer);
47736:   if (entry) {
47736:     entry->mContainerLayerFrame = aContainerLayerFrame;
47736:     NS_ASSERTION(aItem->GetUnderlyingFrame(), "Must have frame");
47751:     ClippedDisplayItem* cdi =
52292:       entry->mItems.AppendElement(ClippedDisplayItem(aItem, aClip));
48765:     cdi->mTempLayerManager = aTempManager;
47736:   }
47736: }
47736: 
47736: void
47736: FrameLayerBuilder::AddLayerDisplayItem(Layer* aLayer,
47736:                                        nsDisplayItem* aItem)
47736: {
47736:   if (aLayer->Manager() != mRetainingManager)
47736:     return;
47736: 
47736:   nsIFrame* f = aItem->GetUnderlyingFrame();
47736:   DisplayItemDataEntry* entry = mNewDisplayItemData.PutEntry(f);
47736:   if (entry) {
47736:     entry->mData.AppendElement(DisplayItemData(aLayer, aItem->GetPerFrameKey()));
47736:   }
47736: }
47736: 
51947: nscolor
51947: FrameLayerBuilder::FindOpaqueColorCovering(nsDisplayListBuilder* aBuilder,
51947:                                            ThebesLayer* aLayer,
51947:                                            const nsRect& aRect)
51947: {
51947:   ThebesLayerItemsEntry* entry = mThebesLayerItems.GetEntry(aLayer);
51947:   NS_ASSERTION(entry, "Must know about this layer!");
51947:   for (PRInt32 i = entry->mItems.Length() - 1; i >= 0; --i) {
51947:     nsDisplayItem* item = entry->mItems[i].mItem;
51947:     const nsRect& visible = item->GetVisibleRect();
51947:     if (!visible.Intersects(aRect))
51947:       continue;
51947: 
51947:     nscolor color;
51947:     if (visible.Contains(aRect) && item->IsUniform(aBuilder, &color) &&
51947:         NS_GET_A(color) == 255)
51947:       return color;
51947:     break;
51947:   }
51947:   return NS_RGBA(0,0,0,0);
51947: }
51947: 
47736: void
47745: ContainerState::CollectOldLayers()
47736: {
47736:   for (Layer* layer = mContainerLayer->GetFirstChild(); layer;
47736:        layer = layer->GetNextSibling()) {
51946:     if (layer->HasUserData(&gColorLayerUserData)) {
47745:       mRecycledColorLayers.AppendElement(static_cast<ColorLayer*>(layer));
60712:     } else if (layer->HasUserData(&gImageLayerUserData)) {
60712:       mRecycledImageLayers.AppendElement(static_cast<ImageLayer*>(layer));
51946:     } else if (layer->HasUserData(&gThebesDisplayItemLayerUserData)) {
47745:       NS_ASSERTION(layer->AsThebesLayer(), "Wrong layer type");
47745:       mRecycledThebesLayers.AppendElement(static_cast<ThebesLayer*>(layer));
47736:     }
47736:   }
47736: }
47736: 
47736: void
59481: ContainerState::Finish(PRUint32* aTextContentFlags)
47736: {
47736:   while (!mThebesLayerDataStack.IsEmpty()) {
47736:     PopThebesLayerData();
47736:   }
47736: 
59482:   PRUint32 textContentFlags = 0;
59481: 
47736:   for (PRUint32 i = 0; i <= mNewChildLayers.Length(); ++i) {
47736:     // An invariant of this loop is that the layers in mNewChildLayers
47736:     // with index < i are the first i child layers of mContainerLayer.
47736:     Layer* layer;
47736:     if (i < mNewChildLayers.Length()) {
47736:       layer = mNewChildLayers[i];
59481:       if (!layer->GetVisibleRegion().IsEmpty()) {
59482:         textContentFlags |= layer->GetContentFlags() & Layer::CONTENT_COMPONENT_ALPHA;
59481:       }
47736:       if (!layer->GetParent()) {
47736:         // This is not currently a child of the container, so just add it
47736:         // now.
48243:         Layer* prevChild = i == 0 ? nsnull : mNewChildLayers[i - 1].get();
47736:         mContainerLayer->InsertAfter(layer, prevChild);
47736:         continue;
47736:       }
47736:       NS_ASSERTION(layer->GetParent() == mContainerLayer,
47736:                    "Layer shouldn't be the child of some other container");
47736:     } else {
47736:       layer = nsnull;
47736:     }
47736: 
47736:     // If layer is non-null, then it's already a child of the container,
47736:     // so scan forward until we find it, removing the other layers we
47736:     // don't want here.
47736:     // If it's null, scan forward until we've removed all the leftover
47736:     // children.
47736:     Layer* nextOldChild = i == 0 ? mContainerLayer->GetFirstChild() :
47736:       mNewChildLayers[i - 1]->GetNextSibling();
47736:     while (nextOldChild != layer) {
47736:       Layer* tmp = nextOldChild;
47736:       nextOldChild = nextOldChild->GetNextSibling();
47736:       mContainerLayer->RemoveChild(tmp);
47736:     }
47736:     // If non-null, 'layer' is now in the right place in the list, so we
47736:     // can just move on to the next one.
47736:   }
59481: 
59481:   *aTextContentFlags = textContentFlags;
47736: }
42593: 
51752: static void
51752: SetHasContainerLayer(nsIFrame* aFrame)
51752: {
51752:   aFrame->AddStateBits(NS_FRAME_HAS_CONTAINER_LAYER);
51752:   for (nsIFrame* f = aFrame;
51752:        f && !(f->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT);
51752:        f = nsLayoutUtils::GetCrossDocParentFrame(f)) {
51752:     f->AddStateBits(NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT);
51752:   }
51752: }
51752: 
54078: already_AddRefed<ContainerLayer>
47736: FrameLayerBuilder::BuildContainerLayerFor(nsDisplayListBuilder* aBuilder,
42593:                                           LayerManager* aManager,
47736:                                           nsIFrame* aContainerFrame,
47736:                                           nsDisplayItem* aContainerItem,
42593:                                           const nsDisplayList& aChildren)
42593: {
47736:   FrameProperties props = aContainerFrame->Properties();
47736:   PRUint32 containerDisplayItemKey =
47736:     aContainerItem ? aContainerItem->GetPerFrameKey() : 0;
47736:   NS_ASSERTION(aContainerFrame, "Container display items here should have a frame");
47736:   NS_ASSERTION(!aContainerItem ||
47736:                aContainerItem->GetUnderlyingFrame() == aContainerFrame,
47736:                "Container display item must match given frame");
47736: 
47736:   nsRefPtr<ContainerLayer> containerLayer;
47736:   if (aManager == mRetainingManager) {
47736:     Layer* oldLayer = GetOldLayerFor(aContainerFrame, containerDisplayItemKey);
47736:     if (oldLayer) {
47736:       NS_ASSERTION(oldLayer->Manager() == aManager, "Wrong manager");
51946:       if (oldLayer->HasUserData(&gThebesDisplayItemLayerUserData)) {
47751:         // The old layer for this item is actually our ThebesLayer
47751:         // because we rendered its layer into that ThebesLayer. So we
47751:         // don't actually have a retained container layer.
47751:       } else {
47736:         NS_ASSERTION(oldLayer->GetType() == Layer::TYPE_CONTAINER,
47736:                      "Wrong layer type");
47736:         containerLayer = static_cast<ContainerLayer*>(oldLayer);
47751:         // Clear clip rect; the caller will set it if necessary.
47736:         containerLayer->SetClipRect(nsnull);
47736:       }
47736:     }
47751:   }
47736:   if (!containerLayer) {
47736:     // No suitable existing layer was found.
47736:     containerLayer = aManager->CreateContainerLayer();
47736:     if (!containerLayer)
42593:       return nsnull;
47736:   }
42593: 
47736:   ContainerState state(aBuilder, aManager, aContainerFrame, containerLayer);
42593: 
47736:   if (aManager == mRetainingManager) {
47736:     DisplayItemDataEntry* entry = mNewDisplayItemData.PutEntry(aContainerFrame);
47736:     if (entry) {
47736:       entry->mData.AppendElement(
47736:           DisplayItemData(containerLayer, containerDisplayItemKey));
42593:     }
47736: 
47736:     if (mInvalidateAllThebesContent) {
47736:       state.SetInvalidateAllThebesContent();
47736:     }
47736: 
47736:     nsRegion* invalidThebesContent(static_cast<nsRegion*>
47736:       (props.Get(ThebesLayerInvalidRegionProperty())));
47736:     if (invalidThebesContent) {
47736:       nsPoint offset = aBuilder->ToReferenceFrame(aContainerFrame);
47736:       invalidThebesContent->MoveBy(offset);
47736:       state.SetInvalidThebesContent(invalidThebesContent->
47736:         ToOutsidePixels(aContainerFrame->PresContext()->AppUnitsPerDevPixel()));
51752:       // We have to preserve the current contents of invalidThebesContent
51752:       // because there might be multiple container layers for the same
51752:       // frame and we need to invalidate the ThebesLayer children of all
51752:       // of them.
47736:       invalidThebesContent->MoveBy(-offset);
47736:     } else {
51752:       // The region was deleted to indicate that everything should be
51752:       // invalidated.
51752:       state.SetInvalidateAllThebesContent();
47736:     }
51752:     SetHasContainerLayer(aContainerFrame);
47736:   }
47736: 
52292:   Clip clip;
52292:   state.ProcessDisplayItems(aChildren, clip);
47736: 
59482:   // Set CONTENT_COMPONENT_ALPHA if any of our children have it.
59481:   // This is suboptimal ... a child could have text that's over transparent
59481:   // pixels in its own layer, but over opaque parts of previous siblings.
59481:   PRUint32 flags;
59481:   state.Finish(&flags);
59481: 
59481:   if (aChildren.IsOpaque() && !aChildren.NeedsTransparentSurface()) {
59482:     // Clear CONTENT_COMPONENT_ALPHA
59482:     flags = Layer::CONTENT_OPAQUE;
59481:   }
51950:   containerLayer->SetContentFlags(flags);
59481: 
48946:   return containerLayer.forget();
42593: }
42593: 
47731: Layer*
47731: FrameLayerBuilder::GetLeafLayerFor(nsDisplayListBuilder* aBuilder,
47731:                                    LayerManager* aManager,
47731:                                    nsDisplayItem* aItem)
47731: {
47736:   if (aManager != mRetainingManager)
47731:     return nsnull;
47736: 
47736:   nsIFrame* f = aItem->GetUnderlyingFrame();
47736:   NS_ASSERTION(f, "Can only call GetLeafLayerFor on items that have a frame");
47736:   Layer* layer = GetOldLayerFor(f, aItem->GetPerFrameKey());
47736:   if (!layer)
47736:     return nsnull;
51946:   if (layer->HasUserData(&gThebesDisplayItemLayerUserData)) {
47736:     // This layer was created to render Thebes-rendered content for this
47736:     // display item. The display item should not use it for its own
47736:     // layer rendering.
47736:     return nsnull;
47736:   }
47736:   // Clear clip rect; the caller is responsible for setting it.
47736:   layer->SetClipRect(nsnull);
47736:   return layer;
47731: }
47731: 
47731: /* static */ void
47731: FrameLayerBuilder::InvalidateThebesLayerContents(nsIFrame* aFrame,
47731:                                                  const nsRect& aRect)
47731: {
47736:   nsRegion* invalidThebesContent = static_cast<nsRegion*>
47736:     (aFrame->Properties().Get(ThebesLayerInvalidRegionProperty()));
47736:   if (!invalidThebesContent)
47736:     return;
47736:   invalidThebesContent->Or(*invalidThebesContent, aRect);
47736:   invalidThebesContent->SimplifyOutward(20);
47736: }
47736: 
51752: /**
51752:  * Returns true if we find a descendant with a container layer
51752:  */
51752: static PRBool
51752: InternalInvalidateThebesLayersInSubtree(nsIFrame* aFrame)
51752: {
51752:   if (!(aFrame->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT))
51752:     return PR_FALSE;
51752: 
51752:   PRBool foundContainerLayer = PR_FALSE;
51752:   if (aFrame->GetStateBits() & NS_FRAME_HAS_CONTAINER_LAYER) {
51752:     // Delete the invalid region to indicate that all Thebes contents
51752:     // need to be invalidated
51752:     aFrame->Properties().Delete(ThebesLayerInvalidRegionProperty());
51752:     foundContainerLayer = PR_TRUE;
51752:   }
51752: 
51752:   PRInt32 listIndex = 0;
51752:   nsIAtom* childList = nsnull;
51752:   do {
51752:     nsIFrame* child = aFrame->GetFirstChild(childList);
51752:     if (!child && !childList) {
51754:       nsSubDocumentFrame* subdocumentFrame = do_QueryFrame(aFrame);
51752:       if (subdocumentFrame) {
51752:         // Descend into the subdocument
51752:         child = subdocumentFrame->GetSubdocumentRootFrame();
51752:       }
51752:     }
51752:     while (child) {
51752:       if (InternalInvalidateThebesLayersInSubtree(child)) {
51752:         foundContainerLayer = PR_TRUE;
51752:       }
51752:       child = child->GetNextSibling();
51752:     }
51752:     childList = aFrame->GetAdditionalChildListName(listIndex++);
51752:   } while (childList);
51752: 
51752:   if (!foundContainerLayer) {
51752:     aFrame->RemoveStateBits(NS_FRAME_HAS_CONTAINER_LAYER_DESCENDANT);
51752:   }
51752:   return foundContainerLayer;
51752: }
51752: 
51752: /* static */ void
51752: FrameLayerBuilder::InvalidateThebesLayersInSubtree(nsIFrame* aFrame)
51752: {
51752:   InternalInvalidateThebesLayersInSubtree(aFrame);
51752: }
51752: 
47736: /* static */ void
47736: FrameLayerBuilder::InvalidateAllThebesLayerContents(LayerManager* aManager)
47736: {
47736:   LayerManagerData* data = static_cast<LayerManagerData*>
51946:     (aManager->GetUserData(&gLayerManagerUserData));
47736:   if (data) {
47736:     data->mInvalidateAllThebesContent = PR_TRUE;
47736:   }
47736: }
47736: 
47736: /* static */ void
47736: FrameLayerBuilder::InvalidateAllLayers(LayerManager* aManager)
47736: {
47736:   LayerManagerData* data = static_cast<LayerManagerData*>
51946:     (aManager->GetUserData(&gLayerManagerUserData));
47736:   if (data) {
47736:     data->mInvalidateAllLayers = PR_TRUE;
47736:   }
47731: }
47731: 
47740: /* static */
47740: PRBool
47740: FrameLayerBuilder::HasDedicatedLayer(nsIFrame* aFrame, PRUint32 aDisplayItemKey)
47740: {
47740:   void* propValue = aFrame->Properties().Get(DisplayItemDataProperty());
47740:   if (!propValue)
47740:     return PR_FALSE;
47740: 
47740:   nsTArray<DisplayItemData>* array =
47740:     (reinterpret_cast<nsTArray<DisplayItemData>*>(&propValue));
47740:   for (PRUint32 i = 0; i < array->Length(); ++i) {
47740:     if (array->ElementAt(i).mDisplayItemKey == aDisplayItemKey) {
51946:       Layer* layer = array->ElementAt(i).mLayer;
51946:       if (!layer->HasUserData(&gColorLayerUserData) &&
60712:           !layer->HasUserData(&gImageLayerUserData) &&
51946:           !layer->HasUserData(&gThebesDisplayItemLayerUserData))
47740:         return PR_TRUE;
47740:     }
47740:   }
47740:   return PR_FALSE;
47740: }
47740: 
42593: /* static */ void
42593: FrameLayerBuilder::DrawThebesLayer(ThebesLayer* aLayer,
42593:                                    gfxContext* aContext,
42593:                                    const nsIntRegion& aRegionToDraw,
47108:                                    const nsIntRegion& aRegionToInvalidate,
42593:                                    void* aCallbackData)
42593: {
47736:   nsDisplayListBuilder* builder = static_cast<nsDisplayListBuilder*>
47736:     (aCallbackData);
54261: 
54261:   if (builder->LayerBuilder()->CheckDOMModified())
54261:     return;
54261: 
47766:   nsTArray<ClippedDisplayItem> items;
47766:   nsIFrame* containerLayerFrame;
47766:   {
47736:     ThebesLayerItemsEntry* entry =
47736:       builder->LayerBuilder()->mThebesLayerItems.GetEntry(aLayer);
47736:     NS_ASSERTION(entry, "We shouldn't be drawing into a layer with no items!");
47766:     items.SwapElements(entry->mItems);
47766:     containerLayerFrame = entry->mContainerLayerFrame;
47766:     // Later after this point, due to calls to DidEndTransaction
47766:     // for temporary layer managers, mThebesLayerItems can change,
47766:     // so 'entry' could become invalid.
47766:   }
47108: 
51947:   ThebesDisplayItemLayerUserData* userData =
51947:     static_cast<ThebesDisplayItemLayerUserData*>
51947:       (aLayer->GetUserData(&gThebesDisplayItemLayerUserData));
51947:   NS_ASSERTION(userData, "where did our user data go?");
51947:   if (NS_GET_A(userData->mForcedBackgroundColor) > 0) {
60025:     nsIntRect r = aLayer->GetVisibleRegion().GetBounds();
60025:     aContext->NewPath();
60025:     aContext->Rectangle(gfxRect(r.x, r.y, r.width, r.height));
51947:     aContext->SetColor(gfxRGBA(userData->mForcedBackgroundColor));
60025:     aContext->Fill();
51947:   }
51947: 
47736:   gfxMatrix transform;
47736:   if (!aLayer->GetTransform().Is2D(&transform)) {
47736:     NS_ERROR("non-2D transform in our Thebes layer!");
47736:     return;
47736:   }
47736:   NS_ASSERTION(!transform.HasNonIntegerTranslation(),
47736:                "Matrix not just an integer translation?");
47736:   // make the origin of the context coincide with the origin of the
47736:   // ThebesLayer
47736:   gfxContextMatrixAutoSaveRestore saveMatrix(aContext); 
47736:   aContext->Translate(-gfxPoint(transform.x0, transform.y0));
47736:   nsIntPoint offset(PRInt32(transform.x0), PRInt32(transform.y0));
42593: 
47766:   nsPresContext* presContext = containerLayerFrame->PresContext();
51871:   PRInt32 appUnitsPerDevPixel = presContext->AppUnitsPerDevPixel();
47736:   nsRect r = (aRegionToInvalidate.GetBounds() + offset).
47736:     ToAppUnits(appUnitsPerDevPixel);
47771:   containerLayerFrame->InvalidateWithFlags(r,
47771:       nsIFrame::INVALIDATE_NO_THEBES_LAYERS |
47771:       nsIFrame::INVALIDATE_EXCLUDE_CURRENT_PAINT);
42593: 
47736:   PRUint32 i;
47736:   // Update visible regions. We need perform visibility analysis again
47736:   // because we may be asked to draw into part of a ThebesLayer that
47736:   // isn't actually visible in the window (e.g., because a ThebesLayer
47736:   // expanded its visible region to a rectangle internally), in which
47736:   // case the mVisibleRect stored in the display item may be wrong.
47736:   nsRegion visible = aRegionToDraw.ToAppUnits(appUnitsPerDevPixel);
47736:   visible.MoveBy(NSIntPixelsToAppUnits(offset.x, appUnitsPerDevPixel),
47736:                  NSIntPixelsToAppUnits(offset.y, appUnitsPerDevPixel));
47736: 
47766:   for (i = items.Length(); i > 0; --i) {
47766:     ClippedDisplayItem* cdi = &items[i - 1];
47736: 
49163:     NS_ASSERTION(AppUnitsPerDevPixel(cdi->mItem) == appUnitsPerDevPixel,
49163:                  "a thebes layer should contain items only at the same zoom");
47736: 
52292:     NS_ABORT_IF_FALSE(cdi->mClip.mHaveClipRect ||
52292:                       cdi->mClip.mRoundedClipRects.IsEmpty(),
52292:                       "If we have rounded rects, we must have a clip rect");
52292: 
52292:     if (!cdi->mClip.mHaveClipRect ||
52292:         (cdi->mClip.mRoundedClipRects.IsEmpty() &&
52292:          cdi->mClip.mClipRect.Contains(visible.GetBounds()))) {
47736:       cdi->mItem->RecomputeVisibility(builder, &visible);
47736:       continue;
47736:     }
47736: 
47736:     // Do a little dance to account for the fact that we're clipping
47736:     // to cdi->mClipRect
47736:     nsRegion clipped;
52292:     clipped.And(visible, cdi->mClip.mClipRect);
47736:     nsRegion finalClipped = clipped;
47736:     cdi->mItem->RecomputeVisibility(builder, &finalClipped);
52292:     // If we have rounded clip rects, don't subtract from the visible
52292:     // region since we aren't displaying everything inside the rect.
52292:     if (cdi->mClip.mRoundedClipRects.IsEmpty()) {
47736:       nsRegion removed;
47736:       removed.Sub(clipped, finalClipped);
47736:       nsRegion newVisible;
47736:       newVisible.Sub(visible, removed);
47736:       // Don't let the visible region get too complex.
47736:       if (newVisible.GetNumRects() <= 15) {
47736:         visible = newVisible;
47736:       }
47736:     }
61322:     if (!cdi->mClip.IsRectClippedByRoundedCorner(cdi->mItem->GetVisibleRect())) {
61322:       cdi->mClip.RemoveRoundedCorners();
61322:     }
52292:   }
47736: 
49163:   nsRefPtr<nsIRenderingContext> rc;
49163:   nsresult rv =
49163:     presContext->DeviceContext()->CreateRenderingContextInstance(*getter_AddRefs(rc));
49163:   if (NS_FAILED(rv))
49163:     return;
49163:   rc->Init(presContext->DeviceContext(), aContext);
49163: 
52292:   Clip currentClip;
49163:   PRBool setClipRect = PR_FALSE;
49163: 
47766:   for (i = 0; i < items.Length(); ++i) {
47766:     ClippedDisplayItem* cdi = &items[i];
47736: 
47736:     if (cdi->mItem->GetVisibleRect().IsEmpty())
47736:       continue;
47736: 
42593:     // If the new desired clip state is different from the current state,
42593:     // update the clip.
52292:     if (setClipRect != cdi->mClip.mHaveClipRect ||
52292:         (cdi->mClip.mHaveClipRect && cdi->mClip != currentClip)) {
42593:       if (setClipRect) {
42593:         aContext->Restore();
42593:       }
52292:       setClipRect = cdi->mClip.mHaveClipRect;
42593:       if (setClipRect) {
52292:         currentClip = cdi->mClip;
42593:         aContext->Save();
52292:         currentClip.ApplyTo(aContext, presContext);
42593:       }
42593:     }
47736: 
47751:     if (cdi->mTempLayerManager) {
47751:       // This item has an inactive layer. Render it to the ThebesLayer
47751:       // using the temporary BasicLayerManager.
47751:       cdi->mTempLayerManager->BeginTransactionWithTarget(aContext);
47751:       cdi->mTempLayerManager->EndTransaction(DrawThebesLayer, builder);
47751:     } else {
47736:       cdi->mItem->Paint(builder, rc);
42593:     }
54261: 
54261:     if (builder->LayerBuilder()->CheckDOMModified())
54261:       break;
47751:   }
47736: 
42593:   if (setClipRect) {
42593:     aContext->Restore();
42593:   }
42593: }
42593: 
54261: PRBool
54261: FrameLayerBuilder::CheckDOMModified()
54261: {
54324:   if (!mRootPresContext ||
54261:       mInitialDOMGeneration == mRootPresContext->GetDOMGeneration())
54261:     return PR_FALSE;
54261:   if (mDetectedDOMModification) {
54261:     // Don't spam the console with extra warnings
54261:     return PR_TRUE;
54261:   }
54261:   mDetectedDOMModification = PR_TRUE;
54261:   // Painting is not going to complete properly. There's not much
54261:   // we can do here though. Invalidating the window to get another repaint
54261:   // is likely to lead to an infinite repaint loop.
54261:   NS_WARNING("Detected DOM modification during paint, bailing out!");
54261:   return PR_TRUE;
54261: }
54261: 
47736: #ifdef DEBUG
47736: void
47736: FrameLayerBuilder::DumpRetainedLayerTree()
47736: {
47736:   if (mRetainingManager) {
48025:     mRetainingManager->Dump(stderr);
47736:   }
47736: }
47736: #endif
47736: 
52292: FrameLayerBuilder::Clip::Clip(const Clip& aOther, nsDisplayItem* aClipItem)
52292:   : mRoundedClipRects(aOther.mRoundedClipRects),
52292:     mHaveClipRect(PR_TRUE)
52292: {
52292:   nsDisplayItem::Type type = aClipItem->GetType();
52292:   NS_ABORT_IF_FALSE(type == nsDisplayItem::TYPE_CLIP ||
52292:                     type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT,
52292:                     "unexpected display item type");
52292:   nsDisplayClip* item = static_cast<nsDisplayClip*>(aClipItem);
52292:   // Always intersect with mClipRect, even if we're going to add a
52292:   // rounded rect.
52292:   if (aOther.mHaveClipRect) {
52292:     mClipRect.IntersectRect(aOther.mClipRect, item->GetClipRect());
52292:   } else {
52292:     mClipRect = item->GetClipRect();
52292:   }
52292: 
52292:   if (type == nsDisplayItem::TYPE_CLIP_ROUNDED_RECT) {
52292:     RoundedRect *rr = mRoundedClipRects.AppendElement();
52292:     if (rr) {
52292:       rr->mRect = item->GetClipRect();
52292:       static_cast<nsDisplayClipRoundedRect*>(item)->GetRadii(rr->mRadii);
52292:     }
52292:   }
52292: 
52292:   // FIXME: Optimize away excess rounded rectangles due to the new addition.
52292: }
52292: 
52292: void
52292: FrameLayerBuilder::Clip::ApplyTo(gfxContext* aContext,
52292:                                  nsPresContext* aPresContext)
52292: {
52292:   aContext->NewPath();
52292:   PRInt32 A2D = aPresContext->AppUnitsPerDevPixel();
52292:   gfxRect clip = nsLayoutUtils::RectToGfxRect(mClipRect, A2D);
52292:   aContext->Rectangle(clip, PR_TRUE);
52292:   aContext->Clip();
52292: 
52292:   for (PRUint32 i = 0, iEnd = mRoundedClipRects.Length();
52292:        i < iEnd; ++i) {
52292:     const Clip::RoundedRect &rr = mRoundedClipRects[i];
52292: 
52292:     gfxCornerSizes pixelRadii;
52292:     nsCSSRendering::ComputePixelRadii(rr.mRadii, A2D, &pixelRadii);
52292: 
52292:     clip = nsLayoutUtils::RectToGfxRect(rr.mRect, A2D);
52292:     clip.Round();
52292:     clip.Condition();
52292:     // REVIEW: This might make clip empty.  Is that OK?
52292: 
52292:     aContext->NewPath();
52292:     aContext->RoundedRectangle(clip, pixelRadii);
52292:     aContext->Clip();
52292:   }
52292: }
52292: 
59779: nsRect
59779: FrameLayerBuilder::Clip::ApproximateIntersect(const nsRect& aRect) const
59779: {
59779:   nsRect r = aRect;
59779:   if (mHaveClipRect) {
59779:     r.IntersectRect(r, mClipRect);
59779:   }
59779:   for (PRUint32 i = 0, iEnd = mRoundedClipRects.Length();
59779:        i < iEnd; ++i) {
59779:     const Clip::RoundedRect &rr = mRoundedClipRects[i];
59779:     nsRegion rgn = nsLayoutUtils::RoundedRectIntersectRect(rr.mRect, rr.mRadii, r);
59779:     r = rgn.GetLargestRectangle();
59779:   }
59779:   return r;
59779: }
59779: 
61322: // Test if (aXPoint, aYPoint) is in the ellipse with center (aXCenter, aYCenter)
61322: // and radii aXRadius, aYRadius.
61322: bool IsInsideEllipse(nscoord aXRadius, nscoord aXCenter, nscoord aXPoint,
61322:                      nscoord aYRadius, nscoord aYCenter, nscoord aYPoint)
61322: {
61322:   float scaledX = float(aXPoint - aXCenter) / float(aXRadius);
61322:   float scaledY = float(aYPoint - aYCenter) / float(aYRadius);
61322:   return scaledX * scaledX + scaledY * scaledY < 1.0f;
61322: }
61322: 
61322: bool
61322: FrameLayerBuilder::Clip::IsRectClippedByRoundedCorner(const nsRect& aRect) const
61322: {
61322:   if (mRoundedClipRects.IsEmpty())
61322:     return false;
61322: 
61322:   nsRect rect;
61322:   rect.IntersectRect(aRect, NonRoundedIntersection());
61322:   for (PRUint32 i = 0, iEnd = mRoundedClipRects.Length();
61322:        i < iEnd; ++i) {
61322:     const Clip::RoundedRect &rr = mRoundedClipRects[i];
61322:     // top left
61322:     if (rect.x < rr.mRect.x + rr.mRadii[NS_CORNER_TOP_LEFT_X] &&
61322:         rect.y < rr.mRect.y + rr.mRadii[NS_CORNER_TOP_LEFT_Y]) {
61322:       if (!IsInsideEllipse(rr.mRadii[NS_CORNER_TOP_LEFT_X],
61322:                            rr.mRect.x + rr.mRadii[NS_CORNER_TOP_LEFT_X],
61322:                            rect.x,
61322:                            rr.mRadii[NS_CORNER_TOP_LEFT_Y],
61322:                            rr.mRect.y + rr.mRadii[NS_CORNER_TOP_LEFT_Y],
61322:                            rect.y)) {
61322:         return true;
61322:       }
61322:     }
61322:     // top right
61322:     if (rect.XMost() > rr.mRect.XMost() - rr.mRadii[NS_CORNER_TOP_RIGHT_X] &&
61322:         rect.y < rr.mRect.y + rr.mRadii[NS_CORNER_TOP_RIGHT_Y]) {
61322:       if (!IsInsideEllipse(rr.mRadii[NS_CORNER_TOP_RIGHT_X],
61322:                            rr.mRect.XMost() - rr.mRadii[NS_CORNER_TOP_RIGHT_X],
61322:                            rect.XMost(),
61322:                            rr.mRadii[NS_CORNER_TOP_RIGHT_Y],
61322:                            rr.mRect.y + rr.mRadii[NS_CORNER_TOP_RIGHT_Y],
61322:                            rect.y)) {
61322:         return true;
61322:       }
61322:     }
61322:     // bottom left
61322:     if (rect.x < rr.mRect.x + rr.mRadii[NS_CORNER_BOTTOM_LEFT_X] &&
61322:         rect.YMost() > rr.mRect.YMost() - rr.mRadii[NS_CORNER_BOTTOM_LEFT_Y]) {
61322:       if (!IsInsideEllipse(rr.mRadii[NS_CORNER_BOTTOM_LEFT_X],
61322:                            rr.mRect.x + rr.mRadii[NS_CORNER_BOTTOM_LEFT_X],
61322:                            rect.x,
61322:                            rr.mRadii[NS_CORNER_BOTTOM_LEFT_Y],
61322:                            rr.mRect.YMost() - rr.mRadii[NS_CORNER_BOTTOM_LEFT_Y],
61322:                            rect.YMost())) {
61322:         return true;
61322:       }
61322:     }
61322:     // bottom right
61322:     if (rect.XMost() > rr.mRect.XMost() - rr.mRadii[NS_CORNER_BOTTOM_RIGHT_X] &&
61322:         rect.YMost() > rr.mRect.YMost() - rr.mRadii[NS_CORNER_BOTTOM_RIGHT_Y]) {
61322:       if (!IsInsideEllipse(rr.mRadii[NS_CORNER_BOTTOM_RIGHT_X],
61322:                            rr.mRect.XMost() - rr.mRadii[NS_CORNER_BOTTOM_RIGHT_X],
61322:                            rect.XMost(),
61322:                            rr.mRadii[NS_CORNER_BOTTOM_RIGHT_Y],
61322:                            rr.mRect.YMost() - rr.mRadii[NS_CORNER_BOTTOM_RIGHT_Y],
61322:                            rect.YMost())) {
61322:         return true;
61322:       }
61322:     }
61322:   }
61322:   return false;
61322: }
61322: 
61322: nsRect
61322: FrameLayerBuilder::Clip::NonRoundedIntersection() const
61322: {
61322:   NS_ASSERTION(!mRoundedClipRects.IsEmpty(), "no rounded clip rects?");
61322:   nsRect result = mClipRect;
61322:   for (PRUint32 i = 0, iEnd = mRoundedClipRects.Length();
61322:        i < iEnd; ++i) {
61322:     result.IntersectRect(result, mRoundedClipRects[i].mRect);
61322:   }
61322:   return result;
61322: }
61322: 
61322: void
61322: FrameLayerBuilder::Clip::RemoveRoundedCorners()
61322: {
61322:   if (mRoundedClipRects.IsEmpty())
61322:     return;
61322: 
61322:   mClipRect = NonRoundedIntersection();
61322:   mRoundedClipRects.Clear();
61322: }
61322: 
42593: } // namespace mozilla
