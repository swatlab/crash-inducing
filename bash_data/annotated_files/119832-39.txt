 99778: /* This Source Code Form is subject to the terms of the Mozilla Public
 99778:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 99778:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsPKCS11Slot.h"
     1: #include "nsPK11TokenDB.h"
     1: 
     1: #include "nsCOMPtr.h"
     1: #include "nsISupportsArray.h"
     1: #include "nsString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsCRT.h"
     1: 
     1: #include "secmod.h"
     1: 
     1: #ifdef PR_LOGGING
     1: extern PRLogModuleInfo* gPIPNSSLog;
     1: #endif
     1: 
     1: NS_IMPL_ISUPPORTS1(nsPKCS11Slot, nsIPKCS11Slot)
     1: 
     1: nsPKCS11Slot::nsPKCS11Slot(PK11SlotInfo *slot)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   PK11_ReferenceSlot(slot);
     1:   mSlot = slot;
     1:   mSeries = PK11_GetSlotSeries(slot);
     1:   refreshSlotInfo();
     1: }
     1: 
     1: void
     1: nsPKCS11Slot::refreshSlotInfo()
     1: {
     1:   CK_SLOT_INFO slot_info;
     1:   if (PK11_GetSlotInfo(mSlot, &slot_info) == SECSuccess) {
     1:     // Set the Description field
     1:     const char *ccDesc = (const char*)slot_info.slotDescription;
     1:     const nsACString &cDesc = Substring(
     1:       ccDesc, 
     1:       ccDesc+PL_strnlen(ccDesc, sizeof(slot_info.slotDescription)));
     1:     mSlotDesc = NS_ConvertUTF8toUTF16(cDesc);
 80486:     mSlotDesc.Trim(" ", false, true);
     1:     // Set the Manufacturer field
     1:     const char *ccManID = (const char*)slot_info.manufacturerID;
     1:     const nsACString &cManID = Substring(
     1:       ccManID, 
     1:       ccManID+PL_strnlen(ccManID, sizeof(slot_info.manufacturerID)));
     1:     mSlotManID = NS_ConvertUTF8toUTF16(cManID);
 80486:     mSlotManID.Trim(" ", false, true);
     1:     // Set the Hardware Version field
     1:     mSlotHWVersion = EmptyString();
     1:     mSlotHWVersion.AppendInt(slot_info.hardwareVersion.major);
     1:     mSlotHWVersion.AppendLiteral(".");
     1:     mSlotHWVersion.AppendInt(slot_info.hardwareVersion.minor);
     1:     // Set the Firmware Version field
     1:     mSlotFWVersion = EmptyString();
     1:     mSlotFWVersion.AppendInt(slot_info.firmwareVersion.major);
     1:     mSlotFWVersion.AppendLiteral(".");
     1:     mSlotFWVersion.AppendInt(slot_info.firmwareVersion.minor);
     1:   }
     1: 
     1: }
     1: 
     1: nsPKCS11Slot::~nsPKCS11Slot()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   destructorSafeDestroyNSSReference();
     1:   shutdown(calledFromObject);
     1: }
     1: 
     1: void nsPKCS11Slot::virtualDestroyNSSReference()
     1: {
     1:   destructorSafeDestroyNSSReference();
     1: }
     1: 
     1: void nsPKCS11Slot::destructorSafeDestroyNSSReference()
     1: {
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   if (mSlot) {
     1:     PK11_FreeSlot(mSlot);
106838:     mSlot = nullptr;
     1:   }
     1: }
     1: 
     1: /* readonly attribute wstring name; */
     1: NS_IMETHODIMP 
     1: nsPKCS11Slot::GetName(PRUnichar **aName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   char *csn = PK11_GetSlotName(mSlot);
     1:   if (*csn) {
     1:     *aName = ToNewUnicode(NS_ConvertUTF8toUTF16(csn));
     1:   } else if (PK11_HasRootCerts(mSlot)) {
     1:     // This is a workaround to an Root Module bug - the root certs module has
     1:     // no slot name.  Not bothering to localize, because this is a workaround
     1:     // and for now all the slot names returned by NSS are char * anyway.
     1:     *aName = ToNewUnicode(NS_LITERAL_STRING("Root Certificates"));
     1:   } else {
     1:     // same as above, this is a catch-all
     1:     *aName = ToNewUnicode(NS_LITERAL_STRING("Unnamed Slot"));
     1:   }
     1:   if (!*aName) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring desc; */
     1: NS_IMETHODIMP 
     1: nsPKCS11Slot::GetDesc(PRUnichar **aDesc)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshSlotInfo();
     1:   }
     1: 
     1:   *aDesc = ToNewUnicode(mSlotDesc);
     1:   if (!*aDesc) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring manID; */
     1: NS_IMETHODIMP 
     1: nsPKCS11Slot::GetManID(PRUnichar **aManID)
     1: {
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshSlotInfo();
     1:   }
     1:   *aManID = ToNewUnicode(mSlotManID);
     1:   if (!*aManID) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring HWVersion; */
     1: NS_IMETHODIMP 
     1: nsPKCS11Slot::GetHWVersion(PRUnichar **aHWVersion)
     1: {
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshSlotInfo();
     1:   }
     1:   *aHWVersion = ToNewUnicode(mSlotHWVersion);
     1:   if (!*aHWVersion) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring FWVersion; */
     1: NS_IMETHODIMP 
     1: nsPKCS11Slot::GetFWVersion(PRUnichar **aFWVersion)
     1: {
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshSlotInfo();
     1:   }
     1:   *aFWVersion = ToNewUnicode(mSlotFWVersion);
     1:   if (!*aFWVersion) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: /* nsIPK11Token getToken (); */
     1: NS_IMETHODIMP 
     1: nsPKCS11Slot::GetToken(nsIPK11Token **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsCOMPtr<nsIPK11Token> token = new nsPK11Token(mSlot);
119832:   if (!token)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1:   *_retval = token;
     1:   NS_ADDREF(*_retval);
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring tokenName; */
     1: NS_IMETHODIMP 
     1: nsPKCS11Slot::GetTokenName(PRUnichar **aName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   if (!PK11_IsPresent(mSlot)) {
106838:     *aName = nullptr;
     1:     return NS_OK;
     1:   }
     1: 
     1:   if (mSeries != PK11_GetSlotSeries(mSlot)) {
     1:     refreshSlotInfo();
     1:   }
     1: 
     1: 
     1:   *aName = ToNewUnicode(NS_ConvertUTF8toUTF16(PK11_GetTokenName(mSlot)));
     1:   if (!*aName) return NS_ERROR_OUT_OF_MEMORY;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMETHODIMP
108991: nsPKCS11Slot::GetStatus(uint32_t *_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   if (PK11_IsDisabled(mSlot))
     1:     *_retval = SLOT_DISABLED;
     1:   else if (!PK11_IsPresent(mSlot))
     1:     *_retval = SLOT_NOT_PRESENT;
     1:   else if (PK11_NeedLogin(mSlot) && PK11_NeedUserInit(mSlot))
     1:     *_retval = SLOT_UNINITIALIZED;
119832:   else if (PK11_NeedLogin(mSlot) && !PK11_IsLoggedIn(mSlot, NULL))
     1:     *_retval = SLOT_NOT_LOGGED_IN;
     1:   else if (PK11_NeedLogin(mSlot))
     1:     *_retval = SLOT_LOGGED_IN;
     1:   else
     1:     *_retval = SLOT_READY;
     1:   return NS_OK;
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS1(nsPKCS11Module, nsIPKCS11Module)
     1: 
     1: nsPKCS11Module::nsPKCS11Module(SECMODModule *module)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   SECMOD_ReferenceModule(module);
     1:   mModule = module;
     1: }
     1: 
     1: nsPKCS11Module::~nsPKCS11Module()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   destructorSafeDestroyNSSReference();
     1:   shutdown(calledFromObject);
     1: }
     1: 
     1: void nsPKCS11Module::virtualDestroyNSSReference()
     1: {
     1:   destructorSafeDestroyNSSReference();
     1: }
     1: 
     1: void nsPKCS11Module::destructorSafeDestroyNSSReference()
     1: {
     1:   if (isAlreadyShutDown())
     1:     return;
     1: 
     1:   if (mModule) {
     1:     SECMOD_DestroyModule(mModule);
106838:     mModule = nullptr;
     1:   }
     1: }
     1: 
     1: /* readonly attribute wstring name; */
     1: NS_IMETHODIMP 
     1: nsPKCS11Module::GetName(PRUnichar **aName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   *aName = ToNewUnicode(NS_ConvertUTF8toUTF16(mModule->commonName));
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute wstring libName; */
     1: NS_IMETHODIMP 
     1: nsPKCS11Module::GetLibName(PRUnichar **aName)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   if ( mModule->dllName ) {
     1:     *aName = ToNewUnicode(NS_ConvertUTF8toUTF16(mModule->dllName));
     1:   } else {
119832:     *aName = NULL;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: /*  nsIPKCS11Slot findSlotByName(in wstring name); */
     1: NS_IMETHODIMP 
     1: nsPKCS11Module::FindSlotByName(const PRUnichar *aName,
     1:                                nsIPKCS11Slot **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   char *asciiname = ToNewUTF8String(nsDependentString(aName));
     1:   PR_LOG(gPIPNSSLog, PR_LOG_DEBUG, ("Getting \"%s\"\n", asciiname));
119832:   PK11SlotInfo *slotinfo = NULL;
     1:   PK11SlotList *slotList = PK11_FindSlotsByNames(mModule->dllName, 
119832:         asciiname /* slotName */, NULL /* token Name */, false);
     1:   if (!slotList) {
     1:     /* name must be the token name */
     1:     slotList = PK11_FindSlotsByNames(mModule->dllName, 
119832:         NULL /*slot Name */, asciiname /* token Name */, false);
     1:   }
     1:   if (slotList) {
     1:     /* should only be one */
     1:     if (slotList->head && slotList->head->slot) {
     1:       slotinfo =  PK11_ReferenceSlot(slotList->head->slot);
     1:     }
     1:     PK11_FreeSlotList(slotList);
     1:   }
     1:   if (!slotinfo) {
     1:     // workaround - the builtin module has no name
119832:     if (asciiname == nullptr) {
     1:       return NS_ERROR_FAILURE;
     1:     } else if (nsCRT::strcmp(asciiname, "Root Certificates") == 0) {
     1:       slotinfo = PK11_ReferenceSlot(mModule->slots[0]);
     1:     } else {
     1:       // give up
     1:       nsMemory::Free(asciiname);
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:   } 
     1:   nsMemory::Free(asciiname);
     1:   nsCOMPtr<nsIPKCS11Slot> slot = new nsPKCS11Slot(slotinfo);
     1:   PK11_FreeSlot(slotinfo);
119832:   if (!slot)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1:   *_retval = slot;
     1:   NS_ADDREF(*_retval);
     1:   return NS_OK;
     1: }
     1: 
     1: /* nsIEnumerator listSlots (); */
     1: NS_IMETHODIMP 
     1: nsPKCS11Module::ListSlots(nsIEnumerator **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   if (isAlreadyShutDown())
     1:     return NS_ERROR_NOT_AVAILABLE;
     1: 
     1:   nsresult rv = NS_OK;
     1:   int i;
     1:   /* get isupports array */
     1:   nsCOMPtr<nsISupportsArray> array;
     1:   rv = NS_NewISupportsArray(getter_AddRefs(array));
     1:   if (NS_FAILED(rv)) return rv;
     1:   /* applications which allow new slot creation (which Firefox now does
     1:    * since it uses the WaitForSlotEvent call) need to hold the
     1:    * ModuleList Read lock to prevent the slot array from changing out
     1:    * from under it. */
     1:   SECMODListLock *lock = SECMOD_GetDefaultModuleListLock();
     1:   SECMOD_GetReadLock(lock);
     1:   for (i=0; i<mModule->slotCount; i++) {
     1:     if (mModule->slots[i]) {
     1:       nsCOMPtr<nsIPKCS11Slot> slot = new nsPKCS11Slot(mModule->slots[i]);
     1:       array->AppendElement(slot);
     1:     }
     1:   }
     1:   SECMOD_ReleaseReadLock(lock);
     1:   rv = array->Enumerate(_retval);
     1:   return rv;
     1: }
     1: 
     1: NS_IMPL_ISUPPORTS2(nsPKCS11ModuleDB, nsIPKCS11ModuleDB, nsICryptoFIPSInfo)
     1: 
     1: nsPKCS11ModuleDB::nsPKCS11ModuleDB()
     1: {
     1: }
     1: 
     1: nsPKCS11ModuleDB::~nsPKCS11ModuleDB()
     1: {
     1: }
     1: 
     1: /* nsIPKCS11Module getInternal (); */
     1: NS_IMETHODIMP 
     1: nsPKCS11ModuleDB::GetInternal(nsIPKCS11Module **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   SECMODModule *nssMod = 
119832:     SECMOD_CreateModule(NULL,SECMOD_INT_NAME, NULL,SECMOD_INT_FLAGS);
     1:   nsCOMPtr<nsIPKCS11Module> module = new nsPKCS11Module(nssMod);
     1:   SECMOD_DestroyModule(nssMod);
119832:   if (!module)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1:   *_retval = module;
     1:   NS_ADDREF(*_retval);
     1:   return NS_OK;
     1: }
     1: 
     1: /* nsIPKCS11Module getInternalFIPS (); */
     1: NS_IMETHODIMP 
     1: nsPKCS11ModuleDB::GetInternalFIPS(nsIPKCS11Module **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   SECMODModule *nssMod = 
119832:     SECMOD_CreateModule(NULL, SECMOD_FIPS_NAME, NULL, SECMOD_FIPS_FLAGS);
     1:   nsCOMPtr<nsIPKCS11Module> module = new nsPKCS11Module(nssMod);
     1:   SECMOD_DestroyModule(nssMod);
119832:   if (!module)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1:   *_retval = module;
     1:   NS_ADDREF(*_retval);
     1:   return NS_OK;
     1: }
     1: 
     1: /* nsIPKCS11Module findModuleByName(in wstring name); */
     1: NS_IMETHODIMP 
     1: nsPKCS11ModuleDB::FindModuleByName(const PRUnichar *aName,
     1:                                    nsIPKCS11Module **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   NS_ConvertUTF16toUTF8 aUtf8Name(aName);
     1:   SECMODModule *mod =
  3233:     SECMOD_FindModule(const_cast<char *>(aUtf8Name.get()));
     1:   if (!mod)
     1:     return NS_ERROR_FAILURE;
     1:   nsCOMPtr<nsIPKCS11Module> module = new nsPKCS11Module(mod);
     1:   SECMOD_DestroyModule(mod);
119832:   if (!module)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1:   *_retval = module;
     1:   NS_ADDREF(*_retval);
     1:   return NS_OK;
     1: }
     1: 
     1: /* This is essentially the same as nsIPK11Token::findTokenByName, except
     1:  * that it returns an nsIPKCS11Slot, which may be desired.
     1:  */
     1: /* nsIPKCS11Module findSlotByName(in wstring name); */
     1: NS_IMETHODIMP 
     1: nsPKCS11ModuleDB::FindSlotByName(const PRUnichar *aName,
     1:                                  nsIPKCS11Slot **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   NS_ConvertUTF16toUTF8 aUtf8Name(aName);
     1:   PK11SlotInfo *slotinfo =
  3233:    PK11_FindSlotByName(const_cast<char*>(aUtf8Name.get()));
     1:   if (!slotinfo)
     1:     return NS_ERROR_FAILURE;
     1:   nsCOMPtr<nsIPKCS11Slot> slot = new nsPKCS11Slot(slotinfo);
     1:   PK11_FreeSlot(slotinfo);
119832:   if (!slot)
119832:     return NS_ERROR_OUT_OF_MEMORY;
     1:   *_retval = slot;
     1:   NS_ADDREF(*_retval);
     1:   return NS_OK;
     1: }
     1: 
     1: /* nsIEnumerator listModules (); */
     1: NS_IMETHODIMP 
     1: nsPKCS11ModuleDB::ListModules(nsIEnumerator **_retval)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   nsresult rv = NS_OK;
     1:   /* get isupports array */
     1:   nsCOMPtr<nsISupportsArray> array;
     1:   rv = NS_NewISupportsArray(getter_AddRefs(array));
     1:   if (NS_FAILED(rv)) return rv;
     1:   /* get the default list of modules */
     1:   SECMODModuleList *list = SECMOD_GetDefaultModuleList();
     1:   /* lock down the list for reading */
     1:   SECMODListLock *lock = SECMOD_GetDefaultModuleListLock();
     1:   SECMOD_GetReadLock(lock);
     1:   while (list) {
     1:     nsCOMPtr<nsIPKCS11Module> module = new nsPKCS11Module(list->module);
     1:     array->AppendElement(module);
     1:     list = list->next;
     1:   }
     1:   /* Get the modules in the database that didn't load */
     1:   list = SECMOD_GetDeadModuleList();
     1:   while (list) {
     1:     nsCOMPtr<nsIPKCS11Module> module = new nsPKCS11Module(list->module);
     1:     array->AppendElement(module);
     1:     list = list->next;
     1:   }
     1:   SECMOD_ReleaseReadLock(lock);
     1:   rv = array->Enumerate(_retval);
     1:   return rv;
     1: }
     1: 
 79445: NS_IMETHODIMP nsPKCS11ModuleDB::GetCanToggleFIPS(bool *aCanToggleFIPS)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   *aCanToggleFIPS = SECMOD_CanDeleteInternalModule();
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: /* void toggleFIPSMode (); */
     1: NS_IMETHODIMP nsPKCS11ModuleDB::ToggleFIPSMode()
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   // The way to toggle FIPS mode in NSS is extremely obscure.
     1:   // Basically, we delete the internal module, and voila it
     1:   // gets replaced with the opposite module, ie if it was 
     1:   // FIPS before, then it becomes non-FIPS next.
     1:   SECMODModule *internal;
     1: 
     1:   // This function returns us a pointer to a local copy of 
     1:   // the internal module stashed in NSS.  We don't want to
     1:   // delete it since it will cause much pain in NSS.
     1:   internal = SECMOD_GetInternalModule();
     1:   if (!internal)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   SECStatus srv = SECMOD_DeleteInternalModule(internal->commonName);
     1:   if (srv != SECSuccess)
     1:     return NS_ERROR_FAILURE;
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute boolean isFIPSEnabled; */
 79445: NS_IMETHODIMP nsPKCS11ModuleDB::GetIsFIPSEnabled(bool *aIsFIPSEnabled)
     1: {
     1:   nsNSSShutDownPreventionLock locker;
     1:   *aIsFIPSEnabled = PK11_IsFIPS();
     1:   return NS_OK;
     1: }
     1: 
 79445: NS_IMETHODIMP nsPKCS11ModuleDB::GetIsFIPSModeActive(bool *aIsFIPSModeActive)
     1: {
     1:   return GetIsFIPSEnabled(aIsFIPSModeActive);
     1: }
