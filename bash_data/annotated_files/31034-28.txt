16295: /********************************************************************
16295:  *                                                                  *
16295:  * THIS FILE IS PART OF THE OggVorbis SOFTWARE CODEC SOURCE CODE.   *
16295:  * USE, DISTRIBUTION AND REPRODUCTION OF THIS LIBRARY SOURCE IS     *
16295:  * GOVERNED BY A BSD-STYLE SOURCE LICENSE INCLUDED WITH THIS SOURCE *
16295:  * IN 'COPYING'. PLEASE READ THESE TERMS BEFORE DISTRIBUTING.       *
16295:  *                                                                  *
31034:  * THE OggVorbis SOURCE CODE IS (C) COPYRIGHT 1994-2009             *
16295:  * by the Xiph.Org Foundation http://www.xiph.org/                  *
16295:  *                                                                  *
16295:  ********************************************************************
16295: 
16295:  function: floor backend 0 implementation
31034:  last mod: $Id: floor0.c 16227 2009-07-08 06:58:46Z xiphmont $
16295: 
16295:  ********************************************************************/
16295: 
16295: #include <stdlib.h>
16295: #include <string.h>
16295: #include <math.h>
16295: #include <ogg/ogg.h>
16295: #include "vorbis/codec.h"
16295: #include "codec_internal.h"
16295: #include "registry.h"
16295: #include "lpc.h"
16295: #include "lsp.h"
16295: #include "codebook.h"
16295: #include "scales.h"
16295: #include "misc.h"
16295: #include "os.h"
16295: 
16295: #include "misc.h"
16295: #include <stdio.h>
16295: 
16295: typedef struct {
16295:   int ln;
16295:   int  m;
16295:   int **linearmap;
16295:   int  n[2];
16295: 
16295:   vorbis_info_floor0 *vi;
16295: 
16295:   long bits;
16295:   long frames;
16295: } vorbis_look_floor0;
16295: 
16295: 
16295: /***********************************************/
16295: 
16295: static void floor0_free_info(vorbis_info_floor *i){
16295:   vorbis_info_floor0 *info=(vorbis_info_floor0 *)i;
16295:   if(info){
16295:     memset(info,0,sizeof(*info));
16295:     _ogg_free(info);
16295:   }
16295: }
16295: 
16295: static void floor0_free_look(vorbis_look_floor *i){
16295:   vorbis_look_floor0 *look=(vorbis_look_floor0 *)i;
16295:   if(look){
16295: 
16295:     if(look->linearmap){
16295: 
16295:       if(look->linearmap[0])_ogg_free(look->linearmap[0]);
16295:       if(look->linearmap[1])_ogg_free(look->linearmap[1]);
16295: 
16295:       _ogg_free(look->linearmap);
16295:     }
16295:     memset(look,0,sizeof(*look));
16295:     _ogg_free(look);
16295:   }
16295: }
16295: 
16295: static vorbis_info_floor *floor0_unpack (vorbis_info *vi,oggpack_buffer *opb){
16295:   codec_setup_info     *ci=vi->codec_setup;
16295:   int j;
16295: 
16295:   vorbis_info_floor0 *info=_ogg_malloc(sizeof(*info));
16295:   info->order=oggpack_read(opb,8);
16295:   info->rate=oggpack_read(opb,16);
16295:   info->barkmap=oggpack_read(opb,16);
16295:   info->ampbits=oggpack_read(opb,6);
16295:   info->ampdB=oggpack_read(opb,8);
16295:   info->numbooks=oggpack_read(opb,4)+1;
16295: 
16295:   if(info->order<1)goto err_out;
16295:   if(info->rate<1)goto err_out;
16295:   if(info->barkmap<1)goto err_out;
16295:   if(info->numbooks<1)goto err_out;
16295: 
16295:   for(j=0;j<info->numbooks;j++){
16295:     info->books[j]=oggpack_read(opb,8);
16295:     if(info->books[j]<0 || info->books[j]>=ci->books)goto err_out;
16295:   }
16295:   return(info);
16295: 
16295:  err_out:
16295:   floor0_free_info(info);
16295:   return(NULL);
16295: }
16295: 
16295: /* initialize Bark scale and normalization lookups.  We could do this
16295:    with static tables, but Vorbis allows a number of possible
16295:    combinations, so it's best to do it computationally.
16295: 
16295:    The below is authoritative in terms of defining scale mapping.
16295:    Note that the scale depends on the sampling rate as well as the
16295:    linear block and mapping sizes */
16295: 
16295: static void floor0_map_lazy_init(vorbis_block      *vb,
16295:                                  vorbis_info_floor *infoX,
16295:                                  vorbis_look_floor0 *look){
16295:   if(!look->linearmap[vb->W]){
16295:     vorbis_dsp_state   *vd=vb->vd;
16295:     vorbis_info        *vi=vd->vi;
16295:     codec_setup_info   *ci=vi->codec_setup;
16295:     vorbis_info_floor0 *info=(vorbis_info_floor0 *)infoX;
16295:     int W=vb->W;
16295:     int n=ci->blocksizes[W]/2,j;
16295: 
16295:     /* we choose a scaling constant so that:
16295:        floor(bark(rate/2-1)*C)=mapped-1
16295:      floor(bark(rate/2)*C)=mapped */
16295:     float scale=look->ln/toBARK(info->rate/2.f);
16295: 
16295:     /* the mapping from a linear scale to a smaller bark scale is
16295:        straightforward.  We do *not* make sure that the linear mapping
16295:        does not skip bark-scale bins; the decoder simply skips them and
16295:        the encoder may do what it wishes in filling them.  They're
16295:        necessary in some mapping combinations to keep the scale spacing
16295:        accurate */
16295:     look->linearmap[W]=_ogg_malloc((n+1)*sizeof(**look->linearmap));
16295:     for(j=0;j<n;j++){
16295:       int val=floor( toBARK((info->rate/2.f)/n*j)
16295:                      *scale); /* bark numbers represent band edges */
16295:       if(val>=look->ln)val=look->ln-1; /* guard against the approximation */
16295:       look->linearmap[W][j]=val;
16295:     }
16295:     look->linearmap[W][j]=-1;
16295:     look->n[W]=n;
16295:   }
16295: }
16295: 
16295: static vorbis_look_floor *floor0_look(vorbis_dsp_state *vd,
16295:                                       vorbis_info_floor *i){
16295:   vorbis_info_floor0 *info=(vorbis_info_floor0 *)i;
16295:   vorbis_look_floor0 *look=_ogg_calloc(1,sizeof(*look));
16295:   look->m=info->order;
16295:   look->ln=info->barkmap;
16295:   look->vi=info;
16295: 
16295:   look->linearmap=_ogg_calloc(2,sizeof(*look->linearmap));
16295: 
16295:   return look;
16295: }
16295: 
16295: static void *floor0_inverse1(vorbis_block *vb,vorbis_look_floor *i){
16295:   vorbis_look_floor0 *look=(vorbis_look_floor0 *)i;
16295:   vorbis_info_floor0 *info=look->vi;
16295:   int j,k;
16295: 
16295:   int ampraw=oggpack_read(&vb->opb,info->ampbits);
16295:   if(ampraw>0){ /* also handles the -1 out of data case */
16295:     long maxval=(1<<info->ampbits)-1;
16295:     float amp=(float)ampraw/maxval*info->ampdB;
16295:     int booknum=oggpack_read(&vb->opb,_ilog(info->numbooks));
16295: 
16295:     if(booknum!=-1 && booknum<info->numbooks){ /* be paranoid */
16295:       codec_setup_info  *ci=vb->vd->vi->codec_setup;
16295:       codebook *b=ci->fullbooks+info->books[booknum];
16295:       float last=0.f;
16295: 
16295:       /* the additional b->dim is a guard against any possible stack
16295:          smash; b->dim is provably more than we can overflow the
16295:          vector */
16295:       float *lsp=_vorbis_block_alloc(vb,sizeof(*lsp)*(look->m+b->dim+1));
16295: 
16295:       for(j=0;j<look->m;j+=b->dim)
16295:         if(vorbis_book_decodev_set(b,lsp+j,&vb->opb,b->dim)==-1)goto eop;
16295:       for(j=0;j<look->m;){
16295:         for(k=0;k<b->dim;k++,j++)lsp[j]+=last;
16295:         last=lsp[j-1];
16295:       }
16295: 
16295:       lsp[look->m]=amp;
16295:       return(lsp);
16295:     }
16295:   }
16295:  eop:
16295:   return(NULL);
16295: }
16295: 
16295: static int floor0_inverse2(vorbis_block *vb,vorbis_look_floor *i,
16295:                            void *memo,float *out){
16295:   vorbis_look_floor0 *look=(vorbis_look_floor0 *)i;
16295:   vorbis_info_floor0 *info=look->vi;
16295: 
16295:   floor0_map_lazy_init(vb,info,look);
16295: 
16295:   if(memo){
16295:     float *lsp=(float *)memo;
16295:     float amp=lsp[look->m];
16295: 
16295:     /* take the coefficients back to a spectral envelope curve */
16295:     vorbis_lsp_to_curve(out,
16295:                         look->linearmap[vb->W],
16295:                         look->n[vb->W],
16295:                         look->ln,
16295:                         lsp,look->m,amp,(float)info->ampdB);
16295:     return(1);
16295:   }
16295:   memset(out,0,sizeof(*out)*look->n[vb->W]);
16295:   return(0);
16295: }
16295: 
16295: /* export hooks */
30043: const vorbis_func_floor floor0_exportbundle={
16295:   NULL,&floor0_unpack,&floor0_look,&floor0_free_info,
16295:   &floor0_free_look,&floor0_inverse1,&floor0_inverse2
16295: };
