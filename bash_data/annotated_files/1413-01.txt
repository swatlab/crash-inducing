   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is mozilla.org code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "nsView.h"
   1: #include "nsIWidget.h"
   1: #include "nsViewManager.h"
   1: #include "nsIWidget.h"
   1: #include "nsGUIEvent.h"
   1: #include "nsIDeviceContext.h"
   1: #include "nsIComponentManager.h"
   1: #include "nsIRenderingContext.h"
   1: #include "nsTransform2D.h"
   1: #include "nsIScrollableView.h"
   1: #include "nsGfxCIID.h"
   1: #include "nsIRegion.h"
   1: #include "nsIInterfaceRequestor.h"
   1: 
   1: 
   1: //mmptemp
   1: 
   1: static nsEventStatus PR_CALLBACK HandleEvent(nsGUIEvent *aEvent);
   1: 
   1: 
   1: //#define SHOW_VIEW_BORDERS
   1: //#define HIDE_ALL_WIDGETS
   1: 
   1: // {34297A07-A8FD-d811-87C6-000244212BCB}
   1: #define VIEW_WRAPPER_IID \
   1: { 0x34297a07, 0xa8fd, 0xd811, { 0x87, 0xc6, 0x0, 0x2, 0x44, 0x21, 0x2b, 0xcb } }
   1: 
   1: 
   1: /**
   1:  * nsISupports-derived helper class that allows to store and get a view
   1:  */
   1: class ViewWrapper : public nsIInterfaceRequestor
   1: {
   1:   public:
   1:     NS_DECLARE_STATIC_IID_ACCESSOR(VIEW_WRAPPER_IID)
   1:     NS_DECL_ISUPPORTS
   1:     NS_DECL_NSIINTERFACEREQUESTOR
   1: 
   1:     ViewWrapper(nsView* aView) : mView(aView) {}
   1: 
   1:     nsView* GetView() { return mView; }
   1:   private:
   1:     nsView* mView;
   1: };
   1: 
   1: NS_DEFINE_STATIC_IID_ACCESSOR(ViewWrapper, VIEW_WRAPPER_IID)
   1: 
   1: NS_IMPL_ADDREF(ViewWrapper)
   1: NS_IMPL_RELEASE(ViewWrapper)
   1: #ifndef DEBUG
   1: NS_IMPL_QUERY_INTERFACE2(ViewWrapper, ViewWrapper, nsIInterfaceRequestor)
   1: 
   1: #else
   1: NS_IMETHODIMP ViewWrapper::QueryInterface(REFNSIID aIID, void** aInstancePtr)
   1: {
   1:   NS_ENSURE_ARG_POINTER(aInstancePtr);
   1: 
   1:   NS_ASSERTION(!aIID.Equals(NS_GET_IID(nsIView)) &&
   1:                !aIID.Equals(NS_GET_IID(nsIScrollableView)),
   1:                "Someone expects a viewwrapper to be a view!");
   1:   
   1:   *aInstancePtr = nsnull;
   1:   
   1:   if (aIID.Equals(NS_GET_IID(nsISupports))) {
   1:     *aInstancePtr = NS_STATIC_CAST(nsISupports*, this);
   1:   }
   1:   else if (aIID.Equals(NS_GET_IID(ViewWrapper))) {
   1:     *aInstancePtr = this;
   1:   }
   1:   else if (aIID.Equals(NS_GET_IID(nsIInterfaceRequestor))) {
   1:     *aInstancePtr = this;
   1:   }
   1: 
   1: 
   1:   if (*aInstancePtr) {
   1:     AddRef();
   1:     return NS_OK;
   1:   }
   1: 
   1:   return NS_NOINTERFACE;
   1: }
   1: #endif
   1: 
   1: NS_IMETHODIMP ViewWrapper::GetInterface(REFNSIID aIID, void** aInstancePtr)
   1: {
   1:   if (aIID.Equals(NS_GET_IID(nsIScrollableView))) {
   1:     *aInstancePtr = mView->ToScrollableView();
   1:     return NS_OK;
   1:   }
   1:   if (aIID.Equals(NS_GET_IID(nsIView))) {
   1:     *aInstancePtr = mView;
   1:     return NS_OK;
   1:   }
   1:   return QueryInterface(aIID, aInstancePtr);
   1: }
   1: 
   1: /**
   1:  * Given a widget, returns the stored ViewWrapper on it, or NULL if no
   1:  * ViewWrapper is there.
   1:  */
   1: static ViewWrapper* GetWrapperFor(nsIWidget* aWidget)
   1: {
   1:   // The widget's client data points back to the owning view
   1:   if (aWidget) {
   1:     void* clientData;
   1:     aWidget->GetClientData(clientData);
   1:     nsISupports* data = (nsISupports*)clientData;
   1:     
   1:     if (data) {
   1:       ViewWrapper* wrapper;
   1:       CallQueryInterface(data, &wrapper);
   1:       // Give a weak reference to the caller. There will still be at least one
   1:       // reference left, since the wrapper was addrefed when set on the widget.
   1:       if (wrapper)
   1:         wrapper->Release();
   1:       return wrapper;
   1:     }
   1:   }
   1:   return nsnull;
   1: }
   1: 
   1: //
   1: // Main events handler
   1: //
   1: nsEventStatus PR_CALLBACK HandleEvent(nsGUIEvent *aEvent)
   1: { 
   1: //printf(" %d %d %d (%d,%d) \n", aEvent->widget, aEvent->widgetSupports, 
   1: //       aEvent->message, aEvent->point.x, aEvent->point.y);
   1:   nsEventStatus result = nsEventStatus_eIgnore;
   1:   nsView       *view = nsView::GetViewFor(aEvent->widget);
   1: 
   1:   if (view)
   1:   {
   1:     view->GetViewManager()->DispatchEvent(aEvent, &result);
   1:   }
   1: 
   1:   return result;
   1: }
   1: 
   1: nsView::nsView(nsViewManager* aViewManager, nsViewVisibility aVisibility)
   1: {
   1:   MOZ_COUNT_CTOR(nsView);
   1: 
   1:   mVis = aVisibility;
   1:   // Views should be transparent by default. Not being transparent is
   1:   // a promise that the view will paint all its pixels opaquely. Views
   1:   // should make this promise explicitly by calling
   1:   // SetViewContentTransparency.
   1:   mVFlags = 0;
   1:   mViewManager = aViewManager;
   1:   mChildRemoved = PR_FALSE;
   1:   mDirtyRegion = nsnull;
   1: }
   1: 
   1: void nsView::DropMouseGrabbing() {
   1:   // check to see if we are grabbing events
   1:   if (mViewManager->GetMouseEventGrabber() == this) {
   1:     // we are grabbing events. Move the grab to the parent if we can.
   1:     PRBool boolResult; //not used
   1:     // if GetParent() returns null, then we release the grab, which is the best we can do
   1:     mViewManager->GrabMouseEvents(GetParent(), boolResult);
   1:   }
   1: }
   1: 
   1: nsView::~nsView()
   1: {
   1:   MOZ_COUNT_DTOR(nsView);
   1: 
   1:   while (GetFirstChild())
   1:   {
   1:     nsView* child = GetFirstChild();
   1:     if (child->GetViewManager() == mViewManager) {
   1:       child->Destroy();
   1:     } else {
   1:       // just unhook it. Someone else will want to destroy this.
   1:       RemoveChild(child);
   1:     }
   1:   }
   1: 
   1:   if (mViewManager)
   1:   {
   1:     DropMouseGrabbing();
   1:   
   1:     nsView *rootView = mViewManager->GetRootView();
   1:     
   1:     if (rootView)
   1:     {
   1:       // Root views can have parents!
   1:       if (mParent)
   1:       {
   1:         mViewManager->RemoveChild(this);
   1:       }
   1: 
   1:       if (rootView == this)
   1:       {
   1:         // Inform the view manager that the root view has gone away...
   1:         mViewManager->SetRootView(nsnull);
   1:       }
   1:     }
   1:     else if (mParent)
   1:     {
   1:       mParent->RemoveChild(this);
   1:     }
   1:     
   1:     mViewManager = nsnull;
   1:   }
   1:   else if (mParent)
   1:   {
   1:     mParent->RemoveChild(this);
   1:   }
   1: 
   1:   if (mZParent)
   1:   {
   1:     mZParent->RemoveReparentedView();
   1:     mZParent->Destroy();
   1:   }
   1: 
   1:   // Destroy and release the widget
   1:   if (mWindow)
   1:   {
   1:     // Release memory for the view wrapper
   1:     ViewWrapper* wrapper = GetWrapperFor(mWindow);
   1:     NS_IF_RELEASE(wrapper);
   1: 
   1:     mWindow->SetClientData(nsnull);
   1:     mWindow->Destroy();
   1:     NS_RELEASE(mWindow);
   1:   }
   1:   delete mDirtyRegion;
   1:   delete mClipRect;
   1: }
   1: 
   1: nsresult nsView::QueryInterface(const nsIID& aIID, void** aInstancePtr)
   1: {
   1:   if (nsnull == aInstancePtr) {
   1:     return NS_ERROR_NULL_POINTER;
   1:   }
   1: 
   1:   NS_ASSERTION(!aIID.Equals(NS_GET_IID(nsISupports)),
   1:                "Someone expects views to be ISupports-derived!");
   1:   
   1:   *aInstancePtr = nsnull;
   1:   
   1:   if (aIID.Equals(NS_GET_IID(nsIView))) {
   1:     *aInstancePtr = (void*)(nsIView*)this;
   1:     return NS_OK;
   1:   }
   1: 
   1:   return NS_NOINTERFACE;
   1: }
   1: 
   1: nsIView* nsIView::GetViewFor(nsIWidget* aWidget)
   1: {           
   1:   NS_PRECONDITION(nsnull != aWidget, "null widget ptr");
   1: 
   1:   ViewWrapper* wrapper = GetWrapperFor(aWidget);
   1:   if (wrapper)
   1:     return wrapper->GetView();  
   1:   return nsnull;
   1: }
   1: 
   1: void nsIView::Destroy()
   1: {
   1:   delete this;
   1: }
   1: 
   1: void nsView::SetPosition(nscoord aX, nscoord aY)
   1: {
   1:   mDimBounds.x += aX - mPosX;
   1:   mDimBounds.y += aY - mPosY;
   1:   mPosX = aX;
   1:   mPosY = aY;
   1: 
   1:   NS_ASSERTION(GetParent() || (aX == 0 && aY == 0),
   1:                "Don't try to move the root widget to something non-zero");
   1: 
   1:   ResetWidgetBounds(PR_TRUE, PR_TRUE, PR_FALSE);
   1: }
   1: 
   1: void nsView::SetPositionIgnoringChildWidgets(nscoord aX, nscoord aY)
   1: {
   1:   mDimBounds.x += aX - mPosX;
   1:   mDimBounds.y += aY - mPosY;
   1:   mPosX = aX;
   1:   mPosY = aY;
   1: 
   1:   ResetWidgetBounds(PR_FALSE, PR_TRUE, PR_FALSE);
   1: }
   1: 
   1: void nsView::ResetWidgetBounds(PRBool aRecurse, PRBool aMoveOnly,
   1:                                PRBool aInvalidateChangedSize) {
   1:   if (mWindow) {
   1:     // If our view manager has refresh disabled, then do nothing; the view
   1:     // manager will set our position when refresh is reenabled.  Just let it
   1:     // know that it has pending updates.
   1:     if (!mViewManager->IsRefreshEnabled()) {
   1:       mViewManager->PostPendingUpdate();
   1:       return;
   1:     }
   1: 
   1:     DoResetWidgetBounds(aMoveOnly, aInvalidateChangedSize);
   1:   } else if (aRecurse) {
   1:     // reposition any widgets under this view
   1:     for (nsView* v = GetFirstChild(); v; v = v->GetNextSibling()) {
   1:       v->ResetWidgetBounds(PR_TRUE, aMoveOnly, aInvalidateChangedSize);
   1:     }
   1:   }
   1: }
   1: 
   1: void nsView::DoResetWidgetBounds(PRBool aMoveOnly,
   1:                                  PRBool aInvalidateChangedSize) {
   1:   // The geometry of a root view's widget is controlled externally,
   1:   // NOT by sizing or positioning the view
   1:   if (mViewManager->GetRootView() == this) {
   1:     return;
   1:   }
   1:   
   1:   nsRect curBounds;
   1:   mWindow->GetBounds(curBounds);
   1:   nsWindowType type;
   1:   mWindow->GetWindowType(type);
   1: 
   1:   if (curBounds.IsEmpty() && mDimBounds.IsEmpty() && type == eWindowType_popup) {
   1:     // Don't manipulate empty popup widgets. For example there's no point
   1:     // moving hidden comboboxes around, or doing X server roundtrips
   1:     // to compute their true screen position. This could mean that WidgetToScreen
   1:     // operations on these widgets don't return up-to-date values, but popup
   1:     // positions aren't reliable anyway because of correction to be on or off-screen.
   1:     return;
   1:   }
   1: 
   1:   NS_PRECONDITION(mWindow, "Why was this called??");
   1:   nsIDeviceContext  *dx;
   1:   
   1:   mViewManager->GetDeviceContext(dx);
   1:   PRInt32 p2a = dx->AppUnitsPerDevPixel();
   1:   NS_RELEASE(dx);
   1: 
   1:   nsPoint offset(0, 0);
   1:   if (GetParent()) {
   1:     nsIWidget* parentWidget = GetParent()->GetNearestWidget(&offset);
   1:     
   1:     if (type == eWindowType_popup) {
   1:       // put offset into screen coordinates
   1:       nsRect screenRect(0,0,1,1);
   1:       parentWidget->WidgetToScreen(screenRect, screenRect);
   1:       offset += nsPoint(NSIntPixelsToAppUnits(screenRect.x, p2a),
   1:                         NSIntPixelsToAppUnits(screenRect.y, p2a));
   1:     }
   1:   }
   1: 
   1:   nsRect newBounds(NSAppUnitsToIntPixels((mDimBounds.x + offset.x), p2a),
   1:                    NSAppUnitsToIntPixels((mDimBounds.y + offset.y), p2a),
   1:                    NSAppUnitsToIntPixels(mDimBounds.width, p2a),
   1:                    NSAppUnitsToIntPixels(mDimBounds.height, p2a));
   1:     
   1:   PRBool changedPos = PR_TRUE;
   1:   PRBool changedSize = PR_TRUE;
   1:   if (!(mVFlags & NS_VIEW_FLAG_HAS_POSITIONED_WIDGET)) {
   1:     mVFlags |= NS_VIEW_FLAG_HAS_POSITIONED_WIDGET;
   1:   } else {
   1:     changedPos = curBounds.TopLeft() != newBounds.TopLeft();
   1:     changedSize = curBounds.Size() != newBounds.Size();
   1:   }
   1: 
   1:   if (changedPos) {
   1:     if (changedSize && !aMoveOnly) {
   1:       mWindow->Resize(newBounds.x, newBounds.y, newBounds.width, newBounds.height,
   1:                       aInvalidateChangedSize);
   1:     } else {
   1:       mWindow->Move(newBounds.x, newBounds.y);
   1:     }
   1:   } else {
   1:     if (changedSize && !aMoveOnly) {
   1:       mWindow->Resize(newBounds.width, newBounds.height, aInvalidateChangedSize);
   1:     } // else do nothing!
   1:   }
   1: }
   1: 
   1: void nsView::SetDimensions(const nsRect& aRect, PRBool aPaint, PRBool aResizeWidget)
   1: {
   1:   nsRect dims = aRect;
   1:   dims.MoveBy(mPosX, mPosY);
   1: 
   1:   // Don't use nsRect's operator== here, since it returns true when
   1:   // both rects are empty even if they have different widths and we
   1:   // have cases where that sort of thing matters to us.
   1:   if (mDimBounds.TopLeft() == dims.TopLeft() &&
   1:       mDimBounds.Size() == dims.Size()) {
   1:     return;
   1:   }
   1: 
   1:   mDimBounds = dims;
   1: 
   1:   if (aResizeWidget) {
   1:     ResetWidgetBounds(PR_FALSE, PR_FALSE, aPaint);
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP nsView::SetVisibility(nsViewVisibility aVisibility)
   1: {
   1: 
   1:   mVis = aVisibility;
   1: 
   1:   if (aVisibility == nsViewVisibility_kHide)
   1:   {
   1:     DropMouseGrabbing();
   1:   }
   1: 
   1:   if (nsnull != mWindow)
   1:   {
   1: #ifndef HIDE_ALL_WIDGETS
   1:     if (mVis == nsViewVisibility_kShow)
   1:     {
   1:       DoResetWidgetBounds(PR_FALSE, PR_TRUE);
   1:       mWindow->Show(PR_TRUE);
   1:     }
   1:     else
   1: #endif
   1:       mWindow->Show(PR_FALSE);
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: NS_IMETHODIMP nsView::SetFloating(PRBool aFloatingView)
   1: {
   1: 	if (aFloatingView)
   1: 		mVFlags |= NS_VIEW_FLAG_FLOATING;
   1: 	else
   1: 		mVFlags &= ~NS_VIEW_FLAG_FLOATING;
   1: 
   1: #if 0
   1: 	// recursively make all sub-views "floating" grr.
   1: 	for (nsView* child = mFirstChild; chlid; child = child->GetNextSibling()) {
   1: 		child->SetFloating(aFloatingView);
   1: 	}
   1: #endif
   1: 
   1: 	return NS_OK;
   1: }
   1: 
   1: void nsView::InvalidateHierarchy(nsViewManager *aViewManagerParent)
   1: {
   1:   if (aViewManagerParent) {
   1:     // We're removed from the view hierarchy of aRemovalPoint, so make sure
   1:     // we're not still grabbing mouse events.
   1:     if (aViewManagerParent->GetMouseEventGrabber() == this) {
   1:       PRBool res;
   1:       aViewManagerParent->GrabMouseEvents(nsnull, res);
   1:     }
   1:   }
   1: 
   1:   if (mViewManager->GetRootView() == this)
   1:     mViewManager->InvalidateHierarchy();
   1: 
   1:   for (nsView *child = mFirstChild; child; child = child->GetNextSibling())
   1:     child->InvalidateHierarchy(aViewManagerParent);
   1: }
   1: 
   1: void nsView::InsertChild(nsView *aChild, nsView *aSibling)
   1: {
   1:   NS_PRECONDITION(nsnull != aChild, "null ptr");
   1: 
   1:   if (nsnull != aChild)
   1:   {
   1:     if (nsnull != aSibling)
   1:     {
   1: #ifdef NS_DEBUG
   1:       NS_ASSERTION(aSibling->GetParent() == this, "tried to insert view with invalid sibling");
   1: #endif
   1:       //insert after sibling
   1:       aChild->SetNextSibling(aSibling->GetNextSibling());
   1:       aSibling->SetNextSibling(aChild);
   1:     }
   1:     else
   1:     {
   1:       aChild->SetNextSibling(mFirstChild);
   1:       mFirstChild = aChild;
   1:     }
   1:     aChild->SetParent(this);
   1: 
   1:     // If we just inserted a root view, then update the RootViewManager
   1:     // on all view managers in the new subtree.
   1: 
   1:     nsViewManager *vm = aChild->GetViewManager();
   1:     if (vm->GetRootView() == aChild)
   1:     {
   1:       aChild->InvalidateHierarchy(nsnull); // don't care about releasing grabs
   1:     }
   1:   }
   1: }
   1: 
   1: void nsView::RemoveChild(nsView *child)
   1: {
   1:   NS_PRECONDITION(nsnull != child, "null ptr");
   1: 
   1:   if (nsnull != child)
   1:   {
   1:     nsView* prevKid = nsnull;
   1:     nsView* kid = mFirstChild;
   1:     PRBool found = PR_FALSE;
   1:     while (nsnull != kid) {
   1:       if (kid == child) {
   1:         if (nsnull != prevKid) {
   1:           prevKid->SetNextSibling(kid->GetNextSibling());
   1:         } else {
   1:           mFirstChild = kid->GetNextSibling();
   1:         }
   1:         child->SetParent(nsnull);
   1:         found = PR_TRUE;
   1:         break;
   1:       }
   1:       prevKid = kid;
   1:       mChildRemoved = PR_TRUE;
   1: 	    kid = kid->GetNextSibling();
   1:     }
   1:     NS_ASSERTION(found, "tried to remove non child");
   1: 
   1:     // If we just removed a root view, then update the RootViewManager
   1:     // on all view managers in the removed subtree.
   1: 
   1:     nsViewManager *vm = child->GetViewManager();
   1:     if (vm->GetRootView() == child)
   1:     {
   1:       child->InvalidateHierarchy(GetViewManager());
   1:     }
   1:   }
   1: }
   1: 
   1: // Native widgets ultimately just can't deal with the awesome power of
   1: // CSS2 z-index. However, we set the z-index on the widget anyway
   1: // because in many simple common cases the widgets do end up in the
   1: // right order. We set each widget's z-index to the z-index of the
   1: // nearest ancestor that has non-auto z-index.
   1: static void UpdateNativeWidgetZIndexes(nsView* aView, PRInt32 aZIndex)
   1: {
   1:   if (aView->HasWidget()) {
   1:     nsIWidget* widget = aView->GetWidget();
   1:     PRInt32 curZ;
   1:     widget->GetZIndex(&curZ);
   1:     if (curZ != aZIndex) {
   1:       widget->SetZIndex(aZIndex);
   1:     }
   1:   } else {
   1:     for (nsView* v = aView->GetFirstChild(); v; v = v->GetNextSibling()) {
   1:       if (v->GetZIndexIsAuto()) {
   1:         UpdateNativeWidgetZIndexes(v, aZIndex);
   1:       }
   1:     }
   1:   }
   1: }
   1: 
   1: static PRInt32 FindNonAutoZIndex(nsView* aView)
   1: {
   1:   while (aView) {
   1:     if (!aView->GetZIndexIsAuto()) {
   1:       return aView->GetZIndex();
   1:     }
   1:     aView = aView->GetParent();
   1:   }
   1:   return 0;
   1: }
   1: 
   1: nsresult nsIView::CreateWidget(const nsIID &aWindowIID,
   1:                                nsWidgetInitData *aWidgetInitData,
   1:                                nsNativeWidget aNative,
   1:                                PRBool aEnableDragDrop,
   1:                                PRBool aResetVisibility,
   1:                                nsContentType aContentType)
   1: {
   1:   nsIDeviceContext  *dx;
   1:   nsRect            trect = mDimBounds;
   1: 
1413:   if (NS_UNLIKELY(mWindow)) {
1413:     NS_ERROR("We already have a window for this view? BAD");
1413:     ViewWrapper* wrapper = GetWrapperFor(mWindow);
1413:     NS_IF_RELEASE(wrapper);
1413:     mWindow->SetClientData(nsnull);
1413:     NS_RELEASE(mWindow);
1413:   }
   1: 
   1:   mViewManager->GetDeviceContext(dx);
   1:   float scale = 1.0f / dx->AppUnitsPerDevPixel();
   1: 
   1:   trect *= scale;
   1: 
   1:   nsView* v = NS_STATIC_CAST(nsView*, this);
   1:   if (NS_OK == v->LoadWidget(aWindowIID))
   1:   {
   1:     PRBool usewidgets;
   1: 
   1:     dx->SupportsNativeWidgets(usewidgets);
   1: 
   1:     if (PR_TRUE == usewidgets)
   1:     {
   1:       PRBool initDataPassedIn = PR_TRUE;
   1:       nsWidgetInitData initData;
   1:       if (!aWidgetInitData) {
   1:         // No initData, we're a child window
   1:         // Create initData to pass in params
   1:         initDataPassedIn = PR_FALSE;
   1:         initData.clipChildren = PR_TRUE; // Clip child window's children
   1:         initData.clipSiblings = PR_TRUE; // Clip child window's siblings
   1:         aWidgetInitData = &initData;
   1:       }
   1:       aWidgetInitData->mContentType = aContentType;
   1: 
   1:       if (aNative)
   1:         mWindow->Create(aNative, trect, ::HandleEvent, dx, nsnull, nsnull, aWidgetInitData);
   1:       else
   1:       {
   1:         if (!initDataPassedIn && GetParent() && 
   1:           GetParent()->GetViewManager() != mViewManager)
   1:           initData.mListenForResizes = PR_TRUE;
   1: 
   1:         nsPoint offset(0, 0);
   1:         nsIWidget* parentWidget = GetParent() ? GetParent()->GetNearestWidget(&offset)
   1:           : nsnull;
   1:         trect += offset;
   1:         if (aWidgetInitData->mWindowType == eWindowType_popup) {
   1:           // Without a parent, we can't make a popup.  This can happen
   1:           // when printing
   1:           if (!parentWidget)
   1:             return NS_ERROR_FAILURE;
   1:           mWindow->Create(parentWidget->GetNativeData(NS_NATIVE_WIDGET), trect,
   1:                           ::HandleEvent, dx, nsnull, nsnull, aWidgetInitData);
   1:         } else {
   1:           mWindow->Create(parentWidget, trect,
   1:                           ::HandleEvent, dx, nsnull, nsnull, aWidgetInitData);
   1:         }
   1:       }
   1:       if (aEnableDragDrop) {
   1:         mWindow->EnableDragDrop(PR_TRUE);
   1:       }
   1:       
   1:       // propagate the z-index to the widget.
   1:       UpdateNativeWidgetZIndexes(v, FindNonAutoZIndex(v));
   1:     }
   1:   }
   1: 
   1:   //make sure visibility state is accurate
   1:   
   1:   if (aResetVisibility) {
   1:     v->SetVisibility(GetVisibility());
   1:   }
   1: 
   1:   NS_RELEASE(dx);
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: void nsView::SetZIndex(PRBool aAuto, PRInt32 aZIndex, PRBool aTopMost)
   1: {
   1:   PRBool oldIsAuto = GetZIndexIsAuto();
   1:   mVFlags = (mVFlags & ~NS_VIEW_FLAG_AUTO_ZINDEX) | (aAuto ? NS_VIEW_FLAG_AUTO_ZINDEX : 0);
   1:   mZIndex = aZIndex;
   1:   SetTopMost(aTopMost);
   1:   
   1:   if (HasWidget() || !oldIsAuto || !aAuto) {
   1:     UpdateNativeWidgetZIndexes(this, FindNonAutoZIndex(this));
   1:   }
   1: }
   1: 
   1: NS_IMETHODIMP nsView::SetWidget(nsIWidget *aWidget)
   1: {
   1:   ViewWrapper* wrapper = new ViewWrapper(this);
   1:   if (!wrapper)
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   NS_ADDREF(wrapper); // Will be released in ~nsView or upon setting a new widget
   1: 
   1:   // Destroy any old wrappers if there are any
   1:   ViewWrapper* oldWrapper = GetWrapperFor(aWidget);
   1:   NS_IF_RELEASE(oldWrapper);
   1:   NS_IF_RELEASE(mWindow);
   1: 
   1:   mWindow = aWidget;
   1: 
   1:   if (nsnull != mWindow)
   1:   {
   1:     NS_ADDREF(mWindow);
   1:     mWindow->SetClientData(wrapper);
   1:   }
   1: 
   1:   mVFlags &= ~NS_VIEW_FLAG_HAS_POSITIONED_WIDGET;
   1: 
   1:   UpdateNativeWidgetZIndexes(this, FindNonAutoZIndex(this));
   1: 
   1:   return NS_OK;
   1: }
   1: 
   1: //
   1: // internal window creation functions
   1: //
   1: nsresult nsView::LoadWidget(const nsCID &aClassIID)
   1: {
   1:   ViewWrapper* wrapper = new ViewWrapper(this);
   1:   if (!wrapper)
   1:     return NS_ERROR_OUT_OF_MEMORY;
   1:   NS_ADDREF(wrapper); // Will be released in ~nsView
   1: 
   1:   nsresult rv = CallCreateInstance(aClassIID, &mWindow);
   1: 
   1:   if (NS_SUCCEEDED(rv)) {
   1:     // Set the widget's client data
   1:     mWindow->SetClientData(wrapper);
   1:   } else {
   1:     delete wrapper;
   1:   }
   1: 
   1:   mVFlags &= ~NS_VIEW_FLAG_HAS_POSITIONED_WIDGET;
   1:   return rv;
   1: }
   1: 
   1: #ifdef DEBUG
   1: void nsIView::List(FILE* out, PRInt32 aIndent) const
   1: {
   1:   PRInt32 i;
   1:   for (i = aIndent; --i >= 0; ) fputs("  ", out);
   1:   fprintf(out, "%p ", (void*)this);
   1:   if (nsnull != mWindow) {
   1:     nsRect windowBounds;
   1:     nsRect nonclientBounds;
   1:     float p2t;
   1:     nsIDeviceContext *dx;
   1:     mViewManager->GetDeviceContext(dx);
   1:     p2t = dx->AppUnitsPerDevPixel();
   1:     NS_RELEASE(dx);
   1:     mWindow->GetClientBounds(windowBounds);
   1:     windowBounds *= p2t;
   1:     mWindow->GetBounds(nonclientBounds);
   1:     nonclientBounds *= p2t;
   1:     nsrefcnt widgetRefCnt = mWindow->AddRef() - 1;
   1:     mWindow->Release();
   1:     PRInt32 Z;
   1:     mWindow->GetZIndex(&Z);
   1:     fprintf(out, "(widget=%p[%d] z=%d pos={%d,%d,%d,%d}) ",
   1:             (void*)mWindow, widgetRefCnt, Z,
   1:             nonclientBounds.x, nonclientBounds.y,
   1:             windowBounds.width, windowBounds.height);
   1:   }
   1:   nsRect brect = GetBounds();
   1:   fprintf(out, "{%d,%d,%d,%d}",
   1:           brect.x, brect.y, brect.width, brect.height);
   1:   const nsView* v = NS_STATIC_CAST(const nsView*, this);
   1:   if (v->IsZPlaceholderView()) {
   1:     fprintf(out, " z-placeholder(%p)",
   1:             (void*)NS_STATIC_CAST(const nsZPlaceholderView*, this)->GetReparentedView());
   1:   }
   1:   if (v->GetZParent()) {
   1:     fprintf(out, " zparent=%p", (void*)v->GetZParent());
   1:   }
   1:   fprintf(out, " z=%d vis=%d clientData=%p <\n",
   1:           mZIndex, mVis, mClientData);
   1:   for (nsView* kid = mFirstChild; kid; kid = kid->GetNextSibling()) {
   1:     NS_ASSERTION(kid->GetParent() == this, "incorrect parent");
   1:     kid->List(out, aIndent + 1);
   1:   }
   1:   for (i = aIndent; --i >= 0; ) fputs("  ", out);
   1:   fputs(">\n", out);
   1: }
   1: #endif // DEBUG
   1: 
   1: nsPoint nsIView::GetOffsetTo(const nsIView* aOther) const
   1: {
   1:   nsPoint offset(0, 0);
   1:   const nsIView* v;
   1:   for (v = this; v != aOther && v; v = v->GetParent()) {
   1:     offset += v->GetPosition();
   1:   }
   1: 
   1:   if (v != aOther) {
   1:     // Looks like aOther wasn't an ancestor of |this|.  So now we have
   1:     // the root-VM-relative position of |this| in |offset|.  Convert back
   1:     // to the coordinates of aOther
   1:     while (aOther) {
   1:       offset -= aOther->GetPosition();
   1:       aOther = aOther->GetParent();
   1:     }
   1:   }
   1: 
   1:   return offset;
   1: }
   1: 
   1: nsIntPoint nsIView::GetScreenPosition() const
   1: {
   1:   nsIntRect screenRect(0,0,0,0);  
   1:   nsPoint toWidgetOffset(0,0);
   1:   nsIWidget* widget = GetNearestWidget(&toWidgetOffset);
   1:   if (widget) {
   1:     nsCOMPtr<nsIDeviceContext> dx;
   1:     mViewManager->GetDeviceContext(*getter_AddRefs(dx));
   1:     PRInt32 p2a = dx->AppUnitsPerDevPixel();
   1:     nsIntRect ourRect(NSAppUnitsToIntPixels(toWidgetOffset.x, p2a),
   1:                       NSAppUnitsToIntPixels(toWidgetOffset.y, p2a),
   1:                       0,
   1:                       0);
   1:     widget->WidgetToScreen(ourRect, screenRect);
   1:   }
   1:   
   1:   return nsIntPoint(screenRect.x, screenRect.y);
   1: }
   1: 
   1: nsIWidget* nsIView::GetNearestWidget(nsPoint* aOffset) const
   1: {
   1:   nsPoint pt(0, 0);
   1:   const nsView* v;
   1:   for (v = NS_STATIC_CAST(const nsView*, this);
   1:        v && !v->HasWidget(); v = v->GetParent()) {
   1:     pt += v->GetPosition();
   1:   }
   1:   if (!v) {
   1:     if (aOffset) {
   1:       *aOffset = pt;
   1:     }
   1:     return NS_STATIC_CAST(const nsView*, this)->GetViewManager()->GetWidget();
   1:   }
   1: 
   1:   // pt is now the offset from v's origin to this's origin
   1:   // The widget's origin is the top left corner of v's bounds, which may
   1:   // not coincide with v's origin
   1:   if (aOffset) {
   1:     nsRect vBounds = v->GetBounds();
   1:     *aOffset = pt + v->GetPosition() -  nsPoint(vBounds.x, vBounds.y);
   1:   }
   1:   return v->GetWidget();
   1: }
   1: 
   1: PRBool nsIView::IsRoot() const
   1: {
   1:   NS_ASSERTION(mViewManager != nsnull," View manager is null in nsView::IsRoot()");
   1:   return mViewManager->GetRootView() == this;
   1: }
   1: 
   1: PRBool nsIView::ExternalIsRoot() const
   1: {
   1:   return nsIView::IsRoot();
   1: }
