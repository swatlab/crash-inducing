79608: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
42412: /* ***** BEGIN LICENSE BLOCK *****
42412:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42412:  *
42412:  * The contents of this file are subject to the Mozilla Public License Version
42412:  * 1.1 (the "License"); you may not use this file except in compliance with
42412:  * the License. You may obtain a copy of the License at
42412:  * http://www.mozilla.org/MPL/
42412:  *
42412:  * Software distributed under the License is distributed on an "AS IS" basis,
42412:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42412:  * for the specific language governing rights and limitations under the
42412:  * License.
42412:  *
42412:  * The Original Code is mozilla.org code.
42412:  *
42412:  * The Initial Developer of the Original Code is
79608:  * the Mozilla Foundation.
42412:  * Portions created by the Initial Developer are Copyright (C) 2010
42412:  * the Initial Developer. All Rights Reserved.
42412:  *
42412:  * Contributor(s):
79608:  *   Ms2ger <ms2ger@gmail.com>
42412:  *
42412:  * Alternatively, the contents of this file may be used under the terms of
42412:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42412:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42412:  * in which case the provisions of the GPL or the LGPL are applicable instead
42412:  * of those above. If you wish to allow use of your version of this file only
42412:  * under the terms of either the GPL or the LGPL, and not to allow others to
42412:  * use your version of this file under the terms of the MPL, indicate your
42412:  * decision by deleting the provisions above and replace them with the notice
42412:  * and other provisions required by the GPL or the LGPL. If you do not delete
42412:  * the provisions above, a recipient may use your version of this file under
42412:  * the terms of any one of the MPL, the GPL or the LGPL.
42412:  *
42412:  * ***** END LICENSE BLOCK ***** */
42412: 
51811: #include "ContentChild.h"
51811: #include "ContentParent.h"
42412: #include "nsFrameMessageManager.h"
42412: #include "nsContentUtils.h"
42412: #include "nsIXPConnect.h"
42412: #include "jsapi.h"
42412: #include "nsJSUtils.h"
91900: #include "nsJSPrincipals.h"
49304: #include "nsNetUtil.h"
49304: #include "nsScriptLoader.h"
49304: #include "nsIJSContextStack.h"
51811: #include "nsIXULRuntime.h"
69796: #include "nsIScriptError.h"
69796: #include "nsIConsoleService.h"
70078: #include "nsIProtocolHandler.h"
82978: #include "nsIScriptSecurityManager.h"
82978: #include "nsIJSRuntimeService.h"
82978: #include "xpcpublic.h"
51811: 
82109: #ifdef ANDROID
82109: #include <android/log.h>
82109: #endif
82109: 
79445: static bool
51811: IsChromeProcess()
51811: {
51811:   nsCOMPtr<nsIXULRuntime> rt = do_GetService("@mozilla.org/xre/runtime;1");
51828:   if (!rt)
80486:     return true;
51828: 
51811:   PRUint32 type;
51811:   rt->GetProcessType(&type);
51811:   return type == nsIXULRuntime::PROCESS_TYPE_DEFAULT;
51811: }
42412: 
42412: NS_IMPL_CYCLE_COLLECTION_CLASS(nsFrameMessageManager)
42412: 
42412: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsFrameMessageManager)
42412:   PRUint32 count = tmp->mListeners.Length();
42412:   for (PRUint32 i = 0; i < count; i++) {
42412:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mListeners[i] mListener");
42412:     cb.NoteXPCOMChild(tmp->mListeners[i].mListener.get());
42412:   }
42412:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mChildManagers)
42412: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
42412: 
42412: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsFrameMessageManager)
42412:   tmp->mListeners.Clear();
42412:   for (PRInt32 i = tmp->mChildManagers.Count(); i > 0; --i) {
42412:     static_cast<nsFrameMessageManager*>(tmp->mChildManagers[i - 1])->
80486:       Disconnect(false);
42412:   }
42412:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mChildManagers)
42412: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
42412: 
42412: 
42412: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsFrameMessageManager)
42412:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIContentFrameMessageManager)
43461:   NS_INTERFACE_MAP_ENTRY_AGGREGATED(nsIFrameMessageManager,
43461:                                     (mChrome ?
43461:                                        static_cast<nsIFrameMessageManager*>(
43461:                                          static_cast<nsIChromeFrameMessageManager*>(this)) :
43461:                                        static_cast<nsIFrameMessageManager*>(
43461:                                          static_cast<nsIContentFrameMessageManager*>(this))))
51811:   /* nsIContentFrameMessageManager is accessible only in TabChildGlobal. */
51811:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIContentFrameMessageManager,
51811:                                      !mChrome && !mIsProcessManager)
51811:   /* Message managers in child process support nsISyncMessageSender. */
51811:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsISyncMessageSender, !mChrome)
76841:   /* Message managers in chrome process support nsITreeItemFrameMessageManager. */
76841:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsITreeItemFrameMessageManager, mChrome)
51811:   /* Process message manager doesn't support nsIChromeFrameMessageManager. */
51811:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIChromeFrameMessageManager,
51811:                                      mChrome && !mIsProcessManager)
42412: NS_INTERFACE_MAP_END
42412: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsFrameMessageManager)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsFrameMessageManager)
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::AddMessageListener(const nsAString& aMessage,
42412:                                           nsIFrameMessageListener* aListener)
42412: {
42412:   nsCOMPtr<nsIAtom> message = do_GetAtom(aMessage);
42412:   PRUint32 len = mListeners.Length();
42412:   for (PRUint32 i = 0; i < len; ++i) {
42412:     if (mListeners[i].mMessage == message &&
42412:       mListeners[i].mListener == aListener) {
42412:       return NS_OK;
42412:     }
42412:   }
42412:   nsMessageListenerInfo* entry = mListeners.AppendElement();
42412:   NS_ENSURE_TRUE(entry, NS_ERROR_OUT_OF_MEMORY);
42412:   entry->mMessage = message;
42412:   entry->mListener = aListener;
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::RemoveMessageListener(const nsAString& aMessage,
42412:                                              nsIFrameMessageListener* aListener)
42412: {
42412:   nsCOMPtr<nsIAtom> message = do_GetAtom(aMessage);
42412:   PRUint32 len = mListeners.Length();
42412:   for (PRUint32 i = 0; i < len; ++i) {
42412:     if (mListeners[i].mMessage == message &&
42412:       mListeners[i].mListener == aListener) {
42412:       mListeners.RemoveElementAt(i);
42412:       return NS_OK;
42412:     }
42412:   }
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::LoadFrameScript(const nsAString& aURL,
79445:                                        bool aAllowDelayedLoad)
42412: {
43461:   if (aAllowDelayedLoad) {
43461:     if (IsGlobal() || IsWindowLevel()) {
43461:       // Cache for future windows or frames
43461:       mPendingScripts.AppendElement(aURL);
43461:     } else if (!mCallbackData) {
43461:       // We're frame message manager, which isn't connected yet.
42412:       mPendingScripts.AppendElement(aURL);
42412:       return NS_OK;
42412:     }
43461:   }
42412: 
42412:   if (mCallbackData) {
42412: #ifdef DEBUG_smaug
42412:     printf("Will load %s \n", NS_ConvertUTF16toUTF8(aURL).get());
42412: #endif
42412:     NS_ENSURE_TRUE(mLoadScriptCallback(mCallbackData, aURL), NS_ERROR_FAILURE);
42412:   }
42412: 
43461:   for (PRInt32 i = 0; i < mChildManagers.Count(); ++i) {
43461:     nsRefPtr<nsFrameMessageManager> mm =
43461:       static_cast<nsFrameMessageManager*>(mChildManagers[i]);
42412:     if (mm) {
80486:       // Use false here, so that child managers don't cache the script, which
43461:       // is already cached in the parent.
80486:       mm->LoadFrameScript(aURL, false);
42412:     }
42412:   }
42412:   return NS_OK;
42412: }
42412: 
77110: NS_IMETHODIMP
77110: nsFrameMessageManager::RemoveDelayedFrameScript(const nsAString& aURL)
77110: {
77110:   mPendingScripts.RemoveElement(aURL);
77110:   return NS_OK;
77110: }
77110: 
42412: static JSBool
42412: JSONCreator(const jschar* aBuf, uint32 aLen, void* aData)
42412: {
42412:   nsAString* result = static_cast<nsAString*>(aData);
79608:   result->Append(static_cast<const PRUnichar*>(aBuf),
79608:                  static_cast<PRUint32>(aLen));
79608:   return true;
42412: }
42412: 
79608: void
79608: nsFrameMessageManager::GetParamsForMessage(const jsval& aObject,
79608:                                            JSContext* aCx,
42412:                                            nsAString& aJSON)
42412: {
42412:   aJSON.Truncate();
79608:   JSAutoRequest ar(aCx);
79608:   jsval v = aObject;
79608:   JS_Stringify(aCx, &v, nsnull, JSVAL_NULL, JSONCreator, &aJSON);
42412: }
42412: 
42412: NS_IMETHODIMP
79608: nsFrameMessageManager::SendSyncMessage(const nsAString& aMessageName,
79608:                                        const jsval& aObject,
79608:                                        JSContext* aCx,
79608:                                        PRUint8 aArgc,
79608:                                        jsval* aRetval)
42412: {
43461:   NS_ASSERTION(!IsGlobal(), "Should not call SendSyncMessage in chrome");
43461:   NS_ASSERTION(!IsWindowLevel(), "Should not call SendSyncMessage in chrome");
43461:   NS_ASSERTION(!mParentManager, "Should not have parent manager in content!");
79608:   *aRetval = JSVAL_VOID;
42412:   if (mSyncCallback) {
42412:     NS_ENSURE_TRUE(mCallbackData, NS_ERROR_NOT_INITIALIZED);
42412:     nsString json;
79608:     if (aArgc >= 2) {
79608:       GetParamsForMessage(aObject, aCx, json);
79608:     }
57141:     InfallibleTArray<nsString> retval;
79608:     if (mSyncCallback(mCallbackData, aMessageName, json, &retval)) {
79608:       JSAutoRequest ar(aCx);
42412:       PRUint32 len = retval.Length();
79608:       JSObject* dataArray = JS_NewArrayObject(aCx, len, NULL);
42412:       NS_ENSURE_TRUE(dataArray, NS_ERROR_OUT_OF_MEMORY);
42412: 
42412:       for (PRUint32 i = 0; i < len; ++i) {
79608:         if (retval[i].IsEmpty()) {
47688:           continue;
79608:         }
47688: 
42412:         jsval ret = JSVAL_VOID;
79608:         if (!JS_ParseJSON(aCx, static_cast<const jschar*>(retval[i].get()),
79608:                           retval[i].Length(), &ret)) {
67923:           return NS_ERROR_UNEXPECTED;
67923:         }
79608:         NS_ENSURE_TRUE(JS_SetElement(aCx, dataArray, i, &ret), NS_ERROR_OUT_OF_MEMORY);
42412:       }
42412: 
79608:       *aRetval = OBJECT_TO_JSVAL(dataArray);
42412:     }
42412:   }
42412:   return NS_OK;
42412: }
42412: 
42412: nsresult
42412: nsFrameMessageManager::SendAsyncMessageInternal(const nsAString& aMessage,
42412:                                                 const nsAString& aJSON)
42412: {
42412:   if (mAsyncCallback) {
42412:     NS_ENSURE_TRUE(mCallbackData, NS_ERROR_NOT_INITIALIZED);
42412:     mAsyncCallback(mCallbackData, aMessage, aJSON);
42412:   }
42412:   PRInt32 len = mChildManagers.Count();
42412:   for (PRInt32 i = 0; i < len; ++i) {
42412:     static_cast<nsFrameMessageManager*>(mChildManagers[i])->
42412:       SendAsyncMessageInternal(aMessage, aJSON);
42412:   }
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
79608: nsFrameMessageManager::SendAsyncMessage(const nsAString& aMessageName,
79608:                                         const jsval& aObject,
79608:                                         JSContext* aCx,
79608:                                         PRUint8 aArgc)
42412: {
42412:   nsString json;
79608:   if (aArgc >= 2) {
79608:     GetParamsForMessage(aObject, aCx, json);
79608:   }
79608:   return SendAsyncMessageInternal(aMessageName, json);
42412: }
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::Dump(const nsAString& aStr)
42412: {
82109: #ifdef ANDROID
82109:   __android_log_print(ANDROID_LOG_INFO, "Gecko", NS_ConvertUTF16toUTF8(aStr).get());
82109: #endif
42412:   fputs(NS_ConvertUTF16toUTF8(aStr).get(), stdout);
42412:   fflush(stdout);
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
58164: nsFrameMessageManager::PrivateNoteIntentionalCrash()
58164: {
58164:   return NS_ERROR_NOT_IMPLEMENTED;
58164: }
58164: 
58164: NS_IMETHODIMP
42412: nsFrameMessageManager::GetContent(nsIDOMWindow** aContent)
42412: {
42412:   *aContent = nsnull;
42412:   return NS_OK;
42412: }
42412: 
42412: NS_IMETHODIMP
42412: nsFrameMessageManager::GetDocShell(nsIDocShell** aDocShell)
42412: {
42412:   *aDocShell = nsnull;
42412:   return NS_OK;
42412: }
42412: 
74412: NS_IMETHODIMP
76841: nsFrameMessageManager::GetChildCount(PRUint32* aChildCount)
76841: {
76841:   *aChildCount = static_cast<PRUint32>(mChildManagers.Count()); 
76841:   return NS_OK;
76841: }
76841: 
76841: NS_IMETHODIMP
76841: nsFrameMessageManager::GetChildAt(PRUint32 aIndex, 
76841:                                   nsITreeItemFrameMessageManager** aMM)
76841: {
76841:   *aMM = nsnull;
76841:   nsCOMPtr<nsITreeItemFrameMessageManager> mm =
76841:     do_QueryInterface(mChildManagers.SafeObjectAt(static_cast<PRUint32>(aIndex)));
76841:   mm.swap(*aMM);
76841:   return NS_OK;
76841: }
76841: 
76841: NS_IMETHODIMP
74412: nsFrameMessageManager::Btoa(const nsAString& aBinaryData,
74412:                             nsAString& aAsciiBase64String)
74412: {
74412:   return NS_OK;
74412: }
74412: 
74412: NS_IMETHODIMP
74412: nsFrameMessageManager::Atob(const nsAString& aAsciiString,
74412:                             nsAString& aBinaryData)
74412: {
74412:   return NS_OK;
74412: }
74412: 
86830: class MMListenerRemover
86830: {
86830: public:
86830:   MMListenerRemover(nsFrameMessageManager* aMM)
90479:     : mWasHandlingMessage(aMM->mHandlingMessage)
90479:     , mMM(aMM)
86830:   {
86830:     mMM->mHandlingMessage = true;
86830:   }
86830:   ~MMListenerRemover()
86830:   {
86830:     if (!mWasHandlingMessage) {
86830:       mMM->mHandlingMessage = false;
86830:       if (mMM->mDisconnected) {
86830:         mMM->mListeners.Clear();
86830:       }
86830:     }
86830:   }
86830: 
86830:   bool mWasHandlingMessage;
86830:   nsRefPtr<nsFrameMessageManager> mMM;
86830: };
86830: 
42412: nsresult
42412: nsFrameMessageManager::ReceiveMessage(nsISupports* aTarget,
42412:                                       const nsAString& aMessage,
79445:                                       bool aSync, const nsAString& aJSON,
42412:                                       JSObject* aObjectsArray,
57141:                                       InfallibleTArray<nsString>* aJSONRetVal,
43461:                                       JSContext* aContext)
42412: {
43461:   JSContext* ctx = mContext ? mContext : aContext;
51811:   if (!ctx) {
51811:     nsContentUtils::ThreadJSContextStack()->GetSafeJSContext(&ctx);
51811:   }
42412:   if (mListeners.Length()) {
42412:     nsCOMPtr<nsIAtom> name = do_GetAtom(aMessage);
86830:     MMListenerRemover lr(this);
42412: 
42412:     for (PRUint32 i = 0; i < mListeners.Length(); ++i) {
42412:       if (mListeners[i].mMessage == name) {
42412:         nsCOMPtr<nsIXPConnectWrappedJS> wrappedJS =
42412:           do_QueryInterface(mListeners[i].mListener);
42412:         if (!wrappedJS) {
42412:           continue;
42412:         }
42412:         JSObject* object = nsnull;
42412:         wrappedJS->GetJSObject(&object);
42412:         if (!object) {
42412:           continue;
42412:         }
42412:         nsCxPusher pusher;
80486:         NS_ENSURE_STATE(pusher.Push(ctx, false));
42412: 
43461:         JSAutoRequest ar(ctx);
42412: 
71060:         JSAutoEnterCompartment ac;
71060:         if (!ac.enter(ctx, object))
71060:           return NS_ERROR_FAILURE;
71060: 
42412:         // The parameter for the listener function.
43461:         JSObject* param = JS_NewObject(ctx, NULL, NULL, NULL);
42412:         NS_ENSURE_TRUE(param, NS_ERROR_OUT_OF_MEMORY);
42412: 
42412:         jsval targetv;
43461:         nsContentUtils::WrapNative(ctx,
71060:                                    JS_GetGlobalForObject(ctx, object),
80486:                                    aTarget, &targetv, nsnull, true);
42412: 
42412:         // To keep compatibility with e10s message manager,
42412:         // define empty objects array.
42412:         if (!aObjectsArray) {
42412:           // Because we want JS messages to have always the same properties,
42412:           // create array even if len == 0.
48553:           aObjectsArray = JS_NewArrayObject(ctx, 0, NULL);
42412:           if (!aObjectsArray) {
62917:             return NS_ERROR_OUT_OF_MEMORY;
42412:           }
42412:         }
42412: 
86989:         JS::AutoValueRooter objectsv(ctx);
72436:         objectsv.set(OBJECT_TO_JSVAL(aObjectsArray));
72436:         if (!JS_WrapValue(ctx, objectsv.jsval_addr()))
72436:             return NS_ERROR_UNEXPECTED;
72436: 
42412:         jsval json = JSVAL_NULL;
58977:         if (!aJSON.IsEmpty()) {
79608:           if (!JS_ParseJSON(ctx, static_cast<const jschar*>(PromiseFlatString(aJSON).get()),
79608:                             aJSON.Length(), &json)) {
42412:             json = JSVAL_NULL;
42412:           }
42412:         }
42412:         JSString* jsMessage =
43461:           JS_NewUCStringCopyN(ctx,
79608:                               static_cast<const jschar*>(PromiseFlatString(aMessage).get()),
42412:                               aMessage.Length());
42412:         NS_ENSURE_TRUE(jsMessage, NS_ERROR_OUT_OF_MEMORY);
43461:         JS_DefineProperty(ctx, param, "target", targetv, NULL, NULL, JSPROP_ENUMERATE);
43461:         JS_DefineProperty(ctx, param, "name",
42412:                           STRING_TO_JSVAL(jsMessage), NULL, NULL, JSPROP_ENUMERATE);
43461:         JS_DefineProperty(ctx, param, "sync",
42412:                           BOOLEAN_TO_JSVAL(aSync), NULL, NULL, JSPROP_ENUMERATE);
43461:         JS_DefineProperty(ctx, param, "json", json, NULL, NULL, JSPROP_ENUMERATE);
72436:         JS_DefineProperty(ctx, param, "objects", objectsv.jsval_value(), NULL, NULL, JSPROP_ENUMERATE);
42412: 
42412:         jsval thisValue = JSVAL_VOID;
42412: 
42412:         jsval funval = JSVAL_VOID;
74492:         if (JS_ObjectIsCallable(ctx, object)) {
42412:           // If the listener is a JS function:
42412:           funval = OBJECT_TO_JSVAL(object);
43461: 
43461:           // A small hack to get 'this' value right on content side where
43461:           // messageManager is wrapped in TabChildGlobal.
43461:           nsCOMPtr<nsISupports> defaultThisValue;
43461:           if (mChrome) {
77547:             defaultThisValue = do_QueryObject(this);
43461:           } else {
43461:             defaultThisValue = aTarget;
43461:           }
43461:           nsContentUtils::WrapNative(ctx,
71060:                                      JS_GetGlobalForObject(ctx, object),
80486:                                      defaultThisValue, &thisValue, nsnull, true);
42412:         } else {
42412:           // If the listener is a JS object which has receiveMessage function:
43461:           NS_ENSURE_STATE(JS_GetProperty(ctx, object, "receiveMessage",
42412:                                          &funval) &&
42412:                           JSVAL_IS_OBJECT(funval) &&
42412:                           !JSVAL_IS_NULL(funval));
42412:           JSObject* funobject = JSVAL_TO_OBJECT(funval);
74492:           NS_ENSURE_STATE(JS_ObjectIsCallable(ctx, funobject));
42412:           thisValue = OBJECT_TO_JSVAL(object);
42412:         }
42412: 
42412:         jsval rval = JSVAL_VOID;
42412: 
86989:         JS::AutoValueRooter argv(ctx);
48470:         argv.set(OBJECT_TO_JSVAL(param));
42412: 
55678:         {
55678:           JSAutoEnterCompartment tac;
55678: 
42412:           JSObject* thisObject = JSVAL_TO_OBJECT(thisValue);
55678: 
55678:           if (!tac.enter(ctx, thisObject) ||
71059:               !JS_WrapValue(ctx, argv.jsval_addr()))
55678:             return NS_ERROR_UNEXPECTED;
55678: 
43461:           JS_CallFunctionValue(ctx, thisObject,
48470:                                funval, 1, argv.jsval_addr(), &rval);
42412:           if (aJSONRetVal) {
42412:             nsString json;
73060:             if (JS_Stringify(ctx, &rval, nsnull, JSVAL_NULL,
42412:                              JSONCreator, &json)) {
42412:               aJSONRetVal->AppendElement(json);
42412:             }
42412:           }
42412:         }
42412:       }
42412:     }
55678:   }
71900:   nsRefPtr<nsFrameMessageManager> kungfuDeathGrip = mParentManager;
42412:   return mParentManager ? mParentManager->ReceiveMessage(aTarget, aMessage,
42412:                                                          aSync, aJSON, aObjectsArray,
43461:                                                          aJSONRetVal, mContext) : NS_OK;
42412: }
42412: 
42412: void
42412: nsFrameMessageManager::AddChildManager(nsFrameMessageManager* aManager,
79445:                                        bool aLoadScripts)
42412: {
42412:   mChildManagers.AppendObject(aManager);
42412:   if (aLoadScripts) {
43461:     nsRefPtr<nsFrameMessageManager> kungfuDeathGrip = this;
43461:     nsRefPtr<nsFrameMessageManager> kungfuDeathGrip2 = aManager;
43461:     // We have parent manager if we're a window message manager.
43461:     // In that case we want to load the pending scripts from global
43461:     // message manager.
43461:     if (mParentManager) {
43461:       nsRefPtr<nsFrameMessageManager> globalMM = mParentManager;
43461:       for (PRUint32 i = 0; i < globalMM->mPendingScripts.Length(); ++i) {
80486:         aManager->LoadFrameScript(globalMM->mPendingScripts[i], false);
43461:       }
43461:     }
42412:     for (PRUint32 i = 0; i < mPendingScripts.Length(); ++i) {
80486:       aManager->LoadFrameScript(mPendingScripts[i], false);
42412:     }
42412:   }
42412: }
42412: 
42412: void
79445: nsFrameMessageManager::SetCallbackData(void* aData, bool aLoadScripts)
42412: {
42412:   if (aData && mCallbackData != aData) {
42412:     mCallbackData = aData;
42412:     // First load global scripts by adding this to parent manager.
42412:     if (mParentManager) {
42412:       mParentManager->AddChildManager(this, aLoadScripts);
42412:     }
42412:     if (aLoadScripts) {
42412:       for (PRUint32 i = 0; i < mPendingScripts.Length(); ++i) {
80486:         LoadFrameScript(mPendingScripts[i], false);
42412:       }
42412:     }
42412:   }
42412: }
42412: 
42412: void
86831: nsFrameMessageManager::RemoveFromParent()
86831: {
86831:   if (mParentManager) {
86831:     mParentManager->RemoveChildManager(this);
86831:   }
86831:   mParentManager = nsnull;
86831:   mCallbackData = nsnull;
86831:   mContext = nsnull;
86831: }
86831: 
86831: void
79445: nsFrameMessageManager::Disconnect(bool aRemoveFromParent)
42412: {
42412:   if (mParentManager && aRemoveFromParent) {
42412:     mParentManager->RemoveChildManager(this);
42412:   }
86830:   mDisconnected = true;
42412:   mParentManager = nsnull;
42412:   mCallbackData = nsnull;
43461:   mContext = nsnull;
86830:   if (!mHandlingMessage) {
86830:     mListeners.Clear();
86830:   }
42412: }
43461: 
43461: nsresult
43461: NS_NewGlobalMessageManager(nsIChromeFrameMessageManager** aResult)
43461: {
51811:   NS_ENSURE_TRUE(IsChromeProcess(), NS_ERROR_NOT_AVAILABLE);
80486:   nsFrameMessageManager* mm = new nsFrameMessageManager(true,
43461:                                                         nsnull,
43461:                                                         nsnull,
43461:                                                         nsnull,
43461:                                                         nsnull,
43461:                                                         nsnull,
43461:                                                         nsnull,
80486:                                                         true);
43461:   NS_ENSURE_TRUE(mm, NS_ERROR_OUT_OF_MEMORY);
43461:   return CallQueryInterface(mm, aResult);
43461: }
49304: 
69796: void
69796: ContentScriptErrorReporter(JSContext* aCx,
69796:                            const char* aMessage,
69796:                            JSErrorReport* aReport)
69796: {
69796:   nsresult rv;
69796:   nsCOMPtr<nsIScriptError> scriptError =
69796:       do_CreateInstance(NS_SCRIPTERROR_CONTRACTID, &rv);
69796:   if (NS_FAILED(rv)) {
69796:     return;
69796:   }
69796:   nsAutoString message, filename, line;
69796:   PRUint32 lineNumber, columnNumber, flags, errorNumber;
69796: 
69796:   if (aReport) {
69796:     if (aReport->ucmessage) {
69796:       message.Assign(reinterpret_cast<const PRUnichar*>(aReport->ucmessage));
69796:     }
69796:     filename.AssignWithConversion(aReport->filename);
69796:     line.Assign(reinterpret_cast<const PRUnichar*>(aReport->uclinebuf));
69796:     lineNumber = aReport->lineno;
69796:     columnNumber = aReport->uctokenptr - aReport->uclinebuf;
69796:     flags = aReport->flags;
69796:     errorNumber = aReport->errorNumber;
69796:   } else {
69796:     lineNumber = columnNumber = errorNumber = 0;
69796:     flags = nsIScriptError::errorFlag | nsIScriptError::exceptionFlag;
69796:   }
69796: 
69796:   if (message.IsEmpty()) {
69796:     message.AssignWithConversion(aMessage);
69796:   }
69796: 
69796:   rv = scriptError->Init(message.get(), filename.get(), line.get(),
69796:                          lineNumber, columnNumber, flags,
69796:                          "Message manager content script");
69796:   if (NS_FAILED(rv)) {
69796:     return;
69796:   }
69796: 
69796:   nsCOMPtr<nsIConsoleService> consoleService =
69796:       do_GetService(NS_CONSOLESERVICE_CONTRACTID);
69796:   if (consoleService) {
69796:     (void) consoleService->LogMessage(scriptError);
69796:   }
74348: 
74348: #ifdef DEBUG
74348:   // Print it to stderr as well, for the benefit of those invoking
74348:   // mozilla with -console.
74348:   nsCAutoString error;
74348:   error.Assign("JavaScript ");
74348:   if (JSREPORT_IS_STRICT(flags)) {
74348:     error.Append("strict ");
74348:   }
74348:   if (JSREPORT_IS_WARNING(flags)) {
74348:     error.Append("warning: ");
74348:   } else {
74348:     error.Append("error: ");
74348:   }
74348:   error.Append(aReport->filename);
74348:   error.Append(", line ");
74348:   error.AppendInt(lineNumber, 10);
74348:   error.Append(": ");
74348:   if (aReport->ucmessage) {
74348:     AppendUTF16toUTF8(reinterpret_cast<const PRUnichar*>(aReport->ucmessage),
74348:                       error);
74348:   } else {
74348:     error.Append(aMessage);
74348:   }
74348: 
74348:   fprintf(stderr, "%s\n", error.get());
74348:   fflush(stderr);
74348: #endif
69796: }
69796: 
78492: nsDataHashtable<nsStringHashKey, nsFrameJSScriptExecutorHolder*>*
49304:   nsFrameScriptExecutor::sCachedScripts = nsnull;
50684: nsRefPtr<nsScriptCacheCleaner> nsFrameScriptExecutor::sScriptCacheCleaner;
49304: 
49304: void
49304: nsFrameScriptExecutor::DidCreateCx()
49304: {
49304:   NS_ASSERTION(mCx, "Should have mCx!");
49304:   if (!sCachedScripts) {
49304:     sCachedScripts =
78492:       new nsDataHashtable<nsStringHashKey, nsFrameJSScriptExecutorHolder*>;
49304:     sCachedScripts->Init();
50684: 
50684:     sScriptCacheCleaner = new nsScriptCacheCleaner();
49304:   }
49304: }
49304: 
49304: void
49304: nsFrameScriptExecutor::DestroyCx()
49304: {
71900:   if (mCxStackRefCnt) {
80486:     mDelayedCxDestroy = true;
71900:     return;
71900:   }
80486:   mDelayedCxDestroy = false;
71900:   if (mCx) {
49304:     nsIXPConnect* xpc = nsContentUtils::XPConnect();
49304:     if (xpc) {
80486:       xpc->ReleaseJSContext(mCx, true);
49304:     } else {
49304:       JS_DestroyContext(mCx);
49304:     }
71900:   }
49304:   mCx = nsnull;
51259:   mGlobal = nsnull;
49304: }
49304: 
49304: static PLDHashOperator
49304: CachedScriptUnrooter(const nsAString& aKey,
78492:                        nsFrameJSScriptExecutorHolder*& aData,
49304:                        void* aUserArg)
49304: {
49304:   JSContext* cx = static_cast<JSContext*>(aUserArg);
78492:   JS_RemoveScriptRoot(cx, &(aData->mScript));
61117:   delete aData;
49304:   return PL_DHASH_REMOVE;
49304: }
49304: 
49304: // static
49304: void
49304: nsFrameScriptExecutor::Shutdown()
49304: {
49304:   if (sCachedScripts) {
49304:     JSContext* cx = nsnull;
49304:     nsContentUtils::ThreadJSContextStack()->GetSafeJSContext(&cx);
49304:     if (cx) {
49304: #ifdef DEBUG_smaug
49304:       printf("Will clear cached frame manager scripts!\n");
49304: #endif
49304:       JSAutoRequest ar(cx);
49304:       NS_ASSERTION(sCachedScripts != nsnull, "Need cached scripts");
49304:       sCachedScripts->Enumerate(CachedScriptUnrooter, cx);
49304:     } else {
49304:       NS_WARNING("No context available. Leaking cached scripts!\n");
49304:     }
49304: 
49304:     delete sCachedScripts;
49304:     sCachedScripts = nsnull;
50684: 
50684:     sScriptCacheCleaner = nsnull;
49304:   }
49304: }
49304: 
49304: void
49304: nsFrameScriptExecutor::LoadFrameScriptInternal(const nsAString& aURL)
49304: {
63116:   if (!mGlobal || !mCx || !sCachedScripts) {
49304:     return;
49304:   }
49304: 
78492:   nsFrameJSScriptExecutorHolder* holder = sCachedScripts->Get(aURL);
49304:   if (holder) {
49304:     nsContentUtils::ThreadJSContextStack()->Push(mCx);
49304:     {
49304:       // Need to scope JSAutoRequest to happen after Push but before Pop,
49304:       // at least for now. See bug 584673.
49304:       JSAutoRequest ar(mCx);
49304:       JSObject* global = nsnull;
49304:       mGlobal->GetJSObject(&global);
49304:       if (global) {
78492:         (void) JS_ExecuteScript(mCx, global, holder->mScript, nsnull);
49304:       }
49304:     }
49304:     JSContext* unused;
49304:     nsContentUtils::ThreadJSContextStack()->Pop(&unused);
49304:     return;
49304:   }
49304: 
49304:   nsCString url = NS_ConvertUTF16toUTF8(aURL);
49304:   nsCOMPtr<nsIURI> uri;
49304:   nsresult rv = NS_NewURI(getter_AddRefs(uri), url);
49304:   if (NS_FAILED(rv)) {
49304:     return;
49304:   }
70078:   
79445:   bool hasFlags;
70078:   rv = NS_URIChainHasFlags(uri,
70078:                            nsIProtocolHandler::URI_IS_LOCAL_RESOURCE,
70078:                            &hasFlags);
70078:   if (NS_FAILED(rv) || !hasFlags) {
70078:     NS_WARNING("Will not load a frame script!");
70078:     return;
70078:   }
70078:   
49304:   nsCOMPtr<nsIChannel> channel;
49304:   NS_NewChannel(getter_AddRefs(channel), uri);
49304:   if (!channel) {
49304:     return;
49304:   }
49304: 
49304:   nsCOMPtr<nsIInputStream> input;
49304:   channel->Open(getter_AddRefs(input));
49304:   nsString dataString;
49304:   PRUint32 avail = 0;
67591:   if (input && NS_SUCCEEDED(input->Available(&avail)) && avail) {
67591:     nsCString buffer;
67591:     if (NS_FAILED(NS_ReadInputStreamToString(input, buffer, avail))) {
67591:       return;
49304:     }
67591:     nsScriptLoader::ConvertToUTF16(channel, (PRUint8*)buffer.get(), avail,
49304:                                    EmptyString(), nsnull, dataString);
49304:   }
49304: 
49304:   if (!dataString.IsEmpty()) {
49304:     nsContentUtils::ThreadJSContextStack()->Push(mCx);
49304:     {
49304:       // Need to scope JSAutoRequest to happen after Push but before Pop,
49304:       // at least for now. See bug 584673.
49304:       JSAutoRequest ar(mCx);
49304:       JSObject* global = nsnull;
49304:       mGlobal->GetJSObject(&global);
94638:       JSAutoEnterCompartment ac;
94638:       if (global && ac.enter(mCx, global)) {
63927:         uint32 oldopts = JS_GetOptions(mCx);
63927:         JS_SetOptions(mCx, oldopts | JSOPTION_NO_SCRIPT_RVAL);
63927: 
78492:         JSScript* script =
91900:           JS_CompileUCScriptForPrincipals(mCx, nsnull,
91900:                                           nsJSPrincipals::get(mPrincipal),
91900:                                           static_cast<const jschar*>(dataString.get()),
49304:                                           dataString.Length(),
49304:                                           url.get(), 1);
49304: 
63927:         JS_SetOptions(mCx, oldopts);
63927: 
78492:         if (script) {
49304:           nsCAutoString scheme;
49304:           uri->GetScheme(scheme);
49304:           // We don't cache data: scripts!
49304:           if (!scheme.EqualsLiteral("data")) {
78492:             nsFrameJSScriptExecutorHolder* holder =
78492:               new nsFrameJSScriptExecutorHolder(script);
49304:             // Root the object also for caching.
78492:             JS_AddNamedScriptRoot(mCx, &(holder->mScript),
49304:                                   "Cached message manager script");
49304:             sCachedScripts->Put(aURL, holder);
49304:           }
78492:           (void) JS_ExecuteScript(mCx, global, script, nsnull);
49304:         }
49304:       }
49304:     } 
49304:     JSContext* unused;
49304:     nsContentUtils::ThreadJSContextStack()->Pop(&unused);
49304:   }
49304: }
50684: 
82978: bool
82978: nsFrameScriptExecutor::InitTabChildGlobalInternal(nsISupports* aScope)
82978: {
82978:   
82978:   nsCOMPtr<nsIJSRuntimeService> runtimeSvc = 
82978:     do_GetService("@mozilla.org/js/xpc/RuntimeService;1");
82978:   NS_ENSURE_TRUE(runtimeSvc, false);
82978: 
82978:   JSRuntime* rt = nsnull;
82978:   runtimeSvc->GetRuntime(&rt);
82978:   NS_ENSURE_TRUE(rt, false);
82978: 
82978:   JSContext* cx = JS_NewContext(rt, 8192);
82978:   NS_ENSURE_TRUE(cx, false);
82978: 
82978:   mCx = cx;
82978: 
82978:   nsContentUtils::GetSecurityManager()->GetSystemPrincipal(getter_AddRefs(mPrincipal));
82978: 
82978:   JS_SetOptions(cx, JS_GetOptions(cx) | JSOPTION_PRIVATE_IS_NSISUPPORTS);
82978:   JS_SetVersion(cx, JSVERSION_LATEST);
82978:   JS_SetErrorReporter(cx, ContentScriptErrorReporter);
82978: 
82978:   xpc_LocalizeContext(cx);
82978: 
82978:   JSAutoRequest ar(cx);
82978:   nsIXPConnect* xpc = nsContentUtils::XPConnect();
82978:   const PRUint32 flags = nsIXPConnect::INIT_JS_STANDARD_CLASSES |
82978:                          nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT;
82978: 
82978:   
82978:   JS_SetContextPrivate(cx, aScope);
82978: 
82978:   nsresult rv =
91577:     xpc->InitClassesWithNewWrappedGlobal(cx, aScope, mPrincipal,
82978:                                          flags, getter_AddRefs(mGlobal));
82978:   NS_ENSURE_SUCCESS(rv, false);
82978: 
82978:     
82978:   JSObject* global = nsnull;
82978:   rv = mGlobal->GetJSObject(&global);
82978:   NS_ENSURE_SUCCESS(rv, false);
82978: 
82978:   JS_SetGlobalObject(cx, global);
82978:   DidCreateCx();
82978:   return true;
82978: }
82978: 
61808: // static
61808: void
61808: nsFrameScriptExecutor::Traverse(nsFrameScriptExecutor *tmp,
61808:                                 nsCycleCollectionTraversalCallback &cb)
61808: {
61808:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mGlobal)
61808:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mCx");
61808:   nsContentUtils::XPConnect()->NoteJSContext(tmp->mCx, cb);
61808: }
61808: 
51344: NS_IMPL_ISUPPORTS1(nsScriptCacheCleaner, nsIObserver)
50684: 
51811: nsFrameMessageManager* nsFrameMessageManager::sChildProcessManager = nsnull;
51811: nsFrameMessageManager* nsFrameMessageManager::sParentProcessManager = nsnull;
80180: nsFrameMessageManager* nsFrameMessageManager::sSameProcessParentManager = nsnull;
80180: nsTArray<nsCOMPtr<nsIRunnable> >* nsFrameMessageManager::sPendingSameProcessAsyncMessages = nsnull;
51811: 
51811: bool SendAsyncMessageToChildProcess(void* aCallbackData,
51811:                                     const nsAString& aMessage,
51811:                                     const nsAString& aJSON)
51811: {
51811:   mozilla::dom::ContentParent* cp =
76841:     static_cast<mozilla::dom::ContentParent*>(aCallbackData);
51811:   NS_WARN_IF_FALSE(cp, "No child process!");
51811:   if (cp) {
51811:     return cp->SendAsyncMessage(nsString(aMessage), nsString(aJSON));
51811:   }
51811:   return true;
51811: }
51811: 
80180: class nsAsyncMessageToSameProcessChild : public nsRunnable
80180: {
80180: public:
80180:   nsAsyncMessageToSameProcessChild(const nsAString& aMessage, const nsAString& aJSON)
80180:     : mMessage(aMessage), mJSON(aJSON) {}
80180: 
80180:   NS_IMETHOD Run()
80180:   {
80180:     if (nsFrameMessageManager::sChildProcessManager) {
80180:       nsRefPtr<nsFrameMessageManager> ppm = nsFrameMessageManager::sChildProcessManager;
80180:       ppm->ReceiveMessage(static_cast<nsIContentFrameMessageManager*>(ppm.get()), mMessage,
80486:                           false, mJSON, nsnull, nsnull);
80180:     }
80180:     return NS_OK;
80180:   }
80180:   nsString mMessage;
80180:   nsString mJSON;
80180: };
80180: 
80180: bool SendAsyncMessageToSameProcessChild(void* aCallbackData,
80180:                                         const nsAString& aMessage,
80180:                                         const nsAString& aJSON)
80180: {
80180:   nsRefPtr<nsIRunnable> ev =
80180:     new nsAsyncMessageToSameProcessChild(aMessage, aJSON);
80180:   NS_DispatchToCurrentThread(ev);
80180:   return true;
80180: }
80180: 
51811: bool SendSyncMessageToParentProcess(void* aCallbackData,
51811:                                     const nsAString& aMessage,
51811:                                     const nsAString& aJSON,
57141:                                     InfallibleTArray<nsString>* aJSONRetVal)
51811: {
51811:   mozilla::dom::ContentChild* cc =
51811:     mozilla::dom::ContentChild::GetSingleton();
51811:   if (cc) {
51811:     return
51811:       cc->SendSyncMessage(nsString(aMessage), nsString(aJSON), aJSONRetVal);
51811:   }
51811:   return true;
51811: }
51811: 
80180: bool SendSyncMessageToSameProcessParent(void* aCallbackData,
80180:                                         const nsAString& aMessage,
80180:                                         const nsAString& aJSON,
80180:                                         InfallibleTArray<nsString>* aJSONRetVal)
80180: {
80180:   nsTArray<nsCOMPtr<nsIRunnable> > asyncMessages;
80180:   if (nsFrameMessageManager::sPendingSameProcessAsyncMessages) {
80180:     asyncMessages.SwapElements(*nsFrameMessageManager::sPendingSameProcessAsyncMessages);
80180:     PRUint32 len = asyncMessages.Length();
80180:     for (PRUint32 i = 0; i < len; ++i) {
80180:       nsCOMPtr<nsIRunnable> async = asyncMessages[i];
80180:       async->Run();
80180:     }
80180:   }
80180:   if (nsFrameMessageManager::sSameProcessParentManager) {
80180:     nsRefPtr<nsFrameMessageManager> ppm = nsFrameMessageManager::sSameProcessParentManager;
80180:     ppm->ReceiveMessage(static_cast<nsIContentFrameMessageManager*>(ppm.get()), aMessage,
80486:                         true, aJSON, nsnull, aJSONRetVal);
80180:   }
80180:   return true;
80180: }
80180: 
51811: bool SendAsyncMessageToParentProcess(void* aCallbackData,
51811:                                      const nsAString& aMessage,
51811:                                      const nsAString& aJSON)
51811: {
51811:   mozilla::dom::ContentChild* cc =
51811:     mozilla::dom::ContentChild::GetSingleton();
51811:   if (cc) {
51811:     return cc->SendAsyncMessage(nsString(aMessage), nsString(aJSON));
51811:   }
51811:   return true;
51811: }
51811: 
80180: class nsAsyncMessageToSameProcessParent : public nsRunnable
80180: {
80180: public:
80180:   nsAsyncMessageToSameProcessParent(const nsAString& aMessage, const nsAString& aJSON)
80180:     : mMessage(aMessage), mJSON(aJSON) {}
80180: 
80180:   NS_IMETHOD Run()
80180:   {
80180:     if (nsFrameMessageManager::sPendingSameProcessAsyncMessages) {
80180:       nsFrameMessageManager::sPendingSameProcessAsyncMessages->RemoveElement(this);
80180:     }
80180:     if (nsFrameMessageManager::sSameProcessParentManager) {
80180:       nsRefPtr<nsFrameMessageManager> ppm = nsFrameMessageManager::sSameProcessParentManager;
80486:       ppm->ReceiveMessage(static_cast<nsIContentFrameMessageManager*>(ppm.get()), mMessage, false,
80180:                           mJSON, nsnull, nsnull);
80180:     }
80180:     return NS_OK;
80180:   }
80180:   nsString mMessage;
80180:   nsString mJSON;
80180: };
80180: 
80180: bool SendAsyncMessageToSameProcessParent(void* aCallbackData,
80180:                                          const nsAString& aMessage,
80180:                                          const nsAString& aJSON)
80180: {
80180:   if (!nsFrameMessageManager::sPendingSameProcessAsyncMessages) {
80180:     nsFrameMessageManager::sPendingSameProcessAsyncMessages = new nsTArray<nsCOMPtr<nsIRunnable> >;
80180:   }
80180:   nsCOMPtr<nsIRunnable> ev =
80180:     new nsAsyncMessageToSameProcessParent(aMessage, aJSON);
80180:   nsFrameMessageManager::sPendingSameProcessAsyncMessages->AppendElement(ev);
80180:   NS_DispatchToCurrentThread(ev);
80180:   return true;
80180: }
80180: 
76841: // This creates the global parent process message manager.
51811: nsresult
51811: NS_NewParentProcessMessageManager(nsIFrameMessageManager** aResult)
51811: {
51811:   NS_ASSERTION(!nsFrameMessageManager::sParentProcessManager,
51811:                "Re-creating sParentProcessManager");
51811:   NS_ENSURE_TRUE(IsChromeProcess(), NS_ERROR_NOT_AVAILABLE);
80486:   nsRefPtr<nsFrameMessageManager> mm = new nsFrameMessageManager(true,
51811:                                                                  nsnull,
51811:                                                                  nsnull,
76841:                                                                  nsnull,
76841:                                                                  nsnull,
51811:                                                                  nsnull,
51811:                                                                  nsnull,
80486:                                                                  false,
80486:                                                                  true);
51811:   NS_ENSURE_TRUE(mm, NS_ERROR_OUT_OF_MEMORY);
51811:   nsFrameMessageManager::sParentProcessManager = mm;
80180:   nsFrameMessageManager::NewProcessMessageManager(nsnull); // Create same process message manager.
51811:   return CallQueryInterface(mm, aResult);
51811: }
51811: 
76841: nsFrameMessageManager*
76841: nsFrameMessageManager::NewProcessMessageManager(mozilla::dom::ContentParent* aProcess)
76841: {
76841:   if (!nsFrameMessageManager::sParentProcessManager) {
76841:      nsCOMPtr<nsIFrameMessageManager> dummy;
76841:      NS_NewParentProcessMessageManager(getter_AddRefs(dummy));
76841:   }
76841: 
80486:   nsFrameMessageManager* mm = new nsFrameMessageManager(true,
76841:                                                         nsnull,
80180:                                                         aProcess ? SendAsyncMessageToChildProcess
80180:                                                                  : SendAsyncMessageToSameProcessChild,
76841:                                                         nsnull,
80180:                                                         aProcess ? static_cast<void*>(aProcess)
80180:                                                                  : static_cast<void*>(&nsFrameMessageManager::sChildProcessManager),
76841:                                                         nsFrameMessageManager::sParentProcessManager,
76841:                                                         nsnull,
80486:                                                         false,
80486:                                                         true);
80180:   if (!aProcess) {
80180:     sSameProcessParentManager = mm;
80180:   }
76841:   return mm;
76841: }
51811: 
51811: nsresult
51811: NS_NewChildProcessMessageManager(nsISyncMessageSender** aResult)
51811: {
51811:   NS_ASSERTION(!nsFrameMessageManager::sChildProcessManager,
51811:                "Re-creating sChildProcessManager");
90092:   bool isChrome = IsChromeProcess();
80486:   nsFrameMessageManager* mm = new nsFrameMessageManager(false,
80180:                                                         isChrome ? SendSyncMessageToSameProcessParent
80180:                                                                  : SendSyncMessageToParentProcess,
80180:                                                         isChrome ? SendAsyncMessageToSameProcessParent
80180:                                                                  : SendAsyncMessageToParentProcess,
51811:                                                         nsnull,
51811:                                                         &nsFrameMessageManager::sChildProcessManager,
51811:                                                         nsnull,
51811:                                                         nsnull,
80486:                                                         false,
80486:                                                         true);
51811:   NS_ENSURE_TRUE(mm, NS_ERROR_OUT_OF_MEMORY);
51811:   nsFrameMessageManager::sChildProcessManager = mm;
51811:   return CallQueryInterface(mm, aResult);
51811: }
88266: 
88266: bool
88266: nsFrameMessageManager::MarkForCC()
88266: {
88266:   PRUint32 len = mListeners.Length();
88266:   for (PRUint32 i = 0; i < len; ++i) {
94338:     xpc_TryUnmarkWrappedGrayObject(mListeners[i].mListener);
88266:   }
88266:   return true;
88266: }
