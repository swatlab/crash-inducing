31481: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
31481:  * vim: set ts=8 sw=4 et tw=79:
31481:  *
31481:  * ***** BEGIN LICENSE BLOCK *****
31481:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
31481:  *
31481:  * The contents of this file are subject to the Mozilla Public License Version
31481:  * 1.1 (the "License"); you may not use this file except in compliance with
31481:  * the License. You may obtain a copy of the License at
31481:  * http://www.mozilla.org/MPL/
31481:  *
31481:  * Software distributed under the License is distributed on an "AS IS" basis,
31481:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
31481:  * for the specific language governing rights and limitations under the
31481:  * License.
31481:  *
31481:  * The Original Code is Mozilla Communicator client code, released
31481:  * March 31, 1998.
31481:  *
31481:  * The Initial Developer of the Original Code is
31481:  * Netscape Communications Corporation.
31481:  * Portions created by the Initial Developer are Copyright (C) 1998
31481:  * the Initial Developer. All Rights Reserved.
31481:  *
31481:  * Contributor(s):
31481:  *
31481:  * Alternatively, the contents of this file may be used under the terms of
31481:  * either of the GNU General Public License Version 2 or later (the "GPL"),
31481:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
31481:  * in which case the provisions of the GPL or the LGPL are applicable instead
31481:  * of those above. If you wish to allow use of your version of this file only
31481:  * under the terms of either the GPL or the LGPL, and not to allow others to
31481:  * use your version of this file under the terms of the MPL, indicate your
31481:  * decision by deleting the provisions above and replace them with the notice
31481:  * and other provisions required by the GPL or the LGPL. If you do not delete
31481:  * the provisions above, a recipient may use your version of this file under
31481:  * the terms of any one of the MPL, the GPL or the LGPL.
31481:  *
31481:  * ***** END LICENSE BLOCK ***** */
31481: 
31481: /* This file needs to be included in possibly multiple places. */
31481: 
31481: #if JS_THREADED_INTERP
31481:   interrupt:
31481: #else /* !JS_THREADED_INTERP */
31481:   case -1:
31481:     JS_ASSERT(switchMask == -1);
31481: #endif /* !JS_THREADED_INTERP */
31481:     {
31481:         bool moreInterrupts = false;
31481:         JSTrapHandler handler = cx->debugHooks->interruptHandler;
31481:         if (handler) {
31481: #ifdef JS_TRACER
31481:             if (TRACE_RECORDER(cx))
37741:                 AbortRecording(cx, "interrupt handler");
31481: #endif
31481:             switch (handler(cx, script, regs.pc, &rval,
31481:                             cx->debugHooks->interruptHandlerData)) {
31481:               case JSTRAP_ERROR:
31481:                 goto error;
31481:               case JSTRAP_CONTINUE:
31481:                 break;
31481:               case JSTRAP_RETURN:
31481:                 fp->rval = rval;
31481:                 ok = JS_TRUE;
31481:                 goto forced_return;
31481:               case JSTRAP_THROW:
31481:                 cx->throwing = JS_TRUE;
31481:                 cx->exception = rval;
31481:                 goto error;
31481:               default:;
31481:             }
31481:             moreInterrupts = true;
31481:         }
31481: 
31481: #ifdef JS_TRACER
35083:         if (TraceRecorder* tr = TRACE_RECORDER(cx)) {
35083:             AbortableRecordingStatus status = tr->monitorRecording(op);
41777:             JS_ASSERT_IF(cx->throwing, status == ARECORD_ERROR);
31481:             switch (status) {
33542:               case ARECORD_CONTINUE:
31481:                 moreInterrupts = true;
31481:                 break;
33542:               case ARECORD_IMACRO:
31481:                 atoms = COMMON_ATOMS_START(&rt->atomState);
31481:                 op = JSOp(*regs.pc);
31481:                 DO_OP();    /* keep interrupting for op. */
31481:                 break;
33542:               case ARECORD_ERROR:
31481:                 // The code at 'error:' aborts the recording.
31481:                 goto error;
33542:               case ARECORD_ABORTED:
35083:               case ARECORD_COMPLETED:
31481:                 break;
33542:               case ARECORD_STOP:
33542:                 /* A 'stop' error should have already aborted recording. */
31481:               default:
31481:                 JS_NOT_REACHED("Bad recording status");
31481:             }
31481:         }
31481: #endif /* !JS_TRACER */
31481: 
31481: #if JS_THREADED_INTERP
31481: #ifdef MOZ_TRACEVIS
31481:         if (!moreInterrupts)
38585:             ExitTraceVisState(cx, R_ABORT);
31481: #endif
31481:         jumpTable = moreInterrupts ? interruptJumpTable : normalJumpTable;
31481:         JS_EXTENSION_(goto *normalJumpTable[op]);
31481: #else
31481:         switchMask = moreInterrupts ? -1 : 0;
31481:         switchOp = intN(op);
31481:         goto do_switch;
31481: #endif
31481:     }
31481: 
31481: /* No-ops for ease of decompilation. */
31481: ADD_EMPTY_CASE(JSOP_NOP)
31481: ADD_EMPTY_CASE(JSOP_CONDSWITCH)
31481: ADD_EMPTY_CASE(JSOP_TRY)
32776: ADD_EMPTY_CASE(JSOP_TRACE)
31481: #if JS_HAS_XML_SUPPORT
31481: ADD_EMPTY_CASE(JSOP_STARTXML)
31481: ADD_EMPTY_CASE(JSOP_STARTXMLEXPR)
31481: #endif
31481: END_EMPTY_CASES
31481: 
31481: /* ADD_EMPTY_CASE is not used here as JSOP_LINENO_LENGTH == 3. */
31481: BEGIN_CASE(JSOP_LINENO)
31481: END_CASE(JSOP_LINENO)
31481: 
31481: BEGIN_CASE(JSOP_PUSH)
31481:     PUSH_OPND(JSVAL_VOID);
31481: END_CASE(JSOP_PUSH)
31481: 
31481: BEGIN_CASE(JSOP_POP)
31481:     regs.sp--;
31481: END_CASE(JSOP_POP)
31481: 
31481: BEGIN_CASE(JSOP_POPN)
31481:     regs.sp -= GET_UINT16(regs.pc);
31481: #ifdef DEBUG
31481:     JS_ASSERT(StackBase(fp) <= regs.sp);
31481:     obj = fp->blockChain;
31481:     JS_ASSERT_IF(obj,
31481:                  OBJ_BLOCK_DEPTH(cx, obj) + OBJ_BLOCK_COUNT(cx, obj)
31481:                  <= (size_t) (regs.sp - StackBase(fp)));
39930:     for (obj = fp->scopeChain; obj; obj = obj->getParent()) {
40826:         clasp = obj->getClass();
31481:         if (clasp != &js_BlockClass && clasp != &js_WithClass)
31481:             continue;
32684:         if (obj->getPrivate() != fp)
31481:             break;
31481:         JS_ASSERT(StackBase(fp) + OBJ_BLOCK_DEPTH(cx, obj)
31481:                              + ((clasp == &js_BlockClass)
31481:                                 ? OBJ_BLOCK_COUNT(cx, obj)
31481:                                 : 1)
31481:                   <= regs.sp);
31481:     }
31481: #endif
31481: END_CASE(JSOP_POPN)
31481: 
31481: BEGIN_CASE(JSOP_SETRVAL)
31481: BEGIN_CASE(JSOP_POPV)
31481:     ASSERT_NOT_THROWING(cx);
31481:     fp->rval = POP_OPND();
31481: END_CASE(JSOP_POPV)
31481: 
31481: BEGIN_CASE(JSOP_ENTERWITH)
31481:     if (!js_EnterWith(cx, -1))
31481:         goto error;
31481: 
31481:     /*
33585:      * We must ensure that different "with" blocks have different stack depth
33585:      * associated with them. This allows the try handler search to properly
33585:      * recover the scope chain. Thus we must keep the stack at least at the
33585:      * current level.
31481:      *
33585:      * We set sp[-1] to the current "with" object to help asserting the
33585:      * enter/leave balance in [leavewith].
31481:      */
31481:     regs.sp[-1] = OBJECT_TO_JSVAL(fp->scopeChain);
31481: END_CASE(JSOP_ENTERWITH)
31481: 
31481: BEGIN_CASE(JSOP_LEAVEWITH)
31481:     JS_ASSERT(regs.sp[-1] == OBJECT_TO_JSVAL(fp->scopeChain));
31481:     regs.sp--;
31481:     js_LeaveWith(cx);
31481: END_CASE(JSOP_LEAVEWITH)
31481: 
31481: BEGIN_CASE(JSOP_RETURN)
31481:     fp->rval = POP_OPND();
31481:     /* FALL THROUGH */
31481: 
31481: BEGIN_CASE(JSOP_RETRVAL)    /* fp->rval already set */
31481: BEGIN_CASE(JSOP_STOP)
31481:     /*
33585:      * When the inlined frame exits with an exception or an error, ok will be
33585:      * false after the inline_return label.
31481:      */
31481:     ASSERT_NOT_THROWING(cx);
31481:     CHECK_BRANCH();
31481: 
31481:     if (fp->imacpc) {
31481:         /*
33585:          * If we are at the end of an imacro, return to its caller in the
33585:          * current frame.
31481:          */
31481:         JS_ASSERT(op == JSOP_STOP);
31481: 
31481:       end_imacro:
31481:         JS_ASSERT((uintN)(regs.sp - fp->slots) <= script->nslots);
31481:         regs.pc = fp->imacpc + js_CodeSpec[*fp->imacpc].length;
31481:         fp->imacpc = NULL;
31481:         atoms = script->atomMap.vector;
31481:         op = JSOp(*regs.pc);
31481:         DO_OP();
31481:     }
31481: 
31481:     JS_ASSERT(regs.sp == StackBase(fp));
40342:     if ((fp->flags & JSFRAME_CONSTRUCTING) && JSVAL_IS_PRIMITIVE(fp->rval))
32774:         fp->rval = fp->thisv;
31481:     ok = JS_TRUE;
31481:     if (inlineCallCount)
31481:   inline_return:
31481:     {
31481:         JSInlineFrame *ifp = (JSInlineFrame *) fp;
31481:         void *hookData = ifp->hookData;
31481: 
31481:         JS_ASSERT(!fp->blockChain);
31481:         JS_ASSERT(!js_IsActiveWithOrBlock(cx, fp->scopeChain, 0));
31481: 
31481:         if (script->staticLevel < JS_DISPLAY_SIZE)
31481:             cx->display[script->staticLevel] = fp->displaySave;
31481: 
31481:         if (hookData) {
31481:             JSInterpreterHook hook;
31481:             JSBool status;
31481: 
31481:             hook = cx->debugHooks->callHook;
31481:             if (hook) {
31481:                 /*
33585:                  * Do not pass &ok directly as exposing the address inhibits
33585:                  * optimizations and uninitialised warnings.
31481:                  */
31481:                 status = ok;
31481:                 hook(cx, fp, JS_FALSE, &status, hookData);
31481:                 ok = status;
31481:                 CHECK_INTERRUPT_HANDLER();
31481:             }
31481:         }
31481: 
31481:         /*
31481:          * If fp has a call object, sync values and clear the back-
33585:          * pointer. This can happen for a lightweight function if it calls eval
33585:          * unexpectedly (in a way that is hidden from the compiler). See bug
33585:          * 325540.
31481:          */
31823:         fp->putActivationObjects(cx);
31481: 
31481: #ifdef INCLUDE_MOZILLA_DTRACE
31481:         /* DTrace function return, inlines */
31481:         if (JAVASCRIPT_FUNCTION_RVAL_ENABLED())
31481:             jsdtrace_function_rval(cx, fp, fp->fun, &fp->rval);
31481:         if (JAVASCRIPT_FUNCTION_RETURN_ENABLED())
31481:             jsdtrace_function_return(cx, fp, fp->fun);
31481: #endif
31481: 
31481:         /* Restore context version only if callee hasn't set version. */
31481:         if (JS_LIKELY(cx->version == currentVersion)) {
31481:             currentVersion = ifp->callerVersion;
31481:             if (currentVersion != cx->version)
31481:                 js_SetVersion(cx, currentVersion);
31481:         }
31481: 
31481:         /*
33585:          * If inline-constructing, replace primitive rval with the new object
33585:          * passed in via |this|, and instrument this constructor invocation.
31481:          */
31481:         if (fp->flags & JSFRAME_CONSTRUCTING) {
31481:             if (JSVAL_IS_PRIMITIVE(fp->rval))
32774:                 fp->rval = fp->thisv;
31481:             JS_RUNTIME_METER(cx->runtime, constructs);
31481:         }
31481: 
31481:         /* Restore caller's registers. */
31481:         regs = ifp->callerRegs;
31481: 
31481:         /* Store the return value in the caller's operand frame. */
31481:         regs.sp -= 1 + (size_t) ifp->frame.argc;
31481:         regs.sp[-1] = fp->rval;
31481: 
33564:         bool recursive = fp->script == fp->down->script;
33564: 
31481:         /* Restore cx->fp and release the inline frame's space. */
31481:         cx->fp = fp = fp->down;
31481:         JS_ASSERT(fp->regs == &ifp->callerRegs);
31481:         fp->regs = &regs;
31481:         JS_ARENA_RELEASE(&cx->stackPool, ifp->mark);
31481: 
31481:         /* Restore the calling script's interpreter registers. */
31481:         script = fp->script;
31481:         atoms = FrameAtomBase(cx, fp);
31481: 
31481:         /* Resume execution in the calling frame. */
31481:         inlineCallCount--;
31481:         if (JS_LIKELY(ok)) {
31481:             JS_ASSERT(js_CodeSpec[js_GetOpcode(cx, script, regs.pc)].length
31481:                       == JSOP_CALL_LENGTH);
33564:             TRACE_0(LeaveFrame);
33564:             if (!TRACE_RECORDER(cx) && recursive) {
33564:                 if (*(regs.pc + JSOP_CALL_LENGTH) == JSOP_TRACE) {
33564:                     regs.pc += JSOP_CALL_LENGTH;
34351:                     MONITOR_BRANCH(Record_LeaveFrame);
33564:                     op = (JSOp)*regs.pc;
33564:                     DO_OP();
33564:                 }
33564:             }
33564:             if (*(regs.pc + JSOP_CALL_LENGTH) == JSOP_TRACE ||
33564:                 *(regs.pc + JSOP_CALL_LENGTH) == JSOP_NOP) {
33564:                 JS_STATIC_ASSERT(JSOP_TRACE_LENGTH == JSOP_NOP_LENGTH);
33564:                 regs.pc += JSOP_CALL_LENGTH;
33564:                 len = JSOP_TRACE_LENGTH;
33564:             } else {
31481:                 len = JSOP_CALL_LENGTH;
33564:             }
31481:             DO_NEXT_OP(len);
31481:         }
31481:         goto error;
31481:     }
31481:     goto exit;
31481: 
31481: BEGIN_CASE(JSOP_DEFAULT)
31481:     (void) POP();
31481:     /* FALL THROUGH */
31481: BEGIN_CASE(JSOP_GOTO)
31481:     len = GET_JUMP_OFFSET(regs.pc);
31481:     BRANCH(len);
31481: END_CASE(JSOP_GOTO)
31481: 
31481: BEGIN_CASE(JSOP_IFEQ)
31481:     POP_BOOLEAN(cx, rval, cond);
31481:     if (cond == JS_FALSE) {
31481:         len = GET_JUMP_OFFSET(regs.pc);
31481:         BRANCH(len);
31481:     }
31481: END_CASE(JSOP_IFEQ)
31481: 
31481: BEGIN_CASE(JSOP_IFNE)
31481:     POP_BOOLEAN(cx, rval, cond);
31481:     if (cond != JS_FALSE) {
31481:         len = GET_JUMP_OFFSET(regs.pc);
31481:         BRANCH(len);
31481:     }
31481: END_CASE(JSOP_IFNE)
31481: 
31481: BEGIN_CASE(JSOP_OR)
31481:     POP_BOOLEAN(cx, rval, cond);
31481:     if (cond == JS_TRUE) {
31481:         len = GET_JUMP_OFFSET(regs.pc);
31481:         PUSH_OPND(rval);
31481:         DO_NEXT_OP(len);
31481:     }
31481: END_CASE(JSOP_OR)
31481: 
31481: BEGIN_CASE(JSOP_AND)
31481:     POP_BOOLEAN(cx, rval, cond);
31481:     if (cond == JS_FALSE) {
31481:         len = GET_JUMP_OFFSET(regs.pc);
31481:         PUSH_OPND(rval);
31481:         DO_NEXT_OP(len);
31481:     }
31481: END_CASE(JSOP_AND)
31481: 
31481: BEGIN_CASE(JSOP_DEFAULTX)
31481:     (void) POP();
31481:     /* FALL THROUGH */
31481: BEGIN_CASE(JSOP_GOTOX)
31481:     len = GET_JUMPX_OFFSET(regs.pc);
31481:     BRANCH(len);
31481: END_CASE(JSOP_GOTOX);
31481: 
31481: BEGIN_CASE(JSOP_IFEQX)
31481:     POP_BOOLEAN(cx, rval, cond);
31481:     if (cond == JS_FALSE) {
31481:         len = GET_JUMPX_OFFSET(regs.pc);
31481:         BRANCH(len);
31481:     }
31481: END_CASE(JSOP_IFEQX)
31481: 
31481: BEGIN_CASE(JSOP_IFNEX)
31481:     POP_BOOLEAN(cx, rval, cond);
31481:     if (cond != JS_FALSE) {
31481:         len = GET_JUMPX_OFFSET(regs.pc);
31481:         BRANCH(len);
31481:     }
31481: END_CASE(JSOP_IFNEX)
31481: 
31481: BEGIN_CASE(JSOP_ORX)
31481:     POP_BOOLEAN(cx, rval, cond);
31481:     if (cond == JS_TRUE) {
31481:         len = GET_JUMPX_OFFSET(regs.pc);
31481:         PUSH_OPND(rval);
31481:         DO_NEXT_OP(len);
31481:     }
31481: END_CASE(JSOP_ORX)
31481: 
31481: BEGIN_CASE(JSOP_ANDX)
31481:     POP_BOOLEAN(cx, rval, cond);
31481:     if (cond == JS_FALSE) {
31481:         len = GET_JUMPX_OFFSET(regs.pc);
31481:         PUSH_OPND(rval);
31481:         DO_NEXT_OP(len);
31481:     }
31481: END_CASE(JSOP_ANDX)
31481: 
31481: /*
31481:  * If the index value at sp[n] is not an int that fits in a jsval, it could
31481:  * be an object (an XML QName, AttributeName, or AnyName), but only if we are
31481:  * compiling with JS_HAS_XML_SUPPORT.  Otherwise convert the index value to a
31481:  * string atom id.
31481:  */
31481: #define FETCH_ELEMENT_ID(obj, n, id)                                          \
31481:     JS_BEGIN_MACRO                                                            \
31481:         jsval idval_ = FETCH_OPND(n);                                         \
31481:         if (JSVAL_IS_INT(idval_)) {                                           \
31481:             id = INT_JSVAL_TO_JSID(idval_);                                   \
31481:         } else {                                                              \
31481:             if (!js_InternNonIntElementId(cx, obj, idval_, &id))              \
31481:                 goto error;                                                   \
31481:             regs.sp[n] = ID_TO_VALUE(id);                                     \
31481:         }                                                                     \
31481:     JS_END_MACRO
31481: 
31481: #define TRY_BRANCH_AFTER_COND(cond,spdec)                                     \
31481:     JS_BEGIN_MACRO                                                            \
31481:         uintN diff_;                                                          \
31481:         JS_ASSERT(js_CodeSpec[op].length == 1);                               \
31481:         diff_ = (uintN) regs.pc[1] - (uintN) JSOP_IFEQ;                       \
31481:         if (diff_ <= 1) {                                                     \
31481:             regs.sp -= spdec;                                                 \
31481:             if (cond == (diff_ != 0)) {                                       \
31481:                 ++regs.pc;                                                    \
31481:                 len = GET_JUMP_OFFSET(regs.pc);                               \
31481:                 BRANCH(len);                                                  \
31481:             }                                                                 \
31481:             len = 1 + JSOP_IFEQ_LENGTH;                                       \
31481:             DO_NEXT_OP(len);                                                  \
31481:         }                                                                     \
31481:     JS_END_MACRO
31481: 
31481: BEGIN_CASE(JSOP_IN)
31481:     rval = FETCH_OPND(-1);
31481:     if (JSVAL_IS_PRIMITIVE(rval)) {
31481:         js_ReportValueError(cx, JSMSG_IN_NOT_OBJECT, -1, rval, NULL);
31481:         goto error;
31481:     }
31481:     obj = JSVAL_TO_OBJECT(rval);
31481:     FETCH_ELEMENT_ID(obj, -2, id);
31501:     if (!obj->lookupProperty(cx, id, &obj2, &prop))
31481:         goto error;
31481:     cond = prop != NULL;
31481:     if (prop)
31501:         obj2->dropProperty(cx, prop);
31481:     TRY_BRANCH_AFTER_COND(cond, 2);
31481:     regs.sp--;
31481:     STORE_OPND(-1, BOOLEAN_TO_JSVAL(cond));
31481: END_CASE(JSOP_IN)
31481: 
31481: BEGIN_CASE(JSOP_ITER)
31481:     JS_ASSERT(regs.sp > StackBase(fp));
31481:     flags = regs.pc[1];
31481:     if (!js_ValueToIterator(cx, flags, &regs.sp[-1]))
31481:         goto error;
31481:     CHECK_INTERRUPT_HANDLER();
31481:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(regs.sp[-1]));
31481:     PUSH(JSVAL_VOID);
31481: END_CASE(JSOP_ITER)
31481: 
31481: BEGIN_CASE(JSOP_NEXTITER)
31481:     JS_ASSERT(regs.sp - 2 >= StackBase(fp));
31481:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(regs.sp[-2]));
31481:     if (!js_CallIteratorNext(cx, JSVAL_TO_OBJECT(regs.sp[-2]), &regs.sp[-1]))
31481:         goto error;
31481:     CHECK_INTERRUPT_HANDLER();
31481:     rval = BOOLEAN_TO_JSVAL(regs.sp[-1] != JSVAL_HOLE);
31481:     PUSH(rval);
31481: END_CASE(JSOP_NEXTITER)
31481: 
31481: BEGIN_CASE(JSOP_ENDITER)
31481:     /*
31481:      * Decrease the stack pointer even when !ok -- see comments in the
31481:      * exception capturing code for details.
31481:      */
31481:     JS_ASSERT(regs.sp - 2 >= StackBase(fp));
31481:     ok = js_CloseIterator(cx, regs.sp[-2]);
31481:     regs.sp -= 2;
31481:     if (!ok)
31481:         goto error;
31481: END_CASE(JSOP_ENDITER)
31481: 
31481: BEGIN_CASE(JSOP_FORARG)
31481:     JS_ASSERT(regs.sp - 2 >= StackBase(fp));
31481:     slot = GET_ARGNO(regs.pc);
31481:     JS_ASSERT(slot < fp->fun->nargs);
31481:     fp->argv[slot] = regs.sp[-1];
31481: END_CASE(JSOP_FORARG)
31481: 
31481: BEGIN_CASE(JSOP_FORLOCAL)
31481:     JS_ASSERT(regs.sp - 2 >= StackBase(fp));
31481:     slot = GET_SLOTNO(regs.pc);
31481:     JS_ASSERT(slot < fp->script->nslots);
31481:     fp->slots[slot] = regs.sp[-1];
31481: END_CASE(JSOP_FORLOCAL)
31481: 
31481: BEGIN_CASE(JSOP_FORNAME)
31481:     JS_ASSERT(regs.sp - 2 >= StackBase(fp));
31481:     LOAD_ATOM(0);
31481:     id = ATOM_TO_JSID(atom);
31481:     if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
31481:         goto error;
31481:     if (prop)
31501:         obj2->dropProperty(cx, prop);
31501:     ok = obj->setProperty(cx, id, &regs.sp[-1]);
31481:     if (!ok)
31481:         goto error;
31481: END_CASE(JSOP_FORNAME)
31481: 
31481: BEGIN_CASE(JSOP_FORPROP)
31481:     JS_ASSERT(regs.sp - 2 >= StackBase(fp));
31481:     LOAD_ATOM(0);
31481:     id = ATOM_TO_JSID(atom);
31481:     FETCH_OBJECT(cx, -1, lval, obj);
31501:     ok = obj->setProperty(cx, id, &regs.sp[-2]);
31481:     if (!ok)
31481:         goto error;
31481:     regs.sp--;
31481: END_CASE(JSOP_FORPROP)
31481: 
31481: BEGIN_CASE(JSOP_FORELEM)
31481:     /*
33585:      * JSOP_FORELEM simply dups the property identifier at top of stack and
33585:      * lets the subsequent JSOP_ENUMELEM opcode sequence handle the left-hand
33585:      * side expression evaluation and assignment. This opcode exists solely to
33585:      * help the decompiler.
31481:      */
31481:     JS_ASSERT(regs.sp - 2 >= StackBase(fp));
31481:     rval = FETCH_OPND(-1);
31481:     PUSH(rval);
31481: END_CASE(JSOP_FORELEM)
31481: 
31481: BEGIN_CASE(JSOP_DUP)
31481:     JS_ASSERT(regs.sp > StackBase(fp));
31481:     rval = FETCH_OPND(-1);
31481:     PUSH(rval);
31481: END_CASE(JSOP_DUP)
31481: 
31481: BEGIN_CASE(JSOP_DUP2)
31481:     JS_ASSERT(regs.sp - 2 >= StackBase(fp));
31481:     lval = FETCH_OPND(-2);
31481:     rval = FETCH_OPND(-1);
31481:     PUSH(lval);
31481:     PUSH(rval);
31481: END_CASE(JSOP_DUP2)
31481: 
31481: BEGIN_CASE(JSOP_SWAP)
31481:     JS_ASSERT(regs.sp - 2 >= StackBase(fp));
31481:     lval = FETCH_OPND(-2);
31481:     rval = FETCH_OPND(-1);
31481:     STORE_OPND(-1, lval);
31481:     STORE_OPND(-2, rval);
31481: END_CASE(JSOP_SWAP)
31481: 
31481: BEGIN_CASE(JSOP_PICK)
31481:     i = regs.pc[1];
31481:     JS_ASSERT(regs.sp - (i+1) >= StackBase(fp));
31481:     lval = regs.sp[-(i+1)];
31481:     memmove(regs.sp - (i+1), regs.sp - i, sizeof(jsval)*i);
31481:     regs.sp[-1] = lval;
31481: END_CASE(JSOP_PICK)
31481: 
31481: #define PROPERTY_OP(n, call)                                                  \
31481:     JS_BEGIN_MACRO                                                            \
31481:         /* Fetch the left part and resolve it to a non-null object. */        \
31481:         FETCH_OBJECT(cx, n, lval, obj);                                       \
31481:                                                                               \
31481:         /* Get or set the property. */                                        \
31481:         if (!call)                                                            \
31481:             goto error;                                                       \
31481:     JS_END_MACRO
31481: 
31481: #define ELEMENT_OP(n, call)                                                   \
31481:     JS_BEGIN_MACRO                                                            \
31481:         /* Fetch the left part and resolve it to a non-null object. */        \
31481:         FETCH_OBJECT(cx, n - 1, lval, obj);                                   \
31481:                                                                               \
31481:         /* Fetch index and convert it to id suitable for use with obj. */     \
31481:         FETCH_ELEMENT_ID(obj, n, id);                                         \
31481:                                                                               \
31481:         /* Get or set the element. */                                         \
31481:         if (!call)                                                            \
31481:             goto error;                                                       \
31481:     JS_END_MACRO
31481: 
32658: #define NATIVE_GET(cx,obj,pobj,sprop,getHow,vp)                               \
31481:     JS_BEGIN_MACRO                                                            \
40265:         if (sprop->hasDefaultGetter()) {                                      \
31481:             /* Fast path for Object instance properties. */                   \
31481:             JS_ASSERT((sprop)->slot != SPROP_INVALID_SLOT ||                  \
40265:                       !sprop->hasDefaultSetter());                            \
31481:             *vp = ((sprop)->slot != SPROP_INVALID_SLOT)                       \
40847:                   ? (pobj)->lockedGetSlot((sprop)->slot)                      \
31481:                   : JSVAL_VOID;                                               \
31481:         } else {                                                              \
32658:             if (!js_NativeGet(cx, obj, pobj, sprop, getHow, vp))              \
31481:                 goto error;                                                   \
31481:         }                                                                     \
31481:     JS_END_MACRO
31481: 
31481: #define NATIVE_SET(cx,obj,sprop,entry,vp)                                     \
31481:     JS_BEGIN_MACRO                                                            \
41855:         TRACE_2(SetPropHit, entry, sprop);                                    \
40265:         if (sprop->hasDefaultSetter() &&                                      \
32658:             (sprop)->slot != SPROP_INVALID_SLOT &&                            \
40847:             !(obj)->scope()->brandedOrHasMethodBarrier()) {                   \
32658:             /* Fast path for, e.g., plain Object instance properties. */      \
40847:             (obj)->lockedSetSlot((sprop)->slot, *vp);                         \
31481:         } else {                                                              \
32658:             if (!js_NativeSet(cx, obj, sprop, false, vp))                     \
31481:                 goto error;                                                   \
31481:         }                                                                     \
31481:     JS_END_MACRO
31481: 
31481: /*
31481:  * Skip the JSOP_POP typically found after a JSOP_SET* opcode, where oplen is
31481:  * the constant length of the SET opcode sequence, and spdec is the constant
31481:  * by which to decrease the stack pointer to pop all of the SET op's operands.
31481:  *
31481:  * NB: unlike macros that could conceivably be replaced by functions (ignoring
31481:  * goto error), where a call should not have to be braced in order to expand
31481:  * correctly (e.g., in if (cond) FOO(); else BAR()), these three macros lack
31481:  * JS_{BEGIN,END}_MACRO brackets. They are also indented so as to align with
31481:  * nearby opcode code.
31481:  */
31481: #define SKIP_POP_AFTER_SET(oplen,spdec)                                       \
31481:             if (regs.pc[oplen] == JSOP_POP) {                                 \
31481:                 regs.sp -= spdec;                                             \
31481:                 regs.pc += oplen + JSOP_POP_LENGTH;                           \
31481:                 op = (JSOp) *regs.pc;                                         \
31481:                 DO_OP();                                                      \
31481:             }
31481: 
31481: #define END_SET_CASE(OP)                                                      \
31481:             SKIP_POP_AFTER_SET(OP##_LENGTH, 1);                               \
31481:           END_CASE(OP)
31481: 
31481: #define END_SET_CASE_STORE_RVAL(OP,spdec)                                     \
31481:             SKIP_POP_AFTER_SET(OP##_LENGTH, spdec);                           \
31481:             rval = FETCH_OPND(-1);                                            \
31481:             regs.sp -= (spdec) - 1;                                           \
31481:             STORE_OPND(-1, rval);                                             \
31481:           END_CASE(OP)
31481: 
31481: BEGIN_CASE(JSOP_SETCONST)
31481:     LOAD_ATOM(0);
37777:     obj = fp->varobj(cx);
31481:     rval = FETCH_OPND(-1);
31501:     if (!obj->defineProperty(cx, ATOM_TO_JSID(atom), rval,
31481:                              JS_PropertyStub, JS_PropertyStub,
32573:                              JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
31481:         goto error;
31481:     }
31481: END_SET_CASE(JSOP_SETCONST);
31481: 
31481: #if JS_HAS_DESTRUCTURING
31481: BEGIN_CASE(JSOP_ENUMCONSTELEM)
31481:     rval = FETCH_OPND(-3);
31481:     FETCH_OBJECT(cx, -2, lval, obj);
31481:     FETCH_ELEMENT_ID(obj, -1, id);
31501:     if (!obj->defineProperty(cx, id, rval,
31481:                              JS_PropertyStub, JS_PropertyStub,
32573:                              JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY)) {
31481:         goto error;
31481:     }
31481:     regs.sp -= 3;
31481: END_CASE(JSOP_ENUMCONSTELEM)
31481: #endif
31481: 
31481: BEGIN_CASE(JSOP_BINDNAME)
31481:     do {
40362:         PropertyCacheEntry *entry;
31481: 
31481:         /*
33585:          * We can skip the property lookup for the global object. If the
33585:          * property does not exist anywhere on the scope chain, JSOP_SETNAME
33585:          * adds the property to the global.
31481:          *
33585:          * As a consequence of this optimization for the global object we run
33585:          * its JSRESOLVE_ASSIGNING-tolerant resolve hooks only in JSOP_SETNAME,
33585:          * after the interpreter evaluates the right- hand-side of the
33585:          * assignment, and not here.
31481:          *
33585:          * This should be transparent to the hooks because the script, instead
33585:          * of name = rhs, could have used global.name = rhs given a global
33585:          * object reference, which also calls the hooks only after evaluating
33585:          * the rhs. We desire such resolve hook equivalence between the two
33585:          * forms.
31481:          */
31481:         obj = fp->scopeChain;
39930:         if (!obj->getParent())
31481:             break;
40392: 
40362:         JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
31481:         if (!atom) {
31481:             ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
31481:             break;
31481:         }
40392: 
31481:         id = ATOM_TO_JSID(atom);
31481:         obj = js_FindIdentifierBase(cx, fp->scopeChain, id);
31481:         if (!obj)
31481:             goto error;
31481:     } while (0);
31481:     PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_BINDNAME)
31481: 
31481: BEGIN_CASE(JSOP_IMACOP)
31481:     JS_ASSERT(JS_UPTRDIFF(fp->imacpc, script->code) < script->length);
31481:     op = JSOp(*fp->imacpc);
31481:     DO_OP();
31481: 
31481: #define BITWISE_OP(OP)                                                        \
31481:     JS_BEGIN_MACRO                                                            \
31481:         FETCH_INT(cx, -2, i);                                                 \
31481:         FETCH_INT(cx, -1, j);                                                 \
31481:         i = i OP j;                                                           \
31481:         regs.sp--;                                                            \
31481:         STORE_INT(cx, -1, i);                                                 \
31481:     JS_END_MACRO
31481: 
31481: BEGIN_CASE(JSOP_BITOR)
31481:     BITWISE_OP(|);
31481: END_CASE(JSOP_BITOR)
31481: 
31481: BEGIN_CASE(JSOP_BITXOR)
31481:     BITWISE_OP(^);
31481: END_CASE(JSOP_BITXOR)
31481: 
31481: BEGIN_CASE(JSOP_BITAND)
31481:     BITWISE_OP(&);
31481: END_CASE(JSOP_BITAND)
31481: 
31481: #define RELATIONAL_OP(OP)                                                     \
31481:     JS_BEGIN_MACRO                                                            \
31481:         rval = FETCH_OPND(-1);                                                \
31481:         lval = FETCH_OPND(-2);                                                \
31481:         /* Optimize for two int-tagged operands (typical loop control). */    \
31481:         if ((lval & rval) & JSVAL_INT) {                                      \
31481:             cond = JSVAL_TO_INT(lval) OP JSVAL_TO_INT(rval);                  \
31481:         } else {                                                              \
31481:             if (!JSVAL_IS_PRIMITIVE(lval))                                    \
31481:                 DEFAULT_VALUE(cx, -2, JSTYPE_NUMBER, lval);                   \
31481:             if (!JSVAL_IS_PRIMITIVE(rval))                                    \
31481:                 DEFAULT_VALUE(cx, -1, JSTYPE_NUMBER, rval);                   \
31481:             if (JSVAL_IS_STRING(lval) && JSVAL_IS_STRING(rval)) {             \
31481:                 str  = JSVAL_TO_STRING(lval);                                 \
31481:                 str2 = JSVAL_TO_STRING(rval);                                 \
31481:                 cond = js_CompareStrings(str, str2) OP 0;                     \
31481:             } else {                                                          \
40828:                 VALUE_TO_NUMBER(cx, lval, d);                                 \
40828:                 VALUE_TO_NUMBER(cx, rval, d2);                                \
31481:                 cond = JSDOUBLE_COMPARE(d, OP, d2, JS_FALSE);                 \
31481:             }                                                                 \
31481:         }                                                                     \
31481:         TRY_BRANCH_AFTER_COND(cond, 2);                                       \
31481:         regs.sp--;                                                            \
31481:         STORE_OPND(-1, BOOLEAN_TO_JSVAL(cond));                               \
31481:     JS_END_MACRO
31481: 
31481: /*
31481:  * NB: These macros can't use JS_BEGIN_MACRO/JS_END_MACRO around their bodies
31481:  * because they begin if/else chains, so callers must not put semicolons after
31481:  * the call expressions!
31481:  */
31481: #if JS_HAS_XML_SUPPORT
31481: #define XML_EQUALITY_OP(OP)                                                   \
31481:     if ((ltmp == JSVAL_OBJECT &&                                              \
31481:          (obj2 = JSVAL_TO_OBJECT(lval)) &&                                    \
41295:          OBJECT_IS_XML(cx, obj2)) ||                                          \
31481:         (rtmp == JSVAL_OBJECT &&                                              \
31481:          (obj2 = JSVAL_TO_OBJECT(rval)) &&                                    \
41295:          OBJECT_IS_XML(cx, obj2))) {                                          \
31481:         if (JSVAL_IS_OBJECT(rval) && obj2 == JSVAL_TO_OBJECT(rval))           \
31481:             rval = lval;                                                      \
31481:         if (!js_TestXMLEquality(cx, obj2, rval, &cond))                       \
31481:             goto error;                                                       \
31481:         cond = cond OP JS_TRUE;                                               \
31481:     } else
31481: 
31481: #define EXTENDED_EQUALITY_OP(OP)                                              \
31481:     if (ltmp == JSVAL_OBJECT &&                                               \
31481:         (obj2 = JSVAL_TO_OBJECT(lval)) &&                                     \
40826:         ((clasp = obj2->getClass())->flags & JSCLASS_IS_EXTENDED)) {          \
31481:         JSExtendedClass *xclasp;                                              \
31481:                                                                               \
31481:         xclasp = (JSExtendedClass *) clasp;                                   \
31481:         if (!xclasp->equality(cx, obj2, rval, &cond))                         \
31481:             goto error;                                                       \
31481:         cond = cond OP JS_TRUE;                                               \
31481:     } else
31481: #else
31481: #define XML_EQUALITY_OP(OP)             /* nothing */
31481: #define EXTENDED_EQUALITY_OP(OP)        /* nothing */
31481: #endif
31481: 
31481: #define EQUALITY_OP(OP, IFNAN)                                                \
31481:     JS_BEGIN_MACRO                                                            \
31481:         rval = FETCH_OPND(-1);                                                \
31481:         lval = FETCH_OPND(-2);                                                \
31481:         ltmp = JSVAL_TAG(lval);                                               \
31481:         rtmp = JSVAL_TAG(rval);                                               \
31481:         XML_EQUALITY_OP(OP)                                                   \
31481:         if (ltmp == rtmp) {                                                   \
31481:             if (ltmp == JSVAL_STRING) {                                       \
31481:                 str  = JSVAL_TO_STRING(lval);                                 \
31481:                 str2 = JSVAL_TO_STRING(rval);                                 \
31481:                 cond = js_EqualStrings(str, str2) OP JS_TRUE;                 \
31481:             } else if (ltmp == JSVAL_DOUBLE) {                                \
31481:                 d  = *JSVAL_TO_DOUBLE(lval);                                  \
31481:                 d2 = *JSVAL_TO_DOUBLE(rval);                                  \
31481:                 cond = JSDOUBLE_COMPARE(d, OP, d2, IFNAN);                    \
31481:             } else {                                                          \
31481:                 EXTENDED_EQUALITY_OP(OP)                                      \
31481:                 /* Handle all undefined (=>NaN) and int combinations. */      \
31481:                 cond = lval OP rval;                                          \
31481:             }                                                                 \
31481:         } else {                                                              \
31481:             if (JSVAL_IS_NULL(lval) || JSVAL_IS_VOID(lval)) {                 \
31481:                 cond = (JSVAL_IS_NULL(rval) || JSVAL_IS_VOID(rval)) OP 1;     \
31481:             } else if (JSVAL_IS_NULL(rval) || JSVAL_IS_VOID(rval)) {          \
31481:                 cond = 1 OP 0;                                                \
31481:             } else {                                                          \
31481:                 if (ltmp == JSVAL_OBJECT) {                                   \
31481:                     DEFAULT_VALUE(cx, -2, JSTYPE_VOID, lval);                 \
31481:                     ltmp = JSVAL_TAG(lval);                                   \
31481:                 } else if (rtmp == JSVAL_OBJECT) {                            \
31481:                     DEFAULT_VALUE(cx, -1, JSTYPE_VOID, rval);                 \
31481:                     rtmp = JSVAL_TAG(rval);                                   \
31481:                 }                                                             \
31481:                 if (ltmp == JSVAL_STRING && rtmp == JSVAL_STRING) {           \
31481:                     str  = JSVAL_TO_STRING(lval);                             \
31481:                     str2 = JSVAL_TO_STRING(rval);                             \
31481:                     cond = js_EqualStrings(str, str2) OP JS_TRUE;             \
31481:                 } else {                                                      \
40828:                     VALUE_TO_NUMBER(cx, lval, d);                             \
40828:                     VALUE_TO_NUMBER(cx, rval, d2);                            \
31481:                     cond = JSDOUBLE_COMPARE(d, OP, d2, IFNAN);                \
31481:                 }                                                             \
31481:             }                                                                 \
31481:         }                                                                     \
31481:         TRY_BRANCH_AFTER_COND(cond, 2);                                       \
31481:         regs.sp--;                                                            \
31481:         STORE_OPND(-1, BOOLEAN_TO_JSVAL(cond));                               \
31481:     JS_END_MACRO
31481: 
31481: BEGIN_CASE(JSOP_EQ)
31481:     EQUALITY_OP(==, JS_FALSE);
31481: END_CASE(JSOP_EQ)
31481: 
31481: BEGIN_CASE(JSOP_NE)
31481:     EQUALITY_OP(!=, JS_TRUE);
31481: END_CASE(JSOP_NE)
31481: 
31481: #define STRICT_EQUALITY_OP(OP)                                                \
31481:     JS_BEGIN_MACRO                                                            \
31481:         rval = FETCH_OPND(-1);                                                \
31481:         lval = FETCH_OPND(-2);                                                \
31481:         cond = js_StrictlyEqual(cx, lval, rval) OP JS_TRUE;                   \
31481:         regs.sp--;                                                            \
31481:         STORE_OPND(-1, BOOLEAN_TO_JSVAL(cond));                               \
31481:     JS_END_MACRO
31481: 
31481: BEGIN_CASE(JSOP_STRICTEQ)
31481:     STRICT_EQUALITY_OP(==);
31481: END_CASE(JSOP_STRICTEQ)
31481: 
31481: BEGIN_CASE(JSOP_STRICTNE)
31481:     STRICT_EQUALITY_OP(!=);
31481: END_CASE(JSOP_STRICTNE)
31481: 
31481: BEGIN_CASE(JSOP_CASE)
31481:     STRICT_EQUALITY_OP(==);
31481:     (void) POP();
31481:     if (cond) {
31481:         len = GET_JUMP_OFFSET(regs.pc);
31481:         BRANCH(len);
31481:     }
31481:     PUSH(lval);
31481: END_CASE(JSOP_CASE)
31481: 
31481: BEGIN_CASE(JSOP_CASEX)
31481:     STRICT_EQUALITY_OP(==);
31481:     (void) POP();
31481:     if (cond) {
31481:         len = GET_JUMPX_OFFSET(regs.pc);
31481:         BRANCH(len);
31481:     }
31481:     PUSH(lval);
31481: END_CASE(JSOP_CASEX)
31481: 
31481: BEGIN_CASE(JSOP_LT)
31481:     RELATIONAL_OP(<);
31481: END_CASE(JSOP_LT)
31481: 
31481: BEGIN_CASE(JSOP_LE)
31481:     RELATIONAL_OP(<=);
31481: END_CASE(JSOP_LE)
31481: 
31481: BEGIN_CASE(JSOP_GT)
31481:     RELATIONAL_OP(>);
31481: END_CASE(JSOP_GT)
31481: 
31481: BEGIN_CASE(JSOP_GE)
31481:     RELATIONAL_OP(>=);
31481: END_CASE(JSOP_GE)
31481: 
31481: #undef EQUALITY_OP
31481: #undef RELATIONAL_OP
31481: 
31481: #define SIGNED_SHIFT_OP(OP)                                                   \
31481:     JS_BEGIN_MACRO                                                            \
31481:         FETCH_INT(cx, -2, i);                                                 \
31481:         FETCH_INT(cx, -1, j);                                                 \
31481:         i = i OP (j & 31);                                                    \
31481:         regs.sp--;                                                            \
31481:         STORE_INT(cx, -1, i);                                                 \
31481:     JS_END_MACRO
31481: 
31481: BEGIN_CASE(JSOP_LSH)
31481:     SIGNED_SHIFT_OP(<<);
31481: END_CASE(JSOP_LSH)
31481: 
31481: BEGIN_CASE(JSOP_RSH)
31481:     SIGNED_SHIFT_OP(>>);
31481: END_CASE(JSOP_RSH)
31481: 
31481: BEGIN_CASE(JSOP_URSH)
31481: {
40828:     uint32_t u;
31481: 
31481:     FETCH_UINT(cx, -2, u);
31481:     FETCH_INT(cx, -1, j);
31481:     u >>= (j & 31);
31481:     regs.sp--;
31481:     STORE_UINT(cx, -1, u);
31481: }
31481: END_CASE(JSOP_URSH)
31481: 
31481: #undef BITWISE_OP
31481: #undef SIGNED_SHIFT_OP
31481: 
31481: BEGIN_CASE(JSOP_ADD)
31481:     rval = FETCH_OPND(-1);
31481:     lval = FETCH_OPND(-2);
31481: #if JS_HAS_XML_SUPPORT
31481:     if (!JSVAL_IS_PRIMITIVE(lval) &&
41295:         (obj2 = JSVAL_TO_OBJECT(lval), OBJECT_IS_XML(cx, obj2)) &&
41295:         VALUE_IS_XML(cx, rval)) {
31481:         if (!js_ConcatenateXML(cx, obj2, rval, &rval))
31481:             goto error;
31481:         regs.sp--;
31481:         STORE_OPND(-1, rval);
31481:     } else
31481: #endif
31481:     {
31481:         if (!JSVAL_IS_PRIMITIVE(lval))
31481:             DEFAULT_VALUE(cx, -2, JSTYPE_VOID, lval);
31481:         if (!JSVAL_IS_PRIMITIVE(rval))
31481:             DEFAULT_VALUE(cx, -1, JSTYPE_VOID, rval);
31481:         if ((cond = JSVAL_IS_STRING(lval)) || JSVAL_IS_STRING(rval)) {
31481:             if (cond) {
31481:                 str = JSVAL_TO_STRING(lval);
31481:                 str2 = js_ValueToString(cx, rval);
31481:                 if (!str2)
31481:                     goto error;
31481:                 regs.sp[-1] = STRING_TO_JSVAL(str2);
31481:             } else {
31481:                 str2 = JSVAL_TO_STRING(rval);
31481:                 str = js_ValueToString(cx, lval);
31481:                 if (!str)
31481:                     goto error;
31481:                 regs.sp[-2] = STRING_TO_JSVAL(str);
31481:             }
31481:             str = js_ConcatStrings(cx, str, str2);
31481:             if (!str)
31481:                 goto error;
31481:             regs.sp--;
31481:             STORE_OPND(-1, STRING_TO_JSVAL(str));
31481:         } else {
40828:             VALUE_TO_NUMBER(cx, lval, d);
40828:             VALUE_TO_NUMBER(cx, rval, d2);
31481:             d += d2;
31481:             regs.sp--;
31481:             STORE_NUMBER(cx, -1, d);
31481:         }
31481:     }
31481: END_CASE(JSOP_ADD)
31481: 
38641: BEGIN_CASE(JSOP_OBJTOSTR)
38641:     rval = FETCH_OPND(-1);
38641:     if (!JSVAL_IS_PRIMITIVE(rval)) {
38641:         str = js_ValueToString(cx, rval);
38641:         if (!str)
38641:             goto error;
38641:         STORE_OPND(-1, STRING_TO_JSVAL(str));
38641:     }
38641: END_CASE(JSOP_OBJTOSTR)
38641: 
32581: BEGIN_CASE(JSOP_CONCATN)
32581: {
38641:     JSCharBuffer buf(cx);
32581:     argc = GET_ARGC(regs.pc);
32581:     for (vp = regs.sp - argc; vp < regs.sp; vp++) {
38641:         JS_ASSERT(JSVAL_IS_PRIMITIVE(*vp));
38641:         if (!js_ValueToCharBuffer(cx, *vp, buf))
32581:             goto error;
32581:     }
32581:     str = js_NewStringFromCharBuffer(cx, buf);
32581:     if (!str)
32581:         goto error;
32581:     regs.sp -= argc - 1;
32581:     STORE_OPND(-1, STRING_TO_JSVAL(str));
32581: }
32581: END_CASE(JSOP_CONCATN)
32581: 
31481: #define BINARY_OP(OP)                                                         \
31481:     JS_BEGIN_MACRO                                                            \
31481:         FETCH_NUMBER(cx, -2, d);                                              \
31481:         FETCH_NUMBER(cx, -1, d2);                                             \
31481:         d = d OP d2;                                                          \
31481:         regs.sp--;                                                            \
31481:         STORE_NUMBER(cx, -1, d);                                              \
31481:     JS_END_MACRO
31481: 
31481: BEGIN_CASE(JSOP_SUB)
31481:     BINARY_OP(-);
31481: END_CASE(JSOP_SUB)
31481: 
31481: BEGIN_CASE(JSOP_MUL)
31481:     BINARY_OP(*);
31481: END_CASE(JSOP_MUL)
31481: 
31481: BEGIN_CASE(JSOP_DIV)
31481:     FETCH_NUMBER(cx, -1, d2);
31481:     FETCH_NUMBER(cx, -2, d);
31481:     regs.sp--;
31481:     if (d2 == 0) {
31481: #ifdef XP_WIN
31481:         /* XXX MSVC miscompiles such that (NaN == 0) */
31481:         if (JSDOUBLE_IS_NaN(d2))
34372:             rval = rt->NaNValue;
31481:         else
31481: #endif
31481:         if (d == 0 || JSDOUBLE_IS_NaN(d))
34372:             rval = rt->NaNValue;
32586:         else if (JSDOUBLE_IS_NEG(d) != JSDOUBLE_IS_NEG(d2))
34372:             rval = rt->negativeInfinityValue;
31481:         else
34372:             rval = rt->positiveInfinityValue;
31481:         STORE_OPND(-1, rval);
31481:     } else {
31481:         d /= d2;
31481:         STORE_NUMBER(cx, -1, d);
31481:     }
31481: END_CASE(JSOP_DIV)
31481: 
31481: BEGIN_CASE(JSOP_MOD)
31481:     FETCH_NUMBER(cx, -1, d2);
31481:     FETCH_NUMBER(cx, -2, d);
31481:     regs.sp--;
31481:     if (d2 == 0) {
34372:         STORE_OPND(-1, rt->NaNValue);
31481:     } else {
31481:         d = js_fmod(d, d2);
31481:         STORE_NUMBER(cx, -1, d);
31481:     }
31481: END_CASE(JSOP_MOD)
31481: 
31481: BEGIN_CASE(JSOP_NOT)
31481:     POP_BOOLEAN(cx, rval, cond);
31481:     PUSH_OPND(BOOLEAN_TO_JSVAL(!cond));
31481: END_CASE(JSOP_NOT)
31481: 
31481: BEGIN_CASE(JSOP_BITNOT)
31481:     FETCH_INT(cx, -1, i);
31481:     i = ~i;
31481:     STORE_INT(cx, -1, i);
31481: END_CASE(JSOP_BITNOT)
31481: 
31481: BEGIN_CASE(JSOP_NEG)
31481:     /*
31481:      * When the operand is int jsval, INT_FITS_IN_JSVAL(i) implies
31481:      * INT_FITS_IN_JSVAL(-i) unless i is 0 or JSVAL_INT_MIN when the
31481:      * results, -0.0 or JSVAL_INT_MAX + 1, are jsdouble values.
31481:      */
31481:     rval = FETCH_OPND(-1);
31481:     if (JSVAL_IS_INT(rval) &&
31481:         rval != INT_TO_JSVAL(JSVAL_INT_MIN) &&
31481:         (i = JSVAL_TO_INT(rval)) != 0) {
31481:         JS_STATIC_ASSERT(!INT_FITS_IN_JSVAL(-JSVAL_INT_MIN));
31481:         i = -i;
31481:         JS_ASSERT(INT_FITS_IN_JSVAL(i));
31481:         regs.sp[-1] = INT_TO_JSVAL(i);
31481:     } else {
40828:         if (!ValueToNumber(cx, regs.sp[-1], &d))
31481:             goto error;
31481:         d = -d;
31481:         if (!js_NewNumberInRootedValue(cx, d, &regs.sp[-1]))
31481:             goto error;
31481:     }
31481: END_CASE(JSOP_NEG)
31481: 
31481: BEGIN_CASE(JSOP_POS)
40828:     if (!ValueToNumberValue(cx, &regs.sp[-1]))
40828:         goto error;
31481: END_CASE(JSOP_POS)
31481: 
31481: BEGIN_CASE(JSOP_DELNAME)
31481:     LOAD_ATOM(0);
31481:     id = ATOM_TO_JSID(atom);
31481:     if (!js_FindProperty(cx, id, &obj, &obj2, &prop))
31481:         goto error;
31481: 
31481:     /* ECMA says to return true if name is undefined or inherited. */
31481:     PUSH_OPND(JSVAL_TRUE);
31481:     if (prop) {
31501:         obj2->dropProperty(cx, prop);
31501:         if (!obj->deleteProperty(cx, id, &regs.sp[-1]))
31481:             goto error;
31481:     }
31481: END_CASE(JSOP_DELNAME)
31481: 
31481: BEGIN_CASE(JSOP_DELPROP)
31481:     LOAD_ATOM(0);
31481:     id = ATOM_TO_JSID(atom);
31501:     PROPERTY_OP(-1, obj->deleteProperty(cx, id, &rval));
31481:     STORE_OPND(-1, rval);
31481: END_CASE(JSOP_DELPROP)
31481: 
31481: BEGIN_CASE(JSOP_DELELEM)
31501:     ELEMENT_OP(-1, obj->deleteProperty(cx, id, &rval));
31481:     regs.sp--;
31481:     STORE_OPND(-1, rval);
31481: END_CASE(JSOP_DELELEM)
31481: 
31481: BEGIN_CASE(JSOP_TYPEOFEXPR)
31481: BEGIN_CASE(JSOP_TYPEOF)
31481:     rval = FETCH_OPND(-1);
31481:     type = JS_TypeOfValue(cx, rval);
31481:     atom = rt->atomState.typeAtoms[type];
31481:     STORE_OPND(-1, ATOM_KEY(atom));
31481: END_CASE(JSOP_TYPEOF)
31481: 
31481: BEGIN_CASE(JSOP_VOID)
31481:     STORE_OPND(-1, JSVAL_VOID);
31481: END_CASE(JSOP_VOID)
31481: 
31481: BEGIN_CASE(JSOP_INCELEM)
31481: BEGIN_CASE(JSOP_DECELEM)
31481: BEGIN_CASE(JSOP_ELEMINC)
31481: BEGIN_CASE(JSOP_ELEMDEC)
31481:     /*
33585:      * Delay fetching of id until we have the object to ensure the proper
33585:      * evaluation order. See bug 372331.
31481:      */
31481:     id = 0;
31481:     i = -2;
31481:     goto fetch_incop_obj;
31481: 
31481: BEGIN_CASE(JSOP_INCPROP)
31481: BEGIN_CASE(JSOP_DECPROP)
31481: BEGIN_CASE(JSOP_PROPINC)
31481: BEGIN_CASE(JSOP_PROPDEC)
31481:     LOAD_ATOM(0);
31481:     id = ATOM_TO_JSID(atom);
31481:     i = -1;
31481: 
31481:   fetch_incop_obj:
31481:     FETCH_OBJECT(cx, i, lval, obj);
31481:     if (id == 0)
31481:         FETCH_ELEMENT_ID(obj, -1, id);
31481:     goto do_incop;
31481: 
31481: BEGIN_CASE(JSOP_INCNAME)
31481: BEGIN_CASE(JSOP_DECNAME)
31481: BEGIN_CASE(JSOP_NAMEINC)
31481: BEGIN_CASE(JSOP_NAMEDEC)
31481: {
40362:     PropertyCacheEntry *entry;
31481: 
31481:     obj = fp->scopeChain;
40392: 
40362:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
31481:     if (!atom) {
31481:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
40374:         if (obj == obj2 && entry->vword.isSlot()) {
40374:             slot = entry->vword.toSlot();
40847:             JS_ASSERT(slot < obj->scope()->freeslot);
40847:             rval = obj->lockedGetSlot(slot);
31481:             if (JS_LIKELY(CAN_DO_FAST_INC_DEC(rval))) {
31481:                 rtmp = rval;
31481:                 rval += (js_CodeSpec[op].format & JOF_INC) ? 2 : -2;
31481:                 if (!(js_CodeSpec[op].format & JOF_POST))
31481:                     rtmp = rval;
40847:                 obj->lockedSetSlot(slot, rval);
31481:                 PUSH_OPND(rtmp);
31481:                 len = JSOP_INCNAME_LENGTH;
31481:                 DO_NEXT_OP(len);
31481:             }
31481:         }
31481:         LOAD_ATOM(0);
31481:     }
40392: 
31481:     id = ATOM_TO_JSID(atom);
31481:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
31481:         goto error;
31481:     if (!prop)
31481:         goto atom_not_defined;
31501:     obj2->dropProperty(cx, prop);
31481: }
31481: 
31481: do_incop:
31481: {
31481:     const JSCodeSpec *cs;
31481:     jsval v;
31481: 
31481:     /*
31481:      * We need a root to store the value to leave on the stack until
31501:      * we have done with obj->setProperty.
31481:      */
31481:     PUSH_OPND(JSVAL_NULL);
31501:     if (!obj->getProperty(cx, id, &regs.sp[-1]))
31481:         goto error;
31481: 
31481:     cs = &js_CodeSpec[op];
31481:     JS_ASSERT(cs->ndefs == 1);
31481:     JS_ASSERT((cs->format & JOF_TMPSLOT_MASK) == JOF_TMPSLOT2);
31481:     v = regs.sp[-1];
31481:     if (JS_LIKELY(CAN_DO_FAST_INC_DEC(v))) {
31481:         jsval incr;
31481: 
31481:         incr = (cs->format & JOF_INC) ? 2 : -2;
31481:         if (cs->format & JOF_POST) {
31481:             regs.sp[-1] = v + incr;
31481:         } else {
31481:             v += incr;
31481:             regs.sp[-1] = v;
31481:         }
31481:         fp->flags |= JSFRAME_ASSIGNING;
31501:         ok = obj->setProperty(cx, id, &regs.sp[-1]);
31481:         fp->flags &= ~JSFRAME_ASSIGNING;
31481:         if (!ok)
31481:             goto error;
31481: 
31481:         /*
31481:          * We must set regs.sp[-1] to v for both post and pre increments
31481:          * as the setter overwrites regs.sp[-1].
31481:          */
31481:         regs.sp[-1] = v;
31481:     } else {
31481:         /* We need an extra root for the result. */
31481:         PUSH_OPND(JSVAL_NULL);
31481:         if (!js_DoIncDec(cx, cs, &regs.sp[-2], &regs.sp[-1]))
31481:             goto error;
31481:         fp->flags |= JSFRAME_ASSIGNING;
31501:         ok = obj->setProperty(cx, id, &regs.sp[-1]);
31481:         fp->flags &= ~JSFRAME_ASSIGNING;
31481:         if (!ok)
31481:             goto error;
31481:         regs.sp--;
31481:     }
31481: 
31481:     if (cs->nuses == 0) {
31481:         /* regs.sp[-1] already contains the result of name increment. */
31481:     } else {
31481:         rtmp = regs.sp[-1];
31481:         regs.sp -= cs->nuses;
31481:         regs.sp[-1] = rtmp;
31481:     }
31481:     len = cs->length;
31481:     DO_NEXT_OP(len);
31481: }
31481: 
31481: {
31481:     jsval incr, incr2;
31481: 
31481:     /* Position cases so the most frequent i++ does not need a jump. */
31481: BEGIN_CASE(JSOP_DECARG)
31481:     incr = -2; incr2 = -2; goto do_arg_incop;
31481: BEGIN_CASE(JSOP_ARGDEC)
31481:     incr = -2; incr2 =  0; goto do_arg_incop;
31481: BEGIN_CASE(JSOP_INCARG)
31481:     incr =  2; incr2 =  2; goto do_arg_incop;
31481: BEGIN_CASE(JSOP_ARGINC)
31481:     incr =  2; incr2 =  0;
31481: 
31481:   do_arg_incop:
31481:     slot = GET_ARGNO(regs.pc);
31481:     JS_ASSERT(slot < fp->fun->nargs);
31481:     METER_SLOT_OP(op, slot);
31481:     vp = fp->argv + slot;
31481:     goto do_int_fast_incop;
31481: 
31481: BEGIN_CASE(JSOP_DECLOCAL)
31481:     incr = -2; incr2 = -2; goto do_local_incop;
31481: BEGIN_CASE(JSOP_LOCALDEC)
31481:     incr = -2; incr2 =  0; goto do_local_incop;
31481: BEGIN_CASE(JSOP_INCLOCAL)
31481:     incr =  2; incr2 =  2; goto do_local_incop;
31481: BEGIN_CASE(JSOP_LOCALINC)
31481:     incr =  2; incr2 =  0;
31481: 
31481:   /*
31481:    * do_local_incop comes right before do_int_fast_incop as we want to
31481:    * avoid an extra jump for variable cases as local++ is more frequent
31481:    * than arg++.
31481:    */
31481:   do_local_incop:
31481:     slot = GET_SLOTNO(regs.pc);
31481:     JS_ASSERT(slot < fp->script->nslots);
31481:     vp = fp->slots + slot;
31481:     METER_SLOT_OP(op, slot);
31481:     vp = fp->slots + slot;
31481: 
31481:   do_int_fast_incop:
31481:     rval = *vp;
31481:     if (JS_LIKELY(CAN_DO_FAST_INC_DEC(rval))) {
31481:         *vp = rval + incr;
31481:         JS_ASSERT(JSOP_INCARG_LENGTH == js_CodeSpec[op].length);
31481:         SKIP_POP_AFTER_SET(JSOP_INCARG_LENGTH, 0);
31481:         PUSH_OPND(rval + incr2);
31481:     } else {
31481:         PUSH_OPND(rval);
31481:         if (!js_DoIncDec(cx, &js_CodeSpec[op], &regs.sp[-1], vp))
31481:             goto error;
31481:     }
31481:     len = JSOP_INCARG_LENGTH;
31481:     JS_ASSERT(len == js_CodeSpec[op].length);
31481:     DO_NEXT_OP(len);
31481: }
31481: 
31481: /* NB: This macro doesn't use JS_BEGIN_MACRO/JS_END_MACRO around its body. */
31481: #define FAST_GLOBAL_INCREMENT_OP(SLOWOP,INCR,INCR2)                           \
31481:     op2 = SLOWOP;                                                             \
31481:     incr = INCR;                                                              \
31481:     incr2 = INCR2;                                                            \
31481:     goto do_global_incop
31481: 
31481: {
31481:     jsval incr, incr2;
31481: 
31481: BEGIN_CASE(JSOP_DECGVAR)
31481:     FAST_GLOBAL_INCREMENT_OP(JSOP_DECNAME, -2, -2);
31481: BEGIN_CASE(JSOP_GVARDEC)
31481:     FAST_GLOBAL_INCREMENT_OP(JSOP_NAMEDEC, -2,  0);
31481: BEGIN_CASE(JSOP_INCGVAR)
31481:     FAST_GLOBAL_INCREMENT_OP(JSOP_INCNAME,  2,  2);
31481: BEGIN_CASE(JSOP_GVARINC)
31481:     FAST_GLOBAL_INCREMENT_OP(JSOP_NAMEINC,  2,  0);
31481: 
31481: #undef FAST_GLOBAL_INCREMENT_OP
31481: 
31481:   do_global_incop:
31481:     JS_ASSERT((js_CodeSpec[op].format & JOF_TMPSLOT_MASK) ==
31481:               JOF_TMPSLOT2);
31481:     slot = GET_SLOTNO(regs.pc);
31481:     JS_ASSERT(slot < GlobalVarCount(fp));
31481:     METER_SLOT_OP(op, slot);
31481:     lval = fp->slots[slot];
31481:     if (JSVAL_IS_NULL(lval)) {
31481:         op = op2;
31481:         DO_OP();
31481:     }
31481:     slot = JSVAL_TO_INT(lval);
37777:     JS_ASSERT(fp->varobj(cx) == cx->activeCallStack()->getInitialVarObj());
40430:     rval = cx->activeCallStack()->getInitialVarObj()->getSlotMT(cx, slot);
31481:     if (JS_LIKELY(CAN_DO_FAST_INC_DEC(rval))) {
31481:         PUSH_OPND(rval + incr2);
31481:         rval += incr;
31481:     } else {
31481:         PUSH_OPND(rval);
31481:         PUSH_OPND(JSVAL_NULL);  /* Extra root */
31481:         if (!js_DoIncDec(cx, &js_CodeSpec[op], &regs.sp[-2], &regs.sp[-1]))
31481:             goto error;
31481:         rval = regs.sp[-1];
31481:         --regs.sp;
31481:     }
40430:     fp->varobj(cx)->setSlotMT(cx, slot, rval);
31481:     len = JSOP_INCGVAR_LENGTH;  /* all gvar incops are same length */
31481:     JS_ASSERT(len == js_CodeSpec[op].length);
31481:     DO_NEXT_OP(len);
31481: }
31481: 
31481: #define COMPUTE_THIS(cx, fp, obj)                                             \
31481:     JS_BEGIN_MACRO                                                            \
40424:         if (!(obj = (fp)->getThisObject(cx)))                                 \
31481:             goto error;                                                       \
31481:     JS_END_MACRO
31481: 
31481: BEGIN_CASE(JSOP_THIS)
31481:     COMPUTE_THIS(cx, fp, obj);
31481:     PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_THIS)
31481: 
38549: BEGIN_CASE(JSOP_UNBRANDTHIS)
38549:     COMPUTE_THIS(cx, fp, obj);
38549:     if (!obj->unbrand(cx))
38549:         goto error;
38549: END_CASE(JSOP_UNBRANDTHIS)
38549: 
31481: BEGIN_CASE(JSOP_GETTHISPROP)
31481:     i = 0;
31481:     COMPUTE_THIS(cx, fp, obj);
31481:     PUSH(JSVAL_NULL);
31481:     goto do_getprop_with_obj;
31481: 
31481: #undef COMPUTE_THIS
31481: 
31481: BEGIN_CASE(JSOP_GETARGPROP)
31481:     i = ARGNO_LEN;
31481:     slot = GET_ARGNO(regs.pc);
31481:     JS_ASSERT(slot < fp->fun->nargs);
31481:     PUSH_OPND(fp->argv[slot]);
31481:     goto do_getprop_body;
31481: 
31481: BEGIN_CASE(JSOP_GETLOCALPROP)
31481:     i = SLOTNO_LEN;
31481:     slot = GET_SLOTNO(regs.pc);
31481:     JS_ASSERT(slot < script->nslots);
31481:     PUSH_OPND(fp->slots[slot]);
31481:     goto do_getprop_body;
31481: 
31481: BEGIN_CASE(JSOP_GETPROP)
31481: BEGIN_CASE(JSOP_GETXPROP)
31481:     i = 0;
31481: 
31481:   do_getprop_body:
31481:     lval = FETCH_OPND(-1);
31481: 
31481:   do_getprop_with_lval:
31481:     VALUE_TO_OBJECT(cx, -1, lval, obj);
31481: 
31481:   do_getprop_with_obj:
31481:     do {
31481:         JSObject *aobj;
40362:         PropertyCacheEntry *entry;
31481: 
32658:         /*
32658:          * We do not impose the method read barrier if in an imacro,
32658:          * assuming any property gets it does (e.g., for 'toString'
32658:          * from JSOP_NEW) will not be leaked to the calling script.
32658:          */
39928:         aobj = js_GetProtoIfDenseArray(obj);
40392: 
40362:         JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
31481:         if (!atom) {
31481:             ASSERT_VALID_PROPERTY_CACHE_HIT(i, aobj, obj2, entry);
40374:             if (entry->vword.isObject()) {
40374:                 rval = entry->vword.toJsval();
40374:             } else if (entry->vword.isSlot()) {
40374:                 slot = entry->vword.toSlot();
40847:                 JS_ASSERT(slot < obj2->scope()->freeslot);
40847:                 rval = obj2->lockedGetSlot(slot);
31481:             } else {
40374:                 JS_ASSERT(entry->vword.isSprop());
40374:                 sprop = entry->vword.toSprop();
32658:                 NATIVE_GET(cx, obj, obj2, sprop,
32658:                            fp->imacpc ? JSGET_NO_METHOD_BARRIER : JSGET_METHOD_BARRIER,
32658:                            &rval);
31481:             }
31481:             break;
31481:         }
40392: 
31481:         id = ATOM_TO_JSID(atom);
40392:         if (JS_LIKELY(aobj->map->ops->getProperty == js_GetProperty)
32658:             ? !js_GetPropertyHelper(cx, obj, id,
32658:                                     fp->imacpc
32658:                                     ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
32658:                                     : JSGET_CACHE_RESULT | JSGET_METHOD_BARRIER,
32658:                                     &rval)
31501:             : !obj->getProperty(cx, id, &rval)) {
31481:             goto error;
31481:         }
31481:     } while (0);
31481: 
31481:     STORE_OPND(-1, rval);
31481:     JS_ASSERT(JSOP_GETPROP_LENGTH + i == js_CodeSpec[op].length);
31481:     len = JSOP_GETPROP_LENGTH + i;
31481: END_VARLEN_CASE
31481: 
31481: BEGIN_CASE(JSOP_LENGTH)
31481:     lval = FETCH_OPND(-1);
31481:     if (JSVAL_IS_STRING(lval)) {
31481:         str = JSVAL_TO_STRING(lval);
31481:         regs.sp[-1] = INT_TO_JSVAL(str->length());
40405:     } else if (!JSVAL_IS_PRIMITIVE(lval)) {
40405:         obj = JSVAL_TO_OBJECT(lval);
40405:         if (obj->isArray()) {
40796:             jsuint length = obj->getArrayLength();
40405: 
40405:             if (length <= JSVAL_INT_MAX)
31481:                 regs.sp[-1] = INT_TO_JSVAL(length);
40405:             else if (!js_NewDoubleInRootedValue(cx, (jsdouble) length, &regs.sp[-1]))
31481:                 goto error;
40864:         } else if (obj->isArguments() && !obj->isArgsLengthOverridden()) {
40864:             uint32 length = obj->getArgsLength();
40405: 
40405:             JS_ASSERT(INT_FITS_IN_JSVAL(length));
40405:             regs.sp[-1] = INT_TO_JSVAL(length);
40405:         } else {
40405:             i = -2;
40405:             goto do_getprop_with_lval;
31481:         }
31481:     } else {
31481:         i = -2;
31481:         goto do_getprop_with_lval;
31481:     }
31481: END_CASE(JSOP_LENGTH)
31481: 
31481: BEGIN_CASE(JSOP_CALLPROP)
31481: {
31481:     JSObject *aobj;
40362:     PropertyCacheEntry *entry;
31481: 
31481:     lval = FETCH_OPND(-1);
31481:     if (!JSVAL_IS_PRIMITIVE(lval)) {
31481:         obj = JSVAL_TO_OBJECT(lval);
31481:     } else {
38604:         JSProtoKey protoKey;
31481:         if (JSVAL_IS_STRING(lval)) {
38604:             protoKey = JSProto_String;
31481:         } else if (JSVAL_IS_NUMBER(lval)) {
38604:             protoKey = JSProto_Number;
31481:         } else if (JSVAL_IS_BOOLEAN(lval)) {
38604:             protoKey = JSProto_Boolean;
31481:         } else {
31481:             JS_ASSERT(JSVAL_IS_NULL(lval) || JSVAL_IS_VOID(lval));
31481:             js_ReportIsNullOrUndefined(cx, -1, lval, NULL);
31481:             goto error;
31481:         }
38604:         if (!js_GetClassPrototype(cx, NULL, protoKey, &obj))
31481:             goto error;
31481:     }
31481: 
39928:     aobj = js_GetProtoIfDenseArray(obj);
40392: 
40362:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, aobj, obj2, entry, atom);
31481:     if (!atom) {
31481:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, aobj, obj2, entry);
40374:         if (entry->vword.isObject()) {
40374:             rval = entry->vword.toJsval();
40374:         } else if (entry->vword.isSlot()) {
40374:             slot = entry->vword.toSlot();
40847:             JS_ASSERT(slot < obj2->scope()->freeslot);
40847:             rval = obj2->lockedGetSlot(slot);
31481:         } else {
40374:             JS_ASSERT(entry->vword.isSprop());
40374:             sprop = entry->vword.toSprop();
32658:             NATIVE_GET(cx, obj, obj2, sprop, JSGET_NO_METHOD_BARRIER, &rval);
31481:         }
31481:         STORE_OPND(-1, rval);
31481:         PUSH_OPND(lval);
31481:         goto end_callprop;
31481:     }
31481: 
31481:     /*
31481:      * Cache miss: use the immediate atom that was loaded for us under
40362:      * PropertyCache::test.
31481:      */
31481:     id = ATOM_TO_JSID(atom);
31481:     PUSH(JSVAL_NULL);
31481:     if (!JSVAL_IS_PRIMITIVE(lval)) {
32658:         if (!js_GetMethod(cx, obj, id,
40392:                           JS_LIKELY(aobj->map->ops->getProperty == js_GetProperty)
32658:                           ? JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER
32658:                           : JSGET_NO_METHOD_BARRIER,
32658:                           &rval)) {
31481:             goto error;
32658:         }
31481:         STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
31481:         STORE_OPND(-2, rval);
31481:     } else {
31481:         JS_ASSERT(obj->map->ops->getProperty == js_GetProperty);
32658:         if (!js_GetPropertyHelper(cx, obj, id,
32658:                                   JSGET_CACHE_RESULT | JSGET_NO_METHOD_BARRIER,
32658:                                   &rval)) {
31481:             goto error;
32658:         }
31481:         STORE_OPND(-1, lval);
31481:         STORE_OPND(-2, rval);
31481:     }
31481: 
31481:   end_callprop:
31481:     /* Wrap primitive lval in object clothing if necessary. */
31481:     if (JSVAL_IS_PRIMITIVE(lval)) {
31481:         /* FIXME: https://bugzilla.mozilla.org/show_bug.cgi?id=412571 */
31481:         if (!VALUE_IS_FUNCTION(cx, rval) ||
31481:             (obj = JSVAL_TO_OBJECT(rval),
31481:              fun = GET_FUNCTION_PRIVATE(cx, obj),
31481:              !PRIMITIVE_THIS_TEST(fun, lval))) {
31481:             if (!js_PrimitiveToObject(cx, &regs.sp[-1]))
31481:                 goto error;
31481:         }
31481:     }
31481: #if JS_HAS_NO_SUCH_METHOD
31481:     if (JS_UNLIKELY(JSVAL_IS_VOID(rval))) {
31481:         LOAD_ATOM(0);
31481:         regs.sp[-2] = ATOM_KEY(atom);
31481:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
31481:             goto error;
31481:     }
31481: #endif
31481: }
31481: END_CASE(JSOP_CALLPROP)
31481: 
37685: BEGIN_CASE(JSOP_UNBRAND)
37685:     JS_ASSERT(regs.sp - fp->slots >= 1);
37685:     lval = FETCH_OPND(-1);
37685:     obj = JSVAL_TO_OBJECT(lval);
37685:     if (!obj->unbrand(cx))
37685:         goto error;
37685: END_CASE(JSOP_UNBRAND)
37685: 
31481: BEGIN_CASE(JSOP_SETNAME)
31481: BEGIN_CASE(JSOP_SETPROP)
32658: BEGIN_CASE(JSOP_SETMETHOD)
31481:     rval = FETCH_OPND(-1);
32658:     JS_ASSERT_IF(op == JSOP_SETMETHOD, VALUE_IS_FUNCTION(cx, rval));
31481:     lval = FETCH_OPND(-2);
32658:     JS_ASSERT_IF(op == JSOP_SETNAME, !JSVAL_IS_PRIMITIVE(lval));
31481:     VALUE_TO_OBJECT(cx, -2, lval, obj);
31481: 
31481:     do {
40392:         PropertyCache *cache = &JS_PROPERTY_CACHE(cx);
40392:         PropertyCacheEntry *entry = NULL;
31481:         atom = NULL;
33121: 
31481:         /*
40391:          * Probe the property cache, specializing for two important
33585:          * set-property cases. First:
31481:          *
31481:          *   function f(a, b, c) {
31481:          *     var o = {p:a, q:b, r:c};
31481:          *     return o;
31481:          *   }
31481:          *
33585:          * or similar real-world cases, which evolve a newborn native
33585:          * object predicatably through some bounded number of property
33585:          * additions. And second:
31481:          *
31481:          *   o.p = x;
31481:          *
33585:          * in a frequently executed method or loop body, where p will
33585:          * (possibly after the first iteration) always exist in native
33585:          * object o.
31481:          */
40391:         if (cache->testForSet(cx, regs.pc, obj, &entry, &obj2, &atom)) {
40327:             /*
40391:              * Fast property cache hit, only partially confirmed by
40391:              * testForSet. We know that the entry applies to regs.pc and
40391:              * that obj's shape matches.
40391:              *
40391:              * The entry predicts either a new property to be added
40391:              * directly to obj by this set, or on an existing "own"
40327:              * property, or on a prototype property that has a setter.
40327:              */
40374:             JS_ASSERT(entry->vword.isSprop());
40374:             sprop = entry->vword.toSprop();
40855:             JS_ASSERT_IF(sprop->isDataDescriptor(), sprop->writable());
40362:             JS_ASSERT_IF(sprop->hasSlot(), entry->vcapTag() == 0);
31481: 
40847:             JSScope *scope = obj->scope();
31481:             JS_ASSERT(!scope->sealed());
31481: 
31481:             /*
33585:              * Fastest path: check whether the cached sprop is already
33585:              * in scope and call NATIVE_SET and break to get out of the
33585:              * do-while(0). But we can call NATIVE_SET only if obj owns
33585:              * scope or sprop is shared.
31481:              */
31481:             bool checkForAdd;
40265:             if (!sprop->hasSlot()) {
40362:                 if (entry->vcapTag() == 0 ||
39928:                     ((obj2 = obj->getProto()) &&
40430:                      obj2->isNative() &&
40847:                      obj2->shape() == entry->vshape())) {
31481:                     goto fast_set_propcache_hit;
31481:                 }
31481: 
31481:                 /* The cache entry doesn't apply. vshape mismatch. */
31481:                 checkForAdd = false;
37766:             } else if (!scope->isSharedEmpty()) {
35453:                 if (sprop == scope->lastProperty() || scope->hasProperty(sprop)) {
31481:                   fast_set_propcache_hit:
31481:                     PCMETER(cache->pchits++);
31481:                     PCMETER(cache->setpchits++);
31481:                     NATIVE_SET(cx, obj, sprop, entry, &rval);
31481:                     break;
31481:                 }
40265:                 checkForAdd = sprop->hasSlot() && sprop->parent == scope->lastProperty();
31481:             } else {
38504:                 /*
38504:                  * We check that cx own obj here and will continue to
38504:                  * own it after js_GetMutableScope returns so we can
38504:                  * continue to skip JS_UNLOCK_OBJ calls.
38504:                  */
38504:                 JS_ASSERT(CX_OWNS_OBJECT_TITLE(cx, obj));
31481:                 scope = js_GetMutableScope(cx, obj);
38504:                 JS_ASSERT(CX_OWNS_OBJECT_TITLE(cx, obj));
38504:                 if (!scope)
31481:                     goto error;
31481:                 checkForAdd = !sprop->parent;
31481:             }
31481: 
40290:             if (checkForAdd &&
40362:                 entry->vshape() == rt->protoHazardShape &&
40290:                 sprop->hasDefaultSetter() &&
31481:                 (slot = sprop->slot) == scope->freeslot) {
31481:                 /*
33585:                  * Fast path: adding a plain old property that was once
33585:                  * at the frontier of the property tree, whose slot is
33585:                  * next to claim among the allocated slots in obj,
33585:                  * where scope->table has not been created yet.
31481:                  *
33585:                  * We may want to remove hazard conditions above and
33585:                  * inline compensation code here, depending on
33585:                  * real-world workloads.
31481:                  */
31481:                 PCMETER(cache->pchits++);
31481:                 PCMETER(cache->addpchits++);
31481: 
31481:                 /*
33585:                  * Beware classes such as Function that use the
33585:                  * reserveSlots hook to allocate a number of reserved
33585:                  * slots that may vary with obj.
31481:                  */
40410:                 if (slot < obj->numSlots() &&
40826:                     !obj->getClass()->reserveSlots) {
31481:                     ++scope->freeslot;
31481:                 } else {
38504:                     if (!js_AllocSlot(cx, obj, &slot))
31481:                         goto error;
31481:                 }
31481: 
31481:                 /*
33585:                  * If this obj's number of reserved slots differed, or
33585:                  * if something created a hash table for scope, we must
35453:                  * pay the price of JSScope::putProperty.
31481:                  *
36435:                  * (A reserveSlots hook can cause scopes of the same
36435:                  * shape to have different freeslot values. This is
36435:                  * what causes the slot != sprop->slot case. See
36435:                  * js_GetMutableScope.)
31481:                  */
31481:                 if (slot != sprop->slot || scope->table) {
31481:                     JSScopeProperty *sprop2 =
35453:                         scope->putProperty(cx, sprop->id,
39894:                                            sprop->getter(), sprop->setter(),
40265:                                            slot, sprop->attributes(),
38562:                                            sprop->getFlags(), sprop->shortid);
31481:                     if (!sprop2) {
31481:                         js_FreeSlot(cx, obj, slot);
31481:                         goto error;
31481:                     }
31481:                     sprop = sprop2;
31481:                 } else {
31481:                     scope->extend(cx, sprop);
31481:                 }
31481: 
32658:                 /*
33585:                  * No method change check here because here we are
33585:                  * adding a new property, not updating an existing
33585:                  * slot's value that might contain a method of a
33585:                  * branded scope.
32658:                  */
41855:                 TRACE_2(SetPropHit, entry, sprop);
40847:                 obj->lockedSetSlot(slot, rval);
31481: 
31481:                 /*
33585:                  * Purge the property cache of the id we may have just
33585:                  * shadowed in obj's scope and proto chains. We do this
33585:                  * after unlocking obj's scope to avoid lock nesting.
31481:                  */
31481:                 js_PurgeScopeChain(cx, obj, sprop->id);
31481:                 break;
31481:             }
31481:             PCMETER(cache->setpcmisses++);
40391:             atom = NULL;
40391:         } else if (!atom) {
40391:             /*
40391:              * Slower property cache hit, fully confirmed by testForSet (in
40391:              * the slow path, via fullTest).
40391:              */
31481:             ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
31481:             sprop = NULL;
31481:             if (obj == obj2) {
40374:                 sprop = entry->vword.toSprop();
40265:                 JS_ASSERT(sprop->writable());
40847:                 JS_ASSERT(!obj2->scope()->sealed());
31481:                 NATIVE_SET(cx, obj, sprop, entry, &rval);
31481:             }
31481:             if (sprop)
31481:                 break;
31481:         }
31481: 
31481:         if (!atom)
31481:             LOAD_ATOM(0);
31481:         id = ATOM_TO_JSID(atom);
40392:         if (entry && JS_LIKELY(obj->map->ops->setProperty == js_SetProperty)) {
41774:             uintN defineHow;
41774:             if (op == JSOP_SETMETHOD)
41774:                 defineHow = JSDNP_CACHE_RESULT | JSDNP_SET_METHOD;
41774:             else if (op == JSOP_SETNAME)
41774:                 defineHow = JSDNP_CACHE_RESULT | JSDNP_UNQUALIFIED;
41774:             else
41774:                 defineHow = JSDNP_CACHE_RESULT;
32658:             if (!js_SetPropertyHelper(cx, obj, id, defineHow, &rval))
31481:                 goto error;
31481:         } else {
31501:             if (!obj->setProperty(cx, id, &rval))
31481:                 goto error;
31481:             ABORT_RECORDING(cx, "Non-native set");
31481:         }
31481:     } while (0);
31481: END_SET_CASE_STORE_RVAL(JSOP_SETPROP, 2);
31481: 
31481: BEGIN_CASE(JSOP_GETELEM)
31481:     /* Open-coded ELEMENT_OP optimized for strings and dense arrays. */
31481:     lval = FETCH_OPND(-2);
31481:     rval = FETCH_OPND(-1);
31481:     if (JSVAL_IS_STRING(lval) && JSVAL_IS_INT(rval)) {
31481:         str = JSVAL_TO_STRING(lval);
31481:         i = JSVAL_TO_INT(rval);
31481:         if ((size_t)i < str->length()) {
32607:             str = JSString::getUnitString(cx, str, size_t(i));
31481:             if (!str)
31481:                 goto error;
31481:             rval = STRING_TO_JSVAL(str);
31481:             goto end_getelem;
31481:         }
31481:     }
31481: 
31481:     VALUE_TO_OBJECT(cx, -2, lval, obj);
31481:     if (JSVAL_IS_INT(rval)) {
39928:         if (obj->isDenseArray()) {
40405:             jsuint idx = jsuint(JSVAL_TO_INT(rval));
40405: 
40796:             if (idx < obj->getArrayLength() &&
41782:                 idx < obj->getDenseArrayCapacity()) {
41782:                 rval = obj->getDenseArrayElement(idx);
31481:                 if (rval != JSVAL_HOLE)
31481:                     goto end_getelem;
31481: 
31481:                 /* Reload rval from the stack in the rare hole case. */
31481:                 rval = FETCH_OPND(-1);
31481:             }
40405:         } else if (obj->isArguments()
40405: #ifdef JS_TRACER
40405:                    && !GetArgsPrivateNative(obj)
40405: #endif
40405:                   ) {
40405:             uint32 arg = uint32(JSVAL_TO_INT(rval));
40405: 
40864:             if (arg < obj->getArgsLength()) {
40405:                 JSStackFrame *afp = (JSStackFrame *) obj->getPrivate();
40405:                 if (afp) {
40405:                     rval = afp->argv[arg];
40405:                     goto end_getelem;
40405:                 }
40405: 
40405:                 rval = GetArgsSlot(obj, arg);
40405:                 if (rval != JSVAL_HOLE)
40405:                     goto end_getelem;
40405:                 rval = FETCH_OPND(-1);
40405:             }
31481:         }
31481:         id = INT_JSVAL_TO_JSID(rval);
31481:     } else {
31481:         if (!js_InternNonIntElementId(cx, obj, rval, &id))
31481:             goto error;
31481:     }
31481: 
31501:     if (!obj->getProperty(cx, id, &rval))
31481:         goto error;
31481:   end_getelem:
31481:     regs.sp--;
31481:     STORE_OPND(-1, rval);
31481: END_CASE(JSOP_GETELEM)
31481: 
31481: BEGIN_CASE(JSOP_CALLELEM)
32658:     ELEMENT_OP(-1, js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, &rval));
31481: #if JS_HAS_NO_SUCH_METHOD
31481:     if (JS_UNLIKELY(JSVAL_IS_VOID(rval))) {
31481:         regs.sp[-2] = regs.sp[-1];
31481:         regs.sp[-1] = OBJECT_TO_JSVAL(obj);
31481:         if (!js_OnUnknownMethod(cx, regs.sp - 2))
31481:             goto error;
31481:     } else
31481: #endif
31481:     {
31481:         STORE_OPND(-2, rval);
31481:         STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
31481:     }
31481: END_CASE(JSOP_CALLELEM)
31481: 
31481: BEGIN_CASE(JSOP_SETELEM)
31481:     rval = FETCH_OPND(-1);
31481:     FETCH_OBJECT(cx, -3, lval, obj);
31481:     FETCH_ELEMENT_ID(obj, -2, id);
31481:     do {
39928:         if (obj->isDenseArray() && JSID_IS_INT(id)) {
31481:             jsuint length;
31481: 
41782:             length = obj->getDenseArrayCapacity();
31481:             i = JSID_TO_INT(id);
31481:             if ((jsuint)i < length) {
41782:                 if (obj->getDenseArrayElement(i) == JSVAL_HOLE) {
31481:                     if (js_PrototypeHasIndexedProperties(cx, obj))
31481:                         break;
40796:                     if ((jsuint)i >= obj->getArrayLength())
41850:                         obj->setDenseArrayLength(i + 1);
41838:                     obj->incDenseArrayCountBy(1);
31481:                 }
41782:                 obj->setDenseArrayElement(i, rval);
31481:                 goto end_setelem;
31481:             }
31481:         }
31481:     } while (0);
31501:     if (!obj->setProperty(cx, id, &rval))
31481:         goto error;
31481:   end_setelem:
31481: END_SET_CASE_STORE_RVAL(JSOP_SETELEM, 3)
31481: 
31481: BEGIN_CASE(JSOP_ENUMELEM)
31481:     /* Funky: the value to set is under the [obj, id] pair. */
31481:     rval = FETCH_OPND(-3);
31481:     FETCH_OBJECT(cx, -2, lval, obj);
31481:     FETCH_ELEMENT_ID(obj, -1, id);
31501:     if (!obj->setProperty(cx, id, &rval))
31481:         goto error;
31481:     regs.sp -= 3;
31481: END_CASE(JSOP_ENUMELEM)
31481: 
31481: BEGIN_CASE(JSOP_NEW)
31481:     /* Get immediate argc and find the constructor function. */
31481:     argc = GET_ARGC(regs.pc);
31481:     vp = regs.sp - (2 + argc);
31481:     JS_ASSERT(vp >= StackBase(fp));
31481: 
31481:     /*
33585:      * Assign lval, obj, and fun exactly as the code at inline_call: expects to
33585:      * find them, to avoid nesting a js_Interpret call via js_InvokeConstructor.
31481:      */
31481:     lval = *vp;
31481:     if (VALUE_IS_FUNCTION(cx, lval)) {
31481:         obj = JSVAL_TO_OBJECT(lval);
31481:         fun = GET_FUNCTION_PRIVATE(cx, obj);
31481:         if (FUN_INTERPRETED(fun)) {
31481:             /* Root as we go using vp[1]. */
31501:             if (!obj->getProperty(cx,
31501:                                   ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
31481:                                   &vp[1])) {
31481:                 goto error;
31481:             }
31481:             rval = vp[1];
40858:             obj2 = NewObject(cx, &js_ObjectClass,
34290:                              JSVAL_IS_OBJECT(rval) ? JSVAL_TO_OBJECT(rval) : NULL,
39930:                              obj->getParent());
31481:             if (!obj2)
31481:                 goto error;
34290: 
34290:             if (fun->u.i.script->isEmpty()) {
34290:                 *vp = OBJECT_TO_JSVAL(obj2);
34290:                 regs.sp = vp + 1;
34290:                 goto end_new;
34290:             }
34290: 
31481:             vp[1] = OBJECT_TO_JSVAL(obj2);
31481:             flags = JSFRAME_CONSTRUCTING;
31481:             goto inline_call;
31481:         }
31481:     }
31481: 
31481:     if (!js_InvokeConstructor(cx, argc, JS_FALSE, vp))
31481:         goto error;
31481:     regs.sp = vp + 1;
31481:     CHECK_INTERRUPT_HANDLER();
31481:     TRACE_0(NativeCallComplete);
34290: 
34290:   end_new:
31481: END_CASE(JSOP_NEW)
31481: 
31481: BEGIN_CASE(JSOP_CALL)
31481: BEGIN_CASE(JSOP_EVAL)
31481: BEGIN_CASE(JSOP_APPLY)
31481:     argc = GET_ARGC(regs.pc);
31481:     vp = regs.sp - (argc + 2);
31481: 
31481:     lval = *vp;
31481:     if (VALUE_IS_FUNCTION(cx, lval)) {
31481:         obj = JSVAL_TO_OBJECT(lval);
31481:         fun = GET_FUNCTION_PRIVATE(cx, obj);
31481: 
31481:         /* Clear frame flags since this is not a constructor call. */
31481:         flags = 0;
31481:         if (FUN_INTERPRETED(fun))
31481:       inline_call:
31481:         {
31481:             uintN nframeslots, nvars, missing;
31481:             JSArena *a;
31481:             jsuword nbytes;
31481:             void *newmark;
31481:             jsval *newsp;
31481:             JSInlineFrame *newifp;
31481:             JSInterpreterHook hook;
31481: 
34290:             script = fun->u.i.script;
34290:             if (script->isEmpty()) {
34290:                 script = fp->script;
34290:                 *vp = JSVAL_VOID;
34290:                 regs.sp = vp + 1;
34290:                 goto end_call;
34290:             }
34290: 
31481:             /* Restrict recursion of lightweight functions. */
33933:             if (inlineCallCount >= JS_MAX_INLINE_CALL_COUNT) {
31481:                 js_ReportOverRecursed(cx);
34310:                 script = fp->script;
31481:                 goto error;
31481:             }
31481: 
31481:             /* Compute the total number of stack slots needed by fun. */
34290:             nframeslots = JS_HOWMANY(sizeof(JSInlineFrame), sizeof(jsval));
31481:             atoms = script->atomMap.vector;
31481:             nbytes = (nframeslots + script->nslots) * sizeof(jsval);
31481: 
31481:             /* Allocate missing expected args adjacent to actuals. */
31481:             a = cx->stackPool.current;
31481:             newmark = (void *) a->avail;
31481:             if (fun->nargs <= argc) {
31481:                 missing = 0;
31481:             } else {
31481:                 newsp = vp + 2 + fun->nargs;
31481:                 JS_ASSERT(newsp > regs.sp);
31481:                 if ((jsuword) newsp <= a->limit) {
31481:                     if ((jsuword) newsp > a->avail)
31481:                         a->avail = (jsuword) newsp;
31481:                     jsval *argsp = newsp;
31481:                     do {
31481:                         *--argsp = JSVAL_VOID;
31481:                     } while (argsp != regs.sp);
31481:                     missing = 0;
31481:                 } else {
31481:                     missing = fun->nargs - argc;
31481:                     nbytes += (2 + fun->nargs) * sizeof(jsval);
31481:                 }
31481:             }
31481: 
31481:             /* Allocate the inline frame with its slots and operands. */
31481:             if (a->avail + nbytes <= a->limit) {
31481:                 newsp = (jsval *) a->avail;
31481:                 a->avail += nbytes;
31481:                 JS_ASSERT(missing == 0);
31481:             } else {
31481:                 JS_ARENA_ALLOCATE_CAST(newsp, jsval *, &cx->stackPool,
31481:                                        nbytes);
31481:                 if (!newsp) {
31481:                     js_ReportOutOfScriptQuota(cx);
31481:                     goto bad_inline_call;
31481:                 }
31481: 
31481:                 /*
33585:                  * Move args if the missing ones overflow arena a, then push
33585:                  * undefined for the missing args.
31481:                  */
31481:                 if (missing) {
31481:                     memcpy(newsp, vp, (2 + argc) * sizeof(jsval));
31481:                     vp = newsp;
31481:                     newsp = vp + 2 + argc;
31481:                     do {
31481:                         *newsp++ = JSVAL_VOID;
31481:                     } while (--missing != 0);
31481:                 }
31481:             }
31481: 
31481:             /* Claim space for the stack frame and initialize it. */
31481:             newifp = (JSInlineFrame *) newsp;
31481:             newsp += nframeslots;
31481:             newifp->frame.callobj = NULL;
31481:             newifp->frame.argsobj = NULL;
31481:             newifp->frame.script = script;
31481:             newifp->frame.fun = fun;
31481:             newifp->frame.argc = argc;
31481:             newifp->frame.argv = vp + 2;
31481:             newifp->frame.rval = JSVAL_VOID;
31481:             newifp->frame.down = fp;
31481:             newifp->frame.annotation = NULL;
39930:             newifp->frame.scopeChain = parent = obj->getParent();
31481:             newifp->frame.flags = flags;
31481:             newifp->frame.blockChain = NULL;
31481:             if (script->staticLevel < JS_DISPLAY_SIZE) {
31481:                 JSStackFrame **disp = &cx->display[script->staticLevel];
31481:                 newifp->frame.displaySave = *disp;
31481:                 *disp = &newifp->frame;
31481:             }
31481:             newifp->mark = newmark;
31481: 
31481:             /* Compute the 'this' parameter now that argv is set. */
31481:             JS_ASSERT(!JSFUN_BOUND_METHOD_TEST(fun->flags));
32774:             newifp->frame.thisv = vp[1];
31481: 
31481:             newifp->frame.regs = NULL;
31481:             newifp->frame.imacpc = NULL;
31481:             newifp->frame.slots = newsp;
31481: 
31481:             /* Push void to initialize local variables. */
31481:             nvars = fun->u.i.nvars;
31481:             while (nvars--)
31481:                 *newsp++ = JSVAL_VOID;
31481: 
31481:             /* Scope with a call object parented by callee's parent. */
31481:             if (JSFUN_HEAVYWEIGHT_TEST(fun->flags) &&
31481:                 !js_GetCallObject(cx, &newifp->frame)) {
31481:                 goto bad_inline_call;
31481:             }
31481: 
31481:             /* Switch version if currentVersion wasn't overridden. */
31481:             newifp->callerVersion = (JSVersion) cx->version;
31481:             if (JS_LIKELY(cx->version == currentVersion)) {
31481:                 currentVersion = (JSVersion) script->version;
31481:                 if (currentVersion != cx->version)
31481:                     js_SetVersion(cx, currentVersion);
31481:             }
31481: 
31481:             /* Push the frame and set interpreter registers. */
31481:             newifp->callerRegs = regs;
31481:             fp->regs = &newifp->callerRegs;
31481:             regs.sp = newsp;
31481:             regs.pc = script->code;
31481:             newifp->frame.regs = &regs;
31481:             cx->fp = fp = &newifp->frame;
31481: 
31481:             /* Call the debugger hook if present. */
31481:             hook = cx->debugHooks->callHook;
31481:             if (hook) {
31481:                 newifp->hookData = hook(cx, &newifp->frame, JS_TRUE, 0,
31481:                                         cx->debugHooks->callHookData);
31481:                 CHECK_INTERRUPT_HANDLER();
31481:             } else {
31481:                 newifp->hookData = NULL;
31481:             }
31481: 
31481:             inlineCallCount++;
31481:             JS_RUNTIME_METER(rt, inlineCalls);
31481: 
31481: #ifdef INCLUDE_MOZILLA_DTRACE
31481:             /* DTrace function entry, inlines */
31481:             if (JAVASCRIPT_FUNCTION_ENTRY_ENABLED())
31481:                 jsdtrace_function_entry(cx, fp, fun);
31481:             if (JAVASCRIPT_FUNCTION_INFO_ENABLED())
31481:                 jsdtrace_function_info(cx, fp, fp->down, fun);
31481:             if (JAVASCRIPT_FUNCTION_ARGS_ENABLED())
31481:                 jsdtrace_function_args(cx, fp, fun, fp->argc, fp->argv);
31481: #endif
31481: 
33564: #ifdef JS_TRACER
41777:             if (TraceRecorder *tr = TRACE_RECORDER(cx)) {
41777:                 AbortableRecordingStatus status = tr->record_EnterFrame(inlineCallCount);
41777:                 RESTORE_INTERP_VARS();
41777:                 if (StatusAbortsRecorderIfActive(status)) {
33564:                     if (TRACE_RECORDER(cx)) {
41777:                         JS_ASSERT(TRACE_RECORDER(cx) == tr);
41777:                         AbortRecording(cx, "record_EnterFrame failed");
41777:                     }
41777:                     if (status == ARECORD_ERROR)
41777:                         goto error;
41777:                 }
33564:             } else if (fp->script == fp->down->script &&
33948:                        *fp->down->regs->pc == JSOP_CALL &&
33948:                        *fp->regs->pc == JSOP_TRACE) {
34351:                 MONITOR_BRANCH(Record_EnterFrame);
33564:             }
33564: #endif
33564: 
31481:             /* Load first op and dispatch it (safe since JSOP_STOP). */
31481:             op = (JSOp) *regs.pc;
31481:             DO_OP();
31481: 
31481:           bad_inline_call:
31481:             JS_ASSERT(fp->regs == &regs);
31481:             script = fp->script;
31481:             atoms = script->atomMap.vector;
31481:             js_FreeRawStack(cx, newmark);
31481:             goto error;
31481:         }
31481: 
31481:         if (fun->flags & JSFUN_FAST_NATIVE) {
31481: #ifdef INCLUDE_MOZILLA_DTRACE
31481:             /* DTrace function entry, non-inlines */
31481:             if (VALUE_IS_FUNCTION(cx, lval)) {
31481:                 if (JAVASCRIPT_FUNCTION_ENTRY_ENABLED())
31481:                     jsdtrace_function_entry(cx, NULL, fun);
31481:                 if (JAVASCRIPT_FUNCTION_INFO_ENABLED())
31481:                     jsdtrace_function_info(cx, NULL, fp, fun);
31481:                 if (JAVASCRIPT_FUNCTION_ARGS_ENABLED())
31481:                     jsdtrace_function_args(cx, fp, fun, argc, vp+2);
31481:             }
31481: #endif
31481: 
31481:             JS_ASSERT(fun->u.n.extra == 0);
31481:             JS_ASSERT(JSVAL_IS_OBJECT(vp[1]) ||
31481:                       PRIMITIVE_THIS_TEST(fun, vp[1]));
31481:             ok = ((JSFastNative) fun->u.n.native)(cx, argc, vp);
31481: #ifdef INCLUDE_MOZILLA_DTRACE
31481:             if (VALUE_IS_FUNCTION(cx, lval)) {
31481:                 if (JAVASCRIPT_FUNCTION_RVAL_ENABLED())
31481:                     jsdtrace_function_rval(cx, NULL, fun, vp);
31481:                 if (JAVASCRIPT_FUNCTION_RETURN_ENABLED())
31481:                     jsdtrace_function_return(cx, NULL, fun);
31481:             }
31481: #endif
31481:             regs.sp = vp + 1;
31481:             if (!ok) {
31481:                 /*
33585:                  * If we are executing the JSOP_NEXTITER imacro and a
33585:                  * Stopiteration exception is raised, transform it into a
33585:                  * JSVAL_HOLE return value.  The tracer generates equivalent
33585:                  * code by calling CatchStopIteration_tn.
31481:                  */
31481:                 if (fp->imacpc && *fp->imacpc == JSOP_NEXTITER &&
31481:                     cx->throwing && js_ValueIsStopIteration(cx->exception)) {
31481:                     // pc may point to JSOP_DUP here due to bug 474854.
33564:                     JS_ASSERT(*regs.pc == JSOP_CALL ||
33564:                               *regs.pc == JSOP_DUP);
31481:                     cx->throwing = JS_FALSE;
31481:                     cx->exception = JSVAL_VOID;
31481:                     regs.sp[-1] = JSVAL_HOLE;
31481:                 } else {
31481:                     goto error;
31481:                 }
31481:             }
31481:             TRACE_0(NativeCallComplete);
31481:             goto end_call;
31481:         }
31481:     }
31481: 
31481:     ok = js_Invoke(cx, argc, vp, 0);
31481:     regs.sp = vp + 1;
31481:     CHECK_INTERRUPT_HANDLER();
31481:     if (!ok)
31481:         goto error;
31481:     JS_RUNTIME_METER(rt, nonInlineCalls);
31481:     TRACE_0(NativeCallComplete);
31481: 
31481:   end_call:
31481: END_CASE(JSOP_CALL)
31481: 
31481: BEGIN_CASE(JSOP_SETCALL)
31481:     argc = GET_ARGC(regs.pc);
31481:     vp = regs.sp - argc - 2;
31817:     if (js_Invoke(cx, argc, vp, 0))
31817:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_LEFTSIDE_OF_ASS);
31481:     goto error;
31481: END_CASE(JSOP_SETCALL)
31481: 
31481: BEGIN_CASE(JSOP_NAME)
31481: BEGIN_CASE(JSOP_CALLNAME)
31481: {
40362:     PropertyCacheEntry *entry;
31481: 
31481:     obj = fp->scopeChain;
40392: 
40362:     JS_PROPERTY_CACHE(cx).test(cx, regs.pc, obj, obj2, entry, atom);
31481:     if (!atom) {
31481:         ASSERT_VALID_PROPERTY_CACHE_HIT(0, obj, obj2, entry);
40374:         if (entry->vword.isObject()) {
40374:             rval = entry->vword.toJsval();
31481:             goto do_push_rval;
31481:         }
31481: 
40374:         if (entry->vword.isSlot()) {
40374:             slot = entry->vword.toSlot();
40847:             JS_ASSERT(slot < obj2->scope()->freeslot);
40847:             rval = obj2->lockedGetSlot(slot);
31481:             goto do_push_rval;
31481:         }
31481: 
40374:         JS_ASSERT(entry->vword.isSprop());
40374:         sprop = entry->vword.toSprop();
31481:         goto do_native_get;
31481:     }
31481: 
31481:     id = ATOM_TO_JSID(atom);
31481:     if (!js_FindPropertyHelper(cx, id, true, &obj, &obj2, &prop))
31481:         goto error;
31481:     if (!prop) {
31481:         /* Kludge to allow (typeof foo == "undefined") tests. */
31481:         endpc = script->code + script->length;
31481:         op2 = js_GetOpcode(cx, script, regs.pc + JSOP_NAME_LENGTH);
31481:         if (op2 == JSOP_TYPEOF) {
31481:             PUSH_OPND(JSVAL_VOID);
31481:             len = JSOP_NAME_LENGTH;
31481:             DO_NEXT_OP(len);
31481:         }
31481:         goto atom_not_defined;
31481:     }
31481: 
31481:     /* Take the slow path if prop was not found in a native object. */
40430:     if (!obj->isNative() || !obj2->isNative()) {
31501:         obj2->dropProperty(cx, prop);
31501:         if (!obj->getProperty(cx, id, &rval))
31481:             goto error;
31481:     } else {
31481:         sprop = (JSScopeProperty *)prop;
31481:   do_native_get:
32658:         NATIVE_GET(cx, obj, obj2, sprop, JSGET_METHOD_BARRIER, &rval);
31501:         obj2->dropProperty(cx, (JSProperty *) sprop);
31481:     }
31481: 
31481:   do_push_rval:
31481:     PUSH_OPND(rval);
31481:     if (op == JSOP_CALLNAME)
31481:         PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: }
31481: END_CASE(JSOP_NAME)
31481: 
31481: BEGIN_CASE(JSOP_UINT16)
31481:     i = (jsint) GET_UINT16(regs.pc);
31481:     rval = INT_TO_JSVAL(i);
31481:     PUSH_OPND(rval);
31481: END_CASE(JSOP_UINT16)
31481: 
31481: BEGIN_CASE(JSOP_UINT24)
31481:     i = (jsint) GET_UINT24(regs.pc);
31481:     rval = INT_TO_JSVAL(i);
31481:     PUSH_OPND(rval);
31481: END_CASE(JSOP_UINT24)
31481: 
31481: BEGIN_CASE(JSOP_INT8)
31481:     i = GET_INT8(regs.pc);
31481:     rval = INT_TO_JSVAL(i);
31481:     PUSH_OPND(rval);
31481: END_CASE(JSOP_INT8)
31481: 
31481: BEGIN_CASE(JSOP_INT32)
31481:     i = GET_INT32(regs.pc);
31481:     rval = INT_TO_JSVAL(i);
31481:     PUSH_OPND(rval);
31481: END_CASE(JSOP_INT32)
31481: 
31481: BEGIN_CASE(JSOP_INDEXBASE)
31481:     /*
33585:      * Here atoms can exceed script->atomMap.length as we use atoms as a
33585:      * segment register for object literals as well.
31481:      */
31481:     atoms += GET_INDEXBASE(regs.pc);
31481: END_CASE(JSOP_INDEXBASE)
31481: 
31481: BEGIN_CASE(JSOP_INDEXBASE1)
31481: BEGIN_CASE(JSOP_INDEXBASE2)
31481: BEGIN_CASE(JSOP_INDEXBASE3)
31481:     atoms += (op - JSOP_INDEXBASE1 + 1) << 16;
31481: END_CASE(JSOP_INDEXBASE3)
31481: 
31481: BEGIN_CASE(JSOP_RESETBASE0)
31481: BEGIN_CASE(JSOP_RESETBASE)
31481:     atoms = script->atomMap.vector;
31481: END_CASE(JSOP_RESETBASE)
31481: 
31481: BEGIN_CASE(JSOP_DOUBLE)
32673:     JS_ASSERT(!fp->imacpc);
32688:     JS_ASSERT(size_t(atoms - script->atomMap.vector) < script->atomMap.length);
32673:     /* FALL THROUGH */
32673: 
31481: BEGIN_CASE(JSOP_STRING)
31481:     LOAD_ATOM(0);
31481:     PUSH_OPND(ATOM_KEY(atom));
31481: END_CASE(JSOP_DOUBLE)
31481: 
31481: BEGIN_CASE(JSOP_OBJECT)
31481:     LOAD_OBJECT(0);
31481:     PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_OBJECT)
31481: 
38604: BEGIN_CASE(JSOP_REGEXP) {
31481:     /*
37029:      * Push a regexp object cloned from the regexp literal object mapped by the
37029:      * bytecode at pc. ES5 finally fixed this bad old ES3 design flaw which was
37029:      * flouted by many browser-based implementations.
31481:      *
38604:      * We avoid the js_GetScopeChain call here and pass fp->scopeChain as
38604:      * js_GetClassPrototype uses the latter only to locate the global.
31481:      */
31481:     index = GET_FULL_INDEX(0);
38604:     JSObject *proto;
38604:     if (!js_GetClassPrototype(cx, fp->scopeChain, JSProto_RegExp, &proto))
38604:         goto error;
38604:     JS_ASSERT(proto);
38604:     obj = js_CloneRegExpObject(cx, script->getRegExp(index), proto);
31481:     if (!obj)
31481:         goto error;
31481:     rval = OBJECT_TO_JSVAL(obj);
31481:     PUSH_OPND(rval);
38604: }
31481: END_CASE(JSOP_REGEXP)
31481: 
31481: BEGIN_CASE(JSOP_ZERO)
31481:     PUSH_OPND(JSVAL_ZERO);
31481: END_CASE(JSOP_ZERO)
31481: 
31481: BEGIN_CASE(JSOP_ONE)
31481:     PUSH_OPND(JSVAL_ONE);
31481: END_CASE(JSOP_ONE)
31481: 
31481: BEGIN_CASE(JSOP_NULL)
31481:     PUSH_OPND(JSVAL_NULL);
31481: END_CASE(JSOP_NULL)
31481: 
31481: BEGIN_CASE(JSOP_FALSE)
31481:     PUSH_OPND(JSVAL_FALSE);
31481: END_CASE(JSOP_FALSE)
31481: 
31481: BEGIN_CASE(JSOP_TRUE)
31481:     PUSH_OPND(JSVAL_TRUE);
31481: END_CASE(JSOP_TRUE)
31481: 
31481: BEGIN_CASE(JSOP_TABLESWITCH)
31481:     pc2 = regs.pc;
31481:     len = GET_JUMP_OFFSET(pc2);
31481: 
31481:     /*
33585:      * ECMAv2+ forbids conversion of discriminant, so we will skip to the
33585:      * default case if the discriminant isn't already an int jsval.  (This
33585:      * opcode is emitted only for dense jsint-domain switches.)
31481:      */
31481:     rval = POP_OPND();
31481:     if (JSVAL_IS_INT(rval)) {
31481:         i = JSVAL_TO_INT(rval);
31481:     } else if (JSVAL_IS_DOUBLE(rval) && *JSVAL_TO_DOUBLE(rval) == 0) {
31481:         /* Treat -0 (double) as 0. */
31481:         i = 0;
31481:     } else {
31481:         DO_NEXT_OP(len);
31481:     }
31481: 
31481:     pc2 += JUMP_OFFSET_LEN;
31481:     low = GET_JUMP_OFFSET(pc2);
31481:     pc2 += JUMP_OFFSET_LEN;
31481:     high = GET_JUMP_OFFSET(pc2);
31481: 
31481:     i -= low;
31481:     if ((jsuint)i < (jsuint)(high - low + 1)) {
31481:         pc2 += JUMP_OFFSET_LEN + JUMP_OFFSET_LEN * i;
31481:         off = (jsint) GET_JUMP_OFFSET(pc2);
31481:         if (off)
31481:             len = off;
31481:     }
31481: END_VARLEN_CASE
31481: 
31481: BEGIN_CASE(JSOP_TABLESWITCHX)
31481:     pc2 = regs.pc;
31481:     len = GET_JUMPX_OFFSET(pc2);
31481: 
31481:     /*
33585:      * ECMAv2+ forbids conversion of discriminant, so we will skip to the
33585:      * default case if the discriminant isn't already an int jsval.  (This
33585:      * opcode is emitted only for dense jsint-domain switches.)
31481:      */
31481:     rval = POP_OPND();
31481:     if (JSVAL_IS_INT(rval)) {
31481:         i = JSVAL_TO_INT(rval);
31481:     } else if (JSVAL_IS_DOUBLE(rval) && *JSVAL_TO_DOUBLE(rval) == 0) {
31481:         /* Treat -0 (double) as 0. */
31481:         i = 0;
31481:     } else {
31481:         DO_NEXT_OP(len);
31481:     }
31481: 
31481:     pc2 += JUMPX_OFFSET_LEN;
31481:     low = GET_JUMP_OFFSET(pc2);
31481:     pc2 += JUMP_OFFSET_LEN;
31481:     high = GET_JUMP_OFFSET(pc2);
31481: 
31481:     i -= low;
31481:     if ((jsuint)i < (jsuint)(high - low + 1)) {
31481:         pc2 += JUMP_OFFSET_LEN + JUMPX_OFFSET_LEN * i;
31481:         off = (jsint) GET_JUMPX_OFFSET(pc2);
31481:         if (off)
31481:             len = off;
31481:     }
31481: END_VARLEN_CASE
31481: 
31481: BEGIN_CASE(JSOP_LOOKUPSWITCHX)
31481:     off = JUMPX_OFFSET_LEN;
31481:     goto do_lookup_switch;
31481: 
31481: BEGIN_CASE(JSOP_LOOKUPSWITCH)
31481:     off = JUMP_OFFSET_LEN;
31481: 
31481:   do_lookup_switch:
31481:     /*
33585:      * JSOP_LOOKUPSWITCH and JSOP_LOOKUPSWITCHX are never used if any atom
33585:      * index in it would exceed 64K limit.
31481:      */
32673:     JS_ASSERT(!fp->imacpc);
31481:     JS_ASSERT(atoms == script->atomMap.vector);
31481:     pc2 = regs.pc;
31481:     lval = POP_OPND();
31481: 
37036:     if (!JSVAL_IS_PRIMITIVE(lval))
31481:         goto end_lookup_switch;
31481: 
31481:     pc2 += off;
31481:     npairs = (jsint) GET_UINT16(pc2);
31481:     pc2 += UINT16_LEN;
31481:     JS_ASSERT(npairs);  /* empty switch uses JSOP_TABLESWITCH */
31481: 
31481: #define SEARCH_PAIRS(MATCH_CODE)                                              \
31481:     for (;;) {                                                                \
31481:         JS_ASSERT(GET_INDEX(pc2) < script->atomMap.length);                   \
31481:         atom = atoms[GET_INDEX(pc2)];                                         \
31481:         rval = ATOM_KEY(atom);                                                \
31481:         MATCH_CODE                                                            \
31481:         pc2 += INDEX_LEN;                                                     \
31481:         if (match)                                                            \
31481:             break;                                                            \
31481:         pc2 += off;                                                           \
31481:         if (--npairs == 0) {                                                  \
31481:             pc2 = regs.pc;                                                    \
31481:             break;                                                            \
31481:         }                                                                     \
31481:     }
33585: 
31481:     if (JSVAL_IS_STRING(lval)) {
31481:         str = JSVAL_TO_STRING(lval);
31481:         SEARCH_PAIRS(
31481:             match = (JSVAL_IS_STRING(rval) &&
31481:                      ((str2 = JSVAL_TO_STRING(rval)) == str ||
31481:                       js_EqualStrings(str2, str)));
31481:         )
31481:     } else if (JSVAL_IS_DOUBLE(lval)) {
31481:         d = *JSVAL_TO_DOUBLE(lval);
31481:         SEARCH_PAIRS(
31481:             match = (JSVAL_IS_DOUBLE(rval) &&
31481:                      *JSVAL_TO_DOUBLE(rval) == d);
31481:         )
31481:     } else {
31481:         SEARCH_PAIRS(
31481:             match = (lval == rval);
31481:         )
31481:     }
31481: #undef SEARCH_PAIRS
31481: 
31481:   end_lookup_switch:
31481:     len = (op == JSOP_LOOKUPSWITCH)
31481:           ? GET_JUMP_OFFSET(pc2)
31481:           : GET_JUMPX_OFFSET(pc2);
31481: END_VARLEN_CASE
31481: 
31481: BEGIN_CASE(JSOP_TRAP)
31481: {
31481:     JSTrapStatus status;
31481: 
31481:     status = JS_HandleTrap(cx, script, regs.pc, &rval);
31481:     switch (status) {
31481:       case JSTRAP_ERROR:
31481:         goto error;
31481:       case JSTRAP_RETURN:
31481:         fp->rval = rval;
31481:         ok = JS_TRUE;
31481:         goto forced_return;
31481:       case JSTRAP_THROW:
31481:         cx->throwing = JS_TRUE;
31481:         cx->exception = rval;
31481:         goto error;
33585:       default:
31481:         break;
31481:     }
31481:     JS_ASSERT(status == JSTRAP_CONTINUE);
31481:     CHECK_INTERRUPT_HANDLER();
31481:     JS_ASSERT(JSVAL_IS_INT(rval));
31481:     op = (JSOp) JSVAL_TO_INT(rval);
31481:     JS_ASSERT((uintN)op < (uintN)JSOP_LIMIT);
31481:     DO_OP();
31481: }
31481: 
31481: BEGIN_CASE(JSOP_ARGUMENTS)
31481:     if (!js_GetArgsValue(cx, fp, &rval))
31481:         goto error;
31481:     PUSH_OPND(rval);
31481: END_CASE(JSOP_ARGUMENTS)
31481: 
31481: BEGIN_CASE(JSOP_ARGSUB)
31481:     id = INT_TO_JSID(GET_ARGNO(regs.pc));
31481:     if (!js_GetArgsProperty(cx, fp, id, &rval))
31481:         goto error;
31481:     PUSH_OPND(rval);
31481: END_CASE(JSOP_ARGSUB)
31481: 
31481: BEGIN_CASE(JSOP_ARGCNT)
31481:     id = ATOM_TO_JSID(rt->atomState.lengthAtom);
31481:     if (!js_GetArgsProperty(cx, fp, id, &rval))
31481:         goto error;
31481:     PUSH_OPND(rval);
31481: END_CASE(JSOP_ARGCNT)
31481: 
31481: BEGIN_CASE(JSOP_GETARG)
31481: BEGIN_CASE(JSOP_CALLARG)
31481:     slot = GET_ARGNO(regs.pc);
31481:     JS_ASSERT(slot < fp->fun->nargs);
31481:     METER_SLOT_OP(op, slot);
31481:     PUSH_OPND(fp->argv[slot]);
31481:     if (op == JSOP_CALLARG)
31481:         PUSH_OPND(JSVAL_NULL);
31481: END_CASE(JSOP_GETARG)
31481: 
31481: BEGIN_CASE(JSOP_SETARG)
31481:     slot = GET_ARGNO(regs.pc);
31481:     JS_ASSERT(slot < fp->fun->nargs);
31481:     METER_SLOT_OP(op, slot);
31481:     vp = &fp->argv[slot];
31481:     *vp = FETCH_OPND(-1);
31481: END_SET_CASE(JSOP_SETARG)
31481: 
31481: BEGIN_CASE(JSOP_GETLOCAL)
31481:     slot = GET_SLOTNO(regs.pc);
31481:     JS_ASSERT(slot < script->nslots);
31481:     PUSH_OPND(fp->slots[slot]);
31481: END_CASE(JSOP_GETLOCAL)
31481: 
31481: BEGIN_CASE(JSOP_CALLLOCAL)
31481:     slot = GET_SLOTNO(regs.pc);
31481:     JS_ASSERT(slot < script->nslots);
31481:     PUSH_OPND(fp->slots[slot]);
31481:     PUSH_OPND(JSVAL_NULL);
31481: END_CASE(JSOP_CALLLOCAL)
31481: 
31481: BEGIN_CASE(JSOP_SETLOCAL)
31481:     slot = GET_SLOTNO(regs.pc);
31481:     JS_ASSERT(slot < script->nslots);
31481:     vp = &fp->slots[slot];
31481:     *vp = FETCH_OPND(-1);
31481: END_SET_CASE(JSOP_SETLOCAL)
31481: 
31481: BEGIN_CASE(JSOP_GETUPVAR)
31481: BEGIN_CASE(JSOP_CALLUPVAR)
31481: {
32723:     JSUpvarArray *uva = script->upvars();
31481: 
31481:     index = GET_UINT16(regs.pc);
31481:     JS_ASSERT(index < uva->length);
31481: 
31481:     rval = js_GetUpvar(cx, script->staticLevel, uva->vector[index]);
31481:     PUSH_OPND(rval);
31481: 
31481:     if (op == JSOP_CALLUPVAR)
31481:         PUSH_OPND(JSVAL_NULL);
31481: }
31481: END_CASE(JSOP_GETUPVAR)
31481: 
31481: BEGIN_CASE(JSOP_GETUPVAR_DBG)
31481: BEGIN_CASE(JSOP_CALLUPVAR_DBG)
31481:     fun = fp->fun;
31481:     JS_ASSERT(FUN_KIND(fun) == JSFUN_INTERPRETED);
31481:     JS_ASSERT(fun->u.i.wrapper);
31481: 
31481:     /* Scope for tempPool mark and local names allocation in it. */
31481:     {
31481:         void *mark = JS_ARENA_MARK(&cx->tempPool);
31481:         jsuword *names = js_GetLocalNameArray(cx, fun, &cx->tempPool);
31481:         if (!names)
31481:             goto error;
31481: 
31481:         index = fun->countArgsAndVars() + GET_UINT16(regs.pc);
31481:         atom = JS_LOCAL_NAME_TO_ATOM(names[index]);
31481:         id = ATOM_TO_JSID(atom);
31481: 
31481:         ok = js_FindProperty(cx, id, &obj, &obj2, &prop);
31481:         JS_ARENA_RELEASE(&cx->tempPool, mark);
31481:         if (!ok)
31481:             goto error;
31481:     }
31481: 
31481:     if (!prop)
31481:         goto atom_not_defined;
31481: 
31481:     /* Minimize footprint with generic code instead of NATIVE_GET. */
31501:     obj2->dropProperty(cx, prop);
31481:     vp = regs.sp;
31481:     PUSH_OPND(JSVAL_NULL);
31501:     if (!obj->getProperty(cx, id, vp))
31481:         goto error;
31481: 
31481:     if (op == JSOP_CALLUPVAR_DBG)
31481:         PUSH_OPND(JSVAL_NULL);
31481: END_CASE(JSOP_GETUPVAR_DBG)
31481: 
31481: BEGIN_CASE(JSOP_GETDSLOT)
31481: BEGIN_CASE(JSOP_CALLDSLOT)
31939:     JS_ASSERT(fp->argv);
31939:     obj = JSVAL_TO_OBJECT(fp->argv[-2]);
31481:     JS_ASSERT(obj);
35057:     JS_ASSERT(obj->dslots);
31481: 
31481:     index = GET_UINT16(regs.pc);
31481:     JS_ASSERT(JS_INITIAL_NSLOTS + index < jsatomid(obj->dslots[-1]));
40847:     JS_ASSERT_IF(obj->scope()->object == obj,
40847:                  JS_INITIAL_NSLOTS + index < obj->scope()->freeslot);
31481: 
31481:     PUSH_OPND(obj->dslots[index]);
31481:     if (op == JSOP_CALLDSLOT)
31481:         PUSH_OPND(JSVAL_NULL);
31481: END_CASE(JSOP_GETDSLOT)
31481: 
31481: BEGIN_CASE(JSOP_GETGVAR)
31481: BEGIN_CASE(JSOP_CALLGVAR)
31481:     slot = GET_SLOTNO(regs.pc);
31481:     JS_ASSERT(slot < GlobalVarCount(fp));
31481:     METER_SLOT_OP(op, slot);
31481:     lval = fp->slots[slot];
31481:     if (JSVAL_IS_NULL(lval)) {
31481:         op = (op == JSOP_GETGVAR) ? JSOP_NAME : JSOP_CALLNAME;
31481:         DO_OP();
31481:     }
37777:     JS_ASSERT(fp->varobj(cx) == cx->activeCallStack()->getInitialVarObj());
37777:     obj = cx->activeCallStack()->getInitialVarObj();
31481:     slot = JSVAL_TO_INT(lval);
40430:     rval = obj->getSlotMT(cx, slot);
31481:     PUSH_OPND(rval);
31481:     if (op == JSOP_CALLGVAR)
40452:         PUSH_OPND(JSVAL_NULL);
31481: END_CASE(JSOP_GETGVAR)
31481: 
31481: BEGIN_CASE(JSOP_SETGVAR)
31481:     slot = GET_SLOTNO(regs.pc);
31481:     JS_ASSERT(slot < GlobalVarCount(fp));
31481:     METER_SLOT_OP(op, slot);
31481:     rval = FETCH_OPND(-1);
37777:     JS_ASSERT(fp->varobj(cx) == cx->activeCallStack()->getInitialVarObj());
37777:     obj = cx->activeCallStack()->getInitialVarObj();
31481:     lval = fp->slots[slot];
31481:     if (JSVAL_IS_NULL(lval)) {
31481:         /*
31481:          * Inline-clone and deoptimize JSOP_SETNAME code here because
31481:          * JSOP_SETGVAR has arity 1: [rval], not arity 2: [obj, rval]
31481:          * as JSOP_SETNAME does, where [obj] is due to JSOP_BINDNAME.
31481:          */
31481: #ifdef JS_TRACER
31481:         if (TRACE_RECORDER(cx))
37741:             AbortRecording(cx, "SETGVAR with NULL slot");
31481: #endif
31481:         LOAD_ATOM(0);
31481:         id = ATOM_TO_JSID(atom);
31501:         if (!obj->setProperty(cx, id, &rval))
31481:             goto error;
31481:     } else {
31481:         slot = JSVAL_TO_INT(lval);
31481:         JS_LOCK_OBJ(cx, obj);
40847:         JSScope *scope = obj->scope();
32658:         if (!scope->methodWriteBarrier(cx, slot, rval)) {
32658:             JS_UNLOCK_SCOPE(cx, scope);
32658:             goto error;
32658:         }
40847:         obj->lockedSetSlot(slot, rval);
32658:         JS_UNLOCK_SCOPE(cx, scope);
31481:     }
31481: END_SET_CASE(JSOP_SETGVAR)
31481: 
31481: BEGIN_CASE(JSOP_DEFCONST)
31481: BEGIN_CASE(JSOP_DEFVAR)
31481:     index = GET_INDEX(regs.pc);
31481:     atom = atoms[index];
31481: 
31481:     /*
31481:      * index is relative to atoms at this point but for global var
31481:      * code below we need the absolute value.
31481:      */
31481:     index += atoms - script->atomMap.vector;
37777:     obj = fp->varobj(cx);
32573:     JS_ASSERT(obj->map->ops->defineProperty == js_DefineProperty);
31481:     attrs = JSPROP_ENUMERATE;
31481:     if (!(fp->flags & JSFRAME_EVAL))
31481:         attrs |= JSPROP_PERMANENT;
31481:     if (op == JSOP_DEFCONST)
31481:         attrs |= JSPROP_READONLY;
31481: 
31481:     /* Lookup id in order to check for redeclaration problems. */
31481:     id = ATOM_TO_JSID(atom);
31481:     prop = NULL;
37370:     if (op == JSOP_DEFVAR) {
37370:         /*
37370:          * Redundant declaration of a |var|, even one for a non-writable
37370:          * property like |undefined| in ES5, does nothing.
37370:          */
37370:         if (!obj->lookupProperty(cx, id, &obj2, &prop))
37370:             goto error;
37370:     } else {
31481:         if (!js_CheckRedeclaration(cx, obj, id, attrs, &obj2, &prop))
31481:             goto error;
37370:     }
31481: 
31481:     /* Bind a variable only if it's not yet defined. */
31481:     if (!prop) {
32573:         if (!js_DefineNativeProperty(cx, obj, id, JSVAL_VOID, JS_PropertyStub, JS_PropertyStub,
32573:                                      attrs, 0, 0, &prop)) {
31481:             goto error;
31481:         }
31481:         JS_ASSERT(prop);
31481:         obj2 = obj;
31481:     }
31481: 
31481:     /*
31481:      * Try to optimize a property we either just created, or found
31481:      * directly in the global object, that is permanent, has a slot,
31481:      * and has stub getter and setter, into a "fast global" accessed
31481:      * by the JSOP_*GVAR opcodes.
31481:      */
31481:     if (!fp->fun &&
31481:         index < GlobalVarCount(fp) &&
31481:         obj2 == obj &&
40430:         obj->isNative()) {
31481:         sprop = (JSScopeProperty *) prop;
40265:         if (!sprop->configurable() &&
40847:             SPROP_HAS_VALID_SLOT(sprop, obj->scope()) &&
40265:             sprop->hasDefaultGetterOrIsMethod() &&
40265:             sprop->hasDefaultSetter()) {
31481:             /*
37777:              * Fast globals use frame variables to map the global name's atom
37777:              * index to the permanent varobj slot number, tagged as a jsval.
37777:              * The atom index for the global's name literal is identical to its
37777:              * variable index.
31481:              */
31481:             fp->slots[index] = INT_TO_JSVAL(sprop->slot);
31481:         }
31481:     }
31481: 
31501:     obj2->dropProperty(cx, prop);
31481: END_CASE(JSOP_DEFVAR)
31481: 
31481: BEGIN_CASE(JSOP_DEFFUN)
31481: {
31481:     JSPropertyOp getter, setter;
31481:     bool doSet;
31481:     JSObject *pobj;
31481:     JSProperty *prop;
31481:     uint32 old;
31481: 
31481:     /*
33585:      * A top-level function defined in Global or Eval code (see ECMA-262
33585:      * Ed. 3), or else a SpiderMonkey extension: a named function statement in
33585:      * a compound statement (not at the top statement level of global code, or
33585:      * at the top level of a function body).
31481:      */
31481:     LOAD_FUNCTION(0);
31481:     obj = FUN_OBJECT(fun);
31481: 
31481:     if (FUN_NULL_CLOSURE(fun)) {
31481:         /*
31481:          * Even a null closure needs a parent for principals finding.
33585:          * FIXME: bug 476950, although debugger users may also demand some kind
33585:          * of scope link for debugger-assisted eval-in-frame.
31481:          */
31481:         obj2 = fp->scopeChain;
31481:     } else {
31481:         JS_ASSERT(!FUN_FLAT_CLOSURE(fun));
31481: 
31481:         /*
31481:          * Inline js_GetScopeChain a bit to optimize for the case of a
31481:          * top-level function.
31481:          */
31481:         if (!fp->blockChain) {
31481:             obj2 = fp->scopeChain;
31481:         } else {
31481:             obj2 = js_GetScopeChain(cx, fp);
31481:             if (!obj2)
31481:                 goto error;
31481:         }
31481:     }
31481: 
31481:     /*
33585:      * If static link is not current scope, clone fun's object to link to the
33585:      * current scope via parent. We do this to enable sharing of compiled
33585:      * functions among multiple equivalent scopes, amortizing the cost of
33585:      * compilation over a number of executions.  Examples include XUL scripts
33585:      * and event handlers shared among Firefox or other Mozilla app chrome
33585:      * windows, and user-defined JS functions precompiled and then shared among
33585:      * requests in server-side JS.
31481:      */
39930:     if (obj->getParent() != obj2) {
38604:         obj = CloneFunctionObject(cx, fun, obj2);
31481:         if (!obj)
31481:             goto error;
31481:     }
31481: 
31481:     /*
31501:      * Protect obj from any GC hiding below JSObject::setProperty or
33585:      * JSObject::defineProperty.  All paths from here must flow through the
33585:      * fp->scopeChain code below the parent->defineProperty call.
31481:      */
31481:     MUST_FLOW_THROUGH("restore_scope");
31481:     fp->scopeChain = obj;
31481: 
31481:     rval = OBJECT_TO_JSVAL(obj);
31481: 
31481:     /*
31481:      * ECMA requires functions defined when entering Eval code to be
31481:      * impermanent.
31481:      */
31481:     attrs = (fp->flags & JSFRAME_EVAL)
31481:             ? JSPROP_ENUMERATE
31481:             : JSPROP_ENUMERATE | JSPROP_PERMANENT;
31481: 
31481:     /*
33585:      * Load function flags that are also property attributes.  Getters and
33585:      * setters do not need a slot, their value is stored elsewhere in the
33585:      * property itself, not in obj slots.
31481:      */
32658:     getter = setter = JS_PropertyStub;
31481:     flags = JSFUN_GSFLAG2ATTR(fun->flags);
31481:     if (flags) {
31481:         /* Function cannot be both getter a setter. */
31481:         JS_ASSERT(flags == JSPROP_GETTER || flags == JSPROP_SETTER);
31481:         attrs |= flags | JSPROP_SHARED;
31481:         rval = JSVAL_VOID;
31481:         if (flags == JSPROP_GETTER)
41860:             getter = CastAsPropertyOp(obj);
31481:         else
41860:             setter = CastAsPropertyOp(obj);
31481:     }
31481: 
31481:     /*
33585:      * We define the function as a property of the variable object and not the
33585:      * current scope chain even for the case of function expression statements
33585:      * and functions defined by eval inside let or with blocks.
31481:      */
37777:     parent = fp->varobj(cx);
31481:     JS_ASSERT(parent);
31481: 
31481:     /*
33585:      * Check for a const property of the same name -- or any kind of property
33585:      * if executing with the strict option.  We check here at runtime as well
33585:      * as at compile-time, to handle eval as well as multiple HTML script tags.
31481:      */
31481:     id = ATOM_TO_JSID(fun->atom);
31481:     prop = NULL;
31481:     ok = js_CheckRedeclaration(cx, parent, id, attrs, &pobj, &prop);
31481:     if (!ok)
31481:         goto restore_scope;
31481: 
31481:     /*
33585:      * We deviate from 10.1.2 in ECMA 262 v3 and under eval use for function
33585:      * declarations JSObject::setProperty, not JSObject::defineProperty, to
33585:      * preserve the JSOP_PERMANENT attribute of existing properties and make
33585:      * sure that such properties cannot be deleted.
31481:      *
33585:      * We also use JSObject::setProperty for the existing properties of Call
33585:      * objects with matching attributes to preserve the native getters and
33585:      * setters that store the value of the property in the interpreter frame,
33585:      * see bug 467495.
31481:      */
31481:     doSet = (attrs == JSPROP_ENUMERATE);
31481:     JS_ASSERT_IF(doSet, fp->flags & JSFRAME_EVAL);
31481:     if (prop) {
31481:         if (parent == pobj &&
40826:             parent->getClass() == &js_CallClass &&
40265:             (old = ((JSScopeProperty *) prop)->attributes(),
31481:              !(old & (JSPROP_GETTER|JSPROP_SETTER)) &&
31481:              (old & (JSPROP_ENUMERATE|JSPROP_PERMANENT)) == attrs)) {
31481:             /*
33585:              * js_CheckRedeclaration must reject attempts to add a getter or
33585:              * setter to an existing property without a getter or setter.
31481:              */
31481:             JS_ASSERT(!(attrs & ~(JSPROP_ENUMERATE|JSPROP_PERMANENT)));
31481:             JS_ASSERT(!(old & JSPROP_READONLY));
31481:             doSet = JS_TRUE;
31481:         }
31501:         pobj->dropProperty(cx, prop);
31481:     }
31481:     ok = doSet
31501:          ? parent->setProperty(cx, id, &rval)
32573:          : parent->defineProperty(cx, id, rval, getter, setter, attrs);
31481: 
31481:   restore_scope:
37777:     /* Restore fp->scopeChain now that obj is defined in fp->callobj. */
31481:     fp->scopeChain = obj2;
33178:     if (!ok)
31481:         goto error;
31481: }
31481: END_CASE(JSOP_DEFFUN)
31481: 
31481: BEGIN_CASE(JSOP_DEFFUN_FC)
31481: BEGIN_CASE(JSOP_DEFFUN_DBGFC)
31481:     LOAD_FUNCTION(0);
31481: 
31481:     obj = (op == JSOP_DEFFUN_FC)
31481:           ? js_NewFlatClosure(cx, fun)
31481:           : js_NewDebuggableFlatClosure(cx, fun);
31481:     if (!obj)
31481:         goto error;
31481:     rval = OBJECT_TO_JSVAL(obj);
31481: 
31481:     attrs = (fp->flags & JSFRAME_EVAL)
31481:             ? JSPROP_ENUMERATE
31481:             : JSPROP_ENUMERATE | JSPROP_PERMANENT;
31481: 
31481:     flags = JSFUN_GSFLAG2ATTR(fun->flags);
31481:     if (flags) {
31481:         attrs |= flags | JSPROP_SHARED;
31481:         rval = JSVAL_VOID;
31481:     }
31481: 
37777:     parent = fp->varobj(cx);
31481:     JS_ASSERT(parent);
31481: 
31481:     id = ATOM_TO_JSID(fun->atom);
31481:     ok = js_CheckRedeclaration(cx, parent, id, attrs, NULL, NULL);
31481:     if (ok) {
31481:         if (attrs == JSPROP_ENUMERATE) {
31481:             JS_ASSERT(fp->flags & JSFRAME_EVAL);
31501:             ok = parent->setProperty(cx, id, &rval);
31481:         } else {
31481:             JS_ASSERT(attrs & JSPROP_PERMANENT);
31481: 
31501:             ok = parent->defineProperty(cx, id, rval,
31481:                                         (flags & JSPROP_GETTER)
41860:                                         ? CastAsPropertyOp(obj)
31481:                                         : JS_PropertyStub,
31481:                                         (flags & JSPROP_SETTER)
41860:                                         ? CastAsPropertyOp(obj)
31481:                                         : JS_PropertyStub,
32573:                                         attrs);
31481:         }
31481:     }
31481: 
33178:     if (!ok)
31481:         goto error;
31481: END_CASE(JSOP_DEFFUN_FC)
31481: 
31481: BEGIN_CASE(JSOP_DEFLOCALFUN)
31481:     /*
33585:      * Define a local function (i.e., one nested at the top level of another
33585:      * function), parented by the current scope chain, stored in a local
33585:      * variable slot that the compiler allocated.  This is an optimization over
33585:      * JSOP_DEFFUN that avoids requiring a call object for the outer function's
33585:      * activation.
31481:      */
31481:     LOAD_FUNCTION(SLOTNO_LEN);
31481:     JS_ASSERT(FUN_INTERPRETED(fun));
31481:     JS_ASSERT(!FUN_FLAT_CLOSURE(fun));
31481:     obj = FUN_OBJECT(fun);
31481: 
31481:     if (FUN_NULL_CLOSURE(fun)) {
38604:         obj = CloneFunctionObject(cx, fun, fp->scopeChain);
31481:         if (!obj)
31481:             goto error;
31481:     } else {
31481:         parent = js_GetScopeChain(cx, fp);
31481:         if (!parent)
31481:             goto error;
31481: 
39930:         if (obj->getParent() != parent) {
31481: #ifdef JS_TRACER
31481:             if (TRACE_RECORDER(cx))
37741:                 AbortRecording(cx, "DEFLOCALFUN for closure");
31481: #endif
38604:             obj = CloneFunctionObject(cx, fun, parent);
31481:             if (!obj)
31481:                 goto error;
31481:         }
31481:     }
31481: 
31481:     slot = GET_SLOTNO(regs.pc);
31481:     TRACE_2(DefLocalFunSetSlot, slot, obj);
31481: 
31481:     fp->slots[slot] = OBJECT_TO_JSVAL(obj);
31481: END_CASE(JSOP_DEFLOCALFUN)
31481: 
31481: BEGIN_CASE(JSOP_DEFLOCALFUN_FC)
31481:     LOAD_FUNCTION(SLOTNO_LEN);
31481: 
31481:     obj = js_NewFlatClosure(cx, fun);
31481:     if (!obj)
31481:         goto error;
31481: 
31481:     slot = GET_SLOTNO(regs.pc);
31481:     TRACE_2(DefLocalFunSetSlot, slot, obj);
31481: 
31481:     fp->slots[slot] = OBJECT_TO_JSVAL(obj);
31481: END_CASE(JSOP_DEFLOCALFUN_FC)
31481: 
31481: BEGIN_CASE(JSOP_DEFLOCALFUN_DBGFC)
31481:     LOAD_FUNCTION(SLOTNO_LEN);
31481: 
31481:     obj = js_NewDebuggableFlatClosure(cx, fun);
31481:     if (!obj)
31481:         goto error;
31481: 
31481:     slot = GET_SLOTNO(regs.pc);
31481:     fp->slots[slot] = OBJECT_TO_JSVAL(obj);
31481: END_CASE(JSOP_DEFLOCALFUN_DBGFC)
31481: 
31481: BEGIN_CASE(JSOP_LAMBDA)
31481:     /* Load the specified function object literal. */
31481:     LOAD_FUNCTION(0);
31481:     obj = FUN_OBJECT(fun);
31481: 
32658:     /* do-while(0) so we can break instead of using a goto. */
32658:     do {
31481:         if (FUN_NULL_CLOSURE(fun)) {
32658:             parent = fp->scopeChain;
32658: 
39930:             if (obj->getParent() == parent) {
32658:                 op = JSOp(regs.pc[JSOP_LAMBDA_LENGTH]);
32658: 
32658:                 /*
32658:                  * Optimize ({method: function () { ... }, ...}) and
32658:                  * this.method = function () { ... }; bytecode sequences.
32658:                  */
32658:                 if (op == JSOP_SETMETHOD) {
32658: #ifdef DEBUG
32658:                     op2 = JSOp(regs.pc[JSOP_LAMBDA_LENGTH + JSOP_SETMETHOD_LENGTH]);
32658:                     JS_ASSERT(op2 == JSOP_POP || op2 == JSOP_POPV);
32658: #endif
32658: 
32658:                     lval = FETCH_OPND(-1);
32658:                     if (JSVAL_IS_OBJECT(lval) &&
32658:                         (obj2 = JSVAL_TO_OBJECT(lval)) &&
40826:                         obj2->getClass() == &js_ObjectClass) {
32658:                         break;
32658:                     }
32658:                 } else if (op == JSOP_INITMETHOD) {
32658:                     lval = FETCH_OPND(-1);
32658:                     JS_ASSERT(!JSVAL_IS_PRIMITIVE(lval));
32658:                     obj2 = JSVAL_TO_OBJECT(lval);
40826:                     JS_ASSERT(obj2->getClass() == &js_ObjectClass);
40847:                     JS_ASSERT(obj2->scope()->object == obj2);
32658:                     break;
32658:                 }
32658:             }
31481:         } else {
31481:             parent = js_GetScopeChain(cx, fp);
31481:             if (!parent)
31481:                 goto error;
32658:         }
32658: 
38604:         obj = CloneFunctionObject(cx, fun, parent);
31481:         if (!obj)
31481:             goto error;
32658:     } while (0);
31481: 
31481:     PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_LAMBDA)
31481: 
31481: BEGIN_CASE(JSOP_LAMBDA_FC)
31481:     LOAD_FUNCTION(0);
31481: 
31481:     obj = js_NewFlatClosure(cx, fun);
31481:     if (!obj)
31481:         goto error;
31481: 
31481:     PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_LAMBDA_FC)
31481: 
31481: BEGIN_CASE(JSOP_LAMBDA_DBGFC)
31481:     LOAD_FUNCTION(0);
31481: 
31481:     obj = js_NewDebuggableFlatClosure(cx, fun);
31481:     if (!obj)
31481:         goto error;
31481: 
31481:     PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_LAMBDA_DBGFC)
31481: 
31481: BEGIN_CASE(JSOP_CALLEE)
31939:     PUSH_OPND(fp->argv[-2]);
31481: END_CASE(JSOP_CALLEE)
31481: 
31481: BEGIN_CASE(JSOP_GETTER)
31481: BEGIN_CASE(JSOP_SETTER)
31481:   do_getter_setter:
31481:     op2 = (JSOp) *++regs.pc;
31481:     switch (op2) {
31481:       case JSOP_INDEXBASE:
31481:         atoms += GET_INDEXBASE(regs.pc);
31481:         regs.pc += JSOP_INDEXBASE_LENGTH - 1;
31481:         goto do_getter_setter;
31481:       case JSOP_INDEXBASE1:
31481:       case JSOP_INDEXBASE2:
31481:       case JSOP_INDEXBASE3:
31481:         atoms += (op2 - JSOP_INDEXBASE1 + 1) << 16;
31481:         goto do_getter_setter;
31481: 
31481:       case JSOP_SETNAME:
31481:       case JSOP_SETPROP:
31481:         LOAD_ATOM(0);
31481:         id = ATOM_TO_JSID(atom);
31481:         rval = FETCH_OPND(-1);
31481:         i = -1;
31481:         goto gs_pop_lval;
31481: 
31481:       case JSOP_SETELEM:
31481:         rval = FETCH_OPND(-1);
31481:         id = 0;
31481:         i = -2;
31481:       gs_pop_lval:
31481:         FETCH_OBJECT(cx, i - 1, lval, obj);
31481:         break;
31481: 
31481:       case JSOP_INITPROP:
31481:         JS_ASSERT(regs.sp - StackBase(fp) >= 2);
31481:         rval = FETCH_OPND(-1);
31481:         i = -1;
31481:         LOAD_ATOM(0);
31481:         id = ATOM_TO_JSID(atom);
31481:         goto gs_get_lval;
31481: 
31481:       default:
31481:         JS_ASSERT(op2 == JSOP_INITELEM);
31481: 
31481:         JS_ASSERT(regs.sp - StackBase(fp) >= 3);
31481:         rval = FETCH_OPND(-1);
31481:         id = 0;
31481:         i = -2;
31481:       gs_get_lval:
31481:         lval = FETCH_OPND(i-1);
31481:         JS_ASSERT(JSVAL_IS_OBJECT(lval));
31481:         obj = JSVAL_TO_OBJECT(lval);
31481:         break;
31481:     }
31481: 
31481:     /* Ensure that id has a type suitable for use with obj. */
31481:     if (id == 0)
31481:         FETCH_ELEMENT_ID(obj, i, id);
31481: 
38638:     if (!js_IsCallable(rval)) {
31481:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
31481:                              JSMSG_BAD_GETTER_OR_SETTER,
31481:                              (op == JSOP_GETTER)
31481:                              ? js_getter_str
31481:                              : js_setter_str);
31481:         goto error;
31481:     }
31481: 
31481:     /*
33585:      * Getters and setters are just like watchpoints from an access control
33585:      * point of view.
31481:      */
31501:     if (!obj->checkAccess(cx, id, JSACC_WATCH, &rtmp, &attrs))
31481:         goto error;
31481: 
31481:     if (op == JSOP_GETTER) {
41860:         getter = CastAsPropertyOp(JSVAL_TO_OBJECT(rval));
31481:         setter = JS_PropertyStub;
31481:         attrs = JSPROP_GETTER;
31481:     } else {
31481:         getter = JS_PropertyStub;
41860:         setter = CastAsPropertyOp(JSVAL_TO_OBJECT(rval));
31481:         attrs = JSPROP_SETTER;
31481:     }
31481:     attrs |= JSPROP_ENUMERATE | JSPROP_SHARED;
31481: 
31481:     /* Check for a readonly or permanent property of the same name. */
31481:     if (!js_CheckRedeclaration(cx, obj, id, attrs, NULL, NULL))
31481:         goto error;
31481: 
32573:     if (!obj->defineProperty(cx, id, JSVAL_VOID, getter, setter, attrs))
31481:         goto error;
31481: 
31481:     regs.sp += i;
32658:     if (js_CodeSpec[op2].ndefs > js_CodeSpec[op2].nuses) {
32658:         JS_ASSERT(js_CodeSpec[op2].ndefs == js_CodeSpec[op2].nuses + 1);
31481:         STORE_OPND(-1, rval);
32658:     }
31481:     len = js_CodeSpec[op2].length;
31481:     DO_NEXT_OP(len);
31481: 
31481: BEGIN_CASE(JSOP_HOLE)
31481:     PUSH_OPND(JSVAL_HOLE);
31481: END_CASE(JSOP_HOLE)
31481: 
31481: BEGIN_CASE(JSOP_NEWARRAY)
31481:     len = GET_UINT16(regs.pc);
31481:     cx->fp->assertValidStackDepth(len);
31481:     obj = js_NewArrayObject(cx, len, regs.sp - len, JS_TRUE);
31481:     if (!obj)
31481:         goto error;
31481:     regs.sp -= len - 1;
31481:     STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_NEWARRAY)
31481: 
31481: BEGIN_CASE(JSOP_NEWINIT)
31481:     i = GET_INT8(regs.pc);
31481:     JS_ASSERT(i == JSProto_Array || i == JSProto_Object);
32658:     if (i == JSProto_Array) {
32658:         obj = js_NewArrayObject(cx, 0, NULL);
31481:         if (!obj)
31481:             goto error;
32658:     } else {
40858:         obj = NewObject(cx, &js_ObjectClass, NULL, NULL);
32658:         if (!obj)
32658:             goto error;
32658: 
32658:         if (regs.pc[JSOP_NEWINIT_LENGTH] != JSOP_ENDINIT) {
32658:             JS_LOCK_OBJ(cx, obj);
32658:             JSScope *scope = js_GetMutableScope(cx, obj);
32658:             if (!scope) {
32658:                 JS_UNLOCK_OBJ(cx, obj);
32658:                 goto error;
32658:             }
38504: 
38504:             /*
38504:              * We cannot assume that js_GetMutableScope above creates a scope
38504:              * owned by cx and skip JS_UNLOCK_SCOPE. A new object debugger
38504:              * hook may add properties to the newly created object, suspend
38504:              * the current request and share the object with other threads.
38504:              */
32658:             JS_UNLOCK_SCOPE(cx, scope);
32658:         }
32658:     }
32658: 
31481:     PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481:     CHECK_INTERRUPT_HANDLER();
31481: END_CASE(JSOP_NEWINIT)
31481: 
31481: BEGIN_CASE(JSOP_ENDINIT)
31481:     /* Re-set the newborn root to the top of this object tree. */
31481:     JS_ASSERT(regs.sp - StackBase(fp) >= 1);
31481:     lval = FETCH_OPND(-1);
31481:     JS_ASSERT(JSVAL_IS_OBJECT(lval));
33952:     cx->weakRoots.finalizableNewborns[FINALIZE_OBJECT] = JSVAL_TO_OBJECT(lval);
31481: END_CASE(JSOP_ENDINIT)
31481: 
31481: BEGIN_CASE(JSOP_INITPROP)
32658: BEGIN_CASE(JSOP_INITMETHOD)
40391: {
31481:     /* Load the property's initial value into rval. */
31481:     JS_ASSERT(regs.sp - StackBase(fp) >= 2);
31481:     rval = FETCH_OPND(-1);
31481: 
31481:     /* Load the object being initialized into lval/obj. */
31481:     lval = FETCH_OPND(-2);
31481:     obj = JSVAL_TO_OBJECT(lval);
40430:     JS_ASSERT(obj->isNative());
40826:     JS_ASSERT(!obj->getClass()->reserveSlots);
40391: 
40847:     JSScope *scope = obj->scope();
40362:     PropertyCacheEntry *entry;
33121: 
38504:     /*
40391:      * Probe the property cache. 
40391:      *
38504:      * We can not assume that the object created by JSOP_NEWINIT is still
38504:      * single-threaded as the debugger can access it from other threads.
40391:      * So check first.
40391:      *
40391:      * On a hit, if the cached sprop has a non-default setter, it must be
40391:      * __proto__ or __parent__. If sprop->parent != scope->lastProperty(),
40391:      * there is a repeated property name. The fast path does not handle these
40391:      * two cases.
38504:      */
40391:     if (CX_OWNS_OBJECT_TITLE(cx, obj) &&
40391:         JS_PROPERTY_CACHE(cx).testForInit(rt, regs.pc, obj, scope, &sprop, &entry) &&
40391:         sprop->hasDefaultSetter() &&
40391:         sprop->parent == scope->lastProperty())
40391:     {
40391:         /* Fast path. Property cache hit. */
31481:         slot = sprop->slot;
31481:         JS_ASSERT(slot == scope->freeslot);
40410:         if (slot < obj->numSlots()) {
31481:             ++scope->freeslot;
31481:         } else {
38504:             if (!js_AllocSlot(cx, obj, &slot))
31481:                 goto error;
31481:             JS_ASSERT(slot == sprop->slot);
31481:         }
31481: 
35453:         JS_ASSERT(!scope->lastProperty() ||
35453:                   scope->shape == scope->lastProperty()->shape);
31481:         if (scope->table) {
31481:             JSScopeProperty *sprop2 =
39894:                 scope->addProperty(cx, sprop->id, sprop->getter(), sprop->setter(), slot,
40265:                                    sprop->attributes(), sprop->getFlags(), sprop->shortid);
31481:             if (!sprop2) {
31481:                 js_FreeSlot(cx, obj, slot);
31481:                 goto error;
31481:             }
31481:             JS_ASSERT(sprop2 == sprop);
31481:         } else {
37766:             JS_ASSERT(!scope->isSharedEmpty());
35018:             scope->extend(cx, sprop);
31481:         }
31481: 
32658:         /*
33585:          * No method change check here because here we are adding a new
33585:          * property, not updating an existing slot's value that might
33585:          * contain a method of a branded scope.
32658:          */
41855:         TRACE_2(SetPropHit, entry, sprop);
40847:         obj->lockedSetSlot(slot, rval);
40391:     } else {
40391:         PCMETER(JS_PROPERTY_CACHE(cx).inipcmisses++);
31481: 
31481:         /* Get the immediate property name into id. */
31481:         LOAD_ATOM(0);
31481:         id = ATOM_TO_JSID(atom);
31481: 
31481:         /* Set the property named by obj[id] to rval. */
31481:         if (!js_CheckRedeclaration(cx, obj, id, JSPROP_INITIALIZER,
31481:                                    NULL, NULL)) {
31481:             goto error;
31481:         }
31481: 
32658:         uintN defineHow = (op == JSOP_INITMETHOD)
32658:                           ? JSDNP_CACHE_RESULT | JSDNP_SET_METHOD
32658:                           : JSDNP_CACHE_RESULT;
31481:         if (!(JS_UNLIKELY(atom == cx->runtime->atomState.protoAtom)
32658:               ? js_SetPropertyHelper(cx, obj, id, defineHow, &rval)
31481:               : js_DefineNativeProperty(cx, obj, id, rval, NULL, NULL,
31481:                                         JSPROP_ENUMERATE, 0, 0, NULL,
32658:                                         defineHow))) {
31481:             goto error;
32658:         }
40391:     }
31481: 
31481:     /* Common tail for property cache hit and miss cases. */
31481:     regs.sp--;
40391: }
31481: END_CASE(JSOP_INITPROP);
31481: 
31481: BEGIN_CASE(JSOP_INITELEM)
31481:     /* Pop the element's value into rval. */
31481:     JS_ASSERT(regs.sp - StackBase(fp) >= 3);
31481:     rval = FETCH_OPND(-1);
31481: 
31481:     /* Find the object being initialized at top of stack. */
31481:     lval = FETCH_OPND(-3);
31481:     JS_ASSERT(!JSVAL_IS_PRIMITIVE(lval));
31481:     obj = JSVAL_TO_OBJECT(lval);
31481: 
31481:     /* Fetch id now that we have obj. */
31481:     FETCH_ELEMENT_ID(obj, -2, id);
31481: 
31481:     /*
33585:      * Check for property redeclaration strict warning (we may be in an object
33585:      * initialiser, not an array initialiser).
31481:      */
31481:     if (!js_CheckRedeclaration(cx, obj, id, JSPROP_INITIALIZER, NULL, NULL))
31481:         goto error;
31481: 
31481:     /*
31501:      * If rval is a hole, do not call JSObject::defineProperty. In this case,
31481:      * obj must be an array, so if the current op is the last element
31481:      * initialiser, set the array length to one greater than id.
31481:      */
31481:     if (rval == JSVAL_HOLE) {
39928:         JS_ASSERT(obj->isArray());
31481:         JS_ASSERT(JSID_IS_INT(id));
31823:         JS_ASSERT(jsuint(JSID_TO_INT(id)) < JS_ARGS_LENGTH_MAX);
31481:         if (js_GetOpcode(cx, script, regs.pc + JSOP_INITELEM_LENGTH) == JSOP_ENDINIT &&
31481:             !js_SetLengthProperty(cx, obj, (jsuint) (JSID_TO_INT(id) + 1))) {
31481:             goto error;
31481:         }
31481:     } else {
32573:         if (!obj->defineProperty(cx, id, rval, NULL, NULL, JSPROP_ENUMERATE))
31481:             goto error;
31481:     }
31481:     regs.sp -= 2;
31481: END_CASE(JSOP_INITELEM)
31481: 
31481: #if JS_HAS_SHARP_VARS
32729: 
31481: BEGIN_CASE(JSOP_DEFSHARP)
32729:     slot = GET_UINT16(regs.pc);
32729:     JS_ASSERT(slot + 1 < fp->script->nfixed);
32729:     lval = fp->slots[slot];
33609:     if (!JSVAL_IS_PRIMITIVE(lval)) {
33609:         obj = JSVAL_TO_OBJECT(lval);
33609:     } else {
33609:         JS_ASSERT(JSVAL_IS_VOID(lval));
31481:         obj = js_NewArrayObject(cx, 0, NULL);
31481:         if (!obj)
31481:             goto error;
32729:         fp->slots[slot] = OBJECT_TO_JSVAL(obj);
31481:     }
32729:     i = (jsint) GET_UINT16(regs.pc + UINT16_LEN);
31481:     id = INT_TO_JSID(i);
31481:     rval = FETCH_OPND(-1);
31481:     if (JSVAL_IS_PRIMITIVE(rval)) {
31481:         char numBuf[12];
31481:         JS_snprintf(numBuf, sizeof numBuf, "%u", (unsigned) i);
31481:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
31481:                              JSMSG_BAD_SHARP_DEF, numBuf);
31481:         goto error;
31481:     }
32573:     if (!obj->defineProperty(cx, id, rval, NULL, NULL, JSPROP_ENUMERATE))
31481:         goto error;
31481: END_CASE(JSOP_DEFSHARP)
31481: 
31481: BEGIN_CASE(JSOP_USESHARP)
32729:     slot = GET_UINT16(regs.pc);
32729:     JS_ASSERT(slot + 1 < fp->script->nfixed);
32729:     lval = fp->slots[slot];
32729:     i = (jsint) GET_UINT16(regs.pc + UINT16_LEN);
32729:     if (JSVAL_IS_VOID(lval)) {
31481:         rval = JSVAL_VOID;
31481:     } else {
32729:         obj = JSVAL_TO_OBJECT(fp->slots[slot]);
32729:         id = INT_TO_JSID(i);
31501:         if (!obj->getProperty(cx, id, &rval))
31481:             goto error;
31481:     }
31481:     if (!JSVAL_IS_OBJECT(rval)) {
31481:         char numBuf[12];
31481: 
31481:         JS_snprintf(numBuf, sizeof numBuf, "%u", (unsigned) i);
31481:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
31481:                              JSMSG_BAD_SHARP_USE, numBuf);
31481:         goto error;
31481:     }
31481:     PUSH_OPND(rval);
31481: END_CASE(JSOP_USESHARP)
32729: 
32729: BEGIN_CASE(JSOP_SHARPINIT)
32729:     slot = GET_UINT16(regs.pc);
32729:     JS_ASSERT(slot + 1 < fp->script->nfixed);
32729:     vp = &fp->slots[slot];
32729:     rval = vp[1];
32729: 
32729:     /*
32729:      * We peek ahead safely here because empty initialisers get zero
32729:      * JSOP_SHARPINIT ops, and non-empty ones get two: the first comes
32729:      * immediately after JSOP_NEWINIT followed by one or more property
32729:      * initialisers; and the second comes directly before JSOP_ENDINIT.
32729:      */
32729:     if (regs.pc[JSOP_SHARPINIT_LENGTH] != JSOP_ENDINIT) {
32729:         rval = JSVAL_IS_VOID(rval) ? JSVAL_ONE : rval + 2;
32729:     } else {
32729:         JS_ASSERT(JSVAL_IS_INT(rval));
32729:         rval -= 2;
32729:         if (rval == JSVAL_ZERO)
32729:             vp[0] = JSVAL_VOID;
32729:     }
32729:     vp[1] = rval;
32729: END_CASE(JSOP_SHARPINIT)
32729: 
31481: #endif /* JS_HAS_SHARP_VARS */
31481: 
31481: BEGIN_CASE(JSOP_GOSUB)
31481:     PUSH(JSVAL_FALSE);
31481:     i = (regs.pc - script->main) + JSOP_GOSUB_LENGTH;
31481:     PUSH(INT_TO_JSVAL(i));
31481:     len = GET_JUMP_OFFSET(regs.pc);
31481: END_VARLEN_CASE
31481: 
31481: BEGIN_CASE(JSOP_GOSUBX)
31481:     PUSH(JSVAL_FALSE);
31481:     i = (regs.pc - script->main) + JSOP_GOSUBX_LENGTH;
31481:     len = GET_JUMPX_OFFSET(regs.pc);
31481:     PUSH(INT_TO_JSVAL(i));
31481: END_VARLEN_CASE
31481: 
31481: BEGIN_CASE(JSOP_RETSUB)
31481:     /* Pop [exception or hole, retsub pc-index]. */
31481:     rval = POP();
31481:     lval = POP();
31481:     JS_ASSERT(JSVAL_IS_BOOLEAN(lval));
31481:     if (JSVAL_TO_BOOLEAN(lval)) {
31481:         /*
33585:          * Exception was pending during finally, throw it *before* we adjust
33585:          * pc, because pc indexes into script->trynotes.  This turns out not to
33585:          * be necessary, but it seems clearer.  And it points out a FIXME:
33585:          * 350509, due to Igor Bukanov.
31481:          */
31481:         cx->throwing = JS_TRUE;
31481:         cx->exception = rval;
31481:         goto error;
31481:     }
31481:     JS_ASSERT(JSVAL_IS_INT(rval));
31481:     len = JSVAL_TO_INT(rval);
31481:     regs.pc = script->main;
31481: END_VARLEN_CASE
31481: 
31481: BEGIN_CASE(JSOP_EXCEPTION)
31481:     JS_ASSERT(cx->throwing);
31481:     PUSH(cx->exception);
31481:     cx->throwing = JS_FALSE;
31481:     CHECK_BRANCH();
31481: END_CASE(JSOP_EXCEPTION)
31481: 
31481: BEGIN_CASE(JSOP_FINALLY)
31481:     CHECK_BRANCH();
31481: END_CASE(JSOP_FINALLY)
31481: 
31481: BEGIN_CASE(JSOP_THROWING)
31481:     JS_ASSERT(!cx->throwing);
31481:     cx->throwing = JS_TRUE;
31481:     cx->exception = POP_OPND();
31481: END_CASE(JSOP_THROWING)
31481: 
31481: BEGIN_CASE(JSOP_THROW)
31481:     JS_ASSERT(!cx->throwing);
31481:     CHECK_BRANCH();
31481:     cx->throwing = JS_TRUE;
31481:     cx->exception = POP_OPND();
31481:     /* let the code at error try to catch the exception. */
31481:     goto error;
31481: 
31481: BEGIN_CASE(JSOP_SETLOCALPOP)
31481:     /*
33585:      * The stack must have a block with at least one local slot below the
33585:      * exception object.
31481:      */
31481:     JS_ASSERT((size_t) (regs.sp - StackBase(fp)) >= 2);
31481:     slot = GET_UINT16(regs.pc);
31481:     JS_ASSERT(slot + 1 < script->nslots);
31481:     fp->slots[slot] = POP_OPND();
31481: END_CASE(JSOP_SETLOCALPOP)
31481: 
31481: BEGIN_CASE(JSOP_IFPRIMTOP)
31481:     /*
33585:      * If the top of stack is of primitive type, jump to our target. Otherwise
33585:      * advance to the next opcode.
31481:      */
31481:     JS_ASSERT(regs.sp > StackBase(fp));
31481:     rval = FETCH_OPND(-1);
31481:     if (JSVAL_IS_PRIMITIVE(rval)) {
31481:         len = GET_JUMP_OFFSET(regs.pc);
31481:         BRANCH(len);
31481:     }
31481: END_CASE(JSOP_IFPRIMTOP)
31481: 
31481: BEGIN_CASE(JSOP_PRIMTOP)
31481:     JS_ASSERT(regs.sp > StackBase(fp));
31481:     lval = FETCH_OPND(-1);
31481:     i = GET_INT8(regs.pc);
31481:     if (!JSVAL_IS_PRIMITIVE(lval)) {
31481:         lval = FETCH_OPND(-2);
33585:         js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO, -2, lval, NULL,
33585:                              (i == JSTYPE_VOID) ? "primitive type" : JS_TYPE_STR(i));
31481:         goto error;
31481:     }
31481: END_CASE(JSOP_PRIMTOP)
31481: 
31481: BEGIN_CASE(JSOP_OBJTOP)
31481:     lval = FETCH_OPND(-1);
31481:     if (JSVAL_IS_PRIMITIVE(lval)) {
31481:         js_ReportValueError(cx, GET_UINT16(regs.pc), -1, lval, NULL);
31481:         goto error;
31481:     }
31481: END_CASE(JSOP_OBJTOP)
31481: 
31481: BEGIN_CASE(JSOP_INSTANCEOF)
31481:     rval = FETCH_OPND(-1);
31481:     if (JSVAL_IS_PRIMITIVE(rval) ||
31481:         !(obj = JSVAL_TO_OBJECT(rval))->map->ops->hasInstance) {
31481:         js_ReportValueError(cx, JSMSG_BAD_INSTANCEOF_RHS,
31481:                             -1, rval, NULL);
31481:         goto error;
31481:     }
31481:     lval = FETCH_OPND(-2);
31481:     cond = JS_FALSE;
31481:     if (!obj->map->ops->hasInstance(cx, obj, lval, &cond))
31481:         goto error;
31481:     regs.sp--;
31481:     STORE_OPND(-1, BOOLEAN_TO_JSVAL(cond));
31481: END_CASE(JSOP_INSTANCEOF)
31481: 
31481: #if JS_HAS_DEBUGGER_KEYWORD
31481: BEGIN_CASE(JSOP_DEBUGGER)
31481: {
31481:     JSTrapHandler handler = cx->debugHooks->debuggerHandler;
31481:     if (handler) {
33585:         switch (handler(cx, script, regs.pc, &rval, cx->debugHooks->debuggerHandlerData)) {
31481:         case JSTRAP_ERROR:
31481:             goto error;
31481:         case JSTRAP_CONTINUE:
31481:             break;
31481:         case JSTRAP_RETURN:
31481:             fp->rval = rval;
31481:             ok = JS_TRUE;
31481:             goto forced_return;
31481:         case JSTRAP_THROW:
31481:             cx->throwing = JS_TRUE;
31481:             cx->exception = rval;
31481:             goto error;
31481:         default:;
31481:         }
31481:         CHECK_INTERRUPT_HANDLER();
31481:     }
31481: }
31481: END_CASE(JSOP_DEBUGGER)
31481: #endif /* JS_HAS_DEBUGGER_KEYWORD */
31481: 
31481: #if JS_HAS_XML_SUPPORT
31481: BEGIN_CASE(JSOP_DEFXMLNS)
31481:     rval = POP();
31481:     if (!js_SetDefaultXMLNamespace(cx, rval))
31481:         goto error;
31481: END_CASE(JSOP_DEFXMLNS)
31481: 
31481: BEGIN_CASE(JSOP_ANYNAME)
31481:     if (!js_GetAnyName(cx, &rval))
31481:         goto error;
31481:     PUSH_OPND(rval);
31481: END_CASE(JSOP_ANYNAME)
31481: 
31481: BEGIN_CASE(JSOP_QNAMEPART)
31481:     LOAD_ATOM(0);
31481:     PUSH_OPND(ATOM_KEY(atom));
31481: END_CASE(JSOP_QNAMEPART)
31481: 
31481: BEGIN_CASE(JSOP_QNAMECONST)
31481:     LOAD_ATOM(0);
31481:     rval = ATOM_KEY(atom);
31481:     lval = FETCH_OPND(-1);
31481:     obj = js_ConstructXMLQNameObject(cx, lval, rval);
31481:     if (!obj)
31481:         goto error;
31481:     STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_QNAMECONST)
31481: 
31481: BEGIN_CASE(JSOP_QNAME)
31481:     rval = FETCH_OPND(-1);
31481:     lval = FETCH_OPND(-2);
31481:     obj = js_ConstructXMLQNameObject(cx, lval, rval);
31481:     if (!obj)
31481:         goto error;
31481:     regs.sp--;
31481:     STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_QNAME)
31481: 
31481: BEGIN_CASE(JSOP_TOATTRNAME)
31481:     rval = FETCH_OPND(-1);
31481:     if (!js_ToAttributeName(cx, &rval))
31481:         goto error;
31481:     STORE_OPND(-1, rval);
31481: END_CASE(JSOP_TOATTRNAME)
31481: 
31481: BEGIN_CASE(JSOP_TOATTRVAL)
31481:     rval = FETCH_OPND(-1);
31481:     JS_ASSERT(JSVAL_IS_STRING(rval));
31481:     str = js_EscapeAttributeValue(cx, JSVAL_TO_STRING(rval), JS_FALSE);
31481:     if (!str)
31481:         goto error;
31481:     STORE_OPND(-1, STRING_TO_JSVAL(str));
31481: END_CASE(JSOP_TOATTRVAL)
31481: 
31481: BEGIN_CASE(JSOP_ADDATTRNAME)
31481: BEGIN_CASE(JSOP_ADDATTRVAL)
31481:     rval = FETCH_OPND(-1);
31481:     lval = FETCH_OPND(-2);
31481:     str = JSVAL_TO_STRING(lval);
31481:     str2 = JSVAL_TO_STRING(rval);
31481:     str = js_AddAttributePart(cx, op == JSOP_ADDATTRNAME, str, str2);
31481:     if (!str)
31481:         goto error;
31481:     regs.sp--;
31481:     STORE_OPND(-1, STRING_TO_JSVAL(str));
31481: END_CASE(JSOP_ADDATTRNAME)
31481: 
31481: BEGIN_CASE(JSOP_BINDXMLNAME)
31481:     lval = FETCH_OPND(-1);
31481:     if (!js_FindXMLProperty(cx, lval, &obj, &id))
31481:         goto error;
31481:     STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
31481:     PUSH_OPND(ID_TO_VALUE(id));
31481: END_CASE(JSOP_BINDXMLNAME)
31481: 
31481: BEGIN_CASE(JSOP_SETXMLNAME)
31481:     obj = JSVAL_TO_OBJECT(FETCH_OPND(-3));
31481:     rval = FETCH_OPND(-1);
31481:     FETCH_ELEMENT_ID(obj, -2, id);
31501:     if (!obj->setProperty(cx, id, &rval))
31481:         goto error;
31481:     rval = FETCH_OPND(-1);
31481:     regs.sp -= 2;
31481:     STORE_OPND(-1, rval);
31481: END_CASE(JSOP_SETXMLNAME)
31481: 
31481: BEGIN_CASE(JSOP_CALLXMLNAME)
31481: BEGIN_CASE(JSOP_XMLNAME)
31481:     lval = FETCH_OPND(-1);
31481:     if (!js_FindXMLProperty(cx, lval, &obj, &id))
31481:         goto error;
31501:     if (!obj->getProperty(cx, id, &rval))
31481:         goto error;
31481:     STORE_OPND(-1, rval);
31481:     if (op == JSOP_CALLXMLNAME)
31481:         PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_XMLNAME)
31481: 
31481: BEGIN_CASE(JSOP_DESCENDANTS)
31481: BEGIN_CASE(JSOP_DELDESC)
31481:     FETCH_OBJECT(cx, -2, lval, obj);
31481:     rval = FETCH_OPND(-1);
31481:     if (!js_GetXMLDescendants(cx, obj, rval, &rval))
31481:         goto error;
31481: 
31481:     if (op == JSOP_DELDESC) {
31481:         regs.sp[-1] = rval;          /* set local root */
31481:         if (!js_DeleteXMLListElements(cx, JSVAL_TO_OBJECT(rval)))
31481:             goto error;
31481:         rval = JSVAL_TRUE;      /* always succeed */
31481:     }
31481: 
31481:     regs.sp--;
31481:     STORE_OPND(-1, rval);
31481: END_CASE(JSOP_DESCENDANTS)
31481: 
31481: BEGIN_CASE(JSOP_FILTER)
31481:     /*
33585:      * We push the hole value before jumping to [enditer] so we can detect the
33585:      * first iteration and direct js_StepXMLListFilter to initialize filter's
33585:      * state.
31481:      */
31481:     PUSH_OPND(JSVAL_HOLE);
31481:     len = GET_JUMP_OFFSET(regs.pc);
31481:     JS_ASSERT(len > 0);
31481: END_VARLEN_CASE
31481: 
31481: BEGIN_CASE(JSOP_ENDFILTER)
31481:     cond = (regs.sp[-1] != JSVAL_HOLE);
31481:     if (cond) {
31481:         /* Exit the "with" block left from the previous iteration. */
31481:         js_LeaveWith(cx);
31481:     }
31481:     if (!js_StepXMLListFilter(cx, cond))
31481:         goto error;
31481:     if (regs.sp[-1] != JSVAL_NULL) {
31481:         /*
33585:          * Decrease sp after EnterWith returns as we use sp[-1] there to root
33585:          * temporaries.
31481:          */
41295:         JS_ASSERT(VALUE_IS_XML(cx, regs.sp[-1]));
31481:         if (!js_EnterWith(cx, -2))
31481:             goto error;
31481:         regs.sp--;
31481:         len = GET_JUMP_OFFSET(regs.pc);
31481:         JS_ASSERT(len < 0);
31481:         BRANCH(len);
31481:     }
31481:     regs.sp--;
31481: END_CASE(JSOP_ENDFILTER);
31481: 
31481: BEGIN_CASE(JSOP_TOXML)
31481:     rval = FETCH_OPND(-1);
31481:     obj = js_ValueToXMLObject(cx, rval);
31481:     if (!obj)
31481:         goto error;
31481:     STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_TOXML)
31481: 
31481: BEGIN_CASE(JSOP_TOXMLLIST)
31481:     rval = FETCH_OPND(-1);
31481:     obj = js_ValueToXMLListObject(cx, rval);
31481:     if (!obj)
31481:         goto error;
31481:     STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_TOXMLLIST)
31481: 
31481: BEGIN_CASE(JSOP_XMLTAGEXPR)
31481:     rval = FETCH_OPND(-1);
31481:     str = js_ValueToString(cx, rval);
31481:     if (!str)
31481:         goto error;
31481:     STORE_OPND(-1, STRING_TO_JSVAL(str));
31481: END_CASE(JSOP_XMLTAGEXPR)
31481: 
31481: BEGIN_CASE(JSOP_XMLELTEXPR)
31481:     rval = FETCH_OPND(-1);
41295:     if (VALUE_IS_XML(cx, rval)) {
31481:         str = js_ValueToXMLString(cx, rval);
31481:     } else {
31481:         str = js_ValueToString(cx, rval);
31481:         if (str)
31481:             str = js_EscapeElementValue(cx, str);
31481:     }
31481:     if (!str)
31481:         goto error;
31481:     STORE_OPND(-1, STRING_TO_JSVAL(str));
31481: END_CASE(JSOP_XMLELTEXPR)
31481: 
31481: BEGIN_CASE(JSOP_XMLOBJECT)
31481:     LOAD_OBJECT(0);
31481:     obj = js_CloneXMLObject(cx, obj);
31481:     if (!obj)
31481:         goto error;
31481:     PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_XMLOBJECT)
31481: 
31481: BEGIN_CASE(JSOP_XMLCDATA)
31481:     LOAD_ATOM(0);
31481:     str = ATOM_TO_STRING(atom);
31481:     obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_TEXT, NULL, str);
31481:     if (!obj)
31481:         goto error;
31481:     PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_XMLCDATA)
31481: 
31481: BEGIN_CASE(JSOP_XMLCOMMENT)
31481:     LOAD_ATOM(0);
31481:     str = ATOM_TO_STRING(atom);
31481:     obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_COMMENT, NULL, str);
31481:     if (!obj)
31481:         goto error;
31481:     PUSH_OPND(OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_XMLCOMMENT)
31481: 
31481: BEGIN_CASE(JSOP_XMLPI)
31481:     LOAD_ATOM(0);
31481:     str = ATOM_TO_STRING(atom);
31481:     rval = FETCH_OPND(-1);
31481:     str2 = JSVAL_TO_STRING(rval);
33585:     obj = js_NewXMLSpecialObject(cx, JSXML_CLASS_PROCESSING_INSTRUCTION, str, str2);
31481:     if (!obj)
31481:         goto error;
31481:     STORE_OPND(-1, OBJECT_TO_JSVAL(obj));
31481: END_CASE(JSOP_XMLPI)
31481: 
31481: BEGIN_CASE(JSOP_GETFUNNS)
31481:     if (!js_GetFunctionNamespace(cx, &rval))
31481:         goto error;
31481:     PUSH_OPND(rval);
31481: END_CASE(JSOP_GETFUNNS)
31481: #endif /* JS_HAS_XML_SUPPORT */
31481: 
31481: BEGIN_CASE(JSOP_ENTERBLOCK)
31481:     LOAD_OBJECT(0);
31481:     JS_ASSERT(!OBJ_IS_CLONED_BLOCK(obj));
31481:     JS_ASSERT(StackBase(fp) + OBJ_BLOCK_DEPTH(cx, obj) == regs.sp);
31481:     vp = regs.sp + OBJ_BLOCK_COUNT(cx, obj);
31481:     JS_ASSERT(regs.sp < vp);
31481:     JS_ASSERT(vp <= fp->slots + script->nslots);
31481:     while (regs.sp < vp) {
31481:         STORE_OPND(0, JSVAL_VOID);
31481:         regs.sp++;
31481:     }
31481: 
31481: #ifdef DEBUG
39930:     JS_ASSERT(fp->blockChain == obj->getParent());
31481: 
31481:     /*
33585:      * The young end of fp->scopeChain may omit blocks if we haven't closed
33585:      * over them, but if there are any closure blocks on fp->scopeChain, they'd
33585:      * better be (clones of) ancestors of the block we're entering now;
33585:      * anything else we should have popped off fp->scopeChain when we left its
33585:      * static scope.
31481:      */
31481:     obj2 = fp->scopeChain;
39930:     while ((clasp = obj2->getClass()) == &js_WithClass)
39930:         obj2 = obj2->getParent();
31481:     if (clasp == &js_BlockClass &&
32684:         obj2->getPrivate() == fp) {
39928:         JSObject *youngestProto = obj2->getProto();
31481:         JS_ASSERT(!OBJ_IS_CLONED_BLOCK(youngestProto));
31481:         parent = obj;
39930:         while ((parent = parent->getParent()) != youngestProto)
31481:             JS_ASSERT(parent);
31481:     }
31481: #endif
31481: 
31481:     fp->blockChain = obj;
31481: END_CASE(JSOP_ENTERBLOCK)
31481: 
31481: BEGIN_CASE(JSOP_LEAVEBLOCKEXPR)
31481: BEGIN_CASE(JSOP_LEAVEBLOCK)
31481: {
31481: #ifdef DEBUG
40826:     JS_ASSERT(fp->blockChain->getClass() == &js_BlockClass);
31481:     uintN blockDepth = OBJ_BLOCK_DEPTH(cx, fp->blockChain);
31481: 
31481:     JS_ASSERT(blockDepth <= StackDepth(script));
31481: #endif
31481:     /*
33585:      * If we're about to leave the dynamic scope of a block that has been
33585:      * cloned onto fp->scopeChain, clear its private data, move its locals from
33585:      * the stack into the clone, and pop it off the chain.
31481:      */
31481:     obj = fp->scopeChain;
39928:     if (obj->getProto() == fp->blockChain) {
40826:         JS_ASSERT(obj->getClass() == &js_BlockClass);
31481:         if (!js_PutBlockObject(cx, JS_TRUE))
31481:             goto error;
31481:     }
31481: 
31481:     /* Pop the block chain, too.  */
39930:     fp->blockChain = fp->blockChain->getParent();
31481: 
33585:     /* Move the result of the expression to the new topmost stack slot. */
31481:     if (op == JSOP_LEAVEBLOCKEXPR)
31481:         rval = FETCH_OPND(-1);
31481:     regs.sp -= GET_UINT16(regs.pc);
31481:     if (op == JSOP_LEAVEBLOCKEXPR) {
31481:         JS_ASSERT(StackBase(fp) + blockDepth == regs.sp - 1);
31481:         STORE_OPND(-1, rval);
31481:     } else {
31481:         JS_ASSERT(StackBase(fp) + blockDepth == regs.sp);
31481:     }
31481: }
31481: END_CASE(JSOP_LEAVEBLOCK)
31481: 
31481: BEGIN_CASE(JSOP_CALLBUILTIN)
31481: #ifdef JS_TRACER
37741:     obj = GetBuiltinFunction(cx, GET_INDEX(regs.pc));
31481:     if (!obj)
31481:         goto error;
31481:     rval = FETCH_OPND(-1);
31481:     PUSH_OPND(rval);
31481:     STORE_OPND(-2, OBJECT_TO_JSVAL(obj));
31481: #else
31481:     goto bad_opcode;  /* This is an imacro-only opcode. */
31481: #endif
31481: END_CASE(JSOP_CALLBUILTIN)
31481: 
31481: #if JS_HAS_GENERATORS
31481: BEGIN_CASE(JSOP_GENERATOR)
31481:     ASSERT_NOT_THROWING(cx);
31481:     regs.pc += JSOP_GENERATOR_LENGTH;
37777:     obj = js_NewGenerator(cx);
31481:     if (!obj)
31481:         goto error;
31481:     JS_ASSERT(!fp->callobj && !fp->argsobj);
31481:     fp->rval = OBJECT_TO_JSVAL(obj);
31481:     ok = JS_TRUE;
31481:     if (inlineCallCount != 0)
31481:         goto inline_return;
31481:     goto exit;
31481: 
31481: BEGIN_CASE(JSOP_YIELD)
31481:     ASSERT_NOT_THROWING(cx);
31481:     if (FRAME_TO_GENERATOR(fp)->state == JSGEN_CLOSING) {
31481:         js_ReportValueError(cx, JSMSG_BAD_GENERATOR_YIELD,
31481:                             JSDVG_SEARCH_STACK, fp->argv[-2], NULL);
31481:         goto error;
31481:     }
31481:     fp->rval = FETCH_OPND(-1);
31481:     fp->flags |= JSFRAME_YIELDING;
31481:     regs.pc += JSOP_YIELD_LENGTH;
31481:     ok = JS_TRUE;
31481:     goto exit;
31481: 
31481: BEGIN_CASE(JSOP_ARRAYPUSH)
31481:     slot = GET_UINT16(regs.pc);
31481:     JS_ASSERT(script->nfixed <= slot);
31481:     JS_ASSERT(slot < script->nslots);
31481:     lval = fp->slots[slot];
31481:     obj  = JSVAL_TO_OBJECT(lval);
31481:     rval = FETCH_OPND(-1);
31481:     if (!js_ArrayCompPush(cx, obj, rval))
31481:         goto error;
31481:     regs.sp--;
31481: END_CASE(JSOP_ARRAYPUSH)
31481: #endif /* JS_HAS_GENERATORS */
31481: 
31481: #if JS_THREADED_INTERP
31481:   L_JSOP_BACKPATCH:
31481:   L_JSOP_BACKPATCH_POP:
31481: 
31481: # if !JS_HAS_GENERATORS
31481:   L_JSOP_GENERATOR:
31481:   L_JSOP_YIELD:
31481:   L_JSOP_ARRAYPUSH:
31481: # endif
31481: 
31481: # if !JS_HAS_SHARP_VARS
31481:   L_JSOP_DEFSHARP:
31481:   L_JSOP_USESHARP:
32729:   L_JSOP_SHARPINIT:
31481: # endif
31481: 
31481: # if !JS_HAS_DESTRUCTURING
31481:   L_JSOP_ENUMCONSTELEM:
31481: # endif
31481: 
31481: # if !JS_HAS_XML_SUPPORT
31481:   L_JSOP_CALLXMLNAME:
31481:   L_JSOP_STARTXMLEXPR:
31481:   L_JSOP_STARTXML:
31481:   L_JSOP_DELDESC:
31481:   L_JSOP_GETFUNNS:
31481:   L_JSOP_XMLPI:
31481:   L_JSOP_XMLCOMMENT:
31481:   L_JSOP_XMLCDATA:
31481:   L_JSOP_XMLOBJECT:
31481:   L_JSOP_XMLELTEXPR:
31481:   L_JSOP_XMLTAGEXPR:
31481:   L_JSOP_TOXMLLIST:
31481:   L_JSOP_TOXML:
31481:   L_JSOP_ENDFILTER:
31481:   L_JSOP_FILTER:
31481:   L_JSOP_DESCENDANTS:
31481:   L_JSOP_XMLNAME:
31481:   L_JSOP_SETXMLNAME:
31481:   L_JSOP_BINDXMLNAME:
31481:   L_JSOP_ADDATTRVAL:
31481:   L_JSOP_ADDATTRNAME:
31481:   L_JSOP_TOATTRVAL:
31481:   L_JSOP_TOATTRNAME:
31481:   L_JSOP_QNAME:
31481:   L_JSOP_QNAMECONST:
31481:   L_JSOP_QNAMEPART:
31481:   L_JSOP_ANYNAME:
31481:   L_JSOP_DEFXMLNS:
31481: # endif
31481: #endif /* !JS_THREADED_INTERP */
