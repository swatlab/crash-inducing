 29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
     1:  * vim: set ts=8 sw=4 et tw=78:
     1:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /*
     1:  * JS script operations.
     1:  */
 88221: 
     1: #include <string.h>
     1: #include "jstypes.h"
 55477: #include "jsutil.h"
 75365: #include "jscrashreport.h"
     1: #include "jsprf.h"
     1: #include "jsapi.h"
     1: #include "jsatom.h"
     1: #include "jscntxt.h"
 18863: #include "jsversion.h"
     1: #include "jsdbgapi.h"
     1: #include "jsfun.h"
 68933: #include "jsgc.h"
     1: #include "jsinterp.h"
     1: #include "jslock.h"
     1: #include "jsnum.h"
     1: #include "jsopcode.h"
 18955: #include "jsscope.h"
     1: #include "jsscript.h"
 80506: 
 97569: #include "gc/Marking.h"
 80964: #include "frontend/BytecodeEmitter.h"
 80506: #include "frontend/Parser.h"
 86104: #include "js/MemoryMetrics.h"
 52559: #include "methodjit/MethodJIT.h"
 77169: #include "methodjit/Retcon.h"
 76244: #include "vm/Debugger.h"
 94006: #include "vm/Xdr.h"
     1: 
 77343: #include "jsinferinlines.h"
 79734: #include "jsinterpinlines.h"
 42733: #include "jsobjinlines.h"
 32737: #include "jsscriptinlines.h"
 32737: 
108850: #include "frontend/SharedContext-inl.h"
 97298: #include "vm/RegExpObject-inl.h"
 97298: 
 37741: using namespace js;
 54707: using namespace js::gc;
 80632: using namespace js::frontend;
 37741: 
105580: unsigned
105580: Bindings::argumentsVarIndex(JSContext *cx) const
105580: {
108509:     PropertyName *arguments = cx->runtime->atomState.argumentsAtom;
108509:     BindingIter bi(*this);
108509:     while (bi->name() != arguments)
108509:         bi++;
105580:     return bi.frameIndex();
 59968: }
 59968: 
 59968: bool
108580: Bindings::initWithTemporaryStorage(JSContext *cx, unsigned numArgs, unsigned numVars, Binding *bindingArray)
 59968: {
108509:     JS_ASSERT(!callObjShape_);
108580:     JS_ASSERT(bindingArrayAndFlag_ == TEMPORARY_STORAGE_BIT);
 59968: 
108509:     if (numArgs > UINT16_MAX || numVars > UINT16_MAX) {
 95101:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
108509:                              numArgs_ > numVars_ ?
108509:                              JSMSG_TOO_MANY_FUN_ARGS :
108509:                              JSMSG_TOO_MANY_LOCALS);
 95101:         return false;
 95101:     }
 95101: 
108580:     JS_ASSERT(!(uintptr_t(bindingArray) & TEMPORARY_STORAGE_BIT));
108580:     bindingArrayAndFlag_ = uintptr_t(bindingArray) | TEMPORARY_STORAGE_BIT;
108509:     numArgs_ = numArgs;
108509:     numVars_ = numVars;
108509: 
 59968:     /*
108509:      * Get the initial shape to use when creating CallObjects for this script.
108509:      * Since unaliased variables are, by definition, only accessed by local
108509:      * operations and never through the scope chain, only give shapes to
108509:      * aliased variables. While the debugger may observe any scope object at
108509:      * any time, such accesses are mediated by DebugScopeProxy (see
108509:      * DebugScopeProxy::handleUnaliasedAccess).
 59968:      */
 59968: 
108509:     JS_STATIC_ASSERT(CallObject::RESERVED_SLOTS == 2);
108509:     gc::AllocKind allocKind = gc::FINALIZE_OBJECT2_BACKGROUND;
108509:     JS_ASSERT(gc::GetGCKindSlots(allocKind) == CallObject::RESERVED_SLOTS);
108509:     callObjShape_ = EmptyShape::getInitialShape(cx, &CallClass, NULL, cx->global(),
108509:                                                 allocKind, BaseShape::VAROBJ);
 59968: 
108509: #ifdef DEBUG
108509:     HashSet<PropertyName *> added(cx);
108509:     if (!added.init())
108509:         return false;
108509: #endif
 59968: 
108509:     BindingIter bi(*this);
108509:     unsigned slot = CallObject::RESERVED_SLOTS;
108509:     for (unsigned i = 0, n = count(); i < n; i++, bi++) {
108509:         if (!bi->aliased())
108509:             continue;
 59968: 
108509: #ifdef DEBUG
108509:         /* The caller ensures no duplicate aliased names. */
108509:         JS_ASSERT(!added.has(bi->name()));
108509:         if (!added.put(bi->name()))
108509:             return false;
108509: #endif
 59968: 
108509:         StackBaseShape base(&CallClass, cx->global(), BaseShape::VAROBJ);
 84345:         UnownedBaseShape *nbase = BaseShape::getUnowned(cx, base);
 83221:         if (!nbase)
101773:             return false;
 59968: 
108509:         RootedId id(cx, NameToId(bi->name()));
108509:         unsigned attrs = JSPROP_PERMANENT | JSPROP_ENUMERATE |
108509:                          (bi->kind() == CONSTANT ? JSPROP_READONLY : 0);
108509:         unsigned frameIndex = bi.frameIndex();
108509:         StackShape child(nbase, id, slot++, 0, attrs, Shape::HAS_SHORTID, frameIndex);
 83221: 
108509:         callObjShape_ = callObjShape_->getChildBinding(cx, child);
108509:         if (!callObjShape_)
 59968:             return false;
108509:     }
108509:     JS_ASSERT(!bi);
 59968: 
 59968:     return true;
 59968: }
 59968: 
108509: uint8_t *
108580: Bindings::switchToScriptStorage(Binding *newBindingArray)
 89745: {
108580:     JS_ASSERT(bindingArrayUsingTemporaryStorage());
108580:     JS_ASSERT(!(uintptr_t(newBindingArray) & TEMPORARY_STORAGE_BIT));
108580: 
108580:     PodCopy(newBindingArray, bindingArray(), count());
108580:     bindingArrayAndFlag_ = uintptr_t(newBindingArray);
108509:     return reinterpret_cast<uint8_t *>(newBindingArray + count());
 89745: }
 89745: 
108505: bool
108509: Bindings::clone(JSContext *cx, uint8_t *dstScriptData, HandleScript srcScript)
108505: {
108509:     /* The clone has the same bindingArray_ offset as 'src'. */
108509:     Bindings &src = srcScript->bindings;
108580:     ptrdiff_t off = (uint8_t *)src.bindingArray() - srcScript->data;
108509:     JS_ASSERT(off >= 0);
108509:     JS_ASSERT(off <= (srcScript->code - srcScript->data));
108509:     Binding *dstPackedBindings = (Binding *)(dstScriptData + off);
108509: 
108509:     /*
108509:      * Since atoms are shareable throughout the runtime, we can simply copy
108509:      * the source's bindingArray directly.
108509:      */
108580:     if (!initWithTemporaryStorage(cx, src.numArgs(), src.numVars(), src.bindingArray()))
108580:         return false;
108580:     switchToScriptStorage(dstPackedBindings);
108580:     return true;
108509: }
108509: 
108509: template<XDRMode mode>
108509: static bool
108509: XDRScriptBindings(XDRState<mode> *xdr, LifoAllocScope &las, unsigned numArgs, unsigned numVars,
108509:                   HandleScript script)
108509: {
108509:     JSContext *cx = xdr->cx();
108509: 
108509:     if (mode == XDR_ENCODE) {
108509:         for (BindingIter bi(script->bindings); bi; bi++) {
108509:             JSAtom *atom = bi->name();
108509:             if (!XDRAtom(xdr, &atom))
108509:                 return false;
108509:         }
108509: 
108509:         for (BindingIter bi(script->bindings); bi; bi++) {
108509:             uint8_t u8 = (uint8_t(bi->kind()) << 1) | bi->aliased();
108509:             if (!xdr->codeUint8(&u8))
108509:                 return false;
108509:         }
108509:     } else {
108509:         unsigned nameCount = numArgs + numVars;
108509: 
108509:         AutoValueVector atoms(cx);
108509:         if (!atoms.resize(nameCount))
108509:             return false;
108509:         for (unsigned i = 0; i < nameCount; i++) {
108509:             JSAtom *atom;
108509:             if (!XDRAtom(xdr, &atom))
108509:                 return false;
108509:             atoms[i] = StringValue(atom);
108509:         }
108509: 
108509:         Binding *bindingArray = las.alloc().newArrayUninitialized<Binding>(nameCount);
108509:         if (!bindingArray)
108509:             return false;
108509:         for (unsigned i = 0; i < nameCount; i++) {
108509:             uint8_t u8;
108509:             if (!xdr->codeUint8(&u8))
108505:                 return false;
108505: 
108509:             PropertyName *name = atoms[i].toString()->asAtom().asPropertyName();
108509:             BindingKind kind = BindingKind(u8 >> 1);
108509:             bool aliased = bool(u8 & 1);
108509: 
108509:             bindingArray[i] = Binding(name, kind, aliased);
108509:         }
108509: 
108580:         if (!script->bindings.initWithTemporaryStorage(cx, numArgs, numVars, bindingArray))
108505:             return false;
108505:     }
108509: 
108509:     return true;
108505: }
108509: 
108509: bool
108509: Bindings::bindingIsAliased(unsigned bindingIndex)
108509: {
108509:     JS_ASSERT(bindingIndex < count());
108580:     return bindingArray()[bindingIndex].aliased();
108505: }
108505: 
 59968: void
 59968: Bindings::trace(JSTracer *trc)
 59968: {
108509:     if (callObjShape_)
108509:         MarkShape(trc, &callObjShape_, "callObjShape");
108509: 
108580:     /*
108580:      * As the comment in Bindings explains, bindingsArray may point into freed
108580:      * storage when bindingArrayUsingTemporaryStorage so we don't mark it.
108580:      * Note: during compilation, atoms are already kept alive by gcKeepAtoms.
108580:      */
108580:     if (bindingArrayUsingTemporaryStorage())
108580:         return;
108580: 
108580:     for (Binding *b = bindingArray(), *end = b + count(); b != end; b++) {
108509:         PropertyName *name = b->name();
108509:         MarkStringUnbarriered(trc, &name, "bindingArray");
108509:     }
108509: }
108509: 
108509: bool
108509: js::FillBindingVector(Bindings &bindings, BindingVector *vec)
108509: {
108509:     for (BindingIter bi(bindings); bi; bi++) {
108509:         if (!vec->append(*bi))
108509:             return false;
108509:     }
108509: 
108509:     return true;
 59968: }
 59968: 
 94006: template<XDRMode mode>
 90546: static bool
 94006: XDRScriptConst(XDRState<mode> *xdr, HeapValue *vp)
 90546: {
 90546:     /*
 90546:      * A script constant can be an arbitrary primitive value as they are used
 90546:      * to implement JSOP_LOOKUPSWITCH. But they cannot be objects, see
 90546:      * bug 407186.
 90546:      */
 90546:     enum ConstTag {
 90546:         SCRIPT_INT     = 0,
 90546:         SCRIPT_DOUBLE  = 1,
 97296:         SCRIPT_ATOM    = 2,
 90546:         SCRIPT_TRUE    = 3,
 90546:         SCRIPT_FALSE   = 4,
 90546:         SCRIPT_NULL    = 5,
 90546:         SCRIPT_VOID    = 6
 90546:     };
 90546: 
 90546:     uint32_t tag;
 94006:     if (mode == XDR_ENCODE) {
 90546:         if (vp->isInt32()) {
 90546:             tag = SCRIPT_INT;
 90546:         } else if (vp->isDouble()) {
 90546:             tag = SCRIPT_DOUBLE;
 90546:         } else if (vp->isString()) {
 97296:             tag = SCRIPT_ATOM;
 90546:         } else if (vp->isTrue()) {
 90546:             tag = SCRIPT_TRUE;
 90546:         } else if (vp->isFalse()) {
 90546:             tag = SCRIPT_FALSE;
 90546:         } else if (vp->isNull()) {
 90546:             tag = SCRIPT_NULL;
 90546:         } else {
 90546:             JS_ASSERT(vp->isUndefined());
 90546:             tag = SCRIPT_VOID;
 90546:         }
 90546:     }
 90546: 
 94006:     if (!xdr->codeUint32(&tag))
 90546:         return false;
 90546: 
 90546:     switch (tag) {
 90546:       case SCRIPT_INT: {
 90546:         uint32_t i;
 94006:         if (mode == XDR_ENCODE)
 90546:             i = uint32_t(vp->toInt32());
 94006:         if (!xdr->codeUint32(&i))
 90546:             return JS_FALSE;
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(Int32Value(int32_t(i)));
 90546:         break;
 90546:       }
 90546:       case SCRIPT_DOUBLE: {
 90546:         double d;
 94006:         if (mode == XDR_ENCODE)
 90546:             d = vp->toDouble();
 94006:         if (!xdr->codeDouble(&d))
 90546:             return false;
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(DoubleValue(d));
 90546:         break;
 90546:       }
 97296:       case SCRIPT_ATOM: {
 97296:         JSAtom *atom;
 94006:         if (mode == XDR_ENCODE)
 97296:             atom = &vp->toString()->asAtom();
 97296:         if (!XDRAtom(xdr, &atom))
 90546:             return false;
 94006:         if (mode == XDR_DECODE)
 97296:             vp->init(StringValue(atom));
 90546:         break;
 90546:       }
 90546:       case SCRIPT_TRUE:
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(BooleanValue(true));
 90546:         break;
 90546:       case SCRIPT_FALSE:
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(BooleanValue(false));
 90546:         break;
 90546:       case SCRIPT_NULL:
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(NullValue());
 90546:         break;
 90546:       case SCRIPT_VOID:
 94006:         if (mode == XDR_DECODE)
 90546:             vp->init(UndefinedValue());
 90546:         break;
 90546:     }
 90546:     return true;
 90546: }
 90546: 
104378: static inline uint32_t
104378: FindBlockIndex(JSScript *script, StaticBlockObject &block)
104378: {
104378:     ObjectArray *objects = script->objects();
104378:     HeapPtrObject *vector = objects->vector;
104378:     unsigned length = objects->length;
104378:     for (unsigned i = 0; i < length; ++i) {
104378:         if (vector[i] == &block)
104378:             return i;
104378:     }
104378: 
104378:     JS_NOT_REACHED("Block not found");
104378:     return UINT32_MAX;
104378: }
104378: 
 94006: template<XDRMode mode>
 94006: bool
104378: js::XDRScript(XDRState<mode> *xdr, HandleObject enclosingScope, HandleScript enclosingScript,
104378:               HandleFunction fun, JSScript **scriptp)
 90546: {
 97298:     /* NB: Keep this in sync with CloneScript. */
 97298: 
 54840:     enum ScriptBits {
 54840:         NoScriptRval,
 54840:         SavedCallerFun,
 54840:         StrictModeCode,
 95099:         ContainsDynamicNameAccess,
101616:         FunHasExtensibleScope,
108509:         FunHasAnyAliasedFormal,
103284:         ArgumentsHasVarBinding,
 93250:         NeedsArgsObj,
 90856:         OwnFilename,
 95100:         ParentFilename,
105944:         IsGenerator,
106311:         IsGeneratorExp,
105944:         OwnSource,
105944:         ExplicitUseStrict
 54840:     };
 54840: 
 84755:     uint32_t length, lineno, nslots;
108509:     uint32_t natoms, nsrcnotes, ntrynotes, nobjects, nregexps, nconsts, i;
 94572:     uint32_t prologLength, version;
 84755:     uint32_t nTypeSets = 0;
 84755:     uint32_t scriptBits = 0;
     1: 
 94006:     JSContext *cx = xdr->cx();
104205:     Rooted<JSScript*> script(cx);
108509:     nsrcnotes = ntrynotes = natoms = nobjects = nregexps = nconsts = 0;
 59968:     jssrcnote *notes = NULL;
     1: 
104378:     /* XDR arguments and vars. */
104378:     uint16_t nargs = 0, nvars = 0;
104378:     uint32_t argsVars = 0;
 94006:     if (mode == XDR_ENCODE) {
 90546:         script = *scriptp;
104378:         JS_ASSERT_IF(enclosingScript, enclosingScript->compartment() == script->compartment());
 90546: 
 95100:         nargs = script->bindings.numArgs();
 95100:         nvars = script->bindings.numVars();
 59968:         argsVars = (nargs << 16) | nvars;
 59968:     }
 94006:     if (!xdr->codeUint32(&argsVars))
 59968:         return false;
 94006:     if (mode == XDR_DECODE) {
 59968:         nargs = argsVars >> 16;
 59968:         nvars = argsVars & 0xFFFF;
 59968:     }
 59968: 
 94006:     if (mode == XDR_ENCODE)
 59220:         length = script->length;
 94006:     if (!xdr->codeUint32(&length))
 34290:         return JS_FALSE;
 34290: 
 94006:     if (mode == XDR_ENCODE) {
 77659:         prologLength = script->mainOffset;
 53848:         JS_ASSERT(script->getVersion() != JSVERSION_UNKNOWN);
 84755:         version = (uint32_t)script->getVersion() | (script->nfixed << 16);
 93548:         lineno = script->lineno;
 84755:         nslots = (uint32_t)script->nslots;
 84755:         nslots = (uint32_t)((script->staticLevel << 16) | script->nslots);
 77659:         natoms = script->natoms;
     1: 
 32723:         notes = script->notes();
 72071:         nsrcnotes = script->numNotes();
     1: 
 97361:         if (script->hasConsts())
 94572:             nconsts = script->consts()->length;
 97361:         if (script->hasObjects())
 32723:             nobjects = script->objects()->length;
 97361:         if (script->hasRegexps())
 32723:             nregexps = script->regexps()->length;
 97361:         if (script->hasTrynotes())
 32723:             ntrynotes = script->trynotes()->length;
 54840: 
 77343:         nTypeSets = script->nTypeSets;
 77343: 
 54840:         if (script->noScriptRval)
 54840:             scriptBits |= (1 << NoScriptRval);
 54840:         if (script->savedCallerFun)
 54840:             scriptBits |= (1 << SavedCallerFun);
 54840:         if (script->strictModeCode)
 54840:             scriptBits |= (1 << StrictModeCode);
105944:         if (script->explicitUseStrict)
105944:             scriptBits |= (1 << ExplicitUseStrict);
 95099:         if (script->bindingsAccessedDynamically)
 95099:             scriptBits |= (1 << ContainsDynamicNameAccess);
101616:         if (script->funHasExtensibleScope)
101616:             scriptBits |= (1 << FunHasExtensibleScope);
108509:         if (script->funHasAnyAliasedFormal)
108509:             scriptBits |= (1 << FunHasAnyAliasedFormal);
103284:         if (script->argumentsHasVarBinding())
103284:             scriptBits |= (1 << ArgumentsHasVarBinding);
 93250:         if (script->analyzedArgsUsage() && script->needsArgsObj())
 93250:             scriptBits |= (1 << NeedsArgsObj);
 90856:         if (script->filename) {
104378:             scriptBits |= (enclosingScript && enclosingScript->filename == script->filename)
 94006:                           ? (1 << ParentFilename)
 94006:                           : (1 << OwnFilename);
 90856:         }
107687:         if (!enclosingScript || enclosingScript->scriptSource() != script->scriptSource())
105946:             scriptBits |= (1 << OwnSource);
 95100:         if (script->isGenerator)
 95100:             scriptBits |= (1 << IsGenerator);
106311:         if (script->isGeneratorExp)
106311:             scriptBits |= (1 << IsGeneratorExp);
 90856: 
 59962:         JS_ASSERT(!script->compileAndGo);
 59962:         JS_ASSERT(!script->hasSingletons);
     1:     }
     1: 
 94006:     if (!xdr->codeUint32(&prologLength))
     1:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&version))
     1:         return JS_FALSE;
     1: 
  3235:     /*
 59968:      * To fuse allocations, we need srcnote, atom, objects, regexp, and trynote
 59968:      * counts early.
  3235:      */
 94006:     if (!xdr->codeUint32(&natoms))
  3235:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&nsrcnotes))
     1:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&ntrynotes))
     1:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&nobjects))
  3235:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&nregexps))
  3235:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&nconsts))
 48470:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&nTypeSets))
 77343:         return JS_FALSE;
 94006:     if (!xdr->codeUint32(&scriptBits))
 54840:         return JS_FALSE;
     1: 
 94006:     if (mode == XDR_DECODE) {
 61450:         /* Note: version is packed into the 32b space with another 16b value. */
 61450:         JSVersion version_ = JSVersion(version & JS_BITMASK(16));
 91237:         JS_ASSERT((version_ & VersionFlags::FULL_MASK) == unsigned(version_));
102048: 
102048:         // principals and originPrincipals are set with xdr->initScriptPrincipals(script) below.
102051:         // staticLevel is set below.
106508:         CompileOptions options(cx);
106508:         options.setVersion(version_)
106508:                .setNoScriptRval(!!(scriptBits & (1 << NoScriptRval)));
107053:         ScriptSource *ss;
107053:         if (scriptBits & (1 << OwnSource)) {
107053:             ss = cx->new_<ScriptSource>();
107053:             if (!ss)
108811:                 return false;
107053:         } else {
107053:             JS_ASSERT(enclosingScript);
107053:             ss = enclosingScript->scriptSource();
107053:         }
107564:         ScriptSourceHolder ssh(cx->runtime, ss);
106508:         script = JSScript::Create(cx, enclosingScope, !!(scriptBits & (1 << SavedCallerFun)),
107053:                                   options, /* staticLevel = */ 0, ss, 0, 0);
108509:         if (!script)
108509:             return false;
108509:     }
  3235: 
108509:     /* JSScript::partiallyInit assumes script->bindings is fully initialized. */
108509:     LifoAllocScope las(&cx->tempLifoAlloc());
108509:     if (!XDRScriptBindings(xdr, las, nargs, nvars, script))
108509:         return false;
108509: 
108509:     if (mode == XDR_DECODE) {
108509:         if (!JSScript::partiallyInit(cx, script, length, nsrcnotes, natoms, nobjects, nregexps,
108509:                                      ntrynotes, nconsts, nTypeSets))
108509:             return false;
108509: 
 77659:         JS_ASSERT(!script->mainOffset);
 77659:         script->mainOffset = prologLength;
 84755:         script->nfixed = uint16_t(version >> 16);
     1: 
     1:         /* If we know nsrcnotes, we allocated space for notes in script. */
 32723:         notes = script->notes();
     1:         *scriptp = script;
 54840: 
 54840:         if (scriptBits & (1 << StrictModeCode))
 54840:             script->strictModeCode = true;
105944:         if (scriptBits & (1 << ExplicitUseStrict))
105944:             script->explicitUseStrict = true;
 95099:         if (scriptBits & (1 << ContainsDynamicNameAccess))
 95099:             script->bindingsAccessedDynamically = true;
101616:         if (scriptBits & (1 << FunHasExtensibleScope))
101616:             script->funHasExtensibleScope = true;
108509:         if (scriptBits & (1 << FunHasAnyAliasedFormal))
108509:             script->funHasAnyAliasedFormal = true;
103284:         if (scriptBits & (1 << ArgumentsHasVarBinding))
103284:             script->setArgumentsHasVarBinding();
 93250:         if (scriptBits & (1 << NeedsArgsObj))
 93250:             script->setNeedsArgsObj(true);
 95100:         if (scriptBits & (1 << IsGenerator))
 95100:             script->isGenerator = true;
106311:         if (scriptBits & (1 << IsGeneratorExp))
106311:             script->isGeneratorExp = true;
     1:     }
     1: 
 94006:     JS_STATIC_ASSERT(sizeof(jsbytecode) == 1);
 94006:     JS_STATIC_ASSERT(sizeof(jssrcnote) == 1);
 94006:     if (!xdr->codeBytes(script->code, length) ||
 94006:         !xdr->codeBytes(notes, nsrcnotes) ||
 94006:         !xdr->codeUint32(&lineno) ||
 94006:         !xdr->codeUint32(&nslots)) {
 90546:         return false;
     1:     }
     1: 
 90856:     if (scriptBits & (1 << OwnFilename)) {
 94006:         const char *filename;
 94006:         if (mode == XDR_ENCODE)
 94006:             filename = script->filename;
 94006:         if (!xdr->codeCString(&filename))
 90546:             return false;
 94006:         if (mode == XDR_DECODE) {
 94006:             script->filename = SaveScriptFilename(cx, filename);
 90856:             if (!script->filename)
 90856:                 return false;
 93548:         }
 94006:     } else if (scriptBits & (1 << ParentFilename)) {
104378:         JS_ASSERT(enclosingScript);
 94006:         if (mode == XDR_DECODE)
104378:             script->filename = enclosingScript->filename;
 64372:     }
 64301: 
107687:     if (scriptBits & (1 << OwnSource)) {
107053:         if (!script->scriptSource()->performXDR<mode>(xdr))
105944:             return false;
105946:     }
105944:     if (!xdr->codeUint32(&script->sourceStart))
105944:         return false;
105944:     if (!xdr->codeUint32(&script->sourceEnd))
105944:         return false;
105944: 
 94006:     if (mode == XDR_DECODE) {
 93548:         script->lineno = lineno;
 93548:         script->nslots = uint16_t(nslots);
 93548:         script->staticLevel = uint16_t(nslots >> 16);
 94006:         xdr->initScriptPrincipals(script);
     1:     }
     1: 
  3235:     for (i = 0; i != natoms; ++i) {
 94934:         if (mode == XDR_DECODE) {
 94934:             JSAtom *tmp = NULL;
 94934:             if (!XDRAtom(xdr, &tmp))
 90546:                 return false;
 94934:             script->atoms[i].init(tmp);
 94934:         } else {
 94934:             JSAtom *tmp = script->atoms[i];
 94934:             if (!XDRAtom(xdr, &tmp))
 94934:                 return false;
 94934:         }
  3235:     }
  1825: 
     1:     /*
104378:      * Here looping from 0-to-length to xdr objects is essential to ensure that
104378:      * all references to enclosing blocks (via FindBlockIndex below) happen
104378:      * after the enclosing block has been XDR'd.
     1:      */
  3235:     for (i = 0; i != nobjects; ++i) {
 82129:         HeapPtr<JSObject> *objp = &script->objects()->vector[i];
 84755:         uint32_t isBlock;
 94006:         if (mode == XDR_ENCODE) {
 86483:             JSObject *obj = *objp;
 86483:             JS_ASSERT(obj->isFunction() || obj->isStaticBlock());
 86483:             isBlock = obj->isBlock() ? 1 : 0;
 28093:         }
 94006:         if (!xdr->codeUint32(&isBlock))
 90546:             return false;
 86483:         if (isBlock == 0) {
104378:             /* Code the nested function's enclosing scope. */
104378:             uint32_t funEnclosingScopeIndex = 0;
104378:             if (mode == XDR_ENCODE) {
104378:                 StaticScopeIter ssi((*objp)->toFunction()->script()->enclosingStaticScope());
104378:                 if (ssi.done() || ssi.type() == StaticScopeIter::FUNCTION) {
104378:                     JS_ASSERT(ssi.done() == !fun);
104378:                     funEnclosingScopeIndex = UINT32_MAX;
104378:                 } else {
104378:                     funEnclosingScopeIndex = FindBlockIndex(script, ssi.block());
104378:                     JS_ASSERT(funEnclosingScopeIndex < i);
104378:                 }
104378:             }
104378:             if (!xdr->codeUint32(&funEnclosingScopeIndex))
104378:                 return false;
104378:             Rooted<JSObject*> funEnclosingScope(cx);
104378:             if (mode == XDR_DECODE) {
104378:                 if (funEnclosingScopeIndex == UINT32_MAX) {
104378:                     funEnclosingScope = fun;
104378:                 } else {
104378:                     JS_ASSERT(funEnclosingScopeIndex < i);
104378:                     funEnclosingScope = script->objects()->vector[funEnclosingScopeIndex];
104378:                 }
104378:             }
104378: 
107154:             RootedObject tmp(cx, *objp);
104378:             if (!XDRInterpretedFunction(xdr, funEnclosingScope, script, &tmp))
 90546:                 return false;
 86483:             *objp = tmp;
 28093:         } else {
104378:             /* Code the nested block's enclosing scope. */
 28093:             JS_ASSERT(isBlock == 1);
104378:             uint32_t blockEnclosingScopeIndex = 0;
104378:             if (mode == XDR_ENCODE) {
104378:                 if (StaticBlockObject *block = (*objp)->asStaticBlock().enclosingBlock())
104378:                     blockEnclosingScopeIndex = FindBlockIndex(script, *block);
104378:                 else
104378:                     blockEnclosingScopeIndex = UINT32_MAX;
104378:             }
104378:             if (!xdr->codeUint32(&blockEnclosingScopeIndex))
104378:                 return false;
104378:             Rooted<JSObject*> blockEnclosingScope(cx);
104378:             if (mode == XDR_DECODE) {
104378:                 if (blockEnclosingScopeIndex != UINT32_MAX) {
104378:                     JS_ASSERT(blockEnclosingScopeIndex < i);
104378:                     blockEnclosingScope = script->objects()->vector[blockEnclosingScopeIndex];
104378:                 } else {
104378:                     blockEnclosingScope = fun;
104378:                 }
104378:             }
104378: 
107154:             Rooted<StaticBlockObject*> tmp(cx, static_cast<StaticBlockObject *>(objp->get()));
107154:             if (!XDRStaticBlockObject(xdr, blockEnclosingScope, script, tmp.address()))
 90546:                 return false;
 86483:             *objp = tmp;
 28093:         }
     1:     }
  3235:     for (i = 0; i != nregexps; ++i) {
 90546:         if (!XDRScriptRegExpObject(xdr, &script->regexps()->vector[i]))
 90546:             return false;
     1:     }
     1: 
  3235:     if (ntrynotes != 0) {
  1825:         /*
  3235:          * We combine tn->kind and tn->stackDepth when serializing as XDR is not
  1825:          * efficient when serializing small integer types.
  1825:          */
  3235:         JSTryNote *tn, *tnfirst;
 84755:         uint32_t kindAndDepth;
 84755:         JS_STATIC_ASSERT(sizeof(tn->kind) == sizeof(uint8_t));
 84755:         JS_STATIC_ASSERT(sizeof(tn->stackDepth) == sizeof(uint16_t));
     1: 
 32723:         tnfirst = script->trynotes()->vector;
 32723:         JS_ASSERT(script->trynotes()->length == ntrynotes);
  3235:         tn = tnfirst + ntrynotes;
  3235:         do {
  3235:             --tn;
 94006:             if (mode == XDR_ENCODE) {
 84755:                 kindAndDepth = (uint32_t(tn->kind) << 16)
 84755:                                | uint32_t(tn->stackDepth);
  3235:             }
 94006:             if (!xdr->codeUint32(&kindAndDepth) ||
 94006:                 !xdr->codeUint32(&tn->start) ||
 94006:                 !xdr->codeUint32(&tn->length)) {
 90546:                 return false;
     1:             }
 94006:             if (mode == XDR_DECODE) {
 84755:                 tn->kind = uint8_t(kindAndDepth >> 16);
 84755:                 tn->stackDepth = uint16_t(kindAndDepth);
     1:             }
  3235:         } while (tn != tnfirst);
  3235:     }
     1: 
 90546:     if (nconsts) {
 90546:         HeapValue *vector = script->consts()->vector;
 48470:         for (i = 0; i != nconsts; ++i) {
 90546:             if (!XDRScriptConst(xdr, &vector[i]))
 90546:                 return false;
 90546:         }
 48470:     }
 48470: 
 94006:     if (mode == XDR_DECODE) {
 90546:         if (cx->hasRunOption(JSOPTION_PCCOUNT))
 94574:             (void) script->initScriptCounts(cx);
 90546:         *scriptp = script;
 90546:     }
 82134: 
 90546:     return true;
     1: }
     1: 
 94006: template bool
104378: js::XDRScript(XDRState<XDR_ENCODE> *, HandleObject, HandleScript, HandleFunction, JSScript **);
     1: 
 94006: template bool
104378: js::XDRScript(XDRState<XDR_DECODE> *, HandleObject, HandleScript, HandleFunction, JSScript **);
 90546: 
 71699: bool
 94574: JSScript::initScriptCounts(JSContext *cx)
 71699: {
 95113:     JS_ASSERT(!hasScriptCounts);
 82134: 
 94574:     size_t n = 0;
 82134: 
 82134:     jsbytecode *pc, *next;
 82134:     for (pc = code; pc < code + length; pc = next) {
 94574:         n += PCCounts::numCounts(JSOp(*pc));
 84195:         next = pc + GetBytecodeLength(pc);
 82134:     }
 82134: 
 94574:     size_t bytes = (length * sizeof(PCCounts)) + (n * sizeof(double));
 82134:     char *cursor = (char *) cx->calloc_(bytes);
 82134:     if (!cursor)
 71699:         return false;
 82134: 
 95113:     /* Create compartment's scriptCountsMap if necessary. */
 95113:     ScriptCountsMap *map = compartment()->scriptCountsMap;
 95113:     if (!map) {
 95113:         map = cx->new_<ScriptCountsMap>();
 95113:         if (!map || !map->init()) {
 95113:             cx->free_(cursor);
 95113:             cx->delete_(map);
 95113:             return false;
 95113:         }
 95113:         compartment()->scriptCountsMap = map;
 95113:     }
 95113: 
 82134:     DebugOnly<char *> base = cursor;
 82134: 
 95113:     ScriptCounts scriptCounts;
 94574:     scriptCounts.pcCountsVector = (PCCounts *) cursor;
 94574:     cursor += length * sizeof(PCCounts);
 82134: 
 82134:     for (pc = code; pc < code + length; pc = next) {
106334:         JS_ASSERT(uintptr_t(cursor) % sizeof(double) == 0);
 94574:         scriptCounts.pcCountsVector[pc - code].counts = (double *) cursor;
 94574:         size_t capacity = PCCounts::numCounts(JSOp(*pc));
 82134: #ifdef DEBUG
 94574:         scriptCounts.pcCountsVector[pc - code].capacity = capacity;
 82134: #endif
 82134:         cursor += capacity * sizeof(double);
 84195:         next = pc + GetBytecodeLength(pc);
 82134:     }
 82134: 
 95113:     if (!map->putNew(this, scriptCounts)) {
 95113:         cx->free_(cursor);
 95113:         cx->delete_(map);
 95113:         return false;
 95113:     }
 95113:     hasScriptCounts = true; // safe to set this;  we can't fail after this point
 95113: 
 82134:     JS_ASSERT(size_t(cursor - base) == bytes);
 82134: 
 84803:     /* Enable interrupts in any interpreter frames running on this script. */
 84803:     InterpreterFrames *frames;
 88135:     for (frames = cx->runtime->interpreterFrames; frames; frames = frames->older)
 84803:         frames->enableInterruptsIfRunning(this);
 84803: 
 71699:     return true;
 71699: }
 71699: 
 95113: js::PCCounts
 95113: JSScript::getPCCounts(jsbytecode *pc) {
 95113:     JS_ASSERT(hasScriptCounts);
 95113:     JS_ASSERT(size_t(pc - code) < length);
 95113:     ScriptCountsMap *map = compartment()->scriptCountsMap;
 95113:     JS_ASSERT(map);
 95113:     ScriptCountsMap::Ptr p = map->lookup(this);
 95113:     JS_ASSERT(p);
 95113:     return p->value.pcCountsVector[pc - code];
 95113: }
 95113: 
 95113: ScriptCounts
 95113: JSScript::releaseScriptCounts()
 95113: {
 95113:     JS_ASSERT(hasScriptCounts);
 95113:     ScriptCountsMap *map = compartment()->scriptCountsMap;
 95113:     JS_ASSERT(map);
 95113:     ScriptCountsMap::Ptr p = map->lookup(this);
 95113:     JS_ASSERT(p);
 95113:     ScriptCounts counts = p->value;
 95113:     map->remove(p);
 95113:     hasScriptCounts = false;
 95113:     return counts;
 95113: }
 95113: 
 71702: void
 94740: JSScript::destroyScriptCounts(FreeOp *fop)
 71702: {
 95113:     if (hasScriptCounts) {
 95113:         ScriptCounts scriptCounts = releaseScriptCounts();
 94740:         fop->free_(scriptCounts.pcCountsVector);
 71702:     }
 71702: }
 71702: 
105944: #ifdef JS_THREADSAFE
105944: void
105944: SourceCompressorThread::compressorThread(void *arg)
105944: {
105944:     PR_SetCurrentThreadName("JS Source Compressing Thread");
105944:     static_cast<SourceCompressorThread *>(arg)->threadLoop();
105944: }
105944: 
105944: bool
105944: SourceCompressorThread::init()
105944: {
105944:     JS_ASSERT(!thread);
105944:     lock = PR_NewLock();
105944:     if (!lock)
105944:         return false;
105944:     wakeup = PR_NewCondVar(lock);
105944:     if (!wakeup)
105944:         return false;
105944:     done = PR_NewCondVar(lock);
105944:     if (!done)
105944:         return false;
105944:     thread = PR_CreateThread(PR_USER_THREAD, compressorThread, this, PR_PRIORITY_NORMAL,
106230:                              PR_GLOBAL_THREAD, PR_JOINABLE_THREAD, 0);
105944:     if (!thread)
105944:         return false;
105944:     return true;
105944: }
105944: 
105944: void
105944: SourceCompressorThread::finish()
105944: {
105944:     if (thread) {
105944:         PR_Lock(lock);
105944:         // We should only be compressing things when in the compiler.
105944:         JS_ASSERT(state == IDLE);
105944:         PR_NotifyCondVar(wakeup);
105944:         state = SHUTDOWN;
105944:         PR_Unlock(lock);
105944:         PR_JoinThread(thread);
105944:     }
105944:     if (wakeup)
105944:         PR_DestroyCondVar(wakeup);
105944:     if (done)
105944:         PR_DestroyCondVar(done);
105944:     if (lock)
105944:         PR_DestroyLock(lock);
105944: }
105944: 
105944: void
105944: SourceCompressorThread::threadLoop()
105944: {
105944:     PR_Lock(lock);
105944:     while (true) {
105944:         switch (state) {
105944:           case SHUTDOWN:
105944:             PR_Unlock(lock);
105944:             return;
105944:           case IDLE:
105944:             PR_WaitCondVar(wakeup, PR_INTERVAL_NO_TIMEOUT);
105944:             break;
106917:           case COMPRESSING: {
105944:             JS_ASSERT(tok);
106917:             ScriptSource *ss = tok->ss;
106917:             JS_ASSERT(!ss->ready());
106917:             const size_t COMPRESS_THRESHOLD = 512;
106917:             size_t compressedLength = 0;
106917: #ifdef USE_ZLIB
106917:             size_t nbytes = sizeof(jschar) * ss->length();
106917:             if (nbytes >= COMPRESS_THRESHOLD) {
106917:                 Compressor comp(reinterpret_cast<const unsigned char *>(tok->chars),
106917:                                 nbytes, ss->data.compressed);
106917:                 if (comp.init()) {
106917:                     while (!stop && comp.compressMore())
106917:                         ;
106917:                     compressedLength = comp.finish();
106917:                     if (stop || compressedLength == nbytes)
106917:                         compressedLength = 0;
106917:                 }
106917:             }
106917: #endif
106917:             ss->compressedLength_ = compressedLength;
106917:             if (compressedLength == 0) {
106917:                 PodCopy(ss->data.source, tok->chars, ss->length());
106917:             } else {
106917:                 // Shrink the buffer to the size of the compressed data. The
106917:                 // memory allocation functions on JSContext and JSRuntime are
106917:                 // not threadsafe, so use js_realloc directly. We'll fix up the
106917:                 // memory accounting of the runtime in waitOnCompression().
106917:                 void *newmem = js_realloc(ss->data.compressed, compressedLength);
106917:                 JS_ASSERT(newmem); // Reducing memory size shouldn't fail.
106917:                 ss->data.compressed = static_cast<unsigned char *>(newmem);
106917:             }
106917: 
105944:             // We hold the lock, so no one should have changed this.
105944:             JS_ASSERT(state == COMPRESSING);
105944:             state = IDLE;
105944:             PR_NotifyCondVar(done);
105944:             break;
105944:           }
105944:         }
105944:     }
106917: }
105944: 
105944: void
105944: SourceCompressorThread::compress(SourceCompressionToken *sct)
105944: {
105944:     if (tok)
105944:         // We have reentered the compiler. (This can happen through the
105944:         // debugger.) Complete the current compression before starting the next
105944:         // one.
105944:         waitOnCompression(tok);
105944:     JS_ASSERT(state == IDLE);
105944:     JS_ASSERT(!tok);
106917:     stop = false;
105944:     PR_Lock(lock);
105944:     tok = sct;
105944:     state = COMPRESSING;
105944:     PR_NotifyCondVar(wakeup);
105944:     PR_Unlock(lock);
105944: }
105944: 
105944: void
105944: SourceCompressorThread::waitOnCompression(SourceCompressionToken *userTok)
105944: {
105944:     JS_ASSERT(userTok == tok);
105944:     PR_Lock(lock);
110074:     while (state == COMPRESSING)
105944:         PR_WaitCondVar(done, PR_INTERVAL_NO_TIMEOUT);
105944:     JS_ASSERT(state == IDLE);
106917:     SourceCompressionToken *saveTok = tok;
105944:     tok = NULL;
105944:     PR_Unlock(lock);
106917: 
106917:     JS_ASSERT(!saveTok->ss->ready());
106917: #ifdef DEBUG
106917:     saveTok->ss->ready_ = true;
106917: #endif
106917: 
106917:     // Update memory accounting if needed.
106917:     if (saveTok->ss->compressed()) {
106917:         ptrdiff_t delta = saveTok->ss->compressedLength_ - sizeof(jschar) * saveTok->ss->length();
106917:         JS_ASSERT(delta < 0);
106917:         saveTok->cx->runtime->updateMallocCounter(NULL, delta);
106917:     }
106917: 
106917:     saveTok->ss = NULL;
106917:     saveTok->chars = NULL;
106917: }
106917: 
106917: void
106917: SourceCompressorThread::abort(SourceCompressionToken *userTok)
106917: {
106917:     JS_ASSERT(userTok == tok);
106917:     stop = true;
105944: }
105944: #endif /* JS_THREADSAFE */
105944: 
106824: void
106824: JSScript::setScriptSource(JSContext *cx, ScriptSource *ss)
106824: {
107053:     JS_ASSERT(ss);
107564:     ss->incref();
106824:     scriptSource_ = ss;
106824: }
106824: 
105947: bool
105947: JSScript::loadSource(JSContext *cx, bool *worked)
105947: {
107053:     JS_ASSERT(!scriptSource_->hasSourceData());
105947:     *worked = false;
107687:     if (!cx->runtime->sourceHook || !scriptSource_->sourceRetrievable())
105947:         return true;
106069:     jschar *src = NULL;
105947:     uint32_t length;
105947:     if (!cx->runtime->sourceHook(cx, this, &src, &length))
105947:         return false;
105947:     if (!src)
105947:         return true;
107053:     ScriptSource *ss = scriptSource();
107107:     ss->setSource(src, length);
105947:     *worked = true;
105947:     return true;
105947: }
105947: 
105944: JSFixedString *
105944: JSScript::sourceData(JSContext *cx)
105944: {
107053:     JS_ASSERT(scriptSource_->hasSourceData());
106824:     return scriptSource_->substring(cx, sourceStart, sourceEnd);
105944: }
105944: 
105944: JSFixedString *
105944: SourceDataCache::lookup(ScriptSource *ss)
105944: {
105944:     if (!map_)
105944:         return NULL;
105944:     if (Map::Ptr p = map_->lookup(ss))
105944:         return p->value;
105944:     return NULL;
105944: }
105944: 
105944: void
105944: SourceDataCache::put(ScriptSource *ss, JSFixedString *str)
105944: {
105944:     if (!map_) {
105944:         map_ = OffTheBooks::new_<Map>();
105944:         if (!map_)
105944:             return;
105944:         if (!map_->init()) {
105944:             purge();
105944:             return;
105944:         }
105944:     }
105944: 
105944:     (void) map_->put(ss, str);
105944: }
105944: 
105944: void
105944: SourceDataCache::purge()
105944: {
105944:     Foreground::delete_(map_);
105944:     map_ = NULL;
105944: }
105944: 
105944: JSFixedString *
105944: ScriptSource::substring(JSContext *cx, uint32_t start, uint32_t stop)
105944: {
105944:     JS_ASSERT(ready());
105944:     const jschar *chars;
106740: #if USE_ZLIB
105944:     Rooted<JSFixedString *> cached(cx, NULL);
105944:     if (compressed()) {
105944:         cached = cx->runtime->sourceDataCache.lookup(this);
105944:         if (!cached) {
106897:             const size_t nbytes = sizeof(jschar) * (length_ + 1);
106897:             jschar *decompressed = static_cast<jschar *>(cx->malloc_(nbytes));
105944:             if (!decompressed)
105944:                 return NULL;
106897:             if (!DecompressString(data.compressed, compressedLength_,
106897:                                   reinterpret_cast<unsigned char *>(decompressed), nbytes)) {
105944:                 JS_ReportOutOfMemory(cx);
105944:                 cx->free_(decompressed);
105944:                 return NULL;
105944:             }
105944:             decompressed[length_] = 0;
105944:             cached = js_NewString(cx, decompressed, length_);
105944:             if (!cached) {
105944:                 cx->free_(decompressed);
105944:                 return NULL;
105944:             }
105944:             cx->runtime->sourceDataCache.put(this, cached);
105944:         }
105944:         chars = cached->getChars(cx);
105944:         JS_ASSERT(chars);
105944:     } else {
105944:         chars = data.source;
105944:     }
106740: #else
106740:     chars = data.source;
106740: #endif
105944:     return js_NewStringCopyN(cx, chars + start, stop - start);
105944: }
105944: 
107053: bool
107107: ScriptSource::setSourceCopy(JSContext *cx, const jschar *src, uint32_t length,
107107:                             bool argumentsNotIncluded, SourceCompressionToken *tok)
105944: {
107053:     JS_ASSERT(!hasSourceData());
106897:     const size_t nbytes = length * sizeof(jschar);
107053:     data.compressed = static_cast<unsigned char *>(cx->malloc_(nbytes));
107053:     if (!data.compressed)
107053:         return false;
107053:     length_ = length;
107053:     argumentsNotIncluded_ = argumentsNotIncluded;
105944: 
105944: #ifdef JS_THREADSAFE
107107:     if (tok) {
107053: #ifdef DEBUG
107053:         ready_ = false;  
107053: #endif
107053:         tok->ss = this;
105944:         tok->chars = src;
105944:         cx->runtime->sourceCompressorThread.compress(tok);
105944:     } else
105944: #endif
106917:     {
107053:         PodCopy(data.source, src, length_);
106917:     }
105944: 
107053:     return true;
105944: }
105944: 
105944: void
107107: ScriptSource::setSource(const jschar *src, uint32_t length)
107107: {
107107:     JS_ASSERT(!hasSourceData());
107107:     length_ = length;
107107:     JS_ASSERT(!argumentsNotIncluded_);
107107:     data.source = const_cast<jschar *>(src);
107107: }
107107: 
107107: void
105944: SourceCompressionToken::ensureReady()
105944: {
105944: #ifdef JS_THREADSAFE
106917:     cx->runtime->sourceCompressorThread.waitOnCompression(this);
106917: #endif
106917: }
106917: 
106917: void
106917: SourceCompressionToken::abort()
106917: {
110381:     JS_ASSERT(active());
106917: #ifdef JS_THREADSAFE
106917:     cx->runtime->sourceCompressorThread.abort(this);
105944: #endif
105944: }
105944: 
105944: void
105944: ScriptSource::destroy(JSRuntime *rt)
105944: {
105944:     JS_ASSERT(ready());
105944:     rt->free_(data.compressed);
108243:     rt->free_(sourceMap_);
105944: #ifdef DEBUG
105944:     ready_ = false;
105944: #endif
105944:     rt->free_(this);
105944: }
105944: 
105945: size_t
105945: ScriptSource::sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf)
105945: {
105945:     JS_ASSERT(ready());
107564: 
107564:     // data is a union, but both members are pointers to allocated memory or
107564:     // NULL, so just using compressed will work.
105945:     return mallocSizeOf(this) + mallocSizeOf(data.compressed);
105945: }
105945: 
105944: template<XDRMode mode>
105944: bool
107053: ScriptSource::performXDR(XDRState<mode> *xdr)
105944: {
107053:     uint8_t hasSource = hasSourceData();
107053:     if (!xdr->codeUint8(&hasSource))
105944:         return false;
106897: 
107687:     uint8_t retrievable = sourceRetrievable_;
107687:     if (!xdr->codeUint8(&retrievable))
107687:         return false;
107687:     sourceRetrievable_ = retrievable;
107687: 
107687:     if (hasSource && !sourceRetrievable_) {
107053:         // Only set members when we know decoding cannot fail. This prevents the
107053:         // script source from being partially initialized.
107053:         uint32_t length = length_;
107053:         if (!xdr->codeUint32(&length))
107053:             return false;
107053: 
107053:         uint32_t compressedLength = compressedLength_;
107053:         if (!xdr->codeUint32(&compressedLength))
107053:             return false;
107053: 
107053:         uint8_t argumentsNotIncluded = argumentsNotIncluded_;
105944:         if (!xdr->codeUint8(&argumentsNotIncluded))
105944:             return false;
106897: 
107053:         size_t byteLen = compressedLength ? compressedLength : (length * sizeof(jschar));
105944:         if (mode == XDR_DECODE) {
107053:             data.compressed = static_cast<unsigned char *>(xdr->cx()->malloc_(byteLen));
107053:             if (!data.compressed)
105944:                 return false;
105944:         }
107053:         if (!xdr->codeBytes(data.compressed, byteLen)) {
107053:             if (mode == XDR_DECODE) {
107053:                 xdr->cx()->free_(data.compressed);
107053:                 data.compressed = NULL;
107053:             }
105944:             return false;
107053:         }
107053:         length_ = length;
107053:         compressedLength_ = compressedLength;
107053:         argumentsNotIncluded_ = argumentsNotIncluded;
107053:     }
107053: 
108243:     uint8_t haveSourceMap = hasSourceMap();
108243:     if (!xdr->codeUint8(&haveSourceMap))
108243:         return false;
108243: 
108243:     if (haveSourceMap) {
108243:         uint32_t sourceMapLen = (mode == XDR_DECODE) ? 0 : js_strlen(sourceMap_);
108243:         if (!xdr->codeUint32(&sourceMapLen))
108243:             return false;
108243: 
108243:         if (mode == XDR_DECODE) {
108243:             size_t byteLen = (sourceMapLen + 1) * sizeof(jschar);
108243:             sourceMap_ = static_cast<jschar *>(xdr->cx()->malloc_(byteLen));
108243:             if (!sourceMap_)
108243:                 return false;
108243:         }
108243:         if (!xdr->codeChars(sourceMap_, sourceMapLen)) {
108243:             if (mode == XDR_DECODE) {
108243:                 xdr->cx()->free_(sourceMap_);
108243:                 sourceMap_ = NULL;
108243:             }
108243:             return false;
108243:         }
108243:         sourceMap_[sourceMapLen] = '\0';
108243:     }
108243: 
105944: #ifdef DEBUG
107053:     if (mode == XDR_DECODE)
107053:         ready_ = true;
105944: #endif
107053: 
105944:     return true;
105944: }
105944: 
108586: bool
108586: ScriptSource::setSourceMap(JSContext *cx, jschar *sourceMapURL, const char *filename)
108243: {
108586:     JS_ASSERT(sourceMapURL);
108586:     if (hasSourceMap()) {
108586:         if (!JS_ReportErrorFlagsAndNumber(cx, JSREPORT_WARNING, js_GetErrorMessage, NULL,
108586:                                           JSMSG_ALREADY_HAS_SOURCEMAP, filename)) {
108586:             cx->free_(sourceMapURL);
108586:             return false;
108586:         }
108586:     }
108586:     sourceMap_ = sourceMapURL;
108586:     return true;
108243: }
108243: 
108243: const jschar *
108243: ScriptSource::sourceMap()
108243: {
108243:     JS_ASSERT(hasSourceMap());
108243:     return sourceMap_;
108243: }
108243: 
     1: /*
     1:  * Shared script filename management.
     1:  */
     1: 
 94202: const char *
 94202: js::SaveScriptFilename(JSContext *cx, const char *filename)
 67927: {
 95295:     if (!filename)
 95295:         return NULL;
 95295: 
 97463:     JSRuntime *rt = cx->runtime;
     1: 
 97463:     ScriptFilenameTable::AddPtr p = rt->scriptFilenameTable.lookupForAdd(filename);
 73899:     if (!p) {
 73899:         size_t size = offsetof(ScriptFilenameEntry, filename) + strlen(filename) + 1;
 73899:         ScriptFilenameEntry *entry = (ScriptFilenameEntry *) cx->malloc_(size);
 73899:         if (!entry)
 73899:             return NULL;
 73899:         entry->marked = false;
 73899:         strcpy(entry->filename, filename);
     1: 
 97463:         if (!rt->scriptFilenameTable.add(p, entry)) {
 73899:             Foreground::free_(entry);
 67927:             JS_ReportOutOfMemory(cx);
     1:             return NULL;
 67927:         }
     1:     }
     1: 
 90843:     ScriptFilenameEntry *sfe = *p;
 90843: #ifdef JSGC_INCREMENTAL
 90843:     /*
 90843:      * During the IGC we need to ensure that filename is marked whenever it is
 90843:      * accessed even if the name was already in the table. At this point old
 90843:      * scripts or exceptions pointing to the filename may no longer be
 90843:      * reachable.
 90843:      */
106556:     if (rt->gcIncrementalState != NO_INCREMENTAL && rt->gcIsFull)
 90843:         sfe->marked = true;
 90843: #endif
 90843: 
 90843:     return sfe->filename;
     1: }
     1: 
     1: void
 97463: js::SweepScriptFilenames(JSRuntime *rt)
     1: {
 97463:     JS_ASSERT(rt->gcIsFull);
 97463:     ScriptFilenameTable &table = rt->scriptFilenameTable;
 73899:     for (ScriptFilenameTable::Enum e(table); !e.empty(); e.popFront()) {
 73899:         ScriptFilenameEntry *entry = e.front();
 73899:         if (entry->marked) {
 73899:             entry->marked = false;
 97463:         } else if (!rt->gcKeepAtoms) {
 73899:             Foreground::free_(entry);
 73899:             e.removeFront();
     1:         }
     1:     }
     1: }
     1: 
 93970: void
 97463: js::FreeScriptFilenames(JSRuntime *rt)
 93970: {
 97463:     ScriptFilenameTable &table = rt->scriptFilenameTable;
 93970:     for (ScriptFilenameTable::Enum e(table); !e.empty(); e.popFront())
 93970:         Foreground::free_(e.front());
 93970: 
 93970:     table.clear();
 93970: }
 93970: 
  3235: /*
 94572:  * JSScript::data has a complex, manually-controlled, memory layout.
  3235:  *
 94572:  * First are some optional array headers.  They are optional because they
 94572:  * often aren't needed, i.e. the corresponding arrays often have zero elements.
 97839:  * Each header has a bit in JSScript::hasArrayBits that indicates if it's
 97839:  * present within |data|;  from this the offset of each present array header
 97839:  * can be computed.  Each header has an accessor function in JSScript that
 97839:  * encapsulates this offset computation.
  3235:  *
 97839:  * Array type       Array elements  Accessor
 97839:  * ----------       --------------  --------
 97839:  * ConstArray       Consts          consts()
 97839:  * ObjectArray      Objects         objects()
 97839:  * ObjectArray      Regexps         regexps()
 97839:  * TryNoteArray     Try notes       trynotes()
  3235:  *
 94572:  * Then are the elements of several arrays.
 94572:  * - Most of these arrays have headers listed above (if present).  For each of
 94572:  *   these, the array pointer and the array length is stored in the header.
 94572:  * - The remaining arrays have pointers and lengths that are stored directly in
 94572:  *   JSScript.  This is because, unlike the others, they are nearly always
 94572:  *   non-zero length and so the optional-header space optimization isn't
 94572:  *   worthwhile.
 94572:  *
 94572:  * Array elements   Pointed to by         Length
 94572:  * --------------   -------------         ------
 94572:  * Consts           consts()->vector      consts()->length
 94572:  * Atoms            atoms                 natoms
 94572:  * Objects          objects()->vector     objects()->length
 94572:  * Regexps          regexps()->vector     regexps()->length
 94572:  * Try notes        trynotes()->vector    trynotes()->length
 94572:  * Bytecodes        code                  length
 94572:  * Source notes     notes()               numNotes() * sizeof(jssrcnote)
 94572:  *
 94572:  * IMPORTANT: This layout has two key properties.
 94572:  * - It ensures that everything has sufficient alignment;  in particular, the
 94572:  *   consts() elements need jsval alignment.
 94572:  * - It ensures there are no gaps between elements, which saves space and makes
 94572:  *   manual layout easy.  In particular, in the second part, arrays with larger
 94572:  *   elements precede arrays with smaller elements.
 94572:  *
 94572:  * The following static assertions check these properties.
  3235:  */
 94572: 
 94572: #define KEEPS_JSVAL_ALIGNMENT(T) \
 94572:     (JS_ALIGNMENT_OF(jsval) % JS_ALIGNMENT_OF(T) == 0 && \
 94572:      sizeof(T) % sizeof(jsval) == 0)
 94572: 
 94572: #define HAS_JSVAL_ALIGNMENT(T) \
 94572:     (JS_ALIGNMENT_OF(jsval) == JS_ALIGNMENT_OF(T) && \
 94572:      sizeof(T) == sizeof(jsval))
 94572: 
 94572: #define NO_PADDING_BETWEEN_ENTRIES(T1, T2) \
 94572:     (JS_ALIGNMENT_OF(T1) % JS_ALIGNMENT_OF(T2) == 0)
 94572: 
 94572: /*
 94572:  * These assertions ensure that there is no padding between the array headers,
 94572:  * and also that the consts() elements (which follow immediately afterward) are
 94572:  * jsval-aligned.  (There is an assumption that |data| itself is jsval-aligned;
 94572:  * we check this below).
 94572:  */
 97362: JS_STATIC_ASSERT(KEEPS_JSVAL_ALIGNMENT(ConstArray));
 97362: JS_STATIC_ASSERT(KEEPS_JSVAL_ALIGNMENT(ObjectArray));       /* there are two of these */
 97362: JS_STATIC_ASSERT(KEEPS_JSVAL_ALIGNMENT(TryNoteArray));
 94572: 
 94572: /* These assertions ensure there is no padding required between array elements. */
 94572: JS_STATIC_ASSERT(HAS_JSVAL_ALIGNMENT(HeapValue));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(HeapValue, JSAtom *));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(JSAtom *, HeapPtrObject));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(HeapPtrObject, HeapPtrObject));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(HeapPtrObject, JSTryNote));
 98173: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(JSTryNote, uint32_t));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(uint32_t, uint32_t));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(uint32_t, jsbytecode));
 94572: JS_STATIC_ASSERT(NO_PADDING_BETWEEN_ENTRIES(jsbytecode, jssrcnote));
  3235: 
 97298: static inline size_t
108509: ScriptDataSize(uint32_t length, uint32_t nsrcnotes, uint32_t nbindings, uint32_t natoms,
108509:                uint32_t nobjects, uint32_t nregexps, uint32_t ntrynotes, uint32_t nconsts)
     1: {
 94572:     size_t size = 0;
 94572: 
 94572:     if (nconsts != 0)
 97362:         size += sizeof(ConstArray) + nconsts * sizeof(Value);
 94572:     size += sizeof(JSAtom *) * natoms;
  3235:     if (nobjects != 0)
 97362:         size += sizeof(ObjectArray) + nobjects * sizeof(JSObject *);
  3235:     if (nregexps != 0)
 97362:         size += sizeof(ObjectArray) + nregexps * sizeof(JSObject *);
  3235:     if (ntrynotes != 0)
 97362:         size += sizeof(TryNoteArray) + ntrynotes * sizeof(JSTryNote);
  3235: 
108509:     size += nbindings * sizeof(Binding);
 94572:     size += length * sizeof(jsbytecode);
 94572:     size += nsrcnotes * sizeof(jssrcnote);
 97298:     return size;
 97298: }
 77659: 
102045: JSScript *
104378: JSScript::Create(JSContext *cx, HandleObject enclosingScope, bool savedCallerFun,
106508:                  const CompileOptions &options, unsigned staticLevel,
105944:                  ScriptSource *ss, uint32_t bufStart, uint32_t bufEnd)
102045: {
102045:     JSScript *script = js_NewGCScript(cx);
102045:     if (!script)
102045:         return NULL;
102045: 
102045:     PodZero(script);
108504:     new (&script->bindings) Bindings;
102046: 
104378:     script->enclosingScope_ = enclosingScope;
102050:     script->savedCallerFun = savedCallerFun;
102050: 
102048:     /* Establish invariant: principals implies originPrincipals. */
106508:     if (options.principals) {
106508:         script->principals = options.principals;
106508:         script->originPrincipals
106508:             = options.originPrincipals ? options.originPrincipals : options.principals;
102048:         JS_HoldPrincipals(script->principals);
102048:         JS_HoldPrincipals(script->originPrincipals);
106508:     } else if (options.originPrincipals) {
106508:         script->originPrincipals = options.originPrincipals;
102048:         JS_HoldPrincipals(script->originPrincipals);
102048:     }
102048: 
106508:     script->compileAndGo = options.compileAndGo;
106508:     script->noScriptRval = options.noScriptRval;
102046:  
106508:     script->version = options.version;
106508:     JS_ASSERT(script->getVersion() == options.version);     // assert that no overflow occurred
102047: 
102051:     // This is an unsigned-to-uint16_t conversion, test for too-high values.
102051:     // In practice, recursion in Parser and/or BytecodeEmitter will blow the
102051:     // stack if we nest functions more than a few hundred deep, so this will
102051:     // never trigger.  Oh well.
102051:     if (staticLevel > UINT16_MAX) {
102051:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_TOO_DEEP, js_function_str);
102385:         return NULL;
102051:     }
102051:     script->staticLevel = uint16_t(staticLevel);
102051: 
106824:     script->setScriptSource(cx, ss);
105944:     script->sourceStart = bufStart;
105944:     script->sourceEnd = bufEnd;
105944: 
102045:     return script;
102045: }
102045: 
 97298: static inline uint8_t *
 97298: AllocScriptData(JSContext *cx, size_t size)
 97298: {
 93833:     uint8_t *data = static_cast<uint8_t *>(cx->calloc_(JS_ROUNDUP(size, sizeof(Value))));
 77659:     if (!data)
 77659:         return NULL;
 48470: 
 97298:     JS_ASSERT(size_t(data) % sizeof(Value) == 0);
 97298:     return data;
 97298: }
 97298: 
104205: /* static */ bool
104205: JSScript::partiallyInit(JSContext *cx, Handle<JSScript*> script,
104205:                         uint32_t length, uint32_t nsrcnotes, uint32_t natoms,
 98173:                         uint32_t nobjects, uint32_t nregexps, uint32_t ntrynotes, uint32_t nconsts,
108509:                         uint32_t nTypeSets)
 97298: {
108509:     size_t size = ScriptDataSize(length, nsrcnotes, script->bindings.count(), natoms, nobjects,
108509:                                  nregexps, ntrynotes, nconsts);
102045:     script->data = AllocScriptData(cx, size);
102045:     if (!script->data)
102045:         return false;
 97298: 
102045:     script->length = length;
 97298: 
108509:     JS_ASSERT(nTypeSets <= UINT16_MAX);
108509:     script->nTypeSets = uint16_t(nTypeSets);
108509: 
104205:     uint8_t *cursor = script->data;
 94572:     if (nconsts != 0) {
 97839:         script->setHasArray(CONSTS);
 97362:         cursor += sizeof(ConstArray);
 94572:     }
  3235:     if (nobjects != 0) {
 97839:         script->setHasArray(OBJECTS);
 97362:         cursor += sizeof(ObjectArray);
  3235:     }
  3235:     if (nregexps != 0) {
 97839:         script->setHasArray(REGEXPS);
 97362:         cursor += sizeof(ObjectArray);
  3235:     }
  3235:     if (ntrynotes != 0) {
 97839:         script->setHasArray(TRYNOTES);
 97362:         cursor += sizeof(TryNoteArray);
  3235:     }
  3235: 
 77659:     if (nconsts != 0) {
 86976:         JS_ASSERT(reinterpret_cast<uintptr_t>(cursor) % sizeof(jsval) == 0);
 77659:         script->consts()->length = nconsts;
 82129:         script->consts()->vector = (HeapValue *)cursor;
 77659:         cursor += nconsts * sizeof(script->consts()->vector[0]);
 77659:     }
 77659: 
  3235:     if (natoms != 0) {
 77659:         script->natoms = natoms;
 94934:         script->atoms = reinterpret_cast<HeapPtrAtom *>(cursor);
 77659:         cursor += natoms * sizeof(script->atoms[0]);
  3235:     }
 17218: 
  3235:     if (nobjects != 0) {
 32723:         script->objects()->length = nobjects;
 82129:         script->objects()->vector = (HeapPtr<JSObject> *)cursor;
 77659:         cursor += nobjects * sizeof(script->objects()->vector[0]);
  3235:     }
 18308: 
  3235:     if (nregexps != 0) {
 32723:         script->regexps()->length = nregexps;
 82129:         script->regexps()->vector = (HeapPtr<JSObject> *)cursor;
 77659:         cursor += nregexps * sizeof(script->regexps()->vector[0]);
  3235:     }
 18308: 
  3235:     if (ntrynotes != 0) {
 32723:         script->trynotes()->length = ntrynotes;
 77659:         script->trynotes()->vector = reinterpret_cast<JSTryNote *>(cursor);
 77659:         size_t vectorSize = ntrynotes * sizeof(script->trynotes()->vector[0]);
  3235: #ifdef DEBUG
  3235:         memset(cursor, 0, vectorSize);
  3235: #endif
  3235:         cursor += vectorSize;
  3235:     }
  3235: 
108580:     cursor = script->bindings.switchToScriptStorage(reinterpret_cast<Binding *>(cursor));
 77343: 
 77659:     script->code = (jsbytecode *)cursor;
104205:     JS_ASSERT(cursor + length * sizeof(jsbytecode) + nsrcnotes * sizeof(jssrcnote) == script->data + size);
 53391: 
102045:     return true;
     1: }
     1: 
104205: /* static */ bool
104205: JSScript::fullyInitTrivial(JSContext *cx, Handle<JSScript*> script)
     1: {
108509:     if (!partiallyInit(cx, script, /* length = */ 1, /* nsrcnotes = */ 1, 0, 0, 0, 0, 0, 0))
102045:         return false;
102045: 
102045:     script->code[0] = JSOP_STOP;
102045:     script->notes()[0] = SRC_NULL;
102045: 
102045:     return true;
102045: }
102045: 
104205: /* static */ bool
104205: JSScript::fullyInitFromEmitter(JSContext *cx, Handle<JSScript*> script, BytecodeEmitter *bce)
102045: {
  3235:     /* The counts of indexed things must be checked during code generation. */
 80964:     JS_ASSERT(bce->atomIndices->count() <= INDEX_LIMIT);
 80964:     JS_ASSERT(bce->objectList.length <= INDEX_LIMIT);
 80964:     JS_ASSERT(bce->regexpList.length <= INDEX_LIMIT);
  3235: 
102045:     uint32_t mainLength = bce->offset();
102045:     uint32_t prologLength = bce->prologOffset();
 84755:     uint32_t nsrcnotes = uint32_t(bce->countFinalSourceNotes());
104205:     if (!partiallyInit(cx, script, prologLength + mainLength, nsrcnotes, bce->atomIndices->count(),
102045:                        bce->objectList.length, bce->regexpList.length, bce->ntrynotes,
108509:                        bce->constList.length(), bce->typesetCount))
102045:         return false;
     1: 
 77659:     JS_ASSERT(script->mainOffset == 0);
 77659:     script->mainOffset = prologLength;
 87623:     PodCopy<jsbytecode>(script->code, bce->prologBase(), prologLength);
 87623:     PodCopy<jsbytecode>(script->main(), bce->base(), mainLength);
108509:     uint32_t nfixed = bce->sc->inFunction() ? script->bindings.numVars() : 0;
 16072:     JS_ASSERT(nfixed < SLOTNO_LIMIT);
 84755:     script->nfixed = uint16_t(nfixed);
 94934:     InitAtomMap(cx, bce->atomIndices.getMap(), script->atoms);
     1: 
102045:     const char *filename = bce->parser->tokenStream.getFilename();
     1:     if (filename) {
 67927:         script->filename = SaveScriptFilename(cx, filename);
     1:         if (!script->filename)
102045:             return false;
     1:     }
 80964:     script->lineno = bce->firstLine;
 80964:     if (script->nfixed + bce->maxStackDepth >= JS_BIT(16)) {
102849:         bce->reportError(NULL, JSMSG_NEED_DIET, "script");
102045:         return false;
 18308:     }
 80964:     script->nslots = script->nfixed + bce->maxStackDepth;
101616: 
 80964:     if (!FinishTakingSrcNotes(cx, bce, script->notes()))
102045:         return false;
 80964:     if (bce->ntrynotes != 0)
 80964:         FinishTakingTryNotes(bce, script->trynotes());
 80964:     if (bce->objectList.length != 0)
 80964:         bce->objectList.finish(script->objects());
 80964:     if (bce->regexpList.length != 0)
 80964:         bce->regexpList.finish(script->regexps());
 80964:     if (bce->constList.length() != 0)
 80964:         bce->constList.finish(script->consts());
 98687:     script->strictModeCode = bce->sc->inStrictMode();
105944:     script->explicitUseStrict = bce->sc->hasExplicitUseStrict();
 98687:     script->bindingsAccessedDynamically = bce->sc->bindingsAccessedDynamically();
101616:     script->funHasExtensibleScope = bce->sc->funHasExtensibleScope();
 98479:     script->hasSingletons = bce->hasSingletons;
 98921: #ifdef JS_METHODJIT
 98921:     if (cx->compartment->debugMode())
 98921:         script->debugMode = true;
 98921: #endif
     1: 
100230:     if (bce->sc->inFunction()) {
 98687:         if (bce->sc->funArgumentsHasLocalBinding()) {
101075:             // This must precede the script->bindings.transfer() call below
103284:             script->setArgumentsHasVarBinding();
 98687:             if (bce->sc->funDefinitelyNeedsArgsObj())
 93250:                 script->setNeedsArgsObj(true);
 98687:         } else {
 98687:             JS_ASSERT(!bce->sc->funDefinitelyNeedsArgsObj());
 98687:         }
100006:     }
 93250: 
103320:     RootedFunction fun(cx, NULL);
100230:     if (bce->sc->inFunction()) {
102046:         JS_ASSERT(!bce->script->noScriptRval);
 98687:         script->isGenerator = bce->sc->funIsGenerator();
106311:         script->isGeneratorExp = bce->sc->funbox() && bce->sc->funbox()->inGenexpLambda;
103777:         script->setFunction(bce->sc->fun());
     1:     }
     1: 
 97298:     /*
 97298:      * initScriptCounts updates scriptCountsMap if necessary. The other script
 97298:      * maps in JSCompartment are populated lazily.
 97298:      */
 82134:     if (cx->hasRunOption(JSOPTION_PCCOUNT))
 94574:         (void) script->initScriptCounts(cx);
 82134: 
108509:     for (unsigned i = 0, n = script->bindings.numArgs(); i < n; ++i) {
108509:         if (script->formalIsAliased(i)) {
108509:             script->funHasAnyAliasedFormal = true;
108509:             break;
108509:         }
108509:     }
108509: 
102045:     return true;
     1: }
     1: 
 72071: size_t
 88145: JSScript::computedSizeOfData()
 72071: {
 84755:     uint8_t *dataEnd = code + length * sizeof(jsbytecode) + numNotes() * sizeof(jssrcnote);
 77659:     JS_ASSERT(dataEnd >= data);
 77659:     return dataEnd - data;
 72071: }
 72071: 
 78016: size_t
 88145: JSScript::sizeOfData(JSMallocSizeOfFun mallocSizeOf)
 78016: {
 88300:     return mallocSizeOf(data);
 78016: }
 78016: 
 72071: /*
 72071:  * Nb: srcnotes are variable-length.  This function computes the number of
 72071:  * srcnote *slots*, which may be greater than the number of srcnotes.
 72071:  */
 84755: uint32_t
 72071: JSScript::numNotes()
 72071: {
 72071:     jssrcnote *sn;
 72071:     jssrcnote *notes_ = notes();
 72071:     for (sn = notes_; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn))
 72071:         continue;
 72071:     return sn - notes_ + 1;    /* +1 for the terminator */
 72071: }
 72071: 
106002: bool
106002: JSScript::enclosingScriptsCompiledSuccessfully() const
106002: {
106002:     /*
106002:      * When a nested script is succesfully compiled, it is eagerly given the
106002:      * static JSFunction of its enclosing script. The enclosing function's
106002:      * 'script' field will be NULL until the enclosing script successfully
106002:      * compiles. Thus, we can detect failed compilation by looking for
106002:      * JSFunctions in the enclosingScope chain without scripts.
106002:      */
106002:     JSObject *enclosing = enclosingScope_;
106002:     while (enclosing) {
106002:         if (enclosing->isFunction()) {
106002:             JSFunction *fun = enclosing->toFunction();
106002:             if (!fun->script())
106002:                 return false;
106002:             enclosing = fun->script()->enclosingScope_;
106002:         } else {
106002:             enclosing = enclosing->asStaticBlock().enclosingStaticScope();
106002:         }
106002:     }
106002:     return true;
106002: }
106002: 
     1: JS_FRIEND_API(void)
     1: js_CallNewScriptHook(JSContext *cx, JSScript *script, JSFunction *fun)
     1: {
 98566:     JS_ASSERT(!script->isActiveEval);
 91178:     if (JSNewScriptHook hook = cx->runtime->debugHooks.newScriptHook) {
 40840:         AutoKeepAtoms keep(cx->runtime);
     1:         hook(cx, script->filename, script->lineno, script, fun,
 91178:              cx->runtime->debugHooks.newScriptHookData);
     1:     }
     1: }
     1: 
 62571: void
 94740: js::CallDestroyScriptHook(FreeOp *fop, JSScript *script)
     1: {
 94740:     if (JSDestroyScriptHook hook = fop->runtime()->debugHooks.destroyScriptHook)
 94740:         hook(fop, script, fop->runtime()->debugHooks.destroyScriptHookData);
 94740:     script->clearTraps(fop);
     1: }
     1: 
 77659: void
 94738: JSScript::finalize(FreeOp *fop)
     1: {
102045:     // NOTE: this JSScript may be partially initialized at this point.  E.g. we
102045:     // may have created it and partially initialized it with
102045:     // JSScript::Create(), but not yet finished initializing it with
102045:     // fullyInitFromEmitter() or fullyInitTrivial().
102045: 
 94740:     CallDestroyScriptHook(fop, this);
103915:     fop->runtime()->spsProfiler.onScriptFinalized(this);
 11377: 
 84691:     JS_ASSERT_IF(principals, originPrincipals);
 77659:     if (principals)
 94738:         JS_DropPrincipals(fop->runtime(), principals);
 84691:     if (originPrincipals)
 94738:         JS_DropPrincipals(fop->runtime(), originPrincipals);
 76766: 
 77659:     if (types)
 77659:         types->destroy();
 76766: 
 77659: #ifdef JS_METHODJIT
 94740:     mjit::ReleaseScriptCode(fop, this);
 24879: #endif
 11377: 
 94740:     destroyScriptCounts(fop);
 95151:     destroyDebugScript(fop);
107564:     scriptSource_->decref(fop->runtime());
 84195: 
102045:     if (data) {
 88145:         JS_POISON(data, 0xdb, computedSizeOfData());
 94738:         fop->free_(data);
 76766:     }
102045: }
     1: 
 67915: namespace js {
     1: 
 84755: static const uint32_t GSN_CACHE_THRESHOLD = 100;
 84755: static const uint32_t GSN_CACHE_MAP_INIT_SIZE = 20;
 67915: 
 26569: void
 67915: GSNCache::purge()
 26569: {
 67915:     code = NULL;
 67915:     if (map.initialized())
 67915:         map.finish();
 26569: }
 67915: 
 67915: } /* namespace js */
 26569: 
     1: jssrcnote *
     1: js_GetSrcNoteCached(JSContext *cx, JSScript *script, jsbytecode *pc)
     1: {
 67915:     size_t target = pc - script->code;
 67915:     if (target >= size_t(script->length))
     1:         return NULL;
     1: 
 67915:     GSNCache *cache = GetGSNCache(cx);
 67915:     if (cache->code == script->code) {
 67915:         JS_ASSERT(cache->map.initialized());
 67915:         GSNCache::Map::Ptr p = cache->map.lookup(pc);
 67915:         return p ? p->value : NULL;
     1:     }
     1: 
 67915:     size_t offset = 0;
 67915:     jssrcnote *result;
 67915:     for (jssrcnote *sn = script->notes(); ; sn = SN_NEXT(sn)) {
     1:         if (SN_IS_TERMINATOR(sn)) {
     1:             result = NULL;
     1:             break;
     1:         }
     1:         offset += SN_DELTA(sn);
     1:         if (offset == target && SN_IS_GETTABLE(sn)) {
     1:             result = sn;
     1:             break;
     1:         }
     1:     }
     1: 
 67915:     if (cache->code != script->code && script->length >= GSN_CACHE_THRESHOLD) {
 91237:         unsigned nsrcnotes = 0;
 67915:         for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn);
     1:              sn = SN_NEXT(sn)) {
     1:             if (SN_IS_GETTABLE(sn))
     1:                 ++nsrcnotes;
     1:         }
 67915:         if (cache->code) {
 67915:             JS_ASSERT(cache->map.initialized());
 67915:             cache->map.finish();
 67915:             cache->code = NULL;
 67915:         }
 67915:         if (cache->map.init(nsrcnotes)) {
     1:             pc = script->code;
 67915:             for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn);
     1:                  sn = SN_NEXT(sn)) {
     1:                 pc += SN_DELTA(sn);
 67915:                 if (SN_IS_GETTABLE(sn))
 67915:                     JS_ALWAYS_TRUE(cache->map.put(pc, sn));
     1:             }
 67915:             cache->code = script->code;
     1:         }
     1:     }
     1: 
     1:     return result;
     1: }
     1: 
 91237: unsigned
109046: js::PCToLineNumber(unsigned startLine, jssrcnote *notes, jsbytecode *code, jsbytecode *pc,
109046:                    unsigned *columnp)
     1: {
 91316:     unsigned lineno = startLine;
109046:     unsigned column = 0;
     1: 
     1:     /*
 91316:      * Walk through source notes accumulating their deltas, keeping track of
 91316:      * line-number notes, until we pass the note for pc's offset within
 91316:      * script->code.
     1:      */
 80631:     ptrdiff_t offset = 0;
 91316:     ptrdiff_t target = pc - code;
 91316:     for (jssrcnote *sn = notes; !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
     1:         offset += SN_DELTA(sn);
 80631:         SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
     1:         if (type == SRC_SETLINE) {
     1:             if (offset <= target)
 91237:                 lineno = (unsigned) js_GetSrcNoteOffset(sn, 0);
109046:             column = 0;
     1:         } else if (type == SRC_NEWLINE) {
     1:             if (offset <= target)
     1:                 lineno++;
109046:             column = 0;
     1:         }
109046: 
     1:         if (offset > target)
     1:             break;
109046: 
109046:         if (type == SRC_COLSPAN) {
109046:             ptrdiff_t colspan = js_GetSrcNoteOffset(sn, 0);
109046: 
109046:             if (colspan >= SN_COLSPAN_DOMAIN / 2)
109046:                 colspan -= SN_COLSPAN_DOMAIN;
109046:             JS_ASSERT(ptrdiff_t(column) + colspan >= 0);
109046:             column += colspan;
     1:         }
109046:     }
109046: 
109046:     if (columnp)
109046:         *columnp = column;
 91316: 
     1:     return lineno;
     1: }
     1: 
 91316: unsigned
109046: js::PCToLineNumber(JSScript *script, jsbytecode *pc, unsigned *columnp)
 91316: {
 91316:     /* Cope with StackFrame.pc value prior to entering js_Interpret. */
 91316:     if (!pc)
 91316:         return 0;
 91316: 
109046:     return PCToLineNumber(script->lineno, script->notes(), script->code, pc,
109046:                           columnp);
 91316: }
 91316: 
     1: /* The line number limit is the same as the jssrcnote offset limit. */
     1: #define SN_LINE_LIMIT   (SN_3BYTE_OFFSET_FLAG << 16)
     1: 
     1: jsbytecode *
 91237: js_LineNumberToPC(JSScript *script, unsigned target)
     1: {
 80631:     ptrdiff_t offset = 0;
 80631:     ptrdiff_t best = -1;
 91237:     unsigned lineno = script->lineno;
 91237:     unsigned bestdiff = SN_LINE_LIMIT;
 80631:     for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
   267:         /*
   267:          * Exact-match only if offset is not in the prolog; otherwise use
   267:          * nearest greater-or-equal line number match.
   267:          */
 77659:         if (lineno == target && offset >= ptrdiff_t(script->mainOffset))
     1:             goto out;
   267:         if (lineno >= target) {
 91237:             unsigned diff = lineno - target;
     1:             if (diff < bestdiff) {
     1:                 bestdiff = diff;
     1:                 best = offset;
     1:             }
     1:         }
     1:         offset += SN_DELTA(sn);
 80631:         SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
     1:         if (type == SRC_SETLINE) {
 91237:             lineno = (unsigned) js_GetSrcNoteOffset(sn, 0);
     1:         } else if (type == SRC_NEWLINE) {
     1:             lineno++;
     1:         }
     1:     }
     1:     if (best >= 0)
     1:         offset = best;
     1: out:
     1:     return script->code + offset;
     1: }
     1: 
 91237: JS_FRIEND_API(unsigned)
     1: js_GetScriptLineExtent(JSScript *script)
     1: {
 91237:     unsigned lineno = script->lineno;
 91237:     unsigned maxLineNo = 0;
 80631:     bool counting = true;
 80631:     for (jssrcnote *sn = script->notes(); !SN_IS_TERMINATOR(sn); sn = SN_NEXT(sn)) {
 80631:         SrcNoteType type = (SrcNoteType) SN_TYPE(sn);
     1:         if (type == SRC_SETLINE) {
 73768:             if (maxLineNo < lineno)
 73768:                 maxLineNo = lineno;
 91237:             lineno = (unsigned) js_GetSrcNoteOffset(sn, 0);
 73768:             counting = true;
 73768:             if (maxLineNo < lineno)
 73768:                 maxLineNo = lineno;
 73768:             else
 73768:                 counting = false;
     1:         } else if (type == SRC_NEWLINE) {
 73768:             if (counting)
     1:                 lineno++;
     1:         }
     1:     }
 73768: 
 73768:     if (maxLineNo > lineno)
 73768:         lineno = maxLineNo;
 73768: 
     1:     return 1 + lineno - script->lineno;
     1: }
 53498: 
 71363: namespace js {
 71363: 
 91237: unsigned
 71363: CurrentLine(JSContext *cx)
 71363: {
 91316:     return PCToLineNumber(cx->fp()->script(), cx->regs().pc);
 71363: }
 71363: 
 84691: void
 91237: CurrentScriptFileLineOriginSlow(JSContext *cx, const char **file, unsigned *linenop,
 84691:                                 JSPrincipals **origin)
 68894: {
108585:     NonBuiltinScriptFrameIter iter(cx);
 71363: 
 71363:     if (iter.done()) {
 84691:         *file = NULL;
 68894:         *linenop = 0;
 84691:         *origin = NULL;
 84691:         return;
 68894:     }
 68894: 
 97161:     JSScript *script = iter.script();
 84691:     *file = script->filename;
 97161:     *linenop = PCToLineNumber(iter.script(), iter.pc());
 84691:     *origin = script->originPrincipals;
 68894: }
 68894: 
 94006: }  /* namespace js */
 64372: 
 97298: template <class T>
 97298: static inline T *
 97298: Rebase(JSScript *dst, JSScript *src, T *srcp)
 97298: {
 97298:     size_t off = reinterpret_cast<uint8_t *>(srcp) - src->data;
 97298:     return reinterpret_cast<T *>(dst->data + off);
 97298: }
 97298: 
 55633: JSScript *
104378: js::CloneScript(JSContext *cx, HandleObject enclosingScope, HandleFunction fun, HandleScript src)
 55633: {
 97298:     /* NB: Keep this in sync with XDRScript. */
 55633: 
 97839:     uint32_t nconsts   = src->hasConsts()   ? src->consts()->length   : 0;
 97839:     uint32_t nobjects  = src->hasObjects()  ? src->objects()->length  : 0;
 97839:     uint32_t nregexps  = src->hasRegexps()  ? src->regexps()->length  : 0;
 97839:     uint32_t ntrynotes = src->hasTrynotes() ? src->trynotes()->length : 0;
 55633: 
 97298:     /* Script data */
 97298: 
108509:     size_t size = ScriptDataSize(src->length, src->numNotes(), src->bindings.count(), src->natoms,
108509:                                  nobjects, nregexps, ntrynotes, nconsts);
 97298: 
 97298:     uint8_t *data = AllocScriptData(cx, size);
 97298:     if (!data)
 55633:         return NULL;
 55633: 
 97298:     /* Bindings */
 55633: 
102615:     Bindings bindings;
108509:     Bindings::AutoRooter bindingRooter(cx, &bindings);
108509:     if (!bindings.clone(cx, data, src))
 97545:         return NULL;
 97298: 
 97298:     /* Objects */
 97298: 
 97298:     AutoObjectVector objects(cx);
 97298:     if (nobjects != 0) {
 97298:         HeapPtrObject *vector = src->objects()->vector;
 97298:         for (unsigned i = 0; i < nobjects; i++) {
104378:             JSObject &obj = *vector[i];
104205:             JSObject *clone;
104378:             if (obj.isStaticBlock()) {
104378:                 Rooted<StaticBlockObject*> innerBlock(cx, &obj.asStaticBlock());
104378: 
104378:                 Rooted<JSObject*> enclosingScope(cx);
104378:                 if (StaticBlockObject *enclosingBlock = innerBlock->enclosingBlock())
104378:                     enclosingScope = objects[FindBlockIndex(src, *enclosingBlock)];
104378:                 else
104378:                     enclosingScope = fun;
104378: 
104378:                 clone = CloneStaticBlockObject(cx, enclosingScope, innerBlock);
104205:             } else {
104378:                 Rooted<JSFunction*> innerFun(cx, obj.toFunction());
104378: 
104378:                 StaticScopeIter ssi(innerFun->script()->enclosingStaticScope());
104378:                 Rooted<JSObject*> enclosingScope(cx);
104378:                 if (!ssi.done() && ssi.type() == StaticScopeIter::BLOCK)
104378:                     enclosingScope = objects[FindBlockIndex(src, ssi.block())];
104378:                 else
104378:                     enclosingScope = fun;
104378: 
104378:                 clone = CloneInterpretedFunction(cx, enclosingScope, innerFun);
104205:             }
 97298:             if (!clone || !objects.append(clone))
 97545:                 return NULL;
 97298:         }
 97298:     }
 97298: 
 97298:     /* RegExps */
 97298: 
 97298:     AutoObjectVector regexps(cx);
 97298:     for (unsigned i = 0; i < nregexps; i++) {
 97298:         HeapPtrObject *vector = src->regexps()->vector;
 97298:         for (unsigned i = 0; i < nregexps; i++) {
 97298:             JSObject *clone = CloneScriptRegExpObject(cx, vector[i]->asRegExp());
 97298:             if (!clone || !regexps.append(clone))
 97545:                 return NULL;
 97298:         }
 97298:     }
 97298: 
 97298:     /* Now that all fallible allocation is complete, create the GC thing. */
 97298: 
106508:     CompileOptions options(cx);
106508:     options.setPrincipals(cx->compartment->principals)
106508:            .setOriginPrincipals(src->originPrincipals)
106508:            .setCompileAndGo(src->compileAndGo)
106508:            .setNoScriptRval(src->noScriptRval)
106508:            .setVersion(src->getVersion());
104378:     JSScript *dst = JSScript::Create(cx, enclosingScope, src->savedCallerFun,
106508:                                      options, src->staticLevel,
106824:                                      src->scriptSource(), src->sourceStart, src->sourceEnd);
 97298:     if (!dst) {
 97298:         Foreground::free_(data);
 55633:         return NULL;
 97298:     }
 55633: 
108509:     dst->bindings = bindings;
 97298: 
 97298:     /* This assignment must occur before all the Rebase calls. */
 97298:     dst->data = data;
 97298:     memcpy(data, src->data, size);
 97298: 
 97298:     dst->code = Rebase<jsbytecode>(dst, src, src->code);
 97298: 
 97298:     /* Script filenames are runtime-wide. */
 97298:     dst->filename = src->filename;
 97298: 
 97298:     /* Atoms are runtime-wide. */
 97298:     if (src->natoms != 0)
 97298:         dst->atoms = Rebase<HeapPtrAtom>(dst, src, src->atoms);
 97298: 
 97298:     dst->length = src->length;
 97298:     dst->lineno = src->lineno;
 97298:     dst->mainOffset = src->mainOffset;
 97298:     dst->natoms = src->natoms;
 97298:     dst->nfixed = src->nfixed;
 97298:     dst->nTypeSets = src->nTypeSets;
 97298:     dst->nslots = src->nslots;
103284:     if (src->argumentsHasVarBinding()) {
103284:         dst->setArgumentsHasVarBinding();
 97298:         if (src->analyzedArgsUsage())
 97298:             dst->setNeedsArgsObj(src->needsArgsObj());
 97298:     }
 97839:     dst->cloneHasArray(src);
 97298:     dst->strictModeCode = src->strictModeCode;
105944:     dst->explicitUseStrict = src->explicitUseStrict;
 97298:     dst->bindingsAccessedDynamically = src->bindingsAccessedDynamically;
101616:     dst->funHasExtensibleScope = src->funHasExtensibleScope;
108509:     dst->funHasAnyAliasedFormal = src->funHasAnyAliasedFormal;
 97298:     dst->hasSingletons = src->hasSingletons;
 97298:     dst->isGenerator = src->isGenerator;
106311:     dst->isGeneratorExp = src->isGeneratorExp;
 97298: 
 97298:     /*
 97298:      * initScriptCounts updates scriptCountsMap if necessary. The other script
 97298:      * maps in JSCompartment are populated lazily.
 97298:      */
 97298:     if (cx->hasRunOption(JSOPTION_PCCOUNT))
 97298:         (void) dst->initScriptCounts(cx);
 97298: 
 97298:     if (nconsts != 0) {
 97298:         HeapValue *vector = Rebase<HeapValue>(dst, src, src->consts()->vector);
 97298:         dst->consts()->vector = vector;
 97298:         for (unsigned i = 0; i < nconsts; ++i)
 97298:             JS_ASSERT_IF(vector[i].isMarkable(), vector[i].toString()->isAtom());
 97298:     }
 97298:     if (nobjects != 0) {
 97298:         HeapPtrObject *vector = Rebase<HeapPtr<JSObject> >(dst, src, src->objects()->vector);
 97298:         dst->objects()->vector = vector;
 97298:         for (unsigned i = 0; i < nobjects; ++i)
 97298:             vector[i].init(objects[i]);
 97298:     }
 97298:     if (nregexps != 0) {
 97298:         HeapPtrObject *vector = Rebase<HeapPtr<JSObject> >(dst, src, src->regexps()->vector);
 97298:         dst->regexps()->vector = vector;
 97298:         for (unsigned i = 0; i < nregexps; ++i)
 97298:             vector[i].init(regexps[i]);
 97298:     }
 97298:     if (ntrynotes != 0)
 97298:         dst->trynotes()->vector = Rebase<JSTryNote>(dst, src, src->trynotes()->vector);
 97298: 
 97298:     return dst;
 55633: }
 55633: 
 95151: DebugScript *
 95151: JSScript::debugScript()
 95151: {
 95151:     JS_ASSERT(hasDebugScript);
 95151:     DebugScriptMap *map = compartment()->debugScriptMap;
 95151:     JS_ASSERT(map);
 95151:     DebugScriptMap::Ptr p = map->lookup(this);
 95151:     JS_ASSERT(p);
 95151:     return p->value;
 95151: }
 95151: 
 95151: DebugScript *
 95151: JSScript::releaseDebugScript()
 95151: {
 95151:     JS_ASSERT(hasDebugScript);
 95151:     DebugScriptMap *map = compartment()->debugScriptMap;
 95151:     JS_ASSERT(map);
 95151:     DebugScriptMap::Ptr p = map->lookup(this);
 95151:     JS_ASSERT(p);
 95151:     DebugScript *debug = p->value;
 95151:     map->remove(p);
 95151:     hasDebugScript = false;
 95151:     return debug;
 95151: }
 95151: 
 95151: void
 95151: JSScript::destroyDebugScript(FreeOp *fop)
 95151: {
 95151:     if (hasDebugScript) {
 95151:         jsbytecode *end = code + length;
 95151:         for (jsbytecode *pc = code; pc < end; pc++) {
 95151:             if (BreakpointSite *site = getBreakpointSite(pc)) {
 95151:                 /* Breakpoints are swept before finalization. */
 95151:                 JS_ASSERT(site->firstBreakpoint() == NULL);
 95151:                 site->clearTrap(fop, NULL, NULL);
 95151:                 JS_ASSERT(getBreakpointSite(pc) == NULL);
 95151:             }
 95151:         }
 95151:         fop->free_(releaseDebugScript());
 95151:     }
 95151: }
 95151: 
 77169: bool
 95151: JSScript::ensureHasDebugScript(JSContext *cx)
 84195: {
 95151:     if (hasDebugScript)
 84195:         return true;
 84195: 
 84195:     size_t nbytes = offsetof(DebugScript, breakpoints) + length * sizeof(BreakpointSite*);
 95151:     DebugScript *debug = (DebugScript *) cx->calloc_(nbytes);
 84195:     if (!debug)
 84195:         return false;
 84195: 
 95151:     /* Create compartment's debugScriptMap if necessary. */
 95151:     DebugScriptMap *map = compartment()->debugScriptMap;
 95151:     if (!map) {
 95151:         map = cx->new_<DebugScriptMap>();
 95151:         if (!map || !map->init()) {
 95151:             cx->free_(debug);
 95151:             cx->delete_(map);
 95151:             return false;
 95151:         }
 95151:         compartment()->debugScriptMap = map;
 95151:     }
 95151: 
 95151:     if (!map->putNew(this, debug)) {
 95151:         cx->free_(debug);
 95151:         cx->delete_(map);
 95151:         return false;
 95151:     }
 95151:     hasDebugScript = true; // safe to set this;  we can't fail after this point
 95151: 
 84195:     /*
 84195:      * Ensure that any Interpret() instances running on this script have
 84195:      * interrupts enabled. The interrupts must stay enabled until the
 84195:      * debug state is destroyed.
 84195:      */
 84195:     InterpreterFrames *frames;
 88135:     for (frames = cx->runtime->interpreterFrames; frames; frames = frames->older)
 84195:         frames->enableInterruptsIfRunning(this);
 84195: 
 84195:     return true;
 84195: }
 84195: 
 94740: void
 94740: JSScript::recompileForStepMode(FreeOp *fop)
 77169: {
 77169: #ifdef JS_METHODJIT
106782:     if (hasMJITInfo()) {
 94740:         mjit::Recompiler::clearStackReferences(fop, this);
 94740:         mjit::ReleaseScriptCode(fop, this);
 77169:     }
 77169: #endif
 77169: }
 77169: 
 77169: bool
 84755: JSScript::tryNewStepMode(JSContext *cx, uint32_t newValue)
 77169: {
 95151:     JS_ASSERT(hasDebugScript);
 84195: 
 95151:     DebugScript *debug = debugScript();
 84755:     uint32_t prior = debug->stepMode;
 84195:     debug->stepMode = newValue;
 77169: 
 77169:     if (!prior != !newValue) {
 77169:         /* Step mode has been enabled or disabled. Alert the methodjit. */
 94740:         recompileForStepMode(cx->runtime->defaultFreeOp());
 77169: 
 95151:         if (!stepModeEnabled() && !debug->numSites)
 95151:             cx->free_(releaseDebugScript());
 77169:     }
 84195: 
 77169:     return true;
 77169: }
 77169: 
 77169: bool
 77169: JSScript::setStepModeFlag(JSContext *cx, bool step)
 77169: {
 95151:     if (!ensureHasDebugScript(cx))
 84195:         return false;
 84195: 
 95151:     return tryNewStepMode(cx, (debugScript()->stepMode & stepCountMask) |
 95151:                                (step ? stepFlagMask : 0));
 77169: }
 77169: 
 77169: bool
 77169: JSScript::changeStepModeCount(JSContext *cx, int delta)
 77169: {
 95151:     if (!ensureHasDebugScript(cx))
 84195:         return false;
 84195: 
 77169:     assertSameCompartment(cx, this);
 77169:     JS_ASSERT_IF(delta > 0, cx->compartment->debugMode());
 77169: 
 95151:     DebugScript *debug = debugScript();
 84755:     uint32_t count = debug->stepMode & stepCountMask;
 77169:     JS_ASSERT(((count + delta) & stepCountMask) == count + delta);
 77169:     return tryNewStepMode(cx,
 84195:                           (debug->stepMode & stepFlagMask) |
 77169:                           ((count + delta) & stepCountMask));
 77169: }
 84195: 
 84195: BreakpointSite *
104376: JSScript::getOrCreateBreakpointSite(JSContext *cx, jsbytecode *pc)
 84195: {
 84195:     JS_ASSERT(size_t(pc - code) < length);
 84195: 
 95151:     if (!ensureHasDebugScript(cx))
 84195:         return NULL;
 84195: 
 95151:     DebugScript *debug = debugScript();
 84195:     BreakpointSite *&site = debug->breakpoints[pc - code];
 84195: 
 84195:     if (!site) {
 84195:         site = cx->runtime->new_<BreakpointSite>(this, pc);
 84195:         if (!site) {
 84195:             js_ReportOutOfMemory(cx);
 84195:             return NULL;
 84195:         }
 84195:         debug->numSites++;
 84195:     }
 84195: 
 84195:     return site;
 84195: }
 84195: 
 84195: void
 94740: JSScript::destroyBreakpointSite(FreeOp *fop, jsbytecode *pc)
 84195: {
 84195:     JS_ASSERT(unsigned(pc - code) < length);
 84195: 
 95151:     DebugScript *debug = debugScript();
 84195:     BreakpointSite *&site = debug->breakpoints[pc - code];
 84195:     JS_ASSERT(site);
 84195: 
 94740:     fop->delete_(site);
 84195:     site = NULL;
 84195: 
 95151:     if (--debug->numSites == 0 && !stepModeEnabled())
 95151:         fop->free_(releaseDebugScript());
 84195: }
 84195: 
 84195: void
 94959: JSScript::clearBreakpointsIn(FreeOp *fop, js::Debugger *dbg, JSObject *handler)
 84195: {
 84195:     if (!hasAnyBreakpointsOrStepMode())
 84195:         return;
 84195: 
 84195:     jsbytecode *end = code + length;
 84195:     for (jsbytecode *pc = code; pc < end; pc++) {
 84195:         BreakpointSite *site = getBreakpointSite(pc);
 84195:         if (site) {
 84195:             Breakpoint *nextbp;
 84195:             for (Breakpoint *bp = site->firstBreakpoint(); bp; bp = nextbp) {
 84195:                 nextbp = bp->nextInSite();
 84195:                 if ((!dbg || bp->debugger == dbg) && (!handler || bp->getHandler() == handler))
 94959:                     bp->destroy(fop);
 84195:             }
 84195:         }
 84195:     }
 84195: }
 84195: 
 84195: void
 94740: JSScript::clearTraps(FreeOp *fop)
 84195: {
 84195:     if (!hasAnyBreakpointsOrStepMode())
 84195:         return;
 84195: 
 84195:     jsbytecode *end = code + length;
 84195:     for (jsbytecode *pc = code; pc < end; pc++) {
 84195:         BreakpointSite *site = getBreakpointSite(pc);
 84195:         if (site)
 94740:             site->clearTrap(fop);
 84195:     }
 84195: }
 84195: 
 84195: void
 91557: JSScript::markChildren(JSTracer *trc)
 84195: {
102045:     // NOTE: this JSScript may be partially initialized at this point.  E.g. we
102045:     // may have created it and partially initialized it with
102045:     // JSScript::Create(), but not yet finished initializing it with
102045:     // fullyInitFromEmitter() or fullyInitTrivial().
102045: 
 94620:     JS_ASSERT_IF(trc->runtime->gcStrictCompartmentChecking, compartment()->isCollecting());
 91557: 
 91557:     for (uint32_t i = 0; i < natoms; ++i) {
 91557:         if (atoms[i])
 94934:             MarkString(trc, &atoms[i], "atom");
 91557:     }
 91557: 
 97361:     if (hasObjects()) {
 97362:         ObjectArray *objarray = objects();
 91557:         MarkObjectRange(trc, objarray->length, objarray->vector, "objects");
 91557:     }
 91557: 
 97361:     if (hasRegexps()) {
 97362:         ObjectArray *objarray = regexps();
 91557:         MarkObjectRange(trc, objarray->length, objarray->vector, "objects");
 91557:     }
 91557: 
 97361:     if (hasConsts()) {
 97362:         ConstArray *constarray = consts();
 91557:         MarkValueRange(trc, constarray->length, constarray->vector, "consts");
 91557:     }
 91557: 
 91557:     if (function())
 91557:         MarkObject(trc, &function_, "function");
 91557: 
104378:     if (enclosingScope_)
104378:         MarkObject(trc, &enclosingScope_, "enclosing");
104378: 
107564:     if (IS_GC_MARKING_TRACER(trc) && filename)
 97463:         MarkScriptFilename(trc->runtime, filename);
 91557: 
 91557:     bindings.trace(trc);
 91557: 
 98147: #ifdef JS_METHODJIT
 98147:     for (int constructing = 0; constructing <= 1; constructing++) {
 98147:         for (int barriers = 0; barriers <= 1; barriers++) {
 98147:             mjit::JITScript *jit = getJIT((bool) constructing, (bool) barriers);
 98147:             if (jit)
 98147:                 jit->trace(trc);
 98147:         }
 98147:     }
 98147: #endif
 98147: 
 91557:     if (hasAnyBreakpointsOrStepMode()) {
 84195:         for (unsigned i = 0; i < length; i++) {
 95151:             BreakpointSite *site = debugScript()->breakpoints[i];
 84195:             if (site && site->trapHandler)
 90302:                 MarkValue(trc, &site->trapClosure, "trap closure");
 84195:         }
 84195:     }
 91557: }
 93250: 
 93250: void
103284: JSScript::setArgumentsHasVarBinding()
 95100: {
103284:     argsHasVarBinding_ = true;
 95100:     needsArgsAnalysis_ = true;
 95100: }
 95100: 
 95100: void
 93250: JSScript::setNeedsArgsObj(bool needsArgsObj)
 93250: {
 95100:     JS_ASSERT(!analyzedArgsUsage());
103284:     JS_ASSERT_IF(needsArgsObj, argumentsHasVarBinding());
 95100:     needsArgsAnalysis_ = false;
 93250:     needsArgsObj_ = needsArgsObj;
 93250: }
 93251: 
 97353: /* static */ bool
103261: JSScript::argumentsOptimizationFailed(JSContext *cx, JSScript *script_)
 93251: {
 99421:     Rooted<JSScript*> script(cx, script_);
 97353: 
 97353:     JS_ASSERT(script->analyzedArgsUsage());
103284:     JS_ASSERT(script->argumentsHasVarBinding());
103773:     JS_ASSERT(!script->isGenerator);
 95684: 
 95684:     /*
 95684:      * It is possible that the apply speculation has already failed, everything
 95684:      * has been fixed up, but there was an outstanding magic value on the
 95684:      * stack that has just now flowed into an apply. In this case, there is
 95684:      * nothing to do; GuardFunApplySpeculation will patch in the real argsobj.
 95684:      */
 97353:     if (script->needsArgsObj())
 95684:         return true;
 95684: 
 97353:     script->needsArgsObj_ = true;
 93251: 
103284:     const unsigned var = script->bindings.argumentsVarIndex(cx);
 95100: 
 93251:     /*
 93251:      * By design, the apply-arguments optimization is only made when there
 93251:      * are no outstanding cases of MagicValue(JS_OPTIMIZED_ARGUMENTS) other
 93251:      * than this particular invocation of 'f.apply(x, arguments)'. Thus, there
 93251:      * are no outstanding values of MagicValue(JS_OPTIMIZED_ARGUMENTS) on the
 93251:      * stack. However, there are three things that need fixup:
 93251:      *  - there may be any number of activations of this script that don't have
 93251:      *    an argsObj that now need one.
 93251:      *  - jit code compiled (and possible active on the stack) with the static
 93251:      *    assumption of !script->needsArgsObj();
 93251:      *  - type inference data for the script assuming script->needsArgsObj; and
 93251:      */
 93251:     for (AllFramesIter i(cx->stack.space()); !i.done(); ++i) {
 93251:         StackFrame *fp = i.fp();
 97353:         if (fp->isFunctionFrame() && fp->script() == script) {
101075:             ArgumentsObject *argsobj = ArgumentsObject::createExpected(cx, fp);
101075:             if (!argsobj) {
 93251:                 /*
101075:                  * We can't leave stack frames with script->needsArgsObj but no
101075:                  * arguments object. It is, however, safe to leave frames with
101075:                  * an arguments object but !script->needsArgsObj.
 93251:                  */
 97353:                 script->needsArgsObj_ = false;
 93251:                 return false;
 93251:             }
 95685: 
 95685:             /* Note: 'arguments' may have already been overwritten. */
103284:             if (fp->unaliasedLocal(var).isMagic(JS_OPTIMIZED_ARGUMENTS))
103284:                 fp->unaliasedLocal(var) = ObjectValue(*argsobj);
 93251:         }
 93251:     }
 93251: 
 93251: #ifdef JS_METHODJIT
106782:     if (script->hasMJITInfo()) {
103617:         mjit::ExpandInlineFrames(cx->compartment);
 97353:         mjit::Recompiler::clearStackReferences(cx->runtime->defaultFreeOp(), script);
 97353:         mjit::ReleaseScriptCode(cx->runtime->defaultFreeOp(), script);
 93251:     }
 93251: #endif
 93251: 
 97353:     if (script->hasAnalysis() && script->analysis()->ranInference()) {
 93251:         types::AutoEnterTypeInference enter(cx);
 97353:         types::TypeScript::MonitorUnknown(cx, script, script->argumentsBytecode());
 93251:     }
 93251: 
 93251:     return true;
 93251: }
 95099: 
 95099: bool
 95099: JSScript::varIsAliased(unsigned varSlot)
 95099: {
108509:     return bindings.bindingIsAliased(bindings.numArgs() + varSlot);
 95099: }
 95099: 
 95099: bool
 98892: JSScript::formalIsAliased(unsigned argSlot)
 95099: {
108509:     return bindings.bindingIsAliased(argSlot);
 95101: }
 95101: 
 95101: bool
 98892: JSScript::formalLivesInArgumentsObject(unsigned argSlot)
 95101: {
108509:     return argsObjAliasesFormals() && !formalIsAliased(argSlot);
 95101: }
