     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 34535: #include <dlfcn.h>
 34535: 
 11978: #include "nsMenuX.h"
 15578: #include "nsMenuItemX.h"
 15578: #include "nsMenuUtilsX.h"
 15578: #include "nsMenuItemIconX.h"
 37976: #include "nsStandaloneNativeMenu.h"
 11978: 
 15578: #include "nsObjCExceptions.h"
 15578: 
 15578: #include "nsToolkit.h"
 98723: #include "nsCocoaFeatures.h"
 15578: #include "nsCocoaUtils.h"
 15561: #include "nsCOMPtr.h"
 15578: #include "prinrval.h"
 15578: #include "nsString.h"
 15578: #include "nsReadableUtils.h"
 15578: #include "nsUnicharUtils.h"
 15578: #include "plstr.h"
 80435: #include "nsGkAtoms.h"
 15578: #include "nsGUIEvent.h"
 15578: #include "nsCRT.h"
120177: #include "nsBaseWidget.h"
 15578: 
     1: #include "nsIDocument.h"
     1: #include "nsIContent.h"
     1: #include "nsIDOMDocument.h"
     1: #include "nsIDocumentObserver.h"
     1: #include "nsIComponentManager.h"
     1: #include "nsIRollupListener.h"
 15578: #include "nsIDOMElement.h"
 99253: #include "nsBindingManager.h"
     1: #include "nsIServiceManager.h"
119458: #include "nsXULPopupManager.h"
     1: 
     1: #include "jsapi.h"
     1: #include "nsIScriptGlobalObject.h"
     1: #include "nsIScriptContext.h"
     1: #include "nsIXPConnect.h"
     1: 
 79445: static bool gConstructingMenu = false;
 79445: static bool gMenuMethodsSwizzled = false;
 13630: 
108991: int32_t nsMenuX::sIndexingMenuLevel = 0;
 14663: 
 37530: 
 37530: //
 37530: // Objective-C class used for representedObject
 37530: //
 37530: 
 37530: @implementation MenuItemInfo
 37530: 
 37530: - (id) initWithMenuGroupOwner:(nsMenuGroupOwnerX *)aMenuGroupOwner
 37530: {
 37530:   if ((self = [super init]) != nil) {
106838:     mMenuGroupOwner = nullptr;
 37530:     [self setMenuGroupOwner:aMenuGroupOwner];
 37530:   }
 37530:   return self;
 37530: }
 37530: 
 37530: - (void) dealloc
 37530: {
106838:   [self setMenuGroupOwner:nullptr];
 37530:   [super dealloc];
 37530: }
 37530: 
 37530: - (nsMenuGroupOwnerX *) menuGroupOwner
 37530: {
 37530:   return mMenuGroupOwner;
 37530: }
 37530: 
 37530: - (void) setMenuGroupOwner:(nsMenuGroupOwnerX *)aMenuGroupOwner
 37530: {
 37530:   // weak reference as the nsMenuGroupOwnerX owns all of its sub-objects
 37530:   mMenuGroupOwner = aMenuGroupOwner;
 37530: }
 37530: 
 37530: @end
 37530: 
 37530: 
 37530: //
 37530: // nsMenuX
 37530: //
 37530: 
     1: nsMenuX::nsMenuX()
106838: : mVisibleItemsCount(0), mParent(nullptr), mMenuGroupOwner(nullptr),
 79564:   mNativeMenu(nil), mNativeMenuItem(nil), mIsEnabled(true),
 79564:   mDestroyHandlerCalled(false), mNeedsRebuild(true),
 79564:   mConstructed(false), mVisible(true), mXBLAttached(false)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 22577:   if (!gMenuMethodsSwizzled) {
 13630:     nsToolkit::SwizzleMethods([NSMenu class], @selector(_addItem:toTable:),
 79564:                               @selector(nsMenuX_NSMenu_addItem:toTable:), true);
 13630:     nsToolkit::SwizzleMethods([NSMenu class], @selector(_removeItem:fromTable:),
 79564:                               @selector(nsMenuX_NSMenu_removeItem:fromTable:), true);
 34535:     // On SnowLeopard the Shortcut framework (which contains the
 34535:     // SCTGRLIndex class) is loaded on demand, whenever the user first opens
 34535:     // a menu (which normally hasn't happened yet).  So we need to load it
 34535:     // here explicitly.
 34535:     dlopen("/System/Library/PrivateFrameworks/Shortcut.framework/Shortcut", RTLD_LAZY);
 14663:     Class SCTGRLIndexClass = ::NSClassFromString(@"SCTGRLIndex");
 14663:     nsToolkit::SwizzleMethods(SCTGRLIndexClass, @selector(indexMenuBarDynamically),
 14663:                               @selector(nsMenuX_SCTGRLIndex_indexMenuBarDynamically));
 38433: 
 79564:     gMenuMethodsSwizzled = true;
 13630:   }
 13630: 
     1:   mMenuDelegate = [[MenuDelegate alloc] initWithGeckoMenu:this];
     1:     
     1:   if (!nsMenuBarX::sNativeEventTarget)
     1:     nsMenuBarX::sNativeEventTarget = [[NativeMenuItemTarget alloc] init];
 11978: 
 15578:   MOZ_COUNT_CTOR(nsMenuX);
 15578: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: nsMenuX::~nsMenuX()
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
 30014:   // Prevent the icon object from outliving us.
 30014:   if (mIcon)
 30014:     mIcon->Destroy();
 30014: 
     1:   RemoveAll();
     1: 
 16264:   [mNativeMenu setDelegate:nil];
 16264:   [mNativeMenu release];
     1:   [mMenuDelegate release];
 25288:   // autorelease the native menu item so that anything else happening to this
 25288:   // object happens before the native menu item actually dies
 25288:   [mNativeMenuItem autorelease];
     1: 
     1:   // alert the change notifier we don't care no more
 15578:   if (mContent)
 37530:     mMenuGroupOwner->UnregisterForContentChanges(mContent);
 15578: 
 15578:   MOZ_COUNT_DTOR(nsMenuX);
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
 37530: nsresult nsMenuX::Create(nsMenuObjectX* aParent, nsMenuGroupOwnerX* aMenuGroupOwner, nsIContent* aNode)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
 15578:   mContent = aNode;
 80435:   mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, mLabel);
 16264:   mNativeMenu = CreateMenuWithGeckoString(mLabel);
     1: 
     1:   // register this menu to be notified when changes are made to our content object
 37530:   mMenuGroupOwner = aMenuGroupOwner; // weak ref
 37530:   NS_ASSERTION(mMenuGroupOwner, "No menu owner given, must have one");
 37530:   mMenuGroupOwner->RegisterForContentChanges(mContent, this);
     1: 
     1:   mParent = aParent;
     1:   // our parent could be either a menu bar (if we're toplevel) or a menu (if we're a submenu)
 58955: 
 58955: #ifdef DEBUG
 58955:   nsMenuObjectTypeX parentType =
 58955: #endif
 58955:     mParent->MenuObjectType();
 37976:   NS_ASSERTION((parentType == eMenuBarObjectType || parentType == eSubmenuObjectType || parentType == eStandaloneNativeMenuObjectType),
 37976:                "Menu parent not a menu bar, menu, or native menu!");
     1: 
 15578:   if (nsMenuUtilsX::NodeIsHiddenOrCollapsed(mContent))
 79564:     mVisible = false;
 15578:   if (mContent->GetChildCount() == 0)
 79564:     mVisible = false;
     1: 
 27906:   NSString *newCocoaLabelString = nsMenuUtilsX::GetTruncatedCocoaLabel(mLabel);
  4725:   mNativeMenuItem = [[NSMenuItem alloc] initWithTitle:newCocoaLabelString action:nil keyEquivalent:@""];
 16264:   [mNativeMenuItem setSubmenu:mNativeMenu];
  4725: 
 80435:   SetEnabled(!mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
 80435:                                     nsGkAtoms::_true, eCaseMatters));
  5999: 
     1:   // We call MenuConstruct here because keyboard commands are dependent upon
     1:   // native menu items being created. If we only call MenuConstruct when a menu
     1:   // is actually selected, then we can't access keyboard commands until the
     1:   // menu gets selected, which is bad.
 16264:   MenuConstruct();
     1: 
 15578:   mIcon = new nsMenuItemIconX(this, mContent, mNativeMenuItem);
   701: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
 15578: nsresult nsMenuX::AddMenuItem(nsMenuItemX* aMenuItem)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
     1:   if (!aMenuItem)
     1:     return NS_ERROR_INVALID_ARG;
     1: 
 15578:   mMenuObjectsArray.AppendElement(aMenuItem);
 15578:   if (nsMenuUtilsX::NodeIsHiddenOrCollapsed(aMenuItem->Content()))
    19:     return NS_OK;
  5355:   ++mVisibleItemsCount;
     1: 
 15578:   NSMenuItem* newNativeMenuItem = (NSMenuItem*)aMenuItem->NativeData();
 15578: 
     1:   // add the menu item to this menu
 16264:   [mNativeMenu addItem:newNativeMenuItem];
     1: 
     1:   // set up target/action
     1:   [newNativeMenuItem setTarget:nsMenuBarX::sNativeEventTarget];
     1:   [newNativeMenuItem setAction:@selector(menuItemHit:)];
     1: 
     1:   // set its command. we get the unique command id from the menubar
 37530:   [newNativeMenuItem setTag:mMenuGroupOwner->RegisterForCommand(aMenuItem)];
 37530:   MenuItemInfo * info = [[MenuItemInfo alloc] initWithMenuGroupOwner:mMenuGroupOwner];
 37530:   [newNativeMenuItem setRepresentedObject:info];
 37530:   [info release];
     1: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
 15578: nsresult nsMenuX::AddMenu(nsMenuX* aMenu)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
     1:   // Add a submenu
     1:   if (!aMenu)
     1:     return NS_ERROR_NULL_POINTER;
     1: 
 15578:   mMenuObjectsArray.AppendElement(aMenu);
 15578:   if (nsMenuUtilsX::NodeIsHiddenOrCollapsed(aMenu->Content()))
    19:     return NS_OK;
  5355:   ++mVisibleItemsCount;
     1: 
     1:   // We have to add a menu item and then associate the menu with it
 16264:   NSMenuItem* newNativeMenuItem = aMenu->NativeMenuItem();
  4725:   if (!newNativeMenuItem)
  4725:     return NS_ERROR_FAILURE;
 16264:   [mNativeMenu addItem:newNativeMenuItem];
     1: 
 15578:   [newNativeMenuItem setSubmenu:(NSMenu*)aMenu->NativeData()];
     1: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
  5355: // Includes all items, including hidden/collapsed ones
108991: uint32_t nsMenuX::GetItemCount()
     1: {
 15578:   return mMenuObjectsArray.Length();
     1: }
     1: 
  5355: // Includes all items, including hidden/collapsed ones
108991: nsMenuObjectX* nsMenuX::GetItemAt(uint32_t aPos)
     1: {
108991:   if (aPos >= (uint32_t)mMenuObjectsArray.Length())
 15578:     return NULL;
  5355: 
 15578:   return mMenuObjectsArray[aPos];
     1: }
     1: 
  5355: // Only includes visible items
108991: nsresult nsMenuX::GetVisibleItemCount(uint32_t &aCount)
  5355: {
  5355:   aCount = mVisibleItemsCount;
  5355:   return NS_OK;
  5355: }
  5355: 
  5355: // Only includes visible items. Note that this is provides O(N) access
  5355: // If you need to iterate or search, consider using GetItemAt and doing your own filtering
108991: nsMenuObjectX* nsMenuX::GetVisibleItemAt(uint32_t aPos)
  5355: {
 15578:   
108991:   uint32_t count = mMenuObjectsArray.Length();
  5355:   if (aPos >= mVisibleItemsCount || aPos >= count)
 15578:     return NULL;
  5355: 
  5355:   // If there are no invisible items, can provide direct access
 15578:   if (mVisibleItemsCount == count)
 15578:     return mMenuObjectsArray[aPos];
  5355: 
  5355:   // Otherwise, traverse the array until we find the the item we're looking for.
 15578:   nsMenuObjectX* item;
108991:   uint32_t visibleNodeIndex = 0;
108991:   for (uint32_t i = 0; i < count; i++) {
 15578:     item = mMenuObjectsArray[i];
 16264:     if (!nsMenuUtilsX::NodeIsHiddenOrCollapsed(item->Content())) {
  5355:       if (aPos == visibleNodeIndex) {
  5355:         // we found the visible node we're looking for, return it
 15578:         return item;
  5355:       }
  5355:       visibleNodeIndex++;
  5355:     }
  5355:   }
  5355: 
 15578:   return NULL;
  5355: }
  5355: 
 15578: nsresult nsMenuX::RemoveAll()
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
 16264:   if (mNativeMenu) {
     1:     // clear command id's
 16264:     int itemCount = [mNativeMenu numberOfItems];
 10562:     for (int i = 0; i < itemCount; i++)
108991:       mMenuGroupOwner->UnregisterCommand((uint32_t)[[mNativeMenu itemAtIndex:i] tag]);
     1:     // get rid of Cocoa menu items
 16264:     for (int i = [mNativeMenu numberOfItems] - 1; i >= 0; i--)
 16264:       [mNativeMenu removeItemAtIndex:i];
     1:   }
 15578: 
 15578:   mMenuObjectsArray.Clear();
  5355:   mVisibleItemsCount = 0;
     1: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
 31539: nsEventStatus nsMenuX::MenuOpened()
     1: {
     1:   // Open the node.
 80435:   mContent->SetAttr(kNameSpaceID_None, nsGkAtoms::open, NS_LITERAL_STRING("true"), true);
     1: 
 15578:   // Fire a handler. If we're told to stop, don't build the menu at all
 79445:   bool keepProcessing = OnOpen();
     1: 
     1:   if (!mNeedsRebuild || !keepProcessing)
     1:     return nsEventStatus_eConsumeNoDefault;
     1: 
     1:   if (!mConstructed || mNeedsRebuild) {
     1:     if (mNeedsRebuild)
     1:       RemoveAll();
     1: 
 16264:     MenuConstruct();
     1:     mConstructed = true;
     1:   }
     1: 
 31539:   nsEventStatus status = nsEventStatus_eIgnore;
106838:   nsMouseEvent event(true, NS_XUL_POPUP_SHOWN, nullptr, nsMouseEvent::eReal);
 31539: 
 31539:   nsCOMPtr<nsIContent> popupContent;
 31539:   GetMenuPopupContent(getter_AddRefs(popupContent));
 31539:   nsIContent* dispatchTo = popupContent ? popupContent : mContent;
106838:   dispatchTo->DispatchDOMEvent(&event, nullptr, nullptr, &status);
     1:   
  6118:   return nsEventStatus_eConsumeNoDefault;
     1: }
     1: 
 31539: void nsMenuX::MenuClosed()
     1: {
     1:   if (mConstructed) {
 15578:     // Don't close if a handler tells us to stop.
 15578:     if (!OnClose())
 15578:       return;
 15578: 
 15578:     if (mNeedsRebuild)
 15578:       mConstructed = false;
 15578: 
 80435:     mContent->UnsetAttr(kNameSpaceID_None, nsGkAtoms::open, true);
 15578: 
 31539:     nsEventStatus status = nsEventStatus_eIgnore;
106838:     nsMouseEvent event(true, NS_XUL_POPUP_HIDDEN, nullptr, nsMouseEvent::eReal);
 15578: 
 31539:     nsCOMPtr<nsIContent> popupContent;
 31539:     GetMenuPopupContent(getter_AddRefs(popupContent));
 31539:     nsIContent* dispatchTo = popupContent ? popupContent : mContent;
106838:     dispatchTo->DispatchDOMEvent(&event, nullptr, nullptr, &status);
 31539: 
 79564:     mDestroyHandlerCalled = true;
     1:     mConstructed = false;
     1:   }
     1: }
     1: 
 16264: void nsMenuX::MenuConstruct()
     1: {
     1:   mConstructed = false;
 79564:   gConstructingMenu = true;
     1:   
     1:   // reset destroy handler flag so that we'll know to fire it next time this menu goes away.
 79564:   mDestroyHandlerCalled = false;
     1: 
 16264:   //printf("nsMenuX::MenuConstruct called for %s = %d \n", NS_LossyConvertUTF16toASCII(mLabel).get(), mNativeMenu);
     1: 
     1:   // Retrieve our menupopup.
     1:   nsCOMPtr<nsIContent> menuPopup;
     1:   GetMenuPopupContent(getter_AddRefs(menuPopup));
     1:   if (!menuPopup) {
 79564:     gConstructingMenu = false;
  7751:     return;
     1:   }
     1: 
     1:   // bug 365405: Manually wrap the menupopup node to make sure it's bounded
     1:   if (!mXBLAttached) {
     1:     nsresult rv;
     1:     nsCOMPtr<nsIXPConnect> xpconnect =
     1:       do_GetService(nsIXPConnect::GetCID(), &rv);
     1:     if (NS_SUCCEEDED(rv)) {
 80526:       nsIDocument* ownerDoc = menuPopup->OwnerDoc();
     1:       nsIScriptGlobalObject* sgo;
     1:       if (ownerDoc && (sgo = ownerDoc->GetScriptGlobalObject())) {
     1:         nsCOMPtr<nsIScriptContext> scriptContext = sgo->GetContext();
     1:         JSObject* global = sgo->GetGlobalJSObject();
     1:         if (scriptContext && global) {
     1:           JSContext* cx = (JSContext*)scriptContext->GetNativeContext();
     1:           if (cx) {
     1:             nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
     1:             xpconnect->WrapNative(cx, global,
     1:                                   menuPopup, NS_GET_IID(nsISupports),
     1:                                   getter_AddRefs(wrapper));
 79564:             mXBLAttached = true;
     1:           }
     1:         }
     1:       } 
     1:     }
     1:   }
     1: 
     1:   // Iterate over the kids
108991:   uint32_t count = menuPopup->GetChildCount();
108991:   for (uint32_t i = 0; i < count; i++) {
     1:     nsIContent *child = menuPopup->GetChildAt(i);
     1:     if (child) {
     1:       // depending on the type, create a menu item, separator, or submenu
     1:       nsIAtom *tag = child->Tag();
 80435:       if (tag == nsGkAtoms::menuitem || tag == nsGkAtoms::menuseparator)
    19:         LoadMenuItem(child);
 80435:       else if (tag == nsGkAtoms::menu)
    19:         LoadSubMenu(child);
     1:     }
     1:   } // for each menu item
     1: 
 79564:   gConstructingMenu = false;
 79564:   mNeedsRebuild = false;
 15578:   // printf("Done building, mMenuObjectsArray.Count() = %d \n", mMenuObjectsArray.Count());
     1: }
     1: 
 79445: void nsMenuX::SetRebuild(bool aNeedsRebuild)
     1: {
     1:   if (!gConstructingMenu)
     1:     mNeedsRebuild = aNeedsRebuild;
     1: }
     1: 
 79445: nsresult nsMenuX::SetEnabled(bool aIsEnabled)
     1: {
     1:   if (aIsEnabled != mIsEnabled) {
     1:     // we always want to rebuild when this changes
     1:     mIsEnabled = aIsEnabled;
 20755:     [mNativeMenuItem setEnabled:(BOOL)mIsEnabled];
     1:   }
     1:   return NS_OK;
     1: }
     1: 
 79445: nsresult nsMenuX::GetEnabled(bool* aIsEnabled)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aIsEnabled);
     1:   *aIsEnabled = mIsEnabled;
     1:   return NS_OK;
     1: }
     1: 
 14024: GeckoNSMenu* nsMenuX::CreateMenuWithGeckoString(nsString& menuTitle)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
     1:   NSString* title = [NSString stringWithCharacters:(UniChar*)menuTitle.get() length:menuTitle.Length()];
 14024:   GeckoNSMenu* myMenu = [[GeckoNSMenu alloc] initWithTitle:title];
     1:   [myMenu setDelegate:mMenuDelegate];
     1: 
     1:   // We don't want this menu to auto-enable menu items because then Cocoa
     1:   // overrides our decisions and things get incorrectly enabled/disabled.
     1:   [myMenu setAutoenablesItems:NO];
     1: 
     1:   // we used to install Carbon event handlers here, but since NSMenu* doesn't
     1:   // create its underlying MenuRef until just before display, we delay until
     1:   // that happens. Now we install the event handlers when Cocoa notifies
     1:   // us that a menu is about to display - see the Cocoa MenuDelegate class.
     1: 
     1:   return myMenu;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
    19: void nsMenuX::LoadMenuItem(nsIContent* inMenuItemContent)
     1: {
     1:   if (!inMenuItemContent)
     1:     return;
     1: 
     1:   nsAutoString menuitemName;
 80435:   inMenuItemContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, menuitemName);
     1: 
     1:   // printf("menuitem %s \n", NS_LossyConvertUTF16toASCII(menuitemName).get());
     1: 
 15578:   EMenuItemType itemType = eRegularMenuItemType;
 80435:   if (inMenuItemContent->Tag() == nsGkAtoms::menuseparator) {
 15578:     itemType = eSeparatorMenuItemType;
  5878:   }
  5878:   else {
     1:     static nsIContent::AttrValuesArray strings[] =
106838:   {&nsGkAtoms::checkbox, &nsGkAtoms::radio, nullptr};
 80435:     switch (inMenuItemContent->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::type,
     1:                                                strings, eCaseMatters)) {
 15578:       case 0: itemType = eCheckboxMenuItemType; break;
 15578:       case 1: itemType = eRadioMenuItemType; break;
     1:     }
  5878:   }
     1: 
     1:   // Create the item.
 15578:   nsMenuItemX* menuItem = new nsMenuItemX();
 15578:   if (!menuItem)
 15578:     return;
     1: 
 37530:   nsresult rv = menuItem->Create(this, menuitemName, itemType, mMenuGroupOwner, inMenuItemContent);
 15578:   if (NS_FAILED(rv)) {
 15578:     delete menuItem;
 15578:     return;
 15578:   }
 15578: 
 15578:   AddMenuItem(menuItem);
   701: 
   701:   // This needs to happen after the nsIMenuItem object is inserted into
   701:   // our item array in AddMenuItem()
 15578:   menuItem->SetupIcon();
     1: }
     1: 
    19: void nsMenuX::LoadSubMenu(nsIContent* inMenuContent)
     1: {
 15578:   nsAutoPtr<nsMenuX> menu(new nsMenuX());
 15578:   if (!menu)
     1:     return;
     1: 
 37530:   nsresult rv = menu->Create(this, mMenuGroupOwner, inMenuContent);
 15578:   if (NS_FAILED(rv))
 15578:     return;
     1: 
 15578:   AddMenu(menu);
   701: 
   701:   // This needs to happen after the nsIMenu object is inserted into
   701:   // our item array in AddMenu()
 15578:   menu->SetupIcon();
 15578: 
 15578:   menu.forget();
     1: }
     1: 
 15578: // This menu is about to open. Returns TRUE if we should keep processing the event,
 15578: // FALSE if the handler wants to stop the opening of the menu.
 79445: bool nsMenuX::OnOpen()
     1: {
     1:   nsEventStatus status = nsEventStatus_eIgnore;
106838:   nsMouseEvent event(true, NS_XUL_POPUP_SHOWING, nullptr,
     1:                      nsMouseEvent::eReal);
     1:   
     1:   nsCOMPtr<nsIContent> popupContent;
     1:   GetMenuPopupContent(getter_AddRefs(popupContent));
     1:   
     1:   nsresult rv = NS_OK;
 15578:   nsIContent* dispatchTo = popupContent ? popupContent : mContent;
106838:   rv = dispatchTo->DispatchDOMEvent(&event, nullptr, nullptr, &status);
     1:   if (NS_FAILED(rv) || status == nsEventStatus_eConsumeNoDefault)
 79564:     return false;
     1: 
 15578:   // If the open is going to succeed we need to walk our menu items, checking to
119458:   // see if any of them have a command attribute. If so, several attributes
 15578:   // must potentially be updated.
 16039: 
 16039:   // Get new popup content first since it might have changed as a result of the
 16039:   // NS_XUL_POPUP_SHOWING event above.
 16039:   GetMenuPopupContent(getter_AddRefs(popupContent));
 16039:   if (!popupContent)
 79564:     return true;
 16039: 
119458:   nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
119458:   if (pm) {
119458:     pm->UpdateMenuItems(popupContent);
     1:   }
     1: 
 79564:   return true;
     1: }
     1: 
 15578: // Returns TRUE if we should keep processing the event, FALSE if the handler
 15578: // wants to stop the closing of the menu.
 79445: bool nsMenuX::OnClose()
     1: {
     1:   if (mDestroyHandlerCalled)
 79564:     return true;
     1: 
     1:   nsEventStatus status = nsEventStatus_eIgnore;
106838:   nsMouseEvent event(true, NS_XUL_POPUP_HIDING, nullptr,
     1:                      nsMouseEvent::eReal);
     1: 
     1:   nsCOMPtr<nsIContent> popupContent;
     1:   GetMenuPopupContent(getter_AddRefs(popupContent));
     1: 
     1:   nsresult rv = NS_OK;
 15578:   nsIContent* dispatchTo = popupContent ? popupContent : mContent;
106838:   rv = dispatchTo->DispatchDOMEvent(&event, nullptr, nullptr, &status);
     1:   
 79564:   mDestroyHandlerCalled = true;
     1:   
     1:   if (NS_FAILED(rv) || status == nsEventStatus_eConsumeNoDefault)
 79564:     return false;
     1:   
 79564:   return true;
     1: }
     1: 
     1: // Find the |menupopup| child in the |popup| representing this menu. It should be one
     1: // of a very few children so we won't be iterating over a bazillion menu items to find
     1: // it (so the strcmp won't kill us).
     1: void nsMenuX::GetMenuPopupContent(nsIContent** aResult)
     1: {
     1:   if (!aResult)
     1:     return;
106838:   *aResult = nullptr;
     1:   
 37976:   // Check to see if we are a "menupopup" node (if we are a native menu).
 37976:   {
108991:     int32_t dummy;
 99253:     nsCOMPtr<nsIAtom> tag = mContent->OwnerDoc()->BindingManager()->ResolveTag(mContent, &dummy);
 80435:     if (tag == nsGkAtoms::menupopup) {
 37976:       *aResult = mContent;
 37976:       NS_ADDREF(*aResult);
 37976:       return;
 37976:     }
 37976:   }
 37976: 
 37976:   // Otherwise check our child nodes.
 37976:   
108991:   uint32_t count = mContent->GetChildCount();
     1: 
108991:   for (uint32_t i = 0; i < count; i++) {
108991:     int32_t dummy;
 15578:     nsIContent *child = mContent->GetChildAt(i);
 99253:     nsCOMPtr<nsIAtom> tag = child->OwnerDoc()->BindingManager()->ResolveTag(child, &dummy);
 80435:     if (tag == nsGkAtoms::menupopup) {
     1:       *aResult = child;
     1:       NS_ADDREF(*aResult);
     1:       return;
     1:     }
     1:   }
  5355: }
     1: 
 15578: NSMenuItem* nsMenuX::NativeMenuItem()
  4175: {
  4175:   return mNativeMenuItem;
  4175: }
  4175: 
 79445: bool nsMenuX::IsXULHelpMenu(nsIContent* aMenuContent)
 36962: {
 79445:   bool retval = false;
 36962:   if (aMenuContent) {
 36962:     nsAutoString id;
 80435:     aMenuContent->GetAttr(kNameSpaceID_None, nsGkAtoms::id, id);
 36962:     if (id.Equals(NS_LITERAL_STRING("helpMenu")))
 79564:       retval = true;
 36962:   }
 36962:   return retval;
 36962: }
 36962: 
     1: //
 10562: // nsChangeObserver
     1: //
     1: 
 15578: void nsMenuX::ObserveAttributeChanged(nsIDocument *aDocument, nsIContent *aContent,
 15578:                                       nsIAtom *aAttribute)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   // ignore the |open| attribute, which is by far the most common
 80435:   if (gConstructingMenu || (aAttribute == nsGkAtoms::open))
 10562:     return;
     1: 
 15578:   nsMenuObjectTypeX parentType = mParent->MenuObjectType();
     1: 
 80435:   if (aAttribute == nsGkAtoms::disabled) {
 80435:     SetEnabled(!mContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::disabled,
 80435:                                       nsGkAtoms::_true, eCaseMatters));
     1:   }
 80435:   else if (aAttribute == nsGkAtoms::label) {
 80435:     mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::label, mLabel);
     1: 
     1:     // invalidate my parent. If we're a submenu parent, we have to rebuild
     1:     // the parent menu in order for the changes to be picked up. If we're
     1:     // a regular menu, just change the title and redraw the menubar.
 15578:     if (parentType == eMenuBarObjectType) {
     1:       // reuse the existing menu, to avoid rebuilding the root menu bar.
 16264:       NS_ASSERTION(mNativeMenu, "nsMenuX::AttributeChanged: invalid menu handle.");
 27906:       NSString *newCocoaLabelString = nsMenuUtilsX::GetTruncatedCocoaLabel(mLabel);
 16264:       [mNativeMenu setTitle:newCocoaLabelString];
     1:     }
 37976:     else if (parentType == eSubmenuObjectType) {
 79564:       static_cast<nsMenuX*>(mParent)->SetRebuild(true);
  8646:     }    
 37976:     else if (parentType == eStandaloneNativeMenuObjectType) {
 79564:       static_cast<nsStandaloneNativeMenu*>(mParent)->GetMenuXObject()->SetRebuild(true);
 37976:     }
     1:   }
 80435:   else if (aAttribute == nsGkAtoms::hidden || aAttribute == nsGkAtoms::collapsed) {
 79564:     SetRebuild(true);
     1: 
 79445:     bool contentIsHiddenOrCollapsed = nsMenuUtilsX::NodeIsHiddenOrCollapsed(mContent);
  5355: 
  5355:     // don't do anything if the state is correct already
  5355:     if (contentIsHiddenOrCollapsed != mVisible)
 10562:       return;
  5355: 
  5355:     if (contentIsHiddenOrCollapsed) {
 37976:       if (parentType == eMenuBarObjectType ||
 37976:           parentType == eSubmenuObjectType ||
 37976:           parentType == eStandaloneNativeMenuObjectType) {
 15578:         NSMenu* parentMenu = (NSMenu*)mParent->NativeData();
 12537:         // An exception will get thrown if we try to remove an item that isn't
 12537:         // in the menu.
 12537:         if ([parentMenu indexOfItem:mNativeMenuItem] != -1)
  5355:           [parentMenu removeItem:mNativeMenuItem];
 79564:         mVisible = false;
     1:       }
     1:     }
     1:     else {
 37976:       if (parentType == eMenuBarObjectType ||
 37976:           parentType == eSubmenuObjectType ||
 37976:           parentType == eStandaloneNativeMenuObjectType) {
 24131:         int insertionIndex = nsMenuUtilsX::CalculateNativeInsertionPoint(mParent, this);
 16264:         if (parentType == eMenuBarObjectType) {
 16264:           // Before inserting we need to figure out if we should take the native
 16264:           // application menu into account.
 16264:           nsMenuBarX* mb = static_cast<nsMenuBarX*>(mParent);
 16264:           if (mb->MenuContainsAppMenu())
 24131:             insertionIndex++;
 16264:         }
 15578:         NSMenu* parentMenu = (NSMenu*)mParent->NativeData();
 24131:         [parentMenu insertItem:mNativeMenuItem atIndex:insertionIndex];
 16264:         [mNativeMenuItem setSubmenu:mNativeMenu];
 79564:         mVisible = true;
     1:       }
     1:     }
     1:   }
 80435:   else if (aAttribute == nsGkAtoms::image) {
   701:     SetupIcon();
   701:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  5355: }
     1: 
 15578: void nsMenuX::ObserveContentRemoved(nsIDocument *aDocument, nsIContent *aChild,
108991:                                     int32_t aIndexInContainer)
     1: {
     1:   if (gConstructingMenu)
 10562:     return;
     1: 
 79564:   SetRebuild(true);
 37530:   mMenuGroupOwner->UnregisterForContentChanges(aChild);
  5355: }
     1: 
 71208: void nsMenuX::ObserveContentInserted(nsIDocument *aDocument, nsIContent* aContainer,
 71208:                                      nsIContent *aChild)
     1: {
     1:   if (gConstructingMenu)
 10562:     return;
     1: 
 79564:   SetRebuild(true);
  5355: }
     1: 
 15578: nsresult nsMenuX::SetupIcon()
     1: {
   701:   // In addition to out-of-memory, menus that are children of the menu bar
   701:   // will not have mIcon set.
 15578:   if (!mIcon)
 15578:     return NS_ERROR_OUT_OF_MEMORY;
 15578: 
   701:   return mIcon->SetupIcon();
     1: }
     1: 
  5355: //
     1: // MenuDelegate Objective-C class, used to set up Carbon events
  5355: //
     1: 
     1: @implementation MenuDelegate
     1: 
     1: - (id)initWithGeckoMenu:(nsMenuX*)geckoMenu
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 11978: 
     1:   if ((self = [super init])) {
 31539:     NS_ASSERTION(geckoMenu, "Cannot initialize native menu delegate with NULL gecko menu! Will crash!");
     1:     mGeckoMenu = geckoMenu;
     1:   }
     1:   return self;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
 31545: - (void)menu:(NSMenu *)menu willHighlightItem:(NSMenuItem *)item
 31545: {
 31545:   if (!menu || !item || !mGeckoMenu)
 31545:     return;
 31545: 
108991:   nsMenuObjectX* target = mGeckoMenu->GetVisibleItemAt((uint32_t)[menu indexOfItem:item]);
 31545:   if (target && (target->MenuObjectType() == eMenuItemObjectType)) {
 31545:     nsMenuItemX* targetMenuItem = static_cast<nsMenuItemX*>(target);
 79445:     bool handlerCalledPreventDefault; // but we don't actually care
 31545:     targetMenuItem->DispatchDOMEvent(NS_LITERAL_STRING("DOMMenuItemActive"), &handlerCalledPreventDefault);
 31545:   }
 31545: }
 31545: 
 31545: - (void)menuWillOpen:(NSMenu *)menu
 31545: {
 31545:   if (!mGeckoMenu)
 31545:     return;
 31545: 
 34535:   // Don't do anything while the OS is (re)indexing our menus (on Leopard and
 34535:   // higher).  This stops the Help menu from being able to search in our
 34535:   // menus, but it also resolves many other problems.
 34535:   if (nsMenuX::sIndexingMenuLevel > 0)
 34535:     return;
 34535: 
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
123327:   if (rollupListener) {
120177:   nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
120177:   if (rollupWidget) {
120177:     rollupListener->Rollup(0, nullptr);
 31545:     [menu cancelTracking];
 31545:     return;
 31545:   }
123327:   }
 31545:   mGeckoMenu->MenuOpened();
 31545: }
 31545: 
 31545: - (void)menuDidClose:(NSMenu *)menu
 31545: {
 31545:   if (!mGeckoMenu)
 31545:     return;
 31545: 
 34535:   // Don't do anything while the OS is (re)indexing our menus (on Leopard and
 34535:   // higher).  This stops the Help menu from being able to search in our
 34535:   // menus, but it also resolves many other problems.
 34535:   if (nsMenuX::sIndexingMenuLevel > 0)
 34535:     return;
 34535: 
 31545:   mGeckoMenu->MenuClosed();
 31545: }
 31545: 
     1: @end
 13630: 
 13630: // OS X Leopard (at least as of 10.5.2) has an obscure bug triggered by some
 13630: // behavior that's present in Mozilla.org browsers but not (as best I can
 13630: // tell) in Apple products like Safari.  (It's not yet clear exactly what this
 13630: // behavior is.)
 13630: //
 13630: // The bug is that sometimes you crash on quit in nsMenuX::RemoveAll(), on a
 13630: // call to [NSMenu removeItemAtIndex:].  The crash is caused by trying to
 13630: // access a deleted NSMenuItem object (sometimes (perhaps always?) by trying
 13630: // to send it a _setChangedFlags: message).  Though this object was deleted
 13630: // some time ago, it remains registered as a potential target for a particular
 13630: // key equivalent.  So when [NSMenu removeItemAtIndex:] removes the current
 13630: // target for that same key equivalent, the OS tries to "activate" the
 13630: // previous target.
 13630: //
 13630: // The underlying reason appears to be that NSMenu's _addItem:toTable: and
 13630: // _removeItem:fromTable: methods (which are used to keep a hashtable of
 13630: // registered key equivalents) don't properly "retain" and "release"
 13630: // NSMenuItem objects as they are added to and removed from the hashtable.
 13630: //
 13630: // Our (hackish) workaround is to shadow the OS's hashtable with another
 13630: // hastable of our own (gShadowKeyEquivDB), and use it to "retain" and
 13630: // "release" NSMenuItem objects as needed.  This resolves bmo bugs 422287 and
 13630: // 423669.  When (if) Apple fixes this bug, we can remove this workaround.
 13630: 
 13630: static NSMutableDictionary *gShadowKeyEquivDB = nil;
 13630: 
 13630: // Class for values in gShadowKeyEquivDB.
 13630: 
 13630: @interface KeyEquivDBItem : NSObject
 13630: {
 13630:   NSMenuItem *mItem;
 14897:   NSMutableSet *mTables;
 13630: }
 13630: 
 13630: - (id)initWithItem:(NSMenuItem *)aItem table:(NSMapTable *)aTable;
 13630: - (BOOL)hasTable:(NSMapTable *)aTable;
 13630: - (int)addTable:(NSMapTable *)aTable;
 13630: - (int)removeTable:(NSMapTable *)aTable;
 13630: 
 13630: @end
 13630: 
 13630: @implementation KeyEquivDBItem
 13630: 
 13630: - (id)initWithItem:(NSMenuItem *)aItem table:(NSMapTable *)aTable
 13630: {
 14897:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 14897:   
 13630:   if (!gShadowKeyEquivDB)
 13630:     gShadowKeyEquivDB = [[NSMutableDictionary alloc] init];
 13630:   self = [super init];
 13630:   if (aItem && aTable) {
 14897:     mTables = [[NSMutableSet alloc] init];
 13630:     mItem = [aItem retain];
 14897:     [mTables addObject:[NSValue valueWithPointer:aTable]];
 13630:   } else {
 13630:     mTables = nil;
 13630:     mItem = nil;
 13630:   }
 13630:   return self;
 14897: 
 14897:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
 13630: }
 13630: 
 13630: - (void)dealloc
 13630: {
 14897:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 14897: 
 13630:   if (mTables)
 13630:     [mTables release];
 13630:   if (mItem)
 13630:     [mItem release];
 13630:   [super dealloc];
 14897: 
 14897:   NS_OBJC_END_TRY_ABORT_BLOCK;
 13630: }
 13630: 
 13630: - (BOOL)hasTable:(NSMapTable *)aTable
 13630: {
 14897:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 14897: 
 14897:   return [mTables member:[NSValue valueWithPointer:aTable]] ? YES : NO;
 14897: 
 14897:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NO);
 13630: }
 13630: 
 13630: // Does nothing if aTable (its index value) is already present in mTables.
 13630: - (int)addTable:(NSMapTable *)aTable
 13630: {
 14897:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 14897: 
 13630:   if (aTable)
 14897:     [mTables addObject:[NSValue valueWithPointer:aTable]];
 13630:   return [mTables count];
 14897: 
 14897:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0);
 13630: }
 13630: 
 13630: - (int)removeTable:(NSMapTable *)aTable
 13630: {
 14897:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 14897: 
 14897:   if (aTable) {
 14897:     NSValue *objectToRemove =
 14897:       [mTables member:[NSValue valueWithPointer:aTable]];
 14897:     if (objectToRemove)
 14897:       [mTables removeObject:objectToRemove];
 14897:   }
 13630:   return [mTables count];
 14897: 
 14897:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(0);
 13630: }
 13630: 
 13630: @end
 13630: 
 13630: @interface NSMenu (MethodSwizzling)
 13630: + (void)nsMenuX_NSMenu_addItem:(NSMenuItem *)aItem toTable:(NSMapTable *)aTable;
 13630: + (void)nsMenuX_NSMenu_removeItem:(NSMenuItem *)aItem fromTable:(NSMapTable *)aTable;
 13630: @end
 13630: 
 13630: @implementation NSMenu (MethodSwizzling)
 13630: 
 13630: + (void)nsMenuX_NSMenu_addItem:(NSMenuItem *)aItem toTable:(NSMapTable *)aTable
 13630: {
 14897:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 14897: 
 13630:   if (aItem && aTable) {
 14897:     NSValue *key = [NSValue valueWithPointer:aItem];
 14897:     KeyEquivDBItem *shadowItem = [gShadowKeyEquivDB objectForKey:key];
 13630:     if (shadowItem) {
 13630:       [shadowItem addTable:aTable];
 13630:     } else {
 13630:       shadowItem = [[KeyEquivDBItem alloc] initWithItem:aItem table:aTable];
 14897:       [gShadowKeyEquivDB setObject:shadowItem forKey:key];
 13630:       // Release after [NSMutableDictionary setObject:forKey:] retains it (so
 13630:       // that it will get dealloced when removeObjectForKey: is called).
 13630:       [shadowItem release];
 13630:     }
 13630:   }
 14897: 
 14897:   NS_OBJC_END_TRY_ABORT_BLOCK;
 14897: 
 13630:   [self nsMenuX_NSMenu_addItem:aItem toTable:aTable];
 13630: }
 13630: 
 13630: + (void)nsMenuX_NSMenu_removeItem:(NSMenuItem *)aItem fromTable:(NSMapTable *)aTable
 13630: {
 13630:   [self nsMenuX_NSMenu_removeItem:aItem fromTable:aTable];
 14897: 
 14897:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 14897: 
 13630:   if (aItem && aTable) {
 14897:     NSValue *key = [NSValue valueWithPointer:aItem];
 14897:     KeyEquivDBItem *shadowItem = [gShadowKeyEquivDB objectForKey:key];
 13630:     if (shadowItem && [shadowItem hasTable:aTable]) {
 13630:       if (![shadowItem removeTable:aTable])
 14897:         [gShadowKeyEquivDB removeObjectForKey:key];
 13630:     }
 13630:   }
 14897: 
 14897:   NS_OBJC_END_TRY_ABORT_BLOCK;
 13630: }
 13630: 
 13630: @end
 14663: 
 14663: // This class is needed to keep track of when the OS is (re)indexing all of
 14663: // our menus.  This appears to only happen on Leopard and higher, and can
 14663: // be triggered by opening the Help menu.  Some operations are unsafe while
 14663: // this is happening -- notably the calls to [[NSImage alloc]
 14663: // initWithSize:imageRect.size] and [newImage lockFocus] in nsMenuItemIconX::
 14663: // OnStopFrame().  But we don't yet have a complete list, and Apple doesn't
 14663: // yet have any documentation on this subject.  (Apple also doesn't yet have
 14663: // any documented way to find the information we seek here.)  The "original"
 14663: // of this class (the one whose indexMenuBarDynamically method we hook) is
 14663: // defined in the Shortcut framework in /System/Library/PrivateFrameworks.
 14663: @interface NSObject (SCTGRLIndexMethodSwizzling)
 14663: - (void)nsMenuX_SCTGRLIndex_indexMenuBarDynamically;
 14663: @end
 14663: 
 14663: @implementation NSObject (SCTGRLIndexMethodSwizzling)
 14663: 
 14663: - (void)nsMenuX_SCTGRLIndex_indexMenuBarDynamically
 14663: {
 14663:   // This method appears to be called (once) whenever the OS (re)indexes our
108991:   // menus.  sIndexingMenuLevel is a int32_t just in case it might be
 14663:   // reentered.  As it's running, it spawns calls to two undocumented
 14663:   // HIToolbox methods (_SimulateMenuOpening() and _SimulateMenuClosed()),
 14663:   // which "simulate" the opening and closing of our menus without actually
 14663:   // displaying them.
 14663:   ++nsMenuX::sIndexingMenuLevel;
 14663:   [self nsMenuX_SCTGRLIndex_indexMenuBarDynamically];
 14663:   --nsMenuX::sIndexingMenuLevel;
 14663: }
 14663: 
 14663: @end
