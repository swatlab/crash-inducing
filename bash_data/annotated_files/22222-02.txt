    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for all element classes; this provides an implementation
    1:  * of DOM Core's nsIDOMElement, implements nsIContent, provides
    1:  * utility methods for subclasses, and so forth.
    1:  */
    1: 
    1: #ifndef nsGenericElement_h___
    1: #define nsGenericElement_h___
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsIContent.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMDocumentFragment.h"
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOM3EventTarget.h"
    1: #include "nsIDOM3Node.h"
    1: #include "nsIDOMNSEventTarget.h"
    1: #include "nsIDOMNSElement.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsContentUtils.h"
    1: #include "nsNodeUtils.h"
    1: #include "nsAttrAndChildArray.h"
    1: #include "mozFlushType.h"
    1: #include "nsDOMAttributeMap.h"
    1: #include "nsIWeakReference.h"
    1: #include "nsCycleCollectionParticipant.h"
13098: #include "nsIDocument.h"
16106: #include "nsIDOMNodeSelector.h"
    1: 
    1: class nsIDOMAttr;
    1: class nsIDOMEventListener;
    1: class nsIFrame;
    1: class nsIDOMNamedNodeMap;
    1: class nsDOMCSSDeclaration;
    1: class nsIDOMCSSStyleDeclaration;
    1: class nsIURI;
    1: class nsVoidArray;
    1: class nsINodeInfo;
    1: class nsIControllers;
    1: class nsIDOMNSFeatureFactory;
    1: class nsIEventListenerManager;
16722: class nsIScrollableView;
17074: class nsContentList;
16722: struct nsRect;
    1: 
    1: typedef unsigned long PtrBits;
    1: 
    1: /**
    1:  * Class that implements the nsIDOMNodeList interface (a list of children of
    1:  * the content), by holding a reference to the content and delegating GetLength
    1:  * and Item to its existing child list.
    1:  * @see nsIDOMNodeList
    1:  */
21618: class nsChildContentList : public nsINodeList,
21618:                            public nsWrapperCache
    1: {
    1: public:
    1:   nsChildContentList(nsINode* aNode)
    1:     : mNode(aNode)
    1:   {
    1:   }
20752: 
20752:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIDOMNodeList interface
20752:   NS_DECL_NSIDOMNODELIST
19130: 
19130:   // nsINodeList interface
19130:   virtual nsINode* GetNodeAt(PRUint32 aIndex);  
    1:   
    1:   void DropReference()
    1:   {
    1:     mNode = nsnull;
    1:   }
    1: 
21618:   nsISupports* GetParentObject()
21618:   {
21618:     return mNode;
21618:   }
21618: 
21618:   static nsChildContentList* FromSupports(nsISupports* aSupports)
21618:   {
21618:     nsINodeList* list = static_cast<nsINodeList*>(aSupports);
21618: #ifdef DEBUG
21618:     {
21618:       nsCOMPtr<nsINodeList> list_qi = do_QueryInterface(aSupports);
21618: 
21618:       // If this assertion fires the QI implementation for the object in
21618:       // question doesn't use the nsINodeList pointer as the nsISupports
21618:       // pointer. That must be fixed, or we'll crash...
21618:       NS_ASSERTION(list_qi == list, "Uh, fix QI!");
21618:     }
21618: #endif
21618:     return static_cast<nsChildContentList*>(list);
21618:   }
21618: 
    1: private:
    1:   // The node whose children make up the list (weak reference)
    1:   nsINode* mNode;
    1: };
    1: 
    1: /**
    1:  * A tearoff class for nsGenericElement to implement additional interfaces
    1:  */
    1: class nsNode3Tearoff : public nsIDOM3Node
    1: {
    1: public:
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   NS_DECL_NSIDOM3NODE
    1: 
    1:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNode3Tearoff)
    1: 
    1:   nsNode3Tearoff(nsIContent *aContent) : mContent(aContent)
    1:   {
    1:   }
    1: 
    1:   /**
    1:    * Determines whether two nodes are equal.
    1:    *
    1:    * @param aContent1 The first node to compare.
    1:    * @param aContent2 The second node to compare.
    1:    *
    1:    * @return PR_TRUE if the nodes are equal.
    1:    */
    1:   static PRBool AreNodesEqual(nsIContent* aContent1,
    1:                               nsIContent* aContent2);
    1: 
    1: protected:
  731:   virtual ~nsNode3Tearoff() {}
    1: 
    1: private:
    1:   nsCOMPtr<nsIContent> mContent;
    1: };
    1: 
    1: /**
    1:  * A class that implements nsIWeakReference
    1:  */
    1: 
    1: class nsNodeWeakReference : public nsIWeakReference
    1: {
    1: public:
    1:   nsNodeWeakReference(nsINode* aNode)
    1:     : mNode(aNode)
    1:   {
    1:   }
    1: 
    1:   ~nsNodeWeakReference();
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   // nsIWeakReference
    1:   NS_DECL_NSIWEAKREFERENCE
    1: 
    1:   void NoticeNodeDestruction()
    1:   {
    1:     mNode = nsnull;
    1:   }
    1: 
    1: private:
    1:   nsINode* mNode;
    1: };
    1: 
    1: /**
    1:  * Tearoff to use for nodes to implement nsISupportsWeakReference
    1:  */
    1: class nsNodeSupportsWeakRefTearoff : public nsISupportsWeakReference
    1: {
    1: public:
    1:   nsNodeSupportsWeakRefTearoff(nsINode* aNode)
    1:     : mNode(aNode)
    1:   {
    1:   }
    1: 
    1:   // nsISupports
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   // nsISupportsWeakReference
    1:   NS_DECL_NSISUPPORTSWEAKREFERENCE
    1: 
    1:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNodeSupportsWeakRefTearoff)
    1: 
    1: private:
    1:   nsCOMPtr<nsINode> mNode;
    1: };
    1: 
    1: #define NS_EVENT_TEAROFF_CACHE_SIZE 4
    1: 
    1: /**
    1:  * nsDOMEventRTTearoff is a tearoff class used by nsGenericElement and
    1:  * nsGenericDOMDataNode classes for implementing the interfaces
 1475:  * nsIDOMEventTarget, nsIDOM3EventTarget and nsIDOMNSEventTarget.
    1:  *
    1:  * Use the method nsDOMEventRTTearoff::Create() to create one of these babies.
    1:  * @see nsDOMEventRTTearoff::Create
    1:  */
    1: 
 1418: class nsDOMEventRTTearoff : public nsIDOMEventTarget,
    1:                             public nsIDOM3EventTarget,
    1:                             public nsIDOMNSEventTarget
    1: {
    1: private:
    1:   // This class uses a caching scheme so we don't let users of this
    1:   // class create new instances with 'new', in stead the callers
    1:   // should use the static method
    1:   // nsDOMEventRTTearoff::Create(). That's why the constructor and
    1:   // destrucor of this class is private.
    1: 
    1:   nsDOMEventRTTearoff(nsIContent *aContent);
    1: 
    1:   static nsDOMEventRTTearoff *mCachedEventTearoff[NS_EVENT_TEAROFF_CACHE_SIZE];
    1:   static PRUint32 mCachedEventTearoffCount;
    1: 
    1:   /**
    1:    * This method gets called by Release() when it's time to delete the
    1:    * this object, in stead of always deleting the object we'll put the
    1:    * object in the cache if unless the cache is already full.
    1:    */
    1:   void LastRelease();
    1: 
    1:   nsresult GetDOM3EventTarget(nsIDOM3EventTarget **aTarget);
    1: 
    1: public:
    1:   virtual ~nsDOMEventRTTearoff();
    1: 
    1:   /**
    1:    * Use this static method to create instances of nsDOMEventRTTearoff.
    1:    * @param aContent the content to create a tearoff for
    1:    */
    1:   static nsDOMEventRTTearoff *Create(nsIContent *aContent);
    1: 
    1:   /**
    1:    * Call before shutdown to clear the cache and free memory for this class.
    1:    */
    1:   static void Shutdown();
    1: 
    1:   // nsISupports
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   // nsIDOMEventTarget
    1:   NS_DECL_NSIDOMEVENTTARGET
    1: 
    1:   // nsIDOM3EventTarget
    1:   NS_DECL_NSIDOM3EVENTTARGET
    1: 
    1:   // nsIDOMNSEventTarget
    1:   NS_DECL_NSIDOMNSEVENTTARGET
    1: 
    1:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsDOMEventRTTearoff,
    1:                                            nsIDOMEventTarget)
    1: 
    1: private:
    1:   /**
    1:    * Strong reference back to the content object from where an instance of this
    1:    * class was 'torn off'
    1:    */
    1:   nsCOMPtr<nsIContent> mContent;
    1: };
    1: 
    1: /**
16106:  * A tearoff class for nsGenericElement to implement NodeSelector
16106:  */
16106: class nsNodeSelectorTearoff : public nsIDOMNodeSelector
16106: {
16106: public:
16106:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
16106: 
16106:   NS_DECL_NSIDOMNODESELECTOR
16106: 
16106:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNodeSelectorTearoff)
16106: 
16106:   nsNodeSelectorTearoff(nsIContent *aContent) : mContent(aContent)
16106:   {
16106:   }
16106: 
16106: private:
16106:   ~nsNodeSelectorTearoff() {}
16106: 
16106: private:
16106:   nsCOMPtr<nsIContent> mContent;
16106: };
16106: 
17074: // Forward declare to allow being a friend
17074: class nsNSElementTearoff;
17074: 
    1: /**
    1:  * A generic base class for DOM elements, implementing many nsIContent,
    1:  * nsIDOMNode and nsIDOMElement methods.
    1:  */
    1: class nsGenericElement : public nsIContent
    1: {
    1: public:
    1:   nsGenericElement(nsINodeInfo *aNodeInfo);
    1:   virtual ~nsGenericElement();
    1: 
16722:   friend class nsNSElementTearoff;
16722: 
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
    1:   /**
    1:    * Called during QueryInterface to give the binding manager a chance to
    1:    * get an interface for this element.
    1:    */
    1:   nsresult PostQueryInterface(REFNSIID aIID, void** aInstancePtr);
    1: 
    1:   // nsINode interface methods
    1:   virtual PRUint32 GetChildCount() const;
    1:   virtual nsIContent *GetChildAt(PRUint32 aIndex) const;
15810:   virtual nsIContent * const * GetChildArray() const;
    1:   virtual PRInt32 IndexOf(nsINode* aPossibleChild) const;
    1:   virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
    1:                                  PRBool aNotify);
    1:   virtual nsresult RemoveChildAt(PRUint32 aIndex, PRBool aNotify);
    1:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
    1:   virtual nsresult PostHandleEvent(nsEventChainPostVisitor& aVisitor);
    1:   virtual nsresult DispatchDOMEvent(nsEvent* aEvent, nsIDOMEvent* aDOMEvent,
    1:                                     nsPresContext* aPresContext,
    1:                                     nsEventStatus* aEventStatus);
 1418:   virtual nsresult GetListenerManager(PRBool aCreateIfNotFound,
    1:                                       nsIEventListenerManager** aResult);
 1418:   virtual nsresult AddEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                          const nsIID& aIID);
 1418:   virtual nsresult RemoveEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                             const nsIID& aIID);
 1418:   virtual nsresult GetSystemEventGroup(nsIDOMEventGroup** aGroup);
16056:   virtual nsresult GetContextForEventHandlers(nsIScriptContext** aContext)
16056:   {
16056:     return nsContentUtils::GetContextForEventHandlers(this, aContext);
16056:   }
    1: 
    1:   // nsIContent interface methods
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers);
    1:   virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
    1:                               PRBool aNullParent = PR_TRUE);
 4036:   virtual nsIAtom *GetIDAttributeName() const;
    1:   virtual nsIAtom *GetClassAttributeName() const;
    1:   virtual already_AddRefed<nsINodeInfo> GetExistingAttrNameFromQName(const nsAString& aStr) const;
    1:   nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                    const nsAString& aValue, PRBool aNotify)
    1:   {
    1:     return SetAttr(aNameSpaceID, aName, nsnull, aValue, aNotify);
    1:   }
    1:   virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName, nsIAtom* aPrefix,
    1:                            const nsAString& aValue, PRBool aNotify);
    1:   virtual PRBool GetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                          nsAString& aResult) const;
    1:   virtual PRBool HasAttr(PRInt32 aNameSpaceID, nsIAtom* aName) const;
    1:   virtual PRBool AttrValueIs(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                              const nsAString& aValue,
    1:                              nsCaseTreatment aCaseSensitive) const;
    1:   virtual PRBool AttrValueIs(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                              nsIAtom* aValue,
    1:                              nsCaseTreatment aCaseSensitive) const;
    1:   virtual PRInt32 FindAttrValueIn(PRInt32 aNameSpaceID,
    1:                                   nsIAtom* aName,
    1:                                   AttrValuesArray* aValues,
    1:                                   nsCaseTreatment aCaseSensitive) const;
    1:   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
    1:                              PRBool aNotify);
    1:   virtual const nsAttrName* GetAttrNameAt(PRUint32 aIndex) const;
    1:   virtual PRUint32 GetAttrCount() const;
    1:   virtual const nsTextFragment *GetText();
    1:   virtual PRUint32 TextLength();
    1:   virtual nsresult SetText(const PRUnichar* aBuffer, PRUint32 aLength,
    1:                            PRBool aNotify);
    1:   // Need to implement this here too to avoid hiding.
    1:   nsresult SetText(const nsAString& aStr, PRBool aNotify)
    1:   {
    1:     return SetText(aStr.BeginReading(), aStr.Length(), aNotify);
    1:   }
    1:   virtual nsresult AppendText(const PRUnichar* aBuffer, PRUint32 aLength,
    1:                               PRBool aNotify);
    1:   virtual PRBool TextIsOnlyWhitespace();
    1:   virtual void AppendTextTo(nsAString& aResult);
    1:   virtual void SetFocus(nsPresContext* aContext);
    1:   virtual nsIContent *GetBindingParent() const;
    1:   virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
    1:   virtual already_AddRefed<nsIURI> GetBaseURI() const;
    1:   virtual PRBool IsLink(nsIURI** aURI) const;
    1:   virtual void SetMayHaveFrame(PRBool aMayHaveFrame);
    1:   virtual PRBool MayHaveFrame() const;
    1: 
    1:   virtual PRUint32 GetScriptTypeID() const;
    1:   virtual nsresult SetScriptTypeID(PRUint32 aLang);
    1: 
 8462:   virtual void DestroyContent();
14188:   virtual void SaveSubtreeState();
14188: 
    1: #ifdef DEBUG
    1:   virtual void List(FILE* out, PRInt32 aIndent) const
    1:   {
    1:     List(out, aIndent, EmptyCString());
    1:   }
    1:   virtual void DumpContent(FILE* out, PRInt32 aIndent, PRBool aDumpAll) const;
    1:   void List(FILE* out, PRInt32 aIndent, const nsCString& aPrefix) const;
    1:   void ListAttributes(FILE* out) const;
    1: #endif
    1: 
    1:   virtual nsIAtom* GetID() const;
19132:   virtual const nsAttrValue* DoGetClasses() const;
    1:   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
    1:   virtual nsICSSStyleRule* GetInlineStyleRule();
    1:   NS_IMETHOD SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify);
    1:   NS_IMETHOD_(PRBool)
    1:     IsAttributeMapped(const nsIAtom* aAttribute) const;
    1:   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute, 
    1:                                               PRInt32 aModType) const;
    1:   /*
    1:    * Attribute Mapping Helpers
    1:    */
    1:   struct MappedAttributeEntry {
    1:     nsIAtom** attribute;
    1:   };
    1:   
    1:   /**
    1:    * A common method where you can just pass in a list of maps to check
    1:    * for attribute dependence. Most implementations of
    1:    * IsAttributeMapped should use this function as a default
    1:    * handler.
    1:    */
    1:   static PRBool
    1:   FindAttributeDependence(const nsIAtom* aAttribute,
    1:                           const MappedAttributeEntry* const aMaps[],
    1:                           PRUint32 aMapCount);
    1: 
    1:   // nsIDOMNode method implementation
    1:   NS_IMETHOD GetNodeName(nsAString& aNodeName);
    1:   NS_IMETHOD GetLocalName(nsAString& aLocalName);
    1:   NS_IMETHOD GetNodeValue(nsAString& aNodeValue);
    1:   NS_IMETHOD SetNodeValue(const nsAString& aNodeValue);
    1:   NS_IMETHOD GetNodeType(PRUint16* aNodeType);
    1:   NS_IMETHOD GetParentNode(nsIDOMNode** aParentNode);
    1:   NS_IMETHOD GetAttributes(nsIDOMNamedNodeMap** aAttributes);
    1:   NS_IMETHOD GetPreviousSibling(nsIDOMNode** aPreviousSibling);
    1:   NS_IMETHOD GetNextSibling(nsIDOMNode** aNextSibling);
    1:   NS_IMETHOD GetOwnerDocument(nsIDOMDocument** aOwnerDocument);
    1:   NS_IMETHOD GetNamespaceURI(nsAString& aNamespaceURI);
    1:   NS_IMETHOD GetPrefix(nsAString& aPrefix);
    1:   NS_IMETHOD SetPrefix(const nsAString& aPrefix);
    1:   NS_IMETHOD Normalize();
    1:   NS_IMETHOD IsSupported(const nsAString& aFeature,
    1:                          const nsAString& aVersion, PRBool* aReturn);
    1:   NS_IMETHOD HasAttributes(PRBool* aHasAttributes);
    1:   NS_IMETHOD GetChildNodes(nsIDOMNodeList** aChildNodes);
    1:   NS_IMETHOD HasChildNodes(PRBool* aHasChildNodes);
    1:   NS_IMETHOD GetFirstChild(nsIDOMNode** aFirstChild);
    1:   NS_IMETHOD GetLastChild(nsIDOMNode** aLastChild);
    1:   NS_IMETHOD InsertBefore(nsIDOMNode* aNewChild, nsIDOMNode* aRefChild,
    1:                           nsIDOMNode** aReturn);
    1:   NS_IMETHOD ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,
    1:                           nsIDOMNode** aReturn);
    1:   NS_IMETHOD RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn);
    1:   NS_IMETHOD AppendChild(nsIDOMNode* aNewChild, nsIDOMNode** aReturn)
    1:   {
    1:     return InsertBefore(aNewChild, nsnull, aReturn);
    1:   }
    1: 
    1:   // nsIDOMElement method implementation
    1:   NS_IMETHOD GetTagName(nsAString& aTagName);
    1:   NS_IMETHOD GetAttribute(const nsAString& aName,
    1:                           nsAString& aReturn);
    1:   NS_IMETHOD SetAttribute(const nsAString& aName,
    1:                           const nsAString& aValue);
    1:   NS_IMETHOD RemoveAttribute(const nsAString& aName);
    1:   NS_IMETHOD GetAttributeNode(const nsAString& aName,
    1:                               nsIDOMAttr** aReturn);
    1:   NS_IMETHOD SetAttributeNode(nsIDOMAttr* aNewAttr, nsIDOMAttr** aReturn);
    1:   NS_IMETHOD RemoveAttributeNode(nsIDOMAttr* aOldAttr, nsIDOMAttr** aReturn);
    1:   NS_IMETHOD GetElementsByTagName(const nsAString& aTagname,
    1:                                   nsIDOMNodeList** aReturn);
    1:   NS_IMETHOD GetAttributeNS(const nsAString& aNamespaceURI,
    1:                             const nsAString& aLocalName,
    1:                             nsAString& aReturn);
    1:   NS_IMETHOD SetAttributeNS(const nsAString& aNamespaceURI,
    1:                             const nsAString& aQualifiedName,
    1:                             const nsAString& aValue);
    1:   NS_IMETHOD RemoveAttributeNS(const nsAString& aNamespaceURI,
    1:                                const nsAString& aLocalName);
    1:   NS_IMETHOD GetAttributeNodeNS(const nsAString& aNamespaceURI,
    1:                                 const nsAString& aLocalName,
    1:                                 nsIDOMAttr** aReturn);
    1:   NS_IMETHOD SetAttributeNodeNS(nsIDOMAttr* aNewAttr, nsIDOMAttr** aReturn);
    1:   NS_IMETHOD GetElementsByTagNameNS(const nsAString& aNamespaceURI,
    1:                                     const nsAString& aLocalName,
    1:                                     nsIDOMNodeList** aReturn);
    1:   NS_IMETHOD HasAttribute(const nsAString& aName, PRBool* aReturn);
    1:   NS_IMETHOD HasAttributeNS(const nsAString& aNamespaceURI,
    1:                             const nsAString& aLocalName,
    1:                             PRBool* aReturn);
    1:   nsresult CloneNode(PRBool aDeep, nsIDOMNode **aResult)
    1:   {
    1:     return nsNodeUtils::CloneNodeImpl(this, aDeep, aResult);
    1:   }
    1: 
    1:   //----------------------------------------
    1: 
    1:   /**
    1:    * Add a script event listener with the given event handler name
    1:    * (like onclick) and with the value as JS   
    1:    * @param aEventName the event listener name
    1:    * @param aValue the JS to attach
    1:    * @param aDefer indicates if deferred execution is allowed
    1:    */
    1:   nsresult AddScriptEventListener(nsIAtom* aEventName,
    1:                                   const nsAString& aValue,
    1:                                   PRBool aDefer = PR_TRUE);
    1: 
    1:   /**
    1:    * Do whatever needs to be done when the mouse leaves a link
    1:    */
    1:   nsresult LeaveLink(nsPresContext* aPresContext);
    1: 
    1:   /**
    1:    * Take two text nodes and append the second to the first.
    1:    * @param aFirst the node which will contain first + second [INOUT]
    1:    * @param aSecond the node which will be appended
    1:    */
    1:   nsresult JoinTextNodes(nsIContent* aFirst,
    1:                          nsIContent* aSecond);
    1: 
    1:   /**
    1:    * Check whether a spec feature/version is supported.
    1:    * @param aObject the object, which should support the feature,
    1:    *        for example nsIDOMNode or nsIDOMDOMImplementation
    1:    * @param aFeature the feature ("Views", "Core", "HTML", "Range" ...)
    1:    * @param aVersion the version ("1.0", "2.0", ...)
    1:    * @param aReturn whether the feature is supported or not [OUT]
    1:    */
    1:   static nsresult InternalIsSupported(nsISupports* aObject,
    1:                                       const nsAString& aFeature,
    1:                                       const nsAString& aVersion,
    1:                                       PRBool* aReturn);
    1: 
    1:   static nsresult InternalGetFeature(nsISupports* aObject,
    1:                                      const nsAString& aFeature,
    1:                                      const nsAString& aVersion,
    1:                                      nsISupports** aReturn);
    1:   
    1:   static already_AddRefed<nsIDOMNSFeatureFactory>
    1:     GetDOMFeatureFactory(const nsAString& aFeature, const nsAString& aVersion);
    1: 
    1:   static PRBool ShouldFocus(nsIContent *aContent);
    1: 
    1:   static PRBool ShouldBlur(nsIContent *aContent);
    1: 
    1:   /**
    1:    * Actual implementation of the DOM InsertBefore and ReplaceChild methods.
    1:    * Shared by nsDocument. When called from nsDocument, aParent will be null.
    1:    *
    1:    * @param aReplace  True if aNewChild should replace aRefChild. False if
    1:    *                  aNewChild should be inserted before aRefChild.
    1:    * @param aNewChild The child to insert
    1:    * @param aRefChild The child to insert before or replace
    1:    * @param aParent The parent to use for the new child
    1:    * @param aDocument The document to use for the new child.
    1:    *                  Must be non-null, if aParent is null and must match
    1:    *                  aParent->GetCurrentDoc() if aParent is not null.
    1:    * @param aReturn [out] the child we insert
    1:    */
    1:   static nsresult doReplaceOrInsertBefore(PRBool aReplace, nsIDOMNode* aNewChild, nsIDOMNode* aRefChild,
    1:                                           nsIContent* aParent, nsIDocument* aDocument,
    1:                                           nsIDOMNode** aReturn);
    1: 
    1:   /**
    1:    * Actual implementation of the DOM RemoveChild method.  Shared by
    1:    * nsDocument.  When called from nsDocument, aParent will be null.
    1:    *
    1:    * @param aOldChild The child to remove
    1:    * @param aParent The parent to use for the new child
    1:    * @param aDocument The document to use for the new child.
    1:    *                  Must be non-null if aParent is null and must match
    1:    *                  aParent->GetCurrentDoc() if aParent is not null.
    1:    * @param aReturn [out] the child we remove
    1:    */
    1:   static nsresult doRemoveChild(nsIDOMNode* aOldChild,
    1:                                 nsIContent* aParent, nsIDocument* aDocument,
    1:                                 nsIDOMNode** aReturn);
    1: 
    1:   /**
    1:    * Most of the implementation of the nsINode InsertChildAt method.  Shared by
    1:    * nsDocument.  When called from nsDocument, aParent will be null.
    1:    *
    1:    * @param aKid The child to insert.
    1:    * @param aIndex The index to insert at.
    1:    * @param aNotify Whether to notify.
    1:    * @param aParent The parent to use for the new child.
    1:    * @param aDocument The document to use for the notifications.  Must be
    1:    *                  non-null if aParent is null (in which case aKid is being
    1:    *                  inserted as its child) and must match
    1:    *                  aParent->GetCurrentDoc() if aParent is not null.
    1:    * @param aChildArray The child array to work with
    1:    */
    1:   static nsresult doInsertChildAt(nsIContent* aKid, PRUint32 aIndex,
    1:                                   PRBool aNotify, nsIContent* aParent,
    1:                                   nsIDocument* aDocument,
    1:                                   nsAttrAndChildArray& aChildArray);
    1: 
    1:   /**
    1:    * Most of the implementation of the nsINode RemoveChildAt method.  Shared by
    1:    * nsDocument.  When called from nsDocument, aParent will be null.
    1:    *
    1:    * @param aIndex The index to remove at.
    1:    * @param aNotify Whether to notify.
    1:    * @param aKid The kid at aIndex.  Must not be null.
    1:    * @param aParent The parent we're removing from.
    1:    * @param aDocument The document to use for the notifications.  Must be
    1:    *                  non-null if aParent is null (in which case aKid is being
    1:    *                  removed as its child) and must match
    1:    *                  aParent->GetCurrentDoc() if aParent is not null.
    1:    * @param aChildArray The child array to work with
    1:    */
    1:   static nsresult doRemoveChildAt(PRUint32 aIndex, PRBool aNotify,
    1:                                   nsIContent* aKid, nsIContent* aParent,
    1:                                   nsIDocument* aDocument,
    1:                                   nsAttrAndChildArray& aChildArray);
    1: 
    1:   /**
16106:    * Helper methods for implementing querySelector/querySelectorAll
16106:    */
16106:   static nsresult doQuerySelector(nsINode* aRoot, const nsAString& aSelector,
16106:                                   nsIDOMElement **aReturn);
16106:   static nsresult doQuerySelectorAll(nsINode* aRoot,
16106:                                      const nsAString& aSelector,
16106:                                      nsIDOMNodeList **aReturn);
16106: 
16106:   /**
    1:    * Default event prehandling for content objects. Handles event retargeting.
    1:    */
    1:   static nsresult doPreHandleEvent(nsIContent* aContent,
    1:                                    nsEventChainPreVisitor& aVisitor);
    1: 
    1:   /**
    1:    * Method to create and dispatch a left-click event loosely based on
    1:    * aSourceEvent. If aFullDispatch is true, the event will be dispatched
    1:    * through the full dispatching of the presshell of the aPresContext; if it's
    1:    * false the event will be dispatched only as a DOM event.
    1:    * If aPresContext is nsnull, this does nothing.
    1:    */
    1:   static nsresult DispatchClickEvent(nsPresContext* aPresContext,
    1:                                      nsInputEvent* aSourceEvent,
    1:                                      nsIContent* aTarget,
    1:                                      PRBool aFullDispatch,
    1:                                      nsEventStatus* aStatus);
    1:   
    1:   /**
    1:    * Method to dispatch aEvent to aTarget. If aFullDispatch is true, the event
    1:    * will be dispatched through the full dispatching of the presshell of the
    1:    * aPresContext; if it's false the event will be dispatched only as a DOM
    1:    * event.
    1:    * If aPresContext is nsnull, this does nothing.
    1:    */
    1:   static nsresult DispatchEvent(nsPresContext* aPresContext,
    1:                                 nsEvent* aEvent,
    1:                                 nsIContent* aTarget,
    1:                                 PRBool aFullDispatch,
    1:                                 nsEventStatus* aStatus);
    1: 
    1:   /**
    1:    * Get the primary frame for this content without flushing (see
    1:    * GetPrimaryFrameFor)
    1:    *
    1:    * @return the primary frame 
    1:    */
    1:   nsIFrame* GetPrimaryFrame();
    1: 
    1:   /**
    1:    * Get the primary frame for this content with flushing (see
    1:    * GetPrimaryFrameFor).
    1:    *
    1:    * @param aType the kind of flush to do, typically Flush_Frames or
    1:    *              Flush_Layout
    1:    * @return the primary frame
    1:    */
    1:   nsIFrame* GetPrimaryFrame(mozFlushType aType);
    1: 
    1:   /**
    1:    * Get the primary frame for a piece of content without flushing.
    1:    *
    1:    * @param aContent the content to get the primary frame for
    1:    * @param aDocument the document for this content
    1:    * @return the primary frame
    1:    */
    1:   static nsIFrame* GetPrimaryFrameFor(nsIContent* aContent,
    1:                                       nsIDocument* aDocument);
    1: 
    1:   /**
    1:    * Struct that stores info on an attribute.  The name and value must
    1:    * either both be null or both be non-null.
    1:    */
    1:   struct nsAttrInfo {
    1:     nsAttrInfo(const nsAttrName* aName, const nsAttrValue* aValue) :
    1:       mName(aName), mValue(aValue) {}
    1:     nsAttrInfo(const nsAttrInfo& aOther) :
    1:       mName(aOther.mName), mValue(aOther.mValue) {}
    1:       
    1:     const nsAttrName* mName;
    1:     const nsAttrValue* mValue;
    1:   };
    1: 
    1:   /**
    1:    * Returns the attribute map, if there is one.
    1:    *
    1:    * @return existing attribute map or nsnull.
    1:    */
    1:   nsDOMAttributeMap *GetAttributeMap()
    1:   {
    1:     nsDOMSlots *slots = GetExistingDOMSlots();
    1: 
    1:     return slots ? slots->mAttributeMap.get() : nsnull;
    1:   }
    1: 
    1:   virtual void RecompileScriptEventListeners()
    1:   {
    1:   }
    1: 
    1:   NS_DECL_CYCLE_COLLECTION_CLASS(nsGenericElement)
    1: 
    1: protected:
    1:   /**
    1:    * Set attribute and (if needed) notify documentobservers and fire off
    1:    * mutation events.
    1:    *
    1:    * @param aNamespaceID  namespace of attribute
    1:    * @param aAttribute    local-name of attribute
    1:    * @param aPrefix       aPrefix of attribute
    1:    * @param aOldValue     previous value of attribute. Only needed if
    1:    *                      aFireMutation is true.
    1:    * @param aParsedValue  parsed new value of attribute
    1:    * @param aModification is this a attribute-modification or addition. Only
    1:    *                      needed if aFireMutation or aNotify is true.
    1:    * @param aFireMutation should mutation-events be fired?
    1:    * @param aNotify       should we notify document-observers?
22222:    * @param aValueForAfterSetAttr If not null, AfterSetAttr will be called
22222:    *                      with the value pointed by this parameter.
    1:    */
    1:   nsresult SetAttrAndNotify(PRInt32 aNamespaceID,
    1:                             nsIAtom* aName,
    1:                             nsIAtom* aPrefix,
    1:                             const nsAString& aOldValue,
    1:                             nsAttrValue& aParsedValue,
    1:                             PRBool aModification,
    1:                             PRBool aFireMutation,
22222:                             PRBool aNotify,
22222:                             const nsAString* aValueForAfterSetAttr);
    1: 
    1:   /**
    1:    * Convert an attribute string value to attribute type based on the type of
    1:    * attribute.  Called by SetAttr().  Note that at the moment we only do this
    1:    * for attributes in the null namespace (kNameSpaceID_None).
    1:    *
    1:    * @param aNamespaceID the namespace of the attribute to convert
    1:    * @param aAttribute the attribute to convert
    1:    * @param aValue the string value to convert
    1:    * @param aResult the nsAttrValue [OUT]
    1:    * @return PR_TRUE if the parsing was successful, PR_FALSE otherwise
    1:    */
    1:   virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
    1:                                 nsIAtom* aAttribute,
    1:                                 const nsAString& aValue,
    1:                                 nsAttrValue& aResult);
    1: 
    1:   /**
    1:    * Try to set the attribute as a mapped attribute, if applicable.  This will
    1:    * only be called for attributes that are in the null namespace and only on
    1:    * attributes that returned true when passed to IsAttributeMapped.  The
    1:    * caller will not try to set the attr in any other way if this method
    1:    * returns PR_TRUE (the value of aRetval does not matter for that purpose).
    1:    *
    1:    * @param aDocument the current document of this node (an optimization)
    1:    * @param aName the name of the attribute
    1:    * @param aValue the nsAttrValue to set
    1:    * @param [out] aRetval the nsresult status of the operation, if any.
    1:    * @return PR_TRUE if the setting was attempted, PR_FALSE otherwise.
    1:    */
    1:   virtual PRBool SetMappedAttribute(nsIDocument* aDocument,
    1:                                     nsIAtom* aName,
    1:                                     nsAttrValue& aValue,
    1:                                     nsresult* aRetval);
    1: 
    1:   /**
    1:    * Hook that is called by nsGenericElement::SetAttr to allow subclasses to
    1:    * deal with attribute sets.  This will only be called after we verify that
    1:    * we're actually doing an attr set and will be called before ParseAttribute
    1:    * and hence before we've set the new value.
    1:    *
    1:    * @param aNamespaceID the namespace of the attr being set
    1:    * @param aName the localname of the attribute being set
    1:    * @param aValue the value it's being set to.  If null, the attr is being
    1:    *        removed.
    1:    * @param aNotify Whether we plan to notify document observers.
    1:    */
    1:   // Note that this is inlined so that when subclasses call it it gets
    1:   // inlined.  Those calls don't go through a vtable.
    1:   virtual nsresult BeforeSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                                  const nsAString* aValue, PRBool aNotify)
    1:   {
    1:     return NS_OK;
    1:   }
    1: 
    1:   /**
    1:    * Hook that is called by nsGenericElement::SetAttr to allow subclasses to
    1:    * deal with attribute sets.  This will only be called after we have called
    1:    * SetAndTakeAttr (that is, after we have actually set the attr).
    1:    *
    1:    * @param aNamespaceID the namespace of the attr being set
    1:    * @param aName the localname of the attribute being set
    1:    * @param aValue the value it's being set to.  If null, the attr is being
    1:    *        removed.
    1:    * @param aNotify Whether we plan to notify document observers.
    1:    */
    1:   // Note that this is inlined so that when subclasses call it it gets
    1:   // inlined.  Those calls don't go through a vtable.
    1:   virtual nsresult AfterSetAttr(PRInt32 aNamespaceID, nsIAtom* aName,
    1:                                 const nsAString* aValue, PRBool aNotify)
    1:   {
    1:     return NS_OK;
    1:   }
    1: 
    1:   /**
    1:    * Hook to allow subclasses to produce a different nsIEventListenerManager if
    1:    * needed for attachment of attribute-defined handlers
    1:    */
    1:   virtual nsresult
    1:     GetEventListenerManagerForAttr(nsIEventListenerManager** aManager,
    1:                                    nsISupports** aTarget,
    1:                                    PRBool* aDefer);
    1: 
    1:   /**
    1:    * Get the attr info for the given namespace ID and attribute name.  The
    1:    * namespace ID must not be kNameSpaceID_Unknown and the name must not be
    1:    * null.  Note that this can only return info on attributes that actually
    1:    * live on this element (and is only virtual to handle XUL prototypes).  That
    1:    * is, this should only be called from methods that only care about attrs
    1:    * that effectively live in mAttrsAndChildren.
    1:    */
    1:   virtual nsAttrInfo GetAttrInfo(PRInt32 aNamespaceID, nsIAtom* aName) const;
    1: 
    1:   /**
    1:    * Copy attributes and state to another element
    1:    * @param aDest the object to copy to
    1:    */
    1:   nsresult CopyInnerTo(nsGenericElement* aDest) const;
    1: 
    1:   /**
    1:    * Internal hook for converting an attribute name-string to an atomized name
    1:    */
    1:   virtual const nsAttrName* InternalGetExistingAttrNameFromQName(const nsAString& aStr) const;
    1: 
16722:   /**
16722:    * Retrieve the rectangle for the offsetX properties, which
16722:    * are coordinates relative to the returned aOffsetParent.
16722:    *
16722:    * @param aRect offset rectangle
16722:    * @param aOffsetParent offset parent
16722:    */
16722:   virtual void GetOffsetRect(nsRect& aRect, nsIContent** aOffsetParent);
16722: 
16722:   nsIFrame* GetStyledFrame();
16722: 
    1: public:
    1:   // Because of a bug in MS C++ compiler nsDOMSlots must be declared public,
    1:   // otherwise nsXULElement::nsXULSlots doesn't compile.
    1:   /**
    1:    * There are a set of DOM- and scripting-specific instance variables
    1:    * that may only be instantiated when a content object is accessed
    1:    * through the DOM. Rather than burn actual slots in the content
    1:    * objects for each of these instance variables, we put them off
    1:    * in a side structure that's only allocated when the content is
    1:    * accessed through the DOM.
    1:    */
    1:   class nsDOMSlots : public nsINode::nsSlots
    1:   {
    1:   public:
    1:     nsDOMSlots(PtrBits aFlags);
    1:     virtual ~nsDOMSlots();
    1: 
    1:     /**
    1:      * The .style attribute (an interface that forwards to the actual
    1:      * style rules)
    1:      * @see nsGenericHTMLElement::GetStyle */
    1:     nsRefPtr<nsDOMCSSDeclaration> mStyle;
    1: 
    1:     /**
    1:      * An object implementing nsIDOMNamedNodeMap for this content (attributes)
    1:      * @see nsGenericElement::GetAttributes
    1:      */
    1:     nsRefPtr<nsDOMAttributeMap> mAttributeMap;
    1: 
    1:     union {
    1:       /**
    1:       * The nearest enclosing content node with a binding that created us.
    1:       * @see nsGenericElement::GetBindingParent
    1:       */
    1:       nsIContent* mBindingParent;  // [Weak]
    1: 
    1:       /**
    1:       * The controllers of the XUL Element.
    1:       */
    1:       nsIControllers* mControllers; // [OWNER]
    1:     };
    1:     
    1:     /**
    1:      * Weak reference to this node
    1:      */
    1:     nsNodeWeakReference* mWeakReference;
17074: 
17074:     /**
17074:      * An object implementing the .children property for this element.
17074:      */
17074:     nsRefPtr<nsContentList> mChildrenList;
    1:   };
    1: 
    1: protected:
    1:   // Override from nsINode
    1:   virtual nsINode::nsSlots* CreateSlots();
    1: 
    1:   nsDOMSlots *GetDOMSlots()
    1:   {
 3233:     return static_cast<nsDOMSlots*>(GetSlots());
    1:   }
    1: 
    1:   nsDOMSlots *GetExistingDOMSlots() const
    1:   {
 3233:     return static_cast<nsDOMSlots*>(GetExistingSlots());
    1:   }
    1: 
    1:   /**
    1:    * GetContentsAsText will take all the textnodes that are children
    1:    * of |this| and concatenate the text in them into aText.  It
    1:    * completely ignores any non-text-node children of |this|; in
    1:    * particular it does not descend into any children of |this| that
    1:    * happen to be container elements.
    1:    *
    1:    * @param aText the resulting text [OUT]
    1:    */
    1:   void GetContentsAsText(nsAString& aText);
    1: 
    1:   /**
  723:    * Functions to carry out event default actions for links of all types
    1:    * (HTML links, XLinks, SVG "XLinks", etc.)
    1:    */
  723: 
  723:   /**
  723:    * Check that we meet the conditions to handle a link event
  723:    * and that we are actually on a link.
  723:    *
  723:    * @param aVisitor event visitor
  723:    * @param aURI the uri of the link, set only if the return value is PR_TRUE [OUT]
  723:    * @return PR_TRUE if we can handle the link event, PR_FALSE otherwise
  723:    */
  723:   PRBool CheckHandleEventForLinksPrecondition(nsEventChainVisitor& aVisitor,
  723:                                               nsIURI** aURI) const;
  723: 
  723:   /**
  723:    * Handle status bar updates before they can be cancelled.
  723:    */
  723:   nsresult PreHandleEventForLinks(nsEventChainPreVisitor& aVisitor);
  723: 
  723:   /**
  723:    * Handle default actions for link event if the event isn't consumed yet.
  723:    */
    1:   nsresult PostHandleEventForLinks(nsEventChainPostVisitor& aVisitor);
    1: 
    1:   /**
    1:    * Get the target of this link element. Consumers should established that
    1:    * this element is a link (probably using IsLink) before calling this
    1:    * function (or else why call it?)
    1:    *
    1:    * Note: for HTML this gets the value of the 'target' attribute; for XLink
    1:    * this gets the value of the xlink:_moz_target attribute, or failing that,
    1:    * the value of xlink:show, converted to a suitably equivalent named target
    1:    * (e.g. _blank).
    1:    */
    1:   virtual void GetLinkTarget(nsAString& aTarget);
    1: 
    1:   /**
    1:    * Array containing all attributes and children for this element
    1:    */
    1:   nsAttrAndChildArray mAttrsAndChildren;
    1: };
    1: 
    1: /**
    1:  * Macros to implement Clone(). _elementName is the class for which to implement
    1:  * Clone.
    1:  */
    1: #define NS_IMPL_ELEMENT_CLONE(_elementName)                                 \
    1: nsresult                                                                    \
    1: _elementName::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const        \
    1: {                                                                           \
    1:   *aResult = nsnull;                                                        \
    1:                                                                             \
11169:   _elementName *it = new _elementName(aNodeInfo);                           \
    1:   if (!it) {                                                                \
    1:     return NS_ERROR_OUT_OF_MEMORY;                                          \
    1:   }                                                                         \
    1:                                                                             \
    1:   nsCOMPtr<nsINode> kungFuDeathGrip = it;                                   \
    1:   nsresult rv = CopyInnerTo(it);                                            \
    1:   if (NS_SUCCEEDED(rv)) {                                                   \
    1:     kungFuDeathGrip.swap(*aResult);                                         \
    1:   }                                                                         \
    1:                                                                             \
    1:   return rv;                                                                \
    1: }
    1: 
    1: #define NS_IMPL_ELEMENT_CLONE_WITH_INIT(_elementName)                       \
    1: nsresult                                                                    \
    1: _elementName::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const        \
    1: {                                                                           \
    1:   *aResult = nsnull;                                                        \
    1:                                                                             \
11169:   _elementName *it = new _elementName(aNodeInfo);                           \
    1:   if (!it) {                                                                \
    1:     return NS_ERROR_OUT_OF_MEMORY;                                          \
    1:   }                                                                         \
    1:                                                                             \
    1:   nsCOMPtr<nsINode> kungFuDeathGrip = it;                                   \
    1:   nsresult rv = it->Init();                                                 \
    1:   rv |= CopyInnerTo(it);                                                    \
    1:   if (NS_SUCCEEDED(rv)) {                                                   \
    1:     kungFuDeathGrip.swap(*aResult);                                         \
    1:   }                                                                         \
    1:                                                                             \
    1:   return rv;                                                                \
    1: }
    1: 
 2014: /**
 2014:  * Yet another tearoff class for nsGenericElement
 2014:  * to implement additional interfaces
 2014:  */
 2014: class nsNSElementTearoff : public nsIDOMNSElement
 2014: {
 2014: public:
 5545:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 2014: 
 2014:   NS_DECL_NSIDOMNSELEMENT
 2014: 
 5545:   NS_DECL_CYCLE_COLLECTION_CLASS(nsNSElementTearoff)
 5545: 
 2014:   nsNSElementTearoff(nsGenericElement *aContent) : mContent(aContent)
 2014:   {
 2014:   }
 2014:   
 2014: private:
17074:   nsContentList* GetChildrenList();
17074: 
 2014:   nsRefPtr<nsGenericElement> mContent;
16722: 
16722:   /**
16722:    * Get this element's client area rect in app units.
16722:    * @return the frame's client area
16722:    */
16722:   nsRect GetClientAreaRect();
16722: 
16722: private:
16722: 
16722:   /**
16722:    * Get the element's styled frame (the primary frame or, for tables, the inner
16722:    * table frame) and closest scrollable view.
16722:    * @note This method flushes pending notifications (Flush_Layout).
16722:    * @param aScrollableView the scrollable view [OUT]
16722:    * @param aFrame (optional) the frame [OUT]
16722:    */
16722:   void GetScrollInfo(nsIScrollableView **aScrollableView,
16722:                      nsIFrame **aFrame = nsnull);
 2014: };
 2014: 
21218: #define NS_ELEMENT_INTERFACE_TABLE_TO_MAP_SEGUE                               \
21218:     rv = nsGenericElement::QueryInterface(aIID, aInstancePtr);                \
21218:     if (NS_SUCCEEDED(rv))                                                     \
21218:       return rv;                                                              \
21218:                                                                               \
21218:     NS_OFFSET_AND_INTERFACE_TABLE_TO_MAP_SEGUE
21218: 
21218: #define NS_ELEMENT_INTERFACE_MAP_END                                          \
21218:     {                                                                         \
21218:       return PostQueryInterface(aIID, aInstancePtr);                          \
21218:     }                                                                         \
21218:                                                                               \
21218:     NS_ADDREF(foundInterface);                                                \
21218:                                                                               \
21218:     *aInstancePtr = foundInterface;                                           \
21218:                                                                               \
21218:     return NS_OK;                                                             \
21218:   }
21218: 
    1: #endif /* nsGenericElement_h___ */
