107763: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
107763: /* vim:set ts=2 sw=2 sts=2 tw=80 et cindent: */
107763: /* This Source Code Form is subject to the terms of the Mozilla Public
107763:  * License, v. 2.0. If a copy of the MPL was not distributed with this
107763:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
107763: 
107763: #include "nsMediaSniffer.h"
107763: #include "nsMemory.h"
107763: #include "nsIHttpChannel.h"
111466: #include "nsString.h"
107763: #include "nsMimeTypes.h"
107763: #include "mozilla/ModuleUtils.h"
107763: 
107763: #include "nsIClassInfoImpl.h"
107763: 
107763: // The minimum number of bytes that are needed to attempt to sniff an mp4 file.
107763: static const unsigned MP4_MIN_BYTES_COUNT = 12;
107763: // The maximum number of bytes to consider when attempting to sniff a file.
111335: static const uint32_t MAX_BYTES_SNIFFED = 512;
107763: 
107763: NS_IMPL_ISUPPORTS1(nsMediaSniffer, nsIContentSniffer)
107763: 
107763: nsMediaSniffer::nsMediaSnifferEntry nsMediaSniffer::sSnifferEntries[] = {
107763:   // The string OggS, followed by the null byte.
107763:   PATTERN_ENTRY("\xFF\xFF\xFF\xFF\xFF", "OggS", APPLICATION_OGG),
107763:   // The string RIFF, followed by four bytes, followed by the string WAVE
107763:   PATTERN_ENTRY("\xFF\xFF\xFF\xFF\x00\x00\x00\x00\xFF\xFF\xFF\xFF", "RIFF\x00\x00\x00\x00WAVE", AUDIO_WAV),
107763:   // WebM
107763:   PATTERN_ENTRY("\xFF\xFF\xFF\xFF", "\x1A\x45\xDF\xA3", VIDEO_WEBM),
107763:   // mp3 with ID3 tags, the string "ID3".
107763:   PATTERN_ENTRY("\xFF\xFF\xFF", "ID3", AUDIO_MP3)
107763: };
107763: 
107763: // This function implements mp4 sniffing algorithm, described at
107763: // http://mimesniff.spec.whatwg.org/#signature-for-mp4
111335: static bool MatchesMP4(const uint8_t* aData, const uint32_t aLength)
107763: {
107763:   if (aLength <= MP4_MIN_BYTES_COUNT) {
107763:     return false;
107763:   }
107763:   // Conversion from big endian to host byte order.
111335:   uint32_t boxSize = (uint32_t)(aData[3] | aData[2] << 8 | aData[1] << 16 | aData[0] << 24);
107763: 
107763:   // Boxsize should be evenly divisible by 4.
107763:   if (boxSize % 4 || aLength < boxSize) {
107763:     return false;
107763:   }
107763:   // The string "ftyp".
107763:   if (aData[4] != 0x66 ||
107763:       aData[5] != 0x74 ||
107763:       aData[6] != 0x79 ||
107763:       aData[7] != 0x70) {
107763:     return false;
107763:   }
111335:   for (uint32_t i = 2; i <= boxSize / 4 - 1 ; i++) {
107763:     if (i == 3) {
107763:       continue;
107763:     }
107763:     // The string "mp4".
107763:     if (aData[4*i]   == 0x6D &&
107763:         aData[4*i+1] == 0x70 &&
107763:         aData[4*i+2] == 0x34) {
107763:       return true;
107763:     }
107763:   }
107763:   return false;
107763: }
107763: 
107763: NS_IMETHODIMP
107763: nsMediaSniffer::GetMIMETypeFromContent(nsIRequest* aRequest,
111335:                                        const uint8_t* aData,
111335:                                        const uint32_t aLength,
107763:                                        nsACString& aSniffedType)
107763: {
111466:   // For media, we want to sniff only if the Content-Type is unknown, or if it
111466:   // is application/octet-stream.
111466:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
111578:   if (!channel) {
111578:     return NS_ERROR_NOT_AVAILABLE;
111578:   }
111466:   nsAutoCString contentType;
111466:   nsresult rv = channel->GetContentType(contentType);
111466:   NS_ENSURE_SUCCESS(rv, rv);
111466:   if (!contentType.IsEmpty() &&
111466:       !contentType.EqualsLiteral(APPLICATION_OCTET_STREAM) &&
111466:       !contentType.EqualsLiteral(UNKNOWN_CONTENT_TYPE)) {
111466:     return NS_ERROR_NOT_AVAILABLE;
111466:   }
111466: 
111335:   const uint32_t clampedLength = NS_MIN(aLength, MAX_BYTES_SNIFFED);
107763: 
111335:   for (uint32_t i = 0; i < NS_ARRAY_LENGTH(sSnifferEntries); ++i) {
107763:     const nsMediaSnifferEntry& currentEntry = sSnifferEntries[i];
107763:     if (clampedLength < currentEntry.mLength || currentEntry.mLength == 0) {
107763:       continue;
107763:     }
107763:     bool matched = true;
111335:     for (uint32_t j = 0; j < currentEntry.mLength; ++j) {
107763:       if ((currentEntry.mMask[j] & aData[j]) != currentEntry.mPattern[j]) {
107763:         matched = false;
107763:         break;
107763:       }
107763:     }
107763:     if (matched) {
107763:       aSniffedType.AssignASCII(currentEntry.mContentType);
107763:       return NS_OK;
107763:     }
107763:   }
107763: 
107763:   if (MatchesMP4(aData, clampedLength)) {
107763:     aSniffedType.AssignLiteral(VIDEO_MP4);
107763:     return NS_OK;
107763:   }
107763: 
107763:   // Could not sniff the media type, we are required to set it to
107763:   // application/octet-stream.
107763:   aSniffedType.AssignLiteral(APPLICATION_OCTET_STREAM);
107763:   return NS_ERROR_NOT_AVAILABLE;
107763: }
