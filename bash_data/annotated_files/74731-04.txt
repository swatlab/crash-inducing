52557: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52557:  * vim: set ts=4 sw=4 et tw=99:
52557:  *
52557:  * ***** BEGIN LICENSE BLOCK *****
52557:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52557:  *
52557:  * The contents of this file are subject to the Mozilla Public License Version
52557:  * 1.1 (the "License"); you may not use this file except in compliance with
52557:  * the License. You may obtain a copy of the License at
52557:  * http://www.mozilla.org/MPL/
52557:  *
52557:  * Software distributed under the License is distributed on an "AS IS" basis,
52557:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52557:  * for the specific language governing rights and limitations under the
52557:  * License.
52557:  *
52557:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52557:  * May 28, 2008.
52557:  *
52557:  * The Initial Developer of the Original Code is
52557:  *   Brendan Eich <brendan@mozilla.org>
52557:  *
52557:  * Contributor(s):
52557:  *
52557:  * Alternatively, the contents of this file may be used under the terms of
52557:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52557:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52557:  * in which case the provisions of the GPL or the LGPL are applicable instead
52557:  * of those above. If you wish to allow use of your version of this file only
52557:  * under the terms of either the GPL or the LGPL, and not to allow others to
52557:  * use your version of this file under the terms of the MPL, indicate your
52557:  * decision by deleting the provisions above and replace them with the notice
52557:  * and other provisions required by the GPL or the LGPL. If you do not delete
52557:  * the provisions above, a recipient may use your version of this file under
52557:  * the terms of any one of the MPL, the GPL or the LGPL.
52557:  *
52557:  * ***** END LICENSE BLOCK ***** */
52557: 
52557: #include "MethodJIT.h"
52557: #include "Logging.h"
52557: #include "assembler/jit/ExecutableAllocator.h"
52557: #include "jstracer.h"
74731: #include "jsgcmark.h"
52853: #include "BaseAssembler.h"
57679: #include "Compiler.h"
52880: #include "MonoIC.h"
52880: #include "PolyIC.h"
53168: #include "TrampolineCompiler.h"
53422: #include "jscntxtinlines.h"
54707: #include "jscompartment.h"
54707: #include "jsscope.h"
54707: 
54707: #include "jsgcinlines.h"
63047: #include "jsinterpinlines.h"
52557: 
52557: using namespace js;
52557: using namespace js::mjit;
52557: 
53840: 
57679: js::mjit::CompilerAllocPolicy::CompilerAllocPolicy(JSContext *cx, Compiler &compiler)
72091: : TempAllocPolicy(cx),
57679:   oomFlag(&compiler.oomInVector)
57679: {
57679: }
53840: void
69223: StackFrame::methodjitStaticAsserts()
53840: {
53840:         /* Static assert for x86 trampolines in MethodJIT.cpp. */
53840: #if defined(JS_CPU_X86)
69223:         JS_STATIC_ASSERT(offsetof(StackFrame, rval_)     == 0x18);
69223:         JS_STATIC_ASSERT(offsetof(StackFrame, rval_) + 4 == 0x1C);
69223:         JS_STATIC_ASSERT(offsetof(StackFrame, ncode_)    == 0x14);
53840:         /* ARM uses decimal literals. */
69223:         JS_STATIC_ASSERT(offsetof(StackFrame, rval_)     == 24);
69223:         JS_STATIC_ASSERT(offsetof(StackFrame, rval_) + 4 == 28);
69223:         JS_STATIC_ASSERT(offsetof(StackFrame, ncode_)    == 20);
53840: #elif defined(JS_CPU_X64)
69223:         JS_STATIC_ASSERT(offsetof(StackFrame, rval_)     == 0x30);
69223:         JS_STATIC_ASSERT(offsetof(StackFrame, ncode_)    == 0x28);
53840: #endif
53840: }
53840: 
53471: /*
53471:  * Explanation of VMFrame activation and various helper thunks below.
53471:  *
53471:  * JaegerTrampoline  - Executes a method JIT-compiled JSFunction. This function
54832:  *    creates a VMFrame on the machine stack and jumps into JIT'd code. The JIT'd
54832:  *    code will eventually jump back to the VMFrame.
53471:  *
53472:  *  - Called from C++ function EnterMethodJIT.
54832:  *  - Parameters: cx, fp, code, stackLimit
53471:  *
53471:  * JaegerThrowpoline - Calls into an exception handler from JIT'd code, and if a
53471:  *    scripted exception handler is not found, unwinds the VMFrame and returns
53471:  *    to C++.
53471:  *
53471:  *  - To start exception handling, we return from a stub call to the throwpoline.
53471:  *  - On entry to the throwpoline, the normal conditions of the jit-code ABI
53471:  *    are satisfied.
53471:  *  - To do the unwinding and find out where to continue executing, we call
53471:  *    js_InternalThrow.
53471:  *  - js_InternalThrow may return 0, which means the place to continue, if any,
53471:  *    is above this JaegerShot activation, so we just return, in the same way
53471:  *    the trampoline does.
53472:  *  - Otherwise, js_InternalThrow returns a jit-code address to continue execution
53472:  *    at. Because the jit-code ABI conditions are satisfied, we can just jump to
53472:  *    that point.
53471:  *
53471:  *  - Used by RunTracer()
53471:  */
53471: 
52853: #ifdef JS_METHODJIT_PROFILE_STUBS
53137: static const size_t STUB_CALLS_FOR_OP_COUNT = 255;
53137: static uint32 StubCallsForOp[STUB_CALLS_FOR_OP_COUNT];
52853: #endif
52853: 
54832: extern "C" void JaegerTrampolineReturn();
54832: 
52557: extern "C" void JS_FASTCALL
53168: PushActiveVMFrame(VMFrame &f)
53168: {
72551:     f.entryfp->script()->compartment->jaegerCompartment()->pushActiveFrame(&f);
69223:     f.regs.fp()->setNativeReturnAddress(JS_FUNC_TO_DATA_PTR(void*, JaegerTrampolineReturn));
53168: }
53168: 
53168: extern "C" void JS_FASTCALL
53168: PopActiveVMFrame(VMFrame &f)
53168: {
72551:     f.entryfp->script()->compartment->jaegerCompartment()->popActiveFrame();
53168: }
53168: 
53168: extern "C" void JS_FASTCALL
52557: SetVMFrameRegs(VMFrame &f)
52557: {
69223:     /* Restored on exit from EnterMethodJIT. */
69223:     f.cx->stack.repointRegs(&f.regs);
52557: }
52557: 
59905: #if defined(__APPLE__) || (defined(XP_WIN) && !defined(JS_CPU_X64)) || defined(XP_OS2)
52557: # define SYMBOL_STRING(name) "_" #name
52557: #else
52557: # define SYMBOL_STRING(name) #name
52557: #endif
52557: 
69223: JS_STATIC_ASSERT(offsetof(FrameRegs, sp) == 0);
52557: 
52557: #if defined(__linux__) && defined(JS_CPU_X64)
52557: # define SYMBOL_STRING_RELOC(name) #name "@plt"
52557: #else
52557: # define SYMBOL_STRING_RELOC(name) SYMBOL_STRING(name)
52557: #endif
52557: 
58645: #if (defined(XP_WIN) || defined(XP_OS2)) && defined(JS_CPU_X86)
53847: # define SYMBOL_STRING_VMFRAME(name) "@" #name "@4"
53847: #else
53847: # define SYMBOL_STRING_VMFRAME(name) SYMBOL_STRING_RELOC(name)
53847: #endif
53847: 
52557: #if defined(XP_MACOSX)
52557: # define HIDE_SYMBOL(name) ".private_extern _" #name
52557: #elif defined(__linux__)
52557: # define HIDE_SYMBOL(name) ".hidden" #name
52557: #else
52557: # define HIDE_SYMBOL(name)
52557: #endif
52557: 
64272: #if defined(__GNUC__) && !defined(_WIN64)
52557: 
52557: /* If this assert fails, you need to realign VMFrame to 16 bytes. */
52557: #ifdef JS_CPU_ARM
52557: JS_STATIC_ASSERT(sizeof(VMFrame) % 8 == 0);
52557: #else
52557: JS_STATIC_ASSERT(sizeof(VMFrame) % 16 == 0);
52557: #endif
52557: 
52557: # if defined(JS_CPU_X64)
52557: 
52557: /*
52557:  *    *** DANGER ***
52557:  * If these assertions break, update the constants below.
52557:  *    *** DANGER ***
52557:  */
53162: JS_STATIC_ASSERT(offsetof(VMFrame, savedRBX) == 0x58);
69223: JS_STATIC_ASSERT(VMFrame::offsetOfFp == 0x38);
52557: 
53476: JS_STATIC_ASSERT(JSVAL_TAG_MASK == 0xFFFF800000000000LL);
53476: JS_STATIC_ASSERT(JSVAL_PAYLOAD_MASK == 0x00007FFFFFFFFFFFLL);
53476: 
68902: asm (
52557: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerTrampoline) "\n"
52557: SYMBOL_STRING(JaegerTrampoline) ":"       "\n"
52557:     /* Prologue. */
52557:     "pushq %rbp"                         "\n"
52557:     "movq %rsp, %rbp"                    "\n"
52557:     /* Save non-volatile registers. */
52557:     "pushq %r12"                         "\n"
52557:     "pushq %r13"                         "\n"
52557:     "pushq %r14"                         "\n"
52557:     "pushq %r15"                         "\n"
52557:     "pushq %rbx"                         "\n"
52557: 
53476:     /* Load mask registers. */
53476:     "movq $0xFFFF800000000000, %r13"     "\n"
53476:     "movq $0x00007FFFFFFFFFFF, %r14"     "\n"
53476: 
52557:     /* Build the JIT frame.
52557:      * rdi = cx
52557:      * rsi = fp
52557:      * rcx = inlineCallCount
52557:      * fp must go into rbx
52557:      */
57308:     "pushq %rsi"                         "\n" /* entryfp */
53422:     "pushq %rcx"                         "\n" /* inlineCallCount */
53422:     "pushq %rdi"                         "\n" /* cx */
53422:     "pushq %rsi"                         "\n" /* fp */
52557:     "movq  %rsi, %rbx"                   "\n"
52557: 
52557:     /* Space for the rest of the VMFrame. */
53471:     "subq  $0x28, %rsp"                  "\n"
52557: 
54832:     /* This is actually part of the VMFrame. */
53471:     "pushq %r8"                          "\n"
53471: 
53471:     /* Set cx->regs and set the active frame. Save rdx and align frame in one. */
52557:     "pushq %rdx"                         "\n"
52557:     "movq  %rsp, %rdi"                   "\n"
53847:     "call " SYMBOL_STRING_VMFRAME(SetVMFrameRegs) "\n"
53168:     "movq  %rsp, %rdi"                   "\n"
53847:     "call " SYMBOL_STRING_VMFRAME(PushActiveVMFrame) "\n"
52557: 
54832:     /* Jump into the JIT'd code. */
54832:     "jmp *0(%rsp)"                      "\n"
54832: );
54832: 
68902: asm (
54832: ".text\n"
54832: ".globl " SYMBOL_STRING(JaegerTrampolineReturn) "\n"
54832: SYMBOL_STRING(JaegerTrampolineReturn) ":"       "\n"
54832:     "or   %rdx, %rcx"                    "\n"
54832:     "movq %rcx, 0x30(%rbx)"              "\n"
53471:     "movq %rsp, %rdi"                    "\n"
53847:     "call " SYMBOL_STRING_VMFRAME(PopActiveVMFrame) "\n"
52557: 
53471:     "addq $0x58, %rsp"                   "\n"
52557:     "popq %rbx"                          "\n"
52557:     "popq %r15"                          "\n"
52557:     "popq %r14"                          "\n"
52557:     "popq %r13"                          "\n"
52557:     "popq %r12"                          "\n"
52557:     "popq %rbp"                          "\n"
52557:     "movq $1, %rax"                      "\n"
52557:     "ret"                                "\n"
52557: );
52557: 
68902: asm (
52557: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerThrowpoline)  "\n"
52557: SYMBOL_STRING(JaegerThrowpoline) ":"        "\n"
52557:     "movq %rsp, %rdi"                       "\n"
52557:     "call " SYMBOL_STRING_RELOC(js_InternalThrow) "\n"
52557:     "testq %rax, %rax"                      "\n"
52557:     "je   throwpoline_exit"                 "\n"
52557:     "jmp  *%rax"                            "\n"
52557:   "throwpoline_exit:"                       "\n"
53168:     "movq %rsp, %rdi"                       "\n"
53847:     "call " SYMBOL_STRING_VMFRAME(PopActiveVMFrame) "\n"
53162:     "addq $0x58, %rsp"                      "\n"
52557:     "popq %rbx"                             "\n"
52557:     "popq %r15"                             "\n"
52557:     "popq %r14"                             "\n"
52557:     "popq %r13"                             "\n"
52557:     "popq %r12"                             "\n"
52557:     "popq %rbp"                             "\n"
53169:     "xorq %rax,%rax"                        "\n"
52557:     "ret"                                   "\n"
52557: );
52557: 
52557: # elif defined(JS_CPU_X86)
52557: 
52557: /*
52557:  *    *** DANGER ***
52557:  * If these assertions break, update the constants below. The throwpoline
52557:  * should have the offset of savedEBX plus 4, because it needs to clean
52557:  * up the argument.
52557:  *    *** DANGER ***
52557:  */
52557: JS_STATIC_ASSERT(offsetof(VMFrame, savedEBX) == 0x2c);
69223: JS_STATIC_ASSERT((VMFrame::offsetOfFp) == 0x1C);
52557: 
68902: asm (
52557: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerTrampoline) "\n"
52557: SYMBOL_STRING(JaegerTrampoline) ":"       "\n"
52557:     /* Prologue. */
52557:     "pushl %ebp"                         "\n"
52557:     "movl %esp, %ebp"                    "\n"
52557:     /* Save non-volatile registers. */
52557:     "pushl %esi"                         "\n"
52557:     "pushl %edi"                         "\n"
52557:     "pushl %ebx"                         "\n"
52557: 
52557:     /* Build the JIT frame. Push fields in order, 
52557:      * then align the stack to form esp == VMFrame. */
53471:     "movl  12(%ebp), %ebx"               "\n"   /* load fp */
57308:     "pushl %ebx"                         "\n"   /* entryfp */
53471:     "pushl 20(%ebp)"                     "\n"   /* stackLimit */
53471:     "pushl 8(%ebp)"                      "\n"   /* cx */
53471:     "pushl %ebx"                         "\n"   /* fp */
53471:     "subl $0x1C, %esp"                   "\n"
52557: 
52557:     /* Jump into the JIT'd code. */
52557:     "movl  %esp, %ecx"                   "\n"
53847:     "call " SYMBOL_STRING_VMFRAME(SetVMFrameRegs) "\n"
53168:     "movl  %esp, %ecx"                   "\n"
53847:     "call " SYMBOL_STRING_VMFRAME(PushActiveVMFrame) "\n"
52557: 
54832:     "jmp *16(%ebp)"                      "\n"
54832: );
54832: 
68902: asm (
54832: ".text\n"
54832: ".globl " SYMBOL_STRING(JaegerTrampolineReturn) "\n"
54832: SYMBOL_STRING(JaegerTrampolineReturn) ":" "\n"
54832:     "movl  %edx, 0x18(%ebx)"             "\n"
54832:     "movl  %ecx, 0x1C(%ebx)"             "\n"
53471:     "movl  %esp, %ecx"                   "\n"
53847:     "call " SYMBOL_STRING_VMFRAME(PopActiveVMFrame) "\n"
52557: 
53471:     "addl $0x2C, %esp"                   "\n"
52557:     "popl %ebx"                          "\n"
52557:     "popl %edi"                          "\n"
52557:     "popl %esi"                          "\n"
52557:     "popl %ebp"                          "\n"
52557:     "movl $1, %eax"                      "\n"
52557:     "ret"                                "\n"
52557: );
52557: 
68902: asm (
52557: ".text\n"
52557: ".globl " SYMBOL_STRING(JaegerThrowpoline)  "\n"
52557: SYMBOL_STRING(JaegerThrowpoline) ":"        "\n"
52557:     /* Align the stack to 16 bytes. */
52557:     "pushl %esp"                         "\n"
52557:     "pushl (%esp)"                       "\n"
52557:     "pushl (%esp)"                       "\n"
52557:     "pushl (%esp)"                       "\n"
52557:     "call " SYMBOL_STRING_RELOC(js_InternalThrow) "\n"
52557:     /* Bump the stack by 0x2c, as in the basic trampoline, but
52557:      * also one more word to clean up the stack for js_InternalThrow,
52557:      * and another to balance the alignment above. */
52557:     "addl $0x10, %esp"                   "\n"
52557:     "testl %eax, %eax"                   "\n"
52557:     "je   throwpoline_exit"              "\n"
52557:     "jmp  *%eax"                         "\n"
52557:   "throwpoline_exit:"                    "\n"
53168:     "movl %esp, %ecx"                    "\n"
53847:     "call " SYMBOL_STRING_VMFRAME(PopActiveVMFrame) "\n"
52557:     "addl $0x2c, %esp"                   "\n"
52557:     "popl %ebx"                          "\n"
52557:     "popl %edi"                          "\n"
52557:     "popl %esi"                          "\n"
52557:     "popl %ebp"                          "\n"
52557:     "xorl %eax, %eax"                    "\n"
52557:     "ret"                                "\n"
52557: );
52557: 
52557: # elif defined(JS_CPU_ARM)
52557: 
53361: JS_STATIC_ASSERT(sizeof(VMFrame) == 80);
53430: JS_STATIC_ASSERT(offsetof(VMFrame, savedLR) ==          (4*19));
57308: JS_STATIC_ASSERT(offsetof(VMFrame, entryfp) ==          (4*10));
53430: JS_STATIC_ASSERT(offsetof(VMFrame, stackLimit) ==       (4*9));
53430: JS_STATIC_ASSERT(offsetof(VMFrame, cx) ==               (4*8));
69223: JS_STATIC_ASSERT(VMFrame::offsetOfFp ==                 (4*7));
53627: JS_STATIC_ASSERT(offsetof(VMFrame, unused) ==           (4*4));
53430: JS_STATIC_ASSERT(offsetof(VMFrame, previous) ==         (4*3));
52557: 
53541: JS_STATIC_ASSERT(JSFrameReg == JSC::ARMRegisters::r11);
53541: JS_STATIC_ASSERT(JSReturnReg_Data == JSC::ARMRegisters::r1);
53541: JS_STATIC_ASSERT(JSReturnReg_Type == JSC::ARMRegisters::r2);
53541: 
54115: #ifdef MOZ_THUMB2
54115: #define FUNCTION_HEADER_EXTRA \
54115:   ".align 2\n" \
54115:   ".thumb\n" \
54115:   ".thumb_func\n"
54115: #else
54115: #define FUNCTION_HEADER_EXTRA
54115: #endif
54115: 
68902: asm (
52557: ".text\n"
54115: FUNCTION_HEADER_EXTRA
52557: ".globl " SYMBOL_STRING(JaegerTrampoline)   "\n"
52557: SYMBOL_STRING(JaegerTrampoline) ":"         "\n"
53361:     /*
53361:      * On entry to JaegerTrampoline:
53361:      *         r0 = cx
53361:      *         r1 = fp
53361:      *         r2 = code
53472:      *         r3 = stackLimit
53361:      *
53361:      * The VMFrame for ARM looks like this:
52557:      *  [ lr        ]   \
52557:      *  [ r11       ]   |
52557:      *  [ r10       ]   |
52557:      *  [ r9        ]   | Callee-saved registers.                             
52557:      *  [ r8        ]   | VFP registers d8-d15 may be required here too, but  
52557:      *  [ r7        ]   | unconditionally preserving them might be expensive
52557:      *  [ r6        ]   | considering that we might not use them anyway.
52557:      *  [ r5        ]   |
52557:      *  [ r4        ]   /
57308:      *  [ entryfp   ]
53430:      *  [ stkLimit  ]
53361:      *  [ cx        ]
53493:      *  [ regs.fp   ]
53493:      *  [ regs.pc   ]
53361:      *  [ regs.sp   ]
53627:      *  [ unused    ]
53361:      *  [ previous  ]
53472:      *  [ args.ptr3 ]
53472:      *  [ args.ptr2 ]
53361:      *  [ args.ptr  ]
52557:      */
52557:     
53472:     /* Push callee-saved registers. */
53361: "   push    {r4-r11,lr}"                        "\n"
53361:     /* Push interesting VMFrame content. */
57308: "   push    {r1}"                               "\n"    /* entryfp */
53430: "   push    {r3}"                               "\n"    /* stackLimit */
53430: "   push    {r0}"                               "\n"    /* cx */
53493: "   push    {r1}"                               "\n"    /* regs.fp */
53361:     /* Remaining fields are set elsewhere, but we need to leave space for them. */
53430: "   sub     sp, sp, #(4*7)"                     "\n"
52557: 
53472:     /* Preserve 'code' (r2) in an arbitrary callee-saved register. */
53472: "   mov     r4, r2"                             "\n"
54832:     /* Preserve 'fp' (r1) in r11 (JSFrameReg). */
53472: "   mov     r11, r1"                            "\n"
53472: 
52557: "   mov     r0, sp"                             "\n"
54115: "   blx  " SYMBOL_STRING_VMFRAME(SetVMFrameRegs)   "\n"
53361: "   mov     r0, sp"                             "\n"
54115: "   blx  " SYMBOL_STRING_VMFRAME(PushActiveVMFrame)"\n"
52557: 
53471:     /* Call the compiled JavaScript function. */
54832: "   bx     r4"                                  "\n"
54832: );
54832: 
68902: asm (
54832: ".text\n"
54832: FUNCTION_HEADER_EXTRA
54832: ".globl " SYMBOL_STRING(JaegerTrampolineReturn)   "\n"
54832: SYMBOL_STRING(JaegerTrampolineReturn) ":"         "\n"
54832: "   str r1, [r11, #24]"                    "\n" /* fp->rval data */
54832: "   str r2, [r11, #28]"                    "\n" /* fp->rval type */
52557: 
53361:     /* Tidy up. */
52557: "   mov     r0, sp"                             "\n"
54115: "   blx  " SYMBOL_STRING_VMFRAME(PopActiveVMFrame) "\n"
52557: 
52557:     /* Skip past the parameters we pushed (such as cx and the like). */
53430: "   add     sp, sp, #(4*7 + 4*4)"               "\n"
52557: 
52557:     /* Set a 'true' return value to indicate successful completion. */
52557: "   mov     r0, #1"                         "\n"
53361: "   pop     {r4-r11,pc}"                    "\n"
52557: );
52557: 
68902: asm (
52557: ".text\n"
54115: FUNCTION_HEADER_EXTRA
52557: ".globl " SYMBOL_STRING(JaegerThrowpoline)  "\n"
52557: SYMBOL_STRING(JaegerThrowpoline) ":"        "\n"
53472:     /* Find the VMFrame pointer for js_InternalThrow. */
52557: "   mov     r0, sp"                         "\n"
52557: 
52557:     /* Call the utility function that sets up the internal throw routine. */
54115: "   blx  " SYMBOL_STRING_RELOC(js_InternalThrow) "\n"
52557:     
53472:     /* If js_InternalThrow found a scripted handler, jump to it. Otherwise, tidy
53472:      * up and return. */
52557: "   cmp     r0, #0"                         "\n"
53528: "   it      ne"                             "\n"
52557: "   bxne    r0"                             "\n"
52557: 
53472:     /* Tidy up, then return '0' to represent an unhandled exception. */
53472: "   mov     r0, sp"                             "\n"
54115: "   blx  " SYMBOL_STRING_VMFRAME(PopActiveVMFrame) "\n"
53430: "   add     sp, sp, #(4*7 + 4*4)"               "\n"
53472: "   mov     r0, #0"                         "\n"
53361: "   pop     {r4-r11,pc}"                    "\n"
52557: );
52557: 
68902: asm (
52557: ".text\n"
54115: FUNCTION_HEADER_EXTRA
52557: ".globl " SYMBOL_STRING(JaegerStubVeneer)   "\n"
52557: SYMBOL_STRING(JaegerStubVeneer) ":"         "\n"
52557:     /* We enter this function as a veneer between a compiled method and one of the js_ stubs. We
52557:      * need to store the LR somewhere (so it can be modified in case on an exception) and then
52557:      * branch to the js_ stub as if nothing had happened.
52557:      * The arguments are identical to those for js_* except that the target function should be in
53361:      * 'ip'. */
53361: "   push    {ip,lr}"                        "\n"
52557: "   blx     ip"                             "\n"
53361: "   pop     {ip,pc}"                        "\n"
52557: );
52557: 
68931: # elif defined(JS_CPU_SPARC)
52557: # else
52557: #  error "Unsupported CPU!"
52557: # endif
64272: #elif defined(_MSC_VER) && defined(JS_CPU_X86)
52557: 
52557: /*
52557:  *    *** DANGER ***
52557:  * If these assertions break, update the constants below. The throwpoline
52557:  * should have the offset of savedEBX plus 4, because it needs to clean
52557:  * up the argument.
52557:  *    *** DANGER ***
52557:  */
52557: JS_STATIC_ASSERT(offsetof(VMFrame, savedEBX) == 0x2c);
69223: JS_STATIC_ASSERT(VMFrame::offsetOfFp == 0x1C);
52557: 
52557: extern "C" {
52557: 
69223:     __declspec(naked) JSBool JaegerTrampoline(JSContext *cx, StackFrame *fp, void *code,
54832:                                               Value *stackLimit)
52557:     {
52557:         __asm {
52557:             /* Prologue. */
52557:             push ebp;
52557:             mov ebp, esp;
52557:             /* Save non-volatile registers. */
52557:             push esi;
52557:             push edi;
52557:             push ebx;
52557: 
52557:             /* Build the JIT frame. Push fields in order, 
52557:              * then align the stack to form esp == VMFrame. */
53422:             mov  ebx, [ebp + 12];
53422:             push ebx;
52557:             push [ebp + 20];
52557:             push [ebp + 8];
53422:             push ebx;
53471:             sub  esp, 0x1C;
52557: 
52557:             /* Jump into into the JIT'd code. */
52557:             mov  ecx, esp;
52557:             call SetVMFrameRegs;
53169:             mov  ecx, esp;
53169:             call PushActiveVMFrame;
52557: 
54832:             jmp dword ptr [ebp + 16];
54832:         }
54832:     }
54832: 
54832:     __declspec(naked) void JaegerTrampolineReturn()
54832:     {
54832:         __asm {
54832:             mov [ebx + 0x18], edx;
54832:             mov [ebx + 0x1C], ecx;
53471:             mov  ecx, esp;
53169:             call PopActiveVMFrame;
52557: 
53471:             add esp, 0x2C;
52557: 
52557:             pop ebx;
52557:             pop edi;
52557:             pop esi;
52557:             pop ebp;
52557:             mov eax, 1;
52557:             ret;
52557:         }
52557:     }
52557: 
52557:     extern "C" void *js_InternalThrow(js::VMFrame &f);
52557: 
52557:     __declspec(naked) void *JaegerThrowpoline(js::VMFrame *vmFrame) {
52557:         __asm {
52557:             /* Align the stack to 16 bytes. */
52557:             push esp;
52557:             push [esp];
52557:             push [esp];
52557:             push [esp];
52557:             call js_InternalThrow;
52557:             /* Bump the stack by 0x2c, as in the basic trampoline, but
52557:              * also one more word to clean up the stack for js_InternalThrow,
52557:              * and another to balance the alignment above. */
52557:             add esp, 0x10;
52557:             test eax, eax;
52557:             je throwpoline_exit;
52557:             jmp eax;
52557:         throwpoline_exit:
53169:             mov ecx, esp;
53169:             call PopActiveVMFrame;
52557:             add esp, 0x2c;
52557:             pop ebx;
52557:             pop edi;
52557:             pop esi;
52557:             pop ebp;
52557:             xor eax, eax
52557:             ret;
52557:         }
52557:     }
52557: }
52557: 
64272: // Windows x64 uses assembler version since compiler doesn't support
64272: // inline assembler
64272: #elif defined(_WIN64)
52557: 
52557: /*
52557:  *    *** DANGER ***
52557:  * If these assertions break, update the constants below.
52557:  *    *** DANGER ***
52557:  */
53477: JS_STATIC_ASSERT(offsetof(VMFrame, savedRBX) == 0x58);
69223: JS_STATIC_ASSERT(VMFrame::offsetOfFp == 0x38);
53477: JS_STATIC_ASSERT(JSVAL_TAG_MASK == 0xFFFF800000000000LL);
53477: JS_STATIC_ASSERT(JSVAL_PAYLOAD_MASK == 0x00007FFFFFFFFFFFLL);
52557: 
64272: #endif                   /* _WIN64 */
52557: 
52557: bool
56773: JaegerCompartment::Initialize()
52557: {
64559:     execAlloc_ = js::OffTheBooks::new_<JSC::ExecutableAllocator>();
64243:     if (!execAlloc_)
52557:         return false;
52557:     
64243:     TrampolineCompiler tc(execAlloc_, &trampolines);
53168:     if (!tc.compile()) {
71355:         js::Foreground::delete_(execAlloc_);
71355:         execAlloc_ = NULL;
53168:         return false;
53168:     }
53168: 
53137: #ifdef JS_METHODJIT_PROFILE_STUBS
53137:     for (size_t i = 0; i < STUB_CALLS_FOR_OP_COUNT; ++i)
53137:         StubCallsForOp[i] = 0;
53137: #endif
53137: 
56773:     activeFrame_ = NULL;
53168: 
52557:     return true;
52557: }
52557: 
52557: void
56773: JaegerCompartment::Finish()
52557: {
53168:     TrampolineCompiler::release(&trampolines);
64559:     Foreground::delete_(execAlloc_);
52853: #ifdef JS_METHODJIT_PROFILE_STUBS
52853:     FILE *fp = fopen("/tmp/stub-profiling", "wt");
52853: # define OPDEF(op,val,name,image,length,nuses,ndefs,prec,format) \
52853:     fprintf(fp, "%03d %s %d\n", val, #op, StubCallsForOp[val]);
52853: # include "jsopcode.tbl"
52853: # undef OPDEF
52853:     fclose(fp);
52853: #endif
52557: }
52557: 
55565: extern "C" JSBool
69223: JaegerTrampoline(JSContext *cx, StackFrame *fp, void *code, Value *stackLimit);
52557: 
55565: JSBool
69223: mjit::EnterMethodJIT(JSContext *cx, StackFrame *fp, void *code, Value *stackLimit)
52557: {
52557: #ifdef JS_METHODJIT_SPEW
52557:     Profiler prof;
53840:     JSScript *script = fp->script();
52557: 
54832:     JaegerSpew(JSpew_Prof, "%s jaeger script, line %d\n",
53471:                script->filename, script->lineno);
52557:     prof.start();
52557: #endif
52557: 
69223:     JS_ASSERT(cx->fp() == fp);
69223:     FrameRegs &oldRegs = cx->regs();
53626: 
60162:     JSBool ok;
60162:     {
60162:         AssertCompartmentUnchanged pcc(cx);
69855:         JSAutoResolveFlags rf(cx, RESOLVE_INFER);
60162:         ok = JaegerTrampoline(cx, fp, code, stackLimit);
60162:     }
52557: 
69223:     /* Undo repointRegs in SetVMFrameRegs. */
69223:     cx->stack.repointRegs(&oldRegs);
55483:     JS_ASSERT(fp == cx->fp());
53626: 
55483:     /* The trampoline wrote the return value but did not set the HAS_RVAL flag. */
55483:     fp->markReturnValue();
52557: 
64365:     /* See comment in mjit::Compiler::emitReturn. */
64365:     fp->markActivationObjectsAsPut();
64365: 
52557: #ifdef JS_METHODJIT_SPEW
52557:     prof.stop();
52557:     JaegerSpew(JSpew_Prof, "script run took %d ms\n", prof.time_ms());
52557: #endif
52557: 
52557:     return ok;
52557: }
52557: 
55565: static inline JSBool
69223: CheckStackAndEnterMethodJIT(JSContext *cx, StackFrame *fp, void *code)
55565: {
64365:     JS_CHECK_RECURSION(cx, return false);
55565: 
73495:     Value *stackLimit = cx->stack.space().getStackLimit(cx, REPORT_ERROR);
64365:     if (!stackLimit)
64365:         return false;
63047: 
64365:     return EnterMethodJIT(cx, fp, code, stackLimit);
55565: }
55565: 
53471: JSBool
53471: mjit::JaegerShot(JSContext *cx)
53471: {
69223:     StackFrame *fp = cx->fp();
55503:     JSScript *script = fp->script();
55503:     JITScript *jit = script->getJIT(fp->isConstructing());
53471: 
53471: #ifdef JS_TRACER
53471:     if (TRACE_RECORDER(cx))
53471:         AbortRecording(cx, "attempt to enter method JIT while recording");
53471: #endif
53471: 
69223:     JS_ASSERT(cx->regs().pc == script->code);
53471: 
55565:     return CheckStackAndEnterMethodJIT(cx, cx->fp(), jit->invokeEntry);
53471: }
53471: 
53471: JSBool
53471: js::mjit::JaegerShotAtSafePoint(JSContext *cx, void *safePoint)
53471: {
53471: #ifdef JS_TRACER
53471:     JS_ASSERT(!TRACE_RECORDER(cx));
53471: #endif
53471: 
55565:     return CheckStackAndEnterMethodJIT(cx, cx->fp(), safePoint);
53471: }
53471: 
62075: NativeMapEntry *
62075: JITScript::nmap() const
62075: {
62075:     return (NativeMapEntry *)((char*)this + sizeof(JITScript));
62075: }
62075: 
62075: char *
62075: JITScript::nmapSectionLimit() const
62075: {
74731:     return (char *)&nmap()[nNmapPairs];
62075: }
62075: 
62075: #ifdef JS_MONOIC
62386: ic::GetGlobalNameIC *
62386: JITScript::getGlobalNames() const
62075: {
68952:     return (ic::GetGlobalNameIC *)nmapSectionLimit();
62386: }
62386: 
62386: ic::SetGlobalNameIC *
62386: JITScript::setGlobalNames() const
62386: {
68952:     return (ic::SetGlobalNameIC *)((char *)nmapSectionLimit() +
62386:             sizeof(ic::GetGlobalNameIC) * nGetGlobalNames);
62075: }
62075: 
68952: ic::CallICInfo *
68952: JITScript::callICs() const
68952: {
74731:     return (ic::CallICInfo *)&setGlobalNames()[nSetGlobalNames];
68952: }
68952: 
62075: ic::EqualityICInfo *
62075: JITScript::equalityICs() const
62075: {
74731:     return (ic::EqualityICInfo *)&callICs()[nCallICs];
62075: }
62075: 
62075: ic::TraceICInfo *
62075: JITScript::traceICs() const
62075: {
74731:     return (ic::TraceICInfo *)&equalityICs()[nEqualityICs];
62075: }
62075: 
62075: char *
62075: JITScript::monoICSectionsLimit() const
62075: {
74731:     return (char *)&traceICs()[nTraceICs];
62075: }
62075: #else   // JS_MONOIC
62075: char *
62075: JITScript::monoICSectionsLimit() const
62075: {
70312:     return nmapSectionLimit();
62075: }
62075: #endif  // JS_MONOIC
62075: 
62075: #ifdef JS_POLYIC
62075: ic::GetElementIC *
62075: JITScript::getElems() const
62075: {
62075:     return (ic::GetElementIC *)monoICSectionsLimit();
62075: }
62075: 
62075: ic::SetElementIC *
62075: JITScript::setElems() const
62075: {
62075:     return (ic::SetElementIC *)((char *)getElems() + sizeof(ic::GetElementIC) * nGetElems);
62075: }
62075: 
62075: ic::PICInfo *
62075: JITScript::pics() const
62075: {
62075:     return (ic::PICInfo *)((char *)setElems() + sizeof(ic::SetElementIC) * nSetElems);
62075: }
62075: 
62075: char *
62075: JITScript::polyICSectionsLimit() const
62075: {
62075:     return (char *)pics() + sizeof(ic::PICInfo) * nPICs;
62075: }
62075: #else   // JS_POLYIC
62075: char *
62075: JITScript::polyICSectionsLimit() const
62075: {
62075:     return monoICSectionsLimit();
62075: }
62075: #endif  // JS_POLYIC
62075: 
62075: js::mjit::CallSite *
62075: JITScript::callSites() const
62075: {
62075:     return (js::mjit::CallSite *)polyICSectionsLimit();
62075: }
62075: 
74731: JSObject **
74731: JITScript::rootedObjects() const
74731: {
74731:     return (JSObject **)&callSites()[nCallSites];
74731: }
74731: 
52880: template <typename T>
52880: static inline void Destroy(T &t)
52880: {
52880:     t.~T();
52880: }
52880: 
57758: mjit::JITScript::~JITScript()
52559: {
71317:     code.release();
52559: 
53119: #if defined JS_POLYIC
62075:     ic::GetElementIC *getElems_ = getElems();
62075:     ic::SetElementIC *setElems_ = setElems();
62075:     ic::PICInfo *pics_ = pics();
62075:     for (uint32 i = 0; i < nGetElems; i++)
62075:         Destroy(getElems_[i]);
62075:     for (uint32 i = 0; i < nSetElems; i++)
62075:         Destroy(setElems_[i]);
56738:     for (uint32 i = 0; i < nPICs; i++)
62075:         Destroy(pics_[i]);
52559: #endif
53590: 
53590: #if defined JS_MONOIC
56192:     for (JSC::ExecutablePool **pExecPool = execPools.begin();
56192:          pExecPool != execPools.end();
56192:          ++pExecPool)
56192:     {
56192:         (*pExecPool)->release();
56192:     }
68952:     
68952:     ic::CallICInfo *callICs_ = callICs();
68952:     for (uint32 i = 0; i < nCallICs; i++)
68952:         callICs_[i].releasePools();
53590: #endif
55503: }
53590: 
74731: void
74731: mjit::JITScript::trace(JSTracer *trc)
74731: {
74731:     for (uint32 i = 0; i < nRootedObjects; ++i)
74731:         MarkObject(trc, *rootedObjects()[i], "mjit rooted object");
74731: }
74731: 
72779: size_t
72779: JSScript::jitDataSize()
72779: {
72779:     size_t n = 0;
72779:     if (jitNormal)
72779:         n += jitNormal->scriptDataSize(); 
72779:     if (jitCtor)
72779:         n += jitCtor->scriptDataSize(); 
72779:     return n;
72779: }
72779: 
60207: /* Please keep in sync with Compiler::finishThisUp! */
60207: size_t
60207: mjit::JITScript::scriptDataSize()
60207: {
60207:     return sizeof(JITScript) +
60207:         sizeof(NativeMapEntry) * nNmapPairs +
60207: #if defined JS_MONOIC
62386:         sizeof(ic::GetGlobalNameIC) * nGetGlobalNames +
62386:         sizeof(ic::SetGlobalNameIC) * nSetGlobalNames +
68952:         sizeof(ic::CallICInfo) * nCallICs +
60207:         sizeof(ic::EqualityICInfo) * nEqualityICs +
60207:         sizeof(ic::TraceICInfo) * nTraceICs +
60207: #endif
60207: #if defined JS_POLYIC
60207:         sizeof(ic::PICInfo) * nPICs +
60207:         sizeof(ic::GetElementIC) * nGetElems +
60207:         sizeof(ic::SetElementIC) * nSetElems +
60207: #endif
60207:         sizeof(CallSite) * nCallSites;
60207: }
60207: 
55503: void
55503: mjit::ReleaseScriptCode(JSContext *cx, JSScript *script)
55503: {
55503:     // NB: The recompiler may call ReleaseScriptCode, in which case it
53506:     // will get called again when the script is destroyed, so we
53506:     // must protect against calling ReleaseScriptCode twice.
60207:     JITScript *jscr;
55503: 
60207:     if ((jscr = script->jitNormal)) {
60207:         jscr->~JITScript();
64560:         cx->free_(jscr);
55503:         script->jitNormal = NULL;
57758:         script->jitArityCheckNormal = NULL;
55503:     }
55503: 
60207:     if ((jscr = script->jitCtor)) {
60207:         jscr->~JITScript();
64560:         cx->free_(jscr);
55503:         script->jitCtor = NULL;
57758:         script->jitArityCheckCtor = NULL;
52559:     }
53520: }
52559: 
74731: void
74731: mjit::TraceScript(JSTracer *trc, JSScript *script)
74731: {
74731:     if (JITScript *jit = script->jitNormal)
74731:         jit->trace(trc);
74731: 
74731:     if (JITScript *jit = script->jitCtor)
74731:         jit->trace(trc);
74731: }
74731: 
52853: #ifdef JS_METHODJIT_PROFILE_STUBS
52853: void JS_FASTCALL
52853: mjit::ProfileStubCall(VMFrame &f)
52853: {
52853:     JSOp op = JSOp(*f.regs.pc);
52853:     StubCallsForOp[op]++;
52853: }
52853: #endif
52853: 
56551: #ifdef JS_POLYIC
56551: static int
56551: PICPCComparator(const void *key, const void *entry)
56551: {
56551:     const jsbytecode *pc = (const jsbytecode *)key;
56551:     const ic::PICInfo *pic = (const ic::PICInfo *)entry;
56551: 
56551:     if (ic::PICInfo::CALL != pic->kind)
56551:         return ic::PICInfo::CALL - pic->kind;
56551: 
56551:     /*
56551:      * We can't just return |pc - pic->pc| because the pointers may be
56551:      * far apart and an int (or even a ptrdiff_t) may not be large
56551:      * enough to hold the difference. C says that pointer subtraction
56551:      * is only guaranteed to work for two pointers into the same array.
56551:      */
56551:     if (pc < pic->pc)
56551:         return -1;
56551:     else if (pc == pic->pc)
56551:         return 0;
56551:     else
56551:         return 1;
56551: }
56551: 
56551: uintN
56551: mjit::GetCallTargetCount(JSScript *script, jsbytecode *pc)
56551: {
56551:     ic::PICInfo *pic;
56551:     
56551:     if (mjit::JITScript *jit = script->getJIT(false)) {
62075:         pic = (ic::PICInfo *)bsearch(pc, jit->pics(), jit->nPICs, sizeof(ic::PICInfo),
56551:                                      PICPCComparator);
56551:         if (pic)
56551:             return pic->stubsGenerated + 1; /* Add 1 for the inline path. */
56551:     }
56551:     
56551:     if (mjit::JITScript *jit = script->getJIT(true)) {
62075:         pic = (ic::PICInfo *)bsearch(pc, jit->pics(), jit->nPICs, sizeof(ic::PICInfo),
56551:                                      PICPCComparator);
56551:         if (pic)
56551:             return pic->stubsGenerated + 1; /* Add 1 for the inline path. */
56551:     }
56551: 
56551:     return 1;
56551: }
56551: #else
56551: uintN
56551: mjit::GetCallTargetCount(JSScript *script, jsbytecode *pc)
56551: {
56551:     return 1;
56551: }
56551: #endif
62038: 
62038: jsbytecode *
62038: JITScript::nativeToPC(void *returnAddress) const
62038: {
62038:     size_t low = 0;
62038:     size_t high = nCallICs;
68952:     js::mjit::ic::CallICInfo *callICs_ = callICs();
62038:     while (high > low + 1) {
62038:         /* Could overflow here on a script with 2 billion calls. Oh well. */
62038:         size_t mid = (high + low) / 2;
68952:         void *entry = callICs_[mid].funGuard.executableAddress();
62038: 
62038:         /*
62038:          * Use >= here as the return address of the call is likely to be
62038:          * the start address of the next (possibly IC'ed) operation.
62038:          */
62038:         if (entry >= returnAddress)
62038:             high = mid;
62038:         else
62038:             low = mid;
62038:     }
62038: 
68952:     js::mjit::ic::CallICInfo &ic = callICs_[low];
62038: 
68952:     JS_ASSERT((uint8*)ic.funGuard.executableAddress() + ic.joinPointOffset == returnAddress);
62038:     return ic.pc;
62038: }
