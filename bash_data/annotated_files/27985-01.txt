15751: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
15751: /* vim:set ts=2 sw=2 sts=2 et cindent: */
15751: /* ***** BEGIN LICENSE BLOCK *****
15751:  * Version: ML 1.1/GPL 2.0/LGPL 2.1
15751:  *
15751:  * The contents of this file are subject to the Mozilla Public License Version
15751:  * 1.1 (the "License"); you may not use this file except in compliance with
15751:  * the License. You may obtain a copy of the License at
15751:  * http://www.mozilla.org/MPL/
15751:  *
15751:  * Software distributed under the License is distributed on an "AS IS" basis,
15751:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
15751:  * for the specific language governing rights and limitations under the
15751:  * License.
15751:  *
15751:  * The Original Code is Mozilla code.
15751:  *
15751:  * The Initial Developer of the Original Code is the Mozilla Corporation.
15751:  * Portions created by the Initial Developer are Copyright (C) 2007
15751:  * the Initial Developer. All Rights Reserved.
15751:  *
15751:  * Contributor(s):
15751:  *  Chris Double <chris.double@double.co.nz>
15751:  *
15751:  * Alternatively, the contents of this file may be used under the terms of
15751:  * either the GNU General Public License Version 2 or later (the "GPL"), or
15751:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
15751:  * in which case the provisions of the GPL or the LGPL are applicable instead
15751:  * of those above. If you wish to allow use of your version of this file only
15751:  * under the terms of either the GPL or the LGPL, and not to allow others to
15751:  * use your version of this file under the terms of the MPL, indicate your
15751:  * decision by deleting the provisions above and replace them with the notice
15751:  * and other provisions required by the GPL or the LGPL. If you do not delete
15751:  * the provisions above, a recipient may use your version of this file under
15751:  * the terms of any one of the MPL, the GPL or the LGPL.
15751:  *
15751:  * ***** END LICENSE BLOCK ***** */
15751: #include "nsIDOMHTMLMediaElement.h"
15751: #include "nsIDOMHTMLSourceElement.h"
15751: #include "nsHTMLMediaElement.h"
15751: #include "nsGenericHTMLElement.h"
15751: #include "nsPresContext.h"
15751: #include "nsIPresShell.h"
15751: #include "nsGkAtoms.h"
15751: #include "nsSize.h"
15751: #include "nsIFrame.h"
15751: #include "nsIDocument.h"
15751: #include "nsIDOMDocument.h"
15751: #include "nsDOMError.h"
15751: #include "nsNodeInfoManager.h"
15751: #include "plbase64.h"
15751: #include "nsNetUtil.h"
15751: #include "prmem.h"
15751: #include "nsNetUtil.h"
15751: #include "nsXPCOMStrings.h"
15751: #include "prlock.h"
15751: #include "nsThreadUtils.h"
22874: #include "nsContentUtils.h"
15751: 
15751: #include "nsIScriptSecurityManager.h"
15751: #include "nsIXPConnect.h"
15751: #include "jsapi.h"
15751: 
15751: #include "nsIRenderingContext.h"
15751: #include "nsITimer.h"
15751: 
15751: #include "nsEventDispatcher.h"
15751: #include "nsIDOMDocumentEvent.h"
15751: #include "nsIDOMProgressEvent.h"
15751: #include "nsHTMLMediaError.h"
21079: #include "nsICategoryManager.h"
22874: #include "nsCommaSeparatedTokenizer.h"
15751: 
24155: #include "nsIContentPolicy.h"
24155: #include "nsContentPolicyUtils.h"
24155: #include "nsContentErrors.h"
24155: #include "nsCrossSiteListenerProxy.h"
25849: #include "nsCycleCollectionParticipant.h"
24155: 
16300: #ifdef MOZ_OGG
16300: #include "nsOggDecoder.h"
16300: #endif
21394: #ifdef MOZ_WAVE
21394: #include "nsWaveDecoder.h"
21394: #endif
16300: 
25269: 
25269: class nsMediaEvent : public nsRunnable
25269: {
25269: public:
25269: 
25269:   nsMediaEvent(nsHTMLMediaElement* aElement) :
25269:     mElement(aElement),
25849:     mLoadID(mElement->GetCurrentLoadID()) {}
25269:   ~nsMediaEvent() {}
25269: 
25269:   NS_IMETHOD Run() = 0;
25269: 
25269: protected:
25269:   PRBool IsCancelled() {
25849:     return mElement->GetCurrentLoadID() != mLoadID;
25269:   }
25269: 
25269:   nsCOMPtr<nsHTMLMediaElement> mElement;
25849:   PRUint32 mLoadID;
25269: };
25269: 
25269: 
25269: class nsAsyncEventRunner : public nsMediaEvent
15751: {
15751: private:
15751:   nsString mName;
15751:   PRPackedBool mProgress;
15751:   
15751: public:
15751:   nsAsyncEventRunner(const nsAString& aName, nsHTMLMediaElement* aElement, PRBool aProgress) : 
25269:     nsMediaEvent(aElement), mName(aName), mProgress(aProgress)
15751:   {
15751:   }
15751:   
15751:   NS_IMETHOD Run() {
25269:     // Silently cancel if our load has been cancelled.
25269:     if (IsCancelled())
25269:       return NS_OK;
15751:     return mProgress ?
15751:       mElement->DispatchProgressEvent(mName) :
15751:       mElement->DispatchSimpleEvent(mName);
15751:   }
15751: };
15751: 
25849: class nsHTMLMediaElement::LoadNextSourceEvent : public nsMediaEvent {
25018: public:
25849:   LoadNextSourceEvent(nsHTMLMediaElement *aElement)
25269:     : nsMediaEvent(aElement) {}
25018:   NS_IMETHOD Run() {
25269:     if (!IsCancelled())
25849:       mElement->LoadFromSourceChildren();
25018:     return NS_OK;
25018:   }
25018: };
25018: 
25849: class nsHTMLMediaElement::SelectResourceEvent : public nsMediaEvent {
25269: public:
25849:   SelectResourceEvent(nsHTMLMediaElement *aElement)
25269:     : nsMediaEvent(aElement) {}
25269:   NS_IMETHOD Run() {
25850:     if (!IsCancelled()) {
25850:       NS_ASSERTION(mElement->mIsRunningSelectResource,
25850:                    "Should have flagged that we're running SelectResource()");
25849:       mElement->SelectResource();
25850:       mElement->mIsRunningSelectResource = PR_FALSE;
25850:     }
25269:     return NS_OK;
25269:   }
25269: };
25269: 
25849: void nsHTMLMediaElement::QueueSelectResourceTask()
25269: {
25850:   // Don't allow multiple async select resource calls to be queued.
25850:   if (mIsRunningSelectResource)
25850:     return;
25850:   mIsRunningSelectResource = PR_TRUE;
25850:   ChangeDelayLoadStatus(PR_TRUE);
25849:   nsCOMPtr<nsIRunnable> event = new SelectResourceEvent(this);
25269:   NS_DispatchToMainThread(event);
25269: }
25269: 
25849: void nsHTMLMediaElement::QueueLoadFromSourceTask()
25269: {
25850:   ChangeDelayLoadStatus(PR_TRUE);
25849:   nsCOMPtr<nsIRunnable> event = new LoadNextSourceEvent(this);
25269:   NS_DispatchToMainThread(event);
25269: }
25269: 
25269: class nsHTMLMediaElement::MediaLoadListener : public nsIStreamListener
22826: {
22826:   NS_DECL_ISUPPORTS
22826:   NS_DECL_NSIREQUESTOBSERVER
22826:   NS_DECL_NSISTREAMLISTENER
22826: 
22826: public:
25269:   MediaLoadListener(nsHTMLMediaElement* aElement)
22826:     : mElement(aElement)
22826:   {
22826:     NS_ABORT_IF_FALSE(mElement, "Must pass an element to call back");
22826:   }
22826: 
22826: private:
22826:   nsRefPtr<nsHTMLMediaElement> mElement;
22826:   nsCOMPtr<nsIStreamListener> mNextListener;
22826: };
22826: 
25269: NS_IMPL_ISUPPORTS2(nsHTMLMediaElement::MediaLoadListener, nsIRequestObserver, nsIStreamListener)
22826: 
25269: NS_IMETHODIMP nsHTMLMediaElement::MediaLoadListener::OnStartRequest(nsIRequest* aRequest, nsISupports* aContext)
22826: {
26341:   // Don't continue to load if the request failed or has been canceled.
26341:   nsresult rv;
26341:   nsresult status;
26341:   rv = aRequest->GetStatus(&status);
26341:   NS_ENSURE_SUCCESS(rv, rv);
26341:   if (NS_FAILED(status)) {
26341:     if (mElement)
26341:       mElement->NotifyLoadError();
26341:     return status;
26341:   }
22826: 
22826:   nsCOMPtr<nsIChannel> channel = do_QueryInterface(aRequest);
22826:   if (channel &&
22826:       mElement &&
25001:       NS_SUCCEEDED(rv = mElement->InitializeDecoderForChannel(channel, getter_AddRefs(mNextListener))) &&
22826:       mNextListener) {
22826:     rv = mNextListener->OnStartRequest(aRequest, aContext);
22826:   } else {
25001:     // If InitializeDecoderForChannel() returned an error, fire a network
25001:     // error.
25001:     if (NS_FAILED(rv) && !mNextListener && mElement) {
25269:       // Load failed, attempt to load the next candidate resource. If there
25269:       // are none, this will trigger a MEDIA_ERR_NONE_SUPPORTED error.
25849:       mElement->NotifyLoadError();
25001:     }
25001:     // If InitializeDecoderForChannel did not return a listener (but may
25001:     // have otherwise succeeded), we abort the connection since we aren't
25001:     // interested in keeping the channel alive ourselves.
22826:     rv = NS_BINDING_ABORTED;
22826:   }
22826: 
22826:   // The element is only needed until we've had a chance to call
22826:   // InitializeDecoderForChannel.
22826:   mElement = nsnull;
22826: 
22826:   return rv;
22826: }
22826: 
25269: NS_IMETHODIMP nsHTMLMediaElement::MediaLoadListener::OnStopRequest(nsIRequest* aRequest, nsISupports* aContext,
22826:                                                                      nsresult aStatus)
22826: {
22826:   if (mNextListener) {
22826:     return mNextListener->OnStopRequest(aRequest, aContext, aStatus);
22826:   }
22826:   return NS_OK;
22826: }
22826: 
25269: NS_IMETHODIMP nsHTMLMediaElement::MediaLoadListener::OnDataAvailable(nsIRequest* aRequest, nsISupports* aContext,
22826:                                                                        nsIInputStream* aStream, PRUint32 aOffset,
22826:                                                                        PRUint32 aCount)
22826: {
27985:   if (!mNextListener) {
27985:     NS_ERROR("Must have a chained listener; OnStartRequest should have canceled this request");
27985:     return NS_BINDING_ABORTED;
27985:   }
22826:   return mNextListener->OnDataAvailable(aRequest, aContext, aStream, aOffset, aCount);
22826: }
22826: 
25849: NS_IMPL_ADDREF_INHERITED(nsHTMLMediaElement, nsGenericHTMLElement)
25849: NS_IMPL_RELEASE_INHERITED(nsHTMLMediaElement, nsGenericHTMLElement)
25269: 
25849: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLMediaElement)
25269: 
25849: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLMediaElement, nsGenericHTMLElement)
25849:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSourcePointer)
25850:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mLoadBlockedDoc)
25849: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
25849: 
25849: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsHTMLMediaElement, nsGenericHTMLElement)
25849:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mSourcePointer)
25849: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
25849: 
25849: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsHTMLMediaElement)
25849: NS_INTERFACE_MAP_END_INHERITING(nsGenericHTMLElement)
25018: 
15751: // nsIDOMHTMLMediaElement
15751: NS_IMPL_URI_ATTR(nsHTMLMediaElement, Src, src)
15751: NS_IMPL_BOOL_ATTR(nsHTMLMediaElement, Controls, controls)
16290: NS_IMPL_BOOL_ATTR(nsHTMLMediaElement, Autoplay, autoplay)
15751: 
25272: /* readonly attribute nsIDOMHTMLMediaElement mozAutoplayEnabled; */
25272: NS_IMETHODIMP nsHTMLMediaElement::GetMozAutoplayEnabled(PRBool *aAutoplayEnabled)
25272: {
25272:   *aAutoplayEnabled = mAutoplayEnabled;
25272: 
25272:   return NS_OK;
25272: }
25272: 
15751: /* readonly attribute nsIDOMHTMLMediaError error; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetError(nsIDOMHTMLMediaError * *aError)
15751: {
15751:   NS_IF_ADDREF(*aError = mError);
15751: 
15751:   return NS_OK;
15751: }
15751: 
16290: /* readonly attribute boolean ended; */
16290: NS_IMETHODIMP nsHTMLMediaElement::GetEnded(PRBool *aEnded)
16290: {
22783:   *aEnded = mDecoder ? mDecoder->IsEnded() : PR_FALSE;
16290: 
16290:   return NS_OK;
16290: }
16290: 
15751: /* readonly attribute DOMString currentSrc; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetCurrentSrc(nsAString & aCurrentSrc)
15751: {
15751:   nsCAutoString src;
15751:   
15751:   if (mDecoder) {
15751:     nsCOMPtr<nsIURI> uri;
15751:     mDecoder->GetCurrentURI(getter_AddRefs(uri));
15751:     if (uri) {
15751:       uri->GetSpec(src);
15751:     }
15751:   }
15751: 
15751:   aCurrentSrc = NS_ConvertUTF8toUTF16(src);
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: /* readonly attribute unsigned short networkState; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetNetworkState(PRUint16 *aNetworkState)
15751: {
15751:   *aNetworkState = mNetworkState;
15751: 
15751:   return NS_OK;
15751: }
15751: 
25849: void nsHTMLMediaElement::AbortExistingLoads()
15751: {
25849:   // Abort any already-running instance of the resource selection algorithm.
25849:   mLoadWaitStatus = NOT_WAITING;
25849: 
25849:   // Set a new load ID. This will cause events which were enqueued
26343:   // with a different load ID to silently be cancelled.
25849:   mCurrentLoadID++;
25269: 
22826:   if (mDecoder) {
22826:     mDecoder->Shutdown();
22826:     mDecoder = nsnull;
21079:   }
21079: 
25849:   if (mNetworkState == nsIDOMHTMLMediaElement::NETWORK_LOADING ||
25849:       mNetworkState == nsIDOMHTMLMediaElement::NETWORK_IDLE)
25849:   {
24155:     mError = new nsHTMLMediaError(nsIDOMHTMLMediaError::MEDIA_ERR_ABORTED);
15751:     DispatchProgressEvent(NS_LITERAL_STRING("abort"));
25269:   }
15751: 
15751:   mError = nsnull;
15751:   mLoadedFirstFrame = PR_FALSE;
15751:   mAutoplaying = PR_TRUE;
25849:   mIsLoadingFromSrcAttribute = PR_FALSE;
15751: 
21357:   // TODO: The playback rate must be set to the default playback rate.
15751: 
22787:   if (mNetworkState != nsIDOMHTMLMediaElement::NETWORK_EMPTY) {
22787:     mNetworkState = nsIDOMHTMLMediaElement::NETWORK_EMPTY;
22787:     ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_NOTHING);
15751:     mPaused = PR_TRUE;
25849: 
15751:     // TODO: The current playback position must be set to 0.
15751:     DispatchSimpleEvent(NS_LITERAL_STRING("emptied"));
15751:   }
25850: 
25850:   mIsRunningSelectResource = PR_FALSE;
25269: }
22826: 
25001: void nsHTMLMediaElement::NoSupportedMediaError()
25001: {
25001:   mError = new nsHTMLMediaError(nsIDOMHTMLMediaError::MEDIA_ERR_NONE_SUPPORTED);
25849:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_NO_SOURCE;
25001:   DispatchAsyncProgressEvent(NS_LITERAL_STRING("error"));
25850:   ChangeDelayLoadStatus(PR_FALSE);
25001: }
25001: 
22826: /* void load (); */
22826: NS_IMETHODIMP nsHTMLMediaElement::Load()
22826: {
25849:   if (mIsRunningLoadMethod)
22826:     return NS_OK;
25849:   mIsRunningLoadMethod = PR_TRUE;
25849:   AbortExistingLoads();
25849:   QueueSelectResourceTask();
25849:   mIsRunningLoadMethod = PR_FALSE;
25018:   return NS_OK;
25001: }
22826: 
25849: static PRBool HasSourceChildren(nsIContent *aElement)
25269: {
25849:   PRUint32 count = aElement->GetChildCount();
25849:   for (PRUint32 i = 0; i < count; ++i) {
25849:     nsIContent* child = aElement->GetChildAt(i);
25849:     NS_ASSERTION(child, "GetChildCount lied!");
25849:     if (child &&
25849:         child->Tag() == nsGkAtoms::source &&
25849:         child->IsNodeOfType(nsINode::eHTML))
25849:     {
25849:       return PR_TRUE;
25849:     }
25849:   }
25849:   return PR_FALSE;
25849: }
25269: 
25849: // Returns true if aElement has a src attribute, or a <source> child.
25849: static PRBool HasPotentialResource(nsIContent *aElement) 
25849: {
25849:   nsAutoString src;
25849:   if (aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::src, src))
25849:     return PR_TRUE;
25849:   return HasSourceChildren(aElement);
25849: }
25849: 
25849: void nsHTMLMediaElement::SelectResource()
25849: {
25849:   if (!HasPotentialResource(this)) {
25849:     // While the media element has neither a src attribute nor any source
25849:     // element children, wait. (This steps might wait forever.) 
25849:     mNetworkState = nsIDOMHTMLMediaElement::NETWORK_NO_SOURCE;
25849:     mLoadWaitStatus = WAITING_FOR_SRC_OR_SOURCE;
25850:     ChangeDelayLoadStatus(PR_FALSE);
25849:     return;
25849:   }
25849: 
25849:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_LOADING;
25849:   DispatchAsyncProgressEvent(NS_LITERAL_STRING("loadstart"));
25849: 
25849:   nsAutoString src;
25849:   nsCOMPtr<nsIURI> uri;
25849: 
25849:   // If we have a 'src' attribute, use that exclusively.
25849:   if (GetAttr(kNameSpaceID_None, nsGkAtoms::src, src)) {
25849:     nsresult rv = NewURIFromString(src, getter_AddRefs(uri));
25849:     if (NS_SUCCEEDED(rv)) {
25849:       mIsLoadingFromSrcAttribute = PR_TRUE;
25849:       rv = LoadResource(uri);
25849:       if (NS_SUCCEEDED(rv))
25849:         return;
25849:     }
25849:     NoSupportedMediaError();
25849:   } else {
25849:     // Otherwise, the source elements will be used.
25849:     LoadFromSourceChildren();
25849:   }
25849: }
25849: 
25849: void nsHTMLMediaElement::NotifyLoadError()
25849: {
25849:   if (mIsLoadingFromSrcAttribute) {
25849:     NoSupportedMediaError();
25849:   } else {
25849:     QueueLoadFromSourceTask();
25849:   }
25849: }
25849: 
25849: void nsHTMLMediaElement::LoadFromSourceChildren()
25849: {
25850:   NS_ASSERTION(!IsInDoc() || mDelayingLoadEvent,
25850:                "Should delay load event while loading in document");
25849:   while (PR_TRUE) {
25269:     nsresult rv;
25849:     nsCOMPtr<nsIURI> uri = GetNextSource();
25849:     if (!uri) {
25849:       // Exhausted candidates, wait for more candidates to be appended to
25849:       // the media element.
25849:       mLoadWaitStatus = WAITING_FOR_SOURCE;
25849:       NoSupportedMediaError();
25849:       return;
25849:     }
25849: 
25849:     mNetworkState = nsIDOMHTMLMediaElement::NETWORK_LOADING;
25849:   
25849:     rv = LoadResource(uri);
25849:     if (NS_SUCCEEDED(rv))
25849:       return;
25849: 
25849:     // If we fail to load, loop back and try loading the next resource.
25849:   }
25849:   NS_NOTREACHED("Execution should not reach here!");
25849: }
25849: 
25849: nsresult nsHTMLMediaElement::LoadResource(nsIURI* aURI)
25849: {
25850:   NS_ASSERTION(!IsInDoc() || mDelayingLoadEvent,
25850:                "Should delay load event while loading in document");
25849:   nsresult rv;
25269: 
22826:   if (mChannel) {
22826:     mChannel->Cancel(NS_BINDING_ABORTED);
22826:     mChannel = nsnull;
22826:   }
22826: 
24226:   PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
24226:   rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_MEDIA,
25849:                                  aURI,
24226:                                  NodePrincipal(),
24226:                                  this,
24226:                                  EmptyCString(), // mime type
24226:                                  nsnull, // extra
24226:                                  &shouldLoad,
24226:                                  nsContentUtils::GetContentPolicy(),
24226:                                  nsContentUtils::GetSecurityManager());
25849:   NS_ENSURE_SUCCESS(rv,rv);
25849:   if (NS_CP_REJECTED(shouldLoad)) return NS_ERROR_FAILURE;
24226: 
27217:   nsCOMPtr<nsILoadGroup> loadGroup = GetDocumentLoadGroup();
22826:   rv = NS_NewChannel(getter_AddRefs(mChannel),
25849:                      aURI,
22826:                      nsnull,
27217:                      loadGroup,
22826:                      nsnull,
22826:                      nsIRequest::LOAD_NORMAL);
25849:   NS_ENSURE_SUCCESS(rv,rv);
25269: 
22826:   // The listener holds a strong reference to us.  This creates a reference
22826:   // cycle which is manually broken in the listener's OnStartRequest method
22826:   // after it is finished with the element.
25269:   nsCOMPtr<nsIStreamListener> loadListener = new MediaLoadListener(this);
25849:   if (!loadListener) return NS_ERROR_OUT_OF_MEMORY;
24155: 
24155:   nsCOMPtr<nsIStreamListener> listener;
24155:   if (ShouldCheckAllowOrigin()) {
24155:     listener = new nsCrossSiteListenerProxy(loadListener,
24155:                                             NodePrincipal(),
24155:                                             mChannel, 
24155:                                             PR_FALSE,
24155:                                             &rv);
25849:     NS_ENSURE_SUCCESS(rv,rv);
25849:     if (!listener) return NS_ERROR_OUT_OF_MEMORY;
24155:   } else {
24187:     rv = nsContentUtils::GetSecurityManager()->
24187:            CheckLoadURIWithPrincipal(NodePrincipal(),
25849:                                      aURI,
24187:                                      nsIScriptSecurityManager::STANDARD);
25849:     NS_ENSURE_SUCCESS(rv,rv);
24155:     listener = loadListener;
24155:   }
22826: 
22826:   nsCOMPtr<nsIHttpChannel> hc = do_QueryInterface(mChannel);
22826:   if (hc) {
22826:     // Use a byte range request from the start of the resource.
22826:     // This enables us to detect if the stream supports byte range
22826:     // requests, and therefore seeking, early.
22826:     hc->SetRequestHeader(NS_LITERAL_CSTRING("Range"),
22826:                          NS_LITERAL_CSTRING("bytes=0-"),
22826:                          PR_FALSE);
22826:   }
22826: 
22826:   rv = mChannel->AsyncOpen(listener, nsnull);
22826:   if (NS_FAILED(rv)) {
22826:     // OnStartRequest is guaranteed to be called if the open succeeds.  If
22826:     // the open failed, the listener's OnStartRequest will never be called,
22826:     // so we need to break the element->channel->listener->element reference
22826:     // cycle here.  The channel holds the only reference to the listener,
22826:     // and is useless now anyway, so drop our reference to it to allow it to
22826:     // be destroyed.
22826:     mChannel = nsnull;
25849:     return rv;
22826:   }
22826: 
25269:   // Else the channel must be open and starting to download. If it encounters
25269:   // a non-catestrophic failure, it will set a new task to continue loading
25849:   // another candidate.
25849:   return NS_OK;
22826: }
22826: 
22826: nsresult nsHTMLMediaElement::LoadWithChannel(nsIChannel *aChannel,
22826:                                              nsIStreamListener **aListener)
22826: {
22826:   NS_ENSURE_ARG_POINTER(aChannel);
22826:   NS_ENSURE_ARG_POINTER(aListener);
22826: 
22826:   *aListener = nsnull;
22826: 
25849:   AbortExistingLoads();
22826: 
25850:   ChangeDelayLoadStatus(PR_TRUE);
25850: 
22826:   nsresult rv = InitializeDecoderForChannel(aChannel, aListener);
22826:   if (NS_FAILED(rv)) {
22826:     return rv;
22826:   }
22787: 
15751:   mBegun = PR_TRUE;
15751: 
15751:   DispatchAsyncProgressEvent(NS_LITERAL_STRING("loadstart"));
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: /* readonly attribute unsigned short readyState; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetReadyState(PRUint16 *aReadyState)
15751: {
15751:   *aReadyState = mReadyState;
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: /* readonly attribute boolean seeking; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetSeeking(PRBool *aSeeking)
15751: {
20627:   *aSeeking = mDecoder && mDecoder->IsSeeking();
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: /* attribute float currentTime; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetCurrentTime(float *aCurrentTime)
15751: {
15751:   *aCurrentTime = mDecoder ? mDecoder->GetCurrentTime() : 0.0;
15751:   return NS_OK;
15751: }
15751: 
15751: NS_IMETHODIMP nsHTMLMediaElement::SetCurrentTime(float aCurrentTime)
15751: {
20627:   if (!mDecoder)
20627:     return NS_ERROR_DOM_INVALID_STATE_ERR;
20627: 
20627:   // Detect for a NaN and invalid values.
20627:   if (!(aCurrentTime >= 0.0))
20627:     return NS_ERROR_FAILURE;
20627: 
22787:   if (mReadyState == nsIDOMHTMLMediaElement::HAVE_NOTHING) 
20627:     return NS_ERROR_DOM_INVALID_STATE_ERR;
20627: 
22787:   mPlayingBeforeSeek = IsPotentiallyPlaying();
20776:   // The media backend is responsible for dispatching the timeupdate
20776:   // event if it changes the playback position as a result of the seek.
20627:   nsresult rv = mDecoder->Seek(aCurrentTime);
20627:   return rv;
15751: }
15751: 
15751: /* readonly attribute float duration; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetDuration(float *aDuration)
15751: {
15754:   *aDuration =  mDecoder ? mDecoder->GetDuration() : 0.0;
15751:   return NS_OK;
15751: }
15751: 
21017: /* readonly attribute boolean paused; */
21017: NS_IMETHODIMP nsHTMLMediaElement::GetPaused(PRBool *aPaused)
15751: {
15751:   *aPaused = mPaused;
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: /* void pause (); */
15751: NS_IMETHODIMP nsHTMLMediaElement::Pause()
15751: {
22787:   if (mNetworkState == nsIDOMHTMLMediaElement::NETWORK_EMPTY) {
23467:     nsresult rv = Load();
15751:     NS_ENSURE_SUCCESS(rv, rv);
23467:   } else if (mDecoder) {
23467:     mDecoder->Pause();
15751:   }
15751: 
15751:   PRBool oldPaused = mPaused;
15751:   mPaused = PR_TRUE;
15751:   mAutoplaying = PR_FALSE;
15751:   
15751:   if (!oldPaused) {
15751:     DispatchAsyncSimpleEvent(NS_LITERAL_STRING("timeupdate"));
15751:     DispatchAsyncSimpleEvent(NS_LITERAL_STRING("pause"));
15751:   }
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: /* attribute float volume; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetVolume(float *aVolume)
15751: {
25534:   *aVolume = mVolume;
25534: 
15751:   return NS_OK;
15751: }
15751: 
15751: NS_IMETHODIMP nsHTMLMediaElement::SetVolume(float aVolume)
15751: {
20036:   if (aVolume < 0.0f || aVolume > 1.0f)
20036:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
20036: 
25534:   if (aVolume == mVolume)
25534:     return NS_OK;
25534: 
25534:   mVolume = aVolume;
25534: 
25534:   if (mDecoder && !mMuted)
25534:     mDecoder->SetVolume(mVolume);
15751: 
24750:   DispatchAsyncSimpleEvent(NS_LITERAL_STRING("volumechange"));
25534: 
15751:   return NS_OK;
15751: }
15751: 
15751: /* attribute boolean muted; */
15751: NS_IMETHODIMP nsHTMLMediaElement::GetMuted(PRBool *aMuted)
15751: {
15751:   *aMuted = mMuted;
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: NS_IMETHODIMP nsHTMLMediaElement::SetMuted(PRBool aMuted)
15751: {
25534:   if (aMuted == mMuted)
25534:     return NS_OK;
15751: 
15751:   mMuted = aMuted;
15751: 
25534:   if (mDecoder) {
25534:     mDecoder->SetVolume(mMuted ? 0.0 : mVolume);
25534:   }
25534: 
24750:   DispatchAsyncSimpleEvent(NS_LITERAL_STRING("volumechange"));
25534: 
15751:   return NS_OK;
15751: }
15751: 
15751: nsHTMLMediaElement::nsHTMLMediaElement(nsINodeInfo *aNodeInfo, PRBool aFromParser)
15751:   : nsGenericHTMLElement(aNodeInfo),
26343:     mCurrentLoadID(0),
22787:     mNetworkState(nsIDOMHTMLMediaElement::NETWORK_EMPTY),
22787:     mReadyState(nsIDOMHTMLMediaElement::HAVE_NOTHING),
26343:     mLoadWaitStatus(NOT_WAITING),
25534:     mVolume(1.0),
20627:     mMediaSize(-1,-1),
15751:     mBegun(PR_FALSE),
15751:     mLoadedFirstFrame(PR_FALSE),
15751:     mAutoplaying(PR_TRUE),
25272:     mAutoplayEnabled(PR_TRUE),
15751:     mPaused(PR_TRUE),
15751:     mMuted(PR_FALSE),
20627:     mIsDoneAddingChildren(!aFromParser),
24919:     mPlayingBeforeSeek(PR_FALSE),
26343:     mPausedBeforeFreeze(PR_FALSE),
25018:     mWaitingFired(PR_FALSE),
25849:     mIsBindingToTree(PR_FALSE),
26343:     mIsRunningLoadMethod(PR_FALSE),
25849:     mIsLoadingFromSrcAttribute(PR_FALSE),
25850:     mDelayingLoadEvent(PR_FALSE),
25850:     mIsRunningSelectResource(PR_FALSE)
15751: {
15751: }
15751: 
15751: nsHTMLMediaElement::~nsHTMLMediaElement()
15751: {
20627:   if (mDecoder) {
20627:     mDecoder->Shutdown();
20627:     mDecoder = nsnull;
20627:   }
22826:   if (mChannel) {
22826:     mChannel->Cancel(NS_BINDING_ABORTED);
22826:     mChannel = nsnull;
22826:   }
15751: }
15751: 
22826: NS_IMETHODIMP nsHTMLMediaElement::Play()
15751: {
22787:   if (mNetworkState == nsIDOMHTMLMediaElement::NETWORK_EMPTY) {
24918:     nsresult rv = Load();
24918:     NS_ENSURE_SUCCESS(rv, rv);
24918:   } else if (mDecoder) {
22783:     if (mDecoder->IsEnded()) {
20715:       SetCurrentTime(0);
20715:     }
24918:     nsresult rv = mDecoder->Play();
24918:     NS_ENSURE_SUCCESS(rv, rv);
24918:   }
20715: 
15751:   // TODO: If the playback has ended, then the user agent must set 
25849:   // seek to the effective start.
21357:   // TODO: The playback rate must be set to the default playback rate.
24918:   if (mPaused) {
24918:     DispatchAsyncSimpleEvent(NS_LITERAL_STRING("play"));
24918:     switch (mReadyState) {
24918:     case nsIDOMHTMLMediaElement::HAVE_METADATA:
24918:     case nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA:
24918:       DispatchAsyncSimpleEvent(NS_LITERAL_STRING("waiting"));
24918:       break;
24918:     case nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA:
24918:     case nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA:
24918:       DispatchAsyncSimpleEvent(NS_LITERAL_STRING("playing"));
24918:       break;
24918:     }
24918:   }
15751: 
15751:   mPaused = PR_FALSE;
15751:   mAutoplaying = PR_FALSE;
15751: 
15751:   return NS_OK;
15751: }
15751: 
22826: PRBool nsHTMLMediaElement::ParseAttribute(PRInt32 aNamespaceID,
15751:                                           nsIAtom* aAttribute,
15751:                                           const nsAString& aValue,
15751:                                           nsAttrValue& aResult)
15751: {
15751:   if (aNamespaceID == kNameSpaceID_None) {
15751:     if (aAttribute == nsGkAtoms::src) {
15751:       static const char* kWhitespace = " \n\r\t\b";
15751:       aResult.SetTo(nsContentUtils::TrimCharsInSet(kWhitespace, aValue));
15751:       return PR_TRUE;
15751:     }
19889:     else if (aAttribute == nsGkAtoms::loopstart
16290:             || aAttribute == nsGkAtoms::loopend
16290:             || aAttribute == nsGkAtoms::start
16290:             || aAttribute == nsGkAtoms::end) {
15751:       return aResult.ParseFloatValue(aValue);
15751:     }
15751:     else if (ParseImageAttribute(aAttribute, aValue, aResult)) {
15751:       return PR_TRUE;
15751:     }
15751:   }
15751: 
15751:   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
15751:                                               aResult);
15751: }
20627: 
22826: nsresult nsHTMLMediaElement::SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
15751:                                      nsIAtom* aPrefix, const nsAString& aValue,
15751:                                      PRBool aNotify)
15751: {
15751:   nsresult rv = 
15751:     nsGenericHTMLElement::SetAttr(aNameSpaceID, aName, aPrefix, aValue,
15751:                                     aNotify);
25849:   if (aNotify &&
25849:       aNameSpaceID == kNameSpaceID_None &&
25849:       aName == nsGkAtoms::src &&
25849:       mLoadWaitStatus == WAITING_FOR_SRC_OR_SOURCE) 
25849:   {
25849:     // A previous load algorithm instance is waiting on a src
25849:     // addition, resume the load. It is waiting at "step 1 of the load
25849:     // algorithm".
25849:     mLoadWaitStatus = NOT_WAITING;
25849:     QueueSelectResourceTask();
15751:   }
15751: 
15751:   return rv;
15751: }
15751: 
25272: static PRBool IsAutoplayEnabled()
25272: {
25272:   return nsContentUtils::GetBoolPref("media.autoplay.enabled");
25272: }
25272: 
15751: nsresult nsHTMLMediaElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
15751:                                         nsIContent* aBindingParent,
15751:                                         PRBool aCompileEventHandlers)
15751: {
25018:   mIsBindingToTree = PR_TRUE;
25272:   mAutoplayEnabled = IsAutoplayEnabled();
15751:   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, 
15751:                                                  aParent, 
15751:                                                  aBindingParent, 
15751:                                                  aCompileEventHandlers);
25018:   if (NS_SUCCEEDED(rv) &&
25018:       mIsDoneAddingChildren &&
25849:       mNetworkState == nsIDOMHTMLMediaElement::NETWORK_EMPTY)
25849:   {
25849:     QueueSelectResourceTask();
25018:   }
15751: 
25018:   mIsBindingToTree = PR_FALSE;
15751: 
15751:   return rv;
15751: }
15751: 
15751: void nsHTMLMediaElement::UnbindFromTree(PRBool aDeep,
15751:                                         PRBool aNullParent)
15751: {
22787:   if (!mPaused && mNetworkState != nsIDOMHTMLMediaElement::NETWORK_EMPTY)
16341:     Pause();
15751:   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
15751: }
15751: 
21079: #ifdef MOZ_OGG
22874: // See http://www.rfc-editor.org/rfc/rfc5334.txt for the definitions
22874: // of Ogg media types and codec types
21079: static const char gOggTypes[][16] = {
21079:   "video/ogg",
21079:   "audio/ogg",
21079:   "application/ogg"
21079: };
15751: 
22874: static const char* gOggCodecs[] = {
22874:   "vorbis",
22874:   "theora",
22874:   nsnull
22874: };
22874: 
22874: static const char* gOggMaybeCodecs[] = {
22874:   nsnull
22874: }; 
22874: 
22724: static PRBool IsOggEnabled()
22724: {
22724:   return nsContentUtils::GetBoolPref("media.ogg.enabled");
22724: }
22724: 
21079: static PRBool IsOggType(const nsACString& aType)
21079: {
22724:   if (!IsOggEnabled())
22724:     return PR_FALSE;
21079:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gOggTypes); ++i) {
21079:     if (aType.EqualsASCII(gOggTypes[i]))
21079:       return PR_TRUE;
21079:   }
21079:   return PR_FALSE;
21079: }
21079: #endif
21079: 
21394: #ifdef MOZ_WAVE
22874: // See http://www.rfc-editor.org/rfc/rfc2361.txt for the definitions
22874: // of WAVE media types and codec types. However, the audio/vnd.wave
22874: // MIME type described there is not used.
21394: static const char gWaveTypes[][16] = {
21394:   "audio/x-wav",
21394:   "audio/wav",
21394:   "audio/wave",
21394:   "audio/x-pn-wav"
21394: };
21394: 
22874: static const char* gWaveCodecs[] = {
22874:   "1", // Microsoft PCM Format
22874:   nsnull
22874: };
22874: 
22874: static const char* gWaveMaybeCodecs[] = {
22874:   "0", // Microsoft Unknown Wave Format
22874:   nsnull
22874: };
22874: 
22724: static PRBool IsWaveEnabled()
22724: {
22724:   return nsContentUtils::GetBoolPref("media.wave.enabled");
22724: }
22724: 
21394: static PRBool IsWaveType(const nsACString& aType)
21394: {
22724:   if (!IsWaveEnabled())
22724:     return PR_FALSE;
21394:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gWaveTypes); ++i) {
21394:     if (aType.EqualsASCII(gWaveTypes[i]))
21394:       return PR_TRUE;
21394:   }
21394:   return PR_FALSE;
21394: }
21394: #endif
21394: 
21079: /* static */
22874: PRBool nsHTMLMediaElement::CanHandleMediaType(const char* aMIMEType,
22874:                                               const char*** aCodecList,
22874:                                               const char*** aMaybeCodecList)
21079: {
21079: #ifdef MOZ_OGG
22874:   if (IsOggType(nsDependentCString(aMIMEType))) {
22874:     *aCodecList = gOggCodecs;
22874:     *aMaybeCodecList = gOggMaybeCodecs;
21079:     return PR_TRUE;
22874:   }
21079: #endif
21394: #ifdef MOZ_WAVE
22874:   if (IsWaveType(nsDependentCString(aMIMEType))) {
22874:     *aCodecList = gWaveCodecs;
22874:     *aMaybeCodecList = gWaveMaybeCodecs;
21394:     return PR_TRUE;
22874:   }
21394: #endif
21079:   return PR_FALSE;
21079: }
21079: 
22874: static PRBool
22874: CodecListContains(const char** aCodecs, const nsAString& aCodec)
22874: {
22874:   for (PRInt32 i = 0; aCodecs[i]; ++i) {
22874:     if (aCodec.EqualsASCII(aCodecs[i]))
22874:       return PR_TRUE;
22874:   }
22874:   return PR_FALSE;
22874: }
22874: 
22874: enum CanPlayStatus {
22874:   CANPLAY_NO,
22874:   CANPLAY_MAYBE,
22874:   CANPLAY_YES
22874: };
22874: 
22874: static CanPlayStatus GetCanPlay(const nsAString& aType)
22874: {
22874:   nsContentTypeParser parser(aType);
22874:   nsAutoString mimeType;
22874:   nsresult rv = parser.GetType(mimeType);
22874:   if (NS_FAILED(rv))
22874:     return CANPLAY_NO;
22874: 
22874:   NS_ConvertUTF16toUTF8 mimeTypeUTF8(mimeType);
22874:   const char** supportedCodecs;
22874:   const char** maybeSupportedCodecs;
22874:   if (!nsHTMLMediaElement::CanHandleMediaType(mimeTypeUTF8.get(),
22874:           &supportedCodecs, &maybeSupportedCodecs))
22874:     return CANPLAY_NO;
22874: 
22874:   nsAutoString codecs;
22874:   rv = parser.GetParameter("codecs", codecs);
22874:   if (NS_FAILED(rv))
22874:     // Parameter not found or whatever
22874:     return CANPLAY_MAYBE;
22874: 
22874:   CanPlayStatus result = CANPLAY_YES;
22874:   // See http://www.rfc-editor.org/rfc/rfc4281.txt for the description
22874:   // of the 'codecs' parameter
22874:   nsCommaSeparatedTokenizer tokenizer(codecs);
22874:   PRBool expectMoreTokens = PR_FALSE;
22874:   while (tokenizer.hasMoreTokens()) {
22874:     const nsSubstring& token = tokenizer.nextToken();
22874: 
22874:     if (CodecListContains(maybeSupportedCodecs, token)) {
22874:       result = CANPLAY_MAYBE;
22874:     } else if (!CodecListContains(supportedCodecs, token)) {
22874:       // Totally unsupported codec
22874:       return CANPLAY_NO;
22874:     }
22874:     expectMoreTokens = tokenizer.lastTokenEndedWithComma();
22874:   }
22874:   if (expectMoreTokens) {
22874:     // Last codec name was empty
22874:     return CANPLAY_NO;
22874:   }
22874:   return result;
22874: }
22874: 
22874: NS_IMETHODIMP
22874: nsHTMLMediaElement::CanPlayType(const nsAString& aType, nsAString& aResult)
22874: {
22874:   switch (GetCanPlay(aType)) {
22874:   case CANPLAY_NO: aResult.AssignLiteral("no"); break;
22874:   case CANPLAY_YES: aResult.AssignLiteral("probably"); break;
22874:   default:
22874:   case CANPLAY_MAYBE: aResult.AssignLiteral("maybe"); break;
22874:   }
22874:   return NS_OK;
22874: }
22874: 
21079: /* static */
21079: void nsHTMLMediaElement::InitMediaTypes()
21079: {
21079:   nsresult rv;
21079:   nsCOMPtr<nsICategoryManager> catMan(do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv));
21079:   if (NS_SUCCEEDED(rv)) {
21079: #ifdef MOZ_OGG
22724:     if (IsOggEnabled()) {
21079:       for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gOggTypes); i++) {
21079:         catMan->AddCategoryEntry("Gecko-Content-Viewers", gOggTypes[i],
21079:                                  "@mozilla.org/content/document-loader-factory;1",
21079:                                  PR_FALSE, PR_TRUE, nsnull);
21079:       }
22724:     }
21079: #endif
21394: #ifdef MOZ_WAVE
22724:     if (IsWaveEnabled()) {
21394:       for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gWaveTypes); i++) {
21394:         catMan->AddCategoryEntry("Gecko-Content-Viewers", gWaveTypes[i],
21394:                                  "@mozilla.org/content/document-loader-factory;1",
21394:                                  PR_FALSE, PR_TRUE, nsnull);
21394:       }
22724:     }
21394: #endif
21079:   }
21079: }
21079: 
21079: /* static */
21079: void nsHTMLMediaElement::ShutdownMediaTypes()
21079: {
21079:   nsresult rv;
21079:   nsCOMPtr<nsICategoryManager> catMan(do_GetService(NS_CATEGORYMANAGER_CONTRACTID, &rv));
21079:   if (NS_SUCCEEDED(rv)) {
21079: #ifdef MOZ_OGG
21079:     for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gOggTypes); i++) {
21079:       catMan->DeleteCategoryEntry("Gecko-Content-Viewers", gOggTypes[i], PR_FALSE);
21079:     }
21079: #endif
21394: #ifdef MOZ_WAVE
21394:     for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(gWaveTypes); i++) {
21394:       catMan->DeleteCategoryEntry("Gecko-Content-Viewers", gWaveTypes[i], PR_FALSE);
21394:     }
21394: #endif
21079:   }
21079: }
21079: 
21079: PRBool nsHTMLMediaElement::CreateDecoder(const nsACString& aType)
21079: {
21079: #ifdef MOZ_OGG
21079:   if (IsOggType(aType)) {
21079:     mDecoder = new nsOggDecoder();
23851:     if (mDecoder && !mDecoder->Init(this)) {
21079:       mDecoder = nsnull;
21079:     }
21079:   }
21079: #endif
21394: #ifdef MOZ_WAVE
21394:   if (IsWaveType(aType)) {
21394:     mDecoder = new nsWaveDecoder();
23851:     if (mDecoder && !mDecoder->Init(this)) {
21394:       mDecoder = nsnull;
21394:     }
21394:   }
21394: #endif
21079:   return mDecoder != nsnull;
21079: }
21079: 
21079: nsresult nsHTMLMediaElement::InitializeDecoderForChannel(nsIChannel *aChannel,
21079:                                                          nsIStreamListener **aListener)
21079: {
21079:   nsCAutoString mimeType;
21079:   aChannel->GetContentType(mimeType);
21079: 
21079:   if (!CreateDecoder(mimeType))
21079:     return NS_ERROR_FAILURE;
21079: 
22787:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_LOADING;
21079: 
24918:   nsresult rv = mDecoder->Load(nsnull, aChannel, aListener);
24918:   if (NS_FAILED(rv))
24918:     return rv;
24918: 
27217:   // Decoder successfully created, its nsMediaStream now has responsibility
27217:   // for the channel, and the owning reference.
27217:   mChannel = nsnull;
27217: 
25534:   mDecoder->SetVolume(mMuted ? 0.0 : mVolume);
25534: 
24918:   if (!mPaused) {
24918:     rv = mDecoder->Play();
24918:   }
24918: 
24918:   return rv;
21079: }
21079: 
22826: nsresult nsHTMLMediaElement::NewURIFromString(const nsAutoString& aURISpec, nsIURI** aURI)
15751: {
22826:   NS_ENSURE_ARG_POINTER(aURI);
22826: 
22826:   *aURI = nsnull;
22826: 
22826:   nsCOMPtr<nsIDocument> doc = GetOwnerDoc();
22826:   if (!doc) {
22826:     return NS_ERROR_DOM_INVALID_STATE_ERR;
22826:   }
22826: 
22826:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
22826:   nsresult rv = nsContentUtils::NewURIWithDocumentCharset(aURI,
22826:                                                           aURISpec,
22826:                                                           doc,
22826:                                                           baseURI);
22826:   NS_ENSURE_SUCCESS(rv, rv);
22826: 
22826:   PRBool equal;
22826:   if (aURISpec.IsEmpty() &&
22826:       doc->GetDocumentURI() &&
22826:       NS_SUCCEEDED(doc->GetDocumentURI()->Equals(*aURI, &equal)) &&
22826:       equal) {
22826:     // It's not possible for a media resource to be embedded in the current
22826:     // document we extracted aURISpec from, so there's no point returning
22826:     // the current document URI just to let the caller attempt and fail to
22826:     // decode it.
22826:     NS_RELEASE(*aURI);
22826:     return NS_ERROR_DOM_INVALID_STATE_ERR;
22826:   }
22826: 
22826:   return NS_OK;
22826: }
22826: 
15751: void nsHTMLMediaElement::MetadataLoaded()
15751: {
22787:   ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_METADATA);
15751:   DispatchAsyncSimpleEvent(NS_LITERAL_STRING("durationchange"));
15751:   DispatchAsyncSimpleEvent(NS_LITERAL_STRING("loadedmetadata"));
15751: }
15751: 
15751: void nsHTMLMediaElement::FirstFrameLoaded()
15751: {
22787:   ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA);
25850:   ChangeDelayLoadStatus(PR_FALSE);
15751: }
15751: 
15751: void nsHTMLMediaElement::ResourceLoaded()
15751: {
15751:   mBegun = PR_FALSE;
22787:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_LOADED;
22787:   ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA);
24725:   DispatchAsyncProgressEvent(NS_LITERAL_STRING("load"));
15751: }
15751: 
15751: void nsHTMLMediaElement::NetworkError()
15751: {
24155:   mError = new nsHTMLMediaError(nsIDOMHTMLMediaError::MEDIA_ERR_NETWORK);
15751:   mBegun = PR_FALSE;
24725:   DispatchAsyncProgressEvent(NS_LITERAL_STRING("error"));
22787:   mNetworkState = nsIDOMHTMLMediaElement::NETWORK_EMPTY;
24725:   DispatchAsyncSimpleEvent(NS_LITERAL_STRING("emptied"));
25850:   ChangeDelayLoadStatus(PR_FALSE);
15751: }
15751: 
20627: void nsHTMLMediaElement::PlaybackEnded()
15751: {
22783:   NS_ASSERTION(mDecoder->IsEnded(), "Decoder fired ended, but not in ended state");
24725:   DispatchAsyncSimpleEvent(NS_LITERAL_STRING("ended"));
15751: }
15751: 
20627: void nsHTMLMediaElement::SeekStarted()
20627: {
20627:   DispatchAsyncSimpleEvent(NS_LITERAL_STRING("seeking"));
20627: }
20627: 
20627: void nsHTMLMediaElement::SeekCompleted()
20627: {
20627:   mPlayingBeforeSeek = PR_FALSE;
20627:   DispatchAsyncSimpleEvent(NS_LITERAL_STRING("seeked"));
20627: }
20627: 
24155: PRBool nsHTMLMediaElement::ShouldCheckAllowOrigin()
24155: {
24155:   return nsContentUtils::GetBoolPref("media.enforce_same_site_origin",
24155:                                      PR_TRUE);
24155: }
24155: 
24721: // Number of bytes to add to the download size when we're computing
24721: // when the download will finish --- a safety margin in case bandwidth
24721: // or other conditions are worse than expected
24721: static const PRInt32 gDownloadSizeSafetyMargin = 1000000;
24721: 
24919: void nsHTMLMediaElement::UpdateReadyStateForData(NextFrameStatus aNextFrame)
24721: {
24721:   if (mReadyState < nsIDOMHTMLMediaElement::HAVE_METADATA) {
26836:     // aNextFrame might have a next frame because the decoder can advance
26836:     // on its own thread before ResourceLoaded or MetadataLoaded gets
26836:     // a chance to run.
26836:     // The arrival of more data can't change us out of this readyState.
24721:     return;
24721:   }
24721: 
26703:   nsMediaDecoder::Statistics stats = mDecoder->GetStatistics();
26703: 
26703:   if (aNextFrame != NEXT_FRAME_AVAILABLE &&
26703:       !mDecoder->IsEnded() &&
26703:       stats.mDownloadPosition < stats.mTotalBytes) {
24721:     ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA);
24919:     if (!mWaitingFired && aNextFrame == NEXT_FRAME_UNAVAILABLE_BUFFERING) {
24919:       DispatchAsyncSimpleEvent(NS_LITERAL_STRING("waiting"));
24919:       mWaitingFired = PR_TRUE;
24919:     }
24721:     return;
24721:   }
24721: 
24721:   // Now see if we should set HAVE_ENOUGH_DATA
24721:   if (stats.mTotalBytes < 0 || stats.mTotalBytes == stats.mDownloadPosition) {
24721:     // If it's something we don't know the size of, then we can't
24721:     // make an estimate, so let's just go straight to HAVE_ENOUGH_DATA,
24721:     // since otherwise autoplay elements will never play.
24721:     ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA);
24721:     return;
24721:   }
24721: 
24721:   if (stats.mDownloadRateReliable && stats.mPlaybackRateReliable) {
24721:     PRInt64 bytesToDownload = stats.mTotalBytes - stats.mDownloadPosition;
24721:     PRInt64 bytesToPlayback = stats.mTotalBytes - stats.mPlaybackPosition;
24721:     double timeToDownload =
24721:       (bytesToDownload + gDownloadSizeSafetyMargin)/stats.mDownloadRate;
24721:     double timeToPlay = bytesToPlayback/stats.mPlaybackRate;
24721:     if (timeToDownload <= timeToPlay) {
24721:       ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA);
24721:       return;
24721:     }
24721:   }
24721: 
24721:   ChangeReadyState(nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA);
24721: }
24721: 
26326: #ifdef DEBUG
26326: static const char* gReadyStateToString[] = {
26326:   "HAVE_NOTHING",
26326:   "HAVE_METADATA",
26326:   "HAVE_CURRENT_DATA",
26326:   "HAVE_FUTURE_DATA",
26326:   "HAVE_ENOUGH_DATA"
26326: };
26326: #endif
26326: 
15751: void nsHTMLMediaElement::ChangeReadyState(nsMediaReadyState aState)
15751: {
24721:   nsMediaReadyState oldState = mReadyState;
26326:   mReadyState = aState;
26326: 
26326:   if (mNetworkState == nsIDOMHTMLMediaElement::NETWORK_EMPTY || 
26326:       oldState == mReadyState) {
26326:     return;
26326:   }
26326: 
26326:   LOG(PR_LOG_DEBUG, ("Ready state changed to %s", gReadyStateToString[aState]));
24721: 
22787:   // Handle raising of "waiting" event during seek (see 4.8.10.9)
26326:   if (mPlayingBeforeSeek &&
26326:       oldState < nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA) {
20627:     DispatchAsyncSimpleEvent(NS_LITERAL_STRING("waiting"));
24721:   }
20627: 
26326:   if (oldState < nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA &&
26326:       mReadyState >= nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA && 
26326:       !mLoadedFirstFrame)
26326:   {
24721:     DispatchAsyncSimpleEvent(NS_LITERAL_STRING("loadeddata"));
24721:     mLoadedFirstFrame = PR_TRUE;
24721:   }
15751: 
26326:   if (mReadyState == nsIDOMHTMLMediaElement::HAVE_CURRENT_DATA) {
26326:     mWaitingFired = PR_FALSE;
24721:   }
15751: 
26326:   if (oldState < nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA && 
26326:       mReadyState >= nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA) {
24721:     DispatchAsyncSimpleEvent(NS_LITERAL_STRING("canplay"));
24721:   }
26326: 
26836:   if (mReadyState == nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA) {
26836:     NotifyAutoplayDataReady();
15751:   }
26326:   
26326:   if (oldState < nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA && 
26326:       mReadyState >= nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA &&
24721:       IsPotentiallyPlaying()) {
24721:     DispatchAsyncSimpleEvent(NS_LITERAL_STRING("playing"));
24721:   }
26326: 
26326:   if (oldState < nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA &&
26326:       mReadyState >= nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA) {
24918:     DispatchAsyncSimpleEvent(NS_LITERAL_STRING("canplaythrough"));
24918:   }
15751: }
15751: 
26836: void nsHTMLMediaElement::NotifyAutoplayDataReady()
26836: {
26836:   if (mAutoplaying &&
26836:       mPaused &&
26836:       HasAttr(kNameSpaceID_None, nsGkAtoms::autoplay) &&
26836:       mAutoplayEnabled) {
26836:     mPaused = PR_FALSE;
26836:     if (mDecoder) {
26836:       mDecoder->Play();
26836:     }
26836:     DispatchAsyncSimpleEvent(NS_LITERAL_STRING("play"));
26836:   }
26836: }
26836: 
26989: void nsHTMLMediaElement::Paint(gfxContext* aContext,
26989:                                gfxPattern::GraphicsFilter aFilter,
26989:                                const gfxRect& aRect) 
15751: {
15751:   if (mDecoder)
26989:     mDecoder->Paint(aContext, aFilter, aRect);
15751: }
15751: 
15751: nsresult nsHTMLMediaElement::DispatchSimpleEvent(const nsAString& aName)
15751: {
15751:   return nsContentUtils::DispatchTrustedEvent(GetOwnerDoc(), 
15751:                                               static_cast<nsIContent*>(this), 
15751:                                               aName, 
15751:                                               PR_TRUE, 
15751:                                               PR_TRUE);
15751: }
15751: 
15751: nsresult nsHTMLMediaElement::DispatchAsyncSimpleEvent(const nsAString& aName)
15751: {
15751:   nsCOMPtr<nsIRunnable> event = new nsAsyncEventRunner(aName, this, PR_FALSE);
15751:   NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL); 
15751:   return NS_OK;                           
15751: }
15751: 
15751: nsresult nsHTMLMediaElement::DispatchAsyncProgressEvent(const nsAString& aName)
15751: {
15751:   nsCOMPtr<nsIRunnable> event = new nsAsyncEventRunner(aName, this, PR_TRUE);
15751:   NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL); 
15751:   return NS_OK;                           
15751: }
15751: 
15751: nsresult nsHTMLMediaElement::DispatchProgressEvent(const nsAString& aName)
15751: {
15751:   nsCOMPtr<nsIDOMDocumentEvent> docEvent(do_QueryInterface(GetOwnerDoc()));
15751:   nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(static_cast<nsIContent*>(this)));
15751:   NS_ENSURE_TRUE(docEvent && target, NS_ERROR_INVALID_ARG);
15751: 
15751:   nsCOMPtr<nsIDOMEvent> event;
15751:   nsresult rv = docEvent->CreateEvent(NS_LITERAL_STRING("ProgressEvent"), getter_AddRefs(event));
15751:   NS_ENSURE_SUCCESS(rv, rv);
15751:   
15751:   nsCOMPtr<nsIDOMProgressEvent> progressEvent(do_QueryInterface(event));
15751:   NS_ENSURE_TRUE(progressEvent, NS_ERROR_FAILURE);
15751: 
25001:   PRInt64 totalBytes = 0;
25001:   PRUint64 downloadPosition = 0;
25001:   if (mDecoder) {
24721:     nsMediaDecoder::Statistics stats = mDecoder->GetStatistics();
25001:     totalBytes = stats.mTotalBytes;
25001:     downloadPosition = stats.mDownloadPosition;
25001:   }
23763:   rv = progressEvent->InitProgressEvent(aName, PR_TRUE, PR_TRUE,
25001:     totalBytes >= 0, downloadPosition, totalBytes);
15751:   NS_ENSURE_SUCCESS(rv, rv);
15751: 
15751:   PRBool dummy;
15751:   return target->DispatchEvent(event, &dummy);  
15751: }
15751: 
15751: nsresult nsHTMLMediaElement::DoneAddingChildren(PRBool aHaveNotified)
15751: {
15751:   if (!mIsDoneAddingChildren) {
15751:     mIsDoneAddingChildren = PR_TRUE;
15751:   
22787:     if (mNetworkState == nsIDOMHTMLMediaElement::NETWORK_EMPTY) {
25849:       QueueSelectResourceTask();
15751:     }
15751:   }
15751: 
15751:   return NS_OK;
15751: }
15751: 
15751: PRBool nsHTMLMediaElement::IsDoneAddingChildren()
15751: {
15751:   return mIsDoneAddingChildren;
15751: }
18910: 
22787: PRBool nsHTMLMediaElement::IsPotentiallyPlaying() const
20627: {
20627:   // TODO: 
20627:   //   playback has not stopped due to errors, 
20627:   //   and the element has not paused for user interaction
20627:   return 
20627:     !mPaused && 
22787:     (mReadyState == nsIDOMHTMLMediaElement::HAVE_ENOUGH_DATA ||
22787:     mReadyState == nsIDOMHTMLMediaElement::HAVE_FUTURE_DATA) &&
20627:     !IsPlaybackEnded();
20627: }
22783: 
20627: PRBool nsHTMLMediaElement::IsPlaybackEnded() const
20627: {
20627:   // TODO:
25849:   //   the current playback position is equal to the effective end of the media resource.
20627:   //   See bug 449157.
22787:   return mNetworkState >= nsIDOMHTMLMediaElement::HAVE_METADATA &&
22783:     mDecoder ? mDecoder->IsEnded() : PR_FALSE;
20627: }
20627: 
26836: already_AddRefed<nsIPrincipal> nsHTMLMediaElement::GetCurrentPrincipal()
18910: {
18910:   if (!mDecoder)
18910:     return nsnull;
18910: 
18910:   return mDecoder->GetCurrentPrincipal();
18910: }
19770: 
20627: void nsHTMLMediaElement::UpdateMediaSize(nsIntSize size)
20627: {
20627:   mMediaSize = size;
20627: }
20627: 
19770: void nsHTMLMediaElement::DestroyContent()
19770: {
19770:   if (mDecoder) {
20627:     mDecoder->Shutdown();
19770:     mDecoder = nsnull;
19770:   }
22826:   if (mChannel) {
22826:     mChannel->Cancel(NS_BINDING_ABORTED);
22826:     mChannel = nsnull;
22826:   }
19770:   nsGenericHTMLElement::DestroyContent();
19770: }
21006: 
21006: void nsHTMLMediaElement::Freeze()
21006: {
21006:   mPausedBeforeFreeze = mPaused;
21006:   if (!mPaused) {
21006:     Pause();
21006:   }
24020:   if (mDecoder) {
24020:     mDecoder->Suspend();
24020:   }
21006: }
21006: 
21006: void nsHTMLMediaElement::Thaw()
21006: {
21006:   if (!mPausedBeforeFreeze) {
21006:     Play();
21006:   }
24020: 
24020:   if (mDecoder) {
24020:     mDecoder->Resume();
21006:   }
24020: }
25018: 
25018: PRBool
25018: nsHTMLMediaElement::IsNodeOfType(PRUint32 aFlags) const
25018: {
25018:   return !(aFlags & ~(eCONTENT | eELEMENT | eHTML | eMEDIA));
25018: }
25018: 
25018: void nsHTMLMediaElement::NotifyAddedSource()
25018: {
25849:   if (mLoadWaitStatus == WAITING_FOR_SRC_OR_SOURCE) {
25849:     QueueSelectResourceTask();
25849:   } else if (mLoadWaitStatus == WAITING_FOR_SOURCE) { 
25849:     QueueLoadFromSourceTask();
25018:   }
25018: }
25849: 
25849: already_AddRefed<nsIURI> nsHTMLMediaElement::GetNextSource()
25849: {
25849:   nsresult rv = NS_OK;
25849:   nsCOMPtr<nsIDOMNode> thisDomNode = do_QueryInterface(this);
25849: 
25849:   if (!mSourcePointer) {
25849:     // First time this has been run, create a selection to cover children.
25849:     mSourcePointer = do_CreateInstance("@mozilla.org/content/range;1");
25849: 
25849:     rv = mSourcePointer->SelectNodeContents(thisDomNode);
25849:     if (NS_FAILED(rv)) return nsnull;
25849: 
25849:     rv = mSourcePointer->Collapse(PR_TRUE);
25849:     if (NS_FAILED(rv)) return nsnull;
25849:   }
25849: 
25849:   while (PR_TRUE) {
25849: #ifdef DEBUG
25849:     nsCOMPtr<nsIDOMNode> startContainer;
25849:     rv = mSourcePointer->GetStartContainer(getter_AddRefs(startContainer));
25849:     if (NS_FAILED(rv)) return nsnull;
25849:     NS_ASSERTION(startContainer == thisDomNode,
25849:                 "Should only iterate over direct children");
25849: #endif
25849: 
25849:     PRInt32 startOffset = 0;
25849:     rv = mSourcePointer->GetStartOffset(&startOffset);
25849:     NS_ENSURE_SUCCESS(rv, nsnull);
25849: 
25849:     if (startOffset == GetChildCount())
25849:       return nsnull; // No more children.
25849: 
25849:     // Advance the range to the next child.
25849:     rv = mSourcePointer->SetStart(thisDomNode, startOffset+1);
25849:     NS_ENSURE_SUCCESS(rv, nsnull);
25849: 
25849:     nsIContent* child = GetChildAt(startOffset);
25849: 
25849:     // If child is a <source> element, it may be the next candidate.
25849:     if (child &&
25849:         child->Tag() == nsGkAtoms::source &&
25849:         child->IsNodeOfType(nsINode::eHTML))
25849:     {
25849:       nsCOMPtr<nsIURI> uri;
25849:       nsAutoString src,type;
25849: 
25849:       // Must have src attribute.
25849:       if (!child->GetAttr(kNameSpaceID_None, nsGkAtoms::src, src))
25849:         continue;
25849: 
25849:       // If we have a type attribute, it must be a supported type.
25849:       if (child->GetAttr(kNameSpaceID_None, nsGkAtoms::type, type) &&
25849:           GetCanPlay(type) == CANPLAY_NO)
25849:         continue;
25849:       
25849:       NewURIFromString(src, getter_AddRefs(uri));
25849:       return uri.forget();
25849:     }
25849:   }
25849:   NS_NOTREACHED("Execution should not reach here!");
25849:   return nsnull;
25849: }
25850: 
25850: void nsHTMLMediaElement::ChangeDelayLoadStatus(PRBool aDelay) {
25850:   if (mDelayingLoadEvent == aDelay)
25850:     return;
25850: 
25850:   LOG(PR_LOG_DEBUG, ("ChangeDelayLoadStatus(%d) doc=0x%p", aDelay, mLoadBlockedDoc.get()));
25850:   mDelayingLoadEvent = aDelay;
25850: 
25850:   if (aDelay) {
25850:     mLoadBlockedDoc = GetOwnerDoc();
25850:     mLoadBlockedDoc->BlockOnload();
25850:   } else {
27217:     if (mDecoder) {
27217:       mDecoder->MoveLoadsToBackground();
27217:     }
25850:     NS_ASSERTION(mLoadBlockedDoc, "Need a doc to block on");
25850:     mLoadBlockedDoc->UnblockOnload(PR_FALSE);
25850:     mLoadBlockedDoc = nsnull;
25850:   }
25850: }
27217: 
27217: already_AddRefed<nsILoadGroup> nsHTMLMediaElement::GetDocumentLoadGroup()
27217: {
27217:   nsIDocument* doc = GetOwnerDoc();
27217:   return doc ? doc->GetDocumentLoadGroup() : nsnull;
27217: }
