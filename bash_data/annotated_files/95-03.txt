 1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 1: /* ***** BEGIN LICENSE BLOCK *****
 1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 1:  *
 1:  * The contents of this file are subject to the Mozilla Public License Version
 1:  * 1.1 (the "License"); you may not use this file except in compliance with
 1:  * the License. You may obtain a copy of the License at
 1:  * http://www.mozilla.org/MPL/
 1:  *
 1:  * Software distributed under the License is distributed on an "AS IS" basis,
 1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 1:  * for the specific language governing rights and limitations under the
 1:  * License.
 1:  *
 1:  * The Original Code is Mozilla Communicator client code.
 1:  *
 1:  * The Initial Developer of the Original Code is
 1:  * Netscape Communications Corporation.
 1:  * Portions created by the Initial Developer are Copyright (C) 1998
 1:  * the Initial Developer. All Rights Reserved.
 1:  *
 1:  * Contributor(s):
 1:  *   Pierre Phaneuf <pp@ludusdesign.com>
 1:  *
 1:  * Alternatively, the contents of this file may be used under the terms of
 1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
 1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 1:  * in which case the provisions of the GPL or the LGPL are applicable instead
 1:  * of those above. If you wish to allow use of your version of this file only
 1:  * under the terms of either the GPL or the LGPL, and not to allow others to
 1:  * use your version of this file under the terms of the MPL, indicate your
 1:  * decision by deleting the provisions above and replace them with the notice
 1:  * and other provisions required by the GPL or the LGPL. If you do not delete
 1:  * the provisions above, a recipient may use your version of this file under
 1:  * the terms of any one of the MPL, the GPL or the LGPL.
 1:  *
 1:  * ***** END LICENSE BLOCK ***** */
 1: #include "nsCOMPtr.h"
 1: #include "nsIDOMHTMLInputElement.h"
 1: #include "nsIDOMNSHTMLInputElement.h"
 1: #include "nsITextControlElement.h"
 1: #include "nsIFileControlElement.h"
 1: #include "nsIDOMNSEditableElement.h"
 1: #include "nsIRadioControlElement.h"
 1: #include "nsIRadioVisitor.h"
 1: #include "nsIPhonetic.h"
 1: 
 1: #include "nsIControllers.h"
 1: #include "nsIFocusController.h"
 1: #include "nsPIDOMWindow.h"
 1: #include "nsContentCID.h"
 1: #include "nsIComponentManager.h"
 1: #include "nsIDOMHTMLFormElement.h"
 1: #include "nsIDOMEventReceiver.h"
 1: #include "nsGenericHTMLElement.h"
 1: #include "nsGkAtoms.h"
 1: #include "nsStyleConsts.h"
 1: #include "nsPresContext.h"
 1: #include "nsMappedAttributes.h"
 1: #include "nsIFormControl.h"
 1: #include "nsIForm.h"
 1: #include "nsIFormSubmission.h"
 1: #include "nsITextControlFrame.h"
 1: #include "nsIRadioControlFrame.h"
 1: #include "nsIDocument.h"
 1: #include "nsIPresShell.h"
 1: #include "nsIFormControlFrame.h"
 1: #include "nsIFrame.h"
 1: #include "nsIEventStateManager.h"
 1: #include "nsIServiceManager.h"
 1: #include "nsIScriptSecurityManager.h"
 1: #include "nsDOMError.h"
 1: #include "nsIPrivateDOMEvent.h"
 1: #include "nsIEditor.h"
 1: #include "nsGUIEvent.h"
 1: 
 1: #include "nsPresState.h"
 1: #include "nsLayoutErrors.h"
 1: #include "nsIDOMEvent.h"
 1: #include "nsIDOMNSEvent.h"
 1: #include "nsIDOMNodeList.h"
 1: #include "nsIDOMHTMLCollection.h"
 1: #include "nsICheckboxControlFrame.h"
 1: #include "nsLinebreakConverter.h" //to strip out carriage returns
 1: #include "nsReadableUtils.h"
 1: #include "nsUnicharUtils.h"
 1: #include "nsEventDispatcher.h"
 1: #include "nsLayoutUtils.h"
 1: 
 1: #include "nsIDOMMutationEvent.h"
 1: #include "nsIDOMEventReceiver.h"
 1: #include "nsMutationEvent.h"
 1: #include "nsIEventListenerManager.h"
 1: 
 1: #include "nsRuleData.h"
 1: 
 1: // input type=radio
 1: #include "nsIRadioControlFrame.h"
 1: #include "nsIRadioGroupContainer.h"
 1: 
 1: // input type=file
 1: #include "nsIMIMEService.h"
 1: #include "nsCExternalHandlerService.h"
 1: #include "nsIFile.h"
 1: #include "nsILocalFile.h"
 1: #include "nsIFileStreams.h"
 1: #include "nsNetUtil.h"
 1: 
 1: // input type=image
 1: #include "nsImageLoadingContent.h"
 1: #include "nsIDOMWindowInternal.h"
 1: 
 1: // XXX align=left, hspace, vspace, border? other nav4 attrs
 1: 
 1: static NS_DEFINE_CID(kXULControllersCID,  NS_XULCONTROLLERS_CID);
 1: //
 1: // Accessors for mBitField
 1: //
 1: #define BF_DISABLED_CHANGED 0
 1: #define BF_HANDLING_CLICK 1
 1: #define BF_VALUE_CHANGED 2
 1: #define BF_CHECKED_CHANGED 3
 1: #define BF_CHECKED 4
 1: #define BF_HANDLING_SELECT_EVENT 5
 1: #define BF_SHOULD_INIT_CHECKED 6
 1: #define BF_PARSER_CREATING 7
 1: #define BF_IN_INTERNAL_ACTIVATE 8
 1: #define BF_CHECKED_IS_TOGGLED 9
 1: 
 1: #define GET_BOOLBIT(bitfield, field) (((bitfield) & (0x01 << (field))) \
 1:                                         ? PR_TRUE : PR_FALSE)
 1: #define SET_BOOLBIT(bitfield, field, b) ((b) \
 1:                                         ? ((bitfield) |=  (0x01 << (field))) \
 1:                                         : ((bitfield) &= ~(0x01 << (field))))
 1: 
 1: // First bits are needed for the control type.
 1: #define NS_OUTER_ACTIVATE_EVENT   (1 << 9)
 1: #define NS_ORIGINAL_CHECKED_VALUE (1 << 10)
 1: #define NS_NO_CONTENT_DISPATCH    (1 << 11)
 1: #define NS_CONTROL_TYPE(bits)  ((bits) & ~( \
 1:   NS_OUTER_ACTIVATE_EVENT | NS_ORIGINAL_CHECKED_VALUE | NS_NO_CONTENT_DISPATCH))
 1: 
 1: static const char kWhitespace[] = "\n\r\t\b";
 1: 
 1: class nsHTMLInputElement : public nsGenericHTMLFormElement,
 1:                            public nsImageLoadingContent,
 1:                            public nsIDOMHTMLInputElement,
 1:                            public nsIDOMNSHTMLInputElement,
 1:                            public nsITextControlElement,
 1:                            public nsIRadioControlElement,
 1:                            public nsIPhonetic,
 1:                            public nsIDOMNSEditableElement,
 1:                            public nsIFileControlElement
 1: {
 1: public:
 1:   nsHTMLInputElement(nsINodeInfo *aNodeInfo, PRBool aFromParser);
 1:   virtual ~nsHTMLInputElement();
 1: 
 1:   // nsISupports
 1:   NS_DECL_ISUPPORTS_INHERITED
 1: 
 1:   // nsIDOMNode
 1:   NS_FORWARD_NSIDOMNODE(nsGenericHTMLFormElement::)
 1: 
 1:   // nsIDOMElement
 1:   NS_FORWARD_NSIDOMELEMENT(nsGenericHTMLFormElement::)
 1: 
 1:   // nsIDOMHTMLElement
 1:   NS_FORWARD_NSIDOMHTMLELEMENT(nsGenericHTMLFormElement::)
 1: 
 1:   // nsIDOMHTMLInputElement
 1:   NS_DECL_NSIDOMHTMLINPUTELEMENT
 1: 
 1:   // nsIDOMNSHTMLInputElement
 1:   NS_DECL_NSIDOMNSHTMLINPUTELEMENT
 1: 
 1:   // nsIPhonetic
 1:   NS_DECL_NSIPHONETIC
 1: 
 1:   // nsIDOMNSEditableElement
 1:   NS_FORWARD_NSIDOMNSEDITABLEELEMENT(nsGenericHTMLElement::)
 1: 
 1:   // Overriden nsIFormControl methods
 1:   NS_IMETHOD_(PRInt32) GetType() const { return mType; }
 1:   NS_IMETHOD Reset();
 1:   NS_IMETHOD SubmitNamesValues(nsIFormSubmission* aFormSubmission,
 1:                                nsIContent* aSubmitElement);
 1:   NS_IMETHOD SaveState();
 1:   virtual PRBool RestoreState(nsPresState* aState);
 1:   virtual PRBool AllowDrop();
 1: 
 1:   // nsIContent
 1:   virtual void SetFocus(nsPresContext* aPresContext);
 1:   virtual PRBool IsFocusable(PRInt32 *aTabIndex = nsnull);
 1: 
 1:   virtual PRBool ParseAttribute(PRInt32 aNamespaceID,
 1:                                 nsIAtom* aAttribute,
 1:                                 const nsAString& aValue,
 1:                                 nsAttrValue& aResult);
 1:   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
 1:                                               PRInt32 aModType) const;
 1:   NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;
 1:   virtual nsMapRuleToAttributesFunc GetAttributeMappingFunction() const;
 1: 
 1:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
 1:   virtual nsresult PostHandleEvent(nsEventChainPostVisitor& aVisitor);
 1: 
 1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
 1:                               nsIContent* aBindingParent,
 1:                               PRBool aCompileEventHandlers);
 1:   virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
 1:                               PRBool aNullParent = PR_TRUE);
 1:   
 1:   virtual void DoneCreatingElement();
 1: 
 1:   virtual PRInt32 IntrinsicState() const;
 1: 
 1:   // nsITextControlElement
 1:   NS_IMETHOD TakeTextFrameValue(const nsAString& aValue);
 1:   NS_IMETHOD SetValueChanged(PRBool aValueChanged);
 1:   
 1:   // nsIFileControlElement
 1:   virtual void GetFileName(nsAString& aFileName);
 1:   virtual void SetFileName(const nsAString& aFileName);
 1: 
 1:   // nsIRadioControlElement
 1:   NS_IMETHOD RadioSetChecked(PRBool aNotify);
 1:   NS_IMETHOD SetCheckedChanged(PRBool aCheckedChanged);
 1:   NS_IMETHOD SetCheckedChangedInternal(PRBool aCheckedChanged);
 1:   NS_IMETHOD GetCheckedChanged(PRBool* aCheckedChanged);
 1:   NS_IMETHOD AddedToRadioGroup(PRBool aNotify = PR_TRUE);
 1:   NS_IMETHOD WillRemoveFromRadioGroup();
 1:   /**
 1:    * Get the radio group container for this button (form or document)
 1:    * @return the radio group container (or null if no form or document)
 1:    */
 1:   virtual already_AddRefed<nsIRadioGroupContainer> GetRadioGroupContainer();
 1: 
 1:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const;
 1: 
 1:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsHTMLInputElement,
 1:                                                      nsGenericHTMLFormElement)
 1: 
 1: protected:
 1:   // Helper method
 1:   nsresult SetValueInternal(const nsAString& aValue,
 1:                             nsITextControlFrame* aFrame);
 1: 
 1:   nsresult GetSelectionRange(PRInt32* aSelectionStart, PRInt32* aSelectionEnd);
 1: 
 1:   /**
 1:    * Get the name if it exists and return whether it did exist
 1:    * @param aName the name returned [OUT]
 1:    * @param true if the name existed, false if not
 1:    */
 1:   PRBool GetNameIfExists(nsAString& aName) {
 1:     return GetAttr(kNameSpaceID_None, nsGkAtoms::name, aName);
 1:   }
 1: 
 1:   /**
 1:    * Called when an attribute is about to be changed
 1:    */
 1:   virtual nsresult BeforeSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 1:                                  const nsAString* aValue, PRBool aNotify);
 1:   /**
 1:    * Called when an attribute has just been changed
 1:    */
 1:   virtual nsresult AfterSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 1:                                 const nsAString* aValue, PRBool aNotify);
 1: 
 1:   void SelectAll(nsPresContext* aPresContext);
 1:   PRBool IsImage() const
 1:   {
 1:     return AttrValueIs(kNameSpaceID_None, nsGkAtoms::type,
 1:                        nsGkAtoms::image, eIgnoreCase);
 1:   }
 1: 
 1:   /**
 1:    * Fire the onChange event
 1:    */
 1:   void FireOnChange();
 1: 
 1:   /**
 1:    * Visit a the group of radio buttons this radio belongs to
 1:    * @param aVisitor the visitor to visit with
 1:    */
 1:   nsresult VisitGroup(nsIRadioVisitor* aVisitor, PRBool aFlushContent);
 1: 
 1:   /**
 1:    * Do all the work that |SetChecked| does (radio button handling, etc.), but
 1:    * take an |aNotify| parameter.
 1:    */
 1:   nsresult DoSetChecked(PRBool aValue, PRBool aNotify = PR_TRUE);
 1: 
 1:   /**
 1:    * Do all the work that |SetCheckedChanged| does (radio button handling,
 1:    * etc.), but take an |aNotify| parameter that lets it avoid flushing content
 1:    * when it can.
 1:    */
 1:   nsresult DoSetCheckedChanged(PRBool aCheckedChanged, PRBool aNotify);
 1: 
 1:   /**
 1:    * Actually set checked and notify the frame of the change.
 1:    * @param aValue the value of checked to set
 1:    */
 1:   nsresult SetCheckedInternal(PRBool aValue, PRBool aNotify);
 1: 
 1:   /**
 1:    * MaybeSubmitForm looks for a submit input or a single text control
 1:    * and submits the form if either is present.
 1:    */
 1:   nsresult MaybeSubmitForm(nsPresContext* aPresContext);
 1:   
 1:   nsCOMPtr<nsIControllers> mControllers;
 1: 
 1:   /**
 1:    * The type of this input (<input type=...>) as an integer.
 1:    * @see nsIFormControl.h (specifically NS_FORM_INPUT_*)
 1:    */
 1:   PRInt8                   mType;
 1:   /**
 1:    * A bitfield containing our booleans
 1:    * @see GET_BOOLBIT / SET_BOOLBIT macros and BF_* field identifiers
 1:    */
 1:   PRInt16                  mBitField;
 1:   /**
 1:    * The current value of the input if it has been changed from the default
 1:    */
 1:   char*                    mValue;
 1:   /**
 1:    * The value of the input if it is a file input. This is the filename used
 1:    * when uploading a file. It is vital that this is kept separate from mValue
 1:    * so that it won't be possible to 'leak' the value from a text-input to a
 1:    * file-input. Additionally, the logic for this value is kept as simple as
 1:    * possible to avoid accidental errors where the wrong filename is used.
 1:    * Therefor the filename is always owned by this member, never by the frame.
 1:    * Whenever the frame wants to change the filename it has to call
 1:    * SetFileName to update this member.
 1:    */
 1:   nsAutoPtr<nsString>      mFileName;
 1: };
 1: 
 1: #ifdef ACCESSIBILITY
 1: //Helper method
 1: static nsresult FireEventForAccessibility(nsIDOMHTMLInputElement* aTarget,
 1:                                           nsPresContext* aPresContext,
 1:                                           const nsAString& aEventType);
 1: #endif
 1: 
 1: //
 1: // construction, destruction
 1: //
 1: 
 1: NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER(Input)
 1: 
 1: nsHTMLInputElement::nsHTMLInputElement(nsINodeInfo *aNodeInfo,
 1:                                        PRBool aFromParser)
 1:   : nsGenericHTMLFormElement(aNodeInfo),
 1:     mType(NS_FORM_INPUT_TEXT), // default value
 1:     mBitField(0),
 1:     mValue(nsnull)
 1: {
 1:   SET_BOOLBIT(mBitField, BF_PARSER_CREATING, aFromParser);
 1: }
 1: 
 1: nsHTMLInputElement::~nsHTMLInputElement()
 1: {
 1:   DestroyImageLoadingContent();
 1:   if (mValue) {
 1:     nsMemory::Free(mValue);
 1:   }
 1: }
 1: 
 1: 
 1: // nsISupports
 1: 
 1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLInputElement)
 1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLInputElement,
 1:                                                   nsGenericHTMLFormElement)
 1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mControllers)
 1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 1: 
 1: NS_IMPL_ADDREF_INHERITED(nsHTMLInputElement, nsGenericElement) 
 1: NS_IMPL_RELEASE_INHERITED(nsHTMLInputElement, nsGenericElement) 
 1: 
 1: 
 1: // QueryInterface implementation for nsHTMLInputElement
 1: NS_HTML_CONTENT_CC_INTERFACE_MAP_BEGIN(nsHTMLInputElement,
 1:                                        nsGenericHTMLFormElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMHTMLInputElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSHTMLInputElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsITextControlElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIFileControlElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIRadioControlElement)
 1:   NS_INTERFACE_MAP_ENTRY(nsIPhonetic)
 1:   NS_INTERFACE_MAP_ENTRY(imgIDecoderObserver)
 1:   NS_INTERFACE_MAP_ENTRY(nsIImageLoadingContent)
 1:   NS_INTERFACE_MAP_ENTRY(nsIDOMNSEditableElement)
 1:   NS_INTERFACE_MAP_ENTRY_CONTENT_CLASSINFO(HTMLInputElement)
 1: NS_HTML_CONTENT_INTERFACE_MAP_END
 1: 
 1: 
 1: // nsIDOMNode
 1: 
 1: nsresult
 1: nsHTMLInputElement::Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
 1: {
 1:   *aResult = nsnull;
 1: 
 1:   nsHTMLInputElement *it = new nsHTMLInputElement(aNodeInfo, PR_FALSE);
 1:   if (!it) {
 1:     return NS_ERROR_OUT_OF_MEMORY;
 1:   }
 1: 
 1:   nsCOMPtr<nsINode> kungFuDeathGrip = it;
 1:   nsresult rv = CopyInnerTo(it);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   switch (mType) {
 1:     case NS_FORM_INPUT_TEXT:
 1:     case NS_FORM_INPUT_PASSWORD:
 1:       if (GET_BOOLBIT(mBitField, BF_VALUE_CHANGED)) {
 1:         // We don't have our default value anymore.  Set our value on
 1:         // the clone.
 1:         // XXX GetValue should be const
 1:         nsAutoString value;
 1:         NS_CONST_CAST(nsHTMLInputElement*, this)->GetValue(value);
 1:         // SetValueInternal handles setting the VALUE_CHANGED bit for us
 1:         it->SetValueInternal(value, nsnull);
 1:       }
 1:       break;
 1:     case NS_FORM_INPUT_FILE:
 1:       if (mFileName) {
 1:         it->mFileName = new nsString(*mFileName);
 1:       }
 1:       break;
 1:     case NS_FORM_INPUT_RADIO:
 1:     case NS_FORM_INPUT_CHECKBOX:
 1:       if (GET_BOOLBIT(mBitField, BF_CHECKED_CHANGED)) {
 1:         // We no longer have our original checked state.  Set our
 1:         // checked state on the clone.
 1:         // XXX GetChecked should be const
 1:         PRBool checked;
 1:         NS_CONST_CAST(nsHTMLInputElement*, this)->GetChecked(&checked);
 1:         it->DoSetChecked(checked, PR_FALSE);
 1:       }
 1:       break;
 1:     default:
 1:       break;
 1:   }
 1: 
 1:   kungFuDeathGrip.swap(*aResult);
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::BeforeSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 1:                                   const nsAString* aValue,
 1:                                   PRBool aNotify)
 1: {
 1:   if (aNameSpaceID == kNameSpaceID_None) {
 1:     //
 1:     // When name or type changes, radio should be removed from radio group.
 1:     // (type changes are handled in the form itself currently)
 1:     // If the parser is not done creating the radio, we also should not do it.
 1:     //
 1:     if ((aName == nsGkAtoms::name ||
 1:          (aName == nsGkAtoms::type && !mForm)) &&
 1:         mType == NS_FORM_INPUT_RADIO &&
 1:         (mForm || !(GET_BOOLBIT(mBitField, BF_PARSER_CREATING)))) {
 1:       WillRemoveFromRadioGroup();
 1:     } else if (aNotify && aName == nsGkAtoms::src &&
 1:                aValue && mType == NS_FORM_INPUT_IMAGE) {
 1:       // Null value means the attr got unset; don't trigger on that
 1:       LoadImage(*aValue, PR_TRUE, aNotify);
 1:     } else if (aNotify && aName == nsGkAtoms::disabled) {
 1:       SET_BOOLBIT(mBitField, BF_DISABLED_CHANGED, PR_TRUE);
 1:     }
 1:   }
 1: 
 1:   return nsGenericHTMLFormElement::BeforeSetAttr(aNameSpaceID, aName,
 1:                                                  aValue, aNotify);
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::AfterSetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
 1:                                  const nsAString* aValue,
 1:                                  PRBool aNotify)
 1: {
 1:   if (aNameSpaceID == kNameSpaceID_None) {
 1:     //
 1:     // When name or type changes, radio should be added to radio group.
 1:     // (type changes are handled in the form itself currently)
 1:     // If the parser is not done creating the radio, we also should not do it.
 1:     //
 1:     if ((aName == nsGkAtoms::name ||
 1:          (aName == nsGkAtoms::type && !mForm)) &&
 1:         mType == NS_FORM_INPUT_RADIO &&
 1:         (mForm || !(GET_BOOLBIT(mBitField, BF_PARSER_CREATING)))) {
 1:       AddedToRadioGroup();
 1:     }
 1: 
 1:     //
 1:     // Some elements have to change their value when the value and checked
 1:     // attributes change (but they only do so when ValueChanged() and
 1:     // CheckedChanged() are false--i.e. the value has not been changed by the
 1:     // user or by JS)
 1:     //
 1:     // We only really need to call reset for the value so that the text control
 1:     // knows the new value.  No other reason.
 1:     //
 1:     if (aName == nsGkAtoms::value &&
 1:         !GET_BOOLBIT(mBitField, BF_VALUE_CHANGED) &&
 1:         (mType == NS_FORM_INPUT_TEXT ||
 1:          mType == NS_FORM_INPUT_PASSWORD ||
 1:          mType == NS_FORM_INPUT_FILE)) {
 1:       Reset();
 1:     }
 1:     //
 1:     // Checked must be set no matter what type of control it is, since
 1:     // GetChecked() must reflect the new value
 1:     if (aName == nsGkAtoms::checked) {
 1:       if (aNotify &&
 1:           (mType == NS_FORM_INPUT_RADIO || mType == NS_FORM_INPUT_CHECKBOX)) {
 1:         // the checked attribute being changed, no matter the current checked
 1:         // state, influences the :default state, so notify about changes
 1:         nsIDocument* document = GetCurrentDoc();
 1:         if (document) {
 1:           MOZ_AUTO_DOC_UPDATE(document, UPDATE_CONTENT_STATE, aNotify);
 1:           document->ContentStatesChanged(this, nsnull, NS_EVENT_STATE_DEFAULT);
 1:         }
 1:       }
 1:       if (!GET_BOOLBIT(mBitField, BF_CHECKED_CHANGED)) {
 1:         // Delay setting checked if the parser is creating this element (wait
 1:         // until everything is set)
 1:         if (GET_BOOLBIT(mBitField, BF_PARSER_CREATING)) {
 1:           SET_BOOLBIT(mBitField, BF_SHOULD_INIT_CHECKED, PR_TRUE);
 1:         } else {
 1:           PRBool defaultChecked;
 1:           GetDefaultChecked(&defaultChecked);
 1:           DoSetChecked(defaultChecked);
 1:           SetCheckedChanged(PR_FALSE);
 1:         }
 1:       }
 1:     }
 1: 
 1:     if (aName == nsGkAtoms::type) {
 1:       // Changing type means notifying on state changes.  Just start a batch
 1:       // now.
 1:       nsIDocument* document = GetCurrentDoc();
 1:       MOZ_AUTO_DOC_UPDATE(document, UPDATE_CONTENT_STATE, aNotify);
 1:       
 1:       if (!aValue) {
 1:         // We're now a text input.  Note that we have to handle this manually,
 1:         // since removing an attribute (which is what happened, since aValue is
 1:         // null) doesn't call ParseAttribute.
 1:         mType = NS_FORM_INPUT_TEXT;
 1:       }
 1:     
 1:       // If we are changing type from File/Text/Passwd to other input types
 1:       // we need save the mValue into value attribute
 1:       if (mValue &&
 1:           mType != NS_FORM_INPUT_TEXT &&
 1:           mType != NS_FORM_INPUT_PASSWORD &&
 1:           mType != NS_FORM_INPUT_FILE) {
 1:         SetAttr(kNameSpaceID_None, nsGkAtoms::value,
 1:                 NS_ConvertUTF8toUTF16(mValue), PR_FALSE);
 1:         if (mValue) {
 1:           nsMemory::Free(mValue);
 1:           mValue = nsnull;
 1:         }
 1:       }
 1: 
 1:       if (mType != NS_FORM_INPUT_IMAGE) {
 1:         // We're no longer an image input.  Cancel our image requests, if we have
 1:         // any.  Note that doing this when we already weren't an image is ok --
 1:         // just does nothing.
 1:         CancelImageRequests(aNotify);
 1:       } else if (aNotify) {
 1:         // We just got switched to be an image input; we should see
 1:         // whether we have an image to load;
 1:         nsAutoString src;
 1:         if (GetAttr(kNameSpaceID_None, nsGkAtoms::src, src)) {
 1:           LoadImage(src, PR_FALSE, aNotify);
 1:         }
 1:       }
 1: 
 1:       if (aNotify && document) {
 1:         // Changing type affects the applicability of some states.  Just notify
 1:         // on them all now, just in case.  Note that we can't rely on the
 1:         // notifications LoadImage or CancelImageRequests might have sent,
 1:         // because those didn't include all the possibly-changed states in the
 1:         // mask.
 1:         document->ContentStatesChanged(this, nsnull,
 1:                                        NS_EVENT_STATE_CHECKED |
 1:                                        NS_EVENT_STATE_DEFAULT |
 1:                                        NS_EVENT_STATE_BROKEN |
 1:                                        NS_EVENT_STATE_USERDISABLED |
 1:                                        NS_EVENT_STATE_SUPPRESSED |
 1:                                        NS_EVENT_STATE_LOADING);
 1:       }
 1:     }
 1:   }
 1: 
 1:   return nsGenericHTMLFormElement::AfterSetAttr(aNameSpaceID, aName,
 1:                                                 aValue, aNotify);
 1: }
 1: 
 1: // nsIDOMHTMLInputElement
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::GetForm(nsIDOMHTMLFormElement** aForm)
 1: {
 1:   return nsGenericHTMLFormElement::GetForm(aForm);
 1: }
 1: 
 1: //NS_IMPL_STRING_ATTR(nsHTMLInputElement, DefaultValue, value)
 1: NS_IMPL_BOOL_ATTR(nsHTMLInputElement, DefaultChecked, checked)
 1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, Accept, accept)
 1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, AccessKey, accesskey)
 1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, Align, align)
 1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, Alt, alt)
 1: //NS_IMPL_BOOL_ATTR(nsHTMLInputElement, Checked, checked)
 1: NS_IMPL_BOOL_ATTR(nsHTMLInputElement, Disabled, disabled)
 1: NS_IMPL_INT_ATTR(nsHTMLInputElement, MaxLength, maxlength)
 1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, Name, name)
 1: NS_IMPL_BOOL_ATTR(nsHTMLInputElement, ReadOnly, readonly)
 1: NS_IMPL_URI_ATTR(nsHTMLInputElement, Src, src)
 1: NS_IMPL_INT_ATTR_DEFAULT_VALUE(nsHTMLInputElement, TabIndex, tabindex, 0)
 1: NS_IMPL_STRING_ATTR(nsHTMLInputElement, UseMap, usemap)
 1: //NS_IMPL_STRING_ATTR(nsHTMLInputElement, Value, value)
 1: //NS_IMPL_INT_ATTR_DEFAULT_VALUE(nsHTMLInputElement, Size, size, 0)
 1: //NS_IMPL_STRING_ATTR_DEFAULT_VALUE(nsHTMLInputElement, Type, type, "text")
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::GetDefaultValue(nsAString& aValue)
 1: {
 1:   GetAttrHelper(nsGkAtoms::value, aValue);
 1: 
 1:   if (mType != NS_FORM_INPUT_HIDDEN) {
 1:     // Bug 114997: trim \n, etc. for non-hidden inputs
 1:     aValue = nsContentUtils::TrimCharsInSet(kWhitespace, aValue);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SetDefaultValue(const nsAString& aValue)
 1: {
 1:   return SetAttrHelper(nsGkAtoms::value, aValue);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::GetSize(PRUint32* aValue)
 1: {
 1:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(nsGkAtoms::size);
 1:   if (attrVal && attrVal->Type() == nsAttrValue::eInteger) {
 1:     *aValue = attrVal->GetIntegerValue();
 1:   }
 1:   else {
 1:     *aValue = 0;
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SetSize(PRUint32 aValue)
 1: {
 1:   nsAutoString val;
 1:   val.AppendInt(aValue);
 1: 
 1:   return SetAttr(kNameSpaceID_None, nsGkAtoms::size, val, PR_TRUE);
 1: }
 1: 
 1: NS_IMETHODIMP 
 1: nsHTMLInputElement::GetValue(nsAString& aValue)
 1: {
 1:   if (mType == NS_FORM_INPUT_TEXT || mType == NS_FORM_INPUT_PASSWORD) {
 1:     // No need to flush here, if there's no frame created for this
 1:     // input yet, there won't be a value in it (that we don't already
 1:     // have) even if we force it to be created
 1:     nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_FALSE);
 1: 
 1:     PRBool frameOwnsValue = PR_FALSE;
 1:     if (formControlFrame) {
 1:       nsITextControlFrame* textControlFrame = nsnull;
 1:       CallQueryInterface(formControlFrame, &textControlFrame);
 1: 
 1:       if (textControlFrame) {
 1:         textControlFrame->OwnsValue(&frameOwnsValue);
 1:       } else {
 1:         // We assume if it's not a text control frame that it owns the value
 1:         frameOwnsValue = PR_TRUE;
 1:       }
 1:     }
 1: 
 1:     if (frameOwnsValue) {
 1:       formControlFrame->GetFormProperty(nsGkAtoms::value, aValue);
 1:     } else {
 1:       if (!GET_BOOLBIT(mBitField, BF_VALUE_CHANGED) || !mValue) {
 1:         GetDefaultValue(aValue);
 1:       } else {
 1:         CopyUTF8toUTF16(mValue, aValue);
 1:       }
 1:     }
 1: 
 1:     return NS_OK;
 1:   }
 1: 
 1:   if (mType == NS_FORM_INPUT_FILE) {
 1:     if (mFileName) {
 1:       aValue = *mFileName;
 1:     }
 1:     else {
 1:       aValue.Truncate();
 1:     }
 1:     
 1:     return NS_OK;
 1:   }
 1: 
 1:   // Treat value == defaultValue for other input elements
 1:   if (!GetAttr(kNameSpaceID_None, nsGkAtoms::value, aValue) &&
 1:       (mType == NS_FORM_INPUT_RADIO || mType == NS_FORM_INPUT_CHECKBOX)) {
 1:     // The default value of a radio or checkbox input is "on".
 1:     aValue.AssignLiteral("on");
 1:   }
 1: 
 1:   if (mType != NS_FORM_INPUT_HIDDEN) {
 1:     aValue = nsContentUtils::TrimCharsInSet(kWhitespace, aValue);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP 
 1: nsHTMLInputElement::SetValue(const nsAString& aValue)
 1: {
 1:   // check security.  Note that setting the value to the empty string is always
 1:   // OK and gives pages a way to clear a file input if necessary.
 1:   if (mType == NS_FORM_INPUT_FILE) {
 1:     if (!aValue.IsEmpty()) {
 1:       nsIScriptSecurityManager *securityManager =
 1:         nsContentUtils::GetSecurityManager();
 1: 
 1:       PRBool enabled;
 1:       nsresult rv =
 1:         securityManager->IsCapabilityEnabled("UniversalFileRead", &enabled);
 1:       NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:       if (!enabled) {
 1:         // setting the value of a "FILE" input widget requires the
 1:         // UniversalFileRead privilege
 1:         return NS_ERROR_DOM_SECURITY_ERR;
 1:       }
 1:     }
 1:     SetFileName(aValue);
 1:   }
 1:   else {
 1:     SetValueInternal(aValue, nsnull);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::TakeTextFrameValue(const nsAString& aValue)
 1: {
 1:   if (mValue) {
 1:     nsMemory::Free(mValue);
 1:   }
 1:   mValue = ToNewUTF8String(aValue);
 1:   SetValueChanged(PR_TRUE);
 1:   return NS_OK;
 1: }
 1: 
 1: void
 1: nsHTMLInputElement::GetFileName(nsAString& aValue)
 1: {
 1:   if (mFileName) {
 1:     aValue = *mFileName;
 1:   }
 1:   else {
 1:     aValue.Truncate();
 1:   }
 1: }
 1: 
 1: void
 1: nsHTMLInputElement::SetFileName(const nsAString& aValue)
 1: {
 1:   // No big deal if |new| fails, we simply won't submit the file
 1:   mFileName = aValue.IsEmpty() ? nsnull : new nsString(aValue);
 1: 
 1:   SetValueChanged(PR_TRUE);
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::SetValueInternal(const nsAString& aValue,
 1:                                      nsITextControlFrame* aFrame)
 1: {
 1:   NS_PRECONDITION(mType != NS_FORM_INPUT_FILE,
 1:                   "Don't call SetValueInternal for file inputs");
 1: 
 1:   if (mType == NS_FORM_INPUT_TEXT || mType == NS_FORM_INPUT_PASSWORD) {
 1: 
 1:     nsITextControlFrame* textControlFrame = aFrame;
 1:     nsIFormControlFrame* formControlFrame = textControlFrame;
 1:     if (!textControlFrame) {
 1:       // No need to flush here, if there's no frame at this point we
 1:       // don't need to force creation of one just to tell it about this
 1:       // new value.
 1:       formControlFrame = GetFormControlFrame(PR_FALSE);
 1: 
 1:       if (formControlFrame) {
 1:         CallQueryInterface(formControlFrame, &textControlFrame);
 1:       }
 1:     }
 1: 
 1:     // File frames always own the value (if the frame is there).
 1:     // Text frames have a bit that says whether they own the value.
 1:     PRBool frameOwnsValue = PR_FALSE;
 1:     if (textControlFrame) {
 1:       textControlFrame->OwnsValue(&frameOwnsValue);
 1:     }
 1:     // If the frame owns the value, set the value in the frame
 1:     if (frameOwnsValue) {
 1:       formControlFrame->SetFormProperty(nsGkAtoms::value, aValue);
 1:       return NS_OK;
 1:     }
 1: 
 1:     // If the frame does not own the value, set mValue
 1:     if (mValue) {
 1:       nsMemory::Free(mValue);
 1:     }
 1: 
 1:     mValue = ToNewUTF8String(aValue);
 1: 
 1:     SetValueChanged(PR_TRUE);
 1:     return mValue ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 1:   }
 1: 
 1:   if (mType == NS_FORM_INPUT_FILE) {
 1:     return NS_ERROR_UNEXPECTED;
 1:   }
 1: 
 1:   // If the value of a hidden input was changed, we mark it changed so that we
 1:   // will know we need to save / restore the value.  Yes, we are overloading
 1:   // the meaning of ValueChanged just a teensy bit to save a measly byte of
 1:   // storage space in nsHTMLInputElement.  Yes, you are free to make a new flag,
 1:   // NEED_TO_SAVE_VALUE, at such time as mBitField becomes a 16-bit value.
 1:   if (mType == NS_FORM_INPUT_HIDDEN) {
 1:     SetValueChanged(PR_TRUE);
 1:   }
 1: 
 1:   // Treat value == defaultValue for other input elements.
 1:   return nsGenericHTMLFormElement::SetAttr(kNameSpaceID_None,
 1:                                            nsGkAtoms::value, aValue,
 1:                                            PR_TRUE);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SetValueChanged(PRBool aValueChanged)
 1: {
 1:   SET_BOOLBIT(mBitField, BF_VALUE_CHANGED, aValueChanged);
 1:   if (!aValueChanged) {
 1:     if (mValue) {
 1:       nsMemory::Free(mValue);
 1:       mValue = nsnull;
 1:     }
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP 
 1: nsHTMLInputElement::GetChecked(PRBool* aChecked)
 1: {
 1:   *aChecked = GET_BOOLBIT(mBitField, BF_CHECKED);
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SetCheckedChanged(PRBool aCheckedChanged)
 1: {
 1:   return DoSetCheckedChanged(aCheckedChanged, PR_TRUE);
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::DoSetCheckedChanged(PRBool aCheckedChanged,
 1:                                         PRBool aNotify)
 1: {
 1:   if (mType == NS_FORM_INPUT_RADIO) {
 1:     if (GET_BOOLBIT(mBitField, BF_CHECKED_CHANGED) != aCheckedChanged) {
 1:       nsCOMPtr<nsIRadioVisitor> visitor;
 1:       NS_GetRadioSetCheckedChangedVisitor(aCheckedChanged,
 1:                                           getter_AddRefs(visitor));
 1:       VisitGroup(visitor, aNotify);
 1:     }
 1:   } else {
 1:     SetCheckedChangedInternal(aCheckedChanged);
 1:   }
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SetCheckedChangedInternal(PRBool aCheckedChanged)
 1: {
 1:   SET_BOOLBIT(mBitField, BF_CHECKED_CHANGED, aCheckedChanged);
 1:   return NS_OK;
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::GetCheckedChanged(PRBool* aCheckedChanged)
 1: {
 1:   *aCheckedChanged = GET_BOOLBIT(mBitField, BF_CHECKED_CHANGED);
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SetChecked(PRBool aChecked)
 1: {
 1:   return DoSetChecked(aChecked);
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::DoSetChecked(PRBool aChecked, PRBool aNotify)
 1: {
 1:   nsresult rv = NS_OK;
 1: 
 1:   //
 1:   // If the user or JS attempts to set checked, whether it actually changes the
 1:   // value or not, we say the value was changed so that defaultValue don't
 1:   // affect it no more.
 1:   //
 1:   DoSetCheckedChanged(PR_TRUE, aNotify);
 1: 
 1:   //
 1:   // Don't do anything if we're not changing whether it's checked (it would
 1:   // screw up state actually, especially when you are setting radio button to
 1:   // false)
 1:   //
 1:   PRBool checked = PR_FALSE;
 1:   GetChecked(&checked);
 1:   if (checked == aChecked) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   //
 1:   // Set checked
 1:   //
 1:   if (mType == NS_FORM_INPUT_RADIO) {
 1:     //
 1:     // For radio button, we need to do some extra fun stuff
 1:     //
 1:     if (aChecked) {
 1:       rv = RadioSetChecked(aNotify);
 1:     } else {
 1:       rv = SetCheckedInternal(PR_FALSE, aNotify);
 1:       nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
 1:       if (container) {
 1:         nsAutoString name;
 1:         if (GetNameIfExists(name)) {
 1:           container->SetCurrentRadioButton(name, nsnull);
 1:         }
 1:       }
 1:     }
 1:   } else {
 1:     rv = SetCheckedInternal(aChecked, aNotify);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::RadioSetChecked(PRBool aNotify)
 1: {
 1:   nsresult rv = NS_OK;
 1: 
 1:   //
 1:   // Find the selected radio button so we can deselect it
 1:   //
 1:   nsCOMPtr<nsIDOMHTMLInputElement> currentlySelected;
 1:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
 1:   // This is ONLY INITIALIZED IF container EXISTS
 1:   nsAutoString name;
 1:   PRBool nameExists = PR_FALSE;
 1:   if (container) {
 1:     nameExists = GetNameIfExists(name);
 1:     if (nameExists) {
 1:       container->GetCurrentRadioButton(name, getter_AddRefs(currentlySelected));
 1:     }
 1:   }
 1: 
 1:   //
 1:   // Deselect the currently selected radio button
 1:   //
 1:   if (currentlySelected) {
 1:     // Pass PR_TRUE for the aNotify parameter since the currently selected
 1:     // button is already in the document.
 1:     rv = NS_STATIC_CAST(nsHTMLInputElement*,
 1:                         NS_STATIC_CAST(nsIDOMHTMLInputElement*, currentlySelected)
 1:          )->SetCheckedInternal(PR_FALSE, PR_TRUE);
 1:   }
 1: 
 1:   //
 1:   // Actually select this one
 1:   //
 1:   if (NS_SUCCEEDED(rv)) {
 1:     rv = SetCheckedInternal(PR_TRUE, aNotify);
 1:   }
 1: 
 1:   //
 1:   // Let the group know that we are now the One True Radio Button
 1:   //
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   if (container && nameExists) {
 1:     rv = container->SetCurrentRadioButton(name, this);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: /* virtual */ already_AddRefed<nsIRadioGroupContainer>
 1: nsHTMLInputElement::GetRadioGroupContainer()
 1: {
 1:   nsIRadioGroupContainer* retval = nsnull;
 1:   if (mForm) {
 1:     CallQueryInterface(mForm, &retval);
 1:   } else {
 1:     nsIDocument* currentDoc = GetCurrentDoc();
 1:     if (currentDoc) {
 1:       CallQueryInterface(currentDoc, &retval);
 1:     }
 1:   }
 1:   return retval;
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::MaybeSubmitForm(nsPresContext* aPresContext)
 1: {
 1:   if (!mForm) {
 1:     // Nothing to do here.
 1:     return NS_OK;
 1:   }
 1:   
95:   nsCOMPtr<nsIPresShell> shell = aPresContext->GetPresShell();
 1:   if (!shell) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   // Get the default submit element
 1:   nsIFormControl* submitControl = mForm->GetDefaultSubmitElement();
 1:   if (submitControl) {
 1:     nsCOMPtr<nsIContent> submitContent(do_QueryInterface(submitControl));
 1:     NS_ASSERTION(submitContent, "Form control not implementing nsIContent?!");
 1:     // Fire the button's onclick handler and let the button handle
 1:     // submitting the form.
 1:     nsMouseEvent event(PR_TRUE, NS_MOUSE_CLICK, nsnull, nsMouseEvent::eReal);
 1:     nsEventStatus status = nsEventStatus_eIgnore;
 1:     shell->HandleDOMEventWithTarget(submitContent, &event, &status);
 1:   } else if (mForm->HasSingleTextControl()) {
 1:     // If there's only one text control, just submit the form
 1:     nsCOMPtr<nsIContent> form = do_QueryInterface(mForm);
 1:     nsFormEvent event(PR_TRUE, NS_FORM_SUBMIT);
 1:     nsEventStatus status  = nsEventStatus_eIgnore;
 1:     shell->HandleDOMEventWithTarget(form, &event, &status);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::SetCheckedInternal(PRBool aChecked, PRBool aNotify)
 1: {
 1:   //
 1:   // Set the value
 1:   //
 1:   SET_BOOLBIT(mBitField, BF_CHECKED, aChecked);
 1: 
 1:   //
 1:   // Notify the frame
 1:   //
 1:   nsIFrame* frame = GetPrimaryFrame();
 1:   if (frame) {
 1:     nsPresContext *presContext = GetPresContext();
 1: 
 1:     if (mType == NS_FORM_INPUT_CHECKBOX) {
 1:       nsICheckboxControlFrame* checkboxFrame = nsnull;
 1:       CallQueryInterface(frame, &checkboxFrame);
 1:       if (checkboxFrame) {
 1:         checkboxFrame->OnChecked(presContext, aChecked);
 1:       }
 1:     } else if (mType == NS_FORM_INPUT_RADIO) {
 1:       nsIRadioControlFrame* radioFrame = nsnull;
 1:       CallQueryInterface(frame, &radioFrame);
 1:       if (radioFrame) {
 1:         radioFrame->OnChecked(presContext, aChecked);
 1:       }
 1:     }
 1:   }
 1: 
 1:   // Notify the document that the CSS :checked pseudoclass for this element
 1:   // has changed state.
 1:   if (aNotify) {
 1:     nsIDocument* document = GetCurrentDoc();
 1:     if (document) {
 1:       mozAutoDocUpdate upd(document, UPDATE_CONTENT_STATE, aNotify);
 1:       document->ContentStatesChanged(this, nsnull, NS_EVENT_STATE_CHECKED);
 1:     }
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: 
 1: void
 1: nsHTMLInputElement::FireOnChange()
 1: {
 1:   //
 1:   // Since the value is changing, send out an onchange event (bug 23571)
 1:   //
 1:   nsEventStatus status = nsEventStatus_eIgnore;
 1:   nsEvent event(PR_TRUE, NS_FORM_CHANGE);
 1:   nsCOMPtr<nsPresContext> presContext = GetPresContext();
 1:   nsEventDispatcher::Dispatch(NS_STATIC_CAST(nsIContent*, this), presContext,
 1:                               &event, nsnull, &status);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::Blur()
 1: {
 1:   if (ShouldFocus(this)) {
 1:     SetElementFocus(PR_FALSE);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::Focus()
 1: {
 1:   if (ShouldFocus(this)) {
 1:     SetElementFocus(PR_TRUE);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: void
 1: nsHTMLInputElement::SetFocus(nsPresContext* aPresContext)
 1: {
 1:   if (!aPresContext)
 1:     return;
 1: 
 1:   // We can't be focus'd if we aren't in a document
 1:   nsIDocument* doc = GetCurrentDoc();
 1:   if (!doc)
 1:     return;
 1: 
 1:   // first see if we are disabled or not. If disabled then do nothing.
 1:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) {
 1:     return;
 1:   }
 1:  
 1:   // If the window is not active, do not allow the focus to bring the
 1:   // window to the front.  We update the focus controller, but do
 1:   // nothing else.
 1:   nsCOMPtr<nsPIDOMWindow> win = doc->GetWindow();
 1:   if (win) {
 1:     nsIFocusController *focusController = win->GetRootFocusController();
 1:     if (focusController) {
 1:       PRBool isActive = PR_FALSE;
 1:       focusController->GetActive(&isActive);
 1:       if (!isActive) {
 1:         focusController->SetFocusedWindow(win);
 1:         focusController->SetFocusedElement(this);
 1: 
 1:         return;
 1:       }
 1:     }
 1:   }
 1: 
 1:   SetFocusAndScrollIntoView(aPresContext);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::Select()
 1: {
 1:   nsresult rv = NS_OK;
 1: 
 1:   nsIDocument* doc = GetCurrentDoc();
 1:   if (!doc)
 1:     return NS_OK;
 1: 
 1:   // first see if we are disabled or not. If disabled then do nothing.
 1:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   if (mType == NS_FORM_INPUT_PASSWORD || mType == NS_FORM_INPUT_TEXT) {
 1:     // XXX Bug?  We have to give the input focus before contents can be
 1:     // selected
 1: 
 1:     nsCOMPtr<nsPresContext> presContext = GetPresContext();
 1: 
 1:     // If the window is not active, do not allow the select to bring the
 1:     // window to the front.  We update the focus controller, but do
 1:     // nothing else.
 1:     nsPIDOMWindow *win = doc->GetWindow();
 1:     if (win) {
 1:       nsIFocusController *focusController = win->GetRootFocusController();
 1:       if (focusController) {
 1:         PRBool isActive = PR_FALSE;
 1:         focusController->GetActive(&isActive);
 1:         if (!isActive) {
 1:           focusController->SetFocusedWindow(win);
 1:           focusController->SetFocusedElement(this);
 1:           SelectAll(presContext);
 1:           return NS_OK;
 1:         }
 1:       }
 1:     }
 1: 
 1:     // Just like SetFocus() but without the ScrollIntoView()!
 1:     nsEventStatus status = nsEventStatus_eIgnore;
 1:     
 1:     //If already handling select event, don't dispatch a second.
 1:     if (!GET_BOOLBIT(mBitField, BF_HANDLING_SELECT_EVENT)) {
 1:       nsEvent event(nsContentUtils::IsCallerChrome(), NS_FORM_SELECTED);
 1: 
 1:       SET_BOOLBIT(mBitField, BF_HANDLING_SELECT_EVENT, PR_TRUE);
 1:       nsEventDispatcher::Dispatch(NS_STATIC_CAST(nsIContent*, this),
 1:                                   presContext, &event, nsnull, &status);
 1:       SET_BOOLBIT(mBitField, BF_HANDLING_SELECT_EVENT, PR_FALSE);
 1:     }
 1: 
 1:     // If the DOM event was not canceled (e.g. by a JS event handler
 1:     // returning false)
 1:     if (status == nsEventStatus_eIgnore) {
 1:       PRBool shouldFocus = ShouldFocus(this);
 1: 
 1:       if (presContext && shouldFocus) {
 1:         nsIEventStateManager *esm = presContext->EventStateManager();
 1:         // XXX Fix for bug 135345 - ESM currently does not check to see if we
 1:         // have focus before attempting to set focus again and may cause
 1:         // infinite recursion.  For now check if we have focus and do not set
 1:         // focus again if already focused.
 1:         PRInt32 currentState;
 1:         esm->GetContentState(this, currentState);
 1:         if (!(currentState & NS_EVENT_STATE_FOCUS) &&
 1:             !esm->SetContentState(this, NS_EVENT_STATE_FOCUS)) {
 1:           return rv; // We ended up unfocused, e.g. due to a DOM event handler.
 1:         }
 1:       }
 1: 
 1:       nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
 1: 
 1:       if (formControlFrame) {
 1:         if (shouldFocus) {
 1:           formControlFrame->SetFocus(PR_TRUE, PR_TRUE);
 1:         }
 1: 
 1:         // Now Select all the text!
 1:         SelectAll(presContext);
 1:       }
 1:     }
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: void
 1: nsHTMLInputElement::SelectAll(nsPresContext* aPresContext)
 1: {
 1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
 1: 
 1:   if (formControlFrame) {
 1:     formControlFrame->SetFormProperty(nsGkAtoms::select, EmptyString());
 1:   }
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::Click()
 1: {
 1:   nsresult rv = NS_OK;
 1: 
 1:   if (GET_BOOLBIT(mBitField, BF_HANDLING_CLICK)) // Fixes crash as in bug 41599
 1:       return rv;                      // --heikki@netscape.com
 1: 
 1:   // first see if we are disabled or not. If disabled then do nothing.
 1:   nsAutoString disabled;
 1:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::disabled)) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   // see what type of input we are.  Only click button, checkbox, radio,
 1:   // reset, submit, & image
 1:   if (mType == NS_FORM_INPUT_BUTTON   ||
 1:       mType == NS_FORM_INPUT_CHECKBOX ||
 1:       mType == NS_FORM_INPUT_RADIO    ||
 1:       mType == NS_FORM_INPUT_RESET    ||
 1:       mType == NS_FORM_INPUT_SUBMIT   ||
 1:       mType == NS_FORM_INPUT_IMAGE) {
 1: 
 1:     // Strong in case the event kills it
 1:     nsCOMPtr<nsIDocument> doc = GetCurrentDoc();
 1:     if (!doc) {
 1:       return rv;
 1:     }
 1:     
 1:     nsIPresShell *shell = doc->GetShellAt(0);
 1: 
 1:     if (shell) {
 1:       nsCOMPtr<nsPresContext> context = shell->GetPresContext();
 1: 
 1:       if (context) {
 1:         // Click() is never called from native code, but it may be
 1:         // called from chrome JS. Mark this event trusted if Click()
 1:         // is called from chrome code.
 1:         nsMouseEvent event(nsContentUtils::IsCallerChrome(),
 1:                            NS_MOUSE_CLICK, nsnull, nsMouseEvent::eReal);
 1:         nsEventStatus status = nsEventStatus_eIgnore;
 1: 
 1:         SET_BOOLBIT(mBitField, BF_HANDLING_CLICK, PR_TRUE);
 1: 
 1:         nsEventDispatcher::Dispatch(NS_STATIC_CAST(nsIContent*, this), context,
 1:                                     &event, nsnull, &status);
 1: 
 1:         SET_BOOLBIT(mBitField, BF_HANDLING_CLICK, PR_FALSE);
 1:       }
 1:     }
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
 1: {
 1:   // Do not process any DOM events if the element is disabled
 1:   aVisitor.mCanHandle = PR_FALSE;
 1:   PRBool disabled;
 1:   nsresult rv = GetDisabled(&disabled);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   //FIXME Allow submission etc. also when there is no prescontext, Bug 329509.
 1:   if (disabled || !aVisitor.mPresContext) {
 1:     return NS_OK;
 1:   }
 1:   
 1:   // For some reason or another we also need to check if the style shows us
 1:   // as disabled.
 1:   {
 1:     nsIFrame* frame = GetPrimaryFrame();
 1:     if (frame) {
 1:       const nsStyleUserInterface* uiStyle = frame->GetStyleUserInterface();
 1: 
 1:       if (uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE ||
 1:           uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED) {
 1:         return NS_OK;
 1:       }
 1:     }
 1:   }
 1: 
 1:   //
 1:   // Web pages expect the value of a radio button or checkbox to be set
 1:   // *before* onclick and DOMActivate fire, and they expect that if they set
 1:   // the value explicitly during onclick or DOMActivate it will not be toggled
 1:   // or any such nonsense.
 1:   // In order to support that (bug 57137 and 58460 are examples) we toggle
 1:   // the checked attribute *first*, and then fire onclick.  If the user
 1:   // returns false, we reset the control to the old checked value.  Otherwise,
 1:   // we dispatch DOMActivate.  If DOMActivate is cancelled, we also reset
 1:   // the control to the old checked value.  We need to keep track of whether
 1:   // we've already toggled the state from onclick since the user could
 1:   // explicitly dispatch DOMActivate on the element.
 1:   //
 1:   // This is a compatibility hack.
 1:   //
 1: 
 1:   // Track whether we're in the outermost Dispatch invocation that will
 1:   // cause activation of the input.  That is, if we're a click event, or a
 1:   // DOMActivate that was dispatched directly, this will be set, but if we're
 1:   // a DOMActivate dispatched from click handling, it will not be set.
 1:   PRBool outerActivateEvent =
 1:     (NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent) ||
 1:      (aVisitor.mEvent->message == NS_UI_ACTIVATE &&
 1:       !GET_BOOLBIT(mBitField, BF_IN_INTERNAL_ACTIVATE)));
 1: 
 1:   if (outerActivateEvent) {
 1:     aVisitor.mItemFlags |= NS_OUTER_ACTIVATE_EVENT;
 1:   }
 1: 
 1:   PRBool originalCheckedValue = PR_FALSE;
 1: 
 1:   if (outerActivateEvent) {
 1:     SET_BOOLBIT(mBitField, BF_CHECKED_IS_TOGGLED, PR_FALSE);
 1: 
 1:     switch(mType) {
 1:       case NS_FORM_INPUT_CHECKBOX:
 1:         {
 1:           GetChecked(&originalCheckedValue);
 1:           DoSetChecked(!originalCheckedValue);
 1:           SET_BOOLBIT(mBitField, BF_CHECKED_IS_TOGGLED, PR_TRUE);
 1:         }
 1:         break;
 1: 
 1:       case NS_FORM_INPUT_RADIO:
 1:         {
 1:           nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
 1:           if (container) {
 1:             nsAutoString name;
 1:             if (GetNameIfExists(name)) {
 1:               nsCOMPtr<nsIDOMHTMLInputElement> selectedRadioButton;
 1:               container->GetCurrentRadioButton(name,
 1:                                                getter_AddRefs(selectedRadioButton));
 1:               aVisitor.mItemData = selectedRadioButton;
 1:             }
 1:           }
 1: 
 1:           GetChecked(&originalCheckedValue);
 1:           if (!originalCheckedValue) {
 1:             DoSetChecked(PR_TRUE);
 1:             SET_BOOLBIT(mBitField, BF_CHECKED_IS_TOGGLED, PR_TRUE);
 1:           }
 1:         }
 1:         break;
 1: 
 1:       case NS_FORM_INPUT_SUBMIT:
 1:       case NS_FORM_INPUT_IMAGE:
 1:         if(mForm) {
 1:           // tell the form that we are about to enter a click handler.
 1:           // that means that if there are scripted submissions, the
 1:           // latest one will be deferred until after the exit point of the handler. 
 1:           mForm->OnSubmitClickBegin();
 1:         }
 1:         break;
 1: 
 1:       default:
 1:         break;
 1:     } //switch
 1:   }
 1: 
 1:   if (originalCheckedValue) {
 1:     aVisitor.mItemFlags |= NS_ORIGINAL_CHECKED_VALUE;
 1:   }
 1: 
 1:   // If NS_EVENT_FLAG_NO_CONTENT_DISPATCH is set we will not allow content to handle
 1:   // this event.  But to allow middle mouse button paste to work we must allow 
 1:   // middle clicks to go to text fields anyway.
 1:   if (aVisitor.mEvent->flags & NS_EVENT_FLAG_NO_CONTENT_DISPATCH) {
 1:     aVisitor.mItemFlags |= NS_NO_CONTENT_DISPATCH;
 1:   }
 1:   if ((mType == NS_FORM_INPUT_TEXT || mType == NS_FORM_INPUT_PASSWORD) &&
 1:       aVisitor.mEvent->message == NS_MOUSE_CLICK &&
 1:       aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT &&
 1:       NS_STATIC_CAST(nsMouseEvent*, aVisitor.mEvent)->button ==
 1:         nsMouseEvent::eMiddleButton) {
 1:     aVisitor.mEvent->flags &= ~NS_EVENT_FLAG_NO_CONTENT_DISPATCH;
 1:   }
 1: 
 1:   // We must cache type because mType may change during JS event (bug 2369)
 1:   aVisitor.mItemFlags |= NS_STATIC_CAST(PRUint8, mType);
 1: 
 1:   // Fire onchange (if necessary), before we do the blur, bug 357684.
 1:   if (aVisitor.mEvent->message == NS_BLUR_CONTENT) {
 1:     nsIFrame* primaryFrame = GetPrimaryFrame();
 1:     if (primaryFrame) {
 1:       nsITextControlFrame* textFrame = nsnull;
 1:       CallQueryInterface(primaryFrame, &textFrame);
 1:       if (textFrame) {
 1:         textFrame->CheckFireOnChange();
 1:       }
 1:     }
 1:   }
 1: 
 1:   return nsGenericHTMLElement::PreHandleEvent(aVisitor);
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::PostHandleEvent(nsEventChainPostVisitor& aVisitor)
 1: {
 1:   if (!aVisitor.mPresContext) {
 1:     return NS_OK;
 1:   }
 1:   nsresult rv = NS_OK;
 1:   PRBool outerActivateEvent = aVisitor.mItemFlags & NS_OUTER_ACTIVATE_EVENT;
 1:   PRBool originalCheckedValue =
 1:     aVisitor.mItemFlags & NS_ORIGINAL_CHECKED_VALUE;
 1:   PRBool noContentDispatch = aVisitor.mItemFlags & NS_NO_CONTENT_DISPATCH;
 1:   PRInt8 oldType = NS_CONTROL_TYPE(aVisitor.mItemFlags);
 1:   // Ideally we would make the default action for click and space just dispatch
 1:   // DOMActivate, and the default action for DOMActivate flip the checkbox/
 1:   // radio state and fire onchange.  However, for backwards compatibility, we
 1:   // need to flip the state before firing click, and we need to fire click
 1:   // when space is pressed.  So, we just nest the firing of DOMActivate inside
 1:   // the click event handling, and allow cancellation of DOMActivate to cancel
 1:   // the click.
 1:   if (aVisitor.mEventStatus != nsEventStatus_eConsumeNoDefault &&
 1:       mType != NS_FORM_INPUT_TEXT &&
 1:       NS_IS_MOUSE_LEFT_CLICK(aVisitor.mEvent)) {
 1:     nsUIEvent actEvent(NS_IS_TRUSTED_EVENT(aVisitor.mEvent), NS_UI_ACTIVATE, 1);
 1: 
95:     nsCOMPtr<nsIPresShell> shell = aVisitor.mPresContext->GetPresShell();
 1:     if (shell) {
 1:       nsEventStatus status = nsEventStatus_eIgnore;
 1:       SET_BOOLBIT(mBitField, BF_IN_INTERNAL_ACTIVATE, PR_TRUE);
 1:       rv = shell->HandleDOMEventWithTarget(this, &actEvent, &status);
 1:       SET_BOOLBIT(mBitField, BF_IN_INTERNAL_ACTIVATE, PR_FALSE);
 1: 
 1:       // If activate is cancelled, we must do the same as when click is
 1:       // cancelled (revert the checkbox to its original value).
 1:       if (status == nsEventStatus_eConsumeNoDefault)
 1:         aVisitor.mEventStatus = status;
 1:     }
 1:   }
 1: 
 1:   if (outerActivateEvent) {
 1:     switch(oldType) {
 1:       case NS_FORM_INPUT_SUBMIT:
 1:       case NS_FORM_INPUT_IMAGE:
 1:         if(mForm) {
 1:           // tell the form that we are about to exit a click handler
 1:           // so the form knows not to defer subsequent submissions
 1:           // the pending ones that were created during the handler
 1:           // will be flushed or forgoten.
 1:           mForm->OnSubmitClickEnd();
 1:         }
 1:         break;
 1:     } //switch
 1:   }
 1: 
 1:   // Reset the flag for other content besides this text field
 1:   aVisitor.mEvent->flags |=
 1:     noContentDispatch ? NS_EVENT_FLAG_NO_CONTENT_DISPATCH : NS_EVENT_FLAG_NONE;
 1: 
 1:   // now check to see if the event was "cancelled"
 1:   if (GET_BOOLBIT(mBitField, BF_CHECKED_IS_TOGGLED) && outerActivateEvent) {
 1:     if (aVisitor.mEventStatus == nsEventStatus_eConsumeNoDefault) {
 1:       // if it was cancelled and a radio button, then set the old
 1:       // selected btn to TRUE. if it is a checkbox then set it to its
 1:       // original value
 1:       nsCOMPtr<nsIDOMHTMLInputElement> selectedRadioButton =
 1:         do_QueryInterface(aVisitor.mItemData);
 1:       if (selectedRadioButton) {
 1:         selectedRadioButton->SetChecked(PR_TRUE);
 1:         // If this one is no longer a radio button we must reset it back to
 1:         // false to cancel the action.  See how the web of hack grows?
 1:         if (mType != NS_FORM_INPUT_RADIO) {
 1:           DoSetChecked(PR_FALSE);
 1:         }
 1:       } else if (oldType == NS_FORM_INPUT_CHECKBOX) {
 1:         DoSetChecked(originalCheckedValue);
 1:       }
 1:     } else {
 1:       FireOnChange();
 1: #ifdef ACCESSIBILITY
 1:       // Fire an event to notify accessibility
 1:       if (mType == NS_FORM_INPUT_CHECKBOX) {
 1:         FireEventForAccessibility(this, aVisitor.mPresContext,
 1:                                   NS_LITERAL_STRING("CheckboxStateChange"));
 1:       } else {
 1:         FireEventForAccessibility(this, aVisitor.mPresContext,
 1:                                   NS_LITERAL_STRING("RadioStateChange"));
 1:         // Fire event for the previous selected radio.
 1:         nsCOMPtr<nsIDOMHTMLInputElement> previous =
 1:           do_QueryInterface(aVisitor.mItemData);
 1:         if(previous) {
 1:           FireEventForAccessibility(previous, aVisitor.mPresContext,
 1:                                     NS_LITERAL_STRING("RadioStateChange"));
 1:         }
 1:       }
 1: #endif
 1:     }
 1:   }
 1: 
 1:   if (NS_SUCCEEDED(rv)) {
 1:     if (nsEventStatus_eIgnore == aVisitor.mEventStatus) {
 1:       switch (aVisitor.mEvent->message) {
 1: 
 1:         case NS_FOCUS_CONTENT:
 1:         {
 1:           // Check to see if focus has bubbled up from a form control's
 1:           // child textfield or button.  If that's the case, don't focus
 1:           // this parent file control -- leave focus on the child.
 1:           nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_FALSE);
 1:           if (formControlFrame && ShouldFocus(this) &&
 1:               aVisitor.mEvent->originalTarget == NS_STATIC_CAST(nsINode*, this))
 1:             formControlFrame->SetFocus(PR_TRUE, PR_TRUE);
 1:         }
 1:         break; // NS_FOCUS_CONTENT
 1: 
 1:         case NS_KEY_PRESS:
 1:         case NS_KEY_UP:
 1:         {
 1:           // For backwards compat, trigger checks/radios/buttons with
 1:           // space or enter (bug 25300)
 1:           nsKeyEvent * keyEvent = (nsKeyEvent *)aVisitor.mEvent;
 1: 
 1:           if ((aVisitor.mEvent->message == NS_KEY_PRESS &&
 1:                keyEvent->keyCode == NS_VK_RETURN) ||
 1:               (aVisitor.mEvent->message == NS_KEY_UP &&
 1:                keyEvent->keyCode == NS_VK_SPACE)) {
 1:             switch(mType) {
 1:               case NS_FORM_INPUT_CHECKBOX:
 1:               case NS_FORM_INPUT_RADIO:
 1:               {
 1:                 // Checkbox and Radio try to submit on Enter press
 1:                 if (keyEvent->keyCode != NS_VK_SPACE) {
 1:                   MaybeSubmitForm(aVisitor.mPresContext);
 1: 
 1:                   break;  // If we are submitting, do not send click event
 1:                 }
 1:                 // else fall through and treat Space like click...
 1:               }
 1:               case NS_FORM_INPUT_BUTTON:
 1:               case NS_FORM_INPUT_RESET:
 1:               case NS_FORM_INPUT_SUBMIT:
 1:               case NS_FORM_INPUT_IMAGE: // Bug 34418
 1:               {
 1:                 nsMouseEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
 1:                                    NS_MOUSE_CLICK, nsnull, nsMouseEvent::eReal);
 1:                 nsEventStatus status = nsEventStatus_eIgnore;
 1: 
 1:                 nsEventDispatcher::Dispatch(NS_STATIC_CAST(nsIContent*, this),
 1:                                             aVisitor.mPresContext, &event,
 1:                                             nsnull, &status);
 1:               } // case
 1:             } // switch
 1:           }
 1:           if (aVisitor.mEvent->message == NS_KEY_PRESS &&
 1:               mType == NS_FORM_INPUT_RADIO && !keyEvent->isAlt &&
 1:               !keyEvent->isControl && !keyEvent->isMeta) {
 1:             PRBool isMovingBack = PR_FALSE;
 1:             switch (keyEvent->keyCode) {
 1:               case NS_VK_UP: 
 1:               case NS_VK_LEFT:
 1:                 isMovingBack = PR_TRUE;
 1:               case NS_VK_DOWN:
 1:               case NS_VK_RIGHT:
 1:               // Arrow key pressed, focus+select prev/next radio button
 1:               nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
 1:               if (container) {
 1:                 nsAutoString name;
 1:                 if (GetNameIfExists(name)) {
 1:                   nsCOMPtr<nsIDOMHTMLInputElement> selectedRadioButton;
 1:                   container->GetNextRadioButton(name, isMovingBack, this,
 1:                                                 getter_AddRefs(selectedRadioButton));
 1:                   nsCOMPtr<nsIContent> radioContent =
 1:                     do_QueryInterface(selectedRadioButton);
 1:                   if (radioContent) {
 1:                     rv = selectedRadioButton->Focus();
 1:                     if (NS_SUCCEEDED(rv)) {
 1:                       nsEventStatus status = nsEventStatus_eIgnore;
 1:                       nsMouseEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent),
 1:                                          NS_MOUSE_CLICK, nsnull,
 1:                                          nsMouseEvent::eReal);
 1:                       rv = nsEventDispatcher::Dispatch(radioContent,
 1:                                                        aVisitor.mPresContext,
 1:                                                        &event, nsnull, &status);
 1:                       if (NS_SUCCEEDED(rv)) {
 1:                         aVisitor.mEventStatus = nsEventStatus_eConsumeNoDefault;
 1:                       }
 1:                     }
 1:                   }
 1:                 }
 1:               }
 1:             }
 1:           }
 1: 
 1:           /*
 1:            * If this is input type=text, and the user hit enter, fire onChange
 1:            * and submit the form (if we are in one)
 1:            *
 1:            * Bug 99920, bug 109463 and bug 147850:
 1:            * (a) if there is a submit control in the form, click the first
 1:            *     submit control in the form.
 1:            * (b) if there is just one text control in the form, submit by
 1:            *     sending a submit event directly to the form
 1:            * (c) if there is more than one text input and no submit buttons, do
 1:            *     not submit, period.
 1:            */
 1: 
 1:           if (aVisitor.mEvent->message == NS_KEY_PRESS &&
 1:               (keyEvent->keyCode == NS_VK_RETURN ||
 1:                keyEvent->keyCode == NS_VK_ENTER) &&
 1:               (mType == NS_FORM_INPUT_TEXT ||
 1:                mType == NS_FORM_INPUT_PASSWORD ||
 1:                mType == NS_FORM_INPUT_FILE)) {
 1: 
 1:             PRBool isButton = PR_FALSE;
 1:             // If this is an enter on the button of a file input, don't submit
 1:             // -- that's supposed to put up the filepicker
 1:             if (mType == NS_FORM_INPUT_FILE) {
 1:               nsCOMPtr<nsIContent> maybeButton =
 1:                 do_QueryInterface(aVisitor.mEvent->originalTarget);
 1:               if (maybeButton) {
 1:                 isButton = maybeButton->AttrValueIs(kNameSpaceID_None,
 1:                                                     nsGkAtoms::type,
 1:                                                     nsGkAtoms::button,
 1:                                                     eCaseMatters);
 1:               }
 1:             }
 1: 
 1:             if (!isButton) {
 1:               nsIFrame* primaryFrame = GetPrimaryFrame();
 1:               if (primaryFrame) {
 1:                 nsITextControlFrame* textFrame = nsnull;
 1:                 CallQueryInterface(primaryFrame, &textFrame);
 1:               
 1:                 // Fire onChange (if necessary)
 1:                 if (textFrame) {
 1:                   textFrame->CheckFireOnChange();
 1:                 }
 1:               }
 1: 
 1:               rv = MaybeSubmitForm(aVisitor.mPresContext);
 1:               NS_ENSURE_SUCCESS(rv, rv);
 1:             }
 1:           }
 1: 
 1:         } break; // NS_KEY_PRESS || NS_KEY_UP
 1: 
 1:         case NS_MOUSE_BUTTON_DOWN:
 1:         case NS_MOUSE_BUTTON_UP:
 1:         case NS_MOUSE_DOUBLECLICK:
 1:         {
 1:           // cancel all of these events for buttons
 1:           //XXXsmaug Why?
 1:           if (aVisitor.mEvent->eventStructType == NS_MOUSE_EVENT &&
 1:               (NS_STATIC_CAST(nsMouseEvent*, aVisitor.mEvent)->button ==
 1:                  nsMouseEvent::eMiddleButton ||
 1:                NS_STATIC_CAST(nsMouseEvent*, aVisitor.mEvent)->button ==
 1:                  nsMouseEvent::eRightButton)) {
 1:             if (mType == NS_FORM_INPUT_BUTTON ||
 1:                 mType == NS_FORM_INPUT_RESET ||
 1:                 mType == NS_FORM_INPUT_SUBMIT) {
 1:               if (aVisitor.mDOMEvent) {
 1:                 aVisitor.mDOMEvent->StopPropagation();
 1:               } else {
 1:                 rv = NS_ERROR_FAILURE;
 1:               }
 1:             }
 1: 
 1:           }
 1:           break;
 1:         }
 1:         default:
 1:           break;
 1:       }
 1: 
 1:       if (outerActivateEvent) {
 1:         if (mForm && (oldType == NS_FORM_INPUT_SUBMIT ||
 1:                       oldType == NS_FORM_INPUT_IMAGE)) {
 1:           if (mType != NS_FORM_INPUT_SUBMIT && mType != NS_FORM_INPUT_IMAGE) {
 1:             // If the type has changed to a non-submit type, then we want to
 1:             // flush the stored submission if there is one (as if the submit()
 1:             // was allowed to succeed)
 1:             mForm->FlushPendingSubmission();
 1:           }
 1:         }
 1:         switch(mType) {
 1:         case NS_FORM_INPUT_RESET:
 1:         case NS_FORM_INPUT_SUBMIT:
 1:         case NS_FORM_INPUT_IMAGE:
 1:           if (mForm) {
 1:             nsFormEvent event(PR_TRUE, (mType == NS_FORM_INPUT_RESET) ?
 1:                               NS_FORM_RESET : NS_FORM_SUBMIT);
 1:             event.originator      = this;
 1:             nsEventStatus status  = nsEventStatus_eIgnore;
 1: 
95:             nsCOMPtr<nsIPresShell> presShell =
95:               aVisitor.mPresContext->GetPresShell();
 1: 
 1:             // If |nsIPresShell::Destroy| has been called due to
 1:             // handling the event the pres context will return a null
 1:             // pres shell.  See bug 125624.
 1:             if (presShell) {
 1:               nsCOMPtr<nsIContent> form(do_QueryInterface(mForm));
 1:               presShell->HandleDOMEventWithTarget(form, &event, &status);
 1:             }
 1:           }
 1:           break;
 1: 
 1:         default:
 1:           break;
 1:         } //switch 
 1:       } //click or outer activate event
 1:     } else if (outerActivateEvent &&
 1:                (oldType == NS_FORM_INPUT_SUBMIT ||
 1:                 oldType == NS_FORM_INPUT_IMAGE) &&
 1:                mForm) {
 1:       // tell the form to flush a possible pending submission.
 1:       // the reason is that the script returned false (the event was
 1:       // not ignored) so if there is a stored submission, it needs to
 1:       // be submitted immediately.
 1:       mForm->FlushPendingSubmission();
 1:     }
 1:   } // if
 1: 
 1:   return rv;
 1: }
 1: 
 1: 
 1: nsresult
 1: nsHTMLInputElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
 1:                                nsIContent* aBindingParent,
 1:                                PRBool aCompileEventHandlers)
 1: {
 1:   nsresult rv = nsGenericHTMLFormElement::BindToTree(aDocument, aParent,
 1:                                                      aBindingParent,
 1:                                                      aCompileEventHandlers);
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:   if (mType == NS_FORM_INPUT_IMAGE) {
 1:     // Our base URI may have changed; claim that our URI changed, and the
 1:     // nsImageLoadingContent will decide whether a new image load is warranted.
 1:     nsAutoString uri;
 1:     if (GetAttr(kNameSpaceID_None, nsGkAtoms::src, uri)) {
 1:       // Note: no need to notify here; since we're just now being bound
 1:       // we don't have any frames or anything yet.
 1:       LoadImage(uri, PR_FALSE, PR_FALSE);
 1:     }
 1:   }
 1: 
 1:   // Add radio to document if we don't have a form already (if we do it's
 1:   // already been added into that group)
 1:   if (aDocument && !mForm && mType == NS_FORM_INPUT_RADIO) {
 1:     AddedToRadioGroup();
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: void
 1: nsHTMLInputElement::UnbindFromTree(PRBool aDeep, PRBool aNullParent)
 1: {
 1:   // If we have a form and are unbound from it,
 1:   // nsGenericHTMLFormElement::UnbindFromTree() will unset the form and
 1:   // that takes care of form's WillRemove so we just have to take care
 1:   // of the case where we're removing from the document and we don't
 1:   // have a form
 1:   if (!mForm && mType == NS_FORM_INPUT_RADIO) {
 1:     WillRemoveFromRadioGroup();
 1:   }
 1: 
 1:   nsGenericHTMLFormElement::UnbindFromTree(aDeep, aNullParent);
 1: }
 1: 
 1: static const nsAttrValue::EnumTable kInputTypeTable[] = {
 1:   { "button", NS_FORM_INPUT_BUTTON },
 1:   { "checkbox", NS_FORM_INPUT_CHECKBOX },
 1:   { "file", NS_FORM_INPUT_FILE },
 1:   { "hidden", NS_FORM_INPUT_HIDDEN },
 1:   { "reset", NS_FORM_INPUT_RESET },
 1:   { "image", NS_FORM_INPUT_IMAGE },
 1:   { "password", NS_FORM_INPUT_PASSWORD },
 1:   { "radio", NS_FORM_INPUT_RADIO },
 1:   { "submit", NS_FORM_INPUT_SUBMIT },
 1:   { "text", NS_FORM_INPUT_TEXT },
 1:   { 0 }
 1: };
 1: 
 1: PRBool
 1: nsHTMLInputElement::ParseAttribute(PRInt32 aNamespaceID,
 1:                                    nsIAtom* aAttribute,
 1:                                    const nsAString& aValue,
 1:                                    nsAttrValue& aResult)
 1: {
 1:   if (aNamespaceID == kNameSpaceID_None) {
 1:     if (aAttribute == nsGkAtoms::type) {
 1:       // XXX ARG!! This is major evilness. ParseAttribute
 1:       // shouldn't set members. Override SetAttr instead
 1:       if (!aResult.ParseEnumValue(aValue, kInputTypeTable)) {
 1:         mType = NS_FORM_INPUT_TEXT;
 1:         return PR_FALSE;
 1:       }
 1: 
 1:       // Make sure to do the check for newType being NS_FORM_INPUT_FILE and the
 1:       // corresponding SetValueInternal() call _before_ we set mType.  That way
 1:       // the logic in SetValueInternal() will work right (that logic makes
 1:       // assumptions about our frame based on mType, but we won't have had time
 1:       // to recreate frames yet -- that happens later in the SetAttr()
 1:       // process).
 1:       PRInt32 newType = aResult.GetEnumValue();
 1:       if (newType == NS_FORM_INPUT_FILE) {
 1:         // These calls aren't strictly needed any more since we'll never
 1:         // confuse values and filenames. However they're there for backwards
 1:         // compat.
 1:         SetFileName(EmptyString());
 1:         SetValueInternal(EmptyString(), nsnull);
 1:       }
 1: 
 1:       mType = newType;
 1: 
 1:       return PR_TRUE;
 1:     }
 1:     if (aAttribute == nsGkAtoms::width) {
 1:       return aResult.ParseSpecialIntValue(aValue, PR_TRUE, PR_FALSE);
 1:     }
 1:     if (aAttribute == nsGkAtoms::height) {
 1:       return aResult.ParseSpecialIntValue(aValue, PR_TRUE, PR_FALSE);
 1:     }
 1:     if (aAttribute == nsGkAtoms::maxlength) {
 1:       return aResult.ParseIntWithBounds(aValue, 0);
 1:     }
 1:     if (aAttribute == nsGkAtoms::size) {
 1:       return aResult.ParseIntWithBounds(aValue, 0);
 1:     }
 1:     if (aAttribute == nsGkAtoms::border) {
 1:       return aResult.ParseIntWithBounds(aValue, 0);
 1:     }
 1:     if (aAttribute == nsGkAtoms::align) {
 1:       return ParseAlignValue(aValue, aResult);
 1:     }
 1:     if (ParseImageAttribute(aAttribute, aValue, aResult)) {
 1:       // We have to call |ParseImageAttribute| unconditionally since we
 1:       // don't know if we're going to have a type="image" attribute yet,
 1:       // (or could have it set dynamically in the future).  See bug
 1:       // 214077.
 1:       return PR_TRUE;
 1:     }
 1:   }
 1: 
 1:   return nsGenericHTMLElement::ParseAttribute(aNamespaceID, aAttribute, aValue,
 1:                                               aResult);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::GetType(nsAString& aValue)
 1: {
 1:   const nsAttrValue::EnumTable *table = kInputTypeTable;
 1: 
 1:   while (table->tag) {
 1:     if (mType == table->value) {
 1:       CopyUTF8toUTF16(table->tag, aValue);
 1: 
 1:       return NS_OK;
 1:     }
 1: 
 1:     ++table;
 1:   }
 1: 
 1:   NS_ERROR("Shouldn't get here!");
 1: 
 1:   aValue.Truncate();
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SetType(const nsAString& aValue)
 1: {
 1:   return SetAttrHelper(nsGkAtoms::type, aValue);
 1: }
 1: 
 1: static void
 1: MapAttributesIntoRule(const nsMappedAttributes* aAttributes,
 1:                       nsRuleData* aData)
 1: {
 1:   const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::type);
 1:   if (value && value->Type() == nsAttrValue::eEnum &&
 1:       value->GetEnumValue() == NS_FORM_INPUT_IMAGE) {
 1:     nsGenericHTMLFormElement::MapImageBorderAttributeInto(aAttributes, aData);
 1:     nsGenericHTMLFormElement::MapImageMarginAttributeInto(aAttributes, aData);
 1:     nsGenericHTMLFormElement::MapImageSizeAttributesInto(aAttributes, aData);
 1:     // Images treat align as "float"
 1:     nsGenericHTMLFormElement::MapImageAlignAttributeInto(aAttributes, aData);
 1:   } 
 1: 
 1:   nsGenericHTMLFormElement::MapCommonAttributesInto(aAttributes, aData);
 1: }
 1: 
 1: nsChangeHint
 1: nsHTMLInputElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
 1:                                            PRInt32 aModType) const
 1: {
 1:   nsChangeHint retval =
 1:     nsGenericHTMLFormElement::GetAttributeChangeHint(aAttribute, aModType);
 1:   if (aAttribute == nsGkAtoms::type) {
 1:     NS_UpdateHint(retval, NS_STYLE_HINT_FRAMECHANGE);
 1:   } else if (aAttribute == nsGkAtoms::value) {
 1:     NS_UpdateHint(retval, NS_STYLE_HINT_REFLOW);
 1:   } else if (aAttribute == nsGkAtoms::size &&
 1:              (mType == NS_FORM_INPUT_TEXT ||
 1:               mType == NS_FORM_INPUT_PASSWORD)) {
 1:     NS_UpdateHint(retval, NS_STYLE_HINT_REFLOW);
 1:   }
 1:   return retval;
 1: }
 1: 
 1: NS_IMETHODIMP_(PRBool)
 1: nsHTMLInputElement::IsAttributeMapped(const nsIAtom* aAttribute) const
 1: {
 1:   static const MappedAttributeEntry attributes[] = {
 1:     { &nsGkAtoms::align },
 1:     { &nsGkAtoms::type },
 1:     { nsnull },
 1:   };
 1: 
 1:   static const MappedAttributeEntry* const map[] = {
 1:     attributes,
 1:     sCommonAttributeMap,
 1:     sImageMarginSizeAttributeMap,
 1:     sImageBorderAttributeMap,
 1:   };
 1: 
 1:   return FindAttributeDependence(aAttribute, map, NS_ARRAY_LENGTH(map));
 1: }
 1: 
 1: nsMapRuleToAttributesFunc
 1: nsHTMLInputElement::GetAttributeMappingFunction() const
 1: {
 1:   return &MapAttributesIntoRule;
 1: }
 1: 
 1: 
 1: // Controllers Methods
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::GetControllers(nsIControllers** aResult)
 1: {
 1:   NS_ENSURE_ARG_POINTER(aResult);
 1: 
 1:   //XXX: what about type "file"?
 1:   if (mType == NS_FORM_INPUT_TEXT || mType == NS_FORM_INPUT_PASSWORD)
 1:   {
 1:     if (!mControllers)
 1:     {
 1:       nsresult rv;
 1:       mControllers = do_CreateInstance(kXULControllersCID, &rv);
 1:       NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:       nsCOMPtr<nsIController>
 1:         controller(do_CreateInstance("@mozilla.org/editor/editorcontroller;1",
 1:                                      &rv));
 1:       NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:       mControllers->AppendController(controller);
 1:     }
 1:   }
 1: 
 1:   *aResult = mControllers;
 1:   NS_IF_ADDREF(*aResult);
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::GetTextLength(PRInt32* aTextLength)
 1: {
 1:   nsAutoString val;
 1: 
 1:   nsresult rv = GetValue(val);
 1: 
 1:   *aTextLength = val.Length();
 1: 
 1:   return rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SetSelectionRange(PRInt32 aSelectionStart,
 1:                                       PRInt32 aSelectionEnd)
 1: {
 1:   nsresult rv = NS_ERROR_FAILURE;
 1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
 1: 
 1:   if (formControlFrame) {
 1:     nsITextControlFrame* textControlFrame = nsnull;
 1:     CallQueryInterface(formControlFrame, &textControlFrame);
 1: 
 1:     if (textControlFrame)
 1:       rv = textControlFrame->SetSelectionRange(aSelectionStart, aSelectionEnd);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::GetSelectionStart(PRInt32* aSelectionStart)
 1: {
 1:   NS_ENSURE_ARG_POINTER(aSelectionStart);
 1:   
 1:   PRInt32 selEnd;
 1:   return GetSelectionRange(aSelectionStart, &selEnd);
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SetSelectionStart(PRInt32 aSelectionStart)
 1: {
 1:   nsresult rv = NS_ERROR_FAILURE;
 1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
 1: 
 1:   if (formControlFrame) {
 1:     nsITextControlFrame* textControlFrame = nsnull;
 1:     CallQueryInterface(formControlFrame, &textControlFrame);
 1: 
 1:     if (textControlFrame)
 1:       rv = textControlFrame->SetSelectionStart(aSelectionStart);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::GetSelectionEnd(PRInt32* aSelectionEnd)
 1: {
 1:   NS_ENSURE_ARG_POINTER(aSelectionEnd);
 1:   
 1:   PRInt32 selStart;
 1:   return GetSelectionRange(&selStart, aSelectionEnd);
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SetSelectionEnd(PRInt32 aSelectionEnd)
 1: {
 1:   nsresult rv = NS_ERROR_FAILURE;
 1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
 1: 
 1:   if (formControlFrame) {
 1:     nsITextControlFrame* textControlFrame = nsnull;
 1:     CallQueryInterface(formControlFrame, &textControlFrame);
 1: 
 1:     if (textControlFrame)
 1:       rv = textControlFrame->SetSelectionEnd(aSelectionEnd);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::GetSelectionRange(PRInt32* aSelectionStart,
 1:                                       PRInt32* aSelectionEnd)
 1: {
 1:   nsresult rv = NS_ERROR_FAILURE;
 1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
 1: 
 1:   if (formControlFrame) {
 1:     nsITextControlFrame* textControlFrame = nsnull;
 1:     CallQueryInterface(formControlFrame, &textControlFrame);
 1: 
 1:     if (textControlFrame)
 1:       rv = textControlFrame->GetSelectionRange(aSelectionStart, aSelectionEnd);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::GetPhonetic(nsAString& aPhonetic)
 1: {
 1:   aPhonetic.Truncate(0);
 1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_TRUE);
 1: 
 1:   if (formControlFrame) {
 1:     nsCOMPtr<nsIPhonetic>
 1:       phonetic(do_QueryInterface(formControlFrame));
 1: 
 1:     if (phonetic)
 1:       phonetic->GetPhonetic(aPhonetic);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: #ifdef ACCESSIBILITY
 1: /*static*/ nsresult
 1: FireEventForAccessibility(nsIDOMHTMLInputElement* aTarget,
 1:                           nsPresContext* aPresContext,
 1:                           const nsAString& aEventType)
 1: {
 1:   nsCOMPtr<nsIDOMEvent> event;
 1:   if (NS_SUCCEEDED(nsEventDispatcher::CreateEvent(aPresContext, nsnull,
 1:                                                   NS_LITERAL_STRING("Events"),
 1:                                                   getter_AddRefs(event)))) {
 1:     event->InitEvent(aEventType, PR_TRUE, PR_TRUE);
 1: 
 1:     nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
 1:     if (privateEvent) {
 1:       privateEvent->SetTrusted(PR_TRUE);
 1:     }
 1: 
 1:     nsEventDispatcher::DispatchDOMEvent(aTarget, nsnull, event, aPresContext, nsnull);
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: #endif
 1: 
 1: nsresult
 1: nsHTMLInputElement::Reset()
 1: {
 1:   nsresult rv = NS_OK;
 1: 
 1:   nsIFormControlFrame* formControlFrame = GetFormControlFrame(PR_FALSE);
 1: 
 1:   switch (mType) {
 1:     case NS_FORM_INPUT_CHECKBOX:
 1:     case NS_FORM_INPUT_RADIO:
 1:     {
 1:       PRBool resetVal;
 1:       GetDefaultChecked(&resetVal);
 1:       rv = DoSetChecked(resetVal);
 1:       SetCheckedChanged(PR_FALSE);
 1:       break;
 1:     }
 1:     case NS_FORM_INPUT_PASSWORD:
 1:     case NS_FORM_INPUT_TEXT:
 1:     {
 1:       // If the frame is there, we have to set the value so that it will show
 1:       // up.
 1:       if (formControlFrame) {
 1:         nsAutoString resetVal;
 1:         GetDefaultValue(resetVal);
 1:         rv = SetValue(resetVal);
 1:       }
 1:       SetValueChanged(PR_FALSE);
 1:       break;
 1:     }
 1:     case NS_FORM_INPUT_FILE:
 1:     {
 1:       // Resetting it to blank should not perform security check
 1:       SetFileName(EmptyString());
 1:       break;
 1:     }
 1:     // Value is the same as defaultValue for hidden inputs
 1:     case NS_FORM_INPUT_HIDDEN:
 1:     default:
 1:       break;
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SubmitNamesValues(nsIFormSubmission* aFormSubmission,
 1:                                       nsIContent* aSubmitElement)
 1: {
 1:   nsresult rv = NS_OK;
 1: 
 1:   //
 1:   // Disabled elements don't submit
 1:   //
 1:   PRBool disabled;
 1:   rv = GetDisabled(&disabled);
 1:   if (NS_FAILED(rv) || disabled) {
 1:     return rv;
 1:   }
 1: 
 1:   //
 1:   // For type=reset, and type=button, we just never submit, period.
 1:   //
 1:   if (mType == NS_FORM_INPUT_RESET || mType == NS_FORM_INPUT_BUTTON) {
 1:     return rv;
 1:   }
 1: 
 1:   //
 1:   // For type=image and type=button, we only submit if we were the button
 1:   // pressed
 1:   //
 1:   if ((mType == NS_FORM_INPUT_SUBMIT || mType == NS_FORM_INPUT_IMAGE)
 1:       && aSubmitElement != this) {
 1:     return rv;
 1:   }
 1: 
 1:   //
 1:   // For type=radio and type=checkbox, we only submit if checked=true
 1:   //
 1:   if (mType == NS_FORM_INPUT_RADIO || mType == NS_FORM_INPUT_CHECKBOX) {
 1:     PRBool checked;
 1:     rv = GetChecked(&checked);
 1:     if (NS_FAILED(rv) || !checked) {
 1:       return rv;
 1:     }
 1:   }
 1: 
 1:   //
 1:   // Get the name
 1:   //
 1:   nsAutoString name;
 1:   PRBool nameThere = GetNameIfExists(name);
 1: 
 1:   //
 1:   // Submit .x, .y for input type=image
 1:   //
 1:   if (mType == NS_FORM_INPUT_IMAGE) {
 1:     // Get a property set by the frame to find out where it was clicked.
 1:     nsAutoString xVal;
 1:     nsAutoString yVal;
 1: 
 1:     nsIntPoint* lastClickedPoint =
 1:       NS_STATIC_CAST(nsIntPoint*, GetProperty(nsGkAtoms::imageClickedPoint));
 1:     if (lastClickedPoint) {
 1:       // Convert the values to strings for submission
 1:       xVal.AppendInt(lastClickedPoint->x);
 1:       yVal.AppendInt(lastClickedPoint->y);
 1:     }
 1: 
 1:     if (!name.IsEmpty()) {
 1:       aFormSubmission->AddNameValuePair(this,
 1:                                         name + NS_LITERAL_STRING(".x"), xVal);
 1:       aFormSubmission->AddNameValuePair(this,
 1:                                         name + NS_LITERAL_STRING(".y"), yVal);
 1:     } else {
 1:       // If the Image Element has no name, simply return x and y
 1:       // to Nav and IE compatibility.
 1:       aFormSubmission->AddNameValuePair(this, NS_LITERAL_STRING("x"), xVal);
 1:       aFormSubmission->AddNameValuePair(this, NS_LITERAL_STRING("y"), yVal);
 1:     }
 1:   }
 1: 
 1:   //
 1:   // Submit name=value
 1:   //
 1: 
 1:   // If name not there, don't submit
 1:   if (!nameThere) {
 1:     return rv;
 1:   }
 1: 
 1:   // Get the value
 1:   nsAutoString value;
 1:   rv = GetValue(value);
 1:   if (NS_FAILED(rv)) {
 1:     return rv;
 1:   }
 1: 
 1:   if (mType == NS_FORM_INPUT_SUBMIT && value.IsEmpty() &&
 1:       !HasAttr(kNameSpaceID_None, nsGkAtoms::value)) {
 1:     // Get our default value, which is the same as our default label
 1:     nsXPIDLString defaultValue;
 1:     nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
 1:                                        "Submit", defaultValue);
 1:     value = defaultValue;
 1:   }
 1:       
 1:   //
 1:   // Submit file if it's input type=file and this encoding method accepts files
 1:   //
 1:   if (mType == NS_FORM_INPUT_FILE) {
 1:     //
 1:     // Open the file
 1:     //
 1:     nsCOMPtr<nsIFile> file;
 1:  
 1:     if (mFileName) {
 1:       if (StringBeginsWith(*mFileName, NS_LITERAL_STRING("file:"),
 1:                            nsCaseInsensitiveStringComparator())) {
 1:         // Converts the URL string into the corresponding nsIFile if possible.
 1:         // A local file will be created if the URL string begins with file://.
 1:         rv = NS_GetFileFromURLSpec(NS_ConvertUTF16toUTF8(*mFileName),
 1:                                    getter_AddRefs(file));
 1:       }
 1:       if (!file) {
 1:         // this is no "file://", try as local file
 1:         nsCOMPtr<nsILocalFile> localFile;
 1:         rv = NS_NewLocalFile(*mFileName, PR_FALSE, getter_AddRefs(localFile));
 1:         file = localFile;
 1:       }
 1:     }
 1: 
 1:     if (file) {
 1: 
 1:       //
 1:       // Get the leaf path name (to be submitted as the value)
 1:       //
 1:       nsAutoString filename;
 1:       rv = file->GetLeafName(filename);
 1: 
 1:       if (NS_SUCCEEDED(rv) && !filename.IsEmpty()) {
 1:         PRBool acceptsFiles = aFormSubmission->AcceptsFiles();
 1: 
 1:         if (acceptsFiles) {
 1:           //
 1:           // Get content type
 1:           //
 1:           nsCOMPtr<nsIMIMEService> MIMEService =
 1:             do_GetService(NS_MIMESERVICE_CONTRACTID, &rv);
 1:           NS_ENSURE_SUCCESS(rv, rv);
 1: 
 1:           nsCAutoString contentType;
 1:           rv = MIMEService->GetTypeFromFile(file, contentType);
 1:           if (NS_FAILED(rv)) {
 1:             contentType.AssignLiteral("application/octet-stream");
 1:           }
 1: 
 1:           //
 1:           // Get input stream
 1:           //
 1:           nsCOMPtr<nsIInputStream> fileStream;
 1:           rv = NS_NewLocalFileInputStream(getter_AddRefs(fileStream),
 1:                                           file, -1, -1,
 1:                                           nsIFileInputStream::CLOSE_ON_EOF |
 1:                                           nsIFileInputStream::REOPEN_ON_REWIND);
 1:           if (fileStream) {
 1:             //
 1:             // Create buffered stream (for efficiency)
 1:             //
 1:             nsCOMPtr<nsIInputStream> bufferedStream;
 1:             rv = NS_NewBufferedInputStream(getter_AddRefs(bufferedStream),
 1:                                            fileStream, 8192);
 1:             NS_ENSURE_SUCCESS(rv, rv);
 1:             if (bufferedStream) {
 1:               //
 1:               // Submit
 1:               //
 1:               aFormSubmission->AddNameFilePair(this, name, filename,
 1:                                                bufferedStream, contentType,
 1:                                                PR_FALSE);
 1:               return rv;
 1:             }
 1:           }
 1:         }
 1: 
 1:         //
 1:         // If we don't submit as a file, at least submit the truncated filename.
 1:         //
 1:         aFormSubmission->AddNameFilePair(this, name, filename,
 1:             nsnull, NS_LITERAL_CSTRING("application/octet-stream"),
 1:             PR_FALSE);
 1:         return rv;
 1:       } else {
 1:         // Ignore error returns from GetLeafName.  See bug 199053
 1:         rv = NS_OK;
 1:       }
 1:     }
 1:     
 1:     //
 1:     // If we can't even make a truncated filename, submit empty string
 1:     // rather than sending everything
 1:     //
 1:     aFormSubmission->AddNameFilePair(this, name, EmptyString(),
 1:         nsnull, NS_LITERAL_CSTRING("application/octet-stream"),
 1:         PR_FALSE);
 1:     return rv;
 1:   }
 1: 
 1:   // Submit
 1:   // (for type=image, only submit if value is non-null)
 1:   if (mType != NS_FORM_INPUT_IMAGE || !value.IsEmpty()) {
 1:     rv = aFormSubmission->AddNameValuePair(this, name, value);
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::SaveState()
 1: {
 1:   nsresult rv = NS_OK;
 1: 
 1:   nsPresState *state = nsnull;
 1:   switch (mType) {
 1:     case NS_FORM_INPUT_CHECKBOX:
 1:     case NS_FORM_INPUT_RADIO:
 1:       {
 1:         PRBool checked = PR_FALSE;
 1:         GetChecked(&checked);
 1:         PRBool defaultChecked = PR_FALSE;
 1:         GetDefaultChecked(&defaultChecked);
 1:         // Only save if checked != defaultChecked (bug 62713)
 1:         // (always save if it's a radio button so that the checked
 1:         // state of all radio buttons is restored)
 1:         if (mType == NS_FORM_INPUT_RADIO || checked != defaultChecked) {
 1:           rv = GetPrimaryPresState(this, &state);
 1:           if (state) {
 1:             if (checked) {
 1:               rv = state->SetStateProperty(NS_LITERAL_STRING("checked"),
 1:                                            NS_LITERAL_STRING("t"));
 1:             } else {
 1:               rv = state->SetStateProperty(NS_LITERAL_STRING("checked"),
 1:                                            NS_LITERAL_STRING("f"));
 1:             }
 1:             NS_ASSERTION(NS_SUCCEEDED(rv), "checked save failed!");
 1:           }
 1:         }
 1:         break;
 1:       }
 1: 
 1:     // Never save passwords in session history
 1:     case NS_FORM_INPUT_PASSWORD:
 1:       break;
 1:     case NS_FORM_INPUT_TEXT:
 1:     case NS_FORM_INPUT_HIDDEN:
 1:       {
 1:         if (GET_BOOLBIT(mBitField, BF_VALUE_CHANGED)) {
 1:           rv = GetPrimaryPresState(this, &state);
 1:           if (state) {
 1:             nsAutoString value;
 1:             GetValue(value);
 1:             rv = nsLinebreakConverter::ConvertStringLineBreaks(
 1:                      value,
 1:                      nsLinebreakConverter::eLinebreakPlatform,
 1:                      nsLinebreakConverter::eLinebreakContent);
 1:             NS_ASSERTION(NS_SUCCEEDED(rv), "Converting linebreaks failed!");
 1:             rv = state->SetStateProperty(NS_LITERAL_STRING("v"), value);
 1:             NS_ASSERTION(NS_SUCCEEDED(rv), "value save failed!");
 1:           }
 1:         }
 1:         break;
 1:       }
 1:     case NS_FORM_INPUT_FILE:
 1:       {
 1:         if (mFileName) {
 1:           rv = GetPrimaryPresState(this, &state);
 1:           if (state) {
 1:             rv = state->SetStateProperty(NS_LITERAL_STRING("f"), *mFileName);
 1:             NS_ASSERTION(NS_SUCCEEDED(rv), "value save failed!");
 1:           }
 1:         }
 1:         break;
 1:       }
 1:   }
 1:   
 1:   if (GET_BOOLBIT(mBitField, BF_DISABLED_CHANGED)) {
 1:     rv |= GetPrimaryPresState(this, &state);
 1:     if (state) {
 1:       PRBool disabled;
 1:       GetDisabled(&disabled);
 1:       if (disabled) {
 1:         rv |= state->SetStateProperty(NS_LITERAL_STRING("disabled"),
 1:                                      NS_LITERAL_STRING("t"));
 1:       } else {
 1:         rv |= state->SetStateProperty(NS_LITERAL_STRING("disabled"),
 1:                                      NS_LITERAL_STRING("f"));
 1:       }
 1:       NS_ASSERTION(NS_SUCCEEDED(rv), "disabled save failed!");
 1:     }
 1:   }
 1: 
 1:   return rv;
 1: }
 1: 
 1: void
 1: nsHTMLInputElement::DoneCreatingElement()
 1: {
 1:   SET_BOOLBIT(mBitField, BF_PARSER_CREATING, PR_FALSE);
 1: 
 1:   //
 1:   // Restore state as needed.  Note that disabled state applies to all control
 1:   // types.
 1:   //
 1:   PRBool restoredCheckedState = RestoreFormControlState(this, this);
 1: 
 1:   //
 1:   // If restore does not occur, we initialize .checked using the CHECKED
 1:   // property.
 1:   //
 1:   if (!restoredCheckedState &&
 1:       GET_BOOLBIT(mBitField, BF_SHOULD_INIT_CHECKED)) {
 1:     PRBool resetVal;
 1:     GetDefaultChecked(&resetVal);
 1:     DoSetChecked(resetVal, PR_FALSE);
 1:     DoSetCheckedChanged(PR_FALSE, PR_FALSE);
 1:   }
 1: 
 1:   SET_BOOLBIT(mBitField, BF_SHOULD_INIT_CHECKED, PR_FALSE);
 1: }
 1: 
 1: PRInt32
 1: nsHTMLInputElement::IntrinsicState() const
 1: {
 1:   // If you add states here, and they're type-dependent, you need to add them
 1:   // to the type case in AfterSetAttr.
 1:   
 1:   PRInt32 state = nsGenericHTMLFormElement::IntrinsicState();
 1:   if (mType == NS_FORM_INPUT_CHECKBOX || mType == NS_FORM_INPUT_RADIO) {
 1:     // Check current checked state (:checked)
 1:     if (GET_BOOLBIT(mBitField, BF_CHECKED)) {
 1:       state |= NS_EVENT_STATE_CHECKED;
 1:     }
 1: 
 1:     // Check whether we are the default checked element (:default)
 1:     // The call is to an interface function, which makes it non-const, so we
 1:     // use a nasty hack :(
 1:     PRBool defaultState = PR_FALSE;
 1:     NS_CONST_CAST(nsHTMLInputElement*, this)->GetDefaultChecked(&defaultState);
 1:     if (defaultState) {
 1:       state |= NS_EVENT_STATE_DEFAULT;
 1:     }
 1:   } else if (mType == NS_FORM_INPUT_IMAGE) {
 1:     state |= nsImageLoadingContent::ImageState();
 1:   }
 1: 
 1:   return state;
 1: }
 1: 
 1: PRBool
 1: nsHTMLInputElement::RestoreState(nsPresState* aState)
 1: {
 1:   PRBool restoredCheckedState = PR_FALSE;
 1: 
 1:   nsresult rv;
 1:   
 1:   switch (mType) {
 1:     case NS_FORM_INPUT_CHECKBOX:
 1:     case NS_FORM_INPUT_RADIO:
 1:       {
 1:         nsAutoString checked;
 1:         rv = aState->GetStateProperty(NS_LITERAL_STRING("checked"), checked);
 1:         NS_ASSERTION(NS_SUCCEEDED(rv), "checked restore failed!");
 1:         if (rv == NS_STATE_PROPERTY_EXISTS) {
 1:           restoredCheckedState = PR_TRUE;
 1:           DoSetChecked(checked.EqualsLiteral("t"), PR_FALSE);
 1:         }
 1:         break;
 1:       }
 1: 
 1:     case NS_FORM_INPUT_TEXT:
 1:     case NS_FORM_INPUT_HIDDEN:
 1:       {
 1:         nsAutoString value;
 1:         rv = aState->GetStateProperty(NS_LITERAL_STRING("v"), value);
 1:         NS_ASSERTION(NS_SUCCEEDED(rv), "value restore failed!");
 1:         if (rv == NS_STATE_PROPERTY_EXISTS) {
 1:           SetValueInternal(value, nsnull);
 1:         }
 1:         break;
 1:       }
 1:     case NS_FORM_INPUT_FILE:
 1:       {
 1:         nsAutoString value;
 1:         rv = aState->GetStateProperty(NS_LITERAL_STRING("f"), value);
 1:         NS_ASSERTION(NS_SUCCEEDED(rv), "value restore failed!");
 1:         if (rv == NS_STATE_PROPERTY_EXISTS) {
 1:           SetFileName(value);
 1:         }
 1:         break;
 1:       }
 1:   }
 1:   
 1:   nsAutoString disabled;
 1:   rv = aState->GetStateProperty(NS_LITERAL_STRING("disabled"), disabled);
 1:   NS_ASSERTION(NS_SUCCEEDED(rv), "disabled restore failed!");
 1:   if (rv == NS_STATE_PROPERTY_EXISTS) {
 1:     SetDisabled(disabled.EqualsLiteral("t"));
 1:   }
 1: 
 1:   return restoredCheckedState;
 1: }
 1: 
 1: PRBool
 1: nsHTMLInputElement::AllowDrop()
 1: {
 1:   // Allow drop on anything other than file inputs.
 1: 
 1:   return mType != NS_FORM_INPUT_FILE;
 1: }
 1: 
 1: /*
 1:  * Radio group stuff
 1:  */
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::AddedToRadioGroup(PRBool aNotify)
 1: {
 1:   // Make sure not to notify if we're still being created by the parser
 1:   aNotify = aNotify && !GET_BOOLBIT(mBitField, BF_PARSER_CREATING);
 1: 
 1:   //
 1:   //  If the input element is not in a form and
 1:   //  not in a document, we just need to return.
 1:   //
 1:   if (!mForm && !(IsInDoc() && GetParent())) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   //
 1:   // If the input element is checked, and we add it to the group, it will
 1:   // deselect whatever is currently selected in that group
 1:   //
 1:   PRBool checked;
 1:   GetChecked(&checked);
 1:   if (checked) {
 1:     //
 1:     // If it is checked, call "RadioSetChecked" to perform the selection/
 1:     // deselection ritual.  This has the side effect of repainting the
 1:     // radio button, but as adding a checked radio button into the group
 1:     // should not be that common an occurrence, I think we can live with
 1:     // that.
 1:     //
 1:     RadioSetChecked(aNotify);
 1:   }
 1: 
 1:   //
 1:   // For integrity purposes, we have to ensure that "checkedChanged" is
 1:   // the same for this new element as for all the others in the group
 1:   //
 1:   PRBool checkedChanged = PR_FALSE;
 1:   nsCOMPtr<nsIRadioVisitor> visitor;
 1:   nsresult rv = NS_GetRadioGetCheckedChangedVisitor(&checkedChanged, this,
 1:                                            getter_AddRefs(visitor));
 1:   NS_ENSURE_SUCCESS(rv, rv);
 1:   
 1:   VisitGroup(visitor, aNotify);
 1:   SetCheckedChangedInternal(checkedChanged);
 1:   
 1:   //
 1:   // Add the radio to the radio group container.
 1:   //
 1:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
 1:   if (container) {
 1:     nsAutoString name;
 1:     if (GetNameIfExists(name)) {
 1:       container->AddToRadioGroup(name, NS_STATIC_CAST(nsIFormControl*, this));
 1:     }
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: NS_IMETHODIMP
 1: nsHTMLInputElement::WillRemoveFromRadioGroup()
 1: {
 1:   //
 1:   // If the input element is not in a form and
 1:   // not in a document, we just need to return.
 1:   //
 1:   if (!mForm && !(IsInDoc() && GetParent())) {
 1:     return NS_OK;
 1:   }
 1: 
 1:   //
 1:   // If this button was checked, we need to notify the group that there is no
 1:   // longer a selected radio button
 1:   //
 1:   PRBool checked = PR_FALSE;
 1:   GetChecked(&checked);
 1: 
 1:   nsAutoString name;
 1:   PRBool gotName = PR_FALSE;
 1:   if (checked) {
 1:     if (!gotName) {
 1:       if (!GetNameIfExists(name)) {
 1:         // If the name doesn't exist, nothing is going to happen anyway
 1:         return NS_OK;
 1:       }
 1:       gotName = PR_TRUE;
 1:     }
 1: 
 1:     nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
 1:     if (container) {
 1:       container->SetCurrentRadioButton(name, nsnull);
 1:     }
 1:   }
 1:   
 1:   //
 1:   // Remove this radio from its group in the container
 1:   //
 1:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
 1:   if (container) {
 1:     if (!gotName) {
 1:       if (!GetNameIfExists(name)) {
 1:         // If the name doesn't exist, nothing is going to happen anyway
 1:         return NS_OK;
 1:       }
 1:       gotName = PR_TRUE;
 1:     }
 1:     container->RemoveFromRadioGroup(name,
 1:                                     NS_STATIC_CAST(nsIFormControl*, this));
 1:   }
 1: 
 1:   return NS_OK;
 1: }
 1: 
 1: PRBool
 1: nsHTMLInputElement::IsFocusable(PRInt32 *aTabIndex)
 1: {
 1:   if (!nsGenericHTMLElement::IsFocusable(aTabIndex)) {
 1:     return PR_FALSE;
 1:   }
 1: 
 1:   if (mType == NS_FORM_INPUT_TEXT || mType == NS_FORM_INPUT_PASSWORD) {
 1:     return PR_TRUE;
 1:   }
 1: 
 1:   if (mType == NS_FORM_INPUT_HIDDEN || mType == NS_FORM_INPUT_FILE) {
 1:     // Sub controls of file input are tabbable, not the file input itself.
 1:     if (aTabIndex) {
 1:       *aTabIndex = -1;
 1:     }
 1:     return PR_FALSE;
 1:   }
 1: 
 1:   if (!aTabIndex) {
 1:     // The other controls are all focusable
 1:     return PR_TRUE;
 1:   }
 1: 
 1:   // We need to set tabindex to -1 if we're not tabbable
 1:   if (mType != NS_FORM_INPUT_TEXT && mType != NS_FORM_INPUT_PASSWORD &&
 1:       !(sTabFocusModel & eTabFocus_formElementsMask)) {
 1:     *aTabIndex = -1;
 1:   }
 1: 
 1:   if (mType != NS_FORM_INPUT_RADIO) {
 1:     return PR_TRUE;
 1:   }
 1: 
 1:   PRBool checked;
 1:   GetChecked(&checked);
 1:   if (checked) {
 1:     // Selected radio buttons are tabbable
 1:     return PR_TRUE;
 1:   }
 1: 
 1:   // Current radio button is not selected.
 1:   // But make it tabbable if nothing in group is selected.
 1:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
 1:   nsAutoString name;
 1:   if (!container || !GetNameIfExists(name)) {
 1:     return PR_TRUE;
 1:   }
 1: 
 1:   nsCOMPtr<nsIDOMHTMLInputElement> currentRadio;
 1:   container->GetCurrentRadioButton(name, getter_AddRefs(currentRadio));
 1:   if (currentRadio) {
 1:     *aTabIndex = -1;
 1:   }
 1:   return PR_TRUE;
 1: }
 1: 
 1: nsresult
 1: nsHTMLInputElement::VisitGroup(nsIRadioVisitor* aVisitor, PRBool aFlushContent)
 1: {
 1:   nsresult rv = NS_OK;
 1:   nsCOMPtr<nsIRadioGroupContainer> container = GetRadioGroupContainer();
 1:   if (container) {
 1:     nsAutoString name;
 1:     if (GetNameIfExists(name)) {
 1:       rv = container->WalkRadioGroup(name, aVisitor, aFlushContent);
 1:     } else {
 1:       PRBool stop;
 1:       aVisitor->Visit(this, &stop);
 1:     }
 1:   } else {
 1:     PRBool stop;
 1:     aVisitor->Visit(this, &stop);
 1:   }
 1:   return rv;
 1: }
 1: 
 1: 
 1: //
 1: // Visitor classes
 1: //
 1: //
 1: // CLASS nsRadioVisitor
 1: //
 1: // (this is the superclass of the others)
 1: //
 1: class nsRadioVisitor : public nsIRadioVisitor {
 1: public:
 1:   nsRadioVisitor() { }
 1:   virtual ~nsRadioVisitor() { };
 1: 
 1:   NS_DECL_ISUPPORTS
 1: 
 1:   NS_IMETHOD Visit(nsIFormControl* aRadio, PRBool* aStop) = 0;
 1: };
 1: 
 1: NS_IMPL_ADDREF(nsRadioVisitor)
 1: NS_IMPL_RELEASE(nsRadioVisitor)
 1: 
 1: NS_INTERFACE_MAP_BEGIN(nsRadioVisitor)
 1:   NS_INTERFACE_MAP_ENTRY(nsIRadioVisitor)
 1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 1: NS_INTERFACE_MAP_END
 1: 
 1: 
 1: //
 1: // CLASS nsRadioSetCheckedChangedVisitor
 1: //
 1: class nsRadioSetCheckedChangedVisitor : public nsRadioVisitor {
 1: public:
 1:   nsRadioSetCheckedChangedVisitor(PRBool aCheckedChanged) :
 1:     nsRadioVisitor(), mCheckedChanged(aCheckedChanged)
 1:     { }
 1: 
 1:   virtual ~nsRadioSetCheckedChangedVisitor() { }
 1: 
 1:   NS_IMETHOD Visit(nsIFormControl* aRadio, PRBool* aStop)
 1:   {
 1:     nsCOMPtr<nsIRadioControlElement> radio(do_QueryInterface(aRadio));
 1:     NS_ASSERTION(radio, "Visit() passed a null button (or non-radio)!");
 1:     radio->SetCheckedChangedInternal(mCheckedChanged);
 1:     return NS_OK;
 1:   }
 1: 
 1: protected:
 1:   PRPackedBool mCheckedChanged;
 1: };
 1: 
 1: //
 1: // CLASS nsRadioGetCheckedChangedVisitor
 1: //
 1: class nsRadioGetCheckedChangedVisitor : public nsRadioVisitor {
 1: public:
 1:   nsRadioGetCheckedChangedVisitor(PRBool* aCheckedChanged,
 1:                                   nsIFormControl* aExcludeElement) :
 1:     nsRadioVisitor(),
 1:     mCheckedChanged(aCheckedChanged),
 1:     mExcludeElement(aExcludeElement)
 1:     { }
 1: 
 1:   virtual ~nsRadioGetCheckedChangedVisitor() { }
 1: 
 1:   NS_IMETHOD Visit(nsIFormControl* aRadio, PRBool* aStop)
 1:   {
 1:     if (aRadio == mExcludeElement) {
 1:       return NS_OK;
 1:     }
 1:     nsCOMPtr<nsIRadioControlElement> radio(do_QueryInterface(aRadio));
 1:     NS_ASSERTION(radio, "Visit() passed a null button (or non-radio)!");
 1:     radio->GetCheckedChanged(mCheckedChanged);
 1:     *aStop = PR_TRUE;
 1:     return NS_OK;
 1:   }
 1: 
 1: protected:
 1:   PRBool* mCheckedChanged;
 1:   nsIFormControl* mExcludeElement;
 1: };
 1: 
 1: nsresult
 1: NS_GetRadioSetCheckedChangedVisitor(PRBool aCheckedChanged,
 1:                                     nsIRadioVisitor** aVisitor)
 1: {
 1:   //
 1:   // These are static so that we don't have to keep creating new visitors for
 1:   // such an ordinary process all the time.  There are only two possibilities
 1:   // for this visitor: set to true, and set to false.
 1:   //
 1:   static nsIRadioVisitor* sVisitorTrue = nsnull;
 1:   static nsIRadioVisitor* sVisitorFalse = nsnull;
 1: 
 1:   //
 1:   // Get the visitor that sets them to true
 1:   //
 1:   if (aCheckedChanged) {
 1:     if (!sVisitorTrue) {
 1:       sVisitorTrue = new nsRadioSetCheckedChangedVisitor(PR_TRUE);
 1:       if (!sVisitorTrue) {
 1:         return NS_ERROR_OUT_OF_MEMORY;
 1:       }
 1:       NS_ADDREF(sVisitorTrue);
 1:       nsresult rv =
 1:         nsContentUtils::ReleasePtrOnShutdown((nsISupports**)&sVisitorTrue);
 1:       if (NS_FAILED(rv)) {
 1:         NS_RELEASE(sVisitorTrue);
 1:         return rv;
 1:       }
 1:     }
 1:     *aVisitor = sVisitorTrue;
 1:   }
 1:   //
 1:   // Get the visitor that sets them to false
 1:   //
 1:   else {
 1:     if (!sVisitorFalse) {
 1:       sVisitorFalse = new nsRadioSetCheckedChangedVisitor(PR_FALSE);
 1:       if (!sVisitorFalse) {
 1:         return NS_ERROR_OUT_OF_MEMORY;
 1:       }
 1:       NS_ADDREF(sVisitorFalse);
 1:       nsresult rv =
 1:         nsContentUtils::ReleasePtrOnShutdown((nsISupports**)&sVisitorFalse);
 1:       if (NS_FAILED(rv)) {
 1:         NS_RELEASE(sVisitorFalse);
 1:         return rv;
 1:       }
 1:     }
 1:     *aVisitor = sVisitorFalse;
 1:   }
 1: 
 1:   NS_ADDREF(*aVisitor);
 1:   return NS_OK;
 1: }
 1: 
 1: nsresult
 1: NS_GetRadioGetCheckedChangedVisitor(PRBool* aCheckedChanged,
 1:                                     nsIFormControl* aExcludeElement,
 1:                                     nsIRadioVisitor** aVisitor)
 1: {
 1:   *aVisitor = new nsRadioGetCheckedChangedVisitor(aCheckedChanged,
 1:                                                   aExcludeElement);
 1:   if (!*aVisitor) {
 1:     return NS_ERROR_OUT_OF_MEMORY;
 1:   }
 1:   NS_ADDREF(*aVisitor);
 1: 
 1:   return NS_OK;
 1: }
