    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Original Author: Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAccessNodeWrap.h"
    1: #include "ISimpleDOMNode_i.c"
    1: #include "nsAccessibilityAtoms.h"
    1: #include "nsIAccessibilityService.h"
    1: #include "nsIAccessible.h"
 2074: #include "nsAttrName.h"
    1: #include "nsIDocument.h"
    1: #include "nsIDOMCSSStyleDeclaration.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMNSHTMLElement.h"
    1: #include "nsIDOMViewCSS.h"
    1: #include "nsIFrame.h"
    1: #include "nsINameSpaceManager.h"
    1: #include "nsIPrefService.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPIDOMWindow.h"
 2074: #include "nsRootAccessible.h"
    1: #include "nsIServiceManager.h"
 5753: #include "AccessibleApplication.h"
 5753: #include "nsApplicationAccessibleWrap.h"
    1: 
    1: /// the accessible library and cached methods
    1: HINSTANCE nsAccessNodeWrap::gmAccLib = nsnull;
    1: HINSTANCE nsAccessNodeWrap::gmUserLib = nsnull;
    1: LPFNACCESSIBLEOBJECTFROMWINDOW nsAccessNodeWrap::gmAccessibleObjectFromWindow = nsnull;
    1: LPFNNOTIFYWINEVENT nsAccessNodeWrap::gmNotifyWinEvent = nsnull;
    1: LPFNGETGUITHREADINFO nsAccessNodeWrap::gmGetGUIThreadInfo = nsnull;
    1: 
    1: PRBool nsAccessNodeWrap::gIsEnumVariantSupportDisabled = 0;
16515: // Used to determine whether an IAccessible2 compatible screen reader is loaded.
16515: PRBool nsAccessNodeWrap::gIsIA2Disabled = PR_FALSE;
    1: 
 1392: nsIAccessibleTextChangeEvent *nsAccessNodeWrap::gTextEvent = nsnull;
 1392: 
18348: // Pref to disallow CtrlTab preview functionality if JAWS or Window-Eyes are
18348: // running.
18348: #define CTRLTAB_DISALLOW_FOR_SCREEN_READERS_PREF "browser.ctrlTab.disallowForScreenReaders"
18348: 
 2074: 
    1: /* For documentation of the accessibility architecture, 
    1:  * see http://lxr.mozilla.org/seamonkey/source/accessible/accessible-docs.html
    1:  */
    1: 
    1: /*
    1:  * Class nsAccessNodeWrap
    1:  */
    1: 
    1: //-----------------------------------------------------
    1: // construction 
    1: //-----------------------------------------------------
    1: 
    1: nsAccessNodeWrap::nsAccessNodeWrap(nsIDOMNode *aNode, nsIWeakReference* aShell): 
    1:   nsAccessNode(aNode, aShell)
    1: {
    1: }
    1: 
    1: //-----------------------------------------------------
    1: // destruction
    1: //-----------------------------------------------------
    1: nsAccessNodeWrap::~nsAccessNodeWrap()
    1: {
    1: }
    1: 
  966: //-----------------------------------------------------
  966: // nsISupports methods
  966: //-----------------------------------------------------
  966: 
  966: NS_IMPL_ISUPPORTS_INHERITED1(nsAccessNodeWrap, nsAccessNode, nsIWinAccessNode);
  966: 
  966: //-----------------------------------------------------
  966: // nsIWinAccessNode methods
  966: //-----------------------------------------------------
  966: 
  966: NS_IMETHODIMP
  966: nsAccessNodeWrap::QueryNativeInterface(REFIID aIID, void** aInstancePtr)
  966: {
 1000:   return QueryInterface(aIID, aInstancePtr);
  966: }
    1: 
    1: //-----------------------------------------------------
    1: // IUnknown interface methods - see iunknown.h for documentation
    1: //-----------------------------------------------------
    1: 
    1: STDMETHODIMP nsAccessNodeWrap::QueryInterface(REFIID iid, void** ppv)
    1: {
    1:   *ppv = nsnull;
    1: 
    1:   if (IID_IUnknown == iid || IID_ISimpleDOMNode == iid)
 3233:     *ppv = static_cast<ISimpleDOMNode*>(this);
    1: 
    1:   if (nsnull == *ppv)
    1:     return E_NOINTERFACE;      //iid not supported.
    1:    
 3233:   (reinterpret_cast<IUnknown*>(*ppv))->AddRef(); 
    1:   return S_OK;
    1: }
    1: 
 5753: STDMETHODIMP
 5753: nsAccessNodeWrap::QueryService(REFGUID guidService, REFIID iid, void** ppv)
 5753: {
23797:   static const GUID IID_SimpleDOMDeprecated = {0x0c539790,0x12e4,0x11cf,0xb6,0x61,0x00,0xaa,0x00,0x4c,0xd6,0xd8};
23797:   if (guidService != IID_ISimpleDOMNode &&
23797:       guidService != IID_SimpleDOMDeprecated &&
23797:       guidService != IID_IAccessible &&  guidService != IID_IAccessible2 &&
23797:       guidService != IID_IAccessibleApplication)
23797:     return E_INVALIDARG;
23797: 
 5753:   // Can get to IAccessibleApplication from any node via QS
 5753:   if (iid == IID_IAccessibleApplication) {
 5753:     nsRefPtr<nsApplicationAccessibleWrap> app =
 5753:       GetApplicationAccessible();
 5753:     nsresult rv = app->QueryNativeInterface(iid, ppv);
 5753:     return NS_SUCCEEDED(rv) ? S_OK : E_NOINTERFACE;
 5753:   }
 5753: 
 5753:   /**
 5753:    * To get an ISimpleDOMNode, ISimpleDOMDocument, ISimpleDOMText
 5753:    * or any IAccessible2 interface on should use IServiceProvider like this:
 5753:    * -----------------------------------------------------------------------
 5753:    * ISimpleDOMDocument *pAccDoc = NULL;
 5753:    * IServiceProvider *pServProv = NULL;
 5753:    * pAcc->QueryInterface(IID_IServiceProvider, (void**)&pServProv);
 5753:    * if (pServProv) {
 5753:    *   const GUID unused;
 5753:    *   pServProv->QueryService(unused, IID_ISimpleDOMDocument, (void**)&pAccDoc);
 5753:    *   pServProv->Release();
 5753:    * }
 5753:    */
 5753: 
 5753:   return QueryInterface(iid, ppv);
 5753: }
 5753: 
    1: //-----------------------------------------------------
    1: // ISimpleDOMNode methods
    1: //-----------------------------------------------------
    1: 
    1: STDMETHODIMP nsAccessNodeWrap::get_nodeInfo( 
    1:     /* [out] */ BSTR __RPC_FAR *aNodeName,
    1:     /* [out] */ short __RPC_FAR *aNameSpaceID,
    1:     /* [out] */ BSTR __RPC_FAR *aNodeValue,
    1:     /* [out] */ unsigned int __RPC_FAR *aNumChildren,
    1:     /* [out] */ unsigned int __RPC_FAR *aUniqueID,
    1:     /* [out] */ unsigned short __RPC_FAR *aNodeType)
    1: {
11593: __try{
 2074:   *aNodeName = nsnull;
 2074:   *aNodeValue = nsnull;
 2074: 
    1:   if (!mDOMNode)
    1:     return E_FAIL;
    1:  
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
    1: 
    1:   PRUint16 nodeType = 0;
    1:   mDOMNode->GetNodeType(&nodeType);
 3233:   *aNodeType=static_cast<unsigned short>(nodeType);
    1: 
    1:   if (*aNodeType !=  NODETYPE_TEXT) {
    1:     nsAutoString nodeName;
    1:     mDOMNode->GetNodeName(nodeName);
    1:     *aNodeName =   ::SysAllocString(nodeName.get());
    1:   }
    1: 
    1:   nsAutoString nodeValue;
    1: 
    1:   mDOMNode->GetNodeValue(nodeValue);
    1:   *aNodeValue = ::SysAllocString(nodeValue.get());
 3233:   *aNameSpaceID = content ? static_cast<short>(content->GetNameSpaceID()) : 0;
    1: 
    1:   // This is a unique ID for every content node.  The 3rd party
    1:   // accessibility application can compare this to the childID we
    1:   // return for events such as focus events, to correlate back to
    1:   // data nodes in their internal object model.
    1:   void *uniqueID;
    1:   GetUniqueID(&uniqueID);
    1:   *aUniqueID = - NS_PTR_TO_INT32(uniqueID);
    1: 
    1:   *aNumChildren = 0;
    1:   PRUint32 numChildren = 0;
    1:   nsCOMPtr<nsIDOMNodeList> nodeList;
    1:   mDOMNode->GetChildNodes(getter_AddRefs(nodeList));
    1:   if (nodeList && NS_OK == nodeList->GetLength(&numChildren))
 3233:     *aNumChildren = static_cast<unsigned int>(numChildren);
    1: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1: 
    1: 
    1:        
    1: STDMETHODIMP nsAccessNodeWrap::get_attributes( 
    1:     /* [in] */ unsigned short aMaxAttribs,
    1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aAttribNames,
    1:     /* [length_is][size_is][out] */ short __RPC_FAR *aNameSpaceIDs,
    1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aAttribValues,
    1:     /* [out] */ unsigned short __RPC_FAR *aNumAttribs)
    1: {
11593: __try{
    1:   *aNumAttribs = 0;
    1: 
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
    1:   if (!content) 
    1:     return E_FAIL;
    1: 
    1:   PRUint32 numAttribs = content->GetAttrCount();
    1: 
    1:   if (numAttribs > aMaxAttribs)
    1:     numAttribs = aMaxAttribs;
 3233:   *aNumAttribs = static_cast<unsigned short>(numAttribs);
    1: 
    1:   for (PRUint32 index = 0; index < numAttribs; index++) {
    1:     aNameSpaceIDs[index] = 0; aAttribValues[index] = aAttribNames[index] = nsnull;
    1:     nsAutoString attributeValue;
    1:     const char *pszAttributeName; 
    1: 
    1:     const nsAttrName* name = content->GetAttrNameAt(index);
 3233:     aNameSpaceIDs[index] = static_cast<short>(name->NamespaceID());
    1:     name->LocalName()->GetUTF8String(&pszAttributeName);
    1:     aAttribNames[index] = ::SysAllocString(NS_ConvertUTF8toUTF16(pszAttributeName).get());
    1:     content->GetAttr(name->NamespaceID(), name->LocalName(), attributeValue);
    1:     aAttribValues[index] = ::SysAllocString(attributeValue.get());
    1:   }
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK; 
    1: }
    1:         
    1: 
    1: STDMETHODIMP nsAccessNodeWrap::get_attributesForNames( 
    1:     /* [in] */ unsigned short aNumAttribs,
    1:     /* [length_is][size_is][in] */ BSTR __RPC_FAR *aAttribNames,
    1:     /* [length_is][size_is][in] */ short __RPC_FAR *aNameSpaceID,
    1:     /* [length_is][size_is][retval] */ BSTR __RPC_FAR *aAttribValues)
    1: {
11593: __try {
    1:   nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(mDOMNode));
    1:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
    1: 
    1:   if (!domElement || !content) 
    1:     return E_FAIL;
    1: 
    1:   if (!content->GetDocument())
    1:     return E_FAIL;
    1: 
    1:   nsCOMPtr<nsINameSpaceManager> nameSpaceManager =
    1:     do_GetService(NS_NAMESPACEMANAGER_CONTRACTID);
    1: 
    1:   PRInt32 index;
    1: 
    1:   for (index = 0; index < aNumAttribs; index++) {
    1:     aAttribValues[index] = nsnull;
    1:     if (aAttribNames[index]) {
    1:       nsAutoString attributeValue, nameSpaceURI;
 3233:       nsAutoString attributeName(nsDependentString(static_cast<PRUnichar*>(aAttribNames[index])));
    1:       nsresult rv;
    1: 
    1:       if (aNameSpaceID[index]>0 && 
    1:         NS_SUCCEEDED(nameSpaceManager->GetNameSpaceURI(aNameSpaceID[index], nameSpaceURI)))
    1:           rv = domElement->GetAttributeNS(nameSpaceURI, attributeName, attributeValue);
    1:       else 
    1:         rv = domElement->GetAttribute(attributeName, attributeValue);
    1: 
    1:       if (NS_SUCCEEDED(rv))
    1:         aAttribValues[index] = ::SysAllocString(attributeValue.get());
    1:     }
    1:   }
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK; 
    1: }
    1: 
    1: /* To do: use media type if not null */
    1: STDMETHODIMP nsAccessNodeWrap::get_computedStyle( 
    1:     /* [in] */ unsigned short aMaxStyleProperties,
    1:     /* [in] */ boolean aUseAlternateView,
    1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aStyleProperties,
    1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aStyleValues,
    1:     /* [out] */ unsigned short __RPC_FAR *aNumStyleProperties)
    1: {
11593: __try{
19322:   *aNumStyleProperties = 0;
19322: 
19322:   if (IsDefunct())
    1:     return E_FAIL;
    1: 
    1:   nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl;
20566:   nsCoreUtils::GetComputedStyleDeclaration(EmptyString(), mDOMNode,
20566:                                            getter_AddRefs(cssDecl));
    1:   NS_ENSURE_TRUE(cssDecl, E_FAIL);
    1: 
    1:   PRUint32 length;
    1:   cssDecl->GetLength(&length);
    1: 
    1:   PRUint32 index, realIndex;
    1:   for (index = realIndex = 0; index < length && realIndex < aMaxStyleProperties; index ++) {
    1:     nsAutoString property, value;
    1:     if (NS_SUCCEEDED(cssDecl->Item(index, property)) && property.CharAt(0) != '-')  // Ignore -moz-* properties
    1:       cssDecl->GetPropertyValue(property, value);  // Get property value
    1:     if (!value.IsEmpty()) {
    1:       aStyleProperties[realIndex] =   ::SysAllocString(property.get());
    1:       aStyleValues[realIndex]     =   ::SysAllocString(value.get());
    1:       ++realIndex;
    1:     }
    1:   }
 3233:   *aNumStyleProperties = static_cast<unsigned short>(realIndex);
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: 
    1: STDMETHODIMP nsAccessNodeWrap::get_computedStyleForProperties( 
    1:     /* [in] */ unsigned short aNumStyleProperties,
    1:     /* [in] */ boolean aUseAlternateView,
    1:     /* [length_is][size_is][in] */ BSTR __RPC_FAR *aStyleProperties,
    1:     /* [length_is][size_is][out] */ BSTR __RPC_FAR *aStyleValues)
    1: {
11593: __try {
19322:   if (IsDefunct())
    1:     return E_FAIL;
    1:  
    1:   nsCOMPtr<nsIDOMCSSStyleDeclaration> cssDecl;
20566:   nsCoreUtils::GetComputedStyleDeclaration(EmptyString(), mDOMNode,
20566:                                            getter_AddRefs(cssDecl));
    1:   NS_ENSURE_TRUE(cssDecl, E_FAIL);
    1: 
    1:   PRUint32 index;
    1:   for (index = 0; index < aNumStyleProperties; index ++) {
    1:     nsAutoString value;
    1:     if (aStyleProperties[index])
 3233:       cssDecl->GetPropertyValue(nsDependentString(static_cast<PRUnichar*>(aStyleProperties[index])), value);  // Get property value
    1:     aStyleValues[index] = ::SysAllocString(value.get());
    1:   }
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP nsAccessNodeWrap::scrollTo(/* [in] */ boolean aScrollTopLeft)
    1: {
11593: __try {
  497:   PRUint32 scrollType =
  497:     aScrollTopLeft ? nsIAccessibleScrollType::SCROLL_TYPE_TOP_LEFT :
  497:                      nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_RIGHT;
  497: 
  497:   nsresult rv = ScrollTo(scrollType);
    1:   if (NS_SUCCEEDED(rv))
    1:     return S_OK;
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return E_FAIL;
    1: }
    1: 
20256: ISimpleDOMNode* nsAccessNodeWrap::MakeAccessNode(nsIDOMNode *node)
20256: {
20256:   if (!node) 
20256:     return NULL;
20256: 
20256:   nsAccessNodeWrap *newNode = NULL;
20256:   
20256:   nsCOMPtr<nsIContent> content(do_QueryInterface(node));
20256:   nsCOMPtr<nsIDocument> doc;
20256: 
20256:   if (content) 
20256:     doc = content->GetDocument();
20256:   else {
20256:     // Get the document via QueryInterface, since there is no content node
20256:     doc = do_QueryInterface(node);
20256:     content = do_QueryInterface(node);
20256:   }
20256: 
20256:   if (!doc)
20256:     return NULL;
20256: 
20256:   nsCOMPtr<nsIAccessibilityService> accService(do_GetService("@mozilla.org/accessibilityService;1"));
20256:   if (!accService)
20256:     return NULL;
20256: 
20256:   ISimpleDOMNode *iNode = NULL;
20256:   nsCOMPtr<nsIAccessible> nsAcc;
20256:   accService->GetAccessibleInWeakShell(node, mWeakShell, getter_AddRefs(nsAcc));
20256:   if (nsAcc) {
20256:     nsCOMPtr<nsIAccessNode> accessNode(do_QueryInterface(nsAcc));
20256:     NS_ASSERTION(accessNode, "nsIAccessible impl does not inherit from nsIAccessNode");
20256:     IAccessible *msaaAccessible;
20256:     nsAcc->GetNativeInterface((void**)&msaaAccessible); // addrefs
20256:     msaaAccessible->QueryInterface(IID_ISimpleDOMNode, (void**)&iNode); // addrefs
20256:     msaaAccessible->Release(); // Release IAccessible
20256:   }
20256:   else {
20256:     newNode = new nsAccessNodeWrap(node, mWeakShell);
20256:     if (!newNode)
20256:       return NULL;
20256: 
20256:     newNode->Init();
20256:     iNode = static_cast<ISimpleDOMNode*>(newNode);
20256:     iNode->AddRef();
20256:   }
20256: 
20256:   return iNode;
20256: }
20256: 
20256: 
20256: STDMETHODIMP nsAccessNodeWrap::get_parentNode(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
20256:   if (!mDOMNode)
20256:     return E_FAIL;
    1:  
20256:   nsCOMPtr<nsIDOMNode> node;
20256:   mDOMNode->GetParentNode(getter_AddRefs(node));
20256:   *aNode = MakeAccessNode(node);
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
20256: STDMETHODIMP nsAccessNodeWrap::get_firstChild(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
20256:   if (!mDOMNode)
20256:     return E_FAIL;
    1:  
20256:   nsCOMPtr<nsIDOMNode> node;
20256:   mDOMNode->GetFirstChild(getter_AddRefs(node));
20256:   *aNode = MakeAccessNode(node);
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
20256: STDMETHODIMP nsAccessNodeWrap::get_lastChild(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593:   __try {
20256:   if (!mDOMNode)
20256:     return E_FAIL;
    1: 
20256:   nsCOMPtr<nsIDOMNode> node;
20256:   mDOMNode->GetLastChild(getter_AddRefs(node));
20256:   *aNode = MakeAccessNode(node);
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
20256: STDMETHODIMP nsAccessNodeWrap::get_previousSibling(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
20256:   if (!mDOMNode)
20256:     return E_FAIL;
    1: 
20256:   nsCOMPtr<nsIDOMNode> node;
20256:   mDOMNode->GetPreviousSibling(getter_AddRefs(node));
20256:   *aNode = MakeAccessNode(node);
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
20256: STDMETHODIMP nsAccessNodeWrap::get_nextSibling(ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
20256:   if (!mDOMNode)
20256:     return E_FAIL;
    1: 
20256:   nsCOMPtr<nsIDOMNode> node;
20256:   mDOMNode->GetNextSibling(getter_AddRefs(node));
20256:   *aNode = MakeAccessNode(node);
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP 
    1: nsAccessNodeWrap::get_childAt(unsigned aChildIndex,
    1:                               ISimpleDOMNode __RPC_FAR *__RPC_FAR *aNode)
    1: {
11593: __try {
20256:   *aNode = nsnull;
    1: 
20256:   nsCOMPtr<nsIContent> content(do_QueryInterface(mDOMNode));
20256:   if (!content)
20256:     return E_FAIL;  // Node already shut down
    1: 
20256:   nsCOMPtr<nsIDOMNode> node =
20256:     do_QueryInterface(content->GetChildAt(aChildIndex));
20256: 
20256:   if (!node)
20256:     return E_FAIL; // No such child
20256: 
20256:   *aNode = MakeAccessNode(node);
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP 
    1: nsAccessNodeWrap::get_innerHTML(BSTR __RPC_FAR *aInnerHTML)
    1: {
11593: __try {
    1:   *aInnerHTML = nsnull;
    1: 
    1:   nsCOMPtr<nsIDOMNSHTMLElement> domNSElement(do_QueryInterface(mDOMNode));
    1:   if (!domNSElement)
    1:     return E_FAIL; // Node already shut down
    1: 
    1:   nsAutoString innerHTML;
    1:   domNSElement->GetInnerHTML(innerHTML);
13128:   if (innerHTML.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aInnerHTML = ::SysAllocStringLen(innerHTML.get(), innerHTML.Length());
13128:   if (!*aInnerHTML)
13128:     return E_OUTOFMEMORY;
13128: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP 
    1: nsAccessNodeWrap::get_language(BSTR __RPC_FAR *aLanguage)
    1: {
11593: __try {
13128:   *aLanguage = NULL;
 2074: 
 1751:   nsAutoString language;
 1751:   if (NS_FAILED(GetLanguage(language))) {
    1:     return E_FAIL;
    1:   }
13128: 
13128:   if (language.IsEmpty())
13128:     return S_FALSE;
13128: 
13128:   *aLanguage = ::SysAllocStringLen(language.get(), language.Length());
13128:   if (!*aLanguage)
13128:     return E_OUTOFMEMORY;
13128: 
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
11593: 
    1:   return S_OK;
    1: }
    1: 
    1: STDMETHODIMP 
    1: nsAccessNodeWrap::get_localInterface( 
    1:     /* [out] */ void __RPC_FAR *__RPC_FAR *localInterface)
    1: {
11593: __try {
 3233:   *localInterface = static_cast<nsIAccessNode*>(this);
    1:   NS_ADDREF_THIS();
11593: } __except(FilterA11yExceptions(::GetExceptionCode(), GetExceptionInformation())) { }
    1:   return S_OK;
    1: }
    1:  
    1: void nsAccessNodeWrap::InitAccessibility()
    1: {
30820:   NS_ASSERTION(!gIsAccessibilityActive,
30820:                "Accessibility was initialized already!");
    1: 
    1:   nsCOMPtr<nsIPrefBranch> prefBranch(do_GetService(NS_PREFSERVICE_CONTRACTID));
    1:   if (prefBranch) {
    1:     prefBranch->GetBoolPref("accessibility.disableenumvariant", &gIsEnumVariantSupportDisabled);
    1:   }
    1: 
    1:   if (!gmUserLib) {
18477:     gmUserLib =::LoadLibraryW(L"USER32.DLL");
    1:   }
    1: 
    1:   if (gmUserLib) {
    1:     if (!gmNotifyWinEvent)
    1:       gmNotifyWinEvent = (LPFNNOTIFYWINEVENT)GetProcAddress(gmUserLib,"NotifyWinEvent");
    1:     if (!gmGetGUIThreadInfo)
    1:       gmGetGUIThreadInfo = (LPFNGETGUITHREADINFO)GetProcAddress(gmUserLib,"GetGUIThreadInfo");
    1:   }
    1: 
16515:   DoATSpecificProcessing();
16515:   
    1:   nsAccessNode::InitXPAccessibility();
    1: }
    1: 
    1: void nsAccessNodeWrap::ShutdownAccessibility()
    1: {
 1392:   NS_IF_RELEASE(gTextEvent);
 2395:   ::DestroyCaret();
 1392: 
30820:   NS_ASSERTION(gIsAccessibilityActive, "Accessibility was shutdown already!");
    1: 
    1:   nsAccessNode::ShutdownXPAccessibility();
    1: }
11440: 
11440: int nsAccessNodeWrap::FilterA11yExceptions(unsigned int aCode, EXCEPTION_POINTERS *aExceptionInfo)
11440: {
11440:   if (aCode == EXCEPTION_ACCESS_VIOLATION) {
11440: #ifdef MOZ_CRASHREPORTER
11440:     // MSAA swallows crashes (because it is COM-based)
11440:     // but we still need to learn about those crashes so we can fix them
11440:     // Make sure to pass them to the crash reporter
11440:     nsCOMPtr<nsICrashReporter> crashReporter =
11440:       do_GetService("@mozilla.org/toolkit/crash-reporter;1");
11440:     if (crashReporter) {
11440:       crashReporter->WriteMinidumpForException(aExceptionInfo);
11440:     }
11440: #endif
11440:   }
11440:   else {
11440:     NS_NOTREACHED("We should only be catching crash exceptions");
11440:   }
11440:   return EXCEPTION_CONTINUE_SEARCH;
11440: }
13730: 
13730: HRESULT
13730: GetHRESULT(nsresult aResult)
13730: {
13730:   switch (aResult) {
13730:     case NS_OK:
13730:       return S_OK;
13730: 
13730:     case NS_ERROR_INVALID_ARG: case NS_ERROR_INVALID_POINTER:
13730:       return E_INVALIDARG;
13730: 
13730:     case NS_ERROR_OUT_OF_MEMORY:
13730:       return E_OUTOFMEMORY;
13730: 
13730:     case NS_ERROR_NOT_IMPLEMENTED:
13730:       return E_NOTIMPL;
13730: 
13730:     default:
13730:       return E_FAIL;
13730:   }
13730: }
13730: 
16515: PRBool nsAccessNodeWrap::IsOnlyMsaaCompatibleJawsPresent()
16515: {
18348:   HMODULE jhookhandle = ::GetModuleHandleW(L"jhook");
16515:   if (!jhookhandle)
16515:     return PR_FALSE;  // No JAWS, or some other screen reader, use IA2
16515: 
16515:   PRUnichar fileName[MAX_PATH];
16515:   ::GetModuleFileNameW(jhookhandle, fileName, MAX_PATH);
16515: 
16515:   DWORD dummy;
16515:   DWORD length = ::GetFileVersionInfoSizeW(fileName, &dummy);
16515: 
16515:   LPBYTE versionInfo = new BYTE[length];
16515:   ::GetFileVersionInfoW(fileName, 0, length, versionInfo);
16515: 
16515:   UINT uLen;
16515:   VS_FIXEDFILEINFO *fixedFileInfo;
16515:   ::VerQueryValueW(versionInfo, L"\\", (LPVOID*)&fixedFileInfo, &uLen);
16515:   DWORD dwFileVersionMS = fixedFileInfo->dwFileVersionMS;
16515:   DWORD dwFileVersionLS = fixedFileInfo->dwFileVersionLS;
16515:   delete [] versionInfo;
16515: 
16515:   DWORD dwLeftMost = HIWORD(dwFileVersionMS);
16515: //  DWORD dwSecondLeft = LOWORD(dwFileVersionMS);
16515:   DWORD dwSecondRight = HIWORD(dwFileVersionLS);
16515: //  DWORD dwRightMost = LOWORD(dwFileVersionLS);
16515: 
16515:   return (dwLeftMost < 8
16515:           || (dwLeftMost == 8 && dwSecondRight < 2173));
16515: }
16515: 
18348: void nsAccessNodeWrap::TurnOffNewTabSwitchingForJawsAndWE()
18348: {
18348:   HMODULE srHandle = ::GetModuleHandleW(L"jhook");
18348:   if (!srHandle) {
18348:     // No JAWS, try Window-Eyes
18348:     srHandle = ::GetModuleHandleW(L"gwm32inc");
18348:     if (!srHandle) {
18348:       // no screen reader we're interested in. Bail out.
18348:       return;
18348:     }
18348:   }
18348: 
18348:   // Check to see if the pref for disallowing CtrlTab is already set.
18348:   // If so, bail out.
18348:   // If not, set it.
18348:   nsCOMPtr<nsIPrefBranch> prefs (do_GetService(NS_PREFSERVICE_CONTRACTID));
18348:   if (prefs) {
18348:     PRBool hasDisallowNewCtrlTabPref = PR_FALSE;
18348:     nsresult rv = prefs->PrefHasUserValue(CTRLTAB_DISALLOW_FOR_SCREEN_READERS_PREF,
18348:              &hasDisallowNewCtrlTabPref);
18348:     if (NS_SUCCEEDED(rv) && hasDisallowNewCtrlTabPref) {
18348:       // This pref has been set before. There is no default for it.
18348:       // Do nothing further, respect the setting that's there.
18348:       // That way, if noone touches it, it'll stay on after toggled once.
18348:       // If someone decided to turn it off, we respect that, too.
18348:       return;
18348:     }
18348:     
18348:     // Value has never been set, set it.
18348:     prefs->SetBoolPref(CTRLTAB_DISALLOW_FOR_SCREEN_READERS_PREF, PR_TRUE);
18348:   }
18348: }
18348: 
16515: void nsAccessNodeWrap::DoATSpecificProcessing()
16515: {
16515:   if (IsOnlyMsaaCompatibleJawsPresent())
16515:     // All versions below 8.0.2173 are not compatible
16515:     gIsIA2Disabled  = PR_TRUE;
18348: 
18348:   TurnOffNewTabSwitchingForJawsAndWE();
16515: }
