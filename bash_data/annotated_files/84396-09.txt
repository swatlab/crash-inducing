35924: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
35924: /* vim: set sw=2 ts=8 et tw=80 : */
35924: 
35924: /* ***** BEGIN LICENSE BLOCK *****
35924:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35924:  *
35924:  * The contents of this file are subject to the Mozilla Public License Version
35924:  * 1.1 (the "License"); you may not use this file except in compliance with
35924:  * the License. You may obtain a copy of the License at
35924:  * http://www.mozilla.org/MPL/
35924:  *
35924:  * Software distributed under the License is distributed on an "AS IS" basis,
35924:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35924:  * for the specific language governing rights and limitations under the
35924:  * License.
35924:  *
35924:  * The Original Code is mozilla.org code.
35924:  *
35924:  * The Initial Developer of the Original Code is
35924:  *  The Mozilla Foundation
35924:  * Portions created by the Initial Developer are Copyright (C) 2009
35924:  * the Initial Developer. All Rights Reserved.
35924:  *
35924:  * Contributor(s):
35924:  *   Jason Duell <jduell.mcbugs@gmail.com>
46790:  *   Daniel Witte <dwitte@mozilla.com>
49375:  *   Honza Bambas <honzab@firemni.cz>
35924:  *
35924:  * Alternatively, the contents of this file may be used under the terms of
35924:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35924:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35924:  * in which case the provisions of the GPL or the LGPL are applicable instead
35924:  * of those above. If you wish to allow use of your version of this file only
35924:  * under the terms of either the GPL or the LGPL, and not to allow others to
35924:  * use your version of this file under the terms of the MPL, indicate your
35924:  * decision by deleting the provisions above and replace them with the notice
35924:  * and other provisions required by the GPL or the LGPL. If you do not delete
35924:  * the provisions above, a recipient may use your version of this file under
35924:  * the terms of any one of the MPL, the GPL or the LGPL.
35924:  *
35924:  * ***** END LICENSE BLOCK ***** */
35924: 
46672: #include "nsHttp.h"
46908: #include "mozilla/dom/TabChild.h"
46672: #include "mozilla/net/NeckoChild.h"
35924: #include "mozilla/net/HttpChannelChild.h"
46672: 
46672: #include "nsStringStream.h"
46672: #include "nsHttpHandler.h"
46672: #include "nsMimeTypes.h"
46672: #include "nsNetUtil.h"
50566: #include "nsSerializationHelper.h"
46672: 
49365: namespace mozilla {
49365: namespace net {
49365: 
49375: //-----------------------------------------------------------------------------
49375: // HttpChannelChild
49375: //-----------------------------------------------------------------------------
49375: 
35924: HttpChannelChild::HttpChannelChild()
71646:   : HttpAsyncAborter<HttpChannelChild>(this)
80486:   , mIsFromCache(false)
80486:   , mCacheEntryAvailable(false)
46915:   , mCacheExpirationTime(nsICache::NO_EXPIRATION_TIME)
49379:   , mSendResumeAt(false)
48132:   , mIPCOpen(false)
61190:   , mKeptAlive(false)
72966:   , mEventQ(static_cast<nsIHttpChannel*>(this))
35924: {
46672:   LOG(("Creating HttpChannelChild @%x\n", this));
35924: }
35924: 
35924: HttpChannelChild::~HttpChannelChild()
35924: {
46672:   LOG(("Destroying HttpChannelChild @%x\n", this));
46672: }
46672: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::nsISupports
46672: //-----------------------------------------------------------------------------
46672: 
46834: // Override nsHashPropertyBag's AddRef: we don't need thread-safe refcnt
46834: NS_IMPL_ADDREF(HttpChannelChild)
50566: 
50566: NS_IMETHODIMP_(nsrefcnt) HttpChannelChild::Release()
50566: {
50566:   NS_PRECONDITION(0 != mRefCnt, "dup release");
50566:   NS_ASSERT_OWNINGTHREAD(HttpChannelChild);
50566:   --mRefCnt;
50566:   NS_LOG_RELEASE(this, mRefCnt, "HttpChannelChild");
50566: 
77793:   // Normally we Send_delete in OnStopRequest, but when we need to retain the
77793:   // remote channel for security info IPDL itself holds 1 reference, so we
77793:   // Send_delete when refCnt==1.
77793:   if (mKeptAlive && mRefCnt == 1) {
77793:     NS_ASSERTION(mIPCOpen, "mIPCOpen false!");
61190:     mKeptAlive = false;
50566:     // Send_delete calls NeckoChild::DeallocPHttpChannel, which will release
50566:     // again to refcount==0
50566:     PHttpChannelChild::Send__delete__(this);
50566:     return 0;
50566:   }
50566: 
50566:   if (mRefCnt == 0) {
50566:     mRefCnt = 1; /* stabilize */
50566:     delete this;
50566:     return 0;
50566:   }
50566:   return mRefCnt;
50566: }
46672: 
46672: NS_INTERFACE_MAP_BEGIN(HttpChannelChild)
46672:   NS_INTERFACE_MAP_ENTRY(nsIRequest)
46672:   NS_INTERFACE_MAP_ENTRY(nsIChannel)
46672:   NS_INTERFACE_MAP_ENTRY(nsIHttpChannel)
46672:   NS_INTERFACE_MAP_ENTRY(nsIHttpChannelInternal)
46915:   NS_INTERFACE_MAP_ENTRY(nsICacheInfoChannel)
46672:   NS_INTERFACE_MAP_ENTRY(nsIResumableChannel)
46672:   NS_INTERFACE_MAP_ENTRY(nsISupportsPriority)
46672:   NS_INTERFACE_MAP_ENTRY(nsIProxiedChannel)
46672:   NS_INTERFACE_MAP_ENTRY(nsITraceableChannel)
46672:   NS_INTERFACE_MAP_ENTRY(nsIApplicationCacheContainer)
46672:   NS_INTERFACE_MAP_ENTRY(nsIApplicationCacheChannel)
49375:   NS_INTERFACE_MAP_ENTRY(nsIAsyncVerifyRedirectCallback)
58111:   NS_INTERFACE_MAP_ENTRY(nsIChildChannel)
58111:   NS_INTERFACE_MAP_ENTRY(nsIHttpChannelChild)
50566:   NS_INTERFACE_MAP_ENTRY_CONDITIONAL(nsIAssociatedContentSecurity, GetAssociatedContentSecurity())
46790: NS_INTERFACE_MAP_END_INHERITING(HttpBaseChannel)
46672: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::PHttpChannelChild
46672: //-----------------------------------------------------------------------------
46672: 
48132: void
48132: HttpChannelChild::AddIPDLReference()
48132: {
48132:   NS_ABORT_IF_FALSE(!mIPCOpen, "Attempt to retain more than one IPDL reference");
48132:   mIPCOpen = true;
48132:   AddRef();
48132: }
48132: 
48132: void
48132: HttpChannelChild::ReleaseIPDLReference()
48132: {
48132:   NS_ABORT_IF_FALSE(mIPCOpen, "Attempt to release nonexistent IPDL reference");
48132:   mIPCOpen = false;
48132:   Release();
48132: }
48132: 
76989: class AssociateApplicationCacheEvent : public ChannelEvent
76989: {
76989:   public:
76989:     AssociateApplicationCacheEvent(HttpChannelChild* child,
76989:                                    const nsCString &groupID,
76989:                                    const nsCString &clientID)
76989:     : mChild(child)
76989:     , groupID(groupID)
76989:     , clientID(clientID) {}
76989: 
76989:     void Run() { mChild->AssociateApplicationCache(groupID, clientID); }
76989:   private:
76989:     HttpChannelChild* mChild;
76989:     nsCString groupID;
76989:     nsCString clientID;
76989: };
76989: 
76989: bool
76989: HttpChannelChild::RecvAssociateApplicationCache(const nsCString &groupID,
76989:                                                 const nsCString &clientID)
76989: {
76989:   if (mEventQ.ShouldEnqueue()) {
76989:     mEventQ.Enqueue(new AssociateApplicationCacheEvent(this, groupID, clientID));
76989:   } else {
76989:     AssociateApplicationCache(groupID, clientID);
76989:   }
76989:   return true;
76989: }
76989: 
76989: void
76989: HttpChannelChild::AssociateApplicationCache(const nsCString &groupID,
76989:                                             const nsCString &clientID)
76989: {
76989:   nsresult rv;
76989:   mApplicationCache = do_CreateInstance(NS_APPLICATIONCACHE_CONTRACTID, &rv);
76989:   if (NS_FAILED(rv))
76989:     return;
76989: 
80486:   mLoadedFromApplicationCache = true;
76989:   mApplicationCache->InitAsHandle(groupID, clientID);
76989: }
76989: 
55160: class StartRequestEvent : public ChannelEvent
49365: {
49365:  public:
49365:   StartRequestEvent(HttpChannelChild* child,
49365:                     const nsHttpResponseHead& responseHead,
79445:                     const bool& useResponseHead,
54894:                     const RequestHeaderTuples& requestHeaders,
79445:                     const bool& isFromCache,
79445:                     const bool& cacheEntryAvailable,
49365:                     const PRUint32& cacheExpirationTime,
50566:                     const nsCString& cachedCharset,
69351:                     const nsCString& securityInfoSerialization,
69351:                     const PRNetAddr& selfAddr,
69351:                     const PRNetAddr& peerAddr)
49365:   : mChild(child)
49365:   , mResponseHead(responseHead)
54894:   , mRequestHeaders(requestHeaders)
49365:   , mUseResponseHead(useResponseHead)
49365:   , mIsFromCache(isFromCache)
49365:   , mCacheEntryAvailable(cacheEntryAvailable)
49365:   , mCacheExpirationTime(cacheExpirationTime)
49365:   , mCachedCharset(cachedCharset)
50566:   , mSecurityInfoSerialization(securityInfoSerialization)
69351:   , mSelfAddr(selfAddr)
69351:   , mPeerAddr(peerAddr)
49365:   {}
49365: 
49365:   void Run() 
49365:   { 
54894:     mChild->OnStartRequest(mResponseHead, mUseResponseHead, mRequestHeaders,
54894:                            mIsFromCache, mCacheEntryAvailable,
54894:                            mCacheExpirationTime, mCachedCharset,
69351:                            mSecurityInfoSerialization, mSelfAddr, mPeerAddr);
49365:   }
49365:  private:
49365:   HttpChannelChild* mChild;
49365:   nsHttpResponseHead mResponseHead;
54894:   RequestHeaderTuples mRequestHeaders;
79445:   bool mUseResponseHead;
79445:   bool mIsFromCache;
79445:   bool mCacheEntryAvailable;
49365:   PRUint32 mCacheExpirationTime;
49365:   nsCString mCachedCharset;
50566:   nsCString mSecurityInfoSerialization;
69351:   PRNetAddr mSelfAddr;
69351:   PRNetAddr mPeerAddr;
49365: };
49365: 
46672: bool 
46911: HttpChannelChild::RecvOnStartRequest(const nsHttpResponseHead& responseHead,
79445:                                      const bool& useResponseHead,
54894:                                      const RequestHeaderTuples& requestHeaders,
79445:                                      const bool& isFromCache,
79445:                                      const bool& cacheEntryAvailable,
46915:                                      const PRUint32& cacheExpirationTime,
50566:                                      const nsCString& cachedCharset,
69351:                                      const nsCString& securityInfoSerialization,
69351:                                      const PRNetAddr& selfAddr,
69351:                                      const PRNetAddr& peerAddr)
46672: {
71647:   if (mEventQ.ShouldEnqueue()) {
71647:     mEventQ.Enqueue(new StartRequestEvent(this, responseHead, useResponseHead,
71647:                                           requestHeaders, isFromCache,
71647:                                           cacheEntryAvailable,
50566:                                           cacheExpirationTime, cachedCharset,
69351:                                           securityInfoSerialization, selfAddr,
69351:                                           peerAddr));
49365:   } else {
54894:     OnStartRequest(responseHead, useResponseHead, requestHeaders, isFromCache,
50566:                    cacheEntryAvailable, cacheExpirationTime, cachedCharset,
69351:                    securityInfoSerialization, selfAddr, peerAddr);
49365:   }
49365:   return true;
49365: }
49365: 
49365: void 
49365: HttpChannelChild::OnStartRequest(const nsHttpResponseHead& responseHead,
79445:                                  const bool& useResponseHead,
54894:                                  const RequestHeaderTuples& requestHeaders,
79445:                                  const bool& isFromCache,
79445:                                  const bool& cacheEntryAvailable,
49365:                                  const PRUint32& cacheExpirationTime,
50566:                                  const nsCString& cachedCharset,
69351:                                  const nsCString& securityInfoSerialization,
69351:                                  const PRNetAddr& selfAddr,
69351:                                  const PRNetAddr& peerAddr)
49365: {
46672:   LOG(("HttpChannelChild::RecvOnStartRequest [this=%x]\n", this));
46672: 
50561:   if (useResponseHead && !mCanceled)
46755:     mResponseHead = new nsHttpResponseHead(responseHead);
46911: 
50566:   if (!securityInfoSerialization.IsEmpty()) {
50566:     NS_DeserializeObject(securityInfoSerialization, 
50566:                          getter_AddRefs(mSecurityInfo));
50566:   }
50566: 
46915:   mIsFromCache = isFromCache;
46915:   mCacheEntryAvailable = cacheEntryAvailable;
46915:   mCacheExpirationTime = cacheExpirationTime;
46915:   mCachedCharset = cachedCharset;
46672: 
71647:   AutoEventEnqueuer ensureSerialDispatch(mEventQ);
49365: 
54894:   // replace our request headers with what actually got sent in the parent
54894:   mRequestHead.ClearHeaders();
54894:   for (PRUint32 i = 0; i < requestHeaders.Length(); i++) {
54894:     mRequestHead.Headers().SetHeader(nsHttp::ResolveAtom(requestHeaders[i].mHeader),
54894:                                      requestHeaders[i].mValue);
54894:   }
54894: 
70426:   // notify "http-on-examine-response" observers
70426:   gHttpHandler->OnExamineResponse(this);
80486:   mTracingEnabled = false;
70426: 
46790:   nsresult rv = mListener->OnStartRequest(this, mListenerContext);
53990:   if (NS_FAILED(rv)) {
53990:     Cancel(rv);
53990:     return;
53990:   }
53990: 
49365:   if (mResponseHead)
49365:     SetCookie(mResponseHead->PeekHeader(nsHttp::Set_Cookie));
53990: 
53990:   rv = ApplyContentConversions();
53990:   if (NS_FAILED(rv))
50561:     Cancel(rv);
71834: 
71834:   mSelfAddr = selfAddr;
71834:   mPeerAddr = peerAddr;
49365: }
46906: 
67800: class TransportAndDataEvent : public ChannelEvent
48849: {
48849:  public:
67800:   TransportAndDataEvent(HttpChannelChild* child,
67800:                         const nsresult& status,
67800:                         const PRUint64& progress,
67800:                         const PRUint64& progressMax,
48849:                         const nsCString& data,
48849:                         const PRUint32& offset,
48849:                         const PRUint32& count)
48849:   : mChild(child)
67800:   , mStatus(status)
67800:   , mProgress(progress)
67800:   , mProgressMax(progressMax)
48849:   , mData(data)
48849:   , mOffset(offset)
48849:   , mCount(count) {}
48849: 
67800:   void Run() { mChild->OnTransportAndData(mStatus, mProgress, mProgressMax,
67800:                                           mData, mOffset, mCount); }
48849:  private:
48849:   HttpChannelChild* mChild;
67800:   nsresult mStatus;
67800:   PRUint64 mProgress;
67800:   PRUint64 mProgressMax;
48849:   nsCString mData;
48849:   PRUint32 mOffset;
48849:   PRUint32 mCount;
48849: };
48849: 
48849: bool
67800: HttpChannelChild::RecvOnTransportAndData(const nsresult& status,
67800:                                          const PRUint64& progress,
67800:                                          const PRUint64& progressMax,
67800:                                          const nsCString& data,
48849:                                          const PRUint32& offset,
48849:                                          const PRUint32& count)
48849: {
71647:   if (mEventQ.ShouldEnqueue()) {
71647:     mEventQ.Enqueue(new TransportAndDataEvent(this, status, progress,
71647:                                               progressMax, data, offset, 
71647:                                               count));
49365:   } else {
67800:     OnTransportAndData(status, progress, progressMax, data, offset, count);
49365:   }
49365:   return true;
46672: }
46672: 
49365: void
67800: HttpChannelChild::OnTransportAndData(const nsresult& status,
67800:                                      const PRUint64 progress,
67800:                                      const PRUint64& progressMax,
67800:                                      const nsCString& data,
46672:                                      const PRUint32& offset,
46672:                                      const PRUint32& count)
46672: {
67800:   LOG(("HttpChannelChild::OnTransportAndData [this=%x]\n", this));
46672: 
50561:   if (mCanceled)
50561:     return;
46672: 
67800:   // cache the progress sink so we don't have to query for it each time.
67800:   if (!mProgressSink)
67800:     GetCallback(mProgressSink);
67800: 
67800:   // Hold queue lock throughout all three calls, else we might process a later
67800:   // necko msg in between them.
71647:   AutoEventEnqueuer ensureSerialDispatch(mEventQ);
67800: 
67800:   // block status/progress after Cancel or OnStopRequest has been called,
67800:   // or if channel has LOAD_BACKGROUND set.
67800:   // - JDUELL: may not need mStatus/mIsPending checks, given this is always called
67800:   //   during OnDataAvailable, and we've already checked mCanceled.  Code
67800:   //   dupe'd from nsHttpChannel
67800:   if (mProgressSink && NS_SUCCEEDED(mStatus) && mIsPending &&
67800:       !(mLoadFlags & LOAD_BACKGROUND))
67800:   {
67800:     // OnStatus
67800:     //
67800:     NS_ASSERTION(status == nsISocketTransport::STATUS_RECEIVING_FROM ||
67800:                  status == nsITransport::STATUS_READING,
67800:                  "unexpected status code");
67800: 
67800:     nsCAutoString host;
67800:     mURI->GetHost(host);
67800:     mProgressSink->OnStatus(this, nsnull, status,
67800:                             NS_ConvertUTF8toUTF16(host).get());
67800:     // OnProgress
67800:     //
67800:     if (progress > 0) {
67800:       NS_ASSERTION(progress <= progressMax, "unexpected progress values");
67800:       mProgressSink->OnProgress(this, nsnull, progress, progressMax);
67800:     }
67800:   }
67800: 
67800:   // OnDataAvailable
67800:   //
46672:   // NOTE: the OnDataAvailable contract requires the client to read all the data
46672:   // in the inputstream.  This code relies on that ('data' will go away after
46672:   // this function).  Apparently the previous, non-e10s behavior was to actually
46672:   // support only reading part of the data, allowing later calls to read the
46672:   // rest.
46672:   nsCOMPtr<nsIInputStream> stringStream;
67800:   nsresult rv = NS_NewByteInputStream(getter_AddRefs(stringStream), data.get(),
67800:                                       count, NS_ASSIGNMENT_DEPEND);
46906:   if (NS_FAILED(rv)) {
50561:     Cancel(rv);
49365:     return;
46672:   }
49365: 
46790:   rv = mListener->OnDataAvailable(this, mListenerContext,
46672:                                   stringStream, offset, count);
46672:   stringStream->Close();
46906:   if (NS_FAILED(rv)) {
50561:     Cancel(rv);
46672:   }
46672: }
46672: 
55160: class StopRequestEvent : public ChannelEvent
48849: {
48849:  public:
48849:   StopRequestEvent(HttpChannelChild* child,
48849:                    const nsresult& statusCode)
48849:   : mChild(child)
48849:   , mStatusCode(statusCode) {}
48849: 
49365:   void Run() { mChild->OnStopRequest(mStatusCode); }
48849:  private:
48849:   HttpChannelChild* mChild;
48849:   nsresult mStatusCode;
48849: };
48849: 
46672: bool 
46672: HttpChannelChild::RecvOnStopRequest(const nsresult& statusCode)
46672: {
71647:   if (mEventQ.ShouldEnqueue()) {
71647:     mEventQ.Enqueue(new StopRequestEvent(this, statusCode));
49365:   } else {
49365:     OnStopRequest(statusCode);
49365:   }
49365:   return true;
48849: }
48849: 
49365: void 
48849: HttpChannelChild::OnStopRequest(const nsresult& statusCode)
48849: {
50561:   LOG(("HttpChannelChild::OnStopRequest [this=%x status=%u]\n", 
46672:            this, statusCode));
46672: 
80486:   mIsPending = false;
46672: 
59687:   if (!mCanceled && NS_SUCCEEDED(mStatus))
46672:     mStatus = statusCode;
49365: 
50561:   { // We must flush the queue before we Send__delete__
50561:     // (although we really shouldn't receive any msgs after OnStop),
49365:     // so make sure this goes out of scope before then.
71647:     AutoEventEnqueuer ensureSerialDispatch(mEventQ);
49365: 
59687:     mListener->OnStopRequest(this, mListenerContext, mStatus);
50561: 
46790:     mListener = 0;
46790:     mListenerContext = 0;
80486:     mCacheEntryAvailable = false;
46886:     if (mLoadGroup)
59687:       mLoadGroup->RemoveRequest(this, nsnull, mStatus);
49365:   }
46886: 
77793:   if (mLoadFlags & LOAD_DOCUMENT_URI) {
77793:     // Keep IPDL channel open, but only for updating security info.
77793:     mKeptAlive = true;
77793:     SendDocumentChannelCleanup();
77793:   } else {
61190:     // This calls NeckoChild::DeallocPHttpChannel(), which deletes |this| if IPDL
61190:     // holds the last reference.  Don't rely on |this| existing after here.
61190:     PHttpChannelChild::Send__delete__(this);
61190:   }
46672: }
46672: 
55160: class ProgressEvent : public ChannelEvent
48849: {
48849:  public:
48849:   ProgressEvent(HttpChannelChild* child,
48849:                 const PRUint64& progress,
48849:                 const PRUint64& progressMax)
48849:   : mChild(child)
48849:   , mProgress(progress)
48849:   , mProgressMax(progressMax) {}
48849: 
49365:   void Run() { mChild->OnProgress(mProgress, mProgressMax); }
48849:  private:
48849:   HttpChannelChild* mChild;
48849:   PRUint64 mProgress, mProgressMax;
48849: };
48849: 
46851: bool
46851: HttpChannelChild::RecvOnProgress(const PRUint64& progress,
46851:                                  const PRUint64& progressMax)
46851: {
71647:   if (mEventQ.ShouldEnqueue())  {
71647:     mEventQ.Enqueue(new ProgressEvent(this, progress, progressMax));
49365:   } else {
49365:     OnProgress(progress, progressMax);
49365:   }
49365:   return true;
48849: }
48849: 
49365: void
48849: HttpChannelChild::OnProgress(const PRUint64& progress,
48849:                              const PRUint64& progressMax)
48849: {
50561:   LOG(("HttpChannelChild::OnProgress [this=%p progress=%llu/%llu]\n",
46851:        this, progress, progressMax));
46851: 
50561:   if (mCanceled)
50561:     return;
50561: 
46851:   // cache the progress sink so we don't have to query for it each time.
46851:   if (!mProgressSink)
46851:     GetCallback(mProgressSink);
46851: 
71647:   AutoEventEnqueuer ensureSerialDispatch(mEventQ);
49365: 
67800:   // block socket status event after Cancel or OnStopRequest has been called,
67800:   // or if channel has LOAD_BACKGROUND set
46851:   if (mProgressSink && NS_SUCCEEDED(mStatus) && mIsPending && 
46851:       !(mLoadFlags & LOAD_BACKGROUND)) 
46851:   {
46851:     if (progress > 0) {
46851:       NS_ASSERTION(progress <= progressMax, "unexpected progress values");
46851:       mProgressSink->OnProgress(this, nsnull, progress, progressMax);
46851:     }
46851:   }
46851: }
46851: 
55160: class StatusEvent : public ChannelEvent
48849: {
48849:  public:
48849:   StatusEvent(HttpChannelChild* child,
67800:               const nsresult& status)
48849:   : mChild(child)
67800:   , mStatus(status) {}
48849: 
67800:   void Run() { mChild->OnStatus(mStatus); }
48849:  private:
48849:   HttpChannelChild* mChild;
48849:   nsresult mStatus;
48849: };
48849: 
46851: bool
67800: HttpChannelChild::RecvOnStatus(const nsresult& status)
46851: {
71647:   if (mEventQ.ShouldEnqueue()) {
71647:     mEventQ.Enqueue(new StatusEvent(this, status));
49365:   } else {
67800:     OnStatus(status);
49365:   }
49365:   return true;
48849: }
48849: 
49365: void
67800: HttpChannelChild::OnStatus(const nsresult& status)
48849: {
50561:   LOG(("HttpChannelChild::OnStatus [this=%p status=%x]\n", this, status));
50561: 
50561:   if (mCanceled)
50561:     return;
46851: 
46851:   // cache the progress sink so we don't have to query for it each time.
46851:   if (!mProgressSink)
46851:     GetCallback(mProgressSink);
46851: 
71647:   AutoEventEnqueuer ensureSerialDispatch(mEventQ);
49365: 
67800:   // block socket status event after Cancel or OnStopRequest has been called,
67800:   // or if channel has LOAD_BACKGROUND set
46851:   if (mProgressSink && NS_SUCCEEDED(mStatus) && mIsPending && 
46851:       !(mLoadFlags & LOAD_BACKGROUND)) 
46851:   {
67800:     nsCAutoString host;
67800:     mURI->GetHost(host);
67800:     mProgressSink->OnStatus(this, nsnull, status,
67800:                             NS_ConvertUTF8toUTF16(host).get());
46851:   }
48849: }
48849: 
71646: class FailedAsyncOpenEvent : public ChannelEvent
50561: {
50561:  public:
71646:   FailedAsyncOpenEvent(HttpChannelChild* child, const nsresult& status)
50561:   : mChild(child)
50561:   , mStatus(status) {}
50561: 
71646:   void Run() { mChild->FailedAsyncOpen(mStatus); }
50561:  private:
50561:   HttpChannelChild* mChild;
50561:   nsresult mStatus;
50561: };
50561: 
50561: bool
71646: HttpChannelChild::RecvFailedAsyncOpen(const nsresult& status)
50561: {
71647:   if (mEventQ.ShouldEnqueue()) {
71647:     mEventQ.Enqueue(new FailedAsyncOpenEvent(this, status));
50561:   } else {
71646:     FailedAsyncOpen(status);
50561:   }
50561:   return true;
50561: }
50561: 
71646: // We need to have an implementation of this function just so that we can keep
71646: // all references to mCallOnResume of type HttpChannelChild:  it's not OK in C++
71646: // to set a member function ptr to a base class function.
50561: void
71646: HttpChannelChild::HandleAsyncAbort()
50561: {
71646:   HttpAsyncAborter<HttpChannelChild>::HandleAsyncAbort();
50561: }
50561: 
71646: void
71646: HttpChannelChild::FailedAsyncOpen(const nsresult& status)
71646: {
71646:   LOG(("HttpChannelChild::FailedAsyncOpen [this=%p status=%x]\n", this, status));
50561: 
71646:   mStatus = status;
80486:   mIsPending = false;
71646:   // We're already being called from IPDL, therefore already "async"
71646:   HandleAsyncAbort();
71646: }
71646: 
71646: void
71646: HttpChannelChild::DoNotifyListenerCleanup()
71646: {
61190:   if (mIPCOpen)
61190:     PHttpChannelChild::Send__delete__(this);
50561: }
50561: 
55161: class DeleteSelfEvent : public ChannelEvent
55161: {
55161:  public:
55161:   DeleteSelfEvent(HttpChannelChild* child) : mChild(child) {}
55161:   void Run() { mChild->DeleteSelf(); }
55161:  private:
55161:   HttpChannelChild* mChild;
55161: };
55161: 
55161: bool
55161: HttpChannelChild::RecvDeleteSelf()
55161: {
71647:   if (mEventQ.ShouldEnqueue()) {
71647:     mEventQ.Enqueue(new DeleteSelfEvent(this));
55161:   } else {
55161:     DeleteSelf();
55161:   }
55161:   return true;
55161: }
55161: 
55161: void
55161: HttpChannelChild::DeleteSelf()
55161: {
61190:   Send__delete__(this);
55161: }
55161: 
55160: class Redirect1Event : public ChannelEvent
49375: {
49375:  public:
49375:   Redirect1Event(HttpChannelChild* child,
58111:                  const PRUint32& newChannelId,
49375:                  const IPC::URI& newURI,
49375:                  const PRUint32& redirectFlags,
49375:                  const nsHttpResponseHead& responseHead)
49375:   : mChild(child)
58111:   , mNewChannelId(newChannelId)
49375:   , mNewURI(newURI)
49375:   , mRedirectFlags(redirectFlags)
49375:   , mResponseHead(responseHead) {}
49375: 
49375:   void Run() 
49375:   { 
58111:     mChild->Redirect1Begin(mNewChannelId, mNewURI, mRedirectFlags,
49375:                            mResponseHead); 
49375:   }
49375:  private:
49375:   HttpChannelChild*   mChild;
58111:   PRUint32            mNewChannelId;
49375:   IPC::URI            mNewURI;
49375:   PRUint32            mRedirectFlags;
49375:   nsHttpResponseHead  mResponseHead;
49375: };
49375: 
49375: bool
58111: HttpChannelChild::RecvRedirect1Begin(const PRUint32& newChannelId,
58111:                                      const URI& newUri,
49375:                                      const PRUint32& redirectFlags,
49375:                                      const nsHttpResponseHead& responseHead)
49375: {
71647:   if (mEventQ.ShouldEnqueue()) {
71647:     mEventQ.Enqueue(new Redirect1Event(this, newChannelId, newUri,
71647:                                        redirectFlags, responseHead));
49375:   } else {
58111:     Redirect1Begin(newChannelId, newUri, redirectFlags, responseHead);
49375:   }
49375:   return true;
49375: }
49375: 
49375: void
58111: HttpChannelChild::Redirect1Begin(const PRUint32& newChannelId,
49375:                                  const IPC::URI& newURI,
49375:                                  const PRUint32& redirectFlags,
49375:                                  const nsHttpResponseHead& responseHead)
49375: {
58111:   nsresult rv;
58111: 
58111:   nsCOMPtr<nsIIOService> ioService;
58111:   rv = gHttpHandler->GetIOService(getter_AddRefs(ioService));
58111:   if (NS_FAILED(rv)) {
58111:     // Veto redirect.  nsHttpChannel decides to cancel or continue.
58111:     OnRedirectVerifyCallback(rv);
58111:     return;
58111:   }
58111: 
49375:   nsCOMPtr<nsIURI> uri(newURI);
49375: 
58111:   nsCOMPtr<nsIChannel> newChannel;
58111:   rv = ioService->NewChannelFromURI(uri, getter_AddRefs(newChannel));
50561:   if (NS_FAILED(rv)) {
55240:     // Veto redirect.  nsHttpChannel decides to cancel or continue.
58111:     OnRedirectVerifyCallback(rv);
50561:     return;
50561:   }
49375: 
49375:   // We won't get OnStartRequest, set cookies here.
49375:   mResponseHead = new nsHttpResponseHead(responseHead);
49375:   SetCookie(mResponseHead->PeekHeader(nsHttp::Set_Cookie));
49375: 
80420:   bool rewriteToGET = ShouldRewriteRedirectToGET(mResponseHead->Status(), 
80420:                                                  mRequestHead.Method());
80420:   
80420:   rv = SetupReplacementChannel(uri, newChannel, !rewriteToGET);
50561:   if (NS_FAILED(rv)) {
55240:     // Veto redirect.  nsHttpChannel decides to cancel or continue.
58111:     OnRedirectVerifyCallback(rv);
50561:     return;
50561:   }
49375: 
58111:   mRedirectChannelChild = do_QueryInterface(newChannel);
58111:   if (mRedirectChannelChild) {
58111:     mRedirectChannelChild->ConnectParent(newChannelId);
58111:   } else {
58111:     NS_ERROR("Redirecting to a protocol that doesn't support universal protocol redirect");
58111:   }
49375: 
50561:   rv = gHttpHandler->AsyncOnChannelRedirect(this, 
58111:                                             newChannel,
49375:                                             redirectFlags);
50561:   if (NS_FAILED(rv))
50561:     OnRedirectVerifyCallback(rv);
49375: }
49375: 
55160: class Redirect3Event : public ChannelEvent
49375: {
49375:  public:
49375:   Redirect3Event(HttpChannelChild* child) : mChild(child) {}
49375:   void Run() { mChild->Redirect3Complete(); }
49375:  private:
49375:   HttpChannelChild* mChild;
49375: };
49375: 
49375: bool
49375: HttpChannelChild::RecvRedirect3Complete()
49375: {
71647:   if (mEventQ.ShouldEnqueue()) {
71647:     mEventQ.Enqueue(new Redirect3Event(this));
49375:   } else {
49375:     Redirect3Complete();
49375:   }
49375:   return true;
49375: }
49375: 
49375: void
49375: HttpChannelChild::Redirect3Complete()
49375: {
58111:   nsresult rv = NS_OK;
58111: 
58111:   // Chrome channel has been AsyncOpen'd.  Reflect this in child.
58111:   if (mRedirectChannelChild)
58111:     rv = mRedirectChannelChild->CompleteRedirectSetup(mListener,
58111:                                                       mListenerContext);
49375: 
49375:   // Redirecting to new channel: shut this down and init new channel
49375:   if (mLoadGroup)
49375:     mLoadGroup->RemoveRequest(this, nsnull, NS_BINDING_ABORTED);
49375: 
49375:   if (NS_FAILED(rv))
55240:     NS_WARNING("CompleteRedirectSetup failed, HttpChannelChild already open?");
55240: 
55240:   // Release ref to new channel.
55240:   mRedirectChannelChild = nsnull;
49375: }
49375: 
58111: //-----------------------------------------------------------------------------
58111: // HttpChannelChild::nsIChildChannel
58111: //-----------------------------------------------------------------------------
58111: 
58111: NS_IMETHODIMP
58111: HttpChannelChild::ConnectParent(PRUint32 id)
58111: {
58111:   mozilla::dom::TabChild* tabChild = nsnull;
58111:   nsCOMPtr<nsITabChild> iTabChild;
58111:   GetCallback(iTabChild);
58111:   if (iTabChild) {
58111:     tabChild = static_cast<mozilla::dom::TabChild*>(iTabChild.get());
58111:   }
58111: 
58111:   // The socket transport in the chrome process now holds a logical ref to us
58111:   // until OnStopRequest, or we do a redirect, or we hit an IPDL error.
58111:   AddIPDLReference();
58111: 
58111:   if (!gNeckoChild->SendPHttpChannelConstructor(this, tabChild))
58111:     return NS_ERROR_FAILURE;
58111: 
58111:   if (!SendConnectChannel(id))
58111:     return NS_ERROR_FAILURE;
58111: 
58111:   return NS_OK;
58111: }
58111: 
58111: NS_IMETHODIMP
49375: HttpChannelChild::CompleteRedirectSetup(nsIStreamListener *listener, 
49375:                                         nsISupports *aContext)
49375: {
49375:   LOG(("HttpChannelChild::FinishRedirectSetup [this=%x]\n", this));
49375: 
49375:   NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
49375:   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
49375: 
55240:   /*
55240:    * No need to check for cancel: we don't get here if nsHttpChannel canceled
55240:    * before AsyncOpen(); if it's canceled after that, OnStart/Stop will just
55240:    * get called with error code as usual.  So just setup mListener and make the
55240:    * channel reflect AsyncOpen'ed state.
55240:    */
55240: 
80486:   mIsPending = true;
80486:   mWasOpened = true;
49375:   mListener = listener;
49375:   mListenerContext = aContext;
49375: 
49375:   // add ourselves to the load group. 
49375:   if (mLoadGroup)
49375:     mLoadGroup->AddRequest(this, nsnull);
49375: 
50561:   // We already have an open IPDL connection to the parent. If on-modify-request
50561:   // listeners or load group observers canceled us, let the parent handle it
50561:   // and send it back to us naturally.
49375:   return NS_OK;
49375: }
49375: 
49375: //-----------------------------------------------------------------------------
49375: // HttpChannelChild::nsIAsyncVerifyRedirectCallback
49375: //-----------------------------------------------------------------------------
49375: 
49375: NS_IMETHODIMP
49375: HttpChannelChild::OnRedirectVerifyCallback(nsresult result)
49375: {
58111:   nsCOMPtr<nsIHttpChannel> newHttpChannel =
58111:       do_QueryInterface(mRedirectChannelChild);
58111: 
58111:   if (newHttpChannel) {
49375:     // Must not be called until after redirect observers called.
75025:     newHttpChannel->SetOriginalURI(mOriginalURI);
58111:   }
58111: 
58111:   RequestHeaderTuples emptyHeaders;
58111:   RequestHeaderTuples* headerTuples = &emptyHeaders;
58111: 
58111:   nsCOMPtr<nsIHttpChannelChild> newHttpChannelChild =
58111:       do_QueryInterface(mRedirectChannelChild);
58111:   if (newHttpChannelChild && NS_SUCCEEDED(result)) {
58111:     newHttpChannelChild->AddCookiesToRequest();
58111:     newHttpChannelChild->GetHeaderTuples(&headerTuples);
58111:   }
49375: 
55241:   // After we verify redirect, nsHttpChannel may hit the network: must give
55241:   // "http-on-modify-request" observers the chance to cancel before that.
55241:   if (NS_SUCCEEDED(result))
58111:     gHttpHandler->OnModifyRequest(newHttpChannel);
55241: 
71646:   if (mIPCOpen)
71646:     SendRedirect2Verify(result, *headerTuples);
71646: 
71646:   return NS_OK;
49375: }
49375: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::nsIRequest
46672: //-----------------------------------------------------------------------------
46672: 
46672: NS_IMETHODIMP
46790: HttpChannelChild::Cancel(nsresult status)
46672: {
50561:   if (!mCanceled) {
50561:     // If this cancel occurs before nsHttpChannel has been set up, AsyncOpen
50561:     // is responsible for cleaning up.
50561:     mCanceled = true;
50561:     mStatus = status;
77793:     if (RemoteChannelExists())
50561:       SendCancel(status);
50561:   }
46792:   return NS_OK;
46672: }
46672: 
46672: NS_IMETHODIMP
46672: HttpChannelChild::Suspend()
46672: {
77793:   NS_ENSURE_TRUE(RemoteChannelExists(), NS_ERROR_NOT_AVAILABLE);
71647:   if (!mSuspendCount++) {
49379:     SendSuspend();
71647:     mEventQ.Suspend();
71647:   }
49379:   return NS_OK;
46672: }
46672: 
71646: void
71646: HttpChannelChild::CompleteResume()
71646: {
71646:   if (mCallOnResume) {
71646:     (this->*mCallOnResume)();
71646:     mCallOnResume = 0;
71646:   }
71646: 
71647:   // Don't resume event queue until now, else queued events could get
71647:   // flushed/called before mCallOnResume, which needs to run first.
71647:   mEventQ.Resume();
71646: }
71646: 
46672: NS_IMETHODIMP
46672: HttpChannelChild::Resume()
46672: {
77793:   NS_ENSURE_TRUE(RemoteChannelExists(), NS_ERROR_NOT_AVAILABLE);
49379:   NS_ENSURE_TRUE(mSuspendCount > 0, NS_ERROR_UNEXPECTED);
71646: 
71646:   nsresult rv = NS_OK;
71646: 
71647:   if (!--mSuspendCount) {
49379:     SendResume();
71646:     rv = AsyncCall(&HttpChannelChild::CompleteResume);
54829:   }
71646:   return rv;
46672: }
46672: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::nsIChannel
46672: //-----------------------------------------------------------------------------
46672: 
46672: NS_IMETHODIMP
46672: HttpChannelChild::GetSecurityInfo(nsISupports **aSecurityInfo)
46672: {
46792:   NS_ENSURE_ARG_POINTER(aSecurityInfo);
50566:   NS_IF_ADDREF(*aSecurityInfo = mSecurityInfo);
46792:   return NS_OK;
46672: }
46672: 
46672: NS_IMETHODIMP
46672: HttpChannelChild::AsyncOpen(nsIStreamListener *listener, nsISupports *aContext)
46672: {
46672:   LOG(("HttpChannelChild::AsyncOpen [this=%x uri=%s]\n", this, mSpec.get()));
46672: 
50561:   if (mCanceled)
50561:     return mStatus;
50561: 
46672:   NS_ENSURE_TRUE(gNeckoChild != nsnull, NS_ERROR_FAILURE);
46672:   NS_ENSURE_ARG_POINTER(listener);
46672:   NS_ENSURE_TRUE(!mIsPending, NS_ERROR_IN_PROGRESS);
46672:   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
46672: 
46672:   // Port checked in parent, but duplicate here so we can return with error
46838:   // immediately
46672:   nsresult rv;
46672:   rv = NS_CheckPortSafety(mURI);
46672:   if (NS_FAILED(rv))
46672:     return rv;
46672: 
46906:   const char *cookieHeader = mRequestHead.PeekHeader(nsHttp::Cookie);
46906:   if (cookieHeader) {
46906:     mUserSetCookieHeader = cookieHeader;
46906:   }
46906: 
46906:   AddCookiesToRequest();
46672: 
46887:   //
46887:   // NOTE: From now on we must return NS_OK; all errors must be handled via
46887:   // OnStart/OnStopRequest
46887:   //
46887: 
46838:   // notify "http-on-modify-request" observers
46838:   gHttpHandler->OnModifyRequest(this);
46838: 
80486:   mIsPending = true;
80486:   mWasOpened = true;
46790:   mListener = listener;
46790:   mListenerContext = aContext;
46790: 
46838:   // add ourselves to the load group. 
46838:   if (mLoadGroup)
46838:     mLoadGroup->AddRequest(this, nsnull);
46790: 
50561:   if (mCanceled) {
50561:     // We may have been canceled already, either by on-modify-request
50561:     // listeners or by load group observers; in that case, don't create IPDL
50561:     // connection. See nsHttpChannel::AsyncOpen().
71646:     AsyncAbort(mStatus);
50561:     return NS_OK;
50561:   }
46672: 
56242:   nsCString appCacheClientId;
56242:   if (mInheritApplicationCache) {
56242:     // Pick up an application cache from the notification
56242:     // callbacks if available
56242:     nsCOMPtr<nsIApplicationCacheContainer> appCacheContainer;
56242:     GetCallback(appCacheContainer);
56242: 
56242:     if (appCacheContainer) {
56242:       nsCOMPtr<nsIApplicationCache> appCache;
56242:       rv = appCacheContainer->GetApplicationCache(getter_AddRefs(appCache));
56242:       if (NS_SUCCEEDED(rv) && appCache) {
56242:         appCache->GetClientID(appCacheClientId);
56242:       }
56242:     }
56242:   }
56242: 
46838:   //
46838:   // Send request to the chrome process...
46838:   //
46672: 
46838:   // FIXME: bug 558623: Combine constructor and SendAsyncOpen into one IPC msg
46908: 
46908:   mozilla::dom::TabChild* tabChild = nsnull;
46908:   nsCOMPtr<nsITabChild> iTabChild;
46908:   GetCallback(iTabChild);
46908:   if (iTabChild) {
46908:     tabChild = static_cast<mozilla::dom::TabChild*>(iTabChild.get());
46908:   }
46908: 
49375:   // The socket transport in the chrome process now holds a logical ref to us
49375:   // until OnStopRequest, or we do a redirect, or we hit an IPDL error.
48132:   AddIPDLReference();
48132: 
46908:   gNeckoChild->SendPHttpChannelConstructor(this, tabChild);
46672: 
49375:   SendAsyncOpen(IPC::URI(mURI), IPC::URI(mOriginalURI),
49375:                 IPC::URI(mDocumentURI), IPC::URI(mReferrer), mLoadFlags,
78638:                 mRequestHeaders, mRequestHead.Method(),
56318:                 IPC::InputStream(mUploadStream), mUploadStreamHasHeaders,
56318:                 mPriority, mRedirectionLimit, mAllowPipelining,
56318:                 mForceAllowThirdPartyCookie, mSendResumeAt,
56242:                 mStartPos, mEntityID, mChooseApplicationCache, 
84396:                 appCacheClientId);
46672: 
46672:   return NS_OK;
46672: }
46672: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::nsIHttpChannel
46672: //-----------------------------------------------------------------------------
46672: 
46672: NS_IMETHODIMP
46672: HttpChannelChild::SetRequestHeader(const nsACString& aHeader, 
46672:                                    const nsACString& aValue, 
79445:                                    bool aMerge)
46672: {
46790:   nsresult rv = HttpBaseChannel::SetRequestHeader(aHeader, aValue, aMerge);
46755:   if (NS_FAILED(rv))
46755:     return rv;
46755: 
46755:   RequestHeaderTuple* tuple = mRequestHeaders.AppendElement();
46755:   if (!tuple)
46755:     return NS_ERROR_OUT_OF_MEMORY;
46755: 
46755:   tuple->mHeader = aHeader;
46755:   tuple->mValue = aValue;
46755:   tuple->mMerge = aMerge;
46755:   return NS_OK;
46755: }
46755: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::nsIHttpChannelInternal
46672: //-----------------------------------------------------------------------------
46672: 
46672: NS_IMETHODIMP
46672: HttpChannelChild::SetupFallbackChannel(const char *aFallbackKey)
46672: {
46672:   DROP_DEAD();
46672: }
46672: 
71834: // The next four _should_ be implemented, but we need to figure out how
71834: // to transfer the data from the chrome process first.
71834: 
71834: NS_IMETHODIMP
71834: HttpChannelChild::GetRemoteAddress(nsACString & _result)
71834: {
71834:   return NS_ERROR_NOT_AVAILABLE;
71834: }
71834: 
71834: NS_IMETHODIMP
71834: HttpChannelChild::GetRemotePort(PRInt32 * _result)
71834: {
71834:   NS_ENSURE_ARG_POINTER(_result);
71834:   return NS_ERROR_NOT_AVAILABLE;
71834: }
71834: 
71834: NS_IMETHODIMP
71834: HttpChannelChild::GetLocalAddress(nsACString & _result)
71834: {
71834:   return NS_ERROR_NOT_AVAILABLE;
71834: }
71834: 
71834: NS_IMETHODIMP
71834: HttpChannelChild::GetLocalPort(PRInt32 * _result)
71834: {
71834:   NS_ENSURE_ARG_POINTER(_result);
71834:   return NS_ERROR_NOT_AVAILABLE;
71834: }
71834: 
71834: 
46672: //-----------------------------------------------------------------------------
46915: // HttpChannelChild::nsICacheInfoChannel
46672: //-----------------------------------------------------------------------------
46672: 
46672: NS_IMETHODIMP
46915: HttpChannelChild::GetCacheTokenExpirationTime(PRUint32 *_retval)
46672: {
46915:   NS_ENSURE_ARG_POINTER(_retval);
46915:   if (!mCacheEntryAvailable)
46792:     return NS_ERROR_NOT_AVAILABLE;
46915: 
46915:   *_retval = mCacheExpirationTime;
46915:   return NS_OK;
46672: }
46672: 
46672: NS_IMETHODIMP
46915: HttpChannelChild::GetCacheTokenCachedCharset(nsACString &_retval)
46672: {
46915:   if (!mCacheEntryAvailable)
46915:     return NS_ERROR_NOT_AVAILABLE;
46672: 
46915:   _retval = mCachedCharset;
46792:   return NS_OK;
46672: }
46672: NS_IMETHODIMP
46915: HttpChannelChild::SetCacheTokenCachedCharset(const nsACString &aCharset)
46672: {
77793:   if (!mCacheEntryAvailable || !RemoteChannelExists())
46915:     return NS_ERROR_NOT_AVAILABLE;
46915: 
46915:   mCachedCharset = aCharset;
46915:   if (!SendSetCacheTokenCachedCharset(PromiseFlatCString(aCharset))) {
46915:     return NS_ERROR_FAILURE;
46672:   }
46915:   return NS_OK;
46672: }
46672: 
46672: NS_IMETHODIMP
79445: HttpChannelChild::IsFromCache(bool *value)
46672: {
46792:   if (!mIsPending)
46792:     return NS_ERROR_NOT_AVAILABLE;
46792: 
46915:   *value = mIsFromCache;
46792:   return NS_OK;
46672: }
46672: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::nsIResumableChannel
46672: //-----------------------------------------------------------------------------
46672: 
46672: NS_IMETHODIMP
46672: HttpChannelChild::ResumeAt(PRUint64 startPos, const nsACString& entityID)
46672: {
49379:   ENSURE_CALLED_BEFORE_ASYNC_OPEN();
49379:   mStartPos = startPos;
49379:   mEntityID = entityID;
49379:   mSendResumeAt = true;
49379:   return NS_OK;
46672: }
46672: 
49379: // GetEntityID is shared in HttpBaseChannel
46672: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::nsISupportsPriority
46672: //-----------------------------------------------------------------------------
46672: 
46672: NS_IMETHODIMP
46672: HttpChannelChild::SetPriority(PRInt32 aPriority)
46672: {
46793:   PRInt16 newValue = CLAMP(aPriority, PR_INT16_MIN, PR_INT16_MAX);
46793:   if (mPriority == newValue)
46793:     return NS_OK;
46793:   mPriority = newValue;
77793:   if (RemoteChannelExists())
46793:     SendSetPriority(mPriority);
46793:   return NS_OK;
46672: }
46672: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::nsIProxiedChannel
46672: //-----------------------------------------------------------------------------
46672: 
46672: NS_IMETHODIMP
46672: HttpChannelChild::GetProxyInfo(nsIProxyInfo **aProxyInfo)
46672: {
46672:   DROP_DEAD();
46672: }
46672: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::nsIApplicationCacheContainer
46672: //-----------------------------------------------------------------------------
46672: 
46672: NS_IMETHODIMP
46672: HttpChannelChild::GetApplicationCache(nsIApplicationCache **aApplicationCache)
46672: {
56242:   NS_IF_ADDREF(*aApplicationCache = mApplicationCache);
56242:   return NS_OK;
46672: }
46672: NS_IMETHODIMP
46672: HttpChannelChild::SetApplicationCache(nsIApplicationCache *aApplicationCache)
46672: {
56242:   NS_ENSURE_TRUE(!mWasOpened, NS_ERROR_ALREADY_OPENED);
56242: 
56242:   mApplicationCache = aApplicationCache;
56242:   return NS_OK;
46672: }
46672: 
46672: //-----------------------------------------------------------------------------
46672: // HttpChannelChild::nsIApplicationCacheChannel
46672: //-----------------------------------------------------------------------------
46672: 
46672: NS_IMETHODIMP
79445: HttpChannelChild::GetLoadedFromApplicationCache(bool *aLoadedFromApplicationCache)
46672: {
56242:   *aLoadedFromApplicationCache = mLoadedFromApplicationCache;
46792:   return NS_OK;
46672: }
46672: 
46672: NS_IMETHODIMP
79445: HttpChannelChild::GetInheritApplicationCache(bool *aInherit)
46672: {
56242:   *aInherit = mInheritApplicationCache;
56242:   return NS_OK;
46672: }
46672: NS_IMETHODIMP
79445: HttpChannelChild::SetInheritApplicationCache(bool aInherit)
46672: {
56242:   mInheritApplicationCache = aInherit;
46672:   return NS_OK;
46672: }
46672: 
46672: NS_IMETHODIMP
79445: HttpChannelChild::GetChooseApplicationCache(bool *aChoose)
46672: {
56242:   *aChoose = mChooseApplicationCache;
56242:   return NS_OK;
46672: }
56242: 
46672: NS_IMETHODIMP
79445: HttpChannelChild::SetChooseApplicationCache(bool aChoose)
46672: {
56242:   mChooseApplicationCache = aChoose;
56242:   return NS_OK;
56242: }
56242: 
56242: NS_IMETHODIMP
56242: HttpChannelChild::MarkOfflineCacheEntryAsForeign()
56242: {
56242:   SendMarkOfflineCacheEntryAsForeign();
46672:   return NS_OK;
46672: }
46672: 
50566: //-----------------------------------------------------------------------------
50566: // HttpChannelChild::nsIAssociatedContentSecurity
50566: //-----------------------------------------------------------------------------
50566: 
50566: bool
50566: HttpChannelChild::GetAssociatedContentSecurity(
50566:                     nsIAssociatedContentSecurity** _result)
50566: {
50566:   if (!mSecurityInfo)
50566:     return false;
50566: 
50566:   nsCOMPtr<nsIAssociatedContentSecurity> assoc =
50566:       do_QueryInterface(mSecurityInfo);
50566:   if (!assoc)
50566:     return false;
50566: 
50566:   if (_result)
50566:     assoc.forget(_result);
50566:   return true;
50566: }
50566: 
50566: /* attribute unsigned long countSubRequestsHighSecurity; */
50566: NS_IMETHODIMP
50566: HttpChannelChild::GetCountSubRequestsHighSecurity(
50566:                     PRInt32 *aSubRequestsHighSecurity)
50566: {
50566:   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
50566:   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
50566:     return NS_OK;
50566: 
50566:   return assoc->GetCountSubRequestsHighSecurity(aSubRequestsHighSecurity);
50566: }
50566: NS_IMETHODIMP
50566: HttpChannelChild::SetCountSubRequestsHighSecurity(
50566:                     PRInt32 aSubRequestsHighSecurity)
50566: {
50566:   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
50566:   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
50566:     return NS_OK;
50566: 
50566:   return assoc->SetCountSubRequestsHighSecurity(aSubRequestsHighSecurity);
50566: }
50566: 
50566: /* attribute unsigned long countSubRequestsLowSecurity; */
50566: NS_IMETHODIMP
50566: HttpChannelChild::GetCountSubRequestsLowSecurity(
50566:                     PRInt32 *aSubRequestsLowSecurity)
50566: {
50566:   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
50566:   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
50566:     return NS_OK;
50566: 
50566:   return assoc->GetCountSubRequestsLowSecurity(aSubRequestsLowSecurity);
50566: }
50566: NS_IMETHODIMP
50566: HttpChannelChild::SetCountSubRequestsLowSecurity(
50566:                     PRInt32 aSubRequestsLowSecurity)
50566: {
50566:   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
50566:   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
50566:     return NS_OK;
50566: 
50566:   return assoc->SetCountSubRequestsLowSecurity(aSubRequestsLowSecurity);
50566: }
50566: 
50566: /* attribute unsigned long countSubRequestsBrokenSecurity; */
50566: NS_IMETHODIMP 
50566: HttpChannelChild::GetCountSubRequestsBrokenSecurity(
50566:                     PRInt32 *aSubRequestsBrokenSecurity)
50566: {
50566:   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
50566:   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
50566:     return NS_OK;
50566: 
50566:   return assoc->GetCountSubRequestsBrokenSecurity(aSubRequestsBrokenSecurity);
50566: }
50566: NS_IMETHODIMP 
50566: HttpChannelChild::SetCountSubRequestsBrokenSecurity(
50566:                     PRInt32 aSubRequestsBrokenSecurity)
50566: {
50566:   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
50566:   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
50566:     return NS_OK;
50566: 
50566:   return assoc->SetCountSubRequestsBrokenSecurity(aSubRequestsBrokenSecurity);
50566: }
50566: 
50566: /* attribute unsigned long countSubRequestsNoSecurity; */
50566: NS_IMETHODIMP
50566: HttpChannelChild::GetCountSubRequestsNoSecurity(PRInt32 *aSubRequestsNoSecurity)
50566: {
50566:   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
50566:   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
50566:     return NS_OK;
50566: 
50566:   return assoc->GetCountSubRequestsNoSecurity(aSubRequestsNoSecurity);
50566: }
50566: NS_IMETHODIMP
50566: HttpChannelChild::SetCountSubRequestsNoSecurity(PRInt32 aSubRequestsNoSecurity)
50566: {
50566:   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
50566:   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
50566:     return NS_OK;
50566: 
50566:   return assoc->SetCountSubRequestsNoSecurity(aSubRequestsNoSecurity);
50566: }
50566: 
50566: NS_IMETHODIMP
50566: HttpChannelChild::Flush()
50566: {
50566:   nsCOMPtr<nsIAssociatedContentSecurity> assoc;
50566:   if (!GetAssociatedContentSecurity(getter_AddRefs(assoc)))
50566:     return NS_OK;
50566: 
50566:   nsresult rv;
50566:   PRInt32 hi, low, broken, no;
50566: 
50566:   rv = assoc->GetCountSubRequestsHighSecurity(&hi);
50566:   NS_ENSURE_SUCCESS(rv, rv);
50566:   rv = assoc->GetCountSubRequestsLowSecurity(&low);
50566:   NS_ENSURE_SUCCESS(rv, rv);
50566:   rv = assoc->GetCountSubRequestsBrokenSecurity(&broken);
50566:   NS_ENSURE_SUCCESS(rv, rv);
50566:   rv = assoc->GetCountSubRequestsNoSecurity(&no);
50566:   NS_ENSURE_SUCCESS(rv, rv);
50566: 
50566:   if (mIPCOpen)
50566:     SendUpdateAssociatedContentSecurity(hi, low, broken, no);
50566: 
50566:   return NS_OK;
50566: }
46672: 
58111: //-----------------------------------------------------------------------------
58111: // HttpChannelChild::nsIHttpChannelChild
58111: //-----------------------------------------------------------------------------
58111: 
58111: NS_IMETHODIMP HttpChannelChild::AddCookiesToRequest()
58111: {
58111:   HttpBaseChannel::AddCookiesToRequest();
58111:   return NS_OK;
58111: }
58111: 
58111: NS_IMETHODIMP HttpChannelChild::GetHeaderTuples(RequestHeaderTuples **aHeaderTuples)
58111: {
58111:   *aHeaderTuples = &mRequestHeaders;
58111:   return NS_OK;
58111: }
58111: 
46672: //------------------------------------------------------------------------------
49375: 
35924: }} // mozilla::net
