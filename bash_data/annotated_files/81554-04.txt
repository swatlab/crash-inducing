80098: #!/usr/bin/env/python
80098: # ***** BEGIN LICENSE BLOCK *****
80098: # Version: MPL 1.1/GPL 2.0/LGPL 2.1
80098: #
80098: # The contents of this file are subject to the Mozilla Public License Version
80098: # 1.1 (the "License"); you may not use this file except in compliance with
80098: # the License. You may obtain a copy of the License at
80098: # http://www.mozilla.org/MPL/
80098: #
80098: # Software distributed under the License is distributed on an "AS IS" basis,
80098: # WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
80098: # for the specific language governing rights and limitations under the
80098: # License.
80098: #
80098: # The Original Code is mozilla.org code.
80098: #
80098: # The Initial Developer of the Original Code is
80098: #   Mozilla Foundation.
80098: # Portions created by the Initial Developer are Copyright (C) 2011
80098: # the Initial Developer. All Rights Reserved.
80098: #
80098: # Contributor(s):
80098: #
80098: # Alternatively, the contents of this file may be used under the terms of
80098: # either of the GNU General Public License Version 2 or later (the "GPL"),
80098: # or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
80098: # in which case the provisions of the GPL or the LGPL are applicable instead
80098: # of those above. If you wish to allow use of your version of this file only
80098: # under the terms of either the GPL or the LGPL, and not to allow others to
80098: # use your version of this file under the terms of the MPL, indicate your
80098: # decision by deleting the provisions above and replace them with the notice
80098: # and other provisions required by the GPL or the LGPL. If you do not delete
80098: # the provisions above, a recipient may use your version of this file under
80098: # the terms of any one of the MPL, the GPL or the LGPL.
80098: #
80098: # ***** END LICENSE BLOCK *****
80098: 
80098: from codegen import *
80098: import xpidl
80098: import os, re
80098: import string
80098: import UserDict
80098: 
80098: # === Preliminaries
80098: 
80098: # --makedepend-output support.
80098: make_dependencies = []
80098: make_targets = []
80098: 
80098: # === Reading the file
80098: 
80098: def addStubMember(memberId, member):
80098:     # Add this member to the list.
80098:     member.iface.stubMembers.append(member)
80098: 
80098: def checkStubMember(member):
80098:     memberId = member.iface.name + "." + member.name
80098:     if member.kind not in ('method', 'attribute'):
80098:         raise UserError("Member %s is %r, not a method or attribute."
80098:                         % (memberId, member.kind))
80098:     if member.noscript:
80098:         raise UserError("%s %s is noscript."
80098:                         % (member.kind.capitalize(), memberId))
80098:     if member.notxpcom:
80098:         raise UserError(
80098:             "%s %s: notxpcom methods are not supported."
80098:             % (member.kind.capitalize(), memberId))
80098: 
80098:     # Check for unknown properties.
80098:     for attrname, value in vars(member).items():
80098:         if value is True and attrname not in ('readonly','optional_argc',
80098:                                               'implicit_jscontext','getter',
80098:                                               'stringifier'):
80098:             raise UserError("%s %s: unrecognized property %r"
80098:                             % (member.kind.capitalize(), memberId,
80098:                                attrname))
80098: 
80098: def loadIDL(parser, includePath, filename):
80098:     make_dependencies.append(filename)
80098:     text = open(filename, 'r').read()
80098:     idl = parser.parse(text, filename=filename)
80098:     idl.resolve(includePath, parser)
80098:     return idl
80098: 
80098: 
80098: def firstCap(str):
80098:     return str[0].upper() + str[1:]
80098: 
80098: class DOMClass(UserDict.DictMixin):
80098:     def __init__(self, name, nativeClass):
80098:         self.name = name
80098:         self.base = None
80098:         self.isBase = False
80098:         self.nativeClass = nativeClass
80098:         self.indexGetter = None
80099:         self.indexSetter = None
80098:         self.nameGetter = None
80099:         self.nameSetter = None
80098:         self.stringifier = False
80098:         self.members = set()
80098: 
80098:     @staticmethod
80098:     def getterNativeType(getter):
80098:         if isStringType(getter.realtype):
80098:             return 'nsString'
80098:         type = getter.realtype
80098:         if type.kind in ('interface', 'forward'):
80098:             if not getter.notxpcom:
80098:                 return "nsCOMPtr<%s>" % type.name
80098:             if len(getter.params) > 1:
80098:                 assert len(getter.params) == 2
80098:                 assert getter.params[1].realtype.kind == 'native' and getter.params[1].realtype.nativename == 'nsWrapperCache'
80098:                 return 'nsISupportsResult' 
80098:         return type.nativeType('in').strip()
80098: 
80098:     @staticmethod
80098:     def getterNativeCall(getter):
80098:         if isStringType(getter.realtype):
80098:             template = ("    list->%s(index, item);\n"
80098:                         "    return !DOMStringIsNull(item);\n")
80098:         else:
80098:             type = getter.realtype
80098:             if type.kind in ('interface', 'forward'):
80098:                 if not getter.notxpcom:
80098:                     template = "    return NS_SUCCEEDED(list->%s(index, getter_AddRefs(item)));\n"
80098:                 elif len(getter.params) > 1:
80098:                     template = ("    item.mResult = list->%s(index, &item.mCache);\n"
80098:                                 "    return !!item.mResult;\n")
80098:                 else:
80098:                     template = ("    item = list->%s(index);\n"
80098:                                 "    return !!item;\n")
80098:             else:
80098:                 template = ("    item = list->%s(index);\n"
80098:                             "    return !!item;\n")
80098: 
80098:         return template % header.methodNativeName(getter)
80098: 
80099:     @staticmethod
80099:     def setterNativeCall(setter):
80099:         if setter.notxpcom:
80099:             template = ("    !; // TODO")
80099:         else:
80099:             template = ("    nsresult rv = list->%s(index, item);\n"
81554:                         "    return NS_SUCCEEDED(rv) ? true : Throw(cx, rv);\n")
80099: 
80099:         return template % header.methodNativeName(setter)
80099: 
80098:     def __setattr__(self, name, value):
80098:         self.__dict__[name] = value
80098:         if value:
80098:             if name == 'indexGetter':
80098:                 if value.forward:
80098:                     self.realIndexGetter = value.iface.namemap[value.forward]
80098:                 else:
80098:                     self.realIndexGetter = value
80098:                 self.indexGetterType = self.getterNativeType(self.realIndexGetter)
80099:             elif name == 'indexSetter':
80099:                 if value.forward:
80099:                     self.realIndexSetter = value.iface.namemap[value.forward]
80099:                 else:
80099:                     self.realIndexSetter = value
80099:                 self.indexSetterType = self.realIndexSetter.params[1].realtype.nativeType("in")
80098:             elif name == 'nameGetter':
80098:                 if value.forward:
80098:                     self.realNameGetter = value.iface.namemap[value.forward]
80098:                 else:
80098:                     self.realNameGetter = value
80098:                 self.nameGetterType = self.getterNativeType(self.realNameGetter)
80099:             elif name == 'nameSetter':
80099:                 if value.forward:
80099:                     self.realNameSetter = value.iface.namemap[value.forward]
80099:                 else:
80099:                     self.realNameSetter = value
80099:                 self.nameSetterType = self.getterNativeType(self.realNameSetter)
80098: 
80098:     def __getitem__(self, key):
80098:         assert type(key) == str
80098: 
80098:         if key == 'indexGet':
80098:             return DOMClass.getterNativeCall(self.realIndexGetter)
80098: 
80099:         if key == 'indexSet':
80099:             return DOMClass.setterNativeCall(self.realIndexSetter)
80099: 
80098:         if key == 'nameGet':
80098:             return DOMClass.getterNativeCall(self.realNameGetter)
80098: 
80099:         if key == 'nameSet':
80099:             return DOMClass.setterNativeCall(self.realNameSetter)
80099: 
80099:         def ops(getterType, setterType):
80098:             def opType(type):
80098:                 return type + (" " if type.endswith('>') else "")
80098: 
80099:             if getterType or setterType:
80099:                 opsClass = ", Ops<"
80098:                 if getterType:
80098:                     opsClass += "Getter<" + opType(getterType) + ">"
80099:                 else:
80099:                     # Should we even support this?
80099:                     opsClass += "NoOp"
80099:                 if setterType:
80099:                     opsClass += ", Setter<" + opType(setterType) + ">"
80098:                 opsClass += " >"
80098:             else:
80098:                 opsClass = ", NoOps"
80098:             return opsClass
80098: 
80098:         if key == 'indexOps':
80099:             return ops(self.indexGetter and self.indexGetterType, self.indexSetter and self.indexSetterType)
80098:         if key == 'nameOps':
80099:             return ops(self.nameGetter and self.nameGetterType, self.nameSetter and self.nameSetterType) if self.nameGetter else ""
80098: 
80098:         if key == 'listClass':
80098:             if self.base:
80098:                 template = "DerivedListClass<${nativeClass}, ${base}Wrapper${indexOps}${nameOps} >"
80098:             else:
80098:                 template = "ListClass<${nativeClass}${indexOps}${nameOps} >"
80098:             return string.Template(template).substitute(self)
80098: 
80098:         return self.__dict__[key]
80098: 
80098:     def __cmp__(x, y):
80098:         if x.isBase != y.isBase:
80098:             return -1 if x.isBase else 1
80098:         return cmp(x.name, y.name)
80098: 
80098: class Configuration:
80098:     def __init__(self, filename, includePath):
80098:         self.includePath = includePath
80098:         config = {}
80098:         execfile(filename, config)
80098: 
80098:         # required settings
80098:         if 'classes' not in config:
80098:             raise UserError(filename + ": `%s` was not defined." % name)
80098:         self.classes = {}
80098:         for clazz in config['classes']:
80098:             self.classes[clazz] = DOMClass(name=clazz, nativeClass=config['classes'][clazz])
80098:         # optional settings
80098:         self.customInheritance = config.get('customInheritance', {})
80098:         self.derivedClasses = {}
80098:         self.irregularFilenames = config.get('irregularFilenames', {})
80098:         self.customIncludes = config.get('customIncludes', [])
80098: 
80098: def readConfigFile(filename, includePath):
80098:     # Read the config file.
80098:     return Configuration(filename, includePath)
80098: 
80098: def completeConfiguration(conf, includePath, cachedir):
80098:     # Now read IDL files to connect the information in the config file to
80098:     # actual XPCOM interfaces, methods, and attributes.
80098:     interfaces = []
80098:     interfacesByName = {}
80098:     parser = xpidl.IDLParser(cachedir)
80098: 
80098:     def getInterface(interfaceName, errorLoc):
80098:         iface = interfacesByName.get(interfaceName)
80098:         if iface is None:
80098:             idlFile = findIDL(conf.includePath, conf.irregularFilenames,
80098:                               interfaceName)
80098:             idl = loadIDL(parser, conf.includePath, idlFile)
80098:             if not idl.hasName(interfaceName):
80098:                 raise UserError("The interface %s was not found "
80098:                                 "in the idl file %r."
80098:                                 % (interfaceName, idlFile))
80098:             iface = idl.getName(interfaceName, errorLoc)
80098:             if not iface.attributes.scriptable:
80098:                 raise UserError("Interface %s is not scriptable. "
80098:                                 "IDL file: %r." % (interfaceName, idlFile))
80098:             iface.stubMembers = []
80098:             interfaces.append(iface)
80098:             interfacesByName[interfaceName] = iface
80098:         return iface
80098: 
80098:     stubbedInterfaces = []
80098: 
80098:     for clazz in conf.classes.itervalues():
80098:         interfaceName = 'nsIDOM' + clazz.name
80098: 
80098:         iface = getInterface(interfaceName, errorLoc='looking for %r' % clazz.name)
80098: 
80098:         for member in iface.members:
80098:             if member.kind in ('method', 'attribute') and not member.noscript:
80098:                 #addStubMember(iface.name + '.' + member.name, member)
80098:                 clazz.members.add(member)
80098: 
80098:         # Stub all scriptable members of this interface.
80098:         while True:
80098:             if iface not in stubbedInterfaces:
80098:                 stubbedInterfaces.append(iface)
80098:             if not clazz.indexGetter and iface.ops['index']['getter']:
80098:                 clazz.indexGetter = iface.ops['index']['getter']
80099:             if not clazz.indexSetter and iface.ops['index']['setter']:
80099:                 clazz.indexSetter = iface.ops['index']['setter']
80098:             if not clazz.nameGetter and iface.ops['name']['getter']:
80098:                 clazz.nameGetter = iface.ops['name']['getter']
80099:             if not clazz.nameSetter and iface.ops['name']['setter']:
80099:                 clazz.nameSetter = iface.ops['name']['setter']
80098:             if not clazz.stringifier and iface.ops['stringifier']:
80098:                 clazz.stringifier = iface.ops['stringifier']
80098:             interfaceName = conf.customInheritance.get(iface.name, iface.base)
80098:             iface = getInterface(interfaceName, errorLoc='looking for %r' % clazz.name)
80098:             if iface.name == 'nsISupports':
80098:                 break
80098: 
80098:             assert iface.name.startswith('nsIDOM') and not iface.name.startswith('nsIDOMNS')
80098:             clazz.base = iface.name[6:]
80098:             # For now we only support base classes that are real DOM classes
80098:             assert clazz.base in conf.classes
80098:             if not conf.classes[clazz.base].isBase:
80098:                 conf.classes[clazz.base].isBase = True
80098:                 conf.derivedClasses[clazz.base] = []
80098:             conf.derivedClasses[clazz.base].append(clazz.name)
80098: 
80098:     # Now go through and check all the interfaces' members
80098:     for iface in stubbedInterfaces:
80098:         for member in iface.stubMembers:
80098:             checkStubMember(member)
80098: 
80098:     return interfaces
80098: 
80098: # === Generating the header file
80098: 
80098: def needsForwardDeclaration(type):
80098:     return isInterfaceType(type) or (type.kind == 'native' and type.specialtype is None)
80098: 
80098: def getTypes(classes, map={}):
80098:     def getTranslatedType(type):
80098:         return map.get(type, type)
80098: 
80098:     types = set()
80098:     for clazz in classes.itervalues():
80098:         types.add(getTranslatedType(clazz.nativeClass))
80098:         if clazz.indexGetter and needsForwardDeclaration(clazz.realIndexGetter.realtype):
80098:             types.add(getTranslatedType(clazz.realIndexGetter.realtype.name))
80099:         if clazz.indexSetter and needsForwardDeclaration(clazz.realIndexSetter.realtype):
80099:             types.add(getTranslatedType(clazz.realIndexSetter.realtype.name))
80098:         if clazz.nameGetter and needsForwardDeclaration(clazz.realNameGetter.realtype):
80098:             types.add(getTranslatedType(clazz.realNameGetter.realtype.name))
80098:     return sorted(types)
80098: 
80098: listDefinitionTemplate = (
80098: "class ${name} {\n"
80098: "public:\n"
80098: "    template<typename I>\n"
80098: "    static JSObject *create(JSContext *cx, XPCWrappedNativeScope *scope, I *list, bool *triedToWrap)\n"
80098: "    {\n"
80098: "        return create(cx, scope, list, GetWrapperCache(list), triedToWrap);\n"
80098: "    }\n"
80098: "\n"
80098: "    static bool objIsWrapper(JSObject *obj);\n"
80098: "    static ${nativeClass} *getNative(JSObject *obj);\n"
80098: "\n"
80098: "private:\n"
80098: "    static JSObject *create(JSContext *cx, XPCWrappedNativeScope *scope, ${nativeClass} *list, nsWrapperCache *cache, bool *triedToWrap);\n"
80098: "};"
80098: "\n"
80098: "\n")
80098: 
80098: def writeHeaderFile(filename, config):
80098:     print "Creating header file", filename
80098: 
80098:     headerMacro = '__gen_%s__' % filename.replace('.', '_')
80098:     f = open(filename, 'w')
80098:     try:
80098:         f.write("/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */\n\n"
80098:                 "#ifndef " + headerMacro + "\n"
80098:                 "#define " + headerMacro + "\n\n")
80098: 
80098:         namespaces = []
80098:         for type in getTypes(config.classes, {}):
80098:             newNamespaces = type.split('::')
80098:             type = newNamespaces.pop()
80098:             j = 0
80098:             for i in range(min(len(namespaces), len(newNamespaces))):
80098:                 if namespaces[i] != newNamespaces[i]:
80098:                     break
80098:                 j += 1
80098:             for i in range(j, len(namespaces)):
80098:                 f.write("}\n")
80098:                 namespaces.pop()
80098:             for i in range(j, len(newNamespaces)):
80098:                 f.write("namespace %s {\n" % newNamespaces[i])
80098:                 namespaces.append(newNamespaces[i])
80098:             f.write("class %s;\n" % type)
80098:         for namespace in namespaces:
80098:             f.write("}\n")
80098:         f.write("\n")
80098: 
80098:         f.write("namespace mozilla {\n"
80098:                 "namespace dom {\n"
80098:                 "namespace binding {\n\n")
80098:         f.write("bool\n"
80098:                 "DefinePropertyStaticJSVals(JSContext *cx);\n\n")
80098: 
80098:         for clazz in config.classes.itervalues():
80098:             f.write(string.Template(listDefinitionTemplate).substitute(clazz))
80098: 
80098:         f.write("\n"
80098:                 "}\n"
80098:                 "}\n"
80098:                 "}\n\n")
80098:         f.write("#endif\n")
80098:     finally:
80098:         f.close()
80098: 
80098: def writeMakeDependOutput(filename):
80098:     print "Creating makedepend file", filename
80098:     f = open(filename, 'w')
80098:     try:
80098:         if len(make_targets) > 0:
80098:             f.write("%s:" % makeQuote(make_targets[0]))
80098:             for filename in make_dependencies:
80098:                 f.write(' \\\n\t\t%s' % makeQuote(filename))
80098:             f.write('\n\n')
80098:             for filename in make_targets[1:]:
80098:                 f.write('%s: %s\n' % (makeQuote(filename), makeQuote(make_targets[0])))
80098:     finally:
80098:         f.close()
80098: 
80098: # === Generating the source file
80098: 
80098: listTemplateHeader = (
80098: "// ${name}\n"
80098: "\n"
80098: "typedef ${listClass} ${name}Class;\n"
80098: "typedef ListBase<${name}Class> ${name}Wrapper;\n"
80098: "\n"
80098: "\n")
80098: 
80098: listTemplate = (
80098: "// ${name}\n"
80098: "\n"
80098: "template<>\n"
80098: "js::Class ${name}Wrapper::sInterfaceClass = {\n"
80098: "    \"${name}\",\n"
80098: "    0,\n"
80098: "    JS_PropertyStub,        /* addProperty */\n"
80098: "    JS_PropertyStub,        /* delProperty */\n"
80098: "    JS_PropertyStub,        /* getProperty */\n"
80098: "    JS_StrictPropertyStub,  /* setProperty */\n"
80098: "    JS_EnumerateStub,\n"
80098: "    JS_ResolveStub,\n"
80098: "    JS_ConvertStub,\n"
80098: "    NULL,                   /* finalize */\n"
80098: "    NULL,                   /* reserved0 */\n"
80098: "    NULL,                   /* checkAccess */\n"
80098: "    NULL,                   /* call */\n"
80098: "    NULL,                   /* construct */\n"
80098: "    NULL,                   /* xdrObject */\n"
80098: "    interface_hasInstance\n"
80098: "};\n"
80098: "\n")
80098: 
80098: derivedClassTemplate = (
80098: "template<>\n"
80098: "bool\n"
80098: "${name}Wrapper::objIsList(JSObject *obj)\n"
80098: "{\n"
80098: "    if (!js::IsProxy(obj))\n"
80098: "        return false;\n"
80098: "    js::ProxyHandler *handler = js::GetProxyHandler(obj);\n"
80098: "    return proxyHandlerIsList(handler) ||\n"
80098: "${checkproxyhandlers};\n"
80098: "}\n"
80098: "\n"
80098: "template<>\n"
80098: "${nativeClass}*\n"
80098: "${name}Wrapper::getNative(JSObject *obj)\n"
80098: "{\n"
80098: "    js::ProxyHandler *handler = js::GetProxyHandler(obj);\n"
80098: "    if (proxyHandlerIsList(handler))\n"
80098: "        return static_cast<${nativeClass}*>(js::GetProxyPrivate(obj).toPrivate());\n"
80098: "${castproxyhandlers}"
80098: "\n"
80098: "    NS_RUNTIMEABORT(\"Unknown list type!\");\n"
80098: "    return NULL;\n"
80098: "}\n"
80098: "\n")
80098: 
80098: toStringTemplate = (
80098: "template<>\n"
80098: "JSString *\n"
80098: "${name}Wrapper::obj_toString(JSContext *cx, JSObject *proxy)\n"
80098: "{\n"
80098: "    nsString result;\n"
80098: "    nsresult rv = ${name}Wrapper::getListObject(proxy)->ToString(result);\n"
80098: "    JSString *jsresult;\n"
80098: "    return NS_SUCCEEDED(rv) && xpc_qsStringToJsstring(cx, result, &jsresult) ? jsresult : NULL;\n"
80098: "}\n"
80098: "\n")
80098: 
80098: indexGetterTemplate = (
80098: "template<>\n"
80098: "bool\n"
80098: "${name}Wrapper::getItemAt(${nativeClass} *list, uint32 index, ${indexGetterType} &item)\n"
80098: "{\n"
80098: "${indexGet}"
80098: "}\n"
80098: "\n")
80098: 
80099: indexSetterTemplate = (
80099: "template<>\n"
80099: "bool\n"
81554: "${name}Wrapper::setItemAt(JSContext *cx, ${nativeClass} *list, uint32 index, ${indexSetterType} item)\n"
80099: "{\n"
80099: "${indexSet}"
80099: "}\n"
80099: "\n")
80099: 
80098: nameGetterTemplate = (
80098: "template<>\n"
80098: "bool\n"
80098: "${name}Wrapper::getNamedItem(${nativeClass} *list, const nsAString& index, ${nameGetterType} &item)\n"
80098: "{\n"
80098: "${nameGet}"
80098: "}\n"
80098: "\n")
80098: 
80099: nameSetterTemplate = (
80099: "template<>\n"
80099: "bool\n"
81554: "${name}Wrapper::setNamedItem(JSContext *cx, ${nativeClass} *list, const nsAString& index, ${nameSetterType} item)\n"
80099: "{\n"
80099: "${nameSet}"
80099: "}\n"
80099: "\n")
80099: 
80098: listTemplateFooter = (
80098: "template<>\n"
80098: "${name}Wrapper::Properties ${name}Wrapper::sProtoProperties[] = {\n"
80098: "${properties}\n"
80098: "};\n"
80098: "\n""template<>\n"
80098: "${name}Wrapper::Methods ${name}Wrapper::sProtoMethods[] = {\n"
80098: "${methods}\n"
80098: "};\n"
80098: "\n"
80234: "template class ListBase<${name}Class>;\n"
80234: "\n"
80098: "JSObject*\n"
80098: "${name}::create(JSContext *cx, XPCWrappedNativeScope *scope, ${nativeClass} *list, nsWrapperCache *cache, bool *triedToWrap)\n"
80098: "{\n"
80098: "    return ${name}Wrapper::create(cx, scope, list, cache, triedToWrap);\n"
80098: "}\n"
80098: "\n"
80098: "bool\n"
80098: "${name}::objIsWrapper(JSObject *obj)\n"
80098: "{\n"
80098: "    return ${name}Wrapper::objIsList(obj);\n"
80098: "}\n"
80098: "\n"
80098: "${nativeClass}*\n"
80098: "${name}::getNative(JSObject *obj)\n"
80098: "{\n"
80098: "    return ${name}Wrapper::getListObject(obj);\n"
80098: "}\n"
80098: "\n")
80098: 
80098: def writeBindingStub(f, classname, member, stubName, isSetter=False):
80098:     def writeThisUnwrapping(f, member, isMethod, isGetter, customMethodCall, haveCcx):
80098:         if isMethod:
80098:             f.write("    JSObject *callee = JSVAL_TO_OBJECT(JS_CALLEE(cx, vp));\n"
80098:                     "    if (!%sWrapper::instanceIsListObject(cx, obj, callee))\n"
80098:                     "        return false;\n" % classname)
80098:         else:
80098:             f.write("    if (!%sWrapper::instanceIsListObject(cx, obj, NULL))\n"
80098:                     "        return false;\n" % classname)
80098:         return "%sWrapper::getListObject(obj)" % classname
80098:     def writeCheckForFailure(f, isMethod, isGeter, haveCcx):
80098:         f.write("    if (NS_FAILED(rv)) {\n"
80098:                 "        xpc_qsThrowMethodFailedWithDetails(cx, rv, \"%s\", \"%s\");\n"
80098:                 "        return JS_FALSE;\n"
80098:                 "    }\n" % (classname, member.name))
80098:     def writeResultWrapping(f, member, jsvalPtr, jsvalRef):
80098:         if member.kind == 'method' and member.notxpcom and len(member.params) > 0 and member.params[len(member.params) - 1].paramtype == 'out':
80098:             assert member.params[len(member.params) - 1].realtype.kind == 'native' and member.params[len(member.params) - 1].realtype.nativename == 'nsWrapperCache'
80098:             template = "    return Wrap(cx, obj, result, cache, ${jsvalPtr});\n"
80098:         else:
80098:             template = "    return Wrap(cx, obj, result, ${jsvalPtr});\n"
80098:         writeResultConv(f, member.realtype, template, jsvalPtr, jsvalRef)
80098: 
80098:     writeStub(f, {}, member, stubName, writeThisUnwrapping, writeCheckForFailure, writeResultWrapping, isSetter)
80098: 
80098: def writeAttrStubs(f, classname, attr):
80098:     getterName = classname + '_' + header.attributeNativeName(attr, True)
80098:     writeBindingStub(f, classname, attr, getterName)
80098:     if attr.readonly:
80098:         setterName = 'xpc_qsGetterOnlyPropertyStub'
80098:     else:
80098:         setterName = (classname + '_'
80098:                       + header.attributeNativeName(attr, False))
80098:         writeBindingStub(f, classname, attr, setterName, isSetter=True)
80098: 
80098:     return "    { s_%s_id, %s, %s }" % (attr.name, getterName, setterName)
80098: 
80098: def writeMethodStub(f, classname, method):
80098:     stubName = classname + '_' + header.methodNativeName(method)
80098:     writeBindingStub(f, classname, method, stubName)
80098:     return "    { s_%s_id, %s, %i }" % (method.name, stubName, argumentsLength(method))
80098: 
80098: def writeStubFile(filename, config, interfaces):
80098:     print "Creating stub file", filename
80098:     make_targets.append(filename)
80098: 
80098:     f = open(filename, 'w')
80098:     filesIncluded = set()
80098: 
80098:     def includeType(type):
80098:         type = unaliasType(type)
80098:         if type.kind in ('builtin', 'native'):
80098:             return None
80098:         file = conf.irregularFilenames.get(type.name, type.name) + '.h'
80098:         if file not in filesIncluded:
80098:             f.write('#include "%s"\n' % file)
80098:             filesIncluded.add(file)
80098:         return type
80098: 
80098:     def writeIncludesForMember(member):
80098:         assert member.kind in ('attribute', 'method')
80098:         resulttype = includeType(member.realtype)
80098:         if member.kind == 'method':
80098:             for p in member.params:
80098:                 includeType(p.realtype)
80098:         return resulttype
80098: 
80098:     headerFilename = re.sub(r'(\.cpp)?$', '.h', filename)
80098: 
80098:     try:
80098:         f.write("/* THIS FILE IS AUTOGENERATED - DO NOT EDIT */\n\n")
80098: 
80098:         f.write("".join([("#include \"%s.h\"\n" % re.sub(r'(([^:]+::)*)', '', type)) for type in getTypes(config.classes, config.irregularFilenames)]))
80098:         f.write("\n")
80098: 
80098:         f.write("namespace mozilla {\n"
80098:                 "namespace dom {\n"
80098:                 "namespace binding {\n\n")
80098: 
80098:         f.write("// Property name ids\n\n")
80098: 
80098:         ids = set()
80098:         for clazz in config.classes.itervalues():
80098:             assert clazz.indexGetter
80098:             ids.add(clazz.indexGetter.name)
80099:             if clazz.indexSetter:
80099:                 ids.add(clazz.indexSetter.name)
80098:             if clazz.nameGetter:
80098:                 ids.add(clazz.nameGetter.name)
80098:             if clazz.stringifier:
80098:                 ids.add('toString')
80098:             for member in clazz.members:
80098:                 if member.name != 'length':
80098:                     ids.add(member.name)
80098: 
80098:         ids = sorted(ids)
80098:         for id in ids:
80098:             f.write("static jsid s_%s_id = JSID_VOID;\n" % id)
80098:         f.write("\n"
80098:                 "bool\n"
80098:                 "DefinePropertyStaticJSVals(JSContext *cx)\n"
80098:                 "{\n")
80098:         f.write("    return %s;" % (" &&\n           ".join([("SET_JSID_TO_STRING(cx, %s)" % id) for id in ids])))
80098:         f.write("\n"
80098:                 "}\n\n")
80098: 
80098:         classes = sorted(config.classes.values())
80098: 
80098:         f.write("// Typedefs\n\n")
80098: 
80098:         for clazz in classes:
80098:             f.write(string.Template(listTemplateHeader).substitute(clazz))
80098: 
80098:         f.write("// Implementation\n\n")
80098: 
80098:         for clazz in classes:
80098:             f.write(string.Template(listTemplate).substitute(clazz))
80098:             derivedClasses = config.derivedClasses.get(clazz.name, None)
80098:             if derivedClasses:
80098:                 # If this hits we might need to do something better than just compare instance pointers
80098:                 assert len(derivedClasses) <= 3
80098:                 checkproxyhandlers = "||\n".join(map(lambda d: "           %sWrapper::proxyHandlerIsList(handler)" % d, derivedClasses))
80098:                 castproxyhandlers = "\n".join(map(lambda d: "    if (%sWrapper::proxyHandlerIsList(handler))\n        return %sWrapper::getNative(obj);\n" % (d, d), derivedClasses))
80098:                 f.write(string.Template(derivedClassTemplate).substitute(clazz, checkproxyhandlers=checkproxyhandlers, castproxyhandlers=castproxyhandlers))
80098:             methodsList = []
80098:             propertiesList = []
80098:             if clazz.stringifier:
80098:                 f.write(string.Template(toStringTemplate).substitute(clazz))
80098:                 if clazz.stringifier.name != 'toString':
80098:                     methodsList.append("    { s_toString_id, %s_%s, 0 }", clazz.name, header.methodNativeName(clazz.stringifier))
80098:             if clazz.indexGetter:
80098:                 #methodsList.append("    { s_%s_id, &item, 1 }" % clazz.indexGetter.name)
80098:                 f.write(string.Template(indexGetterTemplate).substitute(clazz))
80099:             if clazz.indexSetter:
80099:                 f.write(string.Template(indexSetterTemplate).substitute(clazz))
80098:             if clazz.nameGetter:
80098:                 #methodsList.append("    { s_%s_id, &namedItem, 1 }" % clazz.nameGetter.name)
80098:                 f.write(string.Template(nameGetterTemplate).substitute(clazz))
80099:             if clazz.nameSetter:
80099:                 f.write(string.Template(nameSetterTemplate).substitute(clazz))
80342:             for member in sorted(clazz.members, key=lambda member: member.name):
80098:                 if member.name == 'length':
80098:                     if not member.readonly:
80098:                         setterName = (clazz.name + '_' + header.attributeNativeName(member, False))
80098:                         writeBindingStub(f, clazz.name, member, setterName, isSetter=True)
80098:                     else:
80098:                         setterName = "NULL"
80098: 
80098:                     propertiesList.append("    { s_length_id, length_getter, %s }" % setterName)
80098:                     continue
80098: 
80098:                 isAttr = (member.kind == 'attribute')
80098:                 isMethod = (member.kind == 'method')
80098:                 assert isAttr or isMethod
80098: 
80098:                 if isMethod:
80098:                     methodsList.append(writeMethodStub(f, clazz.name, member))
80098:                 else:
80098:                     propertiesList.append(writeAttrStubs(f, clazz.name, member))
80098: 
80098:             f.write(string.Template(listTemplateFooter).substitute(clazz, methods=",\n".join(methodsList), properties=",\n".join(propertiesList)))
80098:             
80098:         f.write("// Register prototypes\n\n")
80098: 
80098:         f.write("void\n"
80098:                 "Register(nsDOMClassInfoData *aData)\n"
80098:                 "{\n"
80098:                 "#define REGISTER_PROTO(_dom_class) \\\n"
80098:                 "    aData[eDOMClassInfo_##_dom_class##_id].mDefineDOMInterface = _dom_class##Wrapper::getPrototype\n"
80098:                 "\n")
80098:         for clazz in config.classes.itervalues():
80098:             f.write("    REGISTER_PROTO(%s);\n" % clazz.name)
80098:         f.write("\n"
80098:                 "#undef REGISTER_PROTO\n"
80098:                  "}\n\n")
80098: 
80098:         f.write("}\n"
80098:                 "}\n"
80098:                 "}\n")
80098:     finally:
80098:         f.close()
80098: 
80098: def main():
80098:     from optparse import OptionParser
80098:     o = OptionParser(usage="usage: %prog [options] configfile")
80098:     o.add_option('-o', "--stub-output",
80098:                  type='string', dest='stub_output', default=None,
80098:                  help="Quick stub C++ source output file", metavar="FILE")
80098:     o.add_option('--header-output', type='string', default=None,
80098:                  help="Quick stub header output file", metavar="FILE")
80098:     o.add_option('--makedepend-output', type='string', default=None,
80098:                  help="gnumake dependencies output file", metavar="FILE")
80098:     o.add_option('--idlpath', type='string', default='.',
80098:                  help="colon-separated directories to search for idl files",
80098:                  metavar="PATH")
80098:     o.add_option('--cachedir', dest='cachedir', default='',
80098:                  help="Directory in which to cache lex/parse tables.")
80098:     o.add_option("--verbose-errors", action='store_true', default=False,
80098:                  help="When an error happens, display the Python traceback.")
80098:     (options, filenames) = o.parse_args()
80098: 
80098:     if len(filenames) != 1:
80098:         o.error("Exactly one config filename is needed.")
80098:     filename = filenames[0]
80098: 
80098:     if options.cachedir != '':
80098:         sys.path.append(options.cachedir)
80098:         if not os.path.isdir(options.cachedir):
80098:             os.makedirs(options.cachedir)
80098: 
80098:     try:
80098:         includePath = options.idlpath.split(':')
80098:         conf = readConfigFile(filename,
80098:                               includePath=includePath)
80098:         if options.header_output is not None:
80098:             writeHeaderFile(options.header_output, conf)
80098:         elif options.stub_output is not None:
80098:             interfaces = completeConfiguration(conf,
80098:                                                includePath=includePath,
80098:                                                cachedir=options.cachedir)
80098:             writeStubFile(options.stub_output, conf, interfaces)
80098:             if options.makedepend_output is not None:
80098:                 writeMakeDependOutput(options.makedepend_output)
80098:     except Exception, exc:
80098:         if options.verbose_errors:
80098:             raise
80098:         elif isinstance(exc, (UserError, xpidl.IDLError)):
80098:             warn(str(exc))
80098:         elif isinstance(exc, OSError):
80098:             warn("%s: %s" % (exc.__class__.__name__, exc))
80098:         else:
80098:             raise
80098:         sys.exit(1)
80098: 
80098: if __name__ == '__main__':
80098:     main()
