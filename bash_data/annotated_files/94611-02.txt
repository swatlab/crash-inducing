69223: /* -*- Mode: C; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
69223:  * vim: set ts=4 sw=4 et tw=79 ft=cpp:
69223:  *
69223:  * ***** BEGIN LICENSE BLOCK *****
69223:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
69223:  *
69223:  * The contents of this file are subject to the Mozilla Public License Version
69223:  * 1.1 (the "License"); you may not use this file except in compliance with
69223:  * the License. You may obtain a copy of the License at
69223:  * http://www.mozilla.org/MPL/
69223:  *
69223:  * Software distributed under the License is distributed on an "AS IS" basis,
69223:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
69223:  * for the specific language governing rights and limitations under the
69223:  * License.
69223:  *
69223:  * The Original Code is SpiderMonkey JavaScript engine.
69223:  *
69223:  * The Initial Developer of the Original Code is
69223:  * Mozilla Corporation.
69223:  * Portions created by the Initial Developer are Copyright (C) 2009
69223:  * the Initial Developer. All Rights Reserved.
69223:  *
69223:  * Contributor(s):
69223:  *   Luke Wagner <luke@mozilla.com>
69223:  *
69223:  * Alternatively, the contents of this file may be used under the terms of
69223:  * either the GNU General Public License Version 2 or later (the "GPL"), or
69223:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
69223:  * in which case the provisions of the GPL or the LGPL are applicable instead
69223:  * of those above. If you wish to allow use of your version of this file only
69223:  * under the terms of either the GPL or the LGPL, and not to allow others to
69223:  * use your version of this file under the terms of the MPL, indicate your
69223:  * decision by deleting the provisions above and replace them with the notice
69223:  * and other provisions required by the GPL or the LGPL. If you do not delete
69223:  * the provisions above, a recipient may use your version of this file under
69223:  * the terms of any one of the MPL, the GPL or the LGPL.
69223:  *
69223:  * ***** END LICENSE BLOCK ***** */
69223: 
69223: #ifndef Stack_inl_h__
69223: #define Stack_inl_h__
69223: 
70320: #include "jscntxt.h"
70321: #include "jscompartment.h"
70320: 
86483: #include "methodjit/MethodJIT.h"
86483: #include "vm/Stack.h"
69223: 
77884: #include "jsscriptinlines.h"
86483: 
69827: #include "ArgumentsObject-inl.h"
86483: #include "ScopeObject-inl.h"
78065: 
69827: 
69223: namespace js {
69223: 
83228: /*
83228:  * We cache name lookup results only for the global object or for native
83228:  * non-global objects without prototype or with prototype that never mutates,
83228:  * see bug 462734 and bug 487039.
83228:  */
83228: static inline bool
83228: IsCacheableNonGlobalScope(JSObject *obj)
83228: {
83228:     bool cacheable = (obj->isCall() || obj->isBlock() || obj->isDeclEnv());
83228: 
83228:     JS_ASSERT_IF(cacheable, !obj->getOps()->lookupProperty);
83228:     return cacheable;
83228: }
83228: 
83239: inline JSObject &
83239: StackFrame::scopeChain() const
83239: {
83239:     JS_ASSERT_IF(!(flags_ & HAS_SCOPECHAIN), isFunctionFrame());
83239:     if (!(flags_ & HAS_SCOPECHAIN)) {
83283:         scopeChain_ = callee().toFunction()->environment();
83239:         flags_ |= HAS_SCOPECHAIN;
83239:     }
83239:     return *scopeChain_;
83239: }
83239: 
83239: inline JSObject &
83239: StackFrame::varObj()
83239: {
83239:     JSObject *obj = &scopeChain();
83239:     while (!obj->isVarObj())
86483:         obj = obj->enclosingScope();
83239:     return *obj;
83239: }
83239: 
83239: inline JSCompartment *
83239: StackFrame::compartment() const
83239: {
83239:     JS_ASSERT_IF(isScriptFrame(), scopeChain().compartment() == script()->compartment());
83239:     return scopeChain().compartment();
83239: }
83239: 
69223: inline void
69223: StackFrame::initPrev(JSContext *cx)
69223: {
69223:     JS_ASSERT(flags_ & HAS_PREVPC);
69223:     if (FrameRegs *regs = cx->maybeRegs()) {
69223:         prev_ = regs->fp();
69223:         prevpc_ = regs->pc;
76193:         prevInline_ = regs->inlined();
82642:         JS_ASSERT_IF(!prev_->isDummyFrame(),
84755:                      uint32_t(prevpc_ - prev_->script()->code) < prev_->script()->length);
69223:     } else {
69223:         prev_ = NULL;
69223: #ifdef DEBUG
69223:         prevpc_ = (jsbytecode *)0xbadc;
76193:         prevInline_ = (JSInlinedSite *)0xbadc;
69223: #endif
69223:     }
69223: }
69223: 
69223: inline void
69223: StackFrame::resetGeneratorPrev(JSContext *cx)
69223: {
69223:     flags_ |= HAS_PREVPC;
69223:     initPrev(cx);
69223: }
69223: 
69223: inline void
76193: StackFrame::initInlineFrame(JSFunction *fun, StackFrame *prevfp, jsbytecode *prevpc)
76193: {
77341:     /*
77341:      * Note: no need to ensure the scopeChain is instantiated for inline
77341:      * frames. Functions which use the scope chain are never inlined.
77341:      */
76193:     flags_ = StackFrame::FUNCTION;
76193:     exec.fun = fun;
76193:     resetInlinePrev(prevfp, prevpc);
76193: }
76193: 
76193: inline void
76193: StackFrame::resetInlinePrev(StackFrame *prevfp, jsbytecode *prevpc)
76193: {
76193:     JS_ASSERT_IF(flags_ & StackFrame::HAS_PREVPC, prevInline_);
76193:     flags_ |= StackFrame::HAS_PREVPC;
76193:     prev_ = prevfp;
76193:     prevpc_ = prevpc;
76193:     prevInline_ = NULL;
76193: }
76193: 
76193: inline void
83283: StackFrame::initCallFrame(JSContext *cx, JSFunction &callee,
84755:                           JSScript *script, uint32_t nactual, StackFrame::Flags flagsArg)
69223: {
69223:     JS_ASSERT((flagsArg & ~(CONSTRUCTING |
77341:                             LOWERED_CALL_APPLY |
69223:                             OVERFLOW_ARGS |
69223:                             UNDERFLOW_ARGS)) == 0);
86773:     JS_ASSERT(script == callee.script());
69223: 
69223:     /* Initialize stack frame members. */
86077:     flags_ = FUNCTION | HAS_PREVPC | HAS_SCOPECHAIN | HAS_BLOCKCHAIN | flagsArg;
83283:     exec.fun = &callee;
87583:     u.nactual = nactual;
86773:     scopeChain_ = callee.environment();
76193:     ncode_ = NULL;
69223:     initPrev(cx);
86077:     blockChain_= NULL;
86077:     JS_ASSERT(!hasBlockChain());
69223:     JS_ASSERT(!hasHookData());
69223:     JS_ASSERT(annotation() == NULL);
69223:     JS_ASSERT(!hasCallObj());
71695: 
71695:     SetValueRangeToUndefined(slots(), script->nfixed);
69223: }
69223: 
89722: /*
89722:  * Reinitialize the StackFrame fields that have been initialized up to the
89722:  * point of FixupArity in the function prologue.
89722:  */
69223: inline void
91237: StackFrame::initFixupFrame(StackFrame *prev, StackFrame::Flags flags, void *ncode, unsigned nactual)
69223: {
71695:     JS_ASSERT((flags & ~(CONSTRUCTING |
77341:                          LOWERED_CALL_APPLY |
69223:                          FUNCTION |
69223:                          OVERFLOW_ARGS |
69223:                          UNDERFLOW_ARGS)) == 0);
69223: 
71695:     flags_ = FUNCTION | flags;
73495:     prev_ = prev;
69223:     ncode_ = ncode;
87583:     u.nactual = nactual;
69223: }
69223: 
69223: inline Value &
91237: StackFrame::canonicalActualArg(unsigned i) const
69223: {
69223:     if (i < numFormalArgs())
69223:         return formalArg(i);
69223:     JS_ASSERT(i < numActualArgs());
69223:     return actualArgs()[i];
69223: }
69223: 
69223: template <class Op>
69223: inline bool
91237: StackFrame::forEachCanonicalActualArg(Op op, unsigned start /* = 0 */, unsigned count /* = unsigned(-1) */)
69223: {
91237:     unsigned nformal = fun()->nargs;
70319:     JS_ASSERT(start <= nformal);
70319: 
69223:     Value *formals = formalArgsEnd() - nformal;
91237:     unsigned nactual = numActualArgs();
91237:     if (count == unsigned(-1))
70319:         count = nactual - start;
70319: 
91237:     unsigned end = start + count;
70319:     JS_ASSERT(end >= start);
70319:     JS_ASSERT(end <= nactual);
70319: 
70319:     if (end <= nformal) {
70319:         Value *p = formals + start;
70319:         for (; start < end; ++p, ++start) {
70319:             if (!op(start, p))
69223:                 return false;
69223:         }
69223:     } else {
70319:         for (Value *p = formals + start; start < nformal; ++p, ++start) {
70319:             if (!op(start, p))
69223:                 return false;
69223:         }
70319:         JS_ASSERT(start >= nformal);
70319:         Value *actuals = formals - (nactual + 2) + start;
70319:         for (Value *p = actuals; start < end; ++p, ++start) {
70319:             if (!op(start, p))
69223:                 return false;
69223:         }
69223:     }
69223:     return true;
69223: }
69223: 
69223: template <class Op>
69223: inline bool
69223: StackFrame::forEachFormalArg(Op op)
69223: {
69223:     Value *formals = formalArgsEnd() - fun()->nargs;
69223:     Value *formalsEnd = formalArgsEnd();
91237:     unsigned i = 0;
69223:     for (Value *p = formals; p != formalsEnd; ++p, ++i) {
69223:         if (!op(i, p))
69223:             return false;
69223:     }
69223:     return true;
69223: }
69223: 
69223: struct CopyTo
69223: {
69223:     Value *dst;
69223:     CopyTo(Value *dst) : dst(dst) {}
91237:     bool operator()(unsigned, Value *src) {
69223:         *dst++ = *src;
69223:         return true;
69223:     }
69223: };
69223: 
91237: inline unsigned
69223: StackFrame::numActualArgs() const
69223: {
77341:     /*
87583:      * u.nactual is always coherent, except for method JIT frames where the
77341:      * callee does not access its arguments and the number of actual arguments
77341:      * matches the number of formal arguments. The JIT requires that all frames
77341:      * which do not have an arguments object and use their arguments have a
87583:      * coherent u.nactual (even though the below code may not use it), as
77341:      * JIT code may access the field directly.
77341:      */
69223:     JS_ASSERT(hasArgs());
69223:     if (JS_UNLIKELY(flags_ & (OVERFLOW_ARGS | UNDERFLOW_ARGS)))
87583:         return u.nactual;
69223:     return numFormalArgs();
69223: }
69223: 
69223: inline Value *
69223: StackFrame::actualArgs() const
69223: {
69223:     JS_ASSERT(hasArgs());
69223:     Value *argv = formalArgs();
87583:     if (JS_UNLIKELY(flags_ & OVERFLOW_ARGS))
87583:         return argv - (2 + u.nactual);
69223:     return argv;
69223: }
69223: 
69223: inline Value *
69223: StackFrame::actualArgsEnd() const
69223: {
69223:     JS_ASSERT(hasArgs());
69223:     if (JS_UNLIKELY(flags_ & OVERFLOW_ARGS))
69223:         return formalArgs() - 2;
69223:     return formalArgs() + numActualArgs();
69223: }
69223: 
69223: inline void
69223: StackFrame::setScopeChainNoCallObj(JSObject &obj)
69223: {
69223: #ifdef DEBUG
69223:     JS_ASSERT(&obj != NULL);
69223:     if (&obj != sInvalidScopeChain) {
69223:         if (hasCallObj()) {
69223:             JSObject *pobj = &obj;
69223:             while (pobj && pobj->getPrivate() != this)
86483:                 pobj = pobj->enclosingScope();
69223:             JS_ASSERT(pobj);
69223:         } else {
86483:             for (JSObject *pobj = &obj; pobj->isScope(); pobj = pobj->enclosingScope())
69223:                 JS_ASSERT_IF(pobj->isCall(), pobj->getPrivate() != this);
69223:         }
69223:     }
69223: #endif
69223:     scopeChain_ = &obj;
69223:     flags_ |= HAS_SCOPECHAIN;
69223: }
69223: 
69223: inline void
78065: StackFrame::setScopeChainWithOwnCallObj(CallObject &obj)
69223: {
69223:     JS_ASSERT(&obj != NULL);
78065:     JS_ASSERT(!hasCallObj() && obj.maybeStackFrame() == this);
69223:     scopeChain_ = &obj;
69223:     flags_ |= HAS_SCOPECHAIN | HAS_CALL_OBJ;
69223: }
69223: 
78065: inline CallObject &
69223: StackFrame::callObj() const
69223: {
69223:     JS_ASSERT_IF(isNonEvalFunctionFrame() || isStrictEvalFrame(), hasCallObj());
69223: 
69223:     JSObject *pobj = &scopeChain();
80154:     while (JS_UNLIKELY(!pobj->isCall()))
86483:         pobj = pobj->enclosingScope();
78065:     return pobj->asCall();
69223: }
69223: 
77884: inline bool
77884: StackFrame::maintainNestingState() const
77884: {
77884:     /*
77884:      * Whether to invoke the nesting epilogue/prologue to maintain active
77884:      * frame counts and check for reentrant outer functions.
77884:      */
77884:     return isNonEvalFunctionFrame() && !isGeneratorFrame() && script()->nesting();
77884: }
77884: 
77884: inline bool
77884: StackFrame::functionPrologue(JSContext *cx)
77884: {
77884:     JS_ASSERT(isNonEvalFunctionFrame());
93250:     JS_ASSERT(!isGeneratorFrame());
77884: 
77884:     JSFunction *fun = this->fun();
93250:     JSScript *script = fun->script();
93250: 
93250:     if (script->needsArgsObj() && !ArgumentsObject::create(cx, this))
93250:         return false;
77884: 
77884:     if (fun->isHeavyweight()) {
91175:         if (!CallObject::createForFunction(cx, this))
77884:             return false;
77884:     } else {
77884:         /* Force instantiation of the scope chain, for JIT frames. */
77884:         scopeChain();
77884:     }
77884: 
93250:     if (script->nesting()) {
77884:         JS_ASSERT(maintainNestingState());
77884:         types::NestingPrologue(cx, this);
77884:     }
77884: 
77884:     return true;
77884: }
77884: 
69223: inline void
78748: StackFrame::functionEpilogue()
69223: {
77884:     JS_ASSERT(isNonEvalFunctionFrame());
77884: 
69223:     if (flags_ & (HAS_ARGS_OBJ | HAS_CALL_OBJ)) {
69223:         if (hasCallObj())
69223:             js_PutCallObject(this);
93250:         if (hasArgsObj())
69223:             js_PutArgsObject(this);
69223:     }
77884: 
78748:     if (maintainNestingState())
77884:         types::NestingEpilogue(this);
69223: }
69223: 
69223: inline void
86774: StackFrame::updateEpilogueFlags()
69223: {
69223:     if (flags_ & (HAS_ARGS_OBJ | HAS_CALL_OBJ)) {
87583:         if (hasArgsObj() && !argsObj().maybeStackFrame())
69223:             flags_ &= ~HAS_ARGS_OBJ;
78065:         if (hasCallObj() && !callObj().maybeStackFrame()) {
69223:             /*
69223:              * For function frames, the call object may or may not have have an
69223:              * enclosing DeclEnv object, so we use the callee's parent, since
69223:              * it was the initial scope chain. For global (strict) eval frames,
83252:              * there is no callee, but the call object's parent is the initial
69223:              * scope chain.
69223:              */
69223:             scopeChain_ = isFunctionFrame()
83283:                           ? callee().toFunction()->environment()
86483:                           : &scopeChain_->asScope().enclosingScope();
69223:             flags_ &= ~HAS_CALL_OBJ;
69223:         }
69223:     }
77884: 
77884:     /*
77884:      * For outer/inner function frames, undo the active frame balancing so that
77884:      * when we redo it in the epilogue we get the right final value. The other
77884:      * nesting epilogue changes (update active args/vars) are idempotent.
77884:      */
78748:     if (maintainNestingState())
77884:         script()->nesting()->activeFrames++;
69223: }
69223: 
69223: /*****************************************************************************/
69223: 
69223: STATIC_POSTCONDITION(!return || ubound(from) >= nvals)
69223: JS_ALWAYS_INLINE bool
76885: StackSpace::ensureSpace(JSContext *cx, MaybeReportError report, Value *from, ptrdiff_t nvals,
76885:                         JSCompartment *dest) const
69223: {
73495:     assertInvariants();
69223:     JS_ASSERT(from >= firstUnused());
69223: #ifdef XP_WIN
69223:     JS_ASSERT(from <= commitEnd_);
73495: #endif
73495:     if (JS_UNLIKELY(conservativeEnd_ - from < nvals))
76885:         return ensureSpaceSlow(cx, report, from, nvals, dest);
69223:     return true;
69223: }
69223: 
69223: inline Value *
73495: StackSpace::getStackLimit(JSContext *cx, MaybeReportError report)
69223: {
69223:     FrameRegs &regs = cx->regs();
91237:     unsigned nvals = regs.fp()->numSlots() + STACK_JIT_EXTRA;
73495:     return ensureSpace(cx, report, regs.sp, nvals)
73495:            ? conservativeEnd_
73495:            : NULL;
69223: }
69223: 
69223: /*****************************************************************************/
69223: 
73495: JS_ALWAYS_INLINE StackFrame *
73495: ContextStack::getCallFrame(JSContext *cx, MaybeReportError report, const CallArgs &args,
89722:                            JSFunction *fun, JSScript *script, StackFrame::Flags *flags) const
69223: {
73495:     JS_ASSERT(fun->script() == script);
91237:     unsigned nformal = fun->nargs;
69223: 
73495:     Value *firstUnused = args.end();
73495:     JS_ASSERT(firstUnused == space().firstUnused());
73495: 
77354:     /* Include extra space to satisfy the method-jit stackLimit invariant. */
91237:     unsigned nvals = VALUES_PER_STACK_FRAME + script->nslots + StackSpace::STACK_JIT_EXTRA;
69223: 
69223:     /* Maintain layout invariant: &formalArgs[0] == ((Value *)fp) - nformal. */
69223: 
79387:     if (args.length() == nformal) {
73495:         if (!space().ensureSpace(cx, report, firstUnused, nvals))
69223:             return NULL;
69223:         return reinterpret_cast<StackFrame *>(firstUnused);
69223:     }
69223: 
79387:     if (args.length() < nformal) {
71695:         *flags = StackFrame::Flags(*flags | StackFrame::UNDERFLOW_ARGS);
91237:         unsigned nmissing = nformal - args.length();
73495:         if (!space().ensureSpace(cx, report, firstUnused, nmissing + nvals))
69223:             return NULL;
69223:         SetValueRangeToUndefined(firstUnused, nmissing);
69223:         return reinterpret_cast<StackFrame *>(firstUnused + nmissing);
69223:     }
69223: 
71695:     *flags = StackFrame::Flags(*flags | StackFrame::OVERFLOW_ARGS);
91237:     unsigned ncopy = 2 + nformal;
73495:     if (!space().ensureSpace(cx, report, firstUnused, ncopy + nvals))
69223:         return NULL;
69223:     Value *dst = firstUnused;
71695:     Value *src = args.base();
69223:     PodCopy(dst, src, ncopy);
69223:     return reinterpret_cast<StackFrame *>(firstUnused + ncopy);
69223: }
69223: 
71695: JS_ALWAYS_INLINE bool
71695: ContextStack::pushInlineFrame(JSContext *cx, FrameRegs &regs, const CallArgs &args,
83283:                               JSFunction &callee, JSScript *script,
77354:                               InitialFrameFlags initial)
69223: {
71697:     JS_ASSERT(onTop());
71695:     JS_ASSERT(regs.sp == args.end());
71695:     /* Cannot assert callee == args.callee() since this is called from LeaveTree. */
86773:     JS_ASSERT(script == callee.script());
69223: 
89722:     StackFrame::Flags flags = ToFrameFlags(initial);
83283:     StackFrame *fp = getCallFrame(cx, REPORT_ERROR, args, &callee, script, &flags);
71695:     if (!fp)
71695:         return false;
71695: 
71695:     /* Initialize frame, locals, regs. */
89722:     fp->initCallFrame(cx, callee, script, args.length(), flags);
76193: 
76193:     /*
76193:      * N.B. regs may differ from the active registers, if the parent is about
76193:      * to repoint the active registers to regs. See UncachedInlineCall.
76193:      */
71697:     regs.prepareToRun(*fp, script);
71695:     return true;
69223: }
69223: 
73495: JS_ALWAYS_INLINE bool
73495: ContextStack::pushInlineFrame(JSContext *cx, FrameRegs &regs, const CallArgs &args,
83283:                               JSFunction &callee, JSScript *script,
77354:                               InitialFrameFlags initial, Value **stackLimit)
73495: {
83283:     if (!pushInlineFrame(cx, regs, args, callee, script, initial))
73495:         return false;
73495:     *stackLimit = space().conservativeEnd_;
73495:     return true;
73495: }
73495: 
69223: JS_ALWAYS_INLINE StackFrame *
73495: ContextStack::getFixupFrame(JSContext *cx, MaybeReportError report,
73495:                             const CallArgs &args, JSFunction *fun, JSScript *script,
77354:                             void *ncode, InitialFrameFlags initial, Value **stackLimit)
69223: {
71697:     JS_ASSERT(onTop());
83234:     JS_ASSERT(fun->script() == args.callee().toFunction()->script());
71695:     JS_ASSERT(fun->script() == script);
69223: 
89722:     StackFrame::Flags flags = ToFrameFlags(initial);
73495:     StackFrame *fp = getCallFrame(cx, report, args, fun, script, &flags);
71695:     if (!fp)
71695:         return NULL;
69223: 
71695:     /* Do not init late prologue or regs; this is done by jit code. */
89722:     fp->initFixupFrame(cx->fp(), flags, ncode, args.length());
73495: 
73495:     *stackLimit = space().conservativeEnd_;
71695:     return fp;
69223: }
69223: 
69223: JS_ALWAYS_INLINE void
71697: ContextStack::popInlineFrame(FrameRegs &regs)
69223: {
71697:     JS_ASSERT(onTop());
71697:     JS_ASSERT(&regs == &seg_->regs());
69223: 
71697:     StackFrame *fp = regs.fp();
77884:     fp->functionEpilogue();
69223: 
69223:     Value *newsp = fp->actualArgs() - 1;
69223:     JS_ASSERT(newsp >= fp->prev()->base());
69223: 
69223:     newsp[-1] = fp->returnValue();
71697:     regs.popFrame(newsp);
69223: }
69223: 
71697: inline void
71697: ContextStack::popFrameAfterOverflow()
69223: {
71697:     /* Restore the regs to what they were on entry to JSOP_CALL. */
71697:     FrameRegs &regs = seg_->regs();
71697:     StackFrame *fp = regs.fp();
71697:     regs.popFrame(fp->actualArgsEnd());
69223: }
69223: 
76193: inline JSScript *
76193: ContextStack::currentScript(jsbytecode **ppc) const
76193: {
76193:     if (ppc)
76193:         *ppc = NULL;
76193: 
76193:     FrameRegs *regs = maybeRegs();
76193:     StackFrame *fp = regs ? regs->fp() : NULL;
76193:     while (fp && fp->isDummyFrame())
76193:         fp = fp->prev();
76193:     if (!fp)
76193:         return NULL;
76193: 
76193: #ifdef JS_METHODJIT
76193:     mjit::CallSite *inlined = regs->inlined();
76193:     if (inlined) {
87654:         mjit::JITChunk *chunk = fp->jit()->chunk(regs->pc);
87654:         JS_ASSERT(inlined->inlineIndex < chunk->nInlineFrames);
87654:         mjit::InlineFrame *frame = &chunk->inlineFrames()[inlined->inlineIndex];
76193:         JSScript *script = frame->fun->script();
77659:         if (script->compartment() != cx_->compartment)
76193:             return NULL;
76193:         if (ppc)
76193:             *ppc = script->code + inlined->pcOffset;
76193:         return script;
76193:     }
76193: #endif
76193: 
76193:     JSScript *script = fp->script();
77659:     if (script->compartment() != cx_->compartment)
76193:         return NULL;
76193: 
82642:     if (ppc)
76193:         *ppc = fp->pcQuadratic(*this);
76193:     return script;
76193: }
76193: 
94611: inline JSScript *
94611: ContextStack::currentScriptWithDiagnostics(jsbytecode **ppc) const
94611: {
94611:     if (ppc)
94611:         *ppc = NULL;
94611: 
94611:     FrameRegs *regs = maybeRegs();
94611:     StackFrame *fp = regs ? regs->fp() : NULL;
94611:     while (fp && fp->isDummyFrame())
94611:         fp = fp->prev();
94611:     if (!fp)
94611:         *(int *) 0x10 = 0;
94611: 
94611: #ifdef JS_METHODJIT
94611:     mjit::CallSite *inlined = regs->inlined();
94611:     if (inlined) {
94611:         mjit::JITChunk *chunk = fp->jit()->chunk(regs->pc);
94611:         JS_ASSERT(inlined->inlineIndex < chunk->nInlineFrames);
94611:         mjit::InlineFrame *frame = &chunk->inlineFrames()[inlined->inlineIndex];
94611:         JSScript *script = frame->fun->script();
94611:         if (script->compartment() != cx_->compartment)
94611:             *(int *) 0x20 = 0;
94611:         if (ppc)
94611:             *ppc = script->code + inlined->pcOffset;
94611:         return script;
94611:     }
94611: #endif
94611: 
94611:     JSScript *script = fp->script();
94611:     if (script->compartment() != cx_->compartment)
94611:         *(int *) 0x30 = 0;
94611: 
94611:     if (ppc)
94611:         *ppc = fp->pcQuadratic(*this);
94611:     if (!script)
94611:         *(int *) 0x40 = 0;
94611:     return script;
94611: }
94611: 
76193: inline JSObject *
76193: ContextStack::currentScriptedScopeChain() const
76193: {
76193:     return &fp()->scopeChain();
76193: }
76193: 
69223: } /* namespace js */
69223: #endif /* Stack_inl_h__ */
