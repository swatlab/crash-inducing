    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=80: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Pierre Phaneuf <pp@ludusdesign.com>
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: #include "nsCOMPtr.h"
    1: #include "nsTableFrame.h"
68481: #include "nsRenderingContext.h"
    1: #include "nsStyleContext.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsIContent.h"
    1: #include "nsCellMap.h"
    1: #include "nsTableCellFrame.h"
    1: #include "nsHTMLParts.h"
    1: #include "nsTableColFrame.h"
    1: #include "nsTableColGroupFrame.h"
    1: #include "nsTableRowFrame.h"
    1: #include "nsTableRowGroupFrame.h"
    1: #include "nsTableOuterFrame.h"
    1: #include "nsTablePainter.h"
    1: 
    1: #include "BasicTableLayoutStrategy.h"
    1: #include "FixedTableLayoutStrategy.h"
    1: 
    1: #include "nsPresContext.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsCSSAnonBoxes.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMHTMLBodyElement.h"
    1: #include "nsFrameManager.h"
    1: #include "nsCSSRendering.h"
    1: #include "nsLayoutErrors.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsCSSFrameConstructor.h"
    1: #include "nsStyleSet.h"
    1: #include "nsDisplayList.h"
35706: #include "nsIScrollableFrame.h"
40181: #include "nsCSSProps.h"
    1: 
39965: using namespace mozilla;
39965: 
    1: /********************************************************************************
    1:  ** nsTableReflowState                                                         **
    1:  ********************************************************************************/
    1: 
    1: struct nsTableReflowState {
    1: 
    1:   // the real reflow state
    1:   const nsHTMLReflowState& reflowState;
    1: 
    1:   // The table's available size
    1:   nsSize availSize;
    1: 
    1:   // Stationary x-offset
    1:   nscoord x;
    1: 
    1:   // Running y-offset
    1:   nscoord y;
    1: 
    1:   nsTableReflowState(nsPresContext&           aPresContext,
    1:                      const nsHTMLReflowState& aReflowState,
    1:                      nsTableFrame&            aTableFrame,
    1:                      nscoord                  aAvailWidth,
    1:                      nscoord                  aAvailHeight)
    1:     : reflowState(aReflowState)
    1:   {
    1:     Init(aPresContext, aTableFrame, aAvailWidth, aAvailHeight);
    1:   }
    1: 
    1:   void Init(nsPresContext&  aPresContext,
    1:             nsTableFrame&   aTableFrame,
    1:             nscoord         aAvailWidth,
    1:             nscoord         aAvailHeight)
    1:   {
    1:     nsTableFrame* table = (nsTableFrame*)aTableFrame.GetFirstInFlow();
    1:     nsMargin borderPadding = table->GetChildAreaOffset(&reflowState);
    1:     nscoord cellSpacingX = table->GetCellSpacingX();
    1: 
    1:     x = borderPadding.left + cellSpacingX;
    1:     y = borderPadding.top; //cellspacing added during reflow
    1: 
    1:     availSize.width  = aAvailWidth;
    1:     if (NS_UNCONSTRAINEDSIZE != availSize.width) {
    1:       availSize.width -= borderPadding.left + borderPadding.right
    1:                          + (2 * cellSpacingX);
32531:       availSize.width = NS_MAX(0, availSize.width);
    1:     }
    1: 
    1:     availSize.height = aAvailHeight;
    1:     if (NS_UNCONSTRAINEDSIZE != availSize.height) {
    1:       availSize.height -= borderPadding.top + borderPadding.bottom
    1:                           + (2 * table->GetCellSpacingY());
32531:       availSize.height = NS_MAX(0, availSize.height);
    1:     }
    1:   }
    1: 
    1:   nsTableReflowState(nsPresContext&           aPresContext,
    1:                      const nsHTMLReflowState& aReflowState,
    1:                      nsTableFrame&            aTableFrame)
    1:     : reflowState(aReflowState)
    1:   {
    1:     Init(aPresContext, aTableFrame, aReflowState.availableWidth, aReflowState.availableHeight);
    1:   }
    1: 
    1: };
    1: 
    1: /********************************************************************************
    1:  ** nsTableFrame                                                               **
    1:  ********************************************************************************/
    1: 
    1: struct BCPropertyData
    1: {
24768:   BCPropertyData() { mDamageArea.x = mDamageArea.y = mDamageArea.width =
24768:                      mDamageArea.height = mTopBorderWidth = mRightBorderWidth =
24768:                      mBottomBorderWidth = mLeftBorderWidth =
24768:                      mLeftCellBorderWidth = mRightCellBorderWidth = 0; }
    1:   nsRect  mDamageArea;
    1:   BCPixelSize mTopBorderWidth;
    1:   BCPixelSize mRightBorderWidth;
    1:   BCPixelSize mBottomBorderWidth;
    1:   BCPixelSize mLeftBorderWidth;
24768:   BCPixelSize mLeftCellBorderWidth;
24768:   BCPixelSize mRightCellBorderWidth;
    1: };
    1: 
    1: NS_IMETHODIMP
    1: nsTableFrame::GetParentStyleContextFrame(nsPresContext*  aPresContext,
    1:                                          nsIFrame**      aProviderFrame,
    1:                                          PRBool*         aIsChild)
    1: {
    1:   // Since our parent, the table outer frame, returned this frame, we
    1:   // must return whatever our parent would normally have returned.
    1: 
    1:   NS_PRECONDITION(mParent, "table constructed without outer table");
34387:   if (!mContent->GetParent() && !GetStyleContext()->GetPseudo()) {
 1270:     // We're the root.  We have no style context parent.
 1270:     *aIsChild = PR_FALSE;
 1270:     *aProviderFrame = nsnull;
 1270:     return NS_OK;
 1270:   }
 1270: 
 3233:   return static_cast<nsFrame*>(mParent)->
    1:           DoGetParentStyleContextFrame(aPresContext, aProviderFrame, aIsChild);
    1: }
    1: 
    1: 
    1: nsIAtom*
    1: nsTableFrame::GetType() const
    1: {
    1:   return nsGkAtoms::tableFrame;
    1: }
    1: 
    1: 
    1: nsTableFrame::nsTableFrame(nsStyleContext* aContext)
    1:   : nsHTMLContainerFrame(aContext),
    1:     mCellMap(nsnull),
    1:     mTableLayoutStrategy(nsnull)
    1: {
    1:   mBits.mHaveReflowedColGroups  = PR_FALSE;
    1:   mBits.mCellSpansPctCol        = PR_FALSE;
    1:   mBits.mNeedToCalcBCBorders    = PR_FALSE;
    1:   mBits.mIsBorderCollapse       = PR_FALSE;
    1:   mBits.mResizedColumns         = PR_FALSE; // only really matters if splitting
    1:   mBits.mGeometryDirty          = PR_FALSE;
    1: }
    1: 
23554: NS_QUERYFRAME_HEAD(nsTableFrame)
23554:   NS_QUERYFRAME_ENTRY(nsITableLayout)
23554: NS_QUERYFRAME_TAIL_INHERITING(nsHTMLContainerFrame)
    1: 
    1: NS_IMETHODIMP
    1: nsTableFrame::Init(nsIContent*      aContent,
    1:                    nsIFrame*        aParent,
    1:                    nsIFrame*        aPrevInFlow)
    1: {
    1:   nsresult  rv;
    1: 
    1:   // Let the base class do its processing
    1:   rv = nsHTMLContainerFrame::Init(aContent, aParent, aPrevInFlow);
    1: 
    1:   // see if border collapse is on, if so set it
    1:   const nsStyleTableBorder* tableStyle = GetStyleTableBorder();
    1:   PRBool borderCollapse = (NS_STYLE_BORDER_COLLAPSE == tableStyle->mBorderCollapse);
    1:   SetBorderCollapse(borderCollapse);
    1:   // Create the cell map
    1:   if (!aPrevInFlow) {
    1:     mCellMap = new nsTableCellMap(*this, borderCollapse);
    1:     if (!mCellMap)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   } else {
    1:     mCellMap = nsnull;
    1:   }
    1: 
    1:   if (aPrevInFlow) {
    1:     // set my width, because all frames in a table flow are the same width and
    1:     // code in nsTableOuterFrame depends on this being set
    1:     mRect.width = aPrevInFlow->GetSize().width;
    1:   }
    1:   else {
    1:     NS_ASSERTION(!mTableLayoutStrategy, "strategy was created before Init was called");
    1:     // create the strategy
    1:     if (IsAutoLayout())
    1:       mTableLayoutStrategy = new BasicTableLayoutStrategy(this);
    1:     else
    1:       mTableLayoutStrategy = new FixedTableLayoutStrategy(this);
    1:     if (!mTableLayoutStrategy)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: nsTableFrame::~nsTableFrame()
    1: {
    1:   if (nsnull!=mCellMap) {
    1:     delete mCellMap;
    1:     mCellMap = nsnull;
    1:   }
    1: 
    1:   if (nsnull!=mTableLayoutStrategy) {
    1:     delete mTableLayoutStrategy;
    1:     mTableLayoutStrategy = nsnull;
    1:   }
    1: }
    1: 
    1: void
36647: nsTableFrame::DestroyFrom(nsIFrame* aDestructRoot)
36647: {
36647:   mColGroups.DestroyFramesFrom(aDestructRoot);
36647:   nsHTMLContainerFrame::DestroyFrom(aDestructRoot);
    1: }
    1: 
    1: // Make sure any views are positioned properly
    1: void
    1: nsTableFrame::RePositionViews(nsIFrame* aFrame)
    1: {
    1:   nsContainerFrame::PositionFrameView(aFrame);
    1:   nsContainerFrame::PositionChildViews(aFrame);
    1: }
    1: 
    1: static PRBool
    1: IsRepeatedFrame(nsIFrame* kidFrame)
    1: {
    1:   return (kidFrame->GetType() == nsGkAtoms::tableRowFrame ||
    1:           kidFrame->GetType() == nsGkAtoms::tableRowGroupFrame) &&
    1:          (kidFrame->GetStateBits() & NS_REPEATED_ROW_OR_ROWGROUP);
    1: }
    1: 
    1: PRBool
42270: nsTableFrame::PageBreakAfter(nsIFrame* aSourceFrame,
    1:                              nsIFrame* aNextFrame)
    1: {
42270:   const nsStyleDisplay* display = aSourceFrame->GetStyleDisplay();
42270:   nsTableRowGroupFrame* prevRg = do_QueryFrame(aSourceFrame);
    1:   // don't allow a page break after a repeated element ...
42878:   if ((display->mBreakAfter || (prevRg && prevRg->HasInternalBreakAfter())) &&
42270:       !IsRepeatedFrame(aSourceFrame)) {
    1:     return !(aNextFrame && IsRepeatedFrame(aNextFrame)); // or before
    1:   }
    1: 
    1:   if (aNextFrame) {
    1:     display = aNextFrame->GetStyleDisplay();
    1:     // don't allow a page break before a repeated element ...
42270:      nsTableRowGroupFrame* nextRg = do_QueryFrame(aNextFrame);
42878:     if ((display->mBreakBefore ||
42878:         (nextRg && nextRg->HasInternalBreakBefore())) &&
42270:         !IsRepeatedFrame(aNextFrame)) {
42270:       return !IsRepeatedFrame(aSourceFrame); // or after
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: // XXX this needs to be cleaned up so that the frame constructor breaks out col group
    1: // frames into a separate child list, bug 343048.
    1: NS_IMETHODIMP
    1: nsTableFrame::SetInitialChildList(nsIAtom*        aListName,
30790:                                   nsFrameList&    aChildList)
    1: {
    1: 
    1:   if (!mFrames.IsEmpty() || !mColGroups.IsEmpty()) {
    1:     // We already have child frames which means we've already been
    1:     // initialized
    1:     NS_NOTREACHED("unexpected second call to SetInitialChildList");
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1:   if (aListName) {
    1:     // All we know about is the unnamed principal child list
    1:     NS_NOTREACHED("unknown frame list");
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
30790:   // XXXbz the below code is an icky cesspit that's only needed in its current
30790:   // form for two reasons:
30790:   // 1) Both rowgroups and column groups come in on the principal child list.
32843:   while (aChildList.NotEmpty()) {
30790:     nsIFrame* childFrame = aChildList.FirstChild();
32843:     aChildList.RemoveFirstChild();
    1:     const nsStyleDisplay* childDisplay = childFrame->GetStyleDisplay();
30790: 
32843:     if (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == childDisplay->mDisplay) {
    1:       NS_ASSERTION(nsGkAtoms::tableColGroupFrame == childFrame->GetType(),
    1:                    "This is not a colgroup");
32843:       mColGroups.AppendFrame(nsnull, childFrame);
32843:     }
32843:     else { // row groups and unknown frames go on the main list for now
32843:       mFrames.AppendFrame(nsnull, childFrame);
    1:     }
30790:   }
    1: 
    1:   // If we have a prev-in-flow, then we're a table that has been split and
    1:   // so don't treat this like an append
    1:   if (!GetPrevInFlow()) {
    1:     // process col groups first so that real cols get constructed before
    1:     // anonymous ones due to cells in rows.
30941:     InsertColGroups(0, mColGroups);
30941:     InsertRowGroups(mFrames);
16346:     // calc collapsing borders
16346:     if (IsBorderCollapse()) {
    1:       nsRect damageArea(0, 0, GetColCount(), GetRowCount());
    1:       SetBCDamageArea(damageArea);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ PRBool
    1: nsTableFrame::IsContainingBlock() const
    1: {
    1:   return PR_TRUE;
    1: }
    1: 
    1: void nsTableFrame::AttributeChangedFor(nsIFrame*       aFrame,
    1:                                        nsIContent*     aContent,
    1:                                        nsIAtom*        aAttribute)
    1: {
26583:   nsTableCellFrame *cellFrame = do_QueryFrame(aFrame);
26583:   if (cellFrame) {
    1:     if ((nsGkAtoms::rowspan == aAttribute) ||
    1:         (nsGkAtoms::colspan == aAttribute)) {
    1:       nsTableCellMap* cellMap = GetCellMap();
    1:       if (cellMap) {
    1:         // for now just remove the cell from the map and reinsert it
    1:         PRInt32 rowIndex, colIndex;
    1:         cellFrame->GetRowIndex(rowIndex);
    1:         cellFrame->GetColIndex(colIndex);
    1:         RemoveCell(cellFrame, rowIndex);
24724:         nsAutoTArray<nsTableCellFrame*, 1> cells;
    1:         cells.AppendElement(cellFrame);
    1:         InsertCells(cells, rowIndex, colIndex - 1);
    1: 
    1:         // XXX Should this use eStyleChange?  It currently doesn't need
    1:         // to, but it might given more optimization.
 1158:         PresContext()->PresShell()->
 1158:           FrameNeedsReflow(this, nsIPresShell::eTreeChange, NS_FRAME_IS_DIRTY);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: /* ****** CellMap methods ******* */
    1: 
    1: /* return the effective col count */
    1: PRInt32 nsTableFrame::GetEffectiveColCount() const
    1: {
    1:   PRInt32 colCount = GetColCount();
19643:   if (LayoutStrategy()->GetType() == nsITableLayoutStrategy::Auto) {
19643:     nsTableCellMap* cellMap = GetCellMap();
19643:     if (!cellMap) {
19643:       return 0;
19643:     }
    1:     // don't count cols at the end that don't have originating cells
    1:     for (PRInt32 colX = colCount - 1; colX >= 0; colX--) {
19643:       if (cellMap->GetNumCellsOriginatingInCol(colX) > 0) {
19643:         break;
19643:       }
    1:       colCount--;
    1:     }
    1:   }
    1:   return colCount;
    1: }
    1: 
    1: PRInt32 nsTableFrame::GetIndexOfLastRealCol()
    1: {
24724:   PRInt32 numCols = mColFrames.Length();
    1:   if (numCols > 0) {
    1:     for (PRInt32 colX = numCols - 1; colX >= 0; colX--) {
    1:       nsTableColFrame* colFrame = GetColFrame(colX);
    1:       if (colFrame) {
    1:         if (eColAnonymousCell != colFrame->GetColType()) {
    1:           return colX;
    1:         }
    1:       }
    1:     }
    1:   }
    1:   return -1;
    1: }
    1: 
    1: nsTableColFrame*
    1: nsTableFrame::GetColFrame(PRInt32 aColIndex) const
    1: {
    1:   NS_ASSERTION(!GetPrevInFlow(), "GetColFrame called on next in flow");
24724:   PRInt32 numCols = mColFrames.Length();
    1:   if ((aColIndex >= 0) && (aColIndex < numCols)) {
24724:     return mColFrames.ElementAt(aColIndex);
    1:   }
    1:   else {
    1:     NS_ERROR("invalid col index");
    1:     return nsnull;
    1:   }
    1: }
    1: 
    1: PRInt32 nsTableFrame::GetEffectiveRowSpan(PRInt32                 aRowIndex,
    1:                                           const nsTableCellFrame& aCell) const
    1: {
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   NS_PRECONDITION (nsnull != cellMap, "bad call, cellMap not yet allocated.");
    1: 
    1:   PRInt32 colIndex;
    1:   aCell.GetColIndex(colIndex);
    1:   return cellMap->GetEffectiveRowSpan(aRowIndex, colIndex);
    1: }
    1: 
    1: PRInt32 nsTableFrame::GetEffectiveRowSpan(const nsTableCellFrame& aCell,
    1:                                           nsCellMap*              aCellMap)
    1: {
    1:   nsTableCellMap* tableCellMap = GetCellMap(); if (!tableCellMap) ABORT1(1);
    1: 
    1:   PRInt32 colIndex, rowIndex;
    1:   aCell.GetColIndex(colIndex);
    1:   aCell.GetRowIndex(rowIndex);
    1: 
    1:   if (aCellMap)
    1:     return aCellMap->GetRowSpan(rowIndex, colIndex, PR_TRUE);
    1:   else
    1:     return tableCellMap->GetEffectiveRowSpan(rowIndex, colIndex);
    1: }
    1: 
    1: PRInt32 nsTableFrame::GetEffectiveColSpan(const nsTableCellFrame& aCell,
    1:                                           nsCellMap*              aCellMap) const
    1: {
    1:   nsTableCellMap* tableCellMap = GetCellMap(); if (!tableCellMap) ABORT1(1);
    1: 
    1:   PRInt32 colIndex, rowIndex;
    1:   aCell.GetColIndex(colIndex);
    1:   aCell.GetRowIndex(rowIndex);
    1:   PRBool ignore;
    1: 
    1:   if (aCellMap)
    1:     return aCellMap->GetEffectiveColSpan(*tableCellMap, rowIndex, colIndex, ignore);
    1:   else
    1:     return tableCellMap->GetEffectiveColSpan(rowIndex, colIndex);
    1: }
    1: 
    1: PRBool nsTableFrame::HasMoreThanOneCell(PRInt32 aRowIndex) const
    1: {
    1:   nsTableCellMap* tableCellMap = GetCellMap(); if (!tableCellMap) ABORT1(1);
    1:   return tableCellMap->HasMoreThanOneCell(aRowIndex);
    1: }
    1: 
    1: void nsTableFrame::AdjustRowIndices(PRInt32         aRowIndex,
    1:                                     PRInt32         aAdjustment)
    1: {
    1:   // Iterate over the row groups and adjust the row indices of all rows
    1:   // whose index is >= aRowIndex.
 2141:   RowGroupArray rowGroups;
 2141:   OrderRowGroups(rowGroups);
 2141: 
 2141:   for (PRUint32 rgX = 0; rgX < rowGroups.Length(); rgX++) {
 2141:     rowGroups[rgX]->AdjustRowIndices(aRowIndex, aAdjustment);
    1:   }
    1: }
    1: 
    1: 
30941: void nsTableFrame::ResetRowIndices(const nsFrameList::Slice& aRowGroupsToExclude)
    1: {
    1:   // Iterate over the row groups and adjust the row indices of all rows
    1:   // omit the rowgroups that will be inserted later
 2141:   RowGroupArray rowGroups;
 2141:   OrderRowGroups(rowGroups);
    1: 
    1:   PRInt32 rowIndex = 0;
37262:   nsTHashtable<nsPtrHashKey<nsTableRowGroupFrame> > excludeRowGroups;
37262:   if (!excludeRowGroups.Init()) {
37262:     NS_ERROR("Failed to initialize excludeRowGroups hash.");
37262:     return;
37262:   }
30941:   nsFrameList::Enumerator excludeRowGroupsEnumerator(aRowGroupsToExclude);
37262:   while (!excludeRowGroupsEnumerator.AtEnd()) {
37262:     excludeRowGroups.PutEntry(static_cast<nsTableRowGroupFrame*>(excludeRowGroupsEnumerator.get()));
30941:     excludeRowGroupsEnumerator.Next();
    1:   }
    1: 
 2141:   for (PRUint32 rgX = 0; rgX < rowGroups.Length(); rgX++) {
 2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
37262:     if (!excludeRowGroups.GetEntry(rgFrame)) {
30941:       const nsFrameList& rowFrames = rgFrame->GetChildList(nsnull);
30941:       for (nsFrameList::Enumerator rows(rowFrames); !rows.AtEnd(); rows.Next()) {
30941:         if (NS_STYLE_DISPLAY_TABLE_ROW==rows.get()->GetStyleDisplay()->mDisplay) {
30941:           ((nsTableRowFrame *)rows.get())->SetRowIndex(rowIndex);
    1:           rowIndex++;
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: void nsTableFrame::InsertColGroups(PRInt32                   aStartColIndex,
30941:                                    const nsFrameList::Slice& aColGroups)
    1: {
    1:   PRInt32 colIndex = aStartColIndex;
30941:   nsFrameList::Enumerator colGroups(aColGroups);
30941:   for (; !colGroups.AtEnd(); colGroups.Next()) {
30941:     nsTableColGroupFrame* cgFrame =
30941:       static_cast<nsTableColGroupFrame*>(colGroups.get());
    1:     cgFrame->SetStartColumnIndex(colIndex);
30941:     // XXXbz this sucks.  AddColsToTable will actually remove colgroups from
30941:     // the list we're traversing!  Need to fix things here.  :( I guess this is
30941:     // why the old code used pointer-to-last-frame as opposed to
30941:     // pointer-to-frame-after-last....
30941: 
30941:     // How about dealing with this by storing a const reference to the
30941:     // mNextSibling of the framelist's last frame, instead of storing a pointer
30941:     // to the first-after-next frame?  Will involve making nsFrameList friend
30941:     // of nsIFrame, but it's time for that anyway.
30941:     cgFrame->AddColsToTable(colIndex, PR_FALSE,
30941:                               colGroups.get()->GetChildList(nsnull));
    1:     PRInt32 numCols = cgFrame->GetColCount();
    1:     colIndex += numCols;
    1:   }
30941: 
30941:   nsFrameList::Enumerator remainingColgroups = colGroups.GetUnlimitedEnumerator();
30941:   if (!remainingColgroups.AtEnd()) {
30941:     nsTableColGroupFrame::ResetColIndices(
30941:       static_cast<nsTableColGroupFrame*>(remainingColgroups.get()), colIndex);
    1:   }
    1: }
    1: 
    1: void nsTableFrame::InsertCol(nsTableColFrame& aColFrame,
    1:                              PRInt32          aColIndex)
    1: {
24724:   mColFrames.InsertElementAt(aColIndex, &aColFrame);
    1:   nsTableColType insertedColType = aColFrame.GetColType();
24724:   PRInt32 numCacheCols = mColFrames.Length();
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   if (cellMap) {
    1:     PRInt32 numMapCols = cellMap->GetColCount();
    1:     if (numCacheCols > numMapCols) {
    1:       PRBool removedFromCache = PR_FALSE;
    1:       if (eColAnonymousCell != insertedColType) {
24724:         nsTableColFrame* lastCol = mColFrames.ElementAt(numCacheCols - 1);
    1:         if (lastCol) {
    1:           nsTableColType lastColType = lastCol->GetColType();
    1:           if (eColAnonymousCell == lastColType) {
    1:             // remove the col from the cache
    1:             mColFrames.RemoveElementAt(numCacheCols - 1);
    1:             // remove the col from the eColGroupAnonymousCell col group
    1:             nsTableColGroupFrame* lastColGroup = (nsTableColGroupFrame *)mColGroups.LastChild();
    1:             if (lastColGroup) {
    1:               lastColGroup->RemoveChild(*lastCol, PR_FALSE);
62632: 
    1:               // remove the col group if it is empty
    1:               if (lastColGroup->GetColCount() <= 0) {
    1:                 mColGroups.DestroyFrame((nsIFrame*)lastColGroup);
    1:               }
62632:             }
    1:             removedFromCache = PR_TRUE;
    1:           }
    1:         }
    1:       }
    1:       if (!removedFromCache) {
    1:         cellMap->AddColsAtEnd(1);
    1:       }
    1:     }
    1:   }
    1:   // for now, just bail and recalc all of the collapsing borders
    1:   if (IsBorderCollapse()) {
32531:     nsRect damageArea(0, 0, NS_MAX(1, GetColCount()), NS_MAX(1, GetRowCount()));
    1:     SetBCDamageArea(damageArea);
    1:   }
    1: }
    1: 
    1: void nsTableFrame::RemoveCol(nsTableColGroupFrame* aColGroupFrame,
    1:                              PRInt32               aColIndex,
    1:                              PRBool                aRemoveFromCache,
    1:                              PRBool                aRemoveFromCellMap)
    1: {
    1:   if (aRemoveFromCache) {
    1:     mColFrames.RemoveElementAt(aColIndex);
    1:   }
    1:   if (aRemoveFromCellMap) {
    1:     nsTableCellMap* cellMap = GetCellMap();
    1:     if (cellMap) {
30207:       AppendAnonymousColFrames(1);
    1:     }
    1:   }
    1:   // for now, just bail and recalc all of the collapsing borders
    1:   if (IsBorderCollapse()) {
    1:     nsRect damageArea(0, 0, GetColCount(), GetRowCount());
    1:     SetBCDamageArea(damageArea);
    1:   }
    1: }
    1: 
    1: /** Get the cell map for this table frame.  It is not always mCellMap.
    1:   * Only the firstInFlow has a legit cell map
    1:   */
    1: nsTableCellMap* nsTableFrame::GetCellMap() const
    1: {
    1:   nsTableFrame* firstInFlow = (nsTableFrame *)GetFirstInFlow();
    1:   return firstInFlow->mCellMap;
    1: }
    1: 
    1: // XXX this needs to be moved to nsCSSFrameConstructor
    1: nsTableColGroupFrame*
    1: nsTableFrame::CreateAnonymousColGroupFrame(nsTableColGroupType aColGroupType)
    1: {
    1:   nsIContent* colGroupContent = GetContent();
  238:   nsPresContext* presContext = PresContext();
    1:   nsIPresShell *shell = presContext->PresShell();
    1: 
    1:   nsRefPtr<nsStyleContext> colGroupStyle;
35554:   colGroupStyle = shell->StyleSet()->
35554:     ResolveAnonymousBoxStyle(nsCSSAnonBoxes::tableColGroup, mStyleContext);
    1:   // Create a col group frame
    1:   nsIFrame* newFrame = NS_NewTableColGroupFrame(shell, colGroupStyle);
    1:   if (newFrame) {
    1:     ((nsTableColGroupFrame *)newFrame)->SetColType(aColGroupType);
    1:     newFrame->Init(colGroupContent, this, nsnull);
    1:   }
    1:   return (nsTableColGroupFrame *)newFrame;
    1: }
    1: 
    1: void
30207: nsTableFrame::AppendAnonymousColFrames(PRInt32 aNumColsToAdd)
30207: {
    1:   // get the last col group frame
30786:   nsTableColGroupFrame* colGroupFrame =
30786:     static_cast<nsTableColGroupFrame*>(mColGroups.LastChild());
30786: 
30786:   if (!colGroupFrame ||
30786:       (colGroupFrame->GetColType() != eColGroupAnonymousCell)) {
30207:     PRInt32 colIndex = (colGroupFrame) ?
30207:                         colGroupFrame->GetStartColumnIndex() +
30207:                         colGroupFrame->GetColCount() : 0;
30207:     colGroupFrame = CreateAnonymousColGroupFrame(eColGroupAnonymousCell);
    1:     if (!colGroupFrame) {
    1:       return;
    1:     }
30207:     // add the new frame to the child list
30207:     mColGroups.AppendFrame(this, colGroupFrame);
    1:     colGroupFrame->SetStartColumnIndex(colIndex);
    1:   }
30786:   AppendAnonymousColFrames(colGroupFrame, aNumColsToAdd, eColAnonymousCell,
30786:                            PR_TRUE);
30207: 
    1: }
    1: 
    1: // XXX this needs to be moved to nsCSSFrameConstructor
    1: // Right now it only creates the col frames at the end
    1: void
30786: nsTableFrame::AppendAnonymousColFrames(nsTableColGroupFrame* aColGroupFrame,
    1:                                        PRInt32               aNumColsToAdd,
    1:                                        nsTableColType        aColType,
30786:                                        PRBool                aAddToTable)
    1: {
    1:   NS_PRECONDITION(aColGroupFrame, "null frame");
 8770:   NS_PRECONDITION(aColType != eColAnonymousCol, "Shouldn't happen");
 8770: 
30786:   nsIPresShell *shell = PresContext()->PresShell();
    1: 
    1:   // Get the last col frame
32843:   nsFrameList newColFrames;
    1: 
24724:   PRInt32 startIndex = mColFrames.Length();
    1:   PRInt32 lastIndex  = startIndex + aNumColsToAdd - 1;
    1: 
    1:   for (PRInt32 childX = startIndex; childX <= lastIndex; childX++) {
    1:     nsIContent* iContent;
    1:     nsRefPtr<nsStyleContext> styleContext;
    1:     nsStyleContext* parentStyleContext;
    1: 
 8770:     // all anonymous cols that we create here use a pseudo style context of the
 8770:     // col group
    1:     iContent = aColGroupFrame->GetContent();
    1:     parentStyleContext = aColGroupFrame->GetStyleContext();
35554:     styleContext = shell->StyleSet()->
35554:       ResolveAnonymousBoxStyle(nsCSSAnonBoxes::tableCol, parentStyleContext);
    1:     // ASSERTION to check for bug 54454 sneaking back in...
    1:     NS_ASSERTION(iContent, "null content in CreateAnonymousColFrames");
    1: 
    1:     // create the new col frame
    1:     nsIFrame* colFrame = NS_NewTableColFrame(shell, styleContext);
    1:     ((nsTableColFrame *) colFrame)->SetColType(aColType);
    1:     colFrame->Init(iContent, aColGroupFrame, nsnull);
30786: 
32843:     newColFrames.AppendFrame(nsnull, colFrame);
30786:   }
30786:   nsFrameList& cols = aColGroupFrame->GetWritableChildList();
30786:   nsIFrame* oldLastCol = cols.LastChild();
30941:   const nsFrameList::Slice& newCols =
30786:     cols.InsertFrames(nsnull, oldLastCol, newColFrames);
30786:   if (aAddToTable) {
    1:     // get the starting col index in the cache
30786:     PRInt32 startColIndex;
30786:     if (oldLastCol) {
30786:       startColIndex =
30786:         static_cast<nsTableColFrame*>(oldLastCol)->GetColIndex() + 1;
30786:     } else {
30786:       startColIndex = aColGroupFrame->GetStartColumnIndex();
30786:     }
30786: 
30941:     aColGroupFrame->AddColsToTable(startColIndex, PR_TRUE, newCols);
    1:   }
    1: }
    1: 
    1: void
    1: nsTableFrame::MatchCellMapToColCache(nsTableCellMap* aCellMap)
    1: {
    1:   PRInt32 numColsInMap   = GetColCount();
24724:   PRInt32 numColsInCache = mColFrames.Length();
    1:   PRInt32 numColsToAdd = numColsInMap - numColsInCache;
    1:   if (numColsToAdd > 0) {
    1:     // this sets the child list, updates the col cache and cell map
30207:     AppendAnonymousColFrames(numColsToAdd);
    1:   }
    1:   if (numColsToAdd < 0) {
    1:     PRInt32 numColsNotRemoved = DestroyAnonymousColFrames(-numColsToAdd);
    1:     // if the cell map has fewer cols than the cache, correct it
    1:     if (numColsNotRemoved > 0) {
    1:       aCellMap->AddColsAtEnd(numColsNotRemoved);
    1:     }
    1:   }
    1:   if (numColsToAdd && HasZeroColSpans()) {
    1:     SetNeedColSpanExpansion(PR_TRUE);
    1:   }
    1:   if (NeedColSpanExpansion()) {
    1:     // This flag can be set in two ways -- either by changing
    1:     // the number of columns (that happens in the block above),
    1:     // or by adding a cell with colspan="0" to the cellmap.  To
    1:     // handle the latter case we need to explicitly check the
    1:     // flag here -- it may be set even if the number of columns
    1:     // did not change.
    1:     //
    1:     // @see nsCellMap::AppendCell
    1: 
    1:     aCellMap->ExpandZeroColSpans();
    1:   }
    1: }
    1: 
    1: void
    1: nsTableFrame::DidResizeColumns()
    1: {
    1:   NS_PRECONDITION(!GetPrevInFlow(),
    1:                   "should only be called on first-in-flow");
    1:   if (mBits.mResizedColumns)
    1:     return; // already marked
    1: 
    1:   for (nsTableFrame *f = this; f;
 3233:        f = static_cast<nsTableFrame*>(f->GetNextInFlow()))
    1:     f->mBits.mResizedColumns = PR_TRUE;
    1: }
    1: 
    1: void
    1: nsTableFrame::AppendCell(nsTableCellFrame& aCellFrame,
    1:                          PRInt32           aRowIndex)
    1: {
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   if (cellMap) {
    1:     nsRect damageArea(0,0,0,0);
    1:     cellMap->AppendCell(aCellFrame, aRowIndex, PR_TRUE, damageArea);
    1:     MatchCellMapToColCache(cellMap);
    1:     if (IsBorderCollapse()) {
    1:       SetBCDamageArea(damageArea);
    1:     }
    1:   }
    1: }
    1: 
24724: void nsTableFrame::InsertCells(nsTArray<nsTableCellFrame*>& aCellFrames,
    1:                                PRInt32                      aRowIndex,
    1:                                PRInt32                      aColIndexBefore)
    1: {
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   if (cellMap) {
    1:     nsRect damageArea(0,0,0,0);
    1:     cellMap->InsertCells(aCellFrames, aRowIndex, aColIndexBefore, damageArea);
    1:     MatchCellMapToColCache(cellMap);
    1:     if (IsBorderCollapse()) {
    1:       SetBCDamageArea(damageArea);
    1:     }
    1:   }
    1: }
    1: 
    1: // this removes the frames from the col group and table, but not the cell map
    1: PRInt32
    1: nsTableFrame::DestroyAnonymousColFrames(PRInt32 aNumFrames)
    1: {
    1:   // only remove cols that are of type eTypeAnonymous cell (they are at the end)
24724:   PRInt32 endIndex   = mColFrames.Length() - 1;
    1:   PRInt32 startIndex = (endIndex - aNumFrames) + 1;
    1:   PRInt32 numColsRemoved = 0;
    1:   for (PRInt32 colX = endIndex; colX >= startIndex; colX--) {
    1:     nsTableColFrame* colFrame = GetColFrame(colX);
    1:     if (colFrame && (eColAnonymousCell == colFrame->GetColType())) {
    1:       nsTableColGroupFrame* cgFrame =
 3233:         static_cast<nsTableColGroupFrame*>(colFrame->GetParent());
    1:       // remove the frame from the colgroup
    1:       cgFrame->RemoveChild(*colFrame, PR_FALSE);
    1:       // remove the frame from the cache, but not the cell map
    1:       RemoveCol(nsnull, colX, PR_TRUE, PR_FALSE);
    1:       numColsRemoved++;
    1:     }
    1:     else {
    1:       break;
    1:     }
    1:   }
    1:   return (aNumFrames - numColsRemoved);
    1: }
    1: 
    1: void nsTableFrame::RemoveCell(nsTableCellFrame* aCellFrame,
    1:                               PRInt32           aRowIndex)
    1: {
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   if (cellMap) {
    1:     nsRect damageArea(0,0,0,0);
    1:     cellMap->RemoveCell(aCellFrame, aRowIndex, damageArea);
    1:     MatchCellMapToColCache(cellMap);
    1:     if (IsBorderCollapse()) {
    1:       SetBCDamageArea(damageArea);
    1:     }
    1:   }
    1: }
    1: 
    1: PRInt32
37262: nsTableFrame::GetStartRowIndex(nsTableRowGroupFrame* aRowGroupFrame)
    1: {
 2141:   RowGroupArray orderedRowGroups;
 2141:   OrderRowGroups(orderedRowGroups);
    1: 
    1:   PRInt32 rowIndex = 0;
 2141:   for (PRUint32 rgIndex = 0; rgIndex < orderedRowGroups.Length(); rgIndex++) {
 2141:     nsTableRowGroupFrame* rgFrame = orderedRowGroups[rgIndex];
37262:     if (rgFrame == aRowGroupFrame) {
    1:       break;
    1:     }
    1:     PRInt32 numRows = rgFrame->GetRowCount();
    1:     rowIndex += numRows;
    1:   }
    1:   return rowIndex;
    1: }
    1: 
    1: // this cannot extend beyond a single row group
37262: void nsTableFrame::AppendRows(nsTableRowGroupFrame*       aRowGroupFrame,
    1:                               PRInt32                     aRowIndex,
24724:                               nsTArray<nsTableRowFrame*>& aRowFrames)
    1: {
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   if (cellMap) {
    1:     PRInt32 absRowIndex = GetStartRowIndex(aRowGroupFrame) + aRowIndex;
    1:     InsertRows(aRowGroupFrame, aRowFrames, absRowIndex, PR_TRUE);
    1:   }
    1: }
    1: 
    1: // this cannot extend beyond a single row group
    1: PRInt32
37262: nsTableFrame::InsertRows(nsTableRowGroupFrame*       aRowGroupFrame,
24724:                          nsTArray<nsTableRowFrame*>& aRowFrames,
    1:                          PRInt32                     aRowIndex,
    1:                          PRBool                      aConsiderSpans)
    1: {
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   printf("=== insertRowsBefore firstRow=%d \n", aRowIndex);
    1:   Dump(PR_TRUE, PR_FALSE, PR_TRUE);
    1: #endif
    1: 
    1:   PRInt32 numColsToAdd = 0;
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   if (cellMap) {
    1:     nsRect damageArea(0,0,0,0);
    1:     PRInt32 origNumRows = cellMap->GetRowCount();
24724:     PRInt32 numNewRows = aRowFrames.Length();
    1:     cellMap->InsertRows(aRowGroupFrame, aRowFrames, aRowIndex, aConsiderSpans, damageArea);
    1:     MatchCellMapToColCache(cellMap);
    1:     if (aRowIndex < origNumRows) {
    1:       AdjustRowIndices(aRowIndex, numNewRows);
    1:     }
    1:     // assign the correct row indices to the new rows. If they were adjusted above
    1:     // it may not have been done correctly because each row is constructed with index 0
29425:     for (PRInt32 rowY = 0; rowY < numNewRows; rowY++) {
29425:       nsTableRowFrame* rowFrame = aRowFrames.ElementAt(rowY);
29425:       rowFrame->SetRowIndex(aRowIndex + rowY);
    1:     }
    1:     if (IsBorderCollapse()) {
    1:       SetBCDamageArea(damageArea);
    1:     }
    1:   }
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   printf("=== insertRowsAfter \n");
    1:   Dump(PR_TRUE, PR_FALSE, PR_TRUE);
    1: #endif
    1: 
    1:   return numColsToAdd;
    1: }
    1: 
    1: // this cannot extend beyond a single row group
    1: void nsTableFrame::RemoveRows(nsTableRowFrame& aFirstRowFrame,
    1:                               PRInt32          aNumRowsToRemove,
    1:                               PRBool           aConsiderSpans)
    1: {
    1: #ifdef TBD_OPTIMIZATION
    1:   // decide if we need to rebalance. we have to do this here because the row group
    1:   // cannot do it when it gets the dirty reflow corresponding to the frame being destroyed
    1:   PRBool stopTelling = PR_FALSE;
    1:   for (nsIFrame* kidFrame = aFirstFrame.FirstChild(); (kidFrame && !stopAsking);
    1:        kidFrame = kidFrame->GetNextSibling()) {
26583:     nsTableCellFrame *cellFrame = do_QueryFrame(kidFrame);
26583:     if (cellFrame) {
    1:       stopTelling = tableFrame->CellChangedWidth(*cellFrame, cellFrame->GetPass1MaxElementWidth(),
    1:                                                  cellFrame->GetMaximumWidth(), PR_TRUE);
    1:     }
    1:   }
    1:   // XXX need to consider what happens if there are cells that have rowspans
    1:   // into the deleted row. Need to consider moving rows if a rebalance doesn't happen
    1: #endif
    1: 
    1:   PRInt32 firstRowIndex = aFirstRowFrame.GetRowIndex();
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   printf("=== removeRowsBefore firstRow=%d numRows=%d\n", firstRowIndex, aNumRowsToRemove);
    1:   Dump(PR_TRUE, PR_FALSE, PR_TRUE);
    1: #endif
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   if (cellMap) {
    1:     nsRect damageArea(0,0,0,0);
    1:     cellMap->RemoveRows(firstRowIndex, aNumRowsToRemove, aConsiderSpans, damageArea);
    1:     MatchCellMapToColCache(cellMap);
    1:     if (IsBorderCollapse()) {
    1:       SetBCDamageArea(damageArea);
    1:     }
    1:   }
    1:   AdjustRowIndices(firstRowIndex, -aNumRowsToRemove);
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   printf("=== removeRowsAfter\n");
    1:   Dump(PR_TRUE, PR_TRUE, PR_TRUE);
    1: #endif
    1: }
    1: 
    1: // collect the rows ancestors of aFrame
    1: PRInt32
    1: nsTableFrame::CollectRows(nsIFrame*                   aFrame,
24724:                           nsTArray<nsTableRowFrame*>& aCollection)
    1: {
37262:   NS_PRECONDITION(aFrame, "null frame");
    1:   PRInt32 numRows = 0;
37262:   nsIFrame* childFrame = aFrame->GetFirstChild(nsnull);
    1:   while (childFrame) {
37262:     aCollection.AppendElement(static_cast<nsTableRowFrame*>(childFrame));
    1:     numRows++;
    1:     childFrame = childFrame->GetNextSibling();
    1:   }
    1:   return numRows;
    1: }
    1: 
    1: void
30941: nsTableFrame::InsertRowGroups(const nsFrameList::Slice& aRowGroups)
    1: {
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   printf("=== insertRowGroupsBefore\n");
    1:   Dump(PR_TRUE, PR_FALSE, PR_TRUE);
    1: #endif
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   if (cellMap) {
 2141:     RowGroupArray orderedRowGroups;
 2141:     OrderRowGroups(orderedRowGroups);
 2141: 
24724:     nsAutoTArray<nsTableRowFrame*, 8> rows;
    1:     // Loop over the rowgroups and check if some of them are new, if they are
    1:     // insert cellmaps in the order that is predefined by OrderRowGroups,
30941:     // XXXbz this code is O(N*M) where N is number of new rowgroups
30941:     // and M is number of rowgroups we have!
    1:     PRUint32 rgIndex;
 2141:     for (rgIndex = 0; rgIndex < orderedRowGroups.Length(); rgIndex++) {
30941:       for (nsFrameList::Enumerator rowgroups(aRowGroups); !rowgroups.AtEnd();
30941:            rowgroups.Next()) {
37262:         if (orderedRowGroups[rgIndex] == rowgroups.get()) {
 2141:           nsTableRowGroupFrame* priorRG =
 2141:             (0 == rgIndex) ? nsnull : orderedRowGroups[rgIndex - 1];
    1:           // create and add the cell map for the row group
37262:           cellMap->InsertGroupCellMap(orderedRowGroups[rgIndex], priorRG);
    1: 
    1:           break;
    1:         }
    1:       }
    1:     }
    1:     cellMap->Synchronize(this);
30941:     ResetRowIndices(aRowGroups);
    1: 
    1:     //now that the cellmaps are reordered too insert the rows
 2141:     for (rgIndex = 0; rgIndex < orderedRowGroups.Length(); rgIndex++) {
30941:       for (nsFrameList::Enumerator rowgroups(aRowGroups); !rowgroups.AtEnd();
30941:            rowgroups.Next()) {
37262:         if (orderedRowGroups[rgIndex] == rowgroups.get()) {
 2141:           nsTableRowGroupFrame* priorRG =
 2141:             (0 == rgIndex) ? nsnull : orderedRowGroups[rgIndex - 1];
    1:           // collect the new row frames in an array and add them to the table
30941:           PRInt32 numRows = CollectRows(rowgroups.get(), rows);
    1:           if (numRows > 0) {
    1:             PRInt32 rowIndex = 0;
    1:             if (priorRG) {
    1:               PRInt32 priorNumRows = priorRG->GetRowCount();
    1:               rowIndex = priorRG->GetStartRowIndex() + priorNumRows;
    1:             }
37262:             InsertRows(orderedRowGroups[rgIndex], rows, rowIndex, PR_TRUE);
    1:             rows.Clear();
    1:           }
    1:           break;
    1:         }
    1:       }
    1:     }
    1: 
    1:   }
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   printf("=== insertRowGroupsAfter\n");
    1:   Dump(PR_TRUE, PR_TRUE, PR_TRUE);
    1: #endif
    1: }
    1: 
    1: 
    1: /////////////////////////////////////////////////////////////////////////////
    1: // Child frame enumeration
    1: 
30783: nsFrameList
30783: nsTableFrame::GetChildList(nsIAtom* aListName) const
    1: {
    1:   if (aListName == nsGkAtoms::colGroupList) {
30783:     return mColGroups;
30783:   }
30783: 
30783:   return nsHTMLContainerFrame::GetChildList(aListName);
    1: }
    1: 
    1: nsIAtom*
    1: nsTableFrame::GetAdditionalChildListName(PRInt32 aIndex) const
    1: {
    1:   if (aIndex == NS_TABLE_FRAME_COLGROUP_LIST_INDEX) {
    1:     return nsGkAtoms::colGroupList;
    1:   }
    1:   if (aIndex == NS_TABLE_FRAME_OVERFLOW_LIST_INDEX) {
    1:     return nsGkAtoms::overflowList;
    1:   }
72634:   return nsnull;
    1: }
    1: 
13961: nsRect
13961: nsDisplayTableItem::GetBounds(nsDisplayListBuilder* aBuilder) {
55040:   return mFrame->GetVisualOverflowRect() + ToReferenceFrame();
13961: }
13961: 
13961: PRBool
50392: nsDisplayTableItem::IsVaryingRelativeToMovingFrame(nsDisplayListBuilder* aBuilder,
50392:                                                    nsIFrame* aFrame)
13961: {
13961:   if (!mPartHasFixedBackground)
13961:     return PR_FALSE;
13961: 
50392:   // If aFrame is mFrame or an ancestor in this document, and aFrame is
50392:   // not the viewport frame, then moving aFrame will move mFrame
50392:   // relative to the viewport, so our fixed-pos background will change.
50392:   return mFrame == aFrame ||
50392:     nsLayoutUtils::IsProperAncestorFrame(aFrame, mFrame);
13961: }
13961: 
13961: /* static */ void
13961: nsDisplayTableItem::UpdateForFrameBackground(nsIFrame* aFrame)
13961: {
40177:   nsStyleContext *bgSC;
40177:   if (!nsCSSRendering::FindBackground(aFrame->PresContext(), aFrame, &bgSC))
13961:     return;
40177:   if (!bgSC->GetStyleBackground()->HasFixedBackground())
13961:     return;
13961: 
13961:   mPartHasFixedBackground = PR_TRUE;
13961: }
13961: 
13961: class nsDisplayTableBorderBackground : public nsDisplayTableItem {
    1: public:
51260:   nsDisplayTableBorderBackground(nsDisplayListBuilder* aBuilder,
51260:                                  nsTableFrame* aFrame) :
51260:     nsDisplayTableItem(aBuilder, aFrame) {
    1:     MOZ_COUNT_CTOR(nsDisplayTableBorderBackground);
    1:   }
    1: #ifdef NS_BUILD_REFCNT_LOGGING
    1:   virtual ~nsDisplayTableBorderBackground() {
    1:     MOZ_COUNT_DTOR(nsDisplayTableBorderBackground);
    1:   }
    1: #endif
    1: 
33368:   virtual void Paint(nsDisplayListBuilder* aBuilder,
68481:                      nsRenderingContext* aCtx);
47732:   NS_DISPLAY_DECL_NAME("TableBorderBackground", TYPE_TABLE_BORDER_BACKGROUND)
    1: };
    1: 
    1: void
    1: nsDisplayTableBorderBackground::Paint(nsDisplayListBuilder* aBuilder,
68481:                                       nsRenderingContext* aCtx)
    1: {
 3233:   static_cast<nsTableFrame*>(mFrame)->
33368:     PaintTableBorderBackground(*aCtx, mVisibleRect,
51261:                                ToReferenceFrame(),
32425:                                aBuilder->GetBackgroundPaintFlags());
    1: }
    1: 
    1: static PRInt32 GetTablePartRank(nsDisplayItem* aItem)
    1: {
    1:   nsIAtom* type = aItem->GetUnderlyingFrame()->GetType();
    1:   if (type == nsGkAtoms::tableFrame)
    1:     return 0;
    1:   if (type == nsGkAtoms::tableRowGroupFrame)
    1:     return 1;
    1:   if (type == nsGkAtoms::tableRowFrame)
    1:     return 2;
    1:   return 3;
    1: }
    1: 
    1: static PRBool CompareByTablePartRank(nsDisplayItem* aItem1, nsDisplayItem* aItem2,
    1:                                      void* aClosure)
    1: {
    1:   return GetTablePartRank(aItem1) <= GetTablePartRank(aItem2);
    1: }
    1: 
    1: /* static */ nsresult
    1: nsTableFrame::GenericTraversal(nsDisplayListBuilder* aBuilder, nsFrame* aFrame,
    1:                                const nsRect& aDirtyRect, const nsDisplayListSet& aLists)
    1: {
    1:   // This is similar to what nsContainerFrame::BuildDisplayListForNonBlockChildren
    1:   // does, except that we allow the children's background and borders to go
    1:   // in our BorderBackground list. This doesn't really affect background
    1:   // painting --- the children won't actually draw their own backgrounds
    1:   // because the nsTableFrame already drew them, unless a child has its own
    1:   // stacking context, in which case the child won't use its passed-in
    1:   // BorderBackground list anyway. It does affect cell borders though; this
    1:   // lets us get cell borders into the nsTableFrame's BorderBackground list.
    1:   nsIFrame* kid = aFrame->GetFirstChild(nsnull);
    1:   while (kid) {
    1:     nsresult rv = aFrame->BuildDisplayListForChild(aBuilder, kid, aDirtyRect, aLists);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     kid = kid->GetNextSibling();
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: /* static */ nsresult
    1: nsTableFrame::DisplayGenericTablePart(nsDisplayListBuilder* aBuilder,
    1:                                       nsFrame* aFrame,
    1:                                       const nsRect& aDirtyRect,
    1:                                       const nsDisplayListSet& aLists,
13961:                                       nsDisplayTableItem* aDisplayItem,
    1:                                       DisplayGenericTablePartTraversal aTraversal)
    1: {
    1:   nsDisplayList eventsBorderBackground;
    1:   // If we need to sort the event backgrounds, then we'll put descendants'
    1:   // display items into their own set of lists.
13961:   PRBool sortEventBackgrounds = aDisplayItem && aBuilder->IsForEventDelivery();
    1:   nsDisplayListCollection separatedCollection;
    1:   const nsDisplayListSet* lists = sortEventBackgrounds ? &separatedCollection : &aLists;
    1: 
13961:   nsAutoPushCurrentTableItem pushTableItem;
13961:   if (aDisplayItem) {
13961:     pushTableItem.Push(aBuilder, aDisplayItem);
13961:   }
35635: 
35635:   if (aFrame->IsVisibleForPainting(aBuilder)) {
13961:     nsDisplayTableItem* currentItem = aBuilder->GetCurrentTableItem();
35636:     // currentItem may be null, when none of the table parts have a
35636:     // background or border
35636:     if (currentItem) {
13961:       currentItem->UpdateForFrameBackground(aFrame);
35636:     }
13961: 
24818:     // Paint the outset box-shadows for the table frames
35635:     PRBool hasBoxShadow = aFrame->GetStyleBorder()->mBoxShadow != nsnull;
24818:     if (hasBoxShadow) {
51260:       nsresult rv = lists->BorderBackground()->AppendNewToTop(
51260:           new (aBuilder) nsDisplayBoxShadowOuter(aBuilder, aFrame));
22191:       NS_ENSURE_SUCCESS(rv, rv);
22191:     }
22191: 
    1:     // Create dedicated background display items per-frame when we're
    1:     // handling events.
    1:     // XXX how to handle collapsed borders?
35635:     if (aBuilder->IsForEventDelivery()) {
51260:       nsresult rv = lists->BorderBackground()->AppendNewToTop(
51260:           new (aBuilder) nsDisplayBackground(aBuilder, aFrame));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
24818:     // Paint the inset box-shadows for the table frames
24818:     if (hasBoxShadow) {
51260:       nsresult rv = lists->BorderBackground()->AppendNewToTop(
51260:           new (aBuilder) nsDisplayBoxShadowInner(aBuilder, aFrame));
24818:       NS_ENSURE_SUCCESS(rv, rv);
24818:     }
35635:   }
24818: 
    1:   nsresult rv = aTraversal(aBuilder, aFrame, aDirtyRect, *lists);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (sortEventBackgrounds) {
    1:     // Ensure that the table frame event background goes before the
    1:     // table rowgroups event backgrounds, before the table row event backgrounds,
    1:     // before everything else (cells and their blocks)
    1:     separatedCollection.BorderBackground()->Sort(aBuilder, CompareByTablePartRank, nsnull);
    1:     separatedCollection.MoveTo(aLists);
    1:   }
    1: 
    1:   return aFrame->DisplayOutline(aBuilder, aLists);
    1: }
    1: 
35635: #ifdef DEBUG
35635: static PRBool
35635: IsFrameAllowedInTable(nsIAtom* aType)
35635: {
35635:   return IS_TABLE_CELL(aType) ||
35635:          nsGkAtoms::tableRowFrame == aType ||
35635:          nsGkAtoms::tableRowGroupFrame == aType ||
35635:          nsGkAtoms::scrollFrame == aType ||
35635:          nsGkAtoms::tableFrame == aType ||
35635:          nsGkAtoms::tableColFrame == aType ||
35635:          nsGkAtoms::tableColGroupFrame == aType;
35635: }
35635: #endif
35635: 
35635: static PRBool
38078: AnyTablePartHasBorderOrBackground(nsIFrame* aStart, nsIFrame* aEnd)
38078: {
38078:   for (nsIFrame* f = aStart; f != aEnd; f = f->GetNextSibling()) {
37806:     NS_ASSERTION(IsFrameAllowedInTable(f->GetType()), "unexpected frame type");
37806: 
37806:     if (f->GetStyleVisibility()->IsVisible() &&
37806:         (!f->GetStyleBackground()->IsTransparent() ||
37806:          f->GetStyleDisplay()->mAppearance ||
37806:          f->HasBorder()))
35635:       return PR_TRUE;
35636: 
37806:     nsTableCellFrame *cellFrame = do_QueryFrame(f);
35635:     if (cellFrame)
37806:       continue;
37806: 
38078:     if (AnyTablePartHasBorderOrBackground(f->GetChildList(nsnull).FirstChild(), nsnull))
35635:       return PR_TRUE;
35635:   }
35636: 
35635:   return PR_FALSE;
35635: }
35635: 
    1: // table paint code is concerned primarily with borders and bg color
    1: // SEC: TODO: adjust the rect for captions
    1: NS_IMETHODIMP
    1: nsTableFrame::BuildDisplayList(nsDisplayListBuilder*   aBuilder,
    1:                                const nsRect&           aDirtyRect,
    1:                                const nsDisplayListSet& aLists)
    1: {
    1:   if (!IsVisibleInSelection(aBuilder))
    1:     return NS_OK;
    1: 
    1:   DO_GLOBAL_REFLOW_COUNT_DSP_COLOR("nsTableFrame", NS_RGB(255,128,255));
    1: 
30511:   if (GetStyleVisibility()->IsVisible()) {
30511:     nsMargin deflate = GetDeflationForBackground(PresContext());
30511:     // If 'deflate' is (0,0,0,0) then we can paint the table background
30511:     // in its own display item, so do that to take advantage of
30511:     // opacity and visibility optimizations
68635:     if (deflate == nsMargin(0, 0, 0, 0)) {
30511:       nsresult rv = DisplayBackgroundUnconditional(aBuilder, aLists, PR_FALSE);
30511:       NS_ENSURE_SUCCESS(rv, rv);
30511:     }
30511:   }
30511: 
35635:   nsDisplayTableItem* item = nsnull;
37459:   // This background is created if any of the table parts are visible,
37459:   // or if we're doing event handling (since DisplayGenericTablePart
37459:   // needs the item for the |sortEventBackgrounds|-dependent code).
35635:   // Specific visibility decisions are delegated to the table background
35635:   // painter, which handles borders and backgrounds for the table.
37459:   if (aBuilder->IsForEventDelivery() ||
38078:       AnyTablePartHasBorderOrBackground(this, GetNextSibling()) ||
38078:       AnyTablePartHasBorderOrBackground(mColGroups.FirstChild(), nsnull)) {
51260:     item = new (aBuilder) nsDisplayTableBorderBackground(aBuilder, this);
13961:     nsresult rv = aLists.BorderBackground()->AppendNewToTop(item);
    1:     NS_ENSURE_SUCCESS(rv, rv);
35635:   }
    1: 
13961:   return DisplayGenericTablePart(aBuilder, this, aDirtyRect, aLists, item);
    1: }
    1: 
30511: nsMargin
30511: nsTableFrame::GetDeflationForBackground(nsPresContext* aPresContext) const
30511: {
30511:   if (eCompatibility_NavQuirks != aPresContext->CompatibilityMode() ||
30511:       !IsBorderCollapse())
30511:     return nsMargin(0,0,0,0);
30511: 
30511:   return GetOuterBCBorder();
30511: }
30511: 
    1: // XXX We don't put the borders and backgrounds in tree order like we should.
    1: // That requires some major surgery which we aren't going to do right now.
    1: void
68481: nsTableFrame::PaintTableBorderBackground(nsRenderingContext& aRenderingContext,
    1:                                          const nsRect& aDirtyRect,
32425:                                          nsPoint aPt, PRUint32 aBGPaintFlags)
    1: {
  238:   nsPresContext* presContext = PresContext();
    1: 
    1:   TableBackgroundPainter painter(this, TableBackgroundPainter::eOrigin_Table,
13405:                                  presContext, aRenderingContext,
32425:                                  aDirtyRect, aPt, aBGPaintFlags);
30511:   nsMargin deflate = GetDeflationForBackground(presContext);
30511:   // If 'deflate' is (0,0,0,0) then we'll paint the table background
30511:   // in a separate display item, so don't do it here.
68635:   nsresult rv = painter.PaintTable(this, deflate, deflate != nsMargin(0, 0, 0, 0));
    1:   if (NS_FAILED(rv)) return;
    1: 
    1:   if (GetStyleVisibility()->IsVisible()) {
    1:     if (!IsBorderCollapse()) {
    1:       PRIntn skipSides = GetSkipSides();
13405:       nsRect rect(aPt, mRect.Size());
    1:       nsCSSRendering::PaintBorder(presContext, aRenderingContext, this,
40180:                                   aDirtyRect, rect, mStyleContext, skipSides);
    1:     }
    1:     else {
13405:       // XXX we should probably get rid of this translation at some stage
13405:       // But that would mean modifying PaintBCBorders, ugh
68481:       nsRenderingContext::AutoPushTranslation translate(&aRenderingContext, aPt);
13405:       PaintBCBorders(aRenderingContext, aDirtyRect - aPt);
    1:     }
    1:   }
    1: }
    1: 
    1: PRIntn
    1: nsTableFrame::GetSkipSides() const
    1: {
    1:   PRIntn skip = 0;
    1:   // frame attribute was accounted for in nsHTMLTableElement::MapTableBorderInto
    1:   // account for pagination
    1:   if (nsnull != GetPrevInFlow()) {
    1:     skip |= 1 << NS_SIDE_TOP;
    1:   }
    1:   if (nsnull != GetNextInFlow()) {
    1:     skip |= 1 << NS_SIDE_BOTTOM;
    1:   }
    1:   return skip;
    1: }
    1: 
    1: void
    1: nsTableFrame::SetColumnDimensions(nscoord         aHeight,
    1:                                   const nsMargin& aBorderPadding)
    1: {
    1:   nscoord cellSpacingX = GetCellSpacingX();
    1:   nscoord cellSpacingY = GetCellSpacingY();
    1:   nscoord colHeight = aHeight -= aBorderPadding.top + aBorderPadding.bottom +
    1:                                  2* cellSpacingY;
    1: 
16348:   nsTableIterator iter(mColGroups);
16348:   nsIFrame* colGroupFrame = iter.First();
16348:   PRBool tableIsLTR = GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
32531:   PRInt32 colX =tableIsLTR ? 0 : NS_MAX(0, GetColCount() - 1);
16348:   PRInt32 tableColIncr = tableIsLTR ? 1 : -1;
    1:   nsPoint colGroupOrigin(aBorderPadding.left + cellSpacingX,
    1:                          aBorderPadding.top + cellSpacingY);
    1:   while (nsnull != colGroupFrame) {
    1:     nscoord colGroupWidth = 0;
16348:     nsTableIterator iterCol(*colGroupFrame);
16348:     nsIFrame* colFrame = iterCol.First();
    1:     nsPoint colOrigin(0,0);
    1:     while (nsnull != colFrame) {
    1:       if (NS_STYLE_DISPLAY_TABLE_COLUMN ==
    1:           colFrame->GetStyleDisplay()->mDisplay) {
    1:         NS_ASSERTION(colX < GetColCount(), "invalid number of columns");
    1:         nscoord colWidth = GetColumnWidth(colX);
    1:         nsRect colRect(colOrigin.x, colOrigin.y, colWidth, colHeight);
    1:         colFrame->SetRect(colRect);
    1:         colOrigin.x += colWidth + cellSpacingX;
    1:         colGroupWidth += colWidth + cellSpacingX;
16348:         colX += tableColIncr;
16348:       }
16348:       colFrame = iterCol.Next();
    1:     }
    1:     if (colGroupWidth) {
    1:       colGroupWidth -= cellSpacingX;
    1:     }
    1: 
    1:     nsRect colGroupRect(colGroupOrigin.x, colGroupOrigin.y, colGroupWidth, colHeight);
    1:     colGroupFrame->SetRect(colGroupRect);
16348:     colGroupFrame = iter.Next();
    1:     colGroupOrigin.x += colGroupWidth + cellSpacingX;
    1:   }
    1: }
    1: 
    1: // SEC: TODO need to worry about continuing frames prev/next in flow for splitting across pages.
    1: 
    1: // XXX this could be made more general to handle row modifications that change the
    1: // table height, but first we need to scrutinize every Invalidate
11285: void
11285: nsTableFrame::ProcessRowInserted(nscoord aNewHeight)
11285: {
11285:   SetRowInserted(PR_FALSE); // reset the bit that got us here
 2141:   nsTableFrame::RowGroupArray rowGroups;
11285:   OrderRowGroups(rowGroups);
    1:   // find the row group containing the inserted row
 2141:   for (PRUint32 rgX = 0; rgX < rowGroups.Length(); rgX++) {
 2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
 2141:     NS_ASSERTION(rgFrame, "Must have rgFrame here");
    1:     nsIFrame* childFrame = rgFrame->GetFirstChild(nsnull);
    1:     // find the row that was inserted first
    1:     while (childFrame) {
26583:       nsTableRowFrame *rowFrame = do_QueryFrame(childFrame);
26583:       if (rowFrame) {
    1:         if (rowFrame->IsFirstInserted()) {
    1:           rowFrame->SetFirstInserted(PR_FALSE);
    1:           // damage the table from the 1st row inserted to the end of the table
    1:           nscoord damageY = rgFrame->GetPosition().y + rowFrame->GetPosition().y;
11285:           nsRect damageRect(0, damageY, GetSize().width, aNewHeight - damageY);
11285: 
11285:           Invalidate(damageRect);
11285:           // XXXbz didn't we do this up front?  Why do we need to do it again?
11285:           SetRowInserted(PR_FALSE);
    1:           return; // found it, so leave
    1:         }
    1:       }
    1:       childFrame = childFrame->GetNextSibling();
    1:     }
    1:   }
    1: }
    1: 
    1: /* virtual */ void
    1: nsTableFrame::MarkIntrinsicWidthsDirty()
    1: {
57471:   nsITableLayoutStrategy* tls = LayoutStrategy();
57471:   if (NS_UNLIKELY(!tls)) {
57471:     // This is a FrameNeedsReflow() from nsBlockFrame::RemoveFrame()
57471:     // walking up the ancestor chain in a table next-in-flow.  In this case
57471:     // our original first-in-flow (which owns the TableLayoutStrategy) has
57471:     // already been destroyed and unhooked from the flow chain and thusly
57471:     // LayoutStrategy() returns null.  All the frames in the flow will be
57471:     // destroyed so no need to mark anything dirty here.  See bug 595758.
57471:     return;
57471:   }
57471:   tls->MarkIntrinsicWidthsDirty();
    1: 
    1:   // XXXldb Call SetBCDamageArea?
    1: 
    1:   nsHTMLContainerFrame::MarkIntrinsicWidthsDirty();
    1: }
    1: 
    1: /* virtual */ nscoord
68481: nsTableFrame::GetMinWidth(nsRenderingContext *aRenderingContext)
    1: {
    1:   if (NeedToCalcBCBorders())
    1:     CalcBCBorders();
    1: 
    1:   ReflowColGroups(aRenderingContext);
    1: 
    1:   return LayoutStrategy()->GetMinWidth(aRenderingContext);
    1: }
    1: 
    1: /* virtual */ nscoord
68481: nsTableFrame::GetPrefWidth(nsRenderingContext *aRenderingContext)
    1: {
    1:   if (NeedToCalcBCBorders())
    1:     CalcBCBorders();
    1: 
    1:   ReflowColGroups(aRenderingContext);
    1: 
    1:   return LayoutStrategy()->GetPrefWidth(aRenderingContext, PR_FALSE);
    1: }
    1: 
    1: /* virtual */ nsIFrame::IntrinsicWidthOffsetData
68481: nsTableFrame::IntrinsicWidthOffsets(nsRenderingContext* aRenderingContext)
    1: {
    1:   IntrinsicWidthOffsetData result =
    1:     nsHTMLContainerFrame::IntrinsicWidthOffsets(aRenderingContext);
    1: 
    1:   if (IsBorderCollapse()) {
    1:     result.hPadding = 0;
    1:     result.hPctPadding = 0;
    1: 
    1:     nsMargin outerBC = GetIncludedOuterBCBorder();
    1:     result.hBorder = outerBC.LeftRight();
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nsSize
68481: nsTableFrame::ComputeSize(nsRenderingContext *aRenderingContext,
    1:                           nsSize aCBSize, nscoord aAvailableWidth,
    1:                           nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                           PRBool aShrinkWrap)
    1: {
    1:   nsSize result =
    1:     nsHTMLContainerFrame::ComputeSize(aRenderingContext, aCBSize,
    1:                                       aAvailableWidth,
    1:                                       aMargin, aBorder, aPadding, aShrinkWrap);
    1: 
    1:   // Tables never shrink below their min width.
    1:   nscoord minWidth = GetMinWidth(aRenderingContext);
    1:   if (minWidth > result.width)
    1:     result.width = minWidth;
    1: 
    1:   return result;
    1: }
    1: 
    1: nscoord
68481: nsTableFrame::TableShrinkWidthToFit(nsRenderingContext *aRenderingContext,
    1:                                     nscoord aWidthInCB)
    1: {
    1:   nscoord result;
    1:   nscoord minWidth = GetMinWidth(aRenderingContext);
    1:   if (minWidth > aWidthInCB) {
    1:     result = minWidth;
    1:   } else {
    1:     // Tables shrink width to fit with a slightly different algorithm
    1:     // from the one they use for their intrinsic widths (the difference
    1:     // relates to handling of percentage widths on columns).  So this
    1:     // function differs from nsFrame::ShrinkWidthToFit by only the
    1:     // following line.
    1:     // Since we've already called GetMinWidth, we don't need to do any
    1:     // of the other stuff GetPrefWidth does.
    1:     nscoord prefWidth =
    1:       LayoutStrategy()->GetPrefWidth(aRenderingContext, PR_TRUE);
    1:     if (prefWidth > aWidthInCB) {
    1:       result = aWidthInCB;
    1:     } else {
    1:       result = prefWidth;
    1:     }
    1:   }
    1:   return result;
    1: }
    1: 
    1: /* virtual */ nsSize
68481: nsTableFrame::ComputeAutoSize(nsRenderingContext *aRenderingContext,
    1:                               nsSize aCBSize, nscoord aAvailableWidth,
    1:                               nsSize aMargin, nsSize aBorder, nsSize aPadding,
    1:                               PRBool aShrinkWrap)
    1: {
    1:   // Tables always shrink-wrap.
    1:   nscoord cbBased = aAvailableWidth - aMargin.width - aBorder.width -
    1:                     aPadding.width;
    1:   return nsSize(TableShrinkWidthToFit(aRenderingContext, cbBased),
    1:                 NS_UNCONSTRAINEDSIZE);
    1: }
    1: 
 2765: // Return true if aParentReflowState.frame or any of its ancestors within
 2765: // the containing table have non-auto height. (e.g. pct or fixed height)
 2765: PRBool
 2765: nsTableFrame::AncestorsHaveStyleHeight(const nsHTMLReflowState& aParentReflowState)
 2765: {
 2765:   for (const nsHTMLReflowState* rs = &aParentReflowState;
 2765:        rs && rs->frame; rs = rs->parentReflowState) {
 2765:     nsIAtom* frameType = rs->frame->GetType();
    1:     if (IS_TABLE_CELL(frameType)                     ||
    1:         (nsGkAtoms::tableRowFrame      == frameType) ||
    1:         (nsGkAtoms::tableRowGroupFrame == frameType)) {
51406:       const nsStyleCoord &height = rs->mStylePosition->mHeight;
51406:       // calc() treated like 'auto' on internal table elements
51406:       if (height.GetUnit() != eStyleUnit_Auto && !height.IsCalcUnit()) {
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:     else if (nsGkAtoms::tableFrame == frameType) {
    1:       // we reached the containing table, so always return
 2765:       if (rs->mStylePosition->mHeight.GetUnit() != eStyleUnit_Auto) {
    1:         return PR_TRUE;
    1:       }
    1:       else return PR_FALSE;
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: // See if a special height reflow needs to occur and if so, call RequestSpecialHeightReflow
    1: void
    1: nsTableFrame::CheckRequestSpecialHeightReflow(const nsHTMLReflowState& aReflowState)
    1: {
51406:   NS_ASSERTION(IS_TABLE_CELL(aReflowState.frame->GetType()) ||
51406:                aReflowState.frame->GetType() == nsGkAtoms::tableRowFrame ||
51406:                aReflowState.frame->GetType() == nsGkAtoms::tableRowGroupFrame ||
51406:                aReflowState.frame->GetType() == nsGkAtoms::tableFrame,
51406:                "unexpected frame type");
    1:   if (!aReflowState.frame->GetPrevInFlow() &&  // 1st in flow
 4166:       (NS_UNCONSTRAINEDSIZE == aReflowState.ComputedHeight() ||  // no computed height
 4166:        0                    == aReflowState.ComputedHeight()) &&
 2765:       eStyleUnit_Percent == aReflowState.mStylePosition->mHeight.GetUnit() && // pct height
 2765:       nsTableFrame::AncestorsHaveStyleHeight(*aReflowState.parentReflowState)) {
    1:     nsTableFrame::RequestSpecialHeightReflow(aReflowState);
    1:   }
    1: }
    1: 
    1: // Notify the frame and its ancestors (up to the containing table) that a special
    1: // height reflow will occur. During a special height reflow, a table, row group,
    1: // row, or cell returns the last size it was reflowed at. However, the table may
    1: // change the height of row groups, rows, cells in DistributeHeightToRows after.
    1: // And the row group can change the height of rows, cells in CalculateRowHeights.
    1: void
    1: nsTableFrame::RequestSpecialHeightReflow(const nsHTMLReflowState& aReflowState)
    1: {
    1:   // notify the frame and its ancestors of the special reflow, stopping at the containing table
    1:   for (const nsHTMLReflowState* rs = &aReflowState; rs && rs->frame; rs = rs->parentReflowState) {
    1:     nsIAtom* frameType = rs->frame->GetType();
35640:     NS_ASSERTION(IS_TABLE_CELL(frameType) ||
35640:                  nsGkAtoms::tableRowFrame == frameType ||
35640:                  nsGkAtoms::tableRowGroupFrame == frameType ||
35640:                  nsGkAtoms::tableFrame == frameType,
35640:                  "unexpected frame type");
    1: 
    1:     rs->frame->AddStateBits(NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
    1:     if (nsGkAtoms::tableFrame == frameType) {
    1:       NS_ASSERTION(rs != &aReflowState,
    1:                    "should not request special height reflow for table");
    1:       // always stop when we reach a table
    1:       break;
    1:     }
    1:   }
    1: }
    1: 
    1: /******************************************************************************************
    1:  * Before reflow, intrinsic width calculation is done using GetMinWidth
    1:  * and GetPrefWidth.  This used to be known as pass 1 reflow.
    1:  *
    1:  * After the intrinsic width calculation, the table determines the
    1:  * column widths using BalanceColumnWidths() and
    1:  * then reflows each child again with a constrained avail width. This reflow is referred to
    1:  * as the pass 2 reflow.
    1:  *
    1:  * A special height reflow (pass 3 reflow) can occur during an initial or resize reflow
    1:  * if (a) a row group, row, cell, or a frame inside a cell has a percent height but no computed
    1:  * height or (b) in paginated mode, a table has a height. (a) supports percent nested tables
    1:  * contained inside cells whose heights aren't known until after the pass 2 reflow. (b) is
    1:  * necessary because the table cannot split until after the pass 2 reflow. The mechanics of
    1:  * the special height reflow (variety a) are as follows:
    1:  *
    1:  * 1) Each table related frame (table, row group, row, cell) implements NeedsSpecialReflow()
    1:  *    to indicate that it should get the reflow. It does this when it has a percent height but
    1:  *    no computed height by calling CheckRequestSpecialHeightReflow(). This method calls
    1:  *    RequestSpecialHeightReflow() which calls SetNeedSpecialReflow() on its ancestors until
    1:  *    it reaches the containing table and calls SetNeedToInitiateSpecialReflow() on it. For
    1:  *    percent height frames inside cells, during DidReflow(), the cell's NotifyPercentHeight()
    1:  *    is called (the cell is the reflow state's mPercentHeightObserver in this case).
    1:  *    NotifyPercentHeight() calls RequestSpecialHeightReflow().
    1:  *
    1:  * 2) After the pass 2 reflow, if the table's NeedToInitiateSpecialReflow(true) was called, it
    1:  *    will do the special height reflow, setting the reflow state's mFlags.mSpecialHeightReflow
    1:  *    to true and mSpecialHeightInitiator to itself. It won't do this if IsPrematureSpecialHeightReflow()
    1:  *    returns true because in that case another special height reflow will be coming along with the
    1:  *    containing table as the mSpecialHeightInitiator. It is only relevant to do the reflow when
    1:  *    the mSpecialHeightInitiator is the containing table, because if it is a remote ancestor, then
    1:  *    appropriate heights will not be known.
    1:  *
    1:  * 3) Since the heights of the table, row groups, rows, and cells was determined during the pass 2
    1:  *    reflow, they return their last desired sizes during the special height reflow. The reflow only
    1:  *    permits percent height frames inside the cells to resize based on the cells height and that height
    1:  *    was determined during the pass 2 reflow.
    1:  *
    1:  * So, in the case of deeply nested tables, all of the tables that were told to initiate a special
    1:  * reflow will do so, but if a table is already in a special reflow, it won't inititate the reflow
    1:  * until the current initiator is its containing table. Since these reflows are only received by
    1:  * frames that need them and they don't cause any rebalancing of tables, the extra overhead is minimal.
    1:  *
    1:  * The type of special reflow that occurs during printing (variety b) follows the same mechanism except
    1:  * that all frames will receive the reflow even if they don't really need them.
    1:  *
    1:  * Open issues with the special height reflow:
    1:  *
    1:  * 1) At some point there should be 2 kinds of special height reflows because (a) and (b) above are
    1:  *    really quite different. This would avoid unnecessary reflows during printing.
    1:  * 2) When a cell contains frames whose percent heights > 100%, there is data loss (see bug 115245).
    1:  *    However, this can also occur if a cell has a fixed height and there is no special height reflow.
    1:  *
    1:  * XXXldb Special height reflow should really be its own method, not
    1:  * part of nsIFrame::Reflow.  It should then call nsIFrame::Reflow on
    1:  * the contents of the cells to do the necessary vertical resizing.
    1:  *
    1:  ******************************************************************************************/
    1: 
    1: /* Layout the entire inner table. */
    1: NS_METHOD nsTableFrame::Reflow(nsPresContext*           aPresContext,
    1:                                nsHTMLReflowMetrics&     aDesiredSize,
    1:                                const nsHTMLReflowState& aReflowState,
    1:                                nsReflowStatus&          aStatus)
    1: {
    1:   DO_GLOBAL_REFLOW_COUNT("nsTableFrame");
    1:   DISPLAY_REFLOW(aPresContext, this, aReflowState, aDesiredSize, aStatus);
    1:   PRBool isPaginated = aPresContext->IsPaginated();
    1: 
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   if (!GetPrevInFlow() && !mTableLayoutStrategy) {
    1:     NS_ASSERTION(PR_FALSE, "strategy should have been created in Init");
    1:     return NS_ERROR_NULL_POINTER;
    1:   }
    1:   nsresult rv = NS_OK;
    1: 
    1:   // see if collapsing borders need to be calculated
    1:   if (!GetPrevInFlow() && IsBorderCollapse() && NeedToCalcBCBorders()) {
    1:     CalcBCBorders();
    1:   }
    1: 
    1:   aDesiredSize.width = aReflowState.availableWidth;
    1: 
    1:   // Check for an overflow list, and append any row group frames being pushed
    1:   MoveOverflowToChildList(aPresContext);
    1: 
    1:   PRBool haveDesiredHeight = PR_FALSE;
 4768:   SetHaveReflowedColGroups(PR_FALSE);
    1: 
21894:   // Reflow the entire table (pass 2 and possibly pass 3). This phase is necessary during a
21894:   // constrained initial reflow and other reflows which require either a strategy init or balance.
21894:   // This isn't done during an unconstrained reflow, because it will occur later when the parent
21894:   // reflows with a constrained width.
21894:   if (NS_SUBTREE_DIRTY(this) ||
21894:       aReflowState.ShouldReflowAllKids() ||
21894:       IsGeometryDirty() ||
21894:       aReflowState.mFlags.mVResize) {
21894: 
21894:     if (aReflowState.ComputedHeight() != NS_UNCONSTRAINEDSIZE ||
 2543:         // Also check mVResize, to handle the first Reflow preceding a
 2543:         // special height Reflow, when we've already had a special height
 2543:         // Reflow (where mComputedHeight would not be
 2543:         // NS_UNCONSTRAINEDSIZE, but without a style change in between).
 2543:         aReflowState.mFlags.mVResize) {
 1589:       // XXX Eventually, we should modify DistributeHeightToRows to use
 1589:       // nsTableRowFrame::GetHeight instead of nsIFrame::GetSize().height.
 1589:       // That way, it will make its calculations based on internal table
 1589:       // frame heights as they are before they ever had any extra height
 1589:       // distributed to them.  In the meantime, this reflows all the
 1589:       // internal table frames, which restores them to their state before
 1589:       // DistributeHeightToRows was called.
 1589:       SetGeometryDirty();
 1589:     }
 1589: 
21893:     PRBool needToInitiateSpecialReflow =
21893:       !!(GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT);
    1:     // see if an extra reflow will be necessary in pagination mode when there is a specified table height
    1:     if (isPaginated && !GetPrevInFlow() && (NS_UNCONSTRAINEDSIZE != aReflowState.availableHeight)) {
    1:       nscoord tableSpecifiedHeight = CalcBorderBoxHeight(aReflowState);
    1:       if ((tableSpecifiedHeight > 0) &&
    1:           (tableSpecifiedHeight != NS_UNCONSTRAINEDSIZE)) {
    1:         needToInitiateSpecialReflow = PR_TRUE;
    1:       }
    1:     }
    1:     nsIFrame* lastChildReflowed = nsnull;
    1: 
 6738:     NS_ASSERTION(!aReflowState.mFlags.mSpecialHeightReflow,
 6738:                  "Shouldn't be in special height reflow here!");
    1: 
    1:     // do the pass 2 reflow unless this is a special height reflow and we will be
    1:     // initiating a special height reflow
    1:     // XXXldb I changed this.  Should I change it back?
    1: 
    1:     // if we need to initiate a special height reflow, then don't constrain the
    1:     // height of the reflow before that
    1:     nscoord availHeight = needToInitiateSpecialReflow
    1:                           ? NS_UNCONSTRAINEDSIZE : aReflowState.availableHeight;
    1: 
    1:     ReflowTable(aDesiredSize, aReflowState, availHeight,
    1:                 lastChildReflowed, aStatus);
    1: 
    1:     // reevaluate special height reflow conditions
    1:     if (GetStateBits() & NS_FRAME_CONTAINS_RELATIVE_HEIGHT)
    1:       needToInitiateSpecialReflow = PR_TRUE;
    1: 
    1:     // XXXldb Are all these conditions correct?
    1:     if (needToInitiateSpecialReflow && NS_FRAME_IS_COMPLETE(aStatus)) {
    1:       // XXXldb Do we need to set the mVResize flag on any reflow states?
    1: 
 6738:       nsHTMLReflowState &mutable_rs =
 6738:         const_cast<nsHTMLReflowState&>(aReflowState);
 6738: 
    1:       // distribute extra vertical space to rows
    1:       CalcDesiredHeight(aReflowState, aDesiredSize);
    1:       mutable_rs.mFlags.mSpecialHeightReflow = PR_TRUE;
    1: 
    1:       ReflowTable(aDesiredSize, aReflowState, aReflowState.availableHeight,
    1:                   lastChildReflowed, aStatus);
    1: 
    1:       if (lastChildReflowed && NS_FRAME_IS_NOT_COMPLETE(aStatus)) {
    1:         // if there is an incomplete child, then set the desired height to include it but not the next one
    1:         nsMargin borderPadding = GetChildAreaOffset(&aReflowState);
    1:         aDesiredSize.height = borderPadding.bottom + GetCellSpacingY() +
    1:                               lastChildReflowed->GetRect().YMost();
    1:       }
    1:       haveDesiredHeight = PR_TRUE;
 6738: 
 6738:       mutable_rs.mFlags.mSpecialHeightReflow = PR_FALSE;
 6738:     }
    1:   }
16484:   else {
16484:     // Calculate the overflow area contribution from our children.
16484:     for (nsIFrame* kid = GetFirstChild(nsnull); kid; kid = kid->GetNextSibling()) {
55039:       ConsiderChildOverflow(aDesiredSize.mOverflowAreas, kid);
16484:     }
16484:   }
    1: 
    1:   aDesiredSize.width = aReflowState.ComputedWidth() +
    1:                        aReflowState.mComputedBorderPadding.LeftRight();
    1:   if (!haveDesiredHeight) {
    1:     CalcDesiredHeight(aReflowState, aDesiredSize);
    1:   }
    1:   if (IsRowInserted()) {
11285:     ProcessRowInserted(aDesiredSize.height);
    1:   }
    1: 
    1:   nsMargin borderPadding = GetChildAreaOffset(&aReflowState);
    1:   SetColumnDimensions(aDesiredSize.height, borderPadding);
    1:   if (NeedToCollapse() &&
    1:       (NS_UNCONSTRAINEDSIZE != aReflowState.availableWidth)) {
    1:     AdjustForCollapsingRowsCols(aDesiredSize, borderPadding);
    1:   }
    1: 
    1:   // make sure the table overflow area does include the table rect.
    1:   nsRect tableRect(0, 0, aDesiredSize.width, aDesiredSize.height) ;
    1: 
    1:   if (!aReflowState.mStyleDisplay->IsTableClip()) {
    1:     // collapsed border may leak out
    1:     nsMargin bcMargin = GetExcludedOuterBCBorder();
    1:     tableRect.Inflate(bcMargin);
    1:   }
55039:   aDesiredSize.mOverflowAreas.UnionAllWith(tableRect);
    1: 
11384:   if (GetStateBits() & NS_FRAME_FIRST_REFLOW) {
11384:     // Fulfill the promise InvalidateFrame makes.
55039:     Invalidate(aDesiredSize.VisualOverflow());
13144:   } else {
17140:     CheckInvalidateSizeChange(aDesiredSize);
11384:   }
11384: 
    1:   FinishAndStoreOverflow(&aDesiredSize);
    1:   NS_FRAME_SET_TRUNCATION(aStatus, aReflowState, aDesiredSize);
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsTableFrame::ReflowTable(nsHTMLReflowMetrics&     aDesiredSize,
    1:                           const nsHTMLReflowState& aReflowState,
    1:                           nscoord                  aAvailHeight,
    1:                           nsIFrame*&               aLastChildReflowed,
    1:                           nsReflowStatus&          aStatus)
    1: {
    1:   nsresult rv = NS_OK;
    1:   aLastChildReflowed = nsnull;
    1: 
    1:   if (!GetPrevInFlow()) {
    1:     mTableLayoutStrategy->ComputeColumnWidths(aReflowState);
    1:   }
    1:   // Constrain our reflow width to the computed table width (of the 1st in flow).
    1:   // and our reflow height to our avail height minus border, padding, cellspacing
    1:   aDesiredSize.width = aReflowState.ComputedWidth() +
    1:                        aReflowState.mComputedBorderPadding.LeftRight();
  238:   nsTableReflowState reflowState(*PresContext(), aReflowState, *this,
    1:                                  aDesiredSize.width, aAvailHeight);
    1:   ReflowChildren(reflowState, aStatus, aLastChildReflowed,
55038:                  aDesiredSize.mOverflowAreas);
    1: 
    1:   ReflowColGroups(aReflowState.rendContext);
    1:   return rv;
    1: }
    1: 
    1: nsIFrame*
    1: nsTableFrame::GetFirstBodyRowGroupFrame()
    1: {
    1:   nsIFrame* headerFrame = nsnull;
    1:   nsIFrame* footerFrame = nsnull;
    1: 
    1:   for (nsIFrame* kidFrame = mFrames.FirstChild(); nsnull != kidFrame; ) {
    1:     const nsStyleDisplay* childDisplay = kidFrame->GetStyleDisplay();
    1: 
    1:     // We expect the header and footer row group frames to be first, and we only
    1:     // allow one header and one footer
    1:     if (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == childDisplay->mDisplay) {
    1:       if (headerFrame) {
    1:         // We already have a header frame and so this header frame is treated
    1:         // like an ordinary body row group frame
    1:         return kidFrame;
    1:       }
    1:       headerFrame = kidFrame;
    1: 
    1:     } else if (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == childDisplay->mDisplay) {
    1:       if (footerFrame) {
    1:         // We already have a footer frame and so this footer frame is treated
    1:         // like an ordinary body row group frame
    1:         return kidFrame;
    1:       }
    1:       footerFrame = kidFrame;
    1: 
    1:     } else if (NS_STYLE_DISPLAY_TABLE_ROW_GROUP == childDisplay->mDisplay) {
    1:       return kidFrame;
    1:     }
    1: 
    1:     // Get the next child
    1:     kidFrame = kidFrame->GetNextSibling();
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: // Table specific version that takes into account repeated header and footer
    1: // frames when continuing table frames
    1: void
37262: nsTableFrame::PushChildren(const RowGroupArray& aRowGroups,
    1:                            PRInt32 aPushFrom)
    1: {
    1:   NS_PRECONDITION(aPushFrom > 0, "pushing first child");
    1: 
    1:   // extract the frames from the array into a sibling list
    1:   nsFrameList frames;
    1:   PRUint32 childX;
37262:   for (childX = aPushFrom; childX < aRowGroups.Length(); ++childX) {
37262:     nsTableRowGroupFrame* rgFrame = aRowGroups[childX];
58965:     if (!rgFrame->IsRepeatable()) {
37262:       mFrames.RemoveFrame(rgFrame);
37262:       frames.AppendFrame(nsnull, rgFrame);
    1:     }
    1:   }
    1: 
57069:   if (frames.IsEmpty()) {
57069:     return;
57069:   }
57069: 
57069:   nsTableFrame* nextInFlow = static_cast<nsTableFrame*>(GetNextInFlow());
57069:   if (nextInFlow) {
57069:     // Insert the frames after any repeated header and footer frames.
    1:     nsIFrame* firstBodyFrame = nextInFlow->GetFirstBodyRowGroupFrame();
    1:     nsIFrame* prevSibling = nsnull;
    1:     if (firstBodyFrame) {
33388:       prevSibling = firstBodyFrame->GetPrevSibling();
    1:     }
    1:     // When pushing and pulling frames we need to check for whether any
    1:     // views need to be reparented.
30941:     ReparentFrameViewList(PresContext(), frames, this, nextInFlow);
30941:     nextInFlow->mFrames.InsertFrames(nextInFlow, prevSibling,
30941:                                      frames);
    1:   }
57069:   else {
57069:     // Add the frames to our overflow list.
30781:     SetOverflowFrames(PresContext(), frames);
30781:   }
30781: }
    1: 
    1: // collapsing row groups, rows, col groups and cols are accounted for after both passes of
    1: // reflow so that it has no effect on the calculations of reflow.
    1: void
    1: nsTableFrame::AdjustForCollapsingRowsCols(nsHTMLReflowMetrics& aDesiredSize,
    1:                                           nsMargin             aBorderPadding)
    1: {
    1:   nscoord yTotalOffset = 0; // total offset among all rows in all row groups
    1: 
28441:   // reset the bit, it will be set again if row/rowgroup or col/colgroup are
28441:   // collapsed
    1:   SetNeedToCollapse(PR_FALSE);
    1: 
    1:   // collapse the rows and/or row groups as necessary
    1:   // Get the ordered children
 2141:   RowGroupArray rowGroups;
 2141:   OrderRowGroups(rowGroups);
29426: 
29426:   nsTableFrame* firstInFlow = static_cast<nsTableFrame*> (GetFirstInFlow());
29426:   nscoord width = firstInFlow->GetCollapsedWidth(aBorderPadding);
    1:   nscoord rgWidth = width - 2 * GetCellSpacingX();
55024:   nsOverflowAreas overflow;
    1:   // Walk the list of children
 2141:   for (PRUint32 childX = 0; childX < rowGroups.Length(); childX++) {
 2141:     nsTableRowGroupFrame* rgFrame = rowGroups[childX];
 2141:     NS_ASSERTION(rgFrame, "Must have row group frame here");
    1:     yTotalOffset += rgFrame->CollapseRowGroupIfNecessary(yTotalOffset, rgWidth);
55024:     ConsiderChildOverflow(overflow, rgFrame);
    1:   }
    1: 
    1:   aDesiredSize.height -= yTotalOffset;
    1:   aDesiredSize.width   = width;
55024:   overflow.UnionAllWith(nsRect(0, 0, aDesiredSize.width, aDesiredSize.height));
55024:   FinishAndStoreOverflow(overflow,
    1:                          nsSize(aDesiredSize.width, aDesiredSize.height));
    1: }
    1: 
29426: 
    1: nscoord
    1: nsTableFrame::GetCollapsedWidth(nsMargin aBorderPadding)
    1: {
29426:   NS_ASSERTION(!GetPrevInFlow(), "GetCollapsedWidth called on next in flow");
    1:   nscoord cellSpacingX = GetCellSpacingX();
    1:   nscoord width = cellSpacingX;
    1:   width += aBorderPadding.left + aBorderPadding.right;
    1:   for (nsIFrame* groupFrame = mColGroups.FirstChild(); groupFrame;
    1:          groupFrame = groupFrame->GetNextSibling()) {
    1:     const nsStyleVisibility* groupVis = groupFrame->GetStyleVisibility();
    1:     PRBool collapseGroup = (NS_STYLE_VISIBILITY_COLLAPSE == groupVis->mVisible);
    1:     nsTableColGroupFrame* cgFrame = (nsTableColGroupFrame*)groupFrame;
    1:     for (nsTableColFrame* colFrame = cgFrame->GetFirstColumn(); colFrame;
    1:          colFrame = colFrame->GetNextCol()) {
    1:       const nsStyleDisplay* colDisplay = colFrame->GetStyleDisplay();
    1:       PRInt32 colX = colFrame->GetColIndex();
    1:       if (NS_STYLE_DISPLAY_TABLE_COLUMN == colDisplay->mDisplay) {
    1:         const nsStyleVisibility* colVis = colFrame->GetStyleVisibility();
    1:         PRBool collapseCol = (NS_STYLE_VISIBILITY_COLLAPSE == colVis->mVisible);
    1:         PRInt32 colWidth = GetColumnWidth(colX);
    1:         if (!collapseGroup && !collapseCol) {
    1:           width += colWidth;
19643:           if (ColumnHasCellSpacingBefore(colX))
    1:             width += cellSpacingX;
    1:         }
29426:         else {
29426:           SetNeedToCollapse(PR_TRUE);
29426:         }
    1:       }
    1:     }
    1:   }
    1:   return width;
    1: }
    1: 
20614: /* virtual */ void
20836: nsTableFrame::DidSetStyleContext(nsStyleContext* aOldStyleContext)
20836: {
20836:    if (!aOldStyleContext) //avoid this on init
20836:      return;
20836: 
20836:    if (IsBorderCollapse() &&
20836:        BCRecalcNeeded(aOldStyleContext, GetStyleContext())) {
20836:      nsRect damageArea(0, 0, GetColCount(), GetRowCount());
20836:      SetBCDamageArea(damageArea);
20836:    }
20836: 
20614:    //avoid this on init or nextinflow
20614:    if (!mTableLayoutStrategy || GetPrevInFlow())
20614:      return;
20614: 
20614:    PRBool isAuto = IsAutoLayout();
20614:    if (isAuto != (LayoutStrategy()->GetType() == nsITableLayoutStrategy::Auto)) {
20614:      nsITableLayoutStrategy* temp;
20614:      if (isAuto)
20614:        temp = new BasicTableLayoutStrategy(this);
20614:      else
20614:        temp = new FixedTableLayoutStrategy(this);
20614: 
20614:      if (temp) {
20614:        delete mTableLayoutStrategy;
20614:        mTableLayoutStrategy = temp;
20614:      }
20614:   }
20614: }
    1: 
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsTableFrame::AppendFrames(nsIAtom*        aListName,
30941:                            nsFrameList&    aFrameList)
    1: {
    1:   NS_ASSERTION(!aListName || aListName == nsGkAtoms::colGroupList,
    1:                "unexpected child list");
    1: 
    1:   // Because we actually have two child lists, one for col group frames and one
    1:   // for everything else, we need to look at each frame individually
    1:   // XXX The frame construction code should be separating out child frames
    1:   // based on the type, bug 343048.
30941:   while (!aFrameList.IsEmpty()) {
30941:     nsIFrame* f = aFrameList.FirstChild();
30941:     aFrameList.RemoveFrame(f);
    1: 
    1:     // See what kind of frame we have
    1:     const nsStyleDisplay* display = f->GetStyleDisplay();
    1: 
    1:     if (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == display->mDisplay) {
30941:       nsTableColGroupFrame* lastColGroup =
30941:         nsTableColGroupFrame::GetLastRealColGroup(this);
    1:       PRInt32 startColIndex = (lastColGroup)
    1:         ? lastColGroup->GetStartColumnIndex() + lastColGroup->GetColCount() : 0;
    1:       mColGroups.InsertFrame(nsnull, lastColGroup, f);
    1:       // Insert the colgroup and its cols into the table
30941:       InsertColGroups(startColIndex,
30941:                       nsFrameList::Slice(mColGroups, f, f->GetNextSibling()));
    1:     } else if (IsRowGroup(display->mDisplay)) {
    1:       // Append the new row group frame to the sibling chain
    1:       mFrames.AppendFrame(nsnull, f);
    1: 
    1:       // insert the row group and its rows into the table
30941:       InsertRowGroups(nsFrameList::Slice(mFrames, f, nsnull));
    1:     } else {
    1:       // Nothing special to do, just add the frame to our child list
30941:       NS_NOTREACHED("How did we get here?  Frame construction screwed up");
    1:       mFrames.AppendFrame(nsnull, f);
    1:     }
    1:   }
    1: 
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   printf("=== TableFrame::AppendFrames\n");
    1:   Dump(PR_TRUE, PR_TRUE, PR_TRUE);
    1: #endif
 1158:   PresContext()->PresShell()->FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                                                NS_FRAME_HAS_DIRTY_CHILDREN);
    1:   SetGeometryDirty();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTableFrame::InsertFrames(nsIAtom*        aListName,
    1:                            nsIFrame*       aPrevFrame,
30941:                            nsFrameList&    aFrameList)
    1: {
    1:   // Asssume there's only one frame being inserted. The problem is that
    1:   // row group frames and col group frames go in separate child lists and
19815:   // so if there's more than one type of frames this gets messy...
    1:   // XXX The frame construction code should be separating out child frames
    1:   // based on the type, bug 343048.
19815: 
    1:   NS_ASSERTION(!aPrevFrame || aPrevFrame->GetParent() == this,
    1:                "inserting after sibling frame with different parent");
    1: 
27678:   if ((aPrevFrame && !aPrevFrame->GetNextSibling()) ||
30941:       (!aPrevFrame && GetChildList(aListName).IsEmpty())) {
27678:     // Treat this like an append; still a workaround for bug 343048.
27678:     return AppendFrames(aListName, aFrameList);
27678:   }
27678: 
    1:   // See what kind of frame we have
30941:   const nsStyleDisplay* display = aFrameList.FirstChild()->GetStyleDisplay();
19815: #ifdef DEBUG
19815:   // verify that all sibling have the same type, if they do not, expect cellmap issues
30941:   for (nsFrameList::Enumerator e(aFrameList); !e.AtEnd(); e.Next()) {
30941:     const nsStyleDisplay* nextDisplay = e.get()->GetStyleDisplay();
19815:     NS_ASSERTION((display->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP) ==
19815:         (nextDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP),
19815:       "heterogenous childlist");
19815:   }
19815: #endif
    1:   if (aPrevFrame) {
    1:     const nsStyleDisplay* prevDisplay = aPrevFrame->GetStyleDisplay();
    1:     // Make sure they belong on the same frame list
    1:     if ((display->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP) !=
    1:         (prevDisplay->mDisplay == NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP)) {
    1:       // the previous frame is not valid, see comment at ::AppendFrames
    1:       // XXXbz Using content indices here means XBL will get screwed
    1:       // over...  Oh, well.
30941:       nsIFrame* pseudoFrame = aFrameList.FirstChild();
    1:       nsIContent* parentContent = GetContent();
    1:       nsIContent* content;
    1:       aPrevFrame = nsnull;
    1:       while (pseudoFrame  && (parentContent ==
    1:                               (content = pseudoFrame->GetContent()))) {
    1:         pseudoFrame = pseudoFrame->GetFirstChild(nsnull);
    1:       }
    1:       nsCOMPtr<nsIContent> container = content->GetParent();
10306:       if (NS_LIKELY(container)) { // XXX need this null-check, see bug 411823.
    1:         PRInt32 newIndex = container->IndexOf(content);
    1:         nsIFrame* kidFrame;
    1:         PRBool isColGroup = (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP ==
    1:                              display->mDisplay);
20832:         nsTableColGroupFrame* lastColGroup;
    1:         if (isColGroup) {
    1:           kidFrame = mColGroups.FirstChild();
30941:           lastColGroup = nsTableColGroupFrame::GetLastRealColGroup(this);
    1:         }
    1:         else {
    1:           kidFrame = mFrames.FirstChild();
    1:         }
    1:         // Important: need to start at a value smaller than all valid indices
    1:         PRInt32 lastIndex = -1;
    1:         while (kidFrame) {
    1:           if (isColGroup) {
20832:             if (kidFrame == lastColGroup) {
20832:               aPrevFrame = kidFrame; // there is no real colgroup after this one
20832:               break;
    1:             }
    1:           }
    1:           pseudoFrame = kidFrame;
    1:           while (pseudoFrame  && (parentContent ==
    1:                                   (content = pseudoFrame->GetContent()))) {
    1:             pseudoFrame = pseudoFrame->GetFirstChild(nsnull);
    1:           }
    1:           PRInt32 index = container->IndexOf(content);
    1:           if (index > lastIndex && index < newIndex) {
    1:             lastIndex = index;
    1:             aPrevFrame = kidFrame;
    1:           }
    1:           kidFrame = kidFrame->GetNextSibling();
    1:         }
    1:       }
    1:     }
10306:   }
    1:   if (NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP == display->mDisplay) {
    1:     NS_ASSERTION(!aListName || aListName == nsGkAtoms::colGroupList,
    1:                  "unexpected child list");
30941:     // Insert the column group frames
30941:     const nsFrameList::Slice& newColgroups =
19815:       mColGroups.InsertFrames(nsnull, aPrevFrame, aFrameList);
    1:     // find the starting col index for the first new col group
    1:     PRInt32 startColIndex = 0;
    1:     if (aPrevFrame) {
    1:       nsTableColGroupFrame* prevColGroup =
    1:         (nsTableColGroupFrame*)GetFrameAtOrBefore(this, aPrevFrame,
    1:                                                   nsGkAtoms::tableColGroupFrame);
    1:       if (prevColGroup) {
    1:         startColIndex = prevColGroup->GetStartColumnIndex() + prevColGroup->GetColCount();
    1:       }
    1:     }
30941:     InsertColGroups(startColIndex, newColgroups);
    1:   } else if (IsRowGroup(display->mDisplay)) {
    1:     NS_ASSERTION(!aListName, "unexpected child list");
    1:     // Insert the frames in the sibling chain
30941:     const nsFrameList::Slice& newRowGroups =
19815:       mFrames.InsertFrames(nsnull, aPrevFrame, aFrameList);
    1: 
30941:     InsertRowGroups(newRowGroups);
    1:   } else {
    1:     NS_ASSERTION(!aListName, "unexpected child list");
30941:     NS_NOTREACHED("How did we even get here?");
    1:     // Just insert the frame and don't worry about reflowing it
19815:     mFrames.InsertFrames(nsnull, aPrevFrame, aFrameList);
    1:     return NS_OK;
    1:   }
    1: 
 1158:   PresContext()->PresShell()->FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                                                NS_FRAME_HAS_DIRTY_CHILDREN);
    1:   SetGeometryDirty();
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   printf("=== TableFrame::InsertFrames\n");
    1:   Dump(PR_TRUE, PR_TRUE, PR_TRUE);
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsTableFrame::RemoveFrame(nsIAtom*        aListName,
    1:                           nsIFrame*       aOldFrame)
    1: {
36646:   NS_ASSERTION(aListName == nsGkAtoms::colGroupList ||
36646:                NS_STYLE_DISPLAY_TABLE_COLUMN_GROUP !=
36646:                  aOldFrame->GetStyleDisplay()->mDisplay,
36646:                "Wrong list name; use nsGkAtoms::colGroupList iff colgroup");
36646:   if (aListName == nsGkAtoms::colGroupList) {
    1:     nsIFrame* nextColGroupFrame = aOldFrame->GetNextSibling();
    1:     nsTableColGroupFrame* colGroup = (nsTableColGroupFrame*)aOldFrame;
    1:     PRInt32 firstColIndex = colGroup->GetStartColumnIndex();
    1:     PRInt32 lastColIndex  = firstColIndex + colGroup->GetColCount() - 1;
    1:     mColGroups.DestroyFrame(aOldFrame);
    1:     nsTableColGroupFrame::ResetColIndices(nextColGroupFrame, firstColIndex);
    1:     // remove the cols from the table
    1:     PRInt32 colX;
    1:     for (colX = lastColIndex; colX >= firstColIndex; colX--) {
24724:       nsTableColFrame* colFrame = mColFrames.SafeElementAt(colX);
    1:       if (colFrame) {
    1:         RemoveCol(colGroup, colX, PR_TRUE, PR_FALSE);
    1:       }
    1:     }
    1: 
24724:     PRInt32 numAnonymousColsToAdd = GetColCount() - mColFrames.Length();
    1:     if (numAnonymousColsToAdd > 0) {
    1:       // this sets the child list, updates the col cache and cell map
30207:       AppendAnonymousColFrames(numAnonymousColsToAdd);
    1:     }
    1: 
    1:   } else {
    1:     NS_ASSERTION(!aListName, "unexpected child list");
37262:     nsTableRowGroupFrame* rgFrame =
37262:       static_cast<nsTableRowGroupFrame*>(aOldFrame);
    1:     // remove the row group from the cell map
    1:     nsTableCellMap* cellMap = GetCellMap();
    1:     if (cellMap) {
    1:       cellMap->RemoveGroupCellMap(rgFrame);
    1:     }
    1: 
    1:     // remove the row group frame from the sibling chain
    1:     mFrames.DestroyFrame(aOldFrame);
    1: 
37262:     // the removal of a row group changes the cellmap, the columns might change
    1:     if (cellMap) {
    1:       cellMap->Synchronize(this);
30941:       // Create an empty slice
30941:       ResetRowIndices(nsFrameList::Slice(mFrames, nsnull, nsnull));
    1:       nsRect damageArea;
    1:       cellMap->RebuildConsideringCells(nsnull, nsnull, 0, 0, PR_FALSE, damageArea);
    1: 
    1:       MatchCellMapToColCache(cellMap);
    1:     }
63970:   }
    1:   // for now, just bail and recalc all of the collapsing borders
37262:   // as the cellmap changes we need to recalc
    1:   if (IsBorderCollapse()) {
32531:     nsRect damageArea(0, 0, NS_MAX(1, GetColCount()), NS_MAX(1, GetRowCount()));
    1:     SetBCDamageArea(damageArea);
    1:   }
 1158:   PresContext()->PresShell()->FrameNeedsReflow(this, nsIPresShell::eTreeChange,
 1158:                                                NS_FRAME_HAS_DIRTY_CHILDREN);
    1:   SetGeometryDirty();
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   printf("=== TableFrame::RemoveFrame\n");
    1:   Dump(PR_TRUE, PR_TRUE, PR_TRUE);
    1: #endif
    1:   return NS_OK;
    1: }
    1: 
    1: /* virtual */ nsMargin
    1: nsTableFrame::GetUsedBorder() const
    1: {
    1:   if (!IsBorderCollapse())
    1:     return nsHTMLContainerFrame::GetUsedBorder();
    1: 
    1:   return GetIncludedOuterBCBorder();
    1: }
    1: 
    1: /* virtual */ nsMargin
    1: nsTableFrame::GetUsedPadding() const
    1: {
    1:   if (!IsBorderCollapse())
    1:     return nsHTMLContainerFrame::GetUsedPadding();
    1: 
    1:   return nsMargin(0,0,0,0);
    1: }
    1: 
39965: // Destructor function for BCPropertyData properties
39965: static void
39965: DestroyBCProperty(void* aPropertyValue)
39965: {
39965:   delete static_cast<BCPropertyData*>(aPropertyValue);
39965: }
39965: 
39965: NS_DECLARE_FRAME_PROPERTY(TableBCProperty, DestroyBCProperty)
39965: 
    1: static void
34593: DivideBCBorderSize(BCPixelSize  aPixelSize,
34593:                    BCPixelSize& aSmallHalf,
34593:                    BCPixelSize& aLargeHalf)
    1: {
    1:   aSmallHalf = aPixelSize / 2;
    1:   aLargeHalf = aPixelSize - aSmallHalf;
    1: }
    1: 
    1: nsMargin
    1: nsTableFrame::GetOuterBCBorder() const
    1: {
    1:   if (NeedToCalcBCBorders())
 3233:     const_cast<nsTableFrame*>(this)->CalcBCBorders();
    1: 
    1:   nsMargin border(0, 0, 0, 0);
    1:   PRInt32 p2t = nsPresContext::AppUnitsPerCSSPixel();
39965:   BCPropertyData* propData = static_cast<BCPropertyData*>
39965:     (Properties().Get(TableBCProperty()));
    1:   if (propData) {
24768:     border.top    = BC_BORDER_TOP_HALF_COORD(p2t, propData->mTopBorderWidth);
24768:     border.right  = BC_BORDER_RIGHT_HALF_COORD(p2t, propData->mRightBorderWidth);
24768:     border.bottom = BC_BORDER_BOTTOM_HALF_COORD(p2t, propData->mBottomBorderWidth);
24768:     border.left   = BC_BORDER_LEFT_HALF_COORD(p2t, propData->mLeftBorderWidth);
    1:   }
    1:   return border;
    1: }
    1: 
    1: nsMargin
    1: nsTableFrame::GetIncludedOuterBCBorder() const
    1: {
24768:   if (NeedToCalcBCBorders())
24768:     const_cast<nsTableFrame*>(this)->CalcBCBorders();
24768: 
    1:   nsMargin border(0, 0, 0, 0);
24768:   PRInt32 p2t = nsPresContext::AppUnitsPerCSSPixel();
39965:   BCPropertyData* propData = static_cast<BCPropertyData*>
39965:     (Properties().Get(TableBCProperty()));
24768:   if (propData) {
24768:     border.top += BC_BORDER_TOP_HALF_COORD(p2t, propData->mTopBorderWidth);
24768:     border.right += BC_BORDER_RIGHT_HALF_COORD(p2t, propData->mRightCellBorderWidth);
24768:     border.bottom += BC_BORDER_BOTTOM_HALF_COORD(p2t, propData->mBottomBorderWidth);
24768:     border.left += BC_BORDER_LEFT_HALF_COORD(p2t, propData->mLeftCellBorderWidth);
24768:   }
    1:   return border;
    1: }
    1: 
    1: nsMargin
    1: nsTableFrame::GetExcludedOuterBCBorder() const
    1: {
24768:   return GetOuterBCBorder() - GetIncludedOuterBCBorder();
    1: }
30511: 
    1: static
    1: void GetSeparateModelBorderPadding(const nsHTMLReflowState* aReflowState,
    1:                                    nsStyleContext&          aStyleContext,
    1:                                    nsMargin&                aBorderPadding)
    1: {
    1:   // XXXbz Either we _do_ have a reflow state and then we can use its
    1:   // mComputedBorderPadding or we don't and then we get the padding
    1:   // wrong!
    1:   const nsStyleBorder* border = aStyleContext.GetStyleBorder();
15992:   aBorderPadding = border->GetActualBorder();
    1:   if (aReflowState) {
    1:     aBorderPadding += aReflowState->mComputedPadding;
    1:   }
    1: }
    1: 
    1: nsMargin
    1: nsTableFrame::GetChildAreaOffset(const nsHTMLReflowState* aReflowState) const
    1: {
    1:   nsMargin offset(0,0,0,0);
    1:   if (IsBorderCollapse()) {
24768:     offset = GetIncludedOuterBCBorder();
    1:   }
    1:   else {
    1:     GetSeparateModelBorderPadding(aReflowState, *mStyleContext, offset);
    1:   }
    1:   return offset;
    1: }
    1: 
    1: void
    1: nsTableFrame::InitChildReflowState(nsHTMLReflowState& aReflowState)
    1: {
    1:   nsMargin collapseBorder;
    1:   nsMargin padding(0,0,0,0);
    1:   nsMargin* pCollapseBorder = nsnull;
  238:   nsPresContext* presContext = PresContext();
    1:   if (IsBorderCollapse()) {
37262:     nsTableRowGroupFrame* rgFrame =
37262:        static_cast<nsTableRowGroupFrame*>(aReflowState.frame);
    1:     pCollapseBorder = rgFrame->GetBCBorderWidth(collapseBorder);
    1:   }
    1:   aReflowState.Init(presContext, -1, -1, pCollapseBorder, &padding);
    1: 
    1:   NS_ASSERTION(!mBits.mResizedColumns ||
    1:                !aReflowState.parentReflowState->mFlags.mSpecialHeightReflow,
    1:                "should not resize columns on special height reflow");
    1:   if (mBits.mResizedColumns) {
    1:     aReflowState.mFlags.mHResize = PR_TRUE;
    1:   }
    1: }
    1: 
    1: // Position and size aKidFrame and update our reflow state. The origin of
    1: // aKidRect is relative to the upper-left origin of our frame
    1: void nsTableFrame::PlaceChild(nsTableReflowState&  aReflowState,
    1:                               nsIFrame*            aKidFrame,
11384:                               nsHTMLReflowMetrics& aKidDesiredSize,
13144:                               const nsRect&        aOriginalKidRect,
55037:                               const nsRect&        aOriginalKidVisualOverflow)
11384: {
11384:   PRBool isFirstReflow =
11384:     (aKidFrame->GetStateBits() & NS_FRAME_FIRST_REFLOW) != 0;
    1: 
    1:   // Place and size the child
  238:   FinishReflowChild(aKidFrame, PresContext(), nsnull, aKidDesiredSize,
    1:                     aReflowState.x, aReflowState.y, 0);
    1: 
55037:   InvalidateFrame(aKidFrame, aOriginalKidRect, aOriginalKidVisualOverflow,
13144:                   isFirstReflow);
11384: 
    1:   // Adjust the running y-offset
    1:   aReflowState.y += aKidDesiredSize.height;
    1: 
    1:   // If our height is constrained, then update the available height
    1:   if (NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height) {
    1:     aReflowState.availSize.height -= aKidDesiredSize.height;
    1:   }
    1: }
    1: 
    1: void
37262: nsTableFrame::OrderRowGroups(RowGroupArray& aChildren,
37262:                              nsTableRowGroupFrame** aHead,
37262:                              nsTableRowGroupFrame** aFoot) const
    1: {
    1:   aChildren.Clear();
 2141:   nsTableRowGroupFrame* head = nsnull;
 2141:   nsTableRowGroupFrame* foot = nsnull;
    1: 
    1:   nsIFrame* kidFrame = mFrames.FirstChild();
    1:   while (kidFrame) {
    1:     const nsStyleDisplay* kidDisplay = kidFrame->GetStyleDisplay();
37262:     nsTableRowGroupFrame* rowGroup =
37262:       static_cast<nsTableRowGroupFrame*>(kidFrame);
37262: 
    1:     switch (kidDisplay->mDisplay) {
    1:     case NS_STYLE_DISPLAY_TABLE_HEADER_GROUP:
    1:       if (head) { // treat additional thead like tbody
 2141:         aChildren.AppendElement(rowGroup);
    1:       }
    1:       else {
 2141:         head = rowGroup;
    1:       }
    1:       break;
    1:     case NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP:
 2141:       if (foot) { // treat additional tfoot like tbody
 2141:         aChildren.AppendElement(rowGroup);
    1:       }
    1:       else {
 2141:         foot = rowGroup;
 2141:       }
 2141:       break;
 2141:     case NS_STYLE_DISPLAY_TABLE_ROW_GROUP:
 2141:       aChildren.AppendElement(rowGroup);
    1:       break;
    1:     default:
 2141:       NS_NOTREACHED("How did this produce an nsTableRowGroupFrame?");
 2141:       // Just ignore it
 2141:       break;
 2141:     }
    1:     // Get the next sibling but skip it if it's also the next-in-flow, since
    1:     // a next-in-flow will not be part of the current table.
    1:     while (kidFrame) {
    1:       nsIFrame* nif = kidFrame->GetNextInFlow();
    1:       kidFrame = kidFrame->GetNextSibling();
    1:       if (kidFrame != nif)
    1:         break;
    1:     }
    1:   }
 2141: 
    1:   // put the thead first
    1:   if (head) {
 2141:     aChildren.InsertElementAt(0, head);
 2141:   }
37262:   if (aHead)
37262:     *aHead = head;
    1:   // put the tfoot after the last tbody
    1:   if (foot) {
 2141:     aChildren.AppendElement(foot);
 2141:   }
37262:   if (aFoot)
37262:     *aFoot = foot;
37262: }
37262: 
37262: nsTableRowGroupFrame*
37262: nsTableFrame::GetTHead() const
37262: {
 2141:   nsIFrame* kidFrame = mFrames.FirstChild();
 2141:   while (kidFrame) {
37262:     if (kidFrame->GetStyleDisplay()->mDisplay ==
37262:           NS_STYLE_DISPLAY_TABLE_HEADER_GROUP) {
37262:       return static_cast<nsTableRowGroupFrame*>(kidFrame);
 2141:     }
 2141: 
 2141:     // Get the next sibling but skip it if it's also the next-in-flow, since
 2141:     // a next-in-flow will not be part of the current table.
 2141:     while (kidFrame) {
 2141:       nsIFrame* nif = kidFrame->GetNextInFlow();
 2141:       kidFrame = kidFrame->GetNextSibling();
 2141:       if (kidFrame != nif)
 2141:         break;
 2141:     }
 2141:   }
 2141: 
37262:   return nsnull;
 2141: }
 2141: 
 2141: nsTableRowGroupFrame*
37262: nsTableFrame::GetTFoot() const
 2141: {
 2141:   nsIFrame* kidFrame = mFrames.FirstChild();
 2141:   while (kidFrame) {
 2141:     if (kidFrame->GetStyleDisplay()->mDisplay ==
37262:           NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP) {
37262:       return static_cast<nsTableRowGroupFrame*>(kidFrame);
 2141:     }
 2141: 
 2141:     // Get the next sibling but skip it if it's also the next-in-flow, since
 2141:     // a next-in-flow will not be part of the current table.
 2141:     while (kidFrame) {
 2141:       nsIFrame* nif = kidFrame->GetNextInFlow();
 2141:       kidFrame = kidFrame->GetNextSibling();
 2141:       if (kidFrame != nif)
 2141:         break;
 2141:     }
 2141:   }
 2141: 
 2141:   return nsnull;
 2141: }
 2141: 
    1: static PRBool
 8727: IsRepeatable(nscoord aFrameHeight, nscoord aPageHeight)
 8727: {
 8727:   return aFrameHeight < (aPageHeight / 4);
 8727: }
 8727: 
 8727: nsresult
 8727: nsTableFrame::SetupHeaderFooterChild(const nsTableReflowState& aReflowState,
 8727:                                      nsTableRowGroupFrame* aFrame,
 8727:                                      nscoord* aDesiredHeight)
 8727: {
 8727:   nsPresContext* presContext = PresContext();
 8727:   nscoord pageHeight = presContext->GetPageSize().height;
 8727: 
 8727:   // Reflow the child with unconstrainted height
 8727:   nsHTMLReflowState kidReflowState(presContext, aReflowState.reflowState,
 8727:                                    aFrame,
 8727:                                    nsSize(aReflowState.availSize.width, NS_UNCONSTRAINEDSIZE),
 8727:                                    -1, -1, PR_FALSE);
 8727:   InitChildReflowState(kidReflowState);
 8727:   kidReflowState.mFlags.mIsTopOfPage = PR_TRUE;
 8727:   nsHTMLReflowMetrics desiredSize;
 8727:   desiredSize.width = desiredSize.height = 0;
 8727:   nsReflowStatus status;
 8727:   nsresult rv = ReflowChild(aFrame, presContext, desiredSize, kidReflowState,
 8727:                             aReflowState.x, aReflowState.y, 0, status);
 8727:   NS_ENSURE_SUCCESS(rv, rv);
 8727:   // The child will be reflowed again "for real" so no need to place it now
 8727: 
 8727:   aFrame->SetRepeatable(IsRepeatable(desiredSize.height, pageHeight));
 8727:   *aDesiredHeight = desiredSize.height;
 8727:   return NS_OK;
    1: }
    1: 
42270: void 
42270: nsTableFrame::PlaceRepeatedFooter(nsTableReflowState& aReflowState,
42270:                                   nsTableRowGroupFrame *aTfoot,
42270:                                   nscoord aFooterHeight)
42270: {
42270:   nsPresContext* presContext = PresContext();
42270:   nsSize kidAvailSize(aReflowState.availSize);
42270:   kidAvailSize.height = aFooterHeight;
42270:   nsHTMLReflowState footerReflowState(presContext,
42270:                                       aReflowState.reflowState,
42270:                                       aTfoot, kidAvailSize,
42270:                                       -1, -1, PR_FALSE);
42270:   InitChildReflowState(footerReflowState);
42270:   aReflowState.y += GetCellSpacingY();
42270: 
42270:   nsRect origTfootRect = aTfoot->GetRect();
55037:   nsRect origTfootVisualOverflow = aTfoot->GetVisualOverflowRect();
42270:           
42270:   nsReflowStatus footerStatus;
42270:   nsHTMLReflowMetrics desiredSize;
42270:   desiredSize.width = desiredSize.height = 0;
42270:   ReflowChild(aTfoot, presContext, desiredSize, footerReflowState,
42270:               aReflowState.x, aReflowState.y,
42270:               NS_FRAME_INVALIDATE_ON_MOVE, footerStatus);
42270:   PlaceChild(aReflowState, aTfoot, desiredSize, origTfootRect,
55037:              origTfootVisualOverflow);
42270: }
42270:                     
    1: // Reflow the children based on the avail size and reason in aReflowState
    1: // update aReflowMetrics a aStatus
55038: nsresult
    1: nsTableFrame::ReflowChildren(nsTableReflowState& aReflowState,
    1:                              nsReflowStatus&     aStatus,
    1:                              nsIFrame*&          aLastChildReflowed,
55038:                              nsOverflowAreas&    aOverflowAreas)
    1: {
    1:   aStatus = NS_FRAME_COMPLETE;
    1:   aLastChildReflowed = nsnull;
    1: 
    1:   nsIFrame* prevKidFrame = nsnull;
    1:   nsresult  rv = NS_OK;
    1:   nscoord   cellSpacingY = GetCellSpacingY();
    1: 
  238:   nsPresContext* presContext = PresContext();
    1:   // XXXldb Should we be checking constrained height instead?
42270:   PRBool isPaginated = presContext->IsPaginated() &&
42270:                        NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height;
    1: 
55038:   aOverflowAreas.Clear();
    1: 
    1:   PRBool reflowAllKids = aReflowState.reflowState.ShouldReflowAllKids() ||
 1589:                          mBits.mResizedColumns ||
 1589:                          IsGeometryDirty();
    1: 
37262:   RowGroupArray rowGroups;
    1:   nsTableRowGroupFrame *thead, *tfoot;
37262:   OrderRowGroups(rowGroups, &thead, &tfoot);
    1:   PRBool pageBreak = PR_FALSE;
 8727:   nscoord footerHeight = 0;
 8727: 
 8727:   // Determine the repeatablility of headers and footers, and also the desired
 8727:   // height of any repeatable footer.
 8727:   // The repeatability of headers on continued tables is handled
 8727:   // when they are created in nsCSSFrameConstructor::CreateContinuingTableFrame.
 8727:   // We handle the repeatability of footers again here because we need to
 8727:   // determine the footer's height anyway. We could perhaps optimize by
 8727:   // using the footer's prev-in-flow's height instead of reflowing it again,
 8727:   // but there's no real need.
 8727:   if (isPaginated) {
 8727:     if (thead && !GetPrevInFlow()) {
 8727:       nscoord desiredHeight;
 8727:       rv = SetupHeaderFooterChild(aReflowState, thead, &desiredHeight);
 8727:       if (NS_FAILED(rv))
 8727:         return rv;
 8727:     }
 8727:     if (tfoot) {
 8727:       rv = SetupHeaderFooterChild(aReflowState, tfoot, &footerHeight);
 8727:       if (NS_FAILED(rv))
 8727:         return rv;
 8727:     }
 8727:   }
42270:    // if the child is a tbody in paginated mode reduce the height by a repeated footer
42270:   PRBool allowRepeatedFooter = PR_FALSE;
37262:   for (PRUint32 childX = 0; childX < rowGroups.Length(); childX++) {
 2141:     nsIFrame* kidFrame = rowGroups[childX];
    1:     // Get the frame state bits
    1:     // See if we should only reflow the dirty child frames
    1:     if (reflowAllKids ||
 1158:         NS_SUBTREE_DIRTY(kidFrame) ||
    1:         (aReflowState.reflowState.mFlags.mSpecialHeightReflow &&
    1:          (isPaginated || (kidFrame->GetStateBits() &
    1:                           NS_FRAME_CONTAINS_RELATIVE_HEIGHT)))) {
    1:       if (pageBreak) {
    1:         PushChildren(rowGroups, childX);
42270:         if (allowRepeatedFooter) {
42270:           PlaceRepeatedFooter(aReflowState, tfoot, footerHeight);
42270:         }
    1:         aStatus = NS_FRAME_NOT_COMPLETE;
    1:         break;
    1:       }
    1: 
    1:       nsSize kidAvailSize(aReflowState.availSize);
42270:       allowRepeatedFooter = PR_FALSE;
    1:       if (isPaginated && (NS_UNCONSTRAINEDSIZE != kidAvailSize.height)) {
37262:         nsTableRowGroupFrame* kidRG =
37262:           static_cast<nsTableRowGroupFrame*>(kidFrame);
 8727:         if (kidRG != thead && kidRG != tfoot && tfoot && tfoot->IsRepeatable()) {
 8727:           // the child is a tbody and there is a repeatable footer
 8727:           NS_ASSERTION(tfoot == rowGroups[rowGroups.Length() - 1], "Missing footer!");
 8727:           if (footerHeight + cellSpacingY < kidAvailSize.height) {
 8727:             allowRepeatedFooter = PR_TRUE;
 8727:             kidAvailSize.height -= footerHeight + cellSpacingY;
    1:           }
    1:         }
    1:       }
    1: 
    1:       nsRect oldKidRect = kidFrame->GetRect();
55037:       nsRect oldKidVisualOverflow = kidFrame->GetVisualOverflowRect();
    1: 
    1:       nsHTMLReflowMetrics desiredSize;
    1:       desiredSize.width = desiredSize.height = 0;
    1: 
    1:       // Reflow the child into the available space
    1:       nsHTMLReflowState kidReflowState(presContext, aReflowState.reflowState,
    1:                                        kidFrame, kidAvailSize,
    1:                                        -1, -1, PR_FALSE);
    1:       InitChildReflowState(kidReflowState);
    1: 
14430:       // If this isn't the first row group, and the previous row group has a
14430:       // nonzero YMost, then we can't be at the top of the page.
14430:       // We ignore the head row group in this check, because a head row group
14430:       // may be automatically added at the top of *every* page.  This prevents
14430:       // infinite loops in some circumstances - see bug 344883.
14430:       if (childX > (thead ? 1 : 0) &&
14430:           (rowGroups[childX - 1]->GetRect().YMost() > 0)) {
    1:         kidReflowState.mFlags.mIsTopOfPage = PR_FALSE;
    1:       }
    1:       aReflowState.y += cellSpacingY;
    1:       if (NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height) {
    1:         aReflowState.availSize.height -= cellSpacingY;
    1:       }
    1:       // record the presence of a next in flow, it might get destroyed so we
    1:       // need to reorder the row group array
    1:       PRBool reorder = PR_FALSE;
    1:       if (kidFrame->GetNextInFlow())
    1:         reorder = PR_TRUE;
    1: 
    1:       rv = ReflowChild(kidFrame, presContext, desiredSize, kidReflowState,
11384:                        aReflowState.x, aReflowState.y,
11384:                        NS_FRAME_INVALIDATE_ON_MOVE, aStatus);
    1: 
    1:       if (reorder) {
    1:         // reorder row groups the reflow may have changed the nextinflows
37262:         OrderRowGroups(rowGroups, &thead, &tfoot);
 2141:         childX = rowGroups.IndexOf(kidFrame);
 2141:         if (childX == RowGroupArray::NoIndex) {
 2141:           // XXXbz can this happen?
37262:           childX = rowGroups.Length();
    1:         }
    1:       }
    1:       // see if the rowgroup did not fit on this page might be pushed on
    1:       // the next page
    1:       if (NS_FRAME_IS_COMPLETE(aStatus) && isPaginated &&
    1:           (NS_UNCONSTRAINEDSIZE != kidReflowState.availableHeight) &&
    1:           kidReflowState.availableHeight < desiredSize.height) {
    1:         // if we are on top of the page place with dataloss
    1:         if (kidReflowState.mFlags.mIsTopOfPage) {
 2141:           if (childX+1 < rowGroups.Length()) {
 2141:             nsIFrame* nextRowGroupFrame = rowGroups[childX + 1];
    1:             if (nextRowGroupFrame) {
13144:               PlaceChild(aReflowState, kidFrame, desiredSize, oldKidRect,
55037:                          oldKidVisualOverflow);
42270:               if (allowRepeatedFooter) {
42270:                 PlaceRepeatedFooter(aReflowState, tfoot, footerHeight);
42270:               }
    1:               aStatus = NS_FRAME_NOT_COMPLETE;
    1:               PushChildren(rowGroups, childX + 1);
    1:               aLastChildReflowed = kidFrame;
    1:               break;
    1:             }
    1:           }
    1:         }
    1:         else { // we are not on top, push this rowgroup onto the next page
    1:           if (prevKidFrame) { // we had a rowgroup before so push this
42270:             if (allowRepeatedFooter) {
42270:               PlaceRepeatedFooter(aReflowState, tfoot, footerHeight);
42270:             }
    1:             aStatus = NS_FRAME_NOT_COMPLETE;
    1:             PushChildren(rowGroups, childX);
    1:             aLastChildReflowed = prevKidFrame;
    1:             break;
    1:           }
74400:           else { // we can't push so lets make clear how much space we need
74400:             PlaceChild(aReflowState, kidFrame, desiredSize, oldKidRect,
74400:                                      oldKidVisualOverflow);
74400:             aLastChildReflowed = kidFrame;
74400:             if (allowRepeatedFooter) {
74400:               PlaceRepeatedFooter(aReflowState, tfoot, footerHeight);
74400:               aLastChildReflowed = tfoot;
74400:             }
74400:             break;
74400:           }
    1:         }
    1:       }
    1: 
    1:       aLastChildReflowed   = kidFrame;
    1: 
    1:       pageBreak = PR_FALSE;
    1:       // see if there is a page break after this row group or before the next one
    1:       if (NS_FRAME_IS_COMPLETE(aStatus) && isPaginated &&
    1:           (NS_UNCONSTRAINEDSIZE != kidReflowState.availableHeight)) {
 2141:         nsIFrame* nextKid =
37262:           (childX + 1 < rowGroups.Length()) ? rowGroups[childX + 1] : nsnull;
42270:         pageBreak = PageBreakAfter(kidFrame, nextKid);
    1:       }
    1: 
    1:       // Place the child
13144:       PlaceChild(aReflowState, kidFrame, desiredSize, oldKidRect,
55037:                  oldKidVisualOverflow);
    1: 
    1:       // Remember where we just were in case we end up pushing children
    1:       prevKidFrame = kidFrame;
    1: 
    1:       // Special handling for incomplete children
    1:       if (NS_FRAME_IS_NOT_COMPLETE(aStatus)) {
64107:         nsIFrame* kidNextInFlow = kidFrame->GetNextInFlow();
    1:         if (!kidNextInFlow) {
    1:           // The child doesn't have a next-in-flow so create a continuing
    1:           // frame. This hooks the child into the flow
    1:           rv = presContext->PresShell()->FrameConstructor()->
32841:             CreateContinuingFrame(presContext, kidFrame, this, &kidNextInFlow);
    1:           if (NS_FAILED(rv)) {
    1:             aStatus = NS_FRAME_COMPLETE;
    1:             break;
    1:           }
    1: 
32841:           // Insert the continuing frame into the sibling list.
32841:           mFrames.InsertFrame(nsnull, kidFrame, kidNextInFlow);
32841: 
32841:           // Fall through and update |rowGroups| with the new rowgroup, just as
32841:           // it would have been if we had called OrderRowGroups again.
32841:           // Note that rowGroups doesn't get used again after we PushChildren
32841:           // below, anyway.
32841:         }
32841: 
32841:         // Put the nextinflow so that it will get pushed
37262:         rowGroups.InsertElementAt(childX + 1,
37262:                            static_cast <nsTableRowGroupFrame*>(kidNextInFlow));
32841: 
    1:         // We've used up all of our available space so push the remaining
    1:         // children to the next-in-flow
    1:         nsIFrame* nextSibling = kidFrame->GetNextSibling();
    1:         if (nsnull != nextSibling) {
    1:           PushChildren(rowGroups, childX + 1);
    1:         }
 8727:         if (allowRepeatedFooter) {
42270:           PlaceRepeatedFooter(aReflowState, tfoot, footerHeight);
    1:         }
    1:         break;
    1:       }
    1:     }
    1:     else { // it isn't being reflowed
    1:       aReflowState.y += cellSpacingY;
    1:       nsRect kidRect = kidFrame->GetRect();
    1:       if (kidRect.y != aReflowState.y) {
11384:         // invalidate the old position
51756:         kidFrame->InvalidateFrameSubtree();
    1:         kidRect.y = aReflowState.y;
    1:         kidFrame->SetRect(kidRect);        // move to the new position
    1:         RePositionViews(kidFrame);
11384:         // invalidate the new position
51756:         kidFrame->InvalidateFrameSubtree();
    1:       }
    1:       aReflowState.y += kidRect.height;
    1: 
    1:       // If our height is constrained then update the available height.
    1:       if (NS_UNCONSTRAINEDSIZE != aReflowState.availSize.height) {
    1:         aReflowState.availSize.height -= cellSpacingY + kidRect.height;
    1:       }
    1:     }
55038:     ConsiderChildOverflow(aOverflowAreas, kidFrame);
    1:   }
    1: 
    1:   // We've now propagated the column resizes and geometry changes to all
    1:   // the children.
    1:   mBits.mResizedColumns = PR_FALSE;
    1:   ClearGeometryDirty();
    1: 
    1:   return rv;
    1: }
    1: 
    1: void
68481: nsTableFrame::ReflowColGroups(nsRenderingContext *aRenderingContext)
    1: {
    1:   if (!GetPrevInFlow() && !HaveReflowedColGroups()) {
    1:     nsHTMLReflowMetrics kidMet;
  238:     nsPresContext *presContext = PresContext();
    1:     for (nsIFrame* kidFrame = mColGroups.FirstChild(); kidFrame;
    1:          kidFrame = kidFrame->GetNextSibling()) {
 4768:       if (NS_SUBTREE_DIRTY(kidFrame)) {
    1:         // The column groups don't care about dimensions or reflow states.
    1:         nsHTMLReflowState kidReflowState(presContext, kidFrame,
    1:                                        aRenderingContext, nsSize(0,0));
    1:         nsReflowStatus cgStatus;
    1:         ReflowChild(kidFrame, presContext, kidMet, kidReflowState, 0, 0, 0,
    1:                     cgStatus);
    1:         FinishReflowChild(kidFrame, presContext, nsnull, kidMet, 0, 0, 0);
    1:       }
 4768:     }
    1:     SetHaveReflowedColGroups(PR_TRUE);
    1:   }
    1: }
    1: 
    1: void
    1: nsTableFrame::CalcDesiredHeight(const nsHTMLReflowState& aReflowState, nsHTMLReflowMetrics& aDesiredSize)
    1: {
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   if (!cellMap) {
    1:     NS_ASSERTION(PR_FALSE, "never ever call me until the cell map is built!");
    1:     aDesiredSize.height = 0;
    1:     return;
    1:   }
    1:   nscoord  cellSpacingY = GetCellSpacingY();
    1:   nsMargin borderPadding = GetChildAreaOffset(&aReflowState);
    1: 
37262:   // get the natural height based on the last child's (row group) rect
37262:   RowGroupArray rowGroups;
37262:   OrderRowGroups(rowGroups);
37262:   if (rowGroups.IsEmpty()) {
    1:     // tables can be used as rectangular items without content
    1:     nscoord tableSpecifiedHeight = CalcBorderBoxHeight(aReflowState);
    1:     if ((NS_UNCONSTRAINEDSIZE != tableSpecifiedHeight) &&
    1:         (tableSpecifiedHeight > 0) &&
  238:         eCompatibility_NavQuirks != PresContext()->CompatibilityMode()) {
    1:           // empty tables should not have a size in quirks mode
    1:       aDesiredSize.height = tableSpecifiedHeight;
    1:     }
    1:     else
    1:       aDesiredSize.height = 0;
    1:     return;
    1:   }
    1:   PRInt32 rowCount = cellMap->GetRowCount();
    1:   PRInt32 colCount = cellMap->GetColCount();
    1:   nscoord desiredHeight = borderPadding.top + borderPadding.bottom;
    1:   if (rowCount > 0 && colCount > 0) {
    1:     desiredHeight += cellSpacingY;
37262:     for (PRUint32 rgX = 0; rgX < rowGroups.Length(); rgX++) {
 2141:       desiredHeight += rowGroups[rgX]->GetSize().height + cellSpacingY;
    1:     }
    1:   }
    1: 
    1:   // see if a specified table height requires dividing additional space to rows
    1:   if (!GetPrevInFlow()) {
    1:     nscoord tableSpecifiedHeight = CalcBorderBoxHeight(aReflowState);
    1:     if ((tableSpecifiedHeight > 0) &&
    1:         (tableSpecifiedHeight != NS_UNCONSTRAINEDSIZE) &&
    1:         (tableSpecifiedHeight > desiredHeight)) {
    1:       // proportionately distribute the excess height to unconstrained rows in each
 1589:       // unconstrained row group.
    1:       DistributeHeightToRows(aReflowState, tableSpecifiedHeight - desiredHeight);
    1:       // this might have changed the overflow area incorporate the childframe overflow area.
    1:       for (nsIFrame* kidFrame = mFrames.FirstChild(); kidFrame; kidFrame = kidFrame->GetNextSibling()) {
55039:         ConsiderChildOverflow(aDesiredSize.mOverflowAreas, kidFrame);
    1:       }
    1:       desiredHeight = tableSpecifiedHeight;
    1:     }
    1:   }
    1:   aDesiredSize.height = desiredHeight;
    1: }
    1: 
    1: static
    1: void ResizeCells(nsTableFrame& aTableFrame)
    1: {
 2141:   nsTableFrame::RowGroupArray rowGroups;
 2141:   aTableFrame.OrderRowGroups(rowGroups);
    1:   nsHTMLReflowMetrics tableDesiredSize;
    1:   nsRect tableRect = aTableFrame.GetRect();
    1:   tableDesiredSize.width = tableRect.width;
    1:   tableDesiredSize.height = tableRect.height;
55039:   tableDesiredSize.SetOverflowAreasToDesiredBounds();
    1: 
 2141:   for (PRUint32 rgX = 0; rgX < rowGroups.Length(); rgX++) {
 2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
    1: 
    1:     nsRect rowGroupRect = rgFrame->GetRect();
    1:     nsHTMLReflowMetrics groupDesiredSize;
    1:     groupDesiredSize.width = rowGroupRect.width;
    1:     groupDesiredSize.height = rowGroupRect.height;
55039:     groupDesiredSize.SetOverflowAreasToDesiredBounds();
55039: 
    1:     nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
    1:     while (rowFrame) {
    1:       rowFrame->DidResize();
55039:       rgFrame->ConsiderChildOverflow(groupDesiredSize.mOverflowAreas, rowFrame);
    1:       rowFrame = rowFrame->GetNextRow();
    1:     }
55024:     rgFrame->FinishAndStoreOverflow(&groupDesiredSize);
55039:     tableDesiredSize.mOverflowAreas.UnionWith(groupDesiredSize.mOverflowAreas +
55039:                                               rgFrame->GetPosition());
    1:   }
55024:   aTableFrame.FinishAndStoreOverflow(&tableDesiredSize);
    1: }
    1: 
    1: void
    1: nsTableFrame::DistributeHeightToRows(const nsHTMLReflowState& aReflowState,
    1:                                      nscoord                  aAmount)
    1: {
    1:   nscoord cellSpacingY = GetCellSpacingY();
    1: 
    1:   nsMargin borderPadding = GetChildAreaOffset(&aReflowState);
    1: 
 2141:   RowGroupArray rowGroups;
 2141:   OrderRowGroups(rowGroups);
    1: 
    1:   nscoord amountUsed = 0;
    1:   // distribute space to each pct height row whose row group doesn't have a computed
    1:   // height, and base the pct on the table height. If the row group had a computed
    1:   // height, then this was already done in nsTableRowGroupFrame::CalculateRowHeights
 4166:   nscoord pctBasis = aReflowState.ComputedHeight() - (GetCellSpacingY() * (GetRowCount() + 1));
    1:   nscoord yOriginRG = borderPadding.top + GetCellSpacingY();
    1:   nscoord yEndRG = yOriginRG;
    1:   PRUint32 rgX;
 2141:   for (rgX = 0; rgX < rowGroups.Length(); rgX++) {
 2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
    1:     nscoord amountUsedByRG = 0;
    1:     nscoord yOriginRow = 0;
    1:     nsRect rgRect = rgFrame->GetRect();
 2141:     if (!rgFrame->HasStyleHeight()) {
    1:       nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
    1:       while (rowFrame) {
    1:         nsRect rowRect = rowFrame->GetRect();
    1:         if ((amountUsed < aAmount) && rowFrame->HasPctHeight()) {
    1:           nscoord pctHeight = rowFrame->GetHeight(pctBasis);
32531:           nscoord amountForRow = NS_MIN(aAmount - amountUsed, pctHeight - rowRect.height);
    1:           if (amountForRow > 0) {
11384:             nsRect oldRowRect = rowRect;
    1:             rowRect.height += amountForRow;
11384:             // XXXbz we don't need to change rowRect.y to be yOriginRow?
    1:             rowFrame->SetRect(rowRect);
    1:             yOriginRow += rowRect.height + cellSpacingY;
    1:             yEndRG += rowRect.height + cellSpacingY;
    1:             amountUsed += amountForRow;
    1:             amountUsedByRG += amountForRow;
    1:             //rowFrame->DidResize();
    1:             nsTableFrame::RePositionViews(rowFrame);
11384: 
11384:             rgFrame->InvalidateRectDifference(oldRowRect, rowRect);
    1:           }
    1:         }
    1:         else {
11384:           if (amountUsed > 0 && yOriginRow != rowRect.y &&
11384:               !(GetStateBits() & NS_FRAME_FIRST_REFLOW)) {
51756:             rowFrame->InvalidateFrameSubtree();
    1:             rowFrame->SetPosition(nsPoint(rowRect.x, yOriginRow));
    1:             nsTableFrame::RePositionViews(rowFrame);
51756:             rowFrame->InvalidateFrameSubtree();
    1:           }
    1:           yOriginRow += rowRect.height + cellSpacingY;
    1:           yEndRG += rowRect.height + cellSpacingY;
    1:         }
    1:         rowFrame = rowFrame->GetNextRow();
    1:       }
    1:       if (amountUsed > 0) {
11384:         if (rgRect.y != yOriginRG) {
51756:           rgFrame->InvalidateFrameSubtree();
11384:         }
11384: 
11384:         nsRect origRgRect = rgRect;
55037:         nsRect origRgVisualOverflow = rgFrame->GetVisualOverflowRect();
11384: 
    1:         rgRect.y = yOriginRG;
    1:         rgRect.height += amountUsedByRG;
11384: 
    1:         rgFrame->SetRect(rgRect);
11384: 
55037:         nsTableFrame::InvalidateFrame(rgFrame, origRgRect,
55037:                                       origRgVisualOverflow, PR_FALSE);
11384:       }
11384:     }
16448:     else if (amountUsed > 0 && yOriginRG != rgRect.y) {
51756:       rgFrame->InvalidateFrameSubtree();
16448:       rgFrame->SetPosition(nsPoint(rgRect.x, yOriginRG));
    1:       // Make sure child views are properly positioned
    1:       nsTableFrame::RePositionViews(rgFrame);
51756:       rgFrame->InvalidateFrameSubtree();
    1:     }
    1:     yOriginRG = yEndRG;
    1:   }
    1: 
    1:   if (amountUsed >= aAmount) {
    1:     ResizeCells(*this);
    1:     return;
    1:   }
    1: 
 9138:   // get the first row without a style height where its row group has an
 9138:   // unconstrained height
    1:   nsTableRowGroupFrame* firstUnStyledRG  = nsnull;
    1:   nsTableRowFrame*      firstUnStyledRow = nsnull;
 2141:   for (rgX = 0; rgX < rowGroups.Length() && !firstUnStyledRG; rgX++) {
 2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
 2141:     if (!rgFrame->HasStyleHeight()) {
    1:       nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
    1:       while (rowFrame) {
    1:         if (!rowFrame->HasStyleHeight()) {
    1:           firstUnStyledRG = rgFrame;
    1:           firstUnStyledRow = rowFrame;
    1:           break;
    1:         }
    1:         rowFrame = rowFrame->GetNextRow();
    1:       }
    1:     }
    1:   }
    1: 
 9138:   nsTableRowFrame* lastEligibleRow = nsnull;
 9138:   // Accumulate the correct divisor. This will be the total total height of all
 9138:   // unstyled rows inside unstyled row groups, unless there are none, in which
 9138:   // case, it will be number of all rows. If the unstyled rows don't have a
 9138:   // height, divide the space equally among them.
    1:   nscoord divisor = 0;
 9138:   PRInt32 eligibleRows = 0;
 9138:   PRBool expandEmptyRows = PR_FALSE;
 9138: 
 9138:   if (!firstUnStyledRow) {
 9138:     // there is no unstyled row
 9138:     divisor = GetRowCount();
 9138:   }
 9138:   else {
 2141:     for (rgX = 0; rgX < rowGroups.Length(); rgX++) {
 2141:       nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
 2141:       if (!firstUnStyledRG || !rgFrame->HasStyleHeight()) {
    1:         nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
    1:         while (rowFrame) {
    1:           if (!firstUnStyledRG || !rowFrame->HasStyleHeight()) {
 9138:             NS_ASSERTION(rowFrame->GetSize().height >= 0,
 9138:                          "negative row frame height");
    1:             divisor += rowFrame->GetSize().height;
 9138:             eligibleRows++;
 9138:             lastEligibleRow = rowFrame;
    1:           }
    1:           rowFrame = rowFrame->GetNextRow();
    1:         }
    1:       }
    1:     }
 9138:     if (divisor <= 0) {
 9138:       if (eligibleRows > 0) {
 9138:         expandEmptyRows = PR_TRUE;
 9138:       }
 9138:       else {
    1:         NS_ERROR("invalid divisor");
    1:         return;
    1:       }
 9138:     }
 9138:   }
    1:   // allocate the extra height to the unstyled row groups and rows
 9138:   nscoord heightToDistribute = aAmount - amountUsed;
    1:   yOriginRG = borderPadding.top + cellSpacingY;
    1:   yEndRG = yOriginRG;
 2141:   for (rgX = 0; rgX < rowGroups.Length(); rgX++) {
 2141:     nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
    1:     nscoord amountUsedByRG = 0;
    1:     nscoord yOriginRow = 0;
    1:     nsRect rgRect = rgFrame->GetRect();
55037:     nsRect rgVisualOverflow = rgFrame->GetVisualOverflowRect();
 9138:     // see if there is an eligible row group or we distribute to all rows
 9138:     if (!firstUnStyledRG || !rgFrame->HasStyleHeight() || !eligibleRows) {
    1:       nsTableRowFrame* rowFrame = rgFrame->GetFirstRow();
    1:       while (rowFrame) {
    1:         nsRect rowRect = rowFrame->GetRect();
55037:         nsRect rowVisualOverflow = rowFrame->GetVisualOverflowRect();
 9138:         // see if there is an eligible row or we distribute to all rows
 9138:         if (!firstUnStyledRow || !rowFrame->HasStyleHeight() || !eligibleRows) {
 9138:           float ratio;
 9138:           if (eligibleRows) {
 9138:             if (!expandEmptyRows) {
 9138:               // The amount of additional space each row gets is proportional to
 9138:               // its height
 9138:               ratio = float(rowRect.height) / float(divisor);
 7988:             } else {
 9138:               // empty rows get all the same additional space
 9138:               ratio = 1.0f / float(eligibleRows);
 9138:             }
 9138:           }
 9138:           else {
 9138:             // all rows get the same additional space
 9138:             ratio = 1.0f / float(divisor);
 9138:           }
 9138:           // give rows their additional space, except for the last row which
 9138:           // gets the remainder
 9138:           nscoord amountForRow = (rowFrame == lastEligibleRow)
 9138:                                  ? aAmount - amountUsed : NSToCoordRound(((float)(heightToDistribute)) * ratio);
32531:           amountForRow = NS_MIN(amountForRow, aAmount - amountUsed);
11384: 
11384:           if (yOriginRow != rowRect.y) {
51756:             rowFrame->InvalidateFrameSubtree();
11384:           }
11384: 
    1:           // update the row height
11384:           nsRect newRowRect(rowRect.x, yOriginRow, rowRect.width,
11384:                             rowRect.height + amountForRow);
    1:           rowFrame->SetRect(newRowRect);
11384: 
    1:           yOriginRow += newRowRect.height + cellSpacingY;
    1:           yEndRG += newRowRect.height + cellSpacingY;
    1: 
    1:           amountUsed += amountForRow;
    1:           amountUsedByRG += amountForRow;
    1:           NS_ASSERTION((amountUsed <= aAmount), "invalid row allocation");
    1:           //rowFrame->DidResize();
    1:           nsTableFrame::RePositionViews(rowFrame);
11384: 
55037:           nsTableFrame::InvalidateFrame(rowFrame, rowRect, rowVisualOverflow,
13144:                                         PR_FALSE);
    1:         }
    1:         else {
11384:           if (amountUsed > 0 && yOriginRow != rowRect.y) {
51756:             rowFrame->InvalidateFrameSubtree();
    1:             rowFrame->SetPosition(nsPoint(rowRect.x, yOriginRow));
    1:             nsTableFrame::RePositionViews(rowFrame);
51756:             rowFrame->InvalidateFrameSubtree();
    1:           }
    1:           yOriginRow += rowRect.height + cellSpacingY;
    1:           yEndRG += rowRect.height + cellSpacingY;
    1:         }
    1:         rowFrame = rowFrame->GetNextRow();
    1:       }
    1:       if (amountUsed > 0) {
11384:         if (rgRect.y != yOriginRG) {
51756:           rgFrame->InvalidateFrameSubtree();
11384:         }
11384: 
11384:         rgFrame->SetRect(nsRect(rgRect.x, yOriginRG, rgRect.width,
11384:                                 rgRect.height + amountUsedByRG));
11384: 
55037:         nsTableFrame::InvalidateFrame(rgFrame, rgRect, rgVisualOverflow,
13144:                                       PR_FALSE);
    1:       }
    1:       // Make sure child views are properly positioned
    1:     }
16448:     else if (amountUsed > 0 && yOriginRG != rgRect.y) {
51756:       rgFrame->InvalidateFrameSubtree();
16448:       rgFrame->SetPosition(nsPoint(rgRect.x, yOriginRG));
    1:       // Make sure child views are properly positioned
    1:       nsTableFrame::RePositionViews(rgFrame);
51756:       rgFrame->InvalidateFrameSubtree();
    1:     }
    1:     yOriginRG = yEndRG;
    1:   }
    1: 
    1:   ResizeCells(*this);
    1: }
    1: 
    1: PRInt32 nsTableFrame::GetColumnWidth(PRInt32 aColIndex)
    1: {
    1:   nsTableFrame * firstInFlow = (nsTableFrame *)GetFirstInFlow();
    1:   NS_ASSERTION(firstInFlow, "illegal state -- no first in flow");
    1:   PRInt32 result = 0;
    1:   if (this == firstInFlow) {
    1:     nsTableColFrame* colFrame = GetColFrame(aColIndex);
    1:     if (colFrame) {
    1:       result = colFrame->GetFinalWidth();
    1:     }
    1:   }
    1:   else {
    1:     result = firstInFlow->GetColumnWidth(aColIndex);
    1:   }
    1: 
    1:   return result;
    1: }
    1: 
    1: // XXX: could cache this.  But be sure to check style changes if you do!
    1: nscoord nsTableFrame::GetCellSpacingX()
    1: {
    1:   if (IsBorderCollapse())
    1:     return 0;
    1: 
19206:   return GetStyleTableBorder()->mBorderSpacingX;
    1: }
    1: 
    1: // XXX: could cache this. But be sure to check style changes if you do!
    1: nscoord nsTableFrame::GetCellSpacingY()
    1: {
    1:   if (IsBorderCollapse())
    1:     return 0;
    1: 
19206:   return GetStyleTableBorder()->mBorderSpacingY;
    1: }
    1: 
    1: 
    1: /* virtual */ nscoord
    1: nsTableFrame::GetBaseline() const
    1: {
    1:   nscoord ascent = 0;
 2141:   RowGroupArray orderedRowGroups;
 2141:   OrderRowGroups(orderedRowGroups);
    1:   nsTableRowFrame* firstRow = nsnull;
 2141:   for (PRUint32 rgIndex = 0; rgIndex < orderedRowGroups.Length(); rgIndex++) {
 2141:     nsTableRowGroupFrame* rgFrame = orderedRowGroups[rgIndex];
    1:     if (rgFrame->GetRowCount()) {
    1:       firstRow = rgFrame->GetFirstRow();
    1:       ascent = rgFrame->GetRect().y + firstRow->GetRect().y + firstRow->GetRowBaseline();
    1:       break;
    1:     }
    1:   }
    1:   if (!firstRow)
    1:     ascent = GetRect().height;
    1:   return ascent;
    1: }
    1: /* ----- global methods ----- */
    1: 
    1: nsIFrame*
    1: NS_NewTableFrame(nsIPresShell* aPresShell, nsStyleContext* aContext)
    1: {
    1:   return new (aPresShell) nsTableFrame(aContext);
    1: }
    1: 
32423: NS_IMPL_FRAMEARENA_HELPERS(nsTableFrame)
32423: 
    1: nsTableFrame*
    1: nsTableFrame::GetTableFrame(nsIFrame* aSourceFrame)
    1: {
    1:   if (aSourceFrame) {
    1:     // "result" is the result of intermediate calls, not the result we return from this method
    1:     for (nsIFrame* parentFrame = aSourceFrame->GetParent(); parentFrame;
    1:          parentFrame = parentFrame->GetParent()) {
    1:       if (nsGkAtoms::tableFrame == parentFrame->GetType()) {
    1:         return (nsTableFrame*)parentFrame;
    1:       }
    1:     }
    1:   }
    1:   NS_NOTREACHED("unable to find table parent");
    1:   return nsnull;
    1: }
    1: 
    1: PRBool
    1: nsTableFrame::IsAutoHeight()
    1: {
51406:   const nsStyleCoord &height = GetStylePosition()->mHeight;
51406:   // Don't consider calc() here like this quirk for percent.
51406:   return height.GetUnit() == eStyleUnit_Auto ||
51406:          (height.GetUnit() == eStyleUnit_Percent &&
51406:           height.GetPercentValue() <= 0.0f);
    1: }
    1: 
    1: nscoord
    1: nsTableFrame::CalcBorderBoxHeight(const nsHTMLReflowState& aState)
    1: {
 4166:   nscoord height = aState.ComputedHeight();
    1:   if (NS_AUTOHEIGHT != height) {
24768:     nsMargin borderPadding = GetChildAreaOffset(&aState);
    1:     height += borderPadding.top + borderPadding.bottom;
    1:   }
32531:   height = NS_MAX(0, height);
    1: 
    1:   return height;
    1: }
    1: 
    1: PRBool
    1: nsTableFrame::IsAutoLayout()
    1: {
 1068:   if (GetStyleTable()->mLayoutStrategy == NS_STYLE_TABLE_LAYOUT_AUTO)
 1068:     return PR_TRUE;
    1:   // a fixed-layout inline-table must have a width
 8046:   // and tables with 'width: -moz-max-content' must be auto-layout
 1068:   // (at least as long as FixedTableLayoutStrategy::GetPrefWidth returns
 1068:   // nscoord_MAX)
 1068:   const nsStyleCoord &width = GetStylePosition()->mWidth;
 7085:   return (width.GetUnit() == eStyleUnit_Auto) ||
 1068:          (width.GetUnit() == eStyleUnit_Enumerated &&
 8046:           width.GetIntValue() == NS_STYLE_WIDTH_MAX_CONTENT);
    1: }
    1: 
    1: #ifdef DEBUG
    1: NS_IMETHODIMP
    1: nsTableFrame::GetFrameName(nsAString& aResult) const
    1: {
    1:   return MakeFrameName(NS_LITERAL_STRING("Table"), aResult);
    1: }
    1: #endif
    1: 
    1: // Find the closet sibling before aPriorChildFrame (including aPriorChildFrame) that
    1: // is of type aChildType
    1: nsIFrame*
    1: nsTableFrame::GetFrameAtOrBefore(nsIFrame*       aParentFrame,
    1:                                  nsIFrame*       aPriorChildFrame,
    1:                                  nsIAtom*        aChildType)
    1: {
    1:   nsIFrame* result = nsnull;
    1:   if (!aPriorChildFrame) {
    1:     return result;
    1:   }
    1:   if (aChildType == aPriorChildFrame->GetType()) {
    1:     return aPriorChildFrame;
    1:   }
    1: 
    1:   // aPriorChildFrame is not of type aChildType, so we need start from
    1:   // the beginnng and find the closest one
    1:   nsIFrame* lastMatchingFrame = nsnull;
    1:   nsIFrame* childFrame = aParentFrame->GetFirstChild(nsnull);
    1:   while (childFrame && (childFrame != aPriorChildFrame)) {
    1:     if (aChildType == childFrame->GetType()) {
    1:       lastMatchingFrame = childFrame;
    1:     }
    1:     childFrame = childFrame->GetNextSibling();
    1:   }
    1:   return lastMatchingFrame;
    1: }
    1: 
    1: #ifdef DEBUG
    1: void
    1: nsTableFrame::DumpRowGroup(nsIFrame* aKidFrame)
    1: {
37262:   if (!aKidFrame)
37262:     return;
37262: 
37262:   nsIFrame* cFrame = aKidFrame->GetFirstChild(nsnull);
26583:   while (cFrame) {
26583:     nsTableRowFrame *rowFrame = do_QueryFrame(cFrame);
26583:     if (rowFrame) {
37269:       printf("row(%d)=%p ", rowFrame->GetRowIndex(),
37269:              static_cast<void*>(rowFrame));
26583:       nsIFrame* childFrame = cFrame->GetFirstChild(nsnull);
26583:       while (childFrame) {
26583:         nsTableCellFrame *cellFrame = do_QueryFrame(childFrame);
26583:         if (cellFrame) {
    1:           PRInt32 colIndex;
26583:           cellFrame->GetColIndex(colIndex);
37834:           printf("cell(%d)=%p ", colIndex, static_cast<void*>(childFrame));
26583:         }
26583:         childFrame = childFrame->GetNextSibling();
    1:       }
    1:       printf("\n");
    1:     }
    1:     else {
    1:       DumpRowGroup(rowFrame);
    1:     }
26583:     cFrame = cFrame->GetNextSibling();
    1:   }
    1: }
    1: 
    1: void
    1: nsTableFrame::Dump(PRBool          aDumpRows,
    1:                    PRBool          aDumpCols,
    1:                    PRBool          aDumpCellMap)
    1: {
    1:   printf("***START TABLE DUMP*** \n");
    1:   // dump the columns widths array
    1:   printf("mColWidths=");
    1:   PRInt32 numCols = GetColCount();
    1:   PRInt32 colX;
    1:   for (colX = 0; colX < numCols; colX++) {
    1:     printf("%d ", GetColumnWidth(colX));
    1:   }
    1:   printf("\n");
    1: 
    1:   if (aDumpRows) {
    1:     nsIFrame* kidFrame = mFrames.FirstChild();
    1:     while (kidFrame) {
    1:       DumpRowGroup(kidFrame);
    1:       kidFrame = kidFrame->GetNextSibling();
    1:     }
    1:   }
    1: 
    1:   if (aDumpCols) {
    1: 	  // output col frame cache
    1:     printf("\n col frame cache ->");
    1: 	   for (colX = 0; colX < numCols; colX++) {
24724:       nsTableColFrame* colFrame = mColFrames.ElementAt(colX);
    1:       if (0 == (colX % 8)) {
    1:         printf("\n");
    1:       }
37269:       printf ("%d=%p ", colX, static_cast<void*>(colFrame));
    1:       nsTableColType colType = colFrame->GetColType();
    1:       switch (colType) {
    1:       case eColContent:
    1:         printf(" content ");
    1:         break;
    1:       case eColAnonymousCol:
    1:         printf(" anonymous-column ");
    1:         break;
    1:       case eColAnonymousColGroup:
    1:         printf(" anonymous-colgroup ");
    1:         break;
    1:       case eColAnonymousCell:
    1:         printf(" anonymous-cell ");
    1:         break;
    1:       }
    1:     }
    1:     printf("\n colgroups->");
    1:     for (nsIFrame* childFrame = mColGroups.FirstChild(); childFrame;
    1:          childFrame = childFrame->GetNextSibling()) {
    1:       if (nsGkAtoms::tableColGroupFrame == childFrame->GetType()) {
    1:         nsTableColGroupFrame* colGroupFrame = (nsTableColGroupFrame *)childFrame;
    1:         colGroupFrame->Dump(1);
    1:       }
    1:     }
    1:     for (colX = 0; colX < numCols; colX++) {
    1:       printf("\n");
    1:       nsTableColFrame* colFrame = GetColFrame(colX);
    1:       colFrame->Dump(1);
    1:     }
    1:   }
    1:   if (aDumpCellMap) {
    1:     nsTableCellMap* cellMap = GetCellMap();
    1:     cellMap->Dump();
    1:   }
    1:   printf(" ***END TABLE DUMP*** \n");
    1: }
    1: #endif
    1: 
    1: // nsTableIterator
    1: nsTableIterator::nsTableIterator(nsIFrame& aSource)
    1: {
    1:   nsIFrame* firstChild = aSource.GetFirstChild(nsnull);
    1:   Init(firstChild);
    1: }
    1: 
    1: nsTableIterator::nsTableIterator(nsFrameList& aSource)
    1: {
    1:   nsIFrame* firstChild = aSource.FirstChild();
    1:   Init(firstChild);
    1: }
    1: 
    1: void nsTableIterator::Init(nsIFrame* aFirstChild)
    1: {
    1:   mFirstListChild = aFirstChild;
    1:   mFirstChild     = aFirstChild;
    1:   mCurrentChild   = nsnull;
    1:   mLeftToRight    = PR_TRUE;
    1:   mCount          = -1;
    1: 
    1:   if (!mFirstChild) {
    1:     return;
    1:   }
    1: 
    1:   nsTableFrame* table = nsTableFrame::GetTableFrame(mFirstChild);
    1:   if (table) {
    1:     mLeftToRight = (NS_STYLE_DIRECTION_LTR ==
    1:                     table->GetStyleVisibility()->mDirection);
    1:   }
    1:   else {
    1:     NS_NOTREACHED("source of table iterator is not part of a table");
    1:     return;
    1:   }
    1: 
    1:   if (!mLeftToRight) {
    1:     mCount = 0;
    1:     nsIFrame* nextChild = mFirstChild->GetNextSibling();
    1:     while (nsnull != nextChild) {
    1:       mCount++;
    1:       mFirstChild = nextChild;
    1:       nextChild = nextChild->GetNextSibling();
    1:     }
    1:   }
    1: }
    1: 
    1: nsIFrame* nsTableIterator::First()
    1: {
    1:   mCurrentChild = mFirstChild;
    1:   return mCurrentChild;
    1: }
    1: 
    1: nsIFrame* nsTableIterator::Next()
    1: {
    1:   if (!mCurrentChild) {
    1:     return nsnull;
    1:   }
    1: 
    1:   if (mLeftToRight) {
    1:     mCurrentChild = mCurrentChild->GetNextSibling();
    1:     return mCurrentChild;
    1:   }
    1:   else {
    1:     nsIFrame* targetChild = mCurrentChild;
    1:     mCurrentChild = nsnull;
    1:     nsIFrame* child = mFirstListChild;
    1:     while (child && (child != targetChild)) {
    1:       mCurrentChild = child;
    1:       child = child->GetNextSibling();
    1:     }
    1:     return mCurrentChild;
    1:   }
    1: }
    1: 
    1: PRBool nsTableIterator::IsLeftToRight()
    1: {
    1:   return mLeftToRight;
    1: }
    1: 
    1: PRInt32 nsTableIterator::Count()
    1: {
    1:   if (-1 == mCount) {
    1:     mCount = 0;
    1:     nsIFrame* child = mFirstListChild;
    1:     while (nsnull != child) {
    1:       mCount++;
    1:       child = child->GetNextSibling();
    1:     }
    1:   }
    1:   return mCount;
    1: }
    1: 
    1: /*------------------ nsITableLayout methods ------------------------------*/
    1: NS_IMETHODIMP
    1: nsTableFrame::GetCellDataAt(PRInt32        aRowIndex,
    1:                             PRInt32        aColIndex,
    1:                             nsIDOMElement* &aCell,   //out params
    1:                             PRInt32&       aStartRowIndex,
    1:                             PRInt32&       aStartColIndex,
    1:                             PRInt32&       aRowSpan,
    1:                             PRInt32&       aColSpan,
    1:                             PRInt32&       aActualRowSpan,
    1:                             PRInt32&       aActualColSpan,
    1:                             PRBool&        aIsSelected)
    1: {
    1:   // Initialize out params
    1:   aCell = nsnull;
    1:   aStartRowIndex = 0;
    1:   aStartColIndex = 0;
    1:   aRowSpan = 0;
    1:   aColSpan = 0;
    1:   aIsSelected = PR_FALSE;
    1: 
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   if (!cellMap) { return NS_ERROR_NOT_INITIALIZED;}
    1: 
    1:   PRBool originates;
    1:   PRInt32 colSpan; // Is this the "effective" or "html" value?
    1: 
    1:   nsTableCellFrame *cellFrame = cellMap->GetCellInfoAt(aRowIndex, aColIndex, &originates, &colSpan);
    1:   if (!cellFrame) return NS_TABLELAYOUT_CELL_NOT_FOUND;
    1: 
    1:   nsresult result= cellFrame->GetRowIndex(aStartRowIndex);
    1:   if (NS_FAILED(result)) return result;
    1:   result = cellFrame->GetColIndex(aStartColIndex);
    1:   if (NS_FAILED(result)) return result;
    1:   //This returns HTML value, which may be 0
    1:   aRowSpan = cellFrame->GetRowSpan();
    1:   aColSpan = cellFrame->GetColSpan();
    1:   aActualRowSpan = GetEffectiveRowSpan(*cellFrame);
    1:   aActualColSpan = GetEffectiveColSpan(*cellFrame);
    1: 
    1:   // If these aren't at least 1, we have a cellmap error
    1:   if (aActualRowSpan == 0 || aActualColSpan == 0)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   result = cellFrame->GetSelected(&aIsSelected);
    1:   if (NS_FAILED(result)) return result;
    1: 
    1:   // do this last, because it addrefs,
    1:   // and we don't want the caller leaking it on error
    1:   nsIContent* content = cellFrame->GetContent();
    1:   if (!content) return NS_ERROR_FAILURE;
    1: 
    1:   return CallQueryInterface(content, &aCell);
    1: }
    1: 
    1: NS_IMETHODIMP nsTableFrame::GetTableSize(PRInt32& aRowCount, PRInt32& aColCount)
    1: {
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   // Initialize out params
    1:   aRowCount = 0;
    1:   aColCount = 0;
    1:   if (!cellMap) { return NS_ERROR_NOT_INITIALIZED;}
    1: 
    1:   aRowCount = cellMap->GetRowCount();
    1:   aColCount = cellMap->GetColCount();
    1:   return NS_OK;
    1: }
    1: 
11311: NS_IMETHODIMP
11311: nsTableFrame::GetIndexByRowAndColumn(PRInt32 aRow, PRInt32 aColumn,
11311:                                      PRInt32 *aIndex)
11311: {
11311:   NS_ENSURE_ARG_POINTER(aIndex);
11311:   *aIndex = -1;
11311: 
11311:   nsTableCellMap* cellMap = GetCellMap();
11311:   if (!cellMap)
11311:     return NS_ERROR_NOT_INITIALIZED;
11311: 
11311:   *aIndex = cellMap->GetIndexByRowAndColumn(aRow, aColumn);
29821:   return (*aIndex == -1) ? NS_TABLELAYOUT_CELL_NOT_FOUND : NS_OK;
11311: }
11311: 
11311: NS_IMETHODIMP
11311: nsTableFrame::GetRowAndColumnByIndex(PRInt32 aIndex,
11311:                                     PRInt32 *aRow, PRInt32 *aColumn)
11311: {
11311:   NS_ENSURE_ARG_POINTER(aRow);
11311:   *aRow = -1;
11311: 
11311:   NS_ENSURE_ARG_POINTER(aColumn);
11311:   *aColumn = -1;
11311: 
11311:   nsTableCellMap* cellMap = GetCellMap();
11311:   if (!cellMap)
11311:     return NS_ERROR_NOT_INITIALIZED;
11311: 
11311:   cellMap->GetRowAndColumnByIndex(aIndex, aRow, aColumn);
11311:   return NS_OK;
11311: }
11311: 
    1: /*---------------- end of nsITableLayout implementation ------------------*/
    1: 
19643: PRBool
19643: nsTableFrame::ColumnHasCellSpacingBefore(PRInt32 aColIndex) const
19643: {
19643:   // Since fixed-layout tables should not have their column sizes change
19643:   // as they load, we assume that all columns are significant.
19643:   if (LayoutStrategy()->GetType() == nsITableLayoutStrategy::Fixed)
19643:     return PR_TRUE;
27451:   // the first column is always significant
27451:   if (aColIndex == 0)
27451:     return PR_TRUE;
    1:   nsTableCellMap* cellMap = GetCellMap();
19643:   if (!cellMap)
19643:     return PR_FALSE;
19643:   return cellMap->GetNumCellsOriginatingInCol(aColIndex) > 0;
    1: }
    1: 
    1: static void
    1: CheckFixDamageArea(PRInt32 aNumRows,
    1:                    PRInt32 aNumCols,
    1:                    nsRect& aDamageArea)
    1: {
    1:   if (((aDamageArea.XMost() > aNumCols) && (aDamageArea.width  != 1) && (aNumCols != 0)) ||
    1:       ((aDamageArea.YMost() > aNumRows) && (aDamageArea.height != 1) && (aNumRows != 0))) {
    1:     // the damage area was set incorrectly, just be safe and make it the entire table
    1:     NS_ASSERTION(PR_FALSE, "invalid BC damage area");
    1:     aDamageArea.x      = 0;
    1:     aDamageArea.y      = 0;
    1:     aDamageArea.width  = aNumCols;
    1:     aDamageArea.height = aNumRows;
    1:   }
    1: }
    1: 
    1: /********************************************************************************
    1:  * Collapsing Borders
    1:  *
    1:  *  The CSS spec says to resolve border conflicts in this order:
    1:  *  1) any border with the style HIDDEN wins
    1:  *  2) the widest border with a style that is not NONE wins
    1:  *  3) the border styles are ranked in this order, highest to lowest precedence:
    1:  *     double, solid, dashed, dotted, ridge, outset, groove, inset
    1:  *  4) borders that are of equal width and style (differ only in color) have this precedence:
    1:  *     cell, row, rowgroup, col, colgroup, table
    1:  *  5) if all border styles are NONE, then that's the computed border style.
    1:  *******************************************************************************/
    1: 
    1: void
    1: nsTableFrame::SetBCDamageArea(const nsRect& aValue)
    1: {
    1:   nsRect newRect(aValue);
32531:   newRect.width  = NS_MAX(1, newRect.width);
32531:   newRect.height = NS_MAX(1, newRect.height);
    1: 
    1:   if (!IsBorderCollapse()) {
    1:     NS_ASSERTION(PR_FALSE, "invalid call - not border collapse model");
    1:     return;
    1:   }
    1:   SetNeedToCalcBCBorders(PR_TRUE);
    1:   // Get the property
39965:   FrameProperties props = Properties();
39965:   BCPropertyData* value = static_cast<BCPropertyData*>
39965:     (props.Get(TableBCProperty()));
39965:   if (!value) {
39965:     value = new BCPropertyData();
39965:     props.Set(TableBCProperty(), value);
39965:   }
    1:   // for now just construct a union of the new and old damage areas
    1:   value->mDamageArea.UnionRect(value->mDamageArea, newRect);
    1:   CheckFixDamageArea(GetRowCount(), GetColCount(), value->mDamageArea);
    1: }
29425: 
29425: /* BCCellBorder represents a border segment which can be either a horizontal
29425:  * or a vertical segment. For each segment we need to know the color, width,
29425:  * style, who owns it and how long it is in cellmap coordinates.
29425:  * Ownership of these segments is important to calculate which corners should
29425:  * be bevelled. This structure has dual use, its used first to compute the
29425:  * dominant border for horizontal and vertical segments and to store the
29425:  * preliminary computed border results in the BCCellBorders structure.
29425:  * This temporary storage is not symmetric with respect to horizontal and
29425:  * vertical border segments, its always column oriented. For each column in
29425:  * the cellmap there is a temporary stored vertical and horizontal segment.
29425:  * XXX_Bernd this asymmetry is the root of those rowspan bc border errors
29425:  */
29425: struct BCCellBorder
29425: {
29425:   BCCellBorder() { Reset(0, 1); }
29425:   void Reset(PRUint32 aRowIndex, PRUint32 aRowSpan);
29425:   nscolor       color;    // border segment color
29425:   BCPixelSize   width;    // border segment width in pixel coordinates !!
29425:   PRUint8       style;    // border segment style, possible values are defined
29425:                           // in nsStyleConsts.h as NS_STYLE_BORDER_STYLE_*
29425:   BCBorderOwner owner;    // border segment owner, possible values are defined
29425:                           // in celldata.h. In the cellmap for each border
29425:                           // segment we store the owner and later when
29425:                           // painting we know the owner and can retrieve the
29425:                           // style info from the corresponding frame
29425:   PRInt32       rowIndex; // rowIndex of temporary stored horizontal border
29425:                           // segments relative to the table
29425:   PRInt32       rowSpan;  // row span of temporary stored horizontal border
29425:                           // segments
29425: };
29425: 
29425: void
29425: BCCellBorder::Reset(PRUint32 aRowIndex,
29425:                     PRUint32 aRowSpan)
29425: {
29425:   style = NS_STYLE_BORDER_STYLE_NONE;
29425:   color = 0;
29425:   width = 0;
29425:   owner = eTableOwner;
29425:   rowIndex = aRowIndex;
29425:   rowSpan  = aRowSpan;
29425: }
29425: 
29425: class BCMapCellIterator;
29425: 
    1: /*****************************************************************
29425:  *  BCMapCellInfo
29425:  * This structure stores information about the cellmap and all involved
29425:  * table related frames that are used during the computation of winning borders
29425:  * in CalcBCBorders so that they do need to be looked up again and again when
29425:  * iterating over the cells.
    1:  ****************************************************************/
    1: struct BCMapCellInfo
    1: {
29425:   BCMapCellInfo(nsTableFrame* aTableFrame);
29425:   void ResetCellInfo();
29425:   void SetInfo(nsTableRowFrame*   aNewRow,
29425:                PRInt32            aColIndex,
29425:                BCCellData*        aCellData,
29425:                BCMapCellIterator* aIter,
29425:                nsCellMap*         aCellMap = nsnull);
29425:   // The BCMapCellInfo has functions to set the continous
29425:   // border widths (see nsTablePainter.cpp for a description of the continous
29425:   // borders concept). The widths are computed inside these functions based on
29425:   // the current position inside the table and the cached frames that correspond
29425:   // to this position. The widths are stored in member variables of the internal
29425:   // table frames.
29425:   void SetTableTopLeftContBCBorder();
29425:   void SetRowGroupLeftContBCBorder();
29425:   void SetRowGroupRightContBCBorder();
29425:   void SetRowGroupBottomContBCBorder();
29425:   void SetRowLeftContBCBorder();
29425:   void SetRowRightContBCBorder();
29425:   void SetColumnTopRightContBCBorder();
29425:   void SetColumnBottomContBCBorder();
29425:   void SetColGroupBottomContBCBorder();
29425:   void SetInnerRowGroupBottomContBCBorder(const nsIFrame* aNextRowGroup,
29425:                                           nsTableRowFrame* aNextRow);
29425: 
29425:   // functions to set the border widths on the table related frames, where the
29425:   // knowledge about the current position in the table is used.
29425:   void SetTableTopBorderWidth(BCPixelSize aWidth);
29425:   void SetTableLeftBorderWidth(PRInt32 aRowY, BCPixelSize aWidth);
29425:   void SetTableRightBorderWidth(PRInt32 aRowY, BCPixelSize aWidth);
29425:   void SetTableBottomBorderWidth(BCPixelSize aWidth);
29425:   void SetLeftBorderWidths(BCPixelSize aWidth);
29425:   void SetRightBorderWidths(BCPixelSize aWidth);
29425:   void SetTopBorderWidths(BCPixelSize aWidth);
29425:   void SetBottomBorderWidths(BCPixelSize aWidth);
29425: 
29425:   // functions to compute the borders; they depend on the
29425:   // knowledge about the current position in the table. The edge functions
29425:   // should be called if a table edge is involved, otherwise the internal
29425:   // functions should be called.
29425:   BCCellBorder GetTopEdgeBorder();
29425:   BCCellBorder GetBottomEdgeBorder();
29425:   BCCellBorder GetLeftEdgeBorder();
29425:   BCCellBorder GetRightEdgeBorder();
29425:   BCCellBorder GetRightInternalBorder();
29425:   BCCellBorder GetLeftInternalBorder();
29425:   BCCellBorder GetTopInternalBorder();
29425:   BCCellBorder GetBottomInternalBorder();
29425: 
29425:   // functions to set the interal position information
29425:   void SetColumn(PRInt32 aColX);
29425:   // Increment the row as we loop over the rows of a rowspan
29425:   void IncrementRow(PRBool aResetToTopRowOfCell = PR_FALSE);
29425: 
29425:   // Helper functions to get extent of the cell
29425:   PRInt32 GetCellEndRowIndex() const;
29425:   PRInt32 GetCellEndColIndex() const;
29425: 
29425:   // storage of table information
29425:   nsTableFrame*         mTableFrame;
29425:   PRInt32               mNumTableRows;
29425:   PRInt32               mNumTableCols;
29425:   BCPropertyData*       mTableBCData;
29425: 
29425:   // storage of table ltr information, the border collapse code swaps the sides
29425:   // to account for rtl tables, this is done through mStartSide and mEndSide
29425:   PRPackedBool          mTableIsLTR;
41419:   mozilla::css::Side    mStartSide;
41419:   mozilla::css::Side    mEndSide;
29425: 
29425:   // a cell can only belong to one rowgroup
29425:   nsTableRowGroupFrame* mRowGroup;
29425: 
29425:   // a cell with a rowspan has a top and a bottom row, and rows in between
29425:   nsTableRowFrame*      mTopRow;
29425:   nsTableRowFrame*      mBottomRow;
29425:   nsTableRowFrame*      mCurrentRowFrame;
29425: 
29425:   // a cell with a colspan has a left and right column and columns in between
29425:   // they can belong to different colgroups
29425:   nsTableColGroupFrame* mColGroup;
29425:   nsTableColGroupFrame* mCurrentColGroupFrame;
29425: 
29425:   nsTableColFrame*      mLeftCol;
29425:   nsTableColFrame*      mRightCol;
29425:   nsTableColFrame*      mCurrentColFrame;
29425: 
29425:   // cell information
29425:   BCCellData*           mCellData;
29425:   nsBCTableCellFrame*   mCell;
29425: 
29425:   PRInt32               mRowIndex;
29425:   PRInt32               mRowSpan;
29425:   PRInt32               mColIndex;
29425:   PRInt32               mColSpan;
29425: 
29425:   // flags to describe the position of the cell with respect to the row- and
29425:   // colgroups, for instance mRgAtTop documents that the top cell border hits
29425:   // a rowgroup border
29425:   PRPackedBool          mRgAtTop;
29425:   PRPackedBool          mRgAtBottom;
29425:   PRPackedBool          mCgAtLeft;
29425:   PRPackedBool          mCgAtRight;
29425: 
    1: };
    1: 
29425: 
29425: BCMapCellInfo::BCMapCellInfo(nsTableFrame* aTableFrame)
29425: {
29425:   mTableFrame = aTableFrame;
29425:   mTableIsLTR =
29425:     aTableFrame->GetStyleVisibility()->mDirection == NS_STYLE_DIRECTION_LTR;
29425:   if (mTableIsLTR) {
29425:     mStartSide = NS_SIDE_LEFT;
29425:     mEndSide = NS_SIDE_RIGHT;
29425:   }
29425:   else {
29425:     mStartSide = NS_SIDE_RIGHT;
29425:     mEndSide = NS_SIDE_LEFT;
29425:   }
29425:   mNumTableRows = mTableFrame->GetRowCount();
29425:   mNumTableCols = mTableFrame->GetColCount();
39965:   mTableBCData = static_cast<BCPropertyData*>
39965:     (mTableFrame->Properties().Get(TableBCProperty()));
29425: 
29425:   ResetCellInfo();
29425: }
29425: 
29425: void BCMapCellInfo::ResetCellInfo()
29425: {
29425:   mCellData  = nsnull;
29425:   mRowGroup  = nsnull;
29425:   mTopRow    = nsnull;
29425:   mBottomRow = nsnull;
29425:   mColGroup  = nsnull;
29425:   mLeftCol   = nsnull;
29425:   mRightCol  = nsnull;
29425:   mCell      = nsnull;
29425:   mRowIndex  = mRowSpan = mColIndex = mColSpan = 0;
29425:   mRgAtTop = mRgAtBottom = mCgAtLeft = mCgAtRight = PR_FALSE;
29425: }
29425: 
29425: inline PRInt32 BCMapCellInfo::GetCellEndRowIndex() const
29425: {
29425:   return mRowIndex + mRowSpan - 1;
29425: }
29425: 
29425: inline PRInt32 BCMapCellInfo::GetCellEndColIndex() const
29425: {
29425:   return mColIndex + mColSpan - 1;
29425: }
29425: 
    1: 
    1: class BCMapCellIterator
    1: {
    1: public:
29425:   BCMapCellIterator(nsTableFrame* aTableFrame,
    1:                     const nsRect& aDamageArea);
    1: 
    1:   void First(BCMapCellInfo& aMapCellInfo);
    1: 
    1:   void Next(BCMapCellInfo& aMapCellInfo);
    1: 
    1:   void PeekRight(BCMapCellInfo& aRefInfo,
    1:                  PRUint32     aRowIndex,
    1:                  BCMapCellInfo& aAjaInfo);
    1: 
    1:   void PeekBottom(BCMapCellInfo& aRefInfo,
    1:                   PRUint32     aColIndex,
    1:                   BCMapCellInfo& aAjaInfo);
    1: 
    1:   PRBool IsNewRow() { return mIsNewRow; }
    1: 
    1:   nsTableRowFrame* GetPrevRow() const { return mPrevRow; }
29425:   nsTableRowFrame* GetCurrentRow() const { return mRow; }
29425:   nsTableRowGroupFrame* GetCurrentRowGroup() const { return mRowGroup;}
    1: 
    1:   PRInt32    mRowGroupStart;
    1:   PRInt32    mRowGroupEnd;
    1:   PRBool     mAtEnd;
    1:   nsCellMap* mCellMap;
    1: 
    1: private:
    1:   PRBool SetNewRow(nsTableRowFrame* row = nsnull);
    1:   PRBool SetNewRowGroup(PRBool aFindFirstDamagedRow);
    1: 
29425:   nsTableFrame*         mTableFrame;
    1:   nsTableCellMap*       mTableCellMap;
 2141:   nsTableFrame::RowGroupArray mRowGroups;
    1:   nsTableRowGroupFrame* mRowGroup;
    1:   PRInt32               mRowGroupIndex;
29425:   PRUint32              mNumTableRows;
    1:   nsTableRowFrame*      mRow;
    1:   nsTableRowFrame*      mPrevRow;
    1:   PRBool                mIsNewRow;
    1:   PRInt32               mRowIndex;
29425:   PRUint32              mNumTableCols;
    1:   PRInt32               mColIndex;
    1:   nsPoint               mAreaStart;
    1:   nsPoint               mAreaEnd;
    1: };
    1: 
29425: BCMapCellIterator::BCMapCellIterator(nsTableFrame* aTableFrame,
    1:                                      const nsRect& aDamageArea)
    1: :mTableFrame(aTableFrame)
    1: {
29425:   mTableCellMap  = aTableFrame->GetCellMap();
    1: 
    1:   mAreaStart.x   = aDamageArea.x;
    1:   mAreaStart.y   = aDamageArea.y;
    1:   mAreaEnd.y     = aDamageArea.y + aDamageArea.height - 1;
    1:   mAreaEnd.x     = aDamageArea.x + aDamageArea.width - 1;
    1: 
29425:   mNumTableRows  = mTableFrame->GetRowCount();
    1:   mRow           = nsnull;
    1:   mRowIndex      = 0;
29425:   mNumTableCols  = mTableFrame->GetColCount();
    1:   mColIndex      = 0;
    1:   mRowGroupIndex = -1;
    1: 
    1:   // Get the ordered row groups
29425:   aTableFrame->OrderRowGroups(mRowGroups);
    1: 
    1:   mAtEnd = PR_TRUE; // gets reset when First() is called
    1: }
    1: 
29425: // fill fields that we need for border collapse computation on a given cell
    1: void
29425: BCMapCellInfo::SetInfo(nsTableRowFrame*   aNewRow,
    1:                        PRInt32            aColIndex,
29425:                        BCCellData*        aCellData,
29425:                        BCMapCellIterator* aIter,
    1:                        nsCellMap*         aCellMap)
    1: {
29425:   // fill the cell information
29425:   mCellData = aCellData;
29425:   mColIndex = aColIndex;
29425: 
29425:   // initialize the row information if it was not previously set for cells in
29425:   // this row
29425:   mRowIndex = 0;
29425:   if (aNewRow) {
29425:     mTopRow = aNewRow;
29425:     mRowIndex = aNewRow->GetRowIndex();
29425:   }
29425: 
29425:   // fill cell frame info and row information
29425:   mCell      = nsnull;
29425:   mRowSpan   = 1;
29425:   mColSpan   = 1;
    1:   if (aCellData) {
29425:     mCell = static_cast<nsBCTableCellFrame*>(aCellData->GetCellFrame());
29425:     if (mCell) {
29425:       if (!mTopRow) {
29425:         mTopRow = static_cast<nsTableRowFrame*>(mCell->GetParent());
29425:         if (!mTopRow) ABORT0();
29425:         mRowIndex = mTopRow->GetRowIndex();
29425:       }
29425:       mColSpan = mTableFrame->GetEffectiveColSpan(*mCell, aCellMap);
29425:       mRowSpan = mTableFrame->GetEffectiveRowSpan(*mCell, aCellMap);
29425:     }
29425:   }
29425: 
29425:   if (!mTopRow) {
29425:     mTopRow = aIter->GetCurrentRow();
29425:   }
29425:   if (1 == mRowSpan) {
29425:     mBottomRow = mTopRow;
    1:   }
    1:   else {
29425:     mBottomRow = mTopRow->GetNextRow();
29425:     if (mBottomRow) {
29425:       for (PRInt32 spanY = 2; mBottomRow && (spanY < mRowSpan); spanY++) {
29425:         mBottomRow = mBottomRow->GetNextRow();
29425:       }
29425:       NS_ASSERTION(mBottomRow, "spanned row not found");
    1:     }
    1:     else {
    1:       NS_ASSERTION(PR_FALSE, "error in cell map");
29425:       mRowSpan = 1;
29425:       mBottomRow = mTopRow;
29425:     }
29425:   }
    1:   // row group frame info
29425:   // try to reuse the rgStart and rgEnd from the iterator as calls to
29425:   // GetRowCount() are computationally expensive and should be avoided if
29425:   // possible
29425:   PRUint32 rgStart  = aIter->mRowGroupStart;
29425:   PRUint32 rgEnd    = aIter->mRowGroupEnd;
37262:   mRowGroup = static_cast<nsTableRowGroupFrame*>(mTopRow->GetParent());
29425:   if (mRowGroup != aIter->GetCurrentRowGroup()) {
29425:     rgStart = mRowGroup->GetStartRowIndex();
29425:     rgEnd   = rgStart + mRowGroup->GetRowCount() - 1;
29425:   }
29425:   PRUint32 rowIndex = mTopRow->GetRowIndex();
29425:   mRgAtTop    = (rgStart == rowIndex);
29425:   mRgAtBottom = (rgEnd == rowIndex + mRowSpan - 1);
    1: 
    1:    // col frame info
29425:   mLeftCol = mTableFrame->GetColFrame(aColIndex);
29425:   if (!mLeftCol) ABORT0();
29425: 
29425:   mRightCol = mLeftCol;
29425:   if (mColSpan > 1) {
29425:     nsTableColFrame* colFrame = mTableFrame->GetColFrame(aColIndex +
29425:                                                          mColSpan -1);
29425:     if (!colFrame) ABORT0();
29425:     mRightCol = colFrame;
    1:   }
    1: 
    1:   // col group frame info
29425:   mColGroup = static_cast<nsTableColGroupFrame*>(mLeftCol->GetParent());
29425:   PRInt32 cgStart = mColGroup->GetStartColumnIndex();
32531:   PRInt32 cgEnd = NS_MAX(0, cgStart + mColGroup->GetColCount() - 1);
29425:   mCgAtLeft  = (cgStart == aColIndex);
29425:   mCgAtRight = (cgEnd == aColIndex + mColSpan - 1);
    1: }
    1: 
    1: PRBool
    1: BCMapCellIterator::SetNewRow(nsTableRowFrame* aRow)
    1: {
    1:   mAtEnd   = PR_TRUE;
    1:   mPrevRow = mRow;
    1:   if (aRow) {
    1:     mRow = aRow;
    1:   }
    1:   else if (mRow) {
    1:     mRow = mRow->GetNextRow();
    1:   }
    1:   if (mRow) {
    1:     mRowIndex = mRow->GetRowIndex();
    1:     // get to the first entry with an originating cell
    1:     PRInt32 rgRowIndex = mRowIndex - mRowGroupStart;
    1:     if (PRUint32(rgRowIndex) >= mCellMap->mRows.Length())
    1:       ABORT1(PR_FALSE);
    1:     const nsCellMap::CellDataArray& row = mCellMap->mRows[rgRowIndex];
    1: 
    1:     for (mColIndex = mAreaStart.x; mColIndex <= mAreaEnd.x; mColIndex++) {
    1:       CellData* cellData = row.SafeElementAt(mColIndex);
    1:       if (!cellData) { // add a dead cell data
    1:         nsRect damageArea;
    1:         cellData = mCellMap->AppendCell(*mTableCellMap, nsnull, rgRowIndex, PR_FALSE, damageArea); if (!cellData) ABORT1(PR_FALSE);
    1:       }
    1:       if (cellData && (cellData->IsOrig() || cellData->IsDead())) {
    1:         break;
    1:       }
    1:     }
    1:     mIsNewRow = PR_TRUE;
    1:     mAtEnd    = PR_FALSE;
    1:   }
    1:   else ABORT1(PR_FALSE);
    1: 
    1:   return !mAtEnd;
    1: }
    1: 
    1: PRBool
    1: BCMapCellIterator::SetNewRowGroup(PRBool aFindFirstDamagedRow)
    1: {
    1:    mAtEnd = PR_TRUE;
 2141:   PRInt32 numRowGroups = mRowGroups.Length();
    1:   mCellMap = nsnull;
 9141:   for (mRowGroupIndex++; mRowGroupIndex < numRowGroups; mRowGroupIndex++) {
 2141:     mRowGroup = mRowGroups[mRowGroupIndex];
    1:     PRInt32 rowCount = mRowGroup->GetRowCount();
    1:     mRowGroupStart = mRowGroup->GetStartRowIndex();
    1:     mRowGroupEnd   = mRowGroupStart + rowCount - 1;
 9141:     if (rowCount > 0) {
    1:       mCellMap = mTableCellMap->GetMapFor(mRowGroup, mCellMap);
    1:       if (!mCellMap) ABORT1(PR_FALSE);
    1:       nsTableRowFrame* firstRow = mRowGroup->GetFirstRow();
    1:       if (aFindFirstDamagedRow) {
    1:         if ((mAreaStart.y >= mRowGroupStart) && (mAreaStart.y <= mRowGroupEnd)) {
    1:           // the damage area starts in the row group
    1:           if (aFindFirstDamagedRow) {
    1:             // find the correct first damaged row
    1:             PRInt32 numRows = mAreaStart.y - mRowGroupStart;
    1:             for (PRInt32 i = 0; i < numRows; i++) {
 2141:               firstRow = firstRow->GetNextRow();
 2141:               if (!firstRow) ABORT1(PR_FALSE);
    1:             }
    1:           }
    1:         }
    1:         else {
    1:           continue;
    1:         }
    1:       }
    1:       if (SetNewRow(firstRow)) { // sets mAtEnd
    1:         break;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return !mAtEnd;
    1: }
    1: 
    1: void
    1: BCMapCellIterator::First(BCMapCellInfo& aMapInfo)
    1: {
29425:   aMapInfo.ResetCellInfo();
    1: 
    1:   SetNewRowGroup(PR_TRUE); // sets mAtEnd
    1:   while (!mAtEnd) {
    1:     if ((mAreaStart.y >= mRowGroupStart) && (mAreaStart.y <= mRowGroupEnd)) {
29425:       BCCellData* cellData =
29425:         static_cast<BCCellData*>(mCellMap->GetDataAt(mAreaStart.y -
29425:                                                       mRowGroupStart,
29425:                                                       mAreaStart.x));
64009:       if (cellData && (cellData->IsOrig() || cellData->IsDead())) {
29425:         aMapInfo.SetInfo(mRow, mAreaStart.x, cellData, this);
64009:         return;
    1:       }
    1:       else {
29425:         NS_ASSERTION(((0 == mAreaStart.x) && (mRowGroupStart == mAreaStart.y)) ,
29425:                      "damage area expanded incorrectly");
64009:       }
    1:     }
    1:     SetNewRowGroup(PR_TRUE); // sets mAtEnd
    1:   }
    1: }
    1: 
    1: void
    1: BCMapCellIterator::Next(BCMapCellInfo& aMapInfo)
    1: {
    1:   if (mAtEnd) ABORT0();
29425:   aMapInfo.ResetCellInfo();
    1: 
    1:   mIsNewRow = PR_FALSE;
    1:   mColIndex++;
    1:   while ((mRowIndex <= mAreaEnd.y) && !mAtEnd) {
    1:     for (; mColIndex <= mAreaEnd.x; mColIndex++) {
    1:       PRInt32 rgRowIndex = mRowIndex - mRowGroupStart;
29425:       BCCellData* cellData =
29425:          static_cast<BCCellData*>(mCellMap->GetDataAt(rgRowIndex, mColIndex));
    1:       if (!cellData) { // add a dead cell data
    1:         nsRect damageArea;
29425:         cellData =
29425:           static_cast<BCCellData*>(mCellMap->AppendCell(*mTableCellMap, nsnull,
29425:                                                          rgRowIndex, PR_FALSE,
29425:                                                          damageArea));
29425:         if (!cellData) ABORT0();
    1:       }
    1:       if (cellData && (cellData->IsOrig() || cellData->IsDead())) {
29425:         aMapInfo.SetInfo(mRow, mColIndex, cellData, this);
    1:         return;
    1:       }
    1:     }
    1:     if (mRowIndex >= mRowGroupEnd) {
    1:       SetNewRowGroup(PR_FALSE); // could set mAtEnd
    1:     }
    1:     else {
    1:       SetNewRow(); // could set mAtEnd
    1:     }
    1:   }
    1:   mAtEnd = PR_TRUE;
    1: }
    1: 
    1: void
    1: BCMapCellIterator::PeekRight(BCMapCellInfo&   aRefInfo,
    1:                              PRUint32         aRowIndex,
    1:                              BCMapCellInfo&   aAjaInfo)
    1: {
29425:   aAjaInfo.ResetCellInfo();
29425:   PRInt32 colIndex = aRefInfo.mColIndex + aRefInfo.mColSpan;
    1:   PRUint32 rgRowIndex = aRowIndex - mRowGroupStart;
    1: 
29425:   BCCellData* cellData =
29425:     static_cast<BCCellData*>(mCellMap->GetDataAt(rgRowIndex, colIndex));
    1:   if (!cellData) { // add a dead cell data
    1:     NS_ASSERTION(colIndex < mTableCellMap->GetColCount(), "program error");
    1:     nsRect damageArea;
29425:     cellData =
29425:       static_cast<BCCellData*>(mCellMap->AppendCell(*mTableCellMap, nsnull,
29425:                                                      rgRowIndex, PR_FALSE,
29425:                                                      damageArea));
29425:     if (!cellData) ABORT0();
    1:   }
    1:   nsTableRowFrame* row = nsnull;
    1:   if (cellData->IsRowSpan()) {
    1:     rgRowIndex -= cellData->GetRowSpanOffset();
29425:     cellData =
29425:       static_cast<BCCellData*>(mCellMap->GetDataAt(rgRowIndex, colIndex));
    1:     if (!cellData)
    1:       ABORT0();
    1:   }
    1:   else {
    1:     row = mRow;
    1:   }
29425:   aAjaInfo.SetInfo(row, colIndex, cellData, this);
    1: }
    1: 
    1: void
    1: BCMapCellIterator::PeekBottom(BCMapCellInfo&   aRefInfo,
    1:                               PRUint32         aColIndex,
    1:                               BCMapCellInfo&   aAjaInfo)
    1: {
29425:   aAjaInfo.ResetCellInfo();
29425:   PRInt32 rowIndex = aRefInfo.mRowIndex + aRefInfo.mRowSpan;
    1:   PRInt32 rgRowIndex = rowIndex - mRowGroupStart;
    1:   nsTableRowGroupFrame* rg = mRowGroup;
    1:   nsCellMap* cellMap = mCellMap;
    1:   nsTableRowFrame* nextRow = nsnull;
    1:   if (rowIndex > mRowGroupEnd) {
    1:     PRInt32 nextRgIndex = mRowGroupIndex;
    1:     do {
    1:       nextRgIndex++;
 2141:       rg = mRowGroups.SafeElementAt(nextRgIndex);
    1:       if (rg) {
    1:         cellMap = mTableCellMap->GetMapFor(rg, cellMap); if (!cellMap) ABORT0();
    1:         rgRowIndex = 0;
    1:         nextRow = rg->GetFirstRow();
    1:       }
    1:     }
    1:     while (rg && !nextRow);
    1:     if(!rg) return;
    1:   }
    1:   else {
    1:     // get the row within the same row group
    1:     nextRow = mRow;
29425:     for (PRInt32 i = 0; i < aRefInfo.mRowSpan; i++) {
    1:       nextRow = nextRow->GetNextRow(); if (!nextRow) ABORT0();
    1:     }
    1:   }
    1: 
29425:   BCCellData* cellData =
29425:     static_cast<BCCellData*>(cellMap->GetDataAt(rgRowIndex, aColIndex));
    1:   if (!cellData) { // add a dead cell data
    1:     NS_ASSERTION(rgRowIndex < cellMap->GetRowCount(), "program error");
    1:     nsRect damageArea;
29425:     cellData =
29425:       static_cast<BCCellData*>(cellMap->AppendCell(*mTableCellMap, nsnull,
29425:                                                     rgRowIndex, PR_FALSE,
29425:                                                     damageArea));
29425:     if (!cellData) ABORT0();
    1:   }
    1:   if (cellData->IsColSpan()) {
    1:     aColIndex -= cellData->GetColSpanOffset();
29425:     cellData =
29425:       static_cast<BCCellData*>(cellMap->GetDataAt(rgRowIndex, aColIndex));
29425:   }
29425:   aAjaInfo.SetInfo(nextRow, aColIndex, cellData, this, cellMap);
    1: }
    1: 
    1: // Assign priorities to border styles. For example, styleToPriority(NS_STYLE_BORDER_STYLE_SOLID)
    1: // will return the priority of NS_STYLE_BORDER_STYLE_SOLID.
    1: static PRUint8 styleToPriority[13] = { 0,  // NS_STYLE_BORDER_STYLE_NONE
    1:                                        2,  // NS_STYLE_BORDER_STYLE_GROOVE
    1:                                        4,  // NS_STYLE_BORDER_STYLE_RIDGE
    1:                                        5,  // NS_STYLE_BORDER_STYLE_DOTTED
    1:                                        6,  // NS_STYLE_BORDER_STYLE_DASHED
    1:                                        7,  // NS_STYLE_BORDER_STYLE_SOLID
    1:                                        8,  // NS_STYLE_BORDER_STYLE_DOUBLE
    1:                                        1,  // NS_STYLE_BORDER_STYLE_INSET
    1:                                        3,  // NS_STYLE_BORDER_STYLE_OUTSET
    1:                                        9 };// NS_STYLE_BORDER_STYLE_HIDDEN
    1: // priority rules follow CSS 2.1 spec
    1: // 'hidden', 'double', 'solid', 'dashed', 'dotted', 'ridge', 'outset', 'groove',
    1: // and the lowest: 'inset'. none is even weaker
    1: #define CELL_CORNER PR_TRUE
    1: 
    1: /** return the border style, border color for a given frame and side
    1:   * @param aFrame           - query the info for this frame
    1:   * @param aSide            - the side of the frame
    1:   * @param aStyle           - the border style
    1:   * @param aColor           - the border color
    1:   * @param aTableIsLTR      - table direction is LTR
    1:   */
    1: static void
    1: GetColorAndStyle(const nsIFrame*  aFrame,
41419:                  mozilla::css::Side aSide,
    1:                  PRUint8&         aStyle,
    1:                  nscolor&         aColor,
36972:                  PRBool           aTableIsLTR)
    1: {
    1:   NS_PRECONDITION(aFrame, "null frame");
    1:   // initialize out arg
    1:   aColor = 0;
    1:   const nsStyleBorder* styleData = aFrame->GetStyleBorder();
    1:   if(!aTableIsLTR) { // revert the directions
    1:     if (NS_SIDE_RIGHT == aSide) {
    1:       aSide = NS_SIDE_LEFT;
    1:     }
    1:     else if (NS_SIDE_LEFT == aSide) {
    1:       aSide = NS_SIDE_RIGHT;
    1:     }
    1:   }
    1:   aStyle = styleData->GetBorderStyle(aSide);
    1: 
    1:   if ((NS_STYLE_BORDER_STYLE_NONE == aStyle) ||
    1:       (NS_STYLE_BORDER_STYLE_HIDDEN == aStyle)) {
    1:     return;
    1:   }
40181:   aColor = aFrame->GetStyleContext()->GetVisitedDependentColor(
40181:              nsCSSProps::SubpropertyEntryFor(eCSSProperty_border_color)[aSide]);
    1: }
    1: 
    1: /** coerce the paint style as required by CSS2.1
    1:   * @param aFrame           - query the info for this frame
    1:   * @param aSide            - the side of the frame
    1:   * @param aStyle           - the border style
    1:   * @param aColor           - the border color
    1:   * @param aTableIsLTR      - table direction is LTR
    1:   */
    1: static void
    1: GetPaintStyleInfo(const nsIFrame*  aFrame,
41419:                   mozilla::css::Side aSide,
    1:                   PRUint8&         aStyle,
    1:                   nscolor&         aColor,
36972:                   PRBool           aTableIsLTR)
36972: {
36972:   GetColorAndStyle(aFrame, aSide, aStyle, aColor, aTableIsLTR);
    1:   if (NS_STYLE_BORDER_STYLE_INSET    == aStyle) {
    1:     aStyle = NS_STYLE_BORDER_STYLE_RIDGE;
    1:   }
    1:   else if (NS_STYLE_BORDER_STYLE_OUTSET    == aStyle) {
    1:     aStyle = NS_STYLE_BORDER_STYLE_GROOVE;
    1:   }
    1: }
    1: 
    1: /** return the border style, border color and the width in pixel for a given
    1:   * frame and side
    1:   * @param aFrame           - query the info for this frame
    1:   * @param aSide            - the side of the frame
    1:   * @param aStyle           - the border style
    1:   * @param aColor           - the border color
    1:   * @param aTableIsLTR      - table direction is LTR
    1:   * @param aWidth           - the border width in px.
    1:   * @param aTwipsToPixels   - conversion factor from twips to pixel
    1:   */
    1: static void
    1: GetColorAndStyle(const nsIFrame*  aFrame,
41419:                  mozilla::css::Side aSide,
    1:                  PRUint8&         aStyle,
    1:                  nscolor&         aColor,
    1:                  PRBool           aTableIsLTR,
29425:                  BCPixelSize&     aWidth)
    1: {
36972:   GetColorAndStyle(aFrame, aSide, aStyle, aColor, aTableIsLTR);
    1:   if ((NS_STYLE_BORDER_STYLE_NONE == aStyle) ||
    1:       (NS_STYLE_BORDER_STYLE_HIDDEN == aStyle)) {
    1:     aWidth = 0;
    1:     return;
    1:   }
    1:   const nsStyleBorder* styleData = aFrame->GetStyleBorder();
    1:   nscoord width;
    1:   if(!aTableIsLTR) { // revert the directions
    1:     if (NS_SIDE_RIGHT == aSide) {
    1:       aSide = NS_SIDE_LEFT;
    1:     }
    1:     else if (NS_SIDE_LEFT == aSide) {
    1:       aSide = NS_SIDE_RIGHT;
    1:     }
    1:   }
15992:   width = styleData->GetActualBorderWidth(aSide);
    1:   aWidth = nsPresContext::AppUnitsToIntCSSPixels(width);
    1: }
    1: 
20836: class nsDelayedCalcBCBorders : public nsRunnable {
20836: public:
20836:   nsDelayedCalcBCBorders(nsIFrame* aFrame) :
20836:     mFrame(aFrame) {}
20836: 
20836:   NS_IMETHOD Run() {
20836:     if (mFrame) {
20836:       nsTableFrame* tableFrame = static_cast <nsTableFrame*>(mFrame.GetFrame());
20836:       if (tableFrame->NeedToCalcBCBorders()) {
20836:         tableFrame->CalcBCBorders();
20836:       }
20836:     }
20836:     return NS_OK;
20836:   }
20836: private:
20836:   nsWeakFrame mFrame;
20836: };
20836: 
20836: PRBool
20836: nsTableFrame::BCRecalcNeeded(nsStyleContext* aOldStyleContext,
20836:                              nsStyleContext* aNewStyleContext)
20836: {
21170:   // Attention: the old style context is the one we're forgetting,
21170:   // and hence possibly completely bogus for GetStyle* purposes.
21170:   // We use PeekStyleData instead.
21170: 
38860:   const nsStyleBorder* oldStyleData = aOldStyleContext->PeekStyleBorder();
21170:   if (!oldStyleData)
21170:     return PR_FALSE;
21170: 
21170:   const nsStyleBorder* newStyleData = aNewStyleContext->GetStyleBorder();
21170:   nsChangeHint change = newStyleData->CalcDifference(*oldStyleData);
21325:   if (!change)
21170:     return PR_FALSE;
21325:   if (change & nsChangeHint_ReflowFrame)
21170:     return PR_TRUE; // the caller only needs to mark the bc damage area
21325:   if (change & nsChangeHint_RepaintFrame) {
21170:     // we need to recompute the borders and the caller needs to mark
21170:     // the bc damage area
21200:     // XXX In principle this should only be necessary for border style changes
21200:     // However the bc painting code tries to maximize the drawn border segments
21200:     // so it stores in the cellmap where a new border segment starts and this
21200:     // introduces a unwanted cellmap data dependence on color
21170:     nsCOMPtr<nsIRunnable> evt = new nsDelayedCalcBCBorders(this);
21170:     NS_DispatchToCurrentThread(evt);
21170:     return PR_TRUE;
21170:   }
20836:   return PR_FALSE;
20836: }
    1: 
    1: 
    1: // Compare two border segments, this comparison depends whether the two
    1: // segments meet at a corner and whether the second segment is horizontal.
    1: // The return value is whichever of aBorder1 or aBorder2 dominates.
    1: static const BCCellBorder&
    1: CompareBorders(PRBool              aIsCorner, // Pass PR_TRUE for corner calculations
    1:                const BCCellBorder& aBorder1,
    1:                const BCCellBorder& aBorder2,
    1:                PRBool              aSecondIsHorizontal,
    1:                PRBool*             aFirstDominates = nsnull)
    1: {
    1:   PRBool firstDominates = PR_TRUE;
    1: 
    1:   if (NS_STYLE_BORDER_STYLE_HIDDEN == aBorder1.style) {
    1:     firstDominates = (aIsCorner) ? PR_FALSE : PR_TRUE;
    1:   }
    1:   else if (NS_STYLE_BORDER_STYLE_HIDDEN == aBorder2.style) {
    1:     firstDominates = (aIsCorner) ? PR_TRUE : PR_FALSE;
    1:   }
    1:   else if (aBorder1.width < aBorder2.width) {
    1:     firstDominates = PR_FALSE;
    1:   }
    1:   else if (aBorder1.width == aBorder2.width) {
    1:     if (styleToPriority[aBorder1.style] < styleToPriority[aBorder2.style]) {
    1:       firstDominates = PR_FALSE;
    1:     }
    1:     else if (styleToPriority[aBorder1.style] == styleToPriority[aBorder2.style]) {
    1:       if (aBorder1.owner == aBorder2.owner) {
    1:         firstDominates = !aSecondIsHorizontal;
    1:       }
    1:       else if (aBorder1.owner < aBorder2.owner) {
    1:         firstDominates = PR_FALSE;
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (aFirstDominates)
    1:     *aFirstDominates = firstDominates;
    1: 
    1:   if (firstDominates)
    1:     return aBorder1;
    1:   return aBorder2;
    1: }
    1: 
    1: /** calc the dominant border by considering the table, row/col group, row/col,
36972:   * cell.
    1:   * Depending on whether the side is vertical or horizontal and whether
    1:   * adjacent frames are taken into account the ownership of a single border
    1:   * segment is defined. The return value is the dominating border
    1:   * The cellmap stores only top and left borders for each cellmap position.
    1:   * If the cell border is owned by the cell that is left of the border
    1:   * it will be an adjacent owner aka eAjaCellOwner. See celldata.h for the other
    1:   * scenarios with a adjacent owner.
    1:   * @param xxxFrame         - the frame for style information, might be zero if
    1:   *                           it should not be considered
    1:   * @param aSide            - side of the frames that should be considered
    1:   * @param aAja             - the border comparison takes place from the point of
    1:   *                           a frame that is adjacent to the cellmap entry, for
    1:   *                           when a cell owns its lower border it will be the
    1:   *                           adjacent owner as in the cellmap only top and left
    1:   *                           borders are stored.
    1:   * @param aTwipsToPixels   - conversion factor as borders need to be drawn pixel
    1:   *                           aligned.
    1:   */
    1: static BCCellBorder
    1: CompareBorders(const nsIFrame*  aTableFrame,
    1:                const nsIFrame*  aColGroupFrame,
    1:                const nsIFrame*  aColFrame,
    1:                const nsIFrame*  aRowGroupFrame,
    1:                const nsIFrame*  aRowFrame,
    1:                const nsIFrame*  aCellFrame,
    1:                PRBool           aTableIsLTR,
41419:                mozilla::css::Side aSide,
    1:                PRBool           aAja)
    1: {
    1:   BCCellBorder border, tempBorder;
    1:   PRBool horizontal = (NS_SIDE_TOP == aSide) || (NS_SIDE_BOTTOM == aSide);
    1: 
    1:   // start with the table as dominant if present
    1:   if (aTableFrame) {
36972:     GetColorAndStyle(aTableFrame, aSide, border.style, border.color, aTableIsLTR, border.width);
    1:     border.owner = eTableOwner;
    1:     if (NS_STYLE_BORDER_STYLE_HIDDEN == border.style) {
    1:       return border;
    1:     }
    1:   }
    1:   // see if the colgroup is dominant
    1:   if (aColGroupFrame) {
36972:     GetColorAndStyle(aColGroupFrame, aSide, tempBorder.style, tempBorder.color, aTableIsLTR, tempBorder.width);
    1:     tempBorder.owner = (aAja && !horizontal) ? eAjaColGroupOwner : eColGroupOwner;
    1:     // pass here and below PR_FALSE for aSecondIsHorizontal as it is only used for corner calculations.
    1:     border = CompareBorders(!CELL_CORNER, border, tempBorder, PR_FALSE);
    1:     if (NS_STYLE_BORDER_STYLE_HIDDEN == border.style) {
    1:       return border;
    1:     }
    1:   }
    1:   // see if the col is dominant
    1:   if (aColFrame) {
36972:     GetColorAndStyle(aColFrame, aSide, tempBorder.style, tempBorder.color, aTableIsLTR, tempBorder.width);
    1:     tempBorder.owner = (aAja && !horizontal) ? eAjaColOwner : eColOwner;
    1:     border = CompareBorders(!CELL_CORNER, border, tempBorder, PR_FALSE);
    1:     if (NS_STYLE_BORDER_STYLE_HIDDEN == border.style) {
    1:       return border;
    1:     }
    1:   }
    1:   // see if the rowgroup is dominant
    1:   if (aRowGroupFrame) {
36972:     GetColorAndStyle(aRowGroupFrame, aSide, tempBorder.style, tempBorder.color, aTableIsLTR, tempBorder.width);
    1:     tempBorder.owner = (aAja && horizontal) ? eAjaRowGroupOwner : eRowGroupOwner;
    1:     border = CompareBorders(!CELL_CORNER, border, tempBorder, PR_FALSE);
    1:     if (NS_STYLE_BORDER_STYLE_HIDDEN == border.style) {
    1:       return border;
    1:     }
    1:   }
    1:   // see if the row is dominant
    1:   if (aRowFrame) {
36972:     GetColorAndStyle(aRowFrame, aSide, tempBorder.style, tempBorder.color, aTableIsLTR, tempBorder.width);
    1:     tempBorder.owner = (aAja && horizontal) ? eAjaRowOwner : eRowOwner;
    1:     border = CompareBorders(!CELL_CORNER, border, tempBorder, PR_FALSE);
    1:     if (NS_STYLE_BORDER_STYLE_HIDDEN == border.style) {
    1:       return border;
    1:     }
    1:   }
    1:   // see if the cell is dominant
    1:   if (aCellFrame) {
36972:     GetColorAndStyle(aCellFrame, aSide, tempBorder.style, tempBorder.color, aTableIsLTR, tempBorder.width);
    1:     tempBorder.owner = (aAja) ? eAjaCellOwner : eCellOwner;
    1:     border = CompareBorders(!CELL_CORNER, border, tempBorder, PR_FALSE);
    1:   }
    1:   return border;
    1: }
    1: 
    1: static PRBool
41419: Perpendicular(mozilla::css::Side aSide1,
41419:               mozilla::css::Side aSide2)
    1: {
    1:   switch (aSide1) {
    1:   case NS_SIDE_TOP:
    1:     return (NS_SIDE_BOTTOM != aSide2);
    1:   case NS_SIDE_RIGHT:
    1:     return (NS_SIDE_LEFT != aSide2);
    1:   case NS_SIDE_BOTTOM:
    1:     return (NS_SIDE_TOP != aSide2);
    1:   default: // NS_SIDE_LEFT
    1:     return (NS_SIDE_RIGHT != aSide2);
    1:   }
    1: }
    1: 
    1: // XXX allocate this as number-of-cols+1 instead of number-of-cols+1 * number-of-rows+1
    1: struct BCCornerInfo
    1: {
41419:   BCCornerInfo() { ownerColor = 0; ownerWidth = subWidth = ownerElem = subSide =
41419:                    subElem = hasDashDot = numSegs = bevel = 0; ownerSide = NS_SIDE_TOP;
    1:                    ownerStyle = 0xFF; subStyle = NS_STYLE_BORDER_STYLE_SOLID;  }
41419:   void Set(mozilla::css::Side aSide,
    1:            BCCellBorder  border);
    1: 
41419:   void Update(mozilla::css::Side aSide,
    1:               BCCellBorder  border);
    1: 
    1:   nscolor   ownerColor;     // color of borderOwner
    1:   PRUint16  ownerWidth;     // pixel width of borderOwner
    1:   PRUint16  subWidth;       // pixel width of the largest border intersecting the border perpendicular
    1:                             // to ownerSide
41421:   PRUint32  ownerSide:2;    // mozilla::css::Side (e.g NS_SIDE_TOP, NS_SIDE_RIGHT, etc) of the border
41421:                             // owning the corner relative to the corner
    1:   PRUint32  ownerElem:3;    // elem type (e.g. eTable, eGroup, etc) owning the corner
    1:   PRUint32  ownerStyle:8;   // border style of ownerElem
    1:   PRUint32  subSide:2;      // side of border with subWidth relative to the corner
    1:   PRUint32  subElem:3;      // elem type (e.g. eTable, eGroup, etc) of sub owner
    1:   PRUint32  subStyle:8;     // border style of subElem
    1:   PRUint32  hasDashDot:1;   // does a dashed, dotted segment enter the corner, they cannot be beveled
    1:   PRUint32  numSegs:3;      // number of segments entering corner
    1:   PRUint32  bevel:1;        // is the corner beveled (uses the above two fields together with subWidth)
    1:   PRUint32  unused:1;
    1: };
    1: 
    1: void
41419: BCCornerInfo::Set(mozilla::css::Side aSide,
    1:                   BCCellBorder  aBorder)
    1: {
    1:   ownerElem  = aBorder.owner;
    1:   ownerStyle = aBorder.style;
    1:   ownerWidth = aBorder.width;
    1:   ownerColor = aBorder.color;
    1:   ownerSide  = aSide;
    1:   hasDashDot = 0;
    1:   numSegs    = 0;
    1:   if (aBorder.width > 0) {
    1:     numSegs++;
    1:     hasDashDot = (NS_STYLE_BORDER_STYLE_DASHED == aBorder.style) ||
    1:                  (NS_STYLE_BORDER_STYLE_DOTTED == aBorder.style);
    1:   }
    1:   bevel      = 0;
    1:   subWidth   = 0;
    1:   // the following will get set later
    1:   subSide    = ((aSide == NS_SIDE_LEFT) || (aSide == NS_SIDE_RIGHT)) ? NS_SIDE_TOP : NS_SIDE_LEFT;
    1:   subElem    = eTableOwner;
    1:   subStyle   = NS_STYLE_BORDER_STYLE_SOLID;
    1: }
    1: 
    1: void
41419: BCCornerInfo::Update(mozilla::css::Side aSide,
    1:                      BCCellBorder  aBorder)
    1: {
    1:   PRBool existingWins = PR_FALSE;
    1:   if (0xFF == ownerStyle) { // initial value indiating that it hasn't been set yet
    1:     Set(aSide, aBorder);
    1:   }
    1:   else {
    1:     PRBool horizontal = (NS_SIDE_LEFT == aSide) || (NS_SIDE_RIGHT == aSide); // relative to the corner
    1:     BCCellBorder oldBorder, tempBorder;
    1:     oldBorder.owner  = (BCBorderOwner) ownerElem;
    1:     oldBorder.style =  ownerStyle;
    1:     oldBorder.width =  ownerWidth;
    1:     oldBorder.color =  ownerColor;
    1: 
41421:     mozilla::css::Side oldSide  = mozilla::css::Side(ownerSide);
    1: 
    1:     tempBorder = CompareBorders(CELL_CORNER, oldBorder, aBorder, horizontal, &existingWins);
    1: 
    1:     ownerElem  = tempBorder.owner;
    1:     ownerStyle = tempBorder.style;
    1:     ownerWidth = tempBorder.width;
    1:     ownerColor = tempBorder.color;
    1:     if (existingWins) { // existing corner is dominant
41421:       if (::Perpendicular(mozilla::css::Side(ownerSide), aSide)) {
    1:         // see if the new sub info replaces the old
    1:         BCCellBorder subBorder;
    1:         subBorder.owner = (BCBorderOwner) subElem;
    1:         subBorder.style =  subStyle;
    1:         subBorder.width =  subWidth;
    1:         subBorder.color = 0; // we are not interested in subBorder color
    1:         PRBool firstWins;
    1: 
    1:         tempBorder = CompareBorders(CELL_CORNER, subBorder, aBorder, horizontal, &firstWins);
    1: 
    1:         subElem  = tempBorder.owner;
    1:         subStyle = tempBorder.style;
    1:         subWidth = tempBorder.width;
    1:         if (!firstWins) {
    1:           subSide = aSide;
    1:         }
    1:       }
    1:     }
    1:     else { // input args are dominant
    1:       ownerSide = aSide;
41421:       if (::Perpendicular(oldSide, mozilla::css::Side(ownerSide))) {
    1:         subElem  = oldBorder.owner;
    1:         subStyle = oldBorder.style;
    1:         subWidth = oldBorder.width;
    1:         subSide  = oldSide;
    1:       }
    1:     }
    1:     if (aBorder.width > 0) {
    1:       numSegs++;
    1:       if (!hasDashDot && ((NS_STYLE_BORDER_STYLE_DASHED == aBorder.style) ||
    1:                           (NS_STYLE_BORDER_STYLE_DOTTED == aBorder.style))) {
    1:         hasDashDot = 1;
    1:       }
    1:     }
    1: 
    1:     // bevel the corner if only two perpendicular non dashed/dotted segments enter the corner
    1:     bevel = (2 == numSegs) && (subWidth > 1) && (0 == hasDashDot);
    1:   }
    1: }
    1: 
    1: struct BCCorners
    1: {
    1:   BCCorners(PRInt32 aNumCorners,
    1:             PRInt32 aStartIndex);
    1: 
    1:   ~BCCorners() { delete [] corners; }
    1: 
    1:   BCCornerInfo& operator [](PRInt32 i) const
    1:   { NS_ASSERTION((i >= startIndex) && (i <= endIndex), "program error");
32531:     return corners[NS_MAX(NS_MIN(i, endIndex), startIndex) - startIndex]; }
    1: 
    1:   PRInt32       startIndex;
    1:   PRInt32       endIndex;
    1:   BCCornerInfo* corners;
    1: };
    1: 
    1: BCCorners::BCCorners(PRInt32 aNumCorners,
    1:                      PRInt32 aStartIndex)
    1: {
    1:   NS_ASSERTION((aNumCorners > 0) && (aStartIndex >= 0), "program error");
    1:   startIndex = aStartIndex;
    1:   endIndex   = aStartIndex + aNumCorners - 1;
    1:   corners    = new BCCornerInfo[aNumCorners];
    1: }
    1: 
    1: 
    1: struct BCCellBorders
    1: {
    1:   BCCellBorders(PRInt32 aNumBorders,
    1:                 PRInt32 aStartIndex);
    1: 
    1:   ~BCCellBorders() { delete [] borders; }
    1: 
    1:   BCCellBorder& operator [](PRInt32 i) const
    1:   { NS_ASSERTION((i >= startIndex) && (i <= endIndex), "program error");
32531:     return borders[NS_MAX(NS_MIN(i, endIndex), startIndex) - startIndex]; }
    1: 
    1:   PRInt32       startIndex;
    1:   PRInt32       endIndex;
    1:   BCCellBorder* borders;
    1: };
    1: 
    1: BCCellBorders::BCCellBorders(PRInt32 aNumBorders,
    1:                              PRInt32 aStartIndex)
    1: {
    1:   NS_ASSERTION((aNumBorders > 0) && (aStartIndex >= 0), "program error");
    1:   startIndex = aStartIndex;
    1:   endIndex   = aStartIndex + aNumBorders - 1;
    1:   borders    = new BCCellBorder[aNumBorders];
    1: }
    1: 
    1: // this function sets the new border properties and returns true if the border
34593: // segment will start a new segment and not be accumulated into the previous
34593: // segment.
    1: static PRBool
    1: SetBorder(const BCCellBorder&   aNewBorder,
    1:           BCCellBorder&         aBorder)
    1: {
    1:   PRBool changed = (aNewBorder.style != aBorder.style) ||
    1:                    (aNewBorder.width != aBorder.width) ||
    1:                    (aNewBorder.color != aBorder.color);
    1:   aBorder.color        = aNewBorder.color;
    1:   aBorder.width        = aNewBorder.width;
    1:   aBorder.style        = aNewBorder.style;
    1:   aBorder.owner        = aNewBorder.owner;
    1: 
    1:   return changed;
    1: }
    1: 
    1: // this function will set the horizontal border. It will return true if the
    1: // existing segment will not be continued. Having a vertical owner of a corner
    1: // should also start a new segment.
    1: static PRBool
    1: SetHorBorder(const BCCellBorder& aNewBorder,
    1:              const BCCornerInfo& aCorner,
    1:              BCCellBorder&       aBorder)
    1: {
    1:   PRBool startSeg = ::SetBorder(aNewBorder, aBorder);
    1:   if (!startSeg) {
    1:     startSeg = ((NS_SIDE_LEFT != aCorner.ownerSide) && (NS_SIDE_RIGHT != aCorner.ownerSide));
    1:   }
    1:   return startSeg;
    1: }
    1: 
    1: // Make the damage area larger on the top and bottom by at least one row and on the left and right
    1: // at least one column. This is done so that adjacent elements are part of the border calculations.
    1: // The extra segments and borders outside the actual damage area will not be updated in the cell map,
    1: // because they in turn would need info from adjacent segments outside the damage area to be accurate.
    1: void
    1: nsTableFrame::ExpandBCDamageArea(nsRect& aRect) const
    1: {
    1:   PRInt32 numRows = GetRowCount();
    1:   PRInt32 numCols = GetColCount();
    1: 
    1:   PRInt32 dStartX = aRect.x;
    1:   PRInt32 dEndX   = aRect.XMost() - 1;
    1:   PRInt32 dStartY = aRect.y;
    1:   PRInt32 dEndY   = aRect.YMost() - 1;
    1: 
    1:   // expand the damage area in each direction
    1:   if (dStartX > 0) {
    1:     dStartX--;
    1:   }
    1:   if (dEndX < (numCols - 1)) {
    1:     dEndX++;
    1:   }
    1:   if (dStartY > 0) {
    1:     dStartY--;
    1:   }
    1:   if (dEndY < (numRows - 1)) {
    1:     dEndY++;
    1:   }
    1:   // Check the damage area so that there are no cells spanning in or out. If there are any then
    1:   // make the damage area as big as the table, similarly to the way the cell map decides whether
    1:   // to rebuild versus expand. This could be optimized to expand to the smallest area that contains
    1:   // no spanners, but it may not be worth the effort in general, and it would need to be done in the
    1:   // cell map as well.
    1:   PRBool haveSpanner = PR_FALSE;
    1:   if ((dStartX > 0) || (dEndX < (numCols - 1)) || (dStartY > 0) || (dEndY < (numRows - 1))) {
    1:     nsTableCellMap* tableCellMap = GetCellMap(); if (!tableCellMap) ABORT0();
    1:     // Get the ordered row groups
 2141:     RowGroupArray rowGroups;
 2141:     OrderRowGroups(rowGroups);
    1: 
    1:     // Scope outside loop to be used as hint.
    1:     nsCellMap* cellMap = nsnull;
 2141:     for (PRUint32 rgX = 0; rgX < rowGroups.Length(); rgX++) {
 2141:       nsTableRowGroupFrame* rgFrame = rowGroups[rgX];
    1:       PRInt32 rgStartY = rgFrame->GetStartRowIndex();
    1:       PRInt32 rgEndY   = rgStartY + rgFrame->GetRowCount() - 1;
    1:       if (dEndY < rgStartY)
    1:         break;
    1:       cellMap = tableCellMap->GetMapFor(rgFrame, cellMap);
    1:       if (!cellMap) ABORT0();
    1:       // check for spanners from above and below
    1:       if ((dStartY > 0) && (dStartY >= rgStartY) && (dStartY <= rgEndY)) {
    1:         if (PRUint32(dStartY - rgStartY) >= cellMap->mRows.Length())
    1:           ABORT0();
    1:         const nsCellMap::CellDataArray& row =
    1:           cellMap->mRows[dStartY - rgStartY];
    1:         for (PRInt32 x = dStartX; x <= dEndX; x++) {
    1:           CellData* cellData = row.SafeElementAt(x);
    1:           if (cellData && (cellData->IsRowSpan())) {
    1:              haveSpanner = PR_TRUE;
    1:              break;
    1:           }
    1:         }
    1:         if (dEndY < rgEndY) {
    1:           if (PRUint32(dEndY + 1 - rgStartY) >= cellMap->mRows.Length())
    1:             ABORT0();
    1:           const nsCellMap::CellDataArray& row2 =
    1:             cellMap->mRows[dEndY + 1 - rgStartY];
    1:           for (PRInt32 x = dStartX; x <= dEndX; x++) {
    1:             CellData* cellData = row2.SafeElementAt(x);
    1:             if (cellData && (cellData->IsRowSpan())) {
    1:               haveSpanner = PR_TRUE;
    1:               break;
    1:             }
    1:           }
    1:         }
    1:       }
    1:       // check for spanners on the left and right
    1:       PRInt32 iterStartY = -1;
    1:       PRInt32 iterEndY   = -1;
    1:       if ((dStartY >= rgStartY) && (dStartY <= rgEndY)) {
    1:         // the damage area starts in the row group
    1:         iterStartY = dStartY;
32531:         iterEndY   = NS_MIN(dEndY, rgEndY);
    1:       }
    1:       else if ((dEndY >= rgStartY) && (dEndY <= rgEndY)) {
    1:         // the damage area ends in the row group
    1:         iterStartY = rgStartY;
32531:         iterEndY   = NS_MIN(dEndY, rgStartY);
    1:       }
    1:       else if ((rgStartY >= dStartY) && (rgEndY <= dEndY)) {
    1:         // the damage area contains the row group
    1:         iterStartY = rgStartY;
    1:         iterEndY   = rgEndY;
    1:       }
    1:       if ((iterStartY >= 0) && (iterEndY >= 0)) {
    1:         for (PRInt32 y = iterStartY; y <= iterEndY; y++) {
    1:           if (PRUint32(y - rgStartY) >= cellMap->mRows.Length())
    1:             ABORT0();
    1:           const nsCellMap::CellDataArray& row =
    1:             cellMap->mRows[y - rgStartY];
    1:           CellData* cellData = row.SafeElementAt(dStartX);
    1:           if (cellData && (cellData->IsColSpan())) {
    1:             haveSpanner = PR_TRUE;
    1:             break;
    1:           }
    1:           if (dEndX < (numCols - 1)) {
    1:             cellData = row.SafeElementAt(dEndX + 1);
    1:             if (cellData && (cellData->IsColSpan())) {
    1:               haveSpanner = PR_TRUE;
    1:               break;
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1:   if (haveSpanner) {
    1:     // make the damage area the whole table
    1:     aRect.x      = 0;
    1:     aRect.y      = 0;
    1:     aRect.width  = numCols;
    1:     aRect.height = numRows;
    1:   }
    1:   else {
    1:     aRect.x      = dStartX;
    1:     aRect.y      = dStartY;
    1:     aRect.width  = 1 + dEndX - dStartX;
    1:     aRect.height = 1 + dEndY - dStartY;
    1:   }
    1: }
    1: 
    1: 
29425: #define ADJACENT    PR_TRUE
29425: #define HORIZONTAL  PR_TRUE
29425: 
29425: void
29425: BCMapCellInfo::SetTableTopLeftContBCBorder()
29425: {
29425:   BCCellBorder currentBorder;
29425:   //calculate continuous top first row & rowgroup border: special case
29425:   //because it must include the table in the collapse
29425:   if (mTopRow) {
29425:     currentBorder = CompareBorders(mTableFrame, nsnull, nsnull, mRowGroup,
29425:                                    mTopRow, nsnull, mTableIsLTR,
36972:                                    NS_SIDE_TOP, !ADJACENT);
29425:     mTopRow->SetContinuousBCBorderWidth(NS_SIDE_TOP, currentBorder.width);
29425:   }
29425:   if (mCgAtRight && mColGroup) {
29425:     //calculate continuous top colgroup border once per colgroup
29425:     currentBorder = CompareBorders(mTableFrame, mColGroup, nsnull, mRowGroup,
29425:                                    mTopRow, nsnull, mTableIsLTR,
36972:                                    NS_SIDE_TOP, !ADJACENT);
29425:     mColGroup->SetContinuousBCBorderWidth(NS_SIDE_TOP, currentBorder.width);
29425:   }
29425:   if (0 == mColIndex) {
29425:     currentBorder = CompareBorders(mTableFrame, mColGroup, mLeftCol, nsnull,
36972:                                    nsnull, nsnull, mTableIsLTR, NS_SIDE_LEFT,
36972:                                    !ADJACENT);
29425:     mTableFrame->SetContinuousLeftBCBorderWidth(currentBorder.width);
29425:   }
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetRowGroupLeftContBCBorder()
29425: {
29425:   BCCellBorder currentBorder;
29425:   //get row group continuous borders
29425:   if (mRgAtBottom && mRowGroup) { //once per row group, so check for bottom
29425:      currentBorder = CompareBorders(mTableFrame, mColGroup, mLeftCol, mRowGroup,
36972:                                     nsnull, nsnull, mTableIsLTR, NS_SIDE_LEFT,
36972:                                     !ADJACENT);
29425:      mRowGroup->SetContinuousBCBorderWidth(mStartSide, currentBorder.width);
29425:   }
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetRowGroupRightContBCBorder()
29425: {
29425:   BCCellBorder currentBorder;
29425:   //get row group continuous borders
29425:   if (mRgAtBottom && mRowGroup) { //once per mRowGroup, so check for bottom
29425:     currentBorder = CompareBorders(mTableFrame, mColGroup, mRightCol, mRowGroup,
36972:                                    nsnull, nsnull, mTableIsLTR, NS_SIDE_RIGHT,
36972:                                    ADJACENT);
29425:     mRowGroup->SetContinuousBCBorderWidth(mEndSide, currentBorder.width);
29425:   }
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetColumnTopRightContBCBorder()
29425: {
29425:   BCCellBorder currentBorder;
29425:   //calculate column continuous borders
29425:   //we only need to do this once, so we'll do it only on the first row
29425:   currentBorder = CompareBorders(mTableFrame, mCurrentColGroupFrame,
29425:                                  mCurrentColFrame, mRowGroup, mTopRow, nsnull,
36972:                                  mTableIsLTR, NS_SIDE_TOP, !ADJACENT);
29425:   ((nsTableColFrame*) mCurrentColFrame)->SetContinuousBCBorderWidth(NS_SIDE_TOP,
29425:                                                            currentBorder.width);
29425:   if (mNumTableCols == GetCellEndColIndex() + 1) {
29425:     currentBorder = CompareBorders(mTableFrame, mCurrentColGroupFrame,
29425:                                    mCurrentColFrame, nsnull, nsnull, nsnull,
36972:                                    mTableIsLTR, NS_SIDE_RIGHT, !ADJACENT);
29425:   }
29425:   else {
29425:     currentBorder = CompareBorders(nsnull, mCurrentColGroupFrame,
29425:                                    mCurrentColFrame, nsnull,nsnull, nsnull,
36972:                                    mTableIsLTR, NS_SIDE_RIGHT, !ADJACENT);
29425:   }
29425:   mCurrentColFrame->SetContinuousBCBorderWidth(NS_SIDE_RIGHT,
29425:                                                currentBorder.width);
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetColumnBottomContBCBorder()
29425: {
29425:   BCCellBorder currentBorder;
29425:   //get col continuous border
29425:   currentBorder = CompareBorders(mTableFrame, mCurrentColGroupFrame,
29425:                                  mCurrentColFrame, mRowGroup, mBottomRow,
36972:                                  nsnull, mTableIsLTR, NS_SIDE_BOTTOM, ADJACENT);
29425:   mCurrentColFrame->SetContinuousBCBorderWidth(NS_SIDE_BOTTOM,
29425:                                                currentBorder.width);
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetColGroupBottomContBCBorder()
29425: {
29425:   BCCellBorder currentBorder;
29425:   if (mColGroup) {
29425:     currentBorder = CompareBorders(mTableFrame, mColGroup, nsnull, mRowGroup,
36972:                                    mBottomRow, nsnull, mTableIsLTR,
29425:                                    NS_SIDE_BOTTOM, ADJACENT);
29425:     mColGroup->SetContinuousBCBorderWidth(NS_SIDE_BOTTOM, currentBorder.width);
29425:   }
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetRowGroupBottomContBCBorder()
29425: {
29425:   BCCellBorder currentBorder;
29425:   if (mRowGroup) {
29425:     currentBorder = CompareBorders(mTableFrame, nsnull, nsnull, mRowGroup,
36972:                                    mBottomRow, nsnull, mTableIsLTR,
29425:                                    NS_SIDE_BOTTOM, ADJACENT);
29425:     mRowGroup->SetContinuousBCBorderWidth(NS_SIDE_BOTTOM, currentBorder.width);
29425:   }
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetInnerRowGroupBottomContBCBorder(const nsIFrame* aNextRowGroup,
29425:                                                   nsTableRowFrame* aNextRow)
29425: {
29425:   BCCellBorder currentBorder, adjacentBorder;
29425: 
29425:   const nsIFrame* rowgroup = (mRgAtBottom) ? mRowGroup : nsnull;
29425:   currentBorder = CompareBorders(nsnull, nsnull, nsnull, rowgroup, mBottomRow,
36972:                                  nsnull, mTableIsLTR, NS_SIDE_BOTTOM, ADJACENT);
29425: 
29425:   adjacentBorder = CompareBorders(nsnull, nsnull, nsnull, aNextRowGroup,
36972:                                   aNextRow, nsnull, mTableIsLTR, NS_SIDE_TOP,
36972:                                   !ADJACENT);
29425:   currentBorder = CompareBorders(PR_FALSE, currentBorder, adjacentBorder,
29425:                                  HORIZONTAL);
29425:   if (aNextRow) {
29425:     aNextRow->SetContinuousBCBorderWidth(NS_SIDE_TOP, currentBorder.width);
29425:   }
29425:   if (mRgAtBottom && mRowGroup) {
29425:     mRowGroup->SetContinuousBCBorderWidth(NS_SIDE_BOTTOM, currentBorder.width);
29425:   }
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetRowLeftContBCBorder()
29425: {
29425:   //get row continuous borders
29425:   if (mCurrentRowFrame) {
29425:     BCCellBorder currentBorder;
29425:     currentBorder = CompareBorders(mTableFrame, mColGroup, mLeftCol, mRowGroup,
29425:                                    mCurrentRowFrame, nsnull, mTableIsLTR,
36972:                                    NS_SIDE_LEFT, !ADJACENT);
29425:     mCurrentRowFrame->SetContinuousBCBorderWidth(mStartSide,
29425:                                                  currentBorder.width);
29425:   }
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetRowRightContBCBorder()
29425: {
29425:   if (mCurrentRowFrame) {
29425:     BCCellBorder currentBorder;
29425:     currentBorder = CompareBorders(mTableFrame, mColGroup, mRightCol, mRowGroup,
29425:                                    mCurrentRowFrame, nsnull, mTableIsLTR,
36972:                                    NS_SIDE_RIGHT, ADJACENT);
29425:     mCurrentRowFrame->SetContinuousBCBorderWidth(mEndSide,
29425:                                                  currentBorder.width);
29425:   }
29425: }
29425: void
29425: BCMapCellInfo::SetTableTopBorderWidth(BCPixelSize aWidth)
29425: {
39019:   mTableBCData->mTopBorderWidth = NS_MAX(mTableBCData->mTopBorderWidth, aWidth);
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetTableLeftBorderWidth(PRInt32 aRowY, BCPixelSize aWidth)
29425: {
29425:   // update the left/right first cell border
29425:   if (aRowY == 0) {
29425:     if (mTableIsLTR) {
29425:       mTableBCData->mLeftCellBorderWidth = aWidth;
29425:     }
29425:     else {
29425:       mTableBCData->mRightCellBorderWidth = aWidth;
29425:     }
29425:   }
39019:   mTableBCData->mLeftBorderWidth = NS_MAX(mTableBCData->mLeftBorderWidth,
39019:                                           aWidth);
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetTableRightBorderWidth(PRInt32 aRowY, BCPixelSize aWidth)
29425: {
29425:   // update the left/right first cell border
29425:   if (aRowY == 0) {
29425:     if (mTableIsLTR) {
29425:       mTableBCData->mRightCellBorderWidth = aWidth;
29425:     }
29425:     else {
29425:       mTableBCData->mLeftCellBorderWidth = aWidth;
29425:     }
29425:   }
39019:   mTableBCData->mRightBorderWidth = NS_MAX(mTableBCData->mRightBorderWidth,
39019:                                            aWidth);
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetRightBorderWidths(BCPixelSize aWidth)
29425: {
29425:    // update the borders of the cells and cols affected
29425:   if (mCell) {
32531:     mCell->SetBorderWidth(mEndSide, NS_MAX(aWidth,
29425:                           mCell->GetBorderWidth(mEndSide)));
29425:   }
29425:   if (mRightCol) {
29425:     BCPixelSize half = BC_BORDER_LEFT_HALF(aWidth);
32531:     mRightCol->SetRightBorderWidth(NS_MAX(nscoord(half),
29425:                                    mRightCol->GetRightBorderWidth()));
29425:   }
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetBottomBorderWidths(BCPixelSize aWidth)
29425: {
29425:   // update the borders of the affected cells and rows
29425:   if (mCell) {
32531:     mCell->SetBorderWidth(NS_SIDE_BOTTOM, NS_MAX(aWidth,
29425:                           mCell->GetBorderWidth(NS_SIDE_BOTTOM)));
29425:   }
29425:   if (mBottomRow) {
29425:     BCPixelSize half = BC_BORDER_TOP_HALF(aWidth);
32531:     mBottomRow->SetBottomBCBorderWidth(NS_MAX(nscoord(half),
29425:                                        mBottomRow->GetBottomBCBorderWidth()));
29425:   }
29425: }
29425: void
29425: BCMapCellInfo::SetTopBorderWidths(BCPixelSize aWidth)
29425: {
29425:  if (mCell) {
32531:      mCell->SetBorderWidth(NS_SIDE_TOP, NS_MAX(aWidth,
29425:                            mCell->GetBorderWidth(NS_SIDE_TOP)));
29425:   }
29425:   if (mTopRow) {
29425:     BCPixelSize half = BC_BORDER_BOTTOM_HALF(aWidth);
32531:     mTopRow->SetTopBCBorderWidth(NS_MAX(nscoord(half),
32531:                                         mTopRow->GetTopBCBorderWidth()));
29425:   }
29425: }
29425: void
29425: BCMapCellInfo::SetLeftBorderWidths(BCPixelSize aWidth)
29425: {
29425:   if (mCell) {
32531:     mCell->SetBorderWidth(mStartSide, NS_MAX(aWidth,
29425:                           mCell->GetBorderWidth(mStartSide)));
29425:   }
29425:   if (mLeftCol) {
29425:     BCPixelSize half = BC_BORDER_RIGHT_HALF(aWidth);
32531:     mLeftCol->SetLeftBorderWidth(NS_MAX(nscoord(half),
32531:                                         mLeftCol->GetLeftBorderWidth()));
29425:   }
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetTableBottomBorderWidth(BCPixelSize aWidth)
29425: {
39019:   mTableBCData->mBottomBorderWidth = NS_MAX(mTableBCData->mBottomBorderWidth,
39019:                                             aWidth);
29425: }
29425: 
29425: void
29425: BCMapCellInfo::SetColumn(PRInt32 aColX)
29425: {
29425:   mCurrentColFrame = mTableFrame->GetColFrame(aColX);
29425:   if (!mCurrentColFrame) {
29425:     NS_ERROR("null mCurrentColFrame");
29425:   }
29425:   mCurrentColGroupFrame = static_cast<nsTableColGroupFrame*>
29425:                             (mCurrentColFrame->GetParent());
29425:   if (!mCurrentColGroupFrame) {
29425:     NS_ERROR("null mCurrentColGroupFrame");
29425:   }
29425: }
29425: 
29425: void
29425: BCMapCellInfo::IncrementRow(PRBool aResetToTopRowOfCell)
29425: {
29425:   mCurrentRowFrame = (aResetToTopRowOfCell) ? mTopRow :
29425:                                                 mCurrentRowFrame->GetNextRow();
29425: }
29425: 
29425: BCCellBorder
29425: BCMapCellInfo::GetTopEdgeBorder()
29425: {
29425:   return CompareBorders(mTableFrame, mCurrentColGroupFrame, mCurrentColFrame,
36972:                         mRowGroup, mTopRow, mCell, mTableIsLTR, NS_SIDE_TOP,
36972:                         !ADJACENT);
29425: }
29425: 
29425: BCCellBorder
29425: BCMapCellInfo::GetBottomEdgeBorder()
29425: {
29425:   return CompareBorders(mTableFrame, mCurrentColGroupFrame, mCurrentColFrame,
36972:                         mRowGroup, mBottomRow, mCell, mTableIsLTR,
29425:                         NS_SIDE_BOTTOM, ADJACENT);
29425: }
29425: BCCellBorder
29425: BCMapCellInfo::GetLeftEdgeBorder()
29425: {
29425:   return CompareBorders(mTableFrame, mColGroup, mLeftCol, mRowGroup,
36972:                         mCurrentRowFrame, mCell, mTableIsLTR, NS_SIDE_LEFT,
36972:                         !ADJACENT);
29425: }
29425: BCCellBorder
29425: BCMapCellInfo::GetRightEdgeBorder()
29425: {
29425:   return CompareBorders(mTableFrame, mColGroup, mRightCol, mRowGroup,
36972:                         mCurrentRowFrame, mCell, mTableIsLTR, NS_SIDE_RIGHT,
36972:                         ADJACENT);
29425: }
29425: BCCellBorder
29425: BCMapCellInfo::GetRightInternalBorder()
29425: {
29425:   const nsIFrame* cg = (mCgAtRight) ? mColGroup : nsnull;
29425:   return CompareBorders(nsnull, cg, mRightCol, nsnull, nsnull, mCell,
36972:                         mTableIsLTR, NS_SIDE_RIGHT, ADJACENT);
29425: }
29425: 
29425: BCCellBorder
29425: BCMapCellInfo::GetLeftInternalBorder()
29425: {
29425:   const nsIFrame* cg = (mCgAtLeft) ? mColGroup : nsnull;
29425:   return CompareBorders(nsnull, cg, mLeftCol, nsnull, nsnull, mCell,
36972:                         mTableIsLTR, NS_SIDE_LEFT, !ADJACENT);
29425: }
29425: 
29425: BCCellBorder
29425: BCMapCellInfo::GetBottomInternalBorder()
29425: {
29425:   const nsIFrame* rg = (mRgAtBottom) ? mRowGroup : nsnull;
29425:   return CompareBorders(nsnull, nsnull, nsnull, rg, mBottomRow, mCell,
36972:                         mTableIsLTR, NS_SIDE_BOTTOM, ADJACENT);
29425: }
29425: 
29425: BCCellBorder
29425: BCMapCellInfo::GetTopInternalBorder()
29425: {
29425:   const nsIFrame* rg = (mRgAtTop) ? mRowGroup : nsnull;
29425:   return CompareBorders(nsnull, nsnull, nsnull, rg, mTopRow, mCell,
36972:                         mTableIsLTR, NS_SIDE_TOP, !ADJACENT);
29425: }
29425: 
    1: /* Here is the order for storing border edges in the cell map as a cell is processed. There are
    1:    n=colspan top and bottom border edges per cell and n=rowspan left and right border edges per cell.
    1: 
    1:    1) On the top edge of the table, store the top edge. Never store the top edge otherwise, since
    1:       a bottom edge from a cell above will take care of it.
    1:    2) On the left edge of the table, store the left edge. Never store the left edge othewise, since
    1:       a right edge from a cell to the left will take care of it.
    1:    3) Store the right edge (or edges if a row span)
    1:    4) Store the bottom edge (or edges if a col span)
    1: 
    1:    Since corners are computed with only an array of BCCornerInfo indexed by the number-of-cols, corner
    1:    calculations are somewhat complicated. Using an array with number-of-rows * number-of-col entries
    1:    would simplify this, but at an extra in memory cost of nearly 12 bytes per cell map entry. Collapsing
    1:    borders already have about an extra 8 byte per cell map entry overhead (this could be
    1:    reduced to 4 bytes if we are willing to not store border widths in nsTableCellFrame), Here are the
    1:    rules in priority order for storing cornes in the cell map as a cell is processed. top-left means the
    1:    left endpoint of the border edge on the top of the cell. There are n=colspan top and bottom border
    1:    edges per cell and n=rowspan left and right border edges per cell.
    1: 
    1:    1) On the top edge of the table, store the top-left corner, unless on the left edge of the table.
    1:       Never store the top-right corner, since it will get stored as a right-top corner.
    1:    2) On the left edge of the table, store the left-top corner. Never store the left-bottom corner,
    1:       since it will get stored as a bottom-left corner.
    1:    3) Store the right-top corner if (a) it is the top right corner of the table or (b) it is not on
    1:       the top edge of the table. Never store the right-bottom corner since it will get stored as a
    1:       bottom-right corner.
    1:    4) Store the bottom-right corner, if it is the bottom right corner of the table. Never store it
    1:       otherwise, since it will get stored as either a right-top corner by a cell below or
    1:       a bottom-left corner from a cell to the right.
    1:    5) Store the bottom-left corner, if (a) on the bottom edge of the table or (b) if the left edge hits
    1:       the top side of a colspan in its interior. Never store the corner otherwise, since it will
    1:       get stored as a right-top corner by a cell from below.
    1: 
    1:    XXX the BC-RTL hack - The correct fix would be a rewrite as described in bug 203686.
    1:    In order to draw borders in rtl conditions somehow correct, the existing structure which relies
    1:    heavily on the assumption that the next cell sibling will be on the right side, has been modified.
    1:    We flip the border during painting and during style lookup. Look for tableIsLTR for places where
    1:    the flipping is done.
    1:  */
    1: 
29425: 
    1: 
    1: // Calc the dominant border at every cell edge and corner within the current damage area
    1: void
    1: nsTableFrame::CalcBCBorders()
    1: {
    1:   NS_ASSERTION(IsBorderCollapse(),
    1:                "calling CalcBCBorders on separated-border table");
    1:   nsTableCellMap* tableCellMap = GetCellMap(); if (!tableCellMap) ABORT0();
    1:   PRInt32 numRows = GetRowCount();
    1:   PRInt32 numCols = GetColCount();
    1:   if (!numRows || !numCols)
    1:     return; // nothing to do
    1: 
    1:   // Get the property holding the table damage area and border widths
39965:   BCPropertyData* propData = static_cast<BCPropertyData*>
39965:     (Properties().Get(TableBCProperty()));
    1:   if (!propData) ABORT0();
    1: 
29425: 
29425: 
    1:   CheckFixDamageArea(numRows, numCols, propData->mDamageArea);
    1:   // calculate an expanded damage area
    1:   nsRect damageArea(propData->mDamageArea);
    1:   ExpandBCDamageArea(damageArea);
    1: 
29425:   // segments that are on the table border edges need
29425:   // to be initialized only once
    1:   PRBool tableBorderReset[4];
    1:   for (PRUint32 sideX = NS_SIDE_TOP; sideX <= NS_SIDE_LEFT; sideX++) {
    1:     tableBorderReset[sideX] = PR_FALSE;
    1:   }
    1: 
    1:   // vertical borders indexed in x-direction (cols)
29425:   BCCellBorders lastVerBorders(damageArea.width + 1, damageArea.x);
29425:   if (!lastVerBorders.borders) ABORT0();
    1:   BCCellBorder  lastTopBorder, lastBottomBorder;
    1:   // horizontal borders indexed in x-direction (cols)
29425:   BCCellBorders lastBottomBorders(damageArea.width + 1, damageArea.x);
29425:   if (!lastBottomBorders.borders) ABORT0();
    1:   PRBool startSeg;
    1:   PRBool gotRowBorder = PR_FALSE;
    1: 
29425:   BCMapCellInfo  info(this), ajaInfo(this);
29425: 
    1:   BCCellBorder currentBorder, adjacentBorder;
29425:   BCCorners topCorners(damageArea.width + 1, damageArea.x);
29425:   if (!topCorners.corners) ABORT0();
29425:   BCCorners bottomCorners(damageArea.width + 1, damageArea.x);
29425:   if (!bottomCorners.corners) ABORT0();
29425: 
29425:   BCMapCellIterator iter(this, damageArea);
    1:   for (iter.First(info); !iter.mAtEnd; iter.Next(info)) {
    1:     PRBool bottomRowSpan = PR_FALSE;
    1:     // see if lastTopBorder, lastBottomBorder need to be reset
    1:     if (iter.IsNewRow()) {
    1:       gotRowBorder = PR_FALSE;
29425:       lastTopBorder.Reset(info.mRowIndex, info.mRowSpan);
29425:       lastBottomBorder.Reset(info.GetCellEndRowIndex() + 1, info.mRowSpan);
29425:     }
29425:     else if (info.mColIndex > damageArea.x) {
29425:       lastBottomBorder = lastBottomBorders[info.mColIndex - 1];
29425:       if (info.mRowIndex >
29425:           (lastBottomBorder.rowIndex - lastBottomBorder.rowSpan)) {
    1:         // the top border's left edge butts against the middle of a rowspan
29425:         lastTopBorder.Reset(info.mRowIndex, info.mRowSpan);
29425:       }
29425:       if (lastBottomBorder.rowIndex > (info.GetCellEndRowIndex() + 1)) {
    1:         // the bottom border's left edge butts against the middle of a rowspan
29425:         lastBottomBorder.Reset(info.GetCellEndRowIndex() + 1, info.mRowSpan);
    1:         bottomRowSpan = PR_TRUE;
    1:       }
    1:     }
    1: 
29425:     // find the dominant border considering the cell's top border and the table,
29425:     // row group, row if the border is at the top of the table, otherwise it was
29425:     // processed in a previous row
29425:     if (0 == info.mRowIndex) {
    1:       if (!tableBorderReset[NS_SIDE_TOP]) {
    1:         propData->mTopBorderWidth = 0;
    1:         tableBorderReset[NS_SIDE_TOP] = PR_TRUE;
    1:       }
29425:       for (PRInt32 colX = info.mColIndex; colX <= info.GetCellEndColIndex();
29425:            colX++) {
29425:         info.SetColumn(colX);
29425:         currentBorder = info.GetTopEdgeBorder();
    1:         // update/store the top left & top right corners of the seg
    1:         BCCornerInfo& tlCorner = topCorners[colX]; // top left
    1:         if (0 == colX) {
29425:           // we are on right hand side of the corner
29425:           tlCorner.Set(NS_SIDE_RIGHT, currentBorder);
    1:         }
    1:         else {
    1:           tlCorner.Update(NS_SIDE_RIGHT, currentBorder);
29425:           tableCellMap->SetBCBorderCorner(eTopLeft, *iter.mCellMap, 0, 0, colX,
41421:                                           mozilla::css::Side(tlCorner.ownerSide),
41421:                                           tlCorner.subWidth,
29425:                                           tlCorner.bevel);
    1:         }
    1:         topCorners[colX + 1].Set(NS_SIDE_LEFT, currentBorder); // top right
    1:         // update lastTopBorder and see if a new segment starts
    1:         startSeg = SetHorBorder(currentBorder, tlCorner, lastTopBorder);
    1:         // store the border segment in the cell map
29425:         tableCellMap->SetBCBorderEdge(NS_SIDE_TOP, *iter.mCellMap, 0, 0, colX,
29425:                                       1, currentBorder.owner,
29425:                                       currentBorder.width, startSeg);
29425: 
29425:         info.SetTableTopBorderWidth(currentBorder.width);
29425:         info.SetTopBorderWidths(currentBorder.width);
29425:         info.SetColumnTopRightContBCBorder();
29425:       }
29425:       info.SetTableTopLeftContBCBorder();
    1:     }
    1:     else {
29425:       // see if the top border needs to be the start of a segment due to a
29425:       // vertical border owning the corner
29425:       if (info.mColIndex > 0) {
29425:         BCData& data = info.mCellData->mData;
    1:         if (!data.IsTopStart()) {
41419:           mozilla::css::Side cornerSide;
    1:           PRPackedBool bevel;
    1:           data.GetCorner(cornerSide, bevel);
    1:           if ((NS_SIDE_TOP == cornerSide) || (NS_SIDE_BOTTOM == cornerSide)) {
    1:             data.SetTopStart(PR_TRUE);
    1:           }
    1:         }
    1:       }
    1:     }
    1: 
29425:     // find the dominant border considering the cell's left border and the
29425:     // table, col group, col if the border is at the left of the table,
29425:     // otherwise it was processed in a previous col
29425:     if (0 == info.mColIndex) {
    1:       if (!tableBorderReset[NS_SIDE_LEFT]) {
    1:         propData->mLeftBorderWidth = 0;
    1:         tableBorderReset[NS_SIDE_LEFT] = PR_TRUE;
    1:       }
29425:       info.mCurrentRowFrame = nsnull;
29425:       for (PRInt32 rowY = info.mRowIndex; rowY <= info.GetCellEndRowIndex();
29425:            rowY++) {
29425:         info.IncrementRow(rowY == info.mRowIndex);
29425:         currentBorder = info.GetLeftEdgeBorder();
29425:         BCCornerInfo& tlCorner = (0 == rowY) ? topCorners[0] : bottomCorners[0];
    1:         tlCorner.Update(NS_SIDE_BOTTOM, currentBorder);
29425:         tableCellMap->SetBCBorderCorner(eTopLeft, *iter.mCellMap,
29425:                                         iter.mRowGroupStart, rowY, 0,
41421:                                         mozilla::css::Side(tlCorner.ownerSide),
41421:                                         tlCorner.subWidth,
29425:                                         tlCorner.bevel);
    1:         bottomCorners[0].Set(NS_SIDE_TOP, currentBorder); // bottom left
29425: 
    1:         // update lastVerBordersBorder and see if a new segment starts
    1:         startSeg = SetBorder(currentBorder, lastVerBorders[0]);
    1:         // store the border segment in the cell map
29425:         tableCellMap->SetBCBorderEdge(NS_SIDE_LEFT, *iter.mCellMap,
29425:                                       iter.mRowGroupStart, rowY, info.mColIndex,
29425:                                       1, currentBorder.owner,
29425:                                       currentBorder.width, startSeg);
29425:         info.SetTableLeftBorderWidth(rowY , currentBorder.width);
29425:         info.SetLeftBorderWidths(currentBorder.width);
29425:         info.SetRowLeftContBCBorder();
29425:       }
29425:       info.SetRowGroupLeftContBCBorder();
29425:     }
29425: 
29425:     // find the dominant border considering the cell's right border, adjacent
29425:     // cells and the table, row group, row
29425:     if (info.mNumTableCols == info.GetCellEndColIndex() + 1) {
29425:       // touches right edge of table
    1:       if (!tableBorderReset[NS_SIDE_RIGHT]) {
    1:         propData->mRightBorderWidth = 0;
    1:         tableBorderReset[NS_SIDE_RIGHT] = PR_TRUE;
    1:       }
29425:       info.mCurrentRowFrame = nsnull;
29425:       for (PRInt32 rowY = info.mRowIndex; rowY <= info.GetCellEndRowIndex();
29425:            rowY++) {
29425:         info.IncrementRow(rowY == info.mRowIndex);
29425:         currentBorder = info.GetRightEdgeBorder();
    1:         // update/store the top right & bottom right corners
29425:         BCCornerInfo& trCorner = (0 == rowY) ?
29425:                                  topCorners[info.GetCellEndColIndex() + 1] :
29425:                                  bottomCorners[info.GetCellEndColIndex() + 1];
    1:         trCorner.Update(NS_SIDE_BOTTOM, currentBorder);   // top right
29425:         tableCellMap->SetBCBorderCorner(eTopRight, *iter.mCellMap,
29425:                                         iter.mRowGroupStart, rowY,
29425:                                         info.GetCellEndColIndex(),
41421:                                         mozilla::css::Side(trCorner.ownerSide),
41421:                                         trCorner.subWidth,
29425:                                         trCorner.bevel);
29425:         BCCornerInfo& brCorner = bottomCorners[info.GetCellEndColIndex() + 1];
    1:         brCorner.Set(NS_SIDE_TOP, currentBorder); // bottom right
29425:         tableCellMap->SetBCBorderCorner(eBottomRight, *iter.mCellMap,
29425:                                         iter.mRowGroupStart, rowY,
29425:                                         info.GetCellEndColIndex(),
41421:                                         mozilla::css::Side(brCorner.ownerSide),
41421:                                         brCorner.subWidth,
29425:                                         brCorner.bevel);
    1:         // update lastVerBorders and see if a new segment starts
29425:         startSeg = SetBorder(currentBorder,
29425:                              lastVerBorders[info.GetCellEndColIndex() + 1]);
    1:         // store the border segment in the cell map and update cellBorders
29425:         tableCellMap->SetBCBorderEdge(NS_SIDE_RIGHT, *iter.mCellMap,
29425:                                       iter.mRowGroupStart, rowY,
29425:                                       info.GetCellEndColIndex(), 1,
29425:                                       currentBorder.owner, currentBorder.width,
29425:                                       startSeg);
29425:         info.SetTableRightBorderWidth(rowY, currentBorder.width);
29425:         info.SetRightBorderWidths(currentBorder.width);
29425:         info.SetRowRightContBCBorder();
29425:       }
29425:       info.SetRowGroupRightContBCBorder();
    1:     }
    1:     else {
    1:       PRInt32 segLength = 0;
29425:       BCMapCellInfo priorAjaInfo(this);
29425:       for (PRInt32 rowY = info.mRowIndex; rowY <= info.GetCellEndRowIndex();
29425:            rowY += segLength) {
29425:         iter.PeekRight(info, rowY, ajaInfo);
29425:         currentBorder  = info.GetRightInternalBorder();
29425:         adjacentBorder = ajaInfo.GetLeftInternalBorder();
29425:         currentBorder = CompareBorders(!CELL_CORNER, currentBorder,
29425:                                         adjacentBorder, !HORIZONTAL);
29425: 
32531:         segLength = NS_MAX(1, ajaInfo.mRowIndex + ajaInfo.mRowSpan - rowY);
32531:         segLength = NS_MIN(segLength, info.mRowIndex + info.mRowSpan - rowY);
    1: 
    1:         // update lastVerBorders and see if a new segment starts
29425:         startSeg = SetBorder(currentBorder,
29425:                              lastVerBorders[info.GetCellEndColIndex() + 1]);
    1:         // store the border segment in the cell map and update cellBorders
29425:         if (info.GetCellEndColIndex() < damageArea.XMost() &&
29425:             rowY >= damageArea.y && rowY < damageArea.YMost()) {
29425:           tableCellMap->SetBCBorderEdge(NS_SIDE_RIGHT, *iter.mCellMap,
29425:                                         iter.mRowGroupStart, rowY,
29425:                                         info.GetCellEndColIndex(), segLength,
29425:                                         currentBorder.owner,
29425:                                         currentBorder.width, startSeg);
29425:           info.SetRightBorderWidths(currentBorder.width);
29425:           ajaInfo.SetLeftBorderWidths(currentBorder.width);
    1:         }
    1:         // update the top right corner
29425:         PRBool hitsSpanOnRight = (rowY > ajaInfo.mRowIndex) &&
29425:                                   (rowY < ajaInfo.mRowIndex + ajaInfo.mRowSpan);
29425:         BCCornerInfo* trCorner = ((0 == rowY) || hitsSpanOnRight) ?
29425:                                  &topCorners[info.GetCellEndColIndex() + 1] :
29425:                                  &bottomCorners[info.GetCellEndColIndex() + 1];
    1:         trCorner->Update(NS_SIDE_BOTTOM, currentBorder);
29425:         // if this is not the first time through,
29425:         // consider the segment to the right
29425:         if (rowY != info.mRowIndex) {
29425:           currentBorder  = priorAjaInfo.GetBottomInternalBorder();
29425:           adjacentBorder = ajaInfo.GetTopInternalBorder();
29425:           currentBorder = CompareBorders(!CELL_CORNER, currentBorder,
29425:                                           adjacentBorder, HORIZONTAL);
    1:           trCorner->Update(NS_SIDE_RIGHT, currentBorder);
    1:         }
    1:         // store the top right corner in the cell map
29425:         if (info.GetCellEndColIndex() < damageArea.XMost() &&
29425:             rowY >= damageArea.y) {
29425:           if (0 != rowY) {
29425:             tableCellMap->SetBCBorderCorner(eTopRight, *iter.mCellMap,
29425:                                             iter.mRowGroupStart, rowY,
29425:                                             info.GetCellEndColIndex(),
41421:                                             mozilla::css::Side(trCorner->ownerSide),
29425:                                             trCorner->subWidth,
29425:                                             trCorner->bevel);
    1:           }
    1:           // store any corners this cell spans together with the aja cell
29425:           for (PRInt32 rX = rowY + 1; rX < rowY + segLength; rX++) {
29425:             tableCellMap->SetBCBorderCorner(eBottomRight, *iter.mCellMap,
29425:                                             iter.mRowGroupStart, rX,
29425:                                             info.GetCellEndColIndex(),
41421:                                             mozilla::css::Side(trCorner->ownerSide),
29425:                                             trCorner->subWidth, PR_FALSE);
    1:           }
    1:         }
    1:         // update bottom right corner, topCorners, bottomCorners
29425:         hitsSpanOnRight = (rowY + segLength <
29425:                            ajaInfo.mRowIndex + ajaInfo.mRowSpan);
29425:         BCCornerInfo& brCorner = (hitsSpanOnRight) ?
29425:                                  topCorners[info.GetCellEndColIndex() + 1] :
29425:                                  bottomCorners[info.GetCellEndColIndex() + 1];
    1:         brCorner.Set(NS_SIDE_TOP, currentBorder);
    1:         priorAjaInfo = ajaInfo;
    1:       }
    1:     }
29425:     for (PRInt32 colX = info.mColIndex + 1; colX <= info.GetCellEndColIndex();
29425:          colX++) {
    1:       lastVerBorders[colX].Reset(0,1);
    1:     }
    1: 
29425:     // find the dominant border considering the cell's bottom border, adjacent
29425:     // cells and the table, row group, row
29425:     if (info.mNumTableRows == info.GetCellEndRowIndex() + 1) {
29425:       // touches bottom edge of table
    1:       if (!tableBorderReset[NS_SIDE_BOTTOM]) {
    1:         propData->mBottomBorderWidth = 0;
    1:         tableBorderReset[NS_SIDE_BOTTOM] = PR_TRUE;
    1:       }
29425:       for (PRInt32 colX = info.mColIndex; colX <= info.GetCellEndColIndex();
29425:            colX++) {
29425:         info.SetColumn(colX);
29425:         currentBorder = info.GetBottomEdgeBorder();
    1:         // update/store the bottom left & bottom right corners
    1:         BCCornerInfo& blCorner = bottomCorners[colX]; // bottom left
    1:         blCorner.Update(NS_SIDE_RIGHT, currentBorder);
29425:         tableCellMap->SetBCBorderCorner(eBottomLeft, *iter.mCellMap,
29425:                                         iter.mRowGroupStart,
29425:                                         info.GetCellEndRowIndex(),
41421:                                         colX,
41421:                                         mozilla::css::Side(blCorner.ownerSide),
29425:                                         blCorner.subWidth, blCorner.bevel);
    1:         BCCornerInfo& brCorner = bottomCorners[colX + 1]; // bottom right
    1:         brCorner.Update(NS_SIDE_LEFT, currentBorder);
29425:         if (info.mNumTableCols == colX + 1) { // lower right corner of the table
29425:           tableCellMap->SetBCBorderCorner(eBottomRight, *iter.mCellMap,
29425:                                           iter.mRowGroupStart,
29425:                                           info.GetCellEndRowIndex(),colX,
41421:                                           mozilla::css::Side(brCorner.ownerSide),
41421:                                           brCorner.subWidth,
29425:                                           brCorner.bevel, PR_TRUE);
    1:         }
    1:         // update lastBottomBorder and see if a new segment starts
    1:         startSeg = SetHorBorder(currentBorder, blCorner, lastBottomBorder);
    1:         if (!startSeg) {
29425:            // make sure that we did not compare apples to oranges i.e. the
29425:            // current border should be a continuation of the lastBottomBorder,
29425:            // as it is a bottom border
29425:            // add 1 to the info.GetCellEndRowIndex()
29425:            startSeg = (lastBottomBorder.rowIndex !=
29425:                        (info.GetCellEndRowIndex() + 1));
    1:         }
    1:         // store the border segment in the cell map and update cellBorders
29425:         tableCellMap->SetBCBorderEdge(NS_SIDE_BOTTOM, *iter.mCellMap,
29425:                                       iter.mRowGroupStart,
29425:                                       info.GetCellEndRowIndex(),
29425:                                       colX, 1, currentBorder.owner,
29425:                                       currentBorder.width, startSeg);
    1:         // update lastBottomBorders
29425:         lastBottomBorder.rowIndex = info.GetCellEndRowIndex() + 1;
29425:         lastBottomBorder.rowSpan = info.mRowSpan;
    1:         lastBottomBorders[colX] = lastBottomBorder;
29425: 
29425:         info.SetBottomBorderWidths(currentBorder.width);
29425:         info.SetTableBottomBorderWidth(currentBorder.width);
29425:         info.SetColumnBottomContBCBorder();
29425:       }
29425:       info.SetRowGroupBottomContBCBorder();
29425:       info.SetColGroupBottomContBCBorder();
    1:     }
    1:     else {
    1:       PRInt32 segLength = 0;
29425:       for (PRInt32 colX = info.mColIndex; colX <= info.GetCellEndColIndex();
29425:            colX += segLength) {
    1:         iter.PeekBottom(info, colX, ajaInfo);
29425:         currentBorder  = info.GetBottomInternalBorder();
29425:         adjacentBorder = ajaInfo.GetTopInternalBorder();
29425:         currentBorder = CompareBorders(!CELL_CORNER, currentBorder,
29425:                                         adjacentBorder, HORIZONTAL);
32531:         segLength = NS_MAX(1, ajaInfo.mColIndex + ajaInfo.mColSpan - colX);
32531:         segLength = NS_MIN(segLength, info.mColIndex + info.mColSpan - colX);
    1: 
    1:         // update, store the bottom left corner
    1:         BCCornerInfo& blCorner = bottomCorners[colX]; // bottom left
29425:         PRBool hitsSpanBelow = (colX > ajaInfo.mColIndex) &&
29425:                                (colX < ajaInfo.mColIndex + ajaInfo.mColSpan);
    1:         PRBool update = PR_TRUE;
29425:         if ((colX == info.mColIndex) && (colX > damageArea.x)) {
    1:           PRInt32 prevRowIndex = lastBottomBorders[colX - 1].rowIndex;
29425:           if (prevRowIndex > info.GetCellEndRowIndex() + 1) {
29425:             // hits a rowspan on the right
29425:             update = PR_FALSE;
29425:             // the corner was taken care of during the cell on the left
29425:           }
29425:           else if (prevRowIndex < info.GetCellEndRowIndex() + 1) {
29425:             // spans below the cell to the left
    1:             topCorners[colX] = blCorner;
    1:             blCorner.Set(NS_SIDE_RIGHT, currentBorder);
    1:             update = PR_FALSE;
    1:           }
    1:         }
    1:         if (update) {
    1:           blCorner.Update(NS_SIDE_RIGHT, currentBorder);
    1:         }
29425:         if (info.GetCellEndRowIndex() < damageArea.YMost() &&
29425:             (colX >= damageArea.x)) {
    1:           if (hitsSpanBelow) {
29425:             tableCellMap->SetBCBorderCorner(eBottomLeft, *iter.mCellMap,
29425:                                             iter.mRowGroupStart,
29425:                                             info.GetCellEndRowIndex(), colX,
41421:                                             mozilla::css::Side(blCorner.ownerSide),
29425:                                             blCorner.subWidth, blCorner.bevel);
    1:           }
    1:           // store any corners this cell spans together with the aja cell
    1:           for (PRInt32 cX = colX + 1; cX < colX + segLength; cX++) {
    1:             BCCornerInfo& corner = bottomCorners[cX];
    1:             corner.Set(NS_SIDE_RIGHT, currentBorder);
29425:             tableCellMap->SetBCBorderCorner(eBottomLeft, *iter.mCellMap,
29425:                                             iter.mRowGroupStart,
29425:                                             info.GetCellEndRowIndex(), cX,
41421:                                             mozilla::css::Side(corner.ownerSide),
41421:                                             corner.subWidth,
29425:                                             PR_FALSE);
    1:           }
    1:         }
    1:         // update lastBottomBorders and see if a new segment starts
    1:         startSeg = SetHorBorder(currentBorder, blCorner, lastBottomBorder);
    1:         if (!startSeg) {
29425:            // make sure that we did not compare apples to oranges i.e. the
29425:            // current border should be a continuation of the lastBottomBorder,
29425:            // as it is a bottom border
29425:            // add 1 to the info.GetCellEndRowIndex()
29425:            startSeg = (lastBottomBorder.rowIndex !=
29425:                        info.GetCellEndRowIndex() + 1);
29425:         }
29425:         lastBottomBorder.rowIndex = info.GetCellEndRowIndex() + 1;
29425:         lastBottomBorder.rowSpan = info.mRowSpan;
    1:         for (PRInt32 cX = colX; cX < colX + segLength; cX++) {
    1:           lastBottomBorders[cX] = lastBottomBorder;
    1:         }
    1: 
    1:         // store the border segment the cell map and update cellBorders
29425:         if (info.GetCellEndRowIndex() < damageArea.YMost() &&
29425:             (colX >= damageArea.x) &&
29425:             (colX < damageArea.XMost())) {
29425:           tableCellMap->SetBCBorderEdge(NS_SIDE_BOTTOM, *iter.mCellMap,
29425:                                         iter.mRowGroupStart,
29425:                                         info.GetCellEndRowIndex(),
29425:                                         colX, segLength, currentBorder.owner,
29425:                                         currentBorder.width, startSeg);
29425:           info.SetBottomBorderWidths(currentBorder.width);
29425:           ajaInfo.SetTopBorderWidths(currentBorder.width);
    1:         }
    1:         // update bottom right corner
    1:         BCCornerInfo& brCorner = bottomCorners[colX + segLength];
    1:         brCorner.Update(NS_SIDE_LEFT, currentBorder);
    1:       }
29425:       if (!gotRowBorder && 1 == info.mRowSpan &&
29425:           (ajaInfo.mTopRow || info.mRgAtBottom)) {
    1:         //get continuous row/row group border
    1:         //we need to check the row group's bottom border if this is
    1:         //the last row in the row group, but only a cell with rowspan=1
    1:         //will know whether *this* row is at the bottom
29425:         const nsIFrame* nextRowGroup = (ajaInfo.mRgAtTop) ? ajaInfo.mRowGroup :
29425:                                                              nsnull;
29425:         info.SetInnerRowGroupBottomContBCBorder(nextRowGroup, ajaInfo.mTopRow);
    1:         gotRowBorder = PR_TRUE;
    1:       }
    1:     }
    1: 
29425:     // see if the cell to the right had a rowspan and its lower left border
29425:     // needs be joined with this one's bottom
29425:     // if  there is a cell to the right and the cell to right was a rowspan
29425:     if ((info.mNumTableCols != info.GetCellEndColIndex() + 1) &&
29425:         (lastBottomBorders[info.GetCellEndColIndex() + 1].rowSpan > 1)) {
29425:       BCCornerInfo& corner = bottomCorners[info.GetCellEndColIndex() + 1];
29425:       if ((NS_SIDE_TOP != corner.ownerSide) &&
29425:           (NS_SIDE_BOTTOM != corner.ownerSide)) {
29425:         // not a vertical owner
    1:         BCCellBorder& thisBorder = lastBottomBorder;
29425:         BCCellBorder& nextBorder = lastBottomBorders[info.mColIndex + 1];
29425:         if ((thisBorder.color == nextBorder.color) &&
29425:             (thisBorder.width == nextBorder.width) &&
    1:             (thisBorder.style == nextBorder.style)) {
29425:           // set the flag on the next border indicating it is not the start of a
29425:           // new segment
    1:           if (iter.mCellMap) {
62666:             tableCellMap->ResetTopStart(NS_SIDE_BOTTOM, *iter.mCellMap,
29425:                                         info.GetCellEndRowIndex(),
29425:                                         info.GetCellEndColIndex() + 1);
29425:           }
29425:         }
29425:       }
29425:     }
29425:   } // for (iter.First(info); info.mCell; iter.Next(info)) {
    1:   // reset the bc flag and damage area
    1:   SetNeedToCalcBCBorders(PR_FALSE);
    1:   propData->mDamageArea.x = propData->mDamageArea.y = propData->mDamageArea.width = propData->mDamageArea.height = 0;
    1: #ifdef DEBUG_TABLE_CELLMAP
    1:   mCellMap->Dump();
    1: #endif
    1: }
    1: 
34593: class BCPaintBorderIterator;
34593: 
34593: struct BCVerticalSeg
34593: {
34593:   BCVerticalSeg();
34593: 
34593:   void Start(BCPaintBorderIterator& aIter,
34593:              BCBorderOwner          aBorderOwner,
34593:              BCPixelSize            aVerSegWidth,
34593:              BCPixelSize            aHorSegHeight);
34593: 
34593:   void Initialize(BCPaintBorderIterator& aIter);
34593:   void GetBottomCorner(BCPaintBorderIterator& aIter,
34593:                        BCPixelSize            aHorSegHeight);
34593: 
34593: 
34593:    void Paint(BCPaintBorderIterator& aIter,
68481:               nsRenderingContext&   aRenderingContext,
34593:               BCPixelSize            aHorSegHeight);
34593:   void AdvanceOffsetY();
34593:   void IncludeCurrentBorder(BCPaintBorderIterator& aIter);
34593: 
34593: 
34593:   union {
34593:     nsTableColFrame*  mCol;
34593:     PRInt32           mColWidth;
34593:   };
34593:   nscoord               mOffsetX;    // x-offset with respect to the table edge
34593:   nscoord               mOffsetY;    // y-offset with respect to the table edge
34593:   nscoord               mLength;     // vertical length including corners
34593:   BCPixelSize           mWidth;      // width in pixels
34593: 
34593:   nsTableCellFrame*     mAjaCell;       // previous sibling to the first cell
34593:                                         // where the segment starts, it can be
34593:                                         // the owner of a segment
34593:   nsTableCellFrame*     mFirstCell;     // cell at the start of the segment
34593:   nsTableRowGroupFrame* mFirstRowGroup; // row group at the start of the segment
34593:   nsTableRowFrame*      mFirstRow;      // row at the start of the segment
34593:   nsTableCellFrame*     mLastCell;      // cell at the current end of the
34593:                                         // segment
34593: 
34593: 
34593:   PRUint8               mOwner;         // owner of the border, defines the
34593:                                         // style
41419:   mozilla::css::Side    mTopBevelSide;  // direction to bevel at the top
34593:   nscoord               mTopBevelOffset; // how much to bevel at the top
34593:   BCPixelSize           mBottomHorSegHeight; // height of the crossing
34593:                                         //horizontal border
34593:   nscoord               mBottomOffset;  // how much longer is the segment due
34593:                                         // to the horizontal border, by this
34593:                                         // amount the next segment needs to be
34593:                                         // shifted.
34593:   PRBool                mIsBottomBevel; // should we bevel at the bottom
34593: };
34593: 
34593: struct BCHorizontalSeg
34593: {
34593:   BCHorizontalSeg();
34593: 
34593:   void Start(BCPaintBorderIterator& aIter,
34593:              BCBorderOwner          aBorderOwner,
34593:              BCPixelSize            aBottomVerSegWidth,
34593:              BCPixelSize            aHorSegHeight);
34593:    void GetRightCorner(BCPaintBorderIterator& aIter,
34593:                        BCPixelSize            aLeftSegWidth);
34593:    void AdvanceOffsetX(PRInt32 aIncrement);
34593:    void IncludeCurrentBorder(BCPaintBorderIterator& aIter);
34593:    void Paint(BCPaintBorderIterator& aIter,
68481:               nsRenderingContext&   aRenderingContext);
34593: 
34593:   nscoord            mOffsetX;       // x-offset with respect to the table edge
34593:   nscoord            mOffsetY;       // y-offset with respect to the table edge
34593:   nscoord            mLength;        // horizontal length including corners
34593:   BCPixelSize        mWidth;         // border width in pixels
34593:   nscoord            mLeftBevelOffset;   // how much to bevel at the left
41419:   mozilla::css::Side mLeftBevelSide;     // direction to bevel at the left
34593:   PRBool             mIsRightBevel;      // should we bevel at the right end
34593:   nscoord            mRightBevelOffset;  // how much to bevel at the right
41419:   mozilla::css::Side mRightBevelSide;    // direction to bevel at the right
34593:   nscoord            mEndOffset;         // how much longer is the segment due
34593:                                          // to the vertical border, by this
34593:                                          // amount the next segment needs to be
34593:                                          // shifted.
34593:   PRUint8            mOwner;             // owner of the border, defines the
34593:                                          // style
34593:   nsTableCellFrame*  mFirstCell;         // cell at the start of the segment
34593:   nsTableCellFrame*  mAjaCell;           // neighboring cell to the first cell
34593:                                          // where the segment starts, it can be
34593:                                          // the owner of a segment
34593: };
34593: 
    1: // Iterates over borders (left border, corner, top border) in the cell map within a damage area
    1: // from left to right, top to bottom. All members are in terms of the 1st in flow frames, except
    1: // where suffixed by InFlow.
34593: class BCPaintBorderIterator
    1: {
    1: public:
34593: 
34593: 
34593:   BCPaintBorderIterator(nsTableFrame* aTable);
34593:   ~BCPaintBorderIterator() { if (mVerInfo) {
34593:                               delete [] mVerInfo;
34593:                            }}
34593:   void Reset();
34593: 
34593:   PRBool SetDamageArea(nsRect aDirtyRect);
    1:   void First();
    1:   void Next();
68481:   void AccumulateOrPaintHorizontalSegment(nsRenderingContext& aRenderingContext);
68481:   void AccumulateOrPaintVerticalSegment(nsRenderingContext& aRenderingContext);
34593:   void ResetVerInfo();
34593:   void StoreColumnWidth(PRInt32 aIndex);
34593:   PRBool VerticalSegmentOwnsCorner();
34593: 
34593:   nsTableFrame*         mTable;
34593:   nsTableFrame*         mTableFirstInFlow;
34593:   nsTableCellMap*       mTableCellMap;
34593:   nsCellMap*            mCellMap;
34593:   PRBool                mTableIsLTR;
34593:   PRInt32               mColInc;            // +1 for ltr -1 for rtl
34593:   const nsStyleBackground* mTableBgColor;
34593:   nsTableFrame::RowGroupArray mRowGroups;
34593: 
34593:   nsTableRowGroupFrame* mPrevRg;
34593:   nsTableRowGroupFrame* mRg;
34593:   PRBool                mIsRepeatedHeader;
34593:   PRBool                mIsRepeatedFooter;
34593:   nsTableRowGroupFrame* mStartRg; // first row group in the damagearea
34593:   PRInt32               mRgIndex; // current row group index in the
34593:                                         // mRowgroups array
34593:   PRInt32               mFifRgFirstRowIndex; // start row index of the first in
34593:                                            // flow of the row group
34593:   PRInt32               mRgFirstRowIndex; // row index of the first row in the
34593:                                           // row group
34593:   PRInt32               mRgLastRowIndex; // row index of the last row in the row
34593:                                          // group
34593:   PRInt32               mNumTableRows;   // number of rows in the table and all
34593:                                          // continuations
34593:   PRInt32               mNumTableCols;   // number of columns in the table
34593:   PRInt32               mColIndex;       // with respect to the table
34593:   PRInt32               mRowIndex;       // with respect to the table
34593:   PRInt32               mRepeatedHeaderRowIndex; // row index in a repeated
34593:                                             //header, it's equivalent to
34593:                                             // mRowIndex when we're in a repeated
34593:                                             // header, and set to the last row
34593:                                             // index of a repeated header when
34593:                                             // we're not
34593:   PRBool                mIsNewRow;
34593:   PRBool                mAtEnd;             // the iterator cycled over all
34593:                                              // borders
34593:   nsTableRowFrame*      mPrevRow;
34593:   nsTableRowFrame*      mRow;
34593:   nsTableRowFrame*      mStartRow;    //first row in a inside the damagearea
34593: 
34593: 
34593:   // cell properties
34593:   nsTableCellFrame*     mPrevCell;
34593:   nsTableCellFrame*     mCell;
34593:   BCCellData*           mPrevCellData;
34593:   BCCellData*           mCellData;
34593:   BCData*               mBCData;
34593: 
34593:   PRBool                IsTableTopMost()    {return (mRowIndex == 0) && !mTable->GetPrevInFlow();}
34593:   PRBool                IsTableRightMost()  {return (mColIndex >= mNumTableCols);}
34593:   PRBool                IsTableBottomMost() {return (mRowIndex >= mNumTableRows) && !mTable->GetNextInFlow();}
34593:   PRBool                IsTableLeftMost()   {return (mColIndex == 0);}
34593:   PRBool                IsDamageAreaTopMost()    {return (mRowIndex == mDamageArea.y);}
34593:   PRBool                IsDamageAreaRightMost()  {return (mColIndex >= mDamageArea.XMost());}
34593:   PRBool                IsDamageAreaBottomMost() {return (mRowIndex >= mDamageArea.YMost());}
34593:   PRBool                IsDamageAreaLeftMost()   {return (mColIndex == mDamageArea.x);}
34593:   PRInt32               GetRelativeColIndex() {return (mColIndex - mDamageArea.x);}
34593: 
34593:   nsRect                mDamageArea;        // damageArea in cellmap coordinates
34593:   PRBool                IsAfterRepeatedHeader() { return !mIsRepeatedHeader && (mRowIndex == (mRepeatedHeaderRowIndex + 1));}
34593:   PRBool                StartRepeatedFooter() {return mIsRepeatedFooter && (mRowIndex == mRgFirstRowIndex) && (mRowIndex != mDamageArea.y);}
34593:   nscoord               mInitialOffsetX;  // offsetX of the first border with
34593:                                             // respect to the table
34593:   nscoord               mInitialOffsetY;    // offsetY of the first border with
34593:                                             // respect to the table
34593:   nscoord               mNextOffsetY;       // offsetY of the next segment
34593:   BCVerticalSeg*        mVerInfo; // this array is used differently when
34593:                                   // horizontal and vertical borders are drawn
34593:                                   // When horizontal border are drawn we cache
34593:                                   // the column widths and the width of the
34593:                                   // vertical borders that arrive from top
34593:                                   // When we draw vertical borders we store
34593:                                   // lengths and width for vertical borders
34593:                                   // before they are drawn while we  move over
34593:                                   // the columns in the damage area
34593:                                   // It has one more elements than columns are
34593:                                   //in the table.
34593:   BCHorizontalSeg       mHorSeg;            // the horizontal segment while we
34593:                                             // move over the colums
34593:   BCPixelSize           mPrevHorSegHeight;  // the height of the previous
34593:                                             // horizontal border
    1: 
    1: private:
    1: 
    1:   PRBool SetNewRow(nsTableRowFrame* aRow = nsnull);
    1:   PRBool SetNewRowGroup();
34593:   void   SetNewData(PRInt32 aRowIndex, PRInt32 aColIndex);
    1: 
    1: };
    1: 
34593: 
34593: 
34593: BCPaintBorderIterator::BCPaintBorderIterator(nsTableFrame* aTable)
34593: {
34593:   mTable      = aTable;
34593:   mVerInfo    = nsnull;
34593:   nsMargin childAreaOffset = mTable->GetChildAreaOffset(nsnull);
34593:   mTableFirstInFlow    = (nsTableFrame*) mTable->GetFirstInFlow();
34593:   mTableCellMap        = mTable->GetCellMap();
34593:   // y position of first row in damage area
34593:   mInitialOffsetY = (mTable->GetPrevInFlow()) ? 0 : childAreaOffset.top;
34593:   mNumTableRows  = mTable->GetRowCount();
34593:   mNumTableCols  = mTable->GetColCount();
34593: 
34593:   // Get the ordered row groups
34593:   mTable->OrderRowGroups(mRowGroups);
37318:   // initialize to a non existing index
37318:   mRepeatedHeaderRowIndex = -99;
34593: 
34593:   mTableIsLTR = mTable->GetStyleVisibility()->mDirection ==
34593:                    NS_STYLE_DIRECTION_LTR;
34593:   mColInc = (mTableIsLTR) ? 1 : -1;
34593: 
40588:   nsIFrame* bgFrame =
40588:     nsCSSRendering::FindNonTransparentBackgroundFrame(aTable);
40588:   mTableBgColor = bgFrame->GetStyleBackground();
34593: }
34593: 
34593: /**
34593:  * determine the damage area in terms of rows and columns and finalize
34593:    mInitialOffsetY and mInitialOffsetY
34593:    @param aDirtyRect - dirty rect in table coordinates
34593:    @return - do we need to paint at all
34593:  */
34593: PRBool
34593: BCPaintBorderIterator::SetDamageArea(nsRect aDirtyRect)
34593: {
34593: 
34593:   PRUint32 startRowIndex, endRowIndex, startColIndex, endColIndex;
34593:   startRowIndex = endRowIndex = startColIndex = endColIndex = 0;
34593:   PRBool done = PR_FALSE;
34593:   PRBool haveIntersect = PR_FALSE;
34593:   // find startRowIndex, endRowIndex, startRowY
34593:   PRInt32 rowY = mInitialOffsetY;
34593:   for (PRUint32 rgX = 0; rgX < mRowGroups.Length() && !done; rgX++) {
34593:     nsTableRowGroupFrame* rgFrame = mRowGroups[rgX];
34593:     for (nsTableRowFrame* rowFrame = rgFrame->GetFirstRow(); rowFrame;
34593:          rowFrame = rowFrame->GetNextRow()) {
34593:       // conservatively estimate the half border widths outside the row
34593:       nscoord topBorderHalf    = (mTable->GetPrevInFlow()) ? 0 :
34593:        nsPresContext::CSSPixelsToAppUnits(rowFrame->GetTopBCBorderWidth() + 1);
34593:       nscoord bottomBorderHalf = (mTable->GetNextInFlow()) ? 0 :
34593:         nsPresContext::CSSPixelsToAppUnits(rowFrame->GetBottomBCBorderWidth() + 1);
34593:       // get the row rect relative to the table rather than the row group
34593:       nsSize rowSize = rowFrame->GetSize();
34593:       if (haveIntersect) {
34593:         if (aDirtyRect.YMost() >= (rowY - topBorderHalf)) {
34593:           nsTableRowFrame* fifRow =
34593:             (nsTableRowFrame*)rowFrame->GetFirstInFlow();
34593:           if (!fifRow) ABORT1(PR_FALSE);
34593:           endRowIndex = fifRow->GetRowIndex();
34593:         }
34593:         else done = PR_TRUE;
34593:       }
34593:       else {
34593:         if ((rowY + rowSize.height + bottomBorderHalf) >= aDirtyRect.y) {
34593:           mStartRg  = rgFrame;
34593:           mStartRow = rowFrame;
34593:           nsTableRowFrame* fifRow =
34593:             (nsTableRowFrame*)rowFrame->GetFirstInFlow();
34593:           if (!fifRow) ABORT1(PR_FALSE);
34593:           startRowIndex = endRowIndex = fifRow->GetRowIndex();
34593:           haveIntersect = PR_TRUE;
34593:         }
34593:         else {
34593:           mInitialOffsetY += rowSize.height;
34593:         }
34593:       }
34593:       rowY += rowSize.height;
34593:     }
34593:   }
34593:   mNextOffsetY = mInitialOffsetY;
34593: 
34593:   // XXX comment refers to the obsolete NS_FRAME_OUTSIDE_CHILDREN flag
34593:   // XXX but I don't understand it, so not changing it for now
34593:   // outer table borders overflow the table, so the table might be
34593:   // target to other areas as the NS_FRAME_OUTSIDE_CHILDREN is set
34593:   // on the table
34593:   if (!haveIntersect)
34593:     return PR_FALSE;
34593:   // find startColIndex, endColIndex, startColX
34593:   haveIntersect = PR_FALSE;
34593:   if (0 == mNumTableCols)
34593:     return PR_FALSE;
34593:   PRInt32 leftCol, rightCol; // columns are in the range [leftCol, rightCol)
34593: 
34593:   nsMargin childAreaOffset = mTable->GetChildAreaOffset(nsnull);
34593:   if (mTableIsLTR) {
34593:     mInitialOffsetX = childAreaOffset.left; // x position of first col in
34593:                                             // damage area
34593:     leftCol = 0;
34593:     rightCol = mNumTableCols;
34593:   } else {
34593:     // x position of first col in damage area
34593:     mInitialOffsetX = mTable->GetRect().width - childAreaOffset.right;
34593:     leftCol = mNumTableCols-1;
34593:     rightCol = -1;
34593:   }
34593:   nscoord x = 0;
34593:   PRInt32 colX;
34593:   for (colX = leftCol; colX != rightCol; colX += mColInc) {
34593:     nsTableColFrame* colFrame = mTableFirstInFlow->GetColFrame(colX);
34593:     if (!colFrame) ABORT1(PR_FALSE);
34593:     // conservatively estimate the half border widths outside the col
34593:     nscoord leftBorderHalf =
34593:        nsPresContext::CSSPixelsToAppUnits(colFrame->GetLeftBorderWidth() + 1);
34593:     nscoord rightBorderHalf =
34593:       nsPresContext::CSSPixelsToAppUnits(colFrame->GetRightBorderWidth() + 1);
34593:     // get the col rect relative to the table rather than the col group
34593:     nsSize size = colFrame->GetSize();
34593:     if (haveIntersect) {
34593:       if (aDirtyRect.XMost() >= (x - leftBorderHalf)) {
34593:         endColIndex = colX;
34593:       }
34593:       else break;
34593:     }
34593:     else {
34593:       if ((x + size.width + rightBorderHalf) >= aDirtyRect.x) {
34593:         startColIndex = endColIndex = colX;
34593:         haveIntersect = PR_TRUE;
34593:       }
34593:       else {
34593:         mInitialOffsetX += mColInc * size.width;
34593:       }
34593:     }
34593:     x += size.width;
34593:   }
34593:   if (!mTableIsLTR) {
34593:     PRUint32 temp;
34593:     mInitialOffsetX = mTable->GetRect().width - childAreaOffset.right;
34593:     temp = startColIndex; startColIndex = endColIndex; endColIndex = temp;
34593:     for (PRUint32 column = 0; column < startColIndex; column++) {
34593:       nsTableColFrame* colFrame = mTableFirstInFlow->GetColFrame(column);
34593:       if (!colFrame) ABORT1(PR_FALSE);
34593:       nsSize size = colFrame->GetSize();
34593:       mInitialOffsetX += mColInc * size.width;
34593:     }
34593:   }
34593:   if (!haveIntersect)
34593:     return PR_FALSE;
34593:   mDamageArea = nsRect(startColIndex, startRowIndex,
71173:                        1 + NS_ABS(PRInt32(endColIndex - startColIndex)),
34593:                        1 + endRowIndex - startRowIndex);
34593: 
34593:   Reset();
34593:   mVerInfo = new BCVerticalSeg[mDamageArea.width + 1];
34593:   if (!mVerInfo)
34593:     return PR_FALSE;
34593:   return PR_TRUE;
34591: }
34591: 
34591: void
34593: BCPaintBorderIterator::Reset()
34593: {
34593:   mAtEnd = PR_TRUE; // gets reset when First() is called
34593:   mRg = mStartRg;
34593:   mPrevRow  = nsnull;
34593:   mRow      = mStartRow;
34593:   mRowIndex      = 0;
34593:   mColIndex      = 0;
34593:   mRgIndex       = -1;
34593:   mPrevCell      = nsnull;
34593:   mCell          = nsnull;
34593:   mPrevCellData  = nsnull;
34593:   mCellData      = nsnull;
34593:   mBCData        = nsnull;
34593:   ResetVerInfo();
34593:  }
34593: 
34593: /**
34593:  * Set the iterator data to a new cellmap coordinate
34593:  * @param aRowIndex - the row index
34593:  * @param aColIndex - the col index
34593:  */
34591: void
34593: BCPaintBorderIterator::SetNewData(PRInt32 aY,
34591:                                 PRInt32 aX)
34591: {
34593:   if (!mTableCellMap || !mTableCellMap->mBCInfo) ABORT0();
34593: 
34593:   mColIndex    = aX;
34593:   mRowIndex    = aY;
34593:   mPrevCellData = mCellData;
34593:   if (IsTableRightMost() && IsTableBottomMost()) {
34593:    mCell = nsnull;
34593:    mBCData = &mTableCellMap->mBCInfo->mLowerRightCorner;
34593:   }
34593:   else if (IsTableRightMost()) {
34593:     mCellData = nsnull;
34593:     mBCData = &mTableCellMap->mBCInfo->mRightBorders.ElementAt(aY);
34593:   }
34593:   else if (IsTableBottomMost()) {
34593:     mCellData = nsnull;
34593:     mBCData = &mTableCellMap->mBCInfo->mBottomBorders.ElementAt(aX);
34591:   }
34591:   else {
34593:     if (PRUint32(mRowIndex - mFifRgFirstRowIndex) < mCellMap->mRows.Length()) {
34593:       mBCData = nsnull;
34593:       mCellData =
34593:         (BCCellData*)mCellMap->mRows[mRowIndex - mFifRgFirstRowIndex].SafeElementAt(mColIndex);
34593:       if (mCellData) {
34593:         mBCData = &mCellData->mData;
34593:         if (!mCellData->IsOrig()) {
34593:           if (mCellData->IsRowSpan()) {
34593:             aY -= mCellData->GetRowSpanOffset();
34593:           }
34593:           if (mCellData->IsColSpan()) {
34593:             aX -= mCellData->GetColSpanOffset();
34591:           }
34591:           if ((aX >= 0) && (aY >= 0)) {
34593:             mCellData = (BCCellData*)mCellMap->mRows[aY - mFifRgFirstRowIndex][aX];
34593:           }
34593:         }
34593:         if (mCellData->IsOrig()) {
34593:           mPrevCell = mCell;
34593:           mCell = mCellData->GetCellFrame();
34593:         }
34593:       }
34593:     }
34593:   }
34593: }
34593: 
34593: /**
34593:  * Set the iterator to a new row
34593:  * @param aRow - the new row frame, if null the iterator will advance to the
34593:  *               next row
34593:  */
34591: PRBool
34593: BCPaintBorderIterator::SetNewRow(nsTableRowFrame* aRow)
34593: {
34593:   mPrevRow = mRow;
34593:   mRow     = (aRow) ? aRow : mRow->GetNextRow();
34593:   if (mRow) {
34593:     mIsNewRow = PR_TRUE;
34593:     mRowIndex = mRow->GetRowIndex();
34593:     mColIndex = mDamageArea.x;
34593:     mPrevHorSegHeight = 0;
34593:     if (mIsRepeatedHeader) {
34593:       mRepeatedHeaderRowIndex = mRowIndex;
34593:     }
34591:   }
34591:   else {
34593:     mAtEnd = PR_TRUE;
34593:   }
34593:   return !mAtEnd;
34593: }
34593: 
34593: /**
34593:  * Advance the iterator to the next row group
34593:  */
34591: PRBool
34593: BCPaintBorderIterator::SetNewRowGroup()
34593: {
34593: 
34593:   mRgIndex++;
34593: 
34593:   mIsRepeatedHeader = PR_FALSE;
34593:   mIsRepeatedFooter = PR_FALSE;
34593: 
38996:   NS_ASSERTION(mRgIndex >= 0, "mRgIndex out of bounds");
38996:   if (PRUint32(mRgIndex) < mRowGroups.Length()) {
34593:     mPrevRg = mRg;
34593:     mRg = mRowGroups[mRgIndex];
34593:     mFifRgFirstRowIndex = ((nsTableRowGroupFrame*)mRg->GetFirstInFlow())->GetStartRowIndex();
34593:     mRgFirstRowIndex    = mRg->GetStartRowIndex();
34593:     mRgLastRowIndex     = mRgFirstRowIndex + mRg->GetRowCount() - 1;
34593: 
34593:     if (SetNewRow(mRg->GetFirstRow())) {
34593:       mCellMap =
34593:         mTableCellMap->GetMapFor((nsTableRowGroupFrame*)mRg->GetFirstInFlow(),
34591:                                   nsnull);
34593:       if (!mCellMap) ABORT1(PR_FALSE);
34593:     }
34593:     if (mRg && mTable->GetPrevInFlow() && !mRg->GetPrevInFlow()) {
34593:       // if mRowGroup doesn't have a prev in flow, then it may be a repeated
34593:       // header or footer
34593:       const nsStyleDisplay* display = mRg->GetStyleDisplay();
34593:       if (mRowIndex == mDamageArea.y) {
34593:         mIsRepeatedHeader = (NS_STYLE_DISPLAY_TABLE_HEADER_GROUP == display->mDisplay);
34591:       }
34591:       else {
34593:         mIsRepeatedFooter = (NS_STYLE_DISPLAY_TABLE_FOOTER_GROUP == display->mDisplay);
34591:       }
34591:     }
34591:   }
34591:   else {
34593:     mAtEnd = PR_TRUE;
34593:   }
34593:   return !mAtEnd;
34593: }
34593: 
34593: /**
34593:  *  Move the iterator to the first position in the damageArea
34593:  */
34591: void
34593: BCPaintBorderIterator::First()
34593: {
34593:   if (!mTable || (mDamageArea.x >= mNumTableCols) ||
34593:       (mDamageArea.y >= mNumTableRows)) ABORT0();
34593: 
34593:   mAtEnd = PR_FALSE;
34593: 
34593:   PRUint32 numRowGroups = mRowGroups.Length();
34593:   for (PRUint32 rgY = 0; rgY < numRowGroups; rgY++) {
34593:     nsTableRowGroupFrame* rowG = mRowGroups[rgY];
34591:     PRInt32 start = rowG->GetStartRowIndex();
34591:     PRInt32 end   = start + rowG->GetRowCount() - 1;
34593:     if ((mDamageArea.y >= start) && (mDamageArea.y <= end)) {
34593:       mRgIndex = rgY - 1; // SetNewRowGroup increments rowGroupIndex
34591:       if (SetNewRowGroup()) {
34593:         while ((mRowIndex < mDamageArea.y) && !mAtEnd) {
34591:           SetNewRow();
34591:         }
34593:         if (!mAtEnd) {
34593:           SetNewData(mDamageArea.y, mDamageArea.x);
34591:         }
34591:       }
34591:       return;
34591:     }
34591:   }
34593:   mAtEnd = PR_TRUE;
34593: }
34593: 
34593: /**
34593:  * Advance the iterator to the next position
34593:  */
34591: void
34593: BCPaintBorderIterator::Next()
34593: {
34593:   if (mAtEnd) ABORT0();
34593:   mIsNewRow = PR_FALSE;
34593: 
34593:   mColIndex++;
34593:   if (mColIndex > mDamageArea.XMost()) {
34593:     mRowIndex++;
34593:     if (mRowIndex == mDamageArea.YMost()) {
34593:       mColIndex = mDamageArea.x;
34593:     }
34593:     else if (mRowIndex < mDamageArea.YMost()) {
34593:       if (mRowIndex <= mRgLastRowIndex) {
34591:         SetNewRow();
34591:       }
34591:       else {
34591:         SetNewRowGroup();
34591:       }
34591:     }
34591:     else {
34593:       mAtEnd = PR_TRUE;
34593:     }
34593:   }
34593:   if (!mAtEnd) {
34593:     SetNewData(mRowIndex, mColIndex);
34593:   }
34593: }
34593: 
34593: // XXX if CalcVerCornerOffset and CalcHorCornerOffset remain similar, combine
34593: // them
34593: /** Compute the vertical offset of a vertical border segment
34593:   * @param aCornerOwnerSide - which side owns the corner
34593:   * @param aCornerSubWidth  - how wide is the nonwinning side of the corner
34593:   * @param aHorWidth        - how wide is the horizontal edge of the corner
34593:   * @param aIsStartOfSeg    - does this corner start a new segment
34593:   * @param aIsBevel         - is this corner beveled
34593:   * @return                 - offset in twips
34593:   */
34591: static nscoord
41419: CalcVerCornerOffset(mozilla::css::Side aCornerOwnerSide,
34593:                     BCPixelSize aCornerSubWidth,
34593:                     BCPixelSize aHorWidth,
34591:                     PRBool      aIsStartOfSeg,
34591:                     PRBool      aIsBevel)
34591: {
34591:   nscoord offset = 0;
34593:   // XXX These should be replaced with appropriate side-specific macros (which?)
34593:   BCPixelSize smallHalf, largeHalf;
34593:   if ((NS_SIDE_TOP == aCornerOwnerSide) ||
34593:       (NS_SIDE_BOTTOM == aCornerOwnerSide)) {
34591:     DivideBCBorderSize(aCornerSubWidth, smallHalf, largeHalf);
34591:     if (aIsBevel) {
34591:       offset = (aIsStartOfSeg) ? -largeHalf : smallHalf;
34591:     }
34591:     else {
34591:       offset = (NS_SIDE_TOP == aCornerOwnerSide) ? smallHalf : -largeHalf;
34591:     }
34591:   }
34591:   else {
34591:     DivideBCBorderSize(aHorWidth, smallHalf, largeHalf);
34591:     if (aIsBevel) {
34591:       offset = (aIsStartOfSeg) ? -largeHalf : smallHalf;
34591:     }
34591:     else {
34591:       offset = (aIsStartOfSeg) ? smallHalf : -largeHalf;
34591:     }
34591:   }
34591:   return nsPresContext::CSSPixelsToAppUnits(offset);
34591: }
34591: 
34591: /** Compute the horizontal offset of a horizontal border segment
34591:   * @param aCornerOwnerSide - which side owns the corner
34591:   * @param aCornerSubWidth  - how wide is the nonwinning side of the corner
34591:   * @param aVerWidth        - how wide is the vertical edge of the corner
34591:   * @param aIsStartOfSeg    - does this corner start a new segment
34591:   * @param aIsBevel         - is this corner beveled
34591:   * @param aTableIsLTR      - direction, the computation depends on ltr or rtl
34593:   * @return                 - offset in twips
34587:   */
34591: static nscoord
41419: CalcHorCornerOffset(mozilla::css::Side aCornerOwnerSide,
34593:                     BCPixelSize aCornerSubWidth,
34593:                     BCPixelSize aVerWidth,
34591:                     PRBool      aIsStartOfSeg,
34591:                     PRBool      aIsBevel,
34591:                     PRBool      aTableIsLTR)
34591: {
34591:   nscoord offset = 0;
34593:   // XXX These should be replaced with appropriate side-specific macros (which?)
34593:   BCPixelSize smallHalf, largeHalf;
34593:   if ((NS_SIDE_LEFT == aCornerOwnerSide) ||
34593:       (NS_SIDE_RIGHT == aCornerOwnerSide)) {
34591:     if (aTableIsLTR) {
34591:       DivideBCBorderSize(aCornerSubWidth, smallHalf, largeHalf);
34591:     }
34591:     else {
34591:       DivideBCBorderSize(aCornerSubWidth, largeHalf, smallHalf);
34591:     }
34591:     if (aIsBevel) {
34591:       offset = (aIsStartOfSeg) ? -largeHalf : smallHalf;
34591:     }
34591:     else {
34591:       offset = (NS_SIDE_LEFT == aCornerOwnerSide) ? smallHalf : -largeHalf;
34591:     }
34591:   }
34591:   else {
34591:     if (aTableIsLTR) {
34591:       DivideBCBorderSize(aVerWidth, smallHalf, largeHalf);
34591:     }
34591:     else {
34591:       DivideBCBorderSize(aVerWidth, largeHalf, smallHalf);
34591:     }
34591:     if (aIsBevel) {
34591:       offset = (aIsStartOfSeg) ? -largeHalf : smallHalf;
34591:     }
34591:     else {
34591:       offset = (aIsStartOfSeg) ? smallHalf : -largeHalf;
34591:     }
34591:   }
34591:   return nsPresContext::CSSPixelsToAppUnits(offset);
34591: }
34591: 
34593: BCVerticalSeg::BCVerticalSeg()
34593: {
34593:   mCol = nsnull;
34593:   mFirstCell = mLastCell = mAjaCell = nsnull;
41419:   mOffsetX = mOffsetY = mLength = mWidth = mTopBevelOffset = 0;
41419:   mTopBevelSide = NS_SIDE_TOP;
34593:   mOwner = eCellOwner;
34593: }
34593: 
34593: /**
34593:  * Start a new vertical segment
34593:  * @param aIter         - iterator containing the structural information
34593:  * @param aBorderOwner  - determines the border style
34593:  * @param aVerSegWidth  - the width of segment in pixel
34593:  * @param aHorSegHeight - the width of the horizontal segment joining the corner
34593:  *                        at the start
34593:  */
34593: void
34593: BCVerticalSeg::Start(BCPaintBorderIterator& aIter,
34591:                      BCBorderOwner          aBorderOwner,
34593:                      BCPixelSize            aVerSegWidth,
34593:                      BCPixelSize            aHorSegHeight)
34591: {
41419:   mozilla::css::Side ownerSide   = NS_SIDE_TOP;
34591:   PRPackedBool bevel       = PR_FALSE;
34593: 
34593: 
34593:   nscoord cornerSubWidth  = (aIter.mBCData) ?
34593:                                aIter.mBCData->GetCorner(ownerSide, bevel) : 0;
34593: 
34591:   PRBool  topBevel        = (aVerSegWidth > 0) ? bevel : PR_FALSE;
71173:   BCPixelSize maxHorSegHeight = NS_MAX(aIter.mPrevHorSegHeight, aHorSegHeight);
34593:   nscoord offset          = CalcVerCornerOffset(ownerSide, cornerSubWidth,
34593:                                                 maxHorSegHeight, PR_TRUE,
34593:                                                 topBevel);
34593: 
34593:   mTopBevelOffset   = (topBevel) ?
34593:                       nsPresContext::CSSPixelsToAppUnits(maxHorSegHeight): 0;
34593:   // XXX this assumes that only corners where 2 segments join can be beveled
34593:   mTopBevelSide     = (aHorSegHeight > 0) ? NS_SIDE_RIGHT : NS_SIDE_LEFT;
34593:   mOffsetY      += offset;
34593:   mLength        = -offset;
34593:   mWidth         = aVerSegWidth;
34593:   mOwner         = aBorderOwner;
34593:   mFirstCell     = aIter.mCell;
34593:   mFirstRowGroup = aIter.mRg;
34593:   mFirstRow      = aIter.mRow;
34593:   if (aIter.GetRelativeColIndex() > 0) {
34593:     mAjaCell = aIter.mVerInfo[aIter.GetRelativeColIndex() - 1].mLastCell;
34593:   }
34593: }
34593: 
34593: /**
34593:  * Initialize the vertical segments with information that will persist for any
34593:  * vertical segment in this column
34593:  * @param aIter - iterator containing the structural information
34591:  */
34591: void
34593: BCVerticalSeg::Initialize(BCPaintBorderIterator& aIter)
34593: {
34593:   PRInt32 relColIndex = aIter.GetRelativeColIndex();
34593:   mCol = aIter.IsTableRightMost() ? aIter.mVerInfo[relColIndex - 1].mCol :
34593:            aIter.mTableFirstInFlow->GetColFrame(aIter.mColIndex);
34593:   if (!mCol) ABORT0();
34593:   if (0 == relColIndex) {
34593:     mOffsetX = aIter.mInitialOffsetX;
34593:   }
34593:   // set colX for the next column
34593:   if (!aIter.IsDamageAreaRightMost()) {
34593:     aIter.mVerInfo[relColIndex + 1].mOffsetX = mOffsetX +
34593:                                          aIter.mColInc * mCol->GetSize().width;
34593:   }
34593:   mOffsetY = aIter.mInitialOffsetY;
34593:   mLastCell = aIter.mCell;
34593: }
34593: 
34593: /**
34593:  * Compute the offsets for the bottom corner of a vertical segment
34593:  * @param aIter         - iterator containing the structural information
34593:  * @param aHorSegHeight - the width of the horizontal segment joining the corner
34593:  *                        at the start
34593:  */
34591: void
34593: BCVerticalSeg::GetBottomCorner(BCPaintBorderIterator& aIter,
34593:                                BCPixelSize            aHorSegHeight)
34593: {
41419:    mozilla::css::Side ownerSide = NS_SIDE_TOP;
34593:    nscoord cornerSubWidth = 0;
34593:    PRPackedBool bevel = PR_FALSE;
34593:    if (aIter.mBCData) {
34593:      cornerSubWidth = aIter.mBCData->GetCorner(ownerSide, bevel);
34593:    }
34593:    mIsBottomBevel = (mWidth > 0) ? bevel : PR_FALSE;
71173:    mBottomHorSegHeight = NS_MAX(aIter.mPrevHorSegHeight, aHorSegHeight);
34593:    mBottomOffset = CalcVerCornerOffset(ownerSide, cornerSubWidth,
34593:                                     mBottomHorSegHeight,
34593:                                     PR_FALSE, mIsBottomBevel);
34593:    mLength += mBottomOffset;
34593: }
34593: 
34593: /**
34593:  * Paint the vertical segment
34593:  * @param aIter         - iterator containing the structural information
34593:  * @param aRenderingContext - the rendering context
34593:  * @param aHorSegHeight - the width of the horizontal segment joining the corner
34593:  *                        at the start
34593:  */
34593: void
34593: BCVerticalSeg::Paint(BCPaintBorderIterator& aIter,
68481:                      nsRenderingContext&   aRenderingContext,
34593:                      BCPixelSize            aHorSegHeight)
34593: {
    1:   // get the border style, color and paint the segment
41419:   mozilla::css::Side side = (aIter.IsDamageAreaRightMost()) ? NS_SIDE_RIGHT :
34593:                                                     NS_SIDE_LEFT;
34593:   PRInt32 relColIndex = aIter.GetRelativeColIndex();
34593:   nsTableColFrame* col           = mCol; if (!col) ABORT0();
34593:   nsTableCellFrame* cell         = mFirstCell; // ???
36972:   nsIFrame* owner = nsnull;
    1:   PRUint8 style = NS_STYLE_BORDER_STYLE_SOLID;
    1:   nscolor color = 0xFFFFFFFF;
34593: 
34593:   switch (mOwner) {
    1:     case eTableOwner:
36972:       owner = aIter.mTable;
    1:       break;
    1:     case eAjaColGroupOwner:
    1:       side = NS_SIDE_RIGHT;
34593:       if (!aIter.IsTableRightMost() && (relColIndex > 0)) {
34593:         col = aIter.mVerInfo[relColIndex - 1].mCol;
    1:       } // and fall through
    1:     case eColGroupOwner:
    1:       if (col) {
36972:         owner = col->GetParent();
    1:       }
    1:       break;
    1:     case eAjaColOwner:
    1:       side = NS_SIDE_RIGHT;
34593:       if (!aIter.IsTableRightMost() && (relColIndex > 0)) {
34593:         col = aIter.mVerInfo[relColIndex - 1].mCol;
    1:       } // and fall through
    1:     case eColOwner:
36972:       owner = col;
    1:       break;
    1:     case eAjaRowGroupOwner:
34593:       NS_ERROR("a neighboring rowgroup can never own a vertical border");
34593:       // and fall through
    1:     case eRowGroupOwner:
34593:       NS_ASSERTION(aIter.IsTableLeftMost() || aIter.IsTableRightMost(),
34593:                   "row group can own border only at table edge");
36972:       owner = mFirstRowGroup;
    1:       break;
    1:     case eAjaRowOwner:
    1:       NS_ASSERTION(PR_FALSE, "program error"); // and fall through
    1:     case eRowOwner:
34593:       NS_ASSERTION(aIter.IsTableLeftMost() || aIter.IsTableRightMost(),
34593:                    "row can own border only at table edge");
36972:       owner = mFirstRow;
    1:       break;
    1:     case eAjaCellOwner:
    1:       side = NS_SIDE_RIGHT;
34593:       cell = mAjaCell; // and fall through
    1:     case eCellOwner:
36972:       owner = cell;
    1:       break;
    1:   }
36972:   if (owner) {
36972:     ::GetPaintStyleInfo(owner, side, style, color, aIter.mTableIsLTR);
36972:   }
34593:   BCPixelSize smallHalf, largeHalf;
34593:   DivideBCBorderSize(mWidth, smallHalf, largeHalf);
34593:   nsRect segRect(mOffsetX - nsPresContext::CSSPixelsToAppUnits(largeHalf),
34593:                  mOffsetY,
34593:                  nsPresContext::CSSPixelsToAppUnits(mWidth), mLength);
34593:   nscoord bottomBevelOffset = (mIsBottomBevel) ?
34593:                   nsPresContext::CSSPixelsToAppUnits(mBottomHorSegHeight) : 0;
41419:   mozilla::css::Side bottomBevelSide = ((aHorSegHeight > 0) ^ !aIter.mTableIsLTR) ?
34593:                             NS_SIDE_RIGHT : NS_SIDE_LEFT;
41419:   mozilla::css::Side topBevelSide = ((mTopBevelSide == NS_SIDE_RIGHT) ^ !aIter.mTableIsLTR)?
34593:                          NS_SIDE_RIGHT : NS_SIDE_LEFT;
34593:   nsCSSRendering::DrawTableBorderSegment(aRenderingContext, style, color,
34593:                                          aIter.mTableBgColor, segRect,
34593:                                          nsPresContext::AppUnitsPerCSSPixel(),
34593:                                          topBevelSide, mTopBevelOffset,
    1:                                          bottomBevelSide, bottomBevelOffset);
34593: }
34593: 
34593: /**
34593:  * Advance the start point of a segment
34593:  */
34593: void
34593: BCVerticalSeg::AdvanceOffsetY()
34593: {
34593:   mOffsetY +=  mLength - mBottomOffset;
34593: }
34593: 
34593: /**
34593:  * Accumulate the current segment
34593:  */
34593: void
34593: BCVerticalSeg::IncludeCurrentBorder(BCPaintBorderIterator& aIter)
34593: {
34593:   mLastCell = aIter.mCell;
34593:   mLength  += aIter.mRow->GetRect().height;
34593: }
34593: 
34593: BCHorizontalSeg::BCHorizontalSeg()
34593: {
34593:   mOffsetX = mOffsetY = mLength = mWidth =  mLeftBevelOffset = 0;
41419:   mLeftBevelSide = NS_SIDE_TOP;
34593:   mFirstCell = mAjaCell = nsnull;
34593: }
34593: 
34593: /** Initialize a horizontal border segment for painting
34593:   * @param aIter              - iterator storing the current and adjacent frames
34593:   * @param aBorderOwner       - which frame owns the border
34593:   * @param aBottomVerSegWidth - vertical segment width coming from up
34593:   * @param aHorSegHeight      - the height of the segment
34593:   +  */
34593: void
34593: BCHorizontalSeg::Start(BCPaintBorderIterator& aIter,
34593:                        BCBorderOwner        aBorderOwner,
34593:                        BCPixelSize          aBottomVerSegWidth,
34593:                        BCPixelSize          aHorSegHeight)
34593: {
41419:   mozilla::css::Side cornerOwnerSide = NS_SIDE_TOP;
34593:   PRPackedBool bevel     = PR_FALSE;
34593: 
34593:   mOwner = aBorderOwner;
34593:   nscoord cornerSubWidth  = (aIter.mBCData) ?
34593:                              aIter.mBCData->GetCorner(cornerOwnerSide,
34593:                                                        bevel) : 0;
34593: 
34593:   PRBool  leftBevel = (aHorSegHeight > 0) ? bevel : PR_FALSE;
34593:   PRInt32 relColIndex = aIter.GetRelativeColIndex();
71173:   nscoord maxVerSegWidth = NS_MAX(aIter.mVerInfo[relColIndex].mWidth,
34593:                                   aBottomVerSegWidth);
34593:   nscoord offset = CalcHorCornerOffset(cornerOwnerSide, cornerSubWidth,
34593:                                        maxVerSegWidth, PR_TRUE, leftBevel,
34593:                                        aIter.mTableIsLTR);
34593:   mLeftBevelOffset = (leftBevel && (aHorSegHeight > 0)) ? maxVerSegWidth : 0;
34593:   // XXX this assumes that only corners where 2 segments join can be beveled
34593:   mLeftBevelSide   = (aBottomVerSegWidth > 0) ? NS_SIDE_BOTTOM : NS_SIDE_TOP;
34593:   if (aIter.mTableIsLTR) {
34593:     mOffsetX += offset;
    1:   }
    1:   else {
34593:     mOffsetX -= offset;
34593:   }
34593:   mLength          = -offset;
34593:   mWidth           = aHorSegHeight;
34593:   mFirstCell       = aIter.mCell;
34593:   mAjaCell         = (aIter.IsDamageAreaTopMost()) ? nsnull :
34593:                      aIter.mVerInfo[relColIndex].mLastCell;
34593: }
34593: 
34593: /**
34593:  * Compute the offsets for the right corner of a horizontal segment
34593:  * @param aIter         - iterator containing the structural information
34593:  * @param aLeftSegWidth - the width of the vertical segment joining the corner
34593:  *                        at the start
34593:  */
34593: void
34593: BCHorizontalSeg::GetRightCorner(BCPaintBorderIterator& aIter,
34593:                                 BCPixelSize            aLeftSegWidth)
34593: {
41419:   mozilla::css::Side ownerSide = NS_SIDE_TOP;
34593:   nscoord cornerSubWidth = 0;
34593:   PRPackedBool bevel = PR_FALSE;
34593:   if (aIter.mBCData) {
34593:     cornerSubWidth = aIter.mBCData->GetCorner(ownerSide, bevel);
34593:   }
34593: 
34593:   mIsRightBevel = (mWidth > 0) ? bevel : 0;
34593:   PRInt32 relColIndex = aIter.GetRelativeColIndex();
71173:   nscoord verWidth = NS_MAX(aIter.mVerInfo[relColIndex].mWidth, aLeftSegWidth);
34593:   mEndOffset = CalcHorCornerOffset(ownerSide, cornerSubWidth, verWidth,
34593:                                    PR_FALSE, mIsRightBevel, aIter.mTableIsLTR);
34593:   mLength += mEndOffset;
34593:   mRightBevelOffset = (mIsRightBevel) ?
34593:                        nsPresContext::CSSPixelsToAppUnits(verWidth) : 0;
34593:   mRightBevelSide = (aLeftSegWidth > 0) ? NS_SIDE_BOTTOM : NS_SIDE_TOP;
34593: }
34593: 
34593: /**
34593:  * Paint the horizontal segment
34593:  * @param aIter         - iterator containing the structural information
34593:  * @param aRenderingContext - the rendering context
34593:  */
34593: void
34593: BCHorizontalSeg::Paint(BCPaintBorderIterator& aIter,
68481:                        nsRenderingContext&   aRenderingContext)
34593: {
    1:   // get the border style, color and paint the segment
41419:   mozilla::css::Side side = (aIter.IsDamageAreaBottomMost()) ? NS_SIDE_BOTTOM :
34593:                                                      NS_SIDE_TOP;
34593:   nsIFrame* rg   = aIter.mRg;  if (!rg) ABORT0();
34593:   nsIFrame* row  = aIter.mRow; if (!row) ABORT0();
39021:   nsIFrame* cell = mFirstCell;
    1:   nsIFrame* col;
36972:   nsIFrame* owner = nsnull;
    1: 
    1:   PRUint8 style = NS_STYLE_BORDER_STYLE_SOLID;
    1:   nscolor color = 0xFFFFFFFF;
36972: 
34593: 
34593:   switch (mOwner) {
    1:     case eTableOwner:
36972:       owner = aIter.mTable;
    1:       break;
    1:     case eAjaColGroupOwner:
34593:       NS_ERROR("neighboring colgroups can never own a horizontal border");
34593:       // and fall through
36972:     case eColGroupOwner:
34593:       NS_ASSERTION(aIter.IsTableTopMost() || aIter.IsTableBottomMost(),
34593:                    "col group can own border only at the table edge");
34593:       col = aIter.mTableFirstInFlow->GetColFrame(aIter.mColIndex - 1);
34593:       if (!col) ABORT0();
36972:       owner = col->GetParent();
    1:       break;
    1:     case eAjaColOwner:
34593:       NS_ERROR("neighboring column can never own a horizontal border");
34593:       // and fall through
    1:     case eColOwner:
34593:       NS_ASSERTION(aIter.IsTableTopMost() || aIter.IsTableBottomMost(),
34593:                    "col can own border only at the table edge");
36972:       owner = aIter.mTableFirstInFlow->GetColFrame(aIter.mColIndex - 1);
    1:       break;
    1:     case eAjaRowGroupOwner:
    1:       side = NS_SIDE_BOTTOM;
34593:       rg = (aIter.IsTableBottomMost()) ? aIter.mRg : aIter.mPrevRg;
34593:       // and fall through
    1:     case eRowGroupOwner:
36972:       owner = rg;
    1:       break;
    1:     case eAjaRowOwner:
    1:       side = NS_SIDE_BOTTOM;
34593:       row = (aIter.IsTableBottomMost()) ? aIter.mRow : aIter.mPrevRow;
34593:       // and fall through
    1:       case eRowOwner:
36972:       owner = row;
    1:       break;
    1:     case eAjaCellOwner:
    1:       side = NS_SIDE_BOTTOM;
34593:       // if this is null due to the damage area origin-y > 0, then the border
34593:       // won't show up anyway
34593:       cell = mAjaCell;
    1:       // and fall through
    1:     case eCellOwner:
36972:       owner = cell;
    1:       break;
    1:   }
36972:   if (owner) {
36972:     ::GetPaintStyleInfo(owner, side, style, color, aIter.mTableIsLTR);
36972:   }
34593:   BCPixelSize smallHalf, largeHalf;
34593:   DivideBCBorderSize(mWidth, smallHalf, largeHalf);
34593:   nsRect segRect(mOffsetX,
34593:                  mOffsetY - nsPresContext::CSSPixelsToAppUnits(largeHalf),
34593:                  mLength,
34593:                  nsPresContext::CSSPixelsToAppUnits(mWidth));
34593:   if (aIter.mTableIsLTR) {
34593:     nsCSSRendering::DrawTableBorderSegment(aRenderingContext, style, color,
34593:                                            aIter.mTableBgColor, segRect,
34593:                                            nsPresContext::AppUnitsPerCSSPixel(),
34593:                                            mLeftBevelSide,
34593:                                            nsPresContext::CSSPixelsToAppUnits(mLeftBevelOffset),
34593:                                            mRightBevelSide, mRightBevelOffset);
34593:   }
34593:   else {
34591:     segRect.x -= segRect.width;
34593:     nsCSSRendering::DrawTableBorderSegment(aRenderingContext, style, color,
34593:                                            aIter.mTableBgColor, segRect,
34593:                                            nsPresContext::AppUnitsPerCSSPixel(),
34593:                                            mRightBevelSide, mRightBevelOffset,
34593:                                            mLeftBevelSide,
34593:                                            nsPresContext::CSSPixelsToAppUnits(mLeftBevelOffset));
34593:   }
34593: }
34593: 
34593: /**
34593:  * Advance the start point of a segment
34593:  */
34593: void
34593: BCHorizontalSeg::AdvanceOffsetX(PRInt32 aIncrement)
34593: {
34593:   mOffsetX += aIncrement * (mLength - mEndOffset);
34593: }
34593: 
34593: /**
34593:  * Accumulate the current segment
34593:  */
34593: void
34593: BCHorizontalSeg::IncludeCurrentBorder(BCPaintBorderIterator& aIter)
34593: {
34593:   mLength += aIter.mVerInfo[aIter.GetRelativeColIndex()].mColWidth;
34593: }
34593: 
34593: /**
34593:  * store the column width information while painting horizontal segment
34593:  */
34593: void
34593: BCPaintBorderIterator::StoreColumnWidth(PRInt32 aIndex)
34593: {
34593:   if (IsTableRightMost()) {
34593:       mVerInfo[aIndex].mColWidth = mVerInfo[aIndex - 1].mColWidth;
34587:   }
34587:   else {
34593:     nsTableColFrame* col = mTableFirstInFlow->GetColFrame(mColIndex);
34593:     if (!col) ABORT0();
34593:     mVerInfo[aIndex].mColWidth = col->GetSize().width;
34593:   }
34593: }
34593: /**
34593:  * Determine if a vertical segment owns the corder
34593:  */
34593: PRBool
34593: BCPaintBorderIterator::VerticalSegmentOwnsCorner()
34593: {
41419:   mozilla::css::Side cornerOwnerSide = NS_SIDE_TOP;
34593:   PRPackedBool bevel = PR_FALSE;
34593:   nscoord cornerSubWidth;
34593:   cornerSubWidth = (mBCData) ? mBCData->GetCorner(cornerOwnerSide, bevel) : 0;
34593:   // unitialized ownerside, bevel
34593:   return  (NS_SIDE_TOP == cornerOwnerSide) ||
34593:           (NS_SIDE_BOTTOM == cornerOwnerSide);
34593: }
34593: 
34593: /**
34593:  * Paint if necessary a horizontal segment, otherwise accumulate it
34593:  * @param aRenderingContext - the rendering context
34593:  */
34593: void
68481: BCPaintBorderIterator::AccumulateOrPaintHorizontalSegment(nsRenderingContext& aRenderingContext)
34593: {
34593: 
34593:   PRInt32 relColIndex = GetRelativeColIndex();
34593:   // store the current col width if it hasn't been already
34593:   if (mVerInfo[relColIndex].mColWidth < 0) {
34593:     StoreColumnWidth(relColIndex);
34593:   }
34593: 
34593:   BCBorderOwner borderOwner = eCellOwner;
34593:   BCBorderOwner ignoreBorderOwner;
34593:   PRBool isSegStart = PR_TRUE;
34593:   PRBool ignoreSegStart;
34593: 
34593:   nscoord leftSegWidth = (mBCData) ? mBCData->GetLeftEdge(ignoreBorderOwner,
34593:                                                           ignoreSegStart) : 0;
34593:   nscoord topSegHeight = (mBCData) ? mBCData->GetTopEdge(borderOwner,
34593:                                                          isSegStart) : 0;
34593: 
34593:   if (mIsNewRow || (IsDamageAreaLeftMost() && IsDamageAreaBottomMost())) {
34593:     // reset for every new row and on the bottom of the last row
34593:     mHorSeg.mOffsetY = mNextOffsetY;
34593:     mNextOffsetY     = mNextOffsetY + mRow->GetSize().height;
34593:     mHorSeg.mOffsetX = mInitialOffsetX;
34593:     mHorSeg.Start(*this, borderOwner, leftSegWidth, topSegHeight);
34593:   }
34593: 
34593:   if (!IsDamageAreaLeftMost() && (isSegStart || IsDamageAreaRightMost() ||
34593:                                   VerticalSegmentOwnsCorner())) {
34593:     // paint the previous seg or the current one if IsDamageAreaRightMost()
34593:     if (mHorSeg.mLength > 0) {
34593:       mHorSeg.GetRightCorner(*this, leftSegWidth);
34593:       if (mHorSeg.mWidth > 0) {
34593:         mHorSeg.Paint(*this, aRenderingContext);
34593:       }
34593:       mHorSeg.AdvanceOffsetX(mColInc);
34593:     }
34593:     mHorSeg.Start(*this, borderOwner, leftSegWidth, topSegHeight);
34593:   }
34593:   mHorSeg.IncludeCurrentBorder(*this);
34593:   mVerInfo[relColIndex].mWidth = leftSegWidth;
34593:   mVerInfo[relColIndex].mLastCell = mCell;
34593: }
34593: /**
34593:  * Paint if necessary a vertical segment, otherwise  it
34593:  * @param aRenderingContext - the rendering context
34593:  */
34593: void
68481: BCPaintBorderIterator::AccumulateOrPaintVerticalSegment(nsRenderingContext& aRenderingContext)
34593: {
34593:   BCBorderOwner borderOwner = eCellOwner;
34593:   BCBorderOwner ignoreBorderOwner;
34593:   PRBool isSegStart = PR_TRUE;
34593:   PRBool ignoreSegStart;
34593: 
34593:   nscoord verSegWidth  = (mBCData) ? mBCData->GetLeftEdge(borderOwner,
34593:                                                           isSegStart) : 0;
34593:   nscoord horSegHeight = (mBCData) ? mBCData->GetTopEdge(ignoreBorderOwner,
34593:                                                          ignoreSegStart) : 0;
34593: 
34593:   PRInt32 relColIndex = GetRelativeColIndex();
34593:   BCVerticalSeg& verSeg = mVerInfo[relColIndex];
34593:   if (!verSeg.mCol) { // on the first damaged row and the first segment in the
34593:                       // col
34593:     verSeg.Initialize(*this);
34593:     verSeg.Start(*this, borderOwner, verSegWidth, horSegHeight);
34593:   }
34593: 
34593:   if (!IsDamageAreaTopMost() && (isSegStart || IsDamageAreaBottomMost() ||
34593:                                  IsAfterRepeatedHeader() ||
34593:                                  StartRepeatedFooter())) {
34593:     // paint the previous seg or the current one if IsDamageAreaBottomMost()
34593:     if (verSeg.mLength > 0) {
34593:       verSeg.GetBottomCorner(*this, horSegHeight);
34593:       if (verSeg.mWidth > 0) {
34593:         verSeg.Paint(*this, aRenderingContext, horSegHeight);
34593:       }
34593:       verSeg.AdvanceOffsetY();
34593:     }
34593:     verSeg.Start(*this, borderOwner, verSegWidth, horSegHeight);
34593:   }
34593:   verSeg.IncludeCurrentBorder(*this);
34593:   mPrevHorSegHeight = horSegHeight;
34593: }
34593: 
34593: /**
34593:  * Reset the vertical information cache
34593:  */
34593: void
34593: BCPaintBorderIterator::ResetVerInfo()
34593: {
34593:   if (mVerInfo) {
34593:     memset(mVerInfo, 0, mDamageArea.width * sizeof(BCVerticalSeg));
34593:     // XXX reinitialize properly
34593:     for (PRInt32 xIndex = 0; xIndex < mDamageArea.width; xIndex++) {
34593:       mVerInfo[xIndex].mColWidth = -1;
34593:     }
34593:   }
34593: }
34593: 
34593: /**
34593:  * Method to paint BCBorders, this does not use currently display lists although
34593:  * it will do this in future
34593:  * @param aRenderingContext - the rendering context
34593:  * @param aDirtyRect        - inside this rectangle the BC Borders will redrawn
34593:  */
34593: void
68481: nsTableFrame::PaintBCBorders(nsRenderingContext& aRenderingContext,
34593:                              const nsRect&        aDirtyRect)
34593: {
34593:   // We first transfer the aDirtyRect into cellmap coordinates to compute which
34593:   // cell borders need to be painted
34593:   BCPaintBorderIterator iter(this);
34593:   if (!iter.SetDamageArea(aDirtyRect))
34593:     return;
34593: 
34593:   // First, paint all of the vertical borders from top to bottom and left to
34593:   // right as they become complete. They are painted first, since they are less
34593:   // efficient to paint than horizontal segments. They were stored with as few
34593:   // segments as possible (since horizontal borders are painted last and
34593:   // possibly over them). For every cell in a row that fails in the damage are
34593:   // we look up if the current border would start a new segment, if so we paint
34593:   // the previously stored vertical segment and start a new segment. After
34593:   // this we  the now active segment with the current border. These
34593:   // segments are stored in mVerInfo to be used on the next row
34593:   for (iter.First(); !iter.mAtEnd; iter.Next()) {
34593:     iter.AccumulateOrPaintVerticalSegment(aRenderingContext);
34593:   }
34593: 
34593:   // Next, paint all of the horizontal border segments from top to bottom reuse
34593:   // the mVerInfo array to keep track of col widths and vertical segments for
34593:   // corner calculations
34593:   iter.Reset();
34593:   for (iter.First(); !iter.mAtEnd; iter.Next()) {
34593:     iter.AccumulateOrPaintHorizontalSegment(aRenderingContext);
34593:   }
    1: }
    1: 
    1: PRBool nsTableFrame::RowHasSpanningCells(PRInt32 aRowIndex, PRInt32 aNumEffCols)
    1: {
    1:   PRBool result = PR_FALSE;
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   NS_PRECONDITION (cellMap, "bad call, cellMap not yet allocated.");
    1:   if (cellMap) {
    1:     result = cellMap->RowHasSpanningCells(aRowIndex, aNumEffCols);
    1:   }
    1:   return result;
    1: }
    1: 
    1: PRBool nsTableFrame::RowIsSpannedInto(PRInt32 aRowIndex, PRInt32 aNumEffCols)
    1: {
    1:   PRBool result = PR_FALSE;
    1:   nsTableCellMap* cellMap = GetCellMap();
    1:   NS_PRECONDITION (cellMap, "bad call, cellMap not yet allocated.");
    1:   if (cellMap) {
    1:     result = cellMap->RowIsSpannedInto(aRowIndex, aNumEffCols);
    1:   }
    1:   return result;
    1: }
    1: 
11384: /* static */
11384: void
13144: nsTableFrame::InvalidateFrame(nsIFrame* aFrame,
13144:                               const nsRect& aOrigRect,
55037:                               const nsRect& aOrigVisualOverflow,
11384:                               PRBool aIsFirstReflow)
11384: {
11384:   nsIFrame* parent = aFrame->GetParent();
11384:   NS_ASSERTION(parent, "What happened here?");
11384: 
11384:   if (parent->GetStateBits() & NS_FRAME_FIRST_REFLOW) {
11384:     // Don't bother; we'll invalidate the parent's overflow rect when
11384:     // we finish reflowing it.
11384:     return;
11384:   }
11384: 
13144:   // The part that looks at both the rect and the overflow rect is a
13144:   // bit of a hack.  See nsBlockFrame::ReflowLine for an eloquent
13157:   // description of its hackishness.
55037:   nsRect visualOverflow = aFrame->GetVisualOverflowRect();
13144:   if (aIsFirstReflow ||
13144:       aOrigRect.TopLeft() != aFrame->GetPosition() ||
55037:       aOrigVisualOverflow.TopLeft() != visualOverflow.TopLeft()) {
13811:     // Invalidate the old and new overflow rects.  Note that if the
55037:     // frame moved, we can't just use aOrigVisualOverflow, since it's in
13811:     // coordinates relative to the old position.  So invalidate via
13811:     // aFrame's parent, and reposition that overflow rect to the right
13811:     // place.
17140:     // XXXbz this doesn't handle outlines, does it?
55037:     aFrame->Invalidate(visualOverflow);
55037:     parent->Invalidate(aOrigVisualOverflow + aOrigRect.TopLeft());
11384:   } else {
17140:     nsRect rect = aFrame->GetRect();
55037:     aFrame->CheckInvalidateSizeChange(aOrigRect, aOrigVisualOverflow,
20711:                                       rect.Size());
55037:     aFrame->InvalidateRectDifference(aOrigVisualOverflow, visualOverflow);
17140:     parent->InvalidateRectDifference(aOrigRect, rect);
11384:   }
11384: }
