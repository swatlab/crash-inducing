    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Base class for DOM Core's nsIDOMComment, nsIDOMDocumentType, nsIDOMText,
    1:  * nsIDOMCDATASection, and nsIDOMProcessingInstruction nodes.
    1:  */
    1: 
    1: #ifndef nsGenericDOMDataNode_h___
    1: #define nsGenericDOMDataNode_h___
    1: 
30695: #include "nsIContent.h"
    1: #include "nsIDOMCharacterData.h"
 1418: #include "nsIDOMEventTarget.h"
15250: #include "nsIDOM3Text.h"
    1: #include "nsTextFragment.h"
    1: #include "nsDOMError.h"
    1: #include "nsIEventListenerManager.h"
    1: #include "nsGenericElement.h"
    1: #include "nsCycleCollectionParticipant.h"
16056: #include "nsContentUtils.h"
    1: 
23697: #ifdef MOZ_SMIL
23697: #include "nsISMILAttr.h"
23697: #endif // MOZ_SMIL
23697: 
30695: // This bit is set to indicate that if the text node changes to
30695: // non-whitespace, we may need to create a frame for it. This bit must
30695: // not be set on nodes that already have a frame.
30695: #define NS_CREATE_FRAME_IF_NON_WHITESPACE (1 << NODE_TYPE_SPECIFIC_BITS_OFFSET)
30695: 
30695: // This bit is set to indicate that if the text node changes to
30695: // whitespace, we may need to reframe it (or its ancestors).
30695: #define NS_REFRAME_IF_WHITESPACE (1 << (NODE_TYPE_SPECIFIC_BITS_OFFSET + 1))
30695: 
30695: // This bit is set to indicate that the text may be part of a selection.
30695: #define NS_TEXT_IN_SELECTION (1 << (NODE_TYPE_SPECIFIC_BITS_OFFSET + 2))
30695: 
43785: // Make sure we have enough space for those bits
43785: PR_STATIC_ASSERT(NODE_TYPE_SPECIFIC_BITS_OFFSET + 2 < 32);
43785: 
    1: class nsIDOMAttr;
    1: class nsIDOMEventListener;
    1: class nsIDOMNodeList;
    1: class nsIFrame;
    1: class nsIDOMText;
    1: class nsINodeInfo;
    1: class nsURI;
    1: 
    1: class nsGenericDOMDataNode : public nsIContent
    1: {
    1: public:
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
    1: 
48124:   nsGenericDOMDataNode(already_AddRefed<nsINodeInfo> aNodeInfo);
    1:   virtual ~nsGenericDOMDataNode();
    1: 
    1:   // Implementation for nsIDOMNode
    1:   nsresult GetNodeValue(nsAString& aNodeValue);
    1:   nsresult SetNodeValue(const nsAString& aNodeValue);
    1:   nsresult GetAttributes(nsIDOMNamedNodeMap** aAttributes)
    1:   {
    1:     NS_ENSURE_ARG_POINTER(aAttributes);
    1:     *aAttributes = nsnull;
    1:     return NS_OK;
    1:   }
    1:   nsresult HasChildNodes(PRBool* aHasChildNodes)
    1:   {
    1:     NS_ENSURE_ARG_POINTER(aHasChildNodes);
    1:     *aHasChildNodes = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1:   nsresult HasAttributes(PRBool* aHasAttributes)
    1:   {
    1:     NS_ENSURE_ARG_POINTER(aHasAttributes);
    1:     *aHasAttributes = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1:   nsresult InsertBefore(nsIDOMNode* aNewChild, nsIDOMNode* aRefChild,
    1:                         nsIDOMNode** aReturn)
    1:   {
41527:     return ReplaceOrInsertBefore(PR_FALSE, aNewChild, aRefChild, aReturn);
    1:   }
    1:   nsresult ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,
    1:                         nsIDOMNode** aReturn)
    1:   {
41527:     return ReplaceOrInsertBefore(PR_TRUE, aNewChild, aOldChild, aReturn);
    1:   }
    1:   nsresult RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn)
    1:   {
41527:     return nsINode::RemoveChild(aOldChild, aReturn);
    1:   }
    1:   nsresult AppendChild(nsIDOMNode* aNewChild, nsIDOMNode** aReturn)
    1:   {
41527:     return InsertBefore(aNewChild, nsnull, aReturn);
    1:   }
    1:   nsresult GetNamespaceURI(nsAString& aNamespaceURI);
    1:   nsresult GetLocalName(nsAString& aLocalName);
    1:   nsresult GetPrefix(nsAString& aPrefix);
    1:   nsresult SetPrefix(const nsAString& aPrefix);
    1:   nsresult Normalize();
    1:   nsresult IsSupported(const nsAString& aFeature,
    1:                        const nsAString& aVersion,
    1:                        PRBool* aReturn);
    1: 
    1:   // Implementation for nsIDOMCharacterData
    1:   nsresult GetData(nsAString& aData) const;
    1:   nsresult SetData(const nsAString& aData);
    1:   nsresult GetLength(PRUint32* aLength);
    1:   nsresult SubstringData(PRUint32 aOffset, PRUint32 aCount,
    1:                          nsAString& aReturn);
    1:   nsresult AppendData(const nsAString& aArg);
    1:   nsresult InsertData(PRUint32 aOffset, const nsAString& aArg);
    1:   nsresult DeleteData(PRUint32 aOffset, PRUint32 aCount);
    1:   nsresult ReplaceData(PRUint32 aOffset, PRUint32 aCount,
    1:                        const nsAString& aArg);
    1: 
    1:   // nsINode methods
    1:   virtual PRUint32 GetChildCount() const;
    1:   virtual nsIContent *GetChildAt(PRUint32 aIndex) const;
22251:   virtual nsIContent * const * GetChildArray(PRUint32* aChildCount) const;
    1:   virtual PRInt32 IndexOf(nsINode* aPossibleChild) const;
    1:   virtual nsresult InsertChildAt(nsIContent* aKid, PRUint32 aIndex,
    1:                                  PRBool aNotify);
29805:   virtual nsresult RemoveChildAt(PRUint32 aIndex, PRBool aNotify, PRBool aMutationEvent = PR_TRUE);
    1:   virtual nsresult PreHandleEvent(nsEventChainPreVisitor& aVisitor);
    1:   virtual nsresult PostHandleEvent(nsEventChainPostVisitor& aVisitor);
    1:   virtual nsresult DispatchDOMEvent(nsEvent* aEvent, nsIDOMEvent* aDOMEvent,
    1:                                     nsPresContext* aPresContext,
    1:                                     nsEventStatus* aEventStatus);
29474:   virtual nsIEventListenerManager* GetListenerManager(PRBool aCreateIfNotFound);
 1418:   virtual nsresult AddEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                          const nsIID& aIID);
 1418:   virtual nsresult RemoveEventListenerByIID(nsIDOMEventListener *aListener,
 1418:                                             const nsIID& aIID);
 1418:   virtual nsresult GetSystemEventGroup(nsIDOMEventGroup** aGroup);
27700:   virtual nsIScriptContext* GetContextForEventHandlers(nsresult* aRv)
16056:   {
27700:     return nsContentUtils::GetContextForEventHandlers(this, aRv);
16056:   }
41907:   virtual void GetTextContent(nsAString &aTextContent)
41907:   {
41907: #ifdef DEBUG
41907:     nsresult rv =
41907: #endif
41907:     GetNodeValue(aTextContent);
41907:     NS_ASSERTION(NS_SUCCEEDED(rv), "GetNodeValue() failed?");
41907:   }
41907:   virtual nsresult SetTextContent(const nsAString& aTextContent)
41907:   {
41907:     // Batch possible DOMSubtreeModified events.
41907:     mozAutoSubtreeModified subtree(GetOwnerDoc(), nsnull);
41907:     return SetNodeValue(aTextContent);
41907:   }
    1: 
    1:   // Implementation for nsIContent
    1:   virtual nsresult BindToTree(nsIDocument* aDocument, nsIContent* aParent,
    1:                               nsIContent* aBindingParent,
    1:                               PRBool aCompileEventHandlers);
    1:   virtual void UnbindFromTree(PRBool aDeep = PR_TRUE,
    1:                               PRBool aNullParent = PR_TRUE);
    1: 
55877:   virtual already_AddRefed<nsINodeList> GetChildren(PRUint32 aFilter);
38069: 
 4036:   virtual nsIAtom *GetIDAttributeName() const;
    1:   virtual already_AddRefed<nsINodeInfo> GetExistingAttrNameFromQName(const nsAString& aStr) const;
    1:   nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aName,
    1:                    const nsAString& aValue, PRBool aNotify)
    1:   {
    1:     return SetAttr(aNameSpaceID, aName, nsnull, aValue, aNotify);
    1:   }
    1:   virtual nsresult SetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
    1:                            nsIAtom* aPrefix, const nsAString& aValue,
    1:                            PRBool aNotify);
    1:   virtual nsresult UnsetAttr(PRInt32 aNameSpaceID, nsIAtom* aAttribute,
    1:                              PRBool aNotify);
    1:   virtual PRBool GetAttr(PRInt32 aNameSpaceID, nsIAtom *aAttribute,
    1:                          nsAString& aResult) const;
    1:   virtual PRBool HasAttr(PRInt32 aNameSpaceID, nsIAtom *aAttribute) const;
    1:   virtual const nsAttrName* GetAttrNameAt(PRUint32 aIndex) const;
    1:   virtual PRUint32 GetAttrCount() const;
    1:   virtual const nsTextFragment *GetText();
    1:   virtual PRUint32 TextLength();
    1:   virtual nsresult SetText(const PRUnichar* aBuffer, PRUint32 aLength,
    1:                            PRBool aNotify);
    1:   // Need to implement this here too to avoid hiding.
    1:   nsresult SetText(const nsAString& aStr, PRBool aNotify)
    1:   {
    1:     return SetText(aStr.BeginReading(), aStr.Length(), aNotify);
    1:   }
    1:   virtual nsresult AppendText(const PRUnichar* aBuffer, PRUint32 aLength,
    1:                               PRBool aNotify);
    1:   virtual PRBool TextIsOnlyWhitespace();
    1:   virtual void AppendTextTo(nsAString& aResult);
 8462:   virtual void DestroyContent();
14188:   virtual void SaveSubtreeState();
23697: 
23697: #ifdef MOZ_SMIL
55139:   virtual nsISMILAttr* GetAnimatedAttr(PRInt32 /*aNamespaceID*/, nsIAtom* /*aName*/)
23697:   {
23697:     return nsnull;
23697:   }
32193:   virtual nsresult GetSMILOverrideStyle(nsIDOMCSSStyleDeclaration** aStyle);
32193:   virtual nsICSSStyleRule* GetSMILOverrideStyleRule();
32193:   virtual nsresult SetSMILOverrideStyleRule(nsICSSStyleRule* aStyleRule,
32193:                                             PRBool aNotify);
23697: #endif // MOZ_SMIL
23697: 
    1: #ifdef DEBUG
    1:   virtual void List(FILE* out, PRInt32 aIndent) const;
    1:   virtual void DumpContent(FILE* out, PRInt32 aIndent, PRBool aDumpAll) const;
    1: #endif
    1: 
    1:   virtual nsIContent *GetBindingParent() const;
    1:   virtual PRBool IsNodeOfType(PRUint32 aFlags) const;
    1:   virtual PRBool IsLink(nsIURI** aURI) const;
    1: 
43079:   virtual nsIAtom* DoGetID() const;
19132:   virtual const nsAttrValue* DoGetClasses() const;
    1:   NS_IMETHOD WalkContentStyleRules(nsRuleWalker* aRuleWalker);
    1:   virtual nsICSSStyleRule* GetInlineStyleRule();
    1:   NS_IMETHOD SetInlineStyleRule(nsICSSStyleRule* aStyleRule, PRBool aNotify);
    1:   NS_IMETHOD_(PRBool) IsAttributeMapped(const nsIAtom* aAttribute) const;
    1:   virtual nsChangeHint GetAttributeChangeHint(const nsIAtom* aAttribute,
    1:                                               PRInt32 aModType) const;
    1:   virtual nsIAtom *GetClassAttributeName() const;
    1: 
    1:   virtual nsresult Clone(nsINodeInfo *aNodeInfo, nsINode **aResult) const
    1:   {
    1:     *aResult = CloneDataNode(aNodeInfo, PR_TRUE);
    1:     if (!*aResult) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     NS_ADDREF(*aResult);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
16205:   nsresult SplitData(PRUint32 aOffset, nsIContent** aReturn,
16205:                      PRBool aCloneAfterOriginal = PR_TRUE);
16205: 
    1:   //----------------------------------------
    1: 
    1: #ifdef DEBUG
    1:   void ToCString(nsAString& aBuf, PRInt32 aOffset, PRInt32 aLen) const;
    1: #endif
    1: 
30001:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(nsGenericDOMDataNode)
    1: 
    1: protected:
41904:   virtual mozilla::dom::Element* GetNameSpaceElement()
41904:   {
41904:     nsINode *parent = GetNodeParent();
41904: 
41991:     return parent && parent->IsElement() ? parent->AsElement() : nsnull;
41904:   }
41904: 
    1:   /**
    1:    * There are a set of DOM- and scripting-specific instance variables
    1:    * that may only be instantiated when a content object is accessed
    1:    * through the DOM. Rather than burn actual slots in the content
    1:    * objects for each of these instance variables, we put them off
    1:    * in a side structure that's only allocated when the content is
    1:    * accessed through the DOM.
    1:    */
    1:   class nsDataSlots : public nsINode::nsSlots
    1:   {
    1:   public:
    1:     nsDataSlots(PtrBits aFlags)
    1:       : nsINode::nsSlots(aFlags),
    1:         mBindingParent(nsnull)
    1:     {
    1:     }
    1: 
    1:     /**
    1:      * The nearest enclosing content node with a binding that created us.
    1:      * @see nsIContent::GetBindingParent
    1:      */
    1:     nsIContent* mBindingParent;  // [Weak]
    1:   };
    1: 
    1:   // Override from nsINode
    1:   virtual nsINode::nsSlots* CreateSlots();
    1: 
    1:   nsDataSlots *GetDataSlots()
    1:   {
 3233:     return static_cast<nsDataSlots*>(GetSlots());
    1:   }
    1: 
    1:   nsDataSlots *GetExistingDataSlots() const
    1:   {
 3233:     return static_cast<nsDataSlots*>(GetExistingSlots());
    1:   }
    1: 
    1:   nsresult SplitText(PRUint32 aOffset, nsIDOMText** aReturn);
    1: 
15250:   friend class nsText3Tearoff;
15250: 
15899:   static PRInt32 FirstLogicallyAdjacentTextNode(nsIContent* aParent,
15899:                                                 PRInt32 aIndex);
15250: 
15899:   static PRInt32 LastLogicallyAdjacentTextNode(nsIContent* aParent,
15899:                                                PRInt32 aIndex,
15250:                                                PRUint32 aCount);
15250: 
    1:   nsresult SetTextInternal(PRUint32 aOffset, PRUint32 aCount,
    1:                            const PRUnichar* aBuffer, PRUint32 aLength,
    1:                            PRBool aNotify);
    1: 
    1:   /**
    1:    * Method to clone this node. This needs to be overriden by all derived
    1:    * classes. If aCloneText is true the text content will be cloned too.
    1:    *
    1:    * @param aOwnerDocument the ownerDocument of the clone
    1:    * @param aCloneText if true the text content will be cloned too
    1:    * @return the clone
    1:    */
    1:   virtual nsGenericDOMDataNode *CloneDataNode(nsINodeInfo *aNodeInfo,
    1:                                               PRBool aCloneText) const = 0;
    1: 
    1:   nsTextFragment mText;
    1: 
    1: private:
53733:   void UpdateBidiStatus(const PRUnichar* aBuffer, PRUint32 aLength);
    1: 
    1:   already_AddRefed<nsIAtom> GetCurrentValueAtom();
    1: };
    1: 
41903: class nsGenericTextNode : public nsGenericDOMDataNode
41903: {
41903: public:
48124:   nsGenericTextNode(already_AddRefed<nsINodeInfo> aNodeInfo)
48124:   : nsGenericDOMDataNode(aNodeInfo)
41903:   {
41903:   }
41903: 
41903:   PRBool IsElementContentWhitespace()
41903:   {
41903:     return TextIsOnlyWhitespace();
41903:   }
41903:   nsresult GetWholeText(nsAString& aWholeText);
41903: 
41903:   nsIContent* ReplaceWholeText(const nsAFlatString& aContent,
41903:                                nsresult *aResult);
41903: };
41903: 
15250: /** Tearoff class for the nsIDOM3Text portion of nsGenericDOMDataNode. */
15250: class nsText3Tearoff : public nsIDOM3Text
15250: {
15250: public:
15250:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
15250: 
15250:   NS_DECL_NSIDOM3TEXT
15250: 
15250:   NS_DECL_CYCLE_COLLECTION_CLASS(nsText3Tearoff)
15250: 
41903:   nsText3Tearoff(nsGenericTextNode *aNode) : mNode(aNode)
15250:   {
15250:   }
15250: 
15250: protected:
15250:   virtual ~nsText3Tearoff() {}
15250: 
15250: private:
41903:   nsRefPtr<nsGenericTextNode> mNode;
15250: };
15250: 
    1: //----------------------------------------------------------------------
    1: 
    1: /**
    1:  * Mostly implement the nsIDOMNode API by forwarding the methods to
    1:  * nsGenericDOMDataNode
    1:  *
    1:  * Note that classes using this macro will need to implement:
    1:  *       NS_IMETHOD GetNodeType(PRUint16* aNodeType);
    1:  *       nsGenericDOMDataNode *CloneDataNode(nsINodeInfo *aNodeInfo,
    1:  *                                           PRBool aCloneText) const;
    1:  */
    1: #define NS_IMPL_NSIDOMNODE_USING_GENERIC_DOM_DATA                           \
    1:   NS_IMETHOD GetNodeName(nsAString& aNodeName);                             \
    1:   NS_IMETHOD GetLocalName(nsAString& aLocalName) {                          \
    1:     return nsGenericDOMDataNode::GetLocalName(aLocalName);                  \
    1:   }                                                                         \
    1:   NS_IMETHOD GetNodeValue(nsAString& aNodeValue);                           \
    1:   NS_IMETHOD SetNodeValue(const nsAString& aNodeValue);                     \
    1:   NS_IMETHOD GetNodeType(PRUint16* aNodeType);                              \
    1:   NS_IMETHOD GetParentNode(nsIDOMNode** aParentNode) {                      \
    1:     return nsGenericDOMDataNode::GetParentNode(aParentNode);                \
    1:   }                                                                         \
    1:   NS_IMETHOD GetChildNodes(nsIDOMNodeList** aChildNodes) {                  \
    1:     return nsGenericDOMDataNode::GetChildNodes(aChildNodes);                \
    1:   }                                                                         \
    1:   NS_IMETHOD HasChildNodes(PRBool* aHasChildNodes) {                        \
    1:     return nsGenericDOMDataNode::HasChildNodes(aHasChildNodes);             \
    1:   }                                                                         \
    1:   NS_IMETHOD HasAttributes(PRBool* aHasAttributes) {                        \
    1:     return nsGenericDOMDataNode::HasAttributes(aHasAttributes);             \
    1:   }                                                                         \
    1:   NS_IMETHOD GetFirstChild(nsIDOMNode** aFirstChild) {                      \
    1:     return nsGenericDOMDataNode::GetFirstChild(aFirstChild);                \
    1:   }                                                                         \
    1:   NS_IMETHOD GetLastChild(nsIDOMNode** aLastChild) {                        \
    1:     return nsGenericDOMDataNode::GetLastChild(aLastChild);                  \
    1:   }                                                                         \
    1:   NS_IMETHOD GetPreviousSibling(nsIDOMNode** aPreviousSibling) {            \
    1:     return nsGenericDOMDataNode::GetPreviousSibling(aPreviousSibling);      \
    1:   }                                                                         \
    1:   NS_IMETHOD GetNextSibling(nsIDOMNode** aNextSibling) {                    \
    1:     return nsGenericDOMDataNode::GetNextSibling(aNextSibling);              \
    1:   }                                                                         \
    1:   NS_IMETHOD GetAttributes(nsIDOMNamedNodeMap** aAttributes) {              \
    1:     return nsGenericDOMDataNode::GetAttributes(aAttributes);                \
    1:   }                                                                         \
    1:   NS_IMETHOD InsertBefore(nsIDOMNode* aNewChild, nsIDOMNode* aRefChild,     \
    1:                              nsIDOMNode** aReturn) {                        \
    1:     return nsGenericDOMDataNode::InsertBefore(aNewChild, aRefChild,         \
    1:                                               aReturn);                     \
    1:   }                                                                         \
    1:   NS_IMETHOD AppendChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn) {     \
    1:     return nsGenericDOMDataNode::AppendChild(aOldChild, aReturn);           \
    1:   }                                                                         \
    1:   NS_IMETHOD ReplaceChild(nsIDOMNode* aNewChild, nsIDOMNode* aOldChild,     \
    1:                              nsIDOMNode** aReturn) {                        \
    1:     return nsGenericDOMDataNode::ReplaceChild(aNewChild, aOldChild,         \
    1:                                               aReturn);                     \
    1:   }                                                                         \
    1:   NS_IMETHOD RemoveChild(nsIDOMNode* aOldChild, nsIDOMNode** aReturn) {     \
    1:     return nsGenericDOMDataNode::RemoveChild(aOldChild, aReturn);           \
    1:   }                                                                         \
    1:   NS_IMETHOD GetOwnerDocument(nsIDOMDocument** aOwnerDocument) {            \
    1:     return nsGenericDOMDataNode::GetOwnerDocument(aOwnerDocument);          \
    1:   }                                                                         \
    1:   NS_IMETHOD GetNamespaceURI(nsAString& aNamespaceURI) {                    \
    1:     return nsGenericDOMDataNode::GetNamespaceURI(aNamespaceURI);            \
    1:   }                                                                         \
    1:   NS_IMETHOD GetPrefix(nsAString& aPrefix) {                                \
    1:     return nsGenericDOMDataNode::GetPrefix(aPrefix);                        \
    1:   }                                                                         \
    1:   NS_IMETHOD SetPrefix(const nsAString& aPrefix) {                          \
    1:     return nsGenericDOMDataNode::SetPrefix(aPrefix);                        \
    1:   }                                                                         \
    1:   NS_IMETHOD Normalize() {                                                  \
    1:     return NS_OK;                                                           \
    1:   }                                                                         \
    1:   NS_IMETHOD IsSupported(const nsAString& aFeature,                         \
    1:                       const nsAString& aVersion,                            \
    1:                       PRBool* aReturn) {                                    \
    1:     return nsGenericDOMDataNode::IsSupported(aFeature, aVersion, aReturn);  \
    1:   }                                                                         \
    1:   NS_IMETHOD CloneNode(PRBool aDeep, nsIDOMNode** aReturn) {                \
58904:     return nsNodeUtils::CloneNodeImpl(this, aDeep, PR_TRUE, aReturn);       \
    1:   }                                                                         \
    1:   virtual nsGenericDOMDataNode *CloneDataNode(nsINodeInfo *aNodeInfo,       \
    1:                                               PRBool aCloneText) const;
    1: 
    1: #endif /* nsGenericDOMDataNode_h___ */
