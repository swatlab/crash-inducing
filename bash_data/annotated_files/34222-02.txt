    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributors:
    1:  *   Mike Shaver <shaver@zeroknowledge.com>
    1:  *   John Bandhauer <jband@netscape.com>
    1:  *   IBM Corp.
    1:  *   Robert Ginda <rginda@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifdef MOZ_LOGGING
    1: #define FORCE_PR_LOG
    1: #endif
    1: 
 1493: #include <stdarg.h>
 1493: 
    1: #include "prlog.h"
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsIComponentManager.h"
 1493: #include "nsIComponentManagerObsolete.h"
    1: #include "nsIGenericFactory.h"
    1: #include "nsILocalFile.h"
    1: #include "nsIModule.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsISupports.h"
    1: #include "mozJSComponentLoader.h"
    1: #include "nsIJSRuntimeService.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsCRT.h"
    1: #include "nsMemory.h"
    1: #include "nsIObserverService.h"
    1: #include "nsIXPCScriptable.h"
    1: #include "nsString.h"
    1: #ifndef XPCONNECT_STANDALONE
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsIURI.h"
 2226: #include "nsIFileURL.h"
    1: #include "nsNetUtil.h"
    1: #endif
    1: #include "jsxdrapi.h"
 1493: #include "jsprf.h"
    1: #include "nsIFastLoadFileControl.h"
    1: // For reporting errors with the console service
    1: #include "nsIScriptError.h"
    1: #include "nsIConsoleService.h"
    1: #include "prmem.h"
    1: #include "plbase64.h"
    1: 
31063: #if defined(MOZ_SHARK) || defined(MOZ_CALLGRIND) || defined(MOZ_VTUNE) || defined(MOZ_TRACEVIS)
10451: #include "jsdbgapi.h"
10451: #endif
10451: 
    1: static const char kJSRuntimeServiceContractID[] = "@mozilla.org/js/xpc/RuntimeService;1";
    1: static const char kXPConnectServiceContractID[] = "@mozilla.org/js/xpc/XPConnect;1";
    1: static const char kObserverServiceContractID[] = "@mozilla.org/observer-service;1";
    1: 
    1: /* Some platforms don't have an implementation of PR_MemMap(). */
25283: #if !defined(XP_BEOS) && !defined(XP_OS2)
    1: #define HAVE_PR_MEMMAP
    1: #endif
    1: 
    1: /**
    1:  * Buffer sizes for serialization and deserialization of scripts.
13823:  * FIXME: bug #411579 (tune this macro!) Last updated: Jan 2008
    1:  */
    1: #define XPC_SERIALIZATION_BUFFER_SIZE   (64 * 1024)
13823: #define XPC_DESERIALIZATION_BUFFER_SIZE (12 * 8192)
    1: 
    1: // Inactivity delay before closing our fastload file stream.
13823: static const int kFastLoadWriteDelay = 10000;   // 10 seconds
    1: 
    1: #ifdef PR_LOGGING
    1: // NSPR_LOG_MODULES=JSComponentLoader:5
    1: static PRLogModuleInfo *gJSCLLog;
    1: #endif
    1: 
    1: #define LOG(args) PR_LOG(gJSCLLog, PR_LOG_DEBUG, args)
    1: 
 1493: // Components.utils.import error messages
 1493: #define ERROR_SCOPE_OBJ "%s - Second argument must be an object."
 1493: #define ERROR_NOT_PRESENT "%s - EXPORTED_SYMBOLS is not present."
 1493: #define ERROR_NOT_AN_ARRAY "%s - EXPORTED_SYMBOLS is not an array."
 1493: #define ERROR_GETTING_ARRAY_LENGTH "%s - Error getting array length of EXPORTED_SYMBOLS."
 1493: #define ERROR_ARRAY_ELEMENT "%s - EXPORTED_SYMBOLS[%d] is not a string."
 1493: #define ERROR_GETTING_SYMBOL "%s - Could not get symbol '%s'."
 1493: #define ERROR_SETTING_SYMBOL "%s - Could not set symbol '%s' on target object."
 1493: 
18907: void
    1: mozJSLoaderErrorReporter(JSContext *cx, const char *message, JSErrorReport *rep)
    1: {
    1:     nsresult rv;
    1: 
    1:     /* Use the console service to register the error. */
    1:     nsCOMPtr<nsIConsoleService> consoleService =
    1:         do_GetService(NS_CONSOLESERVICE_CONTRACTID);
    1: 
    1:     /*
    1:      * Make an nsIScriptError, populate it with information from this
    1:      * error, then log it with the console service.  The UI can then
    1:      * poll the service to update the Error console.
    1:      */
    1:     nsCOMPtr<nsIScriptError> errorObject = 
    1:         do_CreateInstance(NS_SCRIPTERROR_CONTRACTID);
    1:     
    1:     if (consoleService && errorObject) {
    1:         /*
    1:          * Got an error object; prepare appropriate-width versions of
    1:          * various arguments to it.
    1:          */
    1:         nsAutoString fileUni;
    1:         fileUni.AssignWithConversion(rep->filename);
    1: 
    1:         PRUint32 column = rep->uctokenptr - rep->uclinebuf;
    1: 
 3233:         rv = errorObject->Init(reinterpret_cast<const PRUnichar*>
 3233:                                                (rep->ucmessage),
    1:                                fileUni.get(),
 3233:                                reinterpret_cast<const PRUnichar*>
 3233:                                                (rep->uclinebuf),
    1:                                rep->lineno, column, rep->flags,
    1:                                "component javascript");
    1:         if (NS_SUCCEEDED(rv)) {
    1:             rv = consoleService->LogMessage(errorObject);
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 // We're done!  Skip return to fall thru to stderr
    1:                 // printout, for the benefit of those invoking the
    1:                 // browser with -console
    1:                 // return;
    1:             }
    1:         }
    1:     }
    1: 
    1:     /*
    1:      * If any of the above fails for some reason, fall back to
    1:      * printing to stderr.
    1:      */
    1: #ifdef DEBUG
    1:     fprintf(stderr, "JS Component Loader: %s %s:%d\n"
    1:             "                     %s\n",
    1:             JSREPORT_IS_WARNING(rep->flags) ? "WARNING" : "ERROR",
    1:             rep->filename, rep->lineno,
    1:             message ? message : "<no message>");
    1: #endif
    1: }
    1: 
18907: static JSBool
    1: Dump(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSString *str;
    1:     if (!argc)
    1:         return JS_TRUE;
    1:     
    1:     str = JS_ValueToString(cx, argv[0]);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
    1:     char *bytes = JS_GetStringBytes(str);
    1:     fputs(bytes, stderr);
    1:     return JS_TRUE;
    1: }
    1: 
18907: static JSBool
    1: Debug(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1: #ifdef DEBUG
    1:     return Dump(cx, obj, argc, argv, rval);
    1: #else
    1:     return JS_TRUE;
    1: #endif
    1: }
    1: 
18907: static JSBool
    1: Atob(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSString *str;
    1:     if (!argc)
    1:         return JS_TRUE;
    1: 
    1:     str = JS_ValueToString(cx, argv[0]);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
    1:     size_t base64StrLength = JS_GetStringLength(str);
    1:     char *base64Str = JS_GetStringBytes(str);
    1: 
    1:     PRUint32 bin_dataLength = (PRUint32)base64StrLength;
    1:     if (base64Str[base64StrLength - 1] == '=') {
    1:         if (base64Str[base64StrLength - 2] == '=')
    1:             bin_dataLength -= 2;
    1:         else  
    1:             --bin_dataLength;
    1:     }
    1:     bin_dataLength = (PRUint32)((PRUint64)bin_dataLength * 3) / 4;
    1: 
    1:     char *bin_data = PL_Base64Decode(base64Str, base64StrLength, nsnull);
    1:     if (!bin_data)
    1:         return JS_FALSE;
    1: 
    1:     str = JS_NewStringCopyN(cx, bin_data, bin_dataLength);
    1:     PR_Free(bin_data);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
    1:     *rval = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
18907: static JSBool
    1: Btoa(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSString *str;
    1:     if (!argc)
    1:         return JS_TRUE;
    1: 
    1:     str = JS_ValueToString(cx, argv[0]);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
    1:     char *bin_data = JS_GetStringBytes(str);
    1:     size_t bin_dataLength = JS_GetStringLength(str);
    1: 
    1:     char *base64 = PL_Base64Encode(bin_data, bin_dataLength, nsnull);
    1:     if (!base64)
    1:         return JS_FALSE;
    1: 
    1:     PRUint32 base64Length = ((bin_dataLength + 2) / 3) * 4;
    1:     str = JS_NewStringCopyN(cx, base64, base64Length);
    1:     PR_Free(base64);
    1:     if (!str)
    1:         return JS_FALSE;
    1: 
    1:     *rval = STRING_TO_JSVAL(str);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSFunctionSpec gGlobalFun[] = {
    1:     {"dump",    Dump,   1,0,0},
    1:     {"debug",   Debug,  1,0,0},
    1:     {"atob",    Atob,   1,0,0},
    1:     {"btoa",    Btoa,   1,0,0},
10451: #ifdef MOZ_SHARK
10451:     {"startShark",      js_StartShark,     0,0,0},
10451:     {"stopShark",       js_StopShark,      0,0,0},
10451:     {"connectShark",    js_ConnectShark,   0,0,0},
10451:     {"disconnectShark", js_DisconnectShark,0,0,0},
10451: #endif
15763: #ifdef MOZ_CALLGRIND
15763:     {"startCallgrind",  js_StartCallgrind, 0,0,0},
15763:     {"stopCallgrind",   js_StopCallgrind,  0,0,0},
15763:     {"dumpCallgrind",   js_DumpCallgrind,  1,0,0},
15763: #endif
16288: #ifdef MOZ_VTUNE
16288:     {"startVtune",      js_StartVtune,     1,0,0},
16288:     {"stopVtune",       js_StopVtune,      0,0,0},
16288:     {"pauseVtune",      js_PauseVtune,     0,0,0},
16288:     {"resumeVtune",     js_ResumeVtune,    0,0,0},
16288: #endif
31063: #ifdef MOZ_TRACEVIS
31063:     {"initEthogram",     js_InitEthogram,      0,0,0},
31063:     {"shutdownEthogram", js_ShutdownEthogram,  0,0,0},
31063: #endif
    1:     {nsnull,nsnull,0,0,0}
    1: };
    1: 
    1: class JSCLContextHelper
    1: {
    1: public:
16098:     JSCLContextHelper(mozJSComponentLoader* loader);
25117:     ~JSCLContextHelper() { Pop(); }
25117: 
25117:     JSContext* Pop();
    1: 
    1:     operator JSContext*() const {return mContext;}
    1: 
    1:     JSCLContextHelper(); // not implemnted
    1: private:
    1:     JSContext* mContext;
    1:     intN       mContextThread;
16098:     nsIThreadJSContextStack* mContextStack;
    1: };
    1: 
    1: 
    1: class JSCLAutoErrorReporterSetter
    1: {
    1: public:
    1:     JSCLAutoErrorReporterSetter(JSContext* cx, JSErrorReporter reporter)
    1:         {mContext = cx; mOldReporter = JS_SetErrorReporter(cx, reporter);}
    1:     ~JSCLAutoErrorReporterSetter()
    1:         {JS_SetErrorReporter(mContext, mOldReporter);} 
    1:     JSCLAutoErrorReporterSetter(); // not implemented
    1: private:
    1:     JSContext* mContext;
    1:     JSErrorReporter mOldReporter;
    1: };
    1: 
25117: static nsresult
25117: OutputError(JSContext *cx,
25117:             const char *format,
25117:             va_list ap)
25117: {
25117:     char *buf = JS_vsmprintf(format, ap);
25117:     if (!buf) {
25117:         return NS_ERROR_OUT_OF_MEMORY;
25117:     }
25117: 
25117:     JS_ReportError(cx, buf);
25117:     JS_smprintf_free(buf);
25117: 
25117:     return NS_OK;
25117: }
25117: 
25117: static nsresult
25117: ReportOnCaller(nsAXPCNativeCallContext *cc,
25117:                const char *format, ...) {
25117:     if (!cc) {
25117:         return NS_ERROR_FAILURE;
25117:     }
25117:     
25117:     va_list ap;
25117:     va_start(ap, format);
25117: 
25117:     nsresult rv;
25117:     JSContext *callerContext;
25117:     rv = cc->GetJSContext(&callerContext);
25117:     NS_ENSURE_SUCCESS(rv, rv);
25117: 
25117:     return OutputError(callerContext, format, ap);
25117: }
25117: 
25117: static nsresult
25117: ReportOnCaller(JSCLContextHelper &helper,
25117:                const char *format, ...)
25117: {
25117:     va_list ap;
25117:     va_start(ap, format);
25117: 
25117:     JSContext *cx = helper.Pop();
25117:     if (!cx) {
25117:         return NS_ERROR_FAILURE;
25117:     }
25117: 
25117:     return OutputError(cx, format, ap);
25117: }
25117: 
    1: NS_IMPL_ISUPPORTS1(nsXPCFastLoadIO, nsIFastLoadFileIO)
    1: 
    1: NS_IMETHODIMP
    1: nsXPCFastLoadIO::GetInputStream(nsIInputStream **_retval)
    1: {
    1:     if (! mInputStream) {
    1:         nsCOMPtr<nsIInputStream> fileInput;
    1:         nsresult rv = NS_NewLocalFileInputStream(getter_AddRefs(fileInput),
    1:                                                  mFile);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         rv = NS_NewBufferedInputStream(getter_AddRefs(mInputStream),
    1:                                        fileInput,
    1:                                        XPC_DESERIALIZATION_BUFFER_SIZE);
    1:         NS_ENSURE_SUCCESS(rv, rv);
33672:         mTruncateOutputFile = false;
    1:     }
    1: 
    1:     NS_ADDREF(*_retval = mInputStream);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsXPCFastLoadIO::GetOutputStream(nsIOutputStream **_retval)
    1: {
    1:     if (! mOutputStream) {
    1:         PRInt32 ioFlags = PR_WRONLY;
33672:         if (mTruncateOutputFile) {
    1:             ioFlags |= PR_CREATE_FILE | PR_TRUNCATE;
    1:         }
    1: 
    1:         nsCOMPtr<nsIOutputStream> fileOutput;
    1:         nsresult rv = NS_NewLocalFileOutputStream(getter_AddRefs(fileOutput),
    1:                                                   mFile, ioFlags, 0644);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         rv = NS_NewBufferedOutputStream(getter_AddRefs(mOutputStream),
    1:                                         fileOutput,
    1:                                         XPC_SERIALIZATION_BUFFER_SIZE);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     NS_ADDREF(*_retval = mOutputStream);
    1:     return NS_OK;
    1: }
    1: 
33672: NS_IMETHODIMP
33672: nsXPCFastLoadIO::DisableTruncate()
33672: {
33672:     mTruncateOutputFile = false;
33672:     return NS_OK;
33672: }
33672: 
    1: static nsresult
    1: ReadScriptFromStream(JSContext *cx, nsIObjectInputStream *stream,
    1:                      JSScript **script)
    1: {
    1:     *script = nsnull;
    1: 
    1:     PRUint32 size;
    1:     nsresult rv = stream->Read32(&size);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     char *data;
    1:     rv = stream->ReadBytes(size, &data);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     JSXDRState *xdr = JS_XDRNewMem(cx, JSXDR_DECODE);
    1:     NS_ENSURE_TRUE(xdr, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     xdr->userdata = stream;
    1:     JS_XDRMemSetData(xdr, data, size);
    1: 
 3313:     if (!JS_XDRScript(xdr, script)) {
 3313:         rv = NS_ERROR_FAILURE;
 3313:     }
 3313: 
    1:     // Update data in case ::JS_XDRScript called back into C++ code to
    1:     // read an XPCOM object.
    1:     //
    1:     // In that case, the serialization process must have flushed a run
    1:     // of counted bytes containing JS data at the point where the XPCOM
    1:     // object starts, after which an encoding C++ callback from the JS
    1:     // XDR code must have written the XPCOM object directly into the
    1:     // nsIObjectOutputStream.
    1:     //
    1:     // The deserialization process will XDR-decode counted bytes up to
    1:     // but not including the XPCOM object, then call back into C++ to
    1:     // read the object, then read more counted bytes and hand them off
    1:     // to the JSXDRState, so more JS data can be decoded.
    1:     //
    1:     // This interleaving of JS XDR data and XPCOM object data may occur
    1:     // several times beneath the call to ::JS_XDRScript, above.  At the
    1:     // end of the day, we need to free (via nsMemory) the data owned by
    1:     // the JSXDRState.  So we steal it back, nulling xdr's buffer so it
    1:     // doesn't get passed to ::JS_free by ::JS_XDRDestroy.
    1: 
    1:     uint32 length;
 3233:     data = static_cast<char*>(JS_XDRMemGetData(xdr, &length));
    1:     if (data) {
    1:         JS_XDRMemSetData(xdr, nsnull, 0);
    1:     }
    1:     JS_XDRDestroy(xdr);
    1: 
    1:     // If data is null now, it must have been freed while deserializing an
    1:     // XPCOM object (e.g., a principal) beneath ::JS_XDRScript.
    1:     if (data) {
    1:         nsMemory::Free(data);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: static nsresult
    1: WriteScriptToStream(JSContext *cx, JSScript *script,
    1:                     nsIObjectOutputStream *stream)
    1: {
    1:     JSXDRState *xdr = JS_XDRNewMem(cx, JSXDR_ENCODE);
    1:     NS_ENSURE_TRUE(xdr, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     xdr->userdata = stream;
    1:     nsresult rv = NS_OK;
    1: 
    1:     if (JS_XDRScript(xdr, &script)) {
    1:         // Get the encoded JSXDRState data and write it.  The JSXDRState owns
    1:         // this buffer memory and will free it beneath ::JS_XDRDestroy.
    1:         //
    1:         // If an XPCOM object needs to be written in the midst of the JS XDR
    1:         // encoding process, the C++ code called back from the JS engine (e.g.,
    1:         // nsEncodeJSPrincipals in caps/src/nsJSPrincipals.cpp) will flush data
    1:         // from the JSXDRState to aStream, then write the object, then return
    1:         // to JS XDR code with xdr reset so new JS data is encoded at the front
    1:         // of the xdr's data buffer.
    1:         //
    1:         // However many XPCOM objects are interleaved with JS XDR data in the
    1:         // stream, when control returns here from ::JS_XDRScript, we'll have
    1:         // one last buffer of data to write to aStream.
    1: 
    1:         uint32 size;
 3233:         const char* data = reinterpret_cast<const char*>
 3233:                                            (JS_XDRMemGetData(xdr, &size));
    1:         NS_ASSERTION(data, "no decoded JSXDRState data!");
    1: 
    1:         rv = stream->Write32(size);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             rv = stream->WriteBytes(data, size);
    1:         }
    1:     } else {
    1:         rv = NS_ERROR_FAILURE; // likely to be a principals serialization error
    1:     }
    1: 
    1:     JS_XDRDestroy(xdr);
    1:     return rv;
    1: }
    1: 
    1: mozJSComponentLoader::mozJSComponentLoader()
    1:     : mRuntime(nsnull),
    1:       mContext(nsnull),
    1:       mInitialized(PR_FALSE)
    1: {
    1:     NS_ASSERTION(!sSelf, "mozJSComponentLoader should be a singleton");
    1: 
    1: #ifdef PR_LOGGING
    1:     if (!gJSCLLog) {
    1:         gJSCLLog = PR_NewLogModule("JSComponentLoader");
    1:     }
    1: #endif
    1: 
    1:     sSelf = this;
    1: }
    1: 
    1: mozJSComponentLoader::~mozJSComponentLoader()
    1: {
    1:     if (mInitialized) {
    1:         NS_ERROR("'xpcom-shutdown-loaders' was not fired before cleaning up mozJSComponentLoader");
    1:         UnloadModules();
    1:     }
    1: 
    1:     NS_ASSERTION(!mFastLoadTimer,
    1:                  "Fastload file should have been closed via xpcom-shutdown");
    1: 
    1:     sSelf = nsnull;
    1: }
    1: 
    1: mozJSComponentLoader*
    1: mozJSComponentLoader::sSelf;
    1: 
 1493: NS_IMPL_ISUPPORTS3(mozJSComponentLoader,
 1493:                    nsIModuleLoader,
 1493:                    xpcIJSModuleLoader,
 1493:                    nsIObserver)
    1:  
    1: nsresult
    1: mozJSComponentLoader::ReallyInit()
    1: {
    1:     nsresult rv;
    1: 
    1:     /*
    1:      * Get the JSRuntime from the runtime svc, if possible.
    1:      * We keep a reference around, because it's a Bad Thing if the runtime
    1:      * service gets shut down before we're done.  Bad!
    1:      */
    1: 
    1:     mRuntimeService = do_GetService(kJSRuntimeServiceContractID, &rv);
    1:     if (NS_FAILED(rv) ||
    1:         NS_FAILED(rv = mRuntimeService->GetRuntime(&mRuntime)))
    1:         return rv;
    1: 
16098:     mContextStack = do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
16098:     if (NS_FAILED(rv))
16098:         return rv;
16098: 
    1:     // Create our compilation context.
    1:     mContext = JS_NewContext(mRuntime, 256);
    1:     if (!mContext)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     uint32 options = JS_GetOptions(mContext);
    1:     JS_SetOptions(mContext, options | JSOPTION_XML);
    1: 
 2208:     // Always use the latest js version
 2208:     JS_SetVersion(mContext, JSVERSION_LATEST);
    1: 
13533:     // Limit C stack consumption to a reasonable 512K
13533:     int stackDummy;
13533:     const jsuword kStackSize = 0x80000;
13533:     jsuword stackLimit, currentStackAddr = (jsuword)&stackDummy;
13533: 
13533: #if JS_STACK_GROWTH_DIRECTION < 0
13533:     stackLimit = (currentStackAddr > kStackSize)
13533:                  ? currentStackAddr - kStackSize
13533:                  : 0;
13533: #else
13533:     stackLimit = (currentStackAddr + kStackSize > currentStackAddr)
13533:                  ? currentStackAddr + kStackSize
13533:                  : (jsuword) -1;
13533: #endif
13533:     
13533:     JS_SetThreadStackLimit(mContext, stackLimit);
13533: 
    1: #ifndef XPCONNECT_STANDALONE
    1:     nsCOMPtr<nsIScriptSecurityManager> secman = 
    1:         do_GetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID);
    1:     if (!secman)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     rv = secman->GetSystemPrincipal(getter_AddRefs(mSystemPrincipal));
    1:     if (NS_FAILED(rv) || !mSystemPrincipal)
    1:         return NS_ERROR_FAILURE;
    1: #endif
    1: 
    1:     if (!mModules.Init(32))
    1:         return NS_ERROR_OUT_OF_MEMORY;
 1493:     if (!mImports.Init(32))
 1493:         return NS_ERROR_OUT_OF_MEMORY;
 2601:     if (!mInProgressImports.Init(32))
 2601:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     // Set up our fastload file
    1:     nsCOMPtr<nsIFastLoadService> flSvc = do_GetFastLoadService(&rv);
    1:     if (NS_SUCCEEDED(rv))
    1:         rv = flSvc->NewFastLoadFile("XPC", getter_AddRefs(mFastLoadFile));
    1:     if (NS_FAILED(rv)) {
    1:         LOG(("Could not get fastload file location\n"));
    1:     }
    1: 
    1:     // Listen for xpcom-shutdown so that we can close out our fastload file
    1:     // at that point (after that we can no longer create an input stream).
    1:     nsCOMPtr<nsIObserverService> obsSvc =
    1:         do_GetService(kObserverServiceContractID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = obsSvc->AddObserver(this, NS_XPCOM_SHUTDOWN_OBSERVER_ID, PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = obsSvc->AddObserver(this, "xpcom-shutdown-loaders", PR_FALSE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1: #ifdef DEBUG_shaver_off
    1:     fprintf(stderr, "mJCL: ReallyInit success!\n");
    1: #endif
    1:     mInitialized = PR_TRUE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: mozJSComponentLoader::LoadModule(nsILocalFile* aComponentFile,
    1:                                  nsIModule* *aResult)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCAutoString leafName;
    1:     aComponentFile->GetNativeLeafName(leafName);
    1:     if (!StringTail(leafName, 3).LowerCaseEqualsLiteral(".js"))
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     if (!mInitialized) {
    1:         rv = ReallyInit();
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1:     }
    1: 
    1:     nsCOMPtr<nsIHashable> lfhash(do_QueryInterface(aComponentFile));
    1:     if (!lfhash) {
    1:         NS_ERROR("nsLocalFile not implementing nsIHashable");
    1:         return NS_NOINTERFACE;
    1:     }
    1: 
    1:     ModuleEntry* mod;
    1:     if (mModules.Get(lfhash, &mod)) {
    1:         NS_ASSERTION(mod->module, "Bad hashtable data!");
    1:         NS_ADDREF(*aResult = mod->module);
    1:         return NS_OK;
    1:     }
    1: 
    1:     nsAutoPtr<ModuleEntry> entry(new ModuleEntry);
    1:     if (!entry)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
16381:     rv = GlobalForLocation(aComponentFile, &entry->global, &entry->location,
16381:                            nsnull);
    1:     if (NS_FAILED(rv)) {
    1: #ifdef DEBUG_shaver
    1:         fprintf(stderr, "GlobalForLocation failed!\n");
    1: #endif
    1:         return rv;
    1:     }
    1: 
    1:     nsCOMPtr<nsIXPConnect> xpc = do_GetService(kXPConnectServiceContractID,
    1:                                                &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCOMPtr<nsIComponentManager> cm;
    1:     rv = NS_GetComponentManager(getter_AddRefs(cm));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
16098:     JSCLContextHelper cx(this);
    1: 
    1:     JSObject* cm_jsobj;
    1:     nsCOMPtr<nsIXPConnectJSObjectHolder> cm_holder;
    1:     rv = xpc->WrapNative(cx, entry->global, cm, 
    1:                          NS_GET_IID(nsIComponentManager),
    1:                          getter_AddRefs(cm_holder));
    1: 
    1:     if (NS_FAILED(rv)) {
    1: #ifdef DEBUG_shaver
    1:         fprintf(stderr, "WrapNative(%p,%p,nsIComponentManager) failed: %x\n",
    1:                 (void *)(JSContext*)cx, (void *)mCompMgr, rv);
    1: #endif
    1:         return rv;
    1:     }
    1: 
    1:     rv = cm_holder->GetJSObject(&cm_jsobj);
    1:     if (NS_FAILED(rv)) {
    1: #ifdef DEBUG_shaver
    1:         fprintf(stderr, "GetJSObject of ComponentManager failed\n");
    1: #endif
    1:         return rv;
    1:     }
    1: 
    1:     JSObject* file_jsobj;
    1:     nsCOMPtr<nsIXPConnectJSObjectHolder> file_holder;
    1:     rv = xpc->WrapNative(cx, entry->global, aComponentFile, 
    1:                          NS_GET_IID(nsIFile),
    1:                          getter_AddRefs(file_holder));
    1: 
    1:     if (NS_FAILED(rv)) {
    1:         return rv;
    1:     }
    1: 
    1:     rv = file_holder->GetJSObject(&file_jsobj);
    1:     if (NS_FAILED(rv)) {
    1:         return rv;
    1:     }
    1: 
    1:     JSCLAutoErrorReporterSetter aers(cx, mozJSLoaderErrorReporter);
    1: 
    1:     jsval argv[2], retval, NSGetModule_val;
    1: 
    1:     if (!JS_GetProperty(cx, entry->global, "NSGetModule", &NSGetModule_val) ||
    1:         JSVAL_IS_VOID(NSGetModule_val)) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     if (JS_TypeOfValue(cx, NSGetModule_val) != JSTYPE_FUNCTION) {
    1:         nsCAutoString path;
    1:         aComponentFile->GetNativePath(path);
    1: 
    1:         JS_ReportError(cx, "%s has NSGetModule property that is not a function",
    1:                        path.get());
    1:         return NS_ERROR_FAILURE;
    1:     }
    1:     
    1:     argv[0] = OBJECT_TO_JSVAL(cm_jsobj);
    1:     argv[1] = OBJECT_TO_JSVAL(file_jsobj);
    1:     if (!JS_CallFunctionValue(cx, entry->global, NSGetModule_val,
    1:                               2, argv, &retval)) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1: #ifdef DEBUG_shaver_off
    1:     JSString *s = JS_ValueToString(cx, retval);
    1:     fprintf(stderr, "mJCL: %s::NSGetModule returned %s\n",
    1:             registryLocation, JS_GetStringBytes(s));
    1: #endif
    1: 
    1:     JSObject *jsModuleObj;
29078:     if (!JS_ValueToObject(cx, retval, &jsModuleObj) ||
29078:         !jsModuleObj) {
    1:         /* XXX report error properly */
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     rv = xpc->WrapJS(cx, jsModuleObj,
    1:                      NS_GET_IID(nsIModule), getter_AddRefs(entry->module));
    1:     if (NS_FAILED(rv)) {
    1:         /* XXX report error properly */
    1: #ifdef DEBUG
    1:         fprintf(stderr, "mJCL: couldn't get nsIModule from jsval\n");
    1: #endif
    1:         return rv;
    1:     }
    1: 
    1:     // Cache this module for later
    1:     if (!mModules.Put(lfhash, entry))
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     NS_ADDREF(*aResult = entry->module);
    1: 
    1:     // The hash owns the ModuleEntry now, forget about it
    1:     entry.forget();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: // Some stack based classes for cleaning up on early return
    1: #ifdef HAVE_PR_MEMMAP
    1: class FileAutoCloser
    1: {
    1:  public:
    1:     explicit FileAutoCloser(PRFileDesc *file) : mFile(file) {}
    1:     ~FileAutoCloser() { PR_Close(mFile); }
    1:  private:
    1:     PRFileDesc *mFile;
    1: };
    1: 
    1: class FileMapAutoCloser
    1: {
    1:  public:
    1:     explicit FileMapAutoCloser(PRFileMap *map) : mMap(map) {}
    1:     ~FileMapAutoCloser() { PR_CloseFileMap(mMap); }
    1:  private:
    1:     PRFileMap *mMap;
    1: };
    1: #endif
    1: 
    1: class JSPrincipalsHolder
    1: {
    1:  public:
    1:     JSPrincipalsHolder(JSContext *cx, JSPrincipals *principals)
    1:         : mCx(cx), mPrincipals(principals) {}
    1:     ~JSPrincipalsHolder() { JSPRINCIPALS_DROP(mCx, mPrincipals); }
    1:  private:
    1:     JSContext *mCx;
    1:     JSPrincipals *mPrincipals;
    1: };
    1: 
    1: class JSScriptHolder
    1: {
    1:  public:
    1:     JSScriptHolder(JSContext *cx, JSScript *script)
    1:         : mCx(cx), mScript(script) {}
    1:     ~JSScriptHolder() { ::JS_DestroyScript(mCx, mScript); }
    1:  private:
    1:     JSContext *mCx;
    1:     JSScript *mScript;
    1: };
    1: 
    1: class FastLoadStateHolder
    1: {
    1:  public:
    1:     explicit FastLoadStateHolder(nsIFastLoadService *service);
    1:     ~FastLoadStateHolder() { pop(); }
    1: 
    1:     void pop();
    1: 
    1:  private:
    1:     nsCOMPtr<nsIFastLoadService> mService;
    1:     nsCOMPtr<nsIFastLoadFileIO> mIO;
    1:     nsCOMPtr<nsIObjectInputStream> mInputStream;
    1:     nsCOMPtr<nsIObjectOutputStream> mOutputStream;
    1: };
    1: 
    1: FastLoadStateHolder::FastLoadStateHolder(nsIFastLoadService *service)
    1: {
    1:     if (!service)
    1:         return;
    1: 
    1:     mService = service;
    1:     service->GetFileIO(getter_AddRefs(mIO));
    1:     service->GetInputStream(getter_AddRefs(mInputStream));
    1:     service->GetOutputStream(getter_AddRefs(mOutputStream));
    1: }
    1: 
    1: void
    1: FastLoadStateHolder::pop()
    1: {
    1:     if (!mService)
    1:         return;
    1: 
    1:     mService->SetFileIO(mIO);
    1:     mService->SetInputStream(mInputStream);
    1:     mService->SetOutputStream(mOutputStream);
    1: 
    1:     mService = nsnull;
    1: }
    1: 
    1: /* static */
    1: void
    1: mozJSComponentLoader::CloseFastLoad(nsITimer *timer, void *closure)
    1: {
 3233:     static_cast<mozJSComponentLoader*>(closure)->CloseFastLoad();
    1: }
    1: 
    1: void
    1: mozJSComponentLoader::CloseFastLoad()
    1: {
    1:     // Close our fastload streams
    1:     LOG(("Closing fastload file\n"));
    1:     if (mFastLoadOutput) {
    1:         nsresult rv = mFastLoadOutput->Close();
    1:         if (NS_SUCCEEDED(rv)) {
    1:             nsCOMPtr<nsIFastLoadService> flSvc = do_GetFastLoadService(&rv);
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 flSvc->CacheChecksum(mFastLoadFile, mFastLoadOutput);
    1:             }
    1:         }
    1:         mFastLoadOutput = nsnull;
    1:     }
    1:     if (mFastLoadInput) {
    1:         mFastLoadInput->Close();
    1:         mFastLoadInput = nsnull;
    1:     }
    1: 
    1:     mFastLoadIO = nsnull;
    1:     mFastLoadTimer = nsnull;
    1: }
    1: 
    1: nsresult
    1: mozJSComponentLoader::StartFastLoad(nsIFastLoadService *flSvc)
    1: {
    1:     if (!mFastLoadFile || !flSvc) {
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1: 
    1:     // Now set our IO object as current, and create our streams.
    1:     if (!mFastLoadIO) {
    1:         mFastLoadIO = new nsXPCFastLoadIO(mFastLoadFile);
    1:         NS_ENSURE_TRUE(mFastLoadIO, NS_ERROR_OUT_OF_MEMORY);
    1:     }
    1: 
    1:     nsresult rv = flSvc->SetFileIO(mFastLoadIO);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (!mFastLoadInput && !mFastLoadOutput) {
    1:         // First time accessing the fastload file
    1:         PRBool exists;
    1:         mFastLoadFile->Exists(&exists);
    1:         if (exists) {
    1:             LOG(("trying to use existing fastload file\n"));
    1: 
33672:             rv = flSvc->NewInputStream(mFastLoadFile, getter_AddRefs(mFastLoadInput));
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 LOG(("opened fastload file for reading\n"));
    1: 
    1:                 nsCOMPtr<nsIFastLoadReadControl>
    1:                     readControl(do_QueryInterface(mFastLoadInput));
    1:                 if (NS_SUCCEEDED(rv)) {
    1:                     /* Get the JS bytecode version number and validate it. */
    1:                     PRUint32 version;
    1:                     rv = mFastLoadInput->Read32(&version);
    1:                     if (NS_SUCCEEDED(rv) && version != JSXDR_BYTECODE_VERSION) {
    1:                         LOG(("Bad JS bytecode version\n"));
    1:                         rv = NS_ERROR_UNEXPECTED;
    1:                     }
    1:                 }
    1:             }
    1:             if (NS_FAILED(rv)) {
    1:                 LOG(("Invalid fastload file detected, removing it\n"));
    1:                 if (mFastLoadInput) {
    1:                     mFastLoadInput->Close();
    1:                     mFastLoadInput = nsnull;
    1:                 } 
    1:                 mFastLoadIO->SetInputStream(nsnull);
    1:                 mFastLoadFile->Remove(PR_FALSE);
    1:                 exists = PR_FALSE;
    1:             }
    1:         }
    1: 
    1:         if (!exists) {
    1:             LOG(("Creating new fastload file\n"));
    1: 
    1:             nsCOMPtr<nsIOutputStream> output;
    1:             rv = mFastLoadIO->GetOutputStream(getter_AddRefs(output));
    1:             NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:             rv = flSvc->NewOutputStream(output,
    1:                                         getter_AddRefs(mFastLoadOutput));
    1: 
    1:             if (NS_SUCCEEDED(rv))
    1:                 rv = mFastLoadOutput->Write32(JSXDR_BYTECODE_VERSION);
    1: 
    1:             if (NS_FAILED(rv)) {
    1:                 LOG(("Fatal error, could not create fastload file\n"));
    1: 
    1:                 if (mFastLoadOutput) {
    1:                     mFastLoadOutput->Close();
    1:                     mFastLoadOutput = nsnull;
    1:                 } else {
    1:                     output->Close();
    1:                 }
    1:                 mFastLoadIO->SetOutputStream(nsnull);
    1:                 mFastLoadFile->Remove(PR_FALSE);
    1:                 return rv;
    1:             }
    1:         }
    1:     }
    1: 
    1:     flSvc->SetInputStream(mFastLoadInput);
    1:     flSvc->SetOutputStream(mFastLoadOutput);
    1: 
    1:     // Start our update timer.  This allows us to keep the stream open
    1:     // when many components are loaded in succession, but close it once
    1:     // there has been a period of inactivity.
    1: 
    1:     if (!mFastLoadTimer) {
    1:         mFastLoadTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:         rv = mFastLoadTimer->InitWithFuncCallback(&mozJSComponentLoader::CloseFastLoad,
    1:                                                   this,
    1:                                                   kFastLoadWriteDelay,
    1:                                                   nsITimer::TYPE_ONE_SHOT);
    1:     } else {
24552:         // Note, that since CloseFastLoad nulls out mFastLoadTimer,
24552:         // SetDelay() will only be called on a timer that hasn't fired.
    1:         rv = mFastLoadTimer->SetDelay(kFastLoadWriteDelay);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: mozJSComponentLoader::ReadScript(nsIFastLoadService *flSvc,
    1:                                  const char *nativePath, nsIURI *uri,
    1:                                  JSContext *cx, JSScript **script)
    1: {
    1:     NS_ASSERTION(flSvc, "fastload not initialized");
    1: 
    1:     nsresult rv = flSvc->StartMuxedDocument(uri, nativePath,
    1:                                             nsIFastLoadService::NS_FASTLOAD_READ);
    1:     if (NS_FAILED(rv)) {
    1:         return rv; // don't warn since NOT_AVAILABLE is an ok error
    1:     }
    1: 
    1:     LOG(("Found %s in fastload file\n", nativePath));
    1: 
    1:     nsCOMPtr<nsIURI> oldURI;
    1:     rv = flSvc->SelectMuxedDocument(uri, getter_AddRefs(oldURI));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     NS_ASSERTION(mFastLoadInput,
    1:                  "FASTLOAD_READ should only succeed with an input stream");
    1: 
    1:     rv = ReadScriptFromStream(cx, mFastLoadInput, script);
    1:     if (NS_SUCCEEDED(rv)) {
    1:         rv = flSvc->EndMuxedDocument(uri);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: mozJSComponentLoader::WriteScript(nsIFastLoadService *flSvc, JSScript *script,
    1:                                   nsIFile *component, const char *nativePath,
    1:                                   nsIURI *uri, JSContext *cx)
    1: {
    1:     NS_ASSERTION(flSvc, "fastload not initialized");
    1:     nsresult rv;
    1: 
    1:     if (!mFastLoadOutput) {
    1:         // Trying to read a URI that was not in the fastload file will have
    1:         // created an output stream for us.  But, if we haven't tried to
    1:         // load anything that was missing, it will still be null.
    1:         rv = flSvc->GetOutputStream(getter_AddRefs(mFastLoadOutput));
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     NS_ASSERTION(mFastLoadOutput, "must have an output stream here");
    1: 
    1:     LOG(("Writing %s to fastload\n", nativePath));
    1:     rv = flSvc->AddDependency(component);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = flSvc->StartMuxedDocument(uri, nativePath,
    1:                                    nsIFastLoadService::NS_FASTLOAD_WRITE);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIURI> oldURI;
    1:     rv = flSvc->SelectMuxedDocument(uri, getter_AddRefs(oldURI));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = WriteScriptToStream(cx, script, mFastLoadOutput);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     return flSvc->EndMuxedDocument(uri);
    1: }
    1: 
    1: nsresult
    1: mozJSComponentLoader::GlobalForLocation(nsILocalFile *aComponent,
    1:                                         JSObject **aGlobal,
16381:                                         char **aLocation,
16381:                                         jsval *exception)
    1: {
    1:     nsresult rv;
    1: 
    1:     JSPrincipals* jsPrincipals = nsnull;
16098:     JSCLContextHelper cx(this);
    1: 
    1: #ifndef XPCONNECT_STANDALONE
    1:     rv = mSystemPrincipal->GetJSPrincipals(cx, &jsPrincipals);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     JSPrincipalsHolder princHolder(mContext, jsPrincipals);
    1: #endif
    1: 
    1:     nsCOMPtr<nsIXPCScriptable> backstagePass;
    1:     rv = mRuntimeService->GetBackstagePass(getter_AddRefs(backstagePass));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     JSCLAutoErrorReporterSetter aers(cx, mozJSLoaderErrorReporter);
    1: 
    1:     nsCOMPtr<nsIXPConnect> xpc =
    1:         do_GetService(kXPConnectServiceContractID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Make sure InitClassesWithNewWrappedGlobal() installs the
    1:     // backstage pass as the global in our compilation context.
    1:     JS_SetGlobalObject(cx, nsnull);
    1: 
    1:     nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
    1:     rv = xpc->InitClassesWithNewWrappedGlobal(cx, backstagePass,
    1:                                               NS_GET_IID(nsISupports),
    1:                                               nsIXPConnect::
    1:                                                   FLAG_SYSTEM_GLOBAL_OBJECT,
    1:                                               getter_AddRefs(holder));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     JSObject *global;
    1:     rv = holder->GetJSObject(&global);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (!JS_DefineFunctions(cx, global, gGlobalFun)) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     nsCOMPtr<nsIXPConnectJSObjectHolder> locationHolder;
    1:     rv = xpc->WrapNative(cx, global, aComponent,
    1:                          NS_GET_IID(nsILocalFile),
    1:                          getter_AddRefs(locationHolder));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     JSObject *locationObj;
    1:     rv = locationHolder->GetJSObject(&locationObj);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (!JS_DefineProperty(cx, global, "__LOCATION__",
    1:                            OBJECT_TO_JSVAL(locationObj), nsnull, nsnull, 0)) {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     nsCAutoString nativePath;
    1:     // Quick hack to unbust XPCONNECT_STANDALONE.
    1:     // This leaves the jsdebugger with a non-URL pathname in the 
    1:     // XPCONNECT_STANDALONE case - but at least it builds and runs otherwise.
    1:     // See: http://bugzilla.mozilla.org/show_bug.cgi?id=121438
    1: #ifdef XPCONNECT_STANDALONE
    1:     localFile->GetNativePath(nativePath);
    1: #else
33501:     NS_GetURLSpecFromActualFile(aComponent, nativePath);
    1: #endif
    1: 
    1:     // Before compiling the script, first check to see if we have it in
    1:     // the fastload file.  Note: as a rule, fastload errors are not fatal
    1:     // to loading the script, since we can always slow-load.
    1:     nsCOMPtr<nsIFastLoadService> flSvc = do_GetFastLoadService(&rv);
    1: 
    1:     // Save the old state and restore it upon return
    1:     FastLoadStateHolder flState(flSvc);
    1:     PRBool fastLoading = PR_FALSE;
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:         rv = StartFastLoad(flSvc);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             fastLoading = PR_TRUE;
    1:         }
    1:     }
    1: 
    1:     nsCOMPtr<nsIURI> uri;
    1:     rv = NS_NewURI(getter_AddRefs(uri), nativePath);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     JSScript *script = nsnull;
    1: 
    1:     if (fastLoading) {
    1:         rv = ReadScript(flSvc, nativePath.get(), uri, cx, &script);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             LOG(("Successfully loaded %s from fastload\n", nativePath.get()));
    1:             fastLoading = PR_FALSE; // no need to write out the script
    1:         } else if (rv == NS_ERROR_NOT_AVAILABLE) {
    1:             // This is ok, it just means the script is not yet in the
    1:             // fastload file.
    1:             rv = NS_OK;
    1:         } else {
    1:             LOG(("Failed to deserialize %s\n", nativePath.get()));
    1: 
    1:             // Remove the fastload file, it may be corrupted.
    1:             LOG(("Invalid fastload file detected, removing it\n"));
    1:             nsCOMPtr<nsIObjectOutputStream> objectOutput;
    1:             flSvc->GetOutputStream(getter_AddRefs(objectOutput));
    1:             if (objectOutput) {
    1:                 flSvc->SetOutputStream(nsnull);
    1:                 objectOutput->Close();
    1:             }
    1:             nsCOMPtr<nsIObjectInputStream> objectInput;
    1:             flSvc->GetInputStream(getter_AddRefs(objectInput));
    1:             if (objectInput) {
    1:                 flSvc->SetInputStream(nsnull);
    1:                 objectInput->Close();
    1:             }
    1:             if (mFastLoadFile) {
    1:                 mFastLoadFile->Remove(PR_FALSE);
    1:             }
    1:             fastLoading = PR_FALSE;
    1:         }
    1:     }
    1: 
    1: 
    1:     if (!script || NS_FAILED(rv)) {
    1:         // The script wasn't in the fastload cache, so compile it now.
    1:         LOG(("Slow loading %s\n", nativePath.get()));
    1: 
16382:         // If |exception| is non-null, then our caller wants us to propagate
16382:         // any exceptions out to our caller. Ensure that the engine doesn't
16381:         // eagerly report the exception.
16381:         uint32 oldopts = 0;
16381:         if (exception) {
16381:             oldopts = JS_GetOptions(cx);
16381:             JS_SetOptions(cx, oldopts | JSOPTION_DONT_REPORT_UNCAUGHT);
16381:         }
16381: 
    1: #ifdef HAVE_PR_MEMMAP
    1:         PRInt64 fileSize;
    1:         rv = aComponent->GetFileSize(&fileSize);
16381:         if (NS_FAILED(rv)) {
16381:             JS_SetOptions(cx, oldopts);
    1:             return rv;
16381:         }
    1: 
    1:         PRInt64 maxSize;
    1:         LL_UI2L(maxSize, PR_UINT32_MAX);
    1:         if (LL_CMP(fileSize, >, maxSize)) {
    1:             NS_ERROR("file too large");
16381:             JS_SetOptions(cx, oldopts);
    1:             return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         PRFileDesc *fileHandle;
    1:         rv = aComponent->OpenNSPRFileDesc(PR_RDONLY, 0, &fileHandle);
16381:         if (NS_FAILED(rv)) {
16381:             JS_SetOptions(cx, oldopts);
16381:             return NS_ERROR_FILE_NOT_FOUND;
16381:         }
    1: 
    1:         // Make sure the file is closed, no matter how we return.
    1:         FileAutoCloser fileCloser(fileHandle);
    1: 
    1:         PRFileMap *map = PR_CreateFileMap(fileHandle, fileSize,
    1:                                           PR_PROT_READONLY);
    1:         if (!map) {
    1:             NS_ERROR("Failed to create file map");
16381:             JS_SetOptions(cx, oldopts);
    1:             return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         // Make sure the file map is closed, no matter how we return.
    1:         FileMapAutoCloser mapCloser(map);
    1: 
    1:         PRUint32 fileSize32;
    1:         LL_L2UI(fileSize32, fileSize);
    1: 
 3233:         char *buf = static_cast<char*>(PR_MemMap(map, 0, fileSize32));
    1:         if (!buf) {
    1:             NS_WARNING("Failed to map file");
16381:             JS_SetOptions(cx, oldopts);
    1:             return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         script = JS_CompileScriptForPrincipals(cx, global,
    1:                                                jsPrincipals,
    1:                                                buf, fileSize32,
11900:                                                nativePath.get(), 1);
    1:         PR_MemUnmap(buf, fileSize32);
    1: 
    1: #else  /* HAVE_PR_MEMMAP */
    1: 
    1:         /**
    1:          * No memmap implementation, so fall back to using
    1:          * JS_CompileFileHandleForPrincipals().
    1:          */
    1: 
    1:         FILE *fileHandle;
    1:         rv = aComponent->OpenANSIFileDesc("r", &fileHandle);
16381:         if (NS_FAILED(rv)) {
16381:             JS_SetOptions(cx, oldopts);
16381:             return NS_ERROR_FILE_NOT_FOUND;
16381:         }
    1: 
    1:         script = JS_CompileFileHandleForPrincipals(cx, global,
    1:                                                    nativePath.get(),
    1:                                                    fileHandle, jsPrincipals);
    1: 
    1:         /* JS will close the filehandle after compilation is complete. */
16381: #endif /* HAVE_PR_MEMMAP */
16363: 
16381:         // Propagate the exception, if one exists. Also, don't leave the stale
16381:         // exception on this context.
16381:         // NB: The caller must stick exception into a rooted slot (probably on
16381:         // its context) as soon as possible to avoid GC hazards.
16381:         if (exception) {
16381:             JS_SetOptions(cx, oldopts);
16381:             if (!script) {
16381:                 JS_GetPendingException(cx, exception);
16381:                 JS_ClearPendingException(cx);
16381:             }
16381:         }
    1:     }
    1: 
    1:     if (!script) {
    1: #ifdef DEBUG_shaver_off
    1:         fprintf(stderr, "mJCL: script compilation of %s FAILED\n",
    1:                 nativePath.get());
    1: #endif
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     // Ensure that we clean up the script on return.
    1:     JSScriptHolder scriptHolder(cx, script);
    1: 
    1:     // Flag this script as a system script
    1:     // FIXME: BUG 346139: We actually want to flag this exact filename, not
    1:     // anything that starts with this filename... Maybe we need a way to do
    1:     // that?  On the other hand, the fact that this is in our components dir
    1:     // means that if someone snuck a malicious file into this dir we're screwed
    1:     // anyway...  So maybe flagging as a prefix is fine.
 9531:     xpc->FlagSystemFilenamePrefix(nativePath.get(), PR_TRUE);
    1: 
    1: #ifdef DEBUG_shaver_off
    1:     fprintf(stderr, "mJCL: compiled JS component %s\n",
    1:             nativePath.get());
    1: #endif
    1: 
    1:     if (fastLoading) {
    1:         // We successfully compiled the script, so cache it in fastload.
    1:         rv = WriteScript(flSvc, script, aComponent, nativePath.get(), uri, cx);
    1: 
    1:         // Don't treat failure to write as fatal, since we might be working
    1:         // with a read-only fastload file.
    1:         if (NS_SUCCEEDED(rv)) {
    1:             LOG(("Successfully wrote to fastload\n"));
    1:         } else {
    1:             LOG(("Failed to write to fastload\n"));
    1:         }
    1:     }
    1: 
    1:     // Restore the old state of the fastload service.
    1:     flState.pop();
    1: 
 2601:     // Assign aGlobal here so that it's available to recursive imports.
 2601:     // See bug 384168.
 2601:     *aGlobal = global;
 2601: 
    1:     jsval retval;
    1:     if (!JS_ExecuteScript(cx, global, script, &retval)) {
    1: #ifdef DEBUG_shaver_off
    1:         fprintf(stderr, "mJCL: failed to execute %s\n", nativePath.get());
    1: #endif
 2601:         *aGlobal = nsnull;
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     /* Freed when we remove from the table. */
    1:     nsCAutoString path;
    1:     aComponent->GetNativePath(path);
    1:     *aLocation = ToNewCString(path);
 2601:     if (!*aLocation) {
 2601:         *aGlobal = nsnull;
    1:         return NS_ERROR_OUT_OF_MEMORY;
 2601:     }
    1: 
    1:     JS_AddNamedRoot(cx, aGlobal, *aLocation);
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: mozJSComponentLoader::UnloadModules()
    1: {
    1:     mInitialized = PR_FALSE;
    1: 
 2601:     mInProgressImports.Clear();
 2601:     mImports.Clear();
    1:     mModules.Clear();
    1: 
    1:     // Destroying our context will force a GC.
    1:     JS_DestroyContext(mContext);
    1:     mContext = nsnull;
    1: 
    1:     mRuntimeService = nsnull;
16098:     mContextStack = nsnull;
    1: #ifdef DEBUG_shaver_off
    1:     fprintf(stderr, "mJCL: UnloadAll(%d)\n", aWhen);
    1: #endif
    1: }
    1: 
 1725: /* [JSObject] import (in AUTF8String registryLocation,
 1725:                       [optional] in JSObject targetObj ); */
 1493: NS_IMETHODIMP
 1493: mozJSComponentLoader::Import(const nsACString & registryLocation)
 1493: {
 1493:     // This function should only be called from JS.
 1493:     nsresult rv;
 1493: 
 1493:     nsCOMPtr<nsIXPConnect> xpc =
 1493:         do_GetService(kXPConnectServiceContractID, &rv);
 1493:     NS_ENSURE_SUCCESS(rv, rv);
 1493:     
10286:     nsAXPCNativeCallContext *cc = nsnull;
10286:     rv = xpc->GetCurrentNativeCallContext(&cc);
 1493:     NS_ENSURE_SUCCESS(rv, rv);
 1493: 
 1493: #ifdef DEBUG
 4515:     {
 1493:     // ensure that we are being call from JS, from this method
 1493:     nsCOMPtr<nsIInterfaceInfo> info;
 1493:     rv = cc->GetCalleeInterface(getter_AddRefs(info));
 1493:     NS_ENSURE_SUCCESS(rv, rv);
 4515:     nsXPIDLCString name;
 4515:     info->GetName(getter_Copies(name));
 4515:     NS_ASSERTION(nsCRT::strcmp("nsIXPCComponents_Utils", name.get()) == 0,
 1493:                  "Components.utils.import must only be called from JS.");
 1493:     PRUint16 methodIndex;
 1493:     const nsXPTMethodInfo *methodInfo;
 1493:     rv = info->GetMethodInfoForName("import", &methodIndex, &methodInfo);
 1493:     NS_ENSURE_SUCCESS(rv, rv);
 1493:     PRUint16 calleeIndex;
 1493:     rv = cc->GetCalleeMethodIndex(&calleeIndex);
 1493:     NS_ASSERTION(calleeIndex == methodIndex,
 1493:                  "Components.utils.import called from another utils method.");
 4515:     }
 1493: #endif
 1493: 
 1493:     JSContext *cx = nsnull;
 1493:     rv = cc->GetJSContext(&cx);
 1493:     NS_ENSURE_SUCCESS(rv, rv);
 1493: 
 6082:     JSAutoRequest ar(cx);
 6082: 
 1493:     JSObject *targetObject = nsnull;
 1493: 
 1493:     PRUint32 argc = 0;
 1493:     rv = cc->GetArgc(&argc);
 1493:     NS_ENSURE_SUCCESS(rv, rv);
 1493: 
 1493:     if (argc > 1) {
 1493:         // The caller passed in the optional second argument. Get it.
 1493:         jsval *argv = nsnull;
 1493:         rv = cc->GetArgvPtr(&argv);
 1493:         NS_ENSURE_SUCCESS(rv, rv);
 3499:         if (!JSVAL_IS_OBJECT(argv[1])) {
 1493:             return ReportOnCaller(cc, ERROR_SCOPE_OBJ,
 1493:                                   PromiseFlatCString(registryLocation).get());
 1493:         }
 3499:         targetObject = JSVAL_TO_OBJECT(argv[1]);
 1493:     } else {
 1493:         // Our targetObject is the caller's global object. Find it by
 1493:         // walking the calling object's parent chain.
 1493: 
 1493:         nsCOMPtr<nsIXPConnectWrappedNative> wn;
 1493:         rv = cc->GetCalleeWrapper(getter_AddRefs(wn));
 1493:         NS_ENSURE_SUCCESS(rv, rv);
 1493:         
 1493:         wn->GetJSObject(&targetObject);
 1493:         if (!targetObject) {
 1493:             NS_ERROR("null calling object");
 1493:             return NS_ERROR_FAILURE;
 1493:         }
 1493: 
10858:         targetObject = JS_GetGlobalForObject(cx, targetObject);
 1493:     }
 1493:  
 1493:     JSObject *globalObj = nsnull;
 1493:     rv = ImportInto(registryLocation, targetObject, cc, &globalObj);
 1493: 
 1493:     jsval *retval = nsnull;
 1493:     cc->GetRetValPtr(&retval);
 1493:     if (*retval)
 1493:         *retval = OBJECT_TO_JSVAL(globalObj);
 1493: 
 1493:     return rv;
 1493: }
 1493: 
 1493: /* [noscript] JSObjectPtr importInto(in AUTF8String registryLocation,
 1493:                                      in JSObjectPtr targetObj); */
 1493: NS_IMETHODIMP
 1493: mozJSComponentLoader::ImportInto(const nsACString & aLocation,
 1493:                                  JSObject * targetObj,
10286:                                  nsAXPCNativeCallContext * cc,
 1493:                                  JSObject * *_retval)
 1493: {
 1493:     nsresult rv;
 8495:     *_retval = nsnull;
 1493: 
 1493:     if (!mInitialized) {
 1493:         rv = ReallyInit();
 1493:         NS_ENSURE_SUCCESS(rv, rv);
 1493:     }
 1493:     
 2226:     nsCOMPtr<nsIIOService> ioService = do_GetIOService(&rv);
 1493:     NS_ENSURE_SUCCESS(rv, rv);
 2226: 
 8495:     // Get the URI.
 2226:     nsCOMPtr<nsIURI> resURI;
 2226:     rv = ioService->NewURI(aLocation, nsnull, nsnull, getter_AddRefs(resURI));
 2226:     nsCOMPtr<nsIFileURL> fileURL = do_QueryInterface(resURI, &rv);
 8495:     // If we don't have a file URL, then the location passed in is invalid.
 8495:     NS_ENSURE_SUCCESS(rv, NS_ERROR_INVALID_ARG);
 2226: 
 2226:     // Get the file belonging to it.
 1493:     nsCOMPtr<nsIFile> file;
 2226:     rv = fileURL->GetFile(getter_AddRefs(file));
 1493:     NS_ENSURE_SUCCESS(rv, rv);
 1493:     nsCOMPtr<nsILocalFile> componentFile = do_QueryInterface(file, &rv);
 1493:     NS_ENSURE_SUCCESS(rv, rv);
 1493: 
 1493:     nsCOMPtr<nsIHashable> lfhash(do_QueryInterface(componentFile));
 1493:     if (!lfhash) {
 1493:         NS_ERROR("nsLocalFile not implementing nsIHashable");
 1493:         return NS_NOINTERFACE;
 1493:     }
 1493: 
 1493:     ModuleEntry* mod;
 1493:     nsAutoPtr<ModuleEntry> newEntry;
 2601:     if (!mImports.Get(lfhash, &mod) && !mInProgressImports.Get(lfhash, &mod)) {
 1493:         newEntry = new ModuleEntry;
 2601:         if (!newEntry || !mInProgressImports.Put(lfhash, newEntry))
 1493:             return NS_ERROR_OUT_OF_MEMORY;
 1493: 
16381:         jsval exception = JSVAL_VOID;
 1493:         rv = GlobalForLocation(componentFile, &newEntry->global,
16381:                                &newEntry->location, &exception);
 2601: 
 2601:         mInProgressImports.Remove(lfhash);
 2601: 
 1493:         if (NS_FAILED(rv)) {
 1493:             *_retval = nsnull;
16381: 
16381:             if (!JSVAL_IS_VOID(exception)) {
16381:                 // An exception was thrown during compilation. Propagate it
16381:                 // out to our caller so they can report it.
16381:                 JSContext *callercx;
16381:                 cc->GetJSContext(&callercx);
16381:                 JS_SetPendingException(callercx, exception);
16381:                 return NS_OK;
16381:             }
16381: 
16381:             // Something failed, but we don't know what it is, guess.
16383:             return NS_ERROR_FILE_NOT_FOUND;
 1493:         }
 1493: 
 1493:         mod = newEntry;
 1493:     }
 1493: 
 1493:     NS_ASSERTION(mod->global, "Import table contains entry with no global");
 1493:     *_retval = mod->global;
 1493: 
 1493:     jsval symbols;
 1493:     if (targetObj) {
25117:         JSCLContextHelper cxhelper(this);
 6082: 
 1493:         if (!JS_GetProperty(mContext, mod->global,
 1493:                             "EXPORTED_SYMBOLS", &symbols)) {
25117:             return ReportOnCaller(cxhelper, ERROR_NOT_PRESENT,
 1493:                                   PromiseFlatCString(aLocation).get());
 1493:         }
 1493: 
 1493:         JSObject *symbolsObj = nsnull;
 1493:         if (!JSVAL_IS_OBJECT(symbols) ||
 1493:             !(symbolsObj = JSVAL_TO_OBJECT(symbols)) ||
 1493:             !JS_IsArrayObject(mContext, symbolsObj)) {
25117:             return ReportOnCaller(cxhelper, ERROR_NOT_AN_ARRAY,
 1493:                                   PromiseFlatCString(aLocation).get());
 1493:         }
 1493: 
 1493:         // Iterate over symbols array, installing symbols on targetObj:
 1493: 
 1493:         jsuint symbolCount = 0;
 1493:         if (!JS_GetArrayLength(mContext, symbolsObj, &symbolCount)) {
25117:             return ReportOnCaller(cxhelper, ERROR_GETTING_ARRAY_LENGTH,
 1493:                                   PromiseFlatCString(aLocation).get());
 1493:         }
 1493: 
 2527: #ifdef DEBUG
 2527:         nsCAutoString logBuffer;
 2527: #endif
 2527: 
 1493:         for (jsuint i = 0; i < symbolCount; ++i) {
 1493:             jsval val;
 1493:             JSString *symbolName;
 1493: 
 1493:             if (!JS_GetElement(mContext, symbolsObj, i, &val) ||
 1493:                 !JSVAL_IS_STRING(val)) {
25117:                 return ReportOnCaller(cxhelper, ERROR_ARRAY_ELEMENT,
 1493:                                       PromiseFlatCString(aLocation).get(), i);
 1493:             }
 1493: 
 1493:             symbolName = JSVAL_TO_STRING(val);
 1493:             if (!JS_GetProperty(mContext, mod->global,
 1493:                                 JS_GetStringBytes(symbolName), &val)) {
25117:                 return ReportOnCaller(cxhelper, ERROR_GETTING_SYMBOL,
 1493:                                       PromiseFlatCString(aLocation).get(),
 1493:                                       JS_GetStringBytes(symbolName));
 1493:             }
 1493: 
 1493:             if (!JS_SetProperty(mContext, targetObj,
 1493:                                 JS_GetStringBytes(symbolName), &val)) {
25117:                 return ReportOnCaller(cxhelper, ERROR_SETTING_SYMBOL,
 1493:                                       PromiseFlatCString(aLocation).get(),
 1493:                                       JS_GetStringBytes(symbolName));
 1493:             }
 1493: #ifdef DEBUG
 1493:             if (i == 0) {
 2527:                 logBuffer.AssignLiteral("Installing symbols [ ");
 1493:             }
 2527:             logBuffer.Append(JS_GetStringBytes(symbolName));
 2527:             logBuffer.AppendLiteral(" ");
 1493:             if (i == symbolCount - 1) {
 2527:                 LOG(("%s] from %s\n", PromiseFlatCString(logBuffer).get(),
 2527:                                       PromiseFlatCString(aLocation).get()));
 1493:             }
 1493: #endif
 1493:         }
 1493:     }
 1493: 
 1493:     // Cache this module for later
 1493:     if (newEntry) {
 1493:         if (!mImports.Put(lfhash, newEntry))
 1493:             return NS_ERROR_OUT_OF_MEMORY;
 1493:         newEntry.forget();
 1493:     }
 1493:     
 1493:     return NS_OK;
 1493: }
 1493: 
    1: NS_IMETHODIMP
    1: mozJSComponentLoader::Observe(nsISupports *subject, const char *topic,
    1:                               const PRUnichar *data)
    1: {
    1:     if (!strcmp(topic, NS_XPCOM_SHUTDOWN_OBSERVER_ID)) {
    1:         if (mFastLoadTimer) {
    1:             mFastLoadTimer->Cancel();
    1:         }
    1: 
    1:         CloseFastLoad();
    1:     }
    1:     else if (!strcmp(topic, "xpcom-shutdown-loaders")) {
    1:         UnloadModules();
    1:     }
    1:     else {
    1:         NS_ERROR("Unexpected observer topic.");
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
16098: JSCLContextHelper::JSCLContextHelper(mozJSComponentLoader *loader)
16098:     : mContext(loader->mContext), mContextThread(0),
16098:       mContextStack(loader->mContextStack)
    1: {
16098:     mContextStack->Push(mContext);
    1:     mContextThread = JS_GetContextThread(mContext);
    1:     if (mContextThread) {
    1:         JS_BeginRequest(mContext);
    1:     } 
    1: }
    1: 
25117: // Pops the context that was pushed and then returns the context that is now at
25117: // the top of the stack.
25117: JSContext*
25117: JSCLContextHelper::Pop()
    1: {
25117:     JSContext* cx = nsnull;
25117:     if (mContextStack) {
    1:         JS_ClearNewbornRoots(mContext);
25117:         if (mContextThread) {
    1:             JS_EndRequest(mContext);
25117:         }
16098: 
16098:         mContextStack->Pop(nsnull);
25117:         mContextStack->Peek(&cx);
25117:         mContextStack = nsnull;
    1:     }
25117:     return cx;
25117: }
