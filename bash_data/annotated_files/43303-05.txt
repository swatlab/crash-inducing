    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsTextServicesDocument_h__
    1: #define nsTextServicesDocument_h__
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsIContent.h"
    1: #include "nsIContentIterator.h"
    1: #include "nsIEditor.h"
    1: #include "nsIEditActionListener.h"
    1: #include "nsITextServicesDocument.h"
27986: #include "nsTArray.h"
    1: #include "nsISelectionController.h"
    1: #include "nsITextServicesFilter.h"
    1: #include "nsWeakReference.h"
43054: #include "nsCycleCollectionParticipant.h"
    1: 
    1: class nsIRangeUtils;
27986: class OffsetEntry;
    1: 
    1: /** implementation of a text services object.
    1:  *
    1:  */
43303: class nsTextServicesDocument : public nsITextServicesDocument,
43303:                                public nsIEditActionListener
    1: {
    1: private:
    1:   static nsIAtom *sAAtom;
    1:   static nsIAtom *sAddressAtom;
    1:   static nsIAtom *sBigAtom;
    1:   static nsIAtom *sBlinkAtom;
    1:   static nsIAtom *sBAtom;
    1:   static nsIAtom *sCiteAtom;
    1:   static nsIAtom *sCodeAtom;
    1:   static nsIAtom *sDfnAtom;
    1:   static nsIAtom *sEmAtom;
    1:   static nsIAtom *sFontAtom;
    1:   static nsIAtom *sIAtom;
    1:   static nsIAtom *sKbdAtom;
    1:   static nsIAtom *sKeygenAtom;
    1:   static nsIAtom *sNobrAtom;
    1:   static nsIAtom *sSAtom;
    1:   static nsIAtom *sSampAtom;
    1:   static nsIAtom *sSmallAtom;
    1:   static nsIAtom *sSpacerAtom;
    1:   static nsIAtom *sSpanAtom;      
    1:   static nsIAtom *sStrikeAtom;
    1:   static nsIAtom *sStrongAtom;
    1:   static nsIAtom *sSubAtom;
    1:   static nsIAtom *sSupAtom;
    1:   static nsIAtom *sTtAtom;
    1:   static nsIAtom *sUAtom;
    1:   static nsIAtom *sVarAtom;
    1:   static nsIAtom *sWbrAtom;
    1: 
    1:   typedef enum { eIsDone=0,        // No iterator (I), or iterator doesn't point to anything valid.
    1:                  eValid,           // I points to first text node (TN) in current block (CB).
    1:                  ePrev,            // No TN in CB, I points to first TN in prev block.
    1:                  eNext             // No TN in CB, I points to first TN in next block.
    1:   } TSDIteratorStatus;
    1: 
    1:   nsCOMPtr<nsIDOMDocument>        mDOMDocument;
    1:   nsCOMPtr<nsISelectionController>mSelCon;
    1:   nsWeakPtr                       mEditor;  // avoid a cycle with the spell checker and editor
    1:   nsCOMPtr<nsIContentIterator>    mIterator;
    1:   TSDIteratorStatus               mIteratorStatus;
    1:   nsCOMPtr<nsIContent>            mPrevTextBlock;
    1:   nsCOMPtr<nsIContent>            mNextTextBlock;
27986:   nsTArray<OffsetEntry*>          mOffsetTable;
    1: 
    1:   PRInt32                         mSelStartIndex;
    1:   PRInt32                         mSelStartOffset;
    1:   PRInt32                         mSelEndIndex;
    1:   PRInt32                         mSelEndOffset;
    1: 
    1:   nsCOMPtr<nsIDOMRange>           mExtent;
    1: 
    1:   nsCOMPtr<nsITextServicesFilter> mTxtSvcFilter;
    1: 
    1:   static nsIRangeUtils* sRangeHelper;
    1: 
    1: public:
    1: 
    1:   /** The default constructor.
    1:    */
    1:   nsTextServicesDocument();
    1: 
    1:   /** The default destructor.
    1:    */
    1:   virtual ~nsTextServicesDocument();
    1: 
    1:   /** To be called at module init
    1:    */
    1:   static void RegisterAtoms();
    1: 
    1:   /** To be called at module shutdown
    1:    */
    1:   static void Shutdown();
    1: 
    1:   /* Macro for AddRef(), Release(), and QueryInterface() */
43054:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
43303:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsTextServicesDocument, nsITextServicesDocument)
    1: 
    1:   /* nsITextServicesDocument method implementations. */
    1:   NS_IMETHOD InitWithEditor(nsIEditor *aEditor);
    1:   NS_IMETHOD GetDocument(nsIDOMDocument **aDoc);
    1:   NS_IMETHOD SetExtent(nsIDOMRange* aDOMRange);
    1:   NS_IMETHOD ExpandRangeToWordBoundaries(nsIDOMRange *aRange);
    1:   NS_IMETHOD SetFilter(nsITextServicesFilter *aFilter);
    1:   NS_IMETHOD GetCurrentTextBlock(nsString *aStr);
    1:   NS_IMETHOD FirstBlock();
    1:   NS_IMETHOD LastSelectedBlock(TSDBlockSelectionStatus *aSelStatus, PRInt32 *aSelOffset, PRInt32 *aSelLength);
    1:   NS_IMETHOD PrevBlock();
    1:   NS_IMETHOD NextBlock();
    1:   NS_IMETHOD IsDone(PRBool *aIsDone);
    1:   NS_IMETHOD SetSelection(PRInt32 aOffset, PRInt32 aLength);
    1:   NS_IMETHOD ScrollSelectionIntoView();
    1:   NS_IMETHOD DeleteSelection();
    1:   NS_IMETHOD InsertText(const nsString *aText);
    1: 
    1:   /* nsIEditActionListener method implementations. */
43303:   NS_IMETHOD WillInsertNode(nsIDOMNode *aNode,
    1:                             nsIDOMNode *aParent,
    1:                             PRInt32      aPosition);
43303:   NS_IMETHOD DidInsertNode(nsIDOMNode *aNode,
43303:                            nsIDOMNode *aParent,
43303:                            PRInt32     aPosition,
43303:                            nsresult    aResult);
43303: 
43303:   NS_IMETHOD WillDeleteNode(nsIDOMNode *aChild);
43303:   NS_IMETHOD DidDeleteNode(nsIDOMNode *aChild, nsresult aResult);
43303: 
43303:   NS_IMETHOD WillSplitNode(nsIDOMNode * aExistingRightNode,
43303:                            PRInt32      aOffset);
43303:   NS_IMETHOD DidSplitNode(nsIDOMNode *aExistingRightNode,
    1:                           PRInt32     aOffset,
43303:                           nsIDOMNode *aNewLeftNode,
43303:                           nsresult    aResult);
43303: 
43303:   NS_IMETHOD WillJoinNodes(nsIDOMNode  *aLeftNode,
    1:                            nsIDOMNode  *aRightNode,
    1:                            nsIDOMNode  *aParent);
43303:   NS_IMETHOD DidJoinNodes(nsIDOMNode  *aLeftNode,
43303:                           nsIDOMNode  *aRightNode,
43303:                           nsIDOMNode  *aParent,
43303:                           nsresult     aResult);
43303:   // these listen methods are unused:
43303:   NS_IMETHOD WillCreateNode(const nsAString& aTag, nsIDOMNode *aParent, PRInt32 aPosition);
43303:   NS_IMETHOD DidCreateNode(const nsAString& aTag, nsIDOMNode *aNode, nsIDOMNode *aParent, PRInt32 aPosition, nsresult aResult);
43303:   NS_IMETHOD WillInsertText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, const nsAString &aString);
43303:   NS_IMETHOD DidInsertText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, const nsAString &aString, nsresult aResult);
43303:   NS_IMETHOD WillDeleteText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, PRInt32 aLength);
43303:   NS_IMETHOD DidDeleteText(nsIDOMCharacterData *aTextNode, PRInt32 aOffset, PRInt32 aLength, nsresult aResult);
43303:   NS_IMETHOD WillDeleteSelection(nsISelection *aSelection);
43303:   NS_IMETHOD DidDeleteSelection(nsISelection *aSelection);
    1: 
    1:   /* Helper functions */
    1:   static nsresult ComparePoints(nsIDOMNode *aParent1, PRInt32 aOffset1, nsIDOMNode *aParent2, PRInt32 aOffset2, PRInt32 *aResult);
    1:   static nsresult GetRangeEndPoints(nsIDOMRange *aRange, nsIDOMNode **aParent1, PRInt32 *aOffset1, nsIDOMNode **aParent2, PRInt32 *aOffset2);
    1:   static nsresult CreateRange(nsIDOMNode *aStartParent, PRInt32 aStartOffset, nsIDOMNode *aEndParent, PRInt32 aEndOffset, nsIDOMRange **aRange);
    1: 
    1: private:
    1:   /* nsTextServicesDocument private methods. */
    1: 
    1:   nsresult CreateContentIterator(nsIDOMRange *aRange, nsIContentIterator **aIterator);
    1: 
    1:   nsresult GetDocumentContentRootNode(nsIDOMNode **aNode);
    1:   nsresult CreateDocumentContentRange(nsIDOMRange **aRange);
    1:   nsresult CreateDocumentContentRootToNodeOffsetRange(nsIDOMNode *aParent, PRInt32 aOffset, PRBool aToStart, nsIDOMRange **aRange);
    1:   nsresult CreateDocumentContentIterator(nsIContentIterator **aIterator);
    1: 
    1:   nsresult AdjustContentIterator();
    1: 
    1:   static nsresult FirstTextNode(nsIContentIterator *aIterator, TSDIteratorStatus *IteratorStatus);
    1:   static nsresult LastTextNode(nsIContentIterator *aIterator, TSDIteratorStatus *IteratorStatus);
    1: 
    1:   static nsresult FirstTextNodeInCurrentBlock(nsIContentIterator *aIterator);
    1:   static nsresult FirstTextNodeInPrevBlock(nsIContentIterator *aIterator);
    1:   static nsresult FirstTextNodeInNextBlock(nsIContentIterator *aIterator);
    1: 
    1:   nsresult GetFirstTextNodeInPrevBlock(nsIContent **aContent);
    1:   nsresult GetFirstTextNodeInNextBlock(nsIContent **aContent);
    1: 
    1:   static PRBool IsBlockNode(nsIContent *aContent);
    1:   static PRBool IsTextNode(nsIContent *aContent);
    1:   static PRBool IsTextNode(nsIDOMNode *aNode);
    1: 
    1:   static PRBool DidSkip(nsIContentIterator* aFilteredIter);
    1:   static void   ClearDidSkip(nsIContentIterator* aFilteredIter);
    1: 
    1:   static PRBool HasSameBlockNodeParent(nsIContent *aContent1, nsIContent *aContent2);
    1: 
    1:   nsresult SetSelectionInternal(PRInt32 aOffset, PRInt32 aLength, PRBool aDoUpdate);
    1:   nsresult GetSelection(TSDBlockSelectionStatus *aSelStatus, PRInt32 *aSelOffset, PRInt32 *aSelLength);
    1:   nsresult GetCollapsedSelection(TSDBlockSelectionStatus *aSelStatus, PRInt32 *aSelOffset, PRInt32 *aSelLength);
    1:   nsresult GetUncollapsedSelection(TSDBlockSelectionStatus *aSelStatus, PRInt32 *aSelOffset, PRInt32 *aSelLength);
    1: 
    1:   PRBool SelectionIsCollapsed();
    1:   PRBool SelectionIsValid();
    1: 
27986:   static nsresult CreateOffsetTable(nsTArray<OffsetEntry*> *aOffsetTable,
    1:                              nsIContentIterator *aIterator,
    1:                              TSDIteratorStatus *aIteratorStatus,
    1:                              nsIDOMRange *aIterRange,
    1:                              nsString *aStr);
27986:   static nsresult ClearOffsetTable(nsTArray<OffsetEntry*> *aOffsetTable);
    1: 
27986:   static nsresult NodeHasOffsetEntry(nsTArray<OffsetEntry*> *aOffsetTable,
    1:                                      nsIDOMNode *aNode,
    1:                                      PRBool *aHasEntry,
    1:                                      PRInt32 *aEntryIndex);
    1: 
    1:   nsresult RemoveInvalidOffsetEntries();
    1:   nsresult SplitOffsetEntry(PRInt32 aTableIndex, PRInt32 aOffsetIntoEntry);
    1: 
27986:   static nsresult FindWordBounds(nsTArray<OffsetEntry*> *offsetTable,
27986:                                  nsString *blockStr,
    1:                                  nsIDOMNode *aNode, PRInt32 aNodeOffset,
    1:                                  nsIDOMNode **aWordStartNode,
    1:                                  PRInt32 *aWordStartOffset,
    1:                                  nsIDOMNode **aWordEndNode,
    1:                                  PRInt32 *aWordEndOffset);
    1: 
    1: #ifdef DEBUG_kin
    1:   void PrintOffsetTable();
    1:   void PrintContentNode(nsIContent *aContent);
    1: #endif
    1: };
    1: 
    1: #endif // nsTextServicesDocument_h__
