52560: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
52560:  * vim: set ts=4 sw=4 et tw=99:
52560:  *
52560:  * ***** BEGIN LICENSE BLOCK *****
52560:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
52560:  *
52560:  * The contents of this file are subject to the Mozilla Public License Version
52560:  * 1.1 (the "License"); you may not use this file except in compliance with
52560:  * the License. You may obtain a copy of the License at
52560:  * http://www.mozilla.org/MPL/
52560:  *
52560:  * Software distributed under the License is distributed on an "AS IS" basis,
52560:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
52560:  * for the specific language governing rights and limitations under the
52560:  * License.
52560:  *
52560:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
52560:  * May 28, 2008.
52560:  *
52560:  * The Initial Developer of the Original Code is
52560:  *   Brendan Eich <brendan@mozilla.org>
52560:  *
52560:  * Contributor(s):
52560:  *   David Anderson <danderson@mozilla.com>
52560:  *
52560:  * Alternatively, the contents of this file may be used under the terms of
52560:  * either of the GNU General Public License Version 2 or later (the "GPL"),
52560:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
52560:  * in which case the provisions of the GPL or the LGPL are applicable instead
52560:  * of those above. If you wish to allow use of your version of this file only
52560:  * under the terms of either the GPL or the LGPL, and not to allow others to
52560:  * use your version of this file under the terms of the MPL, indicate your
52560:  * decision by deleting the provisions above and replace them with the notice
52560:  * and other provisions required by the GPL or the LGPL. If you do not delete
52560:  * the provisions above, a recipient may use your version of this file under
52560:  * the terms of any one of the MPL, the GPL or the LGPL.
52560:  *
52560:  * ***** END LICENSE BLOCK ***** */
53269: 
52618: #if !defined jsjaeger_framestate_inl_h__ && defined JS_METHODJIT
52618: #define jsjaeger_framestate_inl_h__
52560: 
77343: #include "methodjit/LoopState.h"
77343: 
52618: namespace js {
52618: namespace mjit {
52560: 
54719: inline void
54719: FrameState::addToTracker(FrameEntry *fe)
52617: {
54719:     JS_ASSERT(!fe->isTracked());
76019:     fe->track(tracker.nentries);
76019:     tracker.add(fe);
52617: }
52617: 
52618: inline FrameEntry *
52617: FrameState::peek(int32 depth)
52617: {
52617:     JS_ASSERT(depth < 0);
77343:     JS_ASSERT(a->sp + depth >= a->spBase);
77343:     FrameEntry *fe = a->sp + depth;
54719:     if (!fe->isTracked()) {
54719:         addToTracker(fe);
52617:         fe->resetSynced();
52617:     }
52617:     return fe;
52617: }
52617: 
52618: inline void
52617: FrameState::popn(uint32 n)
52617: {
52617:     for (uint32 i = 0; i < n; i++)
52617:         pop();
52617: }
52617: 
53115: inline bool
53115: FrameState::haveSameBacking(FrameEntry *lhs, FrameEntry *rhs)
53115: {
53240:     if (lhs->isCopy())
53240:         lhs = lhs->copyOf();
53240:     if (rhs->isCopy())
53240:         rhs = rhs->copyOf();
53240:     return lhs == rhs;
53115: }
53115: 
77343: inline FrameEntry *
77343: FrameState::getTemporary(uint32 which)
52617: {
77343:     JS_ASSERT(which < TEMPORARY_LIMIT);
77343: 
77343:     FrameEntry *fe = temporaries + which;
77343:     JS_ASSERT(fe < temporariesTop);
77343: 
77343:     return getOrTrack(uint32(fe - entries));
54719: }
54719: 
77343: inline AnyRegisterID
77343: FrameState::allocReg(uint32 mask)
77343: {
77343:     if (freeRegs.hasRegInMask(mask)) {
77343:         AnyRegisterID reg = freeRegs.takeAnyReg(mask);
77343:         modifyReg(reg);
77343:         return reg;
77343:     }
77343: 
77343:     AnyRegisterID reg = evictSomeReg(mask);
77343:     modifyReg(reg);
52827:     return reg;
52617: }
52617: 
52618: inline JSC::MacroAssembler::RegisterID
77343: FrameState::allocReg()
52653: {
77343:     return allocReg(Registers::AvailRegs).reg();
54719: }
54719: 
77343: inline JSC::MacroAssembler::FPRegisterID
77343: FrameState::allocFPReg()
77343: {
77343:     return allocReg(Registers::AvailFPRegs).fpreg();
77343: }
77343: 
77343: inline AnyRegisterID
77343: FrameState::allocAndLoadReg(FrameEntry *fe, bool fp, RematInfo::RematType type)
77343: {
77343:     AnyRegisterID reg;
77343:     uint32 mask = fp ? (uint32) Registers::AvailFPRegs : (uint32) Registers::AvailRegs;
77343: 
77343:     /*
77343:      * Decide whether to retroactively mark a register as holding the entry
77343:      * at the start of the current loop. We can do this if (a) the register has
77343:      * not been touched since the start of the loop (it is in loopRegs), (b)
77343:      * the entry has also not been written to or already had a loop register
77343:      * assigned, and (c) we are not in an inline call with multiple callees or
77343:      * exit points --- we won't pick up the new loop register when restoring.
77343:      */
77343:     if (loop && freeRegs.hasRegInMask(loop->getLoopRegs() & mask) &&
77343:         type == RematInfo::DATA && isOuterSlot(fe) && !cc.activeFrameHasMultipleExits() &&
77343:         fe->lastLoop < loop->headOffset()) {
77343:         reg = freeRegs.takeAnyReg(loop->getLoopRegs() & mask);
77343:         regstate(reg).associate(fe, RematInfo::DATA);
77343:         fe->lastLoop = loop->headOffset();
77343:         loop->setLoopReg(reg, fe);
52653:         return reg;
52653:     }
52653: 
77343:     if (!freeRegs.empty(mask))
77343:         reg = freeRegs.takeAnyReg(mask);
77343:     else
77343:         reg = evictSomeReg(mask);
77343:     modifyReg(reg);
77343: 
77343:     if (fp)
77343:         masm.loadDouble(addressOf(fe), reg.fpreg());
77343:     else if (type == RematInfo::TYPE)
77343:         masm.loadTypeTag(addressOf(fe), reg.reg());
77343:     else
77343:         masm.loadPayload(addressOf(fe), reg.reg());
77343: 
77343:     regstate(reg).associate(fe, type);
77343:     return reg;
54719: }
54719: 
77343: inline void
77343: FrameState::modifyReg(AnyRegisterID reg)
77343: {
77343:     if (loop)
77343:         loop->clearLoopReg(reg);
52617: }
52617: 
52618: inline void
52962: FrameState::convertInt32ToDouble(Assembler &masm, FrameEntry *fe, FPRegisterID fpreg) const
52962: {
52962:     JS_ASSERT(!fe->isConstant());
52962: 
52962:     if (fe->isCopy())
52962:         fe = fe->copyOf();
52962:     
52962:     if (fe->data.inRegister())
52962:         masm.convertInt32ToDouble(fe->data.reg(), fpreg);
52962:     else
68931:         masm.convertInt32ToDouble(masm.payloadOf(addressOf(fe)), fpreg);
52962: }
52962: 
52962: inline bool
52962: FrameState::peekTypeInRegister(FrameEntry *fe) const
52962: {
52962:     if (fe->isCopy())
52962:         fe = fe->copyOf();
52962:     return fe->type.inRegister();
52962: }
52962: 
52962: inline void
52617: FrameState::pop()
52578: {
77343:     JS_ASSERT(a->sp > a->spBase);
52578: 
77343:     FrameEntry *fe = --a->sp;
54719:     if (!fe->isTracked())
52617:         return;
52578: 
52846:     forgetAllRegs(fe);
77343:     fe->type.invalidate();
77343:     fe->data.invalidate();
77343:     fe->clear();
77343: 
77343:     extraArray[fe - entries].reset();
52578: }
52578: 
52618: inline void
77343: FrameState::freeReg(AnyRegisterID reg)
52599: {
77343:     JS_ASSERT(!regstate(reg).usedBy());
54719: 
76019:     freeRegs.putReg(reg);
52599: }
52617: 
52618: inline void
77343: FrameState::forgetReg(AnyRegisterID reg)
52617: {
53181:     /*
53181:      * Important: Do not touch the fe here. We can peephole optimize away
53181:      * loads and stores by re-using the contents of old FEs.
53181:      */
77343:     JS_ASSERT_IF(regstate(reg).fe(), !regstate(reg).fe()->isCopy());
54719: 
77343:     if (!regstate(reg).isPinned()) {
77343:         regstate(reg).forget();
76019:         freeRegs.putReg(reg);
52599:     }
54719: }
52617: 
52618: inline FrameEntry *
52617: FrameState::rawPush()
52617: {
77343:     JS_ASSERT(a->sp < temporaries);
77343:     FrameEntry *fe = a->sp++;
52909: 
77343:     if (!fe->isTracked())
77343:         addToTracker(fe);
77343:     fe->type.invalidate();
77343:     fe->data.invalidate();
77343:     fe->clear();
63240: 
77343:     extraArray[fe - entries].reset();
77343: 
77343:     return fe;
52617: }
52617: 
52618: inline void
52617: FrameState::push(const Value &v)
52617: {
52617:     FrameEntry *fe = rawPush();
78614:     fe->setConstant(v);
52617: }
52617: 
52618: inline void
77343: FrameState::pushSynced(JSValueType type)
52617: {
52617:     FrameEntry *fe = rawPush();
52617: 
52771:     fe->resetSynced();
77343:     if (type != JSVAL_TYPE_UNKNOWN) {
53025:         fe->setType(type);
77343:         if (type == JSVAL_TYPE_DOUBLE)
77343:             masm.ensureInMemoryDouble(addressOf(fe));
77343:     }
52611: }
52611: 
52618: inline void
53025: FrameState::pushSynced(JSValueType type, RegisterID reg)
52719: {
52719:     FrameEntry *fe = rawPush();
52719: 
52719:     fe->resetUnsynced();
52719:     fe->type.sync();
52719:     fe->data.sync();
53025:     fe->setType(type);
52719:     fe->data.setRegister(reg);
77343:     regstate(reg).associate(fe, RematInfo::DATA);
52719: }
52719: 
52719: inline void
77343: FrameState::loadIntoRegisters(Address address, bool reuseBase,
77343:                               RegisterID *ptypeReg, RegisterID *pdataReg)
52611: {
77343: 
56231: #ifdef JS_PUNBOX64
77343: 
56231:     // It's okay if either of these clobbers address.base, since we guarantee
56231:     // eviction will not physically clobber. It's also safe, on x64, for
56231:     // loadValueAsComponents() to take either type or data regs as address.base.
56231:     RegisterID typeReg = allocReg();
77343:     RegisterID dataReg = reuseBase ? address.base : allocReg();
56231:     masm.loadValueAsComponents(address, typeReg, dataReg);
77343: 
56231: #elif JS_NUNBOX32
77343: 
56231:     // Prevent us from clobbering this reg.
76019:     bool free = freeRegs.hasReg(address.base);
77343:     bool needsPin = !free && regstate(address.base).fe();
52622:     if (free)
76019:         freeRegs.takeReg(address.base);
77343:     if (needsPin)
77343:         pinReg(address.base);
52622: 
56231:     RegisterID typeReg = allocReg();
52617: 
56231:     masm.loadTypeTag(address, typeReg);
56231: 
56231:     // Allow re-use of the base register. This could avoid a spill, and
56231:     // is safe because the following allocReg() won't actually emit any
56231:     // writes to the register.
52622:     if (free)
76019:         freeRegs.putReg(address.base);
77343:     if (needsPin)
77343:         unpinReg(address.base);
52622: 
77343:     RegisterID dataReg = reuseBase ? address.base : allocReg();
56231:     masm.loadPayload(address, dataReg);
77343: 
56231: #endif
56231: 
77343:     *ptypeReg = typeReg;
77343:     *pdataReg = dataReg;
76087: }
76087: 
76087: inline void
77343: FrameState::push(Address address, JSValueType knownType, bool reuseBase)
76087: {
77343:     if (knownType == JSVAL_TYPE_DOUBLE) {
77343:         FPRegisterID fpreg = allocFPReg();
77343:         masm.moveInt32OrDouble(address, fpreg);
77343:         pushDouble(fpreg);
77343:         if (reuseBase)
77343:             freeReg(address.base);
77343:         return;
77343:     }
77343: 
77343:     if (knownType != JSVAL_TYPE_UNKNOWN) {
77343:         RegisterID dataReg = reuseBase ? address.base : allocReg();
77343:         masm.loadPayload(address, dataReg);
77343:         pushTypedPayload(knownType, dataReg);
77343:         return;
77343:     }
77343: 
77343:     RegisterID typeReg, dataReg;
77343:     loadIntoRegisters(address, reuseBase, &typeReg, &dataReg);
77343: 
77343:     pushRegs(typeReg, dataReg, JSVAL_TYPE_UNKNOWN);
77343: }
77343: 
77435: inline void
77435: FrameState::pushWord(Address address, JSValueType knownType, bool reuseBase)
77435: {
77435:     JS_ASSERT(knownType != JSVAL_TYPE_DOUBLE);
77435:     JS_ASSERT(knownType != JSVAL_TYPE_UNKNOWN);
77435: 
77435:     RegisterID dataReg = reuseBase ? address.base : allocReg();
77435:     masm.loadPtr(address, dataReg);
77435:     pushTypedPayload(knownType, dataReg);
77435: }
77435: 
77343: inline JSC::MacroAssembler::FPRegisterID
77343: FrameState::storeRegs(int32 depth, RegisterID type, RegisterID data, JSValueType knownType)
77343: {
77343:     FrameEntry *fe = peek(depth);
77343:     forgetEntry(fe);
77343:     fe->resetUnsynced();
77343: 
77343:     /*
77343:      * Even if the type or data gets freed due to knownType or a double result,
77343:      * neither register should be clobbered (see Compiler::testBarrier).
77343:      */
76019:     JS_ASSERT(!freeRegs.hasReg(type) && !freeRegs.hasReg(data));
68931: 
77343:     if (knownType == JSVAL_TYPE_UNKNOWN) {
68931:         fe->type.setRegister(type);
68931:         fe->data.setRegister(data);
77343:         regstate(type).associate(fe, RematInfo::TYPE);
77343:         regstate(data).associate(fe, RematInfo::DATA);
77343:         return Registers::FPConversionTemp;
77343:     }
77343: 
77343:     if (knownType == JSVAL_TYPE_DOUBLE) {
77343:         FPRegisterID fpreg = allocFPReg();
77343:         masm.moveInt32OrDouble(data, type, addressOf(fe), fpreg);
77343:         fe->setType(JSVAL_TYPE_DOUBLE);
77343:         fe->data.setFPRegister(fpreg);
77343:         regstate(fpreg).associate(fe, RematInfo::DATA);
77343:         freeReg(type);
77343:         freeReg(data);
77343:         return fpreg;
77343:     }
77343: 
77343:     freeReg(type);
77343:     fe->setType(knownType);
77343:     fe->data.setRegister(data);
77343:     regstate(data).associate(fe, RematInfo::DATA);
77343:     return Registers::FPConversionTemp;
77343: }
77343: 
77343: inline JSC::MacroAssembler::FPRegisterID
77343: FrameState::pushRegs(RegisterID type, RegisterID data, JSValueType knownType)
77343: {
77343:     pushSynced(JSVAL_TYPE_UNKNOWN);
77343:     return storeRegs(-1, type, data, knownType);
77343: }
77343: 
77343: inline void
77343: FrameState::reloadEntry(Assembler &masm, Address address, FrameEntry *fe)
77343: {
77343:     if (fe->data.inRegister()) {
77343:         if (fe->type.inRegister()) {
77343:             masm.loadValueAsComponents(address, fe->type.reg(), fe->data.reg());
77343:         } else {
77343:             JS_ASSERT(fe->isTypeKnown());
77343:             masm.loadPayload(address, fe->data.reg());
77343:         }
77343:     } else {
77343:         JS_ASSERT(fe->data.inFPRegister());
77343:         masm.moveInt32OrDouble(address, fe->data.fpreg());
77343:     }
52831: }
52831: 
52831: inline void
53025: FrameState::pushTypedPayload(JSValueType type, RegisterID payload)
52599: {
77343:     JS_ASSERT(type != JSVAL_TYPE_DOUBLE);
76019:     JS_ASSERT(!freeRegs.hasReg(payload));
52617: 
52617:     FrameEntry *fe = rawPush();
52617: 
52617:     fe->resetUnsynced();
53025:     fe->setType(type);
52617:     fe->data.setRegister(payload);
77343:     regstate(payload).associate(fe, RematInfo::DATA);
52599: }
52599: 
52623: inline void
77343: FrameState::pushNumber(RegisterID payload, bool asInt32)
53153: {
77343:     JS_ASSERT(!freeRegs.hasReg(payload));
53153: 
53153:     FrameEntry *fe = rawPush();
53153: 
53181:     if (asInt32) {
53181:         if (!fe->type.synced())
53181:             masm.storeTypeTag(ImmType(JSVAL_TYPE_INT32), addressOf(fe));
53153:         fe->type.setMemory();
53181:     } else {
53181:         fe->type.setMemory();
53181:     }
53181: 
53153:     fe->data.unsync();
77343:     fe->data.setRegister(payload);
77343:     regstate(payload).associate(fe, RematInfo::DATA);
53153: }
53153: 
53153: inline void
53200: FrameState::pushInt32(RegisterID payload)
53200: {
53200:     FrameEntry *fe = rawPush();
53200: 
53200:     masm.storeTypeTag(ImmType(JSVAL_TYPE_INT32), addressOf(fe));
53200:     fe->type.setMemory();
53200: 
53200:     fe->data.unsync();
53200:     fe->data.setRegister(payload);
77343:     regstate(payload).associate(fe, RematInfo::DATA);
58056: }
58056: 
58056: inline void
53181: FrameState::pushUntypedPayload(JSValueType type, RegisterID payload)
52623: {
76019:     JS_ASSERT(!freeRegs.hasReg(payload));
52623: 
52623:     FrameEntry *fe = rawPush();
52623: 
53025:     masm.storeTypeTag(ImmType(type), addressOf(fe));
52960: 
52623:     /* The forceful type sync will assert otherwise. */
52623: #ifdef DEBUG
52623:     fe->type.unsync();
52623: #endif
52803:     fe->type.setMemory();
52623:     fe->data.unsync();
52623:     fe->data.setRegister(payload);
77343:     regstate(payload).associate(fe, RematInfo::DATA);
52623: }
52623: 
63236: inline void
63236: FrameState::pushUntypedValue(const Value &v)
63236: {
63236:     FrameEntry *fe = rawPush();
63236: 
63236:     masm.storeValue(v, addressOf(fe));
63236: 
63236:     /* The forceful type sync will assert otherwise. */
63236: #ifdef DEBUG
63236:     fe->type.unsync();
63236: #endif
63236:     fe->type.setMemory();
63236:     fe->data.unsync();
63236:     fe->data.setMemory();
63236: }
63236: 
52618: inline JSC::MacroAssembler::RegisterID
53137: FrameState::tempRegForType(FrameEntry *fe, RegisterID fallback)
53137: {
77343:     JS_ASSERT(!regstate(fallback).fe());
53137:     if (fe->isCopy())
53137:         fe = fe->copyOf();
53137: 
53137:     JS_ASSERT(!fe->type.isConstant());
53137: 
53137:     if (fe->type.inRegister())
53137:         return fe->type.reg();
53137: 
53137:     /* :XXX: X86 */
53137: 
53137:     masm.loadTypeTag(addressOf(fe), fallback);
53137:     return fallback;
53137: }
53137: 
53137: 
53137: inline JSC::MacroAssembler::RegisterID
52962: FrameState::tempRegForType(FrameEntry *fe)
52962: {
52962:     if (fe->isCopy())
52962:         fe = fe->copyOf();
52962: 
53014:     JS_ASSERT(!fe->type.isConstant());
53014: 
52962:     if (fe->type.inRegister())
52962:         return fe->type.reg();
52962: 
52962:     /* :XXX: X86 */
52962: 
77343:     RegisterID reg = allocAndLoadReg(fe, false, RematInfo::TYPE).reg();
52624:     fe->type.setRegister(reg);
52617:     return reg;
52608: }
52608: 
52620: inline JSC::MacroAssembler::RegisterID
52620: FrameState::tempRegForData(FrameEntry *fe)
52620: {
77343:     JS_ASSERT(!fe->isConstant());
77343:     JS_ASSERT(!fe->isType(JSVAL_TYPE_DOUBLE));
52620: 
52670:     if (fe->isCopy())
52705:         fe = fe->copyOf();
52670: 
52620:     if (fe->data.inRegister())
52620:         return fe->data.reg();
52620: 
77343:     RegisterID reg = allocAndLoadReg(fe, false, RematInfo::DATA).reg();
52624:     fe->data.setRegister(reg);
52620:     return reg;
52620: }
52620: 
77343: inline void
77343: FrameState::forgetMismatchedObject(FrameEntry *fe)
52685: {
77343:     if (fe->isNotType(JSVAL_TYPE_OBJECT)) {
77343:         if (fe->isCopied()) {
77343:             syncFe(fe);
77343:             uncopy(fe);
77343:             fe->resetSynced();
77343:         } else {
77343:             syncAndForgetFe(fe);
77343:         }
77343:         fe->clear();
77343:     }
77343: 
77343:     if (fe->isConstant()) {
77343:         RegisterID reg = allocReg();
77343:         regstate(reg).associate(fe, RematInfo::DATA);
77343: 
77343:         masm.move(JSC::MacroAssembler::ImmPtr(&fe->getValue().toObject()), reg);
77343:         fe->data.setRegister(reg);
77343:     }
77343: }
77343: 
77343: inline JSC::MacroAssembler::FPRegisterID
77343: FrameState::tempFPRegForData(FrameEntry *fe)
77343: {
77343:     JS_ASSERT(!fe->isConstant());
77343:     JS_ASSERT(fe->isType(JSVAL_TYPE_DOUBLE));
52685: 
52685:     if (fe->isCopy())
52705:         fe = fe->copyOf();
52685: 
77343:     JS_ASSERT(!fe->data.inRegister());
77343: 
77343:     if (fe->data.inFPRegister())
77343:         return fe->data.fpreg();
77343: 
77343:     FPRegisterID reg = allocAndLoadReg(fe, true, RematInfo::DATA).fpreg();
77343:     fe->data.setFPRegister(reg);
77343:     return reg;
77343: }
77343: 
77343: inline AnyRegisterID
77343: FrameState::tempRegInMaskForData(FrameEntry *fe, uint32 mask)
77343: {
77343:     JS_ASSERT(!fe->isConstant());
77343:     JS_ASSERT_IF(fe->isType(JSVAL_TYPE_DOUBLE), !(mask & ~Registers::AvailFPRegs));
77343:     JS_ASSERT_IF(!fe->isType(JSVAL_TYPE_DOUBLE), !(mask & ~Registers::AvailRegs));
77343: 
77343:     if (fe->isCopy())
77343:         fe = fe->copyOf();
77343: 
77343:     AnyRegisterID reg;
77343:     if (fe->data.inRegister() || fe->data.inFPRegister()) {
77343:         AnyRegisterID old;
77343:         if (fe->data.inRegister())
77343:             old = fe->data.reg();
77343:         else
77343:             old = fe->data.fpreg();
53156:         if (Registers::maskReg(old) & mask)
53156:             return old;
52685: 
52685:         /* Keep the old register pinned. */
77343:         regstate(old).forget();
53156:         reg = allocReg(mask);
77343:         if (reg.isReg())
77343:             masm.move(old.reg(), reg.reg());
77343:         else
77343:             masm.moveDouble(old.fpreg(), reg.fpreg());
52685:         freeReg(old);
52685:     } else {
53156:         reg = allocReg(mask);
77343:         if (reg.isReg())
77343:             masm.loadPayload(addressOf(fe), reg.reg());
77343:         else
77343:             masm.loadDouble(addressOf(fe), reg.fpreg());
52685:     }
77343:     regstate(reg).associate(fe, RematInfo::DATA);
77343:     if (reg.isReg())
77343:         fe->data.setRegister(reg.reg());
77343:     else
77343:         fe->data.setFPRegister(reg.fpreg());
52685:     return reg;
52685: }
52685: 
53228: inline JSC::MacroAssembler::RegisterID
53228: FrameState::tempRegForData(FrameEntry *fe, RegisterID reg, Assembler &masm) const
53228: {
53228:     JS_ASSERT(!fe->data.isConstant());
53228: 
53228:     if (fe->isCopy())
53228:         fe = fe->copyOf();
53228: 
77343:     JS_ASSERT(!fe->data.inFPRegister());
77343: 
53228:     if (fe->data.inRegister()) {
53228:         JS_ASSERT(fe->data.reg() != reg);
53228:         return fe->data.reg();
53228:     } else {
53228:         masm.loadPayload(addressOf(fe), reg);
53228:         return reg;
53228:     }
53228: }
53228: 
52623: inline bool
52623: FrameState::shouldAvoidTypeRemat(FrameEntry *fe)
52620: {
77343:     return !fe->isCopy() && fe->type.inMemory();
52620: }
52620: 
52620: inline bool
52620: FrameState::shouldAvoidDataRemat(FrameEntry *fe)
52620: {
77343:     return !fe->isCopy() && fe->data.inMemory();
52620: }
52620: 
52618: inline void
56004: FrameState::ensureFeSynced(const FrameEntry *fe, Assembler &masm) const
52608: {
56004:     Address to = addressOf(fe);
56004:     const FrameEntry *backing = fe;
56004:     if (fe->isCopy())
56004:         backing = fe->copyOf();
52617: 
77343:     if (backing->isType(JSVAL_TYPE_DOUBLE)) {
77343:         if (fe->data.synced()) {
77343:             /* Entries representing known doubles can't be partially synced. */
77343:             JS_ASSERT(fe->type.synced());
77343:             return;
77343:         }
77343:         if (backing->isConstant()) {
77343:             masm.storeValue(backing->getValue(), to);
77343:         } else if (backing->data.inFPRegister()) {
77343:             masm.storeDouble(backing->data.fpreg(), to);
77343:         } else {
77343:             /* Use a temporary so the entry can be synced without allocating a register. */
77343:             JS_ASSERT(backing->data.inMemory() && backing != fe);
77343:             masm.loadDouble(addressOf(backing), Registers::FPConversionTemp);
77343:             masm.storeDouble(Registers::FPConversionTemp, to);
77343:         }
77343:         return;
77343:     }
77343: 
77343: #if defined JS_PUNBOX64
56004:     /* If we can, sync the type and data in one go. */
56004:     if (!fe->data.synced() && !fe->type.synced()) {
56004:         if (backing->isConstant())
56004:             masm.storeValue(backing->getValue(), to);
56004:         else if (backing->isTypeKnown())
56004:             masm.storeValueFromComponents(ImmType(backing->getKnownType()), backing->data.reg(), to);
55514:         else
56004:             masm.storeValueFromComponents(backing->type.reg(), backing->data.reg(), to);
56004:         return;
56004:     }
56004: #endif
56004: 
56004:     /* 
56004:      * On x86_64, only one of the following two calls will have output,
56004:      * and a load will only occur if necessary.
56004:      */
56004:     ensureDataSynced(fe, masm);
56004:     ensureTypeSynced(fe, masm);
52617: }
52608: 
52618: inline void
56004: FrameState::ensureTypeSynced(const FrameEntry *fe, Assembler &masm) const
52608: {
56004:     if (fe->type.synced())
56004:         return;
52617: 
56004:     Address to = addressOf(fe);
56004:     const FrameEntry *backing = fe;
56004:     if (fe->isCopy())
56004:         backing = fe->copyOf();
56004: 
56004: #if defined JS_PUNBOX64
56004:     /* Attempt to store the entire Value, to prevent a load. */
56004:     if (backing->isConstant()) {
56004:         masm.storeValue(backing->getValue(), to);
56004:         return;
56004:     }
56004: 
56004:     if (backing->data.inRegister()) {
56004:         RegisterID dreg = backing->data.reg();
56004:         if (backing->isTypeKnown())
56004:             masm.storeValueFromComponents(ImmType(backing->getKnownType()), dreg, to);
52617:         else
56004:             masm.storeValueFromComponents(backing->type.reg(), dreg, to);
56004:         return;
56004:     }
56004: #endif
56004: 
56004:     /* Store a double's type bits, even though !isTypeKnown(). */
56004:     if (backing->isConstant())
56004:         masm.storeTypeTag(ImmTag(backing->getKnownTag()), to);
56004:     else if (backing->isTypeKnown())
56004:         masm.storeTypeTag(ImmType(backing->getKnownType()), to); 
56004:     else
56004:         masm.storeTypeTag(backing->type.reg(), to);
56004: }
56004: 
56004: inline void
56004: FrameState::ensureDataSynced(const FrameEntry *fe, Assembler &masm) const
56004: {
56004:     if (fe->data.synced())
56004:         return;
56004: 
56004:     Address to = addressOf(fe);
56004:     const FrameEntry *backing = fe;
56004:     if (fe->isCopy())
56004:         backing = fe->copyOf();
56004: 
56004: #if defined JS_PUNBOX64
56004:     if (backing->isConstant())
56004:         masm.storeValue(backing->getValue(), to);
56004:     else if (backing->isTypeKnown())
56004:         masm.storeValueFromComponents(ImmType(backing->getKnownType()), backing->data.reg(), to);
56004:     else if (backing->type.inRegister())
56004:         masm.storeValueFromComponents(backing->type.reg(), backing->data.reg(), to);
56004:     else
56004:         masm.storePayload(backing->data.reg(), to);
56004: #elif defined JS_NUNBOX32
56004:     if (backing->isConstant())
56004:         masm.storePayload(ImmPayload(backing->getPayload()), to);
56004:     else
56004:         masm.storePayload(backing->data.reg(), to);
56004: #endif
56004: }
56004: 
56004: inline void
56004: FrameState::syncFe(FrameEntry *fe)
56004: {
77343:     if (fe->type.synced() && fe->data.synced())
77343:         return;
77343: 
56004:     FrameEntry *backing = fe;
56004:     if (fe->isCopy())
56004:         backing = fe->copyOf();
56004: 
77343:     if (backing->isType(JSVAL_TYPE_DOUBLE)) {
77343:         if (!backing->isConstant())
77343:             tempFPRegForData(backing);
77343:         ensureFeSynced(fe, masm);
77343: 
77343:         if (!fe->type.synced())
77343:             fe->type.sync();
77343:         if (!fe->data.synced())
77343:             fe->data.sync();
77343:         return;
77343:     }
77343: 
56004:     bool needTypeReg = !fe->type.synced() && backing->type.inMemory();
56004:     bool needDataReg = !fe->data.synced() && backing->data.inMemory();
56004: 
56004: #if defined JS_NUNBOX32
56004:     /* Determine an ordering that won't spill known regs. */
56004:     if (needTypeReg && !needDataReg) {
56004:         syncData(fe);
56004:         syncType(fe);
56004:     } else {
56004:         syncType(fe);
56004:         syncData(fe);
56004:     }
56004: #elif defined JS_PUNBOX64
56004:     if (JS_UNLIKELY(needTypeReg && needDataReg)) {
56004:         /* Memory-to-memory moves can only occur for copies backed by memory. */
56004:         JS_ASSERT(backing != fe);
56004: 
56004:         /* Use ValueReg to do a whole-Value mem-to-mem move. */
56004:         masm.loadValue(addressOf(backing), Registers::ValueReg);
56004:         masm.storeValue(Registers::ValueReg, addressOf(fe));
56004:     } else {
56004:         /* Store in case unpinning is necessary. */
56004:         MaybeRegisterID pairReg;
56004: 
56004:         /* Get a register if necessary, without clobbering its pair. */
56004:         if (needTypeReg) {
77343:             if (backing->data.inRegister() && !regstate(backing->data.reg()).isPinned()) {
56004:                 pairReg = backing->data.reg();
56004:                 pinReg(backing->data.reg());
56004:             }
56004:             tempRegForType(backing);
56004:         } else if (needDataReg) {
77343:             if (backing->type.inRegister() && !regstate(backing->type.reg()).isPinned()) {
56004:                 pairReg = backing->type.reg();
56004:                 pinReg(backing->type.reg());
56004:             }
56004:             tempRegForData(backing);
56004:         }
56004: 
56004:         ensureFeSynced(fe, masm);
56004: 
56004:         if (pairReg.isSet())
56004:             unpinReg(pairReg.reg());
56004:     }
56004: 
56004:     if (!fe->type.synced())
56004:         fe->type.sync();
56004:     if (!fe->data.synced())
56004:         fe->data.sync();
56004: #endif
56004: }
56004: 
56004: inline void
77343: FrameState::syncAndForgetFe(FrameEntry *fe, bool markSynced)
77343: {
77343:     if (markSynced) {
77343:         if (!fe->type.synced())
77343:             fe->type.sync();
77343:         if (!fe->data.synced())
77343:             fe->data.sync();
77343:     }
77343: 
77343:     syncFe(fe);
77343:     forgetAllRegs(fe);
77343:     fe->type.setMemory();
77343:     fe->data.setMemory();
77343: }
77343: 
77884: inline JSC::MacroAssembler::Address
77884: FrameState::loadNameAddress(const analyze::ScriptAnalysis::NameAccess &access)
77884: {
77884:     JS_ASSERT(access.script && access.nesting);
77884: 
77884:     RegisterID reg = allocReg();
77884:     Value **pbase = access.arg ? &access.nesting->argArray : &access.nesting->varArray;
77884:     masm.move(ImmPtr(pbase), reg);
77884:     masm.loadPtr(Address(reg), reg);
77884: 
77884:     return Address(reg, access.index * sizeof(Value));
77884: }
77884: 
77343: inline void
77471: FrameState::forgetLoopReg(FrameEntry *fe)
77471: {
77471:     /*
77471:      * Don't use a loop register for fe in the active loop, as its underlying
77471:      * representation may have changed since the start of the loop.
77471:      */
77471:     if (loop)
77471:         fe->lastLoop = loop->headOffset();
77471: }
77471: 
77471: inline void
56004: FrameState::syncType(FrameEntry *fe)
56004: {
77343:     JS_ASSERT(!fe->isType(JSVAL_TYPE_DOUBLE));
77343: 
56004:     FrameEntry *backing = fe;
56004:     if (fe->isCopy())
56004:         backing = fe->copyOf();
56004: 
56004:     if (!fe->type.synced() && backing->type.inMemory())
56004:         tempRegForType(backing);
56004: 
56004:     ensureTypeSynced(fe, masm);
56004: 
56004:     if (!fe->type.synced())
56004:         fe->type.sync();
56004: }
56004: 
56004: inline void
56004: FrameState::syncData(FrameEntry *fe)
56004: {
77343:     JS_ASSERT(!fe->isType(JSVAL_TYPE_DOUBLE));
77343: 
56004:     FrameEntry *backing = fe;
56004:     if (fe->isCopy())
56004:         backing = fe->copyOf();
56004: 
56004:     if (!fe->data.synced() && backing->data.inMemory())
56004:         tempRegForData(backing);
56004: 
56004:     ensureDataSynced(fe, masm);
56004: 
56004:     if (!fe->data.synced())
56004:         fe->data.sync();
52608: }
52611: 
52619: inline void
77343: FrameState::fakeSync(FrameEntry *fe)
77343: {
77343:     /*
77343:      * If a frame entry's value will no longer be used, we can mark it as being
77343:      * synced without actually performing the sync: the value is not observed.
77343:      */
77343:     if (!fe->data.synced())
77343:         fe->data.sync();
77343:     if (!fe->type.synced())
77343:         fe->type.sync();
77343: }
77343: 
77343: inline void
52804: FrameState::forgetType(FrameEntry *fe)
52804: {
54577:     /*
54577:      * The type may have been forgotten with an intervening storeLocal in the
54577:      * presence of eval or closed variables. For defense in depth and to make
54577:      * callers' lives simpler, bail out if the type is not known.
54577:      */
54577:     if (!fe->isTypeKnown())
54577:         return;
54577: 
56004:     /*
56004:      * Likewise, storeLocal() may have set this FE, with a known type,
56004:      * to be a copy of another FE, which has an unknown type.
56004:      */
56004:     if (fe->isCopy()) {
77343:         syncFe(fe);
77343:         fe->clear();
77343:         fe->resetSynced();
56004:         return;
56004:     }
56004: 
56004:     ensureTypeSynced(fe, masm);
52804:     fe->type.setMemory();
52804: }
52804: 
52804: inline void
77343: FrameState::learnType(FrameEntry *fe, JSValueType type, bool unsync)
52619: {
77343:     JS_ASSERT(!fe->isType(JSVAL_TYPE_DOUBLE));
77343:     JS_ASSERT(type != JSVAL_TYPE_UNKNOWN);
77343: 
77343:     if (fe->isCopy())
77343:         fe = fe->copyOf();
77343: 
77343:     if (type == JSVAL_TYPE_DOUBLE)
77343:         JS_ASSERT(!fe->data.inRegister());
77343:     else
77343:         JS_ASSERT(!fe->data.inFPRegister());
77343: 
52624:     if (fe->type.inRegister())
52624:         forgetReg(fe->type.reg());
53025:     fe->setType(type);
77343:     if (unsync)
77343:         fe->type.unsync();
77343: }
77343: 
77343: inline void
77343: FrameState::learnType(FrameEntry *fe, JSValueType type, RegisterID data)
77343: {
77343:     JS_ASSERT(!fe->isCopied());
77343:     JS_ASSERT(type != JSVAL_TYPE_UNKNOWN && type != JSVAL_TYPE_DOUBLE);
77343: 
77343:     forgetAllRegs(fe);
77343:     fe->clear();
77343: 
77343:     fe->type.setConstant();
77343:     fe->knownType = type;
77343: 
77343:     fe->data.setRegister(data);
77343:     regstate(data).associate(fe, RematInfo::DATA);
77343: 
77343:     fe->data.unsync();
77343:     fe->type.unsync();
77343: }
77343: 
77343: inline int32
77343: FrameState::frameOffset(const FrameEntry *fe, ActiveFrame *a) const
77343: {
77343:     /*
77343:      * The stored frame offsets for analysis temporaries are immediately above
77343:      * the script's normal slots (and will thus be clobbered should a C++ or
77343:      * scripted call push another frame). There must be enough room in the
77343:      * reserved stack space.
77343:      */
77343:     JS_STATIC_ASSERT(StackSpace::STACK_JIT_EXTRA >= TEMPORARY_LIMIT);
77407: 
77407:     /* Note: fe == a->sp is allowed for addressOfTop */
77407:     JS_ASSERT(fe >= a->callee_ && fe <= a->sp);
77343: 
77343:     if (fe >= a->locals)
77343:         return StackFrame::offsetOfFixed(uint32(fe - a->locals));
77343:     if (fe >= a->args)
77391:         return StackFrame::offsetOfFormalArg(a->script->function(), uint32(fe - a->args));
77343:     if (fe == a->this_)
77391:         return StackFrame::offsetOfThis(a->script->hasFunction ? a->script->function() : NULL);
77343:     if (fe == a->callee_)
77391:         return StackFrame::offsetOfCallee(a->script->function());
77343:     JS_NOT_REACHED("Bad fe");
77343:     return 0;
52619: }
52619: 
52620: inline JSC::MacroAssembler::Address
76019: FrameState::addressOf(const FrameEntry *fe) const
52620: {
77343:     if (isTemporary(fe)) {
77343:         /*
77343:          * Temporary addresses are common to the outermost loop, and are shared
77343:          * by all active frames.
77343:          */
77343:         return Address(JSFrameReg, (loop->temporariesStart + fe - temporaries) * sizeof(Value));
77343:     }
77343: 
77343:     ActiveFrame *na = a;
77343:     while (fe < na->callee_)
77343:         na = na->parent;
77343: 
77343:     int32 offset = frameOffset(fe, na);
77343:     return Address(JSFrameReg, offset + (na->depth * sizeof(Value)));
77343: }
77343: 
77343: inline uint32
77343: FrameState::frameSlot(ActiveFrame *a, const FrameEntry *fe) const
77343: {
77343:     if (isTemporary(fe))
77343:         return fe - entries;
77343: 
77343:     JS_ASSERT(fe >= a->callee_ && fe < a->sp);
77343: 
77343:     if (fe >= a->locals)
77343:         return analyze::LocalSlot(a->script, fe - a->locals);
77343:     if (fe >= a->args)
77343:         return analyze::ArgSlot(fe - a->args);
77343:     if (fe == a->this_)
77343:         return analyze::ThisSlot();
77343:     if (fe == a->callee_)
77343:         return analyze::CalleeSlot();
77343:     JS_NOT_REACHED("Bad fe");
77343:     return 0;
77343: }
77343: 
77343: inline JSC::MacroAssembler::Address
81860: FrameState::addressForInlineReturn()
77343: {
81860:     if (a->callee_->isTracked())
81860:         discardFe(a->callee_);
77343:     return addressOf(a->callee_);
52620: }
52620: 
53497: inline JSC::MacroAssembler::Address
53497: FrameState::addressForDataRemat(const FrameEntry *fe) const
53497: {
53497:     if (fe->isCopy() && !fe->data.synced())
53497:         fe = fe->copyOf();
53497:     JS_ASSERT(fe->data.synced());
53497:     return addressOf(fe);
53497: }
53497: 
52623: inline JSC::MacroAssembler::Jump
53004: FrameState::testNull(Assembler::Condition cond, FrameEntry *fe)
53004: {
53004:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
53004:     if (shouldAvoidTypeRemat(fe))
53004:         return masm.testNull(cond, addressOf(fe));
53004:     return masm.testNull(cond, tempRegForType(fe));
53004: }
53004: 
53004: inline JSC::MacroAssembler::Jump
55712: FrameState::testUndefined(Assembler::Condition cond, FrameEntry *fe)
55712: {
55712:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
55712:     if (shouldAvoidTypeRemat(fe))
55712:         return masm.testUndefined(cond, addressOf(fe));
55712:     return masm.testUndefined(cond, tempRegForType(fe));
55712: }
55712: 
55712: inline JSC::MacroAssembler::Jump
52623: FrameState::testInt32(Assembler::Condition cond, FrameEntry *fe)
52623: {
52823:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
52623:     if (shouldAvoidTypeRemat(fe))
52623:         return masm.testInt32(cond, addressOf(fe));
52623:     return masm.testInt32(cond, tempRegForType(fe));
52623: }
52623: 
52734: inline JSC::MacroAssembler::Jump
52894: FrameState::testPrimitive(Assembler::Condition cond, FrameEntry *fe)
52894: {
52894:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
52894:     if (shouldAvoidTypeRemat(fe))
52894:         return masm.testPrimitive(cond, addressOf(fe));
52894:     return masm.testPrimitive(cond, tempRegForType(fe));
52894: }
52894: 
52894: inline JSC::MacroAssembler::Jump
53023: FrameState::testObject(Assembler::Condition cond, FrameEntry *fe)
52838: {
52838:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
52838:     if (shouldAvoidTypeRemat(fe))
53023:         return masm.testObject(cond, addressOf(fe));
53023:     return masm.testObject(cond, tempRegForType(fe));
52850: }
52850: 
52850: inline JSC::MacroAssembler::Jump
52823: FrameState::testDouble(Assembler::Condition cond, FrameEntry *fe)
52823: {
52823:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
52823:     if (shouldAvoidTypeRemat(fe))
52823:         return masm.testDouble(cond, addressOf(fe));
52823:     return masm.testDouble(cond, tempRegForType(fe));
52823: }
52823: 
52823: inline JSC::MacroAssembler::Jump
52734: FrameState::testBoolean(Assembler::Condition cond, FrameEntry *fe)
52734: {
52823:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
52734:     if (shouldAvoidTypeRemat(fe))
52734:         return masm.testBoolean(cond, addressOf(fe));
52734:     return masm.testBoolean(cond, tempRegForType(fe));
52734: }
52734: 
53137: inline JSC::MacroAssembler::Jump
53137: FrameState::testString(Assembler::Condition cond, FrameEntry *fe)
53137: {
53137:     JS_ASSERT(cond == Assembler::Equal || cond == Assembler::NotEqual);
53137:     if (shouldAvoidTypeRemat(fe))
53137:         return masm.testString(cond, addressOf(fe));
53137:     return masm.testString(cond, tempRegForType(fe));
53137: }
53137: 
52670: inline FrameEntry *
57787: FrameState::getOrTrack(uint32 index)
52670: {
54719:     FrameEntry *fe = &entries[index];
54719:     if (!fe->isTracked()) {
54719:         addToTracker(fe);
52670:         fe->resetSynced();
54719:     }
52670:     return fe;
52670: }
52670: 
57787: inline FrameEntry *
77343: FrameState::getStack(uint32 slot)
77343: {
77343:     if (slot >= uint32(a->sp - a->spBase))
77343:         return NULL;
77343:     return getOrTrack(uint32(a->spBase + slot - entries));
77343: }
77343: 
77343: inline FrameEntry *
57787: FrameState::getLocal(uint32 slot)
57787: {
77343:     JS_ASSERT(slot < a->script->nslots);
77343:     return getOrTrack(uint32(a->locals + slot - entries));
57787: }
57787: 
57787: inline FrameEntry *
57787: FrameState::getArg(uint32 slot)
57787: {
77391:     JS_ASSERT(slot < a->script->function()->nargs);
77343:     return getOrTrack(uint32(a->args + slot - entries));
57787: }
57787: 
57787: inline FrameEntry *
57787: FrameState::getThis()
57787: {
77343:     return getOrTrack(uint32(a->this_ - entries));
77343: }
77343: 
77343: inline FrameEntry *
77343: FrameState::getSlotEntry(uint32 slot)
77343: {
77343:     JS_ASSERT(slot < analyze::TotalSlots(a->script));
77343:     return getOrTrack(uint32(a->callee_ + slot - entries));
57787: }
57787: 
57787: inline FrameEntry *
57787: FrameState::getCallee()
57787: {
57787:     // Callee can only be used in function code, and it's always an object.
77391:     JS_ASSERT(a->script->hasFunction);
77343:     FrameEntry *fe = a->callee_;
77343:     if (!fe->isTracked()) {
77343:         addToTracker(fe);
77343:         fe->resetSynced();
77343:         fe->setType(JSVAL_TYPE_OBJECT);
57787:     }
77343:     return fe;
57787: }
57787: 
52685: inline void
54719: FrameState::unpinKilledReg(RegisterID reg)
54719: {
77343:     regstate(reg).unpinUnsafe();
76019:     freeRegs.putReg(reg);
52685: }
52685: 
52691: inline void
52846: FrameState::forgetAllRegs(FrameEntry *fe)
52691: {
77343:     if (fe->isCopy())
77343:         return;
52691:     if (fe->type.inRegister())
52691:         forgetReg(fe->type.reg());
52691:     if (fe->data.inRegister())
52691:         forgetReg(fe->data.reg());
77343:     if (fe->data.inFPRegister())
77343:         forgetReg(fe->data.fpreg());
52691: }
52691: 
52708: inline void
52708: FrameState::swapInTracker(FrameEntry *lhs, FrameEntry *rhs)
52708: {
52708:     uint32 li = lhs->trackerIndex();
52708:     uint32 ri = rhs->trackerIndex();
76019:     JS_ASSERT(tracker[li] == lhs);
76019:     JS_ASSERT(tracker[ri] == rhs);
76019:     tracker.entries[ri] = lhs;
76019:     tracker.entries[li] = rhs;
52708:     lhs->index_ = ri;
52708:     rhs->index_ = li;
52708: }
52708: 
52714: inline void
52714: FrameState::dup()
52714: {
52916:     dupAt(-1);
52714: }
52714: 
52714: inline void
52715: FrameState::dup2()
52715: {
52715:     FrameEntry *lhs = peek(-2);
52715:     FrameEntry *rhs = peek(-1);
77343:     pushCopyOf(lhs);
77343:     pushCopyOf(rhs);
52715: }
52715: 
52715: inline void
52916: FrameState::dupAt(int32 n)
52916: {
52916:     JS_ASSERT(n < 0);
52916:     FrameEntry *fe = peek(n);
77343:     pushCopyOf(fe);
77343: }
77343: 
77343: inline void
77343: FrameState::syncAt(int32 n)
77343: {
77343:     JS_ASSERT(n < 0);
77343:     FrameEntry *fe = peek(n);
77343:     syncFe(fe);
75708: }
75708: 
75708: inline void
52714: FrameState::pushLocal(uint32 n)
52714: {
57787:     FrameEntry *fe = getLocal(n);
77343:     if (!a->analysis->slotEscapes(analyze::LocalSlot(a->script, n))) {
77343:         pushCopyOf(fe);
52878:     } else {
53309: #ifdef DEBUG
53309:         /*
53309:          * We really want to assert on local variables, but in the presence of
53309:          * SETLOCAL equivocation of stack slots, and let expressions, just
53309:          * weakly assert on the fixed local vars.
53309:          */
77343:         if (fe->isTracked() && n < a->script->nfixed)
53309:             JS_ASSERT(fe->data.inMemory());
53309: #endif
77343:         JSValueType type = fe->isTypeKnown() ? fe->getKnownType() : JSVAL_TYPE_UNKNOWN;
77343:         push(addressOf(fe), type);
52878:     }
52714: }
52714: 
52785: inline void
57787: FrameState::pushArg(uint32 n)
57787: {
57787:     FrameEntry *fe = getArg(n);
77343:     if (!a->analysis->slotEscapes(analyze::ArgSlot(n))) {
77343:         pushCopyOf(fe);
57787:     } else {
57787: #ifdef DEBUG
77343:         if (fe->isTracked())
57787:             JS_ASSERT(fe->data.inMemory());
57787: #endif
77343:         JSValueType type = fe->isTypeKnown() ? fe->getKnownType() : JSVAL_TYPE_UNKNOWN;
77343:         push(addressOf(fe), type);
57787:     }
57787: }
57787: 
57787: inline void
57787: FrameState::pushCallee()
57787: {
57787:     FrameEntry *fe = getCallee();
77343:     pushCopyOf(fe);
57787: }
57787: 
57787: inline void
57787: FrameState::pushThis()
57787: {
57787:     FrameEntry *fe = getThis();
77343:     pushCopyOf(fe);
75966: }
75966: 
57787: void
77343: FrameState::learnThisIsObject(bool unsync)
57787: {
77343:     // If the 'this' object is a copy, this must be an inline frame, in which
77343:     // case we will trigger recompilation if the 'this' entry isn't actually
77343:     // an object (thus, it is OK to modify the backing directly).
77431:     FrameEntry *fe = getThis();
77343:     if (fe->isCopy())
77343:         fe = fe->copyOf();
77343:     learnType(fe, JSVAL_TYPE_OBJECT, unsync);
57787: }
57787: 
77413: void
77413: FrameState::setThis(RegisterID reg)
77413: {
77431:     FrameEntry *fe = getThis();
77413:     JS_ASSERT(!fe->isCopy());
77413:     learnType(fe, JSVAL_TYPE_OBJECT, reg);
77413: }
77413: 
77431: void
77431: FrameState::syncThis()
77431: {
77431:     FrameEntry *fe = getThis();
77431:     syncFe(fe);
77431: }
77431: 
77432: inline bool
77432: FrameState::isConstructorThis(const FrameEntry *fe) const
77432: {
77432:     return isThis(fe) && cc.constructing();
77432: }
77432: 
57787: inline void
52785: FrameState::leaveBlock(uint32 n)
52785: {
52785:     popn(n);
52785: }
52785: 
52785: inline void
52785: FrameState::enterBlock(uint32 n)
52785: {
52785:     /* expect that tracker has 0 entries, for now. */
76019:     JS_ASSERT(!tracker.nentries);
77343:     JS_ASSERT(uint32(a->sp + n - a->locals) <= a->script->nslots);
52785: 
77343:     a->sp += n;
52785: }
52785: 
52838: inline void
52838: FrameState::eviscerate(FrameEntry *fe)
52838: {
52846:     forgetAllRegs(fe);
77343:     fe->resetUnsynced();
52838: }
52838: 
52880: inline StateRemat
52880: FrameState::dataRematInfo(const FrameEntry *fe) const
52880: {
52880:     if (fe->isCopy())
52880:         fe = fe->copyOf();
56575: 
56575:     if (fe->data.inRegister())
56575:         return StateRemat::FromRegister(fe->data.reg());
56575: 
52880:     JS_ASSERT(fe->data.synced());
56575:     return StateRemat::FromAddress(addressOf(fe));
52880: }
52880: 
53052: inline void
53052: FrameState::giveOwnRegs(FrameEntry *fe)
53052: {
53052:     JS_ASSERT(!fe->isConstant());
53052:     JS_ASSERT(fe == peek(-1));
53052: 
53052:     if (!fe->isCopy())
53052:         return;
53052: 
53052:     RegisterID data = copyDataIntoReg(fe);
53052:     if (fe->isTypeKnown()) {
53052:         JSValueType type = fe->getKnownType();
53052:         pop();
53052:         pushTypedPayload(type, data);
53052:     } else {
53052:         RegisterID type = copyTypeIntoReg(fe);
53052:         pop();
77343:         pushRegs(type, data, JSVAL_TYPE_UNKNOWN);
53052:     }
53052: }
53052: 
53152: inline void
77343: FrameState::loadDouble(RegisterID t, RegisterID d, FrameEntry *fe, FPRegisterID fpreg,
53229:                        Assembler &masm) const
53229: {
53229: #ifdef JS_CPU_X86
77343:     masm.fastLoadDouble(d, t, fpreg);
53229: #else
77343:     loadDouble(fe, fpreg, masm);
53229: #endif
53229: }
53229: 
53229: inline bool
53229: FrameState::tryFastDoubleLoad(FrameEntry *fe, FPRegisterID fpReg, Assembler &masm) const
53229: {
53229: #ifdef JS_CPU_X86
77343:     if (!fe->isCopy() && fe->type.inRegister() && fe->data.inRegister()) {
53229:         masm.fastLoadDouble(fe->data.reg(), fe->type.reg(), fpReg);
53229:         return true;
53229:     }
53229: #endif
53229:     return false;
53229: }
53229: 
53229: inline void
53152: FrameState::loadDouble(FrameEntry *fe, FPRegisterID fpReg, Assembler &masm) const
53152: {
53152:     if (fe->isCopy()) {
53152:         FrameEntry *backing = fe->copyOf();
53229:         if (tryFastDoubleLoad(fe, fpReg, masm)) 
53229:             return;
53152:         fe = backing;
53152:     }
53152: 
53229:     if (tryFastDoubleLoad(fe, fpReg, masm))
53229:         return;
53229: 
56004:     ensureFeSynced(fe, masm);
55514:     masm.loadDouble(addressOf(fe), fpReg);
53152: }
53152: 
57713: class PinRegAcrossSyncAndKill
57713: {
57713:     typedef JSC::MacroAssembler::RegisterID RegisterID;
57713:     FrameState &frame;
57713:     MaybeRegisterID maybeReg;
57713:   public:
57713:     PinRegAcrossSyncAndKill(FrameState &frame, RegisterID reg)
57713:       : frame(frame), maybeReg(reg)
57713:     {
57713:         frame.pinReg(reg);
57713:     }
57713:     PinRegAcrossSyncAndKill(FrameState &frame, MaybeRegisterID maybeReg)
57713:       : frame(frame), maybeReg(maybeReg)
57713:     {
57713:         if (maybeReg.isSet())
57713:             frame.pinReg(maybeReg.reg());
57713:     }
57713:     ~PinRegAcrossSyncAndKill() {
57713:         if (maybeReg.isSet())
57713:             frame.unpinKilledReg(maybeReg.reg());
57713:     }
57713: };
57713: 
55514: } /* namespace mjit */
55514: } /* namespace js */
52608: 
52618: #endif /* include */
52611: 
