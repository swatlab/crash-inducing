43529: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
43310: /* ***** BEGIN LICENSE BLOCK *****
43310:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43310:  *
43310:  * The contents of this file are subject to the Mozilla Public License Version
43310:  * 1.1 (the "License"); you may not use this file except in compliance with
43310:  * the License. You may obtain a copy of the License at
43310:  * http://www.mozilla.org/MPL/
43310:  *
43310:  * Software distributed under the License is distributed on an "AS IS" basis,
43310:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43310:  * for the specific language governing rights and limitations under the
43310:  * License.
43310:  *
43310:  * The Original Code is mozilla.org code.
43310:  *
43310:  * The Initial Developer of the Original Code is
43310:  * Mozilla Foundation.
43310:  * Portions created by the Initial Developer are Copyright (C) 2010
43310:  * the Initial Developer. All Rights Reserved.
43310:  *
43310:  * Contributor(s):
43310:  *  Alexander Surkov <surkov.alexander@gmail.com> (original author)
43310:  *
43310:  * Alternatively, the contents of this file may be used under the terms of
43310:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43310:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43310:  * in which case the provisions of the GPL or the LGPL are applicable instead
43310:  * of those above. If you wish to allow use of your version of this file only
43310:  * under the terms of either the GPL or the LGPL, and not to allow others to
43310:  * use your version of this file under the terms of the MPL, indicate your
43310:  * decision by deleting the provisions above and replace them with the notice
43310:  * and other provisions required by the GPL or the LGPL. If you do not delete
43310:  * the provisions above, a recipient may use your version of this file under
43310:  * the terms of any one of the MPL, the GPL or the LGPL.
43310:  *
43310:  * ***** END LICENSE BLOCK ***** */
43310: 
43310: #include "nsAccDocManager.h"
43310: 
43310: #include "nsAccessibilityService.h"
43310: #include "nsAccUtils.h"
43310: #include "nsOuterDocAccessible.h"
43310: #include "nsRootAccessibleWrap.h"
43310: 
43310: #include "nsCURILoader.h"
43310: #include "nsDocShellLoadTypes.h"
43310: #include "nsIChannel.h"
43310: #include "nsIContentViewer.h"
43310: #include "nsIDOMDocument.h"
43310: #include "nsIEventListenerManager.h"
43310: #include "nsIDOMEventTarget.h"
43310: #include "nsIDOMWindow.h"
43310: #include "nsIInterfaceRequestorUtils.h"
43310: #include "nsIWebNavigation.h"
43310: #include "nsServiceManagerUtils.h"
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccDocManager
43310: ////////////////////////////////////////////////////////////////////////////////
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccDocManager public
43310: 
43310: nsDocAccessible*
43310: nsAccDocManager::GetDocAccessible(nsIDocument *aDocument)
43310: {
43310:   if (!aDocument)
43310:     return nsnull;
43310: 
43310:   nsDocAccessible *docAcc =
43310:     mDocAccessibleCache.GetWeak(static_cast<void*>(aDocument));
43310:   if (docAcc)
43310:     return docAcc;
43310: 
43310:   return CreateDocOrRootAccessible(aDocument);
43310: }
43310: 
43310: nsAccessible*
43310: nsAccDocManager::FindAccessibleInCache(void *aUniqueID) const
43310: {
43310:   nsSearchAccessibleInCacheArg arg;
43310:     arg.mUniqueID = aUniqueID;
43310: 
43310:   mDocAccessibleCache.EnumerateRead(SearchAccessibleInDocCache,
43310:                                     static_cast<void*>(&arg));
43310: 
43310:   return arg.mAccessible;
43310: }
43310: 
43310: void
43310: nsAccDocManager::ShutdownDocAccessiblesInTree(nsIDocument *aDocument)
43310: {
43310:   nsCOMPtr<nsISupports> container = aDocument->GetContainer();
43310:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(container);
43310:   ShutdownDocAccessiblesInTree(treeItem, aDocument);
43310: }
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccDocManager protected
43310: 
43310: PRBool
43310: nsAccDocManager::Init()
43310: {
43310:   mDocAccessibleCache.Init(4);
43310: 
43310:   nsCOMPtr<nsIWebProgress> progress =
43310:     do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
43310: 
43310:   if (!progress)
43310:     return PR_FALSE;
43310: 
43310:   progress->AddProgressListener(static_cast<nsIWebProgressListener*>(this),
43310:                                 nsIWebProgress::NOTIFY_STATE_DOCUMENT);
43310: 
43310:   return PR_TRUE;
43310: }
43310: 
43310: void
43310: nsAccDocManager::Shutdown()
43310: {
43310:   nsCOMPtr<nsIWebProgress> progress =
43310:     do_GetService(NS_DOCUMENTLOADER_SERVICE_CONTRACTID);
43310: 
43310:   if (progress)
43310:     progress->RemoveProgressListener(static_cast<nsIWebProgressListener*>(this));
43310: 
43310:   ClearDocCache();
43310: }
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsISupports
43310: 
43310: NS_IMPL_THREADSAFE_ISUPPORTS3(nsAccDocManager,
43310:                               nsIWebProgressListener,
43310:                               nsIDOMEventListener,
43310:                               nsISupportsWeakReference)
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsIWebProgressListener
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::OnStateChange(nsIWebProgress *aWebProgress,
43310:                                nsIRequest *aRequest, PRUint32 aStateFlags,
43310:                                nsresult aStatus)
43310: {
43310:   NS_ASSERTION(aStateFlags & STATE_IS_DOCUMENT, "Other notifications excluded");
43310: 
43310:   if (nsAccessibilityService::IsShutdown() || !aWebProgress ||
43310:       (aStateFlags & (STATE_START | STATE_STOP)) == 0)
43310:     return NS_OK;
43310: 
43310:   nsCOMPtr<nsIDOMWindow> DOMWindow;
43310:   aWebProgress->GetDOMWindow(getter_AddRefs(DOMWindow));
43310:   NS_ENSURE_STATE(DOMWindow);
43310: 
43310:   nsCOMPtr<nsIDOMDocument> DOMDocument;
43310:   DOMWindow->GetDocument(getter_AddRefs(DOMDocument));
43310:   NS_ENSURE_STATE(DOMDocument);
43310: 
43310:   nsCOMPtr<nsIDocument> document(do_QueryInterface(DOMDocument));
43310: 
43310:   // Document was loaded.
43310:   if (aStateFlags & STATE_STOP) {
43310:     NS_LOG_ACCDOCLOAD("document loaded", aWebProgress, aRequest, aStateFlags)
43310: 
43310:     // Figure out an event type to notify the document has been loaded.
43310:     PRUint32 eventType = nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_STOPPED;
43310: 
43310:     // Some XUL documents get start state and then stop state with failure
43310:     // status when everything is ok. Fire document load complete event in this
43310:     // case.
43310:     if (NS_SUCCEEDED(aStatus) || !nsCoreUtils::IsContentDocument(document))
43310:       eventType = nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE;
43310: 
43310:     // If end consumer has been retargeted for loaded content then do not fire
43310:     // any event because it means no new document has been loaded, for example,
43310:     // it happens when user clicks on file link.
43310:     if (aRequest) {
43310:       PRUint32 loadFlags = 0;
43310:       aRequest->GetLoadFlags(&loadFlags);
43310:       if (loadFlags & nsIChannel::LOAD_RETARGETED_DOCUMENT_URI)
43310:         eventType = 0;
43310:     }
43310: 
43310:     HandleDOMDocumentLoad(document, eventType);
43310:     return NS_OK;
43310:   }
43310: 
43310:   // Document loading was started.
43310:   NS_LOG_ACCDOCLOAD("start document loading", aWebProgress, aRequest,
43310:                     aStateFlags)
43310: 
43310:   if (!IsEventTargetDocument(document))
43310:     return NS_OK;
43310: 
43310:   nsDocAccessible *docAcc =
43310:     mDocAccessibleCache.GetWeak(static_cast<void*>(document));
43310:   if (!docAcc)
43310:     return NS_OK;
43310: 
43310:   nsCOMPtr<nsIWebNavigation> webNav(do_GetInterface(DOMWindow));
43310:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(webNav));
43310:   NS_ENSURE_STATE(docShell);
43310: 
43310:   // Fire reload and state busy events on existing document accessible while
43310:   // event from user input flag can be calculated properly and accessible
43310:   // is alive. When new document gets loaded then this one is destroyed.
43310:   PRUint32 loadType;
43310:   docShell->GetLoadType(&loadType);
43310:   if (loadType == LOAD_RELOAD_NORMAL ||
43310:       loadType == LOAD_RELOAD_BYPASS_CACHE ||
43310:       loadType == LOAD_RELOAD_BYPASS_PROXY ||
43310:       loadType == LOAD_RELOAD_BYPASS_PROXY_AND_CACHE) {
43310: 
43310:     // Fire reload event.
43310:     nsRefPtr<nsAccEvent> reloadEvent =
43310:       new nsAccEvent(nsIAccessibleEvent::EVENT_DOCUMENT_RELOAD, docAcc);
43310:     nsEventShell::FireEvent(reloadEvent);
43310:   }
43310: 
43310:   // Fire state busy change event. Use delayed event since we don't care
43310:   // actually if event isn't delivered when the document goes away like a shot.
43310:   nsRefPtr<nsAccEvent> stateEvent =
43504:     new nsAccStateChangeEvent(document, nsIAccessibleStates::STATE_BUSY,
43310:                               PR_FALSE, PR_TRUE);
43310:   docAcc->FireDelayedAccessibleEvent(stateEvent);
43310: 
43310:   return NS_OK;
43310: }
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::OnProgressChange(nsIWebProgress *aWebProgress,
43310:                                   nsIRequest *aRequest,
43310:                                   PRInt32 aCurSelfProgress,
43310:                                   PRInt32 aMaxSelfProgress,
43310:                                   PRInt32 aCurTotalProgress,
43310:                                   PRInt32 aMaxTotalProgress)
43310: {
43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
43310:   return NS_OK;
43310: }
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::OnLocationChange(nsIWebProgress *aWebProgress,
43310:                                   nsIRequest *aRequest, nsIURI *aLocation)
43310: {
43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
43310:   return NS_OK;
43310: }
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::OnStatusChange(nsIWebProgress *aWebProgress,
43310:                                 nsIRequest *aRequest, nsresult aStatus,
43310:                                 const PRUnichar *aMessage)
43310: {
43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
43310:   return NS_OK;
43310: }
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::OnSecurityChange(nsIWebProgress *aWebProgress,
43310:                                   nsIRequest *aRequest,
43310:                                   PRUint32 aState)
43310: {
43310:   NS_NOTREACHED("notification excluded in AddProgressListener(...)");
43310:   return NS_OK;
43310: }
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsIDOMEventListener
43310: 
43310: NS_IMETHODIMP
43310: nsAccDocManager::HandleEvent(nsIDOMEvent *aEvent)
43310: {
43310:   nsAutoString type;
43310:   aEvent->GetType(type);
43310: 
43310:   nsCOMPtr<nsIDOMEventTarget> target;
43310:   aEvent->GetTarget(getter_AddRefs(target));
43310: 
43310:   nsCOMPtr<nsIDocument> document(do_QueryInterface(target));
43310:   NS_ASSERTION(document, "pagehide or DOMContentLoaded for non document!");
43310:   if (!document)
43310:     return NS_OK;
43310: 
43310:   if (type.EqualsLiteral("pagehide")) {
43310:     // 'pagehide' event is registered on every DOM document we create an
43310:     // accessible for, process the event for the target. This document
43310:     // accessible and all its sub document accessible are shutdown as result of
43310:     // processing.
43310: 
43310:     NS_LOG_ACCDOCDESTROY("received 'pagehide' event", document)
43310: 
43310:     // Ignore 'pagehide' on temporary documents since we ignore them entirely in
43310:     // accessibility.
43310:     if (document->IsInitialDocument())
43310:       return NS_OK;
43310: 
43310:     // Shutdown this one and sub document accessibles.
43310:     ShutdownDocAccessiblesInTree(document);
43310:     return NS_OK;
43310:   }
43310: 
43310:   // XXX: handle error pages loading separately since they get neither
43310:   // webprogress notifications nor 'pageshow' event.
43310:   if (type.EqualsLiteral("DOMContentLoaded") &&
43310:       nsCoreUtils::IsErrorPage(document)) {
43310:     NS_LOG_ACCDOCLOAD2("handled 'DOMContentLoaded' event", document)
43310:     HandleDOMDocumentLoad(document,
43310:                           nsIAccessibleEvent::EVENT_DOCUMENT_LOAD_COMPLETE,
43310:                           PR_TRUE);
43310:   }
43310: 
43310:   return NS_OK;
43310: }
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccDocManager private
43310: 
43310: void
43310: nsAccDocManager::HandleDOMDocumentLoad(nsIDocument *aDocument,
43310:                                        PRUint32 aLoadEventType,
43310:                                        PRBool aMarkAsLoaded)
43310: {
43310:   // Document accessible can be created before we were notified the DOM document
43310:   // was loaded completely. However if it's not created yet then create it.
43310:   nsDocAccessible *docAcc =
43310:     mDocAccessibleCache.GetWeak(static_cast<void*>(aDocument));
43310: 
43310:   if (!docAcc) {
43310:     docAcc = CreateDocOrRootAccessible(aDocument);
43310:     NS_ASSERTION(docAcc, "Can't create document accessible!");
43310:     if (!docAcc)
43310:       return;
43310:   }
43310: 
43310:   if (aMarkAsLoaded)
43310:     docAcc->MarkAsLoaded();
43310: 
43310:   // Do not fire document complete/stop events for root chrome document
43310:   // accessibles and for frame/iframe documents because
43310:   // a) screen readers start working on focus event in the case of root chrome
43310:   // documents
43310:   // b) document load event on sub documents causes screen readers to act is if
43310:   // entire page is reloaded.
43310:   if (!IsEventTargetDocument(aDocument)) {
43310:     // XXX: AT doesn't update their virtual buffer once frame is loaded and it
43310:     // has dynamic content added after frame load. There's something wrong how
43310:     // we handle this changes.
43310:     if (!nsCoreUtils::IsRootDocument(aDocument)) {
43310:       docAcc->InvalidateCacheSubtree(nsnull,
43310:                                      nsIAccessibilityService::NODE_SIGNIFICANT_CHANGE);
43310:     }
43310:     return;
43310:   }
43310: 
43310:   // Fire complete/load stopped if the load event type is given.
43310:   if (aLoadEventType) {
43504:     nsRefPtr<nsAccEvent> loadEvent = new nsAccEvent(aLoadEventType, aDocument);
43310:     docAcc->FireDelayedAccessibleEvent(loadEvent);
43310:   }
43310: 
43310:   // Fire busy state change event.
43310:   nsRefPtr<nsAccEvent> stateEvent =
43504:     new nsAccStateChangeEvent(aDocument, nsIAccessibleStates::STATE_BUSY,
43310:                               PR_FALSE, PR_FALSE);
43310:   docAcc->FireDelayedAccessibleEvent(stateEvent);
43310: }
43310: 
43310: PRBool
43310: nsAccDocManager::IsEventTargetDocument(nsIDocument *aDocument) const
43310: {
43310:   nsCOMPtr<nsISupports> container = aDocument->GetContainer();
43310:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
43310:     do_QueryInterface(container);
43310:   NS_ASSERTION(docShellTreeItem, "No document shell for document!");
43310: 
43310:   nsCOMPtr<nsIDocShellTreeItem> parentTreeItem;
43310:   docShellTreeItem->GetParent(getter_AddRefs(parentTreeItem));
43310: 
43310:   // It's not a root document.
43310:   if (parentTreeItem) {
43310:     nsCOMPtr<nsIDocShellTreeItem> sameTypeRoot;
43310:     docShellTreeItem->GetSameTypeRootTreeItem(getter_AddRefs(sameTypeRoot));
43310: 
43310:     // It's not a sub document, i.e. a frame or iframe.
43310:     return (sameTypeRoot == docShellTreeItem);
43310:   }
43310: 
43310:   // It's not chrome root document.
43310:   PRInt32 contentType;
43310:   docShellTreeItem->GetItemType(&contentType);
43310:   return (contentType == nsIDocShellTreeItem::typeContent);
43310: }
43310: 
43310: void
43310: nsAccDocManager::AddListeners(nsIDocument *aDocument,
43310:                               PRBool aAddDOMContentLoadedListener)
43310: {
43310:   nsPIDOMWindow *window = aDocument->GetWindow();
43310:   nsPIDOMEventTarget *target = window->GetChromeEventHandler();
43310:   nsIEventListenerManager* elm = target->GetListenerManager(PR_TRUE);
43310:   elm->AddEventListenerByType(this, NS_LITERAL_STRING("pagehide"),
43310:                               NS_EVENT_FLAG_CAPTURE, nsnull);
43310: 
43310:   NS_LOG_ACCDOCCREATE_TEXT("  added 'pagehide' listener")
43310: 
43310:   if (aAddDOMContentLoadedListener) {
43310:     elm->AddEventListenerByType(this, NS_LITERAL_STRING("DOMContentLoaded"),
43310:                                 NS_EVENT_FLAG_CAPTURE, nsnull);
43310:     NS_LOG_ACCDOCCREATE_TEXT("  added 'DOMContentLoaded' listener")
43310:   }
43310: }
43310: 
43310: void
43310: nsAccDocManager::RemoveListeners(nsIDocument *aDocument)
43310: {
43310:   // Document has no window when application shuts down. The document can still
43310:   // exist because we didn't receive a "pagehide" event.
43310:   nsPIDOMWindow *window = aDocument->GetWindow();
43310:   if (!window)
43310:     return;
43310: 
43310:   nsPIDOMEventTarget *target = window->GetChromeEventHandler();
43310:   nsIEventListenerManager* elm = target->GetListenerManager(PR_TRUE);
43310:   elm->RemoveEventListenerByType(this, NS_LITERAL_STRING("pagehide"),
43310:                                  NS_EVENT_FLAG_CAPTURE, nsnull);
43310: 
43310:   NS_LOG_ACCDOCDESTROY("removed 'pagehide' listener", aDocument)
43310: 
43310:   if (nsCoreUtils::IsRootDocument(aDocument)) {
43310:     elm->RemoveEventListenerByType(this, NS_LITERAL_STRING("DOMContentLoaded"),
43310:                                      NS_EVENT_FLAG_CAPTURE, nsnull);
43310: 
43310:     NS_LOG_ACCDOCDESTROY("removed 'DOMContentLoaded' listener", aDocument)
43310:   }
43310: }
43310: 
43310: nsDocAccessible*
43310: nsAccDocManager::CreateDocOrRootAccessible(nsIDocument *aDocument)
43310: {
43763:   // Ignore temporary, hiding and svg resource documents.
43763:   if (aDocument->IsInitialDocument() || !aDocument->IsVisible() ||
43763:       aDocument->GetDisplayDocument())
43310:     return nsnull;
43310: 
43310:   // Ignore documents without presshell.
43310:   nsIPresShell *presShell = aDocument->GetPrimaryShell();
43310:   if (!presShell)
43310:     return nsnull;
43310: 
43310:   // Do not create document accessible until role content is loaded, otherwise
43310:   // we get accessible document with wrong role.
43504:   nsIContent *rootElm = nsCoreUtils::GetRoleContent(aDocument);
43504:   if (!rootElm)
43504:     return nsnull;
43310: 
43310:   PRBool isRootDoc = nsCoreUtils::IsRootDocument(aDocument);
43310: 
43310:   // Ensure the document container node is accessible, otherwise do not create
43310:   // document accessible.
43310:   nsAccessible *outerDocAcc = nsnull;
43310:   if (!isRootDoc) {
43310:     nsIDocument* parentDoc = aDocument->GetParentDocument();
43310:     if (!parentDoc)
43310:       return nsnull;
43310: 
43310:     nsIContent* ownerContent = parentDoc->FindContentForSubDocument(aDocument);
43504:     if (!ownerContent)
43310:       return nsnull;
43310: 
43310:     // XXXaaronl: ideally we would traverse the presshell chain. Since there's
43310:     // no easy way to do that, we cheat and use the document hierarchy.
43310:     // GetAccessible() is bad because it doesn't support our concept of multiple
43310:     // presshells per doc. It should be changed to use
43310:     // GetAccessibleInWeakShell().
43504:     outerDocAcc = GetAccService()->GetAccessible(ownerContent);
43310:     if (!outerDocAcc)
43310:       return nsnull;
43310:   }
43310: 
43310:   nsCOMPtr<nsIWeakReference> weakShell(do_GetWeakReference(presShell));
43310: 
43310:   // We only create root accessibles for the true root, otherwise create a
43310:   // doc accessible.
43310:   nsDocAccessible *docAcc = isRootDoc ?
43504:     new nsRootAccessibleWrap(aDocument, rootElm, weakShell) :
43504:     new nsDocAccessibleWrap(aDocument, rootElm, weakShell);
43310: 
43310:   if (!docAcc)
43310:     return nsnull;
43310: 
43310:   // Cache and addref document accessible.
43310:   if (!mDocAccessibleCache.Put(static_cast<void*>(aDocument), docAcc)) {
43310:     delete docAcc;
43310:     return nsnull;
43310:   }
43310: 
43310:   // XXX: ideally we should initialize an accessible and then put it into tree,
43310:   // also this code should be shared between doc and root accessibles.
43310:   if (outerDocAcc) {
43310:     // Root document accessible doesn't have associated outerdoc accessible, it
43310:     // adds itself to application accessible instead.
43310:     NS_LOG_ACCDOCCREATE("append document to outerdoc", aDocument)
43310:     outerDocAcc->AppendChild(docAcc);
43310:   }
43310: 
43310:   if (!GetAccService()->InitAccessible(docAcc,
43504:                                        nsAccUtils::GetRoleMapEntry(aDocument))) {
43310:     mDocAccessibleCache.Remove(static_cast<void*>(aDocument));
43310:     return nsnull;
43310:   }
43310: 
43310:   NS_LOG_ACCDOCCREATE("document created", aDocument)
43310: 
43310:   AddListeners(aDocument, isRootDoc);
43310:   return docAcc;
43310: }
43310: 
43310: void
43310: nsAccDocManager::ShutdownDocAccessiblesInTree(nsIDocShellTreeItem *aTreeItem,
43310:                                               nsIDocument *aDocument)
43310: {
43310:   nsCOMPtr<nsIDocShellTreeNode> treeNode(do_QueryInterface(aTreeItem));
43310: 
43529:   if (treeNode) {
43310:     PRInt32 subDocumentsCount = 0;
43310:     treeNode->GetChildCount(&subDocumentsCount);
43310:     for (PRInt32 idx = 0; idx < subDocumentsCount; idx++) {
43310:       nsCOMPtr<nsIDocShellTreeItem> treeItemChild;
43310:       treeNode->GetChildAt(idx, getter_AddRefs(treeItemChild));
43310:       NS_ASSERTION(treeItemChild, "No tree item when there should be");
43310:       if (!treeItemChild)
43310:         continue;
43310: 
43310:       nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(treeItemChild));
43310:       nsCOMPtr<nsIContentViewer> contentViewer;
43310:       docShell->GetContentViewer(getter_AddRefs(contentViewer));
43310:       if (!contentViewer)
43310:         continue;
43310: 
43310:       ShutdownDocAccessiblesInTree(treeItemChild, contentViewer->GetDocument());
43310:     }
43529:   }
43310: 
43310:   ShutdownDocAccessible(aDocument);
43310: }
43310: 
43310: void
43310: nsAccDocManager::ShutdownDocAccessible(nsIDocument *aDocument)
43310: {
43310:   RemoveListeners(aDocument);
43310: 
43310:   nsDocAccessible *docAccessible =
43310:     mDocAccessibleCache.GetWeak(static_cast<void*>(aDocument));
43310:   if (docAccessible)
43310:     docAccessible->Shutdown();
43310: 
43310:   mDocAccessibleCache.Remove(static_cast<void*>(aDocument));
43310: }
43310: 
43310: ////////////////////////////////////////////////////////////////////////////////
43310: // nsAccDocManager static
43310: 
43310: PLDHashOperator
43310: nsAccDocManager::ClearDocCacheEntry(const void* aKey,
43310:                                     nsRefPtr<nsDocAccessible>& aDocAccessible,
43310:                                     void* aUserArg)
43310: {
43310:   nsAccDocManager *accDocMgr = static_cast<nsAccDocManager*>(aUserArg);
43310: 
43310:   NS_ASSERTION(aDocAccessible,
43310:                "Calling ClearDocCacheEntry with a NULL pointer!");
43310: 
43310:   if (aDocAccessible) {
43310:     nsCOMPtr<nsIDocument> document = aDocAccessible->GetDOMDocument();
43310:     NS_ASSERTION(document, "Document accessible was shutdown already!");
43310:     if (document)
43310:       accDocMgr->RemoveListeners(document);
43310: 
43310:     aDocAccessible->Shutdown();
43310:   }
43310: 
43310:   return PL_DHASH_REMOVE;
43310: }
43310: 
43310: PLDHashOperator
43310: nsAccDocManager::SearchAccessibleInDocCache(const void* aKey,
43310:                                             nsDocAccessible* aDocAccessible,
43310:                                             void* aUserArg)
43310: {
43310:   NS_ASSERTION(aDocAccessible,
43310:                "No doc accessible for the object in doc accessible cache!");
43310: 
43310:   if (aDocAccessible) {
43310:     nsSearchAccessibleInCacheArg* arg =
43310:       static_cast<nsSearchAccessibleInCacheArg*>(aUserArg);
43538:     arg->mAccessible = aDocAccessible->GetCachedAccessible(arg->mUniqueID);
43538:     if (arg->mAccessible)
43310:       return PL_DHASH_STOP;
43310:   }
43310: 
43310:   return PL_DHASH_NEXT;
43310: }
