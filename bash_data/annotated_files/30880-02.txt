    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   David Hyatt (hyatt@netscape.com)
    1:  *   Mats Palmgren <mats.palmgren@bredband.net>
15268:  *   Michael Ventnor <m.ventnor@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * structs that contain the data provided by nsStyleContext, the
    1:  * internal API for computed style data for an element
    1:  */
    1: 
    1: #include "nsStyleStruct.h"
15992: #include "nsStyleStructInlines.h"
    1: #include "nsStyleConsts.h"
 5690: #include "nsThemeConstants.h"
    1: #include "nsString.h"
    1: #include "nsPresContext.h"
    1: #include "nsIDeviceContext.h"
26846: #include "nsIWidget.h"
    1: #include "nsIStyleRule.h"
    1: #include "nsCRT.h"
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIFrame.h"
    1: #include "nsHTMLReflowState.h"
    1: #include "prenv.h"
    1: 
    1: #include "nsBidiUtils.h"
    1: 
    1: #include "imgIRequest.h"
 6732: #include "prlog.h"
 6732: 
 6732: // Make sure we have enough bits in NS_STYLE_INHERIT_MASK.
 6732: PR_STATIC_ASSERT((((1 << nsStyleStructID_Length) - 1) &
 6732:                   ~(NS_STYLE_INHERIT_MASK)) == 0);
    1: 
    1: inline PRBool IsFixedUnit(nsStyleUnit aUnit, PRBool aEnumOK)
    1: {
 1364:   return PRBool((aUnit == eStyleUnit_Coord) || 
    1:                 (aEnumOK && (aUnit == eStyleUnit_Enumerated)));
    1: }
    1: 
    1: static PRBool EqualURIs(nsIURI *aURI1, nsIURI *aURI2)
    1: {
    1:   PRBool eq;
    1:   return aURI1 == aURI2 ||    // handle null==null, and optimize
    1:          (aURI1 && aURI2 &&
    1:           NS_SUCCEEDED(aURI1->Equals(aURI2, &eq)) && // not equal on fail
    1:           eq);
    1: }
    1: 
 3645: static PRBool EqualURIs(nsCSSValue::URL *aURI1, nsCSSValue::URL *aURI2)
 3645: {
 3645:   return aURI1 == aURI2 ||    // handle null==null, and optimize
 3645:          (aURI1 && aURI2 && aURI1->URIEquals(*aURI2));
 3645: }
 3645: 
    1: static PRBool EqualImages(imgIRequest *aImage1, imgIRequest* aImage2)
    1: {
    1:   if (aImage1 == aImage2) {
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   if (!aImage1 || !aImage2) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> uri1, uri2;
    1:   aImage1->GetURI(getter_AddRefs(uri1));
    1:   aImage2->GetURI(getter_AddRefs(uri2));
    1:   return EqualURIs(uri1, uri2);
    1: }
    1: 
15699: static nsChangeHint CalcShadowDifference(nsCSSShadowArray* lhs,
15699:                                          nsCSSShadowArray* rhs);
15699: 
    1: // --------------------
    1: // nsStyleFont
    1: //
10073: nsStyleFont::nsStyleFont(const nsFont& aFont, nsPresContext *aPresContext)
10073:   : mFont(aFont),
20260:     mGenericID(kGenericFont_NONE)
10073: {
10073:   mSize = mFont.size = nsStyleFont::ZoomText(aPresContext, mFont.size);
10073: #ifdef MOZ_MATHML
10073:   mScriptUnconstrainedSize = mSize;
10073:   mScriptMinSize = aPresContext->TwipsToAppUnits(
10073:       NS_POINTS_TO_TWIPS(NS_MATHML_DEFAULT_SCRIPT_MIN_SIZE_PT));
10073:   mScriptLevel = 0;
10073:   mScriptSizeMultiplier = NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER;
10073: #endif
10073: }
10028: 
10073: nsStyleFont::nsStyleFont(const nsStyleFont& aSrc)
10073:   : mFont(aSrc.mFont)
10073:   , mSize(aSrc.mSize)
20260:   , mGenericID(aSrc.mGenericID)
10073: #ifdef MOZ_MATHML
10073:   , mScriptLevel(aSrc.mScriptLevel)
10073:   , mScriptUnconstrainedSize(aSrc.mScriptUnconstrainedSize)
11852:   , mScriptMinSize(aSrc.mScriptMinSize)
10073:   , mScriptSizeMultiplier(aSrc.mScriptSizeMultiplier)
10073: #endif
10026: {
10026: }
    1: 
    1: nsStyleFont::nsStyleFont(nsPresContext* aPresContext)
10073:   : mFont(*(aPresContext->GetDefaultFont(kPresContext_DefaultVariableFont_ID))),
20260:     mGenericID(kGenericFont_NONE)
    1: {
    1:   mSize = mFont.size = nsStyleFont::ZoomText(aPresContext, mFont.size);
10073: #ifdef MOZ_MATHML
10073:   mScriptUnconstrainedSize = mSize;
10073:   mScriptMinSize = aPresContext->TwipsToAppUnits(
10073:       NS_POINTS_TO_TWIPS(NS_MATHML_DEFAULT_SCRIPT_MIN_SIZE_PT));
10073:   mScriptLevel = 0;
10073:   mScriptSizeMultiplier = NS_MATHML_DEFAULT_SCRIPT_SIZE_MULTIPLIER;
10073: #endif
    1: }
    1: 
    1: void* 
    1: nsStyleFont::operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:   void* result = aContext->AllocateFromShell(sz);
    1:   if (result)
    1:     memset(result, 0, sz);
    1:   return result;
    1: }
    1:   
    1: void 
    1: nsStyleFont::Destroy(nsPresContext* aContext) {
    1:   this->~nsStyleFont();
    1:   aContext->FreeToShell(sizeof(nsStyleFont), this);
    1: }
    1: 
    1: nsChangeHint nsStyleFont::CalcDifference(const nsStyleFont& aOther) const
    1: {
    1:   if (mSize == aOther.mSize) {
    1:     return CalcFontDifference(mFont, aOther.mFont);
    1:   }
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleFont::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: #endif
    1: 
    1: /* static */ nscoord
    1: nsStyleFont::ZoomText(nsPresContext *aPresContext, nscoord aSize)
    1: {
    1:   return nscoord(float(aSize) * aPresContext->TextZoom());
    1: }
    1: 
    1: /* static */ nscoord
    1: nsStyleFont::UnZoomText(nsPresContext *aPresContext, nscoord aSize)
    1: {
    1:   return nscoord(float(aSize) / aPresContext->TextZoom());
    1: }
    1: 
    1: nsChangeHint nsStyleFont::CalcFontDifference(const nsFont& aFont1, const nsFont& aFont2)
    1: {
    1:   if ((aFont1.size == aFont2.size) && 
    1:       (aFont1.sizeAdjust == aFont2.sizeAdjust) && 
    1:       (aFont1.style == aFont2.style) &&
    1:       (aFont1.variant == aFont2.variant) &&
    1:       (aFont1.familyNameQuirks == aFont2.familyNameQuirks) &&
    1:       (aFont1.weight == aFont2.weight) &&
24408:       (aFont1.stretch == aFont2.stretch) &&
    1:       (aFont1.name == aFont2.name)) {
    1:     if ((aFont1.decorations == aFont2.decorations)) {
    1:       return NS_STYLE_HINT_NONE;
    1:     }
    1:     return NS_STYLE_HINT_VISUAL;
    1:   }
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: 
    1: static PRBool IsFixedData(const nsStyleSides& aSides, PRBool aEnumOK)
    1: {
    1:   NS_FOR_CSS_SIDES(side) {
    1:     if (!IsFixedUnit(aSides.GetUnit(side), aEnumOK))
    1:       return PR_FALSE;
    1:   }
    1:   return PR_TRUE;
    1: }
    1: 
    1: static nscoord CalcCoord(const nsStyleCoord& aCoord, 
    1:                          const nscoord* aEnumTable, 
    1:                          PRInt32 aNumEnums)
    1: {
    1:   switch (aCoord.GetUnit()) {
    1:     case eStyleUnit_Coord:
    1:       return aCoord.GetCoordValue();
    1:     case eStyleUnit_Enumerated:
    1:       if (nsnull != aEnumTable) {
    1:         PRInt32 value = aCoord.GetIntValue();
    1:         if ((0 <= value) && (value < aNumEnums)) {
    1:           return aEnumTable[aCoord.GetIntValue()];
    1:         }
    1:       }
    1:       break;
    1:     default:
    1:       NS_ERROR("bad unit type");
    1:       break;
    1:   }
    1:   return 0;
    1: }
    1: 
    1: nsStyleMargin::nsStyleMargin() {
 1361:   nsStyleCoord zero(0);
 1361:   NS_FOR_CSS_SIDES(side) {
 1361:     mMargin.Set(side, zero);
 1361:   }
    1:   mHasCachedMargin = PR_FALSE;
    1: }
    1: 
    1: nsStyleMargin::nsStyleMargin(const nsStyleMargin& aSrc) {
    1:   mMargin = aSrc.mMargin;
    1:   mHasCachedMargin = PR_FALSE;
    1: }
    1: 
    1: void* 
    1: nsStyleMargin::operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:   void* result = aContext->AllocateFromShell(sz);
    1:   if (result)
    1:     memset(result, 0, sz);
    1:   return result;
    1: }
    1:   
    1: void 
    1: nsStyleMargin::Destroy(nsPresContext* aContext) {
    1:   this->~nsStyleMargin();
    1:   aContext->FreeToShell(sizeof(nsStyleMargin), this);
    1: }
    1: 
    1: 
    1: void nsStyleMargin::RecalcData()
    1: {
    1:   if (IsFixedData(mMargin, PR_FALSE)) {
    1:     NS_FOR_CSS_SIDES(side) {
12630:       mCachedMargin.side(side) = CalcCoord(mMargin.Get(side), nsnull, 0);
    1:     }
    1:     mHasCachedMargin = PR_TRUE;
    1:   }
    1:   else
    1:     mHasCachedMargin = PR_FALSE;
    1: }
    1: 
    1: nsChangeHint nsStyleMargin::CalcDifference(const nsStyleMargin& aOther) const
    1: {
    1:   if (mMargin == aOther.mMargin) {
    1:     return NS_STYLE_HINT_NONE;
    1:   }
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleMargin::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: #endif
    1: 
    1: nsStylePadding::nsStylePadding() {
 1361:   nsStyleCoord zero(0);
 1361:   NS_FOR_CSS_SIDES(side) {
 1361:     mPadding.Set(side, zero);
 1361:   }
    1:   mHasCachedPadding = PR_FALSE;
    1: }
    1: 
    1: nsStylePadding::nsStylePadding(const nsStylePadding& aSrc) {
    1:   mPadding = aSrc.mPadding;
    1:   mHasCachedPadding = PR_FALSE;
    1: }
    1: 
    1: void* 
    1: nsStylePadding::operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:   void* result = aContext->AllocateFromShell(sz);
    1:   if (result)
    1:     memset(result, 0, sz);
    1:   return result;
    1: }
    1:   
    1: void 
    1: nsStylePadding::Destroy(nsPresContext* aContext) {
    1:   this->~nsStylePadding();
    1:   aContext->FreeToShell(sizeof(nsStylePadding), this);
    1: }
    1: 
    1: void nsStylePadding::RecalcData()
    1: {
    1:   if (IsFixedData(mPadding, PR_FALSE)) {
    1:     NS_FOR_CSS_SIDES(side) {
12630:       mCachedPadding.side(side) = CalcCoord(mPadding.Get(side), nsnull, 0);
    1:     }
    1:     mHasCachedPadding = PR_TRUE;
    1:   }
    1:   else
    1:     mHasCachedPadding = PR_FALSE;
    1: }
    1: 
    1: nsChangeHint nsStylePadding::CalcDifference(const nsStylePadding& aOther) const
    1: {
    1:   if (mPadding == aOther.mPadding) {
    1:     return NS_STYLE_HINT_NONE;
    1:   }
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStylePadding::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: #endif
    1: 
    1: nsStyleBorder::nsStyleBorder(nsPresContext* aPresContext)
15992:   : mHaveBorderImageWidth(PR_FALSE),
15992:     mComputedBorder(0, 0, 0, 0),
15992:     mBorderImage(nsnull)
    1: {
    1:   nscoord medium =
    1:     (aPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM];
    1:   NS_FOR_CSS_SIDES(side) {
    1:     mBorder.side(side) = medium;
    1:     mBorderStyle[side] = NS_STYLE_BORDER_STYLE_NONE | BORDER_COLOR_FOREGROUND;
    1:     mBorderColor[side] = NS_RGB(0, 0, 0);
20039:   }
20039:   NS_FOR_CSS_HALF_CORNERS(corner) {
20039:     mBorderRadius.Set(corner, nsStyleCoord(0));
    1:   }
    1: 
    1:   mBorderColors = nsnull;
15699:   mBoxShadow = nsnull;
    1: 
    1:   mFloatEdge = NS_STYLE_FLOAT_EDGE_CONTENT;
    1: 
    1:   mTwipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
    1: }
    1: 
20563: nsBorderColors::~nsBorderColors()
20563: {
20563:   NS_CSS_DELETE_LIST_MEMBER(nsBorderColors, this, mNext);
20563: }
20563: 
20563: nsBorderColors*
20563: nsBorderColors::Clone(PRBool aDeep) const
20563: {
20563:   nsBorderColors* result = new nsBorderColors(mColor);
20563:   if (NS_UNLIKELY(!result))
20563:     return result;
20563:   if (aDeep)
20563:     NS_CSS_CLONE_LIST_MEMBER(nsBorderColors, this, mNext, result, (PR_FALSE));
20563:   return result;
20563: }
20563: 
    1: nsStyleBorder::nsStyleBorder(const nsStyleBorder& aSrc)
15992:   : mBorderRadius(aSrc.mBorderRadius),
15992:     mBorderImageSplit(aSrc.mBorderImageSplit),
15992:     mFloatEdge(aSrc.mFloatEdge),
15992:     mBorderImageHFill(aSrc.mBorderImageHFill),
15992:     mBorderImageVFill(aSrc.mBorderImageVFill),
20563:     mBorderColors(nsnull),
15992:     mBoxShadow(aSrc.mBoxShadow),
15992:     mHaveBorderImageWidth(aSrc.mHaveBorderImageWidth),
15992:     mBorderImageWidth(aSrc.mBorderImageWidth),
15992:     mComputedBorder(aSrc.mComputedBorder),
15991:     mBorder(aSrc.mBorder),
15992:     mBorderImage(aSrc.mBorderImage),
15992:     mTwipsPerPixel(aSrc.mTwipsPerPixel)
    1: {
    1:   if (aSrc.mBorderColors) {
    1:     EnsureBorderColors();
    1:     for (PRInt32 i = 0; i < 4; i++)
    1:       if (aSrc.mBorderColors[i])
20563:         mBorderColors[i] = aSrc.mBorderColors[i]->Clone();
    1:       else
    1:         mBorderColors[i] = nsnull;
    1:   }
15699: 
15699:   NS_FOR_CSS_SIDES(side) {
15699:     mBorderStyle[side] = aSrc.mBorderStyle[side];
15699:     mBorderColor[side] = aSrc.mBorderColor[side];
15699:   }
20039:   NS_FOR_CSS_HALF_CORNERS(corner) {
20039:     mBorderRadius.Set(corner, aSrc.mBorderRadius.Get(corner));
20039:   }
    1: }
    1: 
15992: nsStyleBorder::~nsStyleBorder()
15992: {
15992:   if (mBorderColors) {
15992:     for (PRInt32 i = 0; i < 4; i++)
15992:       delete mBorderColors[i];
15992:     delete [] mBorderColors;
15992:   }
15992: }
15992: 
    1: void* 
    1: nsStyleBorder::operator new(size_t sz, nsPresContext* aContext) CPP_THROW_NEW {
    1:   void* result = aContext->AllocateFromShell(sz);
    1:   if (result)
    1:     memset(result, 0, sz);
    1:   return result;
    1: }
    1:   
    1: void 
    1: nsStyleBorder::Destroy(nsPresContext* aContext) {
    1:   this->~nsStyleBorder();
    1:   aContext->FreeToShell(sizeof(nsStyleBorder), this);
    1: }
    1: 
    1: 
    1: nsChangeHint nsStyleBorder::CalcDifference(const nsStyleBorder& aOther) const
    1: {
21206:   nsChangeHint shadowDifference =
21206:     CalcShadowDifference(mBoxShadow, aOther.mBoxShadow);
21206: 
    1:   // Note that differences in mBorder don't affect rendering (which should only
    1:   // use mComputedBorder), so don't need to be tested for here.
21206:   if (mTwipsPerPixel != aOther.mTwipsPerPixel ||
21206:       GetActualBorder() != aOther.GetActualBorder() || 
21206:       mFloatEdge != aOther.mFloatEdge ||
21206:       (shadowDifference & nsChangeHint_ReflowFrame))
21206:     return NS_STYLE_HINT_REFLOW;
21206: 
    1:   // Note that mBorderStyle stores not only the border style but also
    1:   // color-related flags.  Given that we've already done an mComputedBorder
    1:   // comparison, border-style differences can only lead to a VISUAL hint.  So
    1:   // it's OK to just compare the values directly -- if either the actual
    1:   // style or the color flags differ we want to repaint.
    1:   NS_FOR_CSS_SIDES(ix) {
    1:     if (mBorderStyle[ix] != aOther.mBorderStyle[ix] || 
21206:         mBorderColor[ix] != aOther.mBorderColor[ix])
    1:       return NS_STYLE_HINT_VISUAL;
    1:   }
    1: 
    1:   if (mBorderRadius != aOther.mBorderRadius ||
21206:       !mBorderColors != !aOther.mBorderColors)
    1:     return NS_STYLE_HINT_VISUAL;
    1: 
16232:   if (IsBorderImageLoaded() || aOther.IsBorderImageLoaded()) {
16232:     if (mBorderImage != aOther.mBorderImage ||
16232:         mBorderImageHFill != aOther.mBorderImageHFill ||
16232:         mBorderImageVFill != aOther.mBorderImageVFill ||
21206:         mBorderImageSplit != aOther.mBorderImageSplit)
16232:       return NS_STYLE_HINT_VISUAL;
16232:     // The call to GetActualBorder above already considered
16232:     // mBorderImageWidth and mHaveBorderImageWidth.
16232:   }
16232: 
    1:   // Note that at this point if mBorderColors is non-null so is
    1:   // aOther.mBorderColors
    1:   if (mBorderColors) {
    1:     NS_FOR_CSS_SIDES(ix) {
19182:       if (!nsBorderColors::Equal(mBorderColors[ix],
21206:                                  aOther.mBorderColors[ix]))
    1:         return NS_STYLE_HINT_VISUAL;
    1:     }
    1:   }
    1: 
21206:   return shadowDifference;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleBorder::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: #endif
    1: 
15992: PRBool
15992: nsStyleBorder::ImageBorderDiffers() const
15992: {
15992:   return mComputedBorder !=
15992:            (mHaveBorderImageWidth ? mBorderImageWidth : mBorder);
15992: }
15992: 
15992: const nsMargin&
15992: nsStyleBorder::GetActualBorder() const
15992: {
15992:   if (IsBorderImageLoaded())
15992:     if (mHaveBorderImageWidth)
15992:       return mBorderImageWidth;
15992:     else
15992:       return mBorder;
15992:   else
15992:     return mComputedBorder;
15992: }
15992: 
    1: nsStyleOutline::nsStyleOutline(nsPresContext* aPresContext)
    1: {
    1:   // spacing values not inherited
    1:   nsStyleCoord zero(0);
20039:   NS_FOR_CSS_HALF_CORNERS(corner) {
20039:     mOutlineRadius.Set(corner, zero);
    1:   }
    1: 
19205:   mOutlineOffset = 0;
    1: 
    1:   mOutlineWidth = nsStyleCoord(NS_STYLE_BORDER_WIDTH_MEDIUM, eStyleUnit_Enumerated);
    1:   mOutlineStyle = NS_STYLE_BORDER_STYLE_NONE;
    1:   mOutlineColor = NS_RGB(0, 0, 0);
    1: 
    1:   mHasCachedOutline = PR_FALSE;
    1:   mTwipsPerPixel = aPresContext->DevPixelsToAppUnits(1);
    1: }
    1: 
    1: nsStyleOutline::nsStyleOutline(const nsStyleOutline& aSrc) {
    1:   memcpy((nsStyleOutline*)this, &aSrc, sizeof(nsStyleOutline));
    1: }
    1: 
    1: void 
    1: nsStyleOutline::RecalcData(nsPresContext* aContext)
    1: {
    1:   if (NS_STYLE_BORDER_STYLE_NONE == GetOutlineStyle()) {
    1:     mCachedOutlineWidth = 0;
    1:     mHasCachedOutline = PR_TRUE;
    1:   } else if (IsFixedUnit(mOutlineWidth.GetUnit(), PR_TRUE)) {
    1:     mCachedOutlineWidth =
    1:       CalcCoord(mOutlineWidth, aContext->GetBorderWidthTable(), 3);
    1:     mCachedOutlineWidth =
    1:       NS_ROUND_BORDER_TO_PIXELS(mCachedOutlineWidth, mTwipsPerPixel);
    1:     mHasCachedOutline = PR_TRUE;
    1:   }
    1:   else
    1:     mHasCachedOutline = PR_FALSE;
    1: }
    1: 
    1: nsChangeHint nsStyleOutline::CalcDifference(const nsStyleOutline& aOther) const
    1: {
    1:   PRBool outlineWasVisible =
    1:     mCachedOutlineWidth > 0 && mOutlineStyle != NS_STYLE_BORDER_STYLE_NONE;
    1:   PRBool outlineIsVisible = 
    1:     aOther.mCachedOutlineWidth > 0 && aOther.mOutlineStyle != NS_STYLE_BORDER_STYLE_NONE;
    1:   if (outlineWasVisible != outlineIsVisible ||
    1:       (outlineIsVisible && (mOutlineOffset != aOther.mOutlineOffset ||
    1:                             mOutlineWidth != aOther.mOutlineWidth ||
    1:                             mTwipsPerPixel != aOther.mTwipsPerPixel))) {
    1:     return NS_CombineHint(nsChangeHint_ReflowFrame, nsChangeHint_RepaintFrame);
    1:   }
    1:   if ((mOutlineStyle != aOther.mOutlineStyle) ||
    1:       (mOutlineColor != aOther.mOutlineColor) ||
    1:       (mOutlineRadius != aOther.mOutlineRadius)) {
    1:     return nsChangeHint_RepaintFrame;
    1:   }
    1:   return NS_STYLE_HINT_NONE;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleOutline::MaxDifference()
    1: {
    1:   return NS_CombineHint(nsChangeHint_ReflowFrame, nsChangeHint_RepaintFrame);
    1: }
    1: #endif
    1: 
    1: // --------------------
    1: // nsStyleList
    1: //
    1: nsStyleList::nsStyleList() 
    1:   : mListStyleType(NS_STYLE_LIST_STYLE_DISC),
    1:     mListStylePosition(NS_STYLE_LIST_STYLE_POSITION_OUTSIDE)
    1: {
    1: }
    1: 
    1: nsStyleList::~nsStyleList() 
    1: {
    1: }
    1: 
    1: nsStyleList::nsStyleList(const nsStyleList& aSource)
    1:   : mListStyleType(aSource.mListStyleType),
    1:     mListStylePosition(aSource.mListStylePosition),
    1:     mListStyleImage(aSource.mListStyleImage),
    1:     mImageRegion(aSource.mImageRegion)
    1: {
    1: }
    1: 
    1: nsChangeHint nsStyleList::CalcDifference(const nsStyleList& aOther) const
    1: {
    1:   if (mListStylePosition != aOther.mListStylePosition)
    1:     return NS_STYLE_HINT_FRAMECHANGE;
    1:   if (EqualImages(mListStyleImage, aOther.mListStyleImage) &&
    1:       mListStyleType == aOther.mListStyleType) {
    1:     if (mImageRegion == aOther.mImageRegion)
    1:       return NS_STYLE_HINT_NONE;
    1:     if (mImageRegion.width == aOther.mImageRegion.width &&
    1:         mImageRegion.height == aOther.mImageRegion.height)
    1:       return NS_STYLE_HINT_VISUAL;
    1:   }
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleList::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: #endif
    1: 
    1: // --------------------
    1: // nsStyleXUL
    1: //
    1: nsStyleXUL::nsStyleXUL() 
    1: { 
    1:   mBoxAlign  = NS_STYLE_BOX_ALIGN_STRETCH;
    1:   mBoxDirection = NS_STYLE_BOX_DIRECTION_NORMAL;
    1:   mBoxFlex = 0.0f;
    1:   mBoxOrient = NS_STYLE_BOX_ORIENT_HORIZONTAL;
    1:   mBoxPack   = NS_STYLE_BOX_PACK_START;
    1:   mBoxOrdinal = 1;
15260:   mStretchStack = PR_TRUE;
    1: }
    1: 
    1: nsStyleXUL::~nsStyleXUL() 
    1: {
    1: }
    1: 
    1: nsStyleXUL::nsStyleXUL(const nsStyleXUL& aSource)
    1: {
    1:   memcpy((nsStyleXUL*)this, &aSource, sizeof(nsStyleXUL));
    1: }
    1: 
    1: nsChangeHint nsStyleXUL::CalcDifference(const nsStyleXUL& aOther) const
    1: {
    1:   if (mBoxAlign == aOther.mBoxAlign &&
    1:       mBoxDirection == aOther.mBoxDirection &&
    1:       mBoxFlex == aOther.mBoxFlex &&
    1:       mBoxOrient == aOther.mBoxOrient &&
    1:       mBoxPack == aOther.mBoxPack &&
    1:       mBoxOrdinal == aOther.mBoxOrdinal)
    1:     return NS_STYLE_HINT_NONE;
    1:   if (mBoxOrdinal != aOther.mBoxOrdinal)
    1:     return NS_STYLE_HINT_FRAMECHANGE;
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleXUL::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: #endif
    1: 
    1: // --------------------
    1: // nsStyleColumn
    1: //
16055: nsStyleColumn::nsStyleColumn(nsPresContext* aPresContext)
    1: {
    1:   mColumnCount = NS_STYLE_COLUMN_COUNT_AUTO;
    1:   mColumnWidth.SetAutoValue();
    1:   mColumnGap.SetNormalValue();
16055: 
16055:   mColumnRuleWidth = (aPresContext->GetBorderWidthTable())[NS_STYLE_BORDER_WIDTH_MEDIUM];
16055:   mColumnRuleStyle = NS_STYLE_BORDER_STYLE_NONE;
16055:   mColumnRuleColor = NS_RGB(0, 0, 0);
16055:   mColumnRuleColorIsForeground = PR_TRUE;
16055: 
16055:   mTwipsPerPixel = aPresContext->AppUnitsPerDevPixel();
    1: }
    1: 
    1: nsStyleColumn::~nsStyleColumn() 
    1: {
    1: }
    1: 
    1: nsStyleColumn::nsStyleColumn(const nsStyleColumn& aSource)
    1: {
    1:   memcpy((nsStyleColumn*)this, &aSource, sizeof(nsStyleColumn));
    1: }
    1: 
    1: nsChangeHint nsStyleColumn::CalcDifference(const nsStyleColumn& aOther) const
    1: {
    1:   if ((mColumnWidth.GetUnit() == eStyleUnit_Auto)
    1:       != (aOther.mColumnWidth.GetUnit() == eStyleUnit_Auto) ||
    1:       mColumnCount != aOther.mColumnCount)
    1:     // We force column count changes to do a reframe, because it's tricky to handle
    1:     // some edge cases where the column count gets smaller and content overflows.
    1:     // XXX not ideal
16055:     return NS_STYLE_HINT_FRAMECHANGE;
    1: 
    1:   if (mColumnWidth != aOther.mColumnWidth ||
    1:       mColumnGap != aOther.mColumnGap)
16055:     return NS_STYLE_HINT_REFLOW;
16055: 
16055:   if (GetComputedColumnRuleWidth() != aOther.GetComputedColumnRuleWidth() ||
16055:       mColumnRuleStyle != aOther.mColumnRuleStyle ||
16055:       mColumnRuleColor != aOther.mColumnRuleColor ||
16055:       mColumnRuleColorIsForeground != aOther.mColumnRuleColorIsForeground)
16055:     return NS_STYLE_HINT_VISUAL;
    1: 
    1:   return NS_STYLE_HINT_NONE;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleColumn::MaxDifference()
    1: {
16055:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: #endif
    1: 
    1: #ifdef MOZ_SVG
    1: // --------------------
    1: // nsStyleSVG
    1: //
    1: nsStyleSVG::nsStyleSVG() 
    1: {
    1:     mFill.mType              = eStyleSVGPaintType_Color;
    1:     mFill.mPaint.mColor      = NS_RGB(0,0,0);
    1:     mFill.mFallbackColor     = NS_RGB(0,0,0);
    1:     mStroke.mType            = eStyleSVGPaintType_None;
    1:     mStroke.mPaint.mColor    = NS_RGB(0,0,0);
    1:     mStroke.mFallbackColor   = NS_RGB(0,0,0);
    1:     mStrokeDasharray         = nsnull;
    1: 
 3735:     mStrokeDashoffset.SetCoordValue(0);
 3735:     mStrokeWidth.SetCoordValue(nsPresContext::CSSPixelsToAppUnits(1));
    1: 
    1:     mFillOpacity             = 1.0f;
    1:     mStrokeMiterlimit        = 4.0f;
    1:     mStrokeOpacity           = 1.0f;
    1: 
    1:     mStrokeDasharrayLength   = 0;
    1:     mClipRule                = NS_STYLE_FILL_RULE_NONZERO;
    1:     mColorInterpolation      = NS_STYLE_COLOR_INTERPOLATION_SRGB;
    1:     mColorInterpolationFilters = NS_STYLE_COLOR_INTERPOLATION_LINEARRGB;
    1:     mFillRule                = NS_STYLE_FILL_RULE_NONZERO;
26449:     mImageRendering          = NS_STYLE_IMAGE_RENDERING_AUTO;
    1:     mPointerEvents           = NS_STYLE_POINTER_EVENTS_VISIBLEPAINTED;
    1:     mShapeRendering          = NS_STYLE_SHAPE_RENDERING_AUTO;
    1:     mStrokeLinecap           = NS_STYLE_STROKE_LINECAP_BUTT;
    1:     mStrokeLinejoin          = NS_STYLE_STROKE_LINEJOIN_MITER;
    1:     mTextAnchor              = NS_STYLE_TEXT_ANCHOR_START;
    1:     mTextRendering           = NS_STYLE_TEXT_RENDERING_AUTO;
    1: }
    1: 
    1: nsStyleSVG::~nsStyleSVG() 
    1: {
    1:   delete [] mStrokeDasharray;
    1: }
    1: 
    1: nsStyleSVG::nsStyleSVG(const nsStyleSVG& aSource)
    1: {
    1:   //memcpy((nsStyleSVG*)this, &aSource, sizeof(nsStyleSVG));
    1: 
    1:   mFill = aSource.mFill;
    1:   mStroke = aSource.mStroke;
    1: 
    1:   mMarkerEnd = aSource.mMarkerEnd;
    1:   mMarkerMid = aSource.mMarkerMid;
 3735:   mMarkerStart = aSource.mMarkerStart;
    1: 
    1:   mStrokeDasharrayLength = aSource.mStrokeDasharrayLength;
    1:   if (aSource.mStrokeDasharray) {
    1:     mStrokeDasharray = new nsStyleCoord[mStrokeDasharrayLength];
    1:     if (mStrokeDasharray)
    1:       memcpy(mStrokeDasharray,
    1:              aSource.mStrokeDasharray,
    1:              mStrokeDasharrayLength * sizeof(nsStyleCoord));
    1:     else
    1:       mStrokeDasharrayLength = 0;
    1:   } else {
    1:     mStrokeDasharray = nsnull;
    1:   }
    1: 
    1:   mStrokeDashoffset = aSource.mStrokeDashoffset;
    1:   mStrokeWidth = aSource.mStrokeWidth;
    1: 
    1:   mFillOpacity = aSource.mFillOpacity;
    1:   mStrokeMiterlimit = aSource.mStrokeMiterlimit;
    1:   mStrokeOpacity = aSource.mStrokeOpacity;
    1: 
    1:   mClipRule = aSource.mClipRule;
    1:   mColorInterpolation = aSource.mColorInterpolation;
    1:   mColorInterpolationFilters = aSource.mColorInterpolationFilters;
    1:   mFillRule = aSource.mFillRule;
26449:   mImageRendering = aSource.mImageRendering;
    1:   mPointerEvents = aSource.mPointerEvents;
    1:   mShapeRendering = aSource.mShapeRendering;
    1:   mStrokeLinecap = aSource.mStrokeLinecap;
    1:   mStrokeLinejoin = aSource.mStrokeLinejoin;
    1:   mTextAnchor = aSource.mTextAnchor;
    1:   mTextRendering = aSource.mTextRendering;
    1: }
    1: 
19948: static PRBool PaintURIChanged(const nsStyleSVGPaint& aPaint1,
19948:                               const nsStyleSVGPaint& aPaint2)
19948: {
19948:   if (aPaint1.mType != aPaint2.mType) {
19948:     return aPaint1.mType == eStyleSVGPaintType_Server ||
19948:            aPaint2.mType == eStyleSVGPaintType_Server;
19948:   }
19948:   return aPaint1.mType == eStyleSVGPaintType_Server &&
19948:     !EqualURIs(aPaint1.mPaint.mPaintServer, aPaint2.mPaint.mPaintServer);
19948: }
19948: 
    1: nsChangeHint nsStyleSVG::CalcDifference(const nsStyleSVG& aOther) const
    1: {
19948:   nsChangeHint hint = nsChangeHint(0);
19948: 
19948:   if (mTextRendering != aOther.mTextRendering) {
19948:     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
19948:     // May be needed for non-svg frames
19948:     NS_UpdateHint(hint, nsChangeHint_ReflowFrame);
19948:   }
19948: 
24030:   if (!EqualURIs(mMarkerEnd, aOther.mMarkerEnd) ||
24030:       !EqualURIs(mMarkerMid, aOther.mMarkerMid) ||
24030:       !EqualURIs(mMarkerStart, aOther.mMarkerStart)) {
24030:     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
24030:     NS_UpdateHint(hint, nsChangeHint_UpdateEffects);
24030:     return hint;
24030:   }
24030: 
19914:   if (mFill != aOther.mFill ||
19948:       mStroke != aOther.mStroke) {
19948:     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
19948:     if (PaintURIChanged(mFill, aOther.mFill) ||
19948:         PaintURIChanged(mStroke, aOther.mStroke)) {
19948:       NS_UpdateHint(hint, nsChangeHint_UpdateEffects);
19948:     }
19948:     // Nothing more to do, below we can only set "repaint"
19948:     return hint;
19948:   }
19908: 
24030:   if ( mStrokeDashoffset      != aOther.mStrokeDashoffset      ||
    1:        mStrokeWidth           != aOther.mStrokeWidth           ||
    1: 
    1:        mFillOpacity           != aOther.mFillOpacity           ||
    1:        mStrokeMiterlimit      != aOther.mStrokeMiterlimit      ||
    1:        mStrokeOpacity         != aOther.mStrokeOpacity         ||
    1: 
    1:        mClipRule              != aOther.mClipRule              ||
    1:        mColorInterpolation    != aOther.mColorInterpolation    ||
    1:        mColorInterpolationFilters != aOther.mColorInterpolationFilters ||
    1:        mFillRule              != aOther.mFillRule              ||
26449:        mImageRendering        != aOther.mImageRendering        ||
    1:        mShapeRendering        != aOther.mShapeRendering        ||
    1:        mStrokeDasharrayLength != aOther.mStrokeDasharrayLength ||
    1:        mStrokeLinecap         != aOther.mStrokeLinecap         ||
    1:        mStrokeLinejoin        != aOther.mStrokeLinejoin        ||
19948:        mTextAnchor            != aOther.mTextAnchor) {
19948:     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
19948:     return hint;
19948:   }
    1: 
    1:   // length of stroke dasharrays are the same (tested above) - check entries
    1:   for (PRUint32 i=0; i<mStrokeDasharrayLength; i++)
19948:     if (mStrokeDasharray[i] != aOther.mStrokeDasharray[i]) {
19948:       NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
19948:       return hint;
19948:     }
    1: 
19948:   return hint;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleSVG::MaxDifference()
    1: {
19948:   return NS_CombineHint(NS_CombineHint(nsChangeHint_UpdateEffects,
19948:                                        nsChangeHint_ReflowFrame),
19948:                                        nsChangeHint_RepaintFrame);
    1: }
    1: #endif
    1: 
    1: // --------------------
    1: // nsStyleSVGReset
    1: //
    1: nsStyleSVGReset::nsStyleSVGReset() 
    1: {
    1:     mStopColor               = NS_RGB(0,0,0);
    1:     mFloodColor              = NS_RGB(0,0,0);
 4029:     mLightingColor           = NS_RGB(255,255,255);
    1:     mClipPath                = nsnull;
    1:     mFilter                  = nsnull;
    1:     mMask                    = nsnull;
    1:     mStopOpacity             = 1.0f;
    1:     mFloodOpacity            = 1.0f;
    1:     mDominantBaseline        = NS_STYLE_DOMINANT_BASELINE_AUTO;
    1: }
    1: 
    1: nsStyleSVGReset::~nsStyleSVGReset() 
    1: {
    1: }
    1: 
    1: nsStyleSVGReset::nsStyleSVGReset(const nsStyleSVGReset& aSource)
    1: {
    1:   mStopColor = aSource.mStopColor;
    1:   mFloodColor = aSource.mFloodColor;
 4029:   mLightingColor = aSource.mLightingColor;
    1:   mClipPath = aSource.mClipPath;
    1:   mFilter = aSource.mFilter;
    1:   mMask = aSource.mMask;
    1:   mStopOpacity = aSource.mStopOpacity;
    1:   mFloodOpacity = aSource.mFloodOpacity;
    1:   mDominantBaseline = aSource.mDominantBaseline;
    1: }
    1: 
    1: nsChangeHint nsStyleSVGReset::CalcDifference(const nsStyleSVGReset& aOther) const
    1: {
16411:   nsChangeHint hint = nsChangeHint(0);
16411: 
16411:   if (!EqualURIs(mClipPath, aOther.mClipPath) ||
16411:       !EqualURIs(mFilter, aOther.mFilter)     ||
16411:       !EqualURIs(mMask, aOther.mMask)) {
16411:     NS_UpdateHint(hint, nsChangeHint_UpdateEffects);
16411:     NS_UpdateHint(hint, nsChangeHint_ReflowFrame);
16411:     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
19948:   } else if (mStopColor        != aOther.mStopColor     ||
    1:              mFloodColor       != aOther.mFloodColor    ||
 4029:              mLightingColor    != aOther.mLightingColor ||
    1:              mStopOpacity      != aOther.mStopOpacity   ||
    1:              mFloodOpacity     != aOther.mFloodOpacity  ||
    1:              mDominantBaseline != aOther.mDominantBaseline)
16411:     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
    1: 
16411:   return hint;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleSVGReset::MaxDifference()
    1: {
16411:   return NS_CombineHint(NS_CombineHint(nsChangeHint_UpdateEffects,
16411:                                        nsChangeHint_ReflowFrame),
16411:                                        nsChangeHint_RepaintFrame);
    1: }
    1: #endif
    1: 
    1: // nsStyleSVGPaint implementation
 7041: nsStyleSVGPaint::~nsStyleSVGPaint()
 7041: {
    1:   if (mType == eStyleSVGPaintType_Server) {
    1:     NS_IF_RELEASE(mPaint.mPaintServer);
    1:   }
    1: }
    1: 
 7041: void
 7041: nsStyleSVGPaint::SetType(nsStyleSVGPaintType aType)
 7041: {
 7041:   if (mType == eStyleSVGPaintType_Server) {
 7041:     this->~nsStyleSVGPaint();
 7041:     new (this) nsStyleSVGPaint();
 7041:   }
 7041:   mType = aType;
 7041: }
 7041: 
    1: nsStyleSVGPaint& nsStyleSVGPaint::operator=(const nsStyleSVGPaint& aOther) 
    1: {
 7041:   if (this == &aOther)
 7041:     return *this;
 7041: 
 7041:   SetType(aOther.mType);
 7041: 
    1:   mFallbackColor = aOther.mFallbackColor;
    1:   if (mType == eStyleSVGPaintType_Server) {
    1:     mPaint.mPaintServer = aOther.mPaint.mPaintServer;
    1:     NS_IF_ADDREF(mPaint.mPaintServer);
    1:   } else {
    1:     mPaint.mColor = aOther.mPaint.mColor;
    1:   }
    1:   return *this;
    1: }
    1: 
    1: PRBool nsStyleSVGPaint::operator==(const nsStyleSVGPaint& aOther) const
    1: {
    1:   if (mType != aOther.mType)
    1:     return PR_FALSE;
    1:   if (mType == eStyleSVGPaintType_Server)
    1:     return EqualURIs(mPaint.mPaintServer, aOther.mPaint.mPaintServer) &&
    1:            mFallbackColor == aOther.mFallbackColor;
    1:   if (mType == eStyleSVGPaintType_None)
    1:     return PR_TRUE;
    1:   return mPaint.mColor == aOther.mPaint.mColor;
    1: }
    1: 
    1: #endif // MOZ_SVG
    1: 
    1: 
    1: // --------------------
    1: // nsStylePosition
    1: //
    1: nsStylePosition::nsStylePosition(void) 
    1: { 
    1:   // positioning values not inherited
    1:   nsStyleCoord  autoCoord(eStyleUnit_Auto);
    1:   mOffset.SetLeft(autoCoord);
    1:   mOffset.SetTop(autoCoord);
    1:   mOffset.SetRight(autoCoord);
    1:   mOffset.SetBottom(autoCoord);
    1:   mWidth.SetAutoValue();
    1:   mMinWidth.SetCoordValue(0);
 1363:   mMaxWidth.SetNoneValue();
    1:   mHeight.SetAutoValue();
    1:   mMinHeight.SetCoordValue(0);
 1363:   mMaxHeight.SetNoneValue();
    1:   mBoxSizing = NS_STYLE_BOX_SIZING_CONTENT;
    1:   mZIndex.SetAutoValue();
    1: }
    1: 
    1: nsStylePosition::~nsStylePosition(void) 
    1: { 
    1: }
    1: 
    1: nsStylePosition::nsStylePosition(const nsStylePosition& aSource)
    1: {
    1:   memcpy((nsStylePosition*)this, &aSource, sizeof(nsStylePosition));
    1: }
    1: 
    1: nsChangeHint nsStylePosition::CalcDifference(const nsStylePosition& aOther) const
    1: {
    1:   if (mZIndex != aOther.mZIndex) {
    1:     return NS_STYLE_HINT_REFLOW;
    1:   }
    1:   
    1:   if ((mOffset == aOther.mOffset) &&
    1:       (mWidth == aOther.mWidth) &&
    1:       (mMinWidth == aOther.mMinWidth) &&
    1:       (mMaxWidth == aOther.mMaxWidth) &&
    1:       (mHeight == aOther.mHeight) &&
    1:       (mMinHeight == aOther.mMinHeight) &&
    1:       (mMaxHeight == aOther.mMaxHeight) &&
    1:       (mBoxSizing == aOther.mBoxSizing))
    1:     return NS_STYLE_HINT_NONE;
    1:   
    1:   return nsChangeHint_ReflowFrame;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStylePosition::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: #endif
    1: 
    1: // --------------------
    1: // nsStyleTable
    1: //
    1: 
    1: nsStyleTable::nsStyleTable() 
    1: { 
    1:   // values not inherited
    1:   mLayoutStrategy = NS_STYLE_TABLE_LAYOUT_AUTO;
    1:   mCols  = NS_STYLE_TABLE_COLS_NONE;
    1:   mFrame = NS_STYLE_TABLE_FRAME_NONE;
    1:   mRules = NS_STYLE_TABLE_RULES_NONE;
    1:   mSpan = 1;
    1: }
    1: 
    1: nsStyleTable::~nsStyleTable(void) 
    1: { 
    1: }
    1: 
    1: nsStyleTable::nsStyleTable(const nsStyleTable& aSource)
    1: {
    1:   memcpy((nsStyleTable*)this, &aSource, sizeof(nsStyleTable));
    1: }
    1: 
    1: nsChangeHint nsStyleTable::CalcDifference(const nsStyleTable& aOther) const
    1: {
    1:   // Changes in mRules may require reframing (if border-collapse stuff changes, for example).
11412:   if (mRules != aOther.mRules || mSpan != aOther.mSpan ||
11412:       mLayoutStrategy != aOther.mLayoutStrategy)
    1:     return NS_STYLE_HINT_FRAMECHANGE;
11412:   if (mFrame != aOther.mFrame || mCols != aOther.mCols)
11412:     return NS_STYLE_HINT_REFLOW;
    1:   return NS_STYLE_HINT_NONE;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleTable::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: #endif
    1: 
    1: // -----------------------
    1: // nsStyleTableBorder
    1: 
    1: nsStyleTableBorder::nsStyleTableBorder(nsPresContext* aPresContext) 
    1: { 
    1:   mBorderCollapse = NS_STYLE_BORDER_SEPARATE;
    1: 
    1:   nsCompatibility compatMode = eCompatibility_FullStandards;
    1:   if (aPresContext)
    1:     compatMode = aPresContext->CompatibilityMode();
    1:   mEmptyCells = (compatMode == eCompatibility_NavQuirks)
    1:                   ? NS_STYLE_TABLE_EMPTY_CELLS_SHOW_BACKGROUND     
    1:                   : NS_STYLE_TABLE_EMPTY_CELLS_SHOW;
12309:   mCaptionSide = NS_STYLE_CAPTION_SIDE_TOP;
19206:   mBorderSpacingX = 0;
19206:   mBorderSpacingY = 0;
    1: }
    1: 
    1: nsStyleTableBorder::~nsStyleTableBorder(void) 
    1: { 
    1: }
    1: 
    1: nsStyleTableBorder::nsStyleTableBorder(const nsStyleTableBorder& aSource)
    1: {
    1:   memcpy((nsStyleTableBorder*)this, &aSource, sizeof(nsStyleTableBorder));
    1: }
    1: 
    1: nsChangeHint nsStyleTableBorder::CalcDifference(const nsStyleTableBorder& aOther) const
    1: {
    1:   // Border-collapse changes need a reframe, because we use a different frame
    1:   // class for table cells in the collapsed border model.  This is used to
    1:   // conserve memory when using the separated border model (collapsed borders
    1:   // require extra state to be stored).
    1:   if (mBorderCollapse != aOther.mBorderCollapse) {
    1:     return NS_STYLE_HINT_FRAMECHANGE;
    1:   }
    1:   
    1:   if ((mCaptionSide == aOther.mCaptionSide) &&
    1:       (mBorderSpacingX == aOther.mBorderSpacingX) &&
    1:       (mBorderSpacingY == aOther.mBorderSpacingY)) {
    1:     if (mEmptyCells == aOther.mEmptyCells)
    1:       return NS_STYLE_HINT_NONE;
    1:     return NS_STYLE_HINT_VISUAL;
    1:   }
    1:   else
    1:     return NS_STYLE_HINT_REFLOW;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleTableBorder::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: #endif
    1: 
    1: // --------------------
    1: // nsStyleColor
    1: //
    1: 
    1: nsStyleColor::nsStyleColor(nsPresContext* aPresContext)
    1: {
    1:   mColor = aPresContext->DefaultColor();
    1: }
    1: 
    1: nsStyleColor::nsStyleColor(const nsStyleColor& aSource)
    1: {
    1:   mColor = aSource.mColor;
    1: }
    1: 
    1: nsChangeHint nsStyleColor::CalcDifference(const nsStyleColor& aOther) const
    1: {
    1:   if (mColor == aOther.mColor)
    1:     return NS_STYLE_HINT_NONE;
    1:   return NS_STYLE_HINT_VISUAL;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleColor::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_VISUAL;
    1: }
    1: #endif
    1: 
    1: // --------------------
    1: // nsStyleBackground
    1: //
    1: 
19182: nsStyleBackground::nsStyleBackground()
25276:   : mAttachmentCount(1)
25276:   , mClipCount(1)
25276:   , mOriginCount(1)
25276:   , mRepeatCount(1)
25276:   , mPositionCount(1)
25276:   , mImageCount(1)
25276:   , mBackgroundColor(NS_RGBA(0, 0, 0, 0))
25276:   , mBackgroundInlinePolicy(NS_STYLE_BG_INLINE_POLICY_CONTINUOUS)
    1: {
25276:   Layer *onlyLayer = mLayers.AppendElement();
25276:   NS_ASSERTION(onlyLayer, "auto array must have room for 1 element");
25276:   onlyLayer->SetInitialValues();
    1: }
    1: 
    1: nsStyleBackground::nsStyleBackground(const nsStyleBackground& aSource)
25276:   : mAttachmentCount(aSource.mAttachmentCount)
25276:   , mClipCount(aSource.mClipCount)
25276:   , mOriginCount(aSource.mOriginCount)
25276:   , mRepeatCount(aSource.mRepeatCount)
25276:   , mPositionCount(aSource.mPositionCount)
25276:   , mImageCount(aSource.mImageCount)
25276:   , mLayers(aSource.mLayers) // deep copy
25276:   , mBackgroundColor(aSource.mBackgroundColor)
25276:   , mBackgroundInlinePolicy(aSource.mBackgroundInlinePolicy)
    1: {
25276:   // If the deep copy of mLayers failed, truncate the counts.
25276:   PRUint32 count = mLayers.Length();
25276:   if (count != aSource.mLayers.Length()) {
25276:     NS_WARNING("truncating counts due to out-of-memory");
25276:     mAttachmentCount = PR_MAX(mAttachmentCount, count);
25276:     mClipCount = PR_MAX(mClipCount, count);
25276:     mOriginCount = PR_MAX(mOriginCount, count);
25276:     mRepeatCount = PR_MAX(mRepeatCount, count);
25276:     mPositionCount = PR_MAX(mPositionCount, count);
25276:     mImageCount = PR_MAX(mImageCount, count);
25276:   }
    1: }
    1: 
    1: nsStyleBackground::~nsStyleBackground()
    1: {
    1: }
    1: 
    1: nsChangeHint nsStyleBackground::CalcDifference(const nsStyleBackground& aOther) const
    1: {
25276:   if (mBackgroundColor != aOther.mBackgroundColor ||
25276:       mBackgroundInlinePolicy != aOther.mBackgroundInlinePolicy ||
25276:       mImageCount != aOther.mImageCount)
25276:     return NS_STYLE_HINT_VISUAL;
25276: 
25276:   // We checked the image count above.
25276:   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, this) {
25276:     if (mLayers[i] != aOther.mLayers[i])
25276:       return NS_STYLE_HINT_VISUAL;
25276:   }
25276: 
25246:   return NS_STYLE_HINT_NONE;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleBackground::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_VISUAL;
    1: }
    1: #endif
    1: 
    1: PRBool nsStyleBackground::HasFixedBackground() const
    1: {
25276:   NS_FOR_VISIBLE_BACKGROUND_LAYERS_BACK_TO_FRONT(i, this) {
25276:     const Layer &layer = mLayers[i];
29266:     if (layer.mAttachment == NS_STYLE_BG_ATTACHMENT_FIXED && layer.mImage) {
25276:       return PR_TRUE;
25276:     }
25276:   }
25276:   return PR_FALSE;
25276: }
25276: 
25276: PRBool nsStyleBackground::IsTransparent() const
25276: {
29266:   return !BottomLayer().mImage && mImageCount == 1 &&
25276:          NS_GET_A(mBackgroundColor) == 0;
25276: }
25276: 
25276: void
25276: nsStyleBackground::Position::SetInitialValues()
25276: {
25276:   mXPosition.mFloat = 0.0f;
25276:   mYPosition.mFloat = 0.0f;
25276:   mXIsPercent = PR_TRUE;
25276:   mYIsPercent = PR_TRUE;
25276: }
25276: 
25276: nsStyleBackground::Layer::Layer()
25276: {
25276: }
25276: 
25276: nsStyleBackground::Layer::~Layer()
25276: {
25276: }
25276: 
25276: void
25276: nsStyleBackground::Layer::SetInitialValues()
25276: {
25276:   mAttachment = NS_STYLE_BG_ATTACHMENT_SCROLL;
25276:   mClip = NS_STYLE_BG_CLIP_BORDER;
25276:   mOrigin = NS_STYLE_BG_ORIGIN_PADDING;
25276:   mRepeat = NS_STYLE_BG_REPEAT_XY;
25276:   mPosition.SetInitialValues();
29266:   mImage = nsnull;
25276: }
25276: 
25276: PRBool nsStyleBackground::Layer::operator==(const Layer& aOther) const
25276: {
25276:   return mAttachment == aOther.mAttachment &&
25276:          mClip == aOther.mClip &&
25276:          mOrigin == aOther.mOrigin &&
25276:          mRepeat == aOther.mRepeat &&
25276:          mPosition == aOther.mPosition &&
29266:          EqualImages(mImage, aOther.mImage);
    1: }
    1: 
    1: // --------------------
    1: // nsStyleDisplay
    1: //
    1: 
    1: nsStyleDisplay::nsStyleDisplay()
    1: {
 5690:   mAppearance = NS_THEME_NONE;
    1:   mDisplay = NS_STYLE_DISPLAY_INLINE;
    1:   mOriginalDisplay = NS_STYLE_DISPLAY_NONE;
    1:   mPosition = NS_STYLE_POSITION_STATIC;
    1:   mFloats = NS_STYLE_FLOAT_NONE;
    1:   mBreakType = NS_STYLE_CLEAR_NONE;
    1:   mBreakBefore = PR_FALSE;
    1:   mBreakAfter = PR_FALSE;
    1:   mOverflowX = NS_STYLE_OVERFLOW_VISIBLE;
    1:   mOverflowY = NS_STYLE_OVERFLOW_VISIBLE;
    1:   mClipFlags = NS_STYLE_CLIP_AUTO;
    1:   mClip.SetRect(0,0,0,0);
    1:   mOpacity = 1.0f;
19214:   mTransformPresent = PR_FALSE; // No transform
19214:   mTransformOrigin[0].SetPercentValue(0.5f); // Transform is centered on origin
19214:   mTransformOrigin[1].SetPercentValue(0.5f); 
    1: }
    1: 
    1: nsStyleDisplay::nsStyleDisplay(const nsStyleDisplay& aSource)
    1: {
    1:   mAppearance = aSource.mAppearance;
    1:   mDisplay = aSource.mDisplay;
    1:   mOriginalDisplay = aSource.mOriginalDisplay;
    1:   mBinding = aSource.mBinding;
    1:   mPosition = aSource.mPosition;
    1:   mFloats = aSource.mFloats;
    1:   mBreakType = aSource.mBreakType;
    1:   mBreakBefore = aSource.mBreakBefore;
    1:   mBreakAfter = aSource.mBreakAfter;
    1:   mOverflowX = aSource.mOverflowX;
    1:   mOverflowY = aSource.mOverflowY;
    1:   mClipFlags = aSource.mClipFlags;
    1:   mClip = aSource.mClip;
    1:   mOpacity = aSource.mOpacity;
19214: 
19214:   /* Copy over the transformation information. */
19214:   mTransformPresent = aSource.mTransformPresent;
19214:   if (mTransformPresent)
19214:     mTransform = aSource.mTransform;
19214:   
19214:   /* Copy over transform origin. */
19214:   mTransformOrigin[0] = aSource.mTransformOrigin[0];
19214:   mTransformOrigin[1] = aSource.mTransformOrigin[1];
    1: }
    1: 
    1: nsChangeHint nsStyleDisplay::CalcDifference(const nsStyleDisplay& aOther) const
    1: {
    1:   nsChangeHint hint = nsChangeHint(0);
    1: 
    1:   if (!EqualURIs(mBinding, aOther.mBinding)
    1:       || mPosition != aOther.mPosition
    1:       || mDisplay != aOther.mDisplay
    1:       || (mFloats == NS_STYLE_FLOAT_NONE) != (aOther.mFloats == NS_STYLE_FLOAT_NONE)
    1:       || mOverflowX != aOther.mOverflowX
    1:       || mOverflowY != aOther.mOverflowY)
    1:     NS_UpdateHint(hint, nsChangeHint_ReconstructFrame);
    1: 
    1:   if (mFloats != aOther.mFloats)
    1:     NS_UpdateHint(hint, nsChangeHint_ReflowFrame);    
    1: 
  134:   if (mClipFlags != aOther.mClipFlags || mClip != aOther.mClip) {
  134:     NS_UpdateHint(hint, nsChangeHint_ReflowFrame);
  134:   }
    1:   // XXX the following is conservative, for now: changing float breaking shouldn't
    1:   // necessarily require a repaint, reflow should suffice.
    1:   if (mBreakType != aOther.mBreakType
    1:       || mBreakBefore != aOther.mBreakBefore
    1:       || mBreakAfter != aOther.mBreakAfter
    1:       || mAppearance != aOther.mAppearance)
    1:     NS_UpdateHint(hint, NS_CombineHint(nsChangeHint_ReflowFrame, nsChangeHint_RepaintFrame));
    1: 
  134:   if (mOpacity != aOther.mOpacity)
    1:     NS_UpdateHint(hint, nsChangeHint_RepaintFrame);
    1: 
19214:   /* If we've added or removed the transform property, we need to reconstruct the frame to add
19214:    * or remove the view object, and also to handle abs-pos and fixed-pos containers.
19214:    */
19214:   if (mTransformPresent != aOther.mTransformPresent) {
19214:     NS_UpdateHint(hint, nsChangeHint_ReconstructFrame);
19214:   }
19214:   else if (mTransformPresent) {
19214:     /* Otherwise, if we've kept the property lying around and we already had a
19214:      * transform, we need to see whether or not we've changed the transform.
19214:      * If so, we need to do a reflow and a repaint. The reflow is to recompute
19214:      * the overflow rect (which probably changed if the transform changed)
19214:      * and to redraw within the bounds of that new overflow rect.
19214:      */
19214:     if (mTransform != aOther.mTransform)
19214:       NS_UpdateHint(hint, NS_CombineHint(nsChangeHint_ReflowFrame,
19214:                                          nsChangeHint_RepaintFrame));
19214:     
19214:     for (PRUint8 index = 0; index < 2; ++index)
19214:       if (mTransformOrigin[index] != aOther.mTransformOrigin[index]) {
19214:         NS_UpdateHint(hint, NS_CombineHint(nsChangeHint_ReflowFrame,
19214:                                            nsChangeHint_RepaintFrame));
19214:         break;
19214:       }
19214:   }
19214:   
19214:   
    1:   return hint;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleDisplay::MaxDifference()
    1: {
    1:   // All the parts of FRAMECHANGE are present above in CalcDifference.
    1:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: #endif
    1: 
    1: // --------------------
    1: // nsStyleVisibility
    1: //
    1: 
    1: nsStyleVisibility::nsStyleVisibility(nsPresContext* aPresContext)
    1: {
    1:   PRUint32 bidiOptions = aPresContext->GetBidi();
    1:   if (GET_BIDI_OPTION_DIRECTION(bidiOptions) == IBMBIDI_TEXTDIRECTION_RTL)
    1:     mDirection = NS_STYLE_DIRECTION_RTL;
    1:   else
    1:     mDirection = NS_STYLE_DIRECTION_LTR;
    1: 
    1:   mLangGroup = aPresContext->GetLangGroup();
    1:   mVisible = NS_STYLE_VISIBILITY_VISIBLE;
    1: }
    1: 
    1: nsStyleVisibility::nsStyleVisibility(const nsStyleVisibility& aSource)
    1: {
    1:   mDirection = aSource.mDirection;
    1:   mVisible = aSource.mVisible;
    1:   mLangGroup = aSource.mLangGroup;
    1: } 
    1: 
    1: nsChangeHint nsStyleVisibility::CalcDifference(const nsStyleVisibility& aOther) const
    1: {
    1:   if ((mDirection == aOther.mDirection) &&
    1:       (mLangGroup == aOther.mLangGroup)) {
    1:     if ((mVisible == aOther.mVisible)) {
    1:       return NS_STYLE_HINT_NONE;
    1:     }
    1:     if ((NS_STYLE_VISIBILITY_COLLAPSE == mVisible) || 
    1:         (NS_STYLE_VISIBILITY_COLLAPSE == aOther.mVisible)) {
    1:       return NS_STYLE_HINT_REFLOW;
    1:     }
    1:     return NS_STYLE_HINT_VISUAL;
    1:   }
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleVisibility::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: #endif
    1: 
    1: nsStyleContentData::~nsStyleContentData()
    1: {
    1:   if (mType == eStyleContentType_Image) {
    1:     NS_IF_RELEASE(mContent.mImage);
    1:   } else if (mType == eStyleContentType_Counter ||
    1:              mType == eStyleContentType_Counters) {
    1:     mContent.mCounters->Release();
    1:   } else if (mContent.mString) {
    1:     NS_Free(mContent.mString);
    1:   }
    1: }
    1: 
    1: nsStyleContentData& nsStyleContentData::operator=(const nsStyleContentData& aOther)
    1: {
    1:   if (this == &aOther)
    1:     return *this;
    1:   this->~nsStyleContentData();
 7041:   new (this) nsStyleContentData();
 7041: 
    1:   mType = aOther.mType;
    1:   if (mType == eStyleContentType_Image) {
    1:     mContent.mImage = aOther.mContent.mImage;
    1:     NS_IF_ADDREF(mContent.mImage);
    1:   } else if (mType == eStyleContentType_Counter ||
    1:              mType == eStyleContentType_Counters) {
    1:     mContent.mCounters = aOther.mContent.mCounters;
    1:     mContent.mCounters->AddRef();
    1:   } else if (aOther.mContent.mString) {
    1:     mContent.mString = NS_strdup(aOther.mContent.mString);
    1:   } else {
    1:     mContent.mString = nsnull;
    1:   }
    1:   return *this;
    1: }
    1: 
    1: PRBool nsStyleContentData::operator==(const nsStyleContentData& aOther) const
    1: {
    1:   if (mType != aOther.mType)
    1:     return PR_FALSE;
    1:   if (mType == eStyleContentType_Image) {
    1:     if (!mContent.mImage || !aOther.mContent.mImage)
    1:       return mContent.mImage == aOther.mContent.mImage;
    1:     PRBool eq;
    1:     nsCOMPtr<nsIURI> thisURI, otherURI;
    1:     mContent.mImage->GetURI(getter_AddRefs(thisURI));
    1:     aOther.mContent.mImage->GetURI(getter_AddRefs(otherURI));
    1:     return thisURI == otherURI ||  // handles null==null
    1:            (thisURI && otherURI &&
    1:             NS_SUCCEEDED(thisURI->Equals(otherURI, &eq)) &&
    1:             eq);
    1:   }
    1:   if (mType == eStyleContentType_Counter ||
    1:       mType == eStyleContentType_Counters)
    1:     return *mContent.mCounters == *aOther.mContent.mCounters;
    1:   return nsCRT::strcmp(mContent.mString, aOther.mContent.mString) == 0;
    1: }
    1: 
    1: //-----------------------
    1: // nsStyleContent
    1: //
    1: 
    1: nsStyleContent::nsStyleContent(void)
    1:   : mMarkerOffset(),
28329:     mContents(nsnull),
28329:     mIncrements(nsnull),
28329:     mResets(nsnull),
    1:     mContentCount(0),
    1:     mIncrementCount(0),
28329:     mResetCount(0)
    1: {
 1361:   mMarkerOffset.SetAutoValue();
    1: }
    1: 
    1: nsStyleContent::~nsStyleContent(void)
    1: {
    1:   DELETE_ARRAY_IF(mContents);
    1:   DELETE_ARRAY_IF(mIncrements);
    1:   DELETE_ARRAY_IF(mResets);
    1: }
    1: 
    1: nsStyleContent::nsStyleContent(const nsStyleContent& aSource)
    1:    :mMarkerOffset(),
28329:     mContents(nsnull),
28329:     mIncrements(nsnull),
28329:     mResets(nsnull),
    1:     mContentCount(0),
    1:     mIncrementCount(0),
28329:     mResetCount(0)
    1: 
    1: {
    1:   mMarkerOffset = aSource.mMarkerOffset;
    1: 
    1:   PRUint32 index;
    1:   if (NS_SUCCEEDED(AllocateContents(aSource.ContentCount()))) {
    1:     for (index = 0; index < mContentCount; index++) {
    1:       ContentAt(index) = aSource.ContentAt(index);
    1:     }
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(AllocateCounterIncrements(aSource.CounterIncrementCount()))) {
    1:     for (index = 0; index < mIncrementCount; index++) {
    1:       const nsStyleCounterData *data = aSource.GetCounterIncrementAt(index);
    1:       mIncrements[index].mCounter = data->mCounter;
    1:       mIncrements[index].mValue = data->mValue;
    1:     }
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(AllocateCounterResets(aSource.CounterResetCount()))) {
    1:     for (index = 0; index < mResetCount; index++) {
    1:       const nsStyleCounterData *data = aSource.GetCounterResetAt(index);
    1:       mResets[index].mCounter = data->mCounter;
    1:       mResets[index].mValue = data->mValue;
    1:     }
    1:   }
    1: }
    1: 
    1: nsChangeHint nsStyleContent::CalcDifference(const nsStyleContent& aOther) const
    1: {
    1:   if (mContentCount != aOther.mContentCount ||
    1:       mIncrementCount != aOther.mIncrementCount || 
    1:       mResetCount != aOther.mResetCount) {
    1:     return NS_STYLE_HINT_FRAMECHANGE;
    1:   }
    1: 
    1:   PRUint32 ix = mContentCount;
    1:   while (0 < ix--) {
    1:     if (mContents[ix] != aOther.mContents[ix]) {
    1:       // Unfortunately we need to reframe here; a simple reflow
    1:       // will not pick up different text or different image URLs,
    1:       // since we set all that up in the CSSFrameConstructor
    1:       return NS_STYLE_HINT_FRAMECHANGE;
    1:     }
    1:   }
    1:   ix = mIncrementCount;
    1:   while (0 < ix--) {
    1:     if ((mIncrements[ix].mValue != aOther.mIncrements[ix].mValue) || 
    1:         (mIncrements[ix].mCounter != aOther.mIncrements[ix].mCounter)) {
    1:       return NS_STYLE_HINT_FRAMECHANGE;
    1:     }
    1:   }
    1:   ix = mResetCount;
    1:   while (0 < ix--) {
    1:     if ((mResets[ix].mValue != aOther.mResets[ix].mValue) || 
    1:         (mResets[ix].mCounter != aOther.mResets[ix].mCounter)) {
    1:       return NS_STYLE_HINT_FRAMECHANGE;
    1:     }
    1:   }
    1:   if (mMarkerOffset != aOther.mMarkerOffset) {
    1:     return NS_STYLE_HINT_REFLOW;
    1:   }
    1:   return NS_STYLE_HINT_NONE;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleContent::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: #endif
    1: 
    1: nsresult nsStyleContent::AllocateContents(PRUint32 aCount)
    1: {
 6352:   // We need to run the destructors of the elements of mContents, so we
 6352:   // delete and reallocate even if aCount == mContentCount.  (If
 6352:   // nsStyleContentData had its members private and managed their
 6352:   // ownership on setting, we wouldn't need this, but that seems
 6352:   // unnecessary at this point.)
    1:   DELETE_ARRAY_IF(mContents);
    1:   if (aCount) {
    1:     mContents = new nsStyleContentData[aCount];
    1:     if (! mContents) {
    1:       mContentCount = 0;
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1:   mContentCount = aCount;
    1:   return NS_OK;
    1: }
    1: 
    1: // ---------------------
    1: // nsStyleQuotes
    1: //
    1: 
    1: nsStyleQuotes::nsStyleQuotes(void)
    1:   : mQuotesCount(0),
    1:     mQuotes(nsnull)
    1: {
17037:   SetInitial();
    1: }
    1: 
    1: nsStyleQuotes::~nsStyleQuotes(void)
    1: {
    1:   DELETE_ARRAY_IF(mQuotes);
    1: }
    1: 
    1: nsStyleQuotes::nsStyleQuotes(const nsStyleQuotes& aSource)
    1:   : mQuotesCount(0),
    1:     mQuotes(nsnull)
    1: {
17037:   CopyFrom(aSource);
17037: }
17037: 
17037: void
17037: nsStyleQuotes::SetInitial()
17037: {
17037:   // The initial value for quotes is the en-US typographic convention:
17037:   // outermost are LEFT and RIGHT DOUBLE QUOTATION MARK, alternating
17037:   // with LEFT and RIGHT SINGLE QUOTATION MARK.
17037:   static const PRUnichar initialQuotes[8] = {
17037:     0x201C, 0, 0x201D, 0, 0x2018, 0, 0x2019, 0
17037:   };
17037:   
17037:   if (NS_SUCCEEDED(AllocateQuotes(2))) {
17037:     SetQuotesAt(0,
17037:                 nsDependentString(&initialQuotes[0], 1),
17037:                 nsDependentString(&initialQuotes[2], 1));
17037:     SetQuotesAt(1,
17037:                 nsDependentString(&initialQuotes[4], 1),
17037:                 nsDependentString(&initialQuotes[6], 1));
17037:   }
17037: }
17037: 
17037: void
17037: nsStyleQuotes::CopyFrom(const nsStyleQuotes& aSource)
17037: {
    1:   if (NS_SUCCEEDED(AllocateQuotes(aSource.QuotesCount()))) {
    1:     PRUint32 count = (mQuotesCount * 2);
    1:     for (PRUint32 index = 0; index < count; index += 2) {
    1:       aSource.GetQuotesAt(index, mQuotes[index], mQuotes[index + 1]);
    1:     }
    1:   }
    1: }
    1: 
    1: nsChangeHint nsStyleQuotes::CalcDifference(const nsStyleQuotes& aOther) const
    1: {
    1:   // If the quotes implementation is ever going to change we might not need
    1:   // a framechange here and a reflow should be sufficient.  See bug 35768.
    1:   if (mQuotesCount == aOther.mQuotesCount) {
    1:     PRUint32 ix = (mQuotesCount * 2);
    1:     while (0 < ix--) {
    1:       if (mQuotes[ix] != aOther.mQuotes[ix]) {
    1:         return NS_STYLE_HINT_FRAMECHANGE;
    1:       }
    1:     }
    1: 
    1:     return NS_STYLE_HINT_NONE;
    1:   }
    1:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleQuotes::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: #endif
    1: 
    1: // --------------------
    1: // nsStyleTextReset
    1: //
    1: 
    1: nsStyleTextReset::nsStyleTextReset(void) 
    1: { 
    1:   mVerticalAlign.SetIntValue(NS_STYLE_VERTICAL_ALIGN_BASELINE, eStyleUnit_Enumerated);
    1:   mTextDecoration = NS_STYLE_TEXT_DECORATION_NONE;
    1:   mUnicodeBidi = NS_STYLE_UNICODE_BIDI_NORMAL;
    1: }
    1: 
    1: nsStyleTextReset::nsStyleTextReset(const nsStyleTextReset& aSource) 
    1: { 
    1:   memcpy((nsStyleTextReset*)this, &aSource, sizeof(nsStyleTextReset));
    1: }
    1: 
    1: nsStyleTextReset::~nsStyleTextReset(void) { }
    1: 
    1: nsChangeHint nsStyleTextReset::CalcDifference(const nsStyleTextReset& aOther) const
    1: {
13714:   if (mVerticalAlign == aOther.mVerticalAlign
13714:       && mUnicodeBidi == aOther.mUnicodeBidi) {
13714:     if (mTextDecoration != aOther.mTextDecoration) {
13714:       // Reflow for blink changes, repaint for others
13714:       return
13714:         (mTextDecoration & NS_STYLE_TEXT_DECORATION_BLINK) ==
13714:         (aOther.mTextDecoration & NS_STYLE_TEXT_DECORATION_BLINK) ?
13714:           NS_STYLE_HINT_VISUAL : NS_STYLE_HINT_REFLOW;
13714:     }
13714: 
    1:     return NS_STYLE_HINT_NONE;
13714:   }
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleTextReset::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_REFLOW;
    1: }
    1: #endif
    1: 
    1: // --------------------
15699: // nsCSSShadowArray
15699: // nsCSSShadowItem
15268: //
15268: 
15268: nsrefcnt
15699: nsCSSShadowArray::Release()
15268: {
23136:   if (mRefCnt == PR_UINT32_MAX) {
23136:     NS_WARNING("refcount overflow, leaking object");
23136:     return mRefCnt;
23136:   }
15268:   mRefCnt--;
15268:   if (mRefCnt == 0) {
15268:     delete this;
15268:     return 0;
15268:   }
15268:   return mRefCnt;
15268: }
15268: 
21206: // Allowed to return one of NS_STYLE_HINT_NONE, NS_STYLE_HINT_REFLOW
21206: // or NS_STYLE_HINT_VISUAL. Currently we just return NONE or REFLOW, though.
15699: static nsChangeHint
15699: CalcShadowDifference(nsCSSShadowArray* lhs,
15699:                      nsCSSShadowArray* rhs)
15699: {
15699:   if (lhs == rhs)
15699:     return NS_STYLE_HINT_NONE;
15699: 
15699:   if (!lhs || !rhs || lhs->Length() != rhs->Length())
15699:     return NS_STYLE_HINT_REFLOW;
15699: 
15699:   for (PRUint32 i = 0; i < lhs->Length(); ++i) {
15699:     if (*lhs->ShadowAt(i) != *rhs->ShadowAt(i))
15699:       return NS_STYLE_HINT_REFLOW;
15699:   }
15699:   return NS_STYLE_HINT_NONE;
15699: }
15699: 
15268: // --------------------
    1: // nsStyleText
    1: //
    1: 
    1: nsStyleText::nsStyleText(void)
    1: { 
    1:   mTextAlign = NS_STYLE_TEXT_ALIGN_DEFAULT;
    1:   mTextTransform = NS_STYLE_TEXT_TRANSFORM_NONE;
    1:   mWhiteSpace = NS_STYLE_WHITESPACE_NORMAL;
16166:   mWordWrap = NS_STYLE_WORDWRAP_NORMAL;
    1: 
    1:   mLetterSpacing.SetNormalValue();
    1:   mLineHeight.SetNormalValue();
    1:   mTextIndent.SetCoordValue(0);
23137:   mWordSpacing = 0;
15268: 
15699:   mTextShadow = nsnull;
    1: }
    1: 
    1: nsStyleText::nsStyleText(const nsStyleText& aSource)
15268:   : mTextAlign(aSource.mTextAlign),
15268:     mTextTransform(aSource.mTextTransform),
15268:     mWhiteSpace(aSource.mWhiteSpace),
16166:     mWordWrap(aSource.mWordWrap),
15268:     mLetterSpacing(aSource.mLetterSpacing),
15268:     mLineHeight(aSource.mLineHeight),
15268:     mTextIndent(aSource.mTextIndent),
15268:     mWordSpacing(aSource.mWordSpacing),
15699:     mTextShadow(aSource.mTextShadow)
15268: { }
    1: 
    1: nsStyleText::~nsStyleText(void) { }
    1: 
    1: nsChangeHint nsStyleText::CalcDifference(const nsStyleText& aOther) const
    1: {
30880:   if (NewlineIsSignificant() != aOther.NewlineIsSignificant()) {
29501:     // This may require construction of suppressed text frames
29501:     return NS_STYLE_HINT_FRAMECHANGE;
29501:   }
29501: 
15268:   if ((mTextAlign != aOther.mTextAlign) ||
15268:       (mTextTransform != aOther.mTextTransform) ||
30880:       (mWhiteSpace != aOther.mWhiteSpace) ||
16166:       (mWordWrap != aOther.mWordWrap) ||
15268:       (mLetterSpacing != aOther.mLetterSpacing) ||
15268:       (mLineHeight != aOther.mLineHeight) ||
15268:       (mTextIndent != aOther.mTextIndent) ||
15268:       (mWordSpacing != aOther.mWordSpacing))
15268:     return NS_STYLE_HINT_REFLOW;
15268: 
15699:   return CalcShadowDifference(mTextShadow, aOther.mTextShadow);
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleText::MaxDifference()
    1: {
29501:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: #endif
    1: 
    1: //-----------------------
    1: // nsStyleUserInterface
    1: //
    1: 
    1: nsCursorImage::nsCursorImage()
    1:   : mHaveHotspot(PR_FALSE)
    1:   , mHotspotX(0.0f)
    1:   , mHotspotY(0.0f)
    1: {
    1: }
    1: 
    1: nsStyleUserInterface::nsStyleUserInterface(void) 
    1: { 
    1:   mUserInput = NS_STYLE_USER_INPUT_AUTO;
    1:   mUserModify = NS_STYLE_USER_MODIFY_READ_ONLY;
    1:   mUserFocus = NS_STYLE_USER_FOCUS_NONE;
    1: 
    1:   mCursor = NS_STYLE_CURSOR_AUTO; // fix for bugzilla bug 51113
    1: 
    1:   mCursorArrayLength = 0;
    1:   mCursorArray = nsnull;
    1: }
    1: 
    1: nsStyleUserInterface::nsStyleUserInterface(const nsStyleUserInterface& aSource) :
    1:   mUserInput(aSource.mUserInput),
    1:   mUserModify(aSource.mUserModify),
    1:   mUserFocus(aSource.mUserFocus),
    1:   mCursor(aSource.mCursor)
    1: { 
    1:   CopyCursorArrayFrom(aSource);
    1: }
    1: 
    1: nsStyleUserInterface::~nsStyleUserInterface(void) 
    1: { 
    1:   delete [] mCursorArray;
    1: }
    1: 
    1: nsChangeHint nsStyleUserInterface::CalcDifference(const nsStyleUserInterface& aOther) const
    1: {
    1:   nsChangeHint hint = nsChangeHint(0);
    1:   if (mCursor != aOther.mCursor)
    1:     NS_UpdateHint(hint, nsChangeHint_UpdateCursor);
    1: 
    1:   // We could do better. But it wouldn't be worth it, URL-specified cursors are
    1:   // rare.
    1:   if (mCursorArrayLength > 0 || aOther.mCursorArrayLength > 0)
    1:     NS_UpdateHint(hint, nsChangeHint_UpdateCursor);
    1: 
    1:   if (mUserModify != aOther.mUserModify)
    1:     NS_UpdateHint(hint, NS_STYLE_HINT_VISUAL);
    1:   
    1:   if ((mUserInput != aOther.mUserInput) &&
    1:       ((NS_STYLE_USER_INPUT_NONE == mUserInput) || 
    1:        (NS_STYLE_USER_INPUT_NONE == aOther.mUserInput))) {
    1:     NS_UpdateHint(hint, NS_STYLE_HINT_FRAMECHANGE);
    1:   }
    1: 
    1:   // ignore mUserFocus
    1: 
    1:   return hint;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleUserInterface::MaxDifference()
    1: {
    1:   return nsChangeHint(nsChangeHint_UpdateCursor | NS_STYLE_HINT_FRAMECHANGE);
    1: }
    1: #endif
    1: 
    1: void
    1: nsStyleUserInterface::CopyCursorArrayFrom(const nsStyleUserInterface& aSource)
    1: {
    1:   mCursorArray = nsnull;
    1:   mCursorArrayLength = 0;
    1:   if (aSource.mCursorArrayLength) {
    1:     mCursorArray = new nsCursorImage[aSource.mCursorArrayLength];
    1:     if (mCursorArray) {
    1:       mCursorArrayLength = aSource.mCursorArrayLength;
    1:       for (PRUint32 i = 0; i < mCursorArrayLength; ++i)
    1:         mCursorArray[i] = aSource.mCursorArray[i];
    1:     }
    1:   }
    1: }
    1: 
    1: //-----------------------
    1: // nsStyleUIReset
    1: //
    1: 
    1: nsStyleUIReset::nsStyleUIReset(void) 
    1: { 
    1:   mUserSelect = NS_STYLE_USER_SELECT_AUTO;
    1:   mForceBrokenImageIcon = 0;
 1520:   mIMEMode = NS_STYLE_IME_MODE_AUTO;
20464:   mWindowShadow = NS_STYLE_WINDOW_SHADOW_DEFAULT;
    1: }
    1: 
    1: nsStyleUIReset::nsStyleUIReset(const nsStyleUIReset& aSource) 
    1: {
    1:   mUserSelect = aSource.mUserSelect;
    1:   mForceBrokenImageIcon = aSource.mForceBrokenImageIcon;
 1520:   mIMEMode = aSource.mIMEMode;
20464:   mWindowShadow = aSource.mWindowShadow;
    1: }
    1: 
    1: nsStyleUIReset::~nsStyleUIReset(void) 
    1: { 
    1: }
    1: 
    1: nsChangeHint nsStyleUIReset::CalcDifference(const nsStyleUIReset& aOther) const
    1: {
 1520:   // ignore mIMEMode
20464:   if (mForceBrokenImageIcon != aOther.mForceBrokenImageIcon)
20464:     return NS_STYLE_HINT_FRAMECHANGE;
20464:   if (mWindowShadow != aOther.mWindowShadow) {
20464:     // We really need just an nsChangeHint_SyncFrameView, except
20464:     // on an ancestor of the frame, so we get that by doing a
20464:     // reflow.
20464:     return NS_STYLE_HINT_REFLOW;
20464:   }
20464:   if (mUserSelect != aOther.mUserSelect)
20464:     return NS_STYLE_HINT_VISUAL;
    1:   return NS_STYLE_HINT_NONE;
    1: }
    1: 
    1: #ifdef DEBUG
    1: /* static */
    1: nsChangeHint nsStyleUIReset::MaxDifference()
    1: {
    1:   return NS_STYLE_HINT_FRAMECHANGE;
    1: }
    1: #endif
    1: 
