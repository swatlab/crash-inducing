    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set ts=2 sw=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Mark Hammond <mhammond@skippinet.com.au>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsJSEnvironment.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIScriptObjectPrincipal.h"
    1: #include "nsIDOMChromeWindow.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDOMNode.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMText.h"
    1: #include "nsIDOMAttr.h"
    1: #include "nsIDOMNamedNodeMap.h"
    1: #include "nsIDOMNodeList.h"
    1: #include "nsIDOMKeyEvent.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIDOMHTMLOptionElement.h"
    1: #include "nsIScriptSecurityManager.h"
    1: #include "nsDOMCID.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIXPConnect.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIJSRuntimeService.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsISupportsPrimitives.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsJSUtils.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsPresContext.h"
    1: #include "nsIConsoleService.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIPrompt.h"
    1: #include "nsIObserverService.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsITimer.h"
    1: #include "nsIAtom.h"
    1: #include "nsContentUtils.h"
33405: #include "jscntxt.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsIContent.h"
    1: #include "nsCycleCollector.h"
 3275: #include "nsNetUtil.h"
23546: #include "nsXPCOMCIDInternal.h"
23546: #include "nsIXULRuntime.h"
    1: 
    1: // For locale aware string methods
    1: #include "plstr.h"
    1: #include "nsIPlatformCharset.h"
    1: #include "nsICharsetConverterManager.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsILocaleService.h"
    1: #include "nsICollation.h"
    1: #include "nsCollationCID.h"
    1: #include "nsDOMClassInfo.h"
    1: 
    1: #include "jsdbgapi.h"           // for JS_ClearWatchPointsForObject
    1: #include "jsxdrapi.h"
    1: #include "nsIArray.h"
    1: #include "nsIObjectInputStream.h"
    1: #include "nsIObjectOutputStream.h"
    1: #include "nsITimelineService.h"
    1: #include "nsDOMScriptObjectHolder.h"
    1: #include "prmem.h"
    1: 
    1: #ifdef NS_DEBUG
    1: #include "nsGlobalWindow.h"
    1: #endif
    1: 
    1: #ifdef MOZ_JSDEBUGGER
    1: #include "jsdIDebuggerService.h"
    1: #endif
    1: #ifdef MOZ_LOGGING
    1: // Force PR_LOGGING so we can get JS strict warnings even in release builds
    1: #define FORCE_PR_LOG 1
    1: #endif
    1: #include "prlog.h"
    1: #include "prthread.h"
    1: 
    1: const size_t gStackSize = 8192;
    1: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo* gJSDiagnostics;
    1: #endif
    1: 
    1: // Thank you Microsoft!
    1: #ifndef WINCE
    1: #ifdef CompareString
    1: #undef CompareString
    1: #endif
    1: #endif // WINCE
    1: 
    1: // The amount of time we wait between a request to GC (due to leaving
    1: // a page) and doing the actual GC.
    1: #define NS_GC_DELAY                 2000 // ms
    1: 
    1: // The amount of time we wait until we force a GC in case the previous
    1: // GC timer happened to fire while we were in the middle of loading a
    1: // page (we'll GC once the page is loaded if that happens before this
    1: // amount of time has passed).
    1: #define NS_LOAD_IN_PROCESS_GC_DELAY 4000 // ms
    1: 
    1: // The amount of time we wait from the first request to GC to actually
    1: // doing the first GC.
    1: #define NS_FIRST_GC_DELAY           10000 // ms
    1: 
    1: #define JAVASCRIPT nsIProgrammingLanguage::JAVASCRIPT
    1: 
 7093: // The max number of delayed cycle collects..
 7093: #define NS_MAX_DELAYED_CCOLLECT     45
 7093: // The max number of user interaction notifications in inactive state before
 7093: // we try to call cycle collector more aggressively.
 7093: #define NS_CC_SOFT_LIMIT_INACTIVE   6
 7093: // The max number of user interaction notifications in active state before
 7093: // we try to call cycle collector more aggressively.
 7093: #define NS_CC_SOFT_LIMIT_ACTIVE     12
 7093: // When higher probability MaybeCC is used, the number of sDelayedCCollectCount
 7093: // is multiplied with this number.
 7093: #define NS_PROBABILITY_MULTIPLIER   3
30070: // Cycle collector is never called more often than every NS_MIN_CC_INTERVAL
30070: // milliseconds. Exceptions are low memory situation and memory pressure
30070: // notification.
 7093: #define NS_MIN_CC_INTERVAL          10000 // ms
12201: // If previous cycle collection collected more than this number of objects,
12201: // the next collection will happen somewhat soon.
12201: #define NS_COLLECTED_OBJECTS_LIMIT  5000
12201: // CC will be called if GC has been called at least this number of times and
12201: // there are at least NS_MIN_SUSPECT_CHANGES new suspected objects.
12201: #define NS_MAX_GC_COUNT             5
12201: #define NS_MIN_SUSPECT_CHANGES      10
12201: // CC will be called if there are at least NS_MAX_SUSPECT_CHANGES new suspected
12201: // objects.
12201: #define NS_MAX_SUSPECT_CHANGES      100
 7093: 
    1: // if you add statics here, add them to the list in nsJSRuntime::Startup
    1: 
 7093: static PRUint32 sDelayedCCollectCount;
 7093: static PRUint32 sCCollectCount;
 7093: static PRBool sUserIsActive;
 7093: static PRTime sPreviousCCTime;
12201: static PRUint32 sCollectedObjectsCounts;
24385: static PRUint32 sSavedGCCount;
12201: static PRUint32 sCCSuspectChanges;
12201: static PRUint32 sCCSuspectedCount;
    1: static nsITimer *sGCTimer;
    1: static PRBool sReadyForGC;
    1: 
    1: // The number of currently pending document loads. This count isn't
    1: // guaranteed to always reflect reality and can't easily as we don't
    1: // have an easy place to know when a load ends or is interrupted in
    1: // all cases. This counter also gets reset if we end up GC'ing while
    1: // we're waiting for a slow page to load. IOW, this count may be 0
    1: // even when there are pending loads.
    1: static PRUint32 sPendingLoadCount;
    1: 
    1: // Boolean that tells us whether or not the current GC timer
    1: // (sGCTimer) was scheduled due to a GC timer firing while we were in
    1: // the middle of loading a page.
    1: static PRBool sLoadInProgressGCTimer;
    1: 
    1: nsScriptNameSpaceManager *gNameSpaceManager;
    1: 
    1: static nsIJSRuntimeService *sRuntimeService;
    1: JSRuntime *nsJSRuntime::sRuntime;
    1: 
    1: static const char kJSRuntimeServiceContractID[] =
    1:   "@mozilla.org/js/xpc/RuntimeService;1";
    1: 
    1: static JSGCCallback gOldJSGCCallback;
    1: 
    1: static PRBool sIsInitialized;
    1: static PRBool sDidShutdown;
    1: 
    1: static PRInt32 sContextCount;
    1: 
    1: static PRTime sMaxScriptRunTime;
    1: static PRTime sMaxChromeScriptRunTime;
    1: 
    1: static nsIScriptSecurityManager *sSecurityManager;
    1: 
    1: static nsICollation *gCollation;
    1: 
    1: static nsIUnicodeDecoder *gDecoder;
    1: 
 7093: // nsUserActivityObserver observes user-interaction-active and
 7093: // user-interaction-inactive notifications. It counts the number of
 7093: // notifications and if the number is bigger than NS_CC_SOFT_LIMIT_ACTIVE
 7093: // (in case the current notification is user-interaction-active) or
 7093: // NS_CC_SOFT_LIMIT_INACTIVE (current notification is user-interaction-inactive)
 7093: // MaybeCC is called with aHigherParameter set to PR_TRUE, otherwise PR_FALSE.
 7093: //
30070: // When moving from active state to inactive, nsJSContext::IntervalCC() is
30070: // called unless the timer related to page load is active.
 7093: 
 7093: class nsUserActivityObserver : public nsIObserver
 7093: {
 7093: public:
 7093:   nsUserActivityObserver()
 7093:   : mUserActivityCounter(0), mOldCCollectCount(0) {}
 7093:   NS_DECL_ISUPPORTS
 7093:   NS_DECL_NSIOBSERVER
 7093: private:
 7093:   PRUint32 mUserActivityCounter;
 7093:   PRUint32 mOldCCollectCount;
 7093: };
 7093: 
 7093: NS_IMPL_ISUPPORTS1(nsUserActivityObserver, nsIObserver)
 7093: 
 7093: NS_IMETHODIMP
 7093: nsUserActivityObserver::Observe(nsISupports* aSubject, const char* aTopic,
 7093:                                 const PRUnichar* aData)
 7093: {
 7093:   if (mOldCCollectCount != sCCollectCount) {
 7093:     mOldCCollectCount = sCCollectCount;
 7093:     // Cycle collector was called between user interaction notifications, so
 7093:     // we can reset the counter.
 7093:     mUserActivityCounter = 0;
 7093:   }
 7093:   PRBool higherProbability = PR_FALSE;
 7093:   ++mUserActivityCounter;
 7093:   if (!strcmp(aTopic, "user-interaction-inactive")) {
 7093: #ifdef DEBUG_smaug
 7093:     printf("user-interaction-inactive\n");
 7093: #endif
 7093:     if (sUserIsActive) {
 7093:       sUserIsActive = PR_FALSE;
 7093:       if (!sGCTimer) {
30070:         nsJSContext::IntervalCC();
 7093:         return NS_OK;
 7093:       }
 7093:     }
 7093:     higherProbability = (mUserActivityCounter > NS_CC_SOFT_LIMIT_INACTIVE);
 7093:   } else if (!strcmp(aTopic, "user-interaction-active")) {
 7093: #ifdef DEBUG_smaug
 7093:     printf("user-interaction-active\n");
 7093: #endif
 7093:     sUserIsActive = PR_TRUE;
 7093:     higherProbability = (mUserActivityCounter > NS_CC_SOFT_LIMIT_ACTIVE);
 7093:   } else if (!strcmp(aTopic, "xpcom-shutdown")) {
 7093:     nsCOMPtr<nsIObserverService> obs =
 7093:       do_GetService("@mozilla.org/observer-service;1");
 7093:     if (obs) {
 7093:       obs->RemoveObserver(this, "user-interaction-active");
 7093:       obs->RemoveObserver(this, "user-interaction-inactive");
 7093:       obs->RemoveObserver(this, "xpcom-shutdown");
 7093:     }
 7093:     return NS_OK;
 7093:   }
 7093:   nsJSContext::MaybeCC(higherProbability);
 7093:   return NS_OK;
 7093: }
 7093: 
 7369: // nsCCMemoryPressureObserver observes the memory-pressure notifications
 7369: // and forces a cycle collection when it happens.
 7369: 
 7369: class nsCCMemoryPressureObserver : public nsIObserver
 7369: {
 7369: public:
 7369:   NS_DECL_ISUPPORTS
 7369:   NS_DECL_NSIOBSERVER
 7369: };
 7369: 
 7369: NS_IMPL_ISUPPORTS1(nsCCMemoryPressureObserver, nsIObserver)
 7369: 
 7369: NS_IMETHODIMP
 7369: nsCCMemoryPressureObserver::Observe(nsISupports* aSubject, const char* aTopic,
 7369:                                     const PRUnichar* aData)
 7369: {
 7369:   nsJSContext::CC();
 7369:   return NS_OK;
 7369: }
 7369: 
11775: class nsJSVersionSetter {
11775: public:
11775:   nsJSVersionSetter(JSContext *aContext, PRUint32 aVersion);
11775:   ~nsJSVersionSetter();
11775: 
11775: private:
11775:   JSContext* mContext;
11775:   uint32 mOldOptions;
11775:   JSVersion mOldVersion;
11775:   JSBool mOptionsChanged;
11775: };
11775: 
11775: nsJSVersionSetter::nsJSVersionSetter(JSContext *aContext, PRUint32 aVersion)
11775:   : mContext(aContext)
11775: {
11775:   // JSVERSION_HAS_XML may be set in our version mask - however, we can't
11775:   // simply pass this directly to JS_SetOptions as it masks out that bit -
11775:   // the only way to make this happen is via JS_SetOptions.
11775:   JSBool hasxml = (aVersion & JSVERSION_HAS_XML) != 0;
11775:   mOldOptions = ::JS_GetOptions(mContext);
11775:   mOptionsChanged = ((hasxml) ^ !!(mOldOptions & JSOPTION_XML));
11775: 
11775:   if (mOptionsChanged) {
11775:     ::JS_SetOptions(mContext,
11775:                     hasxml
11775:                     ? mOldOptions | JSOPTION_XML
11775:                     : mOldOptions & ~JSOPTION_XML);
11775:   }
11775: 
11775:   // Change the version - this is cheap when the versions match, so no need
11775:   // to optimize here...
11775:   JSVersion newVer = (JSVersion)(aVersion & JSVERSION_MASK);
11775:   mOldVersion = ::JS_SetVersion(mContext, newVer);
11775: }
11775: 
11775: nsJSVersionSetter::~nsJSVersionSetter()
11775: {
11775:   ::JS_SetVersion(mContext, mOldVersion);
11775: 
11775:   if (mOptionsChanged) {
11775:       ::JS_SetOptions(mContext, mOldOptions);
11775:   }
11775: }
11775: 
 7369: 
    1: /****************************************************************
    1:  ************************** AutoFree ****************************
    1:  ****************************************************************/
    1: 
    1: class AutoFree {
    1: public:
    1:   AutoFree(void *aPtr) : mPtr(aPtr) {
    1:   }
    1:   ~AutoFree() {
    1:     if (mPtr)
    1:       nsMemory::Free(mPtr);
    1:   }
    1:   void Invalidate() {
    1:     mPtr = 0;
    1:   }
    1: private:
    1:   void *mPtr;
    1: };
    1: 
    1: class AutoFreeJSStack {
    1: public:
    1:   AutoFreeJSStack(JSContext *ctx, void *aPtr) : mContext(ctx), mStack(aPtr) {
    1:   }
25214:   JS_REQUIRES_STACK ~AutoFreeJSStack() {
    1:     if (mContext && mStack)
    1:       js_FreeStack(mContext, mStack);
    1:   }
    1: private:
    1:   JSContext *mContext;
    1:   void *mStack;
    1: };
    1: 
    1: // A utility function for script languages to call.  Although it looks small,
    1: // the use of nsIDocShell and nsPresContext triggers a huge number of
    1: // dependencies that most languages would not otherwise need.
    1: // XXXmarkh - This function is mis-placed!
    1: PRBool
    1: NS_HandleScriptError(nsIScriptGlobalObject *aScriptGlobal,
    1:                      nsScriptErrorEvent *aErrorEvent,
    1:                      nsEventStatus *aStatus)
    1: {
    1:   PRBool called = PR_FALSE;
    1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aScriptGlobal));
    1:   nsIDocShell *docShell = win ? win->GetDocShell() : nsnull;
    1:   if (docShell) {
    1:     nsCOMPtr<nsPresContext> presContext;
    1:     docShell->GetPresContext(getter_AddRefs(presContext));
    1: 
    1:     static PRInt32 errorDepth; // Recursion prevention
    1:     ++errorDepth;
    1: 
    1:     if (presContext && errorDepth < 2) {
    1:       // Dispatch() must be synchronous for the recursion block
    1:       // (errorDepth) to work.
    1:       nsEventDispatcher::Dispatch(win, presContext, aErrorEvent, nsnull,
    1:                                   aStatus);
    1:       called = PR_TRUE;
    1:     }
    1:     --errorDepth;
    1:   }
    1:   return called;
    1: }
    1: 
    1: // NOTE: This function could be refactored to use the above.  The only reason
    1: // it has not been done is that the code below only fills the error event
    1: // after it has a good nsPresContext - whereas using the above function
    1: // would involve always filling it.  Is that a concern?
18907: void
    1: NS_ScriptErrorReporter(JSContext *cx,
    1:                        const char *message,
    1:                        JSErrorReport *report)
    1: {
25523:   // We don't want to report exceptions too eagerly, but warnings in the
25523:   // absence of werror are swallowed whole, so report those now.
25523:   if (!JSREPORT_IS_WARNING(report->flags)) {
20343:     JSStackFrame * fp = nsnull;
20343:     while ((fp = JS_FrameIterator(cx, &fp))) {
20343:       if (!JS_IsNativeFrame(cx, fp)) {
20343:         return;
20343:       }
20343:     }
20343: 
20343:     nsIXPConnect* xpc = nsContentUtils::XPConnect();
20343:     if (xpc) {
20343:       nsAXPCNativeCallContext *cc = nsnull;
20343:       xpc->GetCurrentNativeCallContext(&cc);
20343:       if (cc) {
20343:         nsAXPCNativeCallContext *prev = cc;
20343:         while (NS_SUCCEEDED(prev->GetPreviousCallContext(&prev)) && prev) {
20343:           PRUint16 lang;
20343:           if (NS_SUCCEEDED(prev->GetLanguage(&lang)) &&
20343:             lang == nsAXPCNativeCallContext::LANG_JS) {
20343:             return;
20343:           }
20343:         }
20343:       }
20343:     }
25523:   }
20343: 
    1:   // XXX this means we are not going to get error reports on non DOM contexts
    1:   nsIScriptContext *context = nsJSUtils::GetDynamicScriptContext(cx);
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1: 
    1:   // Note: we must do this before running any more code on cx (if cx is the
    1:   // dynamic script context).
    1:   ::JS_ClearPendingException(cx);
    1: 
    1:   if (context) {
    1:     nsIScriptGlobalObject *globalObject = context->GetGlobalObject();
    1: 
    1:     if (globalObject) {
    1:       nsAutoString fileName, msg;
 3275:       NS_NAMED_LITERAL_STRING(xoriginMsg, "Script error.");
    1: 
    1:       fileName.AssignWithConversion(report->filename);
    1: 
 3233:       const PRUnichar *m = reinterpret_cast<const PRUnichar*>
 3233:                                              (report->ucmessage);
    1:       if (m) {
    1:         msg.Assign(m);
    1:       }
    1: 
    1:       if (msg.IsEmpty() && message) {
    1:         msg.AssignWithConversion(message);
    1:       }
    1: 
    1:       // First, notify the DOM that we have a script error.
    1:       /* We do not try to report Out Of Memory via a dom
    1:        * event because the dom event handler would encounter
    1:        * an OOM exception trying to process the event, and
    1:        * then we'd need to generate a new OOM event for that
    1:        * new OOM instance -- this isn't pretty.
    1:        */
    1:       {
    1:         // Scope to make sure we're not using |win| in the rest of
    1:         // this function when we should be using |globalObject|.  We
    1:         // only need |win| for the event dispatch.
    1:         nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(globalObject));
    1:         nsIDocShell *docShell = win ? win->GetDocShell() : nsnull;
    1:         if (docShell &&
    1:             (report->errorNumber != JSMSG_OUT_OF_MEMORY &&
 3366:               !JSREPORT_IS_WARNING(report->flags))) {
    1:           static PRInt32 errorDepth; // Recursion prevention
    1:           ++errorDepth;
    1: 
    1:           nsCOMPtr<nsPresContext> presContext;
    1:           docShell->GetPresContext(getter_AddRefs(presContext));
    1: 
    1:           if (presContext && errorDepth < 2) {
    1:             nsScriptErrorEvent errorevent(PR_TRUE, NS_LOAD_ERROR);
    1: 
    1:             errorevent.fileName = fileName.get();
 3275: 
 3275:             nsCOMPtr<nsIScriptObjectPrincipal> sop(do_QueryInterface(win));
 3275:             nsIPrincipal *p = sop->GetPrincipal();
 3275: 
 3366:             PRBool sameOrigin = (report->filename == nsnull);
 3281: 
 3281:             if (p && !sameOrigin) {
 3275:               nsCOMPtr<nsIURI> errorURI;
 3275:               NS_NewURI(getter_AddRefs(errorURI), report->filename);
 3275: 
20271:               if (errorURI) {
 3275:                 // FIXME: Once error reports contain the origin of the
 3275:                 // error (principals) we should change this to do the
 3275:                 // security check based on the principals and not
 3275:                 // URIs. See bug 387476.
20271:                 sameOrigin = NS_SUCCEEDED(p->CheckMayLoad(errorURI, PR_FALSE));
 3275:               }
 3275:             }
 3275: 
 3275:             if (sameOrigin) {
    1:               errorevent.errorMsg = msg.get();
 3366:               errorevent.lineNr = report->lineno;
 3275:             } else {
 3275:               errorevent.errorMsg = xoriginMsg.get();
 3275:               errorevent.lineNr = 0;
 3275:             }
    1: 
    1:             // Dispatch() must be synchronous for the recursion block
    1:             // (errorDepth) to work.
    1:             nsEventDispatcher::Dispatch(win, presContext, &errorevent, nsnull,
    1:                                         &status);
    1:           }
    1: 
    1:           --errorDepth;
    1:         }
    1:       }
    1: 
    1:       if (status != nsEventStatus_eConsumeNoDefault) {
    1:         // Make an nsIScriptError and populate it with information from
    1:         // this error.
    1:         nsCOMPtr<nsIScriptError> errorObject =
    1:           do_CreateInstance("@mozilla.org/scripterror;1");
    1: 
    1:         if (errorObject != nsnull) {
    1:           nsresult rv = NS_ERROR_NOT_AVAILABLE;
    1: 
    1:           // Set category to chrome or content
    1:           nsCOMPtr<nsIScriptObjectPrincipal> scriptPrincipal =
    1:             do_QueryInterface(globalObject);
    1:           NS_ASSERTION(scriptPrincipal, "Global objects must implement "
    1:                        "nsIScriptObjectPrincipal");
    1:           nsCOMPtr<nsIPrincipal> systemPrincipal;
    1:           sSecurityManager->GetSystemPrincipal(getter_AddRefs(systemPrincipal));
    1:           const char * category =
    1:             scriptPrincipal->GetPrincipal() == systemPrincipal
    1:             ? "chrome javascript"
    1:             : "content javascript";
    1: 
    1:           PRUint32 column = report->uctokenptr - report->uclinebuf;
    1: 
    1:           rv = errorObject->Init(msg.get(), fileName.get(),
 3233:                                  reinterpret_cast<const PRUnichar*>
 3233:                                                  (report->uclinebuf),
    1:                                  report->lineno, column, report->flags,
    1:                                  category);
    1: 
    1:           if (NS_SUCCEEDED(rv)) {
    1:             nsCOMPtr<nsIConsoleService> consoleService =
    1:               do_GetService(NS_CONSOLESERVICE_CONTRACTID, &rv);
    1:             if (NS_SUCCEEDED(rv)) {
    1:               consoleService->LogMessage(errorObject);
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   // Print it to stderr as well, for the benefit of those invoking
    1:   // mozilla with -console.
    1:   nsCAutoString error;
    1:   error.Assign("JavaScript ");
    1:   if (JSREPORT_IS_STRICT(report->flags))
    1:     error.Append("strict ");
    1:   if (JSREPORT_IS_WARNING(report->flags))
    1:     error.Append("warning: ");
    1:   else
    1:     error.Append("error: ");
    1:   error.Append(report->filename);
    1:   error.Append(", line ");
    1:   error.AppendInt(report->lineno, 10);
    1:   error.Append(": ");
    1:   if (report->ucmessage) {
 3233:     AppendUTF16toUTF8(reinterpret_cast<const PRUnichar*>(report->ucmessage),
    1:                       error);
    1:   } else {
    1:     error.Append(message);
    1:   }
    1:   if (status != nsEventStatus_eIgnore && !JSREPORT_IS_WARNING(report->flags))
    1:     error.Append(" Error was suppressed by event handler\n");
    1:   fprintf(stderr, "%s\n", error.get());
    1:   fflush(stderr);
    1: #endif
    1: 
    1: #ifdef PR_LOGGING
    1:   if (!gJSDiagnostics)
    1:     gJSDiagnostics = PR_NewLogModule("JSDiagnostics");
    1: 
    1:   if (gJSDiagnostics) {
    1:     PR_LOG(gJSDiagnostics,
    1:            JSREPORT_IS_WARNING(report->flags) ? PR_LOG_WARNING : PR_LOG_ERROR,
    1:            ("file %s, line %u: %s\n%s%s",
    1:             report->filename, report->lineno, message,
    1:             report->linebuf ? report->linebuf : "",
    1:             (report->linebuf &&
    1:              report->linebuf[strlen(report->linebuf)-1] != '\n')
    1:             ? "\n"
    1:             : ""));
    1:   }
    1: #endif
    1: }
    1: 
18907: static JSBool
    1: LocaleToUnicode(JSContext *cx, char *src, jsval *rval)
    1: {
    1:   nsresult rv;
    1: 
    1:   if (!gDecoder) {
    1:     // use app default locale
    1:     nsCOMPtr<nsILocaleService> localeService =
    1:       do_GetService(NS_LOCALESERVICE_CONTRACTID, &rv);
    1:     if (NS_SUCCEEDED(rv)) {
    1:       nsCOMPtr<nsILocale> appLocale;
    1:       rv = localeService->GetApplicationLocale(getter_AddRefs(appLocale));
    1:       if (NS_SUCCEEDED(rv)) {
    1:         nsAutoString localeStr;
    1:         rv = appLocale->
    1:           GetCategory(NS_LITERAL_STRING(NSILOCALE_TIME), localeStr);
    1:         NS_ASSERTION(NS_SUCCEEDED(rv), "failed to get app locale info");
    1: 
    1:         nsCOMPtr<nsIPlatformCharset> platformCharset =
    1:           do_GetService(NS_PLATFORMCHARSET_CONTRACTID, &rv);
    1: 
    1:         if (NS_SUCCEEDED(rv)) {
    1:           nsCAutoString charset;
    1:           rv = platformCharset->GetDefaultCharsetForLocale(localeStr, charset);
    1:           if (NS_SUCCEEDED(rv)) {
    1:             // get/create unicode decoder for charset
    1:             nsCOMPtr<nsICharsetConverterManager> ccm =
    1:               do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
    1:             if (NS_SUCCEEDED(rv))
    1:               ccm->GetUnicodeDecoder(charset.get(), &gDecoder);
    1:           }
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   JSString *str = nsnull;
    1:   PRInt32 srcLength = PL_strlen(src);
    1: 
    1:   if (gDecoder) {
    1:     PRInt32 unicharLength = srcLength;
    1:     PRUnichar *unichars =
    1:       (PRUnichar *)JS_malloc(cx, (srcLength + 1) * sizeof(PRUnichar));
    1:     if (unichars) {
    1:       rv = gDecoder->Convert(src, &srcLength, unichars, &unicharLength);
    1:       if (NS_SUCCEEDED(rv)) {
    1:         // terminate the returned string
    1:         unichars[unicharLength] = 0;
    1: 
    1:         // nsIUnicodeDecoder::Convert may use fewer than srcLength PRUnichars
    1:         if (unicharLength + 1 < srcLength + 1) {
    1:           PRUnichar *shrunkUnichars =
    1:             (PRUnichar *)JS_realloc(cx, unichars,
    1:                                     (unicharLength + 1) * sizeof(PRUnichar));
    1:           if (shrunkUnichars)
    1:             unichars = shrunkUnichars;
    1:         }
    1:         str = JS_NewUCString(cx,
 3233:                              reinterpret_cast<jschar*>(unichars),
    1:                              unicharLength);
    1:       }
    1:       if (!str)
    1:         JS_free(cx, unichars);
    1:     }
    1:   }
    1: 
    1:   if (!str) {
    1:     nsDOMClassInfo::ThrowJSException(cx, NS_ERROR_OUT_OF_MEMORY);
    1:     return JS_FALSE;
    1:   }
    1: 
    1:   *rval = STRING_TO_JSVAL(str);
    1:   return JS_TRUE;
    1: }
    1: 
    1: 
    1: static JSBool
    1: ChangeCase(JSContext *cx, JSString *src, jsval *rval,
    1:            void(* changeCaseFnc)(const nsAString&, nsAString&))
    1: {
    1:   nsAutoString result;
    1:   changeCaseFnc(nsDependentJSString(src), result);
    1: 
    1:   JSString *ucstr = JS_NewUCStringCopyN(cx, (jschar*)result.get(), result.Length());
    1:   if (!ucstr) {
    1:     return JS_FALSE;
    1:   }
    1: 
    1:   *rval = STRING_TO_JSVAL(ucstr);
    1: 
    1:   return JS_TRUE;
    1: }
    1: 
18907: static JSBool
    1: LocaleToUpperCase(JSContext *cx, JSString *src, jsval *rval)
    1: {
    1:   return ChangeCase(cx, src, rval, ToUpperCase);
    1: }
    1: 
18907: static JSBool
    1: LocaleToLowerCase(JSContext *cx, JSString *src, jsval *rval)
    1: {
    1:   return ChangeCase(cx, src, rval, ToLowerCase);
    1: }
    1: 
18907: static JSBool
    1: LocaleCompare(JSContext *cx, JSString *src1, JSString *src2, jsval *rval)
    1: {
    1:   nsresult rv;
    1: 
    1:   if (!gCollation) {
    1:     nsCOMPtr<nsILocaleService> localeService =
    1:       do_GetService(NS_LOCALESERVICE_CONTRACTID, &rv);
    1: 
    1:     if (NS_SUCCEEDED(rv)) {
    1:       nsCOMPtr<nsILocale> locale;
    1:       rv = localeService->GetApplicationLocale(getter_AddRefs(locale));
    1: 
    1:       if (NS_SUCCEEDED(rv)) {
    1:         nsCOMPtr<nsICollationFactory> colFactory =
    1:           do_CreateInstance(NS_COLLATIONFACTORY_CONTRACTID, &rv);
    1: 
    1:         if (NS_SUCCEEDED(rv)) {
    1:           rv = colFactory->CreateCollation(locale, &gCollation);
    1:         }
    1:       }
    1:     }
    1: 
    1:     if (NS_FAILED(rv)) {
    1:       nsDOMClassInfo::ThrowJSException(cx, rv);
    1: 
    1:       return JS_FALSE;
    1:     }
    1:   }
    1: 
    1:   PRInt32 result;
    1:   rv = gCollation->CompareString(nsICollation::kCollationStrengthDefault,
    1:                                  nsDependentJSString(src1),
    1:                                  nsDependentJSString(src2),
    1:                                  &result);
    1: 
    1:   if (NS_FAILED(rv)) {
    1:     nsDOMClassInfo::ThrowJSException(cx, rv);
    1: 
    1:     return JS_FALSE;
    1:   }
    1: 
    1:   *rval = INT_TO_JSVAL(result);
    1: 
    1:   return JS_TRUE;
    1: }
    1: 
    1: #ifdef DEBUG
    1: // A couple of useful functions to call when you're debugging.
    1: nsGlobalWindow *
    1: JSObject2Win(JSContext *cx, JSObject *obj)
    1: {
    1:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1:   if (!xpc) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
    1:   xpc->GetWrappedNativeOfJSObject(cx, obj, getter_AddRefs(wrapper));
    1:   if (wrapper) {
    1:     nsCOMPtr<nsPIDOMWindow> win = do_QueryWrappedNative(wrapper);
    1:     if (win) {
 3233:       return static_cast<nsGlobalWindow *>
 3233:                         (static_cast<nsPIDOMWindow *>(win));
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: void
    1: PrintWinURI(nsGlobalWindow *win)
    1: {
    1:   if (!win) {
    1:     printf("No window passed in.\n");
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(win->GetExtantDocument());
    1:   if (!doc) {
    1:     printf("No document in the window.\n");
    1:     return;
    1:   }
    1: 
    1:   nsIURI *uri = doc->GetDocumentURI();
    1:   if (!uri) {
    1:     printf("Document doesn't have a URI.\n");
    1:     return;
    1:   }
    1: 
    1:   nsCAutoString spec;
    1:   uri->GetSpec(spec);
    1:   printf("%s\n", spec.get());
    1: }
    1: 
    1: void
    1: PrintWinCodebase(nsGlobalWindow *win)
    1: {
    1:   if (!win) {
    1:     printf("No window passed in.\n");
    1:     return;
    1:   }
    1: 
    1:   nsIPrincipal *prin = win->GetPrincipal();
    1:   if (!prin) {
    1:     printf("Window doesn't have principals.\n");
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIURI> uri;
    1:   prin->GetURI(getter_AddRefs(uri));
    1:   if (!uri) {
    1:     printf("No URI, maybe the system principal.\n");
    1:     return;
    1:   }
    1: 
    1:   nsCAutoString spec;
    1:   uri->GetSpec(spec);
    1:   printf("%s\n", spec.get());
    1: }
    1: #endif
    1: 
21973: static void
21973: MaybeGC(JSContext *cx)
21973: {
31888:   size_t bytes = cx->runtime->gcBytes;
31888:   size_t lastBytes = cx->runtime->gcLastBytes;
31888:   if ((bytes > 8192 && bytes > lastBytes * 16)
31888: #ifdef DEBUG
31888:       || cx->runtime->gcZeal > 0
31888: #endif
31888:       ) {
31888:     JS_GC(cx);
31888:   }
21973: }
11892: 
18509: static already_AddRefed<nsIPrompt>
18509: GetPromptFromContext(nsJSContext* ctx)
18509: {
18509:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(ctx->GetGlobalObject()));
18509:   NS_ENSURE_TRUE(win, nsnull);
18509: 
18509:   nsIDocShell *docShell = win->GetDocShell();
18509:   NS_ENSURE_TRUE(docShell, nsnull);
18509: 
18509:   nsCOMPtr<nsIInterfaceRequestor> ireq(do_QueryInterface(docShell));
18509:   NS_ENSURE_TRUE(ireq, nsnull);
18509: 
18509:   // Get the nsIPrompt interface from the docshell
18509:   nsIPrompt* prompt;
18509:   ireq->GetInterface(NS_GET_IID(nsIPrompt), (void**)&prompt);
18509:   return prompt;
18509: }
18509: 
18907: JSBool
10142: nsJSContext::DOMOperationCallback(JSContext *cx)
    1: {
18509:   nsresult rv;
18509: 
    1:   // Get the native context
 3233:   nsJSContext *ctx = static_cast<nsJSContext *>(::JS_GetContextPrivate(cx));
    1: 
    1:   if (!ctx) {
    1:     // Can happen; see bug 355811
    1:     return JS_TRUE;
    1:   }
    1: 
21973:   // XXX Save the operation callback time so we can restore it after the GC,
21973:   // because GCing can cause JS to run on our context, causing our
21973:   // ScriptEvaluated to be called, and clearing our operation callback time.
21973:   // See bug 302333.
10413:   PRTime callbackTime = ctx->mOperationCallbackTime;
29105:   PRTime modalStateTime = ctx->mModalStateTime;
10413: 
21973:   MaybeGC(cx);
21973: 
21973:   // Now restore the callback time and count, in case they got reset.
21973:   ctx->mOperationCallbackTime = callbackTime;
29105:   ctx->mModalStateTime = modalStateTime;
21973: 
18509:   // Check to see if we are running OOM
18509:   nsCOMPtr<nsIMemory> mem;
18509:   NS_GetMemoryManager(getter_AddRefs(mem));
25709:   if (!mem) {
25709:     JS_ClearPendingException(cx);
18509:     return JS_FALSE;
25709:   }
18509: 
18509:   PRBool lowMemory;
18509:   mem->IsLowMemory(&lowMemory);
18509:   if (lowMemory) {
18509:     // try to clean up:
18509:     nsJSContext::CC();
18509: 
19175:     // never prevent system scripts from running
19175:     if (!::JS_IsSystemObject(cx, ::JS_GetGlobalObject(cx))) {
19175: 
19175:       // lets see if CC() did anything, if not, cancel the script.
18509:       mem->IsLowMemory(&lowMemory);
18509:       if (lowMemory) {
18853: 
25709:         if (nsContentUtils::GetBoolPref("dom.prevent_oom_dialog", PR_FALSE)) {
25709:           JS_ClearPendingException(cx);
18853:           return JS_FALSE;
25709:         }
18853: 
34925:         nsCOMPtr<nsIScriptError> errorObject =
34925:           do_CreateInstance("@mozilla.org/scripterror;1");
34925: 
34925:         if (errorObject) {
34925:           nsXPIDLString msg;
34925:           nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                              "LowMemoryMessage",
18509:                                              msg);
18509: 
34925:           JSStackFrame *fp, *iterator = nsnull;
34925:           fp = ::JS_FrameIterator(cx, &iterator);
34925:           PRUint32 lineno = 0;
34925:           nsAutoString sourcefile;
34925:           if (fp) {
34925:             JSScript* script = ::JS_GetFrameScript(cx, fp);
34925:             if (script) {
34925:               const char* filename = ::JS_GetScriptFilename(cx, script);
34925:               if (filename) {
34925:                 CopyUTF8toUTF16(nsDependentCString(filename), sourcefile);
34925:               }
34925:               jsbytecode* pc = ::JS_GetFramePC(cx, fp);
34925:               if (pc) {
34925:                 lineno = ::JS_PCToLineNumber(cx, script, pc);
34925:               }
34925:             }
34925:           }
34925: 
34925:           rv = errorObject->Init(msg.get(),
34925:                                  sourcefile.get(),
34925:                                  EmptyString().get(),
34925:                                  lineno, 0, nsIScriptError::errorFlag,
34925:                                  "content javascript");
34925:           if (NS_SUCCEEDED(rv)) {
34925:             nsCOMPtr<nsIConsoleService> consoleService =
34925:               do_GetService(NS_CONSOLESERVICE_CONTRACTID, &rv);
34925:             if (NS_SUCCEEDED(rv)) {
34925:               consoleService->LogMessage(errorObject);
34925:             }
34925:           }
34925:         }
34925: 
25709:         JS_ClearPendingException(cx);
18509:         return JS_FALSE;
18509:       }
18509:     }
19175:   }
18509: 
10413:   PRTime now = PR_Now();
10413: 
29105:   if (callbackTime == 0) {
10142:     // Initialize mOperationCallbackTime to start timing how long the
 9784:     // script has run
10413:     ctx->mOperationCallbackTime = now;
 9682:     return JS_TRUE;
 9682:   }
 9682: 
29105:   if (ctx->mModalStateDepth) {
29105:     // We're waiting on a modal dialog, nothing more to do here.
29105: 
29105:     return JS_TRUE;
29105:   }
29105: 
29105:   PRTime duration = now - callbackTime;
    1: 
    1:   // Check the amount of time this script has been running, or if the
    1:   // dialog is disabled.
10413:   PRBool isTrackingChromeCodeTime =
10413:     ::JS_IsSystemObject(cx, ::JS_GetGlobalObject(cx));
10413:   if (duration < (isTrackingChromeCodeTime ?
    1:                   sMaxChromeScriptRunTime : sMaxScriptRunTime)) {
    1:     return JS_TRUE;
    1:   }
    1: 
    1:   // If we get here we're most likely executing an infinite loop in JS,
    1:   // we'll tell the user about this and we'll give the user the option
    1:   // of stopping the execution of the script.
18509:   nsCOMPtr<nsIPrompt> prompt = GetPromptFromContext(ctx);
    1:   NS_ENSURE_TRUE(prompt, JS_TRUE);
    1: 
    1:   // Check if we should offer the option to debug
10142:   JSStackFrame* fp = ::JS_GetScriptedCaller(cx, NULL);
25087:   PRBool debugPossible = (fp != nsnull && cx->debugHooks &&
10142:                           cx->debugHooks->debuggerHandler != nsnull);
    1: #ifdef MOZ_JSDEBUGGER
    1:   // Get the debugger service if necessary.
    1:   if (debugPossible) {
    1:     PRBool jsds_IsOn = PR_FALSE;
    1:     const char jsdServiceCtrID[] = "@mozilla.org/js/jsd/debugger-service;1";
    1:     nsCOMPtr<jsdIExecutionHook> jsdHook;
    1:     nsCOMPtr<jsdIDebuggerService> jsds = do_GetService(jsdServiceCtrID, &rv);
    1: 
    1:     // Check if there's a user for the debugger service that's 'on' for us
    1:     if (NS_SUCCEEDED(rv)) {
    1:       jsds->GetDebuggerHook(getter_AddRefs(jsdHook));
    1:       jsds->GetIsOn(&jsds_IsOn);
    1:       if (jsds_IsOn) { // If this is not true, the next call would start jsd...
    1:         rv = jsds->OnForRuntime(cx->runtime);
    1:         jsds_IsOn = NS_SUCCEEDED(rv);
    1:       }
    1:     }
    1: 
    1:     // If there is a debug handler registered for this runtime AND
    1:     // ((jsd is on AND has a hook) OR (jsd isn't on (something else debugs)))
    1:     // then something useful will be done with our request to debug.
    1:     debugPossible = ((jsds_IsOn && (jsdHook != nsnull)) || !jsds_IsOn);
    1:   }
    1: #endif
    1: 
    1:   // Get localizable strings
    1:   nsXPIDLString title, msg, stopButton, waitButton, debugButton, neverShowDlg;
    1: 
18509:   rv = nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                           "KillScriptTitle",
18509:                                           title);
18509: 
18509:   rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                            "StopScriptButton",
18509:                                            stopButton);
18509: 
18509:   rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                            "WaitForScriptButton",
18509:                                            waitButton);
18509: 
18509:   rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                            "DontAskAgain",
18509:                                            neverShowDlg);
    1: 
    1: 
    1:   if (debugPossible) {
18509:     rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                              "DebugScriptButton",
18509:                                              debugButton);
18509: 
18509:     rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                              "KillScriptWithDebugMessage",
18509:                                              msg);
    1:   }
    1:   else {
18509:     rv |= nsContentUtils::GetLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                              "KillScriptMessage",
18509:                                              msg);
    1:   }
    1: 
    1:   //GetStringFromName can return NS_OK and still give NULL string
    1:   if (NS_FAILED(rv) || !title || !msg || !stopButton || !waitButton ||
    1:       (!debugButton && debugPossible) || !neverShowDlg) {
    1:     NS_ERROR("Failed to get localized strings.");
    1:     return JS_TRUE;
    1:   }
    1: 
 8577:   // Append file and line number information, if available
10142:   JSScript *script = fp ? ::JS_GetFrameScript(cx, fp) : nsnull;
 8577:   if (script) {
 8577:     const char *filename = ::JS_GetScriptFilename(cx, script);
 8577:     if (filename) {
 8577:       nsXPIDLString scriptLocation;
 8577:       NS_ConvertUTF8toUTF16 filenameUTF16(filename);
 8577:       const PRUnichar *formatParams[] = { filenameUTF16.get() };
18509:       rv = nsContentUtils::FormatLocalizedString(nsContentUtils::eDOM_PROPERTIES,
18509:                                                  "KillScriptLocation",
 8577:                                                  formatParams, 1,
18509:                                                  scriptLocation);
 8577: 
 8577:       if (NS_SUCCEEDED(rv) && scriptLocation) {
 8577:         msg.AppendLiteral("\n\n");
 8577:         msg.Append(scriptLocation);
 8577: 
 8577:         JSStackFrame *fp, *iterator = nsnull;
 8577:         fp = ::JS_FrameIterator(cx, &iterator);
 8577:         if (fp) {
 8577:           jsbytecode *pc = ::JS_GetFramePC(cx, fp);
 8577:           if (pc) {
 8577:             PRUint32 lineno = ::JS_PCToLineNumber(cx, script, pc);
 8577:             msg.Append(':');
 8577:             msg.AppendInt(lineno);
 8577:           }
 8577:         }
 8577:       }
 8577:     }
 8577:   }
 8577: 
34168:   PRInt32 buttonPressed = 0; //In case user exits dialog by clicking X
    1:   PRBool neverShowDlgChk = PR_FALSE;
34168:   PRUint32 buttonFlags = nsIPrompt::BUTTON_POS_1_DEFAULT +
34168:                          (nsIPrompt::BUTTON_TITLE_IS_STRING *
    1:                           (nsIPrompt::BUTTON_POS_0 + nsIPrompt::BUTTON_POS_1));
    1: 
    1:   // Add a third button if necessary:
    1:   if (debugPossible)
    1:     buttonFlags += nsIPrompt::BUTTON_TITLE_IS_STRING * nsIPrompt::BUTTON_POS_2;
    1: 
25087:   // Null out the operation callback while we're re-entering JS here.
25087:   ::JS_SetOperationCallback(cx, nsnull);
25087: 
    1:   // Open the dialog.
34168:   rv = prompt->ConfirmEx(title, msg, buttonFlags, waitButton, stopButton,
    1:                          debugButton, neverShowDlg, &neverShowDlgChk,
    1:                          &buttonPressed);
    1: 
25087:   ::JS_SetOperationCallback(cx, DOMOperationCallback);
25087: 
34168:   if (NS_FAILED(rv) || (buttonPressed == 0)) {
    1:     // Allow the script to continue running
    1: 
    1:     if (neverShowDlgChk) {
    1:       nsIPrefBranch *prefBranch = nsContentUtils::GetPrefBranch();
    1: 
    1:       if (prefBranch) {
10413:         prefBranch->SetIntPref(isTrackingChromeCodeTime ?
    1:                                "dom.max_chrome_script_run_time" :
    1:                                "dom.max_script_run_time", 0);
    1:       }
    1:     }
    1: 
10142:     ctx->mOperationCallbackTime = PR_Now();
    1:     return JS_TRUE;
    1:   }
    1:   else if ((buttonPressed == 2) && debugPossible) {
    1:     // Debug the script
    1:     jsval rval;
10142:     switch(cx->debugHooks->debuggerHandler(cx, script, ::JS_GetFramePC(cx, fp),
10142:                                            &rval,
 2433:                                            cx->debugHooks->
 2433:                                            debuggerHandlerData)) {
    1:       case JSTRAP_RETURN:
10142:         fp->rval = rval;
    1:         return JS_TRUE;
    1:       case JSTRAP_ERROR:
    1:         cx->throwing = JS_FALSE;
    1:         return JS_FALSE;
    1:       case JSTRAP_THROW:
    1:         JS_SetPendingException(cx, rval);
    1:         return JS_FALSE;
    1:       case JSTRAP_CONTINUE:
    1:       default:
    1:         return JS_TRUE;
    1:     }
    1:   }
    1: 
25709:   JS_ClearPendingException(cx);
    1:   return JS_FALSE;
    1: }
    1: 
29105: void
29105: nsJSContext::EnterModalState()
29105: {
29105:   if (!mModalStateDepth) {
29105:     mModalStateTime =  mOperationCallbackTime ? PR_Now() : 0;
29105:   }
29105:   ++mModalStateDepth;
29105: }
29105: 
29105: void
29105: nsJSContext::LeaveModalState()
29105: {
29105:   if (!mModalStateDepth) {
29105:     NS_ERROR("Uh, mismatched LeaveModalState() call!");
29105: 
29105:     return;
29105:   }
29105: 
29105:   --mModalStateDepth;
29105: 
29105:   // If we're still in a modal dialog, or mOperationCallbackTime is still
29105:   // uninitialized, do nothing.
29105:   if (mModalStateDepth || !mOperationCallbackTime) {
29105:     return;
29105:   }
29105: 
29105:   // If mOperationCallbackTime was set when we entered the first dialog
29105:   // (and mModalStateTime is thus non-zero), adjust mOperationCallbackTime
29105:   // to account for time spent in the dialog.
29105:   // If mOperationCallbackTime got set while the modal dialog was open,
29105:   // simply set mOperationCallbackTime to the closing time of the dialog so
29105:   // that we never adjust mOperationCallbackTime to be in the future. 
29105:   if (mModalStateTime) {
29105:     mOperationCallbackTime += PR_Now() - mModalStateTime;
29105:   }
29105:   else {
29105:     mOperationCallbackTime = PR_Now();
29105:   }
29105: }
29105: 
    1: #define JS_OPTIONS_DOT_STR "javascript.options."
    1: 
    1: static const char js_options_dot_str[]   = JS_OPTIONS_DOT_STR;
    1: static const char js_strict_option_str[] = JS_OPTIONS_DOT_STR "strict";
    1: static const char js_werror_option_str[] = JS_OPTIONS_DOT_STR "werror";
   49: static const char js_relimit_option_str[]= JS_OPTIONS_DOT_STR "relimit";
 7806: #ifdef JS_GC_ZEAL
 7806: static const char js_zeal_option_str[]   = JS_OPTIONS_DOT_STR "gczeal";
 7806: #endif
18253: static const char js_jit_content_str[]   = JS_OPTIONS_DOT_STR "jit.content";
18253: static const char js_jit_chrome_str[]    = JS_OPTIONS_DOT_STR "jit.chrome";
    1: 
20261: int
    1: nsJSContext::JSOptionChangedCallback(const char *pref, void *data)
    1: {
 3233:   nsJSContext *context = reinterpret_cast<nsJSContext *>(data);
    1:   PRUint32 oldDefaultJSOptions = context->mDefaultJSOptions;
    1:   PRUint32 newDefaultJSOptions = oldDefaultJSOptions;
    1: 
    1:   PRBool strict = nsContentUtils::GetBoolPref(js_strict_option_str);
    1:   if (strict)
    1:     newDefaultJSOptions |= JSOPTION_STRICT;
    1:   else
    1:     newDefaultJSOptions &= ~JSOPTION_STRICT;
    1: 
17605:   nsIScriptGlobalObject *global = context->GetGlobalObject();
18253:   // XXX should we check for sysprin instead of a chrome window, to make
18253:   // XXX components be covered by the chrome pref instead of the content one?
17605:   nsCOMPtr<nsIDOMChromeWindow> chromeWindow(do_QueryInterface(global));
23546: 
18253:   PRBool useJIT = nsContentUtils::GetBoolPref(chromeWindow ?
18253:                                               js_jit_chrome_str :
18253:                                               js_jit_content_str);
23546:   nsCOMPtr<nsIXULRuntime> xr = do_GetService(XULRUNTIME_SERVICE_CONTRACTID);
23546:   if (xr) {
23546:     PRBool safeMode = PR_FALSE;
23546:     xr->GetInSafeMode(&safeMode);
23546:     if (safeMode)
23546:       useJIT = PR_FALSE;
23546:   }    
23546: 
18253:   if (useJIT)
17605:     newDefaultJSOptions |= JSOPTION_JIT;
17605:   else
17605:     newDefaultJSOptions &= ~JSOPTION_JIT;
17605: 
 3289: #ifdef DEBUG
 3289:   // In debug builds, warnings are always enabled in chrome context
 3289:   // Note this callback is also called from context's InitClasses thus we don't
 3289:   // need to enable this directly from InitContext
 3289:   if ((newDefaultJSOptions & JSOPTION_STRICT) == 0) {
 3289:     if (chromeWindow)
 3289:       newDefaultJSOptions |= JSOPTION_STRICT;
 3289:   }
 3289: #endif
 3289: 
    1:   PRBool werror = nsContentUtils::GetBoolPref(js_werror_option_str);
    1:   if (werror)
    1:     newDefaultJSOptions |= JSOPTION_WERROR;
    1:   else
    1:     newDefaultJSOptions &= ~JSOPTION_WERROR;
    1: 
   49:   PRBool relimit = nsContentUtils::GetBoolPref(js_relimit_option_str);
   49:   if (relimit)
   49:     newDefaultJSOptions |= JSOPTION_RELIMIT;
   49:   else
   49:     newDefaultJSOptions &= ~JSOPTION_RELIMIT;
   49: 
    1:   if (newDefaultJSOptions != oldDefaultJSOptions) {
    1:     // Set options only if we used the old defaults; otherwise the page has
    1:     // customized some via the options object and we defer to its wisdom.
    1:     if (::JS_GetOptions(context->mContext) == oldDefaultJSOptions)
    1:       ::JS_SetOptions(context->mContext, newDefaultJSOptions);
    1: 
    1:     // Save the new defaults for the next page load (InitContext).
    1:     context->mDefaultJSOptions = newDefaultJSOptions;
    1:   }
 7806: 
 7806: #ifdef JS_GC_ZEAL
 7806:   PRInt32 zeal = nsContentUtils::GetIntPref(js_zeal_option_str, -1);
 7806:   if (zeal >= 0)
 7806:     ::JS_SetGCZeal(context->mContext, (PRUint8)zeal);
 7806: #endif
 7806: 
    1:   return 0;
    1: }
    1: 
    1: nsJSContext::nsJSContext(JSRuntime *aRuntime) : mGCOnDestruction(PR_TRUE)
    1: {
    1: 
    1:   ++sContextCount;
    1: 
10142:   mDefaultJSOptions = JSOPTION_PRIVATE_IS_NSISUPPORTS | JSOPTION_ANONFUNFIX;
    1: 
    1:   mContext = ::JS_NewContext(aRuntime, gStackSize);
    1:   if (mContext) {
 3233:     ::JS_SetContextPrivate(mContext, static_cast<nsIScriptContext *>(this));
    1: 
    1:     // Make sure the new context gets the default context options
    1:     ::JS_SetOptions(mContext, mDefaultJSOptions);
    1: 
   49:     // Watch for the JS boolean options
    1:     nsContentUtils::RegisterPrefCallback(js_options_dot_str,
    1:                                          JSOptionChangedCallback,
    1:                                          this);
23442: 
25087:     ::JS_SetOperationCallback(mContext, DOMOperationCallback);
    1: 
    1:     static JSLocaleCallbacks localeCallbacks =
    1:       {
    1:         LocaleToUpperCase,
    1:         LocaleToLowerCase,
    1:         LocaleCompare,
    1:         LocaleToUnicode
    1:       };
    1: 
    1:     ::JS_SetLocaleCallbacks(mContext, &localeCallbacks);
    1:   }
    1:   mIsInitialized = PR_FALSE;
21973:   mNumEvaluations = 0;
    1:   mTerminations = nsnull;
    1:   mScriptsEnabled = PR_TRUE;
29105:   mOperationCallbackTime = 0;
29105:   mModalStateTime = 0;
29105:   mModalStateDepth = 0;
    1:   mProcessingScriptTag = PR_FALSE;
    1: }
    1: 
    1: nsJSContext::~nsJSContext()
    1: {
 6016: #ifdef DEBUG
 6016:   nsCycleCollector_DEBUG_wasFreed(static_cast<nsIScriptContext*>(this));
 6016: #endif
    1:   NS_PRECONDITION(!mTerminations, "Shouldn't have termination funcs by now");
    1: 
28455:   mGlobalWrapperRef = nsnull;
28455: 
28455:   DestroyJSContext();
 7286: 
 7286:   --sContextCount;
 7286: 
 7286:   if (!sContextCount && sDidShutdown) {
 7286:     // The last context is being deleted, and we're already in the
 7286:     // process of shutting down, release the JS runtime service, and
 7286:     // the security manager.
 7286: 
 7286:     NS_IF_RELEASE(sRuntimeService);
 7286:     NS_IF_RELEASE(sSecurityManager);
 7286:     NS_IF_RELEASE(gCollation);
 7286:     NS_IF_RELEASE(gDecoder);
 7286:   }
 7286: }
 7286: 
 7286: void
28455: nsJSContext::DestroyJSContext()
 7286: {
    1:   if (!mContext)
    1:     return;
    1: 
    1:   // Clear our entry in the JSContext, bugzilla bug 66413
    1:   ::JS_SetContextPrivate(mContext, nsnull);
    1: 
    1:   // Unregister our "javascript.options.*" pref-changed callback.
    1:   nsContentUtils::UnregisterPrefCallback(js_options_dot_str,
    1:                                          JSOptionChangedCallback,
    1:                                          this);
    1: 
28455:   PRBool do_gc = mGCOnDestruction && !sGCTimer && sReadyForGC;
    1: 
    1:   // Let xpconnect destroy the JSContext when it thinks the time is right.
    1:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1:   if (xpc) {
    1:     xpc->ReleaseJSContext(mContext, !do_gc);
28455:   } else if (do_gc) {
28455:     ::JS_DestroyContext(mContext);
28439:   } else {
28455:     ::JS_DestroyContextNoGC(mContext);
    1:   }
 7286:   mContext = nsnull;
 1846: }
 1846: 
    1: // QueryInterface implementation for nsJSContext
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsJSContext)
28455: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsJSContext)
28455:   NS_ASSERTION(!tmp->mContext || tmp->mContext->outstandingRequests == 0,
28455:                "Trying to unlink a context with outstanding requests.");
28455:   tmp->mIsInitialized = PR_FALSE;
28455:   tmp->mGCOnDestruction = PR_FALSE;
28455:   tmp->DestroyJSContext();
28455: NS_IMPL_CYCLE_COLLECTION_ROOT_END
28455: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsJSContext)
28455: NS_IMPL_CYCLE_COLLECTION_TRACE_END
 7286: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsJSContext)
 7286:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mGlobalWrapperRef)
 7286: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
28455: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_REFCNT(nsJSContext, tmp->GetCCRefcnt())
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mGlobalWrapperRef)
28455:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mContext");
 7286:   nsContentUtils::XPConnect()->NoteJSContext(tmp->mContext, cb);
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsJSContext)
    1:   NS_INTERFACE_MAP_ENTRY(nsIScriptContext)
    1:   NS_INTERFACE_MAP_ENTRY(nsIXPCScriptNotify)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIScriptContext)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsJSContext, nsIScriptContext)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsJSContext, nsIScriptContext)
    1: 
28455: nsrefcnt
28455: nsJSContext::GetCCRefcnt()
28455: {
28728:   nsrefcnt refcnt = mRefCnt.get();
28728:   if (NS_LIKELY(mContext))
28728:     refcnt += mContext->outstandingRequests;
28728:   return refcnt;
28455: }
28455: 
    1: nsresult
    1: nsJSContext::EvaluateStringWithValue(const nsAString& aScript,
    1:                                      void *aScopeObject,
    1:                                      nsIPrincipal *aPrincipal,
    1:                                      const char *aURL,
    1:                                      PRUint32 aLineNo,
    1:                                      PRUint32 aVersion,
    1:                                      void* aRetValue,
    1:                                      PRBool* aIsUndefined)
    1: {
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mScriptsEnabled) {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv;
    1:   if (!aScopeObject)
    1:     aScopeObject = ::JS_GetGlobalObject(mContext);
    1: 
    1:   // Safety first: get an object representing the script's principals, i.e.,
    1:   // the entities who signed this script, or the fully-qualified-domain-name
    1:   // or "codebase" from which it was loaded.
    1:   JSPrincipals *jsprin;
    1:   nsIPrincipal *principal = aPrincipal;
    1:   if (!aPrincipal) {
    1:     nsIScriptGlobalObject *global = GetGlobalObject();
    1:     if (!global)
    1:       return NS_ERROR_FAILURE;
    1:     nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal =
    1:       do_QueryInterface(global, &rv);
    1:     if (NS_FAILED(rv))
    1:       return NS_ERROR_FAILURE;
    1:     principal = objPrincipal->GetPrincipal();
    1:     if (!principal)
    1:       return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   principal->GetJSPrincipals(mContext, &jsprin);
    1: 
    1:   // From here on, we must JSPRINCIPALS_DROP(jsprin) before returning...
    1: 
    1:   PRBool ok = PR_FALSE;
    1: 
    1:   rv = sSecurityManager->CanExecuteScripts(mContext, principal, &ok);
    1:   if (NS_FAILED(rv)) {
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Push our JSContext on the current thread's context stack so JS called
    1:   // from native code via XPConnect uses the right context.  Do this whether
    1:   // or not the SecurityManager said "ok", in order to simplify control flow
    1:   // below where we pop before returning.
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:            do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext))) {
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   jsval val;
    1: 
    1:   nsJSContext::TerminationFuncHolder holder(this);
    1: 
    1:   // SecurityManager said "ok", but don't compile if aVersion is unknown.
11775:   // Since the caller is responsible for parsing the version strings, we just
    1:   // check it isn't JSVERSION_UNKNOWN.
    1:   if (ok && ((JSVersion)aVersion) != JSVERSION_UNKNOWN) {
11775: 
    1:     JSAutoRequest ar(mContext);
11775:     nsJSVersionSetter setVersion(mContext, aVersion);
    1: 
    1:     ok = ::JS_EvaluateUCScriptForPrincipals(mContext,
    1:                                             (JSObject *)aScopeObject,
    1:                                             jsprin,
    1:                                             (jschar*)PromiseFlatString(aScript).get(),
    1:                                             aScript.Length(),
    1:                                             aURL,
    1:                                             aLineNo,
    1:                                             &val);
28612: 
28612:     if (!ok) {
28612:       // Tell XPConnect about any pending exceptions. This is needed
28612:       // to avoid dropping JS exceptions in case we got here through
28612:       // nested calls through XPConnect.
28612: 
28612:       ReportPendingException();
28612:     }
    1:   }
    1: 
    1:   // Whew!  Finally done with these manually ref-counted things.
    1:   JSPRINCIPALS_DROP(mContext, jsprin);
    1: 
    1:   // If all went well, convert val to a string (XXXbe unless undefined?).
    1:   if (ok) {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = JSVAL_IS_VOID(val);
    1:     }
    1: 
 3233:     *static_cast<jsval*>(aRetValue) = val;
    1:     // XXX - nsScriptObjectHolder should be used once this method moves to
    1:     // the new world order. However, use of 'jsval' appears to make this
    1:     // tricky...
    1:   }
    1:   else {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   // Pop here, after JS_ValueToString and any other possible evaluation.
    1:   if (NS_FAILED(stack->Pop(nsnull)))
    1:     rv = NS_ERROR_FAILURE;
    1: 
    1:   // ScriptEvaluated needs to come after we pop the stack
    1:   ScriptEvaluated(PR_TRUE);
    1: 
    1:   return rv;
    1: 
    1: }
    1: 
    1: // Helper function to convert a jsval to an nsAString, and set
    1: // exception flags if the conversion fails.
    1: static nsresult
    1: JSValueToAString(JSContext *cx, jsval val, nsAString *result,
    1:                  PRBool *isUndefined)
    1: {
    1:   if (isUndefined) {
    1:     *isUndefined = JSVAL_IS_VOID(val);
    1:   }
    1: 
    1:   if (!result) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   JSString* jsstring = ::JS_ValueToString(cx, val);
    1:   if (jsstring) {
 3233:     result->Assign(reinterpret_cast<const PRUnichar*>
 3233:                                    (::JS_GetStringChars(jsstring)),
    1:                    ::JS_GetStringLength(jsstring));
    1:   } else {
    1:     result->Truncate();
    1: 
    1:     // We failed to convert val to a string. We're either OOM, or the
    1:     // security manager denied access to .toString(), or somesuch, on
    1:     // an object. Treat this case as if the result were undefined.
    1: 
    1:     if (isUndefined) {
    1:       *isUndefined = PR_TRUE;
    1:     }
    1: 
    1:     if (!::JS_IsExceptionPending(cx)) {
    1:       // JS_ValueToString() returned null w/o an exception
    1:       // pending. That means we're OOM.
    1: 
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::EvaluateString(const nsAString& aScript,
    1:                             void *aScopeObject,
    1:                             nsIPrincipal *aPrincipal,
    1:                             const char *aURL,
    1:                             PRUint32 aLineNo,
    1:                             PRUint32 aVersion,
    1:                             nsAString *aRetValue,
    1:                             PRBool* aIsUndefined)
    1: {
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mScriptsEnabled) {
27903:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
27903:     }
    1: 
    1:     if (aRetValue) {
    1:       aRetValue->Truncate();
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv;
    1:   if (!aScopeObject)
    1:     aScopeObject = ::JS_GetGlobalObject(mContext);
    1: 
    1:   // Safety first: get an object representing the script's principals, i.e.,
    1:   // the entities who signed this script, or the fully-qualified-domain-name
    1:   // or "codebase" from which it was loaded.
    1:   JSPrincipals *jsprin;
    1:   nsIPrincipal *principal = aPrincipal;
    1:   if (aPrincipal) {
    1:     aPrincipal->GetJSPrincipals(mContext, &jsprin);
    1:   }
    1:   else {
    1:     nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal =
    1:       do_QueryInterface(GetGlobalObject(), &rv);
    1:     if (NS_FAILED(rv))
    1:       return NS_ERROR_FAILURE;
    1:     principal = objPrincipal->GetPrincipal();
    1:     if (!principal)
    1:       return NS_ERROR_FAILURE;
    1:     principal->GetJSPrincipals(mContext, &jsprin);
    1:   }
    1: 
    1:   // From here on, we must JSPRINCIPALS_DROP(jsprin) before returning...
    1: 
    1:   PRBool ok = PR_FALSE;
    1: 
    1:   rv = sSecurityManager->CanExecuteScripts(mContext, principal, &ok);
    1:   if (NS_FAILED(rv)) {
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Push our JSContext on the current thread's context stack so JS called
    1:   // from native code via XPConnect uses the right context.  Do this whether
    1:   // or not the SecurityManager said "ok", in order to simplify control flow
    1:   // below where we pop before returning.
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:            do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext))) {
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // The result of evaluation, used only if there were no errors.  This need
10142:   // not be a GC root currently, provided we run the GC only from the
10142:   // operation callback or from ScriptEvaluated.
17840:   jsval val = JSVAL_VOID;
17840:   jsval* vp = aRetValue ? &val : NULL;
    1: 
    1:   nsJSContext::TerminationFuncHolder holder(this);
    1: 
    1:   // SecurityManager said "ok", but don't compile if aVersion is unknown.
11775:   // Since the caller is responsible for parsing the version strings, we just
    1:   // check it isn't JSVERSION_UNKNOWN.
    1:   if (ok && ((JSVersion)aVersion) != JSVERSION_UNKNOWN) {
    1:     JSAutoRequest ar(mContext);
11775:     nsJSVersionSetter setVersion(mContext, aVersion);
    1: 
    1:     ok = ::JS_EvaluateUCScriptForPrincipals(mContext,
    1:                                             (JSObject *)aScopeObject,
    1:                                             jsprin,
    1:                                             (jschar*)PromiseFlatString(aScript).get(),
    1:                                             aScript.Length(),
    1:                                             aURL,
    1:                                             aLineNo,
17840:                                             vp);
    1: 
    1:     if (!ok) {
    1:       // Tell XPConnect about any pending exceptions. This is needed
    1:       // to avoid dropping JS exceptions in case we got here through
    1:       // nested calls through XPConnect.
    1: 
28612:       ReportPendingException();
    1:     }
    1:   }
    1: 
    1:   // Whew!  Finally done with these manually ref-counted things.
    1:   JSPRINCIPALS_DROP(mContext, jsprin);
    1: 
17840:   // If all went well, convert val to a string if one is wanted.
    1:   if (ok) {
    1:     JSAutoRequest ar(mContext);
    1:     rv = JSValueToAString(mContext, val, aRetValue, aIsUndefined);
    1:   }
    1:   else {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
    1:     }
    1: 
    1:     if (aRetValue) {
    1:       aRetValue->Truncate();
    1:     }
    1:   }
    1: 
    1:   // Pop here, after JS_ValueToString and any other possible evaluation.
    1:   if (NS_FAILED(stack->Pop(nsnull)))
    1:     rv = NS_ERROR_FAILURE;
    1: 
    1:   // ScriptEvaluated needs to come after we pop the stack
    1:   ScriptEvaluated(PR_TRUE);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::CompileScript(const PRUnichar* aText,
    1:                            PRInt32 aTextLength,
    1:                            void *aScopeObject,
    1:                            nsIPrincipal *aPrincipal,
    1:                            const char *aURL,
    1:                            PRUint32 aLineNo,
    1:                            PRUint32 aVersion,
    1:                            nsScriptObjectHolder &aScriptObject)
    1: {
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult rv;
    1:   NS_ENSURE_ARG_POINTER(aPrincipal);
    1: 
    1:   if (!aScopeObject)
    1:     aScopeObject = ::JS_GetGlobalObject(mContext);
    1: 
    1:   JSPrincipals *jsprin;
    1:   aPrincipal->GetJSPrincipals(mContext, &jsprin);
    1:   // From here on, we must JSPRINCIPALS_DROP(jsprin) before returning...
    1: 
    1:   PRBool ok = PR_FALSE;
    1: 
    1:   rv = sSecurityManager->CanExecuteScripts(mContext, aPrincipal, &ok);
    1:   if (NS_FAILED(rv)) {
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   aScriptObject.drop(); // ensure old object not used on failure...
    1: 
    1:   // SecurityManager said "ok", but don't compile if aVersion is unknown.
11775:   // Since the caller is responsible for parsing the version strings, we just
    1:   // check it isn't JSVERSION_UNKNOWN.
    1:   if (ok && ((JSVersion)aVersion) != JSVERSION_UNKNOWN) {
    1:     JSAutoRequest ar(mContext);
11775:     nsJSVersionSetter setVersion(mContext, aVersion);
    1: 
    1:     JSScript* script =
    1:         ::JS_CompileUCScriptForPrincipals(mContext,
    1:                                           (JSObject *)aScopeObject,
    1:                                           jsprin,
    1:                                           (jschar*) aText,
    1:                                           aTextLength,
    1:                                           aURL,
    1:                                           aLineNo);
    1:     if (script) {
    1:       JSObject *scriptObject = ::JS_NewScriptObject(mContext, script);
    1:       if (scriptObject) {
    1:         NS_ASSERTION(aScriptObject.getScriptTypeID()==JAVASCRIPT,
    1:                      "Expecting JS script object holder");
    1:         rv = aScriptObject.set(scriptObject);
    1:       } else {
    1:         ::JS_DestroyScript(mContext, script);
    1:         script = nsnull;
    1:       }
11775:     } else {
    1:       rv = NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   // Whew!  Finally done.
    1:   JSPRINCIPALS_DROP(mContext, jsprin);
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::ExecuteScript(void *aScriptObject,
    1:                            void *aScopeObject,
    1:                            nsAString* aRetValue,
    1:                            PRBool* aIsUndefined)
    1: {
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mScriptsEnabled) {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
    1:     }
    1: 
    1:     if (aRetValue) {
    1:       aRetValue->Truncate();
    1:     }
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsresult rv;
    1: 
    1:   if (!aScopeObject)
    1:     aScopeObject = ::JS_GetGlobalObject(mContext);
    1: 
    1:   // Push our JSContext on our thread's context stack, in case native code
    1:   // called from JS calls back into JS via XPConnect.
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:            do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext))) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // The result of evaluation, used only if there were no errors.  This need
10142:   // not be a GC root currently, provided we run the GC only from the
10142:   // operation callback or from ScriptEvaluated.
    1:   jsval val;
    1:   JSBool ok;
    1: 
    1:   nsJSContext::TerminationFuncHolder holder(this);
    1:   JSAutoRequest ar(mContext);
    1:   ok = ::JS_ExecuteScript(mContext,
    1:                           (JSObject *)aScopeObject,
    1:                           (JSScript*)::JS_GetPrivate(mContext,
    1:                           (JSObject*)aScriptObject),
    1:                           &val);
    1: 
    1:   if (ok) {
    1:     // If all went well, convert val to a string (XXXbe unless undefined?).
    1:     rv = JSValueToAString(mContext, val, aRetValue, aIsUndefined);
    1:   } else {
    1:     if (aIsUndefined) {
    1:       *aIsUndefined = PR_TRUE;
    1:     }
    1: 
    1:     if (aRetValue) {
    1:       aRetValue->Truncate();
    1:     }
    1:   }
    1: 
    1:   // Pop here, after JS_ValueToString and any other possible evaluation.
    1:   if (NS_FAILED(stack->Pop(nsnull)))
    1:     rv = NS_ERROR_FAILURE;
    1: 
    1:   // ScriptEvaluated needs to come after we pop the stack
    1:   ScriptEvaluated(PR_TRUE);
    1: 
    1:   return rv;
    1: }
    1: 
    1: 
    1: static inline const char *
    1: AtomToEventHandlerName(nsIAtom *aName)
    1: {
    1:   const char *name;
    1: 
    1:   aName->GetUTF8String(&name);
    1: 
    1: #ifdef DEBUG
    1:   const char *cp;
    1:   char c;
    1:   for (cp = name; *cp != '\0'; ++cp)
    1:   {
    1:     c = *cp;
    1:     NS_ASSERTION (('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z'),
    1:                   "non-ASCII non-alphabetic event handler name");
    1:   }
    1: #endif
    1: 
    1:   return name;
    1: }
    1: 
    1: // Helper function to find the JSObject associated with a (presumably DOM)
    1: // interface.
    1: nsresult
    1: nsJSContext::JSObjectFromInterface(nsISupports* aTarget, void *aScope, JSObject **aRet)
    1: {
30625:   // It is legal to specify a null target.
30625:   if (!aTarget) {
    1:       *aRet = nsnull;
    1:       return NS_OK;
    1:   }
30625: 
    1:   // Get the jsobject associated with this target
30625:   // We don't wrap here because we trust the JS engine to wrap the target
30625:   // later.
    1:   nsresult rv;
30001:   jsval v;
31981:   rv = nsContentUtils::WrapNative(mContext, (JSObject *)aScope, aTarget, &v);
    1:   NS_ENSURE_SUCCESS(rv, rv);
30001: 
    1: #ifdef NS_DEBUG
    1:   nsCOMPtr<nsISupports> targetSupp = do_QueryInterface(aTarget);
30001:   nsCOMPtr<nsISupports> native =
30001:     nsContentUtils::XPConnect()->GetNativeOfWrapper(mContext,
30001:                                                     JSVAL_TO_OBJECT(v));
30001:   NS_ASSERTION(native == targetSupp, "Native should be the target!");
    1: #endif
30001: 
30001:   *aRet = JSVAL_TO_OBJECT(v);
30001: 
30001:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsJSContext::CompileEventHandler(nsIAtom *aName,
    1:                                  PRUint32 aArgCount,
    1:                                  const char** aArgNames,
    1:                                  const nsAString& aBody,
    1:                                  const char *aURL, PRUint32 aLineNo,
11775:                                  PRUint32 aVersion,
    1:                                  nsScriptObjectHolder &aHandler)
    1: {
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
22253:   NS_PRECONDITION(!::JS_IsExceptionPending(mContext),
22253:                   "Why are we being called with a pending exception?");
22253: 
    1:   if (!sSecurityManager) {
    1:     NS_ERROR("Huh, we need a script security manager to compile "
    1:              "an event handler!");
    1: 
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1: 
11775:   // Don't compile if aVersion is unknown.  Since the caller is responsible for
11775:   // parsing the version strings, we just check it isn't JSVERSION_UNKNOWN.
11775:   if ((JSVersion)aVersion == JSVERSION_UNKNOWN) {
11775:     return NS_ERROR_ILLEGAL_VALUE;
11775:   }
11775: 
    1:   const char *charName = AtomToEventHandlerName(aName);
    1: 
26165: #ifdef DEBUG
26165:   JSContext* top = nsContentUtils::GetCurrentJSContext();
26165:   NS_ASSERTION(mContext == top, "Context not properly pushed!");
26165: #endif
26165: 
    1:   // Event handlers are always shared, and must be bound before use.
    1:   // Therefore we never bother compiling with principals.
    1:   // (that probably means we should avoid JS_CompileUCFunctionForPrincipals!)
    1:   JSAutoRequest ar(mContext);
11775:   nsJSVersionSetter setVersion(mContext, aVersion);
11775: 
    1:   JSFunction* fun =
    1:       ::JS_CompileUCFunctionForPrincipals(mContext,
    1:                                           nsnull, nsnull,
    1:                                           charName, aArgCount, aArgNames,
    1:                                           (jschar*)PromiseFlatString(aBody).get(),
    1:                                           aBody.Length(),
    1:                                           aURL, aLineNo);
    1: 
    1:   if (!fun) {
28612:     ReportPendingException();
 3187:     return NS_ERROR_ILLEGAL_VALUE;
    1:   }
    1: 
    1:   JSObject *handler = ::JS_GetFunctionObject(fun);
    1:   NS_ASSERTION(aHandler.getScriptTypeID()==JAVASCRIPT,
    1:                "Expecting JS script object holder");
    1:   return aHandler.set((void *)handler);
    1: }
    1: 
    1: // XXX - note that CompileFunction doesn't yet play the nsScriptObjectHolder
    1: // game - caller must still ensure JS GC root.
    1: nsresult
    1: nsJSContext::CompileFunction(void* aTarget,
    1:                              const nsACString& aName,
    1:                              PRUint32 aArgCount,
    1:                              const char** aArgArray,
    1:                              const nsAString& aBody,
    1:                              const char* aURL,
    1:                              PRUint32 aLineNo,
11775:                              PRUint32 aVersion,
    1:                              PRBool aShared,
    1:                              void** aFunctionObject)
    1: {
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
11775:   // Don't compile if aVersion is unknown.  Since the caller is responsible for
11775:   // parsing the version strings, we just check it isn't JSVERSION_UNKNOWN.
11775:   if ((JSVersion)aVersion == JSVERSION_UNKNOWN) {
11775:     return NS_ERROR_ILLEGAL_VALUE;
11775:   }
11775: 
    1:   JSPrincipals *jsprin = nsnull;
    1: 
    1:   nsIScriptGlobalObject *global = GetGlobalObject();
    1:   if (global) {
    1:     // XXXbe why the two-step QI? speed up via a new GetGlobalObjectData func?
    1:     nsCOMPtr<nsIScriptObjectPrincipal> globalData = do_QueryInterface(global);
    1:     if (globalData) {
    1:       nsIPrincipal *prin = globalData->GetPrincipal();
    1:       if (!prin)
    1:         return NS_ERROR_FAILURE;
    1:       prin->GetJSPrincipals(mContext, &jsprin);
    1:     }
    1:   }
    1: 
    1:   JSObject *target = (JSObject*)aTarget;
    1: 
    1:   JSAutoRequest ar(mContext);
11775:   nsJSVersionSetter setVersion(mContext, aVersion);
    1: 
    1:   JSFunction* fun =
    1:       ::JS_CompileUCFunctionForPrincipals(mContext,
    1:                                           aShared ? nsnull : target, jsprin,
    1:                                           PromiseFlatCString(aName).get(),
    1:                                           aArgCount, aArgArray,
    1:                                           (jschar*)PromiseFlatString(aBody).get(),
    1:                                           aBody.Length(),
    1:                                           aURL, aLineNo);
    1: 
    1:   if (jsprin)
    1:     JSPRINCIPALS_DROP(mContext, jsprin);
    1:   if (!fun)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   JSObject *handler = ::JS_GetFunctionObject(fun);
    1:   if (aFunctionObject)
    1:     *aFunctionObject = (void*) handler;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::CallEventHandler(nsISupports* aTarget, void *aScope, void *aHandler,
    1:                               nsIArray *aargv, nsIVariant **arv)
    1: {
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mScriptsEnabled) {
    1:     return NS_OK;
    1:   }
 4051: 
27434:   jsval targetVal = JSVAL_VOID;
27434:   JSAutoTempValueRooter tvr(mContext, 1, &targetVal);
27434: 
    1:   JSObject* target = nsnull;
27434:   nsresult rv = JSObjectFromInterface(aTarget, aScope, &target);
    1:   NS_ENSURE_SUCCESS(rv, rv);
27434: 
27434:   targetVal = OBJECT_TO_JSVAL(target);
    1: 
    1:   jsval rval = JSVAL_VOID;
    1: 
    1:   // This one's a lot easier than EvaluateString because we don't have to
    1:   // hassle with principals: they're already compiled into the JS function.
    1:   // xxxmarkh - this comment is no longer true - principals are not used at
    1:   // all now, and never were in some cases.
    1: 
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:     do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext)))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // check if the event handler can be run on the object in question
    1:   rv = sSecurityManager->CheckFunctionAccess(mContext, aHandler, target);
    1: 
    1:   nsJSContext::TerminationFuncHolder holder(this);
    1: 
    1:   if (NS_SUCCEEDED(rv)) {
    1:     // Convert args to jsvals.
    1:     void *mark;
    1:     PRUint32 argc = 0;
    1:     jsval *argv = nsnull;
    1: 
    1:     // Use |target| as the scope for wrapping the arguments, since aScope is
    1:     // the safe scope in many cases, which isn't very useful.  Wrapping aTarget
    1:     // was OK because those typically have PreCreate methods that give them the
    1:     // right scope anyway, and we want to make sure that the arguments end up
    1:     // in the same scope as aTarget.
    1:     rv = ConvertSupportsTojsvals(aargv, target, &argc,
 3233:                                  reinterpret_cast<void **>(&argv), &mark);
    1:     if (NS_FAILED(rv)) {
    1:       stack->Pop(nsnull);
    1:       return rv;
    1:     }
    1: 
    1:     AutoFreeJSStack stackGuard(mContext, mark); // ensure always freed.
    1: 
24846:     jsval funval = OBJECT_TO_JSVAL(static_cast<JSObject *>(aHandler));
    1:     JSAutoRequest ar(mContext);
    1:     PRBool ok = ::JS_CallFunctionValue(mContext, target,
    1:                                        funval, argc, argv, &rval);
    1: 
    1:     if (!ok) {
    1:       // Tell XPConnect about any pending exceptions. This is needed
    1:       // to avoid dropping JS exceptions in case we got here through
    1:       // nested calls through XPConnect.
    1: 
28612:       ReportPendingException();
    1: 
    1:       // Don't pass back results from failed calls.
    1:       rval = JSVAL_VOID;
    1: 
    1:       // Tell the caller that the handler threw an error.
    1:       rv = NS_ERROR_FAILURE;
    1:     }
    1:   }
    1: 
    1:   if (NS_FAILED(stack->Pop(nsnull)))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   // Convert to variant before calling ScriptEvaluated, as it may GC, meaning
    1:   // we would need to root rval.
    1:   JSAutoRequest ar(mContext);
    1:   if (NS_SUCCEEDED(rv)) {
11211:     if (rval == JSVAL_NULL)
11211:       *arv = nsnull;
11211:     else
    1:       rv = nsContentUtils::XPConnect()->JSToVariant(mContext, rval, arv);
    1:   }
    1: 
    1:   // ScriptEvaluated needs to come after we pop the stack
    1:   ScriptEvaluated(PR_TRUE);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::BindCompiledEventHandler(nsISupports* aTarget, void *aScope,
    1:                                       nsIAtom *aName,
    1:                                       void *aHandler)
    1: {
    1:   NS_ENSURE_ARG(aHandler);
    1:   NS_ENSURE_TRUE(mIsInitialized, NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   const char *charName = AtomToEventHandlerName(aName);
    1:   nsresult rv;
    1: 
    1:   // Get the jsobject associated with this target
    1:   JSObject *target = nsnull;
    1:   nsAutoGCRoot root(&target, &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = JSObjectFromInterface(aTarget, aScope, &target);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   JSObject *funobj = (JSObject*) aHandler;
    1: 
 6082:   JSAutoRequest ar(mContext);
 6082: 
    1:   NS_ASSERTION(JS_TypeOfValue(mContext, OBJECT_TO_JSVAL(funobj)) == JSTYPE_FUNCTION,
    1:                "Event handler object not a function");
    1: 
    1:   // Push our JSContext on our thread's context stack, in case native code
    1:   // called from JS calls back into JS via XPConnect.
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:            do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
    1:   if (NS_FAILED(rv) || NS_FAILED(stack->Push(mContext))) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Make sure the handler function is parented by its event target object
    1:   if (funobj) { // && ::JS_GetParent(mContext, funobj) != target) {
    1:     funobj = ::JS_CloneFunctionObject(mContext, funobj, target);
    1:     if (!funobj)
    1:       rv = NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(rv) &&
    1:       // Make sure the flags here match those in nsEventReceiverSH::NewResolve
    1:       !::JS_DefineProperty(mContext, target, charName,
    1:                            OBJECT_TO_JSVAL(funobj), nsnull, nsnull,
    1:                            JSPROP_ENUMERATE | JSPROP_PERMANENT)) {
28612:     ReportPendingException();
    1:     rv = NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // XXXmarkh - ideally we should assert that the wrapped native is now
    1:   // "long lived" - how to do that?
    1: 
    1:   if (NS_FAILED(stack->Pop(nsnull)) && NS_SUCCEEDED(rv)) {
    1:     rv = NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::GetBoundEventHandler(nsISupports* aTarget, void *aScope,
    1:                                   nsIAtom* aName,
    1:                                   nsScriptObjectHolder &aHandler)
    1: {
    1:     nsresult rv;
    1:     JSObject *obj = nsnull;
    1:     nsAutoGCRoot root(&obj, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     JSAutoRequest ar(mContext);
    1:     rv = JSObjectFromInterface(aTarget, aScope, &obj);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     const char *charName = AtomToEventHandlerName(aName);
    1: 
    1:     jsval funval;
    1:     if (!JS_LookupProperty(mContext, obj,
    1:                            charName, &funval))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     if (JS_TypeOfValue(mContext, funval) != JSTYPE_FUNCTION) {
    1:         NS_WARNING("Event handler object not a function");
    1:         aHandler.drop();
    1:         return NS_OK;
    1:     }
    1:     NS_ASSERTION(aHandler.getScriptTypeID()==JAVASCRIPT,
    1:                  "Expecting JS script object holder");
    1:     return aHandler.set(JSVAL_TO_OBJECT(funval));
    1: }
    1: 
    1: // serialization
    1: nsresult
    1: nsJSContext::Serialize(nsIObjectOutputStream* aStream, void *aScriptObject)
    1: {
    1:     JSObject *mJSObject = (JSObject *)aScriptObject;
    1:     if (!mJSObject)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     nsresult rv;
    1: 
    1:     JSContext* cx = mContext;
    1:     JSXDRState *xdr = ::JS_XDRNewMem(cx, JSXDR_ENCODE);
    1:     if (! xdr)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     xdr->userdata = (void*) aStream;
    1: 
    1:     JSAutoRequest ar(cx);
 3233:     JSScript *script = reinterpret_cast<JSScript*>
 3233:                                        (::JS_GetPrivate(cx, mJSObject));
    1:     if (! ::JS_XDRScript(xdr, &script)) {
    1:         rv = NS_ERROR_FAILURE;  // likely to be a principals serialization error
    1:     } else {
    1:         // Get the encoded JSXDRState data and write it.  The JSXDRState owns
    1:         // this buffer memory and will free it beneath ::JS_XDRDestroy.
    1:         //
    1:         // If an XPCOM object needs to be written in the midst of the JS XDR
    1:         // encoding process, the C++ code called back from the JS engine (e.g.,
    1:         // nsEncodeJSPrincipals in caps/src/nsJSPrincipals.cpp) will flush data
    1:         // from the JSXDRState to aStream, then write the object, then return
    1:         // to JS XDR code with xdr reset so new JS data is encoded at the front
    1:         // of the xdr's data buffer.
    1:         //
    1:         // However many XPCOM objects are interleaved with JS XDR data in the
    1:         // stream, when control returns here from ::JS_XDRScript, we'll have
    1:         // one last buffer of data to write to aStream.
    1: 
    1:         uint32 size;
 3233:         const char* data = reinterpret_cast<const char*>
 3233:                                            (::JS_XDRMemGetData(xdr, &size));
    1:         NS_ASSERTION(data, "no decoded JSXDRState data!");
    1: 
    1:         rv = aStream->Write32(size);
    1:         if (NS_SUCCEEDED(rv))
    1:             rv = aStream->WriteBytes(data, size);
    1:     }
    1: 
    1:     ::JS_XDRDestroy(xdr);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::Deserialize(nsIObjectInputStream* aStream,
    1:                          nsScriptObjectHolder &aResult)
    1: {
    1:     JSObject *result = nsnull;
    1:     nsresult rv;
    1: 
    1:     NS_TIMELINE_MARK_FUNCTION("js script deserialize");
    1: 
    1:     PRUint32 size;
    1:     rv = aStream->Read32(&size);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     char* data;
    1:     rv = aStream->ReadBytes(size, &data);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     JSContext* cx = mContext;
    1: 
    1:     JSXDRState *xdr = ::JS_XDRNewMem(cx, JSXDR_DECODE);
    1:     if (! xdr) {
    1:         rv = NS_ERROR_OUT_OF_MEMORY;
    1:     } else {
    1:         xdr->userdata = (void*) aStream;
    1:         JSAutoRequest ar(cx);
    1:         ::JS_XDRMemSetData(xdr, data, size);
    1: 
    1:         JSScript *script = nsnull;
    1:         if (! ::JS_XDRScript(xdr, &script)) {
    1:             rv = NS_ERROR_FAILURE;  // principals deserialization error?
    1:         } else {
    1:             result = ::JS_NewScriptObject(cx, script);
    1:             if (! result) {
    1:                 rv = NS_ERROR_OUT_OF_MEMORY;    // certain error
    1:                 ::JS_DestroyScript(cx, script);
    1:             }
    1:         }
    1: 
    1:         // Update data in case ::JS_XDRScript called back into C++ code to
    1:         // read an XPCOM object.
    1:         //
    1:         // In that case, the serialization process must have flushed a run
    1:         // of counted bytes containing JS data at the point where the XPCOM
    1:         // object starts, after which an encoding C++ callback from the JS
    1:         // XDR code must have written the XPCOM object directly into the
    1:         // nsIObjectOutputStream.
    1:         //
    1:         // The deserialization process will XDR-decode counted bytes up to
    1:         // but not including the XPCOM object, then call back into C++ to
    1:         // read the object, then read more counted bytes and hand them off
    1:         // to the JSXDRState, so more JS data can be decoded.
    1:         //
    1:         // This interleaving of JS XDR data and XPCOM object data may occur
    1:         // several times beneath the call to ::JS_XDRScript, above.  At the
    1:         // end of the day, we need to free (via nsMemory) the data owned by
    1:         // the JSXDRState.  So we steal it back, nulling xdr's buffer so it
    1:         // doesn't get passed to ::JS_free by ::JS_XDRDestroy.
    1: 
    1:         uint32 junk;
    1:         data = (char*) ::JS_XDRMemGetData(xdr, &junk);
    1:         if (data)
    1:             ::JS_XDRMemSetData(xdr, NULL, 0);
    1:         ::JS_XDRDestroy(xdr);
    1:     }
    1: 
    1:     // If data is null now, it must have been freed while deserializing an
    1:     // XPCOM object (e.g., a principal) beneath ::JS_XDRScript.
    1:     if (data)
    1:         nsMemory::Free(data);
    1:     NS_ASSERTION(aResult.getScriptTypeID()==JAVASCRIPT,
    1:                  "Expecting JS script object holder");
 3729: 
 3729:     // Now that we've cleaned up, handle the case when rv is a failure
 3729:     // code, which could happen for all sorts of reasons above.
 3729:     NS_ENSURE_SUCCESS(rv, rv);
 3729: 
    1:     return aResult.set(result);
    1: }
    1: 
    1: void
    1: nsJSContext::SetDefaultLanguageVersion(PRUint32 aVersion)
    1: {
    1:   ::JS_SetVersion(mContext, (JSVersion)aVersion);
    1: }
    1: 
    1: nsIScriptGlobalObject *
    1: nsJSContext::GetGlobalObject()
    1: {
    1:   JSObject *global = ::JS_GetGlobalObject(mContext);
    1: 
    1:   if (!global) {
    1:     NS_WARNING("Context has no global.");
    1:     return nsnull;
    1:   }
    1: 
    1:   JSClass *c = JS_GET_CLASS(mContext, global);
    1: 
    1:   if (!c || ((~c->flags) & (JSCLASS_HAS_PRIVATE |
    1:                             JSCLASS_PRIVATE_IS_NSISUPPORTS))) {
    1:     return nsnull;
    1:   }
    1: 
    1:   nsCOMPtr<nsIScriptGlobalObject> sgo;
    1:   nsISupports *priv =
    1:     (nsISupports *)::JS_GetPrivate(mContext, global);
    1: 
    1:   nsCOMPtr<nsIXPConnectWrappedNative> wrapped_native =
    1:     do_QueryInterface(priv);
    1: 
    1:   if (wrapped_native) {
    1:     // The global object is a XPConnect wrapped native, the native in
    1:     // the wrapper might be the nsIScriptGlobalObject
    1: 
    1:     sgo = do_QueryWrappedNative(wrapped_native);
    1:   } else {
    1:     sgo = do_QueryInterface(priv);
    1:   }
    1: 
    1:   // This'll return a pointer to something we're about to release, but
    1:   // that's ok, the JS object will hold it alive long enough.
    1:   return sgo;
    1: }
    1: 
    1: void *
    1: nsJSContext::GetNativeGlobal()
    1: {
    1:     return ::JS_GetGlobalObject(mContext);
    1: }
    1: 
    1: nsresult
    1: nsJSContext::CreateNativeGlobalForInner(
    1:                                 nsIScriptGlobalObject *aNewInner,
    1:                                 PRBool aIsChrome,
    1:                                 void **aNativeGlobal, nsISupports **aHolder)
    1: {
    1:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1:   PRUint32 flags = aIsChrome? nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT : 0;
    1:   nsCOMPtr<nsIXPConnectJSObjectHolder> jsholder;
    1:   nsresult rv = xpc->
    1:           InitClassesWithNewWrappedGlobal(mContext,
    1:                                           aNewInner, NS_GET_IID(nsISupports),
    1:                                           flags,
    1:                                           getter_AddRefs(jsholder));
    1:   if (NS_FAILED(rv))
    1:     return rv;
 3233:   jsholder->GetJSObject(reinterpret_cast<JSObject **>(aNativeGlobal));
    1:   *aHolder = jsholder.get();
    1:   NS_ADDREF(*aHolder);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::ConnectToInner(nsIScriptGlobalObject *aNewInner, void *aOuterGlobal)
    1: {
    1:   NS_ENSURE_ARG(aNewInner);
    1:   JSObject *newInnerJSObject = (JSObject *)aNewInner->GetScriptGlobal(JAVASCRIPT);
    1:   JSObject *myobject = (JSObject *)aOuterGlobal;
    1: 
    1:   // Make the inner and outer window both share the same
    1:   // prototype. The prototype we share is the outer window's
    1:   // prototype, this way XPConnect can still find the wrapper to
    1:   // use when making a call like alert() (w/o qualifying it with
    1:   // "window."). XPConnect looks up the wrapper based on the
    1:   // function object's parent, which is the object the function
    1:   // was called on, and when calling alert() we'll be calling the
    1:   // alert() function from the outer window's prototype off of the
    1:   // inner window. In this case XPConnect is able to find the
    1:   // outer (through the JSExtendedClass hook outerObject), so this
    1:   // prototype sharing works.
    1: 
    1:   // We do *not* want to use anything else out of the outer
    1:   // object's prototype chain than the first prototype, which is
    1:   // the XPConnect prototype. The rest we want from the inner
    1:   // window's prototype, i.e. the global scope polluter and
    1:   // Object.prototype. This way the outer also gets the benefits
    1:   // of the global scope polluter, and the inner window's
    1:   // Object.prototype.
    1:   JSObject *proto = ::JS_GetPrototype(mContext, myobject);
    1:   JSObject *innerProto = ::JS_GetPrototype(mContext, newInnerJSObject);
    1:   JSObject *innerProtoProto = ::JS_GetPrototype(mContext, innerProto);
    1: 
    1:   ::JS_SetPrototype(mContext, newInnerJSObject, proto);
    1:   ::JS_SetPrototype(mContext, proto, innerProtoProto);
    1:   return NS_OK;
    1: }
    1: 
    1: void *
    1: nsJSContext::GetNativeContext()
    1: {
    1:   return mContext;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::InitContext(nsIScriptGlobalObject *aGlobalObject)
    1: {
    1:   // Make sure callers of this use
    1:   // WillInitializeContext/DidInitializeContext around this call.
    1:   NS_ENSURE_TRUE(!mIsInitialized, NS_ERROR_ALREADY_INITIALIZED);
    1: 
    1:   if (!mContext)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   ::JS_SetErrorReporter(mContext, NS_ScriptErrorReporter);
    1: 
    1:   if (!aGlobalObject) {
    1:     // If we don't get a global object then there's nothing more to do here.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
21376:   nsCxPusher cxPusher;
21376:   if (!cxPusher.Push(mContext)) {
21376:     return NS_ERROR_FAILURE;
21376:   }
21376: 
    1:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1: 
    1:   JSObject *global = ::JS_GetGlobalObject(mContext);
    1: 
    1:   nsCOMPtr<nsIXPConnectJSObjectHolder> holder;
    1: 
    1:   // If there's already a global object in mContext we won't tell
    1:   // XPConnect to wrap aGlobalObject since it's already wrapped.
    1: 
 7941:   nsresult rv;
 7941: 
    1:   if (!global) {
    1:     nsCOMPtr<nsIDOMChromeWindow> chromeWindow(do_QueryInterface(aGlobalObject));
    1:     PRUint32 flags = 0;
    1: 
    1:     if (chromeWindow) {
 7987:       // Flag this window's global object and objects under it as "system",
 7987:       // for optional automated XPCNativeWrapper construction when chrome JS
 7987:       // views a content DOM.
    1:       flags = nsIXPConnect::FLAG_SYSTEM_GLOBAL_OBJECT;
    1: 
    1:       // Always enable E4X for XUL and other chrome content -- there is no
    1:       // need to preserve the <!-- script hiding hack from JS-in-HTML daze
    1:       // (introduced in 1995 for graceful script degradation in Netscape 1,
    1:       // Mosaic, and other pre-JS browsers).
    1:       ::JS_SetOptions(mContext, ::JS_GetOptions(mContext) | JSOPTION_XML);
    1:     }
    1: 
    1:     rv = xpc->InitClassesWithNewWrappedGlobal(mContext, aGlobalObject,
    1:                                               NS_GET_IID(nsISupports),
    1:                                               flags,
    1:                                               getter_AddRefs(holder));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Now check whether we need to grab a pointer to the
    1:     // XPCNativeWrapper class
29949:     if (!nsDOMClassInfo::GetXPCNativeWrapperClass()) {
    1:       JSAutoRequest ar(mContext);
    1:       rv = FindXPCNativeWrapperClass(holder);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   } else {
29951:     // There's already a global object. We are preparing this outer window
29951:     // object for use as a real outer window (i.e. everything needs to live on
29951:     // the inner window).
29951: 
29951:     // Call ClearScope to nuke any properties (e.g. Function and Object) on the
29951:     // outer object. From now on, anybody asking the outer object for these
29951:     // properties will be forwarded to the inner window.
29951:     ::JS_ClearScope(mContext, global);
29951: 
32415:     // Now that the inner and outer windows are connected, tell XPConnect to
32415:     // re-initialize the prototypes on the outer window's scope.
32415:     rv = xpc->InitClassesForOuterObject(mContext, global);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIClassInfo> ci(do_QueryInterface(aGlobalObject));
    1: 
    1:     if (ci) {
31981:       jsval v;
31981:       rv = nsContentUtils::WrapNative(mContext, global, aGlobalObject, &v,
    1:                                       getter_AddRefs(holder));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       nsCOMPtr<nsIXPConnectWrappedNative> wrapper(do_QueryInterface(holder));
    1:       NS_ENSURE_TRUE(wrapper, NS_ERROR_FAILURE);
    1: 
    1:       rv = wrapper->RefreshPrototype();
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
    1:   // Hold a strong reference to the wrapper for the global to avoid
    1:   // rooting and unrooting the global object every time its AddRef()
    1:   // or Release() methods are called
    1:   mGlobalWrapperRef = holder;
    1: 
    1:   holder->GetJSObject(&global);
    1: 
    1:   rv = InitClasses(global); // this will complete global object initialization
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::InitializeExternalClasses()
    1: {
 7941:   nsScriptNameSpaceManager *nameSpaceManager = nsJSRuntime::GetNameSpaceManager();
 7941:   NS_ENSURE_TRUE(nameSpaceManager, NS_ERROR_NOT_INITIALIZED);
 7941: 
 7941:   return nameSpaceManager->InitForContext(this);
    1: }
    1: 
    1: nsresult
    1: nsJSContext::SetProperty(void *aTarget, const char *aPropName, nsISupports *aArgs)
    1: {
    1:   PRUint32  argc;
    1:   jsval    *argv = nsnull;
    1:   void *mark;
    1: 
    1:   JSAutoRequest ar(mContext);
    1: 
    1:   nsresult rv;
    1:   rv = ConvertSupportsTojsvals(aArgs, GetNativeGlobal(), &argc,
 3233:                                reinterpret_cast<void **>(&argv), &mark);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   AutoFreeJSStack stackGuard(mContext, mark); // ensure always freed.
    1: 
 4040:   jsval vargs;
 4040: 
 4040:   // got the arguments, now attach them.
 4040: 
 4040:   // window.dialogArguments is supposed to be an array if a JS array
 4040:   // was passed to showModalDialog(), deal with that here.
 4123:   if (strcmp(aPropName, "dialogArguments") == 0 && argc <= 1) {
 4123:     vargs = argc ? argv[0] : JSVAL_VOID;
 4040:   } else {
    1:     JSObject *args = ::JS_NewArrayObject(mContext, argc, argv);
 4040:     vargs = OBJECT_TO_JSVAL(args);
 4040:   }
 4040: 
 4040:   // Make sure to use JS_DefineProperty here so that we can override
 4040:   // readonly XPConnect properties here as well (read dialogArguments).
 4040:   rv = ::JS_DefineProperty(mContext, reinterpret_cast<JSObject *>(aTarget),
 4040:                            aPropName, vargs, nsnull, nsnull, 0) ?
    1:        NS_OK : NS_ERROR_FAILURE;
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::ConvertSupportsTojsvals(nsISupports *aArgs,
    1:                                      void *aScope,
    1:                                      PRUint32 *aArgc, void **aArgv,
    1:                                      void **aMarkp)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
25214:   js_LeaveTrace(mContext);
25214: 
    1:   // If the array implements nsIJSArgArray, just grab the values directly.
    1:   nsCOMPtr<nsIJSArgArray> fastArray = do_QueryInterface(aArgs);
    1:   if (fastArray != nsnull) {
    1:     *aMarkp = nsnull;
    1:     return fastArray->GetArgs(aArgc, aArgv);
    1:   }
    1:   // Take the slower path converting each item.
    1:   // Handle only nsIArray and nsIVariant.  nsIArray is only needed for
    1:   // SetProperty('arguments', ...);
    1: 
    1:   *aArgv = nsnull;
    1:   *aArgc = 0;
    1:   *aMarkp = nsnull;
    1: 
    1:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
    1:   NS_ENSURE_TRUE(xpc, NS_ERROR_UNEXPECTED);
    1: 
    1:   if (!aArgs)
    1:     return NS_OK;
    1:   PRUint32 argCtr, argCount;
    1:   // This general purpose function may need to convert an arg array
    1:   // (window.arguments, event-handler args) and a generic property.
    1:   nsCOMPtr<nsIArray> argsArray(do_QueryInterface(aArgs));
    1: 
    1:   if (argsArray) {
    1:     rv = argsArray->GetLength(&argCount);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (argCount == 0)
    1:       return NS_OK;
    1:   } else {
    1:     argCount = 1; // the nsISupports which is not an array
    1:   }
    1: 
    1:   jsval *argv = js_AllocStack(mContext, argCount, aMarkp);
    1:   NS_ENSURE_TRUE(argv, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   if (argsArray) {
    1:     for (argCtr = 0; argCtr < argCount && NS_SUCCEEDED(rv); argCtr++) {
    1:       nsCOMPtr<nsISupports> arg;
    1:       jsval *thisval = argv + argCtr;
    1:       argsArray->QueryElementAt(argCtr, NS_GET_IID(nsISupports),
    1:                                 getter_AddRefs(arg));
    1:       if (!arg) {
    1:         *thisval = JSVAL_NULL;
    1:         continue;
    1:       }
    1:       nsCOMPtr<nsIVariant> variant(do_QueryInterface(arg));
    1:       if (variant != nsnull) {
    1:         rv = xpc->VariantToJS(mContext, (JSObject *)aScope, variant,
    1:                               thisval);
    1:       } else {
    1:         // And finally, support the nsISupportsPrimitives supplied
    1:         // by the AppShell.  It generally will pass only strings, but
    1:         // as we have code for handling all, we may as well use it.
    1:         rv = AddSupportsPrimitiveTojsvals(arg, thisval);
    1:         if (rv == NS_ERROR_NO_INTERFACE) {
 4040:           // something else - probably an event object or similar -
    1:           // just wrap it.
    1: #ifdef NS_DEBUG
    1:           // but first, check its not another nsISupportsPrimitive, as
    1:           // these are now deprecated for use with script contexts.
    1:           nsCOMPtr<nsISupportsPrimitive> prim(do_QueryInterface(arg));
    1:           NS_ASSERTION(prim == nsnull,
    1:                        "Don't pass nsISupportsPrimitives - use nsIVariant!");
    1: #endif
    1:           nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
31981:           jsval v;
31981:           rv = nsContentUtils::WrapNative(mContext, (JSObject *)aScope, arg,
31981:                                           &v, getter_AddRefs(wrapper));
    1:           if (NS_SUCCEEDED(rv)) {
31981:             *thisval = v;
    1:           }
    1:         }
    1:       }
    1:     }
    1:   } else {
    1:     nsCOMPtr<nsIVariant> variant(do_QueryInterface(aArgs));
    1:     if (variant)
    1:       rv = xpc->VariantToJS(mContext, (JSObject *)aScope, variant, argv);
    1:     else {
    1:       NS_ERROR("Not an array, not an interface?");
    1:       rv = NS_ERROR_UNEXPECTED;
    1:     }
    1:   }
    1:   if (NS_FAILED(rv)) {
    1:     js_FreeStack(mContext, *aMarkp);
    1:     return rv;
    1:   }
    1:   *aArgv = argv;
    1:   *aArgc = argCount;
    1:   return NS_OK;
    1: }
    1: 
    1: // This really should go into xpconnect somewhere...
    1: nsresult
    1: nsJSContext::AddSupportsPrimitiveTojsvals(nsISupports *aArg, jsval *aArgv)
    1: {
    1:   NS_PRECONDITION(aArg, "Empty arg");
    1: 
    1:   nsCOMPtr<nsISupportsPrimitive> argPrimitive(do_QueryInterface(aArg));
    1:   if (!argPrimitive)
    1:     return NS_ERROR_NO_INTERFACE;
    1: 
    1:   JSContext *cx = mContext;
    1:   PRUint16 type;
    1:   argPrimitive->GetType(&type);
    1: 
    1:   switch(type) {
    1:     case nsISupportsPrimitive::TYPE_CSTRING : {
    1:       nsCOMPtr<nsISupportsCString> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       nsCAutoString data;
    1: 
    1:       p->GetData(data);
    1: 
    1: 
    1:       JSString *str = ::JS_NewStringCopyN(cx, data.get(), data.Length());
    1:       NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       *aArgv = STRING_TO_JSVAL(str);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_STRING : {
    1:       nsCOMPtr<nsISupportsString> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       nsAutoString data;
    1: 
    1:       p->GetData(data);
    1: 
    1:       // cast is probably safe since wchar_t and jschar are expected
    1:       // to be equivalent; both unsigned 16-bit entities
    1:       JSString *str =
    1:         ::JS_NewUCStringCopyN(cx,
 3233:                               reinterpret_cast<const jschar *>(data.get()),
    1:                               data.Length());
    1:       NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       *aArgv = STRING_TO_JSVAL(str);
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRBOOL : {
    1:       nsCOMPtr<nsISupportsPRBool> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRBool data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = BOOLEAN_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRUINT8 : {
    1:       nsCOMPtr<nsISupportsPRUint8> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRUint8 data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = INT_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRUINT16 : {
    1:       nsCOMPtr<nsISupportsPRUint16> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRUint16 data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = INT_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRUINT32 : {
    1:       nsCOMPtr<nsISupportsPRUint32> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRUint32 data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = INT_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_CHAR : {
    1:       nsCOMPtr<nsISupportsChar> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       char data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       JSString *str = ::JS_NewStringCopyN(cx, &data, 1);
    1:       NS_ENSURE_TRUE(str, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       *aArgv = STRING_TO_JSVAL(str);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRINT16 : {
    1:       nsCOMPtr<nsISupportsPRInt16> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRInt16 data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = INT_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_PRINT32 : {
    1:       nsCOMPtr<nsISupportsPRInt32> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       PRInt32 data;
    1: 
    1:       p->GetData(&data);
    1: 
    1:       *aArgv = INT_TO_JSVAL(data);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_FLOAT : {
    1:       nsCOMPtr<nsISupportsFloat> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       float data;
    1: 
    1:       p->GetData(&data);
    1: 
16094:       JSBool ok = ::JS_NewNumberValue(cx, data, aArgv);
16094:       NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_DOUBLE : {
    1:       nsCOMPtr<nsISupportsDouble> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       double data;
    1: 
    1:       p->GetData(&data);
    1: 
16094:       JSBool ok = ::JS_NewNumberValue(cx, data, aArgv);
16094:       NS_ENSURE_TRUE(ok, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_INTERFACE_POINTER : {
    1:       nsCOMPtr<nsISupportsInterfacePointer> p(do_QueryInterface(argPrimitive));
    1:       NS_ENSURE_TRUE(p, NS_ERROR_UNEXPECTED);
    1: 
    1:       nsCOMPtr<nsISupports> data;
    1:       nsIID *iid = nsnull;
    1: 
    1:       p->GetData(getter_AddRefs(data));
    1:       p->GetDataIID(&iid);
    1:       NS_ENSURE_TRUE(iid, NS_ERROR_UNEXPECTED);
    1: 
    1:       AutoFree iidGuard(iid); // Free iid upon destruction.
    1: 
31981:       nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
31981:       jsval v;
31981:       nsresult rv = nsContentUtils::WrapNative(cx, ::JS_GetGlobalObject(cx),
31981:                                                data, iid, &v,
31981:                                                getter_AddRefs(wrapper));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
31981:       *aArgv = v;
    1: 
    1:       break;
    1:     }
    1:     case nsISupportsPrimitive::TYPE_ID :
    1:     case nsISupportsPrimitive::TYPE_PRUINT64 :
    1:     case nsISupportsPrimitive::TYPE_PRINT64 :
    1:     case nsISupportsPrimitive::TYPE_PRTIME :
    1:     case nsISupportsPrimitive::TYPE_VOID : {
    1:       NS_WARNING("Unsupported primitive type used");
    1:       *aArgv = JSVAL_NULL;
    1:       break;
    1:     }
    1:     default : {
    1:       NS_WARNING("Unknown primitive type used");
    1:       *aArgv = JSVAL_NULL;
    1:       break;
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::FindXPCNativeWrapperClass(nsIXPConnectJSObjectHolder *aHolder)
    1: {
29949:   NS_ASSERTION(!nsDOMClassInfo::GetXPCNativeWrapperClass(),
    1:                "Why was this called?");
    1: 
    1:   JSObject *globalObj;
    1:   aHolder->GetJSObject(&globalObj);
    1:   NS_ASSERTION(globalObj, "Must have global by now!");
    1: 
    1:   const char* arg = "arg";
    1:   NS_NAMED_LITERAL_STRING(body, "return new XPCNativeWrapper(arg);");
    1: 
    1:   // Can't use CompileFunction() here because our principal isn't
    1:   // inited yet and a null principal makes it fail.
    1:   JSFunction *fun =
    1:     ::JS_CompileUCFunction(mContext,
    1:                            globalObj,
    1:                            "_XPCNativeWrapperCtor",
    1:                            1, &arg,
    1:                            (jschar*)body.get(),
    1:                            body.Length(),
    1:                            "javascript:return new XPCNativeWrapper(arg);",
    1:                            1 // lineno
    1:                            );
    1:   NS_ENSURE_TRUE(fun, NS_ERROR_FAILURE);
    1: 
    1:   jsval globalVal = OBJECT_TO_JSVAL(globalObj);
    1:   jsval wrapper;
    1: 
    1:   JSBool ok = ::JS_CallFunction(mContext, globalObj, fun,
    1:                                 1, &globalVal, &wrapper);
    1:   if (!ok) {
    1:     // No need to notify about pending exceptions here; we don't
    1:     // expect any other than out of memory, really.
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   NS_ASSERTION(JSVAL_IS_OBJECT(wrapper), "This should be an object!");
    1: 
29949:   nsDOMClassInfo::SetXPCNativeWrapperClass(
12197:     ::JS_GET_CLASS(mContext, JSVAL_TO_OBJECT(wrapper)));
29949: 
    1:   return NS_OK;
    1: }
    1: 
    1: static JSPropertySpec OptionsProperties[] = {
  131:   {"strict",    (int8)JSOPTION_STRICT,   JSPROP_ENUMERATE | JSPROP_PERMANENT},
  131:   {"werror",    (int8)JSOPTION_WERROR,   JSPROP_ENUMERATE | JSPROP_PERMANENT},
  131:   {"relimit",   (int8)JSOPTION_RELIMIT,  JSPROP_ENUMERATE | JSPROP_PERMANENT},
    1:   {0}
    1: };
    1: 
18907: static JSBool
    1: GetOptionsProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:   if (JSVAL_IS_INT(id)) {
    1:     uint32 optbit = (uint32) JSVAL_TO_INT(id);
    1:     if ((optbit & (optbit - 1)) == 0 && optbit <= JSOPTION_WERROR)
    1:       *vp = (JS_GetOptions(cx) & optbit) ? JSVAL_TRUE : JSVAL_FALSE;
    1:   }
    1:   return JS_TRUE;
    1: }
    1: 
18907: static JSBool
    1: SetOptionsProperty(JSContext *cx, JSObject *obj, jsval id, jsval *vp)
    1: {
    1:   if (JSVAL_IS_INT(id)) {
    1:     uint32 optbit = (uint32) JSVAL_TO_INT(id);
    1: 
   49:     // Don't let options other than strict, werror, or relimit be set -- it
   49:     // would be bad if web page script could clear
   49:     // JSOPTION_PRIVATE_IS_NSISUPPORTS!
   49:     if (((optbit & (optbit - 1)) == 0 && optbit <= JSOPTION_WERROR) ||
   49:         optbit == JSOPTION_RELIMIT) {
    1:       JSBool optval;
30581:       JS_ValueToBoolean(cx, *vp, &optval);
    1: 
    1:       uint32 optset = ::JS_GetOptions(cx);
    1:       if (optval)
    1:         optset |= optbit;
    1:       else
    1:         optset &= ~optbit;
    1:       ::JS_SetOptions(cx, optset);
    1:     }
    1:   }
    1:   return JS_TRUE;
    1: }
    1: 
    1: static JSClass OptionsClass = {
    1:   "JSOptions",
    1:   0,
    1:   JS_PropertyStub, JS_PropertyStub, GetOptionsProperty, SetOptionsProperty,
30654:   JS_EnumerateStub, JS_ResolveStub, JS_ConvertStub, nsnull
    1: };
    1: 
    1: #ifdef NS_TRACE_MALLOC
    1: 
    1: #include <errno.h>              // XXX assume Linux if NS_TRACE_MALLOC
    1: #include <fcntl.h>
    1: #ifdef XP_UNIX
    1: #include <unistd.h>
    1: #endif
    1: #ifdef XP_WIN32
    1: #include <io.h>
    1: #endif
    1: #include "nsTraceMalloc.h"
    1: 
    1: static JSBool
    1: TraceMallocDisable(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     NS_TraceMallocDisable();
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: TraceMallocEnable(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     NS_TraceMallocEnable();
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: TraceMallocOpenLogFile(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     int fd;
    1:     JSString *str;
    1:     char *filename;
    1: 
    1:     if (argc == 0) {
    1:         fd = -1;
    1:     } else {
    1:         str = JS_ValueToString(cx, argv[0]);
    1:         if (!str)
    1:             return JS_FALSE;
    1:         filename = JS_GetStringBytes(str);
    1:         fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0644);
    1:         if (fd < 0) {
    1:             JS_ReportError(cx, "can't open %s: %s", filename, strerror(errno));
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     *rval = INT_TO_JSVAL(fd);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: TraceMallocChangeLogFD(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     int32 fd, oldfd;
    1: 
    1:     if (argc == 0) {
    1:         oldfd = -1;
    1:     } else {
    1:         if (!JS_ValueToECMAInt32(cx, argv[0], &fd))
    1:             return JS_FALSE;
    1:         oldfd = NS_TraceMallocChangeLogFD(fd);
    1:         if (oldfd == -2) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return JS_FALSE;
    1:         }
    1:     }
    1:     *rval = INT_TO_JSVAL(oldfd);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: TraceMallocCloseLogFD(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     int32 fd;
    1: 
    1:     if (argc == 0)
    1:         return JS_TRUE;
    1:     if (!JS_ValueToECMAInt32(cx, argv[0], &fd))
    1:         return JS_FALSE;
    1:     NS_TraceMallocCloseLogFD((int) fd);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: TraceMallocLogTimestamp(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSString *str;
    1:     const char *caption;
    1: 
    1:     str = JS_ValueToString(cx, argv[0]);
    1:     if (!str)
    1:         return JS_FALSE;
    1:     caption = JS_GetStringBytes(str);
    1:     NS_TraceMallocLogTimestamp(caption);
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
    1: TraceMallocDumpAllocations(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)
    1: {
    1:     JSString *str;
    1:     const char *pathname;
    1: 
    1:     str = JS_ValueToString(cx, argv[0]);
    1:     if (!str)
    1:         return JS_FALSE;
    1:     pathname = JS_GetStringBytes(str);
    1:     if (NS_TraceMallocDumpAllocations(pathname) < 0) {
    1:         JS_ReportError(cx, "can't dump to %s: %s", pathname, strerror(errno));
    1:         return JS_FALSE;
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSFunctionSpec TraceMallocFunctions[] = {
    1:     {"TraceMallocDisable",         TraceMallocDisable,         0, 0, 0},
    1:     {"TraceMallocEnable",          TraceMallocEnable,          0, 0, 0},
    1:     {"TraceMallocOpenLogFile",     TraceMallocOpenLogFile,     1, 0, 0},
    1:     {"TraceMallocChangeLogFD",     TraceMallocChangeLogFD,     1, 0, 0},
    1:     {"TraceMallocCloseLogFD",      TraceMallocCloseLogFD,      1, 0, 0},
    1:     {"TraceMallocLogTimestamp",    TraceMallocLogTimestamp,    1, 0, 0},
    1:     {"TraceMallocDumpAllocations", TraceMallocDumpAllocations, 1, 0, 0},
    1:     {nsnull,                       nsnull,                     0, 0, 0}
    1: };
    1: 
    1: #endif /* NS_TRACE_MALLOC */
    1: 
    1: #ifdef MOZ_JPROF
    1: 
    1: #include <signal.h>
    1: 
    1: inline PRBool
    1: IsJProfAction(struct sigaction *action)
    1: {
    1:     return (action->sa_sigaction &&
18876:             action->sa_flags == (SA_RESTART | SA_SIGINFO));
    1: }
    1: 
    1: void NS_JProfStartProfiling();
    1: void NS_JProfStopProfiling();
    1: 
    1: static JSBool
    1: JProfStartProfilingJS(JSContext *cx, JSObject *obj,
    1:                       uintN argc, jsval *argv, jsval *rval)
    1: {
    1:   NS_JProfStartProfiling();
    1:   return JS_TRUE;
    1: }
    1: 
    1: void NS_JProfStartProfiling()
    1: {
    1:     // Figure out whether we're dealing with SIGPROF, SIGALRM, or
    1:     // SIGPOLL profiling (SIGALRM for JP_REALTIME, SIGPOLL for
    1:     // JP_RTC_HZ)
    1:     struct sigaction action;
    1: 
    1:     sigaction(SIGALRM, nsnull, &action);
    1:     if (IsJProfAction(&action)) {
    1:         printf("Beginning real-time jprof profiling.\n");
    1:         raise(SIGALRM);
    1:         return;
    1:     }
    1: 
    1:     sigaction(SIGPROF, nsnull, &action);
    1:     if (IsJProfAction(&action)) {
    1:         printf("Beginning process-time jprof profiling.\n");
    1:         raise(SIGPROF);
    1:         return;
    1:     }
    1: 
    1:     sigaction(SIGPOLL, nsnull, &action);
    1:     if (IsJProfAction(&action)) {
    1:         printf("Beginning rtc-based jprof profiling.\n");
    1:         raise(SIGPOLL);
    1:         return;
    1:     }
    1: 
    1:     printf("Could not start jprof-profiling since JPROF_FLAGS was not set.\n");
    1: }
    1: 
    1: static JSBool
    1: JProfStopProfilingJS(JSContext *cx, JSObject *obj,
    1:                      uintN argc, jsval *argv, jsval *rval)
    1: {
    1:   NS_JProfStopProfiling();
    1:   return JS_TRUE;
    1: }
    1: 
    1: void
    1: NS_JProfStopProfiling()
    1: {
    1:     raise(SIGUSR1);
    1:     printf("Stopped jprof profiling.\n");
    1: }
    1: 
    1: static JSFunctionSpec JProfFunctions[] = {
    1:     {"JProfStartProfiling",        JProfStartProfilingJS,      0, 0, 0},
    1:     {"JProfStopProfiling",         JProfStopProfilingJS,       0, 0, 0},
    1:     {nsnull,                       nsnull,                     0, 0, 0}
    1: };
    1: 
    1: #endif /* defined(MOZ_JPROF) */
    1: 
10339: #ifdef MOZ_SHARK
10339: static JSFunctionSpec SharkFunctions[] = {
10447:     {"startShark",                 js_StartShark,              0, 0, 0},
10447:     {"stopShark",                  js_StopShark,               0, 0, 0},
10447:     {"connectShark",               js_ConnectShark,            0, 0, 0},
10447:     {"disconnectShark",            js_DisconnectShark,         0, 0, 0},
10339:     {nsnull,                       nsnull,                     0, 0, 0}
10339: };
10339: #endif
10339: 
15763: #ifdef MOZ_CALLGRIND
15763: static JSFunctionSpec CallgrindFunctions[] = {
15763:     {"startCallgrind",             js_StartCallgrind,          0, 0, 0},
15763:     {"stopCallgrind",              js_StopCallgrind,           0, 0, 0},
15763:     {"dumpCallgrind",              js_DumpCallgrind,           1, 0, 0},
15763:     {nsnull,                       nsnull,                     0, 0, 0}
15763: };
15763: #endif
15763: 
16288: #ifdef MOZ_VTUNE
16288: static JSFunctionSpec VtuneFunctions[] = {
16288:     {"startVtune",                 js_StartVtune,              1, 0, 0},
16288:     {"stopVtune",                  js_StopVtune,               0, 0, 0},
16288:     {"pauseVtune",                 js_PauseVtune,              0, 0, 0},
16288:     {"resumeVtune",                js_ResumeVtune,             0, 0, 0},
16288:     {nsnull,                       nsnull,                     0, 0, 0}
16288: };
16288: #endif
16288: 
31063: #ifdef MOZ_TRACEVIS
31063: static JSFunctionSpec EthogramFunctions[] = {
31063:     {"initEthogram",               js_InitEthogram,            0, 0, 0},
31063:     {"shutdownEthogram",           js_ShutdownEthogram,        0, 0, 0},
31063:     {nsnull,                       nsnull,                     0, 0, 0}
31063: };
31063: #endif
31063: 
    1: nsresult
    1: nsJSContext::InitClasses(void *aGlobalObj)
    1: {
    1:   nsresult rv = NS_OK;
    1: 
 3233:   JSObject *globalObj = static_cast<JSObject *>(aGlobalObj);
    1: 
    1:   rv = InitializeExternalClasses();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   JSAutoRequest ar(mContext);
    1: 
    1:   // Initialize the options object and set default options in mContext
    1:   JSObject *optionsObj = ::JS_DefineObject(mContext, globalObj, "_options",
    1:                                            &OptionsClass, nsnull, 0);
    1:   if (optionsObj &&
    1:       ::JS_DefineProperties(mContext, optionsObj, OptionsProperties)) {
    1:     ::JS_SetOptions(mContext, mDefaultJSOptions);
    1:   } else {
    1:     rv = NS_ERROR_FAILURE;
    1:   }
    1: 
    1: #ifdef NS_TRACE_MALLOC
    1:   // Attempt to initialize TraceMalloc functions
    1:   ::JS_DefineFunctions(mContext, globalObj, TraceMallocFunctions);
    1: #endif
    1: 
    1: #ifdef MOZ_JPROF
    1:   // Attempt to initialize JProf functions
    1:   ::JS_DefineFunctions(mContext, globalObj, JProfFunctions);
    1: #endif
    1: 
10339: #ifdef MOZ_SHARK
10339:   // Attempt to initialize Shark functions
10339:   ::JS_DefineFunctions(mContext, globalObj, SharkFunctions);
10339: #endif
10339: 
15763: #ifdef MOZ_CALLGRIND
15763:   // Attempt to initialize Callgrind functions
15763:   ::JS_DefineFunctions(mContext, globalObj, CallgrindFunctions);
15763: #endif
15763: 
16288: #ifdef MOZ_VTUNE
16288:   // Attempt to initialize Vtune functions
16288:   ::JS_DefineFunctions(mContext, globalObj, VtuneFunctions);
16288: #endif
16288: 
31063: #ifdef MOZ_TRACEVIS
31063:   // Attempt to initialize Ethogram functions
31063:   ::JS_DefineFunctions(mContext, globalObj, EthogramFunctions);
31063: #endif
31063: 
 3289:   JSOptionChangedCallback(js_options_dot_str, this);
 3289: 
    1:   return rv;
    1: }
    1: 
    1: void
    1: nsJSContext::ClearScope(void *aGlobalObj, PRBool aClearFromProtoChain)
    1: {
12050:   // Push our JSContext on our thread's context stack.
12050:   nsCOMPtr<nsIJSContextStack> stack =
12050:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
12050:   if (stack && NS_FAILED(stack->Push(mContext))) {
12050:     stack = nsnull;
12050:   }
12050: 
    1:   if (aGlobalObj) {
    1:     JSObject *obj = (JSObject *)aGlobalObj;
    1:     JSAutoRequest ar(mContext);
    1:     ::JS_ClearScope(mContext, obj);
    1: 
    1:     // Always clear watchpoints, to deal with two cases:
    1:     // 1.  The first document for this window is loading, and a miscreant has
    1:     //     preset watchpoints on the window object in order to attack the new
    1:     //     document's privileged information.
    1:     // 2.  A document loaded and used watchpoints on its own window, leaving
    1:     //     them set until the next document loads. We must clean up window
    1:     //     watchpoints here.
    1:     // Watchpoints set on document and subordinate objects are all cleared
    1:     // when those sub-window objects are finalized, after JS_ClearScope and
    1:     // a GC run that finds them to be garbage.
    1:     ::JS_ClearWatchPointsForObject(mContext, obj);
    1: 
    1:     // Since the prototype chain is shared between inner and outer (and
    1:     // stays with the inner), we don't clear things from the prototype
    1:     // chain when we're clearing an outer window whose current inner we
    1:     // still want.
    1:     if (aClearFromProtoChain) {
    1:       nsWindowSH::InvalidateGlobalScopePolluter(mContext, obj);
    1: 
    1:       // Clear up obj's prototype chain, but not Object.prototype.
    1:       for (JSObject *o = ::JS_GetPrototype(mContext, obj), *next;
    1:            o && (next = ::JS_GetPrototype(mContext, o)); o = next)
    1:         ::JS_ClearScope(mContext, o);
    1:     }
    1:   }
12050: 
    1:   ::JS_ClearRegExpStatics(mContext);
    1: 
12050:   if (stack) {
12050:     stack->Pop(nsnull);
12050:   }
    1: }
    1: 
    1: void
    1: nsJSContext::WillInitializeContext()
    1: {
    1:   mIsInitialized = PR_FALSE;
    1: }
    1: 
    1: void
    1: nsJSContext::DidInitializeContext()
    1: {
    1:   mIsInitialized = PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsJSContext::IsContextInitialized()
    1: {
    1:   return mIsInitialized;
    1: }
    1: 
    1: void
    1: nsJSContext::FinalizeContext()
    1: {
    1:   ;
    1: }
    1: 
    1: void
    1: nsJSContext::GC()
    1: {
    1:   FireGCTimer(PR_FALSE);
    1: }
    1: 
    1: void
    1: nsJSContext::ScriptEvaluated(PRBool aTerminated)
    1: {
    1:   if (aTerminated && mTerminations) {
    1:     // Make sure to null out mTerminations before doing anything that
    1:     // might cause new termination funcs to be added!
    1:     nsJSContext::TerminationFuncClosure* start = mTerminations;
    1:     mTerminations = nsnull;
    1: 
    1:     for (nsJSContext::TerminationFuncClosure* cur = start;
    1:          cur;
    1:          cur = cur->mNext) {
    1:       (*(cur->mTerminationFunc))(cur->mTerminationFuncArg);
    1:     }
    1:     delete start;
    1:   }
    1: 
21973:   mNumEvaluations++;
21973: 
21973: #ifdef JS_GC_ZEAL
21973:   if (mContext->runtime->gcZeal >= 2) {
21973:     MaybeGC(mContext);
21973:   } else
21973: #endif
21973:   if (mNumEvaluations > 20) {
21973:     mNumEvaluations = 0;
21973:     MaybeGC(mContext);
21973:   }
21973: 
21973:   if (aTerminated) {
29105:     mOperationCallbackTime = 0;
29105:     mModalStateTime = 0;
    1:   }
21973: }
    1: 
    1: nsresult
    1: nsJSContext::SetTerminationFunction(nsScriptTerminationFunc aFunc,
    1:                                     nsISupports* aRef)
    1: {
22652:   NS_PRECONDITION(JS_IsRunning(mContext), "should be executing script");
    1: 
    1:   nsJSContext::TerminationFuncClosure* newClosure =
    1:     new nsJSContext::TerminationFuncClosure(aFunc, aRef, mTerminations);
    1:   if (!newClosure) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   mTerminations = newClosure;
    1:   return NS_OK;
    1: }
    1: 
    1: PRBool
    1: nsJSContext::GetScriptsEnabled()
    1: {
    1:   return mScriptsEnabled;
    1: }
    1: 
    1: void
    1: nsJSContext::SetScriptsEnabled(PRBool aEnabled, PRBool aFireTimeouts)
    1: {
    1:   // eeek - this seems the wrong way around - the global should callback
    1:   // into each context, so every language is disabled.
    1:   mScriptsEnabled = aEnabled;
    1: 
    1:   nsIScriptGlobalObject *global = GetGlobalObject();
    1: 
    1:   if (global) {
    1:     global->SetScriptsEnabled(aEnabled, aFireTimeouts);
    1:   }
    1: }
    1: 
    1: 
    1: PRBool
    1: nsJSContext::GetProcessingScriptTag()
    1: {
    1:   return mProcessingScriptTag;
    1: }
    1: 
    1: void
    1: nsJSContext::SetProcessingScriptTag(PRBool aFlag)
    1: {
    1:   mProcessingScriptTag = aFlag;
    1: }
    1: 
    1: void
    1: nsJSContext::SetGCOnDestruction(PRBool aGCOnDestruction)
    1: {
    1:   mGCOnDestruction = aGCOnDestruction;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJSContext::ScriptExecuted()
    1: {
12523:   ScriptEvaluated(!::JS_IsRunning(mContext));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsJSContext::PreserveWrapper(nsIXPConnectWrappedNative *aWrapper)
    1: {
21618:   nsDOMClassInfo::PreserveNodeWrapper(aWrapper);
21618:   return NS_OK;
    1: }
    1: 
 7093: //static
 7093: void
 7093: nsJSContext::CC()
 7093: {
12201:   ++sCCollectCount;
12201: #ifdef DEBUG_smaug
12201:   printf("Will run cycle collector (%i), %lldms since previous.\n",
12201:          sCCollectCount, (PR_Now() - sPreviousCCTime) / PR_USEC_PER_MSEC);
12201: #endif
 7093:   sPreviousCCTime = PR_Now();
 7093:   sDelayedCCollectCount = 0;
12201:   sCCSuspectChanges = 0;
 7093:   // nsCycleCollector_collect() will run a ::JS_GC() indirectly, so
 7093:   // we do not explicitly call ::JS_GC() here.
12201:   sCollectedObjectsCounts = nsCycleCollector_collect();
12201:   sCCSuspectedCount = nsCycleCollector_suspectedCount();
24385:   sSavedGCCount = JS_GetGCParameter(nsJSRuntime::sRuntime, JSGC_NUMBER);
 7093: #ifdef DEBUG_smaug
21973:   printf("Collected %u objects, %u suspected objects, took %lldms\n",
21973:          sCollectedObjectsCounts, sCCSuspectedCount,
21973:          (PR_Now() - sPreviousCCTime) / PR_USEC_PER_MSEC);
 7093: #endif
 7093: }
 7093: 
24385: static inline uint32
24385: GetGCRunsSinceLastCC()
24385: {
24385:     // To avoid crash if nsJSRuntime is not properly initialized.
24385:     // See the bug 474586
24385:     if (!nsJSRuntime::sRuntime)
24385:         return 0;
24385: 
24385:     // Since JS_GetGCParameter() and sSavedGCCount are unsigned, the following
24385:     // gives the correct result even when the GC counter wraps around
24385:     // UINT32_MAX since the last call to JS_GetGCParameter(). 
24385:     return JS_GetGCParameter(nsJSRuntime::sRuntime, JSGC_NUMBER) -
24385:            sSavedGCCount;
24385: }
24385: 
 7093: //static
 7093: PRBool
 7093: nsJSContext::MaybeCC(PRBool aHigherProbability)
 7093: {
 7093:   ++sDelayedCCollectCount;
12201: 
12201:   // Don't check suspected count if CC will be called anyway.
12201:   if (sCCSuspectChanges <= NS_MIN_SUSPECT_CHANGES ||
24385:       GetGCRunsSinceLastCC() <= NS_MAX_GC_COUNT) {
12201: #ifdef DEBUG_smaug
12201:     PRTime now = PR_Now();
12201: #endif
12201:     PRUint32 suspected = nsCycleCollector_suspectedCount();
12201: #ifdef DEBUG_smaug
12201:     printf("%u suspected objects (%lldms), sCCSuspectedCount %u\n",
12201:             suspected, (PR_Now() - now) / PR_USEC_PER_MSEC,
12201:             sCCSuspectedCount);
12201: #endif
12201:     // Update only when suspected count has increased.
12201:     if (suspected > sCCSuspectedCount) {
12201:       sCCSuspectChanges += (suspected - sCCSuspectedCount);
12201:       sCCSuspectedCount = suspected;
12201:     }
12201:   }
12201: #ifdef DEBUG_smaug
24385:   printf("sCCSuspectChanges %u, GC runs %u\n",
24385:          sCCSuspectChanges, GetGCRunsSinceLastCC());
12201: #endif
12201: 
 7093:   // Increase the probability also if the previous call to cycle collector
 7093:   // collected something.
12201:   if (aHigherProbability ||
12201:       sCollectedObjectsCounts > NS_COLLECTED_OBJECTS_LIMIT) {
 7093:     sDelayedCCollectCount *= NS_PROBABILITY_MULTIPLIER;
 7093:   }
 7093: 
12201:   if (!sGCTimer &&
12201:       (sDelayedCCollectCount > NS_MAX_DELAYED_CCOLLECT) &&
12201:       ((sCCSuspectChanges > NS_MIN_SUSPECT_CHANGES &&
24385:         GetGCRunsSinceLastCC() > NS_MAX_GC_COUNT) ||
12201:        (sCCSuspectChanges > NS_MAX_SUSPECT_CHANGES))) {
30070:     return IntervalCC();
 7093:   }
 7093:   return PR_FALSE;
 7093: }
 7093: 
 7093: //static
 7093: void
 7093: nsJSContext::CCIfUserInactive()
 7093: {
 7093:   if (sUserIsActive) {
 7093:     MaybeCC(PR_TRUE);
 7093:   } else {
30070:     IntervalCC();
30070:   }
30070: }
30070: 
30070: //static
30070: PRBool
30070: nsJSContext::IntervalCC()
30070: {
30070:   if ((PR_Now() - sPreviousCCTime) >=
30070:       PRTime(NS_MIN_CC_INTERVAL * PR_USEC_PER_MSEC)) {
30070:     nsJSContext::CC();
30070:     return PR_TRUE;
30070:   }
30070: #ifdef DEBUG_smaug
30070:   printf("Running CC was delayed because of NS_MIN_CC_INTERVAL.\n");
30070: #endif
30070:   return PR_FALSE;
 7093: }
 7093: 
24951: // static
24951: void
24951: GCTimerFired(nsITimer *aTimer, void *aClosure)
    1: {
    1:   NS_RELEASE(sGCTimer);
    1: 
    1:   if (sPendingLoadCount == 0 || sLoadInProgressGCTimer) {
    1:     sLoadInProgressGCTimer = PR_FALSE;
    1: 
    1:     // Reset sPendingLoadCount in case the timer that fired was a
    1:     // timer we scheduled due to a normal GC timer firing while
    1:     // documents were loading. If this happens we're waiting for a
    1:     // document that is taking a long time to load, and we effectively
    1:     // ignore the fact that the currently loading documents are still
    1:     // loading and move on as if they weren't.
    1:     sPendingLoadCount = 0;
    1: 
24951:     nsJSContext::CCIfUserInactive();
    1:   } else {
24951:     nsJSContext::FireGCTimer(PR_TRUE);
    1:   }
    1: 
    1:   sReadyForGC = PR_TRUE;
    1: }
    1: 
    1: // static
    1: void
    1: nsJSContext::LoadStart()
    1: {
    1:   ++sPendingLoadCount;
    1: }
    1: 
    1: // static
    1: void
 7080: nsJSContext::LoadEnd()
    1: {
    1:   // sPendingLoadCount is not a well managed load counter (and doesn't
    1:   // need to be), so make sure we don't make it wrap backwards here.
    1:   if (sPendingLoadCount > 0) {
    1:     --sPendingLoadCount;
    1:   }
    1: 
    1:   if (!sPendingLoadCount && sLoadInProgressGCTimer) {
    1:     sGCTimer->Cancel();
    1:     NS_RELEASE(sGCTimer);
    1:     sLoadInProgressGCTimer = PR_FALSE;
    1: 
 7093:     CCIfUserInactive();
    1:   }
    1: }
    1: 
24951: // static
    1: void
    1: nsJSContext::FireGCTimer(PRBool aLoadInProgress)
    1: {
    1:   if (sGCTimer) {
    1:     // There's already a timer for GC'ing, just return
    1:     return;
    1:   }
    1: 
    1:   CallCreateInstance("@mozilla.org/timer;1", &sGCTimer);
    1: 
    1:   if (!sGCTimer) {
    1:     NS_WARNING("Failed to create timer");
    1: 
    1:     // Reset sLoadInProgressGCTimer since we're not able to fire the
    1:     // timer.
    1:     sLoadInProgressGCTimer = PR_FALSE;
    1: 
 7093:     CCIfUserInactive();
    1:     return;
    1:   }
    1: 
    1:   static PRBool first = PR_TRUE;
    1: 
24951:   sGCTimer->InitWithFuncCallback(GCTimerFired, nsnull,
    1:                                  first ? NS_FIRST_GC_DELAY :
    1:                                  aLoadInProgress ? NS_LOAD_IN_PROCESS_GC_DELAY :
    1:                                                    NS_GC_DELAY,
    1:                                  nsITimer::TYPE_ONE_SHOT);
    1: 
    1:   sLoadInProgressGCTimer = aLoadInProgress;
    1: 
    1:   first = PR_FALSE;
    1: }
    1: 
18907: static JSBool
    1: DOMGCCallback(JSContext *cx, JSGCStatus status)
    1: {
    1:   JSBool result = gOldJSGCCallback ? gOldJSGCCallback(cx, status) : JS_TRUE;
    1: 
    1:   if (status == JSGC_BEGIN && !NS_IsMainThread())
    1:     return JS_FALSE;
    1: 
    1:   return result;
    1: }
    1: 
    1: // Script object mananagement - note duplicate implementation
    1: // in nsJSRuntime below...
    1: nsresult
    1: nsJSContext::HoldScriptObject(void* aScriptObject)
    1: {
    1:     NS_ASSERTION(sIsInitialized, "runtime not initialized");
    1:     if (! nsJSRuntime::sRuntime) {
    1:         NS_NOTREACHED("couldn't add GC root - no runtime");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     ::JS_LockGCThingRT(nsJSRuntime::sRuntime, aScriptObject);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSContext::DropScriptObject(void* aScriptObject)
    1: {
    1:   NS_ASSERTION(sIsInitialized, "runtime not initialized");
    1:   if (! nsJSRuntime::sRuntime) {
    1:     NS_NOTREACHED("couldn't remove GC root");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   ::JS_UnlockGCThingRT(nsJSRuntime::sRuntime, aScriptObject);
    1:   return NS_OK;
    1: }
    1: 
13341: void
28612: nsJSContext::ReportPendingException()
13341: {
28612:   // set aside the frame chain, since it has nothing to do with the
28612:   // exception we're reporting.
13341:   if (mIsInitialized && ::JS_IsExceptionPending(mContext)) {
28612:     JSStackFrame* frame = JS_SaveFrameChain(mContext);
13341:     ::JS_ReportPendingException(mContext);
22751:     JS_RestoreFrameChain(mContext, frame);
22751:   }
13341: }
13341: 
    1: /**********************************************************************
    1:  * nsJSRuntime implementation
    1:  *********************************************************************/
    1: 
    1: // QueryInterface implementation for nsJSRuntime
    1: NS_INTERFACE_MAP_BEGIN(nsJSRuntime)
    1:   NS_INTERFACE_MAP_ENTRY(nsIScriptRuntime)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
    1: NS_IMPL_ADDREF(nsJSRuntime)
    1: NS_IMPL_RELEASE(nsJSRuntime)
    1: 
    1: nsresult
    1: nsJSRuntime::CreateContext(nsIScriptContext **aContext)
    1: {
    1:   nsCOMPtr<nsIScriptContext> scriptContext;
    1: 
    1:   *aContext = new nsJSContext(sRuntime);
    1:   NS_ENSURE_TRUE(*aContext, NS_ERROR_OUT_OF_MEMORY);
    1:   NS_ADDREF(*aContext);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSRuntime::ParseVersion(const nsString &aVersionStr, PRUint32 *flags)
    1: {
    1:     NS_PRECONDITION(flags, "Null flags param?");
    1:     JSVersion jsVersion = JSVERSION_UNKNOWN;
    1:     if (aVersionStr.Length() != 3 || aVersionStr[0] != '1' || aVersionStr[1] != '.')
    1:         jsVersion = JSVERSION_UNKNOWN;
    1:     else switch (aVersionStr[2]) {
    1:         case '0': jsVersion = JSVERSION_1_0; break;
    1:         case '1': jsVersion = JSVERSION_1_1; break;
    1:         case '2': jsVersion = JSVERSION_1_2; break;
    1:         case '3': jsVersion = JSVERSION_1_3; break;
    1:         case '4': jsVersion = JSVERSION_1_4; break;
    1:         case '5': jsVersion = JSVERSION_1_5; break;
    1:         case '6': jsVersion = JSVERSION_1_6; break;
    1:         case '7': jsVersion = JSVERSION_1_7; break;
 1981:         case '8': jsVersion = JSVERSION_1_8; break;
    1:         default:  jsVersion = JSVERSION_UNKNOWN;
    1:     }
    1:     *flags = (PRUint32)jsVersion;
    1:     return NS_OK;
    1: }
    1: 
    1: //static
    1: void
    1: nsJSRuntime::Startup()
    1: {
    1:   // initialize all our statics, so that we can restart XPCOM
 7093:   sDelayedCCollectCount = 0;
 7093:   sCCollectCount = 0;
 7093:   sUserIsActive = PR_FALSE;
 7093:   sPreviousCCTime = 0;
12201:   sCollectedObjectsCounts = 0;
24385:   sSavedGCCount = 0;
12201:   sCCSuspectChanges = 0;
12201:   sCCSuspectedCount = 0;
    1:   sGCTimer = nsnull;
    1:   sReadyForGC = PR_FALSE;
    1:   sLoadInProgressGCTimer = PR_FALSE;
    1:   sPendingLoadCount = 0;
    1:   gNameSpaceManager = nsnull;
    1:   sRuntimeService = nsnull;
    1:   sRuntime = nsnull;
    1:   gOldJSGCCallback = nsnull;
    1:   sIsInitialized = PR_FALSE;
    1:   sDidShutdown = PR_FALSE;
    1:   sContextCount = 0;
    1:   sSecurityManager = nsnull;
    1:   gCollation = nsnull;
    1: }
    1: 
20261: static int
    1: MaxScriptRunTimePrefChangedCallback(const char *aPrefName, void *aClosure)
    1: {
    1:   // Default limit on script run time to 10 seconds. 0 means let
    1:   // scripts run forever.
    1:   PRBool isChromePref =
    1:     strcmp(aPrefName, "dom.max_chrome_script_run_time") == 0;
    1:   PRInt32 time = nsContentUtils::GetIntPref(aPrefName, isChromePref ? 20 : 10);
    1: 
    1:   PRTime t;
    1:   if (time <= 0) {
    1:     // Let scripts run for a really, really long time.
    1:     t = LL_INIT(0x40000000, 0);
    1:   } else {
    1:     t = time * PR_USEC_PER_SEC;
    1:   }
    1: 
    1:   if (isChromePref) {
    1:     sMaxChromeScriptRunTime = t;
    1:   } else {
    1:     sMaxScriptRunTime = t;
    1:   }
    1: 
    1:   return 0;
    1: }
    1: 
20261: static int
14170: ReportAllJSExceptionsPrefChangedCallback(const char* aPrefName, void* aClosure)
14170: {
14170:   PRBool reportAll = nsContentUtils::GetBoolPref(aPrefName, PR_FALSE);
14170:   nsContentUtils::XPConnect()->SetReportAllJSExceptions(reportAll);
14170:   return 0;
14170: }
14170: 
30112: static int
30112: SetMemoryHighWaterMarkPrefChangedCallback(const char* aPrefName, void* aClosure)
30112: {
30112:   PRInt32 highwatermark = nsContentUtils::GetIntPref(aPrefName, 32);
30112: 
31888:   if (highwatermark >= 32) {
31888:     // There are two options of memory usage in tracemonkey. One is
31888:     // to use malloc() and the other is to use memory for GC. (E.g.
31888:     // js_NewGCThing()/RefillDoubleFreeList()).
31888:     // Let's limit the high water mark for the first one to 32MB,
31888:     // and second one to 0xffffffff.
31888:     JS_SetGCParameter(nsJSRuntime::sRuntime, JSGC_MAX_MALLOC_BYTES,
31888:                       32L * 1024L * 1024L);
30112:     JS_SetGCParameter(nsJSRuntime::sRuntime, JSGC_MAX_BYTES,
31888:                       0xffffffff);
31888:   } else {
31888:     JS_SetGCParameter(nsJSRuntime::sRuntime, JSGC_MAX_MALLOC_BYTES,
31888:                       highwatermark * 1024L * 1024L);
31888:     JS_SetGCParameter(nsJSRuntime::sRuntime, JSGC_MAX_BYTES,
31888:                       highwatermark * 1024L * 1024L);
31888:   }
31888:   return 0;
31888: }
31888: 
31888: static int
31888: SetMemoryGCFrequencyPrefChangedCallback(const char* aPrefName, void* aClosure)
31888: {
31888:   PRInt32 triggerFactor = nsContentUtils::GetIntPref(aPrefName, 1600);
31888:   JS_SetGCParameter(nsJSRuntime::sRuntime, JSGC_TRIGGER_FACTOR, triggerFactor);
30112:   return 0;
30112: }
30112: 
18907: static JSPrincipals *
    1: ObjectPrincipalFinder(JSContext *cx, JSObject *obj)
    1: {
    1:   if (!sSecurityManager)
    1:     return nsnull;
    1: 
    1:   nsCOMPtr<nsIPrincipal> principal;
    1:   nsresult rv =
    1:     sSecurityManager->GetObjectPrincipal(cx, obj,
    1:                                          getter_AddRefs(principal));
    1: 
    1:   if (NS_FAILED(rv) || !principal) {
    1:     return nsnull;
    1:   }
    1: 
    1:   JSPrincipals *jsPrincipals = nsnull;
    1:   principal->GetJSPrincipals(cx, &jsPrincipals);
    1: 
    1:   // nsIPrincipal::GetJSPrincipals() returns a strong reference to the
    1:   // JS principals, but the caller of this function expects a weak
    1:   // reference. So we need to release here.
    1: 
    1:   JSPRINCIPALS_DROP(cx, jsPrincipals);
    1: 
    1:   return jsPrincipals;
    1: }
    1: 
    1: //static
    1: nsresult
    1: nsJSRuntime::Init()
    1: {
    1:   if (sIsInitialized) {
    1:     if (!nsContentUtils::XPConnect())
    1:       return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     return NS_OK;
    1:   }
    1: 
18871:   nsresult rv = CallGetService(NS_SCRIPTSECURITYMANAGER_CONTRACTID,
18871:                                &sSecurityManager);
18871:   NS_ENSURE_SUCCESS(rv, rv);
18871: 
18871:   rv = CallGetService(kJSRuntimeServiceContractID, &sRuntimeService);
    1:   // get the JSRuntime from the runtime svc, if possible
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = sRuntimeService->GetRuntime(&sRuntime);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Let's make sure that our main thread is the same as the xpcom main thread.
    1:   NS_ASSERTION(NS_IsMainThread(), "bad");
    1: 
    1:   NS_ASSERTION(!gOldJSGCCallback,
    1:                "nsJSRuntime initialized more than once");
    1: 
24385:   sSavedGCCount = JS_GetGCParameter(nsJSRuntime::sRuntime, JSGC_NUMBER);
24385: 
    1:   // Save the old GC callback to chain to it, for GC-observing generality.
    1:   gOldJSGCCallback = ::JS_SetGCCallbackRT(sRuntime, DOMGCCallback);
    1: 
18871:   JSSecurityCallbacks *callbacks = JS_GetRuntimeSecurityCallbacks(sRuntime);
18871:   NS_ASSERTION(callbacks, "SecMan should have set security callbacks!");
18871: 
18871:   callbacks->findObjectPrincipals = ObjectPrincipalFinder;
    1: 
    1:   // Set these global xpconnect options...
    1:   nsContentUtils::RegisterPrefCallback("dom.max_script_run_time",
    1:                                        MaxScriptRunTimePrefChangedCallback,
    1:                                        nsnull);
    1:   MaxScriptRunTimePrefChangedCallback("dom.max_script_run_time", nsnull);
    1: 
    1:   nsContentUtils::RegisterPrefCallback("dom.max_chrome_script_run_time",
    1:                                        MaxScriptRunTimePrefChangedCallback,
    1:                                        nsnull);
    1:   MaxScriptRunTimePrefChangedCallback("dom.max_chrome_script_run_time",
    1:                                       nsnull);
    1: 
14170:   nsContentUtils::RegisterPrefCallback("dom.report_all_js_exceptions",
14170:                                        ReportAllJSExceptionsPrefChangedCallback,
14170:                                        nsnull);
14170:   ReportAllJSExceptionsPrefChangedCallback("dom.report_all_js_exceptions",
14170:                                            nsnull);
14170: 
30112:   nsContentUtils::RegisterPrefCallback("javascript.options.mem.high_water_mark",
30112:                                        SetMemoryHighWaterMarkPrefChangedCallback,
30112:                                        nsnull);
30112:   SetMemoryHighWaterMarkPrefChangedCallback("javascript.options.mem.high_water_mark",
30112:                                             nsnull);
30112: 
31888:   nsContentUtils::RegisterPrefCallback("javascript.options.mem.gc_frequency",
31888:                                        SetMemoryGCFrequencyPrefChangedCallback,
31888:                                        nsnull);
31888:   SetMemoryGCFrequencyPrefChangedCallback("javascript.options.mem.gc_frequency",
31888:                                           nsnull);
31888: 
 7093:   nsCOMPtr<nsIObserverService> obs =
 7093:     do_GetService("@mozilla.org/observer-service;1", &rv);
 7093:   NS_ENSURE_SUCCESS(rv, rv);
 7093:   nsIObserver* activityObserver = new nsUserActivityObserver();
 7093:   NS_ENSURE_TRUE(activityObserver, NS_ERROR_OUT_OF_MEMORY);
 7093:   obs->AddObserver(activityObserver, "user-interaction-inactive", PR_FALSE);
 7093:   obs->AddObserver(activityObserver, "user-interaction-active", PR_FALSE);
 7093:   obs->AddObserver(activityObserver, "xpcom-shutdown", PR_FALSE);
 7093: 
 7369:   nsIObserver* ccMemPressureObserver = new nsCCMemoryPressureObserver();
 7369:   NS_ENSURE_TRUE(ccMemPressureObserver, NS_ERROR_OUT_OF_MEMORY);
 7369:   obs->AddObserver(ccMemPressureObserver, "memory-pressure", PR_FALSE);
 7369: 
18871:   sIsInitialized = PR_TRUE;
    1: 
    1:   return rv;
    1: }
    1: 
 7941: //static
 7941: nsScriptNameSpaceManager*
 7941: nsJSRuntime::GetNameSpaceManager()
 7941: {
 7941:   if (sDidShutdown)
 7941:     return nsnull;
 7941: 
 7941:   if (!gNameSpaceManager) {
 7941:     gNameSpaceManager = new nsScriptNameSpaceManager;
 7941:     NS_ENSURE_TRUE(gNameSpaceManager, nsnull);
 7941: 
 7941:     nsresult rv = gNameSpaceManager->Init();
 7941:     NS_ENSURE_SUCCESS(rv, nsnull);
 7941:   }
 7941: 
 7941:   return gNameSpaceManager;
 7941: }
 7941: 
19157: /* static */
19157: void
19157: nsJSRuntime::Shutdown()
    1: {
    1:   if (sGCTimer) {
    1:     // We're being shut down, if we have a GC timer scheduled, cancel
    1:     // it. The DOM factory will do one final GC once it's shut down.
    1: 
    1:     sGCTimer->Cancel();
    1: 
    1:     NS_RELEASE(sGCTimer);
    1: 
    1:     sLoadInProgressGCTimer = PR_FALSE;
    1:   }
    1: 
    1:   delete gNameSpaceManager;
    1:   gNameSpaceManager = nsnull;
    1: 
    1:   if (!sContextCount) {
    1:     // We're being shutdown, and there are no more contexts
    1:     // alive, release the JS runtime service and the security manager.
    1: 
    1:     if (sRuntimeService && sSecurityManager) {
18871:       JSSecurityCallbacks *callbacks = JS_GetRuntimeSecurityCallbacks(sRuntime);
18871:       if (callbacks) {
18871:         NS_ASSERTION(callbacks->findObjectPrincipals == ObjectPrincipalFinder,
18871:                      "Fighting over the findObjectPrincipals callback!");
18871:         callbacks->findObjectPrincipals = NULL;
18871:       }
    1:     }
    1:     NS_IF_RELEASE(sRuntimeService);
    1:     NS_IF_RELEASE(sSecurityManager);
    1:     NS_IF_RELEASE(gCollation);
    1:     NS_IF_RELEASE(gDecoder);
    1:   }
    1: 
    1:   sDidShutdown = PR_TRUE;
    1: }
    1: 
    1: // Script object mananagement - note duplicate implementation
    1: // in nsJSContext above...
    1: nsresult
    1: nsJSRuntime::HoldScriptObject(void* aScriptObject)
    1: {
    1:     NS_ASSERTION(sIsInitialized, "runtime not initialized");
    1:     if (! sRuntime) {
    1:         NS_NOTREACHED("couldn't remove GC root - no runtime");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1: 
    1:     ::JS_LockGCThingRT(sRuntime, aScriptObject);
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsJSRuntime::DropScriptObject(void* aScriptObject)
    1: {
    1:   NS_ASSERTION(sIsInitialized, "runtime not initialized");
    1:   if (! sRuntime) {
    1:     NS_NOTREACHED("couldn't remove GC root");
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   ::JS_UnlockGCThingRT(sRuntime, aScriptObject);
    1:   return NS_OK;
    1: }
    1: 
    1: // A factory for the runtime.
    1: nsresult NS_CreateJSRuntime(nsIScriptRuntime **aRuntime)
    1: {
    1:   nsresult rv = nsJSRuntime::Init();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   *aRuntime = new nsJSRuntime();
    1:   if (*aRuntime == nsnull)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   NS_IF_ADDREF(*aRuntime);
    1:   return NS_OK;
    1: }
    1: 
    1: // A fast-array class for JS.  This class supports both nsIJSScriptArray and
    1: // nsIArray.  If it is JS itself providing and consuming this class, all work
    1: // can be done via nsIJSScriptArray, and avoid the conversion of elements
    1: // to/from nsISupports.
    1: // When consumed by non-JS (eg, another script language), conversion is done
    1: // on-the-fly.
    1: class nsJSArgArray : public nsIJSArgArray, public nsIArray {
    1: public:
    1:   nsJSArgArray(JSContext *aContext, PRUint32 argc, jsval *argv, nsresult *prv);
    1:   ~nsJSArgArray();
    1:   // nsISupports
    1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 7230:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS_AMBIGUOUS(nsJSArgArray,
 7230:                                                          nsIJSArgArray)
    1: 
    1:   // nsIArray
    1:   NS_DECL_NSIARRAY
    1: 
    1:   // nsIJSArgArray
    1:   nsresult GetArgs(PRUint32 *argc, void **argv);
    1: 
    1:   void ReleaseJSObjects();
    1: 
    1: protected:
    1:   JSContext *mContext;
    1:   jsval *mArgv;
    1:   PRUint32 mArgc;
    1: };
    1: 
    1: nsJSArgArray::nsJSArgArray(JSContext *aContext, PRUint32 argc, jsval *argv,
    1:                            nsresult *prv) :
    1:     mContext(aContext),
    1:     mArgv(argv),
    1:     mArgc(argc)
    1: {
    1:   // copy the array - we don't know its lifetime, and ours is tied to xpcom
    1:   // refcounting.  Alloc zero'd array so cleanup etc is safe.
    1:   mArgv = (jsval *) PR_CALLOC(argc * sizeof(jsval));
    1:   if (!mArgv) {
    1:     *prv = NS_ERROR_OUT_OF_MEMORY;
    1:     return;
    1:   }
 6082: 
 7230:   // Callers are allowed to pass in a null argv even for argc > 0. They can
 7230:   // then use GetArgs to initialize the values.
 7230:   if (argv) {
 7230:     for (PRUint32 i = 0; i < argc; ++i)
    1:       mArgv[i] = argv[i];
 7230:   }
 7264: 
 7264:   *prv = argc > 0 ? NS_HOLD_JS_OBJECTS(this, nsJSArgArray) : NS_OK;
    1: }
    1: 
    1: nsJSArgArray::~nsJSArgArray()
    1: {
    1:   ReleaseJSObjects();
    1: }
    1: 
    1: void
    1: nsJSArgArray::ReleaseJSObjects()
    1: {
 7230:   if (mArgc > 0)
 7230:     NS_DROP_JS_OBJECTS(this, nsJSArgArray);
    1:   if (mArgv) {
    1:     PR_DELETE(mArgv);
    1:   }
    1:   mArgc = 0;
    1: }
    1: 
    1: // QueryInterface implementation for nsJSArgArray
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsJSArgArray)
10981: NS_IMPL_CYCLE_COLLECTION_ROOT_BEGIN(nsJSArgArray)
    1:   tmp->ReleaseJSObjects();
10981: NS_IMPL_CYCLE_COLLECTION_ROOT_END
10981: NS_IMPL_CYCLE_COLLECTION_UNLINK_0(nsJSArgArray)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsJSArgArray)
 7230:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_SCRIPT_OBJECTS
 7230: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 7230: 
 7230: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsJSArgArray)
    1:   jsval *argv = tmp->mArgv;
    1:   if (argv) {
    1:     jsval *end;
    1:     for (end = argv + tmp->mArgc; argv < end; ++argv) {
 7230:       if (JSVAL_IS_GCTHING(*argv))
 7230:         NS_IMPL_CYCLE_COLLECTION_TRACE_CALLBACK(JAVASCRIPT,
 7230:                                                 JSVAL_TO_GCTHING(*argv))
 7230:     }
 7230:   }
 7230: NS_IMPL_CYCLE_COLLECTION_TRACE_END
    1: 
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsJSArgArray)
    1:   NS_INTERFACE_MAP_ENTRY(nsIArray)
    1:   NS_INTERFACE_MAP_ENTRY(nsIJSArgArray)
    1:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIJSArgArray)
    1: NS_INTERFACE_MAP_END
    1: 
    1: NS_IMPL_CYCLE_COLLECTING_ADDREF_AMBIGUOUS(nsJSArgArray, nsIJSArgArray)
    1: NS_IMPL_CYCLE_COLLECTING_RELEASE_AMBIGUOUS(nsJSArgArray, nsIJSArgArray)
    1: 
    1: nsresult
    1: nsJSArgArray::GetArgs(PRUint32 *argc, void **argv)
    1: {
    1:   if (!mArgv) {
    1:     NS_WARNING("nsJSArgArray has no argv!");
    1:     return NS_ERROR_UNEXPECTED;
    1:   }
    1:   *argv = (void *)mArgv;
    1:   *argc = mArgc;
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIArray impl
    1: NS_IMETHODIMP nsJSArgArray::GetLength(PRUint32 *aLength)
    1: {
    1:   *aLength = mArgc;
    1:   return NS_OK;
    1: }
    1: 
    1: /* void queryElementAt (in unsigned long index, in nsIIDRef uuid, [iid_is (uuid), retval] out nsQIResult result); */
    1: NS_IMETHODIMP nsJSArgArray::QueryElementAt(PRUint32 index, const nsIID & uuid, void * *result)
    1: {
    1:   *result = nsnull;
    1:   if (index >= mArgc)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   if (uuid.Equals(NS_GET_IID(nsIVariant)) || uuid.Equals(NS_GET_IID(nsISupports))) {
    1:     return nsContentUtils::XPConnect()->JSToVariant(mContext, mArgv[index],
    1:                                                     (nsIVariant **)result);
    1:   }
    1:   NS_WARNING("nsJSArgArray only handles nsIVariant");
    1:   return NS_ERROR_NO_INTERFACE;
    1: }
    1: 
    1: /* unsigned long indexOf (in unsigned long startIndex, in nsISupports element); */
    1: NS_IMETHODIMP nsJSArgArray::IndexOf(PRUint32 startIndex, nsISupports *element, PRUint32 *_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* nsISimpleEnumerator enumerate (); */
    1: NS_IMETHODIMP nsJSArgArray::Enumerate(nsISimpleEnumerator **_retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: // The factory function
    1: nsresult NS_CreateJSArgv(JSContext *aContext, PRUint32 argc, void *argv,
    1:                          nsIArray **aArray)
    1: {
    1:   nsresult rv;
    1:   nsJSArgArray *ret = new nsJSArgArray(aContext, argc,
 3233:                                        static_cast<jsval *>(argv), &rv);
    1:   if (ret == nsnull)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   if (NS_FAILED(rv)) {
    1:     delete ret;
    1:     return rv;
    1:   }
    1:   return ret->QueryInterface(NS_GET_IID(nsIArray), (void **)aArray);
    1: }
