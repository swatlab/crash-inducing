    1: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
32658:  * vim: set ts=8 sw=4 et tw=99:
    1:  *
98983:  * This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
    1: 
    1: #ifndef jsscope_h___
    1: #define jsscope_h___
    1: /*
    1:  * JS symbol tables.
    1:  */
52503: #include <new>
38562: #ifdef DEBUG
38562: #include <stdio.h>
38562: #endif
38562: 
87949: #include "jsobj.h"
87949: #include "jspropertytree.h"
    1: #include "jstypes.h"
69827: 
80202: #include "js/HashTable.h"
87949: #include "gc/Root.h"
86439: #include "mozilla/Attributes.h"
80202: 
33166: #ifdef _MSC_VER
33166: #pragma warning(push)
33166: #pragma warning(disable:4800)
39928: #pragma warning(push)
39928: #pragma warning(disable:4100) /* Silence unreferenced formal parameter warnings */
33166: #endif
33166: 
    1: /*
86523:  * In isolation, a Shape represents a property that exists in one or more
86523:  * objects; it has an id, flags, etc. (But it doesn't represent the property's
86523:  * value.)  However, Shapes are always stored in linked linear sequence of
86523:  * Shapes, called "shape lineages". Each shape lineage represents the layout of
86523:  * an entire object.
    1:  *
86523:  * Every JSObject has a pointer, |shape_|, accessible via lastProperty(), to
86523:  * the last Shape in a shape lineage, which identifies the property most
86523:  * recently added to the object.  This pointer permits fast object layout
86523:  * tests. The shape lineage order also dictates the enumeration order for the
86523:  * object; ECMA requires no particular order but this implementation has
86523:  * promised and delivered property definition order.
    1:  *
86523:  * Shape lineages occur in two kinds of data structure.
    1:  *
86523:  * 1. N-ary property trees. Each path from a non-root node to the root node in
86523:  *    a property tree is a shape lineage. Property trees permit full (or
86523:  *    partial) sharing of Shapes between objects that have fully (or partly)
86523:  *    identical layouts. The root is an EmptyShape whose identity is determined
86523:  *    by the object's class, compartment and prototype. These Shapes are shared
86523:  *    and immutable.
    1:  *
86523:  * 2. Dictionary mode lists. Shapes in such lists are said to be "in
86523:  *    dictionary mode", as are objects that point to such Shapes. These Shapes
86702:  *    are unshared, private to a single object, and immutable except for their
86702:  *    links in the dictionary list.
    1:  *
86523:  * All shape lineages are bi-directionally linked, via the |parent| and
86523:  * |kids|/|listp| members.
    1:  *
86523:  * Shape lineages start out life in the property tree. They can be converted
86523:  * (by copying) to dictionary mode lists in the following circumstances.
    1:  *
86523:  * 1. The shape lineage's size reaches MAX_HEIGHT. This reasonable limit avoids
86523:  *    potential worst cases involving shape lineage mutations.
    1:  *
86523:  * 2. A property represented by a non-last Shape in a shape lineage is removed
86523:  *    from an object. (In the last Shape case, obj->shape_ can be easily
86523:  *    adjusted to point to obj->shape_->parent.)  We originally tried lazy
86523:  *    forking of the property tree, but this blows up for delete/add
86523:  *    repetitions.
    1:  *
86523:  * 3. A property represented by a non-last Shape in a shape lineage has its
86523:  *    attributes modified.
    1:  *
86523:  * To find the Shape for a particular property of an object initially requires
86523:  * a linear search. But if the number of searches starting at any particular
86523:  * Shape in the property tree exceeds MAX_LINEAR_SEARCHES and the Shape's
86523:  * lineage has (excluding the EmptyShape) at least MIN_ENTRIES, we create an
97571:  * auxiliary hash table -- the ShapeTable -- that allows faster lookup.
97571:  * Furthermore, a ShapeTable is always created for dictionary mode lists,
97571:  * and it is attached to the last Shape in the lineage. Shape tables for
97571:  * property tree Shapes never change, but shape tables for dictionary mode
86523:  * Shapes can grow and shrink.
    1:  *
86523:  * There used to be a long, math-heavy comment here explaining why property
86523:  * trees are more space-efficient than alternatives.  This was removed in bug
86523:  * 631138; see that bug for the full details.
    1:  *
86523:  * Because many Shapes have similar data, there is actually a secondary type
86523:  * called a BaseShape that holds some of a Shape's data.  Many shapes can share
86523:  * a single BaseShape.
    1:  */
    1: 
83247: namespace js {
53546: 
83247: /* Limit on the number of slotful properties in an object. */
84755: static const uint32_t SHAPE_INVALID_SLOT = JS_BIT(24) - 1;
84755: static const uint32_t SHAPE_MAXIMUM_SLOT = JS_BIT(24) - 2;
35117: 
52503: /*
94610:  * Shapes use multiplicative hashing, but specialized to
80986:  * minimize footprint.
52503:  */
97571: struct ShapeTable {
94610:     static const uint32_t HASH_BITS     = tl::BitSize<HashNumber>::result;
84755:     static const uint32_t MIN_ENTRIES   = 7;
84755:     static const uint32_t MIN_SIZE_LOG2 = 4;
84755:     static const uint32_t MIN_SIZE      = JS_BIT(MIN_SIZE_LOG2);
35453: 
52503:     int             hashShift;          /* multiplicative hash shift */
30258: 
84755:     uint32_t        entryCount;         /* number of entries in table */
84755:     uint32_t        removedCount;       /* removed entry sentinels in table */
84755:     uint32_t        freelist;           /* SHAPE_INVALID_SLOT or head of slot
53546:                                            freelist in owning dictionary-mode
53546:                                            object */
52503:     js::Shape       **entries;          /* table of ptrs to shared tree nodes */
52503: 
97571:     ShapeTable(uint32_t nentries)
94610:       : hashShift(HASH_BITS - MIN_SIZE_LOG2),
52509:         entryCount(nentries),
53546:         removedCount(0),
53652:         freelist(SHAPE_INVALID_SLOT)
52503:     {
52503:         /* NB: entries is set by init, which must be called. */
52503:     }
52503: 
97571:     ~ShapeTable() {
64560:         js::UnwantedForeground::free_(entries);
52503:     }
52503: 
94610:     /* By definition, hashShift = HASH_BITS - log2(capacity). */
94610:     uint32_t capacity() const { return JS_BIT(HASH_BITS - hashShift); }
35453: 
74300:     /* Computes the size of the entries array for a given capacity. */
74300:     static size_t sizeOfEntries(size_t cap) { return cap * sizeof(Shape *); }
74300: 
78016:     /*
97571:      * This counts the ShapeTable object itself (which must be
78016:      * heap-allocated) and its |entries| array.
78016:      */
82849:     size_t sizeOfIncludingThis(JSMallocSizeOfFun mallocSizeOf) const {
88300:         return mallocSizeOf(this) + mallocSizeOf(entries);
74300:     }
74300: 
58067:     /* Whether we need to grow.  We want to do this if the load factor is >= 0.75 */
58067:     bool needsToGrow() const {
84755:         uint32_t size = capacity();
58067:         return entryCount + removedCount >= size - (size >> 2);
58067:     }
58067: 
58067:     /*
58067:      * Try to grow the table.  On failure, reports out of memory on cx
58067:      * and returns false.  This will make any extant pointers into the
58067:      * table invalid.  Don't call this unless needsToGrow() is true.
58067:      */
58067:     bool grow(JSContext *cx);
58067: 
35453:     /*
52503:      * NB: init and change are fallible but do not report OOM, so callers can
64560:      * cope or ignore. They do however use JSRuntime's calloc_ method in order
56587:      * to update the malloc counter on success.
35453:      */
59992:     bool            init(JSRuntime *rt, js::Shape *lastProp);
56587:     bool            change(int log2Delta, JSContext *cx);
52503:     js::Shape       **search(jsid id, bool adding);
30258: };
30258: 
52503: } /* namespace js */
30258: 
52503: struct JSObject;
40327: 
41860: namespace js {
41860: 
40327: class PropertyTree;
41860: 
59898: /*
59898:  * Reuse the API-only JSPROP_INDEX attribute to mean shadowability.
59898:  */
59898: #define JSPROP_SHADOWABLE       JSPROP_INDEX
59898: 
83221: /*
83221:  * Shapes encode information about both a property lineage *and* a particular
83221:  * property. This information is split across the Shape and the BaseShape
83221:  * at shape->base(). Both Shape and BaseShape can be either owned or unowned
83221:  * by, respectively, the Object or Shape referring to them.
83221:  *
83221:  * Owned Shapes are used in dictionary objects, and form a doubly linked list
83221:  * whose entries are all owned by that dictionary. Unowned Shapes are all in
83221:  * the property tree.
83221:  *
97571:  * Owned BaseShapes are used for shapes which have shape tables, including
83221:  * the last properties in all dictionaries. Unowned BaseShapes compactly store
83229:  * information common to many shapes. In a given compartment there is a single
83229:  * BaseShape for each combination of BaseShape information. This information
83229:  * is cloned in owned BaseShapes so that information can be quickly looked up
83229:  * for a given object or shape without regard to whether the base shape is
83229:  * owned or not.
83221:  *
83221:  * All combinations of owned/unowned Shapes/BaseShapes are possible:
83221:  *
83221:  * Owned Shape, Owned BaseShape:
83221:  *
83221:  *     Last property in a dictionary object. The BaseShape is transferred from
83221:  *     property to property as the object's last property changes.
83221:  *
83221:  * Owned Shape, Unowned BaseShape:
83221:  *
83221:  *     Property in a dictionary object other than the last one.
83221:  *
83221:  * Unowned Shape, Owned BaseShape:
83221:  *
97571:  *     Property in the property tree which has a shape table.
83221:  *
83221:  * Unowned Shape, Unowned BaseShape:
83221:  *
97571:  *     Property in the property tree which does not have a shape table.
83287:  *
83287:  * BaseShapes additionally encode some information about the referring object
83287:  * itself. This includes the object's class, parent and various flags that may
83287:  * be set for the object. Except for the class, this information is mutable and
83287:  * may change when the object has an established property lineage. On such
83287:  * changes the entire property lineage is not updated, but rather only the
83287:  * last property (and its base shape). This works because only the object's
83287:  * last property is used to query information about the object. Care must be
83287:  * taken to call JSObject::canRemoveLastProperty when unwinding an object to
83287:  * an earlier property, however.
83221:  */
83221: 
83229: class UnownedBaseShape;
83229: 
83229: class BaseShape : public js::gc::Cell
83221: {
83248:   public:
83277:     friend struct Shape;
86437:     friend struct StackBaseShape;
86437:     friend struct StackShape;
83229: 
83248:     enum Flag {
83221:         /* Owned by the referring shape. */
83221:         OWNED_SHAPE        = 0x1,
83221: 
83221:         /* getterObj/setterObj are active in unions below. */
83221:         HAS_GETTER_OBJECT  = 0x2,
83221:         HAS_SETTER_OBJECT  = 0x4,
83221: 
83221:         /*
83248:          * Flags set which describe the referring object. Once set these cannot
83248:          * be unset, and are transferred from shape to shape as the object's
83307:          * last property changes.
83248:          */
83248: 
83323:         EXTENSIBLE_PARENTS =    0x8,
83307:         DELEGATE           =   0x10,
83307:         SYSTEM             =   0x20,
83307:         NOT_EXTENSIBLE     =   0x40,
83307:         INDEXED            =   0x80,
83248:         BOUND_FUNCTION     =  0x100,
83248:         VAROBJ             =  0x200,
83248:         WATCHED            =  0x400,
83248:         ITERATED_SINGLETON =  0x800,
83286:         NEW_TYPE_UNKNOWN   = 0x1000,
83334:         UNCACHEABLE_PROTO  = 0x2000,
83248: 
83334:         OBJECT_FLAG_MASK   = 0x3ff8
83221:     };
83221: 
83248:   private:
83245:     Class               *clasp;         /* Class of referring object. */
83301:     HeapPtrObject       parent;         /* Parent of referring object. */
84755:     uint32_t            flags;          /* Vector of above flags. */
84755:     uint32_t            slotSpan_;      /* Object slot span for BaseShapes at
83221:                                          * dictionary last properties. */
83221: 
83221:     union {
83221:         js::PropertyOp  rawGetter;      /* getter hook for shape */
83221:         JSObject        *getterObj;     /* user-defined callable "get" object or
83221:                                            null if shape->hasGetterValue() */
83221:     };
83221: 
83221:     union {
83221:         js::StrictPropertyOp rawSetter; /* setter hook for shape */
83221:         JSObject        *setterObj;     /* user-defined callable "set" object or
83221:                                            null if shape->hasSetterValue() */
83221:     };
83221: 
83229:     /* For owned BaseShapes, the canonical unowned BaseShape. */
83301:     HeapPtr<UnownedBaseShape> unowned_;
83221: 
97571:     /* For owned BaseShapes, the shape's shape table. */
97571:     ShapeTable       *table_;
83221: 
98446:     BaseShape(const BaseShape &base) MOZ_DELETE;
98446: 
83221:   public:
94738:     void finalize(FreeOp *fop);
83221: 
84755:     inline BaseShape(Class *clasp, JSObject *parent, uint32_t objectFlags);
84755:     inline BaseShape(Class *clasp, JSObject *parent, uint32_t objectFlags,
84755:                      uint8_t attrs, PropertyOp rawGetter, StrictPropertyOp rawSetter);
86437:     inline BaseShape(const StackBaseShape &base);
86437: 
86437:     /* Not defined: BaseShapes must not be stack allocated. */
86437:     ~BaseShape();
83221: 
86890:     inline BaseShape &operator=(const BaseShape &other);
86890: 
83302:     bool isOwned() const { return !!(flags & OWNED_SHAPE); }
83221: 
83320:     inline bool matchesGetterSetter(PropertyOp rawGetter,
83320:                                     StrictPropertyOp rawSetter) const;
83320: 
83245:     inline void adoptUnowned(UnownedBaseShape *other);
83302:     inline void setOwned(UnownedBaseShape *unowned);
83221: 
86437:     JSObject *getObjectParent() const { return parent; }
86163:     uint32_t getObjectFlags() const { return flags & OBJECT_FLAG_MASK; }
83248: 
83229:     bool hasGetterObject() const { return !!(flags & HAS_GETTER_OBJECT); }
83229:     JSObject *getterObject() const { JS_ASSERT(hasGetterObject()); return getterObj; }
83229: 
83229:     bool hasSetterObject() const { return !!(flags & HAS_SETTER_OBJECT); }
83229:     JSObject *setterObject() const { JS_ASSERT(hasSetterObject()); return setterObj; }
83229: 
83229:     bool hasTable() const { JS_ASSERT_IF(table_, isOwned()); return table_ != NULL; }
97571:     ShapeTable &table() const { JS_ASSERT(table_ && isOwned()); return *table_; }
97571:     void setTable(ShapeTable *table) { JS_ASSERT(isOwned()); table_ = table; }
83221: 
84755:     uint32_t slotSpan() const { JS_ASSERT(isOwned()); return slotSpan_; }
84755:     void setSlotSpan(uint32_t slotSpan) { JS_ASSERT(isOwned()); slotSpan_ = slotSpan; }
83229: 
83221:     /* Lookup base shapes from the compartment's baseShapes table. */
86437:     static UnownedBaseShape *getUnowned(JSContext *cx, const StackBaseShape &base);
83245: 
83229:     /* Get the canonical base shape. */
83229:     inline UnownedBaseShape *unowned();
83229: 
83229:     /* Get the canonical base shape for an owned one. */
83229:     inline UnownedBaseShape *baseUnowned();
83229: 
83229:     /* Get the canonical base shape for an unowned one (i.e. identity). */
83229:     inline UnownedBaseShape *toUnowned();
83229: 
86163:     /* Check that an owned base shape is consistent with its unowned base. */
86163:     inline void assertConsistency();
86163: 
83229:     /* For JIT usage */
83229:     static inline size_t offsetOfClass() { return offsetof(BaseShape, clasp); }
83245:     static inline size_t offsetOfParent() { return offsetof(BaseShape, parent); }
83248:     static inline size_t offsetOfFlags() { return offsetof(BaseShape, flags); }
83229: 
83302:     static inline void writeBarrierPre(BaseShape *shape);
83302:     static inline void writeBarrierPost(BaseShape *shape, void *addr);
83302:     static inline void readBarrier(BaseShape *shape);
83301: 
86437:     static inline ThingRootKind rootKind() { return THING_ROOT_BASE_SHAPE; }
86437: 
91557:     inline void markChildren(JSTracer *trc);
91557: 
83226:   private:
83226:     static void staticAsserts() {
83226:         JS_STATIC_ASSERT(offsetof(BaseShape, clasp) == offsetof(js::shadow::BaseShape, clasp));
83226:     }
83221: };
83221: 
83229: class UnownedBaseShape : public BaseShape {};
83229: 
83229: UnownedBaseShape *
83229: BaseShape::unowned()
83229: {
83229:     return isOwned() ? baseUnowned() : toUnowned();
83229: }
83229: 
83229: UnownedBaseShape *
83229: BaseShape::toUnowned()
83229: {
83229:     JS_ASSERT(!isOwned() && !unowned_); return static_cast<UnownedBaseShape *>(this);
83229: }
83229: 
83229: UnownedBaseShape *
83229: BaseShape::baseUnowned()
83229: {
83229:     JS_ASSERT(isOwned() && unowned_); return unowned_;
83229: }
83229: 
83297: /* Entries for the per-compartment baseShapes set of unowned base shapes. */
86437: struct StackBaseShape
83297: {
86437:     typedef const StackBaseShape *Lookup;
83297: 
86437:     uint32_t flags;
86437:     Class *clasp;
86437:     JSObject *parent;
86437:     PropertyOp rawGetter;
86437:     StrictPropertyOp rawSetter;
86437: 
86437:     StackBaseShape(BaseShape *base)
86437:       : flags(base->flags & BaseShape::OBJECT_FLAG_MASK),
86437:         clasp(base->clasp),
86437:         parent(base->parent),
86437:         rawGetter(NULL),
86437:         rawSetter(NULL)
86437:     {}
86437: 
86437:     StackBaseShape(Class *clasp, JSObject *parent, uint32_t objectFlags)
86437:       : flags(objectFlags),
86437:         clasp(clasp),
86437:         parent(parent),
86437:         rawGetter(NULL),
86437:         rawSetter(NULL)
86437:     {}
86437: 
86437:     inline StackBaseShape(Shape *shape);
86437: 
86437:     inline void updateGetterSetter(uint8_t attrs,
86437:                                    PropertyOp rawGetter,
86437:                                    StrictPropertyOp rawSetter);
86437: 
86437:     static inline HashNumber hash(const StackBaseShape *lookup);
86437:     static inline bool match(UnownedBaseShape *key, const StackBaseShape *lookup);
99364: 
99364:     class AutoRooter : private AutoGCRooter
99364:     {
99364:       public:
99364:         explicit AutoRooter(JSContext *cx, const StackBaseShape *base_
99364:                             JS_GUARD_OBJECT_NOTIFIER_PARAM)
99364:           : AutoGCRooter(cx, STACKBASESHAPE), base(base_), skip(cx, base_)
99364:         {
99364:             JS_GUARD_OBJECT_NOTIFIER_INIT;
99364:         }
99364: 
99364:         friend void AutoGCRooter::trace(JSTracer *trc);
99364: 
99364:       private:
99364:         const StackBaseShape *base;
99364:         SkipRoot skip;
99364:         JS_DECL_USE_GUARD_OBJECT_NOTIFIER
99364:     };
83297: };
86437: 
86437: typedef HashSet<ReadBarriered<UnownedBaseShape>,
86437:                 StackBaseShape,
86437:                 SystemAllocPolicy> BaseShapeSet;
83297: 
68935: struct Shape : public js::gc::Cell
52503: {
52503:     friend struct ::JSObject;
52503:     friend struct ::JSFunction;
90970:     friend class js::Bindings;
90970:     friend class js::ObjectImpl;
90970:     friend class js::PropertyTree;
86483:     friend class js::StaticBlockObject;
86437:     friend struct js::StackShape;
86437:     friend struct js::StackBaseShape;
52503: 
83221:   protected:
83301:     HeapPtrBaseShape    base_;
83301:     HeapId              propid_;
78614: 
84755:     JS_ENUM_HEADER(SlotInfo, uint32_t)
83316:     {
83247:         /* Number of fixed slots in objects with this shape. */
83247:         FIXED_SLOTS_MAX        = 0x1f,
83247:         FIXED_SLOTS_SHIFT      = 27,
84755:         FIXED_SLOTS_MASK       = uint32_t(FIXED_SLOTS_MAX << FIXED_SLOTS_SHIFT),
68935: 
62399:         /*
83247:          * numLinearSearches starts at zero and is incremented initially on
83247:          * search() calls. Once numLinearSearches reaches LINEAR_SEARCHES_MAX,
83247:          * the table is created on the next search() call. The table can also
83247:          * be created when hashifying for dictionary mode.
62399:          */
83247:         LINEAR_SEARCHES_MAX    = 0x7,
83247:         LINEAR_SEARCHES_SHIFT  = 24,
83247:         LINEAR_SEARCHES_MASK   = LINEAR_SEARCHES_MAX << LINEAR_SEARCHES_SHIFT,
52503: 
83247:         /*
83247:          * Mask to get the index in object slots for shapes which hasSlot().
83247:          * For !hasSlot() shapes in the property tree with a parent, stores the
83247:          * parent's slot index (which may be invalid), and invalid for all
83247:          * other shapes.
83247:          */
83247:         SLOT_MASK              = JS_BIT(24) - 1
83316:     } JS_ENUM_FOOTER(SlotInfo);
52503: 
84755:     uint32_t            slotInfo;       /* mask of above info */
84755:     uint8_t             attrs;          /* attributes, see jsapi.h JSPROP_* */
84755:     uint8_t             flags;          /* flags, see below for defines */
84755:     int16_t             shortid_;       /* tinyid, or local arg/var index */
40331: 
83301:     HeapPtrShape        parent;        /* parent node, reverse for..in order */
78016:     /* kids is valid when !inDictionary(), listp is valid when inDictionary(). */
35453:     union {
83301:         KidsPointer kids;       /* null, single child, or a tagged ptr
    1:                                    to many-kids data structure */
86523:         HeapPtrShape *listp;    /* dictionary list starting at shape_
35453:                                    has a double-indirect back pointer,
86523:                                    either to the next shape's parent if not
86523:                                    last, else to obj->shape_ */
35453:     };
30258: 
86437:     static inline Shape *search(JSContext *cx, Shape *start, jsid id,
86437:                                 Shape ***pspp, bool adding = false);
52503: 
95355: #ifdef DEBUG
95355:     static inline Shape *searchNoAllocation(JSContext *cx, Shape *start, jsid id);
95355: #endif
95355: 
83221:     inline void removeFromDictionary(JSObject *obj);
83301:     inline void insertIntoDictionary(HeapPtrShape *dictp);
52503: 
86437:     inline void initDictionaryShape(const StackShape &child, uint32_t nfixed,
86437:                                     HeapPtrShape *dictp);
83221: 
86437:     Shape *getChildBinding(JSContext *cx, const StackShape &child);
78614: 
83287:     /* Replace the base shape of the last shape in a non-dictionary lineage with base. */
86437:     static Shape *replaceLastProperty(JSContext *cx, const StackBaseShape &base,
86437:                                       JSObject *proto, Shape *shape);
52503: 
78194:     bool hashify(JSContext *cx);
83229:     void handoffTableTo(Shape *newShape);
52503: 
83302:     inline void setParent(js::Shape *p);
82129: 
83221:     bool ensureOwnBaseShape(JSContext *cx) {
83221:         if (base()->isOwned())
83221:             return true;
83221:         return makeOwnBaseShape(cx);
53650:     }
53650: 
83221:     bool makeOwnBaseShape(JSContext *cx);
82468: 
82468:   public:
83229:     bool hasTable() const { return base()->hasTable(); }
97571:     js::ShapeTable &table() const { return base()->table(); }
82468: 
88144:     void sizeOfExcludingThis(JSMallocSizeOfFun mallocSizeOf,
88144:                              size_t *propTableSize, size_t *kidsSize) const {
88144:         *propTableSize = hasTable() ? table().sizeOfIncludingThis(mallocSizeOf) : 0;
88144:         *kidsSize = !inDictionary() && kids.isHash()
82849:                   ? kids.toHash()->sizeOfIncludingThis(mallocSizeOf)
78016:                   : 0;
78016:     }
78016: 
83221:     bool isNative() const {
83245:         JS_ASSERT(!(flags & NON_NATIVE) == getObjectClass()->isNative());
83221:         return !(flags & NON_NATIVE);
83221:     }
68935: 
84173:     const HeapPtrShape &previous() const {
52503:         return parent;
52503:     }
52503: 
52503:     class Range {
52503:       protected:
52503:         friend struct Shape;
52503:         const Shape *cursor;
52503: 
52503:       public:
52503:         Range(const Shape *shape) : cursor(shape) { }
52503: 
52503:         bool empty() const {
83221:             return cursor->isEmptyShape();
52503:         }
52503: 
52503:         const Shape &front() const {
52503:             JS_ASSERT(!empty());
52503:             return *cursor;
52503:         }
52503: 
52503:         void popFront() {
52503:             JS_ASSERT(!empty());
52503:             cursor = cursor->parent;
52503:         }
86437: 
99364:         class AutoRooter : private AutoGCRooter
99364:         {
86437:           public:
99364:             explicit AutoRooter(JSContext *cx, Range *r_
99364:                                 JS_GUARD_OBJECT_NOTIFIER_PARAM)
99364:               : AutoGCRooter(cx, SHAPERANGE), r(r_), skip(cx, r_)
99364:             {
99364:                 JS_GUARD_OBJECT_NOTIFIER_INIT;
99364:             }
99364: 
99364:             friend void AutoGCRooter::trace(JSTracer *trc);
99364:             void trace(JSTracer *trc);
99364: 
99364:           private:
99364:             Range *r;
99364:             SkipRoot skip;
99364:             JS_DECL_USE_GUARD_OBJECT_NOTIFIER
86437:         };
52503:     };
52503: 
52503:     Range all() const {
52503:         return Range(this);
52503:     }
52503: 
83245:     Class *getObjectClass() const { return base()->clasp; }
83245:     JSObject *getObjectParent() const { return base()->parent; }
83245: 
86437:     static Shape *setObjectParent(JSContext *cx, JSObject *obj, JSObject *proto, Shape *last);
86437:     static Shape *setObjectFlag(JSContext *cx, BaseShape::Flag flag, JSObject *proto, Shape *last);
83248: 
86163:     uint32_t getObjectFlags() const { return base()->getObjectFlags(); }
83248:     bool hasObjectFlag(BaseShape::Flag flag) const {
83248:         JS_ASSERT(!(flag & ~BaseShape::OBJECT_FLAG_MASK));
83248:         return !!(base()->flags & flag);
83248:     }
83221: 
52503:   protected:
40327:     /*
52503:      * Implementation-private bits stored in shape->flags. See public: enum {}
40327:      * flags further below, which were allocated FCFS over time, so interleave
40327:      * with these bits.
40327:      */
38562:     enum {
83221:         /* Property is placeholder for a non-native class. */
83221:         NON_NATIVE      = 0x01,
38562: 
38562:         /* Property stored in per-object dictionary, not shared property tree. */
64360:         IN_DICTIONARY   = 0x02,
52503: 
83221:         UNUSED_BITS     = 0x3C
38562:     };
38562: 
83245:     /* Get a shape identical to this one, without parent/kids information. */
86437:     Shape(const StackShape &other, uint32_t nfixed);
39894: 
52503:     /* Used by EmptyShape (see jsscopeinlines.h). */
84755:     Shape(UnownedBaseShape *base, uint32_t nfixed);
52503: 
83245:     /* Copy constructor disabled, to avoid misuse of the above form. */
86439:     Shape(const Shape &other) MOZ_DELETE;
86437: 
83229:     /*
83229:      * Whether this shape has a valid slot value. This may be true even if
83316:      * !hasSlot() (see SlotInfo comment above), and may be false even if
83316:      * hasSlot() if the shape is being constructed and has not had a slot
83316:      * assigned yet. After construction, hasSlot() implies !hasMissingSlot().
83229:      */
83247:     bool hasMissingSlot() const { return maybeSlot() == SHAPE_INVALID_SLOT; }
38562: 
38562:   public:
52503:     /* Public bits stored in shape->flags. */
38562:     enum {
52503:         HAS_SHORTID     = 0x40,
94227:         PUBLIC_FLAGS    = HAS_SHORTID
38562:     };
38562: 
80994:     bool inDictionary() const   { return (flags & IN_DICTIONARY) != 0; }
91237:     unsigned getFlags() const  { return flags & PUBLIC_FLAGS; }
38562:     bool hasShortID() const { return (flags & HAS_SHORTID) != 0; }
38562: 
83221:     PropertyOp getter() const { return base()->rawGetter; }
94227:     bool hasDefaultGetter() const  { return !base()->rawGetter; }
83221:     PropertyOp getterOp() const { JS_ASSERT(!hasGetterValue()); return base()->rawGetter; }
83221:     JSObject *getterObject() const { JS_ASSERT(hasGetterValue()); return base()->getterObj; }
41860: 
41860:     // Per ES5, decode null getterObj as the undefined value, which encodes as null.
78614:     Value getterValue() const {
40265:         JS_ASSERT(hasGetterValue());
83221:         return base()->getterObj ? js::ObjectValue(*base()->getterObj) : js::UndefinedValue();
32658:     }
32658: 
78614:     Value getterOrUndefined() const {
83221:         return (hasGetterValue() && base()->getterObj)
83221:                ? ObjectValue(*base()->getterObj)
83221:                : UndefinedValue();
48470:     }
48470: 
83221:     StrictPropertyOp setter() const { return base()->rawSetter; }
83221:     bool hasDefaultSetter() const  { return !base()->rawSetter; }
83221:     StrictPropertyOp setterOp() const { JS_ASSERT(!hasSetterValue()); return base()->rawSetter; }
83221:     JSObject *setterObject() const { JS_ASSERT(hasSetterValue()); return base()->setterObj; }
41860: 
41860:     // Per ES5, decode null setterObj as the undefined value, which encodes as null.
78614:     Value setterValue() const {
40265:         JS_ASSERT(hasSetterValue());
83221:         return base()->setterObj ? js::ObjectValue(*base()->setterObj) : js::UndefinedValue();
48470:     }
48470: 
78614:     Value setterOrUndefined() const {
83221:         return (hasSetterValue() && base()->setterObj)
83221:                ? ObjectValue(*base()->setterObj)
83221:                : UndefinedValue();
32658:     }
32658: 
84755:     void update(js::PropertyOp getter, js::StrictPropertyOp setter, uint8_t attrs);
82129: 
86437:     inline bool matches(const Shape *other) const;
86437:     inline bool matches(const StackShape &other) const;
83221:     inline bool matchesParamsAfterId(BaseShape *base,
91237:                                      uint32_t aslot, unsigned aattrs, unsigned aflags,
91237:                                      int ashortid) const;
38562: 
98960:     bool get(JSContext* cx, HandleObject receiver, JSObject *obj, JSObject *pobj, js::Value* vp) const;
98960:     bool set(JSContext* cx, HandleObject obj, bool strict, js::Value* vp) const;
32658: 
83221:     BaseShape *base() const { return base_; }
83221: 
40265:     bool hasSlot() const { return (attrs & JSPROP_SHARED) == 0; }
84755:     uint32_t slot() const { JS_ASSERT(hasSlot() && !hasMissingSlot()); return maybeSlot(); }
84755:     uint32_t maybeSlot() const { return slotInfo & SLOT_MASK; }
83221: 
83221:     bool isEmptyShape() const {
83221:         JS_ASSERT_IF(JSID_IS_EMPTY(propid_), hasMissingSlot());
83221:         return JSID_IS_EMPTY(propid_);
83221:     }
83221: 
84755:     uint32_t slotSpan() const {
83231:         JS_ASSERT(!inDictionary());
84755:         uint32_t free = JSSLOT_FREE(getObjectClass());
83231:         return hasMissingSlot() ? free : Max(free, maybeSlot() + 1);
83231:     }
83231: 
84755:     void setSlot(uint32_t slot) {
83247:         JS_ASSERT(slot <= SHAPE_INVALID_SLOT);
86437:         slotInfo = slotInfo & ~Shape::SLOT_MASK;
83247:         slotInfo = slotInfo | slot;
83247:     }
83247: 
84755:     uint32_t numFixedSlots() const {
83247:         return (slotInfo >> FIXED_SLOTS_SHIFT);
83247:     }
83247: 
84755:     void setNumFixedSlots(uint32_t nfixed) {
83247:         JS_ASSERT(nfixed < FIXED_SLOTS_MAX);
83247:         slotInfo = slotInfo & ~FIXED_SLOTS_MASK;
83247:         slotInfo = slotInfo | (nfixed << FIXED_SLOTS_SHIFT);
83247:     }
83247: 
84755:     uint32_t numLinearSearches() const {
83247:         return (slotInfo & LINEAR_SEARCHES_MASK) >> LINEAR_SEARCHES_SHIFT;
83247:     }
83247: 
83247:     void incrementNumLinearSearches() {
84755:         uint32_t count = numLinearSearches();
83247:         JS_ASSERT(count < LINEAR_SEARCHES_MAX);
83247:         slotInfo = slotInfo & ~LINEAR_SEARCHES_MASK;
83247:         slotInfo = slotInfo | ((count + 1) << LINEAR_SEARCHES_SHIFT);
83247:     }
83247: 
90419:     const HeapId &propid() const {
90419:         JS_ASSERT(!isEmptyShape());
90419:         JS_ASSERT(!JSID_IS_VOID(propid_));
90419:         return propid_;
90419:     }
90419:     HeapId &propidRef() { JS_ASSERT(!JSID_IS_VOID(propid_)); return propid_; }
83221: 
84755:     int16_t shortid() const { JS_ASSERT(hasShortID()); return maybeShortid(); }
84755:     int16_t maybeShortid() const { return shortid_; }
83221: 
83221:     /*
83221:      * If SHORTID is set in shape->flags, we use shape->shortid rather
83221:      * than id when calling shape's getter or setter.
83221:      */
97828:     inline bool getUserId(JSContext *cx, jsid *idp) const;
36991: 
84755:     uint8_t attributes() const { return attrs; }
40265:     bool configurable() const { return (attrs & JSPROP_PERMANENT) == 0; }
40265:     bool enumerable() const { return (attrs & JSPROP_ENUMERATE) != 0; }
40265:     bool writable() const {
40265:         // JS_ASSERT(isDataDescriptor());
40265:         return (attrs & JSPROP_READONLY) == 0;
40265:     }
40265:     bool hasGetterValue() const { return attrs & JSPROP_GETTER; }
40265:     bool hasSetterValue() const { return attrs & JSPROP_SETTER; }
40265: 
40265:     bool isDataDescriptor() const {
36991:         return (attrs & (JSPROP_SETTER | JSPROP_GETTER)) == 0;
36991:     }
40265:     bool isAccessorDescriptor() const {
36991:         return (attrs & (JSPROP_SETTER | JSPROP_GETTER)) != 0;
36991:     }
38562: 
59898:     /*
78614:      * For ES5 compatibility, we allow properties with PropertyOp-flavored
59898:      * setters to be shadowed when set. The "own" property thereby created in
59898:      * the directly referenced object will have the same getter and setter as
59898:      * the prototype property. See bug 552432.
59898:      */
59898:     bool shadowable() const {
59898:         JS_ASSERT_IF(isDataDescriptor(), writable());
59898:         return hasSlot() || (attrs & JSPROP_SHADOWABLE);
59898:     }
59898: 
83221:     /*
83221:      * Sometimes call objects and run-time block objects need unique shapes, but
83221:      * sometimes they don't.
83221:      *
83221:      * Property cache entries only record the shapes of the first and last
83221:      * objects along the search path, so if the search traverses more than those
83221:      * two objects, then those first and last shapes must determine the shapes
83221:      * of everything else along the path. The js_PurgeScopeChain stuff takes
83221:      * care of making this work, but that suffices only because we require that
83221:      * start points with the same shape have the same successor object in the
83221:      * search path --- a cache hit means the starting shapes were equal, which
94943:      * means the search path tail (everything but the first object in the path)
83221:      * was shared, which in turn means the effects of a purge will be seen by
83221:      * all affected starting search points.
83221:      *
83221:      * For call and run-time block objects, the "successor object" is the scope
83221:      * chain parent. Unlike prototype objects (of which there are usually few),
83221:      * scope chain parents are created frequently (possibly on every call), so
83221:      * following the shape-implies-parent rule blindly would lead one to give
83221:      * every call and block its own shape.
83221:      *
83221:      * In many cases, however, it's not actually necessary to give call and
83221:      * block objects their own shapes, and we can do better. If the code will
83221:      * always be used with the same global object, and none of the enclosing
83221:      * call objects could have bindings added to them at runtime (by direct eval
83221:      * calls or function statements), then we can use a fixed set of shapes for
83221:      * those objects. You could think of the shapes in the functions' bindings
83221:      * and compile-time blocks as uniquely identifying the global object(s) at
83221:      * the end of the scope chain.
83221:      *
83221:      * (In fact, some JSScripts we do use against multiple global objects (see
83221:      * bug 618497), and using the fixed shapes isn't sound there.)
83221:      *
83221:      * In deciding whether a call or block has any extensible parents, we
83221:      * actually only need to consider enclosing calls; blocks are never
83221:      * extensible, and the other sorts of objects that appear in the scope
83221:      * chains ('with' blocks, say) are not CacheableNonGlobalScopes.
83221:      *
83221:      * If the hasExtensibleParents flag is set for the last property in a
83221:      * script's bindings or a compiler-generated Block object, then created
83221:      * Call or Block objects need unique shapes. If the flag is clear, then we
83221:      * can use lastBinding's shape.
83221:      */
86437:     static Shape *setExtensibleParents(JSContext *cx, Shape *shape);
83221:     bool extensibleParents() const { return !!(base()->flags & BaseShape::EXTENSIBLE_PARENTS); }
83221: 
84755:     uint32_t entryCount() const {
62399:         if (hasTable())
83229:             return table().entryCount;
52503: 
52503:         const js::Shape *shape = this;
84755:         uint32_t count = 0;
52503:         for (js::Shape::Range r = shape->all(); !r.empty(); r.popFront())
52503:             ++count;
52503:         return count;
52503:     }
52503: 
97571:     bool isBigEnoughForAShapeTable() const {
80986:         JS_ASSERT(!hasTable());
80986:         const js::Shape *shape = this;
84755:         uint32_t count = 0;
80986:         for (js::Shape::Range r = shape->all(); !r.empty(); r.popFront()) {
80986:             ++count;
97571:             if (count >= ShapeTable::MIN_ENTRIES)
80986:                 return true;
80986:         }
80986:         return false;
80986:     }
80986: 
38562: #ifdef DEBUG
52503:     void dump(JSContext *cx, FILE *fp) const;
52503:     void dumpSubtree(JSContext *cx, int level, FILE *fp) const;
38562: #endif
64360: 
94738:     void finalize(FreeOp *fop);
64360:     void removeChild(js::Shape *child);
82129: 
83302:     static inline void writeBarrierPre(const Shape *shape);
83302:     static inline void writeBarrierPost(const Shape *shape, void *addr);
82129: 
82129:     /*
82129:      * All weak references need a read barrier for incremental GC. This getter
82129:      * method implements the read barrier. It's used to obtain initial shapes
82129:      * from the compartment.
82129:      */
83302:     static inline void readBarrier(const Shape *shape);
83301: 
86437:     static inline ThingRootKind rootKind() { return THING_ROOT_SHAPE; }
86437: 
91557:     inline void markChildren(JSTracer *trc);
91557: 
83222:     /* For JIT usage */
83222:     static inline size_t offsetOfBase() { return offsetof(Shape, base_); }
83226: 
83226:   private:
83226:     static void staticAsserts() {
83226:         JS_STATIC_ASSERT(offsetof(Shape, base_) == offsetof(js::shadow::Shape, base));
83247:         JS_STATIC_ASSERT(offsetof(Shape, slotInfo) == offsetof(js::shadow::Shape, slotInfo));
83247:         JS_STATIC_ASSERT(FIXED_SLOTS_SHIFT == js::shadow::Shape::FIXED_SLOTS_SHIFT);
83226:     }
    1: };
    1: 
99364: class AutoRooterGetterSetter
97353: {
99364:     class Inner : private AutoGCRooter
99364:     {
99364:       public:
99364:         Inner(JSContext *cx, uint8_t attrs,
99364:               PropertyOp *pgetter_, StrictPropertyOp *psetter_)
99364:             : AutoGCRooter(cx, GETTERSETTER), attrs(attrs),
99364:               pgetter(pgetter_), psetter(psetter_),
99364:               getterRoot(cx, pgetter_), setterRoot(cx, psetter_)
99364:         {}
99364: 
99364:         friend void AutoGCRooter::trace(JSTracer *trc);
99364: 
99364:       private:
99364:         uint8_t attrs;
99364:         PropertyOp *pgetter;
99364:         StrictPropertyOp *psetter;
99364:         SkipRoot getterRoot, setterRoot;
99364:     };
97353: 
97353:   public:
99364:     explicit AutoRooterGetterSetter(JSContext *cx, uint8_t attrs,
99364:                                     PropertyOp *pgetter, StrictPropertyOp *psetter
99364:                                     JS_GUARD_OBJECT_NOTIFIER_PARAM)
97353:     {
99364:         if (attrs & (JSPROP_GETTER | JSPROP_SETTER))
99364:             inner.construct(cx, attrs, pgetter, psetter);
99364:         JS_GUARD_OBJECT_NOTIFIER_INIT;
97353:     }
99364: 
99364:     friend void AutoGCRooter::trace(JSTracer *trc);
99364: 
99364:   private:
99364:     Maybe<Inner> inner;
99364:     JS_DECL_USE_GUARD_OBJECT_NOTIFIER
97353: };
97353: 
52503: struct EmptyShape : public js::Shape
52503: {
84755:     EmptyShape(UnownedBaseShape *base, uint32_t nfixed);
    1: 
83297:     /*
83297:      * Lookup an initial shape matching the given parameters, creating an empty
83297:      * shape if none was found.
83297:      */
83316:     static Shape *getInitialShape(JSContext *cx, Class *clasp, JSObject *proto,
84755:                                   JSObject *parent, gc::AllocKind kind, uint32_t objectFlags = 0);
    1: 
83316:     /*
83316:      * Reinsert an alternate initial shape, to be returned by future
83316:      * getInitialShape calls, until the new shape becomes unreachable in a GC
83316:      * and the table entry is purged.
83316:      */
83297:     static void insertInitialShape(JSContext *cx, Shape *shape, JSObject *proto);
83247: };
64242: 
83297: /*
83297:  * Entries for the per-compartment initialShapes set indexing initial shapes
83297:  * for objects in the compartment and the associated types.
83297:  */
83297: struct InitialShapeEntry
83247: {
83297:     /*
83297:      * Initial shape to give to the object. This is an empty shape, except for
83297:      * certain classes (e.g. String, RegExp) which may add certain baked-in
83297:      * properties.
83297:      */
86321:     ReadBarriered<Shape> shape;
64242: 
83297:     /*
83297:      * Matching prototype for the entry. The shape of an object determines its
83297:      * prototype, but the prototype cannot be determined from the shape itself.
83297:      */
83297:     JSObject *proto;
83247: 
83297:     /* State used to determine a match on an initial shape. */
83297:     struct Lookup {
83297:         Class *clasp;
83297:         JSObject *proto;
83297:         JSObject *parent;
84755:         uint32_t nfixed;
84755:         uint32_t baseFlags;
84755:         Lookup(Class *clasp, JSObject *proto, JSObject *parent, uint32_t nfixed,
84755:                uint32_t baseFlags)
83308:             : clasp(clasp), proto(proto), parent(parent),
83308:               nfixed(nfixed), baseFlags(baseFlags)
83297:         {}
52503:     };
    1: 
99246:     inline InitialShapeEntry();
99246:     inline InitialShapeEntry(const ReadBarriered<Shape> &shape, JSObject *proto);
99246: 
99246:     inline Lookup getLookup();
99246: 
83297:     static inline HashNumber hash(const Lookup &lookup);
83297:     static inline bool match(const InitialShapeEntry &key, const Lookup &lookup);
81003: };
86437: 
83297: typedef HashSet<InitialShapeEntry, InitialShapeEntry, SystemAllocPolicy> InitialShapeSet;
81003: 
86437: struct StackShape
86437: {
86437:     UnownedBaseShape *base;
86437:     jsid             propid;
86437:     uint32_t         slot_;
86437:     uint8_t          attrs;
86437:     uint8_t          flags;
86437:     int16_t          shortid;
86437: 
86437:     StackShape(UnownedBaseShape *base, jsid propid, uint32_t slot,
91237:                uint32_t nfixed, unsigned attrs, unsigned flags, int shortid)
86437:       : base(base),
86437:         propid(propid),
86437:         slot_(slot),
86437:         attrs(uint8_t(attrs)),
86437:         flags(uint8_t(flags)),
86437:         shortid(int16_t(shortid))
86437:     {
86437:         JS_ASSERT(base);
86437:         JS_ASSERT(!JSID_IS_VOID(propid));
86437:         JS_ASSERT(slot <= SHAPE_INVALID_SLOT);
86437:     }
86437: 
86437:     StackShape(const Shape *shape)
86437:       : base(shape->base()->unowned()),
90419:         propid(const_cast<Shape *>(shape)->propidRef()),
86437:         slot_(shape->slotInfo & Shape::SLOT_MASK),
86437:         attrs(shape->attrs),
86437:         flags(shape->flags),
86437:         shortid(shape->shortid_)
86437:     {}
86437: 
86437:     bool hasSlot() const { return (attrs & JSPROP_SHARED) == 0; }
86437:     bool hasMissingSlot() const { return maybeSlot() == SHAPE_INVALID_SLOT; }
86437: 
86437:     uint32_t slot() const { JS_ASSERT(hasSlot() && !hasMissingSlot()); return slot_; }
86437:     uint32_t maybeSlot() const { return slot_; }
86437: 
86437:     uint32_t slotSpan() const {
86437:         uint32_t free = JSSLOT_FREE(base->clasp);
86437:         return hasMissingSlot() ? free : (maybeSlot() + 1);
86437:     }
86437: 
86437:     void setSlot(uint32_t slot) {
86437:         JS_ASSERT(slot <= SHAPE_INVALID_SLOT);
86437:         slot_ = slot;
86437:     }
86437: 
94610:     inline HashNumber hash() const;
99364: 
99364:     class AutoRooter : private AutoGCRooter
99364:     {
99364:       public:
99364:         explicit AutoRooter(JSContext *cx, const StackShape *shape_
99364:                             JS_GUARD_OBJECT_NOTIFIER_PARAM)
99364:           : AutoGCRooter(cx, STACKSHAPE), shape(shape_), skip(cx, shape_)
99364:         {
99364:             JS_GUARD_OBJECT_NOTIFIER_INIT;
99364:         }
99364: 
99364:         friend void AutoGCRooter::trace(JSTracer *trc);
99364: 
99364:       private:
99364:         const StackShape *shape;
99364:         SkipRoot skip;
99364:         JS_DECL_USE_GUARD_OBJECT_NOTIFIER
86437:     };
86437:  };
86437: 
52503: } /* namespace js */
    1: 
52503: /* js::Shape pointer tag bit indicating a collision. */
86976: #define SHAPE_COLLISION                 (uintptr_t(1))
52503: #define SHAPE_REMOVED                   ((js::Shape *) SHAPE_COLLISION)
52503: 
52503: /* Macros to get and set shape pointer values and collision flags. */
52503: #define SHAPE_IS_FREE(shape)            ((shape) == NULL)
52503: #define SHAPE_IS_REMOVED(shape)         ((shape) == SHAPE_REMOVED)
52503: #define SHAPE_IS_LIVE(shape)            ((shape) > SHAPE_REMOVED)
52503: #define SHAPE_FLAG_COLLISION(spp,shape) (*(spp) = (js::Shape *)               \
86976:                                          (uintptr_t(shape) | SHAPE_COLLISION))
86976: #define SHAPE_HAD_COLLISION(shape)      (uintptr_t(shape) & SHAPE_COLLISION)
52503: #define SHAPE_FETCH(spp)                SHAPE_CLEAR_COLLISION(*(spp))
52503: 
52503: #define SHAPE_CLEAR_COLLISION(shape)                                          \
86976:     ((js::Shape *) (uintptr_t(shape) & ~SHAPE_COLLISION))
52503: 
52503: #define SHAPE_STORE_PRESERVING_COLLISION(spp, shape)                          \
86976:     (*(spp) = (js::Shape *) (uintptr_t(shape) | SHAPE_HAD_COLLISION(*(spp))))
52503: 
52503: namespace js {
52503: 
86437: inline Shape *
86437: Shape::search(JSContext *cx, Shape *start, jsid id, Shape ***pspp, bool adding)
30281: {
86437:     if (start->inDictionary()) {
86437:         *pspp = start->table().search(id, adding);
86437:         return SHAPE_FETCH(*pspp);
86437:     }
86437: 
86437:     *pspp = NULL;
86437: 
86437:     if (start->hasTable()) {
86437:         Shape **spp = start->table().search(id, adding);
86437:         return SHAPE_FETCH(spp);
86437:     }
62399: 
83247:     if (start->numLinearSearches() == LINEAR_SEARCHES_MAX) {
97571:         if (start->isBigEnoughForAShapeTable()) {
99421:             RootedShape startRoot(cx, start);
99421:             RootedId idRoot(cx, id);
86437:             if (start->hashify(cx)) {
86437:                 Shape **spp = start->table().search(id, adding);
86437:                 return SHAPE_FETCH(spp);
86437:             }
99364:             start = startRoot;
99364:             id = idRoot;
86437:         }
80986:         /*
80986:          * No table built -- there weren't enough entries, or OOM occurred.
80986:          * Don't increment numLinearSearches, to keep hasTable() false.
80986:          */
62399:         JS_ASSERT(!start->hasTable());
62399:     } else {
83247:         start->incrementNumLinearSearches();
59992:     }
59992: 
86437:     for (Shape *shape = start; shape; shape = shape->parent) {
90419:         if (shape->propidRef() == id)
86437:             return shape;
30281:     }
86437: 
86437:     return NULL;
30281: }
30281: 
95355: #ifdef DEBUG
95355: /* static */ inline Shape *
95355: Shape::searchNoAllocation(JSContext *cx, Shape *start, jsid id)
95355: {
95355:     if (start->hasTable()) {
95355:         Shape **spp = start->table().search(id, false);
95355:         return SHAPE_FETCH(spp);
95355:     }
95355: 
95355:     for (Shape *shape = start; shape; shape = shape->parent) {
95355:         if (shape->propidRef() == id)
95355:             return shape;
95355:     }
95355: 
95355:     return NULL;
95355: }
95355: #endif /* DEBUG */
95355: 
59968: } // namespace js
50491: 
33166: #ifdef _MSC_VER
33166: #pragma warning(pop)
39928: #pragma warning(pop)
33166: #endif
33166: 
83276: namespace JS {
83276:     template<> class AnchorPermitted<js::Shape *> { };
83276:     template<> class AnchorPermitted<const js::Shape *> { };
83276: }
83276: 
    1: #endif /* jsscope_h___ */
