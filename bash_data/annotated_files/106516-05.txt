 62125: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 62125: 
 62125: #include "TextUpdater.h"
 62125: 
 95352: #include "Accessible-inl.h"
106516: #include "DocAccessible.h"
 99295: #include "TextLeafAccessible.h"
 99295: 
 99295: using namespace mozilla::a11y;
 62125: 
 62125: void
 99568: TextUpdater::Run(DocAccessible* aDocument, TextLeafAccessible* aTextLeaf,
 62125:                  const nsAString& aNewText)
 62125: {
 62125:   NS_ASSERTION(aTextLeaf, "No text leaf accessible?");
 62125: 
 62125:   const nsString& oldText = aTextLeaf->Text();
 62125:   PRUint32 oldLen = oldText.Length(), newLen = aNewText.Length();
 62125:   PRUint32 minLen = NS_MIN(oldLen, newLen);
 62125: 
 62125:   // Skip coinciding begin substrings.
 62125:   PRUint32 skipStart = 0;
 62125:   for (; skipStart < minLen; skipStart++) {
 62125:     if (aNewText[skipStart] != oldText[skipStart])
 62125:       break;
 62125:   }
 62125: 
 62125:   // The text was changed. Do update.
 62125:   if (skipStart != minLen || oldLen != newLen) {
 62125:     TextUpdater updater(aDocument, aTextLeaf);
 62125:     updater.DoUpdate(aNewText, oldText, skipStart);
 62125:   }
 62125: }
 62125: 
 62125: void
 62125: TextUpdater::DoUpdate(const nsAString& aNewText, const nsAString& aOldText,
 62125:                       PRUint32 aSkipStart)
 62125: {
 99648:   Accessible* parent = mTextLeaf->Parent();
 74545:   if (!parent)
 64003:     return;
 62125: 
 62125:   mHyperText = parent->AsHyperText();
 62125:   if (!mHyperText) {
 62125:     NS_ERROR("Text leaf parent is not hypertext!");
 62125:     return;
 62125:   }
 62125: 
 62125:   // Get the text leaf accessible offset and invalidate cached offsets after it.
 80486:   mTextOffset = mHyperText->GetChildOffset(mTextLeaf, true);
 62125:   NS_ASSERTION(mTextOffset != -1,
 62125:                "Text leaf hasn't offset within hyper text!");
 62125: 
 62125:   PRUint32 oldLen = aOldText.Length(), newLen = aNewText.Length();
 62125:   PRUint32 minLen = NS_MIN(oldLen, newLen);
 62125: 
 62125:   // Trim coinciding substrings from the end.
 62125:   PRUint32 skipEnd = 0;
 62125:   while (minLen - skipEnd > aSkipStart &&
 62125:          aNewText[newLen - skipEnd - 1] == aOldText[oldLen - skipEnd - 1]) {
 62125:     skipEnd++;
 62125:   }
 62125: 
 90431:   PRUint32 strLen1 = oldLen - aSkipStart - skipEnd;
 90431:   PRUint32 strLen2 = newLen - aSkipStart - skipEnd;
 62125: 
 62125:   const nsAString& str1 = Substring(aOldText, aSkipStart, strLen1);
 62125:   const nsAString& str2 = Substring(aNewText, aSkipStart, strLen2);
 62125: 
 62125:   // Increase offset of the text leaf on skipped characters amount.
 62125:   mTextOffset += aSkipStart;
 62125: 
 74839:   // It could be single insertion or removal or the case of long strings. Do not
 74839:   // calculate the difference between long strings and prefer to fire pair of
 74839:   // insert/remove events as the old string was replaced on the new one.
 74839:   if (strLen1 == 0 || strLen2 == 0 ||
 74839:       strLen1 > kMaxStrLen || strLen2 > kMaxStrLen) {
 74839:     if (strLen1 > 0) {
 74839:       // Fire text change event for removal.
 74839:       nsRefPtr<AccEvent> textRemoveEvent =
 80486:         new AccTextChangeEvent(mHyperText, mTextOffset, str1, false);
 74839:       mDocument->FireDelayedAccessibleEvent(textRemoveEvent);
 74839:     }
 74839: 
 74839:     if (strLen2 > 0) {
 74839:       // Fire text change event for insertion.
 74839:       nsRefPtr<AccEvent> textInsertEvent =
 80486:         new AccTextChangeEvent(mHyperText, mTextOffset, str2, true);
 74839:       mDocument->FireDelayedAccessibleEvent(textInsertEvent);
 74839:     }
 74839: 
 83075:     mDocument->MaybeNotifyOfValueChange(mHyperText);
 74839: 
 74839:     // Update the text.
 74839:     mTextLeaf->SetText(aNewText);
 74839:     return;
 74839:   }
 74839: 
 74839:   // Otherwise find the difference between strings and fire events.
 74839:   // Note: we can skip initial and final coinciding characters since they don't
 74839:   // affect the Levenshtein distance.
 74839: 
 62125:   // Compute the flat structured matrix need to compute the difference.
 62125:   PRUint32 len1 = strLen1 + 1, len2 = strLen2 + 1;
 62125:   PRUint32* entries = new PRUint32[len1 * len2];
 62125: 
 62125:   for (PRUint32 colIdx = 0; colIdx < len1; colIdx++)
 62125:     entries[colIdx] = colIdx;
 62125: 
 62125:   PRUint32* row = entries;
 62125:   for (PRUint32 rowIdx = 1; rowIdx < len2; rowIdx++) {
 62125:     PRUint32* prevRow = row;
 62125:     row += len1;
 62125:     row[0] = rowIdx;
 62125:     for (PRUint32 colIdx = 1; colIdx < len1; colIdx++) {
 62125:       if (str1[colIdx - 1] != str2[rowIdx - 1]) {
 62125:         PRUint32 left = row[colIdx - 1];
 62125:         PRUint32 up = prevRow[colIdx];
 62125:         PRUint32 upleft = prevRow[colIdx - 1];
 62125:         row[colIdx] = NS_MIN(upleft, NS_MIN(left, up)) + 1;
 62125:       } else {
 62125:         row[colIdx] = prevRow[colIdx - 1];
 62125:       }
 62125:     }
 62125:   }
 62125: 
 62125:   // Compute events based on the difference.
 62125:   nsTArray<nsRefPtr<AccEvent> > events;
 62125:   ComputeTextChangeEvents(str1, str2, entries, events);
 62125: 
 62125:   delete [] entries;
 62125: 
 62125:   // Fire events.
 62125:   for (PRInt32 idx = events.Length() - 1; idx >= 0; idx--)
 62125:     mDocument->FireDelayedAccessibleEvent(events[idx]);
 62125: 
 83075:   mDocument->MaybeNotifyOfValueChange(mHyperText);
 62125: 
 62125:   // Update the text.
 62125:   mTextLeaf->SetText(aNewText);
 62125: }
 62125: 
 62125: void
 62125: TextUpdater::ComputeTextChangeEvents(const nsAString& aStr1,
 62125:                                      const nsAString& aStr2,
 62125:                                      PRUint32* aEntries,
 62125:                                      nsTArray<nsRefPtr<AccEvent> >& aEvents)
 62125: {
 62125:   PRInt32 colIdx = aStr1.Length(), rowIdx = aStr2.Length();
 62125: 
 62125:   // Point at which strings last matched.
 62125:   PRInt32 colEnd = colIdx;
 62125:   PRInt32 rowEnd = rowIdx;
 62125: 
 62125:   PRInt32 colLen = colEnd + 1;
 62125:   PRUint32* row = aEntries + rowIdx * colLen;
 90431:   PRUint32 dist = row[colIdx]; // current Levenshtein distance
 62125:   while (rowIdx && colIdx) { // stop when we can't move diagonally
 62125:     if (aStr1[colIdx - 1] == aStr2[rowIdx - 1]) { // match
 62125:       if (rowIdx < rowEnd) { // deal with any pending insertion
 62125:         FireInsertEvent(Substring(aStr2, rowIdx, rowEnd - rowIdx),
 62125:                         rowIdx, aEvents);
 62125:       }
 62125:       if (colIdx < colEnd) { // deal with any pending deletion
 62125:         FireDeleteEvent(Substring(aStr1, colIdx, colEnd - colIdx),
 62125:                         rowIdx, aEvents);
 62125:       }
 62125: 
 62125:       colEnd = --colIdx; // reset the match point
 62125:       rowEnd = --rowIdx;
 62125:       row -= colLen;
 62125:       continue;
 62125:     }
 62125:     --dist;
 62125:     if (dist == row[colIdx - 1 - colLen]) { // substitution
 62125:       --colIdx;
 62125:       --rowIdx;
 62125:       row -= colLen;
 62125:       continue;
 62125:     }
 62125:     if (dist == row[colIdx - colLen]) { // insertion
 62125:       --rowIdx;
 62125:       row -= colLen;
 62125:       continue;
 62125:     }
 62125:     if (dist == row[colIdx - 1]) { // deletion
 62125:       --colIdx;
 62125:       continue;
 62125:     }
 62125:     NS_NOTREACHED("huh?");
 62125:     return;
 62125:   }
 62125: 
 62125:   if (rowEnd)
 62125:     FireInsertEvent(Substring(aStr2, 0, rowEnd), 0, aEvents);
 62125:   if (colEnd)
 62125:     FireDeleteEvent(Substring(aStr1, 0, colEnd), 0, aEvents);
 62125: }
