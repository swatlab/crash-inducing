58092: /* -*- Mode: C++; c-basic-offset: 2; indent-tabs-mode: nil; tab-width: 8 -*- */
58092: /* vim: set sw=4 ts=8 et tw=80 ft=cpp : */
98983: /* This Source Code Form is subject to the terms of the Mozilla Public
98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
58092: 
58092: #include "StorageChild.h"
58092: #include "mozilla/dom/ContentChild.h"
58092: #include "nsDOMError.h"
58092: 
58092: namespace mozilla {
58092: namespace dom {
58092: 
58092: NS_IMPL_CYCLE_COLLECTION_1(StorageChild, mStorage)
58092: 
58092: NS_IMPL_CYCLE_COLLECTING_ADDREF(StorageChild)
58092: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(StorageChild)
99466:   NS_INTERFACE_MAP_ENTRY(nsISupports)
58092: NS_INTERFACE_MAP_END
58092: 
58092: NS_IMETHODIMP_(nsrefcnt) StorageChild::Release(void)
58092: {
58092:   NS_PRECONDITION(0 != mRefCnt, "dup release");
58092:   NS_ASSERT_OWNINGTHREAD(StorageChild);
58092:   nsISupports* base = NS_CYCLE_COLLECTION_CLASSNAME(StorageChild)::Upcast(this);
58092:   nsrefcnt count = mRefCnt.decr(base);
58092:   NS_LOG_RELEASE(this, count, "StorageChild");
58092:   if (count == 1 && mIPCOpen) {
58092:     Send__delete__(this);
58092:     return 0;
58092:   }
58092:   if (count == 0) {
58092:     mRefCnt.stabilizeForDeletion(base);
58092:     delete this;
58092:     return 0;
58092:   }
58092:   return count;
58092: }
58092: 
58092: StorageChild::StorageChild(nsDOMStorage* aOwner)
58092: : mStorage(aOwner)
58092: , mIPCOpen(false)
58092: {
58092: }
58092: 
58092: StorageChild::StorageChild(nsDOMStorage* aOwner, StorageChild& aOther)
58092: : DOMStorageBase(aOther)
58092: , mStorage(aOwner)
58092: , mIPCOpen(false)
58092: {
58092: }
58092: 
58092: void
58092: StorageChild::AddIPDLReference()
58092: {
58092:   NS_ABORT_IF_FALSE(!mIPCOpen, "Attempting to retain multiple IPDL references");
58092:   mIPCOpen = true;
58092:   AddRef();
58092: }
58092: 
58092: void
58092: StorageChild::ReleaseIPDLReference()
58092: {
58092:   NS_ABORT_IF_FALSE(mIPCOpen, "Attempting to release non-existent IPDL reference");
58092:   mIPCOpen = false;
58092:   Release();
58092: }
58092: 
58092: bool
58092: StorageChild::CacheStoragePermissions()
58092: {
58092:   nsDOMStorage* storage = static_cast<nsDOMStorage*>(mStorage.get());
58092:   return storage->CacheStoragePermissions();
58092: }
58092: 
58092: void
58092: StorageChild::InitRemote()
58092: {
58092:   ContentChild* child = ContentChild::GetSingleton();
58092:   AddIPDLReference();
58092:   child->SendPStorageConstructor(this, null_t());
99466:   SendInit(mUseDB, mCanUseChromePersist, mSessionOnly, mDomain, mScopeDBKey,
58092:            mQuotaDomainDBKey, mQuotaETLDplus1DomainDBKey, mStorageType);
58092: }
58092: 
58092: void
99466: StorageChild::InitAsSessionStorage(nsIURI* aDomainURI)
58092: {
99466:   DOMStorageBase::InitAsSessionStorage(aDomainURI);
58092:   InitRemote();
58092: }
58092: 
58092: void
99466: StorageChild::InitAsLocalStorage(nsIURI* aDomainURI, bool aCanUseChromePersist)
58092: {
99466:   DOMStorageBase::InitAsLocalStorage(aDomainURI, aCanUseChromePersist);
58092:   InitRemote();
58092: }
58092: 
58092: nsTArray<nsString>*
58092: StorageChild::GetKeys(bool aCallerSecure)
58092: {
58092:   InfallibleTArray<nsString> remoteKeys;
58092:   SendGetKeys(aCallerSecure, &remoteKeys);
58092:   nsTArray<nsString>* keys = new nsTArray<nsString>;
58092:   *keys = remoteKeys;
58092:   return keys;
58092: }
58092: 
58092: nsresult
58092: StorageChild::GetLength(bool aCallerSecure, PRUint32* aLength)
58092: {
58092:   nsresult rv;
60073:   SendGetLength(aCallerSecure, mSessionOnly, aLength, &rv);
58092:   return rv;
58092: }
58092: 
58092: nsresult
58092: StorageChild::GetKey(bool aCallerSecure, PRUint32 aIndex, nsAString& aKey)
58092: {
58092:   nsresult rv;
58092:   nsString key;
60073:   SendGetKey(aCallerSecure, mSessionOnly, aIndex, &key, &rv);
58092:   if (NS_FAILED(rv))
58092:     return rv;
58092:   aKey = key;
58092:   return NS_OK;
58092: }
58092: 
58092: // Unlike other cross-process forwarding methods, GetValue needs to replicate
58092: // the following behaviour of DOMStorageImpl::GetValue:
58092: //
58092: // - if a security error occurs, or the item isn't found, return null without
58092: //   propogating the error.
58092: //
58092: // If DOMStorageImpl::GetValue ever changes its behaviour, this should be kept
58092: // in sync.
58092: nsIDOMStorageItem*
58092: StorageChild::GetValue(bool aCallerSecure, const nsAString& aKey, nsresult* rv)
58092: {
58092:   nsresult rv2 = *rv = NS_OK;
58092:   StorageItem storageItem;
60073:   SendGetValue(aCallerSecure, mSessionOnly, nsString(aKey), &storageItem, &rv2);
58092:   if (rv2 == NS_ERROR_DOM_SECURITY_ERR || rv2 == NS_ERROR_DOM_NOT_FOUND_ERR)
58092:     return nsnull;
58092:   *rv = rv2;
58092:   if (NS_FAILED(*rv) || storageItem.type() == StorageItem::Tnull_t)
58092:     return nsnull;
58092:   const ItemData& data = storageItem.get_ItemData();
58092:   nsIDOMStorageItem* item = new nsDOMStorageItem(this, aKey, data.value(),
58092:                                                  data.secure());
58092:   return item;
58092: }
58092: 
58092: nsresult
58092: StorageChild::SetValue(bool aCallerSecure, const nsAString& aKey,
58092:                        const nsAString& aData, nsAString& aOldData)
58092: {
58092:   nsresult rv;
58092:   nsString oldData;
60073:   SendSetValue(aCallerSecure, mSessionOnly, nsString(aKey), nsString(aData),
60073:                &oldData, &rv);
58092:   if (NS_FAILED(rv))
58092:     return rv;
58092:   aOldData = oldData;
58092:   return NS_OK;
58092: }
58092: 
58092: nsresult
58092: StorageChild::RemoveValue(bool aCallerSecure, const nsAString& aKey,
58092:                           nsAString& aOldData)
58092: {
58092:   nsresult rv;
58092:   nsString oldData;
60073:   SendRemoveValue(aCallerSecure, mSessionOnly, nsString(aKey), &oldData, &rv);
58092:   if (NS_FAILED(rv))
58092:     return rv;
58092:   aOldData = oldData;
58092:   return NS_OK;
58092: }
58092: 
58092: nsresult
58092: StorageChild::Clear(bool aCallerSecure, PRInt32* aOldCount)
58092: {
58092:   nsresult rv;
58092:   PRInt32 oldCount;
60073:   SendClear(aCallerSecure, mSessionOnly, &oldCount, &rv);
58092:   if (NS_FAILED(rv))
58092:     return rv;
58092:   *aOldCount = oldCount;
58092:   return NS_OK;
58092: }
58092: 
58092: bool
58092: StorageChild::CanUseChromePersist()
58092: {
58092:   return mCanUseChromePersist;
58092: }
58092: 
58092: nsresult
58092: StorageChild::GetDBValue(const nsAString& aKey, nsAString& aValue,
79445:                          bool* aSecure)
58092: {
58092:   nsresult rv;
58092:   nsString value;
58092:   SendGetDBValue(nsString(aKey), &value, aSecure, &rv);
58092:   aValue = value;
58092:   return rv;
58092: }
58092: 
58092: nsresult
58092: StorageChild::SetDBValue(const nsAString& aKey,
58092:                          const nsAString& aValue,
79445:                          bool aSecure)
58092: {
58092:   nsresult rv;
58092:   SendSetDBValue(nsString(aKey), nsString(aValue), aSecure, &rv);
58092:   return rv;
58092: }
58092: 
58092: nsresult
79445: StorageChild::SetSecure(const nsAString& aKey, bool aSecure)
58092: {
58092:   nsresult rv;
58092:   SendSetSecure(nsString(aKey), aSecure, &rv);
58092:   return rv;
58092: }
58092: 
58092: nsresult
58092: StorageChild::CloneFrom(bool aCallerSecure, DOMStorageBase* aThat)
58092: {
58092:   StorageChild* other = static_cast<StorageChild*>(aThat);
58092:   ContentChild* child = ContentChild::GetSingleton();
58092:   StorageClone clone(nsnull, other, aCallerSecure);
58092:   AddIPDLReference();
58092:   child->SendPStorageConstructor(this, clone);
99466:   SendInit(mUseDB, mCanUseChromePersist, mSessionOnly, mDomain, mScopeDBKey,
99466:            mQuotaDomainDBKey, mQuotaETLDplus1DomainDBKey, mStorageType);
58092:   return NS_OK;
58092: }
58092: 
58092: }
58092: }
