40362: /* -*- Mode: C; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
40362:  * vim: set ts=8 sw=4 et tw=98:
40362:  *
40362:  * ***** BEGIN LICENSE BLOCK *****
40359:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
40359:  *
40359:  * The contents of this file are subject to the Mozilla Public License Version
40359:  * 1.1 (the "License"); you may not use this file except in compliance with
40359:  * the License. You may obtain a copy of the License at
40359:  * http://www.mozilla.org/MPL/
40359:  *
40359:  * Software distributed under the License is distributed on an "AS IS" basis,
40359:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
40359:  * for the specific language governing rights and limitations under the
40359:  * License.
40359:  *
40359:  * The Original Code is Mozilla Communicator client code, released
40359:  * March 31, 1998.
40359:  *
40359:  * The Initial Developer of the Original Code is
40359:  * Netscape Communications Corporation.
40359:  * Portions created by the Initial Developer are Copyright (C) 1998
40359:  * the Initial Developer. All Rights Reserved.
40359:  *
40359:  * Contributor(s):
40359:  *
40359:  * Alternatively, the contents of this file may be used under the terms of
40359:  * either the GNU General Public License Version 2 or later (the "GPL"), or
40359:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
40359:  * in which case the provisions of the GPL or the LGPL are applicable instead
40359:  * of those above. If you wish to allow use of your version of this file only
40359:  * under the terms of either the GPL or the LGPL, and not to allow others to
40359:  * use your version of this file under the terms of the MPL, indicate your
40359:  * decision by deleting the provisions above and replace them with the notice
40359:  * and other provisions required by the GPL or the LGPL. If you do not delete
40359:  * the provisions above, a recipient may use your version of this file under
40359:  * the terms of any one of the MPL, the GPL or the LGPL.
40359:  *
40359:  * ***** END LICENSE BLOCK ***** */
40359: 
40359: #include "jspropertycache.h"
52503: #include "jscntxt.h"
52503: #include "jsnum.h"
52503: #include "jsobjinlines.h"
40359: #include "jspropertycacheinlines.h"
40359: 
40359: using namespace js;
40359: 
40374: JS_STATIC_ASSERT(sizeof(PCVal) == sizeof(jsuword));
40374: 
40362: JS_REQUIRES_STACK PropertyCacheEntry *
40362: PropertyCache::fill(JSContext *cx, JSObject *obj, uintN scopeIndex, uintN protoIndex,
52503:                     JSObject *pobj, const Shape *shape, JSBool adding)
40359: {
40359:     jsbytecode *pc;
40359:     jsuword kshape, vshape;
40359:     JSOp op;
40359:     const JSCodeSpec *cs;
40374:     PCVal vword;
40362:     PropertyCacheEntry *entry;
40359: 
40362:     JS_ASSERT(this == &JS_PROPERTY_CACHE(cx));
40359:     JS_ASSERT(!cx->runtime->gcRunning);
40359: 
51472:     if (js_IsPropertyCacheDisabled(cx)) {
40362:         PCMETER(disfills++);
40359:         return JS_NO_PROP_CACHE_FILL;
40359:     }
40359: 
40359:     /*
52503:      * Check for fill from js_SetPropertyHelper where the setter removed shape
52503:      * from pobj (via unwatch or delete, e.g.).
40359:      */
52503:     if (!pobj->nativeContains(*shape)) {
40362:         PCMETER(oddfills++);
40359:         return JS_NO_PROP_CACHE_FILL;
40359:     }
40359: 
40359:     /*
53842:      * Dictionary-mode objects have unique shapes, so there is no way to cache
53842:      * a prediction of the next shape when adding.
53842:      */
53842:     if (adding && obj->inDictionaryMode()) {
53842:         PCMETER(add2dictfills++);
53842:         return JS_NO_PROP_CACHE_FILL;
53842:     }
53842: 
53842:     /*
40359:      * Check for overdeep scope and prototype chain. Because resolve, getter,
40359:      * and setter hooks can change the prototype chain using JS_SetPrototype
40359:      * after js_LookupPropertyWithFlags has returned the nominal protoIndex,
40359:      * we have to validate protoIndex if it is non-zero. If it is zero, then
52503:      * we know thanks to the pobj->nativeContains test above, combined with the
40359:      * fact that obj == pobj, that protoIndex is invariant.
40359:      *
40359:      * The scopeIndex can't be wrong. We require JS_SetParent calls to happen
40359:      * before any running script might consult a parent-linked scope chain. If
40359:      * this requirement is not satisfied, the fill in progress will never hit,
40359:      * but vcap vs. scope shape tests ensure nothing malfunctions.
40359:      */
40359:     JS_ASSERT_IF(scopeIndex == 0 && protoIndex == 0, obj == pobj);
40359: 
40359:     if (protoIndex != 0) {
40359:         JSObject *tmp = obj;
40359: 
40359:         for (uintN i = 0; i != scopeIndex; i++)
40359:             tmp = tmp->getParent();
40359:         JS_ASSERT(tmp != pobj);
40359: 
40359:         protoIndex = 1;
40359:         for (;;) {
49194:             tmp = tmp->getProto();
49194: 
40359:             /*
40359:              * We cannot cache properties coming from native objects behind
49194:              * non-native ones on the prototype chain. The non-natives can
49194:              * mutate in arbitrary way without changing any shapes.
40359:              */
40430:             if (!tmp || !tmp->isNative()) {
40362:                 PCMETER(noprotos++);
40359:                 return JS_NO_PROP_CACHE_FILL;
40359:             }
40359:             if (tmp == pobj)
40359:                 break;
40359:             ++protoIndex;
40359:         }
40359:     }
40359: 
40359:     if (scopeIndex > PCVCAP_SCOPEMASK || protoIndex > PCVCAP_PROTOMASK) {
40362:         PCMETER(longchains++);
40359:         return JS_NO_PROP_CACHE_FILL;
40359:     }
40359: 
40359:     /*
40359:      * Optimize the cached vword based on our parameters and the current pc's
40359:      * opcode format flags.
40359:      */
42717:     pc = cx->regs->pc;
53840:     op = js_GetOpcode(cx, cx->fp()->script(), pc);
40359:     cs = &js_CodeSpec[op];
40359:     kshape = 0;
40359: 
40359:     do {
40359:         /*
40359:          * Check for a prototype "plain old method" callee computation. What
40359:          * is a plain old method? It's a function-valued property with stub
40359:          * getter, so get of a function is idempotent.
40359:          */
40359:         if (cs->format & JOF_CALLOP) {
52503:             if (shape->isMethod()) {
40359:                 /*
40359:                  * A compiler-created function object, AKA a method, already
40359:                  * memoized in the property tree.
40359:                  */
52503:                 JS_ASSERT(pobj->hasMethodBarrier());
52503:                 JSObject &funobj = shape->methodObject();
52503:                 JS_ASSERT(&funobj == &pobj->lockedGetSlot(shape->slot).toObject());
48470:                 vword.setFunObj(funobj);
40359:                 break;
40359:             }
40359: 
52503:             if (!pobj->generic() &&
52503:                 shape->hasDefaultGetter() &&
52503:                 pobj->containsSlot(shape->slot)) {
52503:                 const Value &v = pobj->lockedGetSlot(shape->slot);
48470:                 JSObject *funobj;
52503: 
48470:                 if (IsFunctionObject(v, &funobj)) {
40359:                     /*
40359:                      * Great, we have a function-valued prototype property
40359:                      * where the getter is JS_PropertyStub. The type id in
52503:                      * pobj does not evolve with changes to property values,
52503:                      * however.
40359:                      *
40359:                      * So here, on first cache fill for this method, we brand
52503:                      * obj with a new shape and set the JSObject::BRANDED flag.
52503:                      * Once this flag is set, any property assignment that
52503:                      * changes the value from or to a different function object
52503:                      * will result in shape being regenerated.
40359:                      */
52503:                     if (!pobj->branded()) {
40362:                         PCMETER(brandfills++);
40359: #ifdef DEBUG_notme
40359:                         fprintf(stderr,
40359:                                 "branding %p (%s) for funobj %p (%s), shape %lu\n",
40359:                                 pobj, pobj->getClass()->name,
40359:                                 JSVAL_TO_OBJECT(v),
40359:                                 JS_GetFunctionName(GET_FUNCTION_PRIVATE(cx, JSVAL_TO_OBJECT(v))),
40847:                                 obj->shape());
40359: #endif
52503:                         if (!pobj->brand(cx, shape->slot, v))
40359:                             return JS_NO_PROP_CACHE_FILL;
40359:                     }
48470:                     vword.setFunObj(*funobj);
40359:                     break;
40359:                 }
40359:             }
40359:         }
40359: 
40806:         /*
40806:          * If getting a value via a stub getter, or doing an INCDEC op
40806:          * with stub getters and setters, we can cache the slot.
40806:          */
40806:         if (!(cs->format & (JOF_SET | JOF_FOR)) &&
52503:             (!(cs->format & JOF_INCDEC) || shape->hasDefaultSetter()) &&
52503:             shape->hasDefaultGetter() &&
52503:             pobj->containsSlot(shape->slot)) {
52503:             /* Great, let's cache shape's slot and use it on cache hit. */
52503:             vword.setSlot(shape->slot);
40359:         } else {
52503:             /* Best we can do is to cache shape (still a nice speedup). */
52503:             vword.setShape(shape);
40359:             if (adding &&
52503:                 pobj->shape() == shape->shape) {
40359:                 /*
40359:                  * Our caller added a new property. We also know that a setter
52503:                  * that js_NativeSet might have run has not mutated pobj, so
52503:                  * the added property is still the last one added, and pobj is
52503:                  * not branded.
40359:                  *
52503:                  * We want to cache under pobj's shape before the property
40359:                  * addition to bias for the case when the mutator opcode
40359:                  * always adds the same property. This allows us to optimize
40359:                  * periodic execution of object initializers or other explicit
40359:                  * initialization sequences such as
40359:                  *
40359:                  *   obj = {}; obj.x = 1; obj.y = 2;
40359:                  *
40359:                  * We assume that on average the win from this optimization is
40359:                  * greater than the cost of an extra mismatch per loop owing to
40359:                  * the bias for the following case:
40359:                  *
40359:                  *   obj = {}; ... for (...) { ... obj.x = ... }
40359:                  *
40359:                  * On the first iteration of such a for loop, JSOP_SETPROP
40359:                  * fills the cache with the shape of the newly created object
40359:                  * obj, not the shape of obj after obj.x has been assigned.
40359:                  * That mismatches obj's shape on the second iteration. Note
40359:                  * that on the third and subsequent iterations the cache will
40359:                  * be hit because the shape is no longer updated.
40359:                  */
52503:                 JS_ASSERT(shape == pobj->lastProperty());
52503:                 JS_ASSERT(!pobj->nativeEmpty());
52503: 
52503:                 kshape = shape->previous()->shape;
40359: 
40359:                 /*
40359:                  * When adding we predict no prototype object will later gain a
40359:                  * readonly property or setter.
40359:                  */
40359:                 vshape = cx->runtime->protoHazardShape;
40359:             }
40359:         }
40359:     } while (0);
40359: 
40359:     if (kshape == 0) {
40847:         kshape = obj->shape();
52503:         vshape = pobj->shape();
40359:     }
40359:     JS_ASSERT(kshape < SHAPE_OVERFLOW_BIT);
40359: 
40359:     if (obj == pobj) {
40359:         JS_ASSERT(scopeIndex == 0 && protoIndex == 0);
40359:     } else {
40359: #ifdef DEBUG
40359:         if (scopeIndex == 0) {
40359:             JS_ASSERT(protoIndex != 0);
40359:             JS_ASSERT((protoIndex == 1) == (obj->getProto() == pobj));
40359:         }
40359: #endif
40359: 
40359:         if (scopeIndex != 0 || protoIndex != 1) {
40359:             /*
40359:              * Make sure that a later shadowing assignment will enter
40359:              * PurgeProtoChain and invalidate this entry, bug 479198.
40359:              *
52503:              * This is not thread-safe but we are about to make all objects
52503:              * except multi-threaded wrappers (bug 566951) single-threaded.
52503:              * And multi-threaded wrappers are non-native Proxy instances, so
52503:              * they won't use the property cache.
40359:              */
40359:             obj->setDelegate();
40359:         }
40359:     }
40359:     JS_ASSERT(vshape < SHAPE_OVERFLOW_BIT);
40359: 
40362:     entry = &table[hash(pc, kshape)];
40374:     PCMETER(entry->vword.isNull() || recycles++);
40362:     entry->assign(pc, kshape, vshape, scopeIndex, protoIndex, vword);
40359: 
40362:     empty = false;
40362:     PCMETER(fills++);
40359: 
40359:     /*
40359:      * The modfills counter is not exact. It increases if a getter or setter
40359:      * recurse into the interpreter.
40359:      */
40362:     PCMETER(entry == pctestentry || modfills++);
40362:     PCMETER(pctestentry = NULL);
40359:     return entry;
40359: }
40359: 
40359: static inline JSAtom *
40359: GetAtomFromBytecode(JSContext *cx, jsbytecode *pc, JSOp op, const JSCodeSpec &cs)
40359: {
40359:     if (op == JSOP_LENGTH)
40359:         return cx->runtime->atomState.lengthAtom;
40359: 
53121:     // The method JIT's implementation of instanceof contains an internal lookup
53121:     // of the prototype property.
53121:     if (op == JSOP_INSTANCEOF)
53121:         return cx->runtime->atomState.classPrototypeAtom;
53121: 
40359:     ptrdiff_t pcoff = (JOF_TYPE(cs.format) == JOF_SLOTATOM) ? SLOTNO_LEN : 0;
40359:     JSAtom *atom;
53840:     GET_ATOM_FROM_BYTECODE(cx->fp()->script(), pc, pcoff, atom);
40359:     return atom;
40359: }
40359: 
40359: JS_REQUIRES_STACK JSAtom *
40362: PropertyCache::fullTest(JSContext *cx, jsbytecode *pc, JSObject **objp, JSObject **pobjp,
40362:                         PropertyCacheEntry *entry)
40359: {
40359:     JSObject *obj, *pobj, *tmp;
40359:     uint32 vcap;
40359: 
51446:     JSStackFrame *fp = cx->fp();
51446: 
40362:     JS_ASSERT(this == &JS_PROPERTY_CACHE(cx));
53840:     JS_ASSERT(uintN((fp->hasImacropc() ? fp->imacropc() : pc) - fp->script()->code)
53840:               < fp->script()->length);
40359: 
53840:     JSOp op = js_GetOpcode(cx, fp->script(), pc);
40359:     const JSCodeSpec &cs = js_CodeSpec[op];
40359: 
40359:     obj = *objp;
40359:     vcap = entry->vcap;
40359: 
40359:     if (entry->kpc != pc) {
40362:         PCMETER(kpcmisses++);
40359: 
40359:         JSAtom *atom = GetAtomFromBytecode(cx, pc, op, cs);
40359: #ifdef DEBUG_notme
51449:         JSScript *script = cx->fp()->getScript();
40359:         fprintf(stderr,
40359:                 "id miss for %s from %s:%u"
40359:                 " (pc %u, kpc %u, kshape %u, shape %u)\n",
40359:                 js_AtomToPrintableString(cx, atom),
51449:                 script->filename,
51449:                 js_PCToLineNumber(cx, script, pc),
51449:                 pc - script->code,
51449:                 entry->kpc - script->code,
40359:                 entry->kshape,
40847:                 obj->shape());
51449:                 js_Disassemble1(cx, script, pc,
51449:                                 pc - script->code,
40359:                                 JS_FALSE, stderr);
40359: #endif
40359: 
40359:         return atom;
40359:     }
40359: 
52503:     if (entry->kshape != obj->shape()) {
40362:         PCMETER(kshapemisses++);
40359:         return GetAtomFromBytecode(cx, pc, op, cs);
40359:     }
40359: 
40359:     /*
40362:      * PropertyCache::test handles only the direct and immediate-prototype hit
40362:      * cases. All others go here. We could embed the target object in the cache
40359:      * entry but then entry size would be 5 words. Instead we traverse chains.
40359:      */
40359:     pobj = obj;
40359: 
40359:     if (JOF_MODE(cs.format) == JOF_NAME) {
40359:         while (vcap & (PCVCAP_SCOPEMASK << PCVCAP_PROTOBITS)) {
40359:             tmp = pobj->getParent();
40430:             if (!tmp || !tmp->isNative())
40359:                 break;
40359:             pobj = tmp;
40359:             vcap -= PCVCAP_PROTOSIZE;
40359:         }
40359: 
40359:         *objp = pobj;
40359:     }
40359: 
40359:     while (vcap & PCVCAP_PROTOMASK) {
40359:         tmp = pobj->getProto();
40430:         if (!tmp || !tmp->isNative())
40359:             break;
40359:         pobj = tmp;
40359:         --vcap;
40359:     }
40359: 
40362:     if (matchShape(cx, pobj, vcap >> PCVCAP_TAGBITS)) {
40359: #ifdef DEBUG
40359:         JSAtom *atom = GetAtomFromBytecode(cx, pc, op, cs);
40359:         jsid id = ATOM_TO_JSID(atom);
40359: 
40359:         id = js_CheckForStringIndex(id);
52503:         JS_ASSERT(pobj->nativeContains(id));
40359: #endif
40359:         *pobjp = pobj;
40359:         return NULL;
40359:     }
40359: 
40362:     PCMETER(vcapmisses++);
40359:     return GetAtomFromBytecode(cx, pc, op, cs);
40359: }
40359: 
40359: #ifdef DEBUG
40362: void
40362: PropertyCache::assertEmpty()
40362: {
40362:     JS_ASSERT(empty);
40362:     for (uintN i = 0; i < SIZE; i++) {
40362:         JS_ASSERT(!table[i].kpc);
40362:         JS_ASSERT(!table[i].kshape);
40362:         JS_ASSERT(!table[i].vcap);
40374:         JS_ASSERT(table[i].vword.isNull());
40362:     }
40362: }
40359: #endif
40359: 
40359: void
40362: PropertyCache::purge(JSContext *cx)
40359: {
40362:     if (empty) {
40362:         assertEmpty();
40359:         return;
40359:     }
40359: 
40362:     PodArrayZero(table);
40374:     JS_ASSERT(table[0].vword.isNull());
40362:     empty = true;
40359: 
40359: #ifdef JS_PROPERTY_CACHE_METERING
40359:   { static FILE *fp;
40359:     if (!fp)
40359:         fp = fopen("/tmp/propcache.stats", "w");
40359:     if (fp) {
40359:         fputs("Property cache stats for ", fp);
40359: #ifdef JS_THREADSAFE
40359:         fprintf(fp, "thread %lu, ", (unsigned long) cx->thread->id);
40359: #endif
40359:         fprintf(fp, "GC %u\n", cx->runtime->gcNumber);
40359: 
40362: # define P(mem) fprintf(fp, "%11s %10lu\n", #mem, (unsigned long)mem)
40359:         P(fills);
40359:         P(nofills);
40359:         P(rofills);
40359:         P(disfills);
40359:         P(oddfills);
53842:         P(add2dictfills);
40359:         P(modfills);
40359:         P(brandfills);
40359:         P(noprotos);
40359:         P(longchains);
40359:         P(recycles);
40359:         P(tests);
40359:         P(pchits);
40359:         P(protopchits);
40359:         P(initests);
40359:         P(inipchits);
40359:         P(inipcmisses);
40359:         P(settests);
40359:         P(addpchits);
40359:         P(setpchits);
40359:         P(setpcmisses);
40359:         P(setmisses);
40359:         P(kpcmisses);
40359:         P(kshapemisses);
40359:         P(vcapmisses);
40359:         P(misses);
40359:         P(flushes);
40359:         P(pcpurges);
40359: # undef P
40359: 
40359:         fprintf(fp, "hit rates: pc %g%% (proto %g%%), set %g%%, ini %g%%, full %g%%\n",
40362:                 (100. * pchits) / tests,
40362:                 (100. * protopchits) / tests,
40362:                 (100. * (addpchits + setpchits))
40362:                 / settests,
40362:                 (100. * inipchits) / initests,
40362:                 (100. * (tests - misses)) / tests);
40359:         fflush(fp);
40359:     }
40359:   }
40359: #endif
40359: 
40362:     PCMETER(flushes++);
40359: }
40359: 
40359: void
40362: PropertyCache::purgeForScript(JSScript *script)
40359: {
40362:     for (PropertyCacheEntry *entry = table; entry < table + SIZE; entry++) {
40359:         if (JS_UPTRDIFF(entry->kpc, script->code) < script->length) {
40359:             entry->kpc = NULL;
40359: #ifdef DEBUG
40374:             entry->kshape = entry->vcap = 0;
40374:             entry->vword.setNull();
40359: #endif
40359:         }
40359:     }
40359: }
