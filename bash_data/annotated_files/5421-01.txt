   1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
   1: /* ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Mozilla Communicator client code.
   1:  *
   1:  * The Initial Developer of the Original Code is
   1:  * Netscape Communications Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 1998
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Uri Bernstein <uriber@gmail.com>
   1:  *   Haamed Gheibi <gheibi@metanetworking.com>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
   1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #ifdef IBMBIDI
   1: 
   1: #include "nsBidiPresUtils.h"
   1: #include "nsTextFragment.h"
   1: #include "nsGkAtoms.h"
   1: #include "nsPresContext.h"
   1: #include "nsIRenderingContext.h"
   1: #include "nsIServiceManager.h"
   1: #include "nsFrameManager.h"
   1: #include "nsBidiFrames.h"
   1: #include "nsBidiUtils.h"
   1: #include "nsCSSFrameConstructor.h"
   1: #include "nsHTMLContainerFrame.h"
   1: #include "nsInlineFrame.h"
5421: #include "nsPlaceholderFrame.h"
   1: 
   1: static NS_DEFINE_IID(kInlineFrameCID, NS_INLINE_FRAME_CID);
   1: 
   1: static const PRUnichar kSpace            = 0x0020;
   1: static const PRUnichar kLineSeparator    = 0x2028;
   1: static const PRUnichar kObjectSubstitute = 0xFFFC;
   1: static const PRUnichar kLRE              = 0x202A;
   1: static const PRUnichar kRLE              = 0x202B;
   1: static const PRUnichar kLRO              = 0x202D;
   1: static const PRUnichar kRLO              = 0x202E;
   1: static const PRUnichar kPDF              = 0x202C;
   1: static const PRUnichar ALEF              = 0x05D0;
   1: 
   1: #define CHAR_IS_HEBREW(c) ((0x0590 <= (c)) && ((c)<= 0x05FF))
   1: // Note: The above code are moved from gfx/src/windows/nsRenderingContextWin.cpp
   1: 
   1: nsIFrame*
   1: NS_NewDirectionalFrame(nsIPresShell* aPresShell, nsStyleContext* aContext, PRUnichar aChar);
   1: 
   1: nsBidiPresUtils::nsBidiPresUtils() : mArraySize(8),
   1:                                      mIndexMap(nsnull),
   1:                                      mLevels(nsnull),
   1:                                      mSuccess(NS_ERROR_FAILURE),
   1:                                      mBidiEngine(nsnull)
   1: {
   1:   mBidiEngine = new nsBidi();
   1:   if (mBidiEngine && mContentToFrameIndex.Init()) {
   1:     mSuccess = NS_OK;
   1:   }
   1: }
   1: 
   1: nsBidiPresUtils::~nsBidiPresUtils()
   1: {
   1:   if (mLevels) {
   1:     delete[] mLevels;
   1:   }
   1:   if (mIndexMap) {
   1:     delete[] mIndexMap;
   1:   }
   1:   delete mBidiEngine;
   1: }
   1: 
   1: PRBool
   1: nsBidiPresUtils::IsSuccessful() const
   1: { 
   1:   return NS_SUCCEEDED(mSuccess); 
   1: }
   1: 
   1: /* Some helper methods for Resolve() */
   1: 
   1: // Should this frame be split between text runs?
   1: PRBool
   1: IsBidiSplittable(nsIFrame* aFrame) {
   1:   nsIAtom* frameType = aFrame->GetType();
   1:   // Bidi inline containers should be split, unless they're line frames.
   1:   return aFrame->IsFrameOfType(nsIFrame::eBidiInlineContainer)
   1:     && frameType != nsGkAtoms::lineFrame;
   1: }
   1: 
   1: static nsresult
   1: SplitInlineAncestors(nsPresContext* aPresContext,
   1:                       nsIFrame*     aFrame)
   1: {
   1:   nsIPresShell *presShell = aPresContext->PresShell();
   1:   nsIFrame* frame = aFrame;
   1:   nsIFrame* parent = aFrame->GetParent();
   1:   nsIFrame* newFrame = aFrame->GetNextSibling();
   1:   nsIFrame* newParent;
   1: 
   1:   while (IsBidiSplittable(parent)) {
   1:     nsIFrame* grandparent = parent->GetParent();
   1:     NS_ASSERTION(grandparent, "Couldn't get parent's parent in nsBidiPresUtils::SplitInlineAncestors");
   1:     
   1:     nsresult rv = presShell->FrameConstructor()->
   1:       CreateContinuingFrame(aPresContext, parent, grandparent, &newParent, PR_FALSE);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1:     
   1:     // The new parent adopts the new frame
   1:     frame->SetNextSibling(nsnull);
   1:     rv = newParent->InsertFrames(nsGkAtoms::nextBidi, nsnull, newFrame);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1: 
   1:     // Reparent views as necessary
   1:     rv = nsHTMLContainerFrame::ReparentFrameViewList(aPresContext, newFrame, parent, newParent);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1:     
   1:     // The list name nsGkAtoms::nextBidi would indicate we don't want reflow
   1:     rv = grandparent->InsertFrames(nsGkAtoms::nextBidi, parent, newParent);
   1:     if (NS_FAILED(rv)) {
   1:       return rv;
   1:     }
   1:     
   1:     frame = parent;
   1:     newFrame = newParent;
   1:     parent = grandparent;
   1:   }
   1:   
   1:   return NS_OK;
   1: }
   1: 
   1: static nsresult
   1: CreateBidiContinuation(nsPresContext* aPresContext,
   1:                        nsIFrame*       aFrame,
   1:                        nsIFrame**      aNewFrame)
   1: {
   1:   NS_PRECONDITION(aNewFrame, "null OUT ptr");
   1:   NS_PRECONDITION(aFrame, "null ptr");
   1: 
   1:   *aNewFrame = nsnull;
   1: 
   1:   nsIPresShell *presShell = aPresContext->PresShell();
   1:   NS_ASSERTION(presShell, "PresShell must be set on PresContext before calling nsBidiPresUtils::CreateBidiContinuation");
   1: 
   1:   nsIFrame* parent = aFrame->GetParent();
   1:   NS_ASSERTION(parent, "Couldn't get frame parent in nsBidiPresUtils::CreateBidiContinuation");
   1:   
   1:   nsresult rv = presShell->FrameConstructor()->
   1:     CreateContinuingFrame(aPresContext, aFrame, parent, aNewFrame, PR_FALSE);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1:   
   1:   // The list name nsGkAtoms::nextBidi would indicate we don't want reflow
   1:   rv = parent->InsertFrames(nsGkAtoms::nextBidi, aFrame, *aNewFrame);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1:   
   1:   // Split inline ancestor frames
   1:   rv = SplitInlineAncestors(aPresContext, aFrame);
   1:   if (NS_FAILED(rv)) {
   1:     return rv;
   1:   }
   1: 
   1:   return NS_OK;
   1: }
   1: 
5421: static PRBool
   1: AdvanceLineIteratorToFrame(nsIFrame* aFrame,
   1:                            nsIFrame* aBlockFrame,
   1:                            nsBlockFrame::line_iterator& aLine,
   1:                            nsIFrame*& aPrevFrame,
   1:                            const nsBlockFrame::line_iterator& aEndLines)
   1: {
   1:   // Advance aLine to the line containing aFrame
   1:   nsIFrame* child = aFrame;
   1:   nsIFrame* parent = child->GetParent();
   1:   while (parent && parent != aBlockFrame) {
5421:     if (parent->GetStyleDisplay()->IsBlockOutside())
5421:       return PR_FALSE;
   1:     child = parent;
   1:     parent = child->GetParent();
   1:   }
   1:   NS_ASSERTION (parent, "aFrame is not a descendent of aBlockFrame");
   1:   while (aLine != aEndLines && !aLine->ContainsAfter(aPrevFrame, child, aLine, aEndLines)) {
   1:     ++aLine;
   1:     aPrevFrame = nsnull;
   1:   }
   1:   aPrevFrame = child;
   1:   NS_ASSERTION (aLine != aEndLines, "frame not found on any line");
5421:   return PR_TRUE;
   1: }
   1: 
   1: /*
   1:  * Overview of the implementation of Resolve():
   1:  *
   1:  *  Walk through the descendants of aBlockFrame and build:
   1:  *   * mLogicalArray: an nsVoidArray of nsIFrame* pointers in logical order
   1:  *   * mBuffer: an nsAutoString containing a representation of
   1:  *     the content of the frames.
   1:  *     In the case of text frames, this is the actual text context of the
   1:  *     frames, but some other elements are represented in a symbolic form which
   1:  *     will make the Unicode Bidi Algorithm give the correct results.
   1:  *     Bidi embeddings and overrides set by CSS or <bdo> elements are
   1:  *     represented by the corresponding Unicode control characters.
   1:  *     <br> elements are represented by U+2028 LINE SEPARATOR
   1:  *     Other inline elements are represented by U+FFFC OBJECT REPLACEMENT
   1:  *     CHARACTER
   1:  *
   1:  *  Then pass mBuffer to the Bidi engine for resolving of embedding levels
   1:  *  by nsBidi::SetPara() and division into directional runs by
   1:  *  nsBidi::CountRuns().
   1:  *
   1:  *  Finally, walk these runs in logical order using nsBidi::GetLogicalRun() and
   1:  *  correlate them with the frames indexed in mLogicalArray, setting the
   1:  *  baseLevel, embeddingLevel, and charType properties according to the results
   1:  *  returned by the Bidi engine and CalculateCharType().
   1:  *
   1:  *  The rendering layer requires each text frame to contain text in only one
   1:  *  direction and of only one character type, so we may need to call
   1:  *  EnsureBidiContinuation() to split frames. We may also need to call
   1:  *  RemoveBidiContinuation() to convert frames created by
   1:  *  EnsureBidiContinuation() in previous reflows into fluid continuations.
   1:  */
   1: nsresult
   1: nsBidiPresUtils::Resolve(nsPresContext* aPresContext,
   1:                          nsBlockFrame*   aBlockFrame,
   1:                          nsIFrame*       aFirstChild,
   1:                          PRBool          aIsVisualFormControl)
   1: {
   1:   mLogicalFrames.Clear();
   1:   mContentToFrameIndex.Clear();
   1:   
   1:   nsIPresShell* shell = aPresContext->PresShell();
   1:   nsStyleContext* styleContext = aBlockFrame->GetStyleContext();
   1: 
   1:   // handle bidi-override being set on the block itself before calling
   1:   // InitLogicalArray.
   1:   const nsStyleVisibility* vis = aBlockFrame->GetStyleVisibility();
   1:   const nsStyleTextReset* text = aBlockFrame->GetStyleTextReset();
   1: 
   1:   if (text->mUnicodeBidi == NS_STYLE_UNICODE_BIDI_OVERRIDE) {
   1:     nsIFrame *directionalFrame = nsnull;
   1: 
   1:     if (NS_STYLE_DIRECTION_RTL == vis->mDirection) {
   1:       directionalFrame = NS_NewDirectionalFrame(shell, styleContext, kRLO);
   1:     }
   1:     else if (NS_STYLE_DIRECTION_LTR == vis->mDirection) {
   1:       directionalFrame = NS_NewDirectionalFrame(shell, styleContext, kLRO);
   1:     }
   1: 
   1:     if (directionalFrame) {
   1:       mLogicalFrames.AppendElement(directionalFrame);
   1:     }
   1:   }
   1:   mSuccess = InitLogicalArray(aPresContext, aFirstChild, nsnull, PR_TRUE);
   1: 
   1:   if (text->mUnicodeBidi == NS_STYLE_UNICODE_BIDI_OVERRIDE) {
   1:     nsIFrame* directionalFrame = NS_NewDirectionalFrame(shell, styleContext, kPDF);
   1:     if (directionalFrame) {
   1:       mLogicalFrames.AppendElement(directionalFrame);
   1:     }
   1:   }
   1:   if (NS_FAILED(mSuccess) ) {
   1:     return mSuccess;
   1:   }
   1: 
   1:   CreateBlockBuffer(aPresContext);
   1: 
   1:   PRInt32 bufferLength = mBuffer.Length();
   1: 
   1:   if (bufferLength < 1) {
   1:     mSuccess = NS_OK;
   1:     return mSuccess;
   1:   }
   1:   PRInt32 runCount;
   1:   PRUint8 embeddingLevel;
   1: 
   1:   nsBidiLevel paraLevel = embeddingLevel =
   1:     (NS_STYLE_DIRECTION_RTL == vis->mDirection)
   1:     ? NSBIDI_RTL : NSBIDI_LTR;
   1: 
   1:   mSuccess = mBidiEngine->SetPara(mBuffer.get(), bufferLength, paraLevel, nsnull);
   1:   if (NS_FAILED(mSuccess) ) {
   1:       return mSuccess;
   1:   }
   1: 
   1:   PRBool isVisual;
   1:   if (aIsVisualFormControl) {
   1:     isVisual = PR_FALSE;
   1:   } else {
   1:     isVisual = aPresContext->IsVisualMode();
   1:   }
   1:   mSuccess = mBidiEngine->CountRuns(&runCount);
   1:   if (NS_FAILED(mSuccess) ) {
   1:     return mSuccess;
   1:   }
   1:   PRInt32                  runLength      = 0;
   1:   PRInt32                  fragmentLength = 0;
   1:   PRInt32                  temp;
   1:   PRInt32                  frameIndex     = -1;
   1:   PRInt32                  frameCount     = mLogicalFrames.Count();
   1:   PRInt32                  contentOffset  = 0;   // offset within current frame
   1:   PRInt32                  lineOffset     = 0;   // offset within mBuffer
   1:   PRInt32                  logicalLimit   = 0;
   1:   PRInt32                  numRun         = -1;
   1:   PRUint8                  charType;
   1:   PRUint8                  prevType       = eCharType_LeftToRight;
   1:   PRBool                   isTextFrame    = PR_FALSE;
   1:   nsIFrame*                frame = nsnull;
   1:   nsIFrame*                nextBidi;
   1:   nsIContent*              content = nsnull;
   1:   const nsTextFragment*    fragment;
   1:   nsIAtom*                 frameType = nsnull;
   1: 
   1:   nsPropertyTable *propTable = aPresContext->PropertyTable();
   1: 
   1:   nsBlockFrame::line_iterator line = aBlockFrame->begin_lines();
   1:   nsBlockFrame::line_iterator endLines = aBlockFrame->end_lines();
   1:   nsIFrame* prevFrame = nsnull;
   1:   PRBool lineNeedsUpdate = PR_FALSE;
   1:   
   1:   for (; ;) {
   1:     if (fragmentLength <= 0) {
   1:       if (++frameIndex >= frameCount) {
   1:         break;
   1:       }
   1:       contentOffset = 0;
   1:       
   1:       frame = (nsIFrame*) (mLogicalFrames[frameIndex]);
   1:       frameType = frame->GetType();
   1:       lineNeedsUpdate = PR_TRUE;
   1:       if (nsGkAtoms::textFrame == frameType) {
   1:         content = frame->GetContent();
   1:         if (!content) {
   1:           mSuccess = NS_OK;
   1:           break;
   1:         }
   1:         fragment = content->GetText();
   1:         if (!fragment) {
   1:           mSuccess = NS_ERROR_FAILURE;
   1:           break;
   1:         }
   1:         fragmentLength = fragment->GetLength();
   1:         isTextFrame = PR_TRUE;
   1:       } // if text frame
   1:       else {
   1:         isTextFrame = PR_FALSE;
   1:         fragmentLength = 1;
   1:       }
   1:     } // if (fragmentLength <= 0)
   1:     if (runLength <= 0) {
   1:       if (++numRun >= runCount) {
   1:         break;
   1:       }
   1:       lineOffset = logicalLimit;
   1:       if (NS_FAILED(mBidiEngine->GetLogicalRun(
   1:               lineOffset, &logicalLimit, &embeddingLevel) ) ) {
   1:         break;
   1:       }
   1:       runLength = logicalLimit - lineOffset;
   1:       if (isVisual) {
   1:         embeddingLevel = paraLevel;
   1:       }
   1:     } // if (runLength <= 0)
   1: 
   1:     if (nsGkAtoms::directionalFrame == frameType) {
   1:       frame->Destroy();
   1:       frame = nsnull;
   1:       ++lineOffset;
   1:     }
   1:     else {
   1:       propTable->SetProperty(frame, nsGkAtoms::embeddingLevel,
   1:                              NS_INT32_TO_PTR(embeddingLevel), nsnull, nsnull);
   1:       propTable->SetProperty(frame, nsGkAtoms::baseLevel,
   1:                              NS_INT32_TO_PTR(paraLevel), nsnull, nsnull);
   1:       if (isTextFrame) {
   1:         PRInt32 typeLimit = PR_MIN(logicalLimit, lineOffset + fragmentLength);
   1:         CalculateCharType(lineOffset, typeLimit, logicalLimit, runLength,
   1:                            runCount, charType, prevType);
   1:         // IBMBIDI - Egypt - Start
   1:         propTable->SetProperty(frame, nsGkAtoms::charType,
   1:                                NS_INT32_TO_PTR(charType), nsnull, nsnull);
   1:         // IBMBIDI - Egypt - End
   1: 
   1:         if ( (runLength > 0) && (runLength < fragmentLength) ) {
   1:           if (!EnsureBidiContinuation(aPresContext, frame,
   1:                                       &nextBidi, frameIndex) ) {
   1:             break;
   1:           }
   1:           if (lineNeedsUpdate) {
5421:             if (AdvanceLineIteratorToFrame(frame, aBlockFrame, line,
5421:                                            prevFrame, endLines)) {
   1:               lineNeedsUpdate = PR_FALSE;
   1:             }
5421:           }
   1:           line->MarkDirty();
   1:           frame->AdjustOffsetsForBidi(contentOffset, contentOffset + runLength);
   1:           frame = nextBidi;
   1:           contentOffset += runLength;
   1:         } // if (runLength < fragmentLength)
   1:         else {
   1:           frame->AdjustOffsetsForBidi(contentOffset, contentOffset + fragmentLength);
   1:           PRInt32 newIndex = 0;
   1:           mContentToFrameIndex.Get(content, &newIndex);
   1:           if (newIndex > frameIndex) {
   1:             RemoveBidiContinuation(aPresContext, frame,
   1:                                    frameIndex, newIndex, temp);
   1:             if (lineNeedsUpdate) {
5421:               if (AdvanceLineIteratorToFrame(frame, aBlockFrame, line,
5421:                                              prevFrame, endLines)) {
   1:                 lineNeedsUpdate = PR_FALSE;
   1:               }
5421:             }
   1:             line->MarkDirty();
   1:             runLength -= temp;
   1:             fragmentLength -= temp;
   1:             lineOffset += temp;
   1:             frameIndex = newIndex;
   1:           }
   1:         }
   1:       } // isTextFrame
   1:       else {
   1:         ++lineOffset;
   1:       }
   1:     } // not directionalFrame
   1:     temp = runLength;
   1:     runLength -= fragmentLength;
   1:     fragmentLength -= temp;
   1: 
   1:     // If the frame is at the end of a run, split all ancestor inlines that need splitting.
   1:     if (frame && fragmentLength <= 0 && runLength <= 0) {
   1:       // As long as we're on the last sibling, the parent doesn't have to be split.
   1:       nsIFrame* child = frame;
   1:       nsIFrame* parent = frame->GetParent();
   1:       while (parent &&
   1:              IsBidiSplittable(parent) &&
   1:              !child->GetNextSibling()) {
   1:         child = parent;
   1:         parent = child->GetParent();
   1:       }
   1:       if (parent && IsBidiSplittable(parent))
   1:         SplitInlineAncestors(aPresContext, child);
   1:     }
   1:   } // for
   1:   return mSuccess;
   1: }
   1: 
   1: // Should this frame be treated as a leaf (e.g. when building mLogicalArray)?
   1: PRBool IsBidiLeaf(nsIFrame* aFrame) {
   1:   nsIFrame* kid = aFrame->GetFirstChild(nsnull);
   1:   return !kid
5421:     || !aFrame->IsFrameOfType(nsIFrame::eBidiInlineContainer);
   1: }
   1: 
   1: nsresult
   1: nsBidiPresUtils::InitLogicalArray(nsPresContext* aPresContext,
   1:                                   nsIFrame*       aCurrentFrame,
   1:                                   nsIFrame*       aNextInFlow,
   1:                                   PRBool          aAddMarkers)
   1: {
   1:   nsresult              res = NS_OK;
   1: 
   1:   nsIPresShell* shell = aPresContext->PresShell();
   1:   nsStyleContext* styleContext;
   1: 
5421:   for (nsIFrame* childFrame = aCurrentFrame;
5421:        childFrame && childFrame != aNextInFlow;
5421:        childFrame = childFrame->GetNextSibling()) {
5421: 
5421:     nsIFrame* frame = (nsGkAtoms::placeholderFrame == childFrame->GetType()) ?
5421:       nsPlaceholderFrame::GetRealFrameFor(childFrame) : childFrame;
   1: 
1152:     PRUnichar ch = 0;
   1:     if (aAddMarkers &&
1152:         frame->IsFrameOfType(nsIFrame::eBidiInlineContainer)) {
   1:       const nsStyleVisibility* vis = frame->GetStyleVisibility();
   1:       const nsStyleTextReset* text = frame->GetStyleTextReset();
   1:       switch (text->mUnicodeBidi) {
   1:         case NS_STYLE_UNICODE_BIDI_NORMAL:
   1:           break;
   1:         case NS_STYLE_UNICODE_BIDI_EMBED:
   1:           styleContext = frame->GetStyleContext();
   1: 
   1:           if (NS_STYLE_DIRECTION_RTL == vis->mDirection) {
1152:             ch = kRLE;
   1:           }
   1:           else if (NS_STYLE_DIRECTION_LTR == vis->mDirection) {
1152:             ch = kLRE;
   1:           }
   1:           break;
   1:         case NS_STYLE_UNICODE_BIDI_OVERRIDE:
   1:           styleContext = frame->GetStyleContext();
   1: 
   1:           if (NS_STYLE_DIRECTION_RTL == vis->mDirection) {
1152:             ch = kRLO;
   1:           }
   1:           else if (NS_STYLE_DIRECTION_LTR == vis->mDirection) {
1152:             ch = kLRO;
   1:           }
   1:           break;
   1:       }
   1: 
   1:       // Create a directional frame before the first frame of an
   1:       // element specifying embedding or override
1152:       if (ch != 0 && !frame->GetPrevContinuation()) {
1152:         nsIFrame* dirFrame = NS_NewDirectionalFrame(shell, styleContext, ch);
1152:         if (dirFrame) {
1152:           mLogicalFrames.AppendElement(dirFrame);
1152:         }
   1:       }
   1:     }
   1: 
   1:     if (IsBidiLeaf(frame)) {
   1:       /* Bidi leaf frame: add the frame to the mLogicalFrames array,
   1:        * and add its index to the mContentToFrameIndex hashtable. This
   1:        * will be used in RemoveBidiContinuation() to identify the last
   1:        * frame in the array with a given content.
   1:        */
   1:       nsIContent* content = frame->GetContent();
   1:       if (content) {
   1:         mContentToFrameIndex.Put(content, mLogicalFrames.Count());
   1:       }
   1:       mLogicalFrames.AppendElement(frame);
   1:     }
   1:     else {
   1:       nsIFrame* kid = frame->GetFirstChild(nsnull);
   1:       res = InitLogicalArray(aPresContext, kid, aNextInFlow, aAddMarkers);
   1:     }
   1: 
   1:     // If the element is attributed by dir, indicate direction pop (add PDF frame)
1152:     if (ch != 0 && !frame->GetNextContinuation()) {
   1:       // Create a directional frame after the last frame of an
   1:       // element specifying embedding or override
1152:       nsIFrame* dirFrame = NS_NewDirectionalFrame(shell, styleContext, kPDF);
1152:       if (dirFrame) {
1152:         mLogicalFrames.AppendElement(dirFrame);
   1:       }
   1:     }
   1:   } // for
   1:   return res;       
   1: }
   1: 
   1: void
   1: nsBidiPresUtils::CreateBlockBuffer(nsPresContext* aPresContext)
   1: {
   1:   mBuffer.SetLength(0);
   1: 
   1:   nsIFrame*                 frame;
   1:   nsIContent*               prevContent = nsnull;
   1:   PRUint32                  i;
   1:   PRUint32                  count = mLogicalFrames.Count();
   1: 
   1:   for (i = 0; i < count; i++) {
   1:     frame = (nsIFrame*) (mLogicalFrames[i]);
   1:     nsIAtom* frameType = frame->GetType();
   1: 
   1:     if (nsGkAtoms::textFrame == frameType) {
   1:       nsIContent* content = frame->GetContent();
   1:       if (!content) {
   1:         mSuccess = NS_OK;
   1:         break;
   1:       }
   1:       if (content == prevContent) {
   1:         continue;
   1:       }
   1:       prevContent = content;
   1:       content->AppendTextTo(mBuffer);
   1:     }
   1:     else if (nsGkAtoms::brFrame == frameType) { // break frame
   1:       // Append line separator
3745:       mBuffer.Append(kLineSeparator);
   1:     }
   1:     else if (nsGkAtoms::directionalFrame == frameType) {
3745:       nsDirectionalFrame* dirFrame = static_cast<nsDirectionalFrame*>(frame);
   1:       mBuffer.Append(dirFrame->GetChar());
   1:     }
   1:     else { // not text frame
   1:       // See the Unicode Bidi Algorithm:
   1:       // "...inline objects (such as graphics) are treated as if they are ... U+FFFC"
3745:       mBuffer.Append(kObjectSubstitute);
   1:     }
   1:   }
   1:   // XXX: TODO: Handle preformatted text ('\n')
   1:   mBuffer.ReplaceChar("\t\r\n", kSpace);
   1: }
   1: 
   1: void
   1: nsBidiPresUtils::ReorderFrames(nsPresContext*       aPresContext,
   1:                                nsIRenderingContext* aRendContext,
   1:                                nsIFrame*            aFirstFrameOnLine,
   1:                                PRInt32              aNumFramesOnLine)
   1: {
   1:   // If this line consists of a line frame, reorder the line frame's children.
   1:   if (aFirstFrameOnLine->GetType() == nsGkAtoms::lineFrame) {
   1:     aFirstFrameOnLine = aFirstFrameOnLine->GetFirstChild(nsnull);
   1:     if (!aFirstFrameOnLine)
   1:       return;
   1:     // All children of the line frame are on the first line. Setting aNumFramesOnLine
   1:     // to -1 makes InitLogicalArrayFromLine look at all of them.
   1:     aNumFramesOnLine = -1;
   1:   }
   1: 
   1:   InitLogicalArrayFromLine(aFirstFrameOnLine, aNumFramesOnLine);
   1: 
   1:   PRBool isReordered;
   1:   PRBool hasRTLFrames;
   1:   Reorder(isReordered, hasRTLFrames);
   1:   RepositionInlineFrames(aPresContext, aRendContext, aFirstFrameOnLine, isReordered);
   1: }
   1: 
   1: nsresult
   1: nsBidiPresUtils::Reorder(PRBool& aReordered, PRBool& aHasRTLFrames)
   1: {
   1:   aReordered = PR_FALSE;
   1:   aHasRTLFrames = PR_FALSE;
   1:   PRInt32 count = mLogicalFrames.Count();
   1: 
   1:   if (mArraySize < count) {
   1:     mArraySize = count << 1;
   1:     if (mLevels) {
   1:       delete[] mLevels;
   1:       mLevels = nsnull;
   1:     }
   1:     if (mIndexMap) {
   1:       delete[] mIndexMap;
   1:       mIndexMap = nsnull;
   1:     }
   1:   }
   1:   if (!mLevels) {
   1:     mLevels = new PRUint8[mArraySize];
   1:     if (!mLevels) {
   1:       return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:   }
   1:   memset(mLevels, 0, sizeof(PRUint8) * mArraySize);
   1: 
   1:   nsIFrame* frame;
   1:   PRInt32   i;
   1: 
   1:   for (i = 0; i < count; i++) {
   1:     frame = (nsIFrame*) (mLogicalFrames[i]);
   1:     mLevels[i] = GetFrameEmbeddingLevel(frame);
   1:     if (mLevels[i] & 1) {
   1:       aHasRTLFrames = PR_TRUE;
   1:     }      
   1:   }
   1:   if (!mIndexMap) {
   1:     mIndexMap = new PRInt32[mArraySize];
   1:   }
   1:   if (!mIndexMap) {
   1:     mSuccess = NS_ERROR_OUT_OF_MEMORY;
   1:   }
   1:   else {
   1:     memset(mIndexMap, 0, sizeof(PRUint32) * mArraySize);
   1: 
   1:     mSuccess = mBidiEngine->ReorderVisual(mLevels, count, mIndexMap);
   1: 
   1:     if (NS_SUCCEEDED(mSuccess) ) {
   1:       mVisualFrames.Clear();
   1: 
   1:       for (i = 0; i < count; i++) {
   1:         mVisualFrames.AppendElement(mLogicalFrames[mIndexMap[i]]);
   1:         if (i != mIndexMap[i]) {
   1:           aReordered = PR_TRUE;
   1:         }
   1:       }
   1:     } // NS_SUCCEEDED(mSuccess)
   1:   } // indexMap
   1: 
   1:   if (NS_FAILED(mSuccess) ) {
   1:     aReordered = PR_FALSE;
   1:   }
   1:   return mSuccess;
   1: }
   1: 
   1: nsBidiLevel
   1: nsBidiPresUtils::GetFrameEmbeddingLevel(nsIFrame* aFrame)
   1: {
   1:   nsIFrame* firstLeaf = aFrame;
   1:   while (!IsBidiLeaf(firstLeaf)) {
   1:     firstLeaf = firstLeaf->GetFirstChild(nsnull);
   1:   }
   1:   return NS_GET_EMBEDDING_LEVEL(firstLeaf);
   1: }
   1: 
   1: nsBidiLevel
   1: nsBidiPresUtils::GetFrameBaseLevel(nsIFrame* aFrame)
   1: {
   1:   nsIFrame* firstLeaf = aFrame;
   1:   while (!IsBidiLeaf(firstLeaf)) {
   1:     firstLeaf = firstLeaf->GetFirstChild(nsnull);
   1:   }
   1:   return NS_GET_BASE_LEVEL(firstLeaf);
   1: }
   1: 
   1: void
   1: nsBidiPresUtils::IsLeftOrRightMost(nsIFrame*              aFrame,
   1:                                    nsContinuationStates*  aContinuationStates,
   1:                                    PRBool&                aIsLeftMost /* out */,
   1:                                    PRBool&                aIsRightMost /* out */) const
   1: {
   1:   const nsStyleVisibility* vis = aFrame->GetStyleVisibility();
   1:   PRBool isLTR = (NS_STYLE_DIRECTION_LTR == vis->mDirection);
   1: 
   1:   /*
   1:    * Since we lay out frames from left to right (in both LTR and RTL), visiting a
   1:    * frame with 'mFirstVisualFrame == nsnull', means it's the first appearance of
   1:    * one of its continuation chain frames on the line.
   1:    * To determine if it's the last visual frame of its continuation chain on the line
   1:    * or not, we count the number of frames of the chain on the line, and then reduce
   1:    * it when we lay out a frame of the chain. If this value becomes 1 it means
   1:    * that it's the last visual frame of its continuation chain on this line.
   1:    */
   1: 
   1:   nsFrameContinuationState* frameState = aContinuationStates->GetEntry(aFrame);
   1:   nsFrameContinuationState* firstFrameState;
   1: 
   1:   if (!frameState->mFirstVisualFrame) {
   1:     // aFrame is the first visual frame of its continuation chain
   1:     nsFrameContinuationState* contState;
   1:     nsIFrame* frame;
   1: 
   1:     frameState->mFrameCount = 1;
   1:     frameState->mFirstVisualFrame = aFrame;
   1: 
   1:     /**
   1:      * Traverse continuation chain of aFrame in both backward and forward
   1:      * directions while the frames are on this line. Count the frames and
   1:      * set their mFirstVisualFrame to aFrame.
   1:      */
   1:     // Traverse continuation chain backward
   1:     for (frame = aFrame->GetPrevContinuation();
   1:          frame && (contState = aContinuationStates->GetEntry(frame));
   1:          frame = frame->GetPrevContinuation()) {
   1:       frameState->mFrameCount++;
   1:       contState->mFirstVisualFrame = aFrame;
   1:     }
   1:     frameState->mHasContOnPrevLines = (frame != nsnull);
   1: 
   1:     // Traverse continuation chain forward
   1:     for (frame = aFrame->GetNextContinuation();
   1:          frame && (contState = aContinuationStates->GetEntry(frame));
   1:          frame = frame->GetNextContinuation()) {
   1:       frameState->mFrameCount++;
   1:       contState->mFirstVisualFrame = aFrame;
   1:     }
   1:     frameState->mHasContOnNextLines = (frame != nsnull);
   1: 
   1:     aIsLeftMost = isLTR ? !frameState->mHasContOnPrevLines
   1:                         : !frameState->mHasContOnNextLines;
   1:     firstFrameState = frameState;
   1:   } else {
   1:     // aFrame is not the first visual frame of its continuation chain
   1:     aIsLeftMost = PR_FALSE;
   1:     firstFrameState = aContinuationStates->GetEntry(frameState->mFirstVisualFrame);
   1:   }
   1: 
   1:   aIsRightMost = (firstFrameState->mFrameCount == 1) &&
   1:                  (isLTR ? !firstFrameState->mHasContOnNextLines
   1:                         : !firstFrameState->mHasContOnPrevLines);
   1: 
   1:   // Reduce number of remaining frames of the continuation chain on the line.
   1:   firstFrameState->mFrameCount--;
   1: }
   1: 
   1: void
   1: nsBidiPresUtils::RepositionFrame(nsIFrame*              aFrame,
   1:                                  PRBool                 aIsOddLevel,
   1:                                  nscoord&               aLeft,
   1:                                  nsContinuationStates*  aContinuationStates) const
   1: {
   1:   if (!aFrame)
   1:     return;
   1: 
   1:   PRBool isLeftMost, isRightMost;
   1:   IsLeftOrRightMost(aFrame,
   1:                     aContinuationStates,
   1:                     isLeftMost /* out */,
   1:                     isRightMost /* out */);
   1: 
   1:   nsIFrame* testFrame;
   1:   aFrame->QueryInterface(kInlineFrameCID, (void**)&testFrame);
   1: 
   1:   if (testFrame) {
   1:     aFrame->AddStateBits(NS_INLINE_FRAME_BIDI_VISUAL_STATE_IS_SET);
   1: 
   1:     if (isLeftMost)
   1:       aFrame->AddStateBits(NS_INLINE_FRAME_BIDI_VISUAL_IS_LEFT_MOST);
   1:     else
   1:       aFrame->RemoveStateBits(NS_INLINE_FRAME_BIDI_VISUAL_IS_LEFT_MOST);
   1: 
   1:     if (isRightMost)
   1:       aFrame->AddStateBits(NS_INLINE_FRAME_BIDI_VISUAL_IS_RIGHT_MOST);
   1:     else
   1:       aFrame->RemoveStateBits(NS_INLINE_FRAME_BIDI_VISUAL_IS_RIGHT_MOST);
   1:   }
   1:   nsMargin margin;
   1:   aFrame->GetMargin(margin);
   1:   if (isLeftMost)
   1:     aLeft += margin.left;
   1: 
   1:   nscoord start = aLeft;
   1: 
   1:   if (!IsBidiLeaf(aFrame))
   1:   {
   1:     nscoord x = 0;
   1:     nsMargin borderPadding;
   1:     aFrame->GetBorderAndPadding(borderPadding);
   1:     if (isLeftMost) {
   1:       x += borderPadding.left;
   1:     }
   1: 
   1:     // If aIsOddLevel is true, so we need to traverse the child list
   1:     // in reverse order, to make it O(n) we store the list locally and
   1:     // iterate the list reversely
   1:     nsVoidArray childList;
   1:     nsIFrame *frame = aFrame->GetFirstChild(nsnull);
   1:     if (frame && aIsOddLevel) {
   1:       childList.AppendElement(nsnull);
   1:       while (frame) {
   1:         childList.AppendElement(frame);
   1:         frame = frame->GetNextSibling();
   1:       }
   1:       frame = (nsIFrame*)childList[childList.Count() - 1];
   1:     }
   1: 
   1:     // Reposition the child frames
   1:     PRInt32 index = 0;
   1:     while (frame) {
   1:       RepositionFrame(frame,
   1:                       aIsOddLevel,
   1:                       x,
   1:                       aContinuationStates);
   1:       index++;
   1:       frame = aIsOddLevel ?
   1:                 (nsIFrame*)childList[childList.Count() - index - 1] :
   1:                 frame->GetNextSibling();
   1:     }
   1: 
   1:     if (isRightMost) {
   1:       x += borderPadding.right;
   1:     }
   1:     aLeft += x;
   1:   } else {
   1:     aLeft += aFrame->GetSize().width;
   1:   }
   1:   nsRect rect = aFrame->GetRect();
   1:   aFrame->SetRect(nsRect(start, rect.y, aLeft - start, rect.height));
   1: 
   1:   if (isRightMost)
   1:     aLeft += margin.right;
   1: }
   1: 
   1: void
   1: nsBidiPresUtils::InitContinuationStates(nsIFrame*              aFrame,
   1:                                         nsContinuationStates*  aContinuationStates) const
   1: {
   1:   nsFrameContinuationState* state = aContinuationStates->PutEntry(aFrame);
   1:   state->mFirstVisualFrame = nsnull;
   1:   state->mFrameCount = 0;
   1: 
   1:   if (!IsBidiLeaf(aFrame)) {
   1:     // Continue for child frames
   1:     nsIFrame* frame;
   1:     for (frame = aFrame->GetFirstChild(nsnull);
   1:          frame;
   1:          frame = frame->GetNextSibling()) {
   1:       InitContinuationStates(frame,
   1:                              aContinuationStates);
   1:     }
   1:   }
   1: }
   1: 
   1: void
   1: nsBidiPresUtils::RepositionInlineFrames(nsPresContext*       aPresContext,
   1:                                         nsIRenderingContext* aRendContext,
   1:                                         nsIFrame*            aFirstChild,
   1:                                         PRBool               aReordered) const
   1: {
   1:   nsMargin margin;
   1:   const nsStyleVisibility* vis = aFirstChild->GetStyleVisibility();
   1:   PRBool isLTR = (NS_STYLE_DIRECTION_LTR == vis->mDirection);
   1:   nscoord leftSpace = 0;
   1: 
   1:   aFirstChild->GetMargin(margin);
   1:   if (!aFirstChild->GetPrevContinuation())
   1:     leftSpace = isLTR ? margin.left : margin.right;
   1: 
   1:   nscoord left = aFirstChild->GetPosition().x - leftSpace;
   1:   nsIFrame* frame;
   1:   PRInt32 count = mVisualFrames.Count();
   1:   PRInt32 index;
   1:   nsContinuationStates continuationStates;
   1: 
   1:   continuationStates.Init();
   1: 
   1:   // Initialize continuation states to (nsnull, 0) for
   1:   // each frame on the line.
   1:   for (index = 0; index < count; index++) {
   1:     InitContinuationStates((nsIFrame*)mVisualFrames[index],
   1:                            &continuationStates);
   1:   }
   1: 
   1:   // Reposition frames in visual order
   1:   for (index = 0; index < count; index++) {
   1:     frame = (nsIFrame*) (mVisualFrames[index]);
   1:     RepositionFrame(frame,
   1:                     (mLevels[mIndexMap[index]] & 1),
   1:                     left,
   1:                     &continuationStates);
   1:   } // for
   1: }
   1: 
   1: void 
   1: nsBidiPresUtils::InitLogicalArrayFromLine(nsIFrame* aFirstFrameOnLine,
   1:                                           PRInt32   aNumFramesOnLine) {
   1:   mLogicalFrames.Clear();
   1:   for (nsIFrame* frame = aFirstFrameOnLine;
   1:        frame && aNumFramesOnLine--;
   1:        frame = frame->GetNextSibling()) {
   1:     mLogicalFrames.AppendElement(frame);
   1:   }
   1: }
   1: 
   1: PRBool
   1: nsBidiPresUtils::CheckLineOrder(nsIFrame*  aFirstFrameOnLine,
   1:                                 PRInt32    aNumFramesOnLine,
   1:                                 nsIFrame** aFirstVisual,
   1:                                 nsIFrame** aLastVisual)
   1: {
   1:   InitLogicalArrayFromLine(aFirstFrameOnLine, aNumFramesOnLine);
   1:   
   1:   PRBool isReordered;
   1:   PRBool hasRTLFrames;
   1:   Reorder(isReordered, hasRTLFrames);
   1:   PRInt32 count = mLogicalFrames.Count();
   1:   
   1:   if (aFirstVisual) {
   1:     *aFirstVisual = (nsIFrame*)mVisualFrames[0];
   1:   }
   1:   if (aLastVisual) {
   1:     *aLastVisual = (nsIFrame*)mVisualFrames[count-1];
   1:   }
   1:   
   1:   // If there's an RTL frame, assume the line is reordered
   1:   return isReordered || hasRTLFrames;
   1: }
   1: 
   1: nsIFrame*
   1: nsBidiPresUtils::GetFrameToRightOf(const nsIFrame*  aFrame,
   1:                                    nsIFrame*        aFirstFrameOnLine,
   1:                                    PRInt32          aNumFramesOnLine)
   1: {
   1:   InitLogicalArrayFromLine(aFirstFrameOnLine, aNumFramesOnLine);
   1:   
   1:   PRBool isReordered;
   1:   PRBool hasRTLFrames;
   1:   Reorder(isReordered, hasRTLFrames);
   1:   PRInt32 count = mVisualFrames.Count();
   1: 
   1:   if (aFrame == nsnull)
   1:     return (nsIFrame*)mVisualFrames[0];
   1:   
   1:   for (PRInt32 i = 0; i < count - 1; i++) {
   1:     if ((nsIFrame*)mVisualFrames[i] == aFrame) {
   1:       return (nsIFrame*)mVisualFrames[i+1];
   1:     }
   1:   }
   1:   
   1:   return nsnull;
   1: }
   1: 
   1: nsIFrame*
   1: nsBidiPresUtils::GetFrameToLeftOf(const nsIFrame*  aFrame,
   1:                                   nsIFrame*        aFirstFrameOnLine,
   1:                                   PRInt32          aNumFramesOnLine)
   1: {
   1:   InitLogicalArrayFromLine(aFirstFrameOnLine, aNumFramesOnLine);
   1:   
   1:   PRBool isReordered;
   1:   PRBool hasRTLFrames;
   1:   Reorder(isReordered, hasRTLFrames);
   1:   PRInt32 count = mVisualFrames.Count();
   1:   
   1:   if (aFrame == nsnull)
   1:     return (nsIFrame*)mVisualFrames[count-1];
   1:   
   1:   for (PRInt32 i = 1; i < count; i++) {
   1:     if ((nsIFrame*)mVisualFrames[i] == aFrame) {
   1:       return (nsIFrame*)mVisualFrames[i-1];
   1:     }
   1:   }
   1:   
   1:   return nsnull;
   1: }
   1: 
   1: PRBool
   1: nsBidiPresUtils::EnsureBidiContinuation(nsPresContext* aPresContext,
   1:                                         nsIFrame*       aFrame,
   1:                                         nsIFrame**      aNewFrame,
   1:                                         PRInt32&        aFrameIndex)
   1: {
   1:   NS_PRECONDITION(aNewFrame, "null OUT ptr");
   1:   NS_PRECONDITION(aFrame, "aFrame is null");
   1: 
   1:   *aNewFrame = nsnull;
   1:   nsBidiLevel embeddingLevel = NS_GET_EMBEDDING_LEVEL(aFrame);
   1:   nsBidiLevel baseLevel = NS_GET_BASE_LEVEL(aFrame);
   1:   nsCharType charType = (nsCharType)NS_PTR_TO_INT32(aFrame->GetProperty(nsGkAtoms::charType));
   1:   
   1:   // Skip fluid continuations
   1:   while (aFrameIndex + 1 < mLogicalFrames.Count()) {
   1:     nsIFrame* frame = (nsIFrame*)mLogicalFrames[aFrameIndex + 1];
   1:     if (frame->GetPrevInFlow() != aFrame) {
   1:       // If we found a non-fluid continuation, use it
   1:       if (frame->GetPrevContinuation() == aFrame) {
   1:         *aNewFrame = frame;
   1:         aFrameIndex++;
   1:       }
   1:       break;
   1:     }
   1:     frame->SetProperty(nsGkAtoms::embeddingLevel, NS_INT32_TO_PTR(embeddingLevel));
   1:     frame->SetProperty(nsGkAtoms::baseLevel, NS_INT32_TO_PTR(baseLevel));
   1:     frame->SetProperty(nsGkAtoms::charType, NS_INT32_TO_PTR(charType));
   1:     frame->AddStateBits(NS_FRAME_IS_BIDI);
   1:     aFrameIndex++;
   1:     aFrame = frame;
   1:   }
   1:   
   1:   if (!*aNewFrame) {
   1:     mSuccess = CreateBidiContinuation(aPresContext, aFrame, aNewFrame);
   1:     if (NS_FAILED(mSuccess) ) {
   1:       return PR_FALSE;
   1:     }
   1:   }
   1: 
   1:   return PR_TRUE;
   1: }
   1: 
   1: void
   1: nsBidiPresUtils::RemoveBidiContinuation(nsPresContext* aPresContext,
   1:                                         nsIFrame*       aFrame,
   1:                                         PRInt32         aFirstIndex,
   1:                                         PRInt32         aLastIndex,
   1:                                         PRInt32&        aOffset) const
   1: {
   1:   aOffset = 0;
   1: 
   1:   nsresult rv;
   1:   nsBidiLevel embeddingLevel = (nsCharType)NS_PTR_TO_INT32(aFrame->GetProperty(nsGkAtoms::embeddingLevel, &rv));
   1:   NS_ASSERTION(NS_SUCCEEDED(rv), "embeddingLevel attribute missing from aFrame");
   1:   nsBidiLevel baseLevel = (nsCharType)NS_PTR_TO_INT32(aFrame->GetProperty(nsGkAtoms::baseLevel, &rv));
   1:   NS_ASSERTION(NS_SUCCEEDED(rv), "baseLevel attribute missing from aFrame");
   1:   nsCharType charType = (nsCharType)NS_PTR_TO_INT32(aFrame->GetProperty(nsGkAtoms::charType, &rv));
   1:   NS_ASSERTION(NS_SUCCEEDED(rv), "charType attribute missing from aFrame");
   1:   
   1:   for (PRInt32 index = aFirstIndex + 1; index <= aLastIndex; index++) {
   1:     nsIFrame* frame = (nsIFrame*) mLogicalFrames[index];
   1:     if (nsGkAtoms::directionalFrame == frame->GetType()) {
   1:       frame->Destroy();
   1:       ++aOffset;
   1:     }
   1:     else {
   1:       // Make the frame and its continuation ancestors fluid,
   1:       // so they can be reused or deleted by normal reflow code
   1:       frame->SetProperty(nsGkAtoms::embeddingLevel, NS_INT32_TO_PTR(embeddingLevel));
   1:       frame->SetProperty(nsGkAtoms::baseLevel, NS_INT32_TO_PTR(baseLevel));
   1:       frame->SetProperty(nsGkAtoms::charType, NS_INT32_TO_PTR(charType));
   1:       frame->AddStateBits(NS_FRAME_IS_BIDI);
   1:       while (frame) {
   1:         nsIFrame* prev = frame->GetPrevContinuation();
   1:         if (prev) {
   1:           NS_ASSERTION (!frame->GetPrevInFlow() || frame->GetPrevInFlow() == prev, 
   1:                         "prev-in-flow is not prev continuation!");
   1:           frame->SetPrevInFlow(prev);
   1: 
   1:           NS_ASSERTION (!prev->GetNextInFlow() || prev->GetNextInFlow() == frame,
   1:                         "next-in-flow is not next continuation!");
   1:           prev->SetNextInFlow(frame);
   1: 
   1:           frame = frame->GetParent();
   1:         } else {
   1:           break;
   1:         }
   1:       }
   1:     }
   1:   }
   1: }
   1: 
   1: nsresult
   1: nsBidiPresUtils::FormatUnicodeText(nsPresContext*  aPresContext,
   1:                                    PRUnichar*       aText,
   1:                                    PRInt32&         aTextLength,
   1:                                    nsCharType       aCharType,
   1:                                    PRBool           aIsOddLevel,
   1:                                    PRBool           aIsBidiSystem,
   1:                                    PRBool           aIsNewTextRunSystem)
   1: {
   1:   NS_ASSERTION(aIsOddLevel == 0 || aIsOddLevel == 1, "aIsOddLevel should be 0 or 1");
   1:   nsresult rv = NS_OK;
   1:   // ahmed 
   1:   //adjusted for correct numeral shaping  
   1:   PRUint32 bidiOptions = aPresContext->GetBidi();
   1:   switch (GET_BIDI_OPTION_NUMERAL(bidiOptions)) {
   1: 
   1:     case IBMBIDI_NUMERAL_HINDI:
   1:       HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_HINDI);
   1:       break;
   1: 
   1:     case IBMBIDI_NUMERAL_ARABIC:
   1:       HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_ARABIC);
   1:       break;
   1: 
   1:     case IBMBIDI_NUMERAL_REGULAR:
   1: 
   1:       switch (aCharType) {
   1: 
   1:         case eCharType_EuropeanNumber:
   1:           HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_ARABIC);
   1:           break;
   1: 
   1:         case eCharType_ArabicNumber:
   1:           HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_HINDI);
   1:           break;
   1: 
   1:         default:
   1:           break;
   1:       }
   1:       break;
   1:       
   1:     case IBMBIDI_NUMERAL_HINDICONTEXT:
   1:       if ( ( (GET_BIDI_OPTION_DIRECTION(bidiOptions)==IBMBIDI_TEXTDIRECTION_RTL) && (IS_ARABIC_DIGIT (aText[0])) ) || (eCharType_ArabicNumber == aCharType) )
   1:         HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_HINDI);
   1:       else if (eCharType_EuropeanNumber == aCharType)
   1:         HandleNumbers(aText,aTextLength,IBMBIDI_NUMERAL_ARABIC);
   1:       break;
   1: 
   1:     case IBMBIDI_NUMERAL_NOMINAL:
   1:     default:
   1:       break;
   1:   }
   1: 
   1:   PRBool doReverse = PR_FALSE;
   1:   PRBool doShape = PR_FALSE;
   1: 
   1:   if (!aIsNewTextRunSystem) {
   1:     if (aIsBidiSystem) {
   1:       if ( (CHARTYPE_IS_RTL(aCharType)) ^ (aIsOddLevel) )
   1:         doReverse = PR_TRUE;
   1:     }
   1:     else {
   1:       if (aIsOddLevel)
   1:         doReverse = PR_TRUE;
   1:       if (eCharType_RightToLeftArabic == aCharType) 
   1:         doShape = PR_TRUE;
   1:     }
   1:   }
   1: 
   1:   if (doReverse || doShape) {
   1:     PRInt32    newLen;
   1: 
   1:     if (mBuffer.Length() < aTextLength) {
   1:       if (!EnsureStringLength(mBuffer, aTextLength))
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     PRUnichar* buffer = mBuffer.BeginWriting();
   1: 
   1:     if (doReverse) {
   1:       rv = mBidiEngine->WriteReverse(aText, aTextLength, buffer,
   1:                                      NSBIDI_DO_MIRRORING, &newLen);
   1:       if (NS_SUCCEEDED(rv) ) {
   1:         aTextLength = newLen;
   1:         memcpy(aText, buffer, aTextLength * sizeof(PRUnichar) );
   1:       }
   1:     }
   1:     if (doShape) {
   1:       rv = ArabicShaping(aText, aTextLength, buffer, (PRUint32 *)&newLen,
   1:                          PR_FALSE, PR_FALSE);
   1:       if (NS_SUCCEEDED(rv) ) {
   1:         aTextLength = newLen;
   1:         memcpy(aText, buffer, aTextLength * sizeof(PRUnichar) );
   1:       }
   1:     }
   1:   }
   1:   StripBidiControlCharacters(aText, aTextLength);
   1:   return rv;
   1: }
   1: 
   1: void
   1: nsBidiPresUtils::StripBidiControlCharacters(PRUnichar* aText,
   1:                                             PRInt32&   aTextLength) const
   1: {
   1:   if ( (nsnull == aText) || (aTextLength < 1) ) {
   1:     return;
   1:   }
   1: 
   1:   PRInt32 stripLen = 0;
   1: 
   1:   for (PRInt32 i = 0; i < aTextLength; i++) {
   1:     // XXX: This silently ignores surrogate characters.
   1:     //      As of Unicode 4.0, all Bidi control characters are within the BMP.
2997:     if (IsBidiControl((PRUint32)aText[i])) {
   1:       ++stripLen;
   1:     }
   1:     else {
   1:       aText[i - stripLen] = aText[i];
   1:     }
   1:   }
   1:   aTextLength -= stripLen;
   1: }
   1:  
   1: #if 0 // XXX: for the future use ???
   1: void
   1: RemoveDiacritics(PRUnichar* aText,
   1:                  PRInt32&   aTextLength)
   1: {
   1:   if (aText && (aTextLength > 0) ) {
   1:     PRInt32 offset = 0;
   1: 
   1:     for (PRInt32 i = 0; i < aTextLength && aText[i]; i++) {
   1:       if (IS_BIDI_DIACRITIC(aText[i]) ) {
   1:         ++offset;
   1:         continue;
   1:       }
   1:       aText[i - offset] = aText[i];
   1:     }
   1:     aTextLength = i - offset;
   1:     aText[aTextLength] = 0;
   1:   }
   1: }
   1: #endif
   1: 
   1: void
   1: nsBidiPresUtils::CalculateCharType(PRInt32& aOffset,
   1:                                    PRInt32  aCharTypeLimit,
   1:                                    PRInt32& aRunLimit,
   1:                                    PRInt32& aRunLength,
   1:                                    PRInt32& aRunCount,
   1:                                    PRUint8& aCharType,
   1:                                    PRUint8& aPrevCharType) const
   1: 
   1: {
   1:   PRBool     strongTypeFound = PR_FALSE;
   1:   PRInt32    offset;
   1:   nsCharType charType;
   1: 
   1:   aCharType = eCharType_OtherNeutral;
   1: 
   1:   for (offset = aOffset; offset < aCharTypeLimit; offset++) {
   1:     // Make sure we give RTL chartype to all characters that would be classified
   1:     // as Right-To-Left by a bidi platform.
   1:     // (May differ from the UnicodeData, eg we set RTL chartype to some NSMs.)
   1:     if (IS_HEBREW_CHAR(mBuffer[offset]) ) {
   1:       charType = eCharType_RightToLeft;
   1:     }
   1:     else if (IS_ARABIC_ALPHABETIC(mBuffer[offset]) ) {
   1:       charType = eCharType_RightToLeftArabic;
   1:     }
   1:     else {
   1:       mBidiEngine->GetCharTypeAt(offset, &charType);
   1:     }
   1: 
   1:     if (!CHARTYPE_IS_WEAK(charType) ) {
   1: 
   1:       if (strongTypeFound
   1:           && (charType != aPrevCharType)
   1:           && (CHARTYPE_IS_RTL(charType) || CHARTYPE_IS_RTL(aPrevCharType) ) ) {
   1:         // Stop at this point to ensure uni-directionality of the text
   1:         // (from platform's point of view).
   1:         // Also, don't mix Arabic and Hebrew content (since platform may
   1:         // provide BIDI support to one of them only).
   1:         aRunLength = offset - aOffset;
   1:         aRunLimit = offset;
   1:         ++aRunCount;
   1:         break;
   1:       }
   1: 
   1:       if ( (eCharType_RightToLeftArabic == aPrevCharType
   1:             || eCharType_ArabicNumber == aPrevCharType)
   1:           && eCharType_EuropeanNumber == charType) {
   1:         charType = eCharType_ArabicNumber;
   1:       }
   1: 
   1:       // Set PrevCharType to the last strong type in this frame
   1:       // (for correct numeric shaping)
   1:       aPrevCharType = charType;
   1: 
   1:       strongTypeFound = PR_TRUE;
   1:       aCharType = charType;
   1:     }
   1:   }
   1:   aOffset = offset;
   1: }
   1: 
   1: nsresult nsBidiPresUtils::GetBidiEngine(nsBidi** aBidiEngine)
   1: {
   1:   nsresult rv = NS_ERROR_FAILURE;
   1:   if (mBidiEngine) {
   1:     *aBidiEngine = mBidiEngine;
   1:     rv = NS_OK;
   1:   }
   1:   return rv; 
   1: }
   1: 
   1: nsresult nsBidiPresUtils::ProcessText(const PRUnichar*       aText,
   1:                                       PRInt32                aLength,
   1:                                       nsBidiDirection        aBaseDirection,
   1:                                       nsPresContext*         aPresContext,
   1:                                       nsIRenderingContext&   aRenderingContext,
   1:                                       Mode                   aMode,
   1:                                       nscoord                aX,
   1:                                       nscoord                aY,
   1:                                       nsBidiPositionResolve* aPosResolve,
   1:                                       PRInt32                aPosResolveCount,
   1:                                       nscoord*               aWidth)
   1: {
   1:   NS_ASSERTION((aPosResolve == nsnull) != (aPosResolveCount > 0), "Incorrect aPosResolve / aPosResolveCount arguments");
   1: 
   1:   PRInt32 runCount;
   1: 
2068:   mBuffer.Assign(aText, aLength);
   1: 
   1:   nsresult rv = mBidiEngine->SetPara(mBuffer.get(), aLength, aBaseDirection, nsnull);
   1:   if (NS_FAILED(rv))
   1:     return rv;
   1: 
   1:   rv = mBidiEngine->CountRuns(&runCount);
   1:   if (NS_FAILED(rv))
   1:     return rv;
   1: 
   1:   nscoord width, xEndRun, xStartText = aX;
   1:   PRBool isRTL = PR_FALSE;
   1:   nscoord totalWidth = 0;
   1:   PRInt32 i, start, limit, length;
   1:   PRUint32 visualStart = 0;
   1:   PRUint8 charType;
   1:   PRUint8 prevType = eCharType_LeftToRight;
   1:   nsBidiLevel level;
   1: 
   1:   PRUint32 hints = 0;
   1:   aRenderingContext.GetHints(hints);
   1:   PRBool isBidiSystem = (hints & NS_RENDERING_HINT_BIDI_REORDERING);
   1:       
   1:   for(int nPosResolve=0; nPosResolve < aPosResolveCount; ++nPosResolve)
   1:   {
   1:     aPosResolve[nPosResolve].visualIndex = kNotFound;
   1:     aPosResolve[nPosResolve].visualLeftTwips = kNotFound;
   1:   }
   1: 
   1:   for (i = 0; i < runCount; i++) {
   1:     rv = mBidiEngine->GetVisualRun(i, &start, &length, &aBaseDirection);
   1:     if (NS_FAILED(rv))
   1:       return rv;
   1: 
   1:     rv = mBidiEngine->GetLogicalRun(start, &limit, &level);
   1:     if (NS_FAILED(rv))
   1:       return rv;
   1: 
   1:     PRInt32 subRunLength = limit - start;
   1:     PRInt32 lineOffset = start;
   1:     PRInt32 typeLimit = PR_MIN(limit, aLength);
   1:     PRInt32 subRunCount = 1;
   1:     PRInt32 subRunLimit = typeLimit;
   1: 
   1:     /*
   1:      * If |level| is even, i.e. the direction of the run is left-to-right, we
   1:      * render the subruns from left to right and increment the x-coordinate
   1:      * |aX| by the width of each subrun after rendering.
   1:      *
   1:      * If |level| is odd, i.e. the direction of the run is right-to-left, we
   1:      * render the subruns from right to left. We begin by incrementing |aX| by
   1:      * the width of the whole run, and then decrement it by the width of each
   1:      * subrun before rendering. After rendering all the subruns, we restore the
   1:      * x-coordinate of the end of the run for the start of the next run.
   1:      */
   1:     aRenderingContext.SetTextRunRTL(level & 1);
   1: 
   1:     if (level & 1) {
   1:       aRenderingContext.GetWidth(aText + start, subRunLength, width, nsnull);
   1:       aX += width;
   1:       xEndRun = aX;
   1:     }
   1: 
   1:     while (subRunCount > 0) {
   1:       // CalculateCharType can increment subRunCount if the run
   1:       // contains mixed character types
   1:       CalculateCharType(lineOffset, typeLimit, subRunLimit, subRunLength, subRunCount, charType, prevType);
   1: 
   1:       if (eCharType_RightToLeftArabic == charType) {
   1:         isBidiSystem = (hints & NS_RENDERING_HINT_ARABIC_SHAPING);
   1:       }
   1:       if (isBidiSystem && (CHARTYPE_IS_RTL(charType) ^ isRTL) ) {
   1:         // set reading order into DC
   1:         isRTL = !isRTL;
   1:         aRenderingContext.SetRightToLeftText(isRTL);
   1:       }
   1:       
   1:       nsAutoString runVisualText;
   1:       runVisualText.Assign(aText + start, subRunLength);
   1:       if (runVisualText.Length() < subRunLength)
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:       FormatUnicodeText(aPresContext, runVisualText.BeginWriting(), subRunLength,
   1:                         (nsCharType)charType, level & 1,
   1:                         isBidiSystem, (hints & NS_RENDERING_HINT_NEW_TEXT_RUNS) != 0);
   1: 
   1:       aRenderingContext.GetWidth(runVisualText.get(), subRunLength, width, nsnull);
   1:       totalWidth += width;
   1:       if (level & 1) {
   1:         aX -= width;
   1:       }
   1:       if (aMode == MODE_DRAW) {
   1:         aRenderingContext.DrawString(runVisualText.get(), subRunLength, aX, aY);
   1:       }
   1: 
   1:       /*
   1:        * The caller may request to calculate the visual position of one
   1:        * or more characters.
   1:        */
   1:       for(int nPosResolve=0; nPosResolve<aPosResolveCount; ++nPosResolve)
   1:       {
   1:         nsBidiPositionResolve* posResolve = &aPosResolve[nPosResolve];
   1:         /*
   1:          * Did we already resolve this position's visual metric? If so, skip.
   1:          */
   1:         if (posResolve->visualLeftTwips != kNotFound)
   1:            continue;
   1:            
   1:         /*
   1:          * First find out if the logical position is within this run.
   1:          */
   1:         if (start <= posResolve->logicalIndex &&
   1:             start + subRunLength > posResolve->logicalIndex) {
   1:           /*
   1:            * If this run is only one character long, we have an easy case:
   1:            * the visual position is the x-coord of the start of the run
   1:            * less the x-coord of the start of the whole text (saved in xStartText).
   1:            */
   1:           if (subRunLength == 1) {
   1:             posResolve->visualIndex = visualStart;
   1:             posResolve->visualLeftTwips = aX - xStartText;
   1:           }
   1:           /*
   1:            * Otherwise, we need to measure the width of the run's part
   1:            * which is to the visual left of the index.
   1:            * In other words, the run is broken in two, around the logical index,
   1:            * and we measure the part which is visually left.
   1:            * If the run is right-to-left, this part will span from after the index
   1:            * up to the end of the run; if it is left-to-right, this part will span
   1:            * from the start of the run up to (and inclduing) the character before the index.
   1:            */
   1:           else {
   1:             nscoord subWidth;
   1:             // The position in the text where this run's "left part" begins.
   1:             const PRUnichar* visualLeftPart;
   1:             if (level & 1) {
   1:               // One day, son, this could all be replaced with mBidiEngine.GetVisualIndex ...
   1:               posResolve->visualIndex = visualStart + (subRunLength - (posResolve->logicalIndex + 1 - start));
   1:               // Skipping to the "left part".
   1:               visualLeftPart = aText + posResolve->logicalIndex + 1;
   1:             }
   1:             else {
   1:               posResolve->visualIndex = visualStart + (posResolve->logicalIndex - start);
   1:               // Skipping to the "left part".
   1:               visualLeftPart = aText + start;
   1:             }
   1:             // The delta between the start of the run and the left part's end.
   1:             PRInt32 visualLeftLength = posResolve->visualIndex - visualStart;
   1:             aRenderingContext.GetWidth(visualLeftPart,
   1:                                        visualLeftLength,
   1:                                        subWidth, nsnull);
   1:             posResolve->visualLeftTwips = aX + subWidth - xStartText;
   1:           }
   1:         }
   1:       }
   1: 
   1:       if (!(level & 1)) {
   1:         aX += width;
   1:       }
   1: 
   1:       --subRunCount;
   1:       start = lineOffset;
   1:       subRunLimit = typeLimit;
   1:       subRunLength = typeLimit - lineOffset;
   1:     } // while
   1:     if (level & 1) {
   1:       aX = xEndRun;
   1:     }
   1:     
   1:     visualStart += length;
   1:   } // for
   1: 
   1:   // Restore original reading order
   1:   if (isRTL) {
   1:     aRenderingContext.SetRightToLeftText(PR_FALSE);
   1:   }
   1:   if (aWidth) {
   1:     *aWidth = totalWidth;
   1:   }
   1:   return NS_OK;
   1: }
   1:   
   1: nsresult
   1: nsBidiPresUtils::ReorderUnicodeText(PRUnichar*       aText,
   1:                                     PRInt32&         aTextLength,
   1:                                     nsCharType       aCharType,
   1:                                     PRBool           aIsOddLevel,
   1:                                     PRBool           aIsBidiSystem,
   1:                                     PRBool           aIsNewTextRunSystem)
   1: {
   1:   NS_ASSERTION(aIsOddLevel == 0 || aIsOddLevel == 1, "aIsOddLevel should be 0 or 1");
   1:   nsresult rv = NS_OK;
   1:   PRBool doReverse = PR_FALSE;
   1: 
   1:   if (!aIsNewTextRunSystem) {
   1:     if (aIsBidiSystem) {
   1:       if ( (CHARTYPE_IS_RTL(aCharType)) ^ (aIsOddLevel) )
   1:         doReverse = PR_TRUE;
   1:     }
   1:     else {
   1:       if (aIsOddLevel)
   1:         doReverse = PR_TRUE;
   1:     }
   1:   }
   1: 
   1:   if (doReverse) {
   1:     PRInt32    newLen;
   1: 
   1:     if (mBuffer.Length() < aTextLength) {
   1:       if (!EnsureStringLength(mBuffer, aTextLength))
   1:         return NS_ERROR_OUT_OF_MEMORY;
   1:     }
   1:     PRUnichar* buffer = mBuffer.BeginWriting();
   1: 
   1:     if (doReverse) {
   1:       rv = mBidiEngine->WriteReverse(aText, aTextLength, buffer,
   1:                                      NSBIDI_DO_MIRRORING, &newLen);
   1:       if (NS_SUCCEEDED(rv) ) {
   1:         aTextLength = newLen;
   1:         memcpy(aText, buffer, aTextLength * sizeof(PRUnichar) );
   1:       }
   1:     }
   1:   }
   1:   return rv;
   1: }
   1: 
   1: #endif // IBMBIDI
