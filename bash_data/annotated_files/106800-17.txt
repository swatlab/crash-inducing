     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
 99568: #include "DocAccessible.h"
 12110: #include "nsObjCExceptions.h"
     1: 
 95352: #include "Accessible-inl.h"
106800: #include "nsAccUtils.h"
 87094: #include "Role.h"
 87094: 
     1: #import "mozAccessible.h"
     1: #import "mozActionElements.h"
 87967: #import "mozHTMLAccessible.h"
     1: #import "mozTextAccessible.h"
     1: 
 87094: using namespace mozilla::a11y;
 87094: 
 99648: AccessibleWrap::
 99648:   AccessibleWrap(nsIContent* aContent, DocAccessible* aDoc) :
 99648:   Accessible(aContent, aDoc), mNativeObject(nil),  
 84640:   mNativeInited(false)
     1: {
     1: }
     1: 
 99648: AccessibleWrap::~AccessibleWrap()
     1: {
     1: }
     1: 
 84640: mozAccessible* 
 99648: AccessibleWrap::GetNativeObject()
     1: {
 84478:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 84478:   
 84640:   if (!mNativeInited && !mNativeObject && !IsDefunct() && !AncestorIsFlat())
 84640:     mNativeObject = [[GetNativeType() alloc] initWithAccessible:this];
     1:   
 84640:   mNativeInited = true;
     1:   
 84640:   return mNativeObject;
 84478:   
 84640:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
     1: NS_IMETHODIMP
 99648: AccessibleWrap::GetNativeInterface (void **aOutInterface) 
     1: {
 84478:   NS_ENSURE_ARG_POINTER(aOutInterface);
 84478: 
 84640:   *aOutInterface = static_cast<void*>(GetNativeObject());
 84478:     
 84640:   return *aOutInterface ? NS_OK : NS_ERROR_FAILURE;
     1: }
     1: 
     1: // overridden in subclasses to create the right kind of object. by default we create a generic
     1: // 'mozAccessible' node.
 70017: Class
 99648: AccessibleWrap::GetNativeType () 
     1: {
 12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NIL;
 12110: 
103750:   if (IsXULDeck())
103750:     return [mozPaneAccessible class];
103750:   
 87094:   roles::Role role = Role();
     1:   switch (role) {
 87094:     case roles::PUSHBUTTON:
 87094:     case roles::SPLITBUTTON:
 87094:     case roles::TOGGLE_BUTTON:
     1:     {
     1:       // if this button may show a popup, let's make it of the popupbutton type.
 87094:       return HasPopup() ? [mozPopupButtonAccessible class] : 
 87094:              [mozButtonAccessible class];
     1:     }
     1:     
 88363:     case roles::PAGETAB:
 88363:       return [mozButtonAccessible class];
 88363: 
 87094:     case roles::CHECKBUTTON:
     1:       return [mozCheckboxAccessible class];
     1:       
 87967:     case roles::HEADING:
 87967:       return [mozHeadingAccessible class];
 87967: 
 88363:     case roles::PAGETABLIST:
 88363:       return [mozTabsAccessible class];
 88363: 
 87094:     case roles::ENTRY:
 87094:     case roles::STATICTEXT:
 87094:     case roles::CAPTION:
 87094:     case roles::ACCEL_LABEL:
 95292:     case roles::PASSWORD_TEXT:
     1:       // normal textfield (static or editable)
     1:       return [mozTextAccessible class];
     1: 
103752:     case roles::TEXT_LEAF:
103752:       return [mozTextLeafAccessible class];
103752: 
 88415:     case roles::LINK:
 88415:       return [mozLinkAccessible class];
 88415: 
 87094:     case roles::COMBOBOX:
     1:       return [mozPopupButtonAccessible class];
     1:       
     1:     default:
     1:       return [mozAccessible class];
     1:   }
     1:   
     1:   return nil;
 12110: 
 12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NIL;
     1: }
     1: 
     1: // this method is very important. it is fired when an accessible object "dies". after this point
     1: // the object might still be around (because some 3rd party still has a ref to it), but it is
     1: // in fact 'dead'.
 43538: void
 99648: AccessibleWrap::Shutdown ()
     1: {
 84640:   // this ensure we will not try to re-create the native object.
 84640:   mNativeInited = true;
 84640: 
 84640:   // we really intend to access the member directly.
 84478:   if (mNativeObject) {
 84478:     [mNativeObject expire];
 84478:     [mNativeObject release];
 84478:     mNativeObject = nil;
     1:   }
     1: 
 99648:   Accessible::Shutdown();
     1: }
     1: 
 29320: nsresult
 99648: AccessibleWrap::HandleAccEvent(AccEvent* aEvent)
  3152: {
 12110:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 12110: 
 99648:   nsresult rv = Accessible::HandleAccEvent(aEvent);
  3152:   NS_ENSURE_SUCCESS(rv, rv);
  3152: 
 15375:   return FirePlatformEvent(aEvent);
 15375: 
 15375:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 15375: }
 15375: 
 15375: nsresult
 99648: AccessibleWrap::FirePlatformEvent(AccEvent* aEvent)
 15375: {
 15375:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 15375: 
 37299:   PRUint32 eventType = aEvent->GetEventType();
  3152: 
 94588:   // ignore everything but focus-changed, value-changed, caret and selection
 94588:   // events for now.
  3152:   if (eventType != nsIAccessibleEvent::EVENT_FOCUS &&
 94588:       eventType != nsIAccessibleEvent::EVENT_VALUE_CHANGE &&
 94588:       eventType != nsIAccessibleEvent::EVENT_TEXT_CARET_MOVED &&
 94588:       eventType != nsIAccessibleEvent::EVENT_TEXT_SELECTION_CHANGED)
  3152:     return NS_OK;
  3152: 
 99648:   Accessible* accessible = aEvent->GetAccessible();
  3152:   NS_ENSURE_STATE(accessible);
  3152: 
  3152:   mozAccessible *nativeAcc = nil;
  3152:   accessible->GetNativeInterface((void**)&nativeAcc);
  3152:   if (!nativeAcc)
  3152:     return NS_ERROR_FAILURE;
  3152: 
  3152:   switch (eventType) {
  3152:     case nsIAccessibleEvent::EVENT_FOCUS:
  3152:       [nativeAcc didReceiveFocus];
  3152:       break;
  3152:     case nsIAccessibleEvent::EVENT_VALUE_CHANGE:
  3152:       [nativeAcc valueDidChange];
  3152:       break;
 94588:     case nsIAccessibleEvent::EVENT_TEXT_CARET_MOVED:
 94588:     case nsIAccessibleEvent::EVENT_TEXT_SELECTION_CHANGED:
 94588:       [nativeAcc selectedTextDidChange];
 94588:       break;
  3152:   }
  3152: 
  3152:   return NS_OK;
 12110: 
 12110:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
  3152: }
  3152: 
 29320: void
 99648: AccessibleWrap::InvalidateChildren()
     1: {
 29321:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 12110: 
 84640:   [GetNativeObject() invalidateChildren];
 84478: 
 99648:   Accessible::InvalidateChildren();
 12110: 
 29321:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
 86113: bool
 99648: AccessibleWrap::AppendChild(Accessible* aAccessible)
 86113: {
 99648:   bool appended = Accessible::AppendChild(aAccessible);
 86113:   
 86113:   if (appended && mNativeObject)
 86113:     [mNativeObject appendChild:aAccessible];
 86113: 
 86113:   return appended;
 86113: }
 86113: 
 86113: bool
 99648: AccessibleWrap::RemoveChild(Accessible* aAccessible)
 86113: {
 99648:   bool removed = Accessible::RemoveChild(aAccessible);
 86113: 
 86113:   if (removed && mNativeObject)
 86113:     [mNativeObject invalidateChildren];
 86113: 
 86113:   return removed;
 86113: }
 86113: 
     1: // if we for some reason have no native accessible, we should be skipped over (and traversed)
     1: // when fetching all unignored children, etc.  when counting unignored children, we will not be counted.
 79445: bool 
 99648: AccessibleWrap::IsIgnored() 
     1: {
 84478:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 84478:   
 84640:   mozAccessible* nativeObject = GetNativeObject();
 84640:   return (!nativeObject) || [nativeObject accessibilityIsIgnored];
 84478:   
 84478:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(false);
     1: }
     1: 
     1: void
 99648: AccessibleWrap::GetUnignoredChildren(nsTArray<Accessible*>* aChildrenArray)
     1: {
     1:   // we're flat; there are no children.
 20566:   if (nsAccUtils::MustPrune(this))
     1:     return;
     1: 
 99463:   PRUint32 childCount = ChildCount();
 99463:   for (PRUint32 childIdx = 0; childIdx < childCount; childIdx++) {
 99648:     AccessibleWrap* childAcc =
 99648:       static_cast<AccessibleWrap*>(GetChildAt(childIdx));
 40990: 
 94645:     // If element is ignored, then add its children as substitutes.
 40990:     if (childAcc->IsIgnored()) {
 94645:       childAcc->GetUnignoredChildren(aChildrenArray);
 94645:       continue;
     1:     }
 94645: 
 94645:     aChildrenArray->AppendElement(childAcc);
     1:   }
     1: }
     1: 
 99648: Accessible*
 99648: AccessibleWrap::GetUnignoredParent() const
     1: {
 94578:   // Go up the chain to find a parent that is not ignored.
 99648:   AccessibleWrap* parentWrap = static_cast<AccessibleWrap*>(Parent());
 94578:   while (parentWrap && parentWrap->IsIgnored()) 
 99648:     parentWrap = static_cast<AccessibleWrap*>(parentWrap->Parent());
     1:     
 94578:   return parentWrap;
     1: }
 41384: 
 41384: ////////////////////////////////////////////////////////////////////////////////
 99648: // AccessibleWrap protected
 41384: 
 79445: bool
 99648: AccessibleWrap::AncestorIsFlat()
 41384: {
 41384:   // We don't create a native object if we're child of a "flat" accessible;
 41384:   // for example, on OS X buttons shouldn't have any children, because that
 41384:   // makes the OS confused. 
 41384:   //
 41384:   // To maintain a scripting environment where the XPCOM accessible hierarchy
 41384:   // look the same on all platforms, we still let the C++ objects be created
 41384:   // though.
 41384: 
 99648:   Accessible* parent = Parent();
 41384:   while (parent) {
 41384:     if (nsAccUtils::MustPrune(parent))
 80486:       return true;
 41384: 
 74545:     parent = parent->Parent();
 41384:   }
 41384:   // no parent was flat
 80486:   return false;
 41384: }
