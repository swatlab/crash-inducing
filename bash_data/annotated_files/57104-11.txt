    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Vladimir Vukicevic <vladimir@pobox.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef GFX_PLATFORM_H
    1: #define GFX_PLATFORM_H
    1: 
    1: #include "prtypes.h"
23904: #include "nsTArray.h"
    1: 
19003: #include "nsIObserver.h"
19003: 
    1: #include "gfxTypes.h"
    1: #include "gfxASurface.h"
19127: #include "gfxColor.h"
    1: 
27035: #include "qcms.h"
 4240: #ifdef XP_OS2
 4240: #undef OS2EMX_PLAIN_CHAR
 4240: #endif
 4240: 
    1: class gfxImageSurface;
16418: class gfxFont;
  270: class gfxFontGroup;
  367: struct gfxFontStyle;
19962: class gfxUserFontSet;
19962: class gfxFontEntry;
22397: class gfxProxyFontEntry;
31590: class gfxPlatformFontList;
37211: class gfxTextRun;
19962: class nsIURI;
38493: class nsIAtom;
42854: class nsIPrefBranch;
    1: 
11086: // pref lang id's for font prefs
11086: // !!! needs to match the list of pref font.default.xx entries listed in all.js !!!
39063: // !!! don't use as bit mask, this may grow larger !!!
11086: 
11086: enum eFontPrefLang {
11086:     eFontPrefLang_Western     =  0,
11086:     eFontPrefLang_CentEuro    =  1,
11086:     eFontPrefLang_Japanese    =  2,
11086:     eFontPrefLang_ChineseTW   =  3,
11086:     eFontPrefLang_ChineseCN   =  4,
11086:     eFontPrefLang_ChineseHK   =  5,
11086:     eFontPrefLang_Korean      =  6,
11086:     eFontPrefLang_Cyrillic    =  7,
11086:     eFontPrefLang_Baltic      =  8,
11086:     eFontPrefLang_Greek       =  9,
11086:     eFontPrefLang_Turkish     = 10,
11086:     eFontPrefLang_Thai        = 11,
11086:     eFontPrefLang_Hebrew      = 12,
11086:     eFontPrefLang_Arabic      = 13,
11086:     eFontPrefLang_Devanagari  = 14,
11086:     eFontPrefLang_Tamil       = 15,
11086:     eFontPrefLang_Armenian    = 16,
11086:     eFontPrefLang_Bengali     = 17,
11086:     eFontPrefLang_Canadian    = 18,
11086:     eFontPrefLang_Ethiopic    = 19,
11086:     eFontPrefLang_Georgian    = 20,
11086:     eFontPrefLang_Gujarati    = 21,
11086:     eFontPrefLang_Gurmukhi    = 22,
11086:     eFontPrefLang_Khmer       = 23,
11086:     eFontPrefLang_Malayalam   = 24,
13885:     eFontPrefLang_Oriya       = 25,
13885:     eFontPrefLang_Telugu      = 26,
13885:     eFontPrefLang_Kannada     = 27,
13885:     eFontPrefLang_Sinhala     = 28,
38930:     eFontPrefLang_Tibetan     = 29,
11086: 
38930:     eFontPrefLang_LangCount   = 30, // except Others and UserDefined.
11086: 
38930:     eFontPrefLang_Others      = 30, // x-unicode
38930:     eFontPrefLang_UserDefined = 31,
11086: 
38930:     eFontPrefLang_CJKSet      = 32, // special code for CJK set
38930:     eFontPrefLang_AllCount    = 33
11086: };
11086: 
16571: enum eCMSMode {
16571:     eCMSMode_Off          = 0,     // No color management
16571:     eCMSMode_All          = 1,     // Color manage everything
16571:     eCMSMode_TaggedOnly   = 2,     // Color manage tagged Images Only
16571:     eCMSMode_AllCount     = 3
16571: };
16571: 
11086: // when searching through pref langs, max number of pref langs
13885: const PRUint32 kMaxLenPrefLangList = 32;
11086: 
42854: #define UNINITIALIZED_VALUE  (-1)
42854: 
    1: class THEBES_API gfxPlatform {
    1: public:
    1:     /**
    1:      * Return a pointer to the current active platform.
    1:      * This is a singleton; it contains mostly convenience
    1:      * functions to obtain platform-specific objects.
    1:      */
    1:     static gfxPlatform *GetPlatform();
    1: 
    1:     /**
  218:      * Start up Thebes. This can fail.
  218:      */
  218:     static nsresult Init();
  218: 
  218:     /**
    1:      * Clean up static objects to shut down thebes.
    1:      */
    1:     static void Shutdown();
    1: 
    1:     /**
    1:      * Create an offscreen surface of the given dimensions
 8368:      * and image format.
    1:      */
    1:     virtual already_AddRefed<gfxASurface> CreateOffscreenSurface(const gfxIntSize& size,
54253:                                                                  gfxASurface::gfxContentType contentType) = 0;
    1: 
    1: 
 8368:     virtual already_AddRefed<gfxASurface> OptimizeImage(gfxImageSurface *aSurface,
 8368:                                                         gfxASurface::gfxImageFormat format);
    1: 
    1:     /*
    1:      * Font bits
    1:      */
    1: 
37211:     virtual void SetupClusterBoundaries(gfxTextRun *aTextRun, const PRUnichar *aString);
37211: 
    1:     /**
    1:      * Fill aListOfFonts with the results of querying the list of font names
    1:      * that correspond to the given language group or generic font family
    1:      * (or both, or neither).
    1:      */
38493:     virtual nsresult GetFontList(nsIAtom *aLangGroup,
    1:                                  const nsACString& aGenericFamily,
23904:                                  nsTArray<nsString>& aListOfFonts);
    1: 
    1:     /**
    1:      * Rebuilds the any cached system font lists
    1:      */
    1:     virtual nsresult UpdateFontList();
    1: 
    1:     /**
57104:      * Create the platform font-list object (gfxPlatformFontList concrete subclass).
57104:      * This function is responsible to create the appropriate subclass of
57104:      * gfxPlatformFontList *and* to call its InitFontList() method.
31590:      */
31590:     virtual gfxPlatformFontList *CreatePlatformFontList() {
31590:         NS_NOTREACHED("oops, this platform doesn't have a gfxPlatformFontList implementation");
31590:         return nsnull;
31590:     }
31590: 
31590:     /**
    1:      * Font name resolver, this returns actual font name(s) by the callback
    1:      * function. If the font doesn't exist, the callback function is not called.
    1:      * If the callback function returns PR_FALSE, the aAborted value is set to
    1:      * PR_TRUE, otherwise, PR_FALSE.
    1:      */
    1:     typedef PRBool (*FontResolverCallback) (const nsAString& aName,
    1:                                             void *aClosure);
    1:     virtual nsresult ResolveFontName(const nsAString& aFontName,
    1:                                      FontResolverCallback aCallback,
    1:                                      void *aClosure,
    1:                                      PRBool& aAborted) = 0;
    1: 
  270:     /**
13003:      * Resolving a font name to family name. The result MUST be in the result of GetFontList().
13003:      * If the name doesn't in the system, aFamilyName will be empty string, but not failed.
13003:      */
13003:     virtual nsresult GetStandardFamilyName(const nsAString& aFontName, nsAString& aFamilyName) = 0;
13003: 
13003:     /**
  270:      * Create the appropriate platform font group
  270:      */
  270:     virtual gfxFontGroup *CreateFontGroup(const nsAString& aFamilies,
19962:                                           const gfxFontStyle *aStyle,
19962:                                           gfxUserFontSet *aUserFontSet) = 0;
19962:                                           
19962:                                           
19962:     /**
22397:      * Look up a local platform font using the full font face name.
22397:      * (Needed to support @font-face src local().)
22397:      * Ownership of the returned gfxFontEntry is passed to the caller,
22397:      * who must either AddRef() or delete.
19962:      */
23273:     virtual gfxFontEntry* LookupLocalFont(const gfxProxyFontEntry *aProxyEntry,
23273:                                           const nsAString& aFontName)
23273:     { return nsnull; }
19962: 
19962:     /**
22397:      * Activate a platform font.  (Needed to support @font-face src url().)
32808:      * aFontData is a NS_Malloc'ed block that must be freed by this function
32808:      * (or responsibility passed on) when it is no longer needed; the caller
32808:      * will NOT free it.
22397:      * Ownership of the returned gfxFontEntry is passed to the caller,
22397:      * who must either AddRef() or delete.
19962:      */
22397:     virtual gfxFontEntry* MakePlatformFont(const gfxProxyFontEntry *aProxyEntry,
22397:                                            const PRUint8 *aFontData,
32808:                                            PRUint32 aLength);
19962: 
19962:     /**
19962:      * Whether to allow downloadable fonts via @font-face rules
19962:      */
55084:     PRBool DownloadableFontsEnabled();
55084: 
55084:     /**
55084:      * Whether to sanitize downloaded fonts using the OTS library
55084:      */
55084:     PRBool SanitizeDownloadedFonts();
19962: 
43527:     /**
55086:      * Whether to preserve OpenType layout tables when sanitizing
55086:      */
55086:     PRBool PreserveOTLTablesWhenSanitizing();
55086: 
55086:     /**
43527:      * Whether to use the harfbuzz shaper (depending on script complexity).
43527:      *
43527:      * This allows harfbuzz to be enabled selectively via the preferences.
43527:      * Current "harfbuzz level" options:
43527:      * <= 0 will never use the harfbuzz shaper;
43527:      *  = 1 will use it for "simple" scripts (Latin, Cyrillic, CJK, etc);
43527:      * >= 2 will use it for all scripts, including those requiring complex
43527:      *      shaping for correct rendering (Arabic, Indic, etc).
43527:      *
43527:      * Depending how harfbuzz complex-script support evolves, we may want to
43527:      * update this mechanism - e.g., separating complex-bidi from Indic,
43527:      * or other distinctions.
43527:      */
43527:     PRInt8 UseHarfBuzzLevel();
43527: 
19962:     // check whether format is supported on a platform or not (if unclear, returns true)
19962:     virtual PRBool IsFontFormatSupported(nsIURI *aFontURI, PRUint32 aFormatFlags) { return PR_FALSE; }
  270: 
38493:     void GetPrefFonts(nsIAtom *aLanguage, nsString& array, PRBool aAppendUnicode = PR_TRUE);
    1: 
37211:     // in some situations, need to make decisions about ambiguous characters, may need to look at multiple pref langs
37211:     void GetLangPrefs(eFontPrefLang aPrefLangs[], PRUint32 &aLen, eFontPrefLang aCharLang, eFontPrefLang aPageLang);
37211:     
 3787:     /**
11086:      * Iterate over pref fonts given a list of lang groups.  For a single lang
11086:      * group, multiple pref fonts are possible.  If error occurs, returns PR_FALSE,
11086:      * PR_TRUE otherwise.  Callback returns PR_FALSE to abort process.
11086:      */
11086:     typedef PRBool (*PrefFontCallback) (eFontPrefLang aLang, const nsAString& aName,
11086:                                         void *aClosure);
11086:     static PRBool ForEachPrefFont(eFontPrefLang aLangArray[], PRUint32 aLangArrayLen,
11086:                                   PrefFontCallback aCallback,
11086:                                   void *aClosure);
11086: 
38493:     // convert a lang group to enum constant (i.e. "zh-TW" ==> eFontPrefLang_ChineseTW)
11086:     static eFontPrefLang GetFontPrefLangFor(const char* aLang);
11086: 
38493:     // convert a lang group atom to enum constant
38493:     static eFontPrefLang GetFontPrefLangFor(nsIAtom *aLang);
38493: 
11086:     // convert a enum constant to lang group string (i.e. eFontPrefLang_ChineseTW ==> "zh-TW")
11086:     static const char* GetPrefLangName(eFontPrefLang aLang);
11086:    
37211:     // map a Unicode range (based on char code) to a font language for Preferences
37211:     static eFontPrefLang GetFontPrefLangFor(PRUint8 aUnicodeRange);
37211: 
11086:     // returns true if a pref lang is CJK
11086:     static PRBool IsLangCJK(eFontPrefLang aLang);
11086:     
11086:     // helper method to add a pref lang to an array, if not already in array
11086:     static void AppendPrefLang(eFontPrefLang aPrefLangs[], PRUint32& aLen, eFontPrefLang aAddLang);
11086:     
11086:     /**
 3787:      * Are we going to try color management?
 3787:      */
16571:     static eCMSMode GetCMSMode();
 3787: 
 3787:     /**
16152:      * Determines the rendering intent for color management.
16152:      *
16152:      * If the value in the pref gfx.color_management.rendering_intent is a
32801:      * valid rendering intent as defined in gfx/qcms/qcms.h, that
16152:      * value is returned. Otherwise, -1 is returned and the embedded intent
16152:      * should be used.
16152:      *
16152:      * See bug 444014 for details.
16152:      */
16152:     static int GetRenderingIntent();
16152: 
16152:     /**
19127:      * Convert a pixel using a cms transform in an endian-aware manner.
19127:      *
19127:      * Sets 'out' to 'in' if transform is NULL.
19127:      */
27035:     static void TransformPixel(const gfxRGBA& in, gfxRGBA& out, qcms_transform *transform);
19127: 
19127:     /**
 3787:      * Return the output device ICC profile.
 3787:      */
27035:     static qcms_profile* GetCMSOutputProfile();
 3787: 
 3787:     /**
15987:      * Return the sRGB ICC profile.
15987:      */
27035:     static qcms_profile* GetCMSsRGBProfile();
15987: 
15987:     /**
 3787:      * Return sRGB -> output device transform.
 3787:      */
27035:     static qcms_transform* GetCMSRGBTransform();
 3787: 
 3787:     /**
 5465:      * Return output -> sRGB device transform.
 5465:      */
27035:     static qcms_transform* GetCMSInverseRGBTransform();
 5465: 
 5465:     /**
 3787:      * Return sRGBA -> output device transform.
 3787:      */
27035:     static qcms_transform* GetCMSRGBATransform();
 3787: 
42854:     virtual void FontsPrefsChanged(nsIPrefBranch *aPrefBranch, const char *aPref);
42854: 
51037:     /**
51037:      * Returns a 1x1 surface that can be used to create graphics contexts
51037:      * for measuring text etc as if they will be rendered to the screen
51037:      */
51037:     gfxASurface* ScreenReferenceSurface() { return mScreenReferenceSurface; }
51037: 
    1: protected:
42854:     gfxPlatform();
    1:     virtual ~gfxPlatform();
    1: 
42854:     static PRBool GetBoolPref(const char *aPref, PRBool aDefault);
42854: 
37211:     void AppendCJKPrefLangs(eFontPrefLang aPrefLangs[], PRUint32 &aLen, 
37211:                             eFontPrefLang aCharLang, eFontPrefLang aPageLang);
37211:                                                
42854:     PRBool  mAllowDownloadableFonts;
55084:     PRBool  mDownloadableFontsSanitize;
55086:     PRBool  mSanitizePreserveOTLTables;
42854: 
43527:     // whether to use the HarfBuzz layout engine
43527:     PRInt8  mUseHarfBuzzLevel;
43527: 
 3787: private:
27035:     virtual qcms_profile* GetPlatformCMSOutputProfile();
19003: 
51037:     nsRefPtr<gfxASurface> mScreenReferenceSurface;
37211:     nsTArray<PRUint32> mCJKPrefLangs;
19003:     nsCOMPtr<nsIObserver> overrideObserver;
    1: };
    1: 
    1: #endif /* GFX_PLATFORM_H */
