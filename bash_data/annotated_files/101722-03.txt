     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #ifndef nsBindingManager_h_
     1: #define nsBindingManager_h_
     1: 
  8678: #include "nsStubMutationObserver.h"
     1: #include "pldhash.h"
     1: #include "nsInterfaceHashtable.h"
     1: #include "nsRefPtrHashtable.h"
     1: #include "nsURIHashKey.h"
     1: #include "nsCycleCollectionParticipant.h"
     1: #include "nsXBLBinding.h"
     1: #include "nsTArray.h"
 25116: #include "nsThreadUtils.h"
     1: 
     1: class nsIContent;
     1: class nsIXPConnectWrappedJS;
     1: class nsIAtom;
     1: class nsIDOMNodeList;
     1: class nsIDocument;
     1: class nsIURI;
 47649: class nsXBLDocumentInfo;
     1: class nsIStreamListener;
     1: class nsStyleSet;
     1: class nsXBLBinding;
     1: template<class E> class nsRefPtr;
     1: typedef nsTArray<nsRefPtr<nsXBLBinding> > nsBindingList;
  3645: class nsIPrincipal;
     1: 
  8678: class nsBindingManager : public nsStubMutationObserver
     1: {
     1: public:
     1:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
  8678: 
  8678:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTAPPENDED
  8678:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTINSERTED
  8678:   NS_DECL_NSIMUTATIONOBSERVER_CONTENTREMOVED
     1: 
  6627:   nsBindingManager(nsIDocument* aDocument);
     1:   ~nsBindingManager();
     1: 
     1:   nsXBLBinding* GetBinding(nsIContent* aContent);
     1:   nsresult SetBinding(nsIContent* aContent, nsXBLBinding* aBinding);
     1: 
     1:   nsIContent* GetInsertionParent(nsIContent* aContent);
     1:   nsresult SetInsertionParent(nsIContent* aContent, nsIContent* aResult);
     1: 
     1:   /**
     1:    * Notify the binding manager that an element
 43087:    * has been removed from its document,
     1:    * so that it can update any bindings or
     1:    * nsIAnonymousContentCreator-created anonymous
     1:    * content that may depend on the document.
     1:    * @param aContent the element that's being moved
     1:    * @param aOldDocument the old document in which the
 43087:    *   content resided.
     1:    */
 43087:   void RemovedFromDocument(nsIContent* aContent, nsIDocument* aOldDocument)
 43087:   {
 43087:     if (aContent->HasFlag(NODE_MAY_BE_IN_BINDING_MNGR)) {
101722:       RemovedFromDocumentInternal(aContent, aOldDocument,
101722:                                   aContent->GetBindingParent());
 43087:     }
 43087:   }
 43087:   void RemovedFromDocumentInternal(nsIContent* aContent,
101722:                                    nsIDocument* aOldDocument,
101722:                                    nsIContent* aContentBindingParent);
     1: 
     1:   nsIAtom* ResolveTag(nsIContent* aContent, PRInt32* aNameSpaceID);
     1: 
     1:   /**
     1:    * Return a list of all explicit children, including any children
     1:    * that may have been inserted via XBL insertion points.
     1:    */
     1:   nsresult GetContentListFor(nsIContent* aContent, nsIDOMNodeList** aResult);
     1: 
     1:   /**
 38069:    * Non-COMy version of GetContentListFor.
 38069:    */
 38069:   nsINodeList* GetContentListFor(nsIContent* aContent);
 38069: 
 38069:   /**
     1:    * Set the insertion point children for the specified element.
     1:    * The binding manager assumes ownership of aList.
     1:    */
     1:   nsresult SetContentListFor(nsIContent* aContent,
     1:                              nsInsertionPointList* aList);
     1: 
     1:   /**
     1:    * Determine whether or not the explicit child list has been altered
     1:    * by XBL insertion points.
     1:    */
 79445:   bool HasContentListFor(nsIContent* aContent);
     1: 
     1:   /**
 24403:    * Return the nodelist of "anonymous" kids for this node.  This might
 24403:    * actually include some of the nodes actual DOM kids, if there are
 24403:    * <children> tags directly as kids of <content>.  This will only end up
 24403:    * returning a non-null list for nodes which have a binding attached.
     1:    */
     1:   nsresult GetAnonymousNodesFor(nsIContent* aContent, nsIDOMNodeList** aResult);
     1: 
     1:   /**
 42325:    * Same as above, but without the XPCOM goop
 42325:    */
 42325:   nsINodeList* GetAnonymousNodesFor(nsIContent* aContent);
 42325: 
 42325:   /**
     1:    * Set the anonymous child content for the specified element.
     1:    * The binding manager assumes ownership of aList.
     1:    */
     1:   nsresult SetAnonymousNodesFor(nsIContent* aContent,
     1:                                 nsInsertionPointList* aList);
     1: 
     1:   /**
     1:    * Retrieves the anonymous list of children if the element has one;
     1:    * otherwise, retrieves the list of explicit children. N.B. that if
     1:    * the explicit child list has not been altered by XBL insertion
     1:    * points, then aResult will be null.
     1:    */
     1:   nsresult GetXBLChildNodesFor(nsIContent* aContent, nsIDOMNodeList** aResult);
     1: 
     1:   /**
 24403:    * Non-COMy version of GetXBLChildNodesFor
 24403:    */
 24403:   nsINodeList* GetXBLChildNodesFor(nsIContent* aContent);
 24403: 
 24403:   /**
     1:    * Given a parent element and a child content, determine where the
     1:    * child content should be inserted in the parent element's
     1:    * anonymous content tree. Specifically, aChild should be inserted
     1:    * beneath aResult at the index specified by aIndex.
     1:    */
 24404:   // XXXbz That's false.  The aIndex doesn't seem to accurately reflect
 24404:   // anything resembling reality in terms of inserting content.  It's really
 24404:   // only used to tell apart two different insertion points with the same
 24404:   // insertion parent when managing our internal data structures.  We really
 24404:   // shouldn't be handing it out in our public API, since it's not useful to
 24404:   // anyone.
     1:   nsIContent* GetInsertionPoint(nsIContent* aParent,
 40937:                                 const nsIContent* aChild, PRUint32* aIndex);
     1: 
     1:   /**
     1:    * Return the unfiltered insertion point for the specified parent
     1:    * element. If other filtered insertion points exist,
     1:    * aMultipleInsertionPoints will be set to true.
     1:    */
     1:   nsIContent* GetSingleInsertionPoint(nsIContent* aParent, PRUint32* aIndex,
 79445:                                       bool* aMultipleInsertionPoints);
     1: 
 40937:   nsIContent* GetNestedInsertionPoint(nsIContent* aParent,
 40937:                                       const nsIContent* aChild);
 40937:   nsIContent* GetNestedSingleInsertionPoint(nsIContent* aParent,
 79445:                                             bool* aMultipleInsertionPoints);
 40937: 
  3645:   nsresult AddLayeredBinding(nsIContent* aContent, nsIURI* aURL,
  3645:                              nsIPrincipal* aOriginPrincipal);
     1:   nsresult RemoveLayeredBinding(nsIContent* aContent, nsIURI* aURL);
  3645:   nsresult LoadBindingDocument(nsIDocument* aBoundDoc, nsIURI* aURL,
  3645:                                nsIPrincipal* aOriginPrincipal);
     1: 
     1:   nsresult AddToAttachedQueue(nsXBLBinding* aBinding);
  7274:   void ProcessAttachedQueue(PRUint32 aSkipSize = 0);
     1: 
     1:   void ExecuteDetachedHandlers();
     1: 
 47649:   nsresult PutXBLDocumentInfo(nsXBLDocumentInfo* aDocumentInfo);
 47649:   nsXBLDocumentInfo* GetXBLDocumentInfo(nsIURI* aURI);
 47649:   void RemoveXBLDocumentInfo(nsXBLDocumentInfo* aDocumentInfo);
     1: 
     1:   nsresult PutLoadingDocListener(nsIURI* aURL, nsIStreamListener* aListener);
     1:   nsIStreamListener* GetLoadingDocListener(nsIURI* aURL);
     1:   void RemoveLoadingDocListener(nsIURI* aURL);
     1: 
     1:   void FlushSkinBindings();
     1: 
     1:   nsresult GetBindingImplementation(nsIContent* aContent, REFNSIID aIID, void** aResult);
     1: 
     1:   // Style rule methods
 16231:   nsresult WalkRules(nsIStyleRuleProcessor::EnumFunc aFunc,
     1:                      RuleProcessorData* aData,
 79445:                      bool* aCutOffInheritance);
 39805: 
 39805:   void WalkAllRules(nsIStyleRuleProcessor::EnumFunc aFunc,
 39805:                     RuleProcessorData* aData);
 16231:   /**
 16231:    * Do any processing that needs to happen as a result of a change in
 16231:    * the characteristics of the medium, and return whether this rule
 16231:    * processor's rules have changed (e.g., because of media queries).
 16231:    */
 16231:   nsresult MediumFeaturesChanged(nsPresContext* aPresContext,
 79445:                                  bool* aRulesChanged);
     1: 
 47849:   void AppendAllSheets(nsTArray<nsCSSStyleSheet*>& aArray);
 47849: 
     1:   NS_HIDDEN_(void) Traverse(nsIContent *aContent,
     1:                             nsCycleCollectionTraversalCallback &cb);
     1: 
     1:   NS_DECL_CYCLE_COLLECTION_CLASS(nsBindingManager)
     1: 
  2025:   // Notify the binding manager when an outermost update begins and
  2025:   // ends.  The end method can execute script.
  2025:   void BeginOutermostUpdate();
  2025:   void EndOutermostUpdate();
  2025: 
  8678:   // Called when the document is going away
  8678:   void DropDocumentReference();
  8678: 
     1: protected:
     1:   nsIXPConnectWrappedJS* GetWrappedJS(nsIContent* aContent);
     1:   nsresult SetWrappedJS(nsIContent* aContent, nsIXPConnectWrappedJS* aResult);
     1: 
 24403:   nsINodeList* GetXBLChildNodesInternal(nsIContent* aContent,
 79445:                                         bool* aIsAnonymousContentList);
 24403:   nsINodeList* GetAnonymousNodesInternal(nsIContent* aContent,
 79445:                                          bool* aIsAnonymousContentList);
     1: 
  8040:   // Called by ContentAppended and ContentInserted to handle a single child
  8040:   // insertion.  aChild must not be null.  aContainer may be null.
  8040:   // aIndexInContainer is the index of the child in the parent.  aAppend is
  8040:   // true if this child is being appended, not inserted.
  8040:   void HandleChildInsertion(nsIContent* aContainer, nsIContent* aChild,
 79445:                             PRUint32 aIndexInContainer, bool aAppend);
  8040: 
 27088:   // For the given container under which a child is being added, given
 27088:   // insertion parent and given index of the child being inserted, find the
 27088:   // right nsXBLInsertionPoint and the right index in that insertion point to
 27088:   // insert it at.  If null is returned, aInsertionIndex might be garbage.
 27088:   // aAppend controls what should be returned as the aInsertionIndex if the
 27088:   // right index can't be found.  If true, the length of the insertion point
 27088:   // will be returned; otherwise 0 will be returned.
 27088:   nsXBLInsertionPoint* FindInsertionPointAndIndex(nsIContent* aContainer,
 27088:                                                   nsIContent* aInsertionParent,
 27088:                                                   PRUint32 aIndexInContainer,
 27088:                                                   PRInt32 aAppend,
 27088:                                                   PRInt32* aInsertionIndex);
 27088: 
     1:   // Same as ProcessAttachedQueue, but also nulls out
     1:   // mProcessAttachedQueueEvent
     1:   void DoProcessAttachedQueue();
     1: 
  8673:   // Post an event to process the attached queue.
  8673:   void PostProcessAttachedQueueEvent();
  8673: 
     1: // MEMBER VARIABLES
     1: protected: 
  6864:   void RemoveInsertionParent(nsIContent* aParent);
     1:   // A mapping from nsIContent* to the nsXBLBinding* that is
     1:   // installed on that element.
     1:   nsRefPtrHashtable<nsISupportsHashKey,nsXBLBinding> mBindingTable;
     1: 
 24403:   // A mapping from nsIContent* to an nsAnonymousContentList*.  This
 24403:   // list contains an accurate reflection of our *explicit* children
 24403:   // (once intermingled with insertion points) in the altered DOM.
 24403:   // There is an entry for a content node in this table only if that
 24403:   // content node has some <children> kids.
     1:   PLDHashTable mContentListTable;
     1: 
 24403:   // A mapping from nsIContent* to an nsAnonymousContentList*.  This
 24403:   // list contains an accurate reflection of our *anonymous* children
 24403:   // (if and only if they are intermingled with insertion points) in
 24403:   // the altered DOM.  This table is not used if no insertion points
 24403:   // were defined directly underneath a <content> tag in a binding.
 24403:   // The NodeList from the <content> is used instead as a performance
 24403:   // optimization.  There is an entry for a content node in this table
 24403:   // only if that content node has a binding with a <content> attached
 24403:   // and this <content> contains <children> elements directly.
     1:   PLDHashTable mAnonymousNodesTable;
     1: 
     1:   // A mapping from nsIContent* to nsIContent*.  The insertion parent
     1:   // is our one true parent in the transformed DOM.  This gives us a
     1:   // more-or-less O(1) way of obtaining our transformed parent.
     1:   PLDHashTable mInsertionParentTable;
     1: 
     1:   // A mapping from nsIContent* to nsIXPWrappedJS* (an XPConnect
     1:   // wrapper for JS objects).  For XBL bindings that implement XPIDL
     1:   // interfaces, and that get referred to from C++, this table caches
     1:   // the XPConnect wrapper for the binding.  By caching it, I control
     1:   // its lifetime, and I prevent a re-wrap of the same script object
     1:   // (in the case where multiple bindings in an XBL inheritance chain
     1:   // both implement an XPIDL interface).
     1:   PLDHashTable mWrapperTable;
     1: 
 47649:   // A mapping from a URL (a string) to nsXBLDocumentInfo*.  This table
     1:   // is the cache of all binding documents that have been loaded by a
     1:   // given bound document.
 47649:   nsRefPtrHashtable<nsURIHashKey,nsXBLDocumentInfo> mDocumentTable;
     1: 
     1:   // A mapping from a URL (a string) to a nsIStreamListener. This
     1:   // table is the currently loading binding docs.  If they're in this
     1:   // table, they have not yet finished loading.
     1:   nsInterfaceHashtable<nsURIHashKey,nsIStreamListener> mLoadingDocTable;
     1: 
     1:   // A queue of binding attached event handlers that are awaiting execution.
     1:   nsBindingList mAttachedStack;
 79445:   bool mProcessingAttachedStack;
 79445:   bool mDestroyed;
  7274:   PRUint32 mAttachedStackSizeOnOutermost;
     1: 
     1:   // Our posted event to process the attached queue, if any
     1:   friend class nsRunnableMethod<nsBindingManager>;
 24565:   nsRefPtr< nsRunnableMethod<nsBindingManager> > mProcessAttachedQueueEvent;
  6627: 
  6627:   // Our document.  This is a weak ref; the document owns us
  6627:   nsIDocument* mDocument; 
     1: };
     1: 
     1: #endif
