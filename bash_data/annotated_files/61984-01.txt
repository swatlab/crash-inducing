    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Places.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brian Ryner <bryner@brianryner.com> (original author)
33704:  *   Dietrich Ayala <dietrich@mozilla.com>
23593:  *   Drew Willcoxon <adw@mozilla.com>
33704:  *   Marco Bonardo <mak77@bonardo.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsNavBookmarks.h"
    1: #include "nsNavHistory.h"
    1: #include "mozStorageHelper.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsNetUtil.h"
 4179: #include "nsIDynamicContainer.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsFaviconService.h"
    1: #include "nsAnnotationService.h"
  338: #include "nsPrintfCString.h"
 4004: #include "nsIUUIDGenerator.h"
 4004: #include "prprf.h"
10669: #include "nsILivemarkService.h"
16356: #include "nsPlacesTriggers.h"
16361: #include "nsPlacesTables.h"
28193: #include "nsPlacesIndexes.h"
30050: #include "nsPlacesMacros.h"
37342: #include "Helpers.h"
    1: 
42480: #include "mozilla/FunctionTimer.h"
42480: 
50437: #define BOOKMARKS_TO_KEYWORDS_INITIAL_CACHE_SIZE 64
50437: 
    1: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_ID = 0;
  338: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_Type = 1;
21350: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_PlaceID = 2;
    1: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_Parent = 3;
    1: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_Position = 4;
    1: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_Title = 5;
    1: 
    1: // These columns sit to the right of the kGetInfoIndex_* columns.
33458: const PRInt32 nsNavBookmarks::kGetChildrenIndex_Position = 13;
33458: const PRInt32 nsNavBookmarks::kGetChildrenIndex_Type = 14;
33458: const PRInt32 nsNavBookmarks::kGetChildrenIndex_PlaceID = 15;
33458: const PRInt32 nsNavBookmarks::kGetChildrenIndex_ServiceContractId = 16;
    1: 
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_ID = 0;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_URI = 1;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_Title = 2;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_Position = 3;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_PlaceID = 4;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_Parent = 5;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_Type = 6;
 4179: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_ServiceContractId = 7;
 1604: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_DateAdded = 8;
 1604: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_LastModified = 9;
    1: 
41402: using namespace mozilla::places;
29518: 
35298: PLACES_FACTORY_SINGLETON_IMPLEMENTATION(nsNavBookmarks, gBookmarksService)
    1: 
    1: #define BOOKMARKS_ANNO_PREFIX "bookmarks/"
 2049: #define BOOKMARKS_TOOLBAR_FOLDER_ANNO NS_LITERAL_CSTRING(BOOKMARKS_ANNO_PREFIX "toolbarFolder")
 4004: #define GUID_ANNO NS_LITERAL_CSTRING("placesInternal/GUID")
 4179: #define READ_ONLY_ANNO NS_LITERAL_CSTRING("placesInternal/READ_ONLY")
    1: 
50437: 
50437: namespace {
50437: 
50437: struct keywordSearchData
50437: {
50437:   PRInt64 itemId;
50437:   nsString keyword;
50437: };
50437: 
50437: PLDHashOperator
50437: SearchBookmarkForKeyword(nsTrimInt64HashKey::KeyType aKey,
50437:                          const nsString aValue,
50437:                          void* aUserArg)
50437: {
50437:   keywordSearchData* data = reinterpret_cast<keywordSearchData*>(aUserArg);
50437:   if (data->keyword.Equals(aValue)) {
50437:     data->itemId = aKey;
50437:     return PL_DHASH_STOP;
50437:   }
50437:   return PL_DHASH_NEXT;
50437: }
50437: 
60944: template<typename Method, typename DataType>
60944: class AsyncGetBookmarksForURI : public AsyncStatementCallback
60944: {
60944: public:
60944:   AsyncGetBookmarksForURI(nsNavBookmarks* aBookmarksSvc,
60944:                           Method aCallback,
61984:                           const DataType& aData)
60944:   : mBookmarksSvc(aBookmarksSvc)
60944:   , mCallback(aCallback)
60944:   , mData(aData)
60944:   {
61984:   }
61984: 
61984:   void Init()
61984:   {
60944:     nsCOMPtr<mozIStorageStatement> stmt =
61984:       mBookmarksSvc->GetStatementById(DB_GET_BOOKMARKS_FOR_URI);
60944:     if (stmt) {
61984:       (void)URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), mData.uri);
60944:       nsCOMPtr<mozIStoragePendingStatement> pendingStmt;
60944:       (void)stmt->ExecuteAsync(this, getter_AddRefs(pendingStmt));
60944:     }
60944:   }
60944: 
60944:   NS_IMETHOD HandleResult(mozIStorageResultSet* aResultSet)
60944:   {
60944:     nsCOMPtr<mozIStorageRow> row;
60944:     while (NS_SUCCEEDED(aResultSet->GetNextRow(getter_AddRefs(row))) && row) {
60944:       nsresult rv = row->GetInt64(0, &mData.itemId);
60944:       NS_ENSURE_SUCCESS(rv, rv);
60944:       if (mCallback) {
60944:         ((*mBookmarksSvc).*mCallback)(mData);
60944:       }
60944:     }
60944:     return NS_OK;
60944:   }
60944: 
60944: private:
60944:   nsRefPtr<nsNavBookmarks> mBookmarksSvc;
60944:   Method mCallback;
60944:   DataType mData;
60944: };
60944: 
50437: } // Anonymous namespace.
50437: 
50437: 
33458: nsNavBookmarks::nsNavBookmarks() : mItemCount(0)
33458:                                  , mRoot(0)
59312:                                  , mMenuRoot(0)
59312:                                  , mTagsRoot(0)
59312:                                  , mUnfiledRoot(0)
59312:                                  , mToolbarRoot(0)
33458:                                  , mCanNotify(false)
33458:                                  , mCacheObservers("bookmark-observers")
37340:                                  , mShuttingDown(false)
59379:                                  , mBatching(false)
    1: {
35298:   NS_ASSERTION(!gBookmarksService,
35298:                "Attempting to create two instances of the service!");
35298:   gBookmarksService = this;
    1: }
    1: 
37340: 
    1: nsNavBookmarks::~nsNavBookmarks()
    1: {
35298:   NS_ASSERTION(gBookmarksService == this,
35298:                "Deleting a non-singleton instance of the service");
35298:   if (gBookmarksService == this)
35298:     gBookmarksService = nsnull;
    1: }
    1: 
37340: 
 1337: NS_IMPL_ISUPPORTS3(nsNavBookmarks,
 1337:                    nsINavBookmarksService,
 1337:                    nsINavHistoryObserver,
 1337:                    nsIAnnotationObserver)
    1: 
37340: 
    1: nsresult
    1: nsNavBookmarks::Init()
    1: {
42480:   NS_TIME_FUNCTION;
42480: 
35298:   nsNavHistory* history = nsNavHistory::GetHistoryService();
20874:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
20874:   mDBConn = history->GetStorageConnection();
37341:   NS_ENSURE_STATE(mDBConn);
59362: 
59362:   // Get our read-only cloned connection.
59362:   nsresult rv = mDBConn->Clone(PR_TRUE, getter_AddRefs(mDBReadOnlyConn));
59362:   NS_ENSURE_SUCCESS(rv, rv);
59362: 
59312:   PRUint16 dbStatus;
59362:   rv = history->GetDatabaseStatus(&dbStatus);
59312:   NS_ENSURE_SUCCESS(rv, rv);
59312:   rv = InitRoots(dbStatus != nsINavHistoryService::DATABASE_STATUS_OK);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874: 
30050:   mCanNotify = true;
30050: 
37341:   // Observe annotations.
20874:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
20874:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
20874:   annosvc->AddObserver(this);
20874: 
37341:   // Allows us to notify on title changes. MUST BE LAST so it is impossible
20874:   // to fail after this call, or the history service will have a reference to
20874:   // us and we won't go away.
20874:   history->AddObserver(this, PR_FALSE);
20874: 
20874:   // DO NOT PUT STUFF HERE that can fail. See observer comment above.
20874: 
20874:   return NS_OK;
20874: }
20874: 
37340: 
37341: /**
37341:  * All commands that initialize the database schema should be here.
37341:  * This is called from history init after database connection has been
37341:  * established.
37341:  */
20874: nsresult // static
20874: nsNavBookmarks::InitTables(mozIStorageConnection* aDBConn)
20874: {
20874:   PRBool exists;
20874:   nsresult rv = aDBConn->TableExists(NS_LITERAL_CSTRING("moz_bookmarks"), &exists);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   if (!exists) {
20874:     rv = aDBConn->ExecuteSimpleSQL(CREATE_MOZ_BOOKMARKS);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874: 
20874:     // This index will make it faster to determine if a given item is
20874:     // bookmarked (used by history queries and vacuuming, for example).
20874:     // Making it compound with "type" speeds up type-differentiation
20874:     // queries, such as expiration and search.
28193:     rv = aDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PLACETYPE);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874: 
20874:     // The most common operation is to find the children given a parent and position.
28193:     rv = aDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PARENTPOSITION);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874: 
20874:     // fast access to lastModified is useful during sync and to get
20874:     // last modified bookmark title for tags container's children.
28193:     rv = aDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PLACELASTMODIFIED);
20874:     NS_ENSURE_SUCCESS(rv, rv);
59370: 
59370:     // Selecting by guid needs to be fast.
59370:     rv = aDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_GUID);
59370:     NS_ENSURE_SUCCESS(rv, rv);
20874:   }
20874: 
20874:   rv = aDBConn->TableExists(NS_LITERAL_CSTRING("moz_bookmarks_roots"), &exists);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   if (!exists) {
20874:     rv = aDBConn->ExecuteSimpleSQL(CREATE_MOZ_BOOKMARKS_ROOTS);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874:   }
20874: 
20874:   rv = aDBConn->TableExists(NS_LITERAL_CSTRING("moz_keywords"), &exists);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   if (!exists) {
20874:     rv = aDBConn->ExecuteSimpleSQL(CREATE_MOZ_KEYWORDS);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874: 
20874:     // Create trigger to update as well
20874:     rv = aDBConn->ExecuteSimpleSQL(CREATE_KEYWORD_VALIDITY_TRIGGER);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874:   }
20874: 
20874:   return NS_OK;
20874: }
20874: 
20874: 
37341: mozIStorageStatement*
37341: nsNavBookmarks::GetStatement(const nsCOMPtr<mozIStorageStatement>& aStmt)
20874: {
37341:   if (mShuttingDown)
37341:     return nsnull;
37341: 
29518:   // Double ordering covers possible lastModified ties, that could happen when
29518:   // importing, syncing or due to extensions.
59296:   // Note: not using a JOIN is cheaper in this case.
37341:   RETURN_IF_STMT(mDBFindURIBookmarks, NS_LITERAL_CSTRING(
20868:     "SELECT b.id "
20868:     "FROM moz_bookmarks b "
59296:     "WHERE b.fk = (SELECT id FROM moz_places WHERE url = :page_url) "
37341:     "ORDER BY b.lastModified DESC, b.id DESC "));
37341: 
37341:   // Select all children of a given folder, sorted by position.
59316:   // This is a LEFT JOIN because not all bookmarks types have a place.
37341:   // We construct a result where the first columns exactly match those returned
37341:   // by mDBGetURLPageInfo, and additionally contains columns for position,
37341:   // item_child, and folder_child from moz_bookmarks.
37341:   RETURN_IF_STMT(mDBGetChildren, NS_LITERAL_CSTRING(
59296:     "SELECT h.id, h.url, IFNULL(b.title, h.title), h.rev_host, h.visit_count, "
59296:            "h.last_visit_date, f.url, null, b.id, b.dateAdded, b.lastModified, "
59296:            "b.parent, null, b.position, b.type, b.fk, b.folder_type "
20586:     "FROM moz_bookmarks b "
20868:     "LEFT JOIN moz_places h ON b.fk = h.id "
20868:     "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
41402:     "WHERE b.parent = :parent "
37341:     "ORDER BY b.position ASC"));
37341: 
37341:   // Count all of the children of a given folder and checks that it exists.
37341:   RETURN_IF_STMT(mDBFolderCount, NS_LITERAL_CSTRING(
31729:     "SELECT COUNT(*), "
41402:     "(SELECT id FROM moz_bookmarks WHERE id = :parent) "
41402:     "FROM moz_bookmarks WHERE parent = :parent"));
41402: 
37341:   RETURN_IF_STMT(mDBGetChildAt, NS_LITERAL_CSTRING(
37341:     "SELECT id, fk, type FROM moz_bookmarks "
41402:     "WHERE parent = :parent AND position = :item_index"));
37341: 
37341:   // Get bookmark/folder/separator properties.
59316:   // This is a LEFT JOIN because not all bookmarks types have a place.
37341:   RETURN_IF_STMT(mDBGetItemProperties, NS_LITERAL_CSTRING(
59316:     "SELECT b.id, h.url, b.title, b.position, b.fk, b.parent, b.type, "
59316:            "b.folder_type, b.dateAdded, b.lastModified "
20586:     "FROM moz_bookmarks b "
59316:     "LEFT JOIN moz_places h ON h.id = b.fk "
41402:     "WHERE b.id = :item_id"));
37341: 
37341:   RETURN_IF_STMT(mDBGetItemIdForGUID, NS_LITERAL_CSTRING(
20586:     "SELECT item_id FROM moz_items_annos "
41402:     "WHERE content = :guid "
37341:     "LIMIT 1"));
37341: 
37341:   RETURN_IF_STMT(mDBInsertBookmark, NS_LITERAL_CSTRING(
20868:     "INSERT INTO moz_bookmarks "
37341:       "(id, fk, type, parent, position, title, folder_type, "
59374:        "dateAdded, lastModified, guid) "
41402:     "VALUES (:item_id, :page_id, :item_type, :parent, :item_index, "
59374:             ":item_title, :folder_type, :date_added, :last_modified, "
59374:             "GENERATE_GUID())"));
37341: 
20586:   // Just select position since it's just an int32 and may be faster.
20586:   // We don't actually care about the data, just whether there is any.
37341:   RETURN_IF_STMT(mDBIsBookmarkedInDatabase, NS_LITERAL_CSTRING(
41402:     "SELECT 1 FROM moz_bookmarks WHERE fk = :page_id"));
39203: 
39203:   RETURN_IF_STMT(mDBIsURIBookmarkedInDatabase, NS_LITERAL_CSTRING(
59296:     "SELECT 1 FROM moz_bookmarks b "
59296:     "JOIN moz_places h ON b.fk = h.id "
59296:     "WHERE h.url = :page_url"));
39203: 
39203:   // Checks to make sure a place id is a bookmark, and isn't a livemark.
37341:   RETURN_IF_STMT(mDBIsRealBookmark, NS_LITERAL_CSTRING(
24324:     "SELECT id "
24324:     "FROM moz_bookmarks "
41402:     "WHERE fk = :page_id "
41402:       "AND type = :item_type "
24324:       "AND parent NOT IN ("
24324:         "SELECT a.item_id "
24324:         "FROM moz_items_annos a "
24324:         "JOIN moz_anno_attributes n ON a.anno_attribute_id = n.id "
41402:         "WHERE n.name = :anno_name"
59316:       ") "));
37341: 
37341:   RETURN_IF_STMT(mDBGetLastBookmarkID, NS_LITERAL_CSTRING(
20586:     "SELECT id "
20586:     "FROM moz_bookmarks "
20586:     "ORDER BY ROWID DESC "
37341:     "LIMIT 1"));
37341: 
29518:   // lastModified is set to the same value as dateAdded.  We do this for
29518:   // performance reasons, since it will allow us to use an index to sort items
29518:   // by date.
37341:   RETURN_IF_STMT(mDBSetItemDateAdded, NS_LITERAL_CSTRING(
41402:     "UPDATE moz_bookmarks SET dateAdded = :date, lastModified = :date "
41402:     "WHERE id = :item_id"));
37341: 
37341:   RETURN_IF_STMT(mDBSetItemLastModified, NS_LITERAL_CSTRING(
41402:     "UPDATE moz_bookmarks SET lastModified = :date WHERE id = :item_id"));
37341: 
37341:   RETURN_IF_STMT(mDBSetItemIndex, NS_LITERAL_CSTRING(
41402:     "UPDATE moz_bookmarks SET position = :item_index WHERE id = :item_id"));
37341: 
37341:   RETURN_IF_STMT(mDBGetKeywordForURI, NS_LITERAL_CSTRING(
20586:     "SELECT k.keyword "
59296:     "FROM moz_places h "
20868:     "JOIN moz_bookmarks b ON b.fk = h.id "
59296:     "JOIN moz_keywords k ON k.id = b.keyword_id "
59296:     "WHERE h.url = :page_url "));
37341: 
37340:   RETURN_IF_STMT(mDBAdjustPosition, NS_LITERAL_CSTRING(
41402:     "UPDATE moz_bookmarks SET position = position + :delta "
41402:     "WHERE parent = :parent "
59316:       "AND position BETWEEN :from_index AND :to_index"));
37340: 
37340:   RETURN_IF_STMT(mDBRemoveItem, NS_LITERAL_CSTRING(
41402:     "DELETE FROM moz_bookmarks WHERE id = :item_id"));
37340: 
37340:   RETURN_IF_STMT(mDBGetLastChildId, NS_LITERAL_CSTRING(
41402:     "SELECT id FROM moz_bookmarks WHERE parent = :parent "
37340:     "ORDER BY position DESC LIMIT 1"));
37340: 
37340:   RETURN_IF_STMT(mDBMoveItem, NS_LITERAL_CSTRING(
41402:     "UPDATE moz_bookmarks SET parent = :parent, position = :item_index "
41402:     "WHERE id = :item_id "));
37340: 
37340:   RETURN_IF_STMT(mDBSetItemTitle, NS_LITERAL_CSTRING(
41402:     "UPDATE moz_bookmarks SET title = :item_title, lastModified = :date "
41402:     "WHERE id = :item_id "));
37340: 
37340:   RETURN_IF_STMT(mDBChangeBookmarkURI, NS_LITERAL_CSTRING(
41402:     "UPDATE moz_bookmarks SET fk = :page_id, lastModified = :date "
41402:     "WHERE id = :item_id "));
37340: 
39203:   // The next query finds the bookmarked ancestors in a redirects chain.
39203:   // It won't go further than 3 levels of redirects (a->b->c->your_place_id).
39203:   // To make this path 100% correct (up to any level) we would need either:
39203:   //  - A separate hash, build through recursive querying of the database.
39203:   //    This solution was previously implemented, but it had a negative effect
39203:   //    on startup since at each startup we have to recursively query the
39203:   //    database to rebuild a hash that is always the same across sessions.
39203:   //    It must be updated at each visit and bookmarks change too.  The code to
39203:   //    manage it is complex and prone to errors, sometimes causing incorrect
39203:   //    data fetches (for example wrong favicon for a redirected bookmark).
39203:   //  - A better way to track redirects for a visit.
39203:   //    We would need a separate table to track redirects, in the table we would
39203:   //    have visit_id, redirect_session.  To get all sources for
39203:   //    a visit then we could just join this table and get all visit_id that
39203:   //    are in the same redirect_session as our visit.  This has the drawback
39203:   //    that we can't ensure data integrity in the downgrade -> upgrade path,
39203:   //    since an old version would not update the table on new visits.
39203:   //
39203:   // For most cases these levels of redirects should be fine though, it's hard
39203:   // to hit a page that is 4 or 5 levels of redirects below a bookmarked page.
39203:   //
39203:   // As a bonus the query also checks first if place_id is already a bookmark,
39203:   // so you don't have to check that apart.
39203: 
39203: #define COALESCE_PLACEID \
39203:   "COALESCE(greatgrandparent.place_id, grandparent.place_id, parent.place_id) "
39203: 
39203:   nsCString redirectsFragment =
39203:     nsPrintfCString(3, "%d,%d",
39203:                     nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
39203:                     nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY);
39203: 
39203:   RETURN_IF_STMT(mDBFindRedirectedBookmark, NS_LITERAL_CSTRING(
59296:     "SELECT "
41401:       "(SELECT url FROM moz_places WHERE id = :page_id) "
39203:     "FROM moz_bookmarks b "
41401:     "WHERE b.fk = :page_id "
39203:     "UNION ALL " // Not directly bookmarked.
59296:     "SELECT "
39203:       "(SELECT url FROM moz_places WHERE id = " COALESCE_PLACEID ") "
39203:     "FROM moz_historyvisits self "
39203:     "JOIN moz_bookmarks b ON b.fk = " COALESCE_PLACEID
39203:     "LEFT JOIN moz_historyvisits parent ON parent.id = self.from_visit "
39203:     "LEFT JOIN moz_historyvisits grandparent ON parent.from_visit = grandparent.id "
39203:       "AND parent.visit_type IN (") + redirectsFragment + NS_LITERAL_CSTRING(") "
39203:     "LEFT JOIN moz_historyvisits greatgrandparent ON grandparent.from_visit = greatgrandparent.id "
39203:       "AND grandparent.visit_type IN (") + redirectsFragment + NS_LITERAL_CSTRING(") "
39203:     "WHERE self.visit_type IN (") + redirectsFragment + NS_LITERAL_CSTRING(") "
41401:       "AND self.place_id = :page_id "
39203:     "LIMIT 1 " // Stop at the first result.
39203:   ));
39203: #undef COALESCE_PLACEID
39203: 
37340:   return nsnull;
37340: }
37340: 
37340: 
21642: nsresult
21642: nsNavBookmarks::FinalizeStatements() {
37340:   mShuttingDown = true;
37340: 
21642:   mozIStorageStatement* stmts[] = {
21642:     mDBGetChildren,
21642:     mDBFindURIBookmarks,
21642:     mDBFolderCount,
21642:     mDBGetChildAt,
21642:     mDBGetItemProperties,
21642:     mDBGetItemIdForGUID,
21642:     mDBInsertBookmark,
21642:     mDBIsBookmarkedInDatabase,
24324:     mDBIsRealBookmark,
21642:     mDBGetLastBookmarkID,
21642:     mDBSetItemDateAdded,
21642:     mDBSetItemLastModified,
21642:     mDBSetItemIndex,
21642:     mDBGetKeywordForURI,
37340:     mDBAdjustPosition,
37340:     mDBRemoveItem,
37340:     mDBGetLastChildId,
37340:     mDBMoveItem,
37340:     mDBSetItemTitle,
37340:     mDBChangeBookmarkURI,
39203:     mDBIsURIBookmarkedInDatabase,
39203:     mDBFindRedirectedBookmark,
21642:   };
21642: 
21642:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(stmts); i++) {
21642:     nsresult rv = nsNavHistory::FinalizeStatement(stmts[i]);
21642:     NS_ENSURE_SUCCESS(rv, rv);
21642:   }
21642: 
59362:   // Since we are shutting down, close the read-only connection.
59362:   (void)mDBReadOnlyConn->AsyncClose(nsnull);
59362: 
59374: #ifdef DEBUG
59374:   // Sanity check that all bookmarks have guids.
59374:   nsCOMPtr<mozIStorageStatement> stmt;
59374:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
59374:     "SELECT * "
59374:     "FROM moz_bookmarks "
59374:     "WHERE guid IS NULL "
59374:   ), getter_AddRefs(stmt));
59374:   NS_ENSURE_SUCCESS(rv, rv);
59374: 
59374:   PRBool haveNullGuids;
59374:   rv = stmt->ExecuteStep(&haveNullGuids);
59374:   NS_ENSURE_SUCCESS(rv, rv);
59374:   NS_ASSERTION(!haveNullGuids,
59374:                "Someone added a bookmark without adding a GUID!");
59374: #endif
59374: 
21642:   return NS_OK;
21642: }
20575: 
37340: 
    1: nsresult
59312: nsNavBookmarks::InitRoots(bool aForceCreate)
    1: {
59312:   nsCOMPtr<mozIStorageStatement> stmt;
59362:   nsresult rv = mDBReadOnlyConn->CreateStatement(NS_LITERAL_CSTRING(
59312:     "SELECT root_name, folder_id FROM moz_bookmarks_roots"
59312:   ), getter_AddRefs(stmt));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
59312:   PRBool hasResult;
59312:   while (NS_SUCCEEDED(stmt->ExecuteStep(&hasResult)) && hasResult) {
59312:     nsCAutoString rootName;
59312:     rv = stmt->GetUTF8String(0, rootName);
37340:     NS_ENSURE_SUCCESS(rv, rv);
59312:     PRInt64 rootId;
59312:     rv = stmt->GetInt64(1, &rootId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
59312:     NS_ABORT_IF_FALSE(rootId != 0, "Root id is 0, that is an invalid value.");
59312: 
59312:     if (rootName.EqualsLiteral("places")) {
59312:       mRoot = rootId;
 8193:     }
59312:     else if (rootName.EqualsLiteral("menu")) {
59312:       mMenuRoot = rootId;
 8193:     }
59312:     else if (rootName.EqualsLiteral("toolbar")) {
59312:       mToolbarRoot = rootId;
    1:     }
59312:     else if (rootName.EqualsLiteral("tags")) {
59312:       mTagsRoot = rootId;
    1:     }
59312:     else if (rootName.EqualsLiteral("unfiled")) {
59312:       mUnfiledRoot = rootId;
59312:     }
59312:   }
59312: 
59312:   if (aForceCreate) {
35298:     nsNavHistory* history = nsNavHistory::GetHistoryService();
35298:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
35298:     nsIStringBundle* bundle = history->GetBundle();
20877:     NS_ENSURE_TRUE(bundle, NS_ERROR_OUT_OF_MEMORY);
20877: 
59312:     mozStorageTransaction transaction(mDBConn, PR_FALSE);
59312: 
59312:     rv = CreateRoot(NS_LITERAL_CSTRING("places"), &mRoot, 0,
59312:                     nsnull, nsnull);
  543:     NS_ENSURE_SUCCESS(rv, rv);
59312: 
59312:     rv = CreateRoot(NS_LITERAL_CSTRING("menu"), &mMenuRoot, mRoot, bundle,
59312:                     NS_LITERAL_STRING("BookmarksMenuFolderTitle").get());
  543:     NS_ENSURE_SUCCESS(rv, rv);
  543: 
59312:     rv = CreateRoot(NS_LITERAL_CSTRING("toolbar"), &mToolbarRoot, mRoot, bundle,
59312:                     NS_LITERAL_STRING("BookmarksToolbarFolderTitle").get());
  543:     NS_ENSURE_SUCCESS(rv, rv);
59312: 
59312:     rv = CreateRoot(NS_LITERAL_CSTRING("tags"), &mTagsRoot, mRoot, bundle,
59312:                     NS_LITERAL_STRING("TagsFolderTitle").get());
  543:     NS_ENSURE_SUCCESS(rv, rv);
 8193: 
59312:     rv = CreateRoot(NS_LITERAL_CSTRING("unfiled"), &mUnfiledRoot, mRoot, bundle,
59312:                     NS_LITERAL_STRING("UnsortedBookmarksFolderTitle").get());
  543:     NS_ENSURE_SUCCESS(rv, rv);
59312: 
59312:     rv = transaction.Commit();
 8193:     NS_ENSURE_SUCCESS(rv, rv);
59379: 
59379:     if (!mBatching) {
59379:       ForceWALCheckpoint(mDBConn);
59379:     }
59312:   }
 5930: 
 2049:   return NS_OK;
 2049: }
 2049: 
37340: 
    1: nsresult
59312: nsNavBookmarks::CreateRoot(const nsCString& name,
59312:                            PRInt64* _itemId,
59312:                            PRInt64 aParentId,
59312:                            nsIStringBundle* aBundle,
59312:                            const PRUnichar* aTitleStringId)
    1: {
59312:   nsresult rv;
59312: 
59312:   if (*_itemId == 0) {
59312:     // The root does not exist.  Create a new untitled folder for it.
59312:     rv = CreateFolder(aParentId, EmptyCString(), DEFAULT_INDEX, _itemId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
59312: 
59312:     // Create a entry  in moz_bookmarks_roots to link the folder to the root.
59312:     nsCOMPtr<mozIStorageStatement> stmt;
20874:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
41402:       "INSERT INTO moz_bookmarks_roots (root_name, folder_id) "
41402:       "VALUES (:root_name, :item_id)"
59312:     ), getter_AddRefs(stmt));
    1:     NS_ENSURE_SUCCESS(rv, rv);
59312:     rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("root_name"), name);
    1:     NS_ENSURE_SUCCESS(rv, rv);
59312:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), *_itemId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
59312:     rv = stmt->Execute();
    1:     NS_ENSURE_SUCCESS(rv, rv);
59312:   }
59312: 
59312:   // Now set the title on the root.  Notice we do this regardless, to take in
59312:   // could title changes when schema changes.
59312:   if (aTitleStringId) {
59312:     nsXPIDLString title;
59312:     rv = aBundle->GetStringFromName(aTitleStringId, getter_Copies(title));
59312:     NS_ENSURE_SUCCESS(rv, rv);
59312:     rv = SetItemTitle(*_itemId, NS_ConvertUTF16toUTF8(title));
59312:     NS_ENSURE_SUCCESS(rv, rv);
59312:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
24324: PRBool
24324: nsNavBookmarks::IsRealBookmark(PRInt64 aPlaceId)
24324: {
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBIsRealBookmark);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), aPlaceId);
37340:   NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Binding failed");
41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_type"), TYPE_BOOKMARK);
37340:   NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Binding failed");
41402:   rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("anno_name"),
41402:                                   NS_LITERAL_CSTRING(LMANNO_FEEDURI));
37340:   NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "Binding failed");
24324: 
24324:   // If we get any rows, then there exists at least one bookmark corresponding
24324:   // to aPlaceId that is not a livemark item.
39203:   PRBool isBookmark;
37341:   rv = stmt->ExecuteStep(&isBookmark);
37340:   NS_WARN_IF_FALSE(NS_SUCCEEDED(rv), "ExecuteStep failed");
37340:   if (NS_SUCCEEDED(rv))
24324:     return isBookmark;
24324: 
24324:   return PR_FALSE;
24324: }
24324: 
37340: 
    1: // nsNavBookmarks::IsBookmarkedInDatabase
    1: //
24324: //    This checks to see if the specified place_id is actually bookmarked.
    1: 
    1: nsresult
    1: nsNavBookmarks::IsBookmarkedInDatabase(PRInt64 aPlaceId,
    1:                                        PRBool* aIsBookmarked)
    1: {
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBIsBookmarkedInDatabase);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), aPlaceId);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341:   rv = stmt->ExecuteStep(aIsBookmarked);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   return NS_OK;
37259: }
37259: 
37259: 
37259: nsresult
37340: nsNavBookmarks::AdjustIndices(PRInt64 aFolderId,
37340:                               PRInt32 aStartIndex,
37340:                               PRInt32 aEndIndex,
37259:                               PRInt32 aDelta)
37259: {
37340:   NS_ASSERTION(aStartIndex >= 0 && aEndIndex <= PR_INT32_MAX &&
37340:                aStartIndex <= aEndIndex, "Bad indices");
37340: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBAdjustPosition);
41402:   nsresult rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("delta"), aDelta);
37340:   NS_ENSURE_SUCCESS(rv, rv);
41402:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
37340:   NS_ENSURE_SUCCESS(rv, rv);
41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("from_index"), aStartIndex);
37340:   NS_ENSURE_SUCCESS(rv, rv);
41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("to_index"), aEndIndex);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340: 
37340:   rv = stmt->Execute();
37245:   NS_ENSURE_SUCCESS(rv, rv);
37259:  
37245:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetPlacesRoot(PRInt64* aRoot)
    1: {
    1:   *aRoot = mRoot;
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
 8193: nsNavBookmarks::GetBookmarksMenuFolder(PRInt64* aRoot)
    1: {
59312:   *aRoot = mMenuRoot;
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetToolbarFolder(PRInt64* aFolderId)
    1: {
59312:   *aFolderId = mToolbarRoot;
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
 8193: nsNavBookmarks::GetTagsFolder(PRInt64* aRoot)
    1: {
59312:   *aRoot = mTagsRoot;
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
 8193: nsNavBookmarks::GetUnfiledBookmarksFolder(PRInt64* aRoot)
 5930: {
 5930:   *aRoot = mUnfiledRoot;
 5930:   return NS_OK;
 5930: }
 5930: 
37340: 
29518: nsresult
29518: nsNavBookmarks::InsertBookmarkInDB(PRInt64 aItemId,
29518:                                    PRInt64 aPlaceId,
29518:                                    enum ItemType aItemType,
29518:                                    PRInt64 aParentId,
29518:                                    PRInt32 aIndex,
29518:                                    const nsACString& aTitle,
29518:                                    PRTime aDateAdded,
29518:                                    PRTime aLastModified,
29518:                                    const nsAString& aServiceContractId,
29518:                                    PRInt64* _newItemId)
29518: {
29518:   NS_ASSERTION(_newItemId, "Null pointer passed to InsertBookmarkInDB!");
29518: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBInsertBookmark);
29518:   nsresult rv;
29518:   if (aItemId && aItemId != -1)
41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
29518:   else
41402:     rv = stmt->BindNullByName(NS_LITERAL_CSTRING("item_id"));
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   if (aPlaceId && aPlaceId != -1)
41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), aPlaceId);
29518:   else
41402:     rv = stmt->BindNullByName(NS_LITERAL_CSTRING("page_id"));
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_type"), aItemType);
37341:   NS_ENSURE_SUCCESS(rv, rv);
41402:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aParentId);
37341:   NS_ENSURE_SUCCESS(rv, rv);
41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_index"), aIndex);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   // Support NULL titles.
29518:   if (aTitle.IsVoid())
41402:     rv = stmt->BindNullByName(NS_LITERAL_CSTRING("item_title"));
29518:   else
41402:     rv = stmt->BindUTF8StringByName(NS_LITERAL_CSTRING("item_title"), aTitle);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
41402:   if (aServiceContractId.IsEmpty()) {
41402:     rv = stmt->BindNullByName(NS_LITERAL_CSTRING("folder_type"));
41402:   }
41402:   else {
41402:     rv = stmt->BindStringByName(NS_LITERAL_CSTRING("folder_type"),
41402:                                 aServiceContractId);
41402:   }
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
41402:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("date_added"), aDateAdded);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
41402:   if (aLastModified) {
41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("last_modified"),
41402:                                aLastModified);
41402:   }
41402:   else {
41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("last_modified"), aDateAdded);
41402:   }
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   rv = stmt->Execute();
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   if (!aItemId || aItemId == -1) {
29518:     // Get the new inserted item id.
37342:     DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(lastInsertIdStmt, mDBGetLastBookmarkID);
29518:     PRBool hasResult;
37341:     rv = lastInsertIdStmt->ExecuteStep(&hasResult);
29518:     NS_ENSURE_SUCCESS(rv, rv);
29518:     NS_ENSURE_TRUE(hasResult, NS_ERROR_UNEXPECTED);
37341:     rv = lastInsertIdStmt->GetInt64(0, _newItemId);
37340:     NS_ENSURE_SUCCESS(rv, rv);
29518:   }
37340:   else {
29518:     *_newItemId = aItemId;
37340:   }
29518: 
29518:   // Update last modified date of the parent folder.
29518:   // XXX TODO: This should be done recursively for all ancestors, that would
29518:   //           be slow without a nested tree though.  See bug 408991.
37341:   rv = SetItemDateInternal(GetStatement(mDBSetItemLastModified),
37341:                            aParentId, aDateAdded);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   return NS_OK;
29518: }
29518: 
37340: 
 5930: NS_IMETHODIMP
29123: nsNavBookmarks::InsertBookmark(PRInt64 aFolder,
29123:                                nsIURI* aURI,
29123:                                PRInt32 aIndex,
10046:                                const nsACString& aTitle,
 1738:                                PRInt64* aNewBookmarkId)
    1: {
29123:   NS_ENSURE_ARG(aURI);
29123:   NS_ENSURE_ARG_POINTER(aNewBookmarkId);
29123: 
    1:   // You can pass -1 to indicate append, but no other negative number is allowed
    1:   if (aIndex < nsINavBookmarksService::DEFAULT_INDEX)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
35298:   nsNavHistory* history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
35298: 
16751:   // This is really a place ID
    1:   PRInt64 childID;
35298:   nsresult rv = history->GetUrlIdFor(aURI, &childID, PR_TRUE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 8275:   PRInt32 index;
31729:   PRInt32 folderCount;
31729:   rv = FolderCount(aFolder, &folderCount);
31729:   NS_ENSURE_SUCCESS(rv, rv);
31729:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
31729:       aIndex >= folderCount) {
31729:     index = folderCount;
31729:   }
31729:   else {
 8275:     index = aIndex;
    1:     rv = AdjustIndices(aFolder, index, PR_INT32_MAX, 1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 8275:   }
    1: 
29518:   rv = InsertBookmarkInDB(-1, childID, BOOKMARK, aFolder, index,
29518:                           aTitle, PR_Now(), nsnull, EmptyString(),
29518:                           aNewBookmarkId);
 1738:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
10669:   // XXX
10669:   // 0n import / fx 2 migration, is the frecency work going to slow us down?
10669:   // We might want to skip this stuff, as well as the frecency work
10669:   // caused by GetUrlIdFor() which calls InternalAddNewPage().
10669:   // If we do skip this, after import, we will
10669:   // need to call FixInvalidFrecenciesForExcludedPlaces().
10669:   // We might need to call it anyways, if items aren't properly annotated
10669:   // as livemarks feeds yet.
10669: 
10669:   nsCAutoString url;
29123:   rv = aURI->GetSpec(url);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
59298:   // Re-calculate the frecency for this moz_place entry since it was set to -1.
59298:   rv = history->UpdateFrecency(childID);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
59379:   if (!mBatching) {
59379:     ForceWALCheckpoint(mDBConn);
59379:   }
59379: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
56524:                    OnItemAdded(*aNewBookmarkId, aFolder, index, TYPE_BOOKMARK,
56524:                                aURI));
    1: 
 9553:   // If the bookmark has been added to a tag container, notify all
 9553:   // bookmark-folder result nodes which contain a bookmark for the new
 9553:   // bookmark's url
21350:   PRInt64 grandParentId;
21350:   rv = GetFolderIdForItem(aFolder, &grandParentId);
 9553:   NS_ENSURE_SUCCESS(rv, rv);
59312:   if (grandParentId == mTagsRoot) {
 9553:     // query for all bookmarks for that URI, notify for each
 9553:     nsTArray<PRInt64> bookmarks;
34260:     rv = GetBookmarkIdsForURITArray(aURI, bookmarks);
 9553:     NS_ENSURE_SUCCESS(rv, rv);
 9553: 
 9553:     if (bookmarks.Length()) {
 9553:       for (PRUint32 i = 0; i < bookmarks.Length(); i++) {
61371:         // Don't notify to the same tag entry we just added.
61371:         if (bookmarks[i] == *aNewBookmarkId) {
61371:           continue;
61371:         }
61371: 
37343:         NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                          nsINavBookmarkObserver,
37343:                          OnItemChanged(bookmarks[i], NS_LITERAL_CSTRING("tags"),
37343:                                        PR_FALSE, EmptyCString(), 0,
35298:                                        TYPE_BOOKMARK));
 9553:       }
 9553:     }
 9553:   }
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::RemoveItem(PRInt64 aItemId)
    1: {
24923:   NS_ENSURE_TRUE(aItemId != mRoot, NS_ERROR_INVALID_ARG);
24923: 
14272:   nsresult rv;
    1:   PRInt32 childIndex;
    1:   PRInt64 placeId, folderId;
37340:   PRInt32 itemType;
 1337:   nsCAutoString buffer;
 9553:   nsCAutoString spec;
 1337: 
    1:   { // scoping to ensure the statement gets reset
37342:     DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(getInfoStmt, mDBGetItemProperties);
41402:     rv = getInfoStmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:     PRBool hasResult;
37341:     rv = getInfoStmt->ExecuteStep(&hasResult);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     if (!hasResult)
    1:       return NS_ERROR_INVALID_ARG; // invalid bookmark id
    1: 
37341:     rv = getInfoStmt->GetInt32(kGetItemPropertiesIndex_Position, &childIndex);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     rv = getInfoStmt->GetInt64(kGetItemPropertiesIndex_PlaceID, &placeId);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     rv = getInfoStmt->GetInt64(kGetItemPropertiesIndex_Parent, &folderId);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     rv = getInfoStmt->GetInt32(kGetItemPropertiesIndex_Type, &itemType);
37340:     NS_ENSURE_SUCCESS(rv, rv);
 9553:     if (itemType == TYPE_BOOKMARK) {
37341:       rv = getInfoStmt->GetUTF8String(kGetItemPropertiesIndex_URI, spec);
 9553:       NS_ENSURE_SUCCESS(rv, rv);
 9553:     }
    1:   }
    1: 
14272:   if (itemType == TYPE_FOLDER) {
14272:     rv = RemoveFolder(aItemId);
14272:     NS_ENSURE_SUCCESS(rv, rv);
14272:     return NS_OK;
14272:   }
14272: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
35298:                    OnBeforeItemRemoved(aItemId, itemType));
26383: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
14272: 
14272:   // First, remove item annotations
14272:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
14272:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
14272:   rv = annosvc->RemoveItemAnnotations(aItemId);
14272:   NS_ENSURE_SUCCESS(rv, rv);
14272: 
37340:   {
37342:     DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBRemoveItem);
41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37340:     NS_ENSURE_SUCCESS(rv, rv);
37340:     rv = stmt->Execute();
37340:     NS_ENSURE_SUCCESS(rv, rv);
37340:   }
    1: 
    1:   if (childIndex != -1) {
    1:     rv = AdjustIndices(folderId, childIndex + 1, PR_INT32_MAX, -1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
37341:   rv = SetItemDateInternal(GetStatement(mDBSetItemLastModified),
37341:                            folderId, PR_Now());
 3360:   NS_ENSURE_SUCCESS(rv, rv);
 3360: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
59379:   if (!mBatching) {
59379:     ForceWALCheckpoint(mDBConn);
59379:   }
59379: 
10669:   if (itemType == TYPE_BOOKMARK) {
35298:     nsNavHistory* history = nsNavHistory::GetHistoryService();
35298:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
59298:     rv = history->UpdateFrecency(placeId);
10669:     NS_ENSURE_SUCCESS(rv, rv);
50437: 
50437:     rv = UpdateKeywordsHashForRemovedBookmark(aItemId);
50437:     NS_ENSURE_SUCCESS(rv, rv);
10669:   }
10669: 
61371:   bool isTagEntry = false;
61371:   if (itemType == TYPE_BOOKMARK) {
61371:     // Check if the removed bookmark was child of a tag container.
61371:     // This is done before notifying since during the notification the parent
61371:     // could be removed as well.
61371:     PRInt64 grandParentId;
61371:     rv = GetFolderIdForItem(folderId, &grandParentId);
61371:     NS_ENSURE_SUCCESS(rv, rv);
61371:     isTagEntry = grandParentId == mTagsRoot;
61371:   }
61371: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
35298:                    OnItemRemoved(aItemId, folderId, childIndex, itemType));
    1: 
61371:   if (isTagEntry) {
61371:     // Get all bookmarks pointing to the same uri as this tag entry and
61371:     // notify them that tags changed.
 9553:     nsCOMPtr<nsIURI> uri;
 9553:     rv = NS_NewURI(getter_AddRefs(uri), spec);
 9553:     NS_ENSURE_SUCCESS(rv, rv);
 9553:     nsTArray<PRInt64> bookmarks;
34260:     rv = GetBookmarkIdsForURITArray(uri, bookmarks);
 9553:     NS_ENSURE_SUCCESS(rv, rv);
 9553: 
 9553:     for (PRUint32 i = 0; i < bookmarks.Length(); i++) {
37343:       NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                        nsINavBookmarkObserver,
33340:                        OnItemChanged(bookmarks[i],
37343:                                      NS_LITERAL_CSTRING("tags"), PR_FALSE,
37343:                                      EmptyCString(), 0, TYPE_BOOKMARK));
 9553:     }
 9553:   }
61371: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
10046: nsNavBookmarks::CreateFolder(PRInt64 aParent, const nsACString& aName,
    1:                              PRInt32 aIndex, PRInt64* aNewFolder)
    1: {
29123:   // NOTE: aParent can be null for root creation, so not checked
29123:   NS_ENSURE_ARG_POINTER(aNewFolder);
29123: 
 4179:   // CreateContainerWithID returns the index of the new folder, but that's not
    1:   // used here.  To avoid any risk of corrupting data should this function
    1:   // be changed, we'll use a local variable to hold it.  The PR_TRUE argument
    1:   // will cause notifications to be sent to bookmark observers.
    1:   PRInt32 localIndex = aIndex;
37340:   nsresult rv = CreateContainerWithID(-1, aParent, aName, EmptyString(),
37340:                                       PR_TRUE, &localIndex, aNewFolder);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
37340: nsNavBookmarks::CreateDynamicContainer(PRInt64 aParent,
37340:                                        const nsACString& aName,
 4179:                                        const nsAString& aContractId,
 4179:                                        PRInt32 aIndex,
    1:                                        PRInt64* aNewFolder)
    1: {
37340:   NS_ENSURE_FALSE(aContractId.IsEmpty(), NS_ERROR_INVALID_ARG);
37340: 
37340:   nsresult rv = CreateContainerWithID(-1, aParent, aName, aContractId,
37340:                                       PR_FALSE, &aIndex, aNewFolder);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   return NS_OK;
    1: }
    1: 
37340: 
 4179: NS_IMETHODIMP
 4179: nsNavBookmarks::GetFolderReadonly(PRInt64 aFolder, PRBool* aResult)
 4179: {
29123:   NS_ENSURE_ARG_MIN(aFolder, 1);
29123:   NS_ENSURE_ARG_POINTER(aResult);
29123: 
 4179:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 4179:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
37340:   nsresult rv = annosvc->ItemHasAnnotation(aFolder, READ_ONLY_ANNO, aResult);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   return NS_OK;
 4179: }
 4179: 
37340: 
 4179: NS_IMETHODIMP
 4179: nsNavBookmarks::SetFolderReadonly(PRInt64 aFolder, PRBool aReadOnly)
 4179: {
29123:   NS_ENSURE_ARG_MIN(aFolder, 1);
29123: 
 4179:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 4179:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
37340:   nsresult rv;
 4179:   if (aReadOnly) {
37340:     rv = annosvc->SetItemAnnotationInt32(aFolder, READ_ONLY_ANNO, 1, 0,
 4179:                                          nsAnnotationService::EXPIRE_NEVER);
37340:     NS_ENSURE_SUCCESS(rv, rv);
 4179:   }
 4179:   else {
 4179:     PRBool hasAnno;
37340:     rv = annosvc->ItemHasAnnotation(aFolder, READ_ONLY_ANNO, &hasAnno);
37340:     NS_ENSURE_SUCCESS(rv, rv);
37340:     if (hasAnno) {
37340:       rv = annosvc->RemoveItemAnnotation(aFolder, READ_ONLY_ANNO);
37340:       NS_ENSURE_SUCCESS(rv, rv);
37340:     }
 4179:   }
 4179:   return NS_OK;
 4179: }
 4179: 
37340: 
    1: nsresult
37340: nsNavBookmarks::CreateContainerWithID(PRInt64 aItemId,
37340:                                       PRInt64 aParent,
10046:                                       const nsACString& aName,
 4179:                                       const nsAString& aContractId,
 4179:                                       PRBool aIsBookmarkFolder,
37340:                                       PRInt32* aIndex,
37340:                                       PRInt64* aNewFolder)
    1: {
    1:   // You can pass -1 to indicate append, but no other negative number is allowed
    1:   if (*aIndex < -1)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
 8275:   PRInt32 index;
31729:   PRInt32 folderCount;
31729:   nsresult rv = FolderCount(aParent, &folderCount);
31729:   NS_ENSURE_SUCCESS(rv, rv);
31729:   if (*aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
31729:       *aIndex >= folderCount) {
31729:     index = folderCount;
 8275:   } else {
 8275:     index = *aIndex;
 8275:     rv = AdjustIndices(aParent, index, PR_INT32_MAX, 1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 8275:   }
    1: 
29518:   ItemType containerType = aIsBookmarkFolder ? FOLDER
29518:                                              : DYNAMIC_CONTAINER;
29518:   rv = InsertBookmarkInDB(aItemId, nsnull, containerType, aParent, index,
29518:                           aName, PR_Now(), nsnull, aContractId, aNewFolder);
 3360:   NS_ENSURE_SUCCESS(rv, rv);
 3360: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
59379:   if (!mBatching) {
59379:     ForceWALCheckpoint(mDBConn);
59379:   }
59379: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
56524:                    OnItemAdded(*aNewFolder, aParent, index, containerType,
56524:                                nsnull));
    1: 
    1:   *aIndex = index;
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
37340: nsNavBookmarks::InsertSeparator(PRInt64 aParent,
37340:                                 PRInt32 aIndex,
 1347:                                 PRInt64* aNewItemId)
    1: {
29123:   NS_ENSURE_ARG_MIN(aParent, 1);
34632:   // -1 means "append", but no other negative value is allowed.
34632:   NS_ENSURE_ARG_MIN(aIndex, -1);
29123:   NS_ENSURE_ARG_POINTER(aNewItemId);
29123: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
 8275:   PRInt32 index;
31729:   PRInt32 folderCount;
31729:   nsresult rv = FolderCount(aParent, &folderCount);
31729:   NS_ENSURE_SUCCESS(rv, rv);
31729:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
31729:       aIndex >= folderCount) {
31729:     index = folderCount;
34632:   }
34632:   else {
 8275:     index = aIndex;
 8275:     rv = AdjustIndices(aParent, index, PR_INT32_MAX, 1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 8275:   }
    1: 
37340:   // Set a NULL title, not an empty title.
29518:   nsCString voidString;
29518:   voidString.SetIsVoid(PR_TRUE);
29518:   rv = InsertBookmarkInDB(-1, nsnull, SEPARATOR, aParent, index,
29518:                           voidString, PR_Now(), nsnull, EmptyString(),
29518:                           aNewItemId);
 3360:   NS_ENSURE_SUCCESS(rv, rv);
 3360: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
56524:                    OnItemAdded(*aNewItemId, aParent, index, TYPE_SEPARATOR,
56524:                                nsnull));
    1: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
11268: nsresult
37340: nsNavBookmarks::GetLastChildId(PRInt64 aFolderId, PRInt64* aItemId)
11268: {
37340:   NS_ASSERTION(aFolderId > 0, "Invalid folder id");
34632:   *aItemId = -1;
34632: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetLastChildId);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
37340:   NS_ENSURE_SUCCESS(rv, rv);
34632:   PRBool found;
37340:   rv = stmt->ExecuteStep(&found);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   if (found) {
37340:     rv = stmt->GetInt64(0, aItemId);
37340:     NS_ENSURE_SUCCESS(rv, rv);
37340:   }
24787: 
11268:   return NS_OK;
11268: }
11268: 
37340: 
11268: NS_IMETHODIMP
37340: nsNavBookmarks::GetIdForItemAt(PRInt64 aFolder,
37340:                                PRInt32 aIndex,
37340:                                PRInt64* aItemId)
11268: {
29123:   NS_ENSURE_ARG_MIN(aFolder, 1);
29123:   NS_ENSURE_ARG_POINTER(aItemId);
29123: 
34632:   *aItemId = -1;
34632: 
11268:   nsresult rv;
11268:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX) {
34632:     // Get last item within aFolder.
24787:     rv = GetLastChildId(aFolder, aItemId);
24787:     NS_ENSURE_SUCCESS(rv, rv);
34632:   }
34632:   else {
34632:     // Get the item in aFolder with position aIndex.
37342:     DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetChildAt);
41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolder);
37341:     NS_ENSURE_SUCCESS(rv, rv);
41402:     rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_index"), aIndex);
11268:     NS_ENSURE_SUCCESS(rv, rv);
11268: 
34632:     PRBool found;
37341:     rv = stmt->ExecuteStep(&found);
11268:     NS_ENSURE_SUCCESS(rv, rv);
37340:     if (found) {
37341:       rv = stmt->GetInt64(0, aItemId);
37340:       NS_ENSURE_SUCCESS(rv, rv);
37340:     }
11268:   }
11268:   return NS_OK;
11268: }
11268: 
37340: 
    1: nsresult 
37340: nsNavBookmarks::GetParentAndIndexOfFolder(PRInt64 aFolderId,
37340:                                           PRInt64* _aParent,
37340:                                           PRInt32* _aIndex)
    1: {
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aFolderId);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340: 
37340:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   NS_ENSURE_TRUE(hasResult, NS_ERROR_INVALID_ARG);
37340: 
37341:   rv = stmt->GetInt64(kGetItemPropertiesIndex_Parent, _aParent);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341:   rv = stmt->GetInt32(kGetItemPropertiesIndex_Position, _aIndex);
37340:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
37340: nsresult
14272: nsNavBookmarks::RemoveFolder(PRInt64 aFolderId)
    1: {
24923:   NS_ENSURE_TRUE(aFolderId != mRoot, NS_ERROR_INVALID_ARG);
24923: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
35298:                    OnBeforeItemRemoved(aFolderId, TYPE_FOLDER));
26383: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
 6420: 
14272:   nsresult rv;
 1297:   PRInt64 parent;
14272:   PRInt32 index, type;
 1297:   nsCAutoString folderType;
 1297:   {
37342:     DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(getInfoStmt, mDBGetItemProperties);
41402:     rv = getInfoStmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aFolderId);
 1297:     NS_ENSURE_SUCCESS(rv, rv);
 1297: 
37340:     PRBool hasResult;
37341:     rv = getInfoStmt->ExecuteStep(&hasResult);
37340:     NS_ENSURE_SUCCESS(rv, rv);
37340:     if (!hasResult) {
 1297:       return NS_ERROR_INVALID_ARG; // folder is not in the hierarchy
 1297:     }
 1297: 
37341:     rv = getInfoStmt->GetInt32(kGetItemPropertiesIndex_Type, &type);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:      rv = getInfoStmt->GetInt64(kGetItemPropertiesIndex_Parent, &parent);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     rv = getInfoStmt->GetInt32(kGetItemPropertiesIndex_Position, &index);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     rv = getInfoStmt->GetUTF8String(kGetItemPropertiesIndex_ServiceContractId,
37340:                                     folderType);
 1297:     NS_ENSURE_SUCCESS(rv, rv);
 1297:   }
 1297: 
37340:   // Ensure this is really a folder.
37340:   NS_ENSURE_TRUE(type == TYPE_FOLDER, NS_ERROR_INVALID_ARG);
14272: 
14272:   // First, remove item annotations
14272:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
14272:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
14272:   rv = annosvc->RemoveItemAnnotations(aFolderId);
14272:   NS_ENSURE_SUCCESS(rv, rv);
14272: 
    1:   // If this is a container bookmark, try to notify its service.
    1:   if (folderType.Length() > 0) {
20374:     // There is a type associated with this folder.
 4179:     nsCOMPtr<nsIDynamicContainer> bmcServ = do_GetService(folderType.get());
    1:     if (bmcServ) {
14272:       rv = bmcServ->OnContainerRemoving(aFolderId);
37340:       NS_WARN_IF_FALSE(NS_SUCCEEDED(rv),
37340:                        "Remove folder container notification failed.");
    1:     }
    1:   }
    1: 
 1297:   // Remove all of the folder's children
21350:   rv = RemoveFolderChildren(aFolderId);
21350:   NS_ENSURE_SUCCESS(rv, rv);
 1297: 
37340:   {
37340:     // Remove the folder from its parent.
37342:     DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBRemoveItem);
41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aFolderId);
37340:     NS_ENSURE_SUCCESS(rv, rv);
37340:     rv = stmt->Execute();
37340:     NS_ENSURE_SUCCESS(rv, rv);
37340:   }
    1: 
    1:   rv = AdjustIndices(parent, index + 1, PR_INT32_MAX, -1);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
37341:   rv = SetItemDateInternal(GetStatement(mDBSetItemLastModified),
37341:                            parent, PR_Now());
 3360:   NS_ENSURE_SUCCESS(rv, rv);
 3360: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
59379:   if (!mBatching) {
59379:     ForceWALCheckpoint(mDBConn);
59379:   }
59379: 
59312:   if (aFolderId == mToolbarRoot) {
59312:     mToolbarRoot = 0;
 1553:   }
 1553: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
35298:                    OnItemRemoved(aFolderId, parent, index, TYPE_FOLDER));
    1: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMPL_ISUPPORTS1(nsNavBookmarks::RemoveFolderTransaction, nsITransaction)
    1: 
    1: NS_IMETHODIMP
29123: nsNavBookmarks::GetRemoveFolderTransaction(PRInt64 aFolderId, nsITransaction** aResult)
    1: {
29123:   NS_ENSURE_ARG_MIN(aFolderId, 1);
29123:   NS_ENSURE_ARG_POINTER(aResult);
29123: 
    1:   // Create and initialize a RemoveFolderTransaction object that can be used to
    1:   // recreate the folder safely later. 
    1: 
    1:   RemoveFolderTransaction* rft = 
29123:     new RemoveFolderTransaction(aFolderId);
    1:   if (!rft)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*aResult = rft);
    1:   return NS_OK;
    1: }
    1: 
37340: 
21350: nsresult
21350: nsNavBookmarks::GetDescendantChildren(PRInt64 aFolderId,
21350:                                       PRInt64 aGrandParentId,
21350:                                       nsTArray<folderChildrenInfo>& aFolderChildrenArray) {
21350:   // New children will be added from this index on.
21350:   PRUint32 startIndex = aFolderChildrenArray.Length();
    1:   nsresult rv;
    1:   {
21350:     // Collect children informations.
37342:     DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetChildren);
41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRBool hasMore;
37341:     while (NS_SUCCEEDED(stmt->ExecuteStep(&hasMore)) && hasMore) {
21350:       folderChildrenInfo child;
37341:       rv = stmt->GetInt64(nsNavHistory::kGetInfoIndex_ItemId, &child.itemId);
37340:       NS_ENSURE_SUCCESS(rv, rv);
21350:       child.parentId = aFolderId;
21350:       child.grandParentId = aGrandParentId;
37340:       PRInt32 itemType;
37341:       rv = stmt->GetInt32(kGetChildrenIndex_Type, &itemType);
37340:       child.itemType = (PRUint16)itemType;
37340:       NS_ENSURE_SUCCESS(rv, rv);
37341:       rv = stmt->GetInt64(kGetChildrenIndex_PlaceID, &child.placeId);
37341:       NS_ENSURE_SUCCESS(rv, rv);
37341:       rv = stmt->GetInt32(kGetChildrenIndex_Position, &child.index);
37340:       NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:       if (child.itemType == TYPE_BOOKMARK) {
21350:         nsCAutoString URIString;
37341:         rv = stmt->GetUTF8String(nsNavHistory::kGetInfoIndex_URL, URIString);
21350:         NS_ENSURE_SUCCESS(rv, rv);
21350:         child.url = URIString;
    1:       }
21350:       else if (child.itemType == TYPE_FOLDER) {
21350:         nsCAutoString folderType;
37341:         rv = stmt->GetUTF8String(kGetChildrenIndex_ServiceContractId,
21350:                                  folderType);
21350:         NS_ENSURE_SUCCESS(rv, rv);
21350:         child.folderType = folderType;
    1:       }
21350:       // Append item to children's array.
21350:       aFolderChildrenArray.AppendElement(child);
    1:     }
21350:   }
21350: 
21350:   // Recursively call GetDescendantChildren for added folders.
21350:   // We start at startIndex since previous folders are checked
21350:   // by previous calls to this method.
21350:   PRUint32 childCount = aFolderChildrenArray.Length();
21350:   for (PRUint32 i = startIndex; i < childCount; i++) {
21350:     if (aFolderChildrenArray[i].itemType == TYPE_FOLDER) {
21350:       GetDescendantChildren(aFolderChildrenArray[i].itemId,
21350:                             aFolderId,
21350:                             aFolderChildrenArray);
21350:     }
21350:   }
21350: 
21350:   return NS_OK;
21350: }
21350: 
37340: 
21350: NS_IMETHODIMP
21350: nsNavBookmarks::RemoveFolderChildren(PRInt64 aFolderId)
21350: {
37340:   NS_ENSURE_ARG_MIN(aFolderId, 1);
37340: 
21350:   nsresult rv;
37340:   PRInt32 itemType;
21350:   PRInt64 grandParentId;
21350:   {
37342:     DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(getInfoStmt, mDBGetItemProperties);
41402:     rv = getInfoStmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aFolderId);
21350:     NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:     // Sanity check: ensure that item exists.
21350:     PRBool folderExists;
37341:     if (NS_FAILED(getInfoStmt->ExecuteStep(&folderExists)) || !folderExists)
21350:       return NS_ERROR_INVALID_ARG;
21350: 
21350:     // Sanity check: ensure that this is a folder.
37341:     rv = getInfoStmt->GetInt32(kGetItemPropertiesIndex_Type, &itemType);
37340:     NS_ENSURE_SUCCESS(rv, rv);
21350:     if (itemType != TYPE_FOLDER)
21350:       return NS_ERROR_INVALID_ARG;
21350: 
21350:     // Get the grandParent.
21350:     // We have to do this only once since recursion will give us other
21350:     // grandParents without the need of additional queries.
37341:     rv = getInfoStmt->GetInt64(kGetItemPropertiesIndex_Parent, &grandParentId);
37340:     NS_ENSURE_SUCCESS(rv, rv);
21350:   }
21350: 
21350:   // Fill folder children array recursively.
21350:   nsTArray<folderChildrenInfo> folderChildrenArray;
21350:   rv = GetDescendantChildren(aFolderId, grandParentId, folderChildrenArray);
21350:   NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:   // Build a string of folders whose children will be removed.
21350:   nsCString foldersToRemove;
21350:   for (PRUint32 i = 0; i < folderChildrenArray.Length(); i++) {
21350:     folderChildrenInfo child = folderChildrenArray[i];
26383: 
26383:     // Notify observers that we are about to remove this child.
37343:     NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                      nsINavBookmarkObserver,
35298:                      OnBeforeItemRemoved(child.itemId, child.itemType));
26383: 
21350:     if (child.itemType == TYPE_FOLDER) {
21350:       foldersToRemove.AppendLiteral(",");
21350:       foldersToRemove.AppendInt(child.itemId);
21350: 
21350:       // If this is a dynamic container, try to notify its service that we
21350:       // are going to remove it.
26383:       // XXX (bug 484094) this should use a bookmark observer!
21350:       if (child.folderType.Length() > 0) {
21350:         nsCOMPtr<nsIDynamicContainer> bmcServ =
21350:           do_GetService(child.folderType.get());
21350:         if (bmcServ) {
21350:           rv = bmcServ->OnContainerRemoving(child.itemId);
21350:           if (NS_FAILED(rv))
21350:             NS_WARNING("Remove folder container notification failed.");
21350:         }
21350:       }
21350:     }
21350:   }
21350: 
21350:   // Delete items from the database now.
21350:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
21350: 
24948:   nsCOMPtr<mozIStorageStatement> deleteStatement;
24948:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
21350:       "DELETE FROM moz_bookmarks "
41402:       "WHERE parent IN (:parent") +
21350:         foldersToRemove +
24948:       NS_LITERAL_CSTRING(")"),
24948:     getter_AddRefs(deleteStatement));
24948:   NS_ENSURE_SUCCESS(rv, rv);
41402:   rv = deleteStatement->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
24948:   NS_ENSURE_SUCCESS(rv, rv);
24948:   rv = deleteStatement->Execute();
21350:   NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:   // Clean up orphan items annotations.
21350:   rv = mDBConn->ExecuteSimpleSQL(
21350:     NS_LITERAL_CSTRING(
21350:       "DELETE FROM moz_items_annos "
21350:       "WHERE id IN ("
21350:         "SELECT a.id from moz_items_annos a "
21350:         "LEFT JOIN moz_bookmarks b ON a.item_id = b.id "
21350:         "WHERE b.id ISNULL)"));
21350:   NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:   // Set the lastModified date.
37341:   rv = SetItemDateInternal(GetStatement(mDBSetItemLastModified),
37341:                            aFolderId, PR_Now());
21350:   NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:   for (PRUint32 i = 0; i < folderChildrenArray.Length(); i++) {
21350:     folderChildrenInfo child = folderChildrenArray[i];
21350:     if (child.itemType == TYPE_BOOKMARK) {
21350:       PRInt64 placeId = child.placeId;
35298:       nsNavHistory* history = nsNavHistory::GetHistoryService();
35298:       NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
59298:       rv = history->UpdateFrecency(placeId);
    1:       NS_ENSURE_SUCCESS(rv, rv);
50437: 
50437:       rv = UpdateKeywordsHashForRemovedBookmark(child.itemId);
50437:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
21350:   }
21350: 
21350:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
21350: 
59379:   if (!mBatching) {
59379:     ForceWALCheckpoint(mDBConn);
59379:   }
59379: 
21350:   // Call observers in reverse order to serve children before their parent.
21350:   for (PRInt32 i = folderChildrenArray.Length() - 1; i >= 0 ; i--) {
21350:     folderChildrenInfo child = folderChildrenArray[i];
21350: 
37343:     NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                      nsINavBookmarkObserver,
37343:                      OnItemRemoved(child.itemId, child.parentId, child.index,
33340:                                    child.itemType));
21350: 
21350:     if (child.itemType == TYPE_BOOKMARK) {
21350:       // If the removed bookmark was a child of a tag container, notify all
21350:       // bookmark-folder result nodes which contain a bookmark for the removed
21350:       // bookmark's url.
21350: 
59312:       if (child.grandParentId == mTagsRoot) {
21350:         nsCOMPtr<nsIURI> uri;
21350:         rv = NS_NewURI(getter_AddRefs(uri), child.url);
21350:         NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:         nsTArray<PRInt64> bookmarks;
34260:         rv = GetBookmarkIdsForURITArray(uri, bookmarks);
21350:         NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:         if (bookmarks.Length()) {
21350:           for (PRUint32 i = 0; i < bookmarks.Length(); i++) {
37343:             NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                              nsINavBookmarkObserver,
33340:                              OnItemChanged(bookmarks[i],
37343:                                            NS_LITERAL_CSTRING("tags"), PR_FALSE,
37343:                                            EmptyCString(), 0, TYPE_BOOKMARK));
    1:           }
21350:         }
21350:       }
21350:     }
21350:   }
21350: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
 1726: nsNavBookmarks::MoveItem(PRInt64 aItemId, PRInt64 aNewParent, PRInt32 aIndex)
    1: {
24923:   NS_ENSURE_TRUE(aItemId != mRoot, NS_ERROR_INVALID_ARG);
37340:   NS_ENSURE_ARG_MIN(aItemId, 1);
37340:   NS_ENSURE_ARG_MIN(aNewParent, 1);
37340:   // -1 is append, but no other negative number is allowed.
37340:   NS_ENSURE_ARG_MIN(aIndex, -1);
 7122:   // Disallow making an item its own parent.
37340:   NS_ENSURE_TRUE(aItemId != aNewParent, NS_ERROR_INVALID_ARG);
 1297: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
 1297:   // get item properties
 1297:   nsresult rv;
 1297:   PRInt64 oldParent;
21350:   PRInt32 oldIndex;
37340:   PRInt32 itemType;
 1726:   nsCAutoString folderType;
    1:   {
37342:     DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(getInfoStmt, mDBGetItemProperties);
41402:     rv = getInfoStmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:     PRBool hasResult;
37341:     rv = getInfoStmt->ExecuteStep(&hasResult);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     if (!hasResult) {
    1:       return NS_ERROR_INVALID_ARG; // folder is not in the hierarchy
    1:     }
    1: 
37341:     rv = getInfoStmt->GetInt64(kGetItemPropertiesIndex_Parent, &oldParent);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     rv = getInfoStmt->GetInt32(kGetItemPropertiesIndex_Position, &oldIndex);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     rv = getInfoStmt->GetInt32(kGetItemPropertiesIndex_Type, &itemType);
37340:     NS_ENSURE_SUCCESS(rv, rv);
 1726:     if (itemType == TYPE_FOLDER) {
37341:       rv = getInfoStmt->GetUTF8String(kGetItemPropertiesIndex_ServiceContractId,
 1726:                                       folderType);
 1297:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
 1726:   }
    1: 
 1297:   // if parent and index are the same, nothing to do
 1297:   if (oldParent == aNewParent && oldIndex == aIndex)
 1297:     return NS_OK;
 1297: 
    1:   // Make sure aNewParent is not aFolder or a subfolder of aFolder
 1726:   if (itemType == TYPE_FOLDER) {
37340:     PRInt64 ancestorId = aNewParent;
37340: 
37340:     while (ancestorId) {
37340:       if (ancestorId == aItemId) {
    1:         return NS_ERROR_INVALID_ARG;
    1:       }
    1: 
37342:       DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(getInfoStmt, mDBGetItemProperties);
41402:       rv = getInfoStmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"),
41402:                                         ancestorId);
37340:       NS_ENSURE_SUCCESS(rv, rv);
37340: 
37340:       PRBool hasResult;
37341:       rv = getInfoStmt->ExecuteStep(&hasResult);
37340:       NS_ENSURE_SUCCESS(rv, rv);
37340:       if (hasResult) {
37341:         rv = getInfoStmt->GetInt64(kGetItemPropertiesIndex_Parent, &ancestorId);
37340:         NS_ENSURE_SUCCESS(rv, rv);
37340:       }
37340:       else {
37340:         break;
37340:       }
    1:     }
    1:   }
    1: 
 1297:   // calculate new index
    1:   PRInt32 newIndex;
31729:   PRInt32 folderCount;
31729:   rv = FolderCount(aNewParent, &folderCount);
31729:   NS_ENSURE_SUCCESS(rv, rv);
31729:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
31729:       aIndex >= folderCount) {
31729:     newIndex = folderCount;
    1:     // If the parent remains the same, then the folder is really being moved
    1:     // to count - 1 (since it's being removed from the old position)
 1297:     if (oldParent == aNewParent) {
    1:       --newIndex;
    1:     }
    1:   } else {
    1:     newIndex = aIndex;
    1: 
 1297:     if (oldParent == aNewParent && newIndex > oldIndex) {
    1:       // when an item is being moved lower in the same folder, the new index
    1:       // refers to the index before it was removed. Removal causes everything
    1:       // to shift up.
    1:       --newIndex;
    1:     }
    1:   }
    1: 
 1297:   // this is like the previous check, except this covers if
 1297:   // the specified index was -1 (append), and the calculated
 1297:   // new index is the same as the existing index
 1297:   if (aNewParent == oldParent && newIndex == oldIndex) {
    1:     // Nothing to do!
    1:     return NS_OK;
    1:   }
    1: 
 1297:   // adjust indices to account for the move
 2019:   // do this before we update the parent/index fields
 2019:   // or we'll re-adjust the index for the item we are moving
 1297:   if (oldParent == aNewParent) {
    1:     // We can optimize the updates if moving within the same container.
    1:     // We only shift the items between the old and new positions, since the
    1:     // insertion will offset the deletion.
    1:     if (oldIndex > newIndex) {
 1297:       rv = AdjustIndices(oldParent, newIndex, oldIndex - 1, 1);
37340:     }
37340:     else {
 1297:       rv = AdjustIndices(oldParent, oldIndex + 1, newIndex, -1);
    1:     }
37340:     NS_ENSURE_SUCCESS(rv, rv);
37340:   }
37340:   else {
    1:     // We're moving between containers, so this happens in two steps.
 1297:     // First, fill the hole from the removal from the old parent.
 1297:     rv = AdjustIndices(oldParent, oldIndex + 1, PR_INT32_MAX, -1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     // Now, make room in the new parent for the insertion.
14032:     rv = AdjustIndices(aNewParent, newIndex, PR_INT32_MAX, 1);
37340:     NS_ENSURE_SUCCESS(rv, rv);
37259:   }
37340: 
37340:   {
37340:     // Update parent and position.
37342:     DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBMoveItem);
41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aNewParent);
37340:     NS_ENSURE_SUCCESS(rv, rv);
41402:     rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_index"), newIndex);
37340:     NS_ENSURE_SUCCESS(rv, rv);
41402:     rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37340:     NS_ENSURE_SUCCESS(rv, rv);
37340:     rv = stmt->Execute();
37340:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
 2019: 
 3360:   PRTime now = PR_Now();
37341:   rv = SetItemDateInternal(GetStatement(mDBSetItemLastModified),
37341:                            oldParent, now);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341:   rv = SetItemDateInternal(GetStatement(mDBSetItemLastModified),
37341:                            aNewParent, now);
 3360:   NS_ENSURE_SUCCESS(rv, rv);
 3360: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
 1726:                    OnItemMoved(aItemId, oldParent, oldIndex, aNewParent,
35298:                                newIndex, itemType));
    1: 
 4179:   // notify dynamic container provider if there is one
 1726:   if (!folderType.IsEmpty()) {
 4179:     nsCOMPtr<nsIDynamicContainer> container =
 1726:       do_GetService(folderType.get(), &rv);
    1:     if (NS_SUCCEEDED(rv)) {
 1726:       rv = container->OnContainerMoved(aItemId, aNewParent, newIndex);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
37340: 
13203: nsresult
37340: nsNavBookmarks::SetItemDateInternal(mozIStorageStatement* aStatement,
37340:                                     PRInt64 aItemId,
37340:                                     PRTime aValue)
13203: {
37341:   NS_ENSURE_STATE(aStatement);
37341:   mozStorageStatementScoper scoper(aStatement);
37342: 
41402:   nsresult rv = aStatement->BindInt64ByName(NS_LITERAL_CSTRING("date"), aValue);
13203:   NS_ENSURE_SUCCESS(rv, rv);
41402:   rv = aStatement->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
13203:   NS_ENSURE_SUCCESS(rv, rv);
13203: 
13203:   rv = aStatement->Execute();
13203:   NS_ENSURE_SUCCESS(rv, rv);
13203: 
13203:   // note, we are not notifying the observers
13203:   // that the item has changed.
13203: 
13203:   return NS_OK;
13203: }
13203: 
37340: 
    1: NS_IMETHODIMP
 1604: nsNavBookmarks::SetItemDateAdded(PRInt64 aItemId, PRTime aDateAdded)
 1604: {
33340:   // GetItemType also ensures that aItemId points to a valid item.
33340:   PRUint16 itemType;
33340:   nsresult rv = GetItemType(aItemId, &itemType);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
13203: 
37341:   rv = SetItemDateInternal(GetStatement(mDBSetItemDateAdded),
37341:                            aItemId, aDateAdded);
33340:   NS_ENSURE_SUCCESS(rv, rv);
33340: 
33340:   // Note: mDBSetItemDateAdded also sets lastModified to aDateAdded.
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
13203:                    OnItemChanged(aItemId, NS_LITERAL_CSTRING("dateAdded"),
33340:                                  PR_FALSE,
33340:                                  nsPrintfCString(16, "%lld", aDateAdded),
37343:                                  aDateAdded, itemType));
 1604:   return NS_OK;
 1604: }
 1604: 
37340: 
 1604: NS_IMETHODIMP
37340: nsNavBookmarks::GetItemDateAdded(PRInt64 aItemId, PRTime* _dateAdded)
 1604: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
37340:   NS_ENSURE_ARG_POINTER(_dateAdded);
 1604: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
37340:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   NS_ENSURE_TRUE(hasResult, NS_ERROR_INVALID_ARG); // Invalid itemId.
37340: 
37341:   rv = stmt->GetInt64(kGetItemPropertiesIndex_DateAdded, _dateAdded);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340: 
37340:   return NS_OK;
 1604: }
 1604: 
37340: 
 1604: NS_IMETHODIMP
 1604: nsNavBookmarks::SetItemLastModified(PRInt64 aItemId, PRTime aLastModified)
 1604: {
33340:   // GetItemType also ensures that aItemId points to a valid item.
33340:   PRUint16 itemType;
33340:   nsresult rv = GetItemType(aItemId, &itemType);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
13203: 
37341:   rv = SetItemDateInternal(GetStatement(mDBSetItemLastModified),
37341:                            aItemId, aLastModified);
33340:   NS_ENSURE_SUCCESS(rv, rv);
33340: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
37343:                    OnItemChanged(aItemId, NS_LITERAL_CSTRING("lastModified"),
33340:                                  PR_FALSE,
33340:                                  nsPrintfCString(16, "%lld", aLastModified),
37343:                                  aLastModified, itemType));
 1604:   return NS_OK;
 1604: }
 1604: 
37340: 
 1604: NS_IMETHODIMP
 1604: nsNavBookmarks::GetItemLastModified(PRInt64 aItemId, PRTime* aLastModified)
 1604: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 1604:   NS_ENSURE_ARG_POINTER(aLastModified);
 1604: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   if (!hasResult)
 1604:     return NS_ERROR_INVALID_ARG; // invalid item id
 1604: 
37341:   rv = stmt->GetInt64(kGetItemPropertiesIndex_LastModified, aLastModified);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341:   return NS_OK;
 1604: }
 1604: 
37340: 
20874: nsresult
20874: nsNavBookmarks::GetGUIDBase(nsAString &aGUIDBase)
20874: {
20874:   if (!mGUIDBase.IsEmpty()) {
20874:     aGUIDBase = mGUIDBase;
20874:     return NS_OK;
20874:   }
20874: 
20874:   // generate a new GUID base for this session
20874:   nsCOMPtr<nsIUUIDGenerator> uuidgen =
20874:     do_GetService("@mozilla.org/uuid-generator;1");
20874:   NS_ENSURE_TRUE(uuidgen, NS_ERROR_OUT_OF_MEMORY);
20874:   nsID GUID;
20874:   nsresult rv = uuidgen->GenerateUUIDInPlace(&GUID);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   char GUIDChars[NSID_LENGTH];
20874:   GUID.ToProvidedString(GUIDChars);
20874:   CopyASCIItoUTF16(GUIDChars, mGUIDBase);
20874:   aGUIDBase = mGUIDBase;
20874:   return NS_OK;
20874: }
20874: 
37340: 
 1604: NS_IMETHODIMP
 4004: nsNavBookmarks::GetItemGUID(PRInt64 aItemId, nsAString& aGUID)
 4004: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
29123: 
 4004:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 4004:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 4004:   nsresult rv = annosvc->GetItemAnnotationString(aItemId, GUID_ANNO, aGUID);
 4004:   if (NS_SUCCEEDED(rv) || rv != NS_ERROR_NOT_AVAILABLE)
 4004:     return rv;
 4004: 
 4004:   nsAutoString tmp;
 4004:   tmp.AppendInt(mItemCount++);
10204:   aGUID.SetCapacity(NSID_LENGTH - 1 + tmp.Length());
20874:   nsString GUIDBase;
20874:   rv = GetGUIDBase(GUIDBase);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   aGUID.Assign(GUIDBase);
10204:   aGUID.Append(tmp);
 4004: 
37340:   rv = SetItemGUID(aItemId, aGUID);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   return NS_OK;
 4004: }
 4004: 
37340: 
 4004: NS_IMETHODIMP
 4004: nsNavBookmarks::SetItemGUID(PRInt64 aItemId, const nsAString& aGUID)
 4004: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
29123: 
 4004:   PRInt64 checkId;
 4004:   GetItemIdForGUID(aGUID, &checkId);
 4004:   if (checkId != -1)
 4004:     return NS_ERROR_INVALID_ARG; // invalid GUID, already exists
 4004: 
 4004:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 4004:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
37340:   nsresult rv = annosvc->SetItemAnnotationString(aItemId, GUID_ANNO, aGUID, 0,
 4004:                                                  nsIAnnotationService::EXPIRE_NEVER);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   return NS_OK;
 4004: }
 4004: 
37340: 
 4004: NS_IMETHODIMP
 4004: nsNavBookmarks::GetItemIdForGUID(const nsAString& aGUID, PRInt64* aItemId)
 4004: {
29123:   NS_ENSURE_ARG_POINTER(aItemId);
29123: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemIdForGUID);
41402:   nsresult rv = stmt->BindStringByName(NS_LITERAL_CSTRING("guid"), aGUID);
 4004:   NS_ENSURE_SUCCESS(rv, rv);
 4004: 
 4004:   PRBool hasMore = PR_FALSE;
37341:   rv = stmt->ExecuteStep(&hasMore);
 4004:   if (NS_FAILED(rv) || ! hasMore) {
 4004:     *aItemId = -1;
 4004:     return NS_OK; // not found: return -1
 4004:   }
 4004: 
 4004:   // found, get the itemId
37341:   rv = stmt->GetInt64(0, aItemId);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   return NS_OK;
 4004: }
 4004: 
37340: 
 4004: NS_IMETHODIMP
10046: nsNavBookmarks::SetItemTitle(PRInt64 aItemId, const nsACString& aTitle)
    1: {
33340:   // GetItemType also ensures that aItemId points to a valid item.
33340:   PRUint16 itemType;
33340:   nsresult rv = GetItemType(aItemId, &itemType);
33340:   NS_ENSURE_SUCCESS(rv, rv);
29123: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(statement, mDBSetItemTitle);
27919:   // Support setting a null title, we support this in insertBookmark.
27919:   if (aTitle.IsVoid())
41402:     rv = statement->BindNullByName(NS_LITERAL_CSTRING("item_title"));
27919:   else
41402:     rv = statement->BindUTF8StringByName(NS_LITERAL_CSTRING("item_title"), aTitle);
    1:   NS_ENSURE_SUCCESS(rv, rv);
29518:   PRTime lastModified = PR_Now();
41402:   rv = statement->BindInt64ByName(NS_LITERAL_CSTRING("date"), lastModified);
    1:   NS_ENSURE_SUCCESS(rv, rv);
41402:   rv = statement->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
14289:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = statement->Execute();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
37343:                    OnItemChanged(aItemId, NS_LITERAL_CSTRING("title"), PR_FALSE,
37343:                                  aTitle, lastModified, itemType));
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
10046: nsNavBookmarks::GetItemTitle(PRInt64 aItemId, nsACString& aTitle)
    1: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
29123: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   if (!hasResult)
    1:     return NS_ERROR_INVALID_ARG; // invalid bookmark id
    1: 
37341:   rv = stmt->GetUTF8String(kGetItemPropertiesIndex_Title, aTitle);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetBookmarkURI(PRInt64 aItemId, nsIURI** aURI)
    1: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
    1:   NS_ENSURE_ARG_POINTER(aURI);
    1: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   if (!hasResult)
    1:     return NS_ERROR_INVALID_ARG; // invalid bookmark id
    1: 
37340:   PRInt32 type;
37341:   rv = stmt->GetInt32(kGetItemPropertiesIndex_Type, &type);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   // Ensure this is a bookmark.
37340:   NS_ENSURE_TRUE(type == TYPE_BOOKMARK, NS_ERROR_INVALID_ARG);
 1297: 
    1:   nsCAutoString spec;
37341:   rv = stmt->GetUTF8String(kGetItemPropertiesIndex_URI, spec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = NS_NewURI(aURI, spec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
37340: nsNavBookmarks::GetItemType(PRInt64 aItemId, PRUint16* _type)
    1: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
37340:   NS_ENSURE_ARG_POINTER(_type);
29123: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   if (!hasResult) {
    1:     return NS_ERROR_INVALID_ARG; // invalid bookmark id
 1297:   }
    1: 
37340:   PRInt32 itemType;
37341:   rv = stmt->GetInt32(kGetItemPropertiesIndex_Type, &itemType);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   *_type = itemType;
37340: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: nsresult
    1: nsNavBookmarks::GetFolderType(PRInt64 aFolder, nsACString& aType)
    1: {
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aFolder);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   if (!hasResult) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
37341:   return stmt->GetUTF8String(kGetItemPropertiesIndex_ServiceContractId, aType);
    1: }
    1: 
37340: 
    1: nsresult
 4179: nsNavBookmarks::ResultNodeForContainer(PRInt64 aID,
    1:                                        nsNavHistoryQueryOptions* aOptions,
    1:                                        nsNavHistoryResultNode** aNode)
    1: {
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aID);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341:   NS_ENSURE_TRUE(hasResult, NS_ERROR_INVALID_ARG);
 4179: 
33458:   nsCAutoString title;
37341:   rv = stmt->GetUTF8String(kGetItemPropertiesIndex_Title, title);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340: 
37340:   PRInt32 itemType;
37341:   rv = stmt->GetInt32(kGetItemPropertiesIndex_Type, &itemType);
37340:   NS_ENSURE_SUCCESS(rv, rv);
33458:   if (itemType == TYPE_DYNAMIC_CONTAINER) {
 4179:     // contract id
 4179:     nsCAutoString contractId;
37341:     rv = stmt->GetUTF8String(kGetItemPropertiesIndex_ServiceContractId,
 4179:                              contractId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
37341:     *aNode = new nsNavHistoryContainerResultNode(EmptyCString(), title,
37341:                                                  EmptyCString(),
 4179:                                                  nsINavHistoryResultNode::RESULT_TYPE_DYNAMIC_CONTAINER,
37341:                                                  PR_TRUE, contractId, aOptions);
 4179:     (*aNode)->mItemId = aID;
37340:   }
37340:   else { // TYPE_FOLDER
33458:     *aNode = new nsNavHistoryFolderResultNode(title, aOptions, aID, EmptyCString());
 4179:   }
    1:   if (!*aNode)
    1:     return NS_ERROR_OUT_OF_MEMORY;
 1635: 
37341:   rv = stmt->GetInt64(kGetItemPropertiesIndex_DateAdded,
37340:                       &(*aNode)->mDateAdded);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37341:   rv = stmt->GetInt64(kGetItemPropertiesIndex_LastModified,
37340:                       &(*aNode)->mLastModified);
37340:   NS_ENSURE_SUCCESS(rv, rv);
 1635: 
    1:   NS_ADDREF(*aNode);
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: nsresult
40626: nsNavBookmarks::QueryFolderChildren(
40626:   PRInt64 aFolderId,
    1:   nsNavHistoryQueryOptions* aOptions,
    1:   nsCOMArray<nsNavHistoryResultNode>* aChildren)
    1: {
40626:   NS_ENSURE_ARG_POINTER(aOptions);
40626:   NS_ENSURE_ARG_POINTER(aChildren);
40626: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetChildren);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
37341:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
40626:   nsCOMPtr<mozIStorageValueArray> row = do_QueryInterface(stmt, &rv);
20374:   NS_ENSURE_SUCCESS(rv, rv);
20374: 
    1:   PRInt32 index = -1;
37341:   PRBool hasResult;
37341:   while (NS_SUCCEEDED(stmt->ExecuteStep(&hasResult)) && hasResult) {
40626:     rv = ProcessFolderNodeRow(row, aOptions, aChildren, index);
40626:     NS_ENSURE_SUCCESS(rv, rv);
40626:   }
40626: 
40626:   return NS_OK;
40626: }
40626: 
40626: 
40626: nsresult
40626: nsNavBookmarks::ProcessFolderNodeRow(
40626:   mozIStorageValueArray* aRow,
40626:   nsNavHistoryQueryOptions* aOptions,
40626:   nsCOMArray<nsNavHistoryResultNode>* aChildren,
40626:   PRInt32& aCurrentIndex)
40626: {
40626:   NS_ENSURE_ARG_POINTER(aRow);
40626:   NS_ENSURE_ARG_POINTER(aOptions);
40626:   NS_ENSURE_ARG_POINTER(aChildren);
40626: 
40626:   // The results will be in order of aCurrentIndex. Even if we don't add a node
40626:   // because it was excluded, we need to count its index, so do that before
40626:   // doing anything else.
40626:   aCurrentIndex++;
    1: 
37340:   PRInt32 itemType;
40626:   nsresult rv = aRow->GetInt32(kGetChildrenIndex_Type, &itemType);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   PRInt64 id;
40626:   rv = aRow->GetInt64(nsNavHistory::kGetInfoIndex_ItemId, &id);
37340:   NS_ENSURE_SUCCESS(rv, rv);
 7025:   nsRefPtr<nsNavHistoryResultNode> node;
11421:   if (itemType == TYPE_BOOKMARK) {
35298:     nsNavHistory* history = nsNavHistory::GetHistoryService();
35298:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
40626:     rv = history->RowToResult(aRow, aOptions, getter_AddRefs(node));
11421:     NS_ENSURE_SUCCESS(rv, rv);
11421: 
11421:     PRUint32 nodeType;
11421:     node->GetType(&nodeType);
11421:     if ((nodeType == nsINavHistoryResultNode::RESULT_TYPE_QUERY &&
11421:          aOptions->ExcludeQueries()) ||
11421:         (nodeType != nsINavHistoryResultNode::RESULT_TYPE_QUERY &&
11421:          nodeType != nsINavHistoryResultNode::RESULT_TYPE_FOLDER_SHORTCUT &&
11421:          aOptions->ExcludeItems())) {
40626:       return NS_OK;
11421:     }
40626:   }
40626:   else if (itemType == TYPE_FOLDER || itemType == TYPE_DYNAMIC_CONTAINER) {
40626:     if (aOptions->ExcludeReadOnlyFolders()) {
40626:       // If the folder is read-only, skip it.
40626:       PRBool readOnly;
40626:       if (itemType == TYPE_DYNAMIC_CONTAINER) {
40626:         readOnly = PR_TRUE;
40626:       }
40626:       else {
40626:         readOnly = PR_FALSE;
 1297:         GetFolderReadonly(id, &readOnly);
40626:       }
    1:       if (readOnly)
40626:         return NS_OK;
    1:     }
 4179:     rv = ResultNodeForContainer(id, aOptions, getter_AddRefs(node));
40626:     NS_ENSURE_SUCCESS(rv, rv);
40626:   }
40626:   else {
40626:     // This is a separator.
    1:     if (aOptions->ExcludeItems()) {
40626:       return NS_OK;
    1:     }
    1:     node = new nsNavHistorySeparatorResultNode();
    1:     NS_ENSURE_TRUE(node, NS_ERROR_OUT_OF_MEMORY);
  809: 
40626:     rv = aRow->GetInt64(nsNavHistory::kGetInfoIndex_ItemId, &node->mItemId);
37340:     NS_ENSURE_SUCCESS(rv, rv);
40626:     rv = aRow->GetInt64(nsNavHistory::kGetInfoIndex_ItemDateAdded,
37340:                         &node->mDateAdded);
37340:     NS_ENSURE_SUCCESS(rv, rv);
40626:     rv = aRow->GetInt64(nsNavHistory::kGetInfoIndex_ItemLastModified,
37340:                         &node->mLastModified);
37340:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
40626:   // Store the index of the node within this container.  Note that this is not
40626:   // moz_bookmarks.position.
40626:   node->mBookmarkIndex = aCurrentIndex;
    1: 
    1:   NS_ENSURE_TRUE(aChildren->AppendObject(node), NS_ERROR_OUT_OF_MEMORY);
40626: 
40626:   return NS_OK;
    1: }
40626: 
40626: 
40626: nsresult
40626: nsNavBookmarks::QueryFolderChildrenAsync(
40626:   nsNavHistoryFolderResultNode* aNode,
40626:   PRInt64 aFolderId,
40626:   mozIStoragePendingStatement** _pendingStmt)
40626: {
40626:   NS_ENSURE_ARG_POINTER(aNode);
40626:   NS_ENSURE_ARG_POINTER(_pendingStmt);
40626: 
40626:   mozStorageStatementScoper scope(mDBGetChildren);
40626: 
41402:   nsresult rv = mDBGetChildren->BindInt64ByName(NS_LITERAL_CSTRING("parent"),
41402:                                                 aFolderId);
40626:   NS_ENSURE_SUCCESS(rv, rv);
40626: 
40626:   nsCOMPtr<mozIStoragePendingStatement> pendingStmt;
40626:   rv = mDBGetChildren->ExecuteAsync(aNode, getter_AddRefs(pendingStmt));
40626:   NS_ENSURE_SUCCESS(rv, rv);
40626: 
40626:   NS_IF_ADDREF(*_pendingStmt = pendingStmt);
    1:   return NS_OK;
    1: }
    1: 
37340: 
31729: nsresult
37340: nsNavBookmarks::FolderCount(PRInt64 aFolderId, PRInt32* _folderCount)
    1: {
37340:   *_folderCount = 0;
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBFolderCount);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("parent"), aFolderId);
31729:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
37340:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   NS_ENSURE_TRUE(hasResult, NS_ERROR_UNEXPECTED);
    1: 
31729:   // Ensure that the folder we are looking for exists.
37340:   PRInt64 confirmFolderId;
37341:   rv = stmt->GetInt64(1, &confirmFolderId);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   NS_ENSURE_TRUE(confirmFolderId == aFolderId, NS_ERROR_INVALID_ARG);
37340: 
37341:   rv = stmt->GetInt32(0, _folderCount);
37340:   NS_ENSURE_SUCCESS(rv, rv);
31729: 
31729:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::IsBookmarked(nsIURI* aURI, PRBool* aBookmarked)
    1: {
14272:   NS_ENSURE_ARG(aURI);
29123:   NS_ENSURE_ARG_POINTER(aBookmarked);
14272: 
39203:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBIsURIBookmarkedInDatabase);
41402:   nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
39203:   rv = stmt->ExecuteStep(aBookmarked);
39203:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetBookmarkedURIFor(nsIURI* aURI, nsIURI** _retval)
    1: {
29123:   NS_ENSURE_ARG(aURI);
29123:   NS_ENSURE_ARG_POINTER(_retval);
29123: 
    1:   *_retval = nsnull;
    1: 
35298:   nsNavHistory* history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
39203:   PRInt64 placeId;
51509:   nsresult rv = history->GetUrlIdFor(aURI, &placeId, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
39203:   if (!placeId) {
39203:     // This URI is unknown, just return null.
    1:     return NS_OK;
    1:   }
    1: 
39203:   // Check if a bookmark exists in the redirects chain for this URI.
39203:   // The query will also check if the page is directly bookmarked, and return
39203:   // the first found bookmark in case.  The check is directly on moz_bookmarks
39203:   // without special filtering.
39203:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBFindRedirectedBookmark);
41401:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), placeId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
39203:   PRBool hasBookmarkedOrigin;
39203:   if (NS_SUCCEEDED(stmt->ExecuteStep(&hasBookmarkedOrigin)) &&
39203:       hasBookmarkedOrigin) {
    1:     nsCAutoString spec;
39203:     rv = stmt->GetUTF8String(0, spec);
39203:     NS_ENSURE_SUCCESS(rv, rv);
39203:     rv = NS_NewURI(_retval, spec);
39203:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
39203: 
39203:   // If there is no bookmarked origin, we will just return null.
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::ChangeBookmarkURI(PRInt64 aBookmarkId, nsIURI* aNewURI)
    1: {
29123:   NS_ENSURE_ARG_MIN(aBookmarkId, 1);
 1337:   NS_ENSURE_ARG(aNewURI);
 1337: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
35298:   nsNavHistory* history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
35298: 
    1:   PRInt64 placeId;
35298:   nsresult rv = history->GetUrlIdFor(aNewURI, &placeId, PR_TRUE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!placeId)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
23593:   // We need the bookmark's current corresponding places ID below, so get it now
23593:   // before we change it.  GetBookmarkURI will fail if aBookmarkId is bad.
23593:   nsCOMPtr<nsIURI> oldURI;
23593:   PRInt64 oldPlaceId;
23593:   rv = GetBookmarkURI(aBookmarkId, getter_AddRefs(oldURI));
23593:   NS_ENSURE_SUCCESS(rv, rv);
35298:   rv = history->GetUrlIdFor(oldURI, &oldPlaceId, PR_FALSE);
23593:   NS_ENSURE_SUCCESS(rv, rv);
23593: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(statement, mDBChangeBookmarkURI);
41402:   rv = statement->BindInt64ByName(NS_LITERAL_CSTRING("page_id"), placeId);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518:   PRTime lastModified = PR_Now();
41402:   rv = statement->BindInt64ByName(NS_LITERAL_CSTRING("date"), lastModified);
29518:   NS_ENSURE_SUCCESS(rv, rv);
41402:   rv = statement->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aBookmarkId);
29518:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = statement->Execute();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
59298:   rv = history->UpdateFrecency(placeId);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
59298:   // Upon changing the URI for a bookmark, update the frecency for the old
59298:   // place as well.
59298:   rv = history->UpdateFrecency(oldPlaceId);
23593:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
 1337:   nsCAutoString spec;
 1337:   rv = aNewURI->GetSpec(spec);
 1337:   NS_ENSURE_SUCCESS(rv, rv);
 1337: 
    1:   // Pass the new URI to OnItemChanged.
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
37343:                    OnItemChanged(aBookmarkId, NS_LITERAL_CSTRING("uri"),
37343:                                  PR_FALSE, spec, lastModified, TYPE_BOOKMARK));
    1: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetFolderIdForItem(PRInt64 aItemId, PRInt64* aFolderId)
    1: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
    1:   NS_ENSURE_ARG_POINTER(aFolderId);
    1: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   if (!hasResult)
    1:     return NS_ERROR_INVALID_ARG; // invalid item id
    1: 
37341:   rv = stmt->GetInt64(kGetItemPropertiesIndex_Parent, aFolderId);
 7122:   NS_ENSURE_SUCCESS(rv, rv);
 7122: 
 7122:   // this should not happen, but see bug #400448 for details
 7122:   NS_ENSURE_TRUE(aItemId != *aFolderId, NS_ERROR_UNEXPECTED);
 7122:   return NS_OK;
    1: }
    1: 
37340: 
34260: nsresult
    1: nsNavBookmarks::GetBookmarkIdsForURITArray(nsIURI* aURI,
34260:                                            nsTArray<PRInt64>& aResult)
    1: {
29123:   NS_ENSURE_ARG(aURI);
29123: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBFindURIBookmarks);
41402:   nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), aURI);
37341:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool more;
37341:   while (NS_SUCCEEDED((rv = stmt->ExecuteStep(&more))) && more) {
37340:     PRInt64 bookmarkId;
37341:     rv = stmt->GetInt64(kFindBookmarksIndex_ID, &bookmarkId);
37340:     NS_ENSURE_SUCCESS(rv, rv);
37340:     NS_ENSURE_TRUE(aResult.AppendElement(bookmarkId), NS_ERROR_OUT_OF_MEMORY);
37259:   }
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340: 
11421:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetBookmarkIdsForURI(nsIURI* aURI, PRUint32* aCount,
    1:                                      PRInt64** aBookmarks)
    1: {
29123:   NS_ENSURE_ARG(aURI);
29123:   NS_ENSURE_ARG_POINTER(aCount);
29123:   NS_ENSURE_ARG_POINTER(aBookmarks);
29123: 
    1:   *aCount = 0;
    1:   *aBookmarks = nsnull;
    1:   nsTArray<PRInt64> bookmarks;
    1: 
    1:   // Get the information from the DB as a TArray
34260:   nsresult rv = GetBookmarkIdsForURITArray(aURI, bookmarks);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Copy the results into a new array for output
    1:   if (bookmarks.Length()) {
37340:     *aBookmarks =
37340:       static_cast<PRInt64*>(nsMemory::Alloc(sizeof(PRInt64) * bookmarks.Length()));
    1:     if (!*aBookmarks)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     for (PRUint32 i = 0; i < bookmarks.Length(); i ++)
    1:       (*aBookmarks)[i] = bookmarks[i];
    1:   }
    1:   *aCount = bookmarks.Length();
    1: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
37340: nsNavBookmarks::GetItemIndex(PRInt64 aItemId, PRInt32* _index)
    1: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
37340:   NS_ENSURE_ARG_POINTER(_index);
37340: 
37340:   *_index = -1;
29123: 
37344:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37340:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   if (!hasResult)
37340:     return NS_OK;
37340: 
37344:   rv = stmt->GetInt32(kGetItemPropertiesIndex_Position, _index);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
 1377: nsNavBookmarks::SetItemIndex(PRInt64 aItemId, PRInt32 aNewIndex)
 1377: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
31729:   NS_ENSURE_ARG_MIN(aNewIndex, 0);
29123: 
 1377:   nsresult rv;
 1377:   PRInt32 oldIndex = 0;
 1377:   PRInt64 parent = 0;
37340:   PRInt32 itemType;
 1377: 
 1377:   {
37341:     mozIStorageStatement* getInfoStmt(mDBGetItemProperties);
37341:     NS_ENSURE_STATE(getInfoStmt);
37341:     mozStorageStatementScoper scoper(getInfoStmt);
41402:     rv = getInfoStmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:     PRBool hasResult;
37341:     rv = getInfoStmt->ExecuteStep(&hasResult);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     if (!hasResult)
 1377:       return NS_OK;
 1377: 
37341:     rv = getInfoStmt->GetInt32(kGetItemPropertiesIndex_Position, &oldIndex);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     rv = getInfoStmt->GetInt32(kGetItemPropertiesIndex_Type, &itemType);
37341:     NS_ENSURE_SUCCESS(rv, rv);
37341:     rv = getInfoStmt->GetInt64(kGetItemPropertiesIndex_Parent, &parent);
37340:     NS_ENSURE_SUCCESS(rv, rv);
 1377:   }
 1377: 
31729:   // Ensure we are not going out of range.
31729:   PRInt32 folderCount;
31729:   rv = FolderCount(parent, &folderCount);
31729:   NS_ENSURE_SUCCESS(rv, rv);
31729:   NS_ENSURE_TRUE(aNewIndex < folderCount, NS_ERROR_INVALID_ARG);
31729: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBSetItemIndex);
41402:   rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
37341:   NS_ENSURE_SUCCESS(rv, rv);
41402:   rv = stmt->BindInt32ByName(NS_LITERAL_CSTRING("item_index"), aNewIndex);
37341:   NS_ENSURE_SUCCESS(rv, rv);
37341: 
37341:   rv = stmt->Execute();
 1377:   NS_ENSURE_SUCCESS(rv, rv);
 1377: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
37343:                    OnItemMoved(aItemId, parent, oldIndex, parent, aNewIndex,
37343:                                itemType));
 1377: 
 1377:   return NS_OK;
 1377: }
 1377: 
37340: 
50437: nsresult
50437: nsNavBookmarks::UpdateKeywordsHashForRemovedBookmark(PRInt64 aItemId)
50437: {
50437:   nsAutoString kw;
50437:   if (NS_SUCCEEDED(GetKeywordForBookmark(aItemId, kw)) && !kw.IsEmpty()) {
50437:     nsresult rv = EnsureKeywordsHash();
50437:     NS_ENSURE_SUCCESS(rv, rv);
50437:     mBookmarkToKeywordHash.Remove(aItemId);
50437:   }
50437:   return NS_OK;
50437: }
50437: 
50437: 
 1377: NS_IMETHODIMP
37340: nsNavBookmarks::SetKeywordForBookmark(PRInt64 aBookmarkId,
51666:                                       const nsAString& aUserCasedKeyword)
    1: {
29123:   NS_ENSURE_ARG_MIN(aBookmarkId, 1);
    1: 
50437:   nsresult rv = EnsureKeywordsHash();
50437:   NS_ENSURE_SUCCESS(rv, rv);
50437: 
50437:   // Shortcuts are always lowercased internally.
51666:   nsAutoString keyword(aUserCasedKeyword);
50437:   ToLowerCase(keyword);
50437: 
50437:   // Check if bookmark was already associated to a keyword.
50437:   nsAutoString oldKeyword;
50437:   rv = GetKeywordForBookmark(aBookmarkId, oldKeyword);
50437:   NS_ENSURE_SUCCESS(rv, rv);
50437: 
50437:   // Trying to set the same value or to remove a nonexistent keyword is a no-op.
50437:   if (keyword.Equals(oldKeyword) || (keyword.IsEmpty() && oldKeyword.IsEmpty()))
50437:     return NS_OK;
50437: 
49241:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
50437: 
50437:   nsCOMPtr<mozIStorageStatement> updateBookmarkStmt;
49241:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
50437:     "UPDATE moz_bookmarks "
50437:     "SET keyword_id = (SELECT id FROM moz_keywords WHERE keyword = :keyword), "
50437:         "lastModified = :date "
50437:     "WHERE id = :item_id "
50437:   ), getter_AddRefs(updateBookmarkStmt));
49212:   NS_ENSURE_SUCCESS(rv, rv);
50437: 
50437:   if (keyword.IsEmpty()) {
50437:     // Remove keyword association from the hash.
50437:     mBookmarkToKeywordHash.Remove(aBookmarkId);
50437:     rv = updateBookmarkStmt->BindNullByName(NS_LITERAL_CSTRING("keyword"));
    1:   }
    1:    else {
50437:     // We are associating bookmark to a new keyword. Create a new keyword
50437:     // record if needed.
50437:     nsCOMPtr<mozIStorageStatement> newKeywordStmt;
20874:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
50437:       "INSERT OR IGNORE INTO moz_keywords (keyword) VALUES (:keyword)"
50437:     ), getter_AddRefs(newKeywordStmt));
    1:     NS_ENSURE_SUCCESS(rv, rv);
50437:     rv = newKeywordStmt->BindStringByName(NS_LITERAL_CSTRING("keyword"),
50437:                                           keyword);
    1:     NS_ENSURE_SUCCESS(rv, rv);
50437:     rv = newKeywordStmt->Execute();
    1:     NS_ENSURE_SUCCESS(rv, rv);
16751: 
50437:     // Add new keyword association to the hash, removing the old one if needed.
50437:     if (!oldKeyword.IsEmpty())
50437:       mBookmarkToKeywordHash.Remove(aBookmarkId);
50437:     mBookmarkToKeywordHash.Put(aBookmarkId, keyword);
50437:     rv = updateBookmarkStmt->BindStringByName(NS_LITERAL_CSTRING("keyword"), keyword);
41402:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
29518:   PRTime lastModified = PR_Now();
50437:   rv = updateBookmarkStmt->BindInt64ByName(NS_LITERAL_CSTRING("date"),
50437:                                            lastModified);
29518:   NS_ENSURE_SUCCESS(rv, rv);
50437:   rv = updateBookmarkStmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"),
50437:                                            aBookmarkId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
50437:   rv = updateBookmarkStmt->Execute();
    1:   NS_ENSURE_SUCCESS(rv, rv);
 1429: 
29518:   rv = transaction.Commit();
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
37343:                    nsINavBookmarkObserver,
 1429:                    OnItemChanged(aBookmarkId, NS_LITERAL_CSTRING("keyword"),
50437:                                  PR_FALSE, NS_ConvertUTF16toUTF8(keyword),
35298:                                  lastModified, TYPE_BOOKMARK));
 1604: 
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetKeywordForURI(nsIURI* aURI, nsAString& aKeyword)
    1: {
29123:   NS_ENSURE_ARG(aURI);
    1:   aKeyword.Truncate(0);
    1: 
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetKeywordForURI);
41402:   nsresult rv = URIBinder::Bind(stmt, NS_LITERAL_CSTRING("page_url"), aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool hasMore = PR_FALSE;
37341:   rv = stmt->ExecuteStep(&hasMore);
    1:   if (NS_FAILED(rv) || !hasMore) {
    1:     aKeyword.SetIsVoid(PR_TRUE);
    1:     return NS_OK; // not found: return void keyword string
    1:   }
    1: 
    1:   // found, get the keyword
37341:   rv = stmt->GetString(0, aKeyword);
37340:   NS_ENSURE_SUCCESS(rv, rv);
37340:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetKeywordForBookmark(PRInt64 aBookmarkId, nsAString& aKeyword)
    1: {
29123:   NS_ENSURE_ARG_MIN(aBookmarkId, 1);
    1:   aKeyword.Truncate(0);
    1: 
50437:   nsresult rv = EnsureKeywordsHash();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
50437:   nsAutoString keyword;
50437:   if (!mBookmarkToKeywordHash.Get(aBookmarkId, &keyword)) {
    1:     aKeyword.SetIsVoid(PR_TRUE);
    1:   }
50437:   else {
50437:     aKeyword.Assign(keyword);
50437:   }
50437: 
37341:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
51666: nsNavBookmarks::GetURIForKeyword(const nsAString& aUserCasedKeyword,
51666:                                  nsIURI** aURI)
    1: {
29123:   NS_ENSURE_ARG_POINTER(aURI);
51666:   NS_ENSURE_TRUE(!aUserCasedKeyword.IsEmpty(), NS_ERROR_INVALID_ARG);
    1:   *aURI = nsnull;
    1: 
    1:   // Shortcuts are always lowercased internally.
51666:   nsAutoString keyword(aUserCasedKeyword);
50437:   ToLowerCase(keyword);
50437: 
50437:   nsresult rv = EnsureKeywordsHash();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
50437:   keywordSearchData searchData;
51666:   searchData.keyword.Assign(keyword);
50437:   searchData.itemId = -1;
50437:   mBookmarkToKeywordHash.EnumerateRead(SearchBookmarkForKeyword, &searchData);
50437: 
50437:   if (searchData.itemId == -1) {
50437:     // Not found.
50437:     return NS_OK;
50437:   }
50437: 
50437:   rv = GetBookmarkURI(searchData.itemId, aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
50437: 
50437:   return NS_OK;
50437: }
50437: 
50437: 
50437: nsresult
50437: nsNavBookmarks::EnsureKeywordsHash() {
50437:   if (mBookmarkToKeywordHash.IsInitialized())
50437:     return NS_OK;
50437: 
50437:   mBookmarkToKeywordHash.Init(BOOKMARKS_TO_KEYWORDS_INITIAL_CACHE_SIZE);
50437: 
50437:   nsCOMPtr<mozIStorageStatement> stmt;
50437:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
50437:     "SELECT b.id, k.keyword "
50437:     "FROM moz_bookmarks b "
50437:     "JOIN moz_keywords k ON k.id = b.keyword_id "
50437:   ), getter_AddRefs(stmt));
37340:   NS_ENSURE_SUCCESS(rv, rv);
50437: 
50437:   PRBool hasMore;
50437:   while (NS_SUCCEEDED(stmt->ExecuteStep(&hasMore)) && hasMore) {
50437:     PRInt64 itemId;
50437:     rv = stmt->GetInt64(0, &itemId);
50437:     NS_ENSURE_SUCCESS(rv, rv);
50437:     nsAutoString keyword;
50437:     rv = stmt->GetString(1, keyword);
50437:     NS_ENSURE_SUCCESS(rv, rv);
50437: 
50437:     rv = mBookmarkToKeywordHash.Put(itemId, keyword);
50437:     NS_ENSURE_SUCCESS(rv, rv);
50437:   }
50437: 
37340:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
 2051: nsNavBookmarks::RunInBatchMode(nsINavHistoryBatchCallback* aCallback,
 2051:                                nsISupports* aUserData) {
29123:   NS_ENSURE_ARG(aCallback);
 2051: 
59379:   mBatching = true;
59379: 
57427:   // Just forward the request to history.  History service must exist for
57427:   // bookmarks to work and we are observing it, thus batch notifications will be
57427:   // forwarded to bookmarks observers.
57427:   nsNavHistory* history = nsNavHistory::GetHistoryService();
57427:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
57427:   nsresult rv = history->RunInBatchMode(aCallback, aUserData);
57427:   NS_ENSURE_SUCCESS(rv, rv);
57427: 
57427:   return NS_OK;
 2051: }
 2051: 
37340: 
 2051: NS_IMETHODIMP
    1: nsNavBookmarks::AddObserver(nsINavBookmarkObserver* aObserver,
    1:                             PRBool aOwnsWeak)
    1: {
29123:   NS_ENSURE_ARG(aObserver);
    1:   return mObservers.AppendWeakElement(aObserver, aOwnsWeak);
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::RemoveObserver(nsINavBookmarkObserver* aObserver)
    1: {
    1:   return mObservers.RemoveWeakElement(aObserver);
    1: }
    1: 
60944: void
61984: nsNavBookmarks::NotifyItemVisited(const ItemVisitData& aData)
60944: {
60944:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
60944:                    OnItemVisited(aData.itemId, aData.visitId, aData.time));
60944: }
60944: 
60944: void
61984: nsNavBookmarks::NotifyItemChanged(const ItemChangeData& aData)
60944: {
60944:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
60944:                    OnItemChanged(aData.itemId, aData.property,
60944:                                  aData.isAnnotation, aData.newValue,
60944:                                  aData.lastModified, aData.itemType));
60944: }
60944: 
60944: ////////////////////////////////////////////////////////////////////////////////
60944: //// nsNavBookmarks::nsINavHistoryObserver
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::OnBeginUpdateBatch()
    1: {
57427:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
57427:                    nsINavBookmarkObserver, OnBeginUpdateBatch());
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::OnEndUpdateBatch()
    1: {
59379:   if (mBatching) {
59379:     mBatching = false;
59379:     ForceWALCheckpoint(mDBConn);
59379:   }
59379: 
57427:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
57427:                    nsINavBookmarkObserver, OnEndUpdateBatch());
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
60944: nsNavBookmarks::OnVisit(nsIURI* aURI, PRInt64 aVisitId, PRTime aTime,
    1:                         PRInt64 aSessionID, PRInt64 aReferringID,
12328:                         PRUint32 aTransitionType, PRUint32* aAdded)
    1: {
60944:   // If the page is bookmarked, notify observers for each associated bookmark.
60944:   ItemVisitData visitData;
60944:   visitData.uri = aURI;
60944:   visitData.visitId = aVisitId;
60944:   visitData.time = aTime;
60944: 
60944:   nsRefPtr< AsyncGetBookmarksForURI<ItemVisitMethod, ItemVisitData> > notifier =
60944:     new AsyncGetBookmarksForURI<ItemVisitMethod, ItemVisitData>(this, &nsNavBookmarks::NotifyItemVisited, visitData);
61984:   notifier->Init();
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
27196: nsNavBookmarks::OnBeforeDeleteURI(nsIURI* aURI)
27196: {
27196:   return NS_OK;
27196: }
27196: 
37340: 
27196: NS_IMETHODIMP
    1: nsNavBookmarks::OnDeleteURI(nsIURI* aURI)
    1: {
60944:   // If the page is bookmarked, notify observers for each associated bookmark.
60944:   ItemChangeData changeData;
60944:   changeData.uri = aURI;
60944:   changeData.property = NS_LITERAL_CSTRING("cleartime");
60944:   changeData.isAnnotation = PR_FALSE;
60944:   changeData.lastModified = 0;
60944:   changeData.itemType = TYPE_BOOKMARK;
60944: 
60944:   nsRefPtr< AsyncGetBookmarksForURI<ItemChangeMethod, ItemChangeData> > notifier =
60944:     new AsyncGetBookmarksForURI<ItemChangeMethod, ItemChangeData>(this, &nsNavBookmarks::NotifyItemChanged, changeData);
61984:   notifier->Init();
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::OnClearHistory()
    1: {
    1:   // TODO(bryner): we should notify on visited-time change for all URIs
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
 4037: nsNavBookmarks::OnTitleChanged(nsIURI* aURI, const nsAString& aPageTitle)
    1: {
    1:   // NOOP. We don't consume page titles from moz_places anymore.
    1:   // Title-change notifications are sent from SetItemTitle.
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::OnPageChanged(nsIURI* aURI, PRUint32 aWhat,
    1:                               const nsAString& aValue)
    1: {
 1905:   nsresult rv;
    1:   if (aWhat == nsINavHistoryObserver::ATTRIBUTE_FAVICON) {
60944:     ItemChangeData changeData;
60944:     changeData.uri = aURI;
60944:     changeData.property = NS_LITERAL_CSTRING("favicon");
60944:     changeData.isAnnotation = PR_FALSE;
60944:     changeData.newValue = NS_ConvertUTF16toUTF8(aValue);
60944:     changeData.lastModified = 0;
60944:     changeData.itemType = TYPE_BOOKMARK;
60944: 
 1905:     // Favicons may be set to either pure URIs or to folder URIs
 1905:     PRBool isPlaceURI;
 1905:     rv = aURI->SchemeIs("place", &isPlaceURI);
 1905:     NS_ENSURE_SUCCESS(rv, rv);
 1905:     if (isPlaceURI) {
 1905:       nsCAutoString spec;
 1905:       rv = aURI->GetSpec(spec);
 1905:       NS_ENSURE_SUCCESS(rv, rv);
 1905: 
35298:       nsNavHistory* history = nsNavHistory::GetHistoryService();
35298:       NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
 1905:   
 1905:       nsCOMArray<nsNavHistoryQuery> queries;
 1905:       nsCOMPtr<nsNavHistoryQueryOptions> options;
 1905:       rv = history->QueryStringToQueryArray(spec, &queries, getter_AddRefs(options));
 1905:       NS_ENSURE_SUCCESS(rv, rv);
 1905: 
60944:       if (queries.Count() == 1 && queries[0]->Folders().Length() == 1) {
60944:         changeData.itemId = queries[0]->Folders()[0];
60944:         NotifyItemChanged(changeData);
60944:       }
 1905:     }
 1905:     else {
60944:       nsRefPtr< AsyncGetBookmarksForURI<ItemChangeMethod, ItemChangeData> > notifier =
60944:         new AsyncGetBookmarksForURI<ItemChangeMethod, ItemChangeData>(this, &nsNavBookmarks::NotifyItemChanged, changeData);
61984:       notifier->Init();
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
37340: 
    1: NS_IMETHODIMP
37226: nsNavBookmarks::OnDeleteVisits(nsIURI* aURI, PRTime aVisitTime)
    1: {
    1:   // pages that are bookmarks shouldn't expire, so we don't need to handle it
    1:   return NS_OK;
    1: }
 1337: 
37340: 
 1337: // nsIAnnotationObserver
 1337: 
 1337: NS_IMETHODIMP
 1337: nsNavBookmarks::OnPageAnnotationSet(nsIURI* aPage, const nsACString& aName)
 1337: {
 1337:   return NS_OK;
 1337: }
 1337: 
37340: 
 1337: NS_IMETHODIMP
 1337: nsNavBookmarks::OnItemAnnotationSet(PRInt64 aItemId, const nsACString& aName)
 1337: {
33340:   // GetItemType also ensures that aItemId points to a valid item.
33340:   PRUint16 itemType;
33340:   nsresult rv = GetItemType(aItemId, &itemType);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
33340:   PRTime lastModified = PR_Now();
37341:   rv = SetItemDateInternal(GetStatement(mDBSetItemLastModified),
37341:                            aItemId, lastModified);
33340:   NS_ENSURE_SUCCESS(rv, rv);
33340: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
33340:                    nsINavBookmarkObserver,
33340:                    OnItemChanged(aItemId, aName, PR_TRUE, EmptyCString(),
33340:                                  lastModified, itemType));
 1604: 
 1337:   return NS_OK;
 1337: }
 1337: 
 1337: 
 1337: NS_IMETHODIMP
 1337: nsNavBookmarks::OnPageAnnotationRemoved(nsIURI* aPage, const nsACString& aName)
 1337: {
 1337:   return NS_OK;
 1337: }
 1337: 
37340: 
 1337: NS_IMETHODIMP
 1337: nsNavBookmarks::OnItemAnnotationRemoved(PRInt64 aItemId, const nsACString& aName)
 1337: {
33340:   // GetItemType also ensures that aItemId points to a valid item.
33340:   PRUint16 itemType;
33340:   nsresult rv = GetItemType(aItemId, &itemType);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
33340:   PRTime lastModified = PR_Now();
37341:   rv = SetItemDateInternal(GetStatement(mDBSetItemLastModified),
37341:                            aItemId, lastModified);
33340:   NS_ENSURE_SUCCESS(rv, rv);
33340: 
37343:   NOTIFY_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
33340:                    nsINavBookmarkObserver,
33340:                    OnItemChanged(aItemId, aName, PR_TRUE, EmptyCString(),
33340:                                  lastModified, itemType));
 1604: 
 1337:   return NS_OK;
 1337: }
 2780: 
37340: 
 2780: PRBool
 2780: nsNavBookmarks::ItemExists(PRInt64 aItemId) {
37342:   DECLARE_AND_ASSIGN_SCOPED_LAZY_STMT(stmt, mDBGetItemProperties);
41402:   nsresult rv = stmt->BindInt64ByName(NS_LITERAL_CSTRING("item_id"), aItemId);
 2780:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
 2780: 
37340:   PRBool hasResult;
37341:   rv = stmt->ExecuteStep(&hasResult);
 2780:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
 2780: 
37340:   return hasResult;
 2780: }
