19246: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
19246: /* ***** BEGIN LICENSE BLOCK *****
19246:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
19246:  *
19246:  * The contents of this file are subject to the Mozilla Public License Version
19246:  * 1.1 (the "License"); you may not use this file except in compliance with
19246:  * the License. You may obtain a copy of the License at
19246:  * http://www.mozilla.org/MPL/
19246:  *
19246:  * Software distributed under the License is distributed on an "AS IS" basis,
19246:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
19246:  * for the specific language governing rights and limitations under the
19246:  * License.
19246:  *
19246:  * The Original Code is mozilla.org code.
19246:  *
19246:  * The Initial Developer of the Original Code is
19246:  * Netscape Communications Corporation.
19246:  * Portions created by the Initial Developer are Copyright (C) 1998
19246:  * the Initial Developer. All Rights Reserved.
19246:  *
19246:  * Contributor(s):
19246:  *   Tim Copperfield <timecop@network.email.ne.jp>
19246:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
19246:  *
19246:  * Alternatively, the contents of this file may be used under the terms of
19246:  * either the GNU General Public License Version 2 or later (the "GPL"), or
19246:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
19246:  * in which case the provisions of the GPL or the LGPL are applicable instead
19246:  * of those above. If you wish to allow use of your version of this file only
19246:  * under the terms of either the GPL or the LGPL, and not to allow others to
19246:  * use your version of this file under the terms of the MPL, indicate your
19246:  * decision by deleting the provisions above and replace them with the notice
19246:  * and other provisions required by the GPL or the LGPL. If you do not delete
19246:  * the provisions above, a recipient may use your version of this file under
19246:  * the terms of any one of the MPL, the GPL or the LGPL.
19246:  *
19246:  * ***** END LICENSE BLOCK ***** */
19246: 
19246: #include "prlog.h"
19246: #include "prmem.h"
19246: #include "nscore.h"
19246: #include "prenv.h"
19246: 
19246: #include "nsNPAPIPluginInstance.h"
19246: #include "nsNPAPIPlugin.h"
19246: #include "nsNPAPIPluginStreamListener.h"
29956: #include "nsPluginHost.h"
19246: #include "nsPluginSafety.h"
19246: #include "nsPluginLogging.h"
24475: #include "nsIPrivateBrowsingService.h"
61864: #include "nsContentUtils.h"
19246: 
19246: #include "nsIDocument.h"
29808: #include "nsIScriptGlobalObject.h"
29808: #include "nsIScriptContext.h"
29834: #include "nsDirectoryServiceDefs.h"
19246: #include "nsJSNPRuntime.h"
60021: #include "nsPluginStreamListenerPeer.h"
19246: 
36125: using namespace mozilla::plugins::parent;
36355: using mozilla::TimeStamp;
36125: 
47353: static NS_DEFINE_IID(kIOutputStreamIID, NS_IOUTPUTSTREAM_IID);
19246: static NS_DEFINE_IID(kIPluginStreamListenerIID, NS_IPLUGINSTREAMLISTENER_IID);
19246: 
29953: NS_IMPL_ISUPPORTS1(nsNPAPIPluginInstance, nsIPluginInstance)
19246: 
47965: nsNPAPIPluginInstance::nsNPAPIPluginInstance(nsNPAPIPlugin* plugin)
47965:   :
19246: #ifdef XP_MACOSX
19246: #ifdef NP_NO_QUICKDRAW
19246:     mDrawingModel(NPDrawingModelCoreGraphics),
19246: #else
19246:     mDrawingModel(NPDrawingModelQuickDraw),
19246: #endif
19246: #endif
39838:     mRunning(NOT_STARTED),
19246:     mWindowless(PR_FALSE),
34217:     mWindowlessLocal(PR_FALSE),
19246:     mTransparent(PR_FALSE),
19246:     mCached(PR_FALSE),
19246:     mWantsAllNetworkStreams(PR_FALSE),
19246:     mInPluginInitCall(PR_FALSE),
47965:     mPlugin(plugin),
32019:     mMIMEType(nsnull),
32019:     mOwner(nsnull),
54899:     mCurrentPluginEvent(nsnull),
57209: #if defined(MOZ_X11) || defined(XP_WIN)
54899:     mUsePluginLayersPref(PR_TRUE)
54899: #else
54899:     mUsePluginLayersPref(PR_FALSE)
54899: #endif
19246: {
47965:   NS_ASSERTION(mPlugin != NULL, "Plugin is required when creating an instance.");
19246: 
19246:   // Initialize the NPP structure.
19246: 
30212:   mNPP.pdata = NULL;
30212:   mNPP.ndata = this;
19246: 
54899:   nsCOMPtr<nsIPrefBranch> prefs(do_GetService(NS_PREFSERVICE_CONTRACTID));
54899:   if (prefs) {
54899:     PRBool useLayersPref;
54899:     nsresult rv = prefs->GetBoolPref("mozilla.plugins.use_layers", &useLayersPref);
54899:     if (NS_SUCCEEDED(rv))
54899:       mUsePluginLayersPref = useLayersPref;
54899:   }
54899: 
19246:   PLUGIN_LOG(PLUGIN_LOG_BASIC, ("nsNPAPIPluginInstance ctor: this=%p\n",this));
19246: }
19246: 
47301: nsNPAPIPluginInstance::~nsNPAPIPluginInstance()
19246: {
19246:   PLUGIN_LOG(PLUGIN_LOG_BASIC, ("nsNPAPIPluginInstance dtor: this=%p\n",this));
19246: 
29808:   if (mMIMEType) {
29808:     PR_Free((void *)mMIMEType);
29808:     mMIMEType = nsnull;
29808:   }
19246: }
19246: 
47965: void
47965: nsNPAPIPluginInstance::Destroy()
47965: {
47965:   Stop();
47965:   mPlugin = nsnull;
47965: }
47965: 
36355: TimeStamp
36355: nsNPAPIPluginInstance::LastStopTime()
36355: {
36355:   return mStopTime;
19246: }
19246: 
30101: NS_IMETHODIMP nsNPAPIPluginInstance::Initialize(nsIPluginInstanceOwner* aOwner, const char* aMIMEType)
19246: {
19246:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Initialize this=%p\n",this));
19246: 
29834:   mOwner = aOwner;
29834: 
29808:   if (aMIMEType) {
30101:     mMIMEType = (char*)PR_Malloc(PL_strlen(aMIMEType) + 1);
29808: 
29808:     if (mMIMEType)
30101:       PL_strcpy(mMIMEType, aMIMEType);
29808:   }
29808: 
29834:   return InitializePlugin();
19246: }
19246: 
36355: NS_IMETHODIMP nsNPAPIPluginInstance::Start()
19246: {
19246:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Start this=%p\n",this));
19246: 
39211:   if (RUNNING == mRunning)
19246:     return NS_OK;
19246: 
29834:   return InitializePlugin();
19246: }
19246: 
36355: NS_IMETHODIMP nsNPAPIPluginInstance::Stop()
19246: {
19246:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::Stop this=%p\n",this));
19246: 
19246:   // Make sure the plugin didn't leave popups enabled.
26912:   if (mPopupStates.Length() > 0) {
19246:     nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
19246: 
19246:     if (window) {
19246:       window->PopPopupControlState(openAbused);
19246:     }
19246:   }
19246: 
39211:   if (RUNNING != mRunning) {
19246:     return NS_OK;
23529:   }
19246: 
29937:   // clean up all outstanding timers
29937:   for (PRUint32 i = mTimers.Length(); i > 0; i--)
29937:     UnscheduleTimer(mTimers[i - 1]->id);
29937: 
19246:   // If there's code from this plugin instance on the stack, delay the
19246:   // destroy.
19246:   if (PluginDestructionGuard::DelayDestroy(this)) {
19246:     return NS_OK;
19246:   }
19246: 
36355:   // Make sure we lock while we're writing to mRunning after we've
19246:   // started as other threads might be checking that inside a lock.
19246:   EnterAsyncPluginThreadCallLock();
39211:   mRunning = DESTROYING;
36355:   mStopTime = TimeStamp::Now();
19246:   ExitAsyncPluginThreadCallLock();
19246: 
30212:   OnPluginDestroy(&mNPP);
19246: 
19246:   // clean up open streams
60021:   while (mStreamListeners.Length() > 0) {
60021:     nsRefPtr<nsNPAPIPluginStreamListener> currentListener(mStreamListeners[0]);
49224:     currentListener->CleanUpStream(NPRES_USER_BREAK);
60021:     mStreamListeners.RemoveElement(currentListener);
19246:   }
19246: 
55810:   if (!mPlugin || !mPlugin->GetLibrary())
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
47965: 
39211:   NPError error = NPERR_GENERIC_ERROR;
47965:   if (pluginFunctions->destroy) {
39211:     NPSavedData *sdata = 0;
39211: 
55810:     NS_TRY_SAFE_CALL_RETURN(error, (*pluginFunctions->destroy)(&mNPP, &sdata), this);
19246: 
19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
30212:                    ("NPP Destroy called: this=%p, npp=%p, return=%d\n", this, &mNPP, error));
39211:   }
39211:   mRunning = DESTROYED;
19246: 
30212:   nsJSNPRuntime::OnPluginDestroy(&mNPP);
19246: 
19246:   if (error != NPERR_NO_ERROR)
19246:     return NS_ERROR_FAILURE;
19246:   else
19246:     return NS_OK;
19246: }
19246: 
19246: already_AddRefed<nsPIDOMWindow>
19246: nsNPAPIPluginInstance::GetDOMWindow()
19246: {
19246:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   GetOwner(getter_AddRefs(owner));
21231:   if (!owner)
19246:     return nsnull;
19246: 
19246:   nsCOMPtr<nsIDocument> doc;
19246:   owner->GetDocument(getter_AddRefs(doc));
21231:   if (!doc)
19246:     return nsnull;
19246: 
19246:   nsPIDOMWindow *window = doc->GetWindow();
19246:   NS_IF_ADDREF(window);
19246: 
19246:   return window;
19246: }
19246: 
29834: nsresult
29834: nsNPAPIPluginInstance::GetTagType(nsPluginTagType *result)
19246: {
29834:   if (mOwner) {
29952:     nsCOMPtr<nsIPluginTagInfo> tinfo(do_QueryInterface(mOwner));
29834:     if (tinfo)
29834:       return tinfo->GetTagType(result);
29834:   }
19246: 
29834:   return NS_ERROR_FAILURE;
29834: }
19246: 
29834: nsresult
29834: nsNPAPIPluginInstance::GetAttributes(PRUint16& n, const char*const*& names,
29834:                                      const char*const*& values)
29834: {
29834:   if (mOwner) {
29952:     nsCOMPtr<nsIPluginTagInfo> tinfo(do_QueryInterface(mOwner));
29834:     if (tinfo)
29834:       return tinfo->GetAttributes(n, names, values);
29834:   }
29834: 
29834:   return NS_ERROR_FAILURE;
29834: }
29834: 
29834: nsresult
29834: nsNPAPIPluginInstance::GetParameters(PRUint16& n, const char*const*& names,
29834:                                      const char*const*& values)
29834: {
29834:   if (mOwner) {
29952:     nsCOMPtr<nsIPluginTagInfo> tinfo(do_QueryInterface(mOwner));
29834:     if (tinfo)
29834:       return tinfo->GetParameters(n, names, values);
29834:   }
29834: 
29834:   return NS_ERROR_FAILURE;
29834: }
29834: 
29834: nsresult
32799: nsNPAPIPluginInstance::GetMode(PRInt32 *result)
29834: {
29834:   if (mOwner)
29834:     return mOwner->GetMode(result);
29834:   else
29834:     return NS_ERROR_FAILURE;
29834: }
29834: 
47865: nsTArray<nsNPAPIPluginStreamListener*>*
60021: nsNPAPIPluginInstance::StreamListeners()
47865: {
60021:   return &mStreamListeners;
47865: }
47865: 
47865: nsTArray<nsPluginStreamListenerPeer*>*
60021: nsNPAPIPluginInstance::FileCachedStreamListeners()
47865: {
60021:   return &mFileCachedStreamListeners;
47865: }
47865: 
29834: nsresult
29834: nsNPAPIPluginInstance::InitializePlugin()
29834: { 
19246:   PluginDestructionGuard guard(this);
19246: 
19246:   PRUint16 count = 0;
19246:   const char* const* names = nsnull;
19246:   const char* const* values = nsnull;
19246:   nsPluginTagType tagtype;
29834:   nsresult rv = GetTagType(&tagtype);
19246:   if (NS_SUCCEEDED(rv)) {
19246:     // Note: If we failed to get the tag type, we may be a full page plugin, so no arguments
29834:     rv = GetAttributes(count, names, values);
19246:     NS_ENSURE_SUCCESS(rv, rv);
19246:     
19246:     // nsPluginTagType_Object or Applet may also have PARAM tags
19246:     // Note: The arrays handed back by GetParameters() are
19246:     // crafted specially to be directly behind the arrays from GetAttributes()
19246:     // with a null entry as a separator. This is for 4.x backwards compatibility!
19246:     // see bug 111008 for details
19246:     if (tagtype != nsPluginTagType_Embed) {
19246:       PRUint16 pcount = 0;
19246:       const char* const* pnames = nsnull;
19246:       const char* const* pvalues = nsnull;    
29834:       if (NS_SUCCEEDED(GetParameters(pcount, pnames, pvalues))) {
21231:         NS_ASSERTION(!values[count], "attribute/parameter array not setup correctly for NPAPI plugins");
19246:         if (pcount)
21231:           count += ++pcount; // if it's all setup correctly, then all we need is to
21231:                              // change the count (attrs + PARAM/blank + params)
19246:       }
19246:     }
19246:   }
19246: 
32799:   PRInt32       mode;
30224:   const char*   mimetype;
37569:   NPError       error = NPERR_GENERIC_ERROR;
19246: 
29834:   GetMode(&mode);
29808:   GetMIMEType(&mimetype);
19246: 
19246:   // Some older versions of Flash have a bug in them
19246:   // that causes the stack to become currupt if we
29923:   // pass swliveconnect=1 in the NPP_NewProc arrays.
19246:   // See bug 149336 (UNIX), bug 186287 (Mac)
19246:   //
19246:   // The code below disables the attribute unless
19246:   // the environment variable:
19246:   // MOZILLA_PLUGIN_DISABLE_FLASH_SWLIVECONNECT_HACK
19246:   // is set.
19246:   //
19246:   // It is okay to disable this attribute because
19246:   // back in 4.x, scripting required liveconnect to
19246:   // start Java which was slow. Scripting no longer
19246:   // requires starting Java and is quick plus controled
19246:   // from the browser, so Flash now ignores this attribute.
19246:   //
19246:   // This code can not be put at the time of creating
19246:   // the array because we may need to examine the
19246:   // stream header to determine we want Flash.
19246: 
19246:   static const char flashMimeType[] = "application/x-shockwave-flash";
19246:   static const char blockedParam[] = "swliveconnect";
19246:   if (count && !PL_strcasecmp(mimetype, flashMimeType)) {
19246:     static int cachedDisableHack = 0;
19246:     if (!cachedDisableHack) {
19246:        if (PR_GetEnv("MOZILLA_PLUGIN_DISABLE_FLASH_SWLIVECONNECT_HACK"))
19246:          cachedDisableHack = -1;
19246:        else
19246:          cachedDisableHack = 1;
19246:     }
19246:     if (cachedDisableHack > 0) {
19246:       for (PRUint16 i=0; i<count; i++) {
19246:         if (!PL_strcasecmp(names[i], blockedParam)) {
19246:           // BIG FAT WARNIG:
19246:           // I'm ugly casting |const char*| to |char*| and altering it
19246:           // because I know we do malloc it values in
19246:           // http://bonsai.mozilla.org/cvsblame.cgi?file=mozilla/layout/html/base/src/nsObjectFrame.cpp&rev=1.349&root=/cvsroot#3020
19246:           // and free it at line #2096, so it couldn't be a const ptr to string literal
19246:           char *val = (char*) values[i];
19246:           if (val && *val) {
19246:             // we cannot just *val=0, it won't be free properly in such case
19246:             val[0] = '0';
19246:             val[1] = 0;
19246:           }
19246:           break;
19246:         }
19246:       }
19246:     }
19246:   }
19246: 
19246:   PRBool oldVal = mInPluginInitCall;
19246:   mInPluginInitCall = PR_TRUE;
19246: 
35965:   // Need this on the stack before calling NPP_New otherwise some callbacks that
35965:   // the plugin may make could fail (NPN_HasProperty, for example).
35965:   NPPAutoPusher autopush(&mNPP);
47965: 
47965:   if (!mPlugin)
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   PluginLibrary* library = mPlugin->GetLibrary();
47965:   if (!library)
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   // Mark this instance as running before calling NPP_New because the plugin may
47965:   // call other NPAPI functions, like NPN_GetURLNotify, that assume this is set
47965:   // before returning. If the plugin returns failure, we'll clear it out below.
47965:   mRunning = RUNNING;
47965: 
47965:   nsresult newResult = library->NPP_New((char*)mimetype, &mNPP, (PRUint16)mode, count, (char**)names, (char**)values, NULL, &error);
19246:   mInPluginInitCall = oldVal;
19246: 
19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("NPP New called: this=%p, npp=%p, mime=%s, mode=%d, argc=%d, return=%d\n",
30212:   this, &mNPP, mimetype, mode, count, error));
19246: 
61875:   if (NS_FAILED(newResult) || error != NPERR_NO_ERROR) {
39211:     mRunning = DESTROYED;
61875:     nsJSNPRuntime::OnPluginDestroy(&mNPP);
19246:     return NS_ERROR_FAILURE;
19246:   }
19246:   
19246:   return NS_OK;
19246: }
19246: 
32799: NS_IMETHODIMP nsNPAPIPluginInstance::SetWindow(NPWindow* window)
19246: {
32019:   // NPAPI plugins don't want a SetWindow(NULL).
39211:   if (!window || RUNNING != mRunning)
19246:     return NS_OK;
19246: 
19246: #if defined(MOZ_WIDGET_GTK2)
19246:   // bug 108347, flash plugin on linux doesn't like window->width <=
19246:   // 0, but Java needs wants this call.
32799:   if (!nsPluginHost::IsJavaMIMEType(mMIMEType) && window->type == NPWindowTypeWindow &&
19246:       (window->width <= 0 || window->height <= 0)) {
19246:     return NS_OK;
19246:   }
32019: #endif
19246: 
55810:   if (!mPlugin || !mPlugin->GetLibrary())
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
47965: 
47965:   if (pluginFunctions->setwindow) {
19246:     PluginDestructionGuard guard(this);
19246: 
19246:     // XXX Turns out that NPPluginWindow and NPWindow are structurally
19246:     // identical (on purpose!), so there's no need to make a copy.
19246: 
19246:     PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance::SetWindow (about to call it) this=%p\n",this));
19246: 
19246:     PRBool oldVal = mInPluginInitCall;
19246:     mInPluginInitCall = PR_TRUE;
19246: 
35965:     NPPAutoPusher nppPusher(&mNPP);
35965: 
32019:     NPError error;
55810:     NS_TRY_SAFE_CALL_RETURN(error, (*pluginFunctions->setwindow)(&mNPP, (NPWindow*)window), this);
19246: 
19246:     mInPluginInitCall = oldVal;
19246: 
19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:     ("NPP SetWindow called: this=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d], return=%d\n",
19246:     this, window->x, window->y, window->width, window->height,
19246:     window->clipRect.top, window->clipRect.bottom, window->clipRect.left, window->clipRect.right, error));
19246:   }
19246:   return NS_OK;
19246: }
19246: 
29834: NS_IMETHODIMP
29834: nsNPAPIPluginInstance::NewStreamToPlugin(nsIPluginStreamListener** listener)
19246: {
60021:   // This method can be removed at the next opportunity.
60021:   return NS_ERROR_NOT_IMPLEMENTED;
19246: }
19246: 
29834: NS_IMETHODIMP
30101: nsNPAPIPluginInstance::NewStreamFromPlugin(const char* type, const char* target,
29834:                                            nsIOutputStream* *result)
29834: {
29834:   nsPluginStreamToFile* stream = new nsPluginStreamToFile(target, mOwner);
29834:   if (!stream)
29834:     return NS_ERROR_OUT_OF_MEMORY;
29834: 
29834:   return stream->QueryInterface(kIOutputStreamIID, (void**)result);
29834: }
29834: 
60021: nsresult
60021: nsNPAPIPluginInstance::NewStreamListener(const char* aURL, void* notifyData,
60021:                                          nsIPluginStreamListener** listener)
19246: {
19246:   nsNPAPIPluginStreamListener* stream = new nsNPAPIPluginStreamListener(this, notifyData, aURL);
19246:   NS_ENSURE_TRUE(stream, NS_ERROR_OUT_OF_MEMORY);
19246: 
60021:   mStreamListeners.AppendElement(stream);
19246: 
47301:   return stream->QueryInterface(kIPluginStreamListenerIID, (void**)listener);
19246: }
19246: 
32799: NS_IMETHODIMP nsNPAPIPluginInstance::Print(NPPrint* platformPrint)
19246: {
19246:   NS_ENSURE_TRUE(platformPrint, NS_ERROR_NULL_POINTER);
19246: 
19246:   PluginDestructionGuard guard(this);
19246: 
55810:   if (!mPlugin || !mPlugin->GetLibrary())
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
47965: 
19246:   NPPrint* thePrint = (NPPrint *)platformPrint;
19246: 
19246:   // to be compatible with the older SDK versions and to match what
21231:   // NPAPI and other browsers do, overwrite |window.type| field with one
19246:   // more copy of |platformPrint|. See bug 113264
47965:   PRUint16 sdkmajorversion = (pluginFunctions->version & 0xff00)>>8;
47965:   PRUint16 sdkminorversion = pluginFunctions->version & 0x00ff;
19246:   if ((sdkmajorversion == 0) && (sdkminorversion < 11)) {
19246:     // Let's copy platformPrint bytes over to where it was supposed to be
19246:     // in older versions -- four bytes towards the beginning of the struct
19246:     // but we should be careful about possible misalignments
19246:     if (sizeof(NPWindowType) >= sizeof(void *)) {
19246:       void* source = thePrint->print.embedPrint.platformPrint;
19246:       void** destination = (void **)&(thePrint->print.embedPrint.window.type);
19246:       *destination = source;
31379:     } else {
31379:       NS_ERROR("Incompatible OS for assignment");
19246:     }
19246:   }
19246: 
47965:   if (pluginFunctions->print)
55810:       NS_TRY_SAFE_CALL_VOID((*pluginFunctions->print)(&mNPP, thePrint), this);
19246: 
19246:   NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:   ("NPP PrintProc called: this=%p, pDC=%p, [x=%d,y=%d,w=%d,h=%d], clip[t=%d,b=%d,l=%d,r=%d]\n",
19246:   this,
19246:   platformPrint->print.embedPrint.platformPrint,
19246:   platformPrint->print.embedPrint.window.x,
19246:   platformPrint->print.embedPrint.window.y,
19246:   platformPrint->print.embedPrint.window.width,
19246:   platformPrint->print.embedPrint.window.height,
19246:   platformPrint->print.embedPrint.window.clipRect.top,
19246:   platformPrint->print.embedPrint.window.clipRect.bottom,
19246:   platformPrint->print.embedPrint.window.clipRect.left,
19246:   platformPrint->print.embedPrint.window.clipRect.right));
19246: 
19246:   return NS_OK;
19246: }
19246: 
43436: NS_IMETHODIMP nsNPAPIPluginInstance::HandleEvent(void* event, PRInt16* result)
19246: {
39211:   if (RUNNING != mRunning)
19246:     return NS_OK;
19246: 
19246:   if (!event)
19246:     return NS_ERROR_FAILURE;
19246: 
19246:   PluginDestructionGuard guard(this);
19246: 
55810:   if (!mPlugin || !mPlugin->GetLibrary())
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
47965: 
43436:   PRInt16 tmpResult = kNPEventNotHandled;
19246: 
47965:   if (pluginFunctions->event) {
32019:     mCurrentPluginEvent = event;
32799: #if defined(XP_WIN) || defined(XP_OS2)
55810:     NS_TRY_SAFE_CALL_RETURN(tmpResult, (*pluginFunctions->event)(&mNPP, event), this);
32799: #else
47965:     tmpResult = (*pluginFunctions->event)(&mNPP, event);
19246: #endif
19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NOISY,
32799:       ("NPP HandleEvent called: this=%p, npp=%p, event=%p, return=%d\n", 
43436:       this, &mNPP, event, tmpResult));
19246: 
43436:     if (result)
43436:       *result = tmpResult;
32019:     mCurrentPluginEvent = nsnull;
19246:   }
19246: 
19246:   return NS_OK;
19246: }
19246: 
32799: NS_IMETHODIMP nsNPAPIPluginInstance::GetValueFromPlugin(NPPVariable variable, void* value)
19246: {
38014: #if (MOZ_PLATFORM_MAEMO == 5)
34217:   // The maemo flash plugin does not remember this.  It sets the
34217:   // value, but doesn't support the get value.
34217:   if (variable == NPPVpluginWindowlessLocalBool) {
34217:     *(NPBool*)value = mWindowlessLocal;
34217:     return NS_OK;
34217:   }
34217: #endif
55810:   if (!mPlugin || !mPlugin->GetLibrary())
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
47965: 
47965:   nsresult rv = NS_ERROR_FAILURE;
47965:   if (pluginFunctions->getvalue && RUNNING == mRunning) {
19246:     PluginDestructionGuard guard(this);
19246: 
55810:     NS_TRY_SAFE_CALL_RETURN(rv, (*pluginFunctions->getvalue)(&mNPP, variable, value), this);
19246:     NPP_PLUGIN_LOG(PLUGIN_LOG_NORMAL,
19246:     ("NPP GetValue called: this=%p, npp=%p, var=%d, value=%d, return=%d\n", 
47965:     this, &mNPP, variable, value, rv));
19246:   }
19246: 
47965:   return rv;
47965: }
47965: 
47965: nsNPAPIPlugin* nsNPAPIPluginInstance::GetPlugin()
47965: {
47965:   return mPlugin;
19246: }
19246: 
19246: nsresult nsNPAPIPluginInstance::GetNPP(NPP* aNPP) 
19246: {
21231:   if (aNPP)
30212:     *aNPP = &mNPP;
19246:   else
19246:     return NS_ERROR_NULL_POINTER;
19246: 
19246:   return NS_OK;
19246: }
19246: 
47965: void
47965: nsNPAPIPluginInstance::SetURI(nsIURI* uri)
19246: {
47965:   mURI = uri;
47965: }
19246: 
47965: nsIURI*
47965: nsNPAPIPluginInstance::GetURI()
47965: {
47965:   return mURI.get();
19246: }
19246: 
19246: NPError nsNPAPIPluginInstance::SetWindowless(PRBool aWindowless)
19246: {
19246:   mWindowless = aWindowless;
40724: 
40724:   if (mMIMEType) {
40724:     // bug 558434 - Prior to 3.6.4, we assumed windowless was transparent.
40724:     // Silverlight apparently relied on this quirk, so we default to
40724:     // transparent unless they specify otherwise after setting the windowless
57216:     // property. (Last tested version: sl 4.0).
57216:     // Changes to this code should be matched with changes in
57216:     // PluginInstanceChild::InitQuirksMode.
40724:     NS_NAMED_LITERAL_CSTRING(silverlight, "application/x-silverlight");
40724:     if (!PL_strncasecmp(mMIMEType, silverlight.get(), silverlight.Length())) {
40724:       mTransparent = PR_TRUE;
40724:     }
40724:   }
40724: 
19246:   return NPERR_NO_ERROR;
19246: }
19246: 
34217: NPError nsNPAPIPluginInstance::SetWindowlessLocal(PRBool aWindowlessLocal)
34217: {
34217:   mWindowlessLocal = aWindowlessLocal;
34217:   return NPERR_NO_ERROR;
34217: }
34217: 
19246: NPError nsNPAPIPluginInstance::SetTransparent(PRBool aTransparent)
19246: {
19246:   mTransparent = aTransparent;
19246:   return NPERR_NO_ERROR;
19246: }
19246: 
19246: NPError nsNPAPIPluginInstance::SetWantsAllNetworkStreams(PRBool aWantsAllNetworkStreams)
19246: {
19246:   mWantsAllNetworkStreams = aWantsAllNetworkStreams;
19246:   return NPERR_NO_ERROR;
19246: }
19246: 
19246: #ifdef XP_MACOSX
19246: void nsNPAPIPluginInstance::SetDrawingModel(NPDrawingModel aModel)
19246: {
19246:   mDrawingModel = aModel;
19246: }
19246: 
32019: void nsNPAPIPluginInstance::SetEventModel(NPEventModel aModel)
32019: {
34717:   // the event model needs to be set for the object frame immediately
34717:   nsCOMPtr<nsIPluginInstanceOwner> owner;
34717:   GetOwner(getter_AddRefs(owner));
34717:   if (!owner) {
34717:     NS_WARNING("Trying to set event model without a plugin instance owner!");
34717:     return;
34717:   }
34717: 
34717:   owner->SetEventModel(aModel);
32019: }
32019: 
32799: #endif
32799: 
32799: NS_IMETHODIMP nsNPAPIPluginInstance::GetDrawingModel(PRInt32* aModel)
32019: {
32799: #ifdef XP_MACOSX
32799:   *aModel = (PRInt32)mDrawingModel;
32799:   return NS_OK;
32799: #else
32799:   return NS_ERROR_FAILURE;
32799: #endif
32019: }
32799: 
29953: NS_IMETHODIMP
29953: nsNPAPIPluginInstance::GetJSObject(JSContext *cx, JSObject** outObject)
19246: {
19246:   NPObject *npobj = nsnull;
32799:   nsresult rv = GetValueFromPlugin(NPPVpluginScriptableNPObject, &npobj);
29953:   if (NS_FAILED(rv) || !npobj)
29953:     return NS_ERROR_FAILURE;
19246: 
30212:   *outObject = nsNPObjWrapper::GetNewOrUsed(&mNPP, cx, npobj);
19246: 
19246:   _releaseobject(npobj);
29953: 
29953:   return NS_OK;
19246: }
19246: 
29953: NS_IMETHODIMP
19246: nsNPAPIPluginInstance::DefineJavaProperties()
19246: {
19246:   NPObject *plugin_obj = nsnull;
19246: 
19246:   // The dummy Java plugin's scriptable object is what we want to
19246:   // expose as window.Packages. And Window.Packages.java will be
19246:   // exposed as window.java.
19246: 
19246:   // Get the scriptable plugin object.
32799:   nsresult rv = GetValueFromPlugin(NPPVpluginScriptableNPObject, &plugin_obj);
19246: 
19246:   if (NS_FAILED(rv) || !plugin_obj) {
29953:     return NS_ERROR_FAILURE;
19246:   }
19246: 
19246:   // Get the NPObject wrapper for window.
30212:   NPObject *window_obj = _getwindowobject(&mNPP);
19246: 
19246:   if (!window_obj) {
19246:     _releaseobject(plugin_obj);
19246: 
29953:     return NS_ERROR_FAILURE;
19246:   }
19246: 
19246:   NPIdentifier java_id = _getstringidentifier("java");
19246:   NPIdentifier packages_id = _getstringidentifier("Packages");
19246: 
19246:   NPObject *java_obj = nsnull;
19246:   NPVariant v;
19246:   OBJECT_TO_NPVARIANT(plugin_obj, v);
19246: 
19246:   // Define the properties.
19246: 
30212:   bool ok = _setproperty(&mNPP, window_obj, packages_id, &v);
19246:   if (ok) {
30212:     ok = _getproperty(&mNPP, plugin_obj, java_id, &v);
19246: 
19246:     if (ok && NPVARIANT_IS_OBJECT(v)) {
19246:       // Set java_obj so that we properly release it at the end of
19246:       // this function.
19246:       java_obj = NPVARIANT_TO_OBJECT(v);
19246: 
30212:       ok = _setproperty(&mNPP, window_obj, java_id, &v);
19246:     }
19246:   }
19246: 
19246:   _releaseobject(window_obj);
19246:   _releaseobject(plugin_obj);
19246:   _releaseobject(java_obj);
29953: 
29953:   if (!ok)
29953:     return NS_ERROR_FAILURE;
29953: 
29953:   return NS_OK;
19246: }
19246: 
35426: nsresult
35426: nsNPAPIPluginInstance::SetCached(PRBool aCache)
35426: {
35426:   mCached = aCache;
35426:   return NS_OK;
35426: }
35426: 
29953: NS_IMETHODIMP
32799: nsNPAPIPluginInstance::ShouldCache(PRBool* shouldCache)
32799: {
32799:   *shouldCache = mCached;
32799:   return NS_OK;
32799: }
32799: 
32799: NS_IMETHODIMP
32799: nsNPAPIPluginInstance::IsWindowless(PRBool* isWindowless)
32799: {
32799:   *isWindowless = mWindowless;
32799:   return NS_OK;
32799: }
32799: 
32799: NS_IMETHODIMP
52409: nsNPAPIPluginInstance::AsyncSetWindow(NPWindow* window)
52409: {
52409:   if (RUNNING != mRunning)
52409:     return NS_OK;
52409: 
52409:   PluginDestructionGuard guard(this);
52409: 
52409:   if (!mPlugin)
52409:     return NS_ERROR_FAILURE;
52409: 
52409:   PluginLibrary* library = mPlugin->GetLibrary();
52409:   if (!library)
52409:     return NS_ERROR_FAILURE;
52409: 
52409:   return library->AsyncSetWindow(&mNPP, window);
52409: }
52409: 
52409: NS_IMETHODIMP
52409: nsNPAPIPluginInstance::GetSurface(gfxASurface** aSurface)
52409: {
52409:   if (RUNNING != mRunning)
52409:     return NS_OK;
52409: 
52409:   PluginDestructionGuard guard(this);
52409: 
52409:   if (!mPlugin)
52409:     return NS_ERROR_FAILURE;
52409: 
52409:   PluginLibrary* library = mPlugin->GetLibrary();
52409:   if (!library)
52409:     return NS_ERROR_FAILURE;
52409: 
52409:   return library->GetSurface(&mNPP, aSurface);
52409: }
52409: 
52409: 
52409: NS_IMETHODIMP
52409: nsNPAPIPluginInstance::NotifyPainted(void)
52409: {
57225:   NS_NOTREACHED("Dead code, shouldn't be called.");
57225:   return NS_ERROR_NOT_IMPLEMENTED;
52409: }
52409: 
53941: NS_IMETHODIMP
53941: nsNPAPIPluginInstance::UseAsyncPainting(PRBool* aIsAsync)
53941: {
54899:   if (!mUsePluginLayersPref) {
54899:     *aIsAsync = mUsePluginLayersPref;
54899:     return NS_OK;
54899:   }
54899: 
53941:   PluginDestructionGuard guard(this);
53941: 
53941:   if (!mPlugin)
53941:     return NS_ERROR_FAILURE;
53941: 
53941:   PluginLibrary* library = mPlugin->GetLibrary();
53941:   if (!library)
53941:     return NS_ERROR_FAILURE;
53941: 
57203:   *aIsAsync = library->UseAsyncPainting();
57203:   return NS_OK;
53941: }
52409: 
52409: NS_IMETHODIMP
32799: nsNPAPIPluginInstance::IsTransparent(PRBool* isTransparent)
32799: {
32799:   *isTransparent = mTransparent;
32799:   return NS_OK;
32799: }
32799: 
32799: NS_IMETHODIMP
19246: nsNPAPIPluginInstance::GetFormValue(nsAString& aValue)
19246: {
19246:   aValue.Truncate();
19246: 
19246:   char *value = nsnull;
32799:   nsresult rv = GetValueFromPlugin(NPPVformValue, &value);
29953:   if (NS_FAILED(rv) || !value)
29953:     return NS_ERROR_FAILURE;
19246: 
19246:   CopyUTF8toUTF16(value, aValue);
19246: 
19246:   // NPPVformValue allocates with NPN_MemAlloc(), which uses
19246:   // nsMemory.
19246:   nsMemory::Free(value);
19246: 
19246:   return NS_OK;
19246: }
19246: 
29953: NS_IMETHODIMP
19246: nsNPAPIPluginInstance::PushPopupsEnabledState(PRBool aEnabled)
19246: {
19246:   nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
19246:   if (!window)
29953:     return NS_ERROR_FAILURE;
19246: 
19246:   PopupControlState oldState =
19246:     window->PushPopupControlState(aEnabled ? openAllowed : openAbused,
19246:                                   PR_TRUE);
19246: 
26912:   if (!mPopupStates.AppendElement(oldState)) {
29953:     // Appending to our state stack failed, pop what we just pushed.
19246:     window->PopPopupControlState(oldState);
29953:     return NS_ERROR_FAILURE;
19246:   }
19246: 
29953:   return NS_OK;
29953: }
29953: 
29953: NS_IMETHODIMP
19246: nsNPAPIPluginInstance::PopPopupsEnabledState()
19246: {
26912:   PRInt32 last = mPopupStates.Length() - 1;
19246: 
19246:   if (last < 0) {
19246:     // Nothing to pop.
29953:     return NS_OK;
19246:   }
19246: 
19246:   nsCOMPtr<nsPIDOMWindow> window = GetDOMWindow();
19246:   if (!window)
29953:     return NS_ERROR_FAILURE;
19246: 
26912:   PopupControlState &oldState = mPopupStates[last];
19246: 
19246:   window->PopPopupControlState(oldState);
19246: 
19246:   mPopupStates.RemoveElementAt(last);
29953:   
29953:   return NS_OK;
19246: }
19246: 
29953: NS_IMETHODIMP
29953: nsNPAPIPluginInstance::GetPluginAPIVersion(PRUint16* version)
19246: {
29953:   NS_ENSURE_ARG_POINTER(version);
47965: 
47965:   if (!mPlugin)
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   if (!mPlugin->GetLibrary())
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
47965: 
47965:   *version = pluginFunctions->version;
47965: 
29953:   return NS_OK;
19246: }
24475: 
29937: nsresult
29937: nsNPAPIPluginInstance::PrivateModeStateChanged()
24475: {
39211:   if (RUNNING != mRunning)
24475:     return NS_OK;
24475: 
24475:   PLUGIN_LOG(PLUGIN_LOG_NORMAL, ("nsNPAPIPluginInstance informing plugin of private mode state change this=%p\n",this));
24475: 
55810:   if (!mPlugin || !mPlugin->GetLibrary())
47965:     return NS_ERROR_FAILURE;
47965: 
47965:   NPPluginFuncs* pluginFunctions = mPlugin->PluginFuncs();
47965: 
47965:   if (pluginFunctions->setvalue) {
24475:     PluginDestructionGuard guard(this);
24475:     
24475:     nsCOMPtr<nsIPrivateBrowsingService> pbs = do_GetService(NS_PRIVATE_BROWSING_SERVICE_CONTRACTID);
24475:     if (pbs) {
24475:       PRBool pme = PR_FALSE;
24475:       nsresult rv = pbs->GetPrivateBrowsingEnabled(&pme);
24475:       if (NS_FAILED(rv))
24475:         return rv;
24475: 
24475:       NPError error;
39529:       NPBool value = static_cast<NPBool>(pme);
55810:       NS_TRY_SAFE_CALL_RETURN(error, (*pluginFunctions->setvalue)(&mNPP, NPNVprivateModeBool, &value), this);
24475:       return (error == NPERR_NO_ERROR) ? NS_OK : NS_ERROR_FAILURE;
24475:     }
24475:   }
24475:   return NS_ERROR_FAILURE;
24475: }
29603: 
29937: static void
29937: PluginTimerCallback(nsITimer *aTimer, void *aClosure)
29937: {
29937:   nsNPAPITimer* t = (nsNPAPITimer*)aClosure;
29937:   NPP npp = t->npp;
29937:   uint32_t id = t->id;
29937: 
29937:   (*(t->callback))(npp, id);
29937: 
29937:   // Make sure we still have an instance and the timer is still alive
29937:   // after the callback.
29937:   nsNPAPIPluginInstance *inst = (nsNPAPIPluginInstance*)npp->ndata;
29937:   if (!inst || !inst->TimerWithID(id, NULL))
29937:     return;
29937: 
29937:   // use UnscheduleTimer to clean up if this is a one-shot timer
29937:   PRUint32 timerType;
29937:   t->timer->GetType(&timerType);
29937:   if (timerType == nsITimer::TYPE_ONE_SHOT)
29937:       inst->UnscheduleTimer(id);
29937: }
29937: 
29937: nsNPAPITimer*
29937: nsNPAPIPluginInstance::TimerWithID(uint32_t id, PRUint32* index)
29937: {
29937:   PRUint32 len = mTimers.Length();
29937:   for (PRUint32 i = 0; i < len; i++) {
29937:     if (mTimers[i]->id == id) {
29937:       if (index)
29937:         *index = i;
29937:       return mTimers[i];
29937:     }
29937:   }
29937:   return nsnull;
29937: }
29937: 
29937: uint32_t
29937: nsNPAPIPluginInstance::ScheduleTimer(uint32_t interval, NPBool repeat, void (*timerFunc)(NPP npp, uint32_t timerID))
29937: {
29937:   nsNPAPITimer *newTimer = new nsNPAPITimer();
29937: 
30212:   newTimer->npp = &mNPP;
29937: 
29937:   // generate ID that is unique to this instance
29937:   uint32_t uniqueID = mTimers.Length();
29937:   while ((uniqueID == 0) || TimerWithID(uniqueID, NULL))
29937:     uniqueID++;
29937:   newTimer->id = uniqueID;
29937: 
29937:   // create new xpcom timer, scheduled correctly
29937:   nsresult rv;
29937:   nsCOMPtr<nsITimer> xpcomTimer = do_CreateInstance(NS_TIMER_CONTRACTID, &rv);
41331:   if (NS_FAILED(rv)) {
41331:     delete newTimer;
29937:     return 0;
41331:   }
29937:   const short timerType = (repeat ? (short)nsITimer::TYPE_REPEATING_SLACK : (short)nsITimer::TYPE_ONE_SHOT);
29937:   xpcomTimer->InitWithFuncCallback(PluginTimerCallback, newTimer, interval, timerType);
29937:   newTimer->timer = xpcomTimer;
29937: 
29937:   // save callback function
29937:   newTimer->callback = timerFunc;
29937: 
29937:   // add timer to timers array
29937:   mTimers.AppendElement(newTimer);
29937: 
29937:   return newTimer->id;
29937: }
29937: 
29937: void
29937: nsNPAPIPluginInstance::UnscheduleTimer(uint32_t timerID)
29937: {
29937:   // find the timer struct by ID
29937:   PRUint32 index;
29937:   nsNPAPITimer* t = TimerWithID(timerID, &index);
29937:   if (!t)
29937:     return;
29937: 
29937:   // cancel the timer
29937:   t->timer->Cancel();
29937: 
29937:   // remove timer struct from array
29937:   mTimers.RemoveElementAt(index);
29937: 
29937:   // delete timer
29937:   delete t;
29937: }
29937: 
32019: // Show the context menu at the location for the current event.
32019: // This can only be called from within an NPP_SendEvent call.
32019: NPError
32019: nsNPAPIPluginInstance::PopUpContextMenu(NPMenu* menu)
32019: {
32019:   if (mOwner && mCurrentPluginEvent)
32019:     return mOwner->ShowNativeContextMenu(menu, mCurrentPluginEvent);
32019: 
32019:   return NPERR_GENERIC_ERROR;
32019: }
32019: 
32019: NPBool
32019: nsNPAPIPluginInstance::ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
32019:                                     double *destX, double *destY, NPCoordinateSpace destSpace)
32019: {
32019:   if (mOwner)
32019:     return mOwner->ConvertPoint(sourceX, sourceY, sourceSpace, destX, destY, destSpace);
32019: 
32019:   return PR_FALSE;
32019: }
32019: 
29834: nsresult
29834: nsNPAPIPluginInstance::GetDOMElement(nsIDOMElement* *result)
29834: {
29834:   if (!mOwner) {
29834:     *result = nsnull;
29834:     return NS_ERROR_FAILURE;
29834:   }
29834: 
29952:   nsCOMPtr<nsIPluginTagInfo> tinfo(do_QueryInterface(mOwner));
29834:   if (tinfo)
29834:     return tinfo->GetDOMElement(result);
29834: 
29834:   return NS_ERROR_FAILURE;
29834: }
29834: 
29603: NS_IMETHODIMP
32799: nsNPAPIPluginInstance::InvalidateRect(NPRect *invalidRect)
29603: {
59576:   if (RUNNING != mRunning)
59576:     return NS_OK;
59576: 
29603:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   GetOwner(getter_AddRefs(owner));
29603:   if (!owner)
29603:     return NS_ERROR_FAILURE;
29603: 
29603:   return owner->InvalidateRect(invalidRect);
29603: }
29603: 
29603: NS_IMETHODIMP
32799: nsNPAPIPluginInstance::InvalidateRegion(NPRegion invalidRegion)
29603: {
59576:   if (RUNNING != mRunning)
59576:     return NS_OK;
59576: 
29603:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   GetOwner(getter_AddRefs(owner));
29603:   if (!owner)
29603:     return NS_ERROR_FAILURE;
29603: 
29603:   return owner->InvalidateRegion(invalidRegion);
29603: }
29603: 
29603: NS_IMETHODIMP
29603: nsNPAPIPluginInstance::ForceRedraw()
29603: {
59576:   if (RUNNING != mRunning)
59576:     return NS_OK;
59576: 
29603:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   GetOwner(getter_AddRefs(owner));
29603:   if (!owner)
29603:     return NS_ERROR_FAILURE;
29603: 
29603:   return owner->ForceRedraw();
29603: }
29808: 
29808: NS_IMETHODIMP
30224: nsNPAPIPluginInstance::GetMIMEType(const char* *result)
29808: {
29808:   if (!mMIMEType)
29808:     *result = "";
29808:   else
29808:     *result = mMIMEType;
29808: 
29808:   return NS_OK;
29808: }
29808: 
29808: NS_IMETHODIMP
29808: nsNPAPIPluginInstance::GetJSContext(JSContext* *outContext)
29808: {
29808:   nsCOMPtr<nsIPluginInstanceOwner> owner;
29834:   GetOwner(getter_AddRefs(owner));
29808:   if (!owner)
29808:     return NS_ERROR_FAILURE;
29808: 
29808:   *outContext = NULL;
29808:   nsCOMPtr<nsIDocument> document;
29808: 
29808:   nsresult rv = owner->GetDocument(getter_AddRefs(document));
29808: 
29808:   if (NS_SUCCEEDED(rv) && document) {
29808:     nsIScriptGlobalObject *global = document->GetScriptGlobalObject();
29808: 
29808:     if (global) {
29808:       nsIScriptContext *context = global->GetContext();
29808: 
29808:       if (context) {
29808:         *outContext = (JSContext*) context->GetNativeContext();
29808:       }
29808:     }
29808:   }
29808: 
29808:   return rv;
29808: }
29834: 
29834: NS_IMETHODIMP
29834: nsNPAPIPluginInstance::GetOwner(nsIPluginInstanceOwner **aOwner)
29834: {
29834:   NS_ENSURE_ARG_POINTER(aOwner);
29834:   *aOwner = mOwner;
29834:   NS_IF_ADDREF(mOwner);
29834:   return (mOwner ? NS_OK : NS_ERROR_FAILURE);
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsNPAPIPluginInstance::SetOwner(nsIPluginInstanceOwner *aOwner)
29834: {
29834:   mOwner = aOwner;
29834:   return NS_OK;
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsNPAPIPluginInstance::ShowStatus(const char* message)
29834: {
29834:   if (mOwner)
29834:     return mOwner->ShowStatus(message);
29834: 
29834:   return NS_ERROR_FAILURE;
29834: }
29834: 
29834: NS_IMETHODIMP
29834: nsNPAPIPluginInstance::InvalidateOwner()
29834: {
29834:   mOwner = nsnull;
29834: 
29834:   return NS_OK;
29834: }
52409: 
52409: nsresult
52409: nsNPAPIPluginInstance::AsyncSetWindow(NPWindow& window)
52409: {
52409:   return NS_ERROR_NOT_IMPLEMENTED;
52409: }
60021: 
60021: void
60021: nsNPAPIPluginInstance::URLRedirectResponse(void* notifyData, NPBool allow)
60021: {
60021:   if (!notifyData) {
60021:     return;
60021:   }
60021: 
60021:   PRUint32 listenerCount = mStreamListeners.Length();
60021:   for (PRUint32 i = 0; i < listenerCount; i++) {
60021:     nsNPAPIPluginStreamListener* currentListener = mStreamListeners[i];
60021:     if (currentListener->GetNotifyData() == notifyData) {
60021:       currentListener->URLRedirectResponse(allow);
60021:     }
60021:   }
60021: }
61864: 
61864: class CarbonEventModelFailureEvent : public nsRunnable {
61864: public:
61864:   nsCOMPtr<nsIContent> mContent;
61864: 
61864:   CarbonEventModelFailureEvent(nsIContent* aContent)
61864:     : mContent(aContent)
61864:   {}
61864: 
61864:   ~CarbonEventModelFailureEvent() {}
61864: 
61864:   NS_IMETHOD Run();
61864: };
61864: 
61864: NS_IMETHODIMP
61864: CarbonEventModelFailureEvent::Run()
61864: {
61864:   nsString type = NS_LITERAL_STRING("npapi-carbon-event-model-failure");
61864:   nsContentUtils::DispatchTrustedEvent(mContent->GetDocument(), mContent,
61864:                                        type, PR_TRUE, PR_TRUE);
61864:   return NS_OK;
61864: }
61864: 
61864: void
61864: nsNPAPIPluginInstance::CarbonNPAPIFailure()
61864: {
61864:   nsCOMPtr<nsIDOMElement> element;
61864:   GetDOMElement(getter_AddRefs(element));
61864:   if (!element) {
61864:     return;
61864:   }
61864: 
61864:   nsCOMPtr<nsIContent> content(do_QueryInterface(element));
61864:   if (!content) {
61864:     return;
61864:   }
61864: 
61864:   nsCOMPtr<nsIRunnable> e = new CarbonEventModelFailureEvent(content);
61864:   nsresult rv = NS_DispatchToCurrentThread(e);
61864:   if (NS_FAILED(rv)) {
61864:     NS_WARNING("Failed to dispatch CarbonEventModelFailureEvent.");
61864:   }
61864: }
