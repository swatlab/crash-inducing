    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Roland Mainz <roland.mainz@informatik.med.uni-giessen.de>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsPrintEngine.h"
    1: 
    1: #include "nsIStringBundle.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsCRT.h"
    1: 
    1: #include "nsISelection.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsPIDOMWindow.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIURI.h"
36876: #include "nsITextToSubURI.h"
    1: #include "nsContentErrors.h"
    1: 
    1: // Print Options
    1: #include "nsIPrintSettings.h"
    1: #include "nsIPrintSettingsService.h"
    1: #include "nsIPrintOptions.h"
    1: #include "nsIPrintSession.h"
    1: #include "nsGfxCIID.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsGkAtoms.h"
    1: #include "nsXPCOM.h"
    1: #include "nsISupportsPrimitives.h"
    1: 
    1: static const char sPrintSettingsServiceContractID[] = "@mozilla.org/gfx/printsettings-service;1";
    1: 
    1: // Printing Events
    1: #include "nsPrintPreviewListener.h"
    1: #include "nsThreadUtils.h"
    1: 
    1: // Printing
    1: #include "nsIWebBrowserPrint.h"
    1: #include "nsIDOMHTMLFrameElement.h"
    1: #include "nsIDOMHTMLFrameSetElement.h"
    1: #include "nsIDOMHTMLIFrameElement.h"
    1: #include "nsIDOMHTMLObjectElement.h"
    1: #include "nsIDOMHTMLEmbedElement.h"
    1: 
    1: // Print Preview
    1: #include "imgIContainer.h" // image animation mode constants
    1: #include "nsIWebBrowserPrint.h" // needed for PrintPreview Navigation constants
    1: 
    1: // Print Progress
    1: #include "nsIPrintProgress.h"
    1: #include "nsIPrintProgressParams.h"
    1: #include "nsIObserver.h"
    1: 
    1: // Print error dialog
    1: #include "nsIPrompt.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsIStringBundle.h"
    1: 
    1: // Printing Prompts
    1: #include "nsIPrintingPromptService.h"
    1: static const char kPrintingPromptService[] = "@mozilla.org/embedcomp/printingprompt-service;1";
    1: 
    1: // Printing Timer
    1: #include "nsPagePrintTimer.h"
    1: 
    1: // FrameSet
    1: #include "nsIDocument.h"
    1: 
    1: // Focus
 1418: #include "nsIDOMEventTarget.h"
    1: #include "nsIDOMFocusListener.h"
    1: #include "nsISelectionController.h"
    1: 
    1: // Misc
    1: #include "nsISupportsUtils.h"
    1: #include "nsIFrame.h"
    1: #include "nsIScriptContext.h"
    1: #include "nsILinkHandler.h"
    1: #include "nsIDOMDocument.h"
    1: #include "nsISelectionListener.h"
    1: #include "nsISelectionPrivate.h"
    1: #include "nsIDOMHTMLDocument.h"
16977: #include "nsIDOMNSDocument.h"
    1: #include "nsIDOMNSHTMLDocument.h"
    1: #include "nsIDOMHTMLCollection.h"
    1: #include "nsIDOMHTMLElement.h"
    1: #include "nsIDOMRange.h"
    1: #include "nsContentCID.h"
    1: #include "nsLayoutCID.h"
    1: #include "nsContentUtils.h"
    1: #include "nsIPresShell.h"
    1: #include "nsLayoutUtils.h"
    1: 
    1: #include "nsViewsCID.h"
    1: #include "nsWidgetsCID.h"
    1: #include "nsIDeviceContext.h"
    1: #include "nsIDeviceContextSpec.h"
    1: #include "nsIViewManager.h"
    1: #include "nsIView.h"
    1: 
    1: #include "nsIPageSequenceFrame.h"
    1: #include "nsIURL.h"
    1: #include "nsIContentViewerEdit.h"
    1: #include "nsIContentViewerFile.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsIInterfaceRequestor.h"
    1: #include "nsIInterfaceRequestorUtils.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeNode.h"
    1: #include "nsIDocShellTreeOwner.h"
 7849: #include "nsIWebBrowserChrome.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIBaseWindow.h"
    1: #include "nsILayoutHistoryState.h"
    1: #include "nsFrameManager.h"
    1: #include "nsIParser.h"
    1: #include "nsGUIEvent.h"
    1: #include "nsHTMLReflowState.h"
    1: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMHTMLAreaElement.h"
    1: #include "nsIDOMHTMLLinkElement.h"
    1: #include "nsIDOMHTMLImageElement.h"
    1: #include "nsIContentViewerContainer.h"
    1: #include "nsIContentViewer.h"
51637: #include "nsIDocumentViewer.h"
    1: #include "nsIDocumentViewerPrint.h"
    1: 
    1: #include "nsPIDOMWindow.h"
29018: #include "nsFocusManager.h"
35581: #include "nsRange.h"
    1: #include "nsCDefaultURIFixup.h"
    1: #include "nsIURIFixup.h"
41930: #include "mozilla/dom/Element.h"
41634: 
41634: using namespace mozilla::dom;
    1: 
    1: //-----------------------------------------------------
    1: // PR LOGGING
    1: #ifdef MOZ_LOGGING
    1: #define FORCE_PR_LOG /* Allow logging in the release build */
    1: #endif
    1: 
    1: #include "prlog.h"
    1: 
    1: #ifdef PR_LOGGING
    1: 
    1: #ifdef NS_DEBUG
    1: // PR_LOGGING is force to always be on (even in release builds)
    1: // but we only want some of it on,
    1: //#define EXTENDED_DEBUG_PRINTING 
    1: #endif
    1: 
    1: #define DUMP_LAYOUT_LEVEL 9 // this turns on the dumping of each doucment's layout info
    1: 
    1: static PRLogModuleInfo * kPrintingLogMod = PR_NewLogModule("printing");
    1: #define PR_PL(_p1)  PR_LOG(kPrintingLogMod, PR_LOG_DEBUG, _p1);
    1: 
    1: #ifdef EXTENDED_DEBUG_PRINTING
    1: static PRUint32 gDumpFileNameCnt   = 0;
    1: static PRUint32 gDumpLOFileNameCnt = 0;
    1: #endif
    1: 
    1: #define PRT_YESNO(_p) ((_p)?"YES":"NO")
    1: static const char * gFrameTypesStr[]       = {"eDoc", "eFrame", "eIFrame", "eFrameSet"};
    1: static const char * gPrintFrameTypeStr[]   = {"kNoFrames", "kFramesAsIs", "kSelectedFrame", "kEachFrameSep"};
    1: static const char * gFrameHowToEnableStr[] = {"kFrameEnableNone", "kFrameEnableAll", "kFrameEnableAsIsAndEach"};
    1: static const char * gPrintRangeStr[]       = {"kRangeAllPages", "kRangeSpecifiedPageRange", "kRangeSelection", "kRangeFocusFrame"};
    1: #else
    1: #define PRT_YESNO(_p)
    1: #define PR_PL(_p1)
    1: #endif
    1: 
    1: #ifdef EXTENDED_DEBUG_PRINTING
    1: // Forward Declarations
24551: static void DumpPrintObjectsListStart(const char * aStr, nsTArray<nsPrintObject*> * aDocList);
    1: static void DumpPrintObjectsTree(nsPrintObject * aPO, int aLevel= 0, FILE* aFD = nsnull);
    1: static void DumpPrintObjectsTreeLayout(nsPrintObject * aPO,nsIDeviceContext * aDC, int aLevel= 0, FILE * aFD = nsnull);
    1: 
    1: #define DUMP_DOC_LIST(_title) DumpPrintObjectsListStart((_title), mPrt->mPrintDocList);
    1: #define DUMP_DOC_TREE DumpPrintObjectsTree(mPrt->mPrintObject);
    1: #define DUMP_DOC_TREELAYOUT DumpPrintObjectsTreeLayout(mPrt->mPrintObject, mPrt->mPrintDC);
    1: #else
    1: #define DUMP_DOC_LIST(_title)
    1: #define DUMP_DOC_TREE
    1: #define DUMP_DOC_TREELAYOUT
    1: #endif
    1: 
25991: class nsScriptSuppressor
25991: {
25991: public:
25991:   nsScriptSuppressor(nsPrintEngine* aPrintEngine)
25991:   : mPrintEngine(aPrintEngine), mSuppressed(PR_FALSE) {}
25991: 
25991:   ~nsScriptSuppressor() { Unsuppress(); }
25991: 
25991:   void Suppress()
25991:   {
25991:     if (mPrintEngine) {
25991:       mSuppressed = PR_TRUE;
25991:       mPrintEngine->TurnScriptingOn(PR_FALSE);
25991:     }
25991:   }
25991:   
25991:   void Unsuppress()
25991:   {
25991:     if (mPrintEngine && mSuppressed) {
25991:       mPrintEngine->TurnScriptingOn(PR_TRUE);
25991:     }
25991:     mSuppressed = PR_FALSE;
25991:   }
25991: 
25991:   void Disconnect() { mPrintEngine = nsnull; }
25991: protected:
25991:   nsRefPtr<nsPrintEngine> mPrintEngine;
25991:   PRBool                  mSuppressed;
25991: };
    1: 
    1: // Class IDs
    1: static NS_DEFINE_CID(kViewManagerCID,       NS_VIEW_MANAGER_CID);
    1: 
    1: NS_IMPL_ISUPPORTS1(nsPrintEngine, nsIObserver)
    1: 
    1: //---------------------------------------------------
    1: //-- nsPrintEngine Class Impl
    1: //---------------------------------------------------
    1: nsPrintEngine::nsPrintEngine() :
    1:   mIsCreatingPrintPreview(PR_FALSE),
    1:   mIsDoingPrinting(PR_FALSE),
11852:   mIsDoingPrintPreview(PR_FALSE),
11852:   mProgressDialogIsShown(PR_FALSE),
    1:   mContainer(nsnull),
31784:   mScreenDPI(115.0f),
    1:   mPrt(nsnull),
    1:   mPagePrintTimer(nsnull),
    1:   mPageSeqFrame(nsnull),
    1:   mPrtPreview(nsnull),
    1:   mOldPrtPreview(nsnull),
11852:   mDebugFile(nsnull)
    1: {
    1: }
    1: 
    1: //-------------------------------------------------------
    1: nsPrintEngine::~nsPrintEngine()
    1: {
    1:   Destroy(); // for insurance
    1: }
    1: 
    1: //-------------------------------------------------------
    1: void nsPrintEngine::Destroy()
    1: {
    1:   if (mPrt) {
    1:     delete mPrt;
    1:     mPrt = nsnull;
    1:   }
    1: 
    1: #ifdef NS_PRINT_PREVIEW
    1:   if (mPrtPreview) {
    1:     delete mPrtPreview;
    1:     mPrtPreview = nsnull;
    1:   }
    1: 
    1:   // This is insruance
    1:   if (mOldPrtPreview) {
    1:     delete mOldPrtPreview;
    1:     mOldPrtPreview = nsnull;
    1:   }
    1: 
    1: #endif
19768:   mDocViewerPrint = nsnull;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: void nsPrintEngine::DestroyPrintingData()
    1: {
    1:   if (mPrt) {
    1:     delete mPrt;
    1:     mPrt = nsnull;
    1:   }
    1: }
    1: 
    1: //---------------------------------------------------------------------------------
    1: //-- Section: Methods needed by the DocViewer
    1: //---------------------------------------------------------------------------------
    1: 
    1: //--------------------------------------------------------
    1: nsresult nsPrintEngine::Initialize(nsIDocumentViewerPrint* aDocViewerPrint, 
    1:                                    nsISupports*            aContainer,
    1:                                    nsIDocument*            aDocument,
31784:                                    float                   aScreenDPI,
    1:                                    FILE*                   aDebugFile)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDocViewerPrint);
    1:   NS_ENSURE_ARG_POINTER(aContainer);
    1:   NS_ENSURE_ARG_POINTER(aDocument);
    1: 
19768:   mDocViewerPrint = aDocViewerPrint;
    1:   mContainer      = aContainer;      // weak reference
    1:   mDocument       = aDocument;
31784:   mScreenDPI      = aScreenDPI;
    1: 
    1:   mDebugFile      = aDebugFile;      // ok to be NULL
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: PRBool
    1: nsPrintEngine::CheckBeforeDestroy()
    1: {
    1:   if (mPrt && mPrt->mPreparingForPrint) {
    1:     mPrt->mDocWasToBeDestroyed = PR_TRUE;
    1:     return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: nsresult
    1: nsPrintEngine::Cancelled()
    1: {
    1:   if (mPrt && mPrt->mPrintSettings) {
    1:     return mPrt->mPrintSettings->SetIsCancelled(PR_TRUE);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: // Install our event listeners on the document to prevent 
    1: // some events from being processed while in PrintPreview 
    1: //
    1: // No return code - if this fails, there isn't much we can do
    1: void
    1: nsPrintEngine::InstallPrintPreviewListener()
    1: {
    1:   if (!mPrt->mPPEventListeners) {
    1:     nsCOMPtr<nsPIDOMWindow> win(do_GetInterface(mContainer));
    1:     nsCOMPtr<nsIDOMEventTarget> target(do_QueryInterface(win->GetFrameElementInternal()));
    1:     mPrt->mPPEventListeners = new nsPrintPreviewListener(target);
    1: 
    1:     if (mPrt->mPPEventListeners) {
    1:       mPrt->mPPEventListeners->AddListeners();
    1:     }
    1:   }
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: nsresult 
    1: nsPrintEngine::GetSeqFrameAndCountPagesInternal(nsPrintObject*  aPO,
    1:                                                 nsIFrame*&    aSeqFrame,
    1:                                                 PRInt32&      aCount)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPO);
    1: 
    1:   // Finds the SimplePageSequencer frame
39668:   nsIPageSequenceFrame* seqFrame = aPO->mPresShell->GetPageSequenceFrame();
    1:   if (seqFrame) {
23554:     aSeqFrame = do_QueryFrame(seqFrame);
    1:   } else {
    1:     aSeqFrame = nsnull;
    1:   }
    1:   if (aSeqFrame == nsnull) return NS_ERROR_FAILURE;
    1: 
    1:   // first count the total number of pages
    1:   aCount = 0;
    1:   nsIFrame* pageFrame = aSeqFrame->GetFirstChild(nsnull);
    1:   while (pageFrame != nsnull) {
    1:     aCount++;
    1:     pageFrame = pageFrame->GetNextSibling();
    1:   }
    1: 
    1:   return NS_OK;
    1: 
    1: }
    1: 
    1: //-----------------------------------------------------------------
    1: nsresult nsPrintEngine::GetSeqFrameAndCountPages(nsIFrame*& aSeqFrame, PRInt32& aCount)
    1: {
    1:   NS_ASSERTION(mPrtPreview, "mPrtPreview can't be null!");
    1:   return GetSeqFrameAndCountPagesInternal(mPrtPreview->mPrintObject, aSeqFrame, aCount);
    1: }
    1: //---------------------------------------------------------------------------------
    1: //-- Done: Methods needed by the DocViewer
    1: //---------------------------------------------------------------------------------
    1: 
    1: 
    1: //---------------------------------------------------------------------------------
    1: //-- Section: nsIWebBrowserPrint
    1: //---------------------------------------------------------------------------------
    1: 
    1: // Foward decl for Debug Helper Functions
    1: #ifdef EXTENDED_DEBUG_PRINTING
    1: static int RemoveFilesInDir(const char * aDir);
    1: static void GetDocTitleAndURL(nsPrintObject* aPO, char *& aDocStr, char *& aURLStr);
    1: static void DumpPrintObjectsTree(nsPrintObject * aPO, int aLevel, FILE* aFD);
24551: static void DumpPrintObjectsList(nsTArray<nsPrintObject*> * aDocList);
    1: static void RootFrameList(nsPresContext* aPresContext, FILE* out, PRInt32 aIndent);
    1: static void DumpViews(nsIDocShell* aDocShell, FILE* out);
    1: static void DumpLayoutData(char* aTitleStr, char* aURLStr,
    1:                            nsPresContext* aPresContext,
    1:                            nsIDeviceContext * aDC, nsIFrame * aRootFrame,
    1:                            nsIDocShell * aDocShell, FILE* aFD);
    1: #endif
    1: 
    1: //--------------------------------------------------------------------------------
    1: 
    1: nsresult
    1: nsPrintEngine::CommonPrint(PRBool                  aIsPrintPreview,
    1:                            nsIPrintSettings*       aPrintSettings,
35581:                            nsIWebProgressListener* aWebProgressListener,
35581:                            nsIDOMDocument* aDoc) {
    1:   nsresult rv = DoCommonPrint(aIsPrintPreview, aPrintSettings,
35581:                               aWebProgressListener, aDoc);
    1:   if (NS_FAILED(rv)) {
    1:     if (aIsPrintPreview) {
    1:       SetIsCreatingPrintPreview(PR_FALSE);
    1:       SetIsPrintPreview(PR_FALSE);
    1:     } else {
    1:       SetIsPrinting(PR_FALSE);
    1:     }
    1:     if (mProgressDialogIsShown)
    1:       CloseProgressDialog(aWebProgressListener);
    1:     if (rv != NS_ERROR_ABORT && rv != NS_ERROR_OUT_OF_MEMORY)
    1:       ShowPrintErrorDialog(rv, !aIsPrintPreview);
    1:     delete mPrt;
    1:     mPrt = nsnull;
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: nsresult
    1: nsPrintEngine::DoCommonPrint(PRBool                  aIsPrintPreview,
    1:                              nsIPrintSettings*       aPrintSettings,
35581:                              nsIWebProgressListener* aWebProgressListener,
35581:                              nsIDOMDocument*         aDoc)
    1: {
    1:   nsresult rv;
    1: 
    1:   if (aIsPrintPreview) {
    1:     // The WebProgressListener can be QI'ed to nsIPrintingPromptService
    1:     // then that means the progress dialog is already being shown.
    1:     nsCOMPtr<nsIPrintingPromptService> pps(do_QueryInterface(aWebProgressListener));
    1:     mProgressDialogIsShown = pps != nsnull;
    1: 
    1:     if (mIsDoingPrintPreview) {
    1:       mOldPrtPreview = mPrtPreview;
    1:       mPrtPreview = nsnull;
    1:     }
    1:   } else {
    1:     mProgressDialogIsShown = PR_FALSE;
    1:   }
    1: 
    1:   mPrt = new nsPrintData(aIsPrintPreview ? nsPrintData::eIsPrintPreview :
    1:                                            nsPrintData::eIsPrinting);
    1:   NS_ENSURE_TRUE(mPrt, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // if they don't pass in a PrintSettings, then get the Global PS
    1:   mPrt->mPrintSettings = aPrintSettings;
    1:   if (!mPrt->mPrintSettings) {
    1:     rv = GetGlobalPrintSettings(getter_AddRefs(mPrt->mPrintSettings));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
 1155:   rv = CheckForPrinters(mPrt->mPrintSettings);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mPrt->mPrintSettings->SetIsCancelled(PR_FALSE);
    1:   mPrt->mPrintSettings->GetShrinkToFit(&mPrt->mShrinkToFit);
    1: 
    1:   if (aIsPrintPreview) {
    1:     SetIsCreatingPrintPreview(PR_TRUE);
    1:     SetIsPrintPreview(PR_TRUE);
 7740:     nsCOMPtr<nsIMarkupDocumentViewer> viewer =
 7740:       do_QueryInterface(mDocViewerPrint);
 7740:     if (viewer) {
 7740:       viewer->SetTextZoom(1.0f);
 7740:       viewer->SetFullZoom(1.0f);
 7740:     }
    1:   } else {
    1:     SetIsPrinting(PR_TRUE);
    1:   }
    1: 
    1:   // Create a print session and let the print settings know about it.
    1:   // The print settings hold an nsWeakPtr to the session so it does not
    1:   // need to be cleared from the settings at the end of the job.
    1:   // XXX What lifetime does the printSession need to have?
    1:   nsCOMPtr<nsIPrintSession> printSession;
    1:   if (!aIsPrintPreview) {
    1:     printSession = do_CreateInstance("@mozilla.org/gfx/printsession;1", &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     mPrt->mPrintSettings->SetPrintSession(printSession);
    1:   }
    1: 
    1:   if (aWebProgressListener != nsnull) {
    1:     mPrt->mPrintProgressListeners.AppendObject(aWebProgressListener);
    1:   }
    1: 
    1:   // Get the currently focused window and cache it
    1:   // because the Print Dialog will "steal" focus and later when you try
    1:   // to get the currently focused windows it will be NULL
    1:   mPrt->mCurrentFocusWin = FindFocusedDOMWindow();
    1: 
    1:   // Check to see if there is a "regular" selection
    1:   PRBool isSelection = IsThereARangeSelection(mPrt->mCurrentFocusWin);
    1: 
    1:   // Get the docshell for this documentviewer
    1:   nsCOMPtr<nsIDocShell> webContainer(do_QueryInterface(mContainer, &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mPrt->mPrintObject = new nsPrintObject();
    1:   NS_ENSURE_TRUE(mPrt->mPrintObject, NS_ERROR_OUT_OF_MEMORY);
35581:   rv = mPrt->mPrintObject->Init(webContainer, aDoc, aIsPrintPreview);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
24551:   NS_ENSURE_TRUE(mPrt->mPrintDocList.AppendElement(mPrt->mPrintObject),
    1:                  NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   mPrt->mIsParentAFrameSet = IsParentAFrameSet(webContainer);
    1:   mPrt->mPrintObject->mFrameType = mPrt->mIsParentAFrameSet ? eFrameSet : eDoc;
    1: 
    1:   // Build the "tree" of PrintObjects
35581:   nsCOMPtr<nsIDocShellTreeNode> parentAsNode =
35581:     do_QueryInterface(mPrt->mPrintObject->mDocShell);
24551:   BuildDocTree(parentAsNode, &mPrt->mPrintDocList, mPrt->mPrintObject);
    1: 
    1:   // XXX This isn't really correct...
35581:   if (!mPrt->mPrintObject->mDocument ||
41634:       !mPrt->mPrintObject->mDocument->GetRootElement())
    1:     return NS_ERROR_GFX_PRINTER_STARTDOC;
    1: 
    1:   // Create the linkage from the sub-docs back to the content element
    1:   // in the parent document
    1:   MapContentToWebShells(mPrt->mPrintObject, mPrt->mPrintObject);
    1: 
    1:   mPrt->mIsIFrameSelected = IsThereAnIFrameSelected(webContainer, mPrt->mCurrentFocusWin, mPrt->mIsParentAFrameSet);
    1: 
    1:   // Setup print options for UI
    1:   if (mPrt->mIsParentAFrameSet) {
    1:     if (mPrt->mCurrentFocusWin) {
    1:       mPrt->mPrintSettings->SetHowToEnableFrameUI(nsIPrintSettings::kFrameEnableAll);
    1:     } else {
    1:       mPrt->mPrintSettings->SetHowToEnableFrameUI(nsIPrintSettings::kFrameEnableAsIsAndEach);
    1:     }
    1:   } else {
    1:     mPrt->mPrintSettings->SetHowToEnableFrameUI(nsIPrintSettings::kFrameEnableNone);
    1:   }
    1:   // Now determine how to set up the Frame print UI
    1:   mPrt->mPrintSettings->SetPrintOptions(nsIPrintSettings::kEnableSelectionRB, isSelection || mPrt->mIsIFrameSelected);
    1: 
    1:   nsCOMPtr<nsIDeviceContextSpec> devspec
    1:     (do_CreateInstance("@mozilla.org/gfx/devicecontextspec;1", &rv));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
25991:   nsScriptSuppressor scriptSuppressor(this);
    1:   if (!aIsPrintPreview) {
    1: #ifdef NS_DEBUG
    1:     mPrt->mDebugFilePtr = mDebugFile;
    1: #endif
    1: 
25991:     scriptSuppressor.Suppress();
    1:     PRBool printSilently;
    1:     mPrt->mPrintSettings->GetPrintSilent(&printSilently);
    1: 
    1:     // Check prefs for a default setting as to whether we should print silently
    1:     printSilently = nsContentUtils::GetBoolPref("print.always_print_silent",
    1:                                                 printSilently);
    1: 
    1:     // Ask dialog to be Print Shown via the Plugable Printing Dialog Service
    1:     // This service is for the Print Dialog and the Print Progress Dialog
    1:     // If printing silently or you can't get the service continue on
    1:     if (!printSilently) {
    1:       nsCOMPtr<nsIPrintingPromptService> printPromptService(do_GetService(kPrintingPromptService));
    1:       if (printPromptService) {
    1:         nsIDOMWindow *domWin = mDocument->GetWindow(); 
    1:         NS_ENSURE_TRUE(domWin, NS_ERROR_FAILURE);
    1: 
    1:         // Platforms not implementing a given dialog for the service may
    1:         // return NS_ERROR_NOT_IMPLEMENTED or an error code.
    1:         //
    1:         // NS_ERROR_NOT_IMPLEMENTED indicates they want default behavior
    1:         // Any other error code means we must bail out
    1:         //
    1:         nsCOMPtr<nsIWebBrowserPrint> wbp(do_QueryInterface(mDocViewerPrint));
    1:         rv = printPromptService->ShowPrintDialog(domWin, wbp,
    1:                                                  mPrt->mPrintSettings);
58621:         //
58621:         // ShowPrintDialog triggers an event loop which means we can't assume
58621:         // that the state of this->{anything} matches the state we've checked
58621:         // above. Including that a given {thing} is non null.
58621: 
58621:         if (NS_SUCCEEDED(rv)) {
58621:           // since we got the dialog and it worked then make sure we 
58621:           // are telling GFX we want to print silent
58621:           printSilently = PR_TRUE;
58621: 
58621:           if (mPrt && mPrt->mPrintSettings) {
58621:             // The user might have changed shrink-to-fit in the print dialog, so update our copy of its state
58621:             mPrt->mPrintSettings->GetShrinkToFit(&mPrt->mShrinkToFit);
58621:           }
58621:         } else if (rv == NS_ERROR_NOT_IMPLEMENTED) {
    1:           // This means the Dialog service was there,
    1:           // but they choose not to implement this dialog and
    1:           // are looking for default behavior from the toolkit
    1:           rv = NS_OK;
58621:         }
    1:       } else {
    1:         rv = NS_ERROR_GFX_NO_PRINTROMPTSERVICE;
    1:       }
10489:     } else {
10489:       // Call any code that requires a run of the event loop.
10489:       rv = mPrt->mPrintSettings->SetupSilentPrinting();
    1:     }
    1:     // Check explicitly for abort because it's expected
    1:     if (rv == NS_ERROR_ABORT) 
    1:       return rv;
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   rv = devspec->Init(nsnull, mPrt->mPrintSettings, aIsPrintPreview);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mPrt->mPrintDC = do_CreateInstance("@mozilla.org/gfx/devicecontext;1", &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = mPrt->mPrintDC->InitForPrinting(devspec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   
    1:   if (aIsPrintPreview) {
    1:     mPrt->mPrintSettings->SetPrintFrameType(nsIPrintSettings::kFramesAsIs);
    1: 
    1:     // override any UI that wants to PrintPreview any selection or page range
    1:     // we want to view every page in PrintPreview each time
    1:     mPrt->mPrintSettings->SetPrintRange(nsIPrintSettings::kRangeAllPages);
    1:   } else {
    1:     // Always check and set the print settings first and then fall back
    1:     // onto the PrintService if there isn't a PrintSettings
    1:     //
    1:     // Posiible Usage values:
    1:     //   nsIPrintSettings::kUseInternalDefault
    1:     //   nsIPrintSettings::kUseSettingWhenPossible
    1:     //
    1:     // NOTE: The consts are the same for PrintSettings and PrintSettings
    1:     PRInt16 printFrameTypeUsage = nsIPrintSettings::kUseSettingWhenPossible;
    1:     mPrt->mPrintSettings->GetPrintFrameTypeUsage(&printFrameTypeUsage);
    1: 
    1:     // Ok, see if we are going to use our value and override the default
    1:     if (printFrameTypeUsage == nsIPrintSettings::kUseSettingWhenPossible) {
    1:       // Get the Print Options/Settings PrintFrameType to see what is preferred
    1:       PRInt16 printFrameType = nsIPrintSettings::kEachFrameSep;
    1:       mPrt->mPrintSettings->GetPrintFrameType(&printFrameType);
    1: 
    1:       // Don't let anybody do something stupid like try to set it to
    1:       // kNoFrames when we are printing a FrameSet
    1:       if (printFrameType == nsIPrintSettings::kNoFrames) {
    1:         mPrt->mPrintFrameType = nsIPrintSettings::kEachFrameSep;
    1:         mPrt->mPrintSettings->SetPrintFrameType(mPrt->mPrintFrameType);
    1:       } else {
    1:         // First find out from the PrinService what options are available
    1:         // to us for Printing FrameSets
    1:         PRInt16 howToEnableFrameUI;
    1:         mPrt->mPrintSettings->GetHowToEnableFrameUI(&howToEnableFrameUI);
    1:         if (howToEnableFrameUI != nsIPrintSettings::kFrameEnableNone) {
    1:           switch (howToEnableFrameUI) {
    1:           case nsIPrintSettings::kFrameEnableAll:
    1:             mPrt->mPrintFrameType = printFrameType;
    1:             break;
    1: 
    1:           case nsIPrintSettings::kFrameEnableAsIsAndEach:
    1:             if (printFrameType != nsIPrintSettings::kSelectedFrame) {
    1:               mPrt->mPrintFrameType = printFrameType;
    1:             } else { // revert back to a good value
    1:               mPrt->mPrintFrameType = nsIPrintSettings::kEachFrameSep;
    1:             }
    1:             break;
    1:           } // switch
    1:           mPrt->mPrintSettings->SetPrintFrameType(mPrt->mPrintFrameType);
    1:         }
    1:       }
    1:     } else {
    1:       mPrt->mPrintSettings->GetPrintFrameType(&mPrt->mPrintFrameType);
    1:     }
    1:   }
    1: 
    1:   if (aIsPrintPreview) {
    1:     PRBool notifyOnInit = PR_FALSE;
    1:     ShowPrintProgress(PR_FALSE, notifyOnInit);
    1: 
    1:     // Very important! Turn Off scripting
    1:     TurnScriptingOn(PR_FALSE);
    1: 
    1:     if (!notifyOnInit) {
    1:       rv = FinishPrintPreview();
    1:     } else {
    1:       rv = NS_OK;
    1:     }
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   } else {
    1:     PRUnichar * docTitleStr;
    1:     PRUnichar * docURLStr;
    1: 
    1:     GetDisplayTitleAndURL(mPrt->mPrintObject, &docTitleStr, &docURLStr, eDocTitleDefURLDoc); 
    1: 
    1:     // Nobody ever cared about the file name passed in, as far as I can tell
    1:     rv = mPrt->mPrintDC->PrepareDocument(docTitleStr, nsnull);
    1: 
    1:     if (docTitleStr) nsMemory::Free(docTitleStr);
    1:     if (docURLStr) nsMemory::Free(docURLStr);
    1: 
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRBool doNotify;
    1:     ShowPrintProgress(PR_TRUE, doNotify);
    1:     if (!doNotify) {
    1:       // Print listener setup...
    1:       mPrt->OnStartPrinting();    
    1:       rv = DocumentReadyForPrinting();
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1: 
25991:   // We will enable scripting later after printing has finished.
25991:   scriptSuppressor.Disconnect();
25991: 
    1:   return NS_OK;
    1: }
    1: 
    1: //---------------------------------------------------------------------------------
    1: NS_IMETHODIMP
    1: nsPrintEngine::Print(nsIPrintSettings*       aPrintSettings,
    1:                      nsIWebProgressListener* aWebProgressListener)
    1: {
37276:   // If we have a print preview document, use that instead of the original
37276:   // mDocument. That way animated images etc. get printed using the same state
37276:   // as in print preview.
37276:   nsCOMPtr<nsIDOMDocument> doc =
37276:     do_QueryInterface(mPrtPreview && mPrtPreview->mPrintObject ?
37276:                         mPrtPreview->mPrintObject->mDocument : mDocument);
37276: 
35581:   return CommonPrint(PR_FALSE, aPrintSettings, aWebProgressListener, doc);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsPrintEngine::PrintPreview(nsIPrintSettings* aPrintSettings, 
    1:                                  nsIDOMWindow *aChildDOMWin, 
    1:                                  nsIWebProgressListener* aWebProgressListener)
    1: {
13031:   // Get the DocShell and see if it is busy
13031:   // (We can't Print Preview this document if it is still busy)
13031:   nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(mContainer));
13031:   NS_ASSERTION(docShell, "This has to be a docshell");
13031: 
13031:   PRUint32 busyFlags = nsIDocShell::BUSY_FLAGS_NONE;
13031:   if (NS_FAILED(docShell->GetBusyFlags(&busyFlags)) ||
13031:       busyFlags != nsIDocShell::BUSY_FLAGS_NONE) {
13031:     CloseProgressDialog(aWebProgressListener);
13031:     ShowPrintErrorDialog(NS_ERROR_GFX_PRINTER_DOC_IS_BUSY_PP, PR_FALSE);
13031:     return NS_ERROR_FAILURE;
13031:   }
13031: 
35581:   NS_ENSURE_STATE(aChildDOMWin);
35581:   nsCOMPtr<nsIDOMDocument> doc;
35581:   aChildDOMWin->GetDocument(getter_AddRefs(doc));
35581:   NS_ENSURE_STATE(doc);
35581: 
13031:   // Document is not busy -- go ahead with the Print Preview
35581:   return CommonPrint(PR_TRUE, aPrintSettings, aWebProgressListener, doc);
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: /* readonly attribute boolean isFramesetDocument; */
    1: NS_IMETHODIMP
    1: nsPrintEngine::GetIsFramesetDocument(PRBool *aIsFramesetDocument)
    1: {
    1:   nsCOMPtr<nsIDocShell> webContainer(do_QueryInterface(mContainer));
    1:   *aIsFramesetDocument = IsParentAFrameSet(webContainer);
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: /* readonly attribute boolean isIFrameSelected; */
    1: NS_IMETHODIMP 
    1: nsPrintEngine::GetIsIFrameSelected(PRBool *aIsIFrameSelected)
    1: {
    1:   *aIsIFrameSelected = PR_FALSE;
    1: 
    1:   // Get the docshell for this documentviewer
    1:   nsCOMPtr<nsIDocShell> webContainer(do_QueryInterface(mContainer));
    1:   // Get the currently focused window
    1:   nsCOMPtr<nsIDOMWindow> currentFocusWin = FindFocusedDOMWindow();
    1:   if (currentFocusWin && webContainer) {
    1:     // Get whether the doc contains a frameset 
    1:     // Also, check to see if the currently focus docshell
    1:     // is a child of this docshell
    1:     PRPackedBool isParentFrameSet;
    1:     *aIsIFrameSelected = IsThereAnIFrameSelected(webContainer, currentFocusWin, isParentFrameSet);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: /* readonly attribute boolean isRangeSelection; */
    1: NS_IMETHODIMP 
    1: nsPrintEngine::GetIsRangeSelection(PRBool *aIsRangeSelection)
    1: {
    1:   // Get the currently focused window 
    1:   nsCOMPtr<nsIDOMWindow> currentFocusWin = FindFocusedDOMWindow();
    1:   *aIsRangeSelection = IsThereARangeSelection(currentFocusWin);
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: /* readonly attribute boolean isFramesetFrameSelected; */
    1: NS_IMETHODIMP 
    1: nsPrintEngine::GetIsFramesetFrameSelected(PRBool *aIsFramesetFrameSelected)
    1: {
    1:   // Get the currently focused window 
    1:   nsCOMPtr<nsIDOMWindow> currentFocusWin = FindFocusedDOMWindow();
    1:   *aIsFramesetFrameSelected = currentFocusWin != nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: /* readonly attribute long printPreviewNumPages; */
    1: NS_IMETHODIMP
    1: nsPrintEngine::GetPrintPreviewNumPages(PRInt32 *aPrintPreviewNumPages)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPrintPreviewNumPages);
    1: 
    1:   nsIFrame* seqFrame  = nsnull;
    1:   *aPrintPreviewNumPages = 0;
    1:   if (!mPrtPreview ||
    1:       NS_FAILED(GetSeqFrameAndCountPagesInternal(mPrtPreview->mPrintObject, seqFrame, *aPrintPreviewNumPages))) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: // Enumerate all the documents for their titles
    1: NS_IMETHODIMP
    1: nsPrintEngine::EnumerateDocumentNames(PRUint32* aCount,
    1:                                       PRUnichar*** aResult)
    1: {
    1:   NS_ENSURE_ARG(aCount);
    1:   NS_ENSURE_ARG_POINTER(aResult);
    1: 
    1:   *aCount = 0;
    1:   *aResult = nsnull;
    1: 
24551:   PRInt32     numDocs = mPrt->mPrintDocList.Length();
    1:   PRUnichar** array   = (PRUnichar**) nsMemory::Alloc(numDocs * sizeof(PRUnichar*));
    1:   if (!array)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   for (PRInt32 i=0;i<numDocs;i++) {
24551:     nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
    1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
    1:     PRUnichar * docTitleStr;
    1:     PRUnichar * docURLStr;
    1:     GetDocumentTitleAndURL(po->mDocument, &docTitleStr, &docURLStr);
    1: 
    1:     // Use the URL if the doc is empty
    1:     if (!docTitleStr || !*docTitleStr) {
    1:       if (docURLStr && *docURLStr) {
    1:         nsMemory::Free(docTitleStr);
    1:         docTitleStr = docURLStr;
    1:       } else {
    1:         nsMemory::Free(docURLStr);
    1:       }
    1:       docURLStr = nsnull;
    1:       if (!docTitleStr || !*docTitleStr) {
    1:         CleanupDocTitleArray(array, i);
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:       }
    1:     }
    1:     array[i] = docTitleStr;
    1:     if (docURLStr) nsMemory::Free(docURLStr);
    1:   }
    1:   *aCount  = numDocs;
    1:   *aResult = array;
    1: 
    1:   return NS_OK;
    1: 
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: /* readonly attribute nsIPrintSettings globalPrintSettings; */
    1: nsresult
    1: nsPrintEngine::GetGlobalPrintSettings(nsIPrintSettings **aGlobalPrintSettings)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aGlobalPrintSettings);
    1: 
    1:   nsresult rv = NS_ERROR_FAILURE;
    1:   nsCOMPtr<nsIPrintSettingsService> printSettingsService =
    1:     do_GetService(sPrintSettingsServiceContractID, &rv);
    1:   if (NS_SUCCEEDED(rv)) {
    1:     rv = printSettingsService->GetGlobalPrintSettings(aGlobalPrintSettings);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: /* readonly attribute boolean doingPrint; */
    1: NS_IMETHODIMP
    1: nsPrintEngine::GetDoingPrint(PRBool *aDoingPrint)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDoingPrint);
    1:   *aDoingPrint = mIsDoingPrinting;
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: /* readonly attribute boolean doingPrintPreview; */
    1: NS_IMETHODIMP
    1: nsPrintEngine::GetDoingPrintPreview(PRBool *aDoingPrintPreview)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aDoingPrintPreview);
    1:   *aDoingPrintPreview = mIsDoingPrintPreview;
    1:   return NS_OK;
    1: }
    1: 
    1: //----------------------------------------------------------------------------------
    1: /* readonly attribute nsIPrintSettings currentPrintSettings; */
    1: NS_IMETHODIMP
    1: nsPrintEngine::GetCurrentPrintSettings(nsIPrintSettings * *aCurrentPrintSettings)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aCurrentPrintSettings);
    1: 
    1:   if (mPrt) {
    1:     *aCurrentPrintSettings = mPrt->mPrintSettings;
    1: 
    1:   } else if (mPrtPreview) {
    1:     *aCurrentPrintSettings = mPrtPreview->mPrintSettings;
    1: 
    1:   } else {
    1:     *aCurrentPrintSettings = nsnull;
    1:   }
    1:   NS_IF_ADDREF(*aCurrentPrintSettings);
    1:   return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------
    1: //-- Section: Pre-Reflow Methods
    1: //-----------------------------------------------------------------
    1: 
    1: //---------------------------------------------------------------------
    1: // This method checks to see if there is at least one printer defined
    1: // and if so, it sets the first printer in the list as the default name
    1: // in the PrintSettings which is then used for Printer Preview
    1: nsresult
 1155: nsPrintEngine::CheckForPrinters(nsIPrintSettings* aPrintSettings)
    1: {
57613: #if defined(XP_MACOSX) || defined(ANDROID)
 1155:   // Mac doesn't support retrieving a printer list.
 1155:   return NS_OK;
 1155: #else
    1:   NS_ENSURE_ARG_POINTER(aPrintSettings);
    1: 
 1155:   // See if aPrintSettings already has a printer
 1155:   nsXPIDLString printerName;
 1155:   nsresult rv = aPrintSettings->GetPrinterName(getter_Copies(printerName));
 1155:   if (NS_SUCCEEDED(rv) && !printerName.IsEmpty()) {
 1155:     return NS_OK;
 1155:   }
 1155: 
 1155:   // aPrintSettings doesn't have a printer set. Try to fetch the default.
 1155:   nsCOMPtr<nsIPrintSettingsService> printSettingsService =
 1155:     do_GetService(sPrintSettingsServiceContractID, &rv);
 1155:   NS_ENSURE_SUCCESS(rv, rv);
 1155: 
 1155:   rv = printSettingsService->GetDefaultPrinterName(getter_Copies(printerName));
 1155:   if (NS_SUCCEEDED(rv) && !printerName.IsEmpty()) {
 1155:     rv = aPrintSettings->SetPrinterName(printerName.get());
 1155:   }
 1155:   return rv;
    1: #endif
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: // Set up to use the "pluggable" Print Progress Dialog
    1: void
    1: nsPrintEngine::ShowPrintProgress(PRBool aIsForPrinting, PRBool& aDoNotify)
    1: {
    1:   // default to not notifying, that if something here goes wrong
    1:   // or we aren't going to show the progress dialog we can straight into 
    1:   // reflowing the doc for printing.
    1:   aDoNotify = PR_FALSE;
    1: 
    1:   // Assume we can't do progress and then see if we can
    1:   PRBool showProgresssDialog = PR_FALSE;
    1: 
    1:   // if it is already being shown then don't bother to find out if it should be
    1:   // so skip this and leave mShowProgressDialog set to FALSE
    1:   if (!mProgressDialogIsShown) {
    1:     showProgresssDialog =
    1:       nsContentUtils::GetBoolPref("print.show_print_progress");
    1:   }
    1: 
    1:   // Turning off the showing of Print Progress in Prefs overrides
    1:   // whether the calling PS desire to have it on or off, so only check PS if 
    1:   // prefs says it's ok to be on.
    1:   if (showProgresssDialog) {
    1:     mPrt->mPrintSettings->GetShowPrintProgress(&showProgresssDialog);
    1:   }
    1: 
    1:   // Now open the service to get the progress dialog
    1:   // If we don't get a service, that's ok, then just don't show progress
    1:   if (showProgresssDialog) {
    1:     nsCOMPtr<nsIPrintingPromptService> printPromptService(do_GetService(kPrintingPromptService));
    1:     if (printPromptService) {
    1:       nsPIDOMWindow *domWin = mDocument->GetWindow(); 
    1:       if (!domWin) return;
    1: 
 7849:       nsCOMPtr<nsIDocShellTreeItem> docShellItem =
 7849:         do_QueryInterface(domWin->GetDocShell());
 7849:       if (!docShellItem) return;
 7849:       nsCOMPtr<nsIDocShellTreeOwner> owner;
 7849:       docShellItem->GetTreeOwner(getter_AddRefs(owner));
 7849:       nsCOMPtr<nsIWebBrowserChrome> browserChrome = do_GetInterface(owner);
 7849:       if (!browserChrome) return;
 7849:       PRBool isModal = PR_TRUE;
 7849:       browserChrome->IsWindowModal(&isModal);
 7849:       if (isModal) {
 7849:         // Showing a print progress dialog when printing a modal window
 7849:         // isn't supported. See bug 301560.
 7849:         return;
 7849:       }
 7849: 
    1:       nsCOMPtr<nsIWebProgressListener> printProgressListener;
    1: 
    1:       nsCOMPtr<nsIWebBrowserPrint> wbp(do_QueryInterface(mDocViewerPrint));
    1:       nsresult rv = printPromptService->ShowProgress(domWin, wbp, mPrt->mPrintSettings, this, aIsForPrinting,
    1:                                                      getter_AddRefs(printProgressListener), 
    1:                                                      getter_AddRefs(mPrt->mPrintProgressParams), 
    1:                                                      &aDoNotify);
    1:       if (NS_SUCCEEDED(rv)) {
    1:         if (printProgressListener && mPrt->mPrintProgressParams) {
    1:           mPrt->mPrintProgressListeners.AppendObject(printProgressListener);
    1:           SetDocAndURLIntoProgress(mPrt->mPrintObject, mPrt->mPrintProgressParams);
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: PRBool
    1: nsPrintEngine::IsThereARangeSelection(nsIDOMWindow* aDOMWin)
    1: {
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   if (aDOMWin) {
    1:     nsCOMPtr<nsPIDOMWindow> window(do_QueryInterface(aDOMWin));
    1:     window->GetDocShell()->GetPresShell(getter_AddRefs(presShell));
    1:   }
    1: 
    1:   if (!presShell)
    1:     return PR_FALSE;
    1: 
    1:   // check here to see if there is a range selection
    1:   // so we know whether to turn on the "Selection" radio button
    1:   nsCOMPtr<nsISelection> selection;
    1:   selection = presShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
    1:   if (selection) {
    1:     PRInt32 count;
    1:     selection->GetRangeCount(&count);
    1:     if (count == 1) {
    1:       nsCOMPtr<nsIDOMRange> range;
    1:       if (NS_SUCCEEDED(selection->GetRangeAt(0, getter_AddRefs(range)))) {
    1:         // check to make sure it isn't an insertion selection
    1:         PRBool isCollapsed;
    1:         selection->GetIsCollapsed(&isCollapsed);
    1:         return !isCollapsed;
    1:       }
    1:     }
    1:     if (count > 1) return PR_TRUE;
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: PRBool
    1: nsPrintEngine::IsParentAFrameSet(nsIDocShell * aParent)
    1: {
    1:   // See if the incoming doc is the root document
    1:   nsCOMPtr<nsIDocShellTreeItem> parentAsItem(do_QueryInterface(aParent));
    1:   if (!parentAsItem) return PR_FALSE;
    1: 
    1:   // When it is the top level document we need to check
    1:   // to see if it contains a frameset. If it does, then
    1:   // we only want to print the doc's children and not the document itself
    1:   // For anything else we always print all the children and the document
    1:   // for example, if the doc contains an IFRAME we eant to print the child
    1:   // document (the IFRAME) and then the rest of the document.
    1:   //
    1:   // XXX we really need to search the frame tree, and not the content
    1:   // but there is no way to distinguish between IFRAMEs and FRAMEs
    1:   // with the GetFrameType call.
    1:   // Bug 53459 has been files so we can eventually distinguish
    1:   // between IFRAME frames and FRAME frames
    1:   PRBool isFrameSet = PR_FALSE;
    1:   // only check to see if there is a frameset if there is
    1:   // NO parent doc for this doc. meaning this parent is the root doc
35581:   nsCOMPtr<nsIDOMDocument> domDoc = do_GetInterface(aParent);
35581:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
    1:   if (doc) {
41634:     nsIContent *rootElement = doc->GetRootElement();
41634:     if (rootElement) {
41634:       isFrameSet = HasFramesetChild(rootElement);
    1:     }
    1:   }
    1:   return isFrameSet;
    1: }
    1: 
    1: 
    1: //---------------------------------------------------------------------
    1: // Recursively build a list of sub documents to be printed
    1: // that mirrors the document tree
    1: void
    1: nsPrintEngine::BuildDocTree(nsIDocShellTreeNode *      aParentNode,
24551:                             nsTArray<nsPrintObject*> * aDocList,
    1:                             nsPrintObject *            aPO)
    1: {
    1:   NS_ASSERTION(aParentNode, "Pointer is null!");
    1:   NS_ASSERTION(aDocList, "Pointer is null!");
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1: 
    1:   PRInt32 childWebshellCount;
    1:   aParentNode->GetChildCount(&childWebshellCount);
    1:   if (childWebshellCount > 0) {
    1:     for (PRInt32 i=0;i<childWebshellCount;i++) {
    1:       nsCOMPtr<nsIDocShellTreeItem> child;
    1:       aParentNode->GetChildAt(i, getter_AddRefs(child));
    1:       nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
    1: 
    1:       nsCOMPtr<nsIContentViewer>  viewer;
    1:       childAsShell->GetContentViewer(getter_AddRefs(viewer));
    1:       if (viewer) {
    1:         nsCOMPtr<nsIContentViewerFile> viewerFile(do_QueryInterface(viewer));
    1:         if (viewerFile) {
    1:           nsCOMPtr<nsIDocShell> childDocShell(do_QueryInterface(child));
    1:           nsCOMPtr<nsIDocShellTreeNode> childNode(do_QueryInterface(child));
35581:           nsCOMPtr<nsIDOMDocument> doc = do_GetInterface(childDocShell);
    1:           nsPrintObject * po = new nsPrintObject();
35581:           po->mParent = aPO;
35581:           nsresult rv = po->Init(childDocShell, doc, aPO->mPrintPreview);
    1:           if (NS_FAILED(rv))
    1:             NS_NOTREACHED("Init failed?");
    1:           aPO->mKids.AppendElement(po);
    1:           aDocList->AppendElement(po);
    1:           BuildDocTree(childNode, aDocList, po);
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: void
    1: nsPrintEngine::GetDocumentTitleAndURL(nsIDocument* aDoc,
    1:                                       PRUnichar**  aTitle,
    1:                                       PRUnichar**  aURLStr)
    1: {
    1:   NS_ASSERTION(aDoc,      "Pointer is null!");
    1:   NS_ASSERTION(aTitle,    "Pointer is null!");
    1:   NS_ASSERTION(aURLStr,   "Pointer is null!");
    1: 
    1:   *aTitle  = nsnull;
    1:   *aURLStr = nsnull;
    1: 
16977:   nsAutoString docTitle;
16977:   nsCOMPtr<nsIDOMNSDocument> doc = do_QueryInterface(aDoc);
16977:   doc->GetTitle(docTitle);
    1:   if (!docTitle.IsEmpty()) {
    1:     *aTitle = ToNewUnicode(docTitle);
    1:   }
    1: 
    1:   nsIURI* url = aDoc->GetDocumentURI();
    1:   if (!url) return;
    1: 
    1:   nsCOMPtr<nsIURIFixup> urifixup(do_GetService(NS_URIFIXUP_CONTRACTID));
    1:   if (!urifixup) return;
    1: 
    1:   nsCOMPtr<nsIURI> exposableURI;
    1:   urifixup->CreateExposableURI(url, getter_AddRefs(exposableURI));
    1: 
    1:   if (!exposableURI) return;
    1: 
    1:   nsCAutoString urlCStr;
    1:   exposableURI->GetSpec(urlCStr);
36876: 
36876:   nsresult rv;
36876:   nsCOMPtr<nsITextToSubURI> textToSubURI = 
36876:     do_GetService(NS_ITEXTTOSUBURI_CONTRACTID, &rv);
36876:   if (NS_FAILED(rv)) return;
36876: 
36876:   nsAutoString unescapedURI;
36876:   rv = textToSubURI->UnEscapeURIForUI(NS_LITERAL_CSTRING("UTF-8"),
36876:                                       urlCStr, unescapedURI);
36876:   if (NS_FAILED(rv)) return;
36876: 
36876:   *aURLStr = ToNewUnicode(unescapedURI);
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: // The walks the PO tree and for each document it walks the content
    1: // tree looking for any content that are sub-shells
    1: //
    1: // It then sets the mContent pointer in the "found" PO object back to the
    1: // the document that contained it.
    1: void
    1: nsPrintEngine::MapContentToWebShells(nsPrintObject* aRootPO,
    1:                                      nsPrintObject* aPO)
    1: {
    1:   NS_ASSERTION(aRootPO, "Pointer is null!");
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1: 
    1:   // Recursively walk the content from the root item
    1:   // XXX Would be faster to enumerate the subdocuments, although right now
    1:   //     nsIDocument doesn't expose quite what would be needed.
35581:   nsCOMPtr<nsIContentViewer> viewer;
35581:   aPO->mDocShell->GetContentViewer(getter_AddRefs(viewer));
35581:   if (!viewer) return;
35581: 
35581:   nsCOMPtr<nsIDOMDocument> domDoc;
35581:   viewer->GetDOMDocument(getter_AddRefs(domDoc));
35581:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
35581:   if (!doc) return;
35581: 
41634:   Element* rootElement = doc->GetRootElement();
41634:   if (rootElement) {
41634:     MapContentForPO(aPO, rootElement);
19021:   } else {
19021:     NS_WARNING("Null root content on (sub)document.");
19021:   }
    1: 
    1:   // Continue recursively walking the chilren of this PO
24551:   for (PRUint32 i=0;i<aPO->mKids.Length();i++) {
24551:     MapContentToWebShells(aRootPO, aPO->mKids[i]);
    1:   }
    1: 
    1: }
    1: 
    1: //-------------------------------------------------------
    1: // A Frame's sub-doc may contain content or a FrameSet
    1: // When it contains a FrameSet the mFrameType for the PrintObject
    1: // is always set to an eFrame. Which is fine when printing "AsIs"
    1: // but is incorrect when when printing "Each Frame Separately".
    1: // When printing "Each Frame Separately" the Frame really acts like
    1: // a frameset.
    1: //
    1: // This method walks the PO tree and checks to see if the PrintObject is
    1: // an eFrame and has children that are eFrames (meaning it's a Frame containing a FrameSet)
    1: // If so, then the mFrameType need to be changed to eFrameSet
    1: //
    1: // Also note: We only want to call this we are printing "Each Frame Separately"
    1: //            when printing "As Is" leave it as an eFrame
    1: void
    1: nsPrintEngine::CheckForChildFrameSets(nsPrintObject* aPO)
    1: {
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1: 
    1:   // Continue recursively walking the chilren of this PO
    1:   PRBool hasChildFrames = PR_FALSE;
24551:   for (PRUint32 i=0;i<aPO->mKids.Length();i++) {
24551:     nsPrintObject* po = aPO->mKids[i];
    1:     if (po->mFrameType == eFrame) {
    1:       hasChildFrames = PR_TRUE;
    1:       CheckForChildFrameSets(po);
    1:     }
    1:   }
    1: 
    1:   if (hasChildFrames && aPO->mFrameType == eFrame) {
    1:     aPO->mFrameType = eFrameSet;
    1:   }
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: // This method is key to the entire print mechanism.
    1: //
    1: // This "maps" or figures out which sub-doc represents a
    1: // given Frame or IFrame in its parent sub-doc.
    1: //
    1: // So the Mcontent pointer in the child sub-doc points to the
    1: // content in the its parent document, that caused it to be printed.
    1: // This is used later to (after reflow) to find the absolute location
    1: // of the sub-doc on its parent's page frame so it can be
    1: // printed in the correct location.
    1: //
    1: // This method recursvely "walks" the content for a document finding
    1: // all the Frames and IFrames, then sets the "mFrameType" data member
    1: // which tells us what type of PO we have
    1: void
    1: nsPrintEngine::MapContentForPO(nsPrintObject*   aPO,
    1:                                nsIContent*      aContent)
    1: {
    1:   NS_PRECONDITION(aPO && aContent, "Null argument");
    1: 
    1:   nsIDocument* doc = aContent->GetDocument();
    1: 
    1:   NS_ASSERTION(doc, "Content without a document from a document tree?");
    1: 
    1:   nsIDocument* subDoc = doc->GetSubDocumentFor(aContent);
    1: 
    1:   if (subDoc) {
    1:     nsCOMPtr<nsISupports> container = subDoc->GetContainer();
    1:     nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(container));
    1: 
    1:     if (docShell) {
    1:       nsPrintObject * po = nsnull;
24551:       PRInt32 cnt = aPO->mKids.Length();
    1:       for (PRInt32 i=0;i<cnt;i++) {
24551:         nsPrintObject* kid = aPO->mKids.ElementAt(i);
    1:         if (kid->mDocument == subDoc) {
    1:           po = kid;
    1:           break;
    1:         }
    1:       }
    1: 
    1:       // XXX If a subdocument has no onscreen presentation, there will be no PO
    1:       //     This is even if there should be a print presentation
    1:       if (po) {
    1: 
    1:         nsCOMPtr<nsIDOMHTMLFrameElement> frame(do_QueryInterface(aContent));
11294:         // "frame" elements not in a frameset context should be treated
11294:         // as iframes
11294:         if (frame && po->mParent->mFrameType == eFrameSet) {
    1:           po->mFrameType = eFrame;
    1:         } else {
    1:           // Assume something iframe-like, i.e. iframe, object, or embed
    1:           po->mFrameType = eIFrame;
    1:           SetPrintAsIs(po, PR_TRUE);
    1:           NS_ASSERTION(po->mParent, "The root must be a parent");
    1:           po->mParent->mPrintAsIs = PR_TRUE;
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // walk children content
    1:   PRUint32 count = aContent->GetChildCount();
    1:   for (PRUint32 i = 0; i < count; ++i) {
    1:     nsIContent *child = aContent->GetChildAt(i);
    1:     MapContentForPO(aPO, child);
    1:   }
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: PRBool
    1: nsPrintEngine::IsThereAnIFrameSelected(nsIDocShell* aDocShell,
    1:                                        nsIDOMWindow* aDOMWin,
    1:                                        PRPackedBool& aIsParentFrameSet)
    1: {
    1:   aIsParentFrameSet = IsParentAFrameSet(aDocShell);
    1:   PRBool iFrameIsSelected = PR_FALSE;
    1:   if (mPrt && mPrt->mPrintObject) {
    1:     nsPrintObject* po = FindPrintObjectByDOMWin(mPrt->mPrintObject, aDOMWin);
    1:     iFrameIsSelected = po && po->mFrameType == eIFrame;
    1:   } else {
    1:     // First, check to see if we are a frameset
    1:     if (!aIsParentFrameSet) {
    1:       // Check to see if there is a currenlt focused frame
    1:       // if so, it means the selected frame is either the main docshell
    1:       // or an IFRAME
    1:       if (aDOMWin) {
    1:         // Get the main docshell's DOMWin to see if it matches 
    1:         // the frame that is selected
    1:         nsCOMPtr<nsIDOMWindow> domWin = do_GetInterface(aDocShell);
    1:         if (domWin != aDOMWin) {
    1:           iFrameIsSelected = PR_TRUE; // we have a selected IFRAME
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   return iFrameIsSelected;
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: // Recursively sets all the PO items to be printed
    1: // from the given item down into the tree
    1: void
    1: nsPrintEngine::SetPrintPO(nsPrintObject* aPO, PRBool aPrint)
    1: {
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1: 
    1:   // Set whether to print flag
    1:   aPO->mDontPrint = !aPrint;
    1: 
24551:   for (PRUint32 i=0;i<aPO->mKids.Length();i++) {
24551:     SetPrintPO(aPO->mKids[i], aPrint);
    1:   } 
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: // This will first use a Title and/or URL from the PrintSettings
    1: // if one isn't set then it uses the one from the document
    1: // then if not title is there we will make sure we send something back
    1: // depending on the situation.
    1: void
    1: nsPrintEngine::GetDisplayTitleAndURL(nsPrintObject*    aPO,
    1:                                      PRUnichar**       aTitle, 
    1:                                      PRUnichar**       aURLStr,
    1:                                      eDocTitleDefault  aDefType)
    1: {
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1:   NS_ASSERTION(aTitle, "Pointer is null!");
    1:   NS_ASSERTION(aURLStr, "Pointer is null!");
    1: 
    1:   *aTitle  = nsnull;
    1:   *aURLStr = nsnull;
    1: 
    1:   if (!mPrt)
    1:     return;
    1: 
    1:   // First check to see if the PrintSettings has defined an alternate title
    1:   // and use that if it did
    1:   PRUnichar * docTitleStrPS = nsnull;
    1:   PRUnichar * docURLStrPS   = nsnull;
    1:   if (mPrt->mPrintSettings) {
    1:     mPrt->mPrintSettings->GetTitle(&docTitleStrPS);
    1:     mPrt->mPrintSettings->GetDocURL(&docURLStrPS);
    1: 
    1:     if (docTitleStrPS && *docTitleStrPS) {
    1:       *aTitle  = docTitleStrPS;
    1:     }
    1: 
    1:     if (docURLStrPS && *docURLStrPS) {
    1:       *aURLStr  = docURLStrPS;
    1:     }
    1: 
    1:     // short circut
    1:     if (docTitleStrPS && docURLStrPS) {
    1:       return;
    1:     }
    1:   }
    1: 
    1:   PRUnichar* docTitle;
    1:   PRUnichar* docUrl;
    1:   GetDocumentTitleAndURL(aPO->mDocument, &docTitle, &docUrl);
    1: 
    1:   if (docUrl) {
    1:     if (!docURLStrPS)
    1:       *aURLStr = docUrl;
    1:     else
    1:       nsMemory::Free(docUrl);
    1:   }
    1: 
    1:   if (docTitle) {
    1:     if (!docTitleStrPS)
    1:       *aTitle = docTitle;
    1:     else
    1:       nsMemory::Free(docTitle);
    1:   } else if (!docTitleStrPS) {
    1:     switch (aDefType) {
    1:       case eDocTitleDefBlank: *aTitle = ToNewUnicode(EmptyString());
    1:         break;
    1: 
    1:       case eDocTitleDefURLDoc:
    1:         if (*aURLStr) {
    1:           *aTitle = NS_strdup(*aURLStr);
    1:         } else if (mPrt->mBrandName) {
    1:           *aTitle = NS_strdup(mPrt->mBrandName);
    1:         }
    1:         break;
19300:       case eDocTitleDefNone:
19300:         // *aTitle defaults to nsnull
19300:         break;
    1:     }
    1:   }
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: nsresult nsPrintEngine::DocumentReadyForPrinting()
    1: {
    1:   if (mPrt->mPrintFrameType == nsIPrintSettings::kEachFrameSep) {
    1:     CheckForChildFrameSets(mPrt->mPrintObject);
    1:   }
    1: 
    1:   //
    1:   // Send the document to the printer...
    1:   //
    1:   nsresult rv = SetupToPrintContent();
    1:   if (NS_FAILED(rv)) {
    1:     // The print job was canceled or there was a problem
    1:     // So remove all other documents from the print list
    1:     DonePrintingPages(nsnull, rv);
    1:   }
    1:   return rv;
    1: }
    1: 
    1: /** ---------------------------------------------------
    1:  *  Cleans up when an error occurred
    1:  */
    1: nsresult nsPrintEngine::CleanupOnFailure(nsresult aResult, PRBool aIsPrinting)
    1: {
    1:   PR_PL(("****  Failed %s - rv 0x%X", aIsPrinting?"Printing":"Print Preview", aResult));
    1: 
    1:   /* cleanup... */
    1:   if (mPagePrintTimer) {
    1:     mPagePrintTimer->Stop();
    1:     NS_RELEASE(mPagePrintTimer);
    1:   }
    1:   
    1:   if (aIsPrinting) {
    1:     SetIsPrinting(PR_FALSE);
    1:   } else {
    1:     SetIsPrintPreview(PR_FALSE);
    1:     SetIsCreatingPrintPreview(PR_FALSE);
    1:   }
    1: 
    1:   /* cleanup done, let's fire-up an error dialog to notify the user
    1:    * what went wrong... 
    1:    * 
    1:    * When rv == NS_ERROR_ABORT, it means we want out of the 
    1:    * print job without displaying any error messages
    1:    */
    1:   if (aResult != NS_ERROR_ABORT) {
    1:     ShowPrintErrorDialog(aResult, aIsPrinting);
    1:   }
    1: 
    1:   FirePrintCompletionEvent();
    1: 
    1:   return aResult;
    1: 
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: void
    1: nsPrintEngine::ShowPrintErrorDialog(nsresult aPrintError, PRBool aIsPrinting)
    1: {
    1: 
    1:   PR_PL(("nsPrintEngine::ShowPrintErrorDialog(nsresult aPrintError=%lx, PRBool aIsPrinting=%d)\n", (long)aPrintError, (int)aIsPrinting));
    1: 
    1:   nsCAutoString stringName;
    1: 
    1:   switch(aPrintError)
    1:   {
    1: #define NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(nserr) case nserr: stringName.AssignLiteral(#nserr); break;
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_CMD_NOT_FOUND)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_CMD_FAILURE)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_NO_PRINTER_AVAILABLE)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_NAME_NOT_FOUND)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_ACCESS_DENIED)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_INVALID_ATTRIBUTE)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PRINTER_NOT_READY)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_OUT_OF_PAPER)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PRINTER_IO_ERROR)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_COULD_NOT_OPEN_FILE)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_FILE_IO_ERROR)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PRINTPREVIEW)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_UNEXPECTED)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_OUT_OF_MEMORY)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_NOT_IMPLEMENTED)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_NOT_AVAILABLE)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_ABORT)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_STARTDOC)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_ENDDOC)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_STARTPAGE)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_ENDPAGE)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PRINT_WHILE_PREVIEW)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PAPER_SIZE_NOT_SUPPORTED)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_ORIENTATION_NOT_SUPPORTED)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_COLORSPACE_NOT_SUPPORTED)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_TOO_MANY_COPIES)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_DRIVER_CONFIGURATION_ERROR)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_DOC_IS_BUSY_PP)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_DOC_WAS_DESTORYED)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_NO_PRINTDIALOG_IN_TOOLKIT)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_NO_PRINTROMPTSERVICE)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_NO_XUL)   // Temporary code for Bug 136185 / bug 240490
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_PLEX_NOT_SUPPORTED)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_DOC_IS_BUSY)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTING_NOT_IMPLEMENTED)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_COULD_NOT_LOAD_PRINT_MODULE)
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_GFX_PRINTER_RESOLUTION_NOT_SUPPORTED)
    1: 
    1:     default:
    1:       NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG(NS_ERROR_FAILURE)
    1: #undef NS_ERROR_TO_LOCALIZED_PRINT_ERROR_MSG
    1:   }
    1: 
    1:   PR_PL(("ShowPrintErrorDialog:  stringName='%s'\n", stringName.get()));
    1: 
    1:   nsXPIDLString msg, title;
    1:   nsresult rv =
    1:     nsContentUtils::GetLocalizedString(nsContentUtils::ePRINTING_PROPERTIES,
    1:                                        stringName.get(), msg);
    1:   if (NS_FAILED(rv)) {
    1:     PR_PL(("GetLocalizedString failed\n"));
    1:     return;
    1:   }
    1: 
    1:   rv = nsContentUtils::GetLocalizedString(nsContentUtils::ePRINTING_PROPERTIES,
    1:       aIsPrinting ? "print_error_dialog_title"
    1:                   : "printpreview_error_dialog_title",
    1:       title);
    1: 
    1:   nsCOMPtr<nsIWindowWatcher> wwatch = do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
    1:   if (NS_FAILED(rv)) {
    1:     PR_PL(("ShowPrintErrorDialog(): wwatch==nsnull\n"));
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMWindow> active;
    1:   wwatch->GetActiveWindow(getter_AddRefs(active));
    1: 
    1:   nsCOMPtr<nsIPrompt> dialog;
    1:   /* |GetNewPrompter| allows that |active| is |nsnull| 
    1:    * (see bug 234982 ("nsPrintEngine::ShowPrintErrorDialog() fails in many cases")) */
    1:   wwatch->GetNewPrompter(active, getter_AddRefs(dialog));
    1:   if (!dialog) {
    1:     PR_PL(("ShowPrintErrorDialog(): dialog==nsnull\n"));
    1:     return;
    1:   }
    1: 
    1:   dialog->Alert(title.get(), msg.get());
    1:   PR_PL(("ShowPrintErrorDialog(): alert displayed successfully.\n"));
    1: }
    1: 
    1: //-----------------------------------------------------------------
    1: //-- Section: Reflow Methods
    1: //-----------------------------------------------------------------
    1: 
    1: //-------------------------------------------------------
    1: nsresult
    1: nsPrintEngine::SetupToPrintContent()
    1: {
    1:   // In this step we figure out which documents should be printed
    1:   // i.e. if we are printing the selection then only enable that nsPrintObject
    1:   // for printing
    1:   if (NS_FAILED(EnablePOsForPrinting())) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   DUMP_DOC_LIST("\nAfter Enable------------------------------------------");
    1: 
    1:   // This is an Optimization
    1:   // If we are in PP then we already know all the shrinkage information
    1:   // so just transfer it to the PrintData and we will skip the extra shrinkage reflow
    1:   //
    1:   // doSetPixelScale tells Reflow whether to set the shrinkage value into the DC
    1:   // The first time we do not want to do this, the second time through we do
    1:   PRBool doSetPixelScale = PR_FALSE;
    1:   PRBool ppIsShrinkToFit = mPrtPreview && mPrtPreview->mShrinkToFit;
    1:   if (ppIsShrinkToFit) {
    1:     mPrt->mShrinkRatio = mPrtPreview->mShrinkRatio;
    1:     doSetPixelScale = PR_TRUE;
    1:   }
    1: 
    1:   // Here we reflow all the PrintObjects
    1:   nsresult rv = ReflowDocList(mPrt->mPrintObject, doSetPixelScale);
    1:   if (NS_FAILED(rv)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Here is where we do the extra reflow for shrinking the content
    1:   // But skip this step if we are in PrintPreview
    1:   if (mPrt->mShrinkToFit && !ppIsShrinkToFit) {
    1:     // Now look for the PO that has the smallest percent for shrink to fit
24551:     if (mPrt->mPrintDocList.Length() > 1 && mPrt->mPrintObject->mFrameType == eFrameSet) {
    1:       nsPrintObject* smallestPO = FindSmallestSTF();
    1:       NS_ASSERTION(smallestPO, "There must always be an XMost PO!");
    1:       if (smallestPO) {
    1:         // Calc the shrinkage based on the entire content area
    1:         mPrt->mShrinkRatio = smallestPO->mShrinkRatio;
    1:       }
    1:     } else {
    1:       // Single document so use the Shrink as calculated for the PO
    1:       mPrt->mShrinkRatio = mPrt->mPrintObject->mShrinkRatio;
    1:     }
    1: 
    1:     // Only Shrink if we are smaller
    1:     if (mPrt->mShrinkRatio < 0.998f) {
    1:       // Clamp Shrink to Fit to 60%
32531:       mPrt->mShrinkRatio = NS_MAX(mPrt->mShrinkRatio, 0.60f);
    1: 
24551:       for (PRUint32 i=0;i<mPrt->mPrintDocList.Length();i++) {
24551:         nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
    1:         NS_ASSERTION(po, "nsPrintObject can't be null!");
    1:         // Wipe out the presentation before we reflow
    1:         po->DestroyPresentation();
    1:       }
    1: 
    1: #if (defined(XP_WIN) || defined(XP_OS2)) && defined(EXTENDED_DEBUG_PRINTING)
    1:       // We need to clear all the output files here
    1:       // because they will be re-created with second reflow of the docs
    1:       if (kPrintingLogMod && kPrintingLogMod->level == DUMP_LAYOUT_LEVEL) {
    1:         RemoveFilesInDir(".\\");
    1:         gDumpFileNameCnt   = 0;
    1:         gDumpLOFileNameCnt = 0;
    1:       }
    1: #endif
    1: 
    1:       // Here we reflow all the PrintObjects a second time
    1:       // this time using the shrinkage values
    1:       // The last param here tells reflow to NOT calc the shrinkage values
    1:       if (NS_FAILED(ReflowDocList(mPrt->mPrintObject, PR_TRUE))) {
    1:         return NS_ERROR_FAILURE;
    1:       }
    1:     }
    1: 
    1: #ifdef PR_LOGGING
    1:     {
    1:       float calcRatio = 0.0f;
24551:       if (mPrt->mPrintDocList.Length() > 1 && mPrt->mPrintObject->mFrameType == eFrameSet) {
    1:         nsPrintObject* smallestPO = FindSmallestSTF();
    1:         NS_ASSERTION(smallestPO, "There must always be an XMost PO!");
    1:         if (smallestPO) {
    1:           // Calc the shrinkage based on the entire content area
    1:           calcRatio = smallestPO->mShrinkRatio;
    1:         }
    1:       } else {
    1:         // Single document so use the Shrink as calculated for the PO
    1:         calcRatio = mPrt->mPrintObject->mShrinkRatio;
    1:       }
    1:       PR_PL(("**************************************************************************\n"));
    1:       PR_PL(("STF Ratio is: %8.5f Effective Ratio: %8.5f Diff: %8.5f\n", mPrt->mShrinkRatio, calcRatio,  mPrt->mShrinkRatio-calcRatio));
    1:       PR_PL(("**************************************************************************\n"));
    1:     }
    1: #endif
    1:   }
    1: 
    1:   DUMP_DOC_LIST(("\nAfter Reflow------------------------------------------"));
    1:   PR_PL(("\n"));
    1:   PR_PL(("-------------------------------------------------------\n"));
    1:   PR_PL(("\n"));
    1: 
    1:   CalcNumPrintablePages(mPrt->mNumPrintablePages);
    1: 
    1:   PR_PL(("--- Printing %d pages\n", mPrt->mNumPrintablePages));
    1:   DUMP_DOC_TREELAYOUT;
    1: 
    1:   // Print listener setup...
    1:   if (mPrt != nsnull) {
    1:     mPrt->OnStartPrinting();    
    1:   }
    1: 
    1:   PRUnichar* fileName = nsnull;
    1:   // check to see if we are printing to a file
    1:   PRBool isPrintToFile = PR_FALSE;
    1:   mPrt->mPrintSettings->GetPrintToFile(&isPrintToFile);
    1:   if (isPrintToFile) {
    1:   // On some platforms The BeginDocument needs to know the name of the file
    1:   // and it uses the PrintService to get it, so we need to set it into the PrintService here
    1:     mPrt->mPrintSettings->GetToFileName(&fileName);
    1:   }
    1: 
    1:   PRUnichar * docTitleStr;
    1:   PRUnichar * docURLStr;
    1:   GetDisplayTitleAndURL(mPrt->mPrintObject, &docTitleStr, &docURLStr, eDocTitleDefURLDoc); 
    1: 
    1:   PRInt32 startPage = 1;
    1:   PRInt32 endPage   = mPrt->mNumPrintablePages;
    1: 
    1:   PRInt16 printRangeType = nsIPrintSettings::kRangeAllPages;
    1:   mPrt->mPrintSettings->GetPrintRange(&printRangeType);
    1:   if (printRangeType == nsIPrintSettings::kRangeSpecifiedPageRange) {
    1:     mPrt->mPrintSettings->GetStartPageRange(&startPage);
    1:     mPrt->mPrintSettings->GetEndPageRange(&endPage);
    1:     if (endPage > mPrt->mNumPrintablePages) {
    1:       endPage = mPrt->mNumPrintablePages;
    1:     }
    1:   }
    1: 
    1:   rv = NS_OK;
    1:   // BeginDocument may pass back a FAILURE code
    1:   // i.e. On Windows, if you are printing to a file and hit "Cancel" 
    1:   //      to the "File Name" dialog, this comes back as an error
    1:   // Don't start printing when regression test are executed  
    1:   if (!mPrt->mDebugFilePtr && mIsDoingPrinting) {
    1:     rv = mPrt->mPrintDC->BeginDocument(docTitleStr, fileName, startPage, endPage);
    1:   } 
    1: 
13332:   if (mIsCreatingPrintPreview) {
10888:     // Print Preview -- Pass ownership of docTitleStr and docURLStr
10888:     // to the pageSequenceFrame, to be displayed in the header
39668:     nsIPageSequenceFrame *seqFrame = mPrt->mPrintObject->mPresShell->GetPageSequenceFrame();
10888:     if (seqFrame) {
10888:       seqFrame->StartPrint(mPrt->mPrintObject->mPresContext, 
10888:                            mPrt->mPrintSettings, docTitleStr, docURLStr);
56948:       docTitleStr = nsnull;
56948:       docURLStr = nsnull;
56948:     }
56948:   }
    1:   if (docTitleStr) nsMemory::Free(docTitleStr);
    1:   if (docURLStr) nsMemory::Free(docURLStr);
10888: 
10888:   PR_PL(("****************** Begin Document ************************\n"));
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // This will print the docshell document
    1:   // when it completes asynchronously in the DonePrintingPages method
    1:   // it will check to see if there are more docshells to be printed and
    1:   // then PrintDocContent will be called again.
    1: 
    1:   if (mIsDoingPrinting) {
    1:     PrintDocContent(mPrt->mPrintObject, rv); // ignore return value
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: // Recursively reflow each sub-doc and then calc
    1: // all the frame locations of the sub-docs
    1: nsresult
    1: nsPrintEngine::ReflowDocList(nsPrintObject* aPO, PRBool aSetPixelScale)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aPO);
    1: 
    1:   // Check to see if the subdocument's element has been hidden by the parent document
    1:   if (aPO->mParent && aPO->mParent->mPresShell) {
36656:     nsIFrame * frame = aPO->mContent->GetPrimaryFrame();
    1:     if (frame) {
    1:       if (!frame->GetStyleVisibility()->IsVisible()) {
    1:         aPO->mDontPrint = PR_TRUE;
    1:         aPO->mInvisible = PR_TRUE;
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // Here is where we set the shrinkage value into the DC
    1:   // and this is what actually makes it shrink
    1:   if (aSetPixelScale && aPO->mFrameType != eIFrame) {
    1:     float ratio;
    1:     if (mPrt->mPrintFrameType == nsIPrintSettings::kFramesAsIs || mPrt->mPrintFrameType == nsIPrintSettings::kNoFrames) {
    1:       ratio = mPrt->mShrinkRatio - 0.005f; // round down
    1:     } else {
    1:       ratio = aPO->mShrinkRatio - 0.005f; // round down
    1:     }
    1:     aPO->mZoomRatio = ratio;
    1:   } else if (!mPrt->mShrinkToFit) {
    1:     double scaling;
    1:     mPrt->mPrintSettings->GetScaling(&scaling);
    1:     aPO->mZoomRatio = float(scaling);
    1:   }
    1: 
    1:   nsresult rv;
    1:   // Reflow the PO
    1:   rv = ReflowPrintObject(aPO);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
24551:   PRInt32 cnt = aPO->mKids.Length();
    1:   for (PRInt32 i=0;i<cnt;i++) {
24551:     rv = ReflowDocList(aPO->mKids[i], aSetPixelScale);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: // Reflow a nsPrintObject
    1: nsresult
    1: nsPrintEngine::ReflowPrintObject(nsPrintObject * aPO)
    1: {
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1:   if (!aPO) return NS_ERROR_FAILURE;
    1: 
    1:   nsSize adjSize;
    1:   PRBool documentIsTopLevel;
    1:   if (!aPO->IsPrintable())
    1:     return NS_OK;
    1: 
51637:   PRBool canCreateScrollbars = PR_TRUE;
51637:   nsIView* parentView = nsnull;
51637: 
    1:   if (aPO->mParent && aPO->mParent->IsPrintable()) {
51637:     nsIFrame* frame = aPO->mContent->GetPrimaryFrame();
    1:     // Without a frame, this document can't be displayed; therefore, there is no
    1:     // point to reflowing it
36236:     if (!frame) {
37469:       SetPrintPO(aPO, PR_FALSE);
    1:       return NS_OK;
36236:     }
    1: 
47902:     //XXX If printing supported printing document hierarchies with non-constant
47902:     // zoom this would be wrong as we use the same mPrt->mPrintDC for all
47902:     // subdocuments.
    1:     adjSize = frame->GetContentRect().Size();
    1:     documentIsTopLevel = PR_FALSE;
    1:     // presshell exists because parent is printable
51637: 
51637:     // the top nsPrintObject's widget will always have scrollbars
51637:     if (frame && frame->GetType() == nsGkAtoms::subDocumentFrame) {
51637:       nsIView* view = frame->GetView();
51637:       NS_ENSURE_TRUE(view, NS_ERROR_FAILURE);
51637:       view = view->GetFirstChild();
51637:       NS_ENSURE_TRUE(view, NS_ERROR_FAILURE);
51637:       parentView = view;
51637:       canCreateScrollbars = PR_FALSE;
51637:     }
    1:   } else {
 8247:     nscoord pageWidth, pageHeight;
    1:     mPrt->mPrintDC->GetDeviceSurfaceDimensions(pageWidth, pageHeight);
14016: #if defined(XP_UNIX) && !defined(XP_MACOSX)
14016:     // If we're in landscape mode on Linux, the device surface will have 
14016:     // been rotated, so for the purposes of reflowing content, we'll 
14016:     // treat device's height as our width and its width as our height, 
14016:     PRInt32 orientation;
14016:     mPrt->mPrintSettings->GetOrientation(&orientation);
14016:     if (nsIPrintSettings::kLandscapeOrientation == orientation) {
14016:       adjSize = nsSize(pageHeight, pageWidth);
14016:     } else {
    1:       adjSize = nsSize(pageWidth, pageHeight);
14016:     }
14016: #else
14016:     adjSize = nsSize(pageWidth, pageHeight);
14016: #endif // XP_UNIX && !XP_MACOSX
    1:     documentIsTopLevel = PR_TRUE;
51637: 
52043:     if (mIsCreatingPrintPreview) {
51637:       nsCOMPtr<nsIDocumentViewer> dv = do_QueryInterface(mDocViewerPrint);
51637:       if (dv) {
51637:         parentView = dv->FindContainerView();
51637:       }
    1:     }
52043:   }
    1: 
35581:   NS_ASSERTION(!aPO->mPresContext, "Recreating prescontext");
35581: 
23745:   // create the PresContext
51637:   aPO->mPresContext = new nsPresContext(aPO->mDocument,
30514:     mIsCreatingPrintPreview ? nsPresContext::eContext_PrintPreview:
23745:                               nsPresContext::eContext_Print);
23745:   NS_ENSURE_TRUE(aPO->mPresContext, NS_ERROR_OUT_OF_MEMORY);
23745:   aPO->mPresContext->SetPrintSettings(mPrt->mPrintSettings);
23745: 
23745:   // set the presentation context to the value in the print settings
23745:   PRBool printBGColors;
23745:   mPrt->mPrintSettings->GetPrintBGColors(&printBGColors);
23745:   aPO->mPresContext->SetBackgroundColorDraw(printBGColors);
23745:   mPrt->mPrintSettings->GetPrintBGImages(&printBGColors);
23745:   aPO->mPresContext->SetBackgroundImageDraw(printBGColors);
23745: 
23745:   // init it with the DC
23745:   nsresult rv = aPO->mPresContext->Init(mPrt->mPrintDC);
23745:   NS_ENSURE_SUCCESS(rv, rv);
23745: 
23745:   aPO->mViewManager = do_CreateInstance(kViewManagerCID, &rv);
23745:   NS_ENSURE_SUCCESS(rv,rv);
23745: 
23745:   rv = aPO->mViewManager->Init(mPrt->mPrintDC);
23745:   NS_ENSURE_SUCCESS(rv,rv);
23745: 
23745:   nsStyleSet* styleSet;
23745:   rv = mDocViewerPrint->CreateStyleSet(aPO->mDocument, &styleSet);
23745:   NS_ENSURE_SUCCESS(rv, rv);
23745: 
23745:   rv = aPO->mDocument->CreateShell(aPO->mPresContext, aPO->mViewManager,
23745:                                    styleSet, getter_AddRefs(aPO->mPresShell));
23745:   if (NS_FAILED(rv)) {
23745:     delete styleSet;
23745:     return rv;
23745:   }
23745: 
23745:   styleSet->EndUpdate();
23745:   
23745:   // The pres shell now owns the style set object.
23745: 
23745:   PR_PL(("In DV::ReflowPrintObject PO: %p (%9s) Setting w,h to %d,%d\n", aPO,
23745:          gFrameTypesStr[aPO->mFrameType], adjSize.width, adjSize.height));
23745: 
    1:   // Create a child window of the parent that is our "root view/window"
    1:   nsRect tbounds = nsRect(nsPoint(0, 0), adjSize);
    1:   nsIView* rootView = aPO->mViewManager->CreateView(tbounds, parentView);
    1:   NS_ENSURE_TRUE(rootView, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   if (mIsCreatingPrintPreview && documentIsTopLevel) {
    1:     aPO->mPresContext->SetPaginatedScrolling(canCreateScrollbars);
    1:   }
    1: 
    1:   // Setup hierarchical relationship in view manager
    1:   aPO->mViewManager->SetRootView(rootView);
    1: 
    1:   // This docshell stuff is weird; will go away when we stop having multiple
    1:   // presentations per document
    1:   nsCOMPtr<nsISupports> supps(do_QueryInterface(aPO->mDocShell));
    1:   aPO->mPresContext->SetContainer(supps);
    1: 
    1:   aPO->mPresShell->BeginObservingDocument();
    1: 
    1:   aPO->mPresContext->SetPageSize(adjSize);
    1:   aPO->mPresContext->SetIsRootPaginatedDocument(documentIsTopLevel);
    1:   aPO->mPresContext->SetPageScale(aPO->mZoomRatio);
    1:   // Calculate scale factor from printer to screen
50791:   float printDPI = float(mPrt->mPrintDC->AppUnitsPerCSSInch()) /
 8247:                    float(mPrt->mPrintDC->AppUnitsPerDevPixel());
31784:   aPO->mPresContext->SetPrintPreviewScale(mScreenDPI / printDPI);
    1: 
35581:   if (mIsCreatingPrintPreview && documentIsTopLevel) {
51637:     mDocViewerPrint->SetPrintPreviewPresentation(aPO->mViewManager,
35581:                                                  aPO->mPresContext,
35581:                                                  aPO->mPresShell);
35581:   }
35581: 
    1:   rv = aPO->mPresShell->InitialReflow(adjSize.width, adjSize.height);
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
 1416:   NS_ASSERTION(aPO->mPresShell, "Presshell should still be here");
    1: 
  967:   // Process the reflow event InitialReflow posted
 4886:   aPO->mPresShell->FlushPendingNotifications(Flush_Layout);
  967: 
    1:   nsCOMPtr<nsIPresShell> displayShell;
    1:   aPO->mDocShell->GetPresShell(getter_AddRefs(displayShell));
    1:   // Transfer Selection Ranges to the new Print PresShell
    1:   nsCOMPtr<nsISelection> selection, selectionPS;
    1:   // It's okay if there is no display shell, just skip copying the selection
    1:   if (displayShell) {
    1:     selection = displayShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
    1:   }
    1:   selectionPS = aPO->mPresShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
    1:   if (selection && selectionPS) {
    1:     PRInt32 cnt;
    1:     selection->GetRangeCount(&cnt);
    1:     PRInt32 inx;
    1:     for (inx=0;inx<cnt;inx++) {
    1:       nsCOMPtr<nsIDOMRange> range;
    1:       if (NS_SUCCEEDED(selection->GetRangeAt(inx, getter_AddRefs(range))))
    1:         selectionPS->AddRange(range);
    1:     }
    1:   }
    1: 
    1:   // If we are trying to shrink the contents to fit on the page
    1:   // we must first locate the "pageContent" frame
    1:   // Then we walk the frame tree and look for the "xmost" frame
    1:   // this is the frame where the right-hand side of the frame extends
    1:   // the furthest
    1:   if (mPrt->mShrinkToFit && documentIsTopLevel) {
39668:     nsIPageSequenceFrame* pageSequence = aPO->mPresShell->GetPageSequenceFrame();
40974:     NS_ENSURE_STATE(pageSequence);
    1:     pageSequence->GetSTFPercent(aPO->mShrinkRatio);
    1:   }
    1: 
    1: #ifdef EXTENDED_DEBUG_PRINTING
    1:     if (kPrintingLogMod && kPrintingLogMod->level == DUMP_LAYOUT_LEVEL) {
    1:       char * docStr;
    1:       char * urlStr;
    1:       GetDocTitleAndURL(aPO, docStr, urlStr);
    1:       char filename[256];
    1:       sprintf(filename, "print_dump_%d.txt", gDumpFileNameCnt++);
    1:       // Dump all the frames and view to a a file
    1:       FILE * fd = fopen(filename, "w");
    1:       if (fd) {
    1:         nsIFrame *theRootFrame =
    1:           aPO->mPresShell->FrameManager()->GetRootFrame();
    1:         fprintf(fd, "Title: %s\n", docStr?docStr:"");
    1:         fprintf(fd, "URL:   %s\n", urlStr?urlStr:"");
    1:         fprintf(fd, "--------------- Frames ----------------\n");
    1:         nsCOMPtr<nsIRenderingContext> renderingContext;
    1:         mPrt->mPrintDocDC->CreateRenderingContext(*getter_AddRefs(renderingContext));
    1:         RootFrameList(aPO->mPresContext, fd, 0);
    1:         //DumpFrames(fd, aPO->mPresContext, renderingContext, theRootFrame, 0);
    1:         fprintf(fd, "---------------------------------------\n\n");
    1:         fprintf(fd, "--------------- Views From Root Frame----------------\n");
    1:         nsIView* v = theRootFrame->GetView();
    1:         if (v) {
    1:           v->List(fd);
    1:         } else {
    1:           printf("View is null!\n");
    1:         }
    1:         if (docShell) {
    1:           fprintf(fd, "--------------- All Views ----------------\n");
    1:           DumpViews(docShell, fd);
    1:           fprintf(fd, "---------------------------------------\n\n");
    1:         }
    1:         fclose(fd);
    1:       }
    1:       if (docStr) nsMemory::Free(docStr);
    1:       if (urlStr) nsMemory::Free(urlStr);
    1:     }
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: // Figure out how many documents and how many total pages we are printing
    1: void
    1: nsPrintEngine::CalcNumPrintablePages(PRInt32& aNumPages)
    1: {
    1:   aNumPages = 0;
    1:   // Count the number of printable documents
    1:   // and printable pages
24551:   for (PRUint32 i=0; i<mPrt->mPrintDocList.Length(); i++) {
24551:     nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
    1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
    1:     if (po->mPresContext && po->mPresContext->IsRootPaginatedDocument()) {
39668:       nsIPageSequenceFrame* pageSequence = po->mPresShell->GetPageSequenceFrame();
23554:       nsIFrame * seqFrame = do_QueryFrame(pageSequence);
23554:       if (seqFrame) {
    1:         nsIFrame* frame = seqFrame->GetFirstChild(nsnull);
    1:         while (frame) {
    1:           aNumPages++;
    1:           frame = frame->GetNextSibling();
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: //-----------------------------------------------------------------
    1: //-- Done: Reflow Methods
    1: //-----------------------------------------------------------------
    1: 
    1: //-----------------------------------------------------------------
    1: //-- Section: Printing Methods
    1: //-----------------------------------------------------------------
    1: 
    1: //-------------------------------------------------------
    1: // Called for each DocShell that needs to be printed
    1: PRBool
    1: nsPrintEngine::PrintDocContent(nsPrintObject* aPO, nsresult& aStatus)
    1: {
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1:   aStatus = NS_OK;
    1: 
    1:   if (!aPO->mHasBeenPrinted && aPO->IsPrintable()) {
    1:     aStatus = DoPrint(aPO);
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   // If |aPO->mPrintAsIs| and |aPO->mHasBeenPrinted| are true,
    1:   // the kids frames are already processed in |PrintPage|.
    1:   if (!aPO->mInvisible && !(aPO->mPrintAsIs && aPO->mHasBeenPrinted)) {
24551:     for (PRUint32 i=0;i<aPO->mKids.Length();i++) {
24551:       nsPrintObject* po = aPO->mKids[i];
    1:       PRBool printed = PrintDocContent(po, aStatus);
    1:       if (printed || NS_FAILED(aStatus)) {
    1:         return PR_TRUE;
    1:       }
    1:     }
    1:   }
    1:   return PR_FALSE;
    1: }
    1: 
35581: static already_AddRefed<nsIDOMNode>
35581: GetEqualNodeInCloneTree(nsIDOMNode* aNode, nsIDocument* aDoc)
35581: {
35581:   nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
35581:   // Selections in anonymous subtrees aren't supported.
35581:   if (content && content->IsInAnonymousSubtree()) {
35581:     return nsnull;
35581:   }
35581: 
35581:   nsCOMPtr<nsINode> node = do_QueryInterface(aNode);
35581:   NS_ENSURE_TRUE(node, nsnull);
35581: 
35581:   nsTArray<PRInt32> indexArray;
35581:   nsINode* current = node;
35581:   NS_ENSURE_TRUE(current, nsnull);
35581:   while (current) {
35581:     nsINode* parent = current->GetNodeParent();
35581:     if (!parent) {
35581:      break;
35581:     }
35581:     PRInt32 index = parent->IndexOf(current);
35581:     NS_ENSURE_TRUE(index >= 0, nsnull);
35581:     indexArray.AppendElement(index);
35581:     current = parent;
35581:   }
35581:   NS_ENSURE_TRUE(current->IsNodeOfType(nsINode::eDOCUMENT), nsnull);
35581: 
35581:   current = aDoc;
35581:   for (PRInt32 i = indexArray.Length() - 1; i >= 0; --i) {
35581:     current = current->GetChildAt(indexArray[i]);
35581:     NS_ENSURE_TRUE(current, nsnull);
35581:   }
35581:   nsCOMPtr<nsIDOMNode> result = do_QueryInterface(current);
35581:   return result.forget();
35581: }
35581: 
35581: static nsresult CloneRangeToSelection(nsIDOMRange* aRange,
35581:                                       nsIDocument* aDoc,
35581:                                       nsISelection* aSelection)
35581: {
35581:   PRBool collapsed = PR_FALSE;
35581:   aRange->GetCollapsed(&collapsed);
35581:   if (collapsed) {
35581:     return NS_OK;
35581:   }
35581: 
35581:   nsCOMPtr<nsIDOMNode> startContainer, endContainer;
35581:   PRInt32 startOffset = -1, endOffset = -1;
35581:   aRange->GetStartContainer(getter_AddRefs(startContainer));
35581:   aRange->GetStartOffset(&startOffset);
35581:   aRange->GetEndContainer(getter_AddRefs(endContainer));
35581:   aRange->GetEndOffset(&endOffset);
35581:   NS_ENSURE_STATE(startContainer && endContainer);
35581: 
35581:   nsCOMPtr<nsIDOMNode> newStart = GetEqualNodeInCloneTree(startContainer, aDoc);
35581:   nsCOMPtr<nsIDOMNode> newEnd = GetEqualNodeInCloneTree(endContainer, aDoc);
35581:   NS_ENSURE_STATE(newStart && newEnd);
35581: 
35581:   nsCOMPtr<nsIDOMRange> range;
35581:   NS_NewRange(getter_AddRefs(range));
35581:   NS_ENSURE_TRUE(range, NS_ERROR_OUT_OF_MEMORY);
35581: 
35581:   nsresult rv = range->SetStart(newStart, startOffset);
35581:   NS_ENSURE_SUCCESS(rv, rv);
35581:   rv = range->SetEnd(newEnd, endOffset);
35581:   NS_ENSURE_SUCCESS(rv, rv);
35581: 
35581:   return aSelection->AddRange(range);
35581: }
35581: 
35581: static nsresult CloneSelection(nsIDocument* aOrigDoc, nsIDocument* aDoc)
35581: {
46225:   nsIPresShell* origShell = aOrigDoc->GetShell();
46225:   nsIPresShell* shell = aDoc->GetShell();
35581:   NS_ENSURE_STATE(origShell && shell);
35581: 
35581:   nsCOMPtr<nsISelection> origSelection =
35581:     origShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
35581:   nsCOMPtr<nsISelection> selection =
35581:     shell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
35581:   NS_ENSURE_STATE(origSelection && selection);
35581: 
35581:   PRInt32 rangeCount = 0;
35581:   origSelection->GetRangeCount(&rangeCount);
35581:   for (PRInt32 i = 0; i < rangeCount; ++i) {
35581:     nsCOMPtr<nsIDOMRange> range;
35581:     origSelection->GetRangeAt(i, getter_AddRefs(range));
35581:     if (range) {
35581:       CloneRangeToSelection(range, aDoc, selection);
35581:     }
35581:   }
35581:   return NS_OK;
35581: }
35581: 
    1: //-------------------------------------------------------
    1: nsresult
    1: nsPrintEngine::DoPrint(nsPrintObject * aPO)
    1: {
    1:   PR_PL(("\n"));
    1:   PR_PL(("**************************** %s ****************************\n", gFrameTypesStr[aPO->mFrameType]));
    1:   PR_PL(("****** In DV::DoPrint   PO: %p \n", aPO));
    1: 
    1:   nsIPresShell*   poPresShell   = aPO->mPresShell;
    1:   nsPresContext*  poPresContext = aPO->mPresContext;
    1: 
    1:   NS_ASSERTION(poPresContext, "PrintObject has not been reflowed");
    1:   NS_ASSERTION(poPresContext->Type() != nsPresContext::eContext_PrintPreview,
    1:                "How did this context end up here?");
    1: 
    1:   if (mPrt->mPrintProgressParams) {
    1:     SetDocAndURLIntoProgress(aPO, mPrt->mPrintProgressParams);
    1:   }
    1: 
    1:   {
    1:     PRInt16 printRangeType = nsIPrintSettings::kRangeAllPages;
    1:     nsresult rv;
    1:     if (mPrt->mPrintSettings != nsnull) {
    1:       mPrt->mPrintSettings->GetPrintRange(&printRangeType);
    1:     }
    1: 
    1:     // Ask the page sequence frame to print all the pages
39668:     nsIPageSequenceFrame* pageSequence = poPresShell->GetPageSequenceFrame();
    1:     NS_ASSERTION(nsnull != pageSequence, "no page sequence frame");
    1: 
    1:     // We are done preparing for printing, so we can turn this off
    1:     mPrt->mPreparingForPrint = PR_FALSE;
    1: 
    1:     // mPrt->mDebugFilePtr this is onlu non-null when compiled for debugging
    1:     if (nsnull != mPrt->mDebugFilePtr) {
    1: #ifdef NS_DEBUG
    1:       // output the regression test
    1:       nsIFrame* root = poPresShell->FrameManager()->GetRootFrame();
31709:       root->DumpRegressionData(poPresContext, mPrt->mDebugFilePtr, 0);
    1:       fclose(mPrt->mDebugFilePtr);
    1:       SetIsPrinting(PR_FALSE);
    1: #endif
    1:     } else {
    1: #ifdef EXTENDED_DEBUG_PRINTING
    1:       nsIFrame* rootFrame = poPresShell->FrameManager()->GetRootFrame();
    1:       if (aPO->IsPrintable()) {
    1:         char * docStr;
    1:         char * urlStr;
    1:         GetDocTitleAndURL(aPO, docStr, urlStr);
    1:         DumpLayoutData(docStr, urlStr, poPresContext, mPrt->mPrintDocDC, rootFrame, docShell, nsnull);
    1:         if (docStr) nsMemory::Free(docStr);
    1:         if (urlStr) nsMemory::Free(urlStr);
    1:       }
    1: #endif
    1: 
    1:       if (mPrt->mPrintSettings) {
    1:         PRUnichar * docTitleStr = nsnull;
    1:         PRUnichar * docURLStr   = nsnull;
    1: 
    1:         GetDisplayTitleAndURL(aPO, &docTitleStr, &docURLStr, eDocTitleDefBlank); 
    1: 
    1:         if (nsIPrintSettings::kRangeSelection == printRangeType) {
35581:           CloneSelection(aPO->mDocument->GetOriginalDocument(), aPO->mDocument);
35581: 
    1:           poPresContext->SetIsRenderingOnlySelection(PR_TRUE);
    1:           // temporarily creating rendering context
    1:           // which is needed to dinf the selection frames
    1:           nsCOMPtr<nsIRenderingContext> rc;
    1:           mPrt->mPrintDC->CreateRenderingContext(*getter_AddRefs(rc));
    1: 
    1:           // find the starting and ending page numbers
    1:           // via the selection
    1:           nsIFrame* startFrame;
    1:           nsIFrame* endFrame;
    1:           PRInt32   startPageNum;
    1:           PRInt32   endPageNum;
    1:           nsRect    startRect;
    1:           nsRect    endRect;
    1: 
    1:           nsCOMPtr<nsISelection> selectionPS;
    1:           selectionPS = poPresShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
    1: 
    1:           rv = GetPageRangeForSelection(poPresShell, poPresContext, *rc, selectionPS, pageSequence,
    1:                                         &startFrame, startPageNum, startRect,
    1:                                         &endFrame, endPageNum, endRect);
    1:           if (NS_SUCCEEDED(rv)) {
    1:             mPrt->mPrintSettings->SetStartPageRange(startPageNum);
    1:             mPrt->mPrintSettings->SetEndPageRange(endPageNum);
23738:             nsIntMargin marginTwips(0,0,0,0);
23738:             nsIntMargin unwrtMarginTwips(0,0,0,0);
 8247:             mPrt->mPrintSettings->GetMarginInTwips(marginTwips);
14567:             mPrt->mPrintSettings->GetUnwriteableMarginInTwips(unwrtMarginTwips);
50791:             nsMargin totalMargin = poPresContext->CSSTwipsToAppUnits(marginTwips + 
14567:                                                                      unwrtMarginTwips);
    1:             if (startPageNum == endPageNum) {
    1:               {
14567:                 startRect.y -= totalMargin.top;
14567:                 endRect.y   -= totalMargin.top;
14773: 
14773:                 // Clip out selection regions above the top of the first page
14773:                 if (startRect.y < 0) {
14773:                   // Reduce height to be the height of the positive-territory
14773:                   // region of original rect
32531:                   startRect.height = NS_MAX(0, startRect.YMost());
14773:                   startRect.y = 0;
14773:                 }
14773:                 if (endRect.y < 0) {
14773:                   // Reduce height to be the height of the positive-territory
14773:                   // region of original rect
32531:                   endRect.height = NS_MAX(0, endRect.YMost());
14773:                   endRect.y = 0;
14773:                 }
14773:                 NS_ASSERTION(endRect.y >= startRect.y,
14773:                              "Selection end point should be after start point");
14773:                 NS_ASSERTION(startRect.height >= 0,
14773:                              "rect should have non-negative height.");
14773:                 NS_ASSERTION(endRect.height >= 0,
14773:                              "rect should have non-negative height.");
14773: 
14532:                 nscoord selectionHgt = endRect.y + endRect.height - startRect.y;
    1:                 // XXX This is temporary fix for printing more than one page of a selection
14532:                 pageSequence->SetSelectionHeight(startRect.y * aPO->mZoomRatio,
14532:                                                  selectionHgt * aPO->mZoomRatio);
    1: 
    1:                 // calc total pages by getting calculating the selection's height
    1:                 // and then dividing it by how page content frames will fit.
 8247:                 nscoord pageWidth, pageHeight;
    1:                 mPrt->mPrintDC->GetDeviceSurfaceDimensions(pageWidth, pageHeight);
14567:                 pageHeight -= totalMargin.top + totalMargin.bottom;
14831:                 PRInt32 totalPages = NSToIntCeil(float(selectionHgt) * aPO->mZoomRatio / float(pageHeight));
    1:                 pageSequence->SetTotalNumPages(totalPages);
    1:               }
    1:             }
    1:           }
    1:         }
    1: 
23554:         nsIFrame * seqFrame = do_QueryFrame(pageSequence);
23554:         if (!seqFrame) {
    1:           SetIsPrinting(PR_FALSE);
    1:           return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         mPageSeqFrame = pageSequence;
    1:         mPageSeqFrame->StartPrint(poPresContext, mPrt->mPrintSettings, docTitleStr, docURLStr);
    1: 
    1:         // Schedule Page to Print
    1:         PR_PL(("Scheduling Print of PO: %p (%s) \n", aPO, gFrameTypesStr[aPO->mFrameType]));
    1:         StartPagePrintTimer(aPO);
    1:       } else {
    1:         // not sure what to do here!
    1:         SetIsPrinting(PR_FALSE);
    1:         return NS_ERROR_FAILURE;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: void
    1: nsPrintEngine::SetDocAndURLIntoProgress(nsPrintObject* aPO,
    1:                                         nsIPrintProgressParams* aParams)
    1: {
    1:   NS_ASSERTION(aPO, "Must have vaild nsPrintObject");
    1:   NS_ASSERTION(aParams, "Must have vaild nsIPrintProgressParams");
    1: 
    1:   if (!aPO || !aPO->mDocShell || !aParams) {
    1:     return;
    1:   }
    1:   const PRUint32 kTitleLength = 64;
    1: 
    1:   PRUnichar * docTitleStr;
    1:   PRUnichar * docURLStr;
    1:   GetDisplayTitleAndURL(aPO, &docTitleStr, &docURLStr, eDocTitleDefURLDoc);
    1: 
    1:   // Make sure the Titles & URLS don't get too long for the progress dialog
    1:   ElipseLongString(docTitleStr, kTitleLength, PR_FALSE);
    1:   ElipseLongString(docURLStr, kTitleLength, PR_TRUE);
    1: 
    1:   aParams->SetDocTitle(docTitleStr);
    1:   aParams->SetDocURL(docURLStr);
    1: 
    1:   if (docTitleStr != nsnull) nsMemory::Free(docTitleStr);
    1:   if (docURLStr != nsnull) nsMemory::Free(docURLStr);
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: void
    1: nsPrintEngine::ElipseLongString(PRUnichar *& aStr, const PRUint32 aLen, PRBool aDoFront)
    1: {
    1:   // Make sure the URLS don't get too long for the progress dialog
    1:   if (aStr && nsCRT::strlen(aStr) > aLen) {
    1:     if (aDoFront) {
    1:       PRUnichar * ptr = &aStr[nsCRT::strlen(aStr)-aLen+3];
    1:       nsAutoString newStr;
    1:       newStr.AppendLiteral("...");
    1:       newStr += ptr;
    1:       nsMemory::Free(aStr);
    1:       aStr = ToNewUnicode(newStr);
    1:     } else {
    1:       nsAutoString newStr(aStr);
    1:       newStr.SetLength(aLen-3);
    1:       newStr.AppendLiteral("...");
    1:       nsMemory::Free(aStr);
    1:       aStr = ToNewUnicode(newStr);
    1:     }
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------
    1: PRBool
    1: nsPrintEngine::PrintPage(nsPrintObject*    aPO,
    1:                          PRBool&           aInRange)
    1: {
    1:   NS_ASSERTION(aPO,            "aPO is null!");
    1:   NS_ASSERTION(mPageSeqFrame,  "mPageSeqFrame is null!");
    1:   NS_ASSERTION(mPrt,           "mPrt is null!");
    1: 
    1:   // Although these should NEVER be NULL
    1:   // This is added insurance, to make sure we don't crash in optimized builds
    1:   if (!mPrt || !aPO || !mPageSeqFrame) {
    1:     ShowPrintErrorDialog(NS_ERROR_FAILURE);
    1:     return PR_TRUE; // means we are done printing
    1:   }
    1: 
    1:   PR_PL(("-----------------------------------\n"));
    1:   PR_PL(("------ In DV::PrintPage PO: %p (%s)\n", aPO, gFrameTypesStr[aPO->mFrameType]));
    1: 
    1:   // Check setting to see if someone request it be cancelled
    1:   PRBool isCancelled = PR_FALSE;
    1:   mPrt->mPrintSettings->GetIsCancelled(&isCancelled);
    1:   if (isCancelled)
    1:     return PR_TRUE;
    1: 
    1:   PRInt32 pageNum, numPages, endPage;
    1:   mPageSeqFrame->GetCurrentPageNum(&pageNum);
    1:   mPageSeqFrame->GetNumPages(&numPages);
    1: 
    1:   PRBool donePrinting;
    1:   PRBool isDoingPrintRange;
    1:   mPageSeqFrame->IsDoingPrintRange(&isDoingPrintRange);
    1:   if (isDoingPrintRange) {
    1:     PRInt32 fromPage;
    1:     PRInt32 toPage;
    1:     mPageSeqFrame->GetPrintRange(&fromPage, &toPage);
    1: 
    1:     if (fromPage > numPages) {
    1:       return PR_TRUE;
    1:     }
    1:     if (toPage > numPages) {
    1:       toPage = numPages;
    1:     }
    1: 
    1:     PR_PL(("****** Printing Page %d printing from %d to page %d\n", pageNum, fromPage, toPage));
    1: 
    1:     donePrinting = pageNum >= toPage;
    1:     aInRange = pageNum >= fromPage && pageNum <= toPage;
    1:     endPage = (toPage - fromPage)+1;
    1:   } else {
    1:     PR_PL(("****** Printing Page %d of %d page(s)\n", pageNum, numPages));
    1: 
    1:     donePrinting = pageNum >= numPages;
    1:     endPage = numPages;
    1:     aInRange = PR_TRUE;
    1:   }
    1: 
    1:   // XXX This is wrong, but the actual behavior in the presence of a print
    1:   // range sucks.
    1:   if (mPrt->mPrintFrameType == nsIPrintSettings::kEachFrameSep)
    1:     endPage = mPrt->mNumPrintablePages;
    1:   
    1:   mPrt->DoOnProgressChange(++mPrt->mNumPagesPrinted, endPage, PR_FALSE, 0);
    1: 
    1:   // Print the Page
    1:   // if a print job was cancelled externally, an EndPage or BeginPage may
    1:   // fail and the failure is passed back here.
    1:   // Returning PR_TRUE means we are done printing.
    1:   //
    1:   // When rv == NS_ERROR_ABORT, it means we want out of the
    1:   // print job without displaying any error messages
    1:   nsresult rv = mPageSeqFrame->PrintNextPage();
    1:   if (NS_FAILED(rv)) {
    1:     if (rv != NS_ERROR_ABORT) {
    1:       ShowPrintErrorDialog(rv);
    1:       mPrt->mIsAborted = PR_TRUE;
    1:     }
    1:     return PR_TRUE;
    1:   }
    1: 
    1:   mPageSeqFrame->DoPageEnd();
    1: 
    1:   return donePrinting;
    1: }
    1: 
    1: /** ---------------------------------------------------
    1:  *  Find by checking frames type
    1:  */
    1: nsresult 
    1: nsPrintEngine::FindSelectionBoundsWithList(nsPresContext* aPresContext,
    1:                                            nsIRenderingContext& aRC,
    1:                                            nsIAtom*        aList,
    1:                                            nsIFrame *      aParentFrame,
    1:                                            nsRect&         aRect,
    1:                                            nsIFrame *&     aStartFrame,
    1:                                            nsRect&         aStartRect,
    1:                                            nsIFrame *&     aEndFrame,
    1:                                            nsRect&         aEndRect)
    1: {
    1:   NS_ASSERTION(aPresContext, "Pointer is null!");
    1:   NS_ASSERTION(aParentFrame, "Pointer is null!");
    1: 
    1:   nsIFrame* child = aParentFrame->GetFirstChild(aList);
    1:   aRect += aParentFrame->GetPosition();
    1:   while (child) {
    1:     // only leaf frames have this bit flipped
    1:     // then check the hard way
    1:     PRBool isSelected = (child->GetStateBits() & NS_FRAME_SELECTED_CONTENT)
    1:       == NS_FRAME_SELECTED_CONTENT;
    1:     if (isSelected) {
    1:       isSelected = child->IsVisibleForPainting();
    1:     }
    1: 
    1:     if (isSelected) {
    1:       nsRect r = child->GetRect();
    1:       if (aStartFrame == nsnull) {
    1:         aStartFrame = child;
    1:         aStartRect.SetRect(aRect.x + r.x, aRect.y + r.y, r.width, r.height);
    1:       } else {
    1:         aEndFrame = child;
    1:         aEndRect.SetRect(aRect.x + r.x, aRect.y + r.y, r.width, r.height);
    1:       }
    1:     }
    1:     FindSelectionBounds(aPresContext, aRC, child, aRect, aStartFrame, aStartRect, aEndFrame, aEndRect);
    1:     child = child->GetNextSibling();
    1:   }
    1:   aRect -= aParentFrame->GetPosition();
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: // Find the Frame that is XMost
    1: nsresult 
    1: nsPrintEngine::FindSelectionBounds(nsPresContext* aPresContext,
    1:                                    nsIRenderingContext& aRC,
    1:                                    nsIFrame *      aParentFrame,
    1:                                    nsRect&         aRect,
    1:                                    nsIFrame *&     aStartFrame,
    1:                                    nsRect&         aStartRect,
    1:                                    nsIFrame *&     aEndFrame,
    1:                                    nsRect&         aEndRect)
    1: {
    1:   NS_ASSERTION(aPresContext, "Pointer is null!");
    1:   NS_ASSERTION(aParentFrame, "Pointer is null!");
    1: 
    1:   // loop through named child lists
    1:   nsIAtom* childListName = nsnull;
    1:   PRInt32  childListIndex = 0;
    1:   do {
    1:     nsresult rv = FindSelectionBoundsWithList(aPresContext, aRC, childListName, aParentFrame, aRect, aStartFrame, aStartRect, aEndFrame, aEndRect);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     childListName = aParentFrame->GetAdditionalChildListName(childListIndex++);
    1:   } while (childListName);
    1:   return NS_OK;
    1: }
    1: 
    1: /** ---------------------------------------------------
    1:  *  This method finds the starting and ending page numbers
    1:  *  of the selection and also returns rect for each where
    1:  *  the x,y of the rect is relative to the very top of the
    1:  *  frame tree (absolutely positioned)
    1:  */
    1: nsresult 
    1: nsPrintEngine::GetPageRangeForSelection(nsIPresShell *        aPresShell,
    1:                                         nsPresContext*       aPresContext,
    1:                                         nsIRenderingContext&  aRC,
    1:                                         nsISelection*         aSelection,
    1:                                         nsIPageSequenceFrame* aPageSeqFrame,
    1:                                         nsIFrame**            aStartFrame,
    1:                                         PRInt32&              aStartPageNum,
    1:                                         nsRect&               aStartRect,
    1:                                         nsIFrame**            aEndFrame,
    1:                                         PRInt32&              aEndPageNum,
    1:                                         nsRect&               aEndRect)
    1: {
    1:   NS_ASSERTION(aPresShell, "Pointer is null!");
    1:   NS_ASSERTION(aPresContext, "Pointer is null!");
    1:   NS_ASSERTION(aSelection, "Pointer is null!");
    1:   NS_ASSERTION(aPageSeqFrame, "Pointer is null!");
    1:   NS_ASSERTION(aStartFrame, "Pointer is null!");
    1:   NS_ASSERTION(aEndFrame, "Pointer is null!");
    1: 
23554:   nsIFrame * seqFrame = do_QueryFrame(aPageSeqFrame);
23554:   if (!seqFrame) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   nsIFrame * startFrame = nsnull;
    1:   nsIFrame * endFrame   = nsnull;
    1: 
    1:   // start out with the sequence frame and search the entire frame tree
    1:   // capturing the starting and ending child frames of the selection
    1:   // and their rects
    1:   nsRect r = seqFrame->GetRect();
    1:   FindSelectionBounds(aPresContext, aRC, seqFrame, r,
    1:                       startFrame, aStartRect, endFrame, aEndRect);
    1: 
    1: #ifdef DEBUG_rodsX
    1:   printf("Start Frame: %p\n", startFrame);
    1:   printf("End Frame:   %p\n", endFrame);
    1: #endif
    1: 
    1:   // initial the page numbers here
    1:   // in case we don't find and frames
    1:   aStartPageNum = -1;
    1:   aEndPageNum   = -1;
    1: 
    1:   nsIFrame * startPageFrame;
    1:   nsIFrame * endPageFrame;
    1: 
    1:   // check to make sure we found a starting frame
    1:   if (startFrame != nsnull) {
    1:     // Now search up the tree to find what page the
    1:     // start/ending selections frames are on
    1:     //
    1:     // Check to see if start should be same as end if
    1:     // the end frame comes back null
    1:     if (endFrame == nsnull) {
    1:       // XXX the "GetPageFrame" step could be integrated into
    1:       // the FindSelectionBounds step, but walking up to find
    1:       // the parent of a child frame isn't expensive and it makes
    1:       // FindSelectionBounds a little easier to understand
    1:       startPageFrame = nsLayoutUtils::GetPageFrame(startFrame);
    1:       endPageFrame   = startPageFrame;
    1:       aEndRect       = aStartRect;
    1:     } else {
    1:       startPageFrame = nsLayoutUtils::GetPageFrame(startFrame);
    1:       endPageFrame   = nsLayoutUtils::GetPageFrame(endFrame);
    1:     }
    1:   } else {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1: #ifdef DEBUG_rodsX
    1:   printf("Start Page: %p\n", startPageFrame);
    1:   printf("End Page:   %p\n", endPageFrame);
    1: 
    1:   // dump all the pages and their pointers
    1:   {
    1:   PRInt32 pageNum = 1;
    1:   nsIFrame* child = seqFrame->GetFirstChild(nsnull);
    1:   while (child != nsnull) {
    1:     printf("Page: %d - %p\n", pageNum, child);
    1:     pageNum++;
    1:     child = child->GetNextSibling();
    1:   }
    1:   }
    1: #endif
    1: 
    1:   // Now that we have the page frames
    1:   // find out what the page numbers are for each frame
    1:   PRInt32 pageNum = 1;
    1:   nsIFrame* page = seqFrame->GetFirstChild(nsnull);
    1:   while (page != nsnull) {
    1:     if (page == startPageFrame) {
    1:       aStartPageNum = pageNum;
    1:     }
    1:     if (page == endPageFrame) {
    1:       aEndPageNum = pageNum;
    1:     }
    1:     pageNum++;
    1:     page = page->GetNextSibling();
    1:   }
    1: 
    1: #ifdef DEBUG_rodsX
    1:   printf("Start Page No: %d\n", aStartPageNum);
    1:   printf("End Page No:   %d\n", aEndPageNum);
    1: #endif
    1: 
    1:   *aStartFrame = startPageFrame;
    1:   *aEndFrame   = endPageFrame;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------
    1: //-- Done: Printing Methods
    1: //-----------------------------------------------------------------
    1: 
    1: 
    1: //-----------------------------------------------------------------
    1: //-- Section: Misc Support Methods
    1: //-----------------------------------------------------------------
    1: 
    1: //---------------------------------------------------------------------
    1: void nsPrintEngine::SetIsPrinting(PRBool aIsPrinting)
    1: { 
    1:   mIsDoingPrinting = aIsPrinting;
24061:   // Calling SetIsPrinting while in print preview confuses the document viewer
24061:   // This is safe because we prevent exiting print preview while printing
24061:   if (mDocViewerPrint && !mIsDoingPrintPreview) {
    1:     mDocViewerPrint->SetIsPrinting(aIsPrinting);
    1:   }
 5662:   if (mPrt && aIsPrinting) {
 5662:     mPrt->mPreparingForPrint = PR_TRUE;
 5662:   }
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: void nsPrintEngine::SetIsPrintPreview(PRBool aIsPrintPreview) 
    1: { 
    1:   mIsDoingPrintPreview = aIsPrintPreview; 
    1: 
    1:   if (mDocViewerPrint) {
    1:     mDocViewerPrint->SetIsPrintPreview(aIsPrintPreview);
    1:   }
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: void
    1: nsPrintEngine::CleanupDocTitleArray(PRUnichar**& aArray, PRInt32& aCount)
    1: {
    1:   for (PRInt32 i = aCount - 1; i >= 0; i--) {
    1:     nsMemory::Free(aArray[i]);
    1:   }
    1:   nsMemory::Free(aArray);
    1:   aArray = NULL;
    1:   aCount = 0;
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: // static
    1: PRBool nsPrintEngine::HasFramesetChild(nsIContent* aContent)
    1: {
    1:   if (!aContent) {
    1:     return PR_FALSE;
    1:   }
    1: 
    1:   PRUint32 numChildren = aContent->GetChildCount();
    1: 
    1:   // do a breadth search across all siblings
    1:   for (PRUint32 i = 0; i < numChildren; ++i) {
    1:     nsIContent *child = aContent->GetChildAt(i);
    1:     if (child->Tag() == nsGkAtoms::frameset &&
33329:         child->IsHTML()) {
    1:       return PR_TRUE;
    1:     }
    1:   }
    1: 
    1:   return PR_FALSE;
    1: }
    1:  
    1: 
    1: 
    1: /** ---------------------------------------------------
    1:  *  Get the Focused Frame for a documentviewer
    1:  */
    1: already_AddRefed<nsIDOMWindow>
    1: nsPrintEngine::FindFocusedDOMWindow()
    1: {
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
41536:   NS_ENSURE_TRUE(fm, nsnull);
41536: 
41536:   nsCOMPtr<nsPIDOMWindow> window(mDocument->GetWindow());
41536:   NS_ENSURE_TRUE(window, nsnull);
41536: 
41536:   nsCOMPtr<nsPIDOMWindow> rootWindow = window->GetPrivateRoot();
41536:   NS_ENSURE_TRUE(rootWindow, nsnull);
41536: 
41536:   nsPIDOMWindow* focusedWindow;
41536:   nsFocusManager::GetFocusedDescendant(rootWindow, PR_TRUE, &focusedWindow);
41536:   NS_ENSURE_TRUE(focusedWindow, nsnull);
41536: 
41536:   if (IsWindowsInOurSubTree(focusedWindow)) {
41536:     return focusedWindow;
41536:   }
41536: 
41536:   NS_IF_RELEASE(focusedWindow);
29018:   return nsnull;
    1: }
    1: 
    1: //---------------------------------------------------------------------
    1: PRBool
41536: nsPrintEngine::IsWindowsInOurSubTree(nsPIDOMWindow * window)
    1: {
    1:   PRBool found = PR_FALSE;
    1: 
    1:   // now check to make sure it is in "our" tree of docshells
    1:   if (window) {
    1:     nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
    1:       do_QueryInterface(window->GetDocShell());
    1: 
    1:     if (docShellAsItem) {
    1:       // get this DocViewer docshell
    1:       nsCOMPtr<nsIDocShell> thisDVDocShell(do_QueryInterface(mContainer));
    1:       while (!found) {
    1:         nsCOMPtr<nsIDocShell> parentDocshell(do_QueryInterface(docShellAsItem));
    1:         if (parentDocshell) {
    1:           if (parentDocshell == thisDVDocShell) {
    1:             found = PR_TRUE;
    1:             break;
    1:           }
    1:         } else {
    1:           break; // at top of tree
    1:         }
    1:         nsCOMPtr<nsIDocShellTreeItem> docShellParent;
    1:         docShellAsItem->GetSameTypeParent(getter_AddRefs(docShellParent));
    1:         docShellAsItem = docShellParent;
    1:       } // while
    1:     }
    1:   } // scriptobj
    1: 
    1:   return found;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: PRBool
    1: nsPrintEngine::DonePrintingPages(nsPrintObject* aPO, nsresult aResult)
    1: {
    1:   //NS_ASSERTION(aPO, "Pointer is null!");
    1:   PR_PL(("****** In DV::DonePrintingPages PO: %p (%s)\n", aPO, aPO?gFrameTypesStr[aPO->mFrameType]:""));
    1: 
    1:   if (aPO != nsnull) {
    1:     aPO->mHasBeenPrinted = PR_TRUE;
    1:     nsresult rv;
    1:     PRBool didPrint = PrintDocContent(mPrt->mPrintObject, rv);
    1:     if (NS_SUCCEEDED(rv) && didPrint) {
    1:       PR_PL(("****** In DV::DonePrintingPages PO: %p (%s) didPrint:%s (Not Done Printing)\n", aPO, gFrameTypesStr[aPO->mFrameType], PRT_YESNO(didPrint)));
    1:       return PR_FALSE;
    1:     }
    1:   }
    1: 
    1:   if (NS_SUCCEEDED(aResult)) {
    1:     FirePrintCompletionEvent();
    1:   }
    1: 
25991:   TurnScriptingOn(PR_TRUE);
    1:   SetIsPrinting(PR_FALSE);
    1: 
    1:   // Release reference to mPagePrintTimer; the timer object destroys itself
    1:   // after this returns true
    1:   NS_IF_RELEASE(mPagePrintTimer);
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: // Recursively sets the PO items to be printed "As Is"
    1: // from the given item down into the tree
    1: void
    1: nsPrintEngine::SetPrintAsIs(nsPrintObject* aPO, PRBool aAsIs)
    1: {
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1: 
    1:   aPO->mPrintAsIs = aAsIs;
24551:   for (PRUint32 i=0;i<aPO->mKids.Length();i++) {
24551:     SetPrintAsIs(aPO->mKids[i], aAsIs);
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------
    1: // Given a DOMWindow it recursively finds the PO object that matches
    1: nsPrintObject*
    1: nsPrintEngine::FindPrintObjectByDOMWin(nsPrintObject* aPO,
    1:                                        nsIDOMWindow* aDOMWin)
    1: {
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1: 
    1:   // Often the CurFocused DOMWindow is passed in
    1:   // andit is valid for it to be null, so short circut
    1:   if (!aDOMWin) {
    1:     return nsnull;
    1:   }
    1: 
35581:   nsCOMPtr<nsIDOMDocument> domDoc;
35581:   aDOMWin->GetDocument(getter_AddRefs(domDoc));
35581:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(domDoc);
35581:   if (aPO->mDocument && aPO->mDocument->GetOriginalDocument() == doc) {
    1:     return aPO;
    1:   }
    1: 
24551:   PRInt32 cnt = aPO->mKids.Length();
    1:   for (PRInt32 i = 0; i < cnt; ++i) {
24551:     nsPrintObject* po = FindPrintObjectByDOMWin(aPO->mKids[i], aDOMWin);
    1:     if (po) {
    1:       return po;
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: nsresult
    1: nsPrintEngine::EnablePOsForPrinting()
    1: {
    1:   // NOTE: All POs have been "turned off" for printing
    1:   // this is where we decided which POs get printed.
    1:   mPrt->mSelectedPO = nsnull;
    1: 
    1:   if (mPrt->mPrintSettings == nsnull) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   mPrt->mPrintFrameType = nsIPrintSettings::kNoFrames;
    1:   mPrt->mPrintSettings->GetPrintFrameType(&mPrt->mPrintFrameType);
    1: 
    1:   PRInt16 printHowEnable = nsIPrintSettings::kFrameEnableNone;
    1:   mPrt->mPrintSettings->GetHowToEnableFrameUI(&printHowEnable);
    1: 
    1:   PRInt16 printRangeType = nsIPrintSettings::kRangeAllPages;
    1:   mPrt->mPrintSettings->GetPrintRange(&printRangeType);
    1: 
    1:   PR_PL(("\n"));
    1:   PR_PL(("********* nsPrintEngine::EnablePOsForPrinting *********\n"));
    1:   PR_PL(("PrintFrameType:     %s \n", gPrintFrameTypeStr[mPrt->mPrintFrameType]));
    1:   PR_PL(("HowToEnableFrameUI: %s \n", gFrameHowToEnableStr[printHowEnable]));
    1:   PR_PL(("PrintRange:         %s \n", gPrintRangeStr[printRangeType]));
    1:   PR_PL(("----\n"));
    1: 
    1:   // ***** This is the ultimate override *****
    1:   // if we are printing the selection (either an IFrame or selection range)
    1:   // then set the mPrintFrameType as if it were the selected frame
    1:   if (printRangeType == nsIPrintSettings::kRangeSelection) {
    1:     mPrt->mPrintFrameType = nsIPrintSettings::kSelectedFrame;
    1:     printHowEnable        = nsIPrintSettings::kFrameEnableNone;
    1:   }
    1: 
    1:   // This tells us that the "Frame" UI has turned off,
    1:   // so therefore there are no FrameSets/Frames/IFrames to be printed
    1:   //
    1:   // This means there are not FrameSets,
    1:   // but the document could contain an IFrame
    1:   if (printHowEnable == nsIPrintSettings::kFrameEnableNone) {
    1: 
    1:     // Print all the pages or a sub range of pages
    1:     if (printRangeType == nsIPrintSettings::kRangeAllPages ||
    1:         printRangeType == nsIPrintSettings::kRangeSpecifiedPageRange) {
    1:       SetPrintPO(mPrt->mPrintObject, PR_TRUE);
    1: 
    1:       // Set the children so they are PrinAsIs
    1:       // In this case, the children are probably IFrames
24551:       if (mPrt->mPrintObject->mKids.Length() > 0) {
24551:         for (PRUint32 i=0;i<mPrt->mPrintObject->mKids.Length();i++) {
24551:           nsPrintObject* po = mPrt->mPrintObject->mKids[i];
    1:           NS_ASSERTION(po, "nsPrintObject can't be null!");
    1:           SetPrintAsIs(po);
    1:         }
    1: 
    1:         // ***** Another override *****
    1:         mPrt->mPrintFrameType = nsIPrintSettings::kFramesAsIs;
    1:       }
    1:       PR_PL(("PrintFrameType:     %s \n", gPrintFrameTypeStr[mPrt->mPrintFrameType]));
    1:       PR_PL(("HowToEnableFrameUI: %s \n", gFrameHowToEnableStr[printHowEnable]));
    1:       PR_PL(("PrintRange:         %s \n", gPrintRangeStr[printRangeType]));
    1:       return NS_OK;
    1:     }
    1: 
    1:     // This means we are either printed a selected IFrame or
    1:     // we are printing the current selection
    1:     if (printRangeType == nsIPrintSettings::kRangeSelection) {
    1: 
    1:       // If the currentFocusDOMWin can'r be null if something is selected
    1:       if (mPrt->mCurrentFocusWin) {
    1:         // Find the selected IFrame
    1:         nsPrintObject * po = FindPrintObjectByDOMWin(mPrt->mPrintObject, mPrt->mCurrentFocusWin);
    1:         if (po != nsnull) {
    1:           mPrt->mSelectedPO = po;
    1:           // Makes sure all of its children are be printed "AsIs"
    1:           SetPrintAsIs(po);
    1: 
    1:           // Now, only enable this POs (the selected PO) and all of its children
    1:           SetPrintPO(po, PR_TRUE);
    1: 
    1:           // check to see if we have a range selection,
    1:           // as oppose to a insert selection
    1:           // this means if the user just clicked on the IFrame then
    1:           // there will not be a selection so we want the entire page to print
    1:           //
    1:           // XXX this is sort of a hack right here to make the page
    1:           // not try to reposition itself when printing selection
35581:           nsCOMPtr<nsIDOMWindow> domWin =
35581:             do_QueryInterface(po->mDocument->GetOriginalDocument()->GetWindow());
    1:           if (!IsThereARangeSelection(domWin)) {
    1:             printRangeType = nsIPrintSettings::kRangeAllPages;
    1:             mPrt->mPrintSettings->SetPrintRange(printRangeType);
    1:           }
    1:           PR_PL(("PrintFrameType:     %s \n", gPrintFrameTypeStr[mPrt->mPrintFrameType]));
    1:           PR_PL(("HowToEnableFrameUI: %s \n", gFrameHowToEnableStr[printHowEnable]));
    1:           PR_PL(("PrintRange:         %s \n", gPrintRangeStr[printRangeType]));
    1:           return NS_OK;
    1:         }
    1:       } else {
24551:         for (PRUint32 i=0;i<mPrt->mPrintDocList.Length();i++) {
24551:           nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
    1:           NS_ASSERTION(po, "nsPrintObject can't be null!");
    1:           nsCOMPtr<nsIDOMWindow> domWin = do_GetInterface(po->mDocShell);
    1:           if (IsThereARangeSelection(domWin)) {
    1:             mPrt->mCurrentFocusWin = domWin;
    1:             SetPrintPO(po, PR_TRUE);
    1:             break;
    1:           }
    1:         }
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // check to see if there is a selection when a FrameSet is present
    1:   if (printRangeType == nsIPrintSettings::kRangeSelection) {
    1:     // If the currentFocusDOMWin can'r be null if something is selected
    1:     if (mPrt->mCurrentFocusWin) {
    1:       // Find the selected IFrame
    1:       nsPrintObject * po = FindPrintObjectByDOMWin(mPrt->mPrintObject, mPrt->mCurrentFocusWin);
    1:       if (po != nsnull) {
    1:         mPrt->mSelectedPO = po;
    1:         // Makes sure all of its children are be printed "AsIs"
    1:         SetPrintAsIs(po);
    1: 
    1:         // Now, only enable this POs (the selected PO) and all of its children
    1:         SetPrintPO(po, PR_TRUE);
    1: 
    1:         // check to see if we have a range selection,
    1:         // as oppose to a insert selection
    1:         // this means if the user just clicked on the IFrame then
    1:         // there will not be a selection so we want the entire page to print
    1:         //
    1:         // XXX this is sort of a hack right here to make the page
    1:         // not try to reposition itself when printing selection
35581:         nsCOMPtr<nsIDOMWindow> domWin =
35581:           do_QueryInterface(po->mDocument->GetOriginalDocument()->GetWindow());
    1:         if (!IsThereARangeSelection(domWin)) {
    1:           printRangeType = nsIPrintSettings::kRangeAllPages;
    1:           mPrt->mPrintSettings->SetPrintRange(printRangeType);
    1:         }
    1:         PR_PL(("PrintFrameType:     %s \n", gPrintFrameTypeStr[mPrt->mPrintFrameType]));
    1:         PR_PL(("HowToEnableFrameUI: %s \n", gFrameHowToEnableStr[printHowEnable]));
    1:         PR_PL(("PrintRange:         %s \n", gPrintRangeStr[printRangeType]));
    1:         return NS_OK;
    1:       }
    1:     }
    1:   }
    1: 
    1:   // If we are printing "AsIs" then sets all the POs to be printed as is
    1:   if (mPrt->mPrintFrameType == nsIPrintSettings::kFramesAsIs) {
    1:     SetPrintAsIs(mPrt->mPrintObject);
    1:     SetPrintPO(mPrt->mPrintObject, PR_TRUE);
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If we are printing the selected Frame then
    1:   // find that PO for that selected DOMWin and set it all of its
    1:   // children to be printed
    1:   if (mPrt->mPrintFrameType == nsIPrintSettings::kSelectedFrame) {
    1: 
    1:     if ((mPrt->mIsParentAFrameSet && mPrt->mCurrentFocusWin) || mPrt->mIsIFrameSelected) {
    1:       nsPrintObject * po = FindPrintObjectByDOMWin(mPrt->mPrintObject, mPrt->mCurrentFocusWin);
    1:       if (po != nsnull) {
    1:         mPrt->mSelectedPO = po;
    1:         // NOTE: Calling this sets the "po" and
    1:         // we don't want to do this for documents that have no children,
    1:         // because then the "DoEndPage" gets called and it shouldn't
24551:         if (po->mKids.Length() > 0) {
    1:           // Makes sure that itself, and all of its children are printed "AsIs"
    1:           SetPrintAsIs(po);
    1:         }
    1: 
    1:         // Now, only enable this POs (the selected PO) and all of its children
    1:         SetPrintPO(po, PR_TRUE);
    1:       }
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
    1:   // If we are print each subdoc separately,
    1:   // then don't print any of the FraneSet Docs
    1:   if (mPrt->mPrintFrameType == nsIPrintSettings::kEachFrameSep) {
    1:     SetPrintPO(mPrt->mPrintObject, PR_TRUE);
24551:     PRInt32 cnt = mPrt->mPrintDocList.Length();
    1:     for (PRInt32 i=0;i<cnt;i++) {
24551:       nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
    1:       NS_ASSERTION(po, "nsPrintObject can't be null!");
    1:       if (po->mFrameType == eFrameSet) {
    1:         po->mDontPrint = PR_TRUE;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: // Return the nsPrintObject with that is XMost (The widest frameset frame) AND
    1: // contains the XMost (widest) layout frame
    1: nsPrintObject*
    1: nsPrintEngine::FindSmallestSTF()
    1: {
    1:   float smallestRatio = 1.0f;
    1:   nsPrintObject* smallestPO = nsnull;
    1: 
24551:   for (PRUint32 i=0;i<mPrt->mPrintDocList.Length();i++) {
24551:     nsPrintObject* po = mPrt->mPrintDocList.ElementAt(i);
    1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
    1:     if (po->mFrameType != eFrameSet && po->mFrameType != eIFrame) {
    1:       if (po->mShrinkRatio < smallestRatio) {
    1:         smallestRatio = po->mShrinkRatio;
    1:         smallestPO    = po;
    1:       }
    1:     }
    1:   }
    1: 
    1: #ifdef EXTENDED_DEBUG_PRINTING
    1:   if (smallestPO) printf("*PO: %p  Type: %d  %10.3f\n", smallestPO, smallestPO->mFrameType, smallestPO->mShrinkRatio);
    1: #endif
    1:   return smallestPO;
    1: }
    1: 
    1: //-------------------------------------------------------
    1: void
    1: nsPrintEngine::TurnScriptingOn(PRBool aDoTurnOn)
    1: {
25991:   if (mIsDoingPrinting && aDoTurnOn && mDocViewerPrint &&
25991:       mDocViewerPrint->GetIsPrintPreview()) {
25991:     // We don't want to turn scripting on if print preview is shown still after
25991:     // printing.
25991:     return;
25991:   }
25991: 
    1:   nsPrintData* prt = mPrt;
    1: #ifdef NS_PRINT_PREVIEW
    1:   if (!prt) {
    1:     prt = mPrtPreview;
    1:   }
    1: #endif
    1:   if (!prt) {
    1:     return;
    1:   }
    1: 
    1:   NS_ASSERTION(mDocument, "We MUST have a document.");
    1:   // First, get the script global object from the document...
    1: 
24551:   for (PRUint32 i=0;i<prt->mPrintDocList.Length();i++) {
24551:     nsPrintObject* po = prt->mPrintDocList.ElementAt(i);
    1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
    1: 
    1:     nsIDocument* doc = po->mDocument;
25991:     if (!doc) {
25991:       continue;
25991:     }
    1: 
    1:     // get the script global object
    1:     nsIScriptGlobalObject *scriptGlobalObj = doc->GetScriptGlobalObject();
    1: 
    1:     if (scriptGlobalObj) {
25991:       nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(scriptGlobalObj);
25991:       NS_ASSERTION(window, "Can't get nsPIDOMWindow");
    1:       nsIScriptContext *scx = scriptGlobalObj->GetContext();
25991:       NS_WARN_IF_FALSE(scx, "Can't get nsIScriptContext");
25991:       nsresult propThere = NS_PROPTABLE_PROP_NOT_THERE;
25991:       doc->GetProperty(nsGkAtoms::scriptEnabledBeforePrintOrPreview,
25991:                        &propThere);
    1:       if (aDoTurnOn) {
25991:         if (propThere != NS_PROPTABLE_PROP_NOT_THERE) {
25991:           doc->DeleteProperty(nsGkAtoms::scriptEnabledBeforePrintOrPreview);
25991:           if (scx) {
25991:             scx->SetScriptsEnabled(PR_TRUE, PR_FALSE);
25991:           }
25991:           window->ResumeTimeouts(PR_FALSE);
25991:         }
    1:       } else {
    1:         // Have to be careful, because people call us over and over again with
    1:         // aDoTurnOn == PR_FALSE.  So don't set the property if it's already
    1:         // set, since in that case we'd set it to the wrong value.
    1:         if (propThere == NS_PROPTABLE_PROP_NOT_THERE) {
    1:           // Stash the current value of IsScriptEnabled on the document, so
    1:           // that layout code running in print preview doesn't get confused.
25991:           doc->SetProperty(nsGkAtoms::scriptEnabledBeforePrintOrPreview,
    1:                            NS_INT32_TO_PTR(doc->IsScriptEnabled()));
25991:           if (scx) {
25991:             scx->SetScriptsEnabled(PR_FALSE, PR_FALSE);
25991:           }
25991:           window->SuspendTimeouts(1, PR_FALSE);
25991:         }
25991:       }
    1:     }
    1:   }
    1: }
    1: 
    1: //-----------------------------------------------------------------
    1: //-- Done: Misc Support Methods
    1: //-----------------------------------------------------------------
    1: 
    1: 
    1: //-----------------------------------------------------------------
    1: //-- Section: Finishing up or Cleaning up
    1: //-----------------------------------------------------------------
    1: 
    1: //-----------------------------------------------------------------
    1: void
    1: nsPrintEngine::CloseProgressDialog(nsIWebProgressListener* aWebProgressListener)
    1: {
    1:   if (aWebProgressListener) {
    1:     aWebProgressListener->OnStateChange(nsnull, nsnull, nsIWebProgressListener::STATE_STOP|nsIWebProgressListener::STATE_IS_DOCUMENT, nsnull);
    1:   }
    1: }
    1: 
    1: //-----------------------------------------------------------------
    1: nsresult
    1: nsPrintEngine::FinishPrintPreview()
    1: {
    1:   nsresult rv = NS_OK;
    1: 
    1: #ifdef NS_PRINT_PREVIEW
    1: 
14111:   if (!mPrt) {
14111:     /* we're already finished with print preview */
14111:     return rv;
14111:   }
14111: 
    1:   rv = DocumentReadyForPrinting();
    1: 
    1:   SetIsCreatingPrintPreview(PR_FALSE);
    1: 
    1:   /* cleaup on failure + notify user */
    1:   if (NS_FAILED(rv)) {
    1:     /* cleanup done, let's fire-up an error dialog to notify the user
    1:      * what went wrong...
    1:      */
    1:     mPrt->OnEndPrinting();
    1:     TurnScriptingOn(PR_TRUE);
    1: 
 7782:     return rv;
    1:   }
    1: 
    1:   // At this point we are done preparing everything
    1:   // before it is to be created
    1: 
    1: 
    1:   if (mIsDoingPrintPreview && mOldPrtPreview) {
    1:     delete mOldPrtPreview;
    1:     mOldPrtPreview = nsnull;
    1:   }
    1: 
    1:   InstallPrintPreviewListener();
    1: 
    1:   mPrt->OnEndPrinting();
    1: 
    1:   // PrintPreview was built using the mPrt (code reuse)
    1:   // then we assign it over
    1:   mPrtPreview = mPrt;
    1:   mPrt        = nsnull;
    1: 
    1: #endif // NS_PRINT_PREVIEW
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //-----------------------------------------------------------------
    1: //-- Done: Finishing up or Cleaning up
    1: //-----------------------------------------------------------------
    1: 
    1: 
    1: /*=============== Timer Related Code ======================*/
    1: nsresult
    1: nsPrintEngine::StartPagePrintTimer(nsPrintObject* aPO)
    1: {
    1:   if (!mPagePrintTimer) {
    1:     nsresult rv = NS_NewPagePrintTimer(&mPagePrintTimer);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Get the delay time in between the printing of each page
    1:     // this gives the user more time to press cancel
36472:     PRInt32 printPageDelay = 50;
    1:     mPrt->mPrintSettings->GetPrintPageDelay(&printPageDelay);
    1: 
    1:     mPagePrintTimer->Init(this, mDocViewerPrint, printPageDelay);
    1:   }
    1: 
    1:   return mPagePrintTimer->Start(aPO);
    1: }
    1: 
    1: /*=============== nsIObserver Interface ======================*/
    1: NS_IMETHODIMP 
    1: nsPrintEngine::Observe(nsISupports *aSubject, const char *aTopic, const PRUnichar *aData)
    1: {
    1:   nsresult rv = NS_ERROR_FAILURE;
    1: 
    1:   if (mIsDoingPrinting) {
    1:     rv = DocumentReadyForPrinting();
    1:  
    1:     /* cleaup on failure + notify user */
    1:     if (NS_FAILED(rv)) {
    1:       CleanupOnFailure(rv, PR_TRUE);
    1:     }
    1:   } else {
    1:     rv = FinishPrintPreview();
 7782:     if (NS_FAILED(rv)) {
 7782:       CleanupOnFailure(rv, PR_FALSE);
 7782:     }
    1:     if (mPrtPreview) {
    1:       mPrtPreview->OnEndPrinting();
    1:     }
    1:     rv = NS_OK;
    1:   }
    1: 
    1:   return rv;
    1: 
    1: }
    1: 
    1: //---------------------------------------------------------------
    1: //-- PLEvent Notification
    1: //---------------------------------------------------------------
    1: class nsPrintCompletionEvent : public nsRunnable {
    1: public:
    1:   nsPrintCompletionEvent(nsIDocumentViewerPrint *docViewerPrint)
    1:     : mDocViewerPrint(docViewerPrint) {
    1:     NS_ASSERTION(mDocViewerPrint, "mDocViewerPrint is null.");
    1:   }
    1: 
    1:   NS_IMETHOD Run() {
    1:     if (mDocViewerPrint)
    1:       mDocViewerPrint->OnDonePrinting();
    1:     return NS_OK;
    1:   }
    1: 
    1: private:
    1:   nsCOMPtr<nsIDocumentViewerPrint> mDocViewerPrint;
    1: };
    1: 
    1: //-----------------------------------------------------------
    1: void
    1: nsPrintEngine::FirePrintCompletionEvent()
    1: {
    1:   nsCOMPtr<nsIRunnable> event = new nsPrintCompletionEvent(mDocViewerPrint);
    1:   if (NS_FAILED(NS_DispatchToCurrentThread(event)))
    1:     NS_WARNING("failed to dispatch print completion event");
    1: }
    1: 
    1: //---------------------------------------------------------------
    1: //---------------------------------------------------------------
    1: //-- Debug helper routines
    1: //---------------------------------------------------------------
    1: //---------------------------------------------------------------
    1: #if (defined(XP_WIN) || defined(XP_OS2)) && defined(EXTENDED_DEBUG_PRINTING)
    1: #include "windows.h"
    1: #include "process.h"
    1: #include "direct.h"
    1: 
    1: #define MY_FINDFIRST(a,b) FindFirstFile(a,b)
    1: #define MY_FINDNEXT(a,b) FindNextFile(a,b)
    1: #define ISDIR(a) (a.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    1: #define MY_FINDCLOSE(a) FindClose(a)
    1: #define MY_FILENAME(a) a.cFileName
    1: #define MY_FILESIZE(a) (a.nFileSizeHigh * MAXDWORD) + a.nFileSizeLow
    1: 
    1: int RemoveFilesInDir(const char * aDir)
    1: {
    1: 	WIN32_FIND_DATA data_ptr;
    1: 	HANDLE find_handle;
    1: 
    1:   char path[MAX_PATH];
    1: 
    1:   strcpy(path, aDir);
    1: 
    1: 	// Append slash to the end of the directory names if not there
    1: 	if (path[strlen(path)-1] != '\\')
    1:     strcat(path, "\\");
    1: 
    1:   char findPath[MAX_PATH];
    1:   strcpy(findPath, path);
    1:   strcat(findPath, "*.*");
    1: 
    1: 	find_handle = MY_FINDFIRST(findPath, &data_ptr);
    1: 
    1: 	if (find_handle != INVALID_HANDLE_VALUE) {
    1: 		do  {
    1: 			if (ISDIR(data_ptr)
    1: 				&& (stricmp(MY_FILENAME(data_ptr),"."))
    1: 				&& (stricmp(MY_FILENAME(data_ptr),".."))) {
    1: 					// skip
    1: 			}
    1: 			else if (!ISDIR(data_ptr)) {
    1:         if (!strncmp(MY_FILENAME(data_ptr), "print_dump", 10)) {
    1:           char fileName[MAX_PATH];
    1:           strcpy(fileName, aDir);
    1:           strcat(fileName, "\\");
    1:           strcat(fileName, MY_FILENAME(data_ptr));
    1: 				  printf("Removing %s\n", fileName);
    1:           remove(fileName);
    1:         }
    1: 			}
    1: 		} while(MY_FINDNEXT(find_handle,&data_ptr));
    1: 		MY_FINDCLOSE(find_handle);
    1: 	}
    1: 	return TRUE;
    1: }
    1: #endif
    1: 
    1: #ifdef EXTENDED_DEBUG_PRINTING
    1: 
    1: /** ---------------------------------------------------
    1:  *  Dumps Frames for Printing
    1:  */
    1: static void RootFrameList(nsPresContext* aPresContext, FILE* out, PRInt32 aIndent)
    1: {
    1:   if (!aPresContext || !out)
    1:     return;
    1: 
    1:   nsIPresShell *shell = aPresContext->GetPresShell();
    1:   if (shell) {
    1:     nsIFrame* frame = shell->FrameManager()->GetRootFrame();
    1:     if (frame) {
31709:       frame->List(aPresContext, out, aIndent);
    1:     }
    1:   }
    1: }
    1: 
    1: /** ---------------------------------------------------
    1:  *  Dumps Frames for Printing
    1:  */
    1: static void DumpFrames(FILE*                 out,
    1:                        nsPresContext*       aPresContext,
    1:                        nsIRenderingContext * aRendContext,
    1:                        nsIFrame *            aFrame,
    1:                        PRInt32               aLevel)
    1: {
    1:   NS_ASSERTION(out, "Pointer is null!");
    1:   NS_ASSERTION(aPresContext, "Pointer is null!");
    1:   NS_ASSERTION(aRendContext, "Pointer is null!");
    1:   NS_ASSERTION(aFrame, "Pointer is null!");
    1: 
    1:   nsIFrame* child = aFrame->GetFirstChild(nsnull);
    1:   while (child != nsnull) {
    1:     for (PRInt32 i=0;i<aLevel;i++) {
    1:      fprintf(out, "  ");
    1:     }
    1:     nsAutoString tmp;
31709:     child->GetFrameName(tmp);
    1:     fputs(NS_LossyConvertUTF16toASCII(tmp).get(), out);
    1:     PRBool isSelected;
    1:     if (NS_SUCCEEDED(child->IsVisibleForPainting(aPresContext, *aRendContext, PR_TRUE, &isSelected))) {
    1:       fprintf(out, " %p %s", child, isSelected?"VIS":"UVS");
    1:       nsRect rect = child->GetRect();
    1:       fprintf(out, "[%d,%d,%d,%d] ", rect.x, rect.y, rect.width, rect.height);
    1:       fprintf(out, "v: %p ", (void*)child->GetView());
    1:       fprintf(out, "\n");
    1:       DumpFrames(out, aPresContext, aRendContext, child, aLevel+1);
    1:       child = child->GetNextSibling();
    1:     }
    1:   }
    1: }
    1: 
    1: 
    1: /** ---------------------------------------------------
    1:  *  Dumps the Views from the DocShell
    1:  */
    1: static void
    1: DumpViews(nsIDocShell* aDocShell, FILE* out)
    1: {
    1:   NS_ASSERTION(aDocShell, "Pointer is null!");
    1:   NS_ASSERTION(out, "Pointer is null!");
    1: 
    1:   if (nsnull != aDocShell) {
    1:     fprintf(out, "docshell=%p \n", aDocShell);
    1:     nsIPresShell* shell = nsPrintEngine::GetPresShellFor(aDocShell);
    1:     if (shell) {
    1:       nsIViewManager* vm = shell->GetViewManager();
    1:       if (vm) {
    1:         nsIView* root;
    1:         vm->GetRootView(root);
    1:         if (nsnull != root) {
    1:           root->List(out);
    1:         }
    1:       }
    1:     }
    1:     else {
    1:       fputs("null pres shell\n", out);
    1:     }
    1: 
    1:     // dump the views of the sub documents
    1:     PRInt32 i, n;
    1:     nsCOMPtr<nsIDocShellTreeNode> docShellAsNode(do_QueryInterface(aDocShell));
    1:     docShellAsNode->GetChildCount(&n);
    1:     for (i = 0; i < n; i++) {
    1:       nsCOMPtr<nsIDocShellTreeItem> child;
    1:       docShellAsNode->GetChildAt(i, getter_AddRefs(child));
    1:       nsCOMPtr<nsIDocShell> childAsShell(do_QueryInterface(child));
    1:       if (childAsShell) {
    1:         DumpViews(childAsShell, out);
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: /** ---------------------------------------------------
    1:  *  Dumps the Views and Frames
    1:  */
    1: void DumpLayoutData(char*              aTitleStr,
    1:                     char*              aURLStr,
    1:                     nsPresContext*    aPresContext,
    1:                     nsIDeviceContext * aDC,
    1:                     nsIFrame *         aRootFrame,
    1:                     nsIDocShekk *      aDocShell,
    1:                     FILE*              aFD = nsnull)
    1: {
    1:   if (!kPrintingLogMod || kPrintingLogMod->level != DUMP_LAYOUT_LEVEL) return;
    1: 
    1:   if (aPresContext == nsnull || aDC == nsnull) {
    1:     return;
    1:   }
    1: 
    1: #ifdef NS_PRINT_PREVIEW
    1:   if (aPresContext->Type() == nsPresContext::eContext_PrintPreview) {
    1:     return;
    1:   }
    1: #endif
    1: 
    1:   NS_ASSERTION(aRootFrame, "Pointer is null!");
    1:   NS_ASSERTION(aDocShell, "Pointer is null!");
    1: 
    1:   // Dump all the frames and view to a a file
    1:   char filename[256];
    1:   sprintf(filename, "print_dump_layout_%d.txt", gDumpLOFileNameCnt++);
    1:   FILE * fd = aFD?aFD:fopen(filename, "w");
    1:   if (fd) {
    1:     fprintf(fd, "Title: %s\n", aTitleStr?aTitleStr:"");
    1:     fprintf(fd, "URL:   %s\n", aURLStr?aURLStr:"");
    1:     fprintf(fd, "--------------- Frames ----------------\n");
    1:     fprintf(fd, "--------------- Frames ----------------\n");
    1:     nsCOMPtr<nsIRenderingContext> renderingContext;
    1:     aDC->CreateRenderingContext(*getter_AddRefs(renderingContext));
    1:     RootFrameList(aPresContext, fd, 0);
    1:     //DumpFrames(fd, aPresContext, renderingContext, aRootFrame, 0);
    1:     fprintf(fd, "---------------------------------------\n\n");
    1:     fprintf(fd, "--------------- Views From Root Frame----------------\n");
    1:     nsIView* v = aRootFrame->GetView();
    1:     if (v) {
    1:       v->List(fd);
    1:     } else {
    1:       printf("View is null!\n");
    1:     }
    1:     if (aDocShell) {
    1:       fprintf(fd, "--------------- All Views ----------------\n");
    1:       DumpViews(aDocShell, fd);
    1:       fprintf(fd, "---------------------------------------\n\n");
    1:     }
    1:     if (aFD == nsnull) {
    1:       fclose(fd);
    1:     }
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------
24551: static void DumpPrintObjectsList(nsTArray<nsPrintObject*> * aDocList)
    1: {
    1:   if (!kPrintingLogMod || kPrintingLogMod->level != DUMP_LAYOUT_LEVEL) return;
    1: 
    1:   NS_ASSERTION(aDocList, "Pointer is null!");
    1: 
    1:   const char types[][3] = {"DC", "FR", "IF", "FS"};
    1:   PR_PL(("Doc List\n***************************************************\n"));
    1:   PR_PL(("T  P A H    PO    DocShell   Seq     Page      Root     Page#    Rect\n"));
24551:   PRInt32 cnt = aDocList->Length();
    1:   for (PRInt32 i=0;i<cnt;i++) {
24551:     nsPrintObject* po = aDocList->ElementAt(i);
    1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
    1:     nsIFrame* rootFrame = nsnull;
    1:     if (po->mPresShell) {
    1:       rootFrame = po->mPresShell->FrameManager()->GetRootFrame();
    1:       while (rootFrame != nsnull) {
23554:         nsIPageSequenceFrame * sqf = do_QueryFrame(rootFrame);
23554:         if (sqf) {
    1:           break;
    1:         }
    1:         rootFrame = rootFrame->GetFirstChild(nsnull);
    1:       }
    1:     }
    1: 
    1:     PR_PL(("%s %d %d %d %p %p %p %p %p   %d   %d,%d,%d,%d\n", types[po->mFrameType],
    1:             po->IsPrintable(), po->mPrintAsIs, po->mHasBeenPrinted, po, po->mDocShell.get(), po->mSeqFrame,
    1:             po->mPageFrame, rootFrame, po->mPageNum, po->mRect.x, po->mRect.y, po->mRect.width, po->mRect.height));
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------
    1: static void DumpPrintObjectsTree(nsPrintObject * aPO, int aLevel, FILE* aFD)
    1: {
    1:   if (!kPrintingLogMod || kPrintingLogMod->level != DUMP_LAYOUT_LEVEL) return;
    1: 
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1: 
    1:   FILE * fd = aFD?aFD:stdout;
    1:   const char types[][3] = {"DC", "FR", "IF", "FS"};
    1:   if (aLevel == 0) {
    1:     fprintf(fd, "DocTree\n***************************************************\n");
    1:     fprintf(fd, "T     PO    DocShell   Seq      Page     Page#    Rect\n");
    1:   }
24551:   PRInt32 cnt = aPO->mKids.Length();
    1:   for (PRInt32 i=0;i<cnt;i++) {
24551:     nsPrintObject* po = aPO->mKids.ElementAt(i);
    1:     NS_ASSERTION(po, "nsPrintObject can't be null!");
    1:     for (PRInt32 k=0;k<aLevel;k++) fprintf(fd, "  ");
    1:     fprintf(fd, "%s %p %p %p %p %d %d,%d,%d,%d\n", types[po->mFrameType], po, po->mDocShell.get(), po->mSeqFrame,
    1:            po->mPageFrame, po->mPageNum, po->mRect.x, po->mRect.y, po->mRect.width, po->mRect.height);
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------
    1: static void GetDocTitleAndURL(nsPrintObject* aPO, char *& aDocStr, char *& aURLStr)
    1: {
    1:   aDocStr = nsnull;
    1:   aURLStr = nsnull;
    1: 
    1:   PRUnichar * docTitleStr;
    1:   PRUnichar * docURLStr;
    1:   nsPrintEngine::GetDisplayTitleAndURL(aPO,
    1:                                             &docTitleStr, &docURLStr,
    1:                                             nsPrintEngine::eDocTitleDefURLDoc); 
    1: 
    1:   if (docTitleStr) {
    1:     nsAutoString strDocTitle(docTitleStr);
    1:     aDocStr = ToNewCString(strDocTitle);
    1:     nsMemory::Free(docTitleStr);
    1:   }
    1: 
    1:   if (docURLStr) {
    1:     nsAutoString strURL(docURLStr);
    1:     aURLStr = ToNewCString(strURL);
    1:     nsMemory::Free(docURLStr);
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------
    1: static void DumpPrintObjectsTreeLayout(nsPrintObject * aPO,
    1:                                        nsIDeviceContext * aDC,
    1:                                        int aLevel, FILE * aFD)
    1: {
    1:   if (!kPrintingLogMod || kPrintingLogMod->level != DUMP_LAYOUT_LEVEL) return;
    1: 
    1:   NS_ASSERTION(aPO, "Pointer is null!");
    1:   NS_ASSERTION(aDC, "Pointer is null!");
    1: 
    1:   const char types[][3] = {"DC", "FR", "IF", "FS"};
    1:   FILE * fd = nsnull;
    1:   if (aLevel == 0) {
    1:     fd = fopen("tree_layout.txt", "w");
    1:     fprintf(fd, "DocTree\n***************************************************\n");
    1:     fprintf(fd, "***************************************************\n");
    1:     fprintf(fd, "T     PO    DocShell   Seq      Page     Page#    Rect\n");
    1:   } else {
    1:     fd = aFD;
    1:   }
    1:   if (fd) {
    1:     nsIFrame* rootFrame = nsnull;
    1:     if (aPO->mPresShell) {
    1:       rootFrame = aPO->mPresShell->FrameManager()->GetRootFrame();
    1:     }
    1:     for (PRInt32 k=0;k<aLevel;k++) fprintf(fd, "  ");
    1:     fprintf(fd, "%s %p %p %p %p %d %d,%d,%d,%d\n", types[aPO->mFrameType], aPO, aPO->mDocShell.get(), aPO->mSeqFrame,
    1:            aPO->mPageFrame, aPO->mPageNum, aPO->mRect.x, aPO->mRect.y, aPO->mRect.width, aPO->mRect.height);
    1:     if (aPO->IsPrintable()) {
    1:       char * docStr;
    1:       char * urlStr;
    1:       GetDocTitleAndURL(aPO, docStr, urlStr);
    1:       DumpLayoutData(docStr, urlStr, aPO->mPresContext, aDC, rootFrame, aPO->mDocShell, fd);
    1:       if (docStr) nsMemory::Free(docStr);
    1:       if (urlStr) nsMemory::Free(urlStr);
    1:     }
    1:     fprintf(fd, "<***************************************************>\n");
    1: 
24551:     PRInt32 cnt = aPO->mKids.Length();
    1:     for (PRInt32 i=0;i<cnt;i++) {
24551:       nsPrintObject* po = aPO->mKids.ElementAt(i);
    1:       NS_ASSERTION(po, "nsPrintObject can't be null!");
    1:       DumpPrintObjectsTreeLayout(po, aDC, aLevel+1, fd);
    1:     }
    1:   }
    1:   if (aLevel == 0 && fd) {
    1:     fclose(fd);
    1:   }
    1: }
    1: 
    1: //-------------------------------------------------------------
24551: static void DumpPrintObjectsListStart(const char * aStr, nsTArray<nsPrintObject*> * aDocList)
    1: {
    1:   if (!kPrintingLogMod || kPrintingLogMod->level != DUMP_LAYOUT_LEVEL) return;
    1: 
    1:   NS_ASSERTION(aStr, "Pointer is null!");
    1:   NS_ASSERTION(aDocList, "Pointer is null!");
    1: 
    1:   PR_PL(("%s\n", aStr));
    1:   DumpPrintObjectsList(aDocList);
    1: }
    1: 
    1: #define DUMP_DOC_LIST(_title) DumpPrintObjectsListStart((_title), mPrt->mPrintDocList);
    1: #define DUMP_DOC_TREE DumpPrintObjectsTree(mPrt->mPrintObject);
    1: #define DUMP_DOC_TREELAYOUT DumpPrintObjectsTreeLayout(mPrt->mPrintObject, mPrt->mPrintDC);
    1: 
    1: #else
    1: #define DUMP_DOC_LIST(_title)
    1: #define DUMP_DOC_TREE
    1: #define DUMP_DOC_TREELAYOUT
    1: #endif
    1: 
    1: //---------------------------------------------------------------
    1: //---------------------------------------------------------------
    1: //-- End of debug helper routines
    1: //---------------------------------------------------------------
