50491: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
50491:  * vim: set ts=8 sw=4 et tw=99 ft=cpp:
50491:  *
50491:  * ***** BEGIN LICENSE BLOCK *****
50491:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
50491:  *
50491:  * The contents of this file are subject to the Mozilla Public License Version
50491:  * 1.1 (the "License"); you may not use this file except in compliance with
50491:  * the License. You may obtain a copy of the License at
50491:  * http://www.mozilla.org/MPL/
50491:  *
50491:  * Software distributed under the License is distributed on an "AS IS" basis,
50491:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
50491:  * for the specific language governing rights and limitations under the
50491:  * License.
50491:  *
50491:  * The Original Code is Mozilla SpiderMonkey JavaScript 1.9 code, released
50491:  * June 12, 2009.
50491:  *
50491:  * The Initial Developer of the Original Code is
50491:  *   the Mozilla Corporation.
50491:  *
50491:  * Contributor(s):
50491:  *   Chris Leary <cdleary@mozilla.com>
50491:  *
50491:  * Alternatively, the contents of this file may be used under the terms of
50491:  * either of the GNU General Public License Version 2 or later (the "GPL"),
50491:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
50491:  * in which case the provisions of the GPL or the LGPL are applicable instead
50491:  * of those above. If you wish to allow use of your version of this file only
50491:  * under the terms of either the GPL or the LGPL, and not to allow others to
50491:  * use your version of this file under the terms of the MPL, indicate your
50491:  * decision by deleting the provisions above and replace them with the notice
50491:  * and other provisions required by the GPL or the LGPL. If you do not delete
50491:  * the provisions above, a recipient may use your version of this file under
50491:  * the terms of any one of the MPL, the GPL or the LGPL.
50491:  *
50491:  * ***** END LICENSE BLOCK ***** */
50491: 
50491: #ifndef jsregexpinlines_h___
50491: #define jsregexpinlines_h___
50491: 
50491: #include "jsregexp.h"
50491: #include "jscntxt.h"
50491: #include "jsobjinlines.h"
50493: #include "assembler/wtf/Platform.h"
50493: 
50493: #if ENABLE_YARR_JIT
50491: #include "yarr/yarr/RegexJIT.h"
50493: #else
50491: #include "yarr/pcre/pcre.h"
50493: #endif
50491: 
50491: namespace js {
50491: 
53858: /*
53858:  * res = RegExp statics.
53858:  */
53858: 
53858: extern Class regexp_statics_class;
53858: 
53858: static inline JSObject *
56553: regexp_statics_construct(JSContext *cx, JSObject *parent)
53858: {
56553:     JSObject *obj = NewObject<WithProto::Given>(cx, &regexp_statics_class, NULL, parent);
53858:     if (!obj)
53858:         return NULL;
53858:     RegExpStatics *res = cx->create<RegExpStatics>();
53858:     if (!res)
53858:         return NULL;
53858:     obj->setPrivate(static_cast<void *>(res));
53858:     return obj;
53858: }
53858: 
50491: /* Defined in the inlines header to avoid Yarr dependency includes in main header. */
50491: class RegExp
50491: {
50491:     jsrefcount                  refCount;
50491:     JSString                    *source;
50491: #if ENABLE_YARR_JIT
50491:     JSC::Yarr::RegexCodeBlock   compiled;
50491: #else
50491:     JSRegExp                    *compiled;
50491: #endif
50491:     unsigned                    parenCount;
50491:     uint32                      flags;
50491: 
50491:     RegExp(JSString *source, uint32 flags)
57585:       : refCount(1), source(source), compiled(), parenCount(0), flags(flags) {}
50491:     bool compileHelper(JSContext *cx, UString &pattern);
50491:     bool compile(JSContext *cx);
50491:     static const uint32 allFlags = JSREG_FOLD | JSREG_GLOB | JSREG_MULTILINE | JSREG_STICKY;
50491:     void handlePCREError(JSContext *cx, int error);
50491:     void handleYarrError(JSContext *cx, int error);
53858:     static inline bool initArena(JSContext *cx);
57584:     static inline void checkMatchPairs(JSString *input, int *buf, size_t matchItemCount);
57584:     static JSObject *createResult(JSContext *cx, JSString *input, int *buf, size_t matchItemCount);
53858:     inline bool executeInternal(JSContext *cx, RegExpStatics *res, JSString *input,
53858:                                 size_t *lastIndex, bool test, Value *rval);
50491: 
50491:   public:
50491:     ~RegExp() {
50491: #if !ENABLE_YARR_JIT
50491:         if (compiled)
50491:             jsRegExpFree(compiled);
50491: #endif
50491:     }
50491: 
54576:     static bool isMetaChar(jschar c);
50491:     static bool hasMetaChars(const jschar *chars, size_t length);
50491: 
50491:     /*
50491:      * Parse regexp flags. Report an error and return false if an invalid
50491:      * sequence of flags is encountered (repeat/invalid flag).
50491:      */
50491:     static bool parseFlags(JSContext *cx, JSString *flagStr, uint32 &flagsOut);
50491: 
50491:     /*
50491:      * Execute regexp on |input| at |*lastIndex|.
50491:      *
50491:      * On match:    Update |*lastIndex| and RegExp class statics.
50491:      *              Return true if test is true. Place an array in |*rval| if test is false.
50491:      * On mismatch: Make |*rval| null.
50491:      */
53858:     bool execute(JSContext *cx, RegExpStatics *res, JSString *input, size_t *lastIndex, bool test,
53858:                  Value *rval) {
53858:         JS_ASSERT(res);
53858:         return executeInternal(cx, res, input, lastIndex, test, rval);
53858:     }
53858: 
53858:     bool executeNoStatics(JSContext *cx, JSString *input, size_t *lastIndex, bool test,
53858:                           Value *rval) {
53858:         return executeInternal(cx, NULL, input, lastIndex, test, rval);
53858:     }
50491: 
50491:     /* Factories. */
50491:     static RegExp *create(JSContext *cx, JSString *source, uint32 flags);
50491:     static RegExp *createFlagged(JSContext *cx, JSString *source, JSString *flags);
50491:     /*
50491:      * Create an object with new regular expression internals.
50491:      * @note    The context's regexp statics flags are OR'd into the provided flags,
50491:      *          so this function is really meant for object creation during code
50491:      *          execution, as opposed to during something like XDR.
50491:      */
53858:     static JSObject *createObject(JSContext *cx, RegExpStatics *res, const jschar *chars,
53858:                                   size_t length, uint32 flags);
53858:     static JSObject *createObjectNoStatics(JSContext *cx, const jschar *chars, size_t length,
53858:                                            uint32 flags);
50491:     static RegExp *extractFrom(JSObject *obj);
50491:     static RegExp *clone(JSContext *cx, const RegExp &other);
50491: 
50491:     /* Mutators. */
50491:     void incref(JSContext *cx) { JS_ATOMIC_INCREMENT(&refCount); }
50491:     void decref(JSContext *cx);
50491: 
50491:     /* Accessors. */
50491:     JSString *getSource() const { return source; }
50491:     size_t getParenCount() const { return parenCount; }
50491:     bool ignoreCase() const { return flags & JSREG_FOLD; }
50491:     bool global() const { return flags & JSREG_GLOB; }
50491:     bool multiline() const { return flags & JSREG_MULTILINE; }
50491:     bool sticky() const { return flags & JSREG_STICKY; }
57585: 
50491:     const uint32 &getFlags() const { JS_ASSERT((flags & allFlags) == flags); return flags; }
50491:     uint32 flagCount() const;
50491: };
50491: 
53858: class RegExpMatchBuilder
53858: {
53858:     JSContext   * const cx;
53858:     JSObject    * const array;
53858: 
53858:   public:
53858:     RegExpMatchBuilder(JSContext *cx, JSObject *array) : cx(cx), array(array) {}
53858: 
53858:     bool append(int index, JSString *str) {
53858:         JS_ASSERT(str);
53858:         return append(INT_TO_JSID(index), StringValue(str));
53858:     }
53858: 
53858:     bool append(jsid id, Value val) {
53858:         return !!js_DefineProperty(cx, array, id, &val, js::PropertyStub, js::PropertyStub,
53858:                                    JSPROP_ENUMERATE);
53858:     }
53858: 
53858:     bool appendIndex(int index) {
53858:         return append(ATOM_TO_JSID(cx->runtime->atomState.indexAtom), Int32Value(index));
53858:     }
53858: 
53858:     /* Sets the input attribute of the match array. */
53858:     bool appendInput(JSString *str) {
53858:         JS_ASSERT(str);
53858:         return append(ATOM_TO_JSID(cx->runtime->atomState.inputAtom), StringValue(str));
53858:     }
53858: };
53858: 
50491: /* RegExp inlines. */
50491: 
53858: inline bool
53858: RegExp::initArena(JSContext *cx)
53858: {
53858:     if (cx->regExpPool.first.next)
53858:         return true;
53858: 
53858:     /*
53858:      * The regular expression arena pool is special... we want to hang on to it
53858:      * until a GC is performed so rapid subsequent regexp executions don't
53858:      * thrash malloc/freeing arena chunks.
53858:      *
53858:      * Stick a timestamp at the base of that pool.
53858:      */
53858:     int64 *timestamp;
53858:     JS_ARENA_ALLOCATE_CAST(timestamp, int64 *, &cx->regExpPool, sizeof *timestamp);
53858:     if (!timestamp)
53858:         return false;
53858:     *timestamp = JS_Now();
53858:     return true;
53858: }
53858: 
53858: inline void
57584: RegExp::checkMatchPairs(JSString *input, int *buf, size_t matchItemCount)
53858: {
53858: #if DEBUG
57584:     size_t inputLength = input->length();
57584:     int largestStartSeen = 0;
57584:     for (size_t i = 0; i < matchItemCount; i += 2) {
57584:         int start = buf[i];
57584:         int limit = buf[i + 1];
57584:         JS_ASSERT(limit >= start); /* Limit index must be larger than the start index. */
57584:         if (start == -1)
57584:             continue;
57584:         JS_ASSERT(start >= 0);
57584:         JS_ASSERT(size_t(limit) <= inputLength);
57584:         /* Test the monotonically increasing nature of left parens. */
57584:         JS_ASSERT(start >= largestStartSeen);
57584:         largestStartSeen = start;
57584:     }
53858: #endif
53858: }
53858: 
53858: inline JSObject *
57584: RegExp::createResult(JSContext *cx, JSString *input, int *buf, size_t matchItemCount)
53858: {
53858:     /*
53858:      * Create the result array for a match. Array contents:
53858:      *  0:              matched string
58510:      *  1..pairCount-1: paren matches
53858:      */
53858:     JSObject *array = js_NewSlowArrayObject(cx);
53858:     if (!array)
53858:         return NULL;
53858: 
53858:     RegExpMatchBuilder builder(cx, array);
53858:     for (size_t i = 0; i < matchItemCount; i += 2) {
57584:         int start = buf[i];
57584:         int end = buf[i + 1];
53858: 
53858:         JSString *captured;
53858:         if (start >= 0) {
53858:             JS_ASSERT(start <= end);
57584:             JS_ASSERT(unsigned(end) <= input->length());
53858:             captured = js_NewDependentString(cx, input, start, end - start);
53858:             if (!(captured && builder.append(i / 2, captured)))
53858:                 return NULL;
53858:         } else {
53858:             /* Missing parenthesized match. */
53858:             JS_ASSERT(i != 0); /* Since we had a match, first pair must be present. */
53858:             if (!builder.append(INT_TO_JSID(i / 2), UndefinedValue()))
53858:                 return NULL;
53858:         }
53858:     }
53858: 
57584:     if (!builder.appendIndex(buf[0]) ||
53858:         !builder.appendInput(input))
53858:         return NULL;
53858: 
53858:     return array;
53858: }
53858: 
53858: inline bool
53858: RegExp::executeInternal(JSContext *cx, RegExpStatics *res, JSString *input,
53858:                         size_t *lastIndex, bool test, Value *rval)
53858: {
53858: #if !ENABLE_YARR_JIT
53858:     JS_ASSERT(compiled);
53858: #endif
53858:     const size_t pairCount = parenCount + 1;
53858:     const size_t bufCount = pairCount * 3; /* Should be x2, but PCRE has... needs. */
53858:     const size_t matchItemCount = pairCount * 2;
53858: 
53858:     if (!initArena(cx))
53858:         return false;
53858: 
53858:     AutoArenaAllocator aaa(&cx->regExpPool);
53858:     int *buf = aaa.alloc<int>(bufCount);
53858:     if (!buf)
53858:         return false;
53858: 
53858:     /*
53858:      * The JIT regexp procedure doesn't always initialize matchPair values.
53858:      * Maybe we can make this faster by ensuring it does?
53858:      */
53858:     for (int *it = buf; it != buf + matchItemCount; ++it)
53858:         *it = -1;
53858: 
53858:     const jschar *chars = input->chars();
53858:     size_t len = input->length();
57584: 
57584:     /* 
57584:      * inputOffset emulates sticky mode by matching from this offset into the char buf and
57584:      * subtracting the delta off at the end.
57584:      */
53858:     size_t inputOffset = 0;
53858: 
53858:     if (sticky()) {
53858:         /* Sticky matches at the last index for the regexp object. */
53858:         chars += *lastIndex;
53858:         len -= *lastIndex;
53858:         inputOffset = *lastIndex;
53858:     }
53858: 
53858: #if ENABLE_YARR_JIT
53858:     int result = JSC::Yarr::executeRegex(cx, compiled, chars, *lastIndex - inputOffset, len, buf,
53858:                                          bufCount);
53858: #else
53858:     int result = jsRegExpExecute(cx, compiled, chars, len, *lastIndex - inputOffset, buf, 
53858:                                  bufCount) < 0 ? -1 : buf[0];
53858: #endif
53858:     if (result == -1) {
53858:         *rval = NullValue();
53858:         return true;
53858:     }
53858: 
57584:     /* 
57584:      * Adjust buf for the inputOffset. Use of sticky is rare and the matchItemCount is small, so
57584:      * just do another pass.
57584:      */
57584:     if (JS_UNLIKELY(inputOffset)) {
53858:         for (size_t i = 0; i < matchItemCount; ++i)
57584:             buf[i] = buf[i] < 0 ? -1 : buf[i] + inputOffset;
53858:     }
53858: 
57584:     /* Make sure the populated contents of |buf| are sane values against |input|. */
57584:     checkMatchPairs(input, buf, matchItemCount);
57584: 
57584:     if (res)
57584:         res->updateFromMatch(cx, input, buf, matchItemCount);
57584: 
57584:     *lastIndex = buf[1];
53858: 
53858:     if (test) {
53858:         *rval = BooleanValue(true);
53858:         return true;
53858:     }
53858: 
57584:     JSObject *array = createResult(cx, input, buf, matchItemCount);
53858:     if (!array)
53858:         return false;
53858: 
53858:     *rval = ObjectValue(*array);
53858:     return true;
53858: }
53858: 
50491: inline RegExp *
50491: RegExp::create(JSContext *cx, JSString *source, uint32 flags)
50491: {
50491:     RegExp *self;
50491:     void *mem = cx->malloc(sizeof(*self));
50491:     if (!mem)
50491:         return NULL;
50491:     self = new (mem) RegExp(source, flags);
50491:     if (!self->compile(cx)) {
50491:         cx->destroy<RegExp>(self);
50491:         return NULL;
50491:     }
50491:     return self;
50491: }
50491: 
50491: inline JSObject *
53858: RegExp::createObject(JSContext *cx, RegExpStatics *res, const jschar *chars, size_t length,
53858:                      uint32 flags)
53858: {
53858:     uint32 staticsFlags = res->getFlags();
53858:     return createObjectNoStatics(cx, chars, length, flags | staticsFlags);
53858: }
53858: 
53858: inline JSObject *
53858: RegExp::createObjectNoStatics(JSContext *cx, const jschar *chars, size_t length, uint32 flags)
50491: {
50491:     JS_ASSERT((flags & allFlags) == flags);
50491:     JSString *str = js_NewStringCopyN(cx, chars, length);
50491:     if (!str)
50491:         return NULL;
53858:     RegExp *re = RegExp::create(cx, str, flags);
50491:     if (!re)
50491:         return NULL;
50491:     JSObject *obj = NewBuiltinClassInstance(cx, &js_RegExpClass);
50491:     if (!obj) {
50491:         re->decref(cx);
50491:         return NULL;
50491:     }
50491:     obj->setPrivate(re);
50491:     obj->zeroRegExpLastIndex();
50491:     return obj;
50491: }
50491: 
55910: #ifdef ANDROID
55910: static bool
55910: YarrJITIsBroken(JSContext *cx)
55910: {
55910: #if defined(JS_TRACER) && defined(JS_METHODJIT)
55910:     /* FIXME/bug 604774: dead code walking.
55910:      *
55910:      * If both JITs are disabled, assume they were disabled because
55910:      * we're running on a blacklisted device.
55910:      */
55910:     return !cx->traceJitEnabled && !cx->methodJitEnabled;
55910: #else
55910:     return false;
55910: #endif
55910: }
55910: #endif  /* ANDROID */
55910: 
50491: inline bool
50491: RegExp::compileHelper(JSContext *cx, UString &pattern)
50491: {
50491: #if ENABLE_YARR_JIT
50491:     bool fellBack = false;
50491:     int error = 0;
55910:     jitCompileRegex(*cx->runtime->regExpAllocator, compiled, pattern, parenCount, error, fellBack, ignoreCase(), multiline()
55910: #ifdef ANDROID
55910:                     /* Temporary gross hack to work around buggy kernels. */
55910:                     , YarrJITIsBroken(cx)
55910: #endif
55910: );
50491:     if (!error)
50491:         return true;
50491:     if (fellBack)
50491:         handlePCREError(cx, error);
50491:     else
50491:         handleYarrError(cx, error);
50491:     return false;
50491: #else
50491:     int error = 0;
50491:     compiled = jsRegExpCompile(pattern.chars(), pattern.length(),
50491:                                ignoreCase() ? JSRegExpIgnoreCase : JSRegExpDoNotIgnoreCase,
50491:                                multiline() ? JSRegExpMultiline : JSRegExpSingleLine,
53550:                                &parenCount, &error);
50491:     if (!error)
50491:         return true;
50491:     handlePCREError(cx, error);
50491:     return false;
50491: #endif
50491: }
50491: 
50491: inline bool
50491: RegExp::compile(JSContext *cx)
50491: {
50491:     if (!sticky())
50491:         return compileHelper(cx, *source);
50491:     /*
50491:      * The sticky case we implement hackily by prepending a caret onto the front
50491:      * and relying on |::execute| to pseudo-slice the string when it sees a sticky regexp.
50491:      */
53580:     static const jschar prefix[] = {'^', '(', '?', ':'};
53580:     static const jschar postfix[] = {')'};
53580: 
53580:     JSCharBuffer cb(cx);
53580:     if (!cb.reserve(JS_ARRAY_LENGTH(prefix) + source->length() + JS_ARRAY_LENGTH(postfix)))
53580:         return false;
53580:     JS_ALWAYS_TRUE(cb.append(prefix, JS_ARRAY_LENGTH(prefix)));
53580:     JS_ALWAYS_TRUE(cb.append(source->chars(), source->length()));
53580:     JS_ALWAYS_TRUE(cb.append(postfix, JS_ARRAY_LENGTH(postfix)));
53580: 
53580:     JSString *fakeySource = js_NewStringFromCharBuffer(cx, cb);
53580:     if (!fakeySource)
53580:         return false;
50491:     return compileHelper(cx, *fakeySource);
50491: }
50491: 
50491: inline bool
54576: RegExp::isMetaChar(jschar c)
50491: {
50491:     switch (c) {
50491:       /* Taken from the PatternCharacter production in 15.10.1. */
50491:       case '^': case '$': case '\\': case '.': case '*': case '+':
50491:       case '?': case '(': case ')': case '[': case ']': case '{':
50491:       case '}': case '|':
50491:         return true;
54576:       default:
54576:         return false;
50491:     }
50491: }
54576: 
54576: inline bool
54576: RegExp::hasMetaChars(const jschar *chars, size_t length)
54576: {
54576:     for (size_t i = 0; i < length; ++i) {
54576:         if (isMetaChar(chars[i]))
54576:             return true;
54576:     }
50491:     return false;
50491: }
50491: 
50491: inline uint32
50491: RegExp::flagCount() const
50491: {
50491:     uint32 nflags = 0;
50491:     for (uint32 tmpFlags = flags; tmpFlags != 0; tmpFlags &= tmpFlags - 1)
50491:         nflags++;
50491:     return nflags;
50491: }
50491: 
50491: inline void
50491: RegExp::decref(JSContext *cx)
50491: {
50491:     if (JS_ATOMIC_DECREMENT(&refCount) == 0)
50491:         cx->destroy<RegExp>(this);
50491: }
50491: 
50491: inline RegExp *
50491: RegExp::extractFrom(JSObject *obj)
50491: {
50491:     JS_ASSERT_IF(obj, obj->isRegExp());
50491:     return static_cast<RegExp *>(obj->getPrivate());
50491: }
50491: 
50491: inline RegExp *
50491: RegExp::clone(JSContext *cx, const RegExp &other)
50491: {
50491:     return create(cx, other.source, other.flags);
50491: }
50491: 
50491: /* RegExpStatics inlines. */
50491: 
53858: inline RegExpStatics *
53858: RegExpStatics::extractFrom(JSObject *global)
53858: {
53858:     Value resVal = global->getReservedSlot(JSRESERVED_GLOBAL_REGEXP_STATICS);
53858:     RegExpStatics *res = static_cast<RegExpStatics *>(resVal.toObject().getPrivate());
53858:     return res;
53858: }
53858: 
50491: inline bool
53858: RegExpStatics::createDependent(JSContext *cx, size_t start, size_t end, Value *out) const 
50491: {
50491:     JS_ASSERT(start <= end);
57584:     JS_ASSERT(end <= matchPairsInput->length());
57584:     JSString *str = js_NewDependentString(cx, matchPairsInput, start, end - start);
50491:     if (!str)
50491:         return false;
50491:     *out = StringValue(str);
50491:     return true;
50491: }
50491: 
50491: inline bool
57584: RegExpStatics::createPendingInput(JSContext *cx, Value *out) const
50491: {
57584:     out->setString(pendingInput ? pendingInput : cx->runtime->emptyString);
50491:     return true;
50491: }
50491: 
50491: inline bool
53858: RegExpStatics::makeMatch(JSContext *cx, size_t checkValidIndex, size_t pairNum, Value *out) const
50491: {
50491:     if (checkValidIndex / 2 >= pairCount() || matchPairs[checkValidIndex] < 0) {
55568:         out->setString(cx->runtime->emptyString);
50491:         return true;
50491:     }
53858:     return createDependent(cx, get(pairNum, 0), get(pairNum, 1), out);
50491: }
50491: 
50491: inline bool
53858: RegExpStatics::createLastParen(JSContext *cx, Value *out) const
50491: {
50491:     if (pairCount() <= 1) {
55568:         out->setString(cx->runtime->emptyString);
50491:         return true;
50491:     }
50491:     size_t num = pairCount() - 1;
50491:     int start = get(num, 0);
50491:     int end = get(num, 1);
50491:     if (start == -1) {
55568:         out->setString(cx->runtime->emptyString);
50491:         return true;
50491:     }
50491:     JS_ASSERT(start >= 0 && end >= 0);
58509:     JS_ASSERT(end >= start);
53858:     return createDependent(cx, start, end, out);
50491: }
50491: 
50491: inline bool
53858: RegExpStatics::createLeftContext(JSContext *cx, Value *out) const
50491: {
50491:     if (!pairCount()) {
55568:         out->setString(cx->runtime->emptyString);
50491:         return true;
50491:     }
50491:     if (matchPairs[0] < 0) {
50491:         *out = UndefinedValue();
50491:         return true;
50491:     }
53858:     return createDependent(cx, 0, matchPairs[0], out);
50491: }
50491: 
50491: inline bool
53858: RegExpStatics::createRightContext(JSContext *cx, Value *out) const
50491: {
50491:     if (!pairCount()) {
55568:         out->setString(cx->runtime->emptyString);
50491:         return true;
50491:     }
50491:     if (matchPairs[1] < 0) {
50491:         *out = UndefinedValue();
50491:         return true;
50491:     }
57584:     return createDependent(cx, matchPairs[1], matchPairsInput->length(), out);
50491: }
50491: 
50491: inline void
58510: RegExpStatics::getParen(size_t pairNum, JSSubString *out) const
50491: {
58510:     checkParenNum(pairNum);
58509:     if (!pairIsPresent(pairNum)) {
58509:         *out = js_EmptySubString;
58509:         return;
58509:     }
58509:     out->chars = matchPairsInput->chars() + getCrash(pairNum, 0);
58510:     out->length = getParenLength(pairNum);
50491: }
50491: 
50491: inline void
50491: RegExpStatics::getLastMatch(JSSubString *out) const
50491: {
57585:     if (!pairCountCrash()) {
50491:         *out = js_EmptySubString;
50491:         return;
50491:     }
57585:     JS_CRASH_UNLESS(matchPairsInput);
57585:     out->chars = matchPairsInput->chars() + getCrash(0, 0);
57585:     JS_CRASH_UNLESS(getCrash(0, 1) >= getCrash(0, 0));
50491:     out->length = get(0, 1) - get(0, 0);
50491: }
50491: 
50491: inline void
50491: RegExpStatics::getLastParen(JSSubString *out) const
50491: {
58510:     size_t pairCount = pairCountCrash();
58510:     /* Note: the first pair is the whole match. */
58510:     if (pairCount <= 1) {
50491:         *out = js_EmptySubString;
50491:         return;
50491:     }
58510:     getParen(pairCount - 1, out);
50491: }
50491: 
50491: inline void
50491: RegExpStatics::getLeftContext(JSSubString *out) const
50491: {
57585:     if (!pairCountCrash()) {
50491:         *out = js_EmptySubString;
50491:         return;
50491:     }
57584:     out->chars = matchPairsInput->chars();
57585:     out->length = getCrash(0, 0);
50491: }
50491: 
50491: inline void
50491: RegExpStatics::getRightContext(JSSubString *out) const
50491: {
57585:     if (!pairCountCrash()) {
50491:         *out = js_EmptySubString;
50491:         return;
50491:     }
57585:     out->chars = matchPairsInput->chars() + getCrash(0, 1);
57585:     JS_CRASH_UNLESS(get(0, 1) <= int(matchPairsInput->length()));
57584:     out->length = matchPairsInput->length() - get(0, 1);
50491: }
50491: 
50491: }
50491: 
50491: #endif /* jsregexpinlines_h___ */
