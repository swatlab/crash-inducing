29366: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*-
25100:  * vim: set ts=8 sw=4 et tw=79:
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code, released
    1:  * March 31, 1998.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * JS object implementation.
    1:  */
    1: #include <stdlib.h>
    1: #include <string.h>
    1: #include "jstypes.h"
26316: #include "jsstdint.h"
55477: #include "jsarena.h"
    1: #include "jsbit.h"
55477: #include "jsutil.h"
55477: #include "jshash.h"
    1: #include "jsdhash.h"
    1: #include "jsprf.h"
    1: #include "jsapi.h"
    1: #include "jsarray.h"
    1: #include "jsatom.h"
    1: #include "jsbool.h"
20408: #include "jsbuiltins.h"
    1: #include "jscntxt.h"
18863: #include "jsversion.h"
 8444: #include "jsemit.h"
    1: #include "jsfun.h"
    1: #include "jsgc.h"
68933: #include "jsgcmark.h"
    1: #include "jsinterp.h"
43281: #include "jsiter.h"
    1: #include "jslock.h"
    1: #include "jsnum.h"
    1: #include "jsobj.h"
67934: #include "jsonparser.h"
    1: #include "jsopcode.h"
 8444: #include "jsparse.h"
42733: #include "jsproxy.h"
    1: #include "jsscope.h"
    1: #include "jsscript.h"
24499: #include "jsstaticcheck.h"
33160: #include "jsstdint.h"
    1: #include "jsstr.h"
24499: #include "jstracer.h"
25215: #include "jsdbgapi.h"
51457: #include "json.h"
58714: #include "jswrapper.h"
    1: 
53840: #include "jsinterpinlines.h"
34349: #include "jsscopeinlines.h"
34349: #include "jsscriptinlines.h"
40858: #include "jsobjinlines.h"
34349: 
69242: #include "vm/StringObject-inl.h"
69242: 
    1: #if JS_HAS_GENERATORS
    1: #include "jsiter.h"
    1: #endif
    1: 
    1: #if JS_HAS_XML_SUPPORT
    1: #include "jsxml.h"
    1: #endif
    1: 
    1: #if JS_HAS_XDR
    1: #include "jsxdrapi.h"
    1: #endif
    1: 
53555: #include "jsprobes.h"
30283: #include "jsatominlines.h"
35117: #include "jsobjinlines.h"
32737: #include "jsscriptinlines.h"
30283: 
15453: #include "jsautooplen.h"
15453: 
37741: using namespace js;
54707: using namespace js::gc;
37741: 
68935: JS_FRIEND_DATA(js::Shape) Shape::sharedNonNative(SHAPELESS);
    1: 
48470: Class js_ObjectClass = {
    1:     js_Object_str,
53557:     JSCLASS_HAS_CACHED_PROTO(JSProto_Object),
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub
    1: };
    1: 
48622: JS_FRIEND_API(JSObject *)
48622: js_ObjectToOuterObject(JSContext *cx, JSObject *obj)
48622: {
48622:     OBJ_TO_OUTER_OBJECT(cx, obj);
48622:     return obj;
48622: }
48622: 
    1: #if JS_HAS_OBJ_PROTO_PROP
    1: 
    1: static JSBool
48470: obj_getProto(JSContext *cx, JSObject *obj, jsid id, Value *vp);
    1: 
    1: static JSBool
62395: obj_setProto(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp);
    1: 
    1: static JSPropertySpec object_props[] = {
48470:     {js_proto_str, 0, JSPROP_PERMANENT|JSPROP_SHARED, Jsvalify(obj_getProto), Jsvalify(obj_setProto)},
    1:     {0,0,0,0,0}
    1: };
    1: 
    1: static JSBool
48470: obj_getProto(JSContext *cx, JSObject *obj, jsid id, Value *vp)
41968: {
47455:     /* Let CheckAccess get the slot's value, based on the access mode. */
    1:     uintN attrs;
41968:     id = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
50518:     return CheckAccess(cx, obj, id, JSACC_PROTO, vp, &attrs);
    1: }
    1: 
    1: static JSBool
62395: obj_setProto(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
48470: {
54563:     /* ECMAScript 5 8.6.2 forbids changing [[Prototype]] if not [[Extensible]]. */
54563:     if (!obj->isExtensible()) {
54587:         obj->reportNotExtensible(cx);
54563:         return false;
54563:     }
54563: 
48470:     if (!vp->isObjectOrNull())
    1:         return JS_TRUE;
41968: 
48470:     JSObject *pobj = vp->toObjectOrNull();
    1:     if (pobj) {
    1:         /*
    1:          * Innerize pobj here to avoid sticking unwanted properties on the
    1:          * outer object. This ensures that any with statements only grant
    1:          * access to the inner object.
    1:          */
    1:         OBJ_TO_INNER_OBJECT(cx, pobj);
    1:         if (!pobj)
    1:             return JS_FALSE;
    1:     }
41968: 
41968:     uintN attrs;
41968:     id = ATOM_TO_JSID(cx->runtime->atomState.protoAtom);
50518:     if (!CheckAccess(cx, obj, id, JSAccessMode(JSACC_PROTO|JSACC_WRITE), vp, &attrs))
41968:         return JS_FALSE;
41968: 
47465:     return SetProto(cx, obj, pobj, JS_TRUE);
    1: }
    1: 
    1: #else  /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
    1: #define object_props NULL
    1: 
    1: #endif /* !JS_HAS_OBJ_PROTO_PROP */
    1: 
18907: static JSHashNumber
    1: js_hash_object(const void *key)
    1: {
48470:     return JSHashNumber(uintptr_t(key) >> JS_GCTHING_ALIGN);
    1: }
    1: 
    1: static JSHashEntry *
    1: MarkSharpObjects(JSContext *cx, JSObject *obj, JSIdArray **idap)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSHashTable *table;
    1:     JSHashNumber hash;
    1:     JSHashEntry **hep, *he;
    1:     jsatomid sharpid;
    1:     JSIdArray *ida;
    1:     JSBool ok;
    1:     jsint i, length;
    1:     jsid id;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
11139: 
11139:     JS_CHECK_RECURSION(cx, return NULL);
    1: 
    1:     map = &cx->sharpObjectMap;
23915:     JS_ASSERT(map->depth >= 1);
    1:     table = map->table;
    1:     hash = js_hash_object(obj);
    1:     hep = JS_HashTableRawLookup(table, hash, obj);
    1:     he = *hep;
    1:     if (!he) {
    1:         sharpid = 0;
40292:         he = JS_HashTableRawAdd(table, hep, hash, obj, (void *) sharpid);
    1:         if (!he) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1: 
    1:         ida = JS_Enumerate(cx, obj);
    1:         if (!ida)
    1:             return NULL;
    1: 
    1:         ok = JS_TRUE;
    1:         for (i = 0, length = ida->length; i < length; i++) {
    1:             id = ida->vector[i];
31501:             ok = obj->lookupProperty(cx, id, &obj2, &prop);
    1:             if (!ok)
    1:                 break;
    1:             if (!prop)
    1:                 continue;
42834:             bool hasGetter, hasSetter;
48470:             AutoValueRooter v(cx);
48470:             AutoValueRooter setter(cx);
43202:             if (obj2->isNative()) {
52503:                 const Shape *shape = (Shape *) prop;
52503:                 hasGetter = shape->hasGetterValue();
52503:                 hasSetter = shape->hasSetterValue();
42834:                 if (hasGetter)
52503:                     v.set(shape->getterValue());
42834:                 if (hasSetter)
52503:                     setter.set(shape->setterValue());
42834:             } else {
42834:                 hasGetter = hasSetter = false;
42834:             }
42834:             if (hasSetter) {
    1:                 /* Mark the getter, then set val to setter. */
48470:                 if (hasGetter && v.value().isObject()) {
48470:                     ok = !!MarkSharpObjects(cx, &v.value().toObject(), NULL);
    1:                     if (!ok)
    1:                         break;
42834:                 }
42834:                 v.set(setter.value());
42834:             } else if (!hasGetter) {
42834:                 ok = obj->getProperty(cx, id, v.addr());
42834:                 if (!ok)
42834:                     break;
42834:             }
48470:             if (v.value().isObject() &&
48470:                 !MarkSharpObjects(cx, &v.value().toObject(), NULL)) {
    1:                 ok = JS_FALSE;
    1:                 break;
    1:             }
    1:         }
    1:         if (!ok || !idap)
    1:             JS_DestroyIdArray(cx, ida);
    1:         if (!ok)
    1:             return NULL;
    1:     } else {
40292:         sharpid = uintptr_t(he->value);
    1:         if (sharpid == 0) {
    1:             sharpid = ++map->sharpgen << SHARP_ID_SHIFT;
40292:             he->value = (void *) sharpid;
    1:         }
    1:         ida = NULL;
    1:     }
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: }
    1: 
    1: JSHashEntry *
    1: js_EnterSharpObject(JSContext *cx, JSObject *obj, JSIdArray **idap,
    1:                     jschar **sp)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSHashTable *table;
    1:     JSIdArray *ida;
    1:     JSHashNumber hash;
    1:     JSHashEntry *he, **hep;
    1:     jsatomid sharpid;
    1:     char buf[20];
    1:     size_t len;
    1: 
25087:     if (!JS_CHECK_OPERATION_LIMIT(cx))
    1:         return NULL;
    1: 
    1:     /* Set to null in case we return an early error. */
    1:     *sp = NULL;
    1:     map = &cx->sharpObjectMap;
    1:     table = map->table;
    1:     if (!table) {
    1:         table = JS_NewHashTable(8, js_hash_object, JS_CompareValues,
    1:                                 JS_CompareValues, NULL, NULL);
    1:         if (!table) {
    1:             JS_ReportOutOfMemory(cx);
    1:             return NULL;
    1:         }
    1:         map->table = table;
    1:         JS_KEEP_ATOMS(cx->runtime);
    1:     }
    1: 
    1:     /* From this point the control must flow either through out: or bad:. */
    1:     ida = NULL;
    1:     if (map->depth == 0) {
23915:         /*
23915:          * Although MarkSharpObjects tries to avoid invoking getters,
23915:          * it ends up doing so anyway under some circumstances; for
23915:          * example, if a wrapped object has getters, the wrapper will
23915:          * prevent MarkSharpObjects from recognizing them as such.
23915:          * This could lead to js_LeaveSharpObject being called while
23915:          * MarkSharpObjects is still working.
23915:          *
23915:          * Increment map->depth while we call MarkSharpObjects, to
23915:          * ensure that such a call doesn't free the hash table we're
23915:          * still using.
23915:          */
23915:         ++map->depth;
    1:         he = MarkSharpObjects(cx, obj, &ida);
23915:         --map->depth;
    1:         if (!he)
    1:             goto bad;
40292:         JS_ASSERT((uintptr_t(he->value) & SHARP_BIT) == 0);
    1:         if (!idap) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             ida = NULL;
    1:         }
    1:     } else {
    1:         hash = js_hash_object(obj);
    1:         hep = JS_HashTableRawLookup(table, hash, obj);
    1:         he = *hep;
    1: 
    1:         /*
    1:          * It's possible that the value of a property has changed from the
    1:          * first time the object's properties are traversed (when the property
    1:          * ids are entered into the hash table) to the second (when they are
31501:          * converted to strings), i.e., the JSObject::getProperty() call is not
    1:          * idempotent.
    1:          */
    1:         if (!he) {
    1:             he = JS_HashTableRawAdd(table, hep, hash, obj, NULL);
    1:             if (!he) {
    1:                 JS_ReportOutOfMemory(cx);
    1:                 goto bad;
    1:             }
    1:             sharpid = 0;
    1:             goto out;
    1:         }
    1:     }
    1: 
40292:     sharpid = uintptr_t(he->value);
    1:     if (sharpid != 0) {
    1:         len = JS_snprintf(buf, sizeof buf, "#%u%c",
    1:                           sharpid >> SHARP_ID_SHIFT,
    1:                           (sharpid & SHARP_BIT) ? '#' : '=');
71337:         *sp = InflateString(cx, buf, &len);
    1:         if (!*sp) {
    1:             if (ida)
    1:                 JS_DestroyIdArray(cx, ida);
    1:             goto bad;
    1:         }
    1:     }
    1: 
    1: out:
    1:     JS_ASSERT(he);
    1:     if ((sharpid & SHARP_BIT) == 0) {
    1:         if (idap && !ida) {
    1:             ida = JS_Enumerate(cx, obj);
    1:             if (!ida) {
    1:                 if (*sp) {
64560:                     cx->free_(*sp);
    1:                     *sp = NULL;
    1:                 }
    1:                 goto bad;
    1:             }
    1:         }
    1:         map->depth++;
    1:     }
    1: 
    1:     if (idap)
    1:         *idap = ida;
    1:     return he;
    1: 
    1: bad:
    1:     /* Clean up the sharpObjectMap table on outermost error. */
    1:     if (map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     return NULL;
    1: }
    1: 
    1: void
    1: js_LeaveSharpObject(JSContext *cx, JSIdArray **idap)
    1: {
    1:     JSSharpObjectMap *map;
    1:     JSIdArray *ida;
    1: 
    1:     map = &cx->sharpObjectMap;
    1:     JS_ASSERT(map->depth > 0);
    1:     if (--map->depth == 0) {
    1:         JS_UNKEEP_ATOMS(cx->runtime);
    1:         map->sharpgen = 0;
    1:         JS_HashTableDestroy(map->table);
    1:         map->table = NULL;
    1:     }
    1:     if (idap) {
    1:         ida = *idap;
    1:         if (ida) {
    1:             JS_DestroyIdArray(cx, ida);
    1:             *idap = NULL;
    1:         }
    1:     }
    1: }
    1: 
18907: static intN
    1: gc_sharp_table_entry_marker(JSHashEntry *he, intN i, void *arg)
    1: {
54707:     MarkObject((JSTracer *)arg, *(JSObject *)he->key, "sharp table entry");
    1:     return JS_DHASH_NEXT;
    1: }
    1: 
    1: void
  583: js_TraceSharpMap(JSTracer *trc, JSSharpObjectMap *map)
    1: {
    1:     JS_ASSERT(map->depth > 0);
    1:     JS_ASSERT(map->table);
    1: 
    1:     /*
    1:      * During recursive calls to MarkSharpObjects a non-native object or
    1:      * object with a custom getProperty method can potentially return an
    1:      * unrooted value or even cut from the object graph an argument of one of
    1:      * MarkSharpObjects recursive invocations. So we must protect map->table
    1:      * entries against GC.
    1:      *
    1:      * We can not simply use JSTempValueRooter to mark the obj argument of
    1:      * MarkSharpObjects during recursion as we have to protect *all* entries
    1:      * in JSSharpObjectMap including those that contains otherwise unreachable
    1:      * objects just allocated through custom getProperty. Otherwise newer
    1:      * allocations can re-use the address of an object stored in the hashtable
    1:      * confusing js_EnterSharpObject. So to address the problem we simply
    1:      * mark all objects from map->table.
    1:      *
    1:      * An alternative "proper" solution is to use JSTempValueRooter in
    1:      * MarkSharpObjects with code to remove during finalization entries
    1:      * with otherwise unreachable objects. But this is way too complex
    1:      * to justify spending efforts.
    1:      */
  583:     JS_HashTableEnumerateEntries(map->table, gc_sharp_table_entry_marker, trc);
    1: }
    1: 
    1: #if JS_HAS_TOSOURCE
 4127: static JSBool
48470: obj_toSource(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     JSBool ok;
    1:     JSHashEntry *he;
    1:     JSIdArray *ida;
    1:     jschar *chars, *ochars, *vsharp;
    1:     const jschar *idstrchars, *vchars;
    1:     size_t nchars, idstrlength, gsoplength, vlength, vsharplength, curlen;
16069:     const char *comma;
    1:     JSObject *obj2;
    1:     JSProperty *prop;
48470:     Value *val;
    1:     JSString *gsop[2];
59890:     JSString *valstr, *str;
59890:     JSLinearString *idstr;
11139: 
11139:     JS_CHECK_RECURSION(cx, return JS_FALSE);
    1: 
48470:     Value localroot[4];
48470:     PodArrayZero(localroot);
40388:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(localroot), localroot);
    1: 
    1:     /* If outermost, we need parentheses to be an expression, not a block. */
61734:     JSBool outermost = (cx->sharpObjectMap.depth == 0);
61734: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     if (!(he = js_EnterSharpObject(cx, obj, &ida, &chars))) {
 6917:         ok = JS_FALSE;
 6917:         goto out;
 6917:     }
69323:     if (!ida) {
    1:         /*
    1:          * We didn't enter -- obj is already "sharp", meaning we've visited it
    1:          * already in our depth first search, and therefore chars contains a
    1:          * string of the form "#n#".
    1:          */
69323:         JS_ASSERT(IS_SHARP(he));
    1: #if JS_HAS_SHARP_VARS
    1:         nchars = js_strlen(chars);
    1: #else
    1:         chars[0] = '{';
    1:         chars[1] = '}';
    1:         chars[2] = 0;
    1:         nchars = 2;
    1: #endif
    1:         goto make_string;
    1:     }
69323:     JS_ASSERT(!IS_SHARP(he));
    1:     ok = JS_TRUE;
    1: 
    1:     if (!chars) {
    1:         /* If outermost, allocate 4 + 1 for "({})" and the terminator. */
64560:         chars = (jschar *) cx->malloc_(((outermost ? 4 : 2) + 1) * sizeof(jschar));
    1:         nchars = 0;
    1:         if (!chars)
    1:             goto error;
    1:         if (outermost)
    1:             chars[nchars++] = '(';
    1:     } else {
    1:         /* js_EnterSharpObject returned a string of the form "#n=" in chars. */
    1:         MAKE_SHARP(he);
    1:         nchars = js_strlen(chars);
    1:         chars = (jschar *)
64560:             cx->realloc_((ochars = chars), (nchars + 2 + 1) * sizeof(jschar));
    1:         if (!chars) {
64560:             Foreground::free_(ochars);
    1:             goto error;
    1:         }
    1:         if (outermost) {
    1:             /*
    1:              * No need for parentheses around the whole shebang, because #n=
    1:              * unambiguously begins an object initializer, and never a block
    1:              * statement.
    1:              */
    1:             outermost = JS_FALSE;
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '{';
    1: 
    1:     comma = NULL;
    1: 
    1:     /*
    1:      * We have four local roots for cooked and raw value GC safety.  Hoist the
 6917:      * "localroot + 2" out of the loop using the val local, which refers to
 6917:      * the raw (unconverted, "uncooked") values.
    1:      */
 6917:     val = localroot + 2;
    1: 
40855:     for (jsint i = 0, length = ida->length; i < length; i++) {
 4127:         /* Get strings for id and value and GC-root them via vp. */
40855:         jsid id = ida->vector[i];
40855: 
31501:         ok = obj->lookupProperty(cx, id, &obj2, &prop);
    1:         if (!ok)
    1:             goto error;
  969: 
  969:         /*
48470:          * Convert id to a value and then to a string.  Decide early whether we
  969:          * prefer get/set or old getter/setter syntax.
  969:          */
59890:         JSString *s = js_ValueToString(cx, IdToValue(id));
59890:         if (!s || !(idstr = s->ensureLinear(cx))) {
  969:             ok = JS_FALSE;
  969:             goto error;
  969:         }
48470:         vp->setString(idstr);                           /* local root */
40855: 
40855:         jsint valcnt = 0;
    1:         if (prop) {
43183:             bool doGet = true;
43202:             if (obj2->isNative()) {
52503:                 const Shape *shape = (Shape *) prop;
52503:                 unsigned attrs = shape->attributes();
    1:                 if (attrs & JSPROP_GETTER) {
43183:                     doGet = false;
52503:                     val[valcnt] = shape->getterValue();
64345:                     gsop[valcnt] = cx->runtime->atomState.getAtom;
 1677:                     valcnt++;
    1:                 }
    1:                 if (attrs & JSPROP_SETTER) {
43183:                     doGet = false;
52503:                     val[valcnt] = shape->setterValue();
64345:                     gsop[valcnt] = cx->runtime->atomState.setAtom;
    1:                     valcnt++;
 1677:                 }
43183:             }
43183:             if (doGet) {
    1:                 valcnt = 1;
    1:                 gsop[0] = NULL;
31501:                 ok = obj->getProperty(cx, id, &val[0]);
    1:                 if (!ok)
    1:                     goto error;
43183:             }
43183:         }
    1: 
    1:         /*
40855:          * If id is a string that's not an identifier, or if it's a negative
40855:          * integer, then it must be quoted.
    1:          */
59890:         bool idIsLexicalIdentifier = js_IsIdentifier(idstr);
 4529:         if (JSID_IS_ATOM(id)
  969:             ? !idIsLexicalIdentifier
 4529:             : (!JSID_IS_INT(id) || JSID_TO_INT(id) < 0)) {
59890:             s = js_QuoteString(cx, idstr, jschar('\''));
59890:             if (!s || !(idstr = s->ensureLinear(cx))) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
48470:             vp->setString(idstr);                       /* local root */
    1:         }
59890:         idstrlength = idstr->length();
59890:         idstrchars = idstr->getChars(cx);
59890:         if (!idstrchars) {
59890:             ok = JS_FALSE;
59890:             goto error;
59890:         }
    1: 
40855:         for (jsint j = 0; j < valcnt; j++) {
40855:             /*
40855:              * Censor an accessor descriptor getter or setter part if it's
40855:              * undefined.
40855:              */
48470:             if (gsop[j] && val[j].isUndefined())
40855:                 continue;
40855: 
    1:             /* Convert val[j] to its canonical source form. */
    1:             valstr = js_ValueToSource(cx, val[j]);
    1:             if (!valstr) {
    1:                 ok = JS_FALSE;
    1:                 goto error;
    1:             }
48470:             localroot[j].setString(valstr);             /* local root */
59890:             vchars = valstr->getChars(cx);
59890:             if (!vchars) {
59890:                 ok = JS_FALSE;
59890:                 goto error;
59890:             }
59890:             vlength = valstr->length();
    1: 
40855:             /*
40855:              * If val[j] is a non-sharp object, and we're not serializing an
40855:              * accessor (ECMA syntax can't accommodate sharpened accessors),
40855:              * consider sharpening it.
40855:              */
    1:             vsharp = NULL;
    1:             vsharplength = 0;
    1: #if JS_HAS_SHARP_VARS
48470:             if (!gsop[j] && val[j].isObject() && vchars[0] != '#') {
48470:                 he = js_EnterSharpObject(cx, &val[j].toObject(), NULL, &vsharp);
    1:                 if (!he) {
    1:                     ok = JS_FALSE;
    1:                     goto error;
    1:                 }
    1:                 if (IS_SHARP(he)) {
    1:                     vchars = vsharp;
    1:                     vlength = js_strlen(vchars);
    1:                 } else {
    1:                     if (vsharp) {
    1:                         vsharplength = js_strlen(vsharp);
    1:                         MAKE_SHARP(he);
    1:                     }
    1:                     js_LeaveSharpObject(cx, NULL);
    1:                 }
    1:             }
    1: #endif
    1: 
 2149:             /*
 2149:              * Remove '(function ' from the beginning of valstr and ')' from the
 2149:              * end so that we can put "get" in front of the function definition.
 2149:              */
48470:             if (gsop[j] && IsFunctionObject(val[j])) {
 2149:                 const jschar *start = vchars;
 2149:                 const jschar *end = vchars + vlength;
 2149: 
 2149:                 uint8 parenChomp = 0;
 2149:                 if (vchars[0] == '(') {
 2149:                     vchars++;
 2149:                     parenChomp = 1;
 2149:                 }
 2149: 
 2149:                 /* Try to jump "function" keyword. */
 2149:                 if (vchars)
 2149:                     vchars = js_strchr_limit(vchars, ' ', end);
 2149: 
40855:                 /*
40855:                  * Jump over the function's name: it can't be encoded as part
40855:                  * of an ECMA getter or setter.
40855:                  */
40855:                 if (vchars)
40855:                     vchars = js_strchr_limit(vchars, '(', end);
40855: 
 2149:                 if (vchars) {
 2149:                     if (*vchars == ' ')
 2149:                         vchars++;
 2149:                     vlength = end - vchars - parenChomp;
 2149:                 } else {
 2149:                     gsop[j] = NULL;
 2149:                     vchars = start;
 2149:                 }
 2149:             }
 2149: 
    1: #define SAFE_ADD(n)                                                          \
    1:     JS_BEGIN_MACRO                                                           \
    1:         size_t n_ = (n);                                                     \
    1:         curlen += n_;                                                        \
    1:         if (curlen < n_)                                                     \
    1:             goto overflow;                                                   \
    1:     JS_END_MACRO
    1: 
    1:             curlen = nchars;
    1:             if (comma)
    1:                 SAFE_ADD(2);
    1:             SAFE_ADD(idstrlength + 1);
    1:             if (gsop[j])
29366:                 SAFE_ADD(gsop[j]->length() + 1);
    1:             SAFE_ADD(vsharplength);
    1:             SAFE_ADD(vlength);
    1:             /* Account for the trailing null. */
    1:             SAFE_ADD((outermost ? 2 : 1) + 1);
    1: #undef SAFE_ADD
    1: 
40855:             if (curlen > size_t(-1) / sizeof(jschar))
    1:                 goto overflow;
    1: 
    1:             /* Allocate 1 + 1 at end for closing brace and terminating 0. */
64560:             chars = (jschar *) cx->realloc_((ochars = chars), curlen * sizeof(jschar));
    1:             if (!chars) {
59890:                 chars = ochars;
59890:                 goto overflow;
    1:             }
    1: 
    1:             if (comma) {
    1:                 chars[nchars++] = comma[0];
    1:                 chars[nchars++] = comma[1];
    1:             }
    1:             comma = ", ";
    1: 
    1:             if (gsop[j]) {
29366:                 gsoplength = gsop[j]->length();
59890:                 const jschar *gsopchars = gsop[j]->getChars(cx);
59890:                 if (!gsopchars)
59890:                     goto overflow;
59890:                 js_strncpy(&chars[nchars], gsopchars, gsoplength);
    1:                 nchars += gsoplength;
    1:                 chars[nchars++] = ' ';
    1:             }
    1:             js_strncpy(&chars[nchars], idstrchars, idstrlength);
    1:             nchars += idstrlength;
  969:             /* Extraneous space after id here will be extracted later */
    1:             chars[nchars++] = gsop[j] ? ' ' : ':';
 1490: 
    1:             if (vsharplength) {
    1:                 js_strncpy(&chars[nchars], vsharp, vsharplength);
    1:                 nchars += vsharplength;
    1:             }
    1:             js_strncpy(&chars[nchars], vchars, vlength);
    1:             nchars += vlength;
    1: 
    1:             if (vsharp)
64560:                 cx->free_(vsharp);
    1:         }
    1:     }
    1: 
    1:     chars[nchars++] = '}';
    1:     if (outermost)
    1:         chars[nchars++] = ')';
    1:     chars[nchars] = 0;
    1: 
    1:   error:
    1:     js_LeaveSharpObject(cx, &ida);
    1: 
    1:     if (!ok) {
    1:         if (chars)
64560:             Foreground::free_(chars);
 6917:         goto out;
    1:     }
    1: 
    1:     if (!chars) {
    1:         JS_ReportOutOfMemory(cx);
 6917:         ok = JS_FALSE;
 6917:         goto out;
    1:     }
    1:   make_string:
 4718:     str = js_NewString(cx, chars, nchars);
    1:     if (!str) {
64560:         cx->free_(chars);
 6917:         ok = JS_FALSE;
 6917:         goto out;
    1:     }
48470:     vp->setString(str);
 6917:     ok = JS_TRUE;
 6917:   out:
 6917:     return ok;
    1: 
    1:   overflow:
64560:     cx->free_(vsharp);
64560:     cx->free_(chars);
    1:     chars = NULL;
    1:     goto error;
    1: }
    1: #endif /* JS_HAS_TOSOURCE */
    1: 
47498: namespace js {
47498: 
47498: JSString *
47498: obj_toStringHelper(JSContext *cx, JSObject *obj)
47498: {
47498:     if (obj->isProxy())
47498:         return JSProxy::obj_toString(cx, obj);
47498: 
56565:     const char *clazz = obj->getClass()->name;
47498:     size_t nchars = 9 + strlen(clazz); /* 9 for "[object ]" */
64560:     jschar *chars = (jschar *) cx->malloc_((nchars + 1) * sizeof(jschar));
    1:     if (!chars)
47498:         return NULL;
47498: 
47498:     const char *prefix = "[object ";
    1:     nchars = 0;
    1:     while ((chars[nchars] = (jschar)*prefix) != 0)
    1:         nchars++, prefix++;
    1:     while ((chars[nchars] = (jschar)*clazz) != 0)
    1:         nchars++, clazz++;
    1:     chars[nchars++] = ']';
    1:     chars[nchars] = 0;
    1: 
47498:     JSString *str = js_NewString(cx, chars, nchars);
47498:     if (!str)
64560:         cx->free_(chars);
47498:     return str;
47498: }
47498: 
68911: JSObject *
68911: NonNullObject(JSContext *cx, const Value &v)
68911: {
68911:     if (v.isPrimitive()) {
68911:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
68911:         return NULL;
68911:     }
68911:     return &v.toObject();
68911: }
68911: 
47498: }
47498: 
55714: /* ES5 15.2.4.2.  Note steps 1 and 2 are errata. */
47498: static JSBool
48470: obj_toString(JSContext *cx, uintN argc, Value *vp)
48470: {
55714:     Value &thisv = vp[1];
55714: 
61734:     /* Step 1. */
55714:     if (thisv.isUndefined()) {
64345:         vp->setString(cx->runtime->atomState.objectUndefinedAtom);
55714:         return true;
55714:     }
55714: 
61734:     /* Step 2. */
55714:     if (thisv.isNull()) {
64345:         vp->setString(cx->runtime->atomState.objectNullAtom);
55714:         return true;
55714:     }
55714: 
61734:     /* Step 3. */
61734:     JSObject *obj = ToObject(cx, &thisv);
61734:     if (!obj)
47498:         return false;
47498: 
61734:     /* Steps 4-5. */
61734:     JSString *str = js::obj_toStringHelper(cx, obj);
47498:     if (!str)
47498:         return false;
48470:     vp->setString(str);
47498:     return true;
    1: }
    1: 
69828: /* ES5 15.2.4.3. */
    1: static JSBool
48470: obj_toLocaleString(JSContext *cx, uintN argc, Value *vp)
48470: {
69828:     JS_CHECK_RECURSION(cx, return false);
69828: 
69828:     /* Step 1. */
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
69828:     /* Steps 2-4. */
69828:     return obj->callMethod(cx, ATOM_TO_JSID(cx->runtime->atomState.toStringAtom), 0, NULL, vp);
    1: }
    1: 
    1: static JSBool
48470: obj_valueOf(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734:     vp->setObject(*obj);
61734:     return true;
    1: }
    1: 
68932: /* We should be able to assert this for *any* fp->scopeChain(). */
68894: static void
68932: AssertInnerizedScopeChain(JSContext *cx, JSObject &scopeobj)
68894: {
68894: #ifdef DEBUG
68894:     for (JSObject *o = &scopeobj; o; o = o->getParent()) {
68894:         if (JSObjectOp op = o->getClass()->ext.innerObject)
68932:             JS_ASSERT(op(cx, o) == o);
68894:     }
68894: #endif
12690: }
12690: 
24375: #ifndef EVAL_CACHE_CHAIN_LIMIT
24375: # define EVAL_CACHE_CHAIN_LIMIT 4
24375: #endif
24375: 
24375: static inline JSScript **
59890: EvalCacheHash(JSContext *cx, JSLinearString *str)
59890: {
59890:     const jschar *s = str->chars();
59890:     size_t n = str->length();
59890: 
24375:     if (n > 100)
24375:         n = 100;
59890:     uint32 h;
24375:     for (h = 0; n; s++, n--)
24375:         h = JS_ROTATE_LEFT32(h, 4) ^ *s;
24375: 
24375:     h *= JS_GOLDEN_RATIO;
24375:     h >>= 32 - JS_EVAL_CACHE_SHIFT;
24375:     return &JS_SCRIPTS_TO_GC(cx)[h];
24375: }
24375: 
55553: static JS_ALWAYS_INLINE JSScript *
69223: EvalCacheLookup(JSContext *cx, JSLinearString *str, StackFrame *caller, uintN staticLevel,
68893:                 JSPrincipals *principals, JSObject &scopeobj, JSScript **bucket)
55553: {
73723:     if (!principals)
73723:         return NULL;
73723: 
55553:     /*
55553:      * Cache local eval scripts indexed by source qualified by scope.
55553:      *
55553:      * An eval cache entry should never be considered a hit unless its
55553:      * strictness matches that of the new eval code. The existing code takes
55553:      * care of this, because hits are qualified by the function from which
59939:      * eval was called, whose strictness doesn't change. (We don't cache evals
59939:      * in eval code, so the calling function corresponds to the calling script,
59939:      * and its strictness never varies.) Scripts produced by calls to eval from
59939:      * global code aren't cached.
59939:      *
59939:      * FIXME bug 620141: Qualify hits by calling script rather than function.
59939:      * Then we wouldn't need the unintuitive !isEvalFrame() hack in EvalKernel
59939:      * to avoid caching nested evals in functions (thus potentially mismatching
59939:      * on strict mode), and we could cache evals in global code if desired.
55553:      */
55553:     uintN count = 0;
55553:     JSScript **scriptp = bucket;
55553: 
55553:     JSVersion version = cx->findVersion();
55553:     JSScript *script;
55553:     while ((script = *scriptp) != NULL) {
55553:         if (script->savedCallerFun &&
55553:             script->staticLevel == staticLevel &&
61450:             script->getVersion() == version &&
59962:             !script->hasSingletons &&
55553:             (script->principals == principals ||
73723:              (script->principals &&
73723:               principals->subsume(principals, script->principals) &&
55553:               script->principals->subsume(script->principals, principals)))) {
55553:             /*
55553:              * Get the prior (cache-filling) eval's saved caller function.
55553:              * See Compiler::compileScript in jsparse.cpp.
55553:              */
55553:             JSFunction *fun = script->getFunction(0);
55553: 
55553:             if (fun == caller->fun()) {
55553:                 /*
55553:                  * Get the source string passed for safekeeping in the
55553:                  * atom map by the prior eval to Compiler::compileScript.
55553:                  */
59890:                 JSAtom *src = script->atomMap.vector[0];
59890: 
59890:                 if (src == str || EqualStrings(src, str)) {
55553:                     /*
55553:                      * Source matches, qualify by comparing scopeobj to the
55553:                      * COMPILE_N_GO-memoized parent of the first literal
55553:                      * function or regexp object if any. If none, then this
55553:                      * script has no compiled-in dependencies on the prior
55553:                      * eval's scopeobj.
55553:                      */
55553:                     JSObjectArray *objarray = script->objects();
55553:                     int i = 1;
55553: 
55553:                     if (objarray->length == 1) {
59221:                         if (JSScript::isValidOffset(script->regexpsOffset)) {
55553:                             objarray = script->regexps();
55553:                             i = 0;
55553:                         } else {
55553:                             i = -1;
55553:                         }
55553:                     }
55553:                     if (i < 0 ||
68893:                         objarray->vector[i]->getParent() == &scopeobj) {
55553:                         JS_ASSERT(staticLevel == script->staticLevel);
55553:                         *scriptp = script->u.nextToGC;
55553:                         script->u.nextToGC = NULL;
55553:                         return script;
55553:                     }
55553:                 }
55553:             }
55553:         }
55553: 
55553:         if (++count == EVAL_CACHE_CHAIN_LIMIT)
55553:             return NULL;
55553:         scriptp = &script->u.nextToGC;
55553:     }
55553:     return NULL;
55553: }
55553: 
56775: /*
68894:  * There are two things we want to do with each script executed in EvalKernel:
68894:  *  1. notify jsdbgapi about script creation/destruction
68894:  *  2. add the script to the eval cache when EvalKernel is finished
68894:  *
68894:  * NB: Although the eval cache keeps a script alive wrt to the JS engine, from
68894:  * a jsdbgapi user's perspective, we want each eval() to create and destroy a
68894:  * script. This hides implementation details and means we don't have to deal
68894:  * with calls to JS_GetScriptObject for scripts in the eval cache (currently,
68894:  * script->u.object aliases script->u.nextToGC).
56775:  */
68894: class EvalScriptGuard
68894: {
68894:     JSContext *cx_;
68894:     JSLinearString *str_;
68894:     JSScript **bucket_;
68894:     JSScript *script_;
68894: 
68894:   public:
68894:     EvalScriptGuard(JSContext *cx, JSLinearString *str)
68894:       : cx_(cx),
68894:         str_(str),
68894:         script_(NULL) {
68894:         bucket_ = EvalCacheHash(cx, str);
68894:     }
68894: 
68894:     ~EvalScriptGuard() {
68894:         if (script_) {
68894:             js_CallDestroyScriptHook(cx_, script_);
68894:             script_->u.nextToGC = *bucket_;
68894:             *bucket_ = script_;
68894: #ifdef CHECK_SCRIPT_OWNER
68894:             script_->owner = NULL;
68894: #endif
68894:         }
68894:     }
68894: 
69223:     void lookupInEvalCache(StackFrame *caller, uintN staticLevel,
68894:                            JSPrincipals *principals, JSObject &scopeobj) {
68894:         if (JSScript *found = EvalCacheLookup(cx_, str_, caller, staticLevel,
68894:                                               principals, scopeobj, bucket_)) {
68894:             js_CallNewScriptHook(cx_, found, NULL);
68894:             script_ = found;
68894:         }
68894:     }
68894: 
68894:     void setNewScript(JSScript *script) {
68894:         /* NewScriptFromCG has already called js_CallNewScriptHook. */
68894:         JS_ASSERT(!script_ && script);
68894:         script_ = script;
68894:     }
68894: 
68894:     bool foundScript() {
68894:         return !!script_;
68894:     }
68894: 
68894:     JSScript *script() const {
68894:         JS_ASSERT(script_);
68894:         return script_;
68894:     }
68894: };
68894: 
71695: /* Define subset of ExecuteType so that casting performs the injection. */
71695: enum EvalType { DIRECT_EVAL = EXECUTE_DIRECT_EVAL, INDIRECT_EVAL = EXECUTE_INDIRECT_EVAL };
71695: 
68894: /*
68894:  * Common code implementing direct and indirect eval.
68894:  *
68894:  * Evaluate call.argv[2], if it is a string, in the context of the given calling
68894:  * frame, with the provided scope chain, with the semantics of either a direct
68894:  * or indirect eval (see ES5 10.4.2).  If this is an indirect eval, scopeobj
68894:  * must be a global object.
68894:  *
68894:  * On success, store the completion value in call.rval and return true.
68894:  */
68894: static bool
69223: EvalKernel(JSContext *cx, const CallArgs &call, EvalType evalType, StackFrame *caller,
68893:            JSObject &scopeobj)
56775: {
68894:     JS_ASSERT((evalType == INDIRECT_EVAL) == (caller == NULL));
68932:     AssertInnerizedScopeChain(cx, scopeobj);
55549: 
72056:     if (!scopeobj.getGlobal()->isRuntimeCodeGenEnabled(cx)) {
39061:         JS_ReportError(cx, "call to eval() blocked by CSP");
55553:         return false;
39061:     }
39061: 
56775:     /* ES5 15.1.2.1 step 1. */
68894:     if (call.argc() < 1) {
68894:         call.rval().setUndefined();
56775:         return true;
56775:     }
68894:     if (!call[0].isString()) {
68894:         call.rval() = call[0];
56775:         return true;
56775:     }
68894:     JSString *str = call[0].toString();
56775: 
56775:     /* ES5 15.1.2.1 steps 2-8. */
56775: 
56775:     /*
56775:      * Per ES5, indirect eval runs in the global scope. (eval is specified this
56775:      * way so that the compiler can make assumptions about what bindings may or
56775:      * may not exist in the current frame if it doesn't see 'eval'.)
56775:      */
56775:     uintN staticLevel;
71695:     Value thisv;
56775:     if (evalType == DIRECT_EVAL) {
56775:         staticLevel = caller->script()->staticLevel + 1;
56775: 
71695:         /*
71695:          * Direct calls to eval are supposed to see the caller's |this|. If we
71695:          * haven't wrapped that yet, do so now, before we make a copy of it for
71695:          * the eval code to use.
71695:          */
71695:         if (!ComputeThis(cx, caller))
71695:             return false;
71695:         thisv = caller->thisValue();
71695: 
56775: #ifdef DEBUG
71363:         jsbytecode *callerPC = caller->pcQuadratic(cx);
64364:         JS_ASSERT_IF(caller->isFunctionFrame(), caller->fun()->isHeavyweight());
56775:         JS_ASSERT(callerPC && js_GetOpcode(cx, caller->script(), callerPC) == JSOP_EVAL);
56775: #endif
56775:     } else {
68894:         JS_ASSERT(call.callee().getGlobal() == &scopeobj);
56775:         staticLevel = 0;
71695: 
71695:         /* Use the global as 'this', modulo outerization. */
71695:         JSObject *thisobj = scopeobj.thisObject(cx);
71695:         if (!thisobj)
71695:             return false;
71695:         thisv = ObjectValue(*thisobj);
68894:     }
55532: 
59890:     JSLinearString *linearStr = str->ensureLinear(cx);
59890:     if (!linearStr)
59890:         return false;
59890:     const jschar *chars = linearStr->chars();
59890:     size_t length = linearStr->length();
51457: 
51457:     /*
51457:      * If the eval string starts with '(' and ends with ')', it may be JSON.
51457:      * Try the JSON parser first because it's much faster.  If the eval string
51457:      * isn't JSON, JSON parsing will probably fail quickly, so little time
51457:      * will be lost.
70299:      *
70299:      * Don't use the JSON parser if the caller is strict mode code, because in
70299:      * strict mode object literals must not have repeated properties, and the
70299:      * JSON parser cheerfully (and correctly) accepts them.  If you're parsing
70299:      * JSON with eval and using strict mode, you deserve to be slow.
51457:      */
70299:     if (length > 2 &&
70299:         chars[0] == '(' && chars[length - 1] == ')' &&
70299:         (!caller || !caller->script()->strictModeCode))
70299:     {
71691:         /*
71691:          * Remarkably, JavaScript syntax is not a superset of JSON syntax:
71691:          * strings in JavaScript cannot contain the Unicode line and paragraph
71691:          * terminator characters U+2028 and U+2029, but strings in JSON can.
71691:          * Rather than force the JSON parser to handle this quirk when used by
71691:          * eval, we simply don't use the JSON parser when either character
71691:          * appears in the provided string.  See bug 657367.
71691:          */
71691:         for (const jschar *cp = &chars[1], *end = &chars[length - 2]; ; cp++) {
71691:             if (*cp == 0x2028 || *cp == 0x2029)
71691:                 break;
71691: 
71691:             if (cp == end) {
71691:                 JSONParser parser(cx, chars + 1, length - 2,
71691:                                   JSONParser::StrictJSON, JSONParser::NoError);
68894:                 Value tmp;
68894:                 if (!parser.parse(&tmp))
68894:                     return false;
71691:                 if (tmp.isUndefined())
71691:                     break;
68894:                 call.rval() = tmp;
67934:                 return true;
68894:             }
55553:         }
71691:     }
55553: 
68894:     EvalScriptGuard esg(cx, linearStr);
68894: 
68894:     JSPrincipals *principals = PrincipalsForCompiledCode(call, cx);
68894: 
68894:     if (evalType == DIRECT_EVAL && caller->isNonEvalFunctionFrame())
68894:         esg.lookupInEvalCache(caller, staticLevel, principals, scopeobj);
68894: 
68894:     if (!esg.foundScript()) {
68894:         uintN lineno;
68894:         const char *filename = CurrentScriptFileAndLine(cx, &lineno,
68894:                                                         evalType == DIRECT_EVAL
68894:                                                         ? CALLED_FROM_JSOP_EVAL
68894:                                                         : NOT_CALLED_FROM_JSOP_EVAL);
68894:         uint32 tcflags = TCF_COMPILE_N_GO | TCF_NEED_MUTABLE_SCRIPT | TCF_COMPILE_FOR_EVAL;
68894:         JSScript *compiled = Compiler::compileScript(cx, &scopeobj, caller, principals, tcflags,
68894:                                                      chars, length, filename, lineno,
68894:                                                      cx->findVersion(), linearStr, staticLevel);
68894:         if (!compiled)
68894:             return false;
68894: 
68894:         esg.setNewScript(compiled);
68894:     }
68894: 
71695:     return Execute(cx, esg.script(), scopeobj, thisv, ExecuteType(evalType),
71695:                    NULL /* evalInFrame */, &call.rval());
68894: }
24375: 
33281: /*
68894:  * We once supported a second argument to eval to use as the scope chain
68894:  * when evaluating the code string.  Warn when such uses are seen so that
68894:  * authors will know that support for eval(s, o) has been removed.
62571:  */
68894: static inline bool
68894: WarnOnTooManyArgs(JSContext *cx, const CallArgs &call)
68894: {
68894:     if (call.argc() > 1) {
69223:         if (StackFrame *caller = js_GetScriptedCaller(cx, NULL)) {
68894:             if (!caller->script()->warnedAboutTwoArgumentEval) {
68894:                 static const char TWO_ARGUMENT_WARNING[] =
68894:                     "Support for eval(code, scopeObject) has been removed. "
68894:                     "Use |with (scopeObject) eval(code);| instead.";
68894:                 if (!JS_ReportWarning(cx, TWO_ARGUMENT_WARNING))
68894:                     return false;
68894:                 caller->script()->warnedAboutTwoArgumentEval = true;
68894:             }
68894:         } else {
62571:             /*
68894:              * In the case of an indirect call without a caller frame, avoid a
68894:              * potential warning-flood by doing nothing.
33281:              */
68894:         }
68894:     }
68894: 
68894:     return true;
68894: }
55482: 
    1: /*
68894:  * ES5 15.1.2.1.
68894:  *
68894:  * NB: This method handles only indirect eval.
    1:  */
68894: static JSBool
68894: eval(JSContext *cx, uintN argc, Value *vp)
68894: {
68894:     CallArgs call = CallArgsFromVp(argc, vp);
68894:     return WarnOnTooManyArgs(cx, call) &&
68894:            EvalKernel(cx, call, INDIRECT_EVAL, NULL, *call.callee().getGlobal());
68894: }
68894: 
68894: namespace js {
68894: 
68894: bool
68894: DirectEval(JSContext *cx, const CallArgs &call)
68894: {
68894:     /* Direct eval can assume it was called from an interpreted frame. */
69223:     StackFrame *caller = cx->fp();
68894:     JS_ASSERT(caller->isScriptFrame());
68894:     JS_ASSERT(IsBuiltinEvalForScope(&caller->scopeChain(), call.calleev()));
71339:     JS_ASSERT(js_GetOpcode(cx, cx->fp()->script(), cx->regs().pc) == JSOP_EVAL);
68894: 
68894:     AutoFunctionCallProbe callProbe(cx, call.callee().getFunctionPrivate(), caller->script());
68894: 
68894:     JSObject *scopeChain =
68894:         GetScopeChainFast(cx, caller, JSOP_EVAL, JSOP_EVAL_LENGTH + JSOP_LINENO_LENGTH);
68894: 
68894:     return scopeChain &&
68894:            WarnOnTooManyArgs(cx, call) &&
68894:            EvalKernel(cx, call, DIRECT_EVAL, caller, *scopeChain);
    1: }
    1: 
64210: bool
64228: IsBuiltinEvalForScope(JSObject *scopeChain, const Value &v)
64228: {
68955:     return scopeChain->getGlobal()->getOriginalEval() == v;
64228: }
64228: 
64228: bool
64228: IsAnyBuiltinEval(JSFunction *fun)
56556: {
56556:     return fun->maybeNative() == eval;
56556: }
56556: 
68894: JSPrincipals *
68894: PrincipalsForCompiledCode(const CallArgs &call, JSContext *cx)
68894: {
68894:     JS_ASSERT(IsAnyBuiltinEval(call.callee().getFunctionPrivate()) ||
68894:               IsBuiltinFunctionConstructor(call.callee().getFunctionPrivate()));
68894: 
68894:     /*
68894:      * To compute the principals of the compiled eval/Function code, we simply
68894:      * use the callee's principals. To see why the caller's principals are
68894:      * ignored, consider first that, in the capability-model we assume, the
68894:      * high-privileged eval/Function should never have escaped to the
68894:      * low-privileged caller. (For the Mozilla embedding, this is brute-enforced
68894:      * by explicit filtering by wrappers.) Thus, the caller's privileges should
68894:      * subsume the callee's.
68894:      *
68894:      * In the converse situation, where the callee has lower privileges than the
68894:      * caller, we might initially guess that the caller would want to retain
68894:      * their higher privileges in the generated code. However, since the
68894:      * compiled code will be run with the callee's scope chain, this would make
68894:      * fp->script()->compartment() != fp->compartment().
68894:      */
68894: 
71362:     return call.callee().principals(cx);
68894: }
68894: 
68894: }  /* namespace js */
56556: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: 
    1: static JSBool
48470: obj_watch_handler(JSContext *cx, JSObject *obj, jsid id, jsval old,
48470:                   jsval *nvp, void *closure)
    1: {
64302:     JSObject *callable = (JSObject *) closure;
68894:     if (JSPrincipals *watcher = callable->principals(cx)) {
69223:         if (StackFrame *caller = js_GetScriptedCaller(cx, NULL)) {
69223:             if (JSPrincipals *subject = caller->scopeChain().principals(cx)) {
68894:                 if (!watcher->subsume(watcher, subject)) {
    1:                     /* Silently don't call the watch handler. */
68894:                     return JS_TRUE;
68894:                 }
    1:             }
    1:         }
    1:     }
    1: 
    1:     /* Avoid recursion on (obj, id) already being watched on cx. */
64302:     AutoResolving resolving(cx, obj, id, AutoResolving::WATCH);
64302:     if (resolving.alreadyStarted())
64302:         return true;
64302: 
64302:     Value argv[] = { IdToValue(id), Valueify(old), Valueify(*nvp) };
64302:     return ExternalInvoke(cx, ObjectValue(*obj), ObjectOrNullValue(callable),
64302:                           JS_ARRAY_LENGTH(argv), argv, Valueify(nvp));
    1: }
    1: 
    1: static JSBool
48470: obj_watch(JSContext *cx, uintN argc, Value *vp)
48470: {
16519:     if (argc <= 1) {
48470:         js_ReportMissingArg(cx, *vp, 1);
50518:         return JS_FALSE;
16519:     }
16519: 
48470:     JSObject *callable = js_ValueToCallableObject(cx, &vp[3], 0);
    1:     if (!callable)
50518:         return JS_FALSE;
    1: 
    1:     /* Compute the unique int/atom symbol id needed by js_LookupProperty. */
48470:     jsid propid;
48470:     if (!ValueToId(cx, vp[2], &propid))
50518:         return JS_FALSE;
    1: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
48470:     Value tmp;
48470:     uintN attrs;
61734:     if (!CheckAccess(cx, obj, propid, JSACC_WATCH, &tmp, &attrs))
50518:         return JS_FALSE;
40878: 
48470:     vp->setUndefined();
40878: 
    1:     if (attrs & JSPROP_READONLY)
50518:         return JS_TRUE;
43287:     if (obj->isDenseArray() && !obj->makeDenseArraySlow(cx))
50518:         return JS_FALSE;
48470:     return JS_SetWatchPoint(cx, obj, propid, obj_watch_handler, callable);
    1: }
    1: 
    1: static JSBool
48470: obj_unwatch(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
11809:     if (!obj)
61734:         return false;
48470:     vp->setUndefined();
48470:     jsid id;
48470:     if (argc != 0) {
48470:         if (!ValueToId(cx, vp[2], &id))
48470:             return JS_FALSE;
48470:     } else {
48470:         id = JSID_VOID;
48470:     }
48470:     return JS_ClearWatchPoint(cx, obj, id, NULL, NULL);
    1: }
    1: 
    1: #endif /* JS_HAS_OBJ_WATCHPOINT */
    1: 
    1: /*
    1:  * Prototype and property query methods, to complement the 'in' and
    1:  * 'instanceof' operators.
    1:  */
    1: 
    1: /* Proposed ECMA 15.2.4.5. */
20408: static JSBool
48470: obj_hasOwnProperty(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734:     return js_HasOwnPropertyHelper(cx, obj->getOps()->lookupProperty, argc, vp);
    1: }
    1: 
    1: JSBool
54746: js_HasOwnPropertyHelper(JSContext *cx, LookupPropOp lookup, uintN argc,
48470:                         Value *vp)
    1: {
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
    1:         return JS_FALSE;
32721: 
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
36991:     JSObject *obj2;
36991:     JSProperty *prop;
42733:     if (obj->isProxy()) {
42733:         bool has;
42733:         if (!JSProxy::hasOwn(cx, obj, id, &has))
42733:             return false;
48470:         vp->setBoolean(has);
42733:         return true;
42733:     }
42733:     if (!js_HasOwnProperty(cx, lookup, obj, id, &obj2, &prop))
36991:         return JS_FALSE;
56568:     vp->setBoolean(!!prop);
32721:     return JS_TRUE;
18062: }
18062: 
18062: JSBool
54746: js_HasOwnProperty(JSContext *cx, LookupPropOp lookup, JSObject *obj, jsid id,
36991:                   JSObject **objp, JSProperty **propp)
36991: {
43285:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING);
48622:     if (!(lookup ? lookup : js_LookupProperty)(cx, obj, id, objp, propp))
40327:         return false;
36991:     if (!*propp)
40327:         return true;
36991: 
36991:     if (*objp == obj)
40327:         return true;
36991: 
48622:     JSObject *outer = NULL;
48622:     if (JSObjectOp op = (*objp)->getClass()->ext.outerObject) {
48622:         outer = op(cx, *objp);
 4780:         if (!outer)
40327:             return false;
40327:     }
40327: 
72069:     if (outer != *objp)
36991:         *propp = NULL;
40327:     return true;
    1: }
    1: 
61734: /* ES5 15.2.4.6. */
    1: static JSBool
48470: obj_isPrototypeOf(JSContext *cx, uintN argc, Value *vp)
48470: {
61734:     /* Step 1. */
61734:     if (argc < 1 || !vp[2].isObject()) {
61734:         vp->setBoolean(false);
61734:         return true;
61734:     }
61734: 
61734:     /* Step 2. */
61734:     JSObject *obj = ToObject(cx, &vp[1]);
40880:     if (!obj)
61734:         return false;
61734: 
61734:     /* Step 3. */
61734:     vp->setBoolean(js_IsDelegate(cx, obj, vp[2]));
61734:     return true;
61734: }
61734: 
61734: /* ES5 15.2.4.7. */
20408: static JSBool
48470: obj_propertyIsEnumerable(JSContext *cx, uintN argc, Value *vp)
    1: {
61734:     /* Step 1. */
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
61734:         return false;
61734: 
61734:     /* Step 2. */
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return false;
61734: 
61734:     /* Steps 3-5. */
61734:     return js_PropertyIsEnumerable(cx, obj, id, vp);
18062: }
18062: 
18062: JSBool
48470: js_PropertyIsEnumerable(JSContext *cx, JSObject *obj, jsid id, Value *vp)
18062: {
18062:     JSObject *pobj;
    1:     JSProperty *prop;
31501:     if (!obj->lookupProperty(cx, id, &pobj, &prop))
72089:         return false;
    1: 
    1:     if (!prop) {
48470:         vp->setBoolean(false);
72089:         return true;
    1:     }
    1: 
    1:     /*
72089:      * ECMA spec botch: return false unless hasOwnProperty. Leaving "own" out
72089:      * of propertyIsEnumerable's name was a mistake.
    1:      */
72089:     if (pobj != obj) {
48470:         vp->setBoolean(false);
43290:         return true;
43290:     }
72089: 
72089:     uintN attrs;
72089:     if (!pobj->getAttributes(cx, id, &attrs))
72089:         return false;
72089: 
48470:     vp->setBoolean((attrs & JSPROP_ENUMERATE) != 0);
43290:     return true;
    1: }
    1: 
40855: #if OLD_GETTER_SETTER_METHODS
40855: 
40855: const char js_defineGetter_str[] = "__defineGetter__";
40855: const char js_defineSetter_str[] = "__defineSetter__";
40855: const char js_lookupGetter_str[] = "__lookupGetter__";
40855: const char js_lookupSetter_str[] = "__lookupSetter__";
40855: 
24145: JS_FRIEND_API(JSBool)
48470: js_obj_defineGetter(JSContext *cx, uintN argc, Value *vp)
48470: {
68904:     CallArgs call = CallArgsFromVp(argc, vp);
68904:     if (!BoxNonStrictThis(cx, call))
68904:         return false;
68904:     JSObject *obj = &call.thisv().toObject();
68904: 
68904:     if (argc <= 1 || !js_IsCallable(call[1])) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_GETTER_OR_SETTER,
    1:                              js_getter_str);
    1:         return JS_FALSE;
    1:     }
68904:     PropertyOp getter = CastAsPropertyOp(&call[1].toObject());
48470: 
48470:     jsid id;
68904:     if (!ValueToId(cx, call[0], &id))
    1:         return JS_FALSE;
62411:     if (!CheckRedeclaration(cx, obj, id, JSPROP_GETTER))
    1:         return JS_FALSE;
50518:     /*
50518:      * Getters and setters are just like watchpoints from an access
50518:      * control point of view.
50518:      */
48470:     Value junk;
48470:     uintN attrs;
50518:     if (!CheckAccess(cx, obj, id, JSACC_WATCH, &junk, &attrs))
    1:         return JS_FALSE;
68904:     call.rval().setUndefined();
62395:     return obj->defineProperty(cx, id, UndefinedValue(), getter, StrictPropertyStub,
32573:                                JSPROP_ENUMERATE | JSPROP_GETTER | JSPROP_SHARED);
    1: }
    1: 
24145: JS_FRIEND_API(JSBool)
48470: js_obj_defineSetter(JSContext *cx, uintN argc, Value *vp)
48470: {
68904:     CallArgs call = CallArgsFromVp(argc, vp);
68904:     if (!BoxNonStrictThis(cx, call))
68904:         return false;
68904:     JSObject *obj = &call.thisv().toObject();
68904: 
68904:     if (argc <= 1 || !js_IsCallable(call[1])) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_BAD_GETTER_OR_SETTER,
    1:                              js_setter_str);
    1:         return JS_FALSE;
    1:     }
68904:     StrictPropertyOp setter = CastAsStrictPropertyOp(&call[1].toObject());
48470: 
48470:     jsid id;
68904:     if (!ValueToId(cx, call[0], &id))
    1:         return JS_FALSE;
62411:     if (!CheckRedeclaration(cx, obj, id, JSPROP_SETTER))
    1:         return JS_FALSE;
50518:     /*
50518:      * Getters and setters are just like watchpoints from an access
50518:      * control point of view.
50518:      */
48470:     Value junk;
48470:     uintN attrs;
50518:     if (!CheckAccess(cx, obj, id, JSACC_WATCH, &junk, &attrs))
    1:         return JS_FALSE;
68904:     call.rval().setUndefined();
48470:     return obj->defineProperty(cx, id, UndefinedValue(), PropertyStub, setter,
32573:                                JSPROP_ENUMERATE | JSPROP_SETTER | JSPROP_SHARED);
    1: }
    1: 
    1: static JSBool
48470: obj_lookupGetter(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
48470:         return JS_FALSE;
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return JS_FALSE;
48470:     JSObject *pobj;
    1:     JSProperty *prop;
61734:     if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
48470:     vp->setUndefined();
    1:     if (prop) {
40430:         if (pobj->isNative()) {
52503:             Shape *shape = (Shape *) prop;
52503:             if (shape->hasGetterValue())
52503:                 *vp = shape->getterValue();
43290:         }
    1:     }
    1:     return JS_TRUE;
    1: }
    1: 
    1: static JSBool
48470: obj_lookupSetter(JSContext *cx, uintN argc, Value *vp)
    1: {
    1:     jsid id;
48470:     if (!ValueToId(cx, argc != 0 ? vp[2] : UndefinedValue(), &id))
48470:         return JS_FALSE;
61734:     JSObject *obj = ToObject(cx, &vp[1]);
61734:     if (!obj)
61734:         return JS_FALSE;
48470:     JSObject *pobj;
    1:     JSProperty *prop;
61734:     if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:         return JS_FALSE;
48470:     vp->setUndefined();
    1:     if (prop) {
40430:         if (pobj->isNative()) {
52503:             Shape *shape = (Shape *) prop;
52503:             if (shape->hasSetterValue())
52503:                 *vp = shape->setterValue();
43290:         }
    1:     }
    1:     return JS_TRUE;
    1: }
40855: #endif /* OLD_GETTER_SETTER_METHODS */
    1: 
16380: JSBool
48470: obj_getPrototypeOf(JSContext *cx, uintN argc, Value *vp)
48470: {
16519:     if (argc == 0) {
48470:         js_ReportMissingArg(cx, *vp, 0);
16519:         return JS_FALSE;
16519:     }
16519: 
48470:     if (vp[2].isPrimitive()) {
50457:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, vp[2], NULL);
31844:         if (!bytes)
16380:             return JS_FALSE;
31844:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
31844:                              JSMSG_UNEXPECTED_TYPE, bytes, "not an object");
31844:         JS_free(cx, bytes);
31844:         return JS_FALSE;
31844:     }
31844: 
48470:     JSObject *obj = &vp[2].toObject();
48470:     uintN attrs;
50518:     return CheckAccess(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.protoAtom),
16380:                        JSACC_PROTO, vp, &attrs);
16380: }
16380: 
42733: extern JSBool
48470: js_NewPropertyDescriptorObject(JSContext *cx, jsid id, uintN attrs,
48470:                                const Value &getter, const Value &setter,
48470:                                const Value &value, Value *vp)
42733: {
42733:     /* We have our own property, so start creating the descriptor. */
47497:     JSObject *desc = NewBuiltinClassInstance(cx, &js_ObjectClass);
42733:     if (!desc)
42733:         return false;
48470:     vp->setObject(*desc);    /* Root and return. */
42733: 
42733:     const JSAtomState &atomState = cx->runtime->atomState;
42733:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
42733:         if (!desc->defineProperty(cx, ATOM_TO_JSID(atomState.getAtom), getter,
62395:                                   PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE) ||
42733:             !desc->defineProperty(cx, ATOM_TO_JSID(atomState.setAtom), setter,
62395:                                   PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE)) {
42733:             return false;
42733:         }
42733:     } else {
42733:         if (!desc->defineProperty(cx, ATOM_TO_JSID(atomState.valueAtom), value,
62395:                                   PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE) ||
42733:             !desc->defineProperty(cx, ATOM_TO_JSID(atomState.writableAtom),
48470:                                   BooleanValue((attrs & JSPROP_READONLY) == 0),
62395:                                   PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE)) {
42733:             return false;
42733:         }
42733:     }
42733: 
42733:     return desc->defineProperty(cx, ATOM_TO_JSID(atomState.enumerableAtom),
48470:                                 BooleanValue((attrs & JSPROP_ENUMERATE) != 0),
62395:                                 PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE) &&
42733:            desc->defineProperty(cx, ATOM_TO_JSID(atomState.configurableAtom),
48470:                                 BooleanValue((attrs & JSPROP_PERMANENT) == 0),
62395:                                 PropertyStub, StrictPropertyStub, JSPROP_ENUMERATE);
42733: }
42733: 
40356: JSBool
48470: js_GetOwnPropertyDescriptor(JSContext *cx, JSObject *obj, jsid id, Value *vp)
40356: {
56606:     if (obj->isProxy())
56606:         return JSProxy::getOwnPropertyDescriptor(cx, obj, id, false, vp);
42733: 
36991:     JSObject *pobj;
36991:     JSProperty *prop;
48622:     if (!js_HasOwnProperty(cx, obj->getOps()->lookupProperty, obj, id, &pobj, &prop))
40356:         return false;
36991:     if (!prop) {
48470:         vp->setUndefined();
40356:         return true;
32721:     }
32721: 
48470:     Value roots[] = { UndefinedValue(), UndefinedValue(), UndefinedValue() };
40221:     AutoArrayRooter tvr(cx, JS_ARRAY_LENGTH(roots), roots);
43290:     unsigned attrs;
43290:     bool doGet = true;
43290:     if (pobj->isNative()) {
52503:         Shape *shape = (Shape *) prop;
52503:         attrs = shape->attributes();
35098:         if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
43290:             doGet = false;
35098:             if (attrs & JSPROP_GETTER)
52503:                 roots[0] = shape->getterValue();
35098:             if (attrs & JSPROP_SETTER)
52503:                 roots[1] = shape->setterValue();
35098:         }
54713:     } else {
54713:         if (!pobj->getAttributes(cx, id, &attrs))
40356:             return false;
35098:     }
35098: 
43290:     if (doGet && !obj->getProperty(cx, id, &roots[2]))
43290:         return false;
43290: 
42733:     return js_NewPropertyDescriptorObject(cx, id,
42733:                                           attrs,
42733:                                           roots[0], /* getter */
42733:                                           roots[1], /* setter */
42733:                                           roots[2], /* value */
42733:                                           vp);
32721: }
32721: 
47569: static bool
48470: GetFirstArgumentAsObject(JSContext *cx, uintN argc, Value *vp, const char *method, JSObject **objp)
47569: {
47569:     if (argc == 0) {
47569:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
47569:                              method, "0", "s");
47569:         return false;
47569:     }
47569: 
48470:     const Value &v = vp[2];
54564:     if (!v.isObject()) {
48470:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, NULL);
47569:         if (!bytes)
47569:             return false;
47569:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
47569:                              bytes, "not an object");
47569:         JS_free(cx, bytes);
47569:         return false;
47569:     }
47569: 
48470:     *objp = &v.toObject();
47569:     return true;
47569: }
47569: 
33155: static JSBool
48470: obj_getOwnPropertyDescriptor(JSContext *cx, uintN argc, Value *vp)
40356: {
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.getOwnPropertyDescriptor", &obj))
47569:         return JS_FALSE;
40388:     AutoIdRooter nameidr(cx);
48470:     if (!ValueToId(cx, argc >= 2 ? vp[3] : UndefinedValue(), nameidr.addr()))
40356:         return JS_FALSE;
40356:     return js_GetOwnPropertyDescriptor(cx, obj, nameidr.id(), vp);
40356: }
40356: 
40356: static JSBool
48470: obj_keys(JSContext *cx, uintN argc, Value *vp)
33155: {
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.keys", &obj))
57759:         return false;
42733: 
48470:     AutoIdVector props(cx);
54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY, &props))
57759:         return false;
33155: 
48470:     AutoValueVector vals(cx);
57759:     if (!vals.reserve(props.length()))
57759:         return false;
48463:     for (size_t i = 0, len = props.length(); i < len; i++) {
48470:         jsid id = props[i];
48470:         if (JSID_IS_STRING(id)) {
57759:             JS_ALWAYS_TRUE(vals.append(StringValue(JSID_TO_STRING(id))));
57759:         } else if (JSID_IS_INT(id)) {
48470:             JSString *str = js_IntToString(cx, JSID_TO_INT(id));
48470:             if (!str)
57759:                 return false;
64229:             vals.infallibleAppend(StringValue(str));
57759:         } else {
57759:             JS_ASSERT(JSID_IS_OBJECT(id));
48470:         }
48463:     }
48463: 
48463:     JS_ASSERT(props.length() <= UINT32_MAX);
59234:     JSObject *aobj = NewDenseCopiedArray(cx, jsuint(vals.length()), vals.begin());
33155:     if (!aobj)
57759:         return false;
48470:     vp->setObject(*aobj);
33155: 
57759:     return true;
33155: }
33155: 
54713: static bool
54713: HasProperty(JSContext* cx, JSObject* obj, jsid id, Value* vp, bool *foundp)
54713: {
54713:     if (!obj->hasProperty(cx, id, foundp, JSRESOLVE_QUALIFIED | JSRESOLVE_DETECTING))
54713:         return false;
54713:     if (!*foundp) {
48470:         vp->setUndefined();
54713:         return true;
54713:     }
54713: 
54713:     /*
54713:      * We must go through the method read barrier in case id is 'get' or 'set'.
54713:      * There is no obvious way to defer cloning a joined function object whose
54713:      * identity will be used by DefinePropertyOnObject, e.g., or reflected via
54713:      * js_GetOwnPropertyDescriptor, as the getter or setter callable object.
54713:      */
54713:     return !!obj->getProperty(cx, id, vp);
48470: }
48470: 
48470: PropDesc::PropDesc()
48470:   : pd(UndefinedValue()),
48470:     value(UndefinedValue()),
48470:     get(UndefinedValue()),
48470:     set(UndefinedValue()),
36991:     attrs(0),
36991:     hasGet(false),
36991:     hasSet(false),
36991:     hasValue(false),
36991:     hasWritable(false),
36991:     hasEnumerable(false),
36991:     hasConfigurable(false)
36991: {
36991: }
36991: 
36991: bool
64250: PropDesc::initialize(JSContext* cx, const Value &origval)
48470: {
48470:     Value v = origval;
36991: 
36991:     /* 8.10.5 step 1 */
48470:     if (v.isPrimitive()) {
37010:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
36991:         return false;
36991:     }
48470:     JSObject* desc = &v.toObject();
36991: 
42733:     /* Make a copy of the descriptor. We might need it later. */
42733:     pd = v;
42733: 
36991:     /* Start with the proper defaults. */
36991:     attrs = JSPROP_PERMANENT | JSPROP_READONLY;
36991: 
54713:     bool found;
36991: 
36991:     /* 8.10.5 step 3 */
60142: #ifdef __GNUC__ /* quell GCC overwarning */
60142:     found = false;
60142: #endif
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.enumerableAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasEnumerable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs |= JSPROP_ENUMERATE;
36991:     }
36991: 
36991:     /* 8.10.5 step 4 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.configurableAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasConfigurable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs &= ~JSPROP_PERMANENT;
36991:     }
36991: 
36991:     /* 8.10.5 step 5 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.valueAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasValue = true;
36991:         value = v;
36991:     }
36991: 
36991:     /* 8.10.6 step 6 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.writableAtom), &v, &found))
36991:         return false;
54713:     if (found) {
36991:         hasWritable = JS_TRUE;
36991:         if (js_ValueToBoolean(v))
36991:             attrs &= ~JSPROP_READONLY;
36991:     }
36991: 
36991:     /* 8.10.7 step 7 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.getAtom), &v, &found))
36991:         return false;
54713:     if (found) {
48470:         if ((v.isPrimitive() || !js_IsCallable(v)) && !v.isUndefined()) {
40831:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GET_SET_FIELD,
36991:                                  js_getter_str);
36991:             return false;
36991:         }
36991:         hasGet = true;
36991:         get = v;
36991:         attrs |= JSPROP_GETTER | JSPROP_SHARED;
36991:     }
36991: 
36991:     /* 8.10.7 step 8 */
54713:     if (!HasProperty(cx, desc, ATOM_TO_JSID(cx->runtime->atomState.setAtom), &v, &found))
36991:         return false;
54713:     if (found) {
48470:         if ((v.isPrimitive() || !js_IsCallable(v)) && !v.isUndefined()) {
40831:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_BAD_GET_SET_FIELD,
36991:                                  js_setter_str);
36991:             return false;
36991:         }
36991:         hasSet = true;
36991:         set = v;
36991:         attrs |= JSPROP_SETTER | JSPROP_SHARED;
36991:     }
36991: 
36991:     /* 8.10.7 step 9 */
36991:     if ((hasGet || hasSet) && (hasValue || hasWritable)) {
36991:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_INVALID_DESCRIPTOR);
36991:         return false;
36991:     }
36991: 
36991:     return true;
36991: }
36991: 
36991: static JSBool
36991: Reject(JSContext *cx, uintN errorNumber, bool throwError, jsid id, bool *rval)
36991: {
36991:     if (throwError) {
36991:         jsid idstr;
48470:         if (!js_ValueToStringId(cx, IdToValue(id), &idstr))
36991:            return JS_FALSE;
57812:         JSAutoByteString bytes(cx, JSID_TO_STRING(idstr));
57812:         if (!bytes)
57812:             return JS_FALSE;
57812:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, errorNumber, bytes.ptr());
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     *rval = false;
36991:     return JS_TRUE;
36991: }
36991: 
36991: static JSBool
54587: Reject(JSContext *cx, JSObject *obj, uintN errorNumber, bool throwError, bool *rval)
36991: {
36991:     if (throwError) {
54587:         if (js_ErrorFormatString[errorNumber].argCount == 1) {
54587:             js_ReportValueErrorFlags(cx, JSREPORT_ERROR, errorNumber,
54587:                                      JSDVG_IGNORE_STACK, ObjectValue(*obj),
54587:                                      NULL, NULL, NULL);
54587:         } else {
54587:             JS_ASSERT(js_ErrorFormatString[errorNumber].argCount == 0);
36991:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, errorNumber);
54587:         }
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     *rval = false;
36991:     return JS_TRUE;
36991: }
36991: 
36991: static JSBool
64250: DefinePropertyOnObject(JSContext *cx, JSObject *obj, const jsid &id, const PropDesc &desc,
36991:                        bool throwError, bool *rval)
36991: {
36991:     /* 8.12.9 step 1. */
36991:     JSProperty *current;
36991:     JSObject *obj2;
48622:     JS_ASSERT(!obj->getOps()->lookupProperty);
64250:     if (!js_HasOwnProperty(cx, NULL, obj, id, &obj2, &current))
36991:         return JS_FALSE;
36991: 
48622:     JS_ASSERT(!obj->getOps()->defineProperty);
36991: 
36991:     /* 8.12.9 steps 2-4. */
36991:     if (!current) {
54563:         if (!obj->isExtensible())
54587:             return Reject(cx, obj, JSMSG_OBJECT_NOT_EXTENSIBLE, throwError, rval);
36991: 
36991:         *rval = true;
36991: 
36991:         if (desc.isGenericDescriptor() || desc.isDataDescriptor()) {
48622:             JS_ASSERT(!obj->getOps()->defineProperty);
64250:             return js_DefineProperty(cx, obj, id, &desc.value,
62395:                                      PropertyStub, StrictPropertyStub, desc.attrs);
36991:         }
36991: 
36991:         JS_ASSERT(desc.isAccessorDescriptor());
36991: 
50518:         /*
50518:          * Getters and setters are just like watchpoints from an access
50518:          * control point of view.
50518:          */
48470:         Value dummy;
36991:         uintN dummyAttrs;
64250:         if (!CheckAccess(cx, obj, id, JSACC_WATCH, &dummy, &dummyAttrs))
36991:             return JS_FALSE;
36991: 
48470:         Value tmp = UndefinedValue();
64250:         return js_DefineProperty(cx, obj, id, &tmp,
41860:                                  desc.getter(), desc.setter(), desc.attrs);
36991:     }
36991: 
36991:     /* 8.12.9 steps 5-6 (note 5 is merely a special case of 6). */
48470:     Value v = UndefinedValue();
36991: 
72089:     JS_ASSERT(obj == obj2);
36991: 
52503:     const Shape *shape = reinterpret_cast<Shape *>(current);
36991:     do {
36991:         if (desc.isAccessorDescriptor()) {
52503:             if (!shape->isAccessorDescriptor())
36991:                 break;
36991: 
59890:             if (desc.hasGet) {
59890:                 JSBool same;
59890:                 if (!SameValue(cx, desc.getterValue(), shape->getterOrUndefined(), &same))
59890:                     return JS_FALSE;
59890:                 if (!same)
36991:                     break;
36991:             }
36991: 
59890:             if (desc.hasSet) {
59890:                 JSBool same;
59890:                 if (!SameValue(cx, desc.setterValue(), shape->setterOrUndefined(), &same))
59890:                     return JS_FALSE;
59890:                 if (!same)
36991:                     break;
36991:             }
36991:         } else {
36991:             /*
36991:              * Determine the current value of the property once, if the current
36991:              * value might actually need to be used or preserved later.  NB: we
36991:              * guard on whether the current property is a data descriptor to
36991:              * avoid calling a getter; we won't need the value if it's not a
36991:              * data descriptor.
36991:              */
52503:             if (shape->isDataDescriptor()) {
36991:                 /*
61685:                  * We must rule out a non-configurable js::PropertyOp-guarded
61685:                  * property becoming a writable unguarded data property, since
61685:                  * such a property can have its value changed to one the getter
61685:                  * and setter preclude.
36991:                  *
61685:                  * A desc lacking writable but with value is a data descriptor
61685:                  * and we must reject it as if it had writable: true if current
61685:                  * is writable.
36991:                  */
52503:                 if (!shape->configurable() &&
61685:                     (!shape->hasDefaultGetter() || !shape->hasDefaultSetter()) &&
61685:                     desc.isDataDescriptor() &&
61685:                     (desc.hasWritable ? desc.writable() : shape->writable()))
61685:                 {
64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
36991:                 }
36991: 
61685:                 if (!js_NativeGet(cx, obj, obj2, shape, JSGET_NO_METHOD_BARRIER, &v))
36991:                     return JS_FALSE;
36991:             }
36991: 
36991:             if (desc.isDataDescriptor()) {
52503:                 if (!shape->isDataDescriptor())
36991:                     break;
36991: 
59890:                 JSBool same;
59890:                 if (desc.hasValue) {
59890:                     if (!SameValue(cx, desc.value, v, &same))
59890:                         return JS_FALSE;
61689:                     if (!same) {
61689:                         /*
61689:                          * Insist that a non-configurable js::PropertyOp data
61689:                          * property is frozen at exactly the last-got value.
61689:                          *
61689:                          * Duplicate the first part of the big conjunction that
61689:                          * we tested above, rather than add a local bool flag.
61689:                          * Likewise, don't try to keep shape->writable() in a
61689:                          * flag we veto from true to false for non-configurable
61689:                          * PropertyOp-based data properties and test before the
61689:                          * SameValue check later on in order to re-use that "if
61689:                          * (!SameValue) Reject" logic.
61689:                          *
61689:                          * This function is large and complex enough that it
61689:                          * seems best to repeat a small bit of code and return
61689:                          * Reject(...) ASAP, instead of being clever.
61689:                          */
61689:                         if (!shape->configurable() &&
61689:                             (!shape->hasDefaultGetter() || !shape->hasDefaultSetter()))
61689:                         {
64250:                             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
61689:                         }
36991:                         break;
59890:                     }
61689:                 }
52503:                 if (desc.hasWritable && desc.writable() != shape->writable())
36991:                     break;
36991:             } else {
36991:                 /* The only fields in desc will be handled below. */
36991:                 JS_ASSERT(desc.isGenericDescriptor());
36991:             }
36991:         }
36991: 
52503:         if (desc.hasConfigurable && desc.configurable() != shape->configurable())
36991:             break;
52503:         if (desc.hasEnumerable && desc.enumerable() != shape->enumerable())
36991:             break;
36991: 
36991:         /* The conditions imposed by step 5 or step 6 apply. */
36991:         *rval = true;
36991:         return JS_TRUE;
36991:     } while (0);
36991: 
36991:     /* 8.12.9 step 7. */
52503:     if (!shape->configurable()) {
36991:         /*
36991:          * Since [[Configurable]] defaults to false, we don't need to check
36991:          * whether it was specified.  We can't do likewise for [[Enumerable]]
36991:          * because its putative value is used in a comparison -- a comparison
36991:          * whose result must always be false per spec if the [[Enumerable]]
36991:          * field is not present.  Perfectly pellucid logic, eh?
36991:          */
36991:         JS_ASSERT_IF(!desc.hasConfigurable, !desc.configurable());
36991:         if (desc.configurable() ||
52503:             (desc.hasEnumerable && desc.enumerable() != shape->enumerable())) {
64250:             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
36991:         }
36991:     }
36991: 
55492:     bool callDelProperty = false;
55492: 
36991:     if (desc.isGenericDescriptor()) {
36991:         /* 8.12.9 step 8, no validation required */
52503:     } else if (desc.isDataDescriptor() != shape->isDataDescriptor()) {
36991:         /* 8.12.9 step 9. */
54587:         if (!shape->configurable())
64250:             return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
41860:     } else if (desc.isDataDescriptor()) {
36991:         /* 8.12.9 step 10. */
52503:         JS_ASSERT(shape->isDataDescriptor());
52503:         if (!shape->configurable() && !shape->writable()) {
59890:             if (desc.hasWritable && desc.writable())
64250:                 return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
59890:             if (desc.hasValue) {
59890:                 JSBool same;
59890:                 if (!SameValue(cx, desc.value, v, &same))
59890:                     return JS_FALSE;
59890:                 if (!same)
64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
36991:             }
36991:         }
55492: 
55492:         callDelProperty = !shape->hasDefaultGetter() || !shape->hasDefaultSetter();
36991:     } else {
36991:         /* 8.12.9 step 11. */
52503:         JS_ASSERT(desc.isAccessorDescriptor() && shape->isAccessorDescriptor());
52503:         if (!shape->configurable()) {
59890:             if (desc.hasSet) {
59890:                 JSBool same;
59890:                 if (!SameValue(cx, desc.setterValue(), shape->setterOrUndefined(), &same))
59890:                     return JS_FALSE;
59890:                 if (!same)
64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
59890:             }
59890: 
59890:             if (desc.hasGet) {
59890:                 JSBool same;
59890:                 if (!SameValue(cx, desc.getterValue(), shape->getterOrUndefined(), &same))
59890:                     return JS_FALSE;
59890:                 if (!same)
64250:                     return Reject(cx, JSMSG_CANT_REDEFINE_PROP, throwError, id, rval);
36991:             }
36991:         }
36991:     }
36991: 
36991:     /* 8.12.9 step 12. */
36991:     uintN attrs;
62395:     PropertyOp getter;
62395:     StrictPropertyOp setter;
36991:     if (desc.isGenericDescriptor()) {
36991:         uintN changed = 0;
36991:         if (desc.hasConfigurable)
36991:             changed |= JSPROP_PERMANENT;
36991:         if (desc.hasEnumerable)
36991:             changed |= JSPROP_ENUMERATE;
36991: 
52503:         attrs = (shape->attributes() & ~changed) | (desc.attrs & changed);
52503:         if (shape->isMethod()) {
42784:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
62395:             getter = PropertyStub;
62395:             setter = StrictPropertyStub;
42784:         } else {
52503:             getter = shape->getter();
52503:             setter = shape->setter();
42784:         }
36991:     } else if (desc.isDataDescriptor()) {
36991:         uintN unchanged = 0;
36991:         if (!desc.hasConfigurable)
36991:             unchanged |= JSPROP_PERMANENT;
36991:         if (!desc.hasEnumerable)
36991:             unchanged |= JSPROP_ENUMERATE;
36991:         if (!desc.hasWritable)
36991:             unchanged |= JSPROP_READONLY;
36991: 
36991:         if (desc.hasValue)
36991:             v = desc.value;
52503:         attrs = (desc.attrs & ~unchanged) | (shape->attributes() & unchanged);
62395:         getter = PropertyStub;
62395:         setter = StrictPropertyStub;
36991:     } else {
36991:         JS_ASSERT(desc.isAccessorDescriptor());
36991: 
50518:         /*
50518:          * Getters and setters are just like watchpoints from an access
50518:          * control point of view.
50518:          */
48470:         Value dummy;
64250:         if (!CheckAccess(cx, obj2, id, JSACC_WATCH, &dummy, &attrs))
36991:              return JS_FALSE;
36991: 
52503:         JS_ASSERT_IF(shape->isMethod(), !(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
48498: 
36991:         /* 8.12.9 step 12. */
36991:         uintN changed = 0;
36991:         if (desc.hasConfigurable)
36991:             changed |= JSPROP_PERMANENT;
36991:         if (desc.hasEnumerable)
36991:             changed |= JSPROP_ENUMERATE;
36991:         if (desc.hasGet)
36991:             changed |= JSPROP_GETTER | JSPROP_SHARED;
36991:         if (desc.hasSet)
36991:             changed |= JSPROP_SETTER | JSPROP_SHARED;
36991: 
52503:         attrs = (desc.attrs & changed) | (shape->attributes() & ~changed);
41860:         if (desc.hasGet) {
41860:             getter = desc.getter();
41860:         } else {
52503:             getter = (shape->isMethod() || (shape->hasDefaultGetter() && !shape->hasGetterValue()))
48470:                      ? PropertyStub
52503:                      : shape->getter();
41860:         }
41860:         if (desc.hasSet) {
41860:             setter = desc.setter();
41860:         } else {
52503:             setter = (shape->hasDefaultSetter() && !shape->hasSetterValue())
62395:                      ? StrictPropertyStub
52503:                      : shape->setter();
41860:         }
36991:     }
36991: 
36991:     *rval = true;
55492: 
55492:     /*
55492:      * Since "data" properties implemented using native C functions may rely on
55492:      * side effects during setting, we must make them aware that they have been
55492:      * "assigned"; deleting the property before redefining it does the trick.
55492:      * See bug 539766, where we ran into problems when we redefined
55492:      * arguments.length without making the property aware that its value had
55492:      * been changed (which would have happened if we had deleted it before
55492:      * redefining it or we had invoked its setter to change its value).
55492:      */
55492:     if (callDelProperty) {
61707:         Value dummy = UndefinedValue();
64250:         if (!CallJSPropertyOp(cx, obj2->getClass()->delProperty, obj2, id, &dummy))
64250:             return false;
64250:     }
64250: 
64250:     return js_DefineProperty(cx, obj, id, &v, getter, setter, attrs);
36991: }
36991: 
36991: static JSBool
64250: DefinePropertyOnArray(JSContext *cx, JSObject *obj, const jsid &id, const PropDesc &desc,
36991:                       bool throwError, bool *rval)
36991: {
36991:     /*
36991:      * We probably should optimize dense array property definitions where
36991:      * the descriptor describes a traditional array property (enumerable,
36991:      * configurable, writable, numeric index or length without altering its
36991:      * attributes).  Such definitions are probably unlikely, so we don't bother
36991:      * for now.
36991:      */
43287:     if (obj->isDenseArray() && !obj->makeDenseArraySlow(cx))
36991:         return JS_FALSE;
36991: 
40796:     jsuint oldLen = obj->getArrayLength();
36991: 
64250:     if (JSID_IS_ATOM(id, cx->runtime->atomState.lengthAtom)) {
36991:         /*
36991:          * Our optimization of storage of the length property of arrays makes
36991:          * it very difficult to properly implement defining the property.  For
36991:          * now simply throw an exception (NB: not merely Reject) on any attempt
36991:          * to define the "length" property, rather than attempting to implement
36991:          * some difficult-for-authors-to-grasp subset of that functionality.
36991:          */
54587:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_DEFINE_ARRAY_LENGTH);
36991:         return JS_FALSE;
36991:     }
36991: 
36991:     uint32 index;
64250:     if (js_IdIsIndex(id, &index)) {
36991:         /*
36991:         // Disabled until we support defining "length":
36991:         if (index >= oldLen && lengthPropertyNotWritable())
54587:             return ThrowTypeError(cx, JSMSG_CANT_APPEND_TO_ARRAY);
36991:          */
64250:         if (!DefinePropertyOnObject(cx, obj, id, desc, false, rval))
36991:             return JS_FALSE;
36991:         if (!*rval)
54587:             return Reject(cx, obj, JSMSG_CANT_DEFINE_ARRAY_INDEX, throwError, rval);
36991: 
36991:         if (index >= oldLen) {
36991:             JS_ASSERT(index != UINT32_MAX);
48537:             obj->setArrayLength(index + 1);
36991:         }
36991: 
36991:         *rval = true;
36991:         return JS_TRUE;
36991:     }
36991: 
64250:     return DefinePropertyOnObject(cx, obj, id, desc, throwError, rval);
36991: }
36991: 
36991: static JSBool
64250: DefineProperty(JSContext *cx, JSObject *obj, const jsid &id, const PropDesc &desc, bool throwError,
36991:                bool *rval)
36991: {
39928:     if (obj->isArray())
64250:         return DefinePropertyOnArray(cx, obj, id, desc, throwError, rval);
36991: 
48622:     if (obj->getOps()->lookupProperty) {
42733:         if (obj->isProxy())
64250:             return JSProxy::defineProperty(cx, obj, id, desc.pd);
54587:         return Reject(cx, obj, JSMSG_OBJECT_NOT_EXTENSIBLE, throwError, rval);
42733:     }
36991: 
64250:     return DefinePropertyOnObject(cx, obj, id, desc, throwError, rval);
36991: }
36991: 
40356: JSBool
64250: js_DefineOwnProperty(JSContext *cx, JSObject *obj, jsid id, const Value &descriptor, JSBool *bp)
48470: {
48470:     AutoPropDescArrayRooter descs(cx);
48470:     PropDesc *desc = descs.append();
64250:     if (!desc || !desc->initialize(cx, descriptor))
40356:         return false;
40356: 
40356:     bool rval;
64250:     if (!DefineProperty(cx, obj, id, *desc, true, &rval))
40356:         return false;
40356:     *bp = !!rval;
40356:     return true;
40356: }
40356: 
36991: /* ES5 15.2.3.6: Object.defineProperty(O, P, Attributes) */
36991: static JSBool
48470: obj_defineProperty(JSContext* cx, uintN argc, Value* vp)
36991: {
36991:     /* 15.2.3.6 steps 1 and 5. */
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.defineProperty", &obj))
36991:         return JS_FALSE;
48470:     vp->setObject(*obj);
36991: 
36991:     /* 15.2.3.6 step 2. */
40221:     AutoIdRooter nameidr(cx);
48470:     if (!ValueToId(cx, argc >= 2 ? vp[3] : UndefinedValue(), nameidr.addr()))
36991:         return JS_FALSE;
36991: 
36991:     /* 15.2.3.6 step 3. */
48470:     const Value &descval = argc >= 3 ? vp[4] : UndefinedValue();
36991: 
36991:     /* 15.2.3.6 step 4 */
40356:     JSBool junk;
40356:     return js_DefineOwnProperty(cx, obj, nameidr.id(), descval, &junk);
36991: }
36991: 
42733: static bool
42733: DefineProperties(JSContext *cx, JSObject *obj, JSObject *props)
42733: {
64250:     AutoIdVector ids(cx);
64250:     if (!GetPropertyNames(cx, props, JSITER_OWNONLY, &ids))
42733:         return false;
36991: 
48470:      AutoPropDescArrayRooter descs(cx);
64250:      size_t len = ids.length();
36991:      for (size_t i = 0; i < len; i++) {
64250:          jsid id = ids[i];
48470:          PropDesc* desc = descs.append();
64250:          Value v;
64250:          if (!desc || !props->getProperty(cx, id, &v) || !desc->initialize(cx, v))
64250:              return false;
42733:      }
42733: 
36991:      bool dummy;
36991:      for (size_t i = 0; i < len; i++) {
64250:          if (!DefineProperty(cx, obj, ids[i], descs[i], true, &dummy))
42733:              return false;
42733:      }
42733: 
42733:      return true;
42733: }
42733: 
42733: extern JSBool
42733: js_PopulateObject(JSContext *cx, JSObject *newborn, JSObject *props)
42733: {
42733:     return DefineProperties(cx, newborn, props);
42733: }
42733: 
42733: /* ES5 15.2.3.7: Object.defineProperties(O, Properties) */
42733: static JSBool
48470: obj_defineProperties(JSContext* cx, uintN argc, Value* vp)
42733: {
64250:     /* Steps 1 and 7. */
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.defineProperties", &obj))
47569:         return false;
48470:     vp->setObject(*obj);
47569: 
64250:     /* Step 2. */
42733:     if (argc < 2) {
42733:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
42733:                              "Object.defineProperties", "0", "s");
42733:         return false;
42733:     }
64250:     JSObject* props = ToObject(cx, &vp[3]);
42733:     if (!props)
42733:         return false;
64250: 
64250:     /* Steps 3-6. */
42733:     return DefineProperties(cx, obj, props);
36991: }
36991: 
37000: /* ES5 15.2.3.5: Object.create(O [, Properties]) */
37000: static JSBool
48470: obj_create(JSContext *cx, uintN argc, Value *vp)
37000: {
37000:     if (argc == 0) {
37000:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_MORE_ARGS_NEEDED,
37000:                              "Object.create", "0", "s");
37000:         return JS_FALSE;
37000:     }
37000: 
48470:     const Value &v = vp[2];
48470:     if (!v.isObjectOrNull()) {
48470:         char *bytes = DecompileValueGenerator(cx, JSDVG_SEARCH_STACK, v, NULL);
37000:         if (!bytes)
37000:             return JS_FALSE;
37000:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_UNEXPECTED_TYPE,
37000:                              bytes, "not an object or null");
37000:         JS_free(cx, bytes);
37000:         return JS_FALSE;
37000:     }
37000: 
73086:     JSObject *proto = v.toObjectOrNull();
73086:     if (proto && proto->isXML()) {
72561:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_XML_PROTO_FORBIDDEN);
72561:         return false;
72561:     }
72561: 
37000:     /*
47497:      * Use the callee's global as the parent of the new object to avoid dynamic
47497:      * scoping (i.e., using the caller's global).
37000:      */
73086:     JSObject *obj = NewNonFunction<WithProto::Given>(cx, &js_ObjectClass, proto,
48470:                                                      vp->toObject().getGlobal());
37000:     if (!obj)
37000:         return JS_FALSE;
48470:     vp->setObject(*obj); /* Root and prepare for eventual return. */
37000: 
37000:     /* 15.2.3.5 step 4. */
48470:     if (argc > 1 && !vp[3].isUndefined()) {
48470:         if (vp[3].isPrimitive()) {
37010:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_NOT_NONNULL_OBJECT);
37000:             return JS_FALSE;
37000:         }
37000: 
64250:         if (!DefineProperties(cx, obj, &vp[3].toObject()))
37000:             return JS_FALSE;
37000:     }
37000: 
37000:     /* 5. Return obj. */
37000:     return JS_TRUE;
37000: }
37000: 
47569: static JSBool
48470: obj_getOwnPropertyNames(JSContext *cx, uintN argc, Value *vp)
47569: {
47569:     JSObject *obj;
47569:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.getOwnPropertyNames", &obj))
47569:         return false;
47569: 
48470:     AutoIdVector keys(cx);
54562:     if (!GetPropertyNames(cx, obj, JSITER_OWNONLY | JSITER_HIDDEN, &keys))
47569:         return false;
47569: 
48470:     AutoValueVector vals(cx);
48470:     if (!vals.resize(keys.length()))
48470:         return false;
48470: 
48470:     for (size_t i = 0, len = keys.length(); i < len; i++) {
48470:          jsid id = keys[i];
48470:          if (JSID_IS_INT(id)) {
48470:              JSString *str = js_ValueToString(cx, Int32Value(JSID_TO_INT(id)));
47569:              if (!str)
47569:                  return false;
48470:              vals[i].setString(str);
48470:          } else if (JSID_IS_ATOM(id)) {
48470:              vals[i].setString(JSID_TO_STRING(id));
48470:          } else {
48470:              vals[i].setObject(*JSID_TO_OBJECT(id));
48470:          }
48470:     }
48470: 
59234:     JSObject *aobj = NewDenseCopiedArray(cx, vals.length(), vals.begin());
47569:     if (!aobj)
47569:         return false;
47569: 
48470:     vp->setObject(*aobj);
47569:     return true;
47569: }
47569: 
54563: static JSBool
54563: obj_isExtensible(JSContext *cx, uintN argc, Value *vp)
54563: {
54563:     JSObject *obj;
54563:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.isExtensible", &obj))
54563:         return false;
54563: 
54563:     vp->setBoolean(obj->isExtensible());
54563:     return true;
54563: }
54563: 
54563: static JSBool
54563: obj_preventExtensions(JSContext *cx, uintN argc, Value *vp)
54563: {
54563:     JSObject *obj;
54563:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.preventExtensions", &obj))
54563:         return false;
54563: 
54563:     vp->setObject(*obj);
57813:     if (!obj->isExtensible())
57813:         return true;
54563: 
54563:     AutoIdVector props(cx);
54563:     return obj->preventExtensions(cx, &props);
54563: }
54563: 
54563: bool
57813: JSObject::sealOrFreeze(JSContext *cx, ImmutabilityType it)
54563: {
54563:     assertSameCompartment(cx, this);
57813:     JS_ASSERT(it == SEAL || it == FREEZE);
54563: 
54563:     AutoIdVector props(cx);
54563:     if (isExtensible()) {
54563:         if (!preventExtensions(cx, &props))
54563:             return false;
54563:     } else {
54563:         if (!GetPropertyNames(cx, this, JSITER_HIDDEN | JSITER_OWNONLY, &props))
54563:             return false;
54563:     }
54563: 
54563:     /* preventExtensions must slowify dense arrays, so we can assign to holes without checks. */
54563:     JS_ASSERT(!isDenseArray());
54563: 
54563:     for (size_t i = 0, len = props.length(); i < len; i++) {
54563:         jsid id = props[i];
54563: 
54563:         uintN attrs;
54563:         if (!getAttributes(cx, id, &attrs))
54563:             return false;
54563: 
54563:         /* Make all attributes permanent; if freezing, make data attributes read-only. */
54563:         uintN new_attrs;
57813:         if (it == FREEZE && !(attrs & (JSPROP_GETTER | JSPROP_SETTER)))
54563:             new_attrs = JSPROP_PERMANENT | JSPROP_READONLY;
54563:         else
54563:             new_attrs = JSPROP_PERMANENT;
54563: 
54563:         /* If we already have the attributes we need, skip the setAttributes call. */
54563:         if ((attrs | new_attrs) == attrs)
54563:             continue;
54563: 
54563:         attrs |= new_attrs;
54563:         if (!setAttributes(cx, id, &attrs))
54563:             return false;
54563:     }
54563: 
54563:     return true;
54563: }
32721: 
54564: static JSBool
54564: obj_freeze(JSContext *cx, uintN argc, Value *vp)
54564: {
54564:     JSObject *obj;
54564:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.freeze", &obj))
54564:         return false;
54564: 
54564:     vp->setObject(*obj);
54564: 
54564:     return obj->freeze(cx);
54564: }
54564: 
54564: static JSBool
54564: obj_isFrozen(JSContext *cx, uintN argc, Value *vp)
54564: {
54564:     JSObject *obj;
54564:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.preventExtensions", &obj))
54564:         return false;
54564: 
54564:     vp->setBoolean(false);
54564: 
54564:     if (obj->isExtensible())
54564:         return true; /* The JavaScript value returned is false. */
54564: 
54564:     AutoIdVector props(cx);
54564:     if (!GetPropertyNames(cx, obj, JSITER_HIDDEN | JSITER_OWNONLY, &props))
54564:         return false;
54564: 
54564:     for (size_t i = 0, len = props.length(); i < len; i++) {
54564:         jsid id = props[i];
54564: 
54564:         uintN attrs = 0;
54564:         if (!obj->getAttributes(cx, id, &attrs))
54564:             return false;
54564: 
54564:         /* The property must be non-configurable and either read-only or an accessor. */
54564:         if (!(attrs & JSPROP_PERMANENT) ||
54564:             !(attrs & (JSPROP_READONLY | JSPROP_GETTER | JSPROP_SETTER)))
54564:             return true; /* The JavaScript value returned is false. */
54564:     }
54564: 
54565:     /* It really was sealed, so return true. */
54565:     vp->setBoolean(true);
54565:     return true;
54565: }
54565: 
54565: static JSBool
54565: obj_seal(JSContext *cx, uintN argc, Value *vp)
54565: {
54565:     JSObject *obj;
54565:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.seal", &obj))
54565:         return false;
54565: 
54565:     vp->setObject(*obj);
54565: 
54565:     return obj->seal(cx);
54565: }
54565: 
54565: static JSBool
54565: obj_isSealed(JSContext *cx, uintN argc, Value *vp)
54565: {
54565:     JSObject *obj;
54565:     if (!GetFirstArgumentAsObject(cx, argc, vp, "Object.isSealed", &obj))
54565:         return false;
54565: 
54565:     /* Assume not sealed until proven otherwise. */
54565:     vp->setBoolean(false);
54565: 
54565:     if (obj->isExtensible())
54565:         return true; /* The JavaScript value returned is false. */
54565: 
54565:     AutoIdVector props(cx);
54565:     if (!GetPropertyNames(cx, obj, JSITER_HIDDEN | JSITER_OWNONLY, &props))
54565:         return false;
54565: 
54565:     for (size_t i = 0, len = props.length(); i < len; i++) {
54565:         jsid id = props[i];
54565: 
54565:         uintN attrs;
54565:         if (!obj->getAttributes(cx, id, &attrs))
54565:             return false;
54565: 
54565:         if (!(attrs & JSPROP_PERMANENT))
54565:             return true; /* The JavaScript value returned is false. */
54565:     }
54565: 
54565:     /* It really was sealed, so return true. */
54564:     vp->setBoolean(true);
54564:     return true;
54564: }
54564: 
    1: #if JS_HAS_OBJ_WATCHPOINT
    1: const char js_watch_str[] = "watch";
    1: const char js_unwatch_str[] = "unwatch";
    1: #endif
    1: const char js_hasOwnProperty_str[] = "hasOwnProperty";
    1: const char js_isPrototypeOf_str[] = "isPrototypeOf";
    1: const char js_propertyIsEnumerable_str[] = "propertyIsEnumerable";
    1: 
    1: static JSFunctionSpec object_methods[] = {
    1: #if JS_HAS_TOSOURCE
16519:     JS_FN(js_toSource_str,             obj_toSource,                0,0),
    1: #endif
59941:     JS_FN(js_toString_str,             obj_toString,                0,0),
16519:     JS_FN(js_toLocaleString_str,       obj_toLocaleString,          0,0),
41856:     JS_FN(js_valueOf_str,              obj_valueOf,                 0,0),
    1: #if JS_HAS_OBJ_WATCHPOINT
16519:     JS_FN(js_watch_str,                obj_watch,                   2,0),
16519:     JS_FN(js_unwatch_str,              obj_unwatch,                 1,0),
    1: #endif
41856:     JS_FN(js_hasOwnProperty_str,       obj_hasOwnProperty,          1,0),
16519:     JS_FN(js_isPrototypeOf_str,        obj_isPrototypeOf,           1,0),
41856:     JS_FN(js_propertyIsEnumerable_str, obj_propertyIsEnumerable,    1,0),
40855: #if OLD_GETTER_SETTER_METHODS
24145:     JS_FN(js_defineGetter_str,         js_obj_defineGetter,         2,0),
24145:     JS_FN(js_defineSetter_str,         js_obj_defineSetter,         2,0),
16519:     JS_FN(js_lookupGetter_str,         obj_lookupGetter,            1,0),
16519:     JS_FN(js_lookupSetter_str,         obj_lookupSetter,            1,0),
    1: #endif
 4127:     JS_FS_END
    1: };
    1: 
16380: static JSFunctionSpec object_static_methods[] = {
16519:     JS_FN("getPrototypeOf",            obj_getPrototypeOf,          1,0),
32721:     JS_FN("getOwnPropertyDescriptor",  obj_getOwnPropertyDescriptor,2,0),
33155:     JS_FN("keys",                      obj_keys,                    1,0),
36991:     JS_FN("defineProperty",            obj_defineProperty,          3,0),
36991:     JS_FN("defineProperties",          obj_defineProperties,        2,0),
37000:     JS_FN("create",                    obj_create,                  2,0),
47569:     JS_FN("getOwnPropertyNames",       obj_getOwnPropertyNames,     1,0),
54563:     JS_FN("isExtensible",              obj_isExtensible,            1,0),
54563:     JS_FN("preventExtensions",         obj_preventExtensions,       1,0),
54564:     JS_FN("freeze",                    obj_freeze,                  1,0),
54564:     JS_FN("isFrozen",                  obj_isFrozen,                1,0),
54565:     JS_FN("seal",                      obj_seal,                    1,0),
54565:     JS_FN("isSealed",                  obj_isSealed,                1,0),
16380:     JS_FS_END
16380: };
16380: 
30439: JSBool
50489: js_Object(JSContext *cx, uintN argc, Value *vp)
50489: {
50489:     JSObject *obj;
30439:     if (argc == 0) {
30439:         /* Trigger logic below to construct a blank object. */
30439:         obj = NULL;
30439:     } else {
30439:         /* If argv[0] is null or undefined, obj comes back null. */
50489:         if (!js_ValueToObjectOrNull(cx, vp[2], &obj))
30439:             return JS_FALSE;
30439:     }
30439:     if (!obj) {
50489:         /* Make an object whether this was called with 'new' or not. */
50489:         JS_ASSERT(!argc || vp[2].isNull() || vp[2].isUndefined());
55746:         gc::FinalizeKind kind = NewObjectGCKind(cx, &js_ObjectClass);
55746:         obj = NewBuiltinClassInstance(cx, &js_ObjectClass, kind);
30439:         if (!obj)
30439:             return JS_FALSE;
30439:     }
50489:     vp->setObject(*obj);
30439:     return JS_TRUE;
30439: }
30439: 
53557: JSObject*
55503: js_CreateThis(JSContext *cx, JSObject *callee)
53557: {
53557:     Class *clasp = callee->getClass();
53557: 
53557:     Class *newclasp = &js_ObjectClass;
53557:     if (clasp == &js_FunctionClass) {
53557:         JSFunction *fun = callee->getFunctionPrivate();
53557:         if (fun->isNative() && fun->u.n.clasp)
53557:             newclasp = fun->u.n.clasp;
53557:     }
53557: 
53557:     Value protov;
53557:     if (!callee->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom), &protov))
53557:         return NULL;
53557: 
53557:     JSObject *proto = protov.isObjectOrNull() ? protov.toObjectOrNull() : NULL;
53557:     JSObject *parent = callee->getParent();
55746:     gc::FinalizeKind kind = NewObjectGCKind(cx, newclasp);
57806:     JSObject *obj = NewObject<WithProto::Class>(cx, newclasp, proto, parent, kind);
57806:     if (obj)
57806:         obj->syncSpecialEquality();
57806:     return obj;
53557: }
53557: 
55503: JSObject *
55503: js_CreateThisForFunctionWithProto(JSContext *cx, JSObject *callee, JSObject *proto)
55503: {
55746:     gc::FinalizeKind kind = NewObjectGCKind(cx, &js_ObjectClass);
55746:     return NewNonFunction<WithProto::Class>(cx, &js_ObjectClass, proto, callee->getParent(), kind);
55503: }
55503: 
55503: JSObject *
55503: js_CreateThisForFunction(JSContext *cx, JSObject *callee)
55503: {
55503:     Value protov;
55503:     if (!callee->getProperty(cx,
55503:                              ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
55503:                              &protov)) {
55503:         return NULL;
55503:     }
55503:     JSObject *proto = protov.isObject() ? &protov.toObject() : NULL;
55503:     return js_CreateThisForFunctionWithProto(cx, callee, proto);
55503: }
55503: 
32615: #ifdef JS_TRACER
32615: 
35117: JSObject* FASTCALL
35117: js_Object_tn(JSContext* cx, JSObject* proto)
35117: {
35117:     JS_ASSERT(!(js_ObjectClass.flags & JSCLASS_HAS_PRIVATE));
55746:     return NewObjectWithClassProto(cx, &js_ObjectClass, proto, FINALIZE_OBJECT8);
35117: }
35117: 
35117: JS_DEFINE_TRCINFO_1(js_Object,
39910:     (2, (extern, CONSTRUCTOR_RETRY, js_Object_tn, CONTEXT, CALLEE_PROTOTYPE, 0,
48613:          nanojit::ACCSET_STORE_ANY)))
35117: 
37035: JSObject* FASTCALL
58056: js_InitializerObject(JSContext* cx, JSObject *proto, JSObject *baseobj)
58056: {
58056:     if (!baseobj) {
58056:         gc::FinalizeKind kind = GuessObjectGCKind(0, false);
58056:         return NewObjectWithClassProto(cx, &js_ObjectClass, proto, kind);
58056:     }
58056: 
58056:     return CopyInitializerObject(cx, baseobj);
58056: }
58056: 
58056: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_InitializerObject, CONTEXT, OBJECT, OBJECT,
58056:                      0, nanojit::ACCSET_STORE_ANY)
37035: 
32615: JSObject* FASTCALL
53638: js_String_tn(JSContext* cx, JSObject* proto, JSString* str)
53638: {
53638:     JS_ASSERT(JS_ON_TRACE(cx));
69242:     JS_ASSERT(proto);
69242:     return StringObject::createWithProto(cx, str, *proto);
53638: }
53638: JS_DEFINE_CALLINFO_3(extern, OBJECT, js_String_tn, CONTEXT, CALLEE_PROTOTYPE, STRING, 0,
53638:                      nanojit::ACCSET_STORE_ANY)
53638: 
53638: JSObject * FASTCALL
62590: js_CreateThisFromTrace(JSContext *cx, JSObject *ctor, uintN protoSlot)
62590: {
62590: #ifdef DEBUG
40430:     JS_ASSERT(ctor->isFunction());
62590:     JS_ASSERT(ctor->getFunctionPrivate()->isInterpreted());
62590:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom);
62590:     const Shape *shape = ctor->nativeLookup(id);
62590:     JS_ASSERT(shape->slot == protoSlot);
62590:     JS_ASSERT(!shape->configurable());
62590:     JS_ASSERT(!shape->isMethod());
62590: #endif
32615: 
47497:     JSObject *parent = ctor->getParent();
32615:     JSObject *proto;
62590:     const Value &protov = ctor->getSlotRef(protoSlot);
62590:     if (protov.isObject()) {
62590:         proto = &protov.toObject();
47497:     } else {
62590:         /*
62590:          * GetInterpretedFunctionPrototype found that ctor.prototype is
62590:          * primitive. Use Object.prototype for proto, per ES5 13.2.2 step 7.
62590:          */
47497:         if (!js_GetClassPrototype(cx, parent, JSProto_Object, &proto))
47497:             return NULL;
62590:     }
62590: 
62590:     gc::FinalizeKind kind = NewObjectGCKind(cx, &js_ObjectClass);
62590:     return NewNativeClassInstance(cx, &js_ObjectClass, proto, parent, kind);
62590: }
62590: JS_DEFINE_CALLINFO_3(extern, CONSTRUCTOR_RETRY, js_CreateThisFromTrace, CONTEXT, OBJECT, UINTN, 0,
48613:                      nanojit::ACCSET_STORE_ANY)
32615: 
32615: #else  /* !JS_TRACER */
32615: 
32615: # define js_Object_trcinfo NULL
32615: 
32615: #endif /* !JS_TRACER */
32615: 
    1: /*
23435:  * Given pc pointing after a property accessing bytecode, return true if the
23435:  * access is "object-detecting" in the sense used by web scripts, e.g., when
23435:  * checking whether document.all is defined.
23435:  */
30034: JS_REQUIRES_STACK JSBool
23435: Detecting(JSContext *cx, jsbytecode *pc)
23435: {
23435:     JSScript *script;
25474:     jsbytecode *endpc;
23435:     JSOp op;
23435:     JSAtom *atom;
23435: 
53840:     script = cx->fp()->script();
25474:     endpc = script->code + script->length;
25215:     for (;; pc += js_CodeSpec[op].length) {
53840:         JS_ASSERT_IF(!cx->fp()->hasImacropc(), script->code <= pc && pc < endpc);
25474: 
23435:         /* General case: a branch or equality op follows the access. */
25215:         op = js_GetOpcode(cx, script, pc);
23435:         if (js_CodeSpec[op].format & JOF_DETECTING)
23435:             return JS_TRUE;
23435: 
23435:         switch (op) {
23435:           case JSOP_NULL:
23435:             /*
23435:              * Special case #1: handle (document.all == null).  Don't sweat
23435:              * about JS1.2's revision of the equality operators here.
23435:              */
25474:             if (++pc < endpc) {
25215:                 op = js_GetOpcode(cx, script, pc);
25474:                 return *pc == JSOP_EQ || *pc == JSOP_NE;
25474:             }
25474:             return JS_FALSE;
23435: 
52825:           case JSOP_GETGNAME:
23435:           case JSOP_NAME:
23435:             /*
23435:              * Special case #2: handle (document.all == undefined).  Don't
23435:              * worry about someone redefining undefined, which was added by
23435:              * Edition 3, so is read/write for backward compatibility.
23435:              */
23435:             GET_ATOM_FROM_BYTECODE(script, pc, 0, atom);
25474:             if (atom == cx->runtime->atomState.typeAtoms[JSTYPE_VOID] &&
25474:                 (pc += js_CodeSpec[op].length) < endpc) {
25215:                 op = js_GetOpcode(cx, script, pc);
23435:                 return op == JSOP_EQ || op == JSOP_NE ||
23435:                        op == JSOP_STRICTEQ || op == JSOP_STRICTNE;
23435:             }
23435:             return JS_FALSE;
23435: 
23435:           default:
23435:             /*
23435:              * At this point, anything but an extended atom index prefix means
23435:              * we're not detecting.
23435:              */
23435:             if (!(js_CodeSpec[op].format & JOF_INDEXBASE))
23435:                 return JS_FALSE;
23435:             break;
23435:         }
23435:     }
23435: }
23435: 
23435: /*
23435:  * Infer lookup flags from the currently executing bytecode. This does
23435:  * not attempt to infer JSRESOLVE_WITH, because the current bytecode
23435:  * does not indicate whether we are in a with statement. Return defaultFlags
23435:  * if a currently executing bytecode cannot be determined.
23435:  */
30034: uintN
30034: js_InferFlags(JSContext *cx, uintN defaultFlags)
23435: {
30035: #ifdef JS_TRACER
30034:     if (JS_ON_TRACE(cx))
62033:         return JS_TRACE_MONITOR_ON_TRACE(cx)->bailExit->lookupFlags;
30035: #endif
30034: 
30034:     JS_ASSERT_NOT_ON_TRACE(cx);
30034: 
23435:     jsbytecode *pc;
23435:     const JSCodeSpec *cs;
23435:     uint32 format;
23435:     uintN flags = 0;
23435: 
69223:     StackFrame *const fp = js_GetTopStackFrame(cx);
69223:     if (!fp || !(pc = cx->regs().pc))
23435:         return defaultFlags;
53840:     cs = &js_CodeSpec[js_GetOpcode(cx, fp->script(), pc)];
23435:     format = cs->format;
23435:     if (JOF_MODE(format) != JOF_NAME)
23435:         flags |= JSRESOLVE_QUALIFIED;
68898:     if (format & (JOF_SET | JOF_FOR)) {
23435:         flags |= JSRESOLVE_ASSIGNING;
32680:     } else if (cs->length >= 0) {
23435:         pc += cs->length;
53840:         JSScript *script = cx->fp()->script();
51446:         if (pc < script->code + script->length && Detecting(cx, pc))
23435:             flags |= JSRESOLVE_DETECTING;
23435:     }
23435:     if (format & JOF_DECLARING)
23435:         flags |= JSRESOLVE_DECLARING;
23435:     return flags;
23435: }
23435: 
23435: /*
    1:  * ObjectOps and Class for with-statement stack objects.
    1:  */
    1: static JSBool
    1: with_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
    1:                     JSProperty **propp)
    1: {
23435:     /* Fixes bug 463997 */
23435:     uintN flags = cx->resolveFlags;
69855:     if (flags == RESOLVE_INFER)
30034:         flags = js_InferFlags(cx, flags);
23435:     flags |= JSRESOLVE_WITH;
23435:     JSAutoResolveFlags rf(cx, flags);
47417:     return obj->getProto()->lookupProperty(cx, id, objp, propp);
    1: }
    1: 
    1: static JSBool
56817: with_GetProperty(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, Value *vp)
    1: {
47417:     return obj->getProto()->getProperty(cx, id, vp);
    1: }
    1: 
    1: static JSBool
56760: with_SetProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp, JSBool strict)
54169: {
54169:     return obj->getProto()->setProperty(cx, id, vp, strict);
    1: }
    1: 
    1: static JSBool
43290: with_GetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
    1: {
47417:     return obj->getProto()->getAttributes(cx, id, attrsp);
    1: }
    1: 
    1: static JSBool
43290: with_SetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
    1: {
47417:     return obj->getProto()->setAttributes(cx, id, attrsp);
    1: }
    1: 
    1: static JSBool
54169: with_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, Value *rval, JSBool strict)
54169: {
54169:     return obj->getProto()->deleteProperty(cx, id, rval, strict);
    1: }
    1: 
    1: static JSBool
    1: with_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op,
48470:                Value *statep, jsid *idp)
    1: {
47417:     return obj->getProto()->enumerate(cx, enum_op, statep, idp);
    1: }
    1: 
38633: static JSType
38633: with_TypeOf(JSContext *cx, JSObject *obj)
38633: {
38633:     return JSTYPE_OBJECT;
38633: }
38633: 
    1: static JSObject *
    1: with_ThisObject(JSContext *cx, JSObject *obj)
    1: {
47417:     return obj->getWithThis();
    1: }
    1: 
48622: Class js_WithClass = {
48622:     "With",
48622:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(2) | JSCLASS_IS_ANONYMOUS,
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub,
48622:     NULL,                 /* finalize */
48622:     NULL,                 /* reserved    */
48622:     NULL,                 /* checkAccess */
48622:     NULL,                 /* call        */
48622:     NULL,                 /* construct   */
48622:     NULL,                 /* xdrObject   */
48622:     NULL,                 /* hasInstance */
64223:     NULL,                 /* trace       */
48622:     JS_NULL_CLASS_EXT,
48622:     {
43290:         with_LookupProperty,
48622:         NULL,             /* defineProperty */
43290:         with_GetProperty,
43290:         with_SetProperty,
43290:         with_GetAttributes,
43290:         with_SetAttributes,
43290:         with_DeleteProperty,
43290:         with_Enumerate,
43290:         with_TypeOf,
54563:         NULL,             /* fix   */
43290:         with_ThisObject,
48622:         NULL,             /* clear */
48622:     }
    1: };
    1: 
22652: JS_REQUIRES_STACK JSObject *
    1: js_NewWithObject(JSContext *cx, JSObject *proto, JSObject *parent, jsint depth)
    1: {
    1:     JSObject *obj;
    1: 
55746:     obj = js_NewGCObject(cx, FINALIZE_OBJECT2);
    1:     if (!obj)
    1:         return NULL;
52503: 
69223:     StackFrame *priv = js_FloatingFrameIfGenerator(cx, cx->fp());
55746: 
64242:     EmptyShape *emptyWithShape = EmptyShape::getEmptyWithShape(cx);
64242:     if (!emptyWithShape)
64242:         return NULL;
64242: 
55746:     obj->init(cx, &js_WithClass, proto, parent, priv, false);
64242:     obj->setMap(emptyWithShape);
    1:     OBJ_SET_BLOCK_DEPTH(cx, obj, depth);
47417: 
47417:     AutoObjectRooter tvr(cx, obj);
47417:     JSObject *thisp = proto->thisObject(cx);
47417:     if (!thisp)
47417:         return NULL;
52503: 
55482:     assertSameCompartment(cx, obj, thisp);
55482: 
47417:     obj->setWithThis(thisp);
    1:     return obj;
    1: }
    1: 
    1: JSObject *
    1: js_NewBlockObject(JSContext *cx)
    1: {
    1:     /*
    1:      * Null obj's proto slot so that Object.prototype.* does not pollute block
28093:      * scopes and to give the block object its own scope.
    1:      */
55746:     JSObject *blockObj = js_NewGCObject(cx, FINALIZE_OBJECT2);
47497:     if (!blockObj)
47497:         return NULL;
52503: 
64242:     EmptyShape *emptyBlockShape = EmptyShape::getEmptyBlockShape(cx);
64242:     if (!emptyBlockShape)
64242:         return NULL;
64242: 
55746:     blockObj->init(cx, &js_BlockClass, NULL, NULL, NULL, false);
64242:     blockObj->setMap(emptyBlockShape);
28093:     return blockObj;
    1: }
    1: 
    1: JSObject *
69223: js_CloneBlockObject(JSContext *cx, JSObject *proto, StackFrame *fp)
    1: {
53650:     JS_ASSERT(proto->isStaticBlock());
30645: 
55746:     size_t count = OBJ_BLOCK_COUNT(cx, proto);
55746:     gc::FinalizeKind kind = gc::GetGCObjectKind(count + 1);
55746: 
55746:     JSObject *clone = js_NewGCObject(cx, kind);
    1:     if (!clone)
    1:         return NULL;
30645: 
69223:     StackFrame *priv = js_FloatingFrameIfGenerator(cx, fp);
48470: 
37766:     /* The caller sets parent on its own. */
64296:     clone->initClonedBlock(cx, proto, priv);
64296: 
55746:     if (!clone->ensureInstanceReservedSlots(cx, count + 1))
47497:         return NULL;
53650: 
55746:     clone->setSlot(JSSLOT_BLOCK_DEPTH, proto->getSlot(JSSLOT_BLOCK_DEPTH));
55746: 
53650:     JS_ASSERT(clone->isClonedBlock());
    1:     return clone;
    1: }
    1: 
22652: JS_REQUIRES_STACK JSBool
11859: js_PutBlockObject(JSContext *cx, JSBool normalUnwind)
    1: {
69223:     StackFrame *const fp = cx->fp();
53840:     JSObject *obj = &fp->scopeChain();
53650:     JS_ASSERT(obj->isClonedBlock());
51446:     JS_ASSERT(obj->getPrivate() == js_FloatingFrameIfGenerator(cx, cx->fp()));
14860: 
47497:     /* Block objects should have all reserved slots allocated early. */
47497:     uintN count = OBJ_BLOCK_COUNT(cx, obj);
55746:     JS_ASSERT(obj->numSlots() >= JSSLOT_BLOCK_DEPTH + 1 + count);
14860: 
14860:     /* The block and its locals must be on the current stack for GC safety. */
42717:     uintN depth = OBJ_BLOCK_DEPTH(cx, obj);
69223:     JS_ASSERT(depth <= size_t(cx->regs().sp - fp->base()));
69223:     JS_ASSERT(count <= size_t(cx->regs().sp - fp->base() - depth));
14860: 
32725:     /* See comments in CheckDestructuring from jsparse.cpp. */
14860:     JS_ASSERT(count >= 1);
14860: 
52503:     if (normalUnwind) {
54840:         uintN slot = JSSLOT_BLOCK_FIRST_FREE_SLOT;
53840:         depth += fp->numFixed();
55746:         memcpy(obj->getSlots() + slot, fp->slots() + depth, count * sizeof(Value));
14860:     }
14860: 
11758:     /* We must clear the private slot even with errors. */
31452:     obj->setPrivate(NULL);
53840:     fp->setScopeChainNoCallObj(*obj->getParent());
11758:     return normalUnwind;
    1: }
    1: 
    1: static JSBool
48470: block_getProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp)
    1: {
32717:     /*
32717:      * Block objects are never exposed to script, and the engine handles them
32717:      * with care. So unlike other getters, this one can assert (rather than
32717:      * check) certain invariants about obj.
32717:      */
53650:     JS_ASSERT(obj->isClonedBlock());
48470:     uintN index = (uintN) JSID_TO_INT(id);
32717:     JS_ASSERT(index < OBJ_BLOCK_COUNT(cx, obj));
32717: 
69223:     StackFrame *fp = (StackFrame *) obj->getPrivate();
14860:     if (fp) {
42714:         fp = js_LiveFrameIfGenerator(fp);
53840:         index += fp->numFixed() + OBJ_BLOCK_DEPTH(cx, obj);
53840:         JS_ASSERT(index < fp->numSlots());
42714:         *vp = fp->slots()[index];
32717:         return true;
32717:     }
32717: 
53650:     /* Values are in slots immediately following the class-reserved ones. */
53650:     JS_ASSERT(obj->getSlot(JSSLOT_FREE(&js_BlockClass) + index) == *vp);
32717:     return true;
14860: }
14860: 
14860: static JSBool
62395: block_setProperty(JSContext *cx, JSObject *obj, jsid id, JSBool strict, Value *vp)
14860: {
53650:     JS_ASSERT(obj->isClonedBlock());
48470:     uintN index = (uintN) JSID_TO_INT(id);
32717:     JS_ASSERT(index < OBJ_BLOCK_COUNT(cx, obj));
32717: 
69223:     StackFrame *fp = (StackFrame *) obj->getPrivate();
14860:     if (fp) {
42714:         fp = js_LiveFrameIfGenerator(fp);
53840:         index += fp->numFixed() + OBJ_BLOCK_DEPTH(cx, obj);
53840:         JS_ASSERT(index < fp->numSlots());
42714:         fp->slots()[index] = *vp;
32717:         return true;
32717:     }
32717: 
53650:     /*
53650:      * The value in *vp will be written back to the slot in obj that was
53650:      * allocated when this let binding was defined.
53650:      */
32717:     return true;
32717: }
32717: 
53650: const Shape *
53650: JSObject::defineBlockVariable(JSContext *cx, jsid id, intN index)
53650: {
53650:     JS_ASSERT(isStaticBlock());
32717: 
32717:     /* Use JSPROP_ENUMERATE to aid the disassembler. */
53650:     uint32 slot = JSSLOT_FREE(&js_BlockClass) + index;
53650:     const Shape *shape = addProperty(cx, id,
53650:                                      block_getProperty, block_setProperty,
53650:                                      slot, JSPROP_ENUMERATE | JSPROP_PERMANENT,
53650:                                      Shape::HAS_SHORTID, index);
53650:     if (!shape)
53650:         return NULL;
53650:     if (slot >= numSlots() && !growSlots(cx, slot + 1))
53650:         return NULL;
53650:     return shape;
    1: }
    1: 
42832: static size_t
42832: GetObjectSize(JSObject *obj)
42832: {
42832:     return (obj->isFunction() && !obj->getPrivate())
42832:            ? sizeof(JSFunction)
55746:            : sizeof(JSObject) + sizeof(js::Value) * obj->numFixedSlots();
42832: }
42832: 
58714: bool
58714: JSObject::copyPropertiesFrom(JSContext *cx, JSObject *obj)
58714: {
58714:     // If we're not native, then we cannot copy properties.
58714:     JS_ASSERT(isNative() == obj->isNative());
58714:     if (!isNative())
58714:         return true;
58714: 
62363:     AutoShapeVector shapes(cx);
58714:     for (Shape::Range r(obj->lastProperty()); !r.empty(); r.popFront()) {
58714:         if (!shapes.append(&r.front()))
58714:             return false;
58714:     }
58714: 
58714:     size_t n = shapes.length();
58714:     while (n > 0) {
58714:         const Shape *shape = shapes[--n];
58714:         uintN attrs = shape->attributes();
58714:         PropertyOp getter = shape->getter();
58714:         if ((attrs & JSPROP_GETTER) && !cx->compartment->wrap(cx, &getter))
58714:             return false;
62395:         StrictPropertyOp setter = shape->setter();
58714:         if ((attrs & JSPROP_SETTER) && !cx->compartment->wrap(cx, &setter))
58714:             return false;
58714:         Value v = shape->hasSlot() ? obj->getSlot(shape->slot) : UndefinedValue();
58714:         if (!cx->compartment->wrap(cx, &v))
58714:             return false;
69637:         if (!defineProperty(cx, shape->propid, v, getter, setter, attrs))
58714:             return false;
58714:     }
58714:     return true;
58714: }
58714: 
58714: static bool
58714: CopySlots(JSContext *cx, JSObject *from, JSObject *to)
58714: {
58714:     JS_ASSERT(!from->isNative() && !to->isNative());
58714:     size_t nslots = from->numSlots();
58714:     if (to->ensureSlots(cx, nslots))
58714:         return false;
58714: 
58714:     size_t n = 0;
58714:     if (to->isWrapper() &&
58714:         (JSWrapper::wrapperHandler(to)->flags() & JSWrapper::CROSS_COMPARTMENT)) {
58714:         to->slots[0] = from->slots[0];
58714:         to->slots[1] = from->slots[1];
58714:         n = 2;
58714:     }
58714: 
58714:     for (; n < nslots; ++n) {
58714:         Value v = from->slots[n];
58714:         if (!cx->compartment->wrap(cx, &v))
58714:             return false;
58714:         to->slots[n] = v;
58714:     }
58714:     return true;
58714: }
58714: 
58714: JSObject *
58714: JSObject::clone(JSContext *cx, JSObject *proto, JSObject *parent)
58714: {
58714:     /*
58714:      * We can only clone native objects and proxies. Dense arrays are slowified if
58714:      * we try to clone them.
58714:      */
58714:     if (!isNative()) {
58714:         if (isDenseArray()) {
58714:             if (!makeDenseArraySlow(cx))
58714:                 return NULL;
58714:         } else if (!isProxy()) {
58714:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
58714:                                  JSMSG_CANT_CLONE_OBJECT);
58714:             return NULL;
58714:         }
58714:     }
58714:     JSObject *clone = NewObject<WithProto::Given>(cx, getClass(),
58714:                                                   proto, parent,
58714:                                                   gc::FinalizeKind(finalizeKind()));
58714:     if (!clone)
58714:         return NULL;
58714:     if (isNative()) {
58714:         if (clone->isFunction() && (compartment() != clone->compartment())) {
58714:             JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
58714:                                  JSMSG_CANT_CLONE_OBJECT);
58714:             return NULL;
58714:         }
58714: 
58714:         if (getClass()->flags & JSCLASS_HAS_PRIVATE)
58714:             clone->setPrivate(getPrivate());
58714:     } else {
58714:         JS_ASSERT(isProxy());
58714:         if (!CopySlots(cx, this, clone))
58714:             return NULL;
58714:     }
58714:     return clone;
58714: }
58714: 
58714: static void
58714: TradeGuts(JSObject *a, JSObject *b)
58714: {
58714:     JS_ASSERT(a->compartment() == b->compartment());
58714:     JS_ASSERT(a->isFunction() == b->isFunction());
58714: 
60168:     /*
60168:      * Regexp guts are more complicated -- we would need to migrate the
60168:      * refcounted JIT code blob for them across compartments instead of just
60168:      * swapping guts.
60168:      */
60168:     JS_ASSERT(!a->isRegExp() && !b->isRegExp());
60168: 
58714:     bool aInline = !a->hasSlotsArray();
58714:     bool bInline = !b->hasSlotsArray();
58714: 
58714:     /* Trade the guts of the objects. */
58714:     const size_t size = GetObjectSize(a);
58714:     if (size == GetObjectSize(b)) {
58714:         /*
58714:          * If the objects are the same size, then we make no assumptions about
58714:          * whether they have dynamically allocated slots and instead just copy
58714:          * them over wholesale.
58714:          */
58714:         char tmp[tl::Max<sizeof(JSFunction), sizeof(JSObject_Slots16)>::result];
58714:         JS_ASSERT(size <= sizeof(tmp));
58714: 
58714:         memcpy(tmp, a, size);
58714:         memcpy(a, b, size);
58714:         memcpy(b, tmp, size);
58714: 
58714:         /* Fixup pointers for inline slots on the objects. */
58714:         if (aInline)
58714:             b->slots = b->fixedSlots();
58714:         if (bInline)
58714:             a->slots = a->fixedSlots();
58714:     } else {
58714:         /*
58714:          * If the objects are of differing sizes, then we only copy over the
58714:          * JSObject portion (things like class, etc.) and leave it to
58714:          * JSObject::clone to copy over the dynamic slots for us.
58714:          */
58714:         if (a->isFunction()) {
58714:             JSFunction tmp;
58714:             memcpy(&tmp, a, sizeof tmp);
58714:             memcpy(a, b, sizeof tmp);
58714:             memcpy(b, &tmp, sizeof tmp);
58714:         } else {
58714:             JSObject tmp;
58714:             memcpy(&tmp, a, sizeof tmp);
58714:             memcpy(a, b, sizeof tmp);
58714:             memcpy(b, &tmp, sizeof tmp);
58714:         }
58714: 
58714:         JS_ASSERT(!aInline);
58714:         JS_ASSERT(!bInline);
58714:     }
58714: }
58714: 
42733: /*
42733:  * Use this method with extreme caution. It trades the guts of two objects and updates
42733:  * scope ownership. This operation is not thread-safe, just as fast array to slow array
42733:  * transitions are inherently not thread-safe. Don't perform a swap operation on objects
42733:  * shared across threads or, or bad things will happen. You have been warned.
42733:  */
55746: bool
55746: JSObject::swap(JSContext *cx, JSObject *other)
42733: {
55746:     /*
58714:      * If we are swapping objects with a different number of builtin slots, force
58714:      * both to not use their inline slots.
55746:      */
58714:     if (GetObjectSize(this) != GetObjectSize(other)) {
55746:         if (!hasSlotsArray()) {
55746:             if (!allocSlots(cx, numSlots()))
55746:                 return false;
55746:         }
55746:         if (!other->hasSlotsArray()) {
55746:             if (!other->allocSlots(cx, other->numSlots()))
55746:                 return false;
55746:         }
55746:     }
55746: 
58714:     if (this->compartment() == other->compartment()) {
58714:         TradeGuts(this, other);
58714:         return true;
58714:     }
58714: 
58714:     JSObject *thisClone;
58714:     JSObject *otherClone;
58714:     {
58714:         AutoCompartment ac(cx, other);
58714:         if (!ac.enter())
58714:             return false;
58714:         thisClone = this->clone(cx, other->getProto(), other->getParent());
58714:         if (!thisClone || !thisClone->copyPropertiesFrom(cx, this))
58714:             return false;
58714:     }
58714:     {
58714:         AutoCompartment ac(cx, this);
58714:         if (!ac.enter())
58714:             return false;
58714:         otherClone = other->clone(cx, other->getProto(), other->getParent());
58714:         if (!otherClone || !otherClone->copyPropertiesFrom(cx, other))
58714:             return false;
58714:     }
58714:     TradeGuts(this, otherClone);
58714:     TradeGuts(other, thisClone);
55746: 
55746:     return true;
42733: }
42733: 
    1: #if JS_HAS_XDR
    1: 
 3235: #define NO_PARENT_INDEX ((uint32)-1)
 3235: 
 3235: uint32
 3235: FindObjectIndex(JSObjectArray *array, JSObject *obj)
    1: {
    1:     size_t i;
 3235: 
 3235:     if (array) {
 3235:         i = array->length;
 3235:         do {
 3235: 
 3235:             if (array->vector[--i] == obj)
    1:                 return i;
 3235:         } while (i != 0);
    1:     }
    1: 
    1:     return NO_PARENT_INDEX;
    1: }
    1: 
28093: JSBool
28093: js_XDRBlockObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
 3235:     uint32 parentId;
    1:     JSObject *obj, *parent;
53650:     uintN depth, count;
53650:     uint32 depthAndCount;
52503:     const Shape *shape;
    1: 
    1:     cx = xdr->cx;
    1: #ifdef __GNUC__
    1:     obj = NULL;         /* quell GCC overwarning */
    1: #endif
    1: 
    1:     if (xdr->mode == JSXDR_ENCODE) {
    1:         obj = *objp;
39930:         parent = obj->getParent();
59221:         parentId = JSScript::isValidOffset(xdr->script->objectsOffset)
59221:                    ? FindObjectIndex(xdr->script->objects(), parent)
59221:                    : NO_PARENT_INDEX;
 2531:         depth = (uint16)OBJ_BLOCK_DEPTH(cx, obj);
 2531:         count = (uint16)OBJ_BLOCK_COUNT(cx, obj);
53650:         depthAndCount = (uint32)(depth << 16) | count;
    1:     }
    1: #ifdef __GNUC__ /* suppress bogus gcc warnings */
    1:     else count = 0;
    1: #endif
    1: 
    1:     /* First, XDR the parent atomid. */
    1:     if (!JS_XDRUint32(xdr, &parentId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         obj = js_NewBlockObject(cx);
    1:         if (!obj)
    1:             return JS_FALSE;
    1:         *objp = obj;
    1: 
    1:         /*
    1:          * If there's a parent id, then get the parent out of our script's
 3235:          * object array. We know that we XDR block object in outer-to-inner
 3235:          * order, which means that getting the parent now will work.
    1:          */
 3235:         if (parentId == NO_PARENT_INDEX)
    1:             parent = NULL;
 3235:         else
32723:             parent = xdr->script->getObject(parentId);
39930:         obj->setParent(parent);
    1:     }
    1: 
48470:     AutoObjectRooter tvr(cx, obj);
33178: 
53650:     if (!JS_XDRUint32(xdr, &depthAndCount))
33178:         return false;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
53650:         depth = (uint16)(depthAndCount >> 16);
53650:         count = (uint16)depthAndCount;
48470:         obj->setSlot(JSSLOT_BLOCK_DEPTH, Value(Int32Value(depth)));
    1: 
    1:         /*
    1:          * XDR the block object's properties. We know that there are 'count'
53650:          * properties to XDR, stored as id/shortid pairs.
    1:          */
53650:         for (uintN i = 0; i < count; i++) {
53650:             JSAtom *atom;
64245: 
64245:             /* XDR the real id. */
64245:             if (!js_XDRAtom(xdr, &atom))
64245:                 return false;
64245: 
64245:             if (!obj->defineBlockVariable(cx, ATOM_TO_JSID(atom), i))
53844:                 return false;
53844:         }
53844:     } else {
62363:         AutoShapeVector shapes(cx);
62363:         shapes.growBy(count);
53844: 
53844:         for (Shape::Range r(obj->lastProperty()); !r.empty(); r.popFront()) {
53844:             shape = &r.front();
53844:             shapes[shape->shortid] = shape;
53844:         }
53844: 
53844:         /*
53844:          * XDR the block object's properties. We know that there are 'count'
53844:          * properties to XDR, stored as id/shortid pairs.
53844:          */
53844:         for (uintN i = 0; i < count; i++) {
53650:             shape = shapes[i];
52503:             JS_ASSERT(shape->getter() == block_getProperty);
53650: 
69637:             jsid propid = shape->propid;
    1:             JS_ASSERT(JSID_IS_ATOM(propid));
53844:             JSAtom *atom = JSID_TO_ATOM(propid);
53844: 
64245: #ifdef DEBUG
53844:             uint16 shortid = uint16(shape->shortid);
53650:             JS_ASSERT(shortid == i);
64245: #endif
64245: 
64245:             /* XDR the real id. */
64245:             if (!js_XDRAtom(xdr, &atom))
33178:                 return false;
    1:         }
    1:     }
33178:     return true;
    1: }
    1: 
    1: #endif
    1: 
48470: Class js_BlockClass = {
    1:     "Block",
28093:     JSCLASS_HAS_PRIVATE | JSCLASS_HAS_RESERVED_SLOTS(1) | JSCLASS_IS_ANONYMOUS,
48622:     PropertyStub,         /* addProperty */
48622:     PropertyStub,         /* delProperty */
48622:     PropertyStub,         /* getProperty */
62395:     StrictPropertyStub,   /* setProperty */
48622:     EnumerateStub,
48622:     ResolveStub,
48622:     ConvertStub
    1: };
    1: 
    1: JSObject *
43236: js_InitObjectClass(JSContext *cx, JSObject *obj)
43236: {
53557:     JSObject *proto = js_InitClass(cx, obj, NULL, &js_ObjectClass, js_Object, 1,
43236:                                    object_props, object_methods, NULL, object_static_methods);
43236:     if (!proto)
43236:         return NULL;
43236: 
 2112:     /* ECMA (15.1.2.1) says 'eval' is a property of the global object. */
57721:     jsid id = ATOM_TO_JSID(cx->runtime->atomState.evalAtom);
64228:     JSObject *evalobj = js_DefineFunction(cx, obj, id, eval, 1, JSFUN_STUB_GSOPS);
64228:     if (!evalobj)
    1:         return NULL;
68955:     if (obj->isGlobal())
68955:         obj->asGlobal()->setOriginalEval(evalobj);
    1: 
43236:     return proto;
    1: }
    1: 
42772: static bool
42772: DefineStandardSlot(JSContext *cx, JSObject *obj, JSProtoKey key, JSAtom *atom,
48470:                    const Value &v, uint32 attrs, bool &named)
42772: {
42772:     jsid id = ATOM_TO_JSID(atom);
42772: 
42772:     if (key != JSProto_Null) {
42772:         /*
42772:          * Initializing an actual standard class on a global object. If the
42772:          * property is not yet present, force it into a new one bound to a
42772:          * reserved slot. Otherwise, go through the normal property path.
42772:          */
60566:         JS_ASSERT(obj->isGlobal());
42772:         JS_ASSERT(obj->isNative());
42772: 
56567:         if (!obj->ensureClassReservedSlots(cx))
42772:             return false;
42772: 
52503:         const Shape *shape = obj->nativeLookup(id);
52503:         if (!shape) {
69237:             uint32 slot = 2 * JSProto_LIMIT + key;
56567:             if (!js_SetReservedSlot(cx, obj, slot, v))
42772:                 return false;
62395:             if (!obj->addProperty(cx, id, PropertyStub, StrictPropertyStub, slot, attrs, 0, 0))
42772:                 return false;
42772: 
42772:             named = true;
42772:             return true;
42772:         }
42772:     }
42772: 
62395:     named = obj->defineProperty(cx, id, v, PropertyStub, StrictPropertyStub, attrs);
42772:     return named;
42772: }
42772: 
61705: namespace js {
61705: 
25897: JSObject *
61705: DefineConstructorAndPrototype(JSContext *cx, JSObject *obj, JSProtoKey key, JSAtom *atom,
61705:                               JSObject *protoProto, Class *clasp,
61705:                               Native constructor, uintN nargs,
25897:                               JSPropertySpec *ps, JSFunctionSpec *fs,
28086:                               JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
25897: {
47497:     /*
47497:      * Create a prototype object for this class.
47497:      *
47497:      * FIXME: lazy standard (built-in) class initialization and even older
47497:      * eager boostrapping code rely on all of these properties:
47497:      *
47497:      * 1. NewObject attempting to compute a default prototype object when
47497:      *    passed null for proto; and
47497:      *
47497:      * 2. NewObject tolerating no default prototype (null proto slot value)
47497:      *    due to this js_InitClass call coming from js_InitFunctionClass on an
47497:      *    otherwise-uninitialized global.
47497:      *
47497:      * 3. NewObject allocating a JSFunction-sized GC-thing when clasp is
47497:      *    &js_FunctionClass, not a JSObject-sized (smaller) GC-thing.
47497:      *
47497:      * The JS_NewObjectForGivenProto and JS_NewObject APIs also allow clasp to
47497:      * be &js_FunctionClass (we could break compatibility easily). But fixing
47497:      * (3) is not enough without addressing the bootstrapping dependency on (1)
47497:      * and (2).
47497:      */
61705:     JSObject *proto = NewObject<WithProto::Class>(cx, clasp, protoProto, obj);
25897:     if (!proto)
25897:         return NULL;
25897: 
57806:     proto->syncSpecialEquality();
57806: 
25897:     /* After this point, control must exit via label bad or out. */
48470:     AutoObjectRooter tvr(cx, proto);
48470: 
48470:     JSObject *ctor;
61705:     bool named = false;
25897:     if (!constructor) {
25897:         /*
25897:          * Lacking a constructor, name the prototype (e.g., Math) unless this
25897:          * class (a) is anonymous, i.e. for internal use only; (b) the class
25897:          * of obj (the global object) is has a reserved slot indexed by key;
25897:          * and (c) key is not the null key.
25897:          */
60566:         if (!(clasp->flags & JSCLASS_IS_ANONYMOUS) || !obj->isGlobal() || key == JSProto_Null) {
42772:             uint32 attrs = (clasp->flags & JSCLASS_IS_ANONYMOUS)
25897:                            ? JSPROP_READONLY | JSPROP_PERMANENT
42772:                            : 0;
48470:             if (!DefineStandardSlot(cx, obj, key, atom, ObjectValue(*proto), attrs, named))
25897:                 goto bad;
25897:         }
25897: 
25897:         ctor = proto;
25897:     } else {
61705:         JSFunction *fun = js_NewFunction(cx, NULL, constructor, nargs, JSFUN_CONSTRUCTOR, obj, atom);
25897:         if (!fun)
25897:             goto bad;
25897: 
48470:         AutoValueRooter tvr2(cx, ObjectValue(*fun));
42772:         if (!DefineStandardSlot(cx, obj, key, atom, tvr2.value(), 0, named))
42772:             goto bad;
42772: 
25897:         /*
25897:          * Remember the class this function is a constructor for so that
25897:          * we know to create an object of this class when we call the
48641:          * constructor.
25897:          */
48641:         FUN_CLASP(fun) = clasp;
25897: 
25897:         /*
25897:          * Optionally construct the prototype object, before the class has
25897:          * been fully initialized.  Allow the ctor to replace proto with a
25897:          * different object, as is done for operator new -- and as at least
25897:          * XML support requires.
25897:          */
25897:         ctor = FUN_OBJECT(fun);
25897:         if (clasp->flags & JSCLASS_CONSTRUCT_PROTOTYPE) {
48470:             Value rval;
53557:             if (!InvokeConstructorWithGivenThis(cx, proto, ObjectOrNullValue(ctor),
53557:                                                 0, NULL, &rval)) {
25897:                 goto bad;
53557:             }
48470:             if (rval.isObject() && &rval.toObject() != proto)
48470:                 proto = &rval.toObject();
25897:         }
25897: 
25897:         /* Connect constructor and prototype by named properties. */
25897:         if (!js_SetClassPrototype(cx, ctor, proto,
25897:                                   JSPROP_READONLY | JSPROP_PERMANENT)) {
25897:             goto bad;
25897:         }
25897: 
25897:         /* Bootstrap Function.prototype (see also JS_InitStandardClasses). */
40826:         if (ctor->getClass() == clasp)
39928:             ctor->setProto(proto);
25897:     }
25897: 
25897:     /* Add properties and methods to the prototype and the constructor. */
25897:     if ((ps && !JS_DefineProperties(cx, proto, ps)) ||
25897:         (fs && !JS_DefineFunctions(cx, proto, fs)) ||
25897:         (static_ps && !JS_DefineProperties(cx, ctor, static_ps)) ||
25897:         (static_fs && !JS_DefineFunctions(cx, ctor, static_fs))) {
25897:         goto bad;
25897:     }
25897: 
35117:     /*
57748:      * Pre-brand the prototype and constructor if they have built-in methods.
57748:      * This avoids extra shape guard branch exits in the tracejitted code.
57748:      */
59227:     if (fs)
59227:         proto->brand(cx);
59227:     if (ctor != proto && static_fs)
59227:         ctor->brand(cx);
57748: 
57748:     /*
52503:      * Make sure proto's emptyShape is available to be shared by objects of
52503:      * this class.  JSObject::emptyShape is a one-slot cache. If we omit this,
52503:      * some other class could snap it up. (The risk is particularly great for
52503:      * Object.prototype.)
35117:      *
52503:      * All callers of JSObject::initSharingEmptyShape depend on this.
52513:      *
52513:      * FIXME: bug 592296 -- js_InitArrayClass should pass &js_SlowArrayClass
52513:      * and make the Array.prototype slow from the start.
35117:      */
52513:     JS_ASSERT_IF(proto->clasp != clasp,
52513:                  clasp == &js_ArrayClass && proto->clasp == &js_SlowArrayClass);
55746:     if (!proto->getEmptyShape(cx, proto->clasp, FINALIZE_OBJECT0))
35117:         goto bad;
35117: 
56574:     if (clasp->flags & (JSCLASS_FREEZE_PROTO|JSCLASS_FREEZE_CTOR)) {
56576:         JS_ASSERT_IF(ctor == proto, !(clasp->flags & JSCLASS_FREEZE_CTOR));
56574:         if (proto && (clasp->flags & JSCLASS_FREEZE_PROTO) && !proto->freeze(cx))
56574:             goto bad;
56574:         if (ctor && (clasp->flags & JSCLASS_FREEZE_CTOR) && !ctor->freeze(cx))
56574:             goto bad;
56574:     }
56574: 
25897:     /* If this is a standard class, cache its prototype. */
43258:     if (key != JSProto_Null && !js_SetClassObject(cx, obj, key, ctor, proto))
25897:         goto bad;
25897: 
25897:     return proto;
25897: 
25897: bad:
48470:     if (named) {
48470:         Value rval;
54169:         obj->deleteProperty(cx, ATOM_TO_JSID(atom), &rval, false);
48470:     }
48470:     return NULL;
25897: }
25897: 
69232: /*
69232:  * Lazy standard classes need a way to indicate if they have been initialized.
69232:  * Otherwise, when we delete them, we might accidentally recreate them via a
69232:  * lazy initialization. We use the presence of a ctor or proto in the
69232:  * globalObject's slot to indicate that they've been constructed, but this only
69232:  * works for classes which have a proto and ctor. Classes which don't have one
69232:  * can call MarkStandardClassInitializedNoProto(), and we can always check
69232:  * whether a class is initialized by calling IsStandardClassResolved().
69232:  */
69232: bool
69232: IsStandardClassResolved(JSObject *obj, js::Class *clasp)
69232: {
69232:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
69232: 
69232:     /* If the constructor is undefined, then it hasn't been initialized. */
69237:     return (obj->getReservedSlot(key) != UndefinedValue());
69232: }
69232: 
69232: void
69232: MarkStandardClassInitializedNoProto(JSObject* obj, js::Class *clasp)
69232: {
69232:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
69232: 
69232:     /*
69232:      * We use True so that it's obvious what we're doing (instead of, say,
69232:      * Null, which might be miscontrued as an error in setting Undefined).
69232:      */
69237:     if (obj->getReservedSlot(key) == UndefinedValue())
69232:         obj->setSlot(key, BooleanValue(true));
69232: }
69232: 
61705: }
61705: 
61705: JSObject *
61705: js_InitClass(JSContext *cx, JSObject *obj, JSObject *protoProto,
61705:              Class *clasp, Native constructor, uintN nargs,
61705:              JSPropertySpec *ps, JSFunctionSpec *fs,
61705:              JSPropertySpec *static_ps, JSFunctionSpec *static_fs)
61705: {
70270:     JSAtom *atom = js_Atomize(cx, clasp->name, strlen(clasp->name));
61705:     if (!atom)
61705:         return NULL;
61705: 
61705:     /*
61705:      * All instances of the class will inherit properties from the prototype
61705:      * object we are about to create (in DefineConstructorAndPrototype), which
61705:      * in turn will inherit from protoProto.
61705:      *
61705:      * When initializing a standard class (other than Object), if protoProto is
61705:      * null, default to the Object prototype object. The engine's internal uses
61705:      * of js_InitClass depend on this nicety. Note that in
61705:      * js_InitFunctionAndObjectClasses, we specially hack the resolving table
61705:      * and then depend on js_GetClassPrototype here leaving protoProto NULL and
61705:      * returning true.
61705:      */
61705:     JSProtoKey key = JSCLASS_CACHED_PROTO_KEY(clasp);
61705:     if (key != JSProto_Null &&
61705:         !protoProto &&
61705:         !js_GetClassPrototype(cx, obj, JSProto_Object, &protoProto)) {
61705:         return NULL;
61705:     }
61705: 
61705:     return DefineConstructorAndPrototype(cx, obj, key, atom, protoProto, clasp, constructor, nargs,
61705:                                          ps, fs, static_ps, static_fs);
61705: }
61705: 
40858: bool
55746: JSObject::allocSlots(JSContext *cx, size_t newcap)
55746: {
55746:     uint32 oldcap = numSlots();
55746: 
55746:     JS_ASSERT(newcap >= oldcap && !hasSlotsArray());
55746: 
55746:     if (newcap > NSLOTS_LIMIT) {
55746:         if (!JS_ON_TRACE(cx))
55746:             js_ReportAllocationOverflow(cx);
41117:         return false;
55746:     }
55746: 
64560:     Value *tmpslots = (Value*) cx->malloc_(newcap * sizeof(Value));
55746:     if (!tmpslots)
55746:         return false;  /* Leave slots at inline buffer. */
55746:     slots = tmpslots;
55746:     capacity = newcap;
55746: 
55746:     /* Copy over anything from the inline buffer. */
55746:     memcpy(slots, fixedSlots(), oldcap * sizeof(Value));
55746:     ClearValueRange(slots + oldcap, newcap - oldcap, isDenseArray());
30454:     return true;
30454: }
30454: 
30454: bool
55746: JSObject::growSlots(JSContext *cx, size_t newcap)
30454: {
    1:     /*
55746:      * When an object with CAPACITY_DOUBLING_MAX or fewer slots needs to
55746:      * grow, double its capacity, to add N elements in amortized O(N) time.
55746:      *
55746:      * Above this limit, grow by 12.5% each time. Speed is still amortized
55746:      * O(N), with a higher constant factor, and we waste less space.
    1:      */
55746:     static const size_t CAPACITY_DOUBLING_MAX = 1024 * 1024;
55746:     static const size_t CAPACITY_CHUNK = CAPACITY_DOUBLING_MAX / sizeof(Value);
55746: 
55746:     uint32 oldcap = numSlots();
55746:     JS_ASSERT(oldcap < newcap);
55746: 
55746:     uint32 nextsize = (oldcap <= CAPACITY_DOUBLING_MAX)
55746:                     ? oldcap * 2
55746:                     : oldcap + (oldcap >> 3);
55746: 
55746:     uint32 actualCapacity = JS_MAX(newcap, nextsize);
55746:     if (actualCapacity >= CAPACITY_CHUNK)
55746:         actualCapacity = JS_ROUNDUP(actualCapacity, CAPACITY_CHUNK);
55746:     else if (actualCapacity < SLOT_CAPACITY_MIN)
55746:         actualCapacity = SLOT_CAPACITY_MIN;
52503: 
53650:     /* Don't let nslots get close to wrapping around uint32. */
55746:     if (actualCapacity >= NSLOTS_LIMIT) {
52503:         JS_ReportOutOfMemory(cx);
52503:         return false;
52503:     }
30454: 
55746:     /* If nothing was allocated yet, treat it as initial allocation. */
55746:     if (!hasSlotsArray())
55746:         return allocSlots(cx, actualCapacity);
55746: 
64560:     Value *tmpslots = (Value*) cx->realloc_(slots, oldcap * sizeof(Value), actualCapacity * sizeof(Value));
55746:     if (!tmpslots)
55746:         return false;    /* Leave dslots as its old size. */
55746:     slots = tmpslots;
55746:     capacity = actualCapacity;
30454: 
30454:     /* Initialize the additional slots we added. */
55746:     ClearValueRange(slots + oldcap, actualCapacity - oldcap, isDenseArray());
30454:     return true;
30454: }
30454: 
30454: void
55746: JSObject::shrinkSlots(JSContext *cx, size_t newcap)
55746: {
55746:     uint32 oldcap = numSlots();
55746:     JS_ASSERT(newcap <= oldcap);
55746:     JS_ASSERT(newcap >= slotSpan());
55746: 
55746:     if (oldcap <= SLOT_CAPACITY_MIN || !hasSlotsArray()) {
55746:         /* We won't shrink the slots any more.  Clear excess holes. */
55746:         ClearValueRange(slots + newcap, oldcap - newcap, isDenseArray());
30454:         return;
55746:     }
55746: 
55746:     uint32 fill = newcap;
55746:     if (newcap < SLOT_CAPACITY_MIN)
55746:         newcap = SLOT_CAPACITY_MIN;
58051:     if (newcap < numFixedSlots())
58051:         newcap = numFixedSlots();
55746: 
64560:     Value *tmpslots = (Value*) cx->realloc_(slots, newcap * sizeof(Value));
55746:     if (!tmpslots)
55746:         return;  /* Leave slots at its old size. */
55746:     slots = tmpslots;
55746:     capacity = newcap;
55746: 
55746:     if (fill < newcap) {
55746:         /* Clear any excess holes if we tried to shrink below SLOT_CAPACITY_MIN. */
55746:         ClearValueRange(slots + fill, newcap - fill, isDenseArray());
30454:     }
    1: }
    1: 
30732: bool
52503: JSObject::ensureInstanceReservedSlots(JSContext *cx, size_t nreserved)
52503: {
52503:     JS_ASSERT_IF(isNative(),
54410:                  isBlock() || isCall() || (isFunction() && isBoundFunction()));
52503: 
52503:     uintN nslots = JSSLOT_FREE(clasp) + nreserved;
53650:     return nslots <= numSlots() || allocSlots(cx, nslots);
30732: }
30732: 
18907: static JSObject *
    1: js_InitNullClass(JSContext *cx, JSObject *obj)
    1: {
    1:     JS_ASSERT(0);
    1:     return NULL;
    1: }
    1: 
    1: #define JS_PROTO(name,code,init) extern JSObject *init(JSContext *, JSObject *);
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: 
    1: static JSObjectOp lazy_prototype_init[JSProto_LIMIT] = {
    1: #define JS_PROTO(name,code,init) init,
    1: #include "jsproto.tbl"
    1: #undef JS_PROTO
    1: };
    1: 
47465: namespace js {
47465: 
47465: bool
47465: SetProto(JSContext *cx, JSObject *obj, JSObject *proto, bool checkForCycles)
47465: {
47465:     JS_ASSERT_IF(!checkForCycles, obj != proto);
54563:     JS_ASSERT(obj->isExtensible());
47465: 
47465:     if (obj->isNative()) {
56567:         if (!obj->ensureClassReservedSlots(cx))
47465:             return false;
47465:     }
47465: 
72561:     if (proto && proto->isXML()) {
72561:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_XML_PROTO_FORBIDDEN);
72561:         return false;
72561:     }
72561: 
47465:     /*
47465:      * Regenerate property cache shape ids for all of the scopes along the
47465:      * old prototype chain to invalidate their property cache entries, in
47465:      * case any entries were filled by looking up through obj.
47465:      */
47465:     JSObject *oldproto = obj;
47465:     while (oldproto && oldproto->isNative()) {
52503:         oldproto->protoShapeChange(cx);
56567:         oldproto = oldproto->getProto();
47465:     }
47465: 
70316:     if (checkForCycles) {
70316:         for (JSObject *obj2 = proto; obj2; obj2 = obj2->getProto()) {
70316:             if (obj2 == obj) {
70316:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CYCLIC_VALUE,
70316:                                      js_proto_str);
70316:                 return false;
70316:             }
70316:         }
70316:     }
47465:     obj->setProto(proto);
47465:     return true;
47465: }
47465: 
43258: }
43258: 
    1: JSBool
    1: js_GetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key,
    1:                   JSObject **objp)
    1: {
60566:     obj = obj->getGlobal();
60566:     if (!obj->isGlobal()) {
    1:         *objp = NULL;
64302:         return true;
64302:     }
64302: 
69237:     Value v = obj->getReservedSlot(key);
48470:     if (v.isObject()) {
48470:         *objp = &v.toObject();
64302:         return true;
64302:     }
64302: 
64302:     AutoResolving resolving(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.classAtoms[key]));
64302:     if (resolving.alreadyStarted()) {
64302:         /* Already caching id in obj -- suppress recursion. */
    1:         *objp = NULL;
64302:         return true;
64302:     }
64302: 
64302:     JSObject *cobj = NULL;
64302:     if (JSObjectOp init = lazy_prototype_init[key]) {
64302:         if (!init(cx, obj))
64302:             return false;
69237:         v = obj->getReservedSlot(key);
48470:         if (v.isObject())
48470:             cobj = &v.toObject();
    1:     }
64302: 
    1:     *objp = cobj;
64302:     return true;
    1: }
    1: 
    1: JSBool
43258: js_SetClassObject(JSContext *cx, JSObject *obj, JSProtoKey key, JSObject *cobj, JSObject *proto)
    1: {
39930:     JS_ASSERT(!obj->getParent());
60566:     if (!obj->isGlobal())
    1:         return JS_TRUE;
    1: 
69237:     return js_SetReservedSlot(cx, obj, key, ObjectOrNullValue(cobj)) &&
69237:            js_SetReservedSlot(cx, obj, JSProto_LIMIT + key, ObjectOrNullValue(proto));
    1: }
    1: 
    1: JSBool
38604: js_FindClassObject(JSContext *cx, JSObject *start, JSProtoKey protoKey,
48470:                    Value *vp, Class *clasp)
    1: {
69223:     StackFrame *fp;
    1:     JSObject *obj, *cobj, *pobj;
38604:     jsid id;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1: 
62953:     /*
62953:      * Find the global object. Use cx->fp() directly to avoid falling off
62953:      * trace; all JIT-elided stack frames have the same global object as
62953:      * cx->fp().
62953:      */
62953:     VOUCH_DOES_NOT_REQUIRE_STACK();
62953:     if (!start && (fp = cx->maybefp()) != NULL)
62953:         start = &fp->scopeChain();
62953: 
22652:     if (start) {
62953:         /* Find the topmost object in the scope chain. */
62953:         do {
62953:             obj = start;
62953:             start = obj->getParent();
62953:         } while (start);
    1:     } else {
62953:         obj = cx->globalObject;
62953:         if (!obj) {
62953:             vp->setUndefined();
69855:             return true;
62953:         }
    1:     }
    1: 
    1:     OBJ_TO_INNER_OBJECT(cx, obj);
    1:     if (!obj)
69855:         return false;
    1: 
38604:     if (protoKey != JSProto_Null) {
69237:         JS_ASSERT(JSProto_Null < protoKey);
69237:         JS_ASSERT(protoKey < JSProto_LIMIT);
38604:         if (!js_GetClassObject(cx, obj, protoKey, &cobj))
69855:             return false;
    1:         if (cobj) {
48470:             vp->setObject(*cobj);
    1:             return JS_TRUE;
    1:         }
38604:         id = ATOM_TO_JSID(cx->runtime->atomState.classAtoms[protoKey]);
38604:     } else {
70270:         JSAtom *atom = js_Atomize(cx, clasp->name, strlen(clasp->name));
38604:         if (!atom)
38604:             return false;
38604:         id = ATOM_TO_JSID(atom);
    1:     }
    1: 
40430:     JS_ASSERT(obj->isNative());
69855:     if (!LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_CLASSNAME, &pobj, &prop))
69855:         return false;
48470:     Value v = UndefinedValue();
43290:     if (prop && pobj->isNative()) {
52503:         shape = (Shape *) prop;
52503:         if (pobj->containsSlot(shape->slot)) {
56567:             v = pobj->nativeGetSlot(shape->slot);
48470:             if (v.isPrimitive())
48470:                 v.setUndefined();
 8893:         }
 8893:     }
 8893:     *vp = v;
69855:     return true;
    1: }
    1: 
    1: JSObject *
48470: js_ConstructObject(JSContext *cx, Class *clasp, JSObject *proto, JSObject *parent,
48470:                    uintN argc, Value *argv)
48470: {
40388:     AutoArrayRooter argtvr(cx, argc, argv);
    1: 
38604:     JSProtoKey protoKey = GetClassProtoKey(clasp);
48470: 
48470:     /* Protect constructor in case a crazy getter for .prototype uproots it. */
48470:     AutoValueRooter tvr(cx);
48470:     if (!js_FindClassObject(cx, parent, protoKey, tvr.addr(), clasp))
    1:         return NULL;
    1: 
48470:     const Value &cval = tvr.value();
48470:     if (tvr.value().isPrimitive()) {
48470:         js_ReportIsNotFunction(cx, tvr.addr(), JSV2F_CONSTRUCT | JSV2F_SEARCH_STACK);
    1:         return NULL;
    1:     }
    1: 
    1:     /*
41968:      * If proto is NULL, set it to Constructor.prototype, just like JSOP_NEW
41968:      * does, likewise for the new object's parent.
    1:      */
48470:     JSObject *ctor = &cval.toObject();
    1:     if (!parent)
39930:         parent = ctor->getParent();
    1:     if (!proto) {
48470:         Value rval;
31501:         if (!ctor->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
    1:                                &rval)) {
33178:             return NULL;
    1:         }
48470:         if (rval.isObjectOrNull())
48470:             proto = rval.toObjectOrNull();
48470:     }
48470: 
50450:     JSObject *obj = NewObject<WithProto::Class>(cx, clasp, proto, parent);
    1:     if (!obj)
33178:         return NULL;
    1: 
57806:     obj->syncSpecialEquality();
57806: 
48470:     Value rval;
53557:     if (!InvokeConstructorWithGivenThis(cx, obj, cval, argc, argv, &rval))
33178:         return NULL;
    1: 
48470:     if (rval.isPrimitive())
33178:         return obj;
    1: 
    1:     /*
    1:      * If the instance's class differs from what was requested, throw a type
    1:      * error.  If the given class has both the JSCLASS_HAS_PRIVATE and the
    1:      * JSCLASS_CONSTRUCT_PROTOTYPE flags, and the instance does not have its
    1:      * private data set at this point, then the constructor was replaced and
    1:      * we should throw a type error.
    1:      */
48470:     obj = &rval.toObject();
40826:     if (obj->getClass() != clasp ||
    1:         (!(~clasp->flags & (JSCLASS_HAS_PRIVATE |
    1:                             JSCLASS_CONSTRUCT_PROTOTYPE)) &&
31452:          !obj->getPrivate())) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_WRONG_CONSTRUCTOR, clasp->name);
33178:         return NULL;
33178:     }
    1:     return obj;
    1: }
    1: 
52503: bool
52503: JSObject::allocSlot(JSContext *cx, uint32 *slotp)
52503: {
53652:     uint32 slot = slotSpan();
53650:     JS_ASSERT(slot >= JSSLOT_FREE(clasp));
53650: 
53650:     /*
53650:      * If this object is in dictionary mode and it has a property table, try to
53650:      * pull a free slot from the property table's slot-number freelist.
53650:      */
62399:     if (inDictionaryMode() && lastProp->hasTable()) {
62399:         uint32 &last = lastProp->getTable()->freelist;
53546:         if (last != SHAPE_INVALID_SLOT) {
53650: #ifdef DEBUG
53650:             JS_ASSERT(last < slot);
53650:             uint32 next = getSlot(last).toPrivateUint32();
53650:             JS_ASSERT_IF(next != SHAPE_INVALID_SLOT, next < slot);
53650: #endif
53650: 
53546:             *slotp = last;
53546: 
53546:             Value &vref = getSlotRef(last);
53546:             last = vref.toPrivateUint32();
53546:             vref.setUndefined();
53546:             return true;
53546:         }
53546:     }
53546: 
53650:     if (slot >= numSlots() && !growSlots(cx, slot + 1))
52503:         return false;
52503: 
52503:     /* JSObject::growSlots or JSObject::freeSlot should set the free slots to void. */
53650:     JS_ASSERT(getSlot(slot).isUndefined());
53650:     *slotp = slot;
52503:     return true;
    1: }
    1: 
58749: bool
52503: JSObject::freeSlot(JSContext *cx, uint32 slot)
52503: {
53652:     uint32 limit = slotSpan();
53650:     JS_ASSERT(slot < limit);
52503: 
53546:     Value &vref = getSlotRef(slot);
62399:     if (inDictionaryMode() && lastProp->hasTable()) {
62399:         uint32 &last = lastProp->getTable()->freelist;
53546: 
53650:         /* Can't afford to check the whole freelist, but let's check the head. */
53650:         JS_ASSERT_IF(last != SHAPE_INVALID_SLOT, last < limit && last != slot);
53650: 
53650:         /*
53650:          * Freeing a slot other than the last one mapped by this object's
54416:          * shape (and not a reserved slot; see bug 595230): push the slot onto
54416:          * the dictionary property table's freelist. We want to let the last
54416:          * slot be freed by shrinking the dslots vector; see js_TraceObject.
53650:          */
54416:         if (JSSLOT_FREE(clasp) <= slot && slot + 1 < limit) {
53652:             JS_ASSERT_IF(last != SHAPE_INVALID_SLOT, last < slotSpan());
53546:             vref.setPrivateUint32(last);
53546:             last = slot;
58749:             return true;
53546:         }
53546:     }
53546:     vref.setUndefined();
58749:     return false;
52503: }
30270: 
48470: /* JSBOXEDWORD_INT_MAX as a string */
48470: #define JSBOXEDWORD_INT_MAX_STRING "1073741823"
30270: 
30270: /*
30270:  * Convert string indexes that convert to int jsvals as ints to save memory.
30270:  * Care must be taken to use this macro every time a property name is used, or
30270:  * else double-sets, incorrect property cache misses, or other mistakes could
30270:  * occur.
30270:  */
11524: jsid
30270: js_CheckForStringIndex(jsid id)
    1: {
30270:     if (!JSID_IS_ATOM(id))
30270:         return id;
30270: 
30270:     JSAtom *atom = JSID_TO_ATOM(id);
64345:     const jschar *s = atom->chars();
30270:     jschar ch = *s;
30270: 
30270:     JSBool negative = (ch == '-');
30270:     if (negative)
30270:         ch = *++s;
30270: 
30270:     if (!JS7_ISDEC(ch))
30270:         return id;
30270: 
64345:     size_t n = atom->length() - negative;
48470:     if (n > sizeof(JSBOXEDWORD_INT_MAX_STRING) - 1)
30270:         return id;
30270: 
30270:     const jschar *cp = s;
30270:     const jschar *end = s + n;
30270: 
    1:     jsuint index = JS7_UNDEC(*cp++);
    1:     jsuint oldIndex = 0;
    1:     jsuint c = 0;
    1: 
    1:     if (index != 0) {
    1:         while (JS7_ISDEC(*cp)) {
    1:             oldIndex = index;
    1:             c = JS7_UNDEC(*cp);
    1:             index = 10 * index + c;
    1:             cp++;
    1:         }
    1:     }
22608: 
22608:     /*
22608:      * Non-integer indexes can't be represented as integers.  Also, distinguish
48470:      * index "-0" from "0", because JSBOXEDWORD_INT cannot.
22608:      */
22608:     if (cp != end || (negative && index == 0))
22608:         return id;
30270: 
55493:     if (negative) {
55493:         if (oldIndex < -(JSID_INT_MIN / 10) ||
55493:             (oldIndex == -(JSID_INT_MIN / 10) && c <= (-JSID_INT_MIN % 10)))
55493:         {
57776:             id = INT_TO_JSID(-jsint(index));
55493:         }
55493:     } else {
48470:         if (oldIndex < JSID_INT_MAX / 10 ||
55493:             (oldIndex == JSID_INT_MAX / 10 && c <= (JSID_INT_MAX % 10)))
55493:         {
55493:             id = INT_TO_JSID(jsint(index));
55493:         }
    1:     }
30270: 
    1:     return id;
    1: }
    1: 
    1: static JSBool
11377: PurgeProtoChain(JSContext *cx, JSObject *obj, jsid id)
    1: {
52503:     const Shape *shape;
11377: 
11377:     while (obj) {
40430:         if (!obj->isNative()) {
39928:             obj = obj->getProto();
11377:             continue;
11377:         }
52503:         shape = obj->nativeLookup(id);
52503:         if (shape) {
18308:             PCMETER(JS_PROPERTY_CACHE(cx).pcpurges++);
52503:             obj->shadowingShapeChange(cx, *shape);
27019: 
39930:             if (!obj->getParent()) {
27019:                 /*
27019:                  * All scope chains end in a global object, so this will change
27019:                  * the global shape. jstracer.cpp assumes that the global shape
27019:                  * never changes on trace, so we must deep-bail here.
27019:                  */
37741:                 LeaveTrace(cx);
27019:             }
11377:             return JS_TRUE;
11377:         }
32603:         obj = obj->getProto();
11377:     }
    1:     return JS_FALSE;
11377: }
11377: 
25936: void
25936: js_PurgeScopeChainHelper(JSContext *cx, JSObject *obj, jsid id)
    1: {
32603:     JS_ASSERT(obj->isDelegate());
32603:     PurgeProtoChain(cx, obj->getProto(), id);
28397: 
28397:     /*
28397:      * We must purge the scope chain only for Call objects as they are the only
28397:      * kind of cacheable non-global object that can gain properties after outer
28397:      * properties with the same names have been cached or traced. Call objects
28397:      * may gain such properties via eval introducing new vars; see bug 490364.
28397:      */
52503:     if (obj->isCall()) {
39930:         while ((obj = obj->getParent()) != NULL) {
11377:             if (PurgeProtoChain(cx, obj, id))
28397:                 break;
28397:         }
11377:     }
    1: }
    1: 
52503: const Shape *
    1: js_AddNativeProperty(JSContext *cx, JSObject *obj, jsid id,
62395:                      PropertyOp getter, StrictPropertyOp setter, uint32 slot,
    1:                      uintN attrs, uintN flags, intN shortid)
    1: {
52503:     JS_ASSERT(!(flags & Shape::METHOD));
32658: 
11377:     /*
11377:      * Purge the property cache of now-shadowed id in obj's scope chain. Do
11377:      * this optimistically (assuming no failure below) before locking obj, so
11377:      * we can lock the shadowed scope.
11377:      */
25936:     js_PurgeScopeChain(cx, obj, id);
11377: 
56567:     if (!obj->ensureClassReservedSlots(cx))
56567:         return NULL;
56567: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
56567:     return obj->putProperty(cx, id, getter, setter, slot, attrs, flags, shortid);
52503: }
52503: 
52503: const Shape *
    1: js_ChangeNativePropertyAttrs(JSContext *cx, JSObject *obj,
52503:                              const Shape *shape, uintN attrs, uintN mask,
62395:                              PropertyOp getter, StrictPropertyOp setter)
    1: {
56567:     if (!obj->ensureClassReservedSlots(cx))
56567:         return NULL;
62790: 
62790:     /*
62790:      * Check for freezing an object with shape-memoized methods here, on a
62790:      * shape-by-shape basis. Note that getter may be a pun of the method's
62790:      * joined function object value, to indicate "no getter change". In this
62790:      * case we must null getter to get the desired PropertyStub behavior.
62790:      */
62790:     if ((attrs & JSPROP_READONLY) && shape->isMethod()) {
62790:         JSObject *funobj = &shape->methodObject();
62790:         Value v = ObjectValue(*funobj);
62790: 
62790:         shape = obj->methodReadBarrier(cx, *shape, &v);
62790:         if (!shape)
62790:             return NULL;
62790: 
62790:         if (CastAsObject(getter) == funobj) {
62790:             JS_ASSERT(!(attrs & JSPROP_GETTER));
62790:             getter = NULL;
62790:         }
62790:     }
62790: 
56567:     return obj->changeProperty(cx, shape, attrs, mask, getter, setter);
    1: }
    1: 
    1: JSBool
48470: js_DefineProperty(JSContext *cx, JSObject *obj, jsid id, const Value *value,
62395:                   PropertyOp getter, StrictPropertyOp setter, uintN attrs)
48470: {
69855:     return !!DefineNativeProperty(cx, obj, id, *value, getter, setter, attrs, 0, 0);
    1: }
    1: 
    1: /*
    1:  * Backward compatibility requires allowing addProperty hooks to mutate the
53650:  * nominal initial value of a slotful property, while GC safety wants that
    1:  * value to be stored before the call-out through the hook.  Optimize to do
    1:  * both while saving cycles for classes that stub their addProperty hook.
    1:  */
32658: static inline bool
52503: CallAddPropertyHook(JSContext *cx, Class *clasp, JSObject *obj, const Shape *shape, Value *vp)
48470: {
48470:     if (clasp->addProperty != PropertyStub) {
48470:         Value nominal = *vp;
32658: 
69637:         if (!CallJSPropertyOp(cx, clasp->addProperty, obj, shape->propid, vp))
32658:             return false;
32658:         if (*vp != nominal) {
52503:             if (obj->containsSlot(shape->slot))
56567:                 obj->nativeSetSlot(shape->slot, *vp);
32658:         }
32658:     }
32658:     return true;
32658: }
    1: 
69855: namespace js {
69855: 
69855: const Shape *
69855: DefineNativeProperty(JSContext *cx, JSObject *obj, jsid id, const Value &value,
62395:                      PropertyOp getter, StrictPropertyOp setter, uintN attrs,
69855:                      uintN flags, intN shortid, uintN defineHow /* = 0 */)
69855: {
69855:     JS_ASSERT((defineHow & ~(DNP_CACHE_RESULT | DNP_DONT_PURGE | DNP_SET_METHOD)) == 0);
37741:     LeaveTraceIfGlobalObject(cx, obj);
27492: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
    1: 
    1:     /*
    1:      * If defining a getter or setter, we must check for its counterpart and
    1:      * update the attributes and property ops.  A getter or setter is really
    1:      * only half of a property.
    1:      */
62034:     const Shape *shape = NULL;
    1:     if (attrs & (JSPROP_GETTER | JSPROP_SETTER)) {
    1:         JSObject *pobj;
    1:         JSProperty *prop;
    1: 
    1:         /*
69855:          * If we are defining a getter whose setter was already defined, or
69855:          * vice versa, finish the job via obj->changeProperty, and refresh the
69855:          * property cache line for (obj, id) to map shape.
    1:          */
    1:         if (!js_LookupProperty(cx, obj, id, &pobj, &prop))
69855:             return NULL;
69855:         if (prop && pobj == obj) {
69855:             shape = (const Shape *) prop;
69855:             if (shape->isAccessorDescriptor()) {
52503:                 shape = obj->changeProperty(cx, shape, attrs,
33152:                                             JSPROP_GETTER | JSPROP_SETTER,
    1:                                             (attrs & JSPROP_GETTER)
    1:                                             ? getter
52503:                                             : shape->getter(),
    1:                                             (attrs & JSPROP_SETTER)
    1:                                             ? setter
52503:                                             : shape->setter());
52503:                 if (!shape)
69855:                     return NULL;
69855:             } else {
52503:                 shape = NULL;
    1:             }
    1:         }
69855:     }
    1: 
11377:     /*
28397:      * Purge the property cache of any properties named by id that are about
28397:      * to be shadowed in obj's scope chain unless it is known a priori that it
28397:      * is not possible. We do this before locking obj to avoid nesting locks.
28312:      */
69855:     if (!(defineHow & DNP_DONT_PURGE))
28312:         js_PurgeScopeChain(cx, obj, id);
28312: 
28312:     /*
28312:      * Check whether a readonly property or setter is being defined on a known
28312:      * prototype object. See the comment in jscntxt.h before protoHazardShape's
28312:      * member declaration.
11377:      */
32603:     if (obj->isDelegate() && (attrs & (JSPROP_READONLY | JSPROP_SETTER)))
62077:         cx->runtime->protoHazardShape = js_GenerateShape(cx);
11377: 
    1:     /* Use the object's class getter and setter by default. */
62034:     Class *clasp = obj->getClass();
69855:     if (!(defineHow & DNP_SET_METHOD)) {
41860:         if (!getter && !(attrs & JSPROP_GETTER))
    1:             getter = clasp->getProperty;
41860:         if (!setter && !(attrs & JSPROP_SETTER))
    1:             setter = clasp->setProperty;
32658:     }
    1: 
    1:     /* Get obj's own scope if it has one, or create a new one for obj. */
52503:     if (!obj->ensureClassReservedSlots(cx))
69855:         return NULL;
    1: 
62790:     /*
62790:      * Make a local copy of value, in case a method barrier needs to update the
62790:      * value to define, and just so addProperty can mutate its inout parameter.
62790:      */
62790:     Value valueCopy = value;
62790:     bool adding = false;
62790: 
52503:     if (!shape) {
18750:         /* Add a new property, or replace an existing one of the same id. */
69855:         if (defineHow & DNP_SET_METHOD) {
32658:             JS_ASSERT(clasp == &js_ObjectClass);
48470:             JS_ASSERT(IsFunctionObject(value));
32658:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658:             JS_ASSERT(!getter && !setter);
32658: 
48470:             JSObject *funobj = &value.toObject();
32658:             if (FUN_OBJECT(GET_FUNCTION_PRIVATE(cx, funobj)) == funobj) {
52503:                 flags |= Shape::METHOD;
41860:                 getter = CastAsPropertyOp(funobj);
32658:             }
32658:         }
32658: 
62034:         if (const Shape *existingShape = obj->nativeLookup(id)) {
62034:             if (existingShape->hasSlot())
62034:                 AbortRecordingIfUnexpectedGlobalWrite(cx, obj, existingShape->slot);
62790: 
62790:             if (existingShape->isMethod() &&
62790:                 ObjectValue(existingShape->methodObject()) == valueCopy)
62790:             {
62790:                 /*
62790:                  * Redefining an existing shape-memoized method object without
62790:                  * changing the property's value, perhaps to change attributes.
62790:                  * Clone now via the method read barrier.
62790:                  *
62790:                  * But first, assert that our caller is not trying to preserve
62790:                  * the joined function object value as the getter object for
62790:                  * the redefined property. The joined function object cannot
62790:                  * yet have leaked, so only an internal code path could attempt
62790:                  * such a thing. Any such path would be a bug to fix.
62790:                  */
62790:                 JS_ASSERT(existingShape->getter() != getter);
62790: 
62790:                 if (!obj->methodReadBarrier(cx, *existingShape, &valueCopy))
69855:                     return NULL;
62790:             }
62034:         } else {
62790:             adding = true;
62034:         }
62034: 
52503:         uint32 oldShape = obj->shape();
52503:         shape = obj->putProperty(cx, id, getter, setter, SHAPE_INVALID_SLOT,
35334:                                  attrs, flags, shortid);
52503:         if (!shape)
69855:             return NULL;
41851: 
41851:         /*
62790:          * If shape is a joined method, the above call to putProperty suffices
62790:          * to update the object's shape id if need be (because the shape's hash
62790:          * identity includes the method value).
62790:          *
62790:          * But if scope->branded(), the object's shape id may not have changed
62790:          * and we may be overwriting a cached function-valued property (note
62790:          * how methodWriteBarrier checks previous vs. would-be current value).
62790:          * See bug 560998.
41851:          */
60797:         if (obj->shape() == oldShape && obj->branded() && shape->slot != SHAPE_INVALID_SLOT) {
68941:             DebugOnly<const Shape*> newshape =
62790:                 obj->methodWriteBarrier(cx, *shape, valueCopy);
60797:             JS_ASSERT(newshape == shape);
60797:         }
14646:     }
    1: 
62790:     /* Store valueCopy before calling addProperty, in case the latter GC's. */
62034:     if (obj->containsSlot(shape->slot))
62790:         obj->nativeSetSlot(shape->slot, valueCopy);
    1: 
    1:     /* XXXbe called with lock held */
52503:     if (!CallAddPropertyHook(cx, clasp, obj, shape, &valueCopy)) {
52503:         obj->removeProperty(cx, id);
69855:         return NULL;
69855:     }
69855: 
69855:     if (defineHow & DNP_CACHE_RESULT) {
59009:         JS_ASSERT_NOT_ON_TRACE(cx);
62790:         if (adding) {
69855:             JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, obj, shape, true);
60780:             TRACE_1(AddProperty, obj);
59009:         }
24852:     }
69855:     return shape;
56567: 
58283: #ifdef JS_TRACER
69855:   error:
69855:     /* TRACE_1 jumps here on error. */
69855:     return NULL;
58283: #endif
69855: }
69855: 
69855: } /* namespace js */
10217: 
    1: /*
64217:  * Call obj's resolve hook.
43260:  *
43260:  * cx, start, id, and flags are the parameters initially passed to the ongoing
43260:  * lookup; objp and propp are its out parameters. obj is an object along
43260:  * start's prototype chain.
43260:  *
43260:  * There are four possible outcomes:
43260:  *
64217:  *   - On failure, report an error or exception and return false.
43260:  *
64217:  *   - If we are already resolving a property of *curobjp, set *recursedp = true,
64217:  *     and return true.
43260:  *
43260:  *   - If the resolve hook finds or defines the sought property, set *objp and
64217:  *     *propp appropriately, set *recursedp = false, and return true.
43260:  *
43260:  *   - Otherwise no property was resolved. Set *propp = NULL and *recursedp = false
43260:  *     and return true.
43260:  */
43260: static JSBool
43260: CallResolveOp(JSContext *cx, JSObject *start, JSObject *obj, jsid id, uintN flags,
43260:               JSObject **objp, JSProperty **propp, bool *recursedp)
43260: {
48470:     Class *clasp = obj->getClass();
43260:     JSResolveOp resolve = clasp->resolve;
43260: 
43260:     /*
43260:      * Avoid recursion on (obj, id) already being resolved on cx.
43260:      *
    1:      * Once we have successfully added an entry for (obj, key) to
    1:      * cx->resolvingTable, control must go through cleanup: before
    1:      * returning.  But note that JS_DHASH_ADD may find an existing
    1:      * entry, in which case we bail to suppress runaway recursion.
    1:      */
64302:     AutoResolving resolving(cx, obj, id);
64302:     if (resolving.alreadyStarted()) {
    1:         /* Already resolving id in obj -- suppress recursion. */
43260:         *recursedp = true;
43260:         return true;
43260:     }
43260:     *recursedp = false;
43260: 
    1:     *propp = NULL;
    1: 
    1:     if (clasp->flags & JSCLASS_NEW_RESOLVE) {
64217:         JSNewResolveOp newresolve = reinterpret_cast<JSNewResolveOp>(resolve);
69855:         if (flags == RESOLVE_INFER)
52503:             flags = js_InferFlags(cx, 0);
43260:         JSObject *obj2 = (clasp->flags & JSCLASS_NEW_RESOLVE_GETS_START) ? start : NULL;
64302:         if (!newresolve(cx, obj, id, flags, &obj2))
64302:             return false;
    1: 
64217:         /*
64217:          * We trust the new style resolve hook to set obj2 to NULL when
64217:          * the id cannot be resolved. But, when obj2 is not null, we do
64217:          * not assume that id must exist and do full nativeLookup for
64217:          * compatibility.
64217:          */
64217:         if (!obj2)
64302:             return true;
64217: 
40430:         if (!obj2->isNative()) {
    1:             /* Whoops, newresolve handed back a foreign obj2. */
    1:             JS_ASSERT(obj2 != obj);
64302:             return obj2->lookupProperty(cx, id, objp, propp);
64217:         }
64217:         obj = obj2;
    1:     } else {
64302:         if (!resolve(cx, obj, id))
64302:             return false;
64217:     }
64217: 
64217:     if (!obj->nativeEmpty()) {
64217:         if (const Shape *shape = obj->nativeLookup(id)) {
43260:             *objp = obj;
52503:             *propp = (JSProperty *) shape;
43260:         }
64217:     }
64217: 
64302:     return true;
43260: }
43260: 
69855: static JS_ALWAYS_INLINE bool
69855: LookupPropertyWithFlagsInline(JSContext *cx, JSObject *obj, jsid id, uintN flags,
43260:                               JSObject **objp, JSProperty **propp)
43260: {
56740:     /* We should not get string indices which aren't already integers here. */
56740:     JS_ASSERT(id == js_CheckForStringIndex(id));
43260: 
43260:     /* Search scopes starting with obj and following the prototype link. */
43260:     JSObject *start = obj;
72559:     while (true) {
52503:         const Shape *shape = obj->nativeLookup(id);
52503:         if (shape) {
30645:             *objp = obj;
52503:             *propp = (JSProperty *) shape;
69855:             return true;
    1:         }
    1: 
43260:         /* Try obj's class resolve hook if id was not found in obj's scope. */
69855:         if (obj->getClass()->resolve != JS_ResolveStub) {
43260:             bool recursed;
43260:             if (!CallResolveOp(cx, start, obj, id, flags, objp, propp, &recursed))
69855:                 return false;
43260:             if (recursed)
43260:                 break;
43260:             if (*propp) {
69855:                 /*
69855:                  * For stats we do not recalculate protoIndex even if it was
69855:                  * resolved on some other object.
69855:                  */
69855:                 return true;
43260:             }
43260:         }
43260: 
43260:         JSObject *proto = obj->getProto();
    1:         if (!proto)
    1:             break;
40430:         if (!proto->isNative()) {
31501:             if (!proto->lookupProperty(cx, id, objp, propp))
69855:                 return false;
60172: #ifdef DEBUG
60172:             /*
60172:              * Non-native objects must have either non-native lookup results,
60172:              * or else native results from the non-native's prototype chain.
60172:              *
69223:              * See StackFrame::getValidCalleeObject, where we depend on this
60172:              * fact to force a prototype-delegated joined method accessed via
60172:              * arguments.callee through the delegating |this| object's method
60172:              * read barrier.
60172:              */
60172:             if (*propp && (*objp)->isNative()) {
60172:                 while ((proto = proto->getProto()) != *objp)
60172:                     JS_ASSERT(proto);
60172:             }
60172: #endif
69855:             return true;
10217:         }
30645: 
    1:         obj = proto;
    1:     }
    1: 
    1:     *objp = NULL;
    1:     *propp = NULL;
69855:     return true;
10217: }
10217: 
56740: JS_FRIEND_API(JSBool)
56740: js_LookupProperty(JSContext *cx, JSObject *obj, jsid id, JSObject **objp,
56740:                   JSProperty **propp)
56740: {
56740:     /* Convert string indices to integers if appropriate. */
56740:     id = js_CheckForStringIndex(id);
56740: 
69855:     return LookupPropertyWithFlagsInline(cx, obj, id, cx->resolveFlags, objp, propp);
69855: }
69855: 
69855: namespace js {
69855: 
69855: bool
69855: LookupPropertyWithFlags(JSContext *cx, JSObject *obj, jsid id, uintN flags,
55535:                         JSObject **objp, JSProperty **propp)
55535: {
56740:     /* Convert string indices to integers if appropriate. */
56740:     id = js_CheckForStringIndex(id);
56740: 
69855:     return LookupPropertyWithFlagsInline(cx, obj, id, flags, objp, propp);
69855: }
69855: 
69855: } /* namespace js */
55535: 
40362: PropertyCacheEntry *
27575: js_FindPropertyHelper(JSContext *cx, jsid id, JSBool cacheResult,
27575:                       JSObject **objp, JSObject **pobjp, JSProperty **propp)
    1: {
27539:     JSObject *scopeChain, *obj, *parent, *pobj;
40362:     PropertyCacheEntry *entry;
69855:     int scopeIndex;
    1:     JSProperty *prop;
27575: 
27575:     JS_ASSERT_IF(cacheResult, !JS_ON_TRACE(cx));
53840:     scopeChain = &js_GetTopStackFrame(cx)->scopeChain();
27539: 
27539:     /* Scan entries on the scope chain that we can cache across. */
27575:     entry = JS_NO_PROP_CACHE_FILL;
27539:     obj = scopeChain;
39930:     parent = obj->getParent();
27539:     for (scopeIndex = 0;
27539:          parent
63085:          ? IsCacheableNonGlobalScope(obj)
48622:          : !obj->getOps()->lookupProperty;
27539:          ++scopeIndex) {
69855:         if (!LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags, &pobj, &prop))
27575:             return NULL;
27539: 
27539:         if (prop) {
27539: #ifdef DEBUG
27539:             if (parent) {
48470:                 Class *clasp = obj->getClass();
40430:                 JS_ASSERT(pobj->isNative());
40826:                 JS_ASSERT(pobj->getClass() == clasp);
27539:                 if (clasp == &js_BlockClass) {
27539:                     /*
69855:                      * A block instance on the scope chain is immutable and
69855:                      * shares its shape with the compile-time prototype. Thus
69855:                      * we cannot find any property on the prototype.
27539:                      */
53650:                     JS_ASSERT(pobj->isClonedBlock());
11377:                 } else {
27539:                     /* Call and DeclEnvClass objects have no prototypes. */
39928:                     JS_ASSERT(!obj->getProto());
69855:                 }
69855:                 JS_ASSERT(pobj == obj);
42726:             } else {
42726:                 JS_ASSERT(obj->isNative());
27539:             }
27539: #endif
42726:             /*
42726:              * We must check if pobj is native as a global object can have
42726:              * non-native prototype.
42726:              */
42726:             if (cacheResult && pobj->isNative()) {
69855:                 entry = JS_PROPERTY_CACHE(cx).fill(cx, scopeChain, scopeIndex, pobj,
52503:                                                    (Shape *) prop);
27539:             }
27539:             goto out;
27539:         }
27539: 
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             goto out;
27539:         }
27539:         obj = parent;
39930:         parent = obj->getParent();
27539:     }
27539: 
27539:     for (;;) {
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
27575:             return NULL;
27539:         if (prop) {
11377:             PCMETER(JS_PROPERTY_CACHE(cx).nofills++);
27539:             goto out;
27539:         }
27539: 
27539:         /*
27539:          * We conservatively assume that a resolve hook could mutate the scope
31501:          * chain during JSObject::lookupProperty. So we read parent here again.
27539:          */
39930:         parent = obj->getParent();
27539:         if (!parent) {
27539:             pobj = NULL;
27539:             break;
27539:         }
27539:         obj = parent;
27539:     }
27539: 
27539:   out:
27539:     JS_ASSERT(!!pobj == !!prop);
    1:     *objp = obj;
    1:     *pobjp = pobj;
    1:     *propp = prop;
27575:     return entry;
    1: }
    1: 
57125: /*
57125:  * On return, if |*pobjp| is a native object, then |*propp| is a |Shape *|.
57125:  * Otherwise, its type and meaning depends on the host object's implementation.
57125:  */
    1: JS_FRIEND_API(JSBool)
    1: js_FindProperty(JSContext *cx, jsid id, JSObject **objp, JSObject **pobjp,
    1:                 JSProperty **propp)
    1: {
27575:     return !!js_FindPropertyHelper(cx, id, false, objp, pobjp, propp);
    1: }
    1: 
27319: JSObject *
27575: js_FindIdentifierBase(JSContext *cx, JSObject *scopeChain, jsid id)
    1: {
27237:     /*
27237:      * This function should not be called for a global object or from the
27237:      * trace and should have a valid cache entry for native scopeChain.
27237:      */
39930:     JS_ASSERT(scopeChain->getParent());
27237:     JS_ASSERT(!JS_ON_TRACE(cx));
27237: 
27319:     JSObject *obj = scopeChain;
27319: 
27237:     /*
27319:      * Loop over cacheable objects on the scope chain until we find a
27319:      * property. We also stop when we reach the global object skipping any
27319:      * farther checks or lookups. For details see the JSOP_BINDNAME case of
27319:      * js_Interpret.
41775:      *
63085:      * The test order here matters because IsCacheableNonGlobalScope
41775:      * must not be passed a global object (i.e. one with null parent).
27237:      */
41775:     for (int scopeIndex = 0;
63085:          !obj->getParent() || IsCacheableNonGlobalScope(obj);
41775:          scopeIndex++) {
27237:         JSObject *pobj;
27236:         JSProperty *prop;
69855:         if (!LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags, &pobj, &prop))
27237:             return NULL;
27237:         if (prop) {
42726:             if (!pobj->isNative()) {
42726:                 JS_ASSERT(!obj->getParent());
42726:                 return obj;
42726:             }
42726:             JS_ASSERT_IF(obj->getParent(), pobj->getClass() == obj->getClass());
68941:             DebugOnly<PropertyCacheEntry*> entry =
69855:                 JS_PROPERTY_CACHE(cx).fill(cx, scopeChain, scopeIndex, pobj, (Shape *) prop);
27575:             JS_ASSERT(entry);
27237:             return obj;
27237:         }
27237: 
41775:         JSObject *parent = obj->getParent();
41775:         if (!parent)
27237:             return obj;
41775:         obj = parent;
27237:     }
27319: 
27319:     /* Loop until we find a property or reach the global object. */
27237:     do {
27237:         JSObject *pobj;
27237:         JSProperty *prop;
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:             return NULL;
56567:         if (prop)
27237:             break;
27319: 
27319:         /*
27319:          * We conservatively assume that a resolve hook could mutate the scope
31501:          * chain during JSObject::lookupProperty. So we must check if parent is
31501:          * not null here even if it wasn't before the lookup.
27319:          */
39930:         JSObject *parent = obj->getParent();
27319:         if (!parent)
27319:             break;
27237:         obj = parent;
39930:     } while (obj->getParent());
    1:     return obj;
    1: }
    1: 
55535: static JS_ALWAYS_INLINE JSBool
57739: js_NativeGetInline(JSContext *cx, JSObject *receiver, JSObject *obj, JSObject *pobj,
57739:                    const Shape *shape, uintN getHow, Value *vp)
    1: {
37741:     LeaveTraceIfGlobalObject(cx, pobj);
27490: 
27490:     uint32 slot;
27490:     int32 sample;
27490: 
40430:     JS_ASSERT(pobj->isNative());
52503: 
52503:     slot = shape->slot;
55746:     if (slot != SHAPE_INVALID_SLOT) {
56567:         *vp = pobj->nativeGetSlot(slot);
55746:         JS_ASSERT(!vp->isMagic());
55746:     } else {
48470:         vp->setUndefined();
55746:     }
52503:     if (shape->hasDefaultGetter())
32658:         return true;
32658: 
52503:     if (JS_UNLIKELY(shape->isMethod()) && (getHow & JSGET_NO_METHOD_BARRIER)) {
68893:         JS_ASSERT(shape->methodObject() == vp->toObject());
32658:         return true;
32658:     }
27490: 
27490:     sample = cx->runtime->propertyRemovals;
52503:     {
52503:         AutoShapeRooter tvr(cx, shape);
48470:         AutoObjectRooter tvr2(cx, pobj);
57739:         if (!shape->get(cx, receiver, obj, pobj, vp))
32658:             return false;
40221:     }
52503: 
52503:     if (pobj->containsSlot(slot) &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
52503:          pobj->nativeContains(*shape))) {
56567:         if (!pobj->methodWriteBarrier(cx, *shape, *vp))
32658:             return false;
56567:         pobj->nativeSetSlot(slot, *vp);
32658:     }
32658: 
32658:     return true;
    1: }
    1: 
    1: JSBool
55535: js_NativeGet(JSContext *cx, JSObject *obj, JSObject *pobj, const Shape *shape, uintN getHow,
55535:              Value *vp)
55535: {
57739:     return js_NativeGetInline(cx, obj, obj, pobj, shape, getHow, vp);
55535: }
55535: 
55535: JSBool
62395: js_NativeSet(JSContext *cx, JSObject *obj, const Shape *shape, bool added, bool strict, Value *vp)
    1: {
37741:     LeaveTraceIfGlobalObject(cx, obj);
27490: 
27490:     uint32 slot;
27490:     int32 sample;
27490: 
40430:     JS_ASSERT(obj->isNative());
52503: 
52503:     slot = shape->slot;
52503:     if (slot != SHAPE_INVALID_SLOT) {
56567:         JS_ASSERT(obj->containsSlot(slot));
27490: 
52503:         /* If shape has a stub setter, keep obj locked and just store *vp. */
52503:         if (shape->hasDefaultSetter()) {
62034:             if (!added) {
62034:                 AbortRecordingIfUnexpectedGlobalWrite(cx, obj, slot);
62381: 
62381:                 /* FIXME: This should pass *shape, not slot, but see bug 630354. */
62381:                 if (!obj->methodWriteBarrier(cx, slot, *vp))
32658:                     return false;
62034:             }
56567:             obj->nativeSetSlot(slot, *vp);
32658:             return true;
32658:         }
27490:     } else {
    1:         /*
    1:          * Allow API consumers to create shared properties with stub setters.
36491:          * Such properties effectively function as data descriptors which are
36491:          * not writable, so attempting to set such a property should do nothing
36491:          * or throw if we're in strict mode.
    1:          */
52503:         if (!shape->hasGetterValue() && shape->hasDefaultSetter())
36491:             return js_ReportGetterOnlyAssignment(cx);
    1:     }
27490: 
27490:     sample = cx->runtime->propertyRemovals;
52503:     {
52503:         AutoShapeRooter tvr(cx, shape);
62395:         if (!shape->set(cx, obj, strict, vp))
32658:             return false;
60552: 
60552:         JS_ASSERT_IF(!obj->inDictionaryMode(), shape->slot == slot);
60552:         slot = shape->slot;
40221:     }
    1: 
52503:     if (obj->containsSlot(slot) &&
    1:         (JS_LIKELY(cx->runtime->propertyRemovals == sample) ||
52503:          obj->nativeContains(*shape))) {
62034:         if (!added) {
62034:             AbortRecordingIfUnexpectedGlobalWrite(cx, obj, slot);
62034:             if (!obj->methodWriteBarrier(cx, *shape, *vp))
32658:                 return false;
62034:         }
56567:         obj->setSlot(slot, *vp);
32658:     }
32658: 
32658:     return true;
    1: }
    1: 
54177: static JS_ALWAYS_INLINE bool
56817: js_GetPropertyHelperWithShapeInline(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id,
54172:                                     uintN getHow, Value *vp,
54172:                                     const Shape **shapeOut, JSObject **holderOut)
    1: {
25942:     JSObject *aobj, *obj2;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1: 
32658:     JS_ASSERT_IF(getHow & JSGET_CACHE_RESULT, !JS_ON_TRACE(cx));
32658: 
54172:     *shapeOut = NULL;
54172: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
39928:     aobj = js_GetProtoIfDenseArray(obj);
69855:     /* This call site is hot -- use the always-inlined variant of LookupPropertyWithFlags(). */
69855:     if (!LookupPropertyWithFlagsInline(cx, aobj, id, cx->resolveFlags, &obj2, &prop))
69855:         return false;
54172: 
54172:     *holderOut = obj2;
54172: 
    1:     if (!prop) {
48470:         vp->setUndefined();
48470: 
52503:         if (!CallJSPropertyOp(cx, obj->getClass()->getProperty, obj, id, vp))
    1:             return JS_FALSE;
    1: 
32658:         PCMETER(getHow & JSGET_CACHE_RESULT && JS_PROPERTY_CACHE(cx).nofills++);
11377: 
    1:         /*
    1:          * Give a strict warning if foo.bar is evaluated by a script for an
    1:          * object foo with no property named 'bar'.
    1:          */
24598:         jsbytecode *pc;
48470:         if (vp->isUndefined() && ((pc = js_GetCurrentBytecodePC(cx)) != NULL)) {
    1:             JSOp op;
    1:             uintN flags;
    1: 
 3164:             op = (JSOp) *pc;
25215:             if (op == JSOP_TRAP) {
25215:                 JS_ASSERT_NOT_ON_TRACE(cx);
53840:                 op = JS_GetTrapOpcode(cx, cx->fp()->script(), pc);
25215:             }
    1:             if (op == JSOP_GETXPROP) {
    1:                 flags = JSREPORT_ERROR;
    1:             } else {
61450:                 if (!cx->hasStrictOption() ||
31814:                     (op != JSOP_GETPROP && op != JSOP_GETELEM) ||
31911:                     js_CurrentPCIsInImacro(cx)) {
    1:                     return JS_TRUE;
    1:                 }
    1: 
    1:                 /*
    1:                  * XXX do not warn about missing __iterator__ as the function
    1:                  * may be called from JS_GetMethodById. See bug 355145.
    1:                  */
48470:                 if (JSID_IS_ATOM(id, cx->runtime->atomState.iteratorAtom))
    1:                     return JS_TRUE;
    1: 
25213:                 /* Do not warn about tests like (obj[prop] == undefined). */
69855:                 if (cx->resolveFlags == RESOLVE_INFER) {
37741:                     LeaveTrace(cx);
    1:                     pc += js_CodeSpec[op].length;
    1:                     if (Detecting(cx, pc))
    1:                         return JS_TRUE;
25213:                 } else if (cx->resolveFlags & JSRESOLVE_DETECTING) {
25213:                     return JS_TRUE;
25213:                 }
    1: 
    1:                 flags = JSREPORT_WARNING | JSREPORT_STRICT;
    1:             }
    1: 
    1:             /* Ok, bad undefined property reference: whine about it. */
    1:             if (!js_ReportValueErrorFlags(cx, flags, JSMSG_UNDEFINED_PROP,
48470:                                           JSDVG_IGNORE_STACK, IdToValue(id),
    1:                                           NULL, NULL, NULL)) {
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:         return JS_TRUE;
    1:     }
    1: 
56817:     if (!obj2->isNative()) {
56817:         return obj2->isProxy()
56817:                ? JSProxy::get(cx, obj2, receiver, id, vp)
56817:                : obj2->getProperty(cx, id, vp);
56817:     }
    1: 
52503:     shape = (Shape *) prop;
54172:     *shapeOut = shape;
27490: 
32658:     if (getHow & JSGET_CACHE_RESULT) {
24499:         JS_ASSERT_NOT_ON_TRACE(cx);
69855:         JS_PROPERTY_CACHE(cx).fill(cx, aobj, 0, obj2, shape);
52503:     }
52503: 
55535:     /* This call site is hot -- use the always-inlined variant of js_NativeGet(). */
57739:     if (!js_NativeGetInline(cx, receiver, obj, obj2, shape, getHow, vp))
27932:         return JS_FALSE;
27932: 
27490:     return JS_TRUE;
    1: }
    1: 
56817: bool
56817: js_GetPropertyHelperWithShape(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id,
54177:                               uint32 getHow, Value *vp,
54172:                               const Shape **shapeOut, JSObject **holderOut)
54172: {
56817:     return js_GetPropertyHelperWithShapeInline(cx, obj, receiver, id, getHow, vp,
56817:                                                shapeOut, holderOut);
54172: }
54172: 
55535: static JS_ALWAYS_INLINE JSBool
56817: js_GetPropertyHelperInline(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id,
56817:                            uint32 getHow, Value *vp)
54172: {
54172:     const Shape *shape;
54172:     JSObject *holder;
56817:     return js_GetPropertyHelperWithShapeInline(cx, obj, receiver, id, getHow, vp, &shape, &holder);
56817: }
56817: 
56817: JSBool
56760: js_GetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uint32 getHow, Value *vp)
56760: {
56817:     return js_GetPropertyHelperInline(cx, obj, obj, id, getHow, vp);
56757: }
56757: 
56757: JSBool
56817: js_GetProperty(JSContext *cx, JSObject *obj, JSObject *receiver, jsid id, Value *vp)
    1: {
55535:     /* This call site is hot -- use the always-inlined variant of js_GetPropertyHelper(). */
56817:     return js_GetPropertyHelperInline(cx, obj, receiver, id, JSGET_METHOD_BARRIER, vp);
11377: }
11377: 
11377: JSBool
57734: js::GetPropertyDefault(JSContext *cx, JSObject *obj, jsid id, const Value &def, Value *vp)
56211: {
56211:     JSProperty *prop;
56211:     JSObject *obj2;
69855:     if (!LookupPropertyWithFlags(cx, obj, id, JSRESOLVE_QUALIFIED, &obj2, &prop))
56211:         return false;
56211: 
56211:     if (!prop) {
56211:         *vp = def;
56211:         return true;
56211:     }
56211: 
56211:     return js_GetProperty(cx, obj2, id, vp);
56211: }
56211: 
56211: JSBool
48470: js_GetMethod(JSContext *cx, JSObject *obj, jsid id, uintN getHow, Value *vp)
26187: {
29913:     JSAutoResolveFlags rf(cx, JSRESOLVE_QUALIFIED);
29913: 
48622:     PropertyIdOp op = obj->getOps()->getProperty;
48622:     if (!op) {
48622: #if JS_HAS_XML_SUPPORT
48622:         JS_ASSERT(!obj->isXML());
48622: #endif
32658:         return js_GetPropertyHelper(cx, obj, id, getHow, vp);
32658:     }
39928:     JS_ASSERT_IF(getHow & JSGET_CACHE_RESULT, obj->isDenseArray());
26187: #if JS_HAS_XML_SUPPORT
42693:     if (obj->isXML())
26187:         return js_GetXMLMethod(cx, obj, id, vp);
26187: #endif
56817:     return op(cx, obj, obj, id, vp);
26187: }
26187: 
35308: JS_FRIEND_API(bool)
48470: js_CheckUndeclaredVarAssignment(JSContext *cx, JSString *propname)
27372: {
69223:     StackFrame *const fp = js_GetTopStackFrame(cx);
35308:     if (!fp)
35308:         return true;
35308: 
35308:     /* If neither cx nor the code is strict, then no check is needed. */
53840:     if (!(fp->isScriptFrame() && fp->script()->strictModeCode) &&
61450:         !cx->hasStrictOption()) {
35308:         return true;
35308:     }
35308: 
57812:     JSAutoByteString bytes(cx, propname);
57812:     return !!bytes &&
35308:            JS_ReportErrorFlagsAndNumber(cx,
35308:                                         (JSREPORT_WARNING | JSREPORT_STRICT
35308:                                          | JSREPORT_STRICT_MODE_ERROR),
27372:                                         js_GetErrorMessage, NULL,
57812:                                         JSMSG_UNDECLARED_VAR, bytes.ptr());
27372: }
27372: 
54587: bool
54587: JSObject::reportReadOnly(JSContext* cx, jsid id, uintN report)
54587: {
54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_READ_ONLY,
48470:                                     JSDVG_IGNORE_STACK, IdToValue(id), NULL,
40832:                                     NULL, NULL);
40832: }
40832: 
54587: bool
54587: JSObject::reportNotConfigurable(JSContext* cx, jsid id, uintN report)
54587: {
54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_CANT_DELETE,
54169:                                     JSDVG_IGNORE_STACK, IdToValue(id), NULL,
54169:                                     NULL, NULL);
54169: }
54169: 
54587: bool
54587: JSObject::reportNotExtensible(JSContext *cx, uintN report)
54587: {
54587:     return js_ReportValueErrorFlags(cx, report, JSMSG_OBJECT_NOT_EXTENSIBLE,
54587:                                     JSDVG_IGNORE_STACK, ObjectValue(*this),
54587:                                     NULL, NULL, NULL);
40832: }
40832: 
67921: bool
67921: JSObject::callMethod(JSContext *cx, jsid id, uintN argc, Value *argv, Value *vp)
67921: {
67921:     Value fval;
67921:     return js_GetMethod(cx, this, id, JSGET_NO_METHOD_BARRIER, &fval) &&
67921:            ExternalInvoke(cx, ObjectValue(*this), fval, argc, argv, vp);
67921: }
67921: 
27932: JSBool
56760: js_SetPropertyHelper(JSContext *cx, JSObject *obj, jsid id, uintN defineHow,
54169:                      Value *vp, JSBool strict)
11377: {
    1:     JSObject *pobj;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1:     uintN attrs, flags;
    1:     intN shortid;
48470:     Class *clasp;
62395:     PropertyOp getter;
62395:     StrictPropertyOp setter;
27930:     bool added;
    1: 
69855:     JS_ASSERT((defineHow & ~(DNP_CACHE_RESULT | DNP_SET_METHOD | DNP_UNQUALIFIED)) == 0);
69855:     if (defineHow & DNP_CACHE_RESULT)
28398:         JS_ASSERT_NOT_ON_TRACE(cx);
28398: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
69855:     if (!LookupPropertyWithFlags(cx, obj, id, cx->resolveFlags, &pobj, &prop))
69855:         return false;
27237:     if (prop) {
56817:         if (!pobj->isNative()) {
56817:             if (pobj->isProxy()) {
56817:                 AutoPropertyDescriptorRooter pd(cx);
60344:                 if (!JSProxy::getPropertyDescriptor(cx, pobj, id, true, &pd))
56817:                     return false;
56817: 
63289:                 if ((pd.attrs & (JSPROP_SHARED | JSPROP_SHADOWABLE)) == JSPROP_SHARED) {
63289:                     return !pd.setter ||
63289:                            CallSetter(cx, obj, id, pd.setter, pd.attrs, pd.shortid, strict, vp);
63289:                 }
56817: 
56817:                 if (pd.attrs & JSPROP_READONLY) {
56817:                     if (strict)
56817:                         return obj->reportReadOnly(cx, id);
61450:                     if (cx->hasStrictOption())
56817:                         return obj->reportReadOnly(cx, id, JSREPORT_STRICT | JSREPORT_WARNING);
56817:                     return true;
56817:                 }
56817:             }
56817: 
    1:             prop = NULL;
56817:         }
27237:     } else {
27237:         /* We should never add properties to lexical blocks.  */
53650:         JS_ASSERT(!obj->isBlock());
27237: 
41774:         if (!obj->getParent() &&
69855:             (defineHow & DNP_UNQUALIFIED) &&
48470:             !js_CheckUndeclaredVarAssignment(cx, JSID_TO_STRING(id))) {
41774:             return JS_FALSE;
41774:         }
27237:     }
52503:     shape = (Shape *) prop;
    1: 
    1:     /*
52503:      * Now either shape is null, meaning id was not found in obj or one of its
52503:      * prototypes; or shape is non-null, meaning id was found directly in pobj.
    1:      */
    1:     attrs = JSPROP_ENUMERATE;
    1:     flags = 0;
    1:     shortid = 0;
40826:     clasp = obj->getClass();
    1:     getter = clasp->getProperty;
    1:     setter = clasp->setProperty;
    1: 
52503:     if (shape) {
40832:         /* ES5 8.12.4 [[Put]] step 2. */
52503:         if (shape->isAccessorDescriptor()) {
60780:             if (shape->hasDefaultSetter())
40832:                 return js_ReportGetterOnlyAssignment(cx);
40832:         } else {
52503:             JS_ASSERT(shape->isDataDescriptor());
52503: 
52503:             if (!shape->writable()) {
32658:                 PCMETER((defineHow & JSDNP_CACHE_RESULT) && JS_PROPERTY_CACHE(cx).rofills++);
41247: 
54169:                 /* Error in strict mode code, warn with strict option, otherwise do nothing. */
54169:                 if (strict)
54587:                     return obj->reportReadOnly(cx, id);
61450:                 if (cx->hasStrictOption())
54587:                     return obj->reportReadOnly(cx, id, JSREPORT_STRICT | JSREPORT_WARNING);
27932:                 return JS_TRUE;
    1:             }
40832:         }
    1: 
52503:         attrs = shape->attributes();
56760:         if (pobj != obj) {
    1:             /*
    1:              * We found id in a prototype object: prepare to share or shadow.
    1:              */
59898:             if (!shape->shadowable()) {
69855:                 if (defineHow & DNP_CACHE_RESULT)
69855:                     JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, pobj, shape);
52503: 
52503:                 if (shape->hasDefaultSetter() && !shape->hasGetterValue())
27932:                     return JS_TRUE;
27932: 
62395:                 return shape->set(cx, obj, strict, vp);
    1:             }
    1: 
    1:             /*
59898:              * Preserve attrs except JSPROP_SHARED, getter, and setter when
59898:              * shadowing any property that has no slot (is shared). We must
59898:              * clear the shared attribute for the shadowing shape so that the
59898:              * property in obj that it defines has a slot to retain the value
59898:              * being set, in case the setter simply cannot operate on instances
59898:              * of obj's class by storing the value in some class-specific
59898:              * location.
59898:              *
59898:              * A subset of slotless shared properties is the set of properties
59898:              * with shortids, which must be preserved too. An old API requires
59898:              * that the property's getter and setter receive the shortid, not
59898:              * id, when they are called on the shadowing property that we are
52503:              * about to create in obj.
    1:              */
59898:             if (!shape->hasSlot()) {
69855:                 defineHow &= ~DNP_SET_METHOD;
52503:                 if (shape->hasShortID()) {
52503:                     flags = Shape::HAS_SHORTID;
52503:                     shortid = shape->shortid;
59898:                 }
59898:                 attrs &= ~JSPROP_SHARED;
52503:                 getter = shape->getter();
52503:                 setter = shape->setter();
59898:             } else {
59898:                 /* Restore attrs to the ECMA default for new properties. */
59898:                 attrs = JSPROP_ENUMERATE;
    1:             }
    1: 
    1:             /*
    1:              * Forget we found the proto-property now that we've copied any
    1:              * needed member values.
    1:              */
52503:             shape = NULL;
52503:         }
53577: 
59009:         JS_ASSERT_IF(shape && shape->isMethod(), pobj->hasMethodBarrier());
59009:         JS_ASSERT_IF(shape && shape->isMethod(),
68893:                      pobj->getSlot(shape->slot).toObject() == shape->methodObject());
69855:         if (shape && (defineHow & DNP_SET_METHOD)) {
59009:             /*
59009:              * JSOP_SETMETHOD is assigning to an existing own property. If it
59009:              * is an identical method property, do nothing. Otherwise downgrade
59009:              * to ordinary assignment. Either way, do not fill the property
59009:              * cache, as the interpreter has no fast path for these unusual
59009:              * cases.
59009:              */
68893:             bool identical = shape->isMethod() && shape->methodObject() == vp->toObject();
59009:             if (!identical) {
60797:                 shape = obj->methodShapeChange(cx, *shape);
60797:                 if (!shape)
59009:                     return false;
59009: 
53577:                 JSObject *funobj = &vp->toObject();
60797:                 JSFunction *fun = funobj->getFunctionPrivate();
53577:                 if (fun == funobj) {
53577:                     funobj = CloneFunctionObject(cx, fun, fun->parent);
53577:                     if (!funobj)
53577:                         return JS_FALSE;
53577:                     vp->setObject(*funobj);
53577:                 }
53577:             }
62395:             return identical || js_NativeSet(cx, obj, shape, false, strict, vp);
53577:         }
    1:     }
    1: 
27930:     added = false;
52503:     if (!shape) {
54563:         if (!obj->isExtensible()) {
54563:             /* Error in strict mode code, warn with strict option, otherwise do nothing. */
54563:             if (strict)
54587:                 return obj->reportNotExtensible(cx);
61450:             if (cx->hasStrictOption())
54587:                 return obj->reportNotExtensible(cx, JSREPORT_STRICT | JSREPORT_WARNING);
54563:             return JS_TRUE;
54563:         }
54563: 
11377:         /*
11377:          * Purge the property cache of now-shadowed id in obj's scope chain.
11377:          * Do this early, before locking obj to avoid nesting locks.
11377:          */
25936:         js_PurgeScopeChain(cx, obj, id);
11377: 
    1:         /* Find or make a property descriptor with the right heritage. */
56567:         if (!obj->ensureClassReservedSlots(cx))
27932:             return JS_FALSE;
32658: 
32658:         /*
32658:          * Check for Object class here to avoid defining a method on a class
32658:          * with magic resolve, addProperty, getProperty, etc. hooks.
32658:          */
69855:         if ((defineHow & DNP_SET_METHOD) && obj->canHaveMethodBarrier()) {
48470:             JS_ASSERT(IsFunctionObject(*vp));
32658:             JS_ASSERT(!(attrs & (JSPROP_GETTER | JSPROP_SETTER)));
32658: 
48470:             JSObject *funobj = &vp->toObject();
48676:             JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
48676:             if (fun == funobj) {
52503:                 flags |= Shape::METHOD;
41860:                 getter = CastAsPropertyOp(funobj);
32658:             }
32658:         }
32658: 
52503:         shape = obj->putProperty(cx, id, getter, setter, SHAPE_INVALID_SLOT,
35334:                                  attrs, flags, shortid);
56567:         if (!shape)
27932:             return JS_FALSE;
    1: 
69855:         if (defineHow & DNP_CACHE_RESULT)
60780:             TRACE_1(AddProperty, obj);
60780: 
    1:         /*
    1:          * Initialize the new property value (passed to setter) to undefined.
    1:          * Note that we store before calling addProperty, to match the order
69855:          * in DefineNativeProperty.
    1:          */
52503:         if (obj->containsSlot(shape->slot))
56567:             obj->nativeSetSlot(shape->slot, UndefinedValue());
    1: 
    1:         /* XXXbe called with obj locked */
52503:         if (!CallAddPropertyHook(cx, clasp, obj, shape, vp)) {
52503:             obj->removeProperty(cx, id);
32658:             return JS_FALSE;
32658:         }
27930:         added = true;
    1:     }
    1: 
69855:     if (defineHow & DNP_CACHE_RESULT)
69855:         JS_PROPERTY_CACHE(cx).fill(cx, obj, 0, obj, shape, added);
60780: 
62395:     return js_NativeSet(cx, obj, shape, added, strict, vp);
60780: 
48470: #ifdef JS_TRACER
60780:   error: // TRACE_1 jumps here in case of error.
60780:     return JS_FALSE;
48470: #endif
    1: }
    1: 
    1: JSBool
56760: js_SetProperty(JSContext *cx, JSObject *obj, jsid id, Value *vp, JSBool strict)
56760: {
56760:     return js_SetPropertyHelper(cx, obj, id, 0, vp, strict);
11377: }
11377: 
11377: JSBool
43290: js_GetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
43290: {
43290:     JSProperty *prop;
    1:     if (!js_LookupProperty(cx, obj, id, &obj, &prop))
43290:         return false;
    1:     if (!prop) {
    1:         *attrsp = 0;
43290:         return true;
43290:     }
43290:     if (!obj->isNative())
43290:         return obj->getAttributes(cx, id, attrsp);
43290: 
52503:     const Shape *shape = (Shape *)prop;
52503:     *attrsp = shape->attributes();
43290:     return true;
    1: }
    1: 
    1: JSBool
52503: js_SetNativeAttributes(JSContext *cx, JSObject *obj, Shape *shape, uintN attrs)
43290: {
43290:     JS_ASSERT(obj->isNative());
56567:     return !!js_ChangeNativePropertyAttrs(cx, obj, shape, attrs, 0,
52503:                                           shape->getter(), shape->setter());
43290: }
43290: 
43290: JSBool
43290: js_SetAttributes(JSContext *cx, JSObject *obj, jsid id, uintN *attrsp)
43290: {
43290:     JSProperty *prop;
    1:     if (!js_LookupProperty(cx, obj, id, &obj, &prop))
43290:         return false;
    1:     if (!prop)
43290:         return true;
43290:     return obj->isNative()
52503:            ? js_SetNativeAttributes(cx, obj, (Shape *) prop, *attrsp)
43290:            : obj->setAttributes(cx, id, attrsp);
    1: }
    1: 
    1: JSBool
54169: js_DeleteProperty(JSContext *cx, JSObject *obj, jsid id, Value *rval, JSBool strict)
    1: {
    1:     JSObject *proto;
    1:     JSProperty *prop;
52503:     const Shape *shape;
    1: 
48470:     rval->setBoolean(true);
    1: 
11377:     /* Convert string indices to integers if appropriate. */
30270:     id = js_CheckForStringIndex(id);
11377: 
    1:     if (!js_LookupProperty(cx, obj, id, &proto, &prop))
54169:         return false;
    1:     if (!prop || proto != obj) {
    1:         /*
72089:          * If no property, or the property comes from a prototype, call the
72089:          * class's delProperty hook, passing rval as the result parameter.
    1:          */
52503:         return CallJSPropertyOp(cx, obj->getClass()->delProperty, obj, id, rval);
52503:     }
52503: 
52503:     shape = (Shape *)prop;
52503:     if (!shape->configurable()) {
54169:         if (strict)
54587:             return obj->reportNotConfigurable(cx, id);
48470:         rval->setBoolean(false);
54169:         return true;
    1:     }
    1: 
56567:     if (!CallJSPropertyOp(cx, obj->getClass()->delProperty, obj, SHAPE_USERID(shape), rval))
54169:         return false;
    1: 
52503:     if (obj->containsSlot(shape->slot)) {
56567:         const Value &v = obj->nativeGetSlot(shape->slot);
71353:         GCPoke(cx, v);
48676: 
48676:         /*
48676:          * Delete is rare enough that we can take the hit of checking for an
48676:          * active cloned method function object that must be homed to a callee
48676:          * slot on the active stack frame before this delete completes, in case
48676:          * someone saved the clone and checks it against foo.caller for a foo
48676:          * called from the active method.
48676:          *
48676:          * We do not check suspended frames. They can't be reached via caller,
48676:          * so the only way they could have the method's joined function object
48676:          * as callee is through an API abusage. We break any such edge case.
48676:          */
52503:         if (obj->hasMethodBarrier()) {
48676:             JSObject *funobj;
48676: 
48676:             if (IsFunctionObject(v, &funobj)) {
48676:                 JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
48676: 
48676:                 if (fun != funobj) {
69223:                     for (StackFrame *fp = cx->maybefp(); fp; fp = fp->prev()) {
53840:                         if (fp->isFunctionFrame() &&
68893:                             fp->callee() == fun->compiledFunObj() &&
60172:                             fp->thisValue().isObject())
60172:                         {
60172:                             JSObject *tmp = &fp->thisValue().toObject();
60172:                             do {
60172:                                 if (tmp == obj) {
71695:                                     fp->overwriteCallee(*funobj);
60172:                                     break;
60172:                                 }
60172:                             } while ((tmp = tmp->getProto()) != NULL);
48676:                         }
48676:                     }
48676:                 }
48676:             }
48676:         }
48676:     }
    1: 
56567:     return obj->removeProperty(cx, id) && js_SuppressDeletedProperty(cx, obj, id);
    1: }
    1: 
47607: namespace js {
47607: 
72053: bool
72053: HasDataProperty(JSObject *obj, jsid methodid, Value *vp)
72053: {
72053:     if (const Shape *shape = obj->nativeLookup(methodid)) {
72053:         if (shape->hasDefaultGetterOrIsMethod() && obj->containsSlot(shape->slot)) {
72053:             *vp = obj->nativeGetSlot(shape->slot);
72053:             return true;
72053:         }
72053:     }
72053: 
72053:     return false;
57686: }
57686: 
72054: /*
72054:  * Gets |obj[id]|.  If that value's not callable, returns true and stores a
72054:  * non-primitive value in *vp.  If it's callable, calls it with no arguments
72054:  * and |obj| as |this|, returning the result in *vp.
72054:  *
72054:  * This is a mini-abstraction for ES5 8.12.8 [[DefaultValue]], either steps 1-2
72054:  * or steps 3-4.
72054:  */
72054: static bool
72054: MaybeCallMethod(JSContext *cx, JSObject *obj, jsid id, Value *vp)
72054: {
72054:     if (!js_GetMethod(cx, obj, id, JSGET_NO_METHOD_BARRIER, vp))
72054:         return false;
72054:     if (!js_IsCallable(*vp)) {
72054:         *vp = ObjectValue(*obj);
72054:         return true;
72054:     }
72054:     return ExternalInvoke(cx, ObjectValue(*obj), *vp, 0, NULL, vp);
72054: }
72054: 
72054: JSBool
55737: DefaultValue(JSContext *cx, JSObject *obj, JSType hint, Value *vp)
55737: {
72054:     JS_ASSERT(hint == JSTYPE_NUMBER || hint == JSTYPE_STRING || hint == JSTYPE_VOID);
72054:     JS_ASSERT(!obj->isXML());
72054: 
72054:     Class *clasp = obj->getClass();
55737:     if (hint == JSTYPE_STRING) {
55737:         /* Optimize (new String(...)).toString(). */
72054:         if (clasp == &js_StringClass &&
56216:             ClassMethodIsNative(cx, obj,
56216:                                  &js_StringClass,
55737:                                  ATOM_TO_JSID(cx->runtime->atomState.toStringAtom),
55737:                                  js_str_toString)) {
40901:             *vp = obj->getPrimitiveThis();
55737:             return true;
55737:         }
55737: 
72054:         if (!MaybeCallMethod(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.toStringAtom), vp))
72054:             return false;
72054:         if (vp->isPrimitive())
67921:             return true;
72054: 
72054:         if (!MaybeCallMethod(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.valueOfAtom), vp))
72054:             return false;
72054:         if (vp->isPrimitive())
72054:             return true;
48470:     } else {
55737:         /* Optimize (new String(...)).valueOf(). */
56216:         if ((clasp == &js_StringClass &&
56216:              ClassMethodIsNative(cx, obj, &js_StringClass,
55737:                                  ATOM_TO_JSID(cx->runtime->atomState.valueOfAtom),
56216:                                  js_str_toString)) ||
56216:             (clasp == &js_NumberClass &&
56216:              ClassMethodIsNative(cx, obj, &js_NumberClass,
56216:                                  ATOM_TO_JSID(cx->runtime->atomState.valueOfAtom),
56216:                                  js_num_valueOf))) {
55737:             *vp = obj->getPrimitiveThis();
55737:             return true;
55737:         }
55737: 
72054:         if (!MaybeCallMethod(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.valueOfAtom), vp))
72054:             return false;
72054:         if (vp->isPrimitive())
67921:             return true;
72054: 
72054:         if (!MaybeCallMethod(cx, obj, ATOM_TO_JSID(cx->runtime->atomState.toStringAtom), vp))
72054:             return false;
72054:         if (vp->isPrimitive())
72054:             return true;
72054:     }
72054: 
    1:     /* Avoid recursive death when decompiling in js_ReportValueError. */
48470:     JSString *str;
    1:     if (hint == JSTYPE_STRING) {
72054:         str = JS_InternString(cx, clasp->name);
    1:         if (!str)
55737:             return false;
    1:     } else {
    1:         str = NULL;
    1:     }
72054: 
72054:     js_ReportValueError2(cx, JSMSG_CANT_CONVERT_TO, JSDVG_SEARCH_STACK, ObjectValue(*obj), str,
72054:                          (hint == JSTYPE_VOID) ? "primitive type" : JS_TYPE_STR(hint));
72054:     return false;
    1: }
    1: 
47607: } /* namespace js */
47607: 
48622: JS_FRIEND_API(JSBool)
48470: js_Enumerate(JSContext *cx, JSObject *obj, JSIterateOp enum_op, Value *statep, jsid *idp)
42641: {
42641:     /* If the class has a custom JSCLASS_NEW_ENUMERATE hook, call it. */
48470:     Class *clasp = obj->getClass();
33128:     JSEnumerateOp enumerate = clasp->enumerate;
11835:     if (clasp->flags & JSCLASS_NEW_ENUMERATE) {
11835:         JS_ASSERT(enumerate != JS_EnumerateStub);
48470:         return ((NewEnumerateOp) enumerate)(cx, obj, enum_op, statep, idp);
11835:     }
    1: 
    1:     if (!enumerate(cx, obj))
33128:         return false;
15677: 
42641:     /* Tell InitNativeIterator to treat us like a native object. */
47569:     JS_ASSERT(enum_op == JSENUMERATE_INIT || enum_op == JSENUMERATE_INIT_ALL);
48470:     statep->setMagic(JS_NATIVE_ENUMERATE);
33128:     return true;
    1: }
    1: 
47455: namespace js {
47455: 
    1: JSBool
47455: CheckAccess(JSContext *cx, JSObject *obj, jsid id, JSAccessMode mode,
48470:             Value *vp, uintN *attrsp)
    1: {
    1:     JSBool writing;
    1:     JSObject *pobj;
    1:     JSProperty *prop;
48470:     Class *clasp;
52503:     const Shape *shape;
18870:     JSSecurityCallbacks *callbacks;
48470:     CheckAccessOp check;
    1: 
47455:     while (JS_UNLIKELY(obj->getClass() == &js_WithClass))
47455:         obj = obj->getProto();
47455: 
    1:     writing = (mode & JSACC_WRITE) != 0;
    1:     switch (mode & JSACC_TYPEMASK) {
    1:       case JSACC_PROTO:
    1:         pobj = obj;
    1:         if (!writing)
48470:             vp->setObjectOrNull(obj->getProto());
    1:         *attrsp = JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       case JSACC_PARENT:
    1:         JS_ASSERT(!writing);
    1:         pobj = obj;
48470:         vp->setObject(*obj->getParent());
    1:         *attrsp = JSPROP_READONLY | JSPROP_PERMANENT;
    1:         break;
    1: 
    1:       default:
31501:         if (!obj->lookupProperty(cx, id, &pobj, &prop))
    1:             return JS_FALSE;
    1:         if (!prop) {
    1:             if (!writing)
48470:                 vp->setUndefined();
    1:             *attrsp = 0;
11842:             pobj = obj;
11842:             break;
11842:         }
11842: 
40430:         if (!pobj->isNative()) {
16403:             if (!writing) {
48470:                     vp->setUndefined();
16403:                 *attrsp = 0;
16403:             }
11842:             break;
11961:         }
    1: 
52503:         shape = (Shape *)prop;
52503:         *attrsp = shape->attributes();
    1:         if (!writing) {
52503:             if (pobj->containsSlot(shape->slot))
56567:                 *vp = pobj->nativeGetSlot(shape->slot);
48470:             else
48470:                 vp->setUndefined();
    1:         }
    1:     }
    1: 
    1:     /*
    1:      * If obj's class has a stub (null) checkAccess hook, use the per-runtime
    1:      * checkObjectAccess callback, if configured.
    1:      *
    1:      * We don't want to require all classes to supply a checkAccess hook; we
    1:      * need that hook only for certain classes used when precompiling scripts
    1:      * and functions ("brutal sharing").  But for general safety of built-in
41968:      * magic properties like __proto__, we route all access checks, even for
41968:      * classes that stub out checkAccess, through the global checkObjectAccess
41968:      * hook.  This covers precompilation-based sharing and (possibly
41968:      * unintended) runtime sharing across trust boundaries.
    1:      */
40826:     clasp = pobj->getClass();
    1:     check = clasp->checkAccess;
18870:     if (!check) {
18870:         callbacks = JS_GetSecurityCallbacks(cx);
48470:         check = callbacks ? Valueify(callbacks->checkObjectAccess) : NULL;
48470:     }
48470:     return !check || check(cx, pobj, id, mode, vp);
    1: }
    1: 
47455: }
47455: 
38633: JSType
38633: js_TypeOf(JSContext *cx, JSObject *obj)
38633: {
64209:     return obj->isCallable() ? JSTYPE_FUNCTION : JSTYPE_OBJECT;
38633: }
38633: 
48470: bool
48470: js_IsDelegate(JSContext *cx, JSObject *obj, const Value &v)
48470: {
48470:     if (v.isPrimitive())
48470:         return false;
56565:     JSObject *obj2 = &v.toObject();
39928:     while ((obj2 = obj2->getProto()) != NULL) {
48470:         if (obj2 == obj)
48470:             return true;
48470:     }
48470:     return false;
    1: }
    1: 
47497: bool
52503: js::FindClassPrototype(JSContext *cx, JSObject *scopeobj, JSProtoKey protoKey,
52503:                        JSObject **protop, Class *clasp)
48470: {
48470:     Value v;
52503:     if (!js_FindClassObject(cx, scopeobj, protoKey, &v, clasp))
47497:         return false;
47497: 
48470:     if (IsFunctionObject(v)) {
48470:         JSObject *ctor = &v.toObject();
47497:         if (!ctor->getProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom), &v))
47497:             return false;
47497:     }
47497: 
48470:     *protop = v.isObject() ? &v.toObject() : NULL;
47497:     return true;
47497: }
47497: 
47497: /*
47497:  * The first part of this function has been hand-expanded and optimized into
47497:  * NewBuiltinClassInstance in jsobjinlines.h.
47497:  */
    1: JSBool
52503: js_GetClassPrototype(JSContext *cx, JSObject *scopeobj, JSProtoKey protoKey,
48470:                      JSObject **protop, Class *clasp)
38604: {
38604:     VOUCH_DOES_NOT_REQUIRE_STACK();
38604:     JS_ASSERT(JSProto_Null <= protoKey);
38604:     JS_ASSERT(protoKey < JSProto_LIMIT);
38604: 
38604:     if (protoKey != JSProto_Null) {
52503:         if (!scopeobj) {
71696:             if (cx->hasfp())
62953:                 scopeobj = &cx->fp()->scopeChain();
62953:             if (!scopeobj) {
62953:                 scopeobj = cx->globalObject;
62953:                 if (!scopeobj) {
62953:                     *protop = NULL;
62953:                     return true;
62953:                 }
62953:             }
38604:         }
52503:         scopeobj = scopeobj->getGlobal();
60566:         if (scopeobj->isGlobal()) {
69237:             const Value &v = scopeobj->getReservedSlot(JSProto_LIMIT + protoKey);
48470:             if (v.isObject()) {
48470:                 *protop = &v.toObject();
38604:                 return true;
38604:             }
38604:         }
43258:     }
38604: 
52503:     return FindClassPrototype(cx, scopeobj, protoKey, protop, clasp);
    1: }
    1: 
    1: JSBool
48470: js_SetClassPrototype(JSContext *cx, JSObject *ctor, JSObject *proto, uintN attrs)
    1: {
    1:     /*
    1:      * Use the given attributes for the prototype property of the constructor,
    1:      * as user-defined constructors have a DontDelete prototype (which may be
    1:      * reset), while native or "system" constructors have DontEnum | ReadOnly |
    1:      * DontDelete.
    1:      */
31501:     if (!ctor->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.classPrototypeAtom),
62395:                               ObjectOrNullValue(proto), PropertyStub, StrictPropertyStub, attrs)) {
    1:         return JS_FALSE;
    1:     }
    1: 
    1:     /*
    1:      * ECMA says that Object.prototype.constructor, or f.prototype.constructor
    1:      * for a user-defined function f, is DontEnum.
    1:      */
31501:     return proto->defineProperty(cx, ATOM_TO_JSID(cx->runtime->atomState.constructorAtom),
62395:                                  ObjectOrNullValue(ctor), PropertyStub, StrictPropertyStub, 0);
    1: }
    1: 
61734: JSObject *
61734: PrimitiveToObject(JSContext *cx, const Value &v)
61734: {
69242:     if (v.isString())
69242:         return StringObject::create(cx, v.toString());
67942: 
67942:     JS_ASSERT(v.isNumber() || v.isBoolean());
67942:     Class *clasp = v.isNumber() ? &js_NumberClass : &js_BooleanClass;
48470:     JSObject *obj = NewBuiltinClassInstance(cx, clasp);
 2383:     if (!obj)
61734:         return NULL;
48470: 
48470:     obj->setPrimitiveThis(v);
61734:     return obj;
61734: }
61734: 
61734: JSBool
61734: js_PrimitiveToObject(JSContext *cx, Value *vp)
61734: {
61734:     JSObject *obj = PrimitiveToObject(cx, *vp);
61734:     if (!obj)
61734:         return false;
61734: 
48470:     vp->setObject(*obj);
61734:     return true;
 2383: }
 2383: 
 2383: JSBool
48470: js_ValueToObjectOrNull(JSContext *cx, const Value &v, JSObject **objp)
    1: {
    1:     JSObject *obj;
    1: 
48470:     if (v.isObjectOrNull()) {
48470:         obj = v.toObjectOrNull();
48470:     } else if (v.isUndefined()) {
    1:         obj = NULL;
    1:     } else {
61734:         obj = PrimitiveToObject(cx, v);
61734:         if (!obj)
61734:             return false;
    1:     }
    1:     *objp = obj;
61734:     return true;
61734: }
61734: 
61734: namespace js {
61734: 
61734: /* Callers must handle the already-object case . */
61734: JSObject *
61734: ToObjectSlow(JSContext *cx, Value *vp)
61734: {
61734:     JS_ASSERT(!vp->isMagic());
61734:     JS_ASSERT(!vp->isObject());
61734: 
61734:     if (vp->isNullOrUndefined()) {
61734:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_CANT_CONVERT_TO,
61734:                             vp->isNull() ? "null" : "undefined", "object");
61734:         return NULL;
61734:     }
61734: 
61734:     JSObject *obj = PrimitiveToObject(cx, *vp);
61734:     if (obj)
61734:         vp->setObject(*obj);
61734:     return obj;
61734: }
61734: 
    1: }
    1: 
    1: JSObject *
48470: js_ValueToNonNullObject(JSContext *cx, const Value &v)
    1: {
    1:     JSObject *obj;
    1: 
48470:     if (!js_ValueToObjectOrNull(cx, v, &obj))
    1:         return NULL;
 7897:     if (!obj)
 7897:         js_ReportIsNullOrUndefined(cx, JSDVG_SEARCH_STACK, v, NULL);
    1:     return obj;
    1: }
    1: 
    1: #if JS_HAS_XDR
    1: 
    1: JSBool
    1: js_XDRObject(JSXDRState *xdr, JSObject **objp)
    1: {
    1:     JSContext *cx;
    1:     JSAtom *atom;
48470:     Class *clasp;
    1:     uint32 classId, classDef;
    1:     JSProtoKey protoKey;
    1:     JSObject *proto;
    1: 
    1:     cx = xdr->cx;
    1:     atom = NULL;
    1:     if (xdr->mode == JSXDR_ENCODE) {
40826:         clasp = (*objp)->getClass();
    1:         classId = JS_XDRFindClassIdByName(xdr, clasp->name);
    1:         classDef = !classId;
    1:         if (classDef) {
48470:             if (!JS_XDRRegisterClass(xdr, Jsvalify(clasp), &classId))
    1:                 return JS_FALSE;
    1:             protoKey = JSCLASS_CACHED_PROTO_KEY(clasp);
    1:             if (protoKey != JSProto_Null) {
    1:                 classDef |= (protoKey << 1);
    1:             } else {
70270:                 atom = js_Atomize(cx, clasp->name, strlen(clasp->name));
    1:                 if (!atom)
    1:                     return JS_FALSE;
    1:             }
    1:         }
    1:     } else {
    1:         clasp = NULL;           /* quell GCC overwarning */
    1:         classDef = 0;
    1:     }
    1: 
    1:     /*
    1:      * XDR a flag word, which could be 0 for a class use, in which case no
    1:      * name follows, only the id in xdr's class registry; 1 for a class def,
    1:      * in which case the flag word is followed by the class name transferred
    1:      * from or to atom; or a value greater than 1, an odd number that when
    1:      * divided by two yields the JSProtoKey for class.  In the last case, as
    1:      * in the 0 classDef case, no name is transferred via atom.
    1:      */
    1:     if (!JS_XDRUint32(xdr, &classDef))
    1:         return JS_FALSE;
48480:     if (classDef == 1 && !js_XDRAtom(xdr, &atom))
    1:         return JS_FALSE;
    1: 
    1:     if (!JS_XDRUint32(xdr, &classId))
    1:         return JS_FALSE;
    1: 
    1:     if (xdr->mode == JSXDR_DECODE) {
    1:         if (classDef) {
    1:             /* NB: we know that JSProto_Null is 0 here, for backward compat. */
 3164:             protoKey = (JSProtoKey) (classDef >> 1);
38604:             if (!js_GetClassPrototype(cx, NULL, protoKey, &proto, clasp))
    1:                 return JS_FALSE;
40826:             clasp = proto->getClass();
48470:             if (!JS_XDRRegisterClass(xdr, Jsvalify(clasp), &classId))
    1:                 return JS_FALSE;
    1:         } else {
48470:             clasp = Valueify(JS_XDRFindClassById(xdr, classId));
    1:             if (!clasp) {
    1:                 char numBuf[12];
    1:                 JS_snprintf(numBuf, sizeof numBuf, "%ld", (long)classId);
    1:                 JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                                      JSMSG_CANT_FIND_CLASS, numBuf);
    1:                 return JS_FALSE;
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (!clasp->xdrObject) {
    1:         JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL,
    1:                              JSMSG_CANT_XDR_CLASS, clasp->name);
    1:         return JS_FALSE;
    1:     }
    1:     return clasp->xdrObject(xdr, objp);
    1: }
    1: 
    1: #endif /* JS_HAS_XDR */
    1: 
  583: #ifdef DEBUG
11835: void
11835: js_PrintObjectSlotName(JSTracer *trc, char *buf, size_t bufsize)
  583: {
32684:     JS_ASSERT(trc->debugPrinter == js_PrintObjectSlotName);
32684: 
32684:     JSObject *obj = (JSObject *)trc->debugPrintArg;
32684:     uint32 slot = (uint32)trc->debugPrintIndex;
32684: 
52503:     const Shape *shape;
40430:     if (obj->isNative()) {
52503:         shape = obj->lastProperty();
52503:         while (shape->previous() && shape->slot != slot)
52503:             shape = shape->previous();
55683:         if (shape->slot != slot)
55683:             shape = NULL;
11835:     } else {
52503:         shape = NULL;
52503:     }
52503: 
52503:     if (!shape) {
32684:         const char *slotname = NULL;
60566:         if (obj->isGlobal()) {
  583: #define JS_PROTO(name,code,init)                                              \
55746:     if ((code) == slot) { slotname = js_##name##_str; goto found; }
  583: #include "jsproto.tbl"
  583: #undef JS_PROTO
  583:         }
  583:       found:
  583:         if (slotname)
  583:             JS_snprintf(buf, bufsize, "CLASS_OBJECT(%s)", slotname);
  583:         else
  583:             JS_snprintf(buf, bufsize, "**UNKNOWN SLOT %ld**", (long)slot);
  583:     } else {
69637:         jsid propid = shape->propid;
69637:         if (JSID_IS_INT(propid)) {
69637:             JS_snprintf(buf, bufsize, "%ld", (long)JSID_TO_INT(propid));
69637:         } else if (JSID_IS_ATOM(propid)) {
69637:             PutEscapedString(buf, bufsize, JSID_TO_ATOM(propid), 0);
  583:         } else {
  583:             JS_snprintf(buf, bufsize, "**FINALIZED ATOM KEY**");
  583:         }
  583:     }
  583: }
  583: #endif
  583: 
68903: static const Shape *
68903: LastConfigurableShape(JSObject *obj)
68903: {
68903:     for (Shape::Range r(obj->lastProperty()->all()); !r.empty(); r.popFront()) {
68903:         const Shape *shape = &r.front();
68903:         if (shape->configurable())
68903:             return shape;
68903:     }
68903:     return NULL;
68903: }
68903: 
68903: bool
48622: js_ClearNative(JSContext *cx, JSObject *obj)
    1: {
68903:     /* Remove all configurable properties from obj. */
68903:     while (const Shape *shape = LastConfigurableShape(obj)) {
69637:         if (!obj->removeProperty(cx, shape->propid))
68903:             return false;
68903:     }
68903: 
68903:     /* Set all remaining writable plain data properties to undefined. */
68903:     for (Shape::Range r(obj->lastProperty()->all()); !r.empty(); r.popFront()) {
68903:         const Shape *shape = &r.front();
68903:         if (shape->isDataDescriptor() &&
68903:             shape->writable() &&
68903:             shape->hasDefaultSetter() &&
68903:             obj->containsSlot(shape->slot)) {
68903:             obj->setSlot(shape->slot, UndefinedValue());
68903:         }
68903:     }
68903:     return true;
    1: }
    1: 
32603: bool
55746: js_GetReservedSlot(JSContext *cx, JSObject *obj, uint32 slot, Value *vp)
32603: {
40430:     if (!obj->isNative()) {
48470:         vp->setUndefined();
32603:         return true;
32603:     }
32603: 
48470:     if (slot < obj->numSlots())
48470:         *vp = obj->getSlot(slot);
48470:     else
48470:         vp->setUndefined();
32603:     return true;
32603: }
32603: 
32603: bool
55746: js_SetReservedSlot(JSContext *cx, JSObject *obj, uint32 slot, const Value &v)
    1: {
40430:     if (!obj->isNative())
32603:         return true;
32603: 
48470:     Class *clasp = obj->getClass();
41804: 
41978:     if (slot >= obj->numSlots()) {
32603:         uint32 nslots = JSSLOT_FREE(clasp);
    1:         JS_ASSERT(slot < nslots);
56567:         if (!obj->allocSlots(cx, nslots))
32603:             return false;
    1:     }
    1: 
40410:     obj->setSlot(slot, v);
71353:     GCPoke(cx, NullValue());
32603:     return true;
    1: }
    1: 
68955: GlobalObject *
51090: JSObject::getGlobal() const
51090: {
51090:     JSObject *obj = const_cast<JSObject *>(this);
40424:     while (JSObject *parent = obj->getParent())
40424:         obj = parent;
68955:     return obj->asGlobal();
40424: }
40424: 
36491: JSBool
27641: js_ReportGetterOnlyAssignment(JSContext *cx)
27641: {
36491:     return JS_ReportErrorFlagsAndNumber(cx,
36491:                                         JSREPORT_WARNING | JSREPORT_STRICT |
36491:                                         JSREPORT_STRICT_MODE_ERROR,
36491:                                         js_GetErrorMessage, NULL,
36491:                                         JSMSG_GETTER_ONLY);
27641: }
27641: 
27641: JS_FRIEND_API(JSBool)
62395: js_GetterOnlyPropertyStub(JSContext *cx, JSObject *obj, jsid id, JSBool strict, jsval *vp)
27641: {
36491:     JS_ReportErrorNumber(cx, js_GetErrorMessage, NULL, JSMSG_GETTER_ONLY);
27641:     return JS_FALSE;
27641: }
27641: 
24294: #ifdef DEBUG
19714: 
19714: /*
19714:  * Routines to print out values during debugging.  These are FRIEND_API to help
19714:  * the debugger find them and to support temporarily hacking js_Dump* calls
19714:  * into other code.
19714:  */
19714: 
19714: void
19714: dumpChars(const jschar *s, size_t n)
19714: {
19714:     size_t i;
19714: 
19714:     if (n == (size_t) -1) {
19714:         while (s[++n]) ;
19714:     }
19714: 
    1:     fputc('"', stderr);
19714:     for (i = 0; i < n; i++) {
19714:         if (s[i] == '\n')
19714:             fprintf(stderr, "\\n");
19714:         else if (s[i] == '\t')
19714:             fprintf(stderr, "\\t");
19714:         else if (s[i] >= 32 && s[i] < 127)
19714:             fputc(s[i], stderr);
19714:         else if (s[i] <= 255)
19714:             fprintf(stderr, "\\x%02x", (unsigned int) s[i]);
19714:         else
19714:             fprintf(stderr, "\\u%04x", (unsigned int) s[i]);
19714:     }
19714:     fputc('"', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpChars(const jschar *s, size_t n)
19714: {
19714:     fprintf(stderr, "jschar * (%p) = ", (void *) s);
19714:     dumpChars(s, n);
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: void
19714: dumpString(JSString *str)
19714: {
59890:     if (const jschar *chars = str->getChars(NULL))
59890:         dumpChars(chars, str->length());
59890:     else
59890:         fprintf(stderr, "(oom in dumpString)");
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpString(JSString *str)
19714: {
59890:     if (const jschar *chars = str->getChars(NULL)) {
19714:         fprintf(stderr, "JSString* (%p) = jschar * (%p) = ",
59890:                 (void *) str, (void *) chars);
19714:         dumpString(str);
59890:     } else {
59890:         fprintf(stderr, "(oom in JS_DumpString)");
59890:     }
    1:     fputc('\n', stderr);
    1: }
    1: 
19714: JS_FRIEND_API(void)
19714: js_DumpAtom(JSAtom *atom)
19714: {
19714:     fprintf(stderr, "JSAtom* (%p) = ", (void *) atom);
64345:     js_DumpString(atom);
19714: }
19714: 
19714: void
48470: dumpValue(const Value &v)
48470: {
48470:     if (v.isNull())
19714:         fprintf(stderr, "null");
48470:     else if (v.isUndefined())
19714:         fprintf(stderr, "undefined");
48470:     else if (v.isInt32())
48470:         fprintf(stderr, "%d", v.toInt32());
48470:     else if (v.isDouble())
48470:         fprintf(stderr, "%g", v.toDouble());
48470:     else if (v.isString())
48470:         dumpString(v.toString());
48470:     else if (v.isObject() && v.toObject().isFunction()) {
48470:         JSObject *funobj = &v.toObject();
31452:         JSFunction *fun = GET_FUNCTION_PRIVATE(cx, funobj);
57721:         if (fun->atom) {
57721:             fputs("<function ", stderr);
64345:             FileEscapedString(stderr, fun->atom, 0);
57721:         } else {
57721:             fputs("<unnamed function", stderr);
57721:         }
59062:         if (fun->isInterpreted()) {
59062:             JSScript *script = fun->script();
59062:             fprintf(stderr, " (%s:%u)",
59062:                     script->filename ? script->filename : "", script->lineno);
59062:         }
57721:         fprintf(stderr, " at %p (JSFunction at %p)>", (void *) funobj, (void *) fun);
48470:     } else if (v.isObject()) {
48470:         JSObject *obj = &v.toObject();
48470:         Class *clasp = obj->getClass();
19714:         fprintf(stderr, "<%s%s at %p>",
47480:                 clasp->name,
48676:                 (clasp == &js_ObjectClass) ? "" : " object",
25218:                 (void *) obj);
48470:     } else if (v.isBoolean()) {
48470:         if (v.toBoolean())
19714:             fprintf(stderr, "true");
48470:         else
19714:             fprintf(stderr, "false");
48470:     } else if (v.isMagic()) {
48470:         fprintf(stderr, "<invalid");
48470: #ifdef DEBUG
48470:         switch (v.whyMagic()) {
48470:           case JS_ARRAY_HOLE:        fprintf(stderr, " array hole");         break;
48470:           case JS_ARGS_HOLE:         fprintf(stderr, " args hole");          break;
48470:           case JS_NATIVE_ENUMERATE:  fprintf(stderr, " native enumeration"); break;
48470:           case JS_NO_ITER_VALUE:     fprintf(stderr, " no iter value");      break;
48470:           case JS_GENERATOR_CLOSING: fprintf(stderr, " generator closing");  break;
48470:           default:                   fprintf(stderr, " ?!");                 break;
48470:         }
48470: #endif
48470:         fprintf(stderr, ">");
19714:     } else {
48470:         fprintf(stderr, "unexpected value");
19714:     }
19714: }
19714: 
19714: JS_FRIEND_API(void)
48470: js_DumpValue(const Value &val)
48470: {
19714:     dumpValue(val);
19714:     fputc('\n', stderr);
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpId(jsid id)
19714: {
48470:     fprintf(stderr, "jsid %p = ", (void *) JSID_BITS(id));
48470:     dumpValue(IdToValue(id));
19714:     fputc('\n', stderr);
19714: }
19714: 
20208: static void
62931: DumpProperty(JSObject *obj, const Shape &shape)
52503: {
69637:     jsid id = shape.propid;
52503:     uint8 attrs = shape.attributes();
19714: 
62931:     fprintf(stderr, "    ((Shape *) %p) ", (void *) &shape);
19714:     if (attrs & JSPROP_ENUMERATE) fprintf(stderr, "enumerate ");
19714:     if (attrs & JSPROP_READONLY) fprintf(stderr, "readonly ");
19714:     if (attrs & JSPROP_PERMANENT) fprintf(stderr, "permanent ");
19714:     if (attrs & JSPROP_SHARED) fprintf(stderr, "shared ");
52503:     if (shape.isAlias()) fprintf(stderr, "alias ");
62931:     if (shape.isMethod()) fprintf(stderr, "method=%p ", (void *) &shape.methodObject());
62931: 
62931:     if (shape.hasGetterValue())
62931:         fprintf(stderr, "getterValue=%p ", (void *) shape.getterObject());
62931:     else if (!shape.hasDefaultGetter())
62936:         fprintf(stderr, "getterOp=%p ", JS_FUNC_TO_DATA_PTR(void *, shape.getterOp()));
62931: 
62931:     if (shape.hasSetterValue())
62931:         fprintf(stderr, "setterValue=%p ", (void *) shape.setterObject());
62931:     else if (shape.setterOp() == js_watch_set)
62931:         fprintf(stderr, "setterOp=js_watch_set ");
62931:     else if (!shape.hasDefaultSetter())
62936:         fprintf(stderr, "setterOp=%p ", JS_FUNC_TO_DATA_PTR(void *, shape.setterOp()));
59009: 
19714:     if (JSID_IS_ATOM(id))
48470:         dumpString(JSID_TO_STRING(id));
19714:     else if (JSID_IS_INT(id))
19714:         fprintf(stderr, "%d", (int) JSID_TO_INT(id));
19714:     else
48470:         fprintf(stderr, "unknown jsid %p", (void *) JSID_BITS(id));
52503:     fprintf(stderr, ": slot %d", shape.slot);
62931:     if (obj->containsSlot(shape.slot)) {
62931:         fprintf(stderr, " = ");
62931:         dumpValue(obj->getSlot(shape.slot));
62931:     } else if (shape.slot != SHAPE_INVALID_SLOT) {
62931:         fprintf(stderr, " (INVALID!)");
62931:     }
19714:     fprintf(stderr, "\n");
19714: }
19714: 
19714: JS_FRIEND_API(void)
19714: js_DumpObject(JSObject *obj)
19714: {
13437:     fprintf(stderr, "object %p\n", (void *) obj);
55747:     Class *clasp = obj->getClass();
    1:     fprintf(stderr, "class %p %s\n", (void *)clasp, clasp->name);
19714: 
52503:     fprintf(stderr, "flags:");
52503:     uint32 flags = obj->flags;
52503:     if (flags & JSObject::DELEGATE) fprintf(stderr, " delegate");
52503:     if (flags & JSObject::SYSTEM) fprintf(stderr, " system");
62931:     if (flags & JSObject::NOT_EXTENSIBLE) fprintf(stderr, " not_extensible");
52503:     if (flags & JSObject::BRANDED) fprintf(stderr, " branded");
52503:     if (flags & JSObject::GENERIC) fprintf(stderr, " generic");
52503:     if (flags & JSObject::METHOD_BARRIER) fprintf(stderr, " method_barrier");
52503:     if (flags & JSObject::INDEXED) fprintf(stderr, " indexed");
52503:     if (flags & JSObject::OWN_SHAPE) fprintf(stderr, " own_shape");
56192:     if (flags & JSObject::HAS_EQUALITY) fprintf(stderr, " has_equality");
54563: 
52503:     bool anyFlags = flags != 0;
53569:     if (obj->isNative()) {
52503:         if (obj->inDictionaryMode()) {
52503:             fprintf(stderr, " inDictionaryMode");
52503:             anyFlags = true;
52503:         }
52503:         if (obj->hasPropertyTable()) {
52503:             fprintf(stderr, " hasPropertyTable");
52503:             anyFlags = true;
52503:         }
53569:     }
52503:     if (!anyFlags)
52503:         fprintf(stderr, " none");
52503:     fprintf(stderr, "\n");
52503: 
37003:     if (obj->isDenseArray()) {
55748:         unsigned slots = JS_MIN(obj->getArrayLength(), obj->getDenseArrayCapacity());
19714:         fprintf(stderr, "elements\n");
55748:         for (unsigned i = 0; i < slots; i++) {
19714:             fprintf(stderr, " %3d: ", i);
41782:             dumpValue(obj->getDenseArrayElement(i));
19714:             fprintf(stderr, "\n");
19714:             fflush(stderr);
19714:         }
13437:         return;
13437:     }
13437: 
31452:     fprintf(stderr, "proto ");
48470:     dumpValue(ObjectOrNullValue(obj->getProto()));
31452:     fputc('\n', stderr);
31452: 
31452:     fprintf(stderr, "parent ");
48470:     dumpValue(ObjectOrNullValue(obj->getParent()));
31452:     fputc('\n', stderr);
31452: 
55746:     if (clasp->flags & JSCLASS_HAS_PRIVATE)
31452:         fprintf(stderr, "private %p\n", obj->getPrivate());
31452: 
62931:     if (!obj->isNative())
62931:         fprintf(stderr, "not native\n");
62931: 
55748:     unsigned reservedEnd = JSCLASS_RESERVED_SLOTS(clasp);
55748:     unsigned slots = obj->slotSpan();
62931:     unsigned stop = obj->isNative() ? reservedEnd : slots;
62931:     if (stop > 0)
62931:         fprintf(stderr, obj->isNative() ? "reserved slots:\n" : "slots:\n");
62931:     for (unsigned i = 0; i < stop; i++) {
19714:         fprintf(stderr, " %3d ", i);
31452:         if (i < reservedEnd)
19714:             fprintf(stderr, "(reserved) ");
19714:         fprintf(stderr, "= ");
40410:         dumpValue(obj->getSlot(i));
19714:         fputc('\n', stderr);
19714:     }
62931: 
62931:     if (obj->isNative()) {
62931:         fprintf(stderr, "properties:\n");
62931:         Vector<const Shape *, 8, SystemAllocPolicy> props;
62931:         for (Shape::Range r = obj->lastProperty()->all(); !r.empty(); r.popFront())
62931:             props.append(&r.front());
62931:         for (size_t i = props.length(); i-- != 0;)
62931:             DumpProperty(obj, *props[i]);
62931:     }
19714:     fputc('\n', stderr);
    1: }
    1: 
28665: static void
28665: MaybeDumpObject(const char *name, JSObject *obj)
28665: {
28665:     if (obj) {
28665:         fprintf(stderr, "  %s: ", name);
48470:         dumpValue(ObjectValue(*obj));
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
32774: static void
48470: MaybeDumpValue(const char *name, const Value &v)
48470: {
48470:     if (!v.isNull()) {
32774:         fprintf(stderr, "  %s: ", name);
32774:         dumpValue(v);
32774:         fputc('\n', stderr);
32774:     }
32774: }
32774: 
28665: JS_FRIEND_API(void)
69223: js_DumpStackFrame(JSContext *cx, StackFrame *start)
42717: {
42717:     /* This should only called during live debugging. */
42717:     VOUCH_DOES_NOT_REQUIRE_STACK();
42717: 
42717:     if (!start)
51446:         start = cx->maybefp();
42717:     FrameRegsIter i(cx);
42717:     while (!i.done() && i.fp() != start)
42717:         ++i;
42717: 
42717:     if (i.done()) {
42717:         fprintf(stderr, "fp = %p not found in cx = %p\n", (void *)start, (void *)cx);
42717:         return;
42717:     }
42717: 
42717:     for (; !i.done(); ++i) {
69223:         StackFrame *const fp = i.fp();
69223: 
69223:         fprintf(stderr, "StackFrame at %p\n", (void *) fp);
53840:         if (fp->isFunctionFrame()) {
53840:             fprintf(stderr, "callee fun: ");
53840:             dumpValue(ObjectValue(fp->callee()));
42717:         } else {
28665:             fprintf(stderr, "global frame, no callee");
42717:         }
28665:         fputc('\n', stderr);
28665: 
53840:         if (fp->isScriptFrame()) {
51056:             fprintf(stderr, "file %s line %u\n",
53840:                     fp->script()->filename, (unsigned) fp->script()->lineno);
51056:         }
28665: 
42717:         if (jsbytecode *pc = i.pc()) {
53840:             if (!fp->isScriptFrame()) {
42717:                 fprintf(stderr, "*** pc && !script, skipping frame\n\n");
28665:                 continue;
28665:             }
53840:             if (fp->hasImacropc()) {
28665:                 fprintf(stderr, "  pc in imacro at %p\n  called from ", pc);
53840:                 pc = fp->imacropc();
28665:             } else {
28665:                 fprintf(stderr, "  ");
28665:             }
28665:             fprintf(stderr, "pc = %p\n", pc);
28665:             fprintf(stderr, "  current op: %s\n", js_CodeName[*pc]);
28665:         }
48470:         Value *sp = i.sp();
42714:         fprintf(stderr, "  slots: %p\n", (void *) fp->slots());
42714:         fprintf(stderr, "  sp:    %p = slots + %u\n", (void *) sp, (unsigned) (sp - fp->slots()));
42714:         if (sp - fp->slots() < 10000) { // sanity
48470:             for (Value *p = fp->slots(); p < sp; p++) {
28665:                 fprintf(stderr, "    %p: ", (void *) p);
28665:                 dumpValue(*p);
28665:                 fputc('\n', stderr);
28665:             }
28665:         }
64364:         if (fp->hasArgs()) {
53840:             fprintf(stderr, "  actuals: %p (%u) ", (void *) fp->actualArgs(), (unsigned) fp->numActualArgs());
53840:             fprintf(stderr, "  formals: %p (%u)\n", (void *) fp->formalArgs(), (unsigned) fp->numFormalArgs());
53840:         }
64364:         if (fp->hasCallObj()) {
64364:             fprintf(stderr, "  has call obj: ");
64364:             dumpValue(ObjectValue(fp->callObj()));
64364:             fprintf(stderr, "\n");
64364:         }
50510:         MaybeDumpObject("argsobj", fp->maybeArgsObj());
55608:         if (!fp->isDummyFrame()) {
53840:             MaybeDumpValue("this", fp->thisValue());
28665:             fprintf(stderr, "  rval: ");
53840:             dumpValue(fp->returnValue());
55608:         } else {
55608:             fprintf(stderr, "dummy frame");
55608:         }
28665:         fputc('\n', stderr);
28665: 
28665:         fprintf(stderr, "  flags:");
53840:         if (fp->isConstructing())
28665:             fprintf(stderr, " constructing");
53840:         if (fp->hasOverriddenArgs())
53840:             fprintf(stderr, " overridden_args");
53840:         if (fp->isDebuggerFrame())
28665:             fprintf(stderr, " debugger");
53840:         if (fp->isEvalFrame())
28665:             fprintf(stderr, " eval");
53840:         if (fp->isYielding())
28665:             fprintf(stderr, " yielding");
53840:         if (fp->isGeneratorFrame())
28665:             fprintf(stderr, " generator");
28665:         fputc('\n', stderr);
28665: 
53840:         fprintf(stderr, "  scopeChain: (JSObject *) %p\n", (void *) &fp->scopeChain());
28665: 
28665:         fputc('\n', stderr);
28665:     }
28665: }
28665: 
53013: #endif /* DEBUG */
53013: 
