    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Chris Waterson <waterson@netscape.com>
    1:  *   Brendan Eich <brendan@mozilla.org>
    1:  *   Ben Goodger <ben@netscape.com>
    1:  *   Benjamin Smedberg <bsmedberg@covad.net>
    1:  *   Mark Hammond <mhammond@skippinet.com.au>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsXULPrototypeCache.h"
    1: 
    1: #include "nsContentUtils.h"
    1: #include "plstr.h"
    1: #include "nsXULPrototypeDocument.h"
    1: #include "nsICSSStyleSheet.h"
    1: #include "nsIScriptRuntime.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIURI.h"
    1: #include "nsIXBLDocumentInfo.h"
    1: 
    1: #include "nsIChromeRegistry.h"
    1: #include "nsIFastLoadService.h"
    1: #include "nsIFastLoadFileControl.h"
    1: #include "nsIFile.h"
    1: #include "nsIObjectInputStream.h"
    1: #include "nsIObjectOutputStream.h"
    1: #include "nsIObserverService.h"
    1: 
    1: #include "nsNetUtil.h"
    1: #include "nsAppDirectoryServiceDefs.h"
    1: 
    1: #include "jsxdrapi.h"
    1: 
    1: static NS_DEFINE_CID(kXULPrototypeCacheCID, NS_XULPROTOTYPECACHE_CID);
    1: 
    1: static PRBool gDisableXULCache = PR_FALSE; // enabled by default
    1: static const char kDisableXULCachePref[] = "nglayout.debug.disable_xul_cache";
    1: 
    1: //----------------------------------------------------------------------
    1: 
20261: static int
    1: DisableXULCacheChangedCallback(const char* aPref, void* aClosure)
    1: {
    1:     gDisableXULCache =
    1:         nsContentUtils::GetBoolPref(kDisableXULCachePref, gDisableXULCache);
    1: 
    1:     // Flush the cache, regardless
    1:     nsXULPrototypeCache* cache = nsXULPrototypeCache::GetInstance();
    1:     if (cache)
    1:         cache->Flush();
    1: 
    1:     return 0;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: 
    1: nsIFastLoadService*   nsXULPrototypeCache::gFastLoadService = nsnull;
    1: nsIFile*              nsXULPrototypeCache::gFastLoadFile = nsnull;
    1: nsXULPrototypeCache*  nsXULPrototypeCache::sInstance = nsnull;
    1: 
    1: 
    1: nsXULPrototypeCache::nsXULPrototypeCache()
    1: {
    1: }
    1: 
    1: 
    1: nsXULPrototypeCache::~nsXULPrototypeCache()
    1: {
    1:     FlushScripts();
    1: 
    1:     NS_IF_RELEASE(gFastLoadService); // don't need ReleaseService nowadays!
    1:     NS_IF_RELEASE(gFastLoadFile);
    1: }
    1: 
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS2(nsXULPrototypeCache,
    1:                               nsIXULPrototypeCache,
    1:                               nsIObserver)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: NS_NewXULPrototypeCache(nsISupports* aOuter, REFNSIID aIID, void** aResult)
    1: {
    1:     NS_PRECONDITION(! aOuter, "no aggregation");
    1:     if (aOuter)
    1:         return NS_ERROR_NO_AGGREGATION;
    1: 
    1:     nsRefPtr<nsXULPrototypeCache> result = new nsXULPrototypeCache();
    1:     if (! result)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     if (!(result->mPrototypeTable.Init() &&
    1:           result->mStyleSheetTable.Init() &&
    1:           result->mScriptTable.Init() &&
    1:           result->mXBLDocTable.Init() &&
    1:           result->mFastLoadURITable.Init())) {
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     // XXX Ignore return values.
    1:     gDisableXULCache =
    1:         nsContentUtils::GetBoolPref(kDisableXULCachePref, gDisableXULCache);
    1:     nsContentUtils::RegisterPrefCallback(kDisableXULCachePref,
    1:                                          DisableXULCacheChangedCallback,
    1:                                          nsnull);
    1: 
    1:     nsresult rv = result->QueryInterface(aIID, aResult);
    1: 
    1:     nsCOMPtr<nsIObserverService> obsSvc(do_GetService("@mozilla.org/observer-service;1"));
    1:     if (obsSvc && NS_SUCCEEDED(rv)) {
    1:         nsXULPrototypeCache *p = result;
    1:         obsSvc->AddObserver(p, "chrome-flush-skin-caches", PR_FALSE);
    1:         obsSvc->AddObserver(p, "chrome-flush-caches", PR_FALSE);
    1:     }
    1: 
    1:     return rv;
    1: }
    1: 
    1: /* static */ nsXULPrototypeCache*
    1: nsXULPrototypeCache::GetInstance()
    1: {
    1:     // Theoretically this can return nsnull and callers should handle that.
    1:     if (!sInstance) {
    1:         nsIXULPrototypeCache* cache;
    1: 
    1:         CallGetService(kXULPrototypeCacheCID, &cache);
    1: 
 3233:         sInstance = static_cast<nsXULPrototypeCache*>(cache);
    1:     }
    1:     return sInstance;
    1: }
    1: 
    1: /* static */ nsIFastLoadService*
    1: nsXULPrototypeCache::GetFastLoadService()
    1: {
    1:     return gFastLoadService;
    1: }
    1: 
    1: //----------------------------------------------------------------------
    1: 
    1: NS_IMETHODIMP
    1: nsXULPrototypeCache::Observe(nsISupports* aSubject,
    1:                              const char *aTopic,
    1:                              const PRUnichar *aData)
    1: {
    1:     if (!strcmp(aTopic, "chrome-flush-skin-caches")) {
    1:         FlushSkinFiles();
    1:     }
    1:     else if (!strcmp(aTopic, "chrome-flush-caches")) {
    1:         Flush();
    1:     }
    1:     else {
    1:         NS_WARNING("Unexpected observer topic.");
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: nsXULPrototypeDocument*
    1: nsXULPrototypeCache::GetPrototype(nsIURI* aURI)
    1: {
    1:     nsXULPrototypeDocument* protoDoc = mPrototypeTable.GetWeak(aURI);
    1: 
    1:     if (!protoDoc) {
    1:         // No prototype in XUL memory cache. Spin up FastLoad Service and
    1:         // look in FastLoad file.
    1:         nsresult rv = StartFastLoad(aURI);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             nsCOMPtr<nsIObjectInputStream> objectInput;
    1:             gFastLoadService->GetInputStream(getter_AddRefs(objectInput));
    1: 
    1:             rv = StartFastLoadingURI(aURI, nsIFastLoadService::NS_FASTLOAD_READ);
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 nsCOMPtr<nsIURI> oldURI;
    1:                 gFastLoadService->SelectMuxedDocument(aURI, getter_AddRefs(oldURI));
    1: 
    1:                 // Create a new prototype document.
    1:                 nsRefPtr<nsXULPrototypeDocument> newProto;
    1:                 rv = NS_NewXULPrototypeDocument(getter_AddRefs(newProto));
    1:                 if (NS_FAILED(rv)) return nsnull;
    1: 
    1:                 rv = newProto->Read(objectInput);
    1:                 if (NS_SUCCEEDED(rv)) {
    1:                     rv = PutPrototype(newProto);
    1:                     if (NS_FAILED(rv))
    1:                         newProto = nsnull;
    1: 
    1:                     gFastLoadService->EndMuxedDocument(aURI);
    1:                 } else {
    1:                     newProto = nsnull;
    1:                 }
    1: 
    1:                 RemoveFromFastLoadSet(aURI);
    1:                 protoDoc = newProto;
    1:             }
    1:         }
    1:     }
    1:     return protoDoc;
    1: }
    1: 
    1: nsresult
    1: nsXULPrototypeCache::PutPrototype(nsXULPrototypeDocument* aDocument)
    1: {
    1:     nsCOMPtr<nsIURI> uri = aDocument->GetURI();
    1:     // Put() releases any old value and addrefs the new one
    1:     NS_ENSURE_TRUE(mPrototypeTable.Put(uri, aDocument), NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsXULPrototypeCache::PutStyleSheet(nsICSSStyleSheet* aStyleSheet)
    1: {
    1:     nsCOMPtr<nsIURI> uri;
    1:     nsresult rv = aStyleSheet->GetSheetURI(getter_AddRefs(uri));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:    NS_ENSURE_TRUE(mStyleSheetTable.Put(uri, aStyleSheet),
    1:                   NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: void*
    1: nsXULPrototypeCache::GetScript(nsIURI* aURI, PRUint32 *aLangID)
    1: {
    1:     CacheScriptEntry entry;
    1:     if (!mScriptTable.Get(aURI, &entry)) {
    1:         *aLangID = nsIProgrammingLanguage::UNKNOWN;
    1:         return nsnull;
    1:     }
    1:     *aLangID = entry.mScriptTypeID;
    1:     return entry.mScriptObject;
    1: }
    1: 
    1: 
 4863: /* static */
20261: static PLDHashOperator
 4863: ReleaseScriptObjectCallback(nsIURI* aKey, CacheScriptEntry &aData, void* aClosure)
 4863: {
 4863:     nsCOMPtr<nsIScriptRuntime> rt;
 4863:     if (NS_SUCCEEDED(NS_GetScriptRuntimeByID(aData.mScriptTypeID, getter_AddRefs(rt))))
 4863:         rt->DropScriptObject(aData.mScriptObject);
 4863:     return PL_DHASH_REMOVE;
 4863: }
 4863: 
    1: nsresult
    1: nsXULPrototypeCache::PutScript(nsIURI* aURI, PRUint32 aLangID, void* aScriptObject)
    1: {
 4863:     CacheScriptEntry existingEntry;
 4863:     if (mScriptTable.Get(aURI, &existingEntry)) {
 4863:         NS_WARNING("loaded the same script twice (bug 392650)");
 4863: 
 4863:         // Reuse the callback used for enumeration in FlushScripts
 4863:         ReleaseScriptObjectCallback(aURI, existingEntry, nsnull);
 4863:     }
 4863: 
    1:     CacheScriptEntry entry = {aLangID, aScriptObject};
    1: 
    1:     NS_ENSURE_TRUE(mScriptTable.Put(aURI, entry), NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     // Lock the object from being gc'd until it is removed from the cache
    1:     nsCOMPtr<nsIScriptRuntime> rt;
    1:     nsresult rv = NS_GetScriptRuntimeByID(aLangID, getter_AddRefs(rt));
    1:     if (NS_SUCCEEDED(rv))
    1:         rv = rt->HoldScriptObject(aScriptObject);
    1:     NS_ASSERTION(NS_SUCCEEDED(rv), "Failed to GC lock the object");
    1: 
    1:     // On failure doing the lock, we should remove the map entry?
    1:     return rv;
    1: }
    1: 
    1: void
    1: nsXULPrototypeCache::FlushScripts()
    1: {
    1:     // This callback will unlock each object so it can once again be gc'd.
    1:     // XXX - this might be slow - we fetch the runtime each and every object.
    1:     mScriptTable.Enumerate(ReleaseScriptObjectCallback, nsnull);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULPrototypeCache::PutXBLDocumentInfo(nsIXBLDocumentInfo* aDocumentInfo)
    1: {
    1:     nsIURI* uri = aDocumentInfo->DocumentURI();
    1: 
    1:     nsCOMPtr<nsIXBLDocumentInfo> info;
    1:     mXBLDocTable.Get(uri, getter_AddRefs(info));
    1:     if (!info) {
    1:         NS_ENSURE_TRUE(mXBLDocTable.Put(uri, aDocumentInfo),
    1:                        NS_ERROR_OUT_OF_MEMORY);
    1:     }
    1:     return NS_OK;
    1: }
    1: 
20261: static PLDHashOperator
    1: FlushSkinXBL(nsIURI* aKey, nsCOMPtr<nsIXBLDocumentInfo>& aDocInfo, void* aClosure)
    1: {
    1:   nsCAutoString str;
    1:   aKey->GetPath(str);
    1: 
    1:   PLDHashOperator ret = PL_DHASH_NEXT;
    1: 
    1:   if (!strncmp(str.get(), "/skin", 5)) {
    1:     ret = PL_DHASH_REMOVE;
    1:   }
    1: 
    1:   return ret;
    1: }
    1: 
20261: static PLDHashOperator
    1: FlushSkinSheets(nsIURI* aKey, nsCOMPtr<nsICSSStyleSheet>& aSheet, void* aClosure)
    1: {
    1:   nsCOMPtr<nsIURI> uri;
    1:   aSheet->GetSheetURI(getter_AddRefs(uri));
    1:   nsCAutoString str;
    1:   uri->GetPath(str);
    1: 
    1:   PLDHashOperator ret = PL_DHASH_NEXT;
    1: 
    1:   if (!strncmp(str.get(), "/skin", 5)) {
    1:     // This is a skin binding. Add the key to the list.
    1:     ret = PL_DHASH_REMOVE;
    1:   }
    1:   return ret;
    1: }
    1: 
20261: static PLDHashOperator
    1: FlushScopedSkinStylesheets(nsIURI* aKey, nsCOMPtr<nsIXBLDocumentInfo> &aDocInfo, void* aClosure)
    1: {
    1:   aDocInfo->FlushSkinStylesheets();
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: void
    1: nsXULPrototypeCache::FlushSkinFiles()
    1: {
    1:   // Flush out skin XBL files from the cache.
    1:   mXBLDocTable.Enumerate(FlushSkinXBL, nsnull);
    1: 
    1:   // Now flush out our skin stylesheets from the cache.
    1:   mStyleSheetTable.Enumerate(FlushSkinSheets, nsnull);
    1: 
    1:   // Iterate over all the remaining XBL and make sure cached
    1:   // scoped skin stylesheets are flushed and refetched by the
    1:   // prototype bindings.
    1:   mXBLDocTable.Enumerate(FlushScopedSkinStylesheets, nsnull);
    1: }
    1: 
    1: 
    1: void
    1: nsXULPrototypeCache::Flush()
    1: {
    1:     mPrototypeTable.Clear();
    1: 
    1:     // Clear the script cache, as it refers to prototype-owned mJSObjects.
    1:     FlushScripts();
    1: 
    1:     mStyleSheetTable.Clear();
    1:     mXBLDocTable.Clear();
    1: }
    1: 
    1: 
    1: PRBool
    1: nsXULPrototypeCache::IsEnabled()
    1: {
    1:     return !gDisableXULCache;
    1: }
    1: 
    1: static PRBool gDisableXULFastLoad = PR_FALSE;           // enabled by default
    1: static PRBool gChecksumXULFastLoadFile = PR_TRUE;       // XXXbe too paranoid
    1: 
    1: void
    1: nsXULPrototypeCache::AbortFastLoads()
    1: {
    1: #ifdef DEBUG_brendan
    1:     NS_BREAK();
    1: #endif
    1: 
    1:     // Save a strong ref to the FastLoad file, so we can remove it after we
    1:     // close open streams to it.
    1:     nsCOMPtr<nsIFile> file = gFastLoadFile;
    1: 
    1:     // Flush the XUL cache for good measure, in case we cached a bogus/downrev
    1:     // script, somehow.
    1:     Flush();
    1: 
    1:     // Clear the FastLoad set
    1:     mFastLoadURITable.Clear();
    1: 
    1:     if (! gFastLoadService)
    1:         return;
    1: 
    1:     // Fetch the current input (if FastLoad file existed) or output (if we're
    1:     // creating the FastLoad file during this app startup) stream.
    1:     nsCOMPtr<nsIObjectInputStream> objectInput;
    1:     nsCOMPtr<nsIObjectOutputStream> objectOutput;
    1:     gFastLoadService->GetInputStream(getter_AddRefs(objectInput));
    1:     gFastLoadService->GetOutputStream(getter_AddRefs(objectOutput));
    1: 
    1:     if (objectOutput) {
    1:         gFastLoadService->SetOutputStream(nsnull);
    1: 
    1:         if (NS_SUCCEEDED(objectOutput->Close()) && gChecksumXULFastLoadFile)
    1:             gFastLoadService->CacheChecksum(gFastLoadFile,
    1:                                             objectOutput);
    1:     }
    1: 
    1:     if (objectInput) {
    1:         // If this is the last of one or more XUL master documents loaded
    1:         // together at app startup, close the FastLoad service's singleton
    1:         // input stream now.
    1:         gFastLoadService->SetInputStream(nsnull);
    1:         objectInput->Close();
    1:     }
    1: 
    1:     // Now rename or remove the file.
    1:     if (file) {
    1: #ifdef DEBUG
    1:         // Remove any existing Aborted.mfasl files generated in previous runs.
    1:         nsCOMPtr<nsIFile> existingAbortedFile;
    1:         file->Clone(getter_AddRefs(existingAbortedFile));
    1:         if (existingAbortedFile) {
    1:             existingAbortedFile->SetLeafName(NS_LITERAL_STRING("Aborted.mfasl"));
    1:             PRBool fileExists = PR_FALSE;
    1:             existingAbortedFile->Exists(&fileExists);
    1:             if (fileExists)
    1:                 existingAbortedFile->Remove(PR_FALSE);
    1:         }
    1:         file->MoveToNative(nsnull, NS_LITERAL_CSTRING("Aborted.mfasl"));
    1: #else
    1:         file->Remove(PR_FALSE);
    1: #endif
    1:     }
    1: 
    1:     // If the list is empty now, the FastLoad process is done.
    1:     NS_RELEASE(gFastLoadService);
    1:     NS_RELEASE(gFastLoadFile);
    1: }
    1: 
    1: 
    1: void
    1: nsXULPrototypeCache::RemoveFromFastLoadSet(nsIURI* aURI)
    1: {
    1:     mFastLoadURITable.Remove(aURI);
    1: }
    1: 
    1: static const char kDisableXULFastLoadPref[] = "nglayout.debug.disable_xul_fastload";
    1: static const char kChecksumXULFastLoadFilePref[] = "nglayout.debug.checksum_xul_fastload_file";
    1: 
    1: nsresult
    1: nsXULPrototypeCache::WritePrototype(nsXULPrototypeDocument* aPrototypeDocument)
    1: {
    1:     nsresult rv = NS_OK, rv2 = NS_OK;
    1: 
    1:     // We're here before the FastLoad service has been initialized, probably because
    1:     // of the profile manager. Bail quietly, don't worry, we'll be back later.
    1:     if (! gFastLoadService)
    1:         return NS_OK;
    1: 
    1:     // Fetch the current input (if FastLoad file existed) or output (if we're
    1:     // creating the FastLoad file during this app startup) stream.
    1:     nsCOMPtr<nsIObjectInputStream> objectInput;
    1:     nsCOMPtr<nsIObjectOutputStream> objectOutput;
    1:     gFastLoadService->GetInputStream(getter_AddRefs(objectInput));
    1:     gFastLoadService->GetOutputStream(getter_AddRefs(objectOutput));
    1: 
    1:     nsCOMPtr<nsIURI> protoURI = aPrototypeDocument->GetURI();
    1: 
    1:     // Remove this document from the FastLoad table. We use the table's
    1:     // emptiness instead of a counter to decide when the FastLoad process
    1:     // has completed. When complete, we can write footer details to the
    1:     // FastLoad file.
    1:     RemoveFromFastLoadSet(protoURI);
    1: 
    1:     PRInt32 count = mFastLoadURITable.Count();
    1: 
    1:     if (objectOutput) {
    1:         rv = StartFastLoadingURI(protoURI, nsIFastLoadService::NS_FASTLOAD_WRITE);
    1:         if (NS_SUCCEEDED(rv)) {
    1:             // Re-select the URL of the current prototype, as out-of-line script loads
    1:             // may have changed
    1:             nsCOMPtr<nsIURI> oldURI;
    1:             gFastLoadService->SelectMuxedDocument(protoURI, getter_AddRefs(oldURI));
    1: 
    1:             aPrototypeDocument->Write(objectOutput);
    1: 
    1:             gFastLoadService->EndMuxedDocument(protoURI);
    1:         }
    1: 
    1:         // If this is the last of one or more XUL master documents loaded
    1:         // together at app startup, close the FastLoad service's singleton
    1:         // output stream now.
    1:         //
    1:         // NB: we must close input after output, in case the output stream
    1:         // implementation needs to read from the input stream, to compute a
    1:         // FastLoad file checksum.  In that case, the implementation used
    1:         // nsIFastLoadFileIO to get the corresponding input stream for this
    1:         // output stream.
    1:         if (count == 0) {
    1:             gFastLoadService->SetOutputStream(nsnull);
    1:             rv = objectOutput->Close();
    1: 
    1:             if (NS_SUCCEEDED(rv) && gChecksumXULFastLoadFile) {
    1:                 rv = gFastLoadService->CacheChecksum(gFastLoadFile,
    1:                                                      objectOutput);
    1:             }
    1:         }
    1:     }
    1: 
    1:     if (objectInput) {
    1:         // If this is the last of one or more XUL master documents loaded
    1:         // together at app startup, close the FastLoad service's singleton
    1:         // input stream now.
    1:         if (count == 0) {
    1:             gFastLoadService->SetInputStream(nsnull);
    1:             rv2 = objectInput->Close();
    1:         }
    1:     }
    1: 
    1:     // If the list is empty now, the FastLoad process is done.
    1:     if (count == 0) {
    1:         NS_RELEASE(gFastLoadService);
    1:         NS_RELEASE(gFastLoadFile);
    1:     }
    1: 
    1:     return NS_FAILED(rv) ? rv : rv2;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsXULPrototypeCache::StartFastLoadingURI(nsIURI* aURI, PRInt32 aDirectionFlags)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCAutoString urlspec;
    1:     rv = aURI->GetAsciiSpec(urlspec);
    1:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     // If StartMuxedDocument returns NS_ERROR_NOT_AVAILABLE, then
    1:     // we must be reading the file, and urlspec was not associated
    1:     // with any multiplexed stream in it.  The FastLoad service
    1:     // will therefore arrange to update the file, writing new data
    1:     // at the end while old (available) data continues to be read
    1:     // from the pre-existing part of the file.
    1:     return gFastLoadService->StartMuxedDocument(aURI, urlspec.get(), aDirectionFlags);
    1: }
    1: 
20261: static int
    1: FastLoadPrefChangedCallback(const char* aPref, void* aClosure)
    1: {
    1:     PRBool wasEnabled = !gDisableXULFastLoad;
    1:     gDisableXULFastLoad =
    1:         nsContentUtils::GetBoolPref(kDisableXULFastLoadPref,
    1:                                     gDisableXULFastLoad);
    1: 
    1:     if (wasEnabled && gDisableXULFastLoad) {
    1:         static NS_DEFINE_CID(kXULPrototypeCacheCID, NS_XULPROTOTYPECACHE_CID);
    1:         nsCOMPtr<nsIXULPrototypeCache> cache =
    1:             do_GetService(kXULPrototypeCacheCID);
    1: 
    1:         if (cache)
    1:             cache->AbortFastLoads();
    1:     }
    1: 
    1:     gChecksumXULFastLoadFile =
    1:         nsContentUtils::GetBoolPref(kChecksumXULFastLoadFilePref,
    1:                                     gChecksumXULFastLoadFile);
    1: 
    1:     return 0;
    1: }
    1: 
    1: 
    1: class nsXULFastLoadFileIO : public nsIFastLoadFileIO
    1: {
    1:   public:
    1:     nsXULFastLoadFileIO(nsIFile* aFile)
33672:       : mFile(aFile), mTruncateOutputFile(true) {
    1:     }
    1: 
    1:     virtual ~nsXULFastLoadFileIO() {
    1:     }
    1: 
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIFASTLOADFILEIO
    1: 
    1:     nsCOMPtr<nsIFile>         mFile;
    1:     nsCOMPtr<nsIInputStream>  mInputStream;
    1:     nsCOMPtr<nsIOutputStream> mOutputStream;
33672:     bool mTruncateOutputFile;
    1: };
    1: 
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(nsXULFastLoadFileIO, nsIFastLoadFileIO)
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXULFastLoadFileIO::GetInputStream(nsIInputStream** aResult)
    1: {
    1:     if (! mInputStream) {
    1:         nsresult rv;
    1:         nsCOMPtr<nsIInputStream> fileInput;
    1:         rv = NS_NewLocalFileInputStream(getter_AddRefs(fileInput), mFile);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         rv = NS_NewBufferedInputStream(getter_AddRefs(mInputStream),
    1:                                        fileInput,
    1:                                        XUL_DESERIALIZATION_BUFFER_SIZE);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     NS_ADDREF(*aResult = mInputStream);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsXULFastLoadFileIO::GetOutputStream(nsIOutputStream** aResult)
    1: {
    1:     if (! mOutputStream) {
    1:         PRInt32 ioFlags = PR_WRONLY;
33672:         if (mTruncateOutputFile)
    1:             ioFlags |= PR_CREATE_FILE | PR_TRUNCATE;
    1: 
    1:         nsresult rv;
    1:         nsCOMPtr<nsIOutputStream> fileOutput;
    1:         rv = NS_NewLocalFileOutputStream(getter_AddRefs(fileOutput), mFile,
    1:                                          ioFlags, 0644);
    1:         if (NS_FAILED(rv)) return rv;
    1: 
    1:         rv = NS_NewBufferedOutputStream(getter_AddRefs(mOutputStream),
    1:                                         fileOutput,
    1:                                         XUL_SERIALIZATION_BUFFER_SIZE);
    1:         if (NS_FAILED(rv)) return rv;
    1:     }
    1: 
    1:     NS_ADDREF(*aResult = mOutputStream);
    1:     return NS_OK;
    1: }
    1: 
33672: NS_IMETHODIMP
33672: nsXULFastLoadFileIO::DisableTruncate()
33672: {
33672:     mTruncateOutputFile = false;
33672:     return NS_OK;
33672: }
33672: 
    1: nsresult
    1: nsXULPrototypeCache::StartFastLoad(nsIURI* aURI)
    1: {
    1:     nsresult rv;
    1: 
    1:     nsCAutoString path;
    1:     aURI->GetPath(path);
    1:     if (!StringEndsWith(path, NS_LITERAL_CSTRING(".xul")))
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // Test gFastLoadFile to decide whether this is the first nsXULDocument
    1:     // participating in FastLoad.  If gFastLoadFile is non-null, this document
    1:     // must not be first, but it can join the FastLoad process.  Examples of
    1:     // multiple master documents participating include hiddenWindow.xul and
    1:     // navigator.xul on the Mac, and multiple-app-component (e.g., mailnews
    1:     // and browser) startup due to command-line arguments.
    1:     //
    1:     // XXXbe we should attempt to update the FastLoad file after startup!
    1:     //
    1:     // XXXbe we do not yet use nsFastLoadPtrs, but once we do, we must keep
    1:     // the FastLoad input stream open for the life of the app.
    1:     if (gFastLoadService && gFastLoadFile) {
    1:         mFastLoadURITable.Put(aURI, 1);
    1: 
    1:         return NS_OK;
    1:     }
    1: 
    1:     // Use a local to refer to the service till we're sure we succeeded, then
    1:     // commit to gFastLoadService.  Same for gFastLoadFile, which is used to
    1:     // delete the FastLoad file on abort.
    1:     nsCOMPtr<nsIFastLoadService> fastLoadService(do_GetFastLoadService());
    1:     if (! fastLoadService)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     gDisableXULFastLoad =
    1:         nsContentUtils::GetBoolPref(kDisableXULFastLoadPref,
    1:                                     gDisableXULFastLoad);
    1:     gChecksumXULFastLoadFile =
    1:         nsContentUtils::GetBoolPref(kChecksumXULFastLoadFilePref,
    1:                                     gChecksumXULFastLoadFile);
    1:     nsContentUtils::RegisterPrefCallback(kDisableXULFastLoadPref,
    1:                                          FastLoadPrefChangedCallback,
    1:                                          nsnull);
    1:     nsContentUtils::RegisterPrefCallback(kChecksumXULFastLoadFilePref,
    1:                                          FastLoadPrefChangedCallback,
    1:                                          nsnull);
    1: 
    1:     if (gDisableXULFastLoad)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     // Get the chrome directory to validate against the one stored in the
    1:     // FastLoad file, or to store there if we're generating a new file.
    1:     nsCOMPtr<nsIFile> chromeDir;
    1:     rv = NS_GetSpecialDirectory(NS_APP_CHROME_DIR, getter_AddRefs(chromeDir));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     nsCAutoString chromePath;
    1:     rv = chromeDir->GetNativePath(chromePath);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCOMPtr<nsIFile> file;
    1:     rv = fastLoadService->NewFastLoadFile(XUL_FASTLOAD_FILE_BASENAME,
    1:                                           getter_AddRefs(file));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Give the FastLoad service an object by which it can get or create a
    1:     // file output stream given an input stream on the same file.
    1:     nsXULFastLoadFileIO* xio = new nsXULFastLoadFileIO(file);
 3233:     nsCOMPtr<nsIFastLoadFileIO> io = static_cast<nsIFastLoadFileIO*>(xio);
    1:     if (! io)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1:     fastLoadService->SetFileIO(io);
    1: 
    1:     nsCOMPtr<nsIXULChromeRegistry> chromeReg(do_GetService(NS_CHROMEREGISTRY_CONTRACTID, &rv));
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // XXXbe we assume the first package's locale is the same as the locale of
    1:     // all subsequent packages of FastLoaded chrome URIs....
    1:     nsCAutoString package;
    1:     rv = aURI->GetHost(package);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     nsCAutoString locale;
    1:     rv = chromeReg->GetSelectedLocale(package, locale);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     // Try to read an existent FastLoad file.
    1:     PRBool exists = PR_FALSE;
    1:     if (NS_SUCCEEDED(file->Exists(&exists)) && exists) {
    1:         nsCOMPtr<nsIObjectInputStream> objectInput;
33672:         rv = fastLoadService->NewInputStream(file, getter_AddRefs(objectInput));
    1: 
    1:         if (NS_SUCCEEDED(rv)) {
    1:             if (NS_SUCCEEDED(rv)) {
    1:                 // Get the XUL fastload file version number, which should be
    1:                 // decremented whenever the XUL-specific file format changes
    1:                 // (see public/nsIXULPrototypeCache.h for the #define).
    1:                 PRUint32 xulFastLoadVersion, jsByteCodeVersion;
    1:                 rv = objectInput->Read32(&xulFastLoadVersion);
    1:                 rv |= objectInput->Read32(&jsByteCodeVersion);
    1:                 if (NS_SUCCEEDED(rv)) {
    1:                     if (xulFastLoadVersion != XUL_FASTLOAD_FILE_VERSION ||
    1:                         jsByteCodeVersion != JSXDR_BYTECODE_VERSION) {
    1: #ifdef DEBUG
    1:                         printf((xulFastLoadVersion != XUL_FASTLOAD_FILE_VERSION)
    1:                                ? "bad FastLoad file version\n"
    1:                                : "bad JS bytecode version\n");
    1: #endif
    1:                         rv = NS_ERROR_UNEXPECTED;
    1:                     } else {
    1:                         nsCAutoString fileChromePath, fileLocale;
    1: 
    1:                         rv = objectInput->ReadCString(fileChromePath);
    1:                         rv |= objectInput->ReadCString(fileLocale);
    1:                         if (NS_SUCCEEDED(rv) &&
    1:                             (!fileChromePath.Equals(chromePath) ||
    1:                              !fileLocale.Equals(locale))) {
    1:                             rv = NS_ERROR_UNEXPECTED;
    1:                         }
    1:                     }
    1:                 }
    1:             }
    1:         }
    1: 
    1:         if (NS_SUCCEEDED(rv)) {
    1:             fastLoadService->SetInputStream(objectInput);
    1:         } else {
    1:             // NB: we must close before attempting to remove, for non-Unix OSes
    1:             // that can't do open-unlink.
    1:             if (objectInput)
    1:                 objectInput->Close();
    1:             xio->mInputStream = nsnull;
    1: 
    1: #ifdef DEBUG
    1:             file->MoveToNative(nsnull, NS_LITERAL_CSTRING("Invalid.mfasl"));
    1: #else
    1:             file->Remove(PR_FALSE);
    1: #endif
    1:             exists = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     // FastLoad file not found, or invalid: write a new one.
    1:     if (! exists) {
    1:         nsCOMPtr<nsIOutputStream> output;
    1:         rv = io->GetOutputStream(getter_AddRefs(output));
    1:         if (NS_FAILED(rv))
    1:             return rv;
    1: 
    1:         nsCOMPtr<nsIObjectOutputStream> objectOutput;
    1:         rv = fastLoadService->NewOutputStream(output,
    1:                                               getter_AddRefs(objectOutput));
    1:         if (NS_SUCCEEDED(rv)) {
    1:             rv = objectOutput->Write32(XUL_FASTLOAD_FILE_VERSION);
    1:             rv |= objectOutput->Write32(JSXDR_BYTECODE_VERSION);
    1:             rv |= objectOutput->WriteStringZ(chromePath.get());
    1:             rv |= objectOutput->WriteStringZ(locale.get());
    1:         }
    1: 
    1:         // Remove here even though some errors above will lead to a FastLoad
    1:         // file invalidation.  Other errors (failure to note the dependency on
    1:         // installed-chrome.txt, e.g.) will not cause invalidation, and we may
    1:         // as well tidy up now.
    1:         if (NS_FAILED(rv)) {
    1:             if (objectOutput)
    1:                 objectOutput->Close();
    1:             else
    1:                 output->Close();
    1:             xio->mOutputStream = nsnull;
    1: 
    1:             file->Remove(PR_FALSE);
    1:             return NS_ERROR_FAILURE;
    1:         }
    1: 
    1:         fastLoadService->SetOutputStream(objectOutput);
    1:     }
    1: 
    1:     // Success!  Insert this URI into the mFastLoadURITable
    1:     // and commit locals to globals.
    1:     mFastLoadURITable.Put(aURI, 1);
    1: 
    1:     NS_ADDREF(gFastLoadService = fastLoadService);
    1:     NS_ADDREF(gFastLoadFile = file);
    1:     return NS_OK;
    1: }
    1: 
