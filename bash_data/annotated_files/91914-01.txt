    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   John Gaunt (jgaunt@netscape.com)
    1:  *   Aaron Leventhal (aaronl@netscape.com)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAccessible.h"
39503: 
39503: #include "nsIXBLAccessible.h"
39503: 
47172: #include "AccGroupInfo.h"
43888: #include "AccIterator.h"
41384: #include "nsAccUtils.h"
51377: #include "nsAccEvent.h"
75194: #include "nsAccessibleRelation.h"
41384: #include "nsAccessibilityService.h"
39503: #include "nsAccTreeWalker.h"
75194: #include "nsIAccessibleRelation.h"
90500: #include "nsEventShell.h"
89598: #include "nsRootAccessible.h"
41384: #include "nsTextEquivUtils.h"
75194: #include "Relation.h"
87094: #include "Role.h"
67790: #include "States.h"
90500: #include "StyleInfo.h"
 4451: 
89598: #include "nsIDOMCSSValue.h"
89598: #include "nsIDOMCSSPrimitiveValue.h"
 4451: #include "nsIDOMElement.h"
 4451: #include "nsIDOMDocument.h"
 4451: #include "nsIDOMDocumentXBL.h"
 4451: #include "nsIDOMHTMLDocument.h"
 4451: #include "nsIDOMHTMLFormElement.h"
 4451: #include "nsIDOMNodeFilter.h"
81041: #include "nsIDOMHTMLElement.h"
 4451: #include "nsIDOMTreeWalker.h"
 4451: #include "nsIDOMXULButtonElement.h"
 4451: #include "nsIDOMXULDocument.h"
 4451: #include "nsIDOMXULElement.h"
 4451: #include "nsIDOMXULLabelElement.h"
 4451: #include "nsIDOMXULSelectCntrlEl.h"
 4451: #include "nsIDOMXULSelectCntrlItemEl.h"
 4451: #include "nsPIDOMWindow.h"
 4451: 
 4451: #include "nsIDocument.h"
 4451: #include "nsIContent.h"
 4451: #include "nsIForm.h"
 4451: #include "nsIFormControl.h"
 4451: 
71071: #include "nsLayoutUtils.h"
    1: #include "nsIPresShell.h"
    1: #include "nsPresContext.h"
    1: #include "nsIFrame.h"
37073: #include "nsIView.h"
 4451: #include "nsIDocShellTreeItem.h"
12642: #include "nsIScrollableFrame.h"
29018: #include "nsFocusManager.h"
 4451: 
    1: #include "nsXPIDLString.h"
    1: #include "nsUnicharUtils.h"
 6279: #include "nsReadableUtils.h"
    1: #include "prdtoa.h"
    1: #include "nsIAtom.h"
    1: #include "nsIURI.h"
24822: #include "nsArrayUtils.h"
    1: #include "nsIMutableArray.h"
  511: #include "nsIObserverService.h"
 4451: #include "nsIServiceManager.h"
 7830: #include "nsWhitespaceTokenizer.h"
13012: #include "nsAttrName.h"
13757: #include "nsNetUtil.h"
68780: #include "nsEventStates.h"
    1: 
    1: #ifdef NS_DEBUG
    1: #include "nsIDOMCharacterData.h"
    1: #endif
    1: 
50861: #include "mozilla/unused.h"
71199: #include "mozilla/Preferences.h"
74131: #include "mozilla/dom/Element.h"
71199: 
71199: using namespace mozilla;
74618: using namespace mozilla::a11y;
50861: 
    1: 
16428: ////////////////////////////////////////////////////////////////////////////////
16428: // nsAccessible. nsISupports
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_CLASS(nsAccessible)
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsAccessible, nsAccessNode)
36989:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mParent");
36989:   cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mParent.get()));
36989: 
36989:   PRUint32 i, length = tmp->mChildren.Length();
36989:   for (i = 0; i < length; ++i) {
36989:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mChildren[i]");
36989:     cb.NoteXPCOMChild(static_cast<nsIAccessible*>(tmp->mChildren[i].get()));
36989:   }
16428: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
16428: 
16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsAccessible, nsAccessNode)
16428:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mParent)
36989:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSTARRAY(mChildren)
16428: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
16428: 
    1: NS_IMPL_ADDREF_INHERITED(nsAccessible, nsAccessNode)
    1: NS_IMPL_RELEASE_INHERITED(nsAccessible, nsAccessNode)
    1: 
    1: nsresult nsAccessible::QueryInterface(REFNSIID aIID, void** aInstancePtr)
    1: {
    1:   // Custom-built QueryInterface() knows when we support nsIAccessibleSelectable
 8937:   // based on role attribute and aria-multiselectable
    1:   *aInstancePtr = nsnull;
    1: 
16428:   if (aIID.Equals(NS_GET_IID(nsXPCOMCycleCollectionParticipant))) {
16428:     *aInstancePtr = &NS_CYCLE_COLLECTION_NAME(nsAccessible);
16428:     return NS_OK;
16428:   }
16428: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessible))) {
 3233:     *aInstancePtr = static_cast<nsIAccessible*>(this);
    1:     NS_ADDREF_THIS();
    1:     return NS_OK;
    1:   }
    1: 
20246:   if (aIID.Equals(NS_GET_IID(nsAccessible))) {
20246:     *aInstancePtr = static_cast<nsAccessible*>(this);
20246:     NS_ADDREF_THIS();
20246:     return NS_OK;
20246:   }
20246: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleSelectable))) {
51865:     if (IsSelect()) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleSelectable*>(this);
    1:       NS_ADDREF_THIS();
 4648:       return NS_OK;
    1:     }
51865:     return NS_ERROR_NO_INTERFACE;
    1:   }
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleValue))) {
    1:     if (mRoleMapEntry && mRoleMapEntry->valueRule != eNoValue) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleValue*>(this);
    1:       NS_ADDREF_THIS();
 4648:       return NS_OK;
    1:     }
    1:   }                       
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIAccessibleHyperLink))) {
72484:     if (IsLink()) {
 3233:       *aInstancePtr = static_cast<nsIAccessibleHyperLink*>(this);
    1:       NS_ADDREF_THIS();
    1:       return NS_OK;
    1:     }
    1:     return NS_ERROR_NO_INTERFACE;
    1:   }
    1: 
 4470:   return nsAccessNodeWrap::QueryInterface(aIID, aInstancePtr);
    1: }
    1: 
89799: nsAccessible::nsAccessible(nsIContent* aContent, nsDocAccessible* aDoc) :
89799:   nsAccessNodeWrap(aContent, aDoc),
61466:   mParent(nsnull), mIndexInParent(-1), mFlags(eChildrenUninitialized),
50622:   mIndexOfEmbeddedChild(-1), mRoleMapEntry(nsnull)
    1: {
    1: #ifdef NS_DEBUG_X
    1:    {
    1:      nsCOMPtr<nsIPresShell> shell(do_QueryReferent(aShell));
  732:      printf(">>> %p Created Acc - DOM: %p  PS: %p", 
 3233:             (void*)static_cast<nsIAccessible*>(this), (void*)aNode,
  732:             (void*)shell.get());
  732:     nsCOMPtr<nsIContent> content = do_QueryInterface(aNode);
  732:     if (content) {
69361:       printf(" Con: %s@%p",
69361:              NS_ConvertUTF16toUTF8(content->NodeInfo()->QualifiedName()).get(),
69361:              (void *)content.get());
  732:       nsAutoString buf;
  732:       if (NS_SUCCEEDED(GetName(buf))) {
  732:         printf(" Name:[%s]", NS_ConvertUTF16toUTF8(buf).get());
    1:        }
    1:      }
    1:      printf("\n");
    1:    }
    1: #endif
    1: }
    1: 
    1: //-----------------------------------------------------
    1: // destruction
    1: //-----------------------------------------------------
    1: nsAccessible::~nsAccessible()
    1: {
    1: }
    1: 
29320: void
29320: nsAccessible::SetRoleMapEntry(nsRoleMapEntry* aRoleMapEntry)
 7830: {
 7830:   mRoleMapEntry = aRoleMapEntry;
 7830: }
 7830: 
20246: NS_IMETHODIMP
89598: nsAccessible::GetComputedStyleValue(const nsAString& aPseudoElt,
89598:                                     const nsAString& aPropertyName,
89598:                                     nsAString& aValue)
89598: {
89598:   if (IsDefunct())
89598:     return NS_ERROR_FAILURE;
89598: 
89598:   nsCOMPtr<nsIDOMCSSStyleDeclaration> styleDecl =
89598:     nsCoreUtils::GetComputedStyleDeclaration(aPseudoElt, mContent);
89598:   NS_ENSURE_TRUE(styleDecl, NS_ERROR_FAILURE);
89598: 
89598:   return styleDecl->GetPropertyValue(aPropertyName, aValue);
89598: }
89598: 
89598: NS_IMETHODIMP
89598: nsAccessible::GetComputedStyleCSSValue(const nsAString& aPseudoElt,
89598:                                        const nsAString& aPropertyName,
89598:                                        nsIDOMCSSPrimitiveValue **aCSSValue) {
89598:   NS_ENSURE_ARG_POINTER(aCSSValue);
89598:   *aCSSValue = nsnull;
89598: 
89598:   if (IsDefunct())
89598:     return NS_ERROR_FAILURE;
89598: 
89598:   nsCOMPtr<nsIDOMCSSStyleDeclaration> styleDecl =
89598:     nsCoreUtils::GetComputedStyleDeclaration(aPseudoElt, mContent);
89598:   NS_ENSURE_STATE(styleDecl);
89598: 
89598:   nsCOMPtr<nsIDOMCSSValue> cssValue;
89598:   styleDecl->GetPropertyCSSValue(aPropertyName, getter_AddRefs(cssValue));
89598:   NS_ENSURE_TRUE(cssValue, NS_ERROR_FAILURE);
89598: 
89598:   return CallQueryInterface(cssValue, aCSSValue);
89598: }
89598: 
89598: NS_IMETHODIMP
89598: nsAccessible::GetDocument(nsIAccessibleDocument **aDocument)
89598: {
89598:   NS_ENSURE_ARG_POINTER(aDocument);
89598: 
89800:   NS_IF_ADDREF(*aDocument = Document());
89598:   return NS_OK;
89598: }
89598: 
89598: NS_IMETHODIMP
89598: nsAccessible::GetDOMNode(nsIDOMNode **aDOMNode)
89598: {
89598:   NS_ENSURE_ARG_POINTER(aDOMNode);
89598:   *aDOMNode = nsnull;
89598: 
89598:   nsINode *node = GetNode();
89598:   if (node)
89598:     CallQueryInterface(node, aDOMNode);
89598: 
89598:   return NS_OK;
89598: }
89598: 
89598: NS_IMETHODIMP
89598: nsAccessible::GetRootDocument(nsIAccessibleDocument **aRootDocument)
89598: {
89598:   NS_ENSURE_ARG_POINTER(aRootDocument);
89598: 
89598:   nsRootAccessible* rootDocument = RootAccessible();
89598:   NS_IF_ADDREF(*aRootDocument = rootDocument);
89598:   return NS_OK;
89598: }
89598: 
89598: NS_IMETHODIMP
89598: nsAccessible::GetInnerHTML(nsAString& aInnerHTML)
89598: {
89598:   aInnerHTML.Truncate();
89598: 
89598:   nsCOMPtr<nsIDOMHTMLElement> htmlElement = do_QueryInterface(mContent);
89598:   NS_ENSURE_TRUE(htmlElement, NS_ERROR_NULL_POINTER);
89598: 
89598:   return htmlElement->GetInnerHTML(aInnerHTML);
89598: }
89598: 
89598: NS_IMETHODIMP
89598: nsAccessible::GetLanguage(nsAString& aLanguage)
89598: {
89598:   Language(aLanguage);
89598:   return NS_OK;
89598: }
89598: 
89598: NS_IMETHODIMP
20246: nsAccessible::GetName(nsAString& aName)
    1: {
    1:   aName.Truncate();
20246: 
20246:   if (IsDefunct())
20246:     return NS_ERROR_FAILURE;
20246: 
20246:   GetARIAName(aName);
20246:   if (!aName.IsEmpty())
    1:     return NS_OK;
20246: 
43504:   nsCOMPtr<nsIXBLAccessible> xblAccessible(do_QueryInterface(mContent));
28315:   if (xblAccessible) {
29559:     xblAccessible->GetAccessibleName(aName);
28315:     if (!aName.IsEmpty())
28315:       return NS_OK;
28315:   }
28315: 
22205:   nsresult rv = GetNameInternal(aName);
22205:   NS_ENSURE_SUCCESS(rv, rv);
22205: 
22205:   if (!aName.IsEmpty())
22205:     return NS_OK;
22205: 
22205:   // In the end get the name from tooltip.
22205:   nsIAtom *tooltipAttr = nsnull;
22205: 
43504:   if (mContent->IsHTML())
78350:     tooltipAttr = nsGkAtoms::title;
43504:   else if (mContent->IsXUL())
78350:     tooltipAttr = nsGkAtoms::tooltiptext;
22205:   else
22205:     return NS_OK;
22205: 
22205:   // XXX: if CompressWhiteSpace worked on nsAString we could avoid a copy.
22205:   nsAutoString name;
43504:   if (mContent->GetAttr(kNameSpaceID_None, tooltipAttr, name)) {
22205:     name.CompressWhitespace();
22205:     aName = name;
25591:     return NS_OK_NAME_FROM_TOOLTIP;
25591:   }
25591: 
25591:   if (rv != NS_OK_EMPTY_NAME)
80486:     aName.SetIsVoid(true);
22205: 
22205:   return NS_OK;
    1: }
    1: 
69342: NS_IMETHODIMP
69342: nsAccessible::GetDescription(nsAString& aDescription)
    1: {
27711:   if (IsDefunct())
27711:     return NS_ERROR_FAILURE;
27711: 
69342:   nsAutoString desc;
69342:   Description(desc);
69342:   aDescription.Assign(desc);
69342: 
69342:   return NS_OK;
69342: }
69342: 
69342: void
69342: nsAccessible::Description(nsString& aDescription)
69342: {
    1:   // There are 4 conditions that make an accessible have no accDescription:
    1:   // 1. it's a text node; or
    1:   // 2. It has no DHTML describedby property
    1:   // 3. it doesn't have an accName; or
    1:   // 4. its title attribute already equals to its accName nsAutoString name; 
43504: 
69342:   if (mContent->IsNodeOfType(nsINode::eTEXT))
69342:     return;
69342: 
69342:   nsTextEquivUtils::
78350:     GetTextEquivFromIDRefs(this, nsGkAtoms::aria_describedby,
69342:                            aDescription);
69342: 
69342:   if (aDescription.IsEmpty()) {
79445:     bool isXUL = mContent->IsXUL();
    1:     if (isXUL) {
    1:       // Try XUL <description control="[id]">description text</description>
89800:       XULDescriptionIterator iter(Document(), mContent);
57932:       nsAccessible* descr = nsnull;
69342:       while ((descr = iter.Next()))
69342:         nsTextEquivUtils::AppendTextEquivFromContent(this, descr->GetContent(),
69342:                                                      &aDescription);
69342:       }
69342: 
69342:       if (aDescription.IsEmpty()) {
78350:         nsIAtom *descAtom = isXUL ? nsGkAtoms::tooltiptext :
78350:                                     nsGkAtoms::title;
69342:         if (mContent->GetAttr(kNameSpaceID_None, descAtom, aDescription)) {
    1:           nsAutoString name;
    1:           GetName(name);
69342:           if (name.IsEmpty() || aDescription == name)
    1:             // Don't use tooltip for a description if this object
    1:             // has no name or the tooltip is the same as the name
69342:             aDescription.Truncate();
69342:         }
69342:       }
69342:     }
69342:     aDescription.CompressWhitespace();
    1: }
    1: 
 5414: NS_IMETHODIMP
 5414: nsAccessible::GetKeyboardShortcut(nsAString& aAccessKey)
    1: {
 5414:   aAccessKey.Truncate();
 5414: 
43504:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
 5414: 
74014:   AccessKey().ToString(aAccessKey);
74014:   return NS_OK;
74014: }
74014: 
74014: KeyBinding
74014: nsAccessible::AccessKey() const
74014: {
43504:   PRUint32 key = nsCoreUtils::GetAccessKeyFor(mContent);
43504:   if (!key && mContent->IsElement()) {
57932:     nsAccessible* label = nsnull;
57932: 
57932:     // Copy access key from label node.
57932:     if (mContent->IsHTML()) {
57932:       // Unless it is labeled via an ancestor <label>, in which case that would
57932:       // be redundant.
89800:       HTMLLabelIterator iter(Document(), this,
57932:                              HTMLLabelIterator::eSkipAncestorLabel);
57932:       label = iter.Next();
57932: 
57932:     } else if (mContent->IsXUL()) {
89800:       XULLabelIterator iter(Document(), mContent);
57932:       label = iter.Next();
57932:     }
57932: 
57932:     if (label)
57932:       key = nsCoreUtils::GetAccessKeyFor(label->GetContent());
 5414:   }
 5414: 
 5414:   if (!key)
74014:     return KeyBinding();
74014: 
74014:   // Get modifier mask. Use ui.key.generalAccessKey (unless it is -1).
74014:   switch (Preferences::GetInt("ui.key.generalAccessKey", -1)) {
74014:   case -1:
74014:     break;
74014:   case nsIDOMKeyEvent::DOM_VK_SHIFT:
74014:     return KeyBinding(key, KeyBinding::kShift);
74014:   case nsIDOMKeyEvent::DOM_VK_CONTROL:
74014:     return KeyBinding(key, KeyBinding::kControl);
74014:   case nsIDOMKeyEvent::DOM_VK_ALT:
74014:     return KeyBinding(key, KeyBinding::kAlt);
74014:   case nsIDOMKeyEvent::DOM_VK_META:
74014:     return KeyBinding(key, KeyBinding::kMeta);
74014:   default:
74014:     return KeyBinding();
74014:   }
74014: 
74014:   // Determine the access modifier used in this context.
74014:   nsIDocument* document = mContent->GetCurrentDoc();
74014:   if (!document)
74014:     return KeyBinding();
74014:   nsCOMPtr<nsISupports> container = document->GetContainer();
74014:   if (!container)
74014:     return KeyBinding();
74014:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(container));
74014:   if (!treeItem)
74014:     return KeyBinding();
74014: 
74014:   nsresult rv = NS_ERROR_FAILURE;
74014:   PRInt32 itemType = 0, modifierMask = 0;
74014:   treeItem->GetItemType(&itemType);
74014:   switch (itemType) {
74014:     case nsIDocShellTreeItem::typeChrome:
74014:       rv = Preferences::GetInt("ui.key.chromeAccess", &modifierMask);
74014:       break;
74014:     case nsIDocShellTreeItem::typeContent:
74014:       rv = Preferences::GetInt("ui.key.contentAccess", &modifierMask);
74014:       break;
74014:   }
74014: 
74014:   return NS_SUCCEEDED(rv) ? KeyBinding(key, modifierMask) : KeyBinding();
74014: }
74014: 
74014: KeyBinding
74014: nsAccessible::KeyboardShortcut() const
74014: {
74014:   return KeyBinding();
    1: }
    1: 
29320: NS_IMETHODIMP
29320: nsAccessible::GetParent(nsIAccessible **aParent)
29320: {
35523:   NS_ENSURE_ARG_POINTER(aParent);
74545:   if (IsDefunct())
74545:     return NS_ERROR_FAILURE;
74545: 
74545:   NS_IF_ADDREF(*aParent = Parent());
35523:   return *aParent ? NS_OK : NS_ERROR_FAILURE;
35523: }
35523: 
35523:   /* readonly attribute nsIAccessible nextSibling; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetNextSibling(nsIAccessible **aNextSibling) 
35523: {
35523:   NS_ENSURE_ARG_POINTER(aNextSibling);
71380:   *aNextSibling = nsnull;
71380: 
71380:   if (IsDefunct())
71380:     return NS_ERROR_FAILURE;
35523: 
35523:   nsresult rv = NS_OK;
35523:   NS_IF_ADDREF(*aNextSibling = GetSiblingAtOffset(1, &rv));
35523:   return rv;
35523: }
35523: 
35523:   /* readonly attribute nsIAccessible previousSibling; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetPreviousSibling(nsIAccessible * *aPreviousSibling) 
35523: {
35523:   NS_ENSURE_ARG_POINTER(aPreviousSibling);
71380:   *aPreviousSibling = nsnull;
71380: 
71380:   if (IsDefunct())
71380:     return NS_ERROR_FAILURE;
35523: 
35523:   nsresult rv = NS_OK;
35523:   NS_IF_ADDREF(*aPreviousSibling = GetSiblingAtOffset(-1, &rv));
35523:   return rv;
35523: }
35523: 
35523:   /* readonly attribute nsIAccessible firstChild; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetFirstChild(nsIAccessible **aFirstChild) 
35523: {
35523:   NS_ENSURE_ARG_POINTER(aFirstChild);
35523:   *aFirstChild = nsnull;
35523: 
67626:   if (IsDefunct())
67626:     return NS_ERROR_FAILURE;
67626: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   if (childCount > 0)
35523:     NS_ADDREF(*aFirstChild = GetChildAt(0));
35523: 
35136:   return NS_OK;
35136: }
35136: 
35523:   /* readonly attribute nsIAccessible lastChild; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetLastChild(nsIAccessible **aLastChild)
35136: {
35523:   NS_ENSURE_ARG_POINTER(aLastChild);
35523:   *aLastChild = nsnull;
35523: 
67626:   if (IsDefunct())
67626:     return NS_ERROR_FAILURE;
67626: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   NS_IF_ADDREF(*aLastChild = GetChildAt(childCount - 1));
35523:   return NS_OK;
35523: }
35523: 
35523: NS_IMETHODIMP
35523: nsAccessible::GetChildAt(PRInt32 aChildIndex, nsIAccessible **aChild)
35136: {
35523:   NS_ENSURE_ARG_POINTER(aChild);
35523:   *aChild = nsnull;
35523: 
67626:   if (IsDefunct())
67626:     return NS_ERROR_FAILURE;
67626: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   // If child index is negative, then return last child.
35523:   // XXX: do we really need this?
35523:   if (aChildIndex < 0)
35523:     aChildIndex = childCount - 1;
35523: 
36989:   nsAccessible* child = GetChildAt(aChildIndex);
35523:   if (!child)
35523:     return NS_ERROR_INVALID_ARG;
35523: 
35523:   NS_ADDREF(*aChild = child);
35523:   return NS_OK;
35523: }
35523: 
35523: // readonly attribute nsIArray children;
35523: NS_IMETHODIMP
35523: nsAccessible::GetChildren(nsIArray **aOutChildren)
35133: {
35523:   NS_ENSURE_ARG_POINTER(aOutChildren);
10871:   *aOutChildren = nsnull;
35523: 
67626:   if (IsDefunct())
67626:     return NS_ERROR_FAILURE;
67626: 
35523:   PRInt32 childCount = GetChildCount();
35523:   NS_ENSURE_TRUE(childCount != -1, NS_ERROR_FAILURE);
35523: 
35523:   nsresult rv = NS_OK;
35523:   nsCOMPtr<nsIMutableArray> children =
35523:     do_CreateInstance(NS_ARRAY_CONTRACTID, &rv);
35523:   NS_ENSURE_SUCCESS(rv, rv);
35523: 
35523:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
35523:     nsIAccessible* child = GetChildAt(childIdx);
80486:     children->AppendElement(child, false);
    1:   }
    1: 
    1:   NS_ADDREF(*aOutChildren = children);
    1:   return NS_OK;
    1: }
    1: 
79445: bool
89679: nsAccessible::CanHaveAnonChildren()
    1: {
80486:   return true;
    1: }
    1: 
    1: /* readonly attribute long childCount; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetChildCount(PRInt32 *aChildCount) 
    1: {
35523:   NS_ENSURE_ARG_POINTER(aChildCount);
35523: 
67626:   if (IsDefunct())
67626:     return NS_ERROR_FAILURE;
67626: 
35523:   *aChildCount = GetChildCount();
35523:   return *aChildCount != -1 ? NS_OK : NS_ERROR_FAILURE;  
    1: }
    1: 
    1: /* readonly attribute long indexInParent; */
35523: NS_IMETHODIMP
35523: nsAccessible::GetIndexInParent(PRInt32 *aIndexInParent)
    1: {
35523:   NS_ENSURE_ARG_POINTER(aIndexInParent);
35523: 
72476:   *aIndexInParent = IndexInParent();
35523:   return *aIndexInParent != -1 ? NS_OK : NS_ERROR_FAILURE;
    1: }
    1: 
88363: void 
88363: nsAccessible::TranslateString(const nsAString& aKey, nsAString& aStringOut)
    1: {
    1:   nsXPIDLString xsValue;
    1: 
88363:   gStringBundle->GetStringFromName(PromiseFlatString(aKey).get(), getter_Copies(xsValue));
    1:   aStringOut.Assign(xsValue);
    1: }
    1: 
86931: PRUint64
86931: nsAccessible::VisibilityState()
    1: {
86931:   PRUint64 vstates = states::INVISIBLE | states::OFFSCREEN;
86931: 
86931:   nsIFrame* frame = GetFrame();
87943:   if (!frame)
87943:     return vstates;
87943: 
89799:   nsIPresShell* shell(mDoc->PresShell());
88613:   if (!shell)
88613:     return vstates;
86931: 
67790:   // We need to know if at least a kMinPixels around the object is visible,
86931:   // otherwise it will be marked states::OFFSCREEN.
    1:   const PRUint16 kMinPixels  = 12;
86931:   const nsSize frameSize = frame->GetSize();
86931:   const nsRectVisibility rectVisibility =
37073:     shell->GetRectVisibility(frame, nsRect(nsPoint(0,0), frameSize),
37073:                              nsPresContext::CSSPixelsToAppUnits(kMinPixels));
37073: 
86931:   if (rectVisibility == nsRectVisibility_kVisible)
86931:     vstates &= ~states::OFFSCREEN;
86931: 
    1:   // Zero area rects can occur in the first frame of a multi-frame text flow,
86931:   // in which case the rendered text is not empty and the frame should not be
86931:   // marked invisible.
86931:   // XXX Can we just remove this check? Why do we need to mark empty
86931:   // text invisible?
86931:   if (frame->GetType() == nsGkAtoms::textFrame &&
86931:       !(frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW) &&
86931:       frame->GetRect().IsEmpty()) {
 9480:     nsAutoString renderedText;
 9480:     frame->GetRenderedText(&renderedText, nsnull, nsnull, 0, 1);
86931:     if (renderedText.IsEmpty())
86931:       return vstates;
86931: 
 9480:   }
86931: 
88613:   // XXX Do we really need to cross from content to chrome ancestor?
88613:   if (!frame->IsVisibleConsideringAncestors(nsIFrame::VISIBILITY_CROSS_CHROME_CONTENT_BOUNDARY))
88613:     return vstates;
88613: 
86931:   // Assume we are visible enough.
86931:   return vstates &= ~states::INVISIBLE;
  733: }
  733: 
67790: PRUint64
67790: nsAccessible::NativeState()
    1: {
67790:   PRUint64 state = 0;
74867: 
89800:   nsDocAccessible* document = Document();
74867:   if (!document || !document->IsInDocument(this))
74867:     state |= states::STALE;
74867: 
79445:   bool disabled = false;
71110:   if (mContent->IsElement()) {
71116:     nsEventStates elementState = mContent->AsElement()->State();
71116: 
71116:     if (elementState.HasState(NS_EVENT_STATE_INVALID))
67790:       state |= states::INVALID;
55426: 
71116:     if (elementState.HasState(NS_EVENT_STATE_REQUIRED))
67790:       state |= states::REQUIRED;
55425: 
71110:     disabled = mContent->IsHTML() ? 
71116:       (elementState.HasState(NS_EVENT_STATE_DISABLED)) :
55425:       (mContent->AttrValueIs(kNameSpaceID_None,
78350:                              nsGkAtoms::disabled,
78350:                              nsGkAtoms::_true,
55425:                              eCaseMatters));
71110:   }
55425: 
55425:   // Set unavailable state based on disabled state, otherwise set focus states
55425:   if (disabled) {
67790:     state |= states::UNAVAILABLE;
    1:   }
43504:   else if (mContent->IsElement()) {
    1:     nsIFrame* frame = GetFrame();
79384:     if (frame && frame->IsFocusable())
67790:       state |= states::FOCUSABLE;
79384: 
79384:     if (FocusMgr()->IsFocused(this))
67790:       state |= states::FOCUSED;
67790:   }
67790: 
86931:   // Gather states::INVISIBLE and states::OFFSCREEN flags for this object.
86931:   state |= VisibilityState();
    1: 
 5707:   nsIFrame *frame = GetFrame();
 5707:   if (frame && (frame->GetStateBits() & NS_FRAME_OUT_OF_FLOW))
67790:     state |= states::FLOATING;
 5707: 
31782:   // Check if a XUL element has the popup attribute (an attached popup menu).
43504:   if (mContent->IsXUL())
78350:     if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::popup))
67790:       state |= states::HASPOPUP;
31782: 
13757:   // Add 'linked' state for simple xlink.
43504:   if (nsCoreUtils::IsXLink(mContent))
67790:     state |= states::LINKED;
67790: 
67790:   return state;
    1: }
    1: 
    1:   /* readonly attribute boolean focusedChild; */
43504: NS_IMETHODIMP
74619: nsAccessible::GetFocusedChild(nsIAccessible** aChild)
    1: {
74619:   NS_ENSURE_ARG_POINTER(aChild);
74619:   *aChild = nsnull;
74619: 
74619:   if (IsDefunct())
74619:     return NS_ERROR_FAILURE;
74619: 
74619:   NS_IF_ADDREF(*aChild = FocusedChild());
    1:   return NS_OK;
    1: }
    1: 
74619: nsAccessible*
74619: nsAccessible::FocusedChild()
74619: {
79384:   nsAccessible* focus = FocusMgr()->FocusedAccessible();
79384:   if (focus && (focus == this || focus->Parent() == this))
79384:     return focus;
79384: 
74619:   return nsnull;
74619: }
74619: 
72477: // nsAccessible::ChildAtPoint()
64131: nsAccessible*
72477: nsAccessible::ChildAtPoint(PRInt32 aX, PRInt32 aY,
64131:                            EWhichChildAtPoint aWhichChild)
    1: {
 6068:   // If we can't find the point in a child, we will return the fallback answer:
28197:   // we return |this| if the point is within it, otherwise nsnull.
28197:   PRInt32 x = 0, y = 0, width = 0, height = 0;
28197:   nsresult rv = GetBounds(&x, &y, &width, &height);
64131:   NS_ENSURE_SUCCESS(rv, nsnull);
64131: 
64131:   nsAccessible* fallbackAnswer = nsnull;
28197:   if (aX >= x && aX < x + width && aY >= y && aY < y + height)
 6068:     fallbackAnswer = this;
28197: 
64131:   if (nsAccUtils::MustPrune(this))  // Do not dig any further
64131:     return fallbackAnswer;
 6068: 
 5680:   // Search an accessible at the given point starting from accessible document
 5680:   // because containing block (see CSS2) for out of flow element (for example,
 5680:   // absolutely positioned element) may be different from its DOM parent and
 5680:   // therefore accessible for containing block may be different from accessible
 5680:   // for DOM parent but GetFrameForPoint() should be called for containing block
 5680:   // to get an out of flow element.
89800:   nsDocAccessible* accDocument = Document();
64131:   NS_ENSURE_TRUE(accDocument, nsnull);
 5680: 
39601:   nsIFrame *frame = accDocument->GetFrame();
64131:   NS_ENSURE_TRUE(frame, nsnull);
 5680: 
 5680:   nsPresContext *presContext = frame->PresContext();
 5680: 
90771:   nsRect screenRect = frame->GetScreenRectInAppUnits();
90771:   nsPoint offset(presContext->DevPixelsToAppUnits(aX) - screenRect.x,
90771:                  presContext->DevPixelsToAppUnits(aY) - screenRect.y);
 5680: 
 5680:   nsCOMPtr<nsIPresShell> presShell = presContext->PresShell();
 5680:   nsIFrame *foundFrame = presShell->GetFrameForPoint(frame, offset);
28197: 
28197:   nsIContent* content = nsnull;
64131:   if (!foundFrame || !(content = foundFrame->GetContent()))
64131:     return fallbackAnswer;
 5680: 
46469:   // Get accessible for the node with the point or the first accessible in
46469:   // the DOM parent chain.
90545:   nsDocAccessible* contentDocAcc = GetAccService()->
90545:     GetDocAccessible(content->OwnerDoc());
90886: 
90942:   // contentDocAcc in some circumstances can be NULL. See bug 729861
90942:   NS_ASSERTION(contentDocAcc, "could not get the document accessible");
90942:   if (!contentDocAcc)
90942:     return fallbackAnswer;
90886: 
90545:   nsAccessible* accessible = contentDocAcc->GetAccessibleOrContainer(content);
64131:   if (!accessible)
64131:     return fallbackAnswer;
 6068: 
 6068:   if (accessible == this) {
28197:     // Manually walk through accessible children and see if the are within this
28197:     // point. Skip offscreen or invisible accessibles. This takes care of cases
28197:     // where layout won't walk into things for us, such as image map areas and
28197:     // sub documents (XXX: subdocuments should be handled by methods of
28197:     // nsOuterDocAccessibles).
40990:     PRInt32 childCount = GetChildCount();
40990:     for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
40990:       nsAccessible *child = GetChildAt(childIdx);
40990: 
 6068:       PRInt32 childX, childY, childWidth, childHeight;
 6068:       child->GetBounds(&childX, &childY, &childWidth, &childHeight);
 6068:       if (aX >= childX && aX < childX + childWidth &&
 6068:           aY >= childY && aY < childY + childHeight &&
67790:           (child->State() & states::INVISIBLE) == 0) {
28197: 
64131:         if (aWhichChild == eDeepestChild)
72477:           return child->ChildAtPoint(aX, aY, eDeepestChild);
64131: 
64131:         return child;
 6068:       }
 6068:     }
28197: 
28197:     // The point is in this accessible but not in a child. We are allowed to
28197:     // return |this| as the answer.
64131:     return accessible;
28197:   }
28197: 
28197:   // Since DOM node of obtained accessible may be out of flow then we should
28197:   // ensure obtained accessible is a child of this accessible.
64131:   nsAccessible* child = accessible;
64131:   while (true) {
74545:     nsAccessible* parent = child->Parent();
28197:     if (!parent) {
28197:       // Reached the top of the hierarchy. These bounds were inside an
28197:       // accessible that is not a descendant of this one.
64131:       return fallbackAnswer;
64131:     }
64131: 
64131:     if (parent == this)
64131:       return aWhichChild == eDeepestChild ? accessible : child;
64131: 
64131:     child = parent;
64131:   }
64131: 
64131:   return nsnull;
19323: }
19323: 
19323: // nsIAccessible getChildAtPoint(in long x, in long y)
19323: NS_IMETHODIMP
19323: nsAccessible::GetChildAtPoint(PRInt32 aX, PRInt32 aY,
19323:                               nsIAccessible **aAccessible)
19323: {
28197:   NS_ENSURE_ARG_POINTER(aAccessible);
28197:   *aAccessible = nsnull;
28197: 
28197:   if (IsDefunct())
28197:     return NS_ERROR_FAILURE;
28197: 
72477:   NS_IF_ADDREF(*aAccessible = ChildAtPoint(aX, aY, eDirectChild));
64131:   return NS_OK;
28197: }
28197: 
28197: // nsIAccessible getDeepestChildAtPoint(in long x, in long y)
28197: NS_IMETHODIMP
28197: nsAccessible::GetDeepestChildAtPoint(PRInt32 aX, PRInt32 aY,
28197:                                      nsIAccessible **aAccessible)
28197: {
28197:   NS_ENSURE_ARG_POINTER(aAccessible);
28197:   *aAccessible = nsnull;
28197: 
28197:   if (IsDefunct())
28197:     return NS_ERROR_FAILURE;
28197: 
72477:   NS_IF_ADDREF(*aAccessible = ChildAtPoint(aX, aY, eDeepestChild));
64131:   return NS_OK;
    1: }
    1: 
    1: void nsAccessible::GetBoundsRect(nsRect& aTotalBounds, nsIFrame** aBoundingFrame)
    1: {
    1: /*
    1:  * This method is used to determine the bounds of a content node.
    1:  * Because HTML wraps and links are not always rectangular, this
    1:  * method uses the following algorithm:
    1:  *
    1:  * 1) Start with an empty rectangle
    1:  * 2) Add the rect for the primary frame from for the DOM node.
    1:  * 3) For each next frame at the same depth with the same DOM node, add that rect to total
    1:  * 4) If that frame is an inline frame, search deeper at that point in the tree, adding all rects
    1:  */
    1: 
    1:   // Initialization area
    1:   *aBoundingFrame = nsnull;
    1:   nsIFrame *firstFrame = GetBoundsFrame();
    1:   if (!firstFrame)
    1:     return;
    1: 
    1:   // Find common relative parent
    1:   // This is an ancestor frame that will incompass all frames for this content node.
    1:   // We need the relative parent so we can get absolute screen coordinates
    1:   nsIFrame *ancestorFrame = firstFrame;
    1: 
    1:   while (ancestorFrame) {  
    1:     *aBoundingFrame = ancestorFrame;
    1:     // If any other frame type, we only need to deal with the primary frame
    1:     // Otherwise, there may be more frames attached to the same content node
91506:     if (ancestorFrame->GetType() != nsGkAtoms::inlineFrame &&
91506:         ancestorFrame->GetType() != nsGkAtoms::textFrame)
    1:       break;
    1:     ancestorFrame = ancestorFrame->GetParent();
    1:   }
    1: 
    1:   nsIFrame *iterFrame = firstFrame;
43504:   nsCOMPtr<nsIContent> firstContent(mContent);
    1:   nsIContent* iterContent = firstContent;
    1:   PRInt32 depth = 0;
    1: 
    1:   // Look only at frames below this depth, or at this depth (if we're still on the content node we started with)
    1:   while (iterContent == firstContent || depth > 0) {
    1:     // Coordinates will come back relative to parent frame
    1:     nsRect currFrameBounds = iterFrame->GetRect();
    1:     
    1:     // Make this frame's bounds relative to common parent frame
    1:     currFrameBounds +=
    1:       iterFrame->GetParent()->GetOffsetToExternal(*aBoundingFrame);
    1: 
    1:     // Add this frame's bounds to total
    1:     aTotalBounds.UnionRect(aTotalBounds, currFrameBounds);
    1: 
    1:     nsIFrame *iterNextFrame = nsnull;
    1: 
91506:     if (iterFrame->GetType() == nsGkAtoms::inlineFrame) {
    1:       // Only do deeper bounds search if we're on an inline frame
    1:       // Inline frames can contain larger frames inside of them
77154:       iterNextFrame = iterFrame->GetFirstPrincipalChild();
    1:     }
    1: 
    1:     if (iterNextFrame) 
    1:       ++depth;  // Child was found in code above this: We are going deeper in this iteration of the loop
    1:     else {  
    1:       // Use next sibling if it exists, or go back up the tree to get the first next-in-flow or next-sibling 
    1:       // within our search
    1:       while (iterFrame) {
    1:         iterNextFrame = iterFrame->GetNextContinuation();
    1:         if (!iterNextFrame)
    1:           iterNextFrame = iterFrame->GetNextSibling();
    1:         if (iterNextFrame || --depth < 0) 
    1:           break;
    1:         iterFrame = iterFrame->GetParent();
    1:       }
    1:     }
    1: 
    1:     // Get ready for the next round of our loop
    1:     iterFrame = iterNextFrame;
    1:     if (iterFrame == nsnull)
    1:       break;
    1:     iterContent = nsnull;
    1:     if (depth == 0)
    1:       iterContent = iterFrame->GetContent();
    1:   }
    1: }
    1: 
    1: 
    1: /* void getBounds (out long x, out long y, out long width, out long height); */
55772: NS_IMETHODIMP
55772: nsAccessible::GetBounds(PRInt32* aX, PRInt32* aY,
55772:                         PRInt32* aWidth, PRInt32* aHeight)
    1: {
55772:   NS_ENSURE_ARG_POINTER(aX);
55772:   *aX = 0;
55772:   NS_ENSURE_ARG_POINTER(aY);
55772:   *aY = 0;
55772:   NS_ENSURE_ARG_POINTER(aWidth);
55772:   *aWidth = 0;
55772:   NS_ENSURE_ARG_POINTER(aHeight);
55772:   *aHeight = 0;
55772: 
55772:   if (IsDefunct())
55772:     return NS_ERROR_FAILURE;
55772: 
89799:   nsIPresShell* presShell = mDoc->PresShell();
55772: 
55772:   // This routine will get the entire rectangle for all the frames in this node.
    1:   // -------------------------------------------------------------------------
    1:   //      Primary Frame for node
    1:   //  Another frame, same node                <- Example
    1:   //  Another frame, same node
    1: 
    1:   nsRect unionRectTwips;
55772:   nsIFrame* boundingFrame = nsnull;
55772:   GetBoundsRect(unionRectTwips, &boundingFrame);   // Unions up all primary frames for this node and all siblings after it
55772:   NS_ENSURE_STATE(boundingFrame);
55772: 
55772:   nsPresContext* presContext = presShell->GetPresContext();
55772:   *aX = presContext->AppUnitsToDevPixels(unionRectTwips.x);
55772:   *aY = presContext->AppUnitsToDevPixels(unionRectTwips.y);
55772:   *aWidth = presContext->AppUnitsToDevPixels(unionRectTwips.width);
55772:   *aHeight = presContext->AppUnitsToDevPixels(unionRectTwips.height);
    1: 
    1:   // We have the union of the rectangle, now we need to put it in absolute screen coords
90636:   nsIntRect orgRectPixels = boundingFrame->GetScreenRectInAppUnits().
90636:     ToNearestPixels(presContext->AppUnitsPerDevPixel());
55772:   *aX += orgRectPixels.x;
55772:   *aY += orgRectPixels.y;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // helpers
    1: 
    1: nsIFrame* nsAccessible::GetBoundsFrame()
    1: {
    1:   return GetFrame();
    1: }
    1: 
    1: /* void removeSelection (); */
79445: NS_IMETHODIMP nsAccessible::SetSelected(bool aSelect)
    1: {
    1:   // Add or remove selection
43504:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
    1: 
67790:   if (State() & states::SELECTABLE) {
87449:     nsAccessible* multiSelect =
43504:       nsAccUtils::GetMultiSelectableContainer(mContent);
    1:     if (!multiSelect) {
    1:       return aSelect ? TakeFocus() : NS_ERROR_FAILURE;
    1:     }
    1: 
 6279:     if (mRoleMapEntry) {
    1:       if (aSelect) {
43504:         return mContent->SetAttr(kNameSpaceID_None,
78350:                                  nsGkAtoms::aria_selected,
80486:                                  NS_LITERAL_STRING("true"), true);
 6279:       }
43504:       return mContent->UnsetAttr(kNameSpaceID_None,
80486:                                  nsGkAtoms::aria_selected, true);
43504:     }
43504:   }
43504: 
43504:   return NS_OK;
    1: }
    1: 
    1: /* void takeSelection (); */
    1: NS_IMETHODIMP nsAccessible::TakeSelection()
    1: {
    1:   // Select only this item
43504:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
    1: 
67790:   if (State() & states::SELECTABLE) {
87449:     nsAccessible* multiSelect =
43504:       nsAccUtils::GetMultiSelectableContainer(mContent);
87449:     if (multiSelect)
87449:       multiSelect->ClearSelection();
87449: 
80486:     return SetSelected(true);
    1:   }
    1: 
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
14605: NS_IMETHODIMP
14605: nsAccessible::TakeFocus()
    1: {
14605:   if (IsDefunct())
14605:     return NS_ERROR_FAILURE;
14605: 
14605:   nsIFrame *frame = GetFrame();
14605:   NS_ENSURE_STATE(frame);
14605: 
43504:   nsIContent* focusContent = mContent;
43504: 
84259:   // If the accessible focus is managed by container widget then focus the
84259:   // widget and set the accessible as its current item.
14605:   if (!frame->IsFocusable()) {
84259:     nsAccessible* widget = ContainerWidget();
84259:     if (widget && widget->AreItemsOperable()) {
84259:       nsIContent* widgetElm = widget->GetContent();
84259:       nsIFrame* widgetFrame = widgetElm->GetPrimaryFrame();
84259:       if (widgetFrame && widgetFrame->IsFocusable()) {
84259:         focusContent = widgetElm;
84259:         widget->SetCurrentItem(this);
14605:       }
14605:     }
14605:   }
14605: 
43504:   nsCOMPtr<nsIDOMElement> element(do_QueryInterface(focusContent));
89948:   nsFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm)
29018:     fm->SetFocus(element, 0);
29018: 
    1:   return NS_OK;
    1: }
    1: 
22204: nsresult
22204: nsAccessible::GetHTMLName(nsAString& aLabel)
    1: {
20246:   nsAutoString label;
57932: 
57932:   nsAccessible* labelAcc = nsnull;
89800:   HTMLLabelIterator iter(Document(), this);
57932:   while ((labelAcc = iter.Next())) {
57932:     nsresult rv = nsTextEquivUtils::
57932:       AppendTextEquivFromContent(this, labelAcc->GetContent(), &label);
20362:     NS_ENSURE_SUCCESS(rv, rv);
20362: 
    1:     label.CompressWhitespace();
57932:   }
57932: 
57932:   if (label.IsEmpty())
57932:     return nsTextEquivUtils::GetNameFromSubtree(this, aLabel);
57932: 
    1:   aLabel = label;
    1:   return NS_OK;
    1: }
    1: 
    1: /**
    1:   * 3 main cases for XUL Controls to be labeled
    1:   *   1 - control contains label="foo"
    1:   *   2 - control has, as a child, a label element
    1:   *        - label has either value="foo" or children
    1:   *   3 - non-child label contains control="controlID"
    1:   *        - label has either value="foo" or children
    1:   * Once a label is found, the search is discontinued, so a control
    1:   *  that has a label child as well as having a label external to
    1:   *  the control that uses the control="controlID" syntax will use
    1:   *  the child label for its Name.
    1:   */
22204: nsresult
22204: nsAccessible::GetXULName(nsAString& aLabel)
    1: {
20246:   // CASE #1 (via label attribute) -- great majority of the cases
20246:   nsresult rv = NS_OK;
20246: 
    1:   nsAutoString label;
43504:   nsCOMPtr<nsIDOMXULLabeledControlElement> labeledEl(do_QueryInterface(mContent));
    1:   if (labeledEl) {
    1:     rv = labeledEl->GetLabel(label);
    1:   }
    1:   else {
43504:     nsCOMPtr<nsIDOMXULSelectControlItemElement> itemEl(do_QueryInterface(mContent));
    1:     if (itemEl) {
    1:       rv = itemEl->GetLabel(label);
    1:     }
    1:     else {
43504:       nsCOMPtr<nsIDOMXULSelectControlElement> select(do_QueryInterface(mContent));
    1:       // Use label if this is not a select control element which 
    1:       // uses label attribute to indicate which option is selected
    1:       if (!select) {
43504:         nsCOMPtr<nsIDOMXULElement> xulEl(do_QueryInterface(mContent));
    1:         if (xulEl) {
    1:           rv = xulEl->GetAttribute(NS_LITERAL_STRING("label"), label);
    1:         }
    1:       }
    1:     }
    1:   }
    1: 
    1:   // CASES #2 and #3 ------ label as a child or <label control="id" ... > </label>
    1:   if (NS_FAILED(rv) || label.IsEmpty()) {
    1:     label.Truncate();
57932: 
57932:     nsAccessible* labelAcc = nsnull;
89800:     XULLabelIterator iter(Document(), mContent);
57932:     while ((labelAcc = iter.Next())) {
57932:       nsCOMPtr<nsIDOMXULLabelElement> xulLabel =
57932:         do_QueryInterface(labelAcc->GetContent());
    1:       // Check if label's value attribute is used
    1:       if (xulLabel && NS_SUCCEEDED(xulLabel->GetValue(label)) && label.IsEmpty()) {
    1:         // If no value attribute, a non-empty label must contain
20072:         // children that define its text -- possibly using HTML
57932:         nsTextEquivUtils::
57932:           AppendTextEquivFromContent(this, labelAcc->GetContent(), &label);
57932:       }
    1:     }
    1:   }
    1: 
    1:   // XXX If CompressWhiteSpace worked on nsAString we could avoid a copy
    1:   label.CompressWhitespace();
    1:   if (!label.IsEmpty()) {
    1:     aLabel = label;
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Can get text from title of <toolbaritem> if we're a child of a <toolbaritem>
43504:   nsIContent *bindingParent = mContent->GetBindingParent();
    1:   nsIContent *parent = bindingParent? bindingParent->GetParent() :
43504:                                       mContent->GetParent();
    1:   while (parent) {
78350:     if (parent->Tag() == nsGkAtoms::toolbaritem &&
78350:         parent->GetAttr(kNameSpaceID_None, nsGkAtoms::title, label)) {
    1:       label.CompressWhitespace();
    1:       aLabel = label;
    1:       return NS_OK;
    1:     }
    1:     parent = parent->GetParent();
    1:   }
    1: 
25175:   return nsTextEquivUtils::GetNameFromSubtree(this, aLabel);
    1: }
    1: 
29320: nsresult
51377: nsAccessible::HandleAccEvent(AccEvent* aEvent)
  511: {
  763:   NS_ENSURE_ARG_POINTER(aEvent);
  763: 
  511:   nsCOMPtr<nsIObserverService> obsService =
41540:     mozilla::services::GetObserverService();
  511:   NS_ENSURE_TRUE(obsService, NS_ERROR_FAILURE);
  511: 
51377:   nsCOMPtr<nsISimpleEnumerator> observers;
51377:   obsService->EnumerateObservers(NS_ACCESSIBLE_EVENT_TOPIC,
51377:                                  getter_AddRefs(observers));
51377: 
51377:   NS_ENSURE_STATE(observers);
51377: 
79445:   bool hasObservers = false;
51377:   observers->HasMoreElements(&hasObservers);
51377:   if (hasObservers) {
51377:     nsRefPtr<nsAccEvent> evnt(aEvent->CreateXPCOMObject());
51377:     return obsService->NotifyObservers(evnt, NS_ACCESSIBLE_EVENT_TOPIC, nsnull);
51377:   }
51377: 
51377:   return NS_OK;
    1: }
    1: 
25822: NS_IMETHODIMP
25822: nsAccessible::GetRole(PRUint32 *aRole)
    1: {
 4850:   NS_ENSURE_ARG_POINTER(aRole);
 4850:   *aRole = nsIAccessibleRole::ROLE_NOTHING;
 4850: 
29085:   if (IsDefunct())
29085:     return NS_ERROR_FAILURE;
29085: 
52053:   *aRole = Role();
52027:   return NS_OK;
    1: }
    1: 
  401: NS_IMETHODIMP
  401: nsAccessible::GetAttributes(nsIPersistentProperties **aAttributes)
    1: {
13094:   NS_ENSURE_ARG_POINTER(aAttributes);  // In/out param. Created if necessary.
 8937:   
15511:   if (IsDefunct())
15511:     return NS_ERROR_FAILURE;
15511: 
13094:   nsCOMPtr<nsIPersistentProperties> attributes = *aAttributes;
13094:   if (!attributes) {
13094:     // Create only if an array wasn't already passed in
13094:     attributes = do_CreateInstance(NS_PERSISTENTPROPERTIES_CONTRACTID);
    1:     NS_ENSURE_TRUE(attributes, NS_ERROR_OUT_OF_MEMORY);
13094:     NS_ADDREF(*aAttributes = attributes);
13094:   }
 4516:  
  401:   nsresult rv = GetAttributesInternal(attributes);
  401:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   nsAutoString id;
 6844:   nsAutoString oldValueUnused;
43504:   if (nsCoreUtils::GetID(mContent, id)) {
13094:     // Expose ID. If an <iframe id> exists override the one on the <body> of the source doc,
13094:     // because the specific instance is what makes the ID useful for scripts
    1:     attributes->SetStringProperty(NS_LITERAL_CSTRING("id"), id, oldValueUnused);
 6844:   }
 6844:   
 8937:   nsAutoString xmlRoles;
78350:   if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::role, xmlRoles)) {
 8937:     attributes->SetStringProperty(NS_LITERAL_CSTRING("xml-roles"),  xmlRoles, oldValueUnused);          
    1:   }
    1: 
11394:   nsCOMPtr<nsIAccessibleValue> supportsValue = do_QueryInterface(static_cast<nsIAccessible*>(this));
11394:   if (supportsValue) {
11394:     // We support values, so expose the string value as well, via the valuetext object attribute
11394:     // We test for the value interface because we don't want to expose traditional get_accValue()
11394:     // information such as URL's on links and documents, or text in an input
11394:     nsAutoString valuetext;
11394:     GetValue(valuetext);
11394:     attributes->SetStringProperty(NS_LITERAL_CSTRING("valuetext"), valuetext, oldValueUnused);
11394:   }
11394: 
25348:   // Expose checkable object attribute if the accessible has checkable state
67790:   if (State() & states::CHECKABLE)
78350:     nsAccUtils::SetAccAttr(attributes, nsGkAtoms::checkable, NS_LITERAL_STRING("true"));
13012: 
23326:   // Group attributes (level/setsize/posinset)
36879:   PRInt32 level = 0, posInSet = 0, setSize = 0;
36879:   rv = GroupPosition(&level, &setSize, &posInSet);
36879:   if (NS_SUCCEEDED(rv))
36879:     nsAccUtils::SetAccGroupAttrs(attributes, level, setSize, posInSet);
  401: 
25174:   // Expose object attributes from ARIA attributes.
43504:   PRUint32 numAttrs = mContent->GetAttrCount();
13012:   for (PRUint32 count = 0; count < numAttrs; count ++) {
43504:     const nsAttrName *attr = mContent->GetAttrNameAt(count);
13012:     if (attr && attr->NamespaceEquals(kNameSpaceID_None)) {
13012:       nsIAtom *attrAtom = attr->Atom();
39100:       nsDependentAtomString attrStr(attrAtom);
39100:       if (!StringBeginsWith(attrStr, NS_LITERAL_STRING("aria-"))) 
13012:         continue; // Not ARIA
24997:       PRUint8 attrFlags = nsAccUtils::GetAttributeCharacteristics(attrAtom);
25997:       if (attrFlags & ATTR_BYPASSOBJ)
25997:         continue; // No need to handle exposing as obj attribute here
24997:       if ((attrFlags & ATTR_VALTOKEN) &&
43504:           !nsAccUtils::HasDefinedARIAToken(mContent, attrAtom))
24997:         continue; // only expose token based attributes if they are defined
13012:       nsAutoString value;
43504:       if (mContent->GetAttr(kNameSpaceID_None, attrAtom, value)) {
39100:         attributes->SetStringProperty(NS_ConvertUTF16toUTF8(Substring(attrStr, 5)), value, oldValueUnused);
13012:       }
13012:     }
13012:   }
13012: 
25174:   // If there is no aria-live attribute then expose default value of 'live'
25174:   // object attribute used for ARIA role of this accessible.
25174:   if (mRoleMapEntry) {
25174:     nsAutoString live;
78350:     nsAccUtils::GetAccAttr(attributes, nsGkAtoms::live, live);
25174:     if (live.IsEmpty()) {
32053:       if (nsAccUtils::GetLiveAttrValue(mRoleMapEntry->liveAttRule, live))
78350:         nsAccUtils::SetAccAttr(attributes, nsGkAtoms::live, live);
25174:     }
25174:   }
25174: 
    1:   return NS_OK;
    1: }
    1: 
  401: nsresult
  401: nsAccessible::GetAttributesInternal(nsIPersistentProperties *aAttributes)
  401: {
13094:   // Attributes set by this method will not be used to override attributes on a sub-document accessible
13094:   // when there is a <frame>/<iframe> element that spawned the sub-document
43504:   nsCOMPtr<nsIDOMElement> element(do_QueryInterface(mContent));
  401: 
  401:   nsAutoString tagName;
  401:   element->GetTagName(tagName);
  401:   if (!tagName.IsEmpty()) {
  401:     nsAutoString oldValueUnused;
  401:     aAttributes->SetStringProperty(NS_LITERAL_CSTRING("tag"), tagName,
  401:                                    oldValueUnused);
  401:   }
  401: 
43504:   nsEventShell::GetEventAttributes(GetNode(), aAttributes);
13094:  
13094:   // Expose class because it may have useful microformat information
13094:   // Let the class from an iframe's document be exposed, don't override from <iframe class>
13094:   nsAutoString _class;
78350:   if (mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::_class, _class))
78350:     nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::_class, _class);
13094: 
13094:   // Get container-foo computed live region properties based on the closest container with
13094:   // the live region attribute. 
13094:   // Inner nodes override outer nodes within the same document --
13094:   //   The inner nodes can be used to override live region behavior on more general outer nodes
13094:   // However, nodes in outer documents override nodes in inner documents:
13094:   //   Outer doc author may want to override properties on a widget they used in an iframe
43504:   nsIContent *startContent = mContent;
80486:   while (true) {
13094:     NS_ENSURE_STATE(startContent);
13094:     nsIDocument *doc = startContent->GetDocument();
43504:     nsIContent* rootContent = nsCoreUtils::GetRoleContent(doc);
43504:     NS_ENSURE_STATE(rootContent);
20536:     nsAccUtils::SetLiveContainerAttributes(aAttributes, startContent,
43504:                                            rootContent);
21169: 
13094:     // Allow ARIA live region markup from outer documents to override
13094:     nsCOMPtr<nsISupports> container = doc->GetContainer(); 
21169:     nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
21169:       do_QueryInterface(container);
13351:     if (!docShellTreeItem)
13351:       break;
21169: 
21169:     nsCOMPtr<nsIDocShellTreeItem> sameTypeParent;
21169:     docShellTreeItem->GetSameTypeParent(getter_AddRefs(sameTypeParent));
13094:     if (!sameTypeParent || sameTypeParent == docShellTreeItem)
13094:       break;
21169: 
13094:     nsIDocument *parentDoc = doc->GetParentDocument();
13408:     if (!parentDoc)
13408:       break;
21169: 
13094:     startContent = parentDoc->FindContentForSubDocument(doc);      
13094:   }
13094: 
90500:   if (!mContent->IsElement())
90500:     return NS_OK;
90500: 
29397:   // Expose draggable object attribute?
81041:   nsCOMPtr<nsIDOMHTMLElement> htmlElement = do_QueryInterface(mContent);
29397:   if (htmlElement) {
79445:     bool draggable = false;
29397:     htmlElement->GetDraggable(&draggable);
29397:     if (draggable) {
78350:       nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::draggable,
29397:                              NS_LITERAL_STRING("true"));
29397:     }
29397:   }
29397: 
91914:   // Don't calculate CSS-based object attributes when no frame (i.e.
91914:   // the accessible is not unattached form three) or when the accessible is not
91914:   // primary for node (like list bullet or XUL tree items).
91914:   if (!mContent->GetPrimaryFrame() || !IsPrimaryForNode())
91914:     return NS_OK;
91914: 
91914:   // CSS style based object attributes.
91914:   nsAutoString value;
91914:   StyleInfo styleInfo(mContent->AsElement(), mDoc->PresShell());
91914: 
91914:   // Expose 'display' attribute.
91914:   styleInfo.Display(value);
91914:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::display, value);
91914: 
91914:   // Expose 'text-align' attribute.
91914:   styleInfo.TextAlign(value);
91914:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::textAlign, value);
91914: 
91914:   // Expose 'text-indent' attribute.
91914:   styleInfo.TextIndent(value);
91914:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::textIndent, value);
91914: 
91914:   // Expose 'margin-left' attribute.
91914:   styleInfo.MarginLeft(value);
91914:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::marginLeft, value);
91914: 
91914:   // Expose 'margin-right' attribute.
91914:   styleInfo.MarginRight(value);
91914:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::marginRight, value);
91914: 
91914:   // Expose 'margin-top' attribute.
91914:   styleInfo.MarginTop(value);
91914:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::marginTop, value);
91914: 
91914:   // Expose 'margin-bottom' attribute.
91914:   styleInfo.MarginBottom(value);
91914:   nsAccUtils::SetAccAttr(aAttributes, nsGkAtoms::marginBottom, value);
91914: 
  401:   return NS_OK;
  401: }
  401: 
  144: NS_IMETHODIMP
  144: nsAccessible::GroupPosition(PRInt32 *aGroupLevel,
  144:                             PRInt32 *aSimilarItemsInGroup,
  144:                             PRInt32 *aPositionInGroup)
  144: {
  144:   NS_ENSURE_ARG_POINTER(aGroupLevel);
36879:   *aGroupLevel = 0;
36879: 
  144:   NS_ENSURE_ARG_POINTER(aSimilarItemsInGroup);
36879:   *aSimilarItemsInGroup = 0;
36879: 
  144:   NS_ENSURE_ARG_POINTER(aPositionInGroup);
  144:   *aPositionInGroup = 0;
  144: 
36879:   if (IsDefunct())
  757:     return NS_ERROR_FAILURE;
36879: 
36879:   // Get group position from ARIA attributes.
78350:   nsCoreUtils::GetUIntAttr(mContent, nsGkAtoms::aria_level,
37109:                            aGroupLevel);
78350:   nsCoreUtils::GetUIntAttr(mContent, nsGkAtoms::aria_posinset,
37109:                            aPositionInGroup);
78350:   nsCoreUtils::GetUIntAttr(mContent, nsGkAtoms::aria_setsize,
37109:                            aSimilarItemsInGroup);
36879: 
36879:   // If ARIA is missed and the accessible is visible then calculate group
36879:   // position from hierarchy.
67790:   if (State() & states::INVISIBLE)
36879:     return NS_OK;
36879: 
36879:   // Calculate group level if ARIA is missed.
36879:   if (*aGroupLevel == 0) {
36879:     PRInt32 level = GetLevelInternal();
36879:     if (level != 0)
36879:       *aGroupLevel = level;
36879:   }
36879: 
36879:   // Calculate position in group and group size if ARIA is missed.
36879:   if (*aSimilarItemsInGroup == 0 || *aPositionInGroup == 0) {
36879:     PRInt32 posInSet = 0, setSize = 0;
36879:     GetPositionAndSizeInternal(&posInSet, &setSize);
36879:     if (posInSet != 0 && setSize != 0) {
36879:       if (*aPositionInGroup == 0)
36879:         *aPositionInGroup = posInSet;
36879: 
36879:       if (*aSimilarItemsInGroup == 0)
 7888:         *aSimilarItemsInGroup = setSize;
36879:     }
36879:   }
  144: 
  144:   return NS_OK;
  144: }
  144: 
  262: NS_IMETHODIMP
21256: nsAccessible::GetState(PRUint32* aState, PRUint32* aExtraState)
    1: {
  262:   NS_ENSURE_ARG_POINTER(aState);
  262: 
67790:   nsAccUtils::To32States(State(), aState, aExtraState);
67790:   return NS_OK;
67790: }
67790: 
67790: PRUint64
67790: nsAccessible::State()
67790: {
67973:   if (IsDefunct())
67973:     return states::DEFUNCT;
67973: 
67790:   PRUint64 state = NativeState();
70455:   // Apply ARIA states to be sure accessible states will be overridden.
67790:   ApplyARIAState(&state);
 4381: 
87879:   // If this is an ARIA item of the selectable widget and if it's focused and
87879:   // not marked unselected explicitly (i.e. aria-selected="false") then expose
87879:   // it as selected to make ARIA widget authors life easier.
87879:   if (mRoleMapEntry && !(state & states::SELECTED) &&
70455:       !mContent->AttrValueIs(kNameSpaceID_None,
78350:                              nsGkAtoms::aria_selected,
78350:                              nsGkAtoms::_false, eCaseMatters)) {
87879:     // Special case for tabs: focused tab or focus inside related tab panel
87879:     // implies selected state.
87879:     if (mRoleMapEntry->role == roles::PAGETAB) {
67790:       if (state & states::FOCUSED) {
67790:         state |= states::SELECTED;
 6596:       } else {
70455:         // If focus is in a child of the tab panel surely the tab is selected!
75194:         Relation rel = RelationByType(nsIAccessibleRelation::RELATION_LABEL_FOR);
75194:         nsAccessible* relTarget = nsnull;
75194:         while ((relTarget = rel.Next())) {
87094:           if (relTarget->Role() == roles::PROPERTYPAGE &&
79384:               FocusMgr()->IsFocusWithin(relTarget))
67790:             state |= states::SELECTED;
67790:         }
67790:       }
87879:     } else if (state & states::FOCUSED) {
87879:       nsAccessible* container = nsAccUtils::GetSelectableContainer(this, state);
87879:       if (container &&
87879:           !nsAccUtils::HasDefinedARIAToken(container->GetContent(),
87879:                                            nsGkAtoms::aria_multiselectable)) {
87879:         state |= states::SELECTED;
87879:       }
87879:     }
67790:   }
67790: 
67790:   const PRUint32 kExpandCollapseStates = states::COLLAPSED | states::EXPANDED;
67790:   if ((state & kExpandCollapseStates) == kExpandCollapseStates) {
20128:     // Cannot be both expanded and collapsed -- this happens in ARIA expanded
20128:     // combobox because of limitation of nsARIAMap.
20128:     // XXX: Perhaps we will be able to make this less hacky if we support
20128:     // extended states in nsARIAMap, e.g. derive COLLAPSED from
20128:     // EXPANDABLE && !EXPANDED.
67790:     state &= ~states::COLLAPSED;
67790:   }
67790: 
67790:   if (!(state & states::UNAVAILABLE)) {
67790:     state |= states::ENABLED | states::SENSITIVE;
84145: 
84145:     // If the object is a current item of container widget then mark it as
84145:     // ACTIVE. This allows screen reader virtual buffer modes to know which
84145:     // descendant is the current one that would get focus if the user navigates
84145:     // to the container widget.
84145:     nsAccessible* widget = ContainerWidget();
84145:     if (widget && widget->CurrentItem() == this)
84145:       state |= states::ACTIVE;
67790:   }
67790: 
67790:   if ((state & states::COLLAPSED) || (state & states::EXPANDED))
67790:     state |= states::EXPANDABLE;
 6172: 
 6172:   // For some reasons DOM node may have not a frame. We tract such accessibles
 6172:   // as invisible.
 5424:   nsIFrame *frame = GetFrame();
 6172:   if (!frame)
67790:     return state;
 6172: 
 5424:   const nsStyleDisplay* display = frame->GetStyleDisplay();
 5424:   if (display && display->mOpacity == 1.0f &&
67790:       !(state & states::INVISIBLE)) {
67790:     state |= states::OPAQUE1;
 5424:   }
 5424: 
 5424:   const nsStyleXUL *xulStyle = frame->GetStyleXUL();
 5424:   if (xulStyle) {
 5424:     // In XUL all boxes are either vertical or horizontal
 5424:     if (xulStyle->mBoxOrient == NS_STYLE_BOX_ORIENT_VERTICAL) {
67790:       state |= states::VERTICAL;
 5424:     }
 5424:     else {
67790:       state |= states::HORIZONTAL;
 5424:     }
 5424:   }
 3465:   
25066:   // If we are editable, force readonly bit off
67790:   if (state & states::EDITABLE)
67790:     state &= ~states::READONLY;
67790:  
67790:   return state;
67790: }
67790: 
67790: void
67790: nsAccessible::ApplyARIAState(PRUint64* aState)
  262: {
    1:   // Test for universal states first
83000:   *aState |= nsARIAMap::UniversalStatesFor(mContent);
  262: 
15374:   if (mRoleMapEntry) {
32104: 
32104:     // We only force the readonly bit off if we have a real mapping for the aria
32104:     // role. This preserves the ability for screen readers to use readonly
32104:     // (primarily on the document) as the hint for creating a virtual buffer.
87094:     if (mRoleMapEntry->role != roles::NOTHING)
67790:       *aState &= ~states::READONLY;
13715: 
43504:     if (mContent->HasAttr(kNameSpaceID_None, mContent->GetIDAttributeName())) {
13716:       // If has a role & ID and aria-activedescendant on the container, assume focusable
43504:       nsIContent *ancestorContent = mContent;
13716:       while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
78350:         if (ancestorContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_activedescendant)) {
13716:             // ancestor has activedescendant property, this content could be active
67790:           *aState |= states::FOCUSABLE;
13716:           break;
13716:         }
13716:       }
13716:     }
15374:   }
15374: 
67790:   if (*aState & states::FOCUSABLE) {
15374:     // Special case: aria-disabled propagates from ancestors down to any focusable descendant
43504:     nsIContent *ancestorContent = mContent;
15374:     while ((ancestorContent = ancestorContent->GetParent()) != nsnull) {
78350:       if (ancestorContent->AttrValueIs(kNameSpaceID_None, nsGkAtoms::aria_disabled,
78350:                                        nsGkAtoms::_true, eCaseMatters)) {
15374:           // ancestor has aria-disabled property, this is disabled
67790:         *aState |= states::UNAVAILABLE;
15374:         break;
15374:       }
15374:     }    
15374:   }
15374: 
15374:   if (!mRoleMapEntry)
67790:     return;
13716: 
25066:   // Note: the readonly bitflag will be overridden later if content is editable
13715:   *aState |= mRoleMapEntry->state;
67790:   if (nsStateMapEntry::MapToStates(mContent, aState,
29565:                                    mRoleMapEntry->attributeMap1) &&
67790:       nsStateMapEntry::MapToStates(mContent, aState,
29565:                                    mRoleMapEntry->attributeMap2)) {
67790:     nsStateMapEntry::MapToStates(mContent, aState,
29565:                                  mRoleMapEntry->attributeMap3);
13094:   }
13094: 
    1: }
    1: 
    1: // Not implemented by this class
    1: 
    1: /* DOMString getValue (); */
13757: NS_IMETHODIMP
13757: nsAccessible::GetValue(nsAString& aValue)
    1: {
13757:   if (IsDefunct())
13757:     return NS_ERROR_FAILURE;
13757: 
    1:   if (mRoleMapEntry) {
    1:     if (mRoleMapEntry->valueRule == eNoValue) {
    1:       return NS_OK;
    1:     }
13757: 
11394:     // aria-valuenow is a number, and aria-valuetext is the optional text equivalent
11394:     // For the string value, we will try the optional text equivalent first
43504:     if (!mContent->GetAttr(kNameSpaceID_None,
78350:                            nsGkAtoms::aria_valuetext, aValue)) {
78350:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::aria_valuenow,
43504:                         aValue);
    1:     }
    1:   }
13757: 
13757:   if (!aValue.IsEmpty())
13757:     return NS_OK;
13757: 
20072:   // Check if it's a simple xlink.
43504:   if (nsCoreUtils::IsXLink(mContent)) {
89799:     nsIPresShell* presShell = mDoc->PresShell();
43504:     if (presShell) {
43504:       nsCOMPtr<nsIDOMNode> DOMNode(do_QueryInterface(mContent));
43504:       return presShell->GetLinkLocation(DOMNode, aValue);
43504:     }
13757:   }
13757: 
    1:   return NS_OK;
    1: }
    1: 
 4274: // nsIAccessibleValue
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetMaximumValue(double *aMaximumValue)
    1: {
78350:   return GetAttrValue(nsGkAtoms::aria_valuemax, aMaximumValue);
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetMinimumValue(double *aMinimumValue)
 4274: {
78350:   return GetAttrValue(nsGkAtoms::aria_valuemin, aMinimumValue);
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetMinimumIncrement(double *aMinIncrement)
 4274: {
 4274:   NS_ENSURE_ARG_POINTER(aMinIncrement);
 4274:   *aMinIncrement = 0;
 4274: 
 4274:   // No mimimum increment in dynamic content spec right now
 4274:   return NS_OK_NO_ARIA_VALUE;
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::GetCurrentValue(double *aValue)
 4274: {
78350:   return GetAttrValue(nsGkAtoms::aria_valuenow, aValue);
 4274: }
 4274: 
 4274: NS_IMETHODIMP
 4274: nsAccessible::SetCurrentValue(double aValue)
 4274: {
43504:   if (IsDefunct())
43504:     return NS_ERROR_FAILURE;
 4274: 
 4274:   if (!mRoleMapEntry || mRoleMapEntry->valueRule == eNoValue)
 4274:     return NS_OK_NO_ARIA_VALUE;
 4274: 
67790:   const PRUint32 kValueCannotChange = states::READONLY | states::UNAVAILABLE;
67790: 
67790:   if (State() & kValueCannotChange)
    1:     return NS_ERROR_FAILURE;
 4274: 
 4274:   double minValue = 0;
 4274:   if (NS_SUCCEEDED(GetMinimumValue(&minValue)) && aValue < minValue)
    1:     return NS_ERROR_INVALID_ARG;
 4274: 
 4274:   double maxValue = 0;
 4274:   if (NS_SUCCEEDED(GetMaximumValue(&maxValue)) && aValue > maxValue)
    1:     return NS_ERROR_INVALID_ARG;
 4274: 
    1:   nsAutoString newValue;
    1:   newValue.AppendFloat(aValue);
43504:   return mContent->SetAttr(kNameSpaceID_None,
80486:                            nsGkAtoms::aria_valuenow, newValue, true);
 6279: }
    1: 
    1: /* void setName (in DOMString name); */
    1: NS_IMETHODIMP nsAccessible::SetName(const nsAString& name)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessible::GetDefaultKeyBinding(nsAString& aKeyBinding)
    1: {
    1:   aKeyBinding.Truncate();
74014:   if (IsDefunct())
74014:     return NS_ERROR_FAILURE;
74014: 
74014:   KeyboardShortcut().ToString(aKeyBinding);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsAccessible::GetKeyBindings(PRUint8 aActionIndex,
    1:                              nsIDOMDOMStringList **aKeyBindings)
    1: {
    1:   // Currently we support only unique key binding on element for default action.
    1:   NS_ENSURE_TRUE(aActionIndex == 0, NS_ERROR_INVALID_ARG);
    1: 
    1:   nsAccessibleDOMStringList *keyBindings = new nsAccessibleDOMStringList();
    1:   NS_ENSURE_TRUE(keyBindings, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   nsAutoString defaultKey;
    1:   nsresult rv = GetDefaultKeyBinding(defaultKey);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!defaultKey.IsEmpty())
    1:     keyBindings->Add(defaultKey);
    1: 
    1:   NS_ADDREF(*aKeyBindings = keyBindings);
    1:   return NS_OK;
    1: }
    1: 
87094: role
58433: nsAccessible::ARIARoleInternal()
52053: {
58433:   NS_PRECONDITION(mRoleMapEntry && mRoleMapEntry->roleRule == kUseMapRole,
58433:                   "ARIARoleInternal should only be called when ARIA role overrides!");
52053: 
52053:   // XXX: these unfortunate exceptions don't fit into the ARIA table. This is
52053:   // where the accessible role depends on both the role and ARIA state.
87094:   if (mRoleMapEntry->role == roles::PUSHBUTTON) {
78350:     if (nsAccUtils::HasDefinedARIAToken(mContent, nsGkAtoms::aria_pressed)) {
52053:       // For simplicity, any existing pressed attribute except "" or "undefined"
52053:       // indicates a toggle.
87094:       return roles::TOGGLE_BUTTON;
52053:     }
52053: 
52053:     if (mContent->AttrValueIs(kNameSpaceID_None,
78350:                               nsGkAtoms::aria_haspopup,
78350:                               nsGkAtoms::_true,
52053:                               eCaseMatters)) {
52053:       // For button with aria-haspopup="true".
87094:       return roles::BUTTONMENU;
52053:     }
52053: 
87094:   } else if (mRoleMapEntry->role == roles::LISTBOX) {
52053:     // A listbox inside of a combobox needs a special role because of ATK
52053:     // mapping to menu.
87094:     if (mParent && mParent->Role() == roles::COMBOBOX) {
87094:       return roles::COMBOBOX_LIST;
52053: 
75194:       Relation rel = RelationByType(nsIAccessibleRelation::RELATION_NODE_CHILD_OF);
75194:       nsAccessible* targetAcc = nsnull;
75194:       while ((targetAcc = rel.Next()))
87094:         if (targetAcc->Role() == roles::COMBOBOX)
87094:           return roles::COMBOBOX_LIST;
52053:     }
52053: 
87094:   } else if (mRoleMapEntry->role == roles::OPTION) {
87094:     if (mParent && mParent->Role() == roles::COMBOBOX_LIST)
87094:       return roles::COMBOBOX_OPTION;
52053:   }
52053: 
52053:   return mRoleMapEntry->role;
52053: }
52053: 
87094: role
52027: nsAccessible::NativeRole()
    1: {
87094:   return nsCoreUtils::IsXLink(mContent) ? roles::LINK : roles::NOTHING;
    1: }
    1: 
20140: // readonly attribute PRUint8 numActions
13129: NS_IMETHODIMP
74781: nsAccessible::GetNumActions(PRUint8* aActionCount)
    1: {
74781:   NS_ENSURE_ARG_POINTER(aActionCount);
74781:   *aActionCount = 0;
13129:   if (IsDefunct())
13129:     return NS_ERROR_FAILURE;
13129: 
74781:   *aActionCount = ActionCount();
15309:   return NS_OK;
74781: }
74781: 
74781: PRUint8
74781: nsAccessible::ActionCount()
74781: {
74781:   return GetActionRule(State()) == eNoAction ? 0 : 1;
13757: }
13757: 
    1: /* DOMString getAccActionName (in PRUint8 index); */
13129: NS_IMETHODIMP
13129: nsAccessible::GetActionName(PRUint8 aIndex, nsAString& aName)
    1: {
13129:   aName.Truncate();
13129: 
13129:   if (aIndex != 0)
13129:     return NS_ERROR_INVALID_ARG;
13129: 
13129:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
13129: 
67790:   PRUint64 states = State();
20140:   PRUint32 actionRule = GetActionRule(states);
20140: 
20140:  switch (actionRule) {
20140:    case eActivateAction:
20140:      aName.AssignLiteral("activate");
20140:      return NS_OK;
20140: 
20140:    case eClickAction:
20140:      aName.AssignLiteral("click");
20140:      return NS_OK;
20140: 
89285:    case ePressAction:
89285:      aName.AssignLiteral("press");
89285:      return NS_OK;
89285: 
20140:    case eCheckUncheckAction:
67790:      if (states & states::CHECKED)
25968:        aName.AssignLiteral("uncheck");
67790:      else if (states & states::MIXED)
25871:        aName.AssignLiteral("cycle");
20140:      else
20140:        aName.AssignLiteral("check");
20140:      return NS_OK;
20140: 
20140:    case eJumpAction:
13757:      aName.AssignLiteral("jump");
13757:      return NS_OK;
20140: 
20140:    case eOpenCloseAction:
67790:      if (states & states::COLLAPSED)
20140:        aName.AssignLiteral("open");
20140:      else
20140:        aName.AssignLiteral("close");
13129:      return NS_OK;
20140: 
20140:    case eSelectAction:
20140:      aName.AssignLiteral("select");
20140:      return NS_OK;
20140: 
20140:    case eSwitchAction:
20140:      aName.AssignLiteral("switch");
20140:      return NS_OK;
27511:      
27511:    case eSortAction:
27511:      aName.AssignLiteral("sort");
27511:      return NS_OK;
27511:    
27511:    case eExpandAction:
67790:      if (states & states::COLLAPSED)
27511:        aName.AssignLiteral("expand");
27511:      else
27511:        aName.AssignLiteral("collapse");
27511:      return NS_OK;
13129:   }
13129: 
13129:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
20140: // AString getActionDescription(in PRUint8 index)
13129: NS_IMETHODIMP
13129: nsAccessible::GetActionDescription(PRUint8 aIndex, nsAString& aDescription)
    1: {
    1:   // default to localized action name.
    1:   nsAutoString name;
    1:   nsresult rv = GetActionName(aIndex, name);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
88363:   TranslateString(name, aDescription);
88363:   return NS_OK;
    1: }
    1: 
20140: // void doAction(in PRUint8 index)
13129: NS_IMETHODIMP
13129: nsAccessible::DoAction(PRUint8 aIndex)
    1: {
13129:   if (aIndex != 0)
13129:     return NS_ERROR_INVALID_ARG;
13129: 
13129:   if (IsDefunct())
    1:     return NS_ERROR_FAILURE;
13129: 
67790:   if (GetActionRule(State()) != eNoAction) {
37481:     DoCommand();
37481:     return NS_OK;
20140:   }
13129: 
13129:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: /* DOMString getHelp (); */
    1: NS_IMETHODIMP nsAccessible::GetHelp(nsAString& _retval)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
75194: nsIContent*
75194: nsAccessible::GetAtomicRegion() const
 6066: {
43504:   nsIContent *loopContent = mContent;
 6066:   nsAutoString atomic;
78350:   while (loopContent && !loopContent->GetAttr(kNameSpaceID_None, nsGkAtoms::aria_atomic, atomic))
 6066:     loopContent = loopContent->GetParent();
75194: 
75194:   return atomic.EqualsLiteral("true") ? loopContent : nsnull;
 6066: }
    1: 
24822: // nsIAccessible getRelationByType()
24822: NS_IMETHODIMP
75194: nsAccessible::GetRelationByType(PRUint32 aType,
24822:                                 nsIAccessibleRelation** aRelation)
    1: {
24822:   NS_ENSURE_ARG_POINTER(aRelation);
24822:   *aRelation = nsnull;
24822:   if (IsDefunct())
24822:     return NS_ERROR_FAILURE;
24822: 
75194:   Relation rel = RelationByType(aType);
75194:   NS_ADDREF(*aRelation = new nsAccessibleRelation(aType, &rel));
75194:   return *aRelation ? NS_OK : NS_ERROR_FAILURE;
75194: }
75194: 
75194: Relation
75194: nsAccessible::RelationByType(PRUint32 aType)
75194: {
24822:   // Relationships are defined on the same content node that the role would be
24822:   // defined on.
75194:   switch (aType) {
75194:     case nsIAccessibleRelation::RELATION_LABEL_FOR: {
89800:       Relation rel(new RelatedAccIterator(Document(), mContent,
78350:                                           nsGkAtoms::aria_labelledby));
78350:       if (mContent->Tag() == nsGkAtoms::label)
75194:         rel.AppendIter(new IDRefsIterator(mContent, mContent->IsHTML() ?
78350:                                           nsGkAtoms::_for :
78350:                                           nsGkAtoms::control));
75194: 
75194:       return rel;
75194:     }
75194:     case nsIAccessibleRelation::RELATION_LABELLED_BY: {
75194:       Relation rel(new IDRefsIterator(mContent,
78350:                                       nsGkAtoms::aria_labelledby));
57932:       if (mContent->IsHTML()) {
89800:         rel.AppendIter(new HTMLLabelIterator(Document(), this));
75194:       } else if (mContent->IsXUL()) {
89800:         rel.AppendIter(new XULLabelIterator(Document(), mContent));
75194:       }
75194: 
75194:       return rel;
75194:     }
75194:     case nsIAccessibleRelation::RELATION_DESCRIBED_BY: {
75194:       Relation rel(new IDRefsIterator(mContent,
78350:                                         nsGkAtoms::aria_describedby));
75194:       if (mContent->IsXUL())
89800:         rel.AppendIter(new XULDescriptionIterator(Document(), mContent));
75194: 
75194:       return rel;
75194:     }
75194:     case nsIAccessibleRelation::RELATION_DESCRIPTION_FOR: {
89800:       Relation rel(new RelatedAccIterator(Document(), mContent,
78350:                                           nsGkAtoms::aria_describedby));
75194: 
    1:       // This affectively adds an optional control attribute to xul:description,
    1:       // which only affects accessibility, by allowing the description to be
    1:       // tied to a control.
78350:       if (mContent->Tag() == nsGkAtoms::description &&
75194:           mContent->IsXUL())
75194:         rel.AppendIter(new IDRefsIterator(mContent,
78350:                                           nsGkAtoms::control));
75194: 
75194:       return rel;
75194:     }
75194:     case nsIAccessibleRelation::RELATION_NODE_CHILD_OF: {
89800:       Relation rel(new RelatedAccIterator(Document(), mContent,
78350:                                           nsGkAtoms::aria_owns));
24822:       
34028:       // This is an ARIA tree or treegrid that doesn't use owns, so we need to
34028:       // get the parent the hard way.
87094:       if (mRoleMapEntry && (mRoleMapEntry->role == roles::OUTLINEITEM || 
87094:                             mRoleMapEntry->role == roles::ROW)) {
47172:         AccGroupInfo* groupInfo = GetGroupInfo();
47172:         if (!groupInfo)
75194:           return rel;
75194: 
75194:         rel.AppendTarget(groupInfo->ConceptualParent());
24822:       }
24822: 
30527:       // If accessible is in its own Window, or is the root of a document,
30527:       // then we should provide NODE_CHILD_OF relation so that MSAA clients
30527:       // can easily get to true parent instead of getting to oleacc's
30527:       // ROLE_WINDOW accessible which will prevent us from going up further
30527:       // (because it is system generated and has no idea about the hierarchy
30527:       // above it).
12642:       nsIFrame *frame = GetFrame();
12642:       if (frame) {
12642:         nsIView *view = frame->GetViewExternal();
12642:         if (view) {
23554:           nsIScrollableFrame *scrollFrame = do_QueryFrame(frame);
74545:           if (scrollFrame || view->GetWidget() || !frame->GetParent())
75194:             rel.AppendTarget(Parent());
75194:         }
75194:       }
75194: 
75194:       return rel;
75194:     }
 1628:     case nsIAccessibleRelation::RELATION_CONTROLLED_BY:
89800:       return Relation(new RelatedAccIterator(Document(), mContent,
78350:                                              nsGkAtoms::aria_controls));
75194:     case nsIAccessibleRelation::RELATION_CONTROLLER_FOR: {
75194:       Relation rel(new IDRefsIterator(mContent,
78350:                                       nsGkAtoms::aria_controls));
89800:       rel.AppendIter(new HTMLOutputIterator(Document(), mContent));
75194:       return rel;
75194:     }
 1628:     case nsIAccessibleRelation::RELATION_FLOWS_TO:
75194:       return Relation(new IDRefsIterator(mContent,
78350:                                          nsGkAtoms::aria_flowto));
 1628:     case nsIAccessibleRelation::RELATION_FLOWS_FROM:
89800:       return Relation(new RelatedAccIterator(Document(), mContent,
78350:                                              nsGkAtoms::aria_flowto));
75194:     case nsIAccessibleRelation::RELATION_DEFAULT_BUTTON: {
43504:       if (mContent->IsHTML()) {
 4451:         // HTML form controls implements nsIFormControl interface.
43504:         nsCOMPtr<nsIFormControl> control(do_QueryInterface(mContent));
 4451:         if (control) {
47802:           nsCOMPtr<nsIForm> form(do_QueryInterface(control->GetFormElement()));
24822:           if (form) {
24822:             nsCOMPtr<nsIContent> formContent =
24822:               do_QueryInterface(form->GetDefaultSubmitElement());
75194:             return Relation(formContent);
75194:           }
75194:         }
75194:       } else {
    1:         // In XUL, use first <button default="true" .../> in the document
43504:         nsCOMPtr<nsIDOMXULDocument> xulDoc =
80526:           do_QueryInterface(mContent->OwnerDoc());
    1:         nsCOMPtr<nsIDOMXULButtonElement> buttonEl;
    1:         if (xulDoc) {
    1:           nsCOMPtr<nsIDOMNodeList> possibleDefaultButtons;
    1:           xulDoc->GetElementsByAttribute(NS_LITERAL_STRING("default"),
    1:                                          NS_LITERAL_STRING("true"),
    1:                                          getter_AddRefs(possibleDefaultButtons));
    1:           if (possibleDefaultButtons) {
    1:             PRUint32 length;
    1:             possibleDefaultButtons->GetLength(&length);
    1:             nsCOMPtr<nsIDOMNode> possibleButton;
    1:             // Check for button in list of default="true" elements
    1:             for (PRUint32 count = 0; count < length && !buttonEl; count ++) {
    1:               possibleDefaultButtons->Item(count, getter_AddRefs(possibleButton));
    1:               buttonEl = do_QueryInterface(possibleButton);
    1:             }
    1:           }
    1:           if (!buttonEl) { // Check for anonymous accept button in <dialog>
    1:             nsCOMPtr<nsIDOMDocumentXBL> xblDoc(do_QueryInterface(xulDoc));
    1:             if (xblDoc) {
    1:               nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(xulDoc);
    1:               NS_ASSERTION(domDoc, "No DOM document");
    1:               nsCOMPtr<nsIDOMElement> rootEl;
    1:               domDoc->GetDocumentElement(getter_AddRefs(rootEl));
    1:               if (rootEl) {
    1:                 nsCOMPtr<nsIDOMElement> possibleButtonEl;
    1:                 xblDoc->GetAnonymousElementByAttribute(rootEl,
    1:                                                       NS_LITERAL_STRING("default"),
    1:                                                       NS_LITERAL_STRING("true"),
    1:                                                       getter_AddRefs(possibleButtonEl));
    1:                 buttonEl = do_QueryInterface(possibleButtonEl);
    1:               }
    1:             }
    1:           }
24822:           nsCOMPtr<nsIContent> relatedContent(do_QueryInterface(buttonEl));
75194:           return Relation(relatedContent);
75194:         }
75194:       }
75194:       return Relation();
75194:     }
 4516:     case nsIAccessibleRelation::RELATION_MEMBER_OF:
75194:       return Relation(GetAtomicRegion());
28489:     case nsIAccessibleRelation::RELATION_SUBWINDOW_OF:
28489:     case nsIAccessibleRelation::RELATION_EMBEDS:
28489:     case nsIAccessibleRelation::RELATION_EMBEDDED_BY:
28489:     case nsIAccessibleRelation::RELATION_POPUP_FOR:
28489:     case nsIAccessibleRelation::RELATION_PARENT_WINDOW_OF:
    1:     default:
75194:     return Relation();
24822:   }
    1: }
    1: 
 1628: NS_IMETHODIMP
 1628: nsAccessible::GetRelations(nsIArray **aRelations)
 1628: {
 1628:   NS_ENSURE_ARG_POINTER(aRelations);
75194:   *aRelations = nsnull;
75194: 
75194:   if (IsDefunct())
75194:     return NS_ERROR_FAILURE;
 1628: 
 1628:   nsCOMPtr<nsIMutableArray> relations = do_CreateInstance(NS_ARRAY_CONTRACTID);
 1628:   NS_ENSURE_TRUE(relations, NS_ERROR_OUT_OF_MEMORY);
 1628: 
 5475:   for (PRUint32 relType = nsIAccessibleRelation::RELATION_FIRST;
 5475:        relType < nsIAccessibleRelation::RELATION_LAST;
 5475:        ++relType) {
24822: 
24822:     nsCOMPtr<nsIAccessibleRelation> relation;
24822:     nsresult rv = GetRelationByType(relType, getter_AddRefs(relation));
24822: 
75194:     if (NS_SUCCEEDED(rv) && relation) {
75194:       PRUint32 targets = 0;
75194:       relation->GetTargetsCount(&targets);
75194:       if (targets)
80486:         relations->AppendElement(relation, false);
 1628:     }
75194:   }
 1628: 
 1628:   NS_ADDREF(*aRelations = relations);
 1628:   return NS_OK;
 1628: }
 1628: 
    1: /* void extendSelection (); */
    1: NS_IMETHODIMP nsAccessible::ExtendSelection()
    1: {
    1:   // XXX Should be implemented, but not high priority
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: /* [noscript] void getNativeInterface(out voidPtr aOutAccessible); */
    1: NS_IMETHODIMP nsAccessible::GetNativeInterface(void **aOutAccessible)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
37481: void
31673: nsAccessible::DoCommand(nsIContent *aContent, PRUint32 aActionIndex)
31673: {
43504:   nsIContent* content = aContent ? aContent : mContent.get();
43504:   NS_DISPATCH_RUNNABLEMETHOD_ARG2(DispatchClickEvent, this, content,
43504:                                   aActionIndex);
31673: }
31673: 
31673: void
31673: nsAccessible::DispatchClickEvent(nsIContent *aContent, PRUint32 aActionIndex)
31673: {
31673:   if (IsDefunct())
    1:     return;
16427: 
89799:   nsIPresShell* presShell = mDoc->PresShell();
16427: 
16427:   // Scroll into view.
31673:   presShell->ScrollContentIntoView(aContent, NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                    NS_PRESSHELL_SCROLL_ANYWHERE,
56647:                                    nsIPresShell::SCROLL_OVERFLOW_HIDDEN);
16427: 
16427:   // Fire mouse down and mouse up events.
79445:   bool res = nsCoreUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, presShell,
31673:                                                aContent);
16427:   if (!res)
16427:     return;
16427: 
31673:   nsCoreUtils::DispatchMouseEvent(NS_MOUSE_BUTTON_UP, presShell, aContent);
    1: }
    1: 
89598: NS_IMETHODIMP
89598: nsAccessible::ScrollTo(PRUint32 aHow)
89598: {
89598:   nsAccessNode::ScrollTo(aHow);
89598:   return NS_OK;
89598: }
89598: 
89598: NS_IMETHODIMP
89598: nsAccessible::ScrollToPoint(PRUint32 aCoordinateType, PRInt32 aX, PRInt32 aY)
89598: {
89598:   nsIFrame *frame = GetFrame();
89598:   if (!frame)
89598:     return NS_ERROR_FAILURE;
89598: 
89598:   nsIntPoint coords;
89598:   nsresult rv = nsAccUtils::ConvertToScreenCoords(aX, aY, aCoordinateType,
89598:                                                   this, &coords);
89598:   NS_ENSURE_SUCCESS(rv, rv);
89598: 
89598:   nsIFrame *parentFrame = frame;
89598:   while ((parentFrame = parentFrame->GetParent()))
89598:     nsCoreUtils::ScrollFrameToPoint(parentFrame, frame, coords);
89598: 
89598:   return NS_OK;
89598: }
89598: 
    1: // nsIAccessibleSelectable
    1: NS_IMETHODIMP nsAccessible::GetSelectedChildren(nsIArray **aSelectedAccessibles)
    1: {
51865:   NS_ENSURE_ARG_POINTER(aSelectedAccessibles);
    1:   *aSelectedAccessibles = nsnull;
    1: 
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   nsCOMPtr<nsIArray> items = SelectedItems();
51865:   if (items) {
    1:     PRUint32 length = 0;
51865:     items->GetLength(&length);
51865:     if (length)
51865:       items.swap(*aSelectedAccessibles);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: // return the nth selected descendant nsIAccessible object
    1: NS_IMETHODIMP nsAccessible::RefSelection(PRInt32 aIndex, nsIAccessible **aSelected)
    1: {
42494:   NS_ENSURE_ARG_POINTER(aSelected);
    1:   *aSelected = nsnull;
42494: 
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
    1:   if (aIndex < 0) {
42494:     return NS_ERROR_INVALID_ARG;
42494:   }
42494: 
51865:   *aSelected = GetSelectedItem(aIndex);
51865:   if (*aSelected) {
51865:     NS_ADDREF(*aSelected);
51865:     return NS_OK;
51865:   }
51865: 
42494:   return NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::GetSelectionCount(PRInt32 *aSelectionCount)
    1: {
42494:   NS_ENSURE_ARG_POINTER(aSelectionCount);
    1:   *aSelectionCount = 0;
42494: 
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   *aSelectionCount = SelectedItemCount();
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::AddChildToSelection(PRInt32 aIndex)
    1: {
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   return aIndex >= 0 && AddItemToSelection(aIndex) ?
51865:     NS_OK : NS_ERROR_INVALID_ARG;
    1: }
    1: 
    1: NS_IMETHODIMP nsAccessible::RemoveChildFromSelection(PRInt32 aIndex)
    1: {
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   return aIndex >=0 && RemoveItemFromSelection(aIndex) ?
51865:     NS_OK : NS_ERROR_INVALID_ARG;
    1: }
    1: 
79445: NS_IMETHODIMP nsAccessible::IsChildSelected(PRInt32 aIndex, bool *aIsSelected)
    1: {
51865:   NS_ENSURE_ARG_POINTER(aIsSelected);
80486:   *aIsSelected = false;
51865: 
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
    1:   NS_ENSURE_TRUE(aIndex >= 0, NS_ERROR_FAILURE);
    1: 
51865:   *aIsSelected = IsItemSelected(aIndex);
    1:   return NS_OK;
    1: }
    1: 
42494: NS_IMETHODIMP
42494: nsAccessible::ClearSelection()
    1: {
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   UnselectAll();
    1:   return NS_OK;
    1: }
    1: 
51865: NS_IMETHODIMP
79445: nsAccessible::SelectAllSelection(bool* aIsMultiSelect)
    1: {
51865:   NS_ENSURE_ARG_POINTER(aIsMultiSelect);
80486:   *aIsMultiSelect = false;
51865: 
51865:   if (IsDefunct() || !IsSelect())
51865:     return NS_ERROR_FAILURE;
51865: 
51865:   *aIsMultiSelect = SelectAll();
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIAccessibleHyperLink
    1: // Because of new-atk design, any embedded object in text can implement
    1: // nsIAccessibleHyperLink, which helps determine where it is located
    1: // within containing text
    1: 
14223: // readonly attribute long nsIAccessibleHyperLink::anchorCount
13749: NS_IMETHODIMP
14223: nsAccessible::GetAnchorCount(PRInt32 *aAnchorCount)
    1: {
14223:   NS_ENSURE_ARG_POINTER(aAnchorCount);
51810:   *aAnchorCount = 0;
51810: 
51810:   if (IsDefunct())
51810:     return NS_ERROR_FAILURE;
51810: 
51810:   *aAnchorCount = AnchorCount();
    1:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute long nsIAccessibleHyperLink::startIndex
13749: NS_IMETHODIMP
13749: nsAccessible::GetStartIndex(PRInt32 *aStartIndex)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aStartIndex);
    1:   *aStartIndex = 0;
42376: 
42376:   if (IsDefunct())
42376:     return NS_ERROR_FAILURE;
42376: 
51810:   *aStartIndex = StartOffset();
51810:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute long nsIAccessibleHyperLink::endIndex
13749: NS_IMETHODIMP
13749: nsAccessible::GetEndIndex(PRInt32 *aEndIndex)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aEndIndex);
    1:   *aEndIndex = 0;
42376: 
42376:   if (IsDefunct())
42376:     return NS_ERROR_FAILURE;
42376: 
51810:   *aEndIndex = EndOffset();
51810:   return NS_OK;
    1: }
    1: 
13749: NS_IMETHODIMP
13757: nsAccessible::GetURI(PRInt32 aIndex, nsIURI **aURI)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aURI);
51810: 
51810:   if (IsDefunct())
51810:     return NS_ERROR_FAILURE;
51810: 
51810:   if (aIndex < 0 || aIndex >= static_cast<PRInt32>(AnchorCount()))
13757:     return NS_ERROR_INVALID_ARG;
13757: 
72954:   nsRefPtr<nsIURI>(AnchorURIAt(aIndex)).forget(aURI);
13757:   return NS_OK;
13757: }
13757: 
    1: 
13749: NS_IMETHODIMP
51810: nsAccessible::GetAnchor(PRInt32 aIndex, nsIAccessible** aAccessible)
    1: {
13730:   NS_ENSURE_ARG_POINTER(aAccessible);
    1:   *aAccessible = nsnull;
13730: 
51810:   if (IsDefunct())
51810:     return NS_ERROR_FAILURE;
51810: 
51810:   if (aIndex < 0 || aIndex >= static_cast<PRInt32>(AnchorCount()))
13730:     return NS_ERROR_INVALID_ARG;
13730: 
72483:   NS_IF_ADDREF(*aAccessible = AnchorAt(aIndex));
    1:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute boolean nsIAccessibleHyperLink::valid
13749: NS_IMETHODIMP
79445: nsAccessible::GetValid(bool *aValid)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aValid);
80486:   *aValid = false;
51810: 
51810:   if (IsDefunct())
51810:     return NS_ERROR_FAILURE;
51810: 
72481:   *aValid = IsLinkValid();
    1:   return NS_OK;
    1: }
    1: 
13749: // readonly attribute boolean nsIAccessibleHyperLink::selected
13749: NS_IMETHODIMP
79445: nsAccessible::GetSelected(bool *aSelected)
    1: {
13749:   NS_ENSURE_ARG_POINTER(aSelected);
80486:   *aSelected = false;
51810: 
51810:   if (IsDefunct())
51810:     return NS_ERROR_FAILURE;
51810: 
72480:   *aSelected = IsLinkSelected();
    1:   return NS_OK;
51810: 
    1: }
    1: 
61682: void
61682: nsAccessible::AppendTextTo(nsAString& aText, PRUint32 aStartOffset,
61682:                            PRUint32 aLength)
  460: {
43441:   // Return text representation of non-text accessible within hypertext
43441:   // accessible. Text accessible overrides this method to return enclosed text.
61682:   if (aStartOffset != 0 || aLength == 0)
61682:     return;
43441: 
43441:   nsIFrame *frame = GetFrame();
61682:   if (!frame)
61682:     return;
43441: 
78350:   if (frame->GetType() == nsGkAtoms::brFrame) {
43441:     aText += kForcedNewLineChar;
74545:   } else if (nsAccUtils::MustPrune(Parent())) {
61842:     // Expose the embedded object accessible as imaginary embedded object
61842:     // character if its parent hypertext accessible doesn't expose children to
61842:     // AT.
43441:     aText += kImaginaryEmbeddedObjectChar;
43441:   } else {
43441:     aText += kEmbeddedObjectChar;
43441:   }
    1: }
    1: 
20246: ////////////////////////////////////////////////////////////////////////////////
43538: // nsAccessNode public methods
43538: 
43538: void
43538: nsAccessible::Shutdown()
43538: {
43538:   // Invalidate the child count and pointers to other accessibles, also make
43538:   // sure none of its children point to this parent
43538:   InvalidateChildren();
56292:   if (mParent)
56292:     mParent->RemoveChild(this);
43538: 
43538:   nsAccessNodeWrap::Shutdown();
43538: }
43538: 
43538: ////////////////////////////////////////////////////////////////////////////////
20246: // nsAccessible public methods
20246: 
20246: nsresult
20246: nsAccessible::GetARIAName(nsAString& aName)
20246: {
20246:   nsAutoString label;
49044: 
49044:   // aria-labelledby now takes precedence over aria-label
25175:   nsresult rv = nsTextEquivUtils::
78350:     GetTextEquivFromIDRefs(this, nsGkAtoms::aria_labelledby, label);
25175:   if (NS_SUCCEEDED(rv)) {
25175:     label.CompressWhitespace();
20246:     aName = label;
25175:   }
20246: 
49044:   if (label.IsEmpty() &&
78350:       mContent->GetAttr(kNameSpaceID_None, nsGkAtoms::aria_label,
49044:                         label)) {
49044:     label.CompressWhitespace();
49044:     aName = label;
49044:   }
49044:   
49044:   return NS_OK;
20246: }
20246: 
20246: nsresult
20246: nsAccessible::GetNameInternal(nsAString& aName)
20246: {
43504:   if (mContent->IsHTML())
22204:     return GetHTMLName(aName);
20246: 
43504:   if (mContent->IsXUL())
22204:     return GetXULName(aName);
20246: 
20246:   return NS_OK;
20246: }
20246: 
47105: // nsAccessible protected
35523: void
47105: nsAccessible::BindToParent(nsAccessible* aParent, PRUint32 aIndexInParent)
35523: {
35523:   NS_PRECONDITION(aParent, "This method isn't used to set null parent!");
35523: 
56292:   if (mParent) {
56292:     if (mParent != aParent) {
56292:       NS_ERROR("Adopting child!");
64129:       mParent->RemoveChild(this);
56292:     } else {
56292:       NS_ERROR("Binding to the same parent!");
56292:       return;
56292:     }
35523:   }
35523: 
35523:   mParent = aParent;
47105:   mIndexInParent = aIndexInParent;
35523: }
35523: 
35523: void
47803: nsAccessible::UnbindFromParent()
47803: {
47803:   mParent = nsnull;
47803:   mIndexInParent = -1;
50622:   mIndexOfEmbeddedChild = -1;
47803:   mGroupInfo = nsnull;
47803: }
47803: 
47803: void
35523: nsAccessible::InvalidateChildren()
35523: {
36989:   PRInt32 childCount = mChildren.Length();
35523:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
36989:     nsAccessible* child = mChildren.ElementAt(childIdx);
47105:     child->UnbindFromParent();
35523:   }
35523: 
50622:   mEmbeddedObjCollector = nsnull;
35523:   mChildren.Clear();
61466:   SetChildrenFlag(eChildrenUninitialized);
35523: }
35523: 
79445: bool
47105: nsAccessible::AppendChild(nsAccessible* aChild)
47105: {
57147:   if (!aChild)
80486:     return false;
57147: 
47105:   if (!mChildren.AppendElement(aChild))
80486:     return false;
47105: 
54948:   if (!nsAccUtils::IsEmbeddedObject(aChild))
61466:     SetChildrenFlag(eMixedChildren);
50622: 
47105:   aChild->BindToParent(this, mChildren.Length() - 1);
80486:   return true;
47105: }
47105: 
79445: bool
47105: nsAccessible::InsertChildAt(PRUint32 aIndex, nsAccessible* aChild)
47105: {
57147:   if (!aChild)
80486:     return false;
57147: 
47105:   if (!mChildren.InsertElementAt(aIndex, aChild))
80486:     return false;
47105: 
57147:   for (PRUint32 idx = aIndex + 1; idx < mChildren.Length(); idx++) {
57147:     NS_ASSERTION(mChildren[idx]->mIndexInParent == idx - 1, "Accessible child index doesn't match");
57147:     mChildren[idx]->mIndexInParent = idx;
57147:   }
47105: 
50622:   if (nsAccUtils::IsText(aChild))
61466:     SetChildrenFlag(eMixedChildren);
50622: 
50622:   mEmbeddedObjCollector = nsnull;
50622: 
47105:   aChild->BindToParent(this, aIndex);
80486:   return true;
47105: }
47105: 
79445: bool
47105: nsAccessible::RemoveChild(nsAccessible* aChild)
47105: {
57147:   if (!aChild)
80486:     return false;
57147: 
67790:   if (aChild->mParent != this || aChild->mIndexInParent == -1)
80486:     return false;
47105: 
67790:   PRUint32 index = static_cast<PRUint32>(aChild->mIndexInParent);
57147:   if (index >= mChildren.Length() || mChildren[index] != aChild) {
56426:     NS_ERROR("Child is bound to parent but parent hasn't this child at its index!");
56426:     aChild->UnbindFromParent();
80486:     return false;
56426:   }
56426: 
57147:   for (PRUint32 idx = index + 1; idx < mChildren.Length(); idx++) {
57147:     NS_ASSERTION(mChildren[idx]->mIndexInParent == idx, "Accessible child index doesn't match");
57147:     mChildren[idx]->mIndexInParent = idx - 1;
57147:   }
57147: 
57147:   aChild->UnbindFromParent();
57147:   mChildren.RemoveElementAt(index);
50622:   mEmbeddedObjCollector = nsnull;
50622: 
80486:   return true;
47105: }
47105: 
36989: nsAccessible*
35523: nsAccessible::GetChildAt(PRUint32 aIndex)
35523: {
36989:   nsAccessible *child = mChildren.SafeElementAt(aIndex, nsnull);
35523:   if (!child)
35523:     return nsnull;
35523: 
35523: #ifdef DEBUG
36989:   nsAccessible* realParent = child->mParent;
35523:   NS_ASSERTION(!realParent || realParent == this,
35523:                "Two accessibles have the same first child accessible!");
35523: #endif
35523: 
35523:   return child;
35523: }
35523: 
35523: PRInt32
35523: nsAccessible::GetChildCount()
35523: {
67626:   return mChildren.Length();
35523: }
35523: 
35523: PRInt32
47105: nsAccessible::GetIndexOf(nsAccessible* aChild)
35523: {
72476:   return (aChild->mParent != this) ? -1 : aChild->IndexInParent();
35523: }
35523: 
35523: PRInt32
72476: nsAccessible::IndexInParent() const
35523: {
47105:   return mIndexInParent;
36989: }
36989: 
50622: PRInt32
50622: nsAccessible::GetEmbeddedChildCount()
50622: {
61466:   if (IsChildrenFlag(eMixedChildren)) {
50622:     if (!mEmbeddedObjCollector)
50622:       mEmbeddedObjCollector = new EmbeddedObjCollector(this);
50622:     return mEmbeddedObjCollector ? mEmbeddedObjCollector->Count() : -1;
50622:   }
50622: 
50622:   return GetChildCount();
50622: }
50622: 
50622: nsAccessible*
50622: nsAccessible::GetEmbeddedChildAt(PRUint32 aIndex)
50622: {
61466:   if (IsChildrenFlag(eMixedChildren)) {
50622:     if (!mEmbeddedObjCollector)
50622:       mEmbeddedObjCollector = new EmbeddedObjCollector(this);
50622:     return mEmbeddedObjCollector ?
50622:       mEmbeddedObjCollector->GetAccessibleAt(aIndex) : nsnull;
50622:   }
50622: 
50622:   return GetChildAt(aIndex);
50622: }
50622: 
50622: PRInt32
50622: nsAccessible::GetIndexOfEmbeddedChild(nsAccessible* aChild)
50622: {
61466:   if (IsChildrenFlag(eMixedChildren)) {
50622:     if (!mEmbeddedObjCollector)
50622:       mEmbeddedObjCollector = new EmbeddedObjCollector(this);
50622:     return mEmbeddedObjCollector ?
50622:       mEmbeddedObjCollector->GetIndexAt(aChild) : -1;
50622:   }
50622: 
50622:   return GetIndexOf(aChild);
50622: }
50622: 
20246: ////////////////////////////////////////////////////////////////////////////////
51810: // HyperLinkAccessible methods
51810: 
51810: bool
72484: nsAccessible::IsLink()
51810: {
51810:   // Every embedded accessible within hypertext accessible implements
51810:   // hyperlink interface.
61468:   return mParent && mParent->IsHyperText() && nsAccUtils::IsEmbeddedObject(this);
51810: }
51810: 
51810: PRUint32
51810: nsAccessible::StartOffset()
51810: {
72484:   NS_PRECONDITION(IsLink(), "StartOffset is called not on hyper link!");
51810: 
61468:   nsHyperTextAccessible* hyperText = mParent ? mParent->AsHyperText() : nsnull;
51810:   return hyperText ? hyperText->GetChildOffset(this) : 0;
51810: }
51810: 
51810: PRUint32
51810: nsAccessible::EndOffset()
51810: {
72484:   NS_PRECONDITION(IsLink(), "EndOffset is called on not hyper link!");
51810: 
61468:   nsHyperTextAccessible* hyperText = mParent ? mParent->AsHyperText() : nsnull;
51810:   return hyperText ? (hyperText->GetChildOffset(this) + 1) : 0;
51810: }
51810: 
79384: bool
79384: nsAccessible::IsLinkSelected()
79384: {
79384:   NS_PRECONDITION(IsLink(),
79384:                   "IsLinkSelected() called on something that is not a hyper link!");
79384:   return FocusMgr()->IsFocused(this);
79384: }
79384: 
51810: PRUint32
51810: nsAccessible::AnchorCount()
51810: {
72484:   NS_PRECONDITION(IsLink(), "AnchorCount is called on not hyper link!");
51810:   return 1;
51810: }
51810: 
51810: nsAccessible*
72483: nsAccessible::AnchorAt(PRUint32 aAnchorIndex)
51810: {
72484:   NS_PRECONDITION(IsLink(), "GetAnchor is called on not hyper link!");
51810:   return aAnchorIndex == 0 ? this : nsnull;
51810: }
51810: 
51810: already_AddRefed<nsIURI>
72483: nsAccessible::AnchorURIAt(PRUint32 aAnchorIndex)
51810: {
72484:   NS_PRECONDITION(IsLink(), "AnchorURIAt is called on not hyper link!");
51810: 
51810:   if (aAnchorIndex != 0)
51810:     return nsnull;
51810: 
51810:   // Check if it's a simple xlink.
51810:   if (nsCoreUtils::IsXLink(mContent)) {
51810:     nsAutoString href;
78350:     mContent->GetAttr(kNameSpaceID_XLink, nsGkAtoms::href, href);
51810: 
51810:     nsCOMPtr<nsIURI> baseURI = mContent->GetBaseURI();
80526:     nsCOMPtr<nsIDocument> document = mContent->OwnerDoc();
51810:     nsIURI* anchorURI = nsnull;
51810:     NS_NewURI(&anchorURI, href,
51810:               document ? document->GetDocumentCharacterSet().get() : nsnull,
51810:               baseURI);
51810:     return anchorURI;
51810:   }
51810: 
51810:   return nsnull;
51810: }
51810: 
51865: 
51865: ////////////////////////////////////////////////////////////////////////////////
51865: // SelectAccessible
51865: 
51865: bool
51865: nsAccessible::IsSelect()
51865: {
51865:   // If we have an ARIA role attribute present and the role allows multi
51865:   // selectable state, then we need to support SelectAccessible interface. If
51865:   // either attribute (role or multiselectable) change, then we'll destroy this
51865:   // accessible so that we can follow COM identity rules.
51865: 
51865:   return mRoleMapEntry &&
51865:     (mRoleMapEntry->attributeMap1 == eARIAMultiSelectable ||
51865:      mRoleMapEntry->attributeMap2 == eARIAMultiSelectable ||
51865:      mRoleMapEntry->attributeMap3 == eARIAMultiSelectable);
51865: }
51865: 
51865: already_AddRefed<nsIArray>
51865: nsAccessible::SelectedItems()
51865: {
51865:   nsCOMPtr<nsIMutableArray> selectedItems = do_CreateInstance(NS_ARRAY_CONTRACTID);
51865:   if (!selectedItems)
51865:     return nsnull;
51865: 
51865:   AccIterator iter(this, filters::GetSelected, AccIterator::eTreeNav);
51865:   nsIAccessible* selected = nsnull;
75194:   while ((selected = iter.Next()))
80486:     selectedItems->AppendElement(selected, false);
51865: 
51865:   nsIMutableArray* items = nsnull;
51865:   selectedItems.forget(&items);
51865:   return items;
51865: }
51865: 
51865: PRUint32
51865: nsAccessible::SelectedItemCount()
51865: {
51865:   PRUint32 count = 0;
51865:   AccIterator iter(this, filters::GetSelected, AccIterator::eTreeNav);
51865:   nsAccessible* selected = nsnull;
75194:   while ((selected = iter.Next()))
51865:     ++count;
51865: 
51865:   return count;
51865: }
51865: 
51865: nsAccessible*
51865: nsAccessible::GetSelectedItem(PRUint32 aIndex)
51865: {
51865:   AccIterator iter(this, filters::GetSelected, AccIterator::eTreeNav);
51865:   nsAccessible* selected = nsnull;
51865: 
51865:   PRUint32 index = 0;
75194:   while ((selected = iter.Next()) && index < aIndex)
51865:     index++;
51865: 
51865:   return selected;
51865: }
51865: 
51865: bool
51865: nsAccessible::IsItemSelected(PRUint32 aIndex)
51865: {
51865:   PRUint32 index = 0;
51865:   AccIterator iter(this, filters::GetSelectable, AccIterator::eTreeNav);
51865:   nsAccessible* selected = nsnull;
75194:   while ((selected = iter.Next()) && index < aIndex)
51865:     index++;
51865: 
51865:   return selected &&
67790:     selected->State() & states::SELECTED;
51865: }
51865: 
51865: bool
51865: nsAccessible::AddItemToSelection(PRUint32 aIndex)
51865: {
51865:   PRUint32 index = 0;
51865:   AccIterator iter(this, filters::GetSelectable, AccIterator::eTreeNav);
51865:   nsAccessible* selected = nsnull;
75194:   while ((selected = iter.Next()) && index < aIndex)
51865:     index++;
51865: 
51865:   if (selected)
80486:     selected->SetSelected(true);
51865: 
51865:   return static_cast<bool>(selected);
51865: }
51865: 
51865: bool
51865: nsAccessible::RemoveItemFromSelection(PRUint32 aIndex)
51865: {
51865:   PRUint32 index = 0;
51865:   AccIterator iter(this, filters::GetSelectable, AccIterator::eTreeNav);
51865:   nsAccessible* selected = nsnull;
75194:   while ((selected = iter.Next()) && index < aIndex)
51865:     index++;
51865: 
51865:   if (selected)
80486:     selected->SetSelected(false);
51865: 
51865:   return static_cast<bool>(selected);
51865: }
51865: 
51865: bool
51865: nsAccessible::SelectAll()
51865: {
51865:   bool success = false;
51865:   nsAccessible* selectable = nsnull;
51865: 
51865:   AccIterator iter(this, filters::GetSelectable, AccIterator::eTreeNav);
75194:   while((selectable = iter.Next())) {
51865:     success = true;
80486:     selectable->SetSelected(true);
51865:   }
51865:   return success;
51865: }
51865: 
51865: bool
51865: nsAccessible::UnselectAll()
51865: {
51865:   bool success = false;
51865:   nsAccessible* selected = nsnull;
51865: 
51865:   AccIterator iter(this, filters::GetSelected, AccIterator::eTreeNav);
75194:   while ((selected = iter.Next())) {
51865:     success = true;
80486:     selected->SetSelected(false);
51865:   }
51865:   return success;
51865: }
51865: 
79384: ////////////////////////////////////////////////////////////////////////////////
79384: // Widgets
79384: 
79384: bool
79384: nsAccessible::IsWidget() const
79384: {
79384:   return false;
79384: }
79384: 
79384: bool
79384: nsAccessible::IsActiveWidget() const
79384: {
79384:   return FocusMgr()->IsFocused(this);
79384: }
79384: 
79384: bool
79384: nsAccessible::AreItemsOperable() const
79384: {
79384:   return mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::aria_activedescendant);
79384: }
79384: 
79384: nsAccessible*
79384: nsAccessible::CurrentItem()
79384: {
79384:   // Check for aria-activedescendant, which changes which element has focus.
79384:   // For activedescendant, the ARIA spec does not require that the user agent
79384:   // checks whether pointed node is actually a DOM descendant of the element
79384:   // with the aria-activedescendant attribute.
79384:   nsAutoString id;
79384:   if (mContent->GetAttr(kNameSpaceID_None,
79384:                         nsGkAtoms::aria_activedescendant, id)) {
80526:     nsIDocument* DOMDoc = mContent->OwnerDoc();
79384:     dom::Element* activeDescendantElm = DOMDoc->GetElementById(id);
79384:     if (activeDescendantElm) {
89800:       nsDocAccessible* document = Document();
79384:       if (document)
79384:         return document->GetAccessible(activeDescendantElm);
79384:     }
79384:   }
79384:   return nsnull;
79384: }
79384: 
84259: void
84259: nsAccessible::SetCurrentItem(nsAccessible* aItem)
84259: {
84259:   nsIAtom* id = aItem->GetContent()->GetID();
84259:   if (id) {
84259:     nsAutoString idStr;
84259:     id->ToString(idStr);
84259:     mContent->SetAttr(kNameSpaceID_None,
84259:                       nsGkAtoms::aria_activedescendant, idStr, true);
84259:   }
84259: }
84259: 
79384: nsAccessible*
79384: nsAccessible::ContainerWidget() const
79384: {
87821:   if (HasARIARole() && mContent->HasID()) {
84145:     for (nsAccessible* parent = Parent(); parent; parent = parent->Parent()) {
79384:       nsIContent* parentContent = parent->GetContent();
79384:       if (parentContent &&
79384:         parentContent->HasAttr(kNameSpaceID_None,
79384:                                nsGkAtoms::aria_activedescendant)) {
79384:         return parent;
79384:       }
84145: 
84145:       // Don't cross DOM document boundaries.
84145:       if (parent->IsDocumentNode())
84145:         break;
84145:     }
79384:   }
79384:   return nsnull;
79384: }
51865: 
51810: ////////////////////////////////////////////////////////////////////////////////
35523: // nsAccessible protected methods
35523: 
35523: void
35523: nsAccessible::CacheChildren()
35523: {
89800:   nsDocAccessible* doc = Document();
89799:   NS_ENSURE_TRUE(doc,);
89799: 
89801:   nsAccTreeWalker walker(doc, mContent, CanHaveAnonChildren());
38358: 
64506:   nsAccessible* child = nsnull;
64506:   while ((child = walker.NextChild()) && AppendChild(child));
35523: }
35523: 
35523: void
61461: nsAccessible::TestChildCache(nsAccessible* aCachedChild) const
35523: {
38000: #ifdef DEBUG
40990:   PRInt32 childCount = mChildren.Length();
35523:   if (childCount == 0) {
61466:     NS_ASSERTION(IsChildrenFlag(eChildrenUninitialized),
50622:                  "No children but initialized!");
35523:     return;
35523:   }
35523: 
39144:   nsAccessible *child = nsnull;
35523:   for (PRInt32 childIdx = 0; childIdx < childCount; childIdx++) {
39144:     child = mChildren[childIdx];
35523:     if (child == aCachedChild)
35523:       break;
35523:   }
35523: 
35523:   NS_ASSERTION(child == aCachedChild,
35523:                "[TestChildCache] cached accessible wasn't found. Wrong accessible tree!");  
35523: #endif
35523: }
35523: 
40575: // nsAccessible public
61463: bool
35523: nsAccessible::EnsureChildren()
35523: {
35523:   if (IsDefunct()) {
61466:     SetChildrenFlag(eChildrenUninitialized);
61463:     return true;
35523:   }
35523: 
61466:   if (!IsChildrenFlag(eChildrenUninitialized))
61463:     return false;
35523: 
50622:   // State is embedded children until text leaf accessible is appended.
61466:   SetChildrenFlag(eEmbeddedChildren); // Prevent reentry
57890: 
35523:   CacheChildren();
61463:   return false;
35523: }
35523: 
39191: nsAccessible*
71380: nsAccessible::GetSiblingAtOffset(PRInt32 aOffset, nsresult* aError) const
35523: {
71380:   if (!mParent || mIndexInParent == -1) {
35523:     if (aError)
35523:       *aError = NS_ERROR_UNEXPECTED;
35523: 
35523:     return nsnull;
35523:   }
35523: 
71380:   if (aError && mIndexInParent + aOffset >= mParent->GetChildCount()) {
35523:     *aError = NS_OK; // fail peacefully
35523:     return nsnull;
35523:   }
71380: 
71380:   nsAccessible* child = mParent->GetChildAt(mIndexInParent + aOffset);
35523:   if (aError && !child)
35523:     *aError = NS_ERROR_UNEXPECTED;
35523: 
35523:   return child;
35523: }
20246: 
42795: nsAccessible *
43504: nsAccessible::GetFirstAvailableAccessible(nsINode *aStartNode) const
    1: {
89799:   nsAccessible* accessible = mDoc->GetAccessible(aStartNode);
34455:   if (accessible)
42795:     return accessible;
34455: 
80526:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(aStartNode->OwnerDoc());
69899:   NS_ENSURE_TRUE(domDoc, nsnull);
64000: 
64000:   nsCOMPtr<nsIDOMNode> currentNode = do_QueryInterface(aStartNode);
69899:   nsCOMPtr<nsIDOMNode> rootNode = do_QueryInterface(GetNode());
64000:   nsCOMPtr<nsIDOMTreeWalker> walker;
69899:   domDoc->CreateTreeWalker(rootNode,
64000:                            nsIDOMNodeFilter::SHOW_ELEMENT | nsIDOMNodeFilter::SHOW_TEXT,
80486:                            nsnull, false, getter_AddRefs(walker));
64000:   NS_ENSURE_TRUE(walker, nsnull);
64000: 
64000:   walker->SetCurrentNode(currentNode);
64000:   while (true) {
64000:     walker->NextNode(getter_AddRefs(currentNode));
64000:     if (!currentNode)
64000:       return nsnull;
64000: 
64000:     nsCOMPtr<nsINode> node(do_QueryInterface(currentNode));
89799:     nsAccessible* accessible = mDoc->GetAccessible(node);
64000:     if (accessible)
64000:       return accessible;
64000:   }
64000: 
64000:   return nsnull;
    1: }
    1: 
 4274: nsresult
 8937: nsAccessible::GetAttrValue(nsIAtom *aProperty, double *aValue)
 4274: {
 4274:   NS_ENSURE_ARG_POINTER(aValue);
 4274:   *aValue = 0;
 4274: 
28024:   if (IsDefunct())
 4274:     return NS_ERROR_FAILURE;  // Node already shut down
 4274: 
 4274:  if (!mRoleMapEntry || mRoleMapEntry->valueRule == eNoValue)
 4274:     return NS_OK_NO_ARIA_VALUE;
 4274: 
28024:   nsAutoString attrValue;
43504:   mContent->GetAttr(kNameSpaceID_None, aProperty, attrValue);
28024: 
28024:   // Return zero value if there is no attribute or its value is empty.
28024:   if (attrValue.IsEmpty())
28024:     return NS_OK;
28024: 
28024:   PRInt32 error = NS_OK;
63877:   double value = attrValue.ToDouble(&error);
28024:   if (NS_SUCCEEDED(error))
28024:     *aValue = value;
28024: 
28024:   return NS_OK;
 4274: }
 4274: 
20140: PRUint32
67790: nsAccessible::GetActionRule(PRUint64 aStates)
20140: {
67790:   if (aStates & states::UNAVAILABLE)
20140:     return eNoAction;
20140:   
20140:   // Check if it's simple xlink.
43504:   if (nsCoreUtils::IsXLink(mContent))
20140:     return eJumpAction;
20140: 
31782:   // Return "click" action on elements that have an attached popup menu.
43504:   if (mContent->IsXUL())
78350:     if (mContent->HasAttr(kNameSpaceID_None, nsGkAtoms::popup))
31782:       return eClickAction;
31782: 
20140:   // Has registered 'click' event handler.
79445:   bool isOnclick = nsCoreUtils::HasClickListener(mContent);
20140: 
20140:   if (isOnclick)
20140:     return eClickAction;
20140:   
20140:   // Get an action based on ARIA role.
27511:   if (mRoleMapEntry &&
27511:       mRoleMapEntry->actionRule != eNoAction)
20140:     return mRoleMapEntry->actionRule;
20140: 
27511:   // Get an action based on ARIA attribute.
43504:   if (nsAccUtils::HasDefinedARIAToken(mContent,
78350:                                       nsGkAtoms::aria_expanded))
27511:     return eExpandAction;
27511: 
20140:   return eNoAction;
20140: }
23326: 
47172: AccGroupInfo*
47172: nsAccessible::GetGroupInfo()
47172: {
47172:   if (mGroupInfo)
47172:     return mGroupInfo;
47172: 
47172:   mGroupInfo = AccGroupInfo::CreateGroupInfo(this);
47172:   return mGroupInfo;
47172: }
47172: 
36879: void
36879: nsAccessible::GetPositionAndSizeInternal(PRInt32 *aPosInSet, PRInt32 *aSetSize)
23326: {
47172:   AccGroupInfo* groupInfo = GetGroupInfo();
47172:   if (groupInfo) {
47172:     *aPosInSet = groupInfo->PosInSet();
47172:     *aSetSize = groupInfo->SetSize();
47172:   }
36879: }
36879: 
36879: PRInt32
36879: nsAccessible::GetLevelInternal()
36879: {
37109:   PRInt32 level = nsAccUtils::GetDefaultLevel(this);
37109: 
74545:   if (!IsBoundToParent())
74545:     return level;
74545: 
87094:   roles::Role role = Role();
87094:   if (role == roles::OUTLINEITEM) {
23326:     // Always expose 'level' attribute for 'outlineitem' accessible. The number
23326:     // of nested 'grouping' accessibles containing 'outlineitem' accessible is
23326:     // its level.
37109:     level = 1;
37109: 
74545:     nsAccessible* parent = this;
74545:     while ((parent = parent->Parent())) {
87094:       roles::Role parentRole = parent->Role();
87094: 
87094:       if (parentRole == roles::OUTLINE)
23326:         break;
87094:       if (parentRole == roles::GROUPING)
36879:         ++ level;
23326: 
23326:     }
36879: 
87094:   } else if (role == roles::LISTITEM) {
23326:     // Expose 'level' attribute on nested lists. We assume nested list is a last
23326:     // child of listitem of parent list. We don't handle the case when nested
23326:     // lists have more complex structure, for example when there are accessibles
23326:     // between parent listitem and nested list.
23326: 
23326:     // Calculate 'level' attribute based on number of parent listitems.
37109:     level = 0;
74545:     nsAccessible* parent = this;
74545:     while ((parent = parent->Parent())) {
87094:       roles::Role parentRole = parent->Role();
87094: 
87094:       if (parentRole == roles::LISTITEM)
36879:         ++ level;
87094:       else if (parentRole != roles::LIST)
23326:         break;
23326: 
23326:     }
23326: 
36879:     if (level == 0) {
23326:       // If this listitem is on top of nested lists then expose 'level'
23326:       // attribute.
74545:       parent = Parent();
36989:       PRInt32 siblingCount = parent->GetChildCount();
36989:       for (PRInt32 siblingIdx = 0; siblingIdx < siblingCount; siblingIdx++) {
36989:         nsAccessible* sibling = parent->GetChildAt(siblingIdx);
36989: 
74545:         nsAccessible* siblingChild = sibling->LastChild();
87094:         if (siblingChild && siblingChild->Role() == roles::LIST)
74545:           return 1;
23326:       }
36879:     } else {
36879:       ++ level; // level is 1-index based
36879:     }
37109:   }
36879: 
36879:   return level;
36879: }
74014: 
74014: 
74014: ////////////////////////////////////////////////////////////////////////////////
74014: // KeyBinding class
74014: 
74014: void
74014: KeyBinding::ToPlatformFormat(nsAString& aValue) const
74014: {
74014:   nsCOMPtr<nsIStringBundle> keyStringBundle;
74014:   nsCOMPtr<nsIStringBundleService> stringBundleService =
74014:       mozilla::services::GetStringBundleService();
74014:   if (stringBundleService)
74014:     stringBundleService->CreateBundle(PLATFORM_KEYS_BUNDLE_URL,
74014:                                       getter_AddRefs(keyStringBundle));
74014: 
74014:   if (!keyStringBundle)
74014:     return;
74014: 
74014:   nsAutoString separator;
74014:   keyStringBundle->GetStringFromName(NS_LITERAL_STRING("MODIFIER_SEPARATOR").get(),
74014:                                      getter_Copies(separator));
74014: 
74014:   nsAutoString modifierName;
74014:   if (mModifierMask & kControl) {
74014:     keyStringBundle->GetStringFromName(NS_LITERAL_STRING("VK_CONTROL").get(),
74014:                                        getter_Copies(modifierName));
74014: 
74014:     aValue.Append(modifierName);
74014:     aValue.Append(separator);
74014:   }
74014: 
74014:   if (mModifierMask & kAlt) {
74014:     keyStringBundle->GetStringFromName(NS_LITERAL_STRING("VK_ALT").get(),
74014:                                        getter_Copies(modifierName));
74014: 
74014:     aValue.Append(modifierName);
74014:     aValue.Append(separator);
74014:   }
74014: 
74014:   if (mModifierMask & kShift) {
74014:     keyStringBundle->GetStringFromName(NS_LITERAL_STRING("VK_SHIFT").get(),
74014:                                        getter_Copies(modifierName));
74014: 
74014:     aValue.Append(modifierName);
74014:     aValue.Append(separator);
74014:   }
74014: 
74014:   if (mModifierMask & kMeta) {
74014:     keyStringBundle->GetStringFromName(NS_LITERAL_STRING("VK_META").get(),
74014:                                        getter_Copies(modifierName));
74014: 
74014:     aValue.Append(modifierName);
74014:     aValue.Append(separator);
74014:   }
74014: 
74014:   aValue.Append(mKey);
74014: }
74014: 
74014: void
74014: KeyBinding::ToAtkFormat(nsAString& aValue) const
74014: {
74014:   nsAutoString modifierName;
74014:   if (mModifierMask & kControl)
74014:     aValue.Append(NS_LITERAL_STRING("<Control>"));
74014: 
74014:   if (mModifierMask & kAlt)
74014:     aValue.Append(NS_LITERAL_STRING("<Alt>"));
74014: 
74014:   if (mModifierMask & kShift)
74014:     aValue.Append(NS_LITERAL_STRING("<Shift>"));
74014: 
74014:   if (mModifierMask & kMeta)
74014:       aValue.Append(NS_LITERAL_STRING("<Meta>"));
74014: 
74014:   aValue.Append(mKey);
74014: }
