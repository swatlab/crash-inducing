59571: /* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
43032:  * ***** BEGIN LICENSE BLOCK *****
43032:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43032:  *
43032:  * The contents of this file are subject to the Mozilla Public License Version
43032:  * 1.1 (the "License"); you may not use this file except in compliance with
43032:  * the License. You may obtain a copy of the License at
43032:  * http://www.mozilla.org/MPL/
43032:  *
43032:  * Software distributed under the License is distributed on an "AS IS" basis,
43032:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43032:  * for the specific language governing rights and limitations under the
43032:  * License.
43032:  *
43032:  * The Original Code is Mozilla Android code.
43032:  *
43032:  * The Initial Developer of the Original Code is Mozilla Foundation.
43032:  * Portions created by the Initial Developer are Copyright (C) 2010
43032:  * the Initial Developer. All Rights Reserved.
43032:  *
43032:  * Contributor(s):
43032:  *   Vladimir Vukicevic <vladimir@pobox.com>
43032:  *
43032:  * Alternatively, the contents of this file may be used under the terms of
43032:  * either the GNU General Public License Version 2 or later (the "GPL"), or
43032:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43032:  * in which case the provisions of the GPL or the LGPL are applicable instead
43032:  * of those above. If you wish to allow use of your version of this file only
43032:  * under the terms of either the GPL or the LGPL, and not to allow others to
43032:  * use your version of this file under the terms of the MPL, indicate your
43032:  * decision by deleting the provisions above and replace them with the notice
43032:  * and other provisions required by the GPL or the LGPL. If you do not delete
43032:  * the provisions above, a recipient may use your version of this file under
43032:  * the terms of any one of the MPL, the GPL or the LGPL.
43032:  *
43032:  * ***** END LICENSE BLOCK ***** */
43032: 
43032: package org.mozilla.gecko;
43032: 
43032: import java.io.*;
62122: import java.lang.reflect.*;
62122: import java.nio.*;
62122: import java.nio.channels.*;
62122: import java.text.*;
43032: import java.util.*;
43032: import java.util.zip.*;
63334: import java.util.concurrent.*;
43032: 
43032: import android.os.*;
43032: import android.app.*;
43032: import android.text.*;
43032: import android.view.*;
43032: import android.view.inputmethod.*;
43032: import android.content.*;
57134: import android.content.res.*;
57134: import android.content.pm.*;
43032: import android.graphics.*;
43032: import android.widget.*;
43032: import android.hardware.*;
43107: import android.location.*;
63350: import android.webkit.MimeTypeMap;
67623: import android.media.MediaScannerConnection;
67623: import android.media.MediaScannerConnection.MediaScannerConnectionClient;
76328: import android.provider.Settings;
43032: 
43032: import android.util.*;
48960: import android.net.Uri;
60931: import android.net.ConnectivityManager;
60931: import android.net.NetworkInfo;
43032: 
83536: import android.graphics.Bitmap;
72119: import android.graphics.drawable.*;
72119: 
83485: import org.json.JSONArray;
83485: import org.json.JSONObject;
83485: 
63326: public class GeckoAppShell
43032: {
76836:     private static final String LOG_FILE_NAME = "GeckoAppShell";
76836: 
43032:     // static members only
43032:     private GeckoAppShell() { }
43032: 
59710:     static private LinkedList<GeckoEvent> gPendingEvents =
59710:         new LinkedList<GeckoEvent>();
43032: 
43032:     static private boolean gRestartScheduled = false;
43032: 
48868:     static private final Timer mIMETimer = new Timer();
54906:     static private final HashMap<Integer, AlertNotification>
54906:         mAlertNotifications = new HashMap<Integer, AlertNotification>();
48868: 
48868:     static private final int NOTIFY_IME_RESETINPUTSTATE = 0;
48868:     static private final int NOTIFY_IME_SETOPENSTATE = 1;
58018:     static private final int NOTIFY_IME_CANCELCOMPOSITION = 2;
58018:     static private final int NOTIFY_IME_FOCUSCHANGE = 3;
44156: 
83503:     /* Keep in sync with constants found here:
83503:       http://mxr.mozilla.org/mozilla-central/source/uriloader/base/nsIWebProgressListener.idl
83503:     */
83503:     static private final int WPL_STATE_START = 0x00000001;
83511:     static private final int WPL_STATE_STOP = 0x00000010;
83503:     static private final int WPL_STATE_IS_DOCUMENT = 0x00020000;
83503: 
60836:     static private File sCacheFile = null;
60836:     static private int sFreeSpace = -1;
60061: 
43032:     /* The Android-side API: API methods that Android calls */
43032: 
43032:     // Initialization methods
43032:     public static native void nativeInit();
43032:     public static native void nativeRun(String args);
43032: 
43032:     // helper methods
43032:     public static native void setSurfaceView(GeckoSurfaceView sv);
43032:     public static native void putenv(String map);
61773:     public static native void onResume();
51794:     public static native void onLowMemory();
51723:     public static native void callObserver(String observerKey, String topic, String data);
51723:     public static native void removeObserver(String observerKey);
60061:     public static native void loadLibs(String apkName, boolean shouldExtract);
79687:     public static native void onChangeNetworkLinkStatus(String status);
71129:     public static native void reportJavaCrash(String stack);
43032: 
76837:     public static native void processNextNativeEvent();
76837: 
63362:     // A looper thread, accessed by GeckoAppShell.getHandler
63362:     private static class LooperThread extends Thread {
63362:         public SynchronousQueue<Handler> mHandlerQueue =
63362:             new SynchronousQueue<Handler>();
63362:         
63362:         public void run() {
63362:             Looper.prepare();
63362:             try {
63362:                 mHandlerQueue.put(new Handler());
63362:             } catch (InterruptedException ie) {}
63362:             Looper.loop();
63362:         }
63362:     }
63362: 
67623:     private static class GeckoMediaScannerClient implements MediaScannerConnectionClient {
67623:         private String mFile = "";
67623:         private String mMimeType = "";
67623:         private MediaScannerConnection mScanner = null;
67623: 
67623:         public GeckoMediaScannerClient(Context aContext, String aFile, String aMimeType) {
67623:             mFile = aFile;
67623:             mMimeType = aMimeType;
67623:             mScanner = new MediaScannerConnection(aContext, this);
67623:             if (mScanner != null)
67623:                 mScanner.connect();
67623:         }
67623: 
67623:         public void onMediaScannerConnected() {
67623:             mScanner.scanFile(mFile, mMimeType);
67623:         }
67623: 
67623:         public void onScanCompleted(String path, Uri uri) {
67623:             if(path.equals(mFile)) {
67623:                 mScanner.disconnect();
67623:                 mScanner = null;
67623:             }
67623:         }
67623:     }
67623: 
64514:     // Get a Handler for the main java thread
64514:     public static Handler getMainHandler() {
64514:         return GeckoApp.mAppContext.mMainHandler;
64514:     }
64514: 
63362:     private static Handler sHandler = null;
63362: 
63362:     // Get a Handler for a looper thread, or create one if it doesn't exist yet
63362:     public static Handler getHandler() {
63362:         if (sHandler == null) {
63362:             LooperThread lt = new LooperThread();
63362:             lt.start();
63362:             try {
63362:                 sHandler = lt.mHandlerQueue.take();
63362:             } catch (InterruptedException ie) {}
63362:         }
63362:         return sHandler;
63362:     }
63362: 
60836:     public static File getCacheDir() {
60836:         if (sCacheFile == null)
60836:             sCacheFile = GeckoApp.mAppContext.getCacheDir();
60836:         return sCacheFile;
60836:     }
60836: 
60836:     public static long getFreeSpace() {
62453:         try {
60836:             if (sFreeSpace == -1) {
62453:                 File cacheDir = getCacheDir();
62453:                 if (cacheDir != null) {
62453:                     StatFs cacheStats = new StatFs(cacheDir.getPath());
60836:                     sFreeSpace = cacheStats.getFreeBlocks() *
60836:                         cacheStats.getBlockSize();
62453:                 } else {
76836:                     Log.i(LOG_FILE_NAME, "Unable to get cache dir");
62453:                 }
62453:             }
62453:         } catch (Exception e) {
76836:             Log.e(LOG_FILE_NAME, "exception while stating cache dir: ", e);
60836:         }
60836:         return sFreeSpace;
60836:     }
60836: 
62122:     static boolean moveFile(File inFile, File outFile)
62122:     {
76836:         Log.i(LOG_FILE_NAME, "moving " + inFile + " to " + outFile);
62122:         if (outFile.isDirectory())
62122:             outFile = new File(outFile, inFile.getName());
62122:         try {
62122:             if (inFile.renameTo(outFile))
62122:                 return true;
62122:         } catch (SecurityException se) {
76836:             Log.w(LOG_FILE_NAME, "error trying to rename file", se);
62122:         }
62122:         try {
62122:             long lastModified = inFile.lastModified();
62122:             outFile.createNewFile();
62122:             // so copy it instead
62122:             FileChannel inChannel = new FileInputStream(inFile).getChannel();
62122:             FileChannel outChannel = new FileOutputStream(outFile).getChannel();
62122:             long size = inChannel.size();
62122:             long transferred = inChannel.transferTo(0, size, outChannel);
62122:             inChannel.close();
62122:             outChannel.close();
62122:             outFile.setLastModified(lastModified);
62122: 
62122:             if (transferred == size)
62122:                 inFile.delete();
62122:             else
62122:                 return false;
62122:         } catch (Exception e) {
76836:             Log.e(LOG_FILE_NAME, "exception while moving file: ", e);
62122:             try {
62122:                 outFile.delete();
62122:             } catch (SecurityException se) {
76836:                 Log.w(LOG_FILE_NAME, "error trying to delete file", se);
62122:             }
62122:             return false;
62122:         }
62122:         return true;
62122:     }
62122: 
62122:     static boolean moveDir(File from, File to) {
62122:         try {
62122:             to.mkdirs();
62122:             if (from.renameTo(to))
62122:                 return true;
62122:         } catch (SecurityException se) {
76836:             Log.w(LOG_FILE_NAME, "error trying to rename file", se);
62122:         }
62122:         File[] files = from.listFiles();
62122:         boolean retVal = true;
62122:         if (files == null)
62122:             return false;
62122:         try {
62122:             Iterator fileIterator = Arrays.asList(files).iterator();
62122:             while (fileIterator.hasNext()) {
62122:                 File file = (File)fileIterator.next();
62122:                 File dest = new File(to, file.getName());
62122:                 if (file.isDirectory())
62122:                     retVal = moveDir(file, dest) ? retVal : false;
62122:                 else
62122:                     retVal = moveFile(file, dest) ? retVal : false;
62122:             }
62122:             from.delete();
62122:         } catch(Exception e) {
76836:             Log.e(LOG_FILE_NAME, "error trying to move file", e);
62122:         }
62122:         return retVal;
62122:     }
62122: 
43032:     // java-side stuff
55917:     public static void loadGeckoLibs(String apkName) {
43032:         // The package data lib directory isn't placed in ld.so's
43032:         // search path, so we have to manually load libraries that
43032:         // libxul will depend on.  Not ideal.
55917:         System.loadLibrary("mozutils");
62122:         GeckoApp geckoApp = GeckoApp.mAppContext;
62122:         String homeDir;
62236:         if (Build.VERSION.SDK_INT < 8 ||
78805:             geckoApp.getApplication().getPackageResourcePath().startsWith("/data") ||
78805:             geckoApp.getApplication().getPackageResourcePath().startsWith("/system")) {
62122:             File home = geckoApp.getFilesDir();
62122:             homeDir = home.getPath();
62122:             // handle the application being moved to phone from sdcard
62122:             File profileDir = new File(homeDir, "mozilla");
62122:             File oldHome = new File("/data/data/" + 
62122:                         GeckoApp.mAppContext.getPackageName() + "/mozilla");
62122:             if (oldHome.exists())
62122:                 moveDir(oldHome, profileDir);
62236:             if (Build.VERSION.SDK_INT >= 8) {
62122:                 File extHome =  geckoApp.getExternalFilesDir(null);
62122:                 File extProf = new File (extHome, "mozilla");
62674:                 if (extHome != null && extProf != null && extProf.exists())
62122:                     moveDir(extProf, profileDir);
62236:             }
62122:         } else {
62122:             File home = geckoApp.getExternalFilesDir(null);
62122:             homeDir = home.getPath();
62122:             // handle the application being moved to phone from sdcard
62122:             File profileDir = new File(homeDir, "mozilla");
62122:             File oldHome = new File("/data/data/" + 
62122:                         GeckoApp.mAppContext.getPackageName() + "/mozilla");
62122:             if (oldHome.exists())
62122:                 moveDir(oldHome, profileDir);
47825: 
62122:             File intHome =  geckoApp.getFilesDir();
62122:             File intProf = new File(intHome, "mozilla");
62674:             if (intHome != null && intProf != null && intProf.exists())
62122:                 moveDir(intProf, profileDir);
62122:         }
78424:         try {
78424:             String[] dirs = GeckoApp.mAppContext.getPluginDirectories();
78424:             StringBuffer pluginSearchPath = new StringBuffer();
78424:             for (int i = 0; i < dirs.length; i++) {
78424:                 Log.i("GeckoPlugins", "dir: " + dirs[i]);
78424:                 pluginSearchPath.append(dirs[i]);
78424:                 pluginSearchPath.append(":");
78424:             }
78424:             GeckoAppShell.putenv("MOZ_PLUGIN_PATH="+pluginSearchPath);
78424:         } catch (Exception ex) {
78424:             Log.i("GeckoPlugins", "exception getting plugin dirs", ex);
78424:         }
78424: 
62122:         GeckoAppShell.putenv("HOME=" + homeDir);
62123:         GeckoAppShell.putenv("GRE_HOME=" + GeckoApp.sGREDir.getPath());
62122:         Intent i = geckoApp.getIntent();
47825:         String env = i.getStringExtra("env0");
76836:         Log.i(LOG_FILE_NAME, "env0: "+ env);
47825:         for (int c = 1; env != null; c++) {
47825:             GeckoAppShell.putenv(env);
47825:             env = i.getStringExtra("env" + c);
76836:             Log.i(LOG_FILE_NAME, "env"+ c +": "+ env);
47825:         }
48958: 
62122:         File f = geckoApp.getDir("tmp", Context.MODE_WORLD_READABLE |
62122:                                  Context.MODE_WORLD_WRITEABLE );
62122: 
48958:         if (!f.exists())
48958:             f.mkdirs();
55917: 
48958:         GeckoAppShell.putenv("TMPDIR=" + f.getPath());
48958: 
51176:         f = Environment.getDownloadCacheDirectory();
59798:         GeckoAppShell.putenv("EXTERNAL_STORAGE=" + f.getPath());
60836: 
60836:         File cacheFile = getCacheDir();
60061:         GeckoAppShell.putenv("CACHE_PATH=" + cacheFile.getPath());
60061: 
60061:         // gingerbread introduces File.getUsableSpace(). We should use that.
60836:         long freeSpace = getFreeSpace();
60386:         try {
59798:             File downloadDir = null;
62278:             File updatesDir  = null;
62278:             if (Build.VERSION.SDK_INT >= 8) {
62278:                 downloadDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);
62278:                 updatesDir  = GeckoApp.mAppContext.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS);
62278:             } else {
62278:                 updatesDir = downloadDir = new File(Environment.getExternalStorageDirectory().getPath(), "download");
62278:             }
59798:             GeckoAppShell.putenv("DOWNLOADS_DIRECTORY=" + downloadDir.getPath());
62278:             GeckoAppShell.putenv("UPDATES_DIRECTORY="   + updatesDir.getPath());
60386:         }
60386:         catch (Exception e) {
76836:             Log.i(LOG_FILE_NAME, "No download directory has been found: " + e);
60386:         }
59872: 
59872:         putLocaleEnv();
57606: 
78321:         boolean extractLibs = GeckoApp.ACTION_DEBUG.equals(i.getAction());
78321:         if (!extractLibs) {
78321:             // remove any previously extracted libs
61344:             File[] files = cacheFile.listFiles();
61344:             if (files != null) {
61344:                 Iterator cacheFiles = Arrays.asList(files).iterator();
60061:                 while (cacheFiles.hasNext()) {
60061:                     File libFile = (File)cacheFiles.next();
60061:                     if (libFile.getName().endsWith(".so"))
60061:                         libFile.delete();
60061:                 }
60061:             }
61344:         }
78321:         loadLibs(apkName, extractLibs);
43032:     }
43032: 
59872:     private static void putLocaleEnv() {
59872:         GeckoAppShell.putenv("LANG=" + Locale.getDefault().toString());
59872:         NumberFormat nf = NumberFormat.getInstance();
59872:         if (nf instanceof DecimalFormat) {
59872:             DecimalFormat df = (DecimalFormat)nf;
59872:             DecimalFormatSymbols dfs = df.getDecimalFormatSymbols();
59872: 
59872:             GeckoAppShell.putenv("LOCALE_DECIMAL_POINT=" + dfs.getDecimalSeparator());
59872:             GeckoAppShell.putenv("LOCALE_THOUSANDS_SEP=" + dfs.getGroupingSeparator());
59872:             GeckoAppShell.putenv("LOCALE_GROUPING=" + (char)df.getGroupingSize());
59872:         }
59872:     }
59872: 
43032:     public static void runGecko(String apkPath, String args, String url) {
43032:         // run gecko -- it will spawn its own thread
43032:         GeckoAppShell.nativeInit();
43032: 
43032:         // Tell Gecko where the target surface view is for rendering
43032:         GeckoAppShell.setSurfaceView(GeckoApp.surfaceView);
43032: 
43032:         // First argument is the .apk path
70010:         String combinedArgs = apkPath + " -greomni " + apkPath;
43032:         if (args != null)
43032:             combinedArgs += " " + args;
43032:         if (url != null)
83540:             combinedArgs += " -remote " + url;
78424: 
43032:         // and go
43032:         GeckoAppShell.nativeRun(combinedArgs);
43032:     }
43032: 
43032:     private static GeckoEvent mLastDrawEvent;
43032: 
59710:     private static void sendPendingEventsToGecko() {
59710:         try {
59710:             while (!gPendingEvents.isEmpty()) {
59710:                 GeckoEvent e = gPendingEvents.removeFirst();
59710:                 notifyGeckoOfEvent(e);
59710:             }
59710:         } catch (NoSuchElementException e) {}
59710:     }
59710: 
43032:     public static void sendEventToGecko(GeckoEvent e) {
58306:         if (GeckoApp.checkLaunchState(GeckoApp.LaunchState.GeckoRunning)) {
43032:             notifyGeckoOfEvent(e);
56420:         } else {
59710:             gPendingEvents.addLast(e);
56420:         }
43032:     }
43032: 
63330:     public static void sendEventToGeckoSync(GeckoEvent e) {
63330:         sendEventToGecko(e);
63330:         geckoEventSync();
63330:     }
63330: 
43032:     // Tell the Gecko event loop that an event is available.
43032:     public static native void notifyGeckoOfEvent(GeckoEvent event);
43032: 
43032:     /*
43032:      *  The Gecko-side API: API methods that Gecko calls
43032:      */
43032:     public static void scheduleRedraw() {
43032:         // Redraw everything
43032:         scheduleRedraw(0, -1, -1, -1, -1);
43032:     }
43032: 
43032:     public static void scheduleRedraw(int nativeWindow, int x, int y, int w, int h) {
43032:         GeckoEvent e;
43032: 
43032:         if (x == -1) {
43032:             e = new GeckoEvent(GeckoEvent.DRAW, null);
43032:         } else {
43032:             e = new GeckoEvent(GeckoEvent.DRAW, new Rect(x, y, w, h));
43032:         }
43032: 
43032:         e.mNativeWindow = nativeWindow;
43032: 
43032:         sendEventToGecko(e);
43032:     }
43032: 
48868:     /* Delay updating IME states (see bug 573800) */
48868:     private static final class IMEStateUpdater extends TimerTask
48868:     {
48868:         static private IMEStateUpdater instance;
48868:         private boolean mEnable, mReset;
44156: 
48868:         static private IMEStateUpdater getInstance() {
48868:             if (instance == null) {
48868:                 instance = new IMEStateUpdater();
48868:                 mIMETimer.schedule(instance, 200);
48868:             }
48868:             return instance;
48868:         }
48868: 
48868:         static public synchronized void enableIME() {
48868:             getInstance().mEnable = true;
48868:         }
48868: 
48868:         static public synchronized void resetIME() {
48868:             getInstance().mReset = true;
48868:         }
48868: 
44156:         public void run() {
48868:             synchronized(IMEStateUpdater.class) {
48868:                 instance = null;
48868:             }
48868: 
43032:             InputMethodManager imm = (InputMethodManager)
48868:                 GeckoApp.surfaceView.getContext().getSystemService(
48868:                     Context.INPUT_METHOD_SERVICE);
48868:             if (imm == null)
48868:                 return;
48868: 
48868:             if (mReset)
48868:                 imm.restartInput(GeckoApp.surfaceView);
48868: 
48868:             if (!mEnable)
48868:                 return;
43032: 
68713:             int state = GeckoApp.surfaceView.mIMEState;
68713:             if (state != GeckoSurfaceView.IME_STATE_DISABLED &&
68713:                 state != GeckoSurfaceView.IME_STATE_PLUGIN)
43032:                 imm.showSoftInput(GeckoApp.surfaceView, 0);
43032:             else
48868:                 imm.hideSoftInputFromWindow(
48868:                     GeckoApp.surfaceView.getWindowToken(), 0);
48868:         }
48868:     }
48868: 
48868:     public static void notifyIME(int type, int state) {
48868:         if (GeckoApp.surfaceView == null)
48868:             return;
48868: 
48868:         switch (type) {
48868:         case NOTIFY_IME_RESETINPUTSTATE:
63349:             // Composition event is already fired from widget.
63349:             // So reset IME flags.
63349:             GeckoApp.surfaceView.inputConnection.reset();
63349:             
63349:             // Don't use IMEStateUpdater for reset.
63349:             // Because IME may not work showSoftInput()
63349:             // after calling restartInput() immediately.
63349:             // So we have to call showSoftInput() delay.
63349:             InputMethodManager imm = (InputMethodManager) 
63349:                 GeckoApp.surfaceView.getContext().getSystemService(
63349:                     Context.INPUT_METHOD_SERVICE);
63349:             if (imm == null) {
63349:                 // no way to reset IME status directly
48868:                 IMEStateUpdater.resetIME();
63349:             } else {
63349:                 imm.restartInput(GeckoApp.surfaceView);
63349:             }
63349: 
48868:             // keep current enabled state
48868:             IMEStateUpdater.enableIME();
48868:             break;
48868: 
48868:         case NOTIFY_IME_CANCELCOMPOSITION:
48868:             IMEStateUpdater.resetIME();
48868:             break;
48868: 
48868:         case NOTIFY_IME_FOCUSCHANGE:
54609:             IMEStateUpdater.resetIME();
48868:             break;
58018:         }
58018:     }
44156: 
58121:     public static void notifyIMEEnabled(int state, String typeHint,
67854:                                         String actionHint, boolean landscapeFS)
67854:     {
58018:         if (GeckoApp.surfaceView == null)
58018:             return;
58018: 
58018:         /* When IME is 'disabled', IME processing is disabled.
58018:            In addition, the IME UI is hidden */
58018:         GeckoApp.surfaceView.mIMEState = state;
58121:         GeckoApp.surfaceView.mIMETypeHint = typeHint;
58121:         GeckoApp.surfaceView.mIMEActionHint = actionHint;
67854:         GeckoApp.surfaceView.mIMELandscapeFS = landscapeFS;
58018:         IMEStateUpdater.enableIME();
44156:     }
48868: 
48868:     public static void notifyIMEChange(String text, int start, int end, int newEnd) {
48868:         if (GeckoApp.surfaceView == null ||
48868:             GeckoApp.surfaceView.inputConnection == null)
48868:             return;
48868: 
48868:         InputMethodManager imm = (InputMethodManager)
48868:             GeckoApp.surfaceView.getContext().getSystemService(
48868:                 Context.INPUT_METHOD_SERVICE);
48868:         if (imm == null)
48868:             return;
48868: 
76743:         // Log.d("GeckoAppJava", String.format("IME: notifyIMEChange: t=%s s=%d ne=%d oe=%d",
76743:         //                                      text, start, newEnd, end));
76743: 
48868:         if (newEnd < 0)
48868:             GeckoApp.surfaceView.inputConnection.notifySelectionChange(
48868:                 imm, start, end);
48868:         else
48868:             GeckoApp.surfaceView.inputConnection.notifyTextChange(
48868:                 imm, text, start, end, newEnd);
43032:     }
43032: 
63334:     private static CountDownLatch sGeckoPendingAcks = null;
63330: 
63330:     // Block the current thread until the Gecko event loop is caught up
63334:     synchronized public static void geckoEventSync() {
63334:         sGeckoPendingAcks = new CountDownLatch(1);
63330:         GeckoAppShell.sendEventToGecko(
63330:             new GeckoEvent(GeckoEvent.GECKO_EVENT_SYNC));
63334:         while (sGeckoPendingAcks.getCount() != 0) {
63330:             try {
63334:                 sGeckoPendingAcks.await();
63334:             } catch (InterruptedException e) {}
63330:         }
63334:         sGeckoPendingAcks = null;
63330:     }
63330: 
63330:     // Signal the Java thread that it's time to wake up
63330:     public static void acknowledgeEventSync() {
63334:         CountDownLatch tmp = sGeckoPendingAcks;
63334:         if (tmp != null)
63334:             tmp.countDown();
63330:     }
63330: 
72018:     static Sensor gAccelerometerSensor = null;
72018:     static Sensor gOrientationSensor = null;
72018: 
72018:     public static void enableDeviceMotion(boolean enable) {
72018: 
43032:         SensorManager sm = (SensorManager)
43032:             GeckoApp.surfaceView.getContext().getSystemService(Context.SENSOR_SERVICE);
43032: 
72018:         if (gAccelerometerSensor == null || gOrientationSensor == null) {
72018:             gAccelerometerSensor = sm.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);
72018:             gOrientationSensor   = sm.getDefaultSensor(Sensor.TYPE_ORIENTATION);
72018:         }
72018: 
43032:         if (enable) {
72018:             if (gAccelerometerSensor != null)
72018:                 sm.registerListener(GeckoApp.surfaceView, gAccelerometerSensor, SensorManager.SENSOR_DELAY_GAME);
72018:             if (gOrientationSensor != null)
72018:                 sm.registerListener(GeckoApp.surfaceView, gOrientationSensor,   SensorManager.SENSOR_DELAY_GAME);
43032:         } else {
72018:             if (gAccelerometerSensor != null)
72018:                 sm.unregisterListener(GeckoApp.surfaceView, gAccelerometerSensor);
72018:             if (gOrientationSensor != null)
72018:                 sm.unregisterListener(GeckoApp.surfaceView, gOrientationSensor);
43032:         }
43032:     }
43032: 
64514:     public static void enableLocation(final boolean enable) {
64514:      
64514:         getMainHandler().post(new Runnable() { 
64514:                 public void run() {
64514:                     GeckoSurfaceView view = GeckoApp.surfaceView;
43107:                     LocationManager lm = (LocationManager)
64514:                         view.getContext().getSystemService(Context.LOCATION_SERVICE);
43107: 
43107:                     if (enable) {
43107:                         Criteria crit = new Criteria();
43107:                         crit.setAccuracy(Criteria.ACCURACY_FINE);
43107:                         String provider = lm.getBestProvider(crit, true);
43107:                         if (provider == null)
43107:                             return;
43107: 
64514:                         Looper l = Looper.getMainLooper();
54498:                         Location loc = lm.getLastKnownLocation(provider);
64514:                         if (loc != null) {
64514:                             view.onLocationChanged(loc);
64514:                         }
64514:                         lm.requestLocationUpdates(provider, 100, (float).5, view, l);
43107:                     } else {
64514:                         lm.removeUpdates(view);
43107:                     }
43107:                 }
64514:             });
64514:     }
43107: 
43694:     public static void moveTaskToBack() {
43694:         GeckoApp.mAppContext.moveTaskToBack(true);
43694:     }
43694: 
48868:     public static void returnIMEQueryResult(String result, int selectionStart, int selectionLength) {
43032:         GeckoApp.surfaceView.inputConnection.mSelectionStart = selectionStart;
48868:         GeckoApp.surfaceView.inputConnection.mSelectionLength = selectionLength;
43032:         try {
43032:             GeckoApp.surfaceView.inputConnection.mQueryResult.put(result);
43032:         } catch (InterruptedException e) {
43032:         }
43032:     }
43032: 
56483:     static void onAppShellReady()
56483:     {
58306:         // mLaunchState can only be Launched at this point
58306:         GeckoApp.setLaunchState(GeckoApp.LaunchState.GeckoRunning);
59710:         sendPendingEventsToGecko();
56483:     }
56483: 
43032:     static void onXreExit() {
58306:         // mLaunchState can only be Launched or GeckoRunning at this point
58306:         GeckoApp.setLaunchState(GeckoApp.LaunchState.GeckoExiting);
43032:         Log.i("GeckoAppJava", "XRE exited");
43032:         if (gRestartScheduled) {
43032:             GeckoApp.mAppContext.doRestart();
43032:         } else {
43032:             Log.i("GeckoAppJava", "we're done, good bye");
56418:             GeckoApp.mAppContext.finish();
63376:         }
57316:         System.exit(0);
43032:     }
43032:     static void scheduleRestart() {
43032:         Log.i("GeckoAppJava", "scheduling restart");
43032:         gRestartScheduled = true;
43032:     }
43601: 
55889:     // "Installs" an application by creating a shortcut
75067:     static void createShortcut(String aTitle, String aURI, String aIconData, String aType) {
79787:         Log.w("GeckoAppJava", "createShortcut for " + aURI + " [" + aTitle + "] > " + aType);
55889: 
55889:         // the intent to be launched by the shortcut
75067:         Intent shortcutIntent = new Intent();
79787:         if (aType.equalsIgnoreCase("webapp")) {
75067:             shortcutIntent.setAction("org.mozilla.gecko.WEBAPP");
75067:             shortcutIntent.putExtra("args", "--webapp=" + aURI);
75067:         } else {
75067:             shortcutIntent.setAction("org.mozilla.gecko.BOOKMARK");
75067:             shortcutIntent.putExtra("args", "--url=" + aURI);
75067:         }
55889:         shortcutIntent.setClassName(GeckoApp.mAppContext,
59565:                                     GeckoApp.mAppContext.getPackageName() + ".App");
55889: 
55889:         Intent intent = new Intent();
55889:         intent.putExtra(Intent.EXTRA_SHORTCUT_INTENT, shortcutIntent);
55889:         intent.putExtra(Intent.EXTRA_SHORTCUT_NAME, aTitle);
55889:         byte[] raw = Base64.decode(aIconData.substring(22), Base64.DEFAULT);
55889:         Bitmap bitmap = BitmapFactory.decodeByteArray(raw, 0, raw.length);
55889:         intent.putExtra(Intent.EXTRA_SHORTCUT_ICON, bitmap);
55889:         intent.setAction("com.android.launcher.action.INSTALL_SHORTCUT");
55889:         GeckoApp.mAppContext.sendBroadcast(intent);
55889:     }
55889: 
54802:     static String[] getHandlersForMimeType(String aMimeType, String aAction) {
54802:         Intent intent = getIntentForActionString(aAction);
54802:         if (aMimeType != null && aMimeType.length() > 0)
54802:             intent.setType(aMimeType);
54802:         return getHandlersForIntent(intent);
54802:     }
54802: 
59260:     static String[] getHandlersForURL(String aURL, String aAction) {
59260:         // aURL may contain the whole URL or just the protocol
59260:         Uri uri = aURL.indexOf(':') >= 0 ? Uri.parse(aURL) : new Uri.Builder().scheme(aURL).build();
54802:         Intent intent = getIntentForActionString(aAction);
54802:         intent.setData(uri);
54802:         return getHandlersForIntent(intent);
54802:     }
54802: 
54802:     static String[] getHandlersForIntent(Intent intent) {
43601:         PackageManager pm =
43601:             GeckoApp.surfaceView.getContext().getPackageManager();
43601:         List<ResolveInfo> list = pm.queryIntentActivities(intent, 0);
48960:         int numAttr = 4;
43601:         String[] ret = new String[list.size() * numAttr];
43601:         for (int i = 0; i < list.size(); i++) {
48960:             ResolveInfo resolveInfo = list.get(i);
48960:             ret[i * numAttr] = resolveInfo.loadLabel(pm).toString();
48960:             if (resolveInfo.isDefault)
43601:                 ret[i * numAttr + 1] = "default";
43601:             else
43601:                 ret[i * numAttr + 1] = "";
48960:             ret[i * numAttr + 2] = resolveInfo.activityInfo.applicationInfo.packageName;
48960:             ret[i * numAttr + 3] = resolveInfo.activityInfo.name;
48960:         }
48960:         return ret;
48960:     }
48960: 
54802:     static Intent getIntentForActionString(String aAction) {
54802:         // Default to the view action if no other action as been specified.
54802:         if (aAction != null && aAction.length() > 0)
54802:             return new Intent(aAction);
48960:         else
54802:             return new Intent(Intent.ACTION_VIEW);
43601:     }
43601: 
63350:     static String getExtensionFromMimeType(String aMimeType) {
63350:         return MimeTypeMap.getSingleton().getExtensionFromMimeType(aMimeType);
63350:     }
63350: 
56942:     static String getMimeTypeFromExtensions(String aFileExt) {
63350:         MimeTypeMap mtm = MimeTypeMap.getSingleton();
56942:         StringTokenizer st = new StringTokenizer(aFileExt, "., ");
56942:         String type = null;
56942:         String subType = null;
56942:         while (st.hasMoreElements()) {
56942:             String ext = st.nextToken();
56942:             String mt = mtm.getMimeTypeFromExtension(ext);
56942:             if (mt == null)
56942:                 continue;
56942:             int slash = mt.indexOf('/');
56942:             String tmpType = mt.substring(0, slash);
56942:             if (!tmpType.equalsIgnoreCase(type))
56942:                 type = type == null ? tmpType : "*";
56942:             String tmpSubType = mt.substring(slash + 1);
56942:             if (!tmpSubType.equalsIgnoreCase(subType))
56942:                 subType = subType == null ? tmpSubType : "*";
56942:         }
56942:         if (type == null)
56942:             type = "*";
56942:         if (subType == null)
56942:             subType = "*";
56942:         return type + "/" + subType;
43601:     }
43601: 
54802:     static boolean openUriExternal(String aUriSpec, String aMimeType, String aPackageName,
54884:                                    String aClassName, String aAction, String aTitle) {
54802:         Intent intent = getIntentForActionString(aAction);
54802:         if (aAction.equalsIgnoreCase(Intent.ACTION_SEND)) {
54802:             intent.putExtra(Intent.EXTRA_TEXT, aUriSpec);
54884:             intent.putExtra(Intent.EXTRA_SUBJECT, aTitle);
54802:             if (aMimeType != null && aMimeType.length() > 0)
54802:                 intent.setType(aMimeType);
54802:         } else if (aMimeType.length() > 0) {
48960:             intent.setDataAndType(Uri.parse(aUriSpec), aMimeType);
54802:         } else {
72118:             Uri uri = Uri.parse(aUriSpec);
72118:             if ("sms".equals(uri.getScheme())) {
72118:                 // Have a apecial handling for the SMS, as the message body
72118:                 // is not extracted from the URI automatically
72118:                 final String query = uri.getEncodedQuery();
72118:                 if (query != null && query.length() > 0) {
72118:                     final String[] fields = query.split("&");
72118:                     boolean foundBody = false;
72118:                     String resultQuery = "";
72118:                     for (int i = 0; i < fields.length; i++) {
72118:                         final String field = fields[i];
72118:                         if (field.length() > 5 && "body=".equals(field.substring(0, 5))) {
72118:                             final String body = Uri.decode(field.substring(5));
72118:                             intent.putExtra("sms_body", body);
72118:                             foundBody = true;
72118:                         }
72118:                         else {
72118:                             resultQuery = resultQuery.concat(resultQuery.length() > 0 ? "&" + field : field);
72118:                         }
72118:                     }
72118:                     if (foundBody) {
72118:                         // Put the query without the body field back into the URI
72118:                         final String prefix = aUriSpec.substring(0, aUriSpec.indexOf('?'));
72118:                         uri = Uri.parse(resultQuery.length() > 0 ? prefix + "?" + resultQuery : prefix);
72118:                     }
72118:                 }
72118:             }
72118:             intent.setData(uri);
54802:         }
48960:         if (aPackageName.length() > 0 && aClassName.length() > 0)
48960:             intent.setClassName(aPackageName, aClassName);
48960: 
43601:         intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
43601:         try {
43601:             GeckoApp.surfaceView.getContext().startActivity(intent);
43601:             return true;
43601:         } catch(ActivityNotFoundException e) {
43601:             return false;
43601:         }
43601:     }
51539: 
63362:     static SynchronousQueue<String> sClipboardQueue =
63362:         new SynchronousQueue<String>();
83500:     private static String EMPTY_STRING = new String();
63362: 
63362:     // On some devices, access to the clipboard service needs to happen
63362:     // on a thread with a looper, so dispatch this to our looper thread
63362:     // Note: the main looper won't work because it may be blocked on the
63362:     // gecko thread, which is most likely this thread
51539:     static String getClipboardText() {
63362:         getHandler().post(new Runnable() { 
83506:             @SuppressWarnings("deprecation")
63362:             public void run() {
51539:                 Context context = GeckoApp.surfaceView.getContext();
78917:                 String text = null;
78917:                 if (android.os.Build.VERSION.SDK_INT >= 11) {
78917:                     android.content.ClipboardManager cm = (android.content.ClipboardManager)
78917:                         context.getSystemService(Context.CLIPBOARD_SERVICE);
78917:                     if (cm.hasPrimaryClip()) {
78917:                         ClipData clip = cm.getPrimaryClip();
78917:                         if (clip != null) {
78917:                             ClipData.Item item = clip.getItemAt(0);
78917:                             text = item.coerceToText(context).toString();
78917:                         }
78917:                     }
78917:                 } else {
75020:                     android.text.ClipboardManager cm = (android.text.ClipboardManager)
51539:                         context.getSystemService(Context.CLIPBOARD_SERVICE);
78917:                     if (cm.hasText())
78917:                         text = cm.getText().toString();
78917:                 }
63362:                 try {
83500:                     sClipboardQueue.put(text != null ? text : EMPTY_STRING);
63362:                 } catch (InterruptedException ie) {}
63362:             }});
63362:         try {
63377:             String ret = sClipboardQueue.take();
83500:             return (ret == EMPTY_STRING ? null : ret);
63362:         } catch (InterruptedException ie) {}
51539:         return null;
43601:     }
51539: 
63362:     static void setClipboardText(final String text) {
63362:         getHandler().post(new Runnable() { 
83506:             @SuppressWarnings("deprecation")
63362:             public void run() {
51539:                 Context context = GeckoApp.surfaceView.getContext();
78917:                 if (android.os.Build.VERSION.SDK_INT >= 11) {
78917:                     android.content.ClipboardManager cm = (android.content.ClipboardManager)
78917:                         context.getSystemService(Context.CLIPBOARD_SERVICE);
78917:                     cm.setPrimaryClip(ClipData.newPlainText("Text", text));
78917:                 } else {
75020:                     android.text.ClipboardManager cm = (android.text.ClipboardManager)
51539:                         context.getSystemService(Context.CLIPBOARD_SERVICE);
51539:                     cm.setText(text);
78917:                 }
63362:             }});
51539:     }
51723: 
54906:     public static void showAlertNotification(String aImageUrl, String aAlertTitle, String aAlertText,
54906:                                              String aAlertCookie, String aAlertName) {
51723:         Log.i("GeckoAppJava", "GeckoAppShell.showAlertNotification\n" +
54906:             "- image = '" + aImageUrl + "'\n" +
54906:             "- title = '" + aAlertTitle + "'\n" +
54906:             "- text = '" + aAlertText +"'\n" +
54906:             "- cookie = '" + aAlertCookie +"'\n" +
54906:             "- name = '" + aAlertName + "'");
51723: 
51723:         int icon = R.drawable.icon; // Just use the app icon by default
51723: 
54906:         Uri imageUri = Uri.parse(aImageUrl);
51723:         String scheme = imageUri.getScheme();
51723:         if ("drawable".equals(scheme)) {
51723:             String resource = imageUri.getSchemeSpecificPart();
54906:             resource = resource.substring(resource.lastIndexOf('/') + 1);
54906:             try {
54906:                 Class drawableClass = R.drawable.class;
54906:                 Field f = drawableClass.getField(resource);
54906:                 icon = f.getInt(null);
54906:             } catch (Exception e) {} // just means the resource doesn't exist
69081:             imageUri = null;
51539:         }
51723: 
54906:         int notificationID = aAlertName.hashCode();
51723: 
54906:         // Remove the old notification with the same ID, if any
54906:         removeNotification(notificationID);
54906: 
69081:         AlertNotification notification = 
69081:             new AlertNotification(GeckoApp.mAppContext,notificationID, icon, 
69081:                                   aAlertTitle, aAlertText, 
69081:                                   System.currentTimeMillis());
51723: 
51723:         // The intent to launch when the user clicks the expanded notification
51723:         Intent notificationIntent = new Intent(GeckoApp.ACTION_ALERT_CLICK);
51723:         notificationIntent.setClassName(GeckoApp.mAppContext,
59565:             GeckoApp.mAppContext.getPackageName() + ".NotificationHandler");
51723: 
51723:         // Put the strings into the intent as an URI "alert:<name>#<cookie>"
54906:         Uri dataUri = Uri.fromParts("alert", aAlertName, aAlertCookie);
51723:         notificationIntent.setData(dataUri);
51723: 
59285:         PendingIntent contentIntent = PendingIntent.getBroadcast(GeckoApp.mAppContext, 0, notificationIntent, 0);
54906:         notification.setLatestEventInfo(GeckoApp.mAppContext, aAlertTitle, aAlertText, contentIntent);
69081:         notification.setCustomIcon(imageUri);
51723:         // The intent to execute when the status entry is deleted by the user with the "Clear All Notifications" button
51723:         Intent clearNotificationIntent = new Intent(GeckoApp.ACTION_ALERT_CLEAR);
51723:         clearNotificationIntent.setClassName(GeckoApp.mAppContext,
59565:             GeckoApp.mAppContext.getPackageName() + ".NotificationHandler");
51723:         clearNotificationIntent.setData(dataUri);
59285:         notification.deleteIntent = PendingIntent.getBroadcast(GeckoApp.mAppContext, 0, clearNotificationIntent, 0);
51723: 
54906:         mAlertNotifications.put(notificationID, notification);
54906: 
54906:         notification.show();
54906: 
51723:         Log.i("GeckoAppJava", "Created notification ID " + notificationID);
51723:     }
51723: 
54906:     public static void alertsProgressListener_OnProgress(String aAlertName, long aProgress, long aProgressMax, String aAlertText) {
54906:         Log.i("GeckoAppJava", "GeckoAppShell.alertsProgressListener_OnProgress\n" +
54906:             "- name = '" + aAlertName +"', " +
54906:             "progress = " + aProgress +" / " + aProgressMax + ", text = '" + aAlertText + "'");
54906: 
54906:         int notificationID = aAlertName.hashCode();
54906:         AlertNotification notification = mAlertNotifications.get(notificationID);
54906:         if (notification != null)
54906:             notification.updateProgress(aAlertText, aProgress, aProgressMax);
58188: 
58188:         if (aProgress == aProgressMax) {
58188:             // Hide the notification at 100%
58188:             removeObserver(aAlertName);
58188:             removeNotification(notificationID);
58188:         }
51723:     }
51723: 
56158:     public static void alertsProgressListener_OnCancel(String aAlertName) {
56158:         Log.i("GeckoAppJava", "GeckoAppShell.alertsProgressListener_OnCancel('" + aAlertName + "'");
56158: 
56158:         removeObserver(aAlertName);
56158: 
56158:         int notificationID = aAlertName.hashCode();
56158:         removeNotification(notificationID);
56158:     }
56158: 
54906:     public static void handleNotification(String aAction, String aAlertName, String aAlertCookie) {
54906:         int notificationID = aAlertName.hashCode();
54906: 
54906:         if (GeckoApp.ACTION_ALERT_CLICK.equals(aAction)) {
54906:             Log.i("GeckoAppJava", "GeckoAppShell.handleNotification: callObserver(alertclickcallback)");
54906:             callObserver(aAlertName, "alertclickcallback", aAlertCookie);
54906: 
54906:             AlertNotification notification = mAlertNotifications.get(notificationID);
54906:             if (notification != null && notification.isProgressStyle()) {
54906:                 // When clicked, keep the notification, if it displays a progress
54906:                 return;
51723:             }
51723:         }
54906: 
54906:         callObserver(aAlertName, "alertfinished", aAlertCookie);
54906: 
54906:         removeObserver(aAlertName);
54906: 
54906:         removeNotification(notificationID);
54801:     }
54906: 
54906:     private static void removeNotification(int notificationID) {
54906:         mAlertNotifications.remove(notificationID);
54906: 
54906:         NotificationManager notificationManager = (NotificationManager)
54906:             GeckoApp.mAppContext.getSystemService(Context.NOTIFICATION_SERVICE);
54906:         notificationManager.cancel(notificationID);
54905:     }
54906: 
55134:     public static int getDpi() {
55134:         DisplayMetrics metrics = new DisplayMetrics();
55134:         GeckoApp.mAppContext.getWindowManager().getDefaultDisplay().getMetrics(metrics);
55134:         return metrics.densityDpi;
54906:     }
57134: 
57134:     public static void setFullScreen(boolean fullscreen) {
57134:         GeckoApp.mFullscreen = fullscreen;
57134: 
57134:         // force a reconfiguration to hide/show the system bar
57134:         GeckoApp.mAppContext.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
57134:         GeckoApp.mAppContext.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
57134:         GeckoApp.mAppContext.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_USER);
57134:     }
57337: 
56942:     public static String showFilePicker(String aFilters) {
56942:         return GeckoApp.mAppContext.
56942:             showFilePicker(getMimeTypeFromExtensions(aFilters));
55134:     }
57337: 
57998:     public static void performHapticFeedback(boolean aIsLongPress) {
57998:         GeckoApp.surfaceView.
57998:             performHapticFeedback(aIsLongPress ?
57998:                                   HapticFeedbackConstants.LONG_PRESS :
57998:                                   HapticFeedbackConstants.VIRTUAL_KEY);
57998:     }
57998: 
57337:     public static void showInputMethodPicker() {
57337:         InputMethodManager imm = (InputMethodManager) GeckoApp.surfaceView.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
57337:         imm.showInputMethodPicker();
56159:     }
57419: 
59571:     public static void setKeepScreenOn(final boolean on) {
59571:         GeckoApp.mAppContext.runOnUiThread(new Runnable() {
59571:             public void run() {
59571:                 GeckoApp.surfaceView.setKeepScreenOn(on);
57419:             }
59571:         });
59571:     }
60931: 
60931:     public static boolean isNetworkLinkUp() {
79687:         ConnectivityManager cm = (ConnectivityManager)
79687:             GeckoApp.mAppContext.getSystemService(Context.CONNECTIVITY_SERVICE);
79687:         NetworkInfo info = cm.getActiveNetworkInfo();
79687:         if (info == null || !info.isConnected())
60931:             return false;
60931:         return true;
59571:     }
60931: 
79687:     public static boolean isNetworkLinkKnown() {
60931:         ConnectivityManager cm = (ConnectivityManager)
60931:             GeckoApp.mAppContext.getSystemService(Context.CONNECTIVITY_SERVICE);
79687:         if (cm.getActiveNetworkInfo() == null)
79687:             return false;
79687:         return true;
60931:     }
63152: 
63152:     public static void setSelectedLocale(String localeCode) {
63152:         SharedPreferences settings =
63152:             GeckoApp.mAppContext.getPreferences(Activity.MODE_PRIVATE);
63152:         settings.edit().putString(GeckoApp.mAppContext.getPackageName() + ".locale",
63152:                                   localeCode).commit();
63152:         Locale locale;
63152:         int index;
63152:         if ((index = localeCode.indexOf('-')) != -1 ||
63152:             (index = localeCode.indexOf('_')) != -1) {
63152:             String langCode = localeCode.substring(0, index);
63152:             String countryCode = localeCode.substring(index + 1);
63152:             locale = new Locale(langCode, countryCode);
63152:         } else {
63152:             locale = new Locale(localeCode);
60931:         }
63152:         Locale.setDefault(locale);
63152: 
63152:         Resources res = GeckoApp.mAppContext.getBaseContext().getResources();
63152:         Configuration config = res.getConfiguration();
63152:         config.locale = locale;
63152:         res.updateConfiguration(config, res.getDisplayMetrics());
63152:     }
63326: 
69435:     public static int[] getSystemColors() {
69435:         // attrsAppearance[] must correspond to AndroidSystemColors structure in android/AndroidBridge.h
69435:         final int[] attrsAppearance = {
69435:             android.R.attr.textColor,
69435:             android.R.attr.textColorPrimary,
69435:             android.R.attr.textColorPrimaryInverse,
69435:             android.R.attr.textColorSecondary,
69435:             android.R.attr.textColorSecondaryInverse,
69435:             android.R.attr.textColorTertiary,
69435:             android.R.attr.textColorTertiaryInverse,
69435:             android.R.attr.textColorHighlight,
69435:             android.R.attr.colorForeground,
69435:             android.R.attr.colorBackground,
69435:             android.R.attr.panelColorForeground,
69435:             android.R.attr.panelColorBackground
69435:         };
69435: 
69435:         int[] result = new int[attrsAppearance.length];
69435: 
69435:         final ContextThemeWrapper contextThemeWrapper =
69435:             new ContextThemeWrapper(GeckoApp.mAppContext, android.R.style.TextAppearance);
69435: 
69435:         final TypedArray appearance = contextThemeWrapper.getTheme().obtainStyledAttributes(attrsAppearance);
69435: 
69435:         if (appearance != null) {
69435:             for (int i = 0; i < appearance.getIndexCount(); i++) {
69435:                 int idx = appearance.getIndex(i);
69435:                 int color = appearance.getColor(idx, 0);
69435:                 result[idx] = color;
69435:             }
69435:             appearance.recycle();
69435:         }
69435: 
69435:         return result;
69435:     }
69435: 
63326:     public static void killAnyZombies() {
63385:         GeckoProcessesVisitor visitor = new GeckoProcessesVisitor() {
63385:             public boolean callback(int pid) {
63385:                 if (pid != android.os.Process.myPid())
63326:                     android.os.Process.killProcess(pid);
63385:                 return true;
63152:             }
63385:         };
63385:             
63385:         EnumerateGeckoProcesses(visitor);
63326:     }
63326: 
63326:     public static boolean checkForGeckoProcs() {
63385: 
63385:         class GeckoPidCallback implements GeckoProcessesVisitor {
63385:             public boolean otherPidExist = false;
63385:             public boolean callback(int pid) {
63326:                 if (pid != android.os.Process.myPid()) {
63385:                     otherPidExist = true;
63385:                     return false;
63385:                 }
63326:                 return true;
63326:             }            
63326:         }
63385:         GeckoPidCallback visitor = new GeckoPidCallback();            
63385:         EnumerateGeckoProcesses(visitor);
63385:         return visitor.otherPidExist;
63326:     }
63385: 
63385:     interface GeckoProcessesVisitor{
63385:         boolean callback(int pid);
63385:     }
63385: 
63385:     static int sPidColumn = -1;
63385:     static int sUserColumn = -1;
63385:     private static void EnumerateGeckoProcesses(GeckoProcessesVisitor visiter) {
63385: 
63385:         try {
63385: 
63385:             // run ps and parse its output
63385:             java.lang.Process ps = Runtime.getRuntime().exec("ps");
63385:             BufferedReader in = new BufferedReader(new InputStreamReader(ps.getInputStream()),
63385:                                                    2048);
63385: 
63385:             String headerOutput = in.readLine();
63385: 
63385:             // figure out the column offsets.  We only care about the pid and user fields
63385:             if (sPidColumn == -1 || sUserColumn == -1) {
63385:                 StringTokenizer st = new StringTokenizer(headerOutput);
63385:                 
63385:                 int tokenSoFar = 0;
63385:                 while(st.hasMoreTokens()) {
63385:                     String next = st.nextToken();
63385:                     if (next.equalsIgnoreCase("PID"))
63385:                         sPidColumn = tokenSoFar;
63385:                     else if (next.equalsIgnoreCase("USER"))
63385:                         sUserColumn = tokenSoFar;
63385:                     tokenSoFar++;
63385:                 }
63385:             }
63385: 
63385:             // alright, the rest are process entries.
63385:             String psOutput = null;
63385:             while ((psOutput = in.readLine()) != null) {
63385:                 String[] split = psOutput.split("\\s+");
63385:                 if (split.length <= sPidColumn || split.length <= sUserColumn)
63385:                     continue;
63385:                 int uid = android.os.Process.getUidForName(split[sUserColumn]);
63385:                 if (uid == android.os.Process.myUid() &&
63385:                     !split[split.length - 1].equalsIgnoreCase("ps")) {
63385:                     int pid = Integer.parseInt(split[sPidColumn]);
63385:                     boolean keepGoing = visiter.callback(pid);
63385:                     if (keepGoing == false)
63385:                         break;
63385:                 }
63385:             }
63385:             in.close();
63385:         }
63385:         catch (Exception e) {
76836:             Log.i(LOG_FILE_NAME, "finding procs throws ",  e);
63385:         }
63326:     }
63326: 
63326:     public static void waitForAnotherGeckoProc(){
63326:         int countdown = 40;
63326:         while (!checkForGeckoProcs() &&  --countdown > 0) {
63326:             try {
63326:                 Thread.currentThread().sleep(100);
63326:             } catch (InterruptedException ie) {}
63326:         }
63326:     }
67623: 
67623:     public static void scanMedia(String aFile, String aMimeType) {
67623:         Context context = GeckoApp.surfaceView.getContext();
67623:         GeckoMediaScannerClient client = new GeckoMediaScannerClient(context, aFile, aMimeType);
63326:     }
72119: 
72119:     public static byte[] getIconForExtension(String aExt, int iconSize) {
72119:         try {
72119:             if (iconSize <= 0)
72119:                 iconSize = 16;
72119: 
72119:             if (aExt != null && aExt.length() > 1 && aExt.charAt(0) == '.')
72119:                 aExt = aExt.substring(1);
72119: 
72119:             PackageManager pm = GeckoApp.surfaceView.getContext().getPackageManager();
72119:             Drawable icon = getDrawableForExtension(pm, aExt);
72119:             if (icon == null) {
72119:                 // Use a generic icon
72119:                 icon = pm.getDefaultActivityIcon();
67623:             }
72119: 
72119:             Bitmap bitmap = ((BitmapDrawable)icon).getBitmap();
72119:             if (bitmap.getWidth() != iconSize || bitmap.getHeight() != iconSize)
72119:                 bitmap = Bitmap.createScaledBitmap(bitmap, iconSize, iconSize, true);
72119: 
72119:             ByteBuffer buf = ByteBuffer.allocate(iconSize * iconSize * 4);
72119:             bitmap.copyPixelsToBuffer(buf);
72119: 
72119:             return buf.array();
72119:         }
72119:         catch (Exception e) {
76836:             Log.i(LOG_FILE_NAME, "getIconForExtension error: ",  e);
72119:             return null;
72119:         }
72119:     }
72119: 
72119:     private static Drawable getDrawableForExtension(PackageManager pm, String aExt) {
72119:         Intent intent = new Intent(Intent.ACTION_VIEW);
72119:         MimeTypeMap mtm = MimeTypeMap.getSingleton();
72119:         String mimeType = mtm.getMimeTypeFromExtension(aExt);
72119:         if (mimeType != null && mimeType.length() > 0)
72119:             intent.setType(mimeType);
72119:         else
72119:             return null;
72119: 
72119:         List<ResolveInfo> list = pm.queryIntentActivities(intent, 0);
72119:         if (list.size() == 0)
72119:             return null;
72119: 
72119:         ResolveInfo resolveInfo = list.get(0);
72119: 
72119:         if (resolveInfo == null)
72119:             return null;
72119: 
72119:         ActivityInfo activityInfo = resolveInfo.activityInfo;
72119: 
72119:         return activityInfo.loadIcon(pm);
72119:     }
76328: 
76328:     public static boolean getShowPasswordSetting() {
76328:         try {
76328:             int showPassword =
76328:                 Settings.System.getInt(GeckoApp.mAppContext.getContentResolver(),
80170:                                        Settings.System.TEXT_SHOW_PASSWORD, 1);
76328:             return (showPassword > 0);
72119:         }
76328:         catch (Exception e) {
80170:             return true;
76328:         }
76328:     }
83537:     public static void addPluginView(View view,
83537:                                      double x, double y,
83537:                                      double w, double h)
83537:     {
78424:         Log.i("GeckoAppShell", "addPluginView:" + view + " @ x:" + x + " y:" + y + " w:" + w + " h:" + h ) ;
83537:         GeckoApp.mAppContext.addPluginView(view, x, y, w, h);
78424:     }
78424: 
83537:     public static void removePluginView(View view) {
78424:         Log.i("GeckoAppShell", "remove view:" + view);
83537:         GeckoApp.mAppContext.removePluginView(view);
78424:     }
78424: 
78424:     public static Class<?> loadPluginClass(String className, String libName) {
78424:         Log.i("GeckoAppShell", "in loadPluginClass... attempting to access className, then libName.....");
78424:         Log.i("GeckoAppShell", "className: " + className);
78424:         Log.i("GeckoAppShell", "libName: " + libName);
78424: 
78424:         try {
78424:             String[] split = libName.split("/");
78424:             String packageName = split[split.length - 3];
78424:             Log.i("GeckoAppShell", "load \"" + className + "\" from \"" + packageName + 
78424:                   "\" for \"" + libName + "\"");
78424:             Context pluginContext = 
78424:                 GeckoApp.mAppContext.createPackageContext(packageName,
78424:                                                           Context.CONTEXT_INCLUDE_CODE |
78424:                                                       Context.CONTEXT_IGNORE_SECURITY);
78424:             ClassLoader pluginCL = pluginContext.getClassLoader();
78424:             return pluginCL.loadClass(className);
78424:         } catch (java.lang.ClassNotFoundException cnfe) {
78424:             Log.i("GeckoAppShell", "class not found", cnfe);
78424:         } catch (android.content.pm.PackageManager.NameNotFoundException nnfe) {
78424:             Log.i("GeckoAppShell", "package not found", nnfe);
78424:         }
78424:         Log.e("GeckoAppShell", "couldn't find class");
78424:         return null;
78424:     }
78424: 
80358:     static HashMap<SurfaceView, SurfaceLockInfo> sSufaceMap = new HashMap<SurfaceView, SurfaceLockInfo>();
80358: 
80358:     public static void lockSurfaceANP()
78424:     {
80358:          Log.i("GeckoAppShell", "other lockSurfaceANP");
80358:     }
80358: 
80358:     public static org.mozilla.gecko.SurfaceLockInfo lockSurfaceANP(android.view.SurfaceView sview, int top, int left, int bottom, int right)
80358:     {
80358:         Log.i("GeckoAppShell", "real lockSurfaceANP " + sview + ", " + top + ",  " + left + ", " + bottom + ", " + right);
78424:         if (sview == null)
78424:             return null;
78424: 
78424:         int format = -1;
78424:         try {
78424:             Field privateFormatField = SurfaceView.class.getDeclaredField("mFormat");
78424:             privateFormatField.setAccessible(true);
78424:             format = privateFormatField.getInt(sview);
78424:         } catch (Exception e) {
78424:             Log.i("GeckoAppShell", "mFormat is not a field of sview: ", e);
78424:         }
78424: 
78424:         int n = 0;
80358:         if (format == PixelFormat.RGB_565)
78424:             n = 2;
80358:         else if (format == PixelFormat.RGBA_8888)
78424:             n = 4;
80358: 
80358:         if (n == 0)
78424:             return null;
80358: 
80358:         SurfaceLockInfo info = sSufaceMap.get(sview);
80358:         if (info == null) {
80358:             info = new SurfaceLockInfo();
80358:             sSufaceMap.put(sview, info);
78424:         }
78424: 
80358:         Rect r = new Rect(left, top, right, bottom);
78424: 
80358:         info.canvas = sview.getHolder().lockCanvas(r);
80358:         int bufSizeRequired = info.canvas.getWidth() * info.canvas.getHeight() * n;
80358:         Log.i("GeckoAppShell", "lockSurfaceANP - bufSizeRequired: " + n + " " + info.canvas.getHeight() + " " + info.canvas.getWidth());
80358: 
80358:         if (info.width != info.canvas.getWidth() || info.height != info.canvas.getHeight() || info.buffer == null || info.buffer.capacity() < bufSizeRequired) {
80358:             info.width = info.canvas.getWidth();
80358:             info.height = info.canvas.getHeight();
80358: 
80358:             // XXX Bitmaps instead of ByteBuffer
80358:             info.buffer = ByteBuffer.allocateDirect(bufSizeRequired);  //leak
80358:             Log.i("GeckoAppShell", "!!!!!!!!!!!  lockSurfaceANP - Allocating buffer! " + bufSizeRequired);
80358: 
80358:         }
80358: 
80358:         info.canvas.drawColor(Color.WHITE, PorterDuff.Mode.CLEAR);
80358: 
78424:         info.format = format;
80358:         info.dirtyTop = top;
80358:         info.dirtyBottom = bottom;
80358:         info.dirtyLeft = left;
80358:         info.dirtyRight = right;
78424: 
78424:         return info;
78424:     }
78424: 
80358:     public static void unlockSurfaceANP(SurfaceView sview) {
80358:         SurfaceLockInfo info = sSufaceMap.get(sview);
80358: 
80358:         int n = 0;
80358:         Bitmap.Config config;
80358:         if (info.format == PixelFormat.RGB_565) {
80358:             n = 2;
80358:             config = Bitmap.Config.RGB_565;
80358:         } else {
80358:             n = 4;
80358:             config = Bitmap.Config.ARGB_8888;
80358:         }
80358: 
80358:         Log.i("GeckoAppShell", "unlockSurfaceANP: " + (info.width * info.height * n));
80358: 
80358:         Bitmap bm = Bitmap.createBitmap(info.width, info.height, config);
80358:         bm.copyPixelsFromBuffer(info.buffer);
80358:         info.canvas.drawBitmap(bm, 0, 0, null);
80358:         sview.getHolder().unlockCanvasAndPost(info.canvas);
80358:     }
80358: 
80358:     public static Class getSurfaceLockInfoClass() {
80358:         Log.i("GeckoAppShell", "class name: " + SurfaceLockInfo.class.getName());
80358:         return SurfaceLockInfo.class;
80358:     }
80358: 
80358:     public static Method getSurfaceLockMethod() {
80358:         Method[] m = GeckoAppShell.class.getMethods();
80358:         for (int i = 0; i < m.length; i++) {
80358:             if (m[i].getName().equals("lockSurfaceANP"))
80358:                 return m[i];
80358:         }
80358:         return null;
78424:     }
78424: 
78424:     static native void executeNextRunnable();
78424: 
78424:     static class GeckoRunnableCallback implements Runnable {
78424:         public void run() {
78424:             Log.i("GeckoShell", "run GeckoRunnableCallback");
78424:             GeckoAppShell.executeNextRunnable();
78424:         }
78424:     }
78424: 
78424:     public static void postToJavaThread(boolean mainThread) {
78424:         Log.i("GeckoShell", "post to " + (mainThread ? "main " : "") + "java thread");
78424:         getMainHandler().post(new GeckoRunnableCallback());
78424:     }
78958:     
78958:     public static android.hardware.Camera sCamera = null;
78958:     
78958:     static native void cameraCallbackBridge(byte[] data);
78958: 
78958:     static int kPreferedFps = 25;
78958:     static byte[] sCameraBuffer = null;
78958: 
78958:     static int[] initCamera(String aContentType, int aCamera, int aWidth, int aHeight) {
78958:         Log.i("GeckoAppJava", "initCamera(" + aContentType + ", " + aWidth + "x" + aHeight + ") on thread " + Thread.currentThread().getId());
78958: 
78958:         // [0] = 0|1 (failure/success)
78958:         // [1] = width
78958:         // [2] = height
78958:         // [3] = fps
78958:         int[] result = new int[4];
78958:         result[0] = 0;
78958: 
78958:         if (Build.VERSION.SDK_INT >= 9) {
78958:             if (android.hardware.Camera.getNumberOfCameras() == 0)
78958:                 return result;
78424:         }
78958: 
78958:         try {
79766:             // no front/back camera before API level 9
79766:             if (Build.VERSION.SDK_INT >= 9)
78958:                 sCamera = android.hardware.Camera.open(aCamera);
79766:             else
79766:                 sCamera = android.hardware.Camera.open();
79766: 
78958:             android.hardware.Camera.Parameters params = sCamera.getParameters();
78958:             params.setPreviewFormat(ImageFormat.NV21);
78958: 
78958:             // use the preview fps closest to 25 fps.
78958:             int fpsDelta = 1000;
78958:             try {
78958:                 Iterator<Integer> it = params.getSupportedPreviewFrameRates().iterator();
78958:                 while (it.hasNext()) {
78958:                     int nFps = it.next();
78958:                     if (Math.abs(nFps - kPreferedFps) < fpsDelta) {
78958:                         fpsDelta = Math.abs(nFps - kPreferedFps);
78958:                         params.setPreviewFrameRate(nFps);
78958:                     }
78958:                 }
78958:             } catch(Exception e) {
78958:                 params.setPreviewFrameRate(kPreferedFps);
78958:             }
78958: 
78958:             // set up the closest preview size available
78958:             Iterator<android.hardware.Camera.Size> sit = params.getSupportedPreviewSizes().iterator();
78958:             int sizeDelta = 10000000;
78958:             int bufferSize = 0;
78958:             while (sit.hasNext()) {
78958:                 android.hardware.Camera.Size size = sit.next();
78958:                 if (Math.abs(size.width * size.height - aWidth * aHeight) < sizeDelta) {
78958:                     sizeDelta = Math.abs(size.width * size.height - aWidth * aHeight);
78958:                     params.setPreviewSize(size.width, size.height);
78958:                     bufferSize = size.width * size.height;
78958:                 }
78958:             }
78958: 
80216:             try {
80216:                 sCamera.setPreviewDisplay(GeckoApp.cameraView.getHolder());
80216:             } catch(IOException e) {
80216:                 Log.e("GeckoAppJava", "Error setPreviewDisplay:", e);
80216:             } catch(RuntimeException e) {
80216:                 Log.e("GeckoAppJava", "Error setPreviewDisplay:", e);
80216:             }
80216: 
78958:             sCamera.setParameters(params);
78958:             sCameraBuffer = new byte[(bufferSize * 12) / 8];
78958:             sCamera.addCallbackBuffer(sCameraBuffer);
78958:             sCamera.setPreviewCallbackWithBuffer(new android.hardware.Camera.PreviewCallback() {
78958:                 public void onPreviewFrame(byte[] data, android.hardware.Camera camera) {
78958:                     cameraCallbackBridge(data);
80166:                     if (sCamera != null)
78958:                         sCamera.addCallbackBuffer(sCameraBuffer);
78958:                 }
78958:             });
78958:             sCamera.startPreview();
78958:             params = sCamera.getParameters();
78958:             Log.i("GeckoAppJava", "Camera: " + params.getPreviewSize().width + "x" + params.getPreviewSize().height +
78958:                   " @ " + params.getPreviewFrameRate() + "fps. format is " + params.getPreviewFormat());
78958:             result[0] = 1;
78958:             result[1] = params.getPreviewSize().width;
78958:             result[2] = params.getPreviewSize().height;
78958:             result[3] = params.getPreviewFrameRate();
78958: 
78958:             Log.i("GeckoAppJava", "Camera preview started");
78958:         } catch(RuntimeException e) {
78958:             Log.e("GeckoAppJava", "initCamera RuntimeException : ", e);
78958:             result[0] = result[1] = result[2] = result[3] = 0;
78958:         }
78958:         return result;
78958:     }
78958: 
78958:     static synchronized void closeCamera() {
78958:         Log.i("GeckoAppJava", "closeCamera() on thread " + Thread.currentThread().getId());
78958:         if (sCamera != null) {
78958:             sCamera.stopPreview();
78958:             sCamera.release();
78958:             sCamera = null;
78958:             sCameraBuffer = null;
78958:         }
78958:     }
83485: 
83485:     public static void handleGeckoMessage(String message) {
83485:         //        
83485:         //        {"gecko": {
83485:         //                "type": "value",
83485:         //                "event_specific": "value",
83485:         //                ....
83485:         try {
83485:             JSONObject json = new JSONObject(message);
83485:             JSONObject geckoObject = json.getJSONObject("gecko");
83485:             String type = geckoObject.getString("type");
83485: 
83485:             if (type.equals("DOMContentLoaded")) {
83541:                 final int tabId = geckoObject.getInt("tabID");
83485:                 final String uri = geckoObject.getString("uri");
83485:                 final String title = geckoObject.getString("title");
83485:                 final CharSequence titleText = title;
83541:                 GeckoApp.mAppContext.handleContentLoaded(tabId, uri, title);
83503:                 Log.i("GeckoShell", "URI - " + uri + ", title - " + title);
83532:             } else if (type.equals("DOMTitleChanged")) {
83541:                 final int tabId = geckoObject.getInt("tabID");
83532:                 final String title = geckoObject.getString("title");
83532:                 final CharSequence titleText = title;
83541:                 GeckoApp.mAppContext.handleTitleChanged(tabId, title);
83532:                 Log.i("GeckoShell", "title - " + title);
83532:             } else if (type.equals("DOMLinkAdded")) {
83532:                 final String rel = geckoObject.getString("rel");
83532:                 final String href = geckoObject.getString("href");
83532:                 Log.i("GeckoShell", "link rel - " + rel + ", href - " + href);
83536:                 GeckoApp.mAppContext.handleLinkAdded(rel, href);
83503:             } else if (type.equals("log")) {
83485:                 // generic log listener
83485:                 final String msg = geckoObject.getString("msg");
83485:                 Log.i("GeckoShell", "Log: " + msg);
83503:             } else if (type.equals("onLocationChange")) {
83541:                 final int tabId = geckoObject.getInt("tabID");
83485:                 final String uri = geckoObject.getString("uri");
83485:                 Log.i("GeckoShell", "URI - " + uri);
83541:                 GeckoApp.mAppContext.handleLocationChange(tabId, uri);
83503:             } else if (type.equals("onStateChange")) {
83541:                 final int tabId = geckoObject.getInt("tabID");
83503:                 int state = geckoObject.getInt("state");
83503:                 Log.i("GeckoShell", "State - " + state);
83511:                 if ((state & WPL_STATE_IS_DOCUMENT) != 0) {
83503:                     if ((state & WPL_STATE_START) != 0) {
83503:                         Log.i("GeckoShell", "Got a document start");
83541:                         GeckoApp.mAppContext.handleDocumentStart(tabId);
83536:                     } else if ((state & WPL_STATE_STOP) != 0) {
83511:                         Log.i("GeckoShell", "Got a document stop");
83541:                         GeckoApp.mAppContext.handleDocumentStop(tabId);
83511:                     }
83503:                 }
83503:             } else if (type.equals("onProgressChange")) {
83541:                 final int tabId = geckoObject.getInt("tabID");
83485:                 final int current = geckoObject.getInt("current");
83485:                 final int total = geckoObject.getInt("total");
83485: 
83541:                 GeckoApp.mAppContext.handleProgressChange(tabId, current, total);
83485:                 Log.i("GeckoShell", "progress - " + current + "/" + total);
83519:             } else if (type.equals("onCameraCapture")) {
83519:                 //GeckoApp.mAppContext.doCameraCapture(geckoObject.getString("path"));
83519:                 GeckoApp.mAppContext.doCameraCapture();
83541:             } else if (type.equals("onCreateTab")) {
83541:                 Log.i("GeckoShell", "Created a new tab");
83541:                 int tabId = geckoObject.getInt("tabID");
83541:                 String uri = geckoObject.getString("uri");
83541:                 Tabs.getInstance().addTab(tabId, uri);
83485:             }
83485:         } catch (Exception e) {
83485:             Log.i("GeckoShell", "handleGeckoMessage throws " + e);
83485:         }
83485:     }
83485: }
