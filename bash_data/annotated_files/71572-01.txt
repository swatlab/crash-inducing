32195: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
42402: /* ***** BEGIN LICENSE BLOCK *****
42402:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
42402:  *
42402:  * The contents of this file are subject to the Mozilla Public License Version
42402:  * 1.1 (the "License"); you may not use this file except in compliance with
42402:  * the License. You may obtain a copy of the License at
42402:  * http://www.mozilla.org/MPL/
42402:  *
42402:  * Software distributed under the License is distributed on an "AS IS" basis,
42402:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
42402:  * for the specific language governing rights and limitations under the
42402:  * License.
42402:  *
42402:  * The Original Code is mozilla.org code.
42402:  *
42402:  * The Initial Developer of the Original Code is
42402:  *   Mozilla Corporation.
42402:  * Portions created by the Initial Developer are Copyright (C) 2009
42402:  * the Initial Developer. All Rights Reserved.
42402:  *
42402:  * Contributor(s):
42402:  *   Vladimir Vukicevic <vladimir@pobox.com> (original author)
42402:  *   Mark Steele <mwsteele@gmail.com>
42402:  *
42402:  * Alternatively, the contents of this file may be used under the terms of
42402:  * either the GNU General Public License Version 2 or later (the "GPL"), or
42402:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
42402:  * in which case the provisions of the GPL or the LGPL are applicable instead
42402:  * of those above. If you wish to allow use of your version of this file only
42402:  * under the terms of either the GPL or the LGPL, and not to allow others to
42402:  * use your version of this file under the terms of the MPL, indicate your
42402:  * decision by deleting the provisions above and replace them with the notice
42402:  * and other provisions required by the GPL or the LGPL. If you do not delete
42402:  * the provisions above, a recipient may use your version of this file under
42402:  * the terms of any one of the MPL, the GPL or the LGPL.
42402:  *
42402:  * ***** END LICENSE BLOCK ***** */
42402: 
32195: #include "WebGLContext.h"
32195: 
32195: #include "nsIConsoleService.h"
32195: #include "nsIPrefService.h"
32195: #include "nsServiceManagerUtils.h"
32195: #include "nsIClassInfoImpl.h"
32195: #include "nsContentUtils.h"
34453: #include "nsIXPConnect.h"
32835: #include "nsDOMError.h"
54216: #include "nsIGfxInfo.h"
32195: 
57631: #include "nsIPropertyBag.h"
57631: #include "nsIVariant.h"
57631: 
57632: #include "imgIEncoder.h"
57632: 
32195: #include "gfxContext.h"
32195: #include "gfxPattern.h"
46990: #include "gfxUtils.h"
32195: 
34453: #include "CanvasUtils.h"
64542: #include "nsDisplayList.h"
34453: 
42402: #include "GLContextProvider.h"
42402: 
63285: #include "gfxCrashReporterUtils.h"
63285: 
50430: #include "nsSVGEffects.h"
50430: 
49076: #include "prenv.h"
49076: 
32195: using namespace mozilla;
42403: using namespace mozilla::gl;
51950: using namespace mozilla::layers;
32195: 
57635: nsresult NS_NewCanvasRenderingContextWebGL(nsIDOMWebGLRenderingContext** aResult);
32195: 
32195: nsresult
57635: NS_NewCanvasRenderingContextWebGL(nsIDOMWebGLRenderingContext** aResult)
32195: {
57635:     nsIDOMWebGLRenderingContext* ctx = new WebGLContext();
32195:     if (!ctx)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     NS_ADDREF(*aResult = ctx);
32195:     return NS_OK;
32195: }
32195: 
32195: WebGLContext::WebGLContext()
42402:     : mCanvasElement(nsnull),
70164:       gl(nsnull)
32195: {
47653:     mWidth = mHeight = 0;
47653:     mGeneration = 0;
47653:     mInvalidated = PR_FALSE;
47731:     mResetLayer = PR_TRUE;
53695:     mVerbose = PR_FALSE;
57631:     mOptionsFrozen = PR_FALSE;
47653: 
47653:     mActiveTexture = 0;
47653:     mSynthesizedGLError = LOCAL_GL_NO_ERROR;
47653:     mPixelStoreFlipY = PR_FALSE;
47653:     mPixelStorePremultiplyAlpha = PR_FALSE;
58672:     mPixelStoreColorspaceConversion = BROWSER_DEFAULT_WEBGL;
47653: 
50998:     mShaderValidation = PR_TRUE;
47653: 
32195:     mMapBuffers.Init();
32195:     mMapTextures.Init();
32195:     mMapPrograms.Init();
32195:     mMapShaders.Init();
32195:     mMapFramebuffers.Init();
32195:     mMapRenderbuffers.Init();
51422: 
51422:     mBlackTexturesAreInitialized = PR_FALSE;
51422:     mFakeBlackStatus = DoNotNeedFakeBlack;
51898: 
51898:     mVertexAttrib0Vector[0] = 0;
51898:     mVertexAttrib0Vector[1] = 0;
51898:     mVertexAttrib0Vector[2] = 0;
51898:     mVertexAttrib0Vector[3] = 1;
63064:     mFakeVertexAttrib0BufferObjectVector[0] = 0;
63064:     mFakeVertexAttrib0BufferObjectVector[1] = 0;
63064:     mFakeVertexAttrib0BufferObjectVector[2] = 0;
63064:     mFakeVertexAttrib0BufferObjectVector[3] = 1;
63064:     mFakeVertexAttrib0BufferObjectSize = 0;
63064:     mFakeVertexAttrib0BufferObject = 0;
63064:     mFakeVertexAttrib0BufferStatus = VertexAttrib0Status::Default;
70166: 
70166:     // these are de default values, see 6.2 State tables in the OpenGL ES 2.0.25 spec
70166:     mColorWriteMask[0] = 1;
70166:     mColorWriteMask[1] = 1;
70166:     mColorWriteMask[2] = 1;
70166:     mColorWriteMask[3] = 1;
70166:     mDepthWriteMask = 1;
70166:     mColorClearValue[0] = 0.f;
70166:     mColorClearValue[1] = 0.f;
70166:     mColorClearValue[2] = 0.f;
70166:     mColorClearValue[3] = 0.f;
70166:     mDepthClearValue = 1.f;
70166:     mStencilClearValue = 0;
70170:     mStencilRefFront = 0;
70170:     mStencilRefBack = 0;
70170:     mStencilValueMaskFront = 0xffffffff;
70170:     mStencilValueMaskBack  = 0xffffffff;
70170:     mStencilWriteMaskFront = 0xffffffff;
70170:     mStencilWriteMaskBack  = 0xffffffff;
70170: 
70166:     mScissorTestEnabled = 0;
70166:     mDitherEnabled = 1;
70168:     mBackbufferClearingStatus = BackbufferClearingStatus::NotClearedSinceLastPresented;
32195: }
32195: 
32195: WebGLContext::~WebGLContext()
32195: {
47910:     DestroyResourcesAndContext();
47910: }
47910: 
47910: static PLDHashOperator
47910: DeleteTextureFunction(const PRUint32& aKey, WebGLTexture *aValue, void *aData)
47910: {
47910:     gl::GLContext *gl = (gl::GLContext *) aData;
47910:     NS_ASSERTION(!aValue->Deleted(), "Texture is still in mMapTextures, but is deleted?");
47910:     GLuint name = aValue->GLName();
47910:     gl->fDeleteTextures(1, &name);
47910:     aValue->Delete();
47910:     return PL_DHASH_NEXT;
47910: }
47910: 
47910: static PLDHashOperator
47910: DeleteBufferFunction(const PRUint32& aKey, WebGLBuffer *aValue, void *aData)
47910: {
47910:     gl::GLContext *gl = (gl::GLContext *) aData;
47910:     NS_ASSERTION(!aValue->Deleted(), "Buffer is still in mMapBuffers, but is deleted?");
47910:     GLuint name = aValue->GLName();
47910:     gl->fDeleteBuffers(1, &name);
47910:     aValue->Delete();
47910:     return PL_DHASH_NEXT;
47910: }
47910: 
47910: static PLDHashOperator
47910: DeleteFramebufferFunction(const PRUint32& aKey, WebGLFramebuffer *aValue, void *aData)
47910: {
47910:     gl::GLContext *gl = (gl::GLContext *) aData;
47910:     NS_ASSERTION(!aValue->Deleted(), "Framebuffer is still in mMapFramebuffers, but is deleted?");
47910:     GLuint name = aValue->GLName();
47910:     gl->fDeleteFramebuffers(1, &name);
47910:     aValue->Delete();
47910:     return PL_DHASH_NEXT;
47910: }
47910: 
47910: static PLDHashOperator
47910: DeleteRenderbufferFunction(const PRUint32& aKey, WebGLRenderbuffer *aValue, void *aData)
47910: {
47910:     gl::GLContext *gl = (gl::GLContext *) aData;
47910:     NS_ASSERTION(!aValue->Deleted(), "Renderbuffer is still in mMapRenderbuffers, but is deleted?");
47910:     GLuint name = aValue->GLName();
47910:     gl->fDeleteRenderbuffers(1, &name);
47910:     aValue->Delete();
47910:     return PL_DHASH_NEXT;
47910: }
47910: 
47910: static PLDHashOperator
47910: DeleteProgramFunction(const PRUint32& aKey, WebGLProgram *aValue, void *aData)
47910: {
47910:     gl::GLContext *gl = (gl::GLContext *) aData;
47910:     NS_ASSERTION(!aValue->Deleted(), "Program is still in mMapPrograms, but is deleted?");
47910:     GLuint name = aValue->GLName();
47910:     gl->fDeleteProgram(name);
47910:     aValue->Delete();
47910:     return PL_DHASH_NEXT;
47910: }
47910: 
47910: static PLDHashOperator
47910: DeleteShaderFunction(const PRUint32& aKey, WebGLShader *aValue, void *aData)
47910: {
47910:     gl::GLContext *gl = (gl::GLContext *) aData;
47910:     NS_ASSERTION(!aValue->Deleted(), "Shader is still in mMapShaders, but is deleted?");
47910:     GLuint name = aValue->GLName();
47910:     gl->fDeleteShader(name);
47910:     aValue->Delete();
47910:     return PL_DHASH_NEXT;
47910: }
47910: 
47910: void
47910: WebGLContext::DestroyResourcesAndContext()
47910: {
47910:     if (!gl)
47910:         return;
47910: 
47910:     gl->MakeCurrent();
47910: 
47910:     mMapTextures.EnumerateRead(DeleteTextureFunction, gl);
47910:     mMapTextures.Clear();
47910: 
47910:     mMapBuffers.EnumerateRead(DeleteBufferFunction, gl);
47910:     mMapBuffers.Clear();
47910: 
47910:     mMapPrograms.EnumerateRead(DeleteProgramFunction, gl);
47910:     mMapPrograms.Clear();
47910: 
47910:     mMapShaders.EnumerateRead(DeleteShaderFunction, gl);
47910:     mMapShaders.Clear();
47910: 
47910:     mMapFramebuffers.EnumerateRead(DeleteFramebufferFunction, gl);
47910:     mMapFramebuffers.Clear();
47910: 
47910:     mMapRenderbuffers.EnumerateRead(DeleteRenderbufferFunction, gl);
47910:     mMapRenderbuffers.Clear();
47910: 
51422:     if (mBlackTexturesAreInitialized) {
51422:         gl->fDeleteTextures(1, &mBlackTexture2D);
51422:         gl->fDeleteTextures(1, &mBlackTextureCubeMap);
51422:         mBlackTexturesAreInitialized = PR_FALSE;
51422:     }
51422: 
63064:     if (mFakeVertexAttrib0BufferObject) {
63064:         gl->fDeleteBuffers(1, &mFakeVertexAttrib0BufferObject);
63064:     }
63064: 
47910:     // We just got rid of everything, so the context had better
47910:     // have been going away.
53695: #ifdef DEBUG
47910:     printf_stderr("--- WebGL context destroyed: %p\n", gl.get());
53695: #endif
47910: 
47910:     gl = nsnull;
32195: }
32195: 
32195: void
32195: WebGLContext::Invalidate()
32195: {
64542:     if (mInvalidated)
64542:         return;
64542: 
32195:     if (!mCanvasElement)
32195:         return;
32195: 
50430:     nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
50430: 
47731:     mInvalidated = PR_TRUE;
64542:     HTMLCanvasElement()->InvalidateCanvasContent(nsnull);
39587: }
39587: 
43304: /* readonly attribute nsIDOMHTMLCanvasElement canvas; */
43304: NS_IMETHODIMP
43304: WebGLContext::GetCanvas(nsIDOMHTMLCanvasElement **canvas)
43304: {
43655:     NS_IF_ADDREF(*canvas = mCanvasElement);
43304: 
43304:     return NS_OK;
32195: }
32195: 
32195: //
32195: // nsICanvasRenderingContextInternal
32195: //
32195: 
32195: NS_IMETHODIMP
42402: WebGLContext::SetCanvasElement(nsHTMLCanvasElement* aParentCanvas)
32195: {
42402:     mCanvasElement = aParentCanvas;
32195: 
32195:     return NS_OK;
32195: }
32195: 
57631: static bool
57631: GetBoolFromPropertyBag(nsIPropertyBag *bag, const char *propName, bool *boolResult)
57631: {
57631:     nsCOMPtr<nsIVariant> vv;
57631:     PRBool bv;
57631: 
57631:     nsresult rv = bag->GetProperty(NS_ConvertASCIItoUTF16(propName), getter_AddRefs(vv));
57631:     if (NS_FAILED(rv) || !vv)
57631:         return false;
57631: 
57631:     rv = vv->GetAsBool(&bv);
57631:     if (NS_FAILED(rv))
57631:         return false;
57631: 
57631:     *boolResult = bv ? true : false;
57631:     return true;
57631: }
57631: 
57631: NS_IMETHODIMP
57631: WebGLContext::SetContextOptions(nsIPropertyBag *aOptions)
57631: {
57631:     if (!aOptions)
57631:         return NS_OK;
57631: 
57631:     WebGLContextOptions newOpts;
57631: 
70165:     GetBoolFromPropertyBag(aOptions, "stencil", &newOpts.stencil);
70165:     GetBoolFromPropertyBag(aOptions, "depth", &newOpts.depth);
70165:     GetBoolFromPropertyBag(aOptions, "alpha", &newOpts.alpha);
70165:     GetBoolFromPropertyBag(aOptions, "premultipliedAlpha", &newOpts.premultipliedAlpha);
70165:     GetBoolFromPropertyBag(aOptions, "antialias", &newOpts.antialias);
70165:     GetBoolFromPropertyBag(aOptions, "preserveDrawingBuffer", &newOpts.preserveDrawingBuffer);
57631: 
57631:     // enforce that if stencil is specified, we also give back depth
57631:     newOpts.depth |= newOpts.stencil;
57631: 
58583: #if 0
70165:     LogMessage("aaHint: %d stencil: %d depth: %d alpha: %d premult: %d preserve: %d\n",
70165:                newOpts.antialias ? 1 : 0,
57631:                newOpts.stencil ? 1 : 0,
57631:                newOpts.depth ? 1 : 0,
57631:                newOpts.alpha ? 1 : 0,
70165:                newOpts.premultipliedAlpha ? 1 : 0,
70165:                newOpts.preserveDrawingBuffer ? 1 : 0);
58583: #endif
57631: 
57631:     if (mOptionsFrozen && newOpts != mOptions) {
57631:         // Error if the options are already frozen, and the ones that were asked for
57631:         // aren't the same as what they were originally.
57631:         return NS_ERROR_FAILURE;
57631:     }
57631: 
57631:     mOptions = newOpts;
57631:     return NS_OK;
57631: }
57631: 
32195: NS_IMETHODIMP
32195: WebGLContext::SetDimensions(PRInt32 width, PRInt32 height)
32195: {
71572:     /*** early success return cases ***/
71572:   
64542:     if (mCanvasElement) {
64542:         HTMLCanvasElement()->InvalidateCanvas();
64542:     }
64542: 
69417:     if (gl && mWidth == width && mHeight == height)
47910:         return NS_OK;
47910: 
70071:     // Zero-sized surfaces can cause problems.
70071:     if (width == 0 || height == 0) {
70071:         width = 1;
70071:         height = 1;
70071:     }
70071: 
47910:     // If we already have a gl context, then we just need to resize
47910:     // FB0.
47910:     if (gl &&
47910:         gl->ResizeOffscreen(gfxIntSize(width, height)))
47910:     {
47910:         // everything's good, we're done here
47910:         mWidth = width;
47910:         mHeight = height;
48310:         mResetLayer = PR_TRUE;
47910:         return NS_OK;
47910:     }
47910: 
71572:     /*** end of early success return cases ***/
71572: 
69416:     ScopedGfxFeatureReporter reporter("WebGL");
69416: 
71572:     // At this point we know that the old context is not going to survive, even though we still don't
71572:     // know if creating the new context will succeed.
71572:     DestroyResourcesAndContext();
71572: 
71572:     // Get some prefs for some preferred/overriden things
71572:     nsCOMPtr<nsIPrefBranch> prefService = do_GetService(NS_PREFSERVICE_CONTRACTID);
71572:     NS_ENSURE_TRUE(prefService != nsnull, NS_ERROR_FAILURE);
71572: 
71572:     PRBool forceOSMesa = PR_FALSE;
71572:     PRBool preferEGL = PR_FALSE;
71572:     PRBool preferOpenGL = PR_FALSE;
71572:     PRBool forceEnabled = PR_FALSE;
71572:     PRBool disabled = PR_FALSE;
71572:     PRBool verbose = PR_FALSE;
71572: 
71572:     prefService->GetBoolPref("webgl.force_osmesa", &forceOSMesa);
71572:     prefService->GetBoolPref("webgl.prefer-egl", &preferEGL);
71572:     prefService->GetBoolPref("webgl.prefer-native-gl", &preferOpenGL);
71572:     prefService->GetBoolPref("webgl.force-enabled", &forceEnabled);
71572:     prefService->GetBoolPref("webgl.disabled", &disabled);
71572:     prefService->GetBoolPref("webgl.verbose", &verbose);
71572: 
71572:     if (disabled)
71572:         return NS_ERROR_FAILURE;
71572: 
71572:     mVerbose = verbose;
71572: 
47910:     // We're going to create an entirely new context.  If our
47910:     // generation is not 0 right now (that is, if this isn't the first
47910:     // context we're creating), we may have to dispatch a context lost
47910:     // event.
47910: 
43099:     // If incrementing the generation would cause overflow,
43099:     // don't allow it.  Allowing this would allow us to use
43099:     // resource handles created from older context generations.
47204:     if (!(mGeneration+1).valid())
47204:         return NS_ERROR_FAILURE; // exit without changing the value of mGeneration
43099: 
47907:     gl::ContextFormat format(gl::ContextFormat::BasicRGBA32);
57631:     if (mOptions.depth) {
57631:         format.depth = 24;
57631:         format.minDepth = 16;
57631:     }
57631: 
57631:     if (mOptions.stencil) {
57631:         format.stencil = 8;
57631:         format.minStencil = 8;
57631:     }
57631: 
57631:     if (!mOptions.alpha) {
57631:         // Select 565; we won't/shouldn't hit this on the desktop,
57631:         // but let mobile know we're ok with it.
57631:         format.red = 5;
57631:         format.green = 6;
57631:         format.blue = 5;
57631: 
57631:         format.alpha = 0;
57631:         format.minAlpha = 0;
57631:     }
42403: 
58583:     if (PR_GetEnv("MOZ_WEBGL_PREFER_EGL")) {
58583:         preferEGL = PR_TRUE;
58583:     }
51417: 
55263:     // Ask GfxInfo about what we should use
54216:     PRBool useOpenGL = PR_TRUE;
54216:     PRBool useANGLE = PR_TRUE;
54216: 
54216:     nsCOMPtr<nsIGfxInfo> gfxInfo = do_GetService("@mozilla.org/gfx/info;1");
61566:     if (gfxInfo && !forceEnabled) {
54216:         PRInt32 status;
54216:         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_WEBGL_OPENGL, &status))) {
61297:             if (status != nsIGfxInfo::FEATURE_NO_INFO) {
54216:                 useOpenGL = PR_FALSE;
54216:             }
54216:         }
54216:         if (NS_SUCCEEDED(gfxInfo->GetFeatureStatus(nsIGfxInfo::FEATURE_WEBGL_ANGLE, &status))) {
61297:             if (status != nsIGfxInfo::FEATURE_NO_INFO) {
54216:                 useANGLE = PR_FALSE;
54216:             }
54216:         }
54216:     }
54216: 
58583:     // allow forcing GL and not EGL/ANGLE
58583:     if (PR_GetEnv("MOZ_WEBGL_FORCE_OPENGL")) {
58583:         preferEGL = PR_FALSE;
58583:         useANGLE = PR_FALSE;
58583:         useOpenGL = PR_TRUE;
58583:     }
58583: 
55263:     // if we're forcing osmesa, do it first
55263:     if (forceOSMesa) {
55263:         gl = gl::GLContextProviderOSMesa::CreateOffscreen(gfxIntSize(width, height), format);
55263:         if (!gl || !InitAndValidateGL()) {
56955:             LogMessage("OSMesa forced, but creating context failed -- aborting!");
55263:             return NS_ERROR_FAILURE;
55263:         }
56955:         LogMessage("Using software rendering via OSMesa (THIS WILL BE SLOW)");
55263:     }
55263: 
49076: #ifdef XP_WIN
58583:     // if we want EGL, try it now
58583:     if (!gl && (preferEGL || useANGLE) && !preferOpenGL) {
49076:         gl = gl::GLContextProviderEGL::CreateOffscreen(gfxIntSize(width, height), format);
49076:         if (gl && !InitAndValidateGL()) {
49076:             gl = nsnull;
49076:         }
49076:     }
49076: 
49076:     // if it failed, then try the default provider, whatever that is
54216:     if (!gl && useOpenGL) {
47910:         gl = gl::GLContextProvider::CreateOffscreen(gfxIntSize(width, height), format);
49076:         if (gl && !InitAndValidateGL()) {
49076:             gl = nsnull;
49076:         }
49076:     }
49076: #else
49076:     // other platforms just use whatever the default is
54216:     if (!gl && useOpenGL) {
49076:         gl = gl::GLContextProvider::CreateOffscreen(gfxIntSize(width, height), format);
49076:         if (gl && !InitAndValidateGL()) {
49076:             gl = nsnull;
49076:         }
49076:     }
49076: #endif
49076: 
56957:     // finally, try OSMesa
56957:     if (!gl) {
56957:         gl = gl::GLContextProviderOSMesa::CreateOffscreen(gfxIntSize(width, height), format);
56957:         if (!gl || !InitAndValidateGL()) {
56957:             gl = nsnull;
56957:         } else {
56957:             LogMessage("Using software rendering via OSMesa (THIS WILL BE SLOW)");
56957:         }
56957:     }
56957: 
49076:     if (!gl) {
56955:         LogMessage("Can't get a usable WebGL context");
49076:         return NS_ERROR_FAILURE;
49076:     }
47910: 
53695: #ifdef DEBUG
47910:     printf_stderr ("--- WebGL context created: %p\n", gl.get());
53695: #endif
42402: 
39587:     mWidth = width;
39587:     mHeight = height;
47731:     mResetLayer = PR_TRUE;
57631:     mOptionsFrozen = PR_TRUE;
39587: 
43099:     // increment the generation number
47204:     ++mGeneration;
43099: 
47910: #if 0
47910:     if (mGeneration > 0) {
47910:         // XXX dispatch context lost event
47910:     }
47910: #endif
47910: 
43099:     MakeContextCurrent();
43099: 
39587:     // Make sure that we clear this out, otherwise
39587:     // we'll end up displaying random memory
47910:     gl->fBindFramebuffer(LOCAL_GL_FRAMEBUFFER, gl->GetOffscreenFBO());
39587:     gl->fViewport(0, 0, mWidth, mHeight);
47910:     gl->fClearColor(0.0f, 0.0f, 0.0f, 0.0f);
48029:     gl->fClearDepth(1.0f);
47910:     gl->fClearStencil(0);
39587:     gl->fClear(LOCAL_GL_COLOR_BUFFER_BIT | LOCAL_GL_DEPTH_BUFFER_BIT | LOCAL_GL_STENCIL_BUFFER_BIT);
32195: 
63285:     reporter.SetSuccessful();
32195:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::Render(gfxContext *ctx, gfxPattern::GraphicsFilter f)
32195: {
42402:     if (!gl)
32195:         return NS_OK;
32195: 
42402:     nsRefPtr<gfxImageSurface> surf = new gfxImageSurface(gfxIntSize(mWidth, mHeight),
42402:                                                          gfxASurface::ImageFormatARGB32);
42402:     if (surf->CairoStatus() != 0)
42402:         return NS_ERROR_FAILURE;
32195: 
55265:     gl->ReadPixelsIntoImageSurface(0, 0, mWidth, mHeight, surf);
42402:     gfxUtils::PremultiplyImageSurface(surf);
32195: 
42402:     nsRefPtr<gfxPattern> pat = new gfxPattern(surf);
42402:     pat->SetFilter(f);
32195: 
55265:     // Pixels from ReadPixels will be "upside down" compared to
55265:     // what cairo wants, so draw with a y-flip and a translte to
55265:     // flip them.
55265:     gfxMatrix m;
55265:     m.Translate(gfxPoint(0.0, mHeight));
55265:     m.Scale(1.0, -1.0);
55265:     pat->SetMatrix(m);
55265: 
32195:     ctx->NewPath();
32195:     ctx->PixelSnappedRectangleAndSetPattern(gfxRect(0, 0, mWidth, mHeight), pat);
32195:     ctx->Fill();
32195: 
42402:     return NS_OK;
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::GetInputStream(const char* aMimeType,
32195:                              const PRUnichar* aEncoderOptions,
32195:                              nsIInputStream **aStream)
32195: {
57632:     NS_ASSERTION(gl, "GetInputStream on invalid context?");
57632:     if (!gl)
32195:         return NS_ERROR_FAILURE;
32195: 
57632:     nsRefPtr<gfxImageSurface> surf = new gfxImageSurface(gfxIntSize(mWidth, mHeight),
57632:                                                          gfxASurface::ImageFormatARGB32);
57632:     if (surf->CairoStatus() != 0)
32195:         return NS_ERROR_FAILURE;
32195: 
61665:     nsRefPtr<gfxContext> tmpcx = new gfxContext(surf);
61665:     // Use Render() to make sure that appropriate y-flip gets applied
61665:     nsresult rv = Render(tmpcx, gfxPattern::FILTER_NEAREST);
61665:     if (NS_FAILED(rv))
61665:         return rv;
57632: 
32195:     const char encoderPrefix[] = "@mozilla.org/image/encoder;2?type=";
57632:     nsAutoArrayPtr<char> conid(new char[strlen(encoderPrefix) + strlen(aMimeType) + 1]);
32195: 
32195:     if (!conid)
32195:         return NS_ERROR_OUT_OF_MEMORY;
32195: 
32195:     strcpy(conid, encoderPrefix);
32195:     strcat(conid, aMimeType);
32195: 
32195:     nsCOMPtr<imgIEncoder> encoder = do_CreateInstance(conid);
32195:     if (!encoder)
32195:         return NS_ERROR_FAILURE;
32195: 
57632:     rv = encoder->InitFromData(surf->Data(),
57632:                                mWidth * mHeight * 4,
57632:                                mWidth, mHeight,
57632:                                surf->Stride(),
32195:                                imgIEncoder::INPUT_FORMAT_HOSTARGB,
32195:                                nsDependentString(aEncoderOptions));
32195:     NS_ENSURE_SUCCESS(rv, rv);
32195: 
32195:     return CallQueryInterface(encoder, aStream);
32195: }
32195: 
32195: NS_IMETHODIMP
32195: WebGLContext::GetThebesSurface(gfxASurface **surface)
32195: {
32195:     return NS_ERROR_NOT_AVAILABLE;
32195: }
32195: 
47731: static PRUint8 gWebGLLayerUserData;
47731: 
64542: class WebGLContextUserData : public LayerUserData {
64542: public:
64542:     WebGLContextUserData(nsHTMLCanvasElement *aContent)
64542:     : mContent(aContent) {}
64542:   static void DidTransactionCallback(void* aData)
64542:   {
64542:     static_cast<WebGLContextUserData*>(aData)->mContent->MarkContextClean();
64542:   }
64542: 
64542: private:
64542:   nsRefPtr<nsHTMLCanvasElement> mContent;
64542: };
64542: 
42402: already_AddRefed<layers::CanvasLayer>
64542: WebGLContext::GetCanvasLayer(nsDisplayListBuilder* aBuilder,
64542:                              CanvasLayer *aOldLayer,
47731:                              LayerManager *aManager)
42402: {
47731:     if (!mResetLayer && aOldLayer &&
51946:         aOldLayer->HasUserData(&gWebGLLayerUserData)) {
47731:         NS_ADDREF(aOldLayer);
47731:         return aOldLayer;
47731:     }
47731: 
47731:     nsRefPtr<CanvasLayer> canvasLayer = aManager->CreateCanvasLayer();
42402:     if (!canvasLayer) {
42402:         NS_WARNING("CreateCanvasLayer returned null!");
42402:         return nsnull;
32195:     }
64542:     WebGLContextUserData *userData = nsnull;
64542:     if (aBuilder->IsPaintingToWindow()) {
64542:       // Make the layer tell us whenever a transaction finishes (including
64542:       // the current transaction), so we can clear our invalidation state and
64542:       // start invalidating again. We need to do this for the layer that is
64542:       // being painted to a window (there shouldn't be more than one at a time,
64542:       // and if there is, flushing the invalidation state more often than
64542:       // necessary is harmless).
64542: 
64542:       // The layer will be destroyed when we tear down the presentation
64542:       // (at the latest), at which time this userData will be destroyed,
64542:       // releasing the reference to the element.
64542:       // The userData will receive DidTransactionCallbacks, which flush the
64542:       // the invalidation state to indicate that the canvas is up to date.
64542:       userData = new WebGLContextUserData(HTMLCanvasElement());
64542:       canvasLayer->SetDidTransactionCallback(
64542:               WebGLContextUserData::DidTransactionCallback, userData);
64542:     }
64542:     canvasLayer->SetUserData(&gWebGLLayerUserData, userData);
32195: 
42402:     CanvasLayer::Data data;
42402: 
42474:     // the gl context may either provide a native PBuffer, in which case we want to initialize
42474:     // data with the gl context directly, or may provide a surface to which it renders (this is the case
42474:     // of OSMesa contexts), in which case we want to initialize data with that surface.
42474: 
42474:     void* native_surface = gl->GetNativeData(gl::GLContext::NativeImageSurface);
42474: 
47910:     if (native_surface) {
47910:         data.mSurface = static_cast<gfxASurface*>(native_surface);
47910:     } else {
42402:         data.mGLContext = gl.get();
42474:     }
42474: 
42402:     data.mSize = nsIntSize(mWidth, mHeight);
57631:     data.mGLBufferIsPremultiplied = mOptions.premultipliedAlpha ? PR_TRUE : PR_FALSE;
42402: 
42402:     canvasLayer->Initialize(data);
51950:     PRUint32 flags = gl->CreationFormat().alpha == 0 ? Layer::CONTENT_OPAQUE : 0;
51950:     canvasLayer->SetContentFlags(flags);
64540:     canvasLayer->Updated();
42402: 
47731:     mResetLayer = PR_FALSE;
42402: 
70168:     mBackbufferClearingStatus = BackbufferClearingStatus::NotClearedSinceLastPresented;
70168: 
42402:     return canvasLayer.forget().get();
39587: }
46955: 
57631: NS_IMETHODIMP
57631: WebGLContext::GetContextAttributes(jsval *aResult)
57631: {
57631:     JSContext *cx = nsContentUtils::GetCurrentJSContext();
57631:     if (!cx)
57631:         return NS_ERROR_FAILURE;
57631: 
57631:     JSObject *obj = JS_NewObject(cx, NULL, NULL, NULL);
57631:     if (!obj)
57631:         return NS_ERROR_FAILURE;
57631: 
57631:     *aResult = OBJECT_TO_JSVAL(obj);
57631: 
57631:     gl::ContextFormat cf = gl->ActualFormat();
57631: 
57631:     if (!JS_DefineProperty(cx, obj, "alpha", cf.alpha > 0 ? JSVAL_TRUE : JSVAL_FALSE,
57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
57631:         !JS_DefineProperty(cx, obj, "depth", cf.depth > 0 ? JSVAL_TRUE : JSVAL_FALSE,
57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
57631:         !JS_DefineProperty(cx, obj, "stencil", cf.stencil > 0 ? JSVAL_TRUE : JSVAL_FALSE,
57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
57631:         !JS_DefineProperty(cx, obj, "antialias", JSVAL_FALSE,
57631:                            NULL, NULL, JSPROP_ENUMERATE) ||
57631:         !JS_DefineProperty(cx, obj, "premultipliedAlpha",
57631:                            mOptions.premultipliedAlpha ? JSVAL_TRUE : JSVAL_FALSE,
70165:                            NULL, NULL, JSPROP_ENUMERATE) ||
70165:         !JS_DefineProperty(cx, obj, "preserveDrawingBuffer",
70165:                            mOptions.preserveDrawingBuffer ? JSVAL_TRUE : JSVAL_FALSE,
57631:                            NULL, NULL, JSPROP_ENUMERATE))
57631:     {
57631:         *aResult = JSVAL_VOID;
57631:         return NS_ERROR_FAILURE;
57631:     }
57631: 
57631:     return NS_OK;
57631: }
57631: 
59414: /* [noscript] DOMString mozGetUnderlyingParamString(in WebGLenum pname); */
59414: NS_IMETHODIMP
59414: WebGLContext::MozGetUnderlyingParamString(PRUint32 pname, nsAString& retval)
59414: {
59414:     retval.SetIsVoid(PR_TRUE);
59414: 
59414:     MakeContextCurrent();
59414: 
59414:     switch (pname) {
59414:     case LOCAL_GL_VENDOR:
59414:     case LOCAL_GL_RENDERER:
59414:     case LOCAL_GL_VERSION:
59414:     case LOCAL_GL_SHADING_LANGUAGE_VERSION:
59414:     case LOCAL_GL_EXTENSIONS: {
59414:         const char *s = (const char *) gl->fGetString(pname);
59414:         retval.Assign(NS_ConvertASCIItoUTF16(nsDependentCString(s)));
59414:     }
59414:         break;
59414: 
59414:     default:
59414:         return NS_ERROR_INVALID_ARG;
59414:     }
59414: 
59414:     return NS_OK;
59414: }
59414: 
70163: NS_IMETHODIMP
70163: WebGLContext::GetExtension(const nsAString& aName, nsIWebGLExtension **retval)
70163: {
70163:     *retval = nsnull;
70163: 
70163:     // handle simple extensions that don't need custom objects first
70163:     WebGLExtensionID ei = WebGLExtensionID_Max;
70163:     if (aName.EqualsLiteral("OES_texture_float")) {
70163:         MakeContextCurrent();
70163: 
70163:         PRBool avail = gl->IsExtensionSupported(gl->IsGLES2() ? "GL_OES_texture_float" : "GL_ARB_texture_float");
70163:         if (avail)
70163:             ei = WebGL_OES_texture_float;
70163:     }
70163: 
70163:     // create a WebGLExtension object for extensions that don't
70163:     // have any additional tokens or methods
70163:     if (ei != WebGLExtensionID_Max) {
70163:         if (!IsExtensionEnabled(ei)) {
70163:             mEnabledExtensions[ei] = new WebGLExtension(this);
70163:         }
70163:         NS_ADDREF(*retval = mEnabledExtensions[ei]);
70163:     }
70163: 
70163:     return NS_OK;
70163: }
59414: 
70167: void
70167: WebGLContext::ForceClearFramebufferWithDefaultValues(PRUint32 mask, const nsIntRect& viewportRect)
70167: {
70167:     MakeContextCurrent();
70167: 
70167:     PRBool initializeColorBuffer = 0 != (mask & LOCAL_GL_COLOR_BUFFER_BIT);
70167:     PRBool initializeDepthBuffer = 0 != (mask & LOCAL_GL_DEPTH_BUFFER_BIT);
70167:     PRBool initializeStencilBuffer = 0 != (mask & LOCAL_GL_STENCIL_BUFFER_BIT);
70167: 
70167:     // prepare GL state for clearing
70167:     gl->fDisable(LOCAL_GL_SCISSOR_TEST);
70167:     gl->fDisable(LOCAL_GL_DITHER);
70167:     gl->PushViewportRect(viewportRect);
70167: 
70167:     if (initializeColorBuffer) {
70167:         gl->fColorMask(1, 1, 1, 1);
70167:         gl->fClearColor(0.f, 0.f, 0.f, 0.f);
70167:     }
70167: 
70167:     if (initializeDepthBuffer) {
70167:         gl->fDepthMask(1);
70167:         gl->fClearDepth(1.0f);
70167:     }
70167: 
70167:     if (initializeStencilBuffer) {
70167:         gl->fStencilMask(0xffffffff);
70167:         gl->fClearStencil(0);
70167:     }
70167: 
70167:     // do clear
70167:     gl->fClear(mask);
70167: 
70167:     // restore GL state after clearing
70167:     if (initializeColorBuffer) {
70167:         gl->fColorMask(mColorWriteMask[0],
70167:                        mColorWriteMask[1],
70167:                        mColorWriteMask[2],
70167:                        mColorWriteMask[3]);
70167:         gl->fClearColor(mColorClearValue[0],
70167:                         mColorClearValue[1],
70167:                         mColorClearValue[2],
70167:                         mColorClearValue[3]);
70167:     }
70167: 
70167:     if (initializeDepthBuffer) {
70167:         gl->fDepthMask(mDepthWriteMask);
70167:         gl->fClearDepth(mDepthClearValue);
70167:     }
70167: 
70167:     if (initializeStencilBuffer) {
70170:         gl->fStencilMaskSeparate(LOCAL_GL_FRONT, mStencilWriteMaskFront);
70170:         gl->fStencilMaskSeparate(LOCAL_GL_BACK, mStencilWriteMaskBack);
70167:         gl->fClearStencil(mStencilClearValue);
70167:     }
70167: 
70167:     gl->PopViewportRect();
70167: 
70167:     if (mDitherEnabled)
70167:         gl->fEnable(LOCAL_GL_DITHER);
70167:     else
70167:         gl->fDisable(LOCAL_GL_DITHER);
70167: 
70167:     if (mScissorTestEnabled)
70167:         gl->fEnable(LOCAL_GL_SCISSOR_TEST);
70167:     else
70167:         gl->fDisable(LOCAL_GL_SCISSOR_TEST);
70167: }
70167: 
70168: void
70168: WebGLContext::EnsureBackbufferClearedAsNeeded()
70168: {
70168:     if (mOptions.preserveDrawingBuffer)
70168:         return;
70168: 
70168:     NS_ABORT_IF_FALSE(!mBoundFramebuffer,
70168:                       "EnsureBackbufferClearedAsNeeded must not be called when a FBO is bound");
70168: 
70168:     if (mBackbufferClearingStatus != BackbufferClearingStatus::NotClearedSinceLastPresented)
70168:         return;
70168: 
70168:     mBackbufferClearingStatus = BackbufferClearingStatus::ClearedToDefaultValues;
70168: 
70168:     ForceClearFramebufferWithDefaultValues(LOCAL_GL_COLOR_BUFFER_BIT |
70168:                                            LOCAL_GL_DEPTH_BUFFER_BIT |
70168:                                            LOCAL_GL_STENCIL_BUFFER_BIT,
70168:                                            nsIntRect(0, 0, mWidth, mHeight));
70168: 
70168:     Invalidate();
70168: }
70168: 
32195: //
32195: // XPCOM goop
32195: //
32195: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(WebGLContext)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(WebGLContext)
32195: 
43655: NS_IMPL_CYCLE_COLLECTION_CLASS(WebGLContext)
43655: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(WebGLContext)
43655:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCanvasElement)
43655: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(WebGLContext)
43655:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCanvasElement)
43655: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
39587: 
59162: DOMCI_DATA(WebGLRenderingContext, WebGLContext)
40490: 
43655: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(WebGLContext)
57635:   NS_INTERFACE_MAP_ENTRY(nsIDOMWebGLRenderingContext)
32195:   NS_INTERFACE_MAP_ENTRY(nsICanvasRenderingContextInternal)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
57635:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMWebGLRenderingContext)
59162:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLRenderingContext)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLBuffer)
32195: NS_IMPL_RELEASE(WebGLBuffer)
32195: 
40490: DOMCI_DATA(WebGLBuffer, WebGLBuffer)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLBuffer)
42471:   NS_INTERFACE_MAP_ENTRY(WebGLBuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLBuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLBuffer)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLTexture)
32195: NS_IMPL_RELEASE(WebGLTexture)
32195: 
40490: DOMCI_DATA(WebGLTexture, WebGLTexture)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLTexture)
42471:   NS_INTERFACE_MAP_ENTRY(WebGLTexture)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLTexture)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLTexture)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLProgram)
32195: NS_IMPL_RELEASE(WebGLProgram)
32195: 
40490: DOMCI_DATA(WebGLProgram, WebGLProgram)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLProgram)
42471:   NS_INTERFACE_MAP_ENTRY(WebGLProgram)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLProgram)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLProgram)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLShader)
32195: NS_IMPL_RELEASE(WebGLShader)
32195: 
40490: DOMCI_DATA(WebGLShader, WebGLShader)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLShader)
42471:   NS_INTERFACE_MAP_ENTRY(WebGLShader)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLShader)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLShader)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLFramebuffer)
32195: NS_IMPL_RELEASE(WebGLFramebuffer)
32195: 
40490: DOMCI_DATA(WebGLFramebuffer, WebGLFramebuffer)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLFramebuffer)
42471:   NS_INTERFACE_MAP_ENTRY(WebGLFramebuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLFramebuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLFramebuffer)
32195: NS_INTERFACE_MAP_END
32195: 
32195: NS_IMPL_ADDREF(WebGLRenderbuffer)
32195: NS_IMPL_RELEASE(WebGLRenderbuffer)
32195: 
40490: DOMCI_DATA(WebGLRenderbuffer, WebGLRenderbuffer)
40490: 
32195: NS_INTERFACE_MAP_BEGIN(WebGLRenderbuffer)
42471:   NS_INTERFACE_MAP_ENTRY(WebGLRenderbuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsIWebGLRenderbuffer)
32195:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLRenderbuffer)
32195: NS_INTERFACE_MAP_END
32195: 
43010: NS_IMPL_ADDREF(WebGLUniformLocation)
43010: NS_IMPL_RELEASE(WebGLUniformLocation)
43010: 
43010: DOMCI_DATA(WebGLUniformLocation, WebGLUniformLocation)
43010: 
43010: NS_INTERFACE_MAP_BEGIN(WebGLUniformLocation)
43010:   NS_INTERFACE_MAP_ENTRY(WebGLUniformLocation)
43010:   NS_INTERFACE_MAP_ENTRY(nsIWebGLUniformLocation)
43010:   NS_INTERFACE_MAP_ENTRY(nsISupports)
43010:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLUniformLocation)
43010: NS_INTERFACE_MAP_END
43010: 
51421: NS_IMPL_ADDREF(WebGLActiveInfo)
51421: NS_IMPL_RELEASE(WebGLActiveInfo)
51421: 
51421: DOMCI_DATA(WebGLActiveInfo, WebGLActiveInfo)
51421: 
51421: NS_INTERFACE_MAP_BEGIN(WebGLActiveInfo)
51421:   NS_INTERFACE_MAP_ENTRY(WebGLActiveInfo)
51421:   NS_INTERFACE_MAP_ENTRY(nsIWebGLActiveInfo)
51421:   NS_INTERFACE_MAP_ENTRY(nsISupports)
51421:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLActiveInfo)
51421: NS_INTERFACE_MAP_END
51421: 
42916: #define NAME_NOT_SUPPORTED(base) \
42916: NS_IMETHODIMP base::GetName(WebGLuint *aName) \
42916: { return NS_ERROR_NOT_IMPLEMENTED; } \
42916: NS_IMETHODIMP base::SetName(WebGLuint aName) \
42916: { return NS_ERROR_NOT_IMPLEMENTED; }
39587: 
42916: NAME_NOT_SUPPORTED(WebGLTexture)
42916: NAME_NOT_SUPPORTED(WebGLBuffer)
42916: NAME_NOT_SUPPORTED(WebGLProgram)
42916: NAME_NOT_SUPPORTED(WebGLShader)
42916: NAME_NOT_SUPPORTED(WebGLFramebuffer)
42916: NAME_NOT_SUPPORTED(WebGLRenderbuffer)
43010: 
70163: NS_IMPL_ADDREF(WebGLExtension)
70163: NS_IMPL_RELEASE(WebGLExtension)
70163: 
70163: DOMCI_DATA(WebGLExtension, WebGLExtension)
70163: 
70163: NS_INTERFACE_MAP_BEGIN(WebGLExtension)
70163:   NS_INTERFACE_MAP_ENTRY(WebGLExtension)
70163:   NS_INTERFACE_MAP_ENTRY(nsIWebGLExtension)
70163:   NS_INTERFACE_MAP_ENTRY(nsISupports)
70163:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebGLExtension)
70163: NS_INTERFACE_MAP_END
70163: 
43010: /* [noscript] attribute WebGLint location; */
59414: NS_IMETHODIMP
59414: WebGLUniformLocation::GetLocation(WebGLint *aLocation)
32195: {
32195:     return NS_ERROR_NOT_IMPLEMENTED;
32195: }
59414: 
59414: NS_IMETHODIMP
59414: WebGLUniformLocation::SetLocation(WebGLint aLocation)
32195: {
32195:     return NS_ERROR_NOT_IMPLEMENTED;
32195: }
51421: 
51421: /* readonly attribute WebGLint size; */
59414: NS_IMETHODIMP
59414: WebGLActiveInfo::GetSize(WebGLint *aSize)
51421: {
51421:     *aSize = mSize;
51421:     return NS_OK;
51421: }
51421: 
51421: /* readonly attribute WebGLenum type; */
59414: NS_IMETHODIMP
59414: WebGLActiveInfo::GetType(WebGLenum *aType)
51421: {
51421:     *aType = mType;
51421:     return NS_OK;
51421: }
51421: 
51421: /* readonly attribute DOMString name; */
59414: NS_IMETHODIMP
59414: WebGLActiveInfo::GetName(nsAString & aName)
51421: {
51421:     aName = mName;
51421:     return NS_OK;
51421: }
63219: 
63219: NS_IMETHODIMP
63219: WebGLContext::GetSupportedExtensions(nsIVariant **retval)
63219: {
63219:     nsCOMPtr<nsIWritableVariant> wrval = do_CreateInstance("@mozilla.org/variant;1");
63219:     NS_ENSURE_TRUE(wrval, NS_ERROR_FAILURE);
63219: 
63219:     nsTArray<const char *> extList;
63219: 
63219:     /* no extensions to add to extList */
63219: 
63219:     nsresult rv;
63219:     if (extList.Length() > 0) {
63219:         rv = wrval->SetAsArray(nsIDataType::VTYPE_CHAR_STR, nsnull,
63219:                                extList.Length(), &extList[0]);
63219:     } else {
63219:         rv = wrval->SetAsEmptyArray();
63219:     }
63219:     if (NS_FAILED(rv))
63219:         return rv;
63219: 
63219:     *retval = wrval.forget().get();
63219:     return NS_OK;
63219: }
63219: 
63219: NS_IMETHODIMP
63221: WebGLContext::IsContextLost(WebGLboolean *retval)
63221: {
63221:     *retval = PR_FALSE;
63221:     return NS_OK;
63221: }
63221: 
