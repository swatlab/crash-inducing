32917: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
32917: /* vim: set sw=2 ts=2 et tw=79: */
32917: /* ***** BEGIN LICENSE BLOCK *****
32917:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
32917:  *
32917:  * The contents of this file are subject to the Mozilla Public License Version
32917:  * 1.1 (the "License"); you may not use this file except in compliance with
32917:  * the License. You may obtain a copy of the License at
32917:  * http://www.mozilla.org/MPL/
32917:  *
32917:  * Software distributed under the License is distributed on an "AS IS" basis,
32917:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
32917:  * for the specific language governing rights and limitations under the
32917:  * License.
32917:  *
32917:  * The Original Code is mozilla.org code.
32917:  *
32917:  * The Initial Developer of the Original Code is
32917:  * Netscape Communications Corporation.
32917:  * Portions created by the Initial Developer are Copyright (C) 1998
32917:  * the Initial Developer. All Rights Reserved.
32917:  *
32917:  * Contributor(s):
32917:  *   Pierre Phaneuf <pp@ludusdesign.com>
32917:  *   Henri Sivonen <hsivonen@iki.fi>
32917:  *
32917:  * Alternatively, the contents of this file may be used under the terms of
32917:  * either of the GNU General Public License Version 2 or later (the "GPL"),
32917:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
32917:  * in which case the provisions of the GPL or the LGPL are applicable instead
32917:  * of those above. If you wish to allow use of your version of this file only
32917:  * under the terms of either the GPL or the LGPL, and not to allow others to
32917:  * use your version of this file under the terms of the MPL, indicate your
32917:  * decision by deleting the provisions above and replace them with the notice
32917:  * and other provisions required by the GPL or the LGPL. If you do not delete
32917:  * the provisions above, a recipient may use your version of this file under
32917:  * the terms of any one of the MPL, the GPL or the LGPL.
32917:  *
32917:  * ***** END LICENSE BLOCK ***** */
32917: 
32917: #include "nsHtml5StreamParser.h"
32917: #include "nsICharsetConverterManager.h"
39511: #include "nsICharsetAlias.h"
32917: #include "nsServiceManagerUtils.h"
32917: #include "nsEncoderDecoderUtils.h"
32917: #include "nsContentUtils.h"
32917: #include "nsHtml5Tokenizer.h"
32917: #include "nsIHttpChannel.h"
32917: #include "nsHtml5Parser.h"
34979: #include "nsHtml5TreeBuilder.h"
34979: #include "nsHtml5AtomTable.h"
34980: #include "nsHtml5Module.h"
34980: #include "nsHtml5RefPtr.h"
46396: #include "nsIScriptError.h"
70976: #include "mozilla/Preferences.h"
81151: #include "nsHtml5Highlighter.h"
81156: #include "expat_config.h"
81156: #include "expat.h"
70976: 
70976: using namespace mozilla;
32917: 
32917: static NS_DEFINE_CID(kCharsetAliasCID, NS_CHARSETALIAS_CID);
32917: 
41736: PRInt32 nsHtml5StreamParser::sTimerInitialDelay = 120;
41736: PRInt32 nsHtml5StreamParser::sTimerSubsequentDelay = 120;
35600: 
35600: // static
35600: void
35600: nsHtml5StreamParser::InitializeStatics()
35600: {
71001:   Preferences::AddIntVarCache(&sTimerInitialDelay,
71001:                               "html5.flushtimer.initialdelay");
71001:   Preferences::AddIntVarCache(&sTimerSubsequentDelay,
71001:                               "html5.flushtimer.subsequentdelay");
35600: }
35600: 
41395: /*
41395:  * Note that nsHtml5StreamParser implements cycle collecting AddRef and
41395:  * Release. Therefore, nsHtml5StreamParser must never be refcounted from
41395:  * the parser thread!
41395:  *
41395:  * To work around this limitation, runnables posted by the main thread to the
41395:  * parser thread hold their reference to the stream parser in an
41395:  * nsHtml5RefPtr. Upon creation, nsHtml5RefPtr addrefs the object it holds
41395:  * just like a regular nsRefPtr. This is OK, since the creation of the
41395:  * runnable and the nsHtml5RefPtr happens on the main thread.
41395:  *
41395:  * When the runnable is done on the parser thread, the destructor of
41395:  * nsHtml5RefPtr runs there. It doesn't call Release on the held object
41395:  * directly. Instead, it posts another runnable back to the main thread where
41395:  * that runnable calls Release on the wrapped object.
41395:  *
41395:  * When posting runnables in the other direction, the runnables have to be
41395:  * created on the main thread when nsHtml5StreamParser is instantiated and
41395:  * held for the lifetime of the nsHtml5StreamParser. This works, because the
41395:  * same runnabled can be dispatched multiple times and currently runnables
41395:  * posted from the parser thread to main thread don't need to wrap any
41395:  * runnable-specific data. (In the other direction, the runnables most notably
41395:  * wrap the byte data of the stream.)
41395:  */
32917: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsHtml5StreamParser)
32917: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsHtml5StreamParser)
32917: 
32917: NS_INTERFACE_TABLE_HEAD(nsHtml5StreamParser)
32917:   NS_INTERFACE_TABLE2(nsHtml5StreamParser, 
32917:                       nsIStreamListener, 
32917:                       nsICharsetDetectionObserver)
32917:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsHtml5StreamParser)
32917: NS_INTERFACE_MAP_END
32917: 
34980: NS_IMPL_CYCLE_COLLECTION_CLASS(nsHtml5StreamParser)
34980: 
34980: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsHtml5StreamParser)
41395:   tmp->DropTimer();
34980:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mObserver)
34980:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mRequest)
34983:   tmp->mOwner = nsnull;
34980:   tmp->mExecutorFlusher = nsnull;
39737:   tmp->mLoadFlusher = nsnull;
34980:   tmp->mExecutor = nsnull;
37402:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChardet)
34980: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
34980: 
34980: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsHtml5StreamParser)
34980:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mObserver)
34980:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mRequest)
34983:   if (tmp->mOwner) {
34983:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mOwner");
34983:     cb.NoteXPCOMChild(static_cast<nsIParser*> (tmp->mOwner));
34983:   }
34980:   // hack: count the strongly owned edge wrapped in the runnable
34980:   if (tmp->mExecutorFlusher) {
34980:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mExecutorFlusher->mExecutor");
34980:     cb.NoteXPCOMChild(static_cast<nsIContentSink*> (tmp->mExecutor));
34980:   }
39737:   // hack: count the strongly owned edge wrapped in the runnable
39737:   if (tmp->mLoadFlusher) {
39737:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mLoadFlusher->mExecutor");
39737:     cb.NoteXPCOMChild(static_cast<nsIContentSink*> (tmp->mExecutor));
39737:   }
37402:   // hack: count self if held by mChardet
37402:   if (tmp->mChardet) {
37402:     NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, 
37402:       "mChardet->mObserver");
37402:     cb.NoteXPCOMChild(static_cast<nsIStreamListener*>(tmp));
37402:   }
34980: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
34980: 
34980: class nsHtml5ExecutorFlusher : public nsRunnable
34980: {
34980:   private:
34980:     nsRefPtr<nsHtml5TreeOpExecutor> mExecutor;
34980:   public:
34980:     nsHtml5ExecutorFlusher(nsHtml5TreeOpExecutor* aExecutor)
34980:       : mExecutor(aExecutor)
34980:     {}
34980:     NS_IMETHODIMP Run()
34980:     {
39737:       mExecutor->RunFlushLoop();
39737:       return NS_OK;
39737:     }
39737: };
39737: 
39737: class nsHtml5LoadFlusher : public nsRunnable
39737: {
39737:   private:
39737:     nsRefPtr<nsHtml5TreeOpExecutor> mExecutor;
39737:   public:
39737:     nsHtml5LoadFlusher(nsHtml5TreeOpExecutor* aExecutor)
39737:       : mExecutor(aExecutor)
39737:     {}
39737:     NS_IMETHODIMP Run()
39737:     {
39737:       mExecutor->FlushSpeculativeLoads();
34980:       return NS_OK;
34980:     }
34980: };
32917: 
34979: nsHtml5StreamParser::nsHtml5StreamParser(nsHtml5TreeOpExecutor* aExecutor,
81151:                                          nsHtml5Parser* aOwner,
81151:                                          eParserMode aMode)
80404:   : mFirstBuffer(nsnull) // Will be filled when starting
80404:   , mLastBuffer(nsnull) // Will be filled when starting
32917:   , mExecutor(aExecutor)
81151:   , mTreeBuilder(new nsHtml5TreeBuilder((aMode == VIEW_SOURCE_HTML ||
81151:                                          aMode == VIEW_SOURCE_XML) ?
81151:                                              nsnull : mExecutor->GetStage(),
81151:                                          aMode == NORMAL ?
81151:                                              mExecutor->GetStage() : nsnull))
81154:   , mTokenizer(new nsHtml5Tokenizer(mTreeBuilder, aMode == VIEW_SOURCE_XML))
34979:   , mTokenizerMutex("nsHtml5StreamParser mTokenizerMutex")
32917:   , mOwner(aOwner)
34981:   , mSpeculationMutex("nsHtml5StreamParser mSpeculationMutex")
34979:   , mTerminatedMutex("nsHtml5StreamParser mTerminatedMutex")
34980:   , mThread(nsHtml5Module::GetStreamParserThread())
34980:   , mExecutorFlusher(new nsHtml5ExecutorFlusher(aExecutor))
39737:   , mLoadFlusher(new nsHtml5LoadFlusher(aExecutor))
35600:   , mFlushTimer(do_CreateInstance("@mozilla.org/timer;1"))
81151:   , mMode(aMode)
32917: {
34979:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
41395:   mFlushTimer->SetTarget(mThread);
34979:   mAtomTable.Init(); // we aren't checking for OOM anyway...
34980: #ifdef DEBUG
34980:   mAtomTable.SetPermittedLookupThread(mThread);
34980: #endif
34979:   mTokenizer->setInterner(&mAtomTable);
34979:   mTokenizer->setEncodingDeclarationHandler(this);
37402: 
81151:   if (aMode == VIEW_SOURCE_HTML || aMode == VIEW_SOURCE_XML) {
81153:     nsHtml5Highlighter* highlighter =
81153:       new nsHtml5Highlighter(mExecutor->GetStage());
81153:     mTokenizer->EnableViewSource(highlighter); // takes ownership
81153:     mTreeBuilder->EnableViewSource(highlighter); // doesn't own
81151:   }
81151: 
37402:   // Chardet instantiation adapted from nsDOMFile.
37402:   // Chardet is initialized here even if it turns out to be useless
37402:   // to make the chardet refcount its observer (nsHtml5StreamParser)
37402:   // on the main thread.
70976:   const nsAdoptingCString& detectorName =
70976:     Preferences::GetLocalizedCString("intl.charset.detector");
37402:   if (!detectorName.IsEmpty()) {
37402:     nsCAutoString detectorContractID;
37402:     detectorContractID.AssignLiteral(NS_CHARSET_DETECTOR_CONTRACTID_BASE);
70976:     detectorContractID += detectorName;
62346:     if ((mChardet = do_CreateInstance(detectorContractID.get()))) {
37402:       (void) mChardet->Init(this);
80486:       mFeedChardet = true;
37402:     }
37402:   }
37402: 
34979:   // There's a zeroing operator new for everything else
32917: }
32917: 
32917: nsHtml5StreamParser::~nsHtml5StreamParser()
32917: {
34979:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
34979:   mTokenizer->end();
41395:   NS_ASSERTION(!mFlushTimer, "Flush timer was not dropped before dtor!");
41395: #ifdef DEBUG
32917:   mRequest = nsnull;
32917:   mObserver = nsnull;
32917:   mUnicodeDecoder = nsnull;
32917:   mSniffingBuffer = nsnull;
32917:   mMetaScanner = nsnull;
34981:   mFirstBuffer = nsnull;
32917:   mExecutor = nsnull;
32917:   mTreeBuilder = nsnull;
32917:   mTokenizer = nsnull;
32917:   mOwner = nsnull;
41395: #endif
32917: }
32917: 
32917: nsresult
32917: nsHtml5StreamParser::GetChannel(nsIChannel** aChannel)
32917: {
34979:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
32917:   return mRequest ? CallQueryInterface(mRequest, aChannel) :
32917:                     NS_ERROR_NOT_AVAILABLE;
32917: }
32917: 
32917: NS_IMETHODIMP
32917: nsHtml5StreamParser::Notify(const char* aCharset, nsDetectionConfident aConf)
32917: {
34980:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
32917:   if (aConf == eBestAnswer || aConf == eSureAnswer) {
80486:     mFeedChardet = false; // just in case
62346:     if (HasDecoder()) {
62346:       if (mCharset.Equals(aCharset)) {
62346:         NS_ASSERTION(mCharsetSource < kCharsetFromAutoDetection,
62346:             "Why are we running chardet at all?");
62346:         mCharsetSource = kCharsetFromAutoDetection;
62346:         mTreeBuilder->SetDocumentCharset(mCharset, mCharsetSource);
62346:       } else {
62346:         // We've already committed to a decoder. Request a reload from the
62346:         // docshell.
62346:         nsCAutoString charset(aCharset);
62346:         mTreeBuilder->NeedsCharsetSwitchTo(charset, kCharsetFromAutoDetection);
62346:         FlushTreeOpsAndDisarmTimer();
62346:         Interrupt();
62346:       }
62346:     } else {
62346:       // Got a confident answer from the sniffing buffer. That code will
62346:       // take care of setting up the decoder.
32917:       mCharset.Assign(aCharset);
32917:       mCharsetSource = kCharsetFromAutoDetection;
39511:       mTreeBuilder->SetDocumentCharset(mCharset, mCharsetSource);
32917:     }
62346:   }
32917:   return NS_OK;
32917: }
32917: 
32917: nsresult
32917: nsHtml5StreamParser::SetupDecodingAndWriteSniffingBufferAndCurrentSegment(const PRUint8* aFromSegment, // can be null
32917:                                                                           PRUint32 aCount,
32917:                                                                           PRUint32* aWriteCount)
32917: {
34980:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
32917:   nsresult rv = NS_OK;
32917:   nsCOMPtr<nsICharsetConverterManager> convManager = do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
32917:   NS_ENSURE_SUCCESS(rv, rv);
32917:   rv = convManager->GetUnicodeDecoder(mCharset.get(), getter_AddRefs(mUnicodeDecoder));
32917:   if (rv == NS_ERROR_UCONV_NOCONV) {
40914:     mCharset.AssignLiteral("windows-1252"); // lower case is the raw form
32917:     mCharsetSource = kCharsetFromWeakDocTypeDefault;
32917:     rv = convManager->GetUnicodeDecoderRaw(mCharset.get(), getter_AddRefs(mUnicodeDecoder));
39511:     mTreeBuilder->SetDocumentCharset(mCharset, mCharsetSource);
32917:   }
32917:   NS_ENSURE_SUCCESS(rv, rv);
32917:   mUnicodeDecoder->SetInputErrorBehavior(nsIUnicodeDecoder::kOnError_Recover);
32917:   return WriteSniffingBufferAndCurrentSegment(aFromSegment, aCount, aWriteCount);
32917: }
32917: 
32917: nsresult
32917: nsHtml5StreamParser::WriteSniffingBufferAndCurrentSegment(const PRUint8* aFromSegment, // can be null
32917:                                                           PRUint32 aCount,
32917:                                                           PRUint32* aWriteCount)
32917: {
34980:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
32917:   nsresult rv = NS_OK;
32917:   if (mSniffingBuffer) {
32917:     PRUint32 writeCount;
32917:     rv = WriteStreamBytes(mSniffingBuffer, mSniffingLength, &writeCount);
32917:     NS_ENSURE_SUCCESS(rv, rv);
32917:     mSniffingBuffer = nsnull;
32917:   }
32917:   mMetaScanner = nsnull;
32917:   if (aFromSegment) {
32917:     rv = WriteStreamBytes(aFromSegment, aCount, aWriteCount);
32917:   }
32917:   return rv;
32917: }
32917: 
32917: nsresult
32917: nsHtml5StreamParser::SetupDecodingFromBom(const char* aCharsetName, const char* aDecoderCharsetName)
32917: {
34980:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
32917:   nsresult rv = NS_OK;
32917:   nsCOMPtr<nsICharsetConverterManager> convManager = do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
32917:   NS_ENSURE_SUCCESS(rv, rv);
32917:   rv = convManager->GetUnicodeDecoderRaw(aDecoderCharsetName, getter_AddRefs(mUnicodeDecoder));
32917:   NS_ENSURE_SUCCESS(rv, rv);
40914:   mUnicodeDecoder->SetInputErrorBehavior(nsIUnicodeDecoder::kOnError_Recover);
32917:   mCharset.Assign(aCharsetName);
32917:   mCharsetSource = kCharsetFromByteOrderMark;
80486:   mFeedChardet = false;
39511:   mTreeBuilder->SetDocumentCharset(mCharset, mCharsetSource);
32917:   mSniffingBuffer = nsnull;
32917:   mMetaScanner = nsnull;
32917:   mBomState = BOM_SNIFFING_OVER;
32917:   return rv;
32917: }
32917: 
62647: void
62647: nsHtml5StreamParser::SniffBOMlessUTF16BasicLatin(const PRUint8* aFromSegment,
62647:                                                  PRUint32 aCountToSniffingLimit)
62647: {
62647:   // Make sure there's enough data. Require room for "<title></title>"
62647:   if (mSniffingLength + aCountToSniffingLimit < 30) {
62647:     return;
62647:   }
62647:   // even-numbered bytes tracked at 0, odd-numbered bytes tracked at 1
79445:   bool byteZero[2] = { false, false };
79445:   bool byteNonZero[2] = { false, false };
62647:   PRUint32 i = 0;
62647:   if (mSniffingBuffer) {
62647:     for (; i < mSniffingLength; ++i) {
62647:       if (mSniffingBuffer[i]) {
62647:         if (byteNonZero[1 - (i % 2)]) {
62647:           return;
62647:         }
80486:         byteNonZero[i % 2] = true;
63321:       } else {
63321:         if (byteZero[1 - (i % 2)]) {
63321:           return;
63321:         }
80486:         byteZero[i % 2] = true;
62647:       }
62647:     }
62647:   }
62647:   if (aFromSegment) {
62647:     for (PRUint32 j = 0; j < aCountToSniffingLimit; ++j) {
62647:       if (aFromSegment[j]) {
62647:         if (byteNonZero[1 - ((i + j) % 2)]) {
62647:           return;
62647:         }
80486:         byteNonZero[(i + j) % 2] = true;
63321:       } else {
63321:         if (byteZero[1 - ((i + j) % 2)]) {
63321:           return;
63321:         }
80486:         byteZero[(i + j) % 2] = true;
62647:       }
62647:     }
62647:   }
62647: 
62647:   if (byteNonZero[0]) {
62647:     mCharset.Assign("UTF-16LE");
62647:   } else {
62647:     mCharset.Assign("UTF-16BE");
62647:   }
62647:   mCharsetSource = kCharsetFromIrreversibleAutoDetection;
62647:   mTreeBuilder->SetDocumentCharset(mCharset, mCharsetSource);
80486:   mFeedChardet = false;
62647: }
62647: 
81156: void
81326: nsHtml5StreamParser::SetEncodingFromExpat(const PRUnichar* aEncoding)
81156: {
81326:   if (aEncoding) {
81156:     nsDependentString utf16(aEncoding);
81156:     nsCAutoString utf8;
81156:     CopyUTF16toUTF8(utf16, utf8);
81156:     if (PreferredForInternalEncodingDecl(utf8)) {
81156:       mCharset.Assign(utf8);
81156:       mCharsetSource = kCharsetFromMetaTag; // closest for XML
81326:       return;
81156:     }
81326:     // else the page declared an encoding Gecko doesn't support and we'd
81326:     // end up defaulting to UTF-8 anyway. Might as well fall through here
81326:     // right away and let the encoding be set to UTF-8 which we'd default to
81326:     // anyway.
81326:   }
81326:   mCharset.AssignLiteral("UTF-8"); // XML defaults to UTF-8 without a BOM
81326:   mCharsetSource = kCharsetFromMetaTag; // means confident
81156: }
81156: 
81156: // A separate user data struct is used instead of passing the
81156: // nsHtml5StreamParser instance as user data in order to avoid including
81156: // expat.h in nsHtml5StreamParser.h. Doing that would cause naming conflicts.
81156: // Using a separate user data struct also avoids bloating nsHtml5StreamParser
81156: // by one pointer.
81156: struct UserData {
81156:   XML_Parser mExpat;
81156:   nsHtml5StreamParser* mStreamParser;
81156: };
81156: 
81156: // Using no-namespace handler callbacks to avoid including expat.h in
81156: // nsHtml5StreamParser.h, since doing so would cause naming conclicts.
81156: static void
81156: HandleXMLDeclaration(void* aUserData,
81156:                      const XML_Char* aVersion,
81156:                      const XML_Char* aEncoding,
81156:                      int aStandalone)
81156: {
81156:   UserData* ud = static_cast<UserData*>(aUserData);
81326:   ud->mStreamParser->SetEncodingFromExpat(
81156:       reinterpret_cast<const PRUnichar*>(aEncoding));
81156:   XML_StopParser(ud->mExpat, false);
81156: }
81156: 
81156: static void
81156: HandleStartElement(void* aUserData,
81156:                    const XML_Char* aName,
81156:                    const XML_Char **aAtts)
81156: {
81156:   UserData* ud = static_cast<UserData*>(aUserData);
81156:   XML_StopParser(ud->mExpat, false);
81156: }
81156: 
81156: static void
81156: HandleEndElement(void* aUserData,
81156:                  const XML_Char* aName)
81156: {
81156:   UserData* ud = static_cast<UserData*>(aUserData);
81156:   XML_StopParser(ud->mExpat, false);
81156: }
81156: 
81156: static void
81156: HandleComment(void* aUserData,
81156:               const XML_Char* aName)
81156: {
81156:   UserData* ud = static_cast<UserData*>(aUserData);
81156:   XML_StopParser(ud->mExpat, false);
81156: }
81156: 
81156: static void
81156: HandleProcessingInstruction(void* aUserData,
81156:                             const XML_Char* aTarget,
81156:                             const XML_Char* aData)
81156: {
81156:   UserData* ud = static_cast<UserData*>(aUserData);
81156:   XML_StopParser(ud->mExpat, false);
81156: }
81156: 
32917: nsresult
32917: nsHtml5StreamParser::FinalizeSniffing(const PRUint8* aFromSegment, // can be null
32917:                                       PRUint32 aCount,
32917:                                       PRUint32* aWriteCount,
32917:                                       PRUint32 aCountToSniffingLimit)
32917: {
34980:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
81156:   NS_ASSERTION(mCharsetSource < kCharsetFromMetaTag,
81156:       "Should not finalize sniffing when already confident.");
81156:   if (mMode == VIEW_SOURCE_XML) {
81156:     static const XML_Memory_Handling_Suite memsuite =
81156:       {
81156:         (void *(*)(size_t))moz_xmalloc,
81156:         (void *(*)(void *, size_t))moz_xrealloc,
81156:         moz_free
81156:       };
81156: 
81156:     static const PRUnichar kExpatSeparator[] = { 0xFFFF, '\0' };
81156: 
81156:     static const PRUnichar kISO88591[] =
81156:         { 'I', 'S', 'O', '-', '8', '8', '5', '9', '-', '1', '\0' };
81156: 
81156:     UserData ud;
81156:     ud.mStreamParser = this;
81156: 
81156:     // If we got this far, the stream didn't have a BOM. UTF-16-encoded XML
81156:     // documents MUST begin with a BOM. We don't support EBCDIC and such.
81156:     // Thus, at this point, what we have is garbage or something encoded using
81156:     // a rough ASCII superset. ISO-8859-1 allows us to decode ASCII bytes
81156:     // without throwing errors when bytes have the most significant bit set
81156:     // and without triggering expat's unknown encoding code paths. This is
81156:     // enough to be able to use expat to parse the XML declaration in order
81156:     // to extract the encoding name from it.
81156:     ud.mExpat = XML_ParserCreate_MM(kISO88591, &memsuite, kExpatSeparator);
81156:     XML_SetXmlDeclHandler(ud.mExpat, HandleXMLDeclaration);
81156:     XML_SetElementHandler(ud.mExpat, HandleStartElement, HandleEndElement);
81156:     XML_SetCommentHandler(ud.mExpat, HandleComment);
81156:     XML_SetProcessingInstructionHandler(ud.mExpat, HandleProcessingInstruction);
81156:     XML_SetUserData(ud.mExpat, static_cast<void*>(&ud));
81156: 
81156:     XML_Status status = XML_STATUS_OK;
81164: 
81164:     // aFromSegment points to the data obtained from the current network
81164:     // event. mSniffingBuffer (if it exists) contains the data obtained before
81164:     // the current event. Thus, mSniffingLenth bytes of mSniffingBuffer
81164:     // followed by aCountToSniffingLimit bytes from aFromSegment are the
81164:     // first 1024 bytes of the file (or the file as a whole if the file is
81164:     // 1024 bytes long or shorter). Thus, we parse both buffers, but if the
81164:     // first call succeeds already, we skip parsing the second buffer.
81156:     if (mSniffingBuffer) {
81156:       status = XML_Parse(ud.mExpat,
81156:                          reinterpret_cast<const char*>(mSniffingBuffer.get()),
81156:                          mSniffingLength,
81156:                          false);
81156:     }
81156:     if (status == XML_STATUS_OK &&
81156:         mCharsetSource < kCharsetFromMetaTag &&
81156:         aFromSegment) {
81156:       status = XML_Parse(ud.mExpat,
81156:                          reinterpret_cast<const char*>(aFromSegment),
81156:                          aCountToSniffingLimit,
81156:                          false);
81156:     }
81156:     XML_ParserFree(ud.mExpat);
81156: 
81156:     if (mCharsetSource < kCharsetFromMetaTag) {
81156:       // Failed to get an encoding from the XML declaration. XML defaults
81156:       // confidently to UTF-8 in this case.
81156:       // It is also possible that the document has an XML declaration that is
81156:       // longer than 1024 bytes, but that case is not worth worrying about.
81156:       mCharset.AssignLiteral("UTF-8");
81156:       mCharsetSource = kCharsetFromMetaTag; // means confident
81156:     }
81156: 
81156:     return SetupDecodingAndWriteSniffingBufferAndCurrentSegment(aFromSegment,
81156:                                                                 aCount,
81156:                                                                 aWriteCount);
81156:   }
81156: 
32917:   // meta scan failed.
32917:   if (mCharsetSource >= kCharsetFromHintPrevDoc) {
80486:     mFeedChardet = false;
32917:     return SetupDecodingAndWriteSniffingBufferAndCurrentSegment(aFromSegment, aCount, aWriteCount);
32917:   }
62647:   // Check for BOMless UTF-16 with Basic
62647:   // Latin content for compat with IE. See bug 631751.
62647:   SniffBOMlessUTF16BasicLatin(aFromSegment, aCountToSniffingLimit);
62647:   // the charset may have been set now
37402:   // maybe try chardet now; 
62346:   if (mFeedChardet) {
79445:     bool dontFeed;
37402:     nsresult rv;
32917:     if (mSniffingBuffer) {
37402:       rv = mChardet->DoIt((const char*)mSniffingBuffer.get(), mSniffingLength, &dontFeed);
62346:       mFeedChardet = !dontFeed;
32917:       NS_ENSURE_SUCCESS(rv, rv);
32917:     }
62346:     if (mFeedChardet && aFromSegment) {
62346:       rv = mChardet->DoIt((const char*)aFromSegment,
62346:                           // Avoid buffer boundary-dependent behavior when
62346:                           // reparsing is forbidden. If reparse is forbidden,
62346:                           // act as if we only saw the first 1024 bytes.
62346:                           // When reparsing isn't forbidden, buffer boundaries
62346:                           // can have an effect on whether the page is loaded
62346:                           // once or twice. :-(
62346:                           mReparseForbidden ? aCountToSniffingLimit : aCount,
62346:                           &dontFeed);
62346:       mFeedChardet = !dontFeed;
32917:       NS_ENSURE_SUCCESS(rv, rv);
32917:     }
62346:     if (mFeedChardet && (!aFromSegment || mReparseForbidden)) {
62346:       // mReparseForbidden is checked so that we get to use the sniffing
62346:       // buffer with the best guess so far if we aren't allowed to guess
62346:       // better later.
80486:       mFeedChardet = false;
37402:       rv = mChardet->Done();
32917:       NS_ENSURE_SUCCESS(rv, rv);
62346:     }
32917:     // fall thru; callback may have changed charset  
32917:   }
32917:   if (mCharsetSource == kCharsetUninitialized) {
32917:     // Hopefully this case is never needed, but dealing with it anyway
40914:     mCharset.AssignLiteral("windows-1252");
32917:     mCharsetSource = kCharsetFromWeakDocTypeDefault;
39511:     mTreeBuilder->SetDocumentCharset(mCharset, mCharsetSource);
32917:   }
32917:   return SetupDecodingAndWriteSniffingBufferAndCurrentSegment(aFromSegment, aCount, aWriteCount);
32917: }
32917: 
32917: nsresult
32917: nsHtml5StreamParser::SniffStreamBytes(const PRUint8* aFromSegment,
32917:                                       PRUint32 aCount,
32917:                                       PRUint32* aWriteCount)
32917: {
34980:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
32917:   nsresult rv = NS_OK;
32917:   PRUint32 writeCount;
40914:   for (PRUint32 i = 0; i < aCount && mBomState != BOM_SNIFFING_OVER; i++) {
32917:     switch (mBomState) {
32917:       case BOM_SNIFFING_NOT_STARTED:
32917:         NS_ASSERTION(i == 0, "Bad BOM sniffing state.");
32917:         switch (*aFromSegment) {
32917:           case 0xEF:
32917:             mBomState = SEEN_UTF_8_FIRST_BYTE;
32917:             break;
32917:           case 0xFF:
32917:             mBomState = SEEN_UTF_16_LE_FIRST_BYTE;
32917:             break;
32917:           case 0xFE:
32917:             mBomState = SEEN_UTF_16_BE_FIRST_BYTE;
32917:             break;
32917:           default:
32917:             mBomState = BOM_SNIFFING_OVER;
32917:             break;
32917:         }
32917:         break;
32917:       case SEEN_UTF_16_LE_FIRST_BYTE:
32917:         if (aFromSegment[i] == 0xFE) {
32917:           rv = SetupDecodingFromBom("UTF-16", "UTF-16LE"); // upper case is the raw form
32917:           NS_ENSURE_SUCCESS(rv, rv);
32917:           PRUint32 count = aCount - (i + 1);
32917:           rv = WriteStreamBytes(aFromSegment + (i + 1), count, &writeCount);
32917:           NS_ENSURE_SUCCESS(rv, rv);
32917:           *aWriteCount = writeCount + (i + 1);
32917:           return rv;
32917:         }
32917:         mBomState = BOM_SNIFFING_OVER;
32917:         break;
32917:       case SEEN_UTF_16_BE_FIRST_BYTE:
32917:         if (aFromSegment[i] == 0xFF) {
32917:           rv = SetupDecodingFromBom("UTF-16", "UTF-16BE"); // upper case is the raw form
32917:           NS_ENSURE_SUCCESS(rv, rv);
32917:           PRUint32 count = aCount - (i + 1);
32917:           rv = WriteStreamBytes(aFromSegment + (i + 1), count, &writeCount);
32917:           NS_ENSURE_SUCCESS(rv, rv);
32917:           *aWriteCount = writeCount + (i + 1);
32917:           return rv;
32917:         }
32917:         mBomState = BOM_SNIFFING_OVER;
32917:         break;
32917:       case SEEN_UTF_8_FIRST_BYTE:
32917:         if (aFromSegment[i] == 0xBB) {
32917:           mBomState = SEEN_UTF_8_SECOND_BYTE;
32917:         } else {
32917:           mBomState = BOM_SNIFFING_OVER;
32917:         }
32917:         break;
32917:       case SEEN_UTF_8_SECOND_BYTE:
32917:         if (aFromSegment[i] == 0xBF) {
32917:           rv = SetupDecodingFromBom("UTF-8", "UTF-8"); // upper case is the raw form
32917:           NS_ENSURE_SUCCESS(rv, rv);
32917:           PRUint32 count = aCount - (i + 1);
32917:           rv = WriteStreamBytes(aFromSegment + (i + 1), count, &writeCount);
32917:           NS_ENSURE_SUCCESS(rv, rv);
32917:           *aWriteCount = writeCount + (i + 1);
32917:           return rv;
32917:         }
32917:         mBomState = BOM_SNIFFING_OVER;
32917:         break;
32917:       default:
40914:         mBomState = BOM_SNIFFING_OVER;
40914:         break;
32917:     }
32917:   }
32917:   // if we get here, there either was no BOM or the BOM sniffing isn't complete yet
32917:   
81156:   if (!mMetaScanner && (mMode == NORMAL || mMode == VIEW_SOURCE_HTML)) {
32917:     mMetaScanner = new nsHtml5MetaScanner();
32917:   }
32917:   
32917:   if (mSniffingLength + aCount >= NS_HTML5_STREAM_PARSER_SNIFFING_BUFFER_SIZE) {
32917:     // this is the last buffer
81156:     PRUint32 countToSniffingLimit =
81156:         NS_HTML5_STREAM_PARSER_SNIFFING_BUFFER_SIZE - mSniffingLength;
81156:     if (mMode == NORMAL || mMode == VIEW_SOURCE_HTML) {
81164:       nsHtml5ByteReadable readable(aFromSegment, aFromSegment +
81164:           countToSniffingLimit);
32917:       mMetaScanner->sniff(&readable, getter_AddRefs(mUnicodeDecoder), mCharset);
32917:       if (mUnicodeDecoder) {
81156:         mUnicodeDecoder->SetInputErrorBehavior(
81156:             nsIUnicodeDecoder::kOnError_Recover);
32917:         // meta scan successful
32917:         mCharsetSource = kCharsetFromMetaPrescan;
80486:         mFeedChardet = false;
39511:         mTreeBuilder->SetDocumentCharset(mCharset, mCharsetSource);
32917:         mMetaScanner = nsnull;
81156:         return WriteSniffingBufferAndCurrentSegment(aFromSegment, aCount,
81156:             aWriteCount);
32917:       }
81156:     }
81156:     return FinalizeSniffing(aFromSegment, aCount, aWriteCount,
81156:         countToSniffingLimit);
32917:   }
32917: 
32917:   // not the last buffer
81156:   if (mMode == NORMAL || mMode == VIEW_SOURCE_HTML) {
32917:     nsHtml5ByteReadable readable(aFromSegment, aFromSegment + aCount);
32917:     mMetaScanner->sniff(&readable, getter_AddRefs(mUnicodeDecoder), mCharset);
32917:     if (mUnicodeDecoder) {
32917:       // meta scan successful
81156:       mUnicodeDecoder->SetInputErrorBehavior(
81156:           nsIUnicodeDecoder::kOnError_Recover);
32917:       mCharsetSource = kCharsetFromMetaPrescan;
80486:       mFeedChardet = false;
39511:       mTreeBuilder->SetDocumentCharset(mCharset, mCharsetSource);
32917:       mMetaScanner = nsnull;
81156:       return WriteSniffingBufferAndCurrentSegment(aFromSegment, 
81156:                                                   aCount,
81156:                                                   aWriteCount);
32917:     }
81156:   }
81156: 
32917:   if (!mSniffingBuffer) {
80404:     const mozilla::fallible_t fallible = mozilla::fallible_t();
80404:     mSniffingBuffer = new (fallible)
80404:       PRUint8[NS_HTML5_STREAM_PARSER_SNIFFING_BUFFER_SIZE];
80404:     if (!mSniffingBuffer) {
80404:       return NS_ERROR_OUT_OF_MEMORY;
80404:     }
32917:   }
32917:   memcpy(mSniffingBuffer + mSniffingLength, aFromSegment, aCount);
32917:   mSniffingLength += aCount;
32917:   *aWriteCount = aCount;
32917:   return NS_OK;
32917: }
32917: 
32917: nsresult
32917: nsHtml5StreamParser::WriteStreamBytes(const PRUint8* aFromSegment,
32917:                                       PRUint32 aCount,
32917:                                       PRUint32* aWriteCount)
32917: {
34980:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
80404:   // mLastBuffer always points to a buffer of the size
80404:   // NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE.
32917:   if (mLastBuffer->getEnd() == NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE) {
80404:     nsRefPtr<nsHtml5OwningUTF16Buffer> newBuf =
80404:       nsHtml5OwningUTF16Buffer::FalliblyCreate(
80404:         NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE);
80404:     if (!newBuf) {
80404:       return NS_ERROR_OUT_OF_MEMORY;
80404:     }
80404:     mLastBuffer = (mLastBuffer->next = newBuf.forget());
32917:   }
48213:   PRInt32 totalByteCount = 0;
32917:   for (;;) {
32917:     PRInt32 end = mLastBuffer->getEnd();
32917:     PRInt32 byteCount = aCount - totalByteCount;
32917:     PRInt32 utf16Count = NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE - end;
32917: 
32917:     NS_ASSERTION(utf16Count, "Trying to convert into a buffer with no free space!");
62828:     // byteCount may be zero to force the decoder to output a pending surrogate
62828:     // pair.
32917: 
32917:     nsresult convResult = mUnicodeDecoder->Convert((const char*)aFromSegment, &byteCount, mLastBuffer->getBuffer() + end, &utf16Count);
32917: 
32917:     end += utf16Count;
32917:     mLastBuffer->setEnd(end);
32917:     totalByteCount += byteCount;
32917:     aFromSegment += byteCount;
32917: 
48213:     NS_ASSERTION(end <= NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE,
48213:         "The Unicode decoder wrote too much data.");
48213:     NS_ASSERTION(byteCount >= -1, "The decoder consumed fewer than -1 bytes.");
32917: 
32917:     if (NS_FAILED(convResult)) {
48213:       // Using the more generic NS_FAILED test above in case there are still
48213:       // decoders around that don't use NS_ERROR_ILLEGAL_INPUT properly.
48213:       NS_ASSERTION(convResult == NS_ERROR_ILLEGAL_INPUT,
48213:           "The decoder signaled an error other than NS_ERROR_ILLEGAL_INPUT.");
48213: 
40914:       // There's an illegal byte in the input. It's now the responsibility
40914:       // of this calling code to output a U+FFFD REPLACEMENT CHARACTER and
40914:       // reset the decoder.
40914: 
48213:       if (totalByteCount < (PRInt32)aCount) {
40914:         // advance over the bad byte
32917:         ++totalByteCount;
32917:         ++aFromSegment;
48213:       } else {
48213:         NS_NOTREACHED("The decoder signaled an error but consumed all input.");
48213:         // Recovering from this situation in case there are still broken
48213:         // decoders, since nsScanner had recovery code, too.
48213:         totalByteCount = (PRInt32)aCount;
32917:       }
40914: 
40914:       // Emit the REPLACEMENT CHARACTER
32917:       mLastBuffer->getBuffer()[end] = 0xFFFD;
32917:       ++end;
32917:       mLastBuffer->setEnd(end);
32917:       if (end == NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE) {
80404:         nsRefPtr<nsHtml5OwningUTF16Buffer> newBuf =
80404:           nsHtml5OwningUTF16Buffer::FalliblyCreate(
80404:             NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE);
80404:         if (!newBuf) {
80404:           return NS_ERROR_OUT_OF_MEMORY;
80404:         }
80404:         mLastBuffer = (mLastBuffer->next = newBuf.forget());
32917:       }
40914: 
32917:       mUnicodeDecoder->Reset();
48213:       if (totalByteCount == (PRInt32)aCount) {
48213:         *aWriteCount = (PRUint32)totalByteCount;
32917:         return NS_OK;
32917:       }
32917:     } else if (convResult == NS_PARTIAL_MORE_OUTPUT) {
80404:       nsRefPtr<nsHtml5OwningUTF16Buffer> newBuf =
80404:         nsHtml5OwningUTF16Buffer::FalliblyCreate(
80404:           NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE);
80404:       if (!newBuf) {
80404:         return NS_ERROR_OUT_OF_MEMORY;
80404:       }
80404:       mLastBuffer = (mLastBuffer->next = newBuf.forget());
62828:       // All input may have been consumed if there is a pending surrogate pair
62828:       // that doesn't fit in the output buffer. Loop back to push a zero-length
62828:       // input to the decoder in that case.
32917:     } else {
48213:       NS_ASSERTION(totalByteCount == (PRInt32)aCount,
48213:           "The Unicode decoder consumed the wrong number of bytes.");
48213:       *aWriteCount = (PRUint32)totalByteCount;
32917:       return NS_OK;
32917:     }
32917:   }
32917: }
32917: 
32917: // nsIRequestObserver methods:
32917: nsresult
32917: nsHtml5StreamParser::OnStartRequest(nsIRequest* aRequest, nsISupports* aContext)
32917: {
34979:   NS_PRECONDITION(STREAM_NOT_STARTED == mStreamState,
34979:                   "Got OnStartRequest when the stream had already started.");
34981:   NS_PRECONDITION(!mExecutor->HasStarted(), 
34979:                   "Got OnStartRequest at the wrong stage in the executor life cycle.");
34979:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
32917:   if (mObserver) {
32917:     mObserver->OnStartRequest(aRequest, aContext);
32917:   }
32917:   mRequest = aRequest;
32917: 
34979:   mStreamState = STREAM_BEING_READ;
34979: 
81151:   if (mMode == VIEW_SOURCE_HTML || mMode == VIEW_SOURCE_XML) {
81151:     mTokenizer->StartViewSource();
81151:   }
81151:   // For View Source, the parser should run with scripts "enabled" if a normal
81151:   // load would have scripts enabled.
79445:   bool scriptingEnabled = mExecutor->IsScriptEnabled();
34979:   mOwner->StartTokenizer(scriptingEnabled);
34979:   mTreeBuilder->setScriptingEnabled(scriptingEnabled);
34979:   mTokenizer->start();
34979:   mExecutor->Start();
34979:   mExecutor->StartReadingFromStage();
81186: 
81186:   if (mMode == PLAIN_TEXT) {
81186:     mTreeBuilder->StartPlainText();
81186:     mTokenizer->StartPlainText();
81186:   }
81186: 
32917:   /*
32917:    * If you move the following line, be very careful not to cause 
32917:    * WillBuildModel to be called before the document has had its 
32917:    * script global object set.
32917:    */
34979:   mExecutor->WillBuildModel(eDTDMode_unknown);
34979:   
80404:   nsRefPtr<nsHtml5OwningUTF16Buffer> newBuf =
80404:     nsHtml5OwningUTF16Buffer::FalliblyCreate(
80404:       NS_HTML5_STREAM_PARSER_READ_BUFFER_SIZE);
80404:   if (!newBuf) {
80404:     mExecutor->MarkAsBroken(); // marks this stream parser as terminated,
80404:                                // which prevents entry to code paths that
80404:                                // would use mFirstBuffer or mLastBuffer.
80404:     return NS_ERROR_OUT_OF_MEMORY;
80404:   }
80404:   NS_ASSERTION(!mFirstBuffer, "How come we have the first buffer set?");
80404:   NS_ASSERTION(!mLastBuffer, "How come we have the last buffer set?");
80404:   mFirstBuffer = mLastBuffer = newBuf;
80404: 
34979:   nsresult rv = NS_OK;
34979: 
81151:   // The line below means that the encoding can end up being wrong if
81151:   // a view-source URL is loaded without having the encoding hint from a
81151:   // previous normal load in the history.
81186:   mReparseForbidden = !(mMode == NORMAL || mMode == PLAIN_TEXT);
81151: 
34979:   nsCOMPtr<nsIHttpChannel> httpChannel(do_QueryInterface(mRequest, &rv));
34979:   if (NS_SUCCEEDED(rv)) {
34979:     nsCAutoString method;
34979:     httpChannel->GetRequestMethod(method);
34979:     // XXX does Necko have a way to renavigate POST, etc. without hitting
34979:     // the network?
34979:     if (!method.EqualsLiteral("GET")) {
34979:       // This is the old Gecko behavior but the HTML5 spec disagrees.
34979:       // Don't reparse on POST.
80486:       mReparseForbidden = true;
80486:       mFeedChardet = false; // can't restart anyway
34979:     }
34979:   }
32917: 
62346:   if (mCharsetSource >= kCharsetFromAutoDetection) {
80486:     mFeedChardet = false;
62346:   }
62346:   
58890:   if (mCharsetSource <= kCharsetFromMetaPrescan) {
32917:     // we aren't ready to commit to an encoding yet
32917:     // leave converter uninstantiated for now
32917:     return NS_OK;
32917:   }
32917:   
32917:   nsCOMPtr<nsICharsetConverterManager> convManager = do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
32917:   NS_ENSURE_SUCCESS(rv, rv);
32917:   rv = convManager->GetUnicodeDecoder(mCharset.get(), getter_AddRefs(mUnicodeDecoder));
57467:   // if we failed to get a decoder, there will be fallback, so don't propagate
57467:   //  the error.
57467:   if (NS_SUCCEEDED(rv)) {
32917:     mUnicodeDecoder->SetInputErrorBehavior(nsIUnicodeDecoder::kOnError_Recover);
57467:   } else {
57467:     mCharsetSource = kCharsetFromWeakDocTypeDefault;
57467:   }
32917:   return NS_OK;
32917: }
32917: 
34980: void
34980: nsHtml5StreamParser::DoStopRequest()
34980: {
34980:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
34980:   NS_PRECONDITION(STREAM_BEING_READ == mStreamState,
34980:                   "Stream ended without being open.");
34981:   mTokenizerMutex.AssertCurrentThreadOwns();
34981: 
34981:   if (IsTerminated()) {
34981:     return;
34981:   }
34981: 
80404:   mStreamState = STREAM_ENDED;
80404: 
34980:   if (!mUnicodeDecoder) {
34980:     PRUint32 writeCount;
80404:     if (NS_FAILED(FinalizeSniffing(nsnull, 0, &writeCount, 0))) {
80404:       MarkAsBroken();
80404:       return;
80404:     }
62346:   } else if (mFeedChardet) {
62346:     mChardet->Done();
34980:   }
34980: 
34981:   if (IsTerminatedOrInterrupted()) {
34981:     return;
34980:   }
34981: 
34981:   ParseAvailableData(); 
34980: }
34980: 
34980: class nsHtml5RequestStopper : public nsRunnable
34980: {
34980:   private:
34980:     nsHtml5RefPtr<nsHtml5StreamParser> mStreamParser;
34980:   public:
34980:     nsHtml5RequestStopper(nsHtml5StreamParser* aStreamParser)
34980:       : mStreamParser(aStreamParser)
34980:     {}
34980:     NS_IMETHODIMP Run()
34980:     {
34981:       mozilla::MutexAutoLock autoLock(mStreamParser->mTokenizerMutex);
34980:       mStreamParser->DoStopRequest();
34980:       return NS_OK;
34980:     }
34980: };
34980: 
32917: nsresult
32917: nsHtml5StreamParser::OnStopRequest(nsIRequest* aRequest,
32917:                              nsISupports* aContext,
32917:                              nsresult status)
32917: {
32917:   NS_ASSERTION(mRequest == aRequest, "Got Stop on wrong stream.");
34979:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
32917:   if (mObserver) {
32917:     mObserver->OnStopRequest(aRequest, aContext, status);
32917:   }
34980:   nsCOMPtr<nsIRunnable> stopper = new nsHtml5RequestStopper(this);
34980:   if (NS_FAILED(mThread->Dispatch(stopper, nsIThread::DISPATCH_NORMAL))) {
34980:     NS_WARNING("Dispatching StopRequest event failed.");
34979:   }
32917:   return NS_OK;
32917: }
32917: 
34980: void
34980: nsHtml5StreamParser::DoDataAvailable(PRUint8* aBuffer, PRUint32 aLength)
32917: {
34980:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
34980:   NS_PRECONDITION(STREAM_BEING_READ == mStreamState,
34980:                   "DoDataAvailable called when stream not open.");
34981:   mTokenizerMutex.AssertCurrentThreadOwns();
34981: 
34981:   if (IsTerminated()) {
34981:     return;
34981:   }
34981: 
34980:   PRUint32 writeCount;
80404:   nsresult rv;
62346:   if (HasDecoder()) {
62346:     if (mFeedChardet) {
79445:       bool dontFeed;
62346:       mChardet->DoIt((const char*)aBuffer, aLength, &dontFeed);
62346:       mFeedChardet = !dontFeed;
62346:     }
80404:     rv = WriteStreamBytes(aBuffer, aLength, &writeCount);
62346:   } else {
80404:     rv = SniffStreamBytes(aBuffer, aLength, &writeCount);
62346:   }
80404:   if (NS_FAILED(rv)) {
80404:     MarkAsBroken();
80404:     return;
80404:   }
34980:   NS_ASSERTION(writeCount == aLength, "Wrong number of stream bytes written/sniffed.");
34981: 
34981:   if (IsTerminatedOrInterrupted()) {
34981:     return;
32917:   }
34981: 
34981:   ParseAvailableData();
41395: 
41395:   if (mFlushTimerArmed || mSpeculating) {
41395:     return;
41395:   }
41395: 
41395:   mFlushTimer->InitWithFuncCallback(nsHtml5StreamParser::TimerCallback,
41395:                                     static_cast<void*> (this),
41395:                                     mFlushTimerEverFired ?
41395:                                         sTimerInitialDelay :
41395:                                         sTimerSubsequentDelay,
41395:                                     nsITimer::TYPE_ONE_SHOT);
80486:   mFlushTimerArmed = true;
32917: }
32917: 
34980: class nsHtml5DataAvailable : public nsRunnable
34980: {
34980:   private:
34980:     nsHtml5RefPtr<nsHtml5StreamParser> mStreamParser;
34980:     nsAutoArrayPtr<PRUint8>            mData;
34980:     PRUint32                           mLength;
34980:   public:
34980:     nsHtml5DataAvailable(nsHtml5StreamParser* aStreamParser,
34980:                          PRUint8*             aData,
34980:                          PRUint32             aLength)
34980:       : mStreamParser(aStreamParser)
34980:       , mData(aData)
34980:       , mLength(aLength)
34980:     {}
34980:     NS_IMETHODIMP Run()
34980:     {
34981:       mozilla::MutexAutoLock autoLock(mStreamParser->mTokenizerMutex);
34980:       mStreamParser->DoDataAvailable(mData, mLength);
34980:       return NS_OK;
34980:     }
34980: };
34980: 
34980: // nsIStreamListener method:
32917: nsresult
32917: nsHtml5StreamParser::OnDataAvailable(nsIRequest* aRequest,
32917:                                nsISupports* aContext,
32917:                                nsIInputStream* aInStream,
32917:                                PRUint32 aSourceOffset,
32917:                                PRUint32 aLength)
32917: {
80404:   if (mExecutor->IsBroken()) {
80404:     return NS_ERROR_OUT_OF_MEMORY;
80404:   }
80404: 
32917:   NS_ASSERTION(mRequest == aRequest, "Got data on wrong stream.");
32917:   PRUint32 totalRead;
80404:   const mozilla::fallible_t fallible = mozilla::fallible_t();
80404:   nsAutoArrayPtr<PRUint8> data(new (fallible) PRUint8[aLength]);
80404:   if (!data) {
80404:     mExecutor->MarkAsBroken();
80404:     return NS_ERROR_OUT_OF_MEMORY;
80404:   }
34980:   nsresult rv = aInStream->Read(reinterpret_cast<char*>(data.get()),
34980:   aLength, &totalRead);
34980:   NS_ENSURE_SUCCESS(rv, rv);
34980:   NS_ASSERTION(totalRead <= aLength, "Read more bytes than were available?");
34980:   nsCOMPtr<nsIRunnable> dataAvailable = new nsHtml5DataAvailable(this,
34980:                                                                  data.forget(),
34980:                                                                 totalRead);
34980:   if (NS_FAILED(mThread->Dispatch(dataAvailable, nsIThread::DISPATCH_NORMAL))) {
34980:     NS_WARNING("Dispatching DataAvailable event failed.");
32917:   }
32917:   return rv;
32917: }
32917: 
79445: bool
81156: nsHtml5StreamParser::PreferredForInternalEncodingDecl(nsACString& aEncoding)
32917: {
81156:   nsCAutoString newEncoding(aEncoding);
60373:   newEncoding.Trim(" \t\r\n\f");
48405:   if (newEncoding.LowerCaseEqualsLiteral("utf-16") ||
48405:       newEncoding.LowerCaseEqualsLiteral("utf-16be") ||
48405:       newEncoding.LowerCaseEqualsLiteral("utf-16le")) {
48405:     newEncoding.Assign("UTF-8");
48405:   }
48405: 
32917:   nsresult rv = NS_OK;
32917:   nsCOMPtr<nsICharsetAlias> calias(do_GetService(kCharsetAliasCID, &rv));
32917:   if (NS_FAILED(rv)) {
34986:     NS_NOTREACHED("Charset alias service not available.");
80486:     return false;
32917:   }
79445:   bool eq;
32917:   rv = calias->Equals(newEncoding, mCharset, &eq);
32917:   if (NS_FAILED(rv)) {
34986:     NS_NOTREACHED("Charset name equality check failed.");
80486:     return false;
32917:   }
32917:   if (eq) {
32917:     mCharsetSource = kCharsetFromMetaTag; // become confident
80486:     mFeedChardet = false; // don't feed chardet when confident
80486:     return false;
32917:   }
32917:   
32917:   // XXX check HTML5 non-IANA aliases here
32917:   
34986:   nsCAutoString preferred;
34986:   
34986:   rv = calias->GetPreferred(newEncoding, preferred);
34986:   if (NS_FAILED(rv)) {
34986:     // the encoding name is bogus
80486:     return false;
32917:   }
32917:   
48405:   if (preferred.LowerCaseEqualsLiteral("utf-16") ||
48405:       preferred.LowerCaseEqualsLiteral("utf-16be") ||
48405:       preferred.LowerCaseEqualsLiteral("utf-16le") ||
48405:       preferred.LowerCaseEqualsLiteral("utf-7") ||
48405:       preferred.LowerCaseEqualsLiteral("jis_x0212-1990") ||
48405:       preferred.LowerCaseEqualsLiteral("x-jis0208") ||
48405:       preferred.LowerCaseEqualsLiteral("x-imap4-modified-utf7") ||
48405:       preferred.LowerCaseEqualsLiteral("x-user-defined")) {
48405:     // Not a rough ASCII superset
80486:     return false;
48405:   }
81156:   aEncoding.Assign(preferred);
81156:   return true;
81156: }
81156: 
81156: bool
81156: nsHtml5StreamParser::internalEncodingDeclaration(nsString* aEncoding)
81156: {
81156:   // This code needs to stay in sync with
81156:   // nsHtml5MetaScanner::tryCharset. Unfortunately, the
81156:   // trickery with member fields there leads to some copy-paste reuse. :-(
81156:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
81156:   if (mCharsetSource >= kCharsetFromMetaTag) { // this threshold corresponds to "confident" in the HTML5 spec
81156:     return false;
81156:   }
81156: 
81156:   if (mReparseForbidden) {
81156:     return false; // not reparsing even if we wanted to
81156:   }
81156: 
81156:   nsCAutoString newEncoding;
81156:   CopyUTF16toUTF8(*aEncoding, newEncoding);
81156: 
81156:   if (!PreferredForInternalEncodingDecl(newEncoding)) {
81156:     return false;
81156:   }
48405: 
74488:   // Avoid having the chardet ask for another restart after this restart
74488:   // request.
80486:   mFeedChardet = false;
81156:   mTreeBuilder->NeedsCharsetSwitchTo(newEncoding, kCharsetFromMetaTag);
41395:   FlushTreeOpsAndDisarmTimer();
41395:   Interrupt();
41395:   // the tree op executor will cause the stream parser to terminate
41395:   // if the charset switch request is accepted or it'll uninterrupt 
74488:   // if the request failed. Note that if the restart request fails,
74488:   // we don't bother trying to make chardet resume. Might as well
74488:   // assume that chardet-requested restarts would fail, too.
80486:   return true;
41395: }
41395: 
41395: void
41395: nsHtml5StreamParser::FlushTreeOpsAndDisarmTimer()
41395: {
41395:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
41395:   if (mFlushTimerArmed) {
41395:     // avoid calling Cancel if the flush timer isn't armed to avoid acquiring
41395:     // a mutex
41395:     mFlushTimer->Cancel();
80486:     mFlushTimerArmed = false;
41395:   }
81151:   if (mMode == VIEW_SOURCE_HTML || mMode == VIEW_SOURCE_XML) {
81151:     mTokenizer->FlushViewSource();
81151:   }
34979:   mTreeBuilder->Flush();
34986:   if (NS_FAILED(NS_DispatchToMainThread(mExecutorFlusher))) {
34986:     NS_WARNING("failed to dispatch executor flush event");
34986:   }
32917: }
32917: 
32917: void
34981: nsHtml5StreamParser::ParseAvailableData()
32917: {
34980:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
34981:   mTokenizerMutex.AssertCurrentThreadOwns();
34981: 
34981:   if (IsTerminatedOrInterrupted()) {
32917:     return;
32917:   }
32917:   
32917:   for (;;) {
32917:     if (!mFirstBuffer->hasMore()) {
32917:       if (mFirstBuffer == mLastBuffer) {
34979:         switch (mStreamState) {
34979:           case STREAM_BEING_READ:
34981:             // never release the last buffer.
34981:             if (!mSpeculating) {
34981:               // reuse buffer space if not speculating
32917:               mFirstBuffer->setStart(0);
32917:               mFirstBuffer->setEnd(0);
34981:             }
39737:             mTreeBuilder->FlushLoads();
39737:             // Dispatch this runnable unconditionally, because the loads
39737:             // that need flushing may have been flushed earlier even if the
39737:             // flush right above here did nothing.
39737:             if (NS_FAILED(NS_DispatchToMainThread(mLoadFlusher))) {
39737:               NS_WARNING("failed to dispatch load flush event");
39737:             }
32917:             return; // no more data for now but expecting more
34979:           case STREAM_ENDED:
34981:             if (mAtEOF) {
34981:               return;
34981:             }
80486:             mAtEOF = true;
34979:             mTokenizer->eof();
34979:             mTreeBuilder->StreamEnded();
81151:             if (mMode == VIEW_SOURCE_HTML || mMode == VIEW_SOURCE_XML) {
81151:               mTokenizer->EndViewSource();
81151:             }
41395:             FlushTreeOpsAndDisarmTimer();
32917:             return; // no more data and not expecting more
32917:           default:
32917:             NS_NOTREACHED("It should be impossible to reach this.");
32917:             return;
32917:         }
40914:       }
32917:       mFirstBuffer = mFirstBuffer->next;
32917:       continue;
32917:     }
32917: 
32917:     // now we have a non-empty buffer
32917:     mFirstBuffer->adjust(mLastWasCR);
80486:     mLastWasCR = false;
32917:     if (mFirstBuffer->hasMore()) {
32917:       mLastWasCR = mTokenizer->tokenizeBuffer(mFirstBuffer);
34979:       // At this point, internalEncodingDeclaration() may have called 
34979:       // Terminate, but that never happens together with script.
34979:       // Can't assert that here, though, because it's possible that the main
34979:       // thread has called Terminate() while this thread was parsing.
81151:       if (mMode == NORMAL && mTreeBuilder->HasScript()) {
34981:         mozilla::MutexAutoLock speculationAutoLock(mSpeculationMutex);
34981:         nsHtml5Speculation* speculation = 
34981:           new nsHtml5Speculation(mFirstBuffer,
34981:                                  mFirstBuffer->getStart(),
35294:                                  mTokenizer->getLineNumber(),
34981:                                  mTreeBuilder->newSnapshot());
35294:         mTreeBuilder->AddSnapshotToScript(speculation->GetSnapshot(), 
35294:                                           speculation->GetStartLineNumber());
41395:         FlushTreeOpsAndDisarmTimer();
34981:         mTreeBuilder->SetOpSink(speculation);
34981:         mSpeculations.AppendElement(speculation); // adopts the pointer
80486:         mSpeculating = true;
34981:       }
34981:       if (IsTerminatedOrInterrupted()) {
34981:         return;
32917:       }
32917:     }
32917:     continue;
32917:   }
32917: }
34979: 
34981: class nsHtml5StreamParserContinuation : public nsRunnable
34980: {
34980: private:
34980:   nsHtml5RefPtr<nsHtml5StreamParser> mStreamParser;
34980: public:
34981:   nsHtml5StreamParserContinuation(nsHtml5StreamParser* aStreamParser)
34980:     : mStreamParser(aStreamParser)
34980:   {}
34980:   NS_IMETHODIMP Run()
34980:   {
34981:     mozilla::MutexAutoLock autoLock(mStreamParser->mTokenizerMutex);
41395:     mStreamParser->Uninterrupt();
34981:     mStreamParser->ParseAvailableData();
34980:     return NS_OK;
34980:   }
34980: };
34980: 
34979: void
34979: nsHtml5StreamParser::ContinueAfterScripts(nsHtml5Tokenizer* aTokenizer, 
34979:                                           nsHtml5TreeBuilder* aTreeBuilder,
79445:                                           bool aLastWasCR)
34979: {
34979:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
81151:   NS_ASSERTION(!(mMode == VIEW_SOURCE_HTML || mMode == VIEW_SOURCE_XML),
81151:       "ContinueAfterScripts called in view source mode!");
80404:   if (mExecutor->IsBroken()) {
80404:     return;
80404:   }
34981:   #ifdef DEBUG
34981:     mExecutor->AssertStageEmpty();
34981:   #endif
79445:   bool speculationFailed = false;
34981:   {
34981:     mozilla::MutexAutoLock speculationAutoLock(mSpeculationMutex);
34981:     if (mSpeculations.IsEmpty()) {
41449:       NS_NOTREACHED("ContinueAfterScripts called without speculations.");
34981:       return;
34981:     }
34981:     nsHtml5Speculation* speculation = mSpeculations.ElementAt(0);
34981:     if (aLastWasCR || 
34981:         !aTokenizer->isInDataState() || 
34981:         !aTreeBuilder->snapshotMatches(speculation->GetSnapshot())) {
80486:       speculationFailed = true;
34981:       // We've got a failed speculation :-(
34981:       Interrupt(); // Make the parser thread release the tokenizer mutex sooner
34981:       // now fall out of the speculationAutoLock into the tokenizerAutoLock block
34981:     } else {
34981:       // We've got a successful speculation!
34981:       if (mSpeculations.Length() > 1) {
34981:         // the first speculation isn't the current speculation, so there's 
34981:         // no need to bother the parser thread.
34981:         speculation->FlushToSink(mExecutor);
39737:         NS_ASSERTION(!mExecutor->IsScriptExecuting(),
39737:           "ParseUntilBlocked() was supposed to ensure we don't come "
39737:           "here when scripts are executing.");
39737:         NS_ASSERTION(mExecutor->IsInFlushLoop(), "How are we here if "
39737:           "RunFlushLoop() didn't call ParseUntilBlocked() which is the "
39737:           "only caller of this method?");
34981:         mSpeculations.RemoveElementAt(0);
34981:         return;
34981:       }
34981:       // else
34981:       Interrupt(); // Make the parser thread release the tokenizer mutex sooner
34979:       
34981:       // now fall through
34981:       // the first speculation is the current speculation. Need to 
34981:       // release the the speculation mutex and acquire the tokenizer 
34981:       // mutex. (Just acquiring the other mutex here would deadlock)
34981:     }
34981:   }
34979:   {
34981:     mozilla::MutexAutoLock tokenizerAutoLock(mTokenizerMutex);
34980:     #ifdef DEBUG
40914:     {
34980:       nsCOMPtr<nsIThread> mainThread;
34980:       NS_GetMainThread(getter_AddRefs(mainThread));
34980:       mAtomTable.SetPermittedLookupThread(mainThread);
40914:     }
34980:     #endif
34981:     // In principle, the speculation mutex should be acquired here,
34981:     // but there's no point, because the parser thread only acquires it
34981:     // when it has also acquired the tokenizer mutex and we are already
34981:     // holding the tokenizer mutex.
34981:     if (speculationFailed) {
34981:       // Rewind the stream
80486:       mAtEOF = false;
34981:       nsHtml5Speculation* speculation = mSpeculations.ElementAt(0);
34981:       mFirstBuffer = speculation->GetBuffer();
34981:       mFirstBuffer->setStart(speculation->GetStart());
35294:       mTokenizer->setLineNumber(speculation->GetStartLineNumber());
46396: 
46396:       nsContentUtils::ReportToConsole(nsContentUtils::eDOM_PROPERTIES,
46396:                                       "SpeculationFailed",
46396:                                       nsnull, 0,
59513:                                       nsnull,
46396:                                       EmptyString(),
46396:                                       speculation->GetStartLineNumber(),
46396:                                       0,
46396:                                       nsIScriptError::warningFlag,
59513:                                       "DOM Events",
59513:                                       mExecutor->GetDocument());
46396: 
80404:       nsHtml5OwningUTF16Buffer* buffer = mFirstBuffer->next;
34981:       while (buffer) {
34981:         buffer->setStart(0);
34981:         buffer = buffer->next;
34981:       }
34979:       
34981:       mSpeculations.Clear(); // potentially a huge number of destructors 
34981:                              // run here synchronously on the main thread...
34981: 
35295:       mTreeBuilder->flushCharacters(); // empty the pending buffer
35295:       mTreeBuilder->ClearOps(); // now get rid of the failed ops
35295: 
34981:       mTreeBuilder->SetOpSink(mExecutor->GetStage());
34981:       mExecutor->StartReadingFromStage();
80486:       mSpeculating = false;
41395: 
34981:       // Copy state over
34979:       mLastWasCR = aLastWasCR;
34979:       mTokenizer->loadState(aTokenizer);
34979:       mTreeBuilder->loadState(aTreeBuilder, &mAtomTable);
34981:     } else {    
34981:       // We've got a successful speculation and at least a moment ago it was
34981:       // the current speculation
34981:       mSpeculations.ElementAt(0)->FlushToSink(mExecutor);
39737:       NS_ASSERTION(!mExecutor->IsScriptExecuting(),
39737:         "ParseUntilBlocked() was supposed to ensure we don't come "
39737:         "here when scripts are executing.");
39737:       NS_ASSERTION(mExecutor->IsInFlushLoop(), "How are we here if "
39737:         "RunFlushLoop() didn't call ParseUntilBlocked() which is the "
39737:         "only caller of this method?");
34981:       mSpeculations.RemoveElementAt(0);
34981:       if (mSpeculations.IsEmpty()) {
34981:         // yes, it was still the only speculation. Now stop speculating
46395:         // However, before telling the executor to read from stage, flush
46395:         // any pending ops straight to the executor, because otherwise
46395:         // they remain unflushed until we get more data from the network.
46395:         mTreeBuilder->SetOpSink(mExecutor);
80486:         mTreeBuilder->Flush(true);
34981:         mTreeBuilder->SetOpSink(mExecutor->GetStage());
34981:         mExecutor->StartReadingFromStage();
80486:         mSpeculating = false;
34981:       }
34981:     }
34981:     nsCOMPtr<nsIRunnable> event = new nsHtml5StreamParserContinuation(this);
34981:     if (NS_FAILED(mThread->Dispatch(event, nsIThread::DISPATCH_NORMAL))) {
41395:       NS_WARNING("Failed to dispatch nsHtml5StreamParserContinuation");
34981:     }
34981:     // A stream event might run before this event runs, but that's harmless.
34980:     #ifdef DEBUG
34980:       mAtomTable.SetPermittedLookupThread(mThread);
34980:     #endif
34979:   }
34979: }
34986: 
34986: void
34986: nsHtml5StreamParser::ContinueAfterFailedCharsetSwitch()
34986: {
34986:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
34986:   nsCOMPtr<nsIRunnable> event = new nsHtml5StreamParserContinuation(this);
34986:   if (NS_FAILED(mThread->Dispatch(event, nsIThread::DISPATCH_NORMAL))) {
35600:     NS_WARNING("Failed to dispatch nsHtml5StreamParserContinuation");
34986:   }
34986: }
35600: 
41395: class nsHtml5TimerKungFu : public nsRunnable
41395: {
41395: private:
41395:   nsHtml5RefPtr<nsHtml5StreamParser> mStreamParser;
41395: public:
41395:   nsHtml5TimerKungFu(nsHtml5StreamParser* aStreamParser)
41395:     : mStreamParser(aStreamParser)
41395:   {}
41395:   NS_IMETHODIMP Run()
41395:   {
41395:     if (mStreamParser->mFlushTimer) {
41395:       mStreamParser->mFlushTimer->Cancel();
41395:       mStreamParser->mFlushTimer = nsnull;
41395:     }
41395:     return NS_OK;
41395:   }
41395: };
41395: 
41395: void
41395: nsHtml5StreamParser::DropTimer()
41395: {
41395:   NS_ASSERTION(NS_IsMainThread(), "Wrong thread!");
41395:   /*
41395:    * Simply nulling out the timer wouldn't work, because if the timer is
41395:    * armed, it needs to be canceled first. Simply canceling it first wouldn't
41395:    * work, because nsTimerImpl::Cancel is not safe for calling from outside
41395:    * the thread where nsTimerImpl::Fire would run. It's not safe to
41395:    * dispatch a runnable to cancel the timer from the destructor of this
41395:    * class, because the timer has a weak (void*) pointer back to this instance
41395:    * of the stream parser and having the timer fire before the runnable
41395:    * cancels it would make the timer access a deleted object.
41395:    *
41395:    * This DropTimer method addresses these issues. This method must be called
41395:    * on the main thread before the destructor of this class is reached.
41395:    * The nsHtml5TimerKungFu object has an nsHtml5RefPtr that addrefs this
41395:    * stream parser object to keep it alive until the runnable is done.
41395:    * The runnable cancels the timer on the parser thread, drops the timer
41395:    * and lets nsHtml5RefPtr send a runnable back to the main thread to
41395:    * release the stream parser.
41395:    */
41395:   if (mFlushTimer) {
41395:     nsCOMPtr<nsIRunnable> event = new nsHtml5TimerKungFu(this);
41395:     if (NS_FAILED(mThread->Dispatch(event, nsIThread::DISPATCH_NORMAL))) {
41395:       NS_WARNING("Failed to dispatch TimerKungFu event");
41395:     }
41395:   }
41395: }
41395: 
35600: // Using a static, because the method name Notify is taken by the chardet 
35600: // callback.
35600: void
35600: nsHtml5StreamParser::TimerCallback(nsITimer* aTimer, void* aClosure)
35600: {
41395:   (static_cast<nsHtml5StreamParser*> (aClosure))->TimerFlush();
35600: }
35600: 
35600: void
35600: nsHtml5StreamParser::TimerFlush()
35600: {
35600:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
41395:   mozilla::MutexAutoLock autoLock(mTokenizerMutex);
35600: 
41395:   NS_ASSERTION(!mSpeculating, "Flush timer fired while speculating.");
41395: 
41395:   // The timer fired if we got here. No need to cancel it. Mark it as
41395:   // not armed, though.
80486:   mFlushTimerArmed = false;
41395: 
80486:   mFlushTimerEverFired = true;
41395: 
41395:   if (IsTerminatedOrInterrupted()) {
35600:     return;
35600:   }
35600: 
81151:   if (mMode == VIEW_SOURCE_HTML || mMode == VIEW_SOURCE_XML) {
81151:     mTreeBuilder->Flush(); // delete useless ops
81151:     if (mTokenizer->FlushViewSource()) {
81151:        if (NS_FAILED(NS_DispatchToMainThread(mExecutorFlusher))) {
81151:          NS_WARNING("failed to dispatch executor flush event");
81151:        }
81151:      }
81151:   } else {
35600:     // we aren't speculating and we don't know when new data is
35600:     // going to arrive. Send data to the main thread.
80486:     if (mTreeBuilder->Flush(true)) {
35600:       if (NS_FAILED(NS_DispatchToMainThread(mExecutorFlusher))) {
35600:         NS_WARNING("failed to dispatch executor flush event");
35600:       }
35600:     }
35600:   }
81151: }
80404: 
80404: void
80404: nsHtml5StreamParser::MarkAsBroken()
80404: {
80404:   NS_ASSERTION(IsParserThread(), "Wrong thread!");
80404:   mTokenizerMutex.AssertCurrentThreadOwns();
80404: 
80404:   Terminate();
80404:   mTreeBuilder->MarkAsBroken();
80486:   mozilla::DebugOnly<bool> hadOps = mTreeBuilder->Flush(false);
80404:   NS_ASSERTION(hadOps, "Should have had the markAsBroken op!");
80404:   if (NS_FAILED(NS_DispatchToMainThread(mExecutorFlusher))) {
80404:     NS_WARNING("failed to dispatch executor flush event");
80404:   }
80404: }
