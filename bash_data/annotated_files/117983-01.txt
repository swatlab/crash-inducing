     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsCOMPtr.h"
     1: #include "nsIAtom.h"
 47649: #include "nsXBLDocumentInfo.h"
     1: #include "nsIInputStream.h"
     1: #include "nsINameSpaceManager.h"
     1: #include "nsHashtable.h"
     1: #include "nsIURI.h"
     1: #include "nsIURL.h"
  1418: #include "nsIDOMEventTarget.h"
     1: #include "nsIChannel.h"
     1: #include "nsXPIDLString.h"
     1: #include "nsReadableUtils.h"
     1: #include "nsNetUtil.h"
     1: #include "plstr.h"
     1: #include "nsIContent.h"
     1: #include "nsIDocument.h"
     1: #include "nsContentUtils.h"
     1: #ifdef MOZ_XUL
     1: #include "nsIXULDocument.h"
     1: #endif
     1: #include "nsIXMLContentSink.h"
     1: #include "nsContentCID.h"
     1: #include "nsXMLDocument.h"
     1: #include "jsapi.h"
     1: #include "nsXBLService.h"
     1: #include "nsXBLInsertionPoint.h"
     1: #include "nsIXPConnect.h"
     1: #include "nsIScriptContext.h"
     1: #include "nsCRT.h"
     1: 
     1: // Event listeners
 72328: #include "nsEventListenerManager.h"
 75045: #include "nsIDOMEventListener.h"
     1: #include "nsAttrName.h"
     1: 
     1: #include "nsGkAtoms.h"
     1: 
     1: #include "nsIDOMAttr.h"
     1: #include "nsIDOMNamedNodeMap.h"
     1: 
     1: #include "nsXBLPrototypeHandler.h"
     1: 
     1: #include "nsXBLPrototypeBinding.h"
     1: #include "nsXBLBinding.h"
     1: #include "nsIPrincipal.h"
     1: #include "nsIScriptSecurityManager.h"
     1: #include "nsGUIEvent.h"
     1: 
     1: #include "prprf.h"
     1: #include "nsNodeUtils.h"
     1: 
  6392: // Nasty hack.  Maybe we could move some of the classinfo utility methods
102364: // (e.g. WrapNative) over to nsContentUtils?
  6392: #include "nsDOMClassInfo.h"
  6392: #include "nsJSUtils.h"
  6392: 
 74131: #include "mozilla/dom/Element.h"
 74131: 
     1: // Helper classes
     1: 
     1: /***********************************************************************/
     1: //
     1: // The JS class for XBLBinding
     1: //
 18907: static void
 94738: XBLFinalize(JSFreeOp *fop, JSObject *obj)
     1: {
 47649:   nsXBLDocumentInfo* docInfo =
 89826:     static_cast<nsXBLDocumentInfo*>(::JS_GetPrivate(obj));
117983:   xpc::DeferredRelease(static_cast<nsIScriptGlobalObjectOwner*>(docInfo));
  6392:   
 89430:   nsXBLJSClass* c = static_cast<nsXBLJSClass*>(::JS_GetClass(obj));
     1:   c->Drop();
     1: }
     1: 
102658: // XBL fields are represented on elements inheriting that field a bit trickily.
102658: // Initially the element itself won't have a property for the field.  When an
102658: // attempt is made to access the field, the element's resolve hook won't find
102658: // it.  But the XBL prototype object, in the prototype chain of the element,
102658: // will resolve an accessor property for the field on the XBL prototype object.
102658: // That accessor, when used, will then (via InstallXBLField below) reify a
102658: // property for the field onto the actual XBL-backed element.
102658: //
102658: // The accessor property is a plain old property backed by a getter function and
102658: // a setter function.  These properties are backed by the FieldGetter and
102658: // FieldSetter natives; they're created by XBLResolve.  The precise field to be
102658: // reified is identified using two extra slots on the getter/setter functions.
102658: // XBLPROTO_SLOT stores the XBL prototype object that provides the field.
102658: // FIELD_SLOT stores the name of the field, i.e. its JavaScript property name.
102658: //
102658: // This two-step field installation process -- reify an accessor on the
102658: // prototype, then have that reify an own property on the actual element -- is
102658: // admittedly convoluted.  Better would be for XBL-backed elements to be proxies
102658: // that could resolve fields onto themselves.  But given that XBL bindings are
102658: // associated with elements mutably -- you can add/remove/change -moz-binding
102658: // whenever you want, alas -- doing so would require all elements to be proxies,
102658: // which isn't performant now.  So we do this two-step instead.
102658: static const uint32_t XBLPROTO_SLOT = 0;
102658: static const uint32_t FIELD_SLOT = 1;
102658: 
108554: bool
105479: ValueHasISupportsPrivate(const JS::Value &v)
102658: {
105479:   if (!v.isObject()) {
105479:     return false;
105479:   }
105479: 
105479:   JSClass* clasp = ::JS_GetClass(&v.toObject());
102658:   const uint32_t HAS_PRIVATE_NSISUPPORTS =
102658:     JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS;
102658:   return (clasp->flags & HAS_PRIVATE_NSISUPPORTS) == HAS_PRIVATE_NSISUPPORTS;
102658: }
102658: 
102658: // Define a shadowing property on |this| for the XBL field defined by the
102658: // contents of the callee's reserved slots.  If the property was defined,
102658: // *installed will be true, and idp will be set to the property name that was
102658: // defined.
102658: static JSBool
102658: InstallXBLField(JSContext* cx,
102658:                 JS::Handle<JSObject*> callee, JS::Handle<JSObject*> thisObj,
102658:                 jsid* idp, bool* installed)
102658: {
102658:   *installed = false;
102658: 
102658:   // First ensure |this| is a reasonable XBL bound node.
102658:   //
102658:   // FieldAccessorGuard already determined whether |thisObj| was acceptable as
102658:   // |this| in terms of not throwing a TypeError.  Assert this for good measure.
105479:   MOZ_ASSERT(ValueHasISupportsPrivate(JS::ObjectValue(*thisObj)));
102658: 
102658:   // But there are some cases where we must accept |thisObj| but not install a
102658:   // property on it, or otherwise touch it.  Hence this split of |this|-vetting
102658:   // duties.
102658:   nsCOMPtr<nsIXPConnectWrappedNative> xpcWrapper =
102658:     do_QueryInterface(static_cast<nsISupports*>(::JS_GetPrivate(thisObj)));
102658:   if (!xpcWrapper) {
102658:     // Looks like whatever |thisObj| is it's not our nsIContent.  It might well
102658:     // be the proto our binding installed, however, where the private is the
102658:     // nsXBLDocumentInfo, so just baul out quietly.  Do NOT throw an exception
102658:     // here.
102658:     //
102658:     // We could make this stricter by checking the class maybe, but whatever.
102658:     return true;
102658:   }
102658: 
102658:   nsCOMPtr<nsIContent> xblNode = do_QueryWrappedNative(xpcWrapper);
102658:   if (!xblNode) {
102658:     xpc::Throw(cx, NS_ERROR_UNEXPECTED);
102658:     return false;
102658:   }
102658: 
102658:   // Now that |this| is okay, actually install the field.  Some of this
102658:   // installation work could have been done in XBLResolve, but this splitting
102658:   // of work seems simplest to implement and friendliest regarding lifetimes
102658:   // and potential cycles.
102658: 
102658:   // Because of the possibility (due to XBL binding inheritance, because each
102658:   // XBL binding lives in its own global object) that |this| might be in a
102658:   // different compartment from the callee (not to mention that this method can
102658:   // be called with an arbitrary |this| regardless of how insane XBL is), and
102658:   // because in this method we've entered |this|'s compartment (see in
102658:   // Field[GS]etter where we attempt a cross-compartment call), we must enter
102658:   // the callee's compartment to access its reserved slots.
102658:   nsXBLPrototypeBinding* protoBinding;
102658:   nsDependentJSString fieldName;
102658:   {
109257:     JSAutoCompartment ac(cx, callee);
102658: 
115032:     js::Rooted<JSObject*> xblProto(cx);
102658:     xblProto = &js::GetFunctionNativeReserved(callee, XBLPROTO_SLOT).toObject();
102658: 
102658:     JS::Value name = js::GetFunctionNativeReserved(callee, FIELD_SLOT);
102658:     JSFlatString* fieldStr = JS_ASSERT_STRING_IS_FLAT(name.toString());
102658:     fieldName.init(fieldStr);
102658: 
102658:     MOZ_ALWAYS_TRUE(JS_ValueToId(cx, name, idp));
102658: 
102658:     JS::Value slotVal = ::JS_GetReservedSlot(xblProto, 0);
102658:     protoBinding = static_cast<nsXBLPrototypeBinding*>(slotVal.toPrivate());
102658:     MOZ_ASSERT(protoBinding);
102658:   }
102658: 
102658:   nsXBLProtoImplField* field = protoBinding->FindField(fieldName);
102658:   MOZ_ASSERT(field);
102658: 
102658:   // This mirrors code in nsXBLProtoImpl::InstallImplementation
102658:   nsIScriptGlobalObject* global = xblNode->OwnerDoc()->GetScriptGlobalObject();
102658:   if (!global) {
102658:     return true;
102658:   }
102658: 
102658:   nsCOMPtr<nsIScriptContext> context = global->GetContext();
102658:   if (!context) {
102658:     return true;
102658:   }
102658: 
102658:   nsresult rv = field->InstallField(context, thisObj, xblNode->NodePrincipal(),
102658:                                     protoBinding->DocURI(), installed);
102658:   if (NS_SUCCEEDED(rv)) {
102658:     return true;
102658:   }
102658: 
102658:   if (!::JS_IsExceptionPending(cx)) {
102658:     xpc::Throw(cx, rv);
102658:   }
102658:   return false;
102658: }
102658: 
108554: bool
105479: FieldGetterImpl(JSContext *cx, JS::CallArgs args)
102658: {
105479:   const JS::Value &thisv = args.thisv();
105479:   MOZ_ASSERT(ValueHasISupportsPrivate(thisv));
102658: 
115032:   js::Rooted<JSObject*> thisObj(cx, &thisv.toObject());
102658: 
102658:   bool installed = false;
115032:   js::Rooted<JSObject*> callee(cx, &args.calleev().toObject());
115032:   js::Rooted<jsid> id(cx);
102658:   if (!InstallXBLField(cx, callee, thisObj, id.address(), &installed)) {
102658:     return false;
102658:   }
102658: 
102658:   if (!installed) {
106862:     args.rval().setUndefined();
102658:     return true;
102658:   }
102658: 
115032:   js::Rooted<JS::Value> v(cx);
102658:   if (!JS_GetPropertyById(cx, thisObj, id, v.address())) {
102658:     return false;
102658:   }
106862:   args.rval().set(v);
102658:   return true;
102658: }
102658: 
102658: static JSBool
105479: FieldGetter(JSContext *cx, unsigned argc, JS::Value *vp)
102658: {
105479:   JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
108554:   return JS::CallNonGenericMethod<ValueHasISupportsPrivate, FieldGetterImpl>
108554:                                  (cx, args);
102658: }
102658: 
108554: bool
105479: FieldSetterImpl(JSContext *cx, JS::CallArgs args)
105479: {
105479:   const JS::Value &thisv = args.thisv();
105479:   MOZ_ASSERT(ValueHasISupportsPrivate(thisv));
105479: 
115032:   js::Rooted<JSObject*> thisObj(cx, &thisv.toObject());
105479: 
102658:   bool installed = false;
115032:   js::Rooted<JSObject*> callee(cx, &args.calleev().toObject());
115032:   js::Rooted<jsid> id(cx);
102658:   if (!InstallXBLField(cx, callee, thisObj, id.address(), &installed)) {
102658:     return false;
102658:   }
102658: 
117298:   if (installed) {
115032:     js::Rooted<JS::Value> v(cx,
105479:                             args.length() > 0 ? args[0] : JS::UndefinedValue());
117298:     if (!::JS_SetPropertyById(cx, thisObj, id, v.address())) {
117298:       return false;
117298:     }
117298:   }
117298:   args.rval().setUndefined();
117298:   return true;
102658: }
102658: 
 18907: static JSBool
105479: FieldSetter(JSContext *cx, unsigned argc, JS::Value *vp)
105479: {
105479:   JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
108554:   return JS::CallNonGenericMethod<ValueHasISupportsPrivate, FieldSetterImpl>
108554:                                  (cx, args);
105479: }
105479: 
105479: static JSBool
 98960: XBLResolve(JSContext *cx, JSHandleObject obj, JSHandleId id, unsigned flags,
103636:            JSMutableHandleObject objp)
  6392: {
103636:   objp.set(NULL);
  6392: 
 48470:   if (!JSID_IS_STRING(id)) {
102658:     return true;
  6392:   }
  6392: 
102658:   nsXBLPrototypeBinding* protoBinding =
102658:     static_cast<nsXBLPrototypeBinding*>(::JS_GetReservedSlot(obj, 0).toPrivate());
102658:   MOZ_ASSERT(protoBinding);
102658: 
102658:   // If the field's not present, don't resolve it.  Also don't resolve it if the
102658:   // field is empty; see also nsXBLProtoImplField::InstallField which also must
102658:   // implement the not-empty requirement.
  6392:   nsDependentJSString fieldName(id);
  6392:   nsXBLProtoImplField* field = protoBinding->FindField(fieldName);
102658:   if (!field || field->IsEmpty()) {
102658:     return true;
  6392:   }
  6392: 
102658:   // We have a field: now install a getter/setter pair which will resolve the
102658:   // field onto the actual object, when invoked.
115032:   js::Rooted<JSObject*> global(cx, JS_GetGlobalForObject(cx, obj));
102658: 
115032:   js::Rooted<JSObject*> get(cx);
102658:   get = ::JS_GetFunctionObject(js::NewFunctionByIdWithReserved(cx, FieldGetter,
102658:                                                                0, 0, global,
102658:                                                                id));
102658:   if (!get) {
102658:     return false;
102658:   }
102658:   js::SetFunctionNativeReserved(get, XBLPROTO_SLOT, JS::ObjectValue(*obj));
102658:   js::SetFunctionNativeReserved(get, FIELD_SLOT,
102658:                                 JS::StringValue(JSID_TO_STRING(id)));
102658: 
115032:   js::Rooted<JSObject*> set(cx);
102658:   set = ::JS_GetFunctionObject(js::NewFunctionByIdWithReserved(cx, FieldSetter,
102658:                                                                1, 0, global,
102658:                                                                id));
102658:   if (!set) {
102658:     return false;
102658:   }
102658:   js::SetFunctionNativeReserved(set, XBLPROTO_SLOT, JS::ObjectValue(*obj));
102658:   js::SetFunctionNativeReserved(set, FIELD_SLOT,
102658:                                 JS::StringValue(JSID_TO_STRING(id)));
102658: 
102658:   if (!::JS_DefinePropertyById(cx, obj, id, JS::UndefinedValue(),
103637:                                JS_DATA_TO_FUNC_PTR(JSPropertyOp, get.get()),
103637:                                JS_DATA_TO_FUNC_PTR(JSStrictPropertyOp, set.get()),
102658:                                field->AccessorAttributes())) {
102658:     return false;
  6392:   }
  6392: 
103636:   objp.set(obj);
102658:   return true;
  6392: }
  6392: 
102658: static JSBool
102658: XBLEnumerate(JSContext *cx, JS::Handle<JSObject*> obj)
102658: {
102658:   nsXBLPrototypeBinding* protoBinding =
102658:     static_cast<nsXBLPrototypeBinding*>(::JS_GetReservedSlot(obj, 0).toPrivate());
102658:   MOZ_ASSERT(protoBinding);
  6392: 
102658:   return protoBinding->ResolveAllFields(cx, obj);
  6392: }
  6392: 
     1: nsXBLJSClass::nsXBLJSClass(const nsAFlatCString& aClassName)
     1: {
     1:   memset(this, 0, sizeof(nsXBLJSClass));
  3233:   next = prev = static_cast<JSCList*>(this);
     1:   name = ToNewCString(aClassName);
  6392:   flags =
  6392:     JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS |
102658:     JSCLASS_NEW_RESOLVE |
  6392:     // Our one reserved slot holds the relevant nsXBLPrototypeBinding
  6392:     JSCLASS_HAS_RESERVED_SLOTS(1);
 62397:   addProperty = delProperty = getProperty = ::JS_PropertyStub;
 62397:   setProperty = ::JS_StrictPropertyStub;
102658:   enumerate = XBLEnumerate;
  6392:   resolve = (JSResolveOp)XBLResolve;
     1:   convert = ::JS_ConvertStub;
     1:   finalize = XBLFinalize;
     1: }
     1: 
     1: nsrefcnt
     1: nsXBLJSClass::Destroy()
     1: {
  3233:   NS_ASSERTION(next == prev && prev == static_cast<JSCList*>(this),
     1:                "referenced nsXBLJSClass is on LRU list already!?");
     1: 
     1:   if (nsXBLService::gClassTable) {
     1:     nsCStringKey key(name);
     1:     (nsXBLService::gClassTable)->Remove(&key);
     1:   }
     1: 
     1:   if (nsXBLService::gClassLRUListLength >= nsXBLService::gClassLRUListQuota) {
     1:     // Over LRU list quota, just unhash and delete this class.
     1:     delete this;
     1:   } else {
     1:     // Put this most-recently-used class on end of the LRU-sorted freelist.
  3233:     JSCList* mru = static_cast<JSCList*>(this);
     1:     JS_APPEND_LINK(mru, &nsXBLService::gClassLRUList);
     1:     nsXBLService::gClassLRUListLength++;
     1:   }
     1: 
     1:   return 0;
     1: }
     1: 
     1: // Implementation /////////////////////////////////////////////////////////////////
     1: 
     1: // Constructors/Destructors
     1: nsXBLBinding::nsXBLBinding(nsXBLPrototypeBinding* aBinding)
 96762:   : mIsStyleBinding(true),
 96762:     mMarkedForDeath(false),
 96762:     mPrototypeBinding(aBinding),
106838:     mInsertionPointTable(nullptr)
     1: {
     1:   NS_ASSERTION(mPrototypeBinding, "Must have a prototype binding!");
     1:   // Grab a ref to the document info so the prototype binding won't die
     1:   NS_ADDREF(mPrototypeBinding->XBLDocumentInfo());
     1: }
     1: 
     1: 
     1: nsXBLBinding::~nsXBLBinding(void)
     1: {
 23385:   if (mContent) {
 80526:     nsXBLBinding::UninstallAnonymousContent(mContent->OwnerDoc(), mContent);
 23385:   }
     1:   delete mInsertionPointTable;
 47649:   nsXBLDocumentInfo* info = mPrototypeBinding->XBLDocumentInfo();
     1:   NS_RELEASE(info);
     1: }
     1: 
 20261: static PLDHashOperator
  1829: TraverseKey(nsISupports* aKey, nsInsertionPointList* aData, void* aClosure)
  1829: {
  1829:   nsCycleCollectionTraversalCallback &cb = 
  3233:     *static_cast<nsCycleCollectionTraversalCallback*>(aClosure);
  1829: 
 13202:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mInsertionPointTable key");
  1829:   cb.NoteXPCOMChild(aKey);
  1829:   if (aData) {
 13202:     NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSTARRAY(*aData, nsXBLInsertionPoint,
 13202:                                                "mInsertionPointTable value")
  1829:   }
  1829:   return PL_DHASH_NEXT;
  1829: }
  1829: 
102293: NS_IMPL_CYCLE_COLLECTION_NATIVE_CLASS(nsXBLBinding)
  1829: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_NATIVE(nsXBLBinding)
  1829:   // XXX Probably can't unlink mPrototypeBinding->XBLDocumentInfo(), because
  1829:   //     mPrototypeBinding is weak.
 23385:   if (tmp->mContent) {
 80526:     nsXBLBinding::UninstallAnonymousContent(tmp->mContent->OwnerDoc(),
 23385:                                             tmp->mContent);
 23385:   }
  1829:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContent)
 72202:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mNextBinding)
 72202:   delete tmp->mInsertionPointTable;
106838:   tmp->mInsertionPointTable = nullptr;
  1829: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
  1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsXBLBinding)
 87968:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb,
 87968:                                      "mPrototypeBinding->XBLDocumentInfo()");
 57794:   cb.NoteXPCOMChild(static_cast<nsIScriptGlobalObjectOwner*>(
 57794:                       tmp->mPrototypeBinding->XBLDocumentInfo()));
  1829:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContent)
  1829:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mNextBinding, nsXBLBinding)
  1829:   if (tmp->mInsertionPointTable)
  1829:     tmp->mInsertionPointTable->EnumerateRead(TraverseKey, &cb);
  1829: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
  1829: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsXBLBinding, AddRef)
  1829: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsXBLBinding, Release)
  1829: 
     1: void
     1: nsXBLBinding::SetBaseBinding(nsXBLBinding* aBinding)
     1: {
     1:   if (mNextBinding) {
     1:     NS_ERROR("Base XBL binding is already defined!");
     1:     return;
     1:   }
     1: 
     1:   mNextBinding = aBinding; // Comptr handles rel/add
     1: }
     1: 
     1: void
116970: nsXBLBinding::InstallAnonymousContent(nsIContent* aAnonParent, nsIContent* aElement,
116970:                                       bool aChromeOnlyContent)
     1: {
     1:   // We need to ensure two things.
     1:   // (1) The anonymous content should be fooled into thinking it's in the bound
     1:   // element's document, assuming that the bound element is in a document
     1:   // Note that we don't change the current doc of aAnonParent here, since that
     1:   // quite simply does not matter.  aAnonParent is just a way of keeping refs
     1:   // to all its kids, which are anonymous content from the point of view of
     1:   // aElement.
     1:   // (2) The children's parent back pointer should not be to this synthetic root
     1:   // but should instead point to the enclosing parent element.
     1:   nsIDocument* doc = aElement->GetCurrentDoc();
 79445:   bool allowScripts = AllowScripts();
     1: 
 14228:   nsAutoScriptBlocker scriptBlocker;
 78992:   for (nsIContent* child = aAnonParent->GetFirstChild();
 78992:        child;
 78992:        child = child->GetNextSibling()) {
     1:     child->UnbindFromTree();
116970:     if (aChromeOnlyContent) {
116970:       child->SetFlags(NODE_CHROME_ONLY_ACCESS |
116970:                       NODE_IS_ROOT_OF_CHROME_ONLY_ACCESS);
116970:     }
     1:     nsresult rv =
     1:       child->BindToTree(doc, aElement, mBoundElement, allowScripts);
     1:     if (NS_FAILED(rv)) {
     1:       // Oh, well... Just give up.
     1:       // XXXbz This really shouldn't be a void method!
     1:       child->UnbindFromTree();
     1:       return;
     1:     }        
     1: 
 25511:     child->SetFlags(NODE_IS_ANONYMOUS);
 25511: 
     1: #ifdef MOZ_XUL
     1:     // To make XUL templates work (and other goodies that happen when
     1:     // an element is added to a XUL document), we need to notify the
     1:     // XUL document using its special API.
     1:     nsCOMPtr<nsIXULDocument> xuldoc(do_QueryInterface(doc));
     1:     if (xuldoc)
     1:       xuldoc->AddSubtreeToDocument(child);
     1: #endif
     1:   }
     1: }
     1: 
     1: void
 23385: nsXBLBinding::UninstallAnonymousContent(nsIDocument* aDocument,
 23385:                                         nsIContent* aAnonParent)
 23385: {
 23385:   nsAutoScriptBlocker scriptBlocker;
 23385:   // Hold a strong ref while doing this, just in case.
 23385:   nsCOMPtr<nsIContent> anonParent = aAnonParent;
 23385: #ifdef MOZ_XUL
 23385:   nsCOMPtr<nsIXULDocument> xuldoc =
 23385:     do_QueryInterface(aDocument);
 23385: #endif
 78992:   for (nsIContent* child = aAnonParent->GetFirstChild();
 78992:        child;
 78992:        child = child->GetNextSibling()) {
 23385:     child->UnbindFromTree();
 23385: #ifdef MOZ_XUL
 23385:     if (xuldoc) {
 23385:       xuldoc->RemoveSubtreeFromDocument(child);
 23385:     }
 23385: #endif
 23385:   }
 23385: }
 23385: 
 23385: void
     1: nsXBLBinding::SetBoundElement(nsIContent* aElement)
     1: {
     1:   mBoundElement = aElement;
     1:   if (mNextBinding)
     1:     mNextBinding->SetBoundElement(aElement);
     1: }
     1: 
 79445: bool
     1: nsXBLBinding::HasStyleSheets() const
     1: {
     1:   // Find out if we need to re-resolve style.  We'll need to do this
     1:   // if we have additional stylesheets in our binding document.
     1:   if (mPrototypeBinding->HasStyleSheets())
 80486:     return true;
     1: 
 80486:   return mNextBinding ? mNextBinding->HasStyleSheets() : false;
     1: }
     1: 
     1: struct EnumData {
     1:   nsXBLBinding* mBinding;
     1:  
     1:   EnumData(nsXBLBinding* aBinding)
     1:     :mBinding(aBinding)
   731:   {}
     1: };
     1: 
     1: struct ContentListData : public EnumData {
     1:   nsBindingManager* mBindingManager;
     1:   nsresult          mRv;
     1: 
     1:   ContentListData(nsXBLBinding* aBinding, nsBindingManager* aManager)
     1:     :EnumData(aBinding), mBindingManager(aManager), mRv(NS_OK)
   731:   {}
     1: };
     1: 
 20261: static PLDHashOperator
     1: BuildContentLists(nsISupports* aKey,
     1:                   nsAutoPtr<nsInsertionPointList>& aData,
     1:                   void* aClosure)
     1: {
     1:   ContentListData* data = (ContentListData*)aClosure;
     1:   nsBindingManager* bm = data->mBindingManager;
     1:   nsXBLBinding* binding = data->mBinding;
     1: 
     1:   nsIContent *boundElement = binding->GetBoundElement();
     1: 
108991:   int32_t count = aData->Length();
     1:   
     1:   if (count == 0)
     1:     return PL_DHASH_NEXT;
     1: 
     1:   // Figure out the relevant content node.
     1:   nsXBLInsertionPoint* currPoint = aData->ElementAt(0);
     1:   nsCOMPtr<nsIContent> parent = currPoint->GetInsertionParent();
  6864:   if (!parent) {
  6864:     data->mRv = NS_ERROR_FAILURE;
  6864:     return PL_DHASH_STOP;
  6864:   }
108991:   int32_t currIndex = currPoint->GetInsertionIndex();
     1: 
 64110:   // XXX Could this array just be altered in place and passed directly to
 64110:   // SetContentListFor?  We'd save space if we could pull this off.
 64110:   nsInsertionPointList* contentList = new nsInsertionPointList;
 64110:   if (!contentList) {
 64110:     data->mRv = NS_ERROR_OUT_OF_MEMORY;
 64110:     return PL_DHASH_STOP;
 64110:   }
 64110: 
     1:   nsCOMPtr<nsIDOMNodeList> nodeList;
     1:   if (parent == boundElement) {
     1:     // We are altering anonymous nodes to accommodate insertion points.
     1:     nodeList = binding->GetAnonymousNodes();
     1:   }
     1:   else {
     1:     // We are altering the explicit content list of a node to accommodate insertion points.
     1:     nsCOMPtr<nsIDOMNode> node(do_QueryInterface(parent));
     1:     node->GetChildNodes(getter_AddRefs(nodeList));
     1:   }
     1: 
106838:   nsXBLInsertionPoint* pseudoPoint = nullptr;
108991:   uint32_t childCount;
     1:   nodeList->GetLength(&childCount);
108991:   int32_t j = 0;
     1: 
108991:   for (uint32_t i = 0; i < childCount; i++) {
     1:     nsCOMPtr<nsIDOMNode> node;
     1:     nodeList->Item(i, getter_AddRefs(node));
     1:     nsCOMPtr<nsIContent> child(do_QueryInterface(node));
108991:     if (((int32_t)i) == currIndex) {
     1:       // Add the currPoint to the insertion point list.
     1:       contentList->AppendElement(currPoint);
     1: 
     1:       // Get the next real insertion point and update our currIndex.
     1:       j++;
     1:       if (j < count) {
     1:         currPoint = aData->ElementAt(j);
     1:         currIndex = currPoint->GetInsertionIndex();
     1:       }
     1: 
     1:       // Null out our current pseudo-point.
106838:       pseudoPoint = nullptr;
     1:     }
     1:     
     1:     if (!pseudoPoint) {
108991:       pseudoPoint = new nsXBLInsertionPoint(parent, (uint32_t) -1, nullptr);
     1:       if (pseudoPoint) {
     1:         contentList->AppendElement(pseudoPoint);
     1:       }
     1:     }
     1:     if (pseudoPoint) {
     1:       pseudoPoint->AddChild(child);
     1:     }
     1:   }
     1: 
     1:   // Add in all the remaining insertion points.
     1:   contentList->AppendElements(aData->Elements() + j, count - j);
     1:   
     1:   // Now set the content list using the binding manager,
     1:   // If the bound element is the parent, then we alter the anonymous node list
     1:   // instead.  This allows us to always maintain two distinct lists should
     1:   // insertion points be nested into an inner binding.
     1:   if (parent == boundElement)
     1:     bm->SetAnonymousNodesFor(parent, contentList);
     1:   else 
     1:     bm->SetContentListFor(parent, contentList);
     1:   return PL_DHASH_NEXT;
     1: }
     1: 
 20261: static PLDHashOperator
     1: RealizeDefaultContent(nsISupports* aKey,
     1:                       nsAutoPtr<nsInsertionPointList>& aData,
     1:                       void* aClosure)
     1: {
     1:   ContentListData* data = (ContentListData*)aClosure;
     1:   nsBindingManager* bm = data->mBindingManager;
     1:   nsXBLBinding* binding = data->mBinding;
     1: 
108991:   int32_t count = aData->Length();
     1:  
108991:   for (int32_t i = 0; i < count; i++) {
     1:     nsXBLInsertionPoint* currPoint = aData->ElementAt(i);
108991:     int32_t insCount = currPoint->ChildCount();
     1:     
     1:     if (insCount == 0) {
     1:       nsCOMPtr<nsIContent> defContent = currPoint->GetDefaultContentTemplate();
     1:       if (defContent) {
     1:         // We need to take this template and use it to realize the
     1:         // actual default content (through cloning).
     1:         // Clone this insertion point element.
     1:         nsCOMPtr<nsIContent> insParent = currPoint->GetInsertionParent();
  6864:         if (!insParent) {
  6864:           data->mRv = NS_ERROR_FAILURE;
  6864:           return PL_DHASH_STOP;
  6864:         }
 80526:         nsIDocument *document = insParent->OwnerDoc();
     1:         nsCOMPtr<nsIDOMNode> clonedNode;
     1:         nsCOMArray<nsINode> nodesWithProperties;
 80486:         nsNodeUtils::Clone(defContent, true, document->NodeInfoManager(),
     1:                            nodesWithProperties, getter_AddRefs(clonedNode));
     1: 
     1:         // Now that we have the cloned content, install the default content as
     1:         // if it were additional anonymous content.
     1:         nsCOMPtr<nsIContent> clonedContent(do_QueryInterface(clonedNode));
116970:         binding->InstallAnonymousContent(clonedContent, insParent,
116970:                                          binding->PrototypeBinding()->
116970:                                            ChromeOnlyContent());
     1: 
     1:         // Cache the clone so that it can be properly destroyed if/when our
     1:         // other anonymous content is destroyed.
     1:         currPoint->SetDefaultContent(clonedContent);
     1: 
     1:         // Now make sure the kids of the clone are added to the insertion point as
     1:         // children.
 78992:         for (nsIContent* child = clonedContent->GetFirstChild();
 78992:              child;
 78992:              child = child->GetNextSibling()) {
 78992:           bm->SetInsertionParent(child, insParent);
 78992:           currPoint->AddChild(child);
     1:         }
     1:       }
     1:     }
     1:   }
     1: 
     1:   return PL_DHASH_NEXT;
     1: }
     1: 
 20261: static PLDHashOperator
     1: ChangeDocumentForDefaultContent(nsISupports* aKey,
     1:                                 nsAutoPtr<nsInsertionPointList>& aData,
     1:                                 void* aClosure)
     1: {
108991:   int32_t count = aData->Length();
108991:   for (int32_t i = 0; i < count; i++) {
 10861:     aData->ElementAt(i)->UnbindDefaultContent();
     1:   }
     1: 
     1:   return PL_DHASH_NEXT;
     1: }
     1: 
     1: void
     1: nsXBLBinding::GenerateAnonymousContent()
     1: {
 35002:   NS_ASSERTION(!nsContentUtils::IsSafeToRunScript(),
 35002:                "Someone forgot a script blocker");
 35002: 
     1:   // Fetch the content element for this binding.
     1:   nsIContent* content =
     1:     mPrototypeBinding->GetImmediateChild(nsGkAtoms::content);
     1: 
     1:   if (!content) {
     1:     // We have no anonymous content.
     1:     if (mNextBinding)
     1:       mNextBinding->GenerateAnonymousContent();
     1: 
     1:     return;
     1:   }
     1:      
     1:   // Find out if we're really building kids or if we're just
     1:   // using the attribute-setting shorthand hack.
108991:   uint32_t contentCount = content->GetChildCount();
     1: 
     1:   // Plan to build the content by default.
 79445:   bool hasContent = (contentCount > 0);
 79445:   bool hasInsertionPoints = mPrototypeBinding->HasInsertionPoints();
     1: 
     1: #ifdef DEBUG
     1:   // See if there's an includes attribute.
     1:   if (nsContentUtils::HasNonEmptyAttr(content, kNameSpaceID_None,
     1:                                       nsGkAtoms::includes)) {
110974:     nsAutoCString message("An XBL Binding with URI ");
110974:     nsAutoCString uri;
     1:     mPrototypeBinding->BindingURI()->GetSpec(uri);
     1:     message += uri;
     1:     message += " is still using the deprecated\n<content includes=\"\"> syntax! Use <children> instead!\n"; 
     1:     NS_WARNING(message.get());
     1:   }
     1: #endif
     1: 
     1:   if (hasContent || hasInsertionPoints) {
 80526:     nsIDocument* doc = mBoundElement->OwnerDoc();
     1:     
     1:     nsBindingManager *bindingManager = doc->BindingManager();
     1: 
     1:     nsCOMPtr<nsIDOMNodeList> children;
     1:     bindingManager->GetContentListFor(mBoundElement, getter_AddRefs(children));
     1:  
     1:     nsCOMPtr<nsIDOMNode> node;
     1:     nsCOMPtr<nsIContent> childContent;
108991:     uint32_t length;
     1:     children->GetLength(&length);
     1:     if (length > 0 && !hasInsertionPoints) {
     1:       // There are children being placed underneath us, but we have no specified
     1:       // insertion points, and therefore no place to put the kids.  Don't generate
     1:       // anonymous content.
     1:       // Special case template and observes.
108991:       for (uint32_t i = 0; i < length; i++) {
     1:         children->Item(i, getter_AddRefs(node));
     1:         childContent = do_QueryInterface(node);
     1: 
 94340:         nsINodeInfo *ni = childContent->NodeInfo();
     1:         nsIAtom *localName = ni->NameAtom();
     1:         if (ni->NamespaceID() != kNameSpaceID_XUL ||
     1:             (localName != nsGkAtoms::observes &&
     1:              localName != nsGkAtoms::_template)) {
 80486:           hasContent = false;
     1:           break;
     1:         }
     1:       }
     1:     }
     1: 
     1:     if (hasContent || hasInsertionPoints) {
     1:       nsCOMPtr<nsIDOMNode> clonedNode;
     1:       nsCOMArray<nsINode> nodesWithProperties;
 80486:       nsNodeUtils::Clone(content, true, doc->NodeInfoManager(),
     1:                          nodesWithProperties, getter_AddRefs(clonedNode));
     1: 
     1:       mContent = do_QueryInterface(clonedNode);
116970:       InstallAnonymousContent(mContent, mBoundElement,
116970:                               mPrototypeBinding->ChromeOnlyContent());
     1: 
     1:       if (hasInsertionPoints) {
     1:         // Now check and see if we have a single insertion point 
     1:         // or multiple insertion points.
     1:       
     1:         // Enumerate the prototype binding's insertion table to build
     1:         // our table of instantiated insertion points.
     1:         mPrototypeBinding->InstantiateInsertionPoints(this);
     1: 
     1:         // We now have our insertion point table constructed.  We
     1:         // enumerate this table.  For each array of insertion points
     1:         // bundled under the same content node, we generate a content
     1:         // list.  In the case of the bound element, we generate a new
     1:         // anonymous node list that will be used in place of the binding's
     1:         // cached anonymous node list.
     1:         ContentListData data(this, bindingManager);
     1:         mInsertionPointTable->Enumerate(BuildContentLists, &data);
     1:         if (NS_FAILED(data.mRv)) {
     1:           return;
     1:         }
     1: 
     1:         // We need to place the children
     1:         // at their respective insertion points.
108991:         uint32_t index = 0;
 79445:         bool multiplePoints = false;
     1:         nsIContent *singlePoint = GetSingleInsertionPoint(&index,
     1:                                                           &multiplePoints);
     1:       
     1:         if (children) {
     1:           if (multiplePoints) {
     1:             // We must walk the entire content list in order to determine where
     1:             // each child belongs.
     1:             children->GetLength(&length);
108991:             for (uint32_t i = 0; i < length; i++) {
     1:               children->Item(i, getter_AddRefs(node));
     1:               childContent = do_QueryInterface(node);
     1: 
     1:               // Now determine the insertion point in the prototype table.
108991:               uint32_t index;
     1:               nsIContent *point = GetInsertionPoint(childContent, &index);
     1:               bindingManager->SetInsertionParent(childContent, point);
     1: 
     1:               // Find the correct nsIXBLInsertion point in our table.
106838:               nsInsertionPointList* arr = nullptr;
     1:               GetInsertionPointsFor(point, &arr);
106838:               nsXBLInsertionPoint* insertionPoint = nullptr;
108991:               int32_t arrCount = arr->Length();
108991:               for (int32_t j = 0; j < arrCount; j++) {
     1:                 insertionPoint = arr->ElementAt(j);
     1:                 if (insertionPoint->Matches(point, index))
     1:                   break;
106838:                 insertionPoint = nullptr;
     1:               }
     1: 
     1:               if (insertionPoint) 
     1:                 insertionPoint->AddChild(childContent);
     1:               else {
     1:                 // We were unable to place this child.  All anonymous content
     1:                 // should be thrown out.  Special-case template and observes.
     1: 
 94340:                 nsINodeInfo *ni = childContent->NodeInfo();
     1:                 nsIAtom *localName = ni->NameAtom();
     1:                 if (ni->NamespaceID() != kNameSpaceID_XUL ||
     1:                     (localName != nsGkAtoms::observes &&
     1:                      localName != nsGkAtoms::_template)) {
 22958:                   // Undo InstallAnonymousContent
 23385:                   UninstallAnonymousContent(doc, mContent);
 22958: 
     1:                   // Kill all anonymous content.
106838:                   mContent = nullptr;
106838:                   bindingManager->SetContentListFor(mBoundElement, nullptr);
106838:                   bindingManager->SetAnonymousNodesFor(mBoundElement, nullptr);
     1:                   return;
     1:                 }
     1:               }
     1:             }
     1:           }
     1:           else {
     1:             // All of our children are shunted to this single insertion point.
106838:             nsInsertionPointList* arr = nullptr;
     1:             GetInsertionPointsFor(singlePoint, &arr);
     1:             nsXBLInsertionPoint* insertionPoint = arr->ElementAt(0);
     1:         
     1:             nsCOMPtr<nsIDOMNode> node;
     1:             nsCOMPtr<nsIContent> content;
108991:             uint32_t length;
     1:             children->GetLength(&length);
     1:           
108991:             for (uint32_t i = 0; i < length; i++) {
     1:               children->Item(i, getter_AddRefs(node));
     1:               content = do_QueryInterface(node);
     1:               bindingManager->SetInsertionParent(content, singlePoint);
     1:               insertionPoint->AddChild(content);
     1:             }
     1:           }
     1:         }
     1: 
     1:         // Now that all of our children have been added, we need to walk all of our
     1:         // nsIXBLInsertion points to see if any of them have default content that
     1:         // needs to be built.
     1:         mInsertionPointTable->Enumerate(RealizeDefaultContent, &data);
     1:         if (NS_FAILED(data.mRv)) {
     1:           return;
     1:         }
     1:       }
     1:     }
     1: 
     1:     mPrototypeBinding->SetInitialAttributes(mBoundElement, mContent);
     1:   }
     1: 
     1:   // Always check the content element for potential attributes.
     1:   // This shorthand hack always happens, even when we didn't
     1:   // build anonymous content.
     1:   const nsAttrName* attrName;
108991:   for (uint32_t i = 0; (attrName = content->GetAttrNameAt(i)); ++i) {
108991:     int32_t namespaceID = attrName->NamespaceID();
 13301:     // Hold a strong reference here so that the atom doesn't go away during
 13301:     // UnsetAttr.
 13301:     nsCOMPtr<nsIAtom> name = attrName->LocalName();
     1: 
     1:     if (name != nsGkAtoms::includes) {
     1:       if (!nsContentUtils::HasNonEmptyAttr(mBoundElement, namespaceID, name)) {
     1:         nsAutoString value2;
     1:         content->GetAttr(namespaceID, name, value2);
     1:         mBoundElement->SetAttr(namespaceID, name, attrName->GetPrefix(),
 80486:                                value2, false);
     1:       }
     1:     }
     1: 
     1:     // Conserve space by wiping the attributes off the clone.
     1:     if (mContent)
 80486:       mContent->UnsetAttr(namespaceID, name, false);
     1:   }
     1: }
     1: 
     1: void
     1: nsXBLBinding::InstallEventHandlers()
     1: {
     1:   // Don't install handlers if scripts aren't allowed.
     1:   if (AllowScripts()) {
     1:     // Fetch the handlers prototypes for this binding.
     1:     nsXBLPrototypeHandler* handlerChain = mPrototypeBinding->GetPrototypeHandlers();
     1: 
     1:     if (handlerChain) {
 72328:       nsEventListenerManager* manager =
 80486:         mBoundElement->GetListenerManager(true);
     1:       if (!manager)
     1:         return;
     1: 
 79445:       bool isChromeDoc =
 80526:         nsContentUtils::IsChromeDoc(mBoundElement->OwnerDoc());
 79445:       bool isChromeBinding = mPrototypeBinding->IsChrome();
     1:       nsXBLPrototypeHandler* curr;
     1:       for (curr = handlerChain; curr; curr = curr->GetNextHandler()) {
     1:         // Fetch the event type.
     1:         nsCOMPtr<nsIAtom> eventAtom = curr->GetEventName();
     1:         if (!eventAtom ||
     1:             eventAtom == nsGkAtoms::keyup ||
     1:             eventAtom == nsGkAtoms::keydown ||
     1:             eventAtom == nsGkAtoms::keypress)
     1:           continue;
     1: 
     1:         nsXBLEventHandler* handler = curr->GetEventHandler();
     1:         if (handler) {
     1:           // Figure out if we're using capturing or not.
108991:           int32_t flags = (curr->GetPhase() == NS_PHASE_CAPTURING) ?
     1:             NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
     1: 
 72330:           // If this is a command, add it in the system event group
 72330:           if ((curr->GetType() & (NS_HANDLER_TYPE_XBL_COMMAND |
 72330:                                   NS_HANDLER_TYPE_SYSTEM)) &&
 72330:               (isChromeBinding || mBoundElement->IsInNativeAnonymousSubtree())) {
 72330:             flags |= NS_EVENT_FLAG_SYSTEM_EVENT;
 72330:           }
 72330: 
 79445:           bool hasAllowUntrustedAttr = curr->HasAllowUntrustedAttr();
   541:           if ((hasAllowUntrustedAttr && curr->AllowUntrustedEvents()) ||
   541:               (!hasAllowUntrustedAttr && !isChromeDoc)) {
     1:             flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
     1:           }
     1: 
 39101:           manager->AddEventListenerByType(handler,
 39101:                                           nsDependentAtomString(eventAtom),
 72331:                                           flags);
     1:         }
     1:       }
     1: 
     1:       const nsCOMArray<nsXBLKeyEventHandler>* keyHandlers =
     1:         mPrototypeBinding->GetKeyEventHandlers();
108991:       int32_t i;
     1:       for (i = 0; i < keyHandlers->Count(); ++i) {
     1:         nsXBLKeyEventHandler* handler = keyHandlers->ObjectAt(i);
   541:         handler->SetIsBoundToChrome(isChromeDoc);
     1: 
     1:         nsAutoString type;
     1:         handler->GetEventName(type);
     1: 
     1:         // If this is a command, add it in the system event group, otherwise 
     1:         // add it to the standard event group.
     1: 
     1:         // Figure out if we're using capturing or not.
108991:         int32_t flags = (handler->GetPhase() == NS_PHASE_CAPTURING) ?
     1:           NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
     1: 
 72330:         if ((handler->GetType() & (NS_HANDLER_TYPE_XBL_COMMAND |
 72330:                                    NS_HANDLER_TYPE_SYSTEM)) &&
 72330:             (isChromeBinding || mBoundElement->IsInNativeAnonymousSubtree())) {
 72330:           flags |= NS_EVENT_FLAG_SYSTEM_EVENT;
 72330:         }
 72330: 
     1:         // For key handlers we have to set NS_PRIV_EVENT_UNTRUSTED_PERMITTED flag.
     1:         // Whether the handling of the event is allowed or not is handled in
     1:         // nsXBLKeyEventHandler::HandleEvent
     1:         flags |= NS_PRIV_EVENT_UNTRUSTED_PERMITTED;
     1: 
 72331:         manager->AddEventListenerByType(handler, type, flags);
     1:       }
     1:     }
     1:   }
     1: 
     1:   if (mNextBinding)
     1:     mNextBinding->InstallEventHandlers();
     1: }
     1: 
     1: nsresult
     1: nsXBLBinding::InstallImplementation()
     1: {
     1:   // Always install the base class properties first, so that
     1:   // derived classes can reference the base class properties.
     1: 
     1:   if (mNextBinding) {
     1:     nsresult rv = mNextBinding->InstallImplementation();
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1:   
     1:   // iterate through each property in the prototype's list and install the property.
     1:   if (AllowScripts())
     1:     return mPrototypeBinding->InstallImplementation(mBoundElement);
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: nsIAtom*
108991: nsXBLBinding::GetBaseTag(int32_t* aNameSpaceID)
     1: {
     1:   nsIAtom *tag = mPrototypeBinding->GetBaseTag(aNameSpaceID);
     1:   if (!tag && mNextBinding)
     1:     return mNextBinding->GetBaseTag(aNameSpaceID);
     1: 
     1:   return tag;
     1: }
     1: 
     1: void
108991: nsXBLBinding::AttributeChanged(nsIAtom* aAttribute, int32_t aNameSpaceID,
 79445:                                bool aRemoveFlag, bool aNotify)
     1: {
     1:   // XXX Change if we ever allow multiple bindings in a chain to contribute anonymous content
     1:   if (!mContent) {
     1:     if (mNextBinding)
     1:       mNextBinding->AttributeChanged(aAttribute, aNameSpaceID,
     1:                                      aRemoveFlag, aNotify);
     1:   } else {
     1:     mPrototypeBinding->AttributeChanged(aAttribute, aNameSpaceID, aRemoveFlag,
     1:                                         mBoundElement, mContent, aNotify);
     1:   }
     1: }
     1: 
     1: void
     1: nsXBLBinding::ExecuteAttachedHandler()
     1: {
     1:   if (mNextBinding)
     1:     mNextBinding->ExecuteAttachedHandler();
     1: 
 71642:   if (AllowScripts())
     1:     mPrototypeBinding->BindingAttached(mBoundElement);
     1: }
     1: 
     1: void
     1: nsXBLBinding::ExecuteDetachedHandler()
     1: {
     1:   if (AllowScripts())
     1:     mPrototypeBinding->BindingDetached(mBoundElement);
     1: 
     1:   if (mNextBinding)
     1:     mNextBinding->ExecuteDetachedHandler();
     1: }
     1: 
     1: void
     1: nsXBLBinding::UnhookEventHandlers()
     1: {
     1:   nsXBLPrototypeHandler* handlerChain = mPrototypeBinding->GetPrototypeHandlers();
     1: 
     1:   if (handlerChain) {
 72328:     nsEventListenerManager* manager =
 80486:       mBoundElement->GetListenerManager(false);
  8069:     if (!manager) {
  8069:       return;
  8069:     }
  8069:                                       
 79445:     bool isChromeBinding = mPrototypeBinding->IsChrome();
     1:     nsXBLPrototypeHandler* curr;
     1:     for (curr = handlerChain; curr; curr = curr->GetNextHandler()) {
     1:       nsXBLEventHandler* handler = curr->GetCachedEventHandler();
  8069:       if (!handler) {
  8069:         continue;
  8069:       }
  8069:       
     1:       nsCOMPtr<nsIAtom> eventAtom = curr->GetEventName();
     1:       if (!eventAtom ||
     1:           eventAtom == nsGkAtoms::keyup ||
     1:           eventAtom == nsGkAtoms::keydown ||
     1:           eventAtom == nsGkAtoms::keypress)
     1:         continue;
     1: 
     1:       // Figure out if we're using capturing or not.
108991:       int32_t flags = (curr->GetPhase() == NS_PHASE_CAPTURING) ?
  8069:         NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
     1: 
  8069:       // If this is a command, remove it from the system event group,
  8069:       // otherwise remove it from the standard event group.
     1: 
 72330:       if ((curr->GetType() & (NS_HANDLER_TYPE_XBL_COMMAND |
 72330:                               NS_HANDLER_TYPE_SYSTEM)) &&
 29471:           (isChromeBinding || mBoundElement->IsInNativeAnonymousSubtree())) {
 72330:         flags |= NS_EVENT_FLAG_SYSTEM_EVENT;
     1:       }
     1: 
 39101:       manager->RemoveEventListenerByType(handler,
 39101:                                          nsDependentAtomString(eventAtom),
 72331:                                          flags);
     1:     }
     1: 
     1:     const nsCOMArray<nsXBLKeyEventHandler>* keyHandlers =
     1:       mPrototypeBinding->GetKeyEventHandlers();
108991:     int32_t i;
     1:     for (i = 0; i < keyHandlers->Count(); ++i) {
     1:       nsXBLKeyEventHandler* handler = keyHandlers->ObjectAt(i);
     1: 
     1:       nsAutoString type;
     1:       handler->GetEventName(type);
     1: 
     1:       // Figure out if we're using capturing or not.
108991:       int32_t flags = (handler->GetPhase() == NS_PHASE_CAPTURING) ?
  8069:         NS_EVENT_FLAG_CAPTURE : NS_EVENT_FLAG_BUBBLE;
     1: 
     1:       // If this is a command, remove it from the system event group, otherwise 
     1:       // remove it from the standard event group.
     1: 
 29471:       if ((handler->GetType() & (NS_HANDLER_TYPE_XBL_COMMAND | NS_HANDLER_TYPE_SYSTEM)) &&
 29471:           (isChromeBinding || mBoundElement->IsInNativeAnonymousSubtree())) {
 72330:         flags |= NS_EVENT_FLAG_SYSTEM_EVENT;
     1:       }
     1: 
 72331:       manager->RemoveEventListenerByType(handler, type, flags);
     1:     }
     1:   }
     1: }
     1: 
     1: void
     1: nsXBLBinding::ChangeDocument(nsIDocument* aOldDocument, nsIDocument* aNewDocument)
     1: {
     1:   if (aOldDocument != aNewDocument) {
  7064:     // Only style bindings get their prototypes unhooked.  First do ourselves.
     1:     if (mIsStyleBinding) {
     1:       // Now the binding dies.  Unhook our prototypes.
  7064:       if (mPrototypeBinding->HasImplementation()) { 
  7064:         nsIScriptGlobalObject *global = aOldDocument->GetScopeObject();
     1:         if (global) {
 41890:           JSObject *scope = global->GetGlobalJSObject();
 41890:           // scope might be null if we've cycle-collected the global
 41890:           // object, since the Unlink phase of cycle collection happens
 41890:           // after JS GC finalization.  But in that case, we don't care
 41890:           // about fixing the prototype chain, since everything's going
 41890:           // away immediately.
 41890: 
  7144:           nsCOMPtr<nsIScriptContext> context = global->GetContext();
 41890:           if (context && scope) {
 78415:             JSContext *cx = context->GetNativeContext();
     1:  
 26165:             nsCxPusher pusher;
 26165:             pusher.Push(cx);
 26165: 
 59876:             nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
 59876:             nsIXPConnect *xpc = nsContentUtils::XPConnect();
 31981:             nsresult rv =
 59876:               xpc->GetWrappedNativeOfNativeObject(cx, scope, mBoundElement,
 59876:                                                   NS_GET_IID(nsISupports),
     1:                                                   getter_AddRefs(wrapper));
     1:             if (NS_FAILED(rv))
     1:               return;
     1: 
 59876:             JSObject* scriptObject;
 59876:             if (wrapper)
 59876:                 wrapper->GetJSObject(&scriptObject);
 59876:             else
106838:                 scriptObject = nullptr;
     1: 
 59876:             if (scriptObject) {
     1:               // XXX Stay in sync! What if a layered binding has an
     1:               // <interface>?!
  7064:               // XXXbz what does that comment mean, really?  It seems to date
  7064:               // back to when there was such a thing as an <interface>, whever
  7064:               // that was...
     1: 
  7064:               // Find the right prototype.
  7064:               JSObject* base = scriptObject;
  7064:               JSObject* proto;
  7064:               JSAutoRequest ar(cx);
109257:               JSAutoCompartment ac(cx, scriptObject);
 55601: 
  7064:               for ( ; true; base = proto) { // Will break out on null proto
115023:                 if (!JS_GetPrototype(cx, base, &proto)) {
115023:                   return;
115023:                 }
  7064:                 if (!proto) {
  7064:                   break;
  7064:                 }
  7064: 
 89430:                 JSClass* clazz = ::JS_GetClass(proto);
  7064:                 if (!clazz ||
  7064:                     (~clazz->flags &
  7064:                      (JSCLASS_HAS_PRIVATE | JSCLASS_PRIVATE_IS_NSISUPPORTS)) ||
 53969:                     JSCLASS_RESERVED_SLOTS(clazz) != 1 ||
 53969:                     clazz->resolve != (JSResolveOp)XBLResolve ||
 53969:                     clazz->finalize != XBLFinalize) {
  7064:                   // Clearly not the right class
  7064:                   continue;
  7064:                 }
  7064: 
 47649:                 nsRefPtr<nsXBLDocumentInfo> docInfo =
 89826:                   static_cast<nsXBLDocumentInfo*>(::JS_GetPrivate(proto));
  7064:                 if (!docInfo) {
  7064:                   // Not the proto we seek
  7064:                   continue;
  7064:                 }
  7064: 
 89826:                 jsval protoBinding = ::JS_GetReservedSlot(proto, 0);
  7064: 
  7064:                 if (JSVAL_TO_PRIVATE(protoBinding) != mPrototypeBinding) {
  7064:                   // Not the right binding
  7064:                   continue;
  7064:                 }
  7064: 
  7064:                 // Alright!  This is the right prototype.  Pull it out of the
  7064:                 // proto chain.
115023:                 JSObject* grandProto;
115023:                 if (!JS_GetPrototype(cx, proto, &grandProto)) {
115023:                   return;
115023:                 }
  7064:                 ::JS_SetPrototype(cx, base, grandProto);
  7064:                 break;
     1:               }
     1: 
  7144:               mPrototypeBinding->UndefineFields(cx, scriptObject);
  7144: 
     1:               // Don't remove the reference from the document to the
     1:               // wrapper here since it'll be removed by the element
     1:               // itself when that's taken out of the document.
     1:             }
     1:           }
     1:         }
 59876:       }
  8069: 
  8069:       // Remove our event handlers
  8069:       UnhookEventHandlers();
     1:     }
     1: 
 35002:     {
 35002:       nsAutoScriptBlocker scriptBlocker;
 35002: 
  7064:       // Then do our ancestors.  This reverses the construction order, so that at
  7064:       // all times things are consistent as far as everyone is concerned.
  7064:       if (mNextBinding) {
  7064:         mNextBinding->ChangeDocument(aOldDocument, aNewDocument);
  7064:       }
  7064: 
     1:       // Update the anonymous content.
  7064:       // XXXbz why not only for style bindings?
     1:       nsIContent *anonymous = mContent;
     1:       if (anonymous) {
     1:         // Also kill the default content within all our insertion points.
     1:         if (mInsertionPointTable)
     1:           mInsertionPointTable->Enumerate(ChangeDocumentForDefaultContent,
106838:                                           nullptr);
     1: 
 23385:         nsXBLBinding::UninstallAnonymousContent(aOldDocument, anonymous);
     1:       }
     1: 
     1:       // Make sure that henceforth we don't claim that mBoundElement's children
     1:       // have insertion parents in the old document.
     1:       nsBindingManager* bindingManager = aOldDocument->BindingManager();
 78992:       for (nsIContent* child = mBoundElement->GetLastChild();
 78992:            child;
 78992:            child = child->GetPreviousSibling()) {
106838:         bindingManager->SetInsertionParent(child, nullptr);
     1:       }
     1:     }
     1:   }
 35002: }
     1: 
 79445: bool
     1: nsXBLBinding::InheritsStyle() const
     1: {
     1:   // XXX Will have to change if we ever allow multiple bindings to contribute anonymous content.
     1:   // Most derived binding with anonymous content determines style inheritance for now.
     1: 
     1:   // XXX What about bindings with <content> but no kids, e.g., my treecell-text binding?
     1:   if (mContent)
     1:     return mPrototypeBinding->InheritsStyle();
     1:   
     1:   if (mNextBinding)
     1:     return mNextBinding->InheritsStyle();
     1: 
 80486:   return true;
     1: }
     1: 
     1: void
     1: nsXBLBinding::WalkRules(nsIStyleRuleProcessor::EnumFunc aFunc, void* aData)
     1: {
     1:   if (mNextBinding)
     1:     mNextBinding->WalkRules(aFunc, aData);
     1: 
     1:   nsIStyleRuleProcessor *rules = mPrototypeBinding->GetRuleProcessor();
     1:   if (rules)
     1:     (*aFunc)(rules, aData);
     1: }
     1: 
     1: // Internal helper methods ////////////////////////////////////////////////////////////////
     1: 
     1: // static
     1: nsresult
     1: nsXBLBinding::DoInitJSClass(JSContext *cx, JSObject *global, JSObject *obj,
     1:                             const nsAFlatCString& aClassName,
  6392:                             nsXBLPrototypeBinding* aProtoBinding,
 82305:                             JSObject** aClassObject)
     1: {
     1:   // First ensure our JS class is initialized.
110974:   nsAutoCString className(aClassName);
106838:   JSObject* parent_proto = nullptr;  // If we have an "obj" we can set this
     1:   JSAutoRequest ar(cx);
 55601: 
109257:   JSAutoCompartment ac(cx, global);
 55601: 
     1:   if (obj) {
     1:     // Retrieve the current prototype of obj.
115023:     if (!JS_GetPrototype(cx, obj, &parent_proto)) {
115023:       return NS_ERROR_FAILURE;
115023:     }
     1:     if (parent_proto) {
     1:       // We need to create a unique classname based on aClassName and
     1:       // parent_proto.  Append a space (an invalid URI character) to ensure that
     1:       // we don't have accidental collisions with the case when parent_proto is
     1:       // null and aClassName ends in some bizarre numbers (yeah, it's unlikely).
     1:       jsid parent_proto_id;
     1:       if (!::JS_GetObjectId(cx, parent_proto, &parent_proto_id)) {
     1:         // Probably OOM
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:       }
     1: 
     1:       // One space, maybe "0x", at most 16 chars (on a 64-bit system) of long,
     1:       // and a null-terminator (which PR_snprintf ensures is there even if the
     1:       // string representation of what we're printing does not fit in the buffer
     1:       // provided).
     1:       char buf[20];
     1:       PR_snprintf(buf, sizeof(buf), " %lx", parent_proto_id);
     1:       className.Append(buf);
     1:     }
     1:   }
     1: 
 82305:   jsval val;
 82305:   JSObject* proto = NULL;
 99447:   if ((!::JS_LookupPropertyWithFlags(cx, global, className.get(), 0, &val)) ||
     1:       JSVAL_IS_PRIMITIVE(val)) {
     1:     // We need to initialize the class.
     1: 
     1:     nsXBLJSClass* c;
     1:     void* classObject;
     1:     nsCStringKey key(className);
     1:     classObject = (nsXBLService::gClassTable)->Get(&key);
     1: 
     1:     if (classObject) {
  3233:       c = static_cast<nsXBLJSClass*>(classObject);
     1: 
     1:       // If c is on the LRU list (i.e., not linked to itself), remove it now!
  3233:       JSCList* link = static_cast<JSCList*>(c);
     1:       if (c->next != link) {
     1:         JS_REMOVE_AND_INIT_LINK(link);
     1:         nsXBLService::gClassLRUListLength--;
     1:       }
     1:     } else {
     1:       if (JS_CLIST_IS_EMPTY(&nsXBLService::gClassLRUList)) {
     1:         // We need to create a struct for this class.
     1:         c = new nsXBLJSClass(className);
     1: 
     1:         if (!c)
     1:           return NS_ERROR_OUT_OF_MEMORY;
     1:       } else {
     1:         // Pull the least recently used class struct off the list.
     1:         JSCList* lru = (nsXBLService::gClassLRUList).next;
     1:         JS_REMOVE_AND_INIT_LINK(lru);
     1:         nsXBLService::gClassLRUListLength--;
     1: 
     1:         // Remove any mapping from the old name to the class struct.
  3233:         c = static_cast<nsXBLJSClass*>(lru);
     1:         nsCStringKey oldKey(c->name);
     1:         (nsXBLService::gClassTable)->Remove(&oldKey);
     1: 
     1:         // Change the class name and we're done.
     1:         nsMemory::Free((void*) c->name);
     1:         c->name = ToNewCString(className);
     1:       }
     1: 
     1:       // Add c to our table.
     1:       (nsXBLService::gClassTable)->Put(&key, (void*)c);
     1:     }
     1: 
     1:     // The prototype holds a strong reference to its class struct.
     1:     c->Hold();
     1: 
     1:     // Make a new object prototyped by parent_proto and parented by global.
     1:     proto = ::JS_InitClass(cx,                  // context
     1:                            global,              // global object
     1:                            parent_proto,        // parent proto 
     1:                            c,                   // JSClass
106838:                            nullptr,              // JSNative ctor
     1:                            0,                   // ctor args
106838:                            nullptr,              // proto props
106838:                            nullptr,              // proto funcs
106838:                            nullptr,              // ctor props (static)
106838:                            nullptr);             // ctor funcs (static)
     1:     if (!proto) {
     1:       // This will happen if we're OOM or if the security manager
     1:       // denies defining the new class...
     1: 
     1:       (nsXBLService::gClassTable)->Remove(&key);
     1: 
     1:       c->Drop();
     1: 
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:     }
     1: 
  6392:     // Keep this proto binding alive while we're alive.  Do this first so that
  6392:     // we can guarantee that in XBLFinalize this will be non-null.
 53969:     // Note that we can't just store aProtoBinding in the private and
 53969:     // addref/release the nsXBLDocumentInfo through it, because cycle
 53969:     // collection doesn't seem to work right if the private is not an
 53969:     // nsISupports.
 47649:     nsXBLDocumentInfo* docInfo = aProtoBinding->XBLDocumentInfo();
 89826:     ::JS_SetPrivate(proto, docInfo);
  6392:     NS_ADDREF(docInfo);
  6392: 
 89826:     ::JS_SetReservedSlot(proto, 0, PRIVATE_TO_JSVAL(aProtoBinding));
  6392: 
 82305:     *aClassObject = proto;
     1:   }
     1:   else {
     1:     proto = JSVAL_TO_OBJECT(val);
     1:   }
     1: 
     1:   if (obj) {
     1:     // Set the prototype of our object to be the new class.
     1:     if (!::JS_SetPrototype(cx, obj, proto)) {
     1:       return NS_ERROR_FAILURE;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
 79445: bool
     1: nsXBLBinding::AllowScripts()
     1: {
 47650:   if (!mPrototypeBinding->GetAllowScripts())
 80486:     return false;
     1: 
     1:   // Nasty hack.  Use the JSContext of the bound node, since the
     1:   // security manager API expects to get the docshell type from
     1:   // that.  But use the nsIPrincipal of our document.
     1:   nsIScriptSecurityManager* mgr = nsContentUtils::GetSecurityManager();
     1:   if (!mgr) {
 80486:     return false;
     1:   }
     1: 
106838:   nsIDocument* doc = mBoundElement ? mBoundElement->OwnerDoc() : nullptr;
     1:   if (!doc) {
 80486:     return false;
     1:   }
     1: 
     1:   nsIScriptGlobalObject* global = doc->GetScriptGlobalObject();
     1:   if (!global) {
 80486:     return false;
     1:   }
     1: 
     1:   nsCOMPtr<nsIScriptContext> context = global->GetContext();
     1:   if (!context) {
 80486:     return false;
     1:   }
     1:   
 78415:   JSContext* cx = context->GetNativeContext();
     1: 
 47650:   nsCOMPtr<nsIDocument> ourDocument =
 47650:     mPrototypeBinding->XBLDocumentInfo()->GetDocument();
 79445:   bool canExecute;
     1:   nsresult rv =
     1:     mgr->CanExecuteScripts(cx, ourDocument->NodePrincipal(), &canExecute);
116912:   return NS_SUCCEEDED(rv) && canExecute;
     1: }
     1: 
  6864: void
  6864: nsXBLBinding::RemoveInsertionParent(nsIContent* aParent)
  6864: {
  6864:   if (mNextBinding) {
  6864:     mNextBinding->RemoveInsertionParent(aParent);
  6864:   }
  6864:   if (mInsertionPointTable) {
106838:     nsInsertionPointList* list = nullptr;
  6864:     mInsertionPointTable->Get(aParent, &list);
  6864:     if (list) {
108991:       int32_t count = list->Length();
108991:       for (int32_t i = 0; i < count; ++i) {
  6864:         nsRefPtr<nsXBLInsertionPoint> currPoint = list->ElementAt(i);
 10861:         currPoint->UnbindDefaultContent();
  6864: #ifdef DEBUG
  6864:         nsCOMPtr<nsIContent> parent = currPoint->GetInsertionParent();
  6864:         NS_ASSERTION(!parent || parent == aParent, "Wrong insertion parent!");
  6864: #endif
  6864:         currPoint->ClearInsertionParent();
  6864:       }
  6864:       mInsertionPointTable->Remove(aParent);
  6864:     }
  6864:   }
  6864: }
  6864: 
 79445: bool
  6864: nsXBLBinding::HasInsertionParent(nsIContent* aParent)
  6864: {
  6864:   if (mInsertionPointTable) {
106838:     nsInsertionPointList* list = nullptr;
  6864:     mInsertionPointTable->Get(aParent, &list);
  6864:     if (list) {
 80486:       return true;
  6864:     }
  6864:   }
 80486:   return mNextBinding ? mNextBinding->HasInsertionParent(aParent) : false;
  6864: }
  6864: 
101616: void
     1: nsXBLBinding::GetInsertionPointsFor(nsIContent* aParent,
     1:                                     nsInsertionPointList** aResult)
     1: {
     1:   if (!mInsertionPointTable) {
     1:     mInsertionPointTable =
     1:       new nsClassHashtable<nsISupportsHashKey, nsInsertionPointList>;
 98908:     mInsertionPointTable->Init(4);
     1:   }
     1: 
     1:   mInsertionPointTable->Get(aParent, aResult);
     1: 
     1:   if (!*aResult) {
     1:     *aResult = new nsInsertionPointList;
 98908:     mInsertionPointTable->Put(aParent, *aResult);
  6864:     if (aParent) {
  6864:       aParent->SetFlags(NODE_IS_INSERTION_PARENT);
  6864:     }
     1:   }
     1: }
     1: 
  1685: nsInsertionPointList*
  1685: nsXBLBinding::GetExistingInsertionPointsFor(nsIContent* aParent)
  1685: {
  1685:   if (!mInsertionPointTable) {
106838:     return nullptr;
  1685:   }
  1685: 
106838:   nsInsertionPointList* result = nullptr;
  1685:   mInsertionPointTable->Get(aParent, &result);
  1685:   return result;
  1685: }
  1685: 
     1: nsIContent*
108991: nsXBLBinding::GetInsertionPoint(const nsIContent* aChild, uint32_t* aIndex)
     1: {
     1:   if (mContent) {
     1:     return mPrototypeBinding->GetInsertionPoint(mBoundElement, mContent,
     1:                                                 aChild, aIndex);
     1:   }
     1: 
     1:   if (mNextBinding)
     1:     return mNextBinding->GetInsertionPoint(aChild, aIndex);
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: nsIContent*
108991: nsXBLBinding::GetSingleInsertionPoint(uint32_t* aIndex,
 79445:                                       bool* aMultipleInsertionPoints)
     1: {
 80486:   *aMultipleInsertionPoints = false;
     1:   if (mContent) {
     1:     return mPrototypeBinding->GetSingleInsertionPoint(mBoundElement, mContent, 
     1:                                                       aIndex, 
     1:                                                       aMultipleInsertionPoints);
     1:   }
     1: 
     1:   if (mNextBinding)
     1:     return mNextBinding->GetSingleInsertionPoint(aIndex,
     1:                                                  aMultipleInsertionPoints);
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: nsXBLBinding*
     1: nsXBLBinding::RootBinding()
     1: {
     1:   if (mNextBinding)
     1:     return mNextBinding->RootBinding();
     1: 
     1:   return this;
     1: }
     1: 
     1: nsXBLBinding*
     1: nsXBLBinding::GetFirstStyleBinding()
     1: {
     1:   if (mIsStyleBinding)
     1:     return this;
     1: 
106838:   return mNextBinding ? mNextBinding->GetFirstStyleBinding() : nullptr;
     1: }
     1: 
 79445: bool
  6392: nsXBLBinding::ResolveAllFields(JSContext *cx, JSObject *obj) const
  6392: {
  6392:   if (!mPrototypeBinding->ResolveAllFields(cx, obj)) {
 80486:     return false;
  6392:   }
  6392: 
  6392:   if (mNextBinding) {
  6392:     return mNextBinding->ResolveAllFields(cx, obj);
  6392:   }
  6392: 
 80486:   return true;
  6392: }
  6392: 
     1: void
     1: nsXBLBinding::MarkForDeath()
     1: {
 80486:   mMarkedForDeath = true;
     1:   ExecuteDetachedHandler();
     1: }
     1: 
 79445: bool
     1: nsXBLBinding::ImplementsInterface(REFNSIID aIID) const
     1: {
     1:   return mPrototypeBinding->ImplementsInterface(aIID) ||
     1:     (mNextBinding && mNextBinding->ImplementsInterface(aIID));
     1: }
     1: 
 24403: nsINodeList*
     1: nsXBLBinding::GetAnonymousNodes()
     1: {
     1:   if (mContent) {
 24403:     return mContent->GetChildNodesList();
     1:   }
     1: 
     1:   if (mNextBinding)
     1:     return mNextBinding->GetAnonymousNodes();
     1: 
106838:   return nullptr;
     1: }
