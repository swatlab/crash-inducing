    1: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Places.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Google Inc.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Brian Ryner <bryner@brianryner.com> (original author)
33704:  *   Dietrich Ayala <dietrich@mozilla.com>
23593:  *   Drew Willcoxon <adw@mozilla.com>
33704:  *   Marco Bonardo <mak77@bonardo.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "nsAppDirectoryServiceDefs.h"
    1: #include "nsNavBookmarks.h"
    1: #include "nsNavHistory.h"
    1: #include "mozStorageHelper.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsNetUtil.h"
 4179: #include "nsIDynamicContainer.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsFaviconService.h"
    1: #include "nsAnnotationService.h"
  338: #include "nsPrintfCString.h"
 4004: #include "nsIUUIDGenerator.h"
 4004: #include "prprf.h"
10669: #include "nsILivemarkService.h"
16356: #include "nsPlacesTriggers.h"
16361: #include "nsPlacesTables.h"
28193: #include "nsPlacesIndexes.h"
30050: #include "nsPlacesMacros.h"
    1: 
    1: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_ID = 0;
  338: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_Type = 1;
21350: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_PlaceID = 2;
    1: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_Parent = 3;
    1: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_Position = 4;
    1: const PRInt32 nsNavBookmarks::kFindBookmarksIndex_Title = 5;
    1: 
    1: // These columns sit to the right of the kGetInfoIndex_* columns.
33458: const PRInt32 nsNavBookmarks::kGetChildrenIndex_Position = 13;
33458: const PRInt32 nsNavBookmarks::kGetChildrenIndex_Type = 14;
33458: const PRInt32 nsNavBookmarks::kGetChildrenIndex_PlaceID = 15;
33458: const PRInt32 nsNavBookmarks::kGetChildrenIndex_ServiceContractId = 16;
    1: 
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_ID = 0;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_URI = 1;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_Title = 2;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_Position = 3;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_PlaceID = 4;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_Parent = 5;
 1297: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_Type = 6;
 4179: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_ServiceContractId = 7;
 1604: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_DateAdded = 8;
 1604: const PRInt32 nsNavBookmarks::kGetItemPropertiesIndex_LastModified = 9;
    1: 
29518: const PRInt32 nsNavBookmarks::kInsertBookmarkIndex_Id = 0;
29518: const PRInt32 nsNavBookmarks::kInsertBookmarkIndex_PlaceId = 1;
29518: const PRInt32 nsNavBookmarks::kInsertBookmarkIndex_Type = 2;
29518: const PRInt32 nsNavBookmarks::kInsertBookmarkIndex_Parent = 3;
29518: const PRInt32 nsNavBookmarks::kInsertBookmarkIndex_Position = 4;
29518: const PRInt32 nsNavBookmarks::kInsertBookmarkIndex_Title = 5;
29518: const PRInt32 nsNavBookmarks::kInsertBookmarkIndex_ServiceContractId = 6;
29518: const PRInt32 nsNavBookmarks::kInsertBookmarkIndex_DateAdded = 7;
29518: const PRInt32 nsNavBookmarks::kInsertBookmarkIndex_LastModified = 8;
29518: 
35298: PLACES_FACTORY_SINGLETON_IMPLEMENTATION(nsNavBookmarks, gBookmarksService)
    1: 
    1: #define BOOKMARKS_ANNO_PREFIX "bookmarks/"
 2049: #define BOOKMARKS_TOOLBAR_FOLDER_ANNO NS_LITERAL_CSTRING(BOOKMARKS_ANNO_PREFIX "toolbarFolder")
 4004: #define GUID_ANNO NS_LITERAL_CSTRING("placesInternal/GUID")
 4179: #define READ_ONLY_ANNO NS_LITERAL_CSTRING("placesInternal/READ_ONLY")
    1: 
33458: nsNavBookmarks::nsNavBookmarks() : mItemCount(0)
33458:                                  , mRoot(0)
33458:                                  , mBookmarksRoot(0)
33458:                                  , mTagRoot(0)
33458:                                  , mToolbarFolder(0)
33458:                                  , mBatchLevel(0)
33458:                                  , mBatchHasTransaction(PR_FALSE)
33458:                                  , mCanNotify(false)
33458:                                  , mCacheObservers("bookmark-observers")
    1: {
35298:   NS_ASSERTION(!gBookmarksService,
35298:                "Attempting to create two instances of the service!");
35298:   gBookmarksService = this;
    1: }
    1: 
    1: nsNavBookmarks::~nsNavBookmarks()
    1: {
35298:   NS_ASSERTION(gBookmarksService == this,
35298:                "Deleting a non-singleton instance of the service");
35298:   if (gBookmarksService == this)
35298:     gBookmarksService = nsnull;
    1: }
    1: 
 1337: NS_IMPL_ISUPPORTS3(nsNavBookmarks,
 1337:                    nsINavBookmarksService,
 1337:                    nsINavHistoryObserver,
 1337:                    nsIAnnotationObserver)
    1: 
    1: nsresult
    1: nsNavBookmarks::Init()
    1: {
35298:   nsNavHistory *history = nsNavHistory::GetHistoryService();
20874:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
20874:   mDBConn = history->GetStorageConnection();
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
20874: 
20877:   nsresult rv = InitStatements();
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874: 
20874:   rv = InitRoots();
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874: 
20874:   rv = transaction.Commit();
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874: 
30050:   mCanNotify = true;
30050: 
20874:   // Add observers
20874:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
20874:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
20874:   annosvc->AddObserver(this);
20874: 
20874:   // allows us to notify on title changes. MUST BE LAST so it is impossible
20874:   // to fail after this call, or the history service will have a reference to
20874:   // us and we won't go away.
20874:   history->AddObserver(this, PR_FALSE);
20874: 
20874:   // DO NOT PUT STUFF HERE that can fail. See observer comment above.
20874: 
20874:   return NS_OK;
20874: }
20874: 
20874: // nsNavBookmarks::InitTables
20874: //
20874: //    All commands that initialize the schema of the DB go in here. This is
20874: //    called from history init before the dummy DB connection is started that
20874: //    will prevent us from modifying the schema.
20874: 
20874: nsresult // static
20874: nsNavBookmarks::InitTables(mozIStorageConnection* aDBConn)
20874: {
20874:   PRBool exists;
20874:   nsresult rv = aDBConn->TableExists(NS_LITERAL_CSTRING("moz_bookmarks"), &exists);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   if (! exists) {
20874:     rv = aDBConn->ExecuteSimpleSQL(CREATE_MOZ_BOOKMARKS);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874: 
20874:     // This index will make it faster to determine if a given item is
20874:     // bookmarked (used by history queries and vacuuming, for example).
20874:     // Making it compound with "type" speeds up type-differentiation
20874:     // queries, such as expiration and search.
28193:     rv = aDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PLACETYPE);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874: 
20874:     // The most common operation is to find the children given a parent and position.
28193:     rv = aDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PARENTPOSITION);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874: 
20874:     // fast access to lastModified is useful during sync and to get
20874:     // last modified bookmark title for tags container's children.
28193:     rv = aDBConn->ExecuteSimpleSQL(CREATE_IDX_MOZ_BOOKMARKS_PLACELASTMODIFIED);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874:   }
20874: 
20874:   // moz_bookmarks_roots
20874:   rv = aDBConn->TableExists(NS_LITERAL_CSTRING("moz_bookmarks_roots"), &exists);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   if (!exists) {
20874:     rv = aDBConn->ExecuteSimpleSQL(CREATE_MOZ_BOOKMARKS_ROOTS);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874:   }
20874: 
20874:   // moz_keywords
20874:   rv = aDBConn->TableExists(NS_LITERAL_CSTRING("moz_keywords"), &exists);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   if (! exists) {
20874:     rv = aDBConn->ExecuteSimpleSQL(CREATE_MOZ_KEYWORDS);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874: 
20874:     // Create trigger to update as well
20874:     rv = aDBConn->ExecuteSimpleSQL(CREATE_KEYWORD_VALIDITY_TRIGGER);
20874:     NS_ENSURE_SUCCESS(rv, rv);
20874:   }
20874: 
20874:   return NS_OK;
20874: }
20874: 
20874: 
20874: // nsNavBookmarks::InitStatements
20874: //
20874: //    Create common statements to query the database
20874: nsresult
20874: nsNavBookmarks::InitStatements()
20874: {
20586:   // mDBFindURIBookmarks
29518:   // Double ordering covers possible lastModified ties, that could happen when
29518:   // importing, syncing or due to extensions.
20874:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT b.id "
20868:       "FROM moz_bookmarks b "
31039:       "WHERE b.type = ?2 AND b.fk = ( "
20868:         "SELECT id FROM moz_places_temp "
20868:         "WHERE url = ?1 "
29518:         "UNION "
20868:         "SELECT id FROM moz_places "
20868:         "WHERE url = ?1 "
29518:         "LIMIT 1 "
29518:       ") "
29518:       "ORDER BY b.lastModified DESC, b.id DESC "),
20586:     getter_AddRefs(mDBFindURIBookmarks));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20586:   // Construct a result where the first columns exactly match those returned by
20586:   // mDBGetURLPageInfo, and additionally contains columns for position,
20586:   // item_child, and folder_child from moz_bookmarks.
20586:   // Results are kGetInfoIndex_*
20586: 
20586:   // mDBGetChildren: select all children of a given folder, sorted by position
20586:   // This is a LEFT OUTER JOIN with moz_places since folders does not have
20586:   // a reference into that table.
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20586:       "SELECT h.id, h.url, COALESCE(b.title, h.title), "
28350:         "h.rev_host, h.visit_count, h.last_visit_date, f.url, null, b.id, "
33458:         "b.dateAdded, b.lastModified, b.parent, null, b.position, b.type, "
33458:         "b.fk, b.folder_type "
20586:       "FROM moz_bookmarks b "
20868:       "JOIN moz_places_temp h ON b.fk = h.id "
20868:       "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
20586:       "WHERE b.parent = ?1 "
20868:       "UNION ALL "
20868:       "SELECT h.id, h.url, COALESCE(b.title, h.title), "
28350:         "h.rev_host, h.visit_count, h.last_visit_date, f.url, null, b.id, "
33458:         "b.dateAdded, b.lastModified, b.parent, null, b.position, b.type, "
33458:         "b.fk, b.folder_type "
20868:       "FROM moz_bookmarks b "
20868:       "LEFT JOIN moz_places h ON b.fk = h.id "
20868:       "LEFT JOIN moz_favicons f ON h.favicon_id = f.id "
20868:       "WHERE b.parent = ?1 "
20868:         "AND (b.fk ISNULL OR b.fk NOT IN (select id FROM moz_places_temp)) "
27183:       "ORDER BY position ASC"),
20586:     getter_AddRefs(mDBGetChildren));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
31729:   // mDBFolderCount: count all of the children of a given folder and checks
31729:   // that it exists.
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
31729:       "SELECT COUNT(*), "
31729:       "(SELECT id FROM moz_bookmarks WHERE id = ?1) "
31729:       "FROM moz_bookmarks WHERE parent = ?1"),
20586:     getter_AddRefs(mDBFolderCount));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT position FROM moz_bookmarks WHERE id = ?1"),
20586:     getter_AddRefs(mDBGetItemIndex));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT id, fk, type FROM moz_bookmarks WHERE parent = ?1 AND position = ?2"),
20586:     getter_AddRefs(mDBGetChildAt));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20586:   // get bookmark/folder/separator properties
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT b.id, "
28796:              "IFNULL((SELECT url FROM moz_places_temp WHERE id = b.fk), "
28796:                     "(SELECT url FROM moz_places WHERE id = b.fk)), "
28796:              "b.title, b.position, b.fk, b.parent, b.type, b.folder_type, "
20868:              "b.dateAdded, b.lastModified "
20586:       "FROM moz_bookmarks b "
20586:       "WHERE b.id = ?1"),
20586:     getter_AddRefs(mDBGetItemProperties));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20586:       "SELECT item_id FROM moz_items_annos "
20586:       "WHERE content = ?1 "
20586:       "LIMIT 1"),
20586:     getter_AddRefs(mDBGetItemIdForGUID));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20586:   // mDBGetRedirectDestinations
20586:   // input = page ID, time threshold; output = unique ID input has redirected to
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT DISTINCT dest_v.place_id "
20868:       "FROM moz_historyvisits_temp source_v "
20868:       "JOIN moz_historyvisits_temp dest_v ON dest_v.from_visit = source_v.id "
20586:       "WHERE source_v.place_id = ?1 "
20586:         "AND source_v.visit_date >= ?2 "
20868:         "AND dest_v.visit_type IN (") +
20868:         nsPrintfCString("%d,%d",
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
20868:         NS_LITERAL_CSTRING(") "
20868:       "UNION "
20868:       "SELECT DISTINCT dest_v.place_id "
20868:       "FROM moz_historyvisits_temp source_v "
20868:       "JOIN moz_historyvisits dest_v ON dest_v.from_visit = source_v.id "
20868:       "WHERE source_v.place_id = ?1 "
20868:         "AND source_v.visit_date >= ?2 "
20868:         "AND dest_v.visit_type IN (") +
20868:         nsPrintfCString("%d,%d",
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
20868:         NS_LITERAL_CSTRING(") "
20868:       "UNION "
20868:       "SELECT DISTINCT dest_v.place_id "
20868:       "FROM moz_historyvisits source_v "
20868:       "JOIN moz_historyvisits_temp dest_v ON dest_v.from_visit = source_v.id "
20868:       "WHERE source_v.place_id = ?1 "
20868:         "AND source_v.visit_date >= ?2 "
20868:         "AND dest_v.visit_type IN (") +
20868:         nsPrintfCString("%d,%d",
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
20868:         NS_LITERAL_CSTRING(") "
20868:       "UNION "      
20868:       "SELECT DISTINCT dest_v.place_id "
20868:       "FROM moz_historyvisits source_v "
20868:       "JOIN moz_historyvisits dest_v ON dest_v.from_visit = source_v.id "
20868:       "WHERE source_v.place_id = ?1 "
20868:         "AND source_v.visit_date >= ?2 "
20868:         "AND dest_v.visit_type IN (") +
20868:         nsPrintfCString("%d,%d",
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
20868:         NS_LITERAL_CSTRING(") "),
20586:     getter_AddRefs(mDBGetRedirectDestinations));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20586:   // mDBInsertBookmark
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "INSERT INTO moz_bookmarks "
29518:         "(id, fk, type, parent, position, title, folder_type, dateAdded, lastModified) "
29518:       "VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9)"),
20586:     getter_AddRefs(mDBInsertBookmark));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20586:   // mDBIsBookmarkedInDatabase
20586:   // Just select position since it's just an int32 and may be faster.
20586:   // We don't actually care about the data, just whether there is any.
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20586:       "SELECT position FROM moz_bookmarks WHERE fk = ?1 AND type = ?2"),
20586:     getter_AddRefs(mDBIsBookmarkedInDatabase));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
24324:   // mDBIsRealBookmark
24324:   // Checks to make sure a place_id is a bookmark, and isn't a livemark.
24324:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
24324:       "SELECT id "
24324:       "FROM moz_bookmarks "
24324:       "WHERE fk = ?1 "
24324:         "AND type = ?2 "
24324:         "AND parent NOT IN ("
24324:           "SELECT a.item_id "
24324:           "FROM moz_items_annos a "
24324:           "JOIN moz_anno_attributes n ON a.anno_attribute_id = n.id "
24324:           "WHERE n.name = ?3"
24324:         ") "
24324:       "LIMIT 1"),
24324:     getter_AddRefs(mDBIsRealBookmark));
24324:   NS_ENSURE_SUCCESS(rv, rv);
24324: 
20586:   // mDBGetLastBookmarkID
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20586:       "SELECT id "
20586:       "FROM moz_bookmarks "
20586:       "ORDER BY ROWID DESC "
20586:       "LIMIT 1"),
20586:     getter_AddRefs(mDBGetLastBookmarkID));
20868:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20586:   // mDBSetItemDateAdded
29518:   // lastModified is set to the same value as dateAdded.  We do this for
29518:   // performance reasons, since it will allow us to use an index to sort items
29518:   // by date.
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
29518:       "UPDATE moz_bookmarks SET dateAdded = ?1, lastModified = ?1 "
29518:       "WHERE id = ?2"),
20586:     getter_AddRefs(mDBSetItemDateAdded));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20586:   // mDBSetItemLastModified
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "UPDATE moz_bookmarks SET lastModified = ?1 WHERE id = ?2"),
20586:     getter_AddRefs(mDBSetItemLastModified));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20586:   // mDBSetItemIndex
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "UPDATE moz_bookmarks SET position = ?2 WHERE id = ?1"),
20586:     getter_AddRefs(mDBSetItemIndex));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20586:   // get keyword text for bookmark id
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20586:       "SELECT k.keyword FROM moz_bookmarks b "
20586:       "JOIN moz_keywords k ON k.id = b.keyword_id "
20586:       "WHERE b.id = ?1"),
20586:     getter_AddRefs(mDBGetKeywordForBookmark));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586:   // get keyword text for URI (must be a bookmarked URI)
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20586:       "SELECT k.keyword "
20868:       "FROM ( "
20868:         "SELECT id FROM moz_places_temp "
20868:         "WHERE url = ?1 "
20868:         "UNION ALL "
20868:         "SELECT id FROM moz_places "
28350:         "WHERE url = ?1 "
28350:         "LIMIT 1 "
20868:       ") AS h "
20868:       "JOIN moz_bookmarks b ON b.fk = h.id "
20868:       "JOIN moz_keywords k ON k.id = b.keyword_id"),
20586:     getter_AddRefs(mDBGetKeywordForURI));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20874: 
20586:   // get URI for keyword
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT url FROM moz_keywords k "
20586:       "JOIN moz_bookmarks b ON b.keyword_id = k.id "
20868:       "JOIN moz_places_temp h ON b.fk = h.id "
20868:       "WHERE k.keyword = ?1 "
20868:       "UNION ALL "
20868:       "SELECT url FROM moz_keywords k "
20868:       "JOIN moz_bookmarks b ON b.keyword_id = k.id "
20868:       "JOIN moz_places h ON b.fk = h.id "
20868:       "WHERE k.keyword = ?1 "
28350:       "LIMIT 1"),
20586:     getter_AddRefs(mDBGetURIForKeyword));
20586:   NS_ENSURE_SUCCESS(rv, rv);
20586: 
20575:   return NS_OK;
20575: }
20575: 
21642: nsresult
21642: nsNavBookmarks::FinalizeStatements() {
21642:   mozIStorageStatement* stmts[] = {
21642:     mDBGetChildren,
21642:     mDBFindURIBookmarks,
21642:     mDBFolderCount,
21642:     mDBGetItemIndex,
21642:     mDBGetChildAt,
21642:     mDBGetItemProperties,
21642:     mDBGetItemIdForGUID,
21642:     mDBGetRedirectDestinations,
21642:     mDBInsertBookmark,
21642:     mDBIsBookmarkedInDatabase,
24324:     mDBIsRealBookmark,
21642:     mDBGetLastBookmarkID,
21642:     mDBSetItemDateAdded,
21642:     mDBSetItemLastModified,
21642:     mDBSetItemIndex,
21642:     mDBGetKeywordForURI,
21642:     mDBGetKeywordForBookmark,
21642:     mDBGetURIForKeyword
21642:   };
21642: 
21642:   for (PRUint32 i = 0; i < NS_ARRAY_LENGTH(stmts); i++) {
21642:     nsresult rv = nsNavHistory::FinalizeStatement(stmts[i]);
21642:     NS_ENSURE_SUCCESS(rv, rv);
21642:   }
21642: 
21642:   return NS_OK;
21642: }
20575: 
    1: // nsNavBookmarks::InitRoots
    1: //
    1: //    This locates and creates if necessary the root items in the bookmarks
    1: //    folder hierarchy. These items are stored in a special roots table that
    1: //    maps short predefined names to folder IDs.
    1: //
    1: //    Normally, these folders will exist already and we will save their IDs
    1: //    which are exposed through the bookmark service interface.
    1: //
    1: //    If the root does not exist, a folder is created for it and the ID is
    1: //    saved in the root table. No user-visible name is given to these folders
    1: //    and they have no parent or other attributes.
    1: //
    1: //    These attributes are set when the default_places.html file is imported.
    1: //    It defines the hierarchy, and has special attributes that tell us when
    1: //    a folder is one of our well-known roots. We then insert the root in the
    1: //    defined point in the hierarchy and set its attributes from this.
    1: //
    1: //    This should be called as the last part of the init process so that
    1: //    all of the statements are set up and the service is ready to use.
    1: 
    1: nsresult
    1: nsNavBookmarks::InitRoots()
    1: {
    1:   nsCOMPtr<mozIStorageStatement> getRootStatement;
20874:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "SELECT folder_id FROM moz_bookmarks_roots WHERE root_name = ?1"),
    1:     getter_AddRefs(getRootStatement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 8193:   PRBool createdPlacesRoot = PR_FALSE;
 8193:   rv = CreateRoot(getRootStatement, NS_LITERAL_CSTRING("places"), &mRoot, 0, &createdPlacesRoot);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   getRootStatement->Reset();
 2052:   rv = CreateRoot(getRootStatement, NS_LITERAL_CSTRING("menu"), &mBookmarksRoot, mRoot, nsnull);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 8193:   PRBool createdToolbarFolder;
 8193:   getRootStatement->Reset();
 8193:   rv = CreateRoot(getRootStatement, NS_LITERAL_CSTRING("toolbar"), &mToolbarFolder, mRoot, &createdToolbarFolder);
 8193:   NS_ENSURE_SUCCESS(rv, rv);
 8193: 
 8193:   // Once toolbar was not a root, we may need to move over the items and
 8193:   // delete the custom folder
 8193:   if (!createdPlacesRoot && createdToolbarFolder) {
 8193:     nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 8193:     NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 8193: 
 8193:     nsTArray<PRInt64> folders;
 8193:     annosvc->GetItemsWithAnnotationTArray(BOOKMARKS_TOOLBAR_FOLDER_ANNO,
 8193:                                           &folders);
 8193:     if (folders.Length() > 0) {
 8193:       nsCOMPtr<mozIStorageStatement> moveItems;
20874:       rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:           "UPDATE moz_bookmarks SET parent = ?1 WHERE parent=?2"),
 8193:         getter_AddRefs(moveItems));
 8193:       rv = moveItems->BindInt64Parameter(0, mToolbarFolder);
 8193:       NS_ENSURE_SUCCESS(rv, rv);
 8193:       rv = moveItems->BindInt64Parameter(1, folders[0]);
 8193:       NS_ENSURE_SUCCESS(rv, rv);
 8193:       rv = moveItems->Execute();
 8193:       NS_ENSURE_SUCCESS(rv, rv);
 8193:       rv = RemoveFolder(folders[0]);
 8193:       NS_ENSURE_SUCCESS(rv, rv);
 8193:     }
 8193:   }
 8193: 
    1:   getRootStatement->Reset();
 2052:   rv = CreateRoot(getRootStatement, NS_LITERAL_CSTRING("tags"), &mTagRoot, mRoot, nsnull);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 5930:   getRootStatement->Reset();
 5930:   rv = CreateRoot(getRootStatement, NS_LITERAL_CSTRING("unfiled"), &mUnfiledRoot, mRoot, nsnull);
 5930:   NS_ENSURE_SUCCESS(rv, rv);
 5930: 
 8193:   // Set titles for special folders
 8193:   // We cannot rely on createdPlacesRoot due to Fx3beta->final migration path
21600:   PRUint16 databaseStatus = nsINavHistoryService::DATABASE_STATUS_OK;
35298:   nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
35298:   rv = history->GetDatabaseStatus(&databaseStatus);
21600:   if (NS_FAILED(rv) ||
21600:       databaseStatus != nsINavHistoryService::DATABASE_STATUS_OK) {
  543:     rv = InitDefaults();
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
 2052: 
    1:   return NS_OK;
    1: }
    1: 
  543: // nsNavBookmarks::InitDefaults
  543: //
  543: // Initializes default bookmarks and containers.
  543: // Pulls from places.propertes for l10n.
  543: // Replaces the old default_places.html file.
  543: nsresult
  543: nsNavBookmarks::InitDefaults()
  543: {
35298:   nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
35298:   nsIStringBundle *bundle = history->GetBundle();
20877:   NS_ENSURE_TRUE(bundle, NS_ERROR_OUT_OF_MEMORY);
20877: 
 8193:   // Bookmarks Menu
  543:   nsXPIDLString bookmarksTitle;
20877:   nsresult rv = bundle->GetStringFromName(NS_LITERAL_STRING("BookmarksMenuFolderTitle").get(),
  543:                                           getter_Copies(bookmarksTitle));
  543:   NS_ENSURE_SUCCESS(rv, rv);
10046:   rv = SetItemTitle(mBookmarksRoot, NS_ConvertUTF16toUTF8(bookmarksTitle));
  543:   NS_ENSURE_SUCCESS(rv, rv);
  543: 
 8193:   // Bookmarks Toolbar
  543:   nsXPIDLString toolbarTitle;
20877:   rv = bundle->GetStringFromName(NS_LITERAL_STRING("BookmarksToolbarFolderTitle").get(),
  543:                                  getter_Copies(toolbarTitle));
  543:   NS_ENSURE_SUCCESS(rv, rv);
10046:   rv = SetItemTitle(mToolbarFolder, NS_ConvertUTF16toUTF8(toolbarTitle));
  543:   NS_ENSURE_SUCCESS(rv, rv);
 8193: 
12801:   // Unsorted Bookmarks
 8193:   nsXPIDLString unfiledTitle;
20877:   rv = bundle->GetStringFromName(NS_LITERAL_STRING("UnsortedBookmarksFolderTitle").get(),
 8193:                                  getter_Copies(unfiledTitle));
  543:   NS_ENSURE_SUCCESS(rv, rv);
10046:   rv = SetItemTitle(mUnfiledRoot, NS_ConvertUTF16toUTF8(unfiledTitle));
 8193:   NS_ENSURE_SUCCESS(rv, rv);
 8193: 
 8193:   // Tags
 8193:   nsXPIDLString tagsTitle;
20877:   rv = bundle->GetStringFromName(NS_LITERAL_STRING("TagsFolderTitle").get(),
 8193:                                  getter_Copies(tagsTitle));
 8193:   NS_ENSURE_SUCCESS(rv, rv);
10046:   rv = SetItemTitle(mTagRoot, NS_ConvertUTF16toUTF8(tagsTitle));
 8193:   NS_ENSURE_SUCCESS(rv, rv);
 5930: 
 2049:   return NS_OK;
 2049: }
 2049: 
    1: // nsNavBookmarks::CreateRoot
    1: //
    1: //    This gets or creates a root folder of the given type. aWasCreated
    1: //    (optional) is true if the folder had to be created, false if we just used
    1: //    an old one. The statement that gets a folder ID from a root name is
    1: //    passed in so the DB only needs to parse the statement once, and we don't
    1: //    have to have a global for this. Creation is less optimized because it
    1: //    happens rarely.
    1: 
    1: nsresult
    1: nsNavBookmarks::CreateRoot(mozIStorageStatement* aGetRootStatement,
    1:                            const nsCString& name, PRInt64* aID,
 2052:                            PRInt64 aParentID, PRBool* aWasCreated)
    1: {
    1:   PRBool hasResult = PR_FALSE;
    1:   nsresult rv = aGetRootStatement->BindUTF8StringParameter(0, name);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = aGetRootStatement->ExecuteStep(&hasResult);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (hasResult) {
    1:     if (aWasCreated)
    1:       *aWasCreated = PR_FALSE;
    1:     rv = aGetRootStatement->GetInt64(0, aID);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     NS_ASSERTION(*aID != 0, "Root is 0 for some reason, folders can't have 0 ID");
    1:     return NS_OK;
    1:   }
    1:   if (aWasCreated)
    1:     *aWasCreated = PR_TRUE;
    1: 
    1:   // create folder with no name or attributes
    1:   nsCOMPtr<mozIStorageStatement> insertStatement;
10046:   rv = CreateFolder(aParentID, EmptyCString(), nsINavBookmarksService::DEFAULT_INDEX, aID);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // save root ID
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20868:       "INSERT INTO moz_bookmarks_roots (root_name, folder_id) VALUES (?1, ?2)"),
    1:     getter_AddRefs(insertStatement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = insertStatement->BindUTF8StringParameter(0, name);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = insertStatement->BindInt64Parameter(1, *aID);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = insertStatement->Execute();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return NS_OK;
    1: }
    1: 
29144: // nsNavBookmarks::GetBookmarksHash
29144: //
29144: //    Getter and lazy initializer of the bookmarks redirect hash.
29144: //    See FillBookmarksHash for more information.
29144: 
29144: nsDataHashtable<nsTrimInt64HashKey, PRInt64>*
29144: nsNavBookmarks::GetBookmarksHash()
29144: {
29144:   if (!mBookmarksHash.IsInitialized()) {
29144:     nsresult rv = FillBookmarksHash();
29144:     NS_ABORT_IF_FALSE(NS_SUCCEEDED(rv), "FillBookmarksHash() failed!");
29144:   }
29144: 
29144:   return &mBookmarksHash;
29144: }
    1: 
    1: // nsNavBookmarks::FillBookmarksHash
    1: //
    1: //    This initializes the bookmarks hashtable that tells us which bookmark
    1: //    a given URI redirects to. This hashtable includes all URIs that
    1: //    redirect to bookmarks.
    1: 
    1: nsresult
    1: nsNavBookmarks::FillBookmarksHash()
    1: {
    1:   PRBool hasMore;
    1: 
    1:   // first init the hashtable
    1:   NS_ENSURE_TRUE(mBookmarksHash.Init(1024), NS_ERROR_OUT_OF_MEMORY);
    1: 
29144:   // first populate the hashtable with all bookmarks
    1:   nsCOMPtr<mozIStorageStatement> statement;
20874:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
30050:       "SELECT b.fk "
    1:       "FROM moz_bookmarks b "
30050:       "WHERE b.type = ?1 "
30050:       "AND b.fk NOTNULL"),
    1:     getter_AddRefs(statement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
  338:   rv = statement->BindInt32Parameter(0, TYPE_BOOKMARK);
  338:   NS_ENSURE_SUCCESS(rv, rv);
    1:   while (NS_SUCCEEDED(statement->ExecuteStep(&hasMore)) && hasMore) {
    1:     PRInt64 pageID;
    1:     rv = statement->GetInt64(0, &pageID);
    1:     NS_ENSURE_TRUE(mBookmarksHash.Put(pageID, pageID), NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1: 
    1:   // Find all pages h2 that have been redirected to from a bookmarked URI:
    1:   //    bookmarked -> url (h1)         url (h2)
    1:   //                    |                 ^
    1:   //                    .                 |
    1:   //                 visit (v1) -> destination visit (v2)
    1:   // This should catch most redirects, which are only one level. More levels of
    1:   // redirection will be handled separately.
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
20569:       "SELECT v1.place_id, v2.place_id "
20569:         "FROM moz_bookmarks b "
20868:         "LEFT JOIN moz_historyvisits_temp v1 on b.fk = v1.place_id "
20868:         "LEFT JOIN moz_historyvisits v2 on v2.from_visit = v1.id "
20868:         "WHERE b.fk IS NOT NULL AND b.type = ?1 "
20868:         "AND v2.visit_type IN (") +
20868:         nsPrintfCString("%d,%d",
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
20868:         NS_LITERAL_CSTRING(") GROUP BY v2.place_id "
20868:       "UNION "
20868:       "SELECT v1.place_id, v2.place_id "
20868:         "FROM moz_bookmarks b "
20868:         "LEFT JOIN moz_historyvisits v1 on b.fk = v1.place_id "
20868:         "LEFT JOIN moz_historyvisits_temp v2 on v2.from_visit = v1.id "
20868:         "WHERE b.fk IS NOT NULL AND b.type = ?1 "
20868:         "AND v2.visit_type IN (") +
20868:         nsPrintfCString("%d,%d",
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
20868:         NS_LITERAL_CSTRING(") GROUP BY v2.place_id "
20868:       "UNION "
20868:       "SELECT v1.place_id, v2.place_id "
20868:         "FROM moz_bookmarks b "
  338:         "LEFT JOIN moz_historyvisits v1 on b.fk = v1.place_id "
    1:         "LEFT JOIN moz_historyvisits v2 on v2.from_visit = v1.id "
  338:         "WHERE b.fk IS NOT NULL AND b.type = ?1 "
20868:         "AND v2.visit_type IN (") +
20868:         nsPrintfCString("%d,%d",
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
20868:         NS_LITERAL_CSTRING(") GROUP BY v2.place_id "
20868:       "UNION "
20868:         "SELECT v1.place_id, v2.place_id "
20868:         "FROM moz_bookmarks b "
20868:         "LEFT JOIN moz_historyvisits_temp v1 on b.fk = v1.place_id "
20868:         "LEFT JOIN moz_historyvisits_temp v2 on v2.from_visit = v1.id "
20868:         "WHERE b.fk IS NOT NULL AND b.type = ?1 "
20868:         "AND v2.visit_type IN (") +
20868:         nsPrintfCString("%d,%d",
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_PERMANENT,
20868:                         nsINavHistoryService::TRANSITION_REDIRECT_TEMPORARY) +
20868:         NS_LITERAL_CSTRING(") GROUP BY v2.place_id "),
    1:     getter_AddRefs(statement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
  338:   rv = statement->BindInt64Parameter(0, TYPE_BOOKMARK);
  338:   NS_ENSURE_SUCCESS(rv, rv);
    1:   while (NS_SUCCEEDED(statement->ExecuteStep(&hasMore)) && hasMore) {
    1:     PRInt64 fromId, toId;
    1:     statement->GetInt64(0, &fromId);
    1:     statement->GetInt64(1, &toId);
    1: 
    1:     NS_ENSURE_TRUE(mBookmarksHash.Put(toId, fromId), NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     // handle redirects deeper than one level
    1:     rv = RecursiveAddBookmarkHash(fromId, toId, 0);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavBookmarks::AddBookmarkToHash
    1: //
    1: //    Given a bookmark that was potentially added, this goes through all
    1: //    redirects that this page may have resulted in and adds them to our hash.
    1: //    Note that this takes the ID of the URL in the history system, which we
    1: //    generally have when calling this function and which makes it faster.
    1: //
    1: //    For better performance, this call should be in a DB transaction.
    1: //
    1: //    @see RecursiveAddBookmarkHash
    1: 
    1: nsresult
14272: nsNavBookmarks::AddBookmarkToHash(PRInt64 aPlaceId, PRTime aMinTime)
    1: {
29144:   if (!GetBookmarksHash()->Put(aPlaceId, aPlaceId))
    1:     return NS_ERROR_OUT_OF_MEMORY;
14272:   return RecursiveAddBookmarkHash(aPlaceId, aPlaceId, aMinTime);
    1: }
    1: 
    1: 
    1: // nsNavBookmkars::RecursiveAddBookmarkHash
    1: //
    1: //    Used to add a new level of redirect information to the bookmark hash.
 1043: //    Given a source bookmark 'aBookmark' and 'aCurrentSource' that has already
    1: //    been added to the hashtable, this will add all redirect destinations of
 1043: //    'aCurrentSource'. Will call itself recursively to walk down the chain.
    1: //
    1: //    'aMinTime' is the minimum time to consider visits from. Visits previous
    1: //    to this will not be considered. This allows the search to be much more
    1: //    efficient if you know something happened recently. Use 0 for the min time
    1: //    to search all history for redirects.
    1: 
    1: nsresult
14272: nsNavBookmarks::RecursiveAddBookmarkHash(PRInt64 aPlaceID,
    1:                                          PRInt64 aCurrentSource,
    1:                                          PRTime aMinTime)
    1: {
    1:   nsresult rv;
    1:   nsTArray<PRInt64> found;
    1: 
    1:   // scope for the DB statement. The statement must be reset by the time we
    1:   // recursively call ourselves again, because our recursive call will use the
    1:   // same statement.
    1:   {
    1:     mozStorageStatementScoper scoper(mDBGetRedirectDestinations);
    1:     rv = mDBGetRedirectDestinations->BindInt64Parameter(0, aCurrentSource);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     rv = mDBGetRedirectDestinations->BindInt64Parameter(1, aMinTime);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRBool hasMore;
    1:     while (NS_SUCCEEDED(mDBGetRedirectDestinations->ExecuteStep(&hasMore)) &&
    1:            hasMore) {
    1: 
    1:       // add this newly found redirect destination to the hashtable
    1:       PRInt64 curID;
    1:       rv = mDBGetRedirectDestinations->GetInt64(0, &curID);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       // It is very important we ignore anything already in our hashtable. It
    1:       // is actually pretty common to get loops of redirects. For example,
    1:       // a restricted page will redirect you to a login page, which will
    1:       // redirect you to the restricted page again with the proper cookie.
    1:       PRInt64 alreadyExistingOne;
29144:       if (GetBookmarksHash()->Get(curID, &alreadyExistingOne))
    1:         continue;
    1: 
29144:       if (!GetBookmarksHash()->Put(curID, aPlaceID))
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:       // save for recursion later
    1:       found.AppendElement(curID);
    1:     }
    1:   }
    1: 
    1:   // recurse on each found item now that we're done with the statement
    1:   for (PRUint32 i = 0; i < found.Length(); i ++) {
14272:     rv = RecursiveAddBookmarkHash(aPlaceID, found[i], aMinTime);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: // nsNavBookmarks::UpdateBookmarkHashOnRemove
    1: //
    1: //    Call this when a bookmark is removed. It will see if the bookmark still
    1: //    exists anywhere in the system, and, if not, remove all references to it
    1: //    in the bookmark hashtable.
    1: //
    1: //    The callback takes a pointer to what bookmark is being removed (as
    1: //    an Int64 history page ID) as the userArg and removes all redirect
    1: //    destinations that reference it.
    1: 
20261: static PLDHashOperator
    1: RemoveBookmarkHashCallback(nsTrimInt64HashKey::KeyType aKey,
14272:                            PRInt64& aPlaceId, void* aUserArg)
    1: {
 3233:   const PRInt64* removeThisOne = reinterpret_cast<const PRInt64*>(aUserArg);
14272:   if (aPlaceId == *removeThisOne)
    1:     return PL_DHASH_REMOVE;
    1:   return PL_DHASH_NEXT;
    1: }
    1: nsresult
    1: nsNavBookmarks::UpdateBookmarkHashOnRemove(PRInt64 aPlaceId)
    1: {
    1:   // note we have to use the DB version here since the hashtable may be
    1:   // out-of-date
    1:   PRBool inDB;
    1:   nsresult rv = IsBookmarkedInDatabase(aPlaceId, &inDB);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (inDB)
    1:     return NS_OK; // bookmark still exists, don't need to update hashtable
    1: 
    1:   // remove it
29144:   GetBookmarksHash()->Enumerate(RemoveBookmarkHashCallback,
 3233:                                 reinterpret_cast<void*>(&aPlaceId));
    1:   return NS_OK;
    1: }
    1: 
    1: 
24324: PRBool
24324: nsNavBookmarks::IsRealBookmark(PRInt64 aPlaceId)
24324: {
24324:   // Fast path is to check the hash table first.  If it is in the hash table,
24324:   // then verify that it is a real bookmark.
24324:   PRInt64 bookmarkId;
29144:   PRBool isBookmark = GetBookmarksHash()->Get(aPlaceId, &bookmarkId);
24324:   if (!isBookmark)
24324:     return PR_FALSE;
24324: 
24324:   {
24324:     mozStorageStatementScoper scope(mDBIsRealBookmark);
24324: 
24324:     (void)mDBIsRealBookmark->BindInt64Parameter(0, aPlaceId);
24324:     (void)mDBIsRealBookmark->BindInt32Parameter(1, TYPE_BOOKMARK);
24324:     (void)mDBIsRealBookmark->BindUTF8StringParameter(
24324:       2, NS_LITERAL_CSTRING(LMANNO_FEEDURI)
24324:     );
24324: 
24324:     // If we get any rows, then there exists at least one bookmark corresponding
24324:     // to aPlaceId that is not a livemark item.
24324:     if (NS_SUCCEEDED(mDBIsRealBookmark->ExecuteStep(&isBookmark)))
24324:       return isBookmark;
24324:   }
24324: 
24324:   return PR_FALSE;
24324: }
24324: 
    1: // nsNavBookmarks::IsBookmarkedInDatabase
    1: //
24324: //    This checks to see if the specified place_id is actually bookmarked.
24324: //    This does not check for redirects in the hashtable.
    1: 
    1: nsresult
    1: nsNavBookmarks::IsBookmarkedInDatabase(PRInt64 aPlaceId,
    1:                                        PRBool *aIsBookmarked)
    1: {
 7778:   mozStorageStatementScoper scope(mDBIsBookmarkedInDatabase);
 7778:   nsresult rv = mDBIsBookmarkedInDatabase->BindInt64Parameter(0, aPlaceId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 7778:   rv = mDBIsBookmarkedInDatabase->BindInt32Parameter(1, TYPE_BOOKMARK);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 7778:   return mDBIsBookmarkedInDatabase->ExecuteStep(aIsBookmarked);
    1: }
    1: 
    1: 
    1: nsresult
    1: nsNavBookmarks::AdjustIndices(PRInt64 aFolder,
    1:                               PRInt32 aStartIndex, PRInt32 aEndIndex,
    1:                               PRInt32 aDelta)
    1: {
    1:   NS_ASSERTION(aStartIndex <= aEndIndex, "start index must be <= end index");
    1: 
    1:   nsCAutoString buffer;
    1:   buffer.AssignLiteral("UPDATE moz_bookmarks SET position = position + ");
    1:   buffer.AppendInt(aDelta);
    1:   buffer.AppendLiteral(" WHERE parent = ");
    1:   buffer.AppendInt(aFolder);
    1: 
    1:   if (aStartIndex != 0) {
    1:     buffer.AppendLiteral(" AND position >= ");
    1:     buffer.AppendInt(aStartIndex);
    1:   }
    1:   if (aEndIndex != PR_INT32_MAX) {
    1:     buffer.AppendLiteral(" AND position <= ");
    1:     buffer.AppendInt(aEndIndex);
    1:   }
    1: 
20874:   nsresult rv = mDBConn->ExecuteSimpleSQL(buffer);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:  
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetPlacesRoot(PRInt64 *aRoot)
    1: {
    1:   *aRoot = mRoot;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 8193: nsNavBookmarks::GetBookmarksMenuFolder(PRInt64 *aRoot)
    1: {
    1:   *aRoot = mBookmarksRoot;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetToolbarFolder(PRInt64 *aFolderId)
    1: {
    1:   *aFolderId = mToolbarFolder;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 8193: nsNavBookmarks::GetTagsFolder(PRInt64 *aRoot)
    1: {
    1:   *aRoot = mTagRoot;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 8193: nsNavBookmarks::GetUnfiledBookmarksFolder(PRInt64 *aRoot)
 5930: {
 5930:   *aRoot = mUnfiledRoot;
 5930:   return NS_OK;
 5930: }
 5930: 
29518: nsresult
29518: nsNavBookmarks::InsertBookmarkInDB(PRInt64 aItemId,
29518:                                    PRInt64 aPlaceId,
29518:                                    enum ItemType aItemType,
29518:                                    PRInt64 aParentId,
29518:                                    PRInt32 aIndex,
29518:                                    const nsACString &aTitle,
29518:                                    PRTime aDateAdded,
29518:                                    PRTime aLastModified,
29518:                                    const nsAString &aServiceContractId,
29518:                                    PRInt64 *_newItemId)
29518: {
29518:   NS_ASSERTION(_newItemId, "Null pointer passed to InsertBookmarkInDB!");
29518: 
29518:   mozStorageStatementScoper scope(mDBInsertBookmark);
29518: 
29518:   nsresult rv;
29518:   if (aItemId && aItemId != -1)
29518:     rv = mDBInsertBookmark->BindInt64Parameter(kInsertBookmarkIndex_Id, aItemId);
29518:   else
29518:     rv = mDBInsertBookmark->BindNullParameter(kInsertBookmarkIndex_Id);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   if (aPlaceId && aPlaceId != -1)
29518:     rv = mDBInsertBookmark->BindInt64Parameter(kInsertBookmarkIndex_PlaceId, aPlaceId);
29518:   else
29518:     rv = mDBInsertBookmark->BindNullParameter(kInsertBookmarkIndex_PlaceId);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   rv = mDBInsertBookmark->BindInt32Parameter(kInsertBookmarkIndex_Type, aItemType);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518:   rv = mDBInsertBookmark->BindInt64Parameter(kInsertBookmarkIndex_Parent, aParentId);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518:   rv = mDBInsertBookmark->BindInt32Parameter(kInsertBookmarkIndex_Position, aIndex);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   // Support NULL titles.
29518:   if (aTitle.IsVoid())
29518:     rv = mDBInsertBookmark->BindNullParameter(kInsertBookmarkIndex_Title);
29518:   else
29518:     rv = mDBInsertBookmark->BindUTF8StringParameter(kInsertBookmarkIndex_Title, aTitle);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   if (aServiceContractId.IsEmpty())
29518:     rv = mDBInsertBookmark->BindNullParameter(kInsertBookmarkIndex_ServiceContractId);
29518:   else
29518:     rv = mDBInsertBookmark->BindStringParameter(kInsertBookmarkIndex_ServiceContractId, aServiceContractId);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   rv = mDBInsertBookmark->BindInt64Parameter(kInsertBookmarkIndex_DateAdded, aDateAdded);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   if (aLastModified)
29518:     rv = mDBInsertBookmark->BindInt64Parameter(kInsertBookmarkIndex_LastModified, aLastModified);
29518:   else
29518:     rv = mDBInsertBookmark->BindInt64Parameter(kInsertBookmarkIndex_LastModified, aDateAdded);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   rv = mDBInsertBookmark->Execute();
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   if (!aItemId || aItemId == -1) {
29518:     // Get the new inserted item id.
29518:     mozStorageStatementScoper scoper(mDBGetLastBookmarkID);
29518:     PRBool hasResult;
29518:     rv = mDBGetLastBookmarkID->ExecuteStep(&hasResult);
29518:     NS_ENSURE_SUCCESS(rv, rv);
29518:     NS_ENSURE_TRUE(hasResult, NS_ERROR_UNEXPECTED);
29518:     *_newItemId = mDBGetLastBookmarkID->AsInt64(0);
29518:   }
29518:   else
29518:     *_newItemId = aItemId;
29518: 
29518:   // Update last modified date of the parent folder.
29518:   // XXX TODO: This should be done recursively for all ancestors, that would
29518:   //           be slow without a nested tree though.  See bug 408991.
29518:   rv = SetItemDateInternal(mDBSetItemLastModified, aParentId, aDateAdded);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518: 
29518:   return NS_OK;
29518: }
29518: 
 5930: NS_IMETHODIMP
29123: nsNavBookmarks::InsertBookmark(PRInt64 aFolder,
29123:                                nsIURI *aURI,
29123:                                PRInt32 aIndex,
10046:                                const nsACString& aTitle,
 1738:                                PRInt64 *aNewBookmarkId)
    1: {
29123:   NS_ENSURE_ARG(aURI);
29123:   NS_ENSURE_ARG_POINTER(aNewBookmarkId);
29123: 
    1:   // You can pass -1 to indicate append, but no other negative number is allowed
    1:   if (aIndex < nsINavBookmarksService::DEFAULT_INDEX)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
35298:   nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
35298: 
16751:   // This is really a place ID
    1:   PRInt64 childID;
35298:   nsresult rv = history->GetUrlIdFor(aURI, &childID, PR_TRUE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 8275:   PRInt32 index;
31729:   PRInt32 folderCount;
31729:   rv = FolderCount(aFolder, &folderCount);
31729:   NS_ENSURE_SUCCESS(rv, rv);
31729:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
31729:       aIndex >= folderCount) {
31729:     index = folderCount;
31729:   }
31729:   else {
 8275:     index = aIndex;
    1:     rv = AdjustIndices(aFolder, index, PR_INT32_MAX, 1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 8275:   }
    1: 
29518:   nsString voidString;
29518:   voidString.SetIsVoid(PR_TRUE);
29518:   rv = InsertBookmarkInDB(-1, childID, BOOKMARK, aFolder, index,
29518:                           aTitle, PR_Now(), nsnull, EmptyString(),
29518:                           aNewBookmarkId);
 1738:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
10669:   // XXX
10669:   // 0n import / fx 2 migration, is the frecency work going to slow us down?
10669:   // We might want to skip this stuff, as well as the frecency work
10669:   // caused by GetUrlIdFor() which calls InternalAddNewPage().
10669:   // If we do skip this, after import, we will
10669:   // need to call FixInvalidFrecenciesForExcludedPlaces().
10669:   // We might need to call it anyways, if items aren't properly annotated
10669:   // as livemarks feeds yet.
10669: 
10669:   nsCAutoString url;
29123:   rv = aURI->GetSpec(url);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:   // prevent place: queries from showing up in the URL bar autocomplete results
10669:   PRBool isBookmark = !IsQueryURI(url);
10669: 
10669:   if (isBookmark) {
10669:     // if it is a livemark item (the parent is a livemark), 
10669:     // we pass in false for isBookmark.  otherwise, unvisited livemark 
10669:     // items will appear in URL autocomplete before we visit them.
10669:     PRBool parentIsLivemark;
10669:     nsCOMPtr<nsILivemarkService> lms = 
10669:       do_GetService(NS_LIVEMARKSERVICE_CONTRACTID, &rv);
10669:     NS_ENSURE_SUCCESS(rv, rv);
10669: 
10669:     rv = lms->IsLivemark(aFolder, &parentIsLivemark);
10669:     NS_ENSURE_SUCCESS(rv, rv);
10669:  
10669:     isBookmark = !parentIsLivemark;
10669:   }
10669:   
10669:   // when we created the moz_place entry for the new bookmark 
10669:   // (a side effect of calling GetUrlIdFor()) frecency -1;
10669:   // now we re-calculate the frecency for this moz_place entry. 
35298:   rv = history->UpdateFrecency(childID, isBookmark);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   AddBookmarkToHash(childID, 0);
    1: 
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                       OnItemAdded(*aNewBookmarkId, aFolder, index, TYPE_BOOKMARK));
    1: 
 9553:   // If the bookmark has been added to a tag container, notify all
 9553:   // bookmark-folder result nodes which contain a bookmark for the new
 9553:   // bookmark's url
21350:   PRInt64 grandParentId;
21350:   rv = GetFolderIdForItem(aFolder, &grandParentId);
 9553:   NS_ENSURE_SUCCESS(rv, rv);
21350:   if (grandParentId == mTagRoot) {
 9553:     // query for all bookmarks for that URI, notify for each
 9553:     nsTArray<PRInt64> bookmarks;
 9553: 
34260:     rv = GetBookmarkIdsForURITArray(aURI, bookmarks);
 9553:     NS_ENSURE_SUCCESS(rv, rv);
 9553: 
 9553:     if (bookmarks.Length()) {
 9553:       for (PRUint32 i = 0; i < bookmarks.Length(); i++) {
30050:         ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
33340:                             OnItemChanged(bookmarks[i],
33340:                                           NS_LITERAL_CSTRING("tags"),
33340:                                           PR_FALSE,
33340:                                           EmptyCString(),
33340:                                           0,
35298:                                           TYPE_BOOKMARK));
 9553:       }
 9553:     }
 9553:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::RemoveItem(PRInt64 aItemId)
    1: {
24923:   NS_ENSURE_TRUE(aItemId != mRoot, NS_ERROR_INVALID_ARG);
24923: 
14272:   nsresult rv;
    1:   PRInt32 childIndex;
    1:   PRInt64 placeId, folderId;
21350:   PRUint16 itemType;
 1337:   nsCAutoString buffer;
 9553:   nsCAutoString spec;
 1337: 
    1:   { // scoping to ensure the statement gets reset
 1297:     mozStorageStatementScoper scope(mDBGetItemProperties);
 1297:     mDBGetItemProperties->BindInt64Parameter(0, aItemId);
    1: 
    1:     PRBool results;
 1297:     rv = mDBGetItemProperties->ExecuteStep(&results);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (!results)
    1:       return NS_ERROR_INVALID_ARG; // invalid bookmark id
    1: 
 1297:     childIndex = mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Position);
 1297:     placeId = mDBGetItemProperties->AsInt64(kGetItemPropertiesIndex_PlaceID);
 1297:     folderId = mDBGetItemProperties->AsInt64(kGetItemPropertiesIndex_Parent);
21350:     itemType = (PRUint16) mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Type);
 9553:     if (itemType == TYPE_BOOKMARK) {
 9553:       rv = mDBGetItemProperties->GetUTF8String(kGetItemPropertiesIndex_URI, spec);
 9553:       NS_ENSURE_SUCCESS(rv, rv);
 9553:     }
    1:   }
    1: 
14272:   if (itemType == TYPE_FOLDER) {
14272:     rv = RemoveFolder(aItemId);
14272:     NS_ENSURE_SUCCESS(rv, rv);
14272:     return NS_OK;
14272:   }
14272: 
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                       OnBeforeItemRemoved(aItemId, itemType));
26383: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
14272: 
14272:   // First, remove item annotations
14272:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
14272:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
14272:   rv = annosvc->RemoveItemAnnotations(aItemId);
14272:   NS_ENSURE_SUCCESS(rv, rv);
14272: 
    1:   buffer.AssignLiteral("DELETE FROM moz_bookmarks WHERE id = ");
    1:   buffer.AppendInt(aItemId);
    1: 
20874:   rv = mDBConn->ExecuteSimpleSQL(buffer);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (childIndex != -1) {
    1:     rv = AdjustIndices(folderId, childIndex + 1, PR_INT32_MAX, -1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
13203:   rv = SetItemDateInternal(mDBSetItemLastModified, folderId, PR_Now());
 3360:   NS_ENSURE_SUCCESS(rv, rv);
 3360: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = UpdateBookmarkHashOnRemove(placeId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
10669:   if (itemType == TYPE_BOOKMARK) {
25031:     // UpdateFrecency needs to know whether placeId is still bookmarked.
25031:     // Although we removed aItemId, placeId may still be bookmarked elsewhere;
25031:     // IsRealBookmark will know.
35298:     nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:     NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
35298:     rv = history->UpdateFrecency(placeId, IsRealBookmark(placeId));
10669:     NS_ENSURE_SUCCESS(rv, rv);
10669:   }
10669: 
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                       OnItemRemoved(aItemId, folderId, childIndex, itemType));
    1: 
 9553:   if (itemType == TYPE_BOOKMARK) {
 9553:     // If the removed bookmark was a child of a tag container, notify all
 9553:     // bookmark-folder result nodes which contain a bookmark for the removed
 9553:     // bookmark's url.
21350:     PRInt64 grandParentId;
21350:     rv = GetFolderIdForItem(folderId, &grandParentId);
 9553:     NS_ENSURE_SUCCESS(rv, rv);
21350:     if (grandParentId == mTagRoot) {
 9553:       nsCOMPtr<nsIURI> uri;
 9553:       rv = NS_NewURI(getter_AddRefs(uri), spec);
 9553:       NS_ENSURE_SUCCESS(rv, rv);
 9553:       nsTArray<PRInt64> bookmarks;
 9553: 
34260:       rv = GetBookmarkIdsForURITArray(uri, bookmarks);
 9553:       NS_ENSURE_SUCCESS(rv, rv);
 9553: 
 9553:       if (bookmarks.Length()) {
 9553:         for (PRUint32 i = 0; i < bookmarks.Length(); i++) {
30050:           ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
33340:                               OnItemChanged(bookmarks[i],
33340:                                             NS_LITERAL_CSTRING("tags"),
33340:                                             PR_FALSE,
33340:                                             EmptyCString(),
33340:                                             0,
35298:                                             TYPE_BOOKMARK));
 9553:         }
 9553:       }
 9553:     }
 9553:   }
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
10046: nsNavBookmarks::CreateFolder(PRInt64 aParent, const nsACString &aName,
    1:                              PRInt32 aIndex, PRInt64 *aNewFolder)
    1: {
29123:   // NOTE: aParent can be null for root creation, so not checked
29123:   NS_ENSURE_ARG_POINTER(aNewFolder);
29123: 
 4179:   // CreateContainerWithID returns the index of the new folder, but that's not
    1:   // used here.  To avoid any risk of corrupting data should this function
    1:   // be changed, we'll use a local variable to hold it.  The PR_TRUE argument
    1:   // will cause notifications to be sent to bookmark observers.
    1:   PRInt32 localIndex = aIndex;
29518:   nsString voidString;
29518:   voidString.SetIsVoid(PR_TRUE);
29518:   return CreateContainerWithID(-1, aParent, aName, voidString, PR_TRUE,
 4179:                                &localIndex, aNewFolder);
    1: }
    1: 
    1: NS_IMETHODIMP
10046: nsNavBookmarks::CreateDynamicContainer(PRInt64 aParent, const nsACString &aName,
 4179:                                        const nsAString &aContractId,
 4179:                                        PRInt32 aIndex,
    1:                                        PRInt64 *aNewFolder)
    1: {
 4179:   if (aContractId.IsEmpty())
 4179:     return NS_ERROR_INVALID_ARG;
 4179: 
 4179:   return CreateContainerWithID(-1, aParent, aName, aContractId, PR_FALSE,
 4179:                                &aIndex, aNewFolder);
    1: }
    1: 
 4179: NS_IMETHODIMP
 4179: nsNavBookmarks::GetFolderReadonly(PRInt64 aFolder, PRBool *aResult)
 4179: {
29123:   NS_ENSURE_ARG_MIN(aFolder, 1);
29123:   NS_ENSURE_ARG_POINTER(aResult);
29123: 
 4179:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 4179:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 4179:   return annosvc->ItemHasAnnotation(aFolder, READ_ONLY_ANNO, aResult);
 4179: }
 4179: 
 4179: NS_IMETHODIMP
 4179: nsNavBookmarks::SetFolderReadonly(PRInt64 aFolder, PRBool aReadOnly)
 4179: {
29123:   NS_ENSURE_ARG_MIN(aFolder, 1);
29123: 
 4179:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 4179:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 4179:   if (aReadOnly) {
 4179:     return annosvc->SetItemAnnotationInt32(aFolder, READ_ONLY_ANNO, 1,
 4179:                                            0,
 4179:                                            nsAnnotationService::EXPIRE_NEVER);
 4179:   }
 4179:   else {
 4179:     PRBool hasAnno;
 4179:     nsresult rv = annosvc->ItemHasAnnotation(aFolder, READ_ONLY_ANNO, &hasAnno);
 4179:     NS_ENSURE_SUCCESS(rv, rv);
 4179:     if (hasAnno)
 4179:       return annosvc->RemoveItemAnnotation(aFolder, READ_ONLY_ANNO);
 4179:   }
 4179:   return NS_OK;
 4179: }
 4179: 
    1: nsresult
 4179: nsNavBookmarks::CreateContainerWithID(PRInt64 aItemId, PRInt64 aParent,
10046:                                       const nsACString& aName,
 4179:                                       const nsAString& aContractId,
 4179:                                       PRBool aIsBookmarkFolder,
    1:                                       PRInt32* aIndex, PRInt64* aNewFolder)
    1: {
    1:   // You can pass -1 to indicate append, but no other negative number is allowed
    1:   if (*aIndex < -1)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
 8275:   PRInt32 index;
31729:   PRInt32 folderCount;
31729:   nsresult rv = FolderCount(aParent, &folderCount);
31729:   NS_ENSURE_SUCCESS(rv, rv);
31729:   if (*aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
31729:       *aIndex >= folderCount) {
31729:     index = folderCount;
 8275:   } else {
 8275:     index = *aIndex;
 8275:     rv = AdjustIndices(aParent, index, PR_INT32_MAX, 1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 8275:   }
    1: 
29518:   ItemType containerType = aIsBookmarkFolder ? FOLDER
29518:                                              : DYNAMIC_CONTAINER;
29518:   rv = InsertBookmarkInDB(aItemId, nsnull, containerType, aParent, index,
29518:                           aName, PR_Now(), nsnull, aContractId, aNewFolder);
 3360:   NS_ENSURE_SUCCESS(rv, rv);
 3360: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                       OnItemAdded(*aNewFolder, aParent, index, containerType));
    1: 
    1:   *aIndex = index;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 1347: nsNavBookmarks::InsertSeparator(PRInt64 aParent, PRInt32 aIndex,
 1347:                                 PRInt64* aNewItemId)
    1: {
29123:   NS_ENSURE_ARG_MIN(aParent, 1);
34632:   // -1 means "append", but no other negative value is allowed.
34632:   NS_ENSURE_ARG_MIN(aIndex, -1);
29123:   NS_ENSURE_ARG_POINTER(aNewItemId);
29123: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
 8275:   PRInt32 index;
31729:   PRInt32 folderCount;
31729:   nsresult rv = FolderCount(aParent, &folderCount);
31729:   NS_ENSURE_SUCCESS(rv, rv);
31729:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
31729:       aIndex >= folderCount) {
31729:     index = folderCount;
34632:   }
34632:   else {
 8275:     index = aIndex;
 8275:     rv = AdjustIndices(aParent, index, PR_INT32_MAX, 1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 8275:   }
    1: 
29518:   nsCString voidString;
29518:   voidString.SetIsVoid(PR_TRUE);
29518:   rv = InsertBookmarkInDB(-1, nsnull, SEPARATOR, aParent, index,
29518:                           voidString, PR_Now(), nsnull, EmptyString(),
29518:                           aNewItemId);
 3360:   NS_ENSURE_SUCCESS(rv, rv);
 3360: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                       OnItemAdded(*aNewItemId, aParent, index, TYPE_SEPARATOR));
    1: 
    1:   return NS_OK;
    1: }
    1: 
11268: nsresult
11268: nsNavBookmarks::GetLastChildId(PRInt64 aFolder, PRInt64* aItemId)
11268: {
34632:   *aItemId = -1;
34632: 
11268:   nsCOMPtr<mozIStorageStatement> statement;
20874:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
11268:       "SELECT id FROM moz_bookmarks WHERE parent = ?1 "
34632:       "ORDER BY position DESC LIMIT 1"),
34632:     getter_AddRefs(statement));
11268:   NS_ENSURE_SUCCESS(rv, rv);
11268: 
11268:   rv = statement->BindInt64Parameter(0, aFolder);
11268:   NS_ENSURE_SUCCESS(rv, rv);
11268: 
34632:   PRBool found;
34632:   rv = statement->ExecuteStep(&found);
11268:   NS_ENSURE_SUCCESS(rv, rv);
34632:   if (found)
11268:     *aItemId = statement->AsInt64(0);
24787: 
11268:   return NS_OK;
11268: }
11268: 
11268: NS_IMETHODIMP
11268: nsNavBookmarks::GetIdForItemAt(PRInt64 aFolder, PRInt32 aIndex, PRInt64* aItemId)
11268: {
29123:   NS_ENSURE_ARG_MIN(aFolder, 1);
29123:   NS_ENSURE_ARG_POINTER(aItemId);
29123: 
34632:   *aItemId = -1;
34632: 
11268:   nsresult rv;
11268:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX) {
34632:     // Get last item within aFolder.
24787:     rv = GetLastChildId(aFolder, aItemId);
24787:     NS_ENSURE_SUCCESS(rv, rv);
34632:   }
34632:   else {
34632:     // Get the item in aFolder with position aIndex.
11268:     mozStorageStatementScoper scope(mDBGetChildAt);
11268: 
11268:     rv = mDBGetChildAt->BindInt64Parameter(0, aFolder);
11268:     NS_ENSURE_SUCCESS(rv, rv);
11268:     rv = mDBGetChildAt->BindInt32Parameter(1, aIndex);
11268:     NS_ENSURE_SUCCESS(rv, rv);
11268: 
34632:     PRBool found;
34632:     rv = mDBGetChildAt->ExecuteStep(&found);
11268:     NS_ENSURE_SUCCESS(rv, rv);
34632:     if (found)
11268:       *aItemId = mDBGetChildAt->AsInt64(0);
11268:   }
11268:   return NS_OK;
11268: }
11268: 
    1: nsresult 
    1: nsNavBookmarks::GetParentAndIndexOfFolder(PRInt64 aFolder, PRInt64* aParent, 
    1:                                           PRInt32* aIndex)
    1: {
    1:   nsCOMPtr<mozIStorageStatement> statement;
34632:   nsresult rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
34632:       "SELECT parent, position FROM moz_bookmarks WHERE id = ?1"),
34632:     getter_AddRefs(statement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
34632:   rv = statement->BindInt64Parameter(0, aFolder);
    1:   NS_ENSURE_SUCCESS(rv, rv);
34632: 
34632:   PRBool found;
34632:   rv = statement->ExecuteStep(&found);
34632:   NS_ENSURE_SUCCESS(rv, rv);
34632:   NS_ENSURE_TRUE(found, NS_ERROR_INVALID_ARG); // Folder does not exist.
    1: 
    1:   *aParent = statement->AsInt64(0);
    1:   *aIndex = statement->AsInt32(1);
    1: 
    1:   return NS_OK;
    1: }
    1: 
33340: NS_HIDDEN_(nsresult)
14272: nsNavBookmarks::RemoveFolder(PRInt64 aFolderId)
    1: {
24923:   NS_ENSURE_TRUE(aFolderId != mRoot, NS_ERROR_INVALID_ARG);
24923: 
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                       OnBeforeItemRemoved(aFolderId, TYPE_FOLDER));
26383: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
 6420: 
14272:   nsresult rv;
 1297:   PRInt64 parent;
14272:   PRInt32 index, type;
 1297:   nsCAutoString folderType;
 1297:   {
 1297:     mozStorageStatementScoper scope(mDBGetItemProperties);
14272:     rv = mDBGetItemProperties->BindInt64Parameter(0, aFolderId);
 1297:     NS_ENSURE_SUCCESS(rv, rv);
 1297: 
 1297:     PRBool results;
 1297:     rv = mDBGetItemProperties->ExecuteStep(&results);
 1297:     NS_ENSURE_SUCCESS(rv, rv);
 1297:     if (!results) {
 1297:       return NS_ERROR_INVALID_ARG; // folder is not in the hierarchy
 1297:     }
 1297: 
14272:     type = mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Type);
 1297:     parent = mDBGetItemProperties->AsInt64(kGetItemPropertiesIndex_Parent);
 1297:     index = mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Position);
 4179:     rv = mDBGetItemProperties->GetUTF8String(kGetItemPropertiesIndex_ServiceContractId, folderType);
 1297:     NS_ENSURE_SUCCESS(rv, rv);
 1297:   }
 1297: 
14272:   if (type != TYPE_FOLDER) {
14272:     NS_WARNING("RemoveFolder(): aFolderId is not a folder!");
14272:     return NS_ERROR_INVALID_ARG; // aFolderId is not a folder!
14272:   }
14272: 
14272:   // First, remove item annotations
14272:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
14272:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
14272:   rv = annosvc->RemoveItemAnnotations(aFolderId);
14272:   NS_ENSURE_SUCCESS(rv, rv);
14272: 
    1:   // If this is a container bookmark, try to notify its service.
    1:   if (folderType.Length() > 0) {
20374:     // There is a type associated with this folder.
 4179:     nsCOMPtr<nsIDynamicContainer> bmcServ = do_GetService(folderType.get());
    1:     if (bmcServ) {
14272:       rv = bmcServ->OnContainerRemoving(aFolderId);
    1:       if (NS_FAILED(rv))
    1:         NS_WARNING("Remove folder container notification failed.");
    1:     }
    1:   }
    1: 
 1297:   // Remove all of the folder's children
21350:   rv = RemoveFolderChildren(aFolderId);
21350:   NS_ENSURE_SUCCESS(rv, rv);
 1297: 
    1:   // Remove the folder from its parent
    1:   nsCAutoString buffer;
 1297:   buffer.AssignLiteral("DELETE FROM moz_bookmarks WHERE id = ");
14272:   buffer.AppendInt(aFolderId);
20874:   rv = mDBConn->ExecuteSimpleSQL(buffer);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = AdjustIndices(parent, index + 1, PR_INT32_MAX, -1);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
13203:   rv = SetItemDateInternal(mDBSetItemLastModified, parent, PR_Now());
 3360:   NS_ENSURE_SUCCESS(rv, rv);
 3360: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
14272:   if (aFolderId == mToolbarFolder) {
 1553:     mToolbarFolder = 0;
 1553:   }
 1553: 
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                       OnItemRemoved(aFolderId, parent, index, TYPE_FOLDER));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(nsNavBookmarks::RemoveFolderTransaction, nsITransaction)
    1: 
    1: NS_IMETHODIMP
29123: nsNavBookmarks::GetRemoveFolderTransaction(PRInt64 aFolderId, nsITransaction** aResult)
    1: {
29123:   NS_ENSURE_ARG_MIN(aFolderId, 1);
29123:   NS_ENSURE_ARG_POINTER(aResult);
29123: 
    1:   // Create and initialize a RemoveFolderTransaction object that can be used to
    1:   // recreate the folder safely later. 
    1: 
    1:   RemoveFolderTransaction* rft = 
29123:     new RemoveFolderTransaction(aFolderId);
    1:   if (!rft)
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:   NS_ADDREF(*aResult = rft);
    1:   return NS_OK;
    1: }
    1: 
21350: nsresult
21350: nsNavBookmarks::GetDescendantChildren(PRInt64 aFolderId,
21350:                                       PRInt64 aGrandParentId,
21350:                                       nsTArray<folderChildrenInfo>& aFolderChildrenArray) {
21350:   // New children will be added from this index on.
21350:   PRUint32 startIndex = aFolderChildrenArray.Length();
    1:   nsresult rv;
    1:   {
21350:     // Collect children informations.
    1:     mozStorageStatementScoper scope(mDBGetChildren);
21350:     rv = mDBGetChildren->BindInt64Parameter(0, aFolderId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRBool hasMore;
    1:     while (NS_SUCCEEDED(mDBGetChildren->ExecuteStep(&hasMore)) && hasMore) {
21350:       folderChildrenInfo child;
21350:       child.itemId = mDBGetChildren->AsInt64(nsNavHistory::kGetInfoIndex_ItemId);
21350:       child.parentId = aFolderId;
21350:       child.grandParentId = aGrandParentId;
21350:       child.itemType = (PRUint16) mDBGetChildren->AsInt32(kGetChildrenIndex_Type);
21350:       child.placeId = mDBGetChildren->AsInt64(kGetChildrenIndex_PlaceID);
21350:       child.index = mDBGetChildren->AsInt32(kGetChildrenIndex_Position);
21350: 
21350:       if (child.itemType == TYPE_BOOKMARK) {
21350:         nsCAutoString URIString;
21350:         rv = mDBGetChildren->GetUTF8String(nsNavHistory::kGetInfoIndex_URL,
21350:                                            URIString);
21350:         NS_ENSURE_SUCCESS(rv, rv);
21350:         child.url = URIString;
    1:       }
21350:       else if (child.itemType == TYPE_FOLDER) {
21350:         nsCAutoString folderType;
21350:         rv = mDBGetChildren->GetUTF8String(kGetChildrenIndex_ServiceContractId,
21350:                                            folderType);
21350:         NS_ENSURE_SUCCESS(rv, rv);
21350:         child.folderType = folderType;
    1:       }
21350:       // Append item to children's array.
21350:       aFolderChildrenArray.AppendElement(child);
    1:     }
21350:   }
21350: 
21350:   // Recursively call GetDescendantChildren for added folders.
21350:   // We start at startIndex since previous folders are checked
21350:   // by previous calls to this method.
21350:   PRUint32 childCount = aFolderChildrenArray.Length();
21350:   for (PRUint32 i = startIndex; i < childCount; i++) {
21350:     if (aFolderChildrenArray[i].itemType == TYPE_FOLDER) {
21350:       GetDescendantChildren(aFolderChildrenArray[i].itemId,
21350:                             aFolderId,
21350:                             aFolderChildrenArray);
21350:     }
21350:   }
21350: 
21350:   return NS_OK;
21350: }
21350: 
21350: NS_IMETHODIMP
21350: nsNavBookmarks::RemoveFolderChildren(PRInt64 aFolderId)
21350: {
21350:   nsresult rv;
21350:   PRUint16 itemType;
21350:   PRInt64 grandParentId;
21350:   {
21350:     mozStorageStatementScoper scope(mDBGetItemProperties);
21350:     rv = mDBGetItemProperties->BindInt64Parameter(0, aFolderId);
21350:     NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:     // Sanity check: ensure that item exists.
21350:     PRBool folderExists;
21350:     if (NS_FAILED(mDBGetItemProperties->ExecuteStep(&folderExists)) || !folderExists)
21350:       return NS_ERROR_INVALID_ARG;
21350: 
21350:     // Sanity check: ensure that this is a folder.
21350:     itemType = (PRUint16) mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Type);
21350:     if (itemType != TYPE_FOLDER)
21350:       return NS_ERROR_INVALID_ARG;
21350: 
21350:     // Get the grandParent.
21350:     // We have to do this only once since recursion will give us other
21350:     // grandParents without the need of additional queries.
21350:     grandParentId = mDBGetItemProperties->AsInt64(kGetItemPropertiesIndex_Parent);
21350:   }
21350: 
21350:   // Fill folder children array recursively.
21350:   nsTArray<folderChildrenInfo> folderChildrenArray;
21350:   rv = GetDescendantChildren(aFolderId, grandParentId, folderChildrenArray);
21350:   NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:   // Build a string of folders whose children will be removed.
21350:   nsCString foldersToRemove;
21350:   for (PRUint32 i = 0; i < folderChildrenArray.Length(); i++) {
21350:     folderChildrenInfo child = folderChildrenArray[i];
26383: 
26383:     // Notify observers that we are about to remove this child.
30050:     ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                         OnBeforeItemRemoved(child.itemId, child.itemType));
26383: 
21350:     if (child.itemType == TYPE_FOLDER) {
21350:       foldersToRemove.AppendLiteral(",");
21350:       foldersToRemove.AppendInt(child.itemId);
21350: 
21350:       // If this is a dynamic container, try to notify its service that we
21350:       // are going to remove it.
26383:       // XXX (bug 484094) this should use a bookmark observer!
21350:       if (child.folderType.Length() > 0) {
21350:         nsCOMPtr<nsIDynamicContainer> bmcServ =
21350:           do_GetService(child.folderType.get());
21350:         if (bmcServ) {
21350:           rv = bmcServ->OnContainerRemoving(child.itemId);
21350:           if (NS_FAILED(rv))
21350:             NS_WARNING("Remove folder container notification failed.");
21350:         }
21350:       }
21350:     }
21350:   }
21350: 
21350:   // Delete items from the database now.
21350:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
21350: 
24948:   nsCOMPtr<mozIStorageStatement> deleteStatement;
24948:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
21350:       "DELETE FROM moz_bookmarks "
24948:       "WHERE parent IN (?1") +
21350:         foldersToRemove +
24948:       NS_LITERAL_CSTRING(")"),
24948:     getter_AddRefs(deleteStatement));
24948:   NS_ENSURE_SUCCESS(rv, rv);
24948:   rv = deleteStatement->BindInt64Parameter(0, aFolderId);
24948:   NS_ENSURE_SUCCESS(rv, rv);
24948:   rv = deleteStatement->Execute();
21350:   NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:   // Clean up orphan items annotations.
21350:   rv = mDBConn->ExecuteSimpleSQL(
21350:     NS_LITERAL_CSTRING(
21350:       "DELETE FROM moz_items_annos "
21350:       "WHERE id IN ("
21350:         "SELECT a.id from moz_items_annos a "
21350:         "LEFT JOIN moz_bookmarks b ON a.item_id = b.id "
21350:         "WHERE b.id ISNULL)"));
21350:   NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:   // Set the lastModified date.
21350:   rv = SetItemDateInternal(mDBSetItemLastModified, aFolderId, PR_Now());
21350:   NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:   for (PRUint32 i = 0; i < folderChildrenArray.Length(); i++) {
21350:     folderChildrenInfo child = folderChildrenArray[i];
21350:     if (child.itemType == TYPE_BOOKMARK) {
21350:       PRInt64 placeId = child.placeId;
21350:       UpdateBookmarkHashOnRemove(placeId);
21350: 
25031:       // UpdateFrecency needs to know whether placeId is still bookmarked.
25031:       // Although we removed a child of aFolderId that bookmarked it, it may
25031:       // still be bookmarked elsewhere; IsRealBookmark will know.
35298:       nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:       NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
35298:       rv = history->UpdateFrecency(placeId, IsRealBookmark(placeId));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
21350:   }
21350: 
21350:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:   // Call observers in reverse order to serve children before their parent.
21350:   for (PRInt32 i = folderChildrenArray.Length() - 1; i >= 0 ; i--) {
21350:     folderChildrenInfo child = folderChildrenArray[i];
21350: 
30050:     ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
21350:                         OnItemRemoved(child.itemId,
21350:                                       child.parentId,
33340:                                       child.index,
33340:                                       child.itemType));
21350: 
21350:     if (child.itemType == TYPE_BOOKMARK) {
21350:       // If the removed bookmark was a child of a tag container, notify all
21350:       // bookmark-folder result nodes which contain a bookmark for the removed
21350:       // bookmark's url.
21350: 
21350:       if (child.grandParentId == mTagRoot) {
21350:         nsCOMPtr<nsIURI> uri;
21350:         rv = NS_NewURI(getter_AddRefs(uri), child.url);
21350:         NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:         nsTArray<PRInt64> bookmarks;
34260:         rv = GetBookmarkIdsForURITArray(uri, bookmarks);
21350:         NS_ENSURE_SUCCESS(rv, rv);
21350: 
21350:         if (bookmarks.Length()) {
21350:           for (PRUint32 i = 0; i < bookmarks.Length(); i++) {
30050:             ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
33340:                                 OnItemChanged(bookmarks[i],
33340:                                               NS_LITERAL_CSTRING("tags"),
33340:                                               PR_FALSE,
33340:                                               EmptyCString(),
33340:                                               0,
35298:                                               TYPE_BOOKMARK));
    1:           }
21350:         }
21350:       }
21350:     }
21350:   }
21350: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 1726: nsNavBookmarks::MoveItem(PRInt64 aItemId, PRInt64 aNewParent, PRInt32 aIndex)
    1: {
24923:   NS_ENSURE_TRUE(aItemId != mRoot, NS_ERROR_INVALID_ARG);
24923: 
    1:   // You can pass -1 to indicate append, but no other negative number is allowed
    1:   if (aIndex < -1)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
 7122:   // Disallow making an item its own parent.
 1726:   if (aItemId == aNewParent)
 1297:     return NS_ERROR_INVALID_ARG;
 1297: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
 1297:   // get item properties
 1297:   nsresult rv;
 1297:   PRInt64 oldParent;
21350:   PRInt32 oldIndex;
21350:   PRUint16 itemType;
 1726:   nsCAutoString folderType;
    1:   {
 1297:     mozStorageStatementScoper scope(mDBGetItemProperties);
 1726:     rv = mDBGetItemProperties->BindInt64Parameter(0, aItemId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRBool results;
 1297:     rv = mDBGetItemProperties->ExecuteStep(&results);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     if (!results) {
    1:       return NS_ERROR_INVALID_ARG; // folder is not in the hierarchy
    1:     }
    1: 
 1297:     oldParent = mDBGetItemProperties->AsInt64(kGetItemPropertiesIndex_Parent);
 1297:     oldIndex = mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Position);
21350:     itemType = (PRUint16) mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Type);
 1726:     if (itemType == TYPE_FOLDER) {
 4179:       rv = mDBGetItemProperties->GetUTF8String(kGetItemPropertiesIndex_ServiceContractId,
 1726:                                                folderType);
 1297:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
 1726:   }
    1: 
 1297:   // if parent and index are the same, nothing to do
 1297:   if (oldParent == aNewParent && oldIndex == aIndex)
 1297:     return NS_OK;
 1297: 
    1:   // Make sure aNewParent is not aFolder or a subfolder of aFolder
 1726:   if (itemType == TYPE_FOLDER) {
 2292:     PRInt64 p = aNewParent;
 2292: 
 2292:     while (p) {
 1297:       mozStorageStatementScoper scope(mDBGetItemProperties);
 1726:       if (p == aItemId) {
    1:         return NS_ERROR_INVALID_ARG;
    1:       }
    1: 
 1297:       rv = mDBGetItemProperties->BindInt64Parameter(0, p);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       PRBool results;
 1297:       rv = mDBGetItemProperties->ExecuteStep(&results);
    1:       NS_ENSURE_SUCCESS(rv, rv);
 1297:       p = results ? mDBGetItemProperties->AsInt64(kGetItemPropertiesIndex_Parent) : 0;
    1:     }
    1:   }
    1: 
 1297:   // calculate new index
    1:   PRInt32 newIndex;
31729:   PRInt32 folderCount;
31729:   rv = FolderCount(aNewParent, &folderCount);
31729:   NS_ENSURE_SUCCESS(rv, rv);
31729:   if (aIndex == nsINavBookmarksService::DEFAULT_INDEX ||
31729:       aIndex >= folderCount) {
31729:     newIndex = folderCount;
    1:     // If the parent remains the same, then the folder is really being moved
    1:     // to count - 1 (since it's being removed from the old position)
 1297:     if (oldParent == aNewParent) {
    1:       --newIndex;
    1:     }
    1:   } else {
    1:     newIndex = aIndex;
    1: 
 1297:     if (oldParent == aNewParent && newIndex > oldIndex) {
    1:       // when an item is being moved lower in the same folder, the new index
    1:       // refers to the index before it was removed. Removal causes everything
    1:       // to shift up.
    1:       --newIndex;
    1:     }
    1:   }
    1: 
 1297:   // this is like the previous check, except this covers if
 1297:   // the specified index was -1 (append), and the calculated
 1297:   // new index is the same as the existing index
 1297:   if (aNewParent == oldParent && newIndex == oldIndex) {
    1:     // Nothing to do!
    1:     return NS_OK;
    1:   }
    1: 
 1297:   // adjust indices to account for the move
 2019:   // do this before we update the parent/index fields
 2019:   // or we'll re-adjust the index for the item we are moving
 1297:   if (oldParent == aNewParent) {
    1:     // We can optimize the updates if moving within the same container.
    1:     // We only shift the items between the old and new positions, since the
    1:     // insertion will offset the deletion.
    1:     if (oldIndex > newIndex) {
 1297:       rv = AdjustIndices(oldParent, newIndex, oldIndex - 1, 1);
    1:     } else {
 1297:       rv = AdjustIndices(oldParent, oldIndex + 1, newIndex, -1);
    1:     }
    1:   } else {
    1:     // We're moving between containers, so this happens in two steps.
 1297:     // First, fill the hole from the removal from the old parent.
 1297:     rv = AdjustIndices(oldParent, oldIndex + 1, PR_INT32_MAX, -1);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     // Now, make room in the new parent for the insertion.
14032:     rv = AdjustIndices(aNewParent, newIndex, PR_INT32_MAX, 1);
    1:   }
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 2019:   // update parent/index fields
 2019:   nsCAutoString buffer;
 2019:   buffer.AssignLiteral("UPDATE moz_bookmarks SET ");
 2019:   if (aNewParent != oldParent) {
 2019:     buffer.AppendLiteral(" parent = ");
 2019:     buffer.AppendInt(aNewParent);
 2019:   }
 2019:   if (newIndex != oldIndex) {
 2019:     if (aNewParent != oldParent)
 2019:       buffer.AppendLiteral(", ");
 2019:     buffer.AppendLiteral(" position = ");
 2019:     buffer.AppendInt(newIndex);
 2019:   }
 2019:   buffer.AppendLiteral(" WHERE id = ");
 2019:   buffer.AppendInt(aItemId);
20874:   rv = mDBConn->ExecuteSimpleSQL(buffer);
 2019:   NS_ENSURE_SUCCESS(rv, rv);
 2019: 
 3360:   PRTime now = PR_Now();
14274:   rv = SetItemDateInternal(mDBSetItemLastModified, oldParent, now);
 3360:   NS_ENSURE_SUCCESS(rv, rv);
14274:   rv = SetItemDateInternal(mDBSetItemLastModified, aNewParent, now);
 3360:   NS_ENSURE_SUCCESS(rv, rv);
 3360: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // notify bookmark observers
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
 1726:                       OnItemMoved(aItemId, oldParent, oldIndex, aNewParent,
35298:                                   newIndex, itemType));
    1: 
 4179:   // notify dynamic container provider if there is one
 1726:   if (!folderType.IsEmpty()) {
 4179:     nsCOMPtr<nsIDynamicContainer> container =
 1726:       do_GetService(folderType.get(), &rv);
    1:     if (NS_SUCCEEDED(rv)) {
 1726:       rv = container->OnContainerMoved(aItemId, aNewParent, newIndex);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
13203: nsresult
13203: nsNavBookmarks::SetItemDateInternal(mozIStorageStatement* aStatement, PRInt64 aItemId, PRTime aValue)
13203: {
13203:   mozStorageStatementScoper scope(aStatement);
13203:   nsresult rv = aStatement->BindInt64Parameter(0, aValue);
13203:   NS_ENSURE_SUCCESS(rv, rv);
13203:   rv = aStatement->BindInt64Parameter(1, aItemId);
13203:   NS_ENSURE_SUCCESS(rv, rv);
13203: 
13203:   rv = aStatement->Execute();
13203:   NS_ENSURE_SUCCESS(rv, rv);
13203: 
13203:   // note, we are not notifying the observers
13203:   // that the item has changed.
13203: 
13203:   return NS_OK;
13203: }
13203: 
    1: NS_IMETHODIMP
 1604: nsNavBookmarks::SetItemDateAdded(PRInt64 aItemId, PRTime aDateAdded)
 1604: {
33340:   // GetItemType also ensures that aItemId points to a valid item.
33340:   PRUint16 itemType;
33340:   nsresult rv = GetItemType(aItemId, &itemType);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
13203: 
33340:   rv = SetItemDateInternal(mDBSetItemDateAdded, aItemId, aDateAdded);
33340:   NS_ENSURE_SUCCESS(rv, rv);
33340: 
33340:   // Note: mDBSetItemDateAdded also sets lastModified to aDateAdded.
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
13203:                       OnItemChanged(aItemId, NS_LITERAL_CSTRING("dateAdded"),
33340:                                     PR_FALSE,
33340:                                     nsPrintfCString(16, "%lld", aDateAdded),
33340:                                     aDateAdded,
33340:                                     itemType));
 1604:   return NS_OK;
 1604: }
 1604: 
 1604: NS_IMETHODIMP
 1604: nsNavBookmarks::GetItemDateAdded(PRInt64 aItemId, PRTime *aDateAdded)
 1604: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 1604:   NS_ENSURE_ARG_POINTER(aDateAdded);
 1604: 
 1604:   mozStorageStatementScoper scope(mDBGetItemProperties);
 1604:   nsresult rv = mDBGetItemProperties->BindInt64Parameter(0, aItemId);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
 1604:   PRBool results;
 1604:   rv = mDBGetItemProperties->ExecuteStep(&results);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
 1604:   if (!results)
 1604:     return NS_ERROR_INVALID_ARG; // invalid item id
 1604: 
 1604:   return mDBGetItemProperties->GetInt64(kGetItemPropertiesIndex_DateAdded, aDateAdded);
 1604: }
 1604: 
 1604: NS_IMETHODIMP
 1604: nsNavBookmarks::SetItemLastModified(PRInt64 aItemId, PRTime aLastModified)
 1604: {
33340:   // GetItemType also ensures that aItemId points to a valid item.
33340:   PRUint16 itemType;
33340:   nsresult rv = GetItemType(aItemId, &itemType);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
13203: 
33340:   rv = SetItemDateInternal(mDBSetItemLastModified, aItemId, aLastModified);
33340:   NS_ENSURE_SUCCESS(rv, rv);
33340: 
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
33340:                       OnItemChanged(aItemId,
33340:                                     NS_LITERAL_CSTRING("lastModified"),
33340:                                     PR_FALSE,
33340:                                     nsPrintfCString(16, "%lld", aLastModified),
33340:                                     aLastModified,
33340:                                     itemType));
 1604:   return NS_OK;
 1604: }
 1604: 
 1604: NS_IMETHODIMP
 1604: nsNavBookmarks::GetItemLastModified(PRInt64 aItemId, PRTime *aLastModified)
 1604: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
 1604:   NS_ENSURE_ARG_POINTER(aLastModified);
 1604: 
 1604:   mozStorageStatementScoper scope(mDBGetItemProperties);
 1604:   nsresult rv = mDBGetItemProperties->BindInt64Parameter(0, aItemId);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
 1604:   PRBool results;
 1604:   rv = mDBGetItemProperties->ExecuteStep(&results);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
 1604:   if (!results)
 1604:     return NS_ERROR_INVALID_ARG; // invalid item id
 1604: 
 1604:   return mDBGetItemProperties->GetInt64(kGetItemPropertiesIndex_LastModified, aLastModified);
 1604: }
 1604: 
20874: nsresult
20874: nsNavBookmarks::GetGUIDBase(nsAString &aGUIDBase)
20874: {
20874:   if (!mGUIDBase.IsEmpty()) {
20874:     aGUIDBase = mGUIDBase;
20874:     return NS_OK;
20874:   }
20874: 
20874:   // generate a new GUID base for this session
20874:   nsCOMPtr<nsIUUIDGenerator> uuidgen =
20874:     do_GetService("@mozilla.org/uuid-generator;1");
20874:   NS_ENSURE_TRUE(uuidgen, NS_ERROR_OUT_OF_MEMORY);
20874:   nsID GUID;
20874:   nsresult rv = uuidgen->GenerateUUIDInPlace(&GUID);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   char GUIDChars[NSID_LENGTH];
20874:   GUID.ToProvidedString(GUIDChars);
20874:   CopyASCIItoUTF16(GUIDChars, mGUIDBase);
20874:   aGUIDBase = mGUIDBase;
20874:   return NS_OK;
20874: }
20874: 
 1604: NS_IMETHODIMP
 4004: nsNavBookmarks::GetItemGUID(PRInt64 aItemId, nsAString &aGUID)
 4004: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
29123: 
 4004:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 4004:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 4004:   nsresult rv = annosvc->GetItemAnnotationString(aItemId, GUID_ANNO, aGUID);
 4004: 
 4004:   if (NS_SUCCEEDED(rv) || rv != NS_ERROR_NOT_AVAILABLE)
 4004:     return rv;
 4004: 
 4004:   nsAutoString tmp;
 4004:   tmp.AppendInt(mItemCount++);
10204:   aGUID.SetCapacity(NSID_LENGTH - 1 + tmp.Length());
20874:   nsString GUIDBase;
20874:   rv = GetGUIDBase(GUIDBase);
20874:   NS_ENSURE_SUCCESS(rv, rv);
20874:   aGUID.Assign(GUIDBase);
10204:   aGUID.Append(tmp);
 4004: 
 4004:   return SetItemGUID(aItemId, aGUID);
 4004: }
 4004: 
 4004: NS_IMETHODIMP
 4004: nsNavBookmarks::SetItemGUID(PRInt64 aItemId, const nsAString &aGUID)
 4004: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
29123: 
 4004:   PRInt64 checkId;
 4004:   GetItemIdForGUID(aGUID, &checkId);
 4004:   if (checkId != -1)
 4004:     return NS_ERROR_INVALID_ARG; // invalid GUID, already exists
 4004: 
 4004:   nsAnnotationService* annosvc = nsAnnotationService::GetAnnotationService();
 4004:   NS_ENSURE_TRUE(annosvc, NS_ERROR_OUT_OF_MEMORY);
 4004:   return annosvc->SetItemAnnotationString(aItemId, GUID_ANNO, aGUID, 0,
 4004:                                           nsIAnnotationService::EXPIRE_NEVER);
 4004: }
 4004: 
 4004: NS_IMETHODIMP
 4004: nsNavBookmarks::GetItemIdForGUID(const nsAString &aGUID, PRInt64 *aItemId)
 4004: {
29123:   NS_ENSURE_ARG_POINTER(aItemId);
29123: 
 4004:   mozStorageStatementScoper scoper(mDBGetItemIdForGUID);
 4004:   nsresult rv = mDBGetItemIdForGUID->BindStringParameter(0, aGUID);
 4004:   NS_ENSURE_SUCCESS(rv, rv);
 4004: 
 4004:   PRBool hasMore = PR_FALSE;
 4004:   rv = mDBGetItemIdForGUID->ExecuteStep(&hasMore);
 4004:   if (NS_FAILED(rv) || ! hasMore) {
 4004:     *aItemId = -1;
 4004:     return NS_OK; // not found: return -1
 4004:   }
 4004: 
 4004:   // found, get the itemId
 4004:   return mDBGetItemIdForGUID->GetInt64(0, aItemId);
 4004: }
 4004: 
 4004: NS_IMETHODIMP
10046: nsNavBookmarks::SetItemTitle(PRInt64 aItemId, const nsACString &aTitle)
    1: {
33340:   // GetItemType also ensures that aItemId points to a valid item.
33340:   PRUint16 itemType;
33340:   nsresult rv = GetItemType(aItemId, &itemType);
33340:   NS_ENSURE_SUCCESS(rv, rv);
29123: 
    1:   nsCOMPtr<mozIStorageStatement> statement;
33340:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
14289:       "UPDATE moz_bookmarks SET title = ?1, lastModified = ?2 WHERE id = ?3"),
    1:     getter_AddRefs(statement));
    1:   NS_ENSURE_SUCCESS(rv, rv);
27919:   // Support setting a null title, we support this in insertBookmark.
27919:   if (aTitle.IsVoid())
28349:     rv = statement->BindNullParameter(0);
27919:   else
10046:     rv = statement->BindUTF8StringParameter(0, aTitle);
    1:   NS_ENSURE_SUCCESS(rv, rv);
29518:   PRTime lastModified = PR_Now();
29518:   rv = statement->BindInt64Parameter(1, lastModified);
    1:   NS_ENSURE_SUCCESS(rv, rv);
14289:   rv = statement->BindInt64Parameter(2, aItemId);
14289:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = statement->Execute();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
33340:                       OnItemChanged(aItemId,
33340:                                     NS_LITERAL_CSTRING("title"),
33340:                                     PR_FALSE,
33340:                                     aTitle,
33340:                                     lastModified,
33340:                                     itemType));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
10046: nsNavBookmarks::GetItemTitle(PRInt64 aItemId, nsACString &aTitle)
    1: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
29123: 
 1297:   mozStorageStatementScoper scope(mDBGetItemProperties);
    1: 
 1297:   nsresult rv = mDBGetItemProperties->BindInt64Parameter(0, aItemId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool results;
 1297:   rv = mDBGetItemProperties->ExecuteStep(&results);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!results)
    1:     return NS_ERROR_INVALID_ARG; // invalid bookmark id
    1: 
10046:   return mDBGetItemProperties->GetUTF8String(kGetItemPropertiesIndex_Title, aTitle);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetBookmarkURI(PRInt64 aItemId, nsIURI **aURI)
    1: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
    1:   NS_ENSURE_ARG_POINTER(aURI);
    1: 
 1297:   mozStorageStatementScoper scope(mDBGetItemProperties);
 1297:   nsresult rv = mDBGetItemProperties->BindInt64Parameter(0, aItemId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool results;
 1297:   rv = mDBGetItemProperties->ExecuteStep(&results);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!results)
    1:     return NS_ERROR_INVALID_ARG; // invalid bookmark id
    1: 
 1297:   PRInt32 type = mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Type);
 1297:   if (type != TYPE_BOOKMARK)
 1297:     return NS_ERROR_INVALID_ARG; // invalid type (only for bookmarks)
 1297: 
    1:   nsCAutoString spec;
 1297:   rv = mDBGetItemProperties->GetUTF8String(kGetItemPropertiesIndex_URI, spec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = NS_NewURI(aURI, spec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 1347: nsNavBookmarks::GetItemType(PRInt64 aItemId, PRUint16 *aType)
    1: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
29123:   NS_ENSURE_ARG_POINTER(aType);
29123: 
 1297:   mozStorageStatementScoper scope(mDBGetItemProperties);
 1297: 
 1297:   nsresult rv = mDBGetItemProperties->BindInt64Parameter(0, aItemId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool results;
 1297:   rv = mDBGetItemProperties->ExecuteStep(&results);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
 1297:   if (!results) {
    1:     return NS_ERROR_INVALID_ARG; // invalid bookmark id
 1297:   }
    1: 
 1347:   *aType = (PRUint16)mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Type);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNavBookmarks::GetFolderType(PRInt64 aFolder, nsACString &aType)
    1: {
 1297:   mozStorageStatementScoper scope(mDBGetItemProperties);
 1297:   nsresult rv = mDBGetItemProperties->BindInt64Parameter(0, aFolder);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool results;
 1297:   rv = mDBGetItemProperties->ExecuteStep(&results);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!results) {
    1:     return NS_ERROR_INVALID_ARG;
    1:   }
    1: 
 4179:   return mDBGetItemProperties->GetUTF8String(kGetItemPropertiesIndex_ServiceContractId, aType);
    1: }
    1: 
    1: nsresult
 4179: nsNavBookmarks::ResultNodeForContainer(PRInt64 aID,
    1:                                        nsNavHistoryQueryOptions *aOptions,
    1:                                        nsNavHistoryResultNode **aNode)
    1: {
 1297:   mozStorageStatementScoper scope(mDBGetItemProperties);
 1297:   mDBGetItemProperties->BindInt64Parameter(0, aID);
    1: 
    1:   PRBool results;
 1297:   nsresult rv = mDBGetItemProperties->ExecuteStep(&results);
    1:   NS_ENSURE_SUCCESS(rv, rv);
 4179:   NS_ASSERTION(results, "ResultNodeForContainer expects a valid item id");
 4179: 
33458:   // title
33458:   nsCAutoString title;
33458:   rv = mDBGetItemProperties->GetUTF8String(kGetItemPropertiesIndex_Title, title);
33458: 
33458:   PRUint16 itemType = (PRUint16) mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Type);
33458:   if (itemType == TYPE_DYNAMIC_CONTAINER) {
 4179:     // contract id
 4179:     nsCAutoString contractId;
 4179:     rv = mDBGetItemProperties->GetUTF8String(kGetItemPropertiesIndex_ServiceContractId,
 4179:                                              contractId);
    1:     NS_ENSURE_SUCCESS(rv, rv);
 4179:     *aNode = new nsNavHistoryContainerResultNode(EmptyCString(), title, EmptyCString(),
 4179:                                                  nsINavHistoryResultNode::RESULT_TYPE_DYNAMIC_CONTAINER,
 4179:                                                  PR_TRUE,
 4179:                                                  contractId,
 4179:                                                  aOptions);
 4179:     (*aNode)->mItemId = aID;
 4179:   } else { // TYPE_FOLDER
33458:     *aNode = new nsNavHistoryFolderResultNode(title, aOptions, aID, EmptyCString());
 4179:   }
    1:   if (!*aNode)
    1:     return NS_ERROR_OUT_OF_MEMORY;
 1635: 
 1635:   (*aNode)->mDateAdded =
 1635:     mDBGetItemProperties->AsInt64(kGetItemPropertiesIndex_DateAdded);
 1635:   (*aNode)->mLastModified =
 1635:     mDBGetItemProperties->AsInt64(kGetItemPropertiesIndex_LastModified);
 1635: 
    1:   NS_ADDREF(*aNode);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsNavBookmarks::QueryFolderChildren(PRInt64 aFolderId,
    1:                                     nsNavHistoryQueryOptions *aOptions,
    1:                                     nsCOMArray<nsNavHistoryResultNode> *aChildren)
    1: {
    1:   mozStorageStatementScoper scope(mDBGetChildren);
    1: 
    1:   nsresult rv = mDBGetChildren->BindInt64Parameter(0, aFolderId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool results;
    1: 
    1:   nsCOMPtr<nsNavHistoryQueryOptions> options = do_QueryInterface(aOptions, &rv);
20374:   NS_ENSURE_SUCCESS(rv, rv);
20374: 
    1:   PRInt32 index = -1;
    1:   while (NS_SUCCEEDED(mDBGetChildren->ExecuteStep(&results)) && results) {
    1: 
    1:     // The results will be in order of index. Even if we don't add a node
20072:     // because it was excluded, we need to count its index, so do that
    1:     // before doing anything else. Index was initialized to -1 above, so
    1:     // it will start counting at 0 the first time through the loop.
    1:     index ++;
    1: 
21350:     PRUint16 itemType = (PRUint16) mDBGetChildren->AsInt32(kGetChildrenIndex_Type);
 1337:     PRInt64 id = mDBGetChildren->AsInt64(nsNavHistory::kGetInfoIndex_ItemId);
 7025:     nsRefPtr<nsNavHistoryResultNode> node;
11421:     if (itemType == TYPE_BOOKMARK) {
35298:       nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:       NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
35298:       rv = history->RowToResult(mDBGetChildren, options, getter_AddRefs(node));
11421:       NS_ENSURE_SUCCESS(rv, rv);
11421: 
11421:       PRUint32 nodeType;
11421:       node->GetType(&nodeType);
11421:       if ((nodeType == nsINavHistoryResultNode::RESULT_TYPE_QUERY &&
11421:            aOptions->ExcludeQueries()) ||
11421:           (nodeType != nsINavHistoryResultNode::RESULT_TYPE_QUERY &&
11421:            nodeType != nsINavHistoryResultNode::RESULT_TYPE_FOLDER_SHORTCUT &&
11421:            aOptions->ExcludeItems())) {
11421:         continue;
11421:       }
11421:     } else if (itemType == TYPE_FOLDER || itemType == TYPE_DYNAMIC_CONTAINER) {
20374:       if (options->ExcludeReadOnlyFolders()) {
    1:         // see if it's read only and skip it
    1:         PRBool readOnly = PR_FALSE;
 1297:         GetFolderReadonly(id, &readOnly);
    1:         if (readOnly)
    1:           continue; // skip
    1:       }
    1: 
 4179:       rv = ResultNodeForContainer(id, aOptions, getter_AddRefs(node));
    1:       if (NS_FAILED(rv))
    1:         continue;
11421:     } else {
    1:       // separator
    1:       if (aOptions->ExcludeItems()) {
    1:         continue;
    1:       }
    1:       node = new nsNavHistorySeparatorResultNode();
    1:       NS_ENSURE_TRUE(node, NS_ERROR_OUT_OF_MEMORY);
  809: 
 1337:       // add the item identifier (RowToResult does so for bookmark items in
  809:       // the next else block);
 1337:       node->mItemId =
 1337:         mDBGetChildren->AsInt64(nsNavHistory::kGetInfoIndex_ItemId);
 1635: 
 1635:       // date-added and last-modified
 1635:       node->mDateAdded =
 1635:         mDBGetChildren->AsInt64(nsNavHistory::kGetInfoIndex_ItemDateAdded);
 1635:       node->mLastModified =
 1635:         mDBGetChildren->AsInt64(nsNavHistory::kGetInfoIndex_ItemLastModified);
    1:     }
    1: 
    1:     // this method fills all bookmark queries, so we store the index of the
    1:     // item in its parent
    1:     node->mBookmarkIndex = index;
    1: 
    1:     NS_ENSURE_TRUE(aChildren->AppendObject(node), NS_ERROR_OUT_OF_MEMORY);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
31729: nsresult
31729: nsNavBookmarks::FolderCount(PRInt64 aFolderId, PRInt32 *aFolderCount)
    1: {
31729:   *aFolderCount = 0;
    1:   mozStorageStatementScoper scope(mDBFolderCount);
    1: 
31729:   nsresult rv = mDBFolderCount->BindInt64Parameter(0, aFolderId);
31729:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool results;
    1:   rv = mDBFolderCount->ExecuteStep(&results);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
31729:   // Ensure that the folder we are looking for exists.
31729:   NS_ENSURE_TRUE(mDBFolderCount->AsInt64(1) == aFolderId, NS_ERROR_INVALID_ARG);
31729: 
31729:   *aFolderCount = mDBFolderCount->AsInt32(0);
31729: 
31729:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::IsBookmarked(nsIURI *aURI, PRBool *aBookmarked)
    1: {
14272:   NS_ENSURE_ARG(aURI);
29123:   NS_ENSURE_ARG_POINTER(aBookmarked);
14272: 
35298:   nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // convert the URL to an ID
    1:   PRInt64 urlID;
    1:   nsresult rv = history->GetUrlIdFor(aURI, &urlID, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (! urlID) {
    1:     // never seen this before, not even in history
    1:     *aBookmarked = PR_FALSE;
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRInt64 bookmarkedID;
29144:   PRBool foundOne = GetBookmarksHash()->Get(urlID, &bookmarkedID);
    1: 
    1:   // IsBookmarked only tests if this exact URI is bookmarked, so we need to
    1:   // check that the destination matches
    1:   if (foundOne)
    1:     *aBookmarked = (urlID == bookmarkedID);
    1:   else
    1:     *aBookmarked = PR_FALSE;
    1: 
    1: #ifdef DEBUG
    1:   // sanity check for the bookmark hashtable
    1:   PRBool realBookmarked;
    1:   rv = IsBookmarkedInDatabase(urlID, &realBookmarked);
    1:   NS_ASSERTION(realBookmarked == *aBookmarked,
    1:                "Bookmark hash table out-of-sync with the database");
    1: #endif
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetBookmarkedURIFor(nsIURI* aURI, nsIURI** _retval)
    1: {
29123:   NS_ENSURE_ARG(aURI);
29123:   NS_ENSURE_ARG_POINTER(_retval);
29123: 
    1:   *_retval = nsnull;
    1: 
35298:   nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   // convert the URL to an ID
    1:   PRInt64 urlID;
    1:   nsresult rv = history->GetUrlIdFor(aURI, &urlID, PR_FALSE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (! urlID) {
    1:     // never seen this before, not even in history, leave result NULL
    1:     return NS_OK;
    1:   }
    1: 
    1:   PRInt64 bookmarkID;
29144:   if (GetBookmarksHash()->Get(urlID, &bookmarkID)) {
    1:     // found one, convert ID back to URL. This statement is NOT refcounted
    1:     mozIStorageStatement* statement = history->DBGetIdPageInfo();
35411:     NS_ENSURE_STATE(statement);
    1:     mozStorageStatementScoper scoper(statement);
    1: 
    1:     rv = statement->BindInt64Parameter(0, bookmarkID);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     PRBool hasMore;
    1:     if (NS_SUCCEEDED(statement->ExecuteStep(&hasMore)) && hasMore) {
    1:       nsCAutoString spec;
    1:       statement->GetUTF8String(nsNavHistory::kGetInfoIndex_URL, spec);
    1:       return NS_NewURI(_retval, spec);
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::ChangeBookmarkURI(PRInt64 aBookmarkId, nsIURI *aNewURI)
    1: {
29123:   NS_ENSURE_ARG_MIN(aBookmarkId, 1);
 1337:   NS_ENSURE_ARG(aNewURI);
 1337: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1: 
35298:   nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:   NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
35298: 
    1:   PRInt64 placeId;
35298:   nsresult rv = history->GetUrlIdFor(aNewURI, &placeId, PR_TRUE);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!placeId)
    1:     return NS_ERROR_INVALID_ARG;
    1: 
23593:   // We need the bookmark's current corresponding places ID below, so get it now
23593:   // before we change it.  GetBookmarkURI will fail if aBookmarkId is bad.
23593:   nsCOMPtr<nsIURI> oldURI;
23593:   PRInt64 oldPlaceId;
23593:   rv = GetBookmarkURI(aBookmarkId, getter_AddRefs(oldURI));
23593:   NS_ENSURE_SUCCESS(rv, rv);
35298:   rv = history->GetUrlIdFor(oldURI, &oldPlaceId, PR_FALSE);
23593:   NS_ENSURE_SUCCESS(rv, rv);
23593: 
    1:   nsCOMPtr<mozIStorageStatement> statement;
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
29518:       "UPDATE moz_bookmarks SET fk = ?1, lastModified = ?2 WHERE id = ?3"),
    1:     getter_AddRefs(statement));
29518:   rv = statement->BindInt64Parameter(0, placeId);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518:   PRTime lastModified = PR_Now();
29518:   rv = statement->BindInt64Parameter(1, lastModified);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518:   rv = statement->BindInt64Parameter(2, aBookmarkId);
29518:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = statement->Execute();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = transaction.Commit();
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
23746:   // Add new URI to bookmark hash.
23746:   rv = AddBookmarkToHash(placeId, 0);
23746:   NS_ENSURE_SUCCESS(rv, rv);
23746: 
23746:   // Remove old URI from bookmark hash.
23746:   rv = UpdateBookmarkHashOnRemove(oldPlaceId);
23746:   NS_ENSURE_SUCCESS(rv, rv);
23746: 
23593:   // Upon changing the URI for a bookmark, update the frecency for the new place.
23593:   // UpdateFrecency needs to know whether placeId is bookmarked (as opposed
23593:   // to a livemark item).  Bookmarking it is exactly what we did above.
35298:   rv = history->UpdateFrecency(placeId, PR_TRUE /* isBookmarked */);
10669:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
23593:   // Upon changing the URI for a bookmark, update the frecency for the old place.
23593:   // UpdateFrecency again needs to know whether oldPlaceId is bookmarked.  It may
23593:   // no longer be, so we need to figure out whether it still is.  Our strategy
23593:   // is: find all bookmarks corresponding to oldPlaceId that are not livemark
23593:   // items, i.e., whose parents are not livemarks.  If any such bookmarks exist,
23593:   // oldPlaceId is still bookmarked.
24324: 
35298:   rv = history->UpdateFrecency(oldPlaceId, IsRealBookmark(oldPlaceId));
23593:   NS_ENSURE_SUCCESS(rv, rv);
10669: 
 1337:   nsCAutoString spec;
 1337:   rv = aNewURI->GetSpec(spec);
 1337:   NS_ENSURE_SUCCESS(rv, rv);
 1337: 
    1:   // Pass the new URI to OnItemChanged.
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
33340:     OnItemChanged(aBookmarkId, NS_LITERAL_CSTRING("uri"), PR_FALSE, spec,
35298:                   lastModified, TYPE_BOOKMARK));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetFolderIdForItem(PRInt64 aItemId, PRInt64 *aFolderId)
    1: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
    1:   NS_ENSURE_ARG_POINTER(aFolderId);
    1: 
 1297:   mozStorageStatementScoper scope(mDBGetItemProperties);
 1297:   nsresult rv = mDBGetItemProperties->BindInt64Parameter(0, aItemId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool results;
 1297:   rv = mDBGetItemProperties->ExecuteStep(&results);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!results)
    1:     return NS_ERROR_INVALID_ARG; // invalid item id
    1: 
 7122:   rv = mDBGetItemProperties->GetInt64(kGetItemPropertiesIndex_Parent, aFolderId);
 7122:   NS_ENSURE_SUCCESS(rv, rv);
 7122: 
 7122:   // this should not happen, but see bug #400448 for details
 7122:   NS_ENSURE_TRUE(aItemId != *aFolderId, NS_ERROR_UNEXPECTED);
 7122:   return NS_OK;
    1: }
    1: 
34260: nsresult
    1: nsNavBookmarks::GetBookmarkIdsForURITArray(nsIURI *aURI,
34260:                                            nsTArray<PRInt64> &aResult)
    1: {
34260:   NS_PRECONDITION(aURI, "Should not be null");
29123:   NS_ENSURE_ARG(aURI);
29123: 
    1:   mozStorageStatementScoper scope(mDBFindURIBookmarks);
    1: 
    1:   nsresult rv = BindStatementURI(mDBFindURIBookmarks, 0, aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
31039:   rv = mDBFindURIBookmarks->BindInt32Parameter(1, TYPE_BOOKMARK);
31039:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool more;
    1:   while (NS_SUCCEEDED((rv = mDBFindURIBookmarks->ExecuteStep(&more))) && more) {
34260:     if (!aResult.AppendElement(
    1:         mDBFindURIBookmarks->AsInt64(kFindBookmarksIndex_ID)))
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
11421:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetBookmarkIdsForURI(nsIURI *aURI, PRUint32 *aCount,
    1:                                    PRInt64 **aBookmarks)
    1: {
29123:   NS_ENSURE_ARG(aURI);
29123:   NS_ENSURE_ARG_POINTER(aCount);
29123:   NS_ENSURE_ARG_POINTER(aBookmarks);
29123: 
    1:   *aCount = 0;
    1:   *aBookmarks = nsnull;
    1:   nsTArray<PRInt64> bookmarks;
    1: 
    1:   // Get the information from the DB as a TArray
34260:   nsresult rv = GetBookmarkIdsForURITArray(aURI, bookmarks);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // Copy the results into a new array for output
    1:   if (bookmarks.Length()) {
 3233:     *aBookmarks = static_cast<PRInt64*>
 3233:                              (nsMemory::Alloc(sizeof(PRInt64) * bookmarks.Length()));
    1:     if (! *aBookmarks)
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     for (PRUint32 i = 0; i < bookmarks.Length(); i ++)
    1:       (*aBookmarks)[i] = bookmarks[i];
    1:   }
    1:   *aCount = bookmarks.Length();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 1297: nsNavBookmarks::GetItemIndex(PRInt64 aItemId, PRInt32 *aIndex)
    1: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
29123:   NS_ENSURE_ARG_POINTER(aIndex);
29123: 
 1297:   mozStorageStatementScoper scope(mDBGetItemIndex);
 1297:   mDBGetItemIndex->BindInt64Parameter(0, aItemId);
    1:   PRBool results;
 1297:   nsresult rv = mDBGetItemIndex->ExecuteStep(&results);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   if (!results) {
    1:     *aIndex = -1;
    1:     return NS_OK;
    1:   }
    1: 
 1297:   *aIndex = mDBGetItemIndex->AsInt32(0);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 1377: nsNavBookmarks::SetItemIndex(PRInt64 aItemId, PRInt32 aNewIndex)
 1377: {
29123:   NS_ENSURE_ARG_MIN(aItemId, 1);
31729:   NS_ENSURE_ARG_MIN(aNewIndex, 0);
29123: 
 1377:   nsresult rv;
 1377:   PRInt32 oldIndex = 0;
 1377:   PRInt64 parent = 0;
33340:   PRUint16 itemType;
 1377: 
 1377:   {
 1377:     mozStorageStatementScoper scopeGet(mDBGetItemProperties);
 1377:     rv = mDBGetItemProperties->BindInt64Parameter(0, aItemId);
 1377:     NS_ENSURE_SUCCESS(rv, rv);
 1377: 
 1377:     PRBool results;
 1377:     rv = mDBGetItemProperties->ExecuteStep(&results);
 1377:     NS_ENSURE_SUCCESS(rv, rv);
 1377:     if (!results)
 1377:       return NS_OK;
 1377: 
 1377:     oldIndex = mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Position);
33340:     itemType = (PRUint16)mDBGetItemProperties->AsInt32(kGetItemPropertiesIndex_Type);
 1377:     parent = mDBGetItemProperties->AsInt64(kGetItemPropertiesIndex_Parent);
 1377:   }
 1377: 
31729:   // Ensure we are not going out of range.
31729:   PRInt32 folderCount;
31729:   rv = FolderCount(parent, &folderCount);
31729:   NS_ENSURE_SUCCESS(rv, rv);
31729:   NS_ENSURE_TRUE(aNewIndex < folderCount, NS_ERROR_INVALID_ARG);
31729: 
 7778:   mozStorageStatementScoper scoper(mDBSetItemIndex);
 7778:   rv = mDBSetItemIndex->BindInt64Parameter(0, aItemId);
 1377:   NS_ENSURE_SUCCESS(rv, rv);
 7778:   rv = mDBSetItemIndex->BindInt32Parameter(1, aNewIndex);
 1377:   NS_ENSURE_SUCCESS(rv, rv);
 7778: 
 7778:   rv = mDBSetItemIndex->Execute();
 1377:   NS_ENSURE_SUCCESS(rv, rv);
 1377: 
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
33340:                       OnItemMoved(aItemId, parent, oldIndex, parent,
35298:                                   aNewIndex, itemType));
 1377: 
 1377:   return NS_OK;
 1377: }
 1377: 
 1377: NS_IMETHODIMP
    1: nsNavBookmarks::SetKeywordForBookmark(PRInt64 aBookmarkId, const nsAString& aKeyword)
    1: {
29123:   NS_ENSURE_ARG_MIN(aBookmarkId, 1);
    1: 
    1:   // Shortcuts are always lowercased internally.
    1:   nsAutoString kwd(aKeyword);
    1:   ToLowerCase(kwd);
    1: 
20874:   mozStorageTransaction transaction(mDBConn, PR_FALSE);
    1:   nsresult rv;
    1:   PRBool results;
 1665:   PRInt64 keywordId = 0;
    1: 
    1:   if (!kwd.IsEmpty()) {
    1:     //  Attempt to find pre-existing keyword record
    1:     nsCOMPtr<mozIStorageStatement> getKeywordStmnt;
20874:     rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
    1:         "SELECT id from moz_keywords WHERE keyword = ?1"),
    1:       getter_AddRefs(getKeywordStmnt));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     rv = getKeywordStmnt->BindStringParameter(0, kwd);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     rv = getKeywordStmnt->ExecuteStep(&results);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (results) {
    1:       rv = getKeywordStmnt->GetInt64(0, &keywordId);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1:     else {
    1:       // If not already in the db, create new keyword record
    1:       nsCOMPtr<mozIStorageStatement> addKeywordStmnt;
20874:       rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
    1:           "INSERT INTO moz_keywords (keyword) VALUES (?1)"),
    1:         getter_AddRefs(addKeywordStmnt));
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:       rv = addKeywordStmnt->BindStringParameter(0, kwd);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:       rv = addKeywordStmnt->Execute();
    1:       NS_ENSURE_SUCCESS(rv, rv);
16751: 
16751:       nsCOMPtr<mozIStorageStatement> idStmt;
20874:       rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
16751:           "SELECT id "
16751:           "FROM moz_keywords "
16751:           "ORDER BY ROWID DESC "
16751:           "LIMIT 1"),
16751:         getter_AddRefs(idStmt));
    1:       NS_ENSURE_SUCCESS(rv, rv);
16751: 
16751:       PRBool hasResult;
16751:       rv = idStmt->ExecuteStep(&hasResult);
16751:       NS_ENSURE_SUCCESS(rv, rv);
16751:       NS_ASSERTION(hasResult, "hasResult is false but the call succeeded?");
16751:       keywordId = idStmt->AsInt64(0);
    1:     }
    1:   }
    1: 
    1:   // Update bookmark record w/ the keyword's id, or null
    1:   nsCOMPtr<mozIStorageStatement> updateKeywordStmnt;
20874:   rv = mDBConn->CreateStatement(NS_LITERAL_CSTRING(
29518:       "UPDATE moz_bookmarks SET keyword_id = ?1, lastModified = ?2 "
29518:       "WHERE id = ?3"),
    1:     getter_AddRefs(updateKeywordStmnt));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = updateKeywordStmnt->BindInt64Parameter(0, keywordId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
29518:   PRTime lastModified = PR_Now();
29518:   rv = updateKeywordStmnt->BindInt64Parameter(1, lastModified);
29518:   NS_ENSURE_SUCCESS(rv, rv);
29518:   rv = updateKeywordStmnt->BindInt64Parameter(2, aBookmarkId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   rv = updateKeywordStmnt->Execute();
    1:   NS_ENSURE_SUCCESS(rv, rv);
 1429: 
29518:   rv = transaction.Commit();
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
 1429:   // Pass the new keyword to OnItemChanged.
30050:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
 1429:                       OnItemChanged(aBookmarkId, NS_LITERAL_CSTRING("keyword"),
33340:                                     PR_FALSE, NS_ConvertUTF16toUTF8(aKeyword),
35298:                                     lastModified, TYPE_BOOKMARK));
 1604: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetKeywordForURI(nsIURI* aURI, nsAString& aKeyword)
    1: {
29123:   NS_ENSURE_ARG(aURI);
    1:   aKeyword.Truncate(0);
    1: 
    1:   mozStorageStatementScoper scoper(mDBGetKeywordForURI);
    1:   nsresult rv = BindStatementURI(mDBGetKeywordForURI, 0, aURI);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool hasMore = PR_FALSE;
    1:   rv = mDBGetKeywordForURI->ExecuteStep(&hasMore);
    1:   if (NS_FAILED(rv) || ! hasMore) {
    1:     aKeyword.SetIsVoid(PR_TRUE);
    1:     return NS_OK; // not found: return void keyword string
    1:   }
    1: 
    1:   // found, get the keyword
    1:   return mDBGetKeywordForURI->GetString(0, aKeyword);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetKeywordForBookmark(PRInt64 aBookmarkId, nsAString& aKeyword)
    1: {
29123:   NS_ENSURE_ARG_MIN(aBookmarkId, 1);
    1:   aKeyword.Truncate(0);
    1: 
    1:   mozStorageStatementScoper scoper(mDBGetKeywordForBookmark);
    1:   nsresult rv = mDBGetKeywordForBookmark->BindInt64Parameter(0, aBookmarkId);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool hasMore = PR_FALSE;
    1:   rv = mDBGetKeywordForBookmark->ExecuteStep(&hasMore);
    1:   if (NS_FAILED(rv) || ! hasMore) {
    1:     aKeyword.SetIsVoid(PR_TRUE);
    1:     return NS_OK; // not found: return void keyword string
    1:   }
    1: 
    1:   // found, get the keyword
    1:   return mDBGetKeywordForBookmark->GetString(0, aKeyword);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::GetURIForKeyword(const nsAString& aKeyword, nsIURI** aURI)
    1: {
29123:   NS_ENSURE_ARG_POINTER(aURI);
    1:   *aURI = nsnull;
    1:   if (aKeyword.IsEmpty())
    1:     return NS_ERROR_INVALID_ARG;
    1: 
    1:   // Shortcuts are always lowercased internally.
    1:   nsAutoString kwd(aKeyword);
    1:   ToLowerCase(kwd);
    1: 
    1:   mozStorageStatementScoper scoper(mDBGetURIForKeyword);
    1:   nsresult rv = mDBGetURIForKeyword->BindStringParameter(0, kwd);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRBool hasMore = PR_FALSE;
    1:   rv = mDBGetURIForKeyword->ExecuteStep(&hasMore);
    1:   if (NS_FAILED(rv) || ! hasMore)
    1:     return NS_OK; // not found: leave URI null
    1: 
    1:   // found, get the URI
    1:   nsCAutoString spec;
    1:   rv = mDBGetURIForKeyword->GetUTF8String(0, spec);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1:   return NS_NewURI(aURI, spec);
    1: }
    1: 
12073: // See RunInBatchMode
 2051: nsresult
    1: nsNavBookmarks::BeginUpdateBatch()
    1: {
    1:   if (mBatchLevel++ == 0) {
20874:     mozIStorageConnection* conn = mDBConn;
    1:     PRBool transactionInProgress = PR_TRUE; // default to no transaction on err
    1:     conn->GetTransactionInProgress(&transactionInProgress);
    1:     mBatchHasTransaction = ! transactionInProgress;
    1:     if (mBatchHasTransaction)
    1:       conn->BeginTransaction();
    1: 
30050:     ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                         OnBeginUpdateBatch());
    1:   }
    1:   return NS_OK;
    1: }
    1: 
 2051: nsresult
    1: nsNavBookmarks::EndUpdateBatch()
    1: {
    1:   if (--mBatchLevel == 0) {
    1:     if (mBatchHasTransaction)
20874:       mDBConn->CommitTransaction();
    1:     mBatchHasTransaction = PR_FALSE;
30050:     ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                         OnEndUpdateBatch());
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 2051: nsNavBookmarks::RunInBatchMode(nsINavHistoryBatchCallback* aCallback,
 2051:                                nsISupports* aUserData) {
29123:   NS_ENSURE_ARG(aCallback);
 2051: 
 2051:   BeginUpdateBatch();
 2051:   nsresult rv = aCallback->RunBatched(aUserData);
 2051:   EndUpdateBatch();
12073: 
12073:   return rv;
 2051: }
 2051: 
 2051: NS_IMETHODIMP
    1: nsNavBookmarks::AddObserver(nsINavBookmarkObserver *aObserver,
    1:                             PRBool aOwnsWeak)
    1: {
29123:   NS_ENSURE_ARG(aObserver);
    1:   return mObservers.AppendWeakElement(aObserver, aOwnsWeak);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::RemoveObserver(nsINavBookmarkObserver *aObserver)
    1: {
    1:   return mObservers.RemoveWeakElement(aObserver);
    1: }
    1: 
    1: // nsNavBookmarks::nsINavHistoryObserver
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::OnBeginUpdateBatch()
    1: {
    1:   // These aren't passed through to bookmark observers currently.
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::OnEndUpdateBatch()
    1: {
    1:   // These aren't passed through to bookmark observers currently.
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::OnVisit(nsIURI *aURI, PRInt64 aVisitID, PRTime aTime,
    1:                         PRInt64 aSessionID, PRInt64 aReferringID,
12328:                         PRUint32 aTransitionType, PRUint32* aAdded)
    1: {
    1:   // If the page is bookmarked, we need to notify observers
    1:   PRBool bookmarked = PR_FALSE;
    1:   IsBookmarked(aURI, &bookmarked);
    1:   if (bookmarked) {
    1:     // query for all bookmarks for that URI, notify for each
    1:     nsTArray<PRInt64> bookmarks;
    1: 
34260:     nsresult rv = GetBookmarkIdsForURITArray(aURI, bookmarks);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (bookmarks.Length()) {
    1:       for (PRUint32 i = 0; i < bookmarks.Length(); i++)
30050:         ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
35298:                             OnItemVisited(bookmarks[i], aVisitID, aTime));
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
27196: nsNavBookmarks::OnBeforeDeleteURI(nsIURI *aURI)
27196: {
27196:   return NS_OK;
27196: }
27196: 
27196: NS_IMETHODIMP
    1: nsNavBookmarks::OnDeleteURI(nsIURI *aURI)
    1: {
    1:   // If the page is bookmarked, we need to notify observers
    1:   PRBool bookmarked = PR_FALSE;
    1:   IsBookmarked(aURI, &bookmarked);
    1:   if (bookmarked) {
    1:     // query for all bookmarks for that URI, notify for each 
    1:     nsTArray<PRInt64> bookmarks;
    1: 
34260:     nsresult rv = GetBookmarkIdsForURITArray(aURI, bookmarks);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     if (bookmarks.Length()) {
    1:       for (PRUint32 i = 0; i < bookmarks.Length(); i ++)
30050:         ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
33340:                             OnItemChanged(bookmarks[i],
33340:                                           NS_LITERAL_CSTRING("cleartime"),
33340:                                           PR_FALSE,
33340:                                           EmptyCString(),
33340:                                           0,
35298:                                           TYPE_BOOKMARK));
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::OnClearHistory()
    1: {
    1:   // TODO(bryner): we should notify on visited-time change for all URIs
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
 4037: nsNavBookmarks::OnTitleChanged(nsIURI* aURI, const nsAString& aPageTitle)
    1: {
    1:   // NOOP. We don't consume page titles from moz_places anymore.
    1:   // Title-change notifications are sent from SetItemTitle.
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::OnPageChanged(nsIURI *aURI, PRUint32 aWhat,
    1:                               const nsAString &aValue)
    1: {
 1905:   nsresult rv;
    1:   if (aWhat == nsINavHistoryObserver::ATTRIBUTE_FAVICON) {
 1905:     // Favicons may be set to either pure URIs or to folder URIs
 1905:     PRBool isPlaceURI;
 1905:     rv = aURI->SchemeIs("place", &isPlaceURI);
 1905:     NS_ENSURE_SUCCESS(rv, rv);
 1905:     if (isPlaceURI) {
 1905:       nsCAutoString spec;
 1905:       rv = aURI->GetSpec(spec);
 1905:       NS_ENSURE_SUCCESS(rv, rv);
 1905: 
35298:       nsNavHistory *history = nsNavHistory::GetHistoryService();
35298:       NS_ENSURE_TRUE(history, NS_ERROR_OUT_OF_MEMORY);
 1905:   
 1905:       nsCOMArray<nsNavHistoryQuery> queries;
 1905:       nsCOMPtr<nsNavHistoryQueryOptions> options;
 1905:       rv = history->QueryStringToQueryArray(spec, &queries, getter_AddRefs(options));
 1905:       NS_ENSURE_SUCCESS(rv, rv);
 1905: 
 1905:       NS_ENSURE_STATE(queries.Count() == 1);
 1905:       NS_ENSURE_STATE(queries[0]->Folders().Length() == 1);
 1905: 
30050:       ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
33340:                           OnItemChanged(queries[0]->Folders()[0],
33340:                                         NS_LITERAL_CSTRING("favicon"),
33340:                                         PR_FALSE,
33340:                                         NS_ConvertUTF16toUTF8(aValue),
33340:                                         0,
33340:                                         TYPE_BOOKMARK));
 1905:     }
 1905:     else {
    1:       // query for all bookmarks for that URI, notify for each 
    1:       nsTArray<PRInt64> bookmarks;
34260:       rv = GetBookmarkIdsForURITArray(aURI, bookmarks);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       if (bookmarks.Length()) {
    1:         for (PRUint32 i = 0; i < bookmarks.Length(); i ++)
30050:           ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers, nsINavBookmarkObserver,
33340:                               OnItemChanged(bookmarks[i],
33340:                                             NS_LITERAL_CSTRING("favicon"),
33340:                                             PR_FALSE,
33340:                                             NS_ConvertUTF16toUTF8(aValue),
33340:                                             0,
33340:                                             TYPE_BOOKMARK));
    1:       }
    1:     }
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsNavBookmarks::OnPageExpired(nsIURI* aURI, PRTime aVisitTime,
    1:                               PRBool aWholeEntry)
    1: {
    1:   // pages that are bookmarks shouldn't expire, so we don't need to handle it
    1:   return NS_OK;
    1: }
 1337: 
 1337: // nsIAnnotationObserver
 1337: 
 1337: NS_IMETHODIMP
 1337: nsNavBookmarks::OnPageAnnotationSet(nsIURI* aPage, const nsACString& aName)
 1337: {
 1337:   return NS_OK;
 1337: }
 1337: 
 1337: NS_IMETHODIMP
 1337: nsNavBookmarks::OnItemAnnotationSet(PRInt64 aItemId, const nsACString& aName)
 1337: {
33340:   // GetItemType also ensures that aItemId points to a valid item.
33340:   PRUint16 itemType;
33340:   nsresult rv = GetItemType(aItemId, &itemType);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
33340:   PRTime lastModified = PR_Now();
33340:   rv = SetItemDateInternal(mDBSetItemLastModified, aItemId, lastModified);
33340:   NS_ENSURE_SUCCESS(rv, rv);
33340: 
33340:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
33340:                       nsINavBookmarkObserver,
33340:                       OnItemChanged(aItemId, aName, PR_TRUE, EmptyCString(),
33340:                                     lastModified, itemType));
 1604: 
 1337:   return NS_OK;
 1337: }
 1337: 
 1337: 
 1337: NS_IMETHODIMP
 1337: nsNavBookmarks::OnPageAnnotationRemoved(nsIURI* aPage, const nsACString& aName)
 1337: {
 1337:   return NS_OK;
 1337: }
 1337: 
 1337: NS_IMETHODIMP
 1337: nsNavBookmarks::OnItemAnnotationRemoved(PRInt64 aItemId, const nsACString& aName)
 1337: {
33340:   // GetItemType also ensures that aItemId points to a valid item.
33340:   PRUint16 itemType;
33340:   nsresult rv = GetItemType(aItemId, &itemType);
 1604:   NS_ENSURE_SUCCESS(rv, rv);
 1604: 
33340:   PRTime lastModified = PR_Now();
33340:   rv = SetItemDateInternal(mDBSetItemLastModified, aItemId, lastModified);
33340:   NS_ENSURE_SUCCESS(rv, rv);
33340: 
33340:   ENUMERATE_OBSERVERS(mCanNotify, mCacheObservers, mObservers,
33340:                       nsINavBookmarkObserver,
33340:                       OnItemChanged(aItemId, aName, PR_TRUE, EmptyCString(),
33340:                                     lastModified, itemType));
 1604: 
 1337:   return NS_OK;
 1337: }
 2780: 
 2780: PRBool
 2780: nsNavBookmarks::ItemExists(PRInt64 aItemId) {
 2780:   mozStorageStatementScoper scope(mDBGetItemProperties);
 2780:   nsresult rv = mDBGetItemProperties->BindInt64Parameter(0, aItemId);
 2780:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
 2780: 
 2780:   PRBool results;
 2780:   rv = mDBGetItemProperties->ExecuteStep(&results);
 2780:   NS_ENSURE_SUCCESS(rv, PR_FALSE);
 2780: 
 2780:   if (!results)
 2780:     return PR_FALSE;
 2780: 
 2780:   return PR_TRUE;
 2780: }
