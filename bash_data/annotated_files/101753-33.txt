 81005: 
 81005: /*
 81005:  * Copyright 2006 The Android Open Source Project
 81005:  *
 81005:  * Use of this source code is governed by a BSD-style license that can be
 81005:  * found in the LICENSE file.
 81005:  */
 81005: 
 81005: 
 81005: #include "SkPaint.h"
 81005: #include "SkColorFilter.h"
 81005: #include "SkFontHost.h"
 87682: #include "SkImageFilter.h"
 81005: #include "SkMaskFilter.h"
 81005: #include "SkPathEffect.h"
 81005: #include "SkRasterizer.h"
 81005: #include "SkShader.h"
 81005: #include "SkScalar.h"
 81005: #include "SkScalerContext.h"
 81005: #include "SkStroke.h"
 81005: #include "SkTextFormatParams.h"
 81005: #include "SkTypeface.h"
 81005: #include "SkXfermode.h"
 81005: #include "SkAutoKern.h"
 99650: #include "SkGlyphCache.h"
 99650: #include "SkPaintDefaults.h"
 99650: #include "SkOrderedWriteBuffer.h"
 81005: 
 81005: // define this to get a printf for out-of-range parameter in setters
 81005: // e.g. setTextSize(-1)
 81005: //#define SK_REPORT_API_RANGE_CHECK
 81005: 
 87682: #ifdef SK_BUILD_FOR_ANDROID
 81005: #define GEN_ID_INC                  fGenerationID++
 81005: #define GEN_ID_INC_EVAL(expression) if (expression) { fGenerationID++; }
 81005: #else
 81005: #define GEN_ID_INC
 81005: #define GEN_ID_INC_EVAL(expression)
 81005: #endif
 81005: 
 81005: SkPaint::SkPaint() {
 81005:     // since we may have padding, we zero everything so that our memcmp() call
 81005:     // in operator== will work correctly.
 81005:     // with this, we can skip 0 and null individual initializations
 81005:     sk_bzero(this, sizeof(*this));
 81005: 
 81005: #if 0   // not needed with the bzero call above
 81005:     fTypeface   = NULL;
 81005:     fTextSkewX  = 0;
 81005:     fPathEffect  = NULL;
 81005:     fShader      = NULL;
 81005:     fXfermode    = NULL;
 81005:     fMaskFilter  = NULL;
 81005:     fColorFilter = NULL;
 81005:     fRasterizer  = NULL;
 81005:     fLooper      = NULL;
 87682:     fImageFilter = NULL;
 81005:     fWidth      = 0;
 81005: #endif
 81005: 
 99650:     fTextSize   = SkPaintDefaults_TextSize;
 81005:     fTextScaleX = SK_Scalar1;
 81005:     fColor      = SK_ColorBLACK;
 99650:     fMiterLimit = SkPaintDefaults_MiterLimit;
 99650:     fFlags      = SkPaintDefaults_Flags;
 81005:     fCapType    = kDefault_Cap;
 81005:     fJoinType   = kDefault_Join;
 81005:     fTextAlign  = kLeft_Align;
 81005:     fStyle      = kFill_Style;
 81005:     fTextEncoding = kUTF8_TextEncoding;
 99650:     fHinting    = SkPaintDefaults_Hinting;
 87682: #ifdef SK_BUILD_FOR_ANDROID
 81005:     fGenerationID = 0;
 81005: #endif
 81005: }
 81005: 
 81005: SkPaint::SkPaint(const SkPaint& src) {
 81005:     memcpy(this, &src, sizeof(src));
 81005: 
 81005:     SkSafeRef(fTypeface);
 81005:     SkSafeRef(fPathEffect);
 81005:     SkSafeRef(fShader);
 81005:     SkSafeRef(fXfermode);
 81005:     SkSafeRef(fMaskFilter);
 81005:     SkSafeRef(fColorFilter);
 81005:     SkSafeRef(fRasterizer);
 81005:     SkSafeRef(fLooper);
 87682:     SkSafeRef(fImageFilter);
 81005: }
 81005: 
 81005: SkPaint::~SkPaint() {
 81005:     SkSafeUnref(fTypeface);
 81005:     SkSafeUnref(fPathEffect);
 81005:     SkSafeUnref(fShader);
 81005:     SkSafeUnref(fXfermode);
 81005:     SkSafeUnref(fMaskFilter);
 81005:     SkSafeUnref(fColorFilter);
 81005:     SkSafeUnref(fRasterizer);
 81005:     SkSafeUnref(fLooper);
 87682:     SkSafeUnref(fImageFilter);
 81005: }
 81005: 
 81005: SkPaint& SkPaint::operator=(const SkPaint& src) {
 81005:     SkASSERT(&src);
 81005: 
 81005:     SkSafeRef(src.fTypeface);
 81005:     SkSafeRef(src.fPathEffect);
 81005:     SkSafeRef(src.fShader);
 81005:     SkSafeRef(src.fXfermode);
 81005:     SkSafeRef(src.fMaskFilter);
 81005:     SkSafeRef(src.fColorFilter);
 81005:     SkSafeRef(src.fRasterizer);
 81005:     SkSafeRef(src.fLooper);
 87682:     SkSafeRef(src.fImageFilter);
 81005: 
 81005:     SkSafeUnref(fTypeface);
 81005:     SkSafeUnref(fPathEffect);
 81005:     SkSafeUnref(fShader);
 81005:     SkSafeUnref(fXfermode);
 81005:     SkSafeUnref(fMaskFilter);
 81005:     SkSafeUnref(fColorFilter);
 81005:     SkSafeUnref(fRasterizer);
 81005:     SkSafeUnref(fLooper);
 87682:     SkSafeUnref(fImageFilter);
 81005: 
 87682: #ifdef SK_BUILD_FOR_ANDROID
 81005:     uint32_t oldGenerationID = fGenerationID;
 81005: #endif
 81005:     memcpy(this, &src, sizeof(src));
 87682: #ifdef SK_BUILD_FOR_ANDROID
 81005:     fGenerationID = oldGenerationID + 1;
 81005: #endif
 81005: 
 81005:     return *this;
 81005: }
 81005: 
 81005: bool operator==(const SkPaint& a, const SkPaint& b) {
 87682: #ifdef SK_BUILD_FOR_ANDROID
 87682:     //assumes that fGenerationID is the last field in the struct
 87682:     return !memcmp(&a, &b, SK_OFFSETOF(SkPaint, fGenerationID));
 87682: #else
 81005:     return !memcmp(&a, &b, sizeof(a));
 87682: #endif
 81005: }
 81005: 
 81005: void SkPaint::reset() {
 81005:     SkPaint init;
 81005: 
 87682: #ifdef SK_BUILD_FOR_ANDROID
 81005:     uint32_t oldGenerationID = fGenerationID;
 81005: #endif
 81005:     *this = init;
 87682: #ifdef SK_BUILD_FOR_ANDROID
 81005:     fGenerationID = oldGenerationID + 1;
 81005: #endif
 81005: }
 81005: 
 87682: #ifdef SK_BUILD_FOR_ANDROID
 81005: uint32_t SkPaint::getGenerationID() const {
 81005:     return fGenerationID;
 81005: }
 81005: #endif
 81005: 
 99650: #ifdef SK_BUILD_FOR_ANDROID
 99650: unsigned SkPaint::getBaseGlyphCount(SkUnichar text) const {
 99650:     SkAutoGlyphCache autoCache(*this, NULL);
 99650:     SkGlyphCache* cache = autoCache.getCache();
 99650:     return cache->getBaseGlyphCount(text);
 99650: }
 99650: #endif
 99650: 
 81005: void SkPaint::setHinting(Hinting hintingLevel) {
 81005:     GEN_ID_INC_EVAL((unsigned) hintingLevel != fHinting);
 81005:     fHinting = hintingLevel;
 81005: }
 81005: 
 81005: void SkPaint::setFlags(uint32_t flags) {
 81005:     GEN_ID_INC_EVAL(fFlags != flags);
 81005:     fFlags = flags;
 81005: }
 81005: 
 81005: void SkPaint::setAntiAlias(bool doAA) {
 81005:     GEN_ID_INC_EVAL(doAA != isAntiAlias());
 81005:     this->setFlags(SkSetClearMask(fFlags, doAA, kAntiAlias_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setDither(bool doDither) {
 81005:     GEN_ID_INC_EVAL(doDither != isDither());
 81005:     this->setFlags(SkSetClearMask(fFlags, doDither, kDither_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setSubpixelText(bool doSubpixel) {
 81005:     GEN_ID_INC_EVAL(doSubpixel != isSubpixelText());
 81005:     this->setFlags(SkSetClearMask(fFlags, doSubpixel, kSubpixelText_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setLCDRenderText(bool doLCDRender) {
 81005:     GEN_ID_INC_EVAL(doLCDRender != isLCDRenderText());
 81005:     this->setFlags(SkSetClearMask(fFlags, doLCDRender, kLCDRenderText_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setEmbeddedBitmapText(bool doEmbeddedBitmapText) {
 81005:     GEN_ID_INC_EVAL(doEmbeddedBitmapText != isEmbeddedBitmapText());
 81005:     this->setFlags(SkSetClearMask(fFlags, doEmbeddedBitmapText, kEmbeddedBitmapText_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setAutohinted(bool useAutohinter) {
 81005:     GEN_ID_INC_EVAL(useAutohinter != isAutohinted());
 81005:     this->setFlags(SkSetClearMask(fFlags, useAutohinter, kAutoHinting_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setLinearText(bool doLinearText) {
 81005:     GEN_ID_INC_EVAL(doLinearText != isLinearText());
 81005:     this->setFlags(SkSetClearMask(fFlags, doLinearText, kLinearText_Flag));
 81005: }
 81005: 
 87682: void SkPaint::setVerticalText(bool doVertical) {
 87682:     GEN_ID_INC_EVAL(doVertical != isVerticalText());
 87682:     this->setFlags(SkSetClearMask(fFlags, doVertical, kVerticalText_Flag));
 87682: }
 87682: 
 81005: void SkPaint::setUnderlineText(bool doUnderline) {
 81005:     GEN_ID_INC_EVAL(doUnderline != isUnderlineText());
 81005:     this->setFlags(SkSetClearMask(fFlags, doUnderline, kUnderlineText_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setStrikeThruText(bool doStrikeThru) {
 81005:     GEN_ID_INC_EVAL(doStrikeThru != isStrikeThruText());
 81005:     this->setFlags(SkSetClearMask(fFlags, doStrikeThru, kStrikeThruText_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setFakeBoldText(bool doFakeBold) {
 81005:     GEN_ID_INC_EVAL(doFakeBold != isFakeBoldText());
 81005:     this->setFlags(SkSetClearMask(fFlags, doFakeBold, kFakeBoldText_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setDevKernText(bool doDevKern) {
 81005:     GEN_ID_INC_EVAL(doDevKern != isDevKernText());
 81005:     this->setFlags(SkSetClearMask(fFlags, doDevKern, kDevKernText_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setFilterBitmap(bool doFilter) {
 81005:     GEN_ID_INC_EVAL(doFilter != isFilterBitmap());
 81005:     this->setFlags(SkSetClearMask(fFlags, doFilter, kFilterBitmap_Flag));
 81005: }
 81005: 
 81005: void SkPaint::setStyle(Style style) {
 81005:     if ((unsigned)style < kStyleCount) {
 81005:         GEN_ID_INC_EVAL((unsigned)style != fStyle);
 81005:         fStyle = style;
 81005:     } else {
 81005: #ifdef SK_REPORT_API_RANGE_CHECK
 81005:         SkDebugf("SkPaint::setStyle(%d) out of range\n", style);
 81005: #endif
 81005:     }
 81005: }
 81005: 
 81005: void SkPaint::setColor(SkColor color) {
 81005:     GEN_ID_INC_EVAL(color != fColor);
 81005:     fColor = color;
 81005: }
 81005: 
 81005: void SkPaint::setAlpha(U8CPU a) {
 81005:     this->setColor(SkColorSetARGB(a, SkColorGetR(fColor),
 81005:                                   SkColorGetG(fColor), SkColorGetB(fColor)));
 81005: }
 81005: 
 81005: void SkPaint::setARGB(U8CPU a, U8CPU r, U8CPU g, U8CPU b) {
 81005:     this->setColor(SkColorSetARGB(a, r, g, b));
 81005: }
 81005: 
 81005: void SkPaint::setStrokeWidth(SkScalar width) {
 81005:     if (width >= 0) {
 81005:         GEN_ID_INC_EVAL(width != fWidth);
 81005:         fWidth = width;
 81005:     } else {
 81005: #ifdef SK_REPORT_API_RANGE_CHECK
 81005:         SkDebugf("SkPaint::setStrokeWidth() called with negative value\n");
 81005: #endif
 81005:     }
 81005: }
 81005: 
 81005: void SkPaint::setStrokeMiter(SkScalar limit) {
 81005:     if (limit >= 0) {
 81005:         GEN_ID_INC_EVAL(limit != fMiterLimit);
 81005:         fMiterLimit = limit;
 81005:     } else {
 81005: #ifdef SK_REPORT_API_RANGE_CHECK
 81005:         SkDebugf("SkPaint::setStrokeMiter() called with negative value\n");
 81005: #endif
 81005:     }
 81005: }
 81005: 
 81005: void SkPaint::setStrokeCap(Cap ct) {
 81005:     if ((unsigned)ct < kCapCount) {
 81005:         GEN_ID_INC_EVAL((unsigned)ct != fCapType);
 81005:         fCapType = SkToU8(ct);
 81005:     } else {
 81005: #ifdef SK_REPORT_API_RANGE_CHECK
 81005:         SkDebugf("SkPaint::setStrokeCap(%d) out of range\n", ct);
 81005: #endif
 81005:     }
 81005: }
 81005: 
 81005: void SkPaint::setStrokeJoin(Join jt) {
 81005:     if ((unsigned)jt < kJoinCount) {
 81005:         GEN_ID_INC_EVAL((unsigned)jt != fJoinType);
 81005:         fJoinType = SkToU8(jt);
 81005:     } else {
 81005: #ifdef SK_REPORT_API_RANGE_CHECK
 81005:         SkDebugf("SkPaint::setStrokeJoin(%d) out of range\n", jt);
 81005: #endif
 81005:     }
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: void SkPaint::setTextAlign(Align align) {
 81005:     if ((unsigned)align < kAlignCount) {
 81005:         GEN_ID_INC_EVAL((unsigned)align != fTextAlign);
 81005:         fTextAlign = SkToU8(align);
 81005:     } else {
 81005: #ifdef SK_REPORT_API_RANGE_CHECK
 81005:         SkDebugf("SkPaint::setTextAlign(%d) out of range\n", align);
 81005: #endif
 81005:     }
 81005: }
 81005: 
 81005: void SkPaint::setTextSize(SkScalar ts) {
 87682:     if (ts >= 0) {
 81005:         GEN_ID_INC_EVAL(ts != fTextSize);
 81005:         fTextSize = ts;
 81005:     } else {
 81005: #ifdef SK_REPORT_API_RANGE_CHECK
 81005:         SkDebugf("SkPaint::setTextSize() called with negative value\n");
 81005: #endif
 81005:     }
 81005: }
 81005: 
 81005: void SkPaint::setTextScaleX(SkScalar scaleX) {
 81005:     GEN_ID_INC_EVAL(scaleX != fTextScaleX);
 81005:     fTextScaleX = scaleX;
 81005: }
 81005: 
 81005: void SkPaint::setTextSkewX(SkScalar skewX) {
 81005:     GEN_ID_INC_EVAL(skewX != fTextSkewX);
 81005:     fTextSkewX = skewX;
 81005: }
 81005: 
 81005: void SkPaint::setTextEncoding(TextEncoding encoding) {
 81005:     if ((unsigned)encoding <= kGlyphID_TextEncoding) {
 81005:         GEN_ID_INC_EVAL((unsigned)encoding != fTextEncoding);
 81005:         fTextEncoding = encoding;
 81005:     } else {
 81005: #ifdef SK_REPORT_API_RANGE_CHECK
 81005:         SkDebugf("SkPaint::setTextEncoding(%d) out of range\n", encoding);
 81005: #endif
 81005:     }
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: SkTypeface* SkPaint::setTypeface(SkTypeface* font) {
 81005:     SkRefCnt_SafeAssign(fTypeface, font);
 81005:     GEN_ID_INC;
 81005:     return font;
 81005: }
 81005: 
 81005: SkRasterizer* SkPaint::setRasterizer(SkRasterizer* r) {
 81005:     SkRefCnt_SafeAssign(fRasterizer, r);
 81005:     GEN_ID_INC;
 81005:     return r;
 81005: }
 81005: 
 81005: SkDrawLooper* SkPaint::setLooper(SkDrawLooper* looper) {
 81005:     SkRefCnt_SafeAssign(fLooper, looper);
 81005:     GEN_ID_INC;
 81005:     return looper;
 81005: }
 81005: 
 87682: SkImageFilter* SkPaint::setImageFilter(SkImageFilter* imageFilter) {
 87682:     SkRefCnt_SafeAssign(fImageFilter, imageFilter);
 87682:     GEN_ID_INC;
 87682:     return imageFilter;
 87682: }
 87682: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: #include "SkGlyphCache.h"
 81005: #include "SkUtils.h"
 81005: 
 81005: static void DetachDescProc(const SkDescriptor* desc, void* context) {
 81005:     *((SkGlyphCache**)context) = SkGlyphCache::DetachCache(desc);
 81005: }
 81005: 
 87682: #ifdef SK_BUILD_FOR_ANDROID
 81005: const SkGlyph& SkPaint::getUnicharMetrics(SkUnichar text) {
 81005:     SkGlyphCache* cache;
 81005:     descriptorProc(NULL, DetachDescProc, &cache, true);
 81005: 
 81005:     const SkGlyph& glyph = cache->getUnicharMetrics(text);
 81005: 
 81005:     SkGlyphCache::AttachCache(cache);
 81005:     return glyph;
 81005: }
 81005: 
 99650: const SkGlyph& SkPaint::getGlyphMetrics(uint16_t glyphId) {
 99650:     SkGlyphCache* cache;
 99650:     descriptorProc(NULL, DetachDescProc, &cache, true);
 99650: 
 99650:     const SkGlyph& glyph = cache->getGlyphIDMetrics(glyphId);
 99650: 
 99650:     SkGlyphCache::AttachCache(cache);
 99650:     return glyph;
 99650: }
 99650: 
 81005: const void* SkPaint::findImage(const SkGlyph& glyph) {
 81005:     // See ::detachCache()
 81005:     SkGlyphCache* cache;
 81005:     descriptorProc(NULL, DetachDescProc, &cache, true);
 81005: 
 81005:     const void* image = cache->findImage(glyph);
 81005: 
 81005:     SkGlyphCache::AttachCache(cache);
 81005:     return image;
 81005: }
 81005: #endif
 81005: 
 81005: int SkPaint::textToGlyphs(const void* textData, size_t byteLength,
 81005:                           uint16_t glyphs[]) const {
 81005:     if (byteLength == 0) {
 81005:         return 0;
 81005:     }
 81005: 
 81005:     SkASSERT(textData != NULL);
 81005: 
 81005:     if (NULL == glyphs) {
 81005:         switch (this->getTextEncoding()) {
 81005:         case kUTF8_TextEncoding:
 81005:             return SkUTF8_CountUnichars((const char*)textData, byteLength);
 81005:         case kUTF16_TextEncoding:
 81005:             return SkUTF16_CountUnichars((const uint16_t*)textData,
 81005:                                          byteLength >> 1);
 99650:         case kUTF32_TextEncoding:
 99650:             return byteLength >> 2;
 81005:         case kGlyphID_TextEncoding:
 81005:             return byteLength >> 1;
 81005:         default:
 87682:             SkDEBUGFAIL("unknown text encoding");
 81005:         }
 81005:         return 0;
 81005:     }
 81005: 
 81005:     // if we get here, we have a valid glyphs[] array, so time to fill it in
 81005: 
 81005:     // handle this encoding before the setup for the glyphcache
 81005:     if (this->getTextEncoding() == kGlyphID_TextEncoding) {
 81005:         // we want to ignore the low bit of byteLength
 81005:         memcpy(glyphs, textData, byteLength >> 1 << 1);
 81005:         return byteLength >> 1;
 81005:     }
 81005: 
 81005:     SkAutoGlyphCache autoCache(*this, NULL);
 81005:     SkGlyphCache*    cache = autoCache.getCache();
 81005: 
 81005:     const char* text = (const char*)textData;
 81005:     const char* stop = text + byteLength;
 81005:     uint16_t*   gptr = glyphs;
 81005: 
 81005:     switch (this->getTextEncoding()) {
 81005:         case SkPaint::kUTF8_TextEncoding:
 81005:             while (text < stop) {
 81005:                 *gptr++ = cache->unicharToGlyph(SkUTF8_NextUnichar(&text));
 81005:             }
 81005:             break;
 81005:         case SkPaint::kUTF16_TextEncoding: {
 81005:             const uint16_t* text16 = (const uint16_t*)text;
 81005:             const uint16_t* stop16 = (const uint16_t*)stop;
 81005:             while (text16 < stop16) {
 81005:                 *gptr++ = cache->unicharToGlyph(SkUTF16_NextUnichar(&text16));
 81005:             }
 81005:             break;
 81005:         }
 99650:         case kUTF32_TextEncoding: {
 99650:             const int32_t* text32 = (const int32_t*)text;
 99650:             const int32_t* stop32 = (const int32_t*)stop;
 99650:             while (text32 < stop32) {
 99650:                 *gptr++ = cache->unicharToGlyph(*text32++);
 99650:             }
 99650:             break;
 99650:         }
 81005:         default:
 87682:             SkDEBUGFAIL("unknown text encoding");
 81005:     }
 81005:     return gptr - glyphs;
 81005: }
 81005: 
 81005: bool SkPaint::containsText(const void* textData, size_t byteLength) const {
 81005:     if (0 == byteLength) {
 81005:         return true;
 81005:     }
 81005: 
 81005:     SkASSERT(textData != NULL);
 81005: 
 81005:     // handle this encoding before the setup for the glyphcache
 81005:     if (this->getTextEncoding() == kGlyphID_TextEncoding) {
 81005:         const uint16_t* glyphID = static_cast<const uint16_t*>(textData);
 81005:         size_t count = byteLength >> 1;
 81005:         for (size_t i = 0; i < count; i++) {
 81005:             if (0 == glyphID[i]) {
 81005:                 return false;
 81005:             }
 81005:         }
 81005:         return true;
 81005:     }
 81005: 
 81005:     SkAutoGlyphCache autoCache(*this, NULL);
 81005:     SkGlyphCache*    cache = autoCache.getCache();
 81005: 
 81005:     switch (this->getTextEncoding()) {
 81005:         case SkPaint::kUTF8_TextEncoding: {
 81005:             const char* text = static_cast<const char*>(textData);
 81005:             const char* stop = text + byteLength;
 81005:             while (text < stop) {
 81005:                 if (0 == cache->unicharToGlyph(SkUTF8_NextUnichar(&text))) {
 81005:                     return false;
 81005:                 }
 81005:             }
 81005:             break;
 81005:         }
 81005:         case SkPaint::kUTF16_TextEncoding: {
 81005:             const uint16_t* text = static_cast<const uint16_t*>(textData);
 81005:             const uint16_t* stop = text + (byteLength >> 1);
 81005:             while (text < stop) {
 81005:                 if (0 == cache->unicharToGlyph(SkUTF16_NextUnichar(&text))) {
 81005:                     return false;
 81005:                 }
 81005:             }
 81005:             break;
 81005:         }
 99650:         case SkPaint::kUTF32_TextEncoding: {
 99650:             const int32_t* text = static_cast<const int32_t*>(textData);
 99650:             const int32_t* stop = text + (byteLength >> 2);
 99650:             while (text < stop) {
 99650:                 if (0 == cache->unicharToGlyph(*text++)) {
 99650:                     return false;
 99650:                 }
 99650:             }
 99650:             break;
 99650:         }
 81005:         default:
 87682:             SkDEBUGFAIL("unknown text encoding");
 81005:             return false;
 81005:     }
 81005:     return true;
 81005: }
 81005: 
 81005: void SkPaint::glyphsToUnichars(const uint16_t glyphs[], int count,
 81005:                                SkUnichar textData[]) const {
 81005:     if (count <= 0) {
 81005:         return;
 81005:     }
 81005: 
 81005:     SkASSERT(glyphs != NULL);
 81005:     SkASSERT(textData != NULL);
 81005: 
 81005:     SkAutoGlyphCache autoCache(*this, NULL);
 81005:     SkGlyphCache*    cache = autoCache.getCache();
 81005: 
 81005:     for (int index = 0; index < count; index++) {
 81005:         textData[index] = cache->glyphToUnichar(glyphs[index]);
 81005:     }
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: static const SkGlyph& sk_getMetrics_utf8_next(SkGlyphCache* cache,
 81005:                                               const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     return cache->getUnicharMetrics(SkUTF8_NextUnichar(text));
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getMetrics_utf8_prev(SkGlyphCache* cache,
 81005:                                               const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     return cache->getUnicharMetrics(SkUTF8_PrevUnichar(text));
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getMetrics_utf16_next(SkGlyphCache* cache,
 81005:                                                const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005:     
 81005:     return cache->getUnicharMetrics(SkUTF16_NextUnichar((const uint16_t**)text));
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getMetrics_utf16_prev(SkGlyphCache* cache,
 81005:                                                const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005:     
 81005:     return cache->getUnicharMetrics(SkUTF16_PrevUnichar((const uint16_t**)text));
 81005: }
 81005: 
 99650: static const SkGlyph& sk_getMetrics_utf32_next(SkGlyphCache* cache,
 99650:                                                const char** text) {
 99650:     SkASSERT(cache != NULL);
 99650:     SkASSERT(text != NULL);
 99650: 
 99650:     const int32_t* ptr = *(const int32_t**)text;
 99650:     SkUnichar uni = *ptr++;
 99650:     *text = (const char*)ptr;
 99650:     return cache->getUnicharMetrics(uni);
 99650: }
 99650: 
 99650: static const SkGlyph& sk_getMetrics_utf32_prev(SkGlyphCache* cache,
 99650:                                                const char** text) {
 99650:     SkASSERT(cache != NULL);
 99650:     SkASSERT(text != NULL);
 99650:     
 99650:     const int32_t* ptr = *(const int32_t**)text;
 99650:     SkUnichar uni = *--ptr;
 99650:     *text = (const char*)ptr;
 99650:     return cache->getUnicharMetrics(uni);
 99650: }
 99650: 
 81005: static const SkGlyph& sk_getMetrics_glyph_next(SkGlyphCache* cache,
 81005:                                                const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     const uint16_t* ptr = *(const uint16_t**)text;
 81005:     unsigned glyphID = *ptr;
 81005:     ptr += 1;
 81005:     *text = (const char*)ptr;
 81005:     return cache->getGlyphIDMetrics(glyphID);
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getMetrics_glyph_prev(SkGlyphCache* cache,
 81005:                                                const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     const uint16_t* ptr = *(const uint16_t**)text;
 81005:     ptr -= 1;
 81005:     unsigned glyphID = *ptr;
 81005:     *text = (const char*)ptr;
 81005:     return cache->getGlyphIDMetrics(glyphID);
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getAdvance_utf8_next(SkGlyphCache* cache,
 81005:                                               const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     return cache->getUnicharAdvance(SkUTF8_NextUnichar(text));
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getAdvance_utf8_prev(SkGlyphCache* cache,
 81005:                                               const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     return cache->getUnicharAdvance(SkUTF8_PrevUnichar(text));
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getAdvance_utf16_next(SkGlyphCache* cache,
 81005:                                                const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     return cache->getUnicharAdvance(SkUTF16_NextUnichar((const uint16_t**)text));
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getAdvance_utf16_prev(SkGlyphCache* cache,
 81005:                                                const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     return cache->getUnicharAdvance(SkUTF16_PrevUnichar((const uint16_t**)text));
 81005: }
 81005: 
 99650: static const SkGlyph& sk_getAdvance_utf32_next(SkGlyphCache* cache,
 99650:                                                const char** text) {
 99650:     SkASSERT(cache != NULL);
 99650:     SkASSERT(text != NULL);
 99650:     
 99650:     const int32_t* ptr = *(const int32_t**)text;
 99650:     SkUnichar uni = *ptr++;
 99650:     *text = (const char*)ptr;
 99650:     return cache->getUnicharAdvance(uni);
 99650: }
 99650: 
 99650: static const SkGlyph& sk_getAdvance_utf32_prev(SkGlyphCache* cache,
 99650:                                                const char** text) {
 99650:     SkASSERT(cache != NULL);
 99650:     SkASSERT(text != NULL);
 99650:     
 99650:     const int32_t* ptr = *(const int32_t**)text;
 99650:     SkUnichar uni = *--ptr;
 99650:     *text = (const char*)ptr;
 99650:     return cache->getUnicharAdvance(uni);
 99650: }
 99650: 
 81005: static const SkGlyph& sk_getAdvance_glyph_next(SkGlyphCache* cache,
 81005:                                                const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     const uint16_t* ptr = *(const uint16_t**)text;
 81005:     unsigned glyphID = *ptr;
 81005:     ptr += 1;
 81005:     *text = (const char*)ptr;
 81005:     return cache->getGlyphIDAdvance(glyphID);
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getAdvance_glyph_prev(SkGlyphCache* cache,
 81005:                                                const char** text) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     const uint16_t* ptr = *(const uint16_t**)text;
 81005:     ptr -= 1;
 81005:     unsigned glyphID = *ptr;
 81005:     *text = (const char*)ptr;
 81005:     return cache->getGlyphIDAdvance(glyphID);
 81005: }
 81005: 
 81005: SkMeasureCacheProc SkPaint::getMeasureCacheProc(TextBufferDirection tbd,
 81005:                                                 bool needFullMetrics) const {
 81005:     static const SkMeasureCacheProc gMeasureCacheProcs[] = {
 81005:         sk_getMetrics_utf8_next,
 81005:         sk_getMetrics_utf16_next,
 99650:         sk_getMetrics_utf32_next,
 81005:         sk_getMetrics_glyph_next,
 81005: 
 81005:         sk_getMetrics_utf8_prev,
 81005:         sk_getMetrics_utf16_prev,
 99650:         sk_getMetrics_utf32_prev,
 81005:         sk_getMetrics_glyph_prev,
 81005: 
 81005:         sk_getAdvance_utf8_next,
 81005:         sk_getAdvance_utf16_next,
 99650:         sk_getAdvance_utf32_next,
 81005:         sk_getAdvance_glyph_next,
 81005: 
 81005:         sk_getAdvance_utf8_prev,
 81005:         sk_getAdvance_utf16_prev,
 99650:         sk_getAdvance_utf32_prev,
 81005:         sk_getAdvance_glyph_prev
 81005:     };
 81005: 
 81005:     unsigned index = this->getTextEncoding();
 81005: 
 81005:     if (kBackward_TextBufferDirection == tbd) {
 99650:         index += 4;
 81005:     }
 81005:     if (!needFullMetrics && !this->isDevKernText()) {
 99650:         index += 8;
 81005:     }
 81005: 
 81005:     SkASSERT(index < SK_ARRAY_COUNT(gMeasureCacheProcs));
 81005:     return gMeasureCacheProcs[index];
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: static const SkGlyph& sk_getMetrics_utf8_00(SkGlyphCache* cache,
 81005:                                         const char** text, SkFixed, SkFixed) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     return cache->getUnicharMetrics(SkUTF8_NextUnichar(text));
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getMetrics_utf8_xy(SkGlyphCache* cache,
 81005:                                     const char** text, SkFixed x, SkFixed y) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     return cache->getUnicharMetrics(SkUTF8_NextUnichar(text), x, y);
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getMetrics_utf16_00(SkGlyphCache* cache,
 81005:                                         const char** text, SkFixed, SkFixed) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     return cache->getUnicharMetrics(SkUTF16_NextUnichar((const uint16_t**)text));
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getMetrics_utf16_xy(SkGlyphCache* cache,
 81005:                                      const char** text, SkFixed x, SkFixed y) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     return cache->getUnicharMetrics(SkUTF16_NextUnichar((const uint16_t**)text),
 81005:                                     x, y);
 81005: }
 81005: 
 99650: static const SkGlyph& sk_getMetrics_utf32_00(SkGlyphCache* cache,
 99650:                                     const char** text, SkFixed, SkFixed) {
 99650:     SkASSERT(cache != NULL);
 99650:     SkASSERT(text != NULL);
 99650:     
 99650:     const int32_t* ptr = *(const int32_t**)text;
 99650:     SkUnichar uni = *ptr++;
 99650:     *text = (const char*)ptr;
 99650:     return cache->getUnicharMetrics(uni);
 99650: }
 99650: 
 99650: static const SkGlyph& sk_getMetrics_utf32_xy(SkGlyphCache* cache,
 99650:                                     const char** text, SkFixed x, SkFixed y) {
 99650:     SkASSERT(cache != NULL);
 99650:     SkASSERT(text != NULL);
 99650:     
 99650:     const int32_t* ptr = *(const int32_t**)text;
 99650:     SkUnichar uni = *--ptr;
 99650:     *text = (const char*)ptr;
 99650:     return cache->getUnicharMetrics(uni);
 99650: }
 99650: 
 81005: static const SkGlyph& sk_getMetrics_glyph_00(SkGlyphCache* cache,
 81005:                                          const char** text, SkFixed, SkFixed) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     const uint16_t* ptr = *(const uint16_t**)text;
 81005:     unsigned glyphID = *ptr;
 81005:     ptr += 1;
 81005:     *text = (const char*)ptr;
 81005:     return cache->getGlyphIDMetrics(glyphID);
 81005: }
 81005: 
 81005: static const SkGlyph& sk_getMetrics_glyph_xy(SkGlyphCache* cache,
 81005:                                      const char** text, SkFixed x, SkFixed y) {
 81005:     SkASSERT(cache != NULL);
 81005:     SkASSERT(text != NULL);
 81005: 
 81005:     const uint16_t* ptr = *(const uint16_t**)text;
 81005:     unsigned glyphID = *ptr;
 81005:     ptr += 1;
 81005:     *text = (const char*)ptr;
 81005:     return cache->getGlyphIDMetrics(glyphID, x, y);
 81005: }
 81005: 
 81005: SkDrawCacheProc SkPaint::getDrawCacheProc() const {
 81005:     static const SkDrawCacheProc gDrawCacheProcs[] = {
 81005:         sk_getMetrics_utf8_00,
 81005:         sk_getMetrics_utf16_00,
 99650:         sk_getMetrics_utf32_00,
 81005:         sk_getMetrics_glyph_00,
 81005: 
 81005:         sk_getMetrics_utf8_xy,
 81005:         sk_getMetrics_utf16_xy,
 99650:         sk_getMetrics_utf32_xy,
 81005:         sk_getMetrics_glyph_xy
 81005:     };
 81005: 
 81005:     unsigned index = this->getTextEncoding();
 81005:     if (fFlags & kSubpixelText_Flag) {
 99650:         index += 4;
 81005:     }
 81005: 
 81005:     SkASSERT(index < SK_ARRAY_COUNT(gDrawCacheProcs));
 81005:     return gDrawCacheProcs[index];
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: class SkAutoRestorePaintTextSizeAndFrame {
 81005: public:
 81005:     SkAutoRestorePaintTextSizeAndFrame(const SkPaint* paint)
 81005:             : fPaint((SkPaint*)paint) {
 81005:         fTextSize = paint->getTextSize();
 81005:         fStyle = paint->getStyle();
 81005:         fPaint->setStyle(SkPaint::kFill_Style);
 81005:     }
 81005: 
 81005:     ~SkAutoRestorePaintTextSizeAndFrame() {
 81005:         fPaint->setStyle(fStyle);
 81005:         fPaint->setTextSize(fTextSize);
 81005:     }
 81005: 
 81005: private:
 81005:     SkPaint*        fPaint;
 81005:     SkScalar        fTextSize;
 81005:     SkPaint::Style  fStyle;
 81005: };
 81005: 
 81005: static void set_bounds(const SkGlyph& g, SkRect* bounds) {
 81005:     bounds->set(SkIntToScalar(g.fLeft),
 81005:                 SkIntToScalar(g.fTop),
 81005:                 SkIntToScalar(g.fLeft + g.fWidth),
 81005:                 SkIntToScalar(g.fTop + g.fHeight));
 81005: }
 81005: 
 81005: // 64bits wide, with a 16bit bias. Useful when accumulating lots of 16.16 so
 81005: // we don't overflow along the way
 81005: typedef int64_t Sk48Dot16;
 81005: 
 81005: #ifdef SK_SCALAR_IS_FLOAT
 81005:     static inline float Sk48Dot16ToScalar(Sk48Dot16 x) {
 81005:         return (float) (x * 1.5258789e-5);   // x * (1 / 65536.0f)
 81005:     }
 81005: #else
 81005:     static inline SkFixed Sk48Dot16ToScalar(Sk48Dot16 x) {
 81005:         // just return the low 32bits
 81005:         return static_cast<SkFixed>(x);
 81005:     }
 81005: #endif
 81005: 
 87682: static void join_bounds_x(const SkGlyph& g, SkRect* bounds, Sk48Dot16 dx) {
 81005:     SkScalar sx = Sk48Dot16ToScalar(dx);
 81005:     bounds->join(SkIntToScalar(g.fLeft) + sx,
 81005:                  SkIntToScalar(g.fTop),
 81005:                  SkIntToScalar(g.fLeft + g.fWidth) + sx,
 81005:                  SkIntToScalar(g.fTop + g.fHeight));
 81005: }
 81005: 
 87682: static void join_bounds_y(const SkGlyph& g, SkRect* bounds, Sk48Dot16 dy) {
 87682:     SkScalar sy = Sk48Dot16ToScalar(dy);
 87682:     bounds->join(SkIntToScalar(g.fLeft),
 87682:                  SkIntToScalar(g.fTop) + sy,
 87682:                  SkIntToScalar(g.fLeft + g.fWidth),
 87682:                  SkIntToScalar(g.fTop + g.fHeight) + sy);
 87682: }
 87682: 
 87682: typedef void (*JoinBoundsProc)(const SkGlyph&, SkRect*, Sk48Dot16);
 87682: 
 87682: // xyIndex is 0 for fAdvanceX or 1 for fAdvanceY
 87682: static SkFixed advance(const SkGlyph& glyph, int xyIndex) {
 87682:     SkASSERT(0 == xyIndex || 1 == xyIndex);
 87682:     return (&glyph.fAdvanceX)[xyIndex];
 87682: }
 87682: 
 81005: SkScalar SkPaint::measure_text(SkGlyphCache* cache,
 81005:                                const char* text, size_t byteLength,
 81005:                                int* count, SkRect* bounds) const {
 81005:     SkASSERT(count);
 81005:     if (byteLength == 0) {
 81005:         *count = 0;
 81005:         if (bounds) {
 81005:             bounds->setEmpty();
 81005:         }
 81005:         return 0;
 81005:     }
 81005: 
 81005:     SkMeasureCacheProc glyphCacheProc;
 81005:     glyphCacheProc = this->getMeasureCacheProc(kForward_TextBufferDirection,
 81005:                                                NULL != bounds);
 81005: 
 87682:     int xyIndex;
 87682:     JoinBoundsProc joinBoundsProc;
 87682:     if (this->isVerticalText()) {
 87682:         xyIndex = 1;
 87682:         joinBoundsProc = join_bounds_y;
 87682:     } else {
 87682:         xyIndex = 0;
 87682:         joinBoundsProc = join_bounds_x;
 87682:     }
 87682: 
 81005:     int         n = 1;
 81005:     const char* stop = (const char*)text + byteLength;
 81005:     const SkGlyph* g = &glyphCacheProc(cache, &text);
 81005:     // our accumulated fixed-point advances might overflow 16.16, so we use
 81005:     // a 48.16 (64bit) accumulator, and then convert that to scalar at the
 81005:     // very end.
 87682:     Sk48Dot16 x = advance(*g, xyIndex);
 81005: 
 81005:     SkAutoKern  autokern;
 81005: 
 81005:     if (NULL == bounds) {
 81005:         if (this->isDevKernText()) {
 81005:             int rsb;
 81005:             for (; text < stop; n++) {
 81005:                 rsb = g->fRsbDelta;
 81005:                 g = &glyphCacheProc(cache, &text);
 87682:                 x += SkAutoKern_AdjustF(rsb, g->fLsbDelta) + advance(*g, xyIndex);
 81005:             }
 81005:         } else {
 81005:             for (; text < stop; n++) {
 87682:                 x += advance(glyphCacheProc(cache, &text), xyIndex);
 81005:             }
 81005:         }
 81005:     } else {
 81005:         set_bounds(*g, bounds);
 81005:         if (this->isDevKernText()) {
 81005:             int rsb;
 81005:             for (; text < stop; n++) {
 81005:                 rsb = g->fRsbDelta;
 81005:                 g = &glyphCacheProc(cache, &text);
 81005:                 x += SkAutoKern_AdjustF(rsb, g->fLsbDelta);
 87682:                 joinBoundsProc(*g, bounds, x);
 87682:                 x += advance(*g, xyIndex);
 81005:             }
 81005:         } else {
 81005:             for (; text < stop; n++) {
 81005:                 g = &glyphCacheProc(cache, &text);
 87682:                 joinBoundsProc(*g, bounds, x);
 87682:                 x += advance(*g, xyIndex);
 81005:             }
 81005:         }
 81005:     }
 81005:     SkASSERT(text == stop);
 81005: 
 81005:     *count = n;
 81005:     return Sk48Dot16ToScalar(x);
 81005: }
 81005: 
 81005: SkScalar SkPaint::measureText(const void* textData, size_t length,
 81005:                               SkRect* bounds, SkScalar zoom) const {
 81005:     const char* text = (const char*)textData;
 81005:     SkASSERT(text != NULL || length == 0);
 81005: 
 81005:     SkScalar                            scale = 0;
 81005:     SkAutoRestorePaintTextSizeAndFrame  restore(this);
 81005: 
 81005:     if (this->isLinearText()) {
 81005:         scale = fTextSize / kCanonicalTextSizeForPaths;
 81005:         // this gets restored by restore
 81005:         ((SkPaint*)this)->setTextSize(SkIntToScalar(kCanonicalTextSizeForPaths));
 81005:     }
 81005: 
 81005:     SkMatrix zoomMatrix, *zoomPtr = NULL;
 81005:     if (zoom) {
 81005:         zoomMatrix.setScale(zoom, zoom);
 81005:         zoomPtr = &zoomMatrix;
 81005:     }
 81005: 
 81005:     SkAutoGlyphCache    autoCache(*this, zoomPtr);
 81005:     SkGlyphCache*       cache = autoCache.getCache();
 81005: 
 81005:     SkScalar width = 0;
 81005: 
 81005:     if (length > 0) {
 81005:         int tempCount;
 81005: 
 81005:         width = this->measure_text(cache, text, length, &tempCount, bounds);
 81005:         if (scale) {
 81005:             width = SkScalarMul(width, scale);
 81005:             if (bounds) {
 81005:                 bounds->fLeft = SkScalarMul(bounds->fLeft, scale);
 81005:                 bounds->fTop = SkScalarMul(bounds->fTop, scale);
 81005:                 bounds->fRight = SkScalarMul(bounds->fRight, scale);
 81005:                 bounds->fBottom = SkScalarMul(bounds->fBottom, scale);
 81005:             }
 81005:         }
 81005:     }
 81005:     return width;
 81005: }
 81005: 
 81005: typedef bool (*SkTextBufferPred)(const char* text, const char* stop);
 81005: 
 81005: static bool forward_textBufferPred(const char* text, const char* stop) {
 81005:     return text < stop;
 81005: }
 81005: 
 81005: static bool backward_textBufferPred(const char* text, const char* stop) {
 81005:     return text > stop;
 81005: }
 81005: 
 81005: static SkTextBufferPred chooseTextBufferPred(SkPaint::TextBufferDirection tbd,
 81005:                                              const char** text, size_t length,
 81005:                                              const char** stop) {
 81005:     if (SkPaint::kForward_TextBufferDirection == tbd) {
 81005:         *stop = *text + length;
 81005:         return forward_textBufferPred;
 81005:     } else {
 81005:         // text should point to the end of the buffer, and stop to the beginning
 81005:         *stop = *text;
 81005:         *text += length;
 81005:         return backward_textBufferPred;
 81005:     }
 81005: }
 81005: 
 81005: size_t SkPaint::breakText(const void* textD, size_t length, SkScalar maxWidth,
 81005:                           SkScalar* measuredWidth,
 81005:                           TextBufferDirection tbd) const {
 81005:     if (0 == length || 0 >= maxWidth) {
 81005:         if (measuredWidth) {
 81005:             *measuredWidth = 0;
 81005:         }
 81005:         return 0;
 81005:     }
 81005: 
 87682:     if (0 == fTextSize) {
 87682:         if (measuredWidth) {
 87682:             *measuredWidth = 0;
 87682:         }
 87682:         return length;
 87682:     }
 87682: 
 81005:     SkASSERT(textD != NULL);
 81005:     const char* text = (const char*)textD;
 81005: 
 81005:     SkScalar                            scale = 0;
 81005:     SkAutoRestorePaintTextSizeAndFrame  restore(this);
 81005: 
 81005:     if (this->isLinearText()) {
 81005:         scale = fTextSize / kCanonicalTextSizeForPaths;
 81005:         maxWidth = SkScalarMulDiv(maxWidth, kCanonicalTextSizeForPaths, fTextSize);
 81005:         // this gets restored by restore
 81005:         ((SkPaint*)this)->setTextSize(SkIntToScalar(kCanonicalTextSizeForPaths));
 81005:     }
 81005: 
 81005:     SkAutoGlyphCache    autoCache(*this, NULL);
 81005:     SkGlyphCache*       cache = autoCache.getCache();
 81005: 
 81005:     SkMeasureCacheProc glyphCacheProc = this->getMeasureCacheProc(tbd, false);
 81005:     const char*      stop;
 81005:     SkTextBufferPred pred = chooseTextBufferPred(tbd, &text, length, &stop);
 87682:     const int        xyIndex = this->isVerticalText() ? 1 : 0;
 81005:     // use 64bits for our accumulator, to avoid overflowing 16.16
 81005:     Sk48Dot16        max = SkScalarToFixed(maxWidth);
 81005:     Sk48Dot16        width = 0;
 81005: 
 81005:     SkAutoKern  autokern;
 81005: 
 81005:     if (this->isDevKernText()) {
 81005:         int rsb = 0;
 81005:         while (pred(text, stop)) {
 81005:             const char* curr = text;
 81005:             const SkGlyph& g = glyphCacheProc(cache, &text);
 87682:             SkFixed x = SkAutoKern_AdjustF(rsb, g.fLsbDelta) + advance(g, xyIndex);
 81005:             if ((width += x) > max) {
 81005:                 width -= x;
 81005:                 text = curr;
 81005:                 break;
 81005:             }
 81005:             rsb = g.fRsbDelta;
 81005:         }
 81005:     } else {
 81005:         while (pred(text, stop)) {
 81005:             const char* curr = text;
 87682:             SkFixed x = advance(glyphCacheProc(cache, &text), xyIndex);
 81005:             if ((width += x) > max) {
 81005:                 width -= x;
 81005:                 text = curr;
 81005:                 break;
 81005:             }
 81005:         }
 81005:     }
 81005: 
 81005:     if (measuredWidth) {
 81005:         SkScalar scalarWidth = Sk48Dot16ToScalar(width);
 81005:         if (scale) {
 81005:             scalarWidth = SkScalarMul(scalarWidth, scale);
 81005:         }
 81005:         *measuredWidth = scalarWidth;
 81005:     }
 81005: 
 81005:     // return the number of bytes measured
 81005:     return (kForward_TextBufferDirection == tbd) ?
 81005:                 text - stop + length : stop - text + length;
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: static bool FontMetricsCacheProc(const SkGlyphCache* cache, void* context) {
 81005:     *(SkPaint::FontMetrics*)context = cache->getFontMetricsY();
 81005:     return false;   // don't detach the cache
 81005: }
 81005: 
 81005: static void FontMetricsDescProc(const SkDescriptor* desc, void* context) {
 81005:     SkGlyphCache::VisitCache(desc, FontMetricsCacheProc, context);
 81005: }
 81005: 
 81005: SkScalar SkPaint::getFontMetrics(FontMetrics* metrics, SkScalar zoom) const {
 81005:     SkScalar                            scale = 0;
 81005:     SkAutoRestorePaintTextSizeAndFrame  restore(this);
 81005: 
 81005:     if (this->isLinearText()) {
 81005:         scale = fTextSize / kCanonicalTextSizeForPaths;
 81005:         // this gets restored by restore
 81005:         ((SkPaint*)this)->setTextSize(SkIntToScalar(kCanonicalTextSizeForPaths));
 81005:     }
 81005: 
 81005:     SkMatrix zoomMatrix, *zoomPtr = NULL;
 81005:     if (zoom) {
 81005:         zoomMatrix.setScale(zoom, zoom);
 81005:         zoomPtr = &zoomMatrix;
 81005:     }
 81005: 
 81005: #if 0
 81005:     SkAutoGlyphCache    autoCache(*this, zoomPtr);
 81005:     SkGlyphCache*       cache = autoCache.getCache();
 81005:     const FontMetrics&  my = cache->getFontMetricsY();
 81005: #endif
 81005:     FontMetrics storage;
 81005:     if (NULL == metrics) {
 81005:         metrics = &storage;
 81005:     }
 81005: 
 87682:     this->descriptorProc(zoomPtr, FontMetricsDescProc, metrics, true);
 81005: 
 81005:     if (scale) {
 81005:         metrics->fTop = SkScalarMul(metrics->fTop, scale);
 81005:         metrics->fAscent = SkScalarMul(metrics->fAscent, scale);
 81005:         metrics->fDescent = SkScalarMul(metrics->fDescent, scale);
 81005:         metrics->fBottom = SkScalarMul(metrics->fBottom, scale);
 81005:         metrics->fLeading = SkScalarMul(metrics->fLeading, scale);
 81005:     }
 81005:     return metrics->fDescent - metrics->fAscent + metrics->fLeading;
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: static void set_bounds(const SkGlyph& g, SkRect* bounds, SkScalar scale) {
 81005:     bounds->set(g.fLeft * scale,
 81005:                 g.fTop * scale,
 81005:                 (g.fLeft + g.fWidth) * scale,
 81005:                 (g.fTop + g.fHeight) * scale);
 81005: }
 81005: 
 81005: int SkPaint::getTextWidths(const void* textData, size_t byteLength,
 81005:                            SkScalar widths[], SkRect bounds[]) const {
 81005:     if (0 == byteLength) {
 81005:         return 0;
 81005:     }
 81005: 
 81005:     SkASSERT(NULL != textData);
 81005: 
 81005:     if (NULL == widths && NULL == bounds) {
 81005:         return this->countText(textData, byteLength);
 81005:     }
 81005: 
 81005:     SkAutoRestorePaintTextSizeAndFrame  restore(this);
 81005:     SkScalar                            scale = 0;
 81005: 
 81005:     if (this->isLinearText()) {
 81005:         scale = fTextSize / kCanonicalTextSizeForPaths;
 81005:         // this gets restored by restore
 81005:         ((SkPaint*)this)->setTextSize(SkIntToScalar(kCanonicalTextSizeForPaths));
 81005:     }
 81005: 
 81005:     SkAutoGlyphCache    autoCache(*this, NULL);
 81005:     SkGlyphCache*       cache = autoCache.getCache();
 81005:     SkMeasureCacheProc  glyphCacheProc;
 81005:     glyphCacheProc = this->getMeasureCacheProc(kForward_TextBufferDirection,
 81005:                                                NULL != bounds);
 81005: 
 81005:     const char* text = (const char*)textData;
 81005:     const char* stop = text + byteLength;
 81005:     int         count = 0;
 87682:     const int   xyIndex = this->isVerticalText() ? 1 : 0;
 81005: 
 81005:     if (this->isDevKernText()) {
 81005:         // we adjust the widths returned here through auto-kerning
 81005:         SkAutoKern  autokern;
 81005:         SkFixed     prevWidth = 0;
 81005: 
 81005:         if (scale) {
 81005:             while (text < stop) {
 81005:                 const SkGlyph& g = glyphCacheProc(cache, &text);
 81005:                 if (widths) {
 81005:                     SkFixed  adjust = autokern.adjust(g);
 81005: 
 81005:                     if (count > 0) {
 81005:                         SkScalar w = SkFixedToScalar(prevWidth + adjust);
 81005:                         *widths++ = SkScalarMul(w, scale);
 81005:                     }
 87682:                     prevWidth = advance(g, xyIndex);
 81005:                 }
 81005:                 if (bounds) {
 81005:                     set_bounds(g, bounds++, scale);
 81005:                 }
 81005:                 ++count;
 81005:             }
 81005:             if (count > 0 && widths) {
 81005:                 *widths = SkScalarMul(SkFixedToScalar(prevWidth), scale);
 81005:             }
 81005:         } else {
 81005:             while (text < stop) {
 81005:                 const SkGlyph& g = glyphCacheProc(cache, &text);
 81005:                 if (widths) {
 81005:                     SkFixed  adjust = autokern.adjust(g);
 81005: 
 81005:                     if (count > 0) {
 81005:                         *widths++ = SkFixedToScalar(prevWidth + adjust);
 81005:                     }
 87682:                     prevWidth = advance(g, xyIndex);
 81005:                 }
 81005:                 if (bounds) {
 81005:                     set_bounds(g, bounds++);
 81005:                 }
 81005:                 ++count;
 81005:             }
 81005:             if (count > 0 && widths) {
 81005:                 *widths = SkFixedToScalar(prevWidth);
 81005:             }
 81005:         }
 81005:     } else {    // no devkern
 81005:         if (scale) {
 81005:             while (text < stop) {
 81005:                 const SkGlyph& g = glyphCacheProc(cache, &text);
 81005:                 if (widths) {
 87682:                     *widths++ = SkScalarMul(SkFixedToScalar(advance(g, xyIndex)),
 81005:                                             scale);
 81005:                 }
 81005:                 if (bounds) {
 81005:                     set_bounds(g, bounds++, scale);
 81005:                 }
 81005:                 ++count;
 81005:             }
 81005:         } else {
 81005:             while (text < stop) {
 81005:                 const SkGlyph& g = glyphCacheProc(cache, &text);
 81005:                 if (widths) {
 87682:                     *widths++ = SkFixedToScalar(advance(g, xyIndex));
 81005:                 }
 81005:                 if (bounds) {
 81005:                     set_bounds(g, bounds++);
 81005:                 }
 81005:                 ++count;
 81005:             }
 81005:         }
 81005:     }
 81005: 
 81005:     SkASSERT(text == stop);
 81005:     return count;
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: #include "SkDraw.h"
 81005: 
 81005: void SkPaint::getTextPath(const void* textData, size_t length,
 81005:                           SkScalar x, SkScalar y, SkPath* path) const {
 81005:     SkASSERT(length == 0 || textData != NULL);
 81005: 
 81005:     const char* text = (const char*)textData;
 81005:     if (text == NULL || length == 0 || path == NULL) {
 81005:         return;
 81005:     }
 81005: 
 99650:     SkTextToPathIter    iter(text, length, *this, false);
 81005:     SkMatrix            matrix;
 81005:     SkScalar            prevXPos = 0;
 81005: 
 81005:     matrix.setScale(iter.getPathScale(), iter.getPathScale());
 81005:     matrix.postTranslate(x, y);
 81005:     path->reset();
 81005: 
 81005:     SkScalar        xpos;
 81005:     const SkPath*   iterPath;
 81005:     while ((iterPath = iter.next(&xpos)) != NULL) {
 81005:         matrix.postTranslate(xpos - prevXPos, 0);
 81005:         path->addPath(*iterPath, matrix);
 81005:         prevXPos = xpos;
 81005:     }
 81005: }
 81005: 
 99653: void SkPaint::getPosTextPath(const void* textData, size_t length,
 99653:                              const SkPoint pos[], SkPath* path) const {
 99653:     SkASSERT(length == 0 || textData != NULL);
 99653: 
 99653:     const char* text = (const char*)textData;
 99653:     if (text == NULL || length == 0 || path == NULL) {
 99653:         return;
 99653:     }
 99653: 
101753:     SkTextToPathIter    iter(text, length, *this, false);
 99653:     SkMatrix            matrix;
 99653:     SkPoint             prevPos;
 99653:     prevPos.set(0, 0);
 99653: 
 99653:     matrix.setScale(iter.getPathScale(), iter.getPathScale());
 99653:     path->reset();
 99653: 
 99653:     unsigned int    i = 0;
 99653:     const SkPath*   iterPath;
101753:     while ((iterPath = iter.next(NULL)) != NULL) {
 99653:         matrix.postTranslate(pos[i].fX - prevPos.fX, pos[i].fY - prevPos.fY);
 99653:         path->addPath(*iterPath, matrix);
 99653:         prevPos = pos[i];
 99653:         i++;
 99653:     }
 99653: }
 99653: 
 81005: static void add_flattenable(SkDescriptor* desc, uint32_t tag,
 81005:                             SkFlattenableWriteBuffer* buffer) {
 81005:     buffer->flatten(desc->addEntry(tag, buffer->size(), NULL));
 81005: }
 81005: 
 81005: // SkFontHost can override this choice in FilterRec()
 81005: static SkMask::Format computeMaskFormat(const SkPaint& paint) {
 81005:     uint32_t flags = paint.getFlags();
 81005: 
 81005:     // Antialiasing being disabled trumps all other settings.
 81005:     if (!(flags & SkPaint::kAntiAlias_Flag)) {
 81005:         return SkMask::kBW_Format;
 81005:     }
 81005: 
 81005:     if (flags & SkPaint::kLCDRenderText_Flag) {
 81005:         return SkMask::kLCD16_Format;
 81005:     }
 81005: 
 81005:     return SkMask::kA8_Format;
 81005: }
 81005: 
 81005: // if linear-text is on, then we force hinting to be off (since that's sort of
 81005: // the point of linear-text.
 81005: static SkPaint::Hinting computeHinting(const SkPaint& paint) {
 81005:     SkPaint::Hinting h = paint.getHinting();
 81005:     if (paint.isLinearText()) {
 81005:         h = SkPaint::kNo_Hinting;
 81005:     }
 81005:     return h;
 81005: }
 81005: 
 87682: // return true if the paint is just a single color (i.e. not a shader). If its
 87682: // a shader, then we can't compute a const luminance for it :(
 87682: static bool justAColor(const SkPaint& paint, SkColor* color) {
 87682:     if (paint.getShader()) {
 87682:         return false;
 87682:     }
 87682:     SkColor c = paint.getColor();
 87682:     if (paint.getColorFilter()) {
 87682:         c = paint.getColorFilter()->filterColor(c);
 87682:     }
 87682:     if (color) {
 87682:         *color = c;
 87682:     }
 87682:     return true;
 87682: }
 87682: 
 99650: #ifdef SK_USE_COLOR_LUMINANCE
 99650: static SkColor computeLuminanceColor(const SkPaint& paint) {
 99650:     SkColor c;
 99650:     if (!justAColor(paint, &c)) {
 99650:         c = SkColorSetRGB(0x7F, 0x80, 0x7F);
 99650:     }
 99650:     return c;
 99650: }
 99650: 
 99650: #define assert_byte(x)  SkASSERT(0 == ((x) >> 8))
 99650: 
 99650: static U8CPU reduce_lumbits(U8CPU x) {
 99650:     static const uint8_t gReduceBits[] = {
 99650:         0x0, 0x55, 0xAA, 0xFF
 99650:     };
 99650:     assert_byte(x);
 99650:     return gReduceBits[x >> 6];
 99650: }
 99650: 
 99650: static unsigned computeLuminance(SkColor c) {
 99650:     int r = SkColorGetR(c);
 99650:     int g = SkColorGetG(c);
 99650:     int b = SkColorGetB(c);
 99650:     // compute luminance
 99650:     // R=0.2126 G=0.7152 B=0.0722
 99650:     // scaling by 127 yields 27, 92, 9
 99650:     int luminance = r * 27 + g * 92 + b * 9;
 99650:     luminance >>= 7;
 99650:     assert_byte(luminance);
 99650:     return luminance;
 99650: }
 99650: 
 99650: #else
 87682: // returns 0..kLuminance_Max
 87682: static unsigned computeLuminance(const SkPaint& paint) {
 87682:     SkColor c;
 87682:     if (justAColor(paint, &c)) {
 87682:         int r = SkColorGetR(c);
 87682:         int g = SkColorGetG(c);
 87682:         int b = SkColorGetB(c);
 87682:         // compute luminance
 87682:         // R=0.2126 G=0.7152 B=0.0722
 87682:         // scaling by 127 yields 27, 92, 9
 87682: #if 1
 87682:         int luminance = r * 27 + g * 92 + b * 9;
 87682:         luminance >>= 15 - SkScalerContext::kLuminance_Bits;
 87682: #else
 87682:         int luminance = r * 2 + g * 5 + b * 1;
 87682:         luminance >>= 11 - SkScalerContext::kLuminance_Bits;
 87682: #endif
 87682:         SkASSERT(luminance <= SkScalerContext::kLuminance_Max);
 87682:         return luminance;
 87682:     }
 87682:     // if we're not a single color, return the middle of the luminance range
 87682:     return SkScalerContext::kLuminance_Max >> 1;
 87682: }
 99650: #endif
 87682: 
 81005: // Beyond this size, LCD doesn't appreciably improve quality, but it always
 81005: // cost more RAM and draws slower, so we set a cap.
 81005: #ifndef SK_MAX_SIZE_FOR_LCDTEXT
 81005:     #define SK_MAX_SIZE_FOR_LCDTEXT    48
 81005: #endif
 81005: 
 81005: static bool tooBigForLCD(const SkScalerContext::Rec& rec) {
 81005:     SkScalar area = SkScalarMul(rec.fPost2x2[0][0], rec.fPost2x2[1][1]) -
 81005:                     SkScalarMul(rec.fPost2x2[1][0], rec.fPost2x2[0][1]);
 81005:     SkScalar size = SkScalarMul(area, rec.fTextSize);
 81005:     return SkScalarAbs(size) > SkIntToScalar(SK_MAX_SIZE_FOR_LCDTEXT);
 81005: }
 81005: 
 81005: /*
 81005:  *  Return the scalar with only limited fractional precision. Used to consolidate matrices
 81005:  *  that vary only slightly when we create our key into the font cache, since the font scaler
 81005:  *  typically returns the same looking resuts for tiny changes in the matrix.
 81005:  */
 81005: static SkScalar sk_relax(SkScalar x) {
 81005: #ifdef SK_SCALAR_IS_FLOAT
 81005:     int n = sk_float_round2int(x * 1024);
 81005:     return n / 1024.0f;
 81005: #else
 81005:     // round to the nearest 10 fractional bits
 81005:     return (x + (1 << 5)) & ~(1024 - 1);
 81005: #endif
 81005: }
 81005: 
 81005: void SkScalerContext::MakeRec(const SkPaint& paint,
 81005:                               const SkMatrix* deviceMatrix, Rec* rec) {
 81005:     SkASSERT(deviceMatrix == NULL || !deviceMatrix->hasPerspective());
 81005: 
 81005:     rec->fOrigFontID = SkTypeface::UniqueID(paint.getTypeface());
 81005:     rec->fFontID = rec->fOrigFontID;
 81005:     rec->fTextSize = paint.getTextSize();
 81005:     rec->fPreScaleX = paint.getTextScaleX();
 81005:     rec->fPreSkewX  = paint.getTextSkewX();
 81005: 
 81005:     if (deviceMatrix) {
 81005:         rec->fPost2x2[0][0] = sk_relax(deviceMatrix->getScaleX());
 81005:         rec->fPost2x2[0][1] = sk_relax(deviceMatrix->getSkewX());
 81005:         rec->fPost2x2[1][0] = sk_relax(deviceMatrix->getSkewY());
 81005:         rec->fPost2x2[1][1] = sk_relax(deviceMatrix->getScaleY());
 81005:     } else {
 81005:         rec->fPost2x2[0][0] = rec->fPost2x2[1][1] = SK_Scalar1;
 81005:         rec->fPost2x2[0][1] = rec->fPost2x2[1][0] = 0;
 81005:     }
 81005: 
 81005:     SkPaint::Style  style = paint.getStyle();
 81005:     SkScalar        strokeWidth = paint.getStrokeWidth();
 81005: 
 87682:     unsigned flags = 0;
 81005: 
 81005:     if (paint.isFakeBoldText()) {
 81005: #ifdef SK_USE_FREETYPE_EMBOLDEN
 81005:         flags |= SkScalerContext::kEmbolden_Flag;
 81005: #else
 81005:         SkScalar fakeBoldScale = SkScalarInterpFunc(paint.getTextSize(),
 81005:                                                     kStdFakeBoldInterpKeys,
 81005:                                                     kStdFakeBoldInterpValues,
 81005:                                                     kStdFakeBoldInterpLength);
 81005:         SkScalar extra = SkScalarMul(paint.getTextSize(), fakeBoldScale);
 81005: 
 81005:         if (style == SkPaint::kFill_Style) {
 81005:             style = SkPaint::kStrokeAndFill_Style;
 81005:             strokeWidth = extra;    // ignore paint's strokeWidth if it was "fill"
 81005:         } else {
 81005:             strokeWidth += extra;
 81005:         }
 81005: #endif
 81005:     }
 81005: 
 81005:     if (paint.isDevKernText()) {
 81005:         flags |= SkScalerContext::kDevKernText_Flag;
 81005:     }
 81005: 
 81005:     if (style != SkPaint::kFill_Style && strokeWidth > 0) {
 81005:         rec->fFrameWidth = strokeWidth;
 81005:         rec->fMiterLimit = paint.getStrokeMiter();
 81005:         rec->fStrokeJoin = SkToU8(paint.getStrokeJoin());
 81005: 
 81005:         if (style == SkPaint::kStrokeAndFill_Style) {
 81005:             flags |= SkScalerContext::kFrameAndFill_Flag;
 81005:         }
 81005:     } else {
 81005:         rec->fFrameWidth = 0;
 81005:         rec->fMiterLimit = 0;
 81005:         rec->fStrokeJoin = 0;
 81005:     }
 81005: 
 81005:     rec->fMaskFormat = SkToU8(computeMaskFormat(paint));
 81005: 
 81005:     if (SkMask::kLCD16_Format == rec->fMaskFormat ||
 81005:         SkMask::kLCD32_Format == rec->fMaskFormat)
 81005:     {
 81005:         SkFontHost::LCDOrder order = SkFontHost::GetSubpixelOrder();
 81005:         SkFontHost::LCDOrientation orient = SkFontHost::GetSubpixelOrientation();
 81005:         if (SkFontHost::kNONE_LCDOrder == order || tooBigForLCD(*rec)) {
 81005:             // eeek, can't support LCD
 81005:             rec->fMaskFormat = SkMask::kA8_Format;
 81005:         } else {
 81005:             if (SkFontHost::kVertical_LCDOrientation == orient) {
 81005:                 flags |= SkScalerContext::kLCD_Vertical_Flag;
 81005:             }
 81005:             if (SkFontHost::kBGR_LCDOrder == order) {
 81005:                 flags |= SkScalerContext::kLCD_BGROrder_Flag;
 81005:             }
 81005:         }
 81005:     }
 81005: 
 81005:     if (paint.isEmbeddedBitmapText()) {
 81005:         flags |= SkScalerContext::kEmbeddedBitmapText_Flag;
 81005:     }
 81005:     if (paint.isSubpixelText()) {
 81005:         flags |= SkScalerContext::kSubpixelPositioning_Flag;
 81005:     }
 81005:     if (paint.isAutohinted()) {
 81005:         flags |= SkScalerContext::kAutohinting_Flag;
 81005:     }
 87682:     if (paint.isVerticalText()) {
 87682:         flags |= SkScalerContext::kVertical_Flag;
 81005:     }
 99650:     if (paint.getFlags() & SkPaint::kGenA8FromLCD_Flag) {
 99650:         flags |= SkScalerContext::kGenA8FromLCD_Flag;
 99650:     }
 81005:     rec->fFlags = SkToU16(flags);
 81005: 
 87682:     // these modify fFlags, so do them after assigning fFlags
 81005:     rec->setHinting(computeHinting(paint));
 99650: #ifdef SK_USE_COLOR_LUMINANCE
 99650:     rec->setLuminanceColor(computeLuminanceColor(paint));
 99650: #else
 87682:     rec->setLuminanceBits(computeLuminance(paint));
 99650: #endif
 81005: 
 81005:     /*  Allow the fonthost to modify our rec before we use it as a key into the
 81005:         cache. This way if we're asking for something that they will ignore,
 81005:         they can modify our rec up front, so we don't create duplicate cache
 81005:         entries.
 81005:      */
 81005:     SkFontHost::FilterRec(rec);
 81005: 
 99650:     // be sure to call PostMakeRec(rec) before you actually use it!
 99650: }
 99650: 
 99650: /**
 99650:  *  We ensure that the rec is self-consistent and efficient (where possible)
 99650:  */
 99650: void SkScalerContext::PostMakeRec(SkScalerContext::Rec* rec) {
 99650: 
 99650:     /**
 99650:      *  If we're asking for A8, we force the colorlum to be gray, since that
 99650:      *  that limits the number of unique entries, and the scaler will only
 99650:      *  look at the lum of one of them.
 99650:      */
 99650:     switch (rec->fMaskFormat) {
 99650:         case SkMask::kLCD16_Format:
 99650:         case SkMask::kLCD32_Format: {
 99650: #ifdef SK_USE_COLOR_LUMINANCE
 99650:             // filter down the luminance color to a finite number of bits
 99650:             SkColor c = rec->getLuminanceColor();
 99650:             c = SkColorSetRGB(reduce_lumbits(SkColorGetR(c)),
 99650:                               reduce_lumbits(SkColorGetG(c)),
 99650:                               reduce_lumbits(SkColorGetB(c)));
 99650:             rec->setLuminanceColor(c);
 99650: #endif
 99650:             break;
 99650:         }
 99650:         case SkMask::kA8_Format: {
 99650: #ifdef SK_USE_COLOR_LUMINANCE
 99650:             // filter down the luminance to a single component, since A8 can't
 99650:             // use per-component information
 99650:             unsigned lum = computeLuminance(rec->getLuminanceColor());
 99650:             // reduce to our finite number of bits
 99650:             lum = reduce_lumbits(lum);
 99650:             rec->setLuminanceColor(SkColorSetRGB(lum, lum, lum));
 99650: #endif
 99650:             break;
 99650:         }
 99650:         case SkMask::kBW_Format:
 81005:             // No need to differentiate gamma if we're BW
 99650: #ifdef SK_USE_COLOR_LUMINANCE
 99650:             rec->setLuminanceColor(0);
 99650: #else
 87682:             rec->setLuminanceBits(0);
 99650: #endif
 99650:             break;
 81005:     }
 81005: }
 81005: 
 81005: #define MIN_SIZE_FOR_EFFECT_BUFFER  1024
 81005: 
 81005: #ifdef SK_DEBUG
 81005:     #define TEST_DESC
 81005: #endif
 81005: 
 87682: /*
 87682:  *  ignoreGamma tells us that the caller just wants metrics that are unaffected
 87682:  *  by gamma correction, so we jam the luminance field to 0 (most common value
 87682:  *  for black text) in hopes that we get a cache hit easier. A better solution
 87682:  *  would be for the fontcache lookup to know to ignore the luminance field
 87682:  *  entirely, but not sure how to do that and keep it fast.
 87682:  */
 81005: void SkPaint::descriptorProc(const SkMatrix* deviceMatrix,
 81005:                              void (*proc)(const SkDescriptor*, void*),
 81005:                              void* context, bool ignoreGamma) const {
 81005:     SkScalerContext::Rec    rec;
 81005: 
 81005:     SkScalerContext::MakeRec(*this, deviceMatrix, &rec);
 81005:     if (ignoreGamma) {
 99650: #ifdef SK_USE_COLOR_LUMINANCE
 99650:         rec.setLuminanceColor(0);
 99650: #else
 87682:         rec.setLuminanceBits(0);
 99650: #endif
 81005:     }
 81005: 
 81005:     size_t          descSize = sizeof(rec);
 81005:     int             entryCount = 1;
 81005:     SkPathEffect*   pe = this->getPathEffect();
 81005:     SkMaskFilter*   mf = this->getMaskFilter();
 81005:     SkRasterizer*   ra = this->getRasterizer();
 81005: 
 99650:     SkOrderedWriteBuffer    peBuffer(MIN_SIZE_FOR_EFFECT_BUFFER);
 99650:     SkOrderedWriteBuffer    mfBuffer(MIN_SIZE_FOR_EFFECT_BUFFER);
 99650:     SkOrderedWriteBuffer    raBuffer(MIN_SIZE_FOR_EFFECT_BUFFER);
 81005: 
 81005:     if (pe) {
 81005:         peBuffer.writeFlattenable(pe);
 81005:         descSize += peBuffer.size();
 81005:         entryCount += 1;
 81005:         rec.fMaskFormat = SkMask::kA8_Format;   // force antialiasing when we do the scan conversion
 81005:         // seems like we could support kLCD as well at this point...
 81005:     }
 81005:     if (mf) {
 81005:         mfBuffer.writeFlattenable(mf);
 81005:         descSize += mfBuffer.size();
 81005:         entryCount += 1;
 81005:         rec.fMaskFormat = SkMask::kA8_Format;   // force antialiasing with maskfilters
 81005:     }
 81005:     if (ra) {
 81005:         raBuffer.writeFlattenable(ra);
 81005:         descSize += raBuffer.size();
 81005:         entryCount += 1;
 81005:         rec.fMaskFormat = SkMask::kA8_Format;   // force antialiasing when we do the scan conversion
 81005:     }
 99650: 
 99650:     ///////////////////////////////////////////////////////////////////////////
 99650:     // Now that we're done tweaking the rec, call the PostMakeRec cleanup
 99650:     SkScalerContext::PostMakeRec(&rec);
 99650:     
 81005:     descSize += SkDescriptor::ComputeOverhead(entryCount);
 81005: 
 81005:     SkAutoDescriptor    ad(descSize);
 81005:     SkDescriptor*       desc = ad.getDesc();
 81005: 
 81005:     desc->init();
 81005:     desc->addEntry(kRec_SkDescriptorTag, sizeof(rec), &rec);
 81005: 
 81005:     if (pe) {
 81005:         add_flattenable(desc, kPathEffect_SkDescriptorTag, &peBuffer);
 81005:     }
 81005:     if (mf) {
 81005:         add_flattenable(desc, kMaskFilter_SkDescriptorTag, &mfBuffer);
 81005:     }
 81005:     if (ra) {
 81005:         add_flattenable(desc, kRasterizer_SkDescriptorTag, &raBuffer);
 81005:     }
 81005: 
 81005:     SkASSERT(descSize == desc->getLength());
 81005:     desc->computeChecksum();
 81005: 
 81005: #ifdef TEST_DESC
 81005:     {
 81005:         // Check that we completely write the bytes in desc (our key), and that
 81005:         // there are no uninitialized bytes. If there were, then we would get
 81005:         // false-misses (or worse, false-hits) in our fontcache.
 81005:         //
 81005:         // We do this buy filling 2 others, one with 0s and the other with 1s
 81005:         // and create those, and then check that all 3 are identical.
 81005:         SkAutoDescriptor    ad1(descSize);
 81005:         SkAutoDescriptor    ad2(descSize);
 81005:         SkDescriptor*       desc1 = ad1.getDesc();
 81005:         SkDescriptor*       desc2 = ad2.getDesc();
 81005:         
 81005:         memset(desc1, 0x00, descSize);
 81005:         memset(desc2, 0xFF, descSize);
 81005:         
 81005:         desc1->init();
 81005:         desc2->init();
 81005:         desc1->addEntry(kRec_SkDescriptorTag, sizeof(rec), &rec);
 81005:         desc2->addEntry(kRec_SkDescriptorTag, sizeof(rec), &rec);
 81005:         
 81005:         if (pe) {
 81005:             add_flattenable(desc1, kPathEffect_SkDescriptorTag, &peBuffer);
 81005:             add_flattenable(desc2, kPathEffect_SkDescriptorTag, &peBuffer);
 81005:         }
 81005:         if (mf) {
 81005:             add_flattenable(desc1, kMaskFilter_SkDescriptorTag, &mfBuffer);
 81005:             add_flattenable(desc2, kMaskFilter_SkDescriptorTag, &mfBuffer);
 81005:         }
 81005:         if (ra) {
 81005:             add_flattenable(desc1, kRasterizer_SkDescriptorTag, &raBuffer);
 81005:             add_flattenable(desc2, kRasterizer_SkDescriptorTag, &raBuffer);
 81005:         }
 81005:         
 81005:         SkASSERT(descSize == desc1->getLength());
 81005:         SkASSERT(descSize == desc2->getLength());
 81005:         desc1->computeChecksum();
 81005:         desc2->computeChecksum();
 81005:         SkASSERT(!memcmp(desc, desc1, descSize));
 81005:         SkASSERT(!memcmp(desc, desc2, descSize));
 81005:     }
 81005: #endif
 81005:     
 81005:     proc(desc, context);
 81005: }
 81005: 
 81005: SkGlyphCache* SkPaint::detachCache(const SkMatrix* deviceMatrix) const {
 81005:     SkGlyphCache* cache;
 81005:     this->descriptorProc(deviceMatrix, DetachDescProc, &cache);
 81005:     return cache;
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: #include "SkStream.h"
 81005: 
 81005: static uintptr_t asint(const void* p) {
 81005:     return reinterpret_cast<uintptr_t>(p);
 81005: }
 81005: 
 81005: union Scalar32 {
 81005:     SkScalar    fScalar;
 81005:     uint32_t    f32;
 81005: };
 81005: 
 81005: static uint32_t* write_scalar(uint32_t* ptr, SkScalar value) {
 81005:     SkASSERT(sizeof(SkScalar) == sizeof(uint32_t));
 81005:     Scalar32 tmp;
 81005:     tmp.fScalar = value;
 81005:     *ptr = tmp.f32;
 81005:     return ptr + 1;
 81005: }
 81005: 
 81005: static SkScalar read_scalar(const uint32_t*& ptr) {
 81005:     SkASSERT(sizeof(SkScalar) == sizeof(uint32_t));
 81005:     Scalar32 tmp;
 81005:     tmp.f32 = *ptr++;
 81005:     return tmp.fScalar;
 81005: }
 81005: 
 81005: static uint32_t pack_4(unsigned a, unsigned b, unsigned c, unsigned d) {
 81005:     SkASSERT(a == (uint8_t)a);
 81005:     SkASSERT(b == (uint8_t)b);
 81005:     SkASSERT(c == (uint8_t)c);
 81005:     SkASSERT(d == (uint8_t)d);
 81005:     return (a << 24) | (b << 16) | (c << 8) | d;
 81005: }
 81005: 
 81005: enum FlatFlags {
 81005:     kHasTypeface_FlatFlag   = 0x01,
 81005:     kHasEffects_FlatFlag    = 0x02
 81005: };
 81005: 
 81005: // The size of a flat paint's POD fields
 81005: static const uint32_t kPODPaintSize =   5 * sizeof(SkScalar) +
 81005:                                         1 * sizeof(SkColor) +
 81005:                                         1 * sizeof(uint16_t) +
 81005:                                         6 * sizeof(uint8_t);
 81005: 
 81005: /*  To save space/time, we analyze the paint, and write a truncated version of
 81005:     it if there are not tricky elements like shaders, etc.
 81005:  */
 81005: void SkPaint::flatten(SkFlattenableWriteBuffer& buffer) const {
 81005:     uint8_t flatFlags = 0;
 81005:     if (this->getTypeface()) {
 81005:         flatFlags |= kHasTypeface_FlatFlag;
 81005:     }
 81005:     if (asint(this->getPathEffect()) |
 81005:         asint(this->getShader()) |
 81005:         asint(this->getXfermode()) |
 81005:         asint(this->getMaskFilter()) |
 81005:         asint(this->getColorFilter()) |
 81005:         asint(this->getRasterizer()) |
 87682:         asint(this->getLooper()) |
 87682:         asint(this->getImageFilter())) {
 81005:         flatFlags |= kHasEffects_FlatFlag;
 81005:     }
 81005: 
 81005:     SkASSERT(SkAlign4(kPODPaintSize) == kPODPaintSize);
 81005:     uint32_t* ptr = buffer.reserve(kPODPaintSize);
 81005: 
 81005:     ptr = write_scalar(ptr, this->getTextSize());
 81005:     ptr = write_scalar(ptr, this->getTextScaleX());
 81005:     ptr = write_scalar(ptr, this->getTextSkewX());
 81005:     ptr = write_scalar(ptr, this->getStrokeWidth());
 81005:     ptr = write_scalar(ptr, this->getStrokeMiter());
 81005:     *ptr++ = this->getColor();
 87682:     // previously flags:16, textAlign:8, flatFlags:8
 87682:     // now flags:16, hinting:4, textAlign:4, flatFlags:8
 87682:     *ptr++ = (this->getFlags() << 16) |
 87682:              // hinting added later. 0 in this nibble means use the default.
 87682:              ((this->getHinting()+1) << 12) |
 87682:              (this->getTextAlign() << 8) |
 87682:              flatFlags;
 81005:     *ptr++ = pack_4(this->getStrokeCap(), this->getStrokeJoin(),
 81005:                     this->getStyle(), this->getTextEncoding());
 81005: 
 81005:     // now we're done with ptr and the (pre)reserved space. If we need to write
 81005:     // additional fields, use the buffer directly
 81005:     if (flatFlags & kHasTypeface_FlatFlag) {
 81005:         buffer.writeTypeface(this->getTypeface());
 81005:     }
 81005:     if (flatFlags & kHasEffects_FlatFlag) {
 81005:         buffer.writeFlattenable(this->getPathEffect());
 81005:         buffer.writeFlattenable(this->getShader());
 81005:         buffer.writeFlattenable(this->getXfermode());
 81005:         buffer.writeFlattenable(this->getMaskFilter());
 81005:         buffer.writeFlattenable(this->getColorFilter());
 81005:         buffer.writeFlattenable(this->getRasterizer());
 81005:         buffer.writeFlattenable(this->getLooper());
 87682:         buffer.writeFlattenable(this->getImageFilter());
 81005:     }
 81005: }
 81005: 
 81005: void SkPaint::unflatten(SkFlattenableReadBuffer& buffer) {
 81005:     SkASSERT(SkAlign4(kPODPaintSize) == kPODPaintSize);
 81005:     const void* podData = buffer.skip(kPODPaintSize);
 81005:     const uint32_t* pod = reinterpret_cast<const uint32_t*>(podData);
 81005: 
 81005:     // the order we read must match the order we wrote in flatten()
 81005:     this->setTextSize(read_scalar(pod));
 81005:     this->setTextScaleX(read_scalar(pod));
 81005:     this->setTextSkewX(read_scalar(pod));
 81005:     this->setStrokeWidth(read_scalar(pod));
 81005:     this->setStrokeMiter(read_scalar(pod));
 81005:     this->setColor(*pod++);
 81005: 
 87682:     // previously flags:16, textAlign:8, flatFlags:8
 87682:     // now flags:16, hinting:4, textAlign:4, flatFlags:8
 81005:     uint32_t tmp = *pod++;
 81005:     this->setFlags(tmp >> 16);
 87682: 
 87682:     // hinting added later. 0 in this nibble means use the default.
 87682:     uint32_t hinting = (tmp >> 12) & 0xF;
 87682:     this->setHinting(0 == hinting ? kNormal_Hinting : static_cast<Hinting>(hinting-1));
 87682: 
 87682:     this->setTextAlign(static_cast<Align>((tmp >> 8) & 0xF));
 87682: 
 81005:     uint8_t flatFlags = tmp & 0xFF;
 81005: 
 81005:     tmp = *pod++;
 81005:     this->setStrokeCap(static_cast<Cap>((tmp >> 24) & 0xFF));
 81005:     this->setStrokeJoin(static_cast<Join>((tmp >> 16) & 0xFF));
 81005:     this->setStyle(static_cast<Style>((tmp >> 8) & 0xFF));
 81005:     this->setTextEncoding(static_cast<TextEncoding>((tmp >> 0) & 0xFF));
 81005: 
 81005:     if (flatFlags & kHasTypeface_FlatFlag) {
 81005:         this->setTypeface(buffer.readTypeface());
 81005:     } else {
 81005:         this->setTypeface(NULL);
 81005:     }
 81005: 
 81005:     if (flatFlags & kHasEffects_FlatFlag) {
 81005:         SkSafeUnref(this->setPathEffect((SkPathEffect*) buffer.readFlattenable()));
 81005:         SkSafeUnref(this->setShader((SkShader*) buffer.readFlattenable()));
 81005:         SkSafeUnref(this->setXfermode((SkXfermode*) buffer.readFlattenable()));
 81005:         SkSafeUnref(this->setMaskFilter((SkMaskFilter*) buffer.readFlattenable()));
 81005:         SkSafeUnref(this->setColorFilter((SkColorFilter*) buffer.readFlattenable()));
 81005:         SkSafeUnref(this->setRasterizer((SkRasterizer*) buffer.readFlattenable()));
 81005:         SkSafeUnref(this->setLooper((SkDrawLooper*) buffer.readFlattenable()));
 87682:         SkSafeUnref(this->setImageFilter((SkImageFilter*) buffer.readFlattenable()));
 81005:     } else {
 81005:         this->setPathEffect(NULL);
 81005:         this->setShader(NULL);
 81005:         this->setXfermode(NULL);
 81005:         this->setMaskFilter(NULL);
 81005:         this->setColorFilter(NULL);
 81005:         this->setRasterizer(NULL);
 81005:         this->setLooper(NULL);
 87682:         this->setImageFilter(NULL);
 81005:     }
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: SkShader* SkPaint::setShader(SkShader* shader) {
 81005:     GEN_ID_INC_EVAL(shader != fShader);
 81005:     SkRefCnt_SafeAssign(fShader, shader);
 81005:     return shader;
 81005: }
 81005: 
 81005: SkColorFilter* SkPaint::setColorFilter(SkColorFilter* filter) {
 81005:     GEN_ID_INC_EVAL(filter != fColorFilter);
 81005:     SkRefCnt_SafeAssign(fColorFilter, filter);
 81005:     return filter;
 81005: }
 81005: 
 81005: SkXfermode* SkPaint::setXfermode(SkXfermode* mode) {
 81005:     GEN_ID_INC_EVAL(mode != fXfermode);
 81005:     SkRefCnt_SafeAssign(fXfermode, mode);
 81005:     return mode;
 81005: }
 81005: 
 81005: SkXfermode* SkPaint::setXfermodeMode(SkXfermode::Mode mode) {
 81005:     SkSafeUnref(fXfermode);
 81005:     fXfermode = SkXfermode::Create(mode);
 81005:     GEN_ID_INC;
 81005:     return fXfermode;
 81005: }
 81005: 
 81005: SkPathEffect* SkPaint::setPathEffect(SkPathEffect* effect) {
 81005:     GEN_ID_INC_EVAL(effect != fPathEffect);
 81005:     SkRefCnt_SafeAssign(fPathEffect, effect);
 81005:     return effect;
 81005: }
 81005: 
 81005: SkMaskFilter* SkPaint::setMaskFilter(SkMaskFilter* filter) {
 81005:     GEN_ID_INC_EVAL(filter != fMaskFilter);
 81005:     SkRefCnt_SafeAssign(fMaskFilter, filter);
 81005:     return filter;
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: bool SkPaint::getFillPath(const SkPath& src, SkPath* dst) const {
 81005:     SkPath          effectPath, strokePath;
 81005:     const SkPath*   path = &src;
 81005: 
 81005:     SkScalar width = this->getStrokeWidth();
 81005: 
 81005:     switch (this->getStyle()) {
 81005:         case SkPaint::kFill_Style:
 81005:             width = -1; // mark it as no-stroke
 81005:             break;
 81005:         case SkPaint::kStrokeAndFill_Style:
 81005:             if (width == 0) {
 81005:                 width = -1; // mark it as no-stroke
 81005:             }
 81005:             break;
 81005:         case SkPaint::kStroke_Style:
 81005:             break;
 81005:         default:
 87682:             SkDEBUGFAIL("unknown paint style");
 81005:     }
 81005: 
 81005:     if (this->getPathEffect()) {
 81005:         // lie to the pathEffect if our style is strokeandfill, so that it treats us as just fill
 81005:         if (this->getStyle() == SkPaint::kStrokeAndFill_Style) {
 81005:             width = -1; // mark it as no-stroke
 81005:         }
 81005: 
 81005:         if (this->getPathEffect()->filterPath(&effectPath, src, &width)) {
 81005:             path = &effectPath;
 81005:         }
 81005: 
 81005:         // restore the width if we earlier had to lie, and if we're still set to no-stroke
 81005:         // note: if we're now stroke (width >= 0), then the pathEffect asked for that change
 81005:         // and we want to respect that (i.e. don't overwrite their setting for width)
 81005:         if (this->getStyle() == SkPaint::kStrokeAndFill_Style && width < 0) {
 81005:             width = this->getStrokeWidth();
 81005:             if (width == 0) {
 81005:                 width = -1;
 81005:             }
 81005:         }
 81005:     }
 81005: 
 81005:     if (width > 0 && !path->isEmpty()) {
 81005:         SkStroke stroker(*this, width);
 81005:         stroker.strokePath(*path, &strokePath);
 81005:         path = &strokePath;
 81005:     }
 81005: 
 81005:     if (path == &src) {
 81005:         *dst = src;
 81005:     } else {
 81005:         SkASSERT(path == &effectPath || path == &strokePath);
 81005:         dst->swap(*(SkPath*)path);
 81005:     }
 81005: 
 81005:     return width != 0;  // return true if we're filled, or false if we're hairline (width == 0)
 81005: }
 81005: 
 99650: const SkRect& SkPaint::doComputeFastBounds(const SkRect& origSrc,
 99650:                                            SkRect* storage,
 99650:                                            Style style) const {
 81005:     SkASSERT(storage);
 81005: 
 99650:     const SkRect* src = &origSrc;
 99650: 
 99650:     if (this->getLooper()) {
 99650:         SkASSERT(this->getLooper()->canComputeFastBounds(*this));
 99650:         this->getLooper()->computeFastBounds(*this, *src, storage);
 99650:         return *storage;
 99650:     }
 99650: 
 99650:     SkRect tmpSrc;
 99650:     if (this->getPathEffect()) {
 99650:         this->getPathEffect()->computeFastBounds(&tmpSrc, origSrc);
 99650:         src = &tmpSrc;
 99650:     }
 99650: 
 99650:     if (kFill_Style != style) {
 81005:         // since we're stroked, outset the rect by the radius (and join type)
 81005:         SkScalar radius = SkScalarHalf(this->getStrokeWidth());
 81005:         if (0 == radius) {  // hairline
 81005:             radius = SK_Scalar1;
 81005:         } else if (this->getStrokeJoin() == SkPaint::kMiter_Join) {
 81005:             SkScalar scale = this->getStrokeMiter();
 81005:             if (scale > SK_Scalar1) {
 81005:                 radius = SkScalarMul(radius, scale);
 81005:             }
 81005:         }
 99650:         storage->set(src->fLeft - radius, src->fTop - radius,
 99650:                      src->fRight + radius, src->fBottom + radius);
 99650:     } else {
 99650:         *storage = *src;
 99650:     }
 99650: 
 99650:     if (this->getMaskFilter()) {
 99650:         this->getMaskFilter()->computeFastBounds(*storage, storage);
 99650:     }
 99650: 
 81005:     return *storage;
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: static bool has_thick_frame(const SkPaint& paint) {
 81005:     return  paint.getStrokeWidth() > 0 &&
 81005:             paint.getStyle() != SkPaint::kFill_Style;
 81005: }
 81005: 
 81005: SkTextToPathIter::SkTextToPathIter( const char text[], size_t length,
 81005:                                     const SkPaint& paint,
101753:                                     bool applyStrokeAndPathEffects)
 99650:                                     : fPaint(paint) {
 81005:     fGlyphCacheProc = paint.getMeasureCacheProc(SkPaint::kForward_TextBufferDirection,
 81005:                                                 true);
 81005: 
 81005:     fPaint.setLinearText(true);
 81005:     fPaint.setMaskFilter(NULL);   // don't want this affecting our path-cache lookup
 81005: 
 81005:     if (fPaint.getPathEffect() == NULL && !has_thick_frame(fPaint)) {
 81005:         applyStrokeAndPathEffects = false;
 81005:     }
 81005: 
 99650:     // can't use our canonical size if we need to apply patheffects
101753:     if (fPaint.getPathEffect() == NULL) {
 81005:         fPaint.setTextSize(SkIntToScalar(SkPaint::kCanonicalTextSizeForPaths));
 81005:         fScale = paint.getTextSize() / SkPaint::kCanonicalTextSizeForPaths;
 99650:         if (has_thick_frame(fPaint)) {
 99650:             fPaint.setStrokeWidth(SkScalarDiv(fPaint.getStrokeWidth(), fScale));
 99650:         }
 81005:     } else {
 81005:         fScale = SK_Scalar1;
 81005:     }
 81005: 
 81005:     if (!applyStrokeAndPathEffects) {
 81005:         fPaint.setStyle(SkPaint::kFill_Style);
 81005:         fPaint.setPathEffect(NULL);
 81005:     }
 81005: 
 81005:     fCache = fPaint.detachCache(NULL);
 81005: 
 81005:     SkPaint::Style  style = SkPaint::kFill_Style;
 81005:     SkPathEffect*   pe = NULL;
 81005: 
 81005:     if (!applyStrokeAndPathEffects) {
 81005:         style = paint.getStyle();   // restore
 81005:         pe = paint.getPathEffect();     // restore
 81005:     }
 81005:     fPaint.setStyle(style);
 81005:     fPaint.setPathEffect(pe);
 81005:     fPaint.setMaskFilter(paint.getMaskFilter());    // restore
 81005: 
 81005:     // now compute fXOffset if needed
 81005: 
 81005:     SkScalar xOffset = 0;
 81005:     if (paint.getTextAlign() != SkPaint::kLeft_Align) { // need to measure first
 81005:         int      count;
 81005:         SkScalar width = SkScalarMul(fPaint.measure_text(fCache, text, length,
 81005:                                                          &count, NULL), fScale);
 81005:         if (paint.getTextAlign() == SkPaint::kCenter_Align) {
 81005:             width = SkScalarHalf(width);
 81005:         }
 81005:         xOffset = -width;
 81005:     }
 81005:     fXPos = xOffset;
 81005:     fPrevAdvance = 0;
 81005: 
 81005:     fText = text;
 81005:     fStop = text + length;
 87682:     
 87682:     fXYIndex = paint.isVerticalText() ? 1 : 0;
 81005: }
 81005: 
 81005: SkTextToPathIter::~SkTextToPathIter() {
 81005:     SkGlyphCache::AttachCache(fCache);
 81005: }
 81005: 
 81005: const SkPath* SkTextToPathIter::next(SkScalar* xpos) {
101753:     while (fText < fStop) {
 81005:         const SkGlyph& glyph = fGlyphCacheProc(fCache, &fText);
 81005: 
 81005:         fXPos += SkScalarMul(SkFixedToScalar(fPrevAdvance + fAutoKern.adjust(glyph)), fScale);
 87682:         fPrevAdvance = advance(glyph, fXYIndex);   // + fPaint.getTextTracking();
 81005: 
 81005:         if (glyph.fWidth) {
 81005:             if (xpos) {
 81005:                 *xpos = fXPos;
 81005:             }
101753:             return fCache->findPath(glyph);
 81005:         }
 81005:     }
101753:     return NULL;
 81005: }
 81005: 
 81005: ///////////////////////////////////////////////////////////////////////////////
 81005: 
 81005: bool SkPaint::nothingToDraw() const {
 81005:     if (fLooper) {
 81005:         return false;
 81005:     }
 81005:     SkXfermode::Mode mode;
 81005:     if (SkXfermode::AsMode(fXfermode, &mode)) {
 81005:         switch (mode) {
 81005:             case SkXfermode::kSrcOver_Mode:
 81005:             case SkXfermode::kSrcATop_Mode:
 81005:             case SkXfermode::kDstOut_Mode:
 81005:             case SkXfermode::kDstOver_Mode:
 81005:             case SkXfermode::kPlus_Mode:
 81005:                 return 0 == this->getAlpha();
 81005:             case SkXfermode::kDst_Mode:
 81005:                 return true;
 81005:             default:
 81005:                 break;
 81005:         }
 81005:     }
 81005:     return false;
 81005: }
 81005: 
 81005: 
 87682: //////////// Move these to their own file soon.
 87682: 
 87682: bool SkImageFilter::filterImage(Proxy* proxy, const SkBitmap& src,
 87682:                                 const SkMatrix& ctm,
 87682:                                 SkBitmap* result, SkIPoint* loc) {
 87682:     SkASSERT(proxy);
 87682:     SkASSERT(result);
 87682:     SkASSERT(loc);
 87682:     /*
 87682:      *  Give the proxy first shot at the filter. If it returns false, ask
 87682:      *  the filter to do it.
 87682:      */
 87682:     return proxy->filterImage(this, src, ctm, result, loc) ||
 87682:            this->onFilterImage(proxy, src, ctm, result, loc);
 87682: }
 87682: 
 87682: bool SkImageFilter::filterBounds(const SkIRect& src, const SkMatrix& ctm,
 87682:                                  SkIRect* dst) {
 87682:     SkASSERT(&src);
 87682:     SkASSERT(dst);
 87682:     return this->onFilterBounds(src, ctm, dst);
 87682: }
 87682: 
 87682: bool SkImageFilter::onFilterImage(Proxy*, const SkBitmap&, const SkMatrix&,
 87682:                                   SkBitmap*, SkIPoint*) {
 87682:     return false;
 87682: }
 87682: 
 87682: bool SkImageFilter::onFilterBounds(const SkIRect& src, const SkMatrix& ctm,
 87682:                                    SkIRect* dst) {
 87682:     *dst = src;
 87682:     return true;
 87682: }
 87682: 
 87682: bool SkImageFilter::asABlur(SkSize* sigma) const {
 87682:     return false;
 87682: }
 87682: 
 99650: bool SkImageFilter::asAnErode(SkISize* radius) const {
 99650:     return false;
 99650: }
 99650: 
 99650: bool SkImageFilter::asADilate(SkISize* radius) const {
 99650:     return false;
 99650: }
 99650: 
 99650: //////
 99650: 
 99650: bool SkDrawLooper::canComputeFastBounds(const SkPaint& paint) {
 99650:     SkCanvas canvas;
 99650: 
 99650:     this->init(&canvas);
 99650:     for (;;) {
 99650:         SkPaint p(paint);
 99650:         if (this->next(&canvas, &p)) {
 99650:             p.setLooper(NULL);
 99650:             if (!p.canComputeFastBounds()) {
 99650:                 return false;
 99650:             }
 99650:         } else {
 99650:             break;
 99650:         }
 99650:     }
 99650:     return true;
 99650: }
 99650: 
 99650: void SkDrawLooper::computeFastBounds(const SkPaint& paint, const SkRect& src,
 99650:                                      SkRect* dst) {
 99650:     SkCanvas canvas;
 99650:     
 99650:     this->init(&canvas);
 99650:     for (bool firstTime = true;; firstTime = false) {
 99650:         SkPaint p(paint);
 99650:         if (this->next(&canvas, &p)) {
 99650:             SkRect r(src);
 99650: 
 99650:             p.setLooper(NULL);
 99650:             p.computeFastBounds(r, &r);
 99650:             canvas.getTotalMatrix().mapRect(&r);
 99650: 
 99650:             if (firstTime) {
 99650:                 *dst = r;
 99650:             } else {
 99650:                 dst->join(r);
 99650:             }
 99650:         } else {
 99650:             break;
 99650:         }
 99650:     }
 99650: }
 99650: 
