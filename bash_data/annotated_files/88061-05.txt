82761: /* -*- Mode: Java; c-basic-offset: 4; tab-width: 4; indent-tabs-mode: nil; -*-
82761:  * ***** BEGIN LICENSE BLOCK *****
82761:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
82761:  *
82761:  * The contents of this file are subject to the Mozilla Public License Version
82761:  * 1.1 (the "License"); you may not use this file except in compliance with
82761:  * the License. You may obtain a copy of the License at
82761:  * http://www.mozilla.org/MPL/
82761:  *
82761:  * Software distributed under the License is distributed on an "AS IS" basis,
82761:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
82761:  * for the specific language governing rights and limitations under the
82761:  * License.
82761:  *
82761:  * The Original Code is Mozilla Android code.
82761:  *
82761:  * The Initial Developer of the Original Code is Mozilla Foundation.
82761:  * Portions created by the Initial Developer are Copyright (C) 2011
82761:  * the Initial Developer. All Rights Reserved.
82761:  *
82761:  * Contributor(s):
82761:  *   Mounir Lamouri <mounir.lamouri@mozilla.com> (Original Author)
82761:  *
82761:  * Alternatively, the contents of this file may be used under the terms of
82761:  * either the GNU General Public License Version 2 or later (the "GPL"), or
82761:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
82761:  * in which case the provisions of the GPL or the LGPL are applicable instead
82761:  * of those above. If you wish to allow use of your version of this file only
82761:  * under the terms of either the GPL or the LGPL, and not to allow others to
82761:  * use your version of this file under the terms of the MPL, indicate your
82761:  * decision by deleting the provisions above and replace them with the notice
82761:  * and other provisions required by the GPL or the LGPL. If you do not delete
82761:  * the provisions above, a recipient may use your version of this file under
82761:  * the terms of any one of the MPL, the GPL or the LGPL.
82761:  *
82761:  * ***** END LICENSE BLOCK ***** */
82761: 
82761: package org.mozilla.gecko;
82761: 
82761: import java.util.ArrayList;
87552: import java.util.Iterator;
82761: 
82761: import android.util.Log;
82761: 
87552: import android.app.PendingIntent;
87552: import android.app.Activity;
87552: 
87552: import android.database.Cursor;
87552: 
82767: import android.content.Intent;
87554: import android.content.IntentFilter;
82767: import android.content.BroadcastReceiver;
82767: import android.content.Context;
87552: import android.content.ContentResolver;
87552: import android.content.ContentValues;
87552: import android.content.ContentUris;
87552: 
87552: import android.net.Uri;
82767: 
82767: import android.os.Bundle;
87552: import android.os.Handler;
87552: import android.os.Looper;
82767: 
82761: import android.telephony.SmsManager;
82767: import android.telephony.SmsMessage;
82761: 
87552: /**
87552:  * This class is returning unique ids for PendingIntent requestCode attribute.
87552:  * There are only |Integer.MAX_VALUE - Integer.MIN_VALUE| unique IDs available,
87552:  * and they wrap around.
87552:  */
87552: class PendingIntentUID
87552: {
87552:   static private int sUID = Integer.MIN_VALUE;
87552: 
87552:   static public int generate() { return sUID++; }
87552: }
87552: 
87552: /**
87552:  * The envelope class contains all information that are needed to keep track of
87552:  * a sent SMS.
87552:  */
87552: class Envelope
87552: {
87552:   enum SubParts {
87552:     SENT_PART,
87552:     DELIVERED_PART
87552:   }
87552: 
87552:   protected int       mId;
87552:   protected int       mMessageId;
87552:   protected long      mMessageTimestamp;
87552: 
87552:   /**
87552:    * Number of sent/delivered remaining parts.
87552:    * @note The array has much slots as SubParts items.
87552:    */
87552:   protected int[]     mRemainingParts;
87552: 
87552:   /**
87552:    * Whether sending/delivering is currently failing.
87552:    * @note The array has much slots as SubParts items.
87552:    */
87552:   protected boolean[] mFailing;
87552: 
87552:   /**
87552:    * Error type (only for sent).
87552:    */
87552:   protected int       mError;
87552: 
87552:   public Envelope(int aId, int aParts) {
87552:     mId = aId;
87552:     mMessageId = -1;
87552:     mMessageTimestamp = 0;
87552:     mError = GeckoSmsManager.kNoError;
87552: 
87552:     int size = Envelope.SubParts.values().length;
87552:     mRemainingParts = new int[size];
87552:     mFailing = new boolean[size];
87552: 
87552:     for (int i=0; i<size; ++i) {
87552:       mRemainingParts[i] = aParts;
87552:       mFailing[i] = false;
87552:     }
87552:   }
87552: 
87552:   public void decreaseRemainingParts(Envelope.SubParts aType) {
87552:     --mRemainingParts[aType.ordinal()];
87552: 
87552:     if (mRemainingParts[SubParts.SENT_PART.ordinal()] >
87552:         mRemainingParts[SubParts.DELIVERED_PART.ordinal()]) {
87552:       Log.e("GeckoSmsManager", "Delivered more parts than we sent!?");
87552:     }
87552:   }
87552: 
87552:   public boolean arePartsRemaining(Envelope.SubParts aType) {
87552:     return mRemainingParts[aType.ordinal()] != 0;
87552:   }
87552: 
87552:   public void markAsFailed(Envelope.SubParts aType) {
87552:     mFailing[aType.ordinal()] = true;
87552:   }
87552: 
87552:   public boolean isFailing(Envelope.SubParts aType) {
87552:     return mFailing[aType.ordinal()];
87552:   }
87552: 
87552:   public int getMessageId() {
87552:     return mMessageId;
87552:   }
87552: 
87552:   public void setMessageId(int aMessageId) {
87552:     mMessageId = aMessageId;
87552:   }
87552: 
87552:   public long getMessageTimestamp() {
87552:     return mMessageTimestamp;
87552:   }
87552: 
87552:   public void setMessageTimestamp(long aMessageTimestamp) {
87552:     mMessageTimestamp = aMessageTimestamp;
87552:   }
87552: 
87552:   public int getError() {
87552:     return mError;
87552:   }
87552: 
87552:   public void setError(int aError) {
87552:     mError = aError;
87552:   }
87552: }
87552: 
87552: /**
87552:  * Postman class is a singleton that manages Envelope instances.
87552:  */
87552: class Postman
87552: {
87552:   public static final int kUnknownEnvelopeId = -1;
87552: 
87552:   private static final Postman sInstance = new Postman();
87552: 
87552:   private ArrayList<Envelope> mEnvelopes = new ArrayList<Envelope>(1);
87552: 
87552:   private Postman() {}
87552: 
87552:   public static Postman getInstance() {
87552:     return sInstance;
87552:   }
87552: 
87552:   public int createEnvelope(int aParts) {
87552:     /*
87552:      * We are going to create the envelope in the first empty slot in the array
87552:      * list. If there is no empty slot, we create a new one.
87552:      */
87552:     int size = mEnvelopes.size();
87552: 
87552:     for (int i=0; i<size; ++i) {
87552:       if (mEnvelopes.get(i) == null) {
87552:         mEnvelopes.set(i, new Envelope(i, aParts));
87552:         return i;
87552:       }
87552:     }
87552: 
87552:     mEnvelopes.add(new Envelope(size, aParts));
87552:     return size;
87552:   }
87552: 
87552:   public Envelope getEnvelope(int aId) {
87552:     if (aId < 0 || mEnvelopes.size() <= aId) {
87552:       Log.e("GeckoSmsManager", "Trying to get an unknown Envelope!");
87552:       return null;
87552:     }
87552: 
87552:     Envelope envelope = mEnvelopes.get(aId);
87552:     if (envelope == null) {
87552:       Log.e("GeckoSmsManager", "Trying to get an empty Envelope!");
87552:     }
87552: 
87552:     return envelope;
87552:   }
87552: 
87552:   public void destroyEnvelope(int aId) {
87552:     if (aId < 0 || mEnvelopes.size() <= aId) {
87552:       Log.e("GeckoSmsManager", "Trying to destroy an unknown Envelope!");
87552:       return;
87552:     }
87552: 
87552:     if (mEnvelopes.set(aId, null) == null) {
87552:       Log.e("GeckoSmsManager", "Trying to destroy an empty Envelope!");
87552:     }
87552:   }
87552: }
87552: 
87552: class SmsIOThread extends Thread {
87552:   private final static SmsIOThread sInstance = new SmsIOThread();
87552: 
87552:   private Handler mHandler;
87552: 
87552:   public static SmsIOThread getInstance() {
87552:     return sInstance;
87552:   }
87552: 
87552:   public boolean execute(Runnable r) {
87552:     return mHandler.post(r);
87552:   }
87552: 
87552:   public void run() {
87552:     Looper.prepare();
87552: 
87552:     mHandler = new Handler();
87552: 
87552:     Looper.loop();
87552:   }
87552: }
87552: 
87552: class MessagesListManager
87552: {
87552:   private static final MessagesListManager sInstance = new MessagesListManager();
87552: 
87552:   public static MessagesListManager getInstance() {
87552:     return sInstance;
87552:   }
87552: 
87552:   private ArrayList<Cursor> mCursors = new ArrayList<Cursor>(0);
87552: 
87552:   public int add(Cursor aCursor) {
87552:     int size = mCursors.size();
87552: 
87552:     for (int i=0; i<size; ++i) {
87552:       if (mCursors.get(i) == null) {
87552:         mCursors.set(i, aCursor);
87552:         return i;
87552:       }
87552:     }
87552: 
87552:     mCursors.add(aCursor);
87552:     return size;
87552:   }
87552: 
87552:   public Cursor get(int aId) {
87552:     if (aId < 0 || mCursors.size() <= aId) {
87552:       Log.e("GeckoSmsManager", "Trying to get an unknown list!");
87552:       return null;
87552:     }
87552: 
87552:     Cursor cursor = mCursors.get(aId);
87552:     if (cursor == null) {
87552:       Log.e("GeckoSmsManager", "Trying to get an empty list!");
87552:     }
87552: 
87552:     return cursor;
87552:   }
87552: 
87552:   public void remove(int aId) {
87552:     if (aId < 0 || mCursors.size() <= aId) {
87552:       Log.e("GeckoSmsManager", "Trying to destroy an unknown list!");
87552:       return;
87552:     }
87552: 
87552:     Cursor cursor = mCursors.set(aId, null);
87552:     if (cursor == null) {
87552:       Log.e("GeckoSmsManager", "Trying to destroy an empty list!");
87552:       return;
87552:     }
87552: 
87552:     cursor.close();
87552:   }
87552: 
87552:   public void clear() {
87552:     for (int i=0; i<mCursors.size(); ++i) {
87552:       Cursor c = mCursors.get(i);
87552:       if (c != null) {
87552:         c.close();
87552:       }
87552:     }
87552: 
87552:     mCursors.clear();
87552:   }
87552: }
87552: 
82761: public class GeckoSmsManager
82767:   extends BroadcastReceiver
87554:   implements ISmsManager
82761: {
87552:   public final static String ACTION_SMS_RECEIVED  = "android.provider.Telephony.SMS_RECEIVED";
87552:   public final static String ACTION_SMS_SENT      = "org.mozilla.gecko.SMS_SENT";
87552:   public final static String ACTION_SMS_DELIVERED = "org.mozilla.gecko.SMS_DELIVERED";
87552: 
87552:   /*
87552:    * Make sure that the following error codes are in sync with |ErrorType| in:
87552:    * dom/sms/src/Types.h
87552:    * The error code are owned by the DOM.
87552:    */
87552:   public final static int kNoError       = 0;
87552:   public final static int kNoSignalError = 1;
87552:   public final static int kNotFoundError = 2;
87552:   public final static int kUnknownError  = 3;
87552:   public final static int kInternalError = 4;
87552: 
87552:   private final static int kMaxMessageSize    = 160;
87552: 
87552:   private final static Uri kSmsContentUri     = Uri.parse("content://sms");
87552:   private final static Uri kSmsSentContentUri = Uri.parse("content://sms/sent");
87552: 
87552:   private final static int kSmsTypeInbox      = 1;
87552:   private final static int kSmsTypeSentbox    = 2;
87552: 
87552:   /*
87552:    * Keep the following error codes in syng with |DeliveryState| in:
87552:    * dom/sms/src/Types.h
87552:    */
87552:   private final static int kDeliveryStateSent     = 0;
87552:   private final static int kDeliveryStateReceived = 1;
87552:   private final static int kDeliveryStateUnknown  = 2;
87552:   private final static int kDeliveryStateEndGuard = 3;
87552: 
87552:   private final static String[] kRequiredMessageRows = new String[] { "_id", "address", "body", "date", "type" };
87552: 
88061:   public GeckoSmsManager() {
88061:     SmsIOThread.getInstance().start();
88061:   }
88061: 
88061:   public void start() {
87554:     IntentFilter smsFilter = new IntentFilter();
87554:     smsFilter.addAction(GeckoSmsManager.ACTION_SMS_RECEIVED);
87554:     smsFilter.addAction(GeckoSmsManager.ACTION_SMS_SENT);
87554:     smsFilter.addAction(GeckoSmsManager.ACTION_SMS_DELIVERED);
87554: 
87554:     GeckoApp.mAppContext.registerReceiver(this, smsFilter);
87552:   }
82762: 
82767:   @Override
82767:   public void onReceive(Context context, Intent intent) {
87552:     if (intent.getAction().equals(ACTION_SMS_RECEIVED)) {
82767:       // TODO: Try to find the receiver number to be able to populate
82767:       //       SmsMessage.receiver.
82767:       // TODO: Get the id and the date from the stock app saved message.
82767:       //       Using the stock app saved message require us to wait for it to
82767:       //       be saved which can lead to race conditions.
82767: 
82767:       Bundle bundle = intent.getExtras();
82767: 
82767:       if (bundle == null) {
82767:         return;
82767:       }
82767: 
82767:       Object[] pdus = (Object[]) bundle.get("pdus");
82767: 
82767:       for (int i=0; i<pdus.length; ++i) {
82767:         SmsMessage msg = SmsMessage.createFromPdu((byte[])pdus[i]);
82767: 
82767:         GeckoAppShell.notifySmsReceived(msg.getDisplayOriginatingAddress(),
82767:                                         msg.getDisplayMessageBody(),
82767:                                         System.currentTimeMillis());
82767:       }
87552: 
87552:       return;
87552:     }
87552: 
87552:     if (intent.getAction().equals(ACTION_SMS_SENT) ||
87552:         intent.getAction().equals(ACTION_SMS_DELIVERED)) {
87552:       Bundle bundle = intent.getExtras();
87552: 
87552:       if (bundle == null || !bundle.containsKey("envelopeId") ||
87552:           !bundle.containsKey("number") || !bundle.containsKey("message") ||
87552:           !bundle.containsKey("requestId") || !bundle.containsKey("processId")) {
87552:         Log.e("GeckoSmsManager", "Got an invalid ACTION_SMS_SENT/ACTION_SMS_DELIVERED!");
87552:         return;
87552:       }
87552: 
87552:       int envelopeId = bundle.getInt("envelopeId");
87552:       Postman postman = Postman.getInstance();
87552: 
87552:       Envelope envelope = postman.getEnvelope(envelopeId);
87552:       if (envelope == null) {
87552:         Log.e("GeckoSmsManager", "Got an invalid envelope id (or Envelope has been destroyed)!");
87552:         return;
87552:       }
87552: 
87552:       Envelope.SubParts part = intent.getAction().equals(ACTION_SMS_SENT)
87552:                                  ? Envelope.SubParts.SENT_PART
87552:                                  : Envelope.SubParts.DELIVERED_PART;
87552:       envelope.decreaseRemainingParts(part);
87552:  
87552: 
87552:       if (getResultCode() != Activity.RESULT_OK) {
87552:         switch (getResultCode()) {
87552:           case SmsManager.RESULT_ERROR_NULL_PDU:
87552:             envelope.setError(kInternalError);
87552:             break;
87552:           case SmsManager.RESULT_ERROR_NO_SERVICE:
87552:           case SmsManager.RESULT_ERROR_RADIO_OFF:
87552:             envelope.setError(kNoSignalError);
87552:             break;
87552:           case SmsManager.RESULT_ERROR_GENERIC_FAILURE:
87552:           default:
87552:             envelope.setError(kUnknownError);
87552:             break;
87552:         }
87552:         envelope.markAsFailed(part);
87552:         Log.i("GeckoSmsManager", "SMS part sending failed!");
87552:       }
87552: 
87552:       if (envelope.arePartsRemaining(part)) {
87552:         return;
87552:       }
87552: 
87552:       if (envelope.isFailing(part)) {
87552:         if (part == Envelope.SubParts.SENT_PART) {
87552:           GeckoAppShell.notifySmsSendFailed(envelope.getError(),
87552:                                             bundle.getInt("requestId"),
87552:                                             bundle.getLong("processId"));
87552:           Log.i("GeckoSmsManager", "SMS sending failed!");
87552:         } else {
87552:           // It seems unlikely to get a result code for a failure to deliver.
87552:           // Even if, we don't want to do anything with this.
87552:           Log.e("GeckoSmsManager", "SMS failed to be delivered... is that even possible?");
87552:         }
87552:       } else {
87552:         if (part == Envelope.SubParts.SENT_PART) {
87552:           String number = bundle.getString("number");
87552:           String message = bundle.getString("message");
87552:           long timestamp = System.currentTimeMillis();
87552: 
87552:           int id = GeckoAppShell.saveMessageInSentbox(number, message, timestamp);
87552: 
87552:           GeckoAppShell.notifySmsSent(id, number, message, timestamp,
87552:                                       bundle.getInt("requestId"),
87552:                                       bundle.getLong("processId"));
87552: 
87552:           envelope.setMessageId(id);
87552:           envelope.setMessageTimestamp(timestamp);
87552: 
87552:           Log.i("GeckoSmsManager", "SMS sending was successfull!");
87552:         } else {
87552:           GeckoAppShell.notifySmsDelivered(envelope.getMessageId(),
87552:                                            bundle.getString("number"),
87552:                                            bundle.getString("message"),
87552:                                            envelope.getMessageTimestamp());
87552:           Log.i("GeckoSmsManager", "SMS succesfully delivered!");
87552:         }
87552:       }
87552: 
87552:       // Destroy the envelope object only if the SMS has been sent and delivered.
87552:       if (!envelope.arePartsRemaining(Envelope.SubParts.SENT_PART) &&
87552:           !envelope.arePartsRemaining(Envelope.SubParts.DELIVERED_PART)) {
87552:         postman.destroyEnvelope(envelopeId);
87552:       }
87552: 
87552:       return;
82767:     }
82767:   }
82767: 
87554:   public int getNumberOfMessagesForText(String aText) {
82761:     return SmsManager.getDefault().divideMessage(aText).size();
82761:   }
82762: 
87554:   public void send(String aNumber, String aMessage, int aRequestId, long aProcessId) {
87552:     int envelopeId = Postman.kUnknownEnvelopeId;
87552: 
82762:     try {
82762:       SmsManager sm = SmsManager.getDefault();
82762: 
87552:       Intent sentIntent = new Intent(ACTION_SMS_SENT);
87552:       Intent deliveredIntent = new Intent(ACTION_SMS_DELIVERED);
87552: 
87552:       Bundle bundle = new Bundle();
87552:       bundle.putString("number", aNumber);
87552:       bundle.putString("message", aMessage);
87552:       bundle.putInt("requestId", aRequestId);
87552:       bundle.putLong("processId", aProcessId);
87552: 
82762:       if (aMessage.length() <= kMaxMessageSize) {
87552:         envelopeId = Postman.getInstance().createEnvelope(1);
87552:         bundle.putInt("envelopeId", envelopeId);
87552: 
87552:         sentIntent.putExtras(bundle);
87552:         deliveredIntent.putExtras(bundle);
87552: 
87552:         /*
87552:          * There are a few things to know about getBroadcast and pending intents:
87552:          * - the pending intents are in a shared pool maintained by the system;
87552:          * - each pending intent is identified by a token;
87552:          * - when a new pending intent is created, if it has the same token as
87552:          *   another intent in the pool, one of them has to be removed.
87552:          *
87552:          * To prevent having a hard time because of this situation, we give a
87552:          * unique id to all pending intents we are creating. This unique id is
87552:          * generated by GetPendingIntentUID().
87552:          */
87552:         PendingIntent sentPendingIntent =
87552:           PendingIntent.getBroadcast(GeckoApp.mAppContext,
87552:                                      PendingIntentUID.generate(), sentIntent,
87552:                                      PendingIntent.FLAG_CANCEL_CURRENT);
87552: 
87552:         PendingIntent deliveredPendingIntent =
87552:           PendingIntent.getBroadcast(GeckoApp.mAppContext,
87552:                                      PendingIntentUID.generate(), deliveredIntent,
87552:                                      PendingIntent.FLAG_CANCEL_CURRENT);
87552: 
87552:         sm.sendTextMessage(aNumber, "", aMessage,
87552:                            sentPendingIntent, deliveredPendingIntent);
82762:       } else {
82762:         ArrayList<String> parts = sm.divideMessage(aMessage);
87552:         envelopeId = Postman.getInstance().createEnvelope(parts.size());
87552:         bundle.putInt("envelopeId", envelopeId);
87552: 
87552:         sentIntent.putExtras(bundle);
87552:         deliveredIntent.putExtras(bundle);
87552: 
87552:         ArrayList<PendingIntent> sentPendingIntents =
87552:           new ArrayList<PendingIntent>(parts.size());
87552:         ArrayList<PendingIntent> deliveredPendingIntents =
87552:           new ArrayList<PendingIntent>(parts.size());
87552: 
87552:         for (int i=0; i<parts.size(); ++i) {
87552:           sentPendingIntents.add(
87552:             PendingIntent.getBroadcast(GeckoApp.mAppContext,
87552:                                        PendingIntentUID.generate(), sentIntent,
87552:                                        PendingIntent.FLAG_CANCEL_CURRENT)
87552:           );
87552: 
87552:           deliveredPendingIntents.add(
87552:             PendingIntent.getBroadcast(GeckoApp.mAppContext,
87552:                                        PendingIntentUID.generate(), deliveredIntent,
87552:                                        PendingIntent.FLAG_CANCEL_CURRENT)
87552:           );
87552:         }
87552: 
87552:         sm.sendMultipartTextMessage(aNumber, "", parts, sentPendingIntents,
87552:                                     deliveredPendingIntents);
82761:       }
82762:     } catch (Exception e) {
87552:       Log.e("GeckoSmsManager", "Failed to send an SMS: ", e);
87552: 
87552:       if (envelopeId != Postman.kUnknownEnvelopeId) {
87552:         Postman.getInstance().destroyEnvelope(envelopeId);
82762:       }
87552: 
87552:       GeckoAppShell.notifySmsSendFailed(kUnknownError, aRequestId, aProcessId);
82762:     }
82762:   }
87552: 
87554:   public int saveSentMessage(String aRecipient, String aBody, long aDate) {
87552:     class IdTooHighException extends Exception { }
87552: 
87552:     try {
87552:       ContentValues values = new ContentValues();
87552:       values.put("address", aRecipient);
87552:       values.put("body", aBody);
87552:       values.put("date", aDate);
87552: 
87552:       ContentResolver cr = GeckoApp.mAppContext.getContentResolver();
87552:       Uri uri = cr.insert(kSmsSentContentUri, values);
87552: 
87552:       long id = ContentUris.parseId(uri);
87552: 
87552:       // The DOM API takes a 32bits unsigned int for the id. It's unlikely that
87552:       // we happen to need more than that but it doesn't cost to check.
87552:       if (id > Integer.MAX_VALUE) {
87552:         throw new IdTooHighException();
87552:       }
87552: 
87552:       return (int)id;
87552:     } catch (IdTooHighException e) {
87552:       Log.e("GeckoSmsManager", "The id we received is higher than the higher allowed value.");
87552:       return -1;
87552:     } catch (Exception e) {
87552:       Log.e("GeckoSmsManager", "Something went wrong when trying to write a sent message: " + e);
87552:       return -1;
87552:     }
87552:   }
87552: 
87554:   public void getMessage(int aMessageId, int aRequestId, long aProcessId) {
87552:     class GetMessageRunnable implements Runnable {
87552:       private int mMessageId;
87552:       private int mRequestId;
87552:       private long mProcessId;
87552: 
87552:       GetMessageRunnable(int aMessageId, int aRequestId, long aProcessId) {
87552:         mMessageId = aMessageId;
87552:         mRequestId = aRequestId;
87552:         mProcessId = aProcessId;
87552:       }
87552: 
87552:       @Override
87552:       public void run() {
87552:         class NotFoundException extends Exception { }
87552:         class UnmatchingIdException extends Exception { }
87552:         class TooManyResultsException extends Exception { }
87552:         class InvalidTypeException extends Exception { }
87552: 
87552:         Cursor cursor = null;
87552: 
87552:         try {
87552:           ContentResolver cr = GeckoApp.mAppContext.getContentResolver();
87552:           Uri message = ContentUris.withAppendedId(kSmsContentUri, mMessageId);
87552: 
87552:           cursor = cr.query(message, kRequiredMessageRows, null, null, null);
87552:           if (cursor == null || cursor.getCount() == 0) {
87552:             throw new NotFoundException();
87552:           }
87552: 
87552:           if (cursor.getCount() != 1) {
87552:             throw new TooManyResultsException();
87552:           }
87552: 
87552:           cursor.moveToFirst();
87552: 
87552:           if (cursor.getInt(cursor.getColumnIndex("_id")) != mMessageId) {
87552:             throw new UnmatchingIdException();
87552:           }
87552: 
87552:           int type = cursor.getInt(cursor.getColumnIndex("type"));
87552:           String sender = "";
87552:           String receiver = "";
87552: 
87552:           if (type == kSmsTypeInbox) {
87552:             sender = cursor.getString(cursor.getColumnIndex("address"));
87552:           } else if (type == kSmsTypeSentbox) {
87552:             receiver = cursor.getString(cursor.getColumnIndex("address"));
87552:           } else {
87552:             throw new InvalidTypeException();
87552:           }
87552: 
87552:           GeckoAppShell.notifyGetSms(cursor.getInt(cursor.getColumnIndex("_id")),
87552:                                      receiver, sender,
87552:                                      cursor.getString(cursor.getColumnIndex("body")),
87552:                                      cursor.getLong(cursor.getColumnIndex("date")),
87552:                                      mRequestId, mProcessId);
87552:         } catch (NotFoundException e) {
87552:           Log.i("GeckoSmsManager", "Message id " + mMessageId + " not found");
87552:           GeckoAppShell.notifyGetSmsFailed(kNotFoundError, mRequestId, mProcessId);
87552:         } catch (UnmatchingIdException e) {
87552:           Log.e("GeckoSmsManager", "Requested message id (" + mMessageId +
87552:                                    ") is different from the one we got.");
87552:           GeckoAppShell.notifyGetSmsFailed(kUnknownError, mRequestId, mProcessId);
87552:         } catch (TooManyResultsException e) {
87552:           Log.e("GeckoSmsManager", "Get too many results for id " + mMessageId);
87552:           GeckoAppShell.notifyGetSmsFailed(kUnknownError, mRequestId, mProcessId);
87552:         } catch (InvalidTypeException e) {
87552:           Log.i("GeckoSmsManager", "Message has an invalid type, we ignore it.");
87552:           GeckoAppShell.notifyGetSmsFailed(kNotFoundError, mRequestId, mProcessId);
87552:         } catch (Exception e) {
87552:           Log.e("GeckoSmsManager", "Error while trying to get message: " + e);
87552:           GeckoAppShell.notifyGetSmsFailed(kUnknownError, mRequestId, mProcessId);
87552:         } finally {
87552:           if (cursor != null) {
87552:             cursor.close();
87552:           }
87552:         }
87552:       }
87552:     }
87552: 
87552:     if (!SmsIOThread.getInstance().execute(new GetMessageRunnable(aMessageId, aRequestId, aProcessId))) {
87552:       Log.e("GeckoSmsManager", "Failed to add GetMessageRunnable to the SmsIOThread");
87552:       GeckoAppShell.notifyGetSmsFailed(kUnknownError, aRequestId, aProcessId);
87552:     }
87552:   }
87552: 
87554:   public void deleteMessage(int aMessageId, int aRequestId, long aProcessId) {
87552:     class DeleteMessageRunnable implements Runnable {
87552:       private int mMessageId;
87552:       private int mRequestId;
87552:       private long mProcessId;
87552: 
87552:       DeleteMessageRunnable(int aMessageId, int aRequestId, long aProcessId) {
87552:         mMessageId = aMessageId;
87552:         mRequestId = aRequestId;
87552:         mProcessId = aProcessId;
87552:       }
87552: 
87552:       @Override
87552:       public void run() {
87552:         class TooManyResultsException extends Exception { }
87552: 
87552:         try {
87552:           ContentResolver cr = GeckoApp.mAppContext.getContentResolver();
87552:           Uri message = ContentUris.withAppendedId(kSmsContentUri, mMessageId);
87552: 
87552:           int count = cr.delete(message, null, null);
87552: 
87552:           if (count > 1) {
87552:             throw new TooManyResultsException();
87552:           }
87552: 
87552:           GeckoAppShell.notifySmsDeleted(count == 1, mRequestId, mProcessId);
87552:         } catch (TooManyResultsException e) {
87552:           Log.e("GeckoSmsManager", "Delete more than one message? " + e);
87552:           GeckoAppShell.notifySmsDeleteFailed(kUnknownError, mRequestId, mProcessId);
87552:         } catch (Exception e) {
87552:           Log.e("GeckoSmsManager", "Error while trying to delete a message: " + e);
87552:           GeckoAppShell.notifySmsDeleteFailed(kUnknownError, mRequestId, mProcessId);
87552:         }
87552:       }
87552:     }
87552: 
87552:     if (!SmsIOThread.getInstance().execute(new DeleteMessageRunnable(aMessageId, aRequestId, aProcessId))) {
87552:       Log.e("GeckoSmsManager", "Failed to add GetMessageRunnable to the SmsIOThread");
87552:       GeckoAppShell.notifySmsDeleteFailed(kUnknownError, aRequestId, aProcessId);
87552:     }
87552:   }
87552: 
87554:   public void createMessageList(long aStartDate, long aEndDate, String[] aNumbers, int aNumbersCount, int aDeliveryState, boolean aReverse, int aRequestId, long aProcessId) {
87552:     class CreateMessageListRunnable implements Runnable {
87552:       private long     mStartDate;
87552:       private long     mEndDate;
87552:       private String[] mNumbers;
87552:       private int      mNumbersCount;
87552:       private int      mDeliveryState;
87552:       private boolean  mReverse;
87552:       private int      mRequestId;
87552:       private long     mProcessId;
87552: 
87552:       CreateMessageListRunnable(long aStartDate, long aEndDate, String[] aNumbers, int aNumbersCount, int aDeliveryState, boolean aReverse, int aRequestId, long aProcessId) {
87552:         mStartDate = aStartDate;
87552:         mEndDate = aEndDate;
87552:         mNumbers = aNumbers;
87552:         mNumbersCount = aNumbersCount;
87552:         mDeliveryState = aDeliveryState;
87552:         mReverse = aReverse;
87552:         mRequestId = aRequestId;
87552:         mProcessId = aProcessId;
87552:       }
87552: 
87552:       @Override
87552:       public void run() {
87552:         class UnexpectedDeliveryStateException extends Exception { };
87552:         class InvalidTypeException extends Exception { }
87552: 
87552:         Cursor cursor = null;
87552:         boolean closeCursor = true;
87552: 
87552:         try {
87552:           // TODO: should use the |selectionArgs| argument in |ContentResolver.query()|.
87552:           ArrayList<String> restrictions = new ArrayList<String>();
87552: 
87552:           if (mStartDate != 0) {
87552:             restrictions.add("date >= " + mStartDate);
87552:           }
87552: 
87552:           if (mEndDate != 0) {
87552:             restrictions.add("date <= " + mEndDate);
87552:           }
87552: 
87552:           if (mNumbersCount > 0) {
87552:             String numberRestriction = "address IN ('" + mNumbers[0] + "'";
87552: 
87552:             for (int i=1; i<mNumbersCount; ++i) {
87552:               numberRestriction += ", '" + mNumbers[i] + "'";
87552:             }
87552:             numberRestriction += ")";
87552: 
87552:             restrictions.add(numberRestriction);
87552:           }
87552: 
87552:           if (mDeliveryState == kDeliveryStateUnknown) {
87552:             restrictions.add("type IN ('" + kSmsTypeSentbox + "', '" + kSmsTypeInbox + "')");
87552:           } else if (mDeliveryState == kDeliveryStateSent) {
87552:             restrictions.add("type = " + kSmsTypeSentbox);
87552:           } else if (mDeliveryState == kDeliveryStateReceived) {
87552:             restrictions.add("type = " + kSmsTypeInbox);
87552:           } else {
87552:             throw new UnexpectedDeliveryStateException();
87552:           }
87552: 
87552:           String restrictionText = restrictions.size() > 0 ? restrictions.get(0) : "";
87552: 
87552:           for (int i=1; i<restrictions.size(); ++i) {
87552:             restrictionText += " AND " + restrictions.get(i);
87552:           }
87552: 
87552:           ContentResolver cr = GeckoApp.mAppContext.getContentResolver();
87552:           cursor = cr.query(kSmsContentUri, kRequiredMessageRows, restrictionText, null,
87552:                             mReverse ? "date DESC" : "date ASC");
87552: 
87552:           if (cursor.getCount() == 0) {
87552:             GeckoAppShell.notifyNoMessageInList(mRequestId, mProcessId);
87552:             return;
87552:           }
87552: 
87552:           cursor.moveToFirst();
87552: 
87552:           int type = cursor.getInt(cursor.getColumnIndex("type"));
87552:           String sender = "";
87552:           String receiver = "";
87552: 
87552:           if (type == kSmsTypeInbox) {
87552:             sender = cursor.getString(cursor.getColumnIndex("address"));
87552:           } else if (type == kSmsTypeSentbox) {
87552:             receiver = cursor.getString(cursor.getColumnIndex("address"));
87552:           } else {
87552:             throw new UnexpectedDeliveryStateException();
87552:           }
87552: 
87552:           int listId = MessagesListManager.getInstance().add(cursor);
87552:           closeCursor = false;
87552:           GeckoAppShell.notifyListCreated(listId,
87552:                                           cursor.getInt(cursor.getColumnIndex("_id")),
87552:                                           receiver, sender,
87552:                                           cursor.getString(cursor.getColumnIndex("body")),
87552:                                           cursor.getLong(cursor.getColumnIndex("date")),
87552:                                           mRequestId, mProcessId);
87552:         } catch (UnexpectedDeliveryStateException e) {
87552:           Log.e("GeckoSmsManager", "Unexcepted delivery state type: " + e);
87552:           GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, mRequestId, mProcessId);
87552:         } catch (Exception e) {
87552:           Log.e("GeckoSmsManager", "Error while trying to create a message list cursor: " + e);
87552:           GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, mRequestId, mProcessId);
87552:         } finally {
87552:           // Close the cursor if MessagesListManager isn't taking care of it.
87552:           // We could also just check if it is in the MessagesListManager list but
87552:           // that would be less efficient.
87552:           if (cursor != null && closeCursor) {
87552:             cursor.close();
87552:           }
87552:         }
87552:       }
87552:     }
87552: 
87552:     if (!SmsIOThread.getInstance().execute(new CreateMessageListRunnable(aStartDate, aEndDate, aNumbers, aNumbersCount, aDeliveryState, aReverse, aRequestId, aProcessId))) {
87552:       Log.e("GeckoSmsManager", "Failed to add CreateMessageListRunnable to the SmsIOThread");
87552:       GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, aRequestId, aProcessId);
87552:     }
87552:   }
87552: 
87554:   public void getNextMessageInList(int aListId, int aRequestId, long aProcessId) {
87552:     class GetNextMessageInListRunnable implements Runnable {
87552:       private int mListId;
87552:       private int mRequestId;
87552:       private long mProcessId;
87552: 
87552:       GetNextMessageInListRunnable(int aListId, int aRequestId, long aProcessId) {
87552:         mListId = aListId;
87552:         mRequestId = aRequestId;
87552:         mProcessId = aProcessId;
87552:       }
87552: 
87552:       @Override
87552:       public void run() {
87552:         class UnexpectedDeliveryStateException extends Exception { };
87552: 
87552:         try {
87552:           Cursor cursor = MessagesListManager.getInstance().get(mListId);
87552: 
87552:           if (!cursor.moveToNext()) {
87552:             MessagesListManager.getInstance().remove(mListId);
87552:             GeckoAppShell.notifyNoMessageInList(mRequestId, mProcessId);
87552:             return;
87552:           }
87552: 
87552:           int type = cursor.getInt(cursor.getColumnIndex("type"));
87552:           String sender = "";
87552:           String receiver = "";
87552: 
87552:           if (type == kSmsTypeInbox) {
87552:             sender = cursor.getString(cursor.getColumnIndex("address"));
87552:           } else if (type == kSmsTypeSentbox) {
87552:             receiver = cursor.getString(cursor.getColumnIndex("address"));
87552:           } else {
87552:             throw new UnexpectedDeliveryStateException();
87552:           }
87552: 
87552:           int listId = MessagesListManager.getInstance().add(cursor);
87552:           GeckoAppShell.notifyGotNextMessage(cursor.getInt(cursor.getColumnIndex("_id")),
87552:                                              receiver, sender,
87552:                                              cursor.getString(cursor.getColumnIndex("body")),
87552:                                              cursor.getLong(cursor.getColumnIndex("date")),
87552:                                              mRequestId, mProcessId);
87552:         } catch (UnexpectedDeliveryStateException e) {
87552:           Log.e("GeckoSmsManager", "Unexcepted delivery state type: " + e);
87552:           GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, mRequestId, mProcessId);
87552:         } catch (Exception e) {
87552:           Log.e("GeckoSmsManager", "Error while trying to get the next message of a list: " + e);
87552:           GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, mRequestId, mProcessId);
87552:         }
87552:       }
87552:     }
87552: 
87552:     if (!SmsIOThread.getInstance().execute(new GetNextMessageInListRunnable(aListId, aRequestId, aProcessId))) {
87552:       Log.e("GeckoSmsManager", "Failed to add GetNextMessageInListRunnable to the SmsIOThread");
87552:       GeckoAppShell.notifyReadingMessageListFailed(kUnknownError, aRequestId, aProcessId);
87552:     }
87552:   }
87552: 
87554:   public void clearMessageList(int aListId) {
87552:     MessagesListManager.getInstance().remove(aListId);
87552:   }
87552: 
88061:   public void stop() {
88061:     GeckoApp.mAppContext.unregisterReceiver(this);
88061:   }
88061: 
87554:   public void shutdown() {
87552:     SmsIOThread.getInstance().interrupt();
87552:     MessagesListManager.getInstance().clear();
87552:   }
87552: }
