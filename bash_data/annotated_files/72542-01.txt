50525: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
50525: /* ***** BEGIN LICENSE BLOCK *****
50525:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
50525:  *
50525:  * The contents of this file are subject to the Mozilla Public License Version
50525:  * 1.1 (the "License"); you may not use this file except in compliance with
50525:  * the License. You may obtain a copy of the License at
50525:  * http://www.mozilla.org/MPL/
50525:  *
50525:  * Software distributed under the License is distributed on an "AS IS" basis,
50525:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
50525:  * for the specific language governing rights and limitations under the
50525:  * License.
50525:  *
50525:  * The Original Code is mozilla.org code.
50525:  *
50525:  * The Initial Developer of the Original Code is
50525:  * Mozilla Foundation.
50525:  * Portions created by the Initial Developer are Copyright (C) 2010
50525:  * the Initial Developer. All Rights Reserved.
50525:  *
50525:  * Contributor(s):
51578:  *   Jonathan Griffin <jgriffin@mozilla.com>
50525:  *
50525:  * Alternatively, the contents of this file may be used under the terms of
50525:  * either the GNU General Public License Version 2 or later (the "GPL"), or
50525:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
50525:  * in which case the provisions of the GPL or the LGPL are applicable instead
50525:  * of those above. If you wish to allow use of your version of this file only
50525:  * under the terms of either the GPL or the LGPL, and not to allow others to
50525:  * use your version of this file under the terms of the MPL, indicate your
50525:  * decision by deleting the provisions above and replace them with the notice
50525:  * and other provisions required by the GPL or the LGPL. If you do not delete
50525:  * the provisions above, a recipient may use your version of this file under
50525:  * the terms of any one of the MPL, the GPL or the LGPL.
50525:  *
50525:  * ***** END LICENSE BLOCK ***** */
50525: 
51578: #include <windows.h>
61175: #include <setupapi.h>
50525: #include "gfxWindowsPlatform.h"
50525: #include "GfxInfo.h"
59414: #include "GfxInfoWebGL.h"
51578: #include "nsUnicharUtils.h"
55059: #include "nsPrintfCString.h"
51578: #include "mozilla/FunctionTimer.h"
56956: #include "prenv.h"
56956: #include "prprf.h"
60890: #include "GfxDriverInfo.h"
72430: #include "mozilla/Preferences.h"
50525: 
70361: #if defined(MOZ_CRASHREPORTER)
51579: #include "nsExceptionHandler.h"
51579: #include "nsICrashReporter.h"
51579: #define NS_CRASHREPORTER_CONTRACTID "@mozilla.org/toolkit/crash-reporter;1"
51579: #endif
51579: 
51579: 
50525: using namespace mozilla::widget;
50525: 
60896: #ifdef DEBUG
60896: NS_IMPL_ISUPPORTS_INHERITED1(GfxInfo, GfxInfoBase, nsIGfxInfoDebug)
60896: #endif
60896: 
61025: static const PRUint32 allWindowsVersions = 0xffffffff;
61025: static const PRUint64 allDriverVersions = 0xffffffffffffffffULL;
61025: 
61025: static const PRUint32 vendorIntel = 0x8086;
61025: 
61594: static const PRUint32 vendorNVIDIA = 0x10de;
61594: 
61594: static const PRUint32 vendorAMD = 0x1022;
61594: static const PRUint32 vendorATI = 0x1002;
61594: 
61025: #define V(a,b,c,d) GFX_DRIVER_VERSION(a,b,c,d)
61025: 
61025: 
60895: GfxInfo::GfxInfo()
60895:   : mAdapterVendorID(0),
60896:     mAdapterDeviceID(0),
60896:     mWindowsVersion(0)
60895: {
60895: }
60895: 
51677: /* GetD2DEnabled and GetDwriteEnabled shouldn't be called until after gfxPlatform initialization
51677:  * has occurred because they depend on it for information. (See bug 591561) */
51736: nsresult
51736: GfxInfo::GetD2DEnabled(PRBool *aEnabled)
50525: {
50525:   *aEnabled = gfxWindowsPlatform::GetPlatform()->GetRenderMode() == gfxWindowsPlatform::RENDER_DIRECT2D;
50525:   return NS_OK;
50525: }
50655: 
51736: nsresult
51736: GfxInfo::GetDWriteEnabled(PRBool *aEnabled)
50655: {
50655:   *aEnabled = gfxWindowsPlatform::GetPlatform()->DWriteEnabled();
50655:   return NS_OK;
50655: }
51578: 
72430: nsresult
72430: GfxInfo::GetAzureEnabled(PRBool *aEnabled)
72430: {
72430:   *aEnabled = PR_FALSE;
72430: 
72430:   PRBool d2dEnabled = 
72430:     gfxWindowsPlatform::GetPlatform()->GetRenderMode() == gfxWindowsPlatform::RENDER_DIRECT2D;
72430: 
72430:   if (d2dEnabled) {
72430:     PRBool azure = PR_FALSE;
72430:     nsresult rv = mozilla::Preferences::GetBool("gfx.canvas.azure.enabled", &azure);
72430: 
72430:     if (NS_SUCCEEDED(rv) && azure) {
72430:       *aEnabled = PR_TRUE;
72430:     }
72430:   }
72430: 
72430:   return NS_OK;
72430: }
72430: 
60493: /* readonly attribute DOMString DWriteVersion; */
60493: NS_IMETHODIMP
60493: GfxInfo::GetDWriteVersion(nsAString & aDwriteVersion)
60493: {
69151:   gfxWindowsPlatform::GetDLLVersion(L"dwrite.dll", aDwriteVersion);
60493:   return NS_OK;
60493: }
60493: 
69664: #define PIXEL_STRUCT_RGB  1
69664: #define PIXEL_STRUCT_BGR  2
69664: 
69664: /* readonly attribute DOMString cleartypeParameters; */
69664: NS_IMETHODIMP
69664: GfxInfo::GetCleartypeParameters(nsAString & aCleartypeParams)
69664: {
69664:   nsTArray<ClearTypeParameterInfo> clearTypeParams;
69664: 
69664:   gfxWindowsPlatform::GetPlatform()->GetCleartypeParams(clearTypeParams);
69664:   PRUint32 d, numDisplays = clearTypeParams.Length();
69664:   bool displayNames = (numDisplays > 1);
69664:   bool foundData = false;
69664:   nsString outStr;
69664:   WCHAR valStr[256];
69664: 
69664:   for (d = 0; d < numDisplays; d++) {
69664:     ClearTypeParameterInfo& params = clearTypeParams[d];
69664: 
69664:     if (displayNames) {
69664:       swprintf_s(valStr, NS_ARRAY_LENGTH(valStr),
69664:                  L"%s [ ", params.displayName.get());
69664:       outStr.Append(valStr);
69664:     }
69664: 
69664:     if (params.gamma >= 0) {
69664:       foundData = true;
69664:       swprintf_s(valStr, NS_ARRAY_LENGTH(valStr),
69664:                  L"Gamma: %d ", params.gamma);
69664:       outStr.Append(valStr);
69664:     }
69664: 
69664:     if (params.pixelStructure >= 0) {
69664:       foundData = true;
69664:       if (params.pixelStructure == PIXEL_STRUCT_RGB ||
69664:           params.pixelStructure == PIXEL_STRUCT_BGR)
69664:       {
69664:         swprintf_s(valStr, NS_ARRAY_LENGTH(valStr),
69664:                    L"Pixel Structure: %s ",
69664:                    (params.pixelStructure == PIXEL_STRUCT_RGB ?
69664:                       L"RGB" : L"BGR"));
69664:       } else {
69664:         swprintf_s(valStr, NS_ARRAY_LENGTH(valStr),
69664:                    L"Pixel Structure: %d ", params.pixelStructure);
69664:       }
69664:       outStr.Append(valStr);
69664:     }
69664: 
69664:     if (params.clearTypeLevel >= 0) {
69664:       foundData = true;
69664:       swprintf_s(valStr, NS_ARRAY_LENGTH(valStr),
69664:                  L"ClearType Level: %d ", params.clearTypeLevel);
69664:       outStr.Append(valStr);
69664:     }
69664: 
69664:     if (params.enhancedContrast >= 0) {
69664:       foundData = true;
69664:       swprintf_s(valStr, NS_ARRAY_LENGTH(valStr),
69664:                  L"Enhanced Contrast: %d ", params.enhancedContrast);
69664:       outStr.Append(valStr);
69664:     }
69664: 
69664:     if (displayNames) {
69664:       outStr.Append(L"] ");
69664:     }
69664:   }
69664: 
69664:   if (foundData) {
69664:     aCleartypeParams.Assign(outStr);
69664:     return NS_OK;
69664:   }
69664:   return NS_ERROR_FAILURE;
69664: }
69664: 
51578: /* XXX: GfxInfo doesn't handle multiple GPUs. We should try to do that. Bug #591057 */
51578: 
54670: static nsresult GetKeyValue(const WCHAR* keyLocation, const WCHAR* keyName, nsAString& destString, int type)
51578: {
51578:   HKEY key;
51578:   DWORD dwcbData;
51578:   DWORD dValue;
51676:   DWORD resultType;
51578:   LONG result;
51578:   nsresult retval = NS_OK;
51578: 
51578:   result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, keyLocation, 0, KEY_QUERY_VALUE, &key);
51578:   if (result != ERROR_SUCCESS) {
51578:     return NS_ERROR_FAILURE;
51578:   }
51578: 
51578:   switch (type) {
51578:     case REG_DWORD: {
51578:       // We only use this for vram size
51578:       dwcbData = sizeof(dValue);
51676:       result = RegQueryValueExW(key, keyName, NULL, &resultType, (LPBYTE)&dValue, &dwcbData);
51676:       if (result == ERROR_SUCCESS && resultType == REG_DWORD) {
51676:         dValue = dValue / 1024 / 1024;
54145:         destString.AppendInt(PRInt32(dValue));
51676:       } else {
51578:         retval = NS_ERROR_FAILURE;
51578:       }
51578:       break;
51578:     }
51578:     case REG_MULTI_SZ: {
51578:       // A chain of null-separated strings; we convert the nulls to spaces
51676:       WCHAR wCharValue[1024];
51676:       dwcbData = sizeof(wCharValue);
51676: 
51676:       result = RegQueryValueExW(key, keyName, NULL, &resultType, (LPBYTE)wCharValue, &dwcbData);
51676:       if (result == ERROR_SUCCESS && resultType == REG_MULTI_SZ) {
51676:         // This bit here could probably be cleaner.
51676:         bool isValid = false;
51676: 
51676:         DWORD strLen = dwcbData/sizeof(wCharValue[0]);
51676:         for (DWORD i = 0; i < strLen; i++) {
51676:           if (wCharValue[i] == '\0') {
51676:             if (i < strLen - 1 && wCharValue[i + 1] == '\0') {
51676:               isValid = true;
51676:               break;
51676:             } else {
51676:               wCharValue[i] = ' ';
51676:             }
51676:           }
51676:         }
51676: 
51676:         // ensure wCharValue is null terminated
51676:         wCharValue[strLen-1] = '\0';
51676: 
51676:         if (isValid)
51676:           destString = wCharValue;
51676: 
51676:       } else {
51578:         retval = NS_ERROR_FAILURE;
51578:       }
51676: 
51578:       break;
51578:     }
51578:   }
51578:   RegCloseKey(key);
51578: 
51578:   return retval;
51578: }
51578: 
51578: // The driver ID is a string like PCI\VEN_15AD&DEV_0405&SUBSYS_040515AD, possibly
51578: // followed by &REV_XXXX.  We uppercase the string, and strip the &REV_ part
51578: // from it, if found.
54670: static void normalizeDriverId(nsString& driverid) {
51578:   ToUpperCase(driverid);
51578:   PRInt32 rev = driverid.Find(NS_LITERAL_CSTRING("&REV_"));
51578:   if (rev != -1) {
51578:     driverid.Cut(rev, driverid.Length());
51578:   }
51578: }
51578: 
61175: // Setup API functions
61175: typedef HDEVINFO (WINAPI*SetupDiGetClassDevsWFunc)(
61175:   CONST GUID *ClassGuid,
61175:   PCWSTR Enumerator,
61175:   HWND hwndParent,
61175:   DWORD Flags
61175: );
61175: typedef BOOL (WINAPI*SetupDiEnumDeviceInfoFunc)(
61175:   HDEVINFO DeviceInfoSet,
61175:   DWORD MemberIndex,
61175:   PSP_DEVINFO_DATA DeviceInfoData
61175: );
61175: typedef BOOL (WINAPI*SetupDiGetDeviceRegistryPropertyWFunc)(
61175:   HDEVINFO DeviceInfoSet,
61175:   PSP_DEVINFO_DATA DeviceInfoData,
61175:   DWORD Property,
61175:   PDWORD PropertyRegDataType,
61175:   PBYTE PropertyBuffer,
61175:   DWORD PropertyBufferSize,
61175:   PDWORD RequiredSize
61175: );
61175: typedef BOOL (WINAPI*SetupDiDestroyDeviceInfoListFunc)(
61175:   HDEVINFO DeviceInfoSet
61175: );
61175: 
51578: 
51578: 
51578: /* Other interesting places for info:
51578:  *   IDXGIAdapter::GetDesc()
51578:  *   IDirectDraw7::GetAvailableVidMem()
51578:  *   e->GetAvailableTextureMem()
51578:  * */
51578: 
51578: #define DEVICE_KEY_PREFIX L"\\Registry\\Machine\\"
60893: nsresult
51736: GfxInfo::Init()
51578: {
51578:   NS_TIME_FUNCTION;
51578: 
60893:   nsresult rv = GfxInfoBase::Init();
60893: 
51676:   DISPLAY_DEVICEW displayDevice;
51676:   displayDevice.cb = sizeof(displayDevice);
51578:   int deviceIndex = 0;
51578: 
58229:   mDeviceKeyDebug = NS_LITERAL_STRING("PrimarySearch");
58229: 
51676:   while (EnumDisplayDevicesW(NULL, deviceIndex, &displayDevice, 0)) {
58229:     if (displayDevice.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) {
58229:       mDeviceKeyDebug = NS_LITERAL_STRING("NullSearch");
51578:       break;
58229:     }
51578:     deviceIndex++;
51578:   }
51578: 
51578:   // make sure the string is NULL terminated
51676:   if (wcsnlen(displayDevice.DeviceKey, NS_ARRAY_LENGTH(displayDevice.DeviceKey))
51676:       == NS_ARRAY_LENGTH(displayDevice.DeviceKey)) {
51578:     // we did not find a NULL
60893:     return rv;
51578:   }
51578: 
58229:   mDeviceKeyDebug = displayDevice.DeviceKey;
58229: 
58229:   /* DeviceKey is "reserved" according to MSDN so we'll be careful with it */
58229:   /* check that DeviceKey begins with DEVICE_KEY_PREFIX */
58229:   /* some systems have a DeviceKey starting with \REGISTRY\Machine\ so we need to compare case insenstively */
58229:   if (_wcsnicmp(displayDevice.DeviceKey, DEVICE_KEY_PREFIX, NS_ARRAY_LENGTH(DEVICE_KEY_PREFIX)-1) != 0)
60893:     return rv;
58229: 
51578:   // chop off DEVICE_KEY_PREFIX
51676:   mDeviceKey = displayDevice.DeviceKey + NS_ARRAY_LENGTH(DEVICE_KEY_PREFIX)-1;
51578: 
51676:   mDeviceID = displayDevice.DeviceID;
51676:   mDeviceString = displayDevice.DeviceString;
51578: 
51578: 
61175:   HMODULE setupapi = LoadLibraryW(L"setupapi.dll");
51578: 
61175:   if (setupapi) {
61175:     SetupDiGetClassDevsWFunc setupGetClassDevs = (SetupDiGetClassDevsWFunc)
61175:       GetProcAddress(setupapi, "SetupDiGetClassDevsW");
61175:     SetupDiEnumDeviceInfoFunc setupEnumDeviceInfo = (SetupDiEnumDeviceInfoFunc)
61175:       GetProcAddress(setupapi, "SetupDiEnumDeviceInfo");
61175:     SetupDiGetDeviceRegistryPropertyWFunc setupGetDeviceRegistryProperty = (SetupDiGetDeviceRegistryPropertyWFunc)
61175:       GetProcAddress(setupapi, "SetupDiGetDeviceRegistryPropertyW");
61175:     SetupDiDestroyDeviceInfoListFunc setupDestroyDeviceInfoList = (SetupDiDestroyDeviceInfoListFunc)
61175:       GetProcAddress(setupapi, "SetupDiDestroyDeviceInfoList");
61175: 
61175:     if (setupGetClassDevs &&
61175:         setupEnumDeviceInfo &&
61175:         setupGetDeviceRegistryProperty &&
61175:         setupDestroyDeviceInfoList) {
61175:       /* create a device information set composed of the current display device */
72255:       HDEVINFO devinfo = setupGetClassDevs(NULL, mDeviceID.get(), NULL,
61175:                                            DIGCF_PRESENT | DIGCF_PROFILE | DIGCF_ALLCLASSES);
61175: 
61175:       if (devinfo != INVALID_HANDLE_VALUE) {
61175:         HKEY key;
61175:         LONG result;
61175:         WCHAR value[255];
61175:         DWORD dwcbData;
61175:         SP_DEVINFO_DATA devinfoData;
61175:         DWORD memberIndex = 0;
61175: 
61175:         devinfoData.cbSize = sizeof(devinfoData);
61175:         NS_NAMED_LITERAL_STRING(driverKeyPre, "System\\CurrentControlSet\\Control\\Class\\");
61175:         /* enumerate device information elements in the device information set */
61175:         while (setupEnumDeviceInfo(devinfo, memberIndex++, &devinfoData)) {
61175:           /* get a string that identifies the device's driver key */
61175:           if (setupGetDeviceRegistryProperty(devinfo,
61175:                                              &devinfoData,
61175:                                              SPDRP_DRIVER,
61175:                                              NULL,
61175:                                              (PBYTE)value,
61175:                                              sizeof(value),
61175:                                              NULL)) {
61175:             nsAutoString driverKey(driverKeyPre);
61175:             driverKey += value;
61175:             result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, driverKey.BeginReading(), 0, KEY_QUERY_VALUE, &key);
61175:             if (result == ERROR_SUCCESS) {
61175:               /* we've found the driver we're looking for */
61175:               dwcbData = sizeof(value);
61175:               result = RegQueryValueExW(key, L"DriverVersion", NULL, NULL, (LPBYTE)value, &dwcbData);
61175:               if (result == ERROR_SUCCESS)
61175:                 mDriverVersion = value;
61175:               dwcbData = sizeof(value);
61175:               result = RegQueryValueExW(key, L"DriverDate", NULL, NULL, (LPBYTE)value, &dwcbData);
61175:               if (result == ERROR_SUCCESS)
61175:                 mDriverDate = value;
61175:               RegCloseKey(key);
61175:               break;
61175:             }
61175:           }
51578:         }
51578: 
61175:         setupDestroyDeviceInfoList(devinfo);
51578:       }
51578:     }
51578: 
61175:     FreeLibrary(setupapi);
61175:   }
51579: 
60895:   const char *spoofedDriverVersionString = PR_GetEnv("MOZ_GFX_SPOOF_DRIVER_VERSION");
60895:   if (spoofedDriverVersionString) {
60895:     mDriverVersion.AssignASCII(spoofedDriverVersionString);
60895:   }
60895: 
60895:   const char *spoofedVendor = PR_GetEnv("MOZ_GFX_SPOOF_VENDOR_ID");
60895:   if (spoofedVendor) {
60895:      PR_sscanf(spoofedVendor, "%x", &mAdapterVendorID);
60895:   } else {
60895:     nsAutoString vendor(mDeviceID);
60895:     ToUpperCase(vendor);
60895:     PRInt32 start = vendor.Find(NS_LITERAL_CSTRING("VEN_"));
60895:     if (start != -1) {
60895:       vendor.Cut(0, start + strlen("VEN_"));
60895:       vendor.Truncate(4);
60895:     }
60895:     nsresult err;
60895:     mAdapterVendorID = vendor.ToInteger(&err, 16);
60895:   }
60895: 
61025:   mHasDriverVersionMismatch = PR_FALSE;
61025:   if (mAdapterVendorID == vendorIntel) {
61025:     // we've had big crashers (bugs 590373 and 595364) apparently correlated
69151:     // with bad Intel driver installations where the DriverVersion reported
69151:     // by the registry was not the version of the DLL.
61025:     PRBool is64bitApp = sizeof(void*) == 8;
61526:     const PRUnichar *dllFileName = is64bitApp
61025:                                  ? L"igd10umd64.dll"
61025:                                  : L"igd10umd32.dll";
61025:     nsString dllVersion;
69151:     gfxWindowsPlatform::GetDLLVersion((PRUnichar*)dllFileName, dllVersion);
61025: 
61025:     PRUint64 dllNumericVersion = 0, driverNumericVersion = 0;
61025:     ParseDriverVersion(dllVersion, &dllNumericVersion);
61025:     ParseDriverVersion(mDriverVersion, &driverNumericVersion);
61025: 
69151:     // if GetDLLVersion fails, it gives "0.0.0.0"
69151:     // so if GetDLLVersion failed, we get dllNumericVersion = 0
61025:     // so this test implicitly handles the case where GetDLLVersion failed
61025:     if (dllNumericVersion != driverNumericVersion)
61025:       mHasDriverVersionMismatch = PR_TRUE;
61025:   }
61025: 
60895:   const char *spoofedDevice = PR_GetEnv("MOZ_GFX_SPOOF_DEVICE_ID");
60895:   if (spoofedDevice) {
60895:     PR_sscanf(spoofedDevice, "%x", &mAdapterDeviceID);
60895:   } else {
60895:     nsAutoString device(mDeviceID);
60895:     ToUpperCase(device);
60895:     PRInt32 start = device.Find(NS_LITERAL_CSTRING("&DEV_"));
60895:     if (start != -1) {
60895:       device.Cut(0, start + strlen("&DEV_"));
60895:       device.Truncate(4);
60895:     }
60895:     nsresult err;
60895:     mAdapterDeviceID = device.ToInteger(&err, 16);
60895:   }
60895: 
60896:   const char *spoofedWindowsVersion = PR_GetEnv("MOZ_GFX_SPOOF_WINDOWS_VERSION");
60896:   if (spoofedWindowsVersion) {
60896:     PR_sscanf(spoofedWindowsVersion, "%x", &mWindowsVersion);
60896:   } else {
60896:     mWindowsVersion = gfxWindowsPlatform::WindowsOSVersion();
60896:   }
60896: 
60893:   AddCrashReportAnnotations();
51579: 
60893:   return rv;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterDescription; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDescription(nsAString & aAdapterDescription)
51578: {
51578:   aAdapterDescription = mDeviceString;
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterRAM; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterRAM(nsAString & aAdapterRAM)
51578: {
51578:   if (NS_FAILED(GetKeyValue(mDeviceKey.BeginReading(), L"HardwareInformation.MemorySize", aAdapterRAM, REG_DWORD)))
51578:     aAdapterRAM = L"Unknown";
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterDriver; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDriver(nsAString & aAdapterDriver)
51578: {
51578:   if (NS_FAILED(GetKeyValue(mDeviceKey.BeginReading(), L"InstalledDisplayDrivers", aAdapterDriver, REG_MULTI_SZ)))
51578:     aAdapterDriver = L"Unknown";
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterDriverVersion; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDriverVersion(nsAString & aAdapterDriverVersion)
51578: {
51578:   aAdapterDriverVersion = mDriverVersion;
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute DOMString adapterDriverDate; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDriverDate(nsAString & aAdapterDriverDate)
51578: {
51578:   aAdapterDriverDate = mDriverDate;
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute unsigned long adapterVendorID; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterVendorID(PRUint32 *aAdapterVendorID)
51578: {
60895:   *aAdapterVendorID = mAdapterVendorID;
51578:   return NS_OK;
51578: }
51578: 
51578: /* readonly attribute unsigned long adapterDeviceID; */
51736: NS_IMETHODIMP
51736: GfxInfo::GetAdapterDeviceID(PRUint32 *aAdapterDeviceID)
51578: {
60895:   *aAdapterDeviceID = mAdapterDeviceID;
51578:   return NS_OK;
51578: }
51579: 
70361: #if defined(MOZ_CRASHREPORTER)
61737: /* Cisco's VPN software can cause corruption of the floating point state.
61737:  * Make a note of this in our crash reports so that some weird crashes
61737:  * make more sense */
61737: static void
61737: CheckForCiscoVPN() {
61737:   LONG result;
61737:   HKEY key;
61737:   /* This will give false positives, but hopefully no false negatives */
61737:   result = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"Software\\Cisco Systems\\VPN Client", 0, KEY_QUERY_VALUE, &key);
61737:   if (result == ERROR_SUCCESS) {
61737:     RegCloseKey(key);
61737:     CrashReporter::AppendAppNotesToCrashReport(NS_LITERAL_CSTRING("Cisco VPN\n"));
61737:   }
61737: }
61737: #endif
61737: 
51736: void
51736: GfxInfo::AddCrashReportAnnotations()
51579: {
70361: #if defined(MOZ_CRASHREPORTER)
61737:   CheckForCiscoVPN();
61737: 
51579:   nsCAutoString deviceIDString, vendorIDString;
51579:   PRUint32 deviceID, vendorID;
61024:   nsAutoString adapterDriverVersionString;
51579: 
51579:   GetAdapterDeviceID(&deviceID);
51579:   GetAdapterVendorID(&vendorID);
61024:   GetAdapterDriverVersion(adapterDriverVersionString);
51579: 
51733:   deviceIDString.AppendPrintf("%04x", deviceID);
51733:   vendorIDString.AppendPrintf("%04x", vendorID);
51579: 
51579:   CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AdapterVendorID"),
51579:       vendorIDString);
51579:   CrashReporter::AnnotateCrashReport(NS_LITERAL_CSTRING("AdapterDeviceID"),
51579:       deviceIDString);
51579:   
51579:   /* Add an App Note for now so that we get the data immediately. These
51579:    * can go away after we store the above in the socorro db */
51733:   nsCAutoString note;
51733:   /* AppendPrintf only supports 32 character strings, mrghh. */
51733:   note.AppendPrintf("AdapterVendorID: %04x, ", vendorID);
61024:   note.AppendPrintf("AdapterDeviceID: %04x, ", deviceID);
61024:   note.AppendPrintf("AdapterDriverVersion: ");
61024:   note.Append(NS_LossyConvertUTF16toASCII(adapterDriverVersionString));
58229: 
58229:   if (vendorID == 0) {
58229:       /* if we didn't find a valid vendorID lets append the mDeviceID string to try to find out why */
58229:       note.Append(", ");
58336:       note.AppendWithConversion(mDeviceID);
58336:       note.Append(", ");
58229:       note.AppendWithConversion(mDeviceKeyDebug);
58229:   }
58229:   note.Append("\n");
51733: 
51733:   CrashReporter::AppendAppNotesToCrashReport(note);
51579: 
51579: #endif
51579: }
51736: 
60890: #define V(a,b,c,d) GFX_DRIVER_VERSION(a,b,c,d)
51736: 
54145: static const PRUint32 deviceFamilyIntelGMA500[] = {
54145:     0x8108, /* IntelGMA500_1 */
54145:     0x8109, /* IntelGMA500_2 */
54145:     0
54145: };
54145: 
54145: static const PRUint32 deviceFamilyIntelGMA900[] = {
54145:     0x2582, /* IntelGMA900_1 */
54145:     0x2782, /* IntelGMA900_2 */
54145:     0x2592, /* IntelGMA900_3 */
54145:     0x2792, /* IntelGMA900_4 */
54145:     0
54145: };
54145: 
54145: static const PRUint32 deviceFamilyIntelGMA950[] = {
54145:     0x2772, /* Intel945G_1 */
54145:     0x2776, /* Intel945G_2 */
54145:     0x27A2, /* Intel945_1 */
54145:     0x27A6, /* Intel945_2 */
54145:     0x27AE, /* Intel945_3 */
54145:     0
54145: };
54145: 
54145: static const PRUint32 deviceFamilyIntelGMA3150[] = {
54145:     0xA001, /* IntelGMA3150_Nettop_1 */
54145:     0xA002, /* IntelGMA3150_Nettop_2 */
54145:     0xA011, /* IntelGMA3150_Netbook_1 */
54145:     0xA012, /* IntelGMA3150_Netbook_2 */
54145:     0
54145: };
54145: 
54145: static const PRUint32 deviceFamilyIntelGMAX3000[] = {
54145:     0x2972, /* Intel946GZ_1 */
54145:     0x2973, /* Intel946GZ_2 */
54145:     0x2982, /* IntelG35_1 */
54145:     0x2983, /* IntelG35_2 */
54145:     0x2992, /* IntelQ965_1 */
54145:     0x2993, /* IntelQ965_2 */
54145:     0x29A2, /* IntelG965_1 */
54145:     0x29A3, /* IntelG965_2 */
54145:     0x29B2, /* IntelQ35_1 */
54145:     0x29B3, /* IntelQ35_2 */
54145:     0x29C2, /* IntelG33_1 */
54145:     0x29C3, /* IntelG33_2 */
54145:     0x29D2, /* IntelQ33_1 */
54145:     0x29D3, /* IntelQ33_2 */
54145:     0x2A02, /* IntelGL960_1 */
54145:     0x2A03, /* IntelGL960_2 */
54145:     0x2A12, /* IntelGM965_1 */
54145:     0x2A13, /* IntelGM965_2 */
54145:     0
54145: };
54145: 
54145: static const PRUint32 deviceFamilyIntelGMAX4500HD[] = {
54145:     0x2A42, /* IntelGMA4500MHD_1 */
54145:     0x2A43, /* IntelGMA4500MHD_2 */
54145:     0x2E42, /* IntelB43_1 */
54145:     0x2E43, /* IntelB43_2 */
54145:     0x2E92, /* IntelB43_3 */
54145:     0x2E93, /* IntelB43_4 */
54145:     0x2E32, /* IntelG41_1 */
54145:     0x2E33, /* IntelG41_2 */
54145:     0x2E22, /* IntelG45_1 */
54145:     0x2E23, /* IntelG45_2 */
54145:     0x2E12, /* IntelQ45_1 */
54145:     0x2E13, /* IntelQ45_2 */
54145:     0x0042, /* IntelHDGraphics */
54145:     0x0046, /* IntelMobileHDGraphics */
54145:     0x0102, /* IntelSandyBridge_1 */
54145:     0x0106, /* IntelSandyBridge_2 */
54145:     0x0112, /* IntelSandyBridge_3 */
54145:     0x0116, /* IntelSandyBridge_4 */
54145:     0x0122, /* IntelSandyBridge_5 */
54145:     0x0126, /* IntelSandyBridge_6 */
54145:     0x010A, /* IntelSandyBridge_7 */
54145:     0x0080, /* IntelIvyBridge */
54145:     0
54145: };
54145: 
67824: // Glitches whilst scrolling (see bugs 612007, 644787, 645872)
67824: static const PRUint32 deviceFamilyNvidiaBlockD3D9Layers[] = {
67824:     0x00f3, /* NV43 [GeForce 6200 (TM)] */
67824:     0x0146, /* NV43 [Geforce Go 6600TE/6200TE (TM)] */
67824:     0x014f, /* NV43 [GeForce 6200 (TM)] */
61659:     0x0161, /* NV44 [GeForce 6200 TurboCache (TM)] */
61659:     0x0162, /* NV44 [GeForce 6200SE TurboCache (TM)] */
67824:     0x0163, /* NV44 [GeForce 6200 LE (TM)] */
67824:     0x0164, /* NV44 [GeForce Go 6200 (TM)] */
67824:     0x0167, /* NV43 [GeForce Go 6200/6400 (TM)] */
67824:     0x0168, /* NV43 [GeForce Go 6200/6400 (TM)] */
67824:     0x0169, /* NV44 [GeForce 6250 (TM)] */
67824:     0x0221, /* NV44A [GeForce 6200 (TM)] */
67824:     0x0222, /* NV44 [GeForce 6200 A-LE (TM)] */
67824:     0x0240, /* C51PV [GeForce 6150 (TM)] */
67824:     0x0241, /* C51 [GeForce 6150 LE (TM)] */
67824:     0x0244, /* C51 [Geforce Go 6150 (TM)] */
67824:     0x0245, /* C51 [Quadro NVS 210S/GeForce 6150LE (TM)] */
67824:     0x0247, /* C51 [GeForce Go 6100 (TM)] */
67824:     0x03d0, /* C61 [GeForce 6150SE nForce 430 (TM)] */
67824:     0x03d1, /* C61 [GeForce 6100 nForce 405 (TM)] */
67824:     0x03d2, /* C61 [GeForce 6100 nForce 400 (TM)] */
67824:     0x03d5, /* C61 [GeForce 6100 nForce 420 (TM)] */
61659:     0
61659: };
61659: 
60894: static const GfxDriverInfo gDriverInfo[] = {
51736:   /*
54670:    * Notice that the first match defines the result. So always implement special cases firsts and general case last.
54670:    */
54670: 
54670:   /*
61594:    * NVIDIA entries
61594:    */
61632:   GfxDriverInfo( DRIVER_OS_WINDOWS_XP,
61632:     vendorNVIDIA, GfxDriverInfo::allDevices,
61632:     GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,
61632:     DRIVER_LESS_THAN, V(6,14,12,5721), "257.21" ),
61632:   GfxDriverInfo( DRIVER_OS_WINDOWS_VISTA,
61632:     vendorNVIDIA, GfxDriverInfo::allDevices,
61632:     GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,
61632:     DRIVER_LESS_THAN, V(8,17,12,5721), "257.21" ),
61632:   GfxDriverInfo( DRIVER_OS_WINDOWS_7,
61594:     vendorNVIDIA, GfxDriverInfo::allDevices,
61594:     GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,
61594:     DRIVER_LESS_THAN, V(8,17,12,5721), "257.21" ),
61594: 
67824:   /* Disable D3D9 layers on NVIDIA 6100/6150/6200 series due to glitches
67824:    * whilst scrolling. See bugs: 612007, 644787 & 645872.
67824:    */
61659:   GfxDriverInfo( DRIVER_OS_ALL,
67824:     vendorNVIDIA, (GfxDeviceFamily) deviceFamilyNvidiaBlockD3D9Layers,
61659:     nsIGfxInfo::FEATURE_DIRECT3D_9_LAYERS, nsIGfxInfo::FEATURE_BLOCKED_DEVICE,
61659:     DRIVER_LESS_THAN, allDriverVersions ),
61659: 
61594:   /*
61594:    * AMD/ATI entries
61594:    */
61594:   GfxDriverInfo( DRIVER_OS_ALL,
61594:     vendorATI, GfxDriverInfo::allDevices,
61594:     GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,
61594:     DRIVER_LESS_THAN, V(8,741,0,0), "10.6" ),
61594:   GfxDriverInfo( DRIVER_OS_ALL,
61594:     vendorAMD, GfxDriverInfo::allDevices,
61594:     GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,
61594:     DRIVER_LESS_THAN, V(8,741,0,0), "10.6" ),
61594: 
63066:   /* OpenGL on any ATI/AMD hardware is discouraged
63066:    * See:
63066:    *  bug 619773 - WebGL: Crash with blue screen : "NMI: Parity Check / Memory Parity Error"
63066:    *  bugs 584403, 584404, 620924 - crashes in atioglxx
63066:    *  + many complaints about incorrect rendering
63066:    */
63066:   GfxDriverInfo( DRIVER_OS_ALL,
63066:     vendorATI, GfxDriverInfo::allDevices,
63066:     nsIGfxInfo::FEATURE_OPENGL_LAYERS, nsIGfxInfo::FEATURE_DISCOURAGED,
63066:     DRIVER_LESS_THAN, allDriverVersions ),
63066:   GfxDriverInfo( DRIVER_OS_ALL,
63066:     vendorATI, GfxDriverInfo::allDevices,
63066:     nsIGfxInfo::FEATURE_WEBGL_OPENGL, nsIGfxInfo::FEATURE_DISCOURAGED,
63066:     DRIVER_LESS_THAN, allDriverVersions ),
63066:   GfxDriverInfo( DRIVER_OS_ALL,
63066:     vendorAMD, GfxDriverInfo::allDevices,
63066:     nsIGfxInfo::FEATURE_OPENGL_LAYERS, nsIGfxInfo::FEATURE_DISCOURAGED,
63066:     DRIVER_LESS_THAN, allDriverVersions ),
63066:   GfxDriverInfo( DRIVER_OS_ALL,
63066:     vendorAMD, GfxDriverInfo::allDevices,
63066:     nsIGfxInfo::FEATURE_WEBGL_OPENGL, nsIGfxInfo::FEATURE_DISCOURAGED,
63066:     DRIVER_LESS_THAN, allDriverVersions ),
61594: 
61594:   /*
51736:    * Intel entries
51736:    */
54145: 
54145:   /* implement the blocklist from bug 594877
54670:    * Block all features on any drivers before this, as there's a crash when a MS Hotfix is installed.
54670:    * The crash itself is Direct2D-related, but for safety we block all features.
54145:    */
54145: #define IMPLEMENT_INTEL_DRIVER_BLOCKLIST(winVer, devFamily, driverVer) \
60893:   GfxDriverInfo( winVer,                                               \
60893:     vendorIntel, (GfxDeviceFamily) devFamily,                          \
61023:     GfxDriverInfo::allFeatures, nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION,           \
60893:     DRIVER_LESS_THAN, driverVer ),
54145: 
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, deviceFamilyIntelGMA500,   V(6,14,11,1018))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, deviceFamilyIntelGMA900,   V(6,14,10,4764))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, deviceFamilyIntelGMA950,   V(6,14,10,4926))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, deviceFamilyIntelGMA3150,  V(6,14,10,5260))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, deviceFamilyIntelGMAX3000, V(6,14,10,5218))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_XP, deviceFamilyIntelGMAX4500HD, V(6,14,10,5284))
54145: 
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, deviceFamilyIntelGMA500,   V(7,14,10,1006))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, deviceFamilyIntelGMA900,   allDriverVersions)
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, deviceFamilyIntelGMA950,   V(7,14,10,1504))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, deviceFamilyIntelGMA3150,  V(7,14,10,2124))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, deviceFamilyIntelGMAX3000, V(7,15,10,1666))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_VISTA, deviceFamilyIntelGMAX4500HD, V(8,15,10,2202))
54145: 
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, deviceFamilyIntelGMA500,   V(5,0,0,2026))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, deviceFamilyIntelGMA900,   allDriverVersions)
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, deviceFamilyIntelGMA950,   V(8,15,10,1930))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, deviceFamilyIntelGMA3150,  V(8,14,10,2117))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, deviceFamilyIntelGMAX3000, V(8,15,10,1930))
60890:   IMPLEMENT_INTEL_DRIVER_BLOCKLIST(DRIVER_OS_WINDOWS_7, deviceFamilyIntelGMAX4500HD, V(8,15,10,2202))
51736: 
55059:   /* OpenGL on any Intel hardware is discouraged */
60893:   GfxDriverInfo( DRIVER_OS_ALL,
60893:     vendorIntel, GfxDriverInfo::allDevices,
55059:     nsIGfxInfo::FEATURE_OPENGL_LAYERS, nsIGfxInfo::FEATURE_DISCOURAGED,
60893:     DRIVER_LESS_THAN, allDriverVersions ),
60893:   GfxDriverInfo( DRIVER_OS_ALL,
60893:     vendorIntel, GfxDriverInfo::allDevices,
55059:     nsIGfxInfo::FEATURE_WEBGL_OPENGL, nsIGfxInfo::FEATURE_DISCOURAGED,
60893:     DRIVER_LESS_THAN, allDriverVersions ),
51736: 
60893:   GfxDriverInfo()
51736: };
51736: 
60890: static OperatingSystem
60890: WindowsVersionToOperatingSystem(PRInt32 aWindowsVersion)
51736: {
60890:   switch(aWindowsVersion) {
60890:     case gfxWindowsPlatform::kWindows2000:
60890:       return DRIVER_OS_WINDOWS_2000;
60890:     case gfxWindowsPlatform::kWindowsXP:
60890:       return DRIVER_OS_WINDOWS_XP;
60890:     case gfxWindowsPlatform::kWindowsServer2003:
60890:       return DRIVER_OS_WINDOWS_SERVER_2003;
60890:     case gfxWindowsPlatform::kWindowsVista:
60890:       return DRIVER_OS_WINDOWS_VISTA;
60890:     case gfxWindowsPlatform::kWindows7:
60890:       return DRIVER_OS_WINDOWS_7;
60890:     case gfxWindowsPlatform::kWindowsUnknown:
60890:     default:
60890:       return DRIVER_OS_UNKNOWN;
60890:     };
51736: }
51736: 
55059: nsresult
60894: GfxInfo::GetFeatureStatusImpl(PRInt32 aFeature, PRInt32 *aStatus, nsAString & aSuggestedDriverVersion, GfxDriverInfo* aDriverInfo /* = nsnull */)
51736: {
55059:   *aStatus = nsIGfxInfo::FEATURE_NO_INFO;
55059:   aSuggestedDriverVersion.SetIsVoid(PR_TRUE);
55059: 
55059:   PRInt32 status = nsIGfxInfo::FEATURE_NO_INFO;
51736: 
51736:   PRUint32 adapterVendor = 0;
51736:   PRUint32 adapterDeviceID = 0;
51736:   nsAutoString adapterDriverVersionString;
51736:   if (NS_FAILED(GetAdapterVendorID(&adapterVendor)) ||
51736:       NS_FAILED(GetAdapterDeviceID(&adapterDeviceID)) ||
51736:       NS_FAILED(GetAdapterDriverVersion(adapterDriverVersionString)))
51736:   {
51736:     return NS_ERROR_FAILURE;
51736:   }
51736: 
61595:   if (adapterVendor != vendorIntel &&
61595:       adapterVendor != vendorNVIDIA &&
61595:       adapterVendor != vendorAMD &&
61612:       adapterVendor != vendorATI &&
61612:       // FIXME - these special hex values are currently used in xpcshell tests introduced by
61612:       // bug 625160 patch 8/8. Maybe these tests need to be adjusted now that we're only whitelisting
61612:       // intel/ati/nvidia.
61612:       adapterVendor != 0xabcd &&
61612:       adapterVendor != 0xdcba &&
61612:       adapterVendor != 0xabab &&
61612:       adapterVendor != 0xdcdc)
61595:   {
61595:     *aStatus = FEATURE_BLOCKED_DEVICE;
61595:     return NS_OK;
61595:   }
61595: 
51736:   PRUint64 driverVersion;
51736:   if (!ParseDriverVersion(adapterDriverVersionString, &driverVersion)) {
51736:     return NS_ERROR_FAILURE;
51736:   }
51736:   
56956:   if (aFeature == FEATURE_DIRECT3D_9_LAYERS &&
60896:       mWindowsVersion < gfxWindowsPlatform::kWindowsXP)
56956:   {
56956:     *aStatus = FEATURE_BLOCKED_OS_VERSION;
56956:     return NS_OK;
56956:   }
56956: 
63229:   // ANGLE currently uses D3D10 <-> D3D9 interop, which crashes on Optimus
63229:   // machines.
63229:   if (aFeature == FEATURE_WEBGL_ANGLE &&
63229:       gfxWindowsPlatform::IsOptimus())
63229:   {
63229:     *aStatus = FEATURE_BLOCKED_DEVICE;
63229:     return NS_OK;
63229:   }
63229: 
60896:   OperatingSystem os = WindowsVersionToOperatingSystem(mWindowsVersion);
60890: 
61661:   // Windows Server 2003 should be just like Windows XP for present purpose, but still has a different version number.
61661:   // OTOH Windows Server 2008 R1 and R2 already have the same version numbers as Vista and Seven respectively
61661:   if (os == DRIVER_OS_WINDOWS_SERVER_2003)
61661:     os = DRIVER_OS_WINDOWS_XP;
61661: 
60894:   const GfxDriverInfo *info;
60894:   if (aDriverInfo)
60894:     info = aDriverInfo;
60894:   else
60894:     info = &gDriverInfo[0];
60894: 
61025:   if (mHasDriverVersionMismatch) {
61025:     if (aFeature == nsIGfxInfo::FEATURE_DIRECT3D_10_LAYERS ||
61025:         aFeature == nsIGfxInfo::FEATURE_DIRECT3D_10_1_LAYERS ||
61025:         aFeature == nsIGfxInfo::FEATURE_DIRECT2D)
61025:     {
61025:       *aStatus = nsIGfxInfo::FEATURE_BLOCKED_DRIVER_VERSION;
61025:       return NS_OK;
61025:     }
61025:   }
61025: 
61594:   // special-case the WinXP test slaves: they have out-of-date drivers, but we still want to
61594:   // whitelist them, actually we do know that this combination of device and driver version
61594:   // works well.
61594:   if (os == DRIVER_OS_WINDOWS_XP &&
61594:       adapterVendor == vendorNVIDIA &&
61594:       adapterDeviceID == 0x0861 && // GeForce 9400
61594:       driverVersion == V(6,14,11,7756))
61594:   {
61594:     return NS_OK;
61594:   }
61594: 
60890:   while (info->mOperatingSystem) {
51736: 
60890:     if (info->mOperatingSystem != DRIVER_OS_ALL &&
60890:         info->mOperatingSystem != os)
51736:     {
51736:       info++;
51736:       continue;
51736:     }
51736: 
60890:     if (info->mAdapterVendor != GfxDriverInfo::allAdapterVendors &&
60890:         info->mAdapterVendor != adapterVendor) {
54145:       info++;
54145:       continue;
54145:     }
54145: 
60890:     if (info->mDevices != GfxDriverInfo::allDevices) {
54145:         bool deviceMatches = false;
60890:         for (const PRUint32 *devices = info->mDevices; *devices; ++devices) {
54145:             if (*devices == adapterDeviceID) {
54145:                 deviceMatches = true;
54145:                 break;
54145:             }
54145:         }
54145: 
54145:         if (!deviceMatches) {
54145:             info++;
54145:             continue;
54145:         }
54145:     }
54145: 
54145:     bool match = false;
54145: 
60890:     switch (info->mComparisonOp) {
51736:     case DRIVER_LESS_THAN:
60890:       match = driverVersion < info->mDriverVersion;
51736:       break;
51736:     case DRIVER_LESS_THAN_OR_EQUAL:
60890:       match = driverVersion <= info->mDriverVersion;
51736:       break;
51736:     case DRIVER_GREATER_THAN:
60890:       match = driverVersion > info->mDriverVersion;
51736:       break;
51736:     case DRIVER_GREATER_THAN_OR_EQUAL:
60890:       match = driverVersion >= info->mDriverVersion;
51736:       break;
51736:     case DRIVER_EQUAL:
60890:       match = driverVersion == info->mDriverVersion;
51736:       break;
51736:     case DRIVER_NOT_EQUAL:
60890:       match = driverVersion != info->mDriverVersion;
51736:       break;
51736:     case DRIVER_BETWEEN_EXCLUSIVE:
60890:       match = driverVersion > info->mDriverVersion && driverVersion < info->mDriverVersionMax;
51736:       break;
51736:     case DRIVER_BETWEEN_INCLUSIVE:
60890:       match = driverVersion >= info->mDriverVersion && driverVersion <= info->mDriverVersionMax;
51736:       break;
51736:     case DRIVER_BETWEEN_INCLUSIVE_START:
60890:       match = driverVersion >= info->mDriverVersion && driverVersion < info->mDriverVersionMax;
51736:       break;
51736:     default:
51736:       NS_WARNING("Bogus op in GfxDriverInfo");
51736:       break;
51736:     }
51736: 
51736:     if (match) {
60890:       if (info->mFeature == GfxDriverInfo::allFeatures ||
60890:           info->mFeature == aFeature)
51736:       {
60890:         status = info->mFeatureStatus;
51736:         break;
51736:       }
51736:     }
51736: 
51736:     info++;
51736:   }
51736: 
51736:   *aStatus = status;
55059: 
61594:   if (status == FEATURE_BLOCKED_DRIVER_VERSION) {
61594:       if (info->mSuggestedVersion) {
61594:           aSuggestedDriverVersion.AppendPrintf("%s", info->mSuggestedVersion);
61594:       } else if (info->mComparisonOp == DRIVER_LESS_THAN &&
61594:                  info->mDriverVersion != allDriverVersions)
61594:       {
55059:           aSuggestedDriverVersion.AppendPrintf("%lld.%lld.%lld.%lld",
61594:                                                (info->mDriverVersion & 0xffff000000000000) >> 48,
61594:                                                (info->mDriverVersion & 0x0000ffff00000000) >> 32,
61594:                                                (info->mDriverVersion & 0x00000000ffff0000) >> 16,
61594:                                                (info->mDriverVersion & 0x000000000000ffff));
61594:       }
55059:   }
55059:   
51736:   return NS_OK;
51736: }
60896: 
60896: #ifdef DEBUG
60896: 
60896: // Implement nsIGfxInfoDebug
60896: 
60896: /* void spoofVendorID (in unsigned long aVendorID); */
60896: NS_IMETHODIMP GfxInfo::SpoofVendorID(PRUint32 aVendorID)
60896: {
60896:   mAdapterVendorID = aVendorID;
60896:   return NS_OK;
60896: }
60896: 
60896: /* void spoofDeviceID (in unsigned long aDeviceID); */
60896: NS_IMETHODIMP GfxInfo::SpoofDeviceID(PRUint32 aDeviceID)
60896: {
60896:   mAdapterDeviceID = aDeviceID;
60896:   return NS_OK;
60896: }
60896: 
60896: /* void spoofDriverVersion (in DOMString aDriverVersion); */
60896: NS_IMETHODIMP GfxInfo::SpoofDriverVersion(const nsAString & aDriverVersion)
60896: {
60896:   mDriverVersion = aDriverVersion;
60896:   return NS_OK;
60896: }
60896: 
60896: /* void spoofOSVersion (in unsigned long aVersion); */
60896: NS_IMETHODIMP GfxInfo::SpoofOSVersion(PRUint32 aVersion)
60896: {
60896:   mWindowsVersion = aVersion;
60896:   return NS_OK;
60896: }
60896: 
60896: #endif
