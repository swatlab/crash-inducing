79516: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
79516:  * vim: set ts=8 sw=4 et tw=99 ft=cpp:
79516:  *
79516:  * ***** BEGIN LICENSE BLOCK *****
79516:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
79516:  *
79516:  * The contents of this file are subject to the Mozilla Public License Version
79516:  * 1.1 (the "License"); you may not use this file except in compliance with
79516:  * the License. You may obtain a copy of the License at
79516:  * http://www.mozilla.org/MPL/
79516:  *
79516:  * Software distributed under the License is distributed on an "AS IS" basis,
79516:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
79516:  * for the specific language governing rights and limitations under the
79516:  * License.
79516:  *
79516:  * The Original Code is Mozilla SpiderMonkey JavaScript code.
79516:  *
79516:  * The Initial Developer of the Original Code is
79516:  * the Mozilla Foundation.
79516:  * Portions created by the Initial Developer are Copyright (C) 2011
79516:  * the Initial Developer. All Rights Reserved.
79516:  *
79516:  * Contributor(s):
79516:  *  Chris Leary <cdleary@mozilla.com>
79516:  *
79516:  * Alternatively, the contents of this file may be used under the terms of
79516:  * either the GNU General Public License Version 2 or later (the "GPL"), or
79516:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
79516:  * in which case the provisions of the GPL or the LGPL are applicable instead
79516:  * of those above. If you wish to allow use of your version of this file only
79516:  * under the terms of either the GPL or the LGPL, and not to allow others to
79516:  * use your version of this file under the terms of the MPL, indicate your
79516:  * decision by deleting the provisions above and replace them with the notice
79516:  * and other provisions required by the GPL or the LGPL. If you do not delete
79516:  * the provisions above, a recipient may use your version of this file under
79516:  * the terms of any one of the MPL, the GPL or the LGPL.
79516:  *
79516:  * ***** END LICENSE BLOCK ***** */
79516: 
78949: #include "LifoAlloc.h"
78949: 
78949: #include <new>
78949: 
78949: using namespace js;
78949: 
78949: namespace js {
78949: namespace detail {
78949: 
78949: BumpChunk *
78949: BumpChunk::new_(size_t chunkSize)
78949: {
78949:     JS_ASSERT(RoundUpPow2(chunkSize) == chunkSize);
78949:     void *mem = js_malloc(chunkSize);
78949:     if (!mem)
78949:         return NULL;
78949:     BumpChunk *result = new (mem) BumpChunk(chunkSize - sizeof(BumpChunk));
78949: 
78949:     /* 
78949:      * We assume that the alignment of sAlign is less than that of
78949:      * the underlying memory allocator -- creating a new BumpChunk should
78949:      * always satisfy the sAlign alignment constraint.
78949:      */
78949:     JS_ASSERT(AlignPtr(result->bump) == result->bump);
78949:     return result;
78949: }
78949: 
80214: void
80214: BumpChunk::delete_(BumpChunk *chunk)
80214: {
80214: #ifdef DEBUG
80214:         memset(chunk, 0xcd, sizeof(*chunk) + chunk->bumpSpaceSize);
80214: #endif
80214:         js_free(chunk);
80214: }
80214: 
80214: bool
80214: BumpChunk::canAlloc(size_t n)
80214: {
80214:     char *aligned = AlignPtr(bump);
80214:     char *bumped = aligned + n;
80214:     return bumped <= limit && bumped > headerBase();
80214: }
80214: 
80214: bool
80214: BumpChunk::canAllocUnaligned(size_t n)
80214: {
80214:     char *bumped = bump + n;
80214:     return bumped <= limit && bumped > headerBase();
80214: }
80214: 
78949: void *
78949: BumpChunk::tryAllocUnaligned(size_t n)
78949: {
78949:     char *oldBump = bump;
78949:     char *newBump = bump + n;
78949:     if (newBump > limit)
78949:         return NULL;
78949: 
80214:     JS_ASSERT(canAllocUnaligned(n));
78949:     setBump(newBump);
78949:     return oldBump;
78949: }
78949: 
78949: } /* namespace detail */
78949: } /* namespace js */
78949: 
78949: void
78949: LifoAlloc::freeAll()
78949: {
78949:     while (first) {
78949:         BumpChunk *victim = first;
78949:         first = first->next();
78949:         BumpChunk::delete_(victim);
78949:     }
78949:     first = latest = NULL;
78949: }
78949: 
78949: void
78949: LifoAlloc::freeUnused()
78949: {
78949:     /* Don't free anything if we have outstanding marks. */
78949:     if (markCount || !first)
78949:         return; 
78949: 
78949:     JS_ASSERT(first && latest);
78949: 
78949:     /* Rewind through any unused chunks. */
78949:     if (!latest->used()) {
78949:         BumpChunk *lastUsed = NULL;
78949:         for (BumpChunk *it = first; it != latest; it = it->next()) {
78949:             if (it->used())
78949:                 lastUsed = it;
78949:         }
78949:         if (!lastUsed) {
78949:             freeAll();
78949:             return;
78949:         }
78949:         latest = lastUsed;
78949:     }
78949: 
78949:     /* Free all chunks after |latest|. */
83119:     for (BumpChunk *victim = latest->next(); victim; victim = victim->next())
78949:         BumpChunk::delete_(victim);
83119: 
83119:     latest->setNext(NULL);
78949: }
78949: 
78949: LifoAlloc::BumpChunk *
78949: LifoAlloc::getOrCreateChunk(size_t n)
78949: {
78949:     if (first) {
78949:         /* Look for existing, unused BumpChunks to satisfy the request. */
78949:         while (latest->next()) {
78949:             latest = latest->next();
78949:             latest->resetBump(); /* This was an unused BumpChunk on the chain. */
78949:             if (latest->canAlloc(n))
78949:                 return latest;
78949:         }
78949:     }
78949: 
78949:     size_t defaultChunkFreeSpace = defaultChunkSize_ - sizeof(BumpChunk);
80214:     size_t chunkSize;
80214:     if (n > defaultChunkFreeSpace) {
80214:         size_t allocSizeWithHeader = n + sizeof(BumpChunk);
80214: 
80214:         /* Guard for overflow. */
80214:         if (allocSizeWithHeader < n ||
80214:             (allocSizeWithHeader & (size_t(1) << (tl::BitSize<size_t>::result - 1)))) {
80214:             return NULL;
80214:         }
80214: 
80214:         chunkSize = RoundUpPow2(allocSizeWithHeader);
80214:     } else {
80214:         chunkSize = defaultChunkSize_;
80214:     }
78949: 
78949:     /* If we get here, we couldn't find an existing BumpChunk to fill the request. */
78949:     BumpChunk *newChunk = BumpChunk::new_(chunkSize);
78949:     if (!newChunk)
78949:         return NULL;
78949:     if (!first) {
78949:         latest = first = newChunk;
78949:     } else {
78949:         JS_ASSERT(latest && !latest->next());
78949:         latest->setNext(newChunk);
78949:         latest = newChunk;
78949:     }
78949:     return newChunk;
78949: }
78949: 
78949: void *
78949: LifoAlloc::allocUnaligned(size_t n)
78949: {
78949:     void *result;
78949:     if (latest && (result = latest->tryAllocUnaligned(n)))
78949:         return result;
78949: 
78949:     return alloc(n);
78949: }
78949: 
78949: void *
78949: LifoAlloc::reallocUnaligned(void *origPtr, size_t origSize, size_t incr)
78949: {
78949:     JS_ASSERT(first && latest);
78949: 
78949:     /*
78949:      * Maybe we can grow the latest allocation in a BumpChunk.
78949:      *
78949:      * Note: we could also realloc the whole BumpChunk in the !canAlloc
78949:      * case, but this should not be a frequently hit case.
78949:      */
78949:     if (latest
78949:         && origPtr == (char *) latest->mark() - origSize
78949:         && latest->canAllocUnaligned(incr)) {
78949:         JS_ALWAYS_TRUE(allocUnaligned(incr));
78949:         return origPtr;
78949:     }
78949: 
78949:     /* Otherwise, memcpy. */
78949:     size_t newSize = origSize + incr;
78949:     void *newPtr = allocUnaligned(newSize);
78949:     return newPtr ? memcpy(newPtr, origPtr, origSize) : NULL;
78949: }
