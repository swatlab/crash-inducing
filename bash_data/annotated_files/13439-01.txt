    1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef GFX_WINDOWSFONTS_H
    1: #define GFX_WINDOWSFONTS_H
    1: 
    1: #include "prtypes.h"
    1: #include "gfxTypes.h"
    1: #include "gfxColor.h"
    1: #include "gfxFont.h"
    1: #include "gfxMatrix.h"
 9699: #include "gfxFontUtils.h"
    1: 
    1: #include "nsDataHashtable.h"
    1: 
    1: #include <usp10.h>
    1: #include <cairo-win32.h>
    1: 
13280: 
    1: /**
13280:  * FontFamily is a class that describes one of the fonts on the users system.  It holds
13280:  * each FontEntry (maps more directly to a font face) which holds font type, charset info
13280:  * and character map info.
    1:  */
13280: class FontEntry;
13280: class FontFamily
13280: {
13280: public:
13280:     THEBES_INLINE_DECL_REFCOUNTING(FontFamily)
13280: 
13280:     FontFamily(const nsAString& aName) :
13280:         mName(aName)
13280:     {
13280:     }
13280: 
13280:     nsTArray<nsRefPtr<FontEntry> > mVariations;
13280:     nsString mName;
13280: };
13280: 
13280: 
13280: 
    1: class FontEntry
    1: {
    1: public:
    1:     THEBES_INLINE_DECL_REFCOUNTING(FontEntry)
    1: 
13280:     FontEntry(FontFamily *aFontFamily) : 
13280:         mFamily(aFontFamily), mUnicodeFont(PR_FALSE), mSymbolFont(PR_FALSE),
13280:         mTrueType(PR_FALSE), mIsType1(PR_FALSE),
13439:         mIsBadUnderlineFont(PR_FALSE), mForceGDI(PR_FALSE), mCharset(0), mUnicodeRanges(0)
    1:     {
    1:     }
    1: 
13360:     FontEntry(const FontEntry& aFontEntry) :
13360:         mFamily(aFontEntry.mFamily),
13360:         mWindowsFamily(aFontEntry.mWindowsFamily),
13360:         mWindowsPitch(aFontEntry.mWindowsPitch),
13360:         mUnicodeFont(aFontEntry.mUnicodeFont),
13360:         mSymbolFont(aFontEntry.mSymbolFont),
13360:         mTrueType(aFontEntry.mTrueType),
13360:         mIsType1(aFontEntry.mIsType1),
13360:         mIsBadUnderlineFont(aFontEntry.mIsBadUnderlineFont),
13360:         mItalic(aFontEntry.mItalic),
13360:         mWeight(aFontEntry.mWeight),
13360:         mCharset(aFontEntry.mCharset),
13360:         mUnicodeRanges(aFontEntry.mUnicodeRanges),
13360:         mCharacterMap(aFontEntry.mCharacterMap)
13360:     {
13360:     }
13360: 
13280:     const nsString& GetName() const {
13280:         return mFamily->mName;
13280:     }
13280: 
    1:     PRBool IsCrappyFont() const {
12992:         /* return if it is a bitmap not a unicode font */
13097:         return (!mUnicodeFont || mSymbolFont || mIsType1);
    1:     }
    1: 
    1:     PRBool MatchesGenericFamily(const nsACString& aGeneric) const {
    1:         if (aGeneric.IsEmpty())
    1:             return PR_TRUE;
    1: 
    1:         // Japanese 'Mincho' fonts do not belong to FF_MODERN even if
    1:         // they are fixed pitch because they have variable stroke width.
13280:         if (mWindowsFamily == FF_ROMAN && mWindowsPitch & FIXED_PITCH) {
    1:             return aGeneric.EqualsLiteral("monospace");
    1:         }
    1: 
    1:         // Japanese 'Gothic' fonts do not belong to FF_SWISS even if
    1:         // they are variable pitch because they have constant stroke width.
13280:         if (mWindowsFamily == FF_MODERN && mWindowsPitch & VARIABLE_PITCH) {
    1:             return aGeneric.EqualsLiteral("sans-serif");
    1:         }
    1: 
    1:         // All other fonts will be grouped correctly using family...
13280:         switch (mWindowsFamily) {
    1:         case FF_DONTCARE:
    1:             return PR_TRUE;
    1:         case FF_ROMAN:
    1:             return aGeneric.EqualsLiteral("serif");
    1:         case FF_SWISS:
    1:             return aGeneric.EqualsLiteral("sans-serif");
    1:         case FF_MODERN:
    1:             return aGeneric.EqualsLiteral("monospace");
    1:         case FF_SCRIPT:
    1:             return aGeneric.EqualsLiteral("cursive");
    1:         case FF_DECORATIVE:
    1:             return aGeneric.EqualsLiteral("fantasy");
    1:         }
    1: 
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     PRBool SupportsLangGroup(const nsACString& aLangGroup) const {
    1:         if (aLangGroup.IsEmpty())
    1:             return PR_TRUE;
    1: 
    1:         PRInt16 bit = -1;
    1: 
    1:         /* map our langgroup names in to Windows charset bits */
    1:         if (aLangGroup.EqualsLiteral("x-western")) {
    1:             bit = ANSI_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("ja")) {
    1:             bit = SHIFTJIS_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("ko")) {
    1:             bit = HANGEUL_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("ko-XXX")) {
    1:             bit = JOHAB_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("zh-CN")) {
    1:             bit = GB2312_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("zh-TW")) {
    1:             bit = CHINESEBIG5_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("el")) {
    1:             bit = GREEK_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("tr")) {
    1:             bit = TURKISH_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("he")) {
    1:             bit = HEBREW_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("ar")) {
    1:             bit = ARABIC_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("x-baltic")) {
    1:             bit = BALTIC_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("x-cyrillic")) {
    1:             bit = RUSSIAN_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("th")) {
    1:             bit = THAI_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("x-central-euro")) {
    1:             bit = EASTEUROPE_CHARSET;
    1:         } else if (aLangGroup.EqualsLiteral("x-symbol")) {
    1:             bit = SYMBOL_CHARSET;
    1:         }
    1: 
    1:         if (bit != -1)
    1:             return mCharset[bit];
    1: 
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     PRBool SupportsRange(PRUint8 range) {
    1:         return mUnicodeRanges[range];
    1:     }
    1: 
12989:     // whether this font family is in "bad" underline offset blacklist.
12989:     PRBool IsBadUnderlineFont() { return mIsBadUnderlineFont != 0; }
12989: 
13280:     /* needs to be a weak pointer to avoid a cycle */
13280:     FontFamily *mFamily;
    1: 
13280:     PRUint8 mWindowsFamily;
13280:     PRUint8 mWindowsPitch;
12992: 
    1:     PRPackedBool mUnicodeFont;
 2773:     PRPackedBool mSymbolFont;
13280:     PRPackedBool mTrueType;
12992:     PRPackedBool mIsType1;
12989:     PRPackedBool mIsBadUnderlineFont;
13439:     PRPackedBool mForceGDI;
13280:     PRPackedBool mItalic;
13280:     PRUint16 mWeight;
    1: 
    1:     std::bitset<256> mCharset;
    1:     std::bitset<128> mUnicodeRanges;
 1959: 
 1959:     gfxSparseBitSet mCharacterMap;
    1: };
    1: 
    1: /**********************************************************************
    1:  *
    1:  * class gfxWindowsFont
    1:  *
    1:  **********************************************************************/
    1: 
    1: class gfxWindowsFont : public gfxFont {
    1: public:
13340:     gfxWindowsFont(const nsAString& aName, const gfxFontStyle *aFontStyle, FontEntry *aFontEntry);
    1:     virtual ~gfxWindowsFont();
    1: 
    1:     virtual const gfxFont::Metrics& GetMetrics();
    1: 
 2369:     HFONT GetHFONT() { return mFont; }
    1:     cairo_font_face_t *CairoFontFace();
    1:     cairo_scaled_font_t *CairoScaledFont();
    1:     SCRIPT_CACHE *ScriptCache() { return &mScriptCache; }
    1:     gfxFloat GetAdjustedSize() { MakeHFONT(); return mAdjustedSize; }
    1: 
    1:     virtual nsString GetUniqueName();
    1: 
    1:     virtual void Draw(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,
    1:                       gfxContext *aContext, PRBool aDrawToPath, gfxPoint *aBaselineOrigin,
    1:                       Spacing *aSpacing);
    1: 
 1295:     virtual PRUint32 GetSpaceGlyph() {
 2369:         GetMetrics(); // ensure that the metrics are computed but don't recompute them
 1295:         return mSpaceGlyph;
 1295:     };
 1295: 
 1959:     FontEntry *GetFontEntry() { return mFontEntry; }
 1959: 
    1: protected:
    1:     HFONT MakeHFONT();
13280:     void FillLogFont(gfxFloat aSize);
    1: 
    1:     HFONT    mFont;
    1:     gfxFloat mAdjustedSize;
 1295:     PRUint32 mSpaceGlyph;
    1: 
    1: private:
    1:     void ComputeMetrics();
    1: 
    1:     SCRIPT_CACHE mScriptCache;
    1: 
    1:     cairo_font_face_t *mFontFace;
    1:     cairo_scaled_font_t *mScaledFont;
    1: 
    1:     gfxFont::Metrics *mMetrics;
    1: 
    1:     LOGFONTW mLogFont;
    1: 
 1959:     nsRefPtr<FontEntry> mFontEntry;
    1:     
 6247:     virtual PRBool SetupCairoFont(gfxContext *aContext);
    1: };
    1: 
    1: /**********************************************************************
    1:  *
    1:  * class gfxWindowsFontGroup
    1:  *
    1:  **********************************************************************/
    1: 
    1: class THEBES_API gfxWindowsFontGroup : public gfxFontGroup {
    1: 
    1: public:
    1:     gfxWindowsFontGroup(const nsAString& aFamilies, const gfxFontStyle* aStyle);
    1:     virtual ~gfxWindowsFontGroup();
    1: 
    6:     virtual gfxFontGroup *Copy(const gfxFontStyle *aStyle);
    6: 
    1:     virtual gfxTextRun *MakeTextRun(const PRUnichar* aString, PRUint32 aLength,
 1295:                                     const Parameters* aParams, PRUint32 aFlags);
    1:     virtual gfxTextRun *MakeTextRun(const PRUint8* aString, PRUint32 aLength,
 1295:                                     const Parameters* aParams, PRUint32 aFlags);
    1: 
    1:     const nsACString& GetGenericFamily() const {
    1:         return mGenericFamily;
    1:     }
    1: 
 2252:     const nsTArray<nsRefPtr<FontEntry> >& GetFontList() const {
 2252:         return mFontEntries;
 2252:     }
    1:     PRUint32 FontListLength() const {
 2252:         return mFontEntries.Length();
    1:     }
    1: 
 2252:     FontEntry *GetFontEntryAt(PRInt32 i) {
 2252:         return mFontEntries[i];
    1:     }
    1: 
 2252:     virtual gfxWindowsFont *GetFontAt(PRInt32 i);
    1: 
13280:     void GroupFamilyListToArrayList(nsTArray<nsRefPtr<FontEntry> > *list);
13280:     void FamilyListToArrayList(const nsString& aFamilies,
13280:                                const nsCString& aLangGroup,
13280:                                nsTArray<nsRefPtr<FontEntry> > *list);
13280: 
    1: protected:
    1:     void InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun, const char *aString, PRUint32 aLength);
    1:     void InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun, const PRUnichar *aString, PRUint32 aLength);
    1: 
    1:     void InitTextRunUniscribe(gfxContext *aContext, gfxTextRun *aRun, const PRUnichar *aString, PRUint32 aLength);
    1: 
    1: private:
13280: 
    1:     nsCString mGenericFamily;
 2252:     nsTArray<nsRefPtr<FontEntry> > mFontEntries;
    1: };
    1: 
    1: #endif /* GFX_WINDOWSFONTS_H */
