     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsToolkit.h"
     1: 
     1: #include <ctype.h>
     1: #include <stdlib.h>
     1: #include <stdio.h>
     1: 
     1: #include <mach/mach_port.h>
     1: #include <mach/mach_interface.h>
     1: #include <mach/mach_init.h>
     1: 
 40215: extern "C" {
 40215: #include <mach-o/getsect.h>
 40215: }
 40215: #include <unistd.h>
 40215: #include <dlfcn.h>
 40215: 
  1579: #import <Cocoa/Cocoa.h>
     1: #import <IOKit/pwr_mgt/IOPMLib.h>
     1: #import <IOKit/IOMessage.h>
     1: 
  3574: #include "nsCocoaUtils.h"
 11978: #include "nsObjCExceptions.h"
  3574: 
 80435: #include "nsGkAtoms.h"
  1579: #include "nsIRollupListener.h"
  1579: #include "nsIWidget.h"
120177: #include "nsBaseWidget.h"
     1: 
     1: #include "nsIObserverService.h"
     1: #include "nsIServiceManager.h"
 70976: 
 70976: #include "mozilla/Preferences.h"
 70976: 
 70976: using namespace mozilla;
     1: 
     1: static io_connect_t gRootPort = MACH_PORT_NULL;
     1: 
106838: nsToolkit* nsToolkit::gToolkit = nullptr;
     1: 
     1: nsToolkit::nsToolkit()
106838: : mSleepWakeNotificationRLS(nullptr)
106838: , mEventTapPort(nullptr)
106838: , mEventTapRLS(nullptr)
     1: {
 81023:   MOZ_COUNT_CTOR(nsToolkit);
 80842:   RegisterForSleepWakeNotifcations();
 80842:   RegisterForAllProcessMouseEvents();
     1: }
     1: 
     1: nsToolkit::~nsToolkit()
     1: {
 79844:   MOZ_COUNT_DTOR(nsToolkit);
     1:   RemoveSleepWakeNotifcations();
  3574:   UnregisterAllProcessMouseEventHandlers();
     1: }
     1: 
     1: void
     1: nsToolkit::PostSleepWakeNotification(const char* aNotification)
     1: {
     1:   nsCOMPtr<nsIObserverService> observerService = do_GetService("@mozilla.org/observer-service;1");
     1:   if (observerService)
106838:     observerService->NotifyObservers(nullptr, aNotification, nullptr);
     1: }
     1: 
     1: // http://developer.apple.com/documentation/DeviceDrivers/Conceptual/IOKitFundamentals/PowerMgmt/chapter_10_section_3.html
     1: static void ToolkitSleepWakeCallback(void *refCon, io_service_t service, natural_t messageType, void * messageArgument)
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   switch (messageType)
     1:   {
     1:     case kIOMessageSystemWillSleep:
     1:       // System is going to sleep now.
121564:       nsToolkit::PostSleepWakeNotification(NS_WIDGET_SLEEP_OBSERVER_TOPIC);
     1:       ::IOAllowPowerChange(gRootPort, (long)messageArgument);
     1:       break;
     1:       
     1:     case kIOMessageCanSystemSleep:
     1:       // In this case, the computer has been idle for several minutes
     1:       // and will sleep soon so you must either allow or cancel
     1:       // this notification. Important: if you donâ€™t respond, there will
     1:       // be a 30-second timeout before the computer sleeps.
     1:       // In Mozilla's case, we always allow sleep.
     1:       ::IOAllowPowerChange(gRootPort,(long)messageArgument);
     1:       break;
     1:       
     1:     case kIOMessageSystemHasPoweredOn:
     1:       // Handle wakeup.
121564:       nsToolkit::PostSleepWakeNotification(NS_WIDGET_WAKE_OBSERVER_TOPIC);
     1:       break;
     1:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
     1: nsresult
     1: nsToolkit::RegisterForSleepWakeNotifcations()
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
     1:   IONotificationPortRef notifyPortRef;
     1: 
     1:   NS_ASSERTION(!mSleepWakeNotificationRLS, "Already registered for sleep/wake");
     1: 
     1:   gRootPort = ::IORegisterForSystemPower(0, &notifyPortRef, ToolkitSleepWakeCallback, &mPowerNotifier);
     1:   if (gRootPort == MACH_PORT_NULL) {
 31561:     NS_ERROR("IORegisterForSystemPower failed");
     1:     return NS_ERROR_FAILURE;
     1:   }
     1: 
     1:   mSleepWakeNotificationRLS = ::IONotificationPortGetRunLoopSource(notifyPortRef);
     1:   ::CFRunLoopAddSource(::CFRunLoopGetCurrent(),
     1:                        mSleepWakeNotificationRLS,
     1:                        kCFRunLoopDefaultMode);
     1: 
     1:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
     1: }
     1: 
     1: void
     1: nsToolkit::RemoveSleepWakeNotifcations()
     1: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
     1:   if (mSleepWakeNotificationRLS) {
     1:     ::IODeregisterForSystemPower(&mPowerNotifier);
     1:     ::CFRunLoopRemoveSource(::CFRunLoopGetCurrent(),
     1:                             mSleepWakeNotificationRLS,
     1:                             kCFRunLoopDefaultMode);
     1: 
106838:     mSleepWakeNotificationRLS = nullptr;
     1:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
     1: }
     1: 
  3574: // Converts aPoint from the CoreGraphics "global display coordinate" system
  3574: // (which includes all displays/screens and has a top-left origin) to its
  3574: // (presumed) Cocoa counterpart (assumed to be the same as the "screen
  3574: // coordinates" system), which has a bottom-left origin.
  3574: static NSPoint ConvertCGGlobalToCocoaScreen(CGPoint aPoint)
  3574: {
  3574:   NSPoint cocoaPoint;
  3574:   cocoaPoint.x = aPoint.x;
  8779:   cocoaPoint.y = nsCocoaUtils::FlippedScreenY(aPoint.y);
  3574:   return cocoaPoint;
  1579: }
  1579: 
  3574: // Since our event tap is "listen only", events arrive here a little after
  3574: // they've already been processed.
  3574: static CGEventRef EventTapCallback(CGEventTapProxy proxy, CGEventType type, CGEventRef event, void *refcon)
  3574: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
  3574:   if ((type == kCGEventTapDisabledByUserInput) ||
  3574:       (type == kCGEventTapDisabledByTimeout))
  3574:     return event;
120177:   if ([NSApp isActive])
  3574:     return event;
120177: 
120177:   nsIRollupListener* rollupListener = nsBaseWidget::GetActiveRollupListener();
127124:   NS_ENSURE_TRUE(rollupListener, event);
120177:   nsCOMPtr<nsIWidget> rollupWidget = rollupListener->GetRollupWidget();
127124:   NS_ENSURE_TRUE(rollupWidget, event);
120177: 
  3574:   // Don't bother with rightMouseDown events here -- because of the delay,
  3574:   // we'll end up closing browser context menus that we just opened.  Since
  3574:   // these events usually raise a context menu, we'll handle them by hooking
  3574:   // the @"com.apple.HIToolbox.beginMenuTrackingNotification" distributed
  3574:   // notification (in nsAppShell.mm's AppShellDelegate).
  3574:   if (type == kCGEventRightMouseDown)
  3574:     return event;
120177:   NSWindow *ctxMenuWindow = (NSWindow*) rollupWidget->GetNativeData(NS_NATIVE_WINDOW);
  3574:   if (!ctxMenuWindow)
  3574:     return event;
  3574:   NSPoint screenLocation = ConvertCGGlobalToCocoaScreen(CGEventGetLocation(event));
  3574:   // Don't roll up the rollup widget if our mouseDown happens over it (doing
  3574:   // so would break the corresponding context menu).
  3574:   if (NSPointInRect(screenLocation, [ctxMenuWindow frame]))
  3574:     return event;
120177:   rollupListener->Rollup(0, nullptr);
  3574:   return event;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(NULL);
  3574: }
  3574: 
  3574: // Cocoa Firefox's use of custom context menus requires that we explicitly
  3574: // handle mouse events from other processes that the OS handles
  3574: // "automatically" for native context menus -- mouseMoved events so that
  3574: // right-click context menus work properly when our browser doesn't have the
  3574: // focus (bmo bug 368077), and mouseDown events so that our browser can
  3574: // dismiss a context menu when a mouseDown happens in another process (bmo
  3574: // bug 339945).
  1579: void
  1579: nsToolkit::RegisterForAllProcessMouseEvents()
  1579: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
  4686:   // Don't do this for apps that (like Camino) use native context menus.
 72208: #ifdef MOZ_USE_NATIVE_POPUP_WINDOWS
  4686:   return;
 72208: #endif /* MOZ_USE_NATIVE_POPUP_WINDOWS */
 72208: 
  3574:   if (!mEventTapRLS) {
  3574:     // Using an event tap for mouseDown events (instead of installing a
  3574:     // handler for them on the EventMonitor target) works around an Apple
  3574:     // bug that causes OS menus (like the Clock menu) not to work properly
  3574:     // on OS X 10.4.X and below (bmo bug 381448).
  3574:     // We install our event tap "listen only" to get around yet another Apple
  3574:     // bug -- when we install it as an event filter on any kind of mouseDown
  3574:     // event, that kind of event stops working in the main menu, and usually
  3574:     // mouse event processing stops working in all apps in the current login
  3574:     // session (so the entire OS appears to be hung)!  The downside of
  3574:     // installing listen-only is that events arrive at our handler slightly
  3574:     // after they've already been processed.
  3574:     mEventTapPort = CGEventTapCreate(kCGSessionEventTap,
  3574:                                      kCGHeadInsertEventTap,
  3574:                                      kCGEventTapOptionListenOnly,
  3574:                                      CGEventMaskBit(kCGEventLeftMouseDown)
  3574:                                        | CGEventMaskBit(kCGEventRightMouseDown)
  3574:                                        | CGEventMaskBit(kCGEventOtherMouseDown),
  3574:                                      EventTapCallback,
106838:                                      nullptr);
  3574:     if (!mEventTapPort)
  3574:       return;
106838:     mEventTapRLS = CFMachPortCreateRunLoopSource(nullptr, mEventTapPort, 0);
  3574:     if (!mEventTapRLS) {
  3574:       CFRelease(mEventTapPort);
106838:       mEventTapPort = nullptr;
  3574:       return;
  3574:     }
  3574:     CFRunLoopAddSource(CFRunLoopGetCurrent(), mEventTapRLS, kCFRunLoopDefaultMode);
  3574:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  3574: }
  1579: 
  3574: void
  3574: nsToolkit::UnregisterAllProcessMouseEventHandlers()
  3574: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 11978: 
  3574:   if (mEventTapRLS) {
  3574:     CFRunLoopRemoveSource(CFRunLoopGetCurrent(), mEventTapRLS,
  3574:                           kCFRunLoopDefaultMode);
  3574:     CFRelease(mEventTapRLS);
106838:     mEventTapRLS = nullptr;
  3574:   }
  3574:   if (mEventTapPort) {
 23419:     // mEventTapPort must be invalidated as well as released.  Otherwise the
 23419:     // event tap doesn't get destroyed until the browser process ends (it
 23419:     // keeps showing up in the list returned by CGGetEventTapList()).
 23419:     CFMachPortInvalidate(mEventTapPort);
  3574:     CFRelease(mEventTapPort);
106838:     mEventTapPort = nullptr;
  3574:   }
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK;
  1579: }
  1579: 
 80842: // Return the nsToolkit instance.  If a toolkit does not yet exist, then one
 80842: // will be created.
 80842: // static
 80842: nsToolkit* nsToolkit::GetToolkit()
     1: {
 80842:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_RETURN;
 11978: 
 80842:   if (!gToolkit) {
 80842:     gToolkit = new nsToolkit();
     1:   }
     1: 
 80842:   return gToolkit;
     1: 
106838:   NS_OBJC_END_TRY_ABORT_BLOCK_RETURN(nullptr);
     1: }
     1: 
 11675: // An alternative to [NSObject poseAsClass:] that isn't deprecated on OS X
 11675: // Leopard and is available to 64-bit binaries on Leopard and above.  Based on
 11675: // ideas and code from http://www.cocoadev.com/index.pl?MethodSwizzling.
 11675: // Since the Method type becomes an opaque type as of Objective-C 2.0, we'll
 11675: // have to switch to using accessor methods like method_exchangeImplementations()
 11675: // when we build 64-bit binaries that use Objective-C 2.0 (on and for Leopard
 11675: // and above).  But these accessor methods aren't available in Objective-C 1
 11675: // (or on Tiger).  So we need to access Method's members directly for (Tiger-
 11675: // capable) binaries (32-bit or 64-bit) that use Objective-C 1 (as long as we
 11675: // keep supporting Tiger).
 11675: //
 11675: // Be aware that, if aClass doesn't have an orgMethod selector but one of its
 11675: // superclasses does, the method substitution will (in effect) take place in
 11675: // that superclass (rather than in aClass itself).  The substitution has
 11675: // effect on the class where it takes place and all of that class's
 11675: // subclasses.  In order for method swizzling to work properly, posedMethod
 11675: // needs to be unique in the class where the substitution takes place and all
 11675: // of its subclasses.
 13630: nsresult nsToolkit::SwizzleMethods(Class aClass, SEL orgMethod, SEL posedMethod,
 79445:                                    bool classMethods)
 11675: {
 11978:   NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
 11978: 
 13630:   Method original = nil;
 13630:   Method posed = nil;
 13630: 
 13630:   if (classMethods) {
 13630:     original = class_getClassMethod(aClass, orgMethod);
 13630:     posed = class_getClassMethod(aClass, posedMethod);
 13630:   } else {
 13630:     original = class_getInstanceMethod(aClass, orgMethod);
 13630:     posed = class_getInstanceMethod(aClass, posedMethod);
 13630:   }
 11675: 
 11675:   if (!original || !posed)
 11675:     return NS_ERROR_FAILURE;
 11675: 
 31406: #ifdef __LP64__
 31406:   method_exchangeImplementations(original, posed);
 31406: #else
 11675:   IMP aMethodImp = original->method_imp;
 11675:   original->method_imp = posed->method_imp;
 11675:   posed->method_imp = aMethodImp;
 31406: #endif
 11675: 
 11675:   return NS_OK;
 11978: 
 11978:   NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 11675: }
