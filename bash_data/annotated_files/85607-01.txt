    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1999
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Boris Zbarsky <bzbarsky@mit.edu>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* rules in a CSS stylesheet other than style rules (e.g., @import rules) */
    1: 
    1: #include "nsCSSRules.h"
16545: #include "nsCSSValue.h"
63734: #include "mozilla/css/ImportRule.h"
63731: #include "mozilla/css/NameSpaceRule.h"
    1: 
    1: #include "nsString.h"
    1: #include "nsIAtom.h"
    1: #include "nsIURL.h"
    1: 
16545: #include "nsCSSProps.h"
42163: #include "nsCSSStyleSheet.h"
    1: 
    1: #include "nsCOMPtr.h"
    1: #include "nsIDOMCSSStyleSheet.h"
    1: #include "nsIMediaList.h"
20752: #include "nsICSSRuleList.h"
    1: #include "nsIDocument.h"
    1: #include "nsPresContext.h"
    1: 
    1: #include "nsContentUtils.h"
    1: #include "nsStyleConsts.h"
    1: #include "nsDOMError.h"
16545: #include "nsStyleUtil.h"
47937: #include "mozilla/css/Declaration.h"
67979: #include "nsCSSParser.h"
31706: #include "nsPrintfCString.h"
    1: 
63730: namespace css = mozilla::css;
63730: 
67978: #define IMPL_STYLE_RULE_INHERIT_GET_DOM_RULE_WEAK(class_, super_) \
69443: /* virtual */ nsIDOMCSSRule* class_::GetDOMRule() \
69443:   { return this; }
67978: #define IMPL_STYLE_RULE_INHERIT_MAP_RULE_INFO_INTO(class_, super_) \
67978: /* virtual */ void class_::MapRuleInfoInto(nsRuleData* aRuleData) \
80486:   { NS_ABORT_IF_FALSE(false, "should not be called"); }
    1: 
67978: #define IMPL_STYLE_RULE_INHERIT(class_, super_) \
67978: IMPL_STYLE_RULE_INHERIT_GET_DOM_RULE_WEAK(class_, super_) \
67978: IMPL_STYLE_RULE_INHERIT_MAP_RULE_INFO_INTO(class_, super_)
64680: 
64680: // base class for all rule types in a CSS style sheet
64680: 
64682: namespace mozilla {
64682: namespace css {
64682: 
64683: NS_IMPL_ADDREF(Rule)
64683: NS_IMPL_RELEASE(Rule)
64683: 
64680: /* virtual */ void
64682: Rule::SetStyleSheet(nsCSSStyleSheet* aSheet)
64680: {
64680:   // We don't reference count this up reference. The style sheet
64680:   // will tell us when it's going away or when we're detached from
64680:   // it.
64680:   mSheet = aSheet;
64680: }
64680: 
69442: nsresult
69442: Rule::GetParentRule(nsIDOMCSSRule** aParentRule)
69442: {
69442:   if (mParentRule) {
69443:     NS_IF_ADDREF(*aParentRule = mParentRule->GetDOMRule());
69443:   } else {
69443:     *aParentRule = nsnull;
69442:   }
69442:   return NS_OK;
69442: }
69442: 
69442: nsresult
69442: Rule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
69442: {
69442:   NS_ENSURE_ARG_POINTER(aSheet);
69442: 
69442:   NS_IF_ADDREF(*aSheet = mSheet);
69442:   return NS_OK;
69442: }
69442: 
64680: 
    1: // -------------------------------
    1: // Style Rule List for group rules
    1: //
64676: 
82651: class GroupRuleRuleList : public nsICSSRuleList
    1: {
    1: public:
64677:   GroupRuleRuleList(GroupRule *aGroupRule);
    1: 
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   NS_DECL_NSIDOMCSSRULELIST
    1: 
20752:   virtual nsIDOMCSSRule* GetItemAt(PRUint32 aIndex, nsresult* aResult);
20752: 
    1:   void DropReference() { mGroupRule = nsnull; }
    1: 
64676: private:
64676:   ~GroupRuleRuleList();
    1: 
    1: private:
64677:   GroupRule* mGroupRule;
    1: };
    1: 
64677: GroupRuleRuleList::GroupRuleRuleList(GroupRule *aGroupRule)
    1: {
    1:   // Not reference counted to avoid circular references.
    1:   // The rule will tell us when its going away.
    1:   mGroupRule = aGroupRule;
    1: }
    1: 
64676: GroupRuleRuleList::~GroupRuleRuleList()
    1: {
    1: }
    1: 
    1: // QueryInterface implementation for CSSGroupRuleRuleList
64676: NS_INTERFACE_MAP_BEGIN(GroupRuleRuleList)
20752:   NS_INTERFACE_MAP_ENTRY(nsICSSRuleList)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRuleList)
    1:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSGroupRuleRuleList)
    1: NS_INTERFACE_MAP_END
    1: 
    1: 
64676: NS_IMPL_ADDREF(GroupRuleRuleList)
64676: NS_IMPL_RELEASE(GroupRuleRuleList)
    1: 
    1: NS_IMETHODIMP
64676: GroupRuleRuleList::GetLength(PRUint32* aLength)
    1: {
    1:   if (mGroupRule) {
64679:     *aLength = (PRUint32)mGroupRule->StyleRuleCount();
    1:   } else {
    1:     *aLength = 0;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
20752: nsIDOMCSSRule*
64676: GroupRuleRuleList::GetItemAt(PRUint32 aIndex, nsresult* aResult)
    1: {
64679:   *aResult = NS_OK;
    1: 
    1:   if (mGroupRule) {
69440:     nsRefPtr<Rule> rule = mGroupRule->GetStyleRuleAt(aIndex);
    1:     if (rule) {
69443:       return rule->GetDOMRule();
20752:     }
    1:   }
20752: 
20752:   return nsnull;
20752: }
20752: 
20752: NS_IMETHODIMP
64676: GroupRuleRuleList::Item(PRUint32 aIndex, nsIDOMCSSRule** aReturn)
20752: {
20752:   nsresult rv;
20752:   nsIDOMCSSRule* rule = GetItemAt(aIndex, &rv);
20752:   if (!rule) {
20752:     *aReturn = nsnull;
20752:     return rv;
20752:   }
20752: 
47889:   NS_ADDREF(*aReturn = rule);
47889:   return NS_OK;
    1: }
    1: 
64676: } // namespace css
64676: } // namespace mozilla
64676: 
64676: // Must be outside the namespace
64676: DOMCI_DATA(CSSGroupRuleRuleList, css::GroupRuleRuleList)
64676: 
    1: // -------------------------------------------
    1: // CharsetRule
    1: //
    1: 
64688: // Must be outside namespace
64688: DOMCI_DATA(CSSCharsetRule, css::CharsetRule)
    1: 
64688: namespace mozilla {
64688: namespace css {
    1: 
64688: CharsetRule::CharsetRule(const nsAString& aEncoding)
69442:   : Rule(),
    1:     mEncoding(aEncoding)
    1: {
    1: }
    1: 
64688: CharsetRule::CharsetRule(const CharsetRule& aCopy)
69442:   : Rule(aCopy),
    1:     mEncoding(aCopy.mEncoding)
    1: {
    1: }
    1: 
69442: NS_IMPL_ADDREF_INHERITED(CharsetRule, Rule)
69442: NS_IMPL_RELEASE_INHERITED(CharsetRule, Rule)
    1: 
64688: // QueryInterface implementation for CharsetRule
64688: NS_INTERFACE_MAP_BEGIN(CharsetRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSCharsetRule)
69440:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStyleRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSCharsetRule)
    1: NS_INTERFACE_MAP_END
    1: 
69442: IMPL_STYLE_RULE_INHERIT(CharsetRule, Rule)
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
64688: CharsetRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   // Indent
    1:   for (PRInt32 indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   fputs("@charset \"", out);
    1:   fputs(NS_LossyConvertUTF16toASCII(mEncoding).get(), out);
    1:   fputs("\"\n", out);
    1: }
    1: #endif
    1: 
47887: /* virtual */ PRInt32
64688: CharsetRule::GetType() const
    1: {
69440:   return Rule::CHARSET_RULE;
    1: }
    1: 
69440: /* virtual */ already_AddRefed<Rule>
64688: CharsetRule::Clone() const
    1: {
69440:   nsRefPtr<Rule> clone = new CharsetRule(*this);
50636:   return clone.forget();
    1: }
    1: 
    1: NS_IMETHODIMP
64688: CharsetRule::GetEncoding(nsAString& aEncoding)
    1: {
    1:   aEncoding = mEncoding;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
64688: CharsetRule::SetEncoding(const nsAString& aEncoding)
    1: {
    1:   mEncoding = aEncoding;
    1:   return NS_OK;
    1: }
    1: 
64688: NS_IMETHODIMP
64688: CharsetRule::GetType(PRUint16* aType)
64688: {
64688:   *aType = nsIDOMCSSRule::CHARSET_RULE;
64688:   return NS_OK;
64688: }
64688: 
64688: NS_IMETHODIMP
64688: CharsetRule::GetCssText(nsAString& aCssText)
64688: {
64688:   aCssText.AssignLiteral("@charset \"");
64688:   aCssText.Append(mEncoding);
64688:   aCssText.AppendLiteral("\";");
64688:   return NS_OK;
64688: }
64688: 
64688: NS_IMETHODIMP
64688: CharsetRule::SetCssText(const nsAString& aCssText)
64688: {
64688:   return NS_ERROR_NOT_IMPLEMENTED;
64688: }
64688: 
64688: NS_IMETHODIMP
64688: CharsetRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
64688: {
69442:   return Rule::GetParentStyleSheet(aSheet);
64688: }
64688: 
64688: NS_IMETHODIMP
64688: CharsetRule::GetParentRule(nsIDOMCSSRule** aParentRule)
64688: {
69442:   return Rule::GetParentRule(aParentRule);
64688: }
64688: 
    1: 
    1: 
    1: // -------------------------------------------
63733: // ImportRule
    1: //
63733: 
64686: ImportRule::ImportRule(nsMediaList* aMedia, const nsString& aURLSpec)
64682:   : Rule()
64686:   , mURLSpec(aURLSpec)
    1:   , mMedia(aMedia)
    1: {
    1:   // XXXbz This is really silly.... the mMedia here will be replaced
    1:   // with itself if we manage to load a sheet.  Which should really
    1:   // never fail nowadays, in sane cases.
    1: }
    1: 
63733: ImportRule::ImportRule(const ImportRule& aCopy)
64682:   : Rule(aCopy),
    1:     mURLSpec(aCopy.mURLSpec)
    1: {
64400:   // Whether or not an @import rule has a null sheet is a permanent
64400:   // property of that @import rule, since it is null only if the target
64400:   // sheet failed security checks.
    1:   if (aCopy.mChildSheet) {
64400:     nsRefPtr<nsCSSStyleSheet> sheet =
64400:       aCopy.mChildSheet->Clone(nsnull, this, nsnull, nsnull);
    1:     SetSheet(sheet);
    1:     // SetSheet sets mMedia appropriately
    1:   }
64400: }
    1: 
63733: ImportRule::~ImportRule()
    1: {
    1:   if (mChildSheet) {
    1:     mChildSheet->SetOwnerRule(nsnull);
    1:   }
    1: }
    1: 
64683: NS_IMPL_ADDREF_INHERITED(ImportRule, Rule)
64683: NS_IMPL_RELEASE_INHERITED(ImportRule, Rule)
    1: 
63733: // QueryInterface implementation for ImportRule
63733: NS_INTERFACE_MAP_BEGIN(ImportRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSImportRule)
69440:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStyleRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSImportRule)
    1: NS_INTERFACE_MAP_END
    1: 
64682: IMPL_STYLE_RULE_INHERIT(ImportRule, Rule)
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
63733: ImportRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   // Indent
    1:   for (PRInt32 indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   fputs("@import \"", out);
    1:   fputs(NS_LossyConvertUTF16toASCII(mURLSpec).get(), out);
    1:   fputs("\" ", out);
    1: 
    1:   nsAutoString mediaText;
    1:   mMedia->GetText(mediaText);
    1:   fputs(NS_LossyConvertUTF16toASCII(mediaText).get(), out);
    1:   fputs("\n", out);
    1: }
    1: #endif
    1: 
47887: /* virtual */ PRInt32
63733: ImportRule::GetType() const
    1: {
69440:   return Rule::IMPORT_RULE;
    1: }
    1: 
69440: /* virtual */ already_AddRefed<Rule>
63733: ImportRule::Clone() const
    1: {
69440:   nsRefPtr<Rule> clone = new ImportRule(*this);
50636:   return clone.forget();
    1: }
    1: 
63735: void
63733: ImportRule::SetSheet(nsCSSStyleSheet* aSheet)
    1: {
63735:   NS_PRECONDITION(aSheet, "null arg");
    1: 
    1:   // set the new sheet
    1:   mChildSheet = aSheet;
    1:   aSheet->SetOwnerRule(this);
    1: 
    1:   // set our medialist to be the same as the sheet's medialist
    1:   nsCOMPtr<nsIDOMMediaList> mediaList;
63735:   mChildSheet->GetMedia(getter_AddRefs(mediaList));
63735:   NS_ABORT_IF_FALSE(mediaList, "GetMedia returned null");
 3233:   mMedia = static_cast<nsMediaList*>(mediaList.get());
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetType(PRUint16* aType)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aType);
    1:   *aType = nsIDOMCSSRule::IMPORT_RULE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AssignLiteral("@import url(");
25794:   nsStyleUtil::AppendEscapedCSSString(mURLSpec, aCssText);
    1:   aCssText.Append(NS_LITERAL_STRING(")"));
    1:   if (mMedia) {
    1:     nsAutoString mediaText;
    1:     mMedia->GetText(mediaText);
    1:     if (!mediaText.IsEmpty()) {
    1:       aCssText.AppendLiteral(" ");
    1:       aCssText.Append(mediaText);
    1:     }
    1:   }
    1:   aCssText.AppendLiteral(";");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::SetCssText(const nsAString& aCssText)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
69442:   return Rule::GetParentStyleSheet(aSheet);
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
69442:   return Rule::GetParentRule(aParentRule);
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetHref(nsAString & aHref)
    1: {
    1:   aHref = mURLSpec;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetMedia(nsIDOMMediaList * *aMedia)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aMedia);
47889: 
47889:   NS_IF_ADDREF(*aMedia = mMedia);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63733: ImportRule::GetStyleSheet(nsIDOMCSSStyleSheet * *aStyleSheet)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aStyleSheet);
42969: 
42969:   NS_IF_ADDREF(*aStyleSheet = mChildSheet);
    1:   return NS_OK;
    1: }
    1: 
63733: } // namespace css
63733: } // namespace mozilla
63733: 
63733: // must be outside the namespace
63733: DOMCI_DATA(CSSImportRule, css::ImportRule)
63733: 
79445: static bool
69440: CloneRuleInto(css::Rule* aRule, void* aArray)
    1: {
69440:   nsRefPtr<css::Rule> clone = aRule->Clone();
69440:   static_cast<nsCOMArray<css::Rule>*>(aArray)->AppendObject(clone);
80486:   return true;
    1: }
    1: 
64677: namespace mozilla {
64677: namespace css {
64677: 
64677: GroupRule::GroupRule()
64682:   : Rule()
64677: {
64677: }
64677: 
79445: static bool
69440: SetParentRuleReference(Rule* aRule, void* aParentRule)
    1: {
64677:   GroupRule* parentRule = static_cast<GroupRule*>(aParentRule);
    1:   aRule->SetParentRule(parentRule);
80486:   return true;
    1: }
    1: 
64677: GroupRule::GroupRule(const GroupRule& aCopy)
64682:   : Rule(aCopy)
    1: {
64677:   const_cast<GroupRule&>(aCopy).mRules.EnumerateForwards(CloneRuleInto, &mRules);
    1:   mRules.EnumerateForwards(SetParentRuleReference, this);
    1: }
    1: 
64677: GroupRule::~GroupRule()
    1: {
69252:   NS_ABORT_IF_FALSE(!mSheet, "SetStyleSheet should have been called");
    1:   mRules.EnumerateForwards(SetParentRuleReference, nsnull);
    1:   if (mRuleCollection) {
    1:     mRuleCollection->DropReference();
    1:   }
    1: }
    1: 
67978: IMPL_STYLE_RULE_INHERIT_MAP_RULE_INFO_INTO(GroupRule, Rule)
    1: 
79445: static bool
69440: SetStyleSheetReference(Rule* aRule, void* aSheet)
    1: {
42163:   nsCSSStyleSheet* sheet = (nsCSSStyleSheet*)aSheet;
    1:   aRule->SetStyleSheet(sheet);
80486:   return true;
    1: }
    1: 
47887: /* virtual */ void
64677: GroupRule::SetStyleSheet(nsCSSStyleSheet* aSheet)
    1: {
    1:   mRules.EnumerateForwards(SetStyleSheetReference, aSheet);
64682:   Rule::SetStyleSheet(aSheet);
    1: }
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
64677: GroupRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   fputs(" {\n", out);
    1: 
    1:   for (PRInt32 index = 0, count = mRules.Count(); index < count; ++index) {
    1:     mRules.ObjectAt(index)->List(out, aIndent + 1);
    1:   }
    1:   fputs("}\n", out);
    1: }
    1: #endif
    1: 
64679: void
69440: GroupRule::AppendStyleRule(Rule* aRule)
    1: {
    1:   mRules.AppendObject(aRule);
    1:   aRule->SetStyleSheet(mSheet);
    1:   aRule->SetParentRule(this);
    1:   if (mSheet) {
67977:     mSheet->SetModifiedByChildRule();
    1:   }
    1: }
    1: 
69440: Rule*
64679: GroupRule::GetStyleRuleAt(PRInt32 aIndex) const
    1: {
64679:   return mRules.SafeObjectAt(aIndex);
    1: }
    1: 
79445: bool
64677: GroupRule::EnumerateRulesForwards(RuleEnumFunc aFunc, void * aData) const
    1: {
 9093:   return
64677:     const_cast<GroupRule*>(this)->mRules.EnumerateForwards(aFunc, aData);
    1: }
    1: 
    1: /*
    1:  * The next two methods (DeleteStyleRuleAt and InsertStyleRulesAt)
    1:  * should never be called unless you have first called WillDirty() on
    1:  * the parents tylesheet.  After they are called, DidDirty() needs to
    1:  * be called on the sheet
    1:  */
64679: nsresult
64677: GroupRule::DeleteStyleRuleAt(PRUint32 aIndex)
    1: {
69440:   Rule* rule = mRules.SafeObjectAt(aIndex);
    1:   if (rule) {
    1:     rule->SetStyleSheet(nsnull);
    1:     rule->SetParentRule(nsnull);
    1:   }
    1:   return mRules.RemoveObjectAt(aIndex) ? NS_OK : NS_ERROR_ILLEGAL_VALUE;
    1: }
    1: 
64679: nsresult
64677: GroupRule::InsertStyleRulesAt(PRUint32 aIndex,
69440:                               nsCOMArray<Rule>& aRules)
    1: {
    1:   aRules.EnumerateForwards(SetStyleSheetReference, mSheet);
    1:   aRules.EnumerateForwards(SetParentRuleReference, this);
    1:   if (! mRules.InsertObjectsAt(aRules, aIndex)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1:   return NS_OK;
    1: }
    1: 
64679: nsresult
69440: GroupRule::ReplaceStyleRule(Rule* aOld, Rule* aNew)
    1: {
    1:   PRInt32 index = mRules.IndexOf(aOld);
    1:   NS_ENSURE_TRUE(index != -1, NS_ERROR_UNEXPECTED);
    1:   mRules.ReplaceObjectAt(aNew, index);
    1:   aNew->SetStyleSheet(mSheet);
    1:   aNew->SetParentRule(this);
    1:   aOld->SetStyleSheet(nsnull);
    1:   aOld->SetParentRule(nsnull);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
64677: GroupRule::AppendRulesToCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AppendLiteral(" {\n");
    1: 
    1:   // get all the rules
    1:   for (PRInt32 index = 0, count = mRules.Count(); index < count; ++index) {
69440:     Rule* rule = mRules.ObjectAt(index);
69443:     nsIDOMCSSRule* domRule = rule->GetDOMRule();
    1:     if (domRule) {
    1:       nsAutoString cssText;
    1:       domRule->GetCssText(cssText);
    1:       aCssText.Append(NS_LITERAL_STRING("  ") +
    1:                       cssText +
    1:                       NS_LITERAL_STRING("\n"));
    1:     }
    1:   }
    1: 
    1:   aCssText.AppendLiteral("}");
    1:   
    1:   return NS_OK;
    1: }
    1: 
69442: // nsIDOMCSSMediaRule or nsIDOMCSSMozDocumentRule methods
    1: nsresult
69442: GroupRule::GetCssRules(nsIDOMCSSRuleList* *aRuleList)
    1: {
    1:   if (!mRuleCollection) {
64676:     mRuleCollection = new css::GroupRuleRuleList(this);
    1:   }
    1: 
69442:   NS_ADDREF(*aRuleList = mRuleCollection);
69442:   return NS_OK;
    1: }
    1: 
    1: nsresult
64677: GroupRule::InsertRule(const nsAString & aRule, PRUint32 aIndex, PRUint32* _retval)
    1: {
    1:   NS_ENSURE_TRUE(mSheet, NS_ERROR_FAILURE);
    1:   
    1:   if (aIndex > PRUint32(mRules.Count()))
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1: 
    1:   NS_ASSERTION(PRUint32(mRules.Count()) <= PR_INT32_MAX,
    1:                "Too many style rules!");
    1: 
    1:   return mSheet->InsertRuleIntoGroup(aRule, this, aIndex, _retval);
    1: }
    1: 
    1: nsresult
64677: GroupRule::DeleteRule(PRUint32 aIndex)
    1: {
    1:   NS_ENSURE_TRUE(mSheet, NS_ERROR_FAILURE);
    1: 
    1:   if (aIndex >= PRUint32(mRules.Count()))
    1:     return NS_ERROR_DOM_INDEX_SIZE_ERR;
    1: 
    1:   NS_ASSERTION(PRUint32(mRules.Count()) <= PR_INT32_MAX,
    1:                "Too many style rules!");
    1: 
    1:   return mSheet->DeleteRuleFromGroup(this, aIndex);
    1: }
    1: 
64677: 
    1: // -------------------------------------------
    1: // nsICSSMediaRule
    1: //
64678: MediaRule::MediaRule()
    1: {
    1: }
    1: 
64678: MediaRule::MediaRule(const MediaRule& aCopy)
64677:   : GroupRule(aCopy)
    1: {
    1:   if (aCopy.mMedia) {
    1:     aCopy.mMedia->Clone(getter_AddRefs(mMedia));
    1:     if (mMedia) {
    1:       // XXXldb This doesn't really make sense.
    1:       mMedia->SetStyleSheet(aCopy.mSheet);
    1:     }
    1:   }
    1: }
    1: 
64678: MediaRule::~MediaRule()
    1: {
    1:   if (mMedia) {
    1:     mMedia->SetStyleSheet(nsnull);
    1:   }
    1: }
    1: 
69444: NS_IMPL_ADDREF_INHERITED(MediaRule, GroupRule)
69444: NS_IMPL_RELEASE_INHERITED(MediaRule, GroupRule)
    1: 
64678: // QueryInterface implementation for MediaRule
64678: NS_INTERFACE_MAP_BEGIN(MediaRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSMediaRule)
69440:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStyleRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSMediaRule)
    1: NS_INTERFACE_MAP_END
    1: 
47887: /* virtual */ void
64678: MediaRule::SetStyleSheet(nsCSSStyleSheet* aSheet)
    1: {
    1:   if (mMedia) {
    1:     // Set to null so it knows it's leaving one sheet and joining another.
    1:     mMedia->SetStyleSheet(nsnull);
    1:     mMedia->SetStyleSheet(aSheet);
    1:   }
    1: 
64677:   GroupRule::SetStyleSheet(aSheet);
    1: }
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
64678: MediaRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   for (PRInt32 indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   nsAutoString  buffer;
    1: 
    1:   fputs("@media ", out);
    1: 
    1:   if (mMedia) {
    1:     nsAutoString mediaText;
    1:     mMedia->GetText(mediaText);
    1:     fputs(NS_LossyConvertUTF16toASCII(mediaText).get(), out);
    1:   }
    1: 
64677:   GroupRule::List(out, aIndent);
    1: }
    1: #endif
    1: 
47887: /* virtual */ PRInt32
64678: MediaRule::GetType() const
    1: {
69440:   return Rule::MEDIA_RULE;
    1: }
    1: 
69440: /* virtual */ already_AddRefed<Rule>
64678: MediaRule::Clone() const
    1: {
69440:   nsRefPtr<Rule> clone = new MediaRule(*this);
50636:   return clone.forget();
    1: }
    1: 
    1: nsresult
64678: MediaRule::SetMedia(nsMediaList* aMedia)
    1: {
    1:   mMedia = aMedia;
    1:   if (aMedia)
    1:     mMedia->SetStyleSheet(mSheet);
    1:   return NS_OK;
    1: }
    1: 
    1: // nsIDOMCSSRule methods
    1: NS_IMETHODIMP
64678: MediaRule::GetType(PRUint16* aType)
    1: {
    1:   *aType = nsIDOMCSSRule::MEDIA_RULE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
64678: MediaRule::GetCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AssignLiteral("@media ");
    1:   // get all the media
    1:   if (mMedia) {
    1:     nsAutoString mediaText;
    1:     mMedia->GetText(mediaText);
    1:     aCssText.Append(mediaText);
    1:   }
    1: 
64677:   return GroupRule::AppendRulesToCssText(aCssText);
    1: }
    1: 
    1: NS_IMETHODIMP
64678: MediaRule::SetCssText(const nsAString& aCssText)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
64678: MediaRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
69442:   return GroupRule::GetParentStyleSheet(aSheet);
    1: }
    1: 
    1: NS_IMETHODIMP
64678: MediaRule::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
64677:   return GroupRule::GetParentRule(aParentRule);
    1: }
    1: 
    1: // nsIDOMCSSMediaRule methods
    1: NS_IMETHODIMP
64678: MediaRule::GetMedia(nsIDOMMediaList* *aMedia)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aMedia);
47889:   NS_IF_ADDREF(*aMedia = mMedia);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
64678: MediaRule::GetCssRules(nsIDOMCSSRuleList* *aRuleList)
    1: {
69442:   return GroupRule::GetCssRules(aRuleList);
    1: }
    1: 
    1: NS_IMETHODIMP
64678: MediaRule::InsertRule(const nsAString & aRule, PRUint32 aIndex, PRUint32* _retval)
    1: {
64677:   return GroupRule::InsertRule(aRule, aIndex, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
64678: MediaRule::DeleteRule(PRUint32 aIndex)
    1: {
64677:   return GroupRule::DeleteRule(aIndex);
    1: }
    1: 
64677: // GroupRule interface
79445: /* virtual */ bool
64678: MediaRule::UseForPresentation(nsPresContext* aPresContext,
16223:                                    nsMediaQueryResultCacheKey& aKey)
    1: {
    1:   if (mMedia) {
68768:     return mMedia->Matches(aPresContext, &aKey);
    1:   }
80486:   return true;
    1: }
    1: 
64678: } // namespace css
64678: } // namespace mozilla
    1: 
64678: // Must be outside namespace
64678: DOMCI_DATA(CSSMediaRule, css::MediaRule)
64678: 
64678: namespace mozilla {
64678: namespace css {
64678: 
64678: DocumentRule::DocumentRule()
    1: {
    1: }
    1: 
64678: DocumentRule::DocumentRule(const DocumentRule& aCopy)
64677:   : GroupRule(aCopy)
    1:   , mURLs(new URL(*aCopy.mURLs))
    1: {
    1: }
    1: 
64678: DocumentRule::~DocumentRule()
    1: {
    1: }
    1: 
69444: NS_IMPL_ADDREF_INHERITED(DocumentRule, GroupRule)
69444: NS_IMPL_RELEASE_INHERITED(DocumentRule, GroupRule)
    1: 
64678: // QueryInterface implementation for DocumentRule
64678: NS_INTERFACE_MAP_BEGIN(DocumentRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSMozDocumentRule)
69440:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStyleRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSMozDocumentRule)
    1: NS_INTERFACE_MAP_END
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
64678: DocumentRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   for (PRInt32 indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   nsCAutoString str;
    1:   str.AssignLiteral("@-moz-document ");
    1:   for (URL *url = mURLs; url; url = url->next) {
    1:     switch (url->func) {
    1:       case eURL:
    1:         str.AppendLiteral("url(\"");
    1:         break;
    1:       case eURLPrefix:
    1:         str.AppendLiteral("url-prefix(\"");
    1:         break;
    1:       case eDomain:
    1:         str.AppendLiteral("domain(\"");
71658:         break;
69073:       case eRegExp:
69073:         str.AppendLiteral("regexp(\"");
    1:         break;
    1:     }
    1:     nsCAutoString escapedURL(url->url);
    1:     escapedURL.ReplaceSubstring("\"", "\\\""); // escape quotes
    1:     str.Append(escapedURL);
    1:     str.AppendLiteral("\"), ");
    1:   }
    1:   str.Cut(str.Length() - 2, 1); // remove last ,
    1:   fputs(str.get(), out);
    1: 
64677:   GroupRule::List(out, aIndent);
    1: }
    1: #endif
    1: 
47887: /* virtual */ PRInt32
64678: DocumentRule::GetType() const
    1: {
69440:   return Rule::DOCUMENT_RULE;
    1: }
    1: 
69440: /* virtual */ already_AddRefed<Rule>
64678: DocumentRule::Clone() const
    1: {
69440:   nsRefPtr<Rule> clone = new DocumentRule(*this);
50636:   return clone.forget();
    1: }
    1: 
    1: // nsIDOMCSSRule methods
    1: NS_IMETHODIMP
64678: DocumentRule::GetType(PRUint16* aType)
    1: {
    1:   // XXX What should really happen here?
    1:   *aType = nsIDOMCSSRule::UNKNOWN_RULE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
64678: DocumentRule::GetCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AssignLiteral("@-moz-document ");
    1:   for (URL *url = mURLs; url; url = url->next) {
    1:     switch (url->func) {
    1:       case eURL:
25794:         aCssText.AppendLiteral("url(");
    1:         break;
    1:       case eURLPrefix:
25794:         aCssText.AppendLiteral("url-prefix(");
    1:         break;
    1:       case eDomain:
25794:         aCssText.AppendLiteral("domain(");
    1:         break;
69073:       case eRegExp:
69073:         aCssText.AppendLiteral("regexp(");
69073:         break;
    1:     }
25794:     nsStyleUtil::AppendEscapedCSSString(NS_ConvertUTF8toUTF16(url->url),
25794:                                         aCssText);
25794:     aCssText.AppendLiteral("), ");
    1:   }
    1:   aCssText.Cut(aCssText.Length() - 2, 1); // remove last ,
    1: 
64677:   return GroupRule::AppendRulesToCssText(aCssText);
    1: }
    1: 
    1: NS_IMETHODIMP
64678: DocumentRule::SetCssText(const nsAString& aCssText)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
64678: DocumentRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
69442:   return GroupRule::GetParentStyleSheet(aSheet);
    1: }
    1: 
    1: NS_IMETHODIMP
64678: DocumentRule::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
64677:   return GroupRule::GetParentRule(aParentRule);
    1: }
    1: 
    1: NS_IMETHODIMP
64678: DocumentRule::GetCssRules(nsIDOMCSSRuleList* *aRuleList)
    1: {
69442:   return GroupRule::GetCssRules(aRuleList);
    1: }
    1: 
    1: NS_IMETHODIMP
64678: DocumentRule::InsertRule(const nsAString & aRule, PRUint32 aIndex, PRUint32* _retval)
    1: {
64677:   return GroupRule::InsertRule(aRule, aIndex, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
64678: DocumentRule::DeleteRule(PRUint32 aIndex)
    1: {
64677:   return GroupRule::DeleteRule(aIndex);
    1: }
    1: 
64677: // GroupRule interface
79445: /* virtual */ bool
64678: DocumentRule::UseForPresentation(nsPresContext* aPresContext,
16223:                                  nsMediaQueryResultCacheKey& aKey)
    1: {
69073:   nsIDocument *doc = aPresContext->Document();
69073:   nsIURI *docURI = doc->GetDocumentURI();
    1:   nsCAutoString docURISpec;
    1:   if (docURI)
    1:     docURI->GetSpec(docURISpec);
    1: 
    1:   for (URL *url = mURLs; url; url = url->next) {
    1:     switch (url->func) {
    1:       case eURL: {
    1:         if (docURISpec == url->url)
80486:           return true;
    1:       } break;
    1:       case eURLPrefix: {
    1:         if (StringBeginsWith(docURISpec, url->url))
80486:           return true;
    1:       } break;
    1:       case eDomain: {
    1:         nsCAutoString host;
    1:         if (docURI)
    1:           docURI->GetHost(host);
    1:         PRInt32 lenDiff = host.Length() - url->url.Length();
    1:         if (lenDiff == 0) {
    1:           if (host == url->url)
80486:             return true;
    1:         } else {
    1:           if (StringEndsWith(host, url->url) &&
    1:               host.CharAt(lenDiff - 1) == '.')
80486:             return true;
    1:         }
    1:       } break;
69073:       case eRegExp: {
69073:         NS_ConvertUTF8toUTF16 spec(docURISpec);
69073:         NS_ConvertUTF8toUTF16 regex(url->url);
69073:         if (nsContentUtils::IsPatternMatching(spec, regex, doc)) {
80486:           return true;
69073:         }
69073:       } break;
    1:     }
    1:   }
    1: 
80486:   return false;
    1: }
    1: 
64678: DocumentRule::URL::~URL()
23837: {
64678:   NS_CSS_DELETE_LIST_MEMBER(DocumentRule::URL, this, next);
23837: }
    1: 
64678: } // namespace css
64678: } // namespace mozilla
64678: 
64678: // Must be outside namespace
64678: DOMCI_DATA(CSSMozDocumentRule, css::DocumentRule)
64678: 
    1: // -------------------------------------------
63730: // NameSpaceRule
    1: //
63730: 
63730: namespace mozilla {
63730: namespace css {
63730: 
64687: NameSpaceRule::NameSpaceRule(nsIAtom* aPrefix, const nsString& aURLSpec)
64682:   : Rule(),
64687:     mPrefix(aPrefix),
64687:     mURLSpec(aURLSpec)
    1: {
    1: }
    1: 
63730: NameSpaceRule::NameSpaceRule(const NameSpaceRule& aCopy)
64682:   : Rule(aCopy),
    1:     mPrefix(aCopy.mPrefix),
    1:     mURLSpec(aCopy.mURLSpec)
    1: {
    1: }
    1: 
63730: NameSpaceRule::~NameSpaceRule()
    1: {
    1: }
    1: 
64683: NS_IMPL_ADDREF_INHERITED(NameSpaceRule, Rule)
64683: NS_IMPL_RELEASE_INHERITED(NameSpaceRule, Rule)
    1: 
63730: // QueryInterface implementation for NameSpaceRule
63730: NS_INTERFACE_MAP_BEGIN(NameSpaceRule)
63731:   if (aIID.Equals(NS_GET_IID(css::NameSpaceRule))) {
63731:     *aInstancePtr = this;
63731:     NS_ADDREF_THIS();
63731:     return NS_OK;
63731:   }
63731:   else
    1:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
69440:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStyleRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSNameSpaceRule)
    1: NS_INTERFACE_MAP_END
    1: 
64682: IMPL_STYLE_RULE_INHERIT(NameSpaceRule, Rule)
    1: 
    1: #ifdef DEBUG
43120: /* virtual */ void
63730: NameSpaceRule::List(FILE* out, PRInt32 aIndent) const
    1: {
    1:   for (PRInt32 indent = aIndent; --indent >= 0; ) fputs("  ", out);
    1: 
    1:   nsAutoString  buffer;
    1: 
    1:   fputs("@namespace ", out);
    1: 
    1:   if (mPrefix) {
    1:     mPrefix->ToString(buffer);
    1:     fputs(NS_LossyConvertUTF16toASCII(buffer).get(), out);
    1:     fputs(" ", out);
    1:   }
    1: 
    1:   fputs("url(", out);
    1:   fputs(NS_LossyConvertUTF16toASCII(mURLSpec).get(), out);
    1:   fputs(")\n", out);
    1: }
    1: #endif
    1: 
47887: /* virtual */ PRInt32
63730: NameSpaceRule::GetType() const
    1: {
69440:   return Rule::NAMESPACE_RULE;
    1: }
    1: 
69440: /* virtual */ already_AddRefed<Rule>
63730: NameSpaceRule::Clone() const
    1: {
69440:   nsRefPtr<Rule> clone = new NameSpaceRule(*this);
50636:   return clone.forget();
    1: }
    1: 
    1: NS_IMETHODIMP
63730: NameSpaceRule::GetType(PRUint16* aType)
    1: {
    1:   // XXX What should really happen here?
    1:   *aType = nsIDOMCSSRule::UNKNOWN_RULE;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63730: NameSpaceRule::GetCssText(nsAString& aCssText)
    1: {
    1:   aCssText.AssignLiteral("@namespace ");
    1:   if (mPrefix) {
39101:     aCssText.Append(nsDependentAtomString(mPrefix) + NS_LITERAL_STRING(" "));
    1:   }
    1:   aCssText.AppendLiteral("url(");
25794:   nsStyleUtil::AppendEscapedCSSString(mURLSpec, aCssText);
    1:   aCssText.Append(NS_LITERAL_STRING(");"));
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
63730: NameSpaceRule::SetCssText(const nsAString& aCssText)
    1: {
    1:   return NS_ERROR_NOT_IMPLEMENTED;
    1: }
    1: 
    1: NS_IMETHODIMP
63730: NameSpaceRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
    1: {
69442:   return Rule::GetParentStyleSheet(aSheet);
    1: }
    1: 
    1: NS_IMETHODIMP
63730: NameSpaceRule::GetParentRule(nsIDOMCSSRule** aParentRule)
    1: {
69442:   return Rule::GetParentRule(aParentRule);
    1: }
16545: 
63730: } // namespace css
63730: } // namespace mozilla
63730: 
63730: // Must be outside namespace
63730: DOMCI_DATA(CSSNameSpaceRule, css::NameSpaceRule)
63730: 
16545: // -------------------------------------------
16545: // nsCSSFontFaceStyleDecl and related routines
16545: //
16545: 
16545: // A src: descriptor is represented as an array value; each entry in
16545: // the array can be eCSSUnit_URL, eCSSUnit_Local_Font, or
16545: // eCSSUnit_Font_Format.  Blocks of eCSSUnit_Font_Format may appear
16545: // only after one of the first two.  (css3-fonts only contemplates
16545: // annotating URLs with formats, but we handle the general case.)
16545: static void
25952: AppendSerializedFontSrc(const nsCSSValue& src, nsAString & aResult NS_OUTPARAM)
16545: {
25952:   NS_PRECONDITION(src.GetUnit() == eCSSUnit_Array,
16545:                   "improper value unit for src:");
16545: 
16545:   const nsCSSValue::Array& sources = *src.GetArrayValue();
46243:   size_t i = 0;
16545: 
16545:   while (i < sources.Count()) {
16545:     nsAutoString formats;
16545: 
16545:     if (sources[i].GetUnit() == eCSSUnit_URL) {
25793:       aResult.AppendLiteral("url(");
16545:       nsDependentString url(sources[i].GetOriginalURLValue());
25793:       nsStyleUtil::AppendEscapedCSSString(url, aResult);
25793:       aResult.AppendLiteral(")");
16545:     } else if (sources[i].GetUnit() == eCSSUnit_Local_Font) {
25793:       aResult.AppendLiteral("local(");
16545:       nsDependentString local(sources[i].GetStringBufferValue());
25793:       nsStyleUtil::AppendEscapedCSSString(local, aResult);
25793:       aResult.AppendLiteral(")");
16545:     } else {
16545:       NS_NOTREACHED("entry in src: descriptor with improper unit");
16545:       i++;
16545:       continue;
16545:     }
16545: 
16545:     i++;
16545:     formats.Truncate();
16545:     while (i < sources.Count() &&
16545:            sources[i].GetUnit() == eCSSUnit_Font_Format) {
16545:       formats.Append('"');
16545:       formats.Append(sources[i].GetStringBufferValue());
16545:       formats.AppendLiteral("\", ");
16545:       i++;
16545:     }
16545:     if (formats.Length() > 0) {
16545:       formats.Truncate(formats.Length() - 2); // remove the last comma
16545:       aResult.AppendLiteral(" format(");
16545:       aResult.Append(formats);
16545:       aResult.Append(')');
16545:     }
16545:     aResult.AppendLiteral(", ");
16545:   }
16545:   aResult.Truncate(aResult.Length() - 2); // remove the last comma-space
16545: }
16545: 
31706: // print all characters with at least four hex digits
31706: static void
31706: AppendSerializedUnicodePoint(PRUint32 aCode, nsACString &aBuf NS_OUTPARAM)
31706: {
31706:   aBuf.Append(nsPrintfCString("%04X", aCode));
31706: }
31706: 
31706: // A unicode-range: descriptor is represented as an array of integers,
31706: // to be interpreted as a sequence of pairs: min max min max ...
31706: // It is in source order.  (Possibly it should be sorted and overlaps
31706: // consolidated, but right now we don't do that.)
31706: static void
31706: AppendSerializedUnicodeRange(nsCSSValue const & aValue,
31706:                              nsAString & aResult NS_OUTPARAM)
31706: {
31706:   NS_PRECONDITION(aValue.GetUnit() == eCSSUnit_Null ||
31706:                   aValue.GetUnit() == eCSSUnit_Array,
31706:                   "improper value unit for unicode-range:");
31706:   aResult.Truncate();
31706:   if (aValue.GetUnit() != eCSSUnit_Array)
31706:     return;
31706: 
31706:   nsCSSValue::Array const & sources = *aValue.GetArrayValue();
31706:   nsCAutoString buf;
31706: 
31706:   NS_ABORT_IF_FALSE(sources.Count() % 2 == 0,
31706:                     "odd number of entries in a unicode-range: array");
31706: 
31706:   for (PRUint32 i = 0; i < sources.Count(); i += 2) {
31706:     PRUint32 min = sources[i].GetIntValue();
31706:     PRUint32 max = sources[i+1].GetIntValue();
31706: 
31706:     // We don't try to replicate the U+XX?? notation.
31706:     buf.AppendLiteral("U+");
31706:     AppendSerializedUnicodePoint(min, buf);
31706: 
31706:     if (min != max) {
31706:       buf.Append('-');
31706:       AppendSerializedUnicodePoint(max, buf);
31706:     }
31706:     buf.AppendLiteral(", ");
31706:   }
31706:   buf.Truncate(buf.Length() - 2); // remove the last comma-space
31706:   CopyASCIItoUTF16(buf, aResult);
31706: }
31706: 
16545: // Mapping from nsCSSFontDesc codes to nsCSSFontFaceStyleDecl fields.
16545: // Keep this in sync with enum nsCSSFontDesc in nsCSSProperty.h.
16545: nsCSSValue nsCSSFontFaceStyleDecl::* const
16545: nsCSSFontFaceStyleDecl::Fields[] = {
16545:     &nsCSSFontFaceStyleDecl::mFamily,
16545:     &nsCSSFontFaceStyleDecl::mStyle,
16545:     &nsCSSFontFaceStyleDecl::mWeight,
16545:     &nsCSSFontFaceStyleDecl::mStretch,
16545:     &nsCSSFontFaceStyleDecl::mSrc,
47359:     &nsCSSFontFaceStyleDecl::mUnicodeRange,
47359:     &nsCSSFontFaceStyleDecl::mFontFeatureSettings,
47359:     &nsCSSFontFaceStyleDecl::mFontLanguageOverride
16545: };
16545: 
40490: DOMCI_DATA(CSSFontFaceStyleDecl, nsCSSFontFaceStyleDecl)
40490: 
16545: // QueryInterface implementation for nsCSSFontFaceStyleDecl
16545: NS_INTERFACE_MAP_BEGIN(nsCSSFontFaceStyleDecl)
16545:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSStyleDeclaration)
16545:   NS_INTERFACE_MAP_ENTRY(nsISupports)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSFontFaceStyleDecl)
16545: NS_INTERFACE_MAP_END
16545: 
16545: NS_IMPL_ADDREF_USING_AGGREGATOR(nsCSSFontFaceStyleDecl, ContainingRule())
16545: NS_IMPL_RELEASE_USING_AGGREGATOR(nsCSSFontFaceStyleDecl, ContainingRule())
16545: 
16545: // helper for string GetPropertyValue and RemovePropertyValue
16545: nsresult
16545: nsCSSFontFaceStyleDecl::GetPropertyValue(nsCSSFontDesc aFontDescID,
16545:                                          nsAString & aResult NS_OUTPARAM) const
16545: {
16545:   NS_ENSURE_ARG_RANGE(aFontDescID, eCSSFontDesc_UNKNOWN,
16545:                       eCSSFontDesc_COUNT - 1);
16545: 
16545:   aResult.Truncate();
16545:   if (aFontDescID == eCSSFontDesc_UNKNOWN)
16545:     return NS_OK;
16545: 
16545:   const nsCSSValue& val = this->*nsCSSFontFaceStyleDecl::Fields[aFontDescID];
16545: 
25952:   if (val.GetUnit() == eCSSUnit_Null) {
25952:     // Avoid having to check no-value in the Family and Src cases below.
25952:     return NS_OK;
25952:   }
25952: 
16545:   switch (aFontDescID) {
16545:   case eCSSFontDesc_Family: {
48854:       // we don't use nsCSSValue::AppendToString here because it doesn't
16545:       // canonicalize the way we want, and anyway it's overkill when
16545:       // we know we have eCSSUnit_String
25796:       NS_ASSERTION(val.GetUnit() == eCSSUnit_String, "unexpected unit");
16545:       nsDependentString family(val.GetStringBufferValue());
25793:       nsStyleUtil::AppendEscapedCSSString(family, aResult);
16545:       return NS_OK;
16545:     }
16545: 
16545:   case eCSSFontDesc_Style:
48854:     val.AppendToString(eCSSProperty_font_style, aResult);
16545:     return NS_OK;
16545: 
16545:   case eCSSFontDesc_Weight:
48854:     val.AppendToString(eCSSProperty_font_weight, aResult);
16545:     return NS_OK;
16545: 
16545:   case eCSSFontDesc_Stretch:
48854:     val.AppendToString(eCSSProperty_font_stretch, aResult);
16545:     return NS_OK;
16545: 
51268:   case eCSSFontDesc_FontFeatureSettings:
51268:     val.AppendToString(eCSSProperty_font_feature_settings, aResult);
51268:     return NS_OK;
51268: 
51268:   case eCSSFontDesc_FontLanguageOverride:
51268:     val.AppendToString(eCSSProperty_font_language_override, aResult);
51268:     return NS_OK;
51268: 
16545:   case eCSSFontDesc_Src:
25952:     AppendSerializedFontSrc(val, aResult);
16545:     return NS_OK;
16545: 
16545:   case eCSSFontDesc_UnicodeRange:
31706:     AppendSerializedUnicodeRange(val, aResult);
16545:     return NS_OK;
16545: 
16545:   case eCSSFontDesc_UNKNOWN:
16545:   case eCSSFontDesc_COUNT:
16545:     ;
16545:   }
16545:   NS_NOTREACHED("nsCSSFontFaceStyleDecl::GetPropertyValue: "
16545:                 "out-of-range value got to the switch");
16545:   return NS_ERROR_INVALID_ARG;
16545: }
16545: 
16545: 
16545: // attribute DOMString cssText;
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetCssText(nsAString & aCssText)
16545: {
16545:   nsAutoString descStr;
16545: 
16545:   aCssText.Truncate();
16545:   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
16545:        id < eCSSFontDesc_COUNT;
16545:        id = nsCSSFontDesc(id + 1)) {
16545:     if ((this->*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit()
16545:           != eCSSUnit_Null &&
16545:         NS_SUCCEEDED(GetPropertyValue(id, descStr))) {
16545:       NS_ASSERTION(descStr.Length() > 0,
16545:                    "GetCssText: non-null unit, empty property value");
16545:       aCssText.AppendLiteral("  ");
16545:       aCssText.AppendASCII(nsCSSProps::GetStringValue(id).get());
16545:       aCssText.AppendLiteral(": ");
16545:       aCssText.Append(descStr);
16545:       aCssText.AppendLiteral(";\n");
16545:     }
16545:   }
16545:   return NS_OK;
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::SetCssText(const nsAString & aCssText)
16545: {
16545:   return NS_ERROR_NOT_IMPLEMENTED; // bug 443978
16545: }
16545: 
16545: // DOMString getPropertyValue (in DOMString propertyName);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetPropertyValue(const nsAString & propertyName,
16545:                                          nsAString & aResult NS_OUTPARAM)
16545: {
16545:   return GetPropertyValue(nsCSSProps::LookupFontDesc(propertyName), aResult);
16545: }
16545: 
16545: // nsIDOMCSSValue getPropertyCSSValue (in DOMString propertyName);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetPropertyCSSValue(const nsAString & propertyName,
16545:                                             nsIDOMCSSValue **aResult NS_OUTPARAM)
16545: {
16545:   // ??? nsDOMCSSDeclaration returns null/NS_OK, but that seems wrong.
16545:   return NS_ERROR_NOT_IMPLEMENTED;
16545: }
16545: 
16545: // DOMString removeProperty (in DOMString propertyName) raises (DOMException);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::RemoveProperty(const nsAString & propertyName,
16545:                                        nsAString & aResult NS_OUTPARAM)
16545: {
16545:   nsCSSFontDesc descID = nsCSSProps::LookupFontDesc(propertyName);
16545:   NS_ASSERTION(descID >= eCSSFontDesc_UNKNOWN &&
16545:                descID < eCSSFontDesc_COUNT,
16545:                "LookupFontDesc returned value out of range");
16545: 
16545:   if (descID == eCSSFontDesc_UNKNOWN) {
16545:     aResult.Truncate();
16545:   } else {
16545:     nsresult rv = GetPropertyValue(descID, aResult);
16545:     NS_ENSURE_SUCCESS(rv, rv);
16545:     (this->*nsCSSFontFaceStyleDecl::Fields[descID]).Reset();
16545:   }
16545:   return NS_OK;
16545: }
16545: 
16545: // DOMString getPropertyPriority (in DOMString propertyName);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetPropertyPriority(const nsAString & propertyName,
16545:                                             nsAString & aResult NS_OUTPARAM)
16545: {
16545:   // font descriptors do not have priorities at present
16545:   aResult.Truncate();
16545:   return NS_OK;
16545: }
16545: 
16545: // void setProperty (in DOMString propertyName, in DOMString value,
16545: //                   in DOMString priority)  raises (DOMException);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::SetProperty(const nsAString & propertyName,
16545:                                     const nsAString & value,
16545:                                     const nsAString & priority)
16545: {
16545:   return NS_ERROR_NOT_IMPLEMENTED; // bug 443978
16545: }
16545: 
16545: // readonly attribute unsigned long length;
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetLength(PRUint32 *aLength)
16545: {
16545:   PRUint32 len = 0;
16545:   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
16545:        id < eCSSFontDesc_COUNT;
16545:        id = nsCSSFontDesc(id + 1))
16545:     if ((this->*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit() != eCSSUnit_Null)
16545:       len++;
16545: 
16545:   *aLength = len;
16545:   return NS_OK;
16545: }
16545: 
16545: // DOMString item (in unsigned long index);
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::Item(PRUint32 index, nsAString & aResult NS_OUTPARAM)
16545:  {
16545:   PRInt32 nset = -1;
16545:   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
16545:        id < eCSSFontDesc_COUNT;
16545:        id = nsCSSFontDesc(id + 1)) {
16545:     if ((this->*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit()
16545:         != eCSSUnit_Null) {
16545:       nset++;
16545:       if (nset == PRInt32(index)) {
16545:         aResult.AssignASCII(nsCSSProps::GetStringValue(id).get());
16545:         return NS_OK;
16545:       }
16545:     }
16545:   }
16545:   aResult.Truncate();
16545:   return NS_OK;
16545: }
16545: 
16545: // readonly attribute nsIDOMCSSRule parentRule;
16545: NS_IMETHODIMP
16545: nsCSSFontFaceStyleDecl::GetParentRule(nsIDOMCSSRule** aParentRule)
16545: {
69443:   NS_IF_ADDREF(*aParentRule = ContainingRule()->GetDOMRule());
69443:   return NS_OK;
16545: }
16545: 
16545: 
16545: // -------------------------------------------
16545: // nsCSSFontFaceRule
16545: // 
16545: 
69440: /* virtual */ already_AddRefed<css::Rule>
50636: nsCSSFontFaceRule::Clone() const
16545: {
69440:   nsRefPtr<css::Rule> clone = new nsCSSFontFaceRule(*this);
50636:   return clone.forget();
16545: }
16545: 
69442: NS_IMPL_ADDREF_INHERITED(nsCSSFontFaceRule, Rule)
69442: NS_IMPL_RELEASE_INHERITED(nsCSSFontFaceRule, Rule)
16545: 
40490: DOMCI_DATA(CSSFontFaceRule, nsCSSFontFaceRule)
40490: 
16545: // QueryInterface implementation for nsCSSFontFaceRule
16545: NS_INTERFACE_MAP_BEGIN(nsCSSFontFaceRule)
16545:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
16545:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSFontFaceRule)
16545:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
69440:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStyleRule)
39587:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CSSFontFaceRule)
16545: NS_INTERFACE_MAP_END
16545: 
64682: IMPL_STYLE_RULE_INHERIT(nsCSSFontFaceRule, Rule)
16545: 
16545: #ifdef DEBUG
43120: void
16545: nsCSSFontFaceRule::List(FILE* out, PRInt32 aIndent) const
16545: {
16545:   nsCString baseInd, descInd;
16545:   for (PRInt32 indent = aIndent; --indent >= 0; ) {
16545:     baseInd.AppendLiteral("  ");
16545:     descInd.AppendLiteral("  ");
16545:   }
16545:   descInd.AppendLiteral("  ");
16545: 
16545:   nsString descStr;
16545: 
16545:   fprintf(out, "%s@font-face {\n", baseInd.get());
16545:   for (nsCSSFontDesc id = nsCSSFontDesc(eCSSFontDesc_UNKNOWN + 1);
16545:        id < eCSSFontDesc_COUNT;
16545:        id = nsCSSFontDesc(id + 1))
16545:     if ((mDecl.*nsCSSFontFaceStyleDecl::Fields[id]).GetUnit()
16545:         != eCSSUnit_Null) {
16545:       if (NS_FAILED(mDecl.GetPropertyValue(id, descStr)))
16545:         descStr.AssignLiteral("#<serialization error>");
16545:       else if (descStr.Length() == 0)
16545:         descStr.AssignLiteral("#<serialization missing>");
16545:       fprintf(out, "%s%s: %s\n",
16545:               descInd.get(), nsCSSProps::GetStringValue(id).get(),
16545:               NS_ConvertUTF16toUTF8(descStr).get());
16545:     }
16545:   fprintf(out, "%s}\n", baseInd.get());
16545: }
16545: #endif
16545: 
47887: /* virtual */ PRInt32
47887: nsCSSFontFaceRule::GetType() const
16545: {
69442:   return Rule::FONT_FACE_RULE;
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::GetType(PRUint16* aType)
16545: {
16545:   *aType = nsIDOMCSSRule::FONT_FACE_RULE;
16545:   return NS_OK;
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::GetCssText(nsAString& aCssText)
16545: {
16545:   nsAutoString propText;
16545:   mDecl.GetCssText(propText);
16545: 
16545:   aCssText.AssignLiteral("@font-face {\n");
16545:   aCssText.Append(propText);
16545:   aCssText.Append('}');
16545:   return NS_OK;
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::SetCssText(const nsAString& aCssText)
16545: {
16545:   return NS_ERROR_NOT_IMPLEMENTED; // bug 443978
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
16545: {
69442:   return Rule::GetParentStyleSheet(aSheet);
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::GetParentRule(nsIDOMCSSRule** aParentRule)
16545: {
69442:   return Rule::GetParentRule(aParentRule);
16545: }
16545: 
16545: NS_IMETHODIMP
16545: nsCSSFontFaceRule::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
16545: {
47889:   NS_IF_ADDREF(*aStyle = &mDecl);
47889:   return NS_OK;
16545: }
16545: 
16545: // Arguably these should forward to nsCSSFontFaceStyleDecl methods.
16545: void
16545: nsCSSFontFaceRule::SetDesc(nsCSSFontDesc aDescID, nsCSSValue const & aValue)
16545: {
16545:   NS_PRECONDITION(aDescID > eCSSFontDesc_UNKNOWN &&
16545:                   aDescID < eCSSFontDesc_COUNT,
16545:                   "aDescID out of range in nsCSSFontFaceRule::SetDesc");
16545: 
67979:   // FIXME: handle dynamic changes
67979: 
16545:   mDecl.*nsCSSFontFaceStyleDecl::Fields[aDescID] = aValue;
16545: }
16545: 
16545: void
16545: nsCSSFontFaceRule::GetDesc(nsCSSFontDesc aDescID, nsCSSValue & aValue)
16545: {
16545:   NS_PRECONDITION(aDescID > eCSSFontDesc_UNKNOWN &&
16545:                   aDescID < eCSSFontDesc_COUNT,
16545:                   "aDescID out of range in nsCSSFontFaceRule::GetDesc");
16545: 
16545:   aValue = mDecl.*nsCSSFontFaceStyleDecl::Fields[aDescID];
16545: }
67979: 
67979: // -------------------------------------------
67979: // nsCSSKeyframeStyleDeclaration
67979: //
67979: 
67979: nsCSSKeyframeStyleDeclaration::nsCSSKeyframeStyleDeclaration(nsCSSKeyframeRule *aRule)
67979:   : mRule(aRule)
67979: {
67979: }
67979: 
67979: nsCSSKeyframeStyleDeclaration::~nsCSSKeyframeStyleDeclaration()
67979: {
67979:   NS_ASSERTION(!mRule, "DropReference not called.");
67979: }
67979: 
67979: NS_IMPL_ADDREF(nsCSSKeyframeStyleDeclaration)
67979: NS_IMPL_RELEASE(nsCSSKeyframeStyleDeclaration)
67979: 
67979: css::Declaration*
79445: nsCSSKeyframeStyleDeclaration::GetCSSDeclaration(bool aAllocate)
67979: {
67979:   if (mRule) {
67979:     return mRule->Declaration();
67979:   } else {
67979:     return nsnull;
67979:   }
67979: }
67979: 
69043: void
69043: nsCSSKeyframeStyleDeclaration::GetCSSParsingEnvironment(CSSParsingEnvironment& aCSSParseEnv)
67979: {
69043:   GetCSSParsingEnvironmentForRule(mRule, aCSSParseEnv);
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframeStyleDeclaration::GetParentRule(nsIDOMCSSRule **aParent)
67979: {
67979:   NS_ENSURE_ARG_POINTER(aParent);
67979: 
67979:   NS_IF_ADDREF(*aParent = mRule);
67979:   return NS_OK;
67979: }
67979: 
67979: nsresult
67979: nsCSSKeyframeStyleDeclaration::SetCSSDeclaration(css::Declaration* aDecl)
67979: {
67979:   NS_ABORT_IF_FALSE(aDecl, "must be non-null");
67979:   mRule->ChangeDeclaration(aDecl);
67979:   return NS_OK;
67979: }
67979: 
67979: nsIDocument*
67979: nsCSSKeyframeStyleDeclaration::DocToUpdate()
67979: {
67979:   return nsnull;
67979: }
67979: 
67979: // -------------------------------------------
67979: // nsCSSKeyframeRule
67979: //
67979: 
67979: nsCSSKeyframeRule::nsCSSKeyframeRule(const nsCSSKeyframeRule& aCopy)
67979:   // copy everything except our reference count and mDOMDeclaration
67979:   : Rule(aCopy)
67979:   , mKeys(aCopy.mKeys)
69442:   , mDeclaration(new css::Declaration(*aCopy.mDeclaration))
67979: {
67979: }
67979: 
67979: nsCSSKeyframeRule::~nsCSSKeyframeRule()
67979: {
67979:   if (mDOMDeclaration) {
67979:     mDOMDeclaration->DropReference();
67979:   }
67979: }
67979: 
69440: /* virtual */ already_AddRefed<css::Rule>
67979: nsCSSKeyframeRule::Clone() const
67979: {
69440:   nsRefPtr<css::Rule> clone = new nsCSSKeyframeRule(*this);
67979:   return clone.forget();
67979: }
67979: 
69444: NS_IMPL_ADDREF_INHERITED(nsCSSKeyframeRule, Rule)
69444: NS_IMPL_RELEASE_INHERITED(nsCSSKeyframeRule, Rule)
67979: 
67979: DOMCI_DATA(MozCSSKeyframeRule, nsCSSKeyframeRule)
67979: 
67979: // QueryInterface implementation for nsCSSKeyframeRule
67979: NS_INTERFACE_MAP_BEGIN(nsCSSKeyframeRule)
67979:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
67979:   NS_INTERFACE_MAP_ENTRY(nsIDOMMozCSSKeyframeRule)
67979:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
69440:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStyleRule)
67979:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MozCSSKeyframeRule)
67979: NS_INTERFACE_MAP_END
67979: 
67979: IMPL_STYLE_RULE_INHERIT_GET_DOM_RULE_WEAK(nsCSSKeyframeRule, Rule)
67979: 
67979: /* virtual */ void
67979: nsCSSKeyframeRule::MapRuleInfoInto(nsRuleData* aRuleData)
67979: {
67979:   // We need to implement MapRuleInfoInto because the animation manager
67979:   // constructs a rule node pointing to us in order to compute the
67979:   // styles it needs to animate.
67979: 
67979:   // FIXME (spec): The spec doesn't say what to do with !important.
67979:   // We'll just map them.
67979:   if (mDeclaration->HasImportantData()) {
67979:     mDeclaration->MapImportantRuleInfoInto(aRuleData);
67979:   }
67979:   mDeclaration->MapNormalRuleInfoInto(aRuleData);
67979: }
67979: 
67979: #ifdef DEBUG
67979: void
67979: nsCSSKeyframeRule::List(FILE* out, PRInt32 aIndent) const
67979: {
67979:   // FIXME: WRITE ME
67979: }
67979: #endif
67979: 
67979: /* virtual */ PRInt32
67979: nsCSSKeyframeRule::GetType() const
67979: {
69442:   return Rule::KEYFRAME_RULE;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframeRule::GetType(PRUint16* aType)
67979: {
67979:   *aType = nsIDOMCSSRule::MOZ_KEYFRAME_RULE;
67979:   return NS_OK;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframeRule::GetCssText(nsAString& aCssText)
67979: {
67979:   nsCSSKeyframeRule::GetKeyText(aCssText);
67979:   aCssText.AppendLiteral(" { ");
67979:   nsAutoString tmp;
67979:   mDeclaration->ToString(tmp);
67979:   aCssText.Append(tmp);
67979:   aCssText.AppendLiteral(" }");
67979:   return NS_OK;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframeRule::SetCssText(const nsAString& aCssText)
67979: {
67979:   // FIXME: implement???
67979:   return NS_ERROR_NOT_IMPLEMENTED;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframeRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
67979: {
69442:   return Rule::GetParentStyleSheet(aSheet);
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframeRule::GetParentRule(nsIDOMCSSRule** aParentRule)
67979: {
69442:   return Rule::GetParentRule(aParentRule);
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframeRule::GetKeyText(nsAString& aKeyText)
67979: {
67979:   aKeyText.Truncate();
67979:   PRUint32 i = 0, i_end = mKeys.Length();
67979:   NS_ABORT_IF_FALSE(i_end != 0, "must have some keys");
67979:   for (;;) {
67979:     aKeyText.AppendFloat(mKeys[i] * 100.0f);
67979:     aKeyText.Append(PRUnichar('%'));
67979:     if (++i == i_end) {
67979:       break;
67979:     }
67979:     aKeyText.AppendLiteral(", ");
67979:   }
67979:   return NS_OK;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframeRule::SetKeyText(const nsAString& aKeyText)
67979: {
67979:   nsCSSParser parser;
67979: 
80648:   InfallibleTArray<float> newSelectors;
67979:   // FIXME: pass filename and line number
67979:   if (parser.ParseKeyframeSelectorString(aKeyText, nsnull, 0, newSelectors)) {
67979:     newSelectors.SwapElements(mKeys);
67979:   } else {
67979:     // for now, we don't do anything if the parse fails
67979:   }
67979: 
69252:   if (mSheet) {
67979:     mSheet->SetModifiedByChildRule();
69252:   }
67979: 
67979:   return NS_OK;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframeRule::GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
67979: {
67979:   if (!mDOMDeclaration) {
67979:     mDOMDeclaration = new nsCSSKeyframeStyleDeclaration(this);
67979:   }
67979:   NS_ADDREF(*aStyle = mDOMDeclaration);
67979:   return NS_OK;
67979: }
67979: 
67979: void
69442: nsCSSKeyframeRule::ChangeDeclaration(css::Declaration* aDeclaration)
67979: {
85607:   // Be careful to not assign to an nsAutoPtr if we would be assigning
85607:   // the thing it already holds.
85607:   if (aDeclaration != mDeclaration) {
67979:     mDeclaration = aDeclaration;
85607:   }
67979: 
69252:   if (mSheet) {
67979:     mSheet->SetModifiedByChildRule();
67979:   }
69252: }
67979: 
67979: // -------------------------------------------
67979: // nsCSSKeyframesRule
67979: //
67979: 
67979: nsCSSKeyframesRule::nsCSSKeyframesRule(const nsCSSKeyframesRule& aCopy)
67979:   // copy everything except our reference count.  GroupRule's copy
67979:   // constructor also doesn't copy the lazily-constructed
67979:   // mRuleCollection.
67979:   : GroupRule(aCopy),
67979:     mName(aCopy.mName)
67979: {
67979: }
67979: 
67979: nsCSSKeyframesRule::~nsCSSKeyframesRule()
67979: {
67979: }
67979: 
69440: /* virtual */ already_AddRefed<css::Rule>
67979: nsCSSKeyframesRule::Clone() const
67979: {
69440:   nsRefPtr<css::Rule> clone = new nsCSSKeyframesRule(*this);
67979:   return clone.forget();
67979: }
67979: 
69442: NS_IMPL_ADDREF_INHERITED(nsCSSKeyframesRule, css::GroupRule)
69442: NS_IMPL_RELEASE_INHERITED(nsCSSKeyframesRule, css::GroupRule)
67979: 
67979: DOMCI_DATA(MozCSSKeyframesRule, nsCSSKeyframesRule)
67979: 
67979: // QueryInterface implementation for nsCSSKeyframesRule
67979: NS_INTERFACE_MAP_BEGIN(nsCSSKeyframesRule)
67979:   NS_INTERFACE_MAP_ENTRY(nsIStyleRule)
67979:   NS_INTERFACE_MAP_ENTRY(nsIDOMCSSRule)
67979:   NS_INTERFACE_MAP_ENTRY(nsIDOMMozCSSKeyframesRule)
69440:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIStyleRule)
67979:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MozCSSKeyframesRule)
67979: NS_INTERFACE_MAP_END
67979: 
67979: #ifdef DEBUG
67979: void
67979: nsCSSKeyframesRule::List(FILE* out, PRInt32 aIndent) const
67979: {
67979:   // FIXME: WRITE ME
67979: }
67979: #endif
67979: 
67979: /* virtual */ PRInt32
67979: nsCSSKeyframesRule::GetType() const
67979: {
69442:   return Rule::KEYFRAMES_RULE;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::GetType(PRUint16* aType)
67979: {
67979:   *aType = nsIDOMCSSRule::MOZ_KEYFRAMES_RULE;
67979:   return NS_OK;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::GetCssText(nsAString& aCssText)
67979: {
67979:   aCssText.AssignLiteral("@-moz-keyframes ");
67979:   aCssText.Append(mName);
67979:   aCssText.AppendLiteral(" {\n");
67979:   nsAutoString tmp;
67979:   for (PRUint32 i = 0, i_end = mRules.Count(); i != i_end; ++i) {
67979:     static_cast<nsCSSKeyframeRule*>(mRules[i])->GetCssText(tmp);
67979:     aCssText.Append(tmp);
67979:     aCssText.AppendLiteral("\n");
67979:   }
67979:   aCssText.AppendLiteral("}");
67979:   return NS_OK;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::SetCssText(const nsAString& aCssText)
67979: {
67979:   // FIXME: implement???
67979:   return NS_ERROR_NOT_IMPLEMENTED;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::GetParentStyleSheet(nsIDOMCSSStyleSheet** aSheet)
67979: {
69442:   return GroupRule::GetParentStyleSheet(aSheet);
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::GetParentRule(nsIDOMCSSRule** aParentRule)
67979: {
69442:   return GroupRule::GetParentRule(aParentRule);
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::GetName(nsAString& aName)
67979: {
67979:   aName = mName;
67979:   return NS_OK;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::SetName(const nsAString& aName)
67979: {
67979:   mName = aName;
67979: 
69252:   if (mSheet) {
67979:     mSheet->SetModifiedByChildRule();
69252:   }
67979: 
67979:   return NS_OK;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::GetCssRules(nsIDOMCSSRuleList* *aRuleList)
67979: {
69442:   return GroupRule::GetCssRules(aRuleList);
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::InsertRule(const nsAString& aRule)
67979: {
67979:   // The spec is confusing, and I think we should just append the rule,
67979:   // which also turns out to match WebKit:
67979:   // http://lists.w3.org/Archives/Public/www-style/2011Apr/0034.html
67979:   nsCSSParser parser;
67979: 
67979:   // FIXME: pass filename and line number
67979:   nsRefPtr<nsCSSKeyframeRule> rule =
67979:     parser.ParseKeyframeRule(aRule, nsnull, 0);
67979:   if (rule) {
67979:     mRules.AppendObject(rule);
69252:     if (mSheet) {
67979:       mSheet->SetModifiedByChildRule();
67979:     }
69252:   }
67979: 
67979:   return NS_OK;
67979: }
67979: 
67979: static const PRUint32 RULE_NOT_FOUND = PRUint32(-1);
67979: 
67979: PRUint32
67979: nsCSSKeyframesRule::FindRuleIndexForKey(const nsAString& aKey)
67979: {
67979:   nsCSSParser parser;
67979: 
80648:   InfallibleTArray<float> keys;
67979:   // FIXME: pass filename and line number
67979:   if (parser.ParseKeyframeSelectorString(aKey, nsnull, 0, keys)) {
67979:     // The spec isn't clear, but we'll match on the key list, which
67979:     // mostly matches what WebKit does, except we'll do last-match
67979:     // instead of first-match, and handling parsing differences better.
67979:     // http://lists.w3.org/Archives/Public/www-style/2011Apr/0036.html
67979:     // http://lists.w3.org/Archives/Public/www-style/2011Apr/0037.html
67979:     for (PRUint32 i = mRules.Count(); i-- != 0; ) {
67979:       if (static_cast<nsCSSKeyframeRule*>(mRules[i])->GetKeys() == keys) {
67979:         return i;
67979:       }
67979:     }
67979:   }
67979: 
67979:   return RULE_NOT_FOUND;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::DeleteRule(const nsAString& aKey)
67979: {
67979:   PRUint32 index = FindRuleIndexForKey(aKey);
67979:   if (index != RULE_NOT_FOUND) {
67979:     mRules.RemoveObjectAt(index);
69252:     if (mSheet) {
67979:       mSheet->SetModifiedByChildRule();
67979:     }
69252:   }
67979:   return NS_OK;
67979: }
67979: 
67979: NS_IMETHODIMP
67979: nsCSSKeyframesRule::FindRule(const nsAString& aKey,
67979:                              nsIDOMMozCSSKeyframeRule** aResult)
67979: {
67979:   PRUint32 index = FindRuleIndexForKey(aKey);
67979:   if (index == RULE_NOT_FOUND) {
67979:     *aResult = nsnull;
67979:   } else {
67979:     NS_ADDREF(*aResult = static_cast<nsCSSKeyframeRule*>(mRules[index]));
67979:   }
67979:   return NS_OK;
67979: }
67979: 
67979: // GroupRule interface
79445: /* virtual */ bool
67979: nsCSSKeyframesRule::UseForPresentation(nsPresContext* aPresContext,
67979:                                        nsMediaQueryResultCacheKey& aKey)
67979: {
80486:   NS_ABORT_IF_FALSE(false, "should not be called");
80486:   return false;
67979: }
67979: 
