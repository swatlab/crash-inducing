 42402: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 42402: 
 42402: #include "gfxUtils.h"
 50417: #include "gfxContext.h"
 50417: #include "gfxPlatform.h"
 50419: #include "gfxDrawable.h"
 51956: #include "nsRegion.h"
 79424: #include "yuv_convert.h"
 79424: #include "ycbcr_to_rgb565.h"
 95736: #include "sampler.h"
 50417: 
 71958: #ifdef XP_WIN
 50417: #include "gfxWindowsPlatform.h"
 50417: #endif
 42402: 
 79424: using namespace mozilla;
 79424: using namespace mozilla::layers;
 82354: using namespace mozilla::gfx;
 79424: 
108991: static uint8_t sUnpremultiplyTable[256*256];
108991: static uint8_t sPremultiplyTable[256*256];
 79445: static bool sTablesInitialized = false;
 42402: 
108991: static const uint8_t PremultiplyValue(uint8_t a, uint8_t v) {
 42402:     return sPremultiplyTable[a*256+v];
 42402: }
 42402: 
108991: static const uint8_t UnpremultiplyValue(uint8_t a, uint8_t v) {
 42402:     return sUnpremultiplyTable[a*256+v];
 42402: }
 42402: 
 42402: static void
 42402: CalculateTables()
 42402: {
 42402:     // It's important that the array be indexed first by alpha and then by rgb
 42402:     // value.  When we unpremultiply a pixel, we're guaranteed to do three
 42402:     // lookups with the same alpha; indexing by alpha first makes it likely that
 42402:     // those three lookups will be close to one another in memory, thus
 42402:     // increasing the chance of a cache hit.
 42402: 
 42402:     // Unpremultiply table
 42402: 
 42402:     // a == 0 case
108991:     for (uint32_t c = 0; c <= 255; c++) {
 42402:         sUnpremultiplyTable[c] = c;
 42402:     }
 42402: 
 42402:     for (int a = 1; a <= 255; a++) {
 42402:         for (int c = 0; c <= 255; c++) {
108991:             sUnpremultiplyTable[a*256+c] = (uint8_t)((c * 255) / a);
 42402:         }
 42402:     }
 42402: 
 42402:     // Premultiply table
 42402: 
 42402:     for (int a = 0; a <= 255; a++) {
 42402:         for (int c = 0; c <= 255; c++) {
 42402:             sPremultiplyTable[a*256+c] = (a * c + 254) / 255;
 42402:         }
 42402:     }
 42402: 
 80486:     sTablesInitialized = true;
 42402: }
 42402: 
 42402: void
 42402: gfxUtils::PremultiplyImageSurface(gfxImageSurface *aSourceSurface,
 42402:                                   gfxImageSurface *aDestSurface)
 42402: {
 42402:     if (!aDestSurface)
 42402:         aDestSurface = aSourceSurface;
 42402: 
 42402:     NS_ASSERTION(aSourceSurface->Format() == aDestSurface->Format() &&
 42402:                  aSourceSurface->Width() == aDestSurface->Width() &&
 42402:                  aSourceSurface->Height() == aDestSurface->Height() &&
 42402:                  aSourceSurface->Stride() == aDestSurface->Stride(),
 42402:                  "Source and destination surfaces don't have identical characteristics");
 42402: 
 42402:     NS_ASSERTION(aSourceSurface->Stride() == aSourceSurface->Width() * 4,
 42402:                  "Source surface stride isn't tightly packed");
 42402: 
 42402:     // Only premultiply ARGB32
 42402:     if (aSourceSurface->Format() != gfxASurface::ImageFormatARGB32) {
 42402:         if (aDestSurface != aSourceSurface) {
 42402:             memcpy(aDestSurface->Data(), aSourceSurface->Data(),
 42402:                    aSourceSurface->Stride() * aSourceSurface->Height());
 42402:         }
 42402:         return;
 42402:     }
 42402: 
 42402:     if (!sTablesInitialized)
 42402:         CalculateTables();
 42402: 
108991:     uint8_t *src = aSourceSurface->Data();
108991:     uint8_t *dst = aDestSurface->Data();
 42402: 
108991:     uint32_t dim = aSourceSurface->Width() * aSourceSurface->Height();
108991:     for (uint32_t i = 0; i < dim; ++i) {
 42402: #ifdef IS_LITTLE_ENDIAN
108991:         uint8_t b = *src++;
108991:         uint8_t g = *src++;
108991:         uint8_t r = *src++;
108991:         uint8_t a = *src++;
 42402: 
 42402:         *dst++ = PremultiplyValue(a, b);
 42402:         *dst++ = PremultiplyValue(a, g);
 42402:         *dst++ = PremultiplyValue(a, r);
 42402:         *dst++ = a;
 42402: #else
108991:         uint8_t a = *src++;
108991:         uint8_t r = *src++;
108991:         uint8_t g = *src++;
108991:         uint8_t b = *src++;
 42402: 
 42402:         *dst++ = a;
 42402:         *dst++ = PremultiplyValue(a, r);
 42402:         *dst++ = PremultiplyValue(a, g);
 42402:         *dst++ = PremultiplyValue(a, b);
 42402: #endif
 42402:     }
 42402: }
 42402: 
 42402: void
 42402: gfxUtils::UnpremultiplyImageSurface(gfxImageSurface *aSourceSurface,
 42402:                                     gfxImageSurface *aDestSurface)
 42402: {
 42402:     if (!aDestSurface)
 42402:         aDestSurface = aSourceSurface;
 42402: 
 42402:     NS_ASSERTION(aSourceSurface->Format() == aDestSurface->Format() &&
 42402:                  aSourceSurface->Width() == aDestSurface->Width() &&
 42402:                  aSourceSurface->Height() == aDestSurface->Height() &&
 42402:                  aSourceSurface->Stride() == aDestSurface->Stride(),
 42402:                  "Source and destination surfaces don't have identical characteristics");
 42402: 
 42402:     NS_ASSERTION(aSourceSurface->Stride() == aSourceSurface->Width() * 4,
 42402:                  "Source surface stride isn't tightly packed");
 42402: 
 42402:     // Only premultiply ARGB32
 42402:     if (aSourceSurface->Format() != gfxASurface::ImageFormatARGB32) {
 42402:         if (aDestSurface != aSourceSurface) {
 42402:             memcpy(aDestSurface->Data(), aSourceSurface->Data(),
 42402:                    aSourceSurface->Stride() * aSourceSurface->Height());
 42402:         }
 42402:         return;
 42402:     }
 42402: 
 42402:     if (!sTablesInitialized)
 42402:         CalculateTables();
 42402: 
108991:     uint8_t *src = aSourceSurface->Data();
108991:     uint8_t *dst = aDestSurface->Data();
 42402: 
108991:     uint32_t dim = aSourceSurface->Width() * aSourceSurface->Height();
108991:     for (uint32_t i = 0; i < dim; ++i) {
 42402: #ifdef IS_LITTLE_ENDIAN
108991:         uint8_t b = *src++;
108991:         uint8_t g = *src++;
108991:         uint8_t r = *src++;
108991:         uint8_t a = *src++;
 42402: 
 42402:         *dst++ = UnpremultiplyValue(a, b);
 42402:         *dst++ = UnpremultiplyValue(a, g);
 42402:         *dst++ = UnpremultiplyValue(a, r);
 42402:         *dst++ = a;
 42402: #else
108991:         uint8_t a = *src++;
108991:         uint8_t r = *src++;
108991:         uint8_t g = *src++;
108991:         uint8_t b = *src++;
 42402: 
 42402:         *dst++ = a;
 42402:         *dst++ = UnpremultiplyValue(a, r);
 42402:         *dst++ = UnpremultiplyValue(a, g);
 42402:         *dst++ = UnpremultiplyValue(a, b);
 42402: #endif
 42402:     }
 42402: }
 50417: 
 93959: void
 93959: gfxUtils::ConvertBGRAtoRGBA(gfxImageSurface *aSourceSurface,
 93959:                             gfxImageSurface *aDestSurface) {
 93959:     if (!aDestSurface)
 93959:         aDestSurface = aSourceSurface;
 93959: 
 93959:     NS_ABORT_IF_FALSE(aSourceSurface->Format() == aDestSurface->Format() &&
 93959:                       aSourceSurface->Width() == aDestSurface->Width() &&
 93959:                       aSourceSurface->Height() == aDestSurface->Height() &&
 93959:                       aSourceSurface->Stride() == aDestSurface->Stride(),
 93959:                       "Source and destination surfaces don't have identical characteristics");
 93959: 
 93959:     NS_ABORT_IF_FALSE(aSourceSurface->Stride() == aSourceSurface->Width() * 4,
 93959:                       "Source surface stride isn't tightly packed");
 93959: 
 93959:     NS_ABORT_IF_FALSE(aSourceSurface->Format() == gfxASurface::ImageFormatARGB32,
 93959:                       "Surfaces must be ARGB32");
 93959: 
108991:     uint8_t *src = aSourceSurface->Data();
108991:     uint8_t *dst = aDestSurface->Data();
 93959: 
108991:     uint32_t dim = aSourceSurface->Width() * aSourceSurface->Height();
108991:     uint8_t *srcEnd = src + 4*dim;
 93959: 
 93959:     if (src == dst) {
108991:         uint8_t buffer[4];
 93959:         for (; src != srcEnd; src += 4) {
 93959:             buffer[0] = src[2];
 93959:             buffer[1] = src[1];
 93959:             buffer[2] = src[0];
 93959: 
 93959:             src[0] = buffer[0];
 93959:             src[1] = buffer[1];
 93959:             src[2] = buffer[2];
 93959:         }
 93959:     } else {
 93959:         for (; src != srcEnd; src += 4, dst += 4) {
 93959:             dst[0] = src[2];
 93959:             dst[1] = src[1];
 93959:             dst[2] = src[0];
 93959:             dst[3] = src[3];
 93959:         }
 93959:     }
 93959: }
 93959: 
 79445: static bool
 50417: IsSafeImageTransformComponent(gfxFloat aValue)
 50417: {
 50417:   return aValue >= -32768 && aValue <= 32767;
 50417: }
 50417: 
 55205: /**
 55205:  * This returns the fastest operator to use for solid surfaces which have no
 55205:  * alpha channel or their alpha channel is uniformly opaque.
 55205:  * This differs per render mode.
 55205:  */
 55205: static gfxContext::GraphicsOperator
 55205: OptimalFillOperator()
 55205: {
 55205: #ifdef XP_WIN
 55205:     if (gfxWindowsPlatform::GetPlatform()->GetRenderMode() ==
 55205:         gfxWindowsPlatform::RENDER_DIRECT2D) {
 55205:         // D2D -really- hates operator source.
 55205:         return gfxContext::OPERATOR_OVER;
 55205:     } else {
 55205: #endif
 55205:         return gfxContext::OPERATOR_SOURCE;
 55205: #ifdef XP_WIN
 55205:     }
 55205: #endif
 55205: }
 55205: 
 50417: // EXTEND_PAD won't help us here; we have to create a temporary surface to hold
 50417: // the subimage of pixels we're allowed to sample.
 50419: static already_AddRefed<gfxDrawable>
 50419: CreateSamplingRestrictedDrawable(gfxDrawable* aDrawable,
 50417:                                  gfxContext* aContext,
 50417:                                  const gfxMatrix& aUserSpaceToImageSpace,
 50417:                                  const gfxRect& aSourceRect,
 50417:                                  const gfxRect& aSubimage,
 50417:                                  const gfxImageSurface::gfxImageFormat aFormat)
 50417: {
 95736:     SAMPLE_LABEL("gfxUtils", "CreateSamplingRestricedDrawable");
 50417:     gfxRect userSpaceClipExtents = aContext->GetClipExtents();
 50417:     // This isn't optimal --- if aContext has a rotation then GetClipExtents
 50417:     // will have to do a bounding-box computation, and TransformBounds might
 50417:     // too, so we could get a better result if we computed image space clip
 50417:     // extents in one go --- but it doesn't really matter and this is easier
 50417:     // to understand.
 50417:     gfxRect imageSpaceClipExtents =
 50417:         aUserSpaceToImageSpace.TransformBounds(userSpaceClipExtents);
 50417:     // Inflate by one pixel because bilinear filtering will sample at most
 50417:     // one pixel beyond the computed image pixel coordinate.
 68641:     imageSpaceClipExtents.Inflate(1.0);
 50417: 
 50417:     gfxRect needed = imageSpaceClipExtents.Intersect(aSourceRect);
 50417:     needed = needed.Intersect(aSubimage);
 50417:     needed.RoundOut();
 50417: 
 50417:     // if 'needed' is empty, nothing will be drawn since aFill
 50417:     // must be entirely outside the clip region, so it doesn't
 50417:     // matter what we do here, but we should avoid trying to
 50417:     // create a zero-size surface.
 50417:     if (needed.IsEmpty())
106838:         return nullptr;
 50417: 
108991:     gfxIntSize size(int32_t(needed.Width()), int32_t(needed.Height()));
 50417:     nsRefPtr<gfxASurface> temp =
 54253:         gfxPlatform::GetPlatform()->CreateOffscreenSurface(size, gfxASurface::ContentFromFormat(aFormat));
 50417:     if (!temp || temp->CairoStatus())
106838:         return nullptr;
 50417: 
 55854:     nsRefPtr<gfxContext> tmpCtx = new gfxContext(temp);
 55854:     tmpCtx->SetOperator(OptimalFillOperator());
 80486:     aDrawable->Draw(tmpCtx, needed - needed.TopLeft(), true,
 68632:                     gfxPattern::FILTER_FAST, gfxMatrix().Translate(needed.TopLeft()));
 50417: 
 50417:     nsRefPtr<gfxPattern> resultPattern = new gfxPattern(temp);
 50417:     if (!resultPattern)
106838:         return nullptr;
 50417: 
 50419:     nsRefPtr<gfxDrawable> drawable = 
 68632:         new gfxSurfaceDrawable(temp, size, gfxMatrix().Translate(-needed.TopLeft()));
 50419:     return drawable.forget();
 50417: }
 50417: 
 50417: // working around cairo/pixman bug (bug 364968)
 50417: // Our device-space-to-image-space transform may not be acceptable to pixman.
 50417: struct NS_STACK_CLASS AutoCairoPixmanBugWorkaround
 50417: {
 50417:     AutoCairoPixmanBugWorkaround(gfxContext*      aContext,
 50417:                                  const gfxMatrix& aDeviceSpaceToImageSpace,
 50417:                                  const gfxRect&   aFill,
 86664:                                  const gfxASurface* aSurface)
 80486:      : mContext(aContext), mSucceeded(true), mPushedGroup(false)
 50417:     {
 50417:         // Quartz's limits for matrix are much larger than pixman
 86664:         if (!aSurface || aSurface->GetType() == gfxASurface::SurfaceTypeQuartz)
 50417:             return;
 50417: 
 50417:         if (!IsSafeImageTransformComponent(aDeviceSpaceToImageSpace.xx) ||
 50417:             !IsSafeImageTransformComponent(aDeviceSpaceToImageSpace.xy) ||
 50417:             !IsSafeImageTransformComponent(aDeviceSpaceToImageSpace.yx) ||
 50417:             !IsSafeImageTransformComponent(aDeviceSpaceToImageSpace.yy)) {
 50417:             NS_WARNING("Scaling up too much, bailing out");
 80486:             mSucceeded = false;
 50417:             return;
 50417:         }
 50417: 
 50417:         if (IsSafeImageTransformComponent(aDeviceSpaceToImageSpace.x0) &&
 50417:             IsSafeImageTransformComponent(aDeviceSpaceToImageSpace.y0))
 50417:             return;
 50417: 
 50417:         // We'll push a group, which will hopefully reduce our transform's
 50417:         // translation so it's in bounds.
 50417:         gfxMatrix currentMatrix = mContext->CurrentMatrix();
 50417:         mContext->Save();
 50417: 
 50417:         // Clip the rounded-out-to-device-pixels bounds of the
 50417:         // transformed fill area. This is the area for the group we
 50417:         // want to push.
 50417:         mContext->IdentityMatrix();
 50417:         gfxRect bounds = currentMatrix.TransformBounds(aFill);
 50417:         bounds.RoundOut();
 50417:         mContext->Clip(bounds);
 50417:         mContext->SetMatrix(currentMatrix);
 50417:         mContext->PushGroup(gfxASurface::CONTENT_COLOR_ALPHA);
 50417:         mContext->SetOperator(gfxContext::OPERATOR_OVER);
 50417: 
 80486:         mPushedGroup = true;
 50417:     }
 50417: 
 50417:     ~AutoCairoPixmanBugWorkaround()
 50417:     {
 50417:         if (mPushedGroup) {
 50417:             mContext->PopGroupToSource();
 50417:             mContext->Paint();
 50417:             mContext->Restore();
 50417:         }
 50417:     }
 50417: 
 79445:     bool PushedGroup() { return mPushedGroup; }
 79445:     bool Succeeded() { return mSucceeded; }
 50417: 
 50417: private:
 50417:     gfxContext* mContext;
 79445:     bool mSucceeded;
 79445:     bool mPushedGroup;
 50417: };
 50417: 
 50417: static gfxMatrix
 50417: DeviceToImageTransform(gfxContext* aContext,
 50417:                        const gfxMatrix& aUserSpaceToImageSpace)
 50417: {
 50417:     gfxFloat deviceX, deviceY;
 50417:     nsRefPtr<gfxASurface> currentTarget =
 50417:         aContext->CurrentSurface(&deviceX, &deviceY);
 50417:     gfxMatrix currentMatrix = aContext->CurrentMatrix();
 50417:     gfxMatrix deviceToUser = gfxMatrix(currentMatrix).Invert();
 50417:     deviceToUser.Translate(-gfxPoint(-deviceX, -deviceY));
 50417:     return gfxMatrix(deviceToUser).Multiply(aUserSpaceToImageSpace);
 50417: }
 50417: 
 97658: /* These heuristics are based on Source/WebCore/platform/graphics/skia/ImageSkia.cpp:computeResamplingMode() */
 97658: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
 97658: static gfxPattern::GraphicsFilter ReduceResamplingFilter(gfxPattern::GraphicsFilter aFilter,
 97658:                                                          int aImgWidth, int aImgHeight,
 97658:                                                          float aSourceWidth, float aSourceHeight)
 97658: {
 97658:     // Images smaller than this in either direction are considered "small" and
 97658:     // are not resampled ever (see below).
 97658:     const int kSmallImageSizeThreshold = 8;
 97658: 
 97658:     // The amount an image can be stretched in a single direction before we
 97658:     // say that it is being stretched so much that it must be a line or
 97658:     // background that doesn't need resampling.
 97658:     const float kLargeStretch = 3.0f;
 97658: 
 97658:     if (aImgWidth <= kSmallImageSizeThreshold
 97658:         || aImgHeight <= kSmallImageSizeThreshold) {
 97658:         // Never resample small images. These are often used for borders and
 97658:         // rules (think 1x1 images used to make lines).
 97658:         return gfxPattern::FILTER_NEAREST;
 97658:     }
 97658: 
 97658:     if (aImgHeight * kLargeStretch <= aSourceHeight || aImgWidth * kLargeStretch <= aSourceWidth) {
 97658:         // Large image tiling detected.
 97658: 
 97658:         // Don't resample if it is being tiled a lot in only one direction.
 97658:         // This is trying to catch cases where somebody has created a border
 97658:         // (which might be large) and then is stretching it to fill some part
 97658:         // of the page.
 97658:         if (fabs(aSourceWidth - aImgWidth)/aImgWidth < 0.5 || fabs(aSourceHeight - aImgHeight)/aImgHeight < 0.5)
 97658:             return gfxPattern::FILTER_NEAREST;
 97658: 
 97658:         // The image is growing a lot and in more than one direction. Resampling
 97658:         // is slow and doesn't give us very much when growing a lot.
 97658:         return aFilter;
 97658:     }
 97658: 
 97658:     /* Some notes on other heuristics:
 97658:        The Skia backend also uses nearest for backgrounds that are stretched by
 97658:        a large amount. I'm not sure this is common enough for us to worry about
 97658:        now. It also uses nearest for backgrounds/avoids high quality for images
 97658:        that are very slightly scaled.  I'm also not sure that very slightly
 97658:        scaled backgrounds are common enough us to worry about.
 97658: 
 97658:        We don't currently have much support for doing high quality interpolation.
 97658:        The only place this currently happens is on Quartz and we don't have as
 97658:        much control over it as would be needed. Webkit avoids using high quality
 97658:        resampling during load. It also avoids high quality if the transformation
 97658:        is not just a scale and translation
 97658: 
 97658:        WebKit bug #40045 added code to avoid resampling different parts
 97658:        of an image with different methods by using a resampling hint size.
 97658:        It currently looks unused in WebKit but it's something to watch out for.
 97658:     */
 97658: 
 97658:     return aFilter;
 97658: }
 97658: #else
 97658: static gfxPattern::GraphicsFilter ReduceResamplingFilter(gfxPattern::GraphicsFilter aFilter,
 97658:                                                           int aImgWidth, int aImgHeight,
 97658:                                                           int aSourceWidth, int aSourceHeight)
 97658: {
 97658:     // Just pass the filter through unchanged
 97658:     return aFilter;
 97658: }
 97658: #endif
 97658: 
 50417: /* static */ void
 50417: gfxUtils::DrawPixelSnapped(gfxContext*      aContext,
 50419:                            gfxDrawable*     aDrawable,
 50417:                            const gfxMatrix& aUserSpaceToImageSpace,
 50417:                            const gfxRect&   aSubimage,
 50417:                            const gfxRect&   aSourceRect,
 50417:                            const gfxRect&   aImageRect,
 50417:                            const gfxRect&   aFill,
 50417:                            const gfxImageSurface::gfxImageFormat aFormat,
 97658:                            gfxPattern::GraphicsFilter aFilter,
108991:                            uint32_t         aImageFlags)
 50417: {
 95736:     SAMPLE_LABEL("gfxUtils", "DrawPixelSnapped");
 95637:     bool doTile = !aImageRect.Contains(aSourceRect) &&
 95637:                   !(aImageFlags & imgIContainer::FLAG_CLAMP);
 50417: 
 50417:     nsRefPtr<gfxASurface> currentTarget = aContext->CurrentSurface();
 50417:     gfxMatrix deviceSpaceToImageSpace =
 50417:         DeviceToImageTransform(aContext, aUserSpaceToImageSpace);
 50417: 
 50417:     AutoCairoPixmanBugWorkaround workaround(aContext, deviceSpaceToImageSpace,
 86664:                                             aFill, currentTarget);
 50417:     if (!workaround.Succeeded())
 50417:         return;
 50417: 
 50419:     nsRefPtr<gfxDrawable> drawable = aDrawable;
 50417: 
 97658:     aFilter = ReduceResamplingFilter(aFilter, aImageRect.Width(), aImageRect.Height(), aSourceRect.Width(), aSourceRect.Height());
 97658: 
 99633:     gfxMatrix userSpaceToImageSpace = aUserSpaceToImageSpace;
 99633: 
 98641:     // On Mobile, we don't ever want to do this; it has the potential for
 98641:     // allocating very large temporary surfaces, especially since we'll
 98641:     // do full-page snapshots often (see bug 749426).
 99633: #ifdef MOZ_GFX_OPTIMIZE_MOBILE
 99633:     // If the pattern translation is large we can get into trouble with pixman's
 99633:     // 16 bit coordinate limits. For now, we only do this on platforms where
 99633:     // we know we have the pixman limits. 16384.0 is a somewhat arbitrary
 99633:     // large number to make sure we avoid the expensive fmod when we can, but
 99633:     // still maintain a safe margin from the actual limit
 99633:     if (doTile && (userSpaceToImageSpace.y0 > 16384.0 || userSpaceToImageSpace.x0 > 16384.0)) {
 99633:         userSpaceToImageSpace.x0 = fmod(userSpaceToImageSpace.x0, aImageRect.width);
 99633:         userSpaceToImageSpace.y0 = fmod(userSpaceToImageSpace.y0, aImageRect.height);
 99633:     }
 99633: #else
 50417:     // OK now, the hard part left is to account for the subimage sampling
 50417:     // restriction. If all the transforms involved are just integer
 50417:     // translations, then we assume no resampling will occur so there's
 50417:     // nothing to do.
 50417:     // XXX if only we had source-clipping in cairo!
 50419:     if (aContext->CurrentMatrix().HasNonIntegerTranslation() ||
 50419:         aUserSpaceToImageSpace.HasNonIntegerTranslation()) {
 50419:         if (doTile || !aSubimage.Contains(aImageRect)) {
 50419:             nsRefPtr<gfxDrawable> restrictedDrawable =
 50419:               CreateSamplingRestrictedDrawable(aDrawable, aContext,
 50419:                                                aUserSpaceToImageSpace, aSourceRect,
 50419:                                                aSubimage, aFormat);
 50419:             if (restrictedDrawable) {
 50419:                 drawable.swap(restrictedDrawable);
 50417:             }
 50417:         }
 50419:         // We no longer need to tile: Either we never needed to, or we already
 50419:         // filled a surface with the tiled pattern; this surface can now be
 50419:         // drawn without tiling.
 80486:         doTile = false;
 50417:     }
 98641: #endif
 50417: 
 50417:     gfxContext::GraphicsOperator op = aContext->CurrentOperator();
 50417:     if ((op == gfxContext::OPERATOR_OVER || workaround.PushedGroup()) &&
 50417:         aFormat == gfxASurface::ImageFormatRGB24) {
 50417:         aContext->SetOperator(OptimalFillOperator());
 50417:     }
 50417: 
 99633:     drawable->Draw(aContext, aFill, doTile, aFilter, userSpaceToImageSpace);
 50417: 
 50417:     aContext->SetOperator(op);
 50417: }
 50417: 
 52185: /* static */ int
 52185: gfxUtils::ImageFormatToDepth(gfxASurface::gfxImageFormat aFormat)
 52185: {
 52185:     switch (aFormat) {
 52185:         case gfxASurface::ImageFormatARGB32:
 52185:             return 32;
 52185:         case gfxASurface::ImageFormatRGB24:
 52185:             return 24;
 52185:         case gfxASurface::ImageFormatRGB16_565:
 52185:             return 16;
 52185:         default:
 52185:             break;
 52185:     }
 52185:     return 0;
 52185: }
 61310: 
 51956: static void
 61310: PathFromRegionInternal(gfxContext* aContext, const nsIntRegion& aRegion,
 79445:                        bool aSnap)
 51956: {
 51956:   aContext->NewPath();
 51956:   nsIntRegionRectIterator iter(aRegion);
 51956:   const nsIntRect* r;
106838:   while ((r = iter.Next()) != nullptr) {
 51956:     aContext->Rectangle(gfxRect(r->x, r->y, r->width, r->height), aSnap);
 51956:   }
 61310: }
 61310: 
 61310: static void
 61310: ClipToRegionInternal(gfxContext* aContext, const nsIntRegion& aRegion,
 79445:                      bool aSnap)
 61310: {
 61310:   PathFromRegionInternal(aContext, aRegion, aSnap);
 60911:   aContext->Clip();
 51956: }
 51956: 
 51956: /*static*/ void
 51956: gfxUtils::ClipToRegion(gfxContext* aContext, const nsIntRegion& aRegion)
 51956: {
 80486:   ClipToRegionInternal(aContext, aRegion, false);
 51956: }
 51956: 
 51956: /*static*/ void
 51956: gfxUtils::ClipToRegionSnapped(gfxContext* aContext, const nsIntRegion& aRegion)
 51956: {
 80486:   ClipToRegionInternal(aContext, aRegion, true);
 51956: }
 58579: 
 62161: /*static*/ gfxFloat
 62161: gfxUtils::ClampToScaleFactor(gfxFloat aVal)
 62161: {
 62161:   // Arbitary scale factor limitation. We can increase this
 62161:   // for better scaling performance at the cost of worse
 62161:   // quality.
 62161:   static const gfxFloat kScaleResolution = 2;
 62161: 
 62161:   // Negative scaling is just a flip and irrelevant to
 62161:   // our resolution calculation.
 62161:   if (aVal < 0.0) {
 62161:     aVal = -aVal;
 62161:   }
 62161: 
 62161:   gfxFloat power = log(aVal)/log(kScaleResolution);
 62161: 
 62161:   // If power is within 1e-6 of an integer, round to nearest to
 62161:   // prevent floating point errors, otherwise round up to the
 62161:   // next integer value.
 62161:   if (fabs(power - NS_round(power)) < 1e-6) {
 62161:     power = NS_round(power);
 62161:   } else {
 75359:     power = ceil(power);
 62161:   }
 62161: 
 97193:   gfxFloat scale = pow(kScaleResolution, power);
 97193: 
 97193:   return NS_MAX(scale, 1.0);
 62161: }
 62161: 
 62161: 
 61310: /*static*/ void
 61310: gfxUtils::PathFromRegion(gfxContext* aContext, const nsIntRegion& aRegion)
 61310: {
 80486:   PathFromRegionInternal(aContext, aRegion, false);
 61310: }
 61310: 
 61310: /*static*/ void
 61310: gfxUtils::PathFromRegionSnapped(gfxContext* aContext, const nsIntRegion& aRegion)
 61310: {
 80486:   PathFromRegionInternal(aContext, aRegion, true);
 61310: }
 61310: 
 61310: 
 79445: bool
 58579: gfxUtils::GfxRectToIntRect(const gfxRect& aIn, nsIntRect* aOut)
 58579: {
108991:   *aOut = nsIntRect(int32_t(aIn.X()), int32_t(aIn.Y()),
108991:   int32_t(aIn.Width()), int32_t(aIn.Height()));
 68638:   return gfxRect(aOut->x, aOut->y, aOut->width, aOut->height).IsEqualEdges(aIn);
 58579: }
 58579: 
 79424: void
 79424: gfxUtils::GetYCbCrToRGBDestFormatAndSize(const PlanarYCbCrImage::Data& aData,
 79424:                                          gfxASurface::gfxImageFormat& aSuggestedFormat,
 79424:                                          gfxIntSize& aSuggestedSize)
 79424: {
 79424:   gfx::YUVType yuvtype =
 79424:     gfx::TypeFromSize(aData.mYSize.width,
 79424:                       aData.mYSize.height,
 79424:                       aData.mCbCrSize.width,
 79424:                       aData.mCbCrSize.height);
 79424: 
 79424:   // 'prescale' is true if the scaling is to be done as part of the
 79424:   // YCbCr to RGB conversion rather than on the RGB data when rendered.
 79445:   bool prescale = aSuggestedSize.width > 0 && aSuggestedSize.height > 0 &&
 79424:                     aSuggestedSize != aData.mPicSize;
 79424: 
 79424:   if (aSuggestedFormat == gfxASurface::ImageFormatRGB16_565) {
 79424: #if defined(HAVE_YCBCR_TO_RGB565)
 79424:     if (prescale &&
 79424:         !gfx::IsScaleYCbCrToRGB565Fast(aData.mPicX,
 79424:                                        aData.mPicY,
 79424:                                        aData.mPicSize.width,
 79424:                                        aData.mPicSize.height,
 79424:                                        aSuggestedSize.width,
 79424:                                        aSuggestedSize.height,
 79424:                                        yuvtype,
 79424:                                        gfx::FILTER_BILINEAR) &&
 79424:         gfx::IsConvertYCbCrToRGB565Fast(aData.mPicX,
 79424:                                         aData.mPicY,
 79424:                                         aData.mPicSize.width,
 79424:                                         aData.mPicSize.height,
 79424:                                         yuvtype)) {
 80486:       prescale = false;
 79424:     }
 79424: #else
 79424:     // yuv2rgb16 function not available
 79424:     aSuggestedFormat = gfxASurface::ImageFormatRGB24;
 79424: #endif
 79424:   }
 79424:   else if (aSuggestedFormat != gfxASurface::ImageFormatRGB24) {
 79424:     // No other formats are currently supported.
 79424:     aSuggestedFormat = gfxASurface::ImageFormatRGB24;
 79424:   }
 79424:   if (aSuggestedFormat == gfxASurface::ImageFormatRGB24) {
 79424:     /* ScaleYCbCrToRGB32 does not support a picture offset, nor 4:4:4 data.
 79424:        See bugs 639415 and 640073. */
 79424:     if (aData.mPicX != 0 || aData.mPicY != 0 || yuvtype == gfx::YV24)
 80486:       prescale = false;
 79424:   }
 79424:   if (!prescale) {
 79424:     aSuggestedSize = aData.mPicSize;
 79424:   }
 79424: }
 79424: 
 79424: void
 79424: gfxUtils::ConvertYCbCrToRGB(const PlanarYCbCrImage::Data& aData,
 79424:                             const gfxASurface::gfxImageFormat& aDestFormat,
 79424:                             const gfxIntSize& aDestSize,
 79424:                             unsigned char* aDestBuffer,
108991:                             int32_t aStride)
 79424: {
116721:   // ConvertYCbCrToRGB et al. assume the chroma planes are rounded up if the
116721:   // luma plane is odd sized.
116721:   MOZ_ASSERT((aData.mCbCrSize.width == aData.mYSize.width ||
116721:               aData.mCbCrSize.width == (aData.mYSize.width + 1) >> 1) &&
116721:              (aData.mCbCrSize.height == aData.mYSize.height ||
116721:               aData.mCbCrSize.height == (aData.mYSize.height + 1) >> 1));
 79424:   gfx::YUVType yuvtype =
 79424:     gfx::TypeFromSize(aData.mYSize.width,
 79424:                       aData.mYSize.height,
 79424:                       aData.mCbCrSize.width,
 79424:                       aData.mCbCrSize.height);
 79424: 
 79424:   // Convert from YCbCr to RGB now, scaling the image if needed.
 79424:   if (aDestSize != aData.mPicSize) {
 79424: #if defined(HAVE_YCBCR_TO_RGB565)
 79424:     if (aDestFormat == gfxASurface::ImageFormatRGB16_565) {
 79424:       gfx::ScaleYCbCrToRGB565(aData.mYChannel,
 79424:                               aData.mCbChannel,
 79424:                               aData.mCrChannel,
 79424:                               aDestBuffer,
 79424:                               aData.mPicX,
 79424:                               aData.mPicY,
 79424:                               aData.mPicSize.width,
 79424:                               aData.mPicSize.height,
 79424:                               aDestSize.width,
 79424:                               aDestSize.height,
 79424:                               aData.mYStride,
 79424:                               aData.mCbCrStride,
 79424:                               aStride,
 79424:                               yuvtype,
 79424:                               gfx::FILTER_BILINEAR);
 79424:     } else
 79424: #endif
 79424:       gfx::ScaleYCbCrToRGB32(aData.mYChannel,
 79424:                              aData.mCbChannel,
 79424:                              aData.mCrChannel,
 79424:                              aDestBuffer,
 79424:                              aData.mPicSize.width,
 79424:                              aData.mPicSize.height,
 79424:                              aDestSize.width,
 79424:                              aDestSize.height,
 79424:                              aData.mYStride,
 79424:                              aData.mCbCrStride,
 79424:                              aStride,
 79424:                              yuvtype,
 79424:                              gfx::ROTATE_0,
 79424:                              gfx::FILTER_BILINEAR);
 79424:   } else { // no prescale
 79424: #if defined(HAVE_YCBCR_TO_RGB565)
 79424:     if (aDestFormat == gfxASurface::ImageFormatRGB16_565) {
 79424:       gfx::ConvertYCbCrToRGB565(aData.mYChannel,
 79424:                                 aData.mCbChannel,
 79424:                                 aData.mCrChannel,
 79424:                                 aDestBuffer,
 79424:                                 aData.mPicX,
 79424:                                 aData.mPicY,
 79424:                                 aData.mPicSize.width,
 79424:                                 aData.mPicSize.height,
 79424:                                 aData.mYStride,
 79424:                                 aData.mCbCrStride,
 79424:                                 aStride,
 79424:                                 yuvtype);
 79424:     } else // aDestFormat != gfxASurface::ImageFormatRGB16_565
 79424: #endif
 79424:       gfx::ConvertYCbCrToRGB32(aData.mYChannel,
 79424:                                aData.mCbChannel,
 79424:                                aData.mCrChannel,
 79424:                                aDestBuffer,
 79424:                                aData.mPicX,
 79424:                                aData.mPicY,
 79424:                                aData.mPicSize.width,
 79424:                                aData.mPicSize.height,
 79424:                                aData.mYStride,
 79424:                                aData.mCbCrStride,
 79424:                                aStride,
 79424:                                yuvtype);
 79424:   }
 79424: }
 82354: 
 82354: #ifdef MOZ_DUMP_PAINTING
 82354: /* static */ void
 82354: gfxUtils::WriteAsPNG(DrawTarget* aDT, const char* aFile)
 82354: {
 82354:   aDT->Flush();
 82354:   nsRefPtr<gfxASurface> surf = gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(aDT);
 82354:   if (surf) {
 82354:     surf->WriteAsPNG(aFile);
 82354:   } else {
 82354:     NS_WARNING("Failed to get Thebes surface!");
 82354:   }
 82354: }
 82354: 
 82354: /* static */ void
 82354: gfxUtils::DumpAsDataURL(DrawTarget* aDT)
 82354: {
 82354:   aDT->Flush();
 82354:   nsRefPtr<gfxASurface> surf = gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(aDT);
 82354:   if (surf) {
 82354:     surf->DumpAsDataURL();
 82354:   } else {
 82354:     NS_WARNING("Failed to get Thebes surface!");
 82354:   }
 82354: }
 82354: 
 82354: /* static */ void
 82354: gfxUtils::CopyAsDataURL(DrawTarget* aDT)
 82354: {
 82354:   aDT->Flush();
 82354:   nsRefPtr<gfxASurface> surf = gfxPlatform::GetPlatform()->GetThebesSurfaceForDrawTarget(aDT);
 82354:   if (surf) {
 82354:     surf->CopyAsDataURL();
 82354:   } else {
 82354:     NS_WARNING("Failed to get Thebes surface!");
 82354:   }
 82354: }
 93035: 
 94286: bool gfxUtils::sDumpPaintList = getenv("MOZ_DUMP_PAINT_LIST") != 0;
 94286: bool gfxUtils::sDumpPainting = getenv("MOZ_DUMP_PAINT") != 0;
 93035: bool gfxUtils::sDumpPaintingToFile = getenv("MOZ_DUMP_PAINT_TO_FILE") != 0;
 93035: FILE *gfxUtils::sDumpPaintFile = NULL;
 82354: #endif
