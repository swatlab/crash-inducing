131534: Components.utils.import("resource://gre/modules/XPCOMUtils.jsm");
131534: 
131534: XPCOMUtils.defineLazyModuleGetter(this, "Promise",
131534:   "resource://gre/modules/commonjs/sdk/core/promise.js");
131534: XPCOMUtils.defineLazyModuleGetter(this, "Task",
131534:   "resource://gre/modules/Task.jsm");
131534: XPCOMUtils.defineLazyModuleGetter(this, "PlacesUtils",
131534:   "resource://gre/modules/PlacesUtils.jsm");
131534: 
101264: function whenDelayedStartupFinished(aWindow, aCallback) {
101264:   Services.obs.addObserver(function observer(aSubject, aTopic) {
101264:     if (aWindow == aSubject) {
101264:       Services.obs.removeObserver(observer, aTopic);
101264:       executeSoon(aCallback);
101264:     }
101264:   }, "browser-delayed-startup-finished", false);
101264: }
101264: 
101264: function findChromeWindowByURI(aURI) {
101264:   let windows = Services.wm.getEnumerator(null);
101264:   while (windows.hasMoreElements()) {
101264:     let win = windows.getNext();
101264:     if (win.location.href == aURI)
101264:       return win;
101264:   }
101264:   return null;
101264: }
101264: 
 87662: function updateTabContextMenu(tab) {
 87662:   let menu = document.getElementById("tabContextMenu");
 87662:   if (!tab)
 87662:     tab = gBrowser.selectedTab;
101616:   var evt = new Event("");
101616:   tab.dispatchEvent(evt);
101616:   menu.openPopup(tab, "end_after", 0, 0, true, false, evt);
 87662:   is(TabContextMenu.contextTab, tab, "TabContextMenu context is the expected tab");
 87662:   menu.hidePopup();
 87662: }
101264: 
101264: function findToolbarCustomizationWindow(aBrowserWin) {
101264:   if (!aBrowserWin)
101264:     aBrowserWin = window;
101264: 
101264:   let iframe = aBrowserWin.document.getElementById("customizeToolbarSheetIFrame");
101264:   let win = iframe && iframe.contentWindow;
101264:   if (win)
101264:     return win;
101264: 
101264:   win = findChromeWindowByURI("chrome://global/content/customizeToolbar.xul");
101264:   if (win && win.opener == aBrowserWin)
101264:     return win;
101264: 
101264:   throw Error("Failed to find the customization window");
101264: }
101264: 
101264: function openToolbarCustomizationUI(aCallback, aBrowserWin) {
101264:   if (!aBrowserWin)
101264:     aBrowserWin = window;
101264: 
101264:   aBrowserWin.document.getElementById("cmd_CustomizeToolbars").doCommand();
101264: 
101264:   aBrowserWin.gNavToolbox.addEventListener("beforecustomization", function UI_loaded() {
101264:     aBrowserWin.gNavToolbox.removeEventListener("beforecustomization", UI_loaded);
101264: 
101264:     let win = findToolbarCustomizationWindow(aBrowserWin);
101264:     waitForFocus(function () {
101264:       aCallback(win);
101264:     }, win);
101264:   });
101264: }
101264: 
101264: function closeToolbarCustomizationUI(aCallback, aBrowserWin) {
101264:   let win = findToolbarCustomizationWindow(aBrowserWin);
101264: 
101264:   win.addEventListener("unload", function unloaded() {
101264:     win.removeEventListener("unload", unloaded);
101264:     executeSoon(aCallback);
101264:   });
101264: 
101264:   let button = win.document.getElementById("donebutton");
101264:   button.focus();
101264:   button.doCommand();
101264: }
102168: 
102168: function waitForCondition(condition, nextTest, errorMsg) {
102168:   var tries = 0;
102168:   var interval = setInterval(function() {
102168:     if (tries >= 30) {
102168:       ok(false, errorMsg);
102168:       moveOn();
102168:     }
102168:     if (condition()) {
102168:       moveOn();
102168:     }
102168:     tries++;
102168:   }, 100);
102168:   var moveOn = function() { clearInterval(interval); nextTest(); };
102168: }
105760: 
109452: function getTestPlugin() {
109452:   var ph = Cc["@mozilla.org/plugin/host;1"].getService(Ci.nsIPluginHost);
109452:   var tags = ph.getPluginTags();
109452: 
109452:   // Find the test plugin
109452:   for (var i = 0; i < tags.length; i++) {
109452:     if (tags[i].name == "Test Plug-in")
109452:       return tags[i];
109452:   }
109452:   ok(false, "Unable to find plugin");
109452:   return null;
109452: }
109452: 
124005: function updateBlocklist(aCallback) {
124005:   var blocklistNotifier = Cc["@mozilla.org/extensions/blocklist;1"]
124005:                           .getService(Ci.nsITimerCallback);
124005:   var observer = function() {
124005:     aCallback();
124005:     Services.obs.removeObserver(observer, "blocklist-updated");
124005:   };
124005:   Services.obs.addObserver(observer, "blocklist-updated", false);
124005:   blocklistNotifier.notify(null);
124005: }
124005: 
124375: var _originalTestBlocklistURL = null;
124005: function setAndUpdateBlocklist(aURL, aCallback) {
124375:   if (!_originalTestBlocklistURL)
124375:     _originalTestBlocklistURL = Services.prefs.getCharPref("extensions.blocklist.url");
124005:   Services.prefs.setCharPref("extensions.blocklist.url", aURL);
124005:   updateBlocklist(aCallback);
124005: }
124005: 
124375: function resetBlocklist() {
124375:   Services.prefs.setCharPref("extensions.blocklist.url", _originalTestBlocklistURL);
124005: }
124005: 
123932: function whenNewWindowLoaded(aOptions, aCallback) {
123932:   let win = OpenBrowserWindow(aOptions);
123932:   win.addEventListener("load", function onLoad() {
123932:     win.removeEventListener("load", onLoad, false);
123932:     aCallback(win);
123932:   }, false);
123932: }
130599: 
131534: /**
131534:  * Waits for all pending async statements on the default connection, before
131534:  * proceeding with aCallback.
131534:  *
131534:  * @param aCallback
131534:  *        Function to be called when done.
131534:  * @param aScope
131534:  *        Scope for the callback.
131534:  * @param aArguments
131534:  *        Arguments array for the callback.
131534:  *
131534:  * @note The result is achieved by asynchronously executing a query requiring
131534:  *       a write lock.  Since all statements on the same connection are
131534:  *       serialized, the end of this write operation means that all writes are
131534:  *       complete.  Note that WAL makes so that writers don't block readers, but
131534:  *       this is a problem only across different connections.
131534:  */
131534: function waitForAsyncUpdates(aCallback, aScope, aArguments) {
131534:   let scope = aScope || this;
131534:   let args = aArguments || [];
131534:   let db = PlacesUtils.history.QueryInterface(Ci.nsPIPlacesDatabase)
131534:                               .DBConnection;
131534:   let begin = db.createAsyncStatement("BEGIN EXCLUSIVE");
131534:   begin.executeAsync();
131534:   begin.finalize();
131534: 
131534:   let commit = db.createAsyncStatement("COMMIT");
131534:   commit.executeAsync({
131534:     handleResult: function() {},
131534:     handleError: function() {},
131534:     handleCompletion: function(aReason) {
131534:       aCallback.apply(scope, args);
131534:     }
131534:   });
131534:   commit.finalize();
131534: }
131534: 
131534: /**
131534:  * Asynchronously check a url is visited.
131534: 
131534:  * @param aURI The URI.
131534:  * @param aExpectedValue The expected value.
131534:  * @return {Promise}
131534:  * @resolves When the check has been added successfully.
131534:  * @rejects JavaScript exception.
131534:  */
131534: function promiseIsURIVisited(aURI, aExpectedValue) {
131534:   let deferred = Promise.defer();
131534:   PlacesUtils.asyncHistory.isURIVisited(aURI, function(aURI, aIsVisited) {
131534:     deferred.resolve(aIsVisited);
131534:   });
131534: 
131534:   return deferred.promise;
131534: }
131534: 
130599: function addVisits(aPlaceInfo, aCallback) {
130599:   let places = [];
130599:   if (aPlaceInfo instanceof Ci.nsIURI) {
130599:     places.push({ uri: aPlaceInfo });
130599:   } else if (Array.isArray(aPlaceInfo)) {
130599:     places = places.concat(aPlaceInfo);
130599:   } else {
130599:     places.push(aPlaceInfo);
130599:    }
130599: 
130599:   // Create mozIVisitInfo for each entry.
130599:   let now = Date.now();
130599:   for (let i = 0; i < places.length; i++) {
130599:     if (!places[i].title) {
130599:       places[i].title = "test visit for " + places[i].uri.spec;
130599:     }
130599:     places[i].visits = [{
130599:       transitionType: places[i].transition === undefined ? Ci.nsINavHistoryService.TRANSITION_LINK
130599:                                                          : places[i].transition,
130599:       visitDate: places[i].visitDate || (now++) * 1000,
130599:       referrerURI: places[i].referrer
130599:     }];
130599:   }
130599: 
130599:   PlacesUtils.asyncHistory.updatePlaces(
130599:     places,
130599:     {
130599:       handleError: function AAV_handleError() {
130599:         throw("Unexpected error in adding visit.");
130599:       },
130599:       handleResult: function () {},
130599:       handleCompletion: function UP_handleCompletion() {
130599:         if (aCallback)
130599:           aCallback();
130599:       }
130599:     }
130599:   );
130599: }
131537: 
131537: /**
131537:  * Ensures that the specified URIs are either cleared or not.
131537:  *
131537:  * @param aURIs
131537:  *        Array of page URIs
131537:  * @param aShouldBeCleared
131537:  *        True if each visit to the URI should be cleared, false otherwise
131537:  */
131537: function promiseHistoryClearedState(aURIs, aShouldBeCleared) {
131537:   let deferred = Promise.defer();
131537:   let callbackCount = 0;
131537:   let niceStr = aShouldBeCleared ? "no longer" : "still";
131537:   function callbackDone() {
131537:     if (++callbackCount == aURIs.length)
131537:       deferred.resolve();
131537:   }
131537:   aURIs.forEach(function (aURI) {
131537:     PlacesUtils.asyncHistory.isURIVisited(aURI, function(aURI, aIsVisited) {
131537:       is(aIsVisited, !aShouldBeCleared,
131537:          "history visit " + aURI.spec + " should " + niceStr + " exist");
131537:       callbackDone();
131537:     });
131537:   });
131537: 
131537:   return deferred.promise;
131537: }
