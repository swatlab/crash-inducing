 75154: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 2 -*-
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 54814: 
 75154: #include "mozilla/layers/PLayers.h"
 80467: 
 80467: /* This must occur *after* layers/PLayers.h to avoid typedefs conflicts. */
 80467: #include "mozilla/Util.h"
 80467: 
 54814: #include "ThebesLayerD3D10.h"
 54814: #include "gfxPlatform.h"
 54814: 
 54814: #include "gfxWindowsPlatform.h"
 54814: #ifdef CAIRO_HAS_D2D_SURFACE
 54814: #include "gfxD2DSurface.h"
 54814: #endif
 54814: 
 75147: #include "../d3d9/Nv3DVUtils.h"
 61473: #include "gfxTeeSurface.h"
 61473: #include "gfxUtils.h"
 62702: #include "ReadbackLayer.h"
 62702: #include "ReadbackProcessor.h"
 61473: 
 86671: #include "mozilla/Preferences.h"
 86671: #include "mozilla/gfx/2D.h"
 86671: 
 86671: using namespace mozilla::gfx;
 86671: 
 54814: namespace mozilla {
 54814: namespace layers {
 54814: 
 54814: ThebesLayerD3D10::ThebesLayerD3D10(LayerManagerD3D10 *aManager)
 54814:   : ThebesLayer(aManager, NULL)
 54814:   , LayerD3D10(aManager)
 64536:   , mCurrentSurfaceMode(SURFACE_OPAQUE)
 54814: {
 54814:   mImplData = static_cast<LayerD3D10*>(this);
 54814: }
 54814: 
 54814: ThebesLayerD3D10::~ThebesLayerD3D10()
 54814: {
 54814: }
 54814: 
 54814: void
 61470: ThebesLayerD3D10::InvalidateRegion(const nsIntRegion &aRegion)
 54814: {
115315:   mInvalidRegion.Or(mInvalidRegion, aRegion);
115315:   mInvalidRegion.SimplifyOutward(10);
115315:   mValidRegion.Sub(mValidRegion, mInvalidRegion);
 54814: }
 54814: 
 61470: void ThebesLayerD3D10::CopyRegion(ID3D10Texture2D* aSrc, const nsIntPoint &aSrcOffset,
 61470:                                   ID3D10Texture2D* aDest, const nsIntPoint &aDestOffset,
 72232:                                   const nsIntRegion &aCopyRegion, nsIntRegion* aValidRegion)
 61470: {
 54814:   nsIntRegion retainedRegion;
 61470:   nsIntRegionRectIterator iter(aCopyRegion);
 54814:   const nsIntRect *r;
 54814:   while ((r = iter.Next())) {
 54814:     // Calculate the retained rectangle's position on the old and the new
 72232:     // surface.
 54814:     D3D10_BOX box;
 72232:     box.left = r->x - aSrcOffset.x;
 72232:     box.top = r->y - aSrcOffset.y;
 72232:     box.right = box.left + r->width;
 72232:     box.bottom = box.top + r->height;
 61470:     box.back = 1;
 54814:     box.front = 0;
 54814: 
 61470:     device()->CopySubresourceRegion(aDest, 0,
 72232:                                     r->x - aDestOffset.x,
 72232:                                     r->y - aDestOffset.y,
 54814:                                     0,
 61470:                                     aSrc, 0,
 54814:                                     &box);
 54814: 
 54814:     retainedRegion.Or(retainedRegion, *r);
 54814:   }
 54814: 
 54814:   // Areas which were valid and were retained are still valid
 61470:   aValidRegion->And(*aValidRegion, retainedRegion);  
 54814: }
 54814: 
 54814: void
 57097: ThebesLayerD3D10::RenderLayer()
 54814: {
 54814:   if (!mTexture) {
 54814:     return;
 54814:   }
 54814: 
 57097:   SetEffectTransformAndOpacity();
 54814: 
 54814:   ID3D10EffectTechnique *technique;
 97436:   switch (mCurrentSurfaceMode) {
 97436:   case SURFACE_COMPONENT_ALPHA:
 97438:     technique = SelectShader(SHADER_COMPONENT_ALPHA | LoadMaskTexture());
 97436:     break;
 97436:   case SURFACE_OPAQUE:
 97438:     technique = SelectShader(SHADER_RGB | SHADER_PREMUL | LoadMaskTexture());
 97436:     break;
 97436:   case SURFACE_SINGLE_CHANNEL_ALPHA:
 97438:     technique = SelectShader(SHADER_RGBA | SHADER_PREMUL | LoadMaskTexture());
 97436:     break;
 97436:   default:
 97436:     NS_ERROR("Unknown mode");
 97436:     return;
 97436:   }
 54814: 
 54814:   nsIntRegionRectIterator iter(mVisibleRegion);
 54814: 
 54814:   const nsIntRect *iterRect;
 54814:   if (mSRView) {
 54814:     effect()->GetVariableByName("tRGB")->AsShaderResource()->SetResource(mSRView);
 54814:   }
 61473:   if (mSRViewOnWhite) {
 61473:     effect()->GetVariableByName("tRGBWhite")->AsShaderResource()->SetResource(mSRViewOnWhite);
 61473:   }
 54814: 
 54814:   while ((iterRect = iter.Next())) {
 54814:     effect()->GetVariableByName("vLayerQuad")->AsVector()->SetFloatVector(
 54814:       ShaderConstantRectD3D10(
 54814:         (float)iterRect->x,
 54814:         (float)iterRect->y,
 54814:         (float)iterRect->width,
 54814:         (float)iterRect->height)
 54814:       );
 54814: 
 54814:     effect()->GetVariableByName("vTextureCoords")->AsVector()->SetFloatVector(
 54814:       ShaderConstantRectD3D10(
 64536:         (float)(iterRect->x - mTextureRect.x) / (float)mTextureRect.width,
 64536:         (float)(iterRect->y - mTextureRect.y) / (float)mTextureRect.height,
 64536:         (float)iterRect->width / (float)mTextureRect.width,
 64536:         (float)iterRect->height / (float)mTextureRect.height)
 54814:       );
 54814: 
 54814:     technique->GetPassByIndex(0)->Apply(0);
 54814:     device()->Draw(4, 0);
 54814:   }
 54814: 
 54814:   // Set back to default.
 54814:   effect()->GetVariableByName("vTextureCoords")->AsVector()->
 54814:     SetFloatVector(ShaderConstantRectD3D10(0, 0, 1.0f, 1.0f));
 54814: }
 54814: 
 54814: void
 62702: ThebesLayerD3D10::Validate(ReadbackProcessor *aReadback)
 54814: {
 54814:   if (mVisibleRegion.IsEmpty()) {
 54814:     return;
 54814:   }
 54814: 
 64536:   nsIntRect newTextureRect = mVisibleRegion.GetBounds();
 64536: 
 61473:   SurfaceMode mode = GetSurfaceMode();
 61473:   if (mode == SURFACE_COMPONENT_ALPHA &&
 94667:       (!mParent || !mParent->SupportsComponentAlphaChildren())) {
 61473:     mode = SURFACE_SINGLE_CHANNEL_ALPHA;
 61473:   }
 64536:   // If we have a transform that requires resampling of our texture, then
 64536:   // we need to make sure we don't sample pixels that haven't been drawn.
 64536:   // We clamp sample coordinates to the texture rect, but when the visible region
 64536:   // doesn't fill the entire texture rect we need to make sure we draw all the
 64536:   // pixels in the texture rect anyway in case they get sampled.
 64536:   nsIntRegion neededRegion = mVisibleRegion;
 68638:   if (!neededRegion.GetBounds().IsEqualInterior(newTextureRect) ||
 64536:       neededRegion.GetNumRects() > 1) {
125632:     if (MayResample()) {
 64536:       neededRegion = newTextureRect;
 64536:       if (mode == SURFACE_OPAQUE) {
 64536:         // We're going to paint outside the visible region, but layout hasn't
 64536:         // promised that it will paint opaquely there, so we'll have to
 64536:         // treat this layer as transparent.
 64536:         mode = SURFACE_SINGLE_CHANNEL_ALPHA;
 64536:       }
 64536:     }
 64536:   }
 64536:   mCurrentSurfaceMode = mode;
 61473: 
 61473:   VerifyContentType(mode);
 54814: 
 62702:   nsTArray<ReadbackProcessor::Update> readbackUpdates;
 62702:   nsIntRegion readbackRegion;
 62702:   if (aReadback && UsedForReadback()) {
 62702:     aReadback->GetThebesLayerUpdates(this, &readbackUpdates, &readbackRegion);
 62702:   }
 62702: 
 61470:   if (mTexture) {
 68638:     if (!mTextureRect.IsEqualInterior(newTextureRect)) {
 61470:       nsRefPtr<ID3D10Texture2D> oldTexture = mTexture;
106838:       mTexture = nullptr;
 61473:       nsRefPtr<ID3D10Texture2D> oldTextureOnWhite = mTextureOnWhite;
106838:       mTextureOnWhite = nullptr;
 61470: 
 64536:       nsIntRegion retainRegion = mTextureRect;
 61470:       // Old visible region will become the region that is covered by both the
 61470:       // old and the new visible region.
 61470:       retainRegion.And(retainRegion, mVisibleRegion);
 61470:       // No point in retaining parts which were not valid.
 61470:       retainRegion.And(retainRegion, mValidRegion);
 61470: 
 64536:       CreateNewTextures(gfxIntSize(newTextureRect.width, newTextureRect.height), mode);
 64536: 
 61470:       nsIntRect largeRect = retainRegion.GetLargestRectangle();
 61470: 
 72232:       // If we had no hardware texture before, or have no retained area larger than
 72232:       // the retention threshold, we're not retaining and are done here.
 72232:       // If our texture creation failed this can mean a device reset is pending
 72232:       // and we should silently ignore the failure. In the future when device
 72232:       // failures are properly handled we should test for the type of failure
 72232:       // and gracefully handle different failures. See bug 569081.
114229:       if (!oldTexture || !mTexture) {
 61470:         mValidRegion.SetEmpty();
 61470:       } else {
 64536:         CopyRegion(oldTexture, mTextureRect.TopLeft(),
 64536:                    mTexture, newTextureRect.TopLeft(),
 72232:                    retainRegion, &mValidRegion);
 61473:         if (oldTextureOnWhite) {
 64536:           CopyRegion(oldTextureOnWhite, mTextureRect.TopLeft(),
 64536:                      mTextureOnWhite, newTextureRect.TopLeft(),
 72232:                      retainRegion, &mValidRegion);
 61473:         }
 61470:       }
 61470:     }
 61470:   }
 64536:   mTextureRect = newTextureRect;
 61470: 
 61473:   if (!mTexture || (mode == SURFACE_COMPONENT_ALPHA && !mTextureOnWhite)) {
 64536:     CreateNewTextures(gfxIntSize(newTextureRect.width, newTextureRect.height), mode);
 54814:     mValidRegion.SetEmpty();
 54814:   }
 54814: 
 64536:   nsIntRegion drawRegion;
 64536:   drawRegion.Sub(neededRegion, mValidRegion);
 64536: 
 64536:   if (!drawRegion.IsEmpty()) {
 60859:     LayerManagerD3D10::CallbackInfo cbInfo = mD3DManager->GetCallbackInfo();
 60859:     if (!cbInfo.Callback) {
 60859:       NS_ERROR("D3D10 should never need to update ThebesLayers in an empty transaction");
 60859:       return;
 60859:     }
 60859: 
 64536:     DrawRegion(drawRegion, mode);
 54814: 
 62702:     if (readbackUpdates.Length() > 0) {
 62702:       CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM,
 64536:                                  newTextureRect.width, newTextureRect.height,
 62702:                                  1, 1, 0, D3D10_USAGE_STAGING,
 62702:                                  D3D10_CPU_ACCESS_READ);
 62702: 
 62702:       nsRefPtr<ID3D10Texture2D> readbackTexture;
 81355:       HRESULT hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(readbackTexture));
 81355:       if (FAILED(hr)) {
 81355:         LayerManagerD3D10::ReportFailure(NS_LITERAL_CSTRING("ThebesLayerD3D10::Validate(): Failed to create texture"),
 81355:                                          hr);
 81355:         return;
 81355:       }
 81355: 
 62702:       device()->CopyResource(readbackTexture, mTexture);
 62702: 
108991:       for (uint32_t i = 0; i < readbackUpdates.Length(); i++) {
 62702:         mD3DManager->readbackManager()->PostTask(readbackTexture,
 62702:                                                  &readbackUpdates[i],
 64536:                                                  gfxPoint(newTextureRect.x, newTextureRect.y));
 62702:       }
 62702:     }
 62702: 
 64536:     mValidRegion = neededRegion;
 54814:   }
 54814: }
 54814: 
 54814: void
 54814: ThebesLayerD3D10::LayerManagerDestroyed()
 54814: {
106838:   mD3DManager = nullptr;
 54814: }
 54814: 
 54814: Layer*
 54814: ThebesLayerD3D10::GetLayer()
 54814: {
 54814:   return this;
 54814: }
 54814: 
 54814: void
 61473: ThebesLayerD3D10::VerifyContentType(SurfaceMode aMode)
 54814: {
 54814:   if (mD2DSurface) {
 61473:     gfxASurface::gfxContentType type = aMode != SURFACE_SINGLE_CHANNEL_ALPHA ?
 54814:       gfxASurface::CONTENT_COLOR : gfxASurface::CONTENT_COLOR_ALPHA;
 54814: 
 54814:     if (type != mD2DSurface->GetContentType()) {  
 54814:       mD2DSurface = new gfxD2DSurface(mTexture, type);
 54814: 
 54814:       if (!mD2DSurface || mD2DSurface->CairoStatus()) {
 54814:         NS_WARNING("Failed to create surface for ThebesLayerD3D10.");
106838:         mD2DSurface = nullptr;
 54814:         return;
 54814:       }
 61473: 
 54814:       mValidRegion.SetEmpty();
 54814:     }
 94667:   } else if (mDrawTarget) {
 94667:     SurfaceFormat format = aMode != SURFACE_SINGLE_CHANNEL_ALPHA ?
 94667:       FORMAT_B8G8R8X8 : FORMAT_B8G8R8A8;
 94667: 
 94667:     if (format != mDrawTarget->GetFormat()) {
 94667:       mDrawTarget = Factory::CreateDrawTargetForD3D10Texture(mTexture, format);
 94667: 
 94667:       if (!mDrawTarget) {
 94667:         NS_WARNING("Failed to create drawtarget for ThebesLayerD3D10.");
 94667:         return;
 94667:       }
 96940: 
 96940:       mValidRegion.SetEmpty();
 94667:     }
 94667:   }    
 61473: 
 61473:   if (aMode != SURFACE_COMPONENT_ALPHA && mTextureOnWhite) {
 61473:     // If we've transitioned away from component alpha, we can delete those resources.
106838:     mD2DSurfaceOnWhite = nullptr;
106838:     mSRViewOnWhite = nullptr;
106838:     mTextureOnWhite = nullptr;
 61473:     mValidRegion.SetEmpty();
 54814:   }
 54814: }
 61473: 
 94666: void
 94666: ThebesLayerD3D10::FillTexturesBlackWhite(const nsIntRegion& aRegion, const nsIntPoint& aOffset)
 94666: {
 94666:   if (mTexture && mTextureOnWhite) {
 94666:     // It would be more optimal to draw the actual geometry, but more code
 94666:     // and probably not worth the win here as this will often be a single
 94666:     // rect.
 94666:     nsRefPtr<ID3D10RenderTargetView> oldRT;
 94666:     device()->OMGetRenderTargets(1, getter_AddRefs(oldRT), NULL);
 94666: 
 94666:     nsRefPtr<ID3D10RenderTargetView> viewBlack;
 94666:     nsRefPtr<ID3D10RenderTargetView> viewWhite;
 94666:     device()->CreateRenderTargetView(mTexture, NULL, getter_AddRefs(viewBlack));
 94666:     device()->CreateRenderTargetView(mTextureOnWhite, NULL, getter_AddRefs(viewWhite));
 94666: 
 95179:     D3D10_RECT oldScissor;
 95179:     UINT numRects = 1;
 95179:     device()->RSGetScissorRects(&numRects, &oldScissor);
 95179: 
 94666:     D3D10_TEXTURE2D_DESC desc;
 94666:     mTexture->GetDesc(&desc);
 94666: 
 95179:     D3D10_RECT scissor = { 0, 0, desc.Width, desc.Height };
 95179:     device()->RSSetScissorRects(1, &scissor);
 95179: 
 95178:     mD3DManager->SetupInputAssembler();
 94666:     nsIntSize oldVP = mD3DManager->GetViewport();
 94666: 
 95179:     mD3DManager->SetViewport(nsIntSize(desc.Width, desc.Height));
 94666: 
 94666:     ID3D10RenderTargetView *views[2] = { viewBlack, viewWhite };
 94666:     device()->OMSetRenderTargets(2, views, NULL);
 94666: 
 94666:     gfx3DMatrix transform;
 94666:     transform.Translate(gfxPoint3D(-aOffset.x, -aOffset.y, 0));
 94666:     void* raw = &const_cast<gfx3DMatrix&>(transform)._11;
 94666:     effect()->GetVariableByName("mLayerTransform")->SetRawValue(raw, 0, 64);
 94666: 
 94666:     ID3D10EffectTechnique *technique =
 94666:       effect()->GetTechniqueByName("PrepareAlphaExtractionTextures");
 94666: 
 94666:     nsIntRegionRectIterator iter(aRegion);
 94666: 
 94666:     const nsIntRect *iterRect;
 94666:     while ((iterRect = iter.Next())) {
 94666:       effect()->GetVariableByName("vLayerQuad")->AsVector()->SetFloatVector(
 94666:         ShaderConstantRectD3D10(
 94666:           (float)iterRect->x,
 94666:           (float)iterRect->y,
 94666:           (float)iterRect->width,
 94666:           (float)iterRect->height)
 94666:         );
 94666: 
 94666:       technique->GetPassByIndex(0)->Apply(0);
 94666:       device()->Draw(4, 0);
 94666:     }
 94666: 
 94666:     views[0] = oldRT;
 94666:     device()->OMSetRenderTargets(1, views, NULL);
 94666:     mD3DManager->SetViewport(oldVP);
 95179:     device()->RSSetScissorRects(1, &oldScissor);
 61473:   }
 86671: }
 54814: 
 54814: void
 62165: ThebesLayerD3D10::DrawRegion(nsIntRegion &aRegion, SurfaceMode aMode)
 54814: {
 54814:   nsIntRect visibleRect = mVisibleRegion.GetBounds();
 54814: 
 86671:   if (!mD2DSurface && !mDrawTarget) {
 54814:     return;
 54814:   }
 54814: 
 61473:   nsRefPtr<gfxASurface> destinationSurface;
 61473:   
 61473:   if (aMode == SURFACE_COMPONENT_ALPHA) {
 94666:     FillTexturesBlackWhite(aRegion, visibleRect.TopLeft());
115720:     if (!gfxPlatform::GetPlatform()->SupportsAzureContent()) {
 61473:       gfxASurface* surfaces[2] = { mD2DSurface.get(), mD2DSurfaceOnWhite.get() };
 80467:       destinationSurface = new gfxTeeSurface(surfaces, ArrayLength(surfaces));
 61473:       // Using this surface as a source will likely go horribly wrong, since
 61473:       // only the onBlack surface will really be used, so alpha information will
 61473:       // be incorrect.
 80486:       destinationSurface->SetAllowUseAsSource(false);
 94667:     }
 61473:   } else {
 61473:     destinationSurface = mD2DSurface;
 61473:   }
 61473: 
 86671:   nsRefPtr<gfxContext> context;
 86671: 
 86671:   if (mDrawTarget) {
 86671:     context = new gfxContext(mDrawTarget);
 86671:   } else {
 86671:     context = new gfxContext(destinationSurface);
 86671:   }
 54814: 
 54814:   nsIntRegionRectIterator iter(aRegion);
 54814:   context->Translate(gfxPoint(-visibleRect.x, -visibleRect.y));
 54814:   context->NewPath();
 54814:   const nsIntRect *iterRect;
 54814:   while ((iterRect = iter.Next())) {
 54814:     context->Rectangle(gfxRect(iterRect->x, iterRect->y, iterRect->width, iterRect->height));
 94667:     if (mDrawTarget && aMode == SURFACE_SINGLE_CHANNEL_ALPHA) {
 86671:       mDrawTarget->ClearRect(Rect(iterRect->x, iterRect->y, iterRect->width, iterRect->height));
 86671:     }
 54814:   }
 54814:   context->Clip();
 54814: 
 86671:   if (!mDrawTarget && aMode == SURFACE_SINGLE_CHANNEL_ALPHA) {
 54814:     context->SetOperator(gfxContext::OPERATOR_CLEAR);
 54814:     context->Paint();
 54814:     context->SetOperator(gfxContext::OPERATOR_OVER);
 54814:   }
 54814: 
 86671:   if (mD2DSurface) {
 60658:     mD2DSurface->SetSubpixelAntialiasingEnabled(!(mContentFlags & CONTENT_COMPONENT_ALPHA));
 98514:   } else if (mDrawTarget) {
 98514:     mDrawTarget->SetPermitSubpixelAA(!(mContentFlags & CONTENT_COMPONENT_ALPHA));
 86671:   }
 60658: 
 54814:   LayerManagerD3D10::CallbackInfo cbInfo = mD3DManager->GetCallbackInfo();
 54814:   cbInfo.Callback(this, context, aRegion, nsIntRegion(), cbInfo.CallbackData);
 54814: }
 54814: 
 54814: void
 61473: ThebesLayerD3D10::CreateNewTextures(const gfxIntSize &aSize, SurfaceMode aMode)
 54814: {
 54814:   if (aSize.width == 0 || aSize.height == 0) {
 54814:     // Nothing to do.
 54814:     return;
 54814:   }
 54814: 
 72232:   CD3D10_TEXTURE2D_DESC desc(DXGI_FORMAT_B8G8R8A8_UNORM, aSize.width, aSize.height, 1, 1);
 54814:   desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
 61473:   HRESULT hr;
 54814: 
 61473:   if (!mTexture) {
 61473:     hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(mTexture));
 54814: 
 54814:     if (FAILED(hr)) {
 54814:       NS_WARNING("Failed to create new texture for ThebesLayerD3D10!");
 54814:       return;
 54814:     }
 54814: 
 54814:     hr = device()->CreateShaderResourceView(mTexture, NULL, getter_AddRefs(mSRView));
 54814: 
 54814:     if (FAILED(hr)) {
 54814:       NS_WARNING("Failed to create shader resource view for ThebesLayerD3D10.");
 54814:     }
 54814: 
115720:     if (!gfxPlatform::GetPlatform()->SupportsAzureContent()) {
 61473:       mD2DSurface = new gfxD2DSurface(mTexture, aMode != SURFACE_SINGLE_CHANNEL_ALPHA ?
 54814:                                                 gfxASurface::CONTENT_COLOR : gfxASurface::CONTENT_COLOR_ALPHA);
 54814: 
 54814:       if (!mD2DSurface || mD2DSurface->CairoStatus()) {
 54814:         NS_WARNING("Failed to create surface for ThebesLayerD3D10.");
 86671:         mD2DSurface = NULL;
 54814:         return;
 54814:       }
 86671:     } else {
106838:       mDrawTarget = nullptr;
 86671:     }
 61473:   }
 61473: 
 61473:   if (aMode == SURFACE_COMPONENT_ALPHA && !mTextureOnWhite) {
 61473:     hr = device()->CreateTexture2D(&desc, NULL, getter_AddRefs(mTextureOnWhite));
 61473: 
 61473:     if (FAILED(hr)) {
 61473:       NS_WARNING("Failed to create new texture for ThebesLayerD3D10!");
 61473:       return;
 61473:     }
 61473: 
 61473:     hr = device()->CreateShaderResourceView(mTextureOnWhite, NULL, getter_AddRefs(mSRViewOnWhite));
 61473: 
 61473:     if (FAILED(hr)) {
 61473:       NS_WARNING("Failed to create shader resource view for ThebesLayerD3D10.");
 61473:     }
 61473: 
115720:     if (!gfxPlatform::GetPlatform()->SupportsAzureContent()) {
 61473:       mD2DSurfaceOnWhite = new gfxD2DSurface(mTextureOnWhite, gfxASurface::CONTENT_COLOR);
 61473: 
 61473:       if (!mD2DSurfaceOnWhite || mD2DSurfaceOnWhite->CairoStatus()) {
 61473:         NS_WARNING("Failed to create surface for ThebesLayerD3D10.");
106838:         mD2DSurfaceOnWhite = nullptr;
 61473:         return;
 61473:       }
 94667:     } else {
106838:       mDrawTarget = nullptr;
 94667:     }
 94667:   }
 94667: 
115720:   if (gfxPlatform::GetPlatform()->SupportsAzureContent() && !mDrawTarget) {
 94667:     if (aMode == SURFACE_COMPONENT_ALPHA) {
 94667:       mDrawTarget = Factory::CreateDualDrawTargetForD3D10Textures(mTexture, mTextureOnWhite, FORMAT_B8G8R8X8);
 94667:     } else {
 94667:       mDrawTarget = Factory::CreateDrawTargetForD3D10Texture(mTexture, aMode != SURFACE_SINGLE_CHANNEL_ALPHA ?
 94667:         FORMAT_B8G8R8X8 : FORMAT_B8G8R8A8);
 94667:     }
 94667: 
 94667:     if (!mDrawTarget) {
 94667:       NS_WARNING("Failed to create DrawTarget for ThebesLayerD3D10.");
106838:       mDrawTarget = nullptr;
 94667:       return;
 94667:     }
 61473:   }
 54814: }
 54814: 
 54814: } /* namespace layers */
 54814: } /* namespace mozilla */
