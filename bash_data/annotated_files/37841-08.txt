36238: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
36238: /* ***** BEGIN LICENSE BLOCK *****
36238:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
36238:  *
36238:  * The contents of this file are subject to the Mozilla Public License Version
36238:  * 1.1 (the "License"); you may not use this file except in compliance with
36238:  * the License. You may obtain a copy of the License at
36238:  * http://www.mozilla.org/MPL/
36238:  *
36238:  * Software distributed under the License is distributed on an "AS IS" basis,
36238:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
36238:  * for the specific language governing rights and limitations under the
36238:  * License.
36238:  *
36238:  * The Original Code is mozilla.org code.
36238:  *
36238:  * The Initial Developer of the Original Code is
36238:  * Netscape Communications Corporation.
36238:  * Portions created by the Initial Developer are Copyright (C) 1998
36238:  * the Initial Developer. All Rights Reserved.
36238:  *
36238:  * Contributor(s):
36238:  *   Sean Echevarria <sean@beatnik.com>
36238:  *   HÃ¥kan Waara <hwaara@chello.se>
36238:  *   Josh Aas <josh@mozilla.com>
36238:  *
36238:  * Alternatively, the contents of this file may be used under the terms of
36238:  * either the GNU General Public License Version 2 or later (the "GPL"), or
36238:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
36238:  * in which case the provisions of the GPL or the LGPL are applicable instead
36238:  * of those above. If you wish to allow use of your version of this file only
36238:  * under the terms of either the GPL or the LGPL, and not to allow others to
36238:  * use your version of this file under the terms of the MPL, indicate your
36238:  * decision by deleting the provisions above and replace them with the notice
36238:  * and other provisions required by the GPL or the LGPL. If you do not delete
36238:  * the provisions above, a recipient may use your version of this file under
36238:  * the terms of any one of the MPL, the GPL or the LGPL.
36238:  *
36238:  * ***** END LICENSE BLOCK ***** */
36238: 
36238: #include "nsPluginTags.h"
36238: 
36238: #include "prlink.h"
36238: #include "plstr.h"
36238: #include "nsIPluginInstanceOwner.h"
36238: #include "nsIDocument.h"
36238: #include "nsServiceManagerUtils.h"
36238: #include "nsIPrefService.h"
36238: #include "nsIPrefBranch.h"
36238: #include "nsPluginsDir.h"
36238: #include "nsPluginHost.h"
36238: #include "nsIUnicodeDecoder.h"
36238: #include "nsIPlatformCharset.h"
36238: #include "nsICharsetConverterManager.h"
36238: #include "nsPluginLogging.h"
36238: #include "nsICategoryManager.h"
36355: #include "mozilla/TimeStamp.h"
36355: 
36355: using mozilla::TimeStamp;
36238: 
36238: inline char* new_str(const char* str)
36238: {
36238:   if (str == nsnull)
36238:     return nsnull;
36238:   
36238:   char* result = new char[strlen(str) + 1];
36238:   if (result != nsnull)
36238:     return strcpy(result, str);
36238:   return result;
36238: }
36238: 
36238: /* nsPluginTag */
36238: 
36238: nsPluginTag::nsPluginTag(nsPluginTag* aPluginTag)
36238: : mPluginHost(nsnull),
36238: mName(aPluginTag->mName),
36238: mDescription(aPluginTag->mDescription),
36238: mVariants(aPluginTag->mVariants),
36238: mMimeTypeArray(nsnull),
36238: mMimeDescriptionArray(aPluginTag->mMimeDescriptionArray),
36238: mExtensionsArray(nsnull),
36238: mLibrary(nsnull),
36238: mCanUnloadLibrary(PR_TRUE),
36238: mIsJavaPlugin(aPluginTag->mIsJavaPlugin),
36238: mIsNPRuntimeEnabledJavaPlugin(aPluginTag->mIsNPRuntimeEnabledJavaPlugin),
36238: mFileName(aPluginTag->mFileName),
36238: mFullPath(aPluginTag->mFullPath),
36238: mVersion(aPluginTag->mVersion),
36238: mLastModifiedTime(0),
36238: mFlags(NS_PLUGIN_FLAG_ENABLED)
36238: {
36238:   if (aPluginTag->mMimeTypeArray != nsnull) {
36238:     mMimeTypeArray = new char*[mVariants];
36238:     for (int i = 0; i < mVariants; i++)
36238:       mMimeTypeArray[i] = new_str(aPluginTag->mMimeTypeArray[i]);
36238:   }
36238:   
36238:   if (aPluginTag->mExtensionsArray != nsnull) {
36238:     mExtensionsArray = new char*[mVariants];
36238:     for (int i = 0; i < mVariants; i++)
36238:       mExtensionsArray[i] = new_str(aPluginTag->mExtensionsArray[i]);
36238:   }
36238: }
36238: 
36238: nsPluginTag::nsPluginTag(nsPluginInfo* aPluginInfo)
36238: : mPluginHost(nsnull),
36238: mName(aPluginInfo->fName),
36238: mDescription(aPluginInfo->fDescription),
36238: mVariants(aPluginInfo->fVariantCount),
36238: mMimeTypeArray(nsnull),
36238: mExtensionsArray(nsnull),
36238: mLibrary(nsnull),
36238: #ifdef XP_MACOSX
36238: mCanUnloadLibrary(!aPluginInfo->fBundle),
36238: #else
36238: mCanUnloadLibrary(PR_TRUE),
36238: #endif
36238: mIsJavaPlugin(PR_FALSE),
36238: mIsNPRuntimeEnabledJavaPlugin(PR_FALSE),
36238: mFileName(aPluginInfo->fFileName),
36238: mFullPath(aPluginInfo->fFullPath),
36238: mVersion(aPluginInfo->fVersion),
36238: mLastModifiedTime(0),
36238: mFlags(NS_PLUGIN_FLAG_ENABLED)
36238: {
36238:   if (aPluginInfo->fMimeTypeArray != nsnull) {
36238:     mMimeTypeArray = new char*[mVariants];
36238:     for (int i = 0; i < mVariants; i++) {
36238:       if (mIsJavaPlugin && aPluginInfo->fMimeTypeArray[i] &&
36238:           strcmp(aPluginInfo->fMimeTypeArray[i],
36238:                  "application/x-java-vm-npruntime") == 0) {
36238:             mIsNPRuntimeEnabledJavaPlugin = PR_TRUE;
36238:             
36238:             // Stop processing here, any mimetypes after the magic "I'm a
36238:             // NPRuntime enabled Java plugin" mimetype will be ignored.
36238:             mVariants = i;
36238:             
36238:             break;
36238:           }
36238:       
36238:       mMimeTypeArray[i] = new_str(aPluginInfo->fMimeTypeArray[i]);
36238:       if (nsPluginHost::IsJavaMIMEType(mMimeTypeArray[i]))
36238:         mIsJavaPlugin = PR_TRUE;
36238:     }
36238:   }
36238:   
36238:   if (aPluginInfo->fMimeDescriptionArray != nsnull) {
36238:     for (int i = 0; i < mVariants; i++) {
36238:       // we should cut off the list of suffixes which the mime
36238:       // description string may have, see bug 53895
36238:       // it is usually in form "some description (*.sf1, *.sf2)"
36238:       // so we can search for the opening round bracket
36238:       char cur = '\0';
36238:       char pre = '\0';
36238:       char * p = PL_strrchr(aPluginInfo->fMimeDescriptionArray[i], '(');
36238:       if (p && (p != aPluginInfo->fMimeDescriptionArray[i])) {
36238:         if ((p - 1) && *(p - 1) == ' ') {
36238:           pre = *(p - 1);
36238:           *(p - 1) = '\0';
36238:         } else {
36238:           cur = *p;
36238:           *p = '\0';
36238:         }
36238:         
36238:       }
36238:       mMimeDescriptionArray.AppendElement(
36238:                                           aPluginInfo->fMimeDescriptionArray[i]);
36238:       // restore the original string
36238:       if (cur != '\0')
36238:         *p = cur;
36238:       if (pre != '\0')
36238:         *(p - 1) = pre;
36238:     }
36238:   } else {
36238:     mMimeDescriptionArray.SetLength(mVariants);
36238:   }
36238:   
36238:   if (aPluginInfo->fExtensionArray != nsnull) {
36238:     mExtensionsArray = new char*[mVariants];
36238:     for (int i = 0; i < mVariants; i++)
36238:       mExtensionsArray[i] = new_str(aPluginInfo->fExtensionArray[i]);
36238:   }
36238:   
36238:   EnsureMembersAreUTF8();
36238: }
36238: 
36238: nsPluginTag::nsPluginTag(const char* aName,
36238:                          const char* aDescription,
36238:                          const char* aFileName,
36238:                          const char* aFullPath,
36238:                          const char* aVersion,
36238:                          const char* const* aMimeTypes,
36238:                          const char* const* aMimeDescriptions,
36238:                          const char* const* aExtensions,
36238:                          PRInt32 aVariants,
36238:                          PRInt64 aLastModifiedTime,
36238:                          PRBool aCanUnload,
36238:                          PRBool aArgsAreUTF8)
36238: : mPluginHost(nsnull),
36238: mName(aName),
36238: mDescription(aDescription),
36238: mVariants(aVariants),
36238: mMimeTypeArray(nsnull),
36238: mExtensionsArray(nsnull),
36238: mLibrary(nsnull),
36238: mCanUnloadLibrary(aCanUnload),
36238: mIsJavaPlugin(PR_FALSE),
36238: mIsNPRuntimeEnabledJavaPlugin(PR_FALSE),
36238: mFileName(aFileName),
36238: mFullPath(aFullPath),
36238: mVersion(aVersion),
36238: mLastModifiedTime(aLastModifiedTime),
36238: mFlags(0) // Caller will read in our flags from cache
36238: {
36238:   if (aVariants) {
36238:     mMimeTypeArray        = new char*[mVariants];
36238:     mExtensionsArray      = new char*[mVariants];
36238:     
36238:     for (PRInt32 i = 0; i < aVariants; ++i) {
36238:       if (mIsJavaPlugin && aMimeTypes[i] &&
36238:           strcmp(aMimeTypes[i], "application/x-java-vm-npruntime") == 0) {
36238:         mIsNPRuntimeEnabledJavaPlugin = PR_TRUE;
36238:         
36238:         // Stop processing here, any mimetypes after the magic "I'm a
36238:         // NPRuntime enabled Java plugin" mimetype will be ignored.
36238:         mVariants = i;
36238:         
36238:         break;
36238:       }
36238:       
36238:       mMimeTypeArray[i]        = new_str(aMimeTypes[i]);
36238:       mMimeDescriptionArray.AppendElement(aMimeDescriptions[i]);
36238:       mExtensionsArray[i]      = new_str(aExtensions[i]);
36238:       if (nsPluginHost::IsJavaMIMEType(mMimeTypeArray[i]))
36238:         mIsJavaPlugin = PR_TRUE;
36238:     }
36238:   }
36238:   
36238:   if (!aArgsAreUTF8)
36238:     EnsureMembersAreUTF8();
36238: }
36238: 
36238: nsPluginTag::~nsPluginTag()
36238: {
36238:   NS_ASSERTION(!mNext, "Risk of exhausting the stack space, bug 486349");
36238:   
36238:   if (mMimeTypeArray) {
36238:     for (int i = 0; i < mVariants; i++)
36238:       delete[] mMimeTypeArray[i];
36238:     
36238:     delete[] (mMimeTypeArray);
36238:     mMimeTypeArray = nsnull;
36238:   }
36238:   
36238:   if (mExtensionsArray) {
36238:     for (int i = 0; i < mVariants; i++)
36238:       delete[] mExtensionsArray[i];
36238:     
36238:     delete[] (mExtensionsArray);
36238:     mExtensionsArray = nsnull;
36238:   }
36238: }
36238: 
36238: NS_IMPL_ISUPPORTS1(nsPluginTag, nsIPluginTag)
36238: 
36238: static nsresult ConvertToUTF8(nsIUnicodeDecoder *aUnicodeDecoder,
36238:                               nsAFlatCString& aString)
36238: {
36238:   PRInt32 numberOfBytes = aString.Length();
36238:   PRInt32 outUnicodeLen;
36238:   nsAutoString buffer;
36238:   nsresult rv = aUnicodeDecoder->GetMaxLength(aString.get(), numberOfBytes,
36238:                                               &outUnicodeLen);
36238:   NS_ENSURE_SUCCESS(rv, rv);
36238:   if (!EnsureStringLength(buffer, outUnicodeLen))
36238:     return NS_ERROR_OUT_OF_MEMORY;
36238:   rv = aUnicodeDecoder->Convert(aString.get(), &numberOfBytes,
36238:                                 buffer.BeginWriting(), &outUnicodeLen);
36238:   NS_ENSURE_SUCCESS(rv, rv);
36238:   buffer.SetLength(outUnicodeLen);
36238:   CopyUTF16toUTF8(buffer, aString);
36238:   
36238:   return NS_OK;
36238: }
36238: 
36238: nsresult nsPluginTag::EnsureMembersAreUTF8()
36238: {
36238:   nsresult rv;
36238:   
36238:   nsCOMPtr<nsIPlatformCharset> pcs =
36238:   do_GetService(NS_PLATFORMCHARSET_CONTRACTID, &rv);
36238:   NS_ENSURE_SUCCESS(rv, rv);
36238:   nsCOMPtr<nsIUnicodeDecoder> decoder;
36238:   nsCOMPtr<nsICharsetConverterManager> ccm =
36238:   do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
36238:   NS_ENSURE_SUCCESS(rv, rv);
36238:   
36238:   nsCAutoString charset;
36238:   rv = pcs->GetCharset(kPlatformCharsetSel_FileName, charset);
36238:   NS_ENSURE_SUCCESS(rv, rv);
36238:   if (!charset.LowerCaseEqualsLiteral("utf-8")) {
36238:     rv = ccm->GetUnicodeDecoderRaw(charset.get(), getter_AddRefs(decoder));
36238:     NS_ENSURE_SUCCESS(rv, rv);
36238:     
36238:     ConvertToUTF8(decoder, mFileName);
36238:     ConvertToUTF8(decoder, mFullPath);
36238:   }
36238:   
36238:   // The description of the plug-in and the various MIME type descriptions
36238:   // should be encoded in the standard plain text file encoding for this system.
36238:   // XXX should we add kPlatformCharsetSel_PluginResource?
36238:   rv = pcs->GetCharset(kPlatformCharsetSel_PlainTextInFile, charset);
36238:   NS_ENSURE_SUCCESS(rv, rv);
36238:   if (!charset.LowerCaseEqualsLiteral("utf-8")) {
36238:     rv = ccm->GetUnicodeDecoderRaw(charset.get(), getter_AddRefs(decoder));
36238:     NS_ENSURE_SUCCESS(rv, rv);
36238:     
36238:     ConvertToUTF8(decoder, mName);
36238:     ConvertToUTF8(decoder, mDescription);
36238:     for (PRUint32 i = 0; i < mMimeDescriptionArray.Length(); ++i) {
36238:       ConvertToUTF8(decoder, mMimeDescriptionArray[i]);
36238:     }
36238:   }
36238:   return NS_OK;
36238: }
36238: 
36238: void nsPluginTag::SetHost(nsPluginHost * aHost)
36238: {
36238:   mPluginHost = aHost;
36238: }
36238: 
36238: NS_IMETHODIMP
36238: nsPluginTag::GetDescription(nsACString& aDescription)
36238: {
36238:   aDescription = mDescription;
36238:   return NS_OK;
36238: }
36238: 
36238: NS_IMETHODIMP
36238: nsPluginTag::GetFilename(nsACString& aFileName)
36238: {
36238:   aFileName = mFileName;
36238:   return NS_OK;
36238: }
36238: 
36238: NS_IMETHODIMP
36238: nsPluginTag::GetVersion(nsACString& aVersion)
36238: {
36238:   aVersion = mVersion;
36238:   return NS_OK;
36238: }
36238: 
36238: NS_IMETHODIMP
36238: nsPluginTag::GetName(nsACString& aName)
36238: {
36238:   aName = mName;
36238:   return NS_OK;
36238: }
36238: 
36238: NS_IMETHODIMP
36238: nsPluginTag::GetDisabled(PRBool* aDisabled)
36238: {
36238:   *aDisabled = !HasFlag(NS_PLUGIN_FLAG_ENABLED);
36238:   return NS_OK;
36238: }
36238: 
36238: NS_IMETHODIMP
36238: nsPluginTag::SetDisabled(PRBool aDisabled)
36238: {
36238:   if (HasFlag(NS_PLUGIN_FLAG_ENABLED) == !aDisabled)
36238:     return NS_OK;
36238:   
36238:   if (aDisabled)
36238:     UnMark(NS_PLUGIN_FLAG_ENABLED);
36238:   else
36238:     Mark(NS_PLUGIN_FLAG_ENABLED);
36238:   
36238:   mPluginHost->UpdatePluginInfo(this);
36238:   return NS_OK;
36238: }
36238: 
36238: NS_IMETHODIMP
36238: nsPluginTag::GetBlocklisted(PRBool* aBlocklisted)
36238: {
36238:   *aBlocklisted = HasFlag(NS_PLUGIN_FLAG_BLOCKLISTED);
36238:   return NS_OK;
36238: }
36238: 
36238: NS_IMETHODIMP
36238: nsPluginTag::SetBlocklisted(PRBool aBlocklisted)
36238: {
36238:   if (HasFlag(NS_PLUGIN_FLAG_BLOCKLISTED) == aBlocklisted)
36238:     return NS_OK;
36238:   
36238:   if (aBlocklisted)
36238:     Mark(NS_PLUGIN_FLAG_BLOCKLISTED);
36238:   else
36238:     UnMark(NS_PLUGIN_FLAG_BLOCKLISTED);
36238:   
36238:   mPluginHost->UpdatePluginInfo(nsnull);
36238:   return NS_OK;
36238: }
36238: 
36238: void
36238: nsPluginTag::RegisterWithCategoryManager(PRBool aOverrideInternalTypes,
36238:                                          nsPluginTag::nsRegisterType aType)
36238: {
36238:   if (!mMimeTypeArray)
36238:     return;
36238:   
36238:   PLUGIN_LOG(PLUGIN_LOG_NORMAL,
36238:              ("nsPluginTag::RegisterWithCategoryManager plugin=%s, removing = %s\n",
36238:               mFileName.get(), aType == ePluginUnregister ? "yes" : "no"));
36238:   
36238:   nsCOMPtr<nsICategoryManager> catMan = do_GetService(NS_CATEGORYMANAGER_CONTRACTID);
36238:   if (!catMan)
36238:     return;
36238:   
36238:   const char *contractId = "@mozilla.org/content/plugin/document-loader-factory;1";
36238:   
36238:   nsCOMPtr<nsIPrefBranch> psvc(do_GetService(NS_PREFSERVICE_CONTRACTID));
36238:   if (!psvc)
36238:     return; // NS_ERROR_OUT_OF_MEMORY
36238:   
36238:   // A preference controls whether or not the full page plugin is disabled for
36238:   // a particular type. The string must be in the form:
36238:   //   type1,type2,type3,type4
36238:   // Note: need an actual interface to control this and subsequent disabling 
36238:   // (and other plugin host settings) so applications can reliably disable 
36238:   // plugins - without relying on implementation details such as prefs/category
36238:   // manager entries.
36238:   nsXPIDLCString overrideTypes;
36238:   psvc->GetCharPref("plugin.disable_full_page_plugin_for_types", getter_Copies(overrideTypes));
36238:   nsCAutoString overrideTypesFormatted;
36238:   overrideTypesFormatted.Assign(',');
36238:   overrideTypesFormatted += overrideTypes;
36238:   overrideTypesFormatted.Append(',');
36238:   
36238:   nsACString::const_iterator start, end;
36238:   for (int i = 0; i < mVariants; i++) {
36238:     if (aType == ePluginUnregister) {
36238:       nsXPIDLCString value;
36238:       if (NS_SUCCEEDED(catMan->GetCategoryEntry("Gecko-Content-Viewers",
36238:                                                 mMimeTypeArray[i],
36238:                                                 getter_Copies(value)))) {
36238:         // Only delete the entry if a plugin registered for it
36238:         if (strcmp(value, contractId) == 0) {
36238:           catMan->DeleteCategoryEntry("Gecko-Content-Viewers",
36238:                                       mMimeTypeArray[i],
36238:                                       PR_TRUE);
36238:         }
36238:       }
36238:     } else {
36238:       overrideTypesFormatted.BeginReading(start);
36238:       overrideTypesFormatted.EndReading(end);
36238:       
36238:       nsDependentCString mimeType(mMimeTypeArray[i]);
36238:       nsCAutoString commaSeparated; 
36238:       commaSeparated.Assign(',');
36238:       commaSeparated += mimeType;
36238:       commaSeparated.Append(',');
36238:       if (!FindInReadable(commaSeparated, start, end)) {
36238:         catMan->AddCategoryEntry("Gecko-Content-Viewers",
36238:                                  mMimeTypeArray[i],
36238:                                  contractId,
36238:                                  PR_FALSE, /* persist: broken by bug 193031 */
36238:                                  aOverrideInternalTypes, /* replace if we're told to */
36238:                                  nsnull);
36238:       }
36238:     }
36238:     
36238:     PLUGIN_LOG(PLUGIN_LOG_NOISY,
36238:                ("nsPluginTag::RegisterWithCategoryManager mime=%s, plugin=%s\n",
36238:                 mMimeTypeArray[i], mFileName.get()));
36238:   }
36238: }
36238: 
36238: void nsPluginTag::Mark(PRUint32 mask)
36238: {
36238:   PRBool wasEnabled = IsEnabled();
36238:   mFlags |= mask;
36238:   // Update entries in the category manager if necessary.
36238:   if (mPluginHost && wasEnabled != IsEnabled()) {
36238:     if (wasEnabled)
36238:       RegisterWithCategoryManager(PR_FALSE, nsPluginTag::ePluginUnregister);
36238:     else
36238:       RegisterWithCategoryManager(PR_FALSE, nsPluginTag::ePluginRegister);
36238:   }
36238: }
36238: 
36238: void nsPluginTag::UnMark(PRUint32 mask)
36238: {
36238:   PRBool wasEnabled = IsEnabled();
36238:   mFlags &= ~mask;
36238:   // Update entries in the category manager if necessary.
36238:   if (mPluginHost && wasEnabled != IsEnabled()) {
36238:     if (wasEnabled)
36238:       RegisterWithCategoryManager(PR_FALSE, nsPluginTag::ePluginUnregister);
36238:     else
36238:       RegisterWithCategoryManager(PR_FALSE, nsPluginTag::ePluginRegister);
36238:   }
36238: }
36238: 
36238: PRBool nsPluginTag::HasFlag(PRUint32 flag)
36238: {
36238:   return (mFlags & flag) != 0;
36238: }
36238: 
36238: PRUint32 nsPluginTag::Flags()
36238: {
36238:   return mFlags;
36238: }
36238: 
36238: PRBool nsPluginTag::IsEnabled()
36238: {
36238:   return HasFlag(NS_PLUGIN_FLAG_ENABLED) && !HasFlag(NS_PLUGIN_FLAG_BLOCKLISTED);
36238: }
36238: 
36238: PRBool nsPluginTag::Equals(nsPluginTag *aPluginTag)
36238: {
36238:   NS_ENSURE_TRUE(aPluginTag, PR_FALSE);
36238:   
36238:   if ((!mName.Equals(aPluginTag->mName)) ||
36238:       (!mDescription.Equals(aPluginTag->mDescription)) ||
36238:       (mVariants != aPluginTag->mVariants))
36238:     return PR_FALSE;
36238:   
36238:   if (mVariants && mMimeTypeArray && aPluginTag->mMimeTypeArray) {
36238:     for (PRInt32 i = 0; i < mVariants; i++) {
36238:       if (PL_strcmp(mMimeTypeArray[i], aPluginTag->mMimeTypeArray[i]) != 0)
36238:         return PR_FALSE;
36238:     }
36238:   }
36238:   return PR_TRUE;
36238: }
36238: 
36238: void nsPluginTag::TryUnloadPlugin()
36238: {
36238:   if (mEntryPoint) {
36238:     mEntryPoint->Shutdown();
36238:     mEntryPoint = nsnull;
36238:   }
36238:   
36238:   // before we unload check if we are allowed to, see bug #61388
36238:   if (mLibrary && mCanUnloadLibrary) {
36238:     // unload the plugin asynchronously by posting a PLEvent
36238:     nsPluginHost::PostPluginUnloadEvent(mLibrary);
36238:   }
36238:   
36238:   // we should zero it anyway, it is going to be unloaded by
36238:   // CleanUnsedLibraries before we need to call the library
36238:   // again so the calling code should not be fooled and reload
36238:   // the library fresh
36238:   mLibrary = nsnull;
36238:   
36238:   // Remove mime types added to the category manager
36238:   // only if we were made 'active' by setting the host
36238:   if (mPluginHost) {
36238:     RegisterWithCategoryManager(PR_FALSE, nsPluginTag::ePluginUnregister);
36238:   }
36238: }
37841: 
37841: /* nsPluginInstanceTag */
37841: 
37841: nsPluginInstanceTag::nsPluginInstanceTag(nsPluginTag* aPluginTag,
37841:                                          nsIPluginInstance* aInstance,
37841:                                          const char * url,
37841:                                          PRBool aDefaultPlugin)
37841: {
37841:   NS_ASSERTION(aInstance, "Must have a valid plugin instance when creating an nsPluginInstanceTag");
37841:   NS_ADDREF(aInstance);
37841:   mInstance = static_cast<nsNPAPIPluginInstance*>(aInstance);
37841: 
37841:   mPluginTag = aPluginTag;
37841:   
37841:   mURL = PL_strdup(url);
37841: 
37841:   mDefaultPlugin = aDefaultPlugin;
37841: }
37841: 
37841: nsPluginInstanceTag::~nsPluginInstanceTag()
37841: {
37841:   mPluginTag = nsnull;
37841: 
37841:   nsCOMPtr<nsIPluginInstanceOwner> owner;
37841:   mInstance->GetOwner(getter_AddRefs(owner));
37841:   if (owner)
37841:     owner->SetInstance(nsnull);
37841:   mInstance->InvalidateOwner();
37841: 
37841:   NS_RELEASE(mInstance);
37841: 
37841:   PL_strfree(mURL);
37841: }
