33486: /* vim: se cin sw=2 ts=2 et : */
33486: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
33486:  *
33486:  * ***** BEGIN LICENSE BLOCK *****
33486:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
33486:  *
33486:  * The contents of this file are subject to the Mozilla Public License Version
33486:  * 1.1 (the "License"); you may not use this file except in compliance with
33486:  * the License. You may obtain a copy of the License at
33486:  * http://www.mozilla.org/MPL/
33486:  *
33486:  * Software distributed under the License is distributed on an "AS IS" basis,
33486:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
33486:  * for the specific language governing rights and limitations under the
33486:  * License.
33486:  *
33486:  * The Original Code is mozilla.org code.
33486:  *
33486:  * The Initial Developer of the Original Code is
33486:  * Mozilla Foundation.
33486:  * Portions created by the Initial Developer are Copyright (C) 2009
33486:  * the Initial Developer. All Rights Reserved.
33486:  *
33486:  * Contributor(s):
33486:  *   Rob Arnold <tellrob@gmail.com>
33519:  *   Jim Mathies <jmathies@mozilla.com>
33486:  *
33486:  * Alternatively, the contents of this file may be used under the terms of
33486:  * either the GNU General Public License Version 2 or later (the "GPL"), or
33486:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
33486:  * in which case the provisions of the GPL or the LGPL are applicable instead
33486:  * of those above. If you wish to allow use of your version of this file only
33486:  * under the terms of either the GPL or the LGPL, and not to allow others to
33486:  * use your version of this file under the terms of the MPL, indicate your
33486:  * decision by deleting the provisions above and replace them with the notice
33486:  * and other provisions required by the GPL or the LGPL. If you do not delete
33486:  * the provisions above, a recipient may use your version of this file under
33486:  * the terms of any one of the MPL, the GPL or the LGPL.
33486:  *
33486:  * ***** END LICENSE BLOCK ***** */
33486: 
33486: #if MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
33486: 
33486: #include "WinTaskbar.h"
33486: #include "TaskbarPreview.h"
33486: #include <nsITaskbarPreviewController.h>
33486: 
33486: #include <nsError.h>
33486: #include <nsCOMPtr.h>
33486: #include <nsIWidget.h>
33486: #include <nsIBaseWindow.h>
33486: #include <nsIObserverService.h>
33486: #include <nsServiceManagerUtils.h>
33486: #include <nsAutoPtr.h>
42343: #include "nsIXULAppInfo.h"
33519: #include "nsIJumpListBuilder.h"
33486: #include "nsUXThemeData.h"
33486: #include "nsWindow.h"
33486: #include "TaskbarTabPreview.h"
33486: #include "TaskbarWindowPreview.h"
33519: #include "JumpListBuilder.h"
33519: #include "nsWidgetsCID.h"
42348: #include "nsPIDOMWindow.h"
33486: #include <io.h>
42348: #include <propvarutil.h>
42348: #include <propkey.h>
42348: #include <shellapi.h>
33486: 
33519: const PRUnichar kShellLibraryName[] =  L"shell32.dll";
33519: 
33519: static NS_DEFINE_CID(kJumpListBuilderCID, NS_WIN_JUMPLISTBUILDER_CID);
33519: 
33486: namespace {
42343: 
33486: HWND
33486: GetHWNDFromDocShell(nsIDocShell *aShell) {
33486:   nsCOMPtr<nsIBaseWindow> baseWindow(do_QueryInterface(reinterpret_cast<nsISupports*>(aShell)));
33486: 
33486:   if (!baseWindow)
33486:     return NULL;
33486: 
33486:   nsCOMPtr<nsIWidget> widget;
33486:   baseWindow->GetMainWidget(getter_AddRefs(widget));
33486: 
33486:   return widget ? (HWND)widget->GetNativeData(NS_NATIVE_WINDOW) : NULL;
33486: }
33486: 
42348: HWND
42348: GetHWNDFromDOMWindow(nsIDOMWindow *dw) {
42348:   nsCOMPtr<nsIWidget> widget;
42348: 
42348:   nsCOMPtr<nsPIDOMWindow> window = do_QueryInterface(dw);
42348:   if (!window) 
42348:     return NULL;
42348: 
42348:   return GetHWNDFromDocShell(window->GetDocShell());
42348: }
42348: 
42348: nsresult
42348: SetWindowAppUserModelProp(nsIDOMWindow *aParent,
42348:                           const nsString & aIdentifier) {
42348:   NS_ENSURE_ARG_POINTER(aParent);
42348: 
42348:   if (aIdentifier.IsEmpty())
42348:     return NS_ERROR_INVALID_ARG;
42348: 
42348:   HWND toplevelHWND = ::GetAncestor(GetHWNDFromDOMWindow(aParent), GA_ROOT);
42348: 
42348:   if (!toplevelHWND)
42348:     return NS_ERROR_INVALID_ARG;
42348: 
42348:   typedef HRESULT (WINAPI * SHGetPropertyStoreForWindowPtr)
42348:                     (HWND hwnd, REFIID riid, void** ppv);
42348:   SHGetPropertyStoreForWindowPtr funcGetProStore = nsnull;
42348: 
42348:   HMODULE hDLL = ::LoadLibraryW(kShellLibraryName);
42348:   funcGetProStore = (SHGetPropertyStoreForWindowPtr)
42348:     GetProcAddress(hDLL, "SHGetPropertyStoreForWindow");
42348: 
42348:   if (!funcGetProStore) {
42348:     FreeLibrary(hDLL);
42348:     return NS_ERROR_NO_INTERFACE;
42348:   }
42348: 
42348:   IPropertyStore* pPropStore;
42348:   if (FAILED(funcGetProStore(toplevelHWND,
42348:                              IID_PPV_ARGS(&pPropStore)))) {
42348:     FreeLibrary(hDLL);
42348:     return NS_ERROR_INVALID_ARG;
42348:   }
42348: 
42348:   PROPVARIANT pv;
42348:   if (FAILED(InitPropVariantFromString(aIdentifier.get(), &pv))) {
42348:     pPropStore->Release();
42348:     FreeLibrary(hDLL);
42348:     return NS_ERROR_UNEXPECTED;
42348:   }
42348: 
42348:   nsresult rv = NS_OK;
42348:   if (FAILED(pPropStore->SetValue(PKEY_AppUserModel_ID, pv)) ||
42348:       FAILED(pPropStore->Commit())) {
42348:     rv = NS_ERROR_FAILURE;
42348:   }
42348: 
42348:   PropVariantClear(&pv);
42348:   pPropStore->Release();
42348:   FreeLibrary(hDLL);
42348: 
42348:   return rv;
42348: }
42348: 
42343: ///////////////////////////////////////////////////////////////////////////////
42343: // default nsITaskbarPreviewController
42343: 
33486: class DefaultController : public nsITaskbarPreviewController
33486: {
33486:   HWND mWnd;
33486: public:
33486:   DefaultController(HWND hWnd) 
33486:     : mWnd(hWnd)
33486:   {
33486:   }
33486: 
33486:   NS_DECL_ISUPPORTS
33486:   NS_DECL_NSITASKBARPREVIEWCONTROLLER
33486: };
33486: 
33486: NS_IMETHODIMP
33486: DefaultController::GetWidth(PRUint32 *aWidth)
33486: {
33486:   RECT r;
33486:   ::GetClientRect(mWnd, &r);
33486:   *aWidth = r.right;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: DefaultController::GetHeight(PRUint32 *aHeight)
33486: {
33486:   RECT r;
33486:   ::GetClientRect(mWnd, &r);
33486:   *aHeight = r.bottom;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: DefaultController::GetThumbnailAspectRatio(float *aThumbnailAspectRatio) {
33486:   PRUint32 width, height;
33486:   GetWidth(&width);
33486:   GetHeight(&height);
33486:   if (!height)
33486:     height = 1;
33486: 
33486:   *aThumbnailAspectRatio = width/float(height);
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: DefaultController::DrawPreview(nsIDOMCanvasRenderingContext2D *ctx, PRBool *rDrawFrame) {
33486:   *rDrawFrame = PR_TRUE;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: DefaultController::DrawThumbnail(nsIDOMCanvasRenderingContext2D *ctx, PRUint32 width, PRUint32 height, PRBool *rDrawFrame) {
33486:   *rDrawFrame = PR_FALSE;
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: DefaultController::OnClose(void) {
33486:   NS_NOTREACHED("OnClose should not be called for TaskbarWindowPreviews");
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: DefaultController::OnActivate(PRBool *rAcceptActivation) {
33486:   *rAcceptActivation = PR_TRUE;
33486:   NS_NOTREACHED("OnActivate should not be called for TaskbarWindowPreviews");
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: DefaultController::OnClick(nsITaskbarPreviewButton *button) {
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMPL_ISUPPORTS1(DefaultController, nsITaskbarPreviewController);
33486: }
33486: 
33486: namespace mozilla {
33486: namespace widget {
33486: 
42343: ///////////////////////////////////////////////////////////////////////////////
42343: // nsIWinTaskbar
33519: 
42343: NS_IMPL_THREADSAFE_ISUPPORTS1(WinTaskbar, nsIWinTaskbar)
33486: 
42343: PRBool
42343: WinTaskbar::Initialize() {
42343:   if (mTaskbar)
42343:     return PR_TRUE;
33722: 
33486:   ::CoInitialize(NULL);
33486:   HRESULT hr = ::CoCreateInstance(CLSID_TaskbarList,
33486:                                   NULL,
33486:                                   CLSCTX_INPROC_SERVER,
33486:                                   IID_ITaskbarList4,
33486:                                   (void**)&mTaskbar);
33486:   if (FAILED(hr))
42343:     return PR_FALSE;
33486: 
33486:   hr = mTaskbar->HrInit();
33486:   if (FAILED(hr)) {
33486:     NS_WARNING("Unable to initialize taskbar");
33486:     NS_RELEASE(mTaskbar);
42343:     return PR_FALSE;
33486:   }
42343:   return PR_TRUE;
42343: }
42343: 
42343: WinTaskbar::WinTaskbar() 
42343:   : mTaskbar(nsnull) {
33486: }
33486: 
33486: WinTaskbar::~WinTaskbar() {
42343:   if (mTaskbar) { // match successful Initialize() call
42343:     NS_RELEASE(mTaskbar);
33486:     ::CoUninitialize();
33486:   }
42343: }
42343: 
42343: // static
42343: PRBool
42343: WinTaskbar::GetAppUserModelID(nsAString & aDefaultGroupId) {
42343:   nsCOMPtr<nsIXULAppInfo> appInfo =
42343:     do_GetService("@mozilla.org/xre/app-info;1");
42343:   if (!appInfo)
42343:     return PR_FALSE;
42343: 
42343:   // The default, pulled from application.ini:
42343:   // 'vendor.application.version'
42343:   nsCString val;
42343:   if (NS_SUCCEEDED(appInfo->GetVendor(val))) {
42343:     AppendASCIItoUTF16(val, aDefaultGroupId);
42343:     aDefaultGroupId.Append(PRUnichar('.'));
42343:   }
42343:   if (NS_SUCCEEDED(appInfo->GetName(val))) {
42343:     AppendASCIItoUTF16(val, aDefaultGroupId);
42343:     aDefaultGroupId.Append(PRUnichar('.'));
42343:   }
42343:   if (NS_SUCCEEDED(appInfo->GetVersion(val))) {
42343:     AppendASCIItoUTF16(val, aDefaultGroupId);
42343:   }
42343: 
42343:   return aDefaultGroupId.IsEmpty() ? PR_FALSE : PR_TRUE;
42343: }
42343: 
42343: /* readonly attribute AString defaultGroupId; */
42343: NS_IMETHODIMP
42343: WinTaskbar::GetDefaultGroupId(nsAString & aDefaultGroupId) {
42343:   if (!GetAppUserModelID(aDefaultGroupId))
42343:     return NS_ERROR_UNEXPECTED;
42343: 
42343:   return NS_OK;
42343: }
33486: 
33519: // (static) Called from AppShell
42343: PRBool
42343: WinTaskbar::RegisterAppUserModelID() {
33722:   if (nsWindow::GetWindowsVersion() < WIN7_VERSION)
33722:     return PR_FALSE;
33722: 
33519:   SetCurrentProcessExplicitAppUserModelIDPtr funcAppUserModelID = nsnull;
33519:   PRBool retVal = PR_FALSE;
33519: 
42343:   nsAutoString uid;
42343:   if (!GetAppUserModelID(uid))
33519:     return PR_FALSE;
33519: 
33519:   HMODULE hDLL = ::LoadLibraryW(kShellLibraryName);
33519: 
33519:   funcAppUserModelID = (SetCurrentProcessExplicitAppUserModelIDPtr)
33519:                         GetProcAddress(hDLL, "SetCurrentProcessExplicitAppUserModelID");
33519: 
42343:   if (!funcAppUserModelID) {
42343:     ::FreeLibrary(hDLL);
42343:     return PR_FALSE;
42343:   }
42343: 
42343:   if (SUCCEEDED(funcAppUserModelID(uid.get())))
33519:     retVal = PR_TRUE;
33519: 
33519:   if (hDLL)
33519:     ::FreeLibrary(hDLL);
33519: 
33519:   return retVal;
33519: }
33519: 
33486: NS_IMETHODIMP
33486: WinTaskbar::GetAvailable(PRBool *aAvailable) {
42343:   *aAvailable = 
42343:     nsWindow::GetWindowsVersion() < WIN7_VERSION ?
42343:     PR_FALSE : PR_TRUE;
42343: 
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: WinTaskbar::CreateTaskbarTabPreview(nsIDocShell *shell, nsITaskbarPreviewController *controller, nsITaskbarTabPreview **_retval) {
42343:   if (!Initialize())
42343:     return NS_ERROR_NOT_AVAILABLE;
33486: 
33486:   NS_ENSURE_ARG_POINTER(shell);
33486:   NS_ENSURE_ARG_POINTER(controller);
33486: 
33486:   HWND toplevelHWND = ::GetAncestor(GetHWNDFromDocShell(shell), GA_ROOT);
33486: 
41482:   if (!toplevelHWND)
41482:     return NS_ERROR_INVALID_ARG;
41482: 
61918:   nsWindow *window = nsWindow::GetNSWindowPtr(toplevelHWND);
61918: 
61918:   if (!window)
61918:     return NS_ERROR_INVALID_ARG;
61918: 
33486:   nsRefPtr<TaskbarTabPreview> preview(new TaskbarTabPreview(mTaskbar, controller, toplevelHWND, shell));
33486:   if (!preview)
33486:     return NS_ERROR_OUT_OF_MEMORY;
33486: 
33486:   preview.forget(_retval);
33486: 
33486:   return NS_OK;
33486: }
33486: 
33486: NS_IMETHODIMP
33486: WinTaskbar::GetTaskbarWindowPreview(nsIDocShell *shell, nsITaskbarWindowPreview **_retval) {
42343:   if (!Initialize())
42343:     return NS_ERROR_NOT_AVAILABLE;
33486: 
33486:   NS_ENSURE_ARG_POINTER(shell);
33486: 
33486:   HWND toplevelHWND = ::GetAncestor(GetHWNDFromDocShell(shell), GA_ROOT);
33486: 
41482:   if (!toplevelHWND)
41482:     return NS_ERROR_INVALID_ARG;
41482: 
33486:   nsWindow *window = nsWindow::GetNSWindowPtr(toplevelHWND);
33486: 
33486:   if (!window)
33486:     return NS_ERROR_FAILURE;
33486: 
33486:   nsCOMPtr<nsITaskbarWindowPreview> preview = window->GetTaskbarPreview();
33486:   if (!preview) {
33486:     nsRefPtr<DefaultController> defaultController = new DefaultController(toplevelHWND);
33486:     preview = new TaskbarWindowPreview(mTaskbar, defaultController, toplevelHWND, shell);
33486:     if (!preview)
33486:       return NS_ERROR_OUT_OF_MEMORY;
33486:     window->SetTaskbarPreview(preview);
33486:   }
33486: 
33486:   preview.forget(_retval);
33486: 
33486:   return NS_OK;
33486: }
33486: 
33510: NS_IMETHODIMP
33510: WinTaskbar::GetTaskbarProgress(nsIDocShell *shell, nsITaskbarProgress **_retval) {
33510:   nsCOMPtr<nsITaskbarWindowPreview> preview;
33510:   nsresult rv = GetTaskbarWindowPreview(shell, getter_AddRefs(preview));
33510:   NS_ENSURE_SUCCESS(rv, rv);
33510: 
33510:   return CallQueryInterface(preview, _retval);
33510: }
33510: 
33519: /* nsIJumpListBuilder createJumpListBuilder(); */
42348: NS_IMETHODIMP
42348: WinTaskbar::CreateJumpListBuilder(nsIJumpListBuilder * *aJumpListBuilder) {
33519:   nsresult rv;
33519: 
33519:   if (JumpListBuilder::sBuildingList)
33519:     return NS_ERROR_ALREADY_INITIALIZED;
33519: 
33519:   nsCOMPtr<nsIJumpListBuilder> builder = 
33519:     do_CreateInstance(kJumpListBuilderCID, &rv);
33519:   if (NS_FAILED(rv))
33519:     return NS_ERROR_UNEXPECTED;
33519: 
33519:   NS_IF_ADDREF(*aJumpListBuilder = builder);
33519: 
33519:   return NS_OK;
33519: }
33519: 
42348: /* void setGroupIdForWindow (in nsIDOMWindow aParent, in AString aIdentifier); */
42348: NS_IMETHODIMP
42348: WinTaskbar::SetGroupIdForWindow(nsIDOMWindow *aParent,
42348:                                 const nsAString & aIdentifier) {
42348:   return SetWindowAppUserModelProp(aParent, nsString(aIdentifier));
42348: }
42348: 
33486: } // namespace widget
33486: } // namespace mozilla
33486: 
33486: #endif // MOZ_WINSDK_TARGETVER >= MOZ_NTDDI_WIN7
