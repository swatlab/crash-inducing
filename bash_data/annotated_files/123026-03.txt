     1: //* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: /**
     1:  * This file contains the definitions of nsNavHistoryQuery,
     1:  * nsNavHistoryQueryOptions, and those functions in nsINavHistory that directly
     1:  * support queries (specifically QueryStringToQueries and QueriesToQueryString).
     1:  */
     1: 
     1: #include "nsNavHistory.h"
 13123: #include "nsNavBookmarks.h"
     1: #include "nsEscape.h"
     1: #include "nsCOMArray.h"
     1: #include "nsNetUtil.h"
     1: #include "nsTArray.h"
     1: #include "prprf.h"
 69685: #include "mozilla/Util.h"
 69685: 
 69685: using namespace mozilla;
     1: 
     1: class QueryKeyValuePair
     1: {
     1: public:
     1: 
     1:   // QueryKeyValuePair
     1:   //
     1:   //                  01234567890
     1:   //    input : qwerty&key=value&qwerty
     1:   //                  ^   ^     ^
     1:   //          aKeyBegin   |     aPastEnd (may point to NULL terminator)
     1:   //                      aEquals
     1:   //
     1:   //    Special case: if aKeyBegin == aEquals, then there is only one string
     1:   //    and no equal sign, so we treat the entire thing as a key with no value
     1: 
108991:   QueryKeyValuePair(const nsCSubstring& aSource, int32_t aKeyBegin,
108991:                     int32_t aEquals, int32_t aPastEnd)
     1:   {
     1:     if (aEquals == aKeyBegin)
     1:       aEquals = aPastEnd;
     1:     key = Substring(aSource, aKeyBegin, aEquals - aKeyBegin);
     1:     if (aPastEnd - aEquals > 0)
     1:       value = Substring(aSource, aEquals + 1, aPastEnd - aEquals - 1);
     1:   }
     1:   nsCString key;
     1:   nsCString value;
     1: };
     1: 
     1: static nsresult TokenizeQueryString(const nsACString& aQuery,
     1:                                     nsTArray<QueryKeyValuePair>* aTokens);
     1: static nsresult ParseQueryBooleanString(const nsCString& aString,
 79445:                                         bool* aValue);
     1: 
     1: // query getters
     1: typedef NS_STDCALL_FUNCPROTO(nsresult, BoolQueryGetter, nsINavHistoryQuery,
 79445:                              GetOnlyBookmarked, (bool*));
     1: typedef NS_STDCALL_FUNCPROTO(nsresult, Uint32QueryGetter, nsINavHistoryQuery,
108991:                              GetBeginTimeReference, (uint32_t*));
     1: typedef NS_STDCALL_FUNCPROTO(nsresult, Int64QueryGetter, nsINavHistoryQuery,
108991:                              GetBeginTime, (int64_t*));
     1: static void AppendBoolKeyValueIfTrue(nsACString& aString,
     1:                                      const nsCString& aName,
     1:                                      nsINavHistoryQuery* aQuery,
     1:                                      BoolQueryGetter getter);
     1: static void AppendUint32KeyValueIfNonzero(nsACString& aString,
     1:                                           const nsCString& aName,
     1:                                           nsINavHistoryQuery* aQuery,
     1:                                           Uint32QueryGetter getter);
     1: static void AppendInt64KeyValueIfNonzero(nsACString& aString,
     1:                                          const nsCString& aName,
     1:                                          nsINavHistoryQuery* aQuery,
     1:                                          Int64QueryGetter getter);
     1: 
     1: // query setters
     1: typedef NS_STDCALL_FUNCPROTO(nsresult, BoolQuerySetter, nsINavHistoryQuery,
 79445:                              SetOnlyBookmarked, (bool));
     1: typedef NS_STDCALL_FUNCPROTO(nsresult, Uint32QuerySetter, nsINavHistoryQuery,
108991:                              SetBeginTimeReference, (uint32_t));
     1: typedef NS_STDCALL_FUNCPROTO(nsresult, Int64QuerySetter, nsINavHistoryQuery,
108991:                              SetBeginTime, (int64_t));
     1: static void SetQueryKeyBool(const nsCString& aValue, nsINavHistoryQuery* aQuery,
     1:                             BoolQuerySetter setter);
     1: static void SetQueryKeyUint32(const nsCString& aValue, nsINavHistoryQuery* aQuery,
     1:                               Uint32QuerySetter setter);
     1: static void SetQueryKeyInt64(const nsCString& aValue, nsINavHistoryQuery* aQuery,
     1:                              Int64QuerySetter setter);
     1: 
     1: // options setters
     1: typedef NS_STDCALL_FUNCPROTO(nsresult, BoolOptionsSetter,
     1:                              nsINavHistoryQueryOptions,
 79445:                              SetExpandQueries, (bool));
     1: typedef NS_STDCALL_FUNCPROTO(nsresult, Uint32OptionsSetter,
     1:                              nsINavHistoryQueryOptions,
108991:                              SetMaxResults, (uint32_t));
   809: typedef NS_STDCALL_FUNCPROTO(nsresult, Uint16OptionsSetter,
   809:                              nsINavHistoryQueryOptions,
108991:                              SetResultType, (uint16_t));
     1: static void SetOptionsKeyBool(const nsCString& aValue,
     1:                               nsINavHistoryQueryOptions* aOptions,
     1:                               BoolOptionsSetter setter);
   809: static void SetOptionsKeyUint16(const nsCString& aValue,
   809:                                 nsINavHistoryQueryOptions* aOptions,
   809:                                 Uint16OptionsSetter setter);
     1: static void SetOptionsKeyUint32(const nsCString& aValue,
     1:                                 nsINavHistoryQueryOptions* aOptions,
     1:                                 Uint32OptionsSetter setter);
     1: 
     1: // Components of a query string.
     1: // Note that query strings are also generated in nsNavBookmarks::GetFolderURI
     1: // for performance reasons, so if you change these values, change that, too.
     1: #define QUERYKEY_BEGIN_TIME "beginTime"
     1: #define QUERYKEY_BEGIN_TIME_REFERENCE "beginTimeRef"
     1: #define QUERYKEY_END_TIME "endTime"
     1: #define QUERYKEY_END_TIME_REFERENCE "endTimeRef"
     1: #define QUERYKEY_SEARCH_TERMS "terms"
     1: #define QUERYKEY_MIN_VISITS "minVisits"
     1: #define QUERYKEY_MAX_VISITS "maxVisits"
     1: #define QUERYKEY_ONLY_BOOKMARKED "onlyBookmarked"
     1: #define QUERYKEY_DOMAIN_IS_HOST "domainIsHost"
     1: #define QUERYKEY_DOMAIN "domain"
     1: #define QUERYKEY_FOLDER "folder"
     1: #define QUERYKEY_NOTANNOTATION "!annotation"
     1: #define QUERYKEY_ANNOTATION "annotation"
     1: #define QUERYKEY_URI "uri"
     1: #define QUERYKEY_URIISPREFIX "uriIsPrefix"
     1: #define QUERYKEY_SEPARATOR "OR"
     1: #define QUERYKEY_GROUP "group"
     1: #define QUERYKEY_SORT "sort"
   864: #define QUERYKEY_SORTING_ANNOTATION "sortingAnnotation"
     1: #define QUERYKEY_RESULT_TYPE "type"
     1: #define QUERYKEY_EXCLUDE_ITEMS "excludeItems"
     1: #define QUERYKEY_EXCLUDE_QUERIES "excludeQueries"
     1: #define QUERYKEY_EXCLUDE_READ_ONLY_FOLDERS "excludeReadOnlyFolders"
     1: #define QUERYKEY_EXPAND_QUERIES "expandQueries"
     1: #define QUERYKEY_FORCE_ORIGINAL_TITLE "originalTitle"
     1: #define QUERYKEY_INCLUDE_HIDDEN "includeHidden"
     1: #define QUERYKEY_MAX_RESULTS "maxResults"
   809: #define QUERYKEY_QUERY_TYPE "queryType"
 27981: #define QUERYKEY_TAG "tag"
 27981: #define QUERYKEY_NOTTAGS "!tags"
 40626: #define QUERYKEY_ASYNC_ENABLED "asyncEnabled"
 44194: #define QUERYKEY_TRANSITION "transition"
     1: 
     1: inline void AppendAmpersandIfNonempty(nsACString& aString)
     1: {
     1:   if (! aString.IsEmpty())
     1:     aString.Append('&');
     1: }
108991: inline void AppendInt16(nsACString& str, int16_t i)
   809: {
110974:   nsAutoCString tmp;
   809:   tmp.AppendInt(i);
   809:   str.Append(tmp);
   809: }
108991: inline void AppendInt32(nsACString& str, int32_t i)
     1: {
110974:   nsAutoCString tmp;
     1:   tmp.AppendInt(i);
     1:   str.Append(tmp);
     1: }
108991: inline void AppendInt64(nsACString& str, int64_t i)
     1: {
     1:   nsCString tmp;
     1:   tmp.AppendInt(i);
     1:   str.Append(tmp);
     1: }
     1: 
 13123: namespace PlacesFolderConversion {
 13123:   #define PLACES_ROOT_FOLDER "PLACES_ROOT"
 13123:   #define BOOKMARKS_MENU_FOLDER "BOOKMARKS_MENU"
 13123:   #define TAGS_FOLDER "TAGS"
 13123:   #define UNFILED_BOOKMARKS_FOLDER "UNFILED_BOOKMARKS"
 13123:   #define TOOLBAR_FOLDER "TOOLBAR"
 13123:   
 13123:   /**
 13123:    * Converts a folder name to a folder id.
 13123:    *
 13123:    * @param aName
 13123:    *        The name of the folder to convert to a folder id.
 13123:    * @returns the folder id if aName is a recognizable name, -1 otherwise.
 13123:    */
108991:   inline int64_t DecodeFolder(const nsCString &aName)
 13123:   {
 13123:     nsNavBookmarks *bs = nsNavBookmarks::GetBookmarksService();
 80486:     NS_ENSURE_TRUE(bs, false);
108991:     int64_t folderID = -1;
 13123: 
 13123:     if (aName.EqualsLiteral(PLACES_ROOT_FOLDER))
 13123:       (void)bs->GetPlacesRoot(&folderID);
 13123:     else if (aName.EqualsLiteral(BOOKMARKS_MENU_FOLDER))
 13123:       (void)bs->GetBookmarksMenuFolder(&folderID);
 13123:     else if (aName.EqualsLiteral(TAGS_FOLDER))
 13123:       (void)bs->GetTagsFolder(&folderID);
 13123:     else if (aName.EqualsLiteral(UNFILED_BOOKMARKS_FOLDER))
 13123:       (void)bs->GetUnfiledBookmarksFolder(&folderID);
 13123:     else if (aName.EqualsLiteral(TOOLBAR_FOLDER))
 13123:       (void)bs->GetToolbarFolder(&folderID);
 13123: 
 13123:     return folderID;
 13123:   }
 13123: 
 13123:   /**
 13123:    * Converts a folder id to a named constant, or a string representation of the
 13123:    * folder id if there is no named constant for the folder, and appends it to
 13123:    * aQuery.
 13123:    *
 13123:    * @param aQuery
 13123:    *        The string to append the folder string to.  This is generally a
 13123:    *        query string, but could really be anything.
 13123:    * @param aFolderID
 13123:    *        The folder ID to convert to the proper named constant.
 13123:    */
123026:   inline nsresult AppendFolder(nsCString &aQuery, int64_t aFolderID)
 13123:   {
 13123:     nsNavBookmarks *bs = nsNavBookmarks::GetBookmarksService();
123026:     NS_ENSURE_STATE(bs);
108991:     int64_t folderID;
 13123: 
123026:     if (NS_SUCCEEDED(bs->GetPlacesRoot(&folderID)) &&
123026:         aFolderID == folderID) {
 13123:       aQuery.AppendLiteral(PLACES_ROOT_FOLDER);
123026:     }
123026:     else if (NS_SUCCEEDED(bs->GetBookmarksMenuFolder(&folderID)) &&
123026:              aFolderID == folderID) {
123026:       aQuery.AppendLiteral(BOOKMARKS_MENU_FOLDER);
123026:     }
123026:     else if (NS_SUCCEEDED(bs->GetTagsFolder(&folderID)) &&
123026:              aFolderID == folderID) {
123026:       aQuery.AppendLiteral(TAGS_FOLDER);
123026:     }
123026:     else if (NS_SUCCEEDED(bs->GetUnfiledBookmarksFolder(&folderID)) &&
123026:              aFolderID == folderID) {
123026:       aQuery.AppendLiteral(UNFILED_BOOKMARKS_FOLDER);
123026:     }
123026:     else if (NS_SUCCEEDED(bs->GetToolbarFolder(&folderID)) &&
123026:              aFolderID == folderID) {
123026:       aQuery.AppendLiteral(TOOLBAR_FOLDER);
123026:     }
123026:     else {
123026:       // It wasn't one of our named constants, so just convert it to a string.
123026:       aQuery.AppendInt(aFolderID);
 13123:     }
 13123: 
123026:     return NS_OK;
 13123:   }
 13123: }
     1: 
     1: // nsNavHistory::QueryStringToQueries
     1: //
     1: //    From C++ places code, you should use QueryStringToQueryArray, this is
     1: //    the harder-to-use XPCOM version.
     1: 
     1: NS_IMETHODIMP
     1: nsNavHistory::QueryStringToQueries(const nsACString& aQueryString,
     1:                                    nsINavHistoryQuery*** aQueries,
108991:                                    uint32_t* aResultCount,
     1:                                    nsINavHistoryQueryOptions** aOptions)
     1: {
 28236:   NS_ENSURE_ARG_POINTER(aQueries);
 28236:   NS_ENSURE_ARG_POINTER(aResultCount);
 28236:   NS_ENSURE_ARG_POINTER(aOptions);
 28236: 
106838:   *aQueries = nullptr;
     1:   *aResultCount = 0;
     1:   nsCOMPtr<nsNavHistoryQueryOptions> options;
     1:   nsCOMArray<nsNavHistoryQuery> queries;
     1:   nsresult rv = QueryStringToQueryArray(aQueryString, &queries,
     1:                                         getter_AddRefs(options));
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   *aResultCount = queries.Count();
     1:   if (queries.Count() > 0) {
     1:     // convert COM array to raw
  3233:     *aQueries = static_cast<nsINavHistoryQuery**>
  3233:                            (nsMemory::Alloc(sizeof(nsINavHistoryQuery*) * queries.Count()));
     1:     NS_ENSURE_TRUE(*aQueries, NS_ERROR_OUT_OF_MEMORY);
108991:     for (int32_t i = 0; i < queries.Count(); i ++) {
     1:       (*aQueries)[i] = queries[i];
     1:       NS_ADDREF((*aQueries)[i]);
     1:     }
     1:   }
     1:   NS_ADDREF(*aOptions = options);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // nsNavHistory::QueryStringToQueryArray
     1: //
     1: //    An internal version of QueryStringToQueries that fills a COM array for
     1: //    ease-of-use.
     1: 
     1: nsresult
     1: nsNavHistory::QueryStringToQueryArray(const nsACString& aQueryString,
     1:                                       nsCOMArray<nsNavHistoryQuery>* aQueries,
     1:                                       nsNavHistoryQueryOptions** aOptions)
     1: {
     1:   nsresult rv;
     1:   aQueries->Clear();
106838:   *aOptions = nullptr;
     1: 
     1:   nsRefPtr<nsNavHistoryQueryOptions> options(new nsNavHistoryQueryOptions());
     1:   if (! options)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   nsTArray<QueryKeyValuePair> tokens;
     1:   rv = TokenizeQueryString(aQueryString, &tokens);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:   rv = TokensToQueries(tokens, aQueries, options);
     1:   if (NS_FAILED(rv)) {
     1:     NS_WARNING("Unable to parse the query string: ");
     1:     NS_WARNING(PromiseFlatCString(aQueryString).get());
 24000:     return rv;
     1:   }
     1: 
     1:   NS_ADDREF(*aOptions = options);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // nsNavHistory::QueriesToQueryString
     1: 
     1: NS_IMETHODIMP
     1: nsNavHistory::QueriesToQueryString(nsINavHistoryQuery **aQueries,
108991:                                    uint32_t aQueryCount,
     1:                                    nsINavHistoryQueryOptions* aOptions,
     1:                                    nsACString& aQueryString)
     1: {
 28236:   NS_ENSURE_ARG(aQueries);
 28236:   NS_ENSURE_ARG(aOptions);
 28236: 
     1:   nsCOMPtr<nsNavHistoryQueryOptions> options = do_QueryInterface(aOptions);
     1:   NS_ENSURE_TRUE(options, NS_ERROR_INVALID_ARG);
     1: 
110974:   nsAutoCString queryString;
108991:   for (uint32_t queryIndex = 0; queryIndex < aQueryCount;  queryIndex ++) {
 27981:     nsCOMPtr<nsNavHistoryQuery> query = do_QueryInterface(aQueries[queryIndex]);
     1:     if (queryIndex > 0) {
   427:       AppendAmpersandIfNonempty(queryString);
   427:       queryString += NS_LITERAL_CSTRING(QUERYKEY_SEPARATOR);
     1:     }
     1: 
 79445:     bool hasIt;
     1: 
     1:     // begin time
     1:     query->GetHasBeginTime(&hasIt);
     1:     if (hasIt) {
   427:       AppendInt64KeyValueIfNonzero(queryString,
     1:                                    NS_LITERAL_CSTRING(QUERYKEY_BEGIN_TIME),
     1:                                    query, &nsINavHistoryQuery::GetBeginTime);
   427:       AppendUint32KeyValueIfNonzero(queryString,
     1:                                     NS_LITERAL_CSTRING(QUERYKEY_BEGIN_TIME_REFERENCE),
     1:                                     query, &nsINavHistoryQuery::GetBeginTimeReference);
     1:     }
     1: 
     1:     // end time
     1:     query->GetHasEndTime(&hasIt);
     1:     if (hasIt) {
   427:       AppendInt64KeyValueIfNonzero(queryString,
     1:                                    NS_LITERAL_CSTRING(QUERYKEY_END_TIME),
     1:                                    query, &nsINavHistoryQuery::GetEndTime);
   427:       AppendUint32KeyValueIfNonzero(queryString,
     1:                                     NS_LITERAL_CSTRING(QUERYKEY_END_TIME_REFERENCE),
     1:                                     query, &nsINavHistoryQuery::GetEndTimeReference);
     1:     }
     1: 
     1:     // search terms
     1:     query->GetHasSearchTerms(&hasIt);
     1:     if (hasIt) {
     1:       nsAutoString searchTerms;
     1:       query->GetSearchTerms(searchTerms);
     1:       nsCString escapedTerms;
     1:       if (! NS_Escape(NS_ConvertUTF16toUTF8(searchTerms), escapedTerms,
     1:                       url_XAlphas))
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
   427:       AppendAmpersandIfNonempty(queryString);
   427:       queryString += NS_LITERAL_CSTRING(QUERYKEY_SEARCH_TERMS "=");
   427:       queryString += escapedTerms;
     1:     }
     1: 
     1:     // min and max visits
108991:     int32_t minVisits;
     1:     if (NS_SUCCEEDED(query->GetMinVisits(&minVisits)) && minVisits >= 0) {
   427:       AppendAmpersandIfNonempty(queryString);
   427:       queryString.Append(NS_LITERAL_CSTRING(QUERYKEY_MIN_VISITS "="));
   427:       AppendInt32(queryString, minVisits);
     1:     }
     1: 
108991:     int32_t maxVisits;
     1:     if (NS_SUCCEEDED(query->GetMaxVisits(&maxVisits)) && maxVisits >= 0) {
   427:       AppendAmpersandIfNonempty(queryString);
   427:       queryString.Append(NS_LITERAL_CSTRING(QUERYKEY_MAX_VISITS "="));
   427:       AppendInt32(queryString, maxVisits);
     1:     }
     1: 
     1:     // only bookmarked
   427:     AppendBoolKeyValueIfTrue(queryString,
     1:                              NS_LITERAL_CSTRING(QUERYKEY_ONLY_BOOKMARKED),
     1:                              query, &nsINavHistoryQuery::GetOnlyBookmarked);
     1: 
     1:     // domain (+ is host), only call if hasDomain, which means non-IsVoid
     1:     // this means we may get an empty string for the domain in the result,
     1:     // which is valid
     1:     query->GetHasDomain(&hasIt);
     1:     if (hasIt) {
   427:       AppendBoolKeyValueIfTrue(queryString,
     1:                                NS_LITERAL_CSTRING(QUERYKEY_DOMAIN_IS_HOST),
     1:                                query, &nsINavHistoryQuery::GetDomainIsHost);
110974:       nsAutoCString domain;
     1:       nsresult rv = query->GetDomain(domain);
 69685:       NS_ENSURE_SUCCESS(rv, rv);
     1:       nsCString escapedDomain;
 79445:       bool success = NS_Escape(domain, escapedDomain, url_XAlphas);
     1:       NS_ENSURE_TRUE(success, NS_ERROR_OUT_OF_MEMORY);
     1: 
   427:       AppendAmpersandIfNonempty(queryString);
   427:       queryString.Append(NS_LITERAL_CSTRING(QUERYKEY_DOMAIN "="));
   427:       queryString.Append(escapedDomain);
     1:     }
     1: 
     1:     // uri
     1:     query->GetHasUri(&hasIt);
     1:     if (hasIt) {
     1:       AppendBoolKeyValueIfTrue(aQueryString,
     1:                                NS_LITERAL_CSTRING(QUERYKEY_URIISPREFIX),
     1:                                query, &nsINavHistoryQuery::GetUriIsPrefix);
     1:       nsCOMPtr<nsIURI> uri;
     1:       query->GetUri(getter_AddRefs(uri));
     1:       NS_ENSURE_TRUE(uri, NS_ERROR_FAILURE); // hasURI should tell is if invalid
110974:       nsAutoCString uriSpec;
     1:       nsresult rv = uri->GetSpec(uriSpec);
     1:       NS_ENSURE_SUCCESS(rv, rv);
110974:       nsAutoCString escaped;
 79445:       bool success = NS_Escape(uriSpec, escaped, url_XAlphas);
     1:       NS_ENSURE_TRUE(success, NS_ERROR_OUT_OF_MEMORY);
     1: 
   427:       AppendAmpersandIfNonempty(queryString);
   427:       queryString.Append(NS_LITERAL_CSTRING(QUERYKEY_URI "="));
   427:       queryString.Append(escaped);
     1:     }
     1: 
     1:     // annotation
     1:     query->GetHasAnnotation(&hasIt);
     1:     if (hasIt) {
   427:       AppendAmpersandIfNonempty(queryString);
 79445:       bool annotationIsNot;
     1:       query->GetAnnotationIsNot(&annotationIsNot);
     1:       if (annotationIsNot)
   427:         queryString.AppendLiteral(QUERYKEY_NOTANNOTATION "=");
     1:       else
   427:         queryString.AppendLiteral(QUERYKEY_ANNOTATION "=");
110974:       nsAutoCString annot;
     1:       query->GetAnnotation(annot);
110974:       nsAutoCString escaped;
 79445:       bool success = NS_Escape(annot, escaped, url_XAlphas);
     1:       NS_ENSURE_TRUE(success, NS_ERROR_OUT_OF_MEMORY);
   427:       queryString.Append(escaped);
     1:     }
     1: 
     1:     // folders
108991:     int64_t *folders = nullptr;
108991:     uint32_t folderCount = 0;
     1:     query->GetFolders(&folderCount, &folders);
108991:     for (uint32_t i = 0; i < folderCount; ++i) {
   427:       AppendAmpersandIfNonempty(queryString);
   427:       queryString += NS_LITERAL_CSTRING(QUERYKEY_FOLDER "=");
123026:       nsresult rv = PlacesFolderConversion::AppendFolder(queryString, folders[i]);
123026:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
   424:     nsMemory::Free(folders);
 27981: 
 27981:     // tags
 27981:     const nsTArray<nsString> &tags = query->Tags();
108991:     for (uint32_t i = 0; i < tags.Length(); ++i) {
110974:       nsAutoCString escapedTag;
 27981:       if (!NS_Escape(NS_ConvertUTF16toUTF8(tags[i]), escapedTag, url_XAlphas))
 27981:         return NS_ERROR_OUT_OF_MEMORY;
 27981: 
 27981:       AppendAmpersandIfNonempty(queryString);
 27981:       queryString += NS_LITERAL_CSTRING(QUERYKEY_TAG "=");
 27981:       queryString += escapedTag;
 27981:     }
 27981:     AppendBoolKeyValueIfTrue(queryString,
 27981:                              NS_LITERAL_CSTRING(QUERYKEY_NOTTAGS),
 27981:                              query,
 27981:                              &nsINavHistoryQuery::GetTagsAreNot);
 44194:  
 44194:     // transitions
108991:     const nsTArray<uint32_t>& transitions = query->Transitions();
108991:     for (uint32_t i = 0; i < transitions.Length(); ++i) {
 44194:       AppendAmpersandIfNonempty(queryString);
 44194:       queryString += NS_LITERAL_CSTRING(QUERYKEY_TRANSITION "=");
 44194:       AppendInt64(queryString, transitions[i]);
 44194:     }
     1:   }
     1: 
     1:   // sorting
     1:   if (options->SortingMode() != nsINavHistoryQueryOptions::SORT_BY_NONE) {
   427:     AppendAmpersandIfNonempty(queryString);
   427:     queryString += NS_LITERAL_CSTRING(QUERYKEY_SORT "=");
   809:     AppendInt16(queryString, options->SortingMode());
   864:     if (options->SortingMode() == nsINavHistoryQueryOptions::SORT_BY_ANNOTATION_DESCENDING ||
   864:         options->SortingMode() == nsINavHistoryQueryOptions::SORT_BY_ANNOTATION_ASCENDING) {
   864:       // sortingAnnotation
110974:       nsAutoCString sortingAnnotation;
   864:       if (NS_SUCCEEDED(options->GetSortingAnnotation(sortingAnnotation))) {
   864:         nsCString escaped;
   864:         if (!NS_Escape(sortingAnnotation, escaped, url_XAlphas))
   864:           return NS_ERROR_OUT_OF_MEMORY;
   864:         AppendAmpersandIfNonempty(queryString);
   864:         queryString += NS_LITERAL_CSTRING(QUERYKEY_SORTING_ANNOTATION "=");
   864:         queryString.Append(escaped);
   864:       }
   864:     } 
     1:   }
     1: 
     1:   // result type
     1:   if (options->ResultType() != nsINavHistoryQueryOptions::RESULTS_AS_URI) {
   427:     AppendAmpersandIfNonempty(queryString);
   427:     queryString += NS_LITERAL_CSTRING(QUERYKEY_RESULT_TYPE "=");
   809:     AppendInt16(queryString, options->ResultType());
     1:   }
     1: 
     1:   // exclude items
     1:   if (options->ExcludeItems()) {
   427:     AppendAmpersandIfNonempty(queryString);
   427:     queryString += NS_LITERAL_CSTRING(QUERYKEY_EXCLUDE_ITEMS "=1");
     1:   }
     1: 
     1:   // exclude queries
     1:   if (options->ExcludeQueries()) {
   427:     AppendAmpersandIfNonempty(queryString);
   427:     queryString += NS_LITERAL_CSTRING(QUERYKEY_EXCLUDE_QUERIES "=1");
     1:   }
     1: 
     1:   // exclude read only folders
     1:   if (options->ExcludeReadOnlyFolders()) {
   427:     AppendAmpersandIfNonempty(queryString);
   427:     queryString += NS_LITERAL_CSTRING(QUERYKEY_EXCLUDE_READ_ONLY_FOLDERS "=1");
     1:   }
     1: 
     1:   // expand queries
  5542:   if (!options->ExpandQueries()) {
   427:     AppendAmpersandIfNonempty(queryString);
  5542:     queryString += NS_LITERAL_CSTRING(QUERYKEY_EXPAND_QUERIES "=0");
     1:   }
     1: 
     1:   // include hidden
     1:   if (options->IncludeHidden()) {
   427:     AppendAmpersandIfNonempty(queryString);
   427:     queryString += NS_LITERAL_CSTRING(QUERYKEY_INCLUDE_HIDDEN "=1");
     1:   }
     1: 
     1:   // max results
     1:   if (options->MaxResults()) {
   427:     AppendAmpersandIfNonempty(queryString);
   427:     queryString += NS_LITERAL_CSTRING(QUERYKEY_MAX_RESULTS "=");
   427:     AppendInt32(queryString, options->MaxResults());
     1:   }
     1: 
   809:   // queryType
   809:   if (options->QueryType() !=  nsINavHistoryQueryOptions::QUERY_TYPE_HISTORY) {
   809:     AppendAmpersandIfNonempty(queryString);
   809:     queryString += NS_LITERAL_CSTRING(QUERYKEY_QUERY_TYPE "=");
   809:     AppendInt16(queryString, options->QueryType());
   809:   }
   809: 
 40626:   // async enabled
 40626:   if (options->AsyncEnabled()) {
 40626:     AppendAmpersandIfNonempty(queryString);
 40626:     queryString += NS_LITERAL_CSTRING(QUERYKEY_ASYNC_ENABLED "=1");
 40626:   }
 40626: 
   427:   aQueryString.Assign(NS_LITERAL_CSTRING("place:") + queryString);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // TokenizeQueryString
     1: 
     1: nsresult
     1: TokenizeQueryString(const nsACString& aQuery,
     1:                     nsTArray<QueryKeyValuePair>* aTokens)
     1: {
     1:   // Strip off the "place:" prefix
108991:   const uint32_t prefixlen = 6; // = strlen("place:");
     1:   nsCString query;
 24000:   if (aQuery.Length() >= prefixlen &&
     1:       Substring(aQuery, 0, prefixlen).EqualsLiteral("place:"))
     1:     query = Substring(aQuery, prefixlen);
     1:   else
     1:     query = aQuery;
     1: 
108991:   int32_t keyFirstIndex = 0;
108991:   int32_t equalsIndex = 0;
108991:   for (uint32_t i = 0; i < query.Length(); i ++) {
     1:     if (query[i] == '&') {
     1:       // new clause, save last one
     1:       if (i - keyFirstIndex > 1) {
     1:         if (! aTokens->AppendElement(QueryKeyValuePair(query, keyFirstIndex,
     1:                                                        equalsIndex, i)))
     1:           return NS_ERROR_OUT_OF_MEMORY;
     1:       }
     1:       keyFirstIndex = equalsIndex = i + 1;
     1:     } else if (query[i] == '=') {
     1:       equalsIndex = i;
     1:     }
     1:   }
     1: 
     1:   // handle last pair, if any
     1:   if (query.Length() - keyFirstIndex > 1) {
     1:     if (! aTokens->AppendElement(QueryKeyValuePair(query, keyFirstIndex,
     1:                                                    equalsIndex, query.Length())))
     1:       return NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1:   return NS_OK;
     1: }
     1: 
     1: // nsNavHistory::TokensToQueries
     1: 
     1: nsresult
     1: nsNavHistory::TokensToQueries(const nsTArray<QueryKeyValuePair>& aTokens,
     1:                               nsCOMArray<nsNavHistoryQuery>* aQueries,
     1:                               nsNavHistoryQueryOptions* aOptions)
     1: {
     1:   nsresult rv;
     1: 
     1:   nsCOMPtr<nsNavHistoryQuery> query(new nsNavHistoryQuery());
     1:   if (! query)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   if (! aQueries->AppendObject(query))
     1:     return NS_ERROR_OUT_OF_MEMORY;
 24000: 
 24000:   if (aTokens.Length() == 0)
 24000:     return NS_OK; // nothing to do
 24000: 
108991:   nsTArray<int64_t> folders;
 27981:   nsTArray<nsString> tags;
108991:   nsTArray<uint32_t> transitions;
108991:   for (uint32_t i = 0; i < aTokens.Length(); i ++) {
     1:     const QueryKeyValuePair& kvp = aTokens[i];
     1: 
     1:     // begin time
     1:     if (kvp.key.EqualsLiteral(QUERYKEY_BEGIN_TIME)) {
     1:       SetQueryKeyInt64(kvp.value, query, &nsINavHistoryQuery::SetBeginTime);
     1: 
     1:     // begin time reference
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_BEGIN_TIME_REFERENCE)) {
     1:       SetQueryKeyUint32(kvp.value, query, &nsINavHistoryQuery::SetBeginTimeReference);
     1: 
     1:     // end time
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_END_TIME)) {
     1:       SetQueryKeyInt64(kvp.value, query, &nsINavHistoryQuery::SetEndTime);
     1: 
     1:     // end time reference
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_END_TIME_REFERENCE)) {
     1:       SetQueryKeyUint32(kvp.value, query, &nsINavHistoryQuery::SetEndTimeReference);
     1: 
     1:     // search terms
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_SEARCH_TERMS)) {
     1:       nsCString unescapedTerms = kvp.value;
     1:       NS_UnescapeURL(unescapedTerms); // modifies input
     1:       rv = query->SetSearchTerms(NS_ConvertUTF8toUTF16(unescapedTerms));
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // min visits
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_MIN_VISITS)) {
108991:       int32_t visits = kvp.value.ToInteger(&rv);
     1:       if (NS_SUCCEEDED(rv))
     1:         query->SetMinVisits(visits);
     1:       else
     1:         NS_WARNING("Bad number for minVisits in query");
     1: 
     1:     // max visits
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_MAX_VISITS)) {
108991:       int32_t visits = kvp.value.ToInteger(&rv);
     1:       if (NS_SUCCEEDED(rv))
     1:         query->SetMaxVisits(visits);
     1:       else
     1:         NS_WARNING("Bad number for maxVisits in query");
     1: 
     1:     // onlyBookmarked flag
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_ONLY_BOOKMARKED)) {
     1:       SetQueryKeyBool(kvp.value, query, &nsINavHistoryQuery::SetOnlyBookmarked);
     1: 
     1:     // domainIsHost flag
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_DOMAIN_IS_HOST)) {
     1:       SetQueryKeyBool(kvp.value, query, &nsINavHistoryQuery::SetDomainIsHost);
     1: 
     1:     // domain string
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_DOMAIN)) {
110974:       nsAutoCString unescapedDomain(kvp.value);
     1:       NS_UnescapeURL(unescapedDomain); // modifies input
     1:       rv = query->SetDomain(unescapedDomain);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1: 
  6822:     // folders
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_FOLDER)) {
108991:       int64_t folder;
     1:       if (PR_sscanf(kvp.value.get(), "%lld", &folder) == 1) {
     1:         NS_ENSURE_TRUE(folders.AppendElement(folder), NS_ERROR_OUT_OF_MEMORY);
     1:       } else {
 13123:         folder = PlacesFolderConversion::DecodeFolder(kvp.value);
 13123:         if (folder != -1)
 13123:           NS_ENSURE_TRUE(folders.AppendElement(folder), NS_ERROR_OUT_OF_MEMORY);
 13123:         else
     1:           NS_WARNING("folders value in query is invalid, ignoring");
     1:       }
     1: 
     1:     // uri
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_URI)) {
110974:       nsAutoCString unescapedUri(kvp.value);
     1:       NS_UnescapeURL(unescapedUri); // modifies input
     1:       nsCOMPtr<nsIURI> uri;
     1:       nsresult rv = NS_NewURI(getter_AddRefs(uri), unescapedUri);
     1:       if (NS_FAILED(rv)) {
     1:         NS_WARNING("Unable to parse URI");
     1:       }
     1:       rv = query->SetUri(uri);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:     // URI is prefix
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_URIISPREFIX)) {
     1:       SetQueryKeyBool(kvp.value, query, &nsINavHistoryQuery::SetUriIsPrefix);
     1: 
     1:     // not annotation
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_NOTANNOTATION)) {
110974:       nsAutoCString unescaped(kvp.value);
     1:       NS_UnescapeURL(unescaped); // modifies input
 80486:       query->SetAnnotationIsNot(true);
     1:       query->SetAnnotation(unescaped);
     1: 
     1:     // annotation
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_ANNOTATION)) {
110974:       nsAutoCString unescaped(kvp.value);
     1:       NS_UnescapeURL(unescaped); // modifies input
 80486:       query->SetAnnotationIsNot(false);
     1:       query->SetAnnotation(unescaped);
     1: 
 27981:     // tag
 27981:     } else if (kvp.key.EqualsLiteral(QUERYKEY_TAG)) {
110974:       nsAutoCString unescaped(kvp.value);
 27981:       NS_UnescapeURL(unescaped); // modifies input
 93853:       NS_ConvertUTF8toUTF16 tag(unescaped);
 27981:       if (!tags.Contains(tag)) {
 27981:         NS_ENSURE_TRUE(tags.AppendElement(tag), NS_ERROR_OUT_OF_MEMORY);
 27981:       }
 27981: 
 27981:     // not tags
 27981:     } else if (kvp.key.EqualsLiteral(QUERYKEY_NOTTAGS)) {
 27981:       SetQueryKeyBool(kvp.value, query, &nsINavHistoryQuery::SetTagsAreNot);
 27981: 
 44194:     // transition
 44194:     } else if (kvp.key.EqualsLiteral(QUERYKEY_TRANSITION)) {
108991:       uint32_t transition = kvp.value.ToInteger(&rv);
 44194:       if (NS_SUCCEEDED(rv)) {
 44194:         if (!transitions.Contains(transition))
 44194:           NS_ENSURE_TRUE(transitions.AppendElement(transition),
 44194:                          NS_ERROR_OUT_OF_MEMORY);
 44194:       }
 44194:       else {
 44194:         NS_WARNING("Invalid Int32 transition value.");
 44194:       }
 44194: 
     1:     // new query component
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_SEPARATOR)) {
     1: 
     1:       if (folders.Length() != 0) {
     1:         query->SetFolders(folders.Elements(), folders.Length());
     1:         folders.Clear();
     1:       }
     1: 
 27981:       if (tags.Length() > 0) {
 27981:         rv = query->SetTags(tags);
 27981:         NS_ENSURE_SUCCESS(rv, rv);
 27981:         tags.Clear();
 27981:       }
 27981: 
 44194:       if (transitions.Length() > 0) {
 44194:         rv = query->SetTransitions(transitions);
 44194:         NS_ENSURE_SUCCESS(rv, rv);
 44194:         transitions.Clear();
 44194:       }
 44194: 
     1:       query = new nsNavHistoryQuery();
     1:       if (! query)
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1:       if (! aQueries->AppendObject(query))
     1:         return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:     // sorting mode
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_SORT)) {
   809:       SetOptionsKeyUint16(kvp.value, aOptions,
     1:                           &nsINavHistoryQueryOptions::SetSortingMode);
   864:     // sorting annotation
   864:     } else if (kvp.key.EqualsLiteral(QUERYKEY_SORTING_ANNOTATION)) {
   864:       nsCString sortingAnnotation = kvp.value;
   864:       NS_UnescapeURL(sortingAnnotation);
   864:       rv = aOptions->SetSortingAnnotation(sortingAnnotation);
   864:       NS_ENSURE_SUCCESS(rv, rv);
     1:     // result type
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_RESULT_TYPE)) {
   809:       SetOptionsKeyUint16(kvp.value, aOptions,
     1:                           &nsINavHistoryQueryOptions::SetResultType);
     1: 
     1:     // exclude items
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_EXCLUDE_ITEMS)) {
     1:       SetOptionsKeyBool(kvp.value, aOptions,
     1:                         &nsINavHistoryQueryOptions::SetExcludeItems);
     1: 
     1:     // exclude queries
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_EXCLUDE_QUERIES)) {
     1:       SetOptionsKeyBool(kvp.value, aOptions,
     1:                         &nsINavHistoryQueryOptions::SetExcludeQueries);
     1: 
     1:     // exclude read only folders
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_EXCLUDE_READ_ONLY_FOLDERS)) {
     1:       SetOptionsKeyBool(kvp.value, aOptions,
     1:                         &nsINavHistoryQueryOptions::SetExcludeReadOnlyFolders);
     1: 
     1:     // expand queries
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_EXPAND_QUERIES)) {
     1:       SetOptionsKeyBool(kvp.value, aOptions,
     1:                         &nsINavHistoryQueryOptions::SetExpandQueries);
     1:     // include hidden
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_INCLUDE_HIDDEN)) {
     1:       SetOptionsKeyBool(kvp.value, aOptions,
     1:                         &nsINavHistoryQueryOptions::SetIncludeHidden);
     1:     // max results
     1:     } else if (kvp.key.EqualsLiteral(QUERYKEY_MAX_RESULTS)) {
     1:       SetOptionsKeyUint32(kvp.value, aOptions,
     1:                           &nsINavHistoryQueryOptions::SetMaxResults);
   809:     // query type
   809:     } else if (kvp.key.EqualsLiteral(QUERYKEY_QUERY_TYPE)) {
   809:       SetOptionsKeyUint16(kvp.value, aOptions,
   809:                           &nsINavHistoryQueryOptions::SetQueryType);
 40626:     // async enabled
 40626:     } else if (kvp.key.EqualsLiteral(QUERYKEY_ASYNC_ENABLED)) {
 40626:       SetOptionsKeyBool(kvp.value, aOptions,
 40626:                         &nsINavHistoryQueryOptions::SetAsyncEnabled);
     1:     // unknown key
     1:     } else {
  6803:       NS_WARNING("TokensToQueries(), ignoring unknown key: ");
  6803:       NS_WARNING(kvp.key.get());
     1:     }
     1:   }
     1: 
     1:   if (folders.Length() != 0)
     1:     query->SetFolders(folders.Elements(), folders.Length());
     1: 
 27981:   if (tags.Length() > 0) {
 27981:     rv = query->SetTags(tags);
 27981:     NS_ENSURE_SUCCESS(rv, rv);
 27981:   }
 27981: 
 44194:   if (transitions.Length() > 0) {
 44194:     rv = query->SetTransitions(transitions);
 44194:     NS_ENSURE_SUCCESS(rv, rv);
 44194:   }
 44194: 
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // ParseQueryBooleanString
     1: //
     1: //    Converts a 0/1 or true/false string into a bool
     1: 
     1: nsresult
 79445: ParseQueryBooleanString(const nsCString& aString, bool* aValue)
     1: {
     1:   if (aString.EqualsLiteral("1") || aString.EqualsLiteral("true")) {
 80486:     *aValue = true;
     1:     return NS_OK;
     1:   } else if (aString.EqualsLiteral("0") || aString.EqualsLiteral("false")) {
 80486:     *aValue = false;
     1:     return NS_OK;
     1:   }
     1:   return NS_ERROR_INVALID_ARG;
     1: }
     1: 
     1: 
     1: // nsINavHistoryQuery **********************************************************
     1: 
     1: NS_IMPL_ISUPPORTS2(nsNavHistoryQuery, nsNavHistoryQuery, nsINavHistoryQuery)
     1: 
     1: // nsINavHistoryQuery::nsNavHistoryQuery
     1: //
     1: //    This must initialize the object such that the default values will cause
     1: //    all history to be returned if this query is used. Then the caller can
     1: //    just set the things it's interested in.
     1: 
     1: nsNavHistoryQuery::nsNavHistoryQuery()
     1:   : mMinVisits(-1), mMaxVisits(-1), mBeginTime(0),
     1:     mBeginTimeReference(TIME_RELATIVE_EPOCH),
     1:     mEndTime(0), mEndTimeReference(TIME_RELATIVE_EPOCH),
 80486:     mOnlyBookmarked(false),
 80486:     mDomainIsHost(false), mUriIsPrefix(false),
 80486:     mAnnotationIsNot(false),
 80486:     mTagsAreNot(false)
     1: {
     1:   // differentiate not set (IsVoid) from empty string (local files)
 80486:   mDomain.SetIsVoid(true);
     1: }
     1: 
     1: /* attribute PRTime beginTime; */
     1: NS_IMETHODIMP nsNavHistoryQuery::GetBeginTime(PRTime *aBeginTime)
     1: {
     1:   *aBeginTime = mBeginTime;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP nsNavHistoryQuery::SetBeginTime(PRTime aBeginTime)
     1: {
     1:   mBeginTime = aBeginTime;
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute long beginTimeReference; */
108991: NS_IMETHODIMP nsNavHistoryQuery::GetBeginTimeReference(uint32_t* _retval)
     1: {
     1:   *_retval = mBeginTimeReference;
     1:   return NS_OK;
     1: }
108991: NS_IMETHODIMP nsNavHistoryQuery::SetBeginTimeReference(uint32_t aReference)
     1: {
     1:   if (aReference > TIME_RELATIVE_NOW)
     1:     return NS_ERROR_INVALID_ARG;
     1:   mBeginTimeReference = aReference;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute boolean hasBeginTime; */
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetHasBeginTime(bool* _retval)
     1: {
     1:   *_retval = ! (mBeginTimeReference == TIME_RELATIVE_EPOCH && mBeginTime == 0);
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRTime absoluteBeginTime; */
     1: NS_IMETHODIMP nsNavHistoryQuery::GetAbsoluteBeginTime(PRTime* _retval)
     1: {
     1:   *_retval = nsNavHistory::NormalizeTime(mBeginTimeReference, mBeginTime);
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute PRTime endTime; */
     1: NS_IMETHODIMP nsNavHistoryQuery::GetEndTime(PRTime *aEndTime)
     1: {
     1:   *aEndTime = mEndTime;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP nsNavHistoryQuery::SetEndTime(PRTime aEndTime)
     1: {
     1:   mEndTime = aEndTime;
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute long endTimeReference; */
108991: NS_IMETHODIMP nsNavHistoryQuery::GetEndTimeReference(uint32_t* _retval)
     1: {
     1:   *_retval = mEndTimeReference;
     1:   return NS_OK;
     1: }
108991: NS_IMETHODIMP nsNavHistoryQuery::SetEndTimeReference(uint32_t aReference)
     1: {
     1:   if (aReference > TIME_RELATIVE_NOW)
     1:     return NS_ERROR_INVALID_ARG;
     1:   mEndTimeReference = aReference;
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute boolean hasEndTime; */
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetHasEndTime(bool* _retval)
     1: {
     1:   *_retval = ! (mEndTimeReference == TIME_RELATIVE_EPOCH && mEndTime == 0);
     1:   return NS_OK;
     1: }
     1: 
     1: /* readonly attribute PRTime absoluteEndTime; */
     1: NS_IMETHODIMP nsNavHistoryQuery::GetAbsoluteEndTime(PRTime* _retval)
     1: {
     1:   *_retval = nsNavHistory::NormalizeTime(mEndTimeReference, mEndTime);
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute string searchTerms; */
     1: NS_IMETHODIMP nsNavHistoryQuery::GetSearchTerms(nsAString& aSearchTerms)
     1: {
     1:   aSearchTerms = mSearchTerms;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP nsNavHistoryQuery::SetSearchTerms(const nsAString& aSearchTerms)
     1: {
     1:   mSearchTerms = aSearchTerms;
     1:   return NS_OK;
     1: }
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetHasSearchTerms(bool* _retval)
     1: {
     1:   *_retval = (! mSearchTerms.IsEmpty());
     1:   return NS_OK;
     1: }
     1: 
108991: /* attribute int32_t minVisits; */
108991: NS_IMETHODIMP nsNavHistoryQuery::GetMinVisits(int32_t* _retval)
     1: {
     1:   NS_ENSURE_ARG_POINTER(_retval);
     1:   *_retval = mMinVisits;
     1:   return NS_OK;
     1: }
108991: NS_IMETHODIMP nsNavHistoryQuery::SetMinVisits(int32_t aVisits)
     1: {
     1:   mMinVisits = aVisits;
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute PRint32 maxVisits; */
108991: NS_IMETHODIMP nsNavHistoryQuery::GetMaxVisits(int32_t* _retval)
     1: {
     1:   NS_ENSURE_ARG_POINTER(_retval);
     1:   *_retval = mMaxVisits;
     1:   return NS_OK;
     1: }
108991: NS_IMETHODIMP nsNavHistoryQuery::SetMaxVisits(int32_t aVisits)
     1: {
     1:   mMaxVisits = aVisits;
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute boolean onlyBookmarked; */
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetOnlyBookmarked(bool *aOnlyBookmarked)
     1: {
     1:   *aOnlyBookmarked = mOnlyBookmarked;
     1:   return NS_OK;
     1: }
 79445: NS_IMETHODIMP nsNavHistoryQuery::SetOnlyBookmarked(bool aOnlyBookmarked)
     1: {
     1:   mOnlyBookmarked = aOnlyBookmarked;
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute boolean domainIsHost; */
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetDomainIsHost(bool *aDomainIsHost)
     1: {
     1:   *aDomainIsHost = mDomainIsHost;
     1:   return NS_OK;
     1: }
 79445: NS_IMETHODIMP nsNavHistoryQuery::SetDomainIsHost(bool aDomainIsHost)
     1: {
     1:   mDomainIsHost = aDomainIsHost;
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute AUTF8String domain; */
     1: NS_IMETHODIMP nsNavHistoryQuery::GetDomain(nsACString& aDomain)
     1: {
     1:   aDomain = mDomain;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP nsNavHistoryQuery::SetDomain(const nsACString& aDomain)
     1: {
     1:   mDomain = aDomain;
     1:   return NS_OK;
     1: }
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetHasDomain(bool* _retval)
     1: {
     1:   // note that empty but not void is still a valid query (local files)
     1:   *_retval = (! mDomain.IsVoid());
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute boolean uriIsPrefix; */
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetUriIsPrefix(bool* aIsPrefix)
     1: {
     1:   *aIsPrefix = mUriIsPrefix;
     1:   return NS_OK;
     1: }
 79445: NS_IMETHODIMP nsNavHistoryQuery::SetUriIsPrefix(bool aIsPrefix)
     1: {
     1:   mUriIsPrefix = aIsPrefix;
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute nsIURI uri; */
     1: NS_IMETHODIMP nsNavHistoryQuery::GetUri(nsIURI** aUri)
     1: {
 27433:   NS_IF_ADDREF(*aUri = mUri);
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP nsNavHistoryQuery::SetUri(nsIURI* aUri)
     1: {
     1:   mUri = aUri;
     1:   return NS_OK;
     1: }
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetHasUri(bool* aHasUri)
     1: {
106838:   *aHasUri = (mUri != nullptr);
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute boolean annotationIsNot; */
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetAnnotationIsNot(bool* aIsNot)
     1: {
     1:   *aIsNot = mAnnotationIsNot;
     1:   return NS_OK;
     1: }
 79445: NS_IMETHODIMP nsNavHistoryQuery::SetAnnotationIsNot(bool aIsNot)
     1: {
     1:   mAnnotationIsNot = aIsNot;
     1:   return NS_OK;
     1: }
     1: 
     1: /* attribute AUTF8String annotation; */
     1: NS_IMETHODIMP nsNavHistoryQuery::GetAnnotation(nsACString& aAnnotation)
     1: {
     1:   aAnnotation = mAnnotation;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP nsNavHistoryQuery::SetAnnotation(const nsACString& aAnnotation)
     1: {
     1:   mAnnotation = aAnnotation;
     1:   return NS_OK;
     1: }
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetHasAnnotation(bool* aHasIt)
     1: {
     1:   *aHasIt = ! mAnnotation.IsEmpty();
     1:   return NS_OK;
     1: }
     1: 
 27981: /* attribute nsIVariant tags; */
 27981: NS_IMETHODIMP nsNavHistoryQuery::GetTags(nsIVariant **aTags)
 27981: {
 27981:   NS_ENSURE_ARG_POINTER(aTags);
 27981: 
 27981:   nsresult rv;
 27981:   nsCOMPtr<nsIWritableVariant> out = do_CreateInstance(NS_VARIANT_CONTRACTID,
 27981:                                                        &rv);
 27981:   NS_ENSURE_SUCCESS(rv, rv);
 27981: 
108991:   uint32_t arrayLen = mTags.Length();
 27981: 
 27981:   if (arrayLen == 0)
 27981:     rv = out->SetAsEmptyArray();
 27981:   else {
 27981:     // Note: The resulting nsIVariant dupes both the array and its elements.
 27981:     const PRUnichar **array = reinterpret_cast<const PRUnichar **>
 27981:                               (NS_Alloc(arrayLen * sizeof(PRUnichar *)));
 27981:     NS_ENSURE_TRUE(array, NS_ERROR_OUT_OF_MEMORY);
 27981: 
108991:     for (uint32_t i = 0; i < arrayLen; ++i) {
 27981:       array[i] = mTags[i].get();
 27981:     }
 27981: 
 27981:     rv = out->SetAsArray(nsIDataType::VTYPE_WCHAR_STR,
106838:                          nullptr,
 27981:                          arrayLen,
 27981:                          reinterpret_cast<void *>(array));
 27981:     NS_Free(array);
 27981:   }
 27981:   NS_ENSURE_SUCCESS(rv, rv);
 27981: 
 27981:   NS_ADDREF(*aTags = out);
 27981:   return NS_OK;
 27981: }
 27981: 
 27981: NS_IMETHODIMP nsNavHistoryQuery::SetTags(nsIVariant *aTags)
 27981: {
 27981:   NS_ENSURE_ARG(aTags);
 27981: 
108991:   uint16_t dataType;
 27981:   aTags->GetDataType(&dataType);
 27981: 
 27981:   // Caller passed in empty array.  Easy -- clear our mTags array and return.
 27981:   if (dataType == nsIDataType::VTYPE_EMPTY_ARRAY) {
 27981:     mTags.Clear();
 27981:     return NS_OK;
 27981:   }
 27981: 
 27981:   // Before we go any further, make sure caller passed in an array.
 27981:   NS_ENSURE_TRUE(dataType == nsIDataType::VTYPE_ARRAY, NS_ERROR_ILLEGAL_VALUE);
 27981: 
108991:   uint16_t eltType;
 27981:   nsIID eltIID;
108991:   uint32_t arrayLen;
 27981:   void *array;
 27981: 
 27981:   // Convert the nsIVariant to an array.  We own the resulting buffer and its
 27981:   // elements.
 27981:   nsresult rv = aTags->GetAsArray(&eltType, &eltIID, &arrayLen, &array);
 27981:   NS_ENSURE_SUCCESS(rv, rv);
 27981: 
 27981:   // If element type is not wstring, thanks a lot.  Your memory die now.
 27981:   if (eltType != nsIDataType::VTYPE_WCHAR_STR) {
 27981:     switch (eltType) {
 27981:     case nsIDataType::VTYPE_ID:
 27981:     case nsIDataType::VTYPE_CHAR_STR:
 27981:       {
 27981:         char **charArray = reinterpret_cast<char **>(array);
108991:         for (uint32_t i = 0; i < arrayLen; ++i) {
 27981:           if (charArray[i])
 27981:             NS_Free(charArray[i]);
 27981:         }
 27981:       }
 27981:       break;
 27981:     case nsIDataType::VTYPE_INTERFACE:
 27981:     case nsIDataType::VTYPE_INTERFACE_IS:
 27981:       {
 27981:         nsISupports **supportsArray = reinterpret_cast<nsISupports **>(array);
108991:         for (uint32_t i = 0; i < arrayLen; ++i) {
 27981:           NS_IF_RELEASE(supportsArray[i]);
 27981:         }
 27981:       }
 27981:       break;
 27981:     // The other types are primitives that do not need to be freed.
 27981:     }
 27981:     NS_Free(array);
 27981:     return NS_ERROR_ILLEGAL_VALUE;
 27981:   }
 27981: 
 27981:   PRUnichar **tags = reinterpret_cast<PRUnichar **>(array);
 27981:   mTags.Clear();
 27981: 
 27981:   // Finally, add each passed-in tag to our mTags array and then sort it.
108991:   for (uint32_t i = 0; i < arrayLen; ++i) {
 27981: 
 27981:     // Don't allow nulls.
 27981:     if (!tags[i]) {
 27981:       NS_Free(tags);
 27981:       return NS_ERROR_ILLEGAL_VALUE;
 27981:     }
 27981: 
 27981:     nsDependentString tag(tags[i]);
 27981: 
 27981:     // Don't store duplicate tags.  This isn't just to save memory or to be
 27981:     // fancy; the SQL that's built from the tags relies on no dupes.
 27981:     if (!mTags.Contains(tag)) {
 27981:       if (!mTags.AppendElement(tag)) {
 27981:         NS_Free(tags[i]);
 27981:         NS_Free(tags);
 27981:         return NS_ERROR_OUT_OF_MEMORY;
 27981:       }
 27981:     }
 27981:     NS_Free(tags[i]);
 27981:   }
 27981:   NS_Free(tags);
 27981: 
 27981:   mTags.Sort();
 27981: 
 27981:   return NS_OK;
 27981: }
 27981: 
 27981: /* attribute boolean tagsAreNot; */
 79445: NS_IMETHODIMP nsNavHistoryQuery::GetTagsAreNot(bool *aTagsAreNot)
 27981: {
 27981:   NS_ENSURE_ARG_POINTER(aTagsAreNot);
 27981:   *aTagsAreNot = mTagsAreNot;
 27981:   return NS_OK;
 27981: }
 27981: 
 79445: NS_IMETHODIMP nsNavHistoryQuery::SetTagsAreNot(bool aTagsAreNot)
 27981: {
 27981:   mTagsAreNot = aTagsAreNot;
 27981:   return NS_OK;
 27981: }
 27981: 
108991: NS_IMETHODIMP nsNavHistoryQuery::GetFolders(uint32_t *aCount,
108991:                                             int64_t **aFolders)
     1: {
108991:   uint32_t count = mFolders.Length();
108991:   int64_t *folders = nullptr;
     1:   if (count > 0) {
108991:     folders = static_cast<int64_t*>
108991:                          (nsMemory::Alloc(count * sizeof(int64_t)));
     1:     NS_ENSURE_TRUE(folders, NS_ERROR_OUT_OF_MEMORY);
     1: 
108991:     for (uint32_t i = 0; i < count; ++i) {
     1:       folders[i] = mFolders[i];
     1:     }
     1:   }
     1:   *aCount = count;
     1:   *aFolders = folders;
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsNavHistoryQuery::GetFolderCount(uint32_t *aCount)
     1: {
     1:   *aCount = mFolders.Length();
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsNavHistoryQuery::SetFolders(const int64_t *aFolders,
108991:                                             uint32_t aFolderCount)
     1: {
     1:   if (!mFolders.ReplaceElementsAt(0, mFolders.Length(),
     1:                                   aFolders, aFolderCount)) {
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
108991: NS_IMETHODIMP nsNavHistoryQuery::GetTransitions(uint32_t* aCount,
108991:                                                 uint32_t** aTransitions)
 44194: {
108991:   uint32_t count = mTransitions.Length();
108991:   uint32_t* transitions = nullptr;
 44194:   if (count > 0) {
108991:     transitions = reinterpret_cast<uint32_t*>
108991:                   (NS_Alloc(count * sizeof(uint32_t)));
 44194:     NS_ENSURE_TRUE(transitions, NS_ERROR_OUT_OF_MEMORY);
108991:     for (uint32_t i = 0; i < count; ++i) {
 44194:       transitions[i] = mTransitions[i];
 44194:     }
 44194:   }
 44194:   *aCount = count;
 44194:   *aTransitions = transitions;
 44194:   return NS_OK;
 44194: }
 44194: 
108991: NS_IMETHODIMP nsNavHistoryQuery::GetTransitionCount(uint32_t* aCount)
 44194: {
 44194:   *aCount = mTransitions.Length();
 44194:   return NS_OK;
 44194: }
 44194: 
108991: NS_IMETHODIMP nsNavHistoryQuery::SetTransitions(const uint32_t* aTransitions,
108991:                                                 uint32_t aCount)
 44194: {
 44194:   if (!mTransitions.ReplaceElementsAt(0, mTransitions.Length(), aTransitions,
 44194:                                       aCount))
 44194:     return NS_ERROR_OUT_OF_MEMORY;
 44194: 
 44194:   return NS_OK;
 44194: }
 44194: 
     1: NS_IMETHODIMP nsNavHistoryQuery::Clone(nsINavHistoryQuery** _retval)
     1: {
106838:   *_retval = nullptr;
     1: 
     1:   nsNavHistoryQuery *clone = new nsNavHistoryQuery(*this);
     1:   NS_ENSURE_TRUE(clone, NS_ERROR_OUT_OF_MEMORY);
     1: 
     1:   clone->mRefCnt = 0; // the clone doesn't inherit our refcount
     1:   NS_ADDREF(*_retval = clone);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // nsNavHistoryQueryOptions
     1: NS_IMPL_ISUPPORTS2(nsNavHistoryQueryOptions, nsNavHistoryQueryOptions, nsINavHistoryQueryOptions)
     1: 
     1: // sortingMode
     1: NS_IMETHODIMP
108991: nsNavHistoryQueryOptions::GetSortingMode(uint16_t* aMode)
     1: {
     1:   *aMode = mSort;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP
108991: nsNavHistoryQueryOptions::SetSortingMode(uint16_t aMode)
     1: {
 68592:   if (aMode > SORT_BY_FRECENCY_DESCENDING)
     1:     return NS_ERROR_INVALID_ARG;
     1:   mSort = aMode;
     1:   return NS_OK;
     1: }
     1: 
   713: // sortingAnnotation
   713: NS_IMETHODIMP
   713: nsNavHistoryQueryOptions::GetSortingAnnotation(nsACString& _result) {
   713:   _result.Assign(mSortingAnnotation);
   713:   return NS_OK;
   713: }
   713: 
   713: NS_IMETHODIMP
   713: nsNavHistoryQueryOptions::SetSortingAnnotation(const nsACString& aSortingAnnotation) {
   713:   mSortingAnnotation.Assign(aSortingAnnotation);
   713:   return NS_OK;
   713: }
   713: 
     1: // resultType
     1: NS_IMETHODIMP
108991: nsNavHistoryQueryOptions::GetResultType(uint16_t* aType)
     1: {
     1:   *aType = mResultType;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP
108991: nsNavHistoryQueryOptions::SetResultType(uint16_t aType)
     1: {
 14224:   if (aType > RESULTS_AS_TAG_CONTENTS)
     1:     return NS_ERROR_INVALID_ARG;
 22327:   // Tag queries and containers are bookmarks related, so we set the QueryType
 22327:   // accordingly.
 22327:   if (aType == RESULTS_AS_TAG_QUERY || aType == RESULTS_AS_TAG_CONTENTS)
 22327:     mQueryType = QUERY_TYPE_BOOKMARKS;
     1:   mResultType = aType;
     1:   return NS_OK;
     1: }
     1: 
     1: // excludeItems
     1: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::GetExcludeItems(bool* aExclude)
     1: {
     1:   *aExclude = mExcludeItems;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::SetExcludeItems(bool aExclude)
     1: {
     1:   mExcludeItems = aExclude;
     1:   return NS_OK;
     1: }
     1: 
     1: // excludeQueries
     1: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::GetExcludeQueries(bool* aExclude)
     1: {
     1:   *aExclude = mExcludeQueries;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::SetExcludeQueries(bool aExclude)
     1: {
     1:   mExcludeQueries = aExclude;
     1:   return NS_OK;
     1: }
     1: 
     1: // excludeReadOnlyFolders
     1: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::GetExcludeReadOnlyFolders(bool* aExclude)
     1: {
     1:   *aExclude = mExcludeReadOnlyFolders;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::SetExcludeReadOnlyFolders(bool aExclude)
     1: {
     1:   mExcludeReadOnlyFolders = aExclude;
     1:   return NS_OK;
     1: }
     1: 
     1: // expandQueries
     1: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::GetExpandQueries(bool* aExpand)
     1: {
     1:   *aExpand = mExpandQueries;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::SetExpandQueries(bool aExpand)
     1: {
     1:   mExpandQueries = aExpand;
     1:   return NS_OK;
     1: }
     1: 
     1: // includeHidden
     1: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::GetIncludeHidden(bool* aIncludeHidden)
     1: {
     1:   *aIncludeHidden = mIncludeHidden;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::SetIncludeHidden(bool aIncludeHidden)
     1: {
     1:   mIncludeHidden = aIncludeHidden;
     1:   return NS_OK;
     1: }
     1: 
     1: // maxResults
     1: NS_IMETHODIMP
108991: nsNavHistoryQueryOptions::GetMaxResults(uint32_t* aMaxResults)
     1: {
     1:   *aMaxResults = mMaxResults;
     1:   return NS_OK;
     1: }
     1: NS_IMETHODIMP
108991: nsNavHistoryQueryOptions::SetMaxResults(uint32_t aMaxResults)
     1: {
     1:   mMaxResults = aMaxResults;
     1:   return NS_OK;
     1: }
     1: 
   809: // queryType
   809: NS_IMETHODIMP
108991: nsNavHistoryQueryOptions::GetQueryType(uint16_t* _retval)
   809: {
   809:   *_retval = mQueryType;
   809:   return NS_OK;
   809: }
   809: NS_IMETHODIMP
108991: nsNavHistoryQueryOptions::SetQueryType(uint16_t aQueryType)
   809: {
 22327:   // Tag query and containers are forced to QUERY_TYPE_BOOKMARKS when the
 22327:   // resultType is set.
 22327:   if (mResultType == RESULTS_AS_TAG_CONTENTS ||
 22327:       mResultType == RESULTS_AS_TAG_QUERY)
 22327:    return NS_OK;
   809:   mQueryType = aQueryType;
   809:   return NS_OK;
   809: }
   809: 
 40626: // asyncEnabled
 40626: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::GetAsyncEnabled(bool* _asyncEnabled)
 40626: {
 40626:   *_asyncEnabled = mAsyncEnabled;
 40626:   return NS_OK;
 40626: }
 40626: NS_IMETHODIMP
 79445: nsNavHistoryQueryOptions::SetAsyncEnabled(bool aAsyncEnabled)
 40626: {
 40626:   mAsyncEnabled = aAsyncEnabled;
 40626:   return NS_OK;
 40626: }
 40626: 
 40626: 
     1: NS_IMETHODIMP
     1: nsNavHistoryQueryOptions::Clone(nsINavHistoryQueryOptions** aResult)
     1: {
106838:   nsNavHistoryQueryOptions *clone = nullptr;
     1:   nsresult rv = Clone(&clone);
     1:   *aResult = clone;
     1:   return rv;
     1: }
     1: 
     1: nsresult
     1: nsNavHistoryQueryOptions::Clone(nsNavHistoryQueryOptions **aResult)
     1: {
106838:   *aResult = nullptr;
     1:   nsNavHistoryQueryOptions *result = new nsNavHistoryQueryOptions();
     1:   if (! result)
     1:     return NS_ERROR_OUT_OF_MEMORY;
     1: 
     1:   nsRefPtr<nsNavHistoryQueryOptions> resultHolder(result);
     1:   result->mSort = mSort;
     1:   result->mResultType = mResultType;
     1:   result->mExcludeItems = mExcludeItems;
     1:   result->mExcludeQueries = mExcludeQueries;
     1:   result->mExpandQueries = mExpandQueries;
   809:   result->mMaxResults = mMaxResults;
   809:   result->mQueryType = mQueryType;
  6822:   result->mParentAnnotationToExclude = mParentAnnotationToExclude;
 40626:   result->mAsyncEnabled = mAsyncEnabled;
     1: 
     1:   resultHolder.swap(*aResult);
     1:   return NS_OK;
     1: }
     1: 
     1: 
     1: // AppendBoolKeyValueIfTrue
     1: 
     1: void // static
     1: AppendBoolKeyValueIfTrue(nsACString& aString, const nsCString& aName,
     1:                          nsINavHistoryQuery* aQuery,
     1:                          BoolQueryGetter getter)
     1: {
 79445:   bool value;
 69685:   DebugOnly<nsresult> rv = (aQuery->*getter)(&value);
     1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Failure getting boolean value");
     1:   if (value) {
     1:     AppendAmpersandIfNonempty(aString);
     1:     aString += aName;
     1:     aString.AppendLiteral("=1");
     1:   }
     1: }
     1: 
     1: 
     1: // AppendUint32KeyValueIfNonzero
     1: 
     1: void // static
     1: AppendUint32KeyValueIfNonzero(nsACString& aString,
     1:                               const nsCString& aName,
     1:                               nsINavHistoryQuery* aQuery,
     1:                               Uint32QueryGetter getter)
     1: {
108991:   uint32_t value;
 69685:   DebugOnly<nsresult> rv = (aQuery->*getter)(&value);
     1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Failure getting value");
     1:   if (value) {
     1:     AppendAmpersandIfNonempty(aString);
     1:     aString += aName;
     1: 
     1:     // AppendInt requires a concrete string
110974:     nsAutoCString appendMe("=");
     1:     appendMe.AppendInt(value);
     1:     aString.Append(appendMe);
     1:   }
     1: }
     1: 
     1: 
     1: // AppendInt64KeyValueIfNonzero
     1: 
     1: void // static
     1: AppendInt64KeyValueIfNonzero(nsACString& aString,
     1:                              const nsCString& aName,
     1:                              nsINavHistoryQuery* aQuery,
     1:                              Int64QueryGetter getter)
     1: {
110765:   PRTime value;
 69685:   DebugOnly<nsresult> rv = (aQuery->*getter)(&value);
     1:   NS_ASSERTION(NS_SUCCEEDED(rv), "Failure getting value");
     1:   if (value) {
     1:     AppendAmpersandIfNonempty(aString);
     1:     aString += aName;
110974:     nsAutoCString appendMe("=");
110765:     appendMe.AppendInt(static_cast<int64_t>(value));
     1:     aString.Append(appendMe);
     1:   }
     1: }
     1: 
     1: 
     1: // SetQuery/OptionsKeyBool
     1: 
     1: void // static
     1: SetQueryKeyBool(const nsCString& aValue, nsINavHistoryQuery* aQuery,
     1:                 BoolQuerySetter setter)
     1: {
 79445:   bool value;
     1:   nsresult rv = ParseQueryBooleanString(aValue, &value);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     rv = (aQuery->*setter)(value);
     1:     if (NS_FAILED(rv)) {
     1:       NS_WARNING("Error setting boolean key value");
     1:     }
     1:   } else {
     1:     NS_WARNING("Invalid boolean key value in query string.");
     1:   }
     1: }
     1: void // static
     1: SetOptionsKeyBool(const nsCString& aValue, nsINavHistoryQueryOptions* aOptions,
     1:                  BoolOptionsSetter setter)
     1: {
 79445:   bool value;
     1:   nsresult rv = ParseQueryBooleanString(aValue, &value);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     rv = (aOptions->*setter)(value);
     1:     if (NS_FAILED(rv)) {
     1:       NS_WARNING("Error setting boolean key value");
     1:     }
     1:   } else {
     1:     NS_WARNING("Invalid boolean key value in query string.");
     1:   }
     1: }
     1: 
     1: 
     1: // SetQuery/OptionsKeyUint32
     1: 
     1: void // static
     1: SetQueryKeyUint32(const nsCString& aValue, nsINavHistoryQuery* aQuery,
     1:                   Uint32QuerySetter setter)
     1: {
     1:   nsresult rv;
108991:   uint32_t value = aValue.ToInteger(&rv);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     rv = (aQuery->*setter)(value);
     1:     if (NS_FAILED(rv)) {
     1:       NS_WARNING("Error setting Int32 key value");
     1:     }
     1:   } else {
     1:     NS_WARNING("Invalid Int32 key value in query string.");
     1:   }
     1: }
     1: void // static
     1: SetOptionsKeyUint32(const nsCString& aValue, nsINavHistoryQueryOptions* aOptions,
     1:                   Uint32OptionsSetter setter)
     1: {
     1:   nsresult rv;
108991:   uint32_t value = aValue.ToInteger(&rv);
     1:   if (NS_SUCCEEDED(rv)) {
     1:     rv = (aOptions->*setter)(value);
     1:     if (NS_FAILED(rv)) {
     1:       NS_WARNING("Error setting Int32 key value");
     1:     }
     1:   } else {
     1:     NS_WARNING("Invalid Int32 key value in query string.");
     1:   }
     1: }
     1: 
   809: void // static
   809: SetOptionsKeyUint16(const nsCString& aValue, nsINavHistoryQueryOptions* aOptions,
   809:                     Uint16OptionsSetter setter)
   809: {
   809:   nsresult rv;
108991:   uint16_t value = static_cast<uint16_t>(aValue.ToInteger(&rv));
   809:   if (NS_SUCCEEDED(rv)) {
   809:     rv = (aOptions->*setter)(value);
   809:     if (NS_FAILED(rv)) {
   809:       NS_WARNING("Error setting Int16 key value");
   809:     }
   809:   } else {
   809:     NS_WARNING("Invalid Int16 key value in query string.");
   809:   }
   809: }
   809: 
     1: 
     1: // SetQueryKeyInt64
     1: 
     1: void SetQueryKeyInt64(const nsCString& aValue, nsINavHistoryQuery* aQuery,
     1:                       Int64QuerySetter setter)
     1: {
     1:   nsresult rv;
108991:   int64_t value;
     1:   if (PR_sscanf(aValue.get(), "%lld", &value) == 1) {
     1:     rv = (aQuery->*setter)(value);
     1:     if (NS_FAILED(rv)) {
     1:       NS_WARNING("Error setting Int64 key value");
     1:     }
     1:   } else {
     1:     NS_WARNING("Invalid Int64 value in query string.");
     1:   }
     1: }
