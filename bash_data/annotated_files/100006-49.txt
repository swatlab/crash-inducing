 52557: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
 52557:  * vim: set ts=4 sw=4 et tw=99:
 52557:  *
 98983:  * This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 52557: 
 76193: #if !defined jslogic_h__ && defined JS_METHODJIT
 52557: #define jslogic_h__
 52557: 
 52557: #include "MethodJIT.h"
 52557: 
 52557: namespace js {
 52557: namespace mjit {
 52557: namespace stubs {
 52557: 
 59882: typedef enum JSTrapType {
 59882:     JSTRAP_NONE = 0,
 59882:     JSTRAP_TRAP = 1,
 59882:     JSTRAP_SINGLESTEP = 2
 59882: } JSTrapType;
 59882: 
 52704: void JS_FASTCALL This(VMFrame &f);
 84755: void JS_FASTCALL NewInitArray(VMFrame &f, uint32_t count);
 77413: void JS_FASTCALL NewInitObject(VMFrame &f, JSObject *base);
 84755: void JS_FASTCALL Trap(VMFrame &f, uint32_t trapTypes);
 75513: void JS_FASTCALL DebuggerStatement(VMFrame &f, jsbytecode *pc);
 53168: void JS_FASTCALL Interrupt(VMFrame &f, jsbytecode *pc);
 76193: void JS_FASTCALL RecompileForInline(VMFrame &f);
 84755: void JS_FASTCALL InitElem(VMFrame &f, uint32_t last);
 86542: void JS_FASTCALL InitProp(VMFrame &f, PropertyName *name);
 52719: 
 53840: void JS_FASTCALL HitStackQuota(VMFrame &f);
 84755: void * JS_FASTCALL FixupArity(VMFrame &f, uint32_t argc);
 84755: void * JS_FASTCALL CompileFunction(VMFrame &f, uint32_t argc);
 84755: void JS_FASTCALL SlowNew(VMFrame &f, uint32_t argc);
 84755: void JS_FASTCALL SlowCall(VMFrame &f, uint32_t argc);
 84755: void * JS_FASTCALL UncachedNew(VMFrame &f, uint32_t argc);
 84755: void * JS_FASTCALL UncachedCall(VMFrame &f, uint32_t argc);
 84755: void * JS_FASTCALL UncachedLoweredCall(VMFrame &f, uint32_t argc);
 84755: void JS_FASTCALL Eval(VMFrame &f, uint32_t argc);
 64363: void JS_FASTCALL ScriptDebugPrologue(VMFrame &f);
 64363: void JS_FASTCALL ScriptDebugEpilogue(VMFrame &f);
 73073: void JS_FASTCALL ScriptProbeOnlyPrologue(VMFrame &f);
 73073: void JS_FASTCALL ScriptProbeOnlyEpilogue(VMFrame &f);
 53590: 
 68952: /*
 68952:  * Result struct for UncachedXHelper.
 68952:  *
 68952:  * These functions can have one of two results:
 68952:  *
 68952:  *   (1) The function was executed in the interpreter. Then all fields
 68952:  *       are NULL except unjittable.
 68952:  *
 68952:  *   (2) The function was not executed, and the function has been compiled
 68952:  *       to JM native code. Then all fields are non-NULL.
 68952:  */
 68952: struct UncachedCallResult {
 68952:     JSFunction *fun;          // callee function
 68952:     void       *codeAddr;     // code address of compiled callee function
 68952:     bool       unjittable;    // did we try to JIT and fail?
 68952: 
 68952:     void init() {
 68952:         fun = NULL;
 68952:         codeAddr = NULL;
 68952:         unjittable = false;
 68952:     }
 68952: };
 68952: 
 68952: /*
 68952:  * Helper functions for stubs and IC functions for calling functions.
 68952:  * These functions either execute the function, return a native code
 68952:  * pointer that can be used to call the function, or throw.
 68952:  */
 84755: void UncachedCallHelper(VMFrame &f, uint32_t argc, bool lowered, UncachedCallResult *ucr);
 84755: void UncachedNewHelper(VMFrame &f, uint32_t argc, UncachedCallResult *ucr);
 68952: 
 55503: void JS_FASTCALL CreateThis(VMFrame &f, JSObject *proto);
 52772: void JS_FASTCALL Throw(VMFrame &f);
 52617: 
 53590: void * JS_FASTCALL LookupSwitch(VMFrame &f, jsbytecode *pc);
 53590: void * JS_FASTCALL TableSwitch(VMFrame &f, jsbytecode *origPc);
 53590: 
 86855: void JS_FASTCALL BindName(VMFrame &f, PropertyName *name);
 52826: JSObject * JS_FASTCALL BindGlobalName(VMFrame &f);
 86542: template<JSBool strict> void JS_FASTCALL SetName(VMFrame &f, PropertyName *name);
 86542: template<JSBool strict> void JS_FASTCALL SetGlobalName(VMFrame &f, PropertyName *name);
 52819: void JS_FASTCALL Name(VMFrame &f);
 86855: void JS_FASTCALL GetProp(VMFrame &f, PropertyName *name);
 86542: void JS_FASTCALL GetPropNoCache(VMFrame &f, PropertyName *name);
 52693: void JS_FASTCALL GetElem(VMFrame &f);
 54169: template<JSBool strict> void JS_FASTCALL SetElem(VMFrame &f);
 77357: void JS_FASTCALL ToId(VMFrame &f);
 86855: void JS_FASTCALL ImplicitThis(VMFrame &f, PropertyName *name);
 52746: 
 86542: template <JSBool strict> void JS_FASTCALL DelProp(VMFrame &f, PropertyName *name);
 54406: template <JSBool strict> void JS_FASTCALL DelElem(VMFrame &f);
 86542: void JS_FASTCALL DelName(VMFrame &f, PropertyName *name);
 54413: JSBool JS_FASTCALL In(VMFrame &f);
 52730: 
 86542: void JS_FASTCALL DefVarOrConst(VMFrame &f, PropertyName *name);
 86542: void JS_FASTCALL SetConst(VMFrame &f, PropertyName *name);
 54169: template<JSBool strict> void JS_FASTCALL DefFun(VMFrame &f, JSFunction *fun);
 80271: void JS_FASTCALL RegExp(VMFrame &f, JSObject *regex);
 52730: JSObject * JS_FASTCALL Lambda(VMFrame &f, JSFunction *fun);
 52775: JSObject * JS_FASTCALL FlatLambda(VMFrame &f, JSFunction *fun);
 52778: void JS_FASTCALL Arguments(VMFrame &f);
 52785: void JS_FASTCALL EnterBlock(VMFrame &f, JSObject *obj);
 86077: void JS_FASTCALL LeaveBlock(VMFrame &f);
 52557: 
 52652: JSBool JS_FASTCALL LessThan(VMFrame &f);
 52652: JSBool JS_FASTCALL LessEqual(VMFrame &f);
 52652: JSBool JS_FASTCALL GreaterThan(VMFrame &f);
 52652: JSBool JS_FASTCALL GreaterEqual(VMFrame &f);
 52679: JSBool JS_FASTCALL Equal(VMFrame &f);
 52679: JSBool JS_FASTCALL NotEqual(VMFrame &f);
 52652: 
 52721: void JS_FASTCALL BitOr(VMFrame &f);
 52721: void JS_FASTCALL BitXor(VMFrame &f);
 52617: void JS_FASTCALL BitAnd(VMFrame &f);
 52724: void JS_FASTCALL BitNot(VMFrame &f);
 52685: void JS_FASTCALL Lsh(VMFrame &f);
 52685: void JS_FASTCALL Rsh(VMFrame &f);
 52725: void JS_FASTCALL Ursh(VMFrame &f);
 52692: void JS_FASTCALL Add(VMFrame &f);
 52692: void JS_FASTCALL Sub(VMFrame &f);
 52692: void JS_FASTCALL Mul(VMFrame &f);
 52692: void JS_FASTCALL Div(VMFrame &f);
 52692: void JS_FASTCALL Mod(VMFrame &f);
 52713: void JS_FASTCALL Neg(VMFrame &f);
 52916: void JS_FASTCALL Pos(VMFrame &f);
 52734: void JS_FASTCALL Not(VMFrame &f);
 53513: void JS_FASTCALL StrictEq(VMFrame &f);
 53513: void JS_FASTCALL StrictNe(VMFrame &f);
 52617: 
 84755: void JS_FASTCALL Iter(VMFrame &f, uint32_t flags);
 84755: void JS_FASTCALL IterNext(VMFrame &f, int32_t offset);
 52737: JSBool JS_FASTCALL IterMore(VMFrame &f);
 52737: void JS_FASTCALL EndIter(VMFrame &f);
 52733: 
 52686: JSBool JS_FASTCALL ValueToBoolean(VMFrame &f);
 52738: JSString * JS_FASTCALL TypeOf(VMFrame &f);
 52780: JSBool JS_FASTCALL InstanceOf(VMFrame &f);
 52911: void JS_FASTCALL FastInstanceOf(VMFrame &f);
 52686: 
 76193: /*
 76193:  * Helper for triggering recompilation should a name read miss a type barrier,
 76193:  * produce undefined or -0.
 76193:  */
 84755: void JS_FASTCALL TypeBarrierHelper(VMFrame &f, uint32_t which);
 76193: void JS_FASTCALL TypeBarrierReturn(VMFrame &f, Value *vp);
 76193: void JS_FASTCALL NegZeroHelper(VMFrame &f);
 76193: 
 84755: void JS_FASTCALL StubTypeHelper(VMFrame &f, int32_t which);
 78456: 
 76193: void JS_FASTCALL CheckArgumentTypes(VMFrame &f);
 76193: 
 76193: #ifdef DEBUG
 76193: void JS_FASTCALL AssertArgumentTypes(VMFrame &f);
 76193: #endif
 76193: 
 76193: void JS_FASTCALL MissedBoundsCheckEntry(VMFrame &f);
 76193: void JS_FASTCALL MissedBoundsCheckHead(VMFrame &f);
 76193: void * JS_FASTCALL InvariantFailure(VMFrame &f, void *repatchCode);
 76193: 
 84755: template <bool strict> int32_t JS_FASTCALL ConvertToTypedInt(JSContext *cx, Value *vp);
 60164: void JS_FASTCALL ConvertToTypedFloat(JSContext *cx, Value *vp);
 60164: 
 60211: void JS_FASTCALL Exception(VMFrame &f);
 60211: 
100006: void JS_FASTCALL FunctionFramePrologue(VMFrame &f);
100006: void JS_FASTCALL FunctionFrameEpilogue(VMFrame &f);
 77884: 
 77884: void JS_FASTCALL AnyFrameEpilogue(VMFrame &f);
 77884: 
 76193: JSObject * JS_FASTCALL
 84755: NewDenseUnallocatedArray(VMFrame &f, uint32_t length);
 76193: 
 80557: void JS_FASTCALL ArrayConcatTwoArrays(VMFrame &f);
 80557: void JS_FASTCALL ArrayShift(VMFrame &f);
 80556: 
 82129: void JS_FASTCALL WriteBarrier(VMFrame &f, Value *addr);
 82129: void JS_FASTCALL GCThingWriteBarrier(VMFrame &f, Value *addr);
 82129: 
 87654: void JS_FASTCALL CrossChunkShim(VMFrame &f, void *edge);
 87654: 
 54169: } /* namespace stubs */
 54169: 
 54169: /*
 54169:  * If COND is true, return A; otherwise, return B. This allows us to choose between
 54169:  * function template instantiations without running afoul of C++'s overload resolution
 54169:  * rules. (Try simplifying, and you'll either see the problem --- or have found a
 54169:  * better solution!)
 54169:  */
 54169: template<typename FuncPtr>
 54169: inline FuncPtr FunctionTemplateConditional(bool cond, FuncPtr a, FuncPtr b) {
 54169:     return cond ? a : b;
 54169: }
 54169: 
 54169: }} /* namespace stubs,mjit,js */
 52557: 
 52557: extern "C" void *
 52557: js_InternalThrow(js::VMFrame &f);
 52557: 
 76193: extern "C" void *
 76193: js_InternalInterpret(void *returnData, void *returnType, void *returnReg, js::VMFrame &f);
 76193: 
 52557: #endif /* jslogic_h__ */
 52557: 
