    1: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Robert Ginda, <rginda@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #include "jsdbgapi.h"
56784: #include "jslock.h"
38922: #include "jsd_xpc.h"
    1: 
    1: #include "nsIXPConnect.h"
46998: #include "mozilla/ModuleUtils.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIScriptGlobalObject.h"
    1: #include "nsIObserver.h"
    1: #include "nsIObserverService.h"
    1: #include "nsICategoryManager.h"
    1: #include "nsIJSRuntimeService.h"
    1: #include "nsIThreadInternal.h"
    1: #include "nsThreadUtils.h"
    1: #include "nsMemory.h"
    1: #include "jsdebug.h"
    1: #include "nsReadableUtils.h"
    1: #include "nsCRT.h"
    1: 
    1: /* XXX DOM dependency */
    1: #include "nsIScriptContext.h"
    1: #include "nsIJSContextStack.h"
    1: 
56852: /* XXX private JS headers. */
56852: #include "jscompartment.h"
56852: 
    1: /*
    1:  * defining CAUTIOUS_SCRIPTHOOK makes jsds disable GC while calling out to the
    1:  * script hook.  This was a hack to avoid some js engine problems that should
    1:  * be fixed now (see Mozilla bug 77636).
    1:  */
    1: #undef CAUTIOUS_SCRIPTHOOK
    1: 
    1: #ifdef DEBUG_verbose
    1: #   define DEBUG_COUNT(name, count)                                             \
    1:         { if ((count % 10) == 0) printf (name ": %i\n", count); }
    1: #   define DEBUG_CREATE(name, count) {count++; DEBUG_COUNT ("+++++ "name,count)}
    1: #   define DEBUG_DESTROY(name, count) {count--; DEBUG_COUNT ("----- "name,count)}
    1: #else
    1: #   define DEBUG_CREATE(name, count) 
    1: #   define DEBUG_DESTROY(name, count)
    1: #endif
    1: 
    1: #define ASSERT_VALID_CONTEXT   { if (!mCx) return NS_ERROR_NOT_AVAILABLE; }
    1: #define ASSERT_VALID_EPHEMERAL { if (!mValid) return NS_ERROR_NOT_AVAILABLE; }
    1: 
    1: #define JSDSERVICE_CID                               \
    1: { /* f1299dc2-1dd1-11b2-a347-ee6b7660e048 */         \
    1:      0xf1299dc2,                                     \
    1:      0x1dd1,                                         \
    1:      0x11b2,                                         \
    1:     {0xa3, 0x47, 0xee, 0x6b, 0x76, 0x60, 0xe0, 0x48} \
    1: }
    1: 
    1: #define JSDASO_CID                                   \
    1: { /* 2fd6b7f6-eb8c-4f32-ad26-113f2c02d0fe */         \
    1:      0x2fd6b7f6,                                     \
    1:      0xeb8c,                                         \
    1:      0x4f32,                                         \
    1:     {0xad, 0x26, 0x11, 0x3f, 0x2c, 0x02, 0xd0, 0xfe} \
    1: }
    1: 
    1: #define JSDS_MAJOR_VERSION 1
    1: #define JSDS_MINOR_VERSION 2
    1: 
    1: #define NS_CATMAN_CTRID   "@mozilla.org/categorymanager;1"
    1: #define NS_JSRT_CTRID     "@mozilla.org/js/xpc/RuntimeService;1"
    1: 
    1: #define AUTOREG_CATEGORY  "xpcom-autoregistration"
    1: #define APPSTART_CATEGORY "app-startup"
    1: #define JSD_AUTOREG_ENTRY "JSDebugger Startup Observer"
    1: #define JSD_STARTUP_ENTRY "JSDebugger Startup Observer"
    1: 
18907: static JSBool
    1: jsds_GCCallbackProc (JSContext *cx, JSGCStatus status);
    1: 
    1: /*******************************************************************************
    1:  * global vars
    1:  ******************************************************************************/
    1: 
    1: const char implementationString[] = "Mozilla JavaScript Debugger Service";
    1: 
    1: const char jsdServiceCtrID[] = "@mozilla.org/js/jsd/debugger-service;1";
    1: const char jsdARObserverCtrID[] = "@mozilla.org/js/jsd/app-start-observer;2";
    1: const char jsdASObserverCtrID[] = "service,@mozilla.org/js/jsd/app-start-observer;2";
    1: 
    1: #ifdef DEBUG_verbose
    1: PRUint32 gScriptCount   = 0;
    1: PRUint32 gValueCount    = 0;
    1: PRUint32 gPropertyCount = 0;
    1: PRUint32 gContextCount  = 0;
    1: PRUint32 gFrameCount  = 0;
    1: #endif
    1: 
    1: static jsdService   *gJsds       = 0;
    1: static JSGCCallback  gLastGCProc = jsds_GCCallbackProc;
    1: static JSGCStatus    gGCStatus   = JSGC_END;
    1: 
    1: static struct DeadScript {
    1:     PRCList     links;
    1:     JSDContext *jsdc;
    1:     jsdIScript *script;
    1: } *gDeadScripts = nsnull;
    1: 
    1: enum PatternType {
    1:     ptIgnore     = 0U,
    1:     ptStartsWith = 1U,
    1:     ptEndsWith   = 2U,
    1:     ptContains   = 3U,
    1:     ptEquals     = 4U
    1: };
    1: 
    1: static struct FilterRecord {
    1:     PRCList      links;
    1:     jsdIFilter  *filterObject;
    1:     void        *glob;
23431:     nsCString    urlPattern;
    1:     PatternType  patternType;
    1:     PRUint32     startLine;
    1:     PRUint32     endLine;
    1: } *gFilters = nsnull;
    1: 
    1: static struct LiveEphemeral *gLiveValues      = nsnull;
    1: static struct LiveEphemeral *gLiveProperties  = nsnull;
    1: static struct LiveEphemeral *gLiveContexts    = nsnull;
    1: static struct LiveEphemeral *gLiveStackFrames = nsnull;
    1: 
    1: /*******************************************************************************
    1:  * utility functions for ephemeral lists
    1:  *******************************************************************************/
    1: already_AddRefed<jsdIEphemeral>
    1: jsds_FindEphemeral (LiveEphemeral **listHead, void *key)
    1: {
    1:     if (!*listHead)
    1:         return nsnull;
    1:     
    1:     LiveEphemeral *lv_record = 
 3233:         reinterpret_cast<LiveEphemeral *>
 3233:                         (PR_NEXT_LINK(&(*listHead)->links));
    1:     do
    1:     {
    1:         if (lv_record->key == key)
    1:         {
    1:             NS_IF_ADDREF(lv_record->value);
    1:             return lv_record->value;
    1:         }
 3233:         lv_record = reinterpret_cast<LiveEphemeral *>
 3233:                                     (PR_NEXT_LINK(&lv_record->links));
    1:     }
    1:     while (lv_record != *listHead);
    1: 
    1:     return nsnull;
    1: }
    1: 
    1: void
    1: jsds_InvalidateAllEphemerals (LiveEphemeral **listHead)
    1: {
    1:     LiveEphemeral *lv_record = 
 3233:         reinterpret_cast<LiveEphemeral *>
 3233:                         (PR_NEXT_LINK(&(*listHead)->links));
59949:     do
    1:     {
    1:         LiveEphemeral *next =
 3233:             reinterpret_cast<LiveEphemeral *>
 3233:                             (PR_NEXT_LINK(&lv_record->links));
    1:         lv_record->value->Invalidate();
    1:         lv_record = next;
    1:     }
59949:     while (*listHead);
    1: }
    1: 
    1: void
    1: jsds_InsertEphemeral (LiveEphemeral **listHead, LiveEphemeral *item)
    1: {
    1:     if (*listHead) {
    1:         /* if the list exists, add to it */
    1:         PR_APPEND_LINK(&item->links, &(*listHead)->links);
    1:     } else {
    1:         /* otherwise create the list */
    1:         PR_INIT_CLIST(&item->links);
    1:         *listHead = item;
    1:     }
    1: }
    1: 
    1: void
    1: jsds_RemoveEphemeral (LiveEphemeral **listHead, LiveEphemeral *item)
    1: {
 3233:     LiveEphemeral *next = reinterpret_cast<LiveEphemeral *>
 3233:                                           (PR_NEXT_LINK(&item->links));
    1: 
    1:     if (next == item)
    1:     {
    1:         /* if the current item is also the next item, we're the only element,
    1:          * null out the list head */
    1:         NS_ASSERTION (*listHead == item,
    1:                       "How could we not be the head of a one item list?");
    1:         *listHead = nsnull;
    1:     }
    1:     else if (item == *listHead)
    1:     {
    1:         /* otherwise, if we're currently the list head, change it */
    1:         *listHead = next;
    1:     }
    1:     
    1:     PR_REMOVE_AND_INIT_LINK(&item->links);
    1: }
    1: 
    1: /*******************************************************************************
    1:  * utility functions for filters
    1:  *******************************************************************************/
    1: void
35666: jsds_FreeFilter (FilterRecord *rec)
    1: {
35666:     NS_IF_RELEASE (rec->filterObject);
35666:     PR_Free (rec);
    1: }
    1: 
    1: /* copies appropriate |filter| attributes into |rec|.
    1:  * False return indicates failure, the contents of |rec| will not be changed.
    1:  */
    1: PRBool
    1: jsds_SyncFilter (FilterRecord *rec, jsdIFilter *filter)
    1: {
    1:     NS_ASSERTION (rec, "jsds_SyncFilter without rec");
    1:     NS_ASSERTION (filter, "jsds_SyncFilter without filter");
    1:     
    1:     JSObject *glob_proper = nsnull;
    1:     nsCOMPtr<nsISupports> glob;
    1:     nsresult rv = filter->GetGlobalObject(getter_AddRefs(glob));
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1:     if (glob) {
    1:         nsCOMPtr<nsIScriptGlobalObject> nsiglob = do_QueryInterface(glob);
    1:         if (nsiglob)
    1:             glob_proper = nsiglob->GetGlobalJSObject();
    1:     }
    1:     
    1:     PRUint32 startLine;
    1:     rv = filter->GetStartLine(&startLine);
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1: 
    1:     PRUint32 endLine;
    1:     rv = filter->GetStartLine(&endLine);
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;    
    1: 
23431:     nsCAutoString urlPattern;
23431:     rv = filter->GetUrlPattern (urlPattern);
    1:     if (NS_FAILED(rv))
    1:         return PR_FALSE;
    1:     
23431:     PRUint32 len = urlPattern.Length();
23431:     if (len) {
    1:         if (urlPattern[0] == '*') {
    1:             /* pattern starts with a *, shift all chars once to the left,
    1:              * including the trailing null. */
23431:             urlPattern = Substring(urlPattern, 1, len);
    1: 
    1:             if (urlPattern[len - 2] == '*') {
    1:                 /* pattern is in the format "*foo*", overwrite the final * with
    1:                  * a null. */
23431:                 urlPattern.Truncate(len - 2);
    1:                 rec->patternType = ptContains;
    1:             } else {
    1:                 /* pattern is in the format "*foo", just make a note of the
    1:                  * new length. */
    1:                 rec->patternType = ptEndsWith;
    1:             }
    1:         } else if (urlPattern[len - 1] == '*') {
    1:             /* pattern is in the format "foo*", overwrite the final * with a 
    1:              * null. */
23431:             urlPattern.Truncate(len - 1);
    1:             rec->patternType = ptStartsWith;
    1:         } else {
    1:             /* pattern is in the format "foo". */
    1:             rec->patternType = ptEquals;
    1:         }
    1:     } else {
    1:         rec->patternType = ptIgnore;
    1:     }
    1: 
    1:     /* we got everything we need without failing, now copy it into rec. */
    1: 
    1:     if (rec->filterObject != filter) {
    1:         NS_IF_RELEASE(rec->filterObject);
    1:         NS_ADDREF(filter);
    1:         rec->filterObject = filter;
    1:     }
    1:     
    1:     rec->glob = glob_proper;
    1:     
    1:     rec->startLine     = startLine;
    1:     rec->endLine       = endLine;
    1:     
    1:     rec->urlPattern = urlPattern;
    1: 
    1:     return PR_TRUE;
    1:             
    1: }
    1: 
    1: FilterRecord *
    1: jsds_FindFilter (jsdIFilter *filter)
    1: {
    1:     if (!gFilters)
    1:         return nsnull;
    1:     
    1:     FilterRecord *current = gFilters;
    1:     
    1:     do {
    1:         if (current->filterObject == filter)
    1:             return current;
 3233:         current = reinterpret_cast<FilterRecord *>
 3233:                                   (PR_NEXT_LINK(&current->links));
    1:     } while (current != gFilters);
    1:     
    1:     return nsnull;
    1: }
    1: 
    1: /* returns true if the hook should be executed. */
    1: PRBool
    1: jsds_FilterHook (JSDContext *jsdc, JSDThreadState *state)
    1: {
    1:     JSContext *cx = JSD_GetJSContext (jsdc, state);
 3233:     void *glob = static_cast<void *>(JS_GetGlobalObject (cx));
    1: 
    1:     if (!glob) {
    1:         NS_WARNING("No global in threadstate");
    1:         return PR_FALSE;
    1:     }
    1:     
    1:     JSDStackFrameInfo *frame = JSD_GetStackFrame (jsdc, state);
    1: 
    1:     if (!frame) {
    1:         NS_WARNING("No frame in threadstate");
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     JSDScript *script = JSD_GetScriptForStackFrame (jsdc, state, frame);
    1:     if (!script)
    1:         return PR_TRUE;
    1: 
31602:     jsuword pc = JSD_GetPCForStackFrame (jsdc, state, frame);
    1: 
23431:     nsDependentCString url(JSD_GetScriptFilename (jsdc, script));
23431:     if (url.IsEmpty()) {
    1:         NS_WARNING ("Script with no filename");
    1:         return PR_FALSE;
    1:     }
    1: 
    1:     if (!gFilters)
    1:         return PR_TRUE;    
    1: 
    1:     PRUint32 currentLine = JSD_GetClosestLine (jsdc, script, pc);
    1:     PRUint32 len = 0;
    1:     FilterRecord *currentFilter = gFilters;
    1:     do {
    1:         PRUint32 flags = 0;
    1:         nsresult rv = currentFilter->filterObject->GetFlags(&flags);
    1:         NS_ASSERTION(NS_SUCCEEDED(rv), "Error getting flags for filter");
    1:         if (flags & jsdIFilter::FLAG_ENABLED) {
    1:             /* if there is no glob, or the globs match */
    1:             if ((!currentFilter->glob || currentFilter->glob == glob) &&
    1:                 /* and there is no start line, or the start line is before 
    1:                  * or equal to the current */
    1:                 (!currentFilter->startLine || 
    1:                  currentFilter->startLine <= currentLine) &&
    1:                 /* and there is no end line, or the end line is after
    1:                  * or equal to the current */
    1:                 (!currentFilter->endLine ||
    1:                  currentFilter->endLine >= currentLine)) {
    1:                 /* then we're going to have to compare the url. */
    1:                 if (currentFilter->patternType == ptIgnore)
18998:                     return !!(flags & jsdIFilter::FLAG_PASS);
    1: 
    1:                 if (!len)
23431:                     len = url.Length();
23431:                 nsCString urlPattern = currentFilter->urlPattern;
23431:                 PRUint32 patternLength = urlPattern.Length();
23431:                 if (len >= patternLength) {
    1:                     switch (currentFilter->patternType) {
    1:                         case ptEquals:
23431:                             if (urlPattern.Equals(url))
18998:                                 return !!(flags & jsdIFilter::FLAG_PASS);
    1:                             break;
    1:                         case ptStartsWith:
23431:                             if (urlPattern.Equals(Substring(url, 0, patternLength)))
18998:                                 return !!(flags & jsdIFilter::FLAG_PASS);
    1:                             break;
    1:                         case ptEndsWith:
23431:                             if (urlPattern.Equals(Substring(url, len - patternLength)))
18998:                                 return !!(flags & jsdIFilter::FLAG_PASS);
    1:                             break;
    1:                         case ptContains:
23431:                             {
23431:                                 nsACString::const_iterator start, end;
23431:                                 url.BeginReading(start);
23431:                                 url.EndReading(end);
23431:                                 if (FindInReadable(currentFilter->urlPattern, start, end))
18998:                                     return !!(flags & jsdIFilter::FLAG_PASS);
23431:                             }
    1:                             break;
    1:                         default:
31561:                             NS_ERROR("Invalid pattern type");
    1:                     }
    1:                 }                
    1:             }
    1:         }
 3233:         currentFilter = reinterpret_cast<FilterRecord *>
 3233:                                         (PR_NEXT_LINK(&currentFilter->links));
    1:     } while (currentFilter != gFilters);
    1: 
    1:     return PR_TRUE;
    1:     
    1: }
    1: 
    1: /*******************************************************************************
    1:  * c callbacks
    1:  *******************************************************************************/
    1: 
18907: static void
    1: jsds_NotifyPendingDeadScripts (JSContext *cx)
    1: {
    1: #ifdef CAUTIOUS_SCRIPTHOOK
    1:     JSRuntime *rt = JS_GetRuntime(cx);
    1: #endif
12860:     jsdService *jsds = gJsds;
12860: 
12860:     nsCOMPtr<jsdIScriptHook> hook;
12860:     if (jsds) {
12860:         NS_ADDREF(jsds);
12860:         jsds->GetScriptHook (getter_AddRefs(hook));
12860:         jsds->Pause(nsnull);
12860:     }
12860: 
12615:     DeadScript *deadScripts = gDeadScripts;
12615:     gDeadScripts = nsnull;
12615:     while (deadScripts) {
12615:         DeadScript *ds = deadScripts;
12615:         /* get next deleted script */
12615:         deadScripts = reinterpret_cast<DeadScript *>
12615:                                        (PR_NEXT_LINK(&ds->links));
12615:         if (deadScripts == ds)
12615:             deadScripts = nsnull;
    1: 
    1:         if (hook)
    1:         {
    1:             /* tell the user this script has been destroyed */
    1: #ifdef CAUTIOUS_SCRIPTHOOK
    1:             JS_UNKEEP_ATOMS(rt);
    1: #endif
    1:             hook->OnScriptDestroyed (ds->script);
    1: #ifdef CAUTIOUS_SCRIPTHOOK
    1:             JS_KEEP_ATOMS(rt);
    1: #endif
    1:         }
12615: 
12615:         /* take it out of the circular list */
    1:         PR_REMOVE_LINK(&ds->links);
12615: 
    1:         /* addref came from the FromPtr call in jsds_ScriptHookProc */
    1:         NS_RELEASE(ds->script);
    1:         /* free the struct! */
    1:         PR_Free(ds);
    1:     }
    1: 
12860:     if (jsds) {
12860:         jsds->UnPause(nsnull);
12860:         NS_RELEASE(jsds);
12860:     }
    1: }
    1: 
18907: static JSBool
    1: jsds_GCCallbackProc (JSContext *cx, JSGCStatus status)
    1: {
    1: #ifdef DEBUG_verbose
    1:     printf ("new gc status is %i\n", status);
    1: #endif
12615:     if (status == JSGC_END) {
12615:         /* just to guard against reentering. */
12615:         gGCStatus = JSGC_BEGIN;
12615:         while (gDeadScripts)
    1:             jsds_NotifyPendingDeadScripts (cx);
12615:     }
12615: 
12615:     gGCStatus = status;
61709:     if (gLastGCProc && !gLastGCProc (cx, status)) {
61709:         /*
61709:          * If gLastGCProc returns false, then the GC will abort without making
61709:          * another callback with status=JSGC_END, so set the status to JSGC_END
61709:          * here.
61709:          */
61709:         gGCStatus = JSGC_END;
61709:         return JS_FALSE;
61709:     }
    1:     
    1:     return JS_TRUE;
    1: }
    1: 
18907: static uintN
    1: jsds_ErrorHookProc (JSDContext *jsdc, JSContext *cx, const char *message,
    1:                     JSErrorReport *report, void *callerdata)
    1: {
    1:     static PRBool running = PR_FALSE;
    1: 
    1:     nsCOMPtr<jsdIErrorHook> hook;
    1:     gJsds->GetErrorHook(getter_AddRefs(hook));
    1:     if (!hook)
    1:         return JSD_ERROR_REPORTER_PASS_ALONG;
    1: 
    1:     if (running)
    1:         return JSD_ERROR_REPORTER_PASS_ALONG;
    1:     
    1:     running = PR_TRUE;
    1:     
    1:     nsCOMPtr<jsdIValue> val;
    1:     if (JS_IsExceptionPending(cx)) {
    1:         jsval jv;
    1:         JS_GetPendingException(cx, &jv);
    1:         JSDValue *jsdv = JSD_NewValue (jsdc, jv);
    1:         val = getter_AddRefs(jsdValue::FromPtr(jsdc, jsdv));
    1:     }
    1:     
23431:     nsCAutoString fileName;
    1:     PRUint32    line;
    1:     PRUint32    pos;
    1:     PRUint32    flags;
    1:     PRUint32    errnum;
    1:     PRBool      rval;
    1:     if (report) {
23431:         fileName.Assign(report->filename);
    1:         line = report->lineno;
    1:         pos = report->tokenptr - report->linebuf;
    1:         flags = report->flags;
    1:         errnum = report->errorNumber;
    1:     }
    1:     else
    1:     {
    1:         line     = 0;
    1:         pos      = 0;
    1:         flags    = 0;
    1:         errnum   = 0;
    1:     }
    1:     
    1:     gJsds->Pause(nsnull);
23431:     hook->OnError (nsDependentCString(message), fileName, line, pos, flags, errnum, val, &rval);
    1:     gJsds->UnPause(nsnull);
    1:     
    1:     running = PR_FALSE;
    1:     if (!rval)
    1:         return JSD_ERROR_REPORTER_DEBUG;
    1:     
    1:     return JSD_ERROR_REPORTER_PASS_ALONG;
    1: }
    1: 
18907: static JSBool
    1: jsds_CallHookProc (JSDContext* jsdc, JSDThreadState* jsdthreadstate,
    1:                    uintN type, void* callerdata)
    1: {
    1:     nsCOMPtr<jsdICallHook> hook;
    1: 
    1:     switch (type)
    1:     {
    1:         case JSD_HOOK_TOPLEVEL_START:
    1:         case JSD_HOOK_TOPLEVEL_END:
    1:             gJsds->GetTopLevelHook(getter_AddRefs(hook));
    1:             break;
    1:             
    1:         case JSD_HOOK_FUNCTION_CALL:
    1:         case JSD_HOOK_FUNCTION_RETURN:
    1:             gJsds->GetFunctionHook(getter_AddRefs(hook));
    1:             break;
    1: 
    1:         default:
    1:             NS_ASSERTION (0, "Unknown hook type.");
    1:     }
    1:     
    1:     if (!hook)
    1:         return JS_TRUE;
    1: 
    1:     if (!jsds_FilterHook (jsdc, jsdthreadstate))
    1:         return JS_FALSE;
    1: 
    1:     JSDStackFrameInfo *native_frame = JSD_GetStackFrame (jsdc, jsdthreadstate);
    1:     nsCOMPtr<jsdIStackFrame> frame =
    1:         getter_AddRefs(jsdStackFrame::FromPtr(jsdc, jsdthreadstate,
    1:                                               native_frame));
    1:     gJsds->Pause(nsnull);
    1:     hook->OnCall(frame, type);    
    1:     gJsds->UnPause(nsnull);
    1:     jsdStackFrame::InvalidateAll();
    1: 
    1:     return JS_TRUE;
    1: }
    1: 
18907: static PRUint32
    1: jsds_ExecutionHookProc (JSDContext* jsdc, JSDThreadState* jsdthreadstate,
    1:                         uintN type, void* callerdata, jsval* rval)
    1: {
    1:     nsCOMPtr<jsdIExecutionHook> hook(0);
    1:     PRUint32 hook_rv = JSD_HOOK_RETURN_CONTINUE;
    1:     nsCOMPtr<jsdIValue> js_rv;
    1: 
    1:     switch (type)
    1:     {
    1:         case JSD_HOOK_INTERRUPTED:
    1:             gJsds->GetInterruptHook(getter_AddRefs(hook));
    1:             break;
    1:         case JSD_HOOK_DEBUG_REQUESTED:
    1:             gJsds->GetDebugHook(getter_AddRefs(hook));
    1:             break;
    1:         case JSD_HOOK_DEBUGGER_KEYWORD:
    1:             gJsds->GetDebuggerHook(getter_AddRefs(hook));
    1:             break;
    1:         case JSD_HOOK_BREAKPOINT:
    1:             {
    1:                 /* we can't pause breakpoints the way we pause the other
    1:                  * execution hooks (at least, not easily.)  Instead we bail
    1:                  * here if the service is paused. */
    1:                 PRUint32 level;
    1:                 gJsds->GetPauseDepth(&level);
    1:                 if (!level)
    1:                     gJsds->GetBreakpointHook(getter_AddRefs(hook));
    1:             }
    1:             break;
    1:         case JSD_HOOK_THROW:
    1:         {
    1:             hook_rv = JSD_HOOK_RETURN_CONTINUE_THROW;
    1:             gJsds->GetThrowHook(getter_AddRefs(hook));
    1:             if (hook) {
    1:                 JSDValue *jsdv = JSD_GetException (jsdc, jsdthreadstate);
    1:                 js_rv = getter_AddRefs(jsdValue::FromPtr (jsdc, jsdv));
    1:             }
    1:             break;
    1:         }
    1:         default:
    1:             NS_ASSERTION (0, "Unknown hook type.");
    1:     }
    1: 
    1:     if (!hook)
    1:         return hook_rv;
    1:     
    1:     if (!jsds_FilterHook (jsdc, jsdthreadstate))
    1:         return JSD_HOOK_RETURN_CONTINUE;
    1:     
    1:     JSDStackFrameInfo *native_frame = JSD_GetStackFrame (jsdc, jsdthreadstate);
    1:     nsCOMPtr<jsdIStackFrame> frame =
    1:         getter_AddRefs(jsdStackFrame::FromPtr(jsdc, jsdthreadstate,
    1:                                               native_frame));
    1:     gJsds->Pause(nsnull);
    1:     jsdIValue *inout_rv = js_rv;
    1:     NS_IF_ADDREF(inout_rv);
    1:     hook->OnExecute (frame, type, &inout_rv, &hook_rv);
    1:     js_rv = inout_rv;
    1:     NS_IF_RELEASE(inout_rv);
    1:     gJsds->UnPause(nsnull);
    1:     jsdStackFrame::InvalidateAll();
    1:         
    1:     if (hook_rv == JSD_HOOK_RETURN_RET_WITH_VAL ||
    1:         hook_rv == JSD_HOOK_RETURN_THROW_WITH_VAL) {
 2600:         *rval = JSVAL_VOID;
    1:         if (js_rv) {
    1:             JSDValue *jsdv;
 2600:             if (NS_SUCCEEDED(js_rv->GetJSDValue (&jsdv)))
    1:                 *rval = JSD_GetValueWrappedJSVal(jsdc, jsdv);
    1:         }
    1:     }
    1:     
    1:     return hook_rv;
    1: }
    1: 
18907: static void
    1: jsds_ScriptHookProc (JSDContext* jsdc, JSDScript* jsdscript, JSBool creating,
    1:                      void* callerdata)
    1: {
    1: #ifdef CAUTIOUS_SCRIPTHOOK
    1:     JSContext *cx = JSD_GetDefaultJSContext(jsdc);
    1:     JSRuntime *rt = JS_GetRuntime(cx);
    1: #endif
    1: 
28945:     if (creating) {
    1:         nsCOMPtr<jsdIScriptHook> hook;
    1:         gJsds->GetScriptHook(getter_AddRefs(hook));
    1: 
    1:         /* a script is being created */
    1:         if (!hook) {
    1:             /* nobody cares, just exit */
    1:             return;
    1:         }
    1:             
    1:         nsCOMPtr<jsdIScript> script = 
    1:             getter_AddRefs(jsdScript::FromPtr(jsdc, jsdscript));
    1: #ifdef CAUTIOUS_SCRIPTHOOK
    1:         JS_UNKEEP_ATOMS(rt);
    1: #endif
    1:         gJsds->Pause(nsnull);
    1:         hook->OnScriptCreated (script);
    1:         gJsds->UnPause(nsnull);
    1: #ifdef CAUTIOUS_SCRIPTHOOK
    1:         JS_KEEP_ATOMS(rt);
    1: #endif
    1:     } else {
    1:         /* a script is being destroyed.  even if there is no registered hook
    1:          * we'll still need to invalidate the jsdIScript record, in order
    1:          * to remove the reference held in the JSDScript private data. */
    1:         nsCOMPtr<jsdIScript> jsdis = 
 3233:             static_cast<jsdIScript *>(JSD_GetScriptPrivate(jsdscript));
    1:         if (!jsdis)
    1:             return;
    1: 
    1:         jsdis->Invalidate();
28945: 
28945:         if (gGCStatus == JSGC_END) {
28945:             nsCOMPtr<jsdIScriptHook> hook;
28945:             gJsds->GetScriptHook(getter_AddRefs(hook));
    1:             if (!hook)
    1:                 return;
    1: 
    1:             /* if GC *isn't* running, we can tell the user about the script
    1:              * delete now. */
    1: #ifdef CAUTIOUS_SCRIPTHOOK
    1:             JS_UNKEEP_ATOMS(rt);
    1: #endif
    1:                 
    1:             gJsds->Pause(nsnull);
    1:             hook->OnScriptDestroyed (jsdis);
    1:             gJsds->UnPause(nsnull);
    1: #ifdef CAUTIOUS_SCRIPTHOOK
    1:             JS_KEEP_ATOMS(rt);
    1: #endif
    1:         } else {
    1:             /* if a GC *is* running, we've got to wait until it's done before
    1:              * we can execute any JS, so we queue the notification in a PRCList
    1:              * until GC tells us it's done. See jsds_GCCallbackProc(). */
    1:             DeadScript *ds = PR_NEW(DeadScript);
    1:             if (!ds)
    1:                 return; /* NS_ERROR_OUT_OF_MEMORY */
    1:         
    1:             ds->jsdc = jsdc;
    1:             ds->script = jsdis;
    1:             NS_ADDREF(ds->script);
    1:             if (gDeadScripts)
    1:                 /* if the queue exists, add to it */
    1:                 PR_APPEND_LINK(&ds->links, &gDeadScripts->links);
    1:             else {
    1:                 /* otherwise create the queue */
    1:                 PR_INIT_CLIST(&ds->links);
    1:                 gDeadScripts = ds;
    1:             }
    1:         }
    1:     }            
    1: }
    1: 
    1: /*******************************************************************************
    1:  * reflected jsd data structures
    1:  *******************************************************************************/
    1: 
    1: /* Contexts */
    1: /*
12262: NS_IMPL_THREADSAFE_ISUPPORTS2(jsdContext, jsdIContext, jsdIEphemeral);
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::GetJSDContext(JSDContext **_rval)
    1: {
    1:     *_rval = mCx;
    1:     return NS_OK;
    1: }
    1: */
    1: 
    1: /* Objects */
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(jsdObject, jsdIObject)
    1: 
    1: NS_IMETHODIMP
    1: jsdObject::GetJSDContext(JSDContext **_rval)
    1: {
    1:     *_rval = mCx;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdObject::GetJSDObject(JSDObject **_rval)
    1: {
    1:     *_rval = mObject;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23431: jsdObject::GetCreatorURL(nsACString &_rval)
    1: {
23431:     _rval.Assign(JSD_GetObjectNewURL(mCx, mObject));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdObject::GetCreatorLine(PRUint32 *_rval)
    1: {
    1:     *_rval = JSD_GetObjectNewLineNumber(mCx, mObject);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23431: jsdObject::GetConstructorURL(nsACString &_rval)
    1: {
23431:     _rval.Assign(JSD_GetObjectConstructorURL(mCx, mObject));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdObject::GetConstructorLine(PRUint32 *_rval)
    1: {
    1:     *_rval = JSD_GetObjectConstructorLineNumber(mCx, mObject);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdObject::GetValue(jsdIValue **_rval)
    1: {
    1:     JSDValue *jsdv = JSD_GetValueForObject (mCx, mObject);
    1:     
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: /* Properties */
    1: NS_IMPL_THREADSAFE_ISUPPORTS2(jsdProperty, jsdIProperty, jsdIEphemeral)
    1: 
    1: jsdProperty::jsdProperty (JSDContext *aCx, JSDProperty *aProperty) :
    1:     mCx(aCx), mProperty(aProperty)
    1: {
    1:     DEBUG_CREATE ("jsdProperty", gPropertyCount);
    1:     mValid = (aCx && aProperty);
    1:     mLiveListEntry.value = this;
    1:     jsds_InsertEphemeral (&gLiveProperties, &mLiveListEntry);
    1: }
    1: 
    1: jsdProperty::~jsdProperty () 
    1: {
    1:     DEBUG_DESTROY ("jsdProperty", gPropertyCount);
    1:     if (mValid)
    1:         Invalidate();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdProperty::Invalidate()
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     mValid = PR_FALSE;
    1:     jsds_RemoveEphemeral (&gLiveProperties, &mLiveListEntry);
    1:     JSD_DropProperty (mCx, mProperty);
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: jsdProperty::InvalidateAll()
    1: {
    1:     if (gLiveProperties)
    1:         jsds_InvalidateAllEphemerals (&gLiveProperties);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdProperty::GetJSDContext(JSDContext **_rval)
    1: {
    1:     *_rval = mCx;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdProperty::GetJSDProperty(JSDProperty **_rval)
    1: {
    1:     *_rval = mProperty;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdProperty::GetIsValid(PRBool *_rval)
    1: {
    1:     *_rval = mValid;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdProperty::GetAlias(jsdIValue **_rval)
    1: {
    1:     JSDValue *jsdv = JSD_GetPropertyValue (mCx, mProperty);
    1:     
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdProperty::GetFlags(PRUint32 *_rval)
    1: {
    1:     *_rval = JSD_GetPropertyFlags (mCx, mProperty);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdProperty::GetName(jsdIValue **_rval)
    1: {
    1:     JSDValue *jsdv = JSD_GetPropertyName (mCx, mProperty);
    1:     
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdProperty::GetValue(jsdIValue **_rval)
    1: {
    1:     JSDValue *jsdv = JSD_GetPropertyValue (mCx, mProperty);
    1:     
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdProperty::GetVarArgSlot(PRUint32 *_rval)
    1: {
    1:     *_rval = JSD_GetPropertyVarArgSlot (mCx, mProperty);
    1:     return NS_OK;
    1: }
    1: 
    1: /* Scripts */
    1: NS_IMPL_THREADSAFE_ISUPPORTS2(jsdScript, jsdIScript, jsdIEphemeral)
    1: 
58976: static NS_IMETHODIMP
58976: AssignToJSString(nsACString *x, JSString *str)
58976: {
58976:     if (!str) {
58976:         x->SetLength(0);
58976:         return NS_OK;
58976:     }
58976:     size_t length = JS_GetStringEncodingLength(NULL, str);
58976:     if (length == size_t(-1))
58976:         return NS_ERROR_FAILURE;
58976:     x->SetLength(PRUint32(length));
58976:     if (x->Length() != PRUint32(length))
58976:         return NS_ERROR_OUT_OF_MEMORY;
58976:     JS_EncodeStringToBuffer(str, x->BeginWriting(), length);
58976:     return NS_OK;
58976: }
58976: 
    1: jsdScript::jsdScript (JSDContext *aCx, JSDScript *aScript) : mValid(PR_FALSE),
    1:                                                              mTag(0),
    1:                                                              mCx(aCx),
    1:                                                              mScript(aScript),
    1:                                                              mFileName(0), 
    1:                                                              mFunctionName(0),
    1:                                                              mBaseLineNumber(0),
    1:                                                              mLineExtent(0),
    1:                                                              mPPLineMap(0),
56201:                                                              mFirstPC(0)
    1: {
    1:     DEBUG_CREATE ("jsdScript", gScriptCount);
    1: 
    1:     if (mScript) {
    1:         /* copy the script's information now, so we have it later, when it
    1:          * gets destroyed. */
    1:         JSD_LockScriptSubsystem(mCx);
    1:         mFileName = new nsCString(JSD_GetScriptFilename(mCx, mScript));
58976:         mFunctionName = new nsCString();
58976:         if (mFunctionName) {
61691:             JSString *str = JSD_GetScriptFunctionId(mCx, mScript);
58976:             if (str)
58976:                 AssignToJSString(mFunctionName, str);
58976:         }
    1:         mBaseLineNumber = JSD_GetScriptBaseLineNumber(mCx, mScript);
    1:         mLineExtent = JSD_GetScriptLineExtent(mCx, mScript);
    1:         mFirstPC = JSD_GetClosestPC(mCx, mScript, 0);
    1:         JSD_UnlockScriptSubsystem(mCx);
    1:         
    1:         mValid = PR_TRUE;
    1:     }
    1: }
    1: 
    1: jsdScript::~jsdScript () 
    1: {
    1:     DEBUG_DESTROY ("jsdScript", gScriptCount);
    1:     if (mFileName)
    1:         delete mFileName;
    1:     if (mFunctionName)
    1:         delete mFunctionName;
    1: 
    1:     if (mPPLineMap)
    1:         PR_Free(mPPLineMap);
    1: 
    1:     /* Invalidate() needs to be called to release an owning reference to
    1:      * ourselves, so if we got here without being invalidated, something
    1:      * has gone wrong with our ref count. */
    1:     NS_ASSERTION (!mValid, "Script destroyed without being invalidated.");
    1: }
    1: 
    1: /*
    1:  * This method populates a line <-> pc map for a pretty printed version of this
    1:  * script.  It does this by decompiling, and then recompiling the script.  The
    1:  * resulting script is scanned for the line map, and then left as GC fodder.
    1:  */
    1: PCMapEntry *
    1: jsdScript::CreatePPLineMap()
    1: {    
    1:     JSContext  *cx  = JSD_GetDefaultJSContext (mCx);
    1:     JSAutoRequest ar(cx);
    1:     JSObject   *obj = JS_NewObject(cx, NULL, NULL, NULL);
    1:     JSFunction *fun = JSD_GetJSFunction (mCx, mScript);
62384:     JSScript   *script; /* In JSD compartment */
    1:     PRUint32    baseLine;
    1:     PRBool      scriptOwner = PR_FALSE;
62384:     JSString   *jsstr;
62384:     size_t      length;
62384:     const jschar *chars;
    1:     
    1:     if (fun) {
59883:         uintN nargs;
59883: 
62384:         {
59883:             JSAutoEnterCompartment ac;
59883:             if (!ac.enter(cx, JS_GetFunctionObject(fun)))
59883:                 return nsnull;
59883: 
59883:             nargs = JS_GetFunctionArgumentCount(cx, fun);
48470:             if (nargs > 12)
    1:                 return nsnull;
59883:             jsstr = JS_DecompileFunctionBody (cx, fun, 4);
    1:             if (!jsstr)
    1:                 return nsnull;
62384: 
62384:             if (!(chars = JS_GetStringCharsAndLength(cx, jsstr, &length)))
59889:                 return nsnull;
62384:         }
62384: 
62384:         JS::Anchor<JSString *> kungFuDeathGrip(jsstr);
    1:         const char *argnames[] = {"arg1", "arg2", "arg3", "arg4", 
    1:                                   "arg5", "arg6", "arg7", "arg8",
    1:                                   "arg9", "arg10", "arg11", "arg12" };
59889:         fun = JS_CompileUCFunction (cx, obj, "ppfun", nargs, argnames, chars,
59889:                                     length, "x-jsd:ppbuffer?type=function", 3);
    1:         if (!fun || !(script = JS_GetFunctionScript(cx, fun)))
    1:             return nsnull;
    1:         baseLine = 3;
    1:     } else {
59883:         script = JSD_GetJSScript(mCx, mScript);
62384:         JSString *jsstr;
62384: 
62384:         {
59883:             JSAutoEnterCompartment ac;
59883:             if (!ac.enter(cx, script))
59883:                 return nsnull;
59883: 
62384:             jsstr = JS_DecompileScript (cx, JSD_GetJSScript(mCx, mScript), "ppscript", 4);
    1:             if (!jsstr)
    1:                 return nsnull;
62384: 
62384:             if (!(chars = JS_GetStringCharsAndLength(cx, jsstr, &length)))
59889:                 return nsnull;
62384:         }
62384: 
62384:         JS::Anchor<JSString *> kungFuDeathGrip(jsstr);
62384:         script = JS_CompileUCScript (cx, obj, chars, length, "x-jsd:ppbuffer?type=script", 1);
    1:         if (!script)
    1:             return nsnull;
    1:         scriptOwner = PR_TRUE;
    1:         baseLine = 1;
    1:     }
    1: 
    1:     PRUint32 scriptExtent = JS_GetScriptLineExtent (cx, script);
    1:     jsbytecode* firstPC = JS_LineNumberToPC (cx, script, 0);
    1:     /* allocate worst case size of map (number of lines in script + 1
    1:      * for our 0 record), we'll shrink it with a realloc later. */
23295:     PCMapEntry *lineMap =
 3233:         static_cast<PCMapEntry *>
 3233:                    (PR_Malloc((scriptExtent + 1) * sizeof (PCMapEntry)));
23375:     PRUint32 lineMapSize = 0;
23375: 
23295:     if (lineMap) {
    1:         for (PRUint32 line = baseLine; line < scriptExtent + baseLine; ++line) {
    1:             jsbytecode* pc = JS_LineNumberToPC (cx, script, line);
    1:             if (line == JS_PCToLineNumber (cx, script, pc)) {
23375:                 lineMap[lineMapSize].line = line;
23375:                 lineMap[lineMapSize].pc = pc - firstPC;
23375:                 ++lineMapSize;
23375:             }
23375:         }
23375:         if (scriptExtent != lineMapSize) {
23295:             lineMap =
 3233:                 static_cast<PCMapEntry *>
23295:                            (PR_Realloc(mPPLineMap = lineMap,
23375:                                        lineMapSize * sizeof(PCMapEntry)));
23375:             if (!lineMap) {
23295:                 PR_Free(mPPLineMap);
23375:                 lineMapSize = 0;
23375:             }
    1:         }
    1:     }
    1: 
    1:     if (scriptOwner)
    1:         JS_DestroyScript (cx, script);
    1: 
23375:     mPCMapSize = lineMapSize;
23295:     return mPPLineMap = lineMap;
    1: }
    1: 
    1: PRUint32
    1: jsdScript::PPPcToLine (PRUint32 aPC)
    1: {
    1:     if (!mPPLineMap && !CreatePPLineMap())
    1:         return 0;
    1:     PRUint32 i;
    1:     for (i = 1; i < mPCMapSize; ++i) {
    1:         if (mPPLineMap[i].pc > aPC)
    1:             return mPPLineMap[i - 1].line;            
    1:     }
    1: 
    1:     return mPPLineMap[mPCMapSize - 1].line;
    1: }
    1: 
    1: PRUint32
    1: jsdScript::PPLineToPc (PRUint32 aLine)
    1: {
    1:     if (!mPPLineMap && !CreatePPLineMap())
    1:         return 0;
    1:     PRUint32 i;
    1:     for (i = 1; i < mPCMapSize; ++i) {
    1:         if (mPPLineMap[i].line > aLine)
    1:             return mPPLineMap[i - 1].pc;
    1:     }
    1: 
    1:     return mPPLineMap[mPCMapSize - 1].pc;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetJSDContext(JSDContext **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = mCx;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetJSDScript(JSDScript **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = mScript;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetVersion (PRInt32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSContext *cx = JSD_GetDefaultJSContext (mCx);
    1:     JSScript *script = JSD_GetJSScript(mCx, mScript);
62384:     JSAutoEnterCompartment ac;
62384:     if (!ac.enter(cx, script))
62384:         return NS_ERROR_FAILURE;
 3233:     *_rval = static_cast<PRInt32>(JS_GetScriptVersion(cx, script));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetTag(PRUint32 *_rval)
    1: {
    1:     if (!mTag)
    1:         mTag = ++jsdScript::LastTag;
    1:     
    1:     *_rval = mTag;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::Invalidate()
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     mValid = PR_FALSE;
    1:     
    1:     /* release the addref we do in FromPtr */
 3233:     jsdIScript *script = static_cast<jsdIScript *>
 3233:                                     (JSD_GetScriptPrivate(mScript));
    1:     NS_ASSERTION (script == this, "That's not my script!");
    1:     NS_RELEASE(script);
    1:     JSD_SetScriptPrivate(mScript, NULL);
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: jsdScript::InvalidateAll ()
    1: {
    1:     JSDContext *cx;
 2600:     if (NS_FAILED(gJsds->GetJSDContext (&cx)))
 2600:         return;
 2600: 
    1:     JSDScript *script;
    1:     JSDScript *iter = NULL;
    1:     
    1:     JSD_LockScriptSubsystem(cx);
    1:     while((script = JSD_IterateScripts(cx, &iter)) != NULL) {
    1:         nsCOMPtr<jsdIScript> jsdis = 
 3233:             static_cast<jsdIScript *>(JSD_GetScriptPrivate(script));
    1:         if (jsdis)
    1:             jsdis->Invalidate();
    1:     }
    1:     JSD_UnlockScriptSubsystem(cx);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetIsValid(PRBool *_rval)
    1: {
    1:     *_rval = mValid;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::SetFlags(PRUint32 flags)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSD_SetScriptFlags(mCx, mScript, flags);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetFlags(PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetScriptFlags(mCx, mScript);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23431: jsdScript::GetFileName(nsACString &_rval)
    1: {
23431:     _rval.Assign(*mFileName);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23431: jsdScript::GetFunctionName(nsACString &_rval)
    1: {
23431:     _rval.Assign(*mFunctionName);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
34186: jsdScript::GetParameterNames(PRUint32* count, PRUnichar*** paramNames)
34186: {
34186:     ASSERT_VALID_EPHEMERAL;
34186:     JSContext *cx = JSD_GetDefaultJSContext (mCx);
34186:     if (!cx) {
34186:         NS_WARNING("No default context !?");
34186:         return NS_ERROR_FAILURE;
34186:     }
34186:     JSFunction *fun = JSD_GetJSFunction (mCx, mScript);
62406:     if (!fun) {
62406:         *count = 0;
62406:         *paramNames = nsnull;
62406:         return NS_OK;
62406:     }
34186: 
34186:     JSAutoRequest ar(cx);
62384:     JSAutoEnterCompartment ac;
62384:     if (!ac.enter(cx, JS_GetFunctionObject(fun)))
62384:         return NS_ERROR_FAILURE;
34186: 
50495:     uintN nargs;
62406:     if (!JS_FunctionHasLocalNames(cx, fun) ||
50495:         (nargs = JS_GetFunctionArgumentCount(cx, fun)) == 0) {
34186:         *count = 0;
34186:         *paramNames = nsnull;
34186:         return NS_OK;
34186:     }
34186: 
34186:     PRUnichar **ret =
48470:         static_cast<PRUnichar**>(NS_Alloc(nargs * sizeof(PRUnichar*)));
34186:     if (!ret)
34186:         return NS_ERROR_OUT_OF_MEMORY;
34186: 
48470:     void *mark;
48470:     jsuword *names = JS_GetFunctionLocalNameArray(cx, fun, &mark);
34186:     if (!names) {
34186:         NS_Free(ret);
34186:         return NS_ERROR_OUT_OF_MEMORY;
34186:     }
34186: 
34186:     nsresult rv = NS_OK;
48470:     for (uintN i = 0; i < nargs; ++i) {
48470:         JSAtom *atom = JS_LocalNameToAtom(names[i]);
34186:         if (!atom) {
34186:             ret[i] = 0;
34186:         } else {
48470:             JSString *str = JS_AtomKey(atom);
59889:             ret[i] = NS_strndup(JS_GetInternedStringChars(str), JS_GetStringLength(str));
34186:             if (!ret[i]) {
34186:                 NS_FREE_XPCOM_ALLOCATED_POINTER_ARRAY(i, ret);
34186:                 rv = NS_ERROR_OUT_OF_MEMORY;
34186:                 break;
34186:             }
34186:         }
34186:     }
48470:     JS_ReleaseFunctionLocalNameArray(cx, mark);
34186:     if (NS_FAILED(rv))
34186:         return rv;
48470:     *count = nargs;
34186:     *paramNames = ret;
34186:     return NS_OK;
34186: }
34186: 
34186: NS_IMETHODIMP
    1: jsdScript::GetFunctionObject(jsdIValue **_rval)
    1: {
    1:     JSFunction *fun = JSD_GetJSFunction(mCx, mScript);
    1:     if (!fun)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1:     
    1:     JSObject *obj = JS_GetFunctionObject(fun);
    1:     if (!obj)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     JSDContext *cx;
 2600:     if (NS_FAILED(gJsds->GetJSDContext (&cx)))
 2600:         return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:     JSDValue *jsdv = JSD_NewValue(cx, OBJECT_TO_JSVAL(obj));
    1:     if (!jsdv)
 2600:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     *_rval = jsdValue::FromPtr(cx, jsdv);
    1:     if (!*_rval) {
    1:         JSD_DropValue(cx, jsdv);
 2600:         return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetFunctionSource(nsAString & aFunctionSource)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSContext *cx = JSD_GetDefaultJSContext (mCx);
    1:     if (!cx) {
    1:         NS_WARNING("No default context !?");
    1:         return NS_ERROR_FAILURE;
    1:     }
    1:     JSFunction *fun = JSD_GetJSFunction (mCx, mScript);
    1: 
    1:     JSAutoRequest ar(cx);
    1: 
    1:     JSString *jsstr;
59883:     JSAutoEnterCompartment ac;
56852:     if (fun) {
56852:         if (!ac.enter(cx, JS_GetFunctionObject(fun)))
56852:             return NS_ERROR_FAILURE;
    1:         jsstr = JS_DecompileFunction (cx, fun, 4);
56852:     } else {
    1:         JSScript *script = JSD_GetJSScript (mCx, mScript);
59883:         if (!ac.enter(cx, script))
59883:             return NS_ERROR_FAILURE;
    1:         jsstr = JS_DecompileScript (cx, script, "ppscript", 4);
    1:     }
    1:     if (!jsstr)
    1:         return NS_ERROR_FAILURE;
    1: 
59889:     size_t length;
59889:     const jschar *chars = JS_GetStringCharsZAndLength(cx, jsstr, &length);
59889:     if (!chars)
59889:         return NS_ERROR_FAILURE;
59889: 
59889:     aFunctionSource = nsDependentString(chars, length);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetBaseLineNumber(PRUint32 *_rval)
    1: {
    1:     *_rval = mBaseLineNumber;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetLineExtent(PRUint32 *_rval)
    1: {
    1:     *_rval = mLineExtent;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetCallCount(PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetScriptCallCount (mCx, mScript);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetMaxRecurseDepth(PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetScriptMaxRecurseDepth (mCx, mScript);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetMinExecutionTime(double *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetScriptMinExecutionTime (mCx, mScript);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetMaxExecutionTime(double *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetScriptMaxExecutionTime (mCx, mScript);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetTotalExecutionTime(double *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetScriptTotalExecutionTime (mCx, mScript);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetMinOwnExecutionTime(double *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetScriptMinOwnExecutionTime (mCx, mScript);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetMaxOwnExecutionTime(double *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetScriptMaxOwnExecutionTime (mCx, mScript);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::GetTotalOwnExecutionTime(double *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetScriptTotalOwnExecutionTime (mCx, mScript);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::ClearProfileData()
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSD_ClearScriptProfileData(mCx, mScript);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::PcToLine(PRUint32 aPC, PRUint32 aPcmap, PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     if (aPcmap == PCMAP_SOURCETEXT) {
    1:         *_rval = JSD_GetClosestLine (mCx, mScript, mFirstPC + aPC);
    1:     } else if (aPcmap == PCMAP_PRETTYPRINT) {
    1:         *_rval = PPPcToLine(aPC);
    1:     } else {
    1:         return NS_ERROR_INVALID_ARG;
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::LineToPc(PRUint32 aLine, PRUint32 aPcmap, PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     if (aPcmap == PCMAP_SOURCETEXT) {
    1:         jsuword pc = JSD_GetClosestPC (mCx, mScript, aLine);
    1:         *_rval = pc - mFirstPC;
    1:     } else if (aPcmap == PCMAP_PRETTYPRINT) {
    1:         *_rval = PPLineToPc(aLine);
    1:     } else {
    1:         return NS_ERROR_INVALID_ARG;
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
59882: jsdScript::EnableSingleStepInterrupts(PRBool enable)
59882: {
59882:     ASSERT_VALID_EPHEMERAL;
59882: 
59882:     /* Must have set interrupt hook before enabling */
59882:     if (enable && !jsdService::GetService()->CheckInterruptHook())
59882:         return NS_ERROR_NOT_INITIALIZED;
59882: 
62071:     return (JSD_EnableSingleStepInterrupts(mCx, mScript, enable) ? NS_OK : NS_ERROR_FAILURE);
59882: }
59882: 
59882: NS_IMETHODIMP
    1: jsdScript::IsLineExecutable(PRUint32 aLine, PRUint32 aPcmap, PRBool *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     if (aPcmap == PCMAP_SOURCETEXT) {    
    1:         jsuword pc = JSD_GetClosestPC (mCx, mScript, aLine);
    1:         *_rval = (aLine == JSD_GetClosestLine (mCx, mScript, pc));
    1:     } else if (aPcmap == PCMAP_PRETTYPRINT) {
    1:         if (!mPPLineMap && !CreatePPLineMap())
23295:             return NS_ERROR_OUT_OF_MEMORY;
    1:         *_rval = PR_FALSE;
    1:         for (PRUint32 i = 0; i < mPCMapSize; ++i) {
    1:             if (mPPLineMap[i].line >= aLine) {
    1:                 *_rval = (mPPLineMap[i].line == aLine);
    1:                 break;
    1:             }
    1:         }
    1:     } else {
    1:         return NS_ERROR_INVALID_ARG;
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::SetBreakpoint(PRUint32 aPC)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     jsuword pc = mFirstPC + aPC;
48470:     JSD_SetExecutionHook (mCx, mScript, pc, jsds_ExecutionHookProc, NULL);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::ClearBreakpoint(PRUint32 aPC)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;    
    1:     jsuword pc = mFirstPC + aPC;
    1:     JSD_ClearExecutionHook (mCx, mScript, pc);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdScript::ClearAllBreakpoints()
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSD_LockScriptSubsystem(mCx);
    1:     JSD_ClearAllExecutionHooksForScript (mCx, mScript);
    1:     JSD_UnlockScriptSubsystem(mCx);
    1:     return NS_OK;
    1: }
    1: 
    1: /* Contexts */
    1: NS_IMPL_THREADSAFE_ISUPPORTS2(jsdContext, jsdIContext, jsdIEphemeral)
    1: 
    1: jsdIContext *
    1: jsdContext::FromPtr (JSDContext *aJSDCx, JSContext *aJSCx)
    1: {
23288:     if (!aJSDCx || !aJSCx)
    1:         return nsnull;
    1: 
    1:     nsCOMPtr<jsdIContext> jsdicx;
    1:     nsCOMPtr<jsdIEphemeral> eph = 
 3233:         jsds_FindEphemeral (&gLiveContexts, static_cast<void *>(aJSCx));
    1:     if (eph)
    1:     {
    1:         jsdicx = do_QueryInterface(eph);
    1:     }
    1:     else
    1:     {
23288:         nsCOMPtr<nsISupports> iscx;
23288:         if (JS_GetOptions(aJSCx) & JSOPTION_PRIVATE_IS_NSISUPPORTS)
23288:             iscx = static_cast<nsISupports *>(JS_GetContextPrivate(aJSCx));
    1:         jsdicx = new jsdContext (aJSDCx, aJSCx, iscx);
    1:     }
    1: 
23288:     jsdIContext *ctx = nsnull;
23288:     jsdicx.swap(ctx);
23288:     return ctx;
    1: }
    1: 
    1: jsdContext::jsdContext (JSDContext *aJSDCx, JSContext *aJSCx,
    1:                         nsISupports *aISCx) : mValid(PR_TRUE), mTag(0),
    1:                                               mJSDCx(aJSDCx),
    1:                                               mJSCx(aJSCx), mISCx(aISCx)
    1: {
    1:     DEBUG_CREATE ("jsdContext", gContextCount);
    1:     mLiveListEntry.value = this;
 3233:     mLiveListEntry.key   = static_cast<void *>(aJSCx);
    1:     jsds_InsertEphemeral (&gLiveContexts, &mLiveListEntry);
    1: }
    1: 
    1: jsdContext::~jsdContext() 
    1: {
    1:     DEBUG_DESTROY ("jsdContext", gContextCount);
    1:     if (mValid)
    1:     {
    1:         /* call Invalidate() to take ourselves out of the live list */
    1:         Invalidate();
    1:     }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::GetIsValid(PRBool *_rval)
    1: {
    1:     *_rval = mValid;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::Invalidate()
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     mValid = PR_FALSE;
    1:     jsds_RemoveEphemeral (&gLiveContexts, &mLiveListEntry);
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: jsdContext::InvalidateAll()
    1: {
    1:     if (gLiveContexts)
    1:         jsds_InvalidateAllEphemerals (&gLiveContexts);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::GetJSContext(JSContext **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = mJSCx;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::GetOptions(PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JS_GetOptions(mJSCx);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::SetOptions(PRUint32 options)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     PRUint32 lastOptions = JS_GetOptions(mJSCx);
    1: 
    1:     /* don't let users change this option, they'd just be shooting themselves
    1:      * in the foot. */
    1:     if ((options ^ lastOptions) & JSOPTION_PRIVATE_IS_NSISUPPORTS)
    1:         return NS_ERROR_ILLEGAL_VALUE;
    1: 
    1:     JS_SetOptions(mJSCx, options);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::GetPrivateData(nsISupports **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     PRUint32 options = JS_GetOptions(mJSCx);
    1:     if (options & JSOPTION_PRIVATE_IS_NSISUPPORTS)
    1:     {
 3233:         *_rval = static_cast<nsISupports*>(JS_GetContextPrivate(mJSCx));
    1:         NS_IF_ADDREF(*_rval);
    1:     }
    1:     else
    1:     {
    1:         *_rval = nsnull;
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1:         
    1: NS_IMETHODIMP
    1: jsdContext::GetWrappedContext(nsISupports **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
23288:     NS_IF_ADDREF(*_rval = mISCx);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::GetTag(PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     if (!mTag)
    1:         mTag = ++jsdContext::LastTag;
    1:     
    1:     *_rval = mTag;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::GetVersion (PRInt32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
 3233:     *_rval = static_cast<PRInt32>(JS_GetVersion(mJSCx));
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::SetVersion (PRInt32 id)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
 3233:     JSVersion ver = static_cast<JSVersion>(id);
    1:     JS_SetVersion(mJSCx, ver);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::GetGlobalObject (jsdIValue **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSObject *glob = JS_GetGlobalObject(mJSCx);
    1:     JSDValue *jsdv = JSD_NewValue (mJSDCx, OBJECT_TO_JSVAL(glob));
    1:     if (!jsdv)
    1:         return NS_ERROR_FAILURE;
    1:     *_rval = jsdValue::FromPtr (mJSDCx, jsdv);
    1:     if (!*_rval)
    1:         return NS_ERROR_FAILURE;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::GetScriptsEnabled (PRBool *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
23288:     if (!mISCx) {
23288:         *_rval = PR_TRUE;
23288:         return NS_OK;
23288:     }
23288: 
    1:     nsCOMPtr<nsIScriptContext> context = do_QueryInterface(mISCx);
    1:     if (!context)
    1:         return NS_ERROR_NO_INTERFACE;
    1: 
    1:     *_rval = context->GetScriptsEnabled();
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdContext::SetScriptsEnabled (PRBool _rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
23288:     if (!mISCx) {
23288:         if (_rval)
23288:             return NS_OK;
23288:         return NS_ERROR_NO_INTERFACE;
23288:     }
23288: 
    1:     nsCOMPtr<nsIScriptContext> context = do_QueryInterface(mISCx);
    1:     if (!context)
    1:         return NS_ERROR_NO_INTERFACE;
    1: 
    1:     context->SetScriptsEnabled(_rval, PR_TRUE);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: /* Stack Frames */
    1: NS_IMPL_THREADSAFE_ISUPPORTS2(jsdStackFrame, jsdIStackFrame, jsdIEphemeral)
    1: 
    1: jsdStackFrame::jsdStackFrame (JSDContext *aCx, JSDThreadState *aThreadState,
    1:                               JSDStackFrameInfo *aStackFrameInfo) :
    1:     mCx(aCx), mThreadState(aThreadState), mStackFrameInfo(aStackFrameInfo)
    1: {
    1:     DEBUG_CREATE ("jsdStackFrame", gFrameCount);
    1:     mValid = (aCx && aThreadState && aStackFrameInfo);
    1:     if (mValid) {
    1:         mLiveListEntry.key = aStackFrameInfo;
    1:         mLiveListEntry.value = this;
    1:         jsds_InsertEphemeral (&gLiveStackFrames, &mLiveListEntry);
    1:     }
    1: }
    1: 
    1: jsdStackFrame::~jsdStackFrame() 
    1: {
    1:     DEBUG_DESTROY ("jsdStackFrame", gFrameCount);
    1:     if (mValid)
    1:     {
    1:         /* call Invalidate() to take ourselves out of the live list */
    1:         Invalidate();
    1:     }
    1: }
    1: 
    1: jsdIStackFrame *
    1: jsdStackFrame::FromPtr (JSDContext *aCx, JSDThreadState *aThreadState,
    1:                         JSDStackFrameInfo *aStackFrameInfo)
    1: {
    1:     if (!aStackFrameInfo)
    1:         return nsnull;
    1: 
    1:     jsdIStackFrame *rv;
    1:     nsCOMPtr<jsdIStackFrame> frame;
    1: 
    1:     nsCOMPtr<jsdIEphemeral> eph =
    1:         jsds_FindEphemeral (&gLiveStackFrames,
 3233:                             reinterpret_cast<void *>(aStackFrameInfo));
    1: 
    1:     if (eph)
    1:     {
    1:         frame = do_QueryInterface(eph);
    1:         rv = frame;
    1:     }
    1:     else
    1:     {
    1:         rv = new jsdStackFrame (aCx, aThreadState, aStackFrameInfo);
    1:     }
    1: 
    1:     NS_IF_ADDREF(rv);
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::Invalidate()
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     mValid = PR_FALSE;
    1:     jsds_RemoveEphemeral (&gLiveStackFrames, &mLiveListEntry);
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: jsdStackFrame::InvalidateAll()
    1: {
    1:     if (gLiveStackFrames)
    1:         jsds_InvalidateAllEphemerals (&gLiveStackFrames);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetJSDContext(JSDContext **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = mCx;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetJSDThreadState(JSDThreadState **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = mThreadState;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetJSDStackFrameInfo(JSDStackFrameInfo **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = mStackFrameInfo;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetIsValid(PRBool *_rval)
    1: {
    1:     *_rval = mValid;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetCallingFrame(jsdIStackFrame **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDStackFrameInfo *sfi = JSD_GetCallingStackFrame (mCx, mThreadState,
    1:                                                        mStackFrameInfo);
    1:     *_rval = jsdStackFrame::FromPtr (mCx, mThreadState, sfi);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetExecutionContext(jsdIContext **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSContext *cx = JSD_GetJSContext (mCx, mThreadState);
    1:     *_rval = jsdContext::FromPtr (mCx, cx);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23431: jsdStackFrame::GetFunctionName(nsACString &_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
61691:     JSString *str = JSD_GetIdForStackFrame(mCx, mThreadState, mStackFrameInfo);
58976:     if (str)
58976:         return AssignToJSString(&_rval, str);
58976:     
58976:     _rval.Assign("anonymous");
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetIsDebugger(PRBool *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_IsStackFrameDebugger (mCx, mThreadState, mStackFrameInfo);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetIsConstructing(PRBool *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_IsStackFrameConstructing (mCx, mThreadState, mStackFrameInfo);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetScript(jsdIScript **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDScript *script = JSD_GetScriptForStackFrame (mCx, mThreadState,
    1:                                                     mStackFrameInfo);
    1:     *_rval = jsdScript::FromPtr (mCx, script);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetPc(PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDScript *script = JSD_GetScriptForStackFrame (mCx, mThreadState,
    1:                                                     mStackFrameInfo);
    1:     if (!script)
    1:         return NS_ERROR_FAILURE;
    1:     jsuword pcbase = JSD_GetClosestPC(mCx, script, 0);
    1:     
    1:     jsuword pc = JSD_GetPCForStackFrame (mCx, mThreadState, mStackFrameInfo);
    1:     if (pc)
    1:         *_rval = pc - pcbase;
    1:     else
    1:         *_rval = pcbase;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetLine(PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDScript *script = JSD_GetScriptForStackFrame (mCx, mThreadState,
    1:                                                     mStackFrameInfo);
    1:     if (script) {
    1:         jsuword pc = JSD_GetPCForStackFrame (mCx, mThreadState, mStackFrameInfo);
    1:         *_rval = JSD_GetClosestLine (mCx, script, pc);
    1:     } else {
    1:         return NS_ERROR_FAILURE;
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetCallee(jsdIValue **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDValue *jsdv = JSD_GetCallObjectForStackFrame (mCx, mThreadState,
    1:                                                      mStackFrameInfo);
    1:     
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetScope(jsdIValue **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDValue *jsdv = JSD_GetScopeChainForStackFrame (mCx, mThreadState,
    1:                                                      mStackFrameInfo);
    1:     
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdStackFrame::GetThisValue(jsdIValue **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDValue *jsdv = JSD_GetThisForStackFrame (mCx, mThreadState,
    1:                                                mStackFrameInfo);
    1:     
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
23431: jsdStackFrame::Eval (const nsAString &bytes, const nsACString &fileName,
    1:                      PRUint32 line, jsdIValue **result, PRBool *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1: 
    1:     if (bytes.IsEmpty())
    1:         return NS_ERROR_INVALID_ARG;
    1: 
    1:     // get pointer to buffer contained in |bytes|
    1:     nsAString::const_iterator h;
    1:     bytes.BeginReading(h);
 3233:     const jschar *char_bytes = reinterpret_cast<const jschar *>(h.get());
    1: 
    1:     JSExceptionState *estate = 0;
    1:     jsval jv;
    1: 
    1:     JSContext *cx = JSD_GetJSContext (mCx, mThreadState);
    1: 
    1:     JSAutoRequest ar(cx);
    1: 
    1:     estate = JS_SaveExceptionState (cx);
    1:     JS_ClearPendingException (cx);
    1: 
39321:     nsresult rv;
39321:     nsCOMPtr<nsIJSContextStack> stack = do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv);
41112:     if (NS_SUCCEEDED(rv))
41112:         rv = stack->Push(cx);
41112:     if (NS_FAILED(rv)) {
41112:         JS_RestoreExceptionState (cx, estate);
39321:         return rv;
41112:     }
39321: 
    1:     *_rval = JSD_AttemptUCScriptInStackFrame (mCx, mThreadState,
    1:                                               mStackFrameInfo,
    1:                                               char_bytes, bytes.Length(),
23431:                                               PromiseFlatCString(fileName).get(),
23431:                                               line, &jv);
    1:     if (!*_rval) {
    1:         if (JS_IsExceptionPending(cx))
    1:             JS_GetPendingException (cx, &jv);
    1:         else
48470:             jv = JSVAL_NULL;
    1:     }
    1: 
    1:     JS_RestoreExceptionState (cx, estate);
    1: 
39321: #ifdef DEBUG
39321:     JSContext* poppedCX;
39321:     rv = stack->Pop(&poppedCX);
39321:     NS_ASSERTION(NS_SUCCEEDED(rv) && poppedCX == cx, "bad pop");
39321: #else
39321:     (void) stack->Pop(nsnull);
39321: #endif
39321: 
    1:     JSDValue *jsdv = JSD_NewValue (mCx, jv);
    1:     if (!jsdv)
    1:         return NS_ERROR_FAILURE;
    1:     *result = jsdValue::FromPtr (mCx, jsdv);
    1:     if (!*result)
    1:         return NS_ERROR_FAILURE;
    1:     
    1:     return NS_OK;
    1: }        
    1: 
    1: /* Values */
    1: NS_IMPL_THREADSAFE_ISUPPORTS2(jsdValue, jsdIValue, jsdIEphemeral)
    1: jsdIValue *
    1: jsdValue::FromPtr (JSDContext *aCx, JSDValue *aValue)
    1: {
    1:     /* value will be dropped by te jsdValue destructor. */
    1: 
    1:     if (!aValue)
    1:         return nsnull;
    1:     
    1:     jsdIValue *rv = new jsdValue (aCx, aValue);
    1:     NS_IF_ADDREF(rv);
    1:     return rv;
    1: }
    1: 
    1: jsdValue::jsdValue (JSDContext *aCx, JSDValue *aValue) : mValid(PR_TRUE),
    1:                                                          mCx(aCx), 
    1:                                                          mValue(aValue)
    1: {
    1:     DEBUG_CREATE ("jsdValue", gValueCount);
    1:     mLiveListEntry.value = this;
    1:     jsds_InsertEphemeral (&gLiveValues, &mLiveListEntry);
    1: }
    1: 
    1: jsdValue::~jsdValue() 
    1: {
    1:     DEBUG_DESTROY ("jsdValue", gValueCount);
    1:     if (mValid)
    1:         /* call Invalidate() to take ourselves out of the live list */
    1:         Invalidate();
    1: }   
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetIsValid(PRBool *_rval)
    1: {
    1:     *_rval = mValid;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::Invalidate()
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     mValid = PR_FALSE;
    1:     jsds_RemoveEphemeral (&gLiveValues, &mLiveListEntry);
    1:     JSD_DropValue (mCx, mValue);
    1:     return NS_OK;
    1: }
    1: 
    1: void
    1: jsdValue::InvalidateAll()
    1: {
    1:     if (gLiveValues)
    1:         jsds_InvalidateAllEphemerals (&gLiveValues);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetJSDContext(JSDContext **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = mCx;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetJSDValue (JSDValue **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = mValue;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetIsNative (PRBool *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_IsValueNative (mCx, mValue);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetIsNumber (PRBool *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_IsValueNumber (mCx, mValue);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetIsPrimitive (PRBool *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_IsValuePrimitive (mCx, mValue);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetJsType (PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     jsval val;
    1: 
    1:     val = JSD_GetValueWrappedJSVal (mCx, mValue);
    1:     
    1:     if (JSVAL_IS_NULL(val))
    1:         *_rval = TYPE_NULL;
    1:     else if (JSVAL_IS_BOOLEAN(val))
    1:         *_rval = TYPE_BOOLEAN;
    1:     else if (JSVAL_IS_DOUBLE(val))
    1:         *_rval = TYPE_DOUBLE;
    1:     else if (JSVAL_IS_INT(val))
    1:         *_rval = TYPE_INT;
    1:     else if (JSVAL_IS_STRING(val))
    1:         *_rval = TYPE_STRING;
    1:     else if (JSVAL_IS_VOID(val))
    1:         *_rval = TYPE_VOID;
    1:     else if (JSD_IsValueFunction (mCx, mValue))
    1:         *_rval = TYPE_FUNCTION;
    1:     else if (JSVAL_IS_OBJECT(val))
    1:         *_rval = TYPE_OBJECT;
    1:     else
    1:         NS_ASSERTION (0, "Value has no discernible type.");
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetJsPrototype (jsdIValue **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDValue *jsdv = JSD_GetValuePrototype (mCx, mValue);
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetJsParent (jsdIValue **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDValue *jsdv = JSD_GetValueParent (mCx, mValue);
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23431: jsdValue::GetJsClassName(nsACString &_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
23431:     _rval.Assign(JSD_GetValueClassName(mCx, mValue));
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetJsConstructor (jsdIValue **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDValue *jsdv = JSD_GetValueConstructor (mCx, mValue);
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23431: jsdValue::GetJsFunctionName(nsACString &_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
61691:     return AssignToJSString(&_rval, JSD_GetValueFunctionId(mCx, mValue));
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetBooleanValue(PRBool *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetValueBoolean (mCx, mValue);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetDoubleValue(double *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
48470:     *_rval = JSD_GetValueDouble (mCx, mValue);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetIntValue(PRInt32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *_rval = JSD_GetValueInt (mCx, mValue);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetObjectValue(jsdIObject **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSDObject *obj;
    1:     obj = JSD_GetObjectForValue (mCx, mValue);
    1:     *_rval = jsdObject::FromPtr (mCx, obj);
    1:     if (!*_rval)
    1:         return NS_ERROR_FAILURE;
    1:     return NS_OK;
    1: }
    1:     
    1: NS_IMETHODIMP
23431: jsdValue::GetStringValue(nsACString &_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
59889:     JSContext *cx = JSD_GetDefaultJSContext (mCx);
59889:     if (!cx) {
59889:         NS_WARNING("No default context !?");
59889:         return NS_ERROR_FAILURE;
59889:     }
    1:     JSString *jstr_val = JSD_GetValueString(mCx, mValue);
    1:     if (jstr_val) {
59889:         size_t length;
59889:         const jschar *chars = JS_GetStringCharsZAndLength(cx, jstr_val, &length);
59889:         if (!chars)
59889:             return NS_ERROR_FAILURE;
59889:         nsDependentString depStr(chars, length);
59889:         CopyUTF16toUTF8(depStr, _rval);
    1:     } else {
23431:         _rval.Truncate();
    1:     }
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetPropertyCount (PRInt32 *_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     if (JSD_IsValueObject(mCx, mValue))
    1:         *_rval = JSD_GetCountOfProperties (mCx, mValue);
    1:     else
    1:         *_rval = -1;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetProperties (jsdIProperty ***propArray, PRUint32 *length)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     *propArray = nsnull;
    1:     if (length)
    1:         *length = 0;
    1: 
    1:     PRUint32 prop_count = JSD_IsValueObject(mCx, mValue)
    1:         ? JSD_GetCountOfProperties (mCx, mValue)
    1:         : 0;
    1:     NS_ENSURE_TRUE(prop_count, NS_OK);
    1: 
    1:     jsdIProperty **pa_temp =
 3233:         static_cast<jsdIProperty **>
 3233:                    (nsMemory::Alloc(sizeof (jsdIProperty *) * 
    1:                                        prop_count));
    1:     NS_ENSURE_TRUE(pa_temp, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     PRUint32     i    = 0;
    1:     JSDProperty *iter = NULL;
    1:     JSDProperty *prop;
    1:     while ((prop = JSD_IterateProperties (mCx, mValue, &iter))) {
    1:         pa_temp[i] = jsdProperty::FromPtr (mCx, prop);
    1:         ++i;
    1:     }
    1:     
    1:     NS_ASSERTION (prop_count == i, "property count mismatch");    
    1: 
    1:     /* if caller doesn't care about length, don't bother telling them */
    1:     *propArray = pa_temp;
    1:     if (length)
    1:         *length = prop_count;
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23431: jsdValue::GetProperty (const nsACString &name, jsdIProperty **_rval)
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSContext *cx = JSD_GetDefaultJSContext (mCx);
    1: 
    1:     JSAutoRequest ar(cx);
    1: 
    1:     /* not rooting this */
23431:     JSString *jstr_name = JS_NewStringCopyZ(cx, PromiseFlatCString(name).get());
    1:     if (!jstr_name)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     JSDProperty *prop = JSD_GetValueProperty (mCx, mValue, jstr_name);
    1:     
    1:     *_rval = jsdProperty::FromPtr (mCx, prop);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::Refresh()
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     JSD_RefreshValue (mCx, mValue);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdValue::GetWrappedValue()
    1: {
    1:     ASSERT_VALID_EPHEMERAL;
    1:     nsresult rv;
 3002:     nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID(), &rv);
 3002:     if (NS_FAILED(rv))
 3002:         return rv;
 3002: 
10286:     nsAXPCNativeCallContext *cc = nsnull;
10286:     rv = xpc->GetCurrentNativeCallContext(&cc);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     jsval *result;
    1:     rv = cc->GetRetValPtr(&result);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     if (result)
    1:     {
56704:         JSContext *cx;
56704:         rv = cc->GetJSContext(&cx);
56704:         if (NS_FAILED(rv))
56704:             return rv;
    1:         *result = JSD_GetValueWrappedJSVal (mCx, mValue);
56704:         if (!JS_WrapValue(cx, result))
56704:             return NS_ERROR_FAILURE;
    1:         cc->SetReturnValueWasSet(PR_TRUE);
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
33644: NS_IMETHODIMP
33644: jsdValue::GetScript(jsdIScript **_rval)
33644: {
33644:     ASSERT_VALID_EPHEMERAL;
33644:     JSDScript *script = JSD_GetScriptForValue(mCx, mValue);
33644:     *_rval = jsdScript::FromPtr(mCx, script);
33644:     return NS_OK;
33644: }
33644: 
    1: /******************************************************************************
    1:  * debugger service implementation
    1:  ******************************************************************************/
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(jsdService, jsdIDebuggerService)
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetJSDContext(JSDContext **_rval)
    1: {
    1:     *_rval = mCx;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetFlags (PRUint32 *_rval)
    1: {
    1:     ASSERT_VALID_CONTEXT;
    1:     *_rval = JSD_GetContextFlags (mCx);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SetFlags (PRUint32 flags)
    1: {
    1:     ASSERT_VALID_CONTEXT;
    1:     JSD_SetContextFlags (mCx, flags);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
23431: jsdService::GetImplementationString(nsACString &aImplementationString)
    1: {
23431:     aImplementationString.AssignLiteral(implementationString);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetImplementationMajor(PRUint32 *_rval)
    1: {
    1:     *_rval = JSDS_MAJOR_VERSION;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetImplementationMinor(PRUint32 *_rval)
    1: {
    1:     *_rval = JSDS_MINOR_VERSION;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetIsOn (PRBool *_rval)
    1: {
    1:     *_rval = mOn;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::On (void)
    1: {
56783:     return NS_ERROR_NOT_IMPLEMENTED;
56783: }
56783: 
56783: NS_IMETHODIMP
56783: jsdService::AsyncOn (jsdIActivationCallback *activationCallback)
56783: {
    1:     nsresult  rv;
    1: 
    1:     /* get JS things from the CallContext */
 3002:     nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID(), &rv);
 3002:     if (NS_FAILED(rv)) return rv;
    1: 
10286:     nsAXPCNativeCallContext *cc = nsnull;
10286:     rv = xpc->GetCurrentNativeCallContext(&cc);
 3002:     if (NS_FAILED(rv)) return rv;
    1: 
    1:     JSContext *cx;
    1:     rv = cc->GetJSContext (&cx);
 3002:     if (NS_FAILED(rv)) return rv;
    1: 
56783:     mActivationCallback = activationCallback;
56783:     
56783:     return xpc->SetDebugModeWhenPossible(PR_TRUE);
    1: }
    1: 
    1: NS_IMETHODIMP
62057: jsdService::RecompileForDebugMode (JSContext *cx, JSCompartment *comp, JSBool mode) {
56784:   NS_ASSERTION(NS_IsMainThread(), "wrong thread");
62600:   /* XPConnect now does this work itself, so this IDL entry point is no longer used. */
62600:   return NS_ERROR_NOT_IMPLEMENTED;
62057: }
62057: 
62057: NS_IMETHODIMP
62057: jsdService::DeactivateDebugger ()
62057: {
62057:     if (!mCx)
61245:         return NS_OK;
62057: 
62057:     jsdContext::InvalidateAll();
62057:     jsdScript::InvalidateAll();
62057:     jsdValue::InvalidateAll();
62057:     jsdProperty::InvalidateAll();
62377:     jsdStackFrame::InvalidateAll();
62057:     ClearAllBreakpoints();
62057: 
62057:     JSD_SetErrorReporter (mCx, NULL, NULL);
62057:     JSD_SetScriptHook (mCx, NULL, NULL);
62057:     JSD_ClearThrowHook (mCx);
62057:     JSD_ClearInterruptHook (mCx);
62057:     JSD_ClearDebuggerHook (mCx);
62057:     JSD_ClearDebugBreakHook (mCx);
62057:     JSD_ClearTopLevelHook (mCx);
62057:     JSD_ClearFunctionHook (mCx);
62057:     
62057:     JSD_DebuggerOff (mCx);
62057: 
62057:     mCx = nsnull;
62057:     mRuntime = nsnull;
62057:     mOn = PR_FALSE;
62057: 
62057:     return NS_OK;
62057: }
62057: 
56783: 
56783: NS_IMETHODIMP
56783: jsdService::ActivateDebugger (JSRuntime *rt)
    1: {
    1:     if (mOn)
    1:         return (rt == mRuntime) ? NS_OK : NS_ERROR_ALREADY_INITIALIZED;
    1: 
    1:     mRuntime = rt;
    1: 
    1:     if (gLastGCProc == jsds_GCCallbackProc)
    1:         /* condition indicates that the callback proc has not been set yet */
    1:         gLastGCProc = JS_SetGCCallbackRT (rt, jsds_GCCallbackProc);
    1: 
    1:     mCx = JSD_DebuggerOnForUser (rt, NULL, NULL);
    1:     if (!mCx)
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     JSContext *cx   = JSD_GetDefaultJSContext (mCx);
    1:     JSObject  *glob = JS_GetGlobalObject (cx);
    1: 
    1:     /* init xpconnect on the debugger's context in case xpconnect tries to
    1:      * use it for stuff. */
 3002:     nsresult rv;
 3002:     nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID(), &rv);
 3002:     if (NS_FAILED(rv))
 3002:         return rv;
    1:     
    1:     xpc->InitClasses (cx, glob);
    1: 
62570:     /* Start watching for script creation/destruction and manage jsdScript
62570:      * objects accordingly
62570:      */
62570:     JSD_SetScriptHook (mCx, jsds_ScriptHookProc, NULL);
62570: 
    1:     /* If any of these mFooHook objects are installed, do the required JSD
    1:      * hookup now.   See also, jsdService::SetFooHook().
    1:      */
    1:     if (mErrorHook)
    1:         JSD_SetErrorReporter (mCx, jsds_ErrorHookProc, NULL);
    1:     if (mThrowHook)
    1:         JSD_SetThrowHook (mCx, jsds_ExecutionHookProc, NULL);
    1:     /* can't ignore script callbacks, as we need to |Release| the wrapper 
    1:      * stored in private data when a script is deleted. */
    1:     if (mInterruptHook)
    1:         JSD_SetInterruptHook (mCx, jsds_ExecutionHookProc, NULL);
    1:     if (mDebuggerHook)
    1:         JSD_SetDebuggerHook (mCx, jsds_ExecutionHookProc, NULL);
    1:     if (mDebugHook)
    1:         JSD_SetDebugBreakHook (mCx, jsds_ExecutionHookProc, NULL);
    1:     if (mTopLevelHook)
    1:         JSD_SetTopLevelHook (mCx, jsds_CallHookProc, NULL);
    1:     else
    1:         JSD_ClearTopLevelHook (mCx);
    1:     if (mFunctionHook)
    1:         JSD_SetFunctionHook (mCx, jsds_CallHookProc, NULL);
    1:     else
    1:         JSD_ClearFunctionHook (mCx);
    1:     mOn = PR_TRUE;
    1: 
    1: #ifdef DEBUG
    1:     printf ("+++ JavaScript debugging hooks installed.\n");
    1: #endif
56783: 
56783:     if (mActivationCallback)
56783:         return mActivationCallback->OnDebuggerActivated();
56783: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::Off (void)
    1: {
    1:     if (!mOn)
    1:         return NS_OK;
    1:     
    1:     if (!mCx || !mRuntime)
    1:         return NS_ERROR_NOT_INITIALIZED;
    1:     
    1:     if (gDeadScripts) {
12860:         if (gGCStatus != JSGC_END)
12860:             return NS_ERROR_NOT_AVAILABLE;
12860: 
    1:         JSContext *cx = JSD_GetDefaultJSContext(mCx);
61709:         while (gDeadScripts)
    1:             jsds_NotifyPendingDeadScripts (cx);
    1:     }
    1: 
    1:     /*
    1:     if (gLastGCProc != jsds_GCCallbackProc)
    1:         JS_SetGCCallbackRT (mRuntime, gLastGCProc);
    1:     */
    1: 
62057:     DeactivateDebugger();
    1: 
    1: #ifdef DEBUG
    1:     printf ("+++ JavaScript debugging hooks removed.\n");
    1: #endif
    1: 
56783:     nsresult rv;
56783:     nsCOMPtr<nsIXPConnect> xpc = do_GetService(nsIXPConnect::GetCID(), &rv);
56783:     if (NS_FAILED(rv))
56783:         return rv;
56783: 
56783:     xpc->SetDebugModeWhenPossible(PR_FALSE);
56783: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetPauseDepth(PRUint32 *_rval)
    1: {
    1:     NS_ENSURE_ARG_POINTER(_rval);
    1:     *_rval = mPauseLevel;
    1:     return NS_OK;
    1: }
    1:     
    1: NS_IMETHODIMP
    1: jsdService::Pause(PRUint32 *_rval)
    1: {
    1:     if (!mCx)
    1:         return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:     if (++mPauseLevel == 1) {
    1:         JSD_SetErrorReporter (mCx, NULL, NULL);
    1:         JSD_ClearThrowHook (mCx);
    1:         JSD_ClearInterruptHook (mCx);
    1:         JSD_ClearDebuggerHook (mCx);
    1:         JSD_ClearDebugBreakHook (mCx);
    1:         JSD_ClearTopLevelHook (mCx);
    1:         JSD_ClearFunctionHook (mCx);
35647:         JSD_DebuggerPause (mCx);
    1:     }
    1: 
    1:     if (_rval)
    1:         *_rval = mPauseLevel;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::UnPause(PRUint32 *_rval)
    1: {
    1:     if (!mCx)
    1:         return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:     if (mPauseLevel == 0)
    1:         return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:     /* check mOn before we muck with this stuff, it's possible the debugger
    1:      * was turned off while we were paused.
    1:      */
    1:     if (--mPauseLevel == 0 && mOn) {
35647:         JSD_DebuggerUnpause (mCx);
    1:         if (mErrorHook)
    1:             JSD_SetErrorReporter (mCx, jsds_ErrorHookProc, NULL);
    1:         if (mThrowHook)
    1:             JSD_SetThrowHook (mCx, jsds_ExecutionHookProc, NULL);
    1:         if (mInterruptHook)
    1:             JSD_SetInterruptHook (mCx, jsds_ExecutionHookProc, NULL);
    1:         if (mDebuggerHook)
    1:             JSD_SetDebuggerHook (mCx, jsds_ExecutionHookProc, NULL);
    1:         if (mDebugHook)
    1:             JSD_SetDebugBreakHook (mCx, jsds_ExecutionHookProc, NULL);
    1:         if (mTopLevelHook)
    1:             JSD_SetTopLevelHook (mCx, jsds_CallHookProc, NULL);
    1:         else
    1:             JSD_ClearTopLevelHook (mCx);
    1:         if (mFunctionHook)
    1:             JSD_SetFunctionHook (mCx, jsds_CallHookProc, NULL);
    1:         else
    1:             JSD_ClearFunctionHook (mCx);
    1:     }
    1:     
    1:     if (_rval)
    1:         *_rval = mPauseLevel;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::EnumerateContexts (jsdIContextEnumerator *enumerator)
    1: {
    1:     ASSERT_VALID_CONTEXT;
    1:     
    1:     if (!enumerator)
    1:         return NS_OK;
    1:     
    1:     JSContext *iter = NULL;
    1:     JSContext *cx;
    1: 
    1:     while ((cx = JS_ContextIterator (mRuntime, &iter)))
    1:     {
    1:         nsCOMPtr<jsdIContext> jsdicx = 
    1:             getter_AddRefs(jsdContext::FromPtr(mCx, cx));
    1:         if (jsdicx)
    1:         {
    1:             if (NS_FAILED(enumerator->EnumerateContext(jsdicx)))
    1:                 break;
    1:         }
    1:     }
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::EnumerateScripts (jsdIScriptEnumerator *enumerator)
    1: {
    1:     ASSERT_VALID_CONTEXT;
    1:     
    1:     JSDScript *script;
    1:     JSDScript *iter = NULL;
    1:     nsresult rv = NS_OK;
    1:     
    1:     JSD_LockScriptSubsystem(mCx);
    1:     while((script = JSD_IterateScripts(mCx, &iter))) {
    1:         nsCOMPtr<jsdIScript> jsdis =
    1:             getter_AddRefs(jsdScript::FromPtr(mCx, script));
    1:         rv = enumerator->EnumerateScript (jsdis);
    1:         if (NS_FAILED(rv))
    1:             break;
    1:     }
    1:     JSD_UnlockScriptSubsystem(mCx);
    1: 
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GC (void)
    1: {
    1:     ASSERT_VALID_CONTEXT;
    1:     JSContext *cx = JSD_GetDefaultJSContext (mCx);
  786:     JS_GC(cx);
  786:     return NS_OK;
  786: }
  786:     
  786: NS_IMETHODIMP
23431: jsdService::DumpHeap(const nsACString &fileName)
  786: {
  786:     ASSERT_VALID_CONTEXT;
  786: #ifndef DEBUG
  786:     return NS_ERROR_NOT_IMPLEMENTED;
  786: #else
  786:     nsresult rv = NS_OK;
23431:     FILE *file = !fileName.IsEmpty() ? fopen(PromiseFlatCString(fileName).get(), "w") : stdout;
  786:     if (!file) {
  786:         rv = NS_ERROR_FAILURE;
  786:     } else {
  786:         JSContext *cx = JSD_GetDefaultJSContext (mCx);
  917:         if (!JS_DumpHeap(cx, file, NULL, 0, NULL, (size_t)-1, NULL))
  786:             rv = NS_ERROR_FAILURE;
  786:         if (file != stdout)
  786:             fclose(file);
  786:     }
  786:     return rv;
    1: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::ClearProfileData ()
    1: {
    1:     ASSERT_VALID_CONTEXT;
    1:     JSD_ClearAllProfileData (mCx);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::InsertFilter (jsdIFilter *filter, jsdIFilter *after)
    1: {
    1:     NS_ENSURE_ARG_POINTER (filter);
    1:     if (jsds_FindFilter (filter))
    1:         return NS_ERROR_INVALID_ARG;
    1: 
26086:     FilterRecord *rec = PR_NEWZAP (FilterRecord);
    1:     if (!rec)
    1:         return NS_ERROR_OUT_OF_MEMORY;
    1: 
    1:     if (!jsds_SyncFilter (rec, filter)) {
    1:         PR_Free (rec);
    1:         return NS_ERROR_FAILURE;
    1:     }
    1:     
    1:     if (gFilters) {
    1:         if (!after) {
    1:             /* insert at head of list */
    1:             PR_INSERT_LINK(&rec->links, &gFilters->links);
    1:             gFilters = rec;
    1:         } else {
    1:             /* insert somewhere in the list */
    1:             FilterRecord *afterRecord = jsds_FindFilter (after);
    1:             if (!afterRecord) {
    1:                 jsds_FreeFilter(rec);
    1:                 return NS_ERROR_INVALID_ARG;
    1:             }
    1:             PR_INSERT_AFTER(&rec->links, &afterRecord->links);
    1:         }
    1:     } else {
    1:         if (after) {
    1:             /* user asked to insert into the middle of an empty list, bail. */
    1:             jsds_FreeFilter(rec);
    1:             return NS_ERROR_NOT_INITIALIZED;
    1:         }
    1:         PR_INIT_CLIST(&rec->links);
    1:         gFilters = rec;
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::AppendFilter (jsdIFilter *filter)
    1: {
    1:     NS_ENSURE_ARG_POINTER (filter);
    1:     if (jsds_FindFilter (filter))
    1:         return NS_ERROR_INVALID_ARG;
26086:     FilterRecord *rec = PR_NEWZAP (FilterRecord);
    1: 
    1:     if (!jsds_SyncFilter (rec, filter)) {
    1:         PR_Free (rec);
    1:         return NS_ERROR_FAILURE;
    1:     }
    1:     
    1:     if (gFilters) {
    1:         PR_INSERT_BEFORE(&rec->links, &gFilters->links);
    1:     } else {
    1:         PR_INIT_CLIST(&rec->links);
    1:         gFilters = rec;
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::RemoveFilter (jsdIFilter *filter)
    1: {
    1:     NS_ENSURE_ARG_POINTER(filter);
    1:     FilterRecord *rec = jsds_FindFilter (filter);
    1:     if (!rec)
    1:         return NS_ERROR_INVALID_ARG;
    1:     
    1:     if (gFilters == rec) {
 3233:         gFilters = reinterpret_cast<FilterRecord *>
 3233:                                    (PR_NEXT_LINK(&rec->links));
    1:         /* If we're the only filter left, null out the list head. */
    1:         if (gFilters == rec)
    1:             gFilters = nsnull;
    1:     }
    1: 
    1:     
    1:     PR_REMOVE_LINK(&rec->links);
    1:     jsds_FreeFilter (rec);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SwapFilters (jsdIFilter *filter_a, jsdIFilter *filter_b)
    1: {
    1:     NS_ENSURE_ARG_POINTER(filter_a);
    1:     NS_ENSURE_ARG_POINTER(filter_b);
    1:     
    1:     FilterRecord *rec_a = jsds_FindFilter (filter_a);
    1:     if (!rec_a)
    1:         return NS_ERROR_INVALID_ARG;
    1:     
    1:     if (filter_a == filter_b) {
    1:         /* just a refresh */
    1:         if (!jsds_SyncFilter (rec_a, filter_a))
    1:             return NS_ERROR_FAILURE;
    1:         return NS_OK;
    1:     }
    1:     
    1:     FilterRecord *rec_b = jsds_FindFilter (filter_b);
    1:     if (!rec_b) {
    1:         /* filter_b is not in the list, replace filter_a with filter_b. */
    1:         if (!jsds_SyncFilter (rec_a, filter_b))
    1:             return NS_ERROR_FAILURE;
    1:     } else {
    1:         /* both filters are in the list, swap. */
    1:         if (!jsds_SyncFilter (rec_a, filter_b))
    1:             return NS_ERROR_FAILURE;
    1:         if (!jsds_SyncFilter (rec_b, filter_a))
    1:             return NS_ERROR_FAILURE;
    1:     }
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::EnumerateFilters (jsdIFilterEnumerator *enumerator) 
    1: {
    1:     if (!gFilters)
    1:         return NS_OK;
    1:     
    1:     FilterRecord *current = gFilters;
    1:     do {
    1:         jsds_SyncFilter (current, current->filterObject);
    1:         /* SyncFilter failure would be bad, but what would we do about it? */
    1:         if (enumerator) {
    1:             nsresult rv = enumerator->EnumerateFilter (current->filterObject);
    1:             if (NS_FAILED(rv))
    1:                 return rv;
    1:         }
 3233:         current = reinterpret_cast<FilterRecord *>
 3233:                                   (PR_NEXT_LINK (&current->links));
    1:     } while (current != gFilters);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::RefreshFilters ()
    1: {
    1:     return EnumerateFilters(nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::ClearFilters ()
    1: {
    1:     if (!gFilters)
    1:         return NS_OK;
    1: 
 3233:     FilterRecord *current = reinterpret_cast<FilterRecord *>
 3233:                                             (PR_NEXT_LINK (&gFilters->links));
    1:     do {
 3233:         FilterRecord *next = reinterpret_cast<FilterRecord *>
 3233:                                              (PR_NEXT_LINK (&current->links));
    1:         PR_REMOVE_AND_INIT_LINK(&current->links);
    1:         jsds_FreeFilter(current);
    1:         current = next;
    1:     } while (current != gFilters);
    1:     
    1:     jsds_FreeFilter(current);
    1:     gFilters = nsnull;
    1:     
    1:     return NS_OK;
    1: }
    1:         
    1: NS_IMETHODIMP
    1: jsdService::ClearAllBreakpoints (void)
    1: {
    1:     ASSERT_VALID_CONTEXT;
    1: 
    1:     JSD_LockScriptSubsystem(mCx);
    1:     JSD_ClearAllExecutionHooks (mCx);
    1:     JSD_UnlockScriptSubsystem(mCx);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::WrapValue(jsdIValue **_rval)
    1: {
    1:     ASSERT_VALID_CONTEXT;
    1: 
    1:     nsresult rv;
 3002:     nsCOMPtr<nsIXPConnect> xpc = do_GetService (nsIXPConnect::GetCID(), &rv);
 3002:     if (NS_FAILED(rv))
 3002:         return rv;
 3002: 
10286:     nsAXPCNativeCallContext *cc = nsnull;
10286:     rv = xpc->GetCurrentNativeCallContext (&cc);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
    1:     PRUint32 argc;
    1:     rv = cc->GetArgc (&argc);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     if (argc < 1)
    1:         return NS_ERROR_INVALID_ARG;
    1:     
    1:     jsval    *argv;
    1:     rv = cc->GetArgvPtr (&argv);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
33989:     return WrapJSValue(argv[0], _rval);
33989: }
33989: 
33989: NS_IMETHODIMP
48470: jsdService::WrapJSValue(const jsval &value, jsdIValue** _rval)
33989: {
33989:     JSDValue *jsdv = JSD_NewValue(mCx, value);
    1:     if (!jsdv)
    1:         return NS_ERROR_FAILURE;
    1:     
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: jsdService::EnterNestedEventLoop (jsdINestCallback *callback, PRUint32 *_rval)
    1: {
    1:     // Nesting event queues is a thing of the past.  Now, we just spin the
    1:     // current event loop.
    1:  
 3002:     nsresult rv;
    1:     nsCOMPtr<nsIJSContextStack> 
 3002:         stack(do_GetService("@mozilla.org/js/xpc/ContextStack;1", &rv));
 3002:     if (NS_FAILED(rv))
 3002:         return rv;
    1:     PRUint32 nestLevel = ++mNestedLoopLevel;
    1:     
    1:     nsCOMPtr<nsIThread> thread = do_GetCurrentThread();
    1: 
 3002:     if (NS_SUCCEEDED(stack->Push(nsnull))) {
    1:         if (callback) {
    1:             Pause(nsnull);
    1:             rv = callback->OnNest();
    1:             UnPause(nsnull);
    1:         }
    1:         
    1:         while (NS_SUCCEEDED(rv) && mNestedLoopLevel >= nestLevel) {
    1:             if (!NS_ProcessNextEvent(thread))
    1:                 rv = NS_ERROR_UNEXPECTED;
    1:         }
    1: 
    1:         JSContext* cx;
    1:         stack->Pop(&cx);
    1:         NS_ASSERTION(cx == nsnull, "JSContextStack mismatch");
    1:     }
    1:     else
    1:         rv = NS_ERROR_FAILURE;
    1:     
    1:     NS_ASSERTION (mNestedLoopLevel <= nestLevel,
    1:                   "nested event didn't unwind properly");
    1:     if (mNestedLoopLevel == nestLevel)
    1:         --mNestedLoopLevel;
    1: 
    1:     *_rval = mNestedLoopLevel;
    1:     return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::ExitNestedEventLoop (PRUint32 *_rval)
    1: {
    1:     if (mNestedLoopLevel > 0)
    1:         --mNestedLoopLevel;
    1:     else
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     *_rval = mNestedLoopLevel;    
    1:     return NS_OK;
    1: }    
    1: 
    1: /* hook attribute get/set functions */
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SetErrorHook (jsdIErrorHook *aHook)
    1: {
    1:     mErrorHook = aHook;
    1: 
    1:     /* if the debugger isn't initialized, that's all we can do for now.  The
56783:      * ActivateDebugger() method will do the rest when the coast is clear.
    1:      */
    1:     if (!mCx || mPauseLevel)
    1:         return NS_OK;
    1: 
    1:     if (aHook)
    1:         JSD_SetErrorReporter (mCx, jsds_ErrorHookProc, NULL);
    1:     else
    1:         JSD_SetErrorReporter (mCx, NULL, NULL);
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetErrorHook (jsdIErrorHook **aHook)
    1: {
    1:     *aHook = mErrorHook;
    1:     NS_IF_ADDREF(*aHook);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SetBreakpointHook (jsdIExecutionHook *aHook)
    1: {    
    1:     mBreakpointHook = aHook;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetBreakpointHook (jsdIExecutionHook **aHook)
    1: {   
    1:     *aHook = mBreakpointHook;
    1:     NS_IF_ADDREF(*aHook);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SetDebugHook (jsdIExecutionHook *aHook)
    1: {    
    1:     mDebugHook = aHook;
    1: 
    1:     /* if the debugger isn't initialized, that's all we can do for now.  The
56783:      * ActivateDebugger() method will do the rest when the coast is clear.
    1:      */
    1:     if (!mCx || mPauseLevel)
    1:         return NS_OK;
    1: 
    1:     if (aHook)
    1:         JSD_SetDebugBreakHook (mCx, jsds_ExecutionHookProc, NULL);
    1:     else
    1:         JSD_ClearDebugBreakHook (mCx);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetDebugHook (jsdIExecutionHook **aHook)
    1: {   
    1:     *aHook = mDebugHook;
    1:     NS_IF_ADDREF(*aHook);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SetDebuggerHook (jsdIExecutionHook *aHook)
    1: {    
    1:     mDebuggerHook = aHook;
    1: 
    1:     /* if the debugger isn't initialized, that's all we can do for now.  The
56783:      * ActivateDebugger() method will do the rest when the coast is clear.
    1:      */
    1:     if (!mCx || mPauseLevel)
    1:         return NS_OK;
    1: 
    1:     if (aHook)
    1:         JSD_SetDebuggerHook (mCx, jsds_ExecutionHookProc, NULL);
    1:     else
    1:         JSD_ClearDebuggerHook (mCx);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetDebuggerHook (jsdIExecutionHook **aHook)
    1: {   
    1:     *aHook = mDebuggerHook;
    1:     NS_IF_ADDREF(*aHook);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SetInterruptHook (jsdIExecutionHook *aHook)
    1: {    
    1:     mInterruptHook = aHook;
    1: 
    1:     /* if the debugger isn't initialized, that's all we can do for now.  The
56783:      * ActivateDebugger() method will do the rest when the coast is clear.
    1:      */
    1:     if (!mCx || mPauseLevel)
    1:         return NS_OK;
    1: 
    1:     if (aHook)
    1:         JSD_SetInterruptHook (mCx, jsds_ExecutionHookProc, NULL);
    1:     else
    1:         JSD_ClearInterruptHook (mCx);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetInterruptHook (jsdIExecutionHook **aHook)
    1: {   
    1:     *aHook = mInterruptHook;
    1:     NS_IF_ADDREF(*aHook);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SetScriptHook (jsdIScriptHook *aHook)
    1: {    
    1:     mScriptHook = aHook;
    1: 
    1:     /* if the debugger isn't initialized, that's all we can do for now.  The
56783:      * ActivateDebugger() method will do the rest when the coast is clear.
    1:      */
    1:     if (!mCx || mPauseLevel)
    1:         return NS_OK;
    1:     
    1:     if (aHook)
    1:         JSD_SetScriptHook (mCx, jsds_ScriptHookProc, NULL);
    1:     /* we can't unset it if !aHook, because we still need to see script
    1:      * deletes in order to Release the jsdIScripts held in JSDScript
    1:      * private data. */
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetScriptHook (jsdIScriptHook **aHook)
    1: {   
    1:     *aHook = mScriptHook;
    1:     NS_IF_ADDREF(*aHook);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SetThrowHook (jsdIExecutionHook *aHook)
    1: {    
    1:     mThrowHook = aHook;
    1: 
    1:     /* if the debugger isn't initialized, that's all we can do for now.  The
56783:      * ActivateDebugger() method will do the rest when the coast is clear.
    1:      */
    1:     if (!mCx || mPauseLevel)
    1:         return NS_OK;
    1: 
    1:     if (aHook)
    1:         JSD_SetThrowHook (mCx, jsds_ExecutionHookProc, NULL);
    1:     else
    1:         JSD_ClearThrowHook (mCx);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetThrowHook (jsdIExecutionHook **aHook)
    1: {   
    1:     *aHook = mThrowHook;
    1:     NS_IF_ADDREF(*aHook);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SetTopLevelHook (jsdICallHook *aHook)
    1: {    
    1:     mTopLevelHook = aHook;
    1: 
    1:     /* if the debugger isn't initialized, that's all we can do for now.  The
56783:      * ActivateDebugger() method will do the rest when the coast is clear.
    1:      */
    1:     if (!mCx || mPauseLevel)
    1:         return NS_OK;
    1: 
    1:     if (aHook)
    1:         JSD_SetTopLevelHook (mCx, jsds_CallHookProc, NULL);
    1:     else
    1:         JSD_ClearTopLevelHook (mCx);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetTopLevelHook (jsdICallHook **aHook)
    1: {   
    1:     *aHook = mTopLevelHook;
    1:     NS_IF_ADDREF(*aHook);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::SetFunctionHook (jsdICallHook *aHook)
    1: {    
    1:     mFunctionHook = aHook;
    1: 
    1:     /* if the debugger isn't initialized, that's all we can do for now.  The
56783:      * ActivateDebugger() method will do the rest when the coast is clear.
    1:      */
    1:     if (!mCx || mPauseLevel)
    1:         return NS_OK;
    1: 
    1:     if (aHook)
    1:         JSD_SetFunctionHook (mCx, jsds_CallHookProc, NULL);
    1:     else
    1:         JSD_ClearFunctionHook (mCx);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdService::GetFunctionHook (jsdICallHook **aHook)
    1: {   
    1:     *aHook = mFunctionHook;
    1:     NS_IF_ADDREF(*aHook);
    1:     
    1:     return NS_OK;
    1: }
    1: 
    1: /* virtual */
    1: jsdService::~jsdService()
    1: {
    1:     ClearFilters();
12860:     mErrorHook = nsnull;
12860:     mBreakpointHook = nsnull;
12860:     mDebugHook = nsnull;
12860:     mDebuggerHook = nsnull;
12860:     mInterruptHook = nsnull;
12860:     mScriptHook = nsnull;
12860:     mThrowHook = nsnull;
12860:     mTopLevelHook = nsnull;
12860:     mFunctionHook = nsnull;
12860:     gGCStatus = JSGC_END;
    1:     Off();
    1:     gJsds = nsnull;
    1: }
    1: 
    1: jsdService *
    1: jsdService::GetService ()
    1: {
    1:     if (!gJsds)
    1:         gJsds = new jsdService();
    1:         
    1:     NS_IF_ADDREF(gJsds);
    1:     return gJsds;
    1: }
    1: 
    1: NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(jsdService, jsdService::GetService)
    1: 
    1: /* app-start observer.  turns on the debugger at app-start.  this is inserted
    1:  * and/or removed from the app-start category by the jsdService::initAtStartup
    1:  * property.
    1:  */
    1: class jsdASObserver : public nsIObserver 
    1: {
    1:   public:
    1:     NS_DECL_ISUPPORTS
    1:     NS_DECL_NSIOBSERVER
    1: 
    1:     jsdASObserver () {}    
    1: };
    1: 
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(jsdASObserver, nsIObserver)
    1: 
    1: NS_IMETHODIMP
    1: jsdASObserver::Observe (nsISupports *aSubject, const char *aTopic,
    1:                         const PRUnichar *aData)
    1: {
    1:     nsresult rv;
    1: 
    1:     // Hmm.  Why is the app-startup observer called multiple times?
    1:     //NS_ASSERTION(!gJsds, "app startup observer called twice");
    1:     nsCOMPtr<jsdIDebuggerService> jsds = do_GetService(jsdServiceCtrID, &rv);
 3002:     if (NS_FAILED(rv))
 3002:         return rv;
    1: 
    1:     PRBool on;
    1:     rv = jsds->GetIsOn(&on);
    1:     if (NS_FAILED(rv) || on)
    1:         return rv;
    1:     
    1:     nsCOMPtr<nsIJSRuntimeService> rts = do_GetService(NS_JSRT_CTRID, &rv);
    1:     if (NS_FAILED(rv))
    1:         return rv;    
    1: 
    1:     JSRuntime *rt;
    1:     rts->GetRuntime (&rt);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1: 
56783:     rv = jsds->ActivateDebugger(rt);
    1:     if (NS_FAILED(rv))
    1:         return rv;
    1:     
48556:     return NS_OK;
    1: }
    1: 
    1: NS_GENERIC_FACTORY_CONSTRUCTOR(jsdASObserver)
46998: NS_DEFINE_NAMED_CID(JSDSERVICE_CID);
46998: NS_DEFINE_NAMED_CID(JSDASO_CID);
46998: 
46998: static const mozilla::Module::CIDEntry kJSDCIDs[] = {
46998:     { &kJSDSERVICE_CID, false, NULL, jsdServiceConstructor },
46998:     { &kJSDASO_CID, false, NULL, jsdASObserverConstructor },
46998:     { NULL }
    1: };
    1: 
46998: static const mozilla::Module::ContractIDEntry kJSDContracts[] = {
46998:     { jsdServiceCtrID, &kJSDSERVICE_CID },
46998:     { jsdARObserverCtrID, &kJSDASO_CID },
46998:     { NULL }
46998: };
46998: 
46998: static const mozilla::Module kJSDModule = {
46998:     mozilla::Module::kVersion,
46998:     kJSDCIDs,
46998:     kJSDContracts
46998: };
46998: 
46998: NSMODULE_DEFN(JavaScript_Debugger) = &kJSDModule;
    1: 
    1: /********************************************************************************
    1:  ********************************************************************************
    1:  * graveyard
    1:  */
    1: 
    1: #if 0
    1: /* Thread States */
    1: NS_IMPL_THREADSAFE_ISUPPORTS1(jsdThreadState, jsdIThreadState); 
    1: 
    1: NS_IMETHODIMP
    1: jsdThreadState::GetJSDContext(JSDContext **_rval)
    1: {
    1:     *_rval = mCx;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdThreadState::GetJSDThreadState(JSDThreadState **_rval)
    1: {
    1:     *_rval = mThreadState;
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdThreadState::GetFrameCount (PRUint32 *_rval)
    1: {
    1:     *_rval = JSD_GetCountOfStackFrames (mCx, mThreadState);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdThreadState::GetTopFrame (jsdIStackFrame **_rval)
    1: {
    1:     JSDStackFrameInfo *sfi = JSD_GetStackFrame (mCx, mThreadState);
    1:     
    1:     *_rval = jsdStackFrame::FromPtr (mCx, mThreadState, sfi);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdThreadState::GetPendingException(jsdIValue **_rval)
    1: {
    1:     JSDValue *jsdv = JSD_GetException (mCx, mThreadState);
    1:     
    1:     *_rval = jsdValue::FromPtr (mCx, jsdv);
    1:     return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: jsdThreadState::SetPendingException(jsdIValue *aException)
    1: {
    1:     JSDValue *jsdv;
    1:     
    1:     nsresult rv = aException->GetJSDValue (&jsdv);
    1:     if (NS_FAILED(rv))
    1:         return NS_ERROR_FAILURE;
    1:     
    1:     if (!JSD_SetException (mCx, mThreadState, jsdv))
    1:         return NS_ERROR_FAILURE;
    1: 
    1:     return NS_OK;
    1: }
    1: 
    1: #endif
