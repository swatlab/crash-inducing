    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Communicator client code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef nsXMLContentSink_h__
    1: #define nsXMLContentSink_h__
    1: 
    1: #include "nsContentSink.h"
    1: #include "nsIXMLContentSink.h"
    1: #include "nsIExpatSink.h"
    1: #include "nsIDocumentTransformer.h"
    1: #include "nsTArray.h"
    1: #include "nsCOMPtr.h"
    1: #include "nsCRT.h"
11423: #include "nsCycleCollectionParticipant.h"
29496: #include "nsIDTD.h"
    1: 
    1: class nsIDocument;
    1: class nsIURI;
    1: class nsIContent;
    1: class nsINodeInfo;
    1: class nsIParser;
    1: class nsIViewManager;
    1: 
    1: typedef enum {
    1:   eXMLContentSinkState_InProlog,
    1:   eXMLContentSinkState_InDocumentElement,
    1:   eXMLContentSinkState_InEpilog
    1: } XMLContentSinkState;
    1: 
    1: struct StackNode {
    1:   nsCOMPtr<nsIContent> mContent;
    1:   PRUint32 mNumFlushed;
    1: };
    1: 
    1: class nsXMLContentSink : public nsContentSink,
    1:                          public nsIXMLContentSink,
    1:                          public nsITransformObserver,
    1:                          public nsIExpatSink
    1: {
    1: public:
    1:   nsXMLContentSink();
    1:   virtual ~nsXMLContentSink();
    1: 
    1:   NS_DECL_AND_IMPL_ZEROING_OPERATOR_NEW
    1: 
    1:   nsresult Init(nsIDocument* aDoc,
    1:                 nsIURI* aURL,
    1:                 nsISupports* aContainer,
    1:                 nsIChannel* aChannel);
    1: 
    1:   // nsISupports
    1:   NS_DECL_ISUPPORTS_INHERITED
    1: 
11423:   NS_DECL_CYCLE_COLLECTION_CLASS_INHERITED_NO_UNLINK(nsXMLContentSink,
11423:                                                      nsContentSink)
11423: 
    1:   NS_DECL_NSIEXPATSINK
    1: 
    1:   // nsIContentSink
21121:   NS_IMETHOD WillParse(void);
29496:   NS_IMETHOD WillBuildModel(nsDTDMode aDTDMode);
33527:   NS_IMETHOD DidBuildModel(PRBool aTerminated);
    1:   NS_IMETHOD WillInterrupt(void);
    1:   NS_IMETHOD WillResume(void);
    1:   NS_IMETHOD SetParser(nsIParser* aParser);  
    1:   virtual void FlushPendingNotifications(mozFlushType aType);
    1:   NS_IMETHOD SetDocumentCharset(nsACString& aCharset);
    1:   virtual nsISupports *GetTarget();
27387:   virtual PRBool IsScriptExecuting();
    1: 
    1:   // nsITransformObserver
    1:   NS_IMETHOD OnDocumentCreated(nsIDocument *aResultDocument);
    1:   NS_IMETHOD OnTransformDone(nsresult aResult, nsIDocument *aResultDocument);
    1: 
 2026:   // nsICSSLoaderObserver
42163:   NS_IMETHOD StyleSheetLoaded(nsCSSStyleSheet* aSheet, PRBool aWasAlternate,
 2026:                               nsresult aStatus);
22106:   static PRBool ParsePIData(const nsString &aData, nsString &aHref,
    1:                           nsString &aTitle, nsString &aMedia,
    1:                           PRBool &aIsAlternate);
    1: 
    1: protected:
  681:   // Start layout.  If aIgnorePendingSheets is true, this will happen even if
  681:   // we still have stylesheet loads pending.  Otherwise, we'll wait until the
  681:   // stylesheets are all done loading.
  681:   virtual void MaybeStartLayout(PRBool aIgnorePendingSheets);
    1: 
    1:   virtual nsresult AddAttributes(const PRUnichar** aNode, nsIContent* aContent);
    1:   nsresult AddText(const PRUnichar* aString, PRInt32 aLength);
    1: 
    1:   virtual PRBool OnOpenContainer(const PRUnichar **aAtts, 
    1:                                  PRUint32 aAttsCount, 
    1:                                  PRInt32 aNameSpaceID, 
    1:                                  nsIAtom* aTagName,
    1:                                  PRUint32 aLineNumber) { return PR_TRUE; }
    1:   // Set the given content as the root element for the created document
    1:   //  don't set if root element was already set.
    1:   //  return TRUE if this call set the root element
    1:   virtual PRBool SetDocElement(PRInt32 aNameSpaceID, 
    1:                                nsIAtom *aTagName,
    1:                                nsIContent *aContent);
41743:   virtual PRBool NotifyForDocElement() { return PR_TRUE; }
    1:   virtual nsresult CreateElement(const PRUnichar** aAtts, PRUint32 aAttsCount,
    1:                                  nsINodeInfo* aNodeInfo, PRUint32 aLineNumber,
19719:                                  nsIContent** aResult, PRBool* aAppendContent,
43386:                                  PRUint32 aFromParser);
    1: 
    1:   // aParent is allowed to be null here if this is the root content
    1:   // being closed
    1:   virtual nsresult CloseElement(nsIContent* aContent);
    1: 
20517:   virtual nsresult FlushText(PRBool aReleaseTextNode = PR_TRUE);
    1: 
    1:   nsresult AddContentAsLeaf(nsIContent *aContent);
    1: 
    1:   nsIContent* GetCurrentContent();
54512:   StackNode & GetCurrentStackNode();
    1:   nsresult PushContent(nsIContent *aContent);
    1:   void PopContent();
14437:   PRBool HaveNotifiedForCurrentContent() const;
    1: 
    1:   nsresult FlushTags();
    1: 
    1:   void UpdateChildCounts();
    1: 
    1:   void DidAddContent()
    1:   {
    1:     if (IsTimeToNotify()) {
    1:       FlushTags();	
    1:     }
    1:   }
    1:   
    1:   // nsContentSink override
    1:   virtual nsresult ProcessStyleLink(nsIContent* aElement,
    1:                                     const nsSubstring& aHref,
    1:                                     PRBool aAlternate,
    1:                                     const nsSubstring& aTitle,
    1:                                     const nsSubstring& aType,
    1:                                     const nsSubstring& aMedia);
    1: 
    1:   nsresult LoadXSLStyleSheet(nsIURI* aUrl);
    1: 
    1:   PRBool CanStillPrettyPrint();
    1: 
    1:   nsresult MaybePrettyPrint();
    1:   
    1:   PRBool IsMonolithicContainer(nsINodeInfo* aNodeInfo);
    1: 
 2266:   nsresult HandleStartElement(const PRUnichar *aName, const PRUnichar **aAtts, 
 2266:                               PRUint32 aAttsCount, PRInt32 aIndex, 
 2266:                               PRUint32 aLineNumber,
 2266:                               PRBool aInterruptable);
 2266:   nsresult HandleEndElement(const PRUnichar *aName, PRBool aInterruptable);
 2266:   nsresult HandleCharacterData(const PRUnichar *aData, PRUint32 aLength,
 2266:                                PRBool aInterruptable);
 2266: 
    1:   nsIContent*      mDocElement;
 3317:   nsCOMPtr<nsIContent> mCurrentHead;  // When set, we're in an XHTML <haed>
    1:   PRUnichar*       mText;
    1: 
    1:   XMLContentSinkState mState;
    1: 
    1:   PRInt32 mTextLength;
    1:   PRInt32 mTextSize;
    1:   
    1:   PRInt32 mNotifyLevel;
20517:   nsCOMPtr<nsIContent> mLastTextNode;
20517:   PRInt32 mLastTextNodeSize;
    1: 
    1:   PRUint8 mConstrainSize : 1;
    1:   PRUint8 mPrettyPrintXML : 1;
    1:   PRUint8 mPrettyPrintHasSpecialRoot : 1;
    1:   PRUint8 mPrettyPrintHasFactoredElements : 1;
 2026:   PRUint8 mPrettyPrinting : 1;  // True if we called PrettyPrint() and it
 2026:                                 // decided we should in fact prettyprint.
    1:   
    1:   nsTArray<StackNode>              mContentStack;
    1: 
    1:   nsCOMPtr<nsIDocumentTransformer> mXSLTProcessor;
    1: };
    1: 
    1: #endif // nsXMLContentSink_h__
