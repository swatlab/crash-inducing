    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is the Mozilla SVG project.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Crocodile Clips Ltd..
    1:  * Portions created by the Initial Developer are Copyright (C) 2002
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Alex Fritze <alex.fritze@crocodile-clips.com> (original author)
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: #ifndef __NS_SVGGLYPHFRAME_H__
    1: #define __NS_SVGGLYPHFRAME_H__
    1: 
    1: #include "nsSVGGeometryFrame.h"
    1: #include "nsISVGGlyphFragmentLeaf.h"
    1: #include "nsISVGChildFrame.h"
    1: #include "gfxContext.h"
  630: #include "gfxFont.h"
    1: 
    1: class nsSVGTextFrame;
    1: class nsSVGGlyphFrame;
13259: class CharacterIterator;
13259: struct CharacterPosition;
    1: 
    1: typedef nsSVGGeometryFrame nsSVGGlyphFrameBase;
    1: 
    1: class nsSVGGlyphFrame : public nsSVGGlyphFrameBase,
    1:                         public nsISVGGlyphFragmentLeaf, // : nsISVGGlyphFragmentNode
    1:                         public nsISVGChildFrame
    1: {
    1:   friend nsIFrame*
23953:   NS_NewSVGGlyphFrame(nsIPresShell* aPresShell, nsStyleContext* aContext);
 4230: protected:
 4230:   nsSVGGlyphFrame(nsStyleContext* aContext)
 4230:     : nsSVGGlyphFrameBase(aContext),
13259:       mTextRun(nsnull),
13259:       mWhitespaceHandling(COMPRESS_WHITESPACE)
13259:       {}
13259:   ~nsSVGGlyphFrame()
13259:   {
13259:     ClearTextRun();
13259:   }
    1: 
    1: public:
23554:   NS_DECL_QUERYFRAME
    1: 
    1:   // nsIFrame interface:
    1:   NS_IMETHOD  CharacterDataChanged(nsPresContext*  aPresContext,
    1:                                    nsIContent*     aChild,
    1:                                    PRBool          aAppend);
    1: 
20836:   virtual void DidSetStyleContext(nsStyleContext* aOldStyleContext);
    1: 
    1:   NS_IMETHOD  SetSelected(nsPresContext* aPresContext,
    1:                           nsIDOMRange*    aRange,
    1:                           PRBool          aSelected,
18931:                           nsSpread        aSpread,
18931:                           SelectionType   aType);
    1:   NS_IMETHOD  GetSelected(PRBool *aSelected) const;
    1:   NS_IMETHOD  IsSelectable(PRBool* aIsSelectable, PRUint8* aSelectStyle) const;
    1: 
23953: #ifdef DEBUG
23953:   NS_IMETHOD Init(nsIContent*      aContent,
23953:                   nsIFrame*        aParent,
23953:                   nsIFrame*        aPrevInFlow);
23953: #endif
23953: 
    1:   /**
    1:    * Get the "type" of the frame
    1:    *
    1:    * @see nsGkAtoms::svgGlyphFrame
    1:    */
    1:   virtual nsIAtom* GetType() const;
    1: 
    1:   virtual PRBool IsFrameOfType(PRUint32 aFlags) const
    1:   {
    1:     // Set the frame state bit for text frames to mark them as replaced.
    1:     // XXX kipp: temporary
    1: 
    1:     return nsSVGGlyphFrameBase::IsFrameOfType(aFlags & ~(nsIFrame::eReplaced));
    1:   }
    1: 
    1: #ifdef DEBUG
    1:   NS_IMETHOD GetFrameName(nsAString& aResult) const
    1:   {
    1:     return MakeFrameName(NS_LITERAL_STRING("SVGGlyph"), aResult);
    1:   }
    1: #endif
    1: 
    1:   // nsISVGChildFrame interface:
13259:   // These four always use the global transform, even if NS_STATE_NONDISPLAY_CHILD
20652:   NS_IMETHOD PaintSVG(nsSVGRenderState *aContext,
20652:                       const nsIntRect *aDirtyRect);
18367:   NS_IMETHOD_(nsIFrame*) GetFrameForPoint(const nsPoint &aPoint);
13259:   NS_IMETHOD UpdateCoveredRegion();
13259:   NS_IMETHOD GetBBox(nsIDOMSVGRect **_retval);
13259: 
13219:   NS_IMETHOD_(nsRect) GetCoveredRegion();
    1:   NS_IMETHOD InitialUpdate();
10661:   virtual void NotifySVGChanged(PRUint32 aFlags);
    1:   NS_IMETHOD NotifyRedrawSuspended();
    1:   NS_IMETHOD NotifyRedrawUnsuspended();
19125:   NS_IMETHOD SetMatrixPropagation(PRBool aPropagate);
19125:   virtual PRBool GetMatrixPropagation();
    1:   NS_IMETHOD_(PRBool) IsDisplayContainer() { return PR_FALSE; }
    1:   NS_IMETHOD_(PRBool) HasValidCoveredRect() { return PR_TRUE; }
    1: 
14042:   // nsSVGGeometryFrame methods
    1:   NS_IMETHOD GetCanvasTM(nsIDOMSVGMatrix * *aCTM);
    1: 
    1:   // nsISVGGlyphFragmentLeaf interface:
13259:   // These do not use the global transform if NS_STATE_NONDISPLAY_CHILD
    1:   NS_IMETHOD GetStartPositionOfChar(PRUint32 charnum, nsIDOMSVGPoint **_retval);
    1:   NS_IMETHOD GetEndPositionOfChar(PRUint32 charnum, nsIDOMSVGPoint **_retval);
    1:   NS_IMETHOD GetExtentOfChar(PRUint32 charnum, nsIDOMSVGRect **_retval);
    1:   NS_IMETHOD GetRotationOfChar(PRUint32 charnum, float *_retval);
13259:   /**
13259:    * @param aForceGlobalTransform controls whether to use the
13259:    * global transform even when NS_STATE_NONDISPLAY_CHILD
13259:    */
13259:   NS_IMETHOD_(float) GetBaselineOffset(PRUint16 baselineIdentifier,
13259:                                        PRBool aForceGlobalTransform);
13259:   /**
13259:    * @param aForceGlobalTransform controls whether to use the
13259:    * global transform even when NS_STATE_NONDISPLAY_CHILD
13259:    */
13259:   NS_IMETHOD_(float) GetAdvance(PRBool aForceGlobalTransform);
    1: 
    1:   NS_IMETHOD_(void) SetGlyphPosition(float x, float y);
    1:   NS_IMETHOD_(nsSVGTextPathFrame*) FindTextPathParent();
    1:   NS_IMETHOD_(PRBool) IsStartOfChunk(); // == is new absolutely positioned chunk.
    1:   NS_IMETHOD_(void) GetAdjustedPosition(/* inout */ float &x, /* inout */ float &y);
    1: 
    1:   NS_IMETHOD_(already_AddRefed<nsIDOMSVGLengthList>) GetX();
    1:   NS_IMETHOD_(already_AddRefed<nsIDOMSVGLengthList>) GetY();
    1:   NS_IMETHOD_(already_AddRefed<nsIDOMSVGLengthList>) GetDx();
    1:   NS_IMETHOD_(already_AddRefed<nsIDOMSVGLengthList>) GetDy();
    1:   NS_IMETHOD_(PRUint16) GetTextAnchor();
    1:   NS_IMETHOD_(PRBool) IsAbsolutelyPositioned();
    1: 
    1:   // nsISVGGlyphFragmentNode interface:
13259:   // These do not use the global transform if NS_STATE_NONDISPLAY_CHILD
    1:   NS_IMETHOD_(PRUint32) GetNumberOfChars();
    1:   NS_IMETHOD_(float) GetComputedTextLength();
    1:   NS_IMETHOD_(float) GetSubStringLength(PRUint32 charnum, PRUint32 fragmentChars);
    1:   NS_IMETHOD_(PRInt32) GetCharNumAtPosition(nsIDOMSVGPoint *point);
    1:   NS_IMETHOD_(nsISVGGlyphFragmentLeaf *) GetFirstGlyphFragment();
    1:   NS_IMETHOD_(nsISVGGlyphFragmentLeaf *) GetNextGlyphFragment();
    1:   NS_IMETHOD_(void) SetWhitespaceHandling(PRUint8 aWhitespaceHandling);
    1: 
    1: protected:
13259:   friend class CharacterIterator;
    1: 
13259:   // Use a power of 2 here. It's not so important to match
13259:   // nsIDeviceContext::AppUnitsPerDevPixel, but since we do a lot of
13259:   // multiplying by 1/GetTextRunUnitsFactor, it's good for it to be a
13259:   // power of 2 to avoid accuracy loss.
13259:   static PRUint32 GetTextRunUnitsFactor() { return 64; }
    1:   
13259:   /**
13259:    * @aParam aDrawScale font drawing must be scaled into user units
13259:    * by this factor
13259:    * @param aMetricsScale font metrics must be scaled into user units
13259:    * by this factor
13259:    * @param aForceGlobalTransform set to true if we should force use of
13259:    * the global transform; otherwise we won't use the global transform
13259:    * if we're a NONDISPLAY_CHILD
13259:    */
13259:   PRBool EnsureTextRun(float *aDrawScale, float *aMetricsScale,
13259:                        PRBool aForceGlobalTransform);
13259:   void ClearTextRun();
  630: 
    1:   PRBool GetCharacterData(nsAString & aCharacterData);
13259:   PRBool GetCharacterPositions(nsTArray<CharacterPosition>* aCharacterPositions,
13259:                                float aMetricsScale);
  630: 
13259:   void AddCharactersToPath(CharacterIterator *aIter,
13259:                            gfxContext *aContext);
13259:   void AddBoundingBoxesToPath(CharacterIterator *aIter,
13259:                               gfxContext *aContext);
13259:   void FillCharacters(CharacterIterator *aIter,
13259:                       gfxContext *aContext);
    1: 
14042:   void NotifyGlyphMetricsChange();
18367:   PRBool ContainsPoint(const nsPoint &aPoint);
13760:   PRBool GetGlobalTransform(gfxMatrix *aMatrix);
13760:   void SetupGlobalTransform(gfxContext *aContext);
    1:   nsresult GetHighlight(PRUint32 *charnum, PRUint32 *nchars,
    1:                         nscolor *foreground, nscolor *background);
25840:   const nsTextFragment* GetFragment() const
25840:   {
25840:     return !(GetStateBits() & NS_STATE_SVG_PRINTING) ?
26295:       mContent->GetText() : nsLayoutUtils::GetTextFragmentForPrinting(this);
25840:   }
    1: 
13259:   // Owning pointer, must call gfxTextRunWordCache::RemoveTextRun before deleting
13259:   gfxTextRun *mTextRun;
  630:   gfxPoint mPosition;
    1:   PRUint8 mWhitespaceHandling;
    1: };
    1: 
    1: #endif
