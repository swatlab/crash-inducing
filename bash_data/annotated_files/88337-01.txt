    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* vim: set sw=2 ts=2 et tw=78: */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 1998
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Travis Bogard <travis@netscape.com>
    1:  *   Brendan Eich <brendan@mozilla.org>
    1:  *   David Hyatt (hyatt@netscape.com)
    1:  *   Dan Rosen <dr@netscape.com>
    1:  *   Vidur Apparao <vidur@netscape.com>
    1:  *   Johnny Stenback <jst@netscape.com>
    1:  *   Mark Hammond <mhammond@skippinet.com.au>
    1:  *   Ryan Jones <sciguyryan@gmail.com>
10976:  *   Jeff Walden <jwalden+code@mit.edu>
64411:  *   Ben Bucksch <ben.bucksch  beonex.com>
72734:  *   Emanuele Costa <emanuele.costa@gmail.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
46852: #include "base/basictypes.h"
46852: 
80467: /* This must occur *after* base/basictypes.h to avoid typedefs conflicts. */
80467: #include "mozilla/Util.h"
80467: 
    1: // Local Includes
    1: #include "nsGlobalWindow.h"
81313: #include "Navigator.h"
    1: #include "nsScreen.h"
    1: #include "nsHistory.h"
72298: #include "nsPerformance.h"
72298: #include "nsDOMNavigationTiming.h"
    1: #include "nsBarProps.h"
    1: #include "nsDOMStorage.h"
 1938: #include "nsDOMOfflineResourceList.h"
    1: #include "nsDOMError.h"
    1: 
    1: // Helper Classes
    1: #include "nsXPIDLString.h"
    1: #include "nsJSUtils.h"
    1: #include "prmem.h"
    1: #include "jsapi.h"              // for JSAutoRequest
    1: #include "jsdbgapi.h"           // for JS_ClearWatchPointsForObject
80154: #include "jsfriendapi.h"        // for JS_GetGlobalForFrame
    1: #include "nsReadableUtils.h"
    1: #include "nsDOMClassInfo.h"
62725: #include "nsJSEnvironment.h"
64411: #include "nsCharSeparatedTokenizer.h" // for Accept-Language parsing
64411: #include "nsUnicharUtils.h"
70840: #include "mozilla/Preferences.h"
    1: 
    1: // Other Classes
72328: #include "nsEventListenerManager.h"
    1: #include "nsEscape.h"
    1: #include "nsStyleCoord.h"
    1: #include "nsMimeTypeArray.h"
    1: #include "nsNetUtil.h"
 3239: #include "nsICachingChannel.h"
    1: #include "nsPluginArray.h"
    1: #include "nsIPluginHost.h"
70185: #include "nsPluginHost.h"
70185: #include "nsIPluginInstanceOwner.h"
15958: #include "nsGeolocation.h"
52355: #include "nsDesktopNotification.h"
    1: #include "nsContentCID.h"
    1: #include "nsLayoutStatics.h"
    1: #include "nsCycleCollector.h"
 1353: #include "nsCCUncollectableMarker.h"
37802: #include "nsAutoJSValHolder.h"
68769: #include "nsDOMMediaQueryList.h"
74337: #include "mozilla/dom/workers/Workers.h"
    1: 
    1: // Interfaces Needed
29018: #include "nsIFrame.h"
34149: #include "nsCanvasFrame.h"
    1: #include "nsIWidget.h"
    1: #include "nsIBaseWindow.h"
72018: #include "nsDeviceMotion.h"
    1: #include "nsIContent.h"
    1: #include "nsIContentViewerEdit.h"
    1: #include "nsIDocShell.h"
    1: #include "nsIDocShellLoadInfo.h"
    1: #include "nsIDocShellTreeItem.h"
    1: #include "nsIDocShellTreeNode.h"
29018: #include "nsIEditorDocShell.h"
    1: #include "nsIDocCharset.h"
    1: #include "nsIDocument.h"
    1: #include "nsIHTMLDocument.h"
    1: #include "nsIDOMHTMLDocument.h"
    1: #include "nsIDOMHTMLElement.h"
54925: #ifndef MOZ_DISABLE_DOMCRYPTO
    1: #include "nsIDOMCrypto.h"
54925: #endif
    1: #include "nsIDOMDocument.h"
    1: #include "nsIDOMElement.h"
    1: #include "nsIDOMEvent.h"
41071: #include "nsIDOMHTMLAnchorElement.h"
    1: #include "nsIDOMKeyEvent.h"
10976: #include "nsIDOMMessageEvent.h"
    1: #include "nsIDOMPopupBlockedEvent.h"
37802: #include "nsIDOMPopStateEvent.h"
68729: #include "nsIDOMHashChangeEvent.h"
 1938: #include "nsIDOMOfflineResourceList.h"
16677: #include "nsIDOMGeoGeolocation.h"
52355: #include "nsIDOMDesktopNotification.h"
37608: #include "nsPIDOMStorage.h"
    1: #include "nsDOMString.h"
    1: #include "nsIEmbeddingSiteWindow2.h"
    1: #include "nsThreadUtils.h"
68780: #include "nsEventStateManager.h"
    1: #include "nsIHttpProtocolHandler.h"
    1: #include "nsIJSContextStack.h"
    1: #include "nsIJSRuntimeService.h"
    1: #include "nsIMarkupDocumentViewer.h"
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIPrivateDOMEvent.h"
    1: #include "nsIProgrammingLanguage.h"
    1: #include "nsIServiceManager.h"
    1: #include "nsIScriptGlobalObjectOwner.h"
    1: #include "nsIScriptSecurityManager.h"
37063: #include "nsIScrollableFrame.h"
    1: #include "nsIView.h"
    1: #include "nsIViewManager.h"
    1: #include "nsISelectionController.h"
    1: #include "nsISelection.h"
    1: #include "nsIPrompt.h"
42304: #include "nsIPromptService.h"
57937: #include "nsIPromptFactory.h"
57937: #include "nsIWritablePropertyBag2.h"
    1: #include "nsIWebNavigation.h"
    1: #include "nsIWebBrowser.h"
    1: #include "nsIWebBrowserChrome.h"
    1: #include "nsIWebBrowserFind.h"  // For window.find()
    1: #include "nsIWebContentHandlerRegistrar.h"
    1: #include "nsIWindowMediator.h"  // For window.find()
30385: #include "nsComputedDOMStyle.h"
    1: #include "nsIEntropyCollector.h"
    1: #include "nsDOMCID.h"
    1: #include "nsDOMError.h"
    1: #include "nsDOMWindowUtils.h"
    1: #include "nsIWindowWatcher.h"
    1: #include "nsPIWindowWatcher.h"
    1: #include "nsIContentViewer.h"
    1: #include "nsIJSNativeInitializer.h"
    1: #include "nsIScriptError.h"
    1: #include "nsIConsoleService.h"
 6910: #include "nsIControllers.h"
    1: #include "nsIControllerContext.h"
    1: #include "nsGlobalWindowCommands.h"
    1: #include "nsAutoPtr.h"
    1: #include "nsContentUtils.h"
    1: #include "nsCSSProps.h"
87152: #include "nsBlobProtocolHandler.h"
53994: #include "nsIDOMFile.h"
75350: #include "nsIDOMFileList.h"
    1: #include "nsIURIFixup.h"
41653: #include "mozilla/FunctionTimer.h"
    1: #include "nsCDefaultURIFixup.h"
    1: #include "nsEventDispatcher.h"
    1: #include "nsIObserverService.h"
 3041: #include "nsIXULAppInfo.h"
    1: #include "nsNetUtil.h"
29018: #include "nsFocusManager.h"
47945: #include "nsIXULWindow.h"
60229: #include "nsEventStateManager.h"
72986: #include "nsITimedChannel.h"
74805: #include "nsICookiePermission.h"
88107: #include "nsServiceManagerUtils.h"
 3799: #ifdef MOZ_XUL
 3129: #include "nsXULPopupManager.h"
30327: #include "nsIDOMXULControlElement.h"
71258: #include "nsMenuPopupFrame.h"
 3799: #endif
    1: 
57556: #include "xpcprivate.h"
    1: 
    1: #ifdef NS_PRINTING
    1: #include "nsIPrintSettings.h"
    1: #include "nsIPrintSettingsService.h"
    1: #include "nsIWebBrowserPrint.h"
    1: #endif
    1: 
    1: #include "nsWindowRoot.h"
    1: #include "nsNetCID.h"
    1: #include "nsIArray.h"
    1: #include "nsIScriptRuntime.h"
    1: 
    1: // XXX An unfortunate dependency exists here (two XUL files).
    1: #include "nsIDOMXULDocument.h"
    1: #include "nsIDOMXULCommandDispatcher.h"
    1: 
    1: #include "nsBindingManager.h"
    1: #include "nsIXBLService.h"
    1: 
    1: // used for popup blocking, needs to be converted to something
    1: // belonging to the back-end like nsIContentPolicy
    1: #include "nsIPopupWindowManager.h"
    1: 
13279: #include "nsIDragService.h"
41930: #include "mozilla/dom/Element.h"
42412: #include "nsFrameLoader.h"
42340: #include "nsISupportsPrimitives.h"
42340: #include "nsXPCOMCID.h"
10989: 
42480: #include "mozilla/FunctionTimer.h"
61353: #include "mozIThirdPartyUtil.h"
42480: 
    1: #ifdef MOZ_LOGGING
    1: // so we can get logging even in release builds
    1: #define FORCE_PR_LOG 1
    1: #endif
    1: #include "prlog.h"
74872: #include "prenv.h"
    1: 
46347: #include "mozilla/dom/indexedDB/IDBFactory.h"
56112: #include "mozilla/dom/indexedDB/IndexedDatabaseManager.h"
44204: 
75350: #include "mozilla/dom/StructuredCloneTags.h"
75350: 
50698: #include "nsRefreshDriver.h"
64121: #include "mozAutoDocUpdate.h"
50698: 
72923: #include "mozilla/Telemetry.h"
74762: #include "nsLocation.h"
80074: #include "nsWrapperCacheInlines.h"
72923: 
82109: #ifdef ANDROID
82109: #include <android/log.h>
82109: #endif
82109: 
    1: #ifdef PR_LOGGING
    1: static PRLogModuleInfo* gDOMLeakPRLog;
    1: #endif
    1: 
55110: static const char kStorageEnabled[] = "dom.storage.enabled";
55110: 
70840: using namespace mozilla;
41634: using namespace mozilla::dom;
48032: using mozilla::TimeStamp;
48032: using mozilla::TimeDuration;
41634: 
22689: nsIDOMStorageList *nsGlobalWindow::sGlobalStorageList  = nsnull;
72691: nsGlobalWindow::WindowByIdTable *nsGlobalWindow::sWindowsById = nsnull;
76293: bool nsGlobalWindow::sWarnedAboutWindowInternal = false;
    1: 
    1: static nsIEntropyCollector *gEntropyCollector          = nsnull;
    1: static PRInt32              gRefCnt                    = 0;
    1: static PRInt32              gOpenPopupSpamCount        = 0;
    1: static PopupControlState    gPopupControlState         = openAbused;
    1: static PRInt32              gRunningTimeoutDepth       = 0;
79445: static bool                 gMouseDown                 = false;
79445: static bool                 gDragServiceDisabled       = false;
27826: static FILE                *gDumpFile                  = nsnull;
42108: static PRUint64             gNextWindowID              = 0;
11785: static PRUint32             gSerialCounter             = 0;
11785: 
    1: #ifdef DEBUG_jst
    1: PRInt32 gTimeoutCnt                                    = 0;
    1: #endif
    1: 
21376: #if !(defined(NS_DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
79445: static bool                 gDOMWindowDumpEnabled      = false;
21376: #endif
21376: 
    1: #if defined(DEBUG_bryner) || defined(DEBUG_chb)
    1: #define DEBUG_PAGE_CACHE
    1: #endif
    1: 
88107: #define DOM_TOUCH_LISTENER_ADDED "dom-touch-listener-added"
88107: 
60635: // The default shortest interval/timeout we permit
64522: #define DEFAULT_MIN_TIMEOUT_VALUE 4 // 4ms
63938: #define DEFAULT_MIN_BACKGROUND_TIMEOUT_VALUE 1000 // 1000ms
60635: static PRInt32 gMinTimeoutValue;
63938: static PRInt32 gMinBackgroundTimeoutValue;
63938: inline PRInt32
63938: nsGlobalWindow::DOMMinTimeoutValue() const {
79445:   bool isBackground = !mOuterWindow || mOuterWindow->IsBackground();
63938:   return
63938:     NS_MAX(isBackground ? gMinBackgroundTimeoutValue : gMinTimeoutValue, 0);
60635: }
    1: 
34729: // The number of nested timeouts before we start clamping. HTML5 says 1, WebKit
34729: // uses 5.
34729: #define DOM_CLAMP_TIMEOUT_NESTING_LEVEL 5
34729: 
    1: // The longest interval (as PRIntervalTime) we permit, or that our
    1: // timer code can handle, really. See DELAY_INTERVAL_LIMIT in
    1: // nsTimerImpl.h for details.
70324: #define DOM_MAX_TIMEOUT_VALUE    DELAY_INTERVAL_LIMIT
    1: 
    1: #define FORWARD_TO_OUTER(method, args, err_rval)                              \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsInnerWindow()) {                                                      \
55729:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
    1:     if (!outer) {                                                             \
    1:       NS_WARNING("No outer window available!");                               \
    1:       return err_rval;                                                        \
    1:     }                                                                         \
    1:     return outer->method args;                                                \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
    1: #define FORWARD_TO_OUTER_VOID(method, args)                                   \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsInnerWindow()) {                                                      \
55729:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
    1:     if (!outer) {                                                             \
    1:       NS_WARNING("No outer window available!");                               \
    1:       return;                                                                 \
    1:     }                                                                         \
    1:     outer->method args;                                                       \
    1:     return;                                                                   \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
    1: #define FORWARD_TO_OUTER_CHROME(method, args, err_rval)                       \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsInnerWindow()) {                                                      \
55729:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
    1:     if (!outer) {                                                             \
    1:       NS_WARNING("No outer window available!");                               \
    1:       return err_rval;                                                        \
    1:     }                                                                         \
55729:     return ((nsGlobalChromeWindow *)outer)->method args;                      \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
42412: #define FORWARD_TO_INNER_CHROME(method, args, err_rval)                       \
42412:   PR_BEGIN_MACRO                                                              \
42412:   if (IsOuterWindow()) {                                                      \
42412:     if (!mInnerWindow) {                                                      \
42412:       NS_WARNING("No inner window available!");                               \
42412:       return err_rval;                                                        \
42412:     }                                                                         \
42412:     return ((nsGlobalChromeWindow *)mInnerWindow)->method args;               \
42412:   }                                                                           \
42412:   PR_END_MACRO
42412: 
 4040: #define FORWARD_TO_OUTER_MODAL_CONTENT_WINDOW(method, args, err_rval)         \
 4040:   PR_BEGIN_MACRO                                                              \
 4040:   if (IsInnerWindow()) {                                                      \
55729:     nsGlobalWindow *outer = GetOuterWindowInternal();                         \
 4040:     if (!outer) {                                                             \
 4040:       NS_WARNING("No outer window available!");                               \
 4040:       return err_rval;                                                        \
 4040:     }                                                                         \
55729:     return ((nsGlobalModalWindow *)outer)->method args;                       \
 4040:   }                                                                           \
 4040:   PR_END_MACRO
 4040: 
    1: #define FORWARD_TO_INNER(method, args, err_rval)                              \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsOuterWindow()) {                                                      \
    1:     if (!mInnerWindow) {                                                      \
    1:       NS_WARNING("No inner window available!");                               \
    1:       return err_rval;                                                        \
    1:     }                                                                         \
    1:     return GetCurrentInnerWindowInternal()->method args;                      \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
 4040: #define FORWARD_TO_INNER_MODAL_CONTENT_WINDOW(method, args, err_rval)         \
 4040:   PR_BEGIN_MACRO                                                              \
 4040:   if (IsOuterWindow()) {                                                      \
 4040:     if (!mInnerWindow) {                                                      \
 4040:       NS_WARNING("No inner window available!");                               \
 4040:       return err_rval;                                                        \
 4040:     }                                                                         \
 4040:     return ((nsGlobalModalWindow*)GetCurrentInnerWindowInternal())->method args; \
 4040:   }                                                                           \
 4040:   PR_END_MACRO
 4040: 
    1: #define FORWARD_TO_INNER_VOID(method, args)                                   \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsOuterWindow()) {                                                      \
    1:     if (!mInnerWindow) {                                                      \
    1:       NS_WARNING("No inner window available!");                               \
    1:       return;                                                                 \
    1:     }                                                                         \
    1:     GetCurrentInnerWindowInternal()->method args;                             \
    1:     return;                                                                   \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
    1: // Same as FORWARD_TO_INNER, but this will create a fresh inner if an
    1: // inner doesn't already exists.
29474: #define FORWARD_TO_INNER_CREATE(method, args, err_rval)                       \
    1:   PR_BEGIN_MACRO                                                              \
    1:   if (IsOuterWindow()) {                                                      \
    1:     if (!mInnerWindow) {                                                      \
    1:       if (mIsClosed) {                                                        \
29474:         return err_rval;                                                      \
    1:       }                                                                       \
    1:       nsCOMPtr<nsIDOMDocument> doc;                                           \
    1:       nsresult fwdic_nr = GetDocument(getter_AddRefs(doc));                   \
29474:       NS_ENSURE_SUCCESS(fwdic_nr, err_rval);                                  \
    1:       if (!mInnerWindow) {                                                    \
29474:         return err_rval;                                                      \
    1:       }                                                                       \
    1:     }                                                                         \
    1:     return GetCurrentInnerWindowInternal()->method args;                      \
    1:   }                                                                           \
    1:   PR_END_MACRO
    1: 
    1: // CIDs
    1: static NS_DEFINE_CID(kXULControllersCID, NS_XULCONTROLLERS_CID);
    1: 
    1: static const char sJSStackContractID[] = "@mozilla.org/js/xpc/ContextStack;1";
54925: #ifndef MOZ_DISABLE_DOMCRYPTO
    1: static const char kCryptoContractID[] = NS_CRYPTO_CONTRACTID;
    1: static const char kPkcs11ContractID[] = NS_PKCS11_CONTRACTID;
54925: #endif
37802: static const char sPopStatePrefStr[] = "browser.history.allowPopState";
37802: 
 6774: class nsDummyJavaPluginOwner : public nsIPluginInstanceOwner
 6774: {
 6774: public:
 6774:   nsDummyJavaPluginOwner(nsIDocument *aDocument)
 6774:     : mDocument(aDocument)
 6774:   {
 6774:   }
 6774: 
 6774:   void Destroy();
 6774: 
 6774:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 6774:   NS_DECL_NSIPLUGININSTANCEOWNER
 6774: 
36766:   NS_IMETHOD GetURL(const char *aURL, const char *aTarget,
36766:                     nsIInputStream *aPostStream,
36766:                     void *aHeadersData, PRUint32 aHeadersDataLen);
 6774:   NS_IMETHOD ShowStatus(const PRUnichar *aStatusMsg);
32799:   NPError ShowNativeContextMenu(NPMenu* menu, void* event);
32019:   NPBool ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
32019:                       double *destX, double *destY, NPCoordinateSpace destSpace);
36227:   void SendIdleEvent();
 6774: 
 6774:   NS_DECL_CYCLE_COLLECTION_CLASS(nsDummyJavaPluginOwner)
 6774: 
 6774: private:
70007:   nsRefPtr<nsNPAPIPluginInstance> mInstance;
 6774:   nsCOMPtr<nsIDocument> mDocument;
 6774: };
 6774: 
 6774: NS_IMPL_CYCLE_COLLECTION_2(nsDummyJavaPluginOwner, mDocument, mInstance)
 6774: 
 6774: // QueryInterface implementation for nsDummyJavaPluginOwner
 6774: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsDummyJavaPluginOwner)
 6774:   NS_INTERFACE_MAP_ENTRY(nsISupports)
 6774:   NS_INTERFACE_MAP_ENTRY(nsIPluginInstanceOwner)
 6774: NS_INTERFACE_MAP_END
 6774: 
 6774: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsDummyJavaPluginOwner)
 6774: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsDummyJavaPluginOwner)
 6774: 
 6774: 
 6774: void
 6774: nsDummyJavaPluginOwner::Destroy()
 6774: {
 6774:   // If we have a plugin instance, stop it and destroy it now.
 6774:   if (mInstance) {
 6774:     mInstance->Stop();
29834:     mInstance->InvalidateOwner();
 6774:     mInstance = nsnull;
 6774:   }
 6774: 
 6774:   mDocument = nsnull;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
70007: nsDummyJavaPluginOwner::SetInstance(nsNPAPIPluginInstance *aInstance)
 6774: {
58093:   // If we're going to null out mInstance after use, be sure to call
58093:   // mInstance->InvalidateOwner() here, since it now won't be called
58093:   // from nsDummyJavaPluginOwner::Destroy().
58093:   if (mInstance && !aInstance)
58093:     mInstance->InvalidateOwner();
58093: 
 6774:   mInstance = aInstance;
 6774: 
 6774:   return NS_OK;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
70007: nsDummyJavaPluginOwner::GetInstance(nsNPAPIPluginInstance **aInstance)
70007: {
70007:   *aInstance = mInstance;
78894:   NS_IF_ADDREF(*aInstance);
 6774: 
 6774:   return NS_OK;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
32799: nsDummyJavaPluginOwner::GetWindow(NPWindow *&aWindow)
 6774: {
 6774:   aWindow = nsnull;
 6774: 
 6774:   return NS_OK;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
67851: nsDummyJavaPluginOwner::SetWindow()
67851: {
67851:   return NS_ERROR_NOT_IMPLEMENTED;
67851: }
67851: 
67851: NS_IMETHODIMP
32799: nsDummyJavaPluginOwner::GetMode(PRInt32 *aMode)
 6774: {
 6774:   // This is wrong, but there's no better alternative.
32799:   *aMode = NP_EMBED;
 6774: 
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::CreateWidget(void)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::GetURL(const char *aURL, const char *aTarget,
36766:                                nsIInputStream *aPostStream,
36766:                                void *aHeadersData, PRUint32 aHeadersDataLen)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::ShowStatus(const char *aStatusMsg)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::ShowStatus(const PRUnichar *aStatusMsg)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
32019: NPError
32799: nsDummyJavaPluginOwner::ShowNativeContextMenu(NPMenu* menu, void* event)
32019: {
34015:   return NPERR_GENERIC_ERROR;
32019: }
32019: 
32019: NPBool
32019: nsDummyJavaPluginOwner::ConvertPoint(double sourceX, double sourceY, NPCoordinateSpace sourceSpace,
32019:                                      double *destX, double *destY, NPCoordinateSpace destSpace)
32019: {
80486:   return false;
32019: }
32019: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::GetDocument(nsIDocument **aDocument)
 6774: {
 6774:   NS_IF_ADDREF(*aDocument = mDocument);
 6774: 
 6774:   return NS_OK;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
32799: nsDummyJavaPluginOwner::InvalidateRect(NPRect *invalidRect)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
32799: nsDummyJavaPluginOwner::InvalidateRegion(NPRegion invalidRegion)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
 6774: nsDummyJavaPluginOwner::ForceRedraw()
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
 6774: NS_IMETHODIMP
29834: nsDummyJavaPluginOwner::GetNetscapeWindow(void *value)
 6774: {
 6774:   return NS_ERROR_NOT_IMPLEMENTED;
 6774: }
 6774: 
34717: NS_IMETHODIMP
34717: nsDummyJavaPluginOwner::SetEventModel(PRInt32 eventModel)
34717: {
34717:   return NS_ERROR_NOT_IMPLEMENTED;
34717: }
34717: 
36227: void
36227: nsDummyJavaPluginOwner::SendIdleEvent()
36227: {
36227: }
36227: 
    1: /**
58023:  * An object implementing the window.URL property.
58023:  */
58023: class nsDOMMozURLProperty : public nsIDOMMozURLProperty
58023: {
58023: public:
58023:   nsDOMMozURLProperty(nsGlobalWindow* aWindow)
58023:     : mWindow(aWindow)
58023:   {
58023:   }
58023: 
58023:   NS_DECL_ISUPPORTS
58023:   NS_DECL_NSIDOMMOZURLPROPERTY
58023: 
58023:   void ClearWindowReference() {
58023:     mWindow = nsnull;
58023:   }
58023: private:
58023:   nsGlobalWindow* mWindow;
58023: };
58023: 
58023: DOMCI_DATA(MozURLProperty, nsDOMMozURLProperty)
58023: NS_IMPL_ADDREF(nsDOMMozURLProperty)
58023: NS_IMPL_RELEASE(nsDOMMozURLProperty)
58023: NS_INTERFACE_MAP_BEGIN(nsDOMMozURLProperty)
58023:     NS_INTERFACE_MAP_ENTRY(nsIDOMMozURLProperty)
58023:     NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIDOMMozURLProperty)
58023:     NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(MozURLProperty)
58023: NS_INTERFACE_MAP_END
58023: 
58023: NS_IMETHODIMP
58023: nsDOMMozURLProperty::CreateObjectURL(nsIDOMBlob* aBlob, nsAString& aURL)
58023: {
58023:   NS_PRECONDITION(!mWindow || mWindow->IsInnerWindow(),
58023:                   "Should be inner window");
58023: 
58023:   NS_ENSURE_STATE(mWindow && mWindow->mDoc);
58023:   NS_ENSURE_ARG_POINTER(aBlob);
58023: 
58023:   nsIDocument* doc = mWindow->mDoc;
58023: 
58023:   nsresult rv = aBlob->GetInternalUrl(doc->NodePrincipal(), aURL);
58023:   NS_ENSURE_SUCCESS(rv, rv);
58023: 
58023:   doc->RegisterFileDataUri(NS_LossyConvertUTF16toASCII(aURL));
58023: 
58023:   return NS_OK;
58023: }
58023: 
58023: NS_IMETHODIMP
58023: nsDOMMozURLProperty::RevokeObjectURL(const nsAString& aURL)
58023: {
58023:   NS_PRECONDITION(!mWindow || mWindow->IsInnerWindow(),
58023:                   "Should be inner window");
58023: 
58023:   NS_ENSURE_STATE(mWindow);
58023: 
58023:   NS_LossyConvertUTF16toASCII asciiurl(aURL);
58023: 
58023:   nsIPrincipal* winPrincipal = mWindow->GetPrincipal();
58023:   if (!winPrincipal) {
58023:     return NS_OK;
58023:   }
58023: 
58023:   nsIPrincipal* principal =
87152:     nsBlobProtocolHandler::GetFileDataEntryPrincipal(asciiurl);
79445:   bool subsumes;
58023:   if (principal && winPrincipal &&
58023:       NS_SUCCEEDED(winPrincipal->Subsumes(principal, &subsumes)) &&
58023:       subsumes) {
58023:     if (mWindow->mDoc) {
58023:       mWindow->mDoc->UnregisterFileDataUri(asciiurl);
58023:     }
87152:     nsBlobProtocolHandler::RemoveFileDataEntry(asciiurl);
58023:   }
58023: 
58023:   return NS_OK;
58023: }
58023: 
58023: /**
    1:  * An indirect observer object that means we don't have to implement nsIObserver
    1:  * on nsGlobalWindow, where any script could see it.
    1:  */
    1: class nsGlobalWindowObserver : public nsIObserver {
    1: public:
    1:   nsGlobalWindowObserver(nsGlobalWindow* aWindow) : mWindow(aWindow) {}
    1:   NS_DECL_ISUPPORTS
    1:   NS_IMETHOD Observe(nsISupports* aSubject, const char* aTopic, const PRUnichar* aData)
    1:   {
    1:     if (!mWindow)
    1:       return NS_OK;
    1:     return mWindow->Observe(aSubject, aTopic, aData);
    1:   }
    1:   void Forget() { mWindow = nsnull; }
    1: private:
    1:   nsGlobalWindow* mWindow;
    1: };
    1: 
    1: NS_IMPL_ISUPPORTS1(nsGlobalWindowObserver, nsIObserver)
    1: 
    1: nsTimeout::nsTimeout()
    1: {
    1: #ifdef DEBUG_jst
    1:   {
    1:     extern int gTimeoutCnt;
    1: 
    1:     ++gTimeoutCnt;
    1:   }
    1: #endif
    1: 
    1:   memset(this, 0, sizeof(*this));
    1: 
    1:   MOZ_COUNT_CTOR(nsTimeout);
    1: }
    1: 
    1: nsTimeout::~nsTimeout()
    1: {
    1: #ifdef DEBUG_jst
    1:   {
    1:     extern int gTimeoutCnt;
    1: 
    1:     --gTimeoutCnt;
    1:   }
    1: #endif
    1: 
    1:   MOZ_COUNT_DTOR(nsTimeout);
    1: }
    1: 
24195: NS_IMPL_CYCLE_COLLECTION_CLASS(nsTimeout)
24195: NS_IMPL_CYCLE_COLLECTION_UNLINK_NATIVE_0(nsTimeout)
24195: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_BEGIN(nsTimeout)
24195:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mWindow,
24195:                                                        nsIScriptGlobalObject)
24195:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrincipal)
24195:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mScriptHandler)
24195: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
24195: NS_IMPL_CYCLE_COLLECTION_ROOT_NATIVE(nsTimeout, AddRef)
24195: NS_IMPL_CYCLE_COLLECTION_UNROOT_NATIVE(nsTimeout, Release)
24195: 
41409: nsPIDOMWindow::nsPIDOMWindow(nsPIDOMWindow *aOuterWindow)
41409: : mFrameElement(nsnull), mDocShell(nsnull), mModalStateDepth(0),
80486:   mRunningTimeout(nsnull), mMutationBits(0), mIsDocumentLoaded(false),
80486:   mIsHandlingResizeEvent(false), mIsInnerWindow(aOuterWindow != nsnull),
80486:   mMayHavePaintEventListener(false), mMayHaveTouchEventListener(false),
80486:   mMayHaveMouseEnterLeaveEventListener(false),
80486:   mIsModalContentWindow(false),
80486:   mIsActive(false), mIsBackground(false),
63938:   mInnerWindow(nsnull), mOuterWindow(aOuterWindow),
56273:   // Make sure no actual window ends up with mWindowID == 0
80486:   mWindowID(++gNextWindowID), mHasNotifiedGlobalCreated(false)
56273:  {}
41409: 
41409: nsPIDOMWindow::~nsPIDOMWindow() {}
    1: 
    1: //*****************************************************************************
55577: // nsOuterWindowProxy: Outer Window Proxy
55577: //*****************************************************************************
55577: 
55577: JSString *
55577: nsOuterWindowProxy::obj_toString(JSContext *cx, JSObject *proxy)
55577: {
79734:     JS_ASSERT(js::IsProxy(proxy));
55577: 
55671:     return JS_NewStringCopyZ(cx, "[object Window]");
55577: }
55577: 
80415: void
80415: nsOuterWindowProxy::finalize(JSContext *cx, JSObject *proxy)
80415: {
80415:   nsISupports *global =
80415:     static_cast<nsISupports*>(js::GetProxyExtra(proxy, 0).toPrivate());
80415:   if (global) {
80415:     nsWrapperCache *cache;
80415:     CallQueryInterface(global, &cache);
80415:     cache->ClearWrapperIfProxy();
80415:   }
80415: }
80415: 
55577: nsOuterWindowProxy
55577: nsOuterWindowProxy::singleton;
55577: 
55577: JSObject *
55577: NS_NewOuterWindowProxy(JSContext *cx, JSObject *parent)
55577: {
55601:   JSAutoEnterCompartment ac;
55601:   if (!ac.enter(cx, parent)) {
55601:     return nsnull;
55601:   }
55601: 
79734:   JSObject *obj = js::Wrapper::New(cx, parent, js::GetObjectProto(parent), parent,
55577:                                    &nsOuterWindowProxy::singleton);
79734:   NS_ASSERTION(js::GetObjectClass(obj)->ext.innerObject, "bad class");
55577:   return obj;
55577: }
55577: 
55577: //*****************************************************************************
    1: //***    nsGlobalWindow: Object Management
    1: //*****************************************************************************
    1: 
    1: nsGlobalWindow::nsGlobalWindow(nsGlobalWindow *aOuterWindow)
    1:   : nsPIDOMWindow(aOuterWindow),
80486:     mIsFrozen(false),
80486:     mDidInitJavaProperties(false),
80486:     mFullScreen(false),
80486:     mIsClosed(false), 
80486:     mInClose(false), 
80486:     mHavePendingClose(false),
80486:     mHadOriginalOpener(false),
80486:     mIsPopupSpam(false),
80486:     mBlockScriptedClosingFlag(false),
80486:     mFireOfflineStatusChangeEventOnThaw(false),
80486:     mCreatingInnerWindow(false),
80486:     mIsChrome(false),
80486:     mCleanMessageManager(false),
80486:     mNeedsFocus(true),
80486:     mHasFocus(false),
69620: #if defined(XP_MACOSX)
80486:     mShowAccelerators(false),
80486:     mShowFocusRings(false),
41071: #else
80486:     mShowAccelerators(true),
80486:     mShowFocusRings(true),
41071: #endif
80486:     mShowFocusRingForContent(false),
80486:     mFocusByKeyOccurred(false),
80486:     mHasDeviceMotion(false),
80486:     mNotifiedIDDestroyed(false),
    1:     mTimeoutInsertionPoint(nsnull),
    1:     mTimeoutPublicIdCounter(1),
    1:     mTimeoutFiringDepth(0),
    1:     mJSObject(nsnull),
37833:     mPendingStorageEventsObsolete(nsnull),
29018:     mTimeoutsSuspendDepth(0),
52336:     mFocusMethod(0),
54231:     mSerial(0),
    1: #ifdef DEBUG
80486:     mSetOpenerWindowCalled(false),
    1: #endif
80486:     mCleanedUp(false),
80486:     mCallCleanUpAfterModalDialogCloses(false),
54231:     mDialogAbuseCount(0),
80486:     mDialogDisabled(false)
    1: {
    1:   nsLayoutStatics::AddRef();
    1: 
    1:   // Initialize the PRCList (this).
    1:   PR_INIT_CLIST(this);
    1: 
    1:   // Initialize timeout storage
    1:   PR_INIT_CLIST(&mTimeouts);
    1: 
    1:   if (aOuterWindow) {
    1:     // |this| is an inner window, add this inner window to the outer
    1:     // window list of inners.
    1:     PR_INSERT_AFTER(this, aOuterWindow);
    1: 
    1:     mObserver = new nsGlobalWindowObserver(this);
    1:     if (mObserver) {
    1:       NS_ADDREF(mObserver);
41540:       nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
    1:       if (os) {
    1:         // Watch for online/offline status changes so we can fire events. Use
    1:         // a strong reference.
    1:         os->AddObserver(mObserver, NS_IOSERVICE_OFFLINE_STATUS_TOPIC,
80486:                         false);
    1: 
27004:         // Watch for dom-storage-changed so we can fire storage
    1:         // events. Use a strong reference.
80486:         os->AddObserver(mObserver, "dom-storage2-changed", false);
80486:         os->AddObserver(mObserver, "dom-storage-changed", false);
    1:       }
    1:     }
    1:   } else {
    1:     // |this| is an outer window. Outer windows start out frozen and
    1:     // remain frozen until they get an inner window, so freeze this
    1:     // outer window here.
    1:     Freeze();
    1: 
    1:     mObserver = nsnull;
55577:     SetIsProxy();
    1:   }
    1: 
    1:   // We could have failed the first time through trying
    1:   // to create the entropy collector, so we should
    1:   // try to get one until we succeed.
21376: 
21376:   gRefCnt++;
21376: 
60635:   if (gRefCnt == 1) {
21376: #if !(defined(NS_DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
71001:     Preferences::AddBoolVarCache(&gDOMWindowDumpEnabled,
71001:                                  "browser.dom.window.dump.enabled");
21376: #endif
71001:     Preferences::AddIntVarCache(&gMinTimeoutValue,
71001:                                 "dom.min_timeout_value",
60635:                                 DEFAULT_MIN_TIMEOUT_VALUE);
71001:     Preferences::AddIntVarCache(&gMinBackgroundTimeoutValue,
71001:                                 "dom.min_background_timeout_value",
63938:                                 DEFAULT_MIN_BACKGROUND_TIMEOUT_VALUE);
60635:   }
21376: 
27826:   if (gDumpFile == nsnull) {
27826:     const nsAdoptingCString& fname =
70976:       Preferences::GetCString("browser.dom.window.dump.file");
27826:     if (!fname.IsEmpty()) {
27826:       // if this fails to open, Dump() knows to just go to stdout
27826:       // on null.
27826:       gDumpFile = fopen(fname, "wb+");
27826:     } else {
27826:       gDumpFile = stdout;
27826:     }
27826:   }
27826: 
52336:   mSerial = ++gSerialCounter;
52336: 
    1: #ifdef DEBUG
74872:   if (!PR_GetEnv("MOZ_QUIET")) {
14743:     printf("++DOMWINDOW == %d (%p) [serial = %d] [outer = %p]\n", gRefCnt,
12416:            static_cast<void*>(static_cast<nsIScriptGlobalObject*>(this)),
52336:            gSerialCounter, static_cast<void*>(aOuterWindow));
74872:   }
    1: #endif
    1: 
    1: #ifdef PR_LOGGING
    1:   if (gDOMLeakPRLog)
    1:     PR_LOG(gDOMLeakPRLog, PR_LOG_DEBUG,
    1:            ("DOMWINDOW %p created outer=%p", this, aOuterWindow));
    1: #endif
72691: 
77579:   NS_ASSERTION(sWindowsById, "Windows hash table must be created!");
72691:   NS_ASSERTION(!sWindowsById->Get(mWindowID),
72691:                "This window shouldn't be in the hash table yet!");
72691:   sWindowsById->Put(mWindowID, this);
72691: }
77579: 
77579: /* static */
77579: void
77579: nsGlobalWindow::Init()
77579: {
77579:   CallGetService(NS_ENTROPYCOLLECTOR_CONTRACTID, &gEntropyCollector);
77579:   NS_ASSERTION(gEntropyCollector,
77579:                "gEntropyCollector should have been initialized!");
77579: 
77579: #ifdef PR_LOGGING
77579:   gDOMLeakPRLog = PR_NewLogModule("DOMLeak");
77579:   NS_ASSERTION(gDOMLeakPRLog, "gDOMLeakPRLog should have been initialized!");
77579: #endif
77579: 
77579:   sWindowsById = new WindowByIdTable();
77579:   // There are two reasons to have Init() failing: if we were not able to
77579:   // alloc the memory or if the size we want to init is too high. None of them
77579:   // should happen.
77579: #ifdef DEBUG
77579:   NS_ASSERTION(sWindowsById->Init(), "Init() should not fail!");
77579: #else
77579:   sWindowsById->Init();
77579: #endif
    1: }
    1: 
    1: nsGlobalWindow::~nsGlobalWindow()
    1: {
72691:   // We have to check if sWindowsById isn't null because ::Shutdown might have
72691:   // been called.
72691:   if (sWindowsById) {
72691:     NS_ASSERTION(sWindowsById->Get(mWindowID),
72691:                  "This window should be in the hash table");
72691:     sWindowsById->Remove(mWindowID);
56274:   }
77579: 
77699:   --gRefCnt;
77699: 
    1: #ifdef DEBUG
74872:   if (!PR_GetEnv("MOZ_QUIET")) {
14743:     nsCAutoString url;
14743:     if (mLastOpenedURI) {
14743:       mLastOpenedURI->GetSpec(url);
14743:     }
14743: 
14743:     printf("--DOMWINDOW == %d (%p) [serial = %d] [outer = %p] [url = %s]\n",
12416:            gRefCnt, static_cast<void*>(static_cast<nsIScriptGlobalObject*>(this)),
55729:            mSerial, static_cast<void*>(mOuterWindow.get()), url.get());
74872:   }
    1: #endif
    1: 
    1: #ifdef PR_LOGGING
    1:   if (gDOMLeakPRLog)
    1:     PR_LOG(gDOMLeakPRLog, PR_LOG_DEBUG,
    1:            ("DOMWINDOW %p destroyed", this));
    1: #endif
    1: 
    1:   if (IsOuterWindow()) {
80415:     JSObject *proxy = GetWrapperPreserveColor();
80415:     if (proxy) {
80415:       js::SetProxyExtra(proxy, 0, js::PrivateValue(NULL));
80415:     }
80415: 
    1:     // An outer window is destroyed with inner windows still possibly
38439:     // alive, iterate through the inner windows and null out their
38439:     // back pointer to this outer, and pull them out of the list of
38439:     // inner windows.
    1: 
    1:     nsGlobalWindow *w;
    1:     while ((w = (nsGlobalWindow *)PR_LIST_HEAD(this)) != this) {
    1:       PR_REMOVE_AND_INIT_LINK(w);
    1:     }
    1:   } else {
80393:     Telemetry::Accumulate(Telemetry::INNERWINDOWS_WITH_MUTATION_LISTENERS,
80393:                           mMutationBits ? 1 : 0);
80393: 
    1:     if (mListenerManager) {
    1:       mListenerManager->Disconnect();
    1:       mListenerManager = nsnull;
    1:     }
    1: 
    1:     // An inner window is destroyed, pull it out of the outer window's
    1:     // list if inner windows.
    1: 
    1:     PR_REMOVE_LINK(this);
    1: 
    1:     // If our outer window's inner window is this window, null out the
    1:     // outer window's reference to this window that's being deleted.
    1:     nsGlobalWindow *outer = GetOuterWindowInternal();
    1:     if (outer && outer->mInnerWindow == this) {
    1:       outer->mInnerWindow = nsnull;
    1:     }
    1:   }
    1: 
    1:   mDocument = nsnull;           // Forces Release
    1:   mDoc = nsnull;
    1: 
    1:   NS_ASSERTION(!mArguments, "mArguments wasn't cleaned up properly!");
38439: 
80486:   CleanUp(true);
38439: 
38439: #ifdef DEBUG
38439:   nsCycleCollector_DEBUG_wasFreed(static_cast<nsIScriptGlobalObject*>(this));
38439: #endif
38439: 
58023:   if (mURLProperty) {
58023:     mURLProperty->ClearWindowReference();
58023:   }
58023: 
76835:   DisableDeviceMotionUpdates();
80486:   mHasDeviceMotion = false;
76835: 
38439:   nsLayoutStatics::Release();
38439: }
38439: 
38439: // static
38439: void
38439: nsGlobalWindow::ShutDown()
38439: {
38439:   NS_IF_RELEASE(sGlobalStorageList);
38439: 
38439:   if (gDumpFile && gDumpFile != stdout) {
38439:     fclose(gDumpFile);
38439:   }
38439:   gDumpFile = nsnull;
72691: 
77579:   NS_IF_RELEASE(gEntropyCollector);
77579: 
72691:   delete sWindowsById;
72691:   sWindowsById = nsnull;
38439: }
38439: 
38439: // static
38439: void
38439: nsGlobalWindow::CleanupCachedXBLHandlers(nsGlobalWindow* aWindow)
38439: {
38439:   if (aWindow->mCachedXBLPrototypeHandlers.IsInitialized() &&
38439:       aWindow->mCachedXBLPrototypeHandlers.Count() > 0) {
38439:     aWindow->mCachedXBLPrototypeHandlers.Clear();
38439: 
57794:     nsISupports* supports;
38439:     aWindow->QueryInterface(NS_GET_IID(nsCycleCollectionISupports),
57794:                             reinterpret_cast<void**>(&supports));
38439:     NS_ASSERTION(supports, "Failed to QI to nsCycleCollectionISupports?!");
38439: 
38439:     nsContentUtils::DropJSObjects(supports);
38439:   }
38439: }
38439: 
38439: void
39378: nsGlobalWindow::MaybeForgiveSpamCount()
39378: {
39378:   if (IsOuterWindow() &&
39378:       IsPopupSpamWindow())
39378:   {
80486:     SetPopupSpamWindow(false);
39378:     --gOpenPopupSpamCount;
39378:     NS_ASSERTION(gOpenPopupSpamCount >= 0,
39378:                  "Unbalanced decrement of gOpenPopupSpamCount");
39378:   }
39378: }
39378: 
39378: void
79445: nsGlobalWindow::CleanUp(bool aIgnoreModalDialog)
39378: {
39378:   if (IsOuterWindow() && !aIgnoreModalDialog) {
39378:     nsGlobalWindow* inner = GetCurrentInnerWindowInternal();
77547:     nsCOMPtr<nsIDOMModalContentWindow> dlg(do_QueryObject(inner));
39378:     if (dlg) {
39378:       // The window we're trying to clean up is the outer window of a
39378:       // modal dialog.  Defer cleanup until the window closes, and let
39378:       // ShowModalDialog take care of calling CleanUp.
80486:       mCallCleanUpAfterModalDialogCloses = true;
39378:       return;
39378:     }
39378:   }
39378: 
39378:   // Guarantee idempotence.
39378:   if (mCleanedUp)
39378:     return;
80486:   mCleanedUp = true;
39378: 
61999:   if (mObserver) {
61999:     nsCOMPtr<nsIObserverService> os = mozilla::services::GetObserverService();
61999:     if (os) {
61999:       os->RemoveObserver(mObserver, NS_IOSERVICE_OFFLINE_STATUS_TOPIC);
61999:       os->RemoveObserver(mObserver, "dom-storage2-changed");
61999:       os->RemoveObserver(mObserver, "dom-storage-changed");
61999:     }
61999: 
61999:     // Drop its reference to this dying window, in case for some bogus reason
61999:     // the object stays around.
61999:     mObserver->Forget();
61999:     NS_RELEASE(mObserver);
61999:   }
61999: 
    1:   mNavigator = nsnull;
    1:   mScreen = nsnull;
    1:   mMenubar = nsnull;
    1:   mToolbar = nsnull;
    1:   mLocationbar = nsnull;
    1:   mPersonalbar = nsnull;
    1:   mStatusbar = nsnull;
    1:   mScrollbars = nsnull;
    1:   mLocation = nsnull;
61735:   mHistory = nsnull;
    1:   mFrames = nsnull;
10340:   mApplicationCache = nsnull;
44204:   mIndexedDB = nsnull;
61999:   mPendingStorageEventsObsolete = nsnull;
60680: 
72298:   mPerformance = nsnull;
    1: 
    1:   ClearControllers();
    1: 
    1:   mOpener = nsnull;             // Forces Release
    1:   if (mContext) {
 6016: #ifdef DEBUG
 6016:     nsCycleCollector_DEBUG_shouldBeFreed(mContext);
 6016: #endif
    1:     mContext = nsnull;            // Forces Release
    1:   }
    1:   mChromeEventHandler = nsnull; // Forces Release
43679:   mParentTarget = nsnull;
    1: 
    1:   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
    1: 
    1:   if (inner) {
39378:     inner->CleanUp(aIgnoreModalDialog);
    1:   }
    1: 
61147:   if (mCleanMessageManager) {
61147:     NS_ABORT_IF_FALSE(mIsChrome, "only chrome should have msg manager cleaned");
61147:     nsGlobalChromeWindow *asChrome = static_cast<nsGlobalChromeWindow*>(this);
61147:     if (asChrome->mMessageManager) {
43461:       static_cast<nsFrameMessageManager*>(
61147:         asChrome->mMessageManager.get())->Disconnect();
61147:     }
43461:   }
43461: 
47537:   mInnerWindowHolder = nsnull;
    1:   mArguments = nsnull;
    1:   mArgumentsLast = nsnull;
33525:   mArgumentsOrigin = nsnull;
    1: 
11622:   CleanupCachedXBLHandlers(this);
11622: 
    1: #ifdef DEBUG
 3233:   nsCycleCollector_DEBUG_shouldBeFreed(static_cast<nsIScriptGlobalObject*>(this));
    1: #endif
    1: }
    1: 
    1: void
    1: nsGlobalWindow::ClearControllers()
    1: {
    1:   if (mControllers) {
    1:     PRUint32 count;
    1:     mControllers->GetControllerCount(&count);
    1: 
    1:     while (count--) {
    1:       nsCOMPtr<nsIController> controller;
    1:       mControllers->GetControllerAt(count, getter_AddRefs(controller));
    1: 
    1:       nsCOMPtr<nsIControllerContext> context = do_QueryInterface(controller);
    1:       if (context)
    1:         context->SetCommandContext(nsnull);
    1:     }
    1: 
    1:     mControllers = nsnull;
    1:   }
    1: }
    1: 
61409: // static
    1: void
61409: nsGlobalWindow::TryClearWindowScope(nsISupports *aWindow)
61409: {
61409:   nsGlobalWindow *window =
61409:           static_cast<nsGlobalWindow *>(static_cast<nsIDOMWindow*>(aWindow));
61409: 
61409:   // This termination function might be called when any script evaluation in our
61409:   // context terminated, even if there are other scripts in the stack. Thus, we
61409:   // have to check again if a script is executing and post a new termination
61409:   // function if necessary.
61409:   window->ClearScopeWhenAllScriptsStop();
61409: }
61409: 
61409: void
61409: nsGlobalWindow::ClearScopeWhenAllScriptsStop()
35152: {
35152:   NS_ASSERTION(IsInnerWindow(), "Must be an inner window");
35152: 
61409:   // We cannot clear scope safely until all the scripts in our script context
61409:   // stopped. This might be a long wait, for example if one script is busy
61409:   // because it started a nested event loop for a modal dialog.
35152:   nsIScriptContext *jsscx = GetContextInternal();
35152:   if (jsscx && jsscx->GetExecutingScript()) {
61409:     // We ignore the return value because the only reason that we clear scope
61409:     // here is to try to prevent leaks. Failing to clear scope might mean that
61409:     // we'll leak more but if we don't have enough memory to allocate a
61409:     // termination function we probably don't have to worry about this anyway.
61409:     jsscx->SetTerminationFunction(TryClearWindowScope,
61409:                                   static_cast<nsIDOMWindow *>(this));
35152:     return;
35152:   }
35152: 
42340:   NotifyWindowIDDestroyed("inner-window-destroyed");
47538:   nsIScriptContext *scx = GetContextInternal();
47538:   if (scx) {
80486:     scx->ClearScope(mJSObject, true);
    1:   }
    1: }
    1: 
35152: void
79445: nsGlobalWindow::FreeInnerObjects(bool aClearScope)
35152: {
35152:   NS_ASSERTION(IsInnerWindow(), "Don't free inner objects on an outer window");
35152: 
83058:   // Make sure that this is called before we null out the document and
83058:   // other members that the window destroyed observers could
83058:   // re-create.
83058:   NotifyDOMWindowDestroyed(this);
83058: 
35152:   // Kill all of the workers for this window.
35152:   nsIScriptContext *scx = GetContextInternal();
78415:   JSContext *cx = scx ? scx->GetNativeContext() : nsnull;
74337:   mozilla::dom::workers::CancelWorkersForWindow(cx, this);
35152: 
56112:   // Close all IndexedDB databases for this window.
56112:   indexedDB::IndexedDatabaseManager* idbManager =
56112:     indexedDB::IndexedDatabaseManager::Get();
56112:   if (idbManager) {
61407:     idbManager->AbortCloseDatabasesForWindow(this);
56112:   }
56112: 
35152:   ClearAllTimeouts();
35152: 
35152:   mChromeEventHandler = nsnull;
35152: 
35152:   if (mListenerManager) {
35152:     mListenerManager->Disconnect();
35152:     mListenerManager = nsnull;
35152:   }
35152: 
50477:   mLocation = nsnull;
61735:   mHistory = nsnull;
50477: 
83058:   if (mNavigator) {
83058:     mNavigator->Invalidate();
83058:     mNavigator = nsnull;
83058:   }
83058: 
35152:   if (mDocument) {
35152:     NS_ASSERTION(mDoc, "Why is mDoc null?");
35152: 
35152:     // Remember the document's principal.
35152:     mDocumentPrincipal = mDoc->NodePrincipal();
35152:   }
35152: 
35152: #ifdef DEBUG
35152:   if (mDocument)
35152:     nsCycleCollector_DEBUG_shouldBeFreed(nsCOMPtr<nsISupports>(do_QueryInterface(mDocument)));
35152: #endif
35152: 
35152:   // Remove our reference to the document and the document principal.
35152:   mDocument = nsnull;
35152:   mDoc = nsnull;
35152: 
35152:   if (mApplicationCache) {
35152:     static_cast<nsDOMOfflineResourceList*>(mApplicationCache.get())->Disconnect();
35152:     mApplicationCache = nsnull;
35152:   }
35152: 
44204:   mIndexedDB = nsnull;
44204: 
35152:   if (aClearScope) {
61409:     ClearScopeWhenAllScriptsStop();
35152:   }
35152: 
 6774:   if (mDummyJavaPluginOwner) {
 6774:     // Tear down the dummy java plugin.
 6774: 
 6774:     // XXXjst: On a general note, should windows with java stuff in
 6774:     // them ever even make it into the fast-back cache?
 6774: 
 6774:     mDummyJavaPluginOwner->Destroy();
 6774:     mDummyJavaPluginOwner = nsnull;
87652:     mDidInitJavaProperties = false;
 6774:   }
 6774: 
11622:   CleanupCachedXBLHandlers(this);
11622: 
    1: #ifdef DEBUG
 3233:   nsCycleCollector_DEBUG_shouldBeFreed(static_cast<nsIScriptGlobalObject*>(this));
    1: #endif
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsISupports
    1: //*****************************************************************************
    1: 
55577: #define OUTER_WINDOW_ONLY                                                     \
55577:   if (IsOuterWindow()) {
55577: 
55577: #define END_OUTER_WINDOW_ONLY                                                 \
55577:     foundInterface = 0;                                                       \
55577:   } else
55577: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGlobalWindow)
    1: 
40490: DOMCI_DATA(Window, nsGlobalWindow)
40490: 
12033: // QueryInterface implementation for nsGlobalWindow
12033: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsGlobalWindow)
12033:   // Make sure this matches the cast in nsGlobalWindow::FromWrapper()
12033:   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIScriptGlobalObject)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMWindow)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMJSWindow)
76293:   if (aIID.Equals(NS_GET_IID(nsIDOMWindowInternal))) {
76293:     foundInterface = static_cast<nsIDOMWindowInternal*>(this);
76293:     if (!sWarnedAboutWindowInternal) {
76293:       sWarnedAboutWindowInternal = true;
84636:       nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
84636:                                       "Extensions", mDoc,
84636:                                       nsContentUtils::eDOM_PROPERTIES,
84636:                                       "nsIDOMWindowInternalWarning");
76293:     }
76293:   } else
12033:   NS_INTERFACE_MAP_ENTRY(nsIScriptGlobalObject)
12033:   NS_INTERFACE_MAP_ENTRY(nsIScriptObjectPrincipal)
12033:   NS_INTERFACE_MAP_ENTRY(nsIDOMEventTarget)
12033:   NS_INTERFACE_MAP_ENTRY(nsPIDOMWindow)
60385:   NS_INTERFACE_MAP_ENTRY(nsIDOMStorageIndexedDB)
12033:   NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
12033:   NS_INTERFACE_MAP_ENTRY(nsIInterfaceRequestor)
72298:   NS_INTERFACE_MAP_ENTRY(nsIDOMWindowPerformance)
77146:   NS_INTERFACE_MAP_ENTRY(nsITouchEventReceiver)
77149:   NS_INTERFACE_MAP_ENTRY(nsIInlineEventHandlers)
55578:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(Window)
55577:   OUTER_WINDOW_ONLY
55577:     NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
55577:   END_OUTER_WINDOW_ONLY
12033: NS_INTERFACE_MAP_END
12033: 
12033: 
67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsGlobalWindow)
67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsGlobalWindow)
    1: 
88265: static PLDHashOperator
88265: MarkXBLHandlers(const void* aKey, JSObject* aData, void* aClosure)
88265: {
88265:   xpc_UnmarkGrayObject(aData);
88265:   return PL_DHASH_NEXT;
88265: }
88265: 
88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_BEGIN(nsGlobalWindow)
88265:   if (tmp->IsBlackForCC()) {
88265:     if (tmp->mCachedXBLPrototypeHandlers.IsInitialized()) {
88265:       tmp->mCachedXBLPrototypeHandlers.EnumerateRead(MarkXBLHandlers, nsnull);
88265:     }
88265:     return true;
88265:   }
88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_END
88265: 
88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_BEGIN(nsGlobalWindow)
88265:   return tmp->IsBlackForCC();
88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_IN_CC_END
88265: 
88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_BEGIN(nsGlobalWindow)
88265:   return tmp->IsBlackForCC();
88265: NS_IMPL_CYCLE_COLLECTION_CAN_SKIP_THIS_END
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsGlobalWindow)
88265:   if (!cb.WantAllTraces() && tmp->IsBlackForCC()) {
25691:     return NS_SUCCESS_INTERRUPTED_TRAVERSE;
 1353:   }
 1353: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mControllers)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mArguments)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mArgumentsLast)
    1: 
47537:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mInnerWindowHolder)
55729:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOuterWindow)
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOpenerScriptPrincipal)
72328:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NATIVE_MEMBER(mListenerManager,
72328:                                                   nsEventListenerManager)
24195: 
24195:   for (nsTimeout* timeout = tmp->FirstTimeout();
24195:        tmp->IsTimeout(timeout);
24195:        timeout = timeout->Next()) {
24195:     cb.NoteNativeChild(timeout, &NS_CYCLE_COLLECTION_NAME(nsTimeout));
24195:   }
24195: 
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mSessionStorage)
10340:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mApplicationCache)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocumentPrincipal)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDoc)
    1: 
    1:   // Traverse stuff from nsPIDOMWindow
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mChromeEventHandler)
43679:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mParentTarget)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDocument)
27191:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFrameElement)
 6774: 
 6774:   // Traverse mDummyJavaPluginOwner
 6774:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mDummyJavaPluginOwner)
 6774: 
29018:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mFocusedNode)
29018: 
60680:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMARRAY(mPendingStorageEvents)
60680: 
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsGlobalWindow)
67680:   nsGlobalWindow::CleanupCachedXBLHandlers(tmp);
67680: 
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContext)
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mControllers)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mArguments)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mArgumentsLast)
    1: 
47537:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mInnerWindowHolder)
55729:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOuterWindow)
    1: 
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOpenerScriptPrincipal)
72139:   if (tmp->mListenerManager) {
72139:     tmp->mListenerManager->Disconnect();
    1:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mListenerManager)
72139:   }
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mSessionStorage)
10340:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mApplicationCache)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocumentPrincipal)
72139:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDoc)
    1: 
    1:   // Unlink stuff from nsPIDOMWindow
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mChromeEventHandler)
43679:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mParentTarget)
    1:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDocument)
27191:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFrameElement)
 6774: 
 6774:   // Unlink mDummyJavaPluginOwner
 6774:   if (tmp->mDummyJavaPluginOwner) {
 6774:     tmp->mDummyJavaPluginOwner->Destroy();
 6774:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mDummyJavaPluginOwner)
87652:     tmp->mDidInitJavaProperties = false;
 6774:   }
 6774: 
29018:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mFocusedNode)
29018: 
60680:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMARRAY(mPendingStorageEvents)
60680: 
    1: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
    1: 
11622: struct TraceData
11622: {
11622:   TraceData(TraceCallback& aCallback, void* aClosure) :
11622:     callback(aCallback), closure(aClosure) {}
11622: 
11622:   TraceCallback& callback;
11622:   void* closure;
11622: };
11622: 
20261: static PLDHashOperator
82804: TraceXBLHandlers(const void* aKey, JSObject* aData, void* aClosure)
11622: {
11622:   TraceData* data = static_cast<TraceData*>(aClosure);
69023:   data->callback(nsIProgrammingLanguage::JAVASCRIPT, aData,
69023:                  "Cached XBL prototype handler", data->closure);
11622:   return PL_DHASH_NEXT;
11622: }
11622: 
11622: NS_IMPL_CYCLE_COLLECTION_TRACE_BEGIN(nsGlobalWindow)
11622:   if (tmp->mCachedXBLPrototypeHandlers.IsInitialized()) {
11622:     TraceData data(aCallback, aClosure);
11622:     tmp->mCachedXBLPrototypeHandlers.EnumerateRead(TraceXBLHandlers, &data);
11622:   }
11622: NS_IMPL_CYCLE_COLLECTION_TRACE_END
11622: 
88265: bool
88265: nsGlobalWindow::IsBlackForCC()
88265: {
88265:   return
88265:     (mDoc &&
88265:      nsCCUncollectableMarker::InGeneration(mDoc->GetMarkedCCGeneration())) ||
88265:     (nsCCUncollectableMarker::sGeneration && IsBlack());
88265: }
88265: 
88265: void
88265: nsGlobalWindow::UnmarkGrayTimers()
88265: {
88265:   for (nsTimeout* timeout = FirstTimeout();
88265:        timeout && IsTimeout(timeout);
88265:        timeout = timeout->Next()) {
88265:     if (timeout->mScriptHandler) {
88265:       JSObject* o = timeout->mScriptHandler->GetScriptObject();
88265:       xpc_UnmarkGrayObject(o);
88265:     }
88265:   }
88265: }
88265: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIScriptGlobalObject
    1: //*****************************************************************************
    1: 
    1: nsresult
    1: nsGlobalWindow::SetScriptContext(PRUint32 lang_id, nsIScriptContext *aScriptContext)
    1: {
47537:   NS_ASSERTION(lang_id == nsIProgrammingLanguage::JAVASCRIPT,
47537:                "We don't support this language ID");
    1:   NS_ASSERTION(IsOuterWindow(), "Uh, SetScriptContext() called on inner window!");
    1: 
48477:   NS_ASSERTION(!aScriptContext || !mContext, "Bad call to SetContext()!");
48477: 
48477:   if (aScriptContext) {
    1:     // should probably assert the context is clean???
    1:     aScriptContext->WillInitializeContext();
47537: 
48477:     nsresult rv = aScriptContext->InitContext();
    1:     NS_ENSURE_SUCCESS(rv, rv);
48477: 
    1:     if (IsFrame()) {
    1:       // This window is a [i]frame, don't bother GC'ing when the
    1:       // frame's context is destroyed since a GC will happen when the
    1:       // frameset or host document is destroyed anyway.
    1: 
80486:       aScriptContext->SetGCOnDestruction(false);
    1:     }
    1:   }
47537: 
    1:   mContext = aScriptContext;
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::EnsureScriptEnvironment(PRUint32 aLangID)
    1: {
47537:   NS_ASSERTION(aLangID == nsIProgrammingLanguage::JAVASCRIPT,
47537:                "We don't support this language ID");
    1:   FORWARD_TO_OUTER(EnsureScriptEnvironment, (aLangID), NS_ERROR_NOT_INITIALIZED);
47537: 
47537:   if (mJSObject)
47537:       return NS_OK;
47537: 
48477:   NS_ASSERTION(!GetCurrentInnerWindowInternal(),
48477:                "mJSObject is null, but we have an inner window?");
47540: 
    1:   nsCOMPtr<nsIScriptRuntime> scriptRuntime;
47537:   nsresult rv = NS_GetScriptRuntimeByID(aLangID, getter_AddRefs(scriptRuntime));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
82293:   nsCOMPtr<nsIScriptContext> context = scriptRuntime->CreateContext();
47537:   return SetScriptContext(aLangID, context);
    1: }
    1: 
    1: nsIScriptContext *
    1: nsGlobalWindow::GetScriptContext(PRUint32 lang)
    1: {
47537:   NS_ASSERTION(lang == nsIProgrammingLanguage::JAVASCRIPT,
47537:                "We don't support this language ID");
47537: 
    1:   FORWARD_TO_OUTER(GetScriptContext, (lang), nsnull);
47537:   return mContext;
    1: }
    1: 
    1: nsIScriptContext *
    1: nsGlobalWindow::GetContext()
    1: {
    1:   FORWARD_TO_OUTER(GetContext, (), nsnull);
    1: 
    1:   // check GetContext is indeed identical to GetScriptContext()
    1:   NS_ASSERTION(mContext == GetScriptContext(nsIProgrammingLanguage::JAVASCRIPT),
    1:                "GetContext confused?");
    1:   return mContext;
    1: }
    1: 
    1: JSObject *
    1: nsGlobalWindow::GetGlobalJSObject()
    1: {
47412:   return FastGetGlobalJSObject();
44204: }
    1: 
79445: bool
    1: nsGlobalWindow::WouldReuseInnerWindow(nsIDocument *aNewDocument)
    1: {
    1:   // We reuse the inner window when:
    1:   // a. We are currently at our original document.
    1:   // b. At least one of the following conditions are true:
    1:   // -- We are not currently a content window (i.e., we're currently a chrome
    1:   //    window).
    1:   // -- The new document is the same as the old document. This means that we're
    1:   //    getting called from document.open().
    1:   // -- The new document has the same origin as what we have loaded right now.
    1: 
    1:   if (!mDoc || !aNewDocument) {
80486:     return false;
    1:   }
    1: 
    1:   if (!mDoc->IsInitialDocument()) {
80486:     return false;
    1:   }
    1:   
78530:   NS_ASSERTION(NS_IsAboutBlank(mDoc->GetDocumentURI()),
    1:                "How'd this happen?");
    1:   
    1:   // Great, we're the original document, check for one of the other
    1:   // conditions.
    1:   if (mDoc == aNewDocument) {
    1:     // aClearScopeHint is false.
80486:     return true;
    1:   }
    1: 
79445:   bool equal;
 3286:   if (NS_SUCCEEDED(mDoc->NodePrincipal()->Equals(aNewDocument->NodePrincipal(),
 3286:                                                  &equal)) &&
 3286:       equal) {
    1:     // The origin is the same.
80486:     return true;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(mDocShell));
    1: 
    1:   if (treeItem) {
    1:     PRInt32 itemType = nsIDocShellTreeItem::typeContent;
    1:     treeItem->GetItemType(&itemType);
    1: 
    1:     // If we're a chrome window, then we want to reuse the inner window.
    1:     return itemType == nsIDocShellTreeItem::typeChrome;
    1:   }
    1: 
    1:   // No treeItem: don't reuse the current inner window.
80486:   return false;
    1: }
    1: 
    1: void
    1: nsGlobalWindow::SetOpenerScriptPrincipal(nsIPrincipal* aPrincipal)
    1: {
    1:   FORWARD_TO_OUTER_VOID(SetOpenerScriptPrincipal, (aPrincipal));
    1: 
    1:   if (mDoc) {
    1:     if (!mDoc->IsInitialDocument()) {
    1:       // We have a document already, and it's not the original one.  Bail out.
    1:       // Do NOT set mOpenerScriptPrincipal in this case, just to be safe.
    1:       return;
    1:     }
    1: 
    1: #ifdef DEBUG
    1:     // We better have an about:blank document loaded at this point.  Otherwise,
    1:     // something is really weird.
    1:     nsCOMPtr<nsIURI> uri;
    1:     mDoc->NodePrincipal()->GetURI(getter_AddRefs(uri));
78530:     NS_ASSERTION(uri && NS_IsAboutBlank(uri) &&
78530:                  NS_IsAboutBlank(mDoc->GetDocumentURI()),
    1:                  "Unexpected original document");
    1: #endif
    1: 
63886:     GetDocShell()->CreateAboutBlankContentViewer(aPrincipal);
80486:     mDoc->SetIsInitialDocument(true);
63545: 
63545:     nsCOMPtr<nsIPresShell> shell;
63545:     GetDocShell()->GetPresShell(getter_AddRefs(shell));
63545: 
63545:     if (shell && !shell->DidInitialReflow()) {
63545:       // Ensure that if someone plays with this document they will get
63545:       // layout happening.
63545:       nsRect r = shell->GetPresContext()->GetVisibleArea();
63545:       shell->InitialReflow(r.width, r.height);
63545:     }
55593:   }
    1: }
    1: 
    1: nsIPrincipal*
    1: nsGlobalWindow::GetOpenerScriptPrincipal()
    1: {
    1:   FORWARD_TO_OUTER(GetOpenerScriptPrincipal, (), nsnull);
    1: 
    1:   return mOpenerScriptPrincipal;
    1: }
    1: 
    1: PopupControlState
79445: PushPopupControlState(PopupControlState aState, bool aForce)
    1: {
    1:   PopupControlState oldState = gPopupControlState;
    1: 
    1:   if (aState < gPopupControlState || aForce) {
    1:     gPopupControlState = aState;
    1:   }
    1: 
    1:   return oldState;
    1: }
    1: 
    1: void
    1: PopPopupControlState(PopupControlState aState)
    1: {
    1:   gPopupControlState = aState;
    1: }
    1: 
    1: PopupControlState
    1: nsGlobalWindow::PushPopupControlState(PopupControlState aState,
79445:                                       bool aForce) const
    1: {
    1:   return ::PushPopupControlState(aState, aForce);
    1: }
    1: 
    1: void
    1: nsGlobalWindow::PopPopupControlState(PopupControlState aState) const
    1: {
    1:   ::PopPopupControlState(aState);
    1: }
    1: 
    1: PopupControlState
    1: nsGlobalWindow::GetPopupControlState() const
    1: {
    1:   return gPopupControlState;
    1: }
    1: 
    1: #define WINDOWSTATEHOLDER_IID \
    1: {0x0b917c3e, 0xbd50, 0x4683, {0xaf, 0xc9, 0xc7, 0x81, 0x07, 0xae, 0x33, 0x26}}
    1: 
    1: class WindowStateHolder : public nsISupports
    1: {
    1: public:
    1:   NS_DECLARE_STATIC_IID_ACCESSOR(WINDOWSTATEHOLDER_IID)
    1:   NS_DECL_ISUPPORTS
    1: 
    1:   WindowStateHolder(nsGlobalWindow *aWindow,
47537:                     nsIXPConnectJSObjectHolder *aHolder,
51082:                     nsIXPConnectJSObjectHolder *aOuterProto,
51082:                     nsIXPConnectJSObjectHolder *aOuterRealProto);
    1: 
    1:   nsGlobalWindow* GetInnerWindow() { return mInnerWindow; }
47537:   nsIXPConnectJSObjectHolder *GetInnerWindowHolder()
47537:   { return mInnerWindowHolder; }
    1: 
    1:   nsIXPConnectJSObjectHolder* GetOuterProto() { return mOuterProto; }
51082:   nsIXPConnectJSObjectHolder* GetOuterRealProto() { return mOuterRealProto; }
    1: 
    1:   void DidRestoreWindow()
    1:   {
    1:     mInnerWindow = nsnull;
    1: 
47537:     mInnerWindowHolder = nsnull;
    1:     mOuterProto = nsnull;
51082:     mOuterRealProto = nsnull;
    1:   }
    1: 
    1: protected:
    1:   ~WindowStateHolder();
    1: 
    1:   nsGlobalWindow *mInnerWindow;
    1:   // We hold onto this to make sure the inner window doesn't go away. The outer
    1:   // window ends up recalculating it anyway.
47537:   nsCOMPtr<nsIXPConnectJSObjectHolder> mInnerWindowHolder;
    1:   nsCOMPtr<nsIXPConnectJSObjectHolder> mOuterProto;
51082:   nsCOMPtr<nsIXPConnectJSObjectHolder> mOuterRealProto;
    1: };
    1: 
    1: NS_DEFINE_STATIC_IID_ACCESSOR(WindowStateHolder, WINDOWSTATEHOLDER_IID)
    1: 
    1: WindowStateHolder::WindowStateHolder(nsGlobalWindow *aWindow,
47537:                                      nsIXPConnectJSObjectHolder *aHolder,
51082:                                      nsIXPConnectJSObjectHolder *aOuterProto,
51082:                                      nsIXPConnectJSObjectHolder *aOuterRealProto)
    1:   : mInnerWindow(aWindow),
51082:     mOuterProto(aOuterProto),
51082:     mOuterRealProto(aOuterRealProto)
    1: {
    1:   NS_PRECONDITION(aWindow, "null window");
    1:   NS_PRECONDITION(aWindow->IsInnerWindow(), "Saving an outer window");
    1: 
47537:   mInnerWindowHolder = aHolder;
29018: 
    1:   aWindow->SuspendTimeouts();
    1: }
    1: 
    1: WindowStateHolder::~WindowStateHolder()
    1: {
    1:   if (mInnerWindow) {
    1:     // This window was left in the bfcache and is now going away. We need to
    1:     // free it up.
    1:     // Note that FreeInnerObjects may already have been called on the
    1:     // inner window if its outer has already had SetDocShell(null)
    1:     // called.  In this case the contexts will all be null and the
80486:     // true for aClearScope won't do anything; this is OK since
    1:     // SetDocShell(null) already did it.
80486:     mInnerWindow->FreeInnerObjects(true);
    1:   }
    1: }
    1: 
    1: NS_IMPL_ISUPPORTS1(WindowStateHolder, WindowStateHolder)
    1: 
80660: 
80660: struct ReparentWaiverClosure
80660: {
80660:   JSContext *mCx;
80660:   JSObject *mNewInner;
80660: };
80660: 
80660: static JSDHashOperator
80660: ReparentWaiverWrappers(JSDHashTable *table, JSDHashEntryHdr *hdr,
80660:                        uint32 number, void *arg)
80660: {
80660:     ReparentWaiverClosure *closure = static_cast<ReparentWaiverClosure*>(arg);
80660:     JSObject *value = static_cast<JSObject2JSObjectMap::Entry *>(hdr)->value;
80660: 
80660:     // We reparent wrappers that have as their parent an inner window whose
80660:     // outer has the new inner window as its current inner.
80660:     JSObject *parent = JS_GetParent(closure->mCx, value);
80660:     JSObject *outer = JS_ObjectToOuterObject(closure->mCx, parent);
80660:     if (outer) {
80660:       JSObject *inner = JS_ObjectToInnerObject(closure->mCx, outer);
80660:       if (inner == closure->mNewInner && inner != parent)
80660:         JS_SetParent(closure->mCx, value, closure->mNewInner);
80660:     } else {
80660:       JS_ClearPendingException(closure->mCx);
80660:     }
80660:     return JS_DHASH_NEXT;
80660: }
80660: 
    1: nsresult
    1: nsGlobalWindow::SetNewDocument(nsIDocument* aDocument,
53996:                                nsISupports* aState,
79445:                                bool aForceReuseInnerWindow)
39376: {
41653:   NS_TIME_FUNCTION;
41653: 
39376:   NS_PRECONDITION(mDocumentPrincipal == nsnull,
    1:                   "mDocumentPrincipal prematurely set!");
39376: 
39376:   if (!aDocument) {
39376:     NS_ERROR("SetNewDocument(null) called!");
39376: 
39376:     return NS_ERROR_INVALID_ARG;
39376:   }
39376: 
39376:   if (IsInnerWindow()) {
    1:     if (!mOuterWindow) {
    1:       return NS_ERROR_NOT_INITIALIZED;
    1:     }
    1: 
    1:     // Refuse to set a new document if the call came from an inner
    1:     // window that's not the current inner window.
    1:     if (mOuterWindow->GetCurrentInnerWindow() != this) {
    1:       return NS_ERROR_NOT_AVAILABLE;
    1:     }
    1: 
53996:     return GetOuterWindowInternal()->SetNewDocument(aDocument, aState,
53996:                                                     aForceReuseInnerWindow);
39376:   }
39376: 
39376:   NS_PRECONDITION(IsOuterWindow(), "Must only be called on outer windows");
39376: 
39376:   if (IsFrozen()) {
39376:     // This outer is now getting its first inner, thaw the outer now
39376:     // that it's ready and is getting an inner window.
49089: 
39376:     Thaw();
    1:   }
    1: 
    1:   NS_ASSERTION(!GetCurrentInnerWindow() ||
    1:                GetCurrentInnerWindow()->GetExtantDocument() == mDocument,
    1:                "Uh, mDocument doesn't match the current inner window "
    1:                "document!");
    1: 
79445:   bool wouldReuseInnerWindow = WouldReuseInnerWindow(aDocument);
53996:   if (aForceReuseInnerWindow &&
53996:       !wouldReuseInnerWindow &&
53996:       mDoc &&
53996:       mDoc->NodePrincipal() != aDocument->NodePrincipal()) {
53996:     NS_ERROR("Attempted forced inner window reuse while changing principal");
53996:     return NS_ERROR_UNEXPECTED;
53996:   }
53996: 
    1:   nsCOMPtr<nsIDocument> oldDoc(do_QueryInterface(mDocument));
    1: 
    1:   nsIScriptContext *scx = GetContextInternal();
    1:   NS_ENSURE_TRUE(scx, NS_ERROR_NOT_INITIALIZED);
    1: 
78415:   JSContext *cx = scx->GetNativeContext();
54925: #ifndef MOZ_DISABLE_DOMCRYPTO
    1:   // clear smartcard events, our document has gone away.
    1:   if (mCrypto) {
80486:     mCrypto->SetEnableSmartCardEvents(false);
    1:   }
54925: #endif
    1:   if (!mDocument) {
    1:     // First document load.
    1: 
    1:     // Get our private root. If it is equal to us, then we need to
    1:     // attach our global key bindings that handles browser scrolling
    1:     // and other browser commands.
73870:     nsIDOMWindow* privateRoot = nsGlobalWindow::GetPrivateRoot();
73870: 
73870:     if (privateRoot == static_cast<nsIDOMWindow*>(this)) {
    1:       nsCOMPtr<nsIXBLService> xblService = do_GetService("@mozilla.org/xbl;1");
    1:       if (xblService) {
72327:         xblService->AttachGlobalKeyHandler(mChromeEventHandler);
    1:       }
    1:     }
    1:   }
    1: 
42996:   /* No mDocShell means we're already been partially closed down.  When that
42996:      happens, setting status isn't a big requirement, so don't. (Doesn't happen
42996:      under normal circumstances, but bug 49615 describes a case.) */
42996: 
42996:   nsContentUtils::AddScriptRunner(
42996:     NS_NewRunnableMethod(this, &nsGlobalWindow::ClearStatus));
    1: 
79445:   bool reUseInnerWindow = aForceReuseInnerWindow || wouldReuseInnerWindow;
    1: 
    1:   // Remember the old document's principal.
    1:   nsIPrincipal *oldPrincipal = nsnull;
    1:   if (oldDoc) {
    1:     oldPrincipal = oldDoc->NodePrincipal();
    1:   }
    1: 
73870:   nsresult rv = NS_OK;
73870: 
    1:   // Set mDocument even if this is an outer window to avoid
    1:   // having to *always* reach into the inner window to find the
    1:   // document.
    1:   mDocument = do_QueryInterface(aDocument);
    1:   mDoc = aDocument;
    1: 
14743: #ifdef DEBUG
14743:   mLastOpenedURI = aDocument->GetDocumentURI();
14743: #endif
14743: 
47537:   mContext->WillInitializeContext();
    1: 
    1:   nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
    1: 
    1:   nsRefPtr<nsGlobalWindow> newInnerWindow;
    1: 
79445:   bool thisChrome = IsChromeWindow();
    1: 
79445:   bool isChrome = false;
    1: 
21376:   nsCxPusher cxPusher;
21376:   if (!cxPusher.Push(cx)) {
21376:     return NS_ERROR_FAILURE;
21376:   }
21376: 
    1:   JSAutoRequest ar(cx);
    1: 
51082:   nsCOMPtr<WindowStateHolder> wsh = do_QueryInterface(aState);
51082:   NS_ASSERTION(!aState || wsh, "What kind of weird state are you giving me here?");
51082: 
    1:   // Make sure to clear scope on the outer window *before* we
    1:   // initialize the new inner window. If we don't, things
    1:   // (Object.prototype etc) could leak from the old outer to the new
    1:   // inner scope.
80486:   mContext->ClearScope(mJSObject, false);
    1: 
    1:   if (reUseInnerWindow) {
    1:     // We're reusing the current inner window.
    1:     NS_ASSERTION(!currentInner->IsFrozen(),
    1:                  "We should never be reusing a shared inner window");
    1:     newInnerWindow = currentInner;
    1: 
    1:     if (aDocument != oldDoc) {
55578:       nsWindowSH::InvalidateGlobalScopePolluter(cx, currentInner->mJSObject);
    1:     }
62643: 
62643:     // The API we're really looking for here is to go clear all of the
62643:     // Xray wrappers associated with our outer window. However, we
62643:     // don't expose that API because the implementation would be
62643:     // identical to that of JS_TransplantObject, so we just call that
62643:     // instead.
62643:     if (!JS_TransplantObject(cx, mJSObject, mJSObject)) {
62643:       return NS_ERROR_FAILURE;
62643:     }
    1:   } else {
    1:     if (aState) {
    1:       newInnerWindow = wsh->GetInnerWindow();
47537:       mInnerWindowHolder = wsh->GetInnerWindowHolder();
    1: 
51987:       NS_ASSERTION(newInnerWindow, "Got a state without inner window");
51987:     } else if (thisChrome) {
    1:       newInnerWindow = new nsGlobalChromeWindow(this);
80486:       isChrome = true;
51987:     } else if (mIsModalContentWindow) {
 4040:       newInnerWindow = new nsGlobalModalWindow(this);
 4040:     } else {
    1:       newInnerWindow = new nsGlobalWindow(this);
    1:     }
    1: 
    1:     if (!aState) {
    1:       // This is redundant if we're restoring from a previous inner window.
    1:       nsIScriptGlobalObject *sgo =
    1:         (nsIScriptGlobalObject *)newInnerWindow.get();
    1: 
    1:       // Freeze the outer window and null out the inner window so
    1:       // that initializing classes on the new inner doesn't end up
    1:       // reaching into the old inner window for classes etc.
    1:       //
    1:       // [This happens with Object.prototype when XPConnect creates
    1:       // a temporary global while initializing classes; the reason
    1:       // being that xpconnect creates the temp global w/o a parent
    1:       // and proto, which makes the JS engine look up classes in
    1:       // cx->globalObject, i.e. this outer window].
    1: 
    1:       mInnerWindow = nsnull;
    1: 
    1:       Freeze();
80486:       mCreatingInnerWindow = true;
    1:       // Every script context we are initialized with must create a
    1:       // new global.
47537:       nsCOMPtr<nsIXPConnectJSObjectHolder> &holder = mInnerWindowHolder;
47537:       rv = mContext->CreateNativeGlobalForInner(sgo, isChrome,
48503:                                                 aDocument->NodePrincipal(),
82800:                                                 &newInnerWindow->mJSObject,
    1:                                                 getter_AddRefs(holder));
82800:       NS_ASSERTION(NS_SUCCEEDED(rv) && newInnerWindow->mJSObject && holder,
    1:                    "Failed to get script global and holder");
47537: 
80486:       mCreatingInnerWindow = false;
    1:       Thaw();
    1: 
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1:     }
    1: 
    1:     if (currentInner && currentInner->mJSObject) {
79445:       bool termFuncSet = false;
    1: 
    1:       if (oldDoc == aDocument) {
86264:         // Move the navigator from the old inner window to the new one since
86264:         // this is a document.write. This is safe from a same-origin point of
86264:         // view because document.write can only be used by the same origin.
86264:         newInnerWindow->mNavigator = currentInner->mNavigator;
86264:         currentInner->mNavigator = nsnull;
86264:         if (newInnerWindow->mNavigator) {
86264:           newInnerWindow->mNavigator->SetWindow(newInnerWindow);
86264:         }
86264: 
23153:         // Suspend the current context's request before Pop() resumes the old
23153:         // context's request.
23153:         JSAutoSuspendRequest asr(cx);
23153: 
23153:         // Pop our context here so that we get the correct one for the
23153:         // termination function.
23153:         cxPusher.Pop();
23153: 
23153:         JSContext *oldCx = nsContentUtils::GetCurrentJSContext();
    1: 
    1:         nsIScriptContext *callerScx;
23153:         if (oldCx && (callerScx = GetScriptContextFromJSContext(oldCx))) {
    1:           // We're called from document.open() (and document.open() is
    1:           // called from JS), clear the scope etc in a termination
    1:           // function on the calling context to prevent clearing the
    1:           // calling scope.
    1:           NS_ASSERTION(!currentInner->IsFrozen(),
    1:               "How does this opened window get into session history");
    1: 
23153:           JSAutoRequest ar(oldCx);
    1: 
    1:           callerScx->SetTerminationFunction(ClearWindowScope,
 3233:                                             static_cast<nsIDOMWindow *>
 3233:                                                        (currentInner));
    1: 
80486:           termFuncSet = true;
    1:         }
23153: 
23153:         // Re-push our context.
23153:         cxPusher.Push(cx);
    1:       }
    1: 
    1:       // Don't clear scope on our current inner window if it's going to be
    1:       // held in the bfcache.
    1:       if (!currentInner->IsFrozen()) {
    1:         // Skip the ClearScope if we set a termination function to do
    1:         // it ourselves, later.
    1:         currentInner->FreeInnerObjects(!termFuncSet);
    1:       }
    1:     }
    1: 
    1:     mInnerWindow = newInnerWindow;
51078: 
51078:     if (!mJSObject) {
51078:       mContext->CreateOuterObject(this, newInnerWindow);
51078:       mContext->DidInitializeContext();
55577: 
81042:       mJSObject = mContext->GetNativeGlobal();
55577:       SetWrapper(mJSObject);
51078:     } else {
55577:       JSObject *outerObject =
55577:         NS_NewOuterWindowProxy(cx, newInnerWindow->mJSObject);
55577:       if (!outerObject) {
55577:         NS_ERROR("out of memory");
55577:         return NS_ERROR_FAILURE;
55577:       }
55577: 
80415:       js::SetProxyExtra(mJSObject, 0, js::PrivateValue(NULL));
80415: 
58714:       outerObject = JS_TransplantObject(cx, mJSObject, outerObject);
55577:       if (!outerObject) {
55577:         NS_ERROR("unable to transplant wrappers, probably OOM");
55577:         return NS_ERROR_FAILURE;
55577:       }
55577: 
80415:       nsIScriptGlobalObject *global = static_cast<nsIScriptGlobalObject*>(this);
80415:       js::SetProxyExtra(outerObject, 0, js::PrivateValue(global));
80415: 
55577:       mJSObject = outerObject;
55577:       SetWrapper(mJSObject);
55577: 
55604:       {
55604:         JSAutoEnterCompartment ac;
55604:         if (!ac.enter(cx, mJSObject)) {
55604:           NS_ERROR("unable to enter a compartment");
55604:           return NS_ERROR_FAILURE;
55604:         }
55604: 
55604:         JS_SetParent(cx, mJSObject, newInnerWindow->mJSObject);
55604: 
55577:         mContext->SetOuterObject(mJSObject);
80660: 
80660:         JSCompartment *compartment = js::GetObjectCompartment(mJSObject);
80660:         xpc::CompartmentPrivate *priv =
80660:           static_cast<xpc::CompartmentPrivate*>(JS_GetCompartmentPrivate(cx, compartment));
80660:         if (priv && priv->waiverWrapperMap) {
80660:           NS_ASSERTION(!JS_IsExceptionPending(cx),
80660:                        "We might overwrite a pending exception!");
80660:           ReparentWaiverClosure closure = {
80660:             cx,
80660:             newInnerWindow->mJSObject
80660:           };
80660:           priv->waiverWrapperMap->Enumerate(ReparentWaiverWrappers, &closure);
80660:         }
55577:       }
61142:     }
55577: 
55604:     JSAutoEnterCompartment ac;
55604:     if (!ac.enter(cx, mJSObject)) {
55604:       NS_ERROR("unable to enter a compartment");
55604:       return NS_ERROR_FAILURE;
55604:     }
55604: 
55577:     // XXX Not sure if this is needed.
55577:     if (aState) {
51082:       JSObject *proto;
51082:       if (nsIXPConnectJSObjectHolder *holder = wsh->GetOuterRealProto()) {
51082:         holder->GetJSObject(&proto);
51082:       } else {
51082:         proto = nsnull;
51082:       }
51082: 
51082:       if (!JS_SetPrototype(cx, mJSObject, proto)) {
51082:         NS_ERROR("can't set prototype");
51082:         return NS_ERROR_FAILURE;
51082:       }
55583:     } else {
55583:       if (!JS_DefineProperty(cx, newInnerWindow->mJSObject, "window",
55583:                              OBJECT_TO_JSVAL(mJSObject),
62397:                              JS_PropertyStub, JS_StrictPropertyStub,
55583:                              JSPROP_ENUMERATE | JSPROP_READONLY | JSPROP_PERMANENT)) {
55583:         NS_ERROR("can't create the 'window' property");
55583:         return NS_ERROR_FAILURE;
55583:       }
51082:     }
51078:   }
    1: 
61142:   JSAutoEnterCompartment ac;
61142:   if (!ac.enter(cx, mJSObject)) {
61142:     NS_ERROR("unable to enter a compartment");
61142:     return NS_ERROR_FAILURE;
61142:   }
61142: 
    1:   if (!aState && !reUseInnerWindow) {
    1:     // Loading a new page and creating a new inner window, *not*
    1:     // restoring from session history.
    1: 
    1:     // Now that both the the inner and outer windows are initialized
47537:     // let the script context do its magic to hook them together.
47537:     mContext->ConnectToInner(newInnerWindow, mJSObject);
25723: 
25723:     nsCOMPtr<nsIContent> frame = do_QueryInterface(GetFrameElementInternal());
80526:     if (frame && frame->OwnerDoc()) {
80526:       nsPIDOMWindow* parentWindow = frame->OwnerDoc()->GetWindow();
25723:       if (parentWindow && parentWindow->TimeoutSuspendCount()) {
25723:         SuspendTimeouts(parentWindow->TimeoutSuspendCount());
25723:       }
25723:     }
    1:   }
47537: 
    1:   // Add an extra ref in case we release mContext during GC.
47537:   nsCOMPtr<nsIScriptContext> kungFuDeathGrip(mContext);
    1: 
    1:   // Now that the prototype is all set up, install the global scope
    1:   // polluter. This must happen after the above prototype fixup. If
    1:   // the GSP was to be installed on the inner window's real
    1:   // prototype (as it would be if this was done before the prototype
    1:   // fixup above) we would end up holding the GSP alive (through
    1:   // XPConnect's internal marking of wrapper prototypes) as long as
    1:   // the inner window was around, and if the GSP had properties on
    1:   // it that held an element alive we'd hold the document alive,
    1:   // which could hold event handlers alive, which hold the context
    1:   // alive etc.
    1: 
    1:   if ((!reUseInnerWindow || aDocument != oldDoc) && !aState) {
    1:     nsCOMPtr<nsIHTMLDocument> html_doc(do_QueryInterface(mDocument));
55578:     nsWindowSH::InstallGlobalScopePolluter(cx, newInnerWindow->mJSObject,
    1:                                            html_doc);
    1:   }
    1: 
    1:   if (aDocument) {
    1:     aDocument->SetScriptGlobalObject(newInnerWindow);
    1:   }
    1: 
    1:   if (!aState) {
    1:     if (reUseInnerWindow) {
    1:       if (newInnerWindow->mDoc != aDocument) {
    1:         newInnerWindow->mDocument = do_QueryInterface(aDocument);
    1:         newInnerWindow->mDoc = aDocument;
    1: 
    1:         // We're reusing the inner window for a new document. In this
    1:         // case we don't clear the inner window's scope, but we must
    1:         // make sure the cached document property gets updated.
    1: 
    1:         // XXXmarkh - tell other languages about this?
    1:         ::JS_DeleteProperty(cx, currentInner->mJSObject, "document");
87652: 
87652:         if (mDummyJavaPluginOwner) {
87652:           // Since we're reusing the inner window, tear down the
87652:           // dummy Java plugin we created for the old document in
87652:           // this window.
87652:           mDummyJavaPluginOwner->Destroy();
87652:           mDummyJavaPluginOwner = nsnull;
87652: 
87652:           mDidInitJavaProperties = false;
87652:         }
    1:       }
    1:     } else {
39402:       rv = newInnerWindow->InnerSetNewDocument(aDocument);
    1:       NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:       // Initialize DOM classes etc on the inner window.
55604:       rv = mContext->InitClasses(newInnerWindow->mJSObject);
    1:       NS_ENSURE_SUCCESS(rv, rv);
55673:     }
    1: 
    1:     if (mArguments) {
33525:       newInnerWindow->DefineArgumentsProperty(mArguments);
33525:       newInnerWindow->mArguments = mArguments;
33525:       newInnerWindow->mArgumentsOrigin = mArgumentsOrigin;
33525: 
    1:       mArguments = nsnull;
33525:       mArgumentsOrigin = nsnull;
    1:     }
    1: 
    1:     // Give the new inner window our chrome event handler (since it
    1:     // doesn't have one).
    1:     newInnerWindow->mChromeEventHandler = mChromeEventHandler;
    1:   }
    1: 
88182:   mContext->GC(js::gcreason::SET_NEW_DOCUMENT);
47537:   mContext->DidInitializeContext();
44204: 
58025:   if (newInnerWindow && !newInnerWindow->mHasNotifiedGlobalCreated && mDoc) {
58025:     // We should probably notify. However if this is the, arguably bad,
58025:     // situation when we're creating a temporary non-chrome-about-blank
58025:     // document in a chrome docshell, don't notify just yet. Instead wait
58025:     // until we have a real chrome doc.
58025:     nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(mDocShell));
58025:     PRInt32 itemType = nsIDocShellTreeItem::typeContent;
58025:     if (treeItem) {
58025:       treeItem->GetItemType(&itemType);
58025:     }
58025: 
58025:     if (itemType != nsIDocShellTreeItem::typeChrome ||
58025:         nsContentUtils::IsSystemPrincipal(mDoc->NodePrincipal())) {
80486:       newInnerWindow->mHasNotifiedGlobalCreated = true;
43472:       nsContentUtils::AddScriptRunner(
43472:         NS_NewRunnableMethod(this, &nsGlobalWindow::DispatchDOMWindowCreated));
51987:     }
58025:   }
43472: 
43472:   return NS_OK;
43472: }
43472: 
43472: void
43472: nsGlobalWindow::DispatchDOMWindowCreated()
43472: {
47340:   if (!mDoc || !mDocument) {
47340:     return;
47340:   }
47340: 
43472:   // Fire DOMWindowCreated at chrome event listeners
43472:   nsContentUtils::DispatchChromeEvent(mDoc, mDocument, NS_LITERAL_STRING("DOMWindowCreated"),
80486:                                       true /* bubbles */,
80486:                                       false /* not cancellable */);
43472: 
39377:   nsCOMPtr<nsIObserverService> observerService =
41540:     mozilla::services::GetObserverService();
39377:   if (observerService) {
39377:     nsAutoString origin;
43472:     nsIPrincipal* principal = mDoc->NodePrincipal();
39377:     nsContentUtils::GetUTFOrigin(principal, origin);
39377:     observerService->
39377:       NotifyObservers(static_cast<nsIDOMWindow*>(this),
39377:                       nsContentUtils::IsSystemPrincipal(principal) ?
39377:                         "chrome-document-global-created" :
39377:                         "content-document-global-created",
39377:                       origin.get());
39377:   }
39376: }
39376: 
42996: void
42996: nsGlobalWindow::ClearStatus()
42996: {
42996:   SetStatus(EmptyString());
42996:   SetDefaultStatus(EmptyString());
42996: }
42996: 
39376: nsresult
39402: nsGlobalWindow::InnerSetNewDocument(nsIDocument* aDocument)
39376: {
39376:   NS_PRECONDITION(IsInnerWindow(), "Must only be called on inner windows");
39376: 
39376: #ifdef PR_LOGGING
39376:   if (aDocument && gDOMLeakPRLog &&
39376:       PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
39376:     nsIURI *uri = aDocument->GetDocumentURI();
39376:     nsCAutoString spec;
39376:     if (uri)
39376:       uri->GetSpec(spec);
39376:     PR_LogPrint("DOMWINDOW %p SetNewDocument %s", this, spec.get());
39376:   }
39376: #endif
39376: 
39376:   mDocument = do_QueryInterface(aDocument);
39376:   mDoc = aDocument;
39376:   mLocalStorage = nsnull;
39376:   mSessionStorage = nsnull;
39376: 
39376: #ifdef DEBUG
39376:   mLastOpenedURI = aDocument->GetDocumentURI();
39376: #endif
    1: 
80393:   Telemetry::Accumulate(Telemetry::INNERWINDOWS_WITH_MUTATION_LISTENERS,
80393:                         mMutationBits ? 1 : 0);
80393: 
    1:   // Clear our mutation bitfield.
    1:   mMutationBits = 0;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGlobalWindow::SetDocShell(nsIDocShell* aDocShell)
    1: {
    1:   NS_ASSERTION(IsOuterWindow(), "Uh, SetDocShell() called on inner window!");
    1: 
    1:   if (aDocShell == mDocShell)
    1:     return;
    1: 
38439:   // SetDocShell(nsnull) means the window is being torn down. Drop our
38439:   // reference to the script context, allowing it to be deleted
38439:   // later. Meanwhile, keep our weak reference to the script object
38439:   // (mJSObject) so that it can be retrieved later (until it is
38439:   // finalized by the JS GC).
38439: 
38439:   if (!aDocShell) {
38439:     NS_ASSERTION(PR_CLIST_IS_EMPTY(&mTimeouts),
38439:                  "Uh, outer window holds timeouts!");
38439: 
38439:     // Call FreeInnerObjects on all inner windows, not just the current
38439:     // one, since some could be held by WindowStateHolder objects that
38439:     // are GC-owned.
38439:     for (nsRefPtr<nsGlobalWindow> inner = (nsGlobalWindow *)PR_LIST_HEAD(this);
38439:          inner != this;
38439:          inner = (nsGlobalWindow*)PR_NEXT_LINK(inner)) {
55731:       NS_ASSERTION(!inner->mOuterWindow || inner->mOuterWindow == this,
55731:                    "bad outer window pointer");
80486:       inner->FreeInnerObjects(true);
38439:     }
38439: 
38439:     // Make sure that this is called before we null out the document.
38439:     NotifyDOMWindowDestroyed(this);
38439: 
42340:     NotifyWindowIDDestroyed("outer-window-destroyed");
42340: 
38439:     nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
38439: 
38439:     if (currentInner) {
38439:       NS_ASSERTION(mDoc, "Must have doc!");
38439:       
38439:       // Remember the document's principal.
38439:       mDocumentPrincipal = mDoc->NodePrincipal();
38439: 
38439:       // Release our document reference
38439:       mDocument = nsnull;
38439:       mDoc = nsnull;
38439:     }
38439: 
48112:     if (mContext) {
80486:       mContext->ClearScope(mJSObject, true);
48112:     }
38439: 
38439:     ClearControllers();
38439: 
38439:     mChromeEventHandler = nsnull; // force release now
38439: 
38439:     if (mArguments) { 
38439:       // We got no new document after someone called
38439:       // SetArguments(), drop our reference to the arguments.
38439:       mArguments = nsnull;
38439:       mArgumentsLast = nsnull;
38439:       mArgumentsOrigin = nsnull;
38439:     }
38439: 
48112:     if (mContext) {
88182:       mContext->GC(js::gcreason::SET_DOC_SHELL);
47537:       mContext->FinalizeContext();
47537:       mContext = nsnull;
48112:     }
47537: 
38439: #ifdef DEBUG
38439:     nsCycleCollector_DEBUG_shouldBeFreed(mContext);
38439:     nsCycleCollector_DEBUG_shouldBeFreed(static_cast<nsIScriptGlobalObject*>(this));
38439: #endif
38439:   }
38439: 
    1:   mDocShell = aDocShell;        // Weak Reference
    1: 
83058:   NS_ASSERTION(!mNavigator, "Non-null mNavigator in outer window!");
83058: 
    1:   if (mFrames)
    1:     mFrames->SetDocShell(aDocShell);
    1:   if (mScreen)
    1:     mScreen->SetDocShell(aDocShell);
    1: 
39378:   if (!mDocShell) {
39378:     MaybeForgiveSpamCount();
80486:     CleanUp(false);
39378:   } else {
    1:     // Get our enclosing chrome shell and retrieve its global window impl, so
    1:     // that we can do some forwarding to the chrome document.
    1:     nsCOMPtr<nsIDOMEventTarget> chromeEventHandler;
    1:     mDocShell->GetChromeEventHandler(getter_AddRefs(chromeEventHandler));
    1:     mChromeEventHandler = do_QueryInterface(chromeEventHandler);
    1:     if (!mChromeEventHandler) {
    1:       // We have no chrome event handler. If we have a parent,
    1:       // get our chrome event handler from the parent. If
    1:       // we don't have a parent, then we need to make a new
    1:       // window root object that will function as a chrome event
    1:       // handler and receive all events that occur anywhere inside
    1:       // our window.
    1:       nsCOMPtr<nsIDOMWindow> parentWindow;
    1:       GetParent(getter_AddRefs(parentWindow));
 3233:       if (parentWindow.get() != static_cast<nsIDOMWindow*>(this)) {
    1:         nsCOMPtr<nsPIDOMWindow> piWindow(do_QueryInterface(parentWindow));
    1:         mChromeEventHandler = piWindow->GetChromeEventHandler();
    1:       }
    1:       else NS_NewWindowRoot(this, getter_AddRefs(mChromeEventHandler));
    1:     }
63938: 
79445:     bool docShellActive;
63938:     mDocShell->GetIsActive(&docShellActive);
63938:     mIsBackground = !docShellActive;
    1:   }
    1: }
    1: 
    1: void
73870: nsGlobalWindow::SetOpenerWindow(nsIDOMWindow* aOpener,
79445:                                 bool aOriginalOpener)
    1: {
    1:   FORWARD_TO_OUTER_VOID(SetOpenerWindow, (aOpener, aOriginalOpener));
    1: 
    1:   NS_ASSERTION(!aOriginalOpener || !mSetOpenerWindowCalled,
    1:                "aOriginalOpener is true, but not first call to "
    1:                "SetOpenerWindow!");
    1:   NS_ASSERTION(aOpener || !aOriginalOpener,
    1:                "Shouldn't set mHadOriginalOpener if aOpener is null");
    1: 
11416:   mOpener = do_GetWeakReference(aOpener);
21853:   NS_ASSERTION(mOpener || !aOpener, "Opener must support weak references!");
11416: 
    1:   if (aOriginalOpener) {
80486:     mHadOriginalOpener = true;
    1:   }
    1: 
    1: #ifdef DEBUG
80486:   mSetOpenerWindowCalled = true;
    1: #endif
    1: }
    1: 
43680: void
43680: nsGlobalWindow::UpdateParentTarget()
43680: {
43680:   nsCOMPtr<nsIFrameLoaderOwner> flo = do_QueryInterface(mChromeEventHandler);
43680:   if (flo) {
43680:     nsRefPtr<nsFrameLoader> fl = flo->GetFrameLoader();
43680:     if (fl) {
43680:       mParentTarget = fl->GetTabChildGlobalAsEventTarget();
43680:     }
43680:   }
43680:   if (!mParentTarget) {
43680:     mParentTarget = mChromeEventHandler;
43680:   }
43680: }
43680: 
79445: bool
62677: nsGlobalWindow::GetIsTabModalPromptAllowed()
62677: {
79445:   bool allowTabModal = true;
62677:   if (mDocShell) {
62677:     nsCOMPtr<nsIContentViewer> cv;
62677:     mDocShell->GetContentViewer(getter_AddRefs(cv));
63887:     cv->GetIsTabModalPromptAllowed(&allowTabModal);
62677:   }
62677: 
62677:   return allowTabModal;
62677: }
62677: 
72326: nsIDOMEventTarget*
72322: nsGlobalWindow::GetTargetForDOMEvent()
72322: {
72326:   return static_cast<nsIDOMEventTarget*>(GetOuterWindowInternal());
72326: }
72326: 
72326: nsIDOMEventTarget*
72322: nsGlobalWindow::GetTargetForEventTargetChain()
72322: {
72322:   return IsInnerWindow() ?
72326:     this : static_cast<nsIDOMEventTarget*>(GetCurrentInnerWindowInternal());
72322: }
72322: 
72322: nsresult
72322: nsGlobalWindow::WillHandleEvent(nsEventChainPostVisitor& aVisitor)
72322: {
72322:   return NS_OK;
72322: }
72322: 
72322: JSContext*
72322: nsGlobalWindow::GetJSContextForEventHandlers()
72322: {
72322:   return nsnull;
72322: }
72322: 
    1: nsresult
    1: nsGlobalWindow::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
    1: {
  588:   NS_PRECONDITION(IsInnerWindow(), "PreHandleEvent is used on outer window!?");
    1:   static PRUint32 count = 0;
    1:   PRUint32 msg = aVisitor.mEvent->message;
    1: 
80486:   aVisitor.mCanHandle = true;
80486:   aVisitor.mForceContentDispatch = true; //FIXME! Bug 329119
    1:   if ((msg == NS_MOUSE_MOVE) && gEntropyCollector) {
    1:     //Chances are this counter will overflow during the life of the
    1:     //process, but that's OK for our case. Means we get a little
    1:     //more entropy.
    1:     if (count++ % 100 == 0) {
    1:       //Since the high bits seem to be zero's most of the time,
    1:       //let's only take the lowest half of the point structure.
    1:       PRInt16 myCoord[2];
    1: 
    1:       myCoord[0] = aVisitor.mEvent->refPoint.x;
    1:       myCoord[1] = aVisitor.mEvent->refPoint.y;
    1:       gEntropyCollector->RandomUpdate((void*)myCoord, sizeof(myCoord));
    1:       gEntropyCollector->RandomUpdate((void*)&(aVisitor.mEvent->time),
    1:                                       sizeof(PRUint32));
    1:     }
    1:   } else if (msg == NS_RESIZE_EVENT) {
80486:     mIsHandlingResizeEvent = true;
13279:   } else if (msg == NS_MOUSE_BUTTON_DOWN &&
13279:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
80486:     gMouseDown = true;
72978:   } else if ((msg == NS_MOUSE_BUTTON_UP ||
72978:               msg == NS_DRAGDROP_END) &&
13279:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
80486:     gMouseDown = false;
13279:     if (gDragServiceDisabled) {
13279:       nsCOMPtr<nsIDragService> ds =
13279:         do_GetService("@mozilla.org/widget/dragservice;1");
13279:       if (ds) {
80486:         gDragServiceDisabled = false;
13279:         ds->Unsuppress();
13279:       }
13279:     }
    1:   }
    1: 
43680:   aVisitor.mParentTarget = GetParentTarget();
    1:   return NS_OK;
    1: }
    1: 
54231: bool
54231: nsGlobalWindow::DialogOpenAttempted()
54231: {
54231:   nsGlobalWindow *topWindow = GetTop();
54231:   if (!topWindow) {
54231:     NS_ERROR("DialogOpenAttempted() called without a top window?");
54231: 
54231:     return false;
54231:   }
54231: 
54231:   topWindow = topWindow->GetCurrentInnerWindowInternal();
54231:   if (!topWindow ||
54231:       topWindow->mLastDialogQuitTime.IsNull() ||
86399:       nsContentUtils::CallerHasUniversalXPConnect()) {
54231:     return false;
54231:   }
54231: 
54231:   TimeDuration dialogDuration(TimeStamp::Now() -
54231:                               topWindow->mLastDialogQuitTime);
54231: 
54231:   if (dialogDuration.ToSeconds() <
70842:         Preferences::GetInt("dom.successive_dialog_time_limit",
54231:                             SUCCESSIVE_DIALOG_TIME_LIMIT)) {
54231:     topWindow->mDialogAbuseCount++;
54231: 
54231:     return (topWindow->GetPopupControlState() > openAllowed ||
54231:             topWindow->mDialogAbuseCount > MAX_DIALOG_COUNT);
54231:   }
54231: 
54231:   topWindow->mDialogAbuseCount = 0;
54231: 
54231:   return false;
54231: }
54231: 
54231: bool
54231: nsGlobalWindow::AreDialogsBlocked()
54231: {
54231:   nsGlobalWindow *topWindow = GetTop();
54231:   if (!topWindow) {
60097:     NS_ASSERTION(!mDocShell, "AreDialogsBlocked() called without a top window?");
54231: 
54231:     return true;
54231:   }
54231: 
54231:   topWindow = topWindow->GetCurrentInnerWindowInternal();
54231: 
54231:   return !topWindow ||
54231:          (topWindow->mDialogDisabled &&
54231:           (topWindow->GetPopupControlState() > openAllowed ||
54231:            topWindow->mDialogAbuseCount >= MAX_DIALOG_COUNT));
54231: }
54231: 
54231: bool
54231: nsGlobalWindow::ConfirmDialogAllowed()
54231: {
78277:   FORWARD_TO_OUTER(ConfirmDialogAllowed, (), false);
55612: 
54231:   NS_ENSURE_TRUE(mDocShell, false);
54231:   nsCOMPtr<nsIPromptService> promptSvc =
54231:     do_GetService("@mozilla.org/embedcomp/prompt-service;1");
54231: 
54231:   if (!DialogOpenAttempted() || !promptSvc) {
54231:     return true;
54231:   }
54231: 
54231:   // Reset popup state while opening a modal dialog, and firing events
54231:   // about the dialog, to prevent the current state from being active
54231:   // the whole time a modal dialog is open.
80486:   nsAutoPopupStatePusher popupStatePusher(openAbused, true);
54231: 
79445:   bool disableDialog = false;
54231:   nsXPIDLString label, title;
54231:   nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
54231:                                      "ScriptDialogLabel", label);
54231:   nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
54231:                                      "ScriptDialogPreventTitle", title);
54231:   promptSvc->Confirm(this, title.get(), label.get(), &disableDialog);
54231:   if (disableDialog) {
54231:     PreventFurtherDialogs();
54231:     return false;
54231:   }
54231: 
54231:   return true;
54231: }
54231: 
54231: void
54231: nsGlobalWindow::PreventFurtherDialogs()
54231: {
54231:   nsGlobalWindow *topWindow = GetTop();
54231:   if (!topWindow) {
54231:     NS_ERROR("PreventFurtherDialogs() called without a top window?");
54231: 
54231:     return;
54231:   }
54231: 
54231:   topWindow = topWindow->GetCurrentInnerWindowInternal();
54231: 
54231:   if (topWindow)
80486:     topWindow->mDialogDisabled = true;
54231: }
54231: 
    1: nsresult
    1: nsGlobalWindow::PostHandleEvent(nsEventChainPostVisitor& aVisitor)
    1: {
  588:   NS_PRECONDITION(IsInnerWindow(), "PostHandleEvent is used on outer window!?");
29430: 
29430:   // Return early if there is nothing to do.
29430:   switch (aVisitor.mEvent->message) {
29430:     case NS_RESIZE_EVENT:
29430:     case NS_PAGE_UNLOAD:
29430:     case NS_LOAD:
29430:       break;
29430:     default:
29430:       return NS_OK;
29430:   }
29430: 
    1:   /* mChromeEventHandler and mContext go dangling in the middle of this
    1:    function under some circumstances (events that destroy the window)
    1:    without this addref. */
72326:   nsCOMPtr<nsIDOMEventTarget> kungFuDeathGrip1(mChromeEventHandler);
    1:   nsCOMPtr<nsIScriptContext> kungFuDeathGrip2(GetContextInternal());
    1: 
    1:   if (aVisitor.mEvent->message == NS_RESIZE_EVENT) {
80486:     mIsHandlingResizeEvent = false;
    1:   } else if (aVisitor.mEvent->message == NS_PAGE_UNLOAD &&
    1:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
    1:     // Execute bindingdetached handlers before we tear ourselves
    1:     // down.
    1:     if (mDocument) {
    1:       NS_ASSERTION(mDoc, "Must have doc");
    1:       mDoc->BindingManager()->ExecuteDetachedHandlers();
    1:     }
80486:     mIsDocumentLoaded = false;
    1:   } else if (aVisitor.mEvent->message == NS_LOAD &&
    1:              NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
    1:     // This is page load event since load events don't propagate to |window|.
    1:     // @see nsDocument::PreHandleEvent.
80486:     mIsDocumentLoaded = true;
    1: 
    1:     nsCOMPtr<nsIContent> content(do_QueryInterface(GetFrameElementInternal()));
    1:     nsCOMPtr<nsIDocShellTreeItem> treeItem =
    1:       do_QueryInterface(GetDocShell());
    1: 
    1:     PRInt32 itemType = nsIDocShellTreeItem::typeChrome;
    1: 
    1:     if (treeItem) {
    1:       treeItem->GetItemType(&itemType);
    1:     }
    1: 
    1:     if (content && GetParentInternal() &&
    1:         itemType != nsIDocShellTreeItem::typeChrome) {
    1:       // If we're not in chrome, or at a chrome boundary, fire the
    1:       // onload event for the frame element.
    1: 
    1:       nsEventStatus status = nsEventStatus_eIgnore;
    1:       nsEvent event(NS_IS_TRUSTED_EVENT(aVisitor.mEvent), NS_LOAD);
    1:       event.flags |= NS_EVENT_FLAG_CANT_BUBBLE;
    1: 
    1:       // Most of the time we could get a pres context to pass in here,
    1:       // but not always (i.e. if this window is not shown there won't
    1:       // be a pres context available). Since we're not firing a GUI
    1:       // event we don't need a pres context anyway so we just pass
    1:       // null as the pres context all the time here.
    1:       nsEventDispatcher::Dispatch(content, nsnull, &event, nsnull, &status);
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::DispatchDOMEvent(nsEvent* aEvent,
    1:                                  nsIDOMEvent* aDOMEvent,
    1:                                  nsPresContext* aPresContext,
    1:                                  nsEventStatus* aEventStatus)
    1: {
    1:   return
 3233:     nsEventDispatcher::DispatchDOMEvent(static_cast<nsPIDOMWindow*>(this),
    1:                                        aEvent, aDOMEvent, aPresContext,
    1:                                        aEventStatus);
    1: }
    1: 
    1: void
68467: nsGlobalWindow::OnFinalize(JSObject* aObject)
68467: {
47537:   if (aObject == mJSObject) {
68467:     mJSObject = NULL;
47537:   }
    1: }
    1: 
    1: void
79445: nsGlobalWindow::SetScriptsEnabled(bool aEnabled, bool aFireTimeouts)
    1: {
    1:   FORWARD_TO_INNER_VOID(SetScriptsEnabled, (aEnabled, aFireTimeouts));
    1: 
    1:   if (aEnabled && aFireTimeouts) {
    1:     // Scripts are enabled (again?) on this context, run timeouts that
    1:     // fired on this context while scripts were disabled.
41361:     void (nsGlobalWindow::*run)() = &nsGlobalWindow::RunTimeout;
41361:     NS_DispatchToCurrentThread(NS_NewRunnableMethod(this, run));
    1:   }
    1: }
    1: 
    1: nsresult
33525: nsGlobalWindow::SetArguments(nsIArray *aArguments, nsIPrincipal *aOrigin)
33525: {
33525:   FORWARD_TO_OUTER(SetArguments, (aArguments, aOrigin),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   // Hold on to the arguments so that we can re-set them once the next
    1:   // document is loaded.
    1:   mArguments = aArguments;
33525:   mArgumentsOrigin = aOrigin;
33525: 
33525:   nsGlobalWindow *currentInner = GetCurrentInnerWindowInternal();
33525: 
33525:   if (!mIsModalContentWindow) {
    1:     mArgumentsLast = aArguments;
33525:   } else if (currentInner) {
33525:     // SetArguments() is being called on a modal content window that
33525:     // already has an inner window. This can happen when loading
33525:     // javascript: URIs as modal content dialogs. In this case, we'll
33525:     // set up the dialog window, both inner and outer, before we call
33525:     // SetArguments() on the window, so to deal with that, make sure
33525:     // here that the arguments are propagated to the inner window.
33525: 
33525:     currentInner->mArguments = aArguments;
33525:     currentInner->mArgumentsOrigin = aOrigin;
33525:   }
33525: 
33525:   return currentInner ?
33525:     currentInner->DefineArgumentsProperty(aArguments) : NS_OK;
33525: }
33525: 
33525: nsresult
33525: nsGlobalWindow::DefineArgumentsProperty(nsIArray *aArguments)
33525: {
33525:   JSContext *cx;
33525:   nsIScriptContext *ctx = GetOuterWindowInternal()->mContext;
33525:   NS_ENSURE_TRUE(aArguments && ctx &&
78415:                  (cx = ctx->GetNativeContext()),
33525:                  NS_ERROR_NOT_INITIALIZED);
33525: 
33525:   if (mIsModalContentWindow) {
33525:     // Modal content windows don't have an "arguments" property, they
33525:     // have a "dialogArguments" property which is handled
55578:     // separately. See nsWindowSH::NewResolve().
33525: 
33525:     return NS_OK;
33525:   }
33525: 
47537:   return GetContextInternal()->SetProperty(mJSObject, "arguments", aArguments);
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIScriptObjectPrincipal
    1: //*****************************************************************************
    1: 
    1: nsIPrincipal*
    1: nsGlobalWindow::GetPrincipal()
    1: {
    1:   if (mDoc) {
    1:     // If we have a document, get the principal from the document
    1:     return mDoc->NodePrincipal();
    1:   }
    1: 
    1:   if (mDocumentPrincipal) {
    1:     return mDocumentPrincipal;
    1:   }
    1: 
    1:   // If we don't have a principal and we don't have a document we
    1:   // ask the parent window for the principal. This can happen when
    1:   // loading a frameset that has a <frame src="javascript:xxx">, in
    1:   // that case the global window is used in JS before we've loaded
    1:   // a document into the window.
    1: 
    1:   nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal =
    1:     do_QueryInterface(GetParentInternal());
    1: 
    1:   if (objPrincipal) {
    1:     return objPrincipal->GetPrincipal();
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIDOMWindow
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetDocument(nsIDOMDocument** aDocument)
    1: {
    1:   // This method *should* forward calls to the outer window, but since
    1:   // there's nothing here that *depends* on anything in the outer
    1:   // (GetDocShell() eliminates that dependency), we won't do that to
    1:   // avoid the extra virtual function call.
    1: 
    1:   // lazily instantiate an about:blank document if necessary, and if
    1:   // we have what it takes to do so. Note that domdoc here is the same
    1:   // thing as our mDocument, but we don't have to explicitly set the
    1:   // member variable because the docshell has already called
    1:   // SetNewDocument().
    1:   nsIDocShell *docShell;
    1:   if (!mDocument && (docShell = GetDocShell()))
    1:     nsCOMPtr<nsIDOMDocument> domdoc(do_GetInterface(docShell));
    1: 
    1:   NS_IF_ADDREF(*aDocument = mDocument);
    1: 
    1:   return NS_OK;
    1: }
    1: 
73870: NS_IMETHODIMP
73870: nsGlobalWindow::GetWindow(nsIDOMWindow** aWindow)
    1: {
    1:   FORWARD_TO_OUTER(GetWindow, (aWindow), NS_ERROR_NOT_INITIALIZED);
    1: 
73870:   *aWindow = static_cast<nsIDOMWindow*>(this);
    1:   NS_ADDREF(*aWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
73870: nsGlobalWindow::GetSelf(nsIDOMWindow** aWindow)
    1: {
    1:   FORWARD_TO_OUTER(GetSelf, (aWindow), NS_ERROR_NOT_INITIALIZED);
    1: 
73870:   *aWindow = static_cast<nsIDOMWindow*>(this);
    1:   NS_ADDREF(*aWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetNavigator(nsIDOMNavigator** aNavigator)
    1: {
83058:   FORWARD_TO_INNER(GetNavigator, (aNavigator), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aNavigator = nsnull;
    1: 
    1:   if (!mNavigator) {
83058:     mNavigator = new Navigator(this);
    1:   }
    1: 
    1:   NS_ADDREF(*aNavigator = mNavigator);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScreen(nsIDOMScreen** aScreen)
    1: {
    1:   FORWARD_TO_OUTER(GetScreen, (aScreen), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aScreen = nsnull;
    1: 
    1:   if (!mScreen && mDocShell) {
    1:     mScreen = new nsScreen(mDocShell);
    1:     if (!mScreen) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aScreen = mScreen);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetHistory(nsIDOMHistory** aHistory)
    1: {
61735:   FORWARD_TO_INNER(GetHistory, (aHistory), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aHistory = nsnull;
    1: 
61735:   if (!mHistory) {
61735:     mHistory = new nsHistory(this);
    1:     if (!mHistory) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aHistory = mHistory);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
72298: nsGlobalWindow::GetPerformance(nsIDOMPerformance** aPerformance)
72298: {
72298:   FORWARD_TO_INNER(GetPerformance, (aPerformance), NS_ERROR_NOT_INITIALIZED);
72298: 
72298:   *aPerformance = nsnull;
72298: 
72298:   if (nsGlobalWindow::HasPerformanceSupport()) {
72298:     if (!mPerformance) {
72523:       if (!mDoc) {
72523:         return NS_OK;
72523:       }
72298:       nsRefPtr<nsDOMNavigationTiming> timing = mDoc->GetNavigationTiming();
72986:       nsCOMPtr<nsITimedChannel> timedChannel(do_QueryInterface(mDoc->GetChannel()));
79445:       bool timingEnabled = false;
72986:       if (!timedChannel ||
72986:           !NS_SUCCEEDED(timedChannel->GetTimingEnabled(&timingEnabled)) ||
72986:           !timingEnabled) {
72986:         timedChannel = nsnull;
72986:       }
72298:       if (timing) {
72986:         mPerformance = new nsPerformance(timing, timedChannel);
72298:       }
72298:     }
72298:     NS_IF_ADDREF(*aPerformance = mPerformance);
72298:   }
72298:   return NS_OK;
72298: }
72298: 
72298: NS_IMETHODIMP
    1: nsGlobalWindow::GetParent(nsIDOMWindow** aParent)
    1: {
    1:   FORWARD_TO_OUTER(GetParent, (aParent), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aParent = nsnull;
    1:   if (!mDocShell)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:   NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> parent;
    1:   docShellAsItem->GetSameTypeParent(getter_AddRefs(parent));
    1: 
    1:   if (parent) {
    1:     nsCOMPtr<nsIScriptGlobalObject> globalObject(do_GetInterface(parent));
    1:     NS_ENSURE_SUCCESS(CallQueryInterface(globalObject.get(), aParent),
    1:                       NS_ERROR_FAILURE);
    1:   }
    1:   else {
73870:     *aParent = static_cast<nsIDOMWindow*>(this);
    1:     NS_ADDREF(*aParent);
    1:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetTop(nsIDOMWindow** aTop)
    1: {
    1:   FORWARD_TO_OUTER(GetTop, (aTop), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aTop = nsnull;
    1:   if (mDocShell) {
    1:     nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:     nsCOMPtr<nsIDocShellTreeItem> root;
    1:     docShellAsItem->GetSameTypeRootTreeItem(getter_AddRefs(root));
    1: 
    1:     if (root) {
54231:       nsCOMPtr<nsIDOMWindow> top(do_GetInterface(root));
54231:       top.swap(*aTop);
54231:     }
54231:   }
54231: 
54231:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetContent(nsIDOMWindow** aContent)
    1: {
    1:   FORWARD_TO_OUTER(GetContent, (aContent), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aContent = nsnull;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> primaryContent;
    1: 
    1:   if (!nsContentUtils::IsCallerChrome()) {
    1:     // If we're called by non-chrome code, make sure we don't return
    1:     // the primary content window if the calling tab is hidden. In
    1:     // such a case we return the same-type root in the hidden tab,
    1:     // which is "good enough", for now.
    1:     nsCOMPtr<nsIBaseWindow> baseWin(do_QueryInterface(mDocShell));
    1: 
    1:     if (baseWin) {
79445:       bool visible = false;
    1:       baseWin->GetVisibility(&visible);
    1: 
    1:       if (!visible) {
    1:         nsCOMPtr<nsIDocShellTreeItem> treeItem(do_QueryInterface(mDocShell));
    1: 
    1:         treeItem->GetSameTypeRootTreeItem(getter_AddRefs(primaryContent));
    1:       }
    1:     }
    1:   }
    1: 
    1:   if (!primaryContent) {
    1:     nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:     GetTreeOwner(getter_AddRefs(treeOwner));
    1:     NS_ENSURE_TRUE(treeOwner, NS_ERROR_FAILURE);
    1: 
    1:     treeOwner->GetPrimaryContentShell(getter_AddRefs(primaryContent));
    1:   }
    1: 
73870:   nsCOMPtr<nsIDOMWindow> domWindow(do_GetInterface(primaryContent));
    1:   NS_IF_ADDREF(*aContent = domWindow);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetPrompter(nsIPrompt** aPrompt)
    1: {
    1:   FORWARD_TO_OUTER(GetPrompter, (aPrompt), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mDocShell)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   nsCOMPtr<nsIPrompt> prompter(do_GetInterface(mDocShell));
    1:   NS_ENSURE_TRUE(prompter, NS_ERROR_NO_INTERFACE);
    1: 
    1:   NS_ADDREF(*aPrompt = prompter);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetMenubar(nsIDOMBarProp** aMenubar)
    1: {
    1:   FORWARD_TO_OUTER(GetMenubar, (aMenubar), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aMenubar = nsnull;
    1: 
    1:   if (!mMenubar) {
69041:     mMenubar = new nsMenubarProp(this);
    1:     if (!mMenubar) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aMenubar = mMenubar);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetToolbar(nsIDOMBarProp** aToolbar)
    1: {
    1:   FORWARD_TO_OUTER(GetToolbar, (aToolbar), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aToolbar = nsnull;
    1: 
    1:   if (!mToolbar) {
69041:     mToolbar = new nsToolbarProp(this);
    1:     if (!mToolbar) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aToolbar = mToolbar);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetLocationbar(nsIDOMBarProp** aLocationbar)
    1: {
    1:   FORWARD_TO_OUTER(GetLocationbar, (aLocationbar), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aLocationbar = nsnull;
    1: 
    1:   if (!mLocationbar) {
69041:     mLocationbar = new nsLocationbarProp(this);
    1:     if (!mLocationbar) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aLocationbar = mLocationbar);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetPersonalbar(nsIDOMBarProp** aPersonalbar)
    1: {
    1:   FORWARD_TO_OUTER(GetPersonalbar, (aPersonalbar), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aPersonalbar = nsnull;
    1: 
    1:   if (!mPersonalbar) {
69041:     mPersonalbar = new nsPersonalbarProp(this);
    1:     if (!mPersonalbar) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aPersonalbar = mPersonalbar);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetStatusbar(nsIDOMBarProp** aStatusbar)
    1: {
    1:   FORWARD_TO_OUTER(GetStatusbar, (aStatusbar), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aStatusbar = nsnull;
    1: 
    1:   if (!mStatusbar) {
69041:     mStatusbar = new nsStatusbarProp(this);
    1:     if (!mStatusbar) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aStatusbar = mStatusbar);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScrollbars(nsIDOMBarProp** aScrollbars)
    1: {
    1:   FORWARD_TO_OUTER(GetScrollbars, (aScrollbars), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aScrollbars = nsnull;
    1: 
    1:   if (!mScrollbars) {
    1:     mScrollbars = new nsScrollbarsProp(this);
    1:     if (!mScrollbars) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_ADDREF(*aScrollbars = mScrollbars);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsGlobalWindow::GetClosed(bool* aClosed)
    1: {
    1:   FORWARD_TO_OUTER(GetClosed, (aClosed), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   // If someone called close(), or if we don't have a docshell, we're
    1:   // closed.
    1:   *aClosed = mIsClosed || !mDocShell;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetFrames(nsIDOMWindowCollection** aFrames)
    1: {
    1:   FORWARD_TO_OUTER(GetFrames, (aFrames), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aFrames = nsnull;
    1: 
    1:   if (!mFrames && mDocShell) {
    1:     mFrames = new nsDOMWindowList(mDocShell);
    1:     if (!mFrames) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
 3233:   *aFrames = static_cast<nsIDOMWindowCollection *>(mFrames);
    1:   NS_IF_ADDREF(*aFrames);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
10340: nsGlobalWindow::GetApplicationCache(nsIDOMOfflineResourceList **aApplicationCache)
10340: {
10340:   FORWARD_TO_INNER(GetApplicationCache, (aApplicationCache), NS_ERROR_UNEXPECTED);
10340: 
10340:   NS_ENSURE_ARG_POINTER(aApplicationCache);
10340: 
10340:   if (!mApplicationCache) {
10340:     nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(GetDocShell()));
10340:     if (!webNav) {
10340:       return NS_ERROR_FAILURE;
10340:     }
10340: 
10340:     nsCOMPtr<nsIURI> uri;
10340:     nsresult rv = webNav->GetCurrentURI(getter_AddRefs(uri));
10340:     NS_ENSURE_SUCCESS(rv, rv);
10340: 
21366:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
10340:     nsCOMPtr<nsIURI> manifestURI;
21366:     nsContentUtils::GetOfflineAppManifest(doc, getter_AddRefs(manifestURI));
10340: 
29226:     nsIScriptContext* scriptContext = GetContext();
29226:     NS_ENSURE_STATE(scriptContext);
29226: 
29226:     nsRefPtr<nsDOMOfflineResourceList> applicationCache =
29226:       new nsDOMOfflineResourceList(manifestURI, uri, this, scriptContext);
29226:     NS_ENSURE_TRUE(applicationCache, NS_ERROR_OUT_OF_MEMORY);
29226: 
29226:     applicationCache->Init();
10340: 
10340:     mApplicationCache = applicationCache;
10340:   }
10340: 
10340:   NS_IF_ADDREF(*aApplicationCache = mApplicationCache);
10340: 
10340:   return NS_OK;
10340: }
10340: 
10340: NS_IMETHODIMP
    1: nsGlobalWindow::GetCrypto(nsIDOMCrypto** aCrypto)
    1: {
54925: #ifdef MOZ_DISABLE_DOMCRYPTO
54925:   return NS_ERROR_NOT_IMPLEMENTED;
54925: #else
    1:   FORWARD_TO_OUTER(GetCrypto, (aCrypto), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mCrypto) {
    1:     mCrypto = do_CreateInstance(kCryptoContractID);
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aCrypto = mCrypto);
    1: 
    1:   return NS_OK;
54925: #endif
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetPkcs11(nsIDOMPkcs11** aPkcs11)
    1: {
28823:   *aPkcs11 = nsnull;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetControllers(nsIControllers** aResult)
    1: {
    1:   FORWARD_TO_OUTER(GetControllers, (aResult), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mControllers) {
    1:     nsresult rv;
    1:     mControllers = do_CreateInstance(kXULControllersCID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     // Add in the default controller
    1:     nsCOMPtr<nsIController> controller = do_CreateInstance(
    1:                                NS_WINDOWCONTROLLER_CONTRACTID, &rv);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:     
    1:     mControllers->InsertControllerAt(0, controller);
    1:     nsCOMPtr<nsIControllerContext> controllerContext = do_QueryInterface(controller);
    1:     if (!controllerContext) return NS_ERROR_FAILURE;
    1: 
 3233:     controllerContext->SetCommandContext(static_cast<nsIDOMWindow*>(this));
    1:   }
    1: 
    1:   *aResult = mControllers;
    1:   NS_ADDREF(*aResult);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
73870: nsGlobalWindow::GetOpener(nsIDOMWindow** aOpener)
    1: {
    1:   FORWARD_TO_OUTER(GetOpener, (aOpener), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aOpener = nsnull;
11416: 
34496:   nsCOMPtr<nsPIDOMWindow> opener = do_QueryReferent(mOpener);
11416:   if (!opener) {
11416:     return NS_OK;
11416:   }
11416: 
    1:   // First, check if we were called from a privileged chrome script
    1:   if (nsContentUtils::IsCallerTrustedForRead()) {
11416:     NS_ADDREF(*aOpener = opener);
    1:     return NS_OK;
    1:   }
    1: 
34496:   nsCOMPtr<nsPIDOMWindow> openerPwin(do_QueryInterface(opener));
34496:   if (!openerPwin) {
34496:     return NS_OK;
34496:   }
34496: 
34496:   // First, ensure that we're not handing back a chrome window.
34496:   nsGlobalWindow *win = static_cast<nsGlobalWindow *>(openerPwin.get());
34496:   if (win->IsChromeWindow()) {
34496:     return NS_OK;
34496:   }
34496: 
    1:   // We don't want to reveal the opener if the opener is a mail window,
    1:   // because opener can be used to spoof the contents of a message (bug 105050).
    1:   // So, we look in the opener's root docshell to see if it's a mail window.
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem =
    1:     do_QueryInterface(openerPwin->GetDocShell());
    1: 
    1:   if (docShellAsItem) {
    1:     nsCOMPtr<nsIDocShellTreeItem> openerRootItem;
    1:     docShellAsItem->GetRootTreeItem(getter_AddRefs(openerRootItem));
    1:     nsCOMPtr<nsIDocShell> openerRootDocShell(do_QueryInterface(openerRootItem));
    1:     if (openerRootDocShell) {
    1:       PRUint32 appType;
    1:       nsresult rv = openerRootDocShell->GetAppType(&appType);
    1:       if (NS_SUCCEEDED(rv) && appType != nsIDocShell::APP_TYPE_MAIL) {
11416:         *aOpener = opener;
    1:       }
    1:     }
    1:   }
34496: 
    1:   NS_IF_ADDREF(*aOpener);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
73870: nsGlobalWindow::SetOpener(nsIDOMWindow* aOpener)
    1: {
    1:   // check if we were called from a privileged chrome script.
    1:   // If not, opener is settable only to null.
    1:   if (aOpener && !nsContentUtils::IsCallerTrustedForWrite()) {
    1:     return NS_OK;
    1:   }
    1: 
80486:   SetOpenerWindow(aOpener, false);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetStatus(nsAString& aStatus)
    1: {
    1:   FORWARD_TO_OUTER(GetStatus, (aStatus), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   aStatus = mStatus;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetStatus(const nsAString& aStatus)
    1: {
    1:   FORWARD_TO_OUTER(SetStatus, (aStatus), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
    1:    * If caller is not chrome and dom.disable_window_status_change is true,
    1:    * prevent setting window.status by exiting early
    1:    */
    1: 
    1:   if (!CanSetProperty("dom.disable_window_status_change")) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   mStatus = aStatus;
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:   GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1:   if(browserChrome) {
    1:     browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_SCRIPT,
    1:                              PromiseFlatString(aStatus).get());
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetDefaultStatus(nsAString& aDefaultStatus)
    1: {
    1:   FORWARD_TO_OUTER(GetDefaultStatus, (aDefaultStatus),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   aDefaultStatus = mDefaultStatus;
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetDefaultStatus(const nsAString& aDefaultStatus)
    1: {
    1:   FORWARD_TO_OUTER(SetDefaultStatus, (aDefaultStatus),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
    1:    * If caller is not chrome and dom.disable_window_status_change is true,
    1:    * prevent setting window.defaultStatus by exiting early
    1:    */
    1: 
    1:   if (!CanSetProperty("dom.disable_window_status_change")) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   mDefaultStatus = aDefaultStatus;
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome;
    1:   GetWebBrowserChrome(getter_AddRefs(browserChrome));
    1:   if (browserChrome) {
    1:     browserChrome->SetStatus(nsIWebBrowserChrome::STATUS_SCRIPT_DEFAULT,
    1:                              PromiseFlatString(aDefaultStatus).get());
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetName(nsAString& aName)
    1: {
    1:   FORWARD_TO_OUTER(GetName, (aName), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsXPIDLString name;
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:   if (docShellAsItem)
    1:     docShellAsItem->GetName(getter_Copies(name));
    1: 
    1:   aName.Assign(name);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetName(const nsAString& aName)
    1: {
    1:   FORWARD_TO_OUTER(SetName, (aName), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult result = NS_OK;
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:   if (docShellAsItem)
    1:     result = docShellAsItem->SetName(PromiseFlatString(aName).get());
    1:   return result;
    1: }
    1: 
24816: // Helper functions used by many methods below.
24816: PRInt32
24816: nsGlobalWindow::DevToCSSIntPixels(PRInt32 px)
24816: {
24816:   if (!mDocShell)
24816:     return px; // assume 1:1
24816: 
39823:   nsRefPtr<nsPresContext> presContext;
24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
24816:   if (!presContext)
24816:     return px;
24816: 
29322:   return presContext->DevPixelsToIntCSSPixels(px);
24816: }
24816: 
24816: PRInt32
24816: nsGlobalWindow::CSSToDevIntPixels(PRInt32 px)
24816: {
24816:   if (!mDocShell)
24816:     return px; // assume 1:1
24816: 
39823:   nsRefPtr<nsPresContext> presContext;
24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
24816:   if (!presContext)
24816:     return px;
24816: 
29322:   return presContext->CSSPixelsToDevPixels(px);
24816: }
24816: 
24816: nsIntSize
24816: nsGlobalWindow::DevToCSSIntPixels(nsIntSize px)
24816: {
24816:   if (!mDocShell)
24816:     return px; // assume 1:1
24816: 
39823:   nsRefPtr<nsPresContext> presContext;
24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
24816:   if (!presContext)
24816:     return px;
24816: 
24816:   return nsIntSize(
29322:       presContext->DevPixelsToIntCSSPixels(px.width),
29322:       presContext->DevPixelsToIntCSSPixels(px.height));
24816: }
24816: 
24816: nsIntSize
24816: nsGlobalWindow::CSSToDevIntPixels(nsIntSize px)
24816: {
24816:   if (!mDocShell)
24816:     return px; // assume 1:1
24816: 
39823:   nsRefPtr<nsPresContext> presContext;
24816:   mDocShell->GetPresContext(getter_AddRefs(presContext));
24816:   if (!presContext)
24816:     return px;
24816: 
24816:   return nsIntSize(
29322:     presContext->CSSPixelsToDevPixels(px.width),
29322:     presContext->CSSPixelsToDevPixels(px.height));
24816: }
24816: 
24816: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetInnerWidth(PRInt32* aInnerWidth)
    1: {
    1:   FORWARD_TO_OUTER(GetInnerWidth, (aInnerWidth), NS_ERROR_NOT_INITIALIZED);
    1: 
  334:   NS_ENSURE_STATE(mDocShell);
  334: 
    1:   EnsureSizeUpToDate();
    1: 
39823:   nsRefPtr<nsPresContext> presContext;
28807:   mDocShell->GetPresContext(getter_AddRefs(presContext));
28807: 
59572:   if (presContext) {
59572:     nsRect shellArea = presContext->GetVisibleArea();
59572:     *aInnerWidth = nsPresContext::AppUnitsToIntCSSPixels(shellArea.width);
28807:   } else {
28807:     *aInnerWidth = 0;
28807:   }
28807: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetInnerWidth(PRInt32 aInnerWidth)
    1: {
    1:   FORWARD_TO_OUTER(SetInnerWidth, (aInnerWidth), NS_ERROR_NOT_INITIALIZED);
    1: 
  334:   NS_ENSURE_STATE(mDocShell);
  334: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent setting window.innerWidth by exiting early
    1:    */
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(&aInnerWidth, nsnull),
    1:                     NS_ERROR_FAILURE);
    1: 
59572: 
59572:   nsRefPtr<nsIPresShell> presShell;
59572:   mDocShell->GetPresShell(getter_AddRefs(presShell));
64531: 
64531:   if (presShell && presShell->GetIsViewportOverridden())
59572:   {
59572:     nscoord height = 0;
59572:     nscoord width  = 0;
59572: 
59572:     nsRefPtr<nsPresContext> presContext;
59572:     presContext = presShell->GetPresContext();
59572: 
59572:     nsRect shellArea = presContext->GetVisibleArea();
59572:     height = shellArea.height;
59572:     width  = nsPresContext::CSSPixelsToAppUnits(aInnerWidth);
59572:     return SetCSSViewportWidthAndHeight(width, height);
59572:   }
59572:   else
59572:   {
59572:     PRInt32 height = 0;
59572:     PRInt32 width  = 0;
  334: 
    1:     nsCOMPtr<nsIBaseWindow> docShellAsWin(do_QueryInterface(mDocShell));
59572:     docShellAsWin->GetSize(&width, &height);
59572:     width  = CSSToDevIntPixels(aInnerWidth);
59572:     return SetDocShellWidthAndHeight(width, height);
59572:   }
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetInnerHeight(PRInt32* aInnerHeight)
    1: {
    1:   FORWARD_TO_OUTER(GetInnerHeight, (aInnerHeight), NS_ERROR_NOT_INITIALIZED);
    1: 
  334:   NS_ENSURE_STATE(mDocShell);
  334: 
    1:   EnsureSizeUpToDate();
    1: 
39823:   nsRefPtr<nsPresContext> presContext;
28807:   mDocShell->GetPresContext(getter_AddRefs(presContext));
28807: 
59572:   if (presContext) {
59572:     nsRect shellArea = presContext->GetVisibleArea();
59572:     *aInnerHeight = nsPresContext::AppUnitsToIntCSSPixels(shellArea.height);
28807:   } else {
28807:     *aInnerHeight = 0;
28807:   }
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetInnerHeight(PRInt32 aInnerHeight)
    1: {
    1:   FORWARD_TO_OUTER(SetInnerHeight, (aInnerHeight), NS_ERROR_NOT_INITIALIZED);
    1: 
  334:   NS_ENSURE_STATE(mDocShell);
  334: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent setting window.innerHeight by exiting early
    1:    */
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(nsnull, &aInnerHeight),
    1:                     NS_ERROR_FAILURE);
    1: 
59572:   nsRefPtr<nsIPresShell> presShell;
59572:   mDocShell->GetPresShell(getter_AddRefs(presShell));
64531: 
64531:   if (presShell && presShell->GetIsViewportOverridden())
59572:   {
59572:     nscoord height = 0;
59572:     nscoord width  = 0;
59572: 
59572:     nsRefPtr<nsPresContext> presContext;
59572:     presContext = presShell->GetPresContext();
59572: 
59572:     nsRect shellArea = presContext->GetVisibleArea();
59572:     width = shellArea.width;
59572:     height  = nsPresContext::CSSPixelsToAppUnits(aInnerHeight);
59572:     return SetCSSViewportWidthAndHeight(width, height);
59572:   }
59572:   else
59572:   {
59572:     PRInt32 height = 0;
59572:     PRInt32 width  = 0;
  334: 
    1:     nsCOMPtr<nsIBaseWindow> docShellAsWin(do_QueryInterface(mDocShell));
59572:     docShellAsWin->GetSize(&width, &height);
59572:     height  = CSSToDevIntPixels(aInnerHeight);
59572:     return SetDocShellWidthAndHeight(width, height);
59572:   }
    1: }
    1: 
13806: nsresult
13806: nsGlobalWindow::GetOuterSize(nsIntSize* aSizeCSSPixels)
13806: {
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
    1:   nsGlobalWindow* rootWindow =
 3233:     static_cast<nsGlobalWindow *>(GetPrivateRoot());
    1:   if (rootWindow) {
    1:     rootWindow->FlushPendingNotifications(Flush_Layout);
    1:   }
13806: 
13806:   nsIntSize sizeDevPixels;
13806:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetSize(&sizeDevPixels.width,
13806:                                             &sizeDevPixels.height),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   *aSizeCSSPixels = DevToCSSIntPixels(sizeDevPixels);
13806:   return NS_OK;
13806: }
13806: 
13806: NS_IMETHODIMP
13806: nsGlobalWindow::GetOuterWidth(PRInt32* aOuterWidth)
13806: {
13806:   FORWARD_TO_OUTER(GetOuterWidth, (aOuterWidth), NS_ERROR_NOT_INITIALIZED);
13806: 
13806:   nsIntSize sizeCSSPixels;
13806:   nsresult rv = GetOuterSize(&sizeCSSPixels);
13806:   NS_ENSURE_SUCCESS(rv, rv);
13806: 
13806:   *aOuterWidth = sizeCSSPixels.width;
13806:   return NS_OK;
13806: }
13806: 
13806: NS_IMETHODIMP
13806: nsGlobalWindow::GetOuterHeight(PRInt32* aOuterHeight)
13806: {
13806:   FORWARD_TO_OUTER(GetOuterHeight, (aOuterHeight), NS_ERROR_NOT_INITIALIZED);
13806: 
13806:   nsIntSize sizeCSSPixels;
13806:   nsresult rv = GetOuterSize(&sizeCSSPixels);
13806:   NS_ENSURE_SUCCESS(rv, rv);
13806: 
13806:   *aOuterHeight = sizeCSSPixels.height;
13806:   return NS_OK;
13806: }
13806: 
13806: nsresult
79445: nsGlobalWindow::SetOuterSize(PRInt32 aLengthCSSPixels, bool aIsWidth)
13806: {
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent setting window.outerWidth by exiting early
    1:    */
    1: 
30667:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
13806:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(
24816:                         aIsWidth ? &aLengthCSSPixels : nsnull,
24816:                         aIsWidth ? nsnull : &aLengthCSSPixels),
    1:                     NS_ERROR_FAILURE);
    1: 
13806:   PRInt32 width, height;
13806:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetSize(&width, &height), NS_ERROR_FAILURE);
13806: 
24816:   PRInt32 lengthDevPixels = CSSToDevIntPixels(aLengthCSSPixels);
13806:   if (aIsWidth) {
13806:     width = lengthDevPixels;
13806:   } else {
13806:     height = lengthDevPixels;
13806:   }
80486:   return treeOwnerAsWin->SetSize(width, height, true);    
13806: }
13806: 
13806: NS_IMETHODIMP
13806: nsGlobalWindow::SetOuterWidth(PRInt32 aOuterWidth)
13806: {
13806:   FORWARD_TO_OUTER(SetOuterWidth, (aOuterWidth), NS_ERROR_NOT_INITIALIZED);
13806: 
80486:   return SetOuterSize(aOuterWidth, true);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetOuterHeight(PRInt32 aOuterHeight)
    1: {
    1:   FORWARD_TO_OUTER(SetOuterHeight, (aOuterHeight), NS_ERROR_NOT_INITIALIZED);
    1: 
80486:   return SetOuterSize(aOuterHeight, false);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScreenX(PRInt32* aScreenX)
    1: {
    1:   FORWARD_TO_OUTER(GetScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
24816:   PRInt32 x, y;
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   *aScreenX = DevToCSSIntPixels(x);
    1:   return NS_OK;
    1: }
    1: 
30882: nsRect
30882: nsGlobalWindow::GetInnerScreenRect()
30882: {
30882:   if (!mDocShell)
30882:     return nsRect();
30882: 
30882:   nsGlobalWindow* rootWindow =
30882:     static_cast<nsGlobalWindow*>(GetPrivateRoot());
30882:   if (rootWindow) {
30882:     rootWindow->FlushPendingNotifications(Flush_Layout);
30882:   }
30882: 
30882:   nsCOMPtr<nsIPresShell> presShell;
30882:   mDocShell->GetPresShell(getter_AddRefs(presShell));
30882:   if (!presShell)
30882:     return nsRect();
30882:   nsIFrame* rootFrame = presShell->GetRootFrame();
30882:   if (!rootFrame)
30882:     return nsRect();
30882: 
30882:   return rootFrame->GetScreenRectInAppUnits();
30882: }
30882: 
30882: NS_IMETHODIMP
30882: nsGlobalWindow::GetMozInnerScreenX(float* aScreenX)
30882: {
30882:   FORWARD_TO_OUTER(GetMozInnerScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
30882: 
30882:   nsRect r = GetInnerScreenRect();
30882:   *aScreenX = nsPresContext::AppUnitsToFloatCSSPixels(r.x);
30882:   return NS_OK;
30882: }
30882: 
30882: NS_IMETHODIMP
30882: nsGlobalWindow::GetMozInnerScreenY(float* aScreenY)
30882: {
30882:   FORWARD_TO_OUTER(GetMozInnerScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
30882: 
30882:   nsRect r = GetInnerScreenRect();
30882:   *aScreenY = nsPresContext::AppUnitsToFloatCSSPixels(r.y);
30882:   return NS_OK;
30882: }
30882: 
30882: NS_IMETHODIMP
42240: nsGlobalWindow::GetMozPaintCount(PRUint64* aResult)
42240: {
42240:   FORWARD_TO_OUTER(GetMozPaintCount, (aResult), NS_ERROR_NOT_INITIALIZED);
42240: 
42240:   *aResult = 0;
42240: 
42240:   if (!mDocShell)
42240:     return NS_OK;
42240: 
42240:   nsCOMPtr<nsIPresShell> presShell;
42240:   mDocShell->GetPresShell(getter_AddRefs(presShell));
42240:   if (!presShell)
42240:     return NS_OK;
42240: 
42240:   *aResult = presShell->GetPaintCount();
42240:   return NS_OK;
42240: }
42240: 
42240: NS_IMETHODIMP
84132: nsGlobalWindow::MozRequestAnimationFrame(nsIFrameRequestCallback* aCallback,
84132:                                          PRInt32 *aHandle)
84132: {
84132:   FORWARD_TO_INNER(MozRequestAnimationFrame, (aCallback, aHandle),
52255:                    NS_ERROR_NOT_INITIALIZED);
50368: 
50368:   if (!mDoc) {
50368:     return NS_OK;
50368:   }
50368: 
83087:   if (!aCallback) {
84627:     mDoc->WarnOnceAbout(nsIDocument::eMozBeforePaint);
83087:     return NS_ERROR_XPC_BAD_CONVERT_JS;
83087:   }
83087: 
84132:   return mDoc->ScheduleFrameRequestCallback(aCallback, aHandle);
50368: }
50368: 
50368: NS_IMETHODIMP
84133: nsGlobalWindow::MozCancelRequestAnimationFrame(PRInt32 aHandle)
84133: {
84628:   return MozCancelAnimationFrame(aHandle);
84628: }
84628: 
84628: NS_IMETHODIMP
84628: nsGlobalWindow::MozCancelAnimationFrame(PRInt32 aHandle)
84628: {
84628:   FORWARD_TO_INNER(MozCancelAnimationFrame, (aHandle),
84133:                    NS_ERROR_NOT_INITIALIZED);
84133: 
84133:   if (!mDoc) {
84133:     return NS_OK;
84133:   }
84133: 
84133:   mDoc->CancelFrameRequestCallback(aHandle);
84133:   return NS_OK;
84133: }
84133: 
84133: NS_IMETHODIMP
50368: nsGlobalWindow::GetMozAnimationStartTime(PRInt64 *aTime)
50368: {
50368:   FORWARD_TO_INNER(GetMozAnimationStartTime, (aTime), NS_ERROR_NOT_INITIALIZED);
50368: 
50368:   if (mDoc) {
50368:     nsIPresShell* presShell = mDoc->GetShell();
50368:     if (presShell) {
50368:       *aTime = presShell->GetPresContext()->RefreshDriver()->
50368:         MostRecentRefreshEpochTime() / PR_USEC_PER_MSEC;
50368:       return NS_OK;
50368:     }
50368:   }
50368: 
50368:   // If all else fails, just be compatible with Date.now()
50368:   *aTime = JS_Now() / PR_USEC_PER_MSEC;
50368:   return NS_OK;
50368: }
50368: 
50368: NS_IMETHODIMP
68769: nsGlobalWindow::MatchMedia(const nsAString& aMediaQueryList,
68769:                            nsIDOMMediaQueryList** aResult)
68769: {
68769:   // FIXME: This whole forward-to-outer and then get a pres
68769:   // shell/context off the docshell dance is sort of silly; it'd make
68769:   // more sense to forward to the inner, but it's what everyone else
68769:   // (GetSelection, GetScrollXY, etc.) does around here.
68769:   FORWARD_TO_OUTER(MatchMedia, (aMediaQueryList, aResult),
68769:                    NS_ERROR_NOT_INITIALIZED);
68769: 
68769:   *aResult = nsnull;
68769: 
68769:   if (!mDocShell)
68769:     return NS_OK;
68769: 
68769:   nsRefPtr<nsPresContext> presContext;
68769:   mDocShell->GetPresContext(getter_AddRefs(presContext));
68769: 
68769:   if (!presContext)
68769:     return NS_OK;
68769: 
68769:   presContext->MatchMedia(aMediaQueryList, aResult);
68769:   return NS_OK;
68769: }
68769: 
68769: NS_IMETHODIMP
    1: nsGlobalWindow::SetScreenX(PRInt32 aScreenX)
    1: {
    1:   FORWARD_TO_OUTER(SetScreenX, (aScreenX), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent setting window.screenX by exiting early
    1:    */
    1: 
30667:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
    1:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&aScreenX, nsnull),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 x, y;
    1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   x = CSSToDevIntPixels(aScreenX);
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScreenY(PRInt32* aScreenY)
    1: {
    1:   FORWARD_TO_OUTER(GetScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
24816:   PRInt32 x, y;
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   *aScreenY = DevToCSSIntPixels(y);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetScreenY(PRInt32 aScreenY)
    1: {
    1:   FORWARD_TO_OUTER(SetScreenY, (aScreenY), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent setting window.screenY by exiting early
    1:    */
    1: 
30667:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
    1:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(nsnull, &aScreenY),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 x, y;
    1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   y = CSSToDevIntPixels(aScreenY);
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(x, y),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
24816: // NOTE: Arguments to this function should have values scaled to
24816: // CSS pixels, not device pixels.
    1: nsresult
    1: nsGlobalWindow::CheckSecurityWidthAndHeight(PRInt32* aWidth, PRInt32* aHeight)
    1: {
 3799: #ifdef MOZ_XUL
  677:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
  677:     // if attempting to resize the window, hide any open popups
 3129:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
11414:     nsContentUtils::HidePopupsInDocument(doc);
  677:   }
 3799: #endif
  677: 
    1:   // This one is easy. Just ensure the variable is greater than 100;
    1:   if ((aWidth && *aWidth < 100) || (aHeight && *aHeight < 100)) {
    1:     // Check security state for use in determing window dimensions
    1: 
    1:     if (!nsContentUtils::IsCallerTrustedForWrite()) {
    1:       //sec check failed
    1:       if (aWidth && *aWidth < 100) {
    1:         *aWidth = 100;
    1:       }
    1:       if (aHeight && *aHeight < 100) {
    1:         *aHeight = 100;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
59572: // NOTE: Arguments to this function should have values in device pixels
59572: nsresult
59572: nsGlobalWindow::SetDocShellWidthAndHeight(PRInt32 aInnerWidth, PRInt32 aInnerHeight)
59572: {
59572:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
59572:   NS_ENSURE_TRUE(docShellAsItem, NS_ERROR_FAILURE);
59572: 
59572:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
59572:   docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
59572:   NS_ENSURE_TRUE(treeOwner, NS_ERROR_FAILURE);
59572: 
59572:   NS_ENSURE_SUCCESS(treeOwner->SizeShellTo(docShellAsItem, aInnerWidth, aInnerHeight),
59572:                     NS_ERROR_FAILURE);
59572: 
59572:   return NS_OK;
59572: }
59572: 
59572: // NOTE: Arguments to this function should have values in app units
59572: nsresult
59572: nsGlobalWindow::SetCSSViewportWidthAndHeight(nscoord aInnerWidth, nscoord aInnerHeight)
59572: {
59572:   nsRefPtr<nsPresContext> presContext;
59572:   mDocShell->GetPresContext(getter_AddRefs(presContext));
59572: 
59572:   nsRect shellArea = presContext->GetVisibleArea();
59572:   shellArea.height = aInnerHeight;
59572:   shellArea.width = aInnerWidth;
59572: 
59572:   presContext->SetVisibleArea(shellArea);
59572:   return NS_OK;
59572: }
59572: 
24816: // NOTE: Arguments to this function should have values scaled to
24816: // CSS pixels, not device pixels.
    1: nsresult
    1: nsGlobalWindow::CheckSecurityLeftAndTop(PRInt32* aLeft, PRInt32* aTop)
    1: {
    1:   // This one is harder. We have to get the screen size and window dimensions.
    1: 
    1:   // Check security state for use in determing window dimensions
    1: 
    1:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
 3799: #ifdef MOZ_XUL
  677:     // if attempting to move the window, hide any open popups
 3129:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
11414:     nsContentUtils::HidePopupsInDocument(doc);
 3799: #endif
  677: 
    1:     nsGlobalWindow* rootWindow =
 3233:       static_cast<nsGlobalWindow*>(GetPrivateRoot());
    1:     if (rootWindow) {
    1:       rootWindow->FlushPendingNotifications(Flush_Layout);
    1:     }
    1: 
    1:     nsCOMPtr<nsIBaseWindow> treeOwner;
    1:     GetTreeOwner(getter_AddRefs(treeOwner));
39648: 
39648:     nsCOMPtr<nsIDOMScreen> screen;
39648:     GetScreen(getter_AddRefs(screen));
39648: 
39648:     if (treeOwner && screen) {
39648:       PRInt32 screenLeft, screenTop, screenWidth, screenHeight;
39648:       PRInt32 winLeft, winTop, winWidth, winHeight;
39648: 
39648:       // Get the window size
    1:       treeOwner->GetPositionAndSize(&winLeft, &winTop, &winWidth, &winHeight);
    1: 
24816:       // convert those values to CSS pixels
24816:       // XXX four separate retrievals of the prescontext
24816:       winLeft   = DevToCSSIntPixels(winLeft);
24816:       winTop    = DevToCSSIntPixels(winTop);
24816:       winWidth  = DevToCSSIntPixels(winWidth);
24816:       winHeight = DevToCSSIntPixels(winHeight);
24816: 
    1:       // Get the screen dimensions
    1:       // XXX This should use nsIScreenManager once it's fully fleshed out.
    1:       screen->GetAvailLeft(&screenLeft);
    1:       screen->GetAvailWidth(&screenWidth);
    1:       screen->GetAvailHeight(&screenHeight);
69620: #if defined(XP_MACOSX)
    1:       /* The mac's coordinate system is different from the assumed Windows'
    1:          system. It offsets by the height of the menubar so that a window
    1:          placed at (0,0) will be entirely visible. Unfortunately that
    1:          correction is made elsewhere (in Widget) and the meaning of
    1:          the Avail... coordinates is overloaded. Here we allow a window
    1:          to be placed at (0,0) because it does make sense to do so.
    1:       */
    1:       screen->GetTop(&screenTop);
    1: #else
    1:       screen->GetAvailTop(&screenTop);
    1: #endif
39648: 
    1:       if (aLeft) {
    1:         if (screenLeft+screenWidth < *aLeft+winWidth)
    1:           *aLeft = screenLeft+screenWidth - winWidth;
    1:         if (screenLeft > *aLeft)
    1:           *aLeft = screenLeft;
    1:       }
    1:       if (aTop) {
    1:         if (screenTop+screenHeight < *aTop+winHeight)
    1:           *aTop = screenTop+screenHeight - winHeight;
    1:         if (screenTop > *aTop)
    1:           *aTop = screenTop;
    1:       }
    1:     } else {
    1:       if (aLeft)
    1:         *aLeft = 0;
    1:       if (aTop)
    1:         *aTop = 0;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetPageXOffset(PRInt32* aPageXOffset)
    1: {
    1:   return GetScrollX(aPageXOffset);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetPageYOffset(PRInt32* aPageYOffset)
    1: {
    1:   return GetScrollY(aPageYOffset);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::GetScrollMaxXY(PRInt32* aScrollMaxX, PRInt32* aScrollMaxY)
    1: {
    1:   FORWARD_TO_OUTER(GetScrollMaxXY, (aScrollMaxX, aScrollMaxY),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   FlushPendingNotifications(Flush_Layout);
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063:   if (!sf)
37063:     return NS_OK;
37063: 
37063:   nsRect scrollRange = sf->GetScrollRange();
    1: 
    1:   if (aScrollMaxX)
38330:     *aScrollMaxX = NS_MAX(0,
37063:       (PRInt32)floor(nsPresContext::AppUnitsToFloatCSSPixels(scrollRange.XMost())));
    1:   if (aScrollMaxY)
38330:     *aScrollMaxY = NS_MAX(0,
37063:       (PRInt32)floor(nsPresContext::AppUnitsToFloatCSSPixels(scrollRange.YMost())));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScrollMaxX(PRInt32* aScrollMaxX)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aScrollMaxX);
    1:   *aScrollMaxX = 0;
    1:   return GetScrollMaxXY(aScrollMaxX, nsnull);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScrollMaxY(PRInt32* aScrollMaxY)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aScrollMaxY);
    1:   *aScrollMaxY = 0;
    1:   return GetScrollMaxXY(nsnull, aScrollMaxY);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::GetScrollXY(PRInt32* aScrollX, PRInt32* aScrollY,
79445:                             bool aDoFlush)
    1: {
    1:   FORWARD_TO_OUTER(GetScrollXY, (aScrollX, aScrollY, aDoFlush),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (aDoFlush) {
    1:     FlushPendingNotifications(Flush_Layout);
    1:   } else {
    1:     EnsureSizeUpToDate();
    1:   }
    1: 
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063:   if (!sf)
37063:     return NS_OK;
37063: 
37063:   nsPoint scrollPos = sf->GetScrollPosition();
37063:   if (scrollPos != nsPoint(0,0) && !aDoFlush) {
    1:     // Oh, well.  This is the expensive case -- the window is scrolled and we
    1:     // didn't actually flush yet.  Repeat, but with a flush, since the content
    1:     // may get shorter and hence our scroll position may decrease.
80486:     return GetScrollXY(aScrollX, aScrollY, true);
    1:   }
    1: 
    1:   if (aScrollX)
37063:     *aScrollX = nsPresContext::AppUnitsToIntCSSPixels(scrollPos.x);
    1:   if (aScrollY)
37063:     *aScrollY = nsPresContext::AppUnitsToIntCSSPixels(scrollPos.y);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScrollX(PRInt32* aScrollX)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aScrollX);
    1:   *aScrollX = 0;
80486:   return GetScrollXY(aScrollX, nsnull, false);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetScrollY(PRInt32* aScrollY)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aScrollY);
    1:   *aScrollY = 0;
80486:   return GetScrollXY(nsnull, aScrollY, false);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetLength(PRUint32* aLength)
    1: {
    1:   nsCOMPtr<nsIDOMWindowCollection> frames;
    1:   if (NS_SUCCEEDED(GetFrames(getter_AddRefs(frames))) && frames) {
    1:     return frames->GetLength(aLength);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
79445: bool
    1: nsGlobalWindow::DispatchCustomEvent(const char *aEventName)
    1: {
79445:   bool defaultActionEnabled = true;
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
    1:   nsContentUtils::DispatchTrustedEvent(doc,
73874:                                        GetOuterWindow(),
    1:                                        NS_ConvertASCIItoUTF16(aEventName),
80486:                                        true, true, &defaultActionEnabled);
    1: 
    1:   return defaultActionEnabled;
    1: }
    1: 
    1: static already_AddRefed<nsIDocShellTreeItem>
    1: GetCallerDocShellTreeItem()
    1: {
18868:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
    1:   nsIDocShellTreeItem *callerItem = nsnull;
    1: 
    1:   if (cx) {
    1:     nsCOMPtr<nsIWebNavigation> callerWebNav =
    1:       do_GetInterface(nsJSUtils::GetDynamicScriptGlobal(cx));
    1: 
    1:     if (callerWebNav) {
    1:       CallQueryInterface(callerWebNav, &callerItem);
    1:     }
    1:   }
    1: 
    1:   return callerItem;
    1: }
    1: 
79445: bool
    1: nsGlobalWindow::WindowExists(const nsAString& aName,
79445:                              bool aLookForCallerOnJSStack)
    1: {
    1:   NS_PRECONDITION(IsOuterWindow(), "Must be outer window");
    1:   NS_PRECONDITION(mDocShell, "Must have docshell");
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> caller;
    1:   if (aLookForCallerOnJSStack) {
    1:     caller = GetCallerDocShellTreeItem();
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShell = do_QueryInterface(mDocShell);
    1:   NS_ASSERTION(docShell,
    1:                "Docshell doesn't implement nsIDocShellTreeItem?");
    1: 
    1:   if (!caller) {
    1:     caller = docShell;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> namedItem;
    1:   docShell->FindItemWithName(PromiseFlatString(aName).get(), nsnull, caller,
    1:                              getter_AddRefs(namedItem));
    1:   return namedItem != nsnull;
    1: }
    1: 
    1: already_AddRefed<nsIWidget>
    1: nsGlobalWindow::GetMainWidget()
    1: {
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1: 
    1:   nsIWidget *widget = nsnull;
    1: 
    1:   if (treeOwnerAsWin) {
    1:     treeOwnerAsWin->GetMainWidget(&widget);
    1:   }
    1: 
    1:   return widget;
    1: }
    1: 
30327: nsIWidget*
30327: nsGlobalWindow::GetNearestWidget()
30327: {
30327:   nsIDocShell* docShell = GetDocShell();
30327:   NS_ENSURE_TRUE(docShell, nsnull);
30327:   nsCOMPtr<nsIPresShell> presShell;
30327:   docShell->GetPresShell(getter_AddRefs(presShell));
30327:   NS_ENSURE_TRUE(presShell, nsnull);
30327:   nsIFrame* rootFrame = presShell->GetRootFrame();
30327:   NS_ENSURE_TRUE(rootFrame, nsnull);
30327:   return rootFrame->GetView()->GetNearestWidget(nsnull);
30327: }
30327: 
    1: NS_IMETHODIMP
79445: nsGlobalWindow::SetFullScreen(bool aFullScreen)
    1: {
    1:   FORWARD_TO_OUTER(SetFullScreen, (aFullScreen), NS_ERROR_NOT_INITIALIZED);
    1: 
 8932:   NS_ENSURE_TRUE(mDocShell, NS_ERROR_FAILURE);
 8932: 
79445:   bool rootWinFullScreen;
 2114:   GetFullScreen(&rootWinFullScreen);
77843:   // Only chrome can change our fullScreen mode, unless the DOM full-screen
77843:   // API is enabled.
77843:   if ((aFullScreen == rootWinFullScreen || 
77843:       !nsContentUtils::IsCallerTrustedForWrite()) &&
77843:       !nsContentUtils::IsFullScreenApiEnabled()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // SetFullScreen needs to be called on the root window, so get that
    1:   // via the DocShell tree, and if we are not already the root,
    1:   // call SetFullScreen on that window instead.
    1:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(mDocShell);
    1:   nsCOMPtr<nsIDocShellTreeItem> rootItem;
    1:   treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
73870:   nsCOMPtr<nsIDOMWindow> window = do_GetInterface(rootItem);
    1:   if (!window)
    1:     return NS_ERROR_FAILURE;
    1:   if (rootItem != treeItem)
    1:     return window->SetFullScreen(aFullScreen);
    1: 
    1:   // make sure we don't try to set full screen on a non-chrome window,
    1:   // which might happen in embedding world
    1:   PRInt32 itemType;
    1:   treeItem->GetItemType(&itemType);
    1:   if (itemType != nsIDocShellTreeItem::typeChrome)
    1:     return NS_ERROR_FAILURE;
    1: 
51638:   // If we are already in full screen mode, just return.
51638:   if (mFullScreen == aFullScreen)
51638:     return NS_OK;
51638: 
    1:   // dispatch a "fullscreen" DOM event so that XUL apps can
    1:   // respond visually if we are kicked into full screen mode
    1:   if (!DispatchCustomEvent("fullscreen")) {
    1:     return NS_OK;
    1:   }
    1: 
47945:   // Prevent chrome documents which are still loading from resizing
47945:   // the window after we set fullscreen mode.
47945:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
47945:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
47945:   nsCOMPtr<nsIXULWindow> xulWin(do_GetInterface(treeOwnerAsWin));
47945:   if (aFullScreen && xulWin) {
80486:     xulWin->SetIntrinsicallySized(false);
47945:   }
47945: 
51638:   // Set this before so if widget sends an event indicating its
51638:   // gone full screen, the state trap above works.
51638:   mFullScreen = aFullScreen;
51638: 
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
64065:   if (widget)
    1:     widget->MakeFullScreen(aFullScreen);
    1: 
84109:   if (!mFullScreen) {
84109:     // Force exit from DOM full-screen mode. This is so that if we're in
84109:     // DOM full-screen mode and the user exits full-screen mode with
84109:     // the browser full-screen mode toggle keyboard-shortcut, we'll detect
84109:     // that and leave DOM API full-screen mode too.
84109:     nsIDocument::ExitFullScreen(false);
77843:   }
77843: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsGlobalWindow::GetFullScreen(bool* aFullScreen)
    1: {
    1:   FORWARD_TO_OUTER(GetFullScreen, (aFullScreen), NS_ERROR_NOT_INITIALIZED);
    1: 
 2114:   // Get the fullscreen value of the root window, to always have the value
 2114:   // accurate, even when called from content.
 2114:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(mDocShell);
 8932:   if (treeItem) {
 2114:     nsCOMPtr<nsIDocShellTreeItem> rootItem;
 2114:     treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
 2114:     if (rootItem != treeItem) {
73870:       nsCOMPtr<nsIDOMWindow> window = do_GetInterface(rootItem);
 2114:       if (window)
 2114:         return window->GetFullScreen(aFullScreen);
 2114:     }
 8932:   }
 2114: 
30004:   // We are the root window, or something went wrong. Return our internal value.
30004:   *aFullScreen = mFullScreen;
    1:   return NS_OK;
    1: }
    1: 
79445: bool
21376: nsGlobalWindow::DOMWindowDumpEnabled()
    1: {
    1: #if !(defined(NS_DEBUG) || defined(MOZ_ENABLE_JS_DUMP))
    1:   // In optimized builds we check a pref that controls if we should
    1:   // enable output from dump() or not, in debug builds it's always
    1:   // enabled.
21376:   return gDOMWindowDumpEnabled;
21376: #else
80486:   return true;
    1: #endif
21376: }
21376: 
21376: NS_IMETHODIMP
21376: nsGlobalWindow::Dump(const nsAString& aStr)
21376: {
21376:   if (!DOMWindowDumpEnabled()) {
21376:     return NS_OK;
21376:   }
    1: 
    1:   char *cstr = ToNewUTF8String(aStr);
    1: 
69620: #if defined(XP_MACOSX)
    1:   // have to convert \r to \n so that printing to the console works
43423:   char *c = cstr, *cEnd = cstr + strlen(cstr);
    1:   while (c < cEnd) {
    1:     if (*c == '\r')
    1:       *c = '\n';
    1:     c++;
    1:   }
    1: #endif
    1: 
    1:   if (cstr) {
82109: #ifdef ANDROID
88337:     __android_log_write(ANDROID_LOG_INFO, "GeckoDump", cstr);
82109: #endif
27826:     FILE *fp = gDumpFile ? gDumpFile : stdout;
27826:     fputs(cstr, fp);
27826:     fflush(fp);
    1:     nsMemory::Free(cstr);
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGlobalWindow::EnsureReflowFlushAndPaint()
    1: {
62357:   NS_ASSERTION(IsOuterWindow(), "EnsureReflowFlushAndPaint() must be called on"
62357:                "the outer window");
    1:   NS_ASSERTION(mDocShell, "EnsureReflowFlushAndPaint() called with no "
    1:                "docshell!");
    1: 
22792:   if (!mDocShell)
22792:     return;
22792: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   mDocShell->GetPresShell(getter_AddRefs(presShell));
    1: 
    1:   if (!presShell)
    1:     return;
    1: 
    1:   // Flush pending reflows.
    1:   if (mDoc) {
    1:     mDoc->FlushPendingNotifications(Flush_Layout);
    1:   }
    1: 
    1:   // Unsuppress painting.
    1:   presShell->UnsuppressPainting();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetTextZoom(float *aZoom)
    1: {
    1:   FORWARD_TO_OUTER(GetTextZoom, (aZoom), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (mDocShell) {
    1:     nsCOMPtr<nsIContentViewer> contentViewer;
    1:     mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
    1:     nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(contentViewer));
    1: 
    1:     if (markupViewer) {
    1:       return markupViewer->GetTextZoom(aZoom);
    1:     }
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SetTextZoom(float aZoom)
    1: {
    1:   FORWARD_TO_OUTER(SetTextZoom, (aZoom), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (mDocShell) {
    1:     nsCOMPtr<nsIContentViewer> contentViewer;
    1:     mDocShell->GetContentViewer(getter_AddRefs(contentViewer));
    1:     nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(contentViewer));
    1: 
    1:     if (markupViewer)
    1:       return markupViewer->SetTextZoom(aZoom);
    1:   }
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::MakeScriptDialogTitle(nsAString &aOutTitle)
    1: {
    1:   aOutTitle.Truncate();
    1: 
    1:   // Try to get a host from the running principal -- this will do the
    1:   // right thing for javascript: and data: documents.
    1: 
    1:   nsresult rv = NS_OK;
    1:   NS_ASSERTION(nsContentUtils::GetSecurityManager(),
    1:     "Global Window has no security manager!");
    1:   if (nsContentUtils::GetSecurityManager()) {
    1:     nsCOMPtr<nsIPrincipal> principal;
    1:     rv = nsContentUtils::GetSecurityManager()->
    1:       GetSubjectPrincipal(getter_AddRefs(principal));
    1: 
    1:     if (NS_SUCCEEDED(rv) && principal) {
    1:       nsCOMPtr<nsIURI> uri;
    1:       rv = principal->GetURI(getter_AddRefs(uri));
    1: 
    1:       if (NS_SUCCEEDED(rv) && uri) {
    1:         // remove user:pass for privacy and spoof prevention
    1: 
    1:         nsCOMPtr<nsIURIFixup> fixup(do_GetService(NS_URIFIXUP_CONTRACTID));
    1:         if (fixup) {
    1:           nsCOMPtr<nsIURI> fixedURI;
    1:           rv = fixup->CreateExposableURI(uri, getter_AddRefs(fixedURI));
    1:           if (NS_SUCCEEDED(rv) && fixedURI) {
    1:             nsCAutoString host;
    1:             fixedURI->GetHost(host);
    1: 
    1:             if (!host.IsEmpty()) {
    1:               // if this URI has a host we'll show it. For other
    1:               // schemes (e.g. file:) we fall back to the localized
    1:               // generic string
    1: 
    1:               nsCAutoString prepath;
    1:               fixedURI->GetPrePath(prepath);
    1: 
    1:               NS_ConvertUTF8toUTF16 ucsPrePath(prepath);
    1:               const PRUnichar *formatStrings[] = { ucsPrePath.get() };
    1:               nsXPIDLString tempString;
    1:               nsContentUtils::FormatLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
    1:                                                     "ScriptDlgHeading",
80467:                                                     formatStrings, ArrayLength(formatStrings),
    1:                                                     tempString);
    1:               aOutTitle = tempString;
    1:             }
    1:           }
    1:         }
    1:       }
    1:     }
    1:     else { // failed to get subject principal
    1:       NS_WARNING("No script principal? Who is calling alert/confirm/prompt?!");
    1:     }
    1:   }
    1: 
    1:   if (aOutTitle.IsEmpty()) {
    1:     // We didn't find a host so use the generic heading
    1:     nsXPIDLString tempString;
    1:     nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
    1:                                        "ScriptDlgGenericHeading",
    1:                                        tempString);
    1:     aOutTitle = tempString;
    1:   }
    1: 
    1:   // Just in case
    1:   if (aOutTitle.IsEmpty()) {
    1:     NS_WARNING("could not get ScriptDlgGenericHeading string from string bundle");
    1:     aOutTitle.AssignLiteral("[Script]");
    1:   }
    1: }
    1: 
79445: bool
10989: nsGlobalWindow::CanMoveResizeWindows()
10989: {
71105:   // When called from chrome, we can avoid the following checks.
71105:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
71105:     // Don't allow scripts to move or resize windows that were not opened by a
71105:     // script.
71105:     if (!mHadOriginalOpener) {
80486:       return false;
71105:     }
71105: 
71105:     if (!CanSetProperty("dom.disable_window_move_resize")) {
80486:       return false;
71105:     }
71105: 
71105:     // Ignore the request if we have more than one tab in the window.
71105:     nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
71105:     GetTreeOwner(getter_AddRefs(treeOwner));
71105:     if (treeOwner) {
71105:       PRUint32 itemCount;
71105:       if (NS_SUCCEEDED(treeOwner->GetTargetableShellCount(&itemCount)) &&
71105:           itemCount > 1) {
80486:         return false;
71105:       }
71105:     }
71105:   }
10989: 
72453:   if (mDocShell) {
79445:     bool allow;
72453:     nsresult rv = mDocShell->GetAllowWindowControl(&allow);
72453:     if (NS_SUCCEEDED(rv) && !allow)
80486:       return false;
72453:   }
72453: 
13279:   if (gMouseDown && !gDragServiceDisabled) {
13279:     nsCOMPtr<nsIDragService> ds =
13279:       do_GetService("@mozilla.org/widget/dragservice;1");
13279:     if (ds) {
80486:       gDragServiceDisabled = true;
13279:       ds->Suppress();
13279:     }
13279:   }
80486:   return true;
13279: }
10989: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Alert(const nsAString& aString)
    1: {
    1:   FORWARD_TO_OUTER(Alert, (aString), NS_ERROR_NOT_INITIALIZED);
    1: 
54231:   if (AreDialogsBlocked())
54231:     return NS_ERROR_NOT_AVAILABLE;
54231: 
54231:   // We have to capture this now so as not to get confused with the
54231:   // popup state we push next
79445:   bool shouldEnableDisableDialog = DialogOpenAttempted();
54231: 
    1:   // Reset popup state while opening a modal dialog, and firing events
    1:   // about the dialog, to prevent the current state from being active
    1:   // the whole time a modal dialog is open.
80486:   nsAutoPopupStatePusher popupStatePusher(openAbused, true);
    1: 
    1:   // Special handling for alert(null) in JS for backwards
    1:   // compatibility.
    1: 
    1:   NS_NAMED_LITERAL_STRING(null_str, "null");
    1: 
    1:   const nsAString *str = DOMStringIsNull(aString) ? &null_str : &aString;
    1: 
    1:   // Before bringing up the window, unsuppress painting and flush
    1:   // pending reflows.
    1:   EnsureReflowFlushAndPaint();
    1: 
    1:   nsAutoString title;
    1:   MakeScriptDialogTitle(title);
    1: 
    1:   // Remove non-terminating null characters from the 
    1:   // string. See bug #310037. 
    1:   nsAutoString final;
38887:   nsContentUtils::StripNullChars(*str, final);
    1: 
62631:   // Check if we're being called at a point where we can't use tab-modal
62631:   // prompts, because something doesn't want reentrancy.
79445:   bool allowTabModal = GetIsTabModalPromptAllowed();
62631: 
42304:   nsresult rv;
57937:   nsCOMPtr<nsIPromptFactory> promptFac =
57937:     do_GetService("@mozilla.org/prompter;1", &rv);
42304:   NS_ENSURE_SUCCESS(rv, rv);
42304: 
57937:   nsCOMPtr<nsIPrompt> prompt;
57937:   rv = promptFac->GetPrompt(this, NS_GET_IID(nsIPrompt),
57937:                             reinterpret_cast<void**>(&prompt));
57937:   NS_ENSURE_SUCCESS(rv, rv);
57937: 
57937:   nsCOMPtr<nsIWritablePropertyBag2> promptBag = do_QueryInterface(prompt);
57937:   if (promptBag)
62631:     promptBag->SetPropertyAsBool(NS_LITERAL_STRING("allowTabModal"), allowTabModal);
57937: 
54231:   if (shouldEnableDisableDialog) {
79445:     bool disallowDialog = false;
54231:     nsXPIDLString label;
54231:     nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
54231:                                        "ScriptDialogLabel", label);
54231: 
57937:     rv = prompt->AlertCheck(title.get(), final.get(), label.get(),
54231:                             &disallowDialog);
54231:     if (disallowDialog)
54231:       PreventFurtherDialogs();
54231:   } else {
57937:     rv = prompt->Alert(title.get(), final.get());
54231:   }
54231: 
54231:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsGlobalWindow::Confirm(const nsAString& aString, bool* aReturn)
    1: {
    1:   FORWARD_TO_OUTER(Confirm, (aString, aReturn), NS_ERROR_NOT_INITIALIZED);
    1: 
54231:   if (AreDialogsBlocked())
54231:     return NS_ERROR_NOT_AVAILABLE;
54231: 
54231:   // We have to capture this now so as not to get confused with the popup state
54231:   // we push next
79445:   bool shouldEnableDisableDialog = DialogOpenAttempted();
54231: 
    1:   // Reset popup state while opening a modal dialog, and firing events
    1:   // about the dialog, to prevent the current state from being active
    1:   // the whole time a modal dialog is open.
80486:   nsAutoPopupStatePusher popupStatePusher(openAbused, true);
80486: 
80486:   *aReturn = false;
    1: 
    1:   // Before bringing up the window, unsuppress painting and flush
    1:   // pending reflows.
    1:   EnsureReflowFlushAndPaint();
    1: 
    1:   nsAutoString title;
    1:   MakeScriptDialogTitle(title);
    1: 
    1:   // Remove non-terminating null characters from the 
    1:   // string. See bug #310037. 
    1:   nsAutoString final;
38887:   nsContentUtils::StripNullChars(aString, final);
    1: 
62631:   // Check if we're being called at a point where we can't use tab-modal
62631:   // prompts, because something doesn't want reentrancy.
79445:   bool allowTabModal = GetIsTabModalPromptAllowed();
62631: 
42304:   nsresult rv;
57937:   nsCOMPtr<nsIPromptFactory> promptFac =
57937:     do_GetService("@mozilla.org/prompter;1", &rv);
42304:   NS_ENSURE_SUCCESS(rv, rv);
42304: 
57937:   nsCOMPtr<nsIPrompt> prompt;
57937:   rv = promptFac->GetPrompt(this, NS_GET_IID(nsIPrompt),
57937:                             reinterpret_cast<void**>(&prompt));
57937:   NS_ENSURE_SUCCESS(rv, rv);
57937: 
57937:   nsCOMPtr<nsIWritablePropertyBag2> promptBag = do_QueryInterface(prompt);
57937:   if (promptBag)
62631:     promptBag->SetPropertyAsBool(NS_LITERAL_STRING("allowTabModal"), allowTabModal);
57937: 
54231:   if (shouldEnableDisableDialog) {
79445:     bool disallowDialog = false;
54231:     nsXPIDLString label;
54231:     nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
54231:                                        "ScriptDialogLabel", label);
54231: 
57937:     rv = prompt->ConfirmCheck(title.get(), final.get(), label.get(),
54231:                               &disallowDialog, aReturn);
54231:     if (disallowDialog)
54231:       PreventFurtherDialogs();
54231:   } else {
57937:     rv = prompt->Confirm(title.get(), final.get(), aReturn);
54231:   }
54231: 
54231:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Prompt(const nsAString& aMessage, const nsAString& aInitial,
    1:                        nsAString& aReturn)
    1: {
62357:   FORWARD_TO_OUTER(Prompt, (aMessage, aInitial, aReturn),
62357:                    NS_ERROR_NOT_INITIALIZED);
62357: 
    1:   SetDOMStringToNull(aReturn);
    1: 
54231:   if (AreDialogsBlocked())
54231:     return NS_ERROR_NOT_AVAILABLE;
54231: 
54231:   // We have to capture this now so as not to get confused with the popup state
54231:   // we push next
79445:   bool shouldEnableDisableDialog = DialogOpenAttempted();
54231: 
    1:   // Reset popup state while opening a modal dialog, and firing events
    1:   // about the dialog, to prevent the current state from being active
    1:   // the whole time a modal dialog is open.
80486:   nsAutoPopupStatePusher popupStatePusher(openAbused, true);
    1: 
    1:   // Before bringing up the window, unsuppress painting and flush
    1:   // pending reflows.
    1:   EnsureReflowFlushAndPaint();
    1: 
    1:   nsAutoString title;
    1:   MakeScriptDialogTitle(title);
    1:   
    1:   // Remove non-terminating null characters from the 
    1:   // string. See bug #310037. 
    1:   nsAutoString fixedMessage, fixedInitial;
38887:   nsContentUtils::StripNullChars(aMessage, fixedMessage);
38887:   nsContentUtils::StripNullChars(aInitial, fixedInitial);
    1: 
62631:   // Check if we're being called at a point where we can't use tab-modal
62631:   // prompts, because something doesn't want reentrancy.
79445:   bool allowTabModal = GetIsTabModalPromptAllowed();
62631: 
42304:   nsresult rv;
57937:   nsCOMPtr<nsIPromptFactory> promptFac =
57937:     do_GetService("@mozilla.org/prompter;1", &rv);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
57937:   nsCOMPtr<nsIPrompt> prompt;
57937:   rv = promptFac->GetPrompt(this, NS_GET_IID(nsIPrompt),
57937:                             reinterpret_cast<void**>(&prompt));
57937:   NS_ENSURE_SUCCESS(rv, rv);
57937: 
57937:   nsCOMPtr<nsIWritablePropertyBag2> promptBag = do_QueryInterface(prompt);
57937:   if (promptBag)
62631:     promptBag->SetPropertyAsBool(NS_LITERAL_STRING("allowTabModal"), allowTabModal);
57937: 
42304:   // Pass in the default value, if any.
42304:   PRUnichar *inoutValue = ToNewUnicode(fixedInitial);
79445:   bool disallowDialog = false;
54231: 
54231:   nsXPIDLString label;
54231:   if (shouldEnableDisableDialog) {
54231:     nsContentUtils::GetLocalizedString(nsContentUtils::eCOMMON_DIALOG_PROPERTIES,
54231:                                        "ScriptDialogLabel", label);
54231:   }
54231: 
79445:   bool ok;
57937:   rv = prompt->Prompt(title.get(), fixedMessage.get(),
54231:                       &inoutValue, label.get(), &disallowDialog, &ok);
54231: 
54231:   if (disallowDialog) {
54231:     PreventFurtherDialogs();
54231:   }
54231: 
42304:   NS_ENSURE_SUCCESS(rv, rv);
42304: 
42304:   nsAdoptingString outValue(inoutValue);
42304: 
42304:   if (ok && outValue) {
42304:     aReturn.Assign(outValue);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Focus()
    1: {
    1:   FORWARD_TO_OUTER(Focus, (), NS_ERROR_NOT_INITIALIZED);
    1: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (!fm)
29018:     return NS_OK;
29018: 
    1:   nsCOMPtr<nsIBaseWindow> baseWin = do_QueryInterface(mDocShell);
    1: 
79445:   bool isVisible = false;
    1:   if (baseWin) {
    1:     baseWin->GetVisibility(&isVisible);
    1:   }
    1: 
    1:   if (!isVisible) {
    1:     // A hidden tab is being focused, ignore this call.
    1:     return NS_OK;
    1:   }
    1: 
76293:   nsIDOMWindow *caller = nsContentUtils::GetWindowFromCaller();
73870:   nsCOMPtr<nsIDOMWindow> opener;
52309:   GetOpener(getter_AddRefs(opener));
52309: 
52309:   // Enforce dom.disable_window_flip (for non-chrome), but still allow the
52309:   // window which opened us to raise us at times when popups are allowed
52309:   // (bugs 355482 and 369306).
79445:   bool canFocus = CanSetProperty("dom.disable_window_flip") ||
52309:                     (opener == caller &&
52309:                      RevisePopupAbuseLevel(gPopupControlState) < openAbused);
    1: 
29018:   nsCOMPtr<nsIDOMWindow> activeWindow;
29018:   fm->GetActiveWindow(getter_AddRefs(activeWindow));
29018: 
29018:   nsCOMPtr<nsIDocShellTreeItem> treeItem = do_QueryInterface(mDocShell);
29018:   NS_ASSERTION(treeItem, "What happened?");
29018:   nsCOMPtr<nsIDocShellTreeItem> rootItem;
29018:   treeItem->GetRootTreeItem(getter_AddRefs(rootItem));
29018:   nsCOMPtr<nsIDOMWindow> rootWin = do_GetInterface(rootItem);
79445:   bool isActive = (rootWin == activeWindow);
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   if (treeOwnerAsWin && (canFocus || isActive)) {
79445:     bool isEnabled = true;
    1:     if (NS_SUCCEEDED(treeOwnerAsWin->GetEnabled(&isEnabled)) && !isEnabled) {
    1:       NS_WARNING( "Should not try to set the focus on a disabled window" );
    1:       return NS_OK;
    1:     }
    1: 
29018:     // XXXndeakin not sure what this is for or if it should go somewhere else
    1:     nsCOMPtr<nsIEmbeddingSiteWindow> embeddingWin(do_GetInterface(treeOwnerAsWin));
    1:     if (embeddingWin)
    1:       embeddingWin->SetFocus();
    1:   }
    1: 
29018:   if (!mDocShell)
29018:     return NS_OK;
29018: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   // Don't look for a presshell if we're a root chrome window that's got
    1:   // about:blank loaded.  We don't want to focus our widget in that case.
    1:   // XXXbz should we really be checking for IsInitialDocument() instead?
79445:   bool lookForPresShell = true;
    1:   PRInt32 itemType = nsIDocShellTreeItem::typeContent;
    1:   treeItem->GetItemType(&itemType);
    1:   if (itemType == nsIDocShellTreeItem::typeChrome &&
73870:       GetPrivateRoot() == static_cast<nsIDOMWindow*>(this) &&
    1:       mDocument) {
    1:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
    1:     NS_ASSERTION(doc, "Bogus doc?");
    1:     nsIURI* ourURI = doc->GetDocumentURI();
    1:     if (ourURI) {
78530:       lookForPresShell = !NS_IsAboutBlank(ourURI);
    1:     }
    1:   }
    1: 
    1:   if (lookForPresShell) {
    1:     mDocShell->GetEldestPresShell(getter_AddRefs(presShell));
    1:   }
29018: 
29018:   nsCOMPtr<nsIDocShellTreeItem> parentDsti;
29018:   treeItem->GetParent(getter_AddRefs(parentDsti));
29018: 
29018:   // set the parent's current focus to the frame containing this window.
29018:   nsCOMPtr<nsIDOMWindow> parent(do_GetInterface(parentDsti));
29018:   if (parent) {
29018:     nsCOMPtr<nsIDOMDocument> parentdomdoc;
29018:     parent->GetDocument(getter_AddRefs(parentdomdoc));
29018: 
29018:     nsCOMPtr<nsIDocument> parentdoc = do_QueryInterface(parentdomdoc);
29018:     if (!parentdoc)
29018:       return NS_OK;
29018: 
29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
29018:     nsIContent* frame = parentdoc->FindContentForSubDocument(doc);
29018:     nsCOMPtr<nsIDOMElement> frameElement = do_QueryInterface(frame);
29018:     if (frameElement) {
29018:       PRUint32 flags = nsIFocusManager::FLAG_NOSCROLL;
29018:       if (canFocus)
29018:         flags |= nsIFocusManager::FLAG_RAISE;
29018:       return fm->SetFocus(frameElement, flags);
29018:     }
29018:   }
29018:   else if (canFocus) {
29018:     // if there is no parent, this must be a toplevel window, so raise the
29018:     // window if canFocus is true
29018:     return fm->SetActiveWindow(this);
29018:   }
29018: 
29018:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Blur()
    1: {
    1:   FORWARD_TO_OUTER(Blur, (), NS_ERROR_NOT_INITIALIZED);
    1: 
52309:   // If dom.disable_window_flip == true, then content should not be allowed
52309:   // to call this function (this would allow popunders, bug 369306)
52309:   if (!CanSetProperty("dom.disable_window_flip")) {
52309:     return NS_OK;
52309:   }
52309: 
    1:   // If embedding apps don't implement nsIEmbeddingSiteWindow2, we
    1:   // shouldn't throw exceptions to web content.
    1:   nsresult rv = NS_OK;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   GetTreeOwner(getter_AddRefs(treeOwner));
    1:   nsCOMPtr<nsIEmbeddingSiteWindow2> siteWindow(do_GetInterface(treeOwner));
    1:   if (siteWindow) {
    1:     // This method call may cause mDocShell to become nsnull.
    1:     rv = siteWindow->Blur();
    1: 
29018:     // if the root is focused, clear the focus
29018:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mDocument);
29018:     if (fm && mDocument) {
29018:       nsCOMPtr<nsIDOMElement> element;
80486:       fm->GetFocusedElementForWindow(this, false, nsnull, getter_AddRefs(element));
29018:       nsCOMPtr<nsIContent> content = do_QueryInterface(element);
41634:       if (content == doc->GetRootElement())
29018:         fm->ClearFocus(this);
29018:     }
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Back()
    1: {
    1:   FORWARD_TO_OUTER(Back, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
    1:   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
    1: 
    1:   return webNav->GoBack();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Forward()
    1: {
    1:   FORWARD_TO_OUTER(Forward, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
    1:   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
    1: 
    1:   return webNav->GoForward();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Home()
    1: {
    1:   FORWARD_TO_OUTER(Home, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mDocShell)
    1:     return NS_OK;
    1: 
    1:   nsAdoptingString homeURL =
70976:     Preferences::GetLocalizedString(PREF_BROWSER_STARTUP_HOMEPAGE);
    1: 
    1:   if (homeURL.IsEmpty()) {
    1:     // if all else fails, use this
    1: #ifdef DEBUG_seth
    1:     printf("all else failed.  using %s as the home page\n", DEFAULT_HOME_PAGE);
    1: #endif
    1:     CopyASCIItoUTF16(DEFAULT_HOME_PAGE, homeURL);
    1:   }
    1: 
    1: #ifdef MOZ_PHOENIX
    1:   {
    1:     // Firefox lets the user specify multiple home pages to open in
    1:     // individual tabs by separating them with '|'. Since we don't
    1:     // have the machinery in place to easily open new tabs from here,
    1:     // simply truncate the homeURL at the first '|' character to
    1:     // prevent any possibilities of leaking the users list of home
    1:     // pages to the first home page.
    1:     //
    1:     // Once bug https://bugzilla.mozilla.org/show_bug.cgi?id=221445 is
    1:     // fixed we can revisit this.
    1:     PRInt32 firstPipe = homeURL.FindChar('|');
    1: 
    1:     if (firstPipe > 0) {
    1:       homeURL.Truncate(firstPipe);
    1:     }
    1:   }
    1: #endif
    1: 
    1:   nsresult rv;
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
    1:   NS_ENSURE_TRUE(webNav, NS_ERROR_FAILURE);
    1:   rv = webNav->LoadURI(homeURL.get(),
    1:                        nsIWebNavigation::LOAD_FLAGS_NONE,
    1:                        nsnull,
    1:                        nsnull,
    1:                        nsnull);
    1:   NS_ENSURE_SUCCESS(rv, NS_ERROR_FAILURE);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Stop()
    1: {
    1:   FORWARD_TO_OUTER(Stop, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
    1:   if (!webNav)
    1:     return NS_OK;
    1: 
    1:   return webNav->Stop(nsIWebNavigation::STOP_ALL);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Print()
    1: {
    1: #ifdef NS_PRINTING
    1:   FORWARD_TO_OUTER(Print, (), NS_ERROR_NOT_INITIALIZED);
    1: 
54231:   if (AreDialogsBlocked() || !ConfirmDialogAllowed())
54231:     return NS_ERROR_NOT_AVAILABLE;
54231: 
    1:   nsCOMPtr<nsIWebBrowserPrint> webBrowserPrint;
    1:   if (NS_SUCCEEDED(GetInterface(NS_GET_IID(nsIWebBrowserPrint),
    1:                                 getter_AddRefs(webBrowserPrint)))) {
    1: 
    1:     nsCOMPtr<nsIPrintSettingsService> printSettingsService = 
    1:       do_GetService("@mozilla.org/gfx/printsettings-service;1");
    1: 
    1:     nsCOMPtr<nsIPrintSettings> printSettings;
    1:     if (printSettingsService) {
79445:       bool printSettingsAreGlobal =
79445:         Preferences::GetBool("print.use_global_printsettings", false);
    1: 
    1:       if (printSettingsAreGlobal) {
    1:         printSettingsService->GetGlobalPrintSettings(getter_AddRefs(printSettings));
    1: 
    1:         nsXPIDLString printerName;
42459:         printSettings->GetPrinterName(getter_Copies(printerName));
42459:         if (printerName.IsEmpty()) {
    1:           printSettingsService->GetDefaultPrinterName(getter_Copies(printerName));
42459:           printSettings->SetPrinterName(printerName);
42459:         }
    1:         printSettingsService->InitPrintSettingsFromPrinter(printerName, printSettings);
    1:         printSettingsService->InitPrintSettingsFromPrefs(printSettings, 
80486:                                                          true, 
    1:                                                          nsIPrintSettings::kInitSaveAll);
    1:       } else {
    1:         printSettingsService->GetNewPrintSettings(getter_AddRefs(printSettings));
    1:       }
    1: 
68551:       nsCOMPtr<nsIDOMWindow> callerWin = EnterModalState();
    1:       webBrowserPrint->Print(printSettings, nsnull);
68551:       LeaveModalState(callerWin);
    1: 
79445:       bool savePrintSettings =
79445:         Preferences::GetBool("print.save_print_settings", false);
    1:       if (printSettingsAreGlobal && savePrintSettings) {
    1:         printSettingsService->
    1:           SavePrintSettingsToPrefs(printSettings,
80486:                                    true,
    1:                                    nsIPrintSettings::kInitSaveAll);
    1:         printSettingsService->
    1:           SavePrintSettingsToPrefs(printSettings,
80486:                                    false,
    1:                                    nsIPrintSettings::kInitSavePrinterName);
    1:       }
    1:     } else {
    1:       webBrowserPrint->GetGlobalPrintSettings(getter_AddRefs(printSettings));
    1:       webBrowserPrint->Print(printSettings, nsnull);
    1:     }
    1:   }
38377: #endif //NS_PRINTING
38377: 
38377:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::MoveTo(PRInt32 aXPos, PRInt32 aYPos)
    1: {
    1:   FORWARD_TO_OUTER(MoveTo, (aXPos, aYPos), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent window.moveTo() by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
    1:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&aXPos, &aYPos),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   // mild abuse of a "size" object so we don't need more helper functions
24816:   nsIntSize devPos(CSSToDevIntPixels(nsIntSize(aXPos, aYPos)));
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(devPos.width, devPos.height),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::MoveBy(PRInt32 aXDif, PRInt32 aYDif)
    1: {
    1:   FORWARD_TO_OUTER(MoveBy, (aXDif, aYDif), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent window.moveBy() by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
24816:   // To do this correctly we have to convert what we get from GetPosition
24816:   // into CSS pixels, add the arguments, do the security check, and
24816:   // then convert back to device pixels for the call to SetPosition.
24816: 
    1:   PRInt32 x, y;
    1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetPosition(&x, &y), NS_ERROR_FAILURE);
    1: 
24816:   // mild abuse of a "size" object so we don't need more helper functions
24816:   nsIntSize cssPos(DevToCSSIntPixels(nsIntSize(x, y)));
24816: 
24816:   cssPos.width += aXDif;
24816:   cssPos.height += aYDif;
24816:   
24816:   NS_ENSURE_SUCCESS(CheckSecurityLeftAndTop(&cssPos.width,
24816:                                             &cssPos.height),
24816:                     NS_ERROR_FAILURE);
24816: 
24816:   nsIntSize newDevPos(CSSToDevIntPixels(cssPos));
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetPosition(newDevPos.width,
24816:                                                 newDevPos.height),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ResizeTo(PRInt32 aWidth, PRInt32 aHeight)
    1: {
    1:   FORWARD_TO_OUTER(ResizeTo, (aWidth, aHeight), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent window.resizeTo() by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1:   
    1:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(&aWidth, &aHeight),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   nsIntSize devSz(CSSToDevIntPixels(nsIntSize(aWidth, aHeight)));
24816: 
80486:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetSize(devSz.width, devSz.height, true),
    1:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ResizeBy(PRInt32 aWidthDif, PRInt32 aHeightDif)
    1: {
    1:   FORWARD_TO_OUTER(ResizeBy, (aWidthDif, aHeightDif), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
    1:    * prevent window.resizeBy() by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1:   NS_ENSURE_TRUE(treeOwnerAsWin, NS_ERROR_FAILURE);
    1: 
    1:   PRInt32 width, height;
    1:   NS_ENSURE_SUCCESS(treeOwnerAsWin->GetSize(&width, &height), NS_ERROR_FAILURE);
    1: 
24816:   // To do this correctly we have to convert what we got from GetSize
24816:   // into CSS pixels, add the arguments, do the security check, and
24816:   // then convert back to device pixels for the call to SetSize.
24816: 
24816:   nsIntSize cssSize(DevToCSSIntPixels(nsIntSize(width, height)));
24816: 
24816:   cssSize.width += aWidthDif;
24816:   cssSize.height += aHeightDif;
24816: 
24816:   NS_ENSURE_SUCCESS(CheckSecurityWidthAndHeight(&cssSize.width,
24816:                                                 &cssSize.height),
    1:                     NS_ERROR_FAILURE);
    1: 
24816:   nsIntSize newDevSize(CSSToDevIntPixels(cssSize));
24816: 
24816:   NS_ENSURE_SUCCESS(treeOwnerAsWin->SetSize(newDevSize.width,
24816:                                             newDevSize.height,
80486:                                             true),
24816:                     NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::SizeToContent()
    1: {
    1:   FORWARD_TO_OUTER(SizeToContent, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (!mDocShell) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   /*
13308:    * If caller is not chrome and the user has not explicitly exempted the site,
13308:    * prevent window.sizeToContent() by exiting early
    1:    */
    1: 
13308:   if (!CanMoveResizeWindows() || IsFrame()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   // The content viewer does a check to make sure that it's a content
    1:   // viewer for a toplevel docshell.
    1:   
    1:   nsCOMPtr<nsIContentViewer> cv;
    1:   mDocShell->GetContentViewer(getter_AddRefs(cv));
    1:   nsCOMPtr<nsIMarkupDocumentViewer> markupViewer(do_QueryInterface(cv));
    1:   NS_ENSURE_TRUE(markupViewer, NS_ERROR_FAILURE);
    1:   NS_ENSURE_SUCCESS(markupViewer->SizeToContent(), NS_ERROR_FAILURE);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetWindowRoot(nsIDOMEventTarget **aWindowRoot)
    1: {
38336:   nsCOMPtr<nsPIWindowRoot> root = GetTopWindowRoot();
38336:   return CallQueryInterface(root, aWindowRoot);
38336: }
38336: 
38336: already_AddRefed<nsPIWindowRoot>
38336: nsGlobalWindow::GetTopWindowRoot()
38336: {
73870:   nsIDOMWindow *rootWindow = GetPrivateRoot();
    1:   nsCOMPtr<nsPIDOMWindow> piWin(do_QueryInterface(rootWindow));
38336:   if (!piWin)
38336:     return nsnull;
38336: 
38336:   nsCOMPtr<nsPIWindowRoot> window = do_QueryInterface(piWin->GetChromeEventHandler());
38336:   return window.forget();
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Scroll(PRInt32 aXScroll, PRInt32 aYScroll)
    1: {
    1:   return ScrollTo(aXScroll, aYScroll);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ScrollTo(PRInt32 aXScroll, PRInt32 aYScroll)
    1: {
    1:   FlushPendingNotifications(Flush_Layout);
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063: 
37063:   if (sf) {
    1:     // Here we calculate what the max pixel value is that we can
    1:     // scroll to, we do this by dividing maxint with the pixel to
    1:     // twips conversion factor, and substracting 4, the 4 comes from
    1:     // experimenting with this value, anything less makes the view
    1:     // code not scroll correctly, I have no idea why. -- jst
    1:     const PRInt32 maxpx = nsPresContext::AppUnitsToIntCSSPixels(0x7fffffff) - 4;
    1: 
    1:     if (aXScroll > maxpx) {
    1:       aXScroll = maxpx;
    1:     }
    1: 
    1:     if (aYScroll > maxpx) {
    1:       aYScroll = maxpx;
    1:     }
37063:     sf->ScrollTo(nsPoint(nsPresContext::CSSPixelsToAppUnits(aXScroll),
37063:                          nsPresContext::CSSPixelsToAppUnits(aYScroll)),
37063:                  nsIScrollableFrame::INSTANT);
37063:   }
37063: 
37063:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ScrollBy(PRInt32 aXScrollDif, PRInt32 aYScrollDif)
    1: {
    1:   FlushPendingNotifications(Flush_Layout);
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063: 
37063:   if (sf) {
37063:     nsPoint scrollPos = sf->GetScrollPosition();
37063:     // It seems like it would make more sense for ScrollBy to use
37063:     // SMOOTH mode, but tests seem to depend on the synchronous behaviour.
37063:     // Perhaps Web content does too.
37063:     return ScrollTo(nsPresContext::AppUnitsToIntCSSPixels(scrollPos.x) + aXScrollDif,
37063:                     nsPresContext::AppUnitsToIntCSSPixels(scrollPos.y) + aYScrollDif);
37063:   }
37063: 
37063:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ScrollByLines(PRInt32 numLines)
    1: {
    1:   FlushPendingNotifications(Flush_Layout);
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063:   if (sf) {
37063:     // It seems like it would make more sense for ScrollByLines to use
37063:     // SMOOTH mode, but tests seem to depend on the synchronous behaviour.
37063:     // Perhaps Web content does too.
37063:     sf->ScrollBy(nsIntPoint(0, numLines), nsIScrollableFrame::LINES,
37063:                  nsIScrollableFrame::INSTANT);
37063:   }
37063: 
37063:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ScrollByPages(PRInt32 numPages)
    1: {
    1:   FlushPendingNotifications(Flush_Layout);
37063:   nsIScrollableFrame *sf = GetScrollFrame();
37063:   if (sf) {
37063:     // It seems like it would make more sense for ScrollByPages to use
37063:     // SMOOTH mode, but tests seem to depend on the synchronous behaviour.
37063:     // Perhaps Web content does too.
37063:     sf->ScrollBy(nsIntPoint(0, numPages), nsIScrollableFrame::PAGES,
37063:                  nsIScrollableFrame::INSTANT);
37063:   }
37063: 
37063:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
82813: nsGlobalWindow::ClearTimeout(PRInt32 aHandle)
82813: {
82813:   if (aHandle <= 0) {
82813:     return NS_OK;
82813:   }
82813: 
82813:   return ClearTimeoutOrInterval(aHandle);
82813: }
82813: 
82813: NS_IMETHODIMP
82813: nsGlobalWindow::ClearInterval(PRInt32 aHandle)
82813: {
82813:   if (aHandle <= 0) {
82813:     return NS_OK;
82813:   }
82813: 
82813:   return ClearTimeoutOrInterval(aHandle);
    1: }
    1: 
    1: NS_IMETHODIMP
23272: nsGlobalWindow::SetTimeout(PRInt32 *_retval)
    1: {
80486:   return SetTimeoutOrInterval(false, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
23272: nsGlobalWindow::SetInterval(PRInt32 *_retval)
    1: {
80486:   return SetTimeoutOrInterval(true, _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsGlobalWindow::SetResizable(bool aResizable)
    1: {
    1:   // nop
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: static void
    1: ReportUseOfDeprecatedMethod(nsGlobalWindow* aWindow, const char* aWarning)
    1: {
    1:   nsCOMPtr<nsIDocument> doc = do_QueryInterface(aWindow->GetExtantDocument());
84636:   nsContentUtils::ReportToConsole(nsIScriptError::warningFlag,
84636:                                   "DOM Events", doc,
84636:                                   nsContentUtils::eDOM_PROPERTIES,
84636:                                   aWarning);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::CaptureEvents(PRInt32 aEventFlags)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfCaptureEventsWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::ReleaseEvents(PRInt32 aEventFlags)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfReleaseEventsWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::RouteEvent(nsIDOMEvent* aEvt)
    1: {
    1:   ReportUseOfDeprecatedMethod(this, "UseOfRouteEventWarning");
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::EnableExternalCapture()
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::DisableExternalCapture()
    1: {
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
    1: static
79445: bool IsPopupBlocked(nsIDOMDocument* aDoc)
    1: {
    1:   nsCOMPtr<nsIPopupWindowManager> pm =
    1:     do_GetService(NS_POPUPWINDOWMANAGER_CONTRACTID);
    1: 
    1:   if (!pm) {
80486:     return false;
    1:   }
    1: 
79445:   bool blocked = true;
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(aDoc));
    1: 
    1:   if (doc) {
    1:     PRUint32 permission = nsIPopupWindowManager::ALLOW_POPUP;
    1:     pm->TestPermission(doc->GetDocumentURI(), &permission);
    1:     blocked = (permission == nsIPopupWindowManager::DENY_POPUP);
    1:   }
    1:   return blocked;
    1: }
    1: 
51581: /* static */
51581: void 
51581: nsGlobalWindow::FirePopupBlockedEvent(nsIDOMDocument* aDoc,
    1:                                       nsIDOMWindow *aRequestingWindow, nsIURI *aPopupURI,
    1:                                       const nsAString &aPopupWindowName,
    1:                                       const nsAString &aPopupWindowFeatures)
    1: {
    1:   if (aDoc) {
    1:     // Fire a "DOMPopupBlocked" event so that the UI can hear about
    1:     // blocked popups.
    1:     nsCOMPtr<nsIDOMEvent> event;
70359:     aDoc->CreateEvent(NS_LITERAL_STRING("PopupBlockedEvents"),
    1:                       getter_AddRefs(event));
    1:     if (event) {
    1:       nsCOMPtr<nsIDOMPopupBlockedEvent> pbev(do_QueryInterface(event));
    1:       pbev->InitPopupBlockedEvent(NS_LITERAL_STRING("DOMPopupBlocked"),
80486:                                   true, true, aRequestingWindow,
    1:                                   aPopupURI, aPopupWindowName,
    1:                                   aPopupWindowFeatures);
    1:       nsCOMPtr<nsIPrivateDOMEvent> privateEvent(do_QueryInterface(event));
80486:       privateEvent->SetTrusted(true);
    1: 
    1:       nsCOMPtr<nsIDOMEventTarget> targ(do_QueryInterface(aDoc));
79445:       bool defaultActionEnabled;
    1:       targ->DispatchEvent(event, &defaultActionEnabled);
    1:     }
    1:   }
    1: }
    1: 
    1: void FirePopupWindowEvent(nsIDOMDocument* aDoc)
    1: {
    1:   // Fire a "PopupWindow" event
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(aDoc));
    1:   nsContentUtils::DispatchTrustedEvent(doc, aDoc,
    1:                                        NS_LITERAL_STRING("PopupWindow"),
80486:                                        true, true);
    1: }
    1: 
    1: // static
79445: bool
    1: nsGlobalWindow::CanSetProperty(const char *aPrefName)
    1: {
    1:   // Chrome can set any property.
    1:   if (nsContentUtils::IsCallerTrustedForWrite()) {
80486:     return true;
    1:   }
    1: 
    1:   // If the pref is set to true, we can not set the property
    1:   // and vice versa.
79445:   return !Preferences::GetBool(aPrefName, true);
79445: }
79445: 
79445: bool
34524: nsGlobalWindow::PopupWhitelisted()
34524: {
34524:   if (!IsPopupBlocked(mDocument))
80486:     return true;
34524: 
34524:   nsCOMPtr<nsIDOMWindow> parent;
34524: 
34524:   if (NS_FAILED(GetParent(getter_AddRefs(parent))) ||
34524:       parent == static_cast<nsIDOMWindow*>(this))
34524:   {
80486:     return false;
34524:   }
34524: 
34524:   return static_cast<nsGlobalWindow*>
34524:                     (static_cast<nsIDOMWindow*>
34524:                                 (parent.get()))->PopupWhitelisted();
34524: }
    1: 
    1: /*
    1:  * Examine the current document state to see if we're in a way that is
    1:  * typically abused by web designers. The window.open code uses this
    1:  * routine to determine whether to allow the new window.
34524:  * Returns a value from the PopupControlState enum.
    1:  */
    1: PopupControlState
34524: nsGlobalWindow::RevisePopupAbuseLevel(PopupControlState aControl)
34524: {
34524:   FORWARD_TO_OUTER(RevisePopupAbuseLevel, (aControl), aControl);
    1: 
    1:   NS_ASSERTION(mDocShell, "Must have docshell");
    1:   
    1:   nsCOMPtr<nsIDocShellTreeItem> item(do_QueryInterface(mDocShell));
    1: 
30709:   NS_ASSERTION(item, "Docshell doesn't implement nsIDocShellTreeItem?");
    1: 
    1:   PRInt32 type = nsIDocShellTreeItem::typeChrome;
    1:   item->GetItemType(&type);
    1:   if (type != nsIDocShellTreeItem::typeContent)
    1:     return openAllowed;
    1: 
34524:   PopupControlState abuse = aControl;
34524:   switch (abuse) {
34524:   case openControlled:
34524:   case openAbused:
34524:   case openOverridden:
34524:     if (PopupWhitelisted())
34524:       abuse = PopupControlState(abuse - 1);
34524:   case openAllowed: break;
34524:   default:
34524:     NS_WARNING("Strange PopupControlState!");
34524:   }
    1: 
    1:   // limit the number of simultaneously open popups
    1:   if (abuse == openAbused || abuse == openControlled) {
70842:     PRInt32 popupMax = Preferences::GetInt("dom.popup_maximum", -1);
    1:     if (popupMax >= 0 && gOpenPopupSpamCount >= popupMax)
    1:       abuse = openOverridden;
    1:   }
    1: 
    1:   return abuse;
    1: }
    1: 
    1: /* If a window open is blocked, fire the appropriate DOM events.
    1:    aBlocked signifies we just blocked a popup.
    1:    aWindow signifies we just opened what is probably a popup.
    1: */
    1: void
79445: nsGlobalWindow::FireAbuseEvents(bool aBlocked, bool aWindow,
    1:                                 const nsAString &aPopupURL,
    1:                                 const nsAString &aPopupWindowName,
    1:                                 const nsAString &aPopupWindowFeatures)
    1: {
    1:   // fetch the URI of the window requesting the opened window
    1: 
    1:   nsCOMPtr<nsIDOMWindow> topWindow;
    1:   GetTop(getter_AddRefs(topWindow));
    1:   if (!topWindow)
    1:     return;
    1: 
    1:   nsCOMPtr<nsIDOMDocument> topDoc;
    1:   topWindow->GetDocument(getter_AddRefs(topDoc));
    1: 
    1:   nsCOMPtr<nsIURI> popupURI;
    1: 
    1:   // build the URI of the would-have-been popup window
    1:   // (see nsWindowWatcher::URIfromURL)
    1: 
    1:   // first, fetch the opener's base URI
    1: 
    1:   nsIURI *baseURL = 0;
    1: 
18868:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
    1:   nsCOMPtr<nsIDOMWindow> contextWindow;
18868: 
    1:   if (cx) {
    1:     nsIScriptContext *currentCX = nsJSUtils::GetDynamicScriptContext(cx);
    1:     if (currentCX) {
    1:       contextWindow = do_QueryInterface(currentCX->GetGlobalObject());
    1:     }
    1:   }
    1:   if (!contextWindow)
 3233:     contextWindow = static_cast<nsIDOMWindow*>(this);
    1: 
    1:   nsCOMPtr<nsIDOMDocument> domdoc;
    1:   contextWindow->GetDocument(getter_AddRefs(domdoc));
    1:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(domdoc));
    1:   if (doc)
41900:     baseURL = doc->GetDocBaseURI();
    1: 
    1:   // use the base URI to build what would have been the popup's URI
    1:   nsCOMPtr<nsIIOService> ios(do_GetService(NS_IOSERVICE_CONTRACTID));
    1:   if (ios)
    1:     ios->NewURI(NS_ConvertUTF16toUTF8(aPopupURL), 0, baseURL,
    1:                 getter_AddRefs(popupURI));
    1: 
    1:   // fire an event chock full of informative URIs
    1:   if (aBlocked)
    1:     FirePopupBlockedEvent(topDoc, this, popupURI, aPopupWindowName,
    1:                           aPopupWindowFeatures);
    1:   if (aWindow)
    1:     FirePopupWindowEvent(topDoc);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Open(const nsAString& aUrl, const nsAString& aName,
    1:                      const nsAString& aOptions, nsIDOMWindow **_retval)
    1: {
    1:   return OpenInternal(aUrl, aName, aOptions,
80486:                       false,          // aDialog
80486:                       false,          // aContentModal
80486:                       true,           // aCalledNoScript
80486:                       false,          // aDoJSFixups
    1:                       nsnull, nsnull,    // No args
    1:                       GetPrincipal(),    // aCalleePrincipal
    1:                       nsnull,            // aJSCallerContext
    1:                       _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
19026: nsGlobalWindow::OpenJS(const nsAString& aUrl, const nsAString& aName,
19026:                        const nsAString& aOptions, nsIDOMWindow **_retval)
19026: {
19026:   return OpenInternal(aUrl, aName, aOptions,
80486:                       false,          // aDialog
80486:                       false,          // aContentModal
80486:                       false,          // aCalledNoScript
80486:                       true,           // aDoJSFixups
    1:                       nsnull, nsnull,    // No args
    1:                       GetPrincipal(),    // aCalleePrincipal
19026:                       nsContentUtils::GetCurrentJSContext(), // aJSCallerContext
    1:                       _retval);
    1: }
    1: 
    1: // like Open, but attaches to the new window any extra parameters past
    1: // [features] as a JS property named "arguments"
    1: NS_IMETHODIMP
    1: nsGlobalWindow::OpenDialog(const nsAString& aUrl, const nsAString& aName,
    1:                            const nsAString& aOptions,
    1:                            nsISupports* aExtraArgument, nsIDOMWindow** _retval)
    1: {
    1:   return OpenInternal(aUrl, aName, aOptions,
80486:                       true,                    // aDialog
80486:                       false,                   // aContentModal
80486:                       true,                    // aCalledNoScript
80486:                       false,                   // aDoJSFixups
    1:                       nsnull, aExtraArgument,     // Arguments
    1:                       GetPrincipal(),             // aCalleePrincipal
    1:                       nsnull,                     // aJSCallerContext
    1:                       _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
19026: nsGlobalWindow::OpenDialog(const nsAString& aUrl, const nsAString& aName,
19026:                            const nsAString& aOptions, nsIDOMWindow** _retval)
    1: {
    1:   if (!nsContentUtils::IsCallerTrustedForWrite()) {
    1:     return NS_ERROR_DOM_SECURITY_ERR;
    1:   }
    1: 
10286:   nsAXPCNativeCallContext *ncc = nsnull;
    1:   nsresult rv = nsContentUtils::XPConnect()->
10286:     GetCurrentNativeCallContext(&ncc);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   if (!ncc)
    1:     return NS_ERROR_NOT_AVAILABLE;
    1: 
    1:   JSContext *cx = nsnull;
    1: 
    1:   rv = ncc->GetJSContext(&cx);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   PRUint32 argc;
    1:   jsval *argv = nsnull;
    1: 
    1:   // XXX - need to get this as nsISupports?
    1:   ncc->GetArgc(&argc);
    1:   ncc->GetArgvPtr(&argv);
    1: 
    1:   // Strip the url, name and options from the args seen by scripts.
    1:   PRUint32 argOffset = argc < 3 ? argc : 3;
    1:   nsCOMPtr<nsIArray> argvArray;
19026:   rv = NS_CreateJSArgv(cx, argc - argOffset, argv + argOffset,
19026:                        getter_AddRefs(argvArray));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
19026:   return OpenInternal(aUrl, aName, aOptions,
80486:                       true,             // aDialog
80486:                       false,            // aContentModal
80486:                       false,            // aCalledNoScript
80486:                       false,            // aDoJSFixups
    1:                       argvArray, nsnull,   // Arguments
    1:                       GetPrincipal(),      // aCalleePrincipal
    1:                       cx,                  // aJSCallerContext
    1:                       _retval);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetFrames(nsIDOMWindow** aFrames)
    1: {
    1:   FORWARD_TO_OUTER(GetFrames, (aFrames), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aFrames = this;
    1:   NS_ADDREF(*aFrames);
    1: 
    1:   FlushPendingNotifications(Flush_ContentAndNotify);
    1: 
    1:   return NS_OK;
    1: }
    1: 
11028: nsGlobalWindow*
11028: nsGlobalWindow::CallerInnerWindow()
10976: {
18868:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
18868:   if (!cx) {
18868:     NS_ERROR("Please don't call this method from C++!");
18868: 
10976:     return nsnull;
10976:   }
10976: 
62953:   JSObject *scope = nsnull;
62953:   JSStackFrame *fp = nsnull;
62953:   JS_FrameIterator(cx, &fp);
62953:   if (fp) {
69223:     while (!JS_IsScriptFrame(cx, fp)) {
62953:       if (!JS_FrameIterator(cx, &fp))
62953:         break;
62953:     }
62953: 
62953:     if (fp)
80154:       scope = JS_GetGlobalForFrame(fp);
62953:   }
62953: 
62953:   if (!scope)
80154:     scope = JS_GetGlobalForScopeChain(cx);
55623: 
55623:   JSAutoEnterCompartment ac;
62953:   if (!ac.enter(cx, scope))
10976:     return nsnull;
10976: 
10976:   nsCOMPtr<nsIXPConnectWrappedNative> wrapper;
10976:   nsContentUtils::XPConnect()->
80154:     GetWrappedNativeOfJSObject(cx, scope, getter_AddRefs(wrapper));
10976:   if (!wrapper)
10976:     return nsnull;
10976: 
10976:   // The calling window must be holding a reference, so we can just return a
10976:   // raw pointer here and let the QI's addref be balanced by the nsCOMPtr
10976:   // destructor's release.
10976:   nsCOMPtr<nsPIDOMWindow> win = do_QueryWrappedNative(wrapper);
11028:   if (!win)
11028:     return GetCurrentInnerWindowInternal();
10976:   return static_cast<nsGlobalWindow*>(win.get());
10976: }
10976: 
14898: /**
14898:  * Class used to represent events generated by calls to Window.postMessage,
14898:  * which asynchronously creates and dispatches events.
14898:  */
14898: class PostMessageEvent : public nsRunnable
14898: {
14898:   public:
14898:     NS_DECL_NSIRUNNABLE
14898: 
14898:     PostMessageEvent(nsGlobalWindow* aSource,
14898:                      const nsAString& aCallerOrigin,
14898:                      nsGlobalWindow* aTargetWindow,
14898:                      nsIURI* aProvidedOrigin,
79445:                      bool aTrustedCaller)
14898:     : mSource(aSource),
14898:       mCallerOrigin(aCallerOrigin),
70373:       mMessage(nsnull),
70373:       mMessageLen(0),
14898:       mTargetWindow(aTargetWindow),
14898:       mProvidedOrigin(aProvidedOrigin),
14898:       mTrustedCaller(aTrustedCaller)
14898:     {
14898:       MOZ_COUNT_CTOR(PostMessageEvent);
14898:     }
14898:     
14898:     ~PostMessageEvent()
14898:     {
70373:       NS_ASSERTION(!mMessage, "Message should have been deserialized!");
14898:       MOZ_COUNT_DTOR(PostMessageEvent);
14898:     }
14898: 
70373:     void SetJSData(JSAutoStructuredCloneBuffer& aBuffer)
70373:     {
70373:       NS_ASSERTION(!mMessage && mMessageLen == 0, "Don't call twice!");
70373:       aBuffer.steal(&mMessage, &mMessageLen);
70373:     }
70373: 
75350:     bool StoreISupports(nsISupports* aSupports)
75350:     {
75350:       mSupportsArray.AppendElement(aSupports);
75350:       return true;
75350:     }
75350: 
14898:   private:
14898:     nsRefPtr<nsGlobalWindow> mSource;
14898:     nsString mCallerOrigin;
84755:     uint64_t* mMessage;
70373:     size_t mMessageLen;
14898:     nsRefPtr<nsGlobalWindow> mTargetWindow;
14898:     nsCOMPtr<nsIURI> mProvidedOrigin;
79445:     bool mTrustedCaller;
75350:     nsTArray<nsCOMPtr<nsISupports> > mSupportsArray;
14898: };
14898: 
75350: namespace {
75350: 
75350: struct StructuredCloneInfo {
75350:   PostMessageEvent* event;
79445:   bool subsumes;
75350: };
75350: 
75350: static JSObject*
75350: PostMessageReadStructuredClone(JSContext* cx,
75350:                                JSStructuredCloneReader* reader,
75350:                                uint32 tag,
75350:                                uint32 data,
75350:                                void* closure)
75350: {
78436:   NS_ASSERTION(closure, "Must have closure!");
75350: 
75350:   if (tag == SCTAG_DOM_BLOB || tag == SCTAG_DOM_FILELIST) {
75350:     NS_ASSERTION(!data, "Data should be empty");
75350: 
75350:     nsISupports* supports;
75350:     if (JS_ReadBytes(reader, &supports, sizeof(supports))) {
80154:       JSObject* global = JS_GetGlobalForScopeChain(cx);
75350:       if (global) {
75350:         jsval val;
75350:         nsCOMPtr<nsIXPConnectJSObjectHolder> wrapper;
75350:         if (NS_SUCCEEDED(nsContentUtils::WrapNative(cx, global, supports,
75350:                                                     &val,
75350:                                                     getter_AddRefs(wrapper)))) {
75350:           return JSVAL_TO_OBJECT(val);
75350:         }
75350:       }
75350:     }
75350:   }
75350: 
75350:   const JSStructuredCloneCallbacks* runtimeCallbacks =
87277:     js::GetContextStructuredCloneCallbacks(cx);
75350: 
75350:   if (runtimeCallbacks) {
75350:     return runtimeCallbacks->read(cx, reader, tag, data, nsnull);
75350:   }
75350: 
75350:   return JS_FALSE;
75350: }
75350: 
75350: static JSBool
75350: PostMessageWriteStructuredClone(JSContext* cx,
75350:                                 JSStructuredCloneWriter* writer,
75350:                                 JSObject* obj,
75350:                                 void *closure)
75350: {
75350:   StructuredCloneInfo* scInfo = static_cast<StructuredCloneInfo*>(closure);
75350:   NS_ASSERTION(scInfo, "Must have scInfo!");
75350: 
75350:   nsCOMPtr<nsIXPConnectWrappedNative> wrappedNative;
75350:   nsContentUtils::XPConnect()->
75350:     GetWrappedNativeOfJSObject(cx, obj, getter_AddRefs(wrappedNative));
75350:   if (wrappedNative) {
75350:     PRUint32 scTag = 0;
75350:     nsISupports* supports = wrappedNative->Native();
75350: 
75350:     nsCOMPtr<nsIDOMBlob> blob = do_QueryInterface(supports);
75350:     if (blob && scInfo->subsumes)
75350:       scTag = SCTAG_DOM_BLOB;
75350: 
75350:     nsCOMPtr<nsIDOMFileList> list = do_QueryInterface(supports);
75350:     if (list && scInfo->subsumes)
75350:       scTag = SCTAG_DOM_FILELIST;
75350: 
75350:     if (scTag)
75350:       return JS_WriteUint32Pair(writer, scTag, 0) &&
75350:              JS_WriteBytes(writer, &supports, sizeof(supports)) &&
75350:              scInfo->event->StoreISupports(supports);
75350:   }
75350: 
75350:   const JSStructuredCloneCallbacks* runtimeCallbacks =
87277:     js::GetContextStructuredCloneCallbacks(cx);
75350: 
75350:   if (runtimeCallbacks) {
75350:     return runtimeCallbacks->write(cx, writer, obj, nsnull);
75350:   }
75350: 
75350:   return JS_FALSE;
75350: }
75350: 
75350: JSStructuredCloneCallbacks kPostMessageCallbacks = {
75350:   PostMessageReadStructuredClone,
75350:   PostMessageWriteStructuredClone,
75350:   nsnull
75350: };
75350: 
75350: } // anonymous namespace
75350: 
14898: NS_IMETHODIMP
14898: PostMessageEvent::Run()
14898: {
14898:   NS_ABORT_IF_FALSE(mTargetWindow->IsOuterWindow(),
14898:                     "should have been passed an outer window!");
14898:   NS_ABORT_IF_FALSE(!mSource || mSource->IsOuterWindow(),
14898:                     "should have been passed an outer window!");
14898: 
70373:   // Get the JSContext for the target window
70821:   JSContext* cx = nsnull;
70373:   nsIScriptContext* scriptContext = mTargetWindow->GetContext();
70821:   if (scriptContext) {
78415:     cx = scriptContext->GetNativeContext();
70821:   }
70821: 
70821:   if (!cx) {
70821:     // This can happen if mTargetWindow has been closed.  To avoid leaking,
70821:     // we need to find a JSContext.
70821:     nsIThreadJSContextStack* cxStack = nsContentUtils::ThreadJSContextStack();
70821:     if (cxStack) {
70821:       cxStack->GetSafeJSContext(&cx);
70821:     }
70821: 
70821:     if (!cx) {
70821:       NS_WARNING("Cannot find a JSContext!  Leaking PostMessage buffer.");
70821:       return NS_ERROR_FAILURE;
70821:     }
70821:   }
70373: 
70373:   // If we bailed before this point we're going to leak mMessage, but
70373:   // that's probably better than crashing.
70373: 
70373:   // Ensure that the buffer is freed even if we fail to post the message
70373:   JSAutoStructuredCloneBuffer buffer;
74542:   buffer.adopt(mMessage, mMessageLen);
70373:   mMessage = nsnull;
70373:   mMessageLen = 0;
70373: 
39378:   nsRefPtr<nsGlobalWindow> targetWindow;
39378:   if (mTargetWindow->IsClosedOrClosing() ||
39378:       !(targetWindow = mTargetWindow->GetCurrentInnerWindowInternal()) ||
39378:       targetWindow->IsClosedOrClosing())
15240:     return NS_OK;
15240: 
14898:   NS_ABORT_IF_FALSE(targetWindow->IsInnerWindow(),
14898:                     "we ordered an inner window!");
14898: 
14898:   // Ensure that any origin which might have been provided is the origin of this
14898:   // window's document.  Note that we do this *now* instead of when postMessage
14898:   // is called because the target window might have been navigated to a
14898:   // different location between then and now.  If this check happened when
14898:   // postMessage was called, it would be fairly easy for a malicious webpage to
14898:   // intercept messages intended for another site by carefully timing navigation
14898:   // of the target window so it changed location after postMessage but before
14898:   // now.
14898:   if (mProvidedOrigin) {
14898:     // Get the target's origin either from its principal or, in the case the
14898:     // principal doesn't carry a URI (e.g. the system principal), the target's
14898:     // document.
14898:     nsIPrincipal* targetPrin = targetWindow->GetPrincipal();
14898:     if (!targetPrin)
14898:       return NS_OK;
14898:     nsCOMPtr<nsIURI> targetURI;
14898:     if (NS_FAILED(targetPrin->GetURI(getter_AddRefs(targetURI))))
14898:       return NS_OK;
14898:     if (!targetURI) {
14898:       targetURI = targetWindow->mDoc->GetDocumentURI();
14898:       if (!targetURI)
14898:         return NS_OK;
14898:     }
14898: 
14898:     // Note: This is contrary to the spec with respect to file: URLs, which
14898:     //       the spec groups into a single origin, but given we intentionally
14898:     //       don't do that in other places it seems better to hold the line for
14898:     //       now.  Long-term, we want HTML5 to address this so that we can
14898:     //       be compliant while being safer.
14898:     nsIScriptSecurityManager* ssm = nsContentUtils::GetSecurityManager();
14898:     nsresult rv =
80486:       ssm->CheckSameOriginURI(mProvidedOrigin, targetURI, true);
14898:     if (NS_FAILED(rv))
14898:       return NS_OK;
14898:   }
14898: 
70373:   // Deserialize the structured clone data
70373:   jsval messageData;
70373:   {
70373:     JSAutoRequest ar(cx);
75350:     StructuredCloneInfo scInfo;
75350:     scInfo.event = this;
75350: 
75350:     if (!buffer.read(cx, &messageData, &kPostMessageCallbacks, &scInfo))
70373:       return NS_ERROR_DOM_DATA_CLONE_ERR;
70373:   }
14898: 
14898:   // Create the event
70359:   nsCOMPtr<nsIDOMDocument> domDoc = do_QueryInterface(targetWindow->mDocument);
70359:   if (!domDoc)
14898:     return NS_OK;
14898:   nsCOMPtr<nsIDOMEvent> event;
70359:   domDoc->CreateEvent(NS_LITERAL_STRING("MessageEvent"),
14898:                       getter_AddRefs(event));
14898:   if (!event)
14898:     return NS_OK;
14898: 
14898:   nsCOMPtr<nsIDOMMessageEvent> message = do_QueryInterface(event);
14898:   nsresult rv = message->InitMessageEvent(NS_LITERAL_STRING("message"),
80486:                                           false /* non-bubbling */,
80486:                                           true /* cancelable */,
70373:                                           messageData,
14898:                                           mCallerOrigin,
14898:                                           EmptyString(),
14898:                                           mSource);
14898:   if (NS_FAILED(rv))
14898:     return NS_OK;
14898: 
14898: 
14898:   // We can't simply call dispatchEvent on the window because doing so ends
14898:   // up flipping the trusted bit on the event, and we don't want that to
14898:   // happen because then untrusted content can call postMessage on a chrome
14898:   // window if it can get a reference to it.
14898: 
46225:   nsIPresShell *shell = targetWindow->mDoc->GetShell();
14898:   nsRefPtr<nsPresContext> presContext;
14898:   if (shell)
14898:     presContext = shell->GetPresContext();
14898: 
14898:   nsCOMPtr<nsIPrivateDOMEvent> privEvent = do_QueryInterface(message);
14898:   privEvent->SetTrusted(mTrustedCaller);
20234:   nsEvent *internalEvent = privEvent->GetInternalNSEvent();
14898: 
14898:   nsEventStatus status = nsEventStatus_eIgnore;
14898:   nsEventDispatcher::Dispatch(static_cast<nsPIDOMWindow*>(mTargetWindow),
14898:                               presContext,
14898:                               internalEvent,
14898:                               message,
14898:                               &status);
14898:   return NS_OK;
14898: }
14898: 
11363: NS_IMETHODIMP
70373: nsGlobalWindow::PostMessageMoz(const jsval& aMessage,
70373:                                const nsAString& aOrigin,
70373:                                JSContext* aCx)
70373: {
70373:   FORWARD_TO_OUTER(PostMessageMoz, (aMessage, aOrigin, aCx),
70373:                    NS_ERROR_NOT_INITIALIZED);
10976: 
10976:   //
10976:   // Window.postMessage is an intentional subversion of the same-origin policy.
10976:   // As such, this code must be particularly careful in the information it
10976:   // exposes to calling code.
10976:   //
10976:   // http://www.whatwg.org/specs/web-apps/current-work/multipage/section-crossDocumentMessages.html
10976:   //
10976: 
10976:   // First, get the caller's window
10976:   nsRefPtr<nsGlobalWindow> callerInnerWin = CallerInnerWindow();
10976:   if (!callerInnerWin)
10976:     return NS_OK;
14898:   NS_ABORT_IF_FALSE(callerInnerWin->IsInnerWindow(),
14898:                     "should have gotten an inner window here");
10976: 
12322:   // Compute the caller's origin either from its principal or, in the case the
12322:   // principal doesn't carry a URI (e.g. the system principal), the caller's
14898:   // document.  We must get this now instead of when the event is created and
14898:   // dispatched, because ultimately it is the identity of the calling window
14898:   // *now* that determines who sent the message (and not an identity which might
14898:   // have changed due to intervening navigations).
10976:   nsIPrincipal* callerPrin = callerInnerWin->GetPrincipal();
10976:   if (!callerPrin)
10976:     return NS_OK;
24084:   
14898:   nsCOMPtr<nsIURI> callerOuterURI;
14898:   if (NS_FAILED(callerPrin->GetURI(getter_AddRefs(callerOuterURI))))
14898:     return NS_OK;
24084: 
24084:   nsAutoString origin;
24084:   if (callerOuterURI) {
24084:     // if the principal has a URI, use that to generate the origin
24084:     nsContentUtils::GetUTFOrigin(callerPrin, origin);
24084:   }
24084:   else {
24084:     // otherwise use the URI of the document to generate origin
10976:     nsCOMPtr<nsIDocument> doc = do_QueryInterface(callerInnerWin->mDocument);
10976:     if (!doc)
10976:       return NS_OK;
14898:     callerOuterURI = doc->GetDocumentURI();
24084:     // if the principal has a URI, use that to generate the origin
24084:     nsContentUtils::GetUTFOrigin(callerOuterURI, origin);
24084:   }
12322: 
14898:   // Convert the provided origin string into a URI for comparison purposes.
14898:   // "*" indicates no specific origin is required.
12322:   nsCOMPtr<nsIURI> providedOrigin;
14898:   if (!aOrigin.EqualsASCII("*")) {
12322:     if (NS_FAILED(NS_NewURI(getter_AddRefs(providedOrigin), aOrigin)))
12322:       return NS_ERROR_DOM_SYNTAX_ERR;
24084:     if (NS_FAILED(providedOrigin->SetUserPass(EmptyCString())) ||
24084:         NS_FAILED(providedOrigin->SetPath(EmptyCString())))
24084:       return NS_OK;
24084:   }
10976: 
14898:   // Create and asynchronously dispatch a runnable which will handle actual DOM
14898:   // event creation and dispatch.
14898:   nsRefPtr<PostMessageEvent> event =
14898:     new PostMessageEvent(nsContentUtils::IsCallerChrome()
14898:                          ? nsnull
14898:                          : callerInnerWin->GetOuterWindowInternal(),
24084:                          origin,
14898:                          this,
14898:                          providedOrigin,
14898:                          nsContentUtils::IsCallerTrustedForWrite());
70373: 
70373:   // We *must* clone the data here, or the jsval could be modified
70373:   // by script
70373:   JSAutoStructuredCloneBuffer buffer;
75350:   StructuredCloneInfo scInfo;
75350:   scInfo.event = event;
75350: 
75350:   nsIPrincipal* principal = GetPrincipal();
75350:   if (NS_FAILED(callerPrin->Subsumes(principal, &scInfo.subsumes)))
75350:     return NS_ERROR_DOM_DATA_CLONE_ERR;
75350: 
75350:   if (!buffer.write(aCx, aMessage, &kPostMessageCallbacks, &scInfo))
70373:     return NS_ERROR_DOM_DATA_CLONE_ERR;
70373: 
70373:   event->SetJSData(buffer);
70373: 
14898:   return NS_DispatchToCurrentThread(event);
10976: }
10976: 
    1: class nsCloseEvent : public nsRunnable {
39378: 
39378:   nsRefPtr<nsGlobalWindow> mWindow;
39378: 
    1:   nsCloseEvent(nsGlobalWindow *aWindow)
    1:     : mWindow(aWindow)
39378:   {}
39378: 
39378: public:
39378: 
39378:   static nsresult
39378:   PostCloseEvent(nsGlobalWindow* aWindow) {
39378:     nsCOMPtr<nsIRunnable> ev = new nsCloseEvent(aWindow);
39378:     nsresult rv = NS_DispatchToCurrentThread(ev);
39378:     if (NS_SUCCEEDED(rv))
39378:       aWindow->MaybeForgiveSpamCount();
39378:     return rv;
    1:   }
    1: 
    1:   NS_IMETHOD Run() {
    1:     if (mWindow)
    1:       mWindow->ReallyCloseWindow();
    1:     return NS_OK;
    1:   }
    1: 
    1: };
    1: 
79445: bool
37611: nsGlobalWindow::CanClose()
37611: {
37611:   if (!mDocShell)
80486:     return true;
37611: 
37611:   // Ask the content viewer whether the toplevel window can close.
37611:   // If the content viewer returns false, it is responsible for calling
37611:   // Close() as soon as it is possible for the window to close.
37611:   // This allows us to not close the window while printing is happening.
37611: 
37611:   nsCOMPtr<nsIContentViewer> cv;
37611:   mDocShell->GetContentViewer(getter_AddRefs(cv));
37611:   if (cv) {
79445:     bool canClose;
80486:     nsresult rv = cv->PermitUnload(false, &canClose);
37611:     if (NS_SUCCEEDED(rv) && !canClose)
80486:       return false;
37611: 
37611:     rv = cv->RequestWindowClose(&canClose);
37611:     if (NS_SUCCEEDED(rv) && !canClose)
80486:       return false;
80486:   }
80486: 
80486:   return true;
37611: }
37611: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Close()
    1: {
    1:   FORWARD_TO_OUTER(Close, (), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   if (IsFrame() || !mDocShell || IsInModalState()) {
    1:     // window.close() is called on a frame in a frameset, on a window
    1:     // that's already closed, or on a window for which there's
    1:     // currently a modal dialog open. Ignore such calls.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (mHavePendingClose) {
    1:     // We're going to be closed anyway; do nothing since we don't want
    1:     // to double-close
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (mBlockScriptedClosingFlag)
    1:   {
    1:     // A script's popup has been blocked and we don't want
    1:     // the window to be closed directly after this event,
    1:     // so the user can see that there was a blocked popup.
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Don't allow scripts from content to close windows
    1:   // that were not opened by script
    1:   if (!mHadOriginalOpener && !nsContentUtils::IsCallerTrustedForWrite()) {
79445:     bool allowClose =
79445:       Preferences::GetBool("dom.allow_scripts_to_close_windows", true);
    1:     if (!allowClose) {
    1:       // We're blocking the close operation
    1:       // report localized error msg in JS console
    1:       nsContentUtils::ReportToConsole(
84636:           nsIScriptError::warningFlag,
84636:           "DOM Window", mDoc,  // Better name for the category?
    1:           nsContentUtils::eDOM_PROPERTIES,
84636:           "WindowCloseBlockedWarning");
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
37611:   if (!mInClose && !mIsClosed && !CanClose())
37611:     return NS_OK;
    1: 
    1:   // Fire a DOM event notifying listeners that this window is about to
    1:   // be closed. The tab UI code may choose to cancel the default
    1:   // action for this event, if so, we won't actually close the window
    1:   // (since the tab UI code will close the tab in stead). Sure, this
    1:   // could be abused by content code, but do we care? I don't think
    1:   // so...
    1: 
79445:   bool wasInClose = mInClose;
80486:   mInClose = true;
    1: 
    1:   if (!DispatchCustomEvent("DOMWindowClose")) {
    1:     // Someone chose to prevent the default action for this event, if
    1:     // so, let's not close this window after all...
    1: 
    1:     mInClose = wasInClose;
    1:     return NS_OK;
    1:   }
    1: 
37611:   return FinalClose();
37611: }
37611: 
37611: nsresult
37611: nsGlobalWindow::ForceClose()
37611: {
37611:   if (IsFrame() || !mDocShell) {
37611:     // This may be a frame in a frameset, or a window that's already closed.
37611:     // Ignore such calls.
37611: 
37611:     return NS_OK;
37611:   }
37611: 
37611:   if (mHavePendingClose) {
37611:     // We're going to be closed anyway; do nothing since we don't want
37611:     // to double-close
37611:     return NS_OK;
37611:   }
37611: 
80486:   mInClose = true;
37611: 
37611:   DispatchCustomEvent("DOMWindowClose");
37611: 
37611:   return FinalClose();
37611: }
37611: 
37611: nsresult
37611: nsGlobalWindow::FinalClose()
37611: {
37611:   nsresult rv;
    1:   // Flag that we were closed.
80486:   mIsClosed = true;
    1: 
    1:   nsCOMPtr<nsIJSContextStack> stack =
    1:     do_GetService(sJSStackContractID);
    1: 
    1:   JSContext *cx = nsnull;
    1: 
    1:   if (stack) {
    1:     stack->Peek(&cx);
    1:   }
    1: 
    1:   if (cx) {
    1:     nsIScriptContext *currentCX = nsJSUtils::GetDynamicScriptContext(cx);
    1: 
47537:     if (currentCX && currentCX == GetContextInternal()) {
    1:       // We ignore the return value here.  If setting the termination function
    1:       // fails, it's better to fail to close the window than it is to crash
    1:       // (which is what would tend to happen if we did this synchronously
    1:       // here).
    1:       rv = currentCX->SetTerminationFunction(CloseWindow,
 3233:                                              static_cast<nsIDOMWindow *>
 3233:                                                         (this));
    1:       if (NS_SUCCEEDED(rv)) {
80486:         mHavePendingClose = true;
    1:       }
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   
    1:   // We may have plugins on the page that have issued this close from their
    1:   // event loop and because we currently destroy the plugin window with
    1:   // frames, we crash. So, if we are called from Javascript, post an event
    1:   // to really close the window.
    1:   rv = NS_ERROR_FAILURE;
    1:   if (!nsContentUtils::IsCallerChrome()) {
39378:     rv = nsCloseEvent::PostCloseEvent(this);
    1:   }
    1:   
    1:   if (NS_FAILED(rv)) {
    1:     ReallyCloseWindow();
    1:     rv = NS_OK;
    1:   } else {
80486:     mHavePendingClose = true;
    1:   }
    1:   
    1:   return rv;
    1: }
    1: 
    1: 
    1: void
    1: nsGlobalWindow::ReallyCloseWindow()
    1: {
    1:   FORWARD_TO_OUTER_VOID(ReallyCloseWindow, ());
    1: 
    1:   // Make sure we never reenter this method.
80486:   mHavePendingClose = true;
    1: 
    1:   nsCOMPtr<nsIBaseWindow> treeOwnerAsWin;
    1:   GetTreeOwner(getter_AddRefs(treeOwnerAsWin));
    1: 
    1:   // If there's no treeOwnerAsWin, this window must already be closed.
    1: 
    1:   if (treeOwnerAsWin) {
    1: 
    1:     // but if we're a browser window we could be in some nasty
    1:     // self-destroying cascade that we should mostly ignore
    1: 
    1:     nsCOMPtr<nsIDocShellTreeItem> docItem(do_QueryInterface(mDocShell));
    1:     if (docItem) {
    1:       nsCOMPtr<nsIBrowserDOMWindow> bwin;
    1:       nsCOMPtr<nsIDocShellTreeItem> rootItem;
    1:       docItem->GetRootTreeItem(getter_AddRefs(rootItem));
    1:       nsCOMPtr<nsIDOMWindow> rootWin(do_GetInterface(rootItem));
    1:       nsCOMPtr<nsIDOMChromeWindow> chromeWin(do_QueryInterface(rootWin));
    1:       if (chromeWin)
    1:         chromeWin->GetBrowserDOMWindow(getter_AddRefs(bwin));
    1: 
    1:       if (rootWin) {
    1:         /* Normally we destroy the entire window, but not if
    1:            this DOM window belongs to a tabbed browser and doesn't
    1:            correspond to a tab. This allows a well-behaved tab
    1:            to destroy the container as it should but is a final measure
    1:            to prevent an errant tab from doing so when it shouldn't.
    1:            This works because we reach this code when we shouldn't only
    1:            in the particular circumstance that we belong to a tab
    1:            that has just been closed (and is therefore already missing
    1:            from the list of browsers) (and has an unload handler
    1:            that closes the window). */
    1:         // XXXbz now that we have mHavePendingClose, is this needed?
79445:         bool isTab = false;
    1:         if (rootWin == this ||
    1:             !bwin || (bwin->IsTabContentWindow(GetOuterWindowInternal(),
    1:                                                &isTab), isTab))
    1:           treeOwnerAsWin->Destroy();
    1:       }
    1:     }
    1: 
80486:     CleanUp(false);
    1:   }
    1: }
    1: 
61768: nsIDOMWindow *
    1: nsGlobalWindow::EnterModalState()
    1: {
54231:   nsGlobalWindow* topWin = GetTop();
54231: 
54231:   if (!topWin) {
    1:     NS_ERROR("Uh, EnterModalState() called w/o a reachable top window?");
    1: 
61768:     return nsnull;
    1:   }
    1: 
60229:   // If there is an active ESM in this window, clear it. Otherwise, this can
60229:   // cause a problem if a modal state is entered during a mouseup event.
60229:   nsEventStateManager* activeESM =
60229:     static_cast<nsEventStateManager*>(nsEventStateManager::GetActiveEventStateManager());
60229:   if (activeESM && activeESM->GetPresContext()) {
60229:     nsIPresShell* activeShell = activeESM->GetPresContext()->GetPresShell();
60229:     if (activeShell && (
60229:         nsContentUtils::ContentIsCrossDocDescendantOf(activeShell->GetDocument(), mDoc) ||
60229:         nsContentUtils::ContentIsCrossDocDescendantOf(mDoc, activeShell->GetDocument()))) {
60229:       nsEventStateManager::ClearGlobalActiveContent(activeESM);
60421: 
60421:       activeShell->SetCapturingContent(nsnull, 0);
60421: 
60421:       if (activeShell) {
70097:         nsRefPtr<nsFrameSelection> frameSelection = activeShell->FrameSelection();
80486:         frameSelection->SetMouseDownState(false);
60421:       }
60229:     }
60229:   }
60229: 
25722:   if (topWin->mModalStateDepth == 0) {
25722:     NS_ASSERTION(!mSuspendedDoc, "Shouldn't have mSuspendedDoc here!");
25722: 
25722:     mSuspendedDoc = do_QueryInterface(topWin->GetExtantDocument());
25724:     if (mSuspendedDoc && mSuspendedDoc->EventHandlingSuppressed()) {
25722:       mSuspendedDoc->SuppressEventHandling();
25724:     } else {
25724:       mSuspendedDoc = nsnull;
25722:     }
25722:   }
25722:   topWin->mModalStateDepth++;
29105: 
61768:   JSContext *cx = nsContentUtils::GetCurrentJSContext();
61768: 
61768:   nsCOMPtr<nsIDOMWindow> callerWin;
61768:   nsIScriptContext *scx;
61768:   if (cx && (scx = GetScriptContextFromJSContext(cx))) {
61768:     scx->EnterModalState();
61768:     callerWin = do_QueryInterface(nsJSUtils::GetDynamicScriptGlobal(cx));
61768:   }
61768: 
57392:   if (mContext) {
57392:     mContext->EnterModalState();
29105:   }
61768: 
61768:   return callerWin;
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::RunPendingTimeoutsRecursive(nsGlobalWindow *aTopWindow,
    1:                                             nsGlobalWindow *aWindow)
    1: {
    1:   nsGlobalWindow *inner;
    1: 
    1:   // Return early if we're frozen or have no inner window.
    1:   if (!(inner = aWindow->GetCurrentInnerWindowInternal()) ||
    1:       inner->IsFrozen()) {
    1:     return;
    1:   }
    1: 
    1:   inner->RunTimeout(nsnull);
    1: 
    1:   // Check again if we're frozen since running pending timeouts
    1:   // could've frozen us.
    1:   if (inner->IsFrozen()) {
    1:     return;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDOMWindowCollection> frames;
    1:   aWindow->GetFrames(getter_AddRefs(frames));
    1: 
    1:   if (!frames) {
    1:     return;
    1:   }
    1: 
    1:   PRUint32 i, length;
    1:   if (NS_FAILED(frames->GetLength(&length)) || !length) {
    1:     return;
    1:   }
    1: 
    1:   for (i = 0; i < length && aTopWindow->mModalStateDepth == 0; i++) {
    1:     nsCOMPtr<nsIDOMWindow> child;
    1:     frames->Item(i, getter_AddRefs(child));
    1: 
    1:     if (!child) {
    1:       return;
    1:     }
    1: 
    1:     nsGlobalWindow *childWin =
 3233:       static_cast<nsGlobalWindow *>
 3233:                  (static_cast<nsIDOMWindow *>
 3233:                              (child.get()));
    1: 
    1:     RunPendingTimeoutsRecursive(aTopWindow, childWin);
    1:   }
    1: }
    1: 
    1: class nsPendingTimeoutRunner : public nsRunnable
    1: {
    1: public:
    1:   nsPendingTimeoutRunner(nsGlobalWindow *aWindow)
    1:     : mWindow(aWindow)
    1:   {
    1:     NS_ASSERTION(mWindow, "mWindow is null.");
    1:   }
    1: 
    1:   NS_IMETHOD Run()
    1:   {
    1:     nsGlobalWindow::RunPendingTimeoutsRecursive(mWindow, mWindow);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1: private:
    1:   nsRefPtr<nsGlobalWindow> mWindow;
    1: };
    1: 
    1: void
61768: nsGlobalWindow::LeaveModalState(nsIDOMWindow *aCallerWin)
    1: {
54231:   nsGlobalWindow *topWin = GetTop();
54231: 
54231:   if (!topWin) {
    1:     NS_ERROR("Uh, LeaveModalState() called w/o a reachable top window?");
    1:     return;
    1:   }
    1: 
    1:   topWin->mModalStateDepth--;
    1: 
    1:   if (topWin->mModalStateDepth == 0) {
    1:     nsCOMPtr<nsIRunnable> runner = new nsPendingTimeoutRunner(topWin);
    1:     if (NS_FAILED(NS_DispatchToCurrentThread(runner)))
    1:       NS_WARNING("failed to dispatch pending timeout runnable");
25722: 
25722:     if (mSuspendedDoc) {
25722:       nsCOMPtr<nsIDocument> currentDoc =
25722:         do_QueryInterface(topWin->GetExtantDocument());
26591:       mSuspendedDoc->UnsuppressEventHandlingAndFireEvents(currentDoc == mSuspendedDoc);
25722:       mSuspendedDoc = nsnull;
25722:     }
    1:   }
29105: 
61768:   if (aCallerWin) {
61768:     nsCOMPtr<nsIScriptGlobalObject> sgo(do_QueryInterface(aCallerWin));
61768:     nsIScriptContext *scx = sgo->GetContext();
62912:     if (scx)
61768:       scx->LeaveModalState();
61768:   }
61768: 
57392:   if (mContext) {
57392:     mContext->LeaveModalState();
29105:   }
54231: 
54231:   // Remember the time of the last dialog quit.
54231:   nsGlobalWindow *inner = topWin->GetCurrentInnerWindowInternal();
54231:   if (inner)
54231:     inner->mLastDialogQuitTime = TimeStamp::Now();
    1: }
    1: 
79445: bool
    1: nsGlobalWindow::IsInModalState()
    1: {
54231:   nsGlobalWindow *topWin = GetTop();
54231: 
54231:   if (!topWin) {
    1:     NS_ERROR("Uh, IsInModalState() called w/o a reachable top window?");
    1: 
80486:     return false;
    1:   }
    1: 
54231:   return topWin->mModalStateDepth != 0;
    1: }
    1: 
11693: // static
11693: void
11693: nsGlobalWindow::NotifyDOMWindowDestroyed(nsGlobalWindow* aWindow) {
11693:   nsCOMPtr<nsIObserverService> observerService =
84835:     services::GetObserverService();
11693:   if (observerService) {
11693:     observerService->
11693:       NotifyObservers(static_cast<nsIScriptGlobalObject*>(aWindow),
11693:                       DOM_WINDOW_DESTROYED_TOPIC, nsnull);
11693:   }
11693: }
11693: 
42340: class WindowDestroyedEvent : public nsRunnable
42340: {
42340: public:
42340:   WindowDestroyedEvent(PRUint64 aID, const char* aTopic) :
42340:     mID(aID), mTopic(aTopic) {}
42340: 
42340:   NS_IMETHOD Run()
42340:   {
42340:     nsCOMPtr<nsIObserverService> observerService =
42340:       do_GetService("@mozilla.org/observer-service;1");
42340:     if (observerService) {
42340:       nsCOMPtr<nsISupportsPRUint64> wrapper =
42340:         do_CreateInstance(NS_SUPPORTS_PRUINT64_CONTRACTID);
42340:       if (wrapper) {
42340:         wrapper->SetData(mID);
42340:         observerService->NotifyObservers(wrapper, mTopic.get(), nsnull);
42340:       }
42340:     }
42340:     return NS_OK;
42340:   }
42340: 
42340: private:
42340:   PRUint64 mID;
42340:   nsCString mTopic;
42340: };
42340: 
42340: void
42340: nsGlobalWindow::NotifyWindowIDDestroyed(const char* aTopic)
42340: {
42340:   nsRefPtr<nsIRunnable> runnable = new WindowDestroyedEvent(mWindowID, aTopic);
42340:   nsresult rv = NS_DispatchToCurrentThread(runnable);
42340:   if (NS_SUCCEEDED(rv)) {
80486:     mNotifiedIDDestroyed = true;
42340:   }
42340: }
42340: 
70324: // static
70324: void
70324: nsGlobalWindow::NotifyDOMWindowFrozen(nsGlobalWindow* aWindow) {
70324:   if (aWindow && aWindow->IsInnerWindow()) {
70324:     nsCOMPtr<nsIObserverService> observerService =
84835:       services::GetObserverService();
70324:     if (observerService) {
70324:       observerService->
70324:         NotifyObservers(static_cast<nsIScriptGlobalObject*>(aWindow),
70324:                         DOM_WINDOW_FROZEN_TOPIC, nsnull);
70324:     }
70324:   }
70324: }
70324: 
70324: // static
70324: void
70324: nsGlobalWindow::NotifyDOMWindowThawed(nsGlobalWindow* aWindow) {
70324:   if (aWindow && aWindow->IsInnerWindow()) {
70324:     nsCOMPtr<nsIObserverService> observerService =
84835:       services::GetObserverService();
70324:     if (observerService) {
70324:       observerService->
70324:         NotifyObservers(static_cast<nsIScriptGlobalObject*>(aWindow),
70324:                         DOM_WINDOW_THAWED_TOPIC, nsnull);
70324:     }
70324:   }
70324: }
70324: 
 6774: void
 6774: nsGlobalWindow::InitJavaProperties()
 6774: {
 6774:   nsIScriptContext *scx = GetContextInternal();
 6774: 
 6774:   if (mDidInitJavaProperties || IsOuterWindow() || !scx || !mJSObject) {
 6774:     return;
 6774:   }
 6774: 
 6774:   // Set mDidInitJavaProperties to true here even if initialization
 6774:   // can fail. If it fails, we won't try again...
80486:   mDidInitJavaProperties = true;
 6774: 
 6774:   mDummyJavaPluginOwner = new nsDummyJavaPluginOwner(mDoc);
 6774:   if (!mDummyJavaPluginOwner) {
 6774:     return;
 6774:   }
 6774: 
70185:   nsCOMPtr<nsIPluginHost> pluginHostCOM(do_GetService(MOZ_PLUGIN_HOST_CONTRACTID));
70185:   nsPluginHost *pluginHost = static_cast<nsPluginHost*>(pluginHostCOM.get());
70185:   if (!pluginHost) {
70185:     return;
70185:   }  
70185:   pluginHost->InstantiateDummyJavaPlugin(mDummyJavaPluginOwner);
 6774: 
28034:   // It's possible for us (or the Java plugin, rather) to process
28034:   // events during the above call, which can lead to this window being
28034:   // torn down or what not, so re-check that the dummy plugin is still
28034:   // around.
28034:   if (!mDummyJavaPluginOwner) {
28034:     return;
28034:   }
28034: 
70007:   nsRefPtr<nsNPAPIPluginInstance> dummyPlugin;
70007:   mDummyJavaPluginOwner->GetInstance(getter_AddRefs(dummyPlugin));
 6774: 
 6774:   if (dummyPlugin) {
 6774:     // A dummy plugin was instantiated. This means we have a Java
 6774:     // plugin that supports NPRuntime. For such a plugin, the plugin
 6774:     // instantiation code defines the Java properties for us, so we're
 6774:     // done here.
 6774: 
 6774:     return;
 6774:   }
 6774: 
 6774:   // No NPRuntime enabled Java plugin found, null out the owner we
 6774:   // would have used in that case as it's no longer needed.
 6774:   mDummyJavaPluginOwner = nsnull;
 7273: }
 6774: 
82803: JSObject*
11622: nsGlobalWindow::GetCachedXBLPrototypeHandler(nsXBLPrototypeHandler* aKey)
11622: {
82804:   JSObject* handler = nsnull;
11622:   if (mCachedXBLPrototypeHandlers.IsInitialized()) {
11622:     mCachedXBLPrototypeHandlers.Get(aKey, &handler);
11622:   }
82804:   return handler;
11622: }
11622: 
11622: void
11622: nsGlobalWindow::CacheXBLPrototypeHandler(nsXBLPrototypeHandler* aKey,
84858:                                          nsScriptObjectHolder<JSObject>& aHandler)
11622: {
11622:   if (!mCachedXBLPrototypeHandlers.IsInitialized() &&
11622:       !mCachedXBLPrototypeHandlers.Init()) {
11622:     NS_ERROR("Failed to initiailize hashtable!");
11622:     return;
11622:   }
11622: 
11622:   if (!mCachedXBLPrototypeHandlers.Count()) {
11622:     // Can't use macros to get the participant because nsGlobalChromeWindow also
11622:     // runs through this code. Use QueryInterface to get the correct objects.
11622:     nsXPCOMCycleCollectionParticipant* participant;
11622:     CallQueryInterface(this, &participant);
11622:     NS_ASSERTION(participant,
11622:                  "Failed to QI to nsXPCOMCycleCollectionParticipant!");
11622: 
57794:     nsISupports* thisSupports;
11622:     QueryInterface(NS_GET_IID(nsCycleCollectionISupports),
57794:                    reinterpret_cast<void**>(&thisSupports));
11622:     NS_ASSERTION(thisSupports, "Failed to QI to nsCycleCollectionISupports!");
11622: 
11622:     nsresult rv = nsContentUtils::HoldJSObjects(thisSupports, participant);
11622:     if (NS_FAILED(rv)) {
11622:       NS_ERROR("nsContentUtils::HoldJSObjects failed!");
11622:       return;
11622:     }
11622:   }
11622: 
84858:   mCachedXBLPrototypeHandlers.Put(aKey, aHandler.get());
11622: }
11622: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetFrameElement(nsIDOMElement** aFrameElement)
    1: {
    1:   FORWARD_TO_OUTER(GetFrameElement, (aFrameElement), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aFrameElement = nsnull;
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellTI(do_QueryInterface(mDocShell));
    1: 
    1:   if (!docShellTI) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> parent;
    1:   docShellTI->GetSameTypeParent(getter_AddRefs(parent));
    1: 
    1:   if (!parent || parent == docShellTI) {
    1:     // We're at a chrome boundary, don't expose the chrome iframe
    1:     // element to content code.
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   *aFrameElement = mFrameElement;
    1:   NS_IF_ADDREF(*aFrameElement);
    1: 
    1:   return NS_OK;
    1: }
    1: 
 4422: // Helper for converting window.showModalDialog() options (list of ';'
 4422: // separated name (:|=) value pairs) to a format that's parsable by
 4422: // our normal window opening code.
 4422: 
 4040: void
 4040: ConvertDialogOptions(const nsAString& aOptions, nsAString& aResult)
 4040: {
 4040:   nsAString::const_iterator end;
 4040:   aOptions.EndReading(end);
 4040: 
 4040:   nsAString::const_iterator iter;
 4040:   aOptions.BeginReading(iter);
 4040: 
 4040:   while (iter != end) {
 4040:     // Skip whitespace.
 4040:     while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
 4040:       ++iter;
 4040:     }
 4040: 
 4040:     nsAString::const_iterator name_start = iter;
 4040: 
 4040:     // Skip characters until we find whitespace, ';', ':', or '='
 4040:     while (iter != end && !nsCRT::IsAsciiSpace(*iter) &&
 4040:            *iter != ';' &&
 4040:            *iter != ':' &&
 4040:            *iter != '=') {
 4040:       ++iter;
 4040:     }
 4040: 
 4040:     nsAString::const_iterator name_end = iter;
 4040: 
 4040:     // Skip whitespace.
 4040:     while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
 4040:       ++iter;
 4040:     }
 4040: 
 4040:     if (*iter == ';') {
 4040:       // No value found, skip the ';' and keep going.
 4040:       ++iter;
 4040: 
 4040:       continue;
 4040:     }
 4040: 
 4040:     nsAString::const_iterator value_start = iter;
 4040:     nsAString::const_iterator value_end = iter;
 4040: 
 4040:     if (*iter == ':' || *iter == '=') {
 4040:       // We found name followed by ':' or '='. Look for a value.
 4040: 
 4040:       iter++; // Skip the ':' or '='
 4040: 
 4040:       // Skip whitespace.
 4040:       while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
 4040:         ++iter;
 4040:       }
 4040: 
 4040:       value_start = iter;
 4040: 
 4040:       // Skip until we find whitespace, or ';'.
 4040:       while (iter != end && !nsCRT::IsAsciiSpace(*iter) &&
 4040:              *iter != ';') {
 4040:         ++iter;
 4040:       }
 4040: 
 4040:       value_end = iter;
 4040: 
 4040:       // Skip whitespace.
 4040:       while (nsCRT::IsAsciiSpace(*iter) && iter != end) {
 4040:         ++iter;
 4040:       }
 4040:     }
 4040: 
 4040:     const nsDependentSubstring& name = Substring(name_start, name_end);
 4040:     const nsDependentSubstring& value = Substring(value_start, value_end);
 4040: 
 4040:     if (name.LowerCaseEqualsLiteral("center")) {
 4040:       if (value.LowerCaseEqualsLiteral("on")  ||
 4040:           value.LowerCaseEqualsLiteral("yes") ||
 4040:           value.LowerCaseEqualsLiteral("1")) {
 4040:         aResult.AppendLiteral(",centerscreen=1");
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("dialogwidth")) {
 4040:       if (!value.IsEmpty()) {
 4040:         aResult.AppendLiteral(",width=");
 4040:         aResult.Append(value);
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("dialogheight")) {
 4040:       if (!value.IsEmpty()) {
 4040:         aResult.AppendLiteral(",height=");
 4040:         aResult.Append(value);
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("dialogtop")) {
 4040:       if (!value.IsEmpty()) {
 4040:         aResult.AppendLiteral(",top=");
 4040:         aResult.Append(value);
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("dialogleft")) {
 4040:       if (!value.IsEmpty()) {
 4040:         aResult.AppendLiteral(",left=");
 4040:         aResult.Append(value);
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("resizable")) {
 4040:       if (value.LowerCaseEqualsLiteral("on")  ||
 4040:           value.LowerCaseEqualsLiteral("yes") ||
 4040:           value.LowerCaseEqualsLiteral("1")) {
 4040:         aResult.AppendLiteral(",resizable=1");
 4040:       }
 4040:     } else if (name.LowerCaseEqualsLiteral("scroll")) {
 4040:       if (value.LowerCaseEqualsLiteral("off")  ||
 4040:           value.LowerCaseEqualsLiteral("no") ||
 4040:           value.LowerCaseEqualsLiteral("0")) {
 4040:         aResult.AppendLiteral(",scrollbars=0");
 4040:       }
 4040:     }
 4040: 
 4040:     if (iter == end) {
 4040:       break;
 4040:     }
 4040: 
 4040:     iter++;
 4040:   }
 4040: }
 4040: 
 4040: NS_IMETHODIMP
 4040: nsGlobalWindow::ShowModalDialog(const nsAString& aURI, nsIVariant *aArgs,
 4040:                                 const nsAString& aOptions,
 4040:                                 nsIVariant **aRetVal)
 4040: {
62357:   FORWARD_TO_OUTER(ShowModalDialog, (aURI, aArgs, aOptions, aRetVal),
62357:                    NS_ERROR_NOT_INITIALIZED);
62357: 
 4087:   *aRetVal = nsnull;
 4087: 
54231:   // Before bringing up the window/dialog, unsuppress painting and flush
54231:   // pending reflows.
54231:   EnsureReflowFlushAndPaint();
54231: 
54231:   if (AreDialogsBlocked() || !ConfirmDialogAllowed())
54231:     return NS_ERROR_NOT_AVAILABLE;
22792: 
 4040:   nsCOMPtr<nsIDOMWindow> dlgWin;
13096:   nsAutoString options(NS_LITERAL_STRING("-moz-internal-modal=1,status=1"));
 4422: 
 4422:   ConvertDialogOptions(aOptions, options);
 4040: 
 4040:   options.AppendLiteral(",scrollbars=1,centerscreen=1,resizable=0");
 4040: 
68551:   nsCOMPtr<nsIDOMWindow> callerWin = EnterModalState();
 4040:   nsresult rv = OpenInternal(aURI, EmptyString(), options,
80486:                              false,          // aDialog
80486:                              true,           // aContentModal
80486:                              true,           // aCalledNoScript
80486:                              true,           // aDoJSFixups
 4040:                              nsnull, aArgs,     // args
 4040:                              GetPrincipal(),    // aCalleePrincipal
 4040:                              nsnull,            // aJSCallerContext
 4040:                              getter_AddRefs(dlgWin));
68551:   LeaveModalState(callerWin);
16266: 
16266:   NS_ENSURE_SUCCESS(rv, rv);
16266:   
16266:   if (dlgWin) {
33525:     nsCOMPtr<nsIPrincipal> subjectPrincipal;
33525:     rv = nsContentUtils::GetSecurityManager()->
33525:       GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
33525:     if (NS_FAILED(rv)) {
33525:       return rv;
33525:     }
33525: 
79445:     bool canAccess = true;
33525: 
33525:     if (subjectPrincipal) {
33525:       nsCOMPtr<nsIScriptObjectPrincipal> objPrincipal =
33525:         do_QueryInterface(dlgWin);
33525:       nsCOMPtr<nsIPrincipal> dialogPrincipal;
33525: 
33525:       if (objPrincipal) {
33525:         dialogPrincipal = objPrincipal->GetPrincipal();
33525: 
33525:         rv = subjectPrincipal->Subsumes(dialogPrincipal, &canAccess);
33525:         NS_ENSURE_SUCCESS(rv, rv);
33525:       } else {
33525:         // Uh, not sure what kind of dialog this is. Prevent access to
33525:         // be on the safe side...
33525: 
80486:         canAccess = false;
33525:       }
33525:     }
33525: 
39378:     nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(dlgWin));
39378: 
38439:     if (canAccess) {
 4040:       nsPIDOMWindow *inner = win->GetCurrentInnerWindow();
 4040: 
 4040:       nsCOMPtr<nsIDOMModalContentWindow> dlgInner(do_QueryInterface(inner));
 4040: 
 4040:       if (dlgInner) {
 4040:         dlgInner->GetReturnValue(aRetVal);
 4040:       }
16266:     }
39378: 
39378:     nsRefPtr<nsGlobalWindow> winInternal =
39378:       static_cast<nsGlobalWindow*>(win.get());
39378:     if (winInternal->mCallCleanUpAfterModalDialogCloses) {
80486:       winInternal->mCallCleanUpAfterModalDialogCloses = false;
80486:       winInternal->CleanUp(true);
39378:     }
33525:   }
 4040:   
 4040:   return NS_OK;
 4040: }
 4040: 
36462: class CommandDispatcher : public nsRunnable
36462: {
36462: public:
36462:   CommandDispatcher(nsIDOMXULCommandDispatcher* aDispatcher,
36462:                     const nsAString& aAction)
36462:   : mDispatcher(aDispatcher), mAction(aAction) {}
36462: 
36462:   NS_IMETHOD Run()
36462:   {
36462:     return mDispatcher->UpdateCommands(mAction);
36462:   }
36462: 
36462:   nsCOMPtr<nsIDOMXULCommandDispatcher> mDispatcher;
36462:   nsString                             mAction;
36462: };
36462: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::UpdateCommands(const nsAString& anAction)
    1: {
    1:   nsPIDOMWindow *rootWindow = nsGlobalWindow::GetPrivateRoot();
    1:   if (!rootWindow)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIDOMXULDocument> xulDoc =
    1:     do_QueryInterface(rootWindow->GetExtantDocument());
    1:   // See if we contain a XUL document.
    1:   if (xulDoc) {
    1:     // Retrieve the command dispatcher and call updateCommands on it.
    1:     nsCOMPtr<nsIDOMXULCommandDispatcher> xulCommandDispatcher;
    1:     xulDoc->GetCommandDispatcher(getter_AddRefs(xulCommandDispatcher));
36462:     if (xulCommandDispatcher) {
36462:       nsContentUtils::AddScriptRunner(new CommandDispatcher(xulCommandDispatcher,
36462:                                                             anAction));
36462:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetSelection(nsISelection** aSelection)
    1: {
    1:   FORWARD_TO_OUTER(GetSelection, (aSelection), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   NS_ENSURE_ARG_POINTER(aSelection);
    1:   *aSelection = nsnull;
    1: 
    1:   if (!mDocShell)
    1:     return NS_OK;
    1: 
    1:   nsCOMPtr<nsIPresShell> presShell;
    1:   mDocShell->GetPresShell(getter_AddRefs(presShell));
    1: 
    1:   if (!presShell)
    1:     return NS_OK;
    1:     
    1:   *aSelection = presShell->GetCurrentSelection(nsISelectionController::SELECTION_NORMAL);
    1:   
    1:   NS_IF_ADDREF(*aSelection);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
79445: nsGlobalWindow::Find(const nsAString& aStr, bool aCaseSensitive,
79445:                      bool aBackwards, bool aWrapAround, bool aWholeWord,
79445:                      bool aSearchInFrames, bool aShowDialog,
79445:                      bool *aDidFind)
    1: {
18869:   FORWARD_TO_OUTER(Find, (aStr, aCaseSensitive, aBackwards, aWrapAround,
18869:                           aWholeWord, aSearchInFrames, aShowDialog, aDidFind),
18869:                    NS_ERROR_NOT_INITIALIZED);
18869: 
    1:   nsresult rv = NS_OK;
80486:   *aDidFind = false;
    1: 
    1:   nsCOMPtr<nsIWebBrowserFind> finder(do_GetInterface(mDocShell));
22792:   NS_ENSURE_TRUE(finder, NS_ERROR_FAILURE);
    1: 
    1:   // Set the options of the search
    1:   rv = finder->SetSearchString(PromiseFlatString(aStr).get());
    1:   NS_ENSURE_SUCCESS(rv, rv);
18869:   finder->SetMatchCase(aCaseSensitive);
18869:   finder->SetFindBackwards(aBackwards);
18869:   finder->SetWrapFind(aWrapAround);
18869:   finder->SetEntireWord(aWholeWord);
18869:   finder->SetSearchFrames(aSearchInFrames);
    1: 
    1:   // the nsIWebBrowserFind is initialized to use this window
    1:   // as the search root, but uses focus to set the current search
    1:   // frame. If we're being called from JS (as here), this window
    1:   // should be the current search frame.
    1:   nsCOMPtr<nsIWebBrowserFindInFrames> framesFinder(do_QueryInterface(finder));
    1:   if (framesFinder) {
    1:     framesFinder->SetRootSearchFrame(this);   // paranoia
    1:     framesFinder->SetCurrentSearchFrame(this);
    1:   }
    1:   
    1:   // The Find API does not accept empty strings. Launch the Find Dialog.
18869:   if (aStr.IsEmpty() || aShowDialog) {
    1:     // See if the find dialog is already up using nsIWindowMediator
    1:     nsCOMPtr<nsIWindowMediator> windowMediator =
    1:       do_GetService(NS_WINDOWMEDIATOR_CONTRACTID);
    1: 
73870:     nsCOMPtr<nsIDOMWindow> findDialog;
    1: 
    1:     if (windowMediator) {
    1:       windowMediator->GetMostRecentWindow(NS_LITERAL_STRING("findInPage").get(),
    1:                                           getter_AddRefs(findDialog));
    1:     }
    1: 
    1:     if (findDialog) {
    1:       // The Find dialog is already open, bring it to the top.
    1:       rv = findDialog->Focus();
    1:     } else { // Open a Find dialog
    1:       if (finder) {
    1:         nsCOMPtr<nsIDOMWindow> dialog;
    1:         rv = OpenDialog(NS_LITERAL_STRING("chrome://global/content/finddialog.xul"),
    1:                         NS_LITERAL_STRING("_blank"),
    1:                         NS_LITERAL_STRING("chrome, resizable=no, dependent=yes"),
    1:                         finder, getter_AddRefs(dialog));
    1:       }
    1:     }
    1:   } else {
    1:     // Launch the search with the passed in search string
    1:     rv = finder->FindNext(aDidFind);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Atob(const nsAString& aAsciiBase64String,
    1:                      nsAString& aBinaryData)
    1: {
74412:   return nsContentUtils::Atob(aAsciiBase64String, aBinaryData);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::Btoa(const nsAString& aBinaryData,
    1:                      nsAString& aAsciiBase64String)
    1: {
74412:   return nsContentUtils::Btoa(aBinaryData, aAsciiBase64String);
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIDOMEventTarget
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::RemoveEventListener(const nsAString& aType,
    1:                                     nsIDOMEventListener* aListener,
79445:                                     bool aUseCapture)
    1: {
80486:   nsRefPtr<nsEventListenerManager> elm = GetListenerManager(false);
72329:   if (elm) {
72329:     elm->RemoveEventListener(aType, aListener, aUseCapture);
72329:   }
72329:   return NS_OK;
    1: }
    1: 
82743: NS_IMPL_REMOVE_SYSTEM_EVENT_LISTENER(nsGlobalWindow)
82743: 
    1: NS_IMETHODIMP
79445: nsGlobalWindow::DispatchEvent(nsIDOMEvent* aEvent, bool* aRetVal)
72324: {
72324:   FORWARD_TO_INNER(DispatchEvent, (aEvent, aRetVal), NS_OK);
    1: 
    1:   if (!mDoc) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   // Obtain a presentation shell
46225:   nsIPresShell *shell = mDoc->GetShell();
39823:   nsRefPtr<nsPresContext> presContext;
    1:   if (shell) {
    1:     // Retrieve the context
    1:     presContext = shell->GetPresContext();
    1:   }
    1: 
    1:   nsEventStatus status = nsEventStatus_eIgnore;
    1:   nsresult rv =
    1:     nsEventDispatcher::DispatchDOMEvent(GetOuterWindow(), nsnull, aEvent,
    1:                                         presContext, &status);
    1: 
72324:   *aRetVal = (status != nsEventStatus_eConsumeNoDefault);
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::AddEventListener(const nsAString& aType,
    1:                                  nsIDOMEventListener *aListener,
79445:                                  bool aUseCapture, bool aWantsUntrusted,
72324:                                  PRUint8 aOptionalArgc)
72324: {
72324:   NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
37183:                "Won't check if this is chrome, you want to set "
80486:                "aWantsUntrusted to false or make the aWantsUntrusted "
37183:                "explicit by making optional_argc non-zero.");
37183: 
37184:   if (IsOuterWindow() && mInnerWindow &&
37184:       !nsContentUtils::CanCallerAccess(mInnerWindow)) {
37184:     return NS_ERROR_DOM_SECURITY_ERR;
37184:   }
37184: 
72329:   if (!aWantsUntrusted &&
72329:       (aOptionalArgc < 2 && !nsContentUtils::IsChromeDoc(mDoc))) {
80486:     aWantsUntrusted = true;
80486:   }
80486: 
80486:   nsEventListenerManager* manager = GetListenerManager(true);
29474:   NS_ENSURE_STATE(manager);
76793:   manager->AddEventListener(aType, aListener, aUseCapture, aWantsUntrusted);
76793:   return NS_OK;
    1: }
    1: 
82743: NS_IMETHODIMP
82743: nsGlobalWindow::AddSystemEventListener(const nsAString& aType,
82743:                                        nsIDOMEventListener *aListener,
82743:                                        bool aUseCapture,
82743:                                        bool aWantsUntrusted,
82743:                                        PRUint8 aOptionalArgc)
82743: {
82743:   NS_ASSERTION(!aWantsUntrusted || aOptionalArgc > 1,
82743:                "Won't check if this is chrome, you want to set "
82743:                "aWantsUntrusted to false or make the aWantsUntrusted "
82743:                "explicit by making optional_argc non-zero.");
82743: 
82743:   if (IsOuterWindow() && mInnerWindow &&
82743:       !nsContentUtils::CanCallerAccess(mInnerWindow)) {
82743:     return NS_ERROR_DOM_SECURITY_ERR;
82743:   }
82743: 
82743:   if (!aWantsUntrusted &&
82743:       (aOptionalArgc < 2 && !nsContentUtils::IsChromeDoc(mDoc))) {
82743:     aWantsUntrusted = true;
82743:   }
82743: 
82743:   return NS_AddSystemEventListener(this, aType, aListener, aUseCapture,
82743:                                    aWantsUntrusted);
82743: }
82743: 
72328: nsEventListenerManager*
79445: nsGlobalWindow::GetListenerManager(bool aCreateIfNotFound)
29474: {
29474:   FORWARD_TO_INNER_CREATE(GetListenerManager, (aCreateIfNotFound), nsnull);
    1: 
72328:   if (!mListenerManager && aCreateIfNotFound) {
72328:     mListenerManager =
72328:       new nsEventListenerManager(static_cast<nsIDOMEventTarget*>(this));
29474:   }
29474: 
29474:   return mListenerManager;
    1: }
    1: 
27700: nsIScriptContext*
27700: nsGlobalWindow::GetContextForEventHandlers(nsresult* aRv)
27700: {
80859:   *aRv = NS_ERROR_UNEXPECTED;
80859:   if (IsInnerWindow()) {
80859:     nsPIDOMWindow* outer = GetOuterWindow();
80859:     NS_ENSURE_TRUE(outer && outer->GetCurrentInnerWindow() == this, nsnull);
80859:   }
80859: 
80859:   nsIScriptContext* scx;
80859:   if ((scx = GetContext())) {
80859:     *aRv = NS_OK;
27700:     return scx;
16056:   }
80859:   return nsnull;
80859: }
16056: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsPIDOMWindow
    1: //*****************************************************************************
    1: 
    1: nsPIDOMWindow*
    1: nsGlobalWindow::GetPrivateParent()
    1: {
    1:   FORWARD_TO_OUTER(GetPrivateParent, (), nsnull);
    1: 
    1:   nsCOMPtr<nsIDOMWindow> parent;
    1:   GetParent(getter_AddRefs(parent));
    1: 
 3233:   if (static_cast<nsIDOMWindow *>(this) == parent.get()) {
    1:     nsCOMPtr<nsIContent> chromeElement(do_QueryInterface(mChromeEventHandler));
    1:     if (!chromeElement)
    1:       return nsnull;             // This is ok, just means a null parent.
    1: 
    1:     nsIDocument* doc = chromeElement->GetDocument();
    1:     if (!doc)
    1:       return nsnull;             // This is ok, just means a null parent.
    1: 
    1:     nsIScriptGlobalObject *globalObject = doc->GetScriptGlobalObject();
    1:     if (!globalObject)
    1:       return nsnull;             // This is ok, just means a null parent.
    1: 
    1:     parent = do_QueryInterface(globalObject);
    1:   }
    1: 
    1:   if (parent) {
 3233:     return static_cast<nsGlobalWindow *>
 3233:                       (static_cast<nsIDOMWindow*>(parent.get()));
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: nsPIDOMWindow*
    1: nsGlobalWindow::GetPrivateRoot()
    1: {
    1:   FORWARD_TO_OUTER(GetPrivateRoot, (), nsnull);
    1: 
    1:   nsCOMPtr<nsIDOMWindow> top;
    1:   GetTop(getter_AddRefs(top));
    1: 
    1:   nsCOMPtr<nsPIDOMWindow> ptop = do_QueryInterface(top);
    1:   NS_ASSERTION(ptop, "cannot get ptop");
    1:   if (!ptop)
    1:     return nsnull;
    1: 
    1:   nsIDocShell *docShell = ptop->GetDocShell();
    1: 
    1:   // Get the chrome event handler from the doc shell, since we only
    1:   // want to deal with XUL chrome handlers and not the new kind of
    1:   // window root handler.
    1:   nsCOMPtr<nsIDOMEventTarget> chromeEventHandler;
    1:   docShell->GetChromeEventHandler(getter_AddRefs(chromeEventHandler));
    1: 
    1:   nsCOMPtr<nsIContent> chromeElement(do_QueryInterface(mChromeEventHandler));
    1:   if (chromeElement) {
    1:     nsIDocument* doc = chromeElement->GetDocument();
    1:     if (doc) {
    1:       nsIDOMWindow *parent = doc->GetWindow();
    1:       if (parent) {
    1:         parent->GetTop(getter_AddRefs(top));
    1:       }
    1:     }
    1:   }
    1: 
 3233:   return static_cast<nsGlobalWindow *>
 3233:                     (static_cast<nsIDOMWindow *>(top));
    1: }
    1: 
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetLocation(nsIDOMLocation ** aLocation)
    1: {
50477:   FORWARD_TO_INNER(GetLocation, (aLocation), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   *aLocation = nsnull;
    1: 
50477:   nsIDocShell *docShell = GetDocShell();
50477:   if (!mLocation && docShell) {
50477:     mLocation = new nsLocation(docShell);
    1:     if (!mLocation) {
    1:       return NS_ERROR_OUT_OF_MEMORY;
    1:     }
    1:   }
    1: 
    1:   NS_IF_ADDREF(*aLocation = mLocation);
    1: 
    1:   return NS_OK;
    1: }
    1: 
29018: void
79445: nsGlobalWindow::ActivateOrDeactivate(bool aActivate)
29018: {
39698:   // Set / unset mIsActive on the top level window, which is used for the
39698:   // :-moz-window-inactive pseudoclass.
29018:   nsCOMPtr<nsIWidget> mainWidget = GetMainWidget();
39698:   if (!mainWidget)
39698:     return;
39698: 
29018:   // Get the top level widget (if the main widget is a sheet, this will
29018:   // be the sheet's top (non-sheet) parent).
29018:   nsCOMPtr<nsIWidget> topLevelWidget = mainWidget->GetSheetWindowParent();
39698:   if (!topLevelWidget) {
29018:     topLevelWidget = mainWidget;
39698:   }
29018: 
29018:   // Get the top level widget's nsGlobalWindow
73870:   nsCOMPtr<nsIDOMWindow> topLevelWindow;
29018:   if (topLevelWidget == mainWidget) {
73870:     topLevelWindow = static_cast<nsIDOMWindow*>(this);
29018:   } else {
29018:     // This is a workaround for the following problem:
29018:     // When a window with an open sheet loses focus, only the sheet window
29018:     // receives the NS_DEACTIVATE event. However, it's not the sheet that
39698:     // should lose the active styling, but the containing top level window.
29018:     void* clientData;
29018:     topLevelWidget->GetClientData(clientData); // clientData is nsXULWindow
29018:     nsISupports* data = static_cast<nsISupports*>(clientData);
29018:     nsCOMPtr<nsIInterfaceRequestor> req(do_QueryInterface(data));
29018:     topLevelWindow = do_GetInterface(req);
29018:   }
29018:   if (topLevelWindow) {
39698:     nsCOMPtr<nsPIDOMWindow> piWin(do_QueryInterface(topLevelWindow));
39698:     piWin->SetActive(aActivate);
39698:   }
39698: }
39698: 
79445: static bool
39698: NotifyDocumentTree(nsIDocument* aDocument, void* aData)
39698: {
39698:   aDocument->EnumerateSubDocuments(NotifyDocumentTree, nsnull);
39698:   aDocument->DocumentStatesChanged(NS_DOCUMENT_STATE_WINDOW_INACTIVE);
80486:   return true;
39698: }
39698: 
39698: void
79445: nsGlobalWindow::SetActive(bool aActive)
39698: {
39698:   nsPIDOMWindow::SetActive(aActive);
39698:   NotifyDocumentTree(mDoc, nsnull);
29546: }
    1: 
79445: void nsGlobalWindow::SetIsBackground(bool aIsBackground)
79445: {
79445:   bool resetTimers = (!aIsBackground && IsBackground());
72734:   nsPIDOMWindow::SetIsBackground(aIsBackground);
72734:   if (resetTimers) {
72734:     ResetTimersForNonBackgroundWindow();
72734:   }
72734: }
72734: 
48711: void nsGlobalWindow::MaybeUpdateTouchState()
48711: {
48711:   FORWARD_TO_INNER_VOID(MaybeUpdateTouchState, ());
48711: 
48711:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
48711: 
48711:   nsCOMPtr<nsIDOMWindow> focusedWindow;
48711:   fm->GetFocusedWindow(getter_AddRefs(focusedWindow));
48711: 
48711:   if(this == focusedWindow) {
48711:     UpdateTouchState();
48711:   }
48711: }
48711: 
48711: void nsGlobalWindow::UpdateTouchState()
48711: {
48711:   FORWARD_TO_INNER_VOID(UpdateTouchState, ());
48711: 
48711:   nsCOMPtr<nsIWidget> mainWidget = GetMainWidget();
48711:   if (!mainWidget)
48711:     return;
48711: 
48711:   if (mMayHaveTouchEventListener) {
48711:     mainWidget->RegisterTouchWindow();
88107: 
88107:     nsCOMPtr<nsIObserverService> observerService =
88107:       do_GetService(NS_OBSERVERSERVICE_CONTRACTID);
88107:     if (observerService) {
88107:       nsPIDOMWindow *inner = GetCurrentInnerWindowInternal();
88107:       observerService->NotifyObservers(mainWidget,
88107:                                        DOM_TOUCH_LISTENER_ADDED,
88107:                                        nsnull);
88107:     }
48711:   } else {
48711:     mainWidget->UnregisterTouchWindow();
48711:   }
48711: }
48711: 
59871: void
72018: nsGlobalWindow::EnableDeviceMotionUpdates()
72018: {
72018:   if (mHasDeviceMotion) {
72018:     nsCOMPtr<nsIDeviceMotion> ac =
72018:       do_GetService(NS_DEVICE_MOTION_CONTRACTID);
59871:     if (ac) {
59871:       ac->AddWindowListener(this);
59871:     }
59871:   }
59871: }
59871: 
59871: void
72018: nsGlobalWindow::DisableDeviceMotionUpdates()
72018: {
72018:   if (mHasDeviceMotion) {
72018:     nsCOMPtr<nsIDeviceMotion> ac =
72018:       do_GetService(NS_DEVICE_MOTION_CONTRACTID);
59871:     if (ac) {
59871:       ac->RemoveWindowListener(this);
59871:     }
59871:   }
59871: }
59871: 
16549: void
72326: nsGlobalWindow::SetChromeEventHandler(nsIDOMEventTarget* aChromeEventHandler)
16549: {
16549:   SetChromeEventHandlerInternal(aChromeEventHandler);
16549:   if (IsOuterWindow()) {
16549:     // update the chrome event handler on all our inner windows
16549:     for (nsGlobalWindow *inner = (nsGlobalWindow *)PR_LIST_HEAD(this);
16549:          inner != this;
16549:          inner = (nsGlobalWindow*)PR_NEXT_LINK(inner)) {
55731:       NS_ASSERTION(!inner->mOuterWindow || inner->mOuterWindow == this,
55731:                    "bad outer window pointer");
16549:       inner->SetChromeEventHandlerInternal(aChromeEventHandler);
16549:     }
16549:   } else if (mOuterWindow) {
16549:     // Need the cast to be able to call the protected method on a
16549:     // superclass. We could make the method public instead, but it's really
16549:     // better this way.
55729:     static_cast<nsGlobalWindow*>(mOuterWindow.get())->
16549:       SetChromeEventHandlerInternal(aChromeEventHandler);
16549:   }
16549: }
16549: 
79445: static bool IsLink(nsIContent* aContent)
43884: {
43884:   nsCOMPtr<nsIDOMHTMLAnchorElement> anchor = do_QueryInterface(aContent);
43884:   return (anchor || (aContent &&
43884:                      aContent->AttrValueIs(kNameSpaceID_XLink, nsGkAtoms::type,
43884:                                            nsGkAtoms::simple, eCaseMatters)));
43884: }
43884: 
29018: void
29018: nsGlobalWindow::SetFocusedNode(nsIContent* aNode,
29018:                                PRUint32 aFocusMethod,
79445:                                bool aNeedsFocus)
29018: {
29018:   FORWARD_TO_INNER_VOID(SetFocusedNode, (aNode, aFocusMethod, aNeedsFocus));
29018: 
29018:   NS_ASSERTION(!aNode || aNode->GetCurrentDoc() == mDoc,
29018:                "setting focus to a node from the wrong document");
29018: 
29018:   if (mFocusedNode != aNode) {
80486:     UpdateCanvasFocus(false, aNode);
29018:     mFocusedNode = aNode;
41071:     mFocusMethod = aFocusMethod & FOCUSMETHOD_MASK;
80486:     mShowFocusRingForContent = false;
41071:   }
41071: 
41071:   if (mFocusedNode) {
41071:     // if a node was focused by a keypress, turn on focus rings for the
43884:     // window.
43884:     if (mFocusMethod & nsIFocusManager::FLAG_BYKEY) {
80486:       mFocusByKeyOccurred = true;
43884:     } else if (
43884:       // otherwise, we set mShowFocusRingForContent, as we don't want this to
43884:       // be permanent for the window. On Windows, focus rings are only shown
43884:       // when the FLAG_SHOWRING flag is used. On other platforms, focus rings
43884:       // are only hidden for clicks on links.
43884: #ifndef XP_WIN
43884:       !(mFocusMethod & nsIFocusManager::FLAG_BYMOUSE) || !IsLink(aNode) ||
41071: #endif
43884:       aFocusMethod & nsIFocusManager::FLAG_SHOWRING) {
80486:         mShowFocusRingForContent = true;
41071:     }
29018:   }
29018: 
29018:   if (aNeedsFocus)
29018:     mNeedsFocus = aNeedsFocus;
29018: }
29018: 
29018: PRUint32
29018: nsGlobalWindow::GetFocusMethod()
29018: {
29018:   FORWARD_TO_INNER(GetFocusMethod, (), 0);
29018: 
29018:   return mFocusMethod;
29018: }
29018: 
79445: bool
41071: nsGlobalWindow::ShouldShowFocusRing()
41071: {
80486:   FORWARD_TO_INNER(ShouldShowFocusRing, (), false);
41071: 
42263:   return mShowFocusRings || mShowFocusRingForContent || mFocusByKeyOccurred;
41071: }
41071: 
41071: void
41071: nsGlobalWindow::SetKeyboardIndicators(UIStateChangeType aShowAccelerators,
41071:                                       UIStateChangeType aShowFocusRings)
41071: {
41071:   FORWARD_TO_INNER_VOID(SetKeyboardIndicators, (aShowAccelerators, aShowFocusRings));
41071: 
79445:   bool oldShouldShowFocusRing = ShouldShowFocusRing();
71114: 
41071:   // only change the flags that have been modified
41071:   if (aShowAccelerators != UIStateChangeType_NoChange)
41071:     mShowAccelerators = aShowAccelerators == UIStateChangeType_Set;
41071:   if (aShowFocusRings != UIStateChangeType_NoChange)
41071:     mShowFocusRings = aShowFocusRings == UIStateChangeType_Set;
41071: 
41071:   // propagate the indicators to child windows
41071:   nsCOMPtr<nsIDocShellTreeNode> node = do_QueryInterface(GetDocShell());
41071:   if (node) {
41071:     PRInt32 childCount = 0;
41071:     node->GetChildCount(&childCount);
41071: 
41071:     for (PRInt32 i = 0; i < childCount; ++i) {
41071:       nsCOMPtr<nsIDocShellTreeItem> childShell;
41071:       node->GetChildAt(i, getter_AddRefs(childShell));
41071:       nsCOMPtr<nsPIDOMWindow> childWindow = do_GetInterface(childShell);
41071:       if (childWindow) {
41071:         childWindow->SetKeyboardIndicators(aShowAccelerators, aShowFocusRings);
41071:       }
41071:     }
41071:   }
41071: 
79445:   bool newShouldShowFocusRing = ShouldShowFocusRing();
71114:   if (mHasFocus && mFocusedNode &&
71114:       oldShouldShowFocusRing != newShouldShowFocusRing &&
71114:       mFocusedNode->IsElement()) {
71114:     // Update mFocusedNode's state.
71114:     if (newShouldShowFocusRing) {
71114:       mFocusedNode->AsElement()->AddStates(NS_EVENT_STATE_FOCUSRING);
71114:     } else {
71114:       mFocusedNode->AsElement()->RemoveStates(NS_EVENT_STATE_FOCUSRING);
41071:     }
41071:   }
41071: }
41071: 
41071: void
79445: nsGlobalWindow::GetKeyboardIndicators(bool* aShowAccelerators,
79445:                                       bool* aShowFocusRings)
41071: {
41071:   FORWARD_TO_INNER_VOID(GetKeyboardIndicators, (aShowAccelerators, aShowFocusRings));
41071: 
41071:   *aShowAccelerators = mShowAccelerators;
41071:   *aShowFocusRings = mShowFocusRings;
41071: }
41071: 
79445: bool
79445: nsGlobalWindow::TakeFocus(bool aFocus, PRUint32 aFocusMethod)
29018: {
80486:   FORWARD_TO_INNER(TakeFocus, (aFocus, aFocusMethod), false);
29018: 
29018:   if (aFocus)
41071:     mFocusMethod = aFocusMethod & FOCUSMETHOD_MASK;
29018: 
29018:   if (mHasFocus != aFocus) {
29018:     mHasFocus = aFocus;
80486:     UpdateCanvasFocus(true, mFocusedNode);
29018:   }
29018: 
29018:   // if mNeedsFocus is true, then the document has not yet received a
29018:   // document-level focus event. If there is a root content node, then return
29018:   // true to tell the calling focus manager that a focus event is expected. If
29018:   // there is no root content node, the document hasn't loaded enough yet, or
29018:   // there isn't one and there is no point in firing a focus event.
41634:   if (aFocus && mNeedsFocus && mDoc && mDoc->GetRootElement() != nsnull) {
80486:     mNeedsFocus = false;
80486:     return true;
80486:   }
80486: 
80486:   mNeedsFocus = false;
80486:   return false;
29018: }
29018: 
29018: void
29018: nsGlobalWindow::SetReadyForFocus()
29018: {
29018:   FORWARD_TO_INNER_VOID(SetReadyForFocus, ());
29018: 
79445:   bool oldNeedsFocus = mNeedsFocus;
80486:   mNeedsFocus = false;
29018: 
41071:   // update whether focus rings need to be shown using the state from the
41071:   // root window
41071:   nsPIDOMWindow* root = GetPrivateRoot();
41071:   if (root) {
79445:     bool showAccelerators, showFocusRings;
41071:     root->GetKeyboardIndicators(&showAccelerators, &showFocusRings);
41071:     mShowFocusRings = showFocusRings;
41071:   }
41071: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm)
33917:     fm->WindowShown(this, oldNeedsFocus);
29018: }
29018: 
29018: void
29018: nsGlobalWindow::PageHidden()
29018: {
29018:   FORWARD_TO_INNER_VOID(PageHidden, ());
29018: 
29018:   // the window is being hidden, so tell the focus manager that the frame is
29018:   // no longer valid. Use the persisted field to determine if the document
29018:   // is being destroyed.
29018: 
29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
29018:   if (fm)
29018:     fm->WindowHidden(this);
29018: 
80486:   mNeedsFocus = true;
29018: }
29018: 
68732: class HashchangeCallback : public nsRunnable
68732: {
68729: public:
68729:   HashchangeCallback(const nsAString &aOldURL,
68729:                      const nsAString &aNewURL,
68729:                      nsGlobalWindow* aWindow)
68729:     : mWindow(aWindow)
68729:   {
68729:     mOldURL.Assign(aOldURL);
68729:     mNewURL.Assign(aNewURL);
68729:   }
68729: 
68729:   NS_IMETHOD Run()
68729:   {
68729:     NS_PRECONDITION(NS_IsMainThread(), "Should be called on the main thread.");
68729:     return mWindow->FireHashchange(mOldURL, mNewURL);
68729:   }
68729: 
68729: private:
68729:   nsString mOldURL;
68729:   nsString mNewURL;
68729:   nsRefPtr<nsGlobalWindow> mWindow;
68729: };
68729: 
29975: nsresult
68729: nsGlobalWindow::DispatchAsyncHashchange(nsIURI *aOldURI, nsIURI *aNewURI)
68729: {
68729:   FORWARD_TO_INNER(DispatchAsyncHashchange, (aOldURI, aNewURI), NS_OK);
68729: 
68729:   // Make sure that aOldURI and aNewURI are identical up to the '#', and that
68729:   // their hashes are different.
68729:   nsCAutoString oldBeforeHash, oldHash, newBeforeHash, newHash;
68729:   nsContentUtils::SplitURIAtHash(aOldURI, oldBeforeHash, oldHash);
68729:   nsContentUtils::SplitURIAtHash(aNewURI, newBeforeHash, newHash);
68729: 
68729:   NS_ENSURE_STATE(oldBeforeHash.Equals(newBeforeHash));
68729:   NS_ENSURE_STATE(!oldHash.Equals(newHash));
68729: 
68729:   nsCAutoString oldSpec, newSpec;
68729:   aOldURI->GetSpec(oldSpec);
68729:   aNewURI->GetSpec(newSpec);
68729: 
68729:   NS_ConvertUTF8toUTF16 oldWideSpec(oldSpec);
68729:   NS_ConvertUTF8toUTF16 newWideSpec(newSpec);
68729: 
68729:   nsCOMPtr<nsIRunnable> callback =
68729:     new HashchangeCallback(oldWideSpec, newWideSpec, this);
68729:   return NS_DispatchToMainThread(callback);
58340: }
58340: 
58340: nsresult
68729: nsGlobalWindow::FireHashchange(const nsAString &aOldURL,
68729:                                const nsAString &aNewURL)
58340: {
58340:   NS_ENSURE_TRUE(IsInnerWindow(), NS_ERROR_FAILURE);
29975: 
29975:   // Don't do anything if the window is frozen.
29975:   if (IsFrozen())
29975:     return NS_OK;
29975: 
68729:   // Get a presentation shell for use in creating the hashchange event.
68729:   NS_ENSURE_STATE(mDoc);
68729: 
68729:   nsIPresShell *shell = mDoc->GetShell();
68729:   nsRefPtr<nsPresContext> presContext;
68729:   if (shell) {
68729:     presContext = shell->GetPresContext();
68729:   }
68729: 
68729:   // Create a new hashchange event.
68729:   nsCOMPtr<nsIDOMEvent> domEvent;
68729:   nsresult rv =
68729:     nsEventDispatcher::CreateEvent(presContext, nsnull,
68729:                                    NS_LITERAL_STRING("hashchangeevent"),
68729:                                    getter_AddRefs(domEvent));
68729:   NS_ENSURE_SUCCESS(rv, rv);
68729: 
68729:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(domEvent);
68729:   NS_ENSURE_TRUE(privateEvent, NS_ERROR_UNEXPECTED);
68729: 
68729:   nsCOMPtr<nsIDOMHashChangeEvent> hashchangeEvent = do_QueryInterface(domEvent);
68729:   NS_ENSURE_TRUE(hashchangeEvent, NS_ERROR_UNEXPECTED);
68729: 
68729:   // The hashchange event bubbles and isn't cancellable.
68729:   rv = hashchangeEvent->InitHashChangeEvent(NS_LITERAL_STRING("hashchange"),
80486:                                             true, false,
68729:                                             aOldURL, aNewURL);
68729:   NS_ENSURE_SUCCESS(rv, rv);
68729: 
80486:   rv = privateEvent->SetTrusted(true);
68729:   NS_ENSURE_SUCCESS(rv, rv);
68729: 
79445:   bool dummy;
68729:   return DispatchEvent(hashchangeEvent, &dummy);
29975: }
29975: 
37802: nsresult
63195: nsGlobalWindow::DispatchSyncPopState()
63195: {
63195:   FORWARD_TO_INNER(DispatchSyncPopState, (), NS_OK);
37802: 
37802:   NS_ASSERTION(nsContentUtils::IsSafeToRunScript(),
37802:                "Must be safe to run script here.");
37802: 
37802:   // Check that PopState hasn't been pref'ed off.
79445:   if (!Preferences::GetBool(sPopStatePrefStr, false)) {
70840:     return NS_OK;
70840:   }
37802: 
37802:   nsresult rv = NS_OK;
37802: 
37802:   // Bail if the window is frozen.
37802:   if (IsFrozen()) {
37802:     return NS_OK;
37802:   }
37802: 
37802:   // Get the document's pending state object -- it contains the data we're
69563:   // going to send along with the popstate event.  The object is serialized
69563:   // using structured clone.
37802:   nsCOMPtr<nsIVariant> stateObj;
69563:   rv = mDoc->GetStateObject(getter_AddRefs(stateObj));
37802:   NS_ENSURE_SUCCESS(rv, rv);
37802: 
37802:   // Obtain a presentation shell for use in creating a popstate event.
46225:   nsIPresShell *shell = mDoc->GetShell();
39823:   nsRefPtr<nsPresContext> presContext;
37802:   if (shell) {
37802:     presContext = shell->GetPresContext();
37802:   }
37802: 
37802:   // Create a new popstate event
37802:   nsCOMPtr<nsIDOMEvent> domEvent;
37802:   rv = nsEventDispatcher::CreateEvent(presContext, nsnull,
37802:                                       NS_LITERAL_STRING("popstateevent"),
37802:                                       getter_AddRefs(domEvent));
37802:   NS_ENSURE_SUCCESS(rv, rv);
37802: 
37802:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(domEvent);
37802:   NS_ENSURE_TRUE(privateEvent, NS_ERROR_FAILURE);
37802: 
37802:   // Initialize the popstate event, which does bubble but isn't cancellable.
63195:   nsCOMPtr<nsIDOMPopStateEvent> popstateEvent = do_QueryInterface(domEvent);
37802:   rv = popstateEvent->InitPopStateEvent(NS_LITERAL_STRING("popstate"),
80486:                                         true, false,
63195:                                         stateObj);
37802:   NS_ENSURE_SUCCESS(rv, rv);
37802: 
80486:   rv = privateEvent->SetTrusted(true);
37802:   NS_ENSURE_SUCCESS(rv, rv);
37802: 
37802:   nsCOMPtr<nsIDOMEventTarget> outerWindow =
37802:     do_QueryInterface(GetOuterWindow());
37802:   NS_ENSURE_TRUE(outerWindow, NS_ERROR_UNEXPECTED);
37802: 
37802:   rv = privateEvent->SetTarget(outerWindow);
37802:   NS_ENSURE_SUCCESS(rv, rv);
37802: 
79445:   bool dummy; // default action
63195:   return DispatchEvent(popstateEvent, &dummy);
37802: }
37802: 
37802: // Find an nsICanvasFrame under aFrame.  Only search the principal
29018: // child lists.  aFrame must be non-null.
34149: static nsCanvasFrame* FindCanvasFrame(nsIFrame* aFrame)
34149: {
34149:     nsCanvasFrame* canvasFrame = do_QueryFrame(aFrame);
29018:     if (canvasFrame) {
29018:         return canvasFrame;
29018:     }
29018: 
77154:     nsIFrame* kid = aFrame->GetFirstPrincipalChild();
29018:     while (kid) {
29018:         canvasFrame = FindCanvasFrame(kid);
29018:         if (canvasFrame) {
29018:             return canvasFrame;
29018:         }
29018:         kid = kid->GetNextSibling();
29018:     }
29018: 
29018:     return nsnull;
29018: }
29018: 
29018: //-------------------------------------------------------
29018: // Tells the HTMLFrame/CanvasFrame that is now has focus
29018: void
79445: nsGlobalWindow::UpdateCanvasFocus(bool aFocusChanged, nsIContent* aNewContent)
29018: {
29018:   // this is called from the inner window so use GetDocShell
29018:   nsIDocShell* docShell = GetDocShell();
29018:   if (!docShell)
29018:     return;
29018: 
29018:   nsCOMPtr<nsIEditorDocShell> editorDocShell = do_QueryInterface(docShell);
29018:   if (editorDocShell) {
79445:     bool editable;
29018:     editorDocShell->GetEditable(&editable);
29018:     if (editable)
29018:       return;
29018:   }
29018: 
29018:   nsCOMPtr<nsIPresShell> presShell;
29018:   docShell->GetPresShell(getter_AddRefs(presShell));
29018:   if (!presShell || !mDocument)
29018:     return;
29018: 
29018:   nsCOMPtr<nsIDocument> doc(do_QueryInterface(mDocument));
41634:   Element *rootElement = doc->GetRootElement();
41634:   if (rootElement) {
29018:       if ((mHasFocus || aFocusChanged) &&
41634:           (mFocusedNode == rootElement || aNewContent == rootElement)) {
41634:           nsIFrame* frame = rootElement->GetPrimaryFrame();
29018:           if (frame) {
29018:               frame = frame->GetParent();
34149:               nsCanvasFrame* canvasFrame = do_QueryFrame(frame);
29018:               if (canvasFrame) {
41634:                   canvasFrame->SetHasFocus(mHasFocus && rootElement == aNewContent);
29018:               }
29018:           }
29018:       }
29018:   } else {
29018:       // Look for the frame the hard way
29018:       nsIFrame* frame = presShell->GetRootFrame();
29018:       if (frame) {
34149:           nsCanvasFrame* canvasFrame = FindCanvasFrame(frame);
29018:           if (canvasFrame) {
80486:               canvasFrame->SetHasFocus(false);
29018:           }
29018:       }      
29018:   }
29018: }
29018: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetComputedStyle(nsIDOMElement* aElt,
    1:                                  const nsAString& aPseudoElt,
    1:                                  nsIDOMCSSStyleDeclaration** aReturn)
    1: {
    1:   FORWARD_TO_OUTER(GetComputedStyle, (aElt, aPseudoElt, aReturn),
    1:                    NS_ERROR_NOT_INITIALIZED);
36884: 
36884:   NS_ENSURE_ARG_POINTER(aReturn);
36884:   *aReturn = nsnull;
36884: 
36884:   if (!aElt) {
36884:     return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
36884:   }
36884: 
36884:   if (!mDocShell) {
36884:     return NS_OK;
36884:   }
36884: 
36884:   nsCOMPtr<nsIPresShell> presShell;
36884:   mDocShell->GetPresShell(getter_AddRefs(presShell));
36884: 
36884:   if (!presShell) {
36884:     return NS_OK;
36884:   }
36884: 
30385:   nsRefPtr<nsComputedDOMStyle> compStyle;
36884:   nsresult rv = NS_NewComputedDOMStyle(aElt, aPseudoElt, presShell,
36884:                                        getter_AddRefs(compStyle));
    1:   NS_ENSURE_SUCCESS(rv, rv);
30385: 
30385:   *aReturn = compStyle.forget().get();
30385: 
30385:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetSessionStorage(nsIDOMStorage ** aSessionStorage)
    1: {
    1:   FORWARD_TO_INNER(GetSessionStorage, (aSessionStorage), NS_ERROR_UNEXPECTED);
    1: 
    1:   nsIPrincipal *principal = GetPrincipal();
28676:   nsIDocShell* docShell = GetDocShell();
    1: 
    1:   if (!principal || !docShell) {
55110:     *aSessionStorage = nsnull;
55110:     return NS_OK;
55110:   }
55110: 
70840:   if (!Preferences::GetBool(kStorageEnabled)) {
55110:     *aSessionStorage = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
37608:   if (mSessionStorage) {
37608: #ifdef PR_LOGGING
37608:     if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
37608:       PR_LogPrint("nsGlobalWindow %p has %p sessionStorage", this, mSessionStorage.get());
37608:     }
37608: #endif
37608:     nsCOMPtr<nsPIDOMStorage> piStorage = do_QueryInterface(mSessionStorage);
37608:     if (piStorage) {
79445:       bool canAccess = piStorage->CanAccess(principal);
37608:       NS_ASSERTION(canAccess,
37608:                    "window %x owned sessionStorage "
37608:                    "that could not be accessed!");
37608:       if (!canAccess) {
37608:           mSessionStorage = nsnull;
37608:       }
37608:     }
37608:   }
37608: 
37608:   if (!mSessionStorage) {
37608:     *aSessionStorage = nsnull;
37608: 
37608:     nsString documentURI;
68775:     if (mDocument) {
64020:       mDocument->GetDocumentURI(documentURI);
68775:     }
37608: 
23579:     nsresult rv = docShell->GetSessionStorageForPrincipal(principal,
37608:                                                           documentURI,
80486:                                                           true,
37608:                                                           getter_AddRefs(mSessionStorage));
23579:     NS_ENSURE_SUCCESS(rv, rv);
23579: 
37608: #ifdef PR_LOGGING
37608:     if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
37608:       PR_LogPrint("nsGlobalWindow %p tried to get a new sessionStorage %p", this, mSessionStorage.get());
37608:     }
37608: #endif
37608: 
37608:     if (!mSessionStorage) {
23579:       return NS_ERROR_DOM_NOT_SUPPORTED_ERR;
23579:     }
37608:   }
37608: 
37608: #ifdef PR_LOGGING
37608:     if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
37608:       PR_LogPrint("nsGlobalWindow %p returns %p sessionStorage", this, mSessionStorage.get());
37608:     }
37608: #endif
37608: 
37608:   NS_ADDREF(*aSessionStorage = mSessionStorage);
23579:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetGlobalStorage(nsIDOMStorageList ** aGlobalStorage)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aGlobalStorage);
    1: 
79009:   nsCOMPtr<nsIDocument> document = do_QueryInterface(GetExtantDocument());
79009:   if (document) {
79009:     document->WarnOnceAbout(nsIDocument::eGlobalStorage);
79009:   }
79009: 
70840:   if (!Preferences::GetBool(kStorageEnabled)) {
55110:     *aGlobalStorage = nsnull;
55110:     return NS_OK;
55110:   }
55110: 
22689:   if (!sGlobalStorageList) {
22689:     nsresult rv = NS_NewDOMStorageList(&sGlobalStorageList);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
22689:   *aGlobalStorage = sGlobalStorageList;
    1:   NS_IF_ADDREF(*aGlobalStorage);
    1: 
    1:   return NS_OK;
    1: }
    1: 
26323: NS_IMETHODIMP
28438: nsGlobalWindow::GetLocalStorage(nsIDOMStorage ** aLocalStorage)
26323: {
26323:   FORWARD_TO_INNER(GetLocalStorage, (aLocalStorage), NS_ERROR_UNEXPECTED);
26323: 
26323:   NS_ENSURE_ARG(aLocalStorage);
26323: 
70840:   if (!Preferences::GetBool(kStorageEnabled)) {
55110:     *aLocalStorage = nsnull;
55110:     return NS_OK;
55110:   }
55110: 
26323:   if (!mLocalStorage) {
26323:     *aLocalStorage = nsnull;
26323: 
26323:     nsresult rv;
26323: 
79445:     bool unused;
28495:     if (!nsDOMStorage::CanUseStorage(&unused))
28495:       return NS_ERROR_DOM_SECURITY_ERR;
28495: 
26323:     nsIPrincipal *principal = GetPrincipal();
26323:     if (!principal)
26323:       return NS_OK;
26323: 
26323:     nsCOMPtr<nsIDOMStorageManager> storageManager =
26323:       do_GetService("@mozilla.org/dom/storagemanager;1", &rv);
26323:     NS_ENSURE_SUCCESS(rv, rv);
26323: 
37608:     nsString documentURI;
68775:     if (mDocument) {
64020:       mDocument->GetDocumentURI(documentURI);
68775:     }
37608: 
37608:     rv = storageManager->GetLocalStorageForPrincipal(principal,
37608:                                                      documentURI,
37608:                                                      getter_AddRefs(mLocalStorage));
26323:     NS_ENSURE_SUCCESS(rv, rv);
26323:   }
26323: 
26323:   NS_ADDREF(*aLocalStorage = mLocalStorage);
26323:   return NS_OK;
26323: }
26323: 
60385: //*****************************************************************************
60385: // nsGlobalWindow::nsIDOMStorageIndexedDB
60385: //*****************************************************************************
60385: 
44204: NS_IMETHODIMP
59794: nsGlobalWindow::GetMozIndexedDB(nsIIDBFactory** _retval)
44204: {
44204:   if (!mIndexedDB) {
76987:     if (!IsChromeWindow()) {
61353:       nsCOMPtr<mozIThirdPartyUtil> thirdPartyUtil =
61353:         do_GetService(THIRDPARTYUTIL_CONTRACTID);
61353:       NS_ENSURE_TRUE(thirdPartyUtil, NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR);
61353: 
79445:       bool isThirdParty;
61353:       nsresult rv = thirdPartyUtil->IsThirdPartyWindow(this, nsnull,
61353:                                                        &isThirdParty);
61353:       NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR);
61353: 
61353:       if (isThirdParty) {
61353:         NS_WARNING("IndexedDB is not permitted in a third-party window.");
61353:         *_retval = nsnull;
61353:         return NS_OK;
61353:       }
76987:     }
61353: 
61353:     mIndexedDB = indexedDB::IDBFactory::Create(this);
61353:     NS_ENSURE_TRUE(mIndexedDB, NS_ERROR_DOM_INDEXEDDB_UNKNOWN_ERR);
44204:   }
44204: 
46347:   nsCOMPtr<nsIIDBFactory> request(mIndexedDB);
44204:   request.forget(_retval);
44204:   return NS_OK;
44204: }
44204: 
    1: //*****************************************************************************
    1: // nsGlobalWindow::nsIInterfaceRequestor
    1: //*****************************************************************************
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalWindow::GetInterface(const nsIID & aIID, void **aSink)
    1: {
    1:   NS_ENSURE_ARG_POINTER(aSink);
    1:   *aSink = nsnull;
    1: 
    1:   if (aIID.Equals(NS_GET_IID(nsIDocCharset))) {
    1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     if (mDocShell) {
    1:       nsCOMPtr<nsIDocCharset> docCharset(do_QueryInterface(mDocShell));
    1:       if (docCharset) {
88006:         NS_WARNING("Using deprecated nsIDocCharset: use nsIDocShell.GetCharset() instead ");
    1:         *aSink = docCharset;
    1:         NS_ADDREF(((nsISupports *) *aSink));
    1:       }
    1:     }
    1:   }
    1:   else if (aIID.Equals(NS_GET_IID(nsIWebNavigation))) {
    1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     if (mDocShell) {
    1:       nsCOMPtr<nsIWebNavigation> webNav(do_QueryInterface(mDocShell));
    1:       if (webNav) {
    1:         *aSink = webNav;
    1:         NS_ADDREF(((nsISupports *) *aSink));
    1:       }
    1:     }
    1:   }
    1: #ifdef NS_PRINTING
    1:   else if (aIID.Equals(NS_GET_IID(nsIWebBrowserPrint))) {
    1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     if (mDocShell) {
    1:       nsCOMPtr<nsIContentViewer> viewer;
    1:       mDocShell->GetContentViewer(getter_AddRefs(viewer));
    1:       if (viewer) {
    1:         nsCOMPtr<nsIWebBrowserPrint> webBrowserPrint(do_QueryInterface(viewer));
    1:         if (webBrowserPrint) {
    1:           *aSink = webBrowserPrint;
    1:           NS_ADDREF(((nsISupports *) *aSink));
    1:         }
    1:       }
    1:     }
    1:   }
    1: #endif
63880:   else if (aIID.Equals(NS_GET_IID(nsIDOMWindowUtils))) {
    1:     FORWARD_TO_OUTER(GetInterface, (aIID, aSink), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:     nsCOMPtr<nsISupports> utils(do_QueryReferent(mWindowUtils));
    1:     if (utils) {
    1:       *aSink = utils;
    1:       NS_ADDREF(((nsISupports *) *aSink));
    1:     } else {
    1:       nsDOMWindowUtils *utilObj = new nsDOMWindowUtils(this);
    1:       nsCOMPtr<nsISupports> utilsIfc =
    1:                               NS_ISUPPORTS_CAST(nsIDOMWindowUtils *, utilObj);
    1:       if (utilsIfc) {
    1:         mWindowUtils = do_GetWeakReference(utilsIfc);
    1:         *aSink = utilsIfc;
    1:         NS_ADDREF(((nsISupports *) *aSink));
    1:       }
    1:     }
    1:   }
    1:   else {
    1:     return QueryInterface(aIID, aSink);
    1:   }
    1: 
    1:   return *aSink ? NS_OK : NS_ERROR_NO_INTERFACE;
    1: }
    1: 
    1: void
    1: nsGlobalWindow::FireOfflineStatusEvent()
    1: {
    1:   if (!mDoc)
    1:     return;
    1:   nsAutoString name;
    1:   if (NS_IsOffline()) {
    1:     name.AssignLiteral("offline");
    1:   } else {
    1:     name.AssignLiteral("online");
    1:   }
    1:   // The event is fired at the body element, or if there is no body element,
    1:   // at the document.
    1:   nsCOMPtr<nsISupports> eventTarget = mDoc.get();
    1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDoc = do_QueryInterface(mDoc);
    1:   if (htmlDoc) {
    1:     nsCOMPtr<nsIDOMHTMLElement> body;
    1:     htmlDoc->GetBody(getter_AddRefs(body));
    1:     if (body) {
    1:       eventTarget = body;
    1:     }
    1:   }
    1:   else {
    1:     nsCOMPtr<nsIDOMElement> documentElement;
    1:     mDocument->GetDocumentElement(getter_AddRefs(documentElement));
    1:     if(documentElement) {        
    1:       eventTarget = documentElement;
    1:     }
    1:   }
80486:   nsContentUtils::DispatchTrustedEvent(mDoc, eventTarget, name, true, false);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::Observe(nsISupports* aSubject, const char* aTopic,
    1:                         const PRUnichar* aData)
    1: {
    1:   if (!nsCRT::strcmp(aTopic, NS_IOSERVICE_OFFLINE_STATUS_TOPIC)) {
    1:     if (IsFrozen()) {
    1:       // if an even number of notifications arrive while we're frozen,
    1:       // we don't need to fire.
    1:       mFireOfflineStatusChangeEventOnThaw = !mFireOfflineStatusChangeEventOnThaw;
    1:     } else {
    1:       FireOfflineStatusEvent();
    1:     }
    1:     return NS_OK;
    1:   }
    1: 
    1:   if (IsInnerWindow() && !nsCRT::strcmp(aTopic, "dom-storage-changed")) {
    1:     nsIPrincipal *principal;
    1:     nsresult rv;
    1: 
23579:     principal = GetPrincipal();
37608:     if (principal) {
    1:       // A global storage object changed, check to see if it's one
    1:       // this window can access.
    1: 
    1:       nsCOMPtr<nsIURI> codebase;
    1:       principal->GetURI(getter_AddRefs(codebase));
    1: 
    1:       if (!codebase) {
    1:         return NS_OK;
    1:       }
    1: 
    1:       nsCAutoString currentDomain;
    1:       rv = codebase->GetAsciiHost(currentDomain);
    1:       if (NS_FAILED(rv)) {
    1:         return NS_OK;
    1:       }
    1: 
26323:       if (!nsDOMStorageList::CanAccessDomain(NS_ConvertUTF16toUTF8(aData),
26323:                                              currentDomain)) {
    1:         // This window can't reach the global storage object for the
    1:         // domain for which the change happened, so don't fire any
    1:         // events in this window.
    1: 
    1:         return NS_OK;
    1:       }
    1:     }
    1: 
    1:     nsAutoString domain(aData);
    1: 
    1:     if (IsFrozen()) {
    1:       // This window is frozen, rather than firing the events here,
    1:       // store the domain in which the change happened and fire the
    1:       // events if we're ever thawed.
    1: 
37608:       if (!mPendingStorageEventsObsolete) {
79445:         mPendingStorageEventsObsolete = new nsDataHashtable<nsStringHashKey, bool>;
37608:         NS_ENSURE_TRUE(mPendingStorageEventsObsolete, NS_ERROR_OUT_OF_MEMORY);
37608: 
37608:         rv = mPendingStorageEventsObsolete->Init();
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1: 
80486:       mPendingStorageEventsObsolete->Put(domain, true);
37608: 
37608:       return NS_OK;
37608:     }
37608: 
37608:     nsRefPtr<nsDOMStorageEventObsolete> event = new nsDOMStorageEventObsolete();
    1:     NS_ENSURE_TRUE(event, NS_ERROR_OUT_OF_MEMORY);
    1: 
80486:     rv = event->InitStorageEvent(NS_LITERAL_STRING("storage"), false, false, domain);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(mDocument));
    1: 
    1:     nsCOMPtr<nsIDOMEventTarget> target;
    1: 
    1:     if (htmlDoc) {
    1:       nsCOMPtr<nsIDOMHTMLElement> body;
    1:       htmlDoc->GetBody(getter_AddRefs(body));
    1: 
    1:       target = do_QueryInterface(body);
    1:     }
    1: 
    1:     if (!target) {
    1:       target = this;
    1:     }
    1: 
79445:     bool defaultActionEnabled;
37608:     target->DispatchEvent((nsIDOMStorageEventObsolete *)event, &defaultActionEnabled);
37608: 
37608:     return NS_OK;
37608:   }
37608: 
37608:   if (IsInnerWindow() && !nsCRT::strcmp(aTopic, "dom-storage2-changed")) {
37608:     nsIPrincipal *principal;
37608:     nsresult rv;
37608: 
37608:     nsCOMPtr<nsIDOMStorageEvent> event = do_QueryInterface(aSubject, &rv);
37608:     NS_ENSURE_SUCCESS(rv, rv);
37608: 
37608:     nsCOMPtr<nsIDOMStorage> changingStorage;
37608:     rv = event->GetStorageArea(getter_AddRefs(changingStorage));
37608:     NS_ENSURE_SUCCESS(rv, rv);
37608: 
37608:     nsCOMPtr<nsPIDOMStorage> pistorage = do_QueryInterface(changingStorage);
37608:     nsPIDOMStorage::nsDOMStorageType storageType = pistorage->StorageType();
37608: 
37608:     principal = GetPrincipal();
37608:     switch (storageType)
37608:     {
37608:     case nsPIDOMStorage::SessionStorage:
37608:     {
37608:       if (SameCOMIdentity(mSessionStorage, changingStorage)) {
37608:         // Do not fire any events for the same storage object, it's not shared
37608:         // among windows, see nsGlobalWindow::GetSessionStoarge()
37608:         return NS_OK;
37608:       }
37608: 
37608:       nsCOMPtr<nsIDOMStorage> storage = mSessionStorage;
37608:       if (!storage) {
37608:         nsIDocShell* docShell = GetDocShell();
37608:         if (principal && docShell) {
37608:           // No need to pass documentURI here, it's only needed when we want
80486:           // to create a new storage, the third paramater would be true
37608:           docShell->GetSessionStorageForPrincipal(principal,
37608:                                                   EmptyString(),
80486:                                                   false,
37608:                                                   getter_AddRefs(storage));
37608:         }
37608:       }
37608: 
37608:       if (!pistorage->IsForkOf(storage)) {
37608:         // This storage event is coming from a different doc shell,
37608:         // i.e. it is a clone, ignore this event.
37608:         return NS_OK;
37608:       }
37608: 
37608: #ifdef PR_LOGGING
37608:       if (PR_LOG_TEST(gDOMLeakPRLog, PR_LOG_DEBUG)) {
37608:         PR_LogPrint("nsGlobalWindow %p with sessionStorage %p passing event from %p", this, mSessionStorage.get(), pistorage.get());
37608:       }
37608: #endif
37608: 
37608:       break;
37608:     }
37608:     case nsPIDOMStorage::LocalStorage:
37608:     {
37608:       if (SameCOMIdentity(mLocalStorage, changingStorage)) {
37608:         // Do not fire any events for the same storage object, it's not shared
37608:         // among windows, see nsGlobalWindow::GetLocalStoarge()
37608:         return NS_OK;
37608:       }
37608: 
37608:       // Allow event fire only for the same principal storages
37608:       // XXX We have to use EqualsIgnoreDomain after bug 495337 lands
37608:       nsIPrincipal *storagePrincipal = pistorage->Principal();
79445:       bool equals;
37608: 
37608:       rv = storagePrincipal->Equals(principal, &equals);
37608:       NS_ENSURE_SUCCESS(rv, rv);
37608: 
37608:       if (!equals)
37608:         return NS_OK;
37608: 
37608:       break;
37608:     }
37608:     default:
37608:       return NS_OK;
37608:     }
37608: 
37608:     if (IsFrozen()) {
37608:       // This window is frozen, rather than firing the events here,
37608:       // store the domain in which the change happened and fire the
37608:       // events if we're ever thawed.
37608: 
60680:       mPendingStorageEvents.AppendObject(event);
37608:       return NS_OK;
37608:     }
37608: 
79445:     bool defaultActionEnabled;
37608:     DispatchEvent((nsIDOMStorageEvent *)event, &defaultActionEnabled);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
56242:   if (!nsCRT::strcmp(aTopic, "offline-cache-update-added")) {
56242:     if (mApplicationCache)
56242:       return NS_OK;
56242: 
56242:     // Instantiate the application object now. It observes update belonging to
56242:     // this window's document and correctly updates the applicationCache object
56242:     // state.
56242:     nsCOMPtr<nsIDOMOfflineResourceList> applicationCache;
56242:     GetApplicationCache(getter_AddRefs(applicationCache));
56242:     nsCOMPtr<nsIObserver> observer = do_QueryInterface(applicationCache);
56242:     if (observer)
56242:       observer->Observe(aSubject, aTopic, aData);
56242: 
56242:     return NS_OK;
56242:   }
56242: 
    1:   NS_WARNING("unrecognized topic in nsGlobalWindow::Observe");
    1:   return NS_ERROR_FAILURE;
    1: }
    1: 
20261: static PLDHashOperator
79445: FirePendingStorageEvents(const nsAString& aKey, bool aData, void *userArg)
    1: {
 3233:   nsGlobalWindow *win = static_cast<nsGlobalWindow *>(userArg);
    1: 
    1:   nsCOMPtr<nsIDOMStorage> storage;
    1:   win->GetSessionStorage(getter_AddRefs(storage));
    1: 
    1:   if (storage) {
    1:     win->Observe(storage, "dom-storage-changed",
    1:                  aKey.IsEmpty() ? nsnull : PromiseFlatString(aKey).get());
    1:   }
    1: 
    1:   return PL_DHASH_NEXT;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::FireDelayedDOMEvents()
    1: {
    1:   FORWARD_TO_INNER(FireDelayedDOMEvents, (), NS_ERROR_UNEXPECTED);
    1: 
61946:   for (PRInt32 i = 0; i < mPendingStorageEvents.Count(); ++i) {
37608:     Observe(mPendingStorageEvents[i], "dom-storage2-changed", nsnull);
37608:   }
37608: 
37608:   if (mPendingStorageEventsObsolete) {
    1:     // Fire pending storage events.
37608:     mPendingStorageEventsObsolete->EnumerateRead(FirePendingStorageEvents, this);
37608:     mPendingStorageEventsObsolete = nsnull;
    1:   }
    1: 
10340:   if (mApplicationCache) {
10340:     static_cast<nsDOMOfflineResourceList*>(mApplicationCache.get())->FirePendingEvents();
10340:   }
10340: 
    1:   if (mFireOfflineStatusChangeEventOnThaw) {
80486:     mFireOfflineStatusChangeEventOnThaw = false;
    1:     FireOfflineStatusEvent();
    1:   }
    1: 
    1:   nsCOMPtr<nsIDocShellTreeNode> node =
    1:     do_QueryInterface(GetDocShell());
    1:   if (node) {
    1:     PRInt32 childCount = 0;
    1:     node->GetChildCount(&childCount);
    1: 
    1:     for (PRInt32 i = 0; i < childCount; ++i) {
    1:       nsCOMPtr<nsIDocShellTreeItem> childShell;
    1:       node->GetChildAt(i, getter_AddRefs(childShell));
    1:       NS_ASSERTION(childShell, "null child shell");
    1: 
    1:       nsCOMPtr<nsPIDOMWindow> pWin = do_GetInterface(childShell);
    1:       if (pWin) {
    1:         nsGlobalWindow *win =
 3233:           static_cast<nsGlobalWindow*>
 3233:                      (static_cast<nsPIDOMWindow*>(pWin));
    1:         win->FireDelayedDOMEvents();
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow: Window Control Functions
    1: //*****************************************************************************
    1: 
73870: nsIDOMWindow *
    1: nsGlobalWindow::GetParentInternal()
    1: {
    1:   FORWARD_TO_OUTER(GetParentInternal, (), nsnull);
    1: 
    1:   nsCOMPtr<nsIDOMWindow> parent;
    1:   GetParent(getter_AddRefs(parent));
    1: 
 3233:   if (parent && parent != static_cast<nsIDOMWindow *>(this)) {
73870:     return parent;
73870:   }
73870: 
73870:   return NULL;
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::CloseBlockScriptTerminationFunc(nsISupports *aRef)
    1: {
 3233:   nsGlobalWindow* pwin = static_cast<nsGlobalWindow*>
 3233:                                     (static_cast<nsPIDOMWindow*>(aRef));
80486:   pwin->mBlockScriptedClosingFlag = false;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::OpenInternal(const nsAString& aUrl, const nsAString& aName,
79445:                              const nsAString& aOptions, bool aDialog,
79445:                              bool aContentModal, bool aCalledNoScript,
79445:                              bool aDoJSFixups, nsIArray *argv,
    1:                              nsISupports *aExtraArgument,
    1:                              nsIPrincipal *aCalleePrincipal,
    1:                              JSContext *aJSCallerContext,
    1:                              nsIDOMWindow **aReturn)
    1: {
    1:   FORWARD_TO_OUTER(OpenInternal, (aUrl, aName, aOptions, aDialog,
 5814:                                   aContentModal, aCalledNoScript, aDoJSFixups,
    1:                                   argv, aExtraArgument, aCalleePrincipal,
    1:                                   aJSCallerContext, aReturn),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
    1: #ifdef NS_DEBUG
    1:   PRUint32 argc = 0;
    1:   if (argv)
    1:       argv->GetLength(&argc);
    1: #endif
    1:   NS_PRECONDITION(!aExtraArgument || (!argv && argc == 0),
    1:                   "Can't pass in arguments both ways");
    1:   NS_PRECONDITION(!aCalledNoScript || (!argv && argc == 0),
    1:                   "Can't pass JS args when called via the noscript methods");
    1:   NS_PRECONDITION(!aJSCallerContext || !aCalledNoScript,
    1:                   "Shouldn't have caller context when called noscript");
    1: 
    1:   *aReturn = nsnull;
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> chrome;
    1:   GetWebBrowserChrome(getter_AddRefs(chrome));
    1:   if (!chrome) {
    1:     // No chrome means we don't want to go through with this open call
    1:     // -- see nsIWindowWatcher.idl
    1:     return NS_ERROR_NOT_AVAILABLE;
    1:   }
    1: 
    1:   NS_ASSERTION(mDocShell, "Must have docshell here");
    1: 
79445:   const bool checkForPopup = !nsContentUtils::IsCallerChrome() &&
    1:     !aDialog && !WindowExists(aName, !aCalledNoScript);
    1: 
    1:   // Note: it's very important that this be an nsXPIDLCString, since we want
    1:   // .get() on it to return nsnull until we write stuff to it.  The window
    1:   // watcher expects a null URL string if there is no URL to load.
    1:   nsXPIDLCString url;
    1:   nsresult rv = NS_OK;
    1: 
    1:   // It's important to do this security check before determining whether this
    1:   // window opening should be blocked, to ensure that we don't FireAbuseEvents
    1:   // for a window opening that wouldn't have succeeded in the first place.
    1:   if (!aUrl.IsEmpty()) {
    1:     AppendUTF16toUTF8(aUrl, url);
    1: 
    1:     /* Check whether the URI is allowed, but not for dialogs --
    1:        see bug 56851. The security of this function depends on
    1:        window.openDialog being inaccessible from web scripts */
    1:     if (url.get() && !aDialog)
    1:       rv = SecurityCheckURL(url.get());
    1:   }
    1: 
    1:   if (NS_FAILED(rv))
    1:     return rv;
    1: 
34524:   PopupControlState abuseLevel = gPopupControlState;
    1:   if (checkForPopup) {
34524:     abuseLevel = RevisePopupAbuseLevel(abuseLevel);
34524:     if (abuseLevel >= openAbused) {
    1:       if (aJSCallerContext) {
    1:         // If script in some other window is doing a window.open on us and
    1:         // it's being blocked, then it's OK to close us afterwards, probably.
    1:         // But if we're doing a window.open on ourselves and block the popup,
    1:         // prevent this window from closing until after this script terminates
    1:         // so that whatever popup blocker UI the app has will be visible.
    1:         if (mContext == GetScriptContextFromJSContext(aJSCallerContext)) {
80486:           mBlockScriptedClosingFlag = true;
    1:           mContext->SetTerminationFunction(CloseBlockScriptTerminationFunc,
 3233:                                            static_cast<nsPIDOMWindow*>
 3233:                                                       (this));
    1:         }
    1:       }
    1: 
80486:       FireAbuseEvents(true, false, aUrl, aName, aOptions);
    1:       return aDoJSFixups ? NS_OK : NS_ERROR_FAILURE;
    1:     }
    1:   }    
    1: 
    1:   nsCOMPtr<nsIDOMWindow> domReturn;
    1: 
    1:   nsCOMPtr<nsIWindowWatcher> wwatch =
    1:     do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
    1:   NS_ENSURE_TRUE(wwatch, rv);
    1: 
    1:   NS_ConvertUTF16toUTF8 options(aOptions);
    1:   NS_ConvertUTF16toUTF8 name(aName);
    1: 
    1:   const char *options_ptr = aOptions.IsEmpty() ? nsnull : options.get();
    1:   const char *name_ptr = aName.IsEmpty() ? nsnull : name.get();
    1: 
    1:   {
    1:     // Reset popup state while opening a window to prevent the
    1:     // current state from being active the whole time a modal
    1:     // dialog is open.
80486:     nsAutoPopupStatePusher popupStatePusher(openAbused, true);
    1: 
    1:     if (!aCalledNoScript) {
    1:       nsCOMPtr<nsPIWindowWatcher> pwwatch(do_QueryInterface(wwatch));
    1:       NS_ASSERTION(pwwatch,
    1:                    "Unable to open windows from JS because window watcher "
    1:                    "is broken");
    1:       NS_ENSURE_TRUE(pwwatch, NS_ERROR_UNEXPECTED);
    1:         
    1:       rv = pwwatch->OpenWindowJS(this, url.get(), name_ptr, options_ptr,
    1:                                  aDialog, argv,
    1:                                  getter_AddRefs(domReturn));
    1:     } else {
    1:       // Push a null JSContext here so that the window watcher won't screw us
    1:       // up.  We do NOT want this case looking at the JS context on the stack
    1:       // when searching.  Compare comments on
73870:       // nsIDOMWindow::OpenWindow and nsIWindowWatcher::OpenWindow.
 5814:       nsCOMPtr<nsIJSContextStack> stack;
 5814: 
 5814:       if (!aContentModal) {
 5814:         stack = do_GetService(sJSStackContractID);
 5814:       }
    1: 
    1:       if (stack) {
    1:         rv = stack->Push(nsnull);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1:         
    1:       rv = wwatch->OpenWindow(this, url.get(), name_ptr, options_ptr,
    1:                               aExtraArgument, getter_AddRefs(domReturn));
    1: 
    1:       if (stack) {
    1:         JSContext* cx;
    1:         stack->Pop(&cx);
    1:         NS_ASSERTION(!cx, "Unexpected JSContext popped!");
    1:       }
    1:     }
    1:   }
    1: 
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   // success!
    1: 
    1:   domReturn.swap(*aReturn);
    1: 
    1:   if (aDoJSFixups) {      
    1:     nsCOMPtr<nsIDOMChromeWindow> chrome_win(do_QueryInterface(*aReturn));
    1:     if (!chrome_win) {
    1:       // A new non-chrome window was created from a call to
    1:       // window.open() from JavaScript, make sure there's a document in
    1:       // the new window. We do this by simply asking the new window for
    1:       // its document, this will synchronously create an empty document
    1:       // if there is no document in the window.
    1:       // XXXbz should this just use EnsureInnerWindow()?
    1: #ifdef DEBUG_jst
    1:       {
    1:         nsCOMPtr<nsPIDOMWindow> pidomwin(do_QueryInterface(*aReturn));
    1: 
    1:         nsIDOMDocument *temp = pidomwin->GetExtantDocument();
    1: 
    1:         NS_ASSERTION(temp, "No document in new window!!!");
    1:       }
    1: #endif
    1: 
    1:       nsCOMPtr<nsIDOMDocument> doc;
    1:       (*aReturn)->GetDocument(getter_AddRefs(doc));
    1:     }
    1:   }
    1:     
    1:   if (checkForPopup) {
    1:     if (abuseLevel >= openControlled) {
 3233:       nsGlobalWindow *opened = static_cast<nsGlobalWindow *>(*aReturn);
    1:       if (!opened->IsPopupSpamWindow()) {
80486:         opened->SetPopupSpamWindow(true);
    1:         ++gOpenPopupSpamCount;
    1:       }
    1:     }
    1:     if (abuseLevel >= openAbused)
80486:       FireAbuseEvents(false, true, aUrl, aName, aOptions);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::CloseWindow(nsISupports *aWindow)
    1: {
    1:   nsCOMPtr<nsPIDOMWindow> win(do_QueryInterface(aWindow));
    1: 
    1:   nsGlobalWindow* globalWin =
 3233:     static_cast<nsGlobalWindow *>
 3233:                (static_cast<nsPIDOMWindow*>(win));
    1: 
    1:   // Need to post an event for closing, otherwise window and 
    1:   // presshell etc. may get destroyed while creating frames, bug 338897.
39378:   nsCloseEvent::PostCloseEvent(globalWin);
38439:   // else if OOM, better not to close. That might cause a crash.
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::ClearWindowScope(nsISupports *aWindow)
    1: {
    1:   nsCOMPtr<nsIScriptGlobalObject> sgo(do_QueryInterface(aWindow));
47539:   nsIScriptContext *scx = sgo->GetContext();
    1:   if (scx) {
80486:     scx->ClearScope(sgo->GetGlobalJSObject(), true);
    1:   }
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow: Timeout Functions
    1: //*****************************************************************************
    1: 
34729: PRUint32 sNestingLevel;
34729: 
    1: nsresult
    1: nsGlobalWindow::SetTimeoutOrInterval(nsIScriptTimeoutHandler *aHandler,
    1:                                      PRInt32 interval,
79445:                                      bool aIsInterval, PRInt32 *aReturn)
    1: {
    1:   FORWARD_TO_INNER(SetTimeoutOrInterval, (aHandler, interval, aIsInterval, aReturn),
    1:                    NS_ERROR_NOT_INITIALIZED);
    1: 
 3181:   // If we don't have a document (we could have been unloaded since
 3181:   // the call to setTimeout was made), do nothing.
 3181:   if (!mDocument) {
 3181:     return NS_OK;
 3181:   }
 3181: 
64670:   // Disallow negative intervals.  If aIsInterval also disallow 0,
64670:   // because we use that as a "don't repeat" flag.
64670:   interval = NS_MAX(aIsInterval ? 1 : 0, interval);
64670: 
64670:   // Make sure we don't proceed with an interval larger than our timer
68864:   // code can handle. (Note: we already forced |interval| to be non-negative,
68864:   // so the PRUint32 cast (to avoid compiler warnings) is ok.)
68864:   PRUint32 maxTimeoutMs = PR_IntervalToMilliseconds(DOM_MAX_TIMEOUT_VALUE);
68864:   if (static_cast<PRUint32>(interval) > maxTimeoutMs) {
68864:     interval = maxTimeoutMs;
64670:   }
64670: 
71999:   nsRefPtr<nsTimeout> timeout = new nsTimeout();
72734:   timeout->mIsInterval = aIsInterval;
64670:   timeout->mInterval = interval;
64670:   timeout->mScriptHandler = aHandler;
64670: 
64670:   // Now clamp the actual interval we will use for the timer based on
34729:   PRUint32 nestingLevel = sNestingLevel + 1;
64670:   PRInt32 realInterval = interval;
35709:   if (aIsInterval || nestingLevel >= DOM_CLAMP_TIMEOUT_NESTING_LEVEL) {
60635:     // Don't allow timeouts less than DOMMinTimeoutValue() from
    1:     // now...
64670:     realInterval = NS_MAX(realInterval, DOMMinTimeoutValue());
64670:   }
    1: 
    1:   // Get principal of currently executing code, save for execution of timeout.
 3286:   // If our principals subsume the subject principal then use the subject
 3286:   // principal. Otherwise, use our principal to avoid running script in
 3286:   // elevated principals.
    1: 
    1:   nsCOMPtr<nsIPrincipal> subjectPrincipal;
    1:   nsresult rv;
    1:   rv = nsContentUtils::GetSecurityManager()->
    1:     GetSubjectPrincipal(getter_AddRefs(subjectPrincipal));
    1:   if (NS_FAILED(rv)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
79445:   bool subsumes = false;
    1:   nsCOMPtr<nsIPrincipal> ourPrincipal = GetPrincipal();
    1: 
 3286:   // Note the direction of this test: We don't allow setTimeouts running with
 3286:   // chrome privileges on content windows, but we do allow setTimeouts running
 3286:   // with content privileges on chrome windows (where they can't do very much,
 3286:   // of course).
    1:   rv = ourPrincipal->Subsumes(subjectPrincipal, &subsumes);
    1:   if (NS_FAILED(rv)) {
    1:     return NS_ERROR_FAILURE;
    1:   }
    1: 
    1:   if (subsumes) {
    1:     timeout->mPrincipal = subjectPrincipal;
    1:   } else {
 3286:     timeout->mPrincipal = ourPrincipal;
    1:   }
    1: 
48032:   TimeDuration delta = TimeDuration::FromMilliseconds(realInterval);
    1: 
25074:   if (!IsFrozen() && !mTimeoutsSuspendDepth) {
    1:     // If we're not currently frozen, then we set timeout->mWhen to be the
    1:     // actual firing time of the timer (i.e., now + delta). We also actually
    1:     // create a timer and fire it off.
    1: 
48032:     timeout->mWhen = TimeStamp::Now() + delta;
    1: 
    1:     timeout->mTimer = do_CreateInstance("@mozilla.org/timer;1", &rv);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
78894:     nsRefPtr<nsTimeout> copy = timeout;
78894: 
    1:     rv = timeout->mTimer->InitWithFuncCallback(TimerCallback, timeout,
    1:                                                realInterval,
    1:                                                nsITimer::TYPE_ONE_SHOT);
    1:     if (NS_FAILED(rv)) {
    1:       return rv;
    1:     }
    1: 
    1:     // The timeout is now also held in the timer's closure.
78894:     copy.forget();
    1:   } else {
48032:     // If we are frozen, however, then we instead simply set
48032:     // timeout->mTimeRemaining to be the "time remaining" in the timeout (i.e.,
48032:     // the interval itself). We don't create a timer for it, since that will
48032:     // happen when we are thawed and the timeout will then get a timer and run
48032:     // to completion.
48032: 
48032:     timeout->mTimeRemaining = delta;
    1:   }
    1: 
    1:   timeout->mWindow = this;
    1: 
34729:   if (!aIsInterval) {
34729:     timeout->mNestingLevel = nestingLevel;
34729:   }
34729: 
    1:   // No popups from timeouts by default
    1:   timeout->mPopupState = openAbused;
    1: 
    1:   if (gRunningTimeoutDepth == 0 && gPopupControlState < openAbused) {
    1:     // This timeout is *not* set from another timeout and it's set
    1:     // while popups are enabled. Propagate the state to the timeout if
    1:     // its delay (interval) is equal to or less than what
    1:     // "dom.disable_open_click_delay" is set to (in ms).
    1: 
    1:     PRInt32 delay =
70842:       Preferences::GetInt("dom.disable_open_click_delay");
    1: 
64670:     // This is checking |interval|, not realInterval, on purpose,
64670:     // because our lower bound for |realInterval| could be pretty high
64670:     // in some cases.
    1:     if (interval <= delay) {
    1:       timeout->mPopupState = gPopupControlState;
    1:     }
    1:   }
    1: 
    1:   InsertTimeoutIntoList(timeout);
    1: 
    1:   timeout->mPublicId = ++mTimeoutPublicIdCounter;
    1:   *aReturn = timeout->mPublicId;
    1: 
    1:   return NS_OK;
    1: 
    1: }
    1: 
    1: nsresult
79445: nsGlobalWindow::SetTimeoutOrInterval(bool aIsInterval, PRInt32 *aReturn)
    1: {
 4427:   // This needs to forward to the inner window, but since the current
 4427:   // inner may not be the inner in the calling scope, we need to treat
 4427:   // this specially here as we don't want timeouts registered in a
 4427:   // dying inner window to get registered and run on the current inner
 4427:   // window. To get this right, we need to forward this call to the
 4427:   // inner window that's calling window.setTimeout().
 4427: 
 4427:   if (IsOuterWindow()) {
10976:     nsGlobalWindow* callerInner = CallerInnerWindow();
 4427:     NS_ENSURE_TRUE(callerInner, NS_ERROR_NOT_AVAILABLE);
 4427: 
 4427:     // If the caller and the callee share the same outer window,
 4427:     // forward to the callee inner. Else, we forward to the current
 4427:     // inner (e.g. someone is calling setTimeout() on a reference to
 4427:     // some other window).
 4427: 
 4433:     if (callerInner->GetOuterWindow() == this &&
 4433:         callerInner->IsInnerWindow()) {
 4427:       return callerInner->SetTimeoutOrInterval(aIsInterval, aReturn);
 4427:     }
 4427: 
    1:     FORWARD_TO_INNER(SetTimeoutOrInterval, (aIsInterval, aReturn),
    1:                      NS_ERROR_NOT_INITIALIZED);
 4427:   }
    1: 
    1:   PRInt32 interval = 0;
79445:   bool isInterval = aIsInterval;
    1:   nsCOMPtr<nsIScriptTimeoutHandler> handler;
10986:   nsresult rv = NS_CreateJSTimeoutHandler(this,
 3106:                                           &isInterval,
    1:                                           &interval,
    1:                                           getter_AddRefs(handler));
    1:   if (NS_FAILED(rv))
    1:     return (rv == NS_ERROR_DOM_TYPE_ERR) ? NS_OK : rv;
    1: 
 3106:   return SetTimeoutOrInterval(handler, interval, isInterval, aReturn);
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::RunTimeout(nsTimeout *aTimeout)
    1: {
    1:   // If a modal dialog is open for this window, return early. Pending
    1:   // timeouts will run when the modal dialog is dismissed.
25074:   if (IsInModalState() || mTimeoutsSuspendDepth) {
    1:     return;
    1:   }
    1: 
42480:   NS_TIME_FUNCTION;
42480: 
    1:   NS_ASSERTION(IsInnerWindow(), "Timeout running on outer window!");
    1:   NS_ASSERTION(!IsFrozen(), "Timeout running on a window in the bfcache!");
    1: 
    1:   nsTimeout *nextTimeout, *timeout;
    1:   nsTimeout *last_expired_timeout, *last_insertion_point;
    1:   nsTimeout dummy_timeout;
    1:   PRUint32 firingDepth = mTimeoutFiringDepth + 1;
    1: 
    1:   // Make sure that the window and the script context don't go away as
    1:   // a result of running timeouts
    1:   nsCOMPtr<nsIScriptGlobalObject> windowKungFuDeathGrip(this);
    1: 
    1:   // A native timer has gone off. See which of our timeouts need
    1:   // servicing
48032:   TimeStamp now = TimeStamp::Now();
48032:   TimeStamp deadline;
    1: 
    1:   if (aTimeout && aTimeout->mWhen > now) {
51588:     // The OS timer fired early (yikes!), and possibly out of order
51588:     // too. Set |deadline| to be the time when the OS timer *should*
51588:     // have fired so that any timers that *should* have fired before
51588:     // aTimeout *will* be fired now. This happens most of the time on
51588:     // Win2k.
51588: 
    1:     deadline = aTimeout->mWhen;
    1:   } else {
    1:     deadline = now;
    1:   }
    1: 
    1:   // The timeout list is kept in deadline order. Discover the latest
    1:   // timeout whose deadline has expired. On some platforms, native
    1:   // timeout events fire "early", so we need to test the timer as well
    1:   // as the deadline.
    1:   last_expired_timeout = nsnull;
    1:   for (timeout = FirstTimeout(); IsTimeout(timeout); timeout = timeout->Next()) {
    1:     if (((timeout == aTimeout) || (timeout->mWhen <= deadline)) &&
    1:         (timeout->mFiringDepth == 0)) {
    1:       // Mark any timeouts that are on the list to be fired with the
    1:       // firing depth so that we can reentrantly run timeouts
    1:       timeout->mFiringDepth = firingDepth;
    1:       last_expired_timeout = timeout;
    1:     }
    1:   }
    1: 
    1:   // Maybe the timeout that the event was fired for has been deleted
    1:   // and there are no others timeouts with deadlines that make them
    1:   // eligible for execution yet. Go away.
    1:   if (!last_expired_timeout) {
    1:     return;
    1:   }
    1: 
    1:   // Insert a dummy timeout into the list of timeouts between the
    1:   // portion of the list that we are about to process now and those
    1:   // timeouts that will be processed in a future call to
    1:   // win_run_timeout(). This dummy timeout serves as the head of the
    1:   // list for any timeouts inserted as a result of running a timeout.
    1:   dummy_timeout.mFiringDepth = firingDepth;
48032:   dummy_timeout.mWhen = now;
    1:   PR_INSERT_AFTER(&dummy_timeout, last_expired_timeout);
    1: 
    1:   // Don't let ClearWindowTimeouts throw away our stack-allocated
    1:   // dummy timeout.
    1:   dummy_timeout.AddRef();
    1:   dummy_timeout.AddRef();
    1: 
    1:   last_insertion_point = mTimeoutInsertionPoint;
73617:   // If we ever start setting mTimeoutInsertionPoint to a non-dummy timeout,
73617:   // the logic in ResetTimersForNonBackgroundWindow will need to change.
    1:   mTimeoutInsertionPoint = &dummy_timeout;
    1: 
87192:   Telemetry::AutoCounter<Telemetry::DOM_TIMERS_FIRED_PER_NATIVE_TIMEOUT> timeoutsRan;
87192: 
    1:   for (timeout = FirstTimeout();
27828:        timeout != &dummy_timeout && !IsFrozen();
    1:        timeout = nextTimeout) {
    1:     nextTimeout = timeout->Next();
    1: 
    1:     if (timeout->mFiringDepth != firingDepth) {
    1:       // We skip the timeout since it's on the list to run at another
    1:       // depth.
    1: 
    1:       continue;
    1:     }
    1: 
27828:     if (mTimeoutsSuspendDepth) {
27828:       // Some timer did suspend us. Make sure the
27828:       // rest of the timers get executed later.
27828:       timeout->mFiringDepth = 0;
27828:       continue;
27828:     }
27828: 
    1:     // The timeout is on the list to run at this depth, go ahead and
    1:     // process it.
    1: 
    1:     // Get the script context (a strong ref to prevent it going away)
    1:     // for this timeout and ensure the script language is enabled.
    1:     nsCOMPtr<nsIScriptContext> scx = GetScriptContextInternal(
    1:                                 timeout->mScriptHandler->GetScriptTypeID());
    1: 
    1:     if (!scx) {
    1:       // No context means this window was closed or never properly
    1:       // initialized for this language.
    1:       continue;
    1:     }
    1: 
    1:     // The "scripts disabled" concept is still a little vague wrt
    1:     // multiple languages.  Prepare for the day when languages can be
    1:     // disabled independently of the other languages...
    1:     if (!scx->GetScriptsEnabled()) {
    1:       // Scripts were enabled once in this window (unless aTimeout ==
    1:       // nsnull) but now scripts are disabled (we might be in
    1:       // print-preview, for instance), this means we shouldn't run any
    1:       // timeouts at this point.
    1:       //
    1:       // If scripts are enabled for this language in this window again
    1:       // we'll fire the timeouts that are due at that point.
    1:       continue;
    1:     }
    1: 
    1:     // This timeout is good to run
    1:     nsTimeout *last_running_timeout = mRunningTimeout;
    1:     mRunningTimeout = timeout;
80486:     timeout->mRunning = true;
87192:     ++timeoutsRan;
    1: 
    1:     // Push this timeout's popup control state, which should only be
    1:     // eabled the first time a timeout fires that was created while
    1:     // popups were enabled and with a delay less than
    1:     // "dom.disable_open_click_delay".
    1:     nsAutoPopupStatePusher popupStatePusher(timeout->mPopupState);
    1: 
    1:     // Clear the timeout's popup state, if any, to prevent interval
    1:     // timeouts from repeatedly opening poups.
    1:     timeout->mPopupState = openAbused;
    1: 
    1:     // Hold on to the timeout in case mExpr or mFunObj releases its
    1:     // doc.
    1:     timeout->AddRef();
    1: 
    1:     ++gRunningTimeoutDepth;
    1:     ++mTimeoutFiringDepth;
    1: 
79445:     bool trackNestingLevel = !timeout->mIsInterval;
34729:     PRUint32 nestingLevel;
34729:     if (trackNestingLevel) {
34729:       nestingLevel = sNestingLevel;
34729:       sNestingLevel = timeout->mNestingLevel;
34729:     }
34729: 
    1:     nsCOMPtr<nsIScriptTimeoutHandler> handler(timeout->mScriptHandler);
84683:     JSObject* scriptObject = handler->GetScriptObject();
    1:     if (!scriptObject) {
    1:       // Evaluate the timeout expression.
    1:       const PRUnichar *script = handler->GetHandlerText();
    1:       NS_ASSERTION(script, "timeout has no script nor handler text!");
    1: 
    1:       const char *filename = nsnull;
    1:       PRUint32 lineNo = 0;
    1:       handler->GetLocation(&filename, &lineNo);
    1: 
42480:       NS_TIME_FUNCTION_MARK("(file: %s, line: %d)", filename, lineNo);
42480: 
79445:       bool is_undefined;
81044:       scx->EvaluateString(nsDependentString(script), FastGetGlobalJSObject(),
85979:                           timeout->mPrincipal, timeout->mPrincipal,
85979:                           filename, lineNo,
    1:                           handler->GetScriptVersion(), nsnull,
    1:                           &is_undefined);
    1:     } else {
    1:       // Let the script handler know about the "secret" final argument that
    1:       // indicates timeout lateness in milliseconds
48032:       TimeDuration lateness = now - timeout->mWhen;
48032: 
48032:       handler->SetLateness(lateness.ToMilliseconds());
    1: 
    1:       nsCOMPtr<nsIVariant> dummy;
 3233:       nsCOMPtr<nsISupports> me(static_cast<nsIDOMWindow *>(this));
81044:       scx->CallEventHandler(me, FastGetGlobalJSObject(),
    1:                             scriptObject, handler->GetArgv(),
    1:                             // XXXmarkh - consider allowing CallEventHandler to
    1:                             // accept nsnull?
    1:                             getter_AddRefs(dummy));
    1: 
    1:     }
    1:     handler = nsnull; // drop reference before dropping timeout refs.
    1: 
34729:     if (trackNestingLevel) {
34729:       sNestingLevel = nestingLevel;
34729:     }
34729: 
    1:     --mTimeoutFiringDepth;
    1:     --gRunningTimeoutDepth;
    1: 
    1:     mRunningTimeout = last_running_timeout;
80486:     timeout->mRunning = false;
    1: 
    1:     // We ignore any failures from calling EvaluateString() or
    1:     // CallEventHandler() on the context here since we're in a loop
    1:     // where we're likely to be running timeouts whose OS timers
    1:     // didn't fire in time and we don't want to not fire those timers
    1:     // now just because execution of one timer failed. We can't
    1:     // propagate the error to anyone who cares about it from this
    1:     // point anyway, and the script context should have already reported
    1:     // the script error in the usual way - so we just drop it.
    1: 
    1:     // If all timeouts were cleared and |timeout != aTimeout| then
    1:     // |timeout| may be the last reference to the timeout so check if
    1:     // it was cleared before releasing it.
79445:     bool timeout_was_cleared = timeout->mCleared;
    1: 
    1:     timeout->Release();
    1: 
    1:     if (timeout_was_cleared) {
    1:       // The running timeout's window was cleared, this means that
    1:       // ClearAllTimeouts() was called from a *nested* call, possibly
    1:       // through a timeout that fired while a modal (to this window)
    1:       // dialog was open or through other non-obvious paths.
    1: 
    1:       mTimeoutInsertionPoint = last_insertion_point;
    1: 
    1:       return;
    1:     }
    1: 
79445:     bool isInterval = false;
    1: 
    1:     // If we have a regular interval timer, we re-schedule the
    1:     // timeout, accounting for clock drift.
72734:     if (timeout->mIsInterval) {
34804:       // Compute time to next timeout for interval timer.
60635:       // Make sure nextInterval is at least DOMMinTimeoutValue().
48032:       TimeDuration nextInterval =
48032:         TimeDuration::FromMilliseconds(NS_MAX(timeout->mInterval,
60635:                                               PRUint32(DOMMinTimeoutValue())));
34804: 
34804:       // If we're running pending timeouts because they've been temporarily
34804:       // disabled (!aTimeout), set the next interval to be relative to "now",
81296:       // and not to when the timeout that was pending should have fired.
48032:       TimeStamp firingTime;
81296:       if (!aTimeout)
48032:         firingTime = now + nextInterval;
 2033:       else
48032:         firingTime = timeout->mWhen + nextInterval;
48032: 
81296:       TimeStamp currentNow = TimeStamp::Now();
81296:       TimeDuration delay = firingTime - currentNow;
    1: 
34804:       // And make sure delay is nonnegative; that might happen if the timer
81296:       // thread is firing our timers somewhat early or if they're taking a long
81296:       // time to run the callback.
48032:       if (delay < TimeDuration(0)) {
48032:         delay = TimeDuration(0);
    1:       }
    1: 
    1:       if (timeout->mTimer) {
81296:         timeout->mWhen = currentNow + delay; // firingTime unless delay got
81296:                                              // clamped, in which case it's
81296:                                              // currentNow.
    1: 
    1:         // Reschedule the OS timer. Don't bother returning any error
    1:         // codes if this fails since the callers of this method
    1:         // doesn't care about them nobody who cares about them
    1:         // anyways.
    1: 
    1:         // Make sure to cast the unsigned PR_USEC_PER_MSEC to signed
    1:         // PRTime to make the division do the right thing on 64-bit
    1:         // platforms whether delay is positive or negative (which we
    1:         // know is always positive here, but cast anyways for
    1:         // consistency).
    1:         nsresult rv = timeout->mTimer->
    1:           InitWithFuncCallback(TimerCallback, timeout,
48032:                                delay.ToMilliseconds(),
    1:                                nsITimer::TYPE_ONE_SHOT);
    1: 
    1:         if (NS_FAILED(rv)) {
    1:           NS_ERROR("Error initializing timer for DOM timeout!");
    1: 
    1:           // We failed to initialize the new OS timer, this timer does
    1:           // us no good here so we just cancel it (just in case) and
    1:           // null out the pointer to the OS timer, this will release the
    1:           // OS timer. As we continue executing the code below we'll end
    1:           // up deleting the timeout since it's not an interval timeout
    1:           // any more (since timeout->mTimer == nsnull).
    1:           timeout->mTimer->Cancel();
    1:           timeout->mTimer = nsnull;
    1: 
    1:           // Now that the OS timer no longer has a reference to the
    1:           // timeout we need to drop that reference.
    1:           timeout->Release();
    1:         }
    1:       } else {
25721:         NS_ASSERTION(IsFrozen() || mTimeoutsSuspendDepth,
25721:                      "How'd our timer end up null if we're not frozen or "
25721:                      "suspended?");
    1: 
48032:         timeout->mTimeRemaining = delay;
80486:         isInterval = true;
    1:       }
    1:     }
    1: 
    1:     if (timeout->mTimer) {
72734:       if (timeout->mIsInterval) {
80486:         isInterval = true;
    1:       } else {
    1:         // The timeout still has an OS timer, and it's not an
    1:         // interval, that means that the OS timer could still fire (if
    1:         // it didn't already, i.e. aTimeout == timeout), cancel the OS
24114:         // timer and release its reference to the timeout.
    1:         timeout->mTimer->Cancel();
    1:         timeout->mTimer = nsnull;
    1: 
    1:         timeout->Release();
    1:       }
    1:     }
    1: 
    1:     // Running a timeout can cause another timeout to be deleted, so
    1:     // we need to reset the pointer to the following timeout.
    1:     nextTimeout = timeout->Next();
    1: 
    1:     PR_REMOVE_LINK(timeout);
    1: 
    1:     if (isInterval) {
    1:       // Reschedule an interval timeout. Insert interval timeout
    1:       // onto list sorted in deadline order.
25838:       // AddRefs timeout.
    1:       InsertTimeoutIntoList(timeout);
    1:     }
25838: 
25838:     // Release the timeout struct since it's possibly out of the list
25838:     timeout->Release();
    1:   }
    1: 
    1:   // Take the dummy timeout off the head of the list
    1:   PR_REMOVE_LINK(&dummy_timeout);
    1: 
    1:   mTimeoutInsertionPoint = last_insertion_point;
    1: }
    1: 
    1: nsrefcnt
    1: nsTimeout::Release()
    1: {
    1:   if (--mRefCnt > 0)
    1:     return mRefCnt;
    1: 
    1:   // language specific cleanup done as mScriptHandler destructs...
    1: 
    1:   // Kill the timer if it is still alive.
    1:   if (mTimer) {
    1:     mTimer->Cancel();
    1:     mTimer = nsnull;
    1:   }
    1: 
    1:   delete this;
    1:   return 0;
    1: }
    1: 
    1: nsrefcnt
    1: nsTimeout::AddRef()
    1: {
    1:   return ++mRefCnt;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsGlobalWindow::ClearTimeoutOrInterval(PRInt32 aTimerID)
    1: {
    1:   FORWARD_TO_INNER(ClearTimeoutOrInterval, (aTimerID), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   PRUint32 public_id = (PRUint32)aTimerID;
    1:   nsTimeout *timeout;
    1: 
    1:   for (timeout = FirstTimeout();
    1:        IsTimeout(timeout);
    1:        timeout = timeout->Next()) {
    1:     if (timeout->mPublicId == public_id) {
    1:       if (timeout->mRunning) {
    1:         /* We're running from inside the timeout. Mark this
    1:            timeout for deferred deletion by the code in
    1:            RunTimeout() */
80486:         timeout->mIsInterval = false;
    1:       }
    1:       else {
    1:         /* Delete the timeout from the pending timeout list */
    1:         PR_REMOVE_LINK(timeout);
    1: 
    1:         if (timeout->mTimer) {
    1:           timeout->mTimer->Cancel();
    1:           timeout->mTimer = nsnull;
    1:           timeout->Release();
    1:         }
    1:         timeout->Release();
    1:       }
    1:       break;
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
72734: nsresult nsGlobalWindow::ResetTimersForNonBackgroundWindow()
72734: {
72734:   FORWARD_TO_INNER(ResetTimersForNonBackgroundWindow, (),
72734:                    NS_ERROR_NOT_INITIALIZED);
72734: 
72734:   if (IsFrozen() || mTimeoutsSuspendDepth) {
72734:     return NS_OK;
72734:   }
72734: 
72734:   TimeStamp now = TimeStamp::Now();
72734: 
73617:   // If mTimeoutInsertionPoint is non-null, we're in the middle of firing
73617:   // timers and the timers we're planning to fire all come before
73617:   // mTimeoutInsertionPoint; mTimeoutInsertionPoint itself is a dummy timeout
73617:   // with an mWhen that may be semi-bogus.  In that case, we don't need to do
73617:   // anything with mTimeoutInsertionPoint or anything before it, so should
73617:   // start at the timer after mTimeoutInsertionPoint, if there is one.
73617:   // Otherwise, start at the beginning of the list.
73617:   for (nsTimeout *timeout = mTimeoutInsertionPoint ?
73617:          mTimeoutInsertionPoint->Next() : FirstTimeout();
73617:        IsTimeout(timeout); ) {
72734:     // It's important that this check be <= so that we guarantee that
72734:     // taking NS_MAX with |now| won't make a quantity equal to
72734:     // timeout->mWhen below.
72734:     if (timeout->mWhen <= now) {
72734:       timeout = timeout->Next();
72734:       continue;
72734:     }
72734: 
72734:     if (timeout->mWhen - now >
72734:         TimeDuration::FromMilliseconds(gMinBackgroundTimeoutValue)) {
72734:       // No need to loop further.  Timeouts are sorted in mWhen order
72734:       // and the ones after this point were all set up for at least
72734:       // gMinBackgroundTimeoutValue ms and hence were not clamped.
72734:       break;
72734:     }
72734: 
72734:     /* We switched from background. Re-init the timer appropriately */
72734:     // Compute the interval the timer should have had if it had not been set in a
72734:     // background window
72734:     TimeDuration interval =
72734:       TimeDuration::FromMilliseconds(NS_MAX(timeout->mInterval,
72734:                                             PRUint32(DOMMinTimeoutValue())));
72734:     PRUint32 oldIntervalMillisecs = 0;
72734:     timeout->mTimer->GetDelay(&oldIntervalMillisecs);
72734:     TimeDuration oldInterval = TimeDuration::FromMilliseconds(oldIntervalMillisecs);
72734:     if (oldInterval > interval) {
72734:       // unclamp
72734:       TimeStamp firingTime =
72734:         NS_MAX(timeout->mWhen - oldInterval + interval, now);
72734: 
72734:       NS_ASSERTION(firingTime < timeout->mWhen,
72734:                    "Our firing time should strictly decrease!");
72734: 
72734:       TimeDuration delay = firingTime - now;
72734:       timeout->mWhen = firingTime;
72734: 
72734:       // Since we reset mWhen we need to move |timeout| to the right
72734:       // place in the list so that it remains sorted by mWhen.
72734:       
72734:       // Get the pointer to the next timeout now, before we move the
72734:       // current timeout in the list.
72734:       nsTimeout* nextTimeout = timeout->Next();
72734: 
72734:       // It is safe to remove and re-insert because mWhen is now
72734:       // strictly smaller than it used to be, so we know we'll insert
72734:       // |timeout| before nextTimeout.
72734:       NS_ASSERTION(!IsTimeout(nextTimeout) ||
72734:                    timeout->mWhen < nextTimeout->mWhen, "How did that happen?");
72734:       PR_REMOVE_LINK(timeout);
72734:       // InsertTimeoutIntoList will addref |timeout| and reset
72734:       // mFiringDepth.  Make sure to undo that after calling it.
72734:       PRUint32 firingDepth = timeout->mFiringDepth;
72734:       InsertTimeoutIntoList(timeout);
72734:       timeout->mFiringDepth = firingDepth;
72734:       timeout->Release();
72734: 
72734:       nsresult rv =
72734:         timeout->mTimer->InitWithFuncCallback(TimerCallback,
72734:                                               timeout,
72734:                                               delay.ToMilliseconds(),
72734:                                               nsITimer::TYPE_ONE_SHOT);
72734: 
72734:       if (NS_FAILED(rv)) {
72734:         NS_WARNING("Error resetting non background timer for DOM timeout!");
72734:         return rv;
72734:       }
72734: 
72734:       timeout = nextTimeout;
72734:     } else {
72734:       timeout = timeout->Next();
72734:     }
72734:   }
72734: 
72734:   return NS_OK;
72734: }
72734: 
    1: void
    1: nsGlobalWindow::ClearAllTimeouts()
    1: {
    1:   nsTimeout *timeout, *nextTimeout;
    1: 
    1:   for (timeout = FirstTimeout(); IsTimeout(timeout); timeout = nextTimeout) {
    1:     /* If RunTimeout() is higher up on the stack for this
    1:        window, e.g. as a result of document.write from a timeout,
    1:        then we need to reset the list insertion point for
    1:        newly-created timeouts in case the user adds a timeout,
    1:        before we pop the stack back to RunTimeout. */
    1:     if (mRunningTimeout == timeout)
    1:       mTimeoutInsertionPoint = nsnull;
    1: 
    1:     nextTimeout = timeout->Next();
    1: 
    1:     if (timeout->mTimer) {
    1:       timeout->mTimer->Cancel();
    1:       timeout->mTimer = nsnull;
    1: 
    1:       // Drop the count since the timer isn't going to hold on
    1:       // anymore.
    1:       timeout->Release();
    1:     }
    1: 
    1:     // Set timeout->mCleared to true to indicate that the timeout was
    1:     // cleared and taken out of the list of timeouts
80486:     timeout->mCleared = true;
    1: 
    1:     // Drop the count since we're removing it from the list.
    1:     timeout->Release();
    1:   }
    1: 
    1:   // Clear out our list
    1:   PR_INIT_CLIST(&mTimeouts);
    1: }
    1: 
    1: void
    1: nsGlobalWindow::InsertTimeoutIntoList(nsTimeout *aTimeout)
    1: {
    1:   NS_ASSERTION(IsInnerWindow(),
    1:                "InsertTimeoutIntoList() called on outer window!");
    1: 
    1:   // Start at mLastTimeout and go backwards.  Don't go further than
    1:   // mTimeoutInsertionPoint, though.  This optimizes for the common case of
    1:   // insertion at the end.
    1:   nsTimeout* prevSibling;
    1:   for (prevSibling = LastTimeout();
    1:        IsTimeout(prevSibling) && prevSibling != mTimeoutInsertionPoint &&
48032:          // This condition needs to match the one in SetTimeoutOrInterval that
48032:          // determines whether to set mWhen or mTimeRemaining.
48032:          ((IsFrozen() || mTimeoutsSuspendDepth) ?
48032:           prevSibling->mTimeRemaining > aTimeout->mTimeRemaining :
48032:           prevSibling->mWhen > aTimeout->mWhen);
    1:        prevSibling = prevSibling->Prev()) {
    1:     /* Do nothing; just searching */
    1:   }
    1: 
    1:   // Now link in aTimeout after prevSibling.
    1:   PR_INSERT_AFTER(aTimeout, prevSibling);
    1: 
    1:   aTimeout->mFiringDepth = 0;
    1: 
    1:   // Increment the timeout's reference count since it's now held on to
    1:   // by the list
    1:   aTimeout->AddRef();
    1: }
    1: 
    1: // static
    1: void
    1: nsGlobalWindow::TimerCallback(nsITimer *aTimer, void *aClosure)
    1: {
71999:   nsRefPtr<nsTimeout> timeout = (nsTimeout *)aClosure;
    1: 
    1:   timeout->mWindow->RunTimeout(timeout);
    1: }
    1: 
    1: //*****************************************************************************
    1: // nsGlobalWindow: Helper Functions
    1: //*****************************************************************************
36884: 
    1: nsresult
    1: nsGlobalWindow::GetTreeOwner(nsIDocShellTreeOwner **aTreeOwner)
    1: {
    1:   FORWARD_TO_OUTER(GetTreeOwner, (aTreeOwner), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1: 
    1:   // If there's no docShellAsItem, this window must have been closed,
    1:   // in that case there is no tree owner.
    1: 
    1:   if (!docShellAsItem) {
    1:     *aTreeOwner = nsnull;
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   return docShellAsItem->GetTreeOwner(aTreeOwner);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::GetTreeOwner(nsIBaseWindow **aTreeOwner)
    1: {
    1:   FORWARD_TO_OUTER(GetTreeOwner, (aTreeOwner), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsCOMPtr<nsIDocShellTreeItem> docShellAsItem(do_QueryInterface(mDocShell));
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1: 
    1:   // If there's no docShellAsItem, this window must have been closed,
    1:   // in that case there is no tree owner.
    1: 
    1:   if (docShellAsItem) {
    1:     docShellAsItem->GetTreeOwner(getter_AddRefs(treeOwner));
    1:   }
    1: 
    1:   if (!treeOwner) {
    1:     *aTreeOwner = nsnull;
    1:     return NS_OK;
    1:   }
    1: 
    1:   return CallQueryInterface(treeOwner, aTreeOwner);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::GetWebBrowserChrome(nsIWebBrowserChrome **aBrowserChrome)
    1: {
    1:   nsCOMPtr<nsIDocShellTreeOwner> treeOwner;
    1:   GetTreeOwner(getter_AddRefs(treeOwner));
    1: 
    1:   nsCOMPtr<nsIWebBrowserChrome> browserChrome(do_GetInterface(treeOwner));
    1:   NS_IF_ADDREF(*aBrowserChrome = browserChrome);
    1: 
    1:   return NS_OK;
    1: }
    1: 
37063: nsIScrollableFrame *
37063: nsGlobalWindow::GetScrollFrame()
37063: {
37063:   FORWARD_TO_OUTER(GetScrollFrame, (), nsnull);
    1: 
    1:   if (!mDocShell) {
37063:     return nsnull;
    1:   }
    1: 
26050:   nsCOMPtr<nsIPresShell> presShell;
26050:   mDocShell->GetPresShell(getter_AddRefs(presShell));
26050:   if (presShell) {
37063:     return presShell->GetRootScrollFrameAsScrollable();
37063:   }
37063:   return nsnull;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::BuildURIfromBase(const char *aURL, nsIURI **aBuiltURI,
79445:                                  bool *aFreeSecurityPass,
    1:                                  JSContext **aCXused)
    1: {
    1:   nsIScriptContext *scx = GetContextInternal();
    1:   JSContext *cx = nsnull;
    1: 
    1:   *aBuiltURI = nsnull;
80486:   *aFreeSecurityPass = false;
    1:   if (aCXused)
    1:     *aCXused = nsnull;
    1: 
    1:   // get JSContext
    1:   NS_ASSERTION(scx, "opening window missing its context");
    1:   NS_ASSERTION(mDocument, "opening window missing its document");
    1:   if (!scx || !mDocument)
    1:     return NS_ERROR_FAILURE;
    1: 
77547:   nsCOMPtr<nsIDOMChromeWindow> chrome_win = do_QueryObject(this);
    1: 
    1:   if (nsContentUtils::IsCallerChrome() && !chrome_win) {
    1:     // If open() is called from chrome on a non-chrome window, we'll
    1:     // use the context from the window on which open() is being called
    1:     // to prevent giving chrome priveleges to new windows opened in
    1:     // such a way. This also makes us get the appropriate base URI for
    1:     // the below URI resolution code.
    1: 
78415:     cx = scx->GetNativeContext();
    1:   } else {
    1:     // get the JSContext from the call stack
    1:     nsCOMPtr<nsIThreadJSContextStack> stack(do_GetService(sJSStackContractID));
    1:     if (stack)
    1:       stack->Peek(&cx);
    1:   }
    1: 
    1:   /* resolve the URI, which could be relative to the calling window
    1:      (note the algorithm to get the base URI should match the one
    1:      used to actually kick off the load in nsWindowWatcher.cpp). */
    1:   nsCAutoString charset(NS_LITERAL_CSTRING("UTF-8")); // default to utf-8
    1:   nsIURI* baseURI = nsnull;
    1:   nsCOMPtr<nsIURI> uriToLoad;
    1:   nsCOMPtr<nsIDOMWindow> sourceWindow;
    1: 
    1:   if (cx) {
    1:     nsIScriptContext *scriptcx = nsJSUtils::GetDynamicScriptContext(cx);
    1:     if (scriptcx)
    1:       sourceWindow = do_QueryInterface(scriptcx->GetGlobalObject());
    1:   }
    1: 
    1:   if (!sourceWindow) {
    1:     sourceWindow = do_QueryInterface(NS_ISUPPORTS_CAST(nsIDOMWindow *, this));
80486:     *aFreeSecurityPass = true;
    1:   }
    1: 
    1:   if (sourceWindow) {
    1:     nsCOMPtr<nsIDOMDocument> domDoc;
    1:     sourceWindow->GetDocument(getter_AddRefs(domDoc));
    1:     nsCOMPtr<nsIDocument> doc(do_QueryInterface(domDoc));
    1:     if (doc) {
41900:       baseURI = doc->GetDocBaseURI();
    1:       charset = doc->GetDocumentCharacterSet();
    1:     }
    1:   }
    1: 
    1:   if (aCXused)
    1:     *aCXused = cx;
    1:   return NS_NewURI(aBuiltURI, nsDependentCString(aURL), charset.get(), baseURI);
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::SecurityCheckURL(const char *aURL)
    1: {
    1:   JSContext       *cx;
79445:   bool             freePass;
    1:   nsCOMPtr<nsIURI> uri;
    1: 
    1:   if (NS_FAILED(BuildURIfromBase(aURL, getter_AddRefs(uri), &freePass, &cx)))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!freePass && NS_FAILED(nsContentUtils::GetSecurityManager()->
    1:         CheckLoadURIFromScript(cx, uri)))
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsGlobalWindow::FlushPendingNotifications(mozFlushType aType)
    1: {
    1:   if (mDoc) {
    1:     mDoc->FlushPendingNotifications(aType);
    1:   }
    1: }
    1: 
    1: void
    1: nsGlobalWindow::EnsureSizeUpToDate()
    1: {
    1:   // If we're a subframe, make sure our size is up to date.  It's OK that this
    1:   // crosses the content/chrome boundary, since chrome can have pending reflows
    1:   // too.
    1:   nsGlobalWindow *parent =
 3233:     static_cast<nsGlobalWindow *>(GetPrivateParent());
    1:   if (parent) {
    1:     parent->FlushPendingNotifications(Flush_Layout);
    1:   }
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::SaveWindowState(nsISupports **aState)
    1: {
    1:   NS_PRECONDITION(IsOuterWindow(), "Can't save the inner window's state");
    1: 
    1:   *aState = nsnull;
    1: 
    1:   if (!mContext || !mJSObject) {
    1:     // The window may be getting torn down; don't bother saving state.
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
    1:   NS_ASSERTION(inner, "No inner window to save");
    1: 
    1:   // Don't do anything else to this inner window! After this point, all
    1:   // calls to SetTimeoutOrInterval will create entries in the timeout
    1:   // list that will only run after this window has come out of the bfcache.
    1:   // Also, while we're frozen, we won't dispatch online/offline events
    1:   // to the page.
    1:   inner->Freeze();
    1: 
51082:   // Remember the outer window's prototype.
78415:   JSContext *cx = mContext->GetNativeContext();
51082:   JSAutoRequest req(cx);
51082: 
51082:   nsIXPConnect *xpc = nsContentUtils::XPConnect();
51082: 
    1:   nsCOMPtr<nsIClassInfo> ci =
    1:     do_QueryInterface((nsIScriptGlobalObject *)this);
    1:   nsCOMPtr<nsIXPConnectJSObjectHolder> proto;
51082:   nsresult rv = xpc->GetWrappedNativePrototype(cx, mJSObject, ci,
51082:                                                getter_AddRefs(proto));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
51082:   JSObject *realProto = JS_GetPrototype(cx, mJSObject);
51082:   nsCOMPtr<nsIXPConnectJSObjectHolder> realProtoHolder;
51082:   if (realProto) {
51082:     rv = xpc->HoldObject(cx, realProto, getter_AddRefs(realProtoHolder));
51082:     NS_ENSURE_SUCCESS(rv, rv);
51082:   }
51082: 
    1:   nsCOMPtr<nsISupports> state = new WindowStateHolder(inner,
47537:                                                       mInnerWindowHolder,
51082:                                                       proto,
51082:                                                       realProtoHolder);
    1:   NS_ENSURE_TRUE(state, NS_ERROR_OUT_OF_MEMORY);
    1: 
51082:   JSObject *wnProto;
51082:   proto->GetJSObject(&wnProto);
51082:   if (!JS_SetPrototype(cx, mJSObject, wnProto)) {
51082:     return NS_ERROR_FAILURE;
51082:   }
51082: 
    1: #ifdef DEBUG_PAGE_CACHE
    1:   printf("saving window state, state = %p\n", (void*)state);
    1: #endif
    1: 
    1:   state.swap(*aState);
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsGlobalWindow::RestoreWindowState(nsISupports *aState)
    1: {
    1:   NS_ASSERTION(IsOuterWindow(), "Cannot restore an inner window");
    1: 
    1:   if (!mContext || !mJSObject) {
    1:     // The window may be getting torn down; don't bother restoring state.
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsCOMPtr<WindowStateHolder> holder = do_QueryInterface(aState);
    1:   NS_ENSURE_TRUE(holder, NS_ERROR_FAILURE);
    1: 
    1: #ifdef DEBUG_PAGE_CACHE
    1:   printf("restoring window state, state = %p\n", (void*)holder);
    1: #endif
    1: 
30602:   // And we're ready to go!
    1:   nsGlobalWindow *inner = GetCurrentInnerWindowInternal();
41071: 
41071:   // if a link is focused, refocus with the FLAG_SHOWRING flag set. This makes
41071:   // it easy to tell which link was last clicked when going back a page.
41071:   nsIContent* focusedNode = inner->GetFocusedNode();
43884:   if (IsLink(focusedNode)) {
41071:     nsIFocusManager* fm = nsFocusManager::GetFocusManager();
41071:     if (fm) {
41071:       nsCOMPtr<nsIDOMElement> focusedElement(do_QueryInterface(focusedNode));
41071:       fm->SetFocus(focusedElement, nsIFocusManager::FLAG_NOSCROLL |
41071:                                    nsIFocusManager::FLAG_SHOWRING);
41071:     }
41071:   }
41071: 
    1:   inner->Thaw();
    1: 
    1:   holder->DidRestoreWindow();
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
25723: nsGlobalWindow::SuspendTimeouts(PRUint32 aIncrease,
79445:                                 bool aFreezeChildren)
25723: {
25723:   FORWARD_TO_INNER_VOID(SuspendTimeouts, (aIncrease, aFreezeChildren));
25723: 
79445:   bool suspended = (mTimeoutsSuspendDepth != 0);
25723:   mTimeoutsSuspendDepth += aIncrease;
25723: 
25723:   if (!suspended) {
72018:     DisableDeviceMotionUpdates();
59871: 
74337:     // Suspend all of the workers for this window.
74337:     nsIScriptContext *scx = GetContextInternal();
78415:     JSContext *cx = scx ? scx->GetNativeContext() : nsnull;
74337:     mozilla::dom::workers::SuspendWorkersForWindow(cx, this);
16753: 
48032:     TimeStamp now = TimeStamp::Now();
    1:     for (nsTimeout *t = FirstTimeout(); IsTimeout(t); t = t->Next()) {
48032:       // Set mTimeRemaining to be the time remaining for this timer.
    1:       if (t->mWhen > now)
48101:         t->mTimeRemaining = t->mWhen - now;
    1:       else
48032:         t->mTimeRemaining = TimeDuration(0);
    1:   
    1:       // Drop the XPCOM timer; we'll reschedule when restoring the state.
    1:       if (t->mTimer) {
    1:         t->mTimer->Cancel();
    1:         t->mTimer = nsnull;
    1:   
    1:         // Drop the reference that the timer's closure had on this timeout, we'll
    1:         // add it back in ResumeTimeouts. Note that it shouldn't matter that we're
    1:         // passing null for the context, since this shouldn't actually release this
    1:         // timeout.
    1:         t->Release();
    1:       }
    1:     }
25723:   }
    1: 
    1:   // Suspend our children as well.
    1:   nsCOMPtr<nsIDocShellTreeNode> node(do_QueryInterface(GetDocShell()));
    1:   if (node) {
    1:     PRInt32 childCount = 0;
    1:     node->GetChildCount(&childCount);
    1: 
    1:     for (PRInt32 i = 0; i < childCount; ++i) {
    1:       nsCOMPtr<nsIDocShellTreeItem> childShell;
    1:       node->GetChildAt(i, getter_AddRefs(childShell));
    1:       NS_ASSERTION(childShell, "null child shell");
    1: 
    1:       nsCOMPtr<nsPIDOMWindow> pWin = do_GetInterface(childShell);
    1:       if (pWin) {
    1:         nsGlobalWindow *win =
 3233:           static_cast<nsGlobalWindow*>
 3233:                      (static_cast<nsPIDOMWindow*>(pWin));
    1:         NS_ASSERTION(win->IsOuterWindow(), "Expected outer window");
    1:         nsGlobalWindow* inner = win->GetCurrentInnerWindowInternal();
43465: 
43465:         // This is a bit hackish. Only freeze/suspend windows which are truly our
43465:         // subwindows.
43465:         nsCOMPtr<nsIContent> frame = do_QueryInterface(pWin->GetFrameElementInternal());
80526:         if (!mDoc || !frame || mDoc != frame->OwnerDoc() || !inner) {
43465:           continue;
43465:         }
43465: 
43465:         win->SuspendTimeouts(aIncrease, aFreezeChildren);
43465: 
25723:         if (inner && aFreezeChildren) {
    1:           inner->Freeze();
    1:         }
    1:       }
    1:     }
    1:   }
    1: }
    1: 
    1: nsresult
79445: nsGlobalWindow::ResumeTimeouts(bool aThawChildren)
    1: {
    1:   FORWARD_TO_INNER(ResumeTimeouts, (), NS_ERROR_NOT_INITIALIZED);
    1: 
25074:   NS_ASSERTION(mTimeoutsSuspendDepth, "Mismatched calls to ResumeTimeouts!");
25723:   --mTimeoutsSuspendDepth;
79445:   bool shouldResume = (mTimeoutsSuspendDepth == 0);
25723:   nsresult rv;
25723: 
25723:   if (shouldResume) {
72018:     EnableDeviceMotionUpdates();
59871: 
74337:     // Resume all of the workers for this window.
74337:     nsIScriptContext *scx = GetContextInternal();
78415:     JSContext *cx = scx ? scx->GetNativeContext() : nsnull;
74337:     mozilla::dom::workers::ResumeWorkersForWindow(cx, this);
16753: 
    1:     // Restore all of the timeouts, using the stored time remaining
48032:     // (stored in timeout->mTimeRemaining).
48032: 
48032:     TimeStamp now = TimeStamp::Now();
    1: 
25170: #ifdef DEBUG
79445:     bool _seenDummyTimeout = false;
25170: #endif
25170: 
    1:     for (nsTimeout *t = FirstTimeout(); IsTimeout(t); t = t->Next()) {
25170:       // There's a chance we're being called with RunTimeout on the stack in which
25170:       // case we have a dummy timeout in the list that *must not* be resumed. It
25170:       // can be identified by a null mWindow.
25170:       if (!t->mWindow) {
25170: #ifdef DEBUG
25170:         NS_ASSERTION(!_seenDummyTimeout, "More than one dummy timeout?!");
80486:         _seenDummyTimeout = true;
25170: #endif
25170:         continue;
25170:       }
25170: 
48032:       // XXXbz the combination of the way |delay| and |t->mWhen| are set here
48032:       // makes no sense.  Are we trying to impose that min timeout value or
48032:       // not???
    1:       PRUint32 delay =
48032:         NS_MAX(PRInt32(t->mTimeRemaining.ToMilliseconds()),
60635:                DOMMinTimeoutValue());
    1: 
    1:       // Set mWhen back to the time when the timer is supposed to
    1:       // fire.
48032:       t->mWhen = now + t->mTimeRemaining;
    1: 
    1:       t->mTimer = do_CreateInstance("@mozilla.org/timer;1");
    1:       NS_ENSURE_TRUE(t->mTimer, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:       rv = t->mTimer->InitWithFuncCallback(TimerCallback, t, delay,
    1:                                            nsITimer::TYPE_ONE_SHOT);
    1:       if (NS_FAILED(rv)) {
    1:         t->mTimer = nsnull;
    1:         return rv;
    1:       }
    1: 
    1:       // Add a reference for the new timer's closure.
    1:       t->AddRef();
    1:     }
25723:   }
    1: 
    1:   // Resume our children as well.
    1:   nsCOMPtr<nsIDocShellTreeNode> node =
    1:     do_QueryInterface(GetDocShell());
    1:   if (node) {
    1:     PRInt32 childCount = 0;
    1:     node->GetChildCount(&childCount);
    1: 
    1:     for (PRInt32 i = 0; i < childCount; ++i) {
    1:       nsCOMPtr<nsIDocShellTreeItem> childShell;
    1:       node->GetChildAt(i, getter_AddRefs(childShell));
    1:       NS_ASSERTION(childShell, "null child shell");
    1: 
    1:       nsCOMPtr<nsPIDOMWindow> pWin = do_GetInterface(childShell);
    1:       if (pWin) {
    1:         nsGlobalWindow *win =
 3233:           static_cast<nsGlobalWindow*>
 3233:                      (static_cast<nsPIDOMWindow*>(pWin));
    1: 
    1:         NS_ASSERTION(win->IsOuterWindow(), "Expected outer window");
    1:         nsGlobalWindow* inner = win->GetCurrentInnerWindowInternal();
43465: 
43465:         // This is a bit hackish. Only thaw/resume windows which are truly our
43465:         // subwindows.
43465:         nsCOMPtr<nsIContent> frame = do_QueryInterface(pWin->GetFrameElementInternal());
80526:         if (!mDoc || !frame || mDoc != frame->OwnerDoc() || !inner) {
43465:           continue;
43465:         }
43465: 
25723:         if (inner && aThawChildren) {
    1:           inner->Thaw();
    1:         }
    1: 
25723:         rv = win->ResumeTimeouts(aThawChildren);
    1:         NS_ENSURE_SUCCESS(rv, rv);
    1:       }
    1:     }
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
25723: PRUint32
25723: nsGlobalWindow::TimeoutSuspendCount()
25723: {
25723:   FORWARD_TO_INNER(TimeoutSuspendCount, (), 0);
25723:   return mTimeoutsSuspendDepth;
25723: }
25723: 
31738: void
31738: nsGlobalWindow::SetHasOrientationEventListener()
31738: {
80486:   mHasDeviceMotion = true;
72018:   EnableDeviceMotionUpdates();
31738: }
31738: 
79901: void
79901: nsGlobalWindow::RemoveOrientationEventListener() {
79901:   DisableDeviceMotionUpdates();
79901: }
79901: 
58023: NS_IMETHODIMP
58023: nsGlobalWindow::GetURL(nsIDOMMozURLProperty** aURL)
58023: {
58023:   FORWARD_TO_INNER(GetURL, (aURL), NS_ERROR_UNEXPECTED);
58023: 
58023:   if (!mURLProperty) {
58023:     mURLProperty = new nsDOMMozURLProperty(this);
58023:   }
58023: 
58023:   NS_ADDREF(*aURL = mURLProperty);
58023: 
58023:   return NS_OK;
58023: }
58023: 
70840: // static
70840: bool
70840: nsGlobalWindow::HasIndexedDBSupport()
70840: {
79445:   return Preferences::GetBool("indexedDB.feature.enabled", true);
70840: }
70840: 
72298: // static
72298: bool
72298: nsGlobalWindow::HasPerformanceSupport() 
72298: {
79445:   return Preferences::GetBool("dom.enable_performance", false);
72298: }
72298: 
75136: PRInt64
75136: nsGlobalWindow::SizeOf() const
75136: {
75136:   PRInt64 size = sizeof(*this);
75136: 
77262:   if (IsInnerWindow()) {
77262:     nsEventListenerManager* elm =
80486:       const_cast<nsGlobalWindow*>(this)->GetListenerManager(false);
77262:     if (elm) {
77262:       size += elm->SizeOf();
77262:     }
77262:     if (mDoc) {
75136:       size += mDoc->SizeOf();
75136:     }
77262:   }
75136: 
75136:   size += mNavigator ? mNavigator->SizeOf() : 0;
75136: 
75136:   return size;
75136: }
72298: 
 4040: // nsGlobalChromeWindow implementation
 4040: 
    1: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGlobalChromeWindow)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsGlobalChromeWindow,
    1:                                                   nsGlobalWindow)
    1:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mBrowserDOMWindow)
42412:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mMessageManager)
    1: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
    1: 
72139: 
72139: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsGlobalChromeWindow,
72139:                                                 nsGlobalWindow)
72139:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mBrowserDOMWindow)
72139:   if (tmp->mMessageManager) {
72139:     static_cast<nsFrameMessageManager*>(
72139:       tmp->mMessageManager.get())->Disconnect();
72139:     NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mMessageManager)
72139:   }
72139: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
72139: 
40490: DOMCI_DATA(ChromeWindow, nsGlobalChromeWindow)
40490: 
    1: // QueryInterface implementation for nsGlobalChromeWindow
  791: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsGlobalChromeWindow)
    1:   NS_INTERFACE_MAP_ENTRY(nsIDOMChromeWindow)
55578:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(ChromeWindow)
    1: NS_INTERFACE_MAP_END_INHERITING(nsGlobalWindow)
    1: 
    1: NS_IMPL_ADDREF_INHERITED(nsGlobalChromeWindow, nsGlobalWindow)
    1: NS_IMPL_RELEASE_INHERITED(nsGlobalChromeWindow, nsGlobalWindow)
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::GetWindowState(PRUint16* aWindowState)
    1: {
    1:   *aWindowState = nsIDOMChromeWindow::STATE_NORMAL;
    1: 
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1: 
    1:   PRInt32 aMode = 0;
    1: 
    1:   if (widget) {
    1:     nsresult rv = widget->GetSizeMode(&aMode);
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1:   }
    1: 
    1:   switch (aMode) {
    1:     case nsSizeMode_Minimized:
    1:       *aWindowState = nsIDOMChromeWindow::STATE_MINIMIZED;
    1:       break;
    1:     case nsSizeMode_Maximized:
    1:       *aWindowState = nsIDOMChromeWindow::STATE_MAXIMIZED;
    1:       break;
30075:     case nsSizeMode_Fullscreen:
30075:       *aWindowState = nsIDOMChromeWindow::STATE_FULLSCREEN;
30075:       break;
    1:     case nsSizeMode_Normal:
    1:       *aWindowState = nsIDOMChromeWindow::STATE_NORMAL;
    1:       break;
    1:     default:
    1:       NS_WARNING("Illegal window state for this chrome window");
    1:       break;
    1:   }
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::Maximize()
    1: {
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (widget) {
    1:     rv = widget->SetSizeMode(nsSizeMode_Maximized);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::Minimize()
    1: {
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1:   nsresult rv = NS_OK;
    1: 
30075:   if (widget)
    1:     rv = widget->SetSizeMode(nsSizeMode_Minimized);
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::Restore()
    1: {
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (widget) {
    1:     rv = widget->SetSizeMode(nsSizeMode_Normal);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::GetAttention()
    1: {
    1:   return GetAttentionWithCycleCount(-1);
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::GetAttentionWithCycleCount(PRInt32 aCycleCount)
    1: {
    1:   nsCOMPtr<nsIWidget> widget = GetMainWidget();
    1:   nsresult rv = NS_OK;
    1: 
    1:   if (widget) {
    1:     rv = widget->GetAttention(aCycleCount);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
47857: NS_IMETHODIMP
71258: nsGlobalChromeWindow::BeginWindowMove(nsIDOMEvent *aMouseDownEvent, nsIDOMElement* aPanel)
71258: {
71258:   nsCOMPtr<nsIWidget> widget;
71258: 
71258:   // if a panel was supplied, use its widget instead.
71258: #ifdef MOZ_XUL
71258:   if (aPanel) {
71258:     nsCOMPtr<nsIContent> panel = do_QueryInterface(aPanel);
71258:     NS_ENSURE_TRUE(panel, NS_ERROR_FAILURE);
71258: 
71258:     nsIFrame* frame = panel->GetPrimaryFrame();
71258:     NS_ENSURE_TRUE(frame && frame->GetType() == nsGkAtoms::menuPopupFrame, NS_OK);
71258: 
83107:     widget = (static_cast<nsMenuPopupFrame*>(frame))->GetWidget();
71258:   }
71258:   else {
71258: #endif
71258:     widget = GetMainWidget();
71258: #ifdef MOZ_XUL
71258:   }
71258: #endif
71258: 
47857:   if (!widget) {
47857:     return NS_OK;
47857:   }
47857: 
47857:   nsCOMPtr<nsIPrivateDOMEvent> privEvent = do_QueryInterface(aMouseDownEvent);
47857:   NS_ENSURE_TRUE(privEvent, NS_ERROR_FAILURE);
47857:   nsEvent *internalEvent = privEvent->GetInternalNSEvent();
47857:   NS_ENSURE_TRUE(internalEvent &&
47857:                  internalEvent->eventStructType == NS_MOUSE_EVENT,
47857:                  NS_ERROR_FAILURE);
47857:   nsMouseEvent *mouseEvent = static_cast<nsMouseEvent*>(internalEvent);
47857: 
47857:   return widget->BeginMoveDrag(mouseEvent);
47857: }
47857: 
    1: //Note: This call will lock the cursor, it will not change as it moves.
    1: //To unlock, the cursor must be set back to CURSOR_AUTO.
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::SetCursor(const nsAString& aCursor)
    1: {
    1:   FORWARD_TO_OUTER_CHROME(SetCursor, (aCursor), NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   nsresult rv = NS_OK;
    1:   PRInt32 cursor;
    1: 
    1:   // use C strings to keep the code/data size down
    1:   NS_ConvertUTF16toUTF8 cursorString(aCursor);
    1: 
    1:   if (cursorString.Equals("auto"))
    1:     cursor = NS_STYLE_CURSOR_AUTO;
    1:   else {
    1:     nsCSSKeyword keyword = nsCSSKeywords::LookupKeyword(aCursor);
    1:     if (eCSSKeyword_UNKNOWN == keyword ||
    1:         !nsCSSProps::FindKeyword(keyword, nsCSSProps::kCursorKTable, cursor)) {
    1:       // XXX remove the following three values (leave return NS_OK) after 1.8
    1:       // XXX since they should have been -moz- prefixed (covered by FindKeyword).
    1:       // XXX (also remove |cursorString| at that point?).
    1:       if (cursorString.Equals("grab"))
    1:         cursor = NS_STYLE_CURSOR_GRAB;
    1:       else if (cursorString.Equals("grabbing"))
    1:         cursor = NS_STYLE_CURSOR_GRABBING;
    1:       else if (cursorString.Equals("spinning"))
    1:         cursor = NS_STYLE_CURSOR_SPINNING;
    1:       else
    1:         return NS_OK;
    1:     }
    1:   }
    1: 
39823:   nsRefPtr<nsPresContext> presContext;
    1:   if (mDocShell) {
    1:     mDocShell->GetPresContext(getter_AddRefs(presContext));
    1:   }
    1: 
    1:   if (presContext) {
    1:     // Need root widget.
    1:     nsCOMPtr<nsIPresShell> presShell;
    1:     mDocShell->GetPresShell(getter_AddRefs(presShell));
    1:     NS_ENSURE_TRUE(presShell, NS_ERROR_FAILURE);
    1: 
    1:     nsIViewManager* vm = presShell->GetViewManager();
    1:     NS_ENSURE_TRUE(vm, NS_ERROR_FAILURE);
    1: 
64435:     nsIView* rootView = vm->GetRootView();
    1:     NS_ENSURE_TRUE(rootView, NS_ERROR_FAILURE);
    1: 
30535:     nsIWidget* widget = rootView->GetNearestWidget(nsnull);
    1:     NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
    1: 
    1:     // Call esm and set cursor.
    1:     rv = presContext->EventStateManager()->SetCursor(cursor, nsnull,
80486:                                                      false, 0.0f, 0.0f,
80486:                                                      widget, true);
    1:   }
    1: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::GetBrowserDOMWindow(nsIBrowserDOMWindow **aBrowserWindow)
    1: {
    1:   FORWARD_TO_OUTER_CHROME(GetBrowserDOMWindow, (aBrowserWindow),
    1:                           NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   NS_ENSURE_ARG_POINTER(aBrowserWindow);
    1: 
    1:   *aBrowserWindow = mBrowserDOMWindow;
    1:   NS_IF_ADDREF(*aBrowserWindow);
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP
    1: nsGlobalChromeWindow::SetBrowserDOMWindow(nsIBrowserDOMWindow *aBrowserWindow)
    1: {
    1:   FORWARD_TO_OUTER_CHROME(SetBrowserDOMWindow, (aBrowserWindow),
    1:                           NS_ERROR_NOT_INITIALIZED);
    1: 
    1:   mBrowserDOMWindow = aBrowserWindow;
    1:   return NS_OK;
    1: }
    1: 
30327: NS_IMETHODIMP
30327: nsGlobalChromeWindow::NotifyDefaultButtonLoaded(nsIDOMElement* aDefaultButton)
30327: {
30327: #ifdef MOZ_XUL
30327:   NS_ENSURE_ARG(aDefaultButton);
30327: 
30327:   // Don't snap to a disabled button.
30327:   nsCOMPtr<nsIDOMXULControlElement> xulControl =
30327:                                       do_QueryInterface(aDefaultButton);
30327:   NS_ENSURE_TRUE(xulControl, NS_ERROR_FAILURE);
79445:   bool disabled;
30327:   nsresult rv = xulControl->GetDisabled(&disabled);
30327:   NS_ENSURE_SUCCESS(rv, rv);
30327:   if (disabled)
30327:     return NS_OK;
30327: 
30327:   // Get the button rect in screen coordinates.
30327:   nsCOMPtr<nsIContent> content(do_QueryInterface(aDefaultButton));
30327:   NS_ENSURE_TRUE(content, NS_ERROR_FAILURE);
36657:   nsIFrame *frame = content->GetPrimaryFrame();
30327:   NS_ENSURE_TRUE(frame, NS_ERROR_FAILURE);
30327:   nsIntRect buttonRect = frame->GetScreenRect();
30327: 
30327:   // Get the widget rect in screen coordinates.
30327:   nsIWidget *widget = GetNearestWidget();
30327:   NS_ENSURE_TRUE(widget, NS_ERROR_FAILURE);
30327:   nsIntRect widgetRect;
30327:   rv = widget->GetScreenBounds(widgetRect);
30327:   NS_ENSURE_SUCCESS(rv, rv);
30327: 
30327:   // Convert the buttonRect coordinates from screen to the widget.
30327:   buttonRect -= widgetRect.TopLeft();
30327:   rv = widget->OnDefaultButtonLoaded(buttonRect);
30327:   if (rv == NS_ERROR_NOT_IMPLEMENTED)
30327:     return NS_OK;
30327:   return rv;
30327: #else
30327:   return NS_ERROR_NOT_IMPLEMENTED;
30327: #endif
30327: }
30327: 
42412: NS_IMETHODIMP
42412: nsGlobalChromeWindow::GetMessageManager(nsIChromeFrameMessageManager** aManager)
42412: {
42412:   FORWARD_TO_INNER_CHROME(GetMessageManager, (aManager), NS_ERROR_FAILURE);
42412:   if (!mMessageManager) {
42412:     nsIScriptContext* scx = GetContextInternal();
42412:     NS_ENSURE_STATE(scx);
78415:     JSContext* cx = scx->GetNativeContext();
42412:     NS_ENSURE_STATE(cx);
43461:     nsCOMPtr<nsIChromeFrameMessageManager> globalMM =
43461:       do_GetService("@mozilla.org/globalmessagemanager;1");
43461:     mMessageManager =
80486:       new nsFrameMessageManager(true,
42412:                                 nsnull,
42412:                                 nsnull,
42412:                                 nsnull,
42412:                                 nsnull,
43461:                                 static_cast<nsFrameMessageManager*>(globalMM.get()),
42412:                                 cx);
42412:     NS_ENSURE_TRUE(mMessageManager, NS_ERROR_OUT_OF_MEMORY);
42412:   }
43461:   CallQueryInterface(mMessageManager, aManager);
42412:   return NS_OK;
42412: }
42412: 
 4040: // nsGlobalModalWindow implementation
 4040: 
 4040: // QueryInterface implementation for nsGlobalModalWindow
 4040: NS_IMPL_CYCLE_COLLECTION_CLASS(nsGlobalModalWindow)
 4040: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsGlobalModalWindow,
 4040:                                                   nsGlobalWindow)
31393:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mReturnValue)
 4040: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 4040: 
40490: DOMCI_DATA(ModalContentWindow, nsGlobalModalWindow)
40490: 
 4040: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsGlobalModalWindow)
 4040:   NS_INTERFACE_MAP_ENTRY(nsIDOMModalContentWindow)
55578:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(ModalContentWindow)
 4040: NS_INTERFACE_MAP_END_INHERITING(nsGlobalWindow)
 4040: 
 4040: NS_IMPL_ADDREF_INHERITED(nsGlobalModalWindow, nsGlobalWindow)
 4040: NS_IMPL_RELEASE_INHERITED(nsGlobalModalWindow, nsGlobalWindow)
 4040: 
 4040: 
 4040: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsGlobalModalWindow,
 4040:                                                 nsGlobalWindow)
 4040:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mReturnValue)
 4040: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 4040: 
 4040: 
 4040: NS_IMETHODIMP
 4040: nsGlobalModalWindow::GetDialogArguments(nsIArray **aArguments)
 4040: {
 4040:   FORWARD_TO_INNER_MODAL_CONTENT_WINDOW(GetDialogArguments, (aArguments),
 4040:                                         NS_ERROR_NOT_INITIALIZED);
 4040: 
79445:   bool subsumes = false;
33525:   nsIPrincipal *self = GetPrincipal();
33525:   if (self && NS_SUCCEEDED(self->Subsumes(mArgumentsOrigin, &subsumes)) &&
33525:       subsumes) {
33525:     NS_IF_ADDREF(*aArguments = mArguments);
33525:   } else {
33525:     *aArguments = nsnull;
33525:   }
 4040: 
 4040:   return NS_OK;
 4040: }
 4040: 
 4040: NS_IMETHODIMP
 4040: nsGlobalModalWindow::GetReturnValue(nsIVariant **aRetVal)
 4040: {
 4040:   FORWARD_TO_OUTER_MODAL_CONTENT_WINDOW(GetReturnValue, (aRetVal), NS_OK);
 4040: 
 4040:   NS_IF_ADDREF(*aRetVal = mReturnValue);
 4040: 
 4040:   return NS_OK;
 4040: }
 4040: 
 4040: NS_IMETHODIMP
 4040: nsGlobalModalWindow::SetReturnValue(nsIVariant *aRetVal)
 4040: {
 4040:   FORWARD_TO_OUTER_MODAL_CONTENT_WINDOW(SetReturnValue, (aRetVal), NS_OK);
 4040: 
 4040:   mReturnValue = aRetVal;
 4040: 
 4040:   return NS_OK;
 4040: }
 4040: 
33525: nsresult
33525: nsGlobalModalWindow::SetNewDocument(nsIDocument *aDocument,
53996:                                     nsISupports *aState,
79445:                                     bool aForceReuseInnerWindow)
33525: {
33525:   // If we're loading a new document into a modal dialog, clear the
33525:   // return value that was set, if any, by the current document.
33525:   if (aDocument) {
33525:     mReturnValue = nsnull;
33525:   }
33525: 
53996:   return nsGlobalWindow::SetNewDocument(aDocument, aState,
53996:                                         aForceReuseInnerWindow);
33525: }
33525: 
82604: void
82604: nsGlobalWindow::SetHasAudioAvailableEventListeners()
82604: {
82604:   if (mDoc) {
82604:     mDoc->NotifyAudioAvailableListener();
82604:   }
82604: }
82604: 
    1: //*****************************************************************************
    1: // nsGlobalWindow: Creator Function (This should go away)
    1: //*****************************************************************************
    1: 
    1: nsresult
79445: NS_NewScriptGlobalObject(bool aIsChrome, bool aIsModalContentWindow,
 4040:                          nsIScriptGlobalObject **aResult)
    1: {
    1:   *aResult = nsnull;
    1: 
    1:   nsGlobalWindow *global;
    1: 
    1:   if (aIsChrome) {
    1:     global = new nsGlobalChromeWindow(nsnull);
 4040:   } else if (aIsModalContentWindow) {
 4040:     global = new nsGlobalModalWindow(nsnull);
    1:   } else {
    1:     global = new nsGlobalWindow(nsnull);
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(global, NS_ERROR_OUT_OF_MEMORY);
    1: 
 4040:   NS_ADDREF(*aResult = global);
 4040: 
 4040:   return NS_OK;
    1: }
    1: 
77149: #define EVENT(name_, id_, type_, struct_)                                    \
77149:   NS_IMETHODIMP nsGlobalWindow::GetOn##name_(JSContext *cx,                  \
77149:                                              jsval *vp) {                    \
80486:     nsEventListenerManager *elm = GetListenerManager(false);              \
77149:     if (elm) {                                                               \
77149:       elm->GetJSEventListener(nsGkAtoms::on##name_, vp);                     \
77149:     } else {                                                                 \
77149:       *vp = JSVAL_NULL;                                                      \
77149:     }                                                                        \
77149:     return NS_OK;                                                            \
77149:   }                                                                          \
77149:   NS_IMETHODIMP nsGlobalWindow::SetOn##name_(JSContext *cx,                  \
77149:                                              const jsval &v) {               \
80486:     nsEventListenerManager *elm = GetListenerManager(true);               \
77149:     if (!elm) {                                                              \
77149:       return NS_ERROR_OUT_OF_MEMORY;                                         \
77149:     }                                                                        \
77149:                                                                              \
77149:     JSObject *obj = mJSObject;                                               \
77149:     if (!obj) {                                                              \
77149:       return NS_ERROR_UNEXPECTED;                                            \
77149:     }                                                                        \
77149:     return elm->SetJSEventListenerToJsval(nsGkAtoms::on##name_, cx, obj, v); \
77149:   }
77149: #define WINDOW_ONLY_EVENT EVENT
77149: #define TOUCH_EVENT EVENT
77149: #include "nsEventNameList.h"
77149: #undef TOUCH_EVENT
77149: #undef WINDOW_ONLY_EVENT
77149: #undef EVENT
77149: 
