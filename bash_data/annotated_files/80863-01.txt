27961: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
27961: /* vim:set ts=2 sts=2 sw=2 et cin: */
27961: /* ***** BEGIN LICENSE BLOCK *****
27961:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
27961:  *
27961:  * The contents of this file are subject to the Mozilla Public License Version
27961:  * 1.1 (the "License"); you may not use this file except in compliance with
27961:  * the License. You may obtain a copy of the License at
27961:  * http://www.mozilla.org/MPL/
27961:  *
27961:  * Software distributed under the License is distributed on an "AS IS" basis,
27961:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
27961:  * for the specific language governing rights and limitations under the
27961:  * License.
27961:  *
27961:  * The Original Code is mozilla.org code.
27961:  *
27961:  * The Initial Developer of the Original Code is
27961:  * Netscape Communications Corporation.
27961:  * Portions created by the Initial Developer are Copyright (C) 1998
27961:  * the Initial Developer. All Rights Reserved.
27961:  *
27961:  * Contributor(s):
27961:  *   Masayuki Nakano <masayuki@d-toybox.com>
27961:  *
27961:  * Original nsWindow.cpp Contributor(s):
27961:  *   Dean Tessman <dean_tessman@hotmail.com>
27961:  *   Ere Maijala <ere@atp.fi>
27961:  *   Mark Hammond <markh@activestate.com>
27961:  *   Michael Lowe <michael.lowe@bigfoot.com>
27961:  *   Peter Bajusz <hyp-x@inf.bme.hu>
27961:  *   Pierre Phaneuf <pp@ludusdesign.com>
27961:  *   Robert O'Callahan <roc+moz@cs.cmu.edu>
27961:  *   Roy Yokoyama <yokoyama@netscape.com>
27961:  *   Makoto Kato  <m_kato@ga2.so-net.ne.jp>
27961:  *   Masayuki Nakano <masayuki@d-toybox.com>
27961:  *   Dainis Jonitis <Dainis_Jonitis@swh-t.lv>
27961:  *   Christian Biesinger <cbiesinger@web.de>
27961:  *   Mats Palmgren <mats.palmgren@bredband.net>
27961:  *   Ningjie Chen <chenn@email.uc.edu>
27961:  *
27961:  * Alternatively, the contents of this file may be used under the terms of
27961:  * either the GNU General Public License Version 2 or later (the "GPL"), or
27961:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
27961:  * in which case the provisions of the GPL or the LGPL are applicable instead
27961:  * of those above. If you wish to allow use of your version of this file only
27961:  * under the terms of either the GPL or the LGPL, and not to allow others to
27961:  * use your version of this file under the terms of the MPL, indicate your
27961:  * decision by deleting the provisions above and replace them with the notice
27961:  * and other provisions required by the GPL or the LGPL. If you do not delete
27961:  * the provisions above, a recipient may use your version of this file under
27961:  * the terms of any one of the MPL, the GPL or the LGPL.
27961:  *
27961:  * ***** END LICENSE BLOCK ***** */
27961: 
27961: #ifdef MOZ_LOGGING
27961: #define FORCE_PR_LOG /* Allow logging in the release build */
27961: #endif // MOZ_LOGGING
27961: #include "prlog.h"
27961: 
27961: #include "nsIMM32Handler.h"
27961: #include "nsWindow.h"
27961: 
27961: static nsIMM32Handler* gIMM32Handler = nsnull;
27961: 
27961: #ifdef PR_LOGGING
27961: PRLogModuleInfo* gIMM32Log = nsnull;
27961: #endif
27961: 
27961: static UINT sWM_MSIME_MOUSE = 0; // mouse message for MSIME 98/2000
29318: 
29318: //-------------------------------------------------------------------------
29318: //
29318: // from http://download.microsoft.com/download/6/0/9/60908e9e-d2c1-47db-98f6-216af76a235f/msime.h
29318: // The document for this has been removed from MSDN...
29318: //
29318: //-------------------------------------------------------------------------
29318: 
29318: #define RWM_MOUSE           TEXT("MSIMEMouseOperation")
29318: 
29318: #define IMEMOUSE_NONE       0x00    // no mouse button was pushed
29318: #define IMEMOUSE_LDOWN      0x01
29318: #define IMEMOUSE_RDOWN      0x02
29318: #define IMEMOUSE_MDOWN      0x04
29318: #define IMEMOUSE_WUP        0x10    // wheel up
29318: #define IMEMOUSE_WDOWN      0x20    // wheel down
29318: 
79445: bool nsIMM32Handler::sIsStatusChanged = false;
79445: bool nsIMM32Handler::sIsIME = true;
79445: bool nsIMM32Handler::sIsIMEOpening = false;
28059: 
28059: UINT nsIMM32Handler::sCodePage = 0;
28059: DWORD nsIMM32Handler::sIMEProperty = 0;
27961: 
27961: /* static */ void
27961: nsIMM32Handler::EnsureHandlerInstance()
27961: {
27961:   if (!gIMM32Handler) {
27961:     gIMM32Handler = new nsIMM32Handler();
27961:   }
27961: }
27961: 
27961: /* static */ void
27961: nsIMM32Handler::Initialize()
27961: {
28059: #ifdef PR_LOGGING
28059:   if (!gIMM32Log)
28059:     gIMM32Log = PR_NewLogModule("nsIMM32HandlerWidgets");
28059: #endif
28059: 
27961:   if (!sWM_MSIME_MOUSE) {
27961:     sWM_MSIME_MOUSE = ::RegisterWindowMessage(RWM_MOUSE);
27961:   }
28059:   InitKeyboardLayout(::GetKeyboardLayout(0));
27961: }
27961: 
27961: /* static */ void
27961: nsIMM32Handler::Terminate()
27961: {
27961:   if (!gIMM32Handler)
27961:     return;
27961:   delete gIMM32Handler;
27961:   gIMM32Handler = nsnull;
27961: }
27961: 
79445: /* static */ bool
49149: nsIMM32Handler::IsComposingOnOurEditor()
27961: {
49149:   return gIMM32Handler && gIMM32Handler->mIsComposing;
49149: }
49149: 
79445: /* static */ bool
49149: nsIMM32Handler::IsComposingOnPlugin()
49149: {
49149:   return gIMM32Handler && gIMM32Handler->mIsComposingOnPlugin;
49149: }
49149: 
79445: /* static */ bool
49149: nsIMM32Handler::IsComposingWindow(nsWindow* aWindow)
49149: {
49149:   return gIMM32Handler && gIMM32Handler->mComposingWindow == aWindow;
49149: }
49149: 
79445: /* static */ bool
49149: nsIMM32Handler::IsTopLevelWindowOfComposition(nsWindow* aWindow)
49149: {
49149:   if (!gIMM32Handler || !gIMM32Handler->mComposingWindow) {
79626:     return false;
49149:   }
49149:   HWND wnd = gIMM32Handler->mComposingWindow->GetWindowHandle();
79626:   return nsWindow::GetTopLevelHWND(wnd, true) == aWindow->GetWindowHandle();
27961: }
27961: 
79445: /* static */ bool
27961: nsIMM32Handler::IsDoingKakuteiUndo(HWND aWnd)
27961: {
27961:   // This message pattern is "Kakutei-Undo" on ATOK and WXG.
27961:   // In this case, the message queue has following messages:
27961:   // ---------------------------------------------------------------------------
27961:   // WM_KEYDOWN              * n (wParam = VK_BACK, lParam = 0x1)
27961:   // WM_KEYUP                * 1 (wParam = VK_BACK, lParam = 0xC0000001) # ATOK
27961:   // WM_IME_STARTCOMPOSITION * 1 (wParam = 0x0, lParam = 0x0)
27961:   // WM_IME_COMPOSITION      * 1 (wParam = 0x0, lParam = 0x1BF)
27961:   // WM_CHAR                 * n (wParam = VK_BACK, lParam = 0x1)
27961:   // WM_KEYUP                * 1 (wParam = VK_BACK, lParam = 0xC00E0001)
27961:   // ---------------------------------------------------------------------------
27961:   // This message pattern does not match to the above case;
27961:   // i.e.,WM_KEYDOWN -> WM_CHAR -> WM_KEYDOWN -> WM_CHAR.
27961:   // For more information of this problem:
27961:   // https://bugzilla.mozilla.gr.jp/show_bug.cgi?id=2885 (written in Japanese)
27961:   // https://bugzilla.mozilla.org/show_bug.cgi?id=194559 (written in English)
27961:   MSG imeStartCompositionMsg, imeCompositionMsg, charMsg;
27961:   return ::PeekMessageW(&imeStartCompositionMsg, aWnd,
27961:                         WM_IME_STARTCOMPOSITION, WM_IME_STARTCOMPOSITION,
27961:                         PM_NOREMOVE | PM_NOYIELD) &&
27961:          ::PeekMessageW(&imeCompositionMsg, aWnd, WM_IME_COMPOSITION,
27961:                         WM_IME_COMPOSITION, PM_NOREMOVE | PM_NOYIELD) &&
27961:          ::PeekMessageW(&charMsg, aWnd, WM_CHAR, WM_CHAR,
27961:                         PM_NOREMOVE | PM_NOYIELD) &&
27961:          imeStartCompositionMsg.wParam == 0x0 &&
27961:          imeStartCompositionMsg.lParam == 0x0 &&
27961:          imeCompositionMsg.wParam == 0x0 &&
27961:          imeCompositionMsg.lParam == 0x1BF &&
27961:          charMsg.wParam == VK_BACK && charMsg.lParam == 0x1 &&
27961:          imeStartCompositionMsg.time <= imeCompositionMsg.time &&
27961:          imeCompositionMsg.time <= charMsg.time;
27961: }
27961: 
79445: /* static */ bool
28059: nsIMM32Handler::ShouldDrawCompositionStringOurselves()
28059: {
28059:   // If current IME has special UI or its composition window should not
28059:   // positioned to caret position, we should now draw composition string
28059:   // ourselves.
28059:   return !(sIMEProperty & IME_PROP_SPECIAL_UI) &&
28059:           (sIMEProperty & IME_PROP_AT_CARET);
28059: }
28059: 
27961: /* static */ void
28059: nsIMM32Handler::InitKeyboardLayout(HKL aKeyboardLayout)
27961: {
28059:   WORD langID = LOWORD(aKeyboardLayout);
28059:   ::GetLocaleInfoW(MAKELCID(langID, SORT_DEFAULT),
28059:                    LOCALE_IDEFAULTANSICODEPAGE | LOCALE_RETURN_NUMBER,
28059:                    (PWSTR)&sCodePage, sizeof(sCodePage) / sizeof(WCHAR));
28059:   sIMEProperty = ::ImmGetProperty(aKeyboardLayout, IGP_PROPERTY);
43005:   sIsIME = ::ImmIsIME(aKeyboardLayout);
28059:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
43005:     ("IMM32: InitKeyboardLayout, aKeyboardLayout=%08x, sCodePage=%lu, sIMEProperty=%08x sIsIME=%s\n",
43005:      aKeyboardLayout, sCodePage, sIMEProperty, sIsIME ? "TRUE" : "FALSE"));
27961: }
27961: 
28059: /* static */ UINT
28059: nsIMM32Handler::GetKeyboardCodePage()
28059: {
28059:   return sCodePage;
28059: }
28059: 
79445: /* static */ bool
43005: nsIMM32Handler::CanOptimizeKeyAndIMEMessages(MSG *aNextKeyOrIMEMessage)
43005: {
43005:   // If IME is opening right now, we shouldn't optimize the key and IME message
43005:   // order because ATOK (Japanese IME of third party) has some problem with the
43005:   // optimization.  When it finishes opening completely, it eats all key
43005:   // messages in the message queue.  And it causes starting composition.  So,
43005:   // we shouldn't eat the key messages before ATOK.
43005:   return !sIsIMEOpening;
43005: }
43005: 
28059: 
27961: // used for checking the lParam of WM_IME_COMPOSITION
27961: #define IS_COMPOSING_LPARAM(lParam) \
27961:   ((lParam) & (GCS_COMPSTR | GCS_COMPATTR | GCS_COMPCLAUSE | GCS_CURSORPOS))
27961: #define IS_COMMITTING_LPARAM(lParam) ((lParam) & GCS_RESULTSTR)
27961: // Some IMEs (e.g., the standard IME for Korean) don't have caret position,
27961: // then, we should not set caret position to text event.
27961: #define NO_IME_CARET -1
27961: 
27961: nsIMM32Handler::nsIMM32Handler() :
49149:   mComposingWindow(nsnull), mCursorPosition(NO_IME_CARET), mCompositionStart(0),
79626:   mIsComposing(false), mIsComposingOnPlugin(false),
79626:   mNativeCaretIsCreated(false)
27961: {
28059:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS, ("IMM32: nsIMM32Handler is created\n"));
27961: }
27961: 
27961: nsIMM32Handler::~nsIMM32Handler()
27961: {
27961:   if (mIsComposing) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: ~nsIMM32Handler, ERROR, the instance is still composing\n"));
27961:   }
28059:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS, ("IMM32: nsIMM32Handler is destroyed\n"));
27961: }
27961: 
27961: nsresult
27961: nsIMM32Handler::EnsureClauseArray(PRInt32 aCount)
27961: {
27961:   NS_ENSURE_ARG_MIN(aCount, 0);
27961:   if (!mClauseArray.SetCapacity(aCount + 32)) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: EnsureClauseArray, aCount=%ld, FAILED to allocate\n",
27961:        aCount));
27961:     return NS_ERROR_OUT_OF_MEMORY;
27961:   }
27961:   return NS_OK;
27961: }
27961: 
27961: nsresult
27961: nsIMM32Handler::EnsureAttributeArray(PRInt32 aCount)
27961: {
27961:   NS_ENSURE_ARG_MIN(aCount, 0);
27961:   if (!mAttributeArray.SetCapacity(aCount + 64)) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: EnsureAttributeArray, aCount=%ld, FAILED to allocate\n",
27961:        aCount));
27961:     return NS_ERROR_OUT_OF_MEMORY;
27961:   }
27961:   return NS_OK;
27961: }
27961: 
49149: /* static */ void
79445: nsIMM32Handler::CommitComposition(nsWindow* aWindow, bool aForce)
49149: {
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: CommitComposition, aForce=%s, aWindow=%p, hWnd=%08x, mComposingWindow=%p%s\n",
49149:      aForce ? "TRUE" : "FALSE",
49149:      aWindow, aWindow->GetWindowHandle(),
49149:      gIMM32Handler ? gIMM32Handler->mComposingWindow : nsnull,
49149:      gIMM32Handler && gIMM32Handler->mComposingWindow ?
49149:        IsComposingOnOurEditor() ? " (composing on editor)" :
49149:                                   " (composing on plug-in)" : ""));
49149:   if (!aForce && !IsComposingWindow(aWindow)) {
49149:     return;
49149:   }
73536: 
79445:   bool associated = aWindow->AssociateDefaultIMC(true);
73536:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
73536:     ("IMM32: CommitComposition, associated=%s\n",
73536:      associated ? "YES" : "NO"));
73536: 
49149:   nsIMEContext IMEContext(aWindow->GetWindowHandle());
49149:   if (IMEContext.IsValid()) {
51212:     ::ImmNotifyIME(IMEContext.get(), NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
51212:     ::ImmNotifyIME(IMEContext.get(), NI_COMPOSITIONSTR, CPS_CANCEL, 0);
49149:   }
73536: 
73536:   if (associated) {
79626:     aWindow->AssociateDefaultIMC(false);
73536:   }
49149: }
49149: 
49149: /* static */ void
79445: nsIMM32Handler::CancelComposition(nsWindow* aWindow, bool aForce)
49149: {
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: CancelComposition, aForce=%s, aWindow=%p, hWnd=%08x, mComposingWindow=%p%s\n",
49149:      aForce ? "TRUE" : "FALSE",
49149:      aWindow, aWindow->GetWindowHandle(),
49149:      gIMM32Handler ? gIMM32Handler->mComposingWindow : nsnull,
49149:      gIMM32Handler && gIMM32Handler->mComposingWindow ?
49149:        IsComposingOnOurEditor() ? " (composing on editor)" :
49149:                                   " (composing on plug-in)" : ""));
49149:   if (!aForce && !IsComposingWindow(aWindow)) {
49149:     return;
49149:   }
73536: 
79445:   bool associated = aWindow->AssociateDefaultIMC(true);
73536:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
73536:     ("IMM32: CancelComposition, associated=%s\n",
73536:      associated ? "YES" : "NO"));
73536: 
49149:   nsIMEContext IMEContext(aWindow->GetWindowHandle());
49149:   if (IMEContext.IsValid()) {
51212:     ::ImmNotifyIME(IMEContext.get(), NI_COMPOSITIONSTR, CPS_CANCEL, 0);
49149:   }
73536: 
73536:   if (associated) {
79626:     aWindow->AssociateDefaultIMC(false);
73536:   }
49149: }
49149: 
79445: /* static */ bool
49149: nsIMM32Handler::ProcessInputLangChangeMessage(nsWindow* aWindow,
49149:                                               WPARAM wParam,
49149:                                               LPARAM lParam,
49149:                                               LRESULT *aRetValue,
79445:                                               bool &aEatMessage)
49149: {
49149:   *aRetValue = 0;
79626:   aEatMessage = false;
49149:   // We don't need to create the instance of the handler here.
49149:   if (gIMM32Handler) {
49149:     aEatMessage = gIMM32Handler->OnInputLangChange(aWindow, wParam, lParam);
49149:   }
49149:   InitKeyboardLayout(reinterpret_cast<HKL>(lParam));
49149:   // We can release the instance here, because the instance may be never
49149:   // used. E.g., the new keyboard layout may not use IME, or it may use TSF.
49149:   Terminate();
49149:   // Don't return as "processed", the messages should be processed on nsWindow
49149:   // too.
79626:   return false;
49149: }
49149: 
79445: /* static */ bool
27961: nsIMM32Handler::ProcessMessage(nsWindow* aWindow, UINT msg,
27961:                                WPARAM &wParam, LPARAM &lParam,
79445:                                LRESULT *aRetValue, bool &aEatMessage)
27961: {
49149:   // XXX We store the composing window in mComposingWindow.  If IME messages are
27961:   // sent to different window, we should commit the old transaction.  And also
27961:   // if the new window handle is not focused, probably, we should not start
27961:   // the composition, however, such case should not be, it's just bad scenario.
27961: 
43005:   if (sIsIMEOpening) {
43005:     switch (msg) {
43005:       case WM_INPUTLANGCHANGE:
43005:       case WM_IME_STARTCOMPOSITION:
43005:       case WM_IME_COMPOSITION:
43005:       case WM_IME_ENDCOMPOSITION:
43005:       case WM_IME_CHAR:
43005:       case WM_IME_SELECT:
43005:       case WM_IME_SETCONTEXT:
43005:         // For safety, we should reset sIsIMEOpening when we receive unexpected
43005:         // message.
79626:         sIsIMEOpening = false;
43005:     }
43005:   }
43005: 
49149:   // When a plug-in has focus or compsition, we should dispatch the IME events
49149:   // to the plug-in.
49149:   if (aWindow->PluginHasFocus() || IsComposingOnPlugin()) {
27961:       return ProcessMessageForPlugin(aWindow, msg, wParam, lParam, aRetValue,
27961:                                    aEatMessage);
27961:   }
27961: 
27961:   *aRetValue = 0;
27961:   switch (msg) {
27961:     case WM_LBUTTONDOWN:
27961:     case WM_MBUTTONDOWN:
27961:     case WM_RBUTTONDOWN: {
27961:       // We don't need to create the instance of the handler here.
27961:       if (!gIMM32Handler)
79626:         return false;
27961:       if (!gIMM32Handler->OnMouseEvent(aWindow, lParam,
27961:                             msg == WM_LBUTTONDOWN ? IMEMOUSE_LDOWN :
27961:                             msg == WM_MBUTTONDOWN ? IMEMOUSE_MDOWN :
27961:                                                     IMEMOUSE_RDOWN)) {
79626:         return false;
27961:       }
79626:       aEatMessage = false;
79626:       return true;
27961:     }
27961:     case WM_INPUTLANGCHANGE:
49149:       return ProcessInputLangChangeMessage(aWindow, wParam, lParam,
49149:                                            aRetValue, aEatMessage);
27961:     case WM_IME_STARTCOMPOSITION:
27961:       EnsureHandlerInstance();
27961:       aEatMessage = gIMM32Handler->OnIMEStartComposition(aWindow);
79626:       return true;
27961:     case WM_IME_COMPOSITION:
27961:       EnsureHandlerInstance();
27961:       aEatMessage = gIMM32Handler->OnIMEComposition(aWindow, wParam, lParam);
79626:       return true;
27961:     case WM_IME_ENDCOMPOSITION:
27961:       EnsureHandlerInstance();
27961:       aEatMessage = gIMM32Handler->OnIMEEndComposition(aWindow);
79626:       return true;
27961:     case WM_IME_CHAR:
28059:       aEatMessage = OnIMEChar(aWindow, wParam, lParam);
79626:       return true;
27961:     case WM_IME_NOTIFY:
28059:       aEatMessage = OnIMENotify(aWindow, wParam, lParam);
79626:       return true;
27961:     case WM_IME_REQUEST:
27961:       EnsureHandlerInstance();
27961:       aEatMessage =
27961:         gIMM32Handler->OnIMERequest(aWindow, wParam, lParam, aRetValue);
79626:       return true;
27961:     case WM_IME_SELECT:
28059:       aEatMessage = OnIMESelect(aWindow, wParam, lParam);
79626:       return true;
27961:     case WM_IME_SETCONTEXT:
49149:       aEatMessage = OnIMESetContext(aWindow, wParam, lParam, aRetValue);
79626:       return true;
43005:     case WM_KEYDOWN:
43005:       return OnKeyDownEvent(aWindow, wParam, lParam, aEatMessage);
49149:     case WM_CHAR:
49149:       if (!gIMM32Handler) {
79626:         return false;
49149:       }
49149:       aEatMessage = gIMM32Handler->OnChar(aWindow, wParam, lParam);
49149:       // If we eat this message, we should return "processed", otherwise,
49149:       // the message should be handled on nsWindow, so, we should return
49149:       // "not processed" at that time.
49149:       return aEatMessage;
27961:     default:
79626:       return false;
27961:   };
27961: }
27961: 
79445: /* static */ bool
27961: nsIMM32Handler::ProcessMessageForPlugin(nsWindow* aWindow, UINT msg,
27961:                                         WPARAM &wParam, LPARAM &lParam,
27961:                                         LRESULT *aRetValue,
79445:                                         bool &aEatMessage)
27961: {
27961:   *aRetValue = 0;
79626:   aEatMessage = false;
27961:   switch (msg) {
49149:     case WM_INPUTLANGCHANGEREQUEST:
49149:     case WM_INPUTLANGCHANGE:
79626:       aWindow->DispatchPluginEvent(msg, wParam, lParam, false);
49149:       return ProcessInputLangChangeMessage(aWindow, wParam, lParam,
49149:                                            aRetValue, aEatMessage);
27961:     case WM_IME_COMPOSITION:
49149:       EnsureHandlerInstance();
49149:       aEatMessage =
49149:         gIMM32Handler->OnIMECompositionOnPlugin(aWindow, wParam, lParam);
79626:       return true;
27961:     case WM_IME_STARTCOMPOSITION:
49149:       EnsureHandlerInstance();
49149:       aEatMessage =
49149:         gIMM32Handler->OnIMEStartCompositionOnPlugin(aWindow, wParam, lParam);
79626:       return true;
27961:     case WM_IME_ENDCOMPOSITION:
49149:       EnsureHandlerInstance();
49149:       aEatMessage =
49149:         gIMM32Handler->OnIMEEndCompositionOnPlugin(aWindow, wParam, lParam);
79626:       return true;
49149:     case WM_IME_CHAR:
49149:       EnsureHandlerInstance();
49149:       aEatMessage =
49149:         gIMM32Handler->OnIMECharOnPlugin(aWindow, wParam, lParam);
79626:       return true;
49149:     case WM_IME_SETCONTEXT:
49149:       aEatMessage = OnIMESetContextOnPlugin(aWindow, wParam, lParam, aRetValue);
79626:       return true;
43005:     case WM_IME_NOTIFY:
43005:       if (wParam == IMN_SETOPENSTATUS) {
43005:         // finished being opening
79626:         sIsIMEOpening = false;
43005:       }
79626:       return false;
43005:     case WM_KEYDOWN:
43005:       if (wParam == VK_PROCESSKEY) {
43005:         // If we receive when IME isn't open, it means IME is opening right now.
43005:         nsIMEContext IMEContext(aWindow->GetWindowHandle());
43005:         sIsIMEOpening = IMEContext.IsValid() &&
43005:                         ::ImmGetOpenStatus(IMEContext.get());
43005:       }
79626:       return false;
49149:     case WM_CHAR:
49149:       if (!gIMM32Handler) {
79626:         return false;
49149:       }
49149:       aEatMessage =
49149:         gIMM32Handler->OnCharOnPlugin(aWindow, wParam, lParam);
79626:       return false;  // is going to be handled by nsWindow.
49149:     case WM_IME_COMPOSITIONFULL:
49149:     case WM_IME_CONTROL:
49149:     case WM_IME_KEYDOWN:
49149:     case WM_IME_KEYUP:
49149:     case WM_IME_REQUEST:
49149:     case WM_IME_SELECT:
79626:       aEatMessage = aWindow->DispatchPluginEvent(msg, wParam, lParam, false);
79626:       return true;
27961:   }
79626:   return false;
27961: }
27961: 
49149: /****************************************************************************
49149:  * message handlers
49149:  ****************************************************************************/
49149: 
79445: bool
27961: nsIMM32Handler::OnInputLangChange(nsWindow* aWindow,
27961:                                   WPARAM wParam,
27961:                                   LPARAM lParam)
27961: {
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: OnInputLangChange, hWnd=%08x, wParam=%08x, lParam=%08x\n",
27961:      aWindow->GetWindowHandle(), wParam, lParam));
27961: 
27961:   aWindow->ResetInputState();
27961:   NS_ASSERTION(!mIsComposing, "ResetInputState failed");
27961: 
27961:   if (mIsComposing) {
27961:     HandleEndComposition(aWindow);
27961:   }
27961: 
79626:   return false;
27961: }
27961: 
79445: bool
27961: nsIMM32Handler::OnIMEStartComposition(nsWindow* aWindow)
27961: {
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: OnIMEStartComposition, hWnd=%08x, mIsComposing=%s\n",
27961:      aWindow->GetWindowHandle(), mIsComposing ? "TRUE" : "FALSE"));
27961:   if (mIsComposing) {
48294:     NS_WARNING("Composition has been already started");
27961:     return ShouldDrawCompositionStringOurselves();
27961:   }
27961: 
27961:   nsIMEContext IMEContext(aWindow->GetWindowHandle());
27961:   HandleStartComposition(aWindow, IMEContext);
27961:   return ShouldDrawCompositionStringOurselves();
27961: }
27961: 
79445: bool
27961: nsIMM32Handler::OnIMEComposition(nsWindow* aWindow,
27961:                                  WPARAM wParam,
27961:                                  LPARAM lParam)
27961: {
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: OnIMEComposition, hWnd=%08x, lParam=%08x, mIsComposing=%s\n",
27961:      aWindow->GetWindowHandle(), lParam, mIsComposing ? "TRUE" : "FALSE"));
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: OnIMEComposition, GCS_RESULTSTR=%s, GCS_COMPSTR=%s, GCS_COMPATTR=%s, GCS_COMPCLAUSE=%s, GCS_CURSORPOS=%s\n",
27961:      lParam & GCS_RESULTSTR  ? "YES" : "no",
27961:      lParam & GCS_COMPSTR    ? "YES" : "no",
27961:      lParam & GCS_COMPATTR   ? "YES" : "no",
27961:      lParam & GCS_COMPCLAUSE ? "YES" : "no",
27961:      lParam & GCS_CURSORPOS  ? "YES" : "no"));
27961: 
27961:   NS_PRECONDITION(!aWindow->PluginHasFocus(),
27961:     "OnIMEComposition should not be called when a plug-in has focus");
27961: 
27961:   nsIMEContext IMEContext(aWindow->GetWindowHandle());
27961:   return HandleComposition(aWindow, IMEContext, lParam);
27961: }
27961: 
79445: bool
27961: nsIMM32Handler::OnIMEEndComposition(nsWindow* aWindow)
27961: {
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: OnIMEEndComposition, hWnd=%08x, mIsComposing=%s\n",
27961:      aWindow->GetWindowHandle(), mIsComposing ? "TRUE" : "FALSE"));
27961: 
27961:   if (!mIsComposing) {
27961:     return ShouldDrawCompositionStringOurselves();
27961:   }
27961: 
27961:   // IME on Korean NT somehow send WM_IME_ENDCOMPOSITION
27961:   // first when we hit space in composition mode
27961:   // we need to clear out the current composition string
27961:   // in that case.
27961:   mCompositionString.Truncate();
27961: 
27961:   nsIMEContext IMEContext(aWindow->GetWindowHandle());
79626:   DispatchTextEvent(aWindow, IMEContext, false);
27961: 
27961:   HandleEndComposition(aWindow);
27961: 
27961:   return ShouldDrawCompositionStringOurselves();
27961: }
27961: 
79445: /* static */ bool
27961: nsIMM32Handler::OnIMEChar(nsWindow* aWindow,
27961:                           WPARAM wParam,
27961:                           LPARAM lParam)
27961: {
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: OnIMEChar, hWnd=%08x, char=%08x\n",
27961:      aWindow->GetWindowHandle(), wParam));
27961: 
27961:   // We don't need to fire any text events from here. This method will be
27961:   // called when the composition string of the current IME is not drawn by us
27961:   // and some characters are committed. In that case, the committed string was
27961:   // processed in nsWindow::OnIMEComposition already.
27961: 
27961:   // We need to return TRUE here so that Windows don't send two WM_CHAR msgs
79626:   return true;
27961: }
27961: 
79445: /* static */ bool
27961: nsIMM32Handler::OnIMECompositionFull(nsWindow* aWindow)
27961: {
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: OnIMECompositionFull, hWnd=%08x\n",
27961:      aWindow->GetWindowHandle()));
27961: 
27961:   // not implement yet
79626:   return false;
27961: }
27961: 
79445: /* static */ bool
27961: nsIMM32Handler::OnIMENotify(nsWindow* aWindow,
27961:                             WPARAM wParam,
27961:                             LPARAM lParam)
27961: {
27961: #ifdef PR_LOGGING
27961:   switch (wParam) {
27961:     case IMN_CHANGECANDIDATE:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_CHANGECANDIDATE, lParam=%08x\n",
27961:          aWindow->GetWindowHandle(), lParam));
27961:       break;
27961:     case IMN_CLOSECANDIDATE:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_CLOSECANDIDATE, lParam=%08x\n",
27961:          aWindow->GetWindowHandle(), lParam));
27961:       break;
27961:     case IMN_CLOSESTATUSWINDOW:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_CLOSESTATUSWINDOW\n",
27961:          aWindow->GetWindowHandle()));
27961:       break;
27961:     case IMN_GUIDELINE:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_GUIDELINE\n",
27961:          aWindow->GetWindowHandle()));
27961:       break;
27961:     case IMN_OPENCANDIDATE:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_OPENCANDIDATE, lParam=%08x\n",
27961:          aWindow->GetWindowHandle(), lParam));
27961:       break;
27961:     case IMN_OPENSTATUSWINDOW:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_OPENSTATUSWINDOW\n",
27961:          aWindow->GetWindowHandle()));
27961:       break;
27961:     case IMN_SETCANDIDATEPOS:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_SETCANDIDATEPOS, lParam=%08x\n",
27961:          aWindow->GetWindowHandle(), lParam));
27961:       break;
27961:     case IMN_SETCOMPOSITIONFONT:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_SETCOMPOSITIONFONT\n",
27961:          aWindow->GetWindowHandle()));
27961:       break;
27961:     case IMN_SETCOMPOSITIONWINDOW:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_SETCOMPOSITIONWINDOW\n",
27961:          aWindow->GetWindowHandle()));
27961:       break;
27961:     case IMN_SETCONVERSIONMODE:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_SETCONVERSIONMODE\n",
27961:          aWindow->GetWindowHandle()));
27961:       break;
27961:     case IMN_SETOPENSTATUS:
79626:       sIsIMEOpening = false;
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_SETOPENSTATUS\n",
27961:          aWindow->GetWindowHandle()));
27961:       break;
27961:     case IMN_SETSENTENCEMODE:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_SETSENTENCEMODE\n",
27961:          aWindow->GetWindowHandle()));
27961:       break;
27961:     case IMN_SETSTATUSWINDOWPOS:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_SETSTATUSWINDOWPOS\n",
27961:          aWindow->GetWindowHandle()));
27961:       break;
27961:     case IMN_PRIVATE:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMENotify, hWnd=%08x, IMN_PRIVATE\n",
27961:          aWindow->GetWindowHandle()));
27961:       break;
27961:   }
27961: #endif // PR_LOGGING
27961: 
28059:   if (::GetKeyState(NS_VK_ALT) >= 0) {
79626:     return false;
27961:   }
27961: 
27961:   // XXXmnakano Following code was added by bug 28852 (Key combo to trun ON/OFF
27961:   // Japanese IME incorrectly activates "File" menu).  If one or more keypress
27961:   // events come between Alt keydown event and Alt keyup event, XUL menubar
27961:   // isn't activated by the Alt keyup event.  Therefore, this code sends dummy
27961:   // keypress event to Gecko.  But this is ugly, and this fires incorrect DOM
27961:   // keypress event.  So, we should find another way for the bug.
27961: 
27961:   // add hacky code here
79626:   nsModifierKeyState modKeyState(false, false, true);
27961:   aWindow->DispatchKeyEvent(NS_KEY_PRESS, 0, nsnull, 192, nsnull, modKeyState);
28059:   sIsStatusChanged = sIsStatusChanged || (wParam == IMN_SETOPENSTATUS);
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
28059:     ("IMM32: OnIMENotify, sIsStatusChanged=%s\n",
28059:      sIsStatusChanged ? "TRUE" : "FALSE"));
27961: 
27961:   // not implement yet
79626:   return false;
27961: }
27961: 
79445: bool
27961: nsIMM32Handler::OnIMERequest(nsWindow* aWindow,
27961:                              WPARAM wParam,
27961:                              LPARAM lParam,
27961:                              LRESULT *oResult)
27961: {
27961:   switch (wParam) {
27961:     case IMR_RECONVERTSTRING:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMERequest, hWnd=%08x, IMR_RECONVERTSTRING\n",
27961:          aWindow->GetWindowHandle()));
27961:       return HandleReconvert(aWindow, lParam, oResult);
27961:     case IMR_QUERYCHARPOSITION:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMERequest, hWnd=%08x, IMR_QUERYCHARPOSITION\n",
27961:          aWindow->GetWindowHandle()));
27961:       return HandleQueryCharPosition(aWindow, lParam, oResult);
36322:     case IMR_DOCUMENTFEED:
36322:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:         ("IMM32: OnIMERequest, hWnd=%08x, IMR_DOCUMENTFEED\n",
36322:          aWindow->GetWindowHandle()));
36322:       return HandleDocumentFeed(aWindow, lParam, oResult);
27961:     default:
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: OnIMERequest, hWnd=%08x, wParam=%08x\n",
27961:          aWindow->GetWindowHandle(), wParam));
79626:       return false;
27961:   }
27961: }
27961: 
79445: /* static */ bool
27961: nsIMM32Handler::OnIMESelect(nsWindow* aWindow,
27961:                             WPARAM wParam,
27961:                             LPARAM lParam)
27961: {
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: OnIMESelect, hWnd=%08x, wParam=%08x, lParam=%08x\n",
27961:      aWindow->GetWindowHandle(), wParam, lParam));
27961: 
27961:   // not implement yet
79626:   return false;
27961: }
27961: 
79445: /* static */ bool
27961: nsIMM32Handler::OnIMESetContext(nsWindow* aWindow,
27961:                                 WPARAM wParam,
49149:                                 LPARAM lParam,
49149:                                 LRESULT *aResult)
27961: {
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: OnIMESetContext, hWnd=%08x, %s, lParam=%08x\n",
27961:      aWindow->GetWindowHandle(), wParam ? "Active" : "Deactive", lParam));
27961: 
49149:   // NOTE: If the aWindow is top level window of the composing window because
49149:   // when a window on deactive window gets focus, WM_IME_SETCONTEXT (wParam is
49149:   // TRUE) is sent to the top level window first.  After that,
49149:   // WM_IME_SETCONTEXT (wParam is FALSE) is sent to the top level window.
49149:   // Finally, WM_IME_SETCONTEXT (wParam is TRUE) is sent to the focused window.
49149:   // The top level window never becomes composing window, so, we can ignore
49149:   // the WM_IME_SETCONTEXT on the top level window.
49149:   if (IsTopLevelWindowOfComposition(aWindow)) {
49149:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:       ("IMM32: OnIMESetContext, hWnd=%08x is top level window\n"));
79626:     return false;
49149:   }
49149: 
49149:   // When IME context is activating on another window,
49149:   // we should commit the old composition on the old window.
79445:   bool cancelComposition = false;
49149:   if (wParam && gIMM32Handler) {
49149:     cancelComposition =
49149:       gIMM32Handler->CommitCompositionOnPreviousWindow(aWindow);
27961:   }
27961: 
28059:   if (wParam && (lParam & ISC_SHOWUICOMPOSITIONWINDOW) &&
28059:       ShouldDrawCompositionStringOurselves()) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: OnIMESetContext, ISC_SHOWUICOMPOSITIONWINDOW is removed\n"));
27961:     lParam &= ~ISC_SHOWUICOMPOSITIONWINDOW;
27961:   }
27961: 
49149:   // We should sent WM_IME_SETCONTEXT to the DefWndProc here because the
49149:   // ancestor windows shouldn't receive this message.  If they receive the
49149:   // message, we cannot know whether which window is the target of the message.
49149:   *aResult = ::DefWindowProc(aWindow->GetWindowHandle(),
49149:                              WM_IME_SETCONTEXT, wParam, lParam);
49149: 
49149:   // Cancel composition on the new window if we committed our composition on
49149:   // another window.
49149:   if (cancelComposition) {
79626:     CancelComposition(aWindow, true);
49149:   }
49149: 
79626:   return true;
49149: }
49149: 
79445: bool
49149: nsIMM32Handler::OnChar(nsWindow* aWindow,
49149:                        WPARAM wParam,
49149:                        LPARAM lParam)
49149: {
49149:   if (IsIMECharRecordsEmpty()) {
79626:     return false;
27961:   }
49149:   WPARAM recWParam;
49149:   LPARAM recLParam;
49149:   DequeueIMECharRecords(recWParam, recLParam);
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: OnChar, aWindow=%p, wParam=%08x, lParam=%08x,\n",
49149:      aWindow->GetWindowHandle(), wParam, lParam));
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("               recorded: wParam=%08x, lParam=%08x\n",
49149:      recWParam, recLParam));
49149:   // If an unexpected char message comes, we should reset the records,
49149:   // of course, this shouldn't happen.
49149:   if (recWParam != wParam || recLParam != lParam) {
49149:     ResetIMECharRecords();
79626:     return false;
49149:   }
49149:   // Eat the char message which is caused by WM_IME_CHAR because we should
49149:   // have processed the IME messages, so, this message could be come from
49149:   // a windowless plug-in.
79626:   return true;
49149: }
49149: 
49149: /****************************************************************************
49149:  * message handlers for plug-in
49149:  ****************************************************************************/
49149: 
79445: bool
49149: nsIMM32Handler::OnIMEStartCompositionOnPlugin(nsWindow* aWindow,
49149:                                               WPARAM wParam,
49149:                                               LPARAM lParam)
49149: {
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: OnIMEStartCompositionOnPlugin, hWnd=%08x, mIsComposingOnPlugin=%s\n",
49149:      aWindow->GetWindowHandle(), mIsComposingOnPlugin ? "TRUE" : "FALSE"));
79626:   mIsComposingOnPlugin = true;
49149:   mComposingWindow = aWindow;
79445:   bool handled =
49149:     aWindow->DispatchPluginEvent(WM_IME_STARTCOMPOSITION, wParam, lParam,
79626:                                  false);
49149:   return handled;
49149: }
49149: 
79445: bool
49149: nsIMM32Handler::OnIMECompositionOnPlugin(nsWindow* aWindow,
49149:                                          WPARAM wParam,
49149:                                          LPARAM lParam)
49149: {
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: OnIMECompositionOnPlugin, hWnd=%08x, lParam=%08x, mIsComposingOnPlugin=%s\n",
49149:      aWindow->GetWindowHandle(), lParam,
49149:      mIsComposingOnPlugin ? "TRUE" : "FALSE"));
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: OnIMECompositionOnPlugin, GCS_RESULTSTR=%s, GCS_COMPSTR=%s, GCS_COMPATTR=%s, GCS_COMPCLAUSE=%s, GCS_CURSORPOS=%s\n",
49149:      lParam & GCS_RESULTSTR  ? "YES" : "no",
49149:      lParam & GCS_COMPSTR    ? "YES" : "no",
49149:      lParam & GCS_COMPATTR   ? "YES" : "no",
49149:      lParam & GCS_COMPCLAUSE ? "YES" : "no",
49149:      lParam & GCS_CURSORPOS  ? "YES" : "no"));
49149:   // We should end composition if there is a committed string.
49149:   if (IS_COMMITTING_LPARAM(lParam)) {
79626:     mIsComposingOnPlugin = false;
49149:     mComposingWindow = nsnull;
49149:   }
49149:   // Continue composition if there is still a string being composed.
49149:   if (IS_COMPOSING_LPARAM(lParam)) {
79626:     mIsComposingOnPlugin = true;
49149:     mComposingWindow = aWindow;
49149:   }
79445:   bool handled =
79626:     aWindow->DispatchPluginEvent(WM_IME_COMPOSITION, wParam, lParam, true);
49149:   return handled;
49149: }
49149: 
79445: bool
49149: nsIMM32Handler::OnIMEEndCompositionOnPlugin(nsWindow* aWindow,
49149:                                             WPARAM wParam,
49149:                                             LPARAM lParam)
49149: {
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: OnIMEEndCompositionOnPlugin, hWnd=%08x, mIsComposingOnPlugin=%s\n",
49149:      aWindow->GetWindowHandle(), mIsComposingOnPlugin ? "TRUE" : "FALSE"));
49149: 
79626:   mIsComposingOnPlugin = false;
49149:   mComposingWindow = nsnull;
79445:   bool handled =
49149:     aWindow->DispatchPluginEvent(WM_IME_ENDCOMPOSITION, wParam, lParam,
79626:                                  false);
49149:   return handled;
49149: }
49149: 
79445: bool
49149: nsIMM32Handler::OnIMECharOnPlugin(nsWindow* aWindow,
49149:                                   WPARAM wParam,
49149:                                   LPARAM lParam)
49149: {
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: OnIMECharOnPlugin, hWnd=%08x, char=%08x, scancode=%08x\n",
49149:      aWindow->GetWindowHandle(), wParam, lParam));
49149: 
79445:   bool handled =
79626:     aWindow->DispatchPluginEvent(WM_IME_CHAR, wParam, lParam, true);
49149: 
49149:   if (!handled) {
49149:     // Record the WM_CHAR messages which are going to be coming.
49149:     EnsureHandlerInstance();
49149:     EnqueueIMECharRecords(wParam, lParam);
49149:   }
49149:   return handled;
49149: }
49149: 
79445: /* static */ bool
49149: nsIMM32Handler::OnIMESetContextOnPlugin(nsWindow* aWindow,
49149:                                         WPARAM wParam,
49149:                                         LPARAM lParam,
49149:                                         LRESULT *aResult)
49149: {
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: OnIMESetContextOnPlugin, hWnd=%08x, %s, lParam=%08x\n",
49149:      aWindow->GetWindowHandle(), wParam ? "Active" : "Deactive", lParam));
49149: 
49149:   // If the IME context becomes active on a plug-in, we should commit
49149:   // our composition.  And also we should cancel the composition on new
49149:   // window.  Note that if IsTopLevelWindowOfComposition(aWindow) returns
49149:   // true, we should ignore the message here, see the comment in
49149:   // OnIMESetContext() for the detail.
49149:   if (wParam && gIMM32Handler && !IsTopLevelWindowOfComposition(aWindow)) {
49149:     if (gIMM32Handler->CommitCompositionOnPreviousWindow(aWindow)) {
49149:       CancelComposition(aWindow);
49149:     }
49149:   }
49149: 
49149:   // Dispatch message to the plug-in.
49149:   // XXX When a windowless plug-in gets focus, we should send
49149:   //     WM_IME_SETCONTEXT
79626:   aWindow->DispatchPluginEvent(WM_IME_SETCONTEXT, wParam, lParam, false);
49149: 
49149:   // We should send WM_IME_SETCONTEXT to the DefWndProc here.  It shouldn't
49149:   // be received on ancestor windows, see OnIMESetContext() for the detail.
49149:   *aResult = ::DefWindowProc(aWindow->GetWindowHandle(),
49149:                              WM_IME_SETCONTEXT, wParam, lParam);
49149: 
49149:   // Don't synchronously dispatch the pending events when we receive
49149:   // WM_IME_SETCONTEXT because we get it during plugin destruction.
49149:   // (bug 491848)
79626:   return true;
49149: }
49149: 
79445: bool
49149: nsIMM32Handler::OnCharOnPlugin(nsWindow* aWindow,
49149:                                WPARAM wParam,
49149:                                LPARAM lParam)
49149: {
49149:   if (IsIMECharRecordsEmpty()) {
79626:     return false;
49149:   }
49149: 
49149:   WPARAM recWParam;
49149:   LPARAM recLParam;
49149:   DequeueIMECharRecords(recWParam, recLParam);
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: OnCharOnPlugin, aWindow=%p, wParam=%08x, lParam=%08x,\n",
49149:      aWindow->GetWindowHandle(), wParam, lParam));
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("                       recorded: wParam=%08x, lParam=%08x\n",
49149:      recWParam, recLParam));
49149:   // If an unexpected char message comes, we should reset the records,
49149:   // of course, this shouldn't happen.
49149:   if (recWParam != wParam || recLParam != lParam) {
49149:     ResetIMECharRecords();
49149:   }
49149:   // WM_CHAR on plug-in is always handled by nsWindow.
79626:   return false;
49149: }
49149: 
49149: /****************************************************************************
49149:  * others
49149:  ****************************************************************************/
27961: 
27961: void
27961: nsIMM32Handler::HandleStartComposition(nsWindow* aWindow,
27961:                                        const nsIMEContext &aIMEContext)
27961: {
27961:   NS_PRECONDITION(!mIsComposing,
27961:     "HandleStartComposition is called but mIsComposing is TRUE");
27961:   NS_PRECONDITION(!aWindow->PluginHasFocus(),
27961:     "HandleStartComposition should not be called when a plug-in has focus");
27961: 
79626:   nsQueryContentEvent selection(true, NS_QUERY_SELECTED_TEXT, aWindow);
51212:   nsIntPoint point(0, 0);
51212:   aWindow->InitEvent(selection, &point);
28352:   aWindow->DispatchWindowEvent(&selection);
28352:   if (!selection.mSucceeded) {
28352:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
28352:       ("IMM32: HandleStartComposition, FAILED (NS_QUERY_SELECTED_TEXT)\n"));
28352:     return;
28352:   }
28352: 
28352:   mCompositionStart = selection.mReply.mOffset;
78623:   mLastDispatchedCompositionString.Truncate();
28352: 
79626:   nsCompositionEvent event(true, NS_COMPOSITION_START, aWindow);
27961:   aWindow->InitEvent(event, &point);
27961:   aWindow->DispatchWindowEvent(&event);
27961: 
27961:   SetIMERelatedWindowsPos(aWindow, aIMEContext);
27961: 
79626:   mIsComposing = true;
49149:   mComposingWindow = aWindow;
27961: 
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
28352:     ("IMM32: HandleStartComposition, START composition, mCompositionStart=%ld\n",
28352:      mCompositionStart));
27961: }
27961: 
79445: bool
27961: nsIMM32Handler::HandleComposition(nsWindow* aWindow,
27961:                                   const nsIMEContext &aIMEContext,
27961:                                   LPARAM lParam)
27961: {
27961:   NS_PRECONDITION(!aWindow->PluginHasFocus(),
27961:     "HandleComposition should not be called when a plug-in has focus");
27961: 
27961:   // for bug #60050
27961:   // MS-IME 95/97/98/2000 may send WM_IME_COMPOSITION with non-conversion
27961:   // mode before it send WM_IME_STARTCOMPOSITION.
48294:   // However, ATOK sends a WM_IME_COMPOSITION before WM_IME_STARTCOMPOSITION,
48294:   // and if we access ATOK via some APIs, ATOK will sometimes fail to
48294:   // initialize its state.  If WM_IME_STARTCOMPOSITION is already in the
48294:   // message queue, we should ignore the strange WM_IME_COMPOSITION message and
48294:   // skip to the next.  So, we should look for next composition message
48294:   // (WM_IME_STARTCOMPOSITION or WM_IME_ENDCOMPOSITION or WM_IME_COMPOSITION),
48294:   // and if it's WM_IME_STARTCOMPOSITION, and one more next composition message
48294:   // is WM_IME_COMPOSITION, current IME is ATOK, probably.  Otherwise, we
48294:   // should start composition forcibly.
48294:   if (!mIsComposing) {
48294:     MSG msg1, msg2;
48294:     HWND wnd = aWindow->GetWindowHandle();
48294:     if (::PeekMessageW(&msg1, wnd, WM_IME_STARTCOMPOSITION, WM_IME_COMPOSITION,
48294:                        PM_NOREMOVE) &&
48294:         msg1.message == WM_IME_STARTCOMPOSITION &&
48294:         ::PeekMessageW(&msg2, wnd, WM_IME_ENDCOMPOSITION, WM_IME_COMPOSITION,
48294:                        PM_NOREMOVE) &&
48294:         msg2.message == WM_IME_COMPOSITION) {
48294:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
48294:         ("IMM32: HandleComposition, Ignores due to find a WM_IME_STARTCOMPOSITION\n"));
48294:       return ShouldDrawCompositionStringOurselves();
48294:     }
48294:   }
27961: 
27961:   if (!IS_COMMITTING_LPARAM(lParam) && !IS_COMPOSING_LPARAM(lParam)) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleComposition, Handle 0 length TextEvent\n"));
27961: 
27961:     // XXX This block should be wrong. If composition string is not change,
27961:     // we should do nothing.
27961: 
27961:     if (!mIsComposing) {
27961:       HandleStartComposition(aWindow, aIMEContext);
27961:     }
27961: 
27961:     mCompositionString.Truncate();
79626:     DispatchTextEvent(aWindow, aIMEContext, false);
27961: 
27961:     return ShouldDrawCompositionStringOurselves();
27961:   }
27961: 
27961: 
79445:   bool startCompositionMessageHasBeenSent = mIsComposing;
27961: 
27961:   //
27961:   // This catches a fixed result
27961:   //
27961:   if (IS_COMMITTING_LPARAM(lParam)) {
27961:     if (!mIsComposing) {
27961:       HandleStartComposition(aWindow, aIMEContext);
27961:     }
27961: 
27961:     GetCompositionString(aIMEContext, GCS_RESULTSTR);
27961: 
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleComposition, GCS_RESULTSTR\n"));
27961: 
79626:     DispatchTextEvent(aWindow, aIMEContext, false);
27961:     HandleEndComposition(aWindow);
27961: 
27961:     if (!IS_COMPOSING_LPARAM(lParam)) {
27961:       return ShouldDrawCompositionStringOurselves();
27961:     }
27961:   }
27961: 
27961: 
27961:   //
27961:   // This provides us with a composition string
27961:   //
27961:   if (!mIsComposing) {
27961:     HandleStartComposition(aWindow, aIMEContext);
27961:   }
27961: 
27961:   //--------------------------------------------------------
27961:   // 1. Get GCS_COMPSTR
27961:   //--------------------------------------------------------
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: HandleComposition, GCS_COMPSTR\n"));
27961: 
27961:   GetCompositionString(aIMEContext, GCS_COMPSTR);
27961: 
27961:   // See https://bugzilla.mozilla.org/show_bug.cgi?id=296339
27961:   if (mCompositionString.IsEmpty() && !startCompositionMessageHasBeenSent) {
27961:     // In this case, maybe, the sender is MSPinYin. That sends *only*
27961:     // WM_IME_COMPOSITION with GCS_COMP* and GCS_RESULT* when
27961:     // user inputted the Chinese full stop. So, that doesn't send
27961:     // WM_IME_STARTCOMPOSITION and WM_IME_ENDCOMPOSITION.
27961:     // If WM_IME_STARTCOMPOSITION was not sent and the composition
27961:     // string is null (it indicates the composition transaction ended),
27961:     // WM_IME_ENDCOMPOSITION may not be sent. If so, we cannot run
27961:     // HandleEndComposition() in other place.
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleComposition, Aborting GCS_COMPSTR\n"));
27961:     HandleEndComposition(aWindow);
27961:     return IS_COMMITTING_LPARAM(lParam);
27961:   }
27961: 
27961:   //--------------------------------------------------------
27961:   // 2. Get GCS_COMPCLAUSE
27961:   //--------------------------------------------------------
27961:   long clauseArrayLength =
27961:     ::ImmGetCompositionStringW(aIMEContext.get(), GCS_COMPCLAUSE, NULL, 0);
27961:   clauseArrayLength /= sizeof(PRUint32);
27961: 
27961:   if (clauseArrayLength > 0) {
27961:     nsresult rv = EnsureClauseArray(clauseArrayLength);
79626:     NS_ENSURE_SUCCESS(rv, false);
27961: 
27961:     // Intelligent ABC IME (Simplified Chinese IME, the code page is 936)
27961:     // will crash in ImmGetCompositionStringW for GCS_COMPCLAUSE (bug 424663).
27961:     // See comment 35 of the bug for the detail. Therefore, we should use A
27961:     // API for it, however, we should not kill Unicode support on all IMEs.
79445:     bool useA_API = !(sIMEProperty & IME_PROP_UNICODE);
27961: 
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleComposition, GCS_COMPCLAUSE, useA_API=%s\n",
27961:        useA_API ? "TRUE" : "FALSE"));
27961: 
27961:     long clauseArrayLength2 = 
27961:       useA_API ?
27961:         ::ImmGetCompositionStringA(aIMEContext.get(), GCS_COMPCLAUSE,
27961:                                    mClauseArray.Elements(),
27961:                                    mClauseArray.Capacity() * sizeof(PRUint32)) :
27961:         ::ImmGetCompositionStringW(aIMEContext.get(), GCS_COMPCLAUSE,
27961:                                    mClauseArray.Elements(),
27961:                                    mClauseArray.Capacity() * sizeof(PRUint32));
27961:     clauseArrayLength2 /= sizeof(PRUint32);
27961: 
27961:     if (clauseArrayLength != clauseArrayLength2) {
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: HandleComposition, GCS_COMPCLAUSE, clauseArrayLength=%ld but clauseArrayLength2=%ld\n",
27961:          clauseArrayLength, clauseArrayLength2));
27961:       if (clauseArrayLength > clauseArrayLength2)
27961:         clauseArrayLength = clauseArrayLength2;
27961:     }
27961: 
27961:     if (useA_API) {
27961:       // Convert each values of sIMECompClauseArray. The values mean offset of
27961:       // the clauses in ANSI string. But we need the values in Unicode string.
27961:       nsCAutoString compANSIStr;
27961:       if (ConvertToANSIString(mCompositionString, GetKeyboardCodePage(),
27961:                               compANSIStr)) {
27961:         PRUint32 maxlen = compANSIStr.Length();
27961:         mClauseArray[0] = 0; // first value must be 0
27961:         for (PRInt32 i = 1; i < clauseArrayLength; i++) {
72496:           PRUint32 len = NS_MIN(mClauseArray[i], maxlen);
27961:           mClauseArray[i] = ::MultiByteToWideChar(GetKeyboardCodePage(), 
27961:                                                   MB_PRECOMPOSED,
27961:                                                   (LPCSTR)compANSIStr.get(),
27961:                                                   len, NULL, 0);
27961:         }
27961:       }
27961:     }
27961:   }
27961:   // compClauseArrayLength may be negative. I.e., ImmGetCompositionStringW
27961:   // may return an error code.
72496:   mClauseArray.SetLength(NS_MAX<long>(0, clauseArrayLength));
27961: 
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: HandleComposition, GCS_COMPCLAUSE, mClauseLength=%ld\n",
27961:      mClauseArray.Length()));
27961: 
27961:   //--------------------------------------------------------
27961:   // 3. Get GCS_COMPATTR
27961:   //--------------------------------------------------------
27961:   // This provides us with the attribute string necessary 
27961:   // for doing hiliting
27961:   long attrArrayLength =
27961:     ::ImmGetCompositionStringW(aIMEContext.get(), GCS_COMPATTR, NULL, 0);
27961:   attrArrayLength /= sizeof(PRUint8);
27961: 
27961:   if (attrArrayLength > 0) {
27961:     nsresult rv = EnsureAttributeArray(attrArrayLength);
79626:     NS_ENSURE_SUCCESS(rv, false);
27961:     attrArrayLength =
27961:       ::ImmGetCompositionStringW(aIMEContext.get(), GCS_COMPATTR,
27961:                                  mAttributeArray.Elements(),
27961:                                  mAttributeArray.Capacity() * sizeof(PRUint8));
27961:   }
27961: 
27961:   // attrStrLen may be negative. I.e., ImmGetCompositionStringW may return an
27961:   // error code.
72496:   mAttributeArray.SetLength(NS_MAX<long>(0, attrArrayLength));
27961: 
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: HandleComposition, GCS_COMPATTR, mAttributeLength=%ld\n",
27961:      mAttributeArray.Length()));
27961: 
27961:   //--------------------------------------------------------
27961:   // 4. Get GCS_CURSOPOS
27961:   //--------------------------------------------------------
27961:   // Some IMEs (e.g., the standard IME for Korean) don't have caret position.
27961:   if (lParam & GCS_CURSORPOS) {
27961:     mCursorPosition =
27961:       ::ImmGetCompositionStringW(aIMEContext.get(), GCS_CURSORPOS, NULL, 0);
27961:     if (mCursorPosition < 0) {
27961:       mCursorPosition = NO_IME_CARET; // The result is error
27961:     }
27961:   } else {
27961:     mCursorPosition = NO_IME_CARET;
27961:   }
27961: 
27961:   NS_ASSERTION(mCursorPosition <= (long)mCompositionString.Length(),
27961:                "illegal pos");
27961: 
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: HandleComposition, GCS_CURSORPOS, mCursorPosition=%d\n",
27961:      mCursorPosition));
27961: 
27961:   //--------------------------------------------------------
27961:   // 5. Send the text event
27961:   //--------------------------------------------------------
27961:   DispatchTextEvent(aWindow, aIMEContext);
27961: 
27961:   return ShouldDrawCompositionStringOurselves();
27961: }
27961: 
27961: void
27961: nsIMM32Handler::HandleEndComposition(nsWindow* aWindow)
27961: {
27961:   NS_PRECONDITION(mIsComposing,
27961:     "HandleEndComposition is called but mIsComposing is FALSE");
27961:   NS_PRECONDITION(!aWindow->PluginHasFocus(),
27961:     "HandleComposition should not be called when a plug-in has focus");
27961: 
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: HandleEndComposition\n"));
27961: 
79626:   nsCompositionEvent event(true, NS_COMPOSITION_END, aWindow);
27961:   nsIntPoint point(0, 0);
27961: 
27961:   if (mNativeCaretIsCreated) {
27961:     ::DestroyCaret();
79626:     mNativeCaretIsCreated = false;
27961:   }
27961: 
27961:   aWindow->InitEvent(event, &point);
78623:   // The last dispatched composition string must be the committed string.
78623:   event.data = mLastDispatchedCompositionString;
27961:   aWindow->DispatchWindowEvent(&event);
79626:   mIsComposing = false;
49149:   mComposingWindow = nsnull;
78623:   mLastDispatchedCompositionString.Truncate();
27961: }
27961: 
36322: static void
36322: DumpReconvertString(RECONVERTSTRING* aReconv)
36322: {
36322:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:     ("  dwSize=%ld, dwVersion=%ld, dwStrLen=%ld, dwStrOffset=%ld\n",
36322:      aReconv->dwSize, aReconv->dwVersion,
36322:      aReconv->dwStrLen, aReconv->dwStrOffset));
36322:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:     ("  dwCompStrLen=%ld, dwCompStrOffset=%ld, dwTargetStrLen=%ld, dwTargetStrOffset=%ld\n",
36322:      aReconv->dwCompStrLen, aReconv->dwCompStrOffset,
36322:      aReconv->dwTargetStrLen, aReconv->dwTargetStrOffset));
36322:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:     ("  result str=\"%s\"\n",
36322:      NS_ConvertUTF16toUTF8(
36322:        nsAutoString((PRUnichar*)((char*)(aReconv) + aReconv->dwStrOffset),
36322:                     aReconv->dwStrLen)).get()));
36322: }
36322: 
79445: bool
27961: nsIMM32Handler::HandleReconvert(nsWindow* aWindow,
27961:                                 LPARAM lParam,
27961:                                 LRESULT *oResult)
27961: {
27961:   *oResult = 0;
27961:   RECONVERTSTRING* pReconv = reinterpret_cast<RECONVERTSTRING*>(lParam);
27961: 
79626:   nsQueryContentEvent selection(true, NS_QUERY_SELECTED_TEXT, aWindow);
27961:   nsIntPoint point(0, 0);
27961:   aWindow->InitEvent(selection, &point);
27961:   aWindow->DispatchWindowEvent(&selection);
27961:   if (!selection.mSucceeded) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleReconvert, FAILED (NS_QUERY_SELECTED_TEXT)\n"));
79626:     return false;
27961:   }
27961: 
36322:   PRUint32 len = selection.mReply.mString.Length();
36322:   PRUint32 needSize = sizeof(RECONVERTSTRING) + len * sizeof(WCHAR);
36322: 
27961:   if (!pReconv) {
27961:     // Return need size to reconvert.
36322:     if (len == 0) {
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: HandleReconvert, There are not selected text\n"));
79626:       return false;
27961:     }
36322:     *oResult = needSize;
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleReconvert, SUCCEEDED result=%ld\n",
27961:        *oResult));
79626:     return true;
27961:   }
27961: 
27961:   if (pReconv->dwSize < needSize) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleReconvert, FAILED pReconv->dwSize=%ld, needSize=%ld\n",
27961:        pReconv->dwSize, needSize));
79626:     return false;
27961:   }
27961: 
27961:   *oResult = needSize;
27961: 
36322:   // Fill reconvert struct
27961:   pReconv->dwVersion         = 0;
27961:   pReconv->dwStrLen          = len;
27961:   pReconv->dwStrOffset       = sizeof(RECONVERTSTRING);
27961:   pReconv->dwCompStrLen      = len;
27961:   pReconv->dwCompStrOffset   = 0;
27961:   pReconv->dwTargetStrLen    = len;
27961:   pReconv->dwTargetStrOffset = 0;
27961: 
36322:   ::CopyMemory(reinterpret_cast<LPVOID>(lParam + sizeof(RECONVERTSTRING)),
27961:                selection.mReply.mString.get(), len * sizeof(WCHAR));
27961: 
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:     ("IMM32: HandleReconvert, SUCCEEDED result=%ld\n",
36322:      *oResult));
36322:   DumpReconvertString(pReconv);
27961: 
79626:   return true;
27961: }
27961: 
79445: bool
27961: nsIMM32Handler::HandleQueryCharPosition(nsWindow* aWindow,
27961:                                         LPARAM lParam,
27961:                                         LRESULT *oResult)
27961: {
27961:   PRUint32 len = mIsComposing ? mCompositionString.Length() : 0;
79626:   *oResult = false;
27961:   IMECHARPOSITION* pCharPosition = reinterpret_cast<IMECHARPOSITION*>(lParam);
27961:   if (!pCharPosition) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleQueryCharPosition, FAILED (pCharPosition is null)\n"));
79626:     return false;
27961:   }
27961:   if (pCharPosition->dwSize < sizeof(IMECHARPOSITION)) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleReconvert, FAILED, pCharPosition->dwSize=%ld, sizeof(IMECHARPOSITION)=%ld\n",
27961:        pCharPosition->dwSize, sizeof(IMECHARPOSITION)));
79626:     return false;
27961:   }
27961:   if (::GetFocus() != aWindow->GetWindowHandle()) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleReconvert, FAILED, ::GetFocus()=%08x, OurWindowHandle=%08x\n",
27961:        ::GetFocus(), aWindow->GetWindowHandle()));
79626:     return false;
27961:   }
27961:   if (pCharPosition->dwCharPos > len) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: HandleQueryCharPosition, FAILED, pCharPosition->dwCharPos=%ld, len=%ld\n",
27961:       pCharPosition->dwCharPos, len));
79626:     return false;
27961:   }
27961: 
27961:   nsIntRect r;
79445:   bool ret =
27961:     GetCharacterRectOfSelectedTextAt(aWindow, pCharPosition->dwCharPos, r);
79626:   NS_ENSURE_TRUE(ret, false);
27961: 
27961:   nsIntRect screenRect;
27961:   // We always need top level window that is owner window of the popup window
27961:   // even if the content of the popup window has focus.
79626:   ResolveIMECaretPos(aWindow->GetTopLevelWindow(false),
27961:                      r, nsnull, screenRect);
27961:   pCharPosition->pt.x = screenRect.x;
27961:   pCharPosition->pt.y = screenRect.y;
27961: 
27961:   pCharPosition->cLineHeight = r.height;
27961: 
27961:   // XXX we should use NS_QUERY_EDITOR_RECT event here.
27961:   ::GetWindowRect(aWindow->GetWindowHandle(), &pCharPosition->rcDocument);
27961: 
27961:   *oResult = TRUE;
27961: 
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: HandleQueryCharPosition, SUCCEEDED\n"));
79626:   return true;
27961: }
27961: 
79445: bool
36322: nsIMM32Handler::HandleDocumentFeed(nsWindow* aWindow,
36322:                                    LPARAM lParam,
36322:                                    LRESULT *oResult)
36322: {
36322:   *oResult = 0;
36322:   RECONVERTSTRING* pReconv = reinterpret_cast<RECONVERTSTRING*>(lParam);
36322: 
36322:   nsIntPoint point(0, 0);
36322: 
79445:   bool hasCompositionString =
36322:     mIsComposing && ShouldDrawCompositionStringOurselves();
36322: 
36322:   PRInt32 targetOffset, targetLength;
36322:   if (!hasCompositionString) {
79626:     nsQueryContentEvent selection(true, NS_QUERY_SELECTED_TEXT, aWindow);
36322:     aWindow->InitEvent(selection, &point);
36322:     aWindow->DispatchWindowEvent(&selection);
36322:     if (!selection.mSucceeded) {
36322:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:         ("IMM32: HandleDocumentFeed, FAILED (NS_QUERY_SELECTED_TEXT)\n"));
79626:       return false;
36322:     }
36322:     targetOffset = PRInt32(selection.mReply.mOffset);
36322:     targetLength = PRInt32(selection.mReply.mString.Length());
36322:   } else {
36322:     targetOffset = PRInt32(mCompositionStart);
36322:     targetLength = PRInt32(mCompositionString.Length());
36322:   }
36322: 
36322:   // XXX nsString::Find and nsString::RFind take PRInt32 for offset, so,
36322:   //     we cannot support this message when the current offset is larger than
36322:   //     PR_INT32_MAX.
36322:   if (targetOffset < 0 || targetLength < 0 ||
36322:       targetOffset + targetLength < 0) {
36322:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:       ("IMM32: HandleDocumentFeed, FAILED (The selection is out of range)\n"));
79626:     return false;
36322:   }
36322: 
36322:   // Get all contents of the focused editor.
79626:   nsQueryContentEvent textContent(true, NS_QUERY_TEXT_CONTENT, aWindow);
36322:   textContent.InitForQueryTextContent(0, PR_UINT32_MAX);
36322:   aWindow->InitEvent(textContent, &point);
36322:   aWindow->DispatchWindowEvent(&textContent);
36322:   if (!textContent.mSucceeded) {
36322:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:       ("IMM32: HandleDocumentFeed, FAILED (NS_QUERY_TEXT_CONTENT)\n"));
79626:     return false;
36322:   }
36322: 
36322:   nsAutoString str(textContent.mReply.mString);
36322:   if (targetOffset > PRInt32(str.Length())) {
36322:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:       ("IMM32: HandleDocumentFeed, FAILED (The caret offset is invalid)\n"));
79626:     return false;
36322:   }
36322: 
36322:   // Get the focused paragraph, we decide that it starts from the previous CRLF
36322:   // (or start of the editor) to the next one (or the end of the editor).
79626:   PRInt32 paragraphStart = str.RFind("\n", false, targetOffset, -1) + 1;
36322:   PRInt32 paragraphEnd =
79626:     str.Find("\r", false, targetOffset + targetLength, -1);
36322:   if (paragraphEnd < 0) {
36322:     paragraphEnd = str.Length();
36322:   }
36322:   nsDependentSubstring paragraph(str, paragraphStart,
36322:                                  paragraphEnd - paragraphStart);
36322: 
36322:   PRUint32 len = paragraph.Length();
36322:   PRUint32 needSize = sizeof(RECONVERTSTRING) + len * sizeof(WCHAR);
36322: 
36322:   if (!pReconv) {
36322:     *oResult = needSize;
36322:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:       ("IMM32: HandleDocumentFeed, SUCCEEDED result=%ld\n",
36322:        *oResult));
79626:     return true;
36322:   }
36322: 
36322:   if (pReconv->dwSize < needSize) {
36322:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:       ("IMM32: HandleDocumentFeed, FAILED pReconv->dwSize=%ld, needSize=%ld\n",
36322:        pReconv->dwSize, needSize));
79626:     return false;
36322:   }
36322: 
36322:   // Fill reconvert struct
36322:   pReconv->dwVersion         = 0;
36322:   pReconv->dwStrLen          = len;
36322:   pReconv->dwStrOffset       = sizeof(RECONVERTSTRING);
36322:   if (hasCompositionString) {
36322:     pReconv->dwCompStrLen      = targetLength;
36322:     pReconv->dwCompStrOffset   =
36322:       (targetOffset - paragraphStart) * sizeof(WCHAR);
36322:     // Set composition target clause information
36322:     PRUint32 offset, length;
36322:     if (!GetTargetClauseRange(&offset, &length)) {
36322:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:         ("IMM32: HandleDocumentFeed, FAILED, by GetTargetClauseRange\n"));
79626:       return false;
36322:     }
36322:     pReconv->dwTargetStrLen    = length;
36322:     pReconv->dwTargetStrOffset = (offset - paragraphStart) * sizeof(WCHAR);
36322:   } else {
36322:     pReconv->dwTargetStrLen    = targetLength;
36322:     pReconv->dwTargetStrOffset =
36322:       (targetOffset - paragraphStart) * sizeof(WCHAR);
36322:     // There is no composition string, so, the length is zero but we should
36322:     // set the cursor offset to the composition str offset.
36322:     pReconv->dwCompStrLen      = 0;
36322:     pReconv->dwCompStrOffset   = pReconv->dwTargetStrOffset;
36322:   }
36322: 
36322:   *oResult = needSize;
36322:   ::CopyMemory(reinterpret_cast<LPVOID>(lParam + sizeof(RECONVERTSTRING)),
36322:                paragraph.BeginReading(), len * sizeof(WCHAR));
36322: 
36322:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:     ("IMM32: HandleDocumentFeed, SUCCEEDED result=%ld\n",
36322:      *oResult));
36322:   DumpReconvertString(pReconv);
36322: 
79626:   return true;
36322: }
36322: 
79445: bool
49149: nsIMM32Handler::CommitCompositionOnPreviousWindow(nsWindow* aWindow)
49149: {
49149:   if (!mComposingWindow || mComposingWindow == aWindow) {
79626:     return false;
49149:   }
49149: 
49149:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
49149:     ("IMM32: CommitCompositionOnPreviousWindow, mIsComposing=%s, mIsComposingOnPlugin=%s\n",
49149:      mIsComposing ? "TRUE" : "FALSE", mIsComposingOnPlugin ? "TRUE" : "FALSE"));
49149: 
49149:   // If we have composition, we should dispatch composition events internally.
49149:   if (mIsComposing) {
49149:     nsIMEContext IMEContext(mComposingWindow->GetWindowHandle());
49149:     NS_ASSERTION(IMEContext.IsValid(), "IME context must be valid");
49149: 
79626:     DispatchTextEvent(mComposingWindow, IMEContext, false);
49149:     HandleEndComposition(mComposingWindow);
79626:     return true;
49149:   }
49149: 
49149:   // XXX When plug-in has composition, we should commit composition on the
49149:   // plug-in.  However, we need some more work for that.
49149:   return mIsComposingOnPlugin;
49149: }
49149: 
27961: static PRUint32
27961: PlatformToNSAttr(PRUint8 aAttr)
27961: {
27961:   switch (aAttr)
27961:   {
27961:     case ATTR_INPUT_ERROR:
27961:     // case ATTR_FIXEDCONVERTED:
27961:     case ATTR_INPUT:
27961:       return NS_TEXTRANGE_RAWINPUT;
27961:     case ATTR_CONVERTED:
27961:       return NS_TEXTRANGE_CONVERTEDTEXT;
27961:     case ATTR_TARGET_NOTCONVERTED:
27961:       return NS_TEXTRANGE_SELECTEDRAWTEXT;
27961:     case ATTR_TARGET_CONVERTED:
27961:       return NS_TEXTRANGE_SELECTEDCONVERTEDTEXT;
27961:     default:
79626:       NS_ASSERTION(false, "unknown attribute");
27961:       return NS_TEXTRANGE_CARETPOSITION;
27961:   }
27961: }
27961: 
27961: #ifdef PR_LOGGING
27961: static const char*
27961: GetRangeTypeName(PRUint32 aRangeType)
27961: {
27961:   switch (aRangeType) {
27961:     case NS_TEXTRANGE_RAWINPUT:
27961:       return "NS_TEXTRANGE_RAWINPUT";
27961:     case NS_TEXTRANGE_CONVERTEDTEXT:
27961:       return "NS_TEXTRANGE_CONVERTEDTEXT";
27961:     case NS_TEXTRANGE_SELECTEDRAWTEXT:
27961:       return "NS_TEXTRANGE_SELECTEDRAWTEXT";
27961:     case NS_TEXTRANGE_SELECTEDCONVERTEDTEXT:
27961:       return "NS_TEXTRANGE_SELECTEDCONVERTEDTEXT";
27961:     case NS_TEXTRANGE_CARETPOSITION:
27961:       return "NS_TEXTRANGE_CARETPOSITION";
27961:     default:
27961:       return "UNKNOWN SELECTION TYPE!!";
27961:   }
27961: }
27961: #endif
27961: 
27961: void
27961: nsIMM32Handler::DispatchTextEvent(nsWindow* aWindow,
27961:                                   const nsIMEContext &aIMEContext,
79445:                                   bool aCheckAttr)
27961: {
27961:   NS_ASSERTION(mIsComposing, "conflict state");
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: DispatchTextEvent, aCheckAttr=%s\n",
27961:      aCheckAttr ? "TRUE": "FALSE"));
27961: 
27961:   // If we don't need to draw composition string ourselves and this is not
27961:   // commit event (i.e., under composing), we don't need to fire text event
27961:   // during composing.
27961:   if (aCheckAttr && !ShouldDrawCompositionStringOurselves()) {
27961:     // But we need to adjust composition window pos and native caret pos, here.
27961:     SetIMERelatedWindowsPos(aWindow, aIMEContext);
27961:     return;
27961:   }
27961: 
78623:   nsRefPtr<nsWindow> kungFuDeathGrip(aWindow);
78623: 
78623:   nsIntPoint point(0, 0);
78623: 
78623:   if (mCompositionString != mLastDispatchedCompositionString) {
79626:     nsCompositionEvent compositionUpdate(true, NS_COMPOSITION_UPDATE,
78623:                                          aWindow);
78623:     aWindow->InitEvent(compositionUpdate, &point);
78623:     compositionUpdate.data = mCompositionString;
78623:     mLastDispatchedCompositionString = mCompositionString;
78623: 
78623:     aWindow->DispatchWindowEvent(&compositionUpdate);
78623: 
78623:     if (!mIsComposing || aWindow->Destroyed()) {
78623:       return;
78623:     }
78623:     SetIMERelatedWindowsPos(aWindow, aIMEContext);
78623:   }
78623: 
79626:   nsTextEvent event(true, NS_TEXT_TEXT, aWindow);
27961: 
27961:   aWindow->InitEvent(event, &point);
27961: 
27961:   nsAutoTArray<nsTextRange, 4> textRanges;
27961: 
27961:   if (aCheckAttr) {
27961:     SetTextRangeList(textRanges);
27961:   }
27961: 
27961:   event.rangeCount = textRanges.Length();
27961:   event.rangeArray = textRanges.Elements();
27961: 
27961:   event.theText = mCompositionString.get();
27961:   nsModifierKeyState modKeyState;
27961:   event.isShift = modKeyState.mIsShiftDown;
27961:   event.isControl = modKeyState.mIsControlDown;
79626:   event.isMeta = false;
27961:   event.isAlt = modKeyState.mIsAltDown;
27961: 
27961:   aWindow->DispatchWindowEvent(&event);
27961: 
27961:   SetIMERelatedWindowsPos(aWindow, aIMEContext);
27961: }
27961: 
27961: void
27961: nsIMM32Handler::SetTextRangeList(nsTArray<nsTextRange> &aTextRangeList)
27961: {
27961:   // Sogou (Simplified Chinese IME) returns contradictory values: The cursor
27961:   // position is actual cursor position. However, other values (composition
27961:   // string and attributes) are empty. So, if you want to remove following
27961:   // assertion, be careful.
27961:   NS_ASSERTION(ShouldDrawCompositionStringOurselves(),
27961:     "SetTextRangeList is called when we don't need to fire text event");
27961: 
27961:   nsTextRange range;
27961:   if (mClauseArray.Length() == 0) {
27961:     // Some IMEs don't return clause array information, then, we assume that
27961:     // all characters in the composition string are in one clause.
27961:     range.mStartOffset = 0;
27961:     range.mEndOffset = mCompositionString.Length();
27961:     range.mRangeType = NS_TEXTRANGE_RAWINPUT;
27961:     aTextRangeList.AppendElement(range);
27961: 
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: SetTextRangeList, mClauseLength=0\n"));
27961:   } else {
27961:     // iterate over the attributes
27961:     PRUint32 lastOffset = 0;
27961:     for (PRUint32 i = 0; i < mClauseArray.Length() - 1; i++) {
27961:       PRUint32 current = mClauseArray[i + 1];
27961:       if (current > mCompositionString.Length()) {
27961:         PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:           ("IMM32: SetTextRangeList, mClauseArray[%ld]=%lu. This is larger than mCompositionString.Length()=%lu\n",
27961:            i + 1, current, mCompositionString.Length()));
27961:         current = PRInt32(mCompositionString.Length());
27961:       }
27961: 
27961:       range.mRangeType = PlatformToNSAttr(mAttributeArray[lastOffset]);
27961:       range.mStartOffset = lastOffset;
27961:       range.mEndOffset = current;
27961:       aTextRangeList.AppendElement(range);
27961: 
27961:       lastOffset = current;
27961: 
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: SetTextRangeList, index=%ld, rangeType=%s, range=[%lu-%lu]\n",
27961:          i, GetRangeTypeName(range.mRangeType), range.mStartOffset,
27961:          range.mEndOffset));
27961:     }
27961:   }
27961: 
27961:   if (mCursorPosition == NO_IME_CARET) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: GetTextRangeList, no caret\n"));
27961:     return;
27961:   }
27961: 
27961:   PRInt32 cursor = mCursorPosition;
27961:   if (PRUint32(cursor) > mCompositionString.Length()) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: SetTextRangeList, mCursorPosition=%ld. This is larger than mCompositionString.Length()=%lu\n",
27961:        mCursorPosition, mCompositionString.Length()));
27961:     cursor = mCompositionString.Length();
27961:   }
27961: 
27961:   range.mStartOffset = range.mEndOffset = cursor;
27961:   range.mRangeType = NS_TEXTRANGE_CARETPOSITION;
27961:   aTextRangeList.AppendElement(range);
27961: 
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: SetTextRangeList, caret position=%ld\n",
27961:      range.mStartOffset));
27961: }
27961: 
27961: void
27961: nsIMM32Handler::GetCompositionString(const nsIMEContext &aIMEContext,
27961:                                      DWORD aIndex)
27961: {
27961:   // Retrieve the size of the required output buffer.
27961:   long lRtn = ::ImmGetCompositionStringW(aIMEContext.get(), aIndex, NULL, 0);
27961:   if (lRtn < 0 ||
27961:       !EnsureStringLength(mCompositionString, (lRtn / sizeof(WCHAR)) + 1)) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: GetCompositionString, FAILED by OOM\n"));
27961:     return; // Error or out of memory.
27961:   }
27961: 
27961:   // Actually retrieve the composition string information.
27961:   lRtn = ::ImmGetCompositionStringW(aIMEContext.get(), aIndex,
27961:                                     (LPVOID)mCompositionString.BeginWriting(),
27961:                                     lRtn + sizeof(WCHAR));
27961:   mCompositionString.SetLength(lRtn / sizeof(WCHAR));
27961: 
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: GetCompositionString, SUCCEEDED mCompositionString=\"%s\"\n",
27961:      NS_ConvertUTF16toUTF8(mCompositionString).get()));
27961: }
27961: 
79445: bool
36322: nsIMM32Handler::GetTargetClauseRange(PRUint32 *aOffset, PRUint32 *aLength)
36322: {
79626:   NS_ENSURE_TRUE(aOffset, false);
79626:   NS_ENSURE_TRUE(mIsComposing, false);
79626:   NS_ENSURE_TRUE(ShouldDrawCompositionStringOurselves(), false);
36322: 
79445:   bool found = false;
36322:   *aOffset = mCompositionStart;
36322:   for (PRUint32 i = 0; i < mAttributeArray.Length(); i++) {
36322:     if (mAttributeArray[i] == ATTR_TARGET_NOTCONVERTED ||
36322:         mAttributeArray[i] == ATTR_TARGET_CONVERTED) {
36322:       *aOffset = mCompositionStart + i;
79626:       found = true;
36322:       break;
36322:     }
36322:   }
36322: 
36322:   if (!aLength) {
79626:     return true;
36322:   }
36322: 
36322:   if (!found) {
36322:     // The all composition string is targetted when there is no ATTR_TARGET_*
36322:     // clause. E.g., there is only ATTR_INPUT
36322:     *aLength = mCompositionString.Length();
79626:     return true;
36322:   }
36322: 
36322:   PRUint32 offsetInComposition = *aOffset - mCompositionStart;
36322:   *aLength = mCompositionString.Length() - offsetInComposition;
36322:   for (PRUint32 i = offsetInComposition; i < mAttributeArray.Length(); i++) {
36322:     if (mAttributeArray[i] != ATTR_TARGET_NOTCONVERTED &&
36322:         mAttributeArray[i] != ATTR_TARGET_CONVERTED) {
36322:       *aLength = i - offsetInComposition;
36322:       break;
36322:     }
36322:   }
79626:   return true;
36322: }
36322: 
79445: bool
27961: nsIMM32Handler::ConvertToANSIString(const nsAFlatString& aStr, UINT aCodePage,
27961:                                    nsACString& aANSIStr)
27961: {
27961:   int len = ::WideCharToMultiByte(aCodePage, 0,
27961:                                   (LPCWSTR)aStr.get(), aStr.Length(),
27961:                                   NULL, 0, NULL, NULL);
79626:   NS_ENSURE_TRUE(len >= 0, false);
27961: 
27961:   if (!EnsureStringLength(aANSIStr, len)) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: ConvertToANSIString, FAILED by OOM\n"));
79626:     return false;
27961:   }
27961:   ::WideCharToMultiByte(aCodePage, 0, (LPCWSTR)aStr.get(), aStr.Length(),
27961:                         (LPSTR)aANSIStr.BeginWriting(), len, NULL, NULL);
79626:   return true;
27961: }
27961: 
79445: bool
27961: nsIMM32Handler::GetCharacterRectOfSelectedTextAt(nsWindow* aWindow,
27961:                                                  PRUint32 aOffset,
27961:                                                  nsIntRect &aCharRect)
27961: {
27961:   nsIntPoint point(0, 0);
27961: 
79626:   nsQueryContentEvent selection(true, NS_QUERY_SELECTED_TEXT, aWindow);
27961:   aWindow->InitEvent(selection, &point);
27961:   aWindow->DispatchWindowEvent(&selection);
27961:   if (!selection.mSucceeded) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: GetCharacterRectOfSelectedTextAt, aOffset=%lu, FAILED (NS_QUERY_SELECTED_TEXT)\n",
27961:        aOffset));
79626:     return false;
27961:   }
27961: 
27961:   PRUint32 offset = selection.mReply.mOffset + aOffset;
79445:   bool useCaretRect = selection.mReply.mString.IsEmpty();
27961:   if (useCaretRect && ShouldDrawCompositionStringOurselves() &&
27961:       mIsComposing && !mCompositionString.IsEmpty()) {
27961:     // There is not a normal selection, but we have composition string.
27961:     // XXX mnakano - Should we implement NS_QUERY_IME_SELECTED_TEXT?
79626:     useCaretRect = false;
27961:     if (mCursorPosition != NO_IME_CARET) {
27961:       PRUint32 cursorPosition =
71173:         NS_MIN<PRUint32>(mCursorPosition, mCompositionString.Length());
27961:       offset -= cursorPosition;
27961:       NS_ASSERTION(offset >= 0, "offset is negative!");
27961:     }
27961:   }
27961: 
27961:   nsIntRect r;
27961:   if (!useCaretRect) {
79626:     nsQueryContentEvent charRect(true, NS_QUERY_TEXT_RECT, aWindow);
27961:     charRect.InitForQueryTextRect(offset, 1);
27961:     aWindow->InitEvent(charRect, &point);
27961:     aWindow->DispatchWindowEvent(&charRect);
27961:     if (charRect.mSucceeded) {
27961:       aCharRect = charRect.mReply.mRect;
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: GetCharacterRectOfSelectedTextAt, aOffset=%lu, SUCCEEDED\n",
27961:          aOffset));
27961:       PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:         ("IMM32: GetCharacterRectOfSelectedTextAt, aCharRect={ x: %ld, y: %ld, width: %ld, height: %ld }\n",
27961:          aCharRect.x, aCharRect.y, aCharRect.width, aCharRect.height));
79626:       return true;
27961:     }
27961:   }
27961: 
27961:   return GetCaretRect(aWindow, aCharRect);
27961: }
27961: 
79445: bool
27961: nsIMM32Handler::GetCaretRect(nsWindow* aWindow, nsIntRect &aCaretRect)
27961: {
27961:   nsIntPoint point(0, 0);
27961: 
79626:   nsQueryContentEvent selection(true, NS_QUERY_SELECTED_TEXT, aWindow);
27961:   aWindow->InitEvent(selection, &point);
27961:   aWindow->DispatchWindowEvent(&selection);
27961:   if (!selection.mSucceeded) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: GetCaretRect,  FAILED (NS_QUERY_SELECTED_TEXT)\n"));
79626:     return false;
27961:   }
27961: 
27961:   PRUint32 offset = selection.mReply.mOffset;
27961: 
79626:   nsQueryContentEvent caretRect(true, NS_QUERY_CARET_RECT, aWindow);
27961:   caretRect.InitForQueryCaretRect(offset);
27961:   aWindow->InitEvent(caretRect, &point);
27961:   aWindow->DispatchWindowEvent(&caretRect);
27961:   if (!caretRect.mSucceeded) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: GetCaretRect,  FAILED (NS_QUERY_CARET_RECT)\n"));
79626:     return false;
27961:   }
27961:   aCaretRect = caretRect.mReply.mRect;
27961:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:     ("IMM32: GetCaretRect, SUCCEEDED, aCaretRect={ x: %ld, y: %ld, width: %ld, height: %ld }\n",
27961:      aCaretRect.x, aCaretRect.y, aCaretRect.width, aCaretRect.height));
79626:   return true;
27961: }
27961: 
79445: bool
27961: nsIMM32Handler::SetIMERelatedWindowsPos(nsWindow* aWindow,
27961:                                         const nsIMEContext &aIMEContext)
27961: {
27961:   nsIntRect r;
27961:   // Get first character rect of current a normal selected text or a composing
27961:   // string.
79445:   bool ret = GetCharacterRectOfSelectedTextAt(aWindow, 0, r);
79626:   NS_ENSURE_TRUE(ret, false);
79626:   nsWindow* toplevelWindow = aWindow->GetTopLevelWindow(false);
27961:   nsIntRect firstSelectedCharRect;
27961:   ResolveIMECaretPos(toplevelWindow, r, aWindow, firstSelectedCharRect);
27961: 
27961:   // Set native caret size/position to our caret. Some IMEs honor it. E.g.,
27961:   // "Intelligent ABC" (Simplified Chinese) and "MS PinYin 3.0" (Simplified
27961:   // Chinese) on XP.
27961:   nsIntRect caretRect(firstSelectedCharRect);
27961:   if (GetCaretRect(aWindow, r)) {
27961:     ResolveIMECaretPos(toplevelWindow, r, aWindow, caretRect);
27961:   } else {
27961:     NS_WARNING("failed to get caret rect");
27961:     caretRect.width = 1;
27961:   }
27961:   if (!mNativeCaretIsCreated) {
27961:     mNativeCaretIsCreated = ::CreateCaret(aWindow->GetWindowHandle(), nsnull,
27961:                                           caretRect.width, caretRect.height);
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: SetIMERelatedWindowsPos, mNativeCaretIsCreated=%s, width=%ld height=%ld\n",
27961:        mNativeCaretIsCreated ? "TRUE" : "FALSE",
27961:        caretRect.width, caretRect.height));
27961:   }
27961:   ::SetCaretPos(caretRect.x, caretRect.y);
27961: 
27961:   if (ShouldDrawCompositionStringOurselves()) {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: SetIMERelatedWindowsPos, Set candidate window\n"));
27961: 
27961:     // Get a rect of first character in current target in composition string.
27961:     if (mIsComposing && !mCompositionString.IsEmpty()) {
27961:       // If there are no targetted selection, we should use it's first character
27961:       // rect instead.
36322:       PRUint32 offset;
36322:       if (!GetTargetClauseRange(&offset)) {
36322:         PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
36322:           ("IMM32: SetIMERelatedWindowsPos, FAILED, by GetTargetClauseRange\n"));
79626:         return false;
27961:       }
36322:       ret = GetCharacterRectOfSelectedTextAt(aWindow,
36322:                                              offset - mCompositionStart, r);
79626:       NS_ENSURE_TRUE(ret, false);
27961:     } else {
27961:       // If there are no composition string, we should use a first character
27961:       // rect.
27961:       ret = GetCharacterRectOfSelectedTextAt(aWindow, 0, r);
79626:       NS_ENSURE_TRUE(ret, false);
27961:     }
27961:     nsIntRect firstTargetCharRect;
27961:     ResolveIMECaretPos(toplevelWindow, r, aWindow, firstTargetCharRect);
27961: 
27961:     // Move the candidate window to first character position of the target.
27961:     CANDIDATEFORM candForm;
27961:     candForm.dwIndex = 0;
27961:     candForm.dwStyle = CFS_EXCLUDE;
27961:     candForm.ptCurrentPos.x = firstTargetCharRect.x;
27961:     candForm.ptCurrentPos.y = firstTargetCharRect.y;
27961:     candForm.rcArea.right = candForm.rcArea.left = candForm.ptCurrentPos.x;
27961:     candForm.rcArea.top = candForm.ptCurrentPos.y;
27961:     candForm.rcArea.bottom = candForm.ptCurrentPos.y +
27961:                                firstTargetCharRect.height;
27961:     ::ImmSetCandidateWindow(aIMEContext.get(), &candForm);
27961:   } else {
27961:     PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
27961:       ("IMM32: SetIMERelatedWindowsPos, Set composition window\n"));
27961: 
27961:     // Move the composition window to caret position (if selected some
27961:     // characters, we should use first character rect of them).
27961:     // And in this mode, IME adjusts the candidate window position
27961:     // automatically. So, we don't need to set it.
27961:     COMPOSITIONFORM compForm;
27961:     compForm.dwStyle = CFS_POINT;
27961:     compForm.ptCurrentPos.x = firstSelectedCharRect.x;
27961:     compForm.ptCurrentPos.y = firstSelectedCharRect.y;
27961:     ::ImmSetCompositionWindow(aIMEContext.get(), &compForm);
27961:   }
27961: 
79626:   return true;
27961: }
27961: 
27961: void
27961: nsIMM32Handler::ResolveIMECaretPos(nsIWidget* aReferenceWidget,
27961:                                    nsIntRect& aCursorRect,
27961:                                    nsIWidget* aNewOriginWidget,
27961:                                    nsIntRect& aOutRect)
27961: {
27961:   aOutRect = aCursorRect;
27961: 
27961:   if (aReferenceWidget == aNewOriginWidget)
27961:     return;
27961: 
27961:   if (aReferenceWidget)
27961:     aOutRect.MoveBy(aReferenceWidget->WidgetToScreenOffset());
27961: 
27961:   if (aNewOriginWidget)
27961:     aOutRect.MoveBy(-aNewOriginWidget->WidgetToScreenOffset());
27961: }
27961: 
79445: bool
27961: nsIMM32Handler::OnMouseEvent(nsWindow* aWindow, LPARAM lParam, int aAction)
27961: {
80863:   if (!sWM_MSIME_MOUSE || !mIsComposing ||
80863:       !ShouldDrawCompositionStringOurselves()) {
79626:     return false;
27961:   }
27961: 
28352:   nsIntPoint cursor(LOWORD(lParam), HIWORD(lParam));
79626:   nsQueryContentEvent charAtPt(true, NS_QUERY_CHARACTER_AT_POINT, aWindow);
28352:   aWindow->InitEvent(charAtPt, &cursor);
28352:   aWindow->DispatchWindowEvent(&charAtPt);
28352:   if (!charAtPt.mSucceeded ||
28352:       charAtPt.mReply.mOffset == nsQueryContentEvent::NOT_FOUND ||
28352:       charAtPt.mReply.mOffset < mCompositionStart ||
28352:       charAtPt.mReply.mOffset >
28352:         mCompositionStart + mCompositionString.Length()) {
79626:     return false;
27961:   }
27961: 
27961:   // calcurate positioning and offset
27961:   // char :            JCH1|JCH2|JCH3
27961:   // offset:           0011 1122 2233
27961:   // positioning:      2301 2301 2301
36728:   nsIntRect cursorInTopLevel, cursorRect(cursor, nsIntSize(0, 0));
36728:   ResolveIMECaretPos(aWindow, cursorRect,
79626:                      aWindow->GetTopLevelWindow(false), cursorInTopLevel);
28352:   PRInt32 cursorXInChar = cursorInTopLevel.x - charAtPt.mReply.mRect.x;
80863:   // The event might hit to zero-width character, see bug 694913.
80863:   // The reason might be:
80863:   // * There are some zero-width characters are actually.
80863:   // * font-size is specified zero.
80863:   // But nobody reproduced this bug actually...
80863:   // We should assume that user clicked on right most of the zero-width
80863:   // character in such case.
80863:   int positioning = 1;
80863:   if (charAtPt.mReply.mRect.width > 0) {
80863:     positioning = cursorXInChar * 4 / charAtPt.mReply.mRect.width;
28352:     positioning = (positioning + 2) % 4;
80863:   }
27961: 
28352:   int offset = charAtPt.mReply.mOffset - mCompositionStart;
28352:   if (positioning < 2) {
27961:     offset++;
27961:   }
27961: 
28352:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
28352:     ("IMM32: OnMouseEvent, x,y=%ld,%ld, offset=%ld, positioning=%ld\n",
28352:      cursor.x, cursor.y, offset, positioning));
27961: 
27961:   // send MS_MSIME_MOUSE message to default IME window.
27961:   HWND imeWnd = ::ImmGetDefaultIMEWnd(aWindow->GetWindowHandle());
27961:   nsIMEContext IMEContext(aWindow->GetWindowHandle());
27961:   return ::SendMessageW(imeWnd, sWM_MSIME_MOUSE,
27961:                         MAKELONG(MAKEWORD(aAction, positioning), offset),
27961:                         (LPARAM) IMEContext.get()) == 1;
27961: }
27961: 
79445: /* static */ bool
43005: nsIMM32Handler::OnKeyDownEvent(nsWindow* aWindow, WPARAM wParam, LPARAM lParam,
79445:                                bool &aEatMessage)
43005: {
43005:   PR_LOG(gIMM32Log, PR_LOG_ALWAYS,
43005:     ("IMM32: OnKeyDownEvent, hWnd=%08x, wParam=%08x, lParam=%08x\n",
43005:      aWindow->GetWindowHandle(), wParam, lParam));
79626:   aEatMessage = false;
43005:   switch (wParam) {
43005:     case VK_PROCESSKEY:
43005:       // If we receive when IME isn't open, it means IME is opening right now.
43005:       if (sIsIME) {
43005:         nsIMEContext IMEContext(aWindow->GetWindowHandle());
43005:         sIsIMEOpening =
43005:           IMEContext.IsValid() && !::ImmGetOpenStatus(IMEContext.get());
43005:       }
79626:       return false;
53868:     case VK_TAB:
53868:     case VK_PRIOR:
53868:     case VK_NEXT:
53868:     case VK_END:
53868:     case VK_HOME:
53868:     case VK_LEFT:
53868:     case VK_UP:
53868:     case VK_RIGHT:
53868:     case VK_DOWN:
53868:       // If IME didn't process the key message (the virtual key code wasn't
53868:       // converted to VK_PROCESSKEY), and the virtual key code event causes
53868:       // to move caret, we should cancel the composition here.  Then, this
53868:       // event will be dispatched.
53868:       // XXX I think that we should dispatch all key events during composition,
53868:       //     and nsEditor should cancel/commit the composition if it *thinks*
53868:       //     it's needed.
53868:       if (IsComposingOnOurEditor()) {
53868:         // NOTE: We don't need to cancel the composition on another window.
79626:         CancelComposition(aWindow, false);
53868:       }
79626:       return false;
43005:     default:
79626:       return false;
43005:   }
43005: }
