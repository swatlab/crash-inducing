    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
    1: /* ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * IBM Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2003
    1:  * IBM Corporation. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   IBM Corporation
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /*
    1:  * Storage of the children and attributes of a DOM node; storage for
    1:  * the two is unified to minimize footprint.
    1:  */
    1: 
    1: #include "nsAttrAndChildArray.h"
10073: #include "nsMappedAttributeElement.h"
    1: #include "prmem.h"
    1: #include "prbit.h"
    1: #include "nsString.h"
    1: #include "nsHTMLStyleSheet.h"
    1: #include "nsRuleWalker.h"
    1: #include "nsMappedAttributes.h"
    1: #include "nsUnicharUtils.h"
    1: #include "nsAutoPtr.h"
75263: #include "nsContentUtils.h" // nsAutoScriptBlocker
    1: 
    1: /*
    1: CACHE_POINTER_SHIFT indicates how many steps to downshift the |this| pointer.
    1: It should be small enough to not cause collisions between adjecent arrays, and
    1: large enough to make sure that all indexes are used. The size below is based
    1: on the size of the smallest possible element (currently 24[*] bytes) which is
    1: the smallest distance between two nsAttrAndChildArray. 24/(2^_5_) is 0.75.
    1: This means that two adjacent nsAttrAndChildArrays will overlap one in 4 times.
    1: However not all elements will have enough children to get cached. And any
    1: allocator that doesn't return addresses aligned to 64 bytes will ensure that
    1: any index will get used.
    1: 
    1: [*] sizeof(nsGenericElement) + 4 bytes for nsIDOMElement vtable pointer.
    1: */
    1: 
    1: #define CACHE_POINTER_SHIFT 5
    1: #define CACHE_NUM_SLOTS 128
    1: #define CACHE_CHILD_LIMIT 10
    1: 
    1: #define CACHE_GET_INDEX(_array) \
    1:   ((NS_PTR_TO_INT32(_array) >> CACHE_POINTER_SHIFT) & \
    1:    (CACHE_NUM_SLOTS - 1))
    1: 
    1: struct IndexCacheSlot
    1: {
    1:   const nsAttrAndChildArray* array;
    1:   PRInt32 index;
    1: };
    1: 
    1: // This is inited to all zeroes since it's static. Though even if it wasn't
    1: // the worst thing that'd happen is a small inefficency if you'd get a false
    1: // positive cachehit.
    1: static IndexCacheSlot indexCache[CACHE_NUM_SLOTS];
    1: 
    1: static
    1: inline
    1: void
    1: AddIndexToCache(const nsAttrAndChildArray* aArray, PRInt32 aIndex)
    1: {
    1:   PRUint32 ix = CACHE_GET_INDEX(aArray);
    1:   indexCache[ix].array = aArray;
    1:   indexCache[ix].index = aIndex;
    1: }
    1: 
    1: static
    1: inline
    1: PRInt32
    1: GetIndexFromCache(const nsAttrAndChildArray* aArray)
    1: {
    1:   PRUint32 ix = CACHE_GET_INDEX(aArray);
    1:   return indexCache[ix].array == aArray ? indexCache[ix].index : -1;
    1: }
    1: 
    1: 
    1: /**
    1:  * Due to a compiler bug in VisualAge C++ for AIX, we need to return the 
    1:  * address of the first index into mBuffer here, instead of simply returning 
    1:  * mBuffer itself.
    1:  *
    1:  * See Bug 231104 for more information.
    1:  */
    1: #define ATTRS(_impl) \
 3233:   reinterpret_cast<InternalAttr*>(&((_impl)->mBuffer[0]))
    1:   
    1: 
    1: #define NS_IMPL_EXTRA_SIZE \
    1:   ((sizeof(Impl) - sizeof(mImpl->mBuffer)) / sizeof(void*))
    1: 
11169: nsAttrAndChildArray::nsAttrAndChildArray()
11169:   : mImpl(nsnull)
    1: {
    1: }
    1: 
    1: nsAttrAndChildArray::~nsAttrAndChildArray()
    1: {
11169:   if (!mImpl) {
11169:     return;
    1:   }
    1: 
11169:   Clear();
    1: 
11169:   PR_Free(mImpl);
    1: }
    1: 
    1: nsIContent*
    1: nsAttrAndChildArray::GetSafeChildAt(PRUint32 aPos) const
    1: {
    1:   if (aPos < ChildCount()) {
    1:     return ChildAt(aPos);
    1:   }
    1:   
    1:   return nsnull;
    1: }
    1: 
15810: nsIContent * const *
22251: nsAttrAndChildArray::GetChildArray(PRUint32* aChildCount) const
15810: {
22251:   *aChildCount = ChildCount();
22251:   
22251:   if (!*aChildCount) {
15810:     return nsnull;
15810:   }
15810:   
15810:   return reinterpret_cast<nsIContent**>(mImpl->mBuffer + AttrSlotsSize());
15810: }
15810: 
    1: nsresult
    1: nsAttrAndChildArray::InsertChildAt(nsIContent* aChild, PRUint32 aPos)
    1: {
    1:   NS_ASSERTION(aChild, "nullchild");
    1:   NS_ASSERTION(aPos <= ChildCount(), "out-of-bounds");
    1: 
    1:   PRUint32 offset = AttrSlotsSize();
    1:   PRUint32 childCount = ChildCount();
    1: 
    1:   NS_ENSURE_TRUE(childCount < ATTRCHILD_ARRAY_MAX_CHILD_COUNT,
    1:                  NS_ERROR_FAILURE);
    1: 
    1:   // First try to fit new child in existing childlist
    1:   if (mImpl && offset + childCount < mImpl->mBufferSize) {
    1:     void** pos = mImpl->mBuffer + offset + aPos;
    1:     if (childCount != aPos) {
    1:       memmove(pos + 1, pos, (childCount - aPos) * sizeof(nsIContent*));
    1:     }
42104:     SetChildAtPos(pos, aChild, aPos, childCount);
    1: 
    1:     SetChildCount(childCount + 1);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // Try to fit new child in existing buffer by compressing attrslots
    1:   if (offset && !mImpl->mBuffer[offset - ATTRSIZE]) {
    1:     // Compress away all empty slots while we're at it. This might not be the
    1:     // optimal thing to do.
    1:     PRUint32 attrCount = NonMappedAttrCount();
    1:     void** newStart = mImpl->mBuffer + attrCount * ATTRSIZE;
    1:     void** oldStart = mImpl->mBuffer + offset;
    1:     memmove(newStart, oldStart, aPos * sizeof(nsIContent*));
    1:     memmove(&newStart[aPos + 1], &oldStart[aPos],
    1:             (childCount - aPos) * sizeof(nsIContent*));
42104:     SetChildAtPos(newStart + aPos, aChild, aPos, childCount);
    1: 
    1:     SetAttrSlotAndChildCount(attrCount, childCount + 1);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   // We can't fit in current buffer, Realloc time!
    1:   if (!GrowBy(1)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   void** pos = mImpl->mBuffer + offset + aPos;
    1:   if (childCount != aPos) {
    1:     memmove(pos + 1, pos, (childCount - aPos) * sizeof(nsIContent*));
    1:   }
42104:   SetChildAtPos(pos, aChild, aPos, childCount);
    1: 
    1:   SetChildCount(childCount + 1);
    1:   
    1:   return NS_OK;
    1: }
    1: 
    1: void
    1: nsAttrAndChildArray::RemoveChildAt(PRUint32 aPos)
    1: {
79161:   // Just store the return value of TakeChildAt in an nsCOMPtr to
79161:   // trigger a release.
79161:   nsCOMPtr<nsIContent> child = TakeChildAt(aPos);
79161: }
79161: 
79161: already_AddRefed<nsIContent>
79161: nsAttrAndChildArray::TakeChildAt(PRUint32 aPos)
79161: {
    1:   NS_ASSERTION(aPos < ChildCount(), "out-of-bounds");
    1: 
    1:   PRUint32 childCount = ChildCount();
    1:   void** pos = mImpl->mBuffer + AttrSlotsSize() + aPos;
 3233:   nsIContent* child = static_cast<nsIContent*>(*pos);
42104:   if (child->mPreviousSibling) {
42104:     child->mPreviousSibling->mNextSibling = child->mNextSibling;
42104:   }
42104:   if (child->mNextSibling) {
42104:     child->mNextSibling->mPreviousSibling = child->mPreviousSibling;
42104:   }
42104:   child->mPreviousSibling = child->mNextSibling = nsnull;
42104: 
    1:   memmove(pos, pos + 1, (childCount - aPos - 1) * sizeof(nsIContent*));
    1:   SetChildCount(childCount - 1);
79161: 
79161:   return child;
    1: }
    1: 
    1: PRInt32
    1: nsAttrAndChildArray::IndexOfChild(nsINode* aPossibleChild) const
    1: {
    1:   if (!mImpl) {
    1:     return -1;
    1:   }
    1:   void** children = mImpl->mBuffer + AttrSlotsSize();
    1:   // Use signed here since we compare count to cursor which has to be signed
    1:   PRInt32 i, count = ChildCount();
    1: 
    1:   if (count >= CACHE_CHILD_LIMIT) {
    1:     PRInt32 cursor = GetIndexFromCache(this);
    1:     // Need to compare to count here since we may have removed children since
    1:     // the index was added to the cache.
    1:     // We're also relying on that GetIndexFromCache returns -1 if no cached
    1:     // index was found.
    1:     if (cursor >= count) {
    1:       cursor = -1;
    1:     }
    1: 
    1:     // Seek outward from the last found index. |inc| will change sign every
    1:     // run through the loop. |sign| just exists to make sure the absolute
    1:     // value of |inc| increases each time through.
    1:     PRInt32 inc = 1, sign = 1;
    1:     while (cursor >= 0 && cursor < count) {
    1:       if (children[cursor] == aPossibleChild) {
    1:         AddIndexToCache(this, cursor);
    1: 
    1:         return cursor;
    1:       }
    1: 
    1:       cursor += inc;
    1:       inc = -inc - sign;
    1:       sign = -sign;
    1:     }
    1: 
    1:     // We ran into one 'edge'. Add inc to cursor once more to get back to
    1:     // the 'side' where we still need to search, then step in the |sign|
    1:     // direction.
    1:     cursor += inc;
    1: 
    1:     if (sign > 0) {
    1:       for (; cursor < count; ++cursor) {
    1:         if (children[cursor] == aPossibleChild) {
    1:           AddIndexToCache(this, cursor);
    1: 
 3233:           return static_cast<PRInt32>(cursor);
    1:         }
    1:       }
    1:     }
    1:     else {
    1:       for (; cursor >= 0; --cursor) {
    1:         if (children[cursor] == aPossibleChild) {
    1:           AddIndexToCache(this, cursor);
    1: 
 3233:           return static_cast<PRInt32>(cursor);
    1:         }
    1:       }
    1:     }
    1: 
    1:     // The child wasn't even in the remaining children
    1:     return -1;
    1:   }
    1: 
    1:   for (i = 0; i < count; ++i) {
    1:     if (children[i] == aPossibleChild) {
 3233:       return static_cast<PRInt32>(i);
    1:     }
    1:   }
    1: 
    1:   return -1;
    1: }
    1: 
    1: PRUint32
    1: nsAttrAndChildArray::AttrCount() const
    1: {
    1:   return NonMappedAttrCount() + MappedAttrCount();
    1: }
    1: 
    1: const nsAttrValue*
    1: nsAttrAndChildArray::GetAttr(nsIAtom* aLocalName, PRInt32 aNamespaceID) const
    1: {
    1:   PRUint32 i, slotCount = AttrSlotCount();
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     // This should be the common case so lets make an optimized loop
59211:     for (i = 0; i < slotCount && AttrSlotIsTaken(i); ++i) {
    1:       if (ATTRS(mImpl)[i].mName.Equals(aLocalName)) {
    1:         return &ATTRS(mImpl)[i].mValue;
    1:       }
    1:     }
    1: 
    1:     if (mImpl && mImpl->mMappedAttrs) {
    1:       return mImpl->mMappedAttrs->GetAttr(aLocalName);
    1:     }
    1:   }
    1:   else {
59211:     for (i = 0; i < slotCount && AttrSlotIsTaken(i); ++i) {
    1:       if (ATTRS(mImpl)[i].mName.Equals(aLocalName, aNamespaceID)) {
    1:         return &ATTRS(mImpl)[i].mValue;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: const nsAttrValue*
    1: nsAttrAndChildArray::AttrAt(PRUint32 aPos) const
    1: {
    1:   NS_ASSERTION(aPos < AttrCount(),
    1:                "out-of-bounds access in nsAttrAndChildArray");
    1: 
    1:   PRUint32 mapped = MappedAttrCount();
    1:   if (aPos < mapped) {
    1:     return mImpl->mMappedAttrs->AttrAt(aPos);
    1:   }
    1: 
    1:   return &ATTRS(mImpl)[aPos - mapped].mValue;
    1: }
    1: 
    1: nsresult
    1: nsAttrAndChildArray::SetAttr(nsIAtom* aLocalName, const nsAString& aValue)
    1: {
    1:   PRUint32 i, slotCount = AttrSlotCount();
59211:   for (i = 0; i < slotCount && AttrSlotIsTaken(i); ++i) {
    1:     if (ATTRS(mImpl)[i].mName.Equals(aLocalName)) {
    1:       ATTRS(mImpl)[i].mValue.SetTo(aValue);
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(slotCount < ATTRCHILD_ARRAY_MAX_ATTR_COUNT,
    1:                  NS_ERROR_FAILURE);
    1: 
    1:   if (i == slotCount && !AddAttrSlot()) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   new (&ATTRS(mImpl)[i].mName) nsAttrName(aLocalName);
    1:   new (&ATTRS(mImpl)[i].mValue) nsAttrValue(aValue);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAttrAndChildArray::SetAndTakeAttr(nsIAtom* aLocalName, nsAttrValue& aValue)
    1: {
    1:   PRUint32 i, slotCount = AttrSlotCount();
59211:   for (i = 0; i < slotCount && AttrSlotIsTaken(i); ++i) {
    1:     if (ATTRS(mImpl)[i].mName.Equals(aLocalName)) {
    1:       ATTRS(mImpl)[i].mValue.Reset();
    1:       ATTRS(mImpl)[i].mValue.SwapValueWith(aValue);
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(i < ATTRCHILD_ARRAY_MAX_ATTR_COUNT,
    1:                  NS_ERROR_FAILURE);
    1: 
    1:   if (i == slotCount && !AddAttrSlot()) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   new (&ATTRS(mImpl)[i].mName) nsAttrName(aLocalName);
    1:   new (&ATTRS(mImpl)[i].mValue) nsAttrValue();
    1:   ATTRS(mImpl)[i].mValue.SwapValueWith(aValue);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAttrAndChildArray::SetAndTakeAttr(nsINodeInfo* aName, nsAttrValue& aValue)
    1: {
    1:   PRInt32 namespaceID = aName->NamespaceID();
    1:   nsIAtom* localName = aName->NameAtom();
    1:   if (namespaceID == kNameSpaceID_None) {
    1:     return SetAndTakeAttr(localName, aValue);
    1:   }
    1: 
    1:   PRUint32 i, slotCount = AttrSlotCount();
59211:   for (i = 0; i < slotCount && AttrSlotIsTaken(i); ++i) {
    1:     if (ATTRS(mImpl)[i].mName.Equals(localName, namespaceID)) {
    1:       ATTRS(mImpl)[i].mName.SetTo(aName);
    1:       ATTRS(mImpl)[i].mValue.Reset();
    1:       ATTRS(mImpl)[i].mValue.SwapValueWith(aValue);
    1: 
    1:       return NS_OK;
    1:     }
    1:   }
    1: 
    1:   NS_ENSURE_TRUE(i < ATTRCHILD_ARRAY_MAX_ATTR_COUNT,
    1:                  NS_ERROR_FAILURE);
    1: 
    1:   if (i == slotCount && !AddAttrSlot()) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   new (&ATTRS(mImpl)[i].mName) nsAttrName(aName);
    1:   new (&ATTRS(mImpl)[i].mValue) nsAttrValue();
    1:   ATTRS(mImpl)[i].mValue.SwapValueWith(aValue);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: nsresult
    1: nsAttrAndChildArray::RemoveAttrAt(PRUint32 aPos, nsAttrValue& aValue)
    1: {
    1:   NS_ASSERTION(aPos < AttrCount(), "out-of-bounds");
    1: 
    1:   PRUint32 mapped = MappedAttrCount();
    1:   if (aPos < mapped) {
    1:     if (mapped == 1) {
    1:       // We're removing the last mapped attribute.  Can't swap in this
    1:       // case; have to copy.
    1:       aValue.SetTo(*mImpl->mMappedAttrs->AttrAt(0));
    1:       NS_RELEASE(mImpl->mMappedAttrs);
    1: 
    1:       return NS_OK;
    1:     }
    1: 
    1:     nsRefPtr<nsMappedAttributes> mapped;
    1:     nsresult rv = GetModifiableMapped(nsnull, nsnull, PR_FALSE,
    1:                                       getter_AddRefs(mapped));
    1:     NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:     mapped->RemoveAttrAt(aPos, aValue);
    1: 
    1:     return MakeMappedUnique(mapped);
    1:   }
    1: 
    1:   aPos -= mapped;
    1:   ATTRS(mImpl)[aPos].mValue.SwapValueWith(aValue);
    1:   ATTRS(mImpl)[aPos].~InternalAttr();
    1: 
    1:   PRUint32 slotCount = AttrSlotCount();
    1:   memmove(&ATTRS(mImpl)[aPos],
    1:           &ATTRS(mImpl)[aPos + 1],
    1:           (slotCount - aPos - 1) * sizeof(InternalAttr));
    1:   memset(&ATTRS(mImpl)[slotCount - 1], nsnull, sizeof(InternalAttr));
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: const nsAttrName*
    1: nsAttrAndChildArray::AttrNameAt(PRUint32 aPos) const
    1: {
    1:   NS_ASSERTION(aPos < AttrCount(),
    1:                "out-of-bounds access in nsAttrAndChildArray");
    1: 
    1:   PRUint32 mapped = MappedAttrCount();
    1:   if (aPos < mapped) {
    1:     return mImpl->mMappedAttrs->NameAt(aPos);
    1:   }
    1: 
    1:   return &ATTRS(mImpl)[aPos - mapped].mName;
    1: }
    1: 
    1: const nsAttrName*
    1: nsAttrAndChildArray::GetSafeAttrNameAt(PRUint32 aPos) const
    1: {
    1:   PRUint32 mapped = MappedAttrCount();
    1:   if (aPos < mapped) {
    1:     return mImpl->mMappedAttrs->NameAt(aPos);
    1:   }
    1: 
    1:   aPos -= mapped;
    1:   if (aPos >= AttrSlotCount()) {
    1:     return nsnull;
    1:   }
    1: 
    1:   void** pos = mImpl->mBuffer + aPos * ATTRSIZE;
    1:   if (!*pos) {
    1:     return nsnull;
    1:   }
    1: 
 3233:   return &reinterpret_cast<InternalAttr*>(pos)->mName;
    1: }
    1: 
    1: const nsAttrName*
39101: nsAttrAndChildArray::GetExistingAttrNameFromQName(const nsAString& aName) const
    1: {
    1:   PRUint32 i, slotCount = AttrSlotCount();
59211:   for (i = 0; i < slotCount && AttrSlotIsTaken(i); ++i) {
    1:     if (ATTRS(mImpl)[i].mName.QualifiedNameEquals(aName)) {
    1:       return &ATTRS(mImpl)[i].mName;
    1:     }
    1:   }
    1: 
    1:   if (mImpl && mImpl->mMappedAttrs) {
    1:     return mImpl->mMappedAttrs->GetExistingAttrNameFromQName(aName);
    1:   }
    1: 
    1:   return nsnull;
    1: }
    1: 
    1: PRInt32
    1: nsAttrAndChildArray::IndexOfAttr(nsIAtom* aLocalName, PRInt32 aNamespaceID) const
    1: {
    1:   PRInt32 idx;
    1:   if (mImpl && mImpl->mMappedAttrs) {
    1:     idx = mImpl->mMappedAttrs->IndexOfAttr(aLocalName, aNamespaceID);
    1:     if (idx >= 0) {
    1:       return idx;
    1:     }
    1:   }
    1: 
    1:   PRUint32 i;
    1:   PRUint32 mapped = MappedAttrCount();
    1:   PRUint32 slotCount = AttrSlotCount();
    1:   if (aNamespaceID == kNameSpaceID_None) {
    1:     // This should be the common case so lets make an optimized loop
59211:     for (i = 0; i < slotCount && AttrSlotIsTaken(i); ++i) {
    1:       if (ATTRS(mImpl)[i].mName.Equals(aLocalName)) {
    1:         return i + mapped;
    1:       }
    1:     }
    1:   }
    1:   else {
59211:     for (i = 0; i < slotCount && AttrSlotIsTaken(i); ++i) {
    1:       if (ATTRS(mImpl)[i].mName.Equals(aLocalName, aNamespaceID)) {
    1:         return i + mapped;
    1:       }
    1:     }
    1:   }
    1: 
    1:   return -1;
    1: }
    1: 
    1: nsresult
    1: nsAttrAndChildArray::SetAndTakeMappedAttr(nsIAtom* aLocalName,
    1:                                           nsAttrValue& aValue,
10073:                                           nsMappedAttributeElement* aContent,
    1:                                           nsHTMLStyleSheet* aSheet)
    1: {
    1:   nsRefPtr<nsMappedAttributes> mapped;
77138: 
77138:   PRBool willAdd = PR_TRUE;
77138:   if (mImpl && mImpl->mMappedAttrs) {
77138:     willAdd = mImpl->mMappedAttrs->GetAttr(aLocalName) == nsnull;
77138:   }
77138: 
77138:   nsresult rv = GetModifiableMapped(aContent, aSheet, willAdd,
    1:                                     getter_AddRefs(mapped));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   rv = mapped->SetAndTakeAttr(aLocalName, aValue);
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   return MakeMappedUnique(mapped);
    1: }
    1: 
    1: nsresult
    1: nsAttrAndChildArray::SetMappedAttrStyleSheet(nsHTMLStyleSheet* aSheet)
    1: {
    1:   if (!mImpl || !mImpl->mMappedAttrs ||
    1:       aSheet == mImpl->mMappedAttrs->GetStyleSheet()) {
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsRefPtr<nsMappedAttributes> mapped;
    1:   nsresult rv = GetModifiableMapped(nsnull, nsnull, PR_FALSE, 
    1:                                     getter_AddRefs(mapped));
    1:   NS_ENSURE_SUCCESS(rv, rv);
    1: 
    1:   mapped->SetStyleSheet(aSheet);
    1: 
    1:   return MakeMappedUnique(mapped);
    1: }
    1: 
    1: void
    1: nsAttrAndChildArray::WalkMappedAttributeStyleRules(nsRuleWalker* aRuleWalker)
    1: {
40518:   if (mImpl && mImpl->mMappedAttrs) {
    1:     aRuleWalker->Forward(mImpl->mMappedAttrs);
    1:   }
    1: }
    1: 
    1: void
11169: nsAttrAndChildArray::Compact()
11169: {
11169:   if (!mImpl) {
11169:     return;
11169:   }
11169: 
11169:   // First compress away empty attrslots
11169:   PRUint32 slotCount = AttrSlotCount();
11169:   PRUint32 attrCount = NonMappedAttrCount();
11169:   PRUint32 childCount = ChildCount();
11169: 
11169:   if (attrCount < slotCount) {
11169:     memmove(mImpl->mBuffer + attrCount * ATTRSIZE,
11169:             mImpl->mBuffer + slotCount * ATTRSIZE,
11169:             childCount * sizeof(nsIContent*));
11169:     SetAttrSlotCount(attrCount);
11169:   }
11169: 
11169:   // Then resize or free buffer
11169:   PRUint32 newSize = attrCount * ATTRSIZE + childCount;
11169:   if (!newSize && !mImpl->mMappedAttrs) {
11169:     PR_Free(mImpl);
11169:     mImpl = nsnull;
11169:   }
11169:   else if (newSize < mImpl->mBufferSize) {
11169:     mImpl = static_cast<Impl*>(PR_Realloc(mImpl, (newSize + NS_IMPL_EXTRA_SIZE) * sizeof(nsIContent*)));
11169:     NS_ASSERTION(mImpl, "failed to reallocate to smaller buffer");
11169: 
11169:     mImpl->mBufferSize = newSize;
11169:   }
11169: }
11169: 
11169: void
    1: nsAttrAndChildArray::Clear()
    1: {
    1:   if (!mImpl) {
    1:     return;
    1:   }
    1: 
    1:   if (mImpl->mMappedAttrs) {
    1:     NS_RELEASE(mImpl->mMappedAttrs);
    1:   }
    1: 
    1:   PRUint32 i, slotCount = AttrSlotCount();
59211:   for (i = 0; i < slotCount && AttrSlotIsTaken(i); ++i) {
    1:     ATTRS(mImpl)[i].~InternalAttr();
    1:   }
    1: 
14228:   nsAutoScriptBlocker scriptBlocker;
    1:   PRUint32 end = slotCount * ATTRSIZE + ChildCount();
    1:   for (i = slotCount * ATTRSIZE; i < end; ++i) {
 3233:     nsIContent* child = static_cast<nsIContent*>(mImpl->mBuffer[i]);
    1:     // making this PR_FALSE so tree teardown doesn't end up being
    1:     // O(N*D) (number of nodes times average depth of tree).
    1:     child->UnbindFromTree(PR_FALSE); // XXX is it better to let the owner do this?
42183:     // Make sure to unlink our kids from each other, since someone
42183:     // else could stil be holding references to some of them.
42183: 
42183:     // XXXbz We probably can't push this assignment down into the |aNullParent|
42183:     // case of UnbindFromTree because we still need the assignment in
42183:     // RemoveChildAt.  In particular, ContentRemoved fires between
42183:     // RemoveChildAt and UnbindFromTree, and in ContentRemoved the sibling
42183:     // chain needs to be correct.  Though maybe we could set the prev and next
42183:     // to point to each other but keep the kid being removed pointing to them
42183:     // through ContentRemoved so consumers can find where it used to be in the
42183:     // list?
42183:     child->mPreviousSibling = child->mNextSibling = nsnull;
    1:     NS_RELEASE(child);
    1:   }
    1: 
    1:   SetAttrSlotAndChildCount(0, 0);
    1: }
    1: 
    1: PRUint32
    1: nsAttrAndChildArray::NonMappedAttrCount() const
    1: {
    1:   if (!mImpl) {
    1:     return 0;
    1:   }
    1: 
    1:   PRUint32 count = AttrSlotCount();
    1:   while (count > 0 && !mImpl->mBuffer[(count - 1) * ATTRSIZE]) {
    1:     --count;
    1:   }
    1: 
    1:   return count;
    1: }
    1: 
    1: PRUint32
    1: nsAttrAndChildArray::MappedAttrCount() const
    1: {
    1:   return mImpl && mImpl->mMappedAttrs ? (PRUint32)mImpl->mMappedAttrs->Count() : 0;
    1: }
    1: 
    1: nsresult
10073: nsAttrAndChildArray::GetModifiableMapped(nsMappedAttributeElement* aContent,
    1:                                          nsHTMLStyleSheet* aSheet,
    1:                                          PRBool aWillAddAttr,
    1:                                          nsMappedAttributes** aModifiable)
    1: {
    1:   *aModifiable = nsnull;
    1: 
    1:   if (mImpl && mImpl->mMappedAttrs) {
    1:     *aModifiable = mImpl->mMappedAttrs->Clone(aWillAddAttr);
    1:     NS_ENSURE_TRUE(*aModifiable, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:     NS_ADDREF(*aModifiable);
    1:     
    1:     return NS_OK;
    1:   }
    1: 
    1:   NS_ASSERTION(aContent, "Trying to create modifiable without content");
    1: 
    1:   nsMapRuleToAttributesFunc mapRuleFunc =
    1:     aContent->GetAttributeMappingFunction();
    1:   *aModifiable = new nsMappedAttributes(aSheet, mapRuleFunc);
    1:   NS_ENSURE_TRUE(*aModifiable, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   NS_ADDREF(*aModifiable);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: nsresult
    1: nsAttrAndChildArray::MakeMappedUnique(nsMappedAttributes* aAttributes)
    1: {
    1:   NS_ASSERTION(aAttributes, "missing attributes");
    1: 
    1:   if (!mImpl && !GrowBy(1)) {
    1:     return NS_ERROR_OUT_OF_MEMORY;
    1:   }
    1: 
    1:   if (!aAttributes->GetStyleSheet()) {
    1:     // This doesn't currently happen, but it could if we do loading right
    1: 
    1:     nsRefPtr<nsMappedAttributes> mapped(aAttributes);
    1:     mapped.swap(mImpl->mMappedAttrs);
    1: 
    1:     return NS_OK;
    1:   }
    1: 
    1:   nsRefPtr<nsMappedAttributes> mapped =
    1:     aAttributes->GetStyleSheet()->UniqueMappedAttributes(aAttributes);
    1:   NS_ENSURE_TRUE(mapped, NS_ERROR_OUT_OF_MEMORY);
    1: 
    1:   if (mapped != aAttributes) {
    1:     // Reset the stylesheet of aAttributes so that it doesn't spend time
    1:     // trying to remove itself from the hash. There is no risk that aAttributes
    1:     // is in the hash since it will always have come from GetModifiableMapped,
    1:     // which never returns maps that are in the hash (such hashes are by
    1:     // nature not modifiable).
    1:     aAttributes->DropStyleSheetReference();
    1:   }
    1:   mapped.swap(mImpl->mMappedAttrs);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: 
    1: PRBool
    1: nsAttrAndChildArray::GrowBy(PRUint32 aGrowSize)
    1: {
    1:   PRUint32 size = mImpl ? mImpl->mBufferSize + NS_IMPL_EXTRA_SIZE : 0;
    1:   PRUint32 minSize = size + aGrowSize;
    1: 
    1:   if (minSize <= ATTRCHILD_ARRAY_LINEAR_THRESHOLD) {
    1:     do {
    1:       size += ATTRCHILD_ARRAY_GROWSIZE;
    1:     } while (size < minSize);
    1:   }
    1:   else {
    1:     size = PR_BIT(PR_CeilingLog2(minSize));
    1:   }
    1: 
30570:   PRBool needToInitialize = !mImpl;
30570:   Impl* newImpl = static_cast<Impl*>(PR_Realloc(mImpl, size * sizeof(void*)));
    1:   NS_ENSURE_TRUE(newImpl, PR_FALSE);
11169: 
    1:   mImpl = newImpl;
11169: 
    1:   // Set initial counts if we didn't have a buffer before
30570:   if (needToInitialize) {
    1:     mImpl->mMappedAttrs = nsnull;
    1:     SetAttrSlotAndChildCount(0, 0);
    1:   }
    1: 
    1:   mImpl->mBufferSize = size - NS_IMPL_EXTRA_SIZE;
    1: 
    1:   return PR_TRUE;
    1: }
    1: 
    1: PRBool
    1: nsAttrAndChildArray::AddAttrSlot()
    1: {
    1:   PRUint32 slotCount = AttrSlotCount();
    1:   PRUint32 childCount = ChildCount();
    1: 
    1:   // Grow buffer if needed
    1:   if (!(mImpl && mImpl->mBufferSize >= (slotCount + 1) * ATTRSIZE + childCount) &&
    1:       !GrowBy(ATTRSIZE)) {
    1:     return PR_FALSE;
    1:   }
    1:   void** offset = mImpl->mBuffer + slotCount * ATTRSIZE;
    1: 
    1:   if (childCount > 0) {
    1:     memmove(&ATTRS(mImpl)[slotCount + 1], &ATTRS(mImpl)[slotCount],
    1:             childCount * sizeof(nsIContent*));
    1:   }
    1: 
    1:   SetAttrSlotCount(slotCount + 1);
    1:   offset[0] = nsnull;
    1:   offset[1] = nsnull;
    1: 
    1:   return PR_TRUE;
    1: }
42104: 
42104: inline void
42104: nsAttrAndChildArray::SetChildAtPos(void** aPos, nsIContent* aChild,
42104:                                    PRUint32 aIndex, PRUint32 aChildCount)
42104: {
42104:   NS_PRECONDITION(!aChild->GetNextSibling(), "aChild with next sibling?");
42104:   NS_PRECONDITION(!aChild->GetPreviousSibling(), "aChild with prev sibling?");
42104: 
42104:   *aPos = aChild;
42104:   NS_ADDREF(aChild);
42104:   if (aIndex != 0) {
42104:     nsIContent* previous = static_cast<nsIContent*>(*(aPos - 1));
42104:     aChild->mPreviousSibling = previous;
42104:     previous->mNextSibling = aChild;
42104:   }
42104:   if (aIndex != aChildCount) {
42104:     nsIContent* next = static_cast<nsIContent*>(*(aPos + 1));
42104:     aChild->mNextSibling = next;
42104:     next->mPreviousSibling = aChild;
42104:   }
42104: }
73721: 
73721: PRInt64
73721: nsAttrAndChildArray::SizeOf() const
73721: {
73721:   PRInt64 size = sizeof(*this);
73721: 
73721:   if (mImpl) {
73721:     // Don't add the size taken by *mMappedAttrs because it's shared.
73721: 
73721:     // mBuffer cointains InternalAttr and nsIContent* (even if it's void**)
73721:     // so, we just have to compute the size of *mBuffer given that this object
73721:     // doesn't own the children list.
73721:     size += mImpl->mBufferSize * sizeof(*(mImpl->mBuffer)) + NS_IMPL_EXTRA_SIZE;
75250: 
75250:     PRUint32 slotCount = AttrSlotCount();
75250:     for (PRUint32 i = 0; i < slotCount && AttrSlotIsTaken(i); ++i) {
75250:       nsAttrValue* value = &ATTRS(mImpl)[i].mValue;
75250:       size += value->SizeOf() - sizeof(*value);
75250:     }
73721:   }
73721: 
73721:   return size;
73721: }
73721: 
