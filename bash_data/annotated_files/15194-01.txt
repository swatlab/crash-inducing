 1662: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is Mozilla Foundation code.
    1:  *
    1:  * The Initial Developer of the Original Code is Mozilla Foundation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2005
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <stuart@mozilla.com>
    1:  *   Masayuki Nakano <masayuki@d-toybox.com>
11789:  *   Mats Palmgren <mats.palmgren@bredband.net>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
    1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: //#define FORCE_UNISCRIBE 1
    1: #define FORCE_PR_LOG
    1: 
    1: #include "prtypes.h"
    1: #include "gfxTypes.h"
    1: 
    1: #include "gfxContext.h"
    1: #include "gfxWindowsFonts.h"
    1: #include "gfxWindowsSurface.h"
    1: #include "gfxWindowsPlatform.h"
    1: 
    1: #ifdef MOZ_ENABLE_GLITZ
    1: #include "gfxGlitzSurface.h"
    1: #endif
    1: 
    1: #include "gfxFontTest.h"
    1: 
    1: #include "cairo.h"
    1: #include "cairo-win32.h"
    1: 
    1: #include <windows.h>
    1: 
 6076: #include "nsTArray.h"
    1: #include "nsUnicodeRange.h"
    1: #include "nsUnicharUtils.h"
    1: 
    1: #include "nsIPrefBranch.h"
    1: #include "nsIPrefService.h"
11466: #include "nsIPrefLocalizedString.h"
    1: #include "nsServiceManagerUtils.h"
    1: 
    1: #include "nsCRT.h"
    1: 
    1: #include <math.h>
    1: 
    1: #include "prlog.h"
14918: #include "prinit.h"
    1: static PRLogModuleInfo *gFontLog = PR_NewLogModule("winfonts");
    1: 
    1: #define ROUND(x) floor((x) + 0.5)
    1: 
15022: BYTE 
15022: FontTypeToOutPrecision(PRUint8 fontType)
15022: {
15022: #ifdef WINCE
15022:     return OUT_DEFAULT_PRECIS;
15022: #else
15022:     BYTE ret;
15022:     switch (fontType) {
15022:     case GFX_FONT_TYPE_TT_OPENTYPE:
15022:     case GFX_FONT_TYPE_TRUETYPE:
15022:         ret = OUT_TT_ONLY_PRECIS;
15022:         break;
15022:     case GFX_FONT_TYPE_PS_OPENTYPE:
15022:         ret = OUT_PS_ONLY_PRECIS;
15022:         break;
15022:     case GFX_FONT_TYPE_TYPE1:
15022:         ret = OUT_OUTLINE_PRECIS;
15022:         break;
15022:     case GFX_FONT_TYPE_RASTER:
15022:         ret = OUT_RASTER_PRECIS;
15022:         break;
15022:     case GFX_FONT_TYPE_DEVICE:
15022:         ret = OUT_DEVICE_PRECIS;
15022:         break;
15022:     default:
15022:         ret = OUT_DEFAULT_PRECIS;
15022:     }
15022:     return ret;
15022: #endif
15022: }
 4363: 
 4363: struct DCFromContext {
 4363:     DCFromContext(gfxContext *aContext) {
 4621:         dc = NULL;
 4363:         nsRefPtr<gfxASurface> aSurface = aContext->CurrentSurface();
 4619:         NS_ASSERTION(aSurface, "DCFromContext: null surface");
 6274:         if (aSurface &&
 6274:             (aSurface->GetType() == gfxASurface::SurfaceTypeWin32 ||
 6274:              aSurface->GetType() == gfxASurface::SurfaceTypeWin32Printing))
 6274:         {
 4363:             dc = static_cast<gfxWindowsSurface*>(aSurface.get())->GetDC();
 4363:             needsRelease = PR_FALSE;
 4619:         }
 4619:         if (!dc) {
 4363:             dc = GetDC(NULL);
15061:             SetGraphicsMode(dc, GM_ADVANCED);
 4363:             needsRelease = PR_TRUE;
    1:         }
    1:     }
    1: 
 4363:     ~DCFromContext() {
 4363:         if (needsRelease)
 4363:             ReleaseDC(NULL, dc);
 4363:     }
 4363: 
 4363:     operator HDC () {
 4363:         return dc;
 4363:     }
 4363: 
 4363:     HDC dc;
 4363:     PRBool needsRelease;
 4363: };
 4363: 
13578: 
13578: /**********************************************************************
13578:  *
13578:  * class FontFamily
13578:  *
13578:  **********************************************************************/
13578: static nsresult
13578: ReadCMAP(HDC hdc, FontEntry *aFontEntry)
13578: {
13578:     const PRUint32 kCMAP = (('c') | ('m' << 8) | ('a' << 16) | ('p' << 24));
13578: 
13578:     DWORD len = GetFontData(hdc, kCMAP, 0, nsnull, 0);
13578:     if (len == GDI_ERROR || len == 0) // not a truetype font --
13578:         return NS_ERROR_FAILURE;      // we'll treat it as a symbol font
13578: 
13578:     nsAutoTArray<PRUint8,16384> buffer;
13578:     if (!buffer.AppendElements(len))
13578:         return NS_ERROR_OUT_OF_MEMORY;
13578:     PRUint8 *buf = buffer.Elements();
13578: 
13578:     DWORD newLen = GetFontData(hdc, kCMAP, 0, buf, len);
13578:     NS_ENSURE_TRUE(newLen == len, NS_ERROR_FAILURE);
13578: 
13879:     // can't pass bits as references...
13879:     PRPackedBool unicodeFont = aFontEntry->mUnicodeFont;
13879:     PRPackedBool symbolFont = aFontEntry->mSymbolFont;
13879:     nsresult rv = gfxFontUtils::ReadCMAP(buf, len, aFontEntry->mCharacterMap,
13879:                                          unicodeFont, symbolFont);
13879:     aFontEntry->mUnicodeFont = unicodeFont;
13879:     aFontEntry->mSymbolFont = symbolFont;
13879: 
13879:     return rv;
13578: }
13578: 
13578: struct FamilyAddStyleProcData {
13578:     HDC dc;
13578:     FontFamily *ff;
13578: };
13578: 
13578: int CALLBACK 
13578: FontFamily::FamilyAddStylesProc(const ENUMLOGFONTEXW *lpelfe,
13578:                                 const NEWTEXTMETRICEXW *nmetrics,
13578:                                 DWORD fontType, LPARAM data)
13578: {
13578:     const NEWTEXTMETRICW& metrics = nmetrics->ntmTm;
13578:     LOGFONTW logFont = lpelfe->elfLogFont;
13578: 
13578:     FamilyAddStyleProcData *faspd = reinterpret_cast<FamilyAddStyleProcData*>(data);
13578:     FontFamily *ff = faspd->ff;
13578:     HDC hdc = faspd->dc;
13578: 
13578:     // Some fonts claim to support things > 900, but we don't so clamp the sizes
13578:     logFont.lfWeight = PR_MAX(PR_MIN(logFont.lfWeight, 900), 100);
13578: 
15022:     gfxWindowsFontType feType;
15022:     if (metrics.ntmFlags & NTM_TYPE1)
15022:         feType = GFX_FONT_TYPE_TYPE1;
15022:     else if (metrics.ntmFlags & (NTM_PS_OPENTYPE))
15022:         feType = GFX_FONT_TYPE_PS_OPENTYPE;
15022:     else if (metrics.ntmFlags & (NTM_TT_OPENTYPE))
15022:         feType = GFX_FONT_TYPE_TT_OPENTYPE;
15022:     else if (fontType == TRUETYPE_FONTTYPE)
15022:         feType = GFX_FONT_TYPE_TRUETYPE;
15022:     else if (fontType == RASTER_FONTTYPE)
15022:         feType = GFX_FONT_TYPE_RASTER;
15022:     else if (fontType == DEVICE_FONTTYPE)
15022:         feType = GFX_FONT_TYPE_DEVICE;
15022:     else
15022:         feType = GFX_FONT_TYPE_UNKNOWN;
15022: 
13578:     FontEntry *fe = nsnull;
13578:     for (PRUint32 i = 0; i < ff->mVariations.Length(); ++i) {
13578:         fe = ff->mVariations[i];
15022:         if (feType > fe->mFontType) {
15022:             // if the new type is better than the old one, remove the old entries
15022:             ff->mVariations.RemoveElementAt(i);
15022:             --i;
15022:         } else if (feType < fe->mFontType) {
15022:             // otherwise if the new type is worse, skip it
15022:             return 1;
15022:         }
15022:     }
13578: 
15022:     for (PRUint32 i = 0; i < ff->mVariations.Length(); ++i) {
15022:         fe = ff->mVariations[i];
13578:         // check if we already know about this face
13578:         if (fe->mWeight == logFont.lfWeight &&
13578:             fe->mItalic == (logFont.lfItalic == 0xFF)) {
13578:             // update the charset bit here since this could be different
13578:             fe->mCharset[metrics.tmCharSet] = 1;
13578:             return 1; 
13578:         }
13578:     }
13578: 
13578:     fe = new FontEntry(ff->mName);
13578:     ff->mVariations.AppendElement(fe);
15022:     fe->mFontType = feType;
13578: 
13578:     fe->mItalic = (logFont.lfItalic == 0xFF);
13578:     fe->mWeight = logFont.lfWeight;
13578: 
15022:     if (fe->IsType1())
15022:         fe->mForceGDI = PR_TRUE;
13578: 
13578:     // mark the charset bit
13578:     fe->mCharset[metrics.tmCharSet] = 1;
13578: 
13578:     fe->mWindowsFamily = logFont.lfPitchAndFamily & 0xF0;
13578:     fe->mWindowsPitch = logFont.lfPitchAndFamily & 0x0F;
13578: 
13578:     if (nmetrics->ntmFontSig.fsUsb[0] != 0x00000000 &&
13578:         nmetrics->ntmFontSig.fsUsb[1] != 0x00000000 &&
13578:         nmetrics->ntmFontSig.fsUsb[2] != 0x00000000 &&
13578:         nmetrics->ntmFontSig.fsUsb[3] != 0x00000000) {
13578: 
13578:         // set the unicode ranges
13578:         PRUint32 x = 0;
13578:         for (PRUint32 i = 0; i < 4; ++i) {
13578:             DWORD range = nmetrics->ntmFontSig.fsUsb[i];
13578:             for (PRUint32 k = 0; k < 32; ++k) {
13578:                 fe->mUnicodeRanges[x++] = (range & (1 << k)) != 0;
13578:             }
13578:         }
13578:     }
13578: 
13579:     fe->mIsBadUnderlineFont = ff->mIsBadUnderlineFont;
13579: 
13578:     // read in the character map
13578:     logFont.lfCharSet = DEFAULT_CHARSET;
15022:     logFont.lfOutPrecision = FontTypeToOutPrecision(fe->mFontType);
15022: 
13578:     HFONT font = CreateFontIndirectW(&logFont);
13578: 
13578:     NS_ASSERTION(font, "This font creation should never ever ever fail");
13578:     if (font) {
13578:         HFONT oldFont = (HFONT)SelectObject(hdc, font);
13578: 
13578:         // ReadCMAP may change the values of mUnicodeFont and mSymbolFont
13578:         if (NS_FAILED(ReadCMAP(hdc, fe))) {
13578:             // Type1 fonts aren't necessarily Unicode but
13578:             // this is the best guess we can make here
15022:             if (fe->IsType1())
13578:                 fe->mUnicodeFont = PR_TRUE;
13578:             else
13578:                 fe->mUnicodeFont = PR_FALSE;
13578: 
13578:             // For fonts where we failed to read the character map,
13879:             // we can take a slow path to look up glyphs character by character
13879:             fe->mUnknownCMAP = PR_TRUE;
13578: 
13877:             //printf("(fontinit-cmap) %s failed to get cmap, type1:%d \n", NS_ConvertUTF16toUTF8(fe->mFaceName).get(), (PRUint32)(fe->mIsType1));
13877:         } else {
13877:             //printf("(fontinit-cmap) %s cmap loaded, italic:%d, weight:%d\n", NS_ConvertUTF16toUTF8(fe->mFaceName).get(), (PRUint32)(fe->mItalic), (PRUint32)(fe->mWeight));
13578:         }
13578: 
13578:         SelectObject(hdc, oldFont);
13578:         DeleteObject(font);
13578:     }
13578: 
13578:     return 1;
13578: }
13578: 
13578: // general cmap reading routines moved to gfxFontUtils.cpp
13578: void
13578: FontFamily::FindStyleVariations()
13578: {
13877:     if (mHasStyles)
13877:         return;
13578:     mHasStyles = PR_TRUE;
13578: 
13578:     HDC hdc = GetDC(nsnull);
15061:     SetGraphicsMode(hdc, GM_ADVANCED);
13578: 
13578:     LOGFONTW logFont;
13578:     memset(&logFont, 0, sizeof(LOGFONTW));
13578:     logFont.lfCharSet = DEFAULT_CHARSET;
13578:     logFont.lfPitchAndFamily = 0;
13578:     PRUint32 l = PR_MIN(mName.Length(), LF_FACESIZE - 1);
13578:     memcpy(logFont.lfFaceName,
13578:            nsPromiseFlatString(mName).get(),
13578:            l * sizeof(PRUnichar));
13578:     logFont.lfFaceName[l] = 0;
13578: 
13578:     FamilyAddStyleProcData faspd;
13578:     faspd.dc = hdc;
13578:     faspd.ff = this;
13578: 
13578:     EnumFontFamiliesExW(hdc, &logFont, (FONTENUMPROCW)FontFamily::FamilyAddStylesProc, (LPARAM)&faspd, 0);
13578: 
13578:     ReleaseDC(nsnull, hdc);
13578: 
13578:     // Look for font families without bold variations and add a FontEntry
13578:     // with synthetic bold (weight 600) for them.
13578:     FontEntry *darkestItalic = nsnull;
13578:     FontEntry *darkestNonItalic = nsnull;
13578:     PRUint8 highestItalic = 0, highestNonItalic = 0;
13578:     for (PRUint32 i = 0; i < mVariations.Length(); i++) {
13578:         FontEntry *fe = mVariations[i];
13578:         if (fe->mItalic) {
13578:             if (!darkestItalic || fe->mWeight > darkestItalic->mWeight)
13578:                 darkestItalic = fe;
13578:         } else {
13578:             if (!darkestNonItalic || fe->mWeight > darkestNonItalic->mWeight)
13578:                 darkestNonItalic = fe;
13578:         }
13578:     }
13578: 
13578:     if (darkestItalic && darkestItalic->mWeight < 600) {
13578:         FontEntry *newEntry = new FontEntry(*darkestItalic);
13578:         newEntry->mWeight = 600;
13578:         mVariations.AppendElement(newEntry);
13578:     }
13578:     if (darkestNonItalic && darkestNonItalic->mWeight < 600) {
13578:         FontEntry *newEntry = new FontEntry(*darkestNonItalic);
13578:         newEntry->mWeight = 600;
13578:         mVariations.AppendElement(newEntry);
13578:     }
13578: }
13578: 
13578: 
13578: FontEntry *
13578: FontFamily::FindFontEntry(const gfxFontStyle& aFontStyle)
13578: {
13578:     if (!mHasStyles)
13578:         FindStyleVariations();
13578: 
13578:     PRUint8 bestMatch = 0;
13578:     PRBool italic = (aFontStyle.style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) != 0;
13578: 
13578:     FontEntry *weightList[10] = { 0 };
13578:     for (PRUint32 j = 0; j < 2; j++) {
13578:         PRBool matchesSomething = PR_FALSE;
13578:         // build up an array of weights that match the italicness we're looking for
13578:         for (PRUint32 i = 0; i < mVariations.Length(); i++) {
13578:             FontEntry *fe = mVariations[i];
13578:             const PRUint8 weight = (fe->mWeight / 100);
13578:             if (fe->mItalic == italic) {
13578:                 weightList[weight] = fe;
13578:                 matchesSomething = PR_TRUE;
13578:             }
13578:         }
13578:         if (matchesSomething)
13578:             break;
13578:         italic = !italic;
13578:     }
13578: 
13578:     PRInt8 baseWeight, weightDistance;
13578:     aFontStyle.ComputeWeightAndOffset(&baseWeight, &weightDistance);
13578: 
13578:     // 500 isn't quite bold so we want to treat it as 400 if we don't
13578:     // have a 500 weight
13578:     if (baseWeight == 5 && weightDistance == 0) {
13578:         // If we have a 500 weight then use it
13578:         if (weightList[5])
13578:             return weightList[5];
13578: 
13578:         // Otherwise treat as 400
13578:         baseWeight = 4;
13578:     }
13578: 
13578:     PRInt8 matchBaseWeight = 0;
13578:     PRInt8 direction = (baseWeight > 5) ? 1 : -1;
13578:     for (PRInt8 i = baseWeight; ; i += direction) {
13578:         if (weightList[i]) {
13578:             matchBaseWeight = i;
13578:             break;
13578:         }
13578: 
13578:         // if we've reached one side without finding a font,
13578:         // go the other direction until we find a match
13578:         if (i == 1 || i == 9)
13578:             direction = -direction;
13578:     }
13578: 
13578:     FontEntry *matchFE;
13578:     const PRInt8 absDistance = abs(weightDistance);
13578:     direction = (weightDistance >= 0) ? 1 : -1;
13578:     for (PRInt8 i = matchBaseWeight, k = 0; i < 10 && i > 0; i += direction) {
13578:         if (weightList[i]) {
13578:             matchFE = weightList[i];
13578:             k++;
13578:         }
13578:         if (k > absDistance)
13578:             break;
13578:     }
13578: 
13578:     if (!matchFE)
13578:         matchFE = weightList[matchBaseWeight];
13578: 
13578:     NS_ASSERTION(matchFE, "we should always be able to return something here");
13578:     return matchFE;
13578: }
13578: 
13578: 
    1: /**********************************************************************
    1:  *
    1:  * class gfxWindowsFont
    1:  *
    1:  **********************************************************************/
    1: 
13340: gfxWindowsFont::gfxWindowsFont(const nsAString& aName, const gfxFontStyle *aFontStyle, FontEntry *aFontEntry)
    1:     : gfxFont(aName, aFontStyle),
 9503:       mFont(nsnull), mAdjustedSize(0.0), mScriptCache(nsnull),
    1:       mFontFace(nsnull), mScaledFont(nsnull),
14798:       mMetrics(nsnull), mFontEntry(aFontEntry), mIsValid(PR_TRUE)
    1: {
 1959:     NS_ASSERTION(mFontEntry, "Unable to find font entry for font.  Something is whack.");
 2369: 
 2369:     mFont = MakeHFONT(); // create the HFONT, compute metrics, etc
 2369:     NS_ASSERTION(mFont, "Failed to make HFONT");
    1: }
    1: 
    1: gfxWindowsFont::~gfxWindowsFont()
    1: {
    1:     if (mFontFace)
    1:         cairo_font_face_destroy(mFontFace);
    1: 
    1:     if (mScaledFont)
    1:         cairo_scaled_font_destroy(mScaledFont);
    1: 
    1:     if (mFont)
    1:         DeleteObject(mFont);
    1: 
    1:     ScriptFreeCache(&mScriptCache);
    1: 
    1:     delete mMetrics;
    1: }
    1: 
    1: const gfxFont::Metrics&
    1: gfxWindowsFont::GetMetrics()
    1: {
    1:     if (!mMetrics)
    1:         ComputeMetrics();
    1: 
    1:     return *mMetrics;
    1: }
    1: 
    1: cairo_font_face_t *
    1: gfxWindowsFont::CairoFontFace()
    1: {
    1:     if (!mFontFace)
 2369:         mFontFace = cairo_win32_font_face_create_for_logfontw_hfont(&mLogFont, mFont);
    1: 
    1:     NS_ASSERTION(mFontFace, "Failed to make font face");
    1: 
    1:     return mFontFace;
    1: }
    1: 
    1: cairo_scaled_font_t *
    1: gfxWindowsFont::CairoScaledFont()
    1: {
 2369:     if (!mScaledFont) {
 2369:         cairo_matrix_t sizeMatrix;
 2369:         cairo_matrix_t identityMatrix;
 2369: 
 2369:         cairo_matrix_init_scale(&sizeMatrix, mAdjustedSize, mAdjustedSize);
 2369:         cairo_matrix_init_identity(&identityMatrix);
 2369: 
 2369:         cairo_font_options_t *fontOptions = cairo_font_options_create();
 2369:         mScaledFont = cairo_scaled_font_create(CairoFontFace(), &sizeMatrix,
 2369:                                                &identityMatrix, fontOptions);
 2369:         cairo_font_options_destroy(fontOptions);
 2369:     }
    1: 
 5274:     NS_ASSERTION(mAdjustedSize == 0.0 ||
 5274:                  cairo_scaled_font_status(mScaledFont) == CAIRO_STATUS_SUCCESS,
 4304:                  "Failed to make scaled font");
    1: 
    1:     return mScaledFont;
    1: }
    1: 
    1: HFONT
    1: gfxWindowsFont::MakeHFONT()
    1: {
    1:     if (mFont)
    1:         return mFont;
    1: 
  323:     mAdjustedSize = GetStyle()->size;
 9504:     if (GetStyle()->sizeAdjust > 0.0) {
    1:         if (!mFont) {
13280:             FillLogFont(mAdjustedSize);
    1:             mFont = CreateFontIndirectW(&mLogFont);
    1:         }
    1: 
    1:         Metrics *oldMetrics = mMetrics;
    1:         ComputeMetrics();
    1:         gfxFloat aspect = mMetrics->xHeight / mMetrics->emHeight;
 2210:         mAdjustedSize = GetStyle()->GetAdjustedSize(aspect);
    1: 
    1:         if (mMetrics != oldMetrics) {
    1:             delete mMetrics;
    1:             mMetrics = oldMetrics;
    1:         }
    1:         DeleteObject(mFont);
    1:         mFont = nsnull;
    1:     }
    1: 
    1:     if (!mFont) {
13280:         FillLogFont(mAdjustedSize);
    1:         mFont = CreateFontIndirectW(&mLogFont);
    1:     }
    1: 
    1:     return mFont;
    1: }
    1: 
    1: void
    1: gfxWindowsFont::ComputeMetrics()
    1: {
    1:     if (!mMetrics)
    1:         mMetrics = new gfxFont::Metrics;
 2369:     else
 2369:         NS_WARNING("Calling ComputeMetrics multiple times");
    1: 
    1:     HDC dc = GetDC((HWND)nsnull);
15061:     SetGraphicsMode(dc, GM_ADVANCED);
    1: 
 2369:     HGDIOBJ oldFont = SelectObject(dc, mFont);
    1: 
    1:     // Get font metrics
    1:     OUTLINETEXTMETRIC oMetrics;
    1:     TEXTMETRIC& metrics = oMetrics.otmTextMetrics;
    1: 
    1:     if (0 < GetOutlineTextMetrics(dc, sizeof(oMetrics), &oMetrics)) {
    1:         mMetrics->superscriptOffset = (double)oMetrics.otmptSuperscriptOffset.y;
11789:         // Some fonts have wrong sign on their subscript offset, bug 410917.
11789:         mMetrics->subscriptOffset = fabs((double)oMetrics.otmptSubscriptOffset.y);
11765:         mMetrics->strikeoutSize = (double)oMetrics.otmsStrikeoutSize;
    1:         mMetrics->strikeoutOffset = (double)oMetrics.otmsStrikeoutPosition;
11765:         mMetrics->underlineSize = (double)oMetrics.otmsUnderscoreSize;
    1:         mMetrics->underlineOffset = (double)oMetrics.otmsUnderscorePosition;
    1: 
    1:         const MAT2 kIdentityMatrix = { {0, 1}, {0, 0}, {0, 0}, {0, 1} };
    1:         GLYPHMETRICS gm;
    1:         DWORD len = GetGlyphOutlineW(dc, PRUnichar('x'), GGO_METRICS, &gm, 0, nsnull, &kIdentityMatrix);
    1:         if (len == GDI_ERROR || gm.gmptGlyphOrigin.y <= 0) {
    1:             // 56% of ascent, best guess for true type
    1:             mMetrics->xHeight = ROUND((double)metrics.tmAscent * 0.56);
    1:         } else {
    1:             mMetrics->xHeight = gm.gmptGlyphOrigin.y;
    1:         }
11765:         mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
11765:         gfxFloat typEmHeight = (double)oMetrics.otmAscent - (double)oMetrics.otmDescent;
11765:         mMetrics->emAscent = ROUND(mMetrics->emHeight * (double)oMetrics.otmAscent / typEmHeight);
11765:         mMetrics->emDescent = mMetrics->emHeight - mMetrics->emAscent;
    1:     } else {
    1:         // Make a best-effort guess at extended metrics
    1:         // this is based on general typographic guidelines
14798:         
14798:         // GetTextMetrics can fail if the font file has been removed
14798:         // or corrupted recently.
14798:         BOOL result = GetTextMetrics(dc, &metrics);
14798:         if (!result) {
14798:             NS_WARNING("Missing or corrupt font data, fasten your seatbelt");
14798:             mIsValid = PR_FALSE;
14798:             memset(mMetrics, 0, sizeof(*mMetrics));
14798:             SelectObject(dc, oldFont);
14798:             ReleaseDC((HWND)nsnull, dc);
14798:             return;
14798:         }
    1: 
    1:         mMetrics->xHeight = ROUND((float)metrics.tmAscent * 0.56f); // 56% of ascent, best guess for non-true type
    1:         mMetrics->superscriptOffset = mMetrics->xHeight;
    1:         mMetrics->subscriptOffset = mMetrics->xHeight;
    1:         mMetrics->strikeoutSize = 1;
    1:         mMetrics->strikeoutOffset = ROUND(mMetrics->xHeight / 2.0f); // 50% of xHeight
    1:         mMetrics->underlineSize = 1;
    1:         mMetrics->underlineOffset = -ROUND((float)metrics.tmDescent * 0.30f); // 30% of descent
11765:         mMetrics->emHeight = metrics.tmHeight - metrics.tmInternalLeading;
11765:         mMetrics->emAscent = metrics.tmAscent - metrics.tmInternalLeading;
11765:         mMetrics->emDescent = metrics.tmDescent;
    1:     }
    1: 
    1:     mMetrics->internalLeading = metrics.tmInternalLeading;
    1:     mMetrics->externalLeading = metrics.tmExternalLeading;
    1:     mMetrics->maxHeight = metrics.tmHeight;
    1:     mMetrics->maxAscent = metrics.tmAscent;
    1:     mMetrics->maxDescent = metrics.tmDescent;
    1:     mMetrics->maxAdvance = metrics.tmMaxCharWidth;
    1:     mMetrics->aveCharWidth = PR_MAX(1, metrics.tmAveCharWidth);
14465:     // The font is monospace when TMPF_FIXED_PITCH is *not* set!
14465:     // See http://msdn2.microsoft.com/en-us/library/ms534202(VS.85).aspx
14465:     if (!(metrics.tmPitchAndFamily & TMPF_FIXED_PITCH)) {
14465:       mMetrics->maxAdvance = mMetrics->aveCharWidth;
14465:     }
    1: 
    1:     // Cache the width of a single space.
    1:     SIZE size;
12902:     GetTextExtentPoint32(dc, " ", 1, &size);
    1:     mMetrics->spaceWidth = ROUND(size.cx);
    1: 
 1295:     mSpaceGlyph = 0;
 1295:     if (metrics.tmPitchAndFamily & TMPF_TRUETYPE) {
 1295:         WORD glyph;
12902:         DWORD ret = GetGlyphIndicesA(dc, " ", 1, &glyph,
 1295:                                      GGI_MARK_NONEXISTING_GLYPHS);
 1295:         if (ret != GDI_ERROR && glyph != 0xFFFF) {
 1295:             mSpaceGlyph = glyph;
 1295:         }
 1295:     }
 1295: 
    1:     SelectObject(dc, oldFont);
    1: 
    1:     ReleaseDC((HWND)nsnull, dc);
11765: 
12989:     SanitizeMetrics(mMetrics, mFontEntry->IsBadUnderlineFont());
    1: }
    1: 
    1: void
13280: gfxWindowsFont::FillLogFont(gfxFloat aSize)
    1: {
    1: #define CLIP_TURNOFF_FONTASSOCIATION 0x40
    1:     
  687:     mLogFont.lfHeight = (LONG)-ROUND(aSize);
    1: 
    1:     if (mLogFont.lfHeight == 0)
    1:         mLogFont.lfHeight = -1;
    1: 
    1:     // Fill in logFont structure
    1:     mLogFont.lfWidth          = 0;
    1:     mLogFont.lfEscapement     = 0;
    1:     mLogFont.lfOrientation    = 0;
 1663:     mLogFont.lfUnderline      = FALSE;
 1663:     mLogFont.lfStrikeOut      = FALSE;
    1:     mLogFont.lfCharSet        = DEFAULT_CHARSET;
15022:     mLogFont.lfOutPrecision   = FontTypeToOutPrecision(mFontEntry->mFontType);
    1:     mLogFont.lfClipPrecision  = CLIP_TURNOFF_FONTASSOCIATION;
    1:     mLogFont.lfQuality        = DEFAULT_QUALITY;
    1:     mLogFont.lfPitchAndFamily = DEFAULT_PITCH | FF_DONTCARE;
13280:     // always force lfItalic if we want it.  Font selection code will
13280:     // do its best to give us an italic font entry, but if no face exists
13280:     // it may give us a regular one based on weight.  Windows should
13280:     // do fake italic for us in that case.
  323:     mLogFont.lfItalic         = (GetStyle()->style & (FONT_STYLE_ITALIC | FONT_STYLE_OBLIQUE)) ? TRUE : FALSE;
13280:     mLogFont.lfWeight         = mFontEntry->mWeight;
    1: 
    1:     int len = PR_MIN(mName.Length(), LF_FACESIZE - 1);
    1:     memcpy(mLogFont.lfFaceName, nsPromiseFlatString(mName).get(), len * 2);
    1:     mLogFont.lfFaceName[len] = '\0';
    1: }
    1: 
    1: 
    1: nsString
    1: gfxWindowsFont::GetUniqueName()
    1: {
    1:     nsString uniqueName;
    1: 
    1:     // start with the family name
    1:     uniqueName.Assign(mName);
    1: 
    1:     // append the weight code
    1:     if (mLogFont.lfWeight != 400) {
    1:         uniqueName.AppendLiteral(":");
    1:         uniqueName.AppendInt((PRInt32)mLogFont.lfWeight);
    1:     }
    1: 
    1:     // append italic?
    1:     if (mLogFont.lfItalic)
    1:         uniqueName.AppendLiteral(":Italic");
    1: 
    1:     if (mLogFont.lfUnderline)
    1:         uniqueName.AppendLiteral(":Underline");
    1: 
    1:     if (mLogFont.lfStrikeOut)
    1:         uniqueName.AppendLiteral(":StrikeOut");
    1: 
    1:     return uniqueName;
    1: }
    1: 
    1: void
    1: gfxWindowsFont::Draw(gfxTextRun *aTextRun, PRUint32 aStart, PRUint32 aEnd,
    1:                      gfxContext *aContext, PRBool aDrawToPath, gfxPoint *aBaselineOrigin,
    1:                      Spacing *aSpacing)
    1: {
    1:     // XXX stuart may want us to do something faster here
    1:     gfxFont::Draw(aTextRun, aStart, aEnd, aContext, aDrawToPath, aBaselineOrigin,
    1:                   aSpacing);
    1: }
    1: 
 4304: PRBool
 6247: gfxWindowsFont::SetupCairoFont(gfxContext *aContext)
    1: {
 4304:     cairo_scaled_font_t *scaledFont = CairoScaledFont();
 5274:     if (cairo_scaled_font_status(scaledFont) != CAIRO_STATUS_SUCCESS) {
 5274:         // Don't cairo_set_scaled_font as that would propagate the error to
 5274:         // the cairo_t, precluding any further drawing.
 5274:         return PR_FALSE;
 5274:     }
 6247:     cairo_set_scaled_font(aContext->GetCairo(), scaledFont);
 4304:     return PR_TRUE;
 4304: }
    1: 
    1: /**********************************************************************
    1:  *
    1:  * class gfxWindowsFontGroup
    1:  *
    1:  **********************************************************************/
    1: 
  323: /**
  323:  * Look up the font in the gfxFont cache. If we don't find it, create one.
  323:  * In either case, add a ref, append it to the aFonts array, and return it ---
  323:  * except for OOM in which case we do nothing and return null.
  323:  */
14798: already_AddRefed<gfxWindowsFont>
14798: gfxWindowsFont::GetOrMakeFont(FontEntry *aFontEntry, const gfxFontStyle *aStyle)
  323: {
13649:     // because we know the FontEntry has the weight we really want, use it for matching
13649:     // things in the cache so we don't end up with things like 402 in there.
13649:     gfxFontStyle style(*aStyle);
13649:     style.weight = aFontEntry->mWeight;
13649:     // also pre-round the size if there is no size adjust
13649:     if (style.sizeAdjust == 0.0)
13649:         style.size = ROUND(style.size);
13649: 
13649:     nsRefPtr<gfxFont> font = gfxFontCache::GetCache()->Lookup(aFontEntry->GetName(), &style);
  323:     if (!font) {
13649:         font = new gfxWindowsFont(aFontEntry->GetName(), &style, aFontEntry);
  323:         if (!font)
  323:             return nsnull;
  323:         gfxFontCache::GetCache()->AddNew(font);
  323:     }
  323:     gfxFont *f = nsnull;
  323:     font.swap(f);
  323:     return static_cast<gfxWindowsFont *>(f);
  323: }
  323: 
 2252: static PRBool
13280: AddFontNameToArray(const nsAString& aName,
    1:                    const nsACString& aGenericName,
    1:                    void *closure)
    1: {
    1:     if (!aName.IsEmpty()) {
14457:         nsTArray<nsString> *list = static_cast<nsTArray<nsString> *>(closure);
    1: 
13280:         if (list->IndexOf(aName) == list->NoIndex)
13280:             list->AppendElement(aName);
    1:     }
    1: 
    1:     return PR_TRUE;
    1: }
    1: 
13280: void
13280: gfxWindowsFontGroup::GroupFamilyListToArrayList(nsTArray<nsRefPtr<FontEntry> > *list)
13280: {
14457:     nsAutoTArray<nsString, 15> fonts;
13280:     ForEachFont(AddFontNameToArray, &fonts);
13280: 
13280:     PRUint32 len = fonts.Length();
13280:     for (PRUint32 i = 0; i < len; ++i) {
13578:         nsRefPtr<FontEntry> fe = gfxWindowsPlatform::GetPlatform()->FindFontEntry(fonts[i], mStyle);
13280:         list->AppendElement(fe);
13280:     }
13280: }
13280: 
13280: void
13280: gfxWindowsFontGroup::FamilyListToArrayList(const nsString& aFamilies,
13280:                                            const nsCString& aLangGroup,
13280:                                            nsTArray<nsRefPtr<FontEntry> > *list)
13280: {
14457:     nsAutoTArray<nsString, 15> fonts;
13280:     ForEachFont(aFamilies, aLangGroup, AddFontNameToArray, &fonts);
13280: 
13280:     PRUint32 len = fonts.Length();
13280:     for (PRUint32 i = 0; i < len; ++i) {
14457:         const nsString& str = fonts[i];
13578:         nsRefPtr<FontEntry> fe = gfxWindowsPlatform::GetPlatform()->FindFontEntry(str, mStyle);
13280:         list->AppendElement(fe);
13280:     }
13280: }
13280: 
    1: gfxWindowsFontGroup::gfxWindowsFontGroup(const nsAString& aFamilies, const gfxFontStyle *aStyle)
    1:     : gfxFontGroup(aFamilies, aStyle)
    1: {
13280:     GroupFamilyListToArrayList(&mFontEntries);
    1: 
14798:     mFonts.AppendElements(mFontEntries.Length());
14798: 
14798:     // Ensure that the first font is usable. Precompute its metrics since
14798:     // we'll surely need them anyway.
14798:     while (mFontEntries.Length() > 0) {
14798:         nsRefPtr<gfxWindowsFont> font =
14798:             gfxWindowsFont::GetOrMakeFont(mFontEntries[0], &mStyle);
14798:         if (!font->IsValid()) {
14798:             mFontEntries.RemoveElementAt(0);
14798:             mFonts.RemoveElementAt(0);
14798:             continue;
14798:         }
14798:         mFonts[0] = font;
14798:         break;
14798:     }
14798: 
 5257:     if (mFontEntries.Length() == 0) {
15194:         // It is pretty important that we have at least one font, so
15194:         // try a few system fonts that should be there.
15194:         nsAutoString str;
    1:         HGDIOBJ hGDI = ::GetStockObject(DEFAULT_GUI_FONT);
    1:         LOGFONTW logFont;
15194:         if (hGDI && ::GetObjectW(hGDI, sizeof(logFont), &logFont)) {
15194:             str.AppendLiteral("\"");
15194:             str.Append(nsDependentString(logFont.lfFaceName));
15194:             str.AppendLiteral("\"");
    1:         }
15194: 
15194:         NONCLIENTMETRICSW ncm;
15194:         ncm.cbSize = sizeof(ncm);
15194:         BOOL status = ::SystemParametersInfoW(SPI_GETNONCLIENTMETRICS, 
15194:                                               sizeof(ncm), &ncm, 0);
15194:         if (status) {
15194:             str.AppendLiteral(",\"");
15194:             str.Append(nsDependentString(ncm.lfMessageFont.lfFaceName));
15194:             str.AppendLiteral("\"");
15194:         }
15194: 
15194:         FamilyListToArrayList(str, mStyle.langGroup, &mFontEntries);
15194: 
14798:         // Keep length of mFonts in sync with length of mFontEntries.
14798:         // Maybe we should eagerly set up mFonts[0] like we do above,
14798:         // but if the resulting gfxWindowsFont is invalid then we can't
14798:         // do much anyway. In that case the font will return zero metrics,
14798:         // its mUnknownCMAP will be set to true, and HasCharacter will
14798:         // just report false for all characters, so the fact that the font
14798:         // is bogus should not cause problems.
15194:         mFonts.AppendElements(mFontEntries.Length());
    1:     }
 2252: 
13714:     if (!mStyle.systemFont) {
12989:         for (PRUint32 i = 0; i < mFontEntries.Length(); ++i) {
12989:             if (mFontEntries[i]->IsBadUnderlineFont()) {
12989:                 gfxFloat first = GetFontAt(0)->GetMetrics().underlineOffset;
12989:                 gfxFloat bad = GetFontAt(i)->GetMetrics().underlineOffset;
12989:                 mUnderlineOffset = PR_MIN(first, bad);
12989:                 break;
12989:             }
12989:         }
    1:     }
13714: }
    1: 
    1: gfxWindowsFontGroup::~gfxWindowsFontGroup()
    1: {
    1: }
    1: 
 2252: gfxWindowsFont *
 2252: gfxWindowsFontGroup::GetFontAt(PRInt32 i)
 2252: {
 2252:     if (!mFonts[i]) {
14798:         nsRefPtr<gfxWindowsFont> font =
14798:             gfxWindowsFont::GetOrMakeFont(mFontEntries[i], &mStyle);
 2254:         mFonts[i] = font;
 2252:     }
 2252: 
 3233:     return static_cast<gfxWindowsFont*>(mFonts[i].get());
 2252: }
 2252: 
    6: gfxFontGroup *
    6: gfxWindowsFontGroup::Copy(const gfxFontStyle *aStyle)
    6: {
    6:     return new gfxWindowsFontGroup(mFamilies, aStyle);
    6: }
    6: 
 4032: static PRBool
 4032: CanTakeFastPath(PRUint32 aFlags)
 4032: {
 4032:     // Can take fast path only if OPTIMIZE_SPEED is set and IS_RTL isn't
 4032:     // We need to always use Uniscribe for RTL text, in case glyph mirroring is required
 4032:     return (aFlags &
 4032:             (gfxTextRunFactory::TEXT_OPTIMIZE_SPEED | gfxTextRunFactory::TEXT_IS_RTL)) ==
 4032:         gfxTextRunFactory::TEXT_OPTIMIZE_SPEED;
 4032: }
 4032: 
    1: gfxTextRun *
    1: gfxWindowsFontGroup::MakeTextRun(const PRUnichar *aString, PRUint32 aLength,
 1295:                                  const Parameters *aParams, PRUint32 aFlags)
    1: {
  642:     // XXX comment out the assertion for now since it fires too much
 1295:     //    NS_ASSERTION(!(mFlags & TEXT_NEED_BOUNDING_BOX),
  642:     //                 "Glyph extents not yet supported");
    1: 
 8084:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
    1:     if (!textRun)
    1:         return nsnull;
 1153:     NS_ASSERTION(aParams->mContext, "MakeTextRun called without a gfxContext");
    1: 
    1:     textRun->RecordSurrogates(aString);
    1:     
    1: #ifdef FORCE_UNISCRIBE
    1:     const PRBool isComplex = PR_TRUE;
    1: #else
 4032:     const PRBool isComplex = !CanTakeFastPath(aFlags) ||
 4032:                              ScriptIsComplex(aString, aLength, SIC_COMPLEX) == S_OK;
    1: #endif
    1:     if (isComplex)
    1:         InitTextRunUniscribe(aParams->mContext, textRun, aString, aLength);
    1:     else
    1:         InitTextRunGDI(aParams->mContext, textRun, aString, aLength);
    1: 
 6247:     textRun->FetchGlyphExtents(aParams->mContext);
 6247: 
    1:     return textRun;
    1: }
    1: 
    1: gfxTextRun *
    1: gfxWindowsFontGroup::MakeTextRun(const PRUint8 *aString, PRUint32 aLength,
 1295:                                  const Parameters *aParams, PRUint32 aFlags)
    1: {
 1295:     NS_ASSERTION(aFlags & TEXT_IS_8BIT, "should be marked 8bit");
 1295:  
 8084:     gfxTextRun *textRun = gfxTextRun::Create(aParams, aString, aLength, this, aFlags);
    1:     if (!textRun)
    1:         return nsnull;
 1153:     NS_ASSERTION(aParams->mContext, "MakeTextRun called without a gfxContext");
    1: 
    1: #ifdef FORCE_UNISCRIBE
    1:     const PRBool isComplex = PR_TRUE;
    1: #else
 4032:     const PRBool isComplex = !CanTakeFastPath(aFlags);
    1: #endif
    1: 
  837:     /* We can only call GDI "A" functions if this is a true 7bit ASCII string,
  837:        because they interpret code points from 0x80-0xFF as if they were
  837:        in the system code page. */
 1295:     if (!isComplex && (aFlags & TEXT_IS_ASCII)) {
  837:         InitTextRunGDI(aParams->mContext, textRun,
  837:                        reinterpret_cast<const char*>(aString), aLength);
  837:     }
  837:     else {
    1:         nsDependentCSubstring cString(reinterpret_cast<const char*>(aString),
    1:                                   reinterpret_cast<const char*>(aString + aLength));
    1:         nsAutoString utf16;
    1:         AppendASCIItoUTF16(cString, utf16);
  837:         if (isComplex) {
    1:             InitTextRunUniscribe(aParams->mContext, textRun, utf16.get(), aLength);
    1:         } else {
  837:             InitTextRunGDI(aParams->mContext, textRun, utf16.get(), aLength);
  837:         }
    1:     }
    1: 
 6247:     textRun->FetchGlyphExtents(aParams->mContext);
 6247: 
    1:     return textRun;
    1: }
    1: 
  127: /**
 4363:  * Set the font in the given DC.  If something goes wrong or if the
 4363:  * font is not a Truetype font (hence GetGlyphIndices may be buggy)
 4363:  * then we're not successful and return PR_FALSE, otherwise PR_TRUE.
  127:  */
 4363: static PRBool
 4363: SetupDCFont(HDC dc, gfxWindowsFont *aFont)
    1: {
  127:     HFONT hfont = aFont->GetHFONT();
  127:     if (!hfont)
 4363:         return PR_FALSE;
  127:     SelectObject(dc, hfont);
    1: 
13449:     // GetGlyphIndices is buggy for bitmap and vector fonts, so send them to uniscribe
13449:     // Also sent Symbol fonts through Uniscribe as it has special code to deal with them
15022:     if (!aFont->GetFontEntry()->IsTrueType() || aFont->GetFontEntry()->mSymbolFont)
 4363:         return PR_FALSE;
  127: 
 4363:     return PR_TRUE;
    1: }
    1: 
  127: static PRBool
  127: IsAnyGlyphMissing(WCHAR *aGlyphs, PRUint32 aLength)
    1: {
  127:     PRUint32 i;
  127:     for (i = 0; i < aLength; ++i) {
  127:         if (aGlyphs[i] == 0xFFFF)
  127:             return PR_TRUE;
  127:     }
  127:     return PR_FALSE;
  127: }
  127: 
  127: static PRBool
  127: SetupTextRunFromGlyphs(gfxTextRun *aRun, WCHAR *aGlyphs, HDC aDC,
  127:                        gfxWindowsFont *aFont)
  127: {
  127:     PRUint32 length = aRun->GetLength();
  127:     if (IsAnyGlyphMissing(aGlyphs, length))
  127:         return PR_FALSE;
  127: 
  127:     SIZE size;
 6076:     nsAutoTArray<int,500> partialWidthArray;
 6076:     if (!partialWidthArray.SetLength(length))
  127:         return PR_FALSE;
  127:     BOOL success = GetTextExtentExPointI(aDC,
  341:                                          (WORD*) aGlyphs,
  127:                                          length,
  127:                                          INT_MAX,
  127:                                          NULL,
 6076:                                          partialWidthArray.Elements(),
  127:                                          &size);
  127:     if (!success)
  127:         return PR_FALSE;
  127: 
  127:     aRun->AddGlyphRun(aFont, 0);
  127: 
    1:     gfxTextRun::CompressedGlyph g;
    1:     PRUint32 i;
  127:     PRInt32 lastWidth = 0;
  127:     PRUint32 appUnitsPerDevPixel = aRun->GetAppUnitsPerDevUnit();
    1:     for (i = 0; i < length; ++i) {
  127:         PRInt32 advancePixels = partialWidthArray[i] - lastWidth;
  127:         lastWidth = partialWidthArray[i];
  127:         PRInt32 advanceAppUnits = advancePixels*appUnitsPerDevPixel;
    1:         WCHAR glyph = aGlyphs[i];
 3118:         NS_ASSERTION(!gfxFontGroup::IsInvalidChar(aRun->GetChar(i)),
 3118:                      "Invalid character detected!");
 3118:         if (advanceAppUnits >= 0 &&
    1:             gfxTextRun::CompressedGlyph::IsSimpleAdvance(advanceAppUnits) &&
    1:             gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyph)) {
 7715:             aRun->SetSimpleGlyph(i, g.SetSimpleGlyph(advanceAppUnits, glyph));
    1:         } else {
    1:             gfxTextRun::DetailedGlyph details;
    1:             details.mGlyphID = glyph;
    1:             details.mAdvance = advanceAppUnits;
    1:             details.mXOffset = 0;
    1:             details.mYOffset = 0;
 7715:             aRun->SetGlyphs(i, g.SetComplex(PR_TRUE, PR_TRUE, 1), &details);
    1:         }
    1:     }
    1:     return PR_TRUE;
    1: }
    1: 
    1: void
    1: gfxWindowsFontGroup::InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun,
    1:                                     const char *aString, PRUint32 aLength)
    1: {
 2252:     nsRefPtr<gfxWindowsFont> font = GetFontAt(0);
 4363:     DCFromContext dc(aContext);
 4363:     if (SetupDCFont(dc, font)) {
 6076:         nsAutoTArray<WCHAR,500> glyphArray;
 6076:         if (!glyphArray.SetLength(aLength))
    1:             return;
    1: 
 6076:         DWORD ret = GetGlyphIndicesA(dc, aString, aLength, (WORD*) glyphArray.Elements(),
  127:                                      GGI_MARK_NONEXISTING_GLYPHS);
  127:         if (ret != GDI_ERROR &&
 6076:             SetupTextRunFromGlyphs(aRun, glyphArray.Elements(), dc, font))
  127:             return;
  127:     }
  127: 
    1:     nsDependentCSubstring cString(aString, aString + aLength);
    1:     nsAutoString utf16;
    1:     AppendASCIItoUTF16(cString, utf16);
    1:     InitTextRunUniscribe(aContext, aRun, utf16.get(), aLength);
    1: }
    1: 
    1: void
    1: gfxWindowsFontGroup::InitTextRunGDI(gfxContext *aContext, gfxTextRun *aRun,
    1:                                     const PRUnichar *aString, PRUint32 aLength)
    1: {
 2252:     nsRefPtr<gfxWindowsFont> font = GetFontAt(0);
 4363:     DCFromContext dc(aContext);
 4363:     if (SetupDCFont(dc, font)) {
 6076:         nsAutoTArray<WCHAR,500> glyphArray;
 6076:         if (!glyphArray.SetLength(aLength))
    1:             return;
    1: 
 6076:         DWORD ret = GetGlyphIndicesW(dc, aString, aLength, (WORD*) glyphArray.Elements(),
  127:                                      GGI_MARK_NONEXISTING_GLYPHS);
  127:         if (ret != GDI_ERROR &&
 6076:             SetupTextRunFromGlyphs(aRun, glyphArray.Elements(), dc, font))
    1:             return;
    1:     }
    1: 
  127:     InitTextRunUniscribe(aContext, aRun, aString, aLength);
    1: }
    1: 
    1: /*******************
    1:  * Uniscribe
    1:  *******************/
    1: 
    1: /* we map primary language id's to this to look up language codes */
    1: struct ScriptPropertyEntry {
    1:     const char *value;
    1:     const char *langCode;
    1: };
    1: 
    1: static const struct ScriptPropertyEntry gScriptToText[] =
    1: {
    1:     { nsnull, nsnull },
13578:     { "LANG_ARABIC",     "ar" }, // ara
    1:     { "LANG_BULGARIAN",  "bul" },
    1:     { "LANG_CATALAN",    "cat" },
    1:     { "LANG_CHINESE",    "zh-CN" }, //XXX right lang code?
    1:     { "LANG_CZECH",      "cze" }, // cze/ces
    1:     { "LANG_DANISH",     "dan" },
    1:     { "LANG_GERMAN",     "ger" }, // ger/deu
    1:     { "LANG_GREEK",      "el" }, // gre/ell
    1:     { "LANG_ENGLISH",    "x-western" },
    1:     { "LANG_SPANISH",    "spa" },
    1:     { "LANG_FINNISH",    "fin" },
    1:     { "LANG_FRENCH",     "fre" }, // fre/fra
    1:     { "LANG_HEBREW",     "he" }, // heb
    1:     { "LANG_HUNGARIAN",  "hun" },
    1:     { "LANG_ICELANDIC",  "ice" }, // ice/isl
    1:     { "LANG_ITALIAN",    "ita" },
    1:     { "LANG_JAPANESE",   "ja" }, // jpn
    1:     { "LANG_KOREAN",     "ko" }, // kor
    1:     { "LANG_DUTCH",      "dut" }, // dut/nld
    1:     { "LANG_NORWEGIAN",  "nor" },
    1:     { "LANG_POLISH",     "pol" },
    1:     { "LANG_PORTUGUESE", "por" },
    1:     { nsnull, nsnull },
    1:     { "LANG_ROMANIAN",   "rum" }, // rum/ron
    1:     { "LANG_RUSSIAN",    "rus" },
    1:     { "LANG_SERBIAN",    "scc" }, // scc/srp
    1:     { "LANG_SLOVAK",     "slo" }, // slo/slk
    1:     { "LANG_ALBANIAN",   "alb" }, // alb/sqi
    1:     { "LANG_SWEDISH",    "swe" },
    1:     { "LANG_THAI",       "th" }, // tha
    1:     { "LANG_TURKISH",    "tr" }, // tur
    1:     { "LANG_URDU",       "urd" },
    1:     { "LANG_INDONESIAN", "ind" },
    1:     { "LANG_UKRAINIAN",  "ukr" },
    1:     { "LANG_BELARUSIAN", "bel" },
    1:     { "LANG_SLOVENIAN",  "slv" },
    1:     { "LANG_ESTONIAN",   "est" },
    1:     { "LANG_LATVIAN",    "lav" },
    1:     { "LANG_LITHUANIAN", "lit" },
    1:     { nsnull, nsnull },
    1:     { "LANG_FARSI",      "per" }, // per/fas
    1:     { "LANG_VIETNAMESE", "vie" },
    1:     { "LANG_ARMENIAN",   "x-armn" }, // arm/hye
    1:     { "LANG_AZERI",      "aze" },
    1:     { "LANG_BASQUE",     "baq" }, // baq/eus
    1:     { nsnull, nsnull },
    1:     { "LANG_MACEDONIAN", "mac" }, // mac/mkd
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { "LANG_AFRIKAANS",  "afr" },
    1:     { "LANG_GEORGIAN",   "x-geor" }, // geo
    1:     { "LANG_FAEROESE",   "fao" },
    1:     { "LANG_HINDI",      "x-devanagari" }, // hin
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { "LANG_MALAY",      "may" }, // may/msa
    1:     { "LANG_KAZAK",      "kaz" }, // listed as kazakh?
    1:     { "LANG_KYRGYZ",     "kis" },
    1:     { "LANG_SWAHILI",    "swa" },
    1:     { nsnull, nsnull },
    1:     { "LANG_UZBEK",      "uzb" },
    1:     { "LANG_TATAR",      "tat" },
    1:     { "LANG_BENGALI",    "x-beng" }, // ben
    1:     { "LANG_PUNJABI",    "x-guru" }, // pan -- XXX x-guru is for Gurmukhi which isn't just Punjabi
    1:     { "LANG_GUJARATI",   "x-gujr" }, // guj
13885:     { "LANG_ORIYA",      "x-orya" }, // ori
    1:     { "LANG_TAMIL",      "x-tamil" }, // tam
13885:     { "LANG_TELUGU",     "x-telu" },  //tel
13885:     { "LANG_KANNADA",    "x-knda" },  // kan
    1:     { "LANG_MALAYALAM",  "x-mlym" }, // mal
13885:     { "LANG_ASSAMESE",   "x-beng" },    // asm
13885:     { "LANG_MARATHI",    "x-devanagari" }, // mar
13885:     { "LANG_SANSKRIT",   "x-devanagari" }, // san
    1:     { "LANG_MONGOLIAN",  "mon" },
    1:     { "TIBETAN",         "tib" }, // tib/bod
    1:     { nsnull, nsnull },
    1:     { "KHMER",           "x-khmr" }, // khm
    1:     { "LAO",             "lao" },
    1:     { "MYANMAR",         "bur" }, // bur/mya
    1:     { "LANG_GALICIAN",   "glg" },
    1:     { "LANG_KONKANI",    "kok" },
    1:     { "LANG_MANIPURI",   "mni" },
13885:     { "LANG_SINDHI",     "snd" },
    1:     { "LANG_SYRIAC",     "syr" },
13885:     { "SINHALESE",       "x-sinh" }, // sin
    1:     { "CHEROKEE",        "chr" },
    1:     { "INUKTITUT",       "x-cans" }, // iku
    1:     { "ETHIOPIC",        "x-ethi" }, // amh -- this is both Amharic and Tigrinya
    1:     { nsnull, nsnull },
13885:     { "LANG_KASHMIRI",   "kas" },
    1:     { "LANG_NEPALI",     "x-devanagari" }, // nep
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { nsnull, nsnull },
    1:     { "LANG_DIVEHI",     "div" }
    1: };
    1: 
    1: static const char *sCJKLangGroup[] = {
    1:     "ja",
    1:     "ko",
    1:     "zh-CN",
    1:     "zh-HK",
    1:     "zh-TW"
    1: };
    1: 
    1: #define COUNT_OF_CJK_LANG_GROUP 5
    1: #define CJK_LANG_JA    sCJKLangGroup[0]
    1: #define CJK_LANG_KO    sCJKLangGroup[1]
    1: #define CJK_LANG_ZH_CN sCJKLangGroup[2]
    1: #define CJK_LANG_ZH_HK sCJKLangGroup[3]
    1: #define CJK_LANG_ZH_TW sCJKLangGroup[4]
    1: 
    1: #define STATIC_STRING_LENGTH 100
    1: 
 7625: #define ESTIMATE_MAX_GLYPHS(L) (((3 * (L)) >> 1) + 16)
 7625: 
    1: class UniscribeItem
    1: {
    1: public:
    1:     UniscribeItem(gfxContext *aContext, HDC aDC,
    1:                   const PRUnichar *aString, PRUint32 aLength,
    1:                   SCRIPT_ITEM *aItem,
    1:                   gfxWindowsFontGroup *aGroup) :
 2252:         mContext(aContext), mDC(aDC), mRangeString(nsnull), mRangeLength(0),
 2252:         mItemString(aString), mItemLength(aLength), 
 2252:         mAlternativeString(nsnull), mScriptItem(aItem),
    1:         mScript(aItem->a.eScript), mGroup(aGroup),
 7625:         mNumGlyphs(0), mMaxGlyphs(ESTIMATE_MAX_GLYPHS(aLength)),
    1:         mFontSelected(PR_FALSE)
    1:     {
 7625:         NS_ASSERTION(mMaxGlyphs < 65535, "UniscribeItem is too big, ScriptShape() will fail!");
 6076:         mGlyphs.SetLength(mMaxGlyphs);
 6076:         mClusters.SetLength(mItemLength + 1);
 6076:         mAttr.SetLength(mMaxGlyphs);
    1:     }
    1: 
    1:     ~UniscribeItem() {
    1:         free(mAlternativeString);
    1:     }
    1: 
    1:     /* possible return values:
 1959:      * S_OK - things succeeded
 1959:      * GDI_ERROR - things failed to shape.  Might want to try again after calling DisableShaping()
    1:      */
12992: 
12992:     HRESULT ShapeUniscribe() {
    1:         HRESULT rv;
    1:         HDC shapeDC = nsnull;
    1: 
 2252:         const PRUnichar *str = mAlternativeString ? mAlternativeString : mRangeString;
 1959: 
 6299:         mScriptItem->a.fLogicalOrder = PR_TRUE; 
 5308:         SCRIPT_ANALYSIS sa = mScriptItem->a;
 5308:         /*
 5308:           fLinkBefore and fLinkAfter in the SCRIPT_ANALYSIS structure refer to
 5308:           the whole item, so if the current range begins after the beginning
 5308:           of the item or ends before the end of the item, we need to override
 5308:           them here.
 5308:           This assumes that we won't split an item into ranges between two
 5308:           characters that need to be shaped together.
 5308:         */
 5308:         if (mRangeString > mItemString)
 5308:             sa.fLinkBefore = PR_FALSE;
 5308:         if (mRangeString + mRangeLength < mItemString + mItemLength)
 5308:             sa.fLinkAfter = PR_FALSE;
 5308: 
    1:         while (PR_TRUE) {
  282: 
    1:             rv = ScriptShape(shapeDC, mCurrentFont->ScriptCache(),
 2252:                              str, mRangeLength,
 5308:                              mMaxGlyphs, &sa,
 6076:                              mGlyphs.Elements(), mClusters.Elements(),
 6076:                              mAttr.Elements(), &mNumGlyphs);
    1: 
    1:             if (rv == E_OUTOFMEMORY) {
 6076:                 mGlyphs.SetLength(mMaxGlyphs);
 6076:                 mAttr.SetLength(mMaxGlyphs);
    1:                 mMaxGlyphs *= 2;
    1:                 continue;
    1:             }
    1: 
    1:             if (rv == E_PENDING) {
 4363:                 if (shapeDC == mDC) {
 4363:                     // we already tried this once, something failed, give up
14918:                     return E_PENDING;
 4363:                 }
 4363: 
    1:                 SelectFont();
    1: 
    1:                 shapeDC = mDC;
    1:                 continue;
    1:             }
12992: 
    1:             return rv;
    1:         }
    1:     }
    1: 
12992:     HRESULT ShapeGDI() {
12992:         SelectFont();
12992: 
12992:         mNumGlyphs = mRangeLength;
12992:         GetGlyphIndicesW(mDC, mRangeString, mRangeLength,
12992:                          (WORD*) mGlyphs.Elements(),
12992:                          GGI_MARK_NONEXISTING_GLYPHS);
12992: 
13439:         for (PRUint32 i = 0; i < mRangeLength; ++i)
12992:             mClusters[i] = i;
12992: 
12992:         return S_OK;
12992:     }
12992: 
12992:     HRESULT Shape() {
13439:         // Skip Uniscribe for fonts that need GDI
13439:         if (mCurrentFont->GetFontEntry()->mForceGDI)
12992:             return ShapeGDI();
12992: 
12992:         return ShapeUniscribe();
12992:     }
12992: 
    1:     PRBool ShapingEnabled() {
    1:         return (mScriptItem->a.eScript != SCRIPT_UNDEFINED);
    1:     }
    1:     void DisableShaping() {
    1:         mScriptItem->a.eScript = SCRIPT_UNDEFINED;
    1:         // Note: If we disable the shaping by using SCRIPT_UNDEFINED and
    1:         // the string has the surrogate pair, ScriptShape API is
    1:         // *sometimes* crashed. Therefore, we should replace the surrogate
    1:         // pair to U+FFFD. See bug 341500.
    1:         GenerateAlternativeString();
    1:     }
 2252:     void EnableShaping() {
 2252:         mScriptItem->a.eScript = mScript;
 2252:         if (mAlternativeString) {
 2252:             free(mAlternativeString);
 2252:             mAlternativeString = nsnull;
 1959:         }
  282:     }
  282: 
  282:     PRBool IsGlyphMissing(SCRIPT_FONTPROPERTIES *aSFP, PRUint32 aGlyphIndex) {
13097:         PRBool missing = PR_FALSE;
13439:         if (GetCurrentFont()->GetFontEntry()->mForceGDI) {
13439:             // Our GDI path marks missing glyphs as 0xFFFF. So just look for that.
13097:             if (mGlyphs[aGlyphIndex] == 0xFFFF)
13097:                 missing = PR_TRUE;
13097:         } else if (mGlyphs[aGlyphIndex] == aSFP->wgDefault) {
13097:             missing = PR_TRUE;
13097:         }
13097:         return missing;
    1:     }
    1: 
11748: 
11748:     HRESULT PlaceUniscribe() {
    1:         HRESULT rv;
    1:         HDC placeDC = nsnull;
    1: 
    1:         while (PR_TRUE) {
    1:             rv = ScriptPlace(placeDC, mCurrentFont->ScriptCache(),
 6076:                              mGlyphs.Elements(), mNumGlyphs,
 6076:                              mAttr.Elements(), &mScriptItem->a,
 6076:                              mAdvances.Elements(), mOffsets.Elements(), NULL);
    1: 
    1:             if (rv == E_PENDING) {
    1:                 SelectFont();
    1:                 placeDC = mDC;
    1:                 continue;
    1:             }
    1: 
    1:             break;
    1:         }
    1: 
    1:         return rv;
    1:     }
    1: 
11748:     HRESULT PlaceGDI() {
11748:         SelectFont();
11748: 
11748:         nsAutoTArray<int,500> partialWidthArray;
14918:         // Callers incorrectly assume this code is infallible,
14918:         // so we must abort on this OOM condition.
11748:         if (!partialWidthArray.SetLength(mNumGlyphs))
14918:             PR_Abort();
11748:         SIZE size;
11748: 
11748:         GetTextExtentExPointI(mDC,
11748:                               (WORD*) mGlyphs.Elements(),
11748:                               mNumGlyphs,
11748:                               INT_MAX,
11748:                               NULL,
11748:                               partialWidthArray.Elements(),
11748:                               &size);
11748: 
11748:         PRInt32 lastWidth = 0;
11748: 
11748:         for (PRUint32 i = 0; i < mNumGlyphs; i++) {
11748:             mAdvances[i] = partialWidthArray[i] - lastWidth;
11748:             lastWidth = partialWidthArray[i];
11748:             mOffsets[i].du = mOffsets[i].dv = 0;
11748:         }
11748:         return 0;
11748:     }
11748: 
11748:     HRESULT Place() {
11748:         mOffsets.SetLength(mNumGlyphs);
11748:         mAdvances.SetLength(mNumGlyphs);
11748: 
11748:         PRBool allCJK = PR_TRUE;
12992: 
13439:         // Some fonts don't get along with Uniscribe so we'll use GDI to
13439:         // render them.
13439:         if (!mCurrentFont->GetFontEntry()->mForceGDI) {
11748:             for (PRUint32 i = 0; i < mRangeLength; i++) {
11748:                 const PRUnichar ch = mRangeString[i];
11748:                 if (ch == ' ' || FindCharUnicodeRange(ch) == kRangeSetCJK)
11748:                     continue;
11748: 
11748:                 allCJK = PR_FALSE;
11748:                 break;
11748:             }
12992:         }
11748: 
13879:         if (allCJK)
11748:             return PlaceGDI();
11748: 
11748:         return PlaceUniscribe();
11748:     }
11748: 
    1:     const SCRIPT_PROPERTIES *ScriptProperties() {
    1:         /* we can use this to figure out in some cases the language of the item */
    1:         static const SCRIPT_PROPERTIES **gScriptProperties;
    1:         static int gMaxScript = -1;
    1: 
    1:         if (gMaxScript == -1) {
    1:             ScriptGetProperties(&gScriptProperties, &gMaxScript);
    1:         }
    1:         return gScriptProperties[mScript];
    1:     }
    1: 
    1:     void ScriptFontProperties(SCRIPT_FONTPROPERTIES *sfp) {
    1:         HRESULT rv;
    1: 
    1:         memset(sfp, 0, sizeof(SCRIPT_FONTPROPERTIES));
    1:         sfp->cBytes = sizeof(SCRIPT_FONTPROPERTIES);
    1:         rv = ScriptGetFontProperties(NULL, mCurrentFont->ScriptCache(),
    1:                                      sfp);
    1:         if (rv == E_PENDING) {
    1:             SelectFont();
    1:             rv = ScriptGetFontProperties(mDC, mCurrentFont->ScriptCache(),
    1:                                          sfp);
    1:         }
    1:     }
    1: 
    1:     void SetupClusterBoundaries(gfxTextRun *aRun, PRUint32 aOffsetInRun) {
    1:         if (aRun->GetFlags() & gfxTextRunFactory::TEXT_IS_8BIT)
    1:             return;
    1: 
    1:         nsAutoTArray<SCRIPT_LOGATTR,STATIC_STRING_LENGTH> logAttr;
 2252:         if (!logAttr.AppendElements(mRangeLength))
    1:             return;
 2252:         HRESULT rv = ScriptBreak(mRangeString, mRangeLength,
 2252:                                  &mScriptItem->a, logAttr.Elements());
    1:         if (FAILED(rv))
    1:             return;
    1:         gfxTextRun::CompressedGlyph g;
  277:         // The first character is never inside a cluster. Windows might tell us
  277:         // that it should be, but we have no before-character to cluster
  277:         // it with so we just can't cluster it. So skip it here.
 2252:         for (PRUint32 i = 1; i < mRangeLength; ++i) {
    1:             if (!logAttr[i].fCharStop) {
 7715:                 aRun->SetGlyphs(i + aOffsetInRun, g.SetComplex(PR_FALSE, PR_TRUE, 0), nsnull);
    1:             }
    1:         }
    1:     }
    1: 
    1:     void SaveGlyphs(gfxTextRun *aRun) {
 2252:         PRUint32 offsetInRun = mScriptItem->iCharPos + (mRangeString - mItemString);
    1:         SetupClusterBoundaries(aRun, offsetInRun);
    1: 
  132:         aRun->AddGlyphRun(GetCurrentFont(), offsetInRun);
  132: 
    1:         // XXX We should store this in the item and only fetch it once
    1:         SCRIPT_FONTPROPERTIES sfp;
    1:         ScriptFontProperties(&sfp);
    1: 
    1:         PRUint32 offset = 0;
    1:         nsAutoTArray<gfxTextRun::DetailedGlyph,1> detailedGlyphs;
    1:         gfxTextRun::CompressedGlyph g;
    1:         const PRUint32 appUnitsPerDevUnit = aRun->GetAppUnitsPerDevUnit();
 2252:         while (offset < mRangeLength) {
    1:             PRUint32 runOffset = offsetInRun + offset;
    1:             if (offset > 0 && mClusters[offset] == mClusters[offset - 1]) {
 7715:                 g.SetComplex(aRun->IsClusterStart(runOffset), PR_FALSE, 0);
 7715:                 aRun->SetGlyphs(runOffset, g, nsnull);
    1:             } else {
    1:                 // Count glyphs for this character
    1:                 PRUint32 k = mClusters[offset];
    1:                 PRUint32 glyphCount = mNumGlyphs - k;
    1:                 PRUint32 nextClusterOffset;
  282:                 PRBool missing = IsGlyphMissing(&sfp, k);
 2252:                 for (nextClusterOffset = offset + 1; nextClusterOffset < mRangeLength; ++nextClusterOffset) {
    1:                     if (mClusters[nextClusterOffset] > k) {
    1:                         glyphCount = mClusters[nextClusterOffset] - k;
    1:                         break;
    1:                     }
    1:                 }
    1:                 PRUint32 j;
    1:                 for (j = 1; j < glyphCount; ++j) {
  282:                     if (IsGlyphMissing(&sfp, k + j)) {
    1:                         missing = PR_TRUE;
    1:                     }
    1:                 }
    1:                 PRInt32 advance = mAdvances[k]*appUnitsPerDevUnit;
    1:                 WORD glyph = mGlyphs[k];
 3119:                 NS_ASSERTION(!gfxFontGroup::IsInvalidChar(mRangeString[offset]),
 3119:                              "invalid character detected");
 3119:                 if (missing) {
 6135:                     if (NS_IS_HIGH_SURROGATE(mRangeString[offset]) &&
 6135:                         offset + 1 < mRangeLength &&
 6135:                         NS_IS_LOW_SURROGATE(mRangeString[offset + 1])) {
 6135:                         aRun->SetMissingGlyph(runOffset,
 6135:                                               SURROGATE_TO_UCS4(mRangeString[offset],
 6135:                                                                 mRangeString[offset + 1]));
 6135:                     } else {
 2252:                         aRun->SetMissingGlyph(runOffset, mRangeString[offset]);
 6135:                     }
    1:                 } else if (glyphCount == 1 && advance >= 0 &&
    1:                     mOffsets[k].dv == 0 && mOffsets[k].du == 0 &&
    1:                     gfxTextRun::CompressedGlyph::IsSimpleAdvance(advance) &&
    1:                     gfxTextRun::CompressedGlyph::IsSimpleGlyphID(glyph)) {
 7715:                     aRun->SetSimpleGlyph(runOffset, g.SetSimpleGlyph(advance, glyph));
    1:                 } else {
    1:                     if (detailedGlyphs.Length() < glyphCount) {
    1:                         if (!detailedGlyphs.AppendElements(glyphCount - detailedGlyphs.Length()))
    1:                             return;
    1:                     }
    1:                     PRUint32 i;
    1:                     for (i = 0; i < glyphCount; ++i) {
    1:                         gfxTextRun::DetailedGlyph *details = &detailedGlyphs[i];
    1:                         details->mGlyphID = mGlyphs[k + i];
    1:                         details->mAdvance = mAdvances[k + i]*appUnitsPerDevUnit;
  780:                         details->mXOffset = float(mOffsets[k + i].du)*appUnitsPerDevUnit*aRun->GetDirection();
    1:                         details->mYOffset = float(mOffsets[k + i].dv)*appUnitsPerDevUnit;
    1:                     }
 7715:                     aRun->SetGlyphs(runOffset,
 7715:                         g.SetComplex(PR_TRUE, PR_TRUE, glyphCount), detailedGlyphs.Elements());
    1:                 }
    1:             }
    1:             ++offset;
    1:         }
    1:     }
    1: 
    1:     void SetCurrentFont(gfxWindowsFont *aFont) {
    1:         if (mCurrentFont != aFont) {
    1:             mCurrentFont = aFont;
 4304:             cairo_scaled_font_t *scaledFont = mCurrentFont->CairoScaledFont();
 4304:             cairo_win32_scaled_font_done_font(scaledFont);
    1:             mFontSelected = PR_FALSE;
    1:         }
    1:     }
    1: 
    1:     gfxWindowsFont *GetCurrentFont() {
    1:         return mCurrentFont;
    1:     }
    1: 
    1:     void SelectFont() {
    1:         if (mFontSelected)
    1:             return;
    1: 
    1:         cairo_t *cr = mContext->GetCairo();
    1: 
    1:         cairo_set_font_face(cr, mCurrentFont->CairoFontFace());
    1:         cairo_set_font_size(cr, mCurrentFont->GetAdjustedSize());
 4304:         cairo_scaled_font_t *scaledFont = mCurrentFont->CairoScaledFont();
 4304:         cairo_win32_scaled_font_select_font(scaledFont, mDC);
    1: 
    1:         mFontSelected = PR_TRUE;
    1:     }
    1: 
 2252:     struct TextRange {
 2252:         TextRange(PRUint32 aStart,  PRUint32 aEnd) : start(aStart), end(aEnd) { }
 2252:         PRUint32 Length() const { return end - start; }
14798:         nsRefPtr<gfxWindowsFont> font;
 2252:         PRUint32 start, end;
 2252:     };
 2252: 
 2252:     void SetRange(PRUint32 i) {
14798:         nsRefPtr<gfxWindowsFont> font;
 2252:         if (mRanges[i].font)
14798:             font = mRanges[i].font;
 2252:         else
14798:             font = mGroup->GetFontAt(0);
 2252: 
 2252:         SetCurrentFont(font);
 2252: 
 2252:         mRangeString = mItemString + mRanges[i].start;
 2252:         mRangeLength = mRanges[i].Length();
 2252:     }
 2252: 
13097:     PRBool HasCharacter(FontEntry *aFontEntry, PRUint32 ch) {
13097:         if (aFontEntry->mCharacterMap.test(ch))
13097:             return PR_TRUE;
13097: 
13879:         if (aFontEntry->mUnknownCMAP) {
13097:             if (ch > 0xFFFF)
13097:                 return PR_FALSE;
13097: 
14798:             nsRefPtr<gfxWindowsFont> font =
14798:                 gfxWindowsFont::GetOrMakeFont(aFontEntry, mGroup->GetStyle());
14798:             if (!font->IsValid())
14798:                 return PR_FALSE;
13097: 
13097:             HDC dc = GetDC((HWND)nsnull);
15061:             SetGraphicsMode(dc, GM_ADVANCED);
13097:             HFONT hfont = font->GetHFONT();
14208:             HFONT oldFont = (HFONT)SelectObject(dc, hfont);
13097: 
13097:             PRUnichar str[1] = { (PRUnichar)ch };
13097:             WORD glyph[1];
13097: 
14034:             PRBool hasGlyph = PR_FALSE;
15022:             if (aFontEntry->IsType1()) {
14034:                 // Type1 fonts and uniscribe APIs don't get along.  ScriptGetCMap will return E_HANDLE
14034:                 DWORD ret = GetGlyphIndicesW(dc, str, 1, glyph, GGI_MARK_NONEXISTING_GLYPHS);
14034:                 if (ret != GDI_ERROR && glyph[0] != 0xFFFF)
14034:                     hasGlyph = PR_TRUE;
14034:             } else {
13879:                 // ScriptGetCMap works better than GetGlyphIndicesW for things like bitmap/vector fonts
13879:                 HRESULT rv = ScriptGetCMap(dc, font->ScriptCache(), str, 1, 0, glyph);
14034:                 if (rv == S_OK)
14034:                     hasGlyph = PR_TRUE;
14034:             }
13097: 
14034:             if (hasGlyph) {
13097:                 aFontEntry->mCharacterMap.set(ch);
13097:                 return PR_TRUE;
13097:             }
14208: 
14208:             SelectObject(dc, oldFont);
14208:             ReleaseDC(NULL, dc);
13097:         }
13097: 
13097:         return PR_FALSE;
13097:     }
13097: 
14798:     inline already_AddRefed<gfxWindowsFont>
14798:     WhichFontSupportsChar(const nsTArray<nsRefPtr<FontEntry> >& fonts, PRUint32 ch) {
 2252:         for (PRUint32 i = 0; i < fonts.Length(); i++) {
 2252:             nsRefPtr<FontEntry> fe = fonts[i];
13449:             if (fe->mSymbolFont && !mGroup->GetStyle()->familyNameQuirks)
13449:                 continue;
14798:             if (HasCharacter(fe, ch)) {
14798:                 nsRefPtr<gfxWindowsFont> font =
14798:                     gfxWindowsFont::GetOrMakeFont(fe, mGroup->GetStyle());
14798:                 // Check that the font is still usable.
14798:                 if (!font->IsValid())
14798:                     continue;
14798:                 return font.forget();
14798:             }
 2252:         }
 2252:         return nsnull;
 2252:     }
 2252: 
 2307:     static inline bool IsJoiner(PRUint32 ch) {
 2307:         return (ch == 0x200C ||
 2307:                 ch == 0x200D ||
 2307:                 ch == 0x2060);
 2307:     }
 2307: 
14798:     inline already_AddRefed<gfxWindowsFont>
14798:     FindFontForChar(PRUint32 ch, PRUint32 prevCh, PRUint32 nextCh,
14798:                     gfxWindowsFont *aFont) {
14798:         nsRefPtr<gfxWindowsFont> selectedFont;
 2252: 
 2307:         // if this character or the next one is a joiner use the
 2307:         // same font as the previous range if we can
 2307:         if (IsJoiner(ch) || IsJoiner(prevCh) || IsJoiner(nextCh)) {
14798:             if (aFont && HasCharacter(aFont->GetFontEntry(), ch)) {
14798:                 NS_ADDREF(aFont);
 2307:                 return aFont;
 2307:             }
14798:         }
 2307: 
 2252:         // check the list of fonts
 2252:         selectedFont = WhichFontSupportsChar(mGroup->GetFontList(), ch);
 2252: 
 7375:         // don't look in other fonts if the character is in a Private Use Area
 7375:         if ((ch >= 0xE000  && ch <= 0xF8FF) || 
 7375:             (ch >= 0xF0000 && ch <= 0x10FFFD))
14798:             return selectedFont.forget();
 7375: 
13578:         // check out the style's language group
13578:         if (!selectedFont) {
13578:             nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
13578:             this->GetPrefFonts(mGroup->GetStyle()->langGroup.get(), fonts);
13578:             selectedFont = WhichFontSupportsChar(fonts, ch);
13578:         }
13578: 
 2252:         // otherwise search prefs
 2252:         if (!selectedFont) {
 2252:             /* first check with the script properties to see what they think */
 2252:             const SCRIPT_PROPERTIES *sp = ScriptProperties();
 2252:             if (!sp->fAmbiguousCharSet) {
 2252:                 WORD primaryId = PRIMARYLANGID(sp->langid);
 2252:                 const char *langGroup = gScriptToText[primaryId].langCode;
 2252:                 if (langGroup) {
 2252:                     PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: %s (%s)", langGroup, gScriptToText[primaryId].value));
 2252: 
 5254:                     nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
 2252:                     this->GetPrefFonts(langGroup, fonts);
 2252:                     selectedFont = WhichFontSupportsChar(fonts, ch);
 2252:                 }
 2773:             } else if (ch <= 0xFFFF) {
 2252:                 PRUint32 unicodeRange = FindCharUnicodeRange(ch);
 2252: 
 2252:                 /* special case CJK */
 2252:                 if (unicodeRange == kRangeSetCJK) {
 2252:                     if (PR_LOG_TEST(gFontLog, PR_LOG_DEBUG))
 2252:                         PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: CJK"));
 2252: 
 5254:                     nsAutoTArray<nsRefPtr<FontEntry>, 15> fonts;
 2252:                     this->GetCJKPrefFonts(fonts);
 2252:                     selectedFont = WhichFontSupportsChar(fonts, ch);
 2252:                 } else {
 2252:                     const char *langGroup = LangGroupFromUnicodeRange(unicodeRange);
 2252:                     if (langGroup) {
 2252:                         PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Trying to find fonts for: %s", langGroup));
 2252: 
 5254:                         nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
 2252:                         this->GetPrefFonts(langGroup, fonts);
 2252:                         selectedFont = WhichFontSupportsChar(fonts, ch);
 2252:                     }
 2252:                 }
 2252:             }
 2773:         }
 2252: 
 2252:         // before searching for something else check the font used for the previous character
14798:         if (!selectedFont && aFont && HasCharacter(aFont->GetFontEntry(), ch))
 2252:             selectedFont = aFont;
 2252: 
 2252:         // otherwise look for other stuff
 2252:         if (!selectedFont) {
 2252:             PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Looking for best match"));
 2252: 
 2252:             nsRefPtr<gfxWindowsFont> refFont = mGroup->GetFontAt(0);
 2252:             gfxWindowsPlatform *platform = gfxWindowsPlatform::GetPlatform();
12526:             selectedFont = platform->FindFontForChar(ch, refFont);
 2252:         }
 2252: 
14798:         return selectedFont.forget();
 2252:     }
 2252: 
 2252:     PRUint32 ComputeRanges() {
 2252:         if (mItemLength == 0)
 2252:             return 0;
 2252: 
 2252:         PR_LOG(gFontLog, PR_LOG_DEBUG, ("Computing ranges for string: (len = %d)", mItemLength));
 2307: 
 2307:         PRUint32 prevCh = 0;
 2252:         for (PRUint32 i = 0; i < mItemLength; i++) {
 2252:             const PRUint32 origI = i; // save off incase we increase for surrogate
 2252:             PRUint32 ch = mItemString[i];
 2252:             if ((i+1 < mItemLength) && NS_IS_HIGH_SURROGATE(ch) && NS_IS_LOW_SURROGATE(mItemString[i+1])) {
 2252:                 i++;
 2252:                 ch = SURROGATE_TO_UCS4(ch, mItemString[i]);
 2252:             }
 2252: 
 2252:             PR_LOG(gFontLog, PR_LOG_DEBUG, (" 0x%04x - ", ch));
 2307:             PRUint32 nextCh = 0;
 2307:             if (i+1 < mItemLength) {
 2307:                 nextCh = mItemString[i+1];
14444:                 if ((i+2 < mItemLength) && NS_IS_HIGH_SURROGATE(nextCh) && NS_IS_LOW_SURROGATE(mItemString[i+2]))
 2307:                     nextCh = SURROGATE_TO_UCS4(nextCh, mItemString[i+2]);
 2307:             }
14798:             nsRefPtr<gfxWindowsFont> font =
14798:                 FindFontForChar(ch,
 2307:                                 prevCh,
 2307:                                 nextCh,
 2307:                                 (mRanges.Length() == 0) ? nsnull : mRanges[mRanges.Length() - 1].font);
 2307: 
 2307:             prevCh = ch;
 2252: 
 2252:             if (mRanges.Length() == 0) {
 2252:                 TextRange r(0,1);
14798:                 r.font = font;
 2252:                 mRanges.AppendElement(r);
 2252:             } else {
 2252:                 TextRange& prevRange = mRanges[mRanges.Length() - 1];
14798:                 if (prevRange.font != font) {
 2252:                     // close out the previous range
 2252:                     prevRange.end = origI;
 2252: 
10830:                     TextRange r(origI, i+1);
14798:                     r.font = font;
 2252:                     mRanges.AppendElement(r);
 2252:                 }
 2252:             }
 2307:             if (PR_LOG_TEST(gFontLog, PR_LOG_DEBUG)) {
14798:                 if (font)
14798:                     PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Using %s", NS_LossyConvertUTF16toASCII(font->GetUniqueName()).get()));
 2307:                 else
 2307:                     PR_LOG(gFontLog, PR_LOG_DEBUG, (" - Unable to find font"));
 2307:             }
 2252:         }
 2252:         mRanges[mRanges.Length()-1].end = mItemLength;
 2252: 
 2252:         PRUint32 nranges = mRanges.Length();
 2252:         PR_LOG(gFontLog, PR_LOG_DEBUG, (" Found %d ranges", nranges));
 2252:         return nranges;
 2252:     }
 2252: 
    1: private:
    1:     static PRInt32 GetCJKLangGroupIndex(const char *aLangGroup) {
    1:         PRInt32 i;
    1:         for (i = 0; i < COUNT_OF_CJK_LANG_GROUP; i++) {
    1:             if (!PL_strcasecmp(aLangGroup, sCJKLangGroup[i]))
    1:                 return i;
    1:         }
    1:         return -1;
    1:     }
    1: 
 5259:     // this function appends to the array passed in.
 2252:     void GetPrefFonts(const char *aLangGroup, nsTArray<nsRefPtr<FontEntry> >& array) {
    1:         NS_ASSERTION(aLangGroup, "aLangGroup is null");
 5254:         gfxWindowsPlatform *platform = gfxWindowsPlatform::GetPlatform();
 5254:         nsAutoTArray<nsRefPtr<FontEntry>, 5> fonts;
13280:         /* this lookup has to depend on weight and style */
13280:         nsCAutoString key(aLangGroup);
13280:         key.Append("-");
13280:         key.AppendInt(mGroup->GetStyle()->style);
13280:         key.Append("-");
13280:         key.AppendInt(mGroup->GetStyle()->weight);
13280:         if (!platform->GetPrefFontEntries(key, &fonts)) {
 5254:             nsString fontString;
 5254:             platform->GetPrefFonts(aLangGroup, fontString);
 5254:             if (fontString.IsEmpty())
    1:                 return;
 5254: 
13280:             mGroup->FamilyListToArrayList(fontString, nsDependentCString(aLangGroup),
13280:                                           &fonts);
13280: 
13280:             platform->SetPrefFontEntries(key, fonts);
 5254:         }
 5254:         array.AppendElements(fonts);
    1:     }
    1: 
 5259:     // this function assigns to the array passed in.
 2252:     void GetCJKPrefFonts(nsTArray<nsRefPtr<FontEntry> >& array) {
 5259:         gfxWindowsPlatform *platform = gfxWindowsPlatform::GetPlatform();
13280: 
13280:         nsCAutoString key("x-internal-cjk-");
13280:         key.AppendInt(mGroup->GetStyle()->style);
13280:         key.Append("-");
13280:         key.AppendInt(mGroup->GetStyle()->weight);
13280: 
13280:         if (!platform->GetPrefFontEntries(key, &array)) {
    1:             nsCOMPtr<nsIPrefService> prefs = do_GetService(NS_PREFSERVICE_CONTRACTID);
    1:             if (!prefs)
    1:                 return;
    1: 
    1:             nsCOMPtr<nsIPrefBranch> prefBranch;
    1:             prefs->GetBranch(0, getter_AddRefs(prefBranch));
    1:             if (!prefBranch)
    1:                 return;
    1: 
11466:             // Add the CJK pref fonts from accept languages, the order should be same order
11466:             nsCAutoString list;
11466:             nsCOMPtr<nsIPrefLocalizedString> val;
11466:             nsresult rv = prefBranch->GetComplexValue("intl.accept_languages", NS_GET_IID(nsIPrefLocalizedString),
11466:                                                       getter_AddRefs(val));
11466:             if (NS_SUCCEEDED(rv) && val) {
11466:                 nsAutoString temp;
11466:                 val->ToString(getter_Copies(temp));
11466:                 LossyCopyUTF16toASCII(temp, list);
11466:             }
11466:             if (!list.IsEmpty()) {
    1:                 const char kComma = ',';
    1:                 const char *p, *p_end;
    1:                 list.BeginReading(p);
    1:                 list.EndReading(p_end);
    1:                 while (p < p_end) {
    1:                     while (nsCRT::IsAsciiSpace(*p)) {
    1:                         if (++p == p_end)
    1:                             break;
    1:                     }
    1:                     if (p == p_end)
    1:                         break;
    1:                     const char *start = p;
    1:                     while (++p != p_end && *p != kComma)
    1:                         /* nothing */ ;
    1:                     nsCAutoString lang(Substring(start, p));
    1:                     lang.CompressWhitespace(PR_FALSE, PR_TRUE);
    1:                     PRInt32 index = GetCJKLangGroupIndex(lang.get());
    1:                     if (index >= 0)
 2252:                         GetPrefFonts(sCJKLangGroup[index], array);
    1:                     p++;
    1:                 }
    1:             }
    1: 
    1:             // Add the system locale
    1:             switch (::GetACP()) {
 2252:                 case 932: GetPrefFonts(CJK_LANG_JA, array); break;
 2252:                 case 936: GetPrefFonts(CJK_LANG_ZH_CN, array); break;
 2252:                 case 949: GetPrefFonts(CJK_LANG_KO, array); break;
    1:                 // XXX Don't we need to append CJK_LANG_ZH_HK if the codepage is 950?
 2252:                 case 950: GetPrefFonts(CJK_LANG_ZH_TW, array); break;
    1:             }
    1: 
    1:             // last resort...
 2252:             GetPrefFonts(CJK_LANG_JA, array);
 2252:             GetPrefFonts(CJK_LANG_KO, array);
 2252:             GetPrefFonts(CJK_LANG_ZH_CN, array);
 2252:             GetPrefFonts(CJK_LANG_ZH_HK, array);
 2252:             GetPrefFonts(CJK_LANG_ZH_TW, array);
 5259: 
13280:             platform->SetPrefFontEntries(key, array);
 5259:         }
    1:     }
    1: 
    1:     void GenerateAlternativeString() {
    1:         if (mAlternativeString)
    1:             free(mAlternativeString);
 2252:         mAlternativeString = (PRUnichar *)malloc(mRangeLength * sizeof(PRUnichar));
 7030:         if (!mAlternativeString)
 7030:             return;
 2252:         memcpy((void *)mAlternativeString, (const void *)mRangeString,
 2252:                mRangeLength * sizeof(PRUnichar));
 2308:         for (PRUint32 i = 0; i < mRangeLength; i++) {
 2252:             if (NS_IS_HIGH_SURROGATE(mRangeString[i]) || NS_IS_LOW_SURROGATE(mRangeString[i]))
    1:                 mAlternativeString[i] = PRUnichar(0xFFFD);
    1:         }
    1:     }
 1959: 
    1: private:
    1:     nsRefPtr<gfxContext> mContext;
    1:     HDC mDC;
    1: 
    1:     SCRIPT_ITEM *mScriptItem;
    1:     WORD mScript;
    1: 
 2252:     // these point to the current range
 2252:     const PRUnichar *mRangeString;
 2252:     PRUint32 mRangeLength;
 2252: 
 2252:     // these point to the full string/length of the item
 2252:     const PRUnichar *mItemString;
 2252:     const PRUint32 mItemLength;
    1: 
    1:     PRUnichar *mAlternativeString;
    1: 
    1:     gfxWindowsFontGroup *mGroup;
    1: 
 5393: #define AVERAGE_ITEM_LENGTH 40
 5393: 
 7625:     nsAutoTArray<WORD, PRUint32(ESTIMATE_MAX_GLYPHS(AVERAGE_ITEM_LENGTH))> mGlyphs;
 6076:     nsAutoTArray<WORD, AVERAGE_ITEM_LENGTH + 1> mClusters;
 7625:     nsAutoTArray<SCRIPT_VISATTR, PRUint32(ESTIMATE_MAX_GLYPHS(AVERAGE_ITEM_LENGTH))> mAttr;
 5393:  
 6076:     nsAutoTArray<GOFFSET, 2 * AVERAGE_ITEM_LENGTH> mOffsets;
 6076:     nsAutoTArray<int, 2 * AVERAGE_ITEM_LENGTH> mAdvances;
 5393: 
 5393: #undef AVERAGE_ITEM_LENGTH
    1: 
    1:     int mMaxGlyphs;
    1:     int mNumGlyphs;
    1: 
    1:     nsRefPtr<gfxWindowsFont> mCurrentFont;
    1: 
    1:     PRPackedBool mFontSelected;
 2252: 
 2252:     nsTArray<TextRange> mRanges;
    1: };
    1: 
 7625: 
 7625: #define MAX_ITEM_LENGTH 32768
 7625: 
 7625: 
 7625: 
 7625: static PRUint32 FindNextItemStart(int aOffset, int aLimit,
 7625:                                   nsTArray<SCRIPT_LOGATTR> &aLogAttr,
 7625:                                   const PRUnichar *aString)
 7625: {
 7625:     if (aOffset + MAX_ITEM_LENGTH >= aLimit) {
 7625:         // The item starting at aOffset can't be longer than the max length,
 7625:         // so starting the next item at aLimit won't cause ScriptShape() to fail.
 7625:         return aLimit;
 7625:     }
 7625: 
 7625:     // Try to start the next item before or after a space, since spaces
 7625:     // don't kern or ligate.
 7625:     PRUint32 off;
 7625:     int boundary = -1;
 7625:     for (off = MAX_ITEM_LENGTH; off > 1; --off) {
 7625:       if (aLogAttr[off].fCharStop) {
 7625:           if (off > boundary) {
 7625:               boundary = off;
 7625:           }
 7625:           if (aString[aOffset+off] == ' ' || aString[aOffset+off - 1] == ' ')
 7625:             return aOffset+off;
 7625:       }
 7625:     }
 7625: 
 7625:     // Try to start the next item at the last cluster boundary in the range.
 7625:     if (boundary > 0) {
 7625:       return aOffset+boundary;
 7625:     }
 7625: 
 7625:     // No nice cluster boundaries inside MAX_ITEM_LENGTH characters, break
 7625:     // on the size limit. It won't be visually plesaing, but at least it
 7625:     // won't cause ScriptShape() to fail.
 7625:     return aOffset + MAX_ITEM_LENGTH;
 7625: }
 7625: 
    1: class Uniscribe
    1: {
    1: public:
    1:     Uniscribe(gfxContext *aContext, HDC aDC, const PRUnichar *aString, PRUint32 aLength, PRBool aIsRTL) :
    1:         mContext(aContext), mDC(aDC), mString(aString), mLength(aLength), mIsRTL(aIsRTL),
    1:         mItems(nsnull) {
    1:     }
  282:     ~Uniscribe() {
  282:     }
    1: 
    1:     void Init() {
    1:         memset(&mControl, 0, sizeof(SCRIPT_CONTROL));
    1:         memset(&mState, 0, sizeof(SCRIPT_STATE));
    1:         // Lock the direction. Don't allow the itemizer to change directions
    1:         // based on character type.
    1:         mState.uBidiLevel = mIsRTL;
    1:         mState.fOverrideDirection = PR_TRUE;
    1:     }
    1: 
 7625: private:
 7625: 
 7625:     // Append mItems[aIndex] to aDest, adding extra items to aDest to ensure
 7625:     // that no item is too long for ScriptShape() to handle. See bug 366643.
 7625:     nsresult CopyItemSplitOversize(int aIndex, nsTArray<SCRIPT_ITEM> &aDest) {
 7625:         aDest.AppendElement(mItems[aIndex]);
 7625:         const int itemLength = mItems[aIndex+1].iCharPos - mItems[aIndex].iCharPos;
 7625:         if (ESTIMATE_MAX_GLYPHS(itemLength) > 65535) {
 7625:             // This items length would cause ScriptShape() to fail. We need to
 7625:             // add extra items here so that no item's length could cause the fail.
 7625: 
 7625:             // Get cluster boundaries, so we can break cleanly if possible.
 7625:             nsTArray<SCRIPT_LOGATTR> logAttr;
 7625:             if (!logAttr.SetLength(itemLength))
 7625:                 return NS_ERROR_FAILURE;
 7625:             HRESULT rv= ScriptBreak(mString+mItems[aIndex].iCharPos, itemLength,
 7625:                                     &mItems[aIndex].a, logAttr.Elements());
 7625:             if (FAILED(rv))
 7625:                 return NS_ERROR_FAILURE;
 7625: 
 7625:             const int nextItemStart = mItems[aIndex+1].iCharPos;
 7625:             int start = FindNextItemStart(mItems[aIndex].iCharPos,
 7625:                                           nextItemStart, logAttr, mString);
 7625: 
 7625:             while (start < nextItemStart) {
 7625:                 SCRIPT_ITEM item = mItems[aIndex];
 7625:                 item.iCharPos = start;
 7625:                 aDest.AppendElement(item);
 7625:                 start = FindNextItemStart(start, nextItemStart, logAttr, mString);
 7625:             }
 7625:         } 
 7625:         return NS_OK;
 7625:     }
 7625: 
 7625: public:
 7625: 
    1:     int Itemize() {
    1:         HRESULT rv;
    1: 
    1:         int maxItems = 5;
    1: 
    1:         Init();
 7625: 
  808:         // Allocate space for one more item than expected, to handle a rare
  808:         // overflow in ScriptItemize (pre XP SP2). See bug 366643.
 7625:         if (!mItems.SetLength(maxItems + 1)) {
 7625:             return 0;
 7625:         }
    1:         while ((rv = ScriptItemize(mString, mLength, maxItems, &mControl, &mState,
 7625:                                    mItems.Elements(), &mNumItems)) == E_OUTOFMEMORY) {
    1:             maxItems *= 2;
 7625:             if (!mItems.SetLength(maxItems + 1)) {
 7625:                 return 0;
 7625:             }
    1:             Init();
    1:         }
    1: 
 7625:         if (ESTIMATE_MAX_GLYPHS(mLength) > 65535) {
 7625:             // Any item of length > 43680 will cause ScriptShape() to fail, as its
 7625:             // mMaxGlyphs value will be greater than 65535 (43680*1.5+16>65535). So we
 7625:             // need to break up items which are longer than that upon cluster boundaries.
 7625:             // See bug 394751 for details.
 7625:             nsTArray<SCRIPT_ITEM> items;
 7625:             for (int i=0; i<mNumItems; i++) {
 7625:                 nsresult nrs = CopyItemSplitOversize(i, items);
 7625:                 NS_ASSERTION(NS_SUCCEEDED(nrs), "CopyItemSplitOversize() failed");
 7625:             }
 7625:             items.AppendElement(mItems[mNumItems]); // copy terminator.
 7625: 
 7625:             mItems = items;
 7625:             mNumItems = items.Length() - 1; // Don't count the terminator.
 7625:         }
    1:         return mNumItems;
    1:     }
    1: 
    1:     PRUint32 ItemsLength() {
    1:         return mNumItems;
    1:     }
    1: 
    1:     // XXX Why do we dynamically allocate this? We could just fill in an object
    1:     // on the stack.
    1:     UniscribeItem *GetItem(PRUint32 i, gfxWindowsFontGroup *aGroup) {
    1:         NS_ASSERTION(i < (PRUint32)mNumItems, "Trying to get out of bounds item");
    1: 
    1:         UniscribeItem *item = new UniscribeItem(mContext, mDC,
    1:                                                 mString + mItems[i].iCharPos,
    1:                                                 mItems[i+1].iCharPos - mItems[i].iCharPos,
    1:                                                 &mItems[i],
    1:                                                 aGroup);
    1: 
    1:         return item;
    1:     }
    1: 
    1: private:
    1:     nsRefPtr<gfxContext> mContext;
    1:     HDC mDC;
    1:     const PRUnichar *mString;
    1:     const PRUint32 mLength;
    1:     const PRBool mIsRTL;
    1: 
    1:     SCRIPT_CONTROL mControl;
    1:     SCRIPT_STATE   mState;
 7625:     nsTArray<SCRIPT_ITEM> mItems;
    1:     int mNumItems;
    1: };
    1: 
    1: void
    1: gfxWindowsFontGroup::InitTextRunUniscribe(gfxContext *aContext, gfxTextRun *aRun, const PRUnichar *aString,
    1:                                           PRUint32 aLength)
    1: {
 4363:     DCFromContext aDC(aContext);
    1:  
    1:     const PRBool isRTL = aRun->IsRightToLeft();
    1: 
    1:     HRESULT rv;
    1: 
    1:     Uniscribe us(aContext, aDC, aString, aLength, isRTL);
    1: 
    1:     /* itemize the string */
    1:     int numItems = us.Itemize();
    1: 
    1:     for (int i = 0; i < numItems; ++i) {
    1:         SaveDC(aDC);
    1: 
13517:         nsAutoPtr<UniscribeItem> item(us.GetItem(i, this));
    1: 
 2252:         PRUint32 nranges = item->ComputeRanges();
    1: 
 2252:         for (PRUint32 j = 0; j < nranges; ++j) {
    1: 
 2252:             item->SetRange(j);
    1: 
 2252:             if (!item->ShapingEnabled())
 2252:                 item->EnableShaping();
    1: 
 7625:             rv = item->Shape();
 7625:             if (FAILED(rv)) {
 2252:                 PR_LOG(gFontLog, PR_LOG_DEBUG, ("shaping failed"));
 1959:                 // we know we have the glyphs to display this font already
 1959:                 // so Uniscribe just doesn't know how to shape the script.
 1959:                 // Render the glyphs without shaping.
 1959:                 item->DisableShaping();
 7625:                 rv = item->Shape();
 1959:             }
  282: 
14918:             NS_ASSERTION(SUCCEEDED(rv), "Failed to shape, twice -- we should never hit this");
    1: 
14918:             if (SUCCEEDED(rv)) {
    1:                 rv = item->Place();
 2252:                 NS_ASSERTION(SUCCEEDED(rv), "Failed to place -- this is pretty bad.");
14918:             }
    1: 
13439:             if (FAILED(rv)) {
13439:                 aRun->ResetGlyphRuns();
13439: 
13439:                 /* Uniscribe doesn't like this font, use GDI instead */
13439:                 item->GetCurrentFont()->GetFontEntry()->mForceGDI = PR_TRUE;
13439:                 break;
13439:             }
13439: 
    1:             item->SaveGlyphs(aRun);
 2252:         }
 1959: 
13439:         RestoreDC(aDC, -1);
    1: 
13439:         if (FAILED(rv)) {
13439:             i = -1;
    1:         }
    1:     }
13439: }
