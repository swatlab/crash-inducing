  144: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
  144: /* ***** BEGIN LICENSE BLOCK *****
  144:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
  144:  *
  144:  * The contents of this file are subject to the Mozilla Public License Version
  144:  * 1.1 (the "License"); you may not use this file except in compliance with
  144:  * the License. You may obtain a copy of the License at
  144:  * http://www.mozilla.org/MPL/
  144:  *
  144:  * Software distributed under the License is distributed on an "AS IS" basis,
  144:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
  144:  * for the specific language governing rights and limitations under the
  144:  * License.
  144:  *
  144:  * The Original Code is mozilla.org code.
  144:  *
  144:  * The Initial Developer of the Original Code is
  144:  * Mozilla Foundation.
  144:  * Portions created by the Initial Developer are Copyright (C) 2007
  144:  * the Initial Developer. All Rights Reserved.
  144:  *
  144:  * Contributor(s):
  144:  *   Alexander Surkov <surkov.alexander@gmail.com> (original author)
  144:  *
  144:  * Alternatively, the contents of this file may be used under the terms of
  144:  * either of the GNU General Public License Version 2 or later (the "GPL"),
  144:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
  144:  * in which case the provisions of the GPL or the LGPL are applicable instead
  144:  * of those above. If you wish to allow use of your version of this file only
  144:  * under the terms of either the GPL or the LGPL, and not to allow others to
  144:  * use your version of this file under the terms of the MPL, indicate your
  144:  * decision by deleting the provisions above and replace them with the notice
  144:  * and other provisions required by the GPL or the LGPL. If you do not delete
  144:  * the provisions above, a recipient may use your version of this file under
  144:  * the terms of any one of the MPL, the GPL or the LGPL.
  144:  *
  144:  * ***** END LICENSE BLOCK ***** */
  144: 
20521: #include "nsCoreUtils.h"
 3152: 
 5245: #include "nsIAccessibleTypes.h"
 3152: 
20536: #include "nsAccessNode.h"
20536: 
 5679: #include "nsIDocument.h"
68870: #include "nsIDOMAbstractView.h"
 7830: #include "nsIDOM3Node.h"
 5679: #include "nsIDOMDocument.h"
68870: #include "nsIDOMDocumentView.h"
20138: #include "nsIDOMHTMLDocument.h"
20138: #include "nsIDOMHTMLElement.h"
 6279: #include "nsIDOMNodeList.h"
 5245: #include "nsIDOMRange.h"
68870: #include "nsIDOMViewCSS.h"
 5679: #include "nsIDOMWindowInternal.h"
28029: #include "nsIDOMXULElement.h"
20566: #include "nsIDocShell.h"
20566: #include "nsIContentViewer.h"
 1294: #include "nsIEventListenerManager.h"
 5414: #include "nsIPresShell.h"
 5414: #include "nsPresContext.h"
 6286: #include "nsIScrollableFrame.h"
68780: #include "nsEventStateManager.h"
 5245: #include "nsISelection2.h"
 5245: #include "nsISelectionController.h"
20566: #include "nsPIDOMWindow.h"
16427: #include "nsGUIEvent.h"
37062: #include "nsIView.h"
 5245: 
 5245: #include "nsContentCID.h"
 5245: #include "nsComponentManagerUtils.h"
 5679: #include "nsIInterfaceRequestorUtils.h"
 5245: 
 5245: static NS_DEFINE_IID(kRangeCID, NS_RANGE_CID);
  144: 
41384: ////////////////////////////////////////////////////////////////////////////////
41384: // nsCoreUtils
41384: ////////////////////////////////////////////////////////////////////////////////
41384: 
 3146: PRBool
37859: nsCoreUtils::HasClickListener(nsIContent *aContent)
 1294: {
11916:   NS_ENSURE_TRUE(aContent, PR_FALSE);
29474:   nsIEventListenerManager* listenerManager =
29474:     aContent->GetListenerManager(PR_FALSE);
 1294: 
37859:   return listenerManager &&
37859:     (listenerManager->HasListenersFor(NS_LITERAL_STRING("click")) ||
37859:      listenerManager->HasListenersFor(NS_LITERAL_STRING("mousedown")) ||
37859:      listenerManager->HasListenersFor(NS_LITERAL_STRING("mouseup")));
 1294: }
 1294: 
31673: void
31673: nsCoreUtils::DispatchClickEvent(nsITreeBoxObject *aTreeBoxObj,
31673:                                 PRInt32 aRowIndex, nsITreeColumn *aColumn,
31673:                                 const nsCString& aPseudoElt)
31673: {
31673:   nsCOMPtr<nsIDOMElement> tcElm;
31673:   aTreeBoxObj->GetTreeBody(getter_AddRefs(tcElm));
31673:   if (!tcElm)
31673:     return;
31673: 
31673:   nsCOMPtr<nsIContent> tcContent(do_QueryInterface(tcElm));
31673:   nsIDocument *document = tcContent->GetCurrentDoc();
31673:   if (!document)
31673:     return;
31673: 
31673:   nsIPresShell *presShell = nsnull;
46225:   presShell = document->GetShell();
31673:   if (!presShell)
31673:     return;
31673: 
31673:   // Ensure row is visible.
31673:   aTreeBoxObj->EnsureRowIsVisible(aRowIndex);
31673: 
31673:   // Calculate x and y coordinates.
31673:   PRInt32 x = 0, y = 0, width = 0, height = 0;
31673:   nsresult rv = aTreeBoxObj->GetCoordsForCellItem(aRowIndex, aColumn,
31673:                                                   aPseudoElt,
31673:                                                   &x, &y, &width, &height);
31673:   if (NS_FAILED(rv))
31673:     return;
31673: 
31673:   nsCOMPtr<nsIDOMXULElement> tcXULElm(do_QueryInterface(tcElm));
31673:   nsCOMPtr<nsIBoxObject> tcBoxObj;
31673:   tcXULElm->GetBoxObject(getter_AddRefs(tcBoxObj));
31673: 
31673:   PRInt32 tcX = 0;
31673:   tcBoxObj->GetX(&tcX);
31673: 
31673:   PRInt32 tcY = 0;
31673:   tcBoxObj->GetY(&tcY);
31673: 
31673:   // Dispatch mouse events.
36654:   nsIFrame* tcFrame = tcContent->GetPrimaryFrame();
31673:   nsIFrame* rootFrame = presShell->GetRootFrame();
31673: 
31673:   nsPoint offset;
31673:   nsIWidget *rootWidget =
31673:     rootFrame->GetViewExternal()->GetNearestWidget(&offset);
31673: 
31673:   nsPresContext* presContext = presShell->GetPresContext();
31673: 
31673:   PRInt32 cnvdX = presContext->CSSPixelsToDevPixels(tcX + x + 1) +
31673:     presContext->AppUnitsToDevPixels(offset.x);
31673:   PRInt32 cnvdY = presContext->CSSPixelsToDevPixels(tcY + y + 1) +
31673:     presContext->AppUnitsToDevPixels(offset.y);
31673: 
31673:   DispatchMouseEvent(NS_MOUSE_BUTTON_DOWN, cnvdX, cnvdY,
31673:                      tcContent, tcFrame, presShell, rootWidget);
31673: 
31673:   DispatchMouseEvent(NS_MOUSE_BUTTON_UP, cnvdX, cnvdY,
31673:                      tcContent, tcFrame, presShell, rootWidget);
31673: }
31673: 
16427: PRBool
20521: nsCoreUtils::DispatchMouseEvent(PRUint32 aEventType,
16427:                                 nsIPresShell *aPresShell,
16427:                                 nsIContent *aContent)
16427: {
36654:   nsIFrame *frame = aContent->GetPrimaryFrame();
16427:   if (!frame)
16427:     return PR_FALSE;
16427: 
47902:   // Compute x and y coordinates.
47902:   nsPoint point;
47902:   nsCOMPtr<nsIWidget> widget = frame->GetNearestWidget(point);
47902:   if (!widget)
16427:     return PR_FALSE;
16427: 
16427:   nsSize size = frame->GetSize();
16427: 
16427:   nsPresContext* presContext = aPresShell->GetPresContext();
16427: 
16427:   PRInt32 x = presContext->AppUnitsToDevPixels(point.x + size.width / 2);
16427:   PRInt32 y = presContext->AppUnitsToDevPixels(point.y + size.height / 2);
16427: 
16427:   // Fire mouse event.
47902:   DispatchMouseEvent(aEventType, x, y, aContent, frame, aPresShell, widget);
31673:   return PR_TRUE;
31673: }
31673: 
31673: void
31673: nsCoreUtils::DispatchMouseEvent(PRUint32 aEventType, PRInt32 aX, PRInt32 aY,
31673:                                 nsIContent *aContent, nsIFrame *aFrame,
31673:                                 nsIPresShell *aPresShell, nsIWidget *aRootWidget)
31673: {
31673:   nsMouseEvent event(PR_TRUE, aEventType, aRootWidget,
16427:                      nsMouseEvent::eReal, nsMouseEvent::eNormal);
16427: 
31673:   event.refPoint = nsIntPoint(aX, aY);
16427: 
16427:   event.clickCount = 1;
16427:   event.button = nsMouseEvent::eLeftButton;
16427:   event.time = PR_IntervalNow();
16427: 
16427:   nsEventStatus status = nsEventStatus_eIgnore;
31673:   aPresShell->HandleEventWithTarget(&event, aFrame, aContent, &status);
16427: }
16427: 
 5414: PRUint32
20521: nsCoreUtils::GetAccessKeyFor(nsIContent *aContent)
 5414: {
 5414:   if (!aContent)
 5414:     return 0;
 5414: 
 5414:   // Accesskeys are registered by @accesskey attribute only. At first check
 5414:   // whether it is presented on the given element to avoid the slow
68780:   // nsEventStateManager::GetRegisteredAccessKey() method.
 5414:   if (!aContent->HasAttr(kNameSpaceID_None, nsAccessibilityAtoms::accesskey))
 5414:     return 0;
 5414: 
 5414:   nsCOMPtr<nsIDocument> doc = aContent->GetOwnerDoc();
 5414:   if (!doc)
 5414:     return 0;
 5414: 
46225:   nsCOMPtr<nsIPresShell> presShell = doc->GetShell();
 5414:   if (!presShell)
 5414:     return 0;
 5414: 
 5414:   nsPresContext *presContext = presShell->GetPresContext();
 5414:   if (!presContext)
 5414:     return 0;
 5414: 
68780:   nsEventStateManager *esm = presContext->EventStateManager();
 5414:   if (!esm)
 5414:     return 0;
 5414: 
68780:   return esm->GetRegisteredAccessKey(aContent);
 5414: }
 5414: 
43504: nsIContent *
43504: nsCoreUtils::GetDOMElementFor(nsIContent *aContent)
16001: {
43504:   if (aContent->IsElement())
43504:     return aContent;
19825: 
43504:   if (aContent->IsNodeOfType(nsINode::eTEXT))
43504:     return aContent->GetParent();
20138: 
43504:   return nsnull;
16001: }
16001: 
42796: nsINode *
42796: nsCoreUtils::GetDOMNodeFromDOMPoint(nsINode *aNode, PRUint32 aOffset)
22834: {
42796:   if (aNode && aNode->IsElement()) {
42796:     PRUint32 childCount = aNode->GetChildCount();
22834:     NS_ASSERTION(aOffset >= 0 && aOffset <= childCount,
22834:                  "Wrong offset of the DOM point!");
22834: 
22834:     // The offset can be after last child of container node that means DOM point
22834:     // is placed immediately after the last child. In this case use the DOM node
22834:     // from the given DOM point is used as result node.
42796:     if (aOffset != childCount)
42796:       return aNode->GetChildAt(aOffset);
22834:   }
22834: 
42796:   return aNode;
22834: }
22834: 
20566: nsIContent*
43504: nsCoreUtils::GetRoleContent(nsINode *aNode)
20566: {
43504:   nsCOMPtr<nsIContent> content(do_QueryInterface(aNode));
20566:   if (!content) {
43504:     nsCOMPtr<nsIDOMDocument> domDoc(do_QueryInterface(aNode));
20566:     if (domDoc) {
43504:       nsCOMPtr<nsIDOMHTMLDocument> htmlDoc(do_QueryInterface(aNode));
20566:       if (htmlDoc) {
20566:         nsCOMPtr<nsIDOMHTMLElement> bodyElement;
20566:         htmlDoc->GetBody(getter_AddRefs(bodyElement));
20566:         content = do_QueryInterface(bodyElement);
20566:       }
20566:       else {
20566:         nsCOMPtr<nsIDOMElement> docElement;
20566:         domDoc->GetDocumentElement(getter_AddRefs(docElement));
20566:         content = do_QueryInterface(docElement);
20566:       }
20566:     }
20566:   }
20566: 
20566:   return content;
20566: }
20566: 
 4637: PRBool
37539: nsCoreUtils::IsAncestorOf(nsINode *aPossibleAncestorNode,
43441:                           nsINode *aPossibleDescendantNode,
43441:                           nsINode *aRootNode)
 4637: {
13167:   NS_ENSURE_TRUE(aPossibleAncestorNode && aPossibleDescendantNode, PR_FALSE);
 4637: 
37539:   nsINode *parentNode = aPossibleDescendantNode;
43503:   while ((parentNode = parentNode->GetNodeParent()) &&
43503:          parentNode != aRootNode) {
37539:     if (parentNode == aPossibleAncestorNode)
 4637:       return PR_TRUE;
 4637:   }
37539: 
 4637:   return PR_FALSE;
 4637: }
 4637: 
 5245: nsresult
20521: nsCoreUtils::ScrollSubstringTo(nsIFrame *aFrame,
 5245:                                nsIDOMNode *aStartNode, PRInt32 aStartIndex,
 5245:                                nsIDOMNode *aEndNode, PRInt32 aEndIndex,
 5245:                                PRUint32 aScrollType)
 5245: {
 6286:   PRInt16 vPercent, hPercent;
 6286:   ConvertScrollTypeToPercents(aScrollType, &vPercent, &hPercent);
 6286: 
 6286:   return ScrollSubstringTo(aFrame, aStartNode, aStartIndex, aEndNode, aEndIndex,
 6286:                            vPercent, hPercent);
 6286: }
 6286: 
 6286: nsresult
20521: nsCoreUtils::ScrollSubstringTo(nsIFrame *aFrame,
 6286:                                nsIDOMNode *aStartNode, PRInt32 aStartIndex,
 6286:                                nsIDOMNode *aEndNode, PRInt32 aEndIndex,
 6286:                                PRInt16 aVPercent, PRInt16 aHPercent)
 6286: {
 5245:   if (!aFrame || !aStartNode || !aEndNode)
 5245:     return NS_ERROR_FAILURE;
 5245: 
 5245:   nsPresContext *presContext = aFrame->PresContext();
 5245: 
 5245:   nsCOMPtr<nsIDOMRange> scrollToRange = do_CreateInstance(kRangeCID);
 5245:   NS_ENSURE_TRUE(scrollToRange, NS_ERROR_FAILURE);
 5245: 
 5245:   nsCOMPtr<nsISelectionController> selCon;
 5245:   aFrame->GetSelectionController(presContext, getter_AddRefs(selCon));
 5245:   NS_ENSURE_TRUE(selCon, NS_ERROR_FAILURE);
 5245: 
 5245:   scrollToRange->SetStart(aStartNode, aStartIndex);
 5245:   scrollToRange->SetEnd(aEndNode, aEndIndex);
 5245: 
 5245:   nsCOMPtr<nsISelection> selection1;
 5245:   selCon->GetSelection(nsISelectionController::SELECTION_ACCESSIBILITY,
 5245:                        getter_AddRefs(selection1));
 5245: 
 5245:   nsCOMPtr<nsISelection2> selection(do_QueryInterface(selection1));
 5245:   if (selection) {
 5245:     selection->RemoveAllRanges();
 5245:     selection->AddRange(scrollToRange);
 5245: 
 5245:     selection->ScrollIntoView(nsISelectionController::SELECTION_ANCHOR_REGION,
 6286:                               PR_TRUE, aVPercent, aHPercent);
 5245: 
 5245:     selection->CollapseToStart();
 5245:   }
 5245: 
 5245:   return NS_OK;
 5245: }
 5245: 
 5245: void
20521: nsCoreUtils::ScrollFrameToPoint(nsIFrame *aScrollableFrame,
 6286:                                 nsIFrame *aFrame,
 6286:                                 const nsIntPoint& aPoint)
 6286: {
23554:   nsIScrollableFrame *scrollableFrame = do_QueryFrame(aScrollableFrame);
 6286:   if (!scrollableFrame)
 6286:     return;
 6286: 
 6286:   nsPresContext *presContext = aFrame->PresContext();
 6286: 
 6286:   nsIntRect frameRect = aFrame->GetScreenRectExternal();
 6286:   PRInt32 devDeltaX = aPoint.x - frameRect.x;
 6286:   PRInt32 devDeltaY = aPoint.y - frameRect.y;
 6286: 
 6286:   nsPoint deltaPoint;
 6286:   deltaPoint.x = presContext->DevPixelsToAppUnits(devDeltaX);
 6286:   deltaPoint.y = presContext->DevPixelsToAppUnits(devDeltaY);
 6286: 
 6286:   nsPoint scrollPoint = scrollableFrame->GetScrollPosition();
 6286:   scrollPoint -= deltaPoint;
 6286: 
37055:   scrollableFrame->ScrollTo(scrollPoint, nsIScrollableFrame::INSTANT);
 6286: }
 6286: 
 6286: void
20521: nsCoreUtils::ConvertScrollTypeToPercents(PRUint32 aScrollType,
 5245:                                          PRInt16 *aVPercent,
 5245:                                          PRInt16 *aHPercent)
 5245: {
 5245:   switch (aScrollType)
 5245:   {
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_TOP_LEFT:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_TOP;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_LEFT;
 5245:       break;
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_RIGHT:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_BOTTOM;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_RIGHT;
 5245:       break;
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_TOP_EDGE:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_TOP;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:       break;
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_BOTTOM_EDGE:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_BOTTOM;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:       break;
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_LEFT_EDGE:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_LEFT;
 5245:       break;
 5245:     case nsIAccessibleScrollType::SCROLL_TYPE_RIGHT_EDGE:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_RIGHT;
 5245:       break;
 5245:     default:
 5245:       *aVPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:       *aHPercent = NS_PRESSHELL_SCROLL_ANYWHERE;
 5245:   }
 5245: }
 5245: 
 5679: nsIntPoint
43504: nsCoreUtils::GetScreenCoordsForWindow(nsINode *aNode)
 5679: {
 5679:   nsIntPoint coords(0, 0);
 5679:   nsCOMPtr<nsIDocShellTreeItem> treeItem(GetDocShellTreeItemFor(aNode));
 5679:   if (!treeItem)
 5679:     return coords;
 5679: 
 5679:   nsCOMPtr<nsIDocShellTreeItem> rootTreeItem;
 5679:   treeItem->GetRootTreeItem(getter_AddRefs(rootTreeItem));
 5679:   nsCOMPtr<nsIDOMDocument> domDoc = do_GetInterface(rootTreeItem);
68870:   nsCOMPtr<nsIDOMDocumentView> docView(do_QueryInterface(domDoc));
68870:   if (!docView)
 5679:     return coords;
 5679: 
68870:   nsCOMPtr<nsIDOMAbstractView> abstractView;
68870:   docView->GetDefaultView(getter_AddRefs(abstractView));
68870:   nsCOMPtr<nsIDOMWindowInternal> windowInter(do_QueryInterface(abstractView));
 5679:   if (!windowInter)
 5679:     return coords;
 5679: 
 5679:   windowInter->GetScreenX(&coords.x);
 5679:   windowInter->GetScreenY(&coords.y);
 5679:   return coords;
 5679: }
 5679: 
 5679: already_AddRefed<nsIDocShellTreeItem>
43504: nsCoreUtils::GetDocShellTreeItemFor(nsINode *aNode)
 5679: {
 5679:   if (!aNode)
 5679:     return nsnull;
 5679: 
43504:   nsIDocument *doc = aNode->GetOwnerDoc();
 5679:   NS_ASSERTION(doc, "No document for node passed in");
 5679:   NS_ENSURE_TRUE(doc, nsnull);
 5679: 
 5679:   nsCOMPtr<nsISupports> container = doc->GetContainer();
 5679:   nsIDocShellTreeItem *docShellTreeItem = nsnull;
 5679:   if (container)
 5679:     CallQueryInterface(container, &docShellTreeItem);
 5679: 
 5679:   return docShellTreeItem;
 5679: }
 5679: 
43310: PRBool
43310: nsCoreUtils::IsRootDocument(nsIDocument *aDocument)
43310: {
43310:   nsCOMPtr<nsISupports> container = aDocument->GetContainer();
43310:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
43310:     do_QueryInterface(container);
43310:   NS_ASSERTION(docShellTreeItem, "No document shell for document!");
43310: 
43310:   nsCOMPtr<nsIDocShellTreeItem> parentTreeItem;
43310:   docShellTreeItem->GetParent(getter_AddRefs(parentTreeItem));
43310: 
43310:   return !parentTreeItem;
43310: }
43310: 
43310: PRBool
43310: nsCoreUtils::IsContentDocument(nsIDocument *aDocument)
43310: {
43310:   nsCOMPtr<nsISupports> container = aDocument->GetContainer();
43310:   nsCOMPtr<nsIDocShellTreeItem> docShellTreeItem =
43310:     do_QueryInterface(container);
43310:   NS_ASSERTION(docShellTreeItem, "No document shell tree item for document!");
43310: 
43310:   PRInt32 contentType;
43310:   docShellTreeItem->GetItemType(&contentType);
43310:   return (contentType == nsIDocShellTreeItem::typeContent);
43310: }
43310: 
43310: PRBool
43310: nsCoreUtils::IsErrorPage(nsIDocument *aDocument)
43310: {
43310:   nsIURI *uri = aDocument->GetDocumentURI();
43310:   PRBool isAboutScheme = PR_FALSE;
43310:   uri->SchemeIs("about", &isAboutScheme);
43310:   if (!isAboutScheme)
43310:     return PR_FALSE;
43310: 
43310:   nsCAutoString path;
43310:   uri->GetPath(path);
43310: 
43310:   nsCAutoString::const_iterator start, end;
43310:   path.BeginReading(start);
43310:   path.EndReading(end);
43310: 
43310:   NS_NAMED_LITERAL_CSTRING(neterror, "neterror");
43310:   return FindInReadable(neterror, start, end);
43310: }
43310: 
 6065: PRBool
20566: nsCoreUtils::IsCorrectFrameType(nsIFrame *aFrame, nsIAtom *aAtom)
20566: {
20566:   NS_ASSERTION(aFrame != nsnull,
20566:                "aFrame is null in call to IsCorrectFrameType!");
20566:   NS_ASSERTION(aAtom != nsnull,
20566:                "aAtom is null in call to IsCorrectFrameType!");
20566:   
20566:   return aFrame->GetType() == aAtom;
20566: }
20566: 
20566: already_AddRefed<nsIDOMNode>
20566: nsCoreUtils::GetDOMNodeForContainer(nsIDocShellTreeItem *aContainer)
20566: {
20566:   nsCOMPtr<nsIDocShell> shell = do_QueryInterface(aContainer);
20566: 
20566:   nsCOMPtr<nsIContentViewer> cv;
20566:   shell->GetContentViewer(getter_AddRefs(cv));
20566: 
20566:   if (!cv)
20566:     return nsnull;
20566: 
37433:   nsIDocument* doc = cv->GetDocument();
20566:   if (!doc)
20566:     return nsnull;
20566: 
20566:   nsIDOMNode* node = nsnull;
37433:   CallQueryInterface(doc, &node);
20566:   return node;
20566: }
20566: 
20566: PRBool
20521: nsCoreUtils::GetID(nsIContent *aContent, nsAString& aID)
 6065: {
 6065:   nsIAtom *idAttribute = aContent->GetIDAttributeName();
 6065:   return idAttribute ? aContent->GetAttr(kNameSpaceID_None, idAttribute, aID) : PR_FALSE;
 6065: }
 6279: 
13757: PRBool
37109: nsCoreUtils::GetUIntAttr(nsIContent *aContent, nsIAtom *aAttr, PRInt32 *aUInt)
37109: {
37109:   nsAutoString value;
37109:   aContent->GetAttr(kNameSpaceID_None, aAttr, value);
37109:   if (!value.IsEmpty()) {
37109:     PRInt32 error = NS_OK;
37109:     PRInt32 integer = value.ToInteger(&error);
37109:     if (NS_SUCCEEDED(error) && integer > 0) {
37109:       *aUInt = integer;
37109:       return PR_TRUE;
37109:     }
37109:   }
37109: 
37109:   return PR_FALSE;
37109: }
37109: 
37109: PRBool
20521: nsCoreUtils::IsXLink(nsIContent *aContent)
13757: {
13775:   if (!aContent)
13775:     return PR_FALSE;
13775: 
13757:   return aContent->AttrValueIs(kNameSpaceID_XLink, nsAccessibilityAtoms::type,
13757:                                nsAccessibilityAtoms::simple, eCaseMatters) &&
13757:          aContent->HasAttr(kNameSpaceID_XLink, nsAccessibilityAtoms::href);
13757: }
13757: 
16001: void
20521: nsCoreUtils::GetLanguageFor(nsIContent *aContent, nsIContent *aRootContent,
16001:                             nsAString& aLanguage)
16001: {
16001:   aLanguage.Truncate();
16001: 
16001:   nsIContent *walkUp = aContent;
16001:   while (walkUp && walkUp != aRootContent &&
16001:          !walkUp->GetAttr(kNameSpaceID_None,
16001:                           nsAccessibilityAtoms::lang, aLanguage))
16001:     walkUp = walkUp->GetParent();
16001: }
20566: 
43504: already_AddRefed<nsIDOMCSSStyleDeclaration>
20566: nsCoreUtils::GetComputedStyleDeclaration(const nsAString& aPseudoElt,
43504:                                          nsIContent *aContent)
20566: {
43504:   nsIContent* content = GetDOMElementFor(aContent);
43504:   if (!content)
43504:     return nsnull;
20566: 
20566:   // Returns number of items in style declaration
43504:   nsIDocument* document = content->GetOwnerDoc();
43504:   if (!document)
43504:     return nsnull;
20566: 
68870:   nsCOMPtr<nsIDOMViewCSS> viewCSS(do_QueryInterface(document->GetWindow()));
68870:   if (!viewCSS)
43504:     return nsnull;
20566: 
68870:   nsIDOMCSSStyleDeclaration* cssDecl = nsnull;
43504:   nsCOMPtr<nsIDOMElement> domElement(do_QueryInterface(content));
68870:   viewCSS->GetComputedStyle(domElement, aPseudoElt, &cssDecl);
68870:   return cssDecl;
20566: }
28029: 
28029: already_AddRefed<nsIBoxObject>
28029: nsCoreUtils::GetTreeBodyBoxObject(nsITreeBoxObject *aTreeBoxObj)
28029: {
28029:   nsCOMPtr<nsIDOMElement> tcElm;
28029:   aTreeBoxObj->GetTreeBody(getter_AddRefs(tcElm));
28029:   nsCOMPtr<nsIDOMXULElement> tcXULElm(do_QueryInterface(tcElm));
28029:   if (!tcXULElm)
28029:     return nsnull;
28029: 
28029:   nsIBoxObject *boxObj = nsnull;
28029:   tcXULElm->GetBoxObject(&boxObj);
28029:   return boxObj;
28029: }
31673: 
43504: already_AddRefed<nsITreeBoxObject>
43504: nsCoreUtils::GetTreeBoxObject(nsIContent *aContent)
31673: {
31673:   // Find DOMNode's parents recursively until reach the <tree> tag
43504:   nsIContent* currentContent = aContent;
43504:   while (currentContent) {
43504:     if (currentContent->NodeInfo()->Equals(nsAccessibilityAtoms::tree,
43504:                                            kNameSpaceID_XUL)) {
31673:       // We will get the nsITreeBoxObject from the tree node
43504:       nsCOMPtr<nsIDOMXULElement> xulElement(do_QueryInterface(currentContent));
31673:       if (xulElement) {
31673:         nsCOMPtr<nsIBoxObject> box;
31673:         xulElement->GetBoxObject(getter_AddRefs(box));
31673:         nsCOMPtr<nsITreeBoxObject> treeBox(do_QueryInterface(box));
43504:         if (treeBox)
43504:           return treeBox.forget();
31673:       }
31673:     }
43504:     currentContent = currentContent->GetParent();
31673:   }
31673: 
43504:   return nsnull;
31673: }
31673: 
31673: already_AddRefed<nsITreeColumn>
31673: nsCoreUtils::GetFirstSensibleColumn(nsITreeBoxObject *aTree)
31673: {
31673:   nsCOMPtr<nsITreeColumns> cols;
31673:   aTree->GetColumns(getter_AddRefs(cols));
31673:   if (!cols)
31673:     return nsnull;
31673: 
31673:   nsCOMPtr<nsITreeColumn> column;
31673:   cols->GetFirstColumn(getter_AddRefs(column));
31673:   if (column && IsColumnHidden(column))
31673:     return GetNextSensibleColumn(column);
31673: 
31673:   return column.forget();
31673: }
31673: 
31673: already_AddRefed<nsITreeColumn>
31673: nsCoreUtils::GetLastSensibleColumn(nsITreeBoxObject *aTree)
31673: {
31673:   nsCOMPtr<nsITreeColumns> cols;
31673:   aTree->GetColumns(getter_AddRefs(cols));
31673:   if (!cols)
31673:     return nsnull;
31673: 
31673:   nsCOMPtr<nsITreeColumn> column;
31673:   cols->GetLastColumn(getter_AddRefs(column));
31673:   if (column && IsColumnHidden(column))
31673:     return GetPreviousSensibleColumn(column);
31673: 
31673:   return column.forget();
31673: }
31673: 
31673: PRUint32
35523: nsCoreUtils::GetSensibleColumnCount(nsITreeBoxObject *aTree)
31673: {
31673:   PRUint32 count = 0;
31673: 
31673:   nsCOMPtr<nsITreeColumns> cols;
31673:   aTree->GetColumns(getter_AddRefs(cols));
31673:   if (!cols)
31673:     return count;
31673: 
31673:   nsCOMPtr<nsITreeColumn> column;
31673:   cols->GetFirstColumn(getter_AddRefs(column));
31673: 
31673:   while (column) {
31673:     if (!IsColumnHidden(column))
31673:       count++;
31673: 
31673:     nsCOMPtr<nsITreeColumn> nextColumn;
31673:     column->GetNext(getter_AddRefs(nextColumn));
31673:     column.swap(nextColumn);
31673:   }
31673: 
31673:   return count;
31673: }
31673: 
31673: already_AddRefed<nsITreeColumn>
31673: nsCoreUtils::GetSensibleColumnAt(nsITreeBoxObject *aTree, PRUint32 aIndex)
31673: {
31673:   PRUint32 idx = aIndex;
31673: 
31673:   nsCOMPtr<nsITreeColumn> column = GetFirstSensibleColumn(aTree);
31673:   while (column) {
31673:     if (idx == 0)
31673:       return column.forget();
31673: 
31673:     idx--;
31673:     column = GetNextSensibleColumn(column);
31673:   }
31673: 
31673:   return nsnull;
31673: }
31673: 
31673: already_AddRefed<nsITreeColumn>
31673: nsCoreUtils::GetNextSensibleColumn(nsITreeColumn *aColumn)
31673: {
31673:   nsCOMPtr<nsITreeColumn> nextColumn;
31673:   aColumn->GetNext(getter_AddRefs(nextColumn));
31673: 
31673:   while (nextColumn && IsColumnHidden(nextColumn)) {
31673:     nsCOMPtr<nsITreeColumn> tempColumn;
31673:     nextColumn->GetNext(getter_AddRefs(tempColumn));
31673:     nextColumn.swap(tempColumn);
31673:   }
31673: 
31673:   return nextColumn.forget();
31673: }
31673: 
31673: already_AddRefed<nsITreeColumn>
31673: nsCoreUtils::GetPreviousSensibleColumn(nsITreeColumn *aColumn)
31673: {
31673:   nsCOMPtr<nsITreeColumn> prevColumn;
31673:   aColumn->GetPrevious(getter_AddRefs(prevColumn));
31673: 
31673:   while (prevColumn && IsColumnHidden(prevColumn)) {
31673:     nsCOMPtr<nsITreeColumn> tempColumn;
31673:     prevColumn->GetPrevious(getter_AddRefs(tempColumn));
31673:     prevColumn.swap(tempColumn);
31673:   }
31673: 
31673:   return prevColumn.forget();
31673: }
31673: 
31673: PRBool
31673: nsCoreUtils::IsColumnHidden(nsITreeColumn *aColumn)
31673: {
31673:   nsCOMPtr<nsIDOMElement> element;
31673:   aColumn->GetElement(getter_AddRefs(element));
31673:   nsCOMPtr<nsIContent> content = do_QueryInterface(element);
31673:   return content->AttrValueIs(kNameSpaceID_None, nsAccessibilityAtoms::hidden,
31673:                               nsAccessibilityAtoms::_true, eCaseMatters);
31673: }
34719: 
41384: 
41384: ////////////////////////////////////////////////////////////////////////////////
41384: // nsAccessibleDOMStringList
41384: ////////////////////////////////////////////////////////////////////////////////
41384: 
41384: NS_IMPL_ISUPPORTS1(nsAccessibleDOMStringList, nsIDOMDOMStringList)
41384: 
41384: NS_IMETHODIMP
41384: nsAccessibleDOMStringList::Item(PRUint32 aIndex, nsAString& aResult)
41384: {
41384:   if (aIndex >= mNames.Length())
41384:     SetDOMStringToNull(aResult);
41384:   else
41384:     aResult = mNames.ElementAt(aIndex);
41384: 
41384:   return NS_OK;
41384: }
41384: 
41384: NS_IMETHODIMP
41384: nsAccessibleDOMStringList::GetLength(PRUint32 *aLength)
41384: {
41384:   *aLength = mNames.Length();
41384: 
41384:   return NS_OK;
41384: }
41384: 
41384: NS_IMETHODIMP
41384: nsAccessibleDOMStringList::Contains(const nsAString& aString, PRBool *aResult)
41384: {
41384:   *aResult = mNames.Contains(aString);
41384: 
41384:   return NS_OK;
41384: }
57626: 
57626: 
57626: ////////////////////////////////////////////////////////////////////////////////
57626: // IDRefsIterator
57626: ////////////////////////////////////////////////////////////////////////////////
57626: 
57626: IDRefsIterator::IDRefsIterator(nsIContent* aContent, nsIAtom* aIDRefsAttr) :
57626:   mCurrIdx(0)
57626: {
57626:   if (!aContent->IsInDoc() ||
57626:       !aContent->GetAttr(kNameSpaceID_None, aIDRefsAttr, mIDs))
57626:     return;
57626: 
57626:   if (aContent->IsInAnonymousSubtree()) {
57626:     mXBLDocument = do_QueryInterface(aContent->GetOwnerDoc());
57626:     mBindingParent = do_QueryInterface(aContent->GetBindingParent());
57626:   } else {
57626:     mDocument = aContent->GetOwnerDoc();
57626:   }
57626: }
57626: 
57626: const nsDependentSubstring
57626: IDRefsIterator::NextID()
57626: {
57626:   for (; mCurrIdx < mIDs.Length(); mCurrIdx++) {
57626:     if (!NS_IsAsciiWhitespace(mIDs[mCurrIdx]))
57626:       break;
57626:   }
57626: 
57626:   if (mCurrIdx >= mIDs.Length())
57626:     return nsDependentSubstring();
57626: 
57626:   nsAString::index_type idStartIdx = mCurrIdx;
57626:   while (++mCurrIdx < mIDs.Length()) {
57626:     if (NS_IsAsciiWhitespace(mIDs[mCurrIdx]))
57626:       break;
57626:   }
57626: 
57626:   return Substring(mIDs, idStartIdx, mCurrIdx++ - idStartIdx);
57626: }
57626: 
57626: nsIContent*
57626: IDRefsIterator::NextElem()
57626: {
57626:   while (true) {
57626:     const nsDependentSubstring id = NextID();
57626:     if (id.IsEmpty())
57626:       break;
57626: 
57890:     nsIContent* refContent = GetElem(id);
57890:     if (refContent)
57890:       return refContent;
57890:   }
57890: 
57890:   return nsnull;
57890: }
57890: 
57890: nsIContent*
57890: IDRefsIterator::GetElem(const nsDependentSubstring& aID)
57890: {
57626:   if (mXBLDocument) {
57626:     // If content is anonymous subtree then use "anonid" attribute to get
57626:     // elements, otherwise search elements in DOM by ID attribute.
57626: 
57626:     nsCOMPtr<nsIDOMElement> refElm;
57626:     mXBLDocument->GetAnonymousElementByAttribute(mBindingParent,
57626:                                                  NS_LITERAL_STRING("anonid"),
57890:                                                  aID,
57626:                                                  getter_AddRefs(refElm));
57626:     nsCOMPtr<nsIContent> refContent = do_QueryInterface(refElm);
57626:     return refContent;
57626:   }
57890: 
57890:   return mDocument->GetElementById(aID);
57626: }
