35740: /* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
35740:  * vim: sw=4 ts=4 et :
35740:  * ***** BEGIN LICENSE BLOCK *****
35740:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
35740:  *
35740:  * The contents of this file are subject to the Mozilla Public License Version
35740:  * 1.1 (the "License"); you may not use this file except in compliance with
35740:  * the License. You may obtain a copy of the License at
35740:  * http://www.mozilla.org/MPL/
35740:  *
35740:  * Software distributed under the License is distributed on an "AS IS" basis,
35740:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
35740:  * for the specific language governing rights and limitations under the
35740:  * License.
35740:  *
35740:  * The Original Code is Mozilla Plugin App.
35740:  *
35740:  * The Initial Developer of the Original Code is
35740:  *   Chris Jones <jones.chris.g@gmail.com>
35740:  * Portions created by the Initial Developer are Copyright (C) 2009
35740:  * the Initial Developer. All Rights Reserved.
35740:  *
35740:  * Contributor(s):
35740:  *
35740:  * Alternatively, the contents of this file may be used under the terms of
35740:  * either the GNU General Public License Version 2 or later (the "GPL"), or
35740:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
35740:  * in which case the provisions of the GPL or the LGPL are applicable instead
35740:  * of those above. If you wish to allow use of your version of this file only
35740:  * under the terms of either the GPL or the LGPL, and not to allow others to
35740:  * use your version of this file under the terms of the MPL, indicate your
35740:  * decision by deleting the provisions above and replace them with the notice
35740:  * and other provisions required by the GPL or the LGPL. If you do not delete
35740:  * the provisions above, a recipient may use your version of this file under
35740:  * the terms of any one of the MPL, the GPL or the LGPL.
35740:  *
35740:  * ***** END LICENSE BLOCK ***** */
35740: 
39263: #ifdef MOZ_WIDGET_GTK2
39263: #include <glib.h>
48383: #elif XP_MACOSX
71284: #include "PluginInterposeOSX.h"
48383: #include "PluginUtilsOSX.h"
39263: #endif
43456: #ifdef MOZ_WIDGET_QT
43456: #include <QtCore/QCoreApplication>
43456: #include <QtCore/QEventLoop>
43456: #endif
39263: 
38121: #include "base/process_util.h"
38121: 
70842: #include "mozilla/Preferences.h"
41382: #include "mozilla/unused.h"
38121: #include "mozilla/ipc/SyncChannel.h"
35893: #include "mozilla/plugins/PluginModuleParent.h"
35895: #include "mozilla/plugins/BrowserStreamParent.h"
79569: #include "mozilla/dom/PCrashReporterParent.h"
39742: #include "PluginIdentifierParent.h"
35746: 
49311: #include "nsAutoPtr.h"
37384: #include "nsCRT.h"
39793: #ifdef MOZ_CRASHREPORTER
79569: #include "mozilla/dom/CrashReporterParent.h"
39793: #endif
35913: #include "nsNPAPIPlugin.h"
70185: #include "nsILocalFile.h"
35913: 
72466: #ifdef XP_WIN
72466: #include "mozilla/widget/AudioSession.h"
72466: #endif
88104: #include "sampler.h"
72466: 
38121: using base::KillProcess;
38121: 
36010: using mozilla::PluginLibrary;
38121: using mozilla::ipc::SyncChannel;
79569: using mozilla::dom::PCrashReporterParent;
79569: using mozilla::dom::CrashReporterParent;
35913: 
70842: using namespace mozilla;
35913: using namespace mozilla::plugins;
72341: using namespace mozilla::plugins::parent;
35913: 
76704: static const char kChildTimeoutPref[] = "dom.ipc.plugins.timeoutSecs";
76704: static const char kParentTimeoutPref[] = "dom.ipc.plugins.parentTimeoutSecs";
49311: static const char kLaunchTimeoutPref[] = "dom.ipc.plugins.processLaunchTimeoutSecs";
38121: 
38121: template<>
38121: struct RunnableMethodTraits<mozilla::plugins::PluginModuleParent>
38121: {
38121:     typedef mozilla::plugins::PluginModuleParent Class;
38121:     static void RetainCallee(Class* obj) { }
38121:     static void ReleaseCallee(Class* obj) { }
38121: };
38121: 
36063: // static
36010: PluginLibrary*
64609: PluginModuleParent::LoadModule(const char* aFilePath)
35740: {
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35740: 
70842:     PRInt32 prefSecs = Preferences::GetInt(kLaunchTimeoutPref, 0);
49311: 
35740:     // Block on the child process being launched and initialized.
49311:     nsAutoPtr<PluginModuleParent> parent(new PluginModuleParent(aFilePath));
49311:     bool launched = parent->mSubprocess->Launch(prefSecs * 1000);
49311:     if (!launched) {
49311:         // Need to set this so the destructor doesn't complain.
49311:         parent->mShutdown = true;
49311:         return nsnull;
49311:     }
36063:     parent->Open(parent->mSubprocess->GetChannel(),
36063:                  parent->mSubprocess->GetChildProcessHandle());
35740: 
76704:     TimeoutChanged(kChildTimeoutPref, parent);
79569: 
79569: #ifdef MOZ_CRASHREPORTER
80609:     // If this fails, we're having IPC troubles, and we're doomed anyways.
80609:     if (!CrashReporterParent::CreateCrashReporter(parent.get())) {
80609:         parent->mShutdown = true;
80609:         return nsnull;
80609:     }
79569: #endif
79569: 
49311:     return parent.forget();
35740: }
35740: 
35740: 
64609: PluginModuleParent::PluginModuleParent(const char* aFilePath)
64609:     : mSubprocess(new PluginProcessParent(aFilePath))
36145:     , mShutdown(false)
62174:     , mClearSiteDataSupported(false)
62174:     , mGetSitesWithDataSupported(false)
36145:     , mNPNIface(NULL)
36304:     , mPlugin(NULL)
39793:     , mTaskFactory(this)
35740: {
36063:     NS_ASSERTION(mSubprocess, "Out of memory!");
36063: 
39742:     if (!mIdentifiers.Init()) {
36145:         NS_ERROR("Out of memory");
36145:     }
38121: 
76704:     Preferences::RegisterCallback(TimeoutChanged, kChildTimeoutPref, this);
76704:     Preferences::RegisterCallback(TimeoutChanged, kParentTimeoutPref, this);
35740: }
35740: 
35893: PluginModuleParent::~PluginModuleParent()
35740: {
39312:     NS_ASSERTION(OkToCleanup(), "unsafe destruction");
39312: 
36145:     if (!mShutdown) {
36145:         NS_WARNING("Plugin host deleted the module without shutting down.");
36145:         NPError err;
36145:         NP_Shutdown(&err);
36145:     }
36145:     NS_ASSERTION(mShutdown, "NP_Shutdown didn't");
36145: 
36063:     if (mSubprocess) {
36063:         mSubprocess->Delete();
36063:         mSubprocess = nsnull;
36063:     }
38121: 
76704:     Preferences::UnregisterCallback(TimeoutChanged, kChildTimeoutPref, this);
76704:     Preferences::UnregisterCallback(TimeoutChanged, kParentTimeoutPref, this);
35740: }
35740: 
39793: #ifdef MOZ_CRASHREPORTER
36145: void
79569: PluginModuleParent::WriteExtraDataForMinidump(CrashReporter::AnnotationTable& notes)
37384: {
39793:     typedef nsDependentCString CS;
37384: 
37384:     // Get the plugin filename, try to get just the file leafname
37384:     const std::string& pluginFile = mSubprocess->GetPluginFilePath();
37384:     size_t filePos = pluginFile.rfind(FILE_PATH_SEPARATOR);
37384:     if (filePos == std::string::npos)
37384:         filePos = 0;
37384:     else
37384:         filePos++;
39793:     notes.Put(CS("PluginFilename"), CS(pluginFile.substr(filePos).c_str()));
39793: 
37384:     //TODO: add plugin name and version: bug 539841
37384:     // (as PluginName, PluginVersion)
39793:     notes.Put(CS("PluginName"), CS(""));
39793:     notes.Put(CS("PluginVersion"), CS(""));
38688: 
79569:     const nsString& hangID = CrashReporter()->HangID();
79569:     if (!hangID.IsEmpty())
79569:         notes.Put(CS("HangID"), NS_ConvertUTF16toUTF8(hangID));
37384: }
39793: #endif  // MOZ_CRASHREPORTER
38688: 
38121: int
38121: PluginModuleParent::TimeoutChanged(const char* aPref, void* aModule)
38121: {
39785:     NS_ASSERTION(NS_IsMainThread(), "Wrong thead!");
76704:     if (!strcmp(aPref, kChildTimeoutPref)) {
76704:       // The timeout value used by the parent for children
76704:       PRInt32 timeoutSecs = Preferences::GetInt(kChildTimeoutPref, 0);
38121:       int32 timeoutMs = (timeoutSecs > 0) ? (1000 * timeoutSecs) :
38121:                         SyncChannel::kNoTimeout;
38121:       static_cast<PluginModuleParent*>(aModule)->SetReplyTimeoutMs(timeoutMs);
76704:     } else if (!strcmp(aPref, kParentTimeoutPref)) {
76704:       // The timeout value used by the child for its parent
76704:       PRInt32 timeoutSecs = Preferences::GetInt(kParentTimeoutPref, 0);
90631:       unused << static_cast<PluginModuleParent*>(aModule)->SendSetParentHangTimeout(timeoutSecs);
76704:     }
38121:     return 0;
38121: }
38121: 
38121: void
38121: PluginModuleParent::CleanupFromTimeout()
38121: {
96659:     if (!mShutdown && OkToCleanup())
38121:         Close();
38121: }
38121: 
38121: bool
38121: PluginModuleParent::ShouldContinueFromReplyTimeout()
38121: {
39793: #ifdef MOZ_CRASHREPORTER
79569:     CrashReporterParent* crashReporter = CrashReporter();
79569:     if (crashReporter->GeneratePairedMinidump(this)) {
79569:         mBrowserDumpID = crashReporter->ParentDumpID();
79569:         mPluginDumpID = crashReporter->ChildDumpID();
39793:         PLUGIN_LOG_DEBUG(
39793:                 ("generated paired browser/plugin minidumps: %s/%s (ID=%s)",
39793:                  NS_ConvertUTF16toUTF8(mBrowserDumpID).get(),
39793:                  NS_ConvertUTF16toUTF8(mPluginDumpID).get(),
79569:                  NS_ConvertUTF16toUTF8(crashReporter->HangID()).get()));
79569:     } else {
39793:         NS_WARNING("failed to capture paired minidumps from hang");
39793:     }
39793: #endif
39793: 
39793:     // this must run before the error notification from the channel,
39793:     // or not at all
38121:     MessageLoop::current()->PostTask(
38121:         FROM_HERE,
39793:         mTaskFactory.NewRunnableMethod(
39793:             &PluginModuleParent::CleanupFromTimeout));
38121: 
39793:     if (!KillProcess(OtherProcess(), 1, false))
39793:         NS_WARNING("failed to kill subprocess!");
38121: 
39793:     return false;
38121: }
38121: 
79569: #ifdef MOZ_CRASHREPORTER
79569: CrashReporterParent*
79569: PluginModuleParent::CrashReporter()
79569: {
79569:     MOZ_ASSERT(ManagedPCrashReporterParent().Length() > 0);
79569:     return static_cast<CrashReporterParent*>(ManagedPCrashReporterParent()[0]);
79569: }
79569: #endif
79569: 
37384: void
36145: PluginModuleParent::ActorDestroy(ActorDestroyReason why)
36145: {
36145:     switch (why) {
37384:     case AbnormalShutdown: {
39793: #ifdef MOZ_CRASHREPORTER
79569:         CrashReporterParent* crashReporter = CrashReporter();
79569: 
79569:         CrashReporter::AnnotationTable notes;
79569:         notes.Init(4);
79569:         WriteExtraDataForMinidump(notes);
79569:         
79569:         if (crashReporter->GenerateCrashReport(this, &notes)) {
79569:             mPluginDumpID = crashReporter->ChildDumpID();
39793:             PLUGIN_LOG_DEBUG(("got child minidump: %s",
39793:                               NS_ConvertUTF16toUTF8(mPluginDumpID).get()));
38026:         }
39793:         else if (!mPluginDumpID.IsEmpty() && !mBrowserDumpID.IsEmpty()) {
79569:             crashReporter->GenerateHangCrashReport(&notes);
37384:         }
37384:         else {
37384:             NS_WARNING("[PluginModuleParent::ActorDestroy] abnormal shutdown without minidump!");
37384:         }
39793: #endif
37384: 
36304:         mShutdown = true;
36304:         // Defer the PluginCrashed method so that we don't re-enter
36304:         // and potentially modify the actor child list while enumerating it.
39793:         if (mPlugin)
39793:             MessageLoop::current()->PostTask(
39793:                 FROM_HERE,
39793:                 mTaskFactory.NewRunnableMethod(
39793:                     &PluginModuleParent::NotifyPluginCrashed));
36304:         break;
37384:     }
36145:     case NormalShutdown:
36145:         mShutdown = true;
36145:         break;
36145: 
36145:     default:
36145:         NS_ERROR("Unexpected shutdown reason for toplevel actor.");
36145:     }
36145: }
36145: 
39312: void
39312: PluginModuleParent::NotifyPluginCrashed()
39312: {
39617:     if (!OkToCleanup()) {
39617:         // there's still plugin code on the C++ stack.  try again
39617:         MessageLoop::current()->PostDelayedTask(
39793:             FROM_HERE,
39793:             mTaskFactory.NewRunnableMethod(
39793:                 &PluginModuleParent::NotifyPluginCrashed), 10);
39617:         return;
39617:     }
39617: 
39312:     if (mPlugin)
39794:         mPlugin->PluginCrashed(mPluginDumpID, mBrowserDumpID);
39312: }
39312: 
39742: PPluginIdentifierParent*
39742: PluginModuleParent::AllocPPluginIdentifier(const nsCString& aString,
72341:                                            const int32_t& aInt,
72341:                                            const bool& aTemporary)
39742: {
72341:     if (aTemporary) {
72341:         NS_ERROR("Plugins don't create temporary identifiers.");
72341:         return NULL; // should abort the plugin
72341:     }
72341: 
39742:     NPIdentifier npident = aString.IsVoid() ?
39742:         mozilla::plugins::parent::_getintidentifier(aInt) :
39742:         mozilla::plugins::parent::_getstringidentifier(aString.get());
39742: 
39742:     if (!npident) {
39742:         NS_WARNING("Failed to get identifier!");
39742:         return nsnull;
39742:     }
39742: 
72341:     PluginIdentifierParent* ident = new PluginIdentifierParent(npident, false);
39742:     mIdentifiers.Put(npident, ident);
39742:     return ident;
39742: }
39742: 
39742: bool
39742: PluginModuleParent::DeallocPPluginIdentifier(PPluginIdentifierParent* aActor)
39742: {
39742:     delete aActor;
39742:     return true;
39742: }
39742: 
35898: PPluginInstanceParent*
35943: PluginModuleParent::AllocPPluginInstance(const nsCString& aMimeType,
35746:                                          const uint16_t& aMode,
57141:                                          const InfallibleTArray<nsCString>& aNames,
57141:                                          const InfallibleTArray<nsCString>& aValues,
35746:                                          NPError* rv)
35740: {
35890:     NS_ERROR("Not reachable!");
35890:     return NULL;
35740: }
35740: 
35926: bool
36138: PluginModuleParent::DeallocPPluginInstance(PPluginInstanceParent* aActor)
35746: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
35893:     delete aActor;
35926:     return true;
35746: }
35746: 
35746: void
35893: PluginModuleParent::SetPluginFuncs(NPPluginFuncs* aFuncs)
35746: {
35746:     aFuncs->version = (NP_VERSION_MAJOR << 8) | NP_VERSION_MINOR;
35746:     aFuncs->javaClass = nsnull;
35746: 
62174:     // Gecko should always call these functions through a PluginLibrary object.
62174:     aFuncs->newp = NULL;
62174:     aFuncs->clearsitedata = NULL;
62174:     aFuncs->getsiteswithdata = NULL;
62174: 
35910:     aFuncs->destroy = NPP_Destroy;
35910:     aFuncs->setwindow = NPP_SetWindow;
35910:     aFuncs->newstream = NPP_NewStream;
35910:     aFuncs->destroystream = NPP_DestroyStream;
35910:     aFuncs->asfile = NPP_StreamAsFile;
35910:     aFuncs->writeready = NPP_WriteReady;
35910:     aFuncs->write = NPP_Write;
35910:     aFuncs->print = NPP_Print;
35910:     aFuncs->event = NPP_HandleEvent;
35910:     aFuncs->urlnotify = NPP_URLNotify;
35910:     aFuncs->getvalue = NPP_GetValue;
35910:     aFuncs->setvalue = NPP_SetValue;
60021:     aFuncs->gotfocus = NULL;
60021:     aFuncs->lostfocus = NULL;
60021:     aFuncs->urlredirectnotify = NULL;
60021: 
62174:     // Provide 'NPP_URLRedirectNotify', 'NPP_ClearSiteData', and
62174:     // 'NPP_GetSitesWithData' functionality if it is supported by the plugin.
60021:     bool urlRedirectSupported = false;
62174:     unused << CallOptionalFunctionsSupported(&urlRedirectSupported,
62174:                                              &mClearSiteDataSupported,
62174:                                              &mGetSitesWithDataSupported);
60021:     if (urlRedirectSupported) {
60021:       aFuncs->urlredirectnotify = NPP_URLRedirectNotify;
60021:     }
35746: }
35746: 
35747: NPError
35893: PluginModuleParent::NPP_Destroy(NPP instance,
37311:                                 NPSavedData** /*saved*/)
35747: {
35747:     // FIXME/cjones:
35747:     //  (1) send a "destroy" message to the child
35747:     //  (2) the child shuts down its instance
35747:     //  (3) remove both parent and child IDs from map
35747:     //  (4) free parent
37099:     PLUGIN_LOG_DEBUG_FUNCTION;
35747: 
35893:     PluginInstanceParent* parentInstance =
35893:         static_cast<PluginInstanceParent*>(instance->pdata);
35747: 
36101:     if (!parentInstance)
36101:         return NPERR_NO_ERROR;
36101: 
37311:     NPError retval = parentInstance->Destroy();
35747:     instance->pdata = nsnull;
35747: 
41382:     unused << PluginInstanceParent::Call__delete__(parentInstance);
37311:     return retval;
35740: }
35740: 
35910: NPError
35910: PluginModuleParent::NPP_NewStream(NPP instance, NPMIMEType type,
35910:                                   NPStream* stream, NPBool seekable,
35910:                                   uint16_t* stype)
35910: {
88104:     SAMPLE_LABEL("PluginModuleParent", "NPP_NewStream");
36144:     PluginInstanceParent* i = InstCast(instance);
36144:     if (!i)
36144:         return NPERR_GENERIC_ERROR;
36144: 
36144:     return i->NPP_NewStream(type, stream, seekable,
35910:                             stype);
35910: }
35910: 
35910: NPError
35913: PluginModuleParent::NPP_SetWindow(NPP instance, NPWindow* window)
35913: {
36144:     PluginInstanceParent* i = InstCast(instance);
36144:     if (!i)
36144:         return NPERR_GENERIC_ERROR;
36144: 
36144:     return i->NPP_SetWindow(window);
35913: }
35913: 
35913: NPError
35910: PluginModuleParent::NPP_DestroyStream(NPP instance,
35910:                                       NPStream* stream,
35910:                                       NPReason reason)
35910: {
36144:     PluginInstanceParent* i = InstCast(instance);
36144:     if (!i)
36144:         return NPERR_GENERIC_ERROR;
36144: 
36144:     return i->NPP_DestroyStream(stream, reason);
35910: }
35910: 
35910: int32_t
35910: PluginModuleParent::NPP_WriteReady(NPP instance,
35910:                                    NPStream* stream)
35910: {
36144:     BrowserStreamParent* s = StreamCast(instance, stream);
36144:     if (!s)
36144:         return -1;
36144: 
36144:     return s->WriteReady();
35910: }
35910: 
35910: int32_t
35910: PluginModuleParent::NPP_Write(NPP instance,
35910:                               NPStream* stream,
35910:                               int32_t offset,
35910:                               int32_t len,
35910:                               void* buffer)
35910: {
36144:     BrowserStreamParent* s = StreamCast(instance, stream);
36144:     if (!s)
36144:         return -1;
36144: 
36144:     return s->Write(offset, len, buffer);
35910: }
35910: 
35910: void
35910: PluginModuleParent::NPP_StreamAsFile(NPP instance,
35910:                                      NPStream* stream,
35910:                                      const char* fname)
35910: {
36144:     BrowserStreamParent* s = StreamCast(instance, stream);
36144:     if (!s)
36144:         return;
36144: 
36144:     s->StreamAsFile(fname);
35910: }
35910: 
35910: void
35910: PluginModuleParent::NPP_Print(NPP instance, NPPrint* platformPrint)
35910: {
36144:     PluginInstanceParent* i = InstCast(instance);
36144:     if (i)
36144:         i->NPP_Print(platformPrint);
35910: }
35910: 
35910: int16_t
35910: PluginModuleParent::NPP_HandleEvent(NPP instance, void* event)
35910: {
36144:     PluginInstanceParent* i = InstCast(instance);
36144:     if (!i)
36144:         return false;
36144: 
36144:     return i->NPP_HandleEvent(event);
35910: }
35910: 
35910: void
35910: PluginModuleParent::NPP_URLNotify(NPP instance, const char* url,
35910:                                   NPReason reason, void* notifyData)
35910: {
36144:     PluginInstanceParent* i = InstCast(instance);
36144:     if (!i)
36144:         return;
36144: 
36144:     i->NPP_URLNotify(url, reason, notifyData);
35910: }
35910: 
35910: NPError
35910: PluginModuleParent::NPP_GetValue(NPP instance,
35910:                                  NPPVariable variable, void *ret_value)
35910: {
36144:     PluginInstanceParent* i = InstCast(instance);
36144:     if (!i)
36144:         return NPERR_GENERIC_ERROR;
36144: 
36144:     return i->NPP_GetValue(variable, ret_value);
35910: }
35910: 
35910: NPError
35910: PluginModuleParent::NPP_SetValue(NPP instance, NPNVariable variable,
35910:                                  void *value)
35910: {
36144:     PluginInstanceParent* i = InstCast(instance);
36144:     if (!i)
36144:         return NPERR_GENERIC_ERROR;
36144: 
36144:     return i->NPP_SetValue(variable, value);
35910: }
35910: 
35926: bool
57138: PluginModuleParent::RecvBackUpXResources(const FileDescriptor& aXSocketFd)
57138: {
57138: #ifndef MOZ_X11
57138:     NS_RUNTIMEABORT("This message only makes sense on X11 platforms");
57138: #else
95307:     NS_ABORT_IF_FALSE(0 > mPluginXSocketFdDup.get(),
57138:                       "Already backed up X resources??");
95307:     int fd = aXSocketFd.fd; // Copy to discard |const| qualifier
95307:     mPluginXSocketFdDup.forget();
95307:     mPluginXSocketFdDup.reset(fd);
57138: #endif
57138:     return true;
57138: }
57138: 
60021: void
60021: PluginModuleParent::NPP_URLRedirectNotify(NPP instance, const char* url,
60021:                                           int32_t status, void* notifyData)
60021: {
60021:   PluginInstanceParent* i = InstCast(instance);
60021:   if (!i)
60021:     return;
60021: 
60021:   i->NPP_URLRedirectNotify(url, status, notifyData);
60021: }
60021: 
57138: bool
35968: PluginModuleParent::AnswerNPN_UserAgent(nsCString* userAgent)
35968: {
36125:     *userAgent = NullableString(mNPNIface->uagent(nsnull));
35968:     return true;
35968: }
35968: 
72341: PluginIdentifierParent*
72341: PluginModuleParent::GetIdentifierForNPIdentifier(NPP npp, NPIdentifier aIdentifier)
35835: {
95428:     PluginIdentifierParent* ident;
72341:     if (mIdentifiers.Get(aIdentifier, &ident)) {
72341:         if (ident->IsTemporary()) {
72341:             ident->AddTemporaryRef();
72341:         }
72341:         return ident;
72341:     }
72341: 
39742:     nsCString string;
39742:     int32_t intval = -1;
72341:     bool temporary = false;
39742:     if (mozilla::plugins::parent::_identifierisstring(aIdentifier)) {
39742:         NPUTF8* chars =
39742:             mozilla::plugins::parent::_utf8fromidentifier(aIdentifier);
39742:         if (!chars) {
39742:             return nsnull;
35934:         }
39742:         string.Adopt(chars);
72341:         temporary = !NPStringIdentifierIsPermanent(npp, aIdentifier);
35927:     }
39742:     else {
39742:         intval = mozilla::plugins::parent::_intfromidentifier(aIdentifier);
80486:         string.SetIsVoid(true);
35835:     }
72341: 
72341:     ident = new PluginIdentifierParent(aIdentifier, temporary);
72341:     if (!SendPPluginIdentifierConstructor(ident, string, intval, temporary))
39742:         return nsnull;
41028: 
72341:     if (!temporary) {
39742:         mIdentifiers.Put(aIdentifier, ident);
35934:     }
39742:     return ident;
35835: }
35890: 
35893: PluginInstanceParent*
35893: PluginModuleParent::InstCast(NPP instance)
35890: {
35893:     PluginInstanceParent* ip =
35893:         static_cast<PluginInstanceParent*>(instance->pdata);
36144: 
36144:     // If the plugin crashed and the PluginInstanceParent was deleted,
36144:     // instance->pdata will be NULL.
36144:     if (!ip)
36144:         return NULL;
36144: 
35893:     if (instance != ip->mNPP) {
35890:         NS_RUNTIMEABORT("Corrupted plugin data.");
35893:     }
35890:     return ip;
35890: }
35890: 
35895: BrowserStreamParent*
35893: PluginModuleParent::StreamCast(NPP instance,
35893:                                NPStream* s)
35890: {
35893:     PluginInstanceParent* ip = InstCast(instance);
36144:     if (!ip)
36144:         return NULL;
36144: 
35895:     BrowserStreamParent* sp =
35938:         static_cast<BrowserStreamParent*>(static_cast<AStream*>(s->pdata));
35893:     if (sp->mNPP != ip || s != sp->mStream) {
35890:         NS_RUNTIMEABORT("Corrupted plugin stream data.");
35893:     }
35890:     return sp;
35890: }
35890: 
36010: bool
36010: PluginModuleParent::HasRequiredFunctions()
36010: {
36010:     return true;
36010: }
36010: 
52409: nsresult
52409: PluginModuleParent::AsyncSetWindow(NPP instance, NPWindow* window)
52409: {
52409:     PluginInstanceParent* i = InstCast(instance);
52409:     if (!i)
52409:         return NS_ERROR_FAILURE;
52409: 
52409:     return i->AsyncSetWindow(window);
52409: }
52409: 
77498: #if defined(MOZ_WIDGET_QT) && (MOZ_PLATFORM_MAEMO == 6)
77498: nsresult
77498: PluginModuleParent::HandleGUIEvent(NPP instance,
77498:                                    const nsGUIEvent& anEvent,
77498:                                    bool* handled)
77498: {
77498:     PluginInstanceParent* i = InstCast(instance);
77498:     if (!i)
77498:         return NS_ERROR_FAILURE;
77498: 
77498:     return i->HandleGUIEvent(anEvent, handled);
77498: }
77498: #endif
77498: 
52409: nsresult
89708: PluginModuleParent::GetImageContainer(NPP instance,
89708:                              mozilla::layers::ImageContainer** aContainer)
62473: {
62473:     PluginInstanceParent* i = InstCast(instance);
89708:     return !i ? NS_ERROR_FAILURE : i->GetImageContainer(aContainer);
62473: }
62473: 
62704: nsresult
62981: PluginModuleParent::GetImageSize(NPP instance,
62981:                                  nsIntSize* aSize)
62981: {
62981:     PluginInstanceParent* i = InstCast(instance);
62981:     return !i ? NS_ERROR_FAILURE : i->GetImageSize(aSize);
62981: }
62981: 
62981: nsresult
62704: PluginModuleParent::SetBackgroundUnknown(NPP instance)
62704: {
62704:     PluginInstanceParent* i = InstCast(instance);
62704:     if (!i)
62704:         return NS_ERROR_FAILURE;
62704: 
62704:     return i->SetBackgroundUnknown();
62704: }
62704: 
62704: nsresult
62704: PluginModuleParent::BeginUpdateBackground(NPP instance,
62704:                                           const nsIntRect& aRect,
62704:                                           gfxContext** aCtx)
62704: {
62704:     PluginInstanceParent* i = InstCast(instance);
62704:     if (!i)
62704:         return NS_ERROR_FAILURE;
62704: 
62704:     return i->BeginUpdateBackground(aRect, aCtx);
62704: }
62704: 
62704: nsresult
62704: PluginModuleParent::EndUpdateBackground(NPP instance,
62704:                                         gfxContext* aCtx,
62704:                                         const nsIntRect& aRect)
62704: {
62704:     PluginInstanceParent* i = InstCast(instance);
62704:     if (!i)
62704:         return NS_ERROR_FAILURE;
62704: 
62704:     return i->EndUpdateBackground(aCtx, aRect);
62704: }
62704: 
82142: #if defined(XP_UNIX) && !defined(XP_MACOSX) && !defined(MOZ_WIDGET_GONK)
36010: nsresult
36010: PluginModuleParent::NP_Initialize(NPNetscapeFuncs* bFuncs, NPPluginFuncs* pFuncs, NPError* error)
36010: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
36010: 
36010:     mNPNIface = bFuncs;
36010: 
36145:     if (mShutdown) {
36145:         *error = NPERR_GENERIC_ERROR;
36145:         return NS_ERROR_FAILURE;
36145:     }
36145: 
93035:     uint32_t flags = 0;
93035:     if (mozilla::Preferences::GetBool("plugin.allow.asyncdrawing", false)) {
93035:       flags |= kAllowAsyncDrawing;
93035:     }
93035: 
93035:     if (!CallNP_Initialize(flags, error)) {
36102:         return NS_ERROR_FAILURE;
36010:     }
36010:     else if (*error != NPERR_NO_ERROR) {
36010:         return NS_OK;
36010:     }
36010: 
36010:     SetPluginFuncs(pFuncs);
60021: 
36010:     return NS_OK;
36010: }
36010: #else
36010: nsresult
36010: PluginModuleParent::NP_Initialize(NPNetscapeFuncs* bFuncs, NPError* error)
36010: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
36010: 
36010:     mNPNIface = bFuncs;
36010: 
36145:     if (mShutdown) {
36145:         *error = NPERR_GENERIC_ERROR;
36145:         return NS_ERROR_FAILURE;
36145:     }
36145: 
93035:     uint32_t flags = 0;
93035:     if (mozilla::Preferences::GetBool("plugin.allow.asyncdrawing", false)) {
93035:       flags |= kAllowAsyncDrawing;
93035:     }
93035: 
93035:     if (!CallNP_Initialize(flags, error))
36102:         return NS_ERROR_FAILURE;
36010: 
90760: #if defined XP_WIN
72466:     // Send the info needed to join the chrome process's audio session to the
72466:     // plugin process
72466:     nsID id;
72466:     nsString sessionName;
72466:     nsString iconPath;
72466: 
72466:     if (NS_SUCCEEDED(mozilla::widget::GetAudioSessionData(id, sessionName,
72466:                                                           iconPath)))
72466:         SendSetAudioSessionData(id, sessionName, iconPath);
72466: #endif
72466: 
36010:     return NS_OK;
36010: }
36010: #endif
36010: 
36010: nsresult
36010: PluginModuleParent::NP_Shutdown(NPError* error)
36010: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
36010: 
36145:     if (mShutdown) {
36145:         *error = NPERR_GENERIC_ERROR;
36145:         return NS_ERROR_FAILURE;
36145:     }
36145: 
36140:     bool ok = CallNP_Shutdown(error);
36010: 
36140:     // if NP_Shutdown() is nested within another RPC call, this will
36140:     // break things.  but lord help us if we're doing that anyway; the
36140:     // plugin dso will have been unloaded on the other side by the
36140:     // CallNP_Shutdown() message
36039:     Close();
36039: 
36039:     return ok ? NS_OK : NS_ERROR_FAILURE;
36010: }
36010: 
36010: nsresult
37635: PluginModuleParent::NP_GetMIMEDescription(const char** mimeDesc)
36010: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
36010: 
37635:     *mimeDesc = "application/x-foobar";
36010:     return NS_OK;
36010: }
36010: 
36010: nsresult
36010: PluginModuleParent::NP_GetValue(void *future, NPPVariable aVariable,
36010:                                    void *aValue, NPError* error)
36010: {
37099:     PR_LOG(gPluginLog, PR_LOG_WARNING, ("%s Not implemented, requested variable %i", __FUNCTION__,
37099:                                         (int) aVariable));
36010: 
36010:     //TODO: implement this correctly
36010:     *error = NPERR_GENERIC_ERROR;
36010:     return NS_OK;
36010: }
36010: 
36764: #if defined(XP_WIN) || defined(XP_MACOSX) || defined(XP_OS2)
36010: nsresult
36010: PluginModuleParent::NP_GetEntryPoints(NPPluginFuncs* pFuncs, NPError* error)
36010: {
36010:     NS_ASSERTION(pFuncs, "Null pointer!");
36010: 
60021:     // We need to have the child process update its function table
60021:     // here by actually calling NP_GetEntryPoints since the parent's
60021:     // function table can reflect NULL entries in the child's table.
60021:     if (!CallNP_GetEntryPoints(error)) {
60021:         return NS_ERROR_FAILURE;
60021:     }
60021:     else if (*error != NPERR_NO_ERROR) {
60021:         return NS_OK;
60021:     }
60021: 
36010:     SetPluginFuncs(pFuncs);
60021: 
36010:     return NS_OK;
36010: }
36010: #endif
36010: 
36010: nsresult
36010: PluginModuleParent::NPP_New(NPMIMEType pluginType, NPP instance,
36010:                             uint16_t mode, int16_t argc, char* argn[],
36010:                             char* argv[], NPSavedData* saved,
36010:                             NPError* error)
36010: {
37099:     PLUGIN_LOG_DEBUG_METHOD;
36010: 
36145:     if (mShutdown) {
36145:         *error = NPERR_GENERIC_ERROR;
36145:         return NS_ERROR_FAILURE;
36145:     }
36145: 
36010:     // create the instance on the other side
57141:     InfallibleTArray<nsCString> names;
57141:     InfallibleTArray<nsCString> values;
36010: 
36010:     for (int i = 0; i < argc; ++i) {
36010:         names.AppendElement(NullableString(argn[i]));
36010:         values.AppendElement(NullableString(argv[i]));
36010:     }
36010: 
36098:     PluginInstanceParent* parentInstance =
41029:         new PluginInstanceParent(this, instance,
41029:                                  nsDependentCString(pluginType), mNPNIface);
36010: 
37311:     if (!parentInstance->Init()) {
37311:         delete parentInstance;
37311:         return NS_ERROR_FAILURE;
37311:     }
37311: 
36098:     instance->pdata = parentInstance;
36010: 
36010:     if (!CallPPluginInstanceConstructor(parentInstance,
36010:                                         nsDependentCString(pluginType), mode,
36098:                                         names, values, error)) {
36098:         // |parentInstance| is automatically deleted.
36098:         instance->pdata = nsnull;
36101:         // if IPC is down, we'll get an immediate "failed" return, but
36101:         // without *error being set.  So make sure that the error
36101:         // condition is signaled to nsNPAPIPluginInstance
36101:         if (NPERR_NO_ERROR == *error)
36101:             *error = NPERR_GENERIC_ERROR;
36010:         return NS_ERROR_FAILURE;
36098:     }
36010: 
36098:     if (*error != NPERR_NO_ERROR) {
37311:         NPP_Destroy(instance, 0);
42215:         return NS_ERROR_FAILURE;
36098:     }
36010: 
76704:     TimeoutChanged(kParentTimeoutPref, this);
76704:     
36010:     return NS_OK;
36010: }
36010: 
62174: nsresult
62174: PluginModuleParent::NPP_ClearSiteData(const char* site, uint64_t flags,
62174:                                       uint64_t maxAge)
62174: {
62174:     if (!mClearSiteDataSupported)
62174:         return NS_ERROR_NOT_AVAILABLE;
62174: 
62174:     NPError result;
62174:     if (!CallNPP_ClearSiteData(NullableString(site), flags, maxAge, &result))
62174:         return NS_ERROR_FAILURE;
62174: 
62174:     switch (result) {
62174:     case NPERR_NO_ERROR:
62174:         return NS_OK;
62174:     case NPERR_TIME_RANGE_NOT_SUPPORTED:
62174:         return NS_ERROR_PLUGIN_TIME_RANGE_NOT_SUPPORTED;
62174:     case NPERR_MALFORMED_SITE:
62174:         return NS_ERROR_INVALID_ARG;
62174:     default:
62174:         return NS_ERROR_FAILURE;
62174:     }
62174: }
62174: 
62174: nsresult
62174: PluginModuleParent::NPP_GetSitesWithData(InfallibleTArray<nsCString>& result)
62174: {
62174:     if (!mGetSitesWithDataSupported)
62174:         return NS_ERROR_NOT_AVAILABLE;
62174: 
62174:     if (!CallNPP_GetSitesWithData(&result))
62174:         return NS_ERROR_FAILURE;
62174: 
62174:     return NS_OK;
62174: }
62174: 
72866: #if defined(XP_MACOSX)
72866: nsresult
79445: PluginModuleParent::IsRemoteDrawingCoreAnimation(NPP instance, bool *aDrawing)
72866: {
72866:     PluginInstanceParent* i = InstCast(instance);
72866:     if (!i)
72866:         return NS_ERROR_FAILURE;
72866: 
72866:     return i->IsRemoteDrawingCoreAnimation(aDrawing);
72866: }
72866: #endif
72866: 
36125: bool
36125: PluginModuleParent::AnswerNPN_GetValue_WithBoolReturn(const NPNVariable& aVariable,
36125:                                                       NPError* aError,
36125:                                                       bool* aBoolVal)
36125: {
36125:     NPBool boolVal = false;
36125:     *aError = mozilla::plugins::parent::_getvalue(nsnull, aVariable, &boolVal);
36125:     *aBoolVal = boolVal ? true : false;
36125:     return true;
36125: }
38685: 
43456: #if defined(MOZ_WIDGET_QT)
43456: static const int kMaxtimeToProcessEvents = 30;
43456: bool
43456: PluginModuleParent::AnswerProcessSomeEvents()
43456: {
43456:     PLUGIN_LOG_DEBUG(("Spinning mini nested loop ..."));
43456:     QCoreApplication::processEvents(QEventLoop::AllEvents, kMaxtimeToProcessEvents);
43456: 
43456:     PLUGIN_LOG_DEBUG(("... quitting mini nested loop"));
43456: 
43456:     return true;
43456: }
43456: 
48383: #elif defined(XP_MACOSX)
48383: bool
48383: PluginModuleParent::AnswerProcessSomeEvents()
48383: {
48383:     mozilla::plugins::PluginUtilsOSX::InvokeNativeEventLoop();
48383:     return true;
48383: }
48383: 
43456: #elif !defined(MOZ_WIDGET_GTK2)
38685: bool
38685: PluginModuleParent::AnswerProcessSomeEvents()
38685: {
38685:     NS_RUNTIMEABORT("unreached");
38685:     return false;
38685: }
38685: 
38685: #else
38685: static const int kMaxChancesToProcessEvents = 20;
38685: 
38685: bool
38685: PluginModuleParent::AnswerProcessSomeEvents()
38685: {
38685:     PLUGIN_LOG_DEBUG(("Spinning mini nested loop ..."));
38685: 
39263:     int i = 0;
39263:     for (; i < kMaxChancesToProcessEvents; ++i)
39263:         if (!g_main_context_iteration(NULL, FALSE))
39263:             break;
38685: 
39263:     PLUGIN_LOG_DEBUG(("... quitting mini nested loop; processed %i tasks", i));
38685: 
38685:     return true;
38685: }
38685: #endif
41029: 
41651: bool
41651: PluginModuleParent::RecvProcessNativeEventsInRPCCall()
41651: {
41651:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
41651: #if defined(OS_WIN)
41651:     ProcessNativeEventsInRPCCall();
41651:     return true;
41651: #else
41651:     NS_NOTREACHED(
70027:         "PluginModuleParent::RecvProcessNativeEventsInRPCCall not implemented!");
50439:     return false;
50439: #endif
50439: }
50439: 
70027: void
70027: PluginModuleParent::ProcessRemoteNativeEventsInRPCCall()
70027: {
70027: #if defined(OS_WIN)
70027:     SendProcessNativeEventsInRPCCall();
70027:     return;
70027: #endif
70027:     NS_NOTREACHED(
70027:         "PluginModuleParent::ProcessRemoteNativeEventsInRPCCall not implemented!");
70027: }
70027: 
50439: bool
50439: PluginModuleParent::RecvPluginShowWindow(const uint32_t& aWindowId, const bool& aModal,
50439:                                          const int32_t& aX, const int32_t& aY,
50439:                                          const size_t& aWidth, const size_t& aHeight)
50439: {
50439:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
50439: #if defined(XP_MACOSX)
50439:     CGRect windowBound = ::CGRectMake(aX, aY, aWidth, aHeight);
50439:     mac_plugin_interposing::parent::OnPluginShowWindow(aWindowId, windowBound, aModal);
50439:     return true;
50439: #else
50439:     NS_NOTREACHED(
50439:         "PluginInstanceParent::RecvPluginShowWindow not implemented!");
50439:     return false;
50439: #endif
50439: }
50439: 
50439: bool
50439: PluginModuleParent::RecvPluginHideWindow(const uint32_t& aWindowId)
50439: {
50439:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
50439: #if defined(XP_MACOSX)
50439:     mac_plugin_interposing::parent::OnPluginHideWindow(aWindowId, OtherSidePID());
50439:     return true;
50439: #else
50439:     NS_NOTREACHED(
50439:         "PluginInstanceParent::RecvPluginHideWindow not implemented!");
41651:     return false;
41651: #endif
41651: }
41651: 
79569: PCrashReporterParent*
79569: PluginModuleParent::AllocPCrashReporter(mozilla::dom::NativeThreadId* id,
79569:                                         PRUint32* processType)
79569: {
79569: #ifdef MOZ_CRASHREPORTER
79569:     return new CrashReporterParent();
79569: #else
79569:     return nsnull;
79569: #endif
79569: }
79569: 
79569: bool
79569: PluginModuleParent::DeallocPCrashReporter(PCrashReporterParent* actor)
79569: {
79569:     delete actor;
79569:     return true;
79569: }
79569: 
70434: bool
70434: PluginModuleParent::RecvSetCursor(const NSCursorInfo& aCursorInfo)
70434: {
70434:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
70434: #if defined(XP_MACOSX)
70434:     mac_plugin_interposing::parent::OnSetCursor(aCursorInfo);
70434:     return true;
70434: #else
70434:     NS_NOTREACHED(
70434:         "PluginInstanceParent::RecvSetCursor not implemented!");
70434:     return false;
70434: #endif
70434: }
70434: 
70434: bool
70434: PluginModuleParent::RecvShowCursor(const bool& aShow)
70434: {
70434:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
70434: #if defined(XP_MACOSX)
70434:     mac_plugin_interposing::parent::OnShowCursor(aShow);
70434:     return true;
70434: #else
70434:     NS_NOTREACHED(
70434:         "PluginInstanceParent::RecvShowCursor not implemented!");
70434:     return false;
70434: #endif
70434: }
70434: 
70434: bool
70434: PluginModuleParent::RecvPushCursor(const NSCursorInfo& aCursorInfo)
70434: {
70434:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
70434: #if defined(XP_MACOSX)
70434:     mac_plugin_interposing::parent::OnPushCursor(aCursorInfo);
70434:     return true;
70434: #else
70434:     NS_NOTREACHED(
70434:         "PluginInstanceParent::RecvPushCursor not implemented!");
70434:     return false;
70434: #endif
70434: }
70434: 
70434: bool
70434: PluginModuleParent::RecvPopCursor()
70434: {
70434:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
70434: #if defined(XP_MACOSX)
70434:     mac_plugin_interposing::parent::OnPopCursor();
70434:     return true;
70434: #else
70434:     NS_NOTREACHED(
70434:         "PluginInstanceParent::RecvPopCursor not implemented!");
70434:     return false;
70434: #endif
70434: }
70434: 
70434: bool
70434: PluginModuleParent::RecvGetNativeCursorsSupported(bool* supported)
70434: {
70434:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
70434: #if defined(XP_MACOSX)
94707:     *supported =
94707:       Preferences::GetBool("dom.ipc.plugins.nativeCursorSupport", false);
70434:     return true;
70434: #else
70434:     NS_NOTREACHED(
70434:         "PluginInstanceParent::RecvGetNativeCursorSupportLevel not implemented!");
70434:     return false;
70434: #endif
70434: }
70434: 
74398: bool
74398: PluginModuleParent::RecvNPN_SetException(PPluginScriptableObjectParent* aActor,
74398:                                          const nsCString& aMessage)
74398: {
74398:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
74398: 
74398:     NPObject* aNPObj = NULL;
74398:     if (aActor) {
74398:         aNPObj = static_cast<PluginScriptableObjectParent*>(aActor)->GetObject(true);
74398:         if (!aNPObj) {
74398:             NS_ERROR("Failed to get object!");
74398:             return false;
74398:         }
74398:     }
74398:     mozilla::plugins::parent::_setexception(aNPObj, NullableStringGet(aMessage));
74398:     return true;
74398: }
96581: 
96581: bool
96581: PluginModuleParent::RecvNPN_ReloadPlugins(const bool& aReloadPages)
96581: {
96581:     PLUGIN_LOG_DEBUG(("%s", FULLFUNCTION));
96581: 
96581:     mozilla::plugins::parent::_reloadplugins(aReloadPages);
96581:     return true;
96581: }
