     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
     1: 
     1: #include "nsReadableUtils.h"
136246: 
     1: #include "nsMemory.h"
     1: #include "nsString.h"
136246: #include "nsTArray.h"
     1: #include "nsUTF8Utils.h"
     1: 
     1: void
     1: LossyCopyUTF16toASCII( const nsAString& aSource, nsACString& aDest )
     1:   {
     1:     aDest.Truncate();
     1:     LossyAppendUTF16toASCII(aSource, aDest);
     1:   }
     1: 
     1: void
     1: CopyASCIItoUTF16( const nsACString& aSource, nsAString& aDest )
     1:   {
     1:     aDest.Truncate();
     1:     AppendASCIItoUTF16(aSource, aDest);
     1:   }
     1: 
     1: void
179103: LossyCopyUTF16toASCII( const char16_t* aSource, nsACString& aDest )
     1:   {
     1:     aDest.Truncate();
     1:     if (aSource) {
     1:       LossyAppendUTF16toASCII(nsDependentString(aSource), aDest);
     1:     }
     1:   }
     1: 
     1: void
     1: CopyASCIItoUTF16( const char* aSource, nsAString& aDest )
     1:   {
     1:     aDest.Truncate();
     1:     if (aSource) {
     1:       AppendASCIItoUTF16(nsDependentCString(aSource), aDest);
     1:     }
     1:   }
     1: 
     1: void
     1: CopyUTF16toUTF8( const nsAString& aSource, nsACString& aDest )
     1:   {
     1:     aDest.Truncate();
     1:     AppendUTF16toUTF8(aSource, aDest);
     1:   }
     1: 
     1: void
     1: CopyUTF8toUTF16( const nsACString& aSource, nsAString& aDest )
     1:   {
     1:     aDest.Truncate();
     1:     AppendUTF8toUTF16(aSource, aDest);
     1:   }
     1: 
     1: void
179103: CopyUTF16toUTF8( const char16_t* aSource, nsACString& aDest )
     1:   {
     1:     aDest.Truncate();
     1:     AppendUTF16toUTF8(aSource, aDest);
     1:   }
     1: 
     1: void
     1: CopyUTF8toUTF16( const char* aSource, nsAString& aDest )
     1:   {
     1:     aDest.Truncate();
     1:     AppendUTF8toUTF16(aSource, aDest);
     1:   }
     1: 
     1: void
     1: LossyAppendUTF16toASCII( const nsAString& aSource, nsACString& aDest )
     1:   {
108991:     uint32_t old_dest_length = aDest.Length();
135452:     aDest.SetLength(old_dest_length + aSource.Length());
     1: 
     1:     nsAString::const_iterator fromBegin, fromEnd;
     1: 
     1:     nsACString::iterator dest;
     1:     aDest.BeginWriting(dest);
     1: 
     1:     dest.advance(old_dest_length);
     1: 
     1:     // right now, this won't work on multi-fragment destinations
 64047:     LossyConvertEncoding16to8 converter(dest.get());
     1: 
     1:     copy_string(aSource.BeginReading(fromBegin), aSource.EndReading(fromEnd), converter);
     1:   }
     1: 
     1: void
     1: AppendASCIItoUTF16( const nsACString& aSource, nsAString& aDest )
     1:   {
186279:     if (!AppendASCIItoUTF16(aSource, aDest, mozilla::fallible_t())) {
186279:       NS_ABORT_OOM(aDest.Length() + aSource.Length());
186279:     }
186279:   }
186279: 
186279: bool
186279: AppendASCIItoUTF16( const nsACString& aSource, nsAString& aDest,
186279:                     const mozilla::fallible_t& )
186279:   {
108991:     uint32_t old_dest_length = aDest.Length();
186279:     if (!aDest.SetLength(old_dest_length + aSource.Length(), mozilla::fallible_t())) {
186279:       return false;
186279:     }
     1: 
     1:     nsACString::const_iterator fromBegin, fromEnd;
     1: 
     1:     nsAString::iterator dest;
     1:     aDest.BeginWriting(dest);
     1: 
     1:     dest.advance(old_dest_length);
     1: 
     1:       // right now, this won't work on multi-fragment destinations
 64047:     LossyConvertEncoding8to16 converter(dest.get());
     1: 
     1:     copy_string(aSource.BeginReading(fromBegin), aSource.EndReading(fromEnd), converter);
186279:     return true;
     1:   }
     1: 
     1: void
179103: LossyAppendUTF16toASCII( const char16_t* aSource, nsACString& aDest )
     1:   {
     1:     if (aSource) {
     1:       LossyAppendUTF16toASCII(nsDependentString(aSource), aDest);
     1:     }
     1:   }
     1: 
     1: void
     1: AppendASCIItoUTF16( const char* aSource, nsAString& aDest )
     1:   {
     1:     if (aSource) {
     1:       AppendASCIItoUTF16(nsDependentCString(aSource), aDest);
     1:     }
     1:   }
     1: 
     1: void
     1: AppendUTF16toUTF8( const nsAString& aSource, nsACString& aDest )
     1: {
179373:   if (!AppendUTF16toUTF8(aSource, aDest, mozilla::fallible_t())) {
179373:     NS_ABORT_OOM(aDest.Length() + aSource.Length());
179373:   }
179373: }
179373: 
179373: bool
179373: AppendUTF16toUTF8( const nsAString& aSource, nsACString& aDest,
179373:                    const mozilla::fallible_t& )
179373:   {
     1:     nsAString::const_iterator source_start, source_end;
     1:     CalculateUTF8Size calculator;
     1:     copy_string(aSource.BeginReading(source_start),
     1:                 aSource.EndReading(source_end), calculator);
     1: 
108991:     uint32_t count = calculator.Size();
     1: 
     1:     if (count)
     1:       {
108991:         uint32_t old_dest_length = aDest.Length();
     1: 
     1:         // Grow the buffer if we need to.
179373:         if (!aDest.SetLength(old_dest_length + count, mozilla::fallible_t())) {
179373:           return false;
179373:         }
     1: 
     1:         // All ready? Time to convert
     1: 
 38423:         ConvertUTF16toUTF8 converter(aDest.BeginWriting() + old_dest_length);
     1:         copy_string(aSource.BeginReading(source_start),
     1:                     aSource.EndReading(source_end), converter);
     1: 
 38423:         NS_ASSERTION(converter.Size() == count,
 38423:                      "Unexpected disparity between CalculateUTF8Size and "
 38423:                      "ConvertUTF16toUTF8");
     1:       }
179373: 
179373:     return true;
     1:   }
     1: 
     1: void
     1: AppendUTF8toUTF16( const nsACString& aSource, nsAString& aDest )
     1: {
135452:   if (!AppendUTF8toUTF16(aSource, aDest, mozilla::fallible_t())) {
173128:     NS_ABORT_OOM(aDest.Length() + aSource.Length());
135452:   }
135452: }
135452: 
135452: bool
135452: AppendUTF8toUTF16( const nsACString& aSource, nsAString& aDest,
135452:                    const mozilla::fallible_t& )
135452:   {
     1:     nsACString::const_iterator source_start, source_end;
     1:     CalculateUTF8Length calculator;
     1:     copy_string(aSource.BeginReading(source_start),
     1:                 aSource.EndReading(source_end), calculator);
     1: 
108991:     uint32_t count = calculator.Length();
     1: 
 38423:     // Avoid making the string mutable if we're appending an empty string
     1:     if (count)
     1:       {
108991:         uint32_t old_dest_length = aDest.Length();
     1: 
     1:         // Grow the buffer if we need to.
135452:         if (!aDest.SetLength(old_dest_length + count, mozilla::fallible_t())) {
135452:           return false;
135452:         }
     1: 
     1:         // All ready? Time to convert
     1: 
 38423:         ConvertUTF8toUTF16 converter(aDest.BeginWriting() + old_dest_length);
     1:         copy_string(aSource.BeginReading(source_start),
     1:                     aSource.EndReading(source_end), converter);
     1: 
 38423:         NS_ASSERTION(converter.ErrorEncountered() ||
 38423:                      converter.Length() == count,
 38423:                      "CalculateUTF8Length produced the wrong length");
 38423: 
 38423:         if (converter.ErrorEncountered())
     1:           {
     1:             NS_ERROR("Input wasn't UTF8 or incorrect length was calculated");
     1:             aDest.SetLength(old_dest_length);
     1:           }
     1:       }
135452: 
135452:     return true;
     1:   }
     1: 
     1: void
179103: AppendUTF16toUTF8( const char16_t* aSource, nsACString& aDest )
     1:   {
     1:     if (aSource) {
     1:       AppendUTF16toUTF8(nsDependentString(aSource), aDest);
     1:     }
     1:   }
     1: 
     1: void
     1: AppendUTF8toUTF16( const char* aSource, nsAString& aDest )
     1:   {
     1:     if (aSource) {
     1:       AppendUTF8toUTF16(nsDependentCString(aSource), aDest);
     1:     }
     1:   }
     1: 
     1: 
     1:   /**
     1:    * A helper function that allocates a buffer of the desired character type big enough to hold a copy of the supplied string (plus a zero terminator).
     1:    *
     1:    * @param aSource an string you will eventually be making a copy of
     1:    * @return a new buffer (of the type specified by the second parameter) which you must free with |nsMemory::Free|.
     1:    *
     1:    */
     1: template <class FromStringT, class ToCharT>
     1: inline
     1: ToCharT*
     1: AllocateStringCopy( const FromStringT& aSource, ToCharT* )
     1:   {
  3233:     return static_cast<ToCharT*>(nsMemory::Alloc((aSource.Length()+1) * sizeof(ToCharT)));
     1:   }
     1: 
     1: 
     1: char*
     1: ToNewCString( const nsAString& aSource )
     1:   {
     1:     char* result = AllocateStringCopy(aSource, (char*)0);
     1:     if (!result)
106838:       return nullptr;
     1: 
     1:     nsAString::const_iterator fromBegin, fromEnd;
 64047:     LossyConvertEncoding16to8 converter(result);
     1:     copy_string(aSource.BeginReading(fromBegin), aSource.EndReading(fromEnd), converter).write_terminator();
     1:     return result;
     1:   }
     1: 
     1: char*
108991: ToNewUTF8String( const nsAString& aSource, uint32_t *aUTF8Count )
     1:   {
     1:     nsAString::const_iterator start, end;
     1:     CalculateUTF8Size calculator;
     1:     copy_string(aSource.BeginReading(start), aSource.EndReading(end),
     1:                 calculator);
     1: 
     1:     if (aUTF8Count)
     1:       *aUTF8Count = calculator.Size();
     1: 
  3233:     char *result = static_cast<char*>
  3233:                               (nsMemory::Alloc(calculator.Size() + 1));
     1:     if (!result)
106838:       return nullptr;
     1: 
     1:     ConvertUTF16toUTF8 converter(result);
     1:     copy_string(aSource.BeginReading(start), aSource.EndReading(end),
     1:                 converter).write_terminator();
     1:     NS_ASSERTION(calculator.Size() == converter.Size(), "length mismatch");
     1: 
     1:     return result;
     1:   }
     1: 
     1: char*
     1: ToNewCString( const nsACString& aSource )
     1:   {
     1:     // no conversion needed, just allocate a buffer of the correct length and copy into it
     1: 
     1:     char* result = AllocateStringCopy(aSource, (char*)0);
     1:     if (!result)
106838:       return nullptr;
     1: 
     1:     nsACString::const_iterator fromBegin, fromEnd;
     1:     char* toBegin = result;
     1:     *copy_string(aSource.BeginReading(fromBegin), aSource.EndReading(fromEnd), toBegin) = char(0);
     1:     return result;
     1:   }
     1: 
179103: char16_t*
     1: ToNewUnicode( const nsAString& aSource )
     1:   {
     1:     // no conversion needed, just allocate a buffer of the correct length and copy into it
     1: 
179103:     char16_t* result = AllocateStringCopy(aSource, (char16_t*)0);
     1:     if (!result)
106838:       return nullptr;
     1: 
     1:     nsAString::const_iterator fromBegin, fromEnd;
179103:     char16_t* toBegin = result;
179103:     *copy_string(aSource.BeginReading(fromBegin), aSource.EndReading(fromEnd), toBegin) = char16_t(0);
     1:     return result;
     1:   }
     1: 
179103: char16_t*
     1: ToNewUnicode( const nsACString& aSource )
     1:   {
179103:     char16_t* result = AllocateStringCopy(aSource, (char16_t*)0);
     1:     if (!result)
106838:       return nullptr;
     1: 
     1:     nsACString::const_iterator fromBegin, fromEnd;
 64047:     LossyConvertEncoding8to16 converter(result);
     1:     copy_string(aSource.BeginReading(fromBegin), aSource.EndReading(fromEnd), converter).write_terminator();
     1:     return result;
     1:   }
     1: 
130890: uint32_t
130890: CalcUTF8ToUnicodeLength( const nsACString& aSource)
     1:   {
     1:     nsACString::const_iterator start, end;
     1:     CalculateUTF8Length calculator;
     1:     copy_string(aSource.BeginReading(start), aSource.EndReading(end),
     1:                 calculator);
130890:     return calculator.Length();
130890:   }
130890: 
179103: char16_t*
179103: UTF8ToUnicodeBuffer( const nsACString& aSource, char16_t* aBuffer, uint32_t *aUTF16Count )
130890:   {
130890:     nsACString::const_iterator start, end;
130890:     ConvertUTF8toUTF16 converter(aBuffer);
130890:     copy_string(aSource.BeginReading(start),
130890:                 aSource.EndReading(end),
130890:                 converter).write_terminator();
130890:     if (aUTF16Count)
130890:       *aUTF16Count = converter.Length();
130890:     return aBuffer;
130890:   }
130890: 
179103: char16_t*
130890: UTF8ToNewUnicode( const nsACString& aSource, uint32_t *aUTF16Count )
130890:   {
130890:     const uint32_t length = CalcUTF8ToUnicodeLength(aSource);
179103:     const size_t buffer_size = (length + 1) * sizeof(char16_t);
179103:     char16_t *buffer = static_cast<char16_t*>(nsMemory::Alloc(buffer_size));
130890:     if (!buffer)
130890:       return nullptr;
130890: 
130890:     uint32_t copied;
130890:     UTF8ToUnicodeBuffer(aSource, buffer, &copied);
130890:     NS_ASSERTION(length == copied, "length mismatch");
     1: 
     1:     if (aUTF16Count)
130890:       *aUTF16Count = copied;
130890:     return buffer;
     1:   }
     1: 
179103: char16_t*
179103: CopyUnicodeTo( const nsAString& aSource, uint32_t aSrcOffset, char16_t* aDest, uint32_t aLength )
     1:   {
     1:     nsAString::const_iterator fromBegin, fromEnd;
179103:     char16_t* toBegin = aDest;    
108991:     copy_string(aSource.BeginReading(fromBegin).advance( int32_t(aSrcOffset) ), aSource.BeginReading(fromEnd).advance( int32_t(aSrcOffset+aLength) ), toBegin);
     1:     return aDest;
     1:   }
     1: 
     1: void
     1: CopyUnicodeTo( const nsAString::const_iterator& aSrcStart,
     1:                const nsAString::const_iterator& aSrcEnd,
     1:                nsAString& aDest )
     1:   {
     1:     nsAString::iterator writer;
135452:     aDest.SetLength(Distance(aSrcStart, aSrcEnd));
  3064: 
     1:     aDest.BeginWriting(writer);
     1:     nsAString::const_iterator fromBegin(aSrcStart);
     1:     
     1:     copy_string(fromBegin, aSrcEnd, writer);
     1:   }
     1: 
     1: void
     1: AppendUnicodeTo( const nsAString::const_iterator& aSrcStart,
     1:                  const nsAString::const_iterator& aSrcEnd,
     1:                  nsAString& aDest )
     1:   {
     1:     nsAString::iterator writer;
108991:     uint32_t oldLength = aDest.Length();
135452:     aDest.SetLength(oldLength + Distance(aSrcStart, aSrcEnd));
  3064: 
     1:     aDest.BeginWriting(writer).advance(oldLength);
     1:     nsAString::const_iterator fromBegin(aSrcStart);
     1:     
     1:     copy_string(fromBegin, aSrcEnd, writer);
     1:   }
     1: 
 79445: bool
     1: IsASCII( const nsAString& aString )
     1:   {
179103:     static const char16_t NOT_ASCII = char16_t(~0x007F);
     1: 
     1: 
     1:     // Don't want to use |copy_string| for this task, since we can stop at the first non-ASCII character
     1: 
  9792:     nsAString::const_iterator iter, done_reading;
  9792:     aString.BeginReading(iter);
     1:     aString.EndReading(done_reading);
     1: 
179103:     const char16_t* c = iter.get();
179103:     const char16_t* end = done_reading.get();
  9792:     
  9792:     while ( c < end )
     1:       {
     1:         if ( *c++ & NOT_ASCII )
 80486:           return false;
     1:       }
     1: 
 80486:     return true;
     1:   }
     1: 
 79445: bool
     1: IsASCII( const nsACString& aString )
     1:   {
     1:     static const char NOT_ASCII = char(~0x7F);
     1: 
     1: 
     1:     // Don't want to use |copy_string| for this task, since we can stop at the first non-ASCII character
     1: 
  9792:     nsACString::const_iterator iter, done_reading;
  9792:     aString.BeginReading(iter);
     1:     aString.EndReading(done_reading);
     1: 
  9792:     const char* c = iter.get();
  9792:     const char* end = done_reading.get();
  9792:     
  9792:     while ( c < end )
     1:       {
     1:         if ( *c++ & NOT_ASCII )
 80486:           return false;
     1:       }
     1: 
 80486:     return true;
     1:   }
     1: 
 79445: bool
 79445: IsUTF8( const nsACString& aString, bool aRejectNonChar )
     1:   {
     1:     nsReadingIterator<char> done_reading;
     1:     aString.EndReading(done_reading);
     1: 
108991:     int32_t state = 0;
 79445:     bool overlong = false;
 79445:     bool surrogate = false;
 79445:     bool nonchar = false;
108991:     uint16_t olupper = 0; // overlong byte upper bound.
108991:     uint16_t slower = 0;  // surrogate byte lower bound.
     1: 
     1:     nsReadingIterator<char> iter;
  9792:     aString.BeginReading(iter);
     1: 
     1:     const char* ptr = iter.get();
  9792:     const char* end = done_reading.get();
  9792:     while ( ptr < end )
     1:       {
108991:         uint8_t c;
     1:         
     1:         if (0 == state)
     1:           {
     1:             c = *ptr++;
     1: 
     1:             if ( UTF8traits::isASCII(c) ) 
     1:               continue;
     1: 
     1:             if ( c <= 0xC1 ) // [80-BF] where not expected, [C0-C1] for overlong.
 80486:               return false;
     1:             else if ( UTF8traits::is2byte(c) ) 
     1:                 state = 1;
     1:             else if ( UTF8traits::is3byte(c) ) 
     1:               {
     1:                 state = 2;
     1:                 if ( c == 0xE0 ) // to exclude E0[80-9F][80-BF] 
     1:                   {
 80486:                     overlong = true;
     1:                     olupper = 0x9F;
     1:                   }
     1:                 else if ( c == 0xED ) // ED[A0-BF][80-BF] : surrogate codepoint
     1:                   {
 80486:                     surrogate = true;
     1:                     slower = 0xA0;
     1:                   }
     1:                 else if ( c == 0xEF ) // EF BF [BE-BF] : non-character
 80486:                   nonchar = true;
     1:               }
     1:             else if ( c <= 0xF4 ) // XXX replace /w UTF8traits::is4byte when it's updated to exclude [F5-F7].(bug 199090)
     1:               {
     1:                 state = 3;
 80486:                 nonchar = true;
     1:                 if ( c == 0xF0 ) // to exclude F0[80-8F][80-BF]{2}
     1:                   {
 80486:                     overlong = true;
     1:                     olupper = 0x8F;
     1:                   }
     1:                 else if ( c == 0xF4 ) // to exclude F4[90-BF][80-BF] 
     1:                   {
     1:                     // actually not surrogates but codepoints beyond 0x10FFFF
 80486:                     surrogate = true;
     1:                     slower = 0x90;
     1:                   }
     1:               }
     1:             else
 80486:               return false; // Not UTF-8 string
     1:           }
     1:           
 78539:         if (nonchar && !aRejectNonChar)
 80486:           nonchar = false;
 78539: 
  9792:         while ( ptr < end && state )
     1:           {
     1:             c = *ptr++;
     1:             --state;
     1: 
     1:             // non-character : EF BF [BE-BF] or F[0-7] [89AB]F BF [BE-BF]
 64138:             if ( nonchar &&  
 64138:                  ( ( !state && c < 0xBE ) ||
 64138:                    ( state == 1 && c != 0xBF )  ||
 64138:                    ( state == 2 && 0x0F != (0x0F & c) )))
 80486:               nonchar = false;
     1: 
 64138:             if ( !UTF8traits::isInSeq(c) || ( overlong && c <= olupper ) || 
 64138:                  ( surrogate && slower <= c ) || ( nonchar && !state ))
 80486:               return false; // Not UTF-8 string
 64138: 
 80486:             overlong = surrogate = false;
     1:           }
     1:         }
     1:     return !state; // state != 0 at the end indicates an invalid UTF-8 seq. 
     1:   }
     1: 
     1:   /**
     1:    * A character sink for in-place case conversion.
     1:    */
     1: class ConvertToUpperCase
     1:   {
     1:     public:
     1:       typedef char value_type;
     1: 
108991:       uint32_t
108991:       write( const char* aSource, uint32_t aSourceLength )
     1:         {
  3233:           char* cp = const_cast<char*>(aSource);
     1:           const char* end = aSource + aSourceLength;
     1:           while (cp != end) {
     1:             char ch = *cp;
     1:             if ((ch >= 'a') && (ch <= 'z'))
     1:               *cp = ch - ('a' - 'A');
     1:             ++cp;
     1:           }
     1:           return aSourceLength;
     1:         }
     1:   };
     1: 
     1: void
     1: ToUpperCase( nsCSubstring& aCString )
     1:   {
     1:     ConvertToUpperCase converter;
     1:     char* start;
     1:     converter.write(aCString.BeginWriting(start), aCString.Length());
     1:   }
     1: 
     1:   /**
     1:    * A character sink for copying with case conversion.
     1:    */
     1: class CopyToUpperCase
     1:   {
     1:     public:
     1:       typedef char value_type;
     1: 
     1:       CopyToUpperCase( nsACString::iterator& aDestIter )
     1:         : mIter(aDestIter)
     1:         {
     1:         }
     1: 
108991:       uint32_t
108991:       write( const char* aSource, uint32_t aSourceLength )
     1:         {
129544:           uint32_t len = XPCOM_MIN(uint32_t(mIter.size_forward()), aSourceLength);
     1:           char* cp = mIter.get();
     1:           const char* end = aSource + len;
     1:           while (aSource != end) {
     1:             char ch = *aSource;
     1:             if ((ch >= 'a') && (ch <= 'z'))
     1:               *cp = ch - ('a' - 'A');
     1:             else
     1:               *cp = ch;
     1:             ++aSource;
     1:             ++cp;
     1:           }
     1:           mIter.advance(len);
     1:           return len;
     1:         }
     1: 
     1:     protected:
     1:       nsACString::iterator& mIter;
     1:   };
     1: 
     1: void
     1: ToUpperCase( const nsACString& aSource, nsACString& aDest )
     1:   {
     1:     nsACString::const_iterator fromBegin, fromEnd;
     1:     nsACString::iterator toBegin;
135452:     aDest.SetLength(aSource.Length());
  3064: 
     1:     CopyToUpperCase converter(aDest.BeginWriting(toBegin));
     1:     copy_string(aSource.BeginReading(fromBegin), aSource.EndReading(fromEnd), converter);
     1:   }
     1: 
     1:   /**
     1:    * A character sink for case conversion.
     1:    */
     1: class ConvertToLowerCase
     1:   {
     1:     public:
     1:       typedef char value_type;
     1: 
108991:       uint32_t
108991:       write( const char* aSource, uint32_t aSourceLength )
     1:         {
  3233:           char* cp = const_cast<char*>(aSource);
     1:           const char* end = aSource + aSourceLength;
     1:           while (cp != end) {
     1:             char ch = *cp;
     1:             if ((ch >= 'A') && (ch <= 'Z'))
     1:               *cp = ch + ('a' - 'A');
     1:             ++cp;
     1:           }
     1:           return aSourceLength;
     1:         }
     1:   };
     1: 
     1: void
     1: ToLowerCase( nsCSubstring& aCString )
     1:   {
     1:     ConvertToLowerCase converter;
     1:     char* start;
     1:     converter.write(aCString.BeginWriting(start), aCString.Length());
     1:   }
     1: 
     1:   /**
     1:    * A character sink for copying with case conversion.
     1:    */
     1: class CopyToLowerCase
     1:   {
     1:     public:
     1:       typedef char value_type;
     1: 
     1:       CopyToLowerCase( nsACString::iterator& aDestIter )
     1:         : mIter(aDestIter)
     1:         {
     1:         }
     1: 
108991:       uint32_t
108991:       write( const char* aSource, uint32_t aSourceLength )
     1:         {
129544:           uint32_t len = XPCOM_MIN(uint32_t(mIter.size_forward()), aSourceLength);
     1:           char* cp = mIter.get();
     1:           const char* end = aSource + len;
     1:           while (aSource != end) {
     1:             char ch = *aSource;
     1:             if ((ch >= 'A') && (ch <= 'Z'))
     1:               *cp = ch + ('a' - 'A');
     1:             else
     1:               *cp = ch;
     1:             ++aSource;
     1:             ++cp;
     1:           }
     1:           mIter.advance(len);
     1:           return len;
     1:         }
     1: 
     1:     protected:
     1:       nsACString::iterator& mIter;
     1:   };
     1: 
     1: void
     1: ToLowerCase( const nsACString& aSource, nsACString& aDest )
     1:   {
     1:     nsACString::const_iterator fromBegin, fromEnd;
     1:     nsACString::iterator toBegin;
135452:     aDest.SetLength(aSource.Length());
  3064: 
     1:     CopyToLowerCase converter(aDest.BeginWriting(toBegin));
     1:     copy_string(aSource.BeginReading(fromBegin), aSource.EndReading(fromEnd), converter);
     1:   }
     1: 
 79445: bool
 24031: ParseString(const nsACString& aSource, char aDelimiter, 
 24031:             nsTArray<nsCString>& aArray)
 24031:   {
 24031:     nsACString::const_iterator start, end;
 24031:     aSource.BeginReading(start);
 24031:     aSource.EndReading(end);
 24031: 
108991:     uint32_t oldLength = aArray.Length();
 24031: 
 24031:     for (;;)
 24031:       {
 24031:         nsACString::const_iterator delimiter = start;
 24031:         FindCharInReadable(aDelimiter, delimiter, end);
 24031: 
 24031:         if (delimiter != start)
 24031:           {
 24031:             if (!aArray.AppendElement(Substring(start, delimiter)))
 24031:               {
 24031:                 aArray.RemoveElementsAt(oldLength, aArray.Length() - oldLength);
 80486:                 return false;
 24031:               }
 24031:           }
 24031: 
 24031:         if (delimiter == end)
 24031:           break;
 24031:         start = ++delimiter;
 24031:         if (start == end)
 24031:           break;
 24031:       }
 24031: 
 80486:     return true;
 24031:   }
 24031: 
     1: template <class StringT, class IteratorT, class Comparator>
 79445: bool
     1: FindInReadable_Impl( const StringT& aPattern, IteratorT& aSearchStart, IteratorT& aSearchEnd, const Comparator& compare )
     1:   {
 79445:     bool found_it = false;
     1: 
     1:       // only bother searching at all if we're given a non-empty range to search
     1:     if ( aSearchStart != aSearchEnd )
     1:       {
     1:         IteratorT aPatternStart, aPatternEnd;
     1:         aPattern.BeginReading(aPatternStart);
     1:         aPattern.EndReading(aPatternEnd);
     1: 
     1:           // outer loop keeps searching till we find it or run out of string to search
     1:         while ( !found_it )
     1:           {
     1:               // fast inner loop (that's what it's called, not what it is) looks for a potential match
     1:             while ( aSearchStart != aSearchEnd &&
 56399:                     compare(aPatternStart.get(), aSearchStart.get(), 1, 1) )
     1:               ++aSearchStart;
     1: 
     1:               // if we broke out of the `fast' loop because we're out of string ... we're done: no match
     1:             if ( aSearchStart == aSearchEnd )
     1:               break;
     1: 
     1:               // otherwise, we're at a potential match, let's see if we really hit one
     1:             IteratorT testPattern(aPatternStart);
     1:             IteratorT testSearch(aSearchStart);
     1: 
     1:               // slow inner loop verifies the potential match (found by the `fast' loop) at the current position
     1:             for(;;)
     1:               {
     1:                   // we already compared the first character in the outer loop,
     1:                   //  so we'll advance before the next comparison
     1:                 ++testPattern;
     1:                 ++testSearch;
     1: 
     1:                   // if we verified all the way to the end of the pattern, then we found it!
     1:                 if ( testPattern == aPatternEnd )
     1:                   {
 80486:                     found_it = true;
     1:                     aSearchEnd = testSearch; // return the exact found range through the parameters
     1:                     break;
     1:                   }
     1: 
     1:                   // if we got to end of the string we're searching before we hit the end of the
     1:                   //  pattern, we'll never find what we're looking for
     1:                 if ( testSearch == aSearchEnd )
     1:                   {
     1:                     aSearchStart = aSearchEnd;
     1:                     break;
     1:                   }
     1: 
     1:                   // else if we mismatched ... it's time to advance to the next search position
     1:                   //  and get back into the `fast' loop
 56399:                 if ( compare(testPattern.get(), testSearch.get(), 1, 1) )
     1:                   {
     1:                     ++aSearchStart;
     1:                     break;
     1:                   }
     1:               }
     1:           }
     1:       }
     1: 
     1:     return found_it;
     1:   }
     1: 
  3809:   /**
  3809:    * This searches the entire string from right to left, and returns the first match found, if any.
  3809:    */
  3809: template <class StringT, class IteratorT, class Comparator>
 79445: bool
  3809: RFindInReadable_Impl( const StringT& aPattern, IteratorT& aSearchStart, IteratorT& aSearchEnd, const Comparator& compare )
  3809:   {
  3809:     IteratorT patternStart, patternEnd, searchEnd = aSearchEnd;
  3809:     aPattern.BeginReading(patternStart);
  3809:     aPattern.EndReading(patternEnd);
  3809: 
  3809:       // Point to the last character in the pattern
  3809:     --patternEnd;
  3809:       // outer loop keeps searching till we run out of string to search
  3809:     while ( aSearchStart != searchEnd )
  3809:       {
  3809:           // Point to the end position of the next possible match
  3809:         --searchEnd;
  3809:     
  3809:           // Check last character, if a match, explore further from here
 56399:         if ( compare(patternEnd.get(), searchEnd.get(), 1, 1) == 0 )
  3809:           {  
  3809:               // We're at a potential match, let's see if we really hit one
  3809:             IteratorT testPattern(patternEnd);
  3809:             IteratorT testSearch(searchEnd);
  3809: 
  3809:               // inner loop verifies the potential match at the current position
  3809:             do
  3809:               {
  3809:                   // if we verified all the way to the end of the pattern, then we found it!
  3809:                 if ( testPattern == patternStart )
  3809:                   {
  3809:                     aSearchStart = testSearch;  // point to start of match
  3809:                     aSearchEnd = ++searchEnd;   // point to end of match
 80486:                     return true;
  3809:                   }
  3809:     
  3809:                   // if we got to end of the string we're searching before we hit the end of the
  3809:                   //  pattern, we'll never find what we're looking for
  3809:                 if ( testSearch == aSearchStart )
  3809:                   {
  3809:                     aSearchStart = aSearchEnd;
 80486:                     return false;
  3809:                   }
  3809:     
  3809:                   // test previous character for a match
  3809:                 --testPattern;
  3809:                 --testSearch;
  3809:               }
 56399:             while ( compare(testPattern.get(), testSearch.get(), 1, 1) == 0 );
  3809:           }
  3809:       }
  3809: 
  3809:     aSearchStart = aSearchEnd;
 80486:     return false;
  3809:   }
     1: 
 79445: bool
     1: FindInReadable( const nsAString& aPattern, nsAString::const_iterator& aSearchStart, nsAString::const_iterator& aSearchEnd, const nsStringComparator& aComparator )
     1:   {
     1:     return FindInReadable_Impl(aPattern, aSearchStart, aSearchEnd, aComparator);
     1:   }
     1: 
 79445: bool
     1: FindInReadable( const nsACString& aPattern, nsACString::const_iterator& aSearchStart, nsACString::const_iterator& aSearchEnd, const nsCStringComparator& aComparator)
     1:   {
     1:     return FindInReadable_Impl(aPattern, aSearchStart, aSearchEnd, aComparator);
     1:   }
     1: 
 79445: bool
     1: CaseInsensitiveFindInReadable( const nsACString& aPattern, nsACString::const_iterator& aSearchStart, nsACString::const_iterator& aSearchEnd )
     1:   {
     1:     return FindInReadable_Impl(aPattern, aSearchStart, aSearchEnd, nsCaseInsensitiveCStringComparator());
     1:   }
     1: 
 79445: bool
     1: RFindInReadable( const nsAString& aPattern, nsAString::const_iterator& aSearchStart, nsAString::const_iterator& aSearchEnd, const nsStringComparator& aComparator)
     1:   {
  3809:     return RFindInReadable_Impl(aPattern, aSearchStart, aSearchEnd, aComparator);
     1:   }
     1: 
 79445: bool
     1: RFindInReadable( const nsACString& aPattern, nsACString::const_iterator& aSearchStart, nsACString::const_iterator& aSearchEnd, const nsCStringComparator& aComparator)
     1:   {
  3809:     return RFindInReadable_Impl(aPattern, aSearchStart, aSearchEnd, aComparator);
     1:   }
     1: 
 79445: bool
179103: FindCharInReadable( char16_t aChar, nsAString::const_iterator& aSearchStart, const nsAString::const_iterator& aSearchEnd )
     1:   {
108991:     int32_t fragmentLength = aSearchEnd.get() - aSearchStart.get();
     1: 
179103:     const char16_t* charFoundAt = nsCharTraits<char16_t>::find(aSearchStart.get(), fragmentLength, aChar);
     1:     if ( charFoundAt ) {
     1:       aSearchStart.advance( charFoundAt - aSearchStart.get() );
 80486:       return true;
     1:     }
     1: 
     1:     aSearchStart.advance(fragmentLength);
 80486:     return false;
     1:   }
     1: 
 79445: bool
     1: FindCharInReadable( char aChar, nsACString::const_iterator& aSearchStart, const nsACString::const_iterator& aSearchEnd )
     1:   {
108991:     int32_t fragmentLength = aSearchEnd.get() - aSearchStart.get();
     1: 
     1:     const char* charFoundAt = nsCharTraits<char>::find(aSearchStart.get(), fragmentLength, aChar);
     1:     if ( charFoundAt ) {
     1:       aSearchStart.advance( charFoundAt - aSearchStart.get() );
 80486:       return true;
     1:     }
     1: 
     1:     aSearchStart.advance(fragmentLength);
 80486:     return false;
     1:   }
     1: 
108991: uint32_t
     1: CountCharInReadable( const nsAString& aStr,
179103:                      char16_t aChar )
     1: {
108991:   uint32_t count = 0;
     1:   nsAString::const_iterator begin, end;
     1:   
     1:   aStr.BeginReading(begin);
     1:   aStr.EndReading(end);
     1:   
     1:   while (begin != end) {
     1:     if (*begin == aChar) {
     1:       ++count;
     1:     }
     1:     ++begin;
     1:   }
     1: 
     1:   return count;
     1: }
     1: 
108991: uint32_t
     1: CountCharInReadable( const nsACString& aStr,
     1:                      char aChar )
     1: {
108991:   uint32_t count = 0;
     1:   nsACString::const_iterator begin, end;
     1:   
     1:   aStr.BeginReading(begin);
     1:   aStr.EndReading(end);
     1:   
     1:   while (begin != end) {
     1:     if (*begin == aChar) {
     1:       ++count;
     1:     }
     1:     ++begin;
     1:   }
     1: 
     1:   return count;
     1: }
     1: 
 79445: bool
     1: StringBeginsWith( const nsAString& aSource, const nsAString& aSubstring,
     1:                   const nsStringComparator& aComparator )
     1:   {
     1:     nsAString::size_type src_len = aSource.Length(),
     1:                          sub_len = aSubstring.Length();
     1:     if (sub_len > src_len)
 80486:       return false;
     1:     return Substring(aSource, 0, sub_len).Equals(aSubstring, aComparator);
     1:   }
     1: 
 79445: bool
     1: StringBeginsWith( const nsACString& aSource, const nsACString& aSubstring,
     1:                   const nsCStringComparator& aComparator )
     1:   {
     1:     nsACString::size_type src_len = aSource.Length(),
     1:                           sub_len = aSubstring.Length();
     1:     if (sub_len > src_len)
 80486:       return false;
     1:     return Substring(aSource, 0, sub_len).Equals(aSubstring, aComparator);
     1:   }
     1: 
 79445: bool
     1: StringEndsWith( const nsAString& aSource, const nsAString& aSubstring,
     1:                 const nsStringComparator& aComparator )
     1:   {
     1:     nsAString::size_type src_len = aSource.Length(),
     1:                          sub_len = aSubstring.Length();
     1:     if (sub_len > src_len)
 80486:       return false;
     1:     return Substring(aSource, src_len - sub_len, sub_len).Equals(aSubstring,
     1:                                                                  aComparator);
     1:   }
     1: 
 79445: bool
     1: StringEndsWith( const nsACString& aSource, const nsACString& aSubstring,
     1:                 const nsCStringComparator& aComparator )
     1:   {
     1:     nsACString::size_type src_len = aSource.Length(),
     1:                           sub_len = aSubstring.Length();
     1:     if (sub_len > src_len)
 80486:       return false;
     1:     return Substring(aSource, src_len - sub_len, sub_len).Equals(aSubstring,
     1:                                                                  aComparator);
     1:   }
     1: 
     1: 
     1: 
179103: static const char16_t empty_buffer[1] = { '\0' };
     1: 
     1: const nsAFlatString&
     1: EmptyString()
     1:   {
     1:     static const nsDependentString sEmpty(empty_buffer);
     1: 
     1:     return sEmpty;
     1:   }
     1: 
     1: const nsAFlatCString&
     1: EmptyCString()
     1:   {
     1:     static const nsDependentCString sEmpty((const char *)empty_buffer);
     1: 
     1:     return sEmpty;
     1:   }
     1: 
 85953: const nsAFlatString&
 85953: NullString()
 85953:   {
 85953:     static const nsXPIDLString sNull;
 85953: 
 85953:     return sNull;
 85953:   }
 85953: 
 85953: const nsAFlatCString&
 85953: NullCString()
 85953:   {
 85953:     static const nsXPIDLCString sNull;
 85953: 
 85953:     return sNull;
 85953:   }
 85953: 
108991: int32_t
     1: CompareUTF8toUTF16(const nsASingleFragmentCString& aUTF8String,
     1:                    const nsASingleFragmentString& aUTF16String)
     1:   {
108991:     static const uint32_t NOT_ASCII = uint32_t(~0x7F);
     1: 
     1:     const char *u8, *u8end;
     1:     aUTF8String.BeginReading(u8);
     1:     aUTF8String.EndReading(u8end);
     1: 
179103:     const char16_t *u16, *u16end;
     1:     aUTF16String.BeginReading(u16);
     1:     aUTF16String.EndReading(u16end);
     1: 
     1:     while (u8 != u8end && u16 != u16end)
     1:       {
     1:         // Cast away the signedness of *u8 to prevent signextension when
108991:         // converting to uint32_t
108991:         uint32_t c8_32 = (uint8_t)*u8;
     1: 
     1:         if (c8_32 & NOT_ASCII)
     1:           {
 79445:             bool err;
     1:             c8_32 = UTF8CharEnumerator::NextChar(&u8, u8end, &err);
     1:             if (err)
115367:               return INT32_MIN;
     1: 
108991:             uint32_t c16_32 = UTF16CharEnumerator::NextChar(&u16, u16end);
  5883:             // The above UTF16CharEnumerator::NextChar() calls can
  5883:             // fail, but if it does for anything other than no data to
  5883:             // look at (which can't happen here), it returns the
  5883:             // Unicode replacement character 0xFFFD for the invalid
  5883:             // data they were fed. Ignore that error and treat invalid
  5883:             // UTF16 as 0xFFFD.
  5883:             //
  5883:             // This matches what our UTF16 to UTF8 conversion code
  5883:             // does, and thus a UTF8 string that came from an invalid
  5883:             // UTF16 string will compare equal to the invalid UTF16
  5883:             // string it came from. Same is true for any other UTF16
  5883:             // string differs only in the invalid part of the string.
     1:             
     1:             if (c8_32 != c16_32)
     1:               return c8_32 < c16_32 ? -1 : 1;
     1:           }
     1:         else
     1:           {
     1:             if (c8_32 != *u16)
     1:               return c8_32 > *u16 ? 1 : -1;
     1: 
     1:             ++u8;
     1:             ++u16;
     1:           }
     1:       }
     1: 
     1:     if (u8 != u8end)
     1:       {
     1:         // We get to the end of the UTF16 string, but no to the end of
     1:         // the UTF8 string. The UTF8 string is longer than the UTF16
     1:         // string
     1: 
     1:         return 1;
     1:       }
     1: 
     1:     if (u16 != u16end)
     1:       {
     1:         // We get to the end of the UTF8 string, but no to the end of
     1:         // the UTF16 string. The UTF16 string is longer than the UTF8
     1:         // string
     1: 
     1:         return -1;
     1:       }
     1: 
     1:     // The two strings match.
     1: 
     1:     return 0;
     1:   }
     1: 
     1: void
108991: AppendUCS4ToUTF16(const uint32_t aSource, nsAString& aDest)
     1:   {
     1:     NS_ASSERTION(IS_VALID_CHAR(aSource), "Invalid UCS4 char");
     1:     if (IS_IN_BMP(aSource))
     1:       {
179103:         aDest.Append(char16_t(aSource));
     1:       }
     1:     else
     1:       {
     1:         aDest.Append(H_SURROGATE(aSource));
     1:         aDest.Append(L_SURROGATE(aSource));
     1:       }
     1:   }
