   1: /* -*- Mode: C++; tab-width: 20; indent-tabs-mode: nil; c-basic-offset: 4 -*-
   1:  * ***** BEGIN LICENSE BLOCK *****
   1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
   1:  *
   1:  * The contents of this file are subject to the Mozilla Public License Version
   1:  * 1.1 (the "License"); you may not use this file except in compliance with
   1:  * the License. You may obtain a copy of the License at
   1:  * http://www.mozilla.org/MPL/
   1:  *
   1:  * Software distributed under the License is distributed on an "AS IS" basis,
   1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   1:  * for the specific language governing rights and limitations under the
   1:  * License.
   1:  *
   1:  * The Original Code is Oracle Corporation code.
   1:  *
   1:  * The Initial Developer of the Original Code is Oracle Corporation.
   1:  * Portions created by the Initial Developer are Copyright (C) 2005
   1:  * the Initial Developer. All Rights Reserved.
   1:  *
   1:  * Contributor(s):
   1:  *   Stuart Parmenter <pavlov@pavlov.net>
   1:  *
   1:  * Alternatively, the contents of this file may be used under the terms of
   1:  * either the GNU General Public License Version 2 or later (the "GPL"), or
   1:  * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   1:  * in which case the provisions of the GPL or the LGPL are applicable instead
   1:  * of those above. If you wish to allow use of your version of this file only
   1:  * under the terms of either the GPL or the LGPL, and not to allow others to
   1:  * use your version of this file under the terms of the MPL, indicate your
   1:  * decision by deleting the provisions above and replace them with the notice
   1:  * and other provisions required by the GPL or the LGPL. If you do not delete
   1:  * the provisions above, a recipient may use your version of this file under
   1:  * the terms of any one of the MPL, the GPL or the LGPL.
   1:  *
   1:  * ***** END LICENSE BLOCK ***** */
   1: 
   1: #include "gfxWindowsSurface.h"
   1: #include "gfxContext.h"
   1: #include "gfxPlatform.h"
   1: 
   1: #include "cairo.h"
   1: #include "cairo-win32.h"
   1: 
   1: #include "nsString.h"
   1: 
   1: gfxWindowsSurface::gfxWindowsSurface(HWND wnd) :
   1:     mOwnsDC(PR_TRUE), mWnd(wnd)
   1: {
   1:     mDC = ::GetDC(mWnd);
   1:     Init(cairo_win32_surface_create(mDC));
   1: }
   1: 
   1: gfxWindowsSurface::gfxWindowsSurface(HDC dc, PRBool deleteDC) :
   1:     mOwnsDC(deleteDC), mDC(dc),mWnd(nsnull)
   1: {
   1:     Init(cairo_win32_surface_create(mDC));
   1: }
   1: 
   1: gfxWindowsSurface::gfxWindowsSurface(const gfxIntSize& size, gfxImageFormat imageFormat) :
   1:     mOwnsDC(PR_FALSE), mWnd(nsnull)
   1: {
1349:     if (!CheckSurfaceSize(size))
1349:         return;
1349: 
   1:     cairo_surface_t *surf = cairo_win32_surface_create_with_dib((cairo_format_t)imageFormat,
   1:                                                                 size.width, size.height);
   1:     Init(surf);
   1: 
   1:     mDC = cairo_win32_surface_get_dc(CairoSurface());
   1: }
   1: 
   1: gfxWindowsSurface::gfxWindowsSurface(HDC dc, const gfxIntSize& size, gfxImageFormat imageFormat) :
   1:     mOwnsDC(PR_FALSE), mWnd(nsnull)
   1: {
1349:     if (!CheckSurfaceSize(size))
1349:         return;
1349: 
   1:     cairo_surface_t *surf = cairo_win32_surface_create_with_ddb(dc, (cairo_format_t)imageFormat,
   1:                                                                 size.width, size.height);
   1:     Init(surf);
   1: 
   1:     mDC = cairo_win32_surface_get_dc(CairoSurface());
   1: }
   1: 
   1: 
   1: gfxWindowsSurface::gfxWindowsSurface(cairo_surface_t *csurf) :
   1:     mOwnsDC(PR_FALSE), mWnd(nsnull)
   1: {
   1:     mDC = cairo_win32_surface_get_dc(csurf);
   1: 
   1:     Init(csurf, PR_TRUE);
   1: }
   1: 
   1: gfxWindowsSurface::~gfxWindowsSurface()
   1: {
   1:     if (mOwnsDC) {
   1:         if (mWnd)
   1:             ::ReleaseDC(mWnd, mDC);
   1:         else
   1:             ::DeleteDC(mDC);
   1:     }
   1: }
   1: 
   1: already_AddRefed<gfxImageSurface>
   1: gfxWindowsSurface::GetImageSurface()
   1: {
   1:     cairo_surface_t *isurf = cairo_win32_surface_get_image(CairoSurface());
   1:     if (!isurf)
   1:         return nsnull;
   1: 
   1:     nsRefPtr<gfxASurface> asurf = gfxASurface::Wrap(isurf);
   1:     gfxImageSurface *imgsurf = (gfxImageSurface*) asurf.get();
   1:     NS_ADDREF(imgsurf);
   1:     return imgsurf;
   1: }
   1: 
   1: already_AddRefed<gfxWindowsSurface>
   1: gfxWindowsSurface::OptimizeToDDB(HDC dc, const gfxIntSize& size, gfxImageFormat format)
   1: {
   1:     gfxImageFormat realFormat = format;
   1:     if (realFormat == ImageFormatARGB32) {
   1:         cairo_surface_t *isurf = cairo_win32_surface_get_image(CairoSurface());
   1:         if (isurf && !gfxPlatform::DoesARGBImageDataHaveAlpha(cairo_image_surface_get_data(isurf),
   1:                                                               cairo_image_surface_get_width(isurf),
   1:                                                               cairo_image_surface_get_height(isurf),
   1:                                                               cairo_image_surface_get_stride(isurf)))
   1:         {
   1:             realFormat = ImageFormatRGB24;
   1:         }
   1:     }
   1: 
   1:     if (realFormat != ImageFormatRGB24)
   1:         return nsnull;
   1: 
   1:     nsRefPtr<gfxWindowsSurface> wsurf = new gfxWindowsSurface(dc, size, realFormat);
   1: 
   1:     nsRefPtr<gfxContext> tmpCtx(new gfxContext(wsurf));
   1:     tmpCtx->SetOperator(gfxContext::OPERATOR_SOURCE);
   1:     tmpCtx->SetSource(this);
   1:     tmpCtx->Paint();
   1: 
   1:     gfxWindowsSurface *raw = (gfxWindowsSurface*) (wsurf.get());
   1:     NS_ADDREF(raw);
   1:     return raw;
   1: }
   1: 
   1: static char*
   1: GetACPString(const nsAString& aStr)
   1: {
   1:     int acplen = aStr.Length() * 2 + 1;
   1:     char * acp = new char[acplen];
   1:     if(acp) {
   1:         int outlen = ::WideCharToMultiByte(CP_ACP, 0, 
   1:                                            PromiseFlatString(aStr).get(),
   1:                                            aStr.Length(),
   1:                                            acp, acplen, NULL, NULL);
   1:         if (outlen > 0)
   1:             acp[outlen] = '\0';  // null terminate
   1:     }
   1:     return acp;
   1: }
   1: 
   1: nsresult gfxWindowsSurface::BeginPrinting(const nsAString& aTitle,
   1:                                           const nsAString& aPrintToFileName)
   1: {
   1: #define DOC_TITLE_LENGTH 30
   1:     DOCINFO docinfo;
   1: 
   1:     nsString titleStr;
   1:     titleStr = aTitle;
   1:     if (titleStr.Length() > DOC_TITLE_LENGTH) {
   1:         titleStr.SetLength(DOC_TITLE_LENGTH-3);
   1:         titleStr.AppendLiteral("...");
   1:     }
   1:     char *title = GetACPString(titleStr);
   1: 
   1:     char *docName = nsnull;
   1:     if (!aPrintToFileName.IsEmpty()) {
   1:         docName = ToNewCString(aPrintToFileName);
   1:     }
   1: 
   1:     docinfo.cbSize = sizeof(docinfo);
   1:     docinfo.lpszDocName = title ? title : "Mozilla Document";
   1:     docinfo.lpszOutput = docName;
   1:     docinfo.lpszDatatype = NULL;
   1:     docinfo.fwType = 0;
   1: 
   1:     ::StartDoc(mDC, &docinfo);
   1:         
   1:     delete [] title;
   1:     if (docName != nsnull) nsMemory::Free(docName);
   1: 
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult gfxWindowsSurface::EndPrinting()
   1: {
   1:     ::EndDoc(mDC);
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult gfxWindowsSurface::AbortPrinting()
   1: {
   1:     ::AbortDoc(mDC);
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult gfxWindowsSurface::BeginPage()
   1: {
   1:     ::StartPage(mDC);
   1:     return NS_OK;
   1: }
   1: 
   1: nsresult gfxWindowsSurface::EndPage()
   1: {
   1:     ::EndPage(mDC);
   1:     return NS_OK;
   1: }
