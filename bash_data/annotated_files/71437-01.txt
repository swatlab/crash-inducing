43833: /* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
43833: /* vim: set sw=2 ts=8 et tw=80 : */
43833: /* ***** BEGIN LICENSE BLOCK *****
43833:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
43833:  *
43833:  * The contents of this file are subject to the Mozilla Public License Version
43833:  * 1.1 (the "License"); you may not use this file except in compliance with
43833:  * the License. You may obtain a copy of the License at
43833:  * http://www.mozilla.org/MPL/
43833:  *
43833:  * Software distributed under the License is distributed on an "AS IS" basis,
43833:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
43833:  * for the specific language governing rights and limitations under the
43833:  * License.
43833:  *
43833:  * The Original Code is mozilla.org code.
43833:  *
43833:  * The Initial Developer of the Original Code is
43833:  * Wellington Fernando de Macedo.
43833:  * Portions created by the Initial Developer are Copyright (C) 2009
43833:  * the Initial Developer. All Rights Reserved.
43833:  *
43833:  * Contributor(s):
43833:  *    Wellington Fernando de Macedo <wfernandom2004@gmail.com> (original author)
70220:  *    Patrick McManus <mcmanus@ducksong.com>
43833:  *
43833:  * Alternatively, the contents of this file may be used under the terms of
43833:  * either of the GNU General Public License Version 2 or later (the "GPL"),
43833:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
43833:  * in which case the provisions of the GPL or the LGPL are applicable instead
43833:  * of those above. If you wish to allow use of your version of this file only
43833:  * under the terms of either the GPL or the LGPL, and not to allow others to
43833:  * use your version of this file under the terms of the MPL, indicate your
43833:  * decision by deleting the provisions above and replace them with the notice
43833:  * and other provisions required by the GPL or the LGPL. If you do not delete
43833:  * the provisions above, a recipient may use your version of this file under
43833:  * the terms of any one of the MPL, the GPL or the LGPL.
43833:  *
43833:  * ***** END LICENSE BLOCK ***** */
43833: 
43833: #include "nsWebSocket.h"
70359: 
43833: #include "nsIScriptGlobalObject.h"
43833: #include "nsIDOMWindow.h"
43833: #include "nsIDocument.h"
43833: #include "nsXPCOM.h"
43833: #include "nsIXPConnect.h"
43833: #include "nsContentUtils.h"
43833: #include "nsEventDispatcher.h"
43833: #include "nsDOMError.h"
43833: #include "nsIScriptObjectPrincipal.h"
43833: #include "nsIDOMClassInfo.h"
43833: #include "nsDOMClassInfo.h"
43833: #include "jsapi.h"
43833: #include "nsIURL.h"
43833: #include "nsIPrivateDOMEvent.h"
43833: #include "nsIInterfaceRequestor.h"
43833: #include "nsICharsetConverterManager.h"
43833: #include "nsIUnicodeEncoder.h"
43833: #include "nsThreadUtils.h"
43833: #include "nsIDOMMessageEvent.h"
43833: #include "nsIPromptFactory.h"
43833: #include "nsIWindowWatcher.h"
43833: #include "nsIPrompt.h"
43833: #include "nsIStringBundle.h"
43833: #include "nsIConsoleService.h"
43833: #include "nsLayoutStatics.h"
43834: #include "nsIDOMCloseEvent.h"
43834: #include "nsICryptoHash.h"
59557: #include "jsdbgapi.h"
59557: #include "nsIJSContextStack.h"
59557: #include "nsJSUtils.h"
59557: #include "nsIScriptError.h"
70220: #include "nsNetUtil.h"
70220: #include "nsIWebSocketProtocol.h"
70220: #include "nsILoadGroup.h"
70220: #include "nsIRequest.h"
70840: #include "mozilla/Preferences.h"
43833: 
43833: using namespace mozilla;
43833: 
43833: ////////////////////////////////////////////////////////////////////////////////
43833: // nsWebSocketEstablishedConnection
43833: ////////////////////////////////////////////////////////////////////////////////
43833: 
43833: #define UTF_8_REPLACEMENT_CHAR    static_cast<PRUnichar>(0xFFFD)
43833: 
43833: #define ENSURE_TRUE_AND_FAIL_IF_FAILED(x, ret)                            \
43833:   PR_BEGIN_MACRO                                                          \
43833:     if (NS_UNLIKELY(!(x))) {                                              \
43833:        NS_WARNING("ENSURE_TRUE_AND_FAIL_IF_FAILED(" #x ") failed");       \
43833:        FailConnection();                                                  \
43833:        return ret;                                                        \
43833:     }                                                                     \
43833:   PR_END_MACRO
43833: 
43833: #define ENSURE_SUCCESS_AND_FAIL_IF_FAILED(res, ret)                       \
43833:   PR_BEGIN_MACRO                                                          \
43833:     nsresult __rv = res;                                                  \
43833:     if (NS_FAILED(__rv)) {                                                \
43833:       NS_ENSURE_SUCCESS_BODY(res, ret)                                    \
43833:       FailConnection();                                                   \
43833:       return ret;                                                         \
43833:     }                                                                     \
43833:   PR_END_MACRO
43833: 
43833: // nsIInterfaceRequestor will be the unambiguous class for this class
43833: class nsWebSocketEstablishedConnection: public nsIInterfaceRequestor,
70220:                                         public nsIWebSocketListener,
70220:                                         public nsIRequest
43833: {
43833: public:
43833:   nsWebSocketEstablishedConnection();
43833:   virtual ~nsWebSocketEstablishedConnection();
43833: 
43833:   NS_DECL_ISUPPORTS
43833:   NS_DECL_NSIINTERFACEREQUESTOR
70220:   NS_DECL_NSIWEBSOCKETLISTENER
43833:   NS_DECL_NSIREQUEST
43833: 
43833:   nsresult Init(nsWebSocket *aOwner);
43833:   nsresult Disconnect();
43833: 
70220:   // these method when called can release both the WebSocket object
48067:   // (i.e. mOwner) and its connection (i.e. *this*).
70220:   nsresult Close();
70220:   nsresult FailConnection();
70220:   nsresult ConsoleError();
43834: 
48067:   PRBool HasOutgoingMessages()
70220:   { return mOutgoingBufferedAmount != 0; }
48067: 
43834:   PRBool ClosedCleanly() { return mClosedCleanly; }
43834: 
43833:   nsresult PostMessage(const nsString& aMessage);
43833:   PRUint32 GetOutgoingBufferedAmount() { return mOutgoingBufferedAmount; }
43833: 
70220: private:
43833: 
43833:   nsresult PrintErrorOnConsole(const char       *aBundleURI,
43833:                                const PRUnichar  *aError,
43833:                                const PRUnichar **aFormatStrings,
43833:                                PRUint32          aFormatStringsLen);
70220:   nsresult UpdateMustKeepAlive();
43833:   
70220:   // Frames that have been sent to websockethandler but not placed on wire
70220:   PRUint32 mOutgoingBufferedAmount;
43833: 
70220:   nsWebSocket* mOwner; // weak reference
70220:   nsCOMPtr<nsIWebSocketProtocol> mWebSocketProtocol;
43833: 
43834:   PRPackedBool mClosedCleanly;
43833: 
43833:   enum ConnectionStatus {
43833:     CONN_NOT_CONNECTED,
43833:     CONN_CONNECTED_AND_READY,
43833:     CONN_CLOSED
43833:   };
70220: 
43833:   ConnectionStatus mStatus;
43833: };
43833: 
43833: //-----------------------------------------------------------------------------
43833: // nsWebSocketEstablishedConnection::nsISupports
43833: //-----------------------------------------------------------------------------
43833: 
70220: NS_IMPL_THREADSAFE_ISUPPORTS3(nsWebSocketEstablishedConnection,
43833:                               nsIInterfaceRequestor,
70220:                               nsIWebSocketListener,
70220:                               nsIRequest)
43833: 
43833: //-----------------------------------------------------------------------------
43833: // nsWebSocketEstablishedConnection methods:
43833: //-----------------------------------------------------------------------------
43833: 
43833: nsWebSocketEstablishedConnection::nsWebSocketEstablishedConnection() :
43833:   mOutgoingBufferedAmount(0),
43833:   mOwner(nsnull),
43834:   mClosedCleanly(PR_FALSE),
43833:   mStatus(CONN_NOT_CONNECTED)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833:   nsLayoutStatics::AddRef();
43833: }
43833: 
43833: nsWebSocketEstablishedConnection::~nsWebSocketEstablishedConnection()
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
70220:   NS_ABORT_IF_FALSE(!mOwner, "Disconnect wasn't called!");
70220:   NS_ABORT_IF_FALSE(!mWebSocketProtocol, "Disconnect wasn't called!");
43833: }
43833: 
43833: nsresult
43833: nsWebSocketEstablishedConnection::PostMessage(const nsString& aMessage)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833: 
43833:   if (!mOwner) {
43833:     return NS_OK;
43833:   }
43833: 
43833:   // only send messages when connected
43833:   NS_ENSURE_STATE(mStatus >= CONN_CONNECTED_AND_READY);
43833: 
43833:   nsresult rv;
43833: 
43833:   nsCOMPtr<nsICharsetConverterManager> ccm =
43833:     do_GetService(NS_CHARSETCONVERTERMANAGER_CONTRACTID, &rv);
43834:   ENSURE_SUCCESS_AND_FAIL_IF_FAILED(rv, rv);
43833: 
43833:   nsCOMPtr<nsIUnicodeEncoder> converter;
43833:   rv = ccm->GetUnicodeEncoder("UTF-8", getter_AddRefs(converter));
43834:   ENSURE_SUCCESS_AND_FAIL_IF_FAILED(rv, rv);
43833: 
43833:   rv = converter->SetOutputErrorBehavior(nsIUnicodeEncoder::kOnError_Replace,
43833:                                          nsnull, UTF_8_REPLACEMENT_CHAR);
43834:   ENSURE_SUCCESS_AND_FAIL_IF_FAILED(rv, rv);
43833: 
43833:   PRInt32 inLen = aMessage.Length();
43833:   PRInt32 maxLen;
43833:   rv = converter->GetMaxLength(aMessage.BeginReading(), inLen, &maxLen);
43834:   ENSURE_SUCCESS_AND_FAIL_IF_FAILED(rv, rv);
43833: 
70220:   nsCString buf;
70220:   buf.SetLength(maxLen);
70220:   ENSURE_TRUE_AND_FAIL_IF_FAILED(buf.Length() == static_cast<PRUint32>(maxLen),
43833:                                  NS_ERROR_OUT_OF_MEMORY);
43833: 
70220:   char* start = buf.BeginWriting();
43833: 
43833:   PRInt32 outLen = maxLen;
43833:   rv = converter->Convert(aMessage.BeginReading(), &inLen, start, &outLen);
43833:   if (NS_SUCCEEDED(rv)) {
43833:     PRInt32 outLen2 = maxLen - outLen;
43833:     rv = converter->Finish(start + outLen, &outLen2);
43833:     outLen += outLen2;
43833:   }
43833:   if (NS_FAILED(rv) || rv == NS_ERROR_UENC_NOMAPPING) {
43833:     // Yes, NS_ERROR_UENC_NOMAPPING is a success code
43833:     return NS_ERROR_DOM_SYNTAX_ERR;
43833:   }
43833: 
70220:   buf.SetLength(outLen);
70220:   ENSURE_TRUE_AND_FAIL_IF_FAILED(buf.Length() == static_cast<PRUint32>(outLen),
43833:                                  NS_ERROR_UNEXPECTED);
43833: 
70220:   if (mStatus == CONN_CLOSED) {
70220:     NS_ABORT_IF_FALSE(mOwner, "Posting data after disconnecting the websocket");
70220:     // the tcp connection has been closed, but the main thread hasn't received
70220:     // the event for disconnecting the object yet.
70220:     rv = NS_BASE_STREAM_CLOSED;
70220:   } else {
70220:     mOutgoingBufferedAmount += buf.Length();
70220:     mWebSocketProtocol->SendMsg(buf);
70220:     rv = NS_OK;
70220:   }
70220: 
70220:   UpdateMustKeepAlive();
43834:   ENSURE_SUCCESS_AND_FAIL_IF_FAILED(rv, rv);
43834: 
43834:   return NS_OK;
43833: }
43833: 
43833: nsresult
43833: nsWebSocketEstablishedConnection::Init(nsWebSocket *aOwner)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
70220:   NS_ABORT_IF_FALSE(!mOwner, "WebSocket's connection is already initialized");
43833: 
43833:   nsresult rv;
43833:   mOwner = aOwner;
43833: 
43833:   if (mOwner->mSecure) {
70220:     mWebSocketProtocol =
70220:       do_CreateInstance("@mozilla.org/network/protocol;1?name=wss", &rv);
43833:   }
70220:   else {
70220:     mWebSocketProtocol =
70220:       do_CreateInstance("@mozilla.org/network/protocol;1?name=ws", &rv);
70220:   }
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833:   
70220:   rv = mWebSocketProtocol->SetNotificationCallbacks(this);
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
70220:   // add ourselves to the document's load group and
70220:   // provide the http stack the loadgroup info too
43833:   nsCOMPtr<nsILoadGroup> loadGroup;
43833:   rv = GetLoadGroup(getter_AddRefs(loadGroup));
70220:   if (loadGroup) {
70220:     rv = mWebSocketProtocol->SetLoadGroup(loadGroup);
43833:     NS_ENSURE_SUCCESS(rv, rv);
43833:     rv = loadGroup->AddRequest(this, nsnull);
43833:     NS_ENSURE_SUCCESS(rv, rv);
43833:   }
43833: 
70220:   if (!mOwner->mProtocol.IsEmpty())
70220:     rv = mWebSocketProtocol->SetProtocol(mOwner->mProtocol);
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
70220:   nsCString utf8Origin;
70220:   CopyUTF16toUTF8(mOwner->mUTF16Origin, utf8Origin);
70220:   rv = mWebSocketProtocol->AsyncOpen(mOwner->mURI,
70220:                                      utf8Origin, this, nsnull);
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
43833:   return NS_OK;
43833: }
43833: 
43833: nsresult
43833: nsWebSocketEstablishedConnection::PrintErrorOnConsole(const char *aBundleURI,
43833:                                                       const PRUnichar *aError,
43833:                                                       const PRUnichar **aFormatStrings,
43833:                                                       PRUint32 aFormatStringsLen)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
71437:   NS_ABORT_IF_FALSE(mOwner, "No owner");
43833: 
43833:   nsresult rv;
43833: 
43833:   nsCOMPtr<nsIStringBundleService> bundleService =
43833:     do_GetService(NS_STRINGBUNDLE_CONTRACTID, &rv);
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
43833:   nsCOMPtr<nsIStringBundle> strBundle;
43833:   rv = bundleService->CreateBundle(aBundleURI, getter_AddRefs(strBundle));
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
43833:   nsCOMPtr<nsIConsoleService> console(
43833:     do_GetService(NS_CONSOLESERVICE_CONTRACTID, &rv));
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
59557:   nsCOMPtr<nsIScriptError2> errorObject(
59557:     do_CreateInstance(NS_SCRIPTERROR_CONTRACTID, &rv));
59557:   NS_ENSURE_SUCCESS(rv, rv);
59557: 
43833:   // Localize the error message
43833:   nsXPIDLString message;
43833:   if (aFormatStrings) {
43833:     rv = strBundle->FormatStringFromName(aError, aFormatStrings,
43833:                                          aFormatStringsLen,
43833:                                          getter_Copies(message));
43833:   } else {
43833:     rv = strBundle->GetStringFromName(aError, getter_Copies(message));
43833:   }
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
59557:   errorObject->InitWithWindowID
59557:     (message.get(),
59557:      NS_ConvertUTF8toUTF16(mOwner->GetScriptFile()).get(),
59557:      nsnull,
59557:      mOwner->GetScriptLine(), 0, nsIScriptError::errorFlag,
59557:      "Web Socket", mOwner->WindowID()
59557:      );
59557:   
43833:   // print the error message directly to the JS console
59557:   nsCOMPtr<nsIScriptError> logError(do_QueryInterface(errorObject));
59557:   rv = console->LogMessage(logError);
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
43833:   return NS_OK;
43833: }
43833: 
70220: // when this is called the browser side wants no more part of it
70220: nsresult
70220: nsWebSocketEstablishedConnection::Close()
43834: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
71437:   if (!mOwner)
71437:     return NS_OK;
43834: 
46320:   // Disconnect() can release this object, so we keep a
46320:   // reference until the end of the method
46320:   nsRefPtr<nsWebSocketEstablishedConnection> kungfuDeathGrip = this;
46320: 
43834:   if (mOwner->mReadyState == nsIWebSocket::CONNECTING) {
46983:     mOwner->SetReadyState(nsIWebSocket::CLOSING);
46983:     mOwner->SetReadyState(nsIWebSocket::CLOSED);
43834:     Disconnect();
70220:     return NS_OK;
43834:   }
43834: 
43834:   mOwner->SetReadyState(nsIWebSocket::CLOSING);
43834: 
43834:   if (mStatus == CONN_CLOSED) {
43834:     mOwner->SetReadyState(nsIWebSocket::CLOSED);
43834:     Disconnect();
70220:     return NS_OK;
43834:   }
43834: 
70220:   return mWebSocketProtocol->Close();
43834: }
43834: 
70220: nsresult
70220: nsWebSocketEstablishedConnection::ConsoleError()
43834: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833:   nsresult rv;
70220:   if (!mOwner) return NS_OK;
43833:   
43833:   nsCAutoString targetSpec;
43833:   rv = mOwner->mURI->GetSpec(targetSpec);
70220:   if (NS_FAILED(rv)) {
70220:     NS_WARNING("Failed to get targetSpec");
70220:   } else {
43833:     NS_ConvertUTF8toUTF16 specUTF16(targetSpec);
43833:     const PRUnichar *formatStrings[] = { specUTF16.get() };
43833:     
43833:     if (mStatus < CONN_CONNECTED_AND_READY) {
70220:       PrintErrorOnConsole("chrome://global/locale/appstrings.properties",
43833:                           NS_LITERAL_STRING("connectionFailure").get(),
43833:                           formatStrings, NS_ARRAY_LENGTH(formatStrings));
43833:     } else {
70220:       PrintErrorOnConsole("chrome://global/locale/appstrings.properties",
43833:                           NS_LITERAL_STRING("netInterrupt").get(),
43833:                           formatStrings, NS_ARRAY_LENGTH(formatStrings));
43833:     }
43833:   }
70220:   /// todo some sepcific errors - like for message too large
70220:   return rv;
70220: }
70220: 
70220: 
70220: nsresult
70220: nsWebSocketEstablishedConnection::FailConnection()
70220: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
70220:   nsresult rv = ConsoleError();
70220:   Close();
70220:   return rv;
70220: }
43833: 
43833: nsresult
43833: nsWebSocketEstablishedConnection::Disconnect()
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833: 
43833:   if (!mOwner) {
43833:     return NS_OK;
43833:   }
43833:   
70220:   nsCOMPtr<nsILoadGroup> loadGroup;
70220:   GetLoadGroup(getter_AddRefs(loadGroup));
70220:   if (loadGroup)
70220:     loadGroup->RemoveRequest(this, nsnull, NS_OK);
54462: 
46320:   // If mOwner is deleted when calling mOwner->DontKeepAliveAnyMore()
46320:   // then this method can be called again, and we will get a deadlock.
46320:   nsRefPtr<nsWebSocket> kungfuDeathGrip = mOwner;
46320:   
46320:   mOwner->DontKeepAliveAnyMore();
43833:   mStatus = CONN_CLOSED;
43833:   mOwner = nsnull;
70220:   mWebSocketProtocol = nsnull;
43833: 
43833:   nsLayoutStatics::Release();
43833:   return NS_OK;
43833: }
43833: 
70220: nsresult
70220: nsWebSocketEstablishedConnection::UpdateMustKeepAlive()
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
71437:   NS_ABORT_IF_FALSE(mOwner, "No owner");
71437: 
48067:   mOwner->UpdateMustKeepAlive();
43833:   return NS_OK;
43833: }
43833: 
43833: //-----------------------------------------------------------------------------
70220: // nsWebSocketEstablishedConnection::nsIWebSocketListener methods:
43833: //-----------------------------------------------------------------------------
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::OnMessageAvailable(nsISupports *aContext,
70220:                                                      const nsACString & aMsg)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
70220:   if (!mOwner)
70220:     return NS_ERROR_NOT_AVAILABLE;
43833:   
70220:   // Dispatch New Message
70220:   nsresult rv = mOwner->CreateAndDispatchMessageEvent(aMsg);
70220:   if (NS_FAILED(rv)) {
70220:     NS_WARNING("Failed to dispatch the message event");
43833:   }
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::OnBinaryMessageAvailable(
70220:   nsISupports *aContext,
70220:   const nsACString & aMsg)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
70220:   return NS_ERROR_NOT_IMPLEMENTED;
43833: }
43833: 
70220: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::OnStart(nsISupports *aContext)
70220: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
70220:   if (!mOwner)
70220:     return NS_OK;
70220: 
70220:   if (!mOwner->mProtocol.IsEmpty())
70220:     mWebSocketProtocol->GetProtocol(mOwner->mProtocol);
70220: 
70220:   mStatus = CONN_CONNECTED_AND_READY;
70220:   mOwner->SetReadyState(nsIWebSocket::OPEN);
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::OnStop(nsISupports *aContext,
70220:                                          nsresult aStatusCode)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
70220:   if (!mOwner)
70220:     return NS_OK;
70220: 
70220:   mClosedCleanly = NS_SUCCEEDED(aStatusCode);
70220: 
70220:   if (aStatusCode == NS_BASE_STREAM_CLOSED && 
70220:       mOwner->mReadyState >= nsIWebSocket::CLOSING) {
70220:     // don't generate an error event just because of an unclean close
70220:     aStatusCode = NS_OK;
43833:   }
70220: 
70220:   if (NS_FAILED(aStatusCode)) {
70220:     ConsoleError();
70220:     if (mOwner && mOwner->mReadyState != nsIWebSocket::CONNECTING) {
70220:       nsresult rv =
70220:         mOwner->CreateAndDispatchSimpleEvent(NS_LITERAL_STRING("error"));
70220:       if (NS_FAILED(rv))
70220:         NS_WARNING("Failed to dispatch the error event");
70220:     }
70220:   }
70220: 
70220:   mStatus = CONN_CLOSED;
70220:   if (mOwner) {
70220:     mOwner->SetReadyState(nsIWebSocket::CLOSED);
70220:     Disconnect();
70220:   }
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::OnAcknowledge(nsISupports *aContext,
70220:                                                 PRUint32 aSize)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833: 
70220:   if (aSize > mOutgoingBufferedAmount)
70220:     return NS_ERROR_UNEXPECTED;
70220:   
70220:   mOutgoingBufferedAmount -= aSize;
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::OnServerClose(nsISupports *aContext)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833: 
70220:   Close();                                        /* reciprocate! */
43833:   return NS_OK;
43833: }
43833: 
43833: //-----------------------------------------------------------------------------
43833: // nsWebSocketEstablishedConnection::nsIInterfaceRequestor
43833: //-----------------------------------------------------------------------------
43833: 
43833: NS_IMETHODIMP
43833: nsWebSocketEstablishedConnection::GetInterface(const nsIID &aIID,
43833:                                                void **aResult)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833: 
71437:   if (!mOwner)
71437:     return NS_ERROR_FAILURE;
71437: 
43833:   if (aIID.Equals(NS_GET_IID(nsIAuthPrompt)) ||
43833:       aIID.Equals(NS_GET_IID(nsIAuthPrompt2))) {
43833:     nsresult rv;
43833: 
43833:     nsCOMPtr<nsIDocument> doc =
43833:       nsContentUtils::GetDocumentFromScriptContext(mOwner->mScriptContext);
43833: 
43833:     if (!doc) {
43833:       return NS_ERROR_NOT_AVAILABLE;
43833:     }
43833: 
43833:     nsCOMPtr<nsIPromptFactory> wwatch =
43833:       do_GetService(NS_WINDOWWATCHER_CONTRACTID, &rv);
43833:     NS_ENSURE_SUCCESS(rv, rv);
43833: 
43833:     nsCOMPtr<nsPIDOMWindow> outerWindow = doc->GetWindow();
43833:     return wwatch->GetPrompt(outerWindow, aIID, aResult);
43833:   }
43833: 
43833:   return NS_ERROR_UNEXPECTED;
43833: }
43833: 
43833: ////////////////////////////////////////////////////////////////////////////////
43833: // nsWebSocket
43833: ////////////////////////////////////////////////////////////////////////////////
43833: 
48067: nsWebSocket::nsWebSocket() : mKeepingAlive(PR_FALSE),
48067:                              mCheckMustKeepAlive(PR_TRUE),
48067:                              mTriggeredCloseEvent(PR_FALSE),
46320:                              mReadyState(nsIWebSocket::CONNECTING),
59557:                              mOutgoingBufferedAmount(0),
59557:                              mScriptLine(0),
59557:                              mWindowID(0)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833: }
43833: 
43833: nsWebSocket::~nsWebSocket()
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
46320:   if (mConnection) {
46320:     mConnection->Disconnect();
46320:     mConnection = nsnull;
46320:   }
43833:   if (mListenerManager) {
43833:     mListenerManager->Disconnect();
43833:     mListenerManager = nsnull;
43833:   }
43833: }
43833: 
43833: NS_IMPL_CYCLE_COLLECTION_CLASS(nsWebSocket)
43833: 
43833: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsWebSocket,
43833:                                                   nsDOMEventTargetWrapperCache)
43833:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnOpenListener)
43833:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnMessageListener)
43833:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnCloseListener)
43841:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mOnErrorListener)
43833:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrincipal)
43833:   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mURI)
43833:   NS_CYCLE_COLLECTION_NOTE_EDGE_NAME(cb, "mConnection");
43833:   cb.NoteXPCOMChild(static_cast<nsIInterfaceRequestor*>(tmp->mConnection));
43833: NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
43833: 
43833: NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsWebSocket,
43833:                                                 nsDOMEventTargetWrapperCache)
46320:   if (tmp->mConnection) {
46320:     tmp->mConnection->Disconnect();
46320:     tmp->mConnection = nsnull;
46320:   }
43833:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnOpenListener)
43833:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnMessageListener)
43833:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnCloseListener)
43841:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mOnErrorListener)
43833:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrincipal)
43833:   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mURI)
43833: NS_IMPL_CYCLE_COLLECTION_UNLINK_END
43833: 
43833: DOMCI_DATA(WebSocket, nsWebSocket)
43833: 
43833: NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(nsWebSocket)
43833:   NS_INTERFACE_MAP_ENTRY(nsIWebSocket)
43833:   NS_INTERFACE_MAP_ENTRY(nsIJSNativeInitializer)
43833:   NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(WebSocket)
43833: NS_INTERFACE_MAP_END_INHERITING(nsDOMEventTargetWrapperCache)
43833: 
43833: NS_IMPL_ADDREF_INHERITED(nsWebSocket, nsDOMEventTargetWrapperCache)
43833: NS_IMPL_RELEASE_INHERITED(nsWebSocket, nsDOMEventTargetWrapperCache)
43833: 
43833: //-----------------------------------------------------------------------------
43833: // nsWebSocket::nsIJSNativeInitializer methods:
43833: //-----------------------------------------------------------------------------
43833: 
43833: /**
43833:  * This Initialize method is called from XPConnect via nsIJSNativeInitializer.
43833:  * It is used for constructing our nsWebSocket from JavaScript. It expects a URL
43833:  * string parameter and an optional protocol parameter. It also initializes the
43833:  * principal, the script context and the window owner.
43833:  */
43833: NS_IMETHODIMP
43833: nsWebSocket::Initialize(nsISupports* aOwner,
43834:                         JSContext* aContext,
43834:                         JSObject* aObject,
43834:                         PRUint32 aArgc,
43834:                         jsval* aArgv)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833:   nsAutoString urlParam, protocolParam;
43833: 
58905:   if (!PrefEnabled()) {
43833:     return NS_ERROR_DOM_SECURITY_ERR;
43833:   }
43833: 
43834:   if (aArgc != 1 && aArgc != 2) {
43833:     return NS_ERROR_DOM_SYNTAX_ERR;
43833:   }
43833: 
43834:   JSAutoRequest ar(aContext);
43834: 
43834:   JSString* jsstr = JS_ValueToString(aContext, aArgv[0]);
43833:   if (!jsstr) {
43833:     return NS_ERROR_DOM_SYNTAX_ERR;
43833:   }
59889: 
69423:   JS::Anchor<JSString *> deleteProtector(jsstr);
59889:   size_t length;
59889:   const jschar *chars = JS_GetStringCharsAndLength(aContext, jsstr, &length);
59889:   if (!chars) {
59889:     return NS_ERROR_OUT_OF_MEMORY;
59889:   }
59889: 
59889:   urlParam.Assign(chars, length);
69423:   deleteProtector.clear();
43833: 
43834:   if (aArgc == 2) {
43834:     jsstr = JS_ValueToString(aContext, aArgv[1]);
43833:     if (!jsstr) {
43833:       return NS_ERROR_DOM_SYNTAX_ERR;
43833:     }
59889: 
69423:     deleteProtector.set(jsstr);
59889:     chars = JS_GetStringCharsAndLength(aContext, jsstr, &length);
59889:     if (!chars) {
59889:       return NS_ERROR_OUT_OF_MEMORY;
59889:     }
59889: 
59889:     protocolParam.Assign(chars, length);
43840:     if (protocolParam.IsEmpty()) {
43840:       return NS_ERROR_DOM_SYNTAX_ERR;
43840:     }
43833:   }
43833: 
43833:   nsCOMPtr<nsPIDOMWindow> ownerWindow = do_QueryInterface(aOwner);
43833:   NS_ENSURE_STATE(ownerWindow);
43833: 
43833:   nsCOMPtr<nsIScriptGlobalObject> sgo = do_QueryInterface(aOwner);
43833:   NS_ENSURE_STATE(sgo);
43833:   nsCOMPtr<nsIScriptContext> scriptContext = sgo->GetContext();
43833:   NS_ENSURE_STATE(scriptContext);
43833: 
43833:   nsCOMPtr<nsIScriptObjectPrincipal> scriptPrincipal(do_QueryInterface(aOwner));
43833:   NS_ENSURE_STATE(scriptPrincipal);
43833:   nsCOMPtr<nsIPrincipal> principal = scriptPrincipal->GetPrincipal();
43833:   NS_ENSURE_STATE(principal);
43833: 
43833:   return Init(principal, scriptContext, ownerWindow, urlParam, protocolParam);
43833: }
43833: 
43833: //-----------------------------------------------------------------------------
43833: // nsWebSocket methods:
43833: //-----------------------------------------------------------------------------
43833: 
43833: nsresult
43833: nsWebSocket::EstablishConnection()
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
70220:   NS_ABORT_IF_FALSE(!mConnection, "mConnection should be null");
43833: 
43833:   nsresult rv;
43833: 
43833:   nsRefPtr<nsWebSocketEstablishedConnection> conn =
43833:     new nsWebSocketEstablishedConnection();
43833: 
43833:   rv = conn->Init(this);
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
43833:   mConnection = conn;
43833: 
43833:   return NS_OK;
43833: }
43833: 
43834: class nsWSCloseEvent : public nsRunnable
43834: {
43834: public:
43834:   nsWSCloseEvent(nsWebSocket *aWebSocket, PRBool aWasClean)
43834:     : mWebSocket(aWebSocket),
43834:       mWasClean(aWasClean)
43834:   {}
43834: 
43834:   NS_IMETHOD Run()
43834:   {
46320:     nsresult rv = mWebSocket->CreateAndDispatchCloseEvent(mWasClean);
46320:     mWebSocket->UpdateMustKeepAlive();
46320:     return rv;
43834:   }
43834: 
43834: private:
43834:   nsRefPtr<nsWebSocket> mWebSocket;
43834:   PRBool mWasClean;
43834: };
43834: 
43833: nsresult
43834: nsWebSocket::CreateAndDispatchSimpleEvent(const nsString& aName)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833:   nsresult rv;
43833: 
43833:   rv = CheckInnerWindowCorrectness();
43834:   if (NS_FAILED(rv)) {
43833:     return NS_OK;
43833:   }
43833: 
43833:   nsCOMPtr<nsIDOMEvent> event;
43833:   rv = NS_NewDOMEvent(getter_AddRefs(event), nsnull, nsnull);
43834:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
43833:   // it doesn't bubble, and it isn't cancelable
43834:   rv = event->InitEvent(aName, PR_FALSE, PR_FALSE);
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
43833:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(event);
43833:   rv = privateEvent->SetTrusted(PR_TRUE);
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
43834:   return DispatchDOMEvent(nsnull, event, nsnull, nsnull);
43834: }
43834: 
43834: nsresult
70220: nsWebSocket::CreateAndDispatchMessageEvent(const nsACString& aData)
43834: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43834:   nsresult rv;
43834:   
43834:   rv = CheckInnerWindowCorrectness();
43834:   if (NS_FAILED(rv)) {
43833:     return NS_OK;
43833:   }
43833: 
70373:   // Let's play get the JSContext
70373:   nsCOMPtr<nsIScriptGlobalObject> sgo = do_QueryInterface(mOwner);
70373:   NS_ENSURE_TRUE(sgo, NS_ERROR_FAILURE);
70373: 
70373:   nsIScriptContext* scriptContext = sgo->GetContext();
70373:   NS_ENSURE_TRUE(scriptContext, NS_ERROR_FAILURE);
70373: 
70373:   JSContext* cx = (JSContext*)scriptContext->GetNativeContext();
70373:   NS_ENSURE_TRUE(cx, NS_ERROR_FAILURE);
70373: 
70373:   // Now we can turn our string into a jsval
70373: 
70373:   jsval jsData;
70373:   {
70373:     NS_ConvertUTF8toUTF16 utf16Data(aData);
70373:     JSString* jsString;
70373:     JSAutoRequest ar(cx);
70373:     jsString = JS_NewUCStringCopyN(cx,
70373:                                    utf16Data.get(),
70373:                                    utf16Data.Length());
70373:     NS_ENSURE_TRUE(jsString, NS_ERROR_FAILURE);
70373: 
70373:     jsData = STRING_TO_JSVAL(jsString);
70373:   }
70373: 
43834:   // create an event that uses the MessageEvent interface,
43834:   // which does not bubble, is not cancelable, and has no default action
43834: 
43834:   nsCOMPtr<nsIDOMEvent> event;
43834:   rv = NS_NewDOMMessageEvent(getter_AddRefs(event), nsnull, nsnull);
43834:   NS_ENSURE_SUCCESS(rv, rv);
43834: 
43834:   nsCOMPtr<nsIDOMMessageEvent> messageEvent = do_QueryInterface(event);
43834:   rv = messageEvent->InitMessageEvent(NS_LITERAL_STRING("message"),
43834:                                       PR_FALSE, PR_FALSE,
70373:                                       jsData,
70220:                                       mUTF16Origin,
43834:                                       EmptyString(), nsnull);
43834:   NS_ENSURE_SUCCESS(rv, rv);
43834: 
43834:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(event);
43834:   rv = privateEvent->SetTrusted(PR_TRUE);
43834:   NS_ENSURE_SUCCESS(rv, rv);
43834: 
43834:   return DispatchDOMEvent(nsnull, event, nsnull, nsnull);
43834: }
43834: 
43834: nsresult
43834: nsWebSocket::CreateAndDispatchCloseEvent(PRBool aWasClean)
43834: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43834:   nsresult rv;
43834: 
48067:   mTriggeredCloseEvent = PR_TRUE;
48067: 
43834:   rv = CheckInnerWindowCorrectness();
43834:   if (NS_FAILED(rv)) {
43834:     return NS_OK;
43834:   }
43834: 
43834:   // create an event that uses the CloseEvent interface,
43834:   // which does not bubble, is not cancelable, and has no default action
43834: 
43834:   nsCOMPtr<nsIDOMEvent> event;
43834:   rv = NS_NewDOMCloseEvent(getter_AddRefs(event), nsnull, nsnull);
43834:   NS_ENSURE_SUCCESS(rv, rv);
43834: 
43834:   nsCOMPtr<nsIDOMCloseEvent> closeEvent = do_QueryInterface(event);
43834:   rv = closeEvent->InitCloseEvent(NS_LITERAL_STRING("close"),
43834:                                   PR_FALSE, PR_FALSE,
43834:                                   aWasClean);
43834:   NS_ENSURE_SUCCESS(rv, rv);
43834: 
43834:   nsCOMPtr<nsIPrivateDOMEvent> privateEvent = do_QueryInterface(event);
43834:   rv = privateEvent->SetTrusted(PR_TRUE);
43834:   NS_ENSURE_SUCCESS(rv, rv);
43834: 
43834:   return DispatchDOMEvent(nsnull, event, nsnull, nsnull);
43834: }
43834: 
58905: PRBool
58905: nsWebSocket::PrefEnabled()
58905: {
70840:   return Preferences::GetBool("network.websocket.enabled", PR_TRUE);
58905: }
58905: 
43834: void
43834: nsWebSocket::SetReadyState(PRUint16 aNewReadyState)
43834: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43834:   nsresult rv;
43834: 
43834:   if (mReadyState == aNewReadyState) {
43834:     return;
43834:   }
43834: 
70220:   NS_ABORT_IF_FALSE((aNewReadyState == nsIWebSocket::OPEN)    ||
43834:                     (aNewReadyState == nsIWebSocket::CLOSING) ||
43834:                     (aNewReadyState == nsIWebSocket::CLOSED),
43834:                     "unexpected readyState");
43834: 
43834:   if (aNewReadyState == nsIWebSocket::OPEN) {
70220:     NS_ABORT_IF_FALSE(mReadyState == nsIWebSocket::CONNECTING,
43834:                       "unexpected readyState transition");
43834:     mReadyState = aNewReadyState;
43834: 
43834:     rv = CreateAndDispatchSimpleEvent(NS_LITERAL_STRING("open"));
43834:     if (NS_FAILED(rv)) {
43834:       NS_WARNING("Failed to dispatch the open event");
43834:     }
46320:     UpdateMustKeepAlive();
43834:     return;
43834:   }
43834: 
43834:   if (aNewReadyState == nsIWebSocket::CLOSING) {
70220:     NS_ABORT_IF_FALSE((mReadyState == nsIWebSocket::CONNECTING) ||
43834:                       (mReadyState == nsIWebSocket::OPEN),
43834:                       "unexpected readyState transition");
43834:     mReadyState = aNewReadyState;
43834:     return;
43834:   }
43834: 
43834:   if (aNewReadyState == nsIWebSocket::CLOSED) {
43834:     mReadyState = aNewReadyState;
43834: 
70220:     if (mConnection) {
43834:       // The close event must be dispatched asynchronously.
43834:       nsCOMPtr<nsIRunnable> event =
43834:         new nsWSCloseEvent(this, mConnection->ClosedCleanly());
43834:       mOutgoingBufferedAmount += mConnection->GetOutgoingBufferedAmount();
43834:       mConnection = nsnull; // this is no longer necessary
43834: 
43834:       rv = NS_DispatchToMainThread(event, NS_DISPATCH_NORMAL);
43834:       if (NS_FAILED(rv)) {
43834:         NS_WARNING("Failed to dispatch the close event");
48067:         mTriggeredCloseEvent = PR_TRUE;
46320:         UpdateMustKeepAlive();
43834:       }
43834:     }
43834:   }
70220: }
43834: 
43833: nsresult
43833: nsWebSocket::ParseURL(const nsString& aURL)
43833: {
43833:   nsresult rv;
43833: 
43833:   NS_ENSURE_TRUE(!aURL.IsEmpty(), NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   nsCOMPtr<nsIURI> uri;
43833:   rv = NS_NewURI(getter_AddRefs(uri), aURL);
43833:   NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   nsCOMPtr<nsIURL> parsedURL(do_QueryInterface(uri, &rv));
43833:   NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   nsCAutoString fragment;
43833:   rv = parsedURL->GetRef(fragment);
43833:   NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && fragment.IsEmpty(),
43833:                  NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   nsCAutoString scheme;
43833:   rv = parsedURL->GetScheme(scheme);
43833:   NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && !scheme.IsEmpty(),
43833:                  NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   nsCAutoString host;
43833:   rv = parsedURL->GetAsciiHost(host);
43833:   NS_ENSURE_TRUE(NS_SUCCEEDED(rv) && !host.IsEmpty(), NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   PRInt32 port;
43833:   rv = parsedURL->GetPort(&port);
43833:   NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   rv = NS_CheckPortSafety(port, scheme.get());
43833:   NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   nsCAutoString filePath;
43833:   rv = parsedURL->GetFilePath(filePath);
43833:   if (filePath.IsEmpty()) {
43833:     filePath.AssignLiteral("/");
43833:   }
43833:   NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   nsCAutoString query;
43833:   rv = parsedURL->GetQuery(query);
43833:   NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   nsXPIDLCString origin;
43833:   rv = mPrincipal->GetOrigin(getter_Copies(origin));
43833:   NS_ENSURE_SUCCESS(rv, NS_ERROR_DOM_SYNTAX_ERR);
43833: 
43833:   if (scheme.LowerCaseEqualsLiteral("ws")) {
43833:      mSecure = PR_FALSE;
43833:      mPort = (port == -1) ? DEFAULT_WS_SCHEME_PORT : port;
43833:   } else if (scheme.LowerCaseEqualsLiteral("wss")) {
43833:     mSecure = PR_TRUE;
43833:     mPort = (port == -1) ? DEFAULT_WSS_SCHEME_PORT : port;
43833:   } else {
43833:     return NS_ERROR_DOM_SYNTAX_ERR;
43833:   }
43833: 
70220:   ToLowerCase(origin);
70220:   CopyUTF8toUTF16(origin, mUTF16Origin);
43833:     
43833:   mAsciiHost = host;
43833:   ToLowerCase(mAsciiHost);
43833: 
43833:   mResource = filePath;
43833:   if (!query.IsEmpty()) {
43833:     mResource.AppendLiteral("?");
43833:     mResource.Append(query);
43833:   }
43833:   PRUint32 length = mResource.Length();
43833:   PRUint32 i;
43833:   for (i = 0; i < length; ++i) {
43833:     if (mResource[i] < static_cast<PRUnichar>(0x0021) ||
43833:         mResource[i] > static_cast<PRUnichar>(0x007E)) {
43833:       return NS_ERROR_DOM_SYNTAX_ERR;
43833:     }
43833:   }
43833: 
43833:   mOriginalURL = aURL;
43833:   mURI = parsedURL;
43833:   return NS_OK;
43833: }
43833: 
43833: nsresult
43833: nsWebSocket::SetProtocol(const nsString& aProtocol)
43833: {
43833:   if (aProtocol.IsEmpty()) {
43833:     return NS_ERROR_DOM_SYNTAX_ERR;
43833:   }
43833: 
43833:   PRUint32 length = aProtocol.Length();
43833:   PRUint32 i;
43833:   for (i = 0; i < length; ++i) {
43833:     if (aProtocol[i] < static_cast<PRUnichar>(0x0020) ||
43833:         aProtocol[i] > static_cast<PRUnichar>(0x007E)) {
43833:       return NS_ERROR_DOM_SYNTAX_ERR;
43833:     }
43833:   }
43833: 
43833:   CopyUTF16toUTF8(aProtocol, mProtocol);
43833:   return NS_OK;
43833: }
43833: 
43833: //-----------------------------------------------------------------------------
48067: // Methods that keep alive the WebSocket object when:
48067: //   1. the object has registered event listeners that can be triggered
48067: //      ("strong event listeners");
48067: //   2. there are outgoing not sent messages.
46320: //-----------------------------------------------------------------------------
46320: 
46320: void
46320: nsWebSocket::UpdateMustKeepAlive()
46320: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
48067:   if (!mCheckMustKeepAlive) {
46320:     return;
46320:   }
46320: 
48067:   PRBool shouldKeepAlive = PR_FALSE;
48067: 
48067:   if (mListenerManager) {
48067:     switch (mReadyState)
48067:     {
48067:       case nsIWebSocket::CONNECTING:
48067:       {
48067:         if (mListenerManager->HasListenersFor(NS_LITERAL_STRING("open")) ||
48067:             mListenerManager->HasListenersFor(NS_LITERAL_STRING("message")) ||
48067:             mListenerManager->HasListenersFor(NS_LITERAL_STRING("close"))) {
48067:           shouldKeepAlive = PR_TRUE;
48067:         }
48067:       }
48067:       break;
48067: 
48067:       case nsIWebSocket::OPEN:
48067:       case nsIWebSocket::CLOSING:
48067:       {
48067:         if (mListenerManager->HasListenersFor(NS_LITERAL_STRING("message")) ||
48067:             mListenerManager->HasListenersFor(NS_LITERAL_STRING("close")) ||
48067:             mConnection->HasOutgoingMessages()) {
48067:           shouldKeepAlive = PR_TRUE;
48067:         }
48067:       }
48067:       break;
48067: 
48067:       case nsIWebSocket::CLOSED:
48067:       {
48067:         shouldKeepAlive =
48067:           (!mTriggeredCloseEvent &&
48067:            mListenerManager->HasListenersFor(NS_LITERAL_STRING("close")));
48067:       }
48067:     }
48067:   }
48067: 
48067:   if (mKeepingAlive && !shouldKeepAlive) {
48067:     mKeepingAlive = PR_FALSE;
46320:     static_cast<nsPIDOMEventTarget*>(this)->Release();
48067:   } else if (!mKeepingAlive && shouldKeepAlive) {
48067:     mKeepingAlive = PR_TRUE;
46320:     static_cast<nsPIDOMEventTarget*>(this)->AddRef();
46320:   }
46320: }
46320: 
46320: void
46320: nsWebSocket::DontKeepAliveAnyMore()
46320: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
48067:   if (mKeepingAlive) {
48067:     mKeepingAlive = PR_FALSE;
46320:     static_cast<nsPIDOMEventTarget*>(this)->Release();
46320:   }
48067:   mCheckMustKeepAlive = PR_FALSE;
46320: }
46320: 
46320: NS_IMETHODIMP
46320: nsWebSocket::AddEventListener(const nsAString& aType,
46320:                               nsIDOMEventListener* aListener,
46320:                               PRBool aUseCapture)
46320: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
46320:   nsresult rv = nsDOMEventTargetHelper::AddEventListener(aType,
46320:                                                          aListener,
46320:                                                          aUseCapture);
46320:   if (NS_SUCCEEDED(rv)) {
46320:     UpdateMustKeepAlive();
46320:   }
46320:   return rv;
46320: }
46320: 
46320: NS_IMETHODIMP
46320: nsWebSocket::RemoveEventListener(const nsAString& aType,
46320:                                  nsIDOMEventListener* aListener,
46320:                                  PRBool aUseCapture)
46320: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
46320:   nsresult rv = nsDOMEventTargetHelper::RemoveEventListener(aType,
46320:                                                             aListener,
46320:                                                             aUseCapture);
46320:   if (NS_SUCCEEDED(rv)) {
46320:     UpdateMustKeepAlive();
46320:   }
46320:   return rv;
46320: }
46320: 
46320: NS_IMETHODIMP
46320: nsWebSocket::AddEventListener(const nsAString& aType,
46320:                               nsIDOMEventListener *aListener,
46320:                               PRBool aUseCapture,
46320:                               PRBool aWantsUntrusted,
46320:                               PRUint8 optional_argc)
46320: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
46320:   nsresult rv = nsDOMEventTargetHelper::AddEventListener(aType,
46320:                                                          aListener,
46320:                                                          aUseCapture,
46320:                                                          aWantsUntrusted,
46320:                                                          optional_argc);
46320:   if (NS_SUCCEEDED(rv)) {
46320:     UpdateMustKeepAlive();
46320:   }
46320:   return rv;
46320: }
46320: 
46320: //-----------------------------------------------------------------------------
43833: // nsWebSocket::nsIWebSocket methods:
43833: //-----------------------------------------------------------------------------
43833: 
43833: NS_IMETHODIMP
43907: nsWebSocket::GetUrl(nsAString& aURL)
43833: {
43833:   aURL = mOriginalURL;
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocket::GetProtocol(nsAString& aProtocol)
70220: {
70220:   CopyUTF8toUTF16(mProtocol, aProtocol);
70220:   return NS_OK;
70220: }
70220: 
70220: NS_IMETHODIMP
43834: nsWebSocket::GetReadyState(PRUint16 *aReadyState)
43833: {
43833:   *aReadyState = mReadyState;
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
43833: nsWebSocket::GetBufferedAmount(PRUint32 *aBufferedAmount)
43833: {
43833:   if (!mConnection) {
43833:     *aBufferedAmount = mOutgoingBufferedAmount;
43833:   } else {
43833:     *aBufferedAmount = mConnection->GetOutgoingBufferedAmount();
43833:   }
43833:   return NS_OK;
43833: }
43833: 
43833: #define NS_WEBSOCKET_IMPL_DOMEVENTLISTENER(_eventlistenername, _eventlistener) \
43833:   NS_IMETHODIMP                                                                \
43833:   nsWebSocket::GetOn##_eventlistenername(nsIDOMEventListener * *aEventListener)\
43833:   {                                                                            \
43833:     return GetInnerEventListener(_eventlistener, aEventListener);              \
43833:   }                                                                            \
43833:                                                                                \
43833:   NS_IMETHODIMP                                                                \
43833:   nsWebSocket::SetOn##_eventlistenername(nsIDOMEventListener * aEventListener) \
43833:   {                                                                            \
43833:     return RemoveAddEventListener(NS_LITERAL_STRING(#_eventlistenername),      \
43833:                                   _eventlistener, aEventListener);             \
43833:   }
43833: 
43833: NS_WEBSOCKET_IMPL_DOMEVENTLISTENER(open, mOnOpenListener)
43834: NS_WEBSOCKET_IMPL_DOMEVENTLISTENER(error, mOnErrorListener)
43833: NS_WEBSOCKET_IMPL_DOMEVENTLISTENER(message, mOnMessageListener)
43833: NS_WEBSOCKET_IMPL_DOMEVENTLISTENER(close, mOnCloseListener)
43833: 
43833: NS_IMETHODIMP
43833: nsWebSocket::Send(const nsAString& aData, PRBool *aRet)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833:   *aRet = PR_FALSE;
43833: 
43833:   if (mReadyState == nsIWebSocket::CONNECTING) {
43833:     return NS_ERROR_DOM_INVALID_STATE_ERR;
43833:   }
43833: 
43833:   // We need to check if there isn't unpaired surrogates.
43833:   PRUint32 i, length = aData.Length();
43833:   for (i = 0; i < length; ++i) {
43833:     if (NS_IS_LOW_SURROGATE(aData[i])) {
43833:       return NS_ERROR_DOM_SYNTAX_ERR;
43833:     }
43833:     if (NS_IS_HIGH_SURROGATE(aData[i])) {
43833:       if (i + 1 == length || !NS_IS_LOW_SURROGATE(aData[i + 1])) {
43833:         return NS_ERROR_DOM_SYNTAX_ERR;
43833:       }
43833:       ++i;
43833:       continue;
43833:     }
43833:   }
43833: 
43834:   if (mReadyState == nsIWebSocket::CLOSING ||
43834:       mReadyState == nsIWebSocket::CLOSED) {
43833:     mOutgoingBufferedAmount += NS_ConvertUTF16toUTF8(aData).Length();
43833:     return NS_OK;
43833:   }
43833: 
43833:   nsresult rv = mConnection->PostMessage(PromiseFlatString(aData));
43833:   *aRet = NS_SUCCEEDED(rv);
43834: 
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
43833: nsWebSocket::Close()
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43834:   if (mReadyState == nsIWebSocket::CLOSING ||
43834:       mReadyState == nsIWebSocket::CLOSED) {
43833:     return NS_OK;
43833:   }
43833: 
43834:   if (mReadyState == nsIWebSocket::CONNECTING) {
48067:     // FailConnection() can release the object, so we keep a reference
48067:     // before calling it
46320:     nsRefPtr<nsWebSocket> kungfuDeathGrip = this;
46320: 
43834:     mConnection->FailConnection();
43834:     return NS_OK;
43834:   }
43834: 
43834:   // mReadyState == nsIWebSocket::OPEN
43834:   mConnection->Close();
43833: 
43833:   return NS_OK;
43833: }
43833: 
43833: /**
43833:  * This Init method should only be called by C++ consumers.
43833:  */
43833: NS_IMETHODIMP
43833: nsWebSocket::Init(nsIPrincipal* aPrincipal,
43833:                   nsIScriptContext* aScriptContext,
43833:                   nsPIDOMWindow* aOwnerWindow,
43833:                   const nsAString& aURL,
43833:                   const nsAString& aProtocol)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833:   nsresult rv;
43833: 
43833:   NS_ENSURE_ARG(aPrincipal);
43833: 
58905:   if (!PrefEnabled()) {
43833:     return NS_ERROR_DOM_SECURITY_ERR;
43833:   }
43833: 
43833:   mPrincipal = aPrincipal;
43833:   mScriptContext = aScriptContext;
43833:   if (aOwnerWindow) {
54462:     mOwner = aOwnerWindow->IsOuterWindow() ?
54462:       aOwnerWindow->GetCurrentInnerWindow() : aOwnerWindow;
43833:   }
43833:   else {
43833:     mOwner = nsnull;
43833:   }
43833: 
59557:   nsCOMPtr<nsIJSContextStack> stack =
59557:     do_GetService("@mozilla.org/js/xpc/ContextStack;1");
59557:   JSContext* cx = nsnull;
59557:   if (stack && NS_SUCCEEDED(stack->Peek(&cx)) && cx) {
59557:     JSStackFrame *fp = JS_GetScriptedCaller(cx, NULL);
59557:     if (fp) {
59557:       JSScript *script = JS_GetFrameScript(cx, fp);
59557:       if (script) {
59557:         mScriptFile = JS_GetScriptFilename(cx, script);
59557:       }
59557: 
59557:       jsbytecode *pc = JS_GetFramePC(cx, fp);
59557:       if (script && pc) {
59557:         mScriptLine = JS_PCToLineNumber(cx, script, pc);
59557:       }
59557:     }
59557: 
59557:     mWindowID = nsJSUtils::GetCurrentlyRunningCodeWindowID(cx);
59557:   }
59557: 
43833:   // parses the url
43833:   rv = ParseURL(PromiseFlatString(aURL));
43833:   NS_ENSURE_SUCCESS(rv, rv);
43833: 
43833:   // sets the protocol
43833:   if (!aProtocol.IsEmpty()) {
43833:     rv = SetProtocol(PromiseFlatString(aProtocol));
43833:     NS_ENSURE_SUCCESS(rv, rv);
43833:   }
43833: 
43833:   // the constructor should throw a SYNTAX_ERROR only if it fails to parse the
43833:   // url parameter, so we don't care about the EstablishConnection result.
43833:   EstablishConnection();
43833: 
43833:   return NS_OK;
43833: }
43833: 
70220: //-----------------------------------------------------------------------------
70220: // nsWebSocketEstablishedConnection::nsIRequest
70220: //-----------------------------------------------------------------------------
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::GetName(nsACString &aName)
43833: {
70220:   if (!mOwner)
70220:     return NS_ERROR_UNEXPECTED;
70220:   
70220:   CopyUTF16toUTF8(mOwner->mOriginalURL, aName);
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::IsPending(PRBool *aValue)
43833: {
70220:   *aValue = !!(mOwner);
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::GetStatus(nsresult *aStatus)
43833: {
70220:   *aStatus = NS_OK;
43833:   return NS_OK;
43833: }
43833: 
70220: // probably means window went away or stop button pressed
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::Cancel(nsresult aStatus)
43833: {
70220:   NS_ABORT_IF_FALSE(NS_IsMainThread(), "Not running on main thread");
43833: 
70220:   if (!mOwner) {
70220:     return NS_OK;
70220:   }
43833: 
70220:   ConsoleError();
70220:   return Close();
70220: }
43833: 
70220: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::Suspend()
70220: {
70220:   return NS_ERROR_NOT_IMPLEMENTED;
70220: }
70220: 
70220: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::Resume()
70220: {
70220:   return NS_ERROR_NOT_IMPLEMENTED;
70220: }
70220: 
70220: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::GetLoadGroup(nsILoadGroup **aLoadGroup)
70220: {
70220:   *aLoadGroup = nsnull;
70220:   if (!mOwner)
70220:     return NS_OK;
70220: 
70220:   nsCOMPtr<nsIDocument> doc =
70220:     nsContentUtils::GetDocumentFromScriptContext(mOwner->mScriptContext);
70220: 
70220:   if (doc) {
70220:     *aLoadGroup = doc->GetDocumentLoadGroup().get();  // already_AddRefed
70220:   }
43833: 
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::SetLoadGroup(nsILoadGroup *aLoadGroup)
43833: {
70220:   return NS_ERROR_UNEXPECTED;
43833: }
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::GetLoadFlags(nsLoadFlags *aLoadFlags)
43833: {
70220:   *aLoadFlags = nsIRequest::LOAD_BACKGROUND;
43833:   return NS_OK;
43833: }
43833: 
43833: NS_IMETHODIMP
70220: nsWebSocketEstablishedConnection::SetLoadFlags(nsLoadFlags aLoadFlags)
43833: {
70220:   // we won't change the load flags at all.
43833:   return NS_OK;
43833: }
