121471: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
121471: /* vim:set ts=2 sw=2 sts=2 et cindent: */
121471: /* This Source Code Form is subject to the terms of the Mozilla Public
121471:  * License, v. 2.0. If a copy of the MPL was not distributed with this
121471:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
121471: 
121471: /**
121471:  * A common base class for representing WebIDL callback function types in C++.
121471:  *
121471:  * This class implements common functionality like lifetime
121471:  * management, initialization with the callable, and setup of the call
121471:  * environment.  Subclasses corresponding to particular callback
121471:  * function types should provide a Call() method that actually does
121471:  * the call.
121471:  */
121471: 
121471: #pragma once
121471: 
121471: #include "nsISupports.h"
121471: #include "nsISupportsImpl.h"
121471: #include "nsCycleCollectionParticipant.h"
121471: #include "jsapi.h"
121471: #include "jswrapper.h"
121471: #include "mozilla/Assertions.h"
121471: #include "mozilla/Util.h"
121471: #include "nsContentUtils.h"
121471: #include "nsWrapperCache.h"
121471: #include "nsJSEnvironment.h"
121471: #include "xpcpublic.h"
121717: #include "nsLayoutStatics.h"
121471: 
121471: namespace mozilla {
121471: namespace dom {
121471: 
121471: class CallbackFunction : public nsISupports
121471: {
121471: public:
121471:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
121471:   NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(CallbackFunction)
121471: 
121471:   /**
121471:    * Create a CallbackFunction.  aCallable is the callable we're wrapping.
121471:    * aOwner is the object that will be receiving this CallbackFunction as a
121471:    * method argument, if any.  We need this so we can store our callable in the
121471:    * same compartment as our owner.  If *aInited is set to false, an exception
121471:    * has been thrown.
121471:    */
121471:   CallbackFunction(JSContext* cx, JSObject* aOwner, JSObject* aCallable,
121471:                    bool* aInited)
121471:     : mCallable(nullptr)
121471:   {
121471:     MOZ_ASSERT(JS_ObjectIsCallable(cx, aCallable));
121471:     // If aOwner is not null, enter the compartment of aOwner's
121471:     // underlying object.
121471:     if (aOwner) {
121471:       aOwner = js::UnwrapObject(aOwner);
121471:       JSAutoCompartment ac(cx, aOwner);
121471:       if (!JS_WrapObject(cx, &aCallable)) {
121471:         *aInited = false;
121471:         return;
121471:       }
121471:     }
121471: 
121471:     // Set mCallable before we hold, on the off chance that a GC could somehow
121471:     // happen in there... (which would be pretty odd, granted).
121471:     mCallable = aCallable;
121717:     // Make sure we'll be able to drop as needed
121717:     nsLayoutStatics::AddRef();
121471:     NS_HOLD_JS_OBJECTS(this, CallbackFunction);
121471:     *aInited = true;
121471:   }
121471: 
121471:   virtual ~CallbackFunction()
121471:   {
121471:     DropCallback();
121471:   }
121471: 
121471:   JSObject* Callable() const
121471:   {
121471:     xpc_UnmarkGrayObject(mCallable);
121471:     return mCallable;
121471:   }
121471: 
121485:   bool HasGrayCallable() const
121485:   {
121485:     // Play it safe in case this gets called after unlink.
121485:     return mCallable && xpc_IsGrayGCThing(mCallable);
121485:   }
121485: 
121471: protected:
121471:   void DropCallback()
121471:   {
121471:     if (mCallable) {
121471:       NS_DROP_JS_OBJECTS(this, CallbackFunction);
121471:       mCallable = nullptr;
121717:       nsLayoutStatics::Release();
121471:     }
121471:   }
121471: 
121471:   JSObject* mCallable;
121471: 
121471:   class NS_STACK_CLASS CallSetup
121471:   {
121471:     /**
121471:      * A class that performs whatever setup we need to safely make a
121471:      * call while this class is on the stack, After the constructor
121471:      * returns, the call is safe to make if GetContext() returns
121471:      * non-null.
121471:      */
121471:   public:
121471:     CallSetup(JSObject* const aCallable);
121471:     ~CallSetup();
121471: 
121471:     JSContext* GetContext() const
121471:     {
121471:       return mCx;
121471:     }
121471: 
121471:   private:
121471:     // We better not get copy-constructed
121471:     CallSetup(const CallSetup&) MOZ_DELETE;
121471: 
121471:     // Members which can go away whenever
121471:     JSContext* mCx;
121471:     nsCOMPtr<nsIScriptContext> mCtx;
121471: 
121471:     // And now members whose construction/destruction order we need to control.
121471: 
121471:     // Put our nsAutoMicrotask first, so it gets destroyed after everything else
121471:     // is gone
121471:     nsAutoMicroTask mMt;
121471: 
121471:     // Can't construct an XPCAutoRequest until we have a JSContext, so
121471:     // this needs to be a Maybe.
121471:     Maybe<XPCAutoRequest> mAr;
121471: 
121471:     // Can't construct a TerminationFuncHolder without an nsJSContext.  But we
121471:     // generally want its destructor to come after the destructor of mCxPusher.
121471:     Maybe<nsJSContext::TerminationFuncHolder> mTerminationFuncHolder;
121471: 
121471:     nsCxPusher mCxPusher;
121471: 
121471:     // Can't construct a JSAutoCompartment without a JSContext either.  Also,
121471:     // Put mAc after mCxPusher so that we exit the compartment before we pop the
121471:     // JSContext.  Though in practice we'll often manually order those two
121471:     // things.
121471:     Maybe<JSAutoCompartment> mAc;
121471:   };
121471: };
121471: 
121471: } // namespace dom
121471: } // namespace mozilla
