     1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
     1: /* vim:set tw=80 expandtab softtabstop=2 ts=2 sw=2: */
 98983: /* This Source Code Form is subject to the terms of the Mozilla Public
 98983:  * License, v. 2.0. If a copy of the MPL was not distributed with this
 98983:  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 80467: 
 80467: #include "mozilla/Util.h"
120353: #include "mozilla/Likely.h"
 80467: 
     1: #include "nscore.h"
     1: #include "nsGenericHTMLElement.h"
115564: #include "nsAttrValueInlines.h"
     1: #include "nsCOMPtr.h"
     1: #include "nsIAtom.h"
     1: #include "nsIContentViewer.h"
 63693: #include "mozilla/css/StyleRule.h"
     1: #include "nsIDocument.h"
     1: #include "nsIDocumentEncoder.h"
     1: #include "nsIDOMHTMLBodyElement.h"
     1: #include "nsIDOMHTMLDocument.h"
     1: #include "nsIDOMAttr.h"
     1: #include "nsIDOMDocumentFragment.h"
 81041: #include "nsIDOMHTMLElement.h"
 75019: #include "nsIDOMHTMLMenuElement.h"
     1: #include "nsIDOMElementCSSInlineStyle.h"
     1: #include "nsIDOMWindow.h"
     1: #include "nsIDOMDocument.h"
 72328: #include "nsEventListenerManager.h"
     1: #include "nsMappedAttributes.h"
     1: #include "nsHTMLStyleSheet.h"
     1: #include "nsIHTMLDocument.h"
     1: #include "nsILink.h"
     1: #include "nsPIDOMWindow.h"
     1: #include "nsIStyleRule.h"
     1: #include "nsIURL.h"
     1: #include "nsNetUtil.h"
     1: #include "nsEscape.h"
     1: #include "nsIFrame.h"
     1: #include "nsIScrollableFrame.h"
     1: #include "nsIView.h"
     1: #include "nsIViewManager.h"
 82843: #include "nsIWidget.h"
     1: #include "nsRange.h"
     1: #include "nsIPresShell.h"
     1: #include "nsPresContext.h"
     1: #include "nsIDocShell.h"
 29018: #include "nsIDocShellTreeItem.h"
     1: #include "nsINameSpaceManager.h"
108290: #include "nsError.h"
     1: #include "nsScriptLoader.h"
     1: #include "nsRuleData.h"
     1: 
     1: #include "nsPresState.h"
     1: #include "nsILayoutHistoryState.h"
     1: 
     1: #include "nsHTMLParts.h"
     1: #include "nsContentUtils.h"
108036: #include "mozilla/dom/DirectionalityUtils.h"
     1: #include "nsString.h"
     1: #include "nsUnicharUtils.h"
     1: #include "nsGkAtoms.h"
 68780: #include "nsEventStateManager.h"
     1: #include "nsIDOMEvent.h"
     1: #include "nsDOMCSSDeclaration.h"
     1: #include "nsITextControlFrame.h"
     1: #include "nsIForm.h"
     1: #include "nsIFormControl.h"
     1: #include "nsIDOMHTMLFormElement.h"
 34395: #include "nsHTMLFormElement.h"
 29018: #include "nsFocusManager.h"
123733: #include "nsAttrValueOrString.h"
     1: 
     1: #include "nsMutationEvent.h"
     1: 
     1: #include "nsContentCID.h"
     1: 
 70158: #include "nsDOMStringMap.h"
 70158: 
     1: #include "nsIEditor.h"
     1: #include "nsIEditorIMESupport.h"
     1: #include "nsEventDispatcher.h"
     1: #include "nsLayoutUtils.h"
 14228: #include "mozAutoDocUpdate.h"
 41754: #include "nsHtml5Module.h"
 43129: #include "nsITextControlElement.h"
 47801: #include "mozilla/dom/Element.h"
 54346: #include "nsHTMLFieldSetElement.h"
 75019: #include "nsHTMLMenuElement.h"
 84833: #include "nsAsyncDOMEvent.h"
 94465: #include "nsDOMMutationObserver.h"
 70840: #include "mozilla/Preferences.h"
 82125: #include "mozilla/dom/FromParser.h"
 99884: #include "mozilla/BloomFilter.h"
 70840: 
101092: #include "HTMLPropertiesCollection.h"
101092: #include "nsVariant.h"
101135: #include "nsDOMSettableTokenList.h"
101135: #include "nsThreadUtils.h"
103385: #include "nsTextFragment.h"
114093: #include "mozilla/dom/BindingUtils.h"
114093: #include "mozilla/ErrorResult.h"
121921: #include "nsHTMLDocument.h"
124201: #include "nsDOMTouchEvent.h"
125101: #include "nsGlobalWindow.h"
101092: 
 70840: using namespace mozilla;
 47801: using namespace mozilla::dom;
     1: 
 94340: class nsINodeInfo;
     1: class nsIDOMNodeList;
     1: class nsRuleWalker;
     1: 
     1: // XXX todo: add in missing out-of-memory checks
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: #ifdef GATHER_ELEMENT_USEAGE_STATISTICS
     1: 
     1: // static objects that have constructors are kinda bad, but we don't
     1: // care here, this is only debugging code!
     1: 
     1: static nsHashtable sGEUS_ElementCounts;
     1: 
 94340: void GEUS_ElementCreated(nsINodeInfo *aNodeInfo)
     1: {
     1:   nsAutoString name;
 69362:   aNodeInfo->GetName(name);
     1: 
     1:   nsStringKey key(name);
     1: 
108991:   int32_t count = (int32_t)sGEUS_ElementCounts.Get(&key);
     1: 
     1:   count++;
     1: 
     1:   sGEUS_ElementCounts.Put(&key, (void *)count);
     1: }
     1: 
 79445: bool GEUS_enum_func(nsHashKey *aKey, void *aData, void *aClosure)
     1: {
     1:   const PRUnichar *name_chars = ((nsStringKey *)aKey)->GetString();
     1:   NS_ConvertUTF16toUTF8 name(name_chars);
     1: 
     1:   printf ("%s %d\n", name.get(), aData);
     1: 
 80486:   return true;
     1: }
     1: 
     1: void GEUS_DumpElementCounts()
     1: {
     1:   printf ("Element count statistics:\n");
     1: 
106838:   sGEUS_ElementCounts.Enumerate(GEUS_enum_func, nullptr);
     1: 
     1:   printf ("End of element count statistics:\n");
     1: }
     1: 
     1: nsresult
 94340: nsGenericHTMLElement::Init(nsINodeInfo *aNodeInfo)
     1: {
     1:   GEUS_ElementCreated(aNodeInfo);
     1: 
  4306:   return nsGenericHTMLElementBase::Init(aNodeInfo);
     1: }
     1: 
     1: #endif
     1: 
 42460: /**
 42460:  * nsAutoFocusEvent is used to dispatch a focus event when a
 42460:  * nsGenericHTMLFormElement is binded to the tree with the autofocus attribute
 42460:  * enabled.
 42460:  */
 42460: class nsAutoFocusEvent : public nsRunnable
 42460: {
 42460: public:
 42460:   nsAutoFocusEvent(nsGenericHTMLFormElement* aElement) : mElement(aElement) {}
 42460: 
 42460:   NS_IMETHOD Run() {
 42460:     nsFocusManager* fm = nsFocusManager::GetFocusManager();
 42460:     if (!fm) {
 42460:       return NS_ERROR_NULL_POINTER;
 42460:     }
 42460: 
 80526:     nsIDocument* document = mElement->OwnerDoc();
 42460: 
 42460:     nsPIDOMWindow* window = document->GetWindow();
 59587:     if (!window) {
 59587:       return NS_OK;
 59587:     }
 59450: 
 59450:     // Trying to found the top window (equivalent to window.top).
 59450:     nsCOMPtr<nsIDOMWindow> top;
 59450:     window->GetTop(getter_AddRefs(top));
 59450:     if (top) {
 59450:       window = static_cast<nsPIDOMWindow*>(top.get());
 59450:     }
 59450: 
 59587:     if (window->GetFocusedNode()) {
 59587:       return NS_OK;
 59587:     }
 59587: 
116223:     nsCOMPtr<nsIDocument> topDoc = window->GetExtantDoc();
 59451:     if (topDoc && topDoc->GetReadyStateEnum() == nsIDocument::READYSTATE_COMPLETE) {
 59451:       return NS_OK;
 59451:     }
 59451: 
 42460:     // If something is focused in the same document, ignore autofocus.
 42460:     if (!fm->GetFocusedContent() ||
 80526:         fm->GetFocusedContent()->OwnerDoc() != document) {
116223:       mozilla::ErrorResult rv;
116223:       mElement->Focus(rv);
116223:       return rv.ErrorCode();
 42460:     }
 42460: 
 42460:     return NS_OK;
 42460:   }
 42460: private:
 42460:   // NOTE: nsGenericHTMLFormElement is saved as a nsGenericHTMLElement
 42460:   // because AddRef/Release are ambiguous with nsGenericHTMLFormElement
 42460:   // and Focus() is declared (and defined) in nsGenericHTMLElement class.
 42460:   nsRefPtr<nsGenericHTMLElement> mElement;
 42460: };
     1: 
 81041: class nsGenericHTMLElementTearoff : public nsIDOMElementCSSInlineStyle
 12033: {
 12033:   NS_DECL_CYCLE_COLLECTING_ISUPPORTS
 12033: 
 12033:   nsGenericHTMLElementTearoff(nsGenericHTMLElement *aElement)
 12033:     : mElement(aElement)
 12033:   {
 12033:   }
 12033: 
 12033:   virtual ~nsGenericHTMLElementTearoff()
 12033:   {
 12033:   }
 12033: 
 48944:   NS_IMETHOD GetStyle(nsIDOMCSSStyleDeclaration** aStyle)
 48944:   {
121921:     mozilla::ErrorResult rv;
121921:     NS_IF_ADDREF(*aStyle = mElement->GetStyle(rv));
121921:     return rv.ErrorCode();
 48944:   }
 12033: 
 12033:   NS_DECL_CYCLE_COLLECTION_CLASS_AMBIGUOUS(nsGenericHTMLElementTearoff,
 81041:                                            nsIDOMElementCSSInlineStyle)
 12033: 
 12033: private:
 48449:   nsRefPtr<nsGenericHTMLElement> mElement;
 12033: };
 12033: 
     1: NS_IMPL_CYCLE_COLLECTION_1(nsGenericHTMLElementTearoff, mElement)
     1: 
 67682: NS_IMPL_CYCLE_COLLECTING_ADDREF(nsGenericHTMLElementTearoff)
 67682: NS_IMPL_CYCLE_COLLECTING_RELEASE(nsGenericHTMLElementTearoff)
     1: 
  4838: NS_INTERFACE_TABLE_HEAD(nsGenericHTMLElementTearoff)
 81041:   NS_INTERFACE_TABLE_INHERITED1(nsGenericHTMLElementTearoff,
  4838:                                 nsIDOMElementCSSInlineStyle)
  4838:   NS_INTERFACE_TABLE_TO_MAP_SEGUE_CYCLE_COLLECTION(nsGenericHTMLElementTearoff)
     1: NS_INTERFACE_MAP_END_AGGREGATED(mElement)
     1: 
     1: nsresult
     1: nsGenericHTMLElement::DOMQueryInterface(nsIDOMHTMLElement *aElement,
     1:                                         REFNSIID aIID, void **aInstancePtr)
     1: {
  3114:   NS_PRECONDITION(aInstancePtr, "null out param");
  3114: 
  4838:   nsresult rv = NS_ERROR_FAILURE;
  4838: 
  4838:   NS_INTERFACE_TABLE_BEGIN
  4838:     NS_INTERFACE_TABLE_ENTRY(nsIDOMHTMLElement, nsIDOMNode)
  4838:     NS_INTERFACE_TABLE_ENTRY(nsIDOMHTMLElement, nsIDOMElement)
  4838:     NS_INTERFACE_TABLE_ENTRY(nsIDOMHTMLElement, nsIDOMHTMLElement)
  4838:   NS_INTERFACE_TABLE_END_WITH_PTR(aElement)
  4838: 
  4838:   NS_INTERFACE_TABLE_TO_MAP_SEGUE
  4838:   NS_INTERFACE_MAP_ENTRY_TEAROFF(nsIDOMElementCSSInlineStyle,
  4838:                                  new nsGenericHTMLElementTearoff(this))
  4838:   NS_INTERFACE_MAP_END
  4838: 
 48696: // No closing bracket, because NS_INTERFACE_MAP_END does that for us.
     1: 
     1: nsresult
121948: nsGenericHTMLElement::CopyInnerTo(Element* aDst)
     1: {
     1:   nsresult rv;
108991:   int32_t i, count = GetAttrCount();
     1:   for (i = 0; i < count; ++i) {
     1:     const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
     1:     const nsAttrValue *value = mAttrsAndChildren.AttrAt(i);
 94833: 
 94833:     nsAutoString valStr;
 94833:     value->ToString(valStr);
 94833: 
     1:     if (name->Equals(nsGkAtoms::style, kNameSpaceID_None) &&
     1:         value->Type() == nsAttrValue::eCSSStyleRule) {
     1:       // We can't just set this as a string, because that will fail
     1:       // to reparse the string into style data until the node is
 69440:       // inserted into the document.  Clone the Rule instead.
 69440:       nsRefPtr<mozilla::css::Rule> ruleClone = value->GetCSSStyleRuleValue()->Clone();
 63693:       nsRefPtr<mozilla::css::StyleRule> styleRule = do_QueryObject(ruleClone);
     1:       NS_ENSURE_TRUE(styleRule, NS_ERROR_UNEXPECTED);
     1: 
 94833:       rv = aDst->SetInlineStyleRule(styleRule, &valStr, false);
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1: 
     1:       continue;
     1:     }
     1: 
     1:     rv = aDst->SetAttr(name->NamespaceID(), name->LocalName(),
 80486:                        name->GetPrefix(), valStr, false);
     1:     NS_ENSURE_SUCCESS(rv, rv);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
119075: already_AddRefed<nsDOMStringMap>
119075: nsGenericHTMLElement::Dataset()
119075: {
119075:   nsDOMSlots *slots = DOMSlots();
119075: 
119075:   if (!slots->mDataset) {
119075:     // mDataset is a weak reference so assignment will not AddRef.
119075:     // AddRef is called before returning the pointer.
119075:     slots->mDataset = new nsDOMStringMap(this);
119075:   }
119075: 
119075:   NS_ADDREF(slots->mDataset);
119075:   return slots->mDataset;
119075: }
119075: 
 70158: nsresult
120974: nsGenericHTMLElement::GetDataset(nsISupports** aDataset)
 70158: {
119075:   *aDataset = Dataset().get();
 70158:   return NS_OK;
 70158: }
 70158: 
 70158: nsresult
 70158: nsGenericHTMLElement::ClearDataset()
 70158: {
 70158:   nsDOMSlots *slots = GetExistingDOMSlots();
 70158: 
 70158:   NS_ASSERTION(slots && slots->mDataset,
 70158:                "Slots should exist and dataset should not be null.");
106838:   slots->mDataset = nullptr;
 70158: 
 70158:   return NS_OK;
 70158: }
 70158: 
     1: static const nsAttrValue::EnumTable kDirTable[] = {
123733:   { "ltr", eDir_LTR },
123733:   { "rtl", eDir_RTL },
123733:   { "auto", eDir_Auto },
     1:   { 0 }
     1: };
     1: 
121921: void
 74612: nsGenericHTMLElement::GetAccessKeyLabel(nsAString& aLabel)
 74612: {
 74612:   nsPresContext *presContext = GetPresContext();
 74612: 
121165:   if (presContext) {
 74612:     nsAutoString suffix;
 74612:     GetAccessKey(suffix);
121165:     if (!suffix.IsEmpty() && 
121165:         presContext->EventStateManager()->GetAccessKeyLabelPrefix(aLabel)) {
 74612:       aLabel.Append(suffix);
 74612:     }
121165:   }
 74612: }
 74612: 
 79445: static bool IS_TABLE_CELL(nsIAtom* frameType) {
  2370:   return nsGkAtoms::tableCellFrame == frameType ||
  2370:     nsGkAtoms::bcTableCellFrame == frameType;
  2370: }
  2370: 
 79445: static bool
  2370: IsOffsetParent(nsIFrame* aFrame)
     1: {
  2370:   nsIAtom* frameType = aFrame->GetType();
  2370:   return (IS_TABLE_CELL(frameType) ||
  2370:           frameType == nsGkAtoms::tableFrame);
     1: }
     1: 
121948: Element*
121921: nsGenericHTMLElement::GetOffsetRect(nsRect& aRect)
     1: {
 16722:   aRect = nsRect();
 16722: 
 16722:   nsIFrame* frame = GetStyledFrame();
     1:   if (!frame) {
121921:     return nullptr;
     1:   }
     1: 
     1:   nsIFrame* parent = frame->GetParent();
     1:   nsPoint origin(0, 0);
     1: 
 87317:   if (parent && parent->GetType() == nsGkAtoms::tableOuterFrame &&
 87317:       frame->GetType() == nsGkAtoms::tableFrame) {
     1:     origin = parent->GetPositionIgnoringScrolling();
     1:     parent = parent->GetParent();
     1:   }
     1: 
121921:   nsIContent* offsetParent = nullptr;
 41634:   Element* docElement = GetCurrentDoc()->GetRootElement();
     1:   nsIContent* content = frame->GetContent();
     1: 
 82292:   if (content && (content->IsHTML(nsGkAtoms::body) || content == docElement)) {
     1:     parent = frame;
     1:   }
     1:   else {
107225:     const bool isPositioned = frame->IsPositioned();
107225:     const bool isAbsolutelyPositioned = frame->IsAbsolutelyPositioned();
     1:     origin += frame->GetPositionIgnoringScrolling();
     1: 
     1:     for ( ; parent ; parent = parent->GetParent()) {
     1:       content = parent->GetContent();
     1: 
     1:       // Stop at the first ancestor that is positioned.
107225:       if (parent->IsPositioned()) {
121921:         offsetParent = content;
     1:         break;
     1:       }
     1: 
     1:       // Add the parent's origin to our own to get to the
     1:       // right coordinate system.
 79445:       const bool isOffsetParent = !isPositioned && IsOffsetParent(parent);
  2370:       if (!isAbsolutelyPositioned && !isOffsetParent) {
     1:         origin += parent->GetPositionIgnoringScrolling();
     1:       }
     1: 
     1:       if (content) {
     1:         // If we've hit the document element, break here.
     1:         if (content == docElement) {
     1:           break;
     1:         }
     1: 
  2705:         // Break if the ancestor frame type makes it suitable as offset parent
  2705:         // and this element is *not* positioned or if we found the body element.
 82292:         if (isOffsetParent || content->IsHTML(nsGkAtoms::body)) {
121921:           offsetParent = content;
     1:           break;
     1:         }
     1:       }
     1:     }
     1: 
121921:     if (isAbsolutelyPositioned && !offsetParent) {
     1:       // If this element is absolutely positioned, but we don't have
     1:       // an offset parent it means this element is an absolutely
     1:       // positioned child that's not nested inside another positioned
     1:       // element, in this case the element's frame's parent is the
     1:       // frame for the HTML element so we fail to find the body in the
     1:       // parent chain. We want the offset parent in this case to be
     1:       // the body, so we just get the body element from the document.
     1: 
     1:       nsCOMPtr<nsIDOMHTMLDocument> html_doc(do_QueryInterface(GetCurrentDoc()));
     1: 
     1:       if (html_doc) {
121921:         offsetParent = static_cast<nsHTMLDocument*>(html_doc.get())->GetBody();
     1:       }
     1:     }
     1:   }
     1: 
     1:   // Subtract the parent border unless it uses border-box sizing.
     1:   if (parent &&
     1:       parent->GetStylePosition()->mBoxSizing != NS_STYLE_BOX_SIZING_BORDER) {
     1:     const nsStyleBorder* border = parent->GetStyleBorder();
 99856:     origin.x -= border->GetComputedBorderWidth(NS_SIDE_LEFT);
 99856:     origin.y -= border->GetComputedBorderWidth(NS_SIDE_TOP);
     1:   }
     1: 
     1:   // XXX We should really consider subtracting out padding for
     1:   // content-box sizing, but we should see what IE does....
     1: 
     1:   // Convert to pixels.
     1:   aRect.x = nsPresContext::AppUnitsToIntCSSPixels(origin.x);
     1:   aRect.y = nsPresContext::AppUnitsToIntCSSPixels(origin.y);
 12349: 
 12349:   // Get the union of all rectangles in this and continuation frames.
 12349:   // It doesn't really matter what we use as aRelativeTo here, since
 14186:   // we only care about the size. We just have to use something non-null.
 14186:   nsRect rcFrame = nsLayoutUtils::GetAllInFlowRectsUnion(frame, frame);
     1:   aRect.width = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.width);
     1:   aRect.height = nsPresContext::AppUnitsToIntCSSPixels(rcFrame.height);
121921: 
121948:   return offsetParent ? offsetParent->AsElement() : nullptr;
     1: }
     1: 
 99884: // Try to keep the size of StringBuilder close to a jemalloc bucket size.
 99884: #define STRING_BUFFER_UNITS 1020
 99884: 
 99884: class StringBuilder
 99884: {
 99884: private:
 99884:   class Unit
 99884:   {
 99884:   public:
118692:     Unit() : mAtom(nullptr), mType(eUnknown), mLength(0)
118692:     {
118692:       MOZ_COUNT_CTOR(StringBuilder::Unit);
118692:     }
 99884:     ~Unit()
 99884:     {
 99884:       if (mType == eString || mType == eStringWithEncode) {
 99884:         delete mString;
 99884:       }
118692:       MOZ_COUNT_DTOR(StringBuilder::Unit);
 99884:     }
 99884: 
 99884:     enum Type
 99884:     {
 99884:       eUnknown,
 99884:       eAtom,
 99884:       eString,
 99884:       eStringWithEncode,
 99884:       eLiteral,
 99884:       eTextFragment,
 99884:       eTextFragmentWithEncode,
 99884:     };
 99884: 
 99884:     union
 99884:     {
 99884:       nsIAtom*              mAtom;
 99884:       const char*           mLiteral;
 99884:       nsAutoString*         mString;
 99884:       const nsTextFragment* mTextFragment;
 99884:     };
 99884:     Type     mType;
108991:     uint32_t mLength;
 99884:   };
 99884: public:
118692:   StringBuilder() : mLast(this), mLength(0)
118692:   {
118692:     MOZ_COUNT_CTOR(StringBuilder);
118692:   }
118692: 
118692:   ~StringBuilder()
118692:   {
118692:     MOZ_COUNT_DTOR(StringBuilder);
118692:   }
 99884: 
 99884:   void Append(nsIAtom* aAtom)
 99884:   {
 99884:     Unit* u = AddUnit();
 99884:     u->mAtom = aAtom;
 99884:     u->mType = Unit::eAtom;
108991:     uint32_t len = aAtom->GetLength();
 99884:     u->mLength = len;
 99884:     mLength += len;
 99884:   }
 99884: 
 99884:   template<int N>
 99884:   void Append(const char (&aLiteral)[N])
 99884:   {
 99884:     Unit* u = AddUnit();
 99884:     u->mLiteral = aLiteral;
 99884:     u->mType = Unit::eLiteral;
108991:     uint32_t len = N - 1;
 99884:     u->mLength = len;
 99884:     mLength += len;
 99884:   }
 99884: 
 99884:   template<int N>
 99884:   void Append(char (&aLiteral)[N])
 99884:   {
 99884:     Unit* u = AddUnit();
 99884:     u->mLiteral = aLiteral;
 99884:     u->mType = Unit::eLiteral;
108991:     uint32_t len = N - 1;
 99884:     u->mLength = len;
 99884:     mLength += len;
 99884:   }
 99884: 
 99884:   void Append(const nsAString& aString)
 99884:   {
 99884:     Unit* u = AddUnit();
 99884:     u->mString = new nsAutoString(aString);
 99884:     u->mType = Unit::eString;
108991:     uint32_t len = aString.Length();
 99884:     u->mLength = len;
 99884:     mLength += len;
 99884:   }
 99884: 
 99884:   void Append(nsAutoString* aString)
 99884:   {
 99884:     Unit* u = AddUnit();
 99884:     u->mString = aString;
 99884:     u->mType = Unit::eString;
108991:     uint32_t len = aString->Length();
 99884:     u->mLength = len;
 99884:     mLength += len;
 99884:   }
 99884: 
108991:   void AppendWithAttrEncode(nsAutoString* aString, uint32_t aLen)
 99884:   {
 99884:     Unit* u = AddUnit();
 99884:     u->mString = aString;
 99884:     u->mType = Unit::eStringWithEncode;
 99884:     u->mLength = aLen;
 99884:     mLength += aLen;
 99884:   }
 99884: 
 99884:   void Append(const nsTextFragment* aTextFragment)
 99884:   {
 99884:     Unit* u = AddUnit();
 99884:     u->mTextFragment = aTextFragment;
 99884:     u->mType = Unit::eTextFragment;
108991:     uint32_t len = aTextFragment->GetLength();
 99884:     u->mLength = len;
 99884:     mLength += len;
 99884:   }
 99884: 
108991:   void AppendWithEncode(const nsTextFragment* aTextFragment, uint32_t aLen)
 99884:   {
 99884:     Unit* u = AddUnit();
 99884:     u->mTextFragment = aTextFragment;
 99884:     u->mType = Unit::eTextFragmentWithEncode;
 99884:     u->mLength = aLen;
 99884:     mLength += aLen;
 99884:   }
 99884: 
 99884:   bool ToString(nsAString& aOut)
 99884:   {
 99884:     if (!aOut.SetCapacity(mLength, fallible_t())) {
 99884:       return false;
 99884:     }
 99884: 
 99884:     for (StringBuilder* current = this; current; current = current->mNext) {
108991:       uint32_t len = current->mUnits.Length();
108991:       for (uint32_t i = 0; i < len; ++i) {
 99884:         Unit& u = current->mUnits[i];
 99884:         switch (u.mType) {
 99884:           case Unit::eAtom:
 99884:             aOut.Append(nsDependentAtomString(u.mAtom));
 99884:             break;
 99884:           case Unit::eString:
 99884:             aOut.Append(*(u.mString));
 99884:             break;
 99884:           case Unit::eStringWithEncode:
 99884:             EncodeAttrString(*(u.mString), aOut);
 99884:             break;
 99884:           case Unit::eLiteral:
 99884:             aOut.AppendASCII(u.mLiteral, u.mLength);
 99884:             break;
 99884:           case Unit::eTextFragment:
 99884:             u.mTextFragment->AppendTo(aOut);
 99884:             break;
 99884:           case Unit::eTextFragmentWithEncode:
 99884:             EncodeTextFragment(u.mTextFragment, aOut);
 99884:             break;
 99884:           default:
 99884:             MOZ_NOT_REACHED("Unknown unit type?");
 99884:         }
 99884:       }
 99884:     }
 99884:     return true;
 99884:   }
 99884: private:
 99884:   Unit* AddUnit()
 99884:   {
 99884:     if (mLast->mUnits.Length() == STRING_BUFFER_UNITS) {
 99884:       new StringBuilder(this);
 99884:     }
 99884:     return mLast->mUnits.AppendElement();
 99884:   }
 99884: 
 99884:   StringBuilder(StringBuilder* aFirst)
106838:   : mLast(nullptr), mLength(0)
 99884:   {
118692:     MOZ_COUNT_CTOR(StringBuilder);
 99884:     aFirst->mLast->mNext = this;
 99884:     aFirst->mLast = this;
 99884:   }
 99884: 
 99884:   void EncodeAttrString(const nsAutoString& aValue, nsAString& aOut)
 99884:   {
 99884:     const PRUnichar* c = aValue.BeginReading();
 99884:     const PRUnichar* end = aValue.EndReading();
 99884:     while (c < end) {
 99884:       switch (*c) {
 99884:       case '"':
 99884:         aOut.AppendLiteral("&quot;");
 99884:         break;
 99884:       case '&':
 99884:         aOut.AppendLiteral("&amp;");
 99884:         break;
 99884:       case 0x00A0:
 99884:         aOut.AppendLiteral("&nbsp;");
 99884:         break;
 99884:       default:
 99884:         aOut.Append(*c);
 99884:         break;
 99884:       }
 99884:       ++c;
 99884:     }
 99884:   }
 99884: 
 99884:   void EncodeTextFragment(const nsTextFragment* aValue, nsAString& aOut)
 99884:   {
108991:     uint32_t len = aValue->GetLength();
 99884:     if (aValue->Is2b()) {
 99884:       const PRUnichar* data = aValue->Get2b();
108991:       for (uint32_t i = 0; i < len; ++i) {
 99884:         const PRUnichar c = data[i];
 99884:         switch (c) {
 99884:           case '<':
 99884:             aOut.AppendLiteral("&lt;");
 99884:             break;
 99884:           case '>':
 99884:             aOut.AppendLiteral("&gt;");
 99884:             break;
 99884:           case '&':
 99884:             aOut.AppendLiteral("&amp;");
 99884:             break;
 99884:           case 0x00A0:
 99884:             aOut.AppendLiteral("&nbsp;");
 99884:             break;
 99884:           default:
 99884:             aOut.Append(c);
 99884:             break;
 99884:         }
 99884:       }
 99884:     } else {
 99884:       const char* data = aValue->Get1b();
108991:       for (uint32_t i = 0; i < len; ++i) {
 99884:         const unsigned char c = data[i];
 99884:         switch (c) {
 99884:           case '<':
 99884:             aOut.AppendLiteral("&lt;");
 99884:             break;
 99884:           case '>':
 99884:             aOut.AppendLiteral("&gt;");
 99884:             break;
 99884:           case '&':
 99884:             aOut.AppendLiteral("&amp;");
 99884:             break;
 99884:           case 0x00A0:
 99884:             aOut.AppendLiteral("&nbsp;");
 99884:             break;
 99884:           default:
 99884:             aOut.Append(c);
 99884:             break;
 99884:         }
 99884:       }
 99884:     }
 99884:   }
 99884: 
 99884:   nsAutoTArray<Unit, STRING_BUFFER_UNITS> mUnits;
 99884:   nsAutoPtr<StringBuilder>                mNext;
 99884:   StringBuilder*                          mLast;
 99884:   // mLength is used only in the first StringBuilder object in the linked list.
108991:   uint32_t                                mLength;
 99884: };
 99884: 
 99884: static void
 99884: AppendEncodedCharacters(const nsTextFragment* aText, StringBuilder& aBuilder)
 99884: {
108991:   uint32_t extraSpaceNeeded = 0;
108991:   uint32_t len = aText->GetLength();
 99884:   if (aText->Is2b()) {
 99884:     const PRUnichar* data = aText->Get2b();
108991:     for (uint32_t i = 0; i < len; ++i) {
 99884:       const PRUnichar c = data[i];
 99884:       switch (c) {
 99884:         case '<':
 99884:           extraSpaceNeeded += ArrayLength("&lt;") - 2;
 99884:           break;
 99884:         case '>':
 99884:           extraSpaceNeeded += ArrayLength("&gt;") - 2;
 99884:           break;
 99884:         case '&':
 99884:           extraSpaceNeeded += ArrayLength("&amp;") - 2;
 99884:           break;
 99884:         case 0x00A0:
 99884:           extraSpaceNeeded += ArrayLength("&nbsp;") - 2;
 99884:           break;
 99884:         default:
 99884:           break;
 99884:       }
 99884:     }
 99884:   } else {
 99884:     const char* data = aText->Get1b();
108991:     for (uint32_t i = 0; i < len; ++i) {
 99884:       const unsigned char c = data[i];
 99884:       switch (c) {
 99884:         case '<':
 99884:           extraSpaceNeeded += ArrayLength("&lt;") - 2;
 99884:           break;
 99884:         case '>':
 99884:           extraSpaceNeeded += ArrayLength("&gt;") - 2;
 99884:           break;
 99884:         case '&':
 99884:           extraSpaceNeeded += ArrayLength("&amp;") - 2;
 99884:           break;
 99884:         case 0x00A0:
 99884:           extraSpaceNeeded += ArrayLength("&nbsp;") - 2;
 99884:           break;
 99884:         default:
 99884:           break;
 99884:       }
 99884:     }
 99884:   }
 99884: 
 99884:   if (extraSpaceNeeded) {
 99884:     aBuilder.AppendWithEncode(aText, len + extraSpaceNeeded);
 99884:   } else {
 99884:     aBuilder.Append(aText);
 99884:   }
 99884: }
 99884: 
 99884: static void
 99884: AppendEncodedAttributeValue(nsAutoString* aValue, StringBuilder& aBuilder)
 99884: {
 99884:   const PRUnichar* c = aValue->BeginReading();
 99884:   const PRUnichar* end = aValue->EndReading();
 99884: 
108991:   uint32_t extraSpaceNeeded = 0;
 99884:   while (c < end) {
 99884:     switch (*c) {
 99884:       case '"':
 99884:         extraSpaceNeeded += ArrayLength("&quot;") - 2;
 99884:         break;
 99884:       case '&':
 99884:         extraSpaceNeeded += ArrayLength("&amp;") - 2;
 99884:         break;
 99884:       case 0x00A0:
 99884:         extraSpaceNeeded += ArrayLength("&nbsp;") - 2;
 99884:         break;
 99884:       default:
 99884:         break;
 99884:     }
 99884:     ++c;
 99884:   }
 99884: 
 99884:   if (extraSpaceNeeded) {
 99884:     aBuilder.AppendWithAttrEncode(aValue, aValue->Length() + extraSpaceNeeded);
 99884:   } else {
 99884:     aBuilder.Append(aValue);
 99884:   }
 99884: }
 99884: 
 99884: static void
 99884: StartElement(Element* aContent, StringBuilder& aBuilder)
 99884: {
 99884:   nsIAtom* localName = aContent->Tag();
108991:   int32_t tagNS = aContent->GetNameSpaceID();
 99884: 
 99884:   aBuilder.Append("<");
 99884:   if (aContent->IsHTML() || aContent->IsSVG() || aContent->IsMathML()) {
 99884:     aBuilder.Append(localName);
 99884:   } else {
 99884:     aBuilder.Append(aContent->NodeName());
 99884:   }
 99884: 
108991:   int32_t count = aContent->GetAttrCount();
108991:   for (int32_t i = count; i > 0;) {
 99884:     --i;
 99884:     const nsAttrName* name = aContent->GetAttrNameAt(i);
108991:     int32_t attNs = name->NamespaceID();
 99884:     nsIAtom* attName = name->LocalName();
 99884: 
 99884:     // Filter out any attribute starting with [-|_]moz
 99884:     nsDependentAtomString attrNameStr(attName);
 99884:     if (StringBeginsWith(attrNameStr, NS_LITERAL_STRING("_moz")) ||
 99884:         StringBeginsWith(attrNameStr, NS_LITERAL_STRING("-moz"))) {
 99884:       continue;
 99884:     }
 99884: 
 99884:     nsAutoString* attValue = new nsAutoString();
 99884:     aContent->GetAttr(attNs, attName, *attValue);
 99884: 
 99884:     // Filter out special case of <br type="_moz*"> used by the editor.
 99884:     // Bug 16988.  Yuck.
 99884:     if (localName == nsGkAtoms::br && tagNS == kNameSpaceID_XHTML &&
 99884:         attName == nsGkAtoms::type && attNs == kNameSpaceID_None &&
 99884:         StringBeginsWith(*attValue, NS_LITERAL_STRING("_moz"))) {
 99884:       delete attValue;
 99884:       continue;
 99884:     }
 99884:     
120353:     if (MOZ_LIKELY(attNs == kNameSpaceID_None) ||
 99884:         (attNs == kNameSpaceID_XMLNS &&
 99884:          attName == nsGkAtoms::xmlns)) {
 99884:       aBuilder.Append(" ");
 99884:     } else if (attNs == kNameSpaceID_XML) {
 99884:       aBuilder.Append(" xml:");
 99884:     } else if (attNs == kNameSpaceID_XMLNS) {
 99884:       aBuilder.Append(" xmlns:");
 99884:     } else if (attNs == kNameSpaceID_XLink) {
 99884:       aBuilder.Append(" xlink:");
 99884:     } else {
 99884:       nsIAtom* prefix = name->GetPrefix();
 99884:       if (prefix) {
 99884:         aBuilder.Append(" ");
 99884:         aBuilder.Append(prefix);
 99884:         aBuilder.Append(":");
 99884:       }
 99884:     }
 99884: 
 99884:     aBuilder.Append(attName);
 99884:     aBuilder.Append("=\"");
 99884:     AppendEncodedAttributeValue(attValue, aBuilder);
 99884:     aBuilder.Append("\"");
 99884:   }
 99884: 
 99884:   aBuilder.Append(">");
 99884: 
 99884:   /*
 99884:   // Per HTML spec we should append one \n if the first child of
 99884:   // pre/textarea/listing is a textnode and starts with a \n.
 99884:   // But because browsers haven't traditionally had that behavior,
 99884:   // we're not changing our behavior either - yet.
 99884:   if (aContent->IsHTML()) {
 99884:     if (localName == nsGkAtoms::pre || localName == nsGkAtoms::textarea ||
 99884:         localName == nsGkAtoms::listing) {
 99884:       nsIContent* fc = aContent->GetFirstChild();
 99884:       if (fc &&
 99884:           (fc->NodeType() == nsIDOMNode::TEXT_NODE ||
 99884:            fc->NodeType() == nsIDOMNode::CDATA_SECTION_NODE)) {
 99884:         const nsTextFragment* text = fc->GetText();
 99884:         if (text && text->GetLength() && text->CharAt(0) == PRUnichar('\n')) {
 99884:           aBuilder.Append("\n");
 99884:         }
 99884:       }
 99884:     }
 99884:   }*/
 99884: }
 99884: 
 99884: static inline bool
 99884: ShouldEscape(nsIContent* aParent)
 99884: {
 99884:   if (!aParent || !aParent->IsHTML()) {
 99884:     return true;
 99884:   }
 99884: 
 99884:   static const nsIAtom* nonEscapingElements[] = {
 99884:     nsGkAtoms::style, nsGkAtoms::script, nsGkAtoms::xmp,
 99884:     nsGkAtoms::iframe, nsGkAtoms::noembed, nsGkAtoms::noframes,
 99884:     nsGkAtoms::plaintext, 
 99884:     // Per the current spec noscript should be escaped in case
 99884:     // scripts are disabled or if document doesn't have
 99884:     // browsing context. However the latter seems to be a spec bug
 99884:     // and Gecko hasn't traditionally done the former.
 99884:     nsGkAtoms::noscript    
 99884:   };
 99884:   static mozilla::BloomFilter<12, nsIAtom> sFilter;
 99884:   static bool sInitialized = false;
 99884:   if (!sInitialized) {
 99884:     sInitialized = true;
108991:     for (uint32_t i = 0; i < ArrayLength(nonEscapingElements); ++i) {
 99884:       sFilter.add(nonEscapingElements[i]);
 99884:     }
 99884:   }
 99884: 
 99884:   nsIAtom* tag = aParent->Tag();
 99884:   if (sFilter.mightContain(tag)) {
108991:     for (uint32_t i = 0; i < ArrayLength(nonEscapingElements); ++i) {
 99884:       if (tag == nonEscapingElements[i]) {
 99884:         return false;
 99884:       }
 99884:     }
 99884:   }
 99884:   return true;
 99884: }
 99884: 
 99884: static inline bool
 99884: IsVoidTag(Element* aElement)
 99884: {
 99884:   if (!aElement->IsHTML()) {
 99884:     return false;
 99884:   }
 99884: 
 99884:   static const nsIAtom* voidElements[] = {
 99884:     nsGkAtoms::area, nsGkAtoms::base, nsGkAtoms::basefont,
 99884:     nsGkAtoms::bgsound, nsGkAtoms::br, nsGkAtoms::col,
 99884:     nsGkAtoms::command, nsGkAtoms::embed, nsGkAtoms::frame,
 99884:     nsGkAtoms::hr, nsGkAtoms::img, nsGkAtoms::input,
 99884:     nsGkAtoms::keygen, nsGkAtoms::link, nsGkAtoms::meta,
 99884:     nsGkAtoms::param, nsGkAtoms::source, nsGkAtoms::track,
 99884:     nsGkAtoms::wbr
 99884:   };
 99884: 
 99884:   static mozilla::BloomFilter<12, nsIAtom> sFilter;
 99884:   static bool sInitialized = false;
 99884:   if (!sInitialized) {
 99884:     sInitialized = true;
108991:     for (uint32_t i = 0; i < ArrayLength(voidElements); ++i) {
 99884:       sFilter.add(voidElements[i]);
 99884:     }
 99884:   }
 99884:   
 99884:   nsIAtom* tag = aElement->Tag();
 99884:   if (sFilter.mightContain(tag)) {
108991:     for (uint32_t i = 0; i < ArrayLength(voidElements); ++i) {
 99884:       if (tag == voidElements[i]) {
 99884:         return true;
 99884:       }
 99884:     }
 99884:   }
 99884:   return false;
 99884: }
 99884: 
 99884: static bool
 99884: Serialize(Element* aRoot, bool aDescendentsOnly, nsAString& aOut)
 99884: {
 99884:   nsINode* current = aDescendentsOnly ? aRoot->GetFirstChild() : aRoot;
 99884:   if (!current) {
 99884:     return true;
 99884:   }
 99884: 
 99884:   StringBuilder builder;
 99884:   nsIContent* next;
 99884:   while (true) {
 99884:     bool isVoid = false;
 99884:     switch (current->NodeType()) {
 99884:       case nsIDOMNode::ELEMENT_NODE: {
 99884:         Element* elem = current->AsElement();
 99884:         StartElement(elem, builder);
 99884:         isVoid = IsVoidTag(elem);
 99884:         if (!isVoid && (next = current->GetFirstChild())) {
 99884:           current = next;
 99884:           continue;
 99884:         }
 99884:         break;
 99884:       }
 99884: 
 99884:       case nsIDOMNode::TEXT_NODE:
 99884:       case nsIDOMNode::CDATA_SECTION_NODE: {
 99884:         const nsTextFragment* text = static_cast<nsIContent*>(current)->GetText();
 99884:         nsIContent* parent = current->GetParent();
 99884:         if (ShouldEscape(parent)) {
 99884:           AppendEncodedCharacters(text, builder);
 99884:         } else {
 99884:           builder.Append(text);
 99884:         }
 99884:         break;
 99884:       }
 99884: 
 99884:       case nsIDOMNode::COMMENT_NODE: {
 99884:         builder.Append("<!--");
 99884:         builder.Append(static_cast<nsIContent*>(current)->GetText());
 99884:         builder.Append("-->");
 99884:         break;
 99884:       }
 99884: 
 99884:       case nsIDOMNode::DOCUMENT_TYPE_NODE: {
 99884:         builder.Append("<!DOCTYPE ");
 99884:         builder.Append(current->NodeName());
 99884:         builder.Append(">");
 99884:         break;
 99884:       }
 99884: 
 99884:       case nsIDOMNode::PROCESSING_INSTRUCTION_NODE: {
 99884:         builder.Append("<?");
 99884:         builder.Append(current->NodeName());
 99884:         builder.Append(" ");
 99884:         builder.Append(static_cast<nsIContent*>(current)->GetText());
 99884:         builder.Append(">");
 99884:         break;
 99884:       }
 99884:     }
 99884: 
 99884:     while (true) {
 99884:       if (!isVoid && current->NodeType() == nsIDOMNode::ELEMENT_NODE) {
 99884:         builder.Append("</");
 99884:         nsIContent* elem = static_cast<nsIContent*>(current);
 99884:         if (elem->IsHTML() || elem->IsSVG() || elem->IsMathML()) {
 99884:           builder.Append(elem->Tag());
 99884:         } else {
 99884:           builder.Append(current->NodeName());
 99884:         }
 99884:         builder.Append(">");
 99884:       }
 99884:       isVoid = false;
 99884: 
 99884:       if (current == aRoot) {
 99884:         return builder.ToString(aOut);
 99884:       }
 99884: 
 99884:       if ((next = current->GetNextSibling())) {
 99884:         current = next;
 99884:         break;
 99884:       }
 99884: 
119415:       current = current->GetParentNode();
 99884:       if (aDescendentsOnly && current == aRoot) {
 99884:         return builder.ToString(aOut);
 99884:       }
 99884:     }
 99884:   }
 99884: }
 99884: 
 82125: nsresult
 82125: nsGenericHTMLElement::GetMarkup(bool aIncludeSelf, nsAString& aMarkup)
     1: {
 82125:   aMarkup.Truncate();
     1: 
 80526:   nsIDocument* doc = OwnerDoc();
 99884:   if (IsInHTMLDocument()) {
 99884:     return Serialize(this, !aIncludeSelf, aMarkup) ? NS_OK : NS_ERROR_OUT_OF_MEMORY;
 99884:   }
     1: 
     1:   nsAutoString contentType;
     1:   doc->GetContentType(contentType);
     1: 
 46309:   nsCOMPtr<nsIDocumentEncoder> docEncoder = doc->GetCachedEncoder();
 46309:   if (!docEncoder) {
     1:     docEncoder =
     1:       do_CreateInstance(PromiseFlatCString(
     1:         nsDependentCString(NS_DOC_ENCODER_CONTRACTID_BASE) +
     1:         NS_ConvertUTF16toUTF8(contentType)
     1:       ).get());
 46309:   }
 99884:   if (!docEncoder) {
     1:     // This could be some type for which we create a synthetic document.  Try
     1:     // again as XML
     1:     contentType.AssignLiteral("application/xml");
     1:     docEncoder = do_CreateInstance(NS_DOC_ENCODER_CONTRACTID_BASE "application/xml");
     1:   }
     1: 
     1:   NS_ENSURE_TRUE(docEncoder, NS_ERROR_FAILURE);
     1: 
108991:   uint32_t flags = nsIDocumentEncoder::OutputEncodeBasicEntities |
     1:                    // Output DOM-standard newlines
     1:                    nsIDocumentEncoder::OutputLFLineBreak |
 46309:                    // Don't do linebreaking that's not present in
 46309:                    // the source
 96773:                    nsIDocumentEncoder::OutputRaw |
 96773:                    // Only check for mozdirty when necessary (bug 599983)
 96773:                    nsIDocumentEncoder::OutputIgnoreMozDirty;
 96773: 
 96773:   if (IsEditable()) {
 96773:     nsCOMPtr<nsIEditor> editor;
 96773:     GetEditorInternal(getter_AddRefs(editor));
 96773:     if (editor && editor->OutputsMozDirty()) {
 96773:       flags &= ~nsIDocumentEncoder::OutputIgnoreMozDirty;
 96773:     }
 96773:   }
 96773: 
 96773:   nsresult rv = docEncoder->NativeInit(doc, contentType, flags);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
 82125:   if (aIncludeSelf) {
 82125:     docEncoder->SetNativeNode(this);
 82125:   } else {
 46309:     docEncoder->SetNativeContainerNode(this);
 82125:   }
 82125:   rv = docEncoder->EncodeToString(aMarkup);
 82125:   if (!aIncludeSelf) {
 47922:     doc->SetCachedEncoder(docEncoder.forget());
 82125:   }
 46309:   return rv;
     1: }
     1: 
116224: void
116224: nsGenericHTMLElement::GetInnerHTML(nsAString& aInnerHTML, ErrorResult& aError)
116224: {
116224:   aError = GetMarkup(false, aInnerHTML);
 82125: }
 82125: 
121921: void
121921: nsGenericHTMLElement::GetOuterHTML(nsAString& aOuterHTML, ErrorResult& aError)
121921: {
121921:   aError = GetMarkup(true, aOuterHTML);
 82125: }
 82125: 
 74627: void
 74627: nsGenericHTMLElement::FireMutationEventsForDirectParsing(nsIDocument* aDoc,
 74627:                                                          nsIContent* aDest,
108991:                                                          int32_t aOldChildCount)
 74627: {
 74627:   // Fire mutation events. Optimize for the case when there are no listeners
108991:   int32_t newChildCount = aDest->GetChildCount();
 74627:   if (newChildCount && nsContentUtils::
 74627:         HasMutationListeners(aDoc, NS_EVENT_BITS_MUTATION_NODEINSERTED)) {
 74627:     nsAutoTArray<nsCOMPtr<nsIContent>, 50> childNodes;
 74627:     NS_ASSERTION(newChildCount - aOldChildCount >= 0,
 74627:                  "What, some unexpected dom mutation has happened?");
 74627:     childNodes.SetCapacity(newChildCount - aOldChildCount);
 77283:     for (nsIContent* child = aDest->GetFirstChild();
 77283:          child;
 77283:          child = child->GetNextSibling()) {
 77283:       childNodes.AppendElement(child);
 74627:     }
121948:     Element::FireNodeInserted(aDoc, aDest, childNodes);
 74627:   }
 74627: }
 74627: 
116224: void
116224: nsGenericHTMLElement::SetInnerHTML(const nsAString& aInnerHTML,
116224:                                    ErrorResult& aError)
     1: {
 80526:   nsIDocument* doc = OwnerDoc();
 41754: 
 69573:   // Batch possible DOMSubtreeModified events.
106838:   mozAutoSubtreeModified subtree(doc, nullptr);
 69573: 
 69573:   FireNodeRemovedForChildren();
 69573: 
 74625:   // Needed when innerHTML is used in combination with contenteditable
 80486:   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, true);
     1: 
 69573:   // Remove childnodes.
108991:   uint32_t childCount = GetChildCount();
 94465:   nsAutoMutationBatch mb(this, true, false);
108991:   for (uint32_t i = 0; i < childCount; ++i) {
 80486:     RemoveChildAt(0, true);
 69573:   }
 94465:   mb.RemovalDone();
     1: 
 75206:   nsAutoScriptLoaderDisabler sld(doc);
 75206: 
 74622:   if (doc->IsHTML()) {
108991:     int32_t oldChildCount = GetChildCount();
116224:     aError = nsContentUtils::ParseFragmentHTML(aInnerHTML,
 57561:                                                this,
 57561:                                                Tag(),
 57561:                                                GetNameSpaceID(),
 57561:                                                doc->GetCompatibilityMode() ==
 57561:                                                  eCompatibility_NavQuirks,
 80486:                                                true);
 94465:     mb.NodesAdded();
 41754:     // HTML5 parser has notified, but not fired mutation events.
 74627:     FireMutationEventsForDirectParsing(doc, this, oldChildCount);
 41754:   } else {
 82125:     nsCOMPtr<nsIDOMDocumentFragment> df;
116224:     aError = nsContentUtils::CreateContextualFragment(this, aInnerHTML,
 80486:                                                       true,
     1:                                                       getter_AddRefs(df));
 41240:     nsCOMPtr<nsINode> fragment = do_QueryInterface(df);
116224:     if (!aError.Failed()) {
 78082:       // Suppress assertion about node removal mutation events that can't have
 78082:       // listeners anyway, because no one has had the chance to register mutation
 78082:       // listeners on the fragment that comes from the parser.
 78082:       nsAutoScriptBlockerSuppressNodeRemoved scriptBlocker;
 78082: 
119415:       static_cast<nsINode*>(this)->AppendChild(*fragment, aError);
 94465:       mb.NodesAdded();
     1:     }
 74623:   }
     1: }
     1: 
121921: void
121921: nsGenericHTMLElement::SetOuterHTML(const nsAString& aOuterHTML,
121921:                                    ErrorResult& aError)
 82125: {
119415:   nsCOMPtr<nsINode> parent = GetParentNode();
 82125:   if (!parent) {
121921:     return;
 82125:   }
 82125: 
 82125:   if (parent->NodeType() == nsIDOMNode::DOCUMENT_NODE) {
121921:     aError.Throw(NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR);
121921:     return;
 82125:   }
 82125: 
 82125:   if (OwnerDoc()->IsHTML()) {
 82125:     nsIAtom* localName;
108991:     int32_t namespaceID;
 82125:     if (parent->IsElement()) {
 98964:       localName = static_cast<nsIContent*>(parent.get())->Tag();
 98964:       namespaceID = static_cast<nsIContent*>(parent.get())->GetNameSpaceID();
 82125:     } else {
 82125:       NS_ASSERTION(parent->NodeType() == nsIDOMNode::DOCUMENT_FRAGMENT_NODE,
 82125:         "How come the parent isn't a document, a fragment or an element?");
 82125:       localName = nsGkAtoms::body;
 82125:       namespaceID = kNameSpaceID_XHTML;
 82125:     }
 82125:     nsCOMPtr<nsIDOMDocumentFragment> df;
121921:     aError = NS_NewDocumentFragment(getter_AddRefs(df),
 82125:                                     OwnerDoc()->NodeInfoManager());
121921:     if (aError.Failed()) {
121921:       return;
121921:     }
 82125:     nsCOMPtr<nsIContent> fragment = do_QueryInterface(df);
 82125:     nsContentUtils::ParseFragmentHTML(aOuterHTML,
 82125:                                       fragment,
 82125:                                       localName,
 82125:                                       namespaceID,
 82125:                                       OwnerDoc()->GetCompatibilityMode() ==
 82125:                                         eCompatibility_NavQuirks,
 90092:                                       true);
 94465:     nsAutoMutationBatch mb(parent, true, false);
121921:     parent->ReplaceChild(*fragment, *this, aError);
121921:     return;
 82125:   }
 82125: 
 82125:   nsCOMPtr<nsINode> context;
 82125:   if (parent->IsElement()) {
 82125:     context = parent;
 82125:   } else {
 82125:     NS_ASSERTION(parent->NodeType() == nsIDOMNode::DOCUMENT_FRAGMENT_NODE,
 82125:       "How come the parent isn't a document, a fragment or an element?");
 94340:     nsCOMPtr<nsINodeInfo> info =
 82125:       OwnerDoc()->NodeInfoManager()->GetNodeInfo(nsGkAtoms::body,
106838:                                                  nullptr,
 82125:                                                  kNameSpaceID_XHTML,
 82125:                                                  nsIDOMNode::ELEMENT_NODE);
 82125:     context = NS_NewHTMLBodyElement(info.forget(), FROM_PARSER_FRAGMENT);
 82125:   }
 82125: 
 82125:   nsCOMPtr<nsIDOMDocumentFragment> df;
121921:   aError = nsContentUtils::CreateContextualFragment(context,
 82125:                                                     aOuterHTML,
 90092:                                                     true,
 82125:                                                     getter_AddRefs(df));
121921:   if (aError.Failed()) {
121921:     return;
121921:   }
 82125:   nsCOMPtr<nsINode> fragment = do_QueryInterface(df);
 94465:   nsAutoMutationBatch mb(parent, true, false);
121921:   parent->ReplaceChild(*fragment, *this, aError);
 82125: }
 82125: 
 74627: enum nsAdjacentPosition {
 74627:   eBeforeBegin,
 74627:   eAfterBegin,
 74627:   eBeforeEnd,
 74627:   eAfterEnd
 74627: };
 74627: 
 81041: NS_IMETHODIMP
 74627: nsGenericHTMLElement::InsertAdjacentHTML(const nsAString& aPosition,
 74627:                                          const nsAString& aText)
 74627: {
121921:   ErrorResult rv;
121921:   InsertAdjacentHTML(aPosition, aText, rv);
121921:   return rv.ErrorCode();
121921: }
121921: 
121921: void
121921: nsGenericHTMLElement::InsertAdjacentHTML(const nsAString& aPosition,
121921:                                          const nsAString& aText,
121921:                                          ErrorResult& aError)
121921: {
 74627:   nsAdjacentPosition position;
 74627:   if (aPosition.LowerCaseEqualsLiteral("beforebegin")) {
 74627:     position = eBeforeBegin;
 74627:   } else if (aPosition.LowerCaseEqualsLiteral("afterbegin")) {
 74627:     position = eAfterBegin;
 74627:   } else if (aPosition.LowerCaseEqualsLiteral("beforeend")) {
 74627:     position = eBeforeEnd;
 74627:   } else if (aPosition.LowerCaseEqualsLiteral("afterend")) {
 74627:     position = eAfterEnd;
 74627:   } else {
121921:     aError.Throw(NS_ERROR_DOM_SYNTAX_ERR);
121921:     return;
 74627:   }
 74627: 
 74627:   nsCOMPtr<nsIContent> destination;
 74627:   if (position == eBeforeBegin || position == eAfterEnd) {
 74627:     destination = GetParent();
 74627:     if (!destination) {
121921:       aError.Throw(NS_ERROR_DOM_NO_MODIFICATION_ALLOWED_ERR);
121921:       return;
 74627:     }
 74627:   } else {
 74627:     destination = this;
 74627:   }
 74627: 
 80526:   nsIDocument* doc = OwnerDoc();
 74627: 
 75206:   // Needed when insertAdjacentHTML is used in combination with contenteditable
 80486:   mozAutoDocUpdate updateBatch(doc, UPDATE_CONTENT_MODEL, true);
 75206:   nsAutoScriptLoaderDisabler sld(doc);
 75206:   
 74627:   // Batch possible DOMSubtreeModified events.
106838:   mozAutoSubtreeModified subtree(doc, nullptr);
 74627: 
 74627:   // Parse directly into destination if possible
 94465:   if (doc->IsHTML() && !OwnerDoc()->MayHaveDOMMutationObservers() &&
 74627:       (position == eBeforeEnd ||
 74627:        (position == eAfterEnd && !GetNextSibling()) ||
 74627:        (position == eAfterBegin && !GetFirstChild()))) {
108991:     int32_t oldChildCount = destination->GetChildCount();
108991:     int32_t contextNs = destination->GetNameSpaceID();
 74627:     nsIAtom* contextLocal = destination->Tag();
 74627:     if (contextLocal == nsGkAtoms::html && contextNs == kNameSpaceID_XHTML) {
 74627:       // For compat with IE6 through IE9. Willful violation of HTML5 as of
 74627:       // 2011-04-06. CreateContextualFragment does the same already.
 74627:       // Spec bug: http://www.w3.org/Bugs/Public/show_bug.cgi?id=12434
 74627:       contextLocal = nsGkAtoms::body;
 74627:     }
121921:     aError = nsContentUtils::ParseFragmentHTML(aText,
 74627:                                                destination,
 74627:                                                contextLocal,
 74627:                                                contextNs,
 74627:                                                doc->GetCompatibilityMode() ==
 74627:                                                  eCompatibility_NavQuirks,
 80486:                                                true);
 74627:     // HTML5 parser has notified, but not fired mutation events.
 74627:     FireMutationEventsForDirectParsing(doc, destination, oldChildCount);
121921:     return;
 74627:   }
 74627: 
 74627:   // couldn't parse directly
 74627:   nsCOMPtr<nsIDOMDocumentFragment> df;
121921:   aError = nsContentUtils::CreateContextualFragment(destination,
 74627:                                                     aText,
 80486:                                                     true,
 74627:                                                     getter_AddRefs(df));
121921:   if (aError.Failed()) {
121921:     return;
121921:   }
121921: 
 74627:   nsCOMPtr<nsINode> fragment = do_QueryInterface(df);
 74627: 
 75206:   // Suppress assertion about node removal mutation events that can't have
 75206:   // listeners anyway, because no one has had the chance to register mutation
 75206:   // listeners on the fragment that comes from the parser.
 75206:   nsAutoScriptBlockerSuppressNodeRemoved scriptBlocker;
 75206: 
 94465:   nsAutoMutationBatch mb(destination, true, false);
 74627:   switch (position) {
 74627:     case eBeforeBegin:
121921:       destination->InsertBefore(*fragment, this, aError);
 74627:       break;
 74627:     case eAfterBegin:
121921:       static_cast<nsINode*>(this)->InsertBefore(*fragment, GetFirstChild(),
121921:                                                 aError);
 74627:       break;
 74627:     case eBeforeEnd:
121921:       static_cast<nsINode*>(this)->AppendChild(*fragment, aError);
 74627:       break;
 74627:     case eAfterEnd:
121921:       destination->InsertBefore(*fragment, GetNextSibling(), aError);
 74627:       break;
 74627:   }
121921: }
121921: 
121921: bool
121921: nsGenericHTMLElement::Spellcheck()
     1: {
     1:   // Has the state has been explicitly set?
 33329:   nsIContent* node;
 33329:   for (node = this; node; node = node->GetParent()) {
 33329:     if (node->IsHTML()) {
     1:       static nsIContent::AttrValuesArray strings[] =
106838:         {&nsGkAtoms::_true, &nsGkAtoms::_false, nullptr};
 33329:       switch (node->FindAttrValueIn(kNameSpaceID_None, nsGkAtoms::spellcheck,
     1:                                     strings, eCaseMatters)) {
     1:         case 0:                         // spellcheck = "true"
121921:           return true;
     1:         case 1:                         // spellcheck = "false"
121921:           return false;
     1:       }
     1:     }
     1:   }
     1: 
     1:   // Is this a chrome element?
 80526:   if (nsContentUtils::IsChromeDoc(OwnerDoc())) {
121921:     return false;                       // Not spellchecked by default
     1:   }
     1: 
     1:   if (IsCurrentBodyElement()) {
  2896:     nsCOMPtr<nsIHTMLDocument> doc = do_QueryInterface(GetCurrentDoc());
121921:     return doc && doc->IsEditingOn();
     1:   }
     1: 
     1:   // Is this element editable?
     1:   nsCOMPtr<nsIFormControl> formControl = do_QueryInterface(this);
     1:   if (!formControl) {
121921:     return false;                       // Not spellchecked by default
     1:   }
     1: 
     1:   // Is this a multiline plaintext input?
108991:   int32_t controlType = formControl->GetType();
     1:   if (controlType == NS_FORM_TEXTAREA) {
121921:     return true;             // Spellchecked by default
     1:   }
     1: 
 42192:   // Is this anything other than an input text?
 42192:   // Other inputs are not spellchecked.
     1:   if (controlType != NS_FORM_INPUT_TEXT) {
121921:     return false;                       // Not spellchecked by default
     1:   }
     1: 
 42192:   // Does the user want input text spellchecked by default?
     1:   // NOTE: Do not reflect a pref value of 0 back to the DOM getter.
     1:   // The web page should not know if the user has disabled spellchecking.
     1:   // We'll catch this in the editor itself.
108991:   int32_t spellcheckLevel = Preferences::GetInt("layout.spellcheckDefault", 1);
121921:   return spellcheckLevel == 2;           // "Spellcheck multi- and single-line"
     1: }
     1: 
 79445: bool
     1: nsGenericHTMLElement::InNavQuirksMode(nsIDocument* aDoc)
     1: {
     1:   return aDoc && aDoc->GetCompatibilityMode() == eCompatibility_NavQuirks;
     1: }
     1: 
  2896: void
 79445: nsGenericHTMLElement::UpdateEditableState(bool aNotify)
  2896: {
  2896:   // XXX Should we do this only when in a document?
  2896:   ContentEditableTristate value = GetContentEditableValue();
  2896:   if (value != eInherit) {
 71121:     DoSetEditableFlag(!!value, aNotify);
  2896:     return;
  2896:   }
  2896: 
 71121:   nsStyledElement::UpdateEditableState(aNotify);
  2896: }
  2896: 
108036: nsEventStates
108036: nsGenericHTMLElement::IntrinsicState() const
108036: {
108036:   nsEventStates state = nsGenericHTMLElementBase::IntrinsicState();
108036: 
108036:   if (GetDirectionality() == eDir_RTL) {
108036:     state |= NS_EVENT_STATE_RTL;
108036:     state &= ~NS_EVENT_STATE_LTR;
108036:   } else { // at least for HTML, directionality is exclusively LTR or RTL
108036:     NS_ASSERTION(GetDirectionality() == eDir_LTR,
108036:                  "HTML element's directionality must be either RTL or LTR");
108036:     state |= NS_EVENT_STATE_LTR;
108036:     state &= ~NS_EVENT_STATE_RTL;
108036:   }
108036: 
108036:   return state;
108036: }
108036: 
     1: nsresult
     1: nsGenericHTMLElement::BindToTree(nsIDocument* aDocument, nsIContent* aParent,
     1:                                  nsIContent* aBindingParent,
 79445:                                  bool aCompileEventHandlers)
     1: {
  4306:   nsresult rv = nsGenericHTMLElementBase::BindToTree(aDocument, aParent,
     1:                                                      aBindingParent,
     1:                                                      aCompileEventHandlers);
     1:   NS_ENSURE_SUCCESS(rv, rv);
     1: 
  4306:   if (aDocument) {
101092:     if (HasProperties()) {
101092:       HTMLPropertiesCollection* properties = 
101092:         static_cast<HTMLPropertiesCollection*>(GetProperty(nsGkAtoms::microdataProperties));
101092:       if (properties) {
101092:         properties->SetDocument(aDocument);
101092:       }
101092:     }
 67818:     RegAccessKey();
 67609:     if (HasName()) {
 43079:       aDocument->
 43079:         AddToNameTable(this, GetParsedAttr(nsGkAtoms::name)->GetAtomValue());
 43079:     }
  4306:     if (HasFlag(NODE_IS_EDITABLE) && GetContentEditableValue() == eTrue) {
  2896:       nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(aDocument);
  2896:       if (htmlDocument) {
  2896:         htmlDocument->ChangeContentEditableCount(this, +1);
  2896:       }
  2896:     }
     1:   }
     1: 
     1:   return rv;
     1: }
     1: 
  2896: void
 79445: nsGenericHTMLElement::UnbindFromTree(bool aDeep, bool aNullParent)
  2896: {
 67818:   if (IsInDoc()) {
 67818:     UnregAccessKey();
 67818:   }
 67818:   
101092:   if(HasProperties()) {
101092:     HTMLPropertiesCollection* properties = 
101092:       static_cast<HTMLPropertiesCollection*>(GetProperty(nsGkAtoms::microdataProperties));
101092:     if (properties) {
106838:       properties->SetDocument(nullptr);
101092:     }
101092:   }
101092: 
 48037:   RemoveFromNameTable();
 48037: 
  2896:   if (GetContentEditableValue() == eTrue) {
  2896:     nsCOMPtr<nsIHTMLDocument> htmlDocument = do_QueryInterface(GetCurrentDoc());
  2896:     if (htmlDocument) {
  2896:       htmlDocument->ChangeContentEditableCount(this, -1);
  2896:     }
  2896:   }
  2896: 
 43079:   nsStyledElement::UnbindFromTree(aDeep, aNullParent);
  2896: }
  2896: 
 34395: nsHTMLFormElement*
 51301: nsGenericHTMLElement::FindAncestorForm(nsHTMLFormElement* aCurrentForm)
     1: {
 51301:   NS_ASSERTION(!HasAttr(kNameSpaceID_None, nsGkAtoms::form),
 51301:                "FindAncestorForm should not be called if @form is set!");
 51301: 
  3597:   // Make sure we don't end up finding a form that's anonymous from
  3597:   // our point of view.
  3597:   nsIContent* bindingParent = GetBindingParent();
  3597: 
     1:   nsIContent* content = this;
  3597:   while (content != bindingParent && content) {
     1:     // If the current ancestor is a form, return it as our form
 82292:     if (content->IsHTML(nsGkAtoms::form)) {
  4206: #ifdef DEBUG
  4206:       if (!nsContentUtils::IsInSameAnonymousTree(this, content)) {
  4206:         // It's possible that we started unbinding at |content| or
  4206:         // some ancestor of it, and |content| and |this| used to all be
  4206:         // anonymous.  Check for this the hard way.
  4206:         for (nsIContent* child = this; child != content;
  4206:              child = child->GetParent()) {
  4206:           NS_ASSERTION(child->GetParent()->IndexOf(child) != -1,
  3597:                        "Walked too far?");
  4206:         }
  4206:       }
  4206: #endif
 34395:       return static_cast<nsHTMLFormElement*>(content);
     1:     }
     1: 
     1:     nsIContent *prevContent = content;
     1:     content = prevContent->GetParent();
     1: 
     1:     if (!content && aCurrentForm) {
     1:       // We got to the root of the subtree we're in, and we're being removed
     1:       // from the DOM (the only time we get into this method with a non-null
     1:       // aCurrentForm).  Check whether aCurrentForm is in the same subtree.  If
     1:       // it is, we want to return aCurrentForm, since this case means that
     1:       // we're one of those inputs-in-a-table that have a hacked mForm pointer
     1:       // and a subtree containing both us and the form got removed from the
     1:       // DOM.
 34395:       if (nsContentUtils::ContentIsDescendantOf(aCurrentForm, prevContent)) {
 34395:         return aCurrentForm;
 34395:       }
     1:     }
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
 79445: bool
   723: nsGenericHTMLElement::CheckHandleEventForAnchorsPreconditions(nsEventChainVisitor& aVisitor)
     1: {
     1:   NS_PRECONDITION(nsCOMPtr<nsILink>(do_QueryInterface(this)),
     1:                   "should be called only when |this| implements |nsILink|");
     1: 
     1:   if (!aVisitor.mPresContext) {
     1:     // We need a pres context to do link stuff. Some events (e.g. mutation
     1:     // events) don't have one.
     1:     // XXX: ideally, shouldn't we be able to do what we need without one?
 80486:     return false; 
     1:   }
     1: 
     1:   //Need to check if we hit an imagemap area and if so see if we're handling
     1:   //the event on that map or on a link farther up the tree.  If we're on a
     1:   //link farther up, do nothing.
 68780:   nsCOMPtr<nsIContent> target = aVisitor.mPresContext->EventStateManager()->
 68780:     GetEventTargetContent(aVisitor.mEvent);
     1: 
114050:   return !target || !target->IsHTML(nsGkAtoms::area) || IsHTML(nsGkAtoms::area);
   723: }
   723: 
   723: nsresult
   723: nsGenericHTMLElement::PreHandleEventForAnchors(nsEventChainPreVisitor& aVisitor)
   723: {
  4306:   nsresult rv = nsGenericHTMLElementBase::PreHandleEvent(aVisitor);
   723:   NS_ENSURE_SUCCESS(rv, rv);
   723: 
   723:   if (!CheckHandleEventForAnchorsPreconditions(aVisitor)) {
   723:     return NS_OK;
   723:   }
   723: 
   723:   return PreHandleEventForLinks(aVisitor);
   723: }
   723: 
   723: nsresult
   723: nsGenericHTMLElement::PostHandleEventForAnchors(nsEventChainPostVisitor& aVisitor)
   723: {
   723:   if (!CheckHandleEventForAnchorsPreconditions(aVisitor)) {
     1:     return NS_OK;
     1:   }
     1: 
     1:   return PostHandleEventForLinks(aVisitor);
     1: }
     1: 
 79445: bool
     1: nsGenericHTMLElement::IsHTMLLink(nsIURI** aURI) const
     1: {
     1:   NS_PRECONDITION(aURI, "Must provide aURI out param");
     1: 
 30307:   *aURI = GetHrefURIForAnchors().get();
     1:   // We promise out param is non-null if we return true, so base rv on it
106838:   return *aURI != nullptr;
     1: }
     1: 
 30307: already_AddRefed<nsIURI>
 30307: nsGenericHTMLElement::GetHrefURIForAnchors() const
     1: {
     1:   // This is used by the three nsILink implementations and
     1:   // nsHTMLStyleElement.
     1: 
     1:   // Get href= attribute (relative URI).
     1: 
     1:   // We use the nsAttrValue's copy of the URI string to avoid copying.
 30307:   nsCOMPtr<nsIURI> uri;
106838:   GetURIAttr(nsGkAtoms::href, nullptr, getter_AddRefs(uri));
 30307: 
 30307:   return uri.forget();
     1: }
     1: 
     1: nsresult
123733: nsGenericHTMLElement::BeforeSetAttr(int32_t aNamespaceID, nsIAtom* aName,
123733:                                     const nsAttrValueOrString* aValue,
123733:                                     bool aNotify)
123733: {
123733:   if (aNamespaceID == kNameSpaceID_None &&
123733:       aName == nsGkAtoms::dir &&
123733:       HasDirAuto()) {
123733:       // setting dir on an element that currently has dir=auto
123733:     WalkDescendantsClearAncestorDirAuto(this);
123733:     SetHasDirAuto();
123733:   }
123733: 
123733:   return nsGenericHTMLElementBase::BeforeSetAttr(aNamespaceID, aName,
123733:                                                  aValue, aNotify);
123733: }
123733: 
123733: nsresult
108991: nsGenericHTMLElement::AfterSetAttr(int32_t aNamespaceID, nsIAtom* aName,
 90061:                                    const nsAttrValue* aValue, bool aNotify)
     1: {
     1:   if (aNamespaceID == kNameSpaceID_None) {
121900:     uint32_t eventType = EventNameType_HTML;
121900:     if (mNodeInfo->Equals(nsGkAtoms::body) ||
121900:         mNodeInfo->Equals(nsGkAtoms::frameset)) {
121900:       eventType |= EventNameType_HTMLBodyOrFramesetOnly;
121900:     }
121900:     if (nsContentUtils::IsEventAttributeName(aName, eventType) &&
 90061:         aValue) {
 90061:       NS_ABORT_IF_FALSE(aValue->Type() == nsAttrValue::eString,
 90061:         "Expected string value for script body");
110743:       nsresult rv = SetEventHandler(aName, aValue->GetStringValue());
     1:       NS_ENSURE_SUCCESS(rv, rv);
     1:     }
     1:     else if (aNotify && aName == nsGkAtoms::spellcheck) {
     1:       SyncEditorsOnSubtree(this);
     1:     }
108036:     else if (aName == nsGkAtoms::dir) {
123733:       Directionality dir = eDir_LTR;
123733:       if (aValue && aValue->Type() == nsAttrValue::eEnum) {
108036:         SetHasValidDir();
123733:         Directionality dirValue = (Directionality)aValue->GetEnumValue();
123733:         if (dirValue == eDir_Auto) {
123733:           SetHasDirAuto();
123733:           ClearHasFixedDir();
123733:         } else {
123733:           dir = dirValue;
108036:           SetDirectionality(dir, aNotify);
123733:           ClearHasDirAuto();
123733:           ClearHasDirAutoSet();
123733:           SetHasFixedDir();
123733:         }
108036:       } else {
108036:         ClearHasValidDir();
123733:         ClearHasFixedDir();
123733:         if (NodeInfo()->Equals(nsGkAtoms::bdi)) {
123733:           SetHasDirAuto();
123733:         } else {
108036:           dir = RecomputeDirectionality(this, aNotify);
108036:         }
123733:       }
108036:       SetDirectionalityOnDescendants(this, dir, aNotify);
108036:     }
     1:   }
     1: 
  4306:   return nsGenericHTMLElementBase::AfterSetAttr(aNamespaceID, aName,
     1:                                                 aValue, aNotify);
     1: }
     1: 
 74595: nsEventListenerManager*
 79415: nsGenericHTMLElement::GetEventListenerManagerForAttr(nsIAtom* aAttrName,
 79445:                                                      bool* aDefer)
     1: {
     1:   // Attributes on the body and frameset tags get set on the global object
 79415:   if ((mNodeInfo->Equals(nsGkAtoms::body) ||
 79415:        mNodeInfo->Equals(nsGkAtoms::frameset)) &&
 79415:       // We only forward some event attributes from body/frameset to window
 79415:       (0
 79415: #define EVENT(name_, id_, type_, struct_) /* nothing */
 79415: #define FORWARDED_EVENT(name_, id_, type_, struct_) \
 79415:        || nsGkAtoms::on##name_ == aAttrName
 79415: #define WINDOW_EVENT FORWARDED_EVENT
 79415: #include "nsEventNameList.h"
 79415: #undef WINDOW_EVENT
 79415: #undef FORWARDED_EVENT
 79415: #undef EVENT
 79415:        )
 79415:       ) {
     1:     nsPIDOMWindow *win;
     1: 
     1:     // If we have a document, and it has a window, add the event
     1:     // listener on the window (the inner window). If not, proceed as
     1:     // normal.
     1:     // XXXbz sXBL/XBL2 issue: should we instead use GetCurrentDoc() here,
     1:     // override BindToTree for those classes and munge event listeners there?
 80526:     nsIDocument *document = OwnerDoc();
 14919: 
 14919:     // FIXME (https://bugzilla.mozilla.org/show_bug.cgi?id=431767)
 14919:     // nsDocument::GetInnerWindow can return an outer window in some cases,
 14919:     // we don't want to stick an event listener on an outer window, so
 77149:     // bail if it does.  See similar code in nsHTMLBodyElement and
 77149:     // nsHTMLFramesetElement
 80486:     *aDefer = false;
 80527:     if ((win = document->GetInnerWindow()) && win->IsInnerWindow()) {
 72326:       nsCOMPtr<nsIDOMEventTarget> piTarget(do_QueryInterface(win));
 74595: 
 80486:       return piTarget->GetListenerManager(true);
 74595:     }
 74595: 
106838:     return nullptr;
 74595:   }
 74595: 
 79415:   return nsGenericHTMLElementBase::GetEventListenerManagerForAttr(aAttrName,
 79415:                                                                   aDefer);
     1: }
     1: 
125101: // FIXME (https://bugzilla.mozilla.org/show_bug.cgi?id=431767)
125101: // nsDocument::GetInnerWindow can return an outer window in some
125101: // cases.  We don't want to stick an event listener on an outer
125101: // window, so bail if it does.  See also similar code in
125101: // nsGenericHTMLElement::GetEventListenerManagerForAttr.
125101: #define EVENT(name_, id_, type_, struct_) /* nothing; handled by nsINode */
125101: #define FORWARDED_EVENT(name_, id_, type_, struct_)                           \
125101: EventHandlerNonNull*                                                          \
125101: nsGenericHTMLElement::GetOn##name_()                                          \
125101: {                                                                             \
125101:   if (Tag() == nsGkAtoms::body || Tag() == nsGkAtoms::frameset) {             \
125101:     /* XXXbz note to self: add tests for this! */                             \
125101:     nsPIDOMWindow* win = OwnerDoc()->GetInnerWindow();                        \
125101:     if (win && win->IsInnerWindow()) {                                        \
125101:       nsCOMPtr<nsISupports> supports = do_QueryInterface(win);                \
125101:       nsGlobalWindow* globalWin = nsGlobalWindow::FromSupports(supports);     \
125101:       return globalWin->GetOn##name_();                                       \
125101:     }                                                                         \
125101:     return nullptr;                                                           \
125101:   }                                                                           \
125101:                                                                               \
125101:   return nsINode::GetOn##name_();                                             \
125101: }                                                                             \
125101: void                                                                          \
125101: nsGenericHTMLElement::SetOn##name_(EventHandlerNonNull* handler,              \
125101:                                    ErrorResult& error)                        \
125101: {                                                                             \
125101:   if (Tag() == nsGkAtoms::body || Tag() == nsGkAtoms::frameset) {             \
125101:     nsPIDOMWindow* win = OwnerDoc()->GetInnerWindow();                        \
125101:     if (!win || !win->IsInnerWindow()) {                                      \
125101:       return;                                                                 \
125101:     }                                                                         \
125101:                                                                               \
125101:     nsCOMPtr<nsISupports> supports = do_QueryInterface(win);                  \
125101:     nsGlobalWindow* globalWin = nsGlobalWindow::FromSupports(supports);       \
125101:     return globalWin->SetOn##name_(handler, error);                           \
125101:   }                                                                           \
125101:                                                                               \
125101:   return nsINode::SetOn##name_(handler, error);                               \
125101: }
125101: #define ERROR_EVENT(name_, id_, type_, struct_)                               \
125101: already_AddRefed<EventHandlerNonNull>                                         \
125101: nsGenericHTMLElement::GetOn##name_()                                          \
125101: {                                                                             \
125101:   if (Tag() == nsGkAtoms::body || Tag() == nsGkAtoms::frameset) {             \
125101:     /* XXXbz note to self: add tests for this! */                             \
125101:     nsPIDOMWindow* win = OwnerDoc()->GetInnerWindow();                        \
125101:     if (win && win->IsInnerWindow()) {                                        \
125101:       nsCOMPtr<nsISupports> supports = do_QueryInterface(win);                \
125101:       nsGlobalWindow* globalWin = nsGlobalWindow::FromSupports(supports);     \
125101:       OnErrorEventHandlerNonNull* errorHandler = globalWin->GetOn##name_();   \
125101:       if (errorHandler) {                                                     \
125101:         nsRefPtr<EventHandlerNonNull> handler =                               \
125101:           new EventHandlerNonNull(errorHandler);                              \
125101:         return handler.forget();                                              \
125101:       }                                                                       \
125101:     }                                                                         \
125101:     return nullptr;                                                           \
125101:   }                                                                           \
125101:                                                                               \
125101:   nsRefPtr<EventHandlerNonNull> handler = nsINode::GetOn##name_();            \
125101:   return handler.forget();                                                    \
125101: }                                                                             \
125101: void                                                                          \
125101: nsGenericHTMLElement::SetOn##name_(EventHandlerNonNull* handler,              \
125101:                                    ErrorResult& error)                        \
125101: {                                                                             \
125101:   if (Tag() == nsGkAtoms::body || Tag() == nsGkAtoms::frameset) {             \
125101:     nsPIDOMWindow* win = OwnerDoc()->GetInnerWindow();                        \
125101:     if (!win || !win->IsInnerWindow()) {                                      \
125101:       return;                                                                 \
125101:     }                                                                         \
125101:                                                                               \
125101:     nsCOMPtr<nsISupports> supports = do_QueryInterface(win);                  \
125101:     nsGlobalWindow* globalWin = nsGlobalWindow::FromSupports(supports);       \
125409:     nsRefPtr<OnErrorEventHandlerNonNull> errorHandler;                        \
125409:     if (handler) {                                                            \
125409:       errorHandler = new OnErrorEventHandlerNonNull(handler);                 \
125409:     }                                                                         \
125101:     return globalWin->SetOn##name_(errorHandler, error);                      \
125101:   }                                                                           \
125101:                                                                               \
125101:   return nsINode::SetOn##name_(handler, error);                               \
125101: }
125101: #include "nsEventNameList.h"
125101: #undef ERROR_EVENT
125101: #undef FORWARDED_EVENT
125101: #undef EVENT
125101: 
     1: nsresult
108991: nsGenericHTMLElement::SetAttr(int32_t aNameSpaceID, nsIAtom* aName,
  2896:                               nsIAtom* aPrefix, const nsAString& aValue,
 79445:                               bool aNotify)
  2896: {
 79445:   bool contentEditable = aNameSpaceID == kNameSpaceID_None &&
  2896:                            aName == nsGkAtoms::contenteditable;
 79445:   bool accessKey = aName == nsGkAtoms::accesskey && 
 67818:                      aNameSpaceID == kNameSpaceID_None;
 67818: 
108991:   int32_t change = 0;
  2896:   if (contentEditable) {
  2896:     change = GetContentEditableValue() == eTrue ? -1 : 0;
 67610:     SetMayHaveContentEditableAttr();
  2896:   }
  2896: 
 67818:   if (accessKey) {
 67818:     UnregAccessKey();
 67818:   }
 67818: 
 43079:   nsresult rv = nsStyledElement::SetAttr(aNameSpaceID, aName, aPrefix, aValue,
  2896:                                          aNotify);
  2896:   NS_ENSURE_SUCCESS(rv, rv);
  2896: 
  2896:   if (contentEditable) {
  2896:     if (aValue.IsEmpty() || aValue.LowerCaseEqualsLiteral("true")) {
  2896:       change += 1;
  2896:     }
  2896: 
  2896:     ChangeEditableState(change);
  2896:   }
  2896: 
 67818:   if (accessKey && !aValue.IsEmpty()) {
 67818:     SetFlags(NODE_HAS_ACCESSKEY);
 67818:     RegAccessKey();
 67818:   }
 67818: 
  2896:   return NS_OK;
  2896: }
  2896: 
  2896: nsresult
108991: nsGenericHTMLElement::UnsetAttr(int32_t aNameSpaceID, nsIAtom* aAttribute,
 79445:                                 bool aNotify)
     1: {
 79445:   bool contentEditable = false;
108991:   int32_t contentEditableChange = 0;
 20827: 
 30099:   // Check for event handlers
 20827:   if (aNameSpaceID == kNameSpaceID_None) {
 43079:     if (aAttribute == nsGkAtoms::name) {
 43079:       // Have to do this before clearing flag. See RemoveFromNameTable
 43079:       RemoveFromNameTable();
 67609:       ClearHasName();
 43079:     }
 43079:     else if (aAttribute == nsGkAtoms::contenteditable) {
 80486:       contentEditable = true;
 20827:       contentEditableChange = GetContentEditableValue() == eTrue ? -1 : 0;
 20827:     }
 67818:     else if (aAttribute == nsGkAtoms::accesskey) {
 67818:       // Have to unregister before clearing flag. See UnregAccessKey
 67818:       UnregAccessKey();
 67818:       UnsetFlags(NODE_HAS_ACCESSKEY);
 67818:     }
 30099:     else if (nsContentUtils::IsEventAttributeName(aAttribute,
 30099:                                                   EventNameType_HTML)) {
 80486:       nsEventListenerManager* manager = GetListenerManager(false);
     1:       if (manager) {
110743:         manager->RemoveEventHandler(aAttribute);
     1:       }
     1:     }
  2896:   }
     1: 
 20827:   nsresult rv = nsGenericHTMLElementBase::UnsetAttr(aNameSpaceID, aAttribute,
  4306:                                                     aNotify);
 20827:   NS_ENSURE_SUCCESS(rv, rv);
 20827: 
 20827:   if (contentEditable) {
 20827:     ChangeEditableState(contentEditableChange);
 20827:   }
 20827: 
 20827:   return NS_OK;
     1: }
     1: 
     1: void
     1: nsGenericHTMLElement::GetBaseTarget(nsAString& aBaseTarget) const
     1: {
 80527:   OwnerDoc()->GetBaseTarget(aBaseTarget);
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
 79445: static bool
 43079: CanHaveName(nsIAtom* aTag)
 43079: {
 43079:   return aTag == nsGkAtoms::img ||
 43079:          aTag == nsGkAtoms::form ||
 43079:          aTag == nsGkAtoms::applet ||
 43079:          aTag == nsGkAtoms::embed ||
 43079:          aTag == nsGkAtoms::object;
 43079: }
     1: 
 79445: bool
108991: nsGenericHTMLElement::ParseAttribute(int32_t aNamespaceID,
     1:                                      nsIAtom* aAttribute,
     1:                                      const nsAString& aValue,
     1:                                      nsAttrValue& aResult)
     1: {
     1:   if (aNamespaceID == kNameSpaceID_None) {
     1:     if (aAttribute == nsGkAtoms::dir) {
 80486:       return aResult.ParseEnumValue(aValue, kDirTable, false);
     1:     }
     1:   
     1:     if (aAttribute == nsGkAtoms::tabindex) {
     1:       return aResult.ParseIntWithBounds(aValue, -32768, 32767);
     1:     }
     1: 
 43079:     if (aAttribute == nsGkAtoms::name) {
     1:       // Store name as an atom.  name="" means that the element has no name,
     1:       // not that it has an emptystring as the name.
 43079:       RemoveFromNameTable();
 43079:       if (aValue.IsEmpty()) {
 67609:         ClearHasName();
 80486:         return false;
 43079:       }
 43079: 
     1:       aResult.ParseAtom(aValue);
 43079: 
 43079:       if (CanHaveName(Tag())) {
 67609:         SetHasName();
 43079:         AddToNameTable(aResult.GetAtomValue());
 43079:       }
 43079:       
 80486:       return true;
     1:     }
  2896: 
  2896:     if (aAttribute == nsGkAtoms::contenteditable) {
  2896:       aResult.ParseAtom(aValue);
 80486:       return true;
  2896:     }
101092: 
101092:     if (aAttribute == nsGkAtoms::itemref ||
101092:         aAttribute == nsGkAtoms::itemprop ||
101092:         aAttribute == nsGkAtoms::itemtype) {
101092:       aResult.ParseAtomArray(aValue);
101092:       return true;
101092:     }
     1:   }
     1: 
  4306:   return nsGenericHTMLElementBase::ParseAttribute(aNamespaceID, aAttribute,
  4306:                                                   aValue, aResult);
     1: }
     1: 
 79445: bool
109319: nsGenericHTMLElement::ParseBackgroundAttribute(int32_t aNamespaceID,
109319:                                                nsIAtom* aAttribute,
109319:                                                const nsAString& aValue,
109319:                                                nsAttrValue& aResult)
109319: {
109319:   if (aNamespaceID == kNameSpaceID_None &&
111067:       aAttribute == nsGkAtoms::background &&
111067:       !aValue.IsEmpty()) {
109319:     // Resolve url to an absolute url
109319:     nsIDocument* doc = OwnerDoc();
109319:     nsCOMPtr<nsIURI> baseURI = GetBaseURI();
109319:     nsCOMPtr<nsIURI> uri;
109319:     nsresult rv = nsContentUtils::NewURIWithDocumentCharset(
109319:         getter_AddRefs(uri), aValue, doc, baseURI);
109319:     if (NS_FAILED(rv)) {
109319:       return false;
109319:     }
109319: 
109319:     nsString value(aValue);
109319:     nsRefPtr<nsStringBuffer> buffer = nsCSSValue::BufferFromString(value);
120353:     if (MOZ_UNLIKELY(!buffer)) {
109319:       return false;
109319:     }
109319: 
109319:     mozilla::css::URLValue *url =
125124:       new mozilla::css::URLValue(uri, buffer, doc->GetDocumentURI(),
125124:                                  NodePrincipal());
109319:     aResult.SetTo(url, &aValue);
109319:     return true;
109319:   }
109319: 
109319:   return false;
109319: }
109319: 
109319: bool
     1: nsGenericHTMLElement::IsAttributeMapped(const nsIAtom* aAttribute) const
     1: {
     1:   static const MappedAttributeEntry* const map[] = {
     1:     sCommonAttributeMap
     1:   };
     1:   
 84865:   return FindAttributeDependence(aAttribute, map);
     1: }
     1: 
     1: nsMapRuleToAttributesFunc
     1: nsGenericHTMLElement::GetAttributeMappingFunction() const
     1: {
     1:   return &MapCommonAttributesInto;
     1: }
     1: 
     1: nsIFormControlFrame*
 79445: nsGenericHTMLElement::GetFormControlFrame(bool aFlushFrames)
     1: {
 36655:   if (aFlushFrames && IsInDoc()) {
 27993:     // Cause a flush of the frames, so we get up-to-date frame information
 36655:     GetCurrentDoc()->FlushPendingNotifications(Flush_Frames);
 36655:   }
 36655:   nsIFrame* frame = GetPrimaryFrame();
     1:   if (frame) {
 23554:     nsIFormControlFrame* form_frame = do_QueryFrame(frame);
     1:     if (form_frame) {
     1:       return form_frame;
     1:     }
     1: 
     1:     // If we have generated content, the primary frame will be a
     1:     // wrapper frame..  out real frame will be in its child list.
 77154:     for (frame = frame->GetFirstPrincipalChild();
     1:          frame;
     1:          frame = frame->GetNextSibling()) {
 23554:       form_frame = do_QueryFrame(frame);
     1:       if (form_frame) {
     1:         return form_frame;
     1:       }
     1:     }
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: /* static */ nsresult
     1: nsGenericHTMLElement::GetPrimaryPresState(nsGenericHTMLElement* aContent,
     1:                                           nsPresState** aPresState)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aPresState);
106838:   *aPresState = nullptr;
     1: 
     1:   nsresult result = NS_OK;
     1: 
110974:   nsAutoCString key;
 87638:   nsCOMPtr<nsILayoutHistoryState> history = GetLayoutHistoryAndKey(aContent, false, key);
     1: 
     1:   if (history) {
     1:     // Get the pres state for this key, if it doesn't exist, create one
     1:     result = history->GetState(key, aPresState);
     1:     if (!*aPresState) {
 22740:       *aPresState = new nsPresState();
     1:       result = history->AddState(key, *aPresState);
     1:     }
     1:   }
     1: 
     1:   return result;
     1: }
     1: 
     1: 
 87638: already_AddRefed<nsILayoutHistoryState>
     1: nsGenericHTMLElement::GetLayoutHistoryAndKey(nsGenericHTMLElement* aContent,
 79445:                                              bool aRead,
     1:                                              nsACString& aKey)
     1: {
     1:   //
     1:   // Get the pres shell
     1:   //
     1:   nsCOMPtr<nsIDocument> doc = aContent->GetDocument();
     1:   if (!doc) {
106838:     return nullptr;
     1:   }
     1: 
     1:   //
     1:   // Get the history (don't bother with the key if the history is not there)
     1:   //
 87638:   nsCOMPtr<nsILayoutHistoryState> history = doc->GetLayoutHistoryState();
 87638:   if (!history) {
106838:     return nullptr;
 87638:   }
 87638: 
 87638:   if (aRead && !history->HasStates()) {
106838:     return nullptr;
  3727:   }
  3727: 
     1:   //
     1:   // Get the state key
     1:   //
121998:   nsresult rv = nsContentUtils::GenerateStateKey(aContent, doc, aKey);
     1:   if (NS_FAILED(rv)) {
106838:     return nullptr;
     1:   }
     1: 
     1:   // If the state key is blank, this is anonymous content or for
     1:   // whatever reason we are not supposed to save/restore state.
     1:   if (aKey.IsEmpty()) {
106838:     return nullptr;
     1:   }
     1: 
     1:   // Add something unique to content so layout doesn't muck us up
     1:   aKey += "-C";
     1: 
 87638:   return history.forget();
     1: }
     1: 
 79445: bool
     1: nsGenericHTMLElement::RestoreFormControlState(nsGenericHTMLElement* aContent,
     1:                                               nsIFormControl* aControl)
     1: {
110974:   nsAutoCString key;
 87638:   nsCOMPtr<nsILayoutHistoryState> history = GetLayoutHistoryAndKey(aContent, true, key);
     1:   if (!history) {
 80486:     return false;
     1:   }
     1: 
     1:   nsPresState *state;
     1:   // Get the pres state for this key
 87010:   nsresult rv = history->GetState(key, &state);
 87010:   if (NS_SUCCEEDED(rv) && state) {
 79445:     bool result = aControl->RestoreState(state);
     1:     history->RemoveState(key);
     1:     return result;
     1:   }
     1: 
 80486:   return false;
     1: }
     1: 
     1: // XXX This creates a dependency between content and frames
     1: nsPresContext*
     1: nsGenericHTMLElement::GetPresContext()
     1: {
     1:   // Get the document
     1:   nsIDocument* doc = GetDocument();
     1:   if (doc) {
 82292:     // Get presentation shell.
 46225:     nsIPresShell *presShell = doc->GetShell();
     1:     if (presShell) {
     1:       return presShell->GetPresContext();
     1:     }
     1:   }
     1: 
106838:   return nullptr;
     1: }
     1: 
     1: static const nsAttrValue::EnumTable kAlignTable[] = {
     1:   { "left",      NS_STYLE_TEXT_ALIGN_LEFT },
     1:   { "right",     NS_STYLE_TEXT_ALIGN_RIGHT },
     1: 
     1:   { "top",       NS_STYLE_VERTICAL_ALIGN_TOP },
     1:   { "middle",    NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE },
     1:   { "bottom",    NS_STYLE_VERTICAL_ALIGN_BASELINE },
     1: 
     1:   { "center",    NS_STYLE_VERTICAL_ALIGN_MIDDLE_WITH_BASELINE },
     1:   { "baseline",  NS_STYLE_VERTICAL_ALIGN_BASELINE },
     1: 
     1:   { "texttop",   NS_STYLE_VERTICAL_ALIGN_TEXT_TOP },
     1:   { "absmiddle", NS_STYLE_VERTICAL_ALIGN_MIDDLE },
     1:   { "abscenter", NS_STYLE_VERTICAL_ALIGN_MIDDLE },
     1:   { "absbottom", NS_STYLE_VERTICAL_ALIGN_BOTTOM },
     1:   { 0 }
     1: };
     1: 
     1: static const nsAttrValue::EnumTable kDivAlignTable[] = {
     1:   { "left", NS_STYLE_TEXT_ALIGN_MOZ_LEFT },
     1:   { "right", NS_STYLE_TEXT_ALIGN_MOZ_RIGHT },
     1:   { "center", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
     1:   { "middle", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
     1:   { "justify", NS_STYLE_TEXT_ALIGN_JUSTIFY },
     1:   { 0 }
     1: };
     1: 
     1: static const nsAttrValue::EnumTable kFrameborderTable[] = {
     1:   { "yes", NS_STYLE_FRAME_YES },
     1:   { "no", NS_STYLE_FRAME_NO },
     1:   { "1", NS_STYLE_FRAME_1 },
     1:   { "0", NS_STYLE_FRAME_0 },
     1:   { 0 }
     1: };
     1: 
     1: static const nsAttrValue::EnumTable kScrollingTable[] = {
     1:   { "yes", NS_STYLE_FRAME_YES },
     1:   { "no", NS_STYLE_FRAME_NO },
     1:   { "on", NS_STYLE_FRAME_ON },
     1:   { "off", NS_STYLE_FRAME_OFF },
     1:   { "scroll", NS_STYLE_FRAME_SCROLL },
     1:   { "noscroll", NS_STYLE_FRAME_NOSCROLL },
     1:   { "auto", NS_STYLE_FRAME_AUTO },
     1:   { 0 }
     1: };
     1: 
     1: static const nsAttrValue::EnumTable kTableVAlignTable[] = {
     1:   { "top",     NS_STYLE_VERTICAL_ALIGN_TOP },
     1:   { "middle",  NS_STYLE_VERTICAL_ALIGN_MIDDLE },
     1:   { "bottom",  NS_STYLE_VERTICAL_ALIGN_BOTTOM },
     1:   { "baseline",NS_STYLE_VERTICAL_ALIGN_BASELINE },
     1:   { 0 }
     1: };
     1: 
 79445: bool
     1: nsGenericHTMLElement::ParseAlignValue(const nsAString& aString,
     1:                                       nsAttrValue& aResult)
     1: {
 80486:   return aResult.ParseEnumValue(aString, kAlignTable, false);
     1: }
     1: 
     1: //----------------------------------------
     1: 
     1: static const nsAttrValue::EnumTable kTableHAlignTable[] = {
     1:   { "left",   NS_STYLE_TEXT_ALIGN_LEFT },
     1:   { "right",  NS_STYLE_TEXT_ALIGN_RIGHT },
     1:   { "center", NS_STYLE_TEXT_ALIGN_CENTER },
     1:   { "char",   NS_STYLE_TEXT_ALIGN_CHAR },
     1:   { "justify",NS_STYLE_TEXT_ALIGN_JUSTIFY },
     1:   { 0 }
     1: };
     1: 
 79445: bool
     1: nsGenericHTMLElement::ParseTableHAlignValue(const nsAString& aString,
 43545:                                             nsAttrValue& aResult)
     1: {
 80486:   return aResult.ParseEnumValue(aString, kTableHAlignTable, false);
     1: }
     1: 
     1: //----------------------------------------
     1: 
 48442: // This table is used for td, th, tr, col, thead, tbody and tfoot.
     1: static const nsAttrValue::EnumTable kTableCellHAlignTable[] = {
     1:   { "left",   NS_STYLE_TEXT_ALIGN_MOZ_LEFT },
     1:   { "right",  NS_STYLE_TEXT_ALIGN_MOZ_RIGHT },
     1:   { "center", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
     1:   { "char",   NS_STYLE_TEXT_ALIGN_CHAR },
     1:   { "justify",NS_STYLE_TEXT_ALIGN_JUSTIFY },
     1:   { "middle", NS_STYLE_TEXT_ALIGN_MOZ_CENTER },
     1:   { "absmiddle", NS_STYLE_TEXT_ALIGN_CENTER },
     1:   { 0 }
     1: };
     1: 
 79445: bool
     1: nsGenericHTMLElement::ParseTableCellHAlignValue(const nsAString& aString,
 48442:                                                 nsAttrValue& aResult)
     1: {
 80486:   return aResult.ParseEnumValue(aString, kTableCellHAlignTable, false);
     1: }
     1: 
     1: //----------------------------------------
     1: 
 79445: bool
     1: nsGenericHTMLElement::ParseTableVAlignValue(const nsAString& aString,
     1:                                             nsAttrValue& aResult)
     1: {
 80486:   return aResult.ParseEnumValue(aString, kTableVAlignTable, false);
     1: }
     1: 
 79445: bool
     1: nsGenericHTMLElement::ParseDivAlignValue(const nsAString& aString,
 47237:                                          nsAttrValue& aResult)
     1: {
 80486:   return aResult.ParseEnumValue(aString, kDivAlignTable, false);
     1: }
     1: 
 79445: bool
     1: nsGenericHTMLElement::ParseImageAttribute(nsIAtom* aAttribute,
     1:                                           const nsAString& aString,
     1:                                           nsAttrValue& aResult)
     1: {
     1:   if ((aAttribute == nsGkAtoms::width) ||
     1:       (aAttribute == nsGkAtoms::height)) {
 61970:     return aResult.ParseSpecialIntValue(aString);
     1:   }
 82292:   if ((aAttribute == nsGkAtoms::hspace) ||
     1:       (aAttribute == nsGkAtoms::vspace) ||
     1:       (aAttribute == nsGkAtoms::border)) {
     1:     return aResult.ParseIntWithBounds(aString, 0);
     1:   }
 80486:   return false;
     1: }
     1: 
 79445: bool
     1: nsGenericHTMLElement::ParseFrameborderValue(const nsAString& aString,
     1:                                             nsAttrValue& aResult)
     1: {
 80486:   return aResult.ParseEnumValue(aString, kFrameborderTable, false);
     1: }
     1: 
 79445: bool
     1: nsGenericHTMLElement::ParseScrollingValue(const nsAString& aString,
     1:                                           nsAttrValue& aResult)
     1: {
 80486:   return aResult.ParseEnumValue(aString, kScrollingTable, false);
     1: }
     1: 
     1: /**
     1:  * Handle attributes common to all html elements
     1:  */
     1: void
 58544: nsGenericHTMLElement::MapCommonAttributesExceptHiddenInto(const nsMappedAttributes* aAttributes,
     1:                                                           nsRuleData* aData)
     1: {
  6732:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(UserInterface)) {
 63742:     nsCSSValue* userModify = aData->ValueForUserModify();
 63742:     if (userModify->GetUnit() == eCSSUnit_Null) {
  2896:       const nsAttrValue* value =
  2896:         aAttributes->GetAttr(nsGkAtoms::contenteditable);
  2896:       if (value) {
  2896:         if (value->Equals(nsGkAtoms::_empty, eCaseMatters) ||
  2896:             value->Equals(nsGkAtoms::_true, eIgnoreCase)) {
 63742:           userModify->SetIntValue(NS_STYLE_USER_MODIFY_READ_WRITE,
  2896:                                   eCSSUnit_Enumerated);
  2896:         }
 20264:         else if (value->Equals(nsGkAtoms::_false, eIgnoreCase)) {
 63742:             userModify->SetIntValue(NS_STYLE_USER_MODIFY_READ_ONLY,
  2896:                                     eCSSUnit_Enumerated);
  2896:         }
  2896:       }
  2896:     }
  2896:   }
 48696: 
 88039:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Font)) {
     1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::lang);
     1:     if (value && value->Type() == nsAttrValue::eString) {
 63742:       aData->ValueForLang()->SetStringValue(value->GetStringValue(),
 25796:                                             eCSSUnit_Ident);
     1:     }
     1:   }
 58544: }
 58544: 
 58544: void
 58544: nsGenericHTMLElement::MapCommonAttributesInto(const nsMappedAttributes* aAttributes,
 58544:                                               nsRuleData* aData)
 58544: {
 58544:   nsGenericHTMLElement::MapCommonAttributesExceptHiddenInto(aAttributes, aData);
 48696: 
 48696:   if (aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
 63742:     nsCSSValue* display = aData->ValueForDisplay();
 63742:     if (display->GetUnit() == eCSSUnit_Null) {
104595:       if (aAttributes->IndexOfAttr(nsGkAtoms::hidden) >= 0) {
 63742:         display->SetIntValue(NS_STYLE_DISPLAY_NONE, eCSSUnit_Enumerated);
 48696:       }
 48696:     }
 48696:   }
     1: }
     1: 
     1: 
     1: /* static */ const nsGenericHTMLElement::MappedAttributeEntry
     1: nsGenericHTMLElement::sCommonAttributeMap[] = {
  2896:   { &nsGkAtoms::contenteditable },
     1:   { &nsGkAtoms::lang },
 48696:   { &nsGkAtoms::hidden },
106838:   { nullptr }
     1: };
     1: 
121948: /* static */ const Element::MappedAttributeEntry
     1: nsGenericHTMLElement::sImageMarginSizeAttributeMap[] = {
     1:   { &nsGkAtoms::width },
     1:   { &nsGkAtoms::height },
     1:   { &nsGkAtoms::hspace },
     1:   { &nsGkAtoms::vspace },
106838:   { nullptr }
     1: };
     1: 
121948: /* static */ const Element::MappedAttributeEntry
     1: nsGenericHTMLElement::sImageAlignAttributeMap[] = {
     1:   { &nsGkAtoms::align },
106838:   { nullptr }
     1: };
     1: 
121948: /* static */ const Element::MappedAttributeEntry
     1: nsGenericHTMLElement::sDivAlignAttributeMap[] = {
     1:   { &nsGkAtoms::align },
106838:   { nullptr }
     1: };
     1: 
121948: /* static */ const Element::MappedAttributeEntry
     1: nsGenericHTMLElement::sImageBorderAttributeMap[] = {
     1:   { &nsGkAtoms::border },
106838:   { nullptr }
     1: };
     1: 
121948: /* static */ const Element::MappedAttributeEntry
     1: nsGenericHTMLElement::sBackgroundAttributeMap[] = {
     1:   { &nsGkAtoms::background },
     1:   { &nsGkAtoms::bgcolor },
106838:   { nullptr }
     1: };
     1: 
121948: /* static */ const Element::MappedAttributeEntry
     1: nsGenericHTMLElement::sBackgroundColorAttributeMap[] = {
     1:   { &nsGkAtoms::bgcolor },
106838:   { nullptr }
     1: };
     1: 
121948: /* static */ const Element::MappedAttributeEntry
     1: nsGenericHTMLElement::sScrollingAttributeMap[] = {
     1:   { &nsGkAtoms::scrolling },
106838:   { nullptr }
     1: };
     1: 
     1: void
     1: nsGenericHTMLElement::MapImageAlignAttributeInto(const nsMappedAttributes* aAttributes,
     1:                                                  nsRuleData* aRuleData)
     1: {
  6732:   if (aRuleData->mSIDs & (NS_STYLE_INHERIT_BIT(Display) |
  6732:                           NS_STYLE_INHERIT_BIT(TextReset))) {
     1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
     1:     if (value && value->Type() == nsAttrValue::eEnum) {
108991:       int32_t align = value->GetEnumValue();
 63742:       if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Display)) {
 63742:         nsCSSValue* cssFloat = aRuleData->ValueForCssFloat();
 63742:         if (cssFloat->GetUnit() == eCSSUnit_Null) {
 63742:           if (align == NS_STYLE_TEXT_ALIGN_LEFT) {
 63742:             cssFloat->SetIntValue(NS_STYLE_FLOAT_LEFT, eCSSUnit_Enumerated);
 63742:           } else if (align == NS_STYLE_TEXT_ALIGN_RIGHT) {
 63742:             cssFloat->SetIntValue(NS_STYLE_FLOAT_RIGHT, eCSSUnit_Enumerated);
 63742:           }
 63742:         }
 63742:       }
 63742:       if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(TextReset)) {
 63742:         nsCSSValue* verticalAlign = aRuleData->ValueForVerticalAlign();
 63742:         if (verticalAlign->GetUnit() == eCSSUnit_Null) {
     1:           switch (align) {
     1:           case NS_STYLE_TEXT_ALIGN_LEFT:
     1:           case NS_STYLE_TEXT_ALIGN_RIGHT:
     1:             break;
     1:           default:
 63742:             verticalAlign->SetIntValue(align, eCSSUnit_Enumerated);
     1:             break;
     1:           }
     1:         }
     1:       }
     1:     }
     1:   }
 63742: }
     1: 
     1: void
     1: nsGenericHTMLElement::MapDivAlignAttributeInto(const nsMappedAttributes* aAttributes,
     1:                                                nsRuleData* aRuleData)
     1: {
  6732:   if (aRuleData->mSIDs & NS_STYLE_INHERIT_BIT(Text)) {
 63742:     nsCSSValue* textAlign = aRuleData->ValueForTextAlign();
 63742:     if (textAlign->GetUnit() == eCSSUnit_Null) {
     1:       // align: enum
     1:       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::align);
     1:       if (value && value->Type() == nsAttrValue::eEnum)
 63742:         textAlign->SetIntValue(value->GetEnumValue(), eCSSUnit_Enumerated);
     1:     }
     1:   }
     1: }
     1: 
     1: 
     1: void
     1: nsGenericHTMLElement::MapImageMarginAttributeInto(const nsMappedAttributes* aAttributes,
     1:                                                   nsRuleData* aData)
     1: {
  6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Margin)))
     1:     return;
     1: 
     1:   const nsAttrValue* value;
     1: 
     1:   // hspace: value
     1:   value = aAttributes->GetAttr(nsGkAtoms::hspace);
     1:   if (value) {
     1:     nsCSSValue hval;
     1:     if (value->Type() == nsAttrValue::eInteger)
     1:       hval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     1:     else if (value->Type() == nsAttrValue::ePercent)
     1:       hval.SetPercentValue(value->GetPercentValue());
     1: 
     1:     if (hval.GetUnit() != eCSSUnit_Null) {
 63742:       nsCSSValue* left = aData->ValueForMarginLeftValue();
 63742:       if (left->GetUnit() == eCSSUnit_Null)
 63742:         *left = hval;
 63742:       nsCSSValue* right = aData->ValueForMarginRightValue();
 63742:       if (right->GetUnit() == eCSSUnit_Null)
 63742:         *right = hval;
     1:     }
     1:   }
     1: 
     1:   // vspace: value
     1:   value = aAttributes->GetAttr(nsGkAtoms::vspace);
     1:   if (value) {
     1:     nsCSSValue vval;
     1:     if (value->Type() == nsAttrValue::eInteger)
     1:       vval.SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     1:     else if (value->Type() == nsAttrValue::ePercent)
     1:       vval.SetPercentValue(value->GetPercentValue());
     1:   
     1:     if (vval.GetUnit() != eCSSUnit_Null) {
 63742:       nsCSSValue* top = aData->ValueForMarginTop();
 63742:       if (top->GetUnit() == eCSSUnit_Null)
 63742:         *top = vval;
 63742:       nsCSSValue* bottom = aData->ValueForMarginBottom();
 63742:       if (bottom->GetUnit() == eCSSUnit_Null)
 63742:         *bottom = vval;
     1:     }
     1:   }
     1: }
     1: 
     1: void
     1: nsGenericHTMLElement::MapImageSizeAttributesInto(const nsMappedAttributes* aAttributes,
     1:                                                  nsRuleData* aData)
     1: {
  6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Position)))
     1:     return;
     1: 
     1:   // width: value
 63742:   nsCSSValue* width = aData->ValueForWidth();
 63742:   if (width->GetUnit() == eCSSUnit_Null) {
     1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::width);
     1:     if (value && value->Type() == nsAttrValue::eInteger)
 63742:       width->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel);
     1:     else if (value && value->Type() == nsAttrValue::ePercent)
 63742:       width->SetPercentValue(value->GetPercentValue());
     1:   }
     1: 
     1:   // height: value
 63742:   nsCSSValue* height = aData->ValueForHeight();
 63742:   if (height->GetUnit() == eCSSUnit_Null) {
     1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::height);
     1:     if (value && value->Type() == nsAttrValue::eInteger)
 63742:       height->SetFloatValue((float)value->GetIntegerValue(), eCSSUnit_Pixel); 
     1:     else if (value && value->Type() == nsAttrValue::ePercent)
 63742:       height->SetPercentValue(value->GetPercentValue());
     1:   }
     1: }
     1: 
     1: void
     1: nsGenericHTMLElement::MapImageBorderAttributeInto(const nsMappedAttributes* aAttributes,
     1:                                                   nsRuleData* aData)
     1: {
  6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Border)))
     1:     return;
     1: 
     1:   // border: pixels
     1:   const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::border);
     1:   if (!value)
     1:     return;
     1:   
     1:   nscoord val = 0;
     1:   if (value->Type() == nsAttrValue::eInteger)
     1:     val = value->GetIntegerValue();
     1: 
 63742:   nsCSSValue* borderLeftWidth = aData->ValueForBorderLeftWidthValue();
 63742:   if (borderLeftWidth->GetUnit() == eCSSUnit_Null)
 63742:     borderLeftWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
 63742:   nsCSSValue* borderTopWidth = aData->ValueForBorderTopWidth();
 63742:   if (borderTopWidth->GetUnit() == eCSSUnit_Null)
 63742:     borderTopWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
 63742:   nsCSSValue* borderRightWidth = aData->ValueForBorderRightWidthValue();
 63742:   if (borderRightWidth->GetUnit() == eCSSUnit_Null)
 63742:     borderRightWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
 63742:   nsCSSValue* borderBottomWidth = aData->ValueForBorderBottomWidth();
 63742:   if (borderBottomWidth->GetUnit() == eCSSUnit_Null)
 63742:     borderBottomWidth->SetFloatValue((float)val, eCSSUnit_Pixel);
 63742: 
 63742:   nsCSSValue* borderLeftStyle = aData->ValueForBorderLeftStyleValue();
 63742:   if (borderLeftStyle->GetUnit() == eCSSUnit_Null)
 63742:     borderLeftStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
 63742:   nsCSSValue* borderTopStyle = aData->ValueForBorderTopStyle();
 63742:   if (borderTopStyle->GetUnit() == eCSSUnit_Null)
 63742:     borderTopStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
 63742:   nsCSSValue* borderRightStyle = aData->ValueForBorderRightStyleValue();
 63742:   if (borderRightStyle->GetUnit() == eCSSUnit_Null)
 63742:     borderRightStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
 63742:   nsCSSValue* borderBottomStyle = aData->ValueForBorderBottomStyle();
 63742:   if (borderBottomStyle->GetUnit() == eCSSUnit_Null)
 63742:     borderBottomStyle->SetIntValue(NS_STYLE_BORDER_STYLE_SOLID, eCSSUnit_Enumerated);
 63742: 
 63742:   nsCSSValue* borderLeftColor = aData->ValueForBorderLeftColorValue();
 63742:   if (borderLeftColor->GetUnit() == eCSSUnit_Null)
 63742:     borderLeftColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
 63742:   nsCSSValue* borderTopColor = aData->ValueForBorderTopColor();
 63742:   if (borderTopColor->GetUnit() == eCSSUnit_Null)
 63742:     borderTopColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
 63742:   nsCSSValue* borderRightColor = aData->ValueForBorderRightColorValue();
 63742:   if (borderRightColor->GetUnit() == eCSSUnit_Null)
 63742:     borderRightColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
 63742:   nsCSSValue* borderBottomColor = aData->ValueForBorderBottomColor();
 63742:   if (borderBottomColor->GetUnit() == eCSSUnit_Null)
 63742:     borderBottomColor->SetIntValue(NS_STYLE_COLOR_MOZ_USE_TEXT_COLOR, eCSSUnit_Enumerated);
     1: }
     1: 
     1: void
     1: nsGenericHTMLElement::MapBackgroundInto(const nsMappedAttributes* aAttributes,
     1:                                         nsRuleData* aData)
     1: {
  6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     1:     return;
     1: 
  8088:   nsPresContext* presContext = aData->mPresContext;
 63742:   nsCSSValue* backImage = aData->ValueForBackgroundImage();
 63742:   if (backImage->GetUnit() == eCSSUnit_Null &&
 50931:       presContext->UseDocumentColors()) {
     1:     // background
109319:     nsAttrValue* value =
109319:       const_cast<nsAttrValue*>(aAttributes->GetAttr(nsGkAtoms::background));
109319:     // If the value is an image, or it is a URL and we attempted a load,
109319:     // put it in the style tree.
111067:     if (value) {
111067:       if (value->Type() == nsAttrValue::eURL) {
111067:         value->LoadImage(presContext->Document());
111067:       }
111067:       if (value->Type() == nsAttrValue::eImage) {
 63742:         nsCSSValueList* list = backImage->SetListValue();
109319:         list->mValue.SetImageValue(value->GetImageValue());
     1:       }
     1:     }
     1:   }
111067: }
     1: 
     1: void
     1: nsGenericHTMLElement::MapBGColorInto(const nsMappedAttributes* aAttributes,
     1:                                      nsRuleData* aData)
     1: {
  6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Background)))
     1:     return;
     1: 
 63742:   nsCSSValue* backColor = aData->ValueForBackgroundColor();
 63742:   if (backColor->GetUnit() == eCSSUnit_Null &&
  8088:       aData->mPresContext->UseDocumentColors()) {
     1:     const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::bgcolor);
     1:     nscolor color;
     1:     if (value && value->GetColorValue(color)) {
 63742:       backColor->SetColorValue(color);
     1:     }
     1:   }
     1: }
     1: 
     1: void
     1: nsGenericHTMLElement::MapBackgroundAttributesInto(const nsMappedAttributes* aAttributes,
     1:                                                   nsRuleData* aData)
     1: {
     1:   MapBackgroundInto(aAttributes, aData);
     1:   MapBGColorInto(aAttributes, aData);
     1: }
     1: 
     1: void
     1: nsGenericHTMLElement::MapScrollingAttributeInto(const nsMappedAttributes* aAttributes,
     1:                                                 nsRuleData* aData)
     1: {
  6732:   if (!(aData->mSIDs & NS_STYLE_INHERIT_BIT(Display)))
     1:     return;
     1: 
     1:   // scrolling
     1:   nsCSSValue* overflowValues[2] = {
 63742:     aData->ValueForOverflowX(),
 63742:     aData->ValueForOverflowY(),
     1:   };
108991:   for (uint32_t i = 0; i < ArrayLength(overflowValues); ++i) {
     1:     if (overflowValues[i]->GetUnit() == eCSSUnit_Null) {
     1:       const nsAttrValue* value = aAttributes->GetAttr(nsGkAtoms::scrolling);
     1:       if (value && value->Type() == nsAttrValue::eEnum) {
108991:         int32_t mappedValue;
     1:         switch (value->GetEnumValue()) {
     1:           case NS_STYLE_FRAME_ON:
     1:           case NS_STYLE_FRAME_SCROLL:
     1:           case NS_STYLE_FRAME_YES:
     1:             mappedValue = NS_STYLE_OVERFLOW_SCROLL;
     1:             break;
     1: 
     1:           case NS_STYLE_FRAME_OFF:
     1:           case NS_STYLE_FRAME_NOSCROLL:
     1:           case NS_STYLE_FRAME_NO:
     1:             mappedValue = NS_STYLE_OVERFLOW_HIDDEN;
     1:             break;
     1:         
     1:           case NS_STYLE_FRAME_AUTO:
     1:             mappedValue = NS_STYLE_OVERFLOW_AUTO;
     1:             break;
     1: 
     1:           default:
     1:             NS_NOTREACHED("unexpected value");
     1:             mappedValue = NS_STYLE_OVERFLOW_AUTO;
     1:             break;
     1:         }
     1:         overflowValues[i]->SetIntValue(mappedValue, eCSSUnit_Enumerated);
     1:       }
     1:     }
     1:   }
     1: }
     1: 
     1: //----------------------------------------------------------------------
     1: 
     1: nsresult
     1: nsGenericHTMLElement::SetAttrHelper(nsIAtom* aAttr, const nsAString& aValue)
     1: {
 80486:   return SetAttr(kNameSpaceID_None, aAttr, aValue, true);
     1: }
     1: 
     1: nsresult
 79445: nsGenericHTMLElement::SetBoolAttr(nsIAtom* aAttr, bool aValue)
     1: {
     1:   if (aValue) {
 80486:     return SetAttr(kNameSpaceID_None, aAttr, EmptyString(), true);
 80486:   }
 80486: 
 80486:   return UnsetAttr(kNameSpaceID_None, aAttr, true);
     1: }
     1: 
115695: int32_t
115695: nsGenericHTMLElement::GetIntAttr(nsIAtom* aAttr, int32_t aDefault) const
     1: {
     1:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(aAttr);
     1:   if (attrVal && attrVal->Type() == nsAttrValue::eInteger) {
115695:     return attrVal->GetIntegerValue();
115695:   }
115695:   return aDefault;
     1: }
     1: 
     1: nsresult
108991: nsGenericHTMLElement::SetIntAttr(nsIAtom* aAttr, int32_t aValue)
     1: {
     1:   nsAutoString value;
     1:   value.AppendInt(aValue);
     1: 
 80486:   return SetAttr(kNameSpaceID_None, aAttr, value, true);
     1: }
     1: 
     1: nsresult
108991: nsGenericHTMLElement::GetUnsignedIntAttr(nsIAtom* aAttr, uint32_t aDefault,
108991:                                          uint32_t* aResult)
 56994: {
 56994:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(aAttr);
 56994:   if (attrVal && attrVal->Type() == nsAttrValue::eInteger) {
 56994:     *aResult = attrVal->GetIntegerValue();
 56994:   }
 56994:   else {
 56994:     *aResult = aDefault;
 56994:   }
 56994:   return NS_OK;
 56994: }
 56994: 
 56994: nsresult
108991: nsGenericHTMLElement::SetUnsignedIntAttr(nsIAtom* aAttr, uint32_t aValue)
 56994: {
 56994:   nsAutoString value;
 56994:   value.AppendInt(aValue);
 56994: 
 80486:   return SetAttr(kNameSpaceID_None, aAttr, value, true);
 56994: }
 56994: 
 56994: nsresult
 63879: nsGenericHTMLElement::SetDoubleAttr(nsIAtom* aAttr, double aValue)
 15751: {
 15751:   nsAutoString value;
 15751:   value.AppendFloat(aValue);
 15751: 
 80486:   return SetAttr(kNameSpaceID_None, aAttr, value, true);
 15751: }
 15751: 
121921: void
121921: nsGenericHTMLElement::GetURIAttr(nsIAtom* aAttr, nsIAtom* aBaseAttr,
121921:                                  nsAString& aResult) const
     1: {
 25979:   nsCOMPtr<nsIURI> uri;
 79445:   bool hadAttr = GetURIAttr(aAttr, aBaseAttr, getter_AddRefs(uri));
 56659:   if (!hadAttr) {
     1:     aResult.Truncate();
121921:     return;
     1:   }
     1: 
 56659:   if (!uri) {
 56659:     // Just return the attr value
 56659:     GetAttr(kNameSpaceID_None, aAttr, aResult);
121921:     return;
 56659:   }
 56659: 
110974:   nsAutoCString spec;
 25979:   uri->GetSpec(spec);
 25979:   CopyUTF8toUTF16(spec, aResult);
 25979: }
 25979: 
 79445: bool
 70015: nsGenericHTMLElement::GetURIAttr(nsIAtom* aAttr, nsIAtom* aBaseAttr, nsIURI** aURI) const
 25979: {
106838:   *aURI = nullptr;
 25979: 
 25979:   const nsAttrValue* attr = mAttrsAndChildren.GetAttr(aAttr);
 25979:   if (!attr) {
 80486:     return false;
 25979:   }
 25979: 
     1:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
     1: 
     1:   if (aBaseAttr) {
     1:     nsAutoString baseAttrValue;
     1:     if (GetAttr(kNameSpaceID_None, aBaseAttr, baseAttrValue)) {
     1:       nsCOMPtr<nsIURI> baseAttrURI;
 25979:       nsresult rv =
 25979:         nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(baseAttrURI),
 80526:                                                   baseAttrValue, OwnerDoc(),
     1:                                                   baseURI);
     1:       if (NS_FAILED(rv)) {
 80486:         return true;
     1:       }
     1:       baseURI.swap(baseAttrURI);
     1:     }
     1:   }
     1: 
 25979:   // Don't care about return value.  If it fails, we still want to
 80486:   // return true, and *aURI will be null.
 25979:   nsContentUtils::NewURIWithDocumentCharset(aURI,
 25979:                                             attr->GetStringValue(),
 80526:                                             OwnerDoc(), baseURI);
 80486:   return true;
     1: }
     1: 
     1: nsresult
     1: nsGenericHTMLElement::GetURIListAttr(nsIAtom* aAttr, nsAString& aResult)
     1: {
     1:   aResult.Truncate();
     1: 
     1:   nsAutoString value;
     1:   if (!GetAttr(kNameSpaceID_None, aAttr, value))
     1:     return NS_OK;
     1: 
 80526:   nsIDocument* doc = OwnerDoc(); 
     1:   nsCOMPtr<nsIURI> baseURI = GetBaseURI();
     1: 
     1:   // Value contains relative URIs split on spaces (U+0020)
     1:   const PRUnichar *start = value.BeginReading();
     1:   const PRUnichar *end   = value.EndReading();
     1:   const PRUnichar *iter  = start;
     1:   for (;;) {
     1:     if (iter < end && *iter != ' ') {
     1:       ++iter;
     1:     } else {  // iter is pointing at either end or a space
     1:       while (*start == ' ' && start < iter)
     1:         ++start;
     1:       if (iter != start) {
     1:         if (!aResult.IsEmpty())
     1:           aResult.Append(PRUnichar(' '));
     1:         const nsSubstring& uriPart = Substring(start, iter);
     1:         nsCOMPtr<nsIURI> attrURI;
     1:         nsContentUtils::NewURIWithDocumentCharset(getter_AddRefs(attrURI),
     1:                                                   uriPart, doc, baseURI);
     1:         if (attrURI) {
110974:           nsAutoCString spec;
     1:           attrURI->GetSpec(spec);
     1:           AppendUTF8toUTF16(spec, aResult);
     1:         } else {
     1:           aResult.Append(uriPart);
     1:         }
     1:       }
     1:       start = iter = iter + 1;
     1:       if (iter >= end)
     1:         break;
     1:     }
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
121921: void
 41437: nsGenericHTMLElement::GetEnumAttr(nsIAtom* aAttr,
 41437:                                   const char* aDefault,
121921:                                   nsAString& aResult) const
 41437: {
 41437:   const nsAttrValue* attrVal = mAttrsAndChildren.GetAttr(aAttr);
 41437: 
 41437:   aResult.Truncate();
 41437: 
 41437:   if (attrVal && attrVal->Type() == nsAttrValue::eEnum) {
 80486:     attrVal->GetEnumString(aResult, true);
 71265:   } else if (aDefault) {
 41437:     AppendASCIItoUTF16(nsDependentCString(aDefault), aResult);
 41437:   }
121921: }
121921: 
121921: nsHTMLMenuElement*
121921: nsGenericHTMLElement::GetContextMenu() const
  2896: {
 75019:   nsAutoString value;
121921:   GetHTMLAttr(nsGkAtoms::contextmenu, value);
121921:   if (!value.IsEmpty()) {
 75019:     nsIDocument* doc = GetCurrentDoc();
 75019:     if (doc) {
121921:       return nsHTMLMenuElement::FromContentOrNull(doc->GetElementById(value));
121921:     }
121921:   }
121921:   return nullptr;
121921: }
121921: 
121921: void
121921: nsGenericHTMLElement::GetContextMenu(nsIDOMHTMLMenuElement** aContextMenu) const
121921: {
121921:   NS_IF_ADDREF(*aContextMenu = GetContextMenu());
 75019: }
 75019: 
101616: bool
101616: nsGenericHTMLElement::IsLabelable() const
101616: {
101616:   return Tag() == nsGkAtoms::progress ||
101616:          Tag() == nsGkAtoms::meter;
101616: }
101616: 
124201: // static
124201: bool
124201: nsGenericHTMLElement::PrefEnabled()
124201: {
124201:   // This is a bit of a hack because we don't support non-bool prefs to enable
124201:   // properties. This function will be called every time a HTMLElement interface
124201:   // prototype object is created. The first time this is called we set a boolean
124201:   // pref (dom.w3c_touch_events.expose) which controls the touch event
124201:   // properties on HTMLElement.
124201:   static bool sDidSetPref = false;
124201:   if (!sDidSetPref) {
124201:     sDidSetPref = true;
124201:     Preferences::SetBool("dom.w3c_touch_events.expose",
124201:                          nsDOMTouchEvent::PrefEnabled());
124201:   }
124201:   return true;
124201: }
124201: 
     1: //----------------------------------------------------------------------
     1: 
 94340: nsGenericHTMLFormElement::nsGenericHTMLFormElement(already_AddRefed<nsINodeInfo> aNodeInfo)
 54342:   : nsGenericHTMLElement(aNodeInfo)
106838:   , mForm(nullptr)
106838:   , mFieldSet(nullptr)
     1: {
 71121:   // We should add the NS_EVENT_STATE_ENABLED bit here as needed, but
 71121:   // that depends on our type, which is not initialized yet.  So we
 71121:   // have to do this in subclasses.
     1: }
     1: 
     1: nsGenericHTMLFormElement::~nsGenericHTMLFormElement()
     1: {
 56935:   if (mFieldSet) {
 78416:     mFieldSet->RemoveElement(this);
 56935:   }
 56935: 
 33311:   // Check that this element doesn't know anything about its form at this point.
 54342:   NS_ASSERTION(!mForm, "mForm should be null at this point!");
     1: }
     1: 
  4838: NS_IMPL_QUERY_INTERFACE_INHERITED1(nsGenericHTMLFormElement,
  4838:                                    nsGenericHTMLElement,
  4838:                                    nsIFormControl)
     1: 
 79445: bool
108991: nsGenericHTMLFormElement::IsNodeOfType(uint32_t aFlags) const
     1: {
 41646:   return !(aFlags & ~(eCONTENT | eHTML_FORM_CONTROL));
     1: }
     1: 
  8462: void
 14188: nsGenericHTMLFormElement::SaveSubtreeState()
  8462: {
  8462:   SaveState();
  8462: 
 14188:   nsGenericHTMLElement::SaveSubtreeState();
  8462: }
  8462: 
 19131: void
 19131: nsGenericHTMLFormElement::SetForm(nsIDOMHTMLFormElement* aForm)
 19131: {
 19131:   NS_PRECONDITION(aForm, "Don't pass null here");
 19131:   NS_ASSERTION(!mForm,
 19131:                "We don't support switching from one non-null form to another.");
 19131: 
 19131:   // keep a *weak* ref to the form here
 34395:   mForm = static_cast<nsHTMLFormElement*>(aForm);
 19131: }
 19131: 
 19131: void
 79445: nsGenericHTMLFormElement::ClearForm(bool aRemoveFromForm)
     1: {
106838:   NS_ASSERTION((mForm != nullptr) == HasFlag(ADDED_TO_FORM),
 19131:                "Form control should have had flag set correctly");
 19131: 
 19131:   if (!mForm) {
 19131:     return;
 19131:   }
 19131:   
 18976:   if (aRemoveFromForm) {
     1:     nsAutoString nameVal, idVal;
     1:     GetAttr(kNameSpaceID_None, nsGkAtoms::name, nameVal);
     1:     GetAttr(kNameSpaceID_None, nsGkAtoms::id, idVal);
  4014: 
 57333:     mForm->RemoveElement(this, true);
     1: 
     1:     if (!nameVal.IsEmpty()) {
     1:       mForm->RemoveElementFromTable(this, nameVal);
     1:     }
     1: 
     1:     if (!idVal.IsEmpty()) {
     1:       mForm->RemoveElementFromTable(this, idVal);
     1:     }
 18976:   }
  4014: 
  4014:   UnsetFlags(ADDED_TO_FORM);
106838:   mForm = nullptr;
     1: }
     1: 
 47801: Element*
 47801: nsGenericHTMLFormElement::GetFormElement()
 47801: {
 47801:   return mForm;
 47801: }
 47801: 
 47801: nsresult
     1: nsGenericHTMLFormElement::GetForm(nsIDOMHTMLFormElement** aForm)
     1: {
     1:   NS_ENSURE_ARG_POINTER(aForm);
 34395:   NS_IF_ADDREF(*aForm = mForm);
     1:   return NS_OK;
     1: }
     1: 
 82843: nsIContent::IMEState
     1: nsGenericHTMLFormElement::GetDesiredIMEState()
     1: {
106838:   nsCOMPtr<nsIEditor> editor = nullptr;
     1:   nsresult rv = GetEditorInternal(getter_AddRefs(editor));
     1:   if (NS_FAILED(rv) || !editor)
     1:     return nsGenericHTMLElement::GetDesiredIMEState();
     1:   nsCOMPtr<nsIEditorIMESupport> imeEditor = do_QueryInterface(editor);
     1:   if (!imeEditor)
     1:     return nsGenericHTMLElement::GetDesiredIMEState();
 82843:   IMEState state;
     1:   rv = imeEditor->GetPreferredIMEState(&state);
     1:   if (NS_FAILED(rv))
     1:     return nsGenericHTMLElement::GetDesiredIMEState();
     1:   return state;
     1: }
     1: 
     1: nsresult
     1: nsGenericHTMLFormElement::BindToTree(nsIDocument* aDocument,
     1:                                      nsIContent* aParent,
     1:                                      nsIContent* aBindingParent,
 79445:                                      bool aCompileEventHandlers)
     1: {
     1:   nsresult rv = nsGenericHTMLElement::BindToTree(aDocument, aParent,
     1:                                                  aBindingParent,
     1:                                                  aCompileEventHandlers);
     1:   NS_ENSURE_SUCCESS(rv, rv);
 42460: 
 42460:   // An autofocus event has to be launched if the autofocus attribute is
 42460:   // specified and the element accept the autofocus attribute. In addition,
 42460:   // the document should not be already loaded and the "browser.autofocus"
 42460:   // preference should be 'true'.
 63766:   if (IsAutofocusable() && HasAttr(kNameSpaceID_None, nsGkAtoms::autofocus) &&
 79445:       Preferences::GetBool("browser.autofocus", true)) {
 42460:     nsCOMPtr<nsIRunnable> event = new nsAutoFocusEvent(this);
 42460:     rv = NS_DispatchToCurrentThread(event);
 42460:     NS_ENSURE_SUCCESS(rv, rv);
 42460:   }
 42460: 
 51492:   // If @form is set, the element *has* to be in a document, otherwise it
 51492:   // wouldn't be possible to find an element with the corresponding id.
 51492:   // If @form isn't set, the element *has* to have a parent, otherwise it
 51492:   // wouldn't be possible to find a form ancestor.
 51496:   // We should not call UpdateFormOwner if none of these conditions are
 51492:   // fulfilled.
 51492:   if (HasAttr(kNameSpaceID_None, nsGkAtoms::form) ? !!GetCurrentDoc()
 51492:                                                   : !!aParent) {
106838:     UpdateFormOwner(true, nullptr);
  4014:   }
  4014: 
 54342:   // Set parent fieldset which should be used for the disabled state.
 80486:   UpdateFieldSet(false);
 54342: 
  4014:   return NS_OK;
     1: }
     1: 
     1: void
 79445: nsGenericHTMLFormElement::UnbindFromTree(bool aDeep, bool aNullParent)
     1: {
     1:   // Save state before doing anything
     1:   SaveState();
     1:   
     1:   if (mForm) {
     1:     // Might need to unset mForm
     1:     if (aNullParent) {
     1:       // No more parent means no more form
 80486:       ClearForm(true);
     1:     } else {
     1:       // Recheck whether we should still have an mForm.
 51301:       if (HasAttr(kNameSpaceID_None, nsGkAtoms::form) ||
 51301:           !FindAncestorForm(mForm)) {
 80486:         ClearForm(true);
  7654:       } else {
  7654:         UnsetFlags(MAYBE_ORPHAN_FORM_ELEMENT);
     1:       }
     1:     }
 71121: 
 71121:     if (!mForm) {
 71121:       // Our novalidate state might have changed
 71121:       UpdateState(false);
 71121:     }
     1:   }
     1: 
 51301:   // We have to remove the form id observer if there was one.
 51301:   // We will re-add one later if needed (during bind to tree).
 51301:   if (nsContentUtils::HasNonEmptyAttr(this, kNameSpaceID_None,
 51301:                                       nsGkAtoms::form)) {
 51301:     RemoveFormIdObserver();
 51301:   }
 51301: 
     1:   nsGenericHTMLElement::UnbindFromTree(aDeep, aNullParent);
 54342: 
 54342:   // The element might not have a fieldset anymore.
 80486:   UpdateFieldSet(false);
     1: }
     1: 
     1: nsresult
108991: nsGenericHTMLFormElement::BeforeSetAttr(int32_t aNameSpaceID, nsIAtom* aName,
 90060:                                         const nsAttrValueOrString* aValue,
 90060:                                         bool aNotify)
     1: {
     1:   if (aNameSpaceID == kNameSpaceID_None) {
     1:     nsAutoString tmp;
     1: 
     1:     // remove the control from the hashtable as needed
     1: 
     1:     if (mForm && (aName == nsGkAtoms::name || aName == nsGkAtoms::id)) {
     1:       GetAttr(kNameSpaceID_None, aName, tmp);
     1: 
     1:       if (!tmp.IsEmpty()) {
     1:         mForm->RemoveElementFromTable(this, tmp);
     1:       }
     1:     }
     1: 
     1:     if (mForm && aName == nsGkAtoms::type) {
     1:       GetAttr(kNameSpaceID_None, nsGkAtoms::name, tmp);
     1: 
     1:       if (!tmp.IsEmpty()) {
     1:         mForm->RemoveElementFromTable(this, tmp);
     1:       }
     1: 
     1:       GetAttr(kNameSpaceID_None, nsGkAtoms::id, tmp);
     1: 
     1:       if (!tmp.IsEmpty()) {
     1:         mForm->RemoveElementFromTable(this, tmp);
     1:       }
     1: 
 57333:       mForm->RemoveElement(this, false);
  3410: 
  3410:       // Removing the element from the form can make it not be the default
  3410:       // control anymore.  Go ahead and notify on that change, though we might
  3410:       // end up readding and becoming the default control again in
  3410:       // AfterSetAttr.
 71121:       // FIXME: Bug 656197
 71121:       UpdateState(aNotify);
     1:     }
 51301: 
 51301:     if (aName == nsGkAtoms::form) {
 51301:       // If @form isn't set or set to the empty string, there were no observer
 51301:       // so we don't have to remove it.
 51301:       if (nsContentUtils::HasNonEmptyAttr(this, kNameSpaceID_None,
 51301:                                           nsGkAtoms::form)) {
 51301:         // The current form id observer is no longer needed.
 51301:         // A new one may be added in AfterSetAttr.
 51301:         RemoveFormIdObserver();
 51301:       }
 51301:     }
     1:   }
     1: 
     1:   return nsGenericHTMLElement::BeforeSetAttr(aNameSpaceID, aName,
     1:                                              aValue, aNotify);
     1: }
     1: 
     1: nsresult
108991: nsGenericHTMLFormElement::AfterSetAttr(int32_t aNameSpaceID, nsIAtom* aName,
 90061:                                        const nsAttrValue* aValue, bool aNotify)
     1: {
     1:   if (aNameSpaceID == kNameSpaceID_None) {
     1:     // add the control to the hashtable as needed
     1: 
     1:     if (mForm && (aName == nsGkAtoms::name || aName == nsGkAtoms::id) &&
 90061:         aValue && !aValue->IsEmptyString()) {
 90061:       NS_ABORT_IF_FALSE(aValue->Type() == nsAttrValue::eAtom,
 90061:         "Expected atom value for name/id");
 90061:       mForm->AddElementToTable(this,
 90061:         nsDependentAtomString(aValue->GetAtomValue()));
     1:     }
     1: 
     1:     if (mForm && aName == nsGkAtoms::type) {
     1:       nsAutoString tmp;
     1: 
     1:       GetAttr(kNameSpaceID_None, nsGkAtoms::name, tmp);
     1: 
     1:       if (!tmp.IsEmpty()) {
     1:         mForm->AddElementToTable(this, tmp);
     1:       }
     1: 
     1:       GetAttr(kNameSpaceID_None, nsGkAtoms::id, tmp);
     1: 
     1:       if (!tmp.IsEmpty()) {
     1:         mForm->AddElementToTable(this, tmp);
     1:       }
     1: 
 55187:       mForm->AddElement(this, false, aNotify);
     1: 
  3410:       // Adding the element to the form can make it be the default control .
  3410:       // Go ahead and notify on that change.
     1:       // Note: no need to notify on CanBeDisabled(), since type attr
     1:       // changes can't affect that.
 71121:       UpdateState(aNotify);
     1:     }
 51301: 
 51301:     if (aName == nsGkAtoms::form) {
 51301:       // We need a new form id observer.
 51301:       nsIDocument* doc = GetCurrentDoc();
 51301:       if (doc) {
106838:         Element* formIdElement = nullptr;
 90061:         if (aValue && !aValue->IsEmptyString()) {
 51301:           formIdElement = AddFormIdObserver();
 51301:         }
 51301: 
 51301:         // Because we have a new @form value (or no more @form), we have to
 51301:         // update our form owner.
 51301:         UpdateFormOwner(false, formIdElement);
 51301:       }
 51301:     }
     1:   }
     1: 
     1:   return nsGenericHTMLElement::AfterSetAttr(aNameSpaceID, aName,
     1:                                             aValue, aNotify);
     1: }
     1: 
 29018: nsresult
 29018: nsGenericHTMLFormElement::PreHandleEvent(nsEventChainPreVisitor& aVisitor)
 29018: {
 29018:   if (NS_IS_TRUSTED_EVENT(aVisitor.mEvent)) {
 29018:     switch (aVisitor.mEvent->message) {
 29018:       case NS_FOCUS_CONTENT:
 29018:       {
 29018:         // Check to see if focus has bubbled up from a form control's
 29018:         // child textfield or button.  If that's the case, don't focus
 29018:         // this parent file control -- leave focus on the child.
 80486:         nsIFormControlFrame* formControlFrame = GetFormControlFrame(true);
 29018:         if (formControlFrame &&
 29018:             aVisitor.mEvent->originalTarget == static_cast<nsINode*>(this))
 80486:           formControlFrame->SetFocus(true, true);
 29018:         break;
 29018:       }
 29018:       case NS_BLUR_CONTENT:
 29018:       {
 80486:         nsIFormControlFrame* formControlFrame = GetFormControlFrame(true);
 29018:         if (formControlFrame)
 80486:           formControlFrame->SetFocus(false, false);
 29018:         break;
 29018:       }
 29018:     }
 29018:   }
 29018: 
 29018:   return nsGenericHTMLElement::PreHandleEvent(aVisitor);
 29018: }
 29018: 
 78416: /* virtual */
 78416: bool
 78416: nsGenericHTMLFormElement::IsDisabled() const
 78416: {
 78416:   return HasAttr(kNameSpaceID_None, nsGkAtoms::disabled) ||
 78416:          (mFieldSet && mFieldSet->IsDisabled());
 78416: }
 78416: 
 78416: void
 78416: nsGenericHTMLFormElement::ForgetFieldSet(nsIContent* aFieldset)
 78416: {
 78416:   if (mFieldSet == aFieldset) {
106838:     mFieldSet = nullptr;
 78416:   }
 78416: }
 78416: 
 79445: bool
     1: nsGenericHTMLFormElement::CanBeDisabled() const
     1: {
108991:   int32_t type = GetType();
     1:   // It's easier to test the types that _cannot_ be disabled
     1:   return
     1:     type != NS_FORM_LABEL &&
 41438:     type != NS_FORM_OBJECT &&
101616:     type != NS_FORM_OUTPUT;
     1: }
     1: 
 79445: bool
 79445: nsGenericHTMLFormElement::IsHTMLFocusable(bool aWithMouse,
 79445:                                           bool* aIsFocusable,
108991:                                           int32_t* aTabIndex)
 60074: {
 60074:   if (nsGenericHTMLElement::IsHTMLFocusable(aWithMouse, aIsFocusable, aTabIndex)) {
 80486:     return true;
 60074:   }
 60074: 
 60074: #ifdef XP_MACOSX
 60074:   *aIsFocusable =
 60074:     (!aWithMouse || nsFocusManager::sMouseFocusesFormControl) && *aIsFocusable;
 60074: #endif
 80486:   return false;
 60074: }
 60074: 
 56168: nsEventStates
     1: nsGenericHTMLFormElement::IntrinsicState() const
     1: {
     1:   // If you add attribute-dependent states here, you need to add them them to
     1:   // AfterSetAttr too.  And add them to AfterSetAttr for all subclasses that
     1:   // implement IntrinsicState() and are affected by that attribute.
 56168:   nsEventStates state = nsGenericHTMLElement::IntrinsicState();
     1: 
     1:   if (CanBeDisabled()) {
     1:     // :enabled/:disabled
 54342:     if (IsDisabled()) {
     1:       state |= NS_EVENT_STATE_DISABLED;
     1:       state &= ~NS_EVENT_STATE_ENABLED;
     1:     } else {
     1:       state &= ~NS_EVENT_STATE_DISABLED;
     1:       state |= NS_EVENT_STATE_ENABLED;
     1:     }
     1:   }
     1:   
 32864:   if (mForm && mForm->IsDefaultSubmitElement(this)) {
     1:       NS_ASSERTION(IsSubmitControl(),
     1:                    "Default submit element that isn't a submit control.");
     1:       // We are the default submit element (:default)
     1:       state |= NS_EVENT_STATE_DEFAULT;
     1:   }
     1: 
 98127:   // Make the text controls read-write
 98127:   if (!state.HasState(NS_EVENT_STATE_MOZ_READWRITE) &&
 98127:       IsTextControl(false)) {
115695:     bool roState = GetBoolAttr(nsGkAtoms::readonly);
 98127: 
 98127:     if (!roState) {
 98127:       state |= NS_EVENT_STATE_MOZ_READWRITE;
 98127:       state &= ~NS_EVENT_STATE_MOZ_READONLY;
 98127:     }
 98127:   }
 98127: 
     1:   return state;
     1: }
     1: 
 20109: nsGenericHTMLFormElement::FocusTristate
 20109: nsGenericHTMLFormElement::FocusState()
 20109: {
 20109:   // We can't be focused if we aren't in a document
 20109:   nsIDocument* doc = GetCurrentDoc();
 20109:   if (!doc)
 20109:     return eUnfocusable;
 20109: 
 20109:   // first see if we are disabled or not. If disabled then do nothing.
 54342:   if (IsDisabled()) {
 20109:     return eUnfocusable;
 20109:   }
 20109: 
 20109:   // If the window is not active, do not allow the focus to bring the
 20109:   // window to the front.  We update the focus controller, but do
 20109:   // nothing else.
 30219:   nsPIDOMWindow* win = doc->GetWindow();
 30219:   if (win) {
 30219:     nsCOMPtr<nsIDOMWindow> rootWindow = do_QueryInterface(win->GetPrivateRoot());
 29018: 
 29018:     nsCOMPtr<nsIFocusManager> fm = do_GetService(FOCUSMANAGER_CONTRACTID);
 29018:     if (fm && rootWindow) {
 29018:       nsCOMPtr<nsIDOMWindow> activeWindow;
 29018:       fm->GetActiveWindow(getter_AddRefs(activeWindow));
 29018:       if (activeWindow == rootWindow) {
 29018:         return eActiveWindow;
 29018:       }
 29018:     }
 29018:   }
 20109: 
 20109:   return eInactiveWindow;
 20109: }
 20109: 
 51301: Element*
 51301: nsGenericHTMLFormElement::AddFormIdObserver()
 51301: {
 51301:   NS_ASSERTION(GetCurrentDoc(), "When adding a form id observer, "
 51301:                                 "we should be in a document!");
 51301: 
 51301:   nsAutoString formId;
 80526:   nsIDocument* doc = OwnerDoc();
 51301:   GetAttr(kNameSpaceID_None, nsGkAtoms::form, formId);
 51301:   NS_ASSERTION(!formId.IsEmpty(),
 51301:                "@form value should not be the empty string!");
 51301:   nsCOMPtr<nsIAtom> atom = do_GetAtom(formId);
 51301: 
 80486:   return doc->AddIDTargetObserver(atom, FormIdUpdated, this, false);
 51301: }
 51301: 
 51301: void
 51301: nsGenericHTMLFormElement::RemoveFormIdObserver()
 51301: {
 51301:   /**
 80526:    * We are using OwnerDoc() because we don't really care about having the
 51301:    * element actually being in the tree. If it is not and @form value changes,
 51301:    * this method will be called for nothing but removing an observer which does
 51301:    * not exist doesn't cost so much (no entry in the hash table) so having a
 51301:    * boolean for GetCurrentDoc()/GetOwnerDoc() would make everything look more
 51301:    * complex for nothing.
 51301:    */
 51301: 
 80526:   nsIDocument* doc = OwnerDoc();
 51301: 
 51301:   // At this point, we may not have a document anymore. In that case, we can't
 51301:   // remove the observer. The document did that for us.
 51301:   if (!doc) {
 51301:     return;
 51301:   }
 51301: 
 51301:   nsAutoString formId;
 51301:   GetAttr(kNameSpaceID_None, nsGkAtoms::form, formId);
 51301:   NS_ASSERTION(!formId.IsEmpty(),
 51301:                "@form value should not be the empty string!");
 51301:   nsCOMPtr<nsIAtom> atom = do_GetAtom(formId);
 51301: 
 80486:   doc->RemoveIDTargetObserver(atom, FormIdUpdated, this, false);
 51301: }
 51301: 
 51301: 
 51301: /* static */
 79445: bool
 51301: nsGenericHTMLFormElement::FormIdUpdated(Element* aOldElement,
 51301:                                         Element* aNewElement,
 51301:                                         void* aData)
 51301: {
 51301:   nsGenericHTMLFormElement* element =
 51301:     static_cast<nsGenericHTMLFormElement*>(aData);
 51301: 
 51301:   NS_ASSERTION(element->IsHTML(), "aData should be an HTML element");
 51301: 
 51301:   element->UpdateFormOwner(false, aNewElement);
 51301: 
 80486:   return true;
 51301: }
 51301: 
 79445: bool 
108991: nsGenericHTMLFormElement::IsElementDisabledForEvents(uint32_t aMessage, 
 74002:                                                     nsIFrame* aFrame)
 74002: {
 79445:   bool disabled = IsDisabled();
 74002:   if (!disabled && aFrame) {
 74002:     const nsStyleUserInterface* uiStyle = aFrame->GetStyleUserInterface();
 74002:     disabled = uiStyle->mUserInput == NS_STYLE_USER_INPUT_NONE ||
 74002:       uiStyle->mUserInput == NS_STYLE_USER_INPUT_DISABLED;
 74002: 
 74002:   }
 74002:   return disabled && aMessage != NS_MOUSE_MOVE;
 74002: }
 74002: 
 51301: void
 51301: nsGenericHTMLFormElement::UpdateFormOwner(bool aBindToTree,
 51301:                                           Element* aFormIdElement)
 51301: {
 51301:   NS_PRECONDITION(!aBindToTree || !aFormIdElement,
 51301:                   "aFormIdElement shouldn't be set if aBindToTree is true!");
 51301: 
 79445:   bool needStateUpdate = false;
 71120:   if (!aBindToTree) {
 71121:     needStateUpdate = mForm && mForm->IsDefaultSubmitElement(this);
 80486:     ClearForm(true);
 71121:   }
 71121: 
 71121:   nsHTMLFormElement *oldForm = mForm;
 51301: 
 51301:   if (!mForm) {
 51301:     // If @form is set, we have to use that to find the form.
 51301:     nsAutoString formId;
 51301:     if (GetAttr(kNameSpaceID_None, nsGkAtoms::form, formId)) {
 51301:       if (!formId.IsEmpty()) {
106838:         Element* element = nullptr;
 51301: 
 51301:         if (aBindToTree) {
 51301:           element = AddFormIdObserver();
 51301:         } else {
 51301:           element = aFormIdElement;
 51301:         }
 51301: 
 51301:         NS_ASSERTION(GetCurrentDoc(), "The element should be in a document "
 51301:                                       "when UpdateFormOwner is called!");
 51492:         NS_ASSERTION(!GetCurrentDoc() ||
 51492:                      element == GetCurrentDoc()->GetElementById(formId),
 51301:                      "element should be equals to the current element "
 51301:                      "associated with the id in @form!");
 51301: 
 82292:         if (element && element->IsHTML(nsGkAtoms::form)) {
 51301:           mForm = static_cast<nsHTMLFormElement*>(element);
 51301:         }
 51301:       }
 51301:      } else {
 51301:       // We now have a parent, so we may have picked up an ancestor form.  Search
 51301:       // for it.  Note that if mForm is already set we don't want to do this,
 51301:       // because that means someone (probably the content sink) has already set
 51301:       // it to the right value.  Also note that even if being bound here didn't
 51301:       // change our parent, we still need to search, since our parent chain
 51301:       // probably changed _somewhere_.
 51301:       mForm = FindAncestorForm();
 51301:     }
 51301:   }
 51301: 
 51301:   if (mForm && !HasFlag(ADDED_TO_FORM)) {
 51301:     // Now we need to add ourselves to the form
 51301:     nsAutoString nameVal, idVal;
 51301:     GetAttr(kNameSpaceID_None, nsGkAtoms::name, nameVal);
 51301:     GetAttr(kNameSpaceID_None, nsGkAtoms::id, idVal);
 51301: 
 51301:     SetFlags(ADDED_TO_FORM);
 51301: 
 51301:     // Notify only if we just found this mForm.
106838:     mForm->AddElement(this, true, oldForm == nullptr);
 51301: 
 51301:     if (!nameVal.IsEmpty()) {
 51301:       mForm->AddElementToTable(this, nameVal);
 51301:     }
 51301: 
 51301:     if (!idVal.IsEmpty()) {
 51301:       mForm->AddElementToTable(this, idVal);
 51301:     }
 51301:   }
 71121: 
 71121:   if (mForm != oldForm || needStateUpdate) {
 71121:     UpdateState(true);
 71121:   }
 51301: }
 51301: 
 54342: void
 79445: nsGenericHTMLFormElement::UpdateFieldSet(bool aNotify)
 54342: {
106838:   nsIContent* parent = nullptr;
106838:   nsIContent* prev = nullptr;
 54346: 
 54346:   for (parent = GetParent(); parent;
 54346:        prev = parent, parent = parent->GetParent()) {
 54346:     nsHTMLFieldSetElement* fieldset =
 78416:       nsHTMLFieldSetElement::FromContent(parent);
 78416:     if (fieldset &&
 78416:         (!prev || fieldset->GetFirstLegend() != prev)) {
 71121:       if (mFieldSet == fieldset) {
 71121:         // We already have the right fieldset;
 71121:         return;
 71121:       }
 71121: 
 56935:       if (mFieldSet) {
 78416:         mFieldSet->RemoveElement(this);
 56935:       }
 54346:       mFieldSet = fieldset;
 56935:       fieldset->AddElement(this);
 71121: 
 71121:       // The disabled state may have changed
 71121:       FieldSetDisabledChanged(aNotify);
 54342:       return;
 54342:     }
 54342:   }
 54342: 
 54342:   // No fieldset found.
 56935:   if (mFieldSet) {
 78416:     mFieldSet->RemoveElement(this);
106838:     mFieldSet = nullptr;
 71121:     // The disabled state may have changed
 71121:     FieldSetDisabledChanged(aNotify);
 71121:   }
 54342: }
 54342: 
 54342: void
 79445: nsGenericHTMLFormElement::FieldSetDisabledChanged(bool aNotify)
 54342: {
 71121:   UpdateState(aNotify);
 54342: }
 54342: 
101616: bool
101616: nsGenericHTMLFormElement::IsLabelable() const
101616: {
101616:   // TODO: keygen should be in that list, see bug 101019.
101616:   // TODO: NS_FORM_INPUT_HIDDEN should be removed, see bug 597650.
108991:   uint32_t type = GetType();
101616:   return type & NS_FORM_INPUT_ELEMENT ||
101616:          type & NS_FORM_BUTTON_ELEMENT ||
101616:          // type == NS_FORM_KEYGEN ||
101616:          type == NS_FORM_OUTPUT ||
101616:          type == NS_FORM_SELECT ||
101616:          type == NS_FORM_TEXTAREA;
101616: }
101616: 
     1: //----------------------------------------------------------------------
     1: 
121921: void
121921: nsGenericHTMLElement::Blur(mozilla::ErrorResult& aError)
     1: {
 82292:   if (!ShouldBlur(this)) {
121921:     return;
 82292:   }
 29018: 
 29018:   nsIDocument* doc = GetCurrentDoc();
 82292:   if (!doc) {
121921:     return;
 82292:   }
 29018: 
 29018:   nsIDOMWindow* win = doc->GetWindow();
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
121921:   if (win && fm) {
121921:     aError = fm->ClearFocus(win);
121921:   }
     1: }
     1: 
116223: void
116223: nsGenericHTMLElement::Focus(ErrorResult& aError)
     1: {
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
116223:   if (fm) {
 29018:     nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(this);
116223:     aError = fm->SetFocus(elem, 0);
116223:   }
     1: }
     1: 
116222: void
116222: nsGenericHTMLElement::Click()
 67818: {
 67818:   if (HasFlag(NODE_HANDLING_CLICK))
116222:     return;
 67818: 
 67818:   // Strong in case the event kills it
 67818:   nsCOMPtr<nsIDocument> doc = GetCurrentDoc();
 67818: 
 82292:   nsCOMPtr<nsIPresShell> shell;
 82292:   nsRefPtr<nsPresContext> context;
 67818:   if (doc) {
 67818:     shell = doc->GetShell();
 67818:     if (shell) {
 67818:       context = shell->GetPresContext();
 67818:     }
 67818:   }
 67818: 
 67818:   SetFlags(NODE_HANDLING_CLICK);
 67818: 
 67818:   // Click() is never called from native code, but it may be
 67818:   // called from chrome JS. Mark this event trusted if Click()
 67818:   // is called from chrome code.
 67818:   nsMouseEvent event(nsContentUtils::IsCallerChrome(),
106838:                      NS_MOUSE_CLICK, nullptr, nsMouseEvent::eReal);
 77227:   event.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_UNKNOWN;
 67818: 
 67818:   nsEventDispatcher::Dispatch(this, context, &event);
 67818: 
 67818:   UnsetFlags(NODE_HANDLING_CLICK);
 67818: }
 67818: 
 79445: bool
 79445: nsGenericHTMLElement::IsHTMLFocusable(bool aWithMouse,
 79445:                                       bool *aIsFocusable,
108991:                                       int32_t *aTabIndex)
     1: {
 12253:   nsIDocument *doc = GetCurrentDoc();
 12253:   if (!doc || doc->HasFlag(NODE_IS_EDITABLE)) {
 12253:     // In designMode documents we only allow focusing the document.
 12253:     if (aTabIndex) {
 12253:       *aTabIndex = -1;
 12253:     }
 12253: 
 80486:     *aIsFocusable = false;
 80486: 
 80486:     return true;
 12253:   }
 12253: 
121921:   int32_t tabIndex = TabIndex();
     1: 
 79445:   bool override, disabled = false;
  2896:   if (IsEditableRoot()) {
 14348:     // Editable roots should always be focusable.
 80486:     override = true;
 14348: 
  3444:     // Ignore the disabled attribute in editable contentEditable/designMode
  3444:     // roots.
  2896:     if (!HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)) {
  3444:       // The default value for tabindex should be 0 for editable
  3444:       // contentEditable roots.
  2896:       tabIndex = 0;
  2896:     }
  2896:   }
  2896:   else {
 80486:     override = false;
 14348: 
 29018:     // Just check for disabled attribute on form controls
 54342:     disabled = IsDisabled();
     1:     if (disabled) {
     1:       tabIndex = -1;
     1:     }
  2896:   }
     1: 
     1:   if (aTabIndex) {
     1:     *aTabIndex = tabIndex;
     1:   }
     1: 
     1:   // If a tabindex is specified at all, or the default tabindex is 0, we're focusable
 43884:   *aIsFocusable = 
 43884:     (tabIndex >= 0 || (!disabled && HasAttr(kNameSpaceID_None, nsGkAtoms::tabindex)));
 14348: 
 14348:   return override;
     1: }
     1: 
     1: void
 79445: nsGenericHTMLElement::RegUnRegAccessKey(bool aDoReg)
     1: {
     1:   // first check to see if we have an access key
     1:   nsAutoString accessKey;
     1:   GetAttr(kNameSpaceID_None, nsGkAtoms::accesskey, accessKey);
     1:   if (accessKey.IsEmpty()) {
     1:     return;
     1:   }
     1: 
     1:   // We have an access key, so get the ESM from the pres context.
     1:   nsPresContext *presContext = GetPresContext();
     1: 
     1:   if (presContext) {
 68780:     nsEventStateManager *esm = presContext->EventStateManager();
     1: 
     1:     // Register or unregister as appropriate.
     1:     if (aDoReg) {
108991:       esm->RegisterAccessKey(this, (uint32_t)accessKey.First());
     1:     } else {
108991:       esm->UnregisterAccessKey(this, (uint32_t)accessKey.First());
     1:     }
     1:   }
     1: }
     1: 
     1: void
 79445: nsGenericHTMLElement::PerformAccesskey(bool aKeyCausesActivation,
 79445:                                        bool aIsTrustedEvent)
     1: {
     1:   nsPresContext *presContext = GetPresContext();
     1:   if (!presContext)
     1:     return;
     1: 
     1:   // It's hard to say what HTML4 wants us to do in all cases.
 29018:   nsIFocusManager* fm = nsFocusManager::GetFocusManager();
 29018:   if (fm) {
 29018:     nsCOMPtr<nsIDOMElement> elem = do_QueryInterface(this);
 29018:     fm->SetFocus(elem, nsIFocusManager::FLAG_BYKEY);
 29018:   }
     1: 
     1:   if (aKeyCausesActivation) {
     1:     // Click on it if the users prefs indicate to do so.
     1:     nsMouseEvent event(aIsTrustedEvent, NS_MOUSE_CLICK,
106838:                        nullptr, nsMouseEvent::eReal);
 77227:     event.inputSource = nsIDOMMouseEvent::MOZ_SOURCE_KEYBOARD;
     1: 
     1:     nsAutoPopupStatePusher popupStatePusher(aIsTrustedEvent ?
     1:                                             openAllowed : openAbused);
     1: 
     1:     nsEventDispatcher::Dispatch(this, presContext, &event);
     1:   }
     1: }
     1: 
     1: const nsAttrName*
     1: nsGenericHTMLElement::InternalGetExistingAttrNameFromQName(const nsAString& aStr) const
     1: {
 29004:   if (IsInHTMLDocument()) {
     1:     nsAutoString lower;
 38422:     nsContentUtils::ASCIIToLower(aStr, lower);
 39101:     return mAttrsAndChildren.GetExistingAttrNameFromQName(lower);
 39101:   }
 39101: 
 39101:   return mAttrsAndChildren.GetExistingAttrNameFromQName(aStr);
     1: }
     1: 
     1: nsresult
     1: nsGenericHTMLElement::GetEditor(nsIEditor** aEditor)
     1: {
106838:   *aEditor = nullptr;
     1: 
120109:   if (!nsContentUtils::IsCallerChrome()) {
     1:     return NS_ERROR_DOM_SECURITY_ERR;
 82292:   }
     1: 
     1:   return GetEditorInternal(aEditor);
     1: }
     1: 
     1: nsresult
     1: nsGenericHTMLElement::GetEditorInternal(nsIEditor** aEditor)
     1: {
106838:   *aEditor = nullptr;
     1: 
 43129:   nsCOMPtr<nsITextControlElement> textCtrl = do_QueryInterface(this);
 43129:   if (textCtrl) {
 43129:     *aEditor = textCtrl->GetTextEditor();
 43129:     NS_IF_ADDREF(*aEditor);
     1:   }
     1: 
     1:   return NS_OK;
     1: }
     1: 
     1: already_AddRefed<nsIEditor>
     1: nsGenericHTMLElement::GetAssociatedEditor()
     1: {
     1:   // If contenteditable is ever implemented, it might need to do something different here?
     1: 
106838:   nsIEditor* editor = nullptr;
     1:   GetEditorInternal(&editor);
     1:   return editor;
     1: }
     1: 
 79445: bool
     1: nsGenericHTMLElement::IsCurrentBodyElement()
     1: {
 82292:   // TODO Bug 698498: Should this handle the case where GetBody returns a
 82292:   //                  frameset?
     1:   nsCOMPtr<nsIDOMHTMLBodyElement> bodyElement = do_QueryInterface(this);
     1:   if (!bodyElement) {
 80486:     return false;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMHTMLDocument> htmlDocument =
     1:     do_QueryInterface(GetCurrentDoc());
     1:   if (!htmlDocument) {
 80486:     return false;
     1:   }
     1: 
     1:   nsCOMPtr<nsIDOMHTMLElement> htmlElement;
     1:   htmlDocument->GetBody(getter_AddRefs(htmlElement));
     1:   return htmlElement == bodyElement;
     1: }
     1: 
     1: // static
     1: void
     1: nsGenericHTMLElement::SyncEditorsOnSubtree(nsIContent* content)
     1: {
     1:   /* Sync this node */
     1:   nsGenericHTMLElement* element = FromContent(content);
     1:   if (element) {
     1:     nsCOMPtr<nsIEditor> editor = element->GetAssociatedEditor();
     1:     if (editor) {
     1:       editor->SyncRealTimeSpell();
     1:     }
     1:   }
     1: 
     1:   /* Sync all children */
 78992:   for (nsIContent* child = content->GetFirstChild();
 78992:        child;
 78992:        child = child->GetNextSibling()) {
 78992:     SyncEditorsOnSubtree(child);
     1:   }
     1: }
     1: 
     1: void
     1: nsGenericHTMLElement::RecompileScriptEventListeners()
     1: {
108991:     int32_t i, count = mAttrsAndChildren.AttrCount();
     1:     for (i = 0; i < count; ++i) {
     1:         const nsAttrName *name = mAttrsAndChildren.AttrNameAt(i);
     1: 
     1:         // Eventlistenener-attributes are always in the null namespace
     1:         if (!name->IsAtom()) {
     1:             continue;
     1:         }
     1: 
     1:         nsIAtom *attr = name->Atom();
   265:         if (!nsContentUtils::IsEventAttributeName(attr, EventNameType_HTML)) {
     1:             continue;
     1:         }
     1: 
     1:         nsAutoString value;
     1:         GetAttr(kNameSpaceID_None, attr, value);
110743:         SetEventHandler(attr, value, true);
     1:     }
     1: }
  2896: 
 79445: bool
  2896: nsGenericHTMLElement::IsEditableRoot() const
  2896: {
  2896:   nsIDocument *document = GetCurrentDoc();
  2896:   if (!document) {
 80486:     return false;
  2896:   }
  2896: 
  2896:   if (document->HasFlag(NODE_IS_EDITABLE)) {
 80486:     return false;
  2896:   }
  2896: 
  3444:   if (GetContentEditableValue() != eTrue) {
 80486:     return false;
  2896:   }
  2896: 
  2896:   nsIContent *parent = GetParent();
  2896: 
  2896:   return !parent || !parent->HasFlag(NODE_IS_EDITABLE);
  2896: }
  2896: 
  2896: static void
  2896: MakeContentDescendantsEditable(nsIContent *aContent, nsIDocument *aDocument)
  2896: {
 71110:   // If aContent is not an element, we just need to update its
 71110:   // internal editable state and don't need to notify anyone about
 71110:   // that.  For elements, we need to send a ContentStateChanged
 71110:   // notification.
 71110:   if (!aContent->IsElement()) {
 80486:     aContent->UpdateEditableState(false);
 71110:     return;
 71110:   }
 71110: 
 71110:   Element *element = aContent->AsElement();
 71121: 
 80486:   element->UpdateEditableState(true);
  2896: 
 71110:   for (nsIContent *child = aContent->GetFirstChild();
 71110:        child;
 71110:        child = child->GetNextSibling()) {
  2896:     if (!child->HasAttr(kNameSpaceID_None, nsGkAtoms::contenteditable)) {
  2896:       MakeContentDescendantsEditable(child, aDocument);
  2896:     }
  2896:   }
  2896: }
  2896: 
  2896: void
108991: nsGenericHTMLElement::ChangeEditableState(int32_t aChange)
  2896: {
  2896:   nsIDocument* document = GetCurrentDoc();
  2896:   if (!document) {
  2896:     return;
  2896:   }
  2896: 
  2896:   if (aChange != 0) {
  2896:     nsCOMPtr<nsIHTMLDocument> htmlDocument =
  2896:       do_QueryInterface(document);
  2896:     if (htmlDocument) {
  2896:       htmlDocument->ChangeContentEditableCount(this, aChange);
  2896:     }
  2896:   }
  2896: 
  2896:   if (document->HasFlag(NODE_IS_EDITABLE)) {
106838:     document = nullptr;
  2896:   }
  2896: 
 64120:   // MakeContentDescendantsEditable is going to call ContentStateChanged for
 52197:   // this element and all descendants if editable state has changed.
 71103:   // We might as well wrap it all in one script blocker.
 71103:   nsAutoScriptBlocker scriptBlocker;
  2896:   MakeContentDescendantsEditable(this, document);
  2896: }
101092: 
114093: JS::Value
114093: nsGenericHTMLElement::GetItemValue(JSContext* aCx, JSObject* aScope,
121921:                                    ErrorResult& aError)
114093: {
114093:   if (!HasAttr(kNameSpaceID_None, nsGkAtoms::itemprop)) {
114093:     return JS::NullValue();
114093:   }
114093: 
121921:   if (ItemScope()) {
114093:     JS::Value v;
114093:     if (!mozilla::dom::WrapObject(aCx, aScope, this, &v)) {
121921:       aError.Throw(NS_ERROR_FAILURE);
114093:       return JS::UndefinedValue();
114093:     }
114093:     return v;
114093:   }
114093: 
114093:   nsString string;
114093:   GetItemValueText(string);
114093:   JS::Value v;
114093:   if (!xpc::NonVoidStringToJsval(aCx, string, &v)) {
121921:     aError.Throw(NS_ERROR_FAILURE);
114093:     return JS::UndefinedValue();
114093:   }
114093:   return v;
114093: }
114093: 
101092: NS_IMETHODIMP
101092: nsGenericHTMLElement::GetItemValue(nsIVariant** aValue)
101092: {
101092:   nsCOMPtr<nsIWritableVariant> out = new nsVariant();
101092: 
101092:   if (!HasAttr(kNameSpaceID_None, nsGkAtoms::itemprop)) {
101092:     out->SetAsEmpty();
101092:     out.forget(aValue);
101092:     return NS_OK;
101092:   }
101092: 
121921:   if (ItemScope()) {
101092:     out->SetAsISupports(static_cast<nsISupports*>(this));
101092:   } else {
101092:     nsAutoString string;
101092:     GetItemValueText(string);
101092:     out->SetAsAString(string);
101092:   }
101092: 
101092:   out.forget(aValue);
101092:   return NS_OK;
101092: }
101092: 
121921: void
121921: nsGenericHTMLElement::SetItemValue(JSContext* aCx, JS::Value aValue,
121921:                                    ErrorResult& aError)
121921: {
121921:   if (!HasAttr(kNameSpaceID_None, nsGkAtoms::itemprop) ||
121921:       HasAttr(kNameSpaceID_None, nsGkAtoms::itemscope)) {
121921:     aError.Throw(NS_ERROR_DOM_INVALID_ACCESS_ERR);
121921:     return;
121921:   }
121921: 
121921:   FakeDependentString string;
121921:   if (!ConvertJSValueToString(aCx, aValue, &aValue, eStringify, eStringify, string)) {
121921:     aError.Throw(NS_ERROR_UNEXPECTED);
121921:     return;
121921:   }
121921:   SetItemValueText(string);
121921: }
121921: 
101092: NS_IMETHODIMP
101092: nsGenericHTMLElement::SetItemValue(nsIVariant* aValue)
101092: {
101092:   if (!HasAttr(kNameSpaceID_None, nsGkAtoms::itemprop) ||
101092:       HasAttr(kNameSpaceID_None, nsGkAtoms::itemscope)) {
101092:     return NS_ERROR_DOM_INVALID_ACCESS_ERR;
101092:   }
101092: 
101092:   nsAutoString string;
101092:   aValue->GetAsAString(string);
101092:   SetItemValueText(string);
101092:   return NS_OK;
101092: }
101092: 
101092: void
101092: nsGenericHTMLElement::GetItemValueText(nsAString& text)
101092: {
119415:   GetTextContentInternal(text);
101092: }
101092: 
101092: void
101092: nsGenericHTMLElement::SetItemValueText(const nsAString& text)
101092: {
119415:   mozilla::ErrorResult rv;
119415:   SetTextContentInternal(text, rv);
101092: }
101092: 
101092: static void
101092: nsDOMSettableTokenListPropertyDestructor(void *aObject, nsIAtom *aProperty,
101092:                                          void *aPropertyValue, void *aData)
101092: {
101092:   nsDOMSettableTokenList* list =
101092:     static_cast<nsDOMSettableTokenList*>(aPropertyValue);
101751:   list->DropReference();
101751:   NS_RELEASE(list);
101092: }
101092: 
101092: nsDOMSettableTokenList*
101092: nsGenericHTMLElement::GetTokenList(nsIAtom* aAtom)
101092: {
101092:   nsDOMSettableTokenList* list = NULL;
101092:   if (HasProperties()) {
101092:     list = static_cast<nsDOMSettableTokenList*>(GetProperty(aAtom));
101092:   }
101092:   if (!list) {
101092:     list = new nsDOMSettableTokenList(this, aAtom);
101092:     NS_ADDREF(list);
101092:     SetProperty(aAtom, list, nsDOMSettableTokenListPropertyDestructor);
101092:   }                       
101092:   return list;
101092: }  
101092: 
121921: void
121921: nsGenericHTMLElement::GetTokenList(nsIAtom* aAtom, nsIVariant** aResult)
101092: {
121921:   nsIDOMDOMSettableTokenList* itemType = GetTokenList(aAtom);
101092:   nsCOMPtr<nsIWritableVariant> out = new nsVariant();
101092:   out->SetAsInterface(NS_GET_IID(nsIDOMDOMSettableTokenList), itemType);
101092:   out.forget(aResult);
121921: }
121921: 
121921: nsresult
121921: nsGenericHTMLElement::SetTokenList(nsIAtom* aAtom, nsIVariant* aValue)
101092: {
121921:   nsDOMSettableTokenList* itemType = GetTokenList(aAtom);
101092:   nsAutoString string;
101092:   aValue->GetAsAString(string);
101092:   return itemType->SetValue(string);
101092: }
101092: 
101092: static void
114093: HTMLPropertiesCollectionDestructor(void *aObject, nsIAtom *aProperty,
101092:                                    void *aPropertyValue, void *aData)
101092: {
114093:   HTMLPropertiesCollection* properties = 
114093:     static_cast<HTMLPropertiesCollection*>(aPropertyValue);
101092:   NS_IF_RELEASE(properties);
101092: }
101092: 
121921: HTMLPropertiesCollection*
121921: nsGenericHTMLElement::Properties()
101092: {
114093:   HTMLPropertiesCollection* properties = 
114093:     static_cast<HTMLPropertiesCollection*>(GetProperty(nsGkAtoms::microdataProperties));
101092:   if (!properties) {
101092:      properties = new HTMLPropertiesCollection(this);
101092:      NS_ADDREF(properties);
114093:      SetProperty(nsGkAtoms::microdataProperties, properties, HTMLPropertiesCollectionDestructor);
101092:   }
121921:   return properties;
121921: }
121921: 
121921: void
125288: nsGenericHTMLElement::GetProperties(nsISupports** aProperties)
121921: {
125288:   NS_ADDREF(*aProperties = static_cast<nsIHTMLCollection*>(Properties()));
101092: }
101092: 
103120: nsSize
103120: nsGenericHTMLElement::GetWidthHeightForImage(imgIRequest *aImageRequest)
103120: {
103120:   nsSize size(0,0);
103120: 
103120:   nsIFrame* frame = GetPrimaryFrame(Flush_Layout);
103120: 
103120:   if (frame) {
103120:     size = frame->GetContentRect().Size();
103120: 
103120:     size.width = nsPresContext::AppUnitsToIntCSSPixels(size.width);
103120:     size.height = nsPresContext::AppUnitsToIntCSSPixels(size.height);
103120:   } else {
103120:     const nsAttrValue* value;
103120:     nsCOMPtr<imgIContainer> image;
103120:     if (aImageRequest) {
103120:       aImageRequest->GetImage(getter_AddRefs(image));
103120:     }
103120: 
103120:     if ((value = GetParsedAttr(nsGkAtoms::width)) &&
103120:         value->Type() == nsAttrValue::eInteger) {
103120:       size.width = value->GetIntegerValue();
103120:     } else if (image) {
103120:       image->GetWidth(&size.width);
103120:     }
103120: 
103120:     if ((value = GetParsedAttr(nsGkAtoms::height)) &&
103120:         value->Type() == nsAttrValue::eInteger) {
103120:       size.height = value->GetIntegerValue();
103120:     } else if (image) {
103120:       image->GetHeight(&size.height);
103120:     }
103120:   }
103120: 
103120:   NS_ASSERTION(size.width >= 0, "negative width");
103120:   NS_ASSERTION(size.height >= 0, "negative height");
103120:   return size;
103120: }
