    1: /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-
    1:  *
    1:  * ***** BEGIN LICENSE BLOCK *****
    1:  * Version: MPL 1.1/GPL 2.0/LGPL 2.1
    1:  *
    1:  * The contents of this file are subject to the Mozilla Public License Version
    1:  * 1.1 (the "License"); you may not use this file except in compliance with
    1:  * the License. You may obtain a copy of the License at
    1:  * http://www.mozilla.org/MPL/
    1:  *
    1:  * Software distributed under the License is distributed on an "AS IS" basis,
    1:  * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
    1:  * for the specific language governing rights and limitations under the
    1:  * License.
    1:  *
    1:  * The Original Code is mozilla.org code.
    1:  *
    1:  * The Initial Developer of the Original Code is
    1:  * Netscape Communications Corporation.
    1:  * Portions created by the Initial Developer are Copyright (C) 2001
    1:  * the Initial Developer. All Rights Reserved.
    1:  *
    1:  * Contributor(s):
    1:  *   Stuart Parmenter <pavlov@netscape.com>
    1:  *
    1:  * Alternatively, the contents of this file may be used under the terms of
    1:  * either of the GNU General Public License Version 2 or later (the "GPL"),
    1:  * or the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
    1:  * in which case the provisions of the GPL or the LGPL are applicable instead
    1:  * of those above. If you wish to allow use of your version of this file only
    1:  * under the terms of either the GPL or the LGPL, and not to allow others to
    1:  * use your version of this file under the terms of the MPL, indicate your
    1:  * decision by deleting the provisions above and replace them with the notice
    1:  * and other provisions required by the GPL or the LGPL. If you do not delete
    1:  * the provisions above, a recipient may use your version of this file under
    1:  * the terms of any one of the MPL, the GPL or the LGPL.
    1:  *
    1:  * ***** END LICENSE BLOCK ***** */
    1: 
    1: /* class to notify frames of background image loads */
    1: 
    1: #include "nsImageLoader.h"
    1: 
    1: #include "imgILoader.h"
    1: 
    1: #include "nsIURI.h"
    1: #include "nsILoadGroup.h"
    1: #include "nsNetUtil.h"
    1: 
    1: #include "nsPresContext.h"
    1: #include "nsIPresShell.h"
    1: #include "nsIFrame.h"
    1: #include "nsIContent.h"
    1: #include "nsIDocument.h"
    1: 
    1: #include "imgIContainer.h"
    1: 
    1: #include "nsStyleContext.h"
    1: #include "nsGkAtoms.h"
82102: #include "nsLayoutUtils.h"
    1: 
    1: // Paint forcing
    1: #include "prenv.h"
    1: 
    1: NS_IMPL_ISUPPORTS2(nsImageLoader, imgIDecoderObserver, imgIContainerObserver)
    1: 
32424: nsImageLoader::nsImageLoader(nsIFrame *aFrame, PRUint32 aActions,
25231:                              nsImageLoader *aNextLoader)
25231:   : mFrame(aFrame),
32424:     mActions(aActions),
82102:     mNextLoader(aNextLoader),
82102:     mRequestRegistered(false)
    1: {
    1: }
    1: 
    1: nsImageLoader::~nsImageLoader()
    1: {
82102:   Destroy();
    1: }
    1: 
25231: /* static */ already_AddRefed<nsImageLoader>
25231: nsImageLoader::Create(nsIFrame *aFrame, imgIRequest *aRequest, 
32424:                       PRUint32 aActions, nsImageLoader *aNextLoader)
25231: {
25231:   nsRefPtr<nsImageLoader> loader =
32424:     new nsImageLoader(aFrame, aActions, aNextLoader);
25220: 
25231:   loader->Load(aRequest);
25231: 
25231:   return loader.forget();
    1: }
    1: 
    1: void
    1: nsImageLoader::Destroy()
    1: {
25231:   // Destroy the chain with only one level of recursion.
25231:   nsRefPtr<nsImageLoader> list = mNextLoader;
25231:   mNextLoader = nsnull;
25231:   while (list) {
25231:     nsRefPtr<nsImageLoader> todestroy = list;
25231:     list = todestroy->mNextLoader;
25231:     todestroy->mNextLoader = nsnull;
25231:     todestroy->Destroy();
25231:   }
25231: 
82102:   if (mRequest && mFrame) {
82102:     nsLayoutUtils::DeregisterImageRequest(mFrame->PresContext(), mRequest,
82102:                                           &mRequestRegistered);
82571:   }
82571: 
82571:   mFrame = nsnull;
82571: 
82571:   if (mRequest) {
22953:     mRequest->CancelAndForgetObserver(NS_ERROR_FAILURE);
    1:   }
    1: 
    1:   mRequest = nsnull;
    1: }
    1: 
    1: nsresult
    1: nsImageLoader::Load(imgIRequest *aImage)
    1: {
25231:   NS_ASSERTION(!mRequest, "can't reuse image loaders");
68811:   NS_ASSERTION(mFrame, "not initialized");
68811:   NS_ASSERTION(aImage, "must have non-null image");
25231: 
    1:   if (!mFrame)
    1:     return NS_ERROR_NOT_INITIALIZED;
    1: 
    1:   if (!aImage)
    1:     return NS_ERROR_FAILURE;
    1: 
82102:   // Deregister mRequest from the refresh driver, since it is no longer
82102:   // going to be managed by this nsImageLoader.
82102:   nsPresContext* presContext = mFrame->PresContext();
82102: 
82102:   nsLayoutUtils::DeregisterImageRequest(presContext, mRequest,
82102:                                         &mRequestRegistered);
82102: 
    1:   // Make sure to clone into a temporary, then set mRequest, since
    1:   // cloning may notify and we don't want to trigger paints from this
    1:   // code.
    1:   nsCOMPtr<imgIRequest> newRequest;
    1:   nsresult rv = aImage->Clone(this, getter_AddRefs(newRequest));
    1:   mRequest.swap(newRequest);
82102: 
82102:   if (mRequest) {
82102:     nsLayoutUtils::RegisterImageRequestIfAnimated(presContext, mRequest,
82102:                                                   &mRequestRegistered);
82102:   }
82102: 
    1:   return rv;
    1: }
    1: 
    1: NS_IMETHODIMP nsImageLoader::OnStartContainer(imgIRequest *aRequest,
    1:                                               imgIContainer *aImage)
    1: {
32424:   NS_ABORT_IF_FALSE(aImage, "Who's calling us then?");
32424: 
    1:   /* Get requested animation policy from the pres context:
    1:    *   normal = 0
    1:    *   one frame = 1
    1:    *   one loop = 2
    1:    */
25231:   aImage->SetAnimationMode(mFrame->PresContext()->ImageAnimationMode());
32424: 
    1:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsImageLoader::OnStopFrame(imgIRequest *aRequest,
30479:                                          PRUint32 aFrame)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
32424:   if (!mRequest) {
32424:     // We're in the middle of a paint anyway
32424:     return NS_OK;
    1:   }
32424: 
32424:   // Take requested actions
32424:   if (mActions & ACTION_REFLOW_ON_DECODE) {
32424:     DoReflow();
    1:   }
32424:   if (mActions & ACTION_REDRAW_ON_DECODE) {
32424:     DoRedraw(nsnull);
32424:   }
32424:   return NS_OK;
32424: }
32424: 
82102: NS_IMETHODIMP nsImageLoader::OnImageIsAnimated(imgIRequest *aRequest)
82102: {
82102:   // Register with the refresh driver now that we are aware that
82102:   // we are animated.
82102:   nsLayoutUtils::RegisterImageRequest(mFrame->PresContext(),
82102:                                       aRequest, &mRequestRegistered);
82102:   return NS_OK;
82102: }
82102: 
32424: NS_IMETHODIMP nsImageLoader::OnStopRequest(imgIRequest *aRequest,
79445:                                            bool aLastPart)
32424: {
32424:   if (!mFrame)
32424:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!mRequest) {
    1:     // We're in the middle of a paint anyway
    1:     return NS_OK;
    1:   }
    1: 
32424:   // Take requested actions
32424:   if (mActions & ACTION_REFLOW_ON_LOAD) {
32424:     DoReflow();
32424:   }
32424:   if (mActions & ACTION_REDRAW_ON_LOAD) {
32424:     DoRedraw(nsnull);
32424:   }
32425:   return NS_OK;
    1: }
    1: 
    1: NS_IMETHODIMP nsImageLoader::FrameChanged(imgIContainer *aContainer,
50544:                                           const nsIntRect *aDirtyRect)
    1: {
    1:   if (!mFrame)
    1:     return NS_ERROR_FAILURE;
    1: 
    1:   if (!mRequest) {
    1:     // We're in the middle of a paint anyway
    1:     return NS_OK;
    1:   }
    1: 
68638:   nsRect r = aDirtyRect->IsEqualInterior(nsIntRect::GetMaxSizedIntRect()) ?
52214:     nsRect(nsPoint(0, 0), mFrame->GetSize()) :
52214:     aDirtyRect->ToAppUnits(nsPresContext::AppUnitsPerCSSPixel());
    1: 
32424:   DoRedraw(&r);
    1: 
    1:   return NS_OK;
    1: }
    1: 
    1: void
32424: nsImageLoader::DoReflow()
    1: {
25231:   nsIPresShell *shell = mFrame->PresContext()->GetPresShell();
19448:   shell->FrameNeedsReflow(mFrame, nsIPresShell::eStyleChange, NS_FRAME_IS_DIRTY);
15992: }
32424: 
32424: void
32424: nsImageLoader::DoRedraw(const nsRect* aDamageRect)
32424: {
    1:   // NOTE: It is not sufficient to invalidate only the size of the image:
    1:   //       the image may be tiled! 
    1:   //       The best option is to call into the frame, however lacking this
    1:   //       we have to at least invalidate the frame's bounds, hence
    1:   //       as long as we have a frame we'll use its size.
    1:   //
    1: 
    1:   // Invalidate the entire frame
    1:   // XXX We really only need to invalidate the client area of the frame...    
    1: 
    1:   nsRect bounds(nsPoint(0, 0), mFrame->GetSize());
    1: 
    1:   if (mFrame->GetType() == nsGkAtoms::canvasFrame) {
    1:     // The canvas's background covers the whole viewport.
55040:     bounds = mFrame->GetVisualOverflowRect();
    1:   }
    1: 
    1:   // XXX this should be ok, but there is some crappy ass bug causing it not to work
    1:   // XXX seems related to the "body fixup rule" dealing with the canvas and body frames...
    1: #if 0
    1:   // Invalidate the entire frame only if the frame has a tiled background
    1:   // image, otherwise just invalidate the intersection of the frame's bounds
    1:   // with the damaged rect.
    1:   nsStyleContext* styleContext;
    1:   mFrame->GetStyleContext(&styleContext);
    1:   const nsStyleBackground* bg = styleContext->GetStyleBackground();
    1: 
    1:   if ((bg->mBackgroundFlags & NS_STYLE_BG_IMAGE_NONE) ||
    1:       (bg->mBackgroundRepeat == NS_STYLE_BG_REPEAT_OFF)) {
    1:     // The frame does not have a background image so we are free
    1:     // to invalidate only the intersection of the damage rect and
    1:     // the frame's bounds.
    1: 
    1:     if (aDamageRect) {
    1:       bounds.IntersectRect(*aDamageRect, bounds);
    1:     }
    1:   }
    1: 
    1: #endif
    1: 
26345:   if (mFrame->GetStyleVisibility()->IsVisible()) {
19380:     mFrame->Invalidate(bounds);
    1:   }
26345: }
