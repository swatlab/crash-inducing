 39657: // Copyright (c) 2010 Google Inc.
 35721: // All rights reserved.
 35721: //
 35721: // Redistribution and use in source and binary forms, with or without
 35721: // modification, are permitted provided that the following conditions are
 35721: // met:
 35721: //
 35721: //     * Redistributions of source code must retain the above copyright
 35721: // notice, this list of conditions and the following disclaimer.
 35721: //     * Redistributions in binary form must reproduce the above
 35721: // copyright notice, this list of conditions and the following disclaimer
 35721: // in the documentation and/or other materials provided with the
 35721: // distribution.
 35721: //     * Neither the name of Google Inc. nor the names of its
 35721: // contributors may be used to endorse or promote products derived from
 35721: // this software without specific prior written permission.
 35721: //
 35721: // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 35721: // "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 35721: // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 35721: // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 35721: // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 35721: // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 35721: // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 35721: // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 35721: // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 35721: // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 35721: // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 35721: 
 35721: #include <stdint.h>
 35721: #include <unistd.h>
 35721: #include <signal.h>
 54618: #include <sys/mman.h>
 35721: #include <sys/poll.h>
 35721: #include <sys/socket.h>
 35721: #include <sys/uio.h>
114869: #include <sys/wait.h>
 35721: 
114869: #include <string>
114869: 
114869: #include "breakpad_googletest_includes.h"
 39657: #include "client/linux/handler/exception_handler.h"
 35721: #include "client/linux/minidump_writer/minidump_writer.h"
 37202: #include "common/linux/eintr_wrapper.h"
114869: #include "common/linux/file_id.h"
114869: #include "common/linux/ignore_ret.h"
 35721: #include "common/linux/linux_libc_support.h"
114869: #include "common/tests/auto_tempdir.h"
114869: #include "common/using_std_string.h"
114869: #include "third_party/lss/linux_syscall_support.h"
 54618: #include "google_breakpad/processor/minidump.h"
 35721: 
 35721: using namespace google_breakpad;
 35721: 
114869: namespace {
114869: 
114869: // Length of a formatted GUID string =
114869: // sizeof(MDGUID) * 2 + 4 (for dashes) + 1 (null terminator)
114869: const int kGUIDStringSize = 37;
114869: 
114869: void sigchld_handler(int signo) { }
114869: 
118328: int CreateTMPFile(const string& dir, string* path) {
118328:   string file = dir + "/exception-handler-unittest.XXXXXX";
114869:   const char* c_file = file.c_str();
114869:   // Copy that string, mkstemp needs a C string it can modify.
114869:   char* c_path = strdup(c_file);
114869:   const int fd = mkstemp(c_path);
114869:   if (fd >= 0)
114869:     *path = c_path;
114869:   free(c_path);
114869:   return fd;
114869: }
 35721: 
 35721: class ExceptionHandlerTest : public ::testing::Test {
 35721:  protected:
 35721:   void SetUp() {
 35721:     // We need to be able to wait for children, so SIGCHLD cannot be SIG_IGN.
 35721:     struct sigaction sa;
 35721:     memset(&sa, 0, sizeof(sa));
 35721:     sa.sa_handler = sigchld_handler;
 35721:     ASSERT_NE(sigaction(SIGCHLD, &sa, &old_action), -1);
 35721:   }
 35721: 
 35721:   void TearDown() {
 35721:     sigaction(SIGCHLD, &old_action, NULL);
 35721:   }
 35721: 
 35721:   struct sigaction old_action;
 35721: };
 35721: 
114869: 
114869: void WaitForProcessToTerminate(pid_t process_id, int expected_status) {
114869:   int status;
114869:   ASSERT_NE(HANDLE_EINTR(waitpid(process_id, &status, 0)), -1);
114869:   ASSERT_TRUE(WIFSIGNALED(status));
114869:   ASSERT_EQ(expected_status, WTERMSIG(status));
 35721: }
 35721: 
114869: // Reads the minidump path sent over the pipe |fd| and sets it in |path|.
118328: void ReadMinidumpPathFromPipe(int fd, string* path) {
114869:   struct pollfd pfd;
114869:   memset(&pfd, 0, sizeof(pfd));
114869:   pfd.fd = fd;
114869:   pfd.events = POLLIN | POLLERR;
114869: 
114869:   const int r = HANDLE_EINTR(poll(&pfd, 1, 0));
114869:   ASSERT_EQ(1, r);
114869:   ASSERT_TRUE(pfd.revents & POLLIN);
114869: 
114869:   uint32_t len;
114869:   ASSERT_EQ(static_cast<ssize_t>(sizeof(len)), read(fd, &len, sizeof(len)));
114869:   ASSERT_LT(len, static_cast<uint32_t>(2048));
114869:   char* filename = static_cast<char*>(malloc(len + 1));
114869:   ASSERT_EQ(len, read(fd, filename, len));
114869:   filename[len] = 0;
114869:   close(fd);
114869:   *path = filename;
114869:   free(filename);
114869: }
114869: 
114869: }  // namespace
114869: 
114869: TEST(ExceptionHandlerTest, SimpleWithPath) {
114869:   AutoTempDir temp_dir;
114869:   ExceptionHandler handler(
114869:       MinidumpDescriptor(temp_dir.path()), NULL, NULL, NULL, true, -1);
114869:   EXPECT_EQ(temp_dir.path(), handler.minidump_descriptor().directory());
114869:   string temp_subdir = temp_dir.path() + "/subdir";
114869:   handler.set_minidump_descriptor(MinidumpDescriptor(temp_subdir));
114869:   EXPECT_EQ(temp_subdir, handler.minidump_descriptor().directory());
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, SimpleWithFD) {
114869:   AutoTempDir temp_dir;
118328:   string path;
114869:   const int fd = CreateTMPFile(temp_dir.path(), &path);
114869:   ExceptionHandler handler(MinidumpDescriptor(fd), NULL, NULL, NULL, true, -1);
114869:   close(fd);
114869: }
114869: 
114869: static bool DoneCallback(const MinidumpDescriptor& descriptor,
114534:                          void* context,
114534:                          bool succeeded) {
114534:   if (!succeeded)
114869:     return false;
114534: 
114869:   if (!descriptor.IsFD()) {
114869:     int fd = reinterpret_cast<intptr_t>(context);
114869:     uint32_t len = 0;
114869:     len = my_strlen(descriptor.path());
114869:     IGNORE_RET(HANDLE_EINTR(sys_write(fd, &len, sizeof(len))));
114869:     IGNORE_RET(HANDLE_EINTR(sys_write(fd, descriptor.path(), len)));
114869:   }
114534:   return true;
114534: }
114534: 
114869: void ChildCrash(bool use_fd) {
114869:   AutoTempDir temp_dir;
114869:   int fds[2] = {0};
114869:   int minidump_fd = -1;
118328:   string minidump_path;
114869:   if (use_fd) {
114869:     minidump_fd = CreateTMPFile(temp_dir.path(), &minidump_path);
114869:   } else {
114534:     ASSERT_NE(pipe(fds), -1);
114869:   }
114534: 
114534:   const pid_t child = fork();
114534:   if (child == 0) {
114869:     {
118328:       google_breakpad::scoped_ptr<ExceptionHandler> handler;
114869:       if (use_fd) {
114869:         handler.reset(new ExceptionHandler(MinidumpDescriptor(minidump_fd),
114869:                                            NULL, NULL, NULL, true, -1));
114869:       } else {
114869:         close(fds[0]);  // Close the reading end.
114869:         void* fd_param = reinterpret_cast<void*>(fds[1]);
114869:         handler.reset(new ExceptionHandler(MinidumpDescriptor(temp_dir.path()),
114869:                                            NULL, DoneCallback, fd_param,
114869:                                            true, -1));
114534:       }
114869:       // Crash with the exception handler in scope.
114869:       *reinterpret_cast<volatile int*>(NULL) = 0;
114869:     }
114869:   }
114869:   if (!use_fd)
114869:     close(fds[1]);  // Close the writting end.
114534: 
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGSEGV));
114534: 
114869:   if (!use_fd)
114869:     ASSERT_NO_FATAL_FAILURE(ReadMinidumpPathFromPipe(fds[0], &minidump_path));
 35721: 
 35721:   struct stat st;
114869:   ASSERT_EQ(0, stat(minidump_path.c_str(), &st));
 35721:   ASSERT_GT(st.st_size, 0u);
114869:   unlink(minidump_path.c_str());
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, ChildCrashWithPath) {
114869:   ASSERT_NO_FATAL_FAILURE(ChildCrash(false));
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, ChildCrashWithFD) {
114869:   ASSERT_NO_FATAL_FAILURE(ChildCrash(true));
114869: }
114869: 
114869: static bool DoneCallbackReturnFalse(const MinidumpDescriptor& descriptor,
114869:                                     void* context,
114869:                                     bool succeeded) {
114869:   return false;
114869: }
114869: 
114869: static bool DoneCallbackReturnTrue(const MinidumpDescriptor& descriptor,
114869:                                    void* context,
114869:                                    bool succeeded) {
114869:   return true;
114869: }
114869: 
114869: static bool DoneCallbackRaiseSIGKILL(const MinidumpDescriptor& descriptor,
114869:                                      void* context,
114869:                                      bool succeeded) {
114869:   raise(SIGKILL);
118328:   return true;
114869: }
114869: 
114869: static bool FilterCallbackReturnFalse(void* context) {
114869:   return false;
114869: }
114869: 
114869: static bool FilterCallbackReturnTrue(void* context) {
114869:   return true;
114869: }
114869: 
114869: // SIGKILL cannot be blocked and a handler cannot be installed for it. In the
114869: // following tests, if the child dies with signal SIGKILL, then the signal was
114869: // redelivered to this handler. If the child dies with SIGSEGV then it wasn't.
114869: static void RaiseSIGKILL(int sig) {
114869:   raise(SIGKILL);
114869: }
114869: 
114869: static bool InstallRaiseSIGKILL() {
114869:   struct sigaction sa;
114869:   memset(&sa, 0, sizeof(sa));
114869:   sa.sa_handler = RaiseSIGKILL;
114869:   return sigaction(SIGSEGV, &sa, NULL) != -1;
114869: }
114869: 
114869: static void CrashWithCallbacks(ExceptionHandler::FilterCallback filter,
114869:                                ExceptionHandler::MinidumpCallback done,
114869:                                string path) {
114869:   ExceptionHandler handler(
114869:       MinidumpDescriptor(path), filter, done, NULL, true, -1);
114869:   // Crash with the exception handler in scope.
114869:   *reinterpret_cast<volatile int*>(NULL) = 0;
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, RedeliveryOnFilterCallbackFalse) {
114869:   AutoTempDir temp_dir;
114869: 
114869:   const pid_t child = fork();
114869:   if (child == 0) {
114869:     ASSERT_TRUE(InstallRaiseSIGKILL());
114869:     CrashWithCallbacks(FilterCallbackReturnFalse, NULL, temp_dir.path());
114869:   }
114869: 
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGKILL));
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, RedeliveryOnDoneCallbackFalse) {
114869:   AutoTempDir temp_dir;
114869: 
114869:   const pid_t child = fork();
114869:   if (child == 0) {
114869:     ASSERT_TRUE(InstallRaiseSIGKILL());
114869:     CrashWithCallbacks(NULL, DoneCallbackReturnFalse, temp_dir.path());
114869:   }
114869: 
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGKILL));
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, NoRedeliveryOnDoneCallbackTrue) {
114869:   AutoTempDir temp_dir;
114869: 
114869:   const pid_t child = fork();
114869:   if (child == 0) {
114869:     ASSERT_TRUE(InstallRaiseSIGKILL());
114869:     CrashWithCallbacks(NULL, DoneCallbackReturnTrue, temp_dir.path());
114869:   }
114869: 
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGSEGV));
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, NoRedeliveryOnFilterCallbackTrue) {
114869:   AutoTempDir temp_dir;
114869: 
114869:   const pid_t child = fork();
114869:   if (child == 0) {
114869:     ASSERT_TRUE(InstallRaiseSIGKILL());
114869:     CrashWithCallbacks(FilterCallbackReturnTrue, NULL, temp_dir.path());
114869:   }
114869: 
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGSEGV));
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, RedeliveryToDefaultHandler) {
114869:   AutoTempDir temp_dir;
114869: 
114869:   const pid_t child = fork();
114869:   if (child == 0) {
114869:     CrashWithCallbacks(FilterCallbackReturnFalse, NULL, temp_dir.path());
114869:   }
114869: 
114869:   // As RaiseSIGKILL wasn't installed, the redelivery should just kill the child
114869:   // with SIGSEGV.
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGSEGV));
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, StackedHandlersDeliveredToTop) {
114869:   AutoTempDir temp_dir;
114869: 
114869:   const pid_t child = fork();
114869:   if (child == 0) {
114869:     ExceptionHandler bottom(MinidumpDescriptor(temp_dir.path()),
114869:                             NULL,
114869:                             NULL,
114869:                             NULL,
114869:                             true,
114869:                             -1);
114869:     CrashWithCallbacks(NULL, DoneCallbackRaiseSIGKILL, temp_dir.path());
114869:   }
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGKILL));
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, StackedHandlersNotDeliveredToBottom) {
114869:   AutoTempDir temp_dir;
114869: 
114869:   const pid_t child = fork();
114869:   if (child == 0) {
114869:     ExceptionHandler bottom(MinidumpDescriptor(temp_dir.path()),
114869:                             NULL,
114869:                             DoneCallbackRaiseSIGKILL,
114869:                             NULL,
114869:                             true,
114869:                             -1);
114869:     CrashWithCallbacks(NULL, NULL, temp_dir.path());
114869:   }
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGSEGV));
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, StackedHandlersFilteredToBottom) {
114869:   AutoTempDir temp_dir;
114869: 
114869:   const pid_t child = fork();
114869:   if (child == 0) {
114869:     ExceptionHandler bottom(MinidumpDescriptor(temp_dir.path()),
114869:                             NULL,
114869:                             DoneCallbackRaiseSIGKILL,
114869:                             NULL,
114869:                             true,
114869:                             -1);
114869:     CrashWithCallbacks(FilterCallbackReturnFalse, NULL, temp_dir.path());
114869:   }
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGKILL));
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, StackedHandlersUnhandledToBottom) {
114869:   AutoTempDir temp_dir;
114869: 
114869:   const pid_t child = fork();
114869:   if (child == 0) {
114869:     ExceptionHandler bottom(MinidumpDescriptor(temp_dir.path()),
114869:                             NULL,
114869:                             DoneCallbackRaiseSIGKILL,
114869:                             NULL,
114869:                             true,
114869:                             -1);
114869:     CrashWithCallbacks(NULL, DoneCallbackReturnFalse, temp_dir.path());
114869:   }
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGKILL));
 54618: }
 54618: 
 54618: // Test that memory around the instruction pointer is written
 54618: // to the dump as a MinidumpMemoryRegion.
 54618: TEST(ExceptionHandlerTest, InstructionPointerMemory) {
114869:   AutoTempDir temp_dir;
 54618:   int fds[2];
 54618:   ASSERT_NE(pipe(fds), -1);
 54618: 
 54618:   // These are defined here so the parent can use them to check the
 54618:   // data from the minidump afterwards.
 54618:   const u_int32_t kMemorySize = 256;  // bytes
 54618:   const int kOffset = kMemorySize / 2;
 54618:   // This crashes with SIGILL on x86/x86-64/arm.
 54618:   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
 54618: 
 54618:   const pid_t child = fork();
 54618:   if (child == 0) {
 54618:     close(fds[0]);
114869:     ExceptionHandler handler(MinidumpDescriptor(temp_dir.path()), NULL,
114869:                              DoneCallback, reinterpret_cast<void*>(fds[1]),
114869:                              true, -1);
 54618:     // Get some executable memory.
 54618:     char* memory =
 54618:       reinterpret_cast<char*>(mmap(NULL,
 54618:                                    kMemorySize,
 54618:                                    PROT_READ | PROT_WRITE | PROT_EXEC,
 54618:                                    MAP_PRIVATE | MAP_ANON,
 54618:                                    -1,
 54618:                                    0));
 54618:     if (!memory)
 54618:       exit(0);
 54618: 
 54618:     // Write some instructions that will crash. Put them in the middle
 54618:     // of the block of memory, because the minidump should contain 128
 54618:     // bytes on either side of the instruction pointer.
 54618:     memcpy(memory + kOffset, instructions, sizeof(instructions));
 54618: 
 54618:     // Now execute the instructions, which should crash.
 54618:     typedef void (*void_function)(void);
 54618:     void_function memory_function =
 54618:         reinterpret_cast<void_function>(memory + kOffset);
 54618:     memory_function();
 54618:   }
 54618:   close(fds[1]);
 54618: 
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGILL));
 54618: 
114869:   string minidump_path;
114869:   ASSERT_NO_FATAL_FAILURE(ReadMinidumpPathFromPipe(fds[0], &minidump_path));
 54618: 
 54618:   struct stat st;
114869:   ASSERT_EQ(0, stat(minidump_path.c_str(), &st));
 54618:   ASSERT_GT(st.st_size, 0u);
 54618: 
 54618:   // Read the minidump. Locate the exception record and the
 54618:   // memory list, and then ensure that there is a memory region
 54618:   // in the memory list that covers the instruction pointer from
 54618:   // the exception record.
114869:   Minidump minidump(minidump_path);
 54618:   ASSERT_TRUE(minidump.Read());
 54618: 
 54618:   MinidumpException* exception = minidump.GetException();
 54618:   MinidumpMemoryList* memory_list = minidump.GetMemoryList();
 54618:   ASSERT_TRUE(exception);
 54618:   ASSERT_TRUE(memory_list);
 54618:   ASSERT_LT(0, memory_list->region_count());
 54618: 
 54618:   MinidumpContext* context = exception->GetContext();
 54618:   ASSERT_TRUE(context);
 54618: 
 54618:   u_int64_t instruction_pointer;
114869:   ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 54618: 
 54618:   MinidumpMemoryRegion* region =
 54618:       memory_list->GetMemoryRegionForAddress(instruction_pointer);
 54618:   ASSERT_TRUE(region);
 54618: 
 54618:   EXPECT_EQ(kMemorySize, region->GetSize());
 54618:   const u_int8_t* bytes = region->GetMemory();
 54618:   ASSERT_TRUE(bytes);
 54618: 
 54618:   u_int8_t prefix_bytes[kOffset];
 54618:   u_int8_t suffix_bytes[kMemorySize - kOffset - sizeof(instructions)];
 54618:   memset(prefix_bytes, 0, sizeof(prefix_bytes));
 54618:   memset(suffix_bytes, 0, sizeof(suffix_bytes));
 54618:   EXPECT_TRUE(memcmp(bytes, prefix_bytes, sizeof(prefix_bytes)) == 0);
 54618:   EXPECT_TRUE(memcmp(bytes + kOffset, instructions, sizeof(instructions)) == 0);
 54618:   EXPECT_TRUE(memcmp(bytes + kOffset + sizeof(instructions),
 54618:                      suffix_bytes, sizeof(suffix_bytes)) == 0);
 54618: 
114869:   unlink(minidump_path.c_str());
 54618: }
 54618: 
 54618: // Test that the memory region around the instruction pointer is
 54618: // bounded correctly on the low end.
 54618: TEST(ExceptionHandlerTest, InstructionPointerMemoryMinBound) {
114869:   AutoTempDir temp_dir;
 54618:   int fds[2];
 54618:   ASSERT_NE(pipe(fds), -1);
 54618: 
 54618:   // These are defined here so the parent can use them to check the
 54618:   // data from the minidump afterwards.
 54618:   const u_int32_t kMemorySize = 256;  // bytes
 54618:   const int kOffset = 0;
 54618:   // This crashes with SIGILL on x86/x86-64/arm.
 54618:   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
 54618: 
 54618:   const pid_t child = fork();
 54618:   if (child == 0) {
 54618:     close(fds[0]);
114869:     ExceptionHandler handler(MinidumpDescriptor(temp_dir.path()), NULL,
114869:                              DoneCallback, reinterpret_cast<void*>(fds[1]),
114869:                              true, -1);
 54618:     // Get some executable memory.
 54618:     char* memory =
 54618:         reinterpret_cast<char*>(mmap(NULL,
 54618:                                      kMemorySize,
 54618:                                      PROT_READ | PROT_WRITE | PROT_EXEC,
 54618:                                      MAP_PRIVATE | MAP_ANON,
 54618:                                      -1,
 54618:                                      0));
 54618:     if (!memory)
 54618:       exit(0);
 54618: 
 54618:     // Write some instructions that will crash. Put them in the middle
 54618:     // of the block of memory, because the minidump should contain 128
 54618:     // bytes on either side of the instruction pointer.
 54618:     memcpy(memory + kOffset, instructions, sizeof(instructions));
 54618: 
 54618:     // Now execute the instructions, which should crash.
 54618:     typedef void (*void_function)(void);
 54618:     void_function memory_function =
 54618:         reinterpret_cast<void_function>(memory + kOffset);
 54618:     memory_function();
 54618:   }
 54618:   close(fds[1]);
 54618: 
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGILL));
 54618: 
114869:   string minidump_path;
114869:   ASSERT_NO_FATAL_FAILURE(ReadMinidumpPathFromPipe(fds[0], &minidump_path));
 54618: 
 54618:   struct stat st;
114869:   ASSERT_EQ(0, stat(minidump_path.c_str(), &st));
 54618:   ASSERT_GT(st.st_size, 0u);
 54618: 
 54618:   // Read the minidump. Locate the exception record and the
 54618:   // memory list, and then ensure that there is a memory region
 54618:   // in the memory list that covers the instruction pointer from
 54618:   // the exception record.
114869:   Minidump minidump(minidump_path);
 54618:   ASSERT_TRUE(minidump.Read());
 54618: 
 54618:   MinidumpException* exception = minidump.GetException();
 54618:   MinidumpMemoryList* memory_list = minidump.GetMemoryList();
 54618:   ASSERT_TRUE(exception);
 54618:   ASSERT_TRUE(memory_list);
 54618:   ASSERT_LT(0, memory_list->region_count());
 54618: 
 54618:   MinidumpContext* context = exception->GetContext();
 54618:   ASSERT_TRUE(context);
 54618: 
 54618:   u_int64_t instruction_pointer;
114869:   ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 54618: 
 54618:   MinidumpMemoryRegion* region =
 54618:       memory_list->GetMemoryRegionForAddress(instruction_pointer);
 54618:   ASSERT_TRUE(region);
 54618: 
 54618:   EXPECT_EQ(kMemorySize / 2, region->GetSize());
 54618:   const u_int8_t* bytes = region->GetMemory();
 54618:   ASSERT_TRUE(bytes);
 54618: 
 54618:   u_int8_t suffix_bytes[kMemorySize / 2 - sizeof(instructions)];
 54618:   memset(suffix_bytes, 0, sizeof(suffix_bytes));
 54618:   EXPECT_TRUE(memcmp(bytes + kOffset, instructions, sizeof(instructions)) == 0);
 54618:   EXPECT_TRUE(memcmp(bytes + kOffset + sizeof(instructions),
 54618:                      suffix_bytes, sizeof(suffix_bytes)) == 0);
114869:   unlink(minidump_path.c_str());
 54618: }
 54618: 
 54618: // Test that the memory region around the instruction pointer is
 54618: // bounded correctly on the high end.
 54618: TEST(ExceptionHandlerTest, InstructionPointerMemoryMaxBound) {
114869:   AutoTempDir temp_dir;
 54618:   int fds[2];
 54618:   ASSERT_NE(pipe(fds), -1);
 54618: 
 54618:   // These are defined here so the parent can use them to check the
 54618:   // data from the minidump afterwards.
 54618:   // Use 4k here because the OS will hand out a single page even
 54618:   // if a smaller size is requested, and this test wants to
 54618:   // test the upper bound of the memory range.
 54618:   const u_int32_t kMemorySize = 4096;  // bytes
 54618:   // This crashes with SIGILL on x86/x86-64/arm.
 54618:   const unsigned char instructions[] = { 0xff, 0xff, 0xff, 0xff };
 54618:   const int kOffset = kMemorySize - sizeof(instructions);
 54618: 
 54618:   const pid_t child = fork();
 54618:   if (child == 0) {
 54618:     close(fds[0]);
114869:     ExceptionHandler handler(MinidumpDescriptor(temp_dir.path()), NULL,
114869:                              DoneCallback, reinterpret_cast<void*>(fds[1]),
114869:                              true, -1);
 54618:     // Get some executable memory.
 54618:     char* memory =
 54618:         reinterpret_cast<char*>(mmap(NULL,
 54618:                                      kMemorySize,
 54618:                                      PROT_READ | PROT_WRITE | PROT_EXEC,
 54618:                                      MAP_PRIVATE | MAP_ANON,
 54618:                                      -1,
 54618:                                      0));
 54618:     if (!memory)
 54618:       exit(0);
 54618: 
 54618:     // Write some instructions that will crash. Put them in the middle
 54618:     // of the block of memory, because the minidump should contain 128
 54618:     // bytes on either side of the instruction pointer.
 54618:     memcpy(memory + kOffset, instructions, sizeof(instructions));
 54618: 
 54618:     // Now execute the instructions, which should crash.
 54618:     typedef void (*void_function)(void);
 54618:     void_function memory_function =
 54618:         reinterpret_cast<void_function>(memory + kOffset);
 54618:     memory_function();
 54618:   }
 54618:   close(fds[1]);
 54618: 
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGILL));
 54618: 
114869:   string minidump_path;
114869:   ASSERT_NO_FATAL_FAILURE(ReadMinidumpPathFromPipe(fds[0], &minidump_path));
 54618: 
 54618:   struct stat st;
114869:   ASSERT_EQ(0, stat(minidump_path.c_str(), &st));
 54618:   ASSERT_GT(st.st_size, 0u);
 54618: 
114869:   // Read the minidump. Locate the exception record and the memory list, and
114869:   // then ensure that there is a memory region in the memory list that covers
114869:   // the instruction pointer from the exception record.
114869:   Minidump minidump(minidump_path);
 54618:   ASSERT_TRUE(minidump.Read());
 54618: 
 54618:   MinidumpException* exception = minidump.GetException();
 54618:   MinidumpMemoryList* memory_list = minidump.GetMemoryList();
 54618:   ASSERT_TRUE(exception);
 54618:   ASSERT_TRUE(memory_list);
 54618:   ASSERT_LT(0, memory_list->region_count());
 54618: 
 54618:   MinidumpContext* context = exception->GetContext();
 54618:   ASSERT_TRUE(context);
 54618: 
 54618:   u_int64_t instruction_pointer;
114869:   ASSERT_TRUE(context->GetInstructionPointer(&instruction_pointer));
 54618: 
 54618:   MinidumpMemoryRegion* region =
 54618:       memory_list->GetMemoryRegionForAddress(instruction_pointer);
 54618:   ASSERT_TRUE(region);
 54618: 
 54618:   const size_t kPrefixSize = 128;  // bytes
 54618:   EXPECT_EQ(kPrefixSize + sizeof(instructions), region->GetSize());
 54618:   const u_int8_t* bytes = region->GetMemory();
 54618:   ASSERT_TRUE(bytes);
 54618: 
 54618:   u_int8_t prefix_bytes[kPrefixSize];
 54618:   memset(prefix_bytes, 0, sizeof(prefix_bytes));
 54618:   EXPECT_TRUE(memcmp(bytes, prefix_bytes, sizeof(prefix_bytes)) == 0);
 54618:   EXPECT_TRUE(memcmp(bytes + kPrefixSize,
 54618:                      instructions, sizeof(instructions)) == 0);
 54618: 
114869:   unlink(minidump_path.c_str());
 54618: }
 54618: 
114869: // If AddressSanitizer is used, NULL pointer dereferences generate SIGILL
114869: // (illegal instruction) instead of SIGSEGV (segmentation fault).  Also,
114869: // the number of memory regions differs, so there is no point in running
114869: // this test if AddressSanitizer is used.
114869: #ifndef ADDRESS_SANITIZER
114869: 
114869: // Ensure that an extra memory block doesn't get added when the instruction
114869: // pointer is not in mapped memory.
 54618: TEST(ExceptionHandlerTest, InstructionPointerMemoryNullPointer) {
114869:   AutoTempDir temp_dir;
 54618:   int fds[2];
 54618:   ASSERT_NE(pipe(fds), -1);
 54618: 
 54618:   const pid_t child = fork();
 54618:   if (child == 0) {
 54618:     close(fds[0]);
114869:     ExceptionHandler handler(MinidumpDescriptor(temp_dir.path()), NULL,
114869:                              DoneCallback, reinterpret_cast<void*>(fds[1]),
114869:                              true, -1);
 54618:     // Try calling a NULL pointer.
 54618:     typedef void (*void_function)(void);
114869:     void_function memory_function = reinterpret_cast<void_function>(NULL);
 54618:     memory_function();
 54618:   }
 54618:   close(fds[1]);
 54618: 
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGSEGV));
 54618: 
114869:   string minidump_path;
114869:   ASSERT_NO_FATAL_FAILURE(ReadMinidumpPathFromPipe(fds[0], &minidump_path));
 54618: 
 54618:   struct stat st;
114869:   ASSERT_EQ(0, stat(minidump_path.c_str(), &st));
 54618:   ASSERT_GT(st.st_size, 0u);
 54618: 
 54618:   // Read the minidump. Locate the exception record and the
 54618:   // memory list, and then ensure that there is a memory region
 54618:   // in the memory list that covers the instruction pointer from
 54618:   // the exception record.
114869:   Minidump minidump(minidump_path);
 54618:   ASSERT_TRUE(minidump.Read());
 54618: 
 54618:   MinidumpException* exception = minidump.GetException();
 54618:   MinidumpMemoryList* memory_list = minidump.GetMemoryList();
 54618:   ASSERT_TRUE(exception);
 54618:   ASSERT_TRUE(memory_list);
114869:   ASSERT_EQ(static_cast<unsigned int>(1), memory_list->region_count());
 54618: 
114869:   unlink(minidump_path.c_str());
 35721: }
114869: #endif // !ADDRESS_SANITIZER
 56283: 
 56283: // Test that anonymous memory maps can be annotated with names and IDs.
 56283: TEST(ExceptionHandlerTest, ModuleInfo) {
 56283:   // These are defined here so the parent can use them to check the
 56283:   // data from the minidump afterwards.
 56283:   const u_int32_t kMemorySize = sysconf(_SC_PAGESIZE);
 56283:   const char* kMemoryName = "a fake module";
 56283:   const u_int8_t kModuleGUID[sizeof(MDGUID)] = {
 56283:     0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
 56283:     0x88, 0x99, 0xAA, 0xBB, 0xCC, 0xDD, 0xEE, 0xFF
 56283:   };
114869:   char module_identifier_buffer[kGUIDStringSize];
 56283:   FileID::ConvertIdentifierToString(kModuleGUID,
 56283:                                     module_identifier_buffer,
 56283:                                     sizeof(module_identifier_buffer));
 56283:   string module_identifier(module_identifier_buffer);
 56283:   // Strip out dashes
 56283:   size_t pos;
 56283:   while ((pos = module_identifier.find('-')) != string::npos) {
 56283:     module_identifier.erase(pos, 1);
 56283:   }
 56283:   // And append a zero, because module IDs include an "age" field
 56283:   // which is always zero on Linux.
 56283:   module_identifier += "0";
 56283: 
 56283:   // Get some memory.
 56283:   char* memory =
 56283:       reinterpret_cast<char*>(mmap(NULL,
 56283:                                    kMemorySize,
 56283:                                    PROT_READ | PROT_WRITE,
 56283:                                    MAP_PRIVATE | MAP_ANON,
 56283:                                    -1,
 56283:                                    0));
114869:   const uintptr_t kMemoryAddress = reinterpret_cast<uintptr_t>(memory);
 56283:   ASSERT_TRUE(memory);
 56283: 
114869:   AutoTempDir temp_dir;
114869:   ExceptionHandler handler(
114869:       MinidumpDescriptor(temp_dir.path()), NULL, NULL, NULL, true, -1);
114869: 
 56283:   // Add info about the anonymous memory mapping.
 56283:   handler.AddMappingInfo(kMemoryName,
 56283:                          kModuleGUID,
 56283:                          kMemoryAddress,
 56283:                          kMemorySize,
 56283:                          0);
114869:   ASSERT_TRUE(handler.WriteMinidump());
 56283: 
114869:   const MinidumpDescriptor& minidump_desc = handler.minidump_descriptor();
114869:   // Read the minidump. Load the module list, and ensure that the mmap'ed
114869:   // |memory| is listed with the given module name and debug ID.
114869:   Minidump minidump(minidump_desc.path());
 56283:   ASSERT_TRUE(minidump.Read());
 56283: 
 56283:   MinidumpModuleList* module_list = minidump.GetModuleList();
 56283:   ASSERT_TRUE(module_list);
 56283:   const MinidumpModule* module =
 56283:       module_list->GetModuleForAddress(kMemoryAddress);
 56283:   ASSERT_TRUE(module);
 56283: 
 56283:   EXPECT_EQ(kMemoryAddress, module->base_address());
 56283:   EXPECT_EQ(kMemorySize, module->size());
 56283:   EXPECT_EQ(kMemoryName, module->code_file());
 56283:   EXPECT_EQ(module_identifier, module->debug_identifier());
 56283: 
114869:   unlink(minidump_desc.path());
 56283: }
 56283: 
 35721: static const unsigned kControlMsgSize =
 35721:     CMSG_SPACE(sizeof(int)) + CMSG_SPACE(sizeof(struct ucred));
 35721: 
 35721: static bool
 35721: CrashHandler(const void* crash_context, size_t crash_context_size,
 35721:              void* context) {
 35721:   const int fd = (intptr_t) context;
 35721:   int fds[2];
114869:   if (pipe(fds) == -1) {
114869:     // There doesn't seem to be any way to reliably handle
114869:     // this failure without the parent process hanging
114869:     // At least make sure that this process doesn't access
114869:     // unexpected file descriptors
114869:     fds[0] = -1;
114869:     fds[1] = -1;
114869:   }
 35721:   struct kernel_msghdr msg = {0};
 35721:   struct kernel_iovec iov;
 35721:   iov.iov_base = const_cast<void*>(crash_context);
 35721:   iov.iov_len = crash_context_size;
 35721:   msg.msg_iov = &iov;
 35721:   msg.msg_iovlen = 1;
 35721:   char cmsg[kControlMsgSize];
 35721:   memset(cmsg, 0, kControlMsgSize);
 35721:   msg.msg_control = cmsg;
 35721:   msg.msg_controllen = sizeof(cmsg);
 35721: 
 35721:   struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg);
 35721:   hdr->cmsg_level = SOL_SOCKET;
 35721:   hdr->cmsg_type = SCM_RIGHTS;
 35721:   hdr->cmsg_len = CMSG_LEN(sizeof(int));
 35721:   *((int*) CMSG_DATA(hdr)) = fds[1];
 35721:   hdr = CMSG_NXTHDR((struct msghdr*) &msg, hdr);
 35721:   hdr->cmsg_level = SOL_SOCKET;
 35721:   hdr->cmsg_type = SCM_CREDENTIALS;
 35721:   hdr->cmsg_len = CMSG_LEN(sizeof(struct ucred));
 35721:   struct ucred *cred = reinterpret_cast<struct ucred*>(CMSG_DATA(hdr));
 35721:   cred->uid = getuid();
 35721:   cred->gid = getgid();
 35721:   cred->pid = getpid();
 35721: 
114869:   ssize_t ret = HANDLE_EINTR(sys_sendmsg(fd, &msg, 0));
 35721:   sys_close(fds[1]);
114869:   if (ret <= 0)
114869:     return false;
 35721: 
 35721:   char b;
114869:   IGNORE_RET(HANDLE_EINTR(sys_read(fds[0], &b, 1)));
 35721: 
 35721:   return true;
 35721: }
 35721: 
 35721: TEST(ExceptionHandlerTest, ExternalDumper) {
 35721:   int fds[2];
 35721:   ASSERT_NE(socketpair(AF_UNIX, SOCK_DGRAM, 0, fds), -1);
 35721:   static const int on = 1;
 35721:   setsockopt(fds[0], SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));
 35721:   setsockopt(fds[1], SOL_SOCKET, SO_PASSCRED, &on, sizeof(on));
 35721: 
 35721:   const pid_t child = fork();
 35721:   if (child == 0) {
 35721:     close(fds[0]);
114869:     ExceptionHandler handler(MinidumpDescriptor("/tmp1"), NULL, NULL,
114869:                              reinterpret_cast<void*>(fds[1]), true, -1);
 35721:     handler.set_crash_handler(CrashHandler);
114869:     *reinterpret_cast<volatile int*>(NULL) = 0;
 35721:   }
 35721:   close(fds[1]);
 35721:   struct msghdr msg = {0};
 35721:   struct iovec iov;
 35721:   static const unsigned kCrashContextSize =
 35721:       sizeof(ExceptionHandler::CrashContext);
 35721:   char context[kCrashContextSize];
 35721:   char control[kControlMsgSize];
 35721:   iov.iov_base = context;
 35721:   iov.iov_len = kCrashContextSize;
 35721:   msg.msg_iov = &iov;
 35721:   msg.msg_iovlen = 1;
 35721:   msg.msg_control = control;
 35721:   msg.msg_controllen = kControlMsgSize;
 35721: 
 35721:   const ssize_t n = HANDLE_EINTR(recvmsg(fds[0], &msg, 0));
114869:   ASSERT_EQ(kCrashContextSize, n);
114869:   ASSERT_EQ(kControlMsgSize, msg.msg_controllen);
114869:   ASSERT_EQ(0, msg.msg_flags);
114869:   ASSERT_EQ(0, close(fds[0]));
 35721: 
 35721:   pid_t crashing_pid = -1;
 35721:   int signal_fd = -1;
 35721:   for (struct cmsghdr *hdr = CMSG_FIRSTHDR(&msg); hdr;
 35721:        hdr = CMSG_NXTHDR(&msg, hdr)) {
 35721:     if (hdr->cmsg_level != SOL_SOCKET)
 35721:       continue;
 35721:     if (hdr->cmsg_type == SCM_RIGHTS) {
 35721:       const unsigned len = hdr->cmsg_len -
 35721:           (((uint8_t*)CMSG_DATA(hdr)) - (uint8_t*)hdr);
114869:       ASSERT_EQ(sizeof(int), len);
114869:       signal_fd = *(reinterpret_cast<int*>(CMSG_DATA(hdr)));
 35721:     } else if (hdr->cmsg_type == SCM_CREDENTIALS) {
 35721:       const struct ucred *cred =
 35721:           reinterpret_cast<struct ucred*>(CMSG_DATA(hdr));
 35721:       crashing_pid = cred->pid;
 35721:     }
 35721:   }
 35721: 
 35721:   ASSERT_NE(crashing_pid, -1);
 35721:   ASSERT_NE(signal_fd, -1);
 35721: 
114869:   AutoTempDir temp_dir;
114869:   string templ = temp_dir.path() + "/exception-handler-unittest";
114869:   ASSERT_TRUE(WriteMinidump(templ.c_str(), crashing_pid, context,
 35721:                             kCrashContextSize));
 35721:   static const char b = 0;
114869:   ASSERT_EQ(1U, (HANDLE_EINTR(write(signal_fd, &b, 1))));
114869:   ASSERT_EQ(0, close(signal_fd));
 35721: 
114869:   ASSERT_NO_FATAL_FAILURE(WaitForProcessToTerminate(child, SIGSEGV));
 35721: 
 35721:   struct stat st;
114869:   ASSERT_EQ(0, stat(templ.c_str(), &st));
114869:   ASSERT_GT(st.st_size, 0U);
114869:   unlink(templ.c_str());
 35721: }
114869: 
114869: TEST(ExceptionHandlerTest, WriteMinidumpExceptionStream) {
114869:   AutoTempDir temp_dir;
114869:   ExceptionHandler handler(MinidumpDescriptor(temp_dir.path()), NULL, NULL,
114869:                            NULL, false, -1);
114869:   ASSERT_TRUE(handler.WriteMinidump());
114869: 
114869:   string minidump_path = handler.minidump_descriptor().path();
114869: 
114869:   // Read the minidump and check the exception stream.
114869:   Minidump minidump(minidump_path);
114869:   ASSERT_TRUE(minidump.Read());
114869:   MinidumpException* exception = minidump.GetException();
114869:   ASSERT_TRUE(exception);
114869:   const MDRawExceptionStream* raw = exception->exception();
114869:   ASSERT_TRUE(raw);
114869:   EXPECT_EQ(MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED,
114869:             raw->exception_record.exception_code);
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, GenerateMultipleDumpsWithFD) {
114869:   AutoTempDir temp_dir;
118328:   string path;
114869:   const int fd = CreateTMPFile(temp_dir.path(), &path);
114869:   ExceptionHandler handler(MinidumpDescriptor(fd), NULL, NULL, NULL, false, -1);
114869:   ASSERT_TRUE(handler.WriteMinidump());
114869:   // Check by the size of the data written to the FD that a minidump was
114869:   // generated.
114869:   off_t size = lseek(fd, 0, SEEK_CUR);
114869:   ASSERT_GT(size, 0);
114869: 
114869:   // Generate another minidump.
114869:   ASSERT_TRUE(handler.WriteMinidump());
114869:   size = lseek(fd, 0, SEEK_CUR);
114869:   ASSERT_GT(size, 0);
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, GenerateMultipleDumpsWithPath) {
114869:   AutoTempDir temp_dir;
114869:   ExceptionHandler handler(MinidumpDescriptor(temp_dir.path()), NULL, NULL,
114869:                            NULL, false, -1);
114869:   ASSERT_TRUE(handler.WriteMinidump());
114869: 
114869:   const MinidumpDescriptor& minidump_1 = handler.minidump_descriptor();
114869:   struct stat st;
114869:   ASSERT_EQ(0, stat(minidump_1.path(), &st));
114869:   ASSERT_GT(st.st_size, 0U);
118328:   string minidump_1_path(minidump_1.path());
114869:   // Check it is a valid minidump.
114869:   Minidump minidump1(minidump_1_path);
114869:   ASSERT_TRUE(minidump1.Read());
114869:   unlink(minidump_1.path());
114869: 
114869:   // Generate another minidump, it should go to a different file.
114869:   ASSERT_TRUE(handler.WriteMinidump());
114869:   const MinidumpDescriptor& minidump_2 = handler.minidump_descriptor();
114869:   ASSERT_EQ(0, stat(minidump_2.path(), &st));
114869:   ASSERT_GT(st.st_size, 0U);
118328:   string minidump_2_path(minidump_2.path());
114869:   // Check it is a valid minidump.
114869:   Minidump minidump2(minidump_2_path);
114869:   ASSERT_TRUE(minidump2.Read());
114869:   unlink(minidump_2.path());
114869: 
114869:   // 2 distinct files should be produced.
114869:   ASSERT_STRNE(minidump_1_path.c_str(), minidump_2_path.c_str());
114869: }
114869: 
114869: // Test that an additional memory region can be added to the minidump.
114869: TEST(ExceptionHandlerTest, AdditionalMemory) {
114869:   const u_int32_t kMemorySize = sysconf(_SC_PAGESIZE);
114869: 
114869:   // Get some heap memory.
114869:   u_int8_t* memory = new u_int8_t[kMemorySize];
114869:   const uintptr_t kMemoryAddress = reinterpret_cast<uintptr_t>(memory);
114869:   ASSERT_TRUE(memory);
114869: 
114869:   // Stick some data into the memory so the contents can be verified.
114869:   for (u_int32_t i = 0; i < kMemorySize; ++i) {
114869:     memory[i] = i % 255;
114869:   }
114869: 
114869:   AutoTempDir temp_dir;
114869:   ExceptionHandler handler(
114869:       MinidumpDescriptor(temp_dir.path()), NULL, NULL, NULL, true, -1);
114869: 
114869:   // Add the memory region to the list of memory to be included.
114869:   handler.RegisterAppMemory(memory, kMemorySize);
114869:   handler.WriteMinidump();
114869: 
114869:   const MinidumpDescriptor& minidump_desc = handler.minidump_descriptor();
114869: 
114869:   // Read the minidump. Ensure that the memory region is present
114869:   Minidump minidump(minidump_desc.path());
114869:   ASSERT_TRUE(minidump.Read());
114869: 
114869:   MinidumpMemoryList* dump_memory_list = minidump.GetMemoryList();
114869:   ASSERT_TRUE(dump_memory_list);
114869:   const MinidumpMemoryRegion* region =
114869:     dump_memory_list->GetMemoryRegionForAddress(kMemoryAddress);
114869:   ASSERT_TRUE(region);
114869: 
114869:   EXPECT_EQ(kMemoryAddress, region->GetBase());
114869:   EXPECT_EQ(kMemorySize, region->GetSize());
114869: 
114869:   // Verify memory contents.
114869:   EXPECT_EQ(0, memcmp(region->GetMemory(), memory, kMemorySize));
114869: 
114869:   delete[] memory;
114869: }
114869: 
114869: // Test that a memory region that was previously registered
114869: // can be unregistered.
114869: TEST(ExceptionHandlerTest, AdditionalMemoryRemove) {
114869:   const u_int32_t kMemorySize = sysconf(_SC_PAGESIZE);
114869: 
114869:   // Get some heap memory.
114869:   u_int8_t* memory = new u_int8_t[kMemorySize];
114869:   const uintptr_t kMemoryAddress = reinterpret_cast<uintptr_t>(memory);
114869:   ASSERT_TRUE(memory);
114869: 
114869:   AutoTempDir temp_dir;
114869:   ExceptionHandler handler(
114869:       MinidumpDescriptor(temp_dir.path()), NULL, NULL, NULL, true, -1);
114869: 
114869:   // Add the memory region to the list of memory to be included.
114869:   handler.RegisterAppMemory(memory, kMemorySize);
114869: 
114869:   // ...and then remove it
114869:   handler.UnregisterAppMemory(memory);
114869:   handler.WriteMinidump();
114869: 
114869:   const MinidumpDescriptor& minidump_desc = handler.minidump_descriptor();
114869: 
114869:   // Read the minidump. Ensure that the memory region is not present.
114869:   Minidump minidump(minidump_desc.path());
114869:   ASSERT_TRUE(minidump.Read());
114869: 
114869:   MinidumpMemoryList* dump_memory_list = minidump.GetMemoryList();
114869:   ASSERT_TRUE(dump_memory_list);
114869:   const MinidumpMemoryRegion* region =
114869:     dump_memory_list->GetMemoryRegionForAddress(kMemoryAddress);
114869:   EXPECT_FALSE(region);
114869: 
114869:   delete[] memory;
114869: }
114869: 
114869: static bool SimpleCallback(const MinidumpDescriptor& descriptor,
114869:                            void* context,
114869:                            bool succeeded) {
114869:   string* filename = reinterpret_cast<string*>(context);
114869:   *filename = descriptor.path();
114869:   return true;
114869: }
114869: 
114869: TEST(ExceptionHandlerTest, WriteMinidumpForChild) {
114869:   int fds[2];
114869:   ASSERT_NE(-1, pipe(fds));
114869: 
114869:   const pid_t child = fork();
114869:   if (child == 0) {
114869:     close(fds[1]);
114869:     char b;
114869:     HANDLE_EINTR(read(fds[0], &b, sizeof(b)));
114869:     close(fds[0]);
114869:     syscall(__NR_exit);
114869:   }
114869:   close(fds[0]);
114869: 
114869:   AutoTempDir temp_dir;
114869:   string minidump_filename;
114869:   ASSERT_TRUE(
114869:     ExceptionHandler::WriteMinidumpForChild(child, child,
114869:                                             temp_dir.path(), SimpleCallback,
114869:                                             (void*)&minidump_filename));
114869: 
114869:   Minidump minidump(minidump_filename);
114869:   ASSERT_TRUE(minidump.Read());
114869:   // Check that the crashing thread is the main thread of |child|
114869:   MinidumpException* exception = minidump.GetException();
114869:   ASSERT_TRUE(exception);
114869:   u_int32_t thread_id;
114869:   ASSERT_TRUE(exception->GetThreadID(&thread_id));
114869:   EXPECT_EQ(child, thread_id);
114869: 
114869:   const MDRawExceptionStream* raw = exception->exception();
114869:   ASSERT_TRUE(raw);
114869:   EXPECT_EQ(MD_EXCEPTION_CODE_LIN_DUMP_REQUESTED,
114869:             raw->exception_record.exception_code);
114869: 
114869:   close(fds[1]);
114869:   unlink(minidump_filename.c_str());
114869: }
